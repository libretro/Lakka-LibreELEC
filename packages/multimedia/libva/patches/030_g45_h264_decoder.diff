commit 172b228fc17e38b753c6b1bb7adbd54cba96ce5e
Author: Gwenole Beauchesne <gb@gb-desktop.(none)>
Date:   Sun Apr 25 09:23:31 2010 +0200

    [G45] Merge H.264 decoder for Intel Ironlake from i965_h264 branch (2010/04/19).

diff --git a/configure.ac b/configure.ac
index eedfe4c..b119003 100644
--- a/configure.ac
+++ b/configure.ac
@@ -122,6 +122,8 @@ AC_OUTPUT([
 	dummy_drv_video/Makefile
 	i965_drv_video/Makefile
 	i965_drv_video/shaders/Makefile
+	i965_drv_video/shaders/h264/Makefile
+	i965_drv_video/shaders/h264/mc/Makefile
 	i965_drv_video/shaders/mpeg2/Makefile
 	i965_drv_video/shaders/mpeg2/vld/Makefile
 	i965_drv_video/shaders/render/Makefile
diff --git a/i965_drv_video/Makefile.am b/i965_drv_video/Makefile.am
index 88b5590..bb160ae 100644
--- a/i965_drv_video/Makefile.am
+++ b/i965_drv_video/Makefile.am
@@ -32,21 +32,29 @@ i965_drv_video_la_LIBADD = ../va/libva-x11.la -lpthread
 i965_drv_video_la_SOURCES =	\
 	object_heap.c		\
 	intel_batchbuffer.c	\
+	intel_batchbuffer_dump.c\
 	intel_memman.c		\
 	intel_driver.c		\
 	i965_media.c		\
 	i965_media_mpeg2.c	\
+	i965_media_h264.c	\
 	i965_render.c		\
-	i965_drv_video.c
+	i965_drv_video.c	\
+	i965_avc_bsd.c		\
+	i965_avc_hw_scoreboard.c
 
 noinst_HEADERS =                \
 	object_heap.h           \
 	intel_batchbuffer.h     \
+	intel_batchbuffer_dump.h\
 	intel_memman.h          \
 	intel_driver.h          \
 	i965_media.h            \
 	i965_media_mpeg2.h      \
+	i965_media_h264.h	\
 	i965_render.h           \
 	i965_drv_video.h        \
 	i965_defines.h          \
-	i965_structs.h
+	i965_structs.h		\
+	i965_avc_bsd.h		\
+	i965_avc_hw_scoreboard.h
diff --git a/i965_drv_video/i965_avc_bsd.c b/i965_drv_video/i965_avc_bsd.c
new file mode 100644
index 0000000..d00fe7d
--- /dev/null
+++ b/i965_drv_video/i965_avc_bsd.c
@@ -0,0 +1,1023 @@
+/*
+ * Copyright © 2010 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sub license, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+ * IN NO EVENT SHALL PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR
+ * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors:
+ *    Xiang Haihao <haihao.xiang@intel.com>
+ *
+ */
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <assert.h>
+
+#include "va_backend.h"
+
+#include "intel_batchbuffer.h"
+#include "intel_driver.h"
+
+#include "i965_defines.h"
+#include "i965_drv_video.h"
+#include "i965_avc_bsd.h"
+#include "i965_media_h264.h"
+#include "i965_media.h"
+
+static void 
+i965_avc_bsd_free_private_surface_data(void **data)
+{
+    struct i965_avc_bsd_surface *avc_bsd_surface = *data;
+
+    if (!avc_bsd_surface)
+        return;
+
+    dri_bo_unreference(avc_bsd_surface->direct_mv_wr_top_bo);
+    avc_bsd_surface->direct_mv_wr_top_bo = NULL;
+    dri_bo_unreference(avc_bsd_surface->direct_mv_wr_bottom_bo);
+    avc_bsd_surface->direct_mv_wr_bottom_bo = NULL;
+    free(avc_bsd_surface);
+    *data = NULL;
+}
+
+static void
+i965_avc_bsd_initialize_private_surface_data(VADriverContextP ctx, struct object_surface *obj_surface)
+{
+    struct i965_driver_data *i965 = i965_driver_data(ctx);
+    struct i965_avc_bsd_surface *avc_bsd_surface = obj_surface->private_data;
+
+    obj_surface->free_private_data = i965_avc_bsd_free_private_surface_data;
+
+    if (!avc_bsd_surface) {
+        avc_bsd_surface = calloc(sizeof(struct i965_avc_bsd_surface), 1);
+
+        avc_bsd_surface->direct_mv_wr_top_bo = dri_bo_alloc(i965->intel.bufmgr,
+                                                            "direct mv wr top",
+                                                            0x90000,
+                                                            64);
+        assert(avc_bsd_surface->direct_mv_wr_top_bo);
+        avc_bsd_surface->direct_mv_wr_bottom_bo = dri_bo_alloc(i965->intel.bufmgr,
+                                                               "direct mv wr bottom",
+                                                               0x90000,
+                                                               64);
+        assert(avc_bsd_surface->direct_mv_wr_bottom_bo);
+        obj_surface->private_data = avc_bsd_surface;
+    }
+
+    avc_bsd_surface->direct_mv_flag = -1;
+}
+
+static void
+i965_bsd_ind_obj_base_address(VADriverContextP ctx, struct decode_state *decode_state, int slice)
+{
+    dri_bo *ind_bo = decode_state->slice_datas[slice]->bo;
+
+    BEGIN_BCS_BATCH(ctx, 3);
+    OUT_BCS_BATCH(ctx, CMD_BSD_IND_OBJ_BASE_ADDR | (3 - 2));
+    OUT_BCS_RELOC(ctx, ind_bo,
+                  I915_GEM_DOMAIN_INSTRUCTION, 0,
+                  0);
+    OUT_BCS_BATCH(ctx, 0);
+    ADVANCE_BCS_BATCH(ctx);
+}
+
+static void
+i965_avc_bsd_img_state(VADriverContextP ctx, struct decode_state *decode_state)
+{
+    int qm_present_flag;
+    int img_struct;
+    int mbaff_frame_flag;
+    unsigned int avc_it_command_header;
+    unsigned int width_in_mbs, height_in_mbs;
+    VAPictureParameterBufferH264 *pic_param;
+
+    if (decode_state->iq_matrix && decode_state->iq_matrix->buffer)
+        qm_present_flag = 1;
+    else
+        qm_present_flag = 0; /* built-in QM matrices */
+
+    assert(decode_state->pic_param && decode_state->pic_param->buffer);
+    pic_param = (VAPictureParameterBufferH264 *)decode_state->pic_param->buffer;
+
+    assert(!(pic_param->CurrPic.flags & VA_PICTURE_H264_INVALID));
+
+    if (pic_param->CurrPic.flags & VA_PICTURE_H264_TOP_FIELD)
+        img_struct = 1;
+    else if (pic_param->CurrPic.flags & VA_PICTURE_H264_BOTTOM_FIELD)
+        img_struct = 3;
+    else
+        img_struct = 0;
+
+    if ((img_struct & 0x1) == 0x1) {
+        assert(pic_param->pic_fields.bits.field_pic_flag == 0x1);
+    } else {
+        assert(pic_param->pic_fields.bits.field_pic_flag == 0x0);
+    }
+
+    if (pic_param->seq_fields.bits.frame_mbs_only_flag) { /* a frame containing only frame macroblocks */
+        assert(pic_param->seq_fields.bits.mb_adaptive_frame_field_flag == 0);
+        assert(pic_param->pic_fields.bits.field_pic_flag == 0);
+    } else {
+        assert(pic_param->seq_fields.bits.direct_8x8_inference_flag == 1); /* see H.264 spec */
+    }
+
+    mbaff_frame_flag = (pic_param->seq_fields.bits.mb_adaptive_frame_field_flag &&
+                        !pic_param->pic_fields.bits.field_pic_flag);
+
+    width_in_mbs = ((pic_param->picture_width_in_mbs_minus1 + 1) & 0xff);
+    height_in_mbs = ((pic_param->picture_height_in_mbs_minus1 + 1) & 0xff); /* frame height */
+                                                                               
+    assert(!((width_in_mbs * height_in_mbs) & 0x8000)); /* hardware requirement */
+
+    /* BSD unit doesn't support 4:2:2 and 4:4:4 picture */
+    assert(pic_param->seq_fields.bits.chroma_format_idc == 0 || /* monochrome picture */
+           pic_param->seq_fields.bits.chroma_format_idc == 1);  /* 4:2:0 */
+    assert(pic_param->seq_fields.bits.residual_colour_transform_flag == 0); /* only available for 4:4:4 */
+
+    avc_it_command_header = (CMD_MEDIA_OBJECT_EX | (12 - 2));
+
+    BEGIN_BCS_BATCH(ctx, 6);
+    OUT_BCS_BATCH(ctx, CMD_AVC_BSD_IMG_STATE | (6 - 2));
+    OUT_BCS_BATCH(ctx, 
+                  ((width_in_mbs * height_in_mbs) & 0x7fff));
+    OUT_BCS_BATCH(ctx, 
+                  (height_in_mbs << 16) | 
+                  (width_in_mbs << 0));
+    OUT_BCS_BATCH(ctx, 
+                  (pic_param->second_chroma_qp_index_offset << 24) |
+                  (pic_param->chroma_qp_index_offset << 16) | 
+                  (SCAN_RASTER_ORDER << 15) | /* AVC ILDB Data */
+                  (SCAN_SPECIAL_ORDER << 14) | /* AVC IT Command */
+                  (SCAN_RASTER_ORDER << 13) | /* AVC IT Data */
+                  (1 << 12) | /* always 1, hardware requirement */
+                  (qm_present_flag << 10) |
+                  (img_struct << 8) |
+                  (16 << 0)); /* FIXME: always support 16 reference frames ??? */
+    OUT_BCS_BATCH(ctx,
+                  (RESIDUAL_DATA_OFFSET << 24) | /* residual data offset */
+                  (0 << 17) | /* don't overwrite SRT */
+                  (0 << 16) | /* Un-SRT (Unsynchronized Root Thread) */
+                  (0 << 12) | /* FIXME: no 16MV ??? */
+                  (pic_param->seq_fields.bits.chroma_format_idc << 10) |
+                  (1 << 8)  | /* Enable ILDB writing output */
+                  (pic_param->pic_fields.bits.entropy_coding_mode_flag << 7) |
+                  ((!pic_param->pic_fields.bits.reference_pic_flag) << 6) |
+                  (pic_param->pic_fields.bits.constrained_intra_pred_flag << 5) |
+                  (pic_param->seq_fields.bits.direct_8x8_inference_flag << 4) |
+                  (pic_param->pic_fields.bits.transform_8x8_mode_flag << 3) |
+                  (pic_param->seq_fields.bits.frame_mbs_only_flag << 2) |
+                  (mbaff_frame_flag << 1) |
+                  (pic_param->pic_fields.bits.field_pic_flag << 0));
+    OUT_BCS_BATCH(ctx, avc_it_command_header);
+    ADVANCE_BCS_BATCH(ctx);
+}
+
+static void
+i965_avc_bsd_qm_state(VADriverContextP ctx, struct decode_state *decode_state)
+{
+    int cmd_len;
+    VAIQMatrixBufferH264 *iq_matrix;
+    VAPictureParameterBufferH264 *pic_param;
+
+    if (!decode_state->iq_matrix || !decode_state->iq_matrix->buffer)
+        return;
+
+    iq_matrix = (VAIQMatrixBufferH264 *)decode_state->iq_matrix->buffer;
+
+    assert(decode_state->pic_param && decode_state->pic_param->buffer);
+    pic_param = (VAPictureParameterBufferH264 *)decode_state->pic_param->buffer;
+
+    cmd_len = 2 + 6 * 4; /* always load six 4x4 scaling matrices */
+
+    if (pic_param->pic_fields.bits.transform_8x8_mode_flag)
+        cmd_len += 2 * 16; /* load two 8x8 scaling matrices */
+
+    BEGIN_BCS_BATCH(ctx, cmd_len);
+    OUT_BCS_BATCH(ctx, CMD_AVC_BSD_QM_STATE | (cmd_len - 2));
+
+    if (pic_param->pic_fields.bits.transform_8x8_mode_flag)
+        OUT_BCS_BATCH(ctx, 
+                      (0x0  << 8) | /* don't use default built-in matrices */
+                      (0xff << 0)); /* six 4x4 and two 8x8 scaling matrices */
+    else
+        OUT_BCS_BATCH(ctx, 
+                      (0x0  << 8) | /* don't use default built-in matrices */
+                      (0x3f << 0)); /* six 4x4 scaling matrices */
+
+    intel_batchbuffer_data_bcs(ctx, &iq_matrix->ScalingList4x4[0][0], 6 * 4 * 4);
+
+    if (pic_param->pic_fields.bits.transform_8x8_mode_flag)
+        intel_batchbuffer_data_bcs(ctx, &iq_matrix->ScalingList8x8[0][0], 2 * 16 * 4);
+
+    ADVANCE_BCS_BATCH(ctx);
+}
+
+static void
+i965_avc_bsd_slice_state(VADriverContextP ctx, 
+                         VAPictureParameterBufferH264 *pic_param, 
+                         VASliceParameterBufferH264 *slice_param)
+{
+    struct i965_driver_data *i965 = i965_driver_data(ctx);
+    struct i965_media_state *media_state = &i965->media_state;
+    struct i965_h264_context *i965_h264_context = (struct i965_h264_context *)media_state->private_context;
+    int present_flag, cmd_len, list, j;
+    struct {
+        unsigned char bottom_idc:1;
+        unsigned char frame_store_index:4;
+        unsigned char field_picture:1;
+        unsigned char long_term:1;
+        unsigned char non_exist:1;
+    } refs[32];
+    char weightoffsets[32 * 6];
+
+    /* don't issue SLICE_STATE for intra-prediction decoding */
+    if (slice_param->slice_type == SLICE_TYPE_I ||
+        slice_param->slice_type == SLICE_TYPE_SI)
+        return;
+
+    cmd_len = 2;
+
+    if (slice_param->slice_type == SLICE_TYPE_P ||
+        slice_param->slice_type == SLICE_TYPE_SP) {
+        present_flag = PRESENT_REF_LIST0;
+        cmd_len += 8;
+    } else { 
+        present_flag = PRESENT_REF_LIST0 | PRESENT_REF_LIST1;
+        cmd_len += 16;
+    }
+
+    if ((slice_param->slice_type == SLICE_TYPE_P ||
+         slice_param->slice_type == SLICE_TYPE_SP) && 
+        (pic_param->pic_fields.bits.weighted_pred_flag == 1)) {
+        present_flag |= PRESENT_WEIGHT_OFFSET_L0;
+        cmd_len += 48;
+    }
+
+    if ((slice_param->slice_type == SLICE_TYPE_B) &&
+        (pic_param->pic_fields.bits.weighted_bipred_idc == 1)) {
+        present_flag |= PRESENT_WEIGHT_OFFSET_L0 | PRESENT_WEIGHT_OFFSET_L1;
+        cmd_len += 96;
+    }
+
+    BEGIN_BCS_BATCH(ctx, cmd_len);
+    OUT_BCS_BATCH(ctx, CMD_AVC_BSD_SLICE_STATE | (cmd_len - 2));
+    OUT_BCS_BATCH(ctx, present_flag);
+
+    for (list = 0; list < 2; list++) {
+        int flag;
+        VAPictureH264 *va_pic;
+
+        if (list == 0) {
+            flag = PRESENT_REF_LIST0;
+            va_pic = slice_param->RefPicList0;
+        } else {
+            flag = PRESENT_REF_LIST1;
+            va_pic = slice_param->RefPicList1;
+        }
+
+        if (!(present_flag & flag))
+            continue;
+
+        for (j = 0; j < 32; j++) {
+            if (va_pic->flags & VA_PICTURE_H264_INVALID) {
+                refs[j].non_exist = 1;
+                refs[j].long_term = 1;
+                refs[j].field_picture = 1;
+                refs[j].frame_store_index = 0xf;
+                refs[j].bottom_idc = 1;
+            } else {
+                int frame_idx;
+                
+                for (frame_idx = 0; frame_idx < ARRAY_ELEMS(i965_h264_context->fsid_list); frame_idx++) {
+                    if (i965_h264_context->fsid_list[frame_idx].surface_id != VA_INVALID_ID &&
+                        va_pic->picture_id == i965_h264_context->fsid_list[frame_idx].surface_id) {
+                        assert(frame_idx == i965_h264_context->fsid_list[frame_idx].frame_store_id);
+                        break;
+                    }
+                }
+
+                assert(frame_idx < ARRAY_ELEMS(i965_h264_context->fsid_list));
+                
+                refs[j].non_exist = 0;
+                refs[j].long_term = !!(va_pic->flags & VA_PICTURE_H264_LONG_TERM_REFERENCE);
+                refs[j].field_picture = !!(va_pic->flags & 
+                                           (VA_PICTURE_H264_TOP_FIELD | 
+                                            VA_PICTURE_H264_BOTTOM_FIELD));
+                refs[j].frame_store_index = frame_idx;
+                refs[j].bottom_idc = !!(va_pic->flags & VA_PICTURE_H264_BOTTOM_FIELD);
+            }
+
+            va_pic++;
+        }
+        
+        intel_batchbuffer_data_bcs(ctx, refs, sizeof(refs));
+    }
+
+    i965_h264_context->weight128_luma_l0 = 0;
+    i965_h264_context->weight128_luma_l1 = 0;
+    i965_h264_context->weight128_chroma_l0 = 0;
+    i965_h264_context->weight128_chroma_l1 = 0;
+
+    i965_h264_context->weight128_offset0_flag = 0;
+    i965_h264_context->weight128_offset0 = 0;
+
+    if (present_flag & PRESENT_WEIGHT_OFFSET_L0) {
+        for (j = 0; j < 32; j++) {
+            weightoffsets[j * 6 + 0] = slice_param->luma_offset_l0[j];
+            weightoffsets[j * 6 + 1] = slice_param->luma_weight_l0[j];
+            weightoffsets[j * 6 + 2] = slice_param->chroma_offset_l0[j][0];
+            weightoffsets[j * 6 + 3] = slice_param->chroma_weight_l0[j][0];
+            weightoffsets[j * 6 + 4] = slice_param->chroma_offset_l0[j][1];
+            weightoffsets[j * 6 + 5] = slice_param->chroma_weight_l0[j][1];
+
+            if (pic_param->pic_fields.bits.weighted_pred_flag == 1 ||
+                pic_param->pic_fields.bits.weighted_bipred_idc == 1) {
+                if (i965_h264_context->use_hw_w128) {
+                    if (slice_param->luma_weight_l0[j] == 128)
+                        i965_h264_context->weight128_luma_l0 |= (1 << j);
+
+                    if (slice_param->chroma_weight_l0[j][0] == 128 ||
+                        slice_param->chroma_weight_l0[j][1] == 128)
+                        i965_h264_context->weight128_chroma_l0 |= (1 << j);
+                } else {
+                    /* FIXME: workaround for weight 128 */
+                    if (slice_param->luma_weight_l0[j] == 128 ||
+                        slice_param->chroma_weight_l0[j][0] == 128 ||
+                        slice_param->chroma_weight_l0[j][1] == 128)
+                        i965_h264_context->weight128_offset0_flag = 1;
+                }
+            }
+        }
+
+        intel_batchbuffer_data_bcs(ctx, weightoffsets, sizeof(weightoffsets));
+    }
+
+    if (present_flag & PRESENT_WEIGHT_OFFSET_L1) {
+        for (j = 0; j < 32; j++) {
+            weightoffsets[j * 6 + 0] = slice_param->luma_offset_l1[j];
+            weightoffsets[j * 6 + 1] = slice_param->luma_weight_l1[j];
+            weightoffsets[j * 6 + 2] = slice_param->chroma_offset_l1[j][0];
+            weightoffsets[j * 6 + 3] = slice_param->chroma_weight_l1[j][0];
+            weightoffsets[j * 6 + 4] = slice_param->chroma_offset_l1[j][1];
+            weightoffsets[j * 6 + 5] = slice_param->chroma_weight_l1[j][1];
+
+            if (pic_param->pic_fields.bits.weighted_bipred_idc == 1) {
+                if (i965_h264_context->use_hw_w128) {
+                    if (slice_param->luma_weight_l1[j] == 128)
+                        i965_h264_context->weight128_luma_l1 |= (1 << j);
+
+                    if (slice_param->chroma_weight_l1[j][0] == 128 ||
+                        slice_param->chroma_weight_l1[j][1] == 128)
+                        i965_h264_context->weight128_chroma_l1 |= (1 << j);
+                } else {
+                    if (slice_param->luma_weight_l0[j] == 128 ||
+                        slice_param->chroma_weight_l0[j][0] == 128 ||
+                        slice_param->chroma_weight_l0[j][1] == 128)
+                        i965_h264_context->weight128_offset0_flag = 1;
+                }
+            }
+        }
+
+        intel_batchbuffer_data_bcs(ctx, weightoffsets, sizeof(weightoffsets));
+    }
+
+    ADVANCE_BCS_BATCH(ctx);
+}
+
+static void
+i965_avc_bsd_buf_base_state(VADriverContextP ctx,
+                            VAPictureParameterBufferH264 *pic_param, 
+                            VASliceParameterBufferH264 *slice_param)
+{
+    struct i965_driver_data *i965 = i965_driver_data(ctx);
+    struct i965_media_state *media_state = &i965->media_state;
+    struct i965_h264_context *i965_h264_context;
+    struct i965_avc_bsd_context *i965_avc_bsd_context;
+    int i, j;
+    VAPictureH264 *va_pic;
+    struct object_surface *obj_surface;
+    struct i965_avc_bsd_surface *avc_bsd_surface;
+
+    assert(media_state->private_context);
+    i965_h264_context = (struct i965_h264_context *)media_state->private_context;
+    i965_avc_bsd_context = &i965_h264_context->i965_avc_bsd_context;
+
+    BEGIN_BCS_BATCH(ctx, 74);
+    OUT_BCS_BATCH(ctx, CMD_AVC_BSD_BUF_BASE_STATE | (74 - 2));
+    OUT_BCS_RELOC(ctx, i965_avc_bsd_context->bsd_raw_store.bo,
+                  I915_GEM_DOMAIN_INSTRUCTION, I915_GEM_DOMAIN_INSTRUCTION,
+                  0);
+    OUT_BCS_RELOC(ctx, i965_avc_bsd_context->mpr_row_store.bo,
+                  I915_GEM_DOMAIN_INSTRUCTION, I915_GEM_DOMAIN_INSTRUCTION,
+                  0);
+    OUT_BCS_RELOC(ctx, i965_h264_context->avc_it_command_mb_info.bo,
+                  I915_GEM_DOMAIN_INSTRUCTION, I915_GEM_DOMAIN_INSTRUCTION,
+                  i965_h264_context->avc_it_command_mb_info.mbs * i965_h264_context->use_avc_hw_scoreboard * MB_CMD_IN_BYTES);
+    OUT_BCS_RELOC(ctx, i965_h264_context->avc_it_data.bo,
+                  I915_GEM_DOMAIN_INSTRUCTION, I915_GEM_DOMAIN_INSTRUCTION,
+                  (i965_h264_context->avc_it_data.write_offset << 6));
+    OUT_BCS_RELOC(ctx, i965_avc_bsd_context->ildb_data.bo,
+                  I915_GEM_DOMAIN_INSTRUCTION, I915_GEM_DOMAIN_INSTRUCTION,
+                  0);
+
+    for (i = 0; i < ARRAY_ELEMS(i965_h264_context->fsid_list); i++) {
+        if (i965_h264_context->fsid_list[i].surface_id != VA_INVALID_ID) {
+            int found = 0;
+            for (j = 0; j < ARRAY_ELEMS(pic_param->ReferenceFrames); j++) {
+                va_pic = &pic_param->ReferenceFrames[j];
+                
+                if (va_pic->flags & VA_PICTURE_H264_INVALID)
+                    continue;
+
+                if (va_pic->picture_id == i965_h264_context->fsid_list[i].surface_id) {
+                    found = 1;
+                    break;
+                }
+            }
+
+            assert(found == 1);
+
+            if (!(va_pic->flags & VA_PICTURE_H264_INVALID)) {
+                obj_surface = SURFACE(va_pic->picture_id);
+                assert(obj_surface);
+                avc_bsd_surface = obj_surface->private_data;
+            
+                if (avc_bsd_surface == NULL) {
+                    OUT_BCS_BATCH(ctx, 0);
+                    OUT_BCS_BATCH(ctx, 0);
+                } else {
+                    assert(avc_bsd_surface->direct_mv_flag != -1);
+
+                    OUT_BCS_RELOC(ctx, avc_bsd_surface->direct_mv_wr_top_bo,
+                                  I915_GEM_DOMAIN_INSTRUCTION, 0,
+                                  0);
+
+                    if (avc_bsd_surface->direct_mv_flag == 1)
+                        OUT_BCS_RELOC(ctx, avc_bsd_surface->direct_mv_wr_bottom_bo,
+                                      I915_GEM_DOMAIN_INSTRUCTION, 0,
+                                      0);
+                    else
+                        OUT_BCS_RELOC(ctx, avc_bsd_surface->direct_mv_wr_top_bo,
+                                      I915_GEM_DOMAIN_INSTRUCTION, 0,
+                                      0);
+                }
+            } 
+        } else {
+            OUT_BCS_BATCH(ctx, 0);
+            OUT_BCS_BATCH(ctx, 0);
+        }
+    }
+
+    va_pic = &pic_param->CurrPic;
+    assert(!(va_pic->flags & VA_PICTURE_H264_INVALID));
+    obj_surface = SURFACE(va_pic->picture_id);
+    assert(obj_surface);
+    i965_avc_bsd_initialize_private_surface_data(ctx, obj_surface);
+    avc_bsd_surface = obj_surface->private_data;
+    avc_bsd_surface->direct_mv_flag = (pic_param->pic_fields.bits.field_pic_flag &&
+                                       !pic_param->seq_fields.bits.direct_8x8_inference_flag);
+
+    OUT_BCS_RELOC(ctx, avc_bsd_surface->direct_mv_wr_top_bo,
+                  I915_GEM_DOMAIN_INSTRUCTION, I915_GEM_DOMAIN_INSTRUCTION,
+                  0);
+
+    if (avc_bsd_surface->direct_mv_flag == 1)
+        OUT_BCS_RELOC(ctx, avc_bsd_surface->direct_mv_wr_bottom_bo,
+                      I915_GEM_DOMAIN_INSTRUCTION, I915_GEM_DOMAIN_INSTRUCTION,
+                      0);
+    else
+        OUT_BCS_RELOC(ctx, avc_bsd_surface->direct_mv_wr_top_bo,
+                      I915_GEM_DOMAIN_INSTRUCTION, I915_GEM_DOMAIN_INSTRUCTION,
+                      0);
+
+    /* POC List */
+    for (i = 0; i < ARRAY_ELEMS(i965_h264_context->fsid_list); i++) {
+        if (i965_h264_context->fsid_list[i].surface_id != VA_INVALID_ID) {
+            int found = 0;
+            for (j = 0; j < ARRAY_ELEMS(pic_param->ReferenceFrames); j++) {
+                va_pic = &pic_param->ReferenceFrames[j];
+                
+                if (va_pic->flags & VA_PICTURE_H264_INVALID)
+                    continue;
+
+                if (va_pic->picture_id == i965_h264_context->fsid_list[i].surface_id) {
+                    found = 1;
+                    break;
+                }
+            }
+
+            assert(found == 1);
+
+            if (!(va_pic->flags & VA_PICTURE_H264_INVALID)) {
+                OUT_BCS_BATCH(ctx, va_pic->TopFieldOrderCnt);
+                OUT_BCS_BATCH(ctx, va_pic->BottomFieldOrderCnt);
+            } 
+        } else {
+            OUT_BCS_BATCH(ctx, 0);
+            OUT_BCS_BATCH(ctx, 0);
+        }
+    }
+
+    va_pic = &pic_param->CurrPic;
+    OUT_BCS_BATCH(ctx, va_pic->TopFieldOrderCnt);
+    OUT_BCS_BATCH(ctx, va_pic->BottomFieldOrderCnt);
+
+    ADVANCE_BCS_BATCH(ctx);
+}
+
+static void
+g4x_avc_bsd_object(VADriverContextP ctx, 
+                   struct decode_state *decode_state,
+                   VAPictureParameterBufferH264 *pic_param,
+                   VASliceParameterBufferH264 *slice_param)
+{
+    int width_in_mbs = pic_param->picture_width_in_mbs_minus1 + 1;
+    int height_in_mbs = pic_param->picture_height_in_mbs_minus1 + 1; /* frame height */
+
+    if (slice_param) {
+        int encrypted, counter_value, cmd_len;
+        int slice_hor_pos, slice_ver_pos;
+        int num_ref_idx_l0, num_ref_idx_l1;
+        int mbaff_picture = (!pic_param->pic_fields.bits.field_pic_flag &&
+                             pic_param->seq_fields.bits.mb_adaptive_frame_field_flag);
+        int slice_data_bit_offset;
+        int weighted_pred_idc = 0;
+        int first_mb_in_slice = 0;
+        int slice_type;
+
+        encrypted = 0; /* FIXME: which flag in VAAPI is used for encryption? */
+
+        if (encrypted) {
+            cmd_len = 9;
+            counter_value = 0; /* FIXME: ??? */
+        } else 
+            cmd_len = 8;
+
+        slice_data_bit_offset = slice_param->slice_data_bit_offset;    
+
+        if (pic_param->pic_fields.bits.entropy_coding_mode_flag == ENTROPY_CABAC)
+            slice_data_bit_offset = ALIGN(slice_data_bit_offset, 0x8);
+
+        if (slice_param->slice_type == SLICE_TYPE_I ||
+            slice_param->slice_type == SLICE_TYPE_SI)
+            slice_type = SLICE_TYPE_I;
+        else if (slice_param->slice_type == SLICE_TYPE_P ||
+                 slice_param->slice_type == SLICE_TYPE_SP)
+            slice_type = SLICE_TYPE_P;
+        else {
+            assert(slice_param->slice_type == SLICE_TYPE_B);
+            slice_type = SLICE_TYPE_B;
+        }
+
+        if (slice_type == SLICE_TYPE_I) {
+            assert(slice_param->num_ref_idx_l0_active_minus1 == 0);
+            assert(slice_param->num_ref_idx_l1_active_minus1 == 0);
+            num_ref_idx_l0 = 0;
+            num_ref_idx_l1 = 0;
+        } else if (slice_type == SLICE_TYPE_P) {
+            assert(slice_param->num_ref_idx_l1_active_minus1 == 0);
+            num_ref_idx_l0 = slice_param->num_ref_idx_l0_active_minus1 + 1;
+            num_ref_idx_l1 = 0;
+        } else {
+            num_ref_idx_l0 = slice_param->num_ref_idx_l0_active_minus1 + 1;
+            num_ref_idx_l1 = slice_param->num_ref_idx_l1_active_minus1 + 1;
+        }
+
+        if (slice_type == SLICE_TYPE_P)
+            weighted_pred_idc = pic_param->pic_fields.bits.weighted_pred_flag;
+        else if (slice_type == SLICE_TYPE_B)
+            weighted_pred_idc = pic_param->pic_fields.bits.weighted_bipred_idc;
+
+        first_mb_in_slice = slice_param->first_mb_in_slice;
+        slice_hor_pos = first_mb_in_slice % width_in_mbs; 
+        slice_ver_pos = first_mb_in_slice / width_in_mbs;
+        first_mb_in_slice = (slice_ver_pos << mbaff_picture) * width_in_mbs + slice_hor_pos;
+        slice_hor_pos <<= mbaff_picture;
+
+        BEGIN_BCS_BATCH(ctx, cmd_len);
+        OUT_BCS_BATCH(ctx, CMD_AVC_BSD_OBJECT | (cmd_len - 2));
+        OUT_BCS_BATCH(ctx, 
+                      (encrypted << 31) |
+                      ((slice_param->slice_data_size - (slice_data_bit_offset >> 3)) << 0));
+        OUT_BCS_BATCH(ctx, 
+                      (slice_param->slice_data_offset +
+                       (slice_data_bit_offset >> 3)));
+        OUT_BCS_BATCH(ctx, 
+                      (0 << 31) | /* concealment mode: 0->intra 16x16 prediction, 1->inter P Copy */
+                      (0 << 14) | /* ignore BSDPrematureComplete Error handling */
+                      (0 << 13) | /* FIXME: ??? */
+                      (0 << 12) | /* ignore MPR Error handling */
+                      (0 << 10) | /* ignore Entropy Error handling */
+                      (0 << 8)  | /* ignore MB Header Error handling */
+                      (slice_type << 0));
+        OUT_BCS_BATCH(ctx, 
+                      (num_ref_idx_l1 << 24) |
+                      (num_ref_idx_l0 << 16) |
+                      (slice_param->chroma_log2_weight_denom << 8) |
+                      (slice_param->luma_log2_weight_denom << 0));
+        OUT_BCS_BATCH(ctx, 
+                      (weighted_pred_idc << 30) |
+                      (slice_param->direct_spatial_mv_pred_flag << 29) |
+                      (slice_param->disable_deblocking_filter_idc << 27) |
+                      (slice_param->cabac_init_idc << 24) |
+                      ((pic_param->pic_init_qp_minus26 + 26 + slice_param->slice_qp_delta) << 16) |
+                      ((slice_param->slice_beta_offset_div2 & 0xf) << 8) |
+                      ((slice_param->slice_alpha_c0_offset_div2 & 0xf) << 0));
+        OUT_BCS_BATCH(ctx, 
+                      (slice_ver_pos << 24) |
+                      (slice_hor_pos << 16) | 
+                      (first_mb_in_slice << 0));
+        OUT_BCS_BATCH(ctx, 
+                      (0 << 7) | /* FIXME: ??? */
+                      ((0x7 - (slice_data_bit_offset & 0x7)) << 0));
+
+        if (encrypted) {
+            OUT_BCS_BATCH(ctx, counter_value);
+        }
+
+        ADVANCE_BCS_BATCH(ctx); 
+    } else {
+        BEGIN_BCS_BATCH(ctx, 8); 
+        OUT_BCS_BATCH(ctx, CMD_AVC_BSD_OBJECT | (8 - 2));
+        OUT_BCS_BATCH(ctx, 0); /* indirect data length for phantom slice is 0 */
+        OUT_BCS_BATCH(ctx, 0); /* indirect data start address for phantom slice is 0 */
+        OUT_BCS_BATCH(ctx, 0);
+        OUT_BCS_BATCH(ctx, 0);
+        OUT_BCS_BATCH(ctx, 0);
+        OUT_BCS_BATCH(ctx, width_in_mbs * height_in_mbs / (1 + !!pic_param->pic_fields.bits.field_pic_flag));
+        OUT_BCS_BATCH(ctx, 0);
+        ADVANCE_BCS_BATCH(ctx);
+    }
+}
+
+static void
+ironlake_avc_bsd_object(VADriverContextP ctx, 
+                        struct decode_state *decode_state,
+                        VAPictureParameterBufferH264 *pic_param,
+                        VASliceParameterBufferH264 *slice_param)
+{
+    int width_in_mbs = pic_param->picture_width_in_mbs_minus1 + 1;
+    int height_in_mbs = pic_param->picture_height_in_mbs_minus1 + 1; /* frame height */
+
+    if (slice_param) {
+        struct i965_driver_data *i965 = i965_driver_data(ctx);
+        struct i965_media_state *media_state = &i965->media_state;
+        struct i965_h264_context *i965_h264_context = (struct i965_h264_context *)media_state->private_context;
+        int encrypted, counter_value;
+        int slice_hor_pos, slice_ver_pos;
+        int num_ref_idx_l0, num_ref_idx_l1;
+        int mbaff_picture = (!pic_param->pic_fields.bits.field_pic_flag &&
+                             pic_param->seq_fields.bits.mb_adaptive_frame_field_flag);
+        int slice_data_bit_offset;
+        int weighted_pred_idc = 0;
+        int first_mb_in_slice;
+        int slice_type;
+        encrypted = 0; /* FIXME: which flag in VAAPI is used for encryption? */
+
+        if (encrypted) {
+            counter_value = 0; /* FIXME: ??? */
+        } else 
+            counter_value = 0;
+
+        slice_data_bit_offset = slice_param->slice_data_bit_offset;    
+
+        if (pic_param->pic_fields.bits.entropy_coding_mode_flag == ENTROPY_CABAC)
+            slice_data_bit_offset = ALIGN(slice_data_bit_offset, 0x8);
+
+        if (slice_param->slice_type == SLICE_TYPE_I ||
+            slice_param->slice_type == SLICE_TYPE_SI)
+            slice_type = SLICE_TYPE_I;
+        else if (slice_param->slice_type == SLICE_TYPE_P ||
+                 slice_param->slice_type == SLICE_TYPE_SP)
+            slice_type = SLICE_TYPE_P;
+        else {
+            assert(slice_param->slice_type == SLICE_TYPE_B);
+            slice_type = SLICE_TYPE_B;
+        }
+
+        if (slice_type == SLICE_TYPE_I) {
+            assert(slice_param->num_ref_idx_l0_active_minus1 == 0);
+            assert(slice_param->num_ref_idx_l1_active_minus1 == 0);
+            num_ref_idx_l0 = 0;
+            num_ref_idx_l1 = 0;
+        } else if (slice_type == SLICE_TYPE_P) {
+            assert(slice_param->num_ref_idx_l1_active_minus1 == 0);
+            num_ref_idx_l0 = slice_param->num_ref_idx_l0_active_minus1 + 1;
+            num_ref_idx_l1 = 0;
+        } else {
+            num_ref_idx_l0 = slice_param->num_ref_idx_l0_active_minus1 + 1;
+            num_ref_idx_l1 = slice_param->num_ref_idx_l1_active_minus1 + 1;
+        }
+
+        if (slice_type == SLICE_TYPE_P)
+            weighted_pred_idc = pic_param->pic_fields.bits.weighted_pred_flag;
+        else if (slice_type == SLICE_TYPE_B)
+            weighted_pred_idc = pic_param->pic_fields.bits.weighted_bipred_idc;
+
+        first_mb_in_slice = slice_param->first_mb_in_slice;
+        slice_hor_pos = first_mb_in_slice % width_in_mbs; 
+        slice_ver_pos = first_mb_in_slice / width_in_mbs;
+        first_mb_in_slice = (slice_ver_pos << mbaff_picture) * width_in_mbs + slice_hor_pos;
+        slice_hor_pos <<= mbaff_picture;
+
+        BEGIN_BCS_BATCH(ctx, 16);
+        OUT_BCS_BATCH(ctx, CMD_AVC_BSD_OBJECT | (16 - 2));
+        OUT_BCS_BATCH(ctx, 
+                      (encrypted << 31) |
+                      (0 << 30) | /* FIXME: packet based bit stream */
+                      (0 << 29) | /* FIXME: packet format */
+                      ((slice_param->slice_data_size - (slice_data_bit_offset >> 3)) << 0));
+        OUT_BCS_BATCH(ctx, 
+                      (slice_param->slice_data_offset +
+                       (slice_data_bit_offset >> 3)));
+        OUT_BCS_BATCH(ctx, 
+                      (0 << 31) | /* concealment mode: 0->intra 16x16 prediction, 1->inter P Copy */
+                      (0 << 14) | /* ignore BSDPrematureComplete Error handling */
+                      (0 << 13) | /* FIXME: ??? */
+                      (0 << 12) | /* ignore MPR Error handling */
+                      (0 << 10) | /* ignore Entropy Error handling */
+                      (0 << 8)  | /* ignore MB Header Error handling */
+                      (slice_type << 0));
+        OUT_BCS_BATCH(ctx, 
+                      (num_ref_idx_l1 << 24) |
+                      (num_ref_idx_l0 << 16) |
+                      (slice_param->chroma_log2_weight_denom << 8) |
+                      (slice_param->luma_log2_weight_denom << 0));
+        OUT_BCS_BATCH(ctx, 
+                      (weighted_pred_idc << 30) |
+                      (slice_param->direct_spatial_mv_pred_flag << 29) |
+                      (slice_param->disable_deblocking_filter_idc << 27) |
+                      (slice_param->cabac_init_idc << 24) |
+                      ((pic_param->pic_init_qp_minus26 + 26 + slice_param->slice_qp_delta) << 16) |
+                      ((slice_param->slice_beta_offset_div2 & 0xf) << 8) |
+                      ((slice_param->slice_alpha_c0_offset_div2 & 0xf) << 0));
+        OUT_BCS_BATCH(ctx, 
+                      (slice_ver_pos << 24) |
+                      (slice_hor_pos << 16) | 
+                      (first_mb_in_slice << 0));
+        OUT_BCS_BATCH(ctx, 
+                      (0 << 7) | /* FIXME: ??? */
+                      ((0x7 - (slice_data_bit_offset & 0x7)) << 0));
+        OUT_BCS_BATCH(ctx, counter_value);
+        
+        /* FIXME: dw9-dw11 */
+        OUT_BCS_BATCH(ctx, 0);
+        OUT_BCS_BATCH(ctx, 0);
+        OUT_BCS_BATCH(ctx, 0);
+        OUT_BCS_BATCH(ctx, i965_h264_context->weight128_luma_l0);
+        OUT_BCS_BATCH(ctx, i965_h264_context->weight128_luma_l1);
+        OUT_BCS_BATCH(ctx, i965_h264_context->weight128_chroma_l0);
+        OUT_BCS_BATCH(ctx, i965_h264_context->weight128_chroma_l1);
+
+        ADVANCE_BCS_BATCH(ctx); 
+    } else {
+        BEGIN_BCS_BATCH(ctx, 16);
+        OUT_BCS_BATCH(ctx, CMD_AVC_BSD_OBJECT | (16 - 2));
+        OUT_BCS_BATCH(ctx, 0); /* indirect data length for phantom slice is 0 */
+        OUT_BCS_BATCH(ctx, 0); /* indirect data start address for phantom slice is 0 */
+        OUT_BCS_BATCH(ctx, 0);
+        OUT_BCS_BATCH(ctx, 0);
+        OUT_BCS_BATCH(ctx, 0);
+        OUT_BCS_BATCH(ctx, width_in_mbs * height_in_mbs / (1 + !!pic_param->pic_fields.bits.field_pic_flag));
+        OUT_BCS_BATCH(ctx, 0);
+        OUT_BCS_BATCH(ctx, 0);
+        OUT_BCS_BATCH(ctx, 0);
+        OUT_BCS_BATCH(ctx, 0);
+        OUT_BCS_BATCH(ctx, 0);
+        OUT_BCS_BATCH(ctx, 0);
+        OUT_BCS_BATCH(ctx, 0);
+        OUT_BCS_BATCH(ctx, 0);
+        OUT_BCS_BATCH(ctx, 0);
+        ADVANCE_BCS_BATCH(ctx);
+    }
+}
+
+static void
+i965_avc_bsd_object(VADriverContextP ctx, 
+                    struct decode_state *decode_state,
+                    VAPictureParameterBufferH264 *pic_param,
+                    VASliceParameterBufferH264 *slice_param)
+{
+    struct i965_driver_data *i965 = i965_driver_data(ctx);
+
+    if (IS_IRONLAKE(i965->intel.device_id))
+        ironlake_avc_bsd_object(ctx, decode_state, pic_param, slice_param);
+    else
+        g4x_avc_bsd_object(ctx, decode_state, pic_param, slice_param);
+}
+
+static void
+i965_avc_bsd_phantom_slice(VADriverContextP ctx, 
+                           struct decode_state *decode_state,
+                           VAPictureParameterBufferH264 *pic_param)
+{
+    i965_avc_bsd_object(ctx, decode_state, pic_param, NULL);
+}
+
+static void
+i965_avc_bsd_frame_store_index(VADriverContextP ctx,
+                               VAPictureParameterBufferH264 *pic_param)
+{
+    struct i965_driver_data *i965 = i965_driver_data(ctx);
+    struct i965_media_state *media_state = &i965->media_state;
+    struct i965_h264_context *i965_h264_context = (struct i965_h264_context *)media_state->private_context;
+    int i, j;
+
+    assert(ARRAY_ELEMS(i965_h264_context->fsid_list) == ARRAY_ELEMS(pic_param->ReferenceFrames));
+
+    for (i = 0; i < ARRAY_ELEMS(i965_h264_context->fsid_list); i++) {
+        int found = 0;
+
+        if (i965_h264_context->fsid_list[i].surface_id == VA_INVALID_ID)
+            continue;
+
+        for (j = 0; j < ARRAY_ELEMS(pic_param->ReferenceFrames); j++) {
+            VAPictureH264 *ref_pic = &pic_param->ReferenceFrames[j];
+            if (ref_pic->flags & VA_PICTURE_H264_INVALID)
+                continue;
+
+            if (i965_h264_context->fsid_list[i].surface_id == ref_pic->picture_id) {
+                found = 1;
+                break;
+            }
+        }
+
+        if (!found) {
+            i965_h264_context->fsid_list[i].surface_id = VA_INVALID_ID;
+            i965_h264_context->fsid_list[i].frame_store_id = -1;
+        }
+    }
+
+    for (i = 0; i < ARRAY_ELEMS(pic_param->ReferenceFrames); i++) {
+        VAPictureH264 *ref_pic = &pic_param->ReferenceFrames[i];
+        int found = 0;
+
+        if (ref_pic->flags & VA_PICTURE_H264_INVALID)
+            continue;
+
+        for (j = 0; j < ARRAY_ELEMS(i965_h264_context->fsid_list); j++) {
+            if (i965_h264_context->fsid_list[j].surface_id == VA_INVALID_ID)
+                continue;
+            
+            if (i965_h264_context->fsid_list[j].surface_id == ref_pic->picture_id) {
+                found = 1;
+                break;
+            }
+        }
+
+        if (!found) {
+            int frame_idx;
+            
+            for (frame_idx = 0; frame_idx < ARRAY_ELEMS(i965_h264_context->fsid_list); frame_idx++) {
+                for (j = 0; j < ARRAY_ELEMS(i965_h264_context->fsid_list); j++) {
+                    if (i965_h264_context->fsid_list[j].surface_id == VA_INVALID_ID)
+                        continue;
+
+                    if (i965_h264_context->fsid_list[j].frame_store_id == frame_idx)
+                        break;
+                }
+
+                if (j == ARRAY_ELEMS(i965_h264_context->fsid_list))
+                    break;
+            }
+
+            assert(frame_idx < ARRAY_ELEMS(i965_h264_context->fsid_list));
+
+            for (j = 0; j < ARRAY_ELEMS(i965_h264_context->fsid_list); j++) {
+                if (i965_h264_context->fsid_list[j].surface_id == VA_INVALID_ID) {
+                    i965_h264_context->fsid_list[j].surface_id = ref_pic->picture_id;
+                    i965_h264_context->fsid_list[j].frame_store_id = frame_idx;
+                    break;
+                }
+            }
+        }
+    }
+
+    for (i = 0; i < ARRAY_ELEMS(i965_h264_context->fsid_list) - 1; i++) {
+        if (i965_h264_context->fsid_list[i].surface_id != VA_INVALID_ID &&
+            i965_h264_context->fsid_list[i].frame_store_id == i)
+            continue;
+
+        for (j = i + 1; j < ARRAY_ELEMS(i965_h264_context->fsid_list); j++) {
+            if (i965_h264_context->fsid_list[j].surface_id != VA_INVALID_ID &&
+                i965_h264_context->fsid_list[j].frame_store_id == i) {
+                VASurfaceID id = i965_h264_context->fsid_list[i].surface_id;
+                int frame_idx = i965_h264_context->fsid_list[i].frame_store_id;
+
+                i965_h264_context->fsid_list[i].surface_id = i965_h264_context->fsid_list[j].surface_id;
+                i965_h264_context->fsid_list[i].frame_store_id = i965_h264_context->fsid_list[j].frame_store_id;
+                i965_h264_context->fsid_list[j].surface_id = id;
+                i965_h264_context->fsid_list[j].frame_store_id = frame_idx;
+                break;
+            }
+        }
+    }
+}
+
+void 
+i965_avc_bsd_pipeline(VADriverContextP ctx, struct decode_state *decode_state)
+{
+    int i, j;
+    VAPictureParameterBufferH264 *pic_param;
+    VASliceParameterBufferH264 *slice_param;
+
+    assert(decode_state->pic_param && decode_state->pic_param->buffer);
+    pic_param = (VAPictureParameterBufferH264 *)decode_state->pic_param->buffer;
+    i965_avc_bsd_frame_store_index(ctx, pic_param);
+    intel_batchbuffer_start_atomic_bcs(ctx, 0x1000);
+
+    i965_avc_bsd_img_state(ctx, decode_state);
+    i965_avc_bsd_qm_state(ctx, decode_state);
+
+    for (j = 0; j < decode_state->num_slice_params; j++) {
+        assert(decode_state->slice_params && decode_state->slice_params[j]->buffer);
+        slice_param = (VASliceParameterBufferH264 *)decode_state->slice_params[j]->buffer;
+
+        i965_bsd_ind_obj_base_address(ctx, decode_state, j);
+
+        assert(decode_state->slice_params[j]->num_elements == 1);  /* FIXME */
+        for (i = 0; i < decode_state->slice_params[j]->num_elements; i++) {
+            assert(slice_param->slice_data_flag == VA_SLICE_DATA_FLAG_ALL);
+            assert((slice_param->slice_type == SLICE_TYPE_I) ||
+                   (slice_param->slice_type == SLICE_TYPE_SI) ||
+                   (slice_param->slice_type == SLICE_TYPE_P) ||
+                   (slice_param->slice_type == SLICE_TYPE_SP) ||
+                   (slice_param->slice_type == SLICE_TYPE_B));
+
+            i965_avc_bsd_slice_state(ctx, pic_param, slice_param);
+            i965_avc_bsd_buf_base_state(ctx, pic_param, slice_param);
+            i965_avc_bsd_object(ctx, decode_state, pic_param, slice_param);
+            slice_param++;
+        }
+
+    }
+
+    i965_avc_bsd_phantom_slice(ctx, decode_state, pic_param);
+    intel_batchbuffer_emit_mi_flush_bcs(ctx);
+    intel_batchbuffer_end_atomic_bcs(ctx);
+    intel_batchbuffer_flush_bcs(ctx);
+}
+
+void 
+i965_avc_bsd_decode_init(VADriverContextP ctx)
+{
+    struct i965_driver_data *i965 = i965_driver_data(ctx);
+    struct i965_media_state *media_state = &i965->media_state;
+    struct i965_h264_context *i965_h264_context = (struct i965_h264_context *)media_state->private_context;
+    struct i965_avc_bsd_context *i965_avc_bsd_context;
+    dri_bo *bo;
+
+    assert(i965_h264_context);
+    i965_avc_bsd_context = &i965_h264_context->i965_avc_bsd_context;
+
+    dri_bo_unreference(i965_avc_bsd_context->bsd_raw_store.bo);
+    bo = dri_bo_alloc(i965->intel.bufmgr,
+                      "bsd raw store",
+                      0x4000, /* at least 11520 bytes to support 120 MBs per row */
+                      64);
+    assert(bo);
+    i965_avc_bsd_context->bsd_raw_store.bo = bo;
+
+    dri_bo_unreference(i965_avc_bsd_context->mpr_row_store.bo);
+    bo = dri_bo_alloc(i965->intel.bufmgr,
+                      "mpr row store",
+                      0x2000, /* at least 7680 bytes to support 120 MBs per row */
+                      64);
+    assert(bo);
+    i965_avc_bsd_context->mpr_row_store.bo = bo;
+
+    dri_bo_unreference(i965_avc_bsd_context->ildb_data.bo);
+    bo = dri_bo_alloc(i965->intel.bufmgr,
+                      "ildb data",
+                      0x100000, /* at least 1044480 bytes */
+                      64);
+    assert(bo);
+    i965_avc_bsd_context->ildb_data.bo = bo;
+}
+
+Bool 
+i965_avc_bsd_ternimate(struct i965_avc_bsd_context *i965_avc_bsd_context)
+{
+    dri_bo_unreference(i965_avc_bsd_context->bsd_raw_store.bo);
+    dri_bo_unreference(i965_avc_bsd_context->mpr_row_store.bo);
+    dri_bo_unreference(i965_avc_bsd_context->ildb_data.bo);
+
+    return True;
+}
diff --git a/i965_drv_video/i965_avc_bsd.h b/i965_drv_video/i965_avc_bsd.h
new file mode 100644
index 0000000..7f39ba5
--- /dev/null
+++ b/i965_drv_video/i965_avc_bsd.h
@@ -0,0 +1,68 @@
+/*
+ * Copyright © 2010 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sub license, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+ * IN NO EVENT SHALL PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR
+ * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors:
+ *    Xiang Haihao <haihao.xiang@intel.com>
+ *
+ */
+
+#ifndef __I965_AVC_BSD_H__
+#define __I965_AVC_BSD_H__
+
+struct i965_avc_bsd_surface
+{
+    dri_bo *direct_mv_wr_top_bo;
+    dri_bo *direct_mv_wr_bottom_bo;
+    int direct_mv_flag;
+};
+
+struct i965_avc_bsd_context
+{
+    struct {
+        dri_bo *bo;
+    } bsd_raw_store;
+
+    struct {
+        dri_bo *bo;
+    } mpr_row_store;
+
+    struct {
+        dri_bo *bo;
+    } avc_it_command_mb_info;
+
+    struct {
+        dri_bo *bo;
+        long write_offset;
+    } avc_it_data;
+
+    struct {
+        dri_bo *bo;
+    } ildb_data;
+};
+
+void i965_avc_bsd_pipeline(VADriverContextP, struct decode_state *);
+void i965_avc_bsd_decode_init(VADriverContextP);
+Bool i965_avc_bsd_ternimate(struct i965_avc_bsd_context *);
+
+#endif /* __I965_AVC_BSD_H__ */
+
diff --git a/i965_drv_video/i965_avc_hw_scoreboard.c b/i965_drv_video/i965_avc_hw_scoreboard.c
new file mode 100644
index 0000000..9d6d973
--- /dev/null
+++ b/i965_drv_video/i965_avc_hw_scoreboard.c
@@ -0,0 +1,420 @@
+/*
+ * Copyright © 2010 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sub license, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+ * IN NO EVENT SHALL PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR
+ * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors:
+ *    Xiang Haihao <haihao.xiang@intel.com>
+ *
+ */
+
+#include <stdio.h>
+#include <string.h>
+#include <assert.h>
+
+#include "va_backend.h"
+
+#include "intel_batchbuffer.h"
+#include "intel_driver.h"
+
+#include "i965_defines.h"
+#include "i965_drv_video.h"
+#include "i965_avc_hw_scoreboard.h"
+#include "i965_media_h264.h"
+#include "i965_media.h"
+
+extern struct media_kernel *h264_avc_kernels;
+
+/* On Ironlake */
+#include "shaders/h264/mc/export.inc.gen5"
+
+enum {
+    AVC_HW_SCOREBOARD = 0,
+    AVC_HW_SCOREBOARD_MBAFF
+};
+
+static unsigned long avc_hw_scoreboard_kernel_offset[] = {
+    SETHWSCOREBOARD_IP_GEN5,
+    SETHWSCOREBOARD_MBAFF_IP_GEN5
+};
+
+static unsigned int avc_hw_scoreboard_constants[] = {
+    0x08040201,
+    0x00000010,
+    0x08000210,
+    0x00000000,
+    0x08040201,
+    0x08040210,
+    0x01000010,
+    0x08040200
+};
+
+static void
+i965_avc_hw_scoreboard_surface_state(struct i965_avc_hw_scoreboard_context *avc_hw_scoreboard_context)
+{
+    struct i965_surface_state *ss;
+    dri_bo *bo;
+
+    bo = avc_hw_scoreboard_context->surface.ss_bo;
+    dri_bo_map(bo, 1);
+    assert(bo->virtual);
+    ss = bo->virtual;
+    memset(ss, 0, sizeof(*ss));
+    ss->ss0.surface_type = I965_SURFACE_BUFFER;
+    ss->ss1.base_addr = avc_hw_scoreboard_context->surface.s_bo->offset;
+    ss->ss2.width = ((avc_hw_scoreboard_context->surface.total_mbs * MB_CMD_IN_OWS - 1) & 0x7f);
+    ss->ss2.height = (((avc_hw_scoreboard_context->surface.total_mbs * MB_CMD_IN_OWS - 1) >> 7) & 0x1fff);
+    ss->ss3.depth = (((avc_hw_scoreboard_context->surface.total_mbs * MB_CMD_IN_OWS - 1) >> 20) & 0x7f);
+    dri_bo_emit_reloc(bo,
+                      I915_GEM_DOMAIN_RENDER, I915_GEM_DOMAIN_RENDER,
+                      0,
+                      offsetof(struct i965_surface_state, ss1),
+                      avc_hw_scoreboard_context->surface.s_bo);
+    dri_bo_unmap(bo);
+}
+
+static void
+i965_avc_hw_scoreboard_interface_descriptor_table(struct i965_avc_hw_scoreboard_context *avc_hw_scoreboard_context)
+{
+    struct i965_interface_descriptor *desc;
+    dri_bo *bo;
+
+    bo = avc_hw_scoreboard_context->idrt.bo;
+    dri_bo_map(bo, 1);
+    assert(bo->virtual);
+    desc = bo->virtual;
+    memset(desc, 0, sizeof(*desc));
+    desc->desc0.grf_reg_blocks = 7;
+    desc->desc0.kernel_start_pointer = (avc_hw_scoreboard_context->hw_kernel.bo->offset + 
+                                        avc_hw_scoreboard_context->hw_kernel.offset) >> 6; /* reloc */
+    desc->desc1.const_urb_entry_read_offset = 0;
+    desc->desc1.const_urb_entry_read_len = 1;
+    desc->desc3.binding_table_entry_count = 0;
+    desc->desc3.binding_table_pointer = 
+        avc_hw_scoreboard_context->binding_table.bo->offset >> 5; /*reloc */
+
+    dri_bo_emit_reloc(bo,
+                      I915_GEM_DOMAIN_INSTRUCTION, 0,
+                      desc->desc0.grf_reg_blocks + avc_hw_scoreboard_context->hw_kernel.offset,
+                      offsetof(struct i965_interface_descriptor, desc0),
+                      avc_hw_scoreboard_context->hw_kernel.bo);
+
+    dri_bo_emit_reloc(bo,
+                      I915_GEM_DOMAIN_INSTRUCTION, 0,
+                      desc->desc3.binding_table_entry_count,
+                      offsetof(struct i965_interface_descriptor, desc3),
+                      avc_hw_scoreboard_context->binding_table.bo);
+
+    dri_bo_unmap(bo);
+}
+
+static void
+i965_avc_hw_scoreboard_binding_table(struct i965_avc_hw_scoreboard_context *avc_hw_scoreboard_context)
+{
+    unsigned int *binding_table;
+    dri_bo *bo = avc_hw_scoreboard_context->binding_table.bo;
+
+    dri_bo_map(bo, 1);
+    assert(bo->virtual);
+    binding_table = bo->virtual;
+    memset(binding_table, 0, bo->size);
+    binding_table[0] = avc_hw_scoreboard_context->surface.ss_bo->offset;
+    dri_bo_emit_reloc(bo,
+                      I915_GEM_DOMAIN_INSTRUCTION, 0,
+                      0,
+                      0,
+                      avc_hw_scoreboard_context->surface.ss_bo);
+    dri_bo_unmap(bo);
+}
+
+static void
+i965_avc_hw_scoreboard_vfe_state(struct i965_avc_hw_scoreboard_context *avc_hw_scoreboard_context)
+{
+    struct i965_vfe_state *vfe_state;
+    dri_bo *bo;
+
+    bo = avc_hw_scoreboard_context->vfe_state.bo;
+    dri_bo_map(bo, 1);
+    assert(bo->virtual);
+    vfe_state = bo->virtual;
+    memset(vfe_state, 0, sizeof(*vfe_state));
+    vfe_state->vfe1.max_threads = avc_hw_scoreboard_context->urb.num_vfe_entries - 1;
+    vfe_state->vfe1.urb_entry_alloc_size = avc_hw_scoreboard_context->urb.size_vfe_entry - 1;
+    vfe_state->vfe1.num_urb_entries = avc_hw_scoreboard_context->urb.num_vfe_entries;
+    vfe_state->vfe1.vfe_mode = VFE_GENERIC_MODE;
+    vfe_state->vfe1.children_present = 0;
+    vfe_state->vfe2.interface_descriptor_base = 
+        avc_hw_scoreboard_context->idrt.bo->offset >> 4; /* reloc */
+    dri_bo_emit_reloc(bo,
+                      I915_GEM_DOMAIN_INSTRUCTION, 0,
+                      0,
+                      offsetof(struct i965_vfe_state, vfe2),
+                      avc_hw_scoreboard_context->idrt.bo);
+    dri_bo_unmap(bo);
+}
+
+static void
+i965_avc_hw_scoreboard_upload_constants(struct i965_avc_hw_scoreboard_context *avc_hw_scoreboard_context)
+{
+    unsigned char *constant_buffer;
+
+    dri_bo_map(avc_hw_scoreboard_context->curbe.bo, 1);
+    assert(avc_hw_scoreboard_context->curbe.bo->virtual);
+    constant_buffer = avc_hw_scoreboard_context->curbe.bo->virtual;
+    memcpy(constant_buffer, avc_hw_scoreboard_constants, sizeof(avc_hw_scoreboard_constants));
+    dri_bo_unmap(avc_hw_scoreboard_context->curbe.bo);
+}
+
+static void
+i965_avc_hw_scoreboard_states_setup(struct i965_avc_hw_scoreboard_context *avc_hw_scoreboard_context)
+{
+    i965_avc_hw_scoreboard_surface_state(avc_hw_scoreboard_context);
+    i965_avc_hw_scoreboard_binding_table(avc_hw_scoreboard_context);
+    i965_avc_hw_scoreboard_interface_descriptor_table(avc_hw_scoreboard_context);
+    i965_avc_hw_scoreboard_vfe_state(avc_hw_scoreboard_context);
+    i965_avc_hw_scoreboard_upload_constants(avc_hw_scoreboard_context);
+}
+
+static void
+i965_avc_hw_scoreboard_pipeline_select(VADriverContextP ctx)
+{
+    BEGIN_BATCH(ctx, 1);
+    OUT_BATCH(ctx, CMD_PIPELINE_SELECT | PIPELINE_SELECT_MEDIA);
+    ADVANCE_BATCH(ctx);
+}
+
+static void
+i965_avc_hw_scoreboard_urb_layout(VADriverContextP ctx, struct i965_avc_hw_scoreboard_context *avc_hw_scoreboard_context)
+{
+    struct i965_driver_data *i965 = i965_driver_data(ctx);
+    unsigned int vfe_fence, cs_fence;
+
+    vfe_fence = avc_hw_scoreboard_context->urb.cs_start;
+    cs_fence = URB_SIZE((&i965->intel));
+
+    BEGIN_BATCH(ctx, 3);
+    OUT_BATCH(ctx, CMD_URB_FENCE | UF0_VFE_REALLOC | UF0_CS_REALLOC | 1);
+    OUT_BATCH(ctx, 0);
+    OUT_BATCH(ctx, 
+              (vfe_fence << UF2_VFE_FENCE_SHIFT) |      /* VFE_SIZE */
+              (cs_fence << UF2_CS_FENCE_SHIFT));        /* CS_SIZE */
+    ADVANCE_BATCH(ctx);
+}
+
+static void
+i965_avc_hw_scoreboard_state_base_address(VADriverContextP ctx)
+{
+    BEGIN_BATCH(ctx, 8);
+    OUT_BATCH(ctx, CMD_STATE_BASE_ADDRESS | 6);
+    OUT_BATCH(ctx, 0 | BASE_ADDRESS_MODIFY);
+    OUT_BATCH(ctx, 0 | BASE_ADDRESS_MODIFY);
+    OUT_BATCH(ctx, 0 | BASE_ADDRESS_MODIFY);
+    OUT_BATCH(ctx, 0 | BASE_ADDRESS_MODIFY);
+    OUT_BATCH(ctx, 0 | BASE_ADDRESS_MODIFY);
+    OUT_BATCH(ctx, 0 | BASE_ADDRESS_MODIFY);
+    OUT_BATCH(ctx, 0 | BASE_ADDRESS_MODIFY);
+    ADVANCE_BATCH(ctx);
+}
+
+static void
+i965_avc_hw_scoreboard_state_pointers(VADriverContextP ctx, struct i965_avc_hw_scoreboard_context *avc_hw_scoreboard_context)
+{
+    BEGIN_BATCH(ctx, 3);
+    OUT_BATCH(ctx, CMD_MEDIA_STATE_POINTERS | 1);
+    OUT_BATCH(ctx, 0);
+    OUT_RELOC(ctx, avc_hw_scoreboard_context->vfe_state.bo, I915_GEM_DOMAIN_INSTRUCTION, 0, 0);
+    ADVANCE_BATCH(ctx);
+}
+
+static void 
+i965_avc_hw_scoreboard_cs_urb_layout(VADriverContextP ctx, struct i965_avc_hw_scoreboard_context *avc_hw_scoreboard_context)
+{
+    BEGIN_BATCH(ctx, 2);
+    OUT_BATCH(ctx, CMD_CS_URB_STATE | 0);
+    OUT_BATCH(ctx,
+              ((avc_hw_scoreboard_context->urb.size_cs_entry - 1) << 4) |     /* URB Entry Allocation Size */
+              (avc_hw_scoreboard_context->urb.num_cs_entries << 0));          /* Number of URB Entries */
+    ADVANCE_BATCH(ctx);
+}
+
+static void
+i965_avc_hw_scoreboard_constant_buffer(VADriverContextP ctx, struct i965_avc_hw_scoreboard_context *avc_hw_scoreboard_context)
+{
+    BEGIN_BATCH(ctx, 2);
+    OUT_BATCH(ctx, CMD_CONSTANT_BUFFER | (1 << 8) | (2 - 2));
+    OUT_RELOC(ctx, avc_hw_scoreboard_context->curbe.bo,
+              I915_GEM_DOMAIN_INSTRUCTION, 0,
+              avc_hw_scoreboard_context->urb.size_cs_entry - 1);
+    ADVANCE_BATCH(ctx);    
+}
+
+static void
+i965_avc_hw_scoreboard_objects(VADriverContextP ctx, struct i965_avc_hw_scoreboard_context *avc_hw_scoreboard_context)
+{
+    BEGIN_BATCH(ctx, 6);
+    OUT_BATCH(ctx, CMD_MEDIA_OBJECT | 4);
+    OUT_BATCH(ctx, 0); /* interface descriptor offset: 0 */
+    OUT_BATCH(ctx, 0); /* no indirect data */
+    OUT_BATCH(ctx, 0);
+    OUT_BATCH(ctx, ((avc_hw_scoreboard_context->inline_data.num_mb_cmds << 16) |
+                    (avc_hw_scoreboard_context->inline_data.starting_mb_number << 0)));
+    OUT_BATCH(ctx, avc_hw_scoreboard_context->inline_data.pic_width_in_mbs);
+    ADVANCE_BATCH(ctx);
+}
+
+static void
+i965_avc_hw_scoreboard_pipeline_setup(VADriverContextP ctx, struct i965_avc_hw_scoreboard_context *avc_hw_scoreboard_context)
+{
+    intel_batchbuffer_start_atomic(ctx, 0x1000);
+    intel_batchbuffer_emit_mi_flush(ctx);
+    i965_avc_hw_scoreboard_pipeline_select(ctx);
+    i965_avc_hw_scoreboard_state_base_address(ctx);
+    i965_avc_hw_scoreboard_state_pointers(ctx, avc_hw_scoreboard_context);
+    i965_avc_hw_scoreboard_urb_layout(ctx, avc_hw_scoreboard_context);
+    i965_avc_hw_scoreboard_cs_urb_layout(ctx, avc_hw_scoreboard_context);
+    i965_avc_hw_scoreboard_constant_buffer(ctx, avc_hw_scoreboard_context);
+    i965_avc_hw_scoreboard_objects(ctx, avc_hw_scoreboard_context);
+    intel_batchbuffer_end_atomic(ctx);
+}
+
+void
+i965_avc_hw_scoreboard(VADriverContextP ctx, struct decode_state *decode_state)
+{
+    struct i965_driver_data *i965 = i965_driver_data(ctx);
+    struct i965_media_state *media_state = &i965->media_state;
+    struct i965_h264_context *i965_h264_context = (struct i965_h264_context *)media_state->private_context;
+    struct i965_avc_hw_scoreboard_context *avc_hw_scoreboard_context;
+
+    if (i965_h264_context->use_avc_hw_scoreboard) {
+        assert(i965_h264_context != NULL);
+        avc_hw_scoreboard_context = &i965_h264_context->avc_hw_scoreboard_context;
+
+        avc_hw_scoreboard_context->inline_data.num_mb_cmds = i965_h264_context->avc_it_command_mb_info.mbs;
+        avc_hw_scoreboard_context->inline_data.starting_mb_number = i965_h264_context->avc_it_command_mb_info.mbs;
+        avc_hw_scoreboard_context->inline_data.pic_width_in_mbs = i965_h264_context->picture.width_in_mbs;
+        avc_hw_scoreboard_context->surface.total_mbs = i965_h264_context->avc_it_command_mb_info.mbs * 2;
+        
+        dri_bo_unreference(avc_hw_scoreboard_context->hw_kernel.bo);
+        avc_hw_scoreboard_context->hw_kernel.bo = h264_avc_kernels[H264_AVC_COMBINED].bo;
+        assert(avc_hw_scoreboard_context->hw_kernel.bo != NULL);
+        dri_bo_reference(avc_hw_scoreboard_context->hw_kernel.bo);
+
+        if (i965_h264_context->picture.mbaff_frame_flag)
+            avc_hw_scoreboard_context->hw_kernel.offset = avc_hw_scoreboard_kernel_offset[AVC_HW_SCOREBOARD_MBAFF];
+        else
+            avc_hw_scoreboard_context->hw_kernel.offset = avc_hw_scoreboard_kernel_offset[AVC_HW_SCOREBOARD];
+
+        i965_avc_hw_scoreboard_states_setup(avc_hw_scoreboard_context);
+        i965_avc_hw_scoreboard_pipeline_setup(ctx, avc_hw_scoreboard_context);
+    }
+}
+
+void
+i965_avc_hw_scoreboard_decode_init(VADriverContextP ctx)
+{
+    struct i965_driver_data *i965 = i965_driver_data(ctx);
+    struct i965_media_state *media_state = &i965->media_state;
+    struct i965_h264_context *i965_h264_context = (struct i965_h264_context *)media_state->private_context;
+    struct i965_avc_hw_scoreboard_context *avc_hw_scoreboard_context;
+    dri_bo *bo;
+
+    if (i965_h264_context->use_avc_hw_scoreboard) {
+        assert(i965_h264_context != NULL);
+        avc_hw_scoreboard_context = &i965_h264_context->avc_hw_scoreboard_context;
+
+        dri_bo_unreference(avc_hw_scoreboard_context->curbe.bo);
+        bo = dri_bo_alloc(i965->intel.bufmgr,
+                          "constant buffer",
+                          4096, 64);
+        assert(bo);
+        avc_hw_scoreboard_context->curbe.bo = bo;
+
+        dri_bo_unreference(avc_hw_scoreboard_context->surface.s_bo);
+        avc_hw_scoreboard_context->surface.s_bo = i965_h264_context->avc_it_command_mb_info.bo;
+        assert(avc_hw_scoreboard_context->surface.s_bo != NULL);
+        dri_bo_reference(avc_hw_scoreboard_context->surface.s_bo);
+
+        dri_bo_unreference(avc_hw_scoreboard_context->surface.ss_bo);
+        bo = dri_bo_alloc(i965->intel.bufmgr, 
+                          "surface state", 
+                          sizeof(struct i965_surface_state), 32);
+        assert(bo);
+        avc_hw_scoreboard_context->surface.ss_bo = bo;
+
+        dri_bo_unreference(avc_hw_scoreboard_context->binding_table.bo);
+        bo = dri_bo_alloc(i965->intel.bufmgr, 
+                          "binding table",
+                          MAX_MEDIA_SURFACES * sizeof(unsigned int), 32);
+        assert(bo);
+        avc_hw_scoreboard_context->binding_table.bo = bo;
+
+        dri_bo_unreference(avc_hw_scoreboard_context->idrt.bo);
+        bo = dri_bo_alloc(i965->intel.bufmgr, 
+                          "interface discriptor", 
+                          MAX_INTERFACE_DESC * sizeof(struct i965_interface_descriptor), 16);
+        assert(bo);
+        avc_hw_scoreboard_context->idrt.bo = bo;
+
+        dri_bo_unreference(avc_hw_scoreboard_context->vfe_state.bo);
+        bo = dri_bo_alloc(i965->intel.bufmgr, 
+                          "vfe state", 
+                          sizeof(struct i965_vfe_state), 32);
+        assert(bo);
+        avc_hw_scoreboard_context->vfe_state.bo = bo;
+
+        avc_hw_scoreboard_context->urb.num_vfe_entries = 1;
+        avc_hw_scoreboard_context->urb.size_vfe_entry = 2;
+        avc_hw_scoreboard_context->urb.num_cs_entries = 1;
+        avc_hw_scoreboard_context->urb.size_cs_entry = 1;
+        avc_hw_scoreboard_context->urb.vfe_start = 0;
+        avc_hw_scoreboard_context->urb.cs_start = avc_hw_scoreboard_context->urb.vfe_start + 
+            avc_hw_scoreboard_context->urb.num_vfe_entries * avc_hw_scoreboard_context->urb.size_vfe_entry;
+        assert(avc_hw_scoreboard_context->urb.cs_start + 
+               avc_hw_scoreboard_context->urb.num_cs_entries * avc_hw_scoreboard_context->urb.size_cs_entry <= URB_SIZE((&i965->intel)));
+    }
+}
+
+Bool 
+i965_avc_hw_scoreboard_ternimate(struct i965_avc_hw_scoreboard_context *avc_hw_scoreboard_context)
+{
+    dri_bo_unreference(avc_hw_scoreboard_context->curbe.bo);
+    avc_hw_scoreboard_context->curbe.bo = NULL;
+
+    dri_bo_unreference(avc_hw_scoreboard_context->surface.ss_bo);
+    avc_hw_scoreboard_context->surface.ss_bo = NULL;
+
+    dri_bo_unreference(avc_hw_scoreboard_context->surface.s_bo);
+    avc_hw_scoreboard_context->surface.s_bo = NULL;
+
+    dri_bo_unreference(avc_hw_scoreboard_context->binding_table.bo);
+    avc_hw_scoreboard_context->binding_table.bo = NULL;
+
+    dri_bo_unreference(avc_hw_scoreboard_context->idrt.bo);
+    avc_hw_scoreboard_context->idrt.bo = NULL;
+
+    dri_bo_unreference(avc_hw_scoreboard_context->vfe_state.bo);
+    avc_hw_scoreboard_context->vfe_state.bo = NULL;
+
+    dri_bo_unreference(avc_hw_scoreboard_context->hw_kernel.bo);
+    avc_hw_scoreboard_context->hw_kernel.bo = NULL;
+
+    return True;
+}
diff --git a/i965_drv_video/i965_avc_hw_scoreboard.h b/i965_drv_video/i965_avc_hw_scoreboard.h
new file mode 100644
index 0000000..66ee9fb
--- /dev/null
+++ b/i965_drv_video/i965_avc_hw_scoreboard.h
@@ -0,0 +1,84 @@
+/*
+ * Copyright © 2010 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sub license, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+ * IN NO EVENT SHALL PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR
+ * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors:
+ *    Xiang Haihao <haihao.xiang@intel.com>
+ *
+ */
+
+#ifndef __I965_AVC_HW_SCOREBOARD_H__
+#define __I965_AVC_HW_SCOREBOARD_H__
+
+struct i965_avc_hw_scoreboard_context
+{
+    struct {
+        unsigned int num_mb_cmds;
+        unsigned int starting_mb_number;
+        unsigned int pic_width_in_mbs;
+    } inline_data;
+
+    struct {
+        dri_bo *ss_bo;
+        dri_bo *s_bo;
+        unsigned int total_mbs;
+    } surface;
+
+    struct {
+        dri_bo *bo;
+    } binding_table;
+
+    struct {
+        dri_bo *bo;
+    } idrt;
+
+    struct {
+        dri_bo *bo;
+    } vfe_state;
+
+    struct {
+        dri_bo *bo;
+    } curbe;
+
+    struct {
+        dri_bo *bo;
+        unsigned long offset;
+    } hw_kernel;
+
+    struct {
+        unsigned int vfe_start;
+        unsigned int cs_start;
+
+        unsigned int num_vfe_entries;
+        unsigned int num_cs_entries;
+
+        unsigned int size_vfe_entry;
+        unsigned int size_cs_entry;
+    } urb;
+};
+
+void i965_avc_hw_scoreboard(VADriverContextP, struct decode_state *);
+void i965_avc_hw_scoreboard_decode_init(VADriverContextP);
+Bool i965_avc_hw_scoreboard_ternimate(struct i965_avc_hw_scoreboard_context *);
+
+#endif /* __I965_AVC_HW_SCOREBOARD_H__ */
+
diff --git a/i965_drv_video/i965_defines.h b/i965_drv_video/i965_defines.h
index 260d820..aa2baa3 100644
--- a/i965_drv_video/i965_defines.h
+++ b/i965_drv_video/i965_defines.h
@@ -20,6 +20,13 @@
 #define CMD_MEDIA_OBJECT                        CMD(2, 1, 0)
 #define CMD_MEDIA_OBJECT_EX                     CMD(2, 1, 1)
 
+#define CMD_AVC_BSD_IMG_STATE                   CMD(2, 4, 0)
+#define CMD_AVC_BSD_QM_STATE                    CMD(2, 4, 1)
+#define CMD_AVC_BSD_SLICE_STATE                 CMD(2, 4, 2)
+#define CMD_AVC_BSD_BUF_BASE_STATE              CMD(2, 4, 3)
+#define CMD_BSD_IND_OBJ_BASE_ADDR               CMD(2, 4, 4)
+#define CMD_AVC_BSD_OBJECT                      CMD(2, 4, 8)
+
 #define CMD_PIPELINED_POINTERS                  CMD(3, 0, 0)
 #define CMD_BINDING_TABLE_POINTERS              CMD(3, 0, 1)
 #define CMD_VERTEX_BUFFERS                      CMD(3, 0, 8)
@@ -28,6 +35,9 @@
 #define CMD_CONSTANT_COLOR                      CMD(3, 1, 1)
 #define CMD_3DPRIMITIVE                         CMD(3, 3, 0)
 
+#define CMD_DEPTH_BUFFER                        CMD(3, 1, 5)
+#define I965_DEPTHFORMAT_D32_FLOAT              1
+
 #define BASE_ADDRESS_MODIFY             (1 << 0)
 
 #define PIPELINE_SELECT_3D              0
@@ -321,6 +331,32 @@
 #define I965_TILEWALK_XMAJOR                 0
 #define I965_TILEWALK_YMAJOR                 1
 
-#define URB_SIZE(intel)         (IS_IGDNG(intel->device_id) ? 1024 : \
+#define SCAN_RASTER_ORDER       0
+#define SCAN_SPECIAL_ORDER      1
+
+#define ENTROPY_CAVLD           0
+#define ENTROPY_CABAC           1
+
+#define SLICE_TYPE_P            0
+#define SLICE_TYPE_B            1
+#define SLICE_TYPE_I            2
+#define SLICE_TYPE_SP           3
+#define SLICE_TYPE_SI           4
+
+#define PRESENT_REF_LIST0               (1 << 0)
+#define PRESENT_REF_LIST1               (1 << 1)
+#define PRESENT_WEIGHT_OFFSET_L0        (1 << 2)
+#define PRESENT_WEIGHT_OFFSET_L1        (1 << 3)
+
+#define RESIDUAL_DATA_OFFSET    48
+
+#define PRESENT_NOMV            0
+#define PRESENT_NOWO            1
+#define PRESENT_MV_WO           3
+
+#define SCOREBOARD_STALLING     0
+#define SCOREBOARD_NON_STALLING 1
+
+#define URB_SIZE(intel)         (IS_IRONLAKE(intel->device_id) ? 1024 : \
                                  IS_G4X(intel->device_id) ? 384 : 256)
 #endif /* _I965_DEFINES_H_ */
diff --git a/i965_drv_video/i965_drv_video.c b/i965_drv_video/i965_drv_video.c
index 6a60ecc..80b07ae 100644
--- a/i965_drv_video/i965_drv_video.c
+++ b/i965_drv_video/i965_drv_video.c
@@ -99,6 +99,9 @@ i965_QueryConfigProfiles(VADriverContextP ctx,
 
     profile_list[i++] = VAProfileMPEG2Simple;
     profile_list[i++] = VAProfileMPEG2Main;
+    profile_list[i++] = VAProfileH264Baseline;
+    profile_list[i++] = VAProfileH264Main;
+    profile_list[i++] = VAProfileH264High;
 
     /* If the assert fails then I965_MAX_PROFILES needs to be bigger */
     assert(i <= I965_MAX_PROFILES);
@@ -122,6 +125,13 @@ i965_QueryConfigEntrypoints(VADriverContextP ctx,
         entrypoint_list[0] = VAEntrypointVLD;
         break;
 
+    case VAProfileH264Baseline:
+    case VAProfileH264Main:
+    case VAProfileH264High:
+        *num_entrypoints = 1;
+        entrypoint_list[0] = VAEntrypointVLD;
+        break;
+
     default:
         vaStatus = VA_STATUS_ERROR_UNSUPPORTED_PROFILE;
         *num_entrypoints = 0;
@@ -217,6 +227,17 @@ i965_CreateConfig(VADriverContextP ctx,
         }
         break;
 
+    case VAProfileH264Baseline:
+    case VAProfileH264Main:
+    case VAProfileH264High:
+        if (VAEntrypointVLD == entrypoint) {
+            vaStatus = VA_STATUS_SUCCESS;
+        } else {
+            vaStatus = VA_STATUS_ERROR_UNSUPPORTED_ENTRYPOINT;
+        }
+
+        break;
+
     default:
         vaStatus = VA_STATUS_ERROR_UNSUPPORTED_PROFILE;
         break;
@@ -305,6 +326,12 @@ i965_destroy_surface(struct object_heap *heap, struct object_base *obj)
 
     dri_bo_unreference(obj_surface->bo);
     obj_surface->bo = NULL;
+
+    if (obj_surface->free_private_data != NULL) {
+        obj_surface->free_private_data(&obj_surface->private_data);
+        obj_surface->private_data = NULL;
+    }
+
     object_heap_free(heap, obj);
 }
 
@@ -337,9 +364,9 @@ i965_CreateSurfaces(VADriverContextP ctx,
         surfaces[i] = surfaceID;
         obj_surface->status = VASurfaceReady;
         obj_surface->subpic = VA_INVALID_ID;
-        obj_surface->width = width;
-        obj_surface->height = height;
-        obj_surface->size = SIZE_YUV420(width, height);
+        obj_surface->width = ALIGN(width, 16);
+        obj_surface->height = ALIGN(height, 16);
+        obj_surface->size = SIZE_YUV420(obj_surface->width, obj_surface->height);
         obj_surface->bo = dri_bo_alloc(i965->intel.bufmgr,
                                        "vaapi surface",
                                        obj_surface->size,
@@ -350,6 +377,8 @@ i965_CreateSurfaces(VADriverContextP ctx,
             vaStatus = VA_STATUS_ERROR_UNKNOWN;
             break;
         }
+        obj_surface->private_data = NULL;
+        obj_surface->free_private_data = NULL;
     }
 
     /* Error recovery */
@@ -608,12 +637,23 @@ static void
 i965_destroy_context(struct object_heap *heap, struct object_base *obj)
 {
     struct object_context *obj_context = (struct object_context *)obj;
+    int i;
+
+    assert(obj_context->decode_state.num_slice_params <= obj_context->decode_state.max_slice_params);
+    assert(obj_context->decode_state.num_slice_datas <= obj_context->decode_state.max_slice_datas);
 
     i965_release_buffer_store(&obj_context->decode_state.pic_param);
-    i965_release_buffer_store(&obj_context->decode_state.slice_param);
     i965_release_buffer_store(&obj_context->decode_state.iq_matrix);
     i965_release_buffer_store(&obj_context->decode_state.bit_plane);
-    i965_release_buffer_store(&obj_context->decode_state.slice_data);
+
+    for (i = 0; i < obj_context->decode_state.num_slice_params; i++)
+        i965_release_buffer_store(&obj_context->decode_state.slice_params[i]);
+
+    for (i = 0; i < obj_context->decode_state.num_slice_datas; i++)
+        i965_release_buffer_store(&obj_context->decode_state.slice_datas[i]);
+
+    free(obj_context->decode_state.slice_params);
+    free(obj_context->decode_state.slice_datas);
     free(obj_context->render_targets);
     object_heap_free(heap, obj);
 }
@@ -654,6 +694,12 @@ i965_CreateContext(VADriverContextP ctx,
     *context = contextID;
     memset(&obj_context->decode_state, 0, sizeof(obj_context->decode_state));
     obj_context->decode_state.current_render_target = -1;
+    obj_context->decode_state.max_slice_params = NUM_SLICES;
+    obj_context->decode_state.max_slice_datas = NUM_SLICES;
+    obj_context->decode_state.slice_params = calloc(obj_context->decode_state.max_slice_params,
+                                                    sizeof(*obj_context->decode_state.slice_params));
+    obj_context->decode_state.slice_datas = calloc(obj_context->decode_state.max_slice_datas,
+                                                   sizeof(*obj_context->decode_state.slice_datas));
     obj_context->config_id = config_id;
     obj_context->picture_width = picture_width;
     obj_context->picture_height = picture_height;
@@ -767,6 +813,7 @@ i965_CreateBuffer(VADriverContextP ctx,
             memcpy(buffer_store->buffer, data, size * num_elements);
     }
 
+    buffer_store->num_elements = obj_buffer->num_elements;
     i965_reference_buffer_store(&obj_buffer->buffer_store, buffer_store);
     i965_release_buffer_store(&buffer_store);
     *buf_id = bufferID;
@@ -881,6 +928,12 @@ i965_BeginPicture(VADriverContextP ctx,
         vaStatus = VA_STATUS_SUCCESS;
         break;
 
+    case VAProfileH264Baseline:
+    case VAProfileH264Main:
+    case VAProfileH264High:
+        vaStatus = VA_STATUS_SUCCESS;
+        break;
+
     default:
         assert(0);
         vaStatus = VA_STATUS_ERROR_UNSUPPORTED_PROFILE;
@@ -941,10 +994,18 @@ i965_render_slice_parameter_buffer(VADriverContextP ctx,
 {
     assert(obj_buffer->buffer_store->bo == NULL);
     assert(obj_buffer->buffer_store->buffer);
-    i965_release_buffer_store(&obj_context->decode_state.slice_param);
-    i965_reference_buffer_store(&obj_context->decode_state.slice_param,
+    
+    if (obj_context->decode_state.num_slice_params == obj_context->decode_state.max_slice_params) {
+        obj_context->decode_state.slice_params = realloc(obj_context->decode_state.slice_params,
+                                                        (obj_context->decode_state.max_slice_params + NUM_SLICES) * sizeof(*obj_context->decode_state.slice_params));
+        memset(obj_context->decode_state.slice_params + obj_context->decode_state.max_slice_params, 0, NUM_SLICES * sizeof(*obj_context->decode_state.slice_params));
+        obj_context->decode_state.max_slice_params += NUM_SLICES;
+    }
+        
+    i965_release_buffer_store(&obj_context->decode_state.slice_params[obj_context->decode_state.num_slice_params]);
+    i965_reference_buffer_store(&obj_context->decode_state.slice_params[obj_context->decode_state.num_slice_params],
                                 obj_buffer->buffer_store);
-    obj_context->decode_state.num_slices = obj_buffer->num_elements;    
+    obj_context->decode_state.num_slice_params++;
     
     return VA_STATUS_SUCCESS;
 }
@@ -956,9 +1017,18 @@ i965_render_slice_data_buffer(VADriverContextP ctx,
 {
     assert(obj_buffer->buffer_store->buffer == NULL);
     assert(obj_buffer->buffer_store->bo);
-    i965_release_buffer_store(&obj_context->decode_state.slice_data);
-    i965_reference_buffer_store(&obj_context->decode_state.slice_data,
+
+    if (obj_context->decode_state.num_slice_datas == obj_context->decode_state.max_slice_datas) {
+        obj_context->decode_state.slice_datas = realloc(obj_context->decode_state.slice_datas,
+                                                        (obj_context->decode_state.max_slice_datas + NUM_SLICES) * sizeof(*obj_context->decode_state.slice_datas));
+        memset(obj_context->decode_state.slice_datas + obj_context->decode_state.max_slice_datas, 0, NUM_SLICES * sizeof(*obj_context->decode_state.slice_datas));
+        obj_context->decode_state.max_slice_datas += NUM_SLICES;
+    }
+        
+    i965_release_buffer_store(&obj_context->decode_state.slice_datas[obj_context->decode_state.num_slice_datas]);
+    i965_reference_buffer_store(&obj_context->decode_state.slice_datas[obj_context->decode_state.num_slice_datas],
                                 obj_buffer->buffer_store);
+    obj_context->decode_state.num_slice_datas++;
     
     return VA_STATUS_SUCCESS;
 }
@@ -1014,26 +1084,45 @@ VAStatus
 i965_EndPicture(VADriverContextP ctx, VAContextID context)
 {
     struct i965_driver_data *i965 = i965_driver_data(ctx); 
+    struct i965_render_state *render_state = &i965->render_state;
     struct object_context *obj_context = CONTEXT(context);
     struct object_config *obj_config;
     VAContextID config;
+    int i;
 
     assert(obj_context);
     assert(obj_context->decode_state.pic_param);
-    assert(obj_context->decode_state.slice_param);
-    assert(obj_context->decode_state.slice_data);
+    assert(obj_context->decode_state.num_slice_params >= 1);
+    assert(obj_context->decode_state.num_slice_datas >= 1);
+    assert(obj_context->decode_state.num_slice_params == obj_context->decode_state.num_slice_datas);
 
     config = obj_context->config_id;
     obj_config = CONFIG(config);
     assert(obj_config);
+
+    switch (obj_config->profile) {
+    case VAProfileH264Baseline:
+    case VAProfileH264Main:
+    case VAProfileH264High:
+        render_state->interleaved_uv = 1;
+        break;
+
+    default:
+        render_state->interleaved_uv = 0;
+    }
+
     i965_media_decode_picture(ctx, obj_config->profile, &obj_context->decode_state);
     obj_context->decode_state.current_render_target = -1;
-    obj_context->decode_state.num_slices = 0;
+    obj_context->decode_state.num_slice_params = 0;
+    obj_context->decode_state.num_slice_datas = 0;
     i965_release_buffer_store(&obj_context->decode_state.pic_param);
-    i965_release_buffer_store(&obj_context->decode_state.slice_param);
     i965_release_buffer_store(&obj_context->decode_state.iq_matrix);
     i965_release_buffer_store(&obj_context->decode_state.bit_plane);
-    i965_release_buffer_store(&obj_context->decode_state.slice_data);
+
+    for (i = 0; i < obj_context->decode_state.num_slice_params; i++) {
+        i965_release_buffer_store(&obj_context->decode_state.slice_params[i]);
+        i965_release_buffer_store(&obj_context->decode_state.slice_datas[i]);
+    }
 
     return VA_STATUS_SUCCESS;
 }
@@ -1131,7 +1220,7 @@ i965_Init(VADriverContextP ctx)
         return VA_STATUS_ERROR_UNKNOWN;
 
     if (!IS_G4X(i965->intel.device_id) &&
-        !IS_IGDNG(i965->intel.device_id))
+        !IS_IRONLAKE(i965->intel.device_id))
         return VA_STATUS_ERROR_UNKNOWN;
 
     if (i965_media_init(ctx) == False)
diff --git a/i965_drv_video/i965_drv_video.h b/i965_drv_video/i965_drv_video.h
index fa09869..33b46f3 100644
--- a/i965_drv_video/i965_drv_video.h
+++ b/i965_drv_video/i965_drv_video.h
@@ -53,6 +53,7 @@ struct buffer_store
     unsigned char *buffer;
     dri_bo *bo;
     int ref_count;
+    int num_elements;
 };
     
 struct object_config 
@@ -64,15 +65,20 @@ struct object_config
     int num_attribs;
 };
 
+#define NUM_SLICES     10
+
 struct decode_state
 {
     struct buffer_store *pic_param;
-    struct buffer_store *slice_param;
+    struct buffer_store **slice_params;
     struct buffer_store *iq_matrix;
     struct buffer_store *bit_plane;
-    struct buffer_store *slice_data;
+    struct buffer_store **slice_datas;
     VASurfaceID current_render_target;
-    int num_slices;
+    int max_slice_params;
+    int max_slice_datas;
+    int num_slice_params;
+    int num_slice_datas;
 };
 
 struct object_context 
@@ -97,6 +103,8 @@ struct object_surface
     int height;
     int size;
     dri_bo *bo;
+    void (*free_private_data)(void **data);
+    void *private_data;
 };
 
 struct object_buffer 
diff --git a/i965_drv_video/i965_media.c b/i965_drv_video/i965_media.c
index 82c5652..fe755ab 100644
--- a/i965_drv_video/i965_media.c
+++ b/i965_drv_video/i965_media.c
@@ -38,6 +38,7 @@
 
 #include "i965_defines.h"
 #include "i965_media_mpeg2.h"
+#include "i965_media_h264.h"
 #include "i965_media.h"
 #include "i965_drv_video.h"
 
@@ -72,13 +73,21 @@ static void
 i965_media_state_base_address(VADriverContextP ctx)
 {
     struct i965_driver_data *i965 = i965_driver_data(ctx); 
+    struct i965_media_state *media_state = &i965->media_state;
 
-    if (IS_IGDNG(i965->intel.device_id)) {
+    if (IS_IRONLAKE(i965->intel.device_id)) {
         BEGIN_BATCH(ctx, 8);
         OUT_BATCH(ctx, CMD_STATE_BASE_ADDRESS | 6);
         OUT_BATCH(ctx, 0 | BASE_ADDRESS_MODIFY);
         OUT_BATCH(ctx, 0 | BASE_ADDRESS_MODIFY);
-        OUT_BATCH(ctx, 0 | BASE_ADDRESS_MODIFY);
+        
+        if (media_state->indirect_object.bo) {
+            OUT_RELOC(ctx, media_state->indirect_object.bo, I915_GEM_DOMAIN_INSTRUCTION, 0, 
+                      media_state->indirect_object.offset | BASE_ADDRESS_MODIFY);
+        } else {
+            OUT_BATCH(ctx, 0 | BASE_ADDRESS_MODIFY);
+        }
+
         OUT_BATCH(ctx, 0 | BASE_ADDRESS_MODIFY);
         OUT_BATCH(ctx, 0 | BASE_ADDRESS_MODIFY);
         OUT_BATCH(ctx, 0 | BASE_ADDRESS_MODIFY);
@@ -89,7 +98,14 @@ i965_media_state_base_address(VADriverContextP ctx)
         OUT_BATCH(ctx, CMD_STATE_BASE_ADDRESS | 4);
         OUT_BATCH(ctx, 0 | BASE_ADDRESS_MODIFY);
         OUT_BATCH(ctx, 0 | BASE_ADDRESS_MODIFY);
-        OUT_BATCH(ctx, 0 | BASE_ADDRESS_MODIFY);
+
+        if (media_state->indirect_object.bo) {
+            OUT_RELOC(ctx, media_state->indirect_object.bo, I915_GEM_DOMAIN_INSTRUCTION, 0, 
+                      media_state->indirect_object.offset | BASE_ADDRESS_MODIFY);
+        } else {
+            OUT_BATCH(ctx, 0 | BASE_ADDRESS_MODIFY);
+        }
+
         OUT_BATCH(ctx, 0 | BASE_ADDRESS_MODIFY);
         OUT_BATCH(ctx, 0 | BASE_ADDRESS_MODIFY);
         ADVANCE_BATCH(ctx);
@@ -150,6 +166,20 @@ i965_media_constant_buffer(VADriverContextP ctx, struct decode_state *decode_sta
     ADVANCE_BATCH(ctx);    
 }
 
+static void 
+i965_media_depth_buffer(VADriverContextP ctx)
+{
+    BEGIN_BATCH(ctx, 6);
+    OUT_BATCH(ctx, CMD_DEPTH_BUFFER | 4);
+    OUT_BATCH(ctx, (I965_DEPTHFORMAT_D32_FLOAT << 18) | 
+              (I965_SURFACE_NULL << 29));
+    OUT_BATCH(ctx, 0);
+    OUT_BATCH(ctx, 0);
+    OUT_BATCH(ctx, 0);
+    OUT_BATCH(ctx, 0);
+    ADVANCE_BATCH();
+}
+
 static void
 i965_media_pipeline_setup(VADriverContextP ctx, struct decode_state *decode_state)
 {
@@ -158,6 +188,7 @@ i965_media_pipeline_setup(VADriverContextP ctx, struct decode_state *decode_stat
 
     intel_batchbuffer_start_atomic(ctx, 0x1000);
     intel_batchbuffer_emit_mi_flush(ctx);                       /* step 1 */
+    i965_media_depth_buffer(ctx);
     i965_media_pipeline_select(ctx);                            /* step 2 */
     i965_media_urb_layout(ctx);                                 /* step 3 */
     i965_media_pipeline_state(ctx);                             /* step 4 */
@@ -221,6 +252,12 @@ i965_media_decode_init(VADriverContextP ctx, VAProfile profile)
     case VAProfileMPEG2Main:
         i965_media_mpeg2_decode_init(ctx);
         break;
+        
+    case VAProfileH264Baseline:
+    case VAProfileH264Main:
+    case VAProfileH264High:
+        i965_media_h264_decode_init(ctx);
+        break;
 
     default:
         assert(0);
@@ -237,8 +274,8 @@ i965_media_decode_picture(VADriverContextP ctx,
     struct i965_media_state *media_state = &i965->media_state;
 
     i965_media_decode_init(ctx, profile);
-    assert(media_state->states_setup);
-    media_state->states_setup(ctx, decode_state);
+    assert(media_state->media_states_setup);
+    media_state->media_states_setup(ctx, decode_state);
     i965_media_pipeline_setup(ctx, decode_state);
     intel_batchbuffer_flush(ctx);
 }
@@ -247,6 +284,7 @@ Bool
 i965_media_init(VADriverContextP ctx)
 {
     i965_media_mpeg2_init(ctx);
+    i965_media_h264_init(ctx);
     return True;
 }
 
@@ -277,7 +315,11 @@ i965_media_terminate(VADriverContextP ctx)
     dri_bo_unreference(media_state->curbe.bo);
     media_state->curbe.bo = NULL;
 
+    dri_bo_unreference(media_state->indirect_object.bo);
+    media_state->indirect_object.bo = NULL;
+
     i965_media_mpeg2_ternimate(ctx);
+    i965_media_h264_ternimate(ctx);
     return True;
 }
 
diff --git a/i965_drv_video/i965_media.h b/i965_drv_video/i965_media.h
index e207f4e..b745777 100644
--- a/i965_drv_video/i965_media.h
+++ b/i965_drv_video/i965_media.h
@@ -38,7 +38,7 @@
 #include "i965_structs.h"
 
 #define MAX_INTERFACE_DESC      16
-#define MAX_MEDIA_SURFACES      32
+#define MAX_MEDIA_SURFACES      34
 
 #define MPEG_TOP_FIELD		1
 #define MPEG_BOTTOM_FIELD	2
@@ -83,6 +83,11 @@ struct i965_media_state
     } curbe;
 
     struct {
+        dri_bo *bo;
+        unsigned long offset;
+    } indirect_object;
+
+    struct {
         unsigned int vfe_start;
         unsigned int cs_start;
 
@@ -93,7 +98,8 @@ struct i965_media_state
         unsigned int size_cs_entry;
     } urb;
 
-    void (*states_setup)(VADriverContextP ctx, struct decode_state *decode_state);
+    void *private_context;
+    void (*media_states_setup)(VADriverContextP ctx, struct decode_state *decode_state);
     void (*media_objects)(VADriverContextP ctx, struct decode_state *decode_state);
 };
 
diff --git a/i965_drv_video/i965_media_h264.c b/i965_drv_video/i965_media_h264.c
new file mode 100644
index 0000000..fe8c219
--- /dev/null
+++ b/i965_drv_video/i965_media_h264.c
@@ -0,0 +1,907 @@
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <assert.h>
+
+#include "va_backend.h"
+
+#include "intel_batchbuffer.h"
+#include "intel_driver.h"
+
+#include "i965_defines.h"
+#include "i965_drv_video.h"
+#include "i965_media.h"
+#include "i965_media_h264.h"
+
+enum {
+    INTRA_16X16 = 0,
+    INTRA_8X8,
+    INTRA_4X4,
+    INTRA_PCM,
+    FRAMEMB_MOTION,
+    FIELDMB_MOTION,
+    MBAFF_MOTION,
+};
+
+struct intra_kernel_header
+{
+    /* R1.0 */
+    unsigned char intra_4x4_luma_mode_0_offset;
+    unsigned char intra_4x4_luma_mode_1_offset;
+    unsigned char intra_4x4_luma_mode_2_offset;
+    unsigned char intra_4x4_luma_mode_3_offset;
+    /* R1.1 */
+    unsigned char intra_4x4_luma_mode_4_offset;
+    unsigned char intra_4x4_luma_mode_5_offset;
+    unsigned char intra_4x4_luma_mode_6_offset;
+    unsigned char intra_4x4_luma_mode_7_offset;
+    /* R1.2 */
+    unsigned char intra_4x4_luma_mode_8_offset;
+    unsigned char pad0;
+    unsigned short top_reference_offset;
+    /* R1.3 */
+    unsigned char intra_8x8_luma_mode_0_offset;
+    unsigned char intra_8x8_luma_mode_1_offset;
+    unsigned char intra_8x8_luma_mode_2_offset;
+    unsigned char intra_8x8_luma_mode_3_offset;
+    /* R1.4 */
+    unsigned char intra_8x8_luma_mode_4_offset;
+    unsigned char intra_8x8_luma_mode_5_offset;
+    unsigned char intra_8x8_luma_mode_6_offset;
+    unsigned char intra_8x8_luma_mode_7_offset;
+    /* R1.5 */
+    unsigned char intra_8x8_luma_mode_8_offset;
+    unsigned char pad1;
+    unsigned short const_reverse_data_transfer_intra_8x8;
+    /* R1.6 */
+    unsigned char intra_16x16_luma_mode_0_offset;
+    unsigned char intra_16x16_luma_mode_1_offset;
+    unsigned char intra_16x16_luma_mode_2_offset;
+    unsigned char intra_16x16_luma_mode_3_offset;
+    /* R1.7 */
+    unsigned char intra_chroma_mode_0_offset;
+    unsigned char intra_chroma_mode_1_offset;
+    unsigned char intra_chroma_mode_2_offset;
+    unsigned char intra_chroma_mode_3_offset;
+    /* R2.0 */
+    unsigned int const_intra_16x16_plane_0;
+    /* R2.1 */
+    unsigned int const_intra_16x16_chroma_plane_0;
+    /* R2.2 */
+    unsigned int const_intra_16x16_chroma_plane_1;
+    /* R2.3 */
+    unsigned int const_intra_16x16_plane_1;
+    /* R2.4 */
+    unsigned int left_shift_count_reverse_dw_ordering;
+    /* R2.5 */
+    unsigned int const_reverse_data_transfer_intra_4x4;
+    /* R2.6 */
+    unsigned int intra_4x4_pred_mode_offset;
+};
+
+struct inter_kernel_header
+{
+    unsigned short weight_offset;
+    unsigned char weight_offset_flag;
+    unsigned char pad0;
+};
+
+#include "shaders/h264/mc/export.inc"
+static unsigned long avc_mc_kernel_offset_gen4[] = {
+    INTRA_16x16_IP,
+    INTRA_8x8_IP,
+    INTRA_4x4_IP,
+    INTRA_PCM_IP,
+    FRAME_MB_IP,
+    FIELD_MB_IP,
+    MBAFF_MB_IP
+};
+
+#define INST_UNIT_GEN4  16
+struct intra_kernel_header intra_kernel_header_gen4 = {
+    0 / INST_UNIT_GEN4,
+    (INTRA_4X4_HORIZONTAL_IP - INTRA_4X4_VERTICAL_IP) / INST_UNIT_GEN4,
+    (INTRA_4X4_DC_IP - INTRA_4X4_VERTICAL_IP) / INST_UNIT_GEN4,
+    (INTRA_4X4_DIAG_DOWN_LEFT_IP - INTRA_4X4_VERTICAL_IP) / INST_UNIT_GEN4,
+
+    (INTRA_4X4_DIAG_DOWN_RIGHT_IP - INTRA_4X4_VERTICAL_IP) / INST_UNIT_GEN4,
+    (INTRA_4X4_VERT_RIGHT_IP - INTRA_4X4_VERTICAL_IP) / INST_UNIT_GEN4,
+    (INTRA_4X4_HOR_DOWN_IP - INTRA_4X4_VERTICAL_IP) / INST_UNIT_GEN4,
+    (INTRA_4X4_VERT_LEFT_IP - INTRA_4X4_VERTICAL_IP) / INST_UNIT_GEN4,
+
+    (INTRA_4X4_HOR_UP_IP - INTRA_4X4_VERTICAL_IP) / INST_UNIT_GEN4,
+    0,
+    0xFFFC,
+
+    0 / INST_UNIT_GEN4,
+    (INTRA_8X8_HORIZONTAL_IP - INTRA_8X8_VERTICAL_IP) / INST_UNIT_GEN4,
+    (INTRA_8X8_DC_IP - INTRA_8X8_VERTICAL_IP) / INST_UNIT_GEN4,
+    (INTRA_8X8_DIAG_DOWN_LEFT_IP - INTRA_8X8_VERTICAL_IP) / INST_UNIT_GEN4,
+
+    (INTRA_8X8_DIAG_DOWN_RIGHT_IP - INTRA_8X8_VERTICAL_IP) / INST_UNIT_GEN4,
+    (INTRA_8X8_VERT_RIGHT_IP - INTRA_8X8_VERTICAL_IP) / INST_UNIT_GEN4,
+    (INTRA_8X8_HOR_DOWN_IP - INTRA_8X8_VERTICAL_IP) / INST_UNIT_GEN4,
+    (INTRA_8X8_VERT_LEFT_IP - INTRA_8X8_VERTICAL_IP) / INST_UNIT_GEN4,
+
+    (INTRA_8X8_HOR_UP_IP - INTRA_8X8_VERTICAL_IP) / INST_UNIT_GEN4,
+    0,
+    0x0001,
+
+    0 / INST_UNIT_GEN4,
+    (INTRA_16x16_HORIZONTAL_IP - INTRA_16x16_VERTICAL_IP) / INST_UNIT_GEN4,
+    (INTRA_16x16_DC_IP - INTRA_16x16_VERTICAL_IP) / INST_UNIT_GEN4,
+    (INTRA_16x16_PLANE_IP - INTRA_16x16_VERTICAL_IP) / INST_UNIT_GEN4,
+
+    0 / INST_UNIT_GEN4,
+    (INTRA_CHROMA_HORIZONTAL_IP - INTRA_CHROMA_DC_IP) / INST_UNIT_GEN4,
+    (INTRA_CHROMA_VERTICAL_IP - INTRA_CHROMA_DC_IP) / INST_UNIT_GEN4,
+    (INTRA_Chroma_PLANE_IP - INTRA_CHROMA_DC_IP) / INST_UNIT_GEN4,
+
+    0xFCFBFAF9,
+
+    0x00FFFEFD,
+
+    0x04030201,
+
+    0x08070605,
+
+    0x18100800,
+
+    0x00020406,
+
+    (intra_Pred_4x4_Y_IP - ADD_ERROR_SB3_IP) / INST_UNIT_GEN4 * 0x1000000 + 
+    (intra_Pred_4x4_Y_IP - ADD_ERROR_SB2_IP) / INST_UNIT_GEN4 * 0x10000 + 
+    (intra_Pred_4x4_Y_IP - ADD_ERROR_SB1_IP) / INST_UNIT_GEN4 * 0x100 + 
+    (intra_Pred_4x4_Y_IP - ADD_ERROR_SB0_IP) / INST_UNIT_GEN4
+};
+
+static uint32_t h264_avc_combined_gen4[][4] = {
+#include "shaders/h264/mc/avc_mc.g4b"
+};
+
+static uint32_t h264_avc_null_gen4[][4] = {
+#include "shaders/h264/mc/null.g4b"
+};
+
+static struct media_kernel h264_avc_kernels_gen4[] = {
+    {
+        "AVC combined kernel",
+        H264_AVC_COMBINED,
+        h264_avc_combined_gen4,
+        sizeof(h264_avc_combined_gen4),
+        NULL
+    },
+
+    {
+        "NULL kernel",
+        H264_AVC_NULL,
+        h264_avc_null_gen4,
+        sizeof(h264_avc_null_gen4),
+        NULL
+    }
+};
+
+/* On Ironlake */
+#include "shaders/h264/mc/export.inc.gen5"
+static unsigned long avc_mc_kernel_offset_gen5[] = {
+    INTRA_16x16_IP_GEN5,
+    INTRA_8x8_IP_GEN5,
+    INTRA_4x4_IP_GEN5,
+    INTRA_PCM_IP_GEN5,
+    FRAME_MB_IP_GEN5,
+    FIELD_MB_IP_GEN5,
+    MBAFF_MB_IP_GEN5
+};
+
+#define INST_UNIT_GEN5  8
+
+struct intra_kernel_header intra_kernel_header_gen5 = {
+    0 / INST_UNIT_GEN5,
+    (INTRA_4X4_HORIZONTAL_IP_GEN5 - INTRA_4X4_VERTICAL_IP_GEN5) / INST_UNIT_GEN5,
+    (INTRA_4X4_DC_IP_GEN5 - INTRA_4X4_VERTICAL_IP_GEN5) / INST_UNIT_GEN5,
+    (INTRA_4X4_DIAG_DOWN_LEFT_IP_GEN5 - INTRA_4X4_VERTICAL_IP_GEN5) / INST_UNIT_GEN5,
+
+    (INTRA_4X4_DIAG_DOWN_RIGHT_IP_GEN5 - INTRA_4X4_VERTICAL_IP_GEN5) / INST_UNIT_GEN5,
+    (INTRA_4X4_VERT_RIGHT_IP_GEN5 - INTRA_4X4_VERTICAL_IP_GEN5) / INST_UNIT_GEN5,
+    (INTRA_4X4_HOR_DOWN_IP_GEN5 - INTRA_4X4_VERTICAL_IP_GEN5) / INST_UNIT_GEN5,
+    (INTRA_4X4_VERT_LEFT_IP_GEN5 - INTRA_4X4_VERTICAL_IP_GEN5) / INST_UNIT_GEN5,
+
+    (INTRA_4X4_HOR_UP_IP_GEN5 - INTRA_4X4_VERTICAL_IP_GEN5) / INST_UNIT_GEN5,
+    0,
+    0xFFFC,
+
+    0 / INST_UNIT_GEN5,
+    (INTRA_8X8_HORIZONTAL_IP_GEN5 - INTRA_8X8_VERTICAL_IP_GEN5) / INST_UNIT_GEN5,
+    (INTRA_8X8_DC_IP_GEN5 - INTRA_8X8_VERTICAL_IP_GEN5) / INST_UNIT_GEN5,
+    (INTRA_8X8_DIAG_DOWN_LEFT_IP_GEN5 - INTRA_8X8_VERTICAL_IP_GEN5) / INST_UNIT_GEN5,
+
+    (INTRA_8X8_DIAG_DOWN_RIGHT_IP_GEN5 - INTRA_8X8_VERTICAL_IP_GEN5) / INST_UNIT_GEN5,
+    (INTRA_8X8_VERT_RIGHT_IP_GEN5 - INTRA_8X8_VERTICAL_IP_GEN5) / INST_UNIT_GEN5,
+    (INTRA_8X8_HOR_DOWN_IP_GEN5 - INTRA_8X8_VERTICAL_IP_GEN5) / INST_UNIT_GEN5,
+    (INTRA_8X8_VERT_LEFT_IP_GEN5 - INTRA_8X8_VERTICAL_IP_GEN5) / INST_UNIT_GEN5,
+
+    (INTRA_8X8_HOR_UP_IP_GEN5 - INTRA_8X8_VERTICAL_IP_GEN5) / INST_UNIT_GEN5,
+    0,
+    0x0001,
+
+    0 / INST_UNIT_GEN5,
+    (INTRA_16x16_HORIZONTAL_IP_GEN5 - INTRA_16x16_VERTICAL_IP_GEN5) / INST_UNIT_GEN5,
+    (INTRA_16x16_DC_IP_GEN5 - INTRA_16x16_VERTICAL_IP_GEN5) / INST_UNIT_GEN5,
+    (INTRA_16x16_PLANE_IP_GEN5 - INTRA_16x16_VERTICAL_IP_GEN5) / INST_UNIT_GEN5,
+
+    0 / INST_UNIT_GEN5,
+    (INTRA_CHROMA_HORIZONTAL_IP_GEN5 - INTRA_CHROMA_DC_IP_GEN5) / INST_UNIT_GEN5,
+    (INTRA_CHROMA_VERTICAL_IP_GEN5 - INTRA_CHROMA_DC_IP_GEN5) / INST_UNIT_GEN5,
+    (INTRA_Chroma_PLANE_IP_GEN5 - INTRA_CHROMA_DC_IP_GEN5) / INST_UNIT_GEN5,
+
+    0xFCFBFAF9,
+
+    0x00FFFEFD,
+
+    0x04030201,
+
+    0x08070605,
+
+    0x18100800,
+
+    0x00020406,
+
+    (intra_Pred_4x4_Y_IP_GEN5 - ADD_ERROR_SB3_IP_GEN5) / INST_UNIT_GEN5 * 0x1000000 + 
+    (intra_Pred_4x4_Y_IP_GEN5 - ADD_ERROR_SB2_IP_GEN5) / INST_UNIT_GEN5 * 0x10000 + 
+    (intra_Pred_4x4_Y_IP_GEN5 - ADD_ERROR_SB1_IP_GEN5) / INST_UNIT_GEN5 * 0x100 + 
+    (intra_Pred_4x4_Y_IP_GEN5 - ADD_ERROR_SB0_IP_GEN5) / INST_UNIT_GEN5
+};
+
+static uint32_t h264_avc_combined_gen5[][4] = {
+#include "shaders/h264/mc/avc_mc.g4b.gen5"
+};
+
+static uint32_t h264_avc_null_gen5[][4] = {
+#include "shaders/h264/mc/null.g4b.gen5"
+};
+
+static struct media_kernel h264_avc_kernels_gen5[] = {
+    {
+        "AVC combined kernel",
+        H264_AVC_COMBINED,
+        h264_avc_combined_gen5,
+        sizeof(h264_avc_combined_gen5),
+        NULL
+    },
+
+    {
+        "NULL kernel",
+        H264_AVC_NULL,
+        h264_avc_null_gen5,
+        sizeof(h264_avc_null_gen5),
+        NULL
+    }
+};
+
+#define NUM_H264_AVC_KERNELS (sizeof(h264_avc_kernels_gen4) / sizeof(h264_avc_kernels_gen4[0]))
+struct media_kernel *h264_avc_kernels = NULL;
+
+#define NUM_AVC_MC_INTERFACES (sizeof(avc_mc_kernel_offset_gen4) / sizeof(avc_mc_kernel_offset_gen4[0]))
+static unsigned long *avc_mc_kernel_offset = NULL;
+
+static struct intra_kernel_header *intra_kernel_header = NULL;
+
+static void
+i965_media_h264_surface_state(VADriverContextP ctx, 
+                              int index,
+                              struct object_surface *obj_surface,
+                              unsigned long offset, 
+                              int w, int h, int pitch,
+                              Bool is_dst,
+                              int vert_line_stride,
+                              int vert_line_stride_ofs,
+                              int format)
+{
+    struct i965_driver_data *i965 = i965_driver_data(ctx);  
+    struct i965_media_state *media_state = &i965->media_state;
+    struct i965_surface_state *ss;
+    dri_bo *bo;
+    uint32_t write_domain, read_domain;
+
+    bo = dri_bo_alloc(i965->intel.bufmgr, 
+                      "surface state", 
+                      sizeof(struct i965_surface_state), 32);
+    assert(bo);
+    dri_bo_map(bo, 1);
+    assert(bo->virtual);
+    ss = bo->virtual;
+    memset(ss, 0, sizeof(*ss));
+    ss->ss0.surface_type = I965_SURFACE_2D;
+    ss->ss0.surface_format = format;
+    ss->ss0.vert_line_stride = vert_line_stride;
+    ss->ss0.vert_line_stride_ofs = vert_line_stride_ofs;
+    ss->ss1.base_addr = obj_surface->bo->offset + offset;
+    ss->ss2.width = w - 1;
+    ss->ss2.height = h - 1;
+    ss->ss3.pitch = pitch - 1;
+
+    if (is_dst) {
+        write_domain = I915_GEM_DOMAIN_RENDER;
+        read_domain = I915_GEM_DOMAIN_RENDER;
+    } else {
+        write_domain = 0;
+        read_domain = I915_GEM_DOMAIN_SAMPLER;
+    }
+
+    dri_bo_emit_reloc(bo,
+                      read_domain, write_domain,
+                      offset,
+                      offsetof(struct i965_surface_state, ss1),
+                      obj_surface->bo);
+    dri_bo_unmap(bo);
+
+    assert(index < MAX_MEDIA_SURFACES);
+    media_state->surface_state[index].bo = bo;
+}
+
+static void 
+i965_media_h264_surfaces_setup(VADriverContextP ctx, 
+                               struct decode_state *decode_state)
+{
+    struct i965_driver_data *i965 = i965_driver_data(ctx);  
+    struct i965_media_state *media_state = &i965->media_state;
+    struct i965_h264_context *i965_h264_context;
+    struct object_surface *obj_surface;
+    VAPictureParameterBufferH264 *pic_param;
+    VAPictureH264 *va_pic;
+    int i, j, w, h;
+    int field_picture;
+
+    assert(media_state->private_context);
+    i965_h264_context = (struct i965_h264_context *)media_state->private_context;
+
+    assert(decode_state->pic_param && decode_state->pic_param->buffer);
+    pic_param = (VAPictureParameterBufferH264 *)decode_state->pic_param->buffer;
+
+    /* Target Picture */
+    va_pic = &pic_param->CurrPic;
+    assert(!(va_pic->flags & VA_PICTURE_H264_INVALID));
+    obj_surface = SURFACE(va_pic->picture_id);
+    assert(obj_surface);
+    w = obj_surface->width;
+    h = obj_surface->height;
+    field_picture = !!(va_pic->flags & (VA_PICTURE_H264_TOP_FIELD | VA_PICTURE_H264_BOTTOM_FIELD));
+    i965_media_h264_surface_state(ctx, 0, obj_surface,
+                                  0, w / 4, h / (1 + field_picture), w,
+                                  1, 
+                                  field_picture,
+                                  !!(va_pic->flags & VA_PICTURE_H264_BOTTOM_FIELD),
+                                  I965_SURFACEFORMAT_R8_SINT); /* Y */
+    i965_media_h264_surface_state(ctx, 1, obj_surface,
+                                  w * h, w / 4, h / 2 / (1 + field_picture), w,
+                                  1, 
+                                  field_picture,
+                                  !!(va_pic->flags & VA_PICTURE_H264_BOTTOM_FIELD),
+                                  I965_SURFACEFORMAT_R8G8_SINT);  /* INTERLEAVED U/V */
+
+    /* Reference Pictures */
+    for (i = 0; i < ARRAY_ELEMS(i965_h264_context->fsid_list); i++) {
+        if (i965_h264_context->fsid_list[i].surface_id != VA_INVALID_ID) {
+            int found = 0;
+            for (j = 0; j < ARRAY_ELEMS(pic_param->ReferenceFrames); j++) {
+                va_pic = &pic_param->ReferenceFrames[j];
+                
+                if (va_pic->flags & VA_PICTURE_H264_INVALID)
+                    continue;
+
+                if (va_pic->picture_id == i965_h264_context->fsid_list[i].surface_id) {
+                    found = 1;
+                    break;
+                }
+            }
+
+            assert(found == 1);
+
+            obj_surface = SURFACE(va_pic->picture_id);
+            assert(obj_surface);
+            w = obj_surface->width;
+            h = obj_surface->height;
+            field_picture = !!(va_pic->flags & (VA_PICTURE_H264_TOP_FIELD | VA_PICTURE_H264_BOTTOM_FIELD));
+            i965_media_h264_surface_state(ctx, 2 + i, obj_surface,
+                                          0, w / 4, h / (1 + field_picture), w,
+                                          0, 
+                                          field_picture,
+                                          !!(va_pic->flags & VA_PICTURE_H264_BOTTOM_FIELD),
+                                          I965_SURFACEFORMAT_R8_SINT); /* Y */
+            i965_media_h264_surface_state(ctx, 18 + i, obj_surface,
+                                          w * h, w / 4, h / 2 / (1 + field_picture), w,
+                                          0, 
+                                          field_picture,
+                                          !!(va_pic->flags & VA_PICTURE_H264_BOTTOM_FIELD),
+                                          I965_SURFACEFORMAT_R8G8_SINT);  /* INTERLEAVED U/V */
+        }
+    }
+}
+
+static void
+i965_media_h264_binding_table(VADriverContextP ctx)
+{
+    struct i965_driver_data *i965 = i965_driver_data(ctx);
+    struct i965_media_state *media_state = &i965->media_state;
+    int i;
+    unsigned int *binding_table;
+    dri_bo *bo = media_state->binding_table.bo;
+
+    dri_bo_map(bo, 1);
+    assert(bo->virtual);
+    binding_table = bo->virtual;
+    memset(binding_table, 0, bo->size);
+
+    for (i = 0; i < MAX_MEDIA_SURFACES; i++) {
+        if (media_state->surface_state[i].bo) {
+            binding_table[i] = media_state->surface_state[i].bo->offset;
+            dri_bo_emit_reloc(bo,
+                              I915_GEM_DOMAIN_INSTRUCTION, 0,
+                              0,
+                              i * sizeof(*binding_table),
+                              media_state->surface_state[i].bo);
+        }
+    }
+
+    dri_bo_unmap(media_state->binding_table.bo);
+}
+
+static void 
+i965_media_h264_interface_descriptor_remap_table(VADriverContextP ctx)
+{
+    struct i965_driver_data *i965 = i965_driver_data(ctx);
+    struct i965_media_state *media_state = &i965->media_state;
+    struct i965_interface_descriptor *desc;
+    int i;
+    dri_bo *bo;
+
+    bo = media_state->idrt.bo;
+    dri_bo_map(bo, 1);
+    assert(bo->virtual);
+    desc = bo->virtual;
+
+    for (i = 0; i < NUM_AVC_MC_INTERFACES; i++) {
+        int kernel_offset = avc_mc_kernel_offset[i];
+        memset(desc, 0, sizeof(*desc));
+        desc->desc0.grf_reg_blocks = 7; 
+        desc->desc0.kernel_start_pointer = (h264_avc_kernels[H264_AVC_COMBINED].bo->offset + kernel_offset) >> 6; /* reloc */
+        desc->desc1.const_urb_entry_read_offset = 0;
+        desc->desc1.const_urb_entry_read_len = 2;
+        desc->desc3.binding_table_entry_count = 0;
+        desc->desc3.binding_table_pointer = 
+            media_state->binding_table.bo->offset >> 5; /*reloc */
+
+        dri_bo_emit_reloc(bo,
+                          I915_GEM_DOMAIN_INSTRUCTION, 0,
+                          desc->desc0.grf_reg_blocks + kernel_offset,
+                          i * sizeof(*desc) + offsetof(struct i965_interface_descriptor, desc0),
+                          h264_avc_kernels[H264_AVC_COMBINED].bo);
+
+        dri_bo_emit_reloc(bo,
+                          I915_GEM_DOMAIN_INSTRUCTION, 0,
+                          desc->desc3.binding_table_entry_count,
+                          i * sizeof(*desc) + offsetof(struct i965_interface_descriptor, desc3),
+                          media_state->binding_table.bo);
+        desc++;
+    }
+
+    dri_bo_unmap(bo);
+}
+
+static void
+i965_media_h264_vfe_state(VADriverContextP ctx)
+{
+    struct i965_driver_data *i965 = i965_driver_data(ctx);
+    struct i965_media_state *media_state = &i965->media_state;
+    struct i965_vfe_state *vfe_state;
+    dri_bo *bo;
+
+    bo = media_state->vfe_state.bo;
+    dri_bo_map(bo, 1);
+    assert(bo->virtual);
+    vfe_state = bo->virtual;
+    memset(vfe_state, 0, sizeof(*vfe_state));
+    vfe_state->vfe0.extend_vfe_state_present = 1;
+    vfe_state->vfe1.max_threads = media_state->urb.num_vfe_entries - 1;
+    vfe_state->vfe1.urb_entry_alloc_size = media_state->urb.size_vfe_entry - 1;
+    vfe_state->vfe1.num_urb_entries = media_state->urb.num_vfe_entries;
+    vfe_state->vfe1.vfe_mode = VFE_AVC_IT_MODE;
+    vfe_state->vfe1.children_present = 0;
+    vfe_state->vfe2.interface_descriptor_base = 
+        media_state->idrt.bo->offset >> 4; /* reloc */
+    dri_bo_emit_reloc(bo,
+                      I915_GEM_DOMAIN_INSTRUCTION, 0,
+                      0,
+                      offsetof(struct i965_vfe_state, vfe2),
+                      media_state->idrt.bo);
+    dri_bo_unmap(bo);
+}
+
+static void 
+i965_media_h264_vfe_state_extension(VADriverContextP ctx, 
+                                    struct decode_state *decode_state)
+{
+    struct i965_driver_data *i965 = i965_driver_data(ctx);
+    struct i965_media_state *media_state = &i965->media_state;
+    struct i965_h264_context *i965_h264_context;
+    struct i965_vfe_state_ex *vfe_state_ex;
+    VAPictureParameterBufferH264 *pic_param;
+    VASliceParameterBufferH264 *slice_param;
+    int mbaff_frame_flag;
+
+    assert(media_state->private_context);
+    i965_h264_context = (struct i965_h264_context *)media_state->private_context;
+
+    assert(decode_state->pic_param && decode_state->pic_param->buffer);
+    pic_param = (VAPictureParameterBufferH264 *)decode_state->pic_param->buffer;
+
+    assert(decode_state->slice_params[0] && decode_state->slice_params[0]->buffer);
+    slice_param = (VASliceParameterBufferH264 *)decode_state->slice_params[0]->buffer;
+
+    mbaff_frame_flag = (pic_param->seq_fields.bits.mb_adaptive_frame_field_flag &&
+                        !pic_param->pic_fields.bits.field_pic_flag);
+
+    assert(media_state->extended_state.bo);
+    dri_bo_map(media_state->extended_state.bo, 1);
+    assert(media_state->extended_state.bo->virtual);
+    vfe_state_ex = media_state->extended_state.bo->virtual;
+    memset(vfe_state_ex, 0, sizeof(*vfe_state_ex));
+
+    /*
+     * Indirect data buffer:
+     * --------------------------------------------------------
+     * | Motion Vectors | Weight/Offset data | Residual data |
+     * --------------------------------------------------------
+     * R4-R7: Motion Vectors
+     * R8-R9: Weight/Offset
+     * R10-R33: Residual data
+     */
+    vfe_state_ex->vfex1.avc.residual_data_fix_offset_flag = !!RESIDUAL_DATA_OFFSET;
+    vfe_state_ex->vfex1.avc.residual_data_offset = RESIDUAL_DATA_OFFSET;
+
+    if (slice_param->slice_type == SLICE_TYPE_I ||
+        slice_param->slice_type == SLICE_TYPE_SI) 
+        vfe_state_ex->vfex1.avc.sub_field_present_flag = PRESENT_NOMV; /* NoMV */
+    else 
+        vfe_state_ex->vfex1.avc.sub_field_present_flag = PRESENT_MV_WO; /* Both MV and W/O */
+
+    if (vfe_state_ex->vfex1.avc.sub_field_present_flag == 0) {
+        vfe_state_ex->vfex1.avc.weight_grf_offset = 0;
+        vfe_state_ex->vfex1.avc.residual_grf_offset = 0;
+    } else {
+        vfe_state_ex->vfex1.avc.weight_grf_offset = 4;
+        vfe_state_ex->vfex1.avc.residual_grf_offset = 6;
+    }
+
+    if (!pic_param->pic_fields.bits.field_pic_flag) {
+        if (mbaff_frame_flag) {
+            vfe_state_ex->remap_table0.remap_index_0 = INTRA_16X16;
+            vfe_state_ex->remap_table0.remap_index_1 = INTRA_8X8;
+            vfe_state_ex->remap_table0.remap_index_2 = INTRA_4X4;
+            vfe_state_ex->remap_table0.remap_index_3 = INTRA_PCM;
+            vfe_state_ex->remap_table0.remap_index_4 = MBAFF_MOTION;
+            vfe_state_ex->remap_table0.remap_index_5 = MBAFF_MOTION;
+            vfe_state_ex->remap_table0.remap_index_6 = MBAFF_MOTION;
+            vfe_state_ex->remap_table0.remap_index_7 = MBAFF_MOTION;
+
+            vfe_state_ex->remap_table1.remap_index_8 = MBAFF_MOTION;
+            vfe_state_ex->remap_table1.remap_index_9 = MBAFF_MOTION;
+            vfe_state_ex->remap_table1.remap_index_10 = MBAFF_MOTION;
+            vfe_state_ex->remap_table1.remap_index_11 = MBAFF_MOTION;
+            vfe_state_ex->remap_table1.remap_index_12 = MBAFF_MOTION;
+            vfe_state_ex->remap_table1.remap_index_13 = MBAFF_MOTION;
+            vfe_state_ex->remap_table1.remap_index_14 = MBAFF_MOTION;
+            vfe_state_ex->remap_table1.remap_index_15 = MBAFF_MOTION;
+        } else {
+            vfe_state_ex->remap_table0.remap_index_0 = INTRA_16X16;
+            vfe_state_ex->remap_table0.remap_index_1 = INTRA_8X8;
+            vfe_state_ex->remap_table0.remap_index_2 = INTRA_4X4;
+            vfe_state_ex->remap_table0.remap_index_3 = INTRA_PCM;
+            vfe_state_ex->remap_table0.remap_index_4 = FRAMEMB_MOTION;
+            vfe_state_ex->remap_table0.remap_index_5 = FRAMEMB_MOTION;
+            vfe_state_ex->remap_table0.remap_index_6 = FRAMEMB_MOTION;
+            vfe_state_ex->remap_table0.remap_index_7 = FRAMEMB_MOTION;
+
+            vfe_state_ex->remap_table1.remap_index_8 = FRAMEMB_MOTION;
+            vfe_state_ex->remap_table1.remap_index_9 = FRAMEMB_MOTION;
+            vfe_state_ex->remap_table1.remap_index_10 = FRAMEMB_MOTION;
+            vfe_state_ex->remap_table1.remap_index_11 = FRAMEMB_MOTION;
+            vfe_state_ex->remap_table1.remap_index_12 = FRAMEMB_MOTION;
+            vfe_state_ex->remap_table1.remap_index_13 = FRAMEMB_MOTION;
+            vfe_state_ex->remap_table1.remap_index_14 = FRAMEMB_MOTION;
+            vfe_state_ex->remap_table1.remap_index_15 = FRAMEMB_MOTION;
+        }
+    } else {
+        vfe_state_ex->remap_table0.remap_index_0 = INTRA_16X16;
+        vfe_state_ex->remap_table0.remap_index_1 = INTRA_8X8;
+        vfe_state_ex->remap_table0.remap_index_2 = INTRA_4X4;
+        vfe_state_ex->remap_table0.remap_index_3 = INTRA_PCM;
+        vfe_state_ex->remap_table0.remap_index_4 = FIELDMB_MOTION;
+        vfe_state_ex->remap_table0.remap_index_5 = FIELDMB_MOTION;
+        vfe_state_ex->remap_table0.remap_index_6 = FIELDMB_MOTION;
+        vfe_state_ex->remap_table0.remap_index_7 = FIELDMB_MOTION;
+
+        vfe_state_ex->remap_table1.remap_index_8 = FIELDMB_MOTION;
+        vfe_state_ex->remap_table1.remap_index_9 = FIELDMB_MOTION;
+        vfe_state_ex->remap_table1.remap_index_10 = FIELDMB_MOTION;
+        vfe_state_ex->remap_table1.remap_index_11 = FIELDMB_MOTION;
+        vfe_state_ex->remap_table1.remap_index_12 = FIELDMB_MOTION;
+        vfe_state_ex->remap_table1.remap_index_13 = FIELDMB_MOTION;
+        vfe_state_ex->remap_table1.remap_index_14 = FIELDMB_MOTION;
+        vfe_state_ex->remap_table1.remap_index_15 = FIELDMB_MOTION;
+    }
+
+    if (i965_h264_context->use_avc_hw_scoreboard) {
+        vfe_state_ex->scoreboard0.enable = 1;
+        vfe_state_ex->scoreboard0.type = SCOREBOARD_STALLING;
+        vfe_state_ex->scoreboard0.mask = 0xff;
+
+        vfe_state_ex->scoreboard1.delta_x0 = -1;
+        vfe_state_ex->scoreboard1.delta_y0 = 0;
+        vfe_state_ex->scoreboard1.delta_x1 = 0;
+        vfe_state_ex->scoreboard1.delta_y1 = -1;
+        vfe_state_ex->scoreboard1.delta_x2 = 1;
+        vfe_state_ex->scoreboard1.delta_y2 = -1;
+        vfe_state_ex->scoreboard1.delta_x3 = -1;
+        vfe_state_ex->scoreboard1.delta_y3 = -1;
+
+        vfe_state_ex->scoreboard2.delta_x4 = -1;
+        vfe_state_ex->scoreboard2.delta_y4 = 1;
+        vfe_state_ex->scoreboard2.delta_x5 = 0;
+        vfe_state_ex->scoreboard2.delta_y5 = -2;
+        vfe_state_ex->scoreboard2.delta_x6 = 1;
+        vfe_state_ex->scoreboard2.delta_y6 = -2;
+        vfe_state_ex->scoreboard2.delta_x7 = -1;
+        vfe_state_ex->scoreboard2.delta_y7 = -2;
+    }
+
+    dri_bo_unmap(media_state->extended_state.bo);
+}
+
+static void
+i965_media_h264_upload_constants(VADriverContextP ctx, struct decode_state *decode_state)
+{
+    struct i965_driver_data *i965 = i965_driver_data(ctx);
+    struct i965_media_state *media_state = &i965->media_state;
+    struct i965_h264_context *i965_h264_context;
+    unsigned char *constant_buffer;
+    VASliceParameterBufferH264 *slice_param;
+
+    assert(media_state->private_context);
+    i965_h264_context = (struct i965_h264_context *)media_state->private_context;
+
+    assert(decode_state->slice_params[0] && decode_state->slice_params[0]->buffer);
+    slice_param = (VASliceParameterBufferH264 *)decode_state->slice_params[0]->buffer;
+
+    dri_bo_map(media_state->curbe.bo, 1);
+    assert(media_state->curbe.bo->virtual);
+    constant_buffer = media_state->curbe.bo->virtual;
+
+    /* HW solution for W=128 */
+    if (i965_h264_context->use_hw_w128) {
+        memcpy(constant_buffer, intra_kernel_header, sizeof(*intra_kernel_header));
+    } else {
+        if (slice_param->slice_type == SLICE_TYPE_I ||
+            slice_param->slice_type == SLICE_TYPE_SI) {
+            memcpy(constant_buffer, intra_kernel_header, sizeof(*intra_kernel_header));
+        } else {
+            /* FIXME: Need to upload CURBE data to inter kernel interface 
+             * to support weighted prediction work-around 
+             */
+            *(short *)constant_buffer = i965_h264_context->weight128_offset0;
+            constant_buffer += 2;
+            *(char *)constant_buffer = i965_h264_context->weight128_offset0_flag;
+            constant_buffer++;
+            *constant_buffer = 0;
+        }
+    }
+
+    dri_bo_unmap(media_state->curbe.bo);
+}
+
+static void
+i965_media_h264_states_setup(VADriverContextP ctx, struct decode_state *decode_state)
+{
+    struct i965_driver_data *i965 = i965_driver_data(ctx);
+    struct i965_media_state *media_state = &i965->media_state;
+    struct i965_h264_context *i965_h264_context;
+    VAPictureParameterBufferH264 *pic_param;
+    unsigned int *object_command;
+
+    assert(media_state->private_context);
+    i965_h264_context = (struct i965_h264_context *)media_state->private_context;
+    assert(decode_state->pic_param && decode_state->pic_param->buffer);
+    pic_param = (VAPictureParameterBufferH264 *)decode_state->pic_param->buffer;
+
+    i965_h264_context->picture.width_in_mbs = ((pic_param->picture_width_in_mbs_minus1 + 1) & 0xff);
+    i965_h264_context->picture.height_in_mbs = ((pic_param->picture_height_in_mbs_minus1 + 1) & 0xff) / 
+        (1 + !!pic_param->pic_fields.bits.field_pic_flag); /* picture height */
+    i965_h264_context->picture.mbaff_frame_flag = (pic_param->seq_fields.bits.mb_adaptive_frame_field_flag &&
+                                                   !pic_param->pic_fields.bits.field_pic_flag);
+
+    i965_h264_context->avc_it_command_mb_info.mbs = (i965_h264_context->picture.width_in_mbs * 
+                                                     i965_h264_context->picture.height_in_mbs);
+
+    i965_avc_bsd_pipeline(ctx, decode_state);
+
+    dri_bo_map(i965_h264_context->avc_it_command_mb_info.bo, True);
+    assert(i965_h264_context->avc_it_command_mb_info.bo->virtual);
+    object_command = i965_h264_context->avc_it_command_mb_info.bo->virtual;
+    memset(object_command, 0, i965_h264_context->avc_it_command_mb_info.mbs * i965_h264_context->use_avc_hw_scoreboard * MB_CMD_IN_BYTES);
+    object_command += i965_h264_context->avc_it_command_mb_info.mbs * (1 + i965_h264_context->use_avc_hw_scoreboard) * MB_CMD_IN_DWS;
+    *object_command = MI_BATCH_BUFFER_END;
+    dri_bo_unmap(i965_h264_context->avc_it_command_mb_info.bo);
+
+    i965_avc_hw_scoreboard(ctx, decode_state);
+
+    i965_media_h264_surfaces_setup(ctx, decode_state);
+    i965_media_h264_binding_table(ctx);
+    i965_media_h264_interface_descriptor_remap_table(ctx);
+    i965_media_h264_vfe_state_extension(ctx, decode_state);
+    i965_media_h264_vfe_state(ctx);
+    i965_media_h264_upload_constants(ctx, decode_state);
+}
+
+static void
+i965_media_h264_objects(VADriverContextP ctx, struct decode_state *decode_state)
+{
+    struct i965_driver_data *i965 = i965_driver_data(ctx);
+    struct i965_media_state *media_state = &i965->media_state;
+    struct i965_h264_context *i965_h264_context;
+
+    assert(media_state->private_context);
+    i965_h264_context = (struct i965_h264_context *)media_state->private_context;
+    
+    BEGIN_BATCH(ctx, 2);
+    OUT_BATCH(ctx, MI_BATCH_BUFFER_START | (2 << 6));
+    OUT_RELOC(ctx, i965_h264_context->avc_it_command_mb_info.bo, 
+              I915_GEM_DOMAIN_COMMAND, 0, 
+              0);
+    ADVANCE_BATCH(ctx);
+}
+
+void
+i965_media_h264_decode_init(VADriverContextP ctx)
+{
+    struct i965_driver_data *i965 = i965_driver_data(ctx);
+    struct i965_media_state *media_state = &i965->media_state;
+    struct i965_h264_context *i965_h264_context;
+    dri_bo *bo;
+
+    assert(media_state->private_context);
+    i965_h264_context = media_state->private_context;
+
+    dri_bo_unreference(i965_h264_context->avc_it_command_mb_info.bo);
+    bo = dri_bo_alloc(i965->intel.bufmgr,
+                      "avc it command mb info",
+                      0x80000 * (1 + i965_h264_context->use_avc_hw_scoreboard),  /* at least 522240 bytes */
+                      0x1000);
+    assert(bo);
+    i965_h264_context->avc_it_command_mb_info.bo = bo;
+
+    dri_bo_unreference(i965_h264_context->avc_it_data.bo);
+    bo = dri_bo_alloc(i965->intel.bufmgr,
+                      "avc it data",
+                      0x1000000, /* at least 16711680 bytes */
+                      4096);
+    assert(bo);
+    i965_h264_context->avc_it_data.bo = bo;
+    i965_h264_context->avc_it_data.write_offset = 0;
+    dri_bo_unreference(media_state->indirect_object.bo);
+    media_state->indirect_object.bo = bo;
+    dri_bo_reference(media_state->indirect_object.bo);
+    media_state->indirect_object.offset = i965_h264_context->avc_it_data.write_offset;
+
+    /* bsd pipeline */
+    i965_avc_bsd_decode_init(ctx);
+
+    /* HW scoreboard */
+    i965_avc_hw_scoreboard_decode_init(ctx);
+
+    /* for Media pipeline */
+    media_state->extended_state.enabled = 1;
+    dri_bo_unreference(media_state->extended_state.bo);
+    bo = dri_bo_alloc(i965->intel.bufmgr, 
+                      "extened vfe state", 
+                      sizeof(struct i965_vfe_state_ex), 32);
+    assert(bo);
+    media_state->extended_state.bo = bo;
+
+    /* URB */
+    if (IS_IRONLAKE(i965->intel.device_id)) {
+        media_state->urb.num_vfe_entries = 63;
+    } else {
+        media_state->urb.num_vfe_entries = 23;
+    }
+
+    media_state->urb.size_vfe_entry = 16;
+
+    media_state->urb.num_cs_entries = 1;
+    media_state->urb.size_cs_entry = 1;
+
+    media_state->urb.vfe_start = 0;
+    media_state->urb.cs_start = media_state->urb.vfe_start + 
+        media_state->urb.num_vfe_entries * media_state->urb.size_vfe_entry;
+    assert(media_state->urb.cs_start + 
+           media_state->urb.num_cs_entries * media_state->urb.size_cs_entry <= URB_SIZE((&i965->intel)));
+
+    /* hook functions */
+    media_state->media_states_setup = i965_media_h264_states_setup;
+    media_state->media_objects = i965_media_h264_objects;
+}
+
+Bool 
+i965_media_h264_init(VADriverContextP ctx)
+{
+    struct i965_driver_data *i965 = i965_driver_data(ctx);
+    struct i965_media_state *media_state = &i965->media_state;
+    struct i965_h264_context *i965_h264_context;
+    int i;
+
+    i965_h264_context = calloc(1, sizeof(struct i965_h264_context));
+
+    /* kernel */
+    assert(NUM_H264_AVC_KERNELS == (sizeof(h264_avc_kernels_gen5) / 
+                                    sizeof(h264_avc_kernels_gen5[0])));
+    assert(NUM_AVC_MC_INTERFACES == (sizeof(avc_mc_kernel_offset_gen5) /
+                                     sizeof(avc_mc_kernel_offset_gen5[0])));
+
+    if (IS_IRONLAKE(i965->intel.device_id)) {
+        h264_avc_kernels = h264_avc_kernels_gen5;
+        avc_mc_kernel_offset = avc_mc_kernel_offset_gen5;
+        intra_kernel_header = &intra_kernel_header_gen5;
+        i965_h264_context->use_avc_hw_scoreboard = 1;
+        i965_h264_context->use_hw_w128 = 1;
+    } else {
+        h264_avc_kernels = h264_avc_kernels_gen4;
+        avc_mc_kernel_offset = avc_mc_kernel_offset_gen4;
+        intra_kernel_header = &intra_kernel_header_gen4;
+        i965_h264_context->use_avc_hw_scoreboard = 0;
+        i965_h264_context->use_hw_w128 = 0;
+    }
+
+    for (i = 0; i < NUM_H264_AVC_KERNELS; i++) {
+        struct media_kernel *kernel = &h264_avc_kernels[i];
+        kernel->bo = dri_bo_alloc(i965->intel.bufmgr, 
+                                  kernel->name, 
+                                  kernel->size, 64);
+        assert(kernel->bo);
+        dri_bo_subdata(kernel->bo, 0, kernel->size, kernel->bin);
+    }
+
+    for (i = 0; i < 16; i++) {
+        i965_h264_context->fsid_list[i].surface_id = VA_INVALID_ID;
+        i965_h264_context->fsid_list[i].frame_store_id = -1;
+    }
+
+    media_state->private_context = i965_h264_context;
+    return True;
+}
+
+Bool 
+i965_media_h264_ternimate(VADriverContextP ctx)
+{
+    struct i965_driver_data *i965 = i965_driver_data(ctx);
+    struct i965_media_state *media_state = &i965->media_state;
+    struct i965_h264_context *i965_h264_context;
+    int i;
+
+    if (media_state->private_context) {
+        i965_h264_context = (struct i965_h264_context *)media_state->private_context;
+        i965_avc_hw_scoreboard_ternimate(&i965_h264_context->avc_hw_scoreboard_context);
+        i965_avc_bsd_ternimate(&i965_h264_context->i965_avc_bsd_context);
+        dri_bo_unreference(i965_h264_context->avc_it_command_mb_info.bo);
+        dri_bo_unreference(i965_h264_context->avc_it_data.bo);
+        free(i965_h264_context);
+        media_state->private_context = NULL;
+    }
+
+    for (i = 0; i < NUM_H264_AVC_KERNELS; i++) {
+        struct media_kernel *kernel = &h264_avc_kernels[i];
+
+        dri_bo_unreference(kernel->bo);
+        kernel->bo = NULL;
+    }
+
+    return True;
+}
diff --git a/i965_drv_video/i965_media_h264.h b/i965_drv_video/i965_media_h264.h
new file mode 100644
index 0000000..4df37a4
--- /dev/null
+++ b/i965_drv_video/i965_media_h264.h
@@ -0,0 +1,56 @@
+#ifndef _I965_MEDIA_H264_H_
+#define _I965_MEDIA_H264_H_
+
+#include "i965_avc_bsd.h"
+#include "i965_avc_hw_scoreboard.h"
+
+#define MB_CMD_IN_BYTES         64
+#define MB_CMD_IN_DWS           16
+#define MB_CMD_IN_OWS           4
+
+enum {
+    H264_AVC_COMBINED = 0,
+    H264_AVC_NULL
+};
+
+struct i965_h264_context
+{
+    struct {
+        dri_bo *bo;
+        unsigned int mbs;
+    } avc_it_command_mb_info;
+
+    struct {
+        dri_bo *bo;
+        long write_offset;
+    } avc_it_data;
+
+    struct {
+        unsigned int width_in_mbs;
+        unsigned int height_in_mbs;
+        int mbaff_frame_flag;
+    } picture;
+
+    int use_avc_hw_scoreboard;
+
+    int use_hw_w128;
+    unsigned int weight128_luma_l0;
+    unsigned int weight128_luma_l1;
+    unsigned int weight128_chroma_l0;
+    unsigned int weight128_chroma_l1;
+    char weight128_offset0_flag;
+    short weight128_offset0;
+
+    struct i965_avc_bsd_context i965_avc_bsd_context;
+    struct i965_avc_hw_scoreboard_context avc_hw_scoreboard_context;
+    struct {
+        VASurfaceID surface_id;
+        int frame_store_id;
+    } fsid_list[16];
+};
+
+Bool i965_media_h264_init(VADriverContextP ctx);
+Bool i965_media_h264_ternimate(VADriverContextP ctx);
+void i965_media_h264_decode_init(VADriverContextP ctx);
+
+#endif /* _I965_MEDIA_H264_H_ */
diff --git a/i965_drv_video/i965_media_mpeg2.c b/i965_drv_video/i965_media_mpeg2.c
index 83ee505..c966904 100644
--- a/i965_drv_video/i965_media_mpeg2.c
+++ b/i965_drv_video/i965_media_mpeg2.c
@@ -280,7 +280,7 @@ static struct media_kernel  mpeg2_vld_kernels_gen4[] = {
     }
 };
 
-/* On IGDNG */
+/* On IRONLAKE */
 static uint32_t frame_intra_kernel_gen5[][4] = {
    #include "shaders/mpeg2/vld/frame_intra.g4b.gen5"
 };
@@ -851,30 +851,33 @@ i965_media_mpeg2_states_setup(VADriverContextP ctx, struct decode_state *decode_
 static void
 i965_media_mpeg2_objects(VADriverContextP ctx, struct decode_state *decode_state)
 {
-    int i;
+    int i, j;
     VASliceParameterBufferMPEG2 *slice_param;
 
-    assert(decode_state->slice_param && decode_state->slice_param->buffer);
-    slice_param = (VASliceParameterBufferMPEG2 *)decode_state->slice_param->buffer;
-
-    for (i = 0; i < decode_state->num_slices; i++) {
-        assert(slice_param->slice_data_flag == VA_SLICE_DATA_FLAG_ALL);
-
-        BEGIN_BATCH(ctx, 6);
-        OUT_BATCH(ctx, CMD_MEDIA_OBJECT | 4);
-        OUT_BATCH(ctx, 0);
-        OUT_BATCH(ctx, slice_param->slice_data_size - (slice_param->macroblock_offset >> 3));
-        OUT_RELOC(ctx, decode_state->slice_data->bo, 
-                  I915_GEM_DOMAIN_SAMPLER, 0, 
-                  slice_param->slice_data_offset + (slice_param->macroblock_offset >> 3));
-        OUT_BATCH(ctx, 
-                  ((slice_param->slice_horizontal_position << 24) |     
-                   (slice_param->slice_vertical_position << 16) |
-                   (127 << 8) | 
-                   (slice_param->macroblock_offset & 0x7)));
-        OUT_BATCH(ctx, slice_param->quantiser_scale_code << 24);
-        ADVANCE_BATCH(ctx);          
-        slice_param++;
+    for (j = 0; j < decode_state->num_slice_params; j++) {
+        assert(decode_state->slice_params[j] && decode_state->slice_params[j]->buffer);
+        assert(decode_state->slice_datas[j] && decode_state->slice_datas[j]->bo);
+        slice_param = (VASliceParameterBufferMPEG2 *)decode_state->slice_params[j]->buffer;
+
+        for (i = 0; i < decode_state->slice_params[j]->num_elements; i++) {
+            assert(slice_param->slice_data_flag == VA_SLICE_DATA_FLAG_ALL);
+
+            BEGIN_BATCH(ctx, 6);
+            OUT_BATCH(ctx, CMD_MEDIA_OBJECT | 4);
+            OUT_BATCH(ctx, 0);
+            OUT_BATCH(ctx, slice_param->slice_data_size - (slice_param->macroblock_offset >> 3));
+            OUT_RELOC(ctx, decode_state->slice_datas[j]->bo, 
+                      I915_GEM_DOMAIN_SAMPLER, 0, 
+                      slice_param->slice_data_offset + (slice_param->macroblock_offset >> 3));
+            OUT_BATCH(ctx, 
+                      ((slice_param->slice_horizontal_position << 24) |     
+                       (slice_param->slice_vertical_position << 16) |
+                       (127 << 8) | 
+                       (slice_param->macroblock_offset & 0x7)));
+            OUT_BATCH(ctx, slice_param->quantiser_scale_code << 24);
+            ADVANCE_BATCH(ctx);          
+            slice_param++;
+        }
     }
 }
 
@@ -886,6 +889,7 @@ i965_media_mpeg2_decode_init(VADriverContextP ctx)
     dri_bo *bo;
 
     media_state->extended_state.enabled = 1;
+    media_state->indirect_object.bo = NULL;
     dri_bo_unreference(media_state->extended_state.bo);
     bo = dri_bo_alloc(i965->intel.bufmgr, 
                       "vld state", 
@@ -907,7 +911,7 @@ i965_media_mpeg2_decode_init(VADriverContextP ctx)
            media_state->urb.num_cs_entries * media_state->urb.size_cs_entry <= URB_SIZE((&i965->intel)));
 
     /* hook functions */
-    media_state->states_setup = i965_media_mpeg2_states_setup;
+    media_state->media_states_setup = i965_media_mpeg2_states_setup;
     media_state->media_objects = i965_media_mpeg2_objects;
 
 }
@@ -923,7 +927,7 @@ i965_media_mpeg2_init(VADriverContextP ctx)
                                      sizeof(mpeg2_vld_kernels_gen5[0])));
     assert(NUM_MPEG2_VLD_KERNELS <= MAX_INTERFACE_DESC);
 
-    if (IS_IGDNG(i965->intel.device_id))
+    if (IS_IRONLAKE(i965->intel.device_id))
         mpeg2_vld_kernels = mpeg2_vld_kernels_gen5;
     else
         mpeg2_vld_kernels = mpeg2_vld_kernels_gen4;
diff --git a/i965_drv_video/i965_render.c b/i965_drv_video/i965_render.c
index 4a4f041..aab3b87 100644
--- a/i965_drv_video/i965_render.c
+++ b/i965_drv_video/i965_render.c
@@ -75,7 +75,7 @@ static const unsigned int ps_subpic_kernel_static[][4] =
 #include "shaders/render/exa_wm_write.g4b"
 };
 
-/* On IGDNG */
+/* On IRONLAKE */
 static const unsigned int sf_kernel_static_gen5[][4] = 
 {
 #include "shaders/render/exa_sf.g4b.gen5"
@@ -183,8 +183,8 @@ static struct render_kernel *render_kernels = NULL;
 #define URB_SF_ENTRIES	      1
 #define URB_SF_ENTRY_SIZE     2
 
-#define URB_CS_ENTRIES	      0
-#define URB_CS_ENTRY_SIZE     0
+#define URB_CS_ENTRIES	      1
+#define URB_CS_ENTRY_SIZE     1
 
 static void
 i965_render_vs_unit(VADriverContextP ctx)
@@ -198,7 +198,7 @@ i965_render_vs_unit(VADriverContextP ctx)
     vs_state = render_state->vs.state->virtual;
     memset(vs_state, 0, sizeof(*vs_state));
 
-    if (IS_IGDNG(i965->intel.device_id))
+    if (IS_IRONLAKE(i965->intel.device_id))
         vs_state->thread4.nr_urb_entries = URB_VS_ENTRIES >> 2;
     else
         vs_state->thread4.nr_urb_entries = URB_VS_ENTRIES;
@@ -312,7 +312,7 @@ i965_subpic_render_wm_unit(VADriverContextP ctx)
 
     wm_state->thread1.single_program_flow = 1; /* XXX */
 
-    if (IS_IGDNG(i965->intel.device_id))
+    if (IS_IRONLAKE(i965->intel.device_id))
         wm_state->thread1.binding_table_entry_count = 0; /* hardware requirement */
     else
         wm_state->thread1.binding_table_entry_count = 7;
@@ -329,7 +329,7 @@ i965_subpic_render_wm_unit(VADriverContextP ctx)
     wm_state->wm4.stats_enable = 0;
     wm_state->wm4.sampler_state_pointer = render_state->wm.sampler->offset >> 5; 
 
-    if (IS_IGDNG(i965->intel.device_id))
+    if (IS_IRONLAKE(i965->intel.device_id))
         wm_state->wm4.sampler_count = 0;        /* hardware requirement */
     else
         wm_state->wm4.sampler_count = (render_state->wm.sampler_count + 3) / 4;
@@ -375,7 +375,7 @@ i965_render_wm_unit(VADriverContextP ctx)
 
     wm_state->thread1.single_program_flow = 1; /* XXX */
 
-    if (IS_IGDNG(i965->intel.device_id))
+    if (IS_IRONLAKE(i965->intel.device_id))
         wm_state->thread1.binding_table_entry_count = 0;        /* hardware requirement */
     else
         wm_state->thread1.binding_table_entry_count = 7;
@@ -383,8 +383,8 @@ i965_render_wm_unit(VADriverContextP ctx)
     wm_state->thread2.scratch_space_base_pointer = 0;
     wm_state->thread2.per_thread_scratch_space = 0; /* 1024 bytes */
 
-    wm_state->thread3.dispatch_grf_start_reg = 3; /* XXX */
-    wm_state->thread3.const_urb_entry_read_length = 0;
+    wm_state->thread3.dispatch_grf_start_reg = 2; /* XXX */
+    wm_state->thread3.const_urb_entry_read_length = 1;
     wm_state->thread3.const_urb_entry_read_offset = 0;
     wm_state->thread3.urb_entry_read_length = 1; /* XXX */
     wm_state->thread3.urb_entry_read_offset = 0; /* XXX */
@@ -392,7 +392,7 @@ i965_render_wm_unit(VADriverContextP ctx)
     wm_state->wm4.stats_enable = 0;
     wm_state->wm4.sampler_state_pointer = render_state->wm.sampler->offset >> 5; 
 
-    if (IS_IGDNG(i965->intel.device_id))
+    if (IS_IRONLAKE(i965->intel.device_id))
         wm_state->wm4.sampler_count = 0;        /* hardware requirement */
     else 
         wm_state->wm4.sampler_count = (render_state->wm.sampler_count + 3) / 4;
@@ -532,7 +532,8 @@ i965_render_src_surface_state(VADriverContextP ctx,
                               int index,
                               dri_bo *region,
                               unsigned long offset,
-                              int w, int h)
+                              int w, int h,
+                              int pitch, int format)
 {
     struct i965_driver_data *i965 = i965_driver_data(ctx);  
     struct i965_render_state *render_state = &i965->render_state;
@@ -548,7 +549,7 @@ i965_render_src_surface_state(VADriverContextP ctx,
     ss = ss_bo->virtual;
     memset(ss, 0, sizeof(*ss));
     ss->ss0.surface_type = I965_SURFACE_2D;
-    ss->ss0.surface_format = I965_SURFACEFORMAT_R8_UNORM;
+    ss->ss0.surface_format = format;
     ss->ss0.writedisable_alpha = 0;
     ss->ss0.writedisable_red = 0;
     ss->ss0.writedisable_green = 0;
@@ -566,7 +567,7 @@ i965_render_src_surface_state(VADriverContextP ctx,
     ss->ss2.mip_count = 0;
     ss->ss2.render_target_rotation = 0;
 
-    ss->ss3.pitch = w - 1;
+    ss->ss3.pitch = pitch - 1;
 
     dri_bo_emit_reloc(ss_bo,
                       I915_GEM_DOMAIN_SAMPLER, 0,
@@ -642,6 +643,7 @@ i965_render_src_surfaces_state(VADriverContextP ctx,
                               VASurfaceID surface)
 {
     struct i965_driver_data *i965 = i965_driver_data(ctx);  
+    struct i965_render_state *render_state = &i965->render_state;
     struct object_surface *obj_surface;
     int w, h;
     dri_bo *region;
@@ -653,12 +655,18 @@ i965_render_src_surfaces_state(VADriverContextP ctx,
     h = obj_surface->height;
     region = obj_surface->bo;
 
-    i965_render_src_surface_state(ctx, 1, region, 0, w, h);     /* Y */
-    i965_render_src_surface_state(ctx, 2, region, 0, w, h);
-    i965_render_src_surface_state(ctx, 3, region, w * h + w * h / 4, w / 2, h / 2);     /* V */
-    i965_render_src_surface_state(ctx, 4, region, w * h + w * h / 4, w / 2, h / 2);
-    i965_render_src_surface_state(ctx, 5, region, w * h, w / 2, h / 2); /* U */
-    i965_render_src_surface_state(ctx, 6, region, w * h, w / 2, h / 2);
+    i965_render_src_surface_state(ctx, 1, region, 0, w, h, w, I965_SURFACEFORMAT_R8_UNORM);     /* Y */
+    i965_render_src_surface_state(ctx, 2, region, 0, w, h, w, I965_SURFACEFORMAT_R8_UNORM);
+
+    if (render_state->interleaved_uv) {
+        i965_render_src_surface_state(ctx, 3, region, w * h, w / 2, h / 2, w, I965_SURFACEFORMAT_R8G8_UNORM); /* UV */
+        i965_render_src_surface_state(ctx, 4, region, w * h, w / 2, h / 2, w, I965_SURFACEFORMAT_R8G8_UNORM);
+    } else {
+        i965_render_src_surface_state(ctx, 3, region, w * h, w / 2, h / 2, w / 2, I965_SURFACEFORMAT_R8_UNORM); /* U */
+        i965_render_src_surface_state(ctx, 4, region, w * h, w / 2, h / 2, w / 2, I965_SURFACEFORMAT_R8_UNORM);
+        i965_render_src_surface_state(ctx, 5, region, w * h + w * h / 4, w / 2, h / 2, w / 2, I965_SURFACEFORMAT_R8_UNORM);     /* V */
+        i965_render_src_surface_state(ctx, 6, region, w * h + w * h / 4, w / 2, h / 2, w / 2, I965_SURFACEFORMAT_R8_UNORM);
+    }
 }
 
 static void
@@ -903,6 +911,25 @@ i965_render_upload_vertex(VADriverContextP ctx,
 }
 
 static void
+i965_render_upload_constants(VADriverContextP ctx)
+{
+    struct i965_driver_data *i965 = i965_driver_data(ctx);
+    struct i965_render_state *render_state = &i965->render_state;
+    unsigned short *constant_buffer;
+
+    dri_bo_map(render_state->curbe.bo, 1);
+    assert(render_state->curbe.bo->virtual);
+    constant_buffer = render_state->curbe.bo->virtual;
+
+    if (render_state->interleaved_uv)
+        *constant_buffer = 1;
+    else
+        *constant_buffer = 0;
+
+    dri_bo_unmap(render_state->curbe.bo);
+}
+
+static void
 i965_surface_render_state_setup(VADriverContextP ctx,
                         VASurfaceID surface,
                         short srcx,
@@ -923,10 +950,12 @@ i965_surface_render_state_setup(VADriverContextP ctx,
     i965_render_cc_viewport(ctx);
     i965_render_cc_unit(ctx);
     i965_render_binding_table(ctx);
+    i965_render_upload_constants(ctx);
     i965_render_upload_vertex(ctx, surface,
                               srcx, srcy, srcw, srch,
                               destx, desty, destw, desth);
 }
+
 static void
 i965_subpic_render_state_setup(VADriverContextP ctx,
                         VASurfaceID surface,
@@ -957,7 +986,6 @@ i965_subpic_render_state_setup(VADriverContextP ctx,
     i965_subpic_render_upload_vertex(ctx, surface, &output_rect);
 }
 
-
 static void
 i965_render_pipeline_select(VADriverContextP ctx)
 {
@@ -980,7 +1008,7 @@ i965_render_state_base_address(VADriverContextP ctx)
 {
     struct i965_driver_data *i965 = i965_driver_data(ctx);
 
-    if (IS_IGDNG(i965->intel.device_id)) {
+    if (IS_IRONLAKE(i965->intel.device_id)) {
         BEGIN_BATCH(ctx, 8);
         OUT_BATCH(ctx, CMD_STATE_BASE_ADDRESS | 6);
         OUT_BATCH(ctx, 0 | BASE_ADDRESS_MODIFY);
@@ -1099,6 +1127,20 @@ i965_render_cs_urb_layout(VADriverContextP ctx)
 }
 
 static void
+i965_render_constant_buffer(VADriverContextP ctx)
+{
+    struct i965_driver_data *i965 = i965_driver_data(ctx);
+    struct i965_render_state *render_state = &i965->render_state;
+
+    BEGIN_BATCH(ctx, 2);
+    OUT_BATCH(ctx, CMD_CONSTANT_BUFFER | (1 << 8) | (2 - 2));
+    OUT_RELOC(ctx, render_state->curbe.bo,
+              I915_GEM_DOMAIN_INSTRUCTION, 0,
+              URB_CS_ENTRY_SIZE - 1);
+    ADVANCE_BATCH(ctx);    
+}
+
+static void
 i965_render_drawing_rectangle(VADriverContextP ctx)
 {
     struct i965_driver_data *i965 = i965_driver_data(ctx);  
@@ -1118,7 +1160,7 @@ i965_render_vertex_elements(VADriverContextP ctx)
 {
     struct i965_driver_data *i965 = i965_driver_data(ctx);  
 
-    if (IS_IGDNG(i965->intel.device_id)) {
+    if (IS_IRONLAKE(i965->intel.device_id)) {
         BEGIN_BATCH(ctx, 5);
         OUT_BATCH(ctx, CMD_VERTEX_ELEMENTS | 3);
         /* offset 0: X,Y -> {X, Y, 1.0, 1.0} */
@@ -1206,7 +1248,7 @@ i965_render_startup(VADriverContextP ctx)
               ((4 * 4) << VB0_BUFFER_PITCH_SHIFT));
     OUT_RELOC(ctx, render_state->vb.vertex_buffer, I915_GEM_DOMAIN_VERTEX, 0, 0);
 
-    if (IS_IGDNG(i965->intel.device_id))
+    if (IS_IRONLAKE(i965->intel.device_id))
         OUT_RELOC(ctx, render_state->vb.vertex_buffer, I915_GEM_DOMAIN_VERTEX, 0, 12 * 4);
     else
         OUT_BATCH(ctx, 3);
@@ -1282,6 +1324,7 @@ i965_surface_render_pipeline_setup(VADriverContextP ctx)
     i965_render_pipelined_pointers(ctx);
     i965_render_urb_layout(ctx);
     i965_render_cs_urb_layout(ctx);
+    i965_render_constant_buffer(ctx);
     i965_render_drawing_rectangle(ctx);
     i965_render_vertex_elements(ctx);
     i965_render_startup(ctx);
@@ -1445,13 +1488,14 @@ Bool
 i965_render_init(VADriverContextP ctx)
 {
     struct i965_driver_data *i965 = i965_driver_data(ctx);
+    struct i965_render_state *render_state = &i965->render_state;
     int i;
 
     /* kernel */
     assert(NUM_RENDER_KERNEL == (sizeof(render_kernels_gen5) / 
                                  sizeof(render_kernels_gen5[0])));
 
-    if (IS_IGDNG(i965->intel.device_id))
+    if (IS_IRONLAKE(i965->intel.device_id))
         render_kernels = render_kernels_gen5;
     else
         render_kernels = render_kernels_gen4;
@@ -1465,6 +1509,12 @@ i965_render_init(VADriverContextP ctx)
         dri_bo_subdata(kernel->bo, 0, kernel->size, kernel->bin);
     }
 
+    /* constant buffer */
+    render_state->curbe.bo = dri_bo_alloc(i965->intel.bufmgr,
+                      "constant buffer",
+                      4096, 64);
+    assert(render_state->curbe.bo);
+
     return True;
 }
 
@@ -1475,6 +1525,9 @@ i965_render_terminate(VADriverContextP ctx)
     struct i965_driver_data *i965 = i965_driver_data(ctx);
     struct i965_render_state *render_state = &i965->render_state;
 
+    dri_bo_unreference(render_state->curbe.bo);
+    render_state->curbe.bo = NULL;
+
     for (i = 0; i < NUM_RENDER_KERNEL; i++) {
         struct render_kernel *kernel = &render_kernels[i];
         
diff --git a/i965_drv_video/i965_render.h b/i965_drv_video/i965_render.h
index e3dce02..2643285 100644
--- a/i965_drv_video/i965_render.h
+++ b/i965_drv_video/i965_render.h
@@ -60,6 +60,11 @@ struct i965_render_state
         dri_bo *viewport;
     } cc;
 
+    struct {
+        dri_bo *bo;
+    } curbe;
+
+    int interleaved_uv;
     struct intel_region *draw_region;
 };
 
diff --git a/i965_drv_video/i965_structs.h b/i965_drv_video/i965_structs.h
index 93fa2f0..d133446 100644
--- a/i965_drv_video/i965_structs.h
+++ b/i965_drv_video/i965_structs.h
@@ -34,16 +34,20 @@ struct i965_vfe_state_ex
 	unsigned int obj_id:24;
     } vfex0;
 
-    struct {
-	unsigned int residual_grf_offset:5;
-	unsigned int pad0:3;
-	unsigned int weight_grf_offset:5;
-	unsigned int pad1:3;
-	unsigned int residual_data_offset:8;
-	unsigned int sub_field_present_flag:2;
-	unsigned int residual_data_fix_offset:1;
-	unsigned int pad2:5;
-    }vfex1;
+    union {
+        struct {
+            unsigned int residual_grf_offset:5;
+            unsigned int pad0:3;
+            unsigned int weight_grf_offset:5;
+            unsigned int pad1:3;
+            unsigned int residual_data_offset:8;
+            unsigned int sub_field_present_flag:2;
+            unsigned int residual_data_fix_offset_flag:1;
+            unsigned int pad2:5;
+        } avc;
+        
+        unsigned int vc1;
+    } vfex1;
 
     struct {
 	unsigned int remap_index_0:4;
@@ -68,18 +72,32 @@ struct i965_vfe_state_ex
     } remap_table1;
 
     struct {
-	unsigned int scoreboard_mask:8;
+	unsigned int mask:8;
 	unsigned int pad:22;
 	unsigned int type:1;
 	unsigned int enable:1;
     } scoreboard0;
 
     struct {
-	unsigned int ignore;
+        int delta_x0:4;
+        int delta_y0:4;
+        int delta_x1:4;
+        int delta_y1:4;
+        int delta_x2:4;
+        int delta_y2:4;
+        int delta_x3:4;
+        int delta_y3:4;
     } scoreboard1;
 
     struct {
-	unsigned int ignore;
+        int delta_x4:4;
+        int delta_y4:4;
+        int delta_x5:4;
+        int delta_y5:4;
+        int delta_x6:4;
+        int delta_y6:4;
+        int delta_x7:4;
+        int delta_y7:4;
     } scoreboard2;
 
     unsigned int pad;
@@ -177,8 +195,9 @@ struct i965_surface_state
 	unsigned int cube_neg_y:1;
 	unsigned int cube_pos_x:1;
 	unsigned int cube_neg_x:1;
-	unsigned int pad:3;
+	unsigned int pad:2;
 	unsigned int render_cache_read_mode:1;
+	unsigned int cube_map_corner_mode:1;
 	unsigned int mipmap_layout_mode:1;
 	unsigned int vert_line_stride_ofs:1;
 	unsigned int vert_line_stride:1;
diff --git a/i965_drv_video/intel_batchbuffer.c b/i965_drv_video/intel_batchbuffer.c
index 9fabf6a..4c622d6 100644
--- a/i965_drv_video/intel_batchbuffer.c
+++ b/i965_drv_video/intel_batchbuffer.c
@@ -38,16 +38,16 @@ intel_batchbuffer_reset(struct intel_batchbuffer *batch)
 {
     struct intel_driver_data *intel = batch->intel; 
 
-    if (batch->buffer != NULL) {
-        dri_bo_unreference(batch->buffer);
-        batch->buffer = NULL;
-    }
+    assert(batch->flag == ON_RENDER_RING ||
+           batch->flag == ON_BSD_RING);
 
-    batch->buffer = dri_bo_alloc(intel->bufmgr, "batch buffer", 
+    dri_bo_unreference(batch->buffer);
+    batch->buffer = dri_bo_alloc(intel->bufmgr, 
+                                 batch->flag == ON_RENDER_RING ? "render batch buffer" : "bsd batch buffer", 
                                  BATCH_SIZE, 0x1000);
-
     assert(batch->buffer);
     dri_bo_map(batch->buffer, 1);
+    assert(batch->buffer->virtual);
     batch->map = batch->buffer->virtual;
     batch->size = BATCH_SIZE;
     batch->ptr = batch->map;
@@ -58,11 +58,19 @@ Bool
 intel_batchbuffer_init(struct intel_driver_data *intel)
 {
     intel->batch = calloc(1, sizeof(*(intel->batch)));
-
     assert(intel->batch);
     intel->batch->intel = intel;
+    intel->batch->flag = ON_RENDER_RING;
+    intel->batch->run = drm_intel_bo_mrb_exec;
     intel_batchbuffer_reset(intel->batch);
 
+    intel->batch_bcs = calloc(1, sizeof(*(intel->batch_bcs)));
+    assert(intel->batch_bcs);
+    intel->batch_bcs->intel = intel;
+    intel->batch_bcs->flag = ON_BSD_RING;
+    intel->batch_bcs->run = drm_intel_bo_mrb_exec;
+    intel_batchbuffer_reset(intel->batch_bcs);
+
     return True;
 }
 
@@ -80,14 +88,25 @@ intel_batchbuffer_terminate(struct intel_driver_data *intel)
         intel->batch = NULL;
     }
 
+    if (intel->batch_bcs) {
+        if (intel->batch_bcs->map) {
+            dri_bo_unmap(intel->batch_bcs->buffer);
+            intel->batch_bcs->map = NULL;
+        }
+
+        dri_bo_unreference(intel->batch_bcs->buffer);
+        free(intel->batch_bcs);
+        intel->batch_bcs = NULL;
+    }
+
     return True;
 }
 
-Bool 
-intel_batchbuffer_flush(VADriverContextP ctx)
+static Bool
+intel_batchbuffer_flush_helper(VADriverContextP ctx,
+                               struct intel_batchbuffer *batch)
 {
-    struct intel_driver_data *intel = intel_driver_data(ctx);
-    struct intel_batchbuffer *batch = intel->batch;
+    struct intel_driver_data *intel = batch->intel;
     unsigned int used = batch->ptr - batch->map;
     int is_locked = intel->locked;
 
@@ -108,98 +127,228 @@ intel_batchbuffer_flush(VADriverContextP ctx)
     if (!is_locked)
         intel_lock_hardware(ctx);
 
-    dri_bo_exec(batch->buffer, used, 0, 0, 0);
+    batch->run(batch->buffer, used, 0, 0, 0, batch->flag);
 
     if (!is_locked)
         intel_unlock_hardware(ctx);
 
-    intel_batchbuffer_reset(intel->batch);
+    intel_batchbuffer_reset(batch);
 
     return True;
 }
 
+Bool 
+intel_batchbuffer_flush(VADriverContextP ctx)
+{
+    struct intel_driver_data *intel = intel_driver_data(ctx);
+    
+    return intel_batchbuffer_flush_helper(ctx, intel->batch);
+}
+
+Bool 
+intel_batchbuffer_flush_bcs(VADriverContextP ctx)
+{
+    struct intel_driver_data *intel = intel_driver_data(ctx);
+    
+    return intel_batchbuffer_flush_helper(ctx, intel->batch_bcs);
+}
+
 static unsigned int
-intel_batchbuffer_space(struct intel_batchbuffer *batch)
+intel_batchbuffer_space_helper(struct intel_batchbuffer *batch)
 {
     return (batch->size - BATCH_RESERVED) - (batch->ptr - batch->map);
 }
 
+static void
+intel_batchbuffer_emit_dword_helper(struct intel_batchbuffer *batch, 
+                                    unsigned int x)
+{
+    assert(intel_batchbuffer_space_helper(batch) >= 4);
+    *(unsigned int *)batch->ptr = x;
+    batch->ptr += 4;
+}
+
 void 
 intel_batchbuffer_emit_dword(VADriverContextP ctx, unsigned int x)
 {
     struct intel_driver_data *intel = intel_driver_data(ctx);
-    struct intel_batchbuffer *batch = intel->batch;
 
-    assert(intel_batchbuffer_space(batch) >= 4);
-    *(unsigned int*)batch->ptr = x;
-    batch->ptr += 4;
+    intel_batchbuffer_emit_dword_helper(intel->batch, x);
 }
 
 void 
-intel_batchbuffer_emit_reloc(VADriverContextP ctx, dri_bo *bo, 
-                             uint32_t read_domains, uint32_t write_domains, 
-                             uint32_t delta)
+intel_batchbuffer_emit_dword_bcs(VADriverContextP ctx, unsigned int x)
 {
     struct intel_driver_data *intel = intel_driver_data(ctx);
-    struct intel_batchbuffer *batch = intel->batch;
 
+    intel_batchbuffer_emit_dword_helper(intel->batch_bcs, x);
+}
+
+static void 
+intel_batchbuffer_emit_reloc_helper(VADriverContextP ctx, 
+                                    struct intel_batchbuffer *batch,
+                                    dri_bo *bo, 
+                                    uint32_t read_domains, uint32_t write_domains, 
+                                    uint32_t delta)
+{
     assert(batch->ptr - batch->map < batch->size);
     dri_bo_emit_reloc(batch->buffer, read_domains, write_domains,
                       delta, batch->ptr - batch->map, bo);
-    intel_batchbuffer_emit_dword(ctx, bo->offset + delta);
+    intel_batchbuffer_emit_dword_helper(batch, bo->offset + delta);
 }
 
 void 
-intel_batchbuffer_require_space(VADriverContextP ctx, unsigned int size)
+intel_batchbuffer_emit_reloc(VADriverContextP ctx, dri_bo *bo, 
+                             uint32_t read_domains, uint32_t write_domains, 
+                             uint32_t delta)
 {
     struct intel_driver_data *intel = intel_driver_data(ctx);
-    struct intel_batchbuffer *batch = intel->batch;
 
+    intel_batchbuffer_emit_reloc_helper(ctx, intel->batch,
+                                        bo, read_domains, write_domains,
+                                        delta);
+}
+
+void 
+intel_batchbuffer_emit_reloc_bcs(VADriverContextP ctx, dri_bo *bo, 
+                                 uint32_t read_domains, uint32_t write_domains, 
+                                 uint32_t delta)
+{
+    struct intel_driver_data *intel = intel_driver_data(ctx);
+
+    intel_batchbuffer_emit_reloc_helper(ctx, intel->batch_bcs,
+                                        bo, read_domains, write_domains,
+                                        delta);
+}
+
+static void 
+intel_batchbuffer_require_space_helper(VADriverContextP ctx, 
+                                struct intel_batchbuffer *batch,
+                                unsigned int size)
+{
     assert(size < batch->size - 8);
 
-    if (intel_batchbuffer_space(batch) < size) {
-        intel_batchbuffer_flush(ctx);
+    if (intel_batchbuffer_space_helper(batch) < size) {
+        intel_batchbuffer_flush_helper(ctx, batch);
     }
 }
 
 void 
-intel_batchbuffer_data(VADriverContextP ctx, void *data, unsigned int size)
+intel_batchbuffer_require_space(VADriverContextP ctx, unsigned int size)
 {
     struct intel_driver_data *intel = intel_driver_data(ctx);
-    struct intel_batchbuffer *batch = intel->batch;
 
+    intel_batchbuffer_require_space_helper(ctx, intel->batch, size);
+}
+
+void 
+intel_batchbuffer_require_space_bcs(VADriverContextP ctx, unsigned int size)
+{
+    struct intel_driver_data *intel = intel_driver_data(ctx);
+
+    intel_batchbuffer_require_space_helper(ctx, intel->batch_bcs, size);
+}
+
+static void 
+intel_batchbuffer_data_helper(VADriverContextP ctx, 
+                              struct intel_batchbuffer *batch,
+                              void *data,
+                              unsigned int size)
+{
     assert((size & 3) == 0);
-    intel_batchbuffer_require_space(ctx, size);
+    intel_batchbuffer_require_space_helper(ctx, batch, size);
 
     assert(batch->ptr);
     memcpy(batch->ptr, data, size);
     batch->ptr += size;
 }
 
+void 
+intel_batchbuffer_data(VADriverContextP ctx, void *data, unsigned int size)
+{
+    struct intel_driver_data *intel = intel_driver_data(ctx);
+
+    intel_batchbuffer_data_helper(ctx, intel->batch, data, size);
+}
+
+void 
+intel_batchbuffer_data_bcs(VADriverContextP ctx, void *data, unsigned int size)
+{
+    struct intel_driver_data *intel = intel_driver_data(ctx);
+
+    intel_batchbuffer_data_helper(ctx, intel->batch_bcs, data, size);
+}
+
+static void
+intel_batchbuffer_emit_mi_flush_helper(VADriverContextP ctx,
+                                       struct intel_batchbuffer *batch)
+{
+    intel_batchbuffer_require_space_helper(ctx, batch, 4);
+    intel_batchbuffer_emit_dword_helper(batch, 
+                                        MI_FLUSH | STATE_INSTRUCTION_CACHE_INVALIDATE);
+}
+
 void
 intel_batchbuffer_emit_mi_flush(VADriverContextP ctx)
 {
-    intel_batchbuffer_require_space(ctx, 4);
-    intel_batchbuffer_emit_dword(ctx, MI_FLUSH | STATE_INSTRUCTION_CACHE_INVALIDATE);
+    struct intel_driver_data *intel = intel_driver_data(ctx);
+
+    intel_batchbuffer_emit_mi_flush_helper(ctx, intel->batch);
 }
 
 void
-intel_batchbuffer_start_atomic(VADriverContextP ctx, unsigned int size)
+intel_batchbuffer_emit_mi_flush_bcs(VADriverContextP ctx)
 {
     struct intel_driver_data *intel = intel_driver_data(ctx);
-    struct intel_batchbuffer *batch = intel->batch;
 
+    intel_batchbuffer_emit_mi_flush_helper(ctx, intel->batch_bcs);
+}
+
+void
+intel_batchbuffer_start_atomic_helper(VADriverContextP ctx, 
+                                      struct intel_batchbuffer *batch,
+                                      unsigned int size)
+{
     assert(!batch->atomic);
-    intel_batchbuffer_require_space(ctx, size);
+    intel_batchbuffer_require_space_helper(ctx, batch, size);
     batch->atomic = 1;
 }
 
 void
-intel_batchbuffer_end_atomic(VADriverContextP ctx)
+intel_batchbuffer_start_atomic(VADriverContextP ctx, unsigned int size)
+{
+    struct intel_driver_data *intel = intel_driver_data(ctx);
+
+    intel_batchbuffer_start_atomic_helper(ctx, intel->batch, size);
+}
+
+void
+intel_batchbuffer_start_atomic_bcs(VADriverContextP ctx, unsigned int size)
 {
     struct intel_driver_data *intel = intel_driver_data(ctx);
-    struct intel_batchbuffer *batch = intel->batch;
+    intel_batchbuffer_start_atomic_helper(ctx, intel->batch_bcs, size);
+}
 
+void
+intel_batchbuffer_end_atomic_helper(struct intel_batchbuffer *batch)
+{
     assert(batch->atomic);
     batch->atomic = 0;
 }
+
+void
+intel_batchbuffer_end_atomic(VADriverContextP ctx)
+{
+    struct intel_driver_data *intel = intel_driver_data(ctx);
+
+    intel_batchbuffer_end_atomic_helper(intel->batch);
+}
+
+void
+intel_batchbuffer_end_atomic_bcs(VADriverContextP ctx)
+{
+    struct intel_driver_data *intel = intel_driver_data(ctx);
+
+    intel_batchbuffer_end_atomic_helper(intel->batch_bcs);
+}
+
diff --git a/i965_drv_video/intel_batchbuffer.h b/i965_drv_video/intel_batchbuffer.h
index c3a2457..99ab08d 100644
--- a/i965_drv_video/intel_batchbuffer.h
+++ b/i965_drv_video/intel_batchbuffer.h
@@ -16,10 +16,16 @@ struct intel_batchbuffer
     unsigned char *map;
     unsigned char *ptr;
     int atomic;
+    int flag;
+
+    int (*run)(drm_intel_bo *bo, int used,
+               drm_clip_rect_t *cliprects, int num_cliprects,
+               int DR4, int ring_flag);
 };
 
 Bool intel_batchbuffer_init(struct intel_driver_data *intel);
 Bool intel_batchbuffer_terminate(struct intel_driver_data *intel);
+
 void intel_batchbuffer_emit_dword(VADriverContextP ctx, unsigned int x);
 void intel_batchbuffer_emit_reloc(VADriverContextP ctx, dri_bo *bo, 
                                   uint32_t read_domains, uint32_t write_domains, 
@@ -31,6 +37,17 @@ void intel_batchbuffer_start_atomic(VADriverContextP ctx, unsigned int size);
 void intel_batchbuffer_end_atomic(VADriverContextP ctx);
 Bool intel_batchbuffer_flush(VADriverContextP ctx);
 
+void intel_batchbuffer_emit_dword_bcs(VADriverContextP ctx, unsigned int x);
+void intel_batchbuffer_emit_reloc_bcs(VADriverContextP ctx, dri_bo *bo, 
+                                      uint32_t read_domains, uint32_t write_domains, 
+                                      uint32_t delta);
+void intel_batchbuffer_require_space_bcs(VADriverContextP ctx, unsigned int size);
+void intel_batchbuffer_data_bcs(VADriverContextP ctx, void *data, unsigned int size);
+void intel_batchbuffer_emit_mi_flush_bcs(VADriverContextP ctx);
+void intel_batchbuffer_start_atomic_bcs(VADriverContextP ctx, unsigned int size);
+void intel_batchbuffer_end_atomic_bcs(VADriverContextP ctx);
+Bool intel_batchbuffer_flush_bcs(VADriverContextP ctx);
+
 #define BEGIN_BATCH(ctx, n) do {                                \
    intel_batchbuffer_require_space(ctx, (n) * 4);               \
 } while (0)
@@ -48,4 +65,21 @@ Bool intel_batchbuffer_flush(VADriverContextP ctx);
 #define ADVANCE_BATCH(ctx) do {                                         \
 } while (0)
 
+#define BEGIN_BCS_BATCH(ctx, n) do {                                    \
+   intel_batchbuffer_require_space_bcs(ctx, (n) * 4);                   \
+} while (0)
+
+#define OUT_BCS_BATCH(ctx, d) do {                                      \
+   intel_batchbuffer_emit_dword_bcs(ctx, d);                            \
+} while (0)
+
+#define OUT_BCS_RELOC(ctx, bo, read_domains, write_domain, delta) do {  \
+   assert((delta) >= 0);                                                \
+   intel_batchbuffer_emit_reloc_bcs(ctx, bo,                            \
+                                    read_domains, write_domain, delta); \
+} while (0)
+
+#define ADVANCE_BCS_BATCH(ctx) do {                                     \
+} while (0)
+
 #endif /* _INTEL_BATCHBUFFER_H_ */
diff --git a/i965_drv_video/intel_batchbuffer_dump.c b/i965_drv_video/intel_batchbuffer_dump.c
new file mode 100644
index 0000000..0732f0f
--- /dev/null
+++ b/i965_drv_video/intel_batchbuffer_dump.c
@@ -0,0 +1,409 @@
+#include <stdio.h>
+#include <stdarg.h>
+#include <string.h>
+#include <inttypes.h>
+
+#include "intel_driver.h"
+#include "intel_batchbuffer_dump.h"
+
+#define BUFFER_FAIL(_count, _len, _name) do {			\
+    fprintf(gout, "Buffer size too small in %s (%d < %d)\n",	\
+	    (_name), (_count), (_len));				\
+    (*failures)++;						\
+    return count;						\
+} while (0)
+
+static FILE *gout;
+
+static void
+instr_out(unsigned int *data, unsigned int offset, unsigned int index, char *fmt, ...)
+{
+    va_list va;
+
+    fprintf(gout, "0x%08x: 0x%08x:%s ", offset + index * 4, data[index],
+	    index == 0 ? "" : "  ");
+    va_start(va, fmt);
+    vfprintf(gout, fmt, va);
+    va_end(va);
+}
+
+
+static int
+dump_mi(unsigned int *data, unsigned int offset, int count, unsigned int device, int *failures)
+{
+    unsigned int opcode;
+    int length, i;
+
+    struct {
+	unsigned int opcode;
+	int mask_length;
+	int min_len;
+	int max_len;
+	char *name;
+    } mi_commands[] = {
+	{ 0x00, 0, 1, 1, "MI_NOOP" },
+	{ 0x04, 0, 1, 1, "MI_FLUSH" },
+	{ 0x0a, 0, 1, 1, "MI_BATCH_BUFFER_END" },
+    };
+
+    opcode = ((data[0] & MASK_MI_OPCODE) >> SHIFT_MI_OPCODE);
+
+    for (i = 0; i < sizeof(mi_commands) / sizeof(mi_commands[0]); i++) {
+        if (opcode == mi_commands[i].opcode) {
+            int index;
+
+            length = 1;
+	    instr_out(data, offset, 0, "%s\n", mi_commands[i].name);
+
+	    if (mi_commands[i].max_len > 1) {
+                length = (data[0] & mi_commands[i].mask_length) + 2;
+
+                if (length < mi_commands[i].min_len ||
+                    length > mi_commands[i].max_len) {
+		    fprintf(gout, "Bad length (%d) in %s, [%d, %d]\n",
+			    length, mi_commands[i].name,
+			    mi_commands[i].min_len,
+			    mi_commands[i].max_len);
+		}
+	    }
+
+            for (index = 1; index < length; index++) {
+                if (index >= count)
+		    BUFFER_FAIL(count, length, mi_commands[i].name);
+
+		instr_out(data, offset, index, "dword %d\n", index);
+	    }
+
+	    return length;
+	}
+    }
+
+    instr_out(data, offset, 0, "UNKNOWN MI COMMAND\n");
+    (*failures)++;
+    return 1;
+}
+
+static int
+dump_gfxpipe_3d(unsigned int *data, unsigned int offset, int count, unsigned int device, int *failures)
+{
+    instr_out(data, offset, 0, "UNKNOWN 3D COMMAND\n");
+    (*failures)++;
+
+    return 1;
+}
+
+static void
+dump_avc_bsd_img_state(unsigned int *data, unsigned int offset, unsigned int device, int *failures)
+{
+    int img_struct = ((data[3] >> 8) & 0x3);
+
+    instr_out(data, offset, 1, "frame size: %d\n", (data[1] & 0xffff));
+    instr_out(data, offset, 2, "width: %d, height: %d\n", (data[2] & 0xff), (data[2] >> 16) & 0xff);
+    instr_out(data, offset, 3, 
+              "second_chroma_qp_offset: %d,"
+              "chroma_qp_offset: %d,"
+              "QM present flag: %d," 
+              "image struct: %s,"
+              "img_dec_fs_idc: %d,"
+              "\n",
+              (data[3] >> 24) & 0x1f,
+              (data[3] >> 16) & 0x1f,
+              (data[3] >> 10) & 0x1,
+              (img_struct == 0) ? "frame" : (img_struct == 2) ? "invalid" : (img_struct == 1) ? "top field" : "bottom field",
+              data[3] & 0xff);
+    instr_out(data, offset, 4,
+              "residual off: 0x%x,"
+              "16MV: %d,"
+              "chroma fmt: %d,"
+              "CABAC: %d,"
+              "non-ref: %d,"
+              "constrained intra: %d,"
+              "direct8x8: %d,"
+              "trans8x8: %d,"
+              "MB only: %d,"
+              "MBAFF: %d,"
+              "\n",
+              (data[4] >> 24) & 0xff,
+              (data[4] >> 12) & 0x1,
+              (data[4] >> 10) & 0x3,
+              (data[4] >> 7) & 0x1,
+              (data[4] >> 6) & 0x1,
+              (data[4] >> 5) & 0x1,
+              (data[4] >> 4) & 0x1,
+              (data[4] >> 3) & 0x1,
+              (data[4] >> 2) & 0x1,
+              (data[4] >> 1) & 0x1);
+    instr_out(data, offset, 5, "AVC-IT Command Header\n");
+}
+
+static void
+dump_avc_bsd_qm_state(unsigned int *data, unsigned int offset, unsigned int device, int *failures)
+{
+    unsigned int length = ((data[0] & MASK_GFXPIPE_LENGTH) >> SHIFT_GFXPIPE_LENGTH) + 2;
+    int i;
+
+    instr_out(data, offset, 1, "user default: %02x, QM list present: %02x\n", 
+              (data[1] >> 8) & 0xff, data[1] & 0xff);
+
+    for (i = 2; i < length; i++) {
+        instr_out(data, offset, i, "dword %d\n", i);
+    }
+}
+
+static void
+dump_avc_bsd_slice_state(unsigned int *data, unsigned int offset, unsigned int device, int *failures)
+{
+
+}
+
+static void
+dump_avc_bsd_buf_base_state(unsigned int *data, unsigned int offset, unsigned int device, int *failures)
+{
+    int i;
+
+    instr_out(data, offset, 1, "BSD row store base address\n");
+    instr_out(data, offset, 2, "MPR row store base address\n");
+    instr_out(data, offset, 3, "AVC-IT command buffer base address\n");
+    instr_out(data, offset, 4, "AVC-IT data buffer: 0x%08x, write offset: 0x%x\n", 
+              data[4] & 0xFFFFF000, data[4] & 0xFC0);
+    instr_out(data, offset, 5, "ILDB data buffer\n");
+
+    for (i = 6; i < 38; i++) {
+        instr_out(data, offset, i, "Direct MV read base address for reference frame %d\n", i - 6);
+    }
+
+    instr_out(data, offset, 38, "direct mv wr0 top\n");
+    instr_out(data, offset, 39, "direct mv wr0 bottom\n");
+
+    for (i = 40; i < 74; i++) {
+        instr_out(data, offset, i, "POC List %d\n", i - 40);
+    }
+}
+
+static void
+dump_bsd_ind_obj_base_addr(unsigned int *data, unsigned int offset, unsigned int device, int *failures)
+{
+    instr_out(data, offset, 1, "AVC indirect object base address\n");
+    instr_out(data, offset, 2, "AVC Indirect Object Access Upper Bound\n");
+}
+
+static void 
+dump_ironlake_avc_bsd_object(unsigned int *data, unsigned int offset, int *failures)
+{
+    int slice_type = data[3] & 0xf;
+    int i, is_phantom = ((data[1] & 0x3fffff) == 0);
+
+    if (!is_phantom) {
+        instr_out(data, offset, 1, "Encrypted: %d, bitsteam length: %d\n", data[1] >> 31, data[1] & 0x3fffff);
+        instr_out(data, offset, 2, "Indirect Data Start Address: %d\n", data[2] & 0x1fffffff);
+        instr_out(data, offset, 3, "%s Slice\n", slice_type == 0 ? "P" : slice_type == 1 ? "B" : "I");
+        instr_out(data, offset, 4, 
+                  "Num_Ref_Idx_L1: %d,"
+                  "Num_Ref_Idx_L0: %d,"
+                  "Log2WeightDenomChroma: %d,"
+                  "Log2WeightDenomLuma: %d"
+                  "\n",
+                  (data[4] >> 24) & 0x3f,
+                  (data[4] >> 16) & 0x3f,
+                  (data[4] >> 8) & 0x3,
+                  (data[4] >> 0) & 0x3);
+        instr_out(data, offset, 5,
+                  "WeightedPredIdc: %d,"
+                  "DirectPredType: %d,"
+                  "DisableDeblockingFilter: %d,"
+                  "CabacInitIdc: %d,"
+                  "SliceQp: %d,"
+                  "SliceBetaOffsetDiv2: %d,"
+                  "SliceAlphaC0OffsetDiv2: %d"
+                  "\n",
+                  (data[5] >> 30) & 0x3,
+                  (data[5] >> 29) & 0x1,
+                  (data[5] >> 27) & 0x3,
+                  (data[5] >> 24) & 0x3,
+                  (data[5] >> 16) & 0x3f,
+                  (data[5] >> 8) & 0xf,
+                  (data[5] >> 0) & 0xf);
+        instr_out(data, offset, 6,
+                  "Slice_MB_Start_Vert_Pos: %d,"
+                  "Slice_MB_Start_Hor_Pos: %d,"
+                  "Slice_Start_Mb_Num: %d"
+                  "\n",
+                  (data[6] >> 24) & 0xff,
+                  (data[6] >> 16) & 0xff,
+                  (data[6] >> 0) & 0x7fff);
+        instr_out(data, offset, 7,
+                  "Fix_Prev_Mb_Skipped: %d,"
+                  "First_MB_Bit_Offset: %d"
+                  "\n",
+                  (data[7] >> 7) & 0x1,
+                  (data[7] >> 0) & 0x7);
+
+        for (i = 8; i < 16; i++)
+            instr_out(data, offset, i, "dword %d\n", i);
+    } else {
+        instr_out(data, offset, 1, "phantom slice\n");
+
+        for (i = 2; i < 6; i++)
+            instr_out(data, offset, i, "dword %d\n", i);
+
+        instr_out(data, offset, 6,
+                  "Slice_Start_Mb_Num: %d"
+                  "\n",
+                  (data[6] >> 0) & 0x7fff);
+
+        for (i = 7; i < 16; i++)
+            instr_out(data, offset, i, "dword %d\n", i);
+
+    }
+}
+
+static void 
+dump_g4x_avc_bsd_object(unsigned int *data, unsigned int offset, int *failures)
+{
+
+}
+
+static void 
+dump_avc_bsd_object(unsigned int *data, unsigned int offset, unsigned int device, int *failures)
+{
+    if (IS_IRONLAKE(device))
+        dump_ironlake_avc_bsd_object(data, offset, failures);
+    else
+        dump_g4x_avc_bsd_object(data, offset, failures);
+}
+
+static int
+dump_bsd_avc(unsigned int *data, unsigned int offset, int count, unsigned int device, int *failures)
+{
+    unsigned int subopcode;
+    int length, i;
+
+    struct {
+	unsigned int subopcode;
+	int min_len;
+	int max_len;
+	char *name;
+        void (*detail)(unsigned int *data, unsigned int offset, unsigned int device, int  *failures);
+    } avc_commands[] = {
+        { 0x00, 0x06, 0x06, "AVC_BSD_IMG_STATE", dump_avc_bsd_img_state },
+        { 0x01, 0x02, 0x3a, "AVC_BSD_QM_STATE", dump_avc_bsd_qm_state },
+        { 0x02, 0x02, 0xd2, "AVC_BSD_SLICE_STATE", NULL },
+        { 0x03, 0x4a, 0x4a, "AVC_BSD_BUF_BASE_STATE", dump_avc_bsd_buf_base_state },
+        { 0x04, 0x03, 0x03, "BSD_IND_OBJ_BASE_ADDR", dump_bsd_ind_obj_base_addr },
+        { 0x08, 0x08, 0x10, "AVC_BSD_OBJECT", dump_avc_bsd_object },
+    };
+
+    subopcode = ((data[0] & MASK_GFXPIPE_SUBOPCODE) >> SHIFT_GFXPIPE_SUBOPCODE);
+
+    for (i = 0; i < sizeof(avc_commands) / sizeof(avc_commands[0]); i++) {
+        if (subopcode == avc_commands[i].subopcode) {
+            unsigned int index;
+
+            length = (data[0] & MASK_GFXPIPE_LENGTH) >> SHIFT_GFXPIPE_LENGTH;
+            length += 2;
+            instr_out(data, offset, 0, "%s\n", avc_commands[i].name);
+
+            if (length < avc_commands[i].min_len || 
+                length > avc_commands[i].max_len) {
+                fprintf(gout, "Bad length(%d) in %s [%d, %d]\n", 
+                        length, avc_commands[i].name,
+                        avc_commands[i].min_len,
+                        avc_commands[i].max_len);
+            }
+
+            if (length - 1 >= count)
+                BUFFER_FAIL(count, length, avc_commands[i].name);
+
+            if (avc_commands[i].detail)
+                avc_commands[i].detail(data, offset, device, failures);
+            else {
+                for (index = 1; index < length; index++)
+                    instr_out(data, offset, index, "dword %d\n", index);
+            }
+
+	    return length;
+	}
+    }
+
+    instr_out(data, offset, 0, "UNKNOWN AVC COMMAND\n");
+    (*failures)++;
+    return 1;
+}
+
+static int
+dump_gfxpipe_bsd(unsigned int *data, unsigned int offset, int count, unsigned int device, int *failures)
+{
+    int length;
+
+    switch ((data[0] & MASK_GFXPIPE_OPCODE) >> SHIFT_GFXPIPE_OPCODE) {
+    case OPCODE_BSD_AVC:
+        length = dump_bsd_avc(data, offset, count, device, failures);
+        break;
+
+    default:
+        length = 1;
+        (*failures)++;
+        instr_out(data, offset, 0, "UNKNOWN BSD OPCODE\n");
+        break;
+    }
+
+    return length;
+}
+
+static int
+dump_gfxpipe(unsigned int *data, unsigned int offset, int count, unsigned int device, int *failures)
+{
+    int length;
+
+    switch ((data[0] & MASK_GFXPIPE_SUBTYPE) >> SHIFT_GFXPIPE_SUBTYPE) {
+    case GFXPIPE_3D:
+        length = dump_gfxpipe_3d(data, offset, count, device, failures);
+        break;
+
+    case GFXPIPE_BSD:
+        length = dump_gfxpipe_bsd(data, offset, count, device, failures);
+        break;
+
+    default:
+        length = 1;
+        (*failures)++;
+        instr_out(data, offset, 0, "UNKNOWN GFXPIPE COMMAND\n");
+        break;
+    }
+
+    return length;
+}
+
+int intel_batchbuffer_dump(unsigned int *data, unsigned int offset, int count, unsigned int device)
+{
+    int index = 0;
+    int failures = 0;
+
+    gout = fopen("/tmp/bsd_command_dump.txt", "w+");
+
+    while (index < count) {
+	switch ((data[index] & MASK_CMD_TYPE) >> SHIFT_CMD_TYPE) {
+	case CMD_TYPE_MI:
+	    index += dump_mi(data + index, offset + index * 4,
+                             count - index, device, &failures);
+	    break;
+
+	case CMD_TYPE_GFXPIPE:
+            index += dump_gfxpipe(data + index, offset + index * 4,
+                                  count - index, device, &failures);
+	    break;
+
+	default:
+	    instr_out(data, offset, index, "UNKNOWN COMMAND\n");
+	    failures++;
+	    index++;
+	    break;
+	}
+
+	fflush(gout);
+    }
+
+    fclose(gout);
+
+    return failures;
+}
diff --git a/i965_drv_video/intel_batchbuffer_dump.h b/i965_drv_video/intel_batchbuffer_dump.h
new file mode 100644
index 0000000..ad096a9
--- /dev/null
+++ b/i965_drv_video/intel_batchbuffer_dump.h
@@ -0,0 +1,49 @@
+#ifndef _INTEL_BATCHBUFFER_DUMP_H_
+#define _INTEL_BATCHBUFFER_DUMP_H_
+
+#define MASK_CMD_TYPE           0xE0000000
+
+#define SHIFT_CMD_TYPE          29
+
+#define CMD_TYPE_GFXPIPE        3
+#define CMD_TYPE_BLT            2
+#define CMD_TYPE_MI             0
+
+
+/* GFXPIPE */
+#define MASK_GFXPIPE_SUBTYPE    0x18000000
+#define MASK_GFXPIPE_OPCODE     0x07000000
+#define MASK_GFXPIPE_SUBOPCODE  0x00FF0000
+#define MASK_GFXPIPE_LENGTH     0x0000FFFF
+
+#define SHIFT_GFXPIPE_SUBTYPE           27
+#define SHIFT_GFXPIPE_OPCODE            24
+#define SHIFT_GFXPIPE_SUBOPCODE         16
+#define SHIFT_GFXPIPE_LENGTH            0
+
+/* 3D */
+#define GFXPIPE_3D              3
+
+/* BSD */
+#define GFXPIPE_BSD             2
+
+#define OPCODE_BSD_AVC          4
+
+#define SUBOPCODE_BSD_IMG       0
+#define SUBOPCODE_BSD_QM        1
+#define SUBOPCODE_BSD_SLICE     2
+#define SUBOPCODE_BSD_BUF_BASE  3
+#define SUBOPCODE_BSD_IND_OBJ   4
+#define SUBOPCODE_BSD_OBJECT    8
+
+/* MI */
+#define MASK_MI_OPCODE          0x1F800000
+
+#define SHIFT_MI_OPCODE         23
+
+#define OPCODE_MI_FLUSH                 0x04
+#define OPCODE_MI_BATCH_BUFFER_END      0x0A
+
+int intel_batchbuffer_dump(unsigned int *data, unsigned int offset, int count, unsigned int device);
+
+#endif /* _INTEL_BATCHBUFFER_DUMP_H_ */
diff --git a/i965_drv_video/intel_driver.h b/i965_drv_video/intel_driver.h
index 9ab95b7..e7cbaaa 100644
--- a/i965_drv_video/intel_driver.h
+++ b/i965_drv_video/intel_driver.h
@@ -17,7 +17,7 @@
 #define INLINE
 #endif
 
-#define BATCH_SIZE      0x10000
+#define BATCH_SIZE      0x100000
 #define BATCH_RESERVED  0x10
 
 #define CMD_MI                                  (0x0 << 29)
@@ -26,6 +26,7 @@
 #define MI_NOOP                                 (CMD_MI | 0)
 
 #define MI_BATCH_BUFFER_END                     (CMD_MI | (0xA << 23))
+#define MI_BATCH_BUFFER_START                   (CMD_MI | (0x31 << 23))
 
 #define MI_FLUSH                                (CMD_MI | (0x4 << 23))
 #define STATE_INSTRUCTION_CACHE_INVALIDATE      (0x1 << 0)
@@ -44,6 +45,7 @@ struct intel_batchbuffer;
 #define ALIGN(i, n)    (((i) + (n) - 1) & ~((n) - 1))
 #define MIN(a, b) ((a) < (b) ? (a) : (b))
 #define MAX(a, b) ((a) > (b) ? (a) : (b))
+#define ARRAY_ELEMS(a) (sizeof(a) / sizeof((a)[0]))
 
 #define SET_BLOCKED_SIGSET()   do {     \
         sigset_t bl_mask;               \
@@ -85,6 +87,7 @@ struct intel_driver_data
     int locked;
 
     struct intel_batchbuffer *batch;
+    struct intel_batchbuffer *batch_bcs;
     dri_bufmgr *bufmgr;
 };
 
@@ -118,8 +121,8 @@ struct intel_region
 #define PCI_CHIP_G45_G                  0x2E22
 #define PCI_CHIP_G41_G                  0x2E32
 
-#define PCI_CHIP_IGDNG_D_G              0x0042
-#define PCI_CHIP_IGDNG_M_G              0x0046
+#define PCI_CHIP_IRONLAKE_D_G           0x0042
+#define PCI_CHIP_IRONLAKE_M_G           0x0046
 
 #define IS_G45(devid)           (devid == PCI_CHIP_IGD_E_G || \
                                  devid == PCI_CHIP_Q45_G || \
@@ -128,8 +131,8 @@ struct intel_region
 #define IS_GM45(devid)          (devid == PCI_CHIP_GM45_GM)
 #define IS_G4X(devid)		(IS_G45(devid) || IS_GM45(devid))
 
-#define IS_IGDNG_D(devid)       (devid == PCI_CHIP_IGDNG_D_G)
-#define IS_IGDNG_M(devid)       (devid == PCI_CHIP_IGDNG_M_G)
-#define IS_IGDNG(devid)         (IS_IGDNG_D(devid) || IS_IGDNG_M(devid))
+#define IS_IRONLAKE_D(devid)    (devid == PCI_CHIP_IRONLAKE_D_G)
+#define IS_IRONLAKE_M(devid)    (devid == PCI_CHIP_IRONLAKE_M_G)
+#define IS_IRONLAKE(devid)      (IS_IRONLAKE_D(devid) || IS_IRONLAKE_M(devid))
 
 #endif /* _INTEL_DRIVER_H_ */
diff --git a/i965_drv_video/object_heap.c b/i965_drv_video/object_heap.c
index 1900f8c..e867139 100644
--- a/i965_drv_video/object_heap.c
+++ b/i965_drv_video/object_heap.c
@@ -50,7 +50,6 @@ static int object_heap_expand( object_heap_p heap )
     {
         return -1; /* Out of memory */
     }
-    memset(new_heap_index + heap->heap_size*heap->object_size, 0, heap->heap_increment * new_heap_size);
     heap->heap_index = new_heap_index;
     next_free = heap->next_free;
     for(i = new_heap_size; i-- > heap->heap_size; )
diff --git a/i965_drv_video/shaders/Makefile.am b/i965_drv_video/shaders/Makefile.am
index 24f1aa8..2fd019b 100644
--- a/i965_drv_video/shaders/Makefile.am
+++ b/i965_drv_video/shaders/Makefile.am
@@ -1 +1 @@
-SUBDIRS = mpeg2 render
+SUBDIRS = h264 mpeg2 render
diff --git a/i965_drv_video/shaders/h264/Makefile.am b/i965_drv_video/shaders/h264/Makefile.am
new file mode 100644
index 0000000..d6d106b
--- /dev/null
+++ b/i965_drv_video/shaders/h264/Makefile.am
@@ -0,0 +1 @@
+SUBDIRS = mc
diff --git a/i965_drv_video/shaders/h264/ildb/AVC_ILDB.inc b/i965_drv_video/shaders/h264/ildb/AVC_ILDB.inc
new file mode 100644
index 0000000..734717f
--- /dev/null
+++ b/i965_drv_video/shaders/h264/ildb/AVC_ILDB.inc
@@ -0,0 +1,718 @@
+/*
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+#if !defined(__AVC_ILDB_HEADER__)	// Make sure this file is only included once
+#define __AVC_ILDB_HEADER__
+
+// Module name: AVC_ILDB.inc
+
+#undef ORIX
+#undef ORIY
+
+//========== Root thread input parameters ==================================================
+#define RootParam				r1		// :w
+#define	MBsCntX					r1.0	// :w, MB count per row
+#define	MBsCntY					r1.1	// :w, MB count per col
+//#define PicType					r1.2	// :w, Picture type
+#define	MaxThreads				r1.3	// :w, Max Thread limit
+#define EntrySignature			r1.4	// :w, Debug flag
+#define BitFields				r1.5	// :uw
+#define 	MbaffFlag			BIT0	// :w, mbaff flag, bit 0 in BitFields
+#define 	BotFieldFlag		BIT1	// :w, bottom field flag, bit 1 in BitFields
+#define 	CntlDataExpFlag		BIT2	// :w, Control Data Expansion Flag, bit 2 in BitFields
+#define RampConst				r1.12	// 8 :ub, Ramp constant, r1.12 - r1.19:ub
+#define StepToNextMB			r1.20	// :b, 2 bytes
+#define Minus2Minus1			r1.22	// :b, 2 bytes
+// next one starts at r1.11:w
+
+#define 	TopFieldFlag		0xFFFD	// :w, top field flag, used to set bit1 to 0.
+
+
+//========== Root Locals =============================================================
+
+// Variables in root kernel for launching child therad
+#define ChildParam				r2.0	// :w
+//Not used  #define	URBOffset				r2.3	// :w, Each row occupies 4 URB entries.  All children in the same row use the same set of URB entries
+#define	CurCol					r2.10	// :w, current col
+#define	CurColB					r2.20	// :b, current col
+#define	CurRow					r2.11	// :w, current row
+#define	CurRowB					r2.22	// :b, current row
+#define	LastCol					r2.12	// :w, last col
+#define	LastRow					r2.13	// :w, last row
+
+// Root local constants during spawning process
+#define	Col_Boundary			r3.0	// :w, 
+#define	Row_Boundary			r3.1	// :w, 
+//#define	TotalBlocks				r3.2	// :w, Total blocks in the frame 
+#define	URB_EntriesPerMB_2		r3.3	// :w, = URB entries per MB, but in differnt form
+#define	URBOffsetUVBase			r3.4	// :w, UV Base offset in URB
+
+#define	Temp1_D					r3.6	// :d:
+#define	Temp1_W					r3.12	// :w, Temp1
+#define	Temp1_B					r3.24	// :b, = Temp1_W
+#define	Temp2_W					r3.13	// :w, Temp2
+#define	Temp2_B					r3.26	// :b, = Temp2_W
+
+// Root local variables
+#define JumpTable				r4		// :d, jump table
+#define JUMPTABLE_BASE			4*32
+#define JumpAddr				a0.7
+
+#define TopRowForScan			r5.0 	// :w, track the top row for scan. All rows above this row is deblocked already. 
+
+
+// Child Thread R0 Header Field
+#define MRF0					m0		
+#define CT_R0Hdr				m1
+
+/*
+.declare GatewayAperture	Base=r50.0 ElementSize=4 SrcRegion=REGION(8,1) Type=ud	
+#define GatewayApertureB	1600	// r50 byte offset from r0.0
+
+// Chroma root thread updates luma root's ThreadLimit at r10.0:w via gateway
+#define ThreadLimit				r62.0	// :w, thread limit //r56.0
+#define THREAD_LIMIT_OFFSET		0x01800000	// Offset from r50 to r56 = 12*32 = 384 = 0x0180.  0x180 << 16 = 0x01800000
+	//#define THREAD_LIMIT_OFFSET		0x00C00000	// Offset from r50 to r56 = 6*32 = 192 = 0x00C0.  0xC0 << 16 = 0x00C00000
+*/
+
+// Gateway size is 16 GRF.  68 rows of MBs takes 9 GRFs (r6 - r14)
+// For CTG: Expended to support 1280 rows of pixel (80 rows of MBs).  It requires 10 GRFs (r6 - r15)
+.declare GatewayAperture	Base=r6.0 ElementSize=4 SrcRegion=REGION(8,1) Type=ud	
+#define GatewayApertureB	192	// r0.0 byte offset from r0.0
+
+// Chroma root thread updates luma root's ThreadLimit at r10.0:w via gateway
+#define ThreadLimit				r18.0	// :w, thread limit 
+#define THREAD_LIMIT_OFFSET		0x01800000	// Offset from r50 to r56 = 12*32 = 384 = 0x0180.  0x180 << 16 = 0x01800000
+#define	TotalBlocks				r18.1	// :w, Total blocks in the frame 
+
+// Root local variables
+#define	ChildThreadsID			r19.0	// :w, Child thread ID, unique to each child
+#define	OutstandingThreads		r20.0	// :w, Outstanding threads 
+#define ProcessedMBs			r20.1	// :w, # of MBs processed 
+
+#define	URBOffset				r21.0	// :w, Each row occupies 4 URB entries.  All children in the same row use the same set of URB entries
+
+//=================================================================================
+
+#define ScoreBd_Size			128 //96 // size of Status[] or ProcCol[]
+
+#define ScoreBd_Idx				2		
+//#define Saved_Col				0
+
+#define StatusAddr				a0.4	// :w, point to r50
+//=================================================================================
+
+
+// Gateway payload
+#define GatewayPayload			r48.0	// :ud
+#define GatewayPayloadKey		r48.8	// :uw
+#define DispatchID				r48.20	// :ub
+#define RegBase_GatewaySize 	r48.5	// :ud, used in open a gateway
+#define Offset_Length			r48.5	// :ud, used in forwardmsg back to root
+#define EUID_TID				r48.9	// :uw, used in forwardmsg back to root
+
+// Gateway response
+#define GatewayResponse 		r49.0	// :ud, one GRF
+
+#define URBWriteMsgDesc			a0.0	// Used in URB write, :ud
+#define URBWriteMsgDescLow		a0.0	// Used in URB write, :uw
+#define URBWriteMsgDescHigh		a0.1	// Used in URB write, :uw
+
+.declare WritebackResponse		Base=r50 ElementSize=4 SrcRegion=REGION(8,1) Type=ud	// 1 GRF for write backs
+
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+// IDesc Order					Offset
+//
+// 0) luma root					0 from luma root
+// 1) luma child				16 from luma root
+// 2) chroma root				32 from luma root
+// 3) chroma child				16 from chroma root
+
+// 4) luma field root			0 from luma field root
+// 5) luma field child			16 from luma field root
+// 6) chroma field root			32 from luma field root
+// 7) chroma field child		16 from chroma field root
+
+// 8) luma Mbaff root			0 from luma Mbaff root
+// 9) luma Mbaff child 			16 from luma Mbaff root
+// 10) chroma Mbaff root		32 from luma Mbaff root
+// 11) chroma Mbaff child		16 from chroma Mbaff root
+
+// IDesc offset within non-mbaff or mbaff mode
+#define CHROMA_ROOT_OFFSET 		32		// Offset from luma root to chroma root
+#define CHILD_OFFSET	  		16		// Offset from luma root to luma child, 
+										// and from chroma root to chroma child
+/////////////////////////////////////////////////////////////////////////////////////////////
+
+
+//========== End of Root Variables ======================================================
+
+
+//========== Child thread input parameters ==============================================
+//#define	MBsCntX					r1.0	// :w, MB count per row (same as root)
+//#define	MBsCntY					r1.1	// :w, MB count per col (same as root)
+//#define PicTypeC				r1.2	// :w, Picture type		same as root thread (same as root)
+#define	URBOffsetC				r1.3	// :w, 
+#define EntrySignatureC			r1.4	// :w, Debug field (same as root)
+//#define BitFields				r1.5	// :w (same as root)
+//#define 	MbaffFlag			BIT0	// :w, mbaff flag, bit 0 in BitFields
+//#define 	BotFieldFlag		BIT1	// :w, bottom field flag, bit 1 in BitFields
+//#define 	CntlDataExpFlag		BIT2	// :w, Control Data Expansion Flag, bit 2 in BitFields
+#define RampConstC				r1.12	// 8 :ub, Ramp constant, r1.12 - r1.19:ub.
+#define	ORIX					r1.10	// :w, carry over from root r1 in MB count
+#define	ORIY					r1.11	// :w, carry over from root r1 in MB count
+#define	LastColC				r1.12	// :w, last col
+#define	LastRowC				r1.13	// :w, last row
+
+.declare GatewayApertureC		Base=r1.0 ElementSize=4 SrcRegion=REGION(8,1) Type=ud	
+#define GatewayApertureCBase	32		// r1 byte offset from r0.0
+
+
+//========== Child Variables ============================================================
+
+// Mbaff Alpha, Beta, Tc0 vectors for an edge
+.declare Mbaff_ALPHA 	Base=r14.0  ElementSize=2 SrcRegion=REGION(8,1) Type=uw		// r14
+.declare Mbaff_BETA 	Base=r15.0  ElementSize=2 SrcRegion=REGION(8,1) Type=uw		// r15
+.declare Mbaff_TC0 		Base=r16.0  ElementSize=2 SrcRegion=REGION(8,1) Type=uw		// r16
+.declare RRampW	   		Base=r17.0 ElementSize=2 SrcRegion=REGION(8,1) Type=w		// r17
+
+.declare Mbaff_ALPHA2	Base=r45.0  ElementSize=2 SrcRegion=REGION(8,1) Type=uw		// alpha2 = (alpha >> 2) + 2
+
+
+#define	ORIX_CUR				r46.0	// :w, current block origin X in bytes
+#define	ORIY_CUR				r46.1	// :w, current block origin Y in bytes
+#define	ORIX_LEFT				r46.2	// :w, left block origin X in bytes
+#define	ORIY_LEFT				r46.3	// :w, left block origin Y in bytes
+#define	ORIX_TOP				r46.4	// :w, top block origin X in bytes
+#define	ORIY_TOP				r46.5	// :w, top block origin Y in bytes
+//#define FilterSampleFlag		r46.6	// :uw,
+#define	CTemp0_W				r46.7	// :w, child Temp0
+
+#define alpha					r46.8	// :w, Scaler version for non Mbaff
+#define beta					r46.9	// :w, Scaler version for non Mbaff
+#define tc0						r46.20	// 4 :ub, r46.20 ~ r46.23, Scaler version for non Mbaff
+#define MaskA					r46.12	// :uw
+#define MaskB					r46.13	// :uw
+
+// Child control flags
+#define DualFieldMode			r47.0	// Cur MB is frame based, above MB is field based in mbaff mode
+										// :uw, 0 = not in dual field mode,  1 = in dual field mode, filter both top and bot fields
+#define	GateWayOffsetC			r47.1	// :w, Gateway offset for child writing into root space
+#define CntrlDataOffsetY		r47.1	// :ud, MB control data data offset
+#define alpha2					r47.4	// :uw, 	alpha2 = (alpha >> 2) + 2
+
+#define VertEdgePattern			r47.5	// :uw, 
+
+#define	CTemp1_W				r47.6	// :w, child Temp1
+#define	CTemp1_B				r47.12	// :b, = child Temp1_W
+#define	CTemp2_W				r47.7	// :w, child Temp2
+#define	CTemp2_B				r47.14	// :b, = child Temp2_W
+
+// Used in child
+#define ECM_AddrReg				a0.4	// Edge Control Map register
+#define P_AddrReg				a0.6	// point to P samples in left or top MB
+#define Q_AddrReg				a0.7	// point to Q samples in cur MB
+
+
+.declare 	RTempD	   Base=r26.0 ElementSize=4 SrcRegion=REGION(8,1) Type=d	// r26-27
+.declare 	RTempB	   Base=r26.0 ElementSize=1 SrcRegion=REGION(8,4) Type=ub	// r26-27
+.declare 	RTempW	   Base=r26.0 ElementSize=2 SrcRegion=REGION(8,1) Type=w	// r26-27
+#define 	LEFT_TEMP_D		RTempD
+#define 	LEFT_TEMP_B		RTempB
+#define 	LEFT_TEMP_W		RTempW
+
+.declare 	TempRow0   Base=r26.0 ElementSize=2 SrcRegion=REGION(8,1) Type=w
+.declare 	TempRow0B  Base=r26.0 ElementSize=1 SrcRegion=REGION(8,2) Type=ub
+.declare 	TempRow1   Base=r27.0 ElementSize=2 SrcRegion=REGION(8,1) Type=w
+.declare 	TempRow1B  Base=r27.0 ElementSize=1 SrcRegion=REGION(8,2) Type=ub
+
+.declare 	CUR_TEMP_D	Base=r28.0 ElementSize=4 SrcRegion=REGION(8,1) Type=d	// 8 GRFs
+.declare 	CUR_TEMP_B	Base=r28.0 ElementSize=1 SrcRegion=REGION(8,4) Type=ub
+.declare 	CUR_TEMP_W	Base=r28.0 ElementSize=2 SrcRegion=REGION(8,1) Type=w
+
+#define FilterSampleFlag		r28.0	// :uw,
+
+.declare 	A   		Base=r28.0 ElementSize=2 SrcRegion=REGION(16,1) Type=w
+.declare 	B   		Base=r29.0 ElementSize=2 SrcRegion=REGION(16,1) Type=w
+
+.declare 	TempRow3   Base=r30.0 ElementSize=2 SrcRegion=REGION(8,1) Type=w
+.declare 	TempRow3B  Base=r30.0 ElementSize=1 SrcRegion=REGION(8,2) Type=ub
+
+.declare 	tc0_exp		Base=r30.0 ElementSize=2 SrcRegion=REGION(8,1) Type=w
+.declare 	tc8			Base=r30.0 ElementSize=2 SrcRegion=REGION(8,1) Type=w
+
+.declare 	tc_exp		Base=r31.0 ElementSize=2 SrcRegion=REGION(8,1) Type=w
+.declare	tx_exp_8	Base=r31.0 ElementSize=2 SrcRegion=REGION(8,1) Type=w
+
+.declare	q0_p0		Base=r32.0 ElementSize=2 SrcRegion=REGION(8,1) Type=w
+.declare	ABS_q0_p0	Base=r33.0 ElementSize=2 SrcRegion=REGION(8,1) Type=w
+
+.declare	ap			Base=r34.0 ElementSize=2 SrcRegion=REGION(8,1) Type=w
+.declare	aq			Base=r35.0 ElementSize=2 SrcRegion=REGION(8,1) Type=w
+
+// These buffers have the src data for each edge to be beblocked.
+// They have modified pixels from previous edges.
+//
+//	Y:
+//	+----+----+----+----+----+----+----+----+
+//	| p3 | p2 | P1 | p0 | q0 | q1 | q2 | q3 |
+//	+----+----+----+----+----+----+----+----+
+//
+//	p3 = r[P_AddrReg, 0]<16;16,1>  
+//	p2 = r[P_AddrReg, 16]<16;16,1> 
+//	p1 = r[P_AddrReg, 32]<16;16,1> 
+//	p0 = r[P_AddrReg, 48]<16;16,1> 
+// 	q0 = r[Q_AddrReg, 0]<16;16,1>  
+//	q1 = r[Q_AddrReg, 16]<16;16,1> 
+//	q2 = r[Q_AddrReg, 32]<16;16,1> 
+//	q3 = r[Q_AddrReg, 48]<16;16,1> 
+
+.declare	p0123_W		Base=r36.0  ElementSize=2 SrcRegion=REGION(16,1) Type=uw		// r36, r37
+.declare	q0123_W		Base=r38.0  ElementSize=2 SrcRegion=REGION(16,1) Type=uw		// r38, r39
+.declare	p3			Base=r36.0  ElementSize=1 SrcRegion=REGION(8,1) Type=ub
+.declare	p2			Base=r36.16 ElementSize=1 SrcRegion=REGION(8,1) Type=ub
+.declare	p1			Base=r37.0  ElementSize=1 SrcRegion=REGION(8,1) Type=ub
+.declare	p0			Base=r37.16 ElementSize=1 SrcRegion=REGION(8,1) Type=ub
+.declare	q0			Base=r38.0  ElementSize=1 SrcRegion=REGION(8,1) Type=ub
+.declare	q1			Base=r38.16 ElementSize=1 SrcRegion=REGION(8,1) Type=ub
+.declare	q2			Base=r39.0  ElementSize=1 SrcRegion=REGION(8,1) Type=ub
+.declare	q3			Base=r39.16 ElementSize=1 SrcRegion=REGION(8,1) Type=ub
+
+.declare 	TempRow2   Base=r38.0 ElementSize=2 SrcRegion=REGION(8,1) Type=w
+
+// Temp space for mbaff dual field mode
+#define		ABOVE_CUR_MB_BASE	40*GRFWIB											// Byte offset to r40
+.declare    ABOVE_CUR_MB_YW  Base=r40 	ElementSize=2 SrcRegion=REGION(8,1) Type=uw
+.declare    ABOVE_CUR_MB_UW  Base=r40 	ElementSize=2 SrcRegion=REGION(8,1) Type=uw
+
+.declare 	P0_plus_P1   Base=r41.0 ElementSize=2 SrcRegion=REGION(8,1) Type=w
+.declare 	Q0_plus_Q1   Base=r42.0 ElementSize=2 SrcRegion=REGION(8,1) Type=w
+
+.declare 	P2_plus_P3   Base=r43.0 ElementSize=2 SrcRegion=REGION(8,1) Type=w
+.declare 	Q2_plus_Q3   Base=r44.0 ElementSize=2 SrcRegion=REGION(8,1) Type=w
+
+
+//////////////////////////////////////////////////////////////////////////////////////////
+// MB control data reference
+
+// Expanded control data is in r18 - r25
+.declare    CNTRL_DATA_D Base=r18 	ElementSize=4 SrcRegion=REGION(8,1) Type=ud		// For read, 8 GRFs
+#define		CNTRL_DATA_BASE	18*GRFWIB												// Base offset to r18
+
+//  Bit mask for extracting bits
+#define	MbaffFrameFlag					0x01
+#define	FieldModeCurrentMbFlag			0x02
+#define FieldModeLeftMbFlag				0x04
+#define FieldModeAboveMbFlag			0x08
+#define FilterInternal8x8EdgesFlag		0x10
+#define FilterInternal4x4EdgesFlag		0x20
+#define FilterLeftMbEdgeFlag			0x40
+#define FilterTopMbEdgeFlag				0x80
+
+#define	DISABLE_ILDB_FLAG				0x01
+
+//  Exact bit pattern for left and cur MB coding mode (frame vs. field)
+#define LEFT_FRAME_CUR_FRAME			0x00
+#define LEFT_FRAME_CUR_FIELD			0x02
+#define LEFT_FIELD_CUR_FRAME			0x04
+#define LEFT_FIELD_CUR_FIELD			0x06
+
+//  Exact bit pattern for above and cur MB coding mode (frame vs. field)
+#define ABOVE_FRAME_CUR_FRAME			0x00
+#define ABOVE_FRAME_CUR_FIELD			0x02
+#define ABOVE_FIELD_CUR_FRAME			0x08
+#define ABOVE_FIELD_CUR_FIELD			0x0A
+
+
+
+//========== MB control data field offset in byte ==========
+
+#if !defined(_APPLE)
+
+// GRF0 - GRF1 holds original control data
+
+// GRF0
+#define HorizOrigin						0
+#define VertOrigin						1
+#define BitFlags						2		// Bit flags
+
+#define bbSinternalLeftVert				4		// Internal left vertical bS, 2 bits per bS for 4 Y pixels and 2 U/V pixels 	
+#define bbSinternalMidVert				5		// Internal mid vertical bS
+#define bbSinternalRightVert			6		// Internal right vertical bS
+#define bbSinternalTopHorz				7		// Internal top horizontal bS
+
+#define	bbSinternalMidHorz				8		// Internal mid horizontal bS
+#define	bbSinternalBotHorz				9		// Internal bottom horizontal bS
+#define	wbSLeft0						10		// External left vertical bS (0), 4 bits per bS for 4 Y pixels and 2 U/V pixels, and byte 11
+
+#define	wbSLeft1						12		// External left vertical bS (1), and byte 13
+#define	wbSTop0							14		// External top horizontal bS (0), and byte 15
+
+#define	wbSTop1							16		// Externaltop horizontal bS (1), and byte 17
+#define	bIndexAinternal_Y				18		// Internal index A for Y
+#define	bIndexBinternal_Y				19		// Internal index B for Y
+
+#define	bIndexAleft0_Y					20		// Left index A for Y (0)
+#define	bIndexBleft0_Y					21		// Left index B for Y (0)
+#define	bIndexAleft1_Y					22		// Left index A for Y (1)
+#define	bIndexBleft1_Y					23		// Left index B for Y (1)
+
+#define	bIndexAtop0_Y					24		// Top index A for Y (0)
+#define	bIndexBtop0_Y					25		// Top index B for Y (0)
+#define	bIndexAtop1_Y					26		// Top index A for Y (1)
+#define	bIndexBtop1_Y					27		// Top index B for Y (1)
+
+#define	bIndexAinternal_Cb				28		// Internal index A for Cb
+#define	bIndexBinternal_Cb				29		// Internal index B for Cb
+#define	bIndexAleft0_Cb					30		// Left index A for Cb (0)
+#define	bIndexBleft0_Cb					31		// Left index B for Cb (0)
+
+// GRF1
+#define	bIndexAleft1_Cb					32		// Left index A for Cb (1)
+#define	bIndexBleft1_Cb					33		// Left index B for Cb (1)
+#define	bIndexAtop0_Cb					34		// Top index A for Cb (0)
+#define	bIndexBtop0_Cb					35		// Top index B for Cb (0)
+
+#define	bIndexAtop1_Cb					36		// Top index A for Cb (1)
+#define	bIndexBtop1_Cb					37		// Top index B for Cb (1)
+#define	bIndexAinternal_Cr				38		// Internal index A for Cr
+#define	bIndexBinternal_Cr				39		// Internal index B for Cr
+
+#define	bIndexAleft0_Cr					40		// Left index A for Cr (0)
+#define bIndexBleft0_Cr					41		// Left index B for Cr (0)
+#define	bIndexAleft1_Cr					42		// Left index A for Cr (1)
+#define	bIndexBleft1_Cr					43		// Left index B for Cr (1)
+
+#define	bIndexAtop0_Cr					44		// Top index A for Cr (0)
+#define	bIndexBtop0_Cr					45		// Top index B for Cr (0)
+#define	bIndexAtop1_Cr					46		// Top index A for Cr (1)
+#define	bIndexBtop1_Cr					47		// Top index B for Cr (1)
+
+#define	ExtBitFlags						48		// Extended bit flags, such as disable ILDB bits
+
+// Offset 49 - 63 not used
+
+
+//===== GRF2 - GRF7 hold expanded control data =====
+
+// GRF2
+#define	wEdgeCntlMap_IntLeftVert		64		// Derived from bbSinternalLeftVert, 1 bit per pixel 
+#define	wEdgeCntlMap_IntMidVert			66		// Derived from bbSinternalLeftVert
+		
+#define	wEdgeCntlMap_IntRightVert		68		// Derived from bbSinternalRightVert
+#define	wEdgeCntlMap_IntTopHorz			70		// Derived from bbSinternalTopHorz, 1bit per pixel 
+		
+#define	wEdgeCntlMap_IntMidHorz			72		// Derived from bbSinternalMidHorz
+#define	wEdgeCntlMap_IntBotHorz			74		// Derived from bbSinternalBotHorz
+
+// Offset 76 - 79 not used
+
+#define	wEdgeCntlMapA_ExtLeftVert0		80		// Derived from wbSLeft0, 1bit per pixel
+#define	wEdgeCntlMapB_ExtLeftVert0		82		// Derived from wbSLeft0
+
+#define	wEdgeCntlMapA_ExtTopHorz0		84		// Derived from wbSTop0, 1bit per pixel
+#define	wEdgeCntlMapB_ExtTopHorz0		86		// Derived from wbSTop0
+
+#define	wEdgeCntlMapA_ExtLeftVert1		88		// Derived from wbSLeft1, 1bit per pixel
+#define	wEdgeCntlMapB_ExtLeftVert1		90		// Derived from wbSLeft1
+
+#define	wEdgeCntlMapA_ExtTopHorz1		92		// Derived from wbSTop1, 1bit per pixel
+#define	wEdgeCntlMapB_ExtTopHorz1		94		// Derived from wbSTop1
+
+
+// GRF3
+#define	bTc0_v00_0_Y					96		// Derived from bSv00_0 and bIndexAleft0_Y, 4 pixels per tc0
+#define	bTc0_v10_0_Y					97		// Derived from bSv10_0 and bIndexAleft0_Y
+#define	bTc0_v20_0_Y					98		// Derived from bSv20_0 and bIndexAleft0_Y
+#define	bTc0_v30_0_Y					99		// Derived from bSv30_0 and bIndexAleft0_Y
+
+#define	bTc0_v01_Y						100		// Derived from bSv01 and bIndexAinternal_Y
+#define	bTc0_v11_Y						101		// Derived from bSv11 and bIndexAinternal_Y
+#define	bTc0_v21_Y						102		// Derived from bSv21 and bIndexAinternal_Y
+#define	bTc0_v31_Y						103		// Derived from bSv31 and bIndexAinternal_Y
+
+#define	bTc0_v02_Y						104		// Derived from bSv02 and bIndexAinternal_Y
+#define	bTc0_v12_Y						105		// Derived from bSv12 and bIndexAinternal_Y
+#define	bTc0_v22_Y						106		// Derived from bSv22 and bIndexAinternal_Y
+#define	bTc0_v32_Y						107		// Derived from bSv32 and bIndexAinternal_Y
+
+#define	bTc0_v03_Y						108		// Derived from bSv03 and bIndexAinternal_Y
+#define	bTc0_v13_Y						109		// Derived from bSv13 and bIndexAinternal_Y
+#define	bTc0_v23_Y						110		// Derived from bSv23 and bIndexAinternal_Y
+#define	bTc0_v33_Y						111		// Derived from bSv33 and bIndexAinternal_Y
+
+#define	bTc0_h00_0_Y					112		// Derived from bSh00_0 and bIndexAleft0_Y
+#define	bTc0_h01_0_Y					113		// Derived from bSh01_0 and bIndexAleft0_Y
+#define	bTc0_h02_0_Y					114		// Derived from bSh02_0 and bIndexAleft0_Y
+#define	bTc0_h03_0_Y					115		// Derived from bSh03_0 and bIndexAleft0_Y
+
+#define	bTc0_h10_Y						116		// Derived from bSh10 and bIndexAinternal_Y
+#define	bTc0_h11_Y						117		// Derived from bSh11 and bIndexAinternal_Y
+#define	bTc0_h12_Y						118		// Derived from bSh12 and bIndexAinternal_Y
+#define	bTc0_h13_Y						119		// Derived from bSh13 and bIndexAinternal_Y
+		
+#define	bTc0_h20_Y						120		// Derived from bSh20 and bIndexAinternal_Y
+#define	bTc0_h21_Y						121		// Derived from bSh21 and bIndexAinternal_Y
+#define	bTc0_h22_Y						122		// Derived from bSh22 and bIndexAinternal_Y
+#define	bTc0_h23_Y						123		// Derived from bSh23 and bIndexAinternal_Y
+
+#define	bTc0_h30_Y						124		// Derived from bSh30 and bIndexAinternal_Y
+#define	bTc0_h31_Y						125		// Derived from bSh31 and bIndexAinternal_Y
+#define	bTc0_h32_Y						126		// Derived from bSh32 and bIndexAinternal_Y
+#define	bTc0_h33_Y						127		// Derived from bSh33 and bIndexAinternal_Y
+
+// GRF4
+#define	bAlphaLeft0_Y					128		// Derived from bIndexAleft0_Y	
+#define	bBetaLeft0_Y					129		// Derived from bIndexBleft0_Y	
+#define	bAlphaTop0_Y					130		// Derived from bIndexAtop0_Y	
+#define	bBetaTop0_Y						131		// Derived from bIndexBtop0_Y	
+
+#define	bAlphaInternal_Y				132		// Derived from bIndexAinternal_Y	
+#define	bBetaInternal_Y					133		// Derived from bIndexBinternal_Y	
+// Offset 134 - 135 not used
+
+// Offset 136 - 143 not used
+#define	bAlphaLeft1_Y					144		// Derived from bIndexAleft1_Y	Used in Mbaff mode only
+#define	bBetaLeft1_Y					145		// Derived from bIndexBleft1_Y	Used in Mbaff mode only
+#define	bAlphaTop1_Y					146		// Derived from bIndexAtop1_Y	Used in Mbaff mode only
+#define	bBetaTop1_Y						147		// Derived from bIndexBtop1_Y	Used in Mbaff mode only
+
+// Offset 148 - 151 not used
+#define	bTc0_v00_1_Y					152		// Derived from bSv00_1 and bIndexAleft1_Y	Used in Mbaff mode only
+#define	bTc0_v10_1_Y					153		// Derived from bSv10_1 and bIndexAleft1_Y	Used in Mbaff mode only
+#define	bTc0_v20_1_Y					154		// Derived from bSv20_1 and bIndexAleft1_Y	Used in Mbaff mode only
+#define	bTc0_v30_1_Y					155		// Derived from bSv30_1 and bIndexAleft1_Y	Used in Mbaff mode only
+
+#define	bTc0_h00_1_Y					156		// Derived from bSh00_1 and bIndexAleft1_Y	Used in Mbaff mode only
+#define	bTc0_h01_1_Y					157		// Derived from bSh01_1 and bIndexAleft1_Y	Used in Mbaff mode only
+#define	bTc0_h02_1_Y					158		// Derived from bSh02_1 and bIndexAleft1_Y	Used in Mbaff mode only
+#define	bTc0_h03_1_Y					159		// Derived from bSh03_1 and bIndexAleft1_Y	Used in Mbaff mode only
+
+
+// GRF5
+#define	bTc0_v00_0_Cb					160		// Derived from bSv00_0 and bIndexAleft0_Cb, 2 pixels per tc0	Left0
+#define	bTc0_v10_0_Cb					161		// Derived from bSv10_0 and bIndexAleft0_Cb	
+#define	bTc0_v20_0_Cb					162		// Derived from bSv20_0 and bIndexAleft0_Cb	
+#define	bTc0_v30_0_Cb					163		// Derived from bSv30_0 and bIndexAleft0_Cb	
+
+#define	bTc0_v02_Cb						164		// Derived from bSv02 and bIndexAinternal_Cb	MidVert
+#define	bTc0_v12_Cb						165		// Derived from bSv12 and bIndexAinternal_Cb	
+#define	bTc0_v22_Cb						166		// Derived from bSv22 and bIndexAinternal_Cb	
+#define	bTc0_v32_Cb						167		// Derived from bSv32 and bIndexAinternal_Cb	
+
+#define	bTc0_h00_0_Cb					168		// Derived from bSh00_0 and bIndexAleft0_Cb	Top0
+#define	bTc0_h01_0_Cb					169		// Derived from bSh01_0 and bIndexAleft0_Cb	
+#define	bTc0_h02_0_Cb					170		// Derived from bSh02_0 and bIndexAleft0_Cb	
+#define	bTc0_h03_0_Cb					171		// Derived from bSh03_0 and bIndexAleft0_Cb	
+
+#define	bTc0_h20_Cb						172		// Derived from bSh20 and bIndexAinternal_Cb	MidHorz
+#define	bTc0_h21_Cb						173		// Derived from bSh21 and bIndexAinternal_Cb	
+#define	bTc0_h22_Cb						174		// Derived from bSh22 and bIndexAinternal_Cb	
+#define	bTc0_h23_Cb						175		// Derived from bSh23 and bIndexAinternal_Cb	
+
+#define	bTc0_v00_0_Cr					176		// Derived from bSv00_0 and bIndexAleft0_Cr, 2 pixels per tc0	Left0
+#define	bTc0_v10_0_Cr					177		// Derived from bSv10_0 and bIndexAleft0_Cr	
+#define	bTc0_v20_0_Cr					178		// Derived from bSv20_0 and bIndexAleft0_Cr	
+#define	bTc0_v30_0_Cr					179		// Derived from bSv30_0 and bIndexAleft0_Cr	
+
+#define	bTc0_v02_Cr						180		// Derived from bSv02 and bIndexAinternal_Cr	Mid Vert
+#define	bTc0_v12_Cr						181		// Derived from bSv12 and bIndexAinternal_Cr	
+#define	bTc0_v22_Cr						182		// Derived from bSv22 and bIndexAinternal_Cr	
+#define	bTc0_v32_Cr						183		// Derived from bSv32 and bIndexAinternal_Cr	
+
+#define	bTc0_h00_0_Cr					184		// Derived from bSh00_0 and bIndexAleft0_Cr, 2 pixels per tc0	Top0
+#define	bTc0_h01_0_Cr					185		// Derived from bSh01_0 and bIndexAleft0_Cr	
+#define	bTc0_h02_0_Cr					186		// Derived from bSh02_0 and bIndexAleft0_Cr	
+#define	bTc0_h03_0_Cr					187		// Derived from bSh03_0 and bIndexAleft0_Cr	
+
+#define	bTc0_h20_Cr						188		// Derived from bSh20 and bIndexAinternal_Cr	Mid  Horz
+#define	bTc0_h21_Cr						189		// Derived from bSh21 and bIndexAinternal_Cr	
+#define	bTc0_h22_Cr						190		// Derived from bSh22 and bIndexAinternal_Cr	
+#define	bTc0_h23_Cr						191		// Derived from bSh23 and bIndexAinternal_Cr	
+
+// GRF6
+#define	bAlphaLeft0_Cb					192		// Derived from bIndexAleft0_Cb
+#define	bBetaLeft0_Cb					193		// Derived from bIndexBleft0_Cb
+#define	bAlphaTop0_Cb					194		// Derived from bIndexAtop0_Cb
+#define	bBetaTop0_Cb					195		// Derived from bIndexBtop0_Cb
+
+#define	bAlphaInternal_Cb				196		// Derived from bIndexAinternal_Cb
+#define	bBetaInternal_Cb				197		// Derived from bIndexBinternal_Cb
+// Offset 198 - 199 not used		
+
+#define	bAlphaLeft0_Cr					200		// Derived from bIndexAleft0_Cr
+#define	bBetaLeft0_Cr					201		// Derived from bIndexBleft0_Cr
+#define	bAlphaTop0_Cr					202		// Derived from bIndexAtop0_Cr
+#define	bBetaTop0_Cr					203		// Derived from bIndexBtop0_Cr
+
+#define	bAlphaInternal_Cr				204		// Derived from bIndexAinternal_Cr
+#define	bBetaInternal_Cr				205		// Derived from bIndexBinternal_Cr
+// Offset 206 - 223 not used		
+
+// GRF7
+#define	bAlphaLeft1_Cb					224		// Derived from bIndexAleft1_Cb	Used in Mbaff mode only
+#define	bBetaLeft1_Cb					225		// Derived from bIndexBleft1_Cb	Used in Mbaff mode only
+#define	bAlphaTop1_Cb					226		// Derived from bIndexAtop1_Cb	Used in Mbaff mode only
+#define	bBetaTop1_Cb					227		// Derived from bIndexBtop1_Cb	Used in Mbaff mode only
+
+// Offset 228 - 231 not used
+
+#define	bTc0_v00_1_Cb					232		// Derived from bSv00_1 and bIndexAleft1_Cb	Used in Mbaff mode only
+#define	bTc0_v10_1_Cb					233		// Derived from bSv10_1 and bIndexAleft1_Cb	Used in Mbaff mode only
+#define	bTc0_v20_1_Cb					234		// Derived from bSv20_1 and bIndexAleft1_Cb	Used in Mbaff mode only
+#define	bTc0_v30_1_Cb					235		// Derived from bSv30_1 and bIndexAleft1_Cb	Used in Mbaff mode only
+
+#define	bTc0_h00_1_Cb					236		// Derived from bSh00_1 and bIndexAleft1_Cb	Used in Mbaff mode only
+#define	bTc0_h01_1_Cb					237		// 	Derived from bSh01_1 and bIndexAleft1_Cb	Used in Mbaff mode only
+#define	bTc0_h02_1_Cb					238		// Derived from bSh02_1 and bIndexAleft1_Cb	Used in Mbaff mode only
+#define	bTc0_h03_1_Cb					239		// Derived from bSh03_1 and bIndexAleft1_Cb	Used in Mbaff mode only
+
+#define	bAlphaLeft1_Cr					240		// Derived from bIndexAleft1_Cr	Used in Mbaff mode only
+#define	bBetaLeft1_Cr					241		// Derived from bIndexBleft1_Cr	Used in Mbaff mode only
+#define	bAlphaTop1_Cr					242		// Derived from bIndexAtop1_Cr	Used in Mbaff mode only
+#define	bBetaTop1_Cr					243		// Derived from bIndexBtop1_Cr	Used in Mbaff mode only
+
+// Offset 244 - 247 not used		
+
+#define	bTc0_v00_1_Cr					248		// Derived from bSv00_1 and bIndexAleft1_Cr	Used in Mbaff mode only
+#define	bTc0_v10_1_Cr					249		// Derived from bSv10_1 and bIndexAleft1_Cr	Used in Mbaff mode only
+#define	bTc0_v20_1_Cr					250		// Derived from bSv20_1 and bIndexAleft1_Cr	Used in Mbaff mode only
+#define	bTc0_v30_1_Cr					251		// Derived from bSv30_1 and bIndexAleft1_Cr	Used in Mbaff mode only
+
+#define	bTc0_h00_1_Cr					252		// Derived from bSh00_1 and bIndexAleft1_Cr	Used in Mbaff mode only
+#define	bTc0_h01_1_Cr					253		// Derived from bSh01_1 and bIndexAleft1_Cr	Used in Mbaff mode only
+#define	bTc0_h02_1_Cr					254		// Derived from bSh02_1 and bIndexAleft1_Cr	Used in Mbaff mode only
+#define	bTc0_h03_1_Cr					255		// Derived from bSh03_1 and bIndexAleft1_Cr	Used in Mbaff mode only
+
+
+#else		// _APPLE is defined
+
+//******** Crestline for Apple, progressive only, 88 bytes **********
+
+// GRF0
+#define HorizOrigin						0
+#define VertOrigin						1
+#define BitFlags						2		// Bit flags
+
+#define	wEdgeCntlMap_IntLeftVert		4		// Derived from bbSinternalLeftVert, 1 bit per pixel 
+#define	wEdgeCntlMap_IntMidVert			6		// Derived from bbSinternalLeftVert
+#define	wEdgeCntlMap_IntRightVert		8		// Derived from bbSinternalRightVert
+#define	wEdgeCntlMap_IntTopHorz			10		// Derived from bbSinternalTopHorz, 1bit per pixel 
+#define	wEdgeCntlMap_IntMidHorz			12		// Derived from bbSinternalMidHorz
+#define	wEdgeCntlMap_IntBotHorz			14		// Derived from bbSinternalBotHorz
+#define	wEdgeCntlMapA_ExtLeftVert0		16		// Derived from wbSLeft0, 1bit per pixel
+#define	wEdgeCntlMapB_ExtLeftVert0		18		// Derived from wbSLeft0
+#define	wEdgeCntlMapA_ExtTopHorz0		20		// Derived from wbSTop0, 1bit per pixel
+#define	wEdgeCntlMapB_ExtTopHorz0		22		// Derived from wbSTop0
+
+#define	bAlphaLeft0_Y					24		// Derived from bIndexAleft0_Y	
+#define	bBetaLeft0_Y					25		// Derived from bIndexBleft0_Y	
+#define	bAlphaTop0_Y					26		// Derived from bIndexAtop0_Y	
+#define	bBetaTop0_Y						27		// Derived from bIndexBtop0_Y	
+#define	bAlphaInternal_Y				28		// Derived from bIndexAinternal_Y	
+#define	bBetaInternal_Y					29		// Derived from bIndexBinternal_Y	
+
+// GRF1
+#define	bTc0_v00_0_Y					32		// Derived from bSv00_0 and bIndexAleft0_Y, 4 pixels per tc0
+#define	bTc0_v10_0_Y					33		// Derived from bSv10_0 and bIndexAleft0_Y
+#define	bTc0_v20_0_Y					34		// Derived from bSv20_0 and bIndexAleft0_Y
+#define	bTc0_v30_0_Y					35		// Derived from bSv30_0 and bIndexAleft0_Y
+#define	bTc0_v01_Y						36		// Derived from bSv01 and bIndexAinternal_Y
+#define	bTc0_v11_Y						37		// Derived from bSv11 and bIndexAinternal_Y
+#define	bTc0_v21_Y						38		// Derived from bSv21 and bIndexAinternal_Y
+#define	bTc0_v31_Y						39		// Derived from bSv31 and bIndexAinternal_Y
+#define	bTc0_v02_Y						40		// Derived from bSv02 and bIndexAinternal_Y
+#define	bTc0_v12_Y						41		// Derived from bSv12 and bIndexAinternal_Y
+#define	bTc0_v22_Y						42		// Derived from bSv22 and bIndexAinternal_Y
+#define	bTc0_v32_Y						43		// Derived from bSv32 and bIndexAinternal_Y
+#define	bTc0_v03_Y						44		// Derived from bSv03 and bIndexAinternal_Y
+#define	bTc0_v13_Y						45		// Derived from bSv13 and bIndexAinternal_Y
+#define	bTc0_v23_Y						46		// Derived from bSv23 and bIndexAinternal_Y
+#define	bTc0_v33_Y						47		// Derived from bSv33 and bIndexAinternal_Y
+
+#define	bTc0_h00_0_Y					48		// Derived from bSh00_0 and bIndexAleft0_Y
+#define	bTc0_h01_0_Y					49		// Derived from bSh01_0 and bIndexAleft0_Y
+#define	bTc0_h02_0_Y					50		// Derived from bSh02_0 and bIndexAleft0_Y
+#define	bTc0_h03_0_Y					51		// Derived from bSh03_0 and bIndexAleft0_Y
+#define	bTc0_h10_Y						52		// Derived from bSh10 and bIndexAinternal_Y
+#define	bTc0_h11_Y						53		// Derived from bSh11 and bIndexAinternal_Y
+#define	bTc0_h12_Y						54		// Derived from bSh12 and bIndexAinternal_Y
+#define	bTc0_h13_Y						55		// Derived from bSh13 and bIndexAinternal_Y
+#define	bTc0_h20_Y						56		// Derived from bSh20 and bIndexAinternal_Y
+#define	bTc0_h21_Y						57		// Derived from bSh21 and bIndexAinternal_Y
+#define	bTc0_h22_Y						58		// Derived from bSh22 and bIndexAinternal_Y
+#define	bTc0_h23_Y						59		// Derived from bSh23 and bIndexAinternal_Y
+#define	bTc0_h30_Y						60		// Derived from bSh30 and bIndexAinternal_Y
+#define	bTc0_h31_Y						61		// Derived from bSh31 and bIndexAinternal_Y
+#define	bTc0_h32_Y						62		// Derived from bSh32 and bIndexAinternal_Y
+#define	bTc0_h33_Y						63		// Derived from bSh33 and bIndexAinternal_Y
+
+// GRF2, 
+#define	bTc0_v00_0_Cb					64		// Derived from bSv00_0 and bIndexAleft0_Cb, 2 pixels per tc0	Left0
+#define	bTc0_v10_0_Cb					65		// Derived from bSv10_0 and bIndexAleft0_Cb	
+#define	bTc0_v20_0_Cb					66		// Derived from bSv20_0 and bIndexAleft0_Cb	
+#define	bTc0_v30_0_Cb					67		// Derived from bSv30_0 and bIndexAleft0_Cb	
+#define	bTc0_v02_Cb						68		// Derived from bSv02 and bIndexAinternal_Cb	MidVert
+#define	bTc0_v12_Cb						69		// Derived from bSv12 and bIndexAinternal_Cb	
+#define	bTc0_v22_Cb						70		// Derived from bSv22 and bIndexAinternal_Cb	
+#define	bTc0_v32_Cb						71		// Derived from bSv32 and bIndexAinternal_Cb	
+#define	bTc0_h00_0_Cb					72		// Derived from bSh00_0 and bIndexAleft0_Cb	Top0
+#define	bTc0_h01_0_Cb					73		// Derived from bSh01_0 and bIndexAleft0_Cb	
+#define	bTc0_h02_0_Cb					74		// Derived from bSh02_0 and bIndexAleft0_Cb	
+#define	bTc0_h03_0_Cb					75		// Derived from bSh03_0 and bIndexAleft0_Cb	
+#define	bTc0_h20_Cb						76		// Derived from bSh20 and bIndexAinternal_Cb	MidHorz
+#define	bTc0_h21_Cb						77		// Derived from bSh21 and bIndexAinternal_Cb	
+#define	bTc0_h22_Cb						78		// Derived from bSh22 and bIndexAinternal_Cb	
+#define	bTc0_h23_Cb						79		// Derived from bSh23 and bIndexAinternal_Cb	
+
+#define	bAlphaLeft0_Cb					80		// Derived from bIndexAleft0_Cb
+#define	bBetaLeft0_Cb					81		// Derived from bIndexBleft0_Cb
+#define	bAlphaTop0_Cb					82		// Derived from bIndexAtop0_Cb
+#define	bBetaTop0_Cb					83		// Derived from bIndexBtop0_Cb
+#define	bAlphaInternal_Cb				84		// Derived from bIndexAinternal_Cb
+#define	bBetaInternal_Cb				85		// Derived from bIndexBinternal_Cb
+
+#define	ExtBitFlags						86		// Extended bit flags, such as disable ILDB bits
+
+// Shared between Cb and Cr
+#define	bTc0_v00_0_Cr			bTc0_v00_0_Cb	
+#define	bTc0_v10_0_Cr		    bTc0_v10_0_Cb	
+#define	bTc0_v20_0_Cr		    bTc0_v20_0_Cb	
+#define	bTc0_v30_0_Cr		    bTc0_v30_0_Cb	
+#define	bTc0_v02_Cr			    bTc0_v02_Cb		
+#define	bTc0_v12_Cr			    bTc0_v12_Cb		
+#define	bTc0_v22_Cr			    bTc0_v22_Cb		
+#define	bTc0_v32_Cr			    bTc0_v32_Cb		
+#define	bTc0_h00_0_Cr		    bTc0_h00_0_Cb	
+#define	bTc0_h01_0_Cr		    bTc0_h01_0_Cb	
+#define	bTc0_h02_0_Cr		    bTc0_h02_0_Cb	
+#define	bTc0_h03_0_Cr		    bTc0_h03_0_Cb	
+#define	bTc0_h20_Cr			    bTc0_h20_Cb		
+#define	bTc0_h21_Cr			    bTc0_h21_Cb		
+#define	bTc0_h22_Cr			    bTc0_h22_Cb		
+#define	bTc0_h23_Cr			    bTc0_h23_Cb		
+                                
+#define	bAlphaLeft0_Cr		    bAlphaLeft0_Cb		   
+#define	bBetaLeft0_Cr		    bBetaLeft0_Cb		   
+#define	bAlphaTop0_Cr		    bAlphaTop0_Cb		   
+#define	bBetaTop0_Cr		    bBetaTop0_Cb		   
+#define	bAlphaInternal_Cr	    bAlphaInternal_Cb	   
+#define	bBetaInternal_Cr	    bBetaInternal_Cb	   
+
+
+#endif
+
+
+//========== End of Child Variables ===============================================================
+
+#if !defined(COMBINED_KERNEL)
+#define ILDB_LABEL(x)	x		// No symbol extension for standalone kernels
+#endif
+
+#endif	// !defined(__AVC_ILDB_HEADER__)
diff --git a/i965_drv_video/shaders/h264/ildb/AVC_ILDB_Child_Field_UV.asm b/i965_drv_video/shaders/h264/ildb/AVC_ILDB_Child_Field_UV.asm
new file mode 100644
index 0000000..b0986b5
--- /dev/null
+++ b/i965_drv_video/shaders/h264/ildb/AVC_ILDB_Child_Field_UV.asm
@@ -0,0 +1,9 @@
+/*
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+#include "AVC_ILDB_Child_UV.asm"
diff --git a/i965_drv_video/shaders/h264/ildb/AVC_ILDB_Child_Field_Y.asm b/i965_drv_video/shaders/h264/ildb/AVC_ILDB_Child_Field_Y.asm
new file mode 100644
index 0000000..fafd6c0
--- /dev/null
+++ b/i965_drv_video/shaders/h264/ildb/AVC_ILDB_Child_Field_Y.asm
@@ -0,0 +1,9 @@
+/*
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+#include "AVC_ILDB_Child_Y.asm"
diff --git a/i965_drv_video/shaders/h264/ildb/AVC_ILDB_Child_Mbaff_UV.asm b/i965_drv_video/shaders/h264/ildb/AVC_ILDB_Child_Mbaff_UV.asm
new file mode 100644
index 0000000..64dd802
--- /dev/null
+++ b/i965_drv_video/shaders/h264/ildb/AVC_ILDB_Child_Mbaff_UV.asm
@@ -0,0 +1,173 @@
+/*
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+//////////////////////////////////////////////////////////////////////////////////////////////////////////////
+// AVC Child Kernel (Vertical and horizontal de-block a 4:2:0 MB UV comp)
+//
+// First de-block vertical edges from left to right.
+// Second de-block horizontal edge from top to bottom.
+// 
+// For 4:2:0, chroma is always de-blocked at 8x8.
+// NV12 format allows to filter U and V together.
+//
+//////////////////////////////////////////////////////////////////////////////////////////////////////////////
+#define AVC_ILDB
+
+.kernel AVC_ILDB_CHILD_MBAFF_UV
+#if defined(COMBINED_KERNEL)
+ILDB_LABEL(AVC_ILDB_CHILD_UV):
+#endif
+
+#include "setupVPKernel.asm"
+#include "AVC_ILDB.inc"
+
+#if defined(_DEBUG) 
+	mov		(1)		EntrySignatureC:w			0xE997:w
+#endif
+
+	// Setup temp buf used by load and save code
+	#define BUF_B		RTempB
+	#define BUF_W		RTempW
+	#define BUF_D		RTempD
+
+	// Init local variables
+	mul (4)		ORIX_CUR<2>:w		ORIX<0;1,0>:w		16:w	{ NoDDClr }		// Expand X addr to bytes, repeat 4 times
+	mul (4)		ORIY_CUR<2>:w		ORIY<0;1,0>:w		32:w	{ NoDDChk }		// Expand Y addr to bytes, repeat 4 times
+
+	mov (2)		f0.0<1>:w		0:w
+
+	mov	(1)		GateWayOffsetC:uw	ORIY:uw						// Use row # as Gateway offset
+
+	//=== Null Kernel ===============================================================
+//	jmpi ILDB_LABEL(POST_ILDB_UV)
+	//===============================================================================
+
+	//====================================================================================
+	// Assuming the MB control data is laid out in scan line order in a rectangle with width = 16 bytes.
+	// Control data has dimension of X x Y = 16 x N bytes, where N = W x H / 16
+	// Each MB has 256 bytes of control data
+
+	// For CRESTLINE, 256 bytes are stored in memory and fetched into GRF.
+	// MB_offset = MBsCntX * CurRow + CurCol
+	// Byte_offset = MB_offset * (256 << Mbaff_flag),	Mbaff_flag = 0 or 1.
+	// Base address of a control data block = (x, y) = (0, y'=y/x), region width is 16 bytes
+	// where y' = Byte_offset / 16 = MB_offset * (16 << Mbaff_flag)
+	// MBCntrlDataOffsetY holds y'.
+
+	// For BearLake-C, 64 bytes are stored in memory and dataport expands to 256 bytes.  Need to use a special read command on BL-C.
+	// MB_offset = MBsCntX * CurRow + CurCol
+	// Byte_offset = MB_offset * (64 << Mbaff_flag),	Mbaff_flag = 0 or 1.
+	// MBCntrlDataOffsetY holds globel byte offset.
+	
+#if !defined(DEV_CL)
+	mul (1) CntrlDataOffsetY:ud		MBsCntX:w 				ORIY:w
+	add (1) CntrlDataOffsetY:ud		CntrlDataOffsetY:ud		ORIX:w
+	mul (1) CntrlDataOffsetY:ud		CntrlDataOffsetY:ud		128:uw
+#endif
+	//====================================================================================
+
+	add (1)		ORIX_LEFT:w			ORIX_LEFT:w			-4:w
+	add (1)		ORIY_TOP:w			ORIY_TOP:w			-4:w
+
+	//=========== Process Top MB ============
+    and (1)  	BitFields:w  		BitFields:w		TopFieldFlag:w		// Reset BotFieldFlag
+
+	// Build a ramp from 0 to 15
+	mov	(16)	RRampW(0)<1>		RampConstC<0;8,1>:ub
+	add (8)		RRampW(0,8)<1>		RRampW(0,8)			8:w				// RRampW = ramp 15-0
+
+ILDB_LABEL(RE_ENTRY_UV):	// for bootom field
+
+	// Load current MB control data
+#if defined(DEV_CL)
+	#include "load_ILDB_Cntrl_Data_64DW.asm"	// Crestline
+#else
+	#include "load_ILDB_Cntrl_Data_16DW.asm"	// Cantiga and beyond
+#endif
+
+	// Init addr register for vertical control data
+	mov (1)		ECM_AddrReg<1>:w		CNTRL_DATA_BASE:w		// Init ECM_AddrReg
+
+	// Use free cycles here
+	// Check loaded control data
+	and.z.f0.1  (16) null<1>:uw	r[ECM_AddrReg, wEdgeCntlMap_IntLeftVert]<16;16,1>:uw	0xFFFF:uw		// Skip ILDB?		
+	and.nz.f0.0  (1) null:w		r[ECM_AddrReg, ExtBitFlags]:ub		DISABLE_ILDB_FLAG:w		// Skip ILDB?
+
+	// Set DualFieldMode for all data read, write and deblocking
+	and	(1)	CTemp1_W:uw		r[ECM_AddrReg, BitFlags]:ub		FieldModeAboveMbFlag+FieldModeCurrentMbFlag:uw
+
+	// Get Vert Edge Pattern (frame vs. field MBs)
+	and	(1)	VertEdgePattern:uw		r[ECM_AddrReg, BitFlags]:ub		FieldModeLeftMbFlag+FieldModeCurrentMbFlag:uw
+
+	(f0.1.all16h)	jmpi 	ILDB_LABEL(SKIP_ILDB_UV)						// Skip ILDB
+	(f0.0)			jmpi 	ILDB_LABEL(SKIP_ILDB_UV)						// Skip ILDB
+
+	// Set DualFieldMode for all data read, write and deblocking
+//	and	(1)	CTemp1_W:uw		r[ECM_AddrReg, BitFlags]:ub		FieldModeAboveMbFlag+FieldModeCurrentMbFlag:uw
+	cmp.z.f0.0	(1)	null:w	CTemp1_W:uw		ABOVE_FIELD_CUR_FRAME:w
+	and (1)		DualFieldMode:w		f0.0:w		0x0001:w
+
+	#include "load_Cur_UV_8x8T_Mbaff.asm"		// Load transposed data 8x8
+	#include "load_Left_UV_2x8T_Mbaff.asm"				// Load left MB (2x8) UV data from memory if exists
+
+	#include "Transpose_Cur_UV_8x8.asm"
+	#include "Transpose_Left_UV_2x8.asm"
+	
+
+	//---------- Perform vertical ILDB filting on UV ----------
+	#include "AVC_ILDB_Filter_Mbaff_UV_v.asm"	
+	//---------------------------------------------------------
+
+	#include "save_Left_UV_8x2T_Mbaff.asm"				// Write left MB (2x8) Y data to memory if exists
+	#include "load_Top_UV_8x2_Mbaff.asm"				// Load top MB (8x2) Y data from memory if exists
+
+	#include "Transpose_Cur_UV_8x8.asm"					// Transpose a MB for horizontal edge de-blocking 
+
+	//---------- Perform horizontal ILDB filting on UV ----------
+	#include "AVC_ILDB_Filter_Mbaff_UV_h.asm"	
+	//-----------------------------------------------------------
+
+	#include "save_Cur_UV_8x8_Mbaff.asm"				// Write 8x8
+	#include "save_Top_UV_8x2_Mbaff.asm"				// Write top MB (8x2) if not the top row
+
+	//-----------------------------------------------------------
+ILDB_LABEL(SKIP_ILDB_UV):
+	
+	and.z.f0.0 (1) 	null:w		BitFields:w		BotFieldFlag:w
+
+	//=========== Process Bottom MB ============
+    or (1)  	BitFields:w  	BitFields:w		BotFieldFlag:w	// Set BotFieldFlag to 1
+	(f0.0) jmpi		ILDB_LABEL(RE_ENTRY_UV)							// Loop back for bottom deblocking
+
+	// Fall through to finish
+
+	//=========== Check write commit of the last write ============
+    mov (8)	WritebackResponse(0)<1>		WritebackResponse(0)	
+
+ILDB_LABEL(POST_ILDB_UV):	
+	
+	// Send notification thru Gateway to root thread, update chroma Status[CurRow]
+	#include "AVC_ILDB_ForwardMsg.asm"
+
+#if !defined(GW_DCN)		// For non-ILK chipsets
+	//child send EOT : Request type = 1
+	END_CHILD_THREAD
+#endif	// !defined(DEV_ILK)
+	
+	// The thread finishs here
+	//------------------------------------------------------------------------------
+	
+	////////////////////////////////////////////////////////////////////////////////
+	// Include other subrutines being called
+	#include "AVC_ILDB_Chroma_Core_Mbaff.asm"
+	
+#if !defined(COMBINED_KERNEL)		// For standalone kernel only
+.end_code
+
+.end_kernel
+#endif
diff --git a/i965_drv_video/shaders/h264/ildb/AVC_ILDB_Child_Mbaff_Y.asm b/i965_drv_video/shaders/h264/ildb/AVC_ILDB_Child_Mbaff_Y.asm
new file mode 100644
index 0000000..b4b1937
--- /dev/null
+++ b/i965_drv_video/shaders/h264/ildb/AVC_ILDB_Child_Mbaff_Y.asm
@@ -0,0 +1,188 @@
+/*
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+//////////////////////////////////////////////////////////////////////////////////////////////////////////////
+// AVC Child Kernel (Vertical and horizontal de-block a 4:2:0 MB Y comp)
+//
+// First, de-block vertical edges from left to right.
+// Second, de-block horizontal edge from top to bottom.
+// 
+//	***** MBAFF Mode *****
+//	This version deblocks top MB first, followed by bottom MB.
+//
+//	Need variable CurMB	to indicate top MB or bottom MB (CurMB = 0 or 1).  
+//	We can use BotFieldFlag in BitFields to represent it.
+//
+//  Usage:
+// 	1) Access control data for top 
+//		CntrlDataOffsetY + CurMB  * Control data block size		(64 DWs for CL, 16 DWs for BLC)
+//
+// 	2) Load frame/field video data based on flags: FieldModeCurrentMbFlag, FieldModeLeftMbFlag, FieldModeaboveMbFlag, 
+//
+//	E.g. 
+//	if (pCntlData->BitField & FieldModeCurrentMbFlag)
+//		cur_y = ORIX_CUR.y + CurMB * 1;				// Add field vertical offset for bot field MB .
+//	else
+//		cur_y = ORIX_CUR.y + CurMB * MB_Rows_Y;		// Add bottom MB vertical offset for bot MB
+//
+//
+//////////////////////////////////////////////////////////////////////////////////////////////////////////////
+#define AVC_ILDB
+
+.kernel AVC_ILDB_CHILD_MBAFF_Y
+#if defined(COMBINED_KERNEL)
+ILDB_LABEL(AVC_ILDB_CHILD_Y):
+#endif
+
+#include "setupVPKernel.asm"
+#include "AVC_ILDB.inc"
+
+#if defined(_DEBUG) 
+	mov		(1)		EntrySignatureC:w			0xE998:w
+#endif
+
+	// Setup temp buf used by load and save code
+	#define BUF_B		RTempB				
+	#define BUF_D		RTempD
+	
+	// Init local variables
+	// These coordinates are in progressive fashion
+	mul (4)		ORIX_CUR<2>:w		ORIX<0;1,0>:w		16:w	{ NoDDClr }		// Expand X addr to bytes, repeat 4 times
+	mul (4)		ORIY_CUR<2>:w		ORIY<0;1,0>:w		32:w	{ NoDDChk }		// Expand Y addr to bytes, repeat 4 times
+
+	mov (2)		f0.0<1>:w		0:w
+	
+	mov	(1)		GateWayOffsetC:uw	ORIY:uw						// Use row # as Gateway offset
+
+	//=== Null Kernel ===============================================================
+//	jmpi POST_ILDB
+	//===============================================================================
+
+	//====================================================================================
+	// Assuming the MB control data is laid out in scan line order in a rectangle with width = 16 bytes.
+	// Control data has dimension of X x Y = 16 x N bytes, where N = W x H / 16
+	// Each MB has 256 bytes of control data
+
+	// For CRESTLINE, 256 bytes are stored in memory and fetched into GRF.
+	// MB_offset = MBsCntX * CurRow + CurCol
+	// Byte_offset = MB_offset * (256 << Mbaff_flag),	Mbaff_flag = 0 or 1.
+	// Base address of a control data block = (x, y) = (0, y'=y/x), region width is 16 bytes
+	// where y' = Byte_offset / 16 = MB_offset * (16 << Mbaff_flag)
+	// MBCntrlDataOffsetY holds y'.
+
+	// For BearLake-C, 64 bytes are stored in memory and dataport expands to 256 bytes.  Need to use a special read command on BL-C.
+	// MB_offset = MBsCntX * CurRow + CurCol
+	// Byte_offset = MB_offset * (64 << Mbaff_flag),	Mbaff_flag = 0 or 1.
+	// MBCntrlDataOffsetY holds globel byte offset.
+
+#if !defined(DEV_CL)	
+	mul (1) CntrlDataOffsetY:ud		MBsCntX:w 				ORIY:w
+	add (1) CntrlDataOffsetY:ud		CntrlDataOffsetY:ud		ORIX:w
+	mul (1) CntrlDataOffsetY:ud		CntrlDataOffsetY:ud		128:uw
+#endif
+
+	//====================================================================================
+	
+	add (1)		ORIX_LEFT:w			ORIX_LEFT:w			-4:w
+	add (1)		ORIY_TOP:w			ORIY_TOP:w			-4:w
+
+
+	//=========== Process Top MB ============
+    and (1)  	BitFields:w  		BitFields:w		TopFieldFlag:w	// Reset BotFieldFlag
+
+RE_ENTRY:	// for bootom field
+
+	// Load current MB control data
+#if defined(DEV_CL)
+	#include "load_ILDB_Cntrl_Data_64DW.asm"	// Crestline
+#else
+	#include "load_ILDB_Cntrl_Data_16DW.asm"	// Cantiga and beyond
+#endif
+
+	// Init addr register for vertical control data
+	mov (1)		ECM_AddrReg<1>:w	CNTRL_DATA_BASE:w			// Init edge control map AddrReg
+
+	// Check loaded control data
+	and.z.f0.1  (16) null<1>:uw	r[ECM_AddrReg, wEdgeCntlMap_IntLeftVert]<16;16,1>:uw	0xFFFF:uw		// Skip ILDB?		
+	and.nz.f0.0  (1) null:w		r[ECM_AddrReg, ExtBitFlags]:ub		DISABLE_ILDB_FLAG:w		// Skip ILDB?
+
+	// Use free cycles here
+	// Set DualFieldMode for all data read, write and deblocking
+	and	(1)	CTemp1_W:uw		r[ECM_AddrReg, BitFlags]:ub		FieldModeAboveMbFlag+FieldModeCurrentMbFlag:uw
+
+	// Get Vert Edge Pattern (frame vs. field MBs)
+	and	(1)	VertEdgePattern:uw		r[ECM_AddrReg, BitFlags]:ub		FieldModeLeftMbFlag+FieldModeCurrentMbFlag:uw
+
+	(f0.1.all16h)	jmpi 	SKIP_ILDB						// Skip ILDB
+	(f0.0)			jmpi 	SKIP_ILDB						// Skip ILDB
+
+	// Set DualFieldMode for all data read, write and deblocking
+//	and	(1)	CTemp1_W:uw		r[ECM_AddrReg, BitFlags]:ub		FieldModeAboveMbFlag+FieldModeCurrentMbFlag:uw
+	cmp.z.f0.0	(1)	null:w	CTemp1_W:uw		ABOVE_FIELD_CUR_FRAME:w
+	and (1)		DualFieldMode:w		f0.0:w		0x0001:w
+
+	// Load current MB 				// DDD1
+	#include "load_Cur_Y_16x16T_Mbaff.asm"				// Load cur Y, 16x16, transpose
+	#include "load_Left_Y_4x16T_Mbaff.asm"				// Load left MB (4x16) Y data from memory if exists
+
+	#include "Transpose_Cur_Y_16x16.asm"
+	#include "Transpose_Left_Y_4x16.asm"
+
+	//---------- Perform vertical ILDB filting on Y----------
+	#include "AVC_ILDB_Filter_Mbaff_Y_v.asm"	
+	//-------------------------------------------------------
+
+	#include "save_Left_Y_16x4T_Mbaff.asm"				// Write left MB (4x16) Y data to memory if exists
+	#include "load_Top_Y_16x4_Mbaff.asm"				// Load top MB (16x4) Y data from memory if exists
+	#include "Transpose_Cur_Y_16x16.asm"				// Transpose a MB for horizontal edge de-blocking 
+
+	//---------- Perform horizontal ILDB filting on Y ----------
+	#include "AVC_ILDB_Filter_Mbaff_Y_h.asm"	
+	//----------------------------------------------------------
+
+	#include "save_Cur_Y_16x16_Mbaff.asm"					// Write cur MB (16x16)
+	#include "save_Top_Y_16x4_Mbaff.asm"					// Write top MB (16x4) if not the top row
+
+SKIP_ILDB:
+	//----------------------------------------------------------
+	and.z.f0.0 (1) 	null:w		BitFields:w		BotFieldFlag:w
+
+	//=========== Process Bottom MB ============
+    or (1)  	BitFields:w  	BitFields:w		BotFieldFlag:w	// Set BotFieldFlag to 1
+	(f0.0) jmpi		RE_ENTRY								// Loop back for bottom deblocking
+
+	// Fall through to finish
+
+	//=========== Check write commit of the last write ============
+    mov (8)	WritebackResponse(0)<1>		WritebackResponse(0)	
+
+POST_ILDB:
+	
+	//---------------------------------------------------------------------------
+	// Send notification thru Gateway to root thread, update luma Status[CurRow]
+	
+	#include "AVC_ILDB_ForwardMsg.asm"	
+
+#if !defined(GW_DCN)		// For non-ILK chipsets
+	//child send EOT : Request type = 1
+	END_CHILD_THREAD
+#endif	// !defined(DEV_ILK)
+	
+	// The thread finishs here
+	//------------------------------------------------------------------------------
+	
+	
+	////////////////////////////////////////////////////////////////////////////////
+	// Include other subrutines being called
+	#include "AVC_ILDB_Luma_Core_Mbaff.asm"
+
+#if !defined(COMBINED_KERNEL)		// For standalone kernel only
+.end_code
+
+.end_kernel
+#endif
diff --git a/i965_drv_video/shaders/h264/ildb/AVC_ILDB_Child_UV.asm b/i965_drv_video/shaders/h264/ildb/AVC_ILDB_Child_UV.asm
new file mode 100644
index 0000000..df40ad4
--- /dev/null
+++ b/i965_drv_video/shaders/h264/ildb/AVC_ILDB_Child_UV.asm
@@ -0,0 +1,186 @@
+/*
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+//////////////////////////////////////////////////////////////////////////////////////////////////////////////
+// AVC Child Kernel (Vertical and horizontal de-block a 4:2:0 MB UV comp)
+//
+// First de-block vertical edges from left to right.
+// Second de-block horizontal edge from top to bottom.
+// 
+// For 4:2:0, chroma is always de-blocked at 8x8.
+// NV12 format allows to filter U and V together.
+//
+//////////////////////////////////////////////////////////////////////////////////////////////////////////////
+#define AVC_ILDB
+
+.kernel AVC_ILDB_CHILD_UV
+#if defined(COMBINED_KERNEL)
+ILDB_LABEL(AVC_ILDB_CHILD_UV):
+#endif
+
+#include "setupVPKernel.asm"
+#include "AVC_ILDB.inc"
+
+#if defined(_DEBUG) 
+	mov		(1)		EntrySignatureC:w			0x9997:w
+#endif
+
+	// Init local variables
+	shl (8)		ORIX_CUR<1>:w		ORIX<0;2,1>:w		4:w		// Expand addr to bytes, repeat (x,y) 4 times
+
+	// Init addr register for vertical control data
+	mov (1)		ECM_AddrReg<1>:w		CNTRL_DATA_BASE:w		// Init ECM_AddrReg
+
+	//=== Null Kernel ===============================================================
+//	jmpi ILDB_LABEL(POST_ILDB_UV_UV)
+	//===============================================================================
+
+#if defined(DEV_CL)	
+	mov	(1)		acc0.0:w		240:w	
+#else
+	//====================================================================================
+	// For BearLake-C, 64 bytes are stored in memory and dataport expands to 256 bytes.  Need to use a special read command on BL-C.
+	// MB_offset = MBsCntX * CurRow + CurCol
+	// MBCntrlDataOffsetY = globel_byte_offset = MB_offset * 64
+	mul (1) CntrlDataOffsetY:ud		MBsCntX:w 				ORIY:w
+	add (1) CntrlDataOffsetY:ud		CntrlDataOffsetY:ud		ORIX:w
+
+	// Assign to MSGSRC.2:ud for memory access
+	// mul (1) CntrlDataOffsetY:ud		CntrlDataOffsetY:ud		64:uw
+	mul (1) MSGSRC.2:ud		CntrlDataOffsetY:ud		64:uw
+		
+	mov	(1)		acc0.0:w		320:w	
+#endif
+	mac (1)		URBOffsetC:w	ORIY:w			4:w				// UV URB entries are right after Y entries		
+
+
+	// Init local variables
+//	shl (8)		ORIX_CUR<1>:w		ORIX<0;2,1>:w		4:w		// Expand addr to bytes, repeat (x,y) 4 times
+	add (1)		ORIX_LEFT:w			ORIX_LEFT:w			-4:w
+	add (1)		ORIY_TOP:w			ORIY_TOP:w			-4:w
+
+	// Build a ramp from 0 to 15
+	mov	(16)	RRampW(0)<1>		RampConstC<0;8,1>:ub
+	add (8)		RRampW(0,8)<1>		RRampW(0,8)			8:w		// RRampW = ramp 15-0
+
+	// Load current MB control data
+#if defined(DEV_CL)
+	#if defined(_APPLE)
+		#include "load_ILDB_Cntrl_Data_22DW.asm"	// Crestline for Apple, progressive only
+	#else
+		#include "load_ILDB_Cntrl_Data_64DW.asm"	// Crestline
+	#endif	
+#else
+	#include "load_ILDB_Cntrl_Data_16DW.asm"	// Cantiga and beyond
+#endif
+
+	// Check loaded control data
+	#if defined(_APPLE)
+		and.z.f0.1  (8) null<1>:uw	r[ECM_AddrReg, wEdgeCntlMap_IntLeftVert]<8;8,1>:uw		0xFFFF:uw		// Skip ILDB?
+		(f0.1) and.z.f0.1 (2) null<1>:uw	r[ECM_AddrReg, wEdgeCntlMapA_ExtTopHorz0]<2;2,1>:uw		0xFFFF:uw		// Skip ILDB?
+	#else
+		and.z.f0.1  (16) null<1>:uw	r[ECM_AddrReg, wEdgeCntlMap_IntLeftVert]<16;16,1>:uw	0xFFFF:uw		// Skip ILDB?		
+	#endif	
+		
+	and.nz.f0.0  (1) null:w		r[ECM_AddrReg, ExtBitFlags]:ub		DISABLE_ILDB_FLAG:w		// Skip ILDB?
+	
+	mov	(1)		GateWayOffsetC:uw	ORIY:uw		// Use row # as Gateway offset
+
+	#if defined(_APPLE)
+		(f0.1.all8h)	jmpi 	ILDB_LABEL(READ_FOR_URB_UV)				// Skip ILDB
+	#else
+		(f0.1.all16h)	jmpi 	ILDB_LABEL(READ_FOR_URB_UV)				// Skip ILDB
+	#endif	
+
+	(f0.0)			jmpi 	ILDB_LABEL(READ_FOR_URB_UV)					// Skip ILDB
+
+
+
+	#include "load_Cur_UV_8x8T.asm"				// Load transposed data 8x8
+//	#include "load_Left_UV_2x8T.asm"
+	#include "load_Top_UV_8x2.asm"				// Load top MB (8x2) Y data from memory if exists
+
+	#include "Transpose_Cur_UV_8x8.asm"
+//	#include "Transpose_Left_UV_2x8.asm"
+
+
+	//---------- Perform vertical ILDB filting on UV ----------
+	#include "AVC_ILDB_Filter_UV_v.asm"	
+	//---------------------------------------------------------
+
+	#include "save_Left_UV_8x2T.asm"			// Write left MB (2x8) Y data to memory if exists
+	#include "Transpose_Cur_UV_8x8.asm"			// Transpose a MB for horizontal edge de-blocking 
+
+	//---------- Perform horizontal ILDB filting on UV ----------
+	#include "AVC_ILDB_Filter_UV_h.asm"	
+	//-----------------------------------------------------------
+
+	#include "save_Cur_UV_8x8.asm"				// Write 8x8
+	#include "save_Top_UV_8x2.asm"				// Write top MB (8x2) if not the top row
+
+	//---------- Write right most 4 columns of cur MB to URB ----------
+	// Transpose the right most 2 cols 2x8 (word) in GRF to 8x2 in BUF_D.  It is 2 left most cols in cur MB.
+	#include "Transpose_Cur_UV_2x8.asm"						
+		
+ILDB_LABEL(WRITE_URB_UV):
+	mov (8)		m1<1>:ud		LEFT_TEMP_D(1)<8;8,1>			// Copy 1 GRF to 1 URB entry (U+V)
+	
+	#include "writeURB_UV_Child.asm"	
+	//-----------------------------------------------------------------
+
+	//=========== Check write commit of the last write ============
+    mov (8)	WritebackResponse(0)<1>		WritebackResponse(0)	
+
+ILDB_LABEL(POST_ILDB_UV):
+	//---------------------------------		
+	
+	// Send notification thru Gateway to root thread, update chroma Status[CurRow]
+	#include "AVC_ILDB_ForwardMsg.asm"
+
+#if !defined(GW_DCN)		// For non-ILK chipsets
+	//child send EOT : Request type = 1
+	END_CHILD_THREAD
+#endif	// !defined(DEV_ILK)
+	
+	// The thread finishs here
+	//------------------------------------------------------------------------------
+	
+ILDB_LABEL(READ_FOR_URB_UV):
+	// Still need to prepare URB data for the right neighbor MB
+	#include "load_Cur_UV_Right_Most_2x8.asm"		// Load cur MB ( right most 4x16) Y data from memory
+	#include "Transpose_Cur_UV_Right_Most_2x8.asm"						
+//	jmpi ILDB_LABEL(WRITE_URB_UV)
+
+	mov (8)		m1<1>:ud		LEFT_TEMP_D(1)<8;8,1>			// Copy 1 GRF to 1 URB entry (U+V)
+	
+	#include "writeURB_UV_Child.asm"	
+	//-----------------------------------------------------------------
+
+	// Send notification thru Gateway to root thread, update chroma Status[CurRow]
+	#include "AVC_ILDB_ForwardMsg.asm"
+
+#if !defined(GW_DCN)		// For non-ILK chipsets
+	//child send EOT : Request type = 1
+	END_CHILD_THREAD
+#endif	// !defined(DEV_ILK)
+	
+	// The thread finishs here
+	//------------------------------------------------------------------------------
+	
+	
+	////////////////////////////////////////////////////////////////////////////////
+	// Include other subrutines being called
+//	#include "AVC_ILDB_Luma_Core.asm"
+	#include "AVC_ILDB_Chroma_Core.asm"
+
+	
+#if !defined(COMBINED_KERNEL)		// For standalone kernel only
+.end_code
+
+.end_kernel
+#endif
diff --git a/i965_drv_video/shaders/h264/ildb/AVC_ILDB_Child_Y.asm b/i965_drv_video/shaders/h264/ildb/AVC_ILDB_Child_Y.asm
new file mode 100644
index 0000000..bef52d8
--- /dev/null
+++ b/i965_drv_video/shaders/h264/ildb/AVC_ILDB_Child_Y.asm
@@ -0,0 +1,176 @@
+/*
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+//////////////////////////////////////////////////////////////////////////////////////////////////////////////
+// AVC Child Kernel (Vertical and horizontal de-block a 4:2:0 MB Y comp)
+//
+// First, de-block vertical edges from left to right.
+// Second, de-block horizontal edge from top to bottom.
+// 
+// If transform_size_8x8_flag = 1, luma is de-blocked at 8x8.  Otherwise, luma is de-blocked at 4x4.
+//
+//////////////////////////////////////////////////////////////////////////////////////////////////////////////
+#define AVC_ILDB
+
+.kernel AVC_ILDB_CHILD_Y
+#if defined(COMBINED_KERNEL)
+ILDB_LABEL(AVC_ILDB_CHILD_Y):
+#endif
+
+#include "setupVPKernel.asm"
+#include "AVC_ILDB.inc"
+
+#if defined(_DEBUG) 
+	mov		(1)		EntrySignatureC:w			0x9998:w
+#endif
+
+	// Init local variables
+	shl (8)		ORIX_CUR<1>:w		ORIX<0;2,1>:w		4:w		// Expand addr to bytes, repeat (x,y) 4 times
+
+	// Init addr register for vertical control data
+	mov (1)		ECM_AddrReg<1>:w	CNTRL_DATA_BASE:w			// Init edge control map AddrReg
+
+	//=== Null Kernel ===============================================================
+//	jmpi ILDB_LABEL(POST_ILDB_Y)
+	//===============================================================================
+
+	mul	(1)		URBOffsetC:uw	ORIY:uw		4:w	
+	
+#if !defined(DEV_CL)	
+	//====================================================================================
+	// For BearLake-C, 64 bytes are stored in memory and dataport expands to 256 bytes.  Need to use a special read command on BL-C.
+	// MB_offset = MBsCntX * CurRow + CurCol
+	// MBCntrlDataOffsetY = globel_byte_offset = MB_offset * 64
+	mul (1) CntrlDataOffsetY:ud		MBsCntX:w 				ORIY:w
+	add (1) CntrlDataOffsetY:ud		CntrlDataOffsetY:ud		ORIX:w
+		
+	// Assign to MSGSRC.2:ud for memory access
+	// mul (1) CntrlDataOffsetY:ud		CntrlDataOffsetY:ud		64:uw
+	mul (1) MSGSRC.2:ud		CntrlDataOffsetY:ud		64:uw		
+	
+#endif
+
+	// Load current MB control data
+#if defined(DEV_CL) 
+	#if defined(_APPLE)
+		#include "load_ILDB_Cntrl_Data_22DW.asm"	// Crestline for Apple, progressive only
+	#else
+		#include "load_ILDB_Cntrl_Data_64DW.asm"	// Crestline
+	#endif	
+#else
+	#include "load_ILDB_Cntrl_Data_16DW.asm"	// Cantiga and beyond
+#endif
+
+	// Check loaded control data
+	#if defined(_APPLE)
+		and.z.f0.1  (8) null<1>:uw	r[ECM_AddrReg, wEdgeCntlMap_IntLeftVert]<8;8,1>:uw		0xFFFF:uw		// Skip ILDB?
+		(f0.1) and.z.f0.1 (2) null<1>:uw	r[ECM_AddrReg, wEdgeCntlMapA_ExtTopHorz0]<2;2,1>:uw		0xFFFF:uw		// Skip ILDB?
+	#else
+		and.z.f0.1  (16) null<1>:uw	r[ECM_AddrReg, wEdgeCntlMap_IntLeftVert]<16;16,1>:uw	0xFFFF:uw		// Skip ILDB?		
+	#endif	
+
+	and.nz.f0.0  (1) null:w		r[ECM_AddrReg, ExtBitFlags]:ub		DISABLE_ILDB_FLAG:w		// Skip ILDB?
+
+	// Use free cycles here
+	add (1)		ORIX_LEFT:w			ORIX_LEFT:w			-4:w
+//	add (1)		ORIY_TOP:w			ORIY_TOP:w			-4:w
+	mov	(1)		GateWayOffsetC:uw	ORIY:uw						// Use row # as Gateway offset
+
+	#if defined(_APPLE)
+		(f0.1.all8h)	jmpi 	ILDB_LABEL(READ_FOR_URB_Y)				// Skip ILDB
+	#else
+		(f0.1.all16h)	jmpi 	ILDB_LABEL(READ_FOR_URB_Y)				// Skip ILDB
+	#endif
+
+	(f0.0)			jmpi 	ILDB_LABEL(READ_FOR_URB_Y)					// Skip ILDB
+
+	add (1)		ORIY_TOP:w			ORIY_TOP:w			-4:w
+
+	// Bettr performance is observed if boundary MBs are not checked and skipped.
+	
+	#include "load_Cur_Y_16x16T.asm"				// Load cur MB Y, 16x16, transpose
+//	#include "load_Left_Y_4x16T.asm"				// Load left MB (4x16) Y data from memory
+	#include "load_Top_Y_16x4.asm"					// Load top MB (16x4) Y data from memory
+
+	#include "Transpose_Cur_Y_16x16.asm"
+//	#include "Transpose_Left_Y_4x16.asm"
+
+	//---------- Perform vertical ILDB filting on Y ---------
+	#include "AVC_ILDB_Filter_Y_v.asm"	
+	//-------------------------------------------------------
+
+	#include "save_Left_Y_16x4T.asm"				// Write left MB (4x16) Y data to memory
+	#include "Transpose_Cur_Y_16x16.asm"			// Transpose a MB for horizontal edge de-blocking 
+
+	//---------- Perform horizontal ILDB filting on Y -------
+	#include "AVC_ILDB_Filter_Y_h.asm"	
+	//-------------------------------------------------------
+
+	#include "save_Cur_Y_16x16.asm"					// Write cur MB (16x16)
+	#include "save_Top_Y_16x4.asm"					// Write top MB (16x4)
+
+	//---------- Write right most 4 columns of cur MB to URB ----------
+	// Transpose the right most 4 cols 4x16 in GRF to 16x4 in LEFT_TEMP_B.  It is 4 left most cols in cur MB.	
+	#include "Transpose_Cur_Y_4x16.asm"						
+	
+ILDB_LABEL(WRITE_URB_Y):
+	// Note: LEFT_TEMP_B(2) = TOP_TEMP_B(0), TOP_TEMP_B must be avail
+	mov (16)	m1<1>:ud		LEFT_TEMP_D(2)<8;8,1>		// Copy 2 GRFs to 2 URB entries (Y)
+	
+	#include "writeURB_Y_Child.asm"	
+	//-----------------------------------------------------------------
+
+	//=========== Check write commit of the last write ============
+    mov (8)	WritebackResponse(0)<1>		WritebackResponse(0)	
+
+ILDB_LABEL(POST_ILDB_Y):
+	// Send notification thru Gateway to root thread, update luma Status[CurRow]
+	#include "AVC_ILDB_ForwardMsg.asm"	
+
+#if !defined(GW_DCN)		// For non-ILK chipsets
+	//child send EOT : Request type = 1
+	END_CHILD_THREAD
+#endif	// !defined(DEV_ILK)
+	
+	// The thread finishs here
+	//------------------------------------------------------------------------------
+
+ILDB_LABEL(READ_FOR_URB_Y):
+	// Still need to prepare URB data for the right neighbor MB
+	#include "load_Cur_Y_Right_Most_4x16.asm"		// Load cur MB ( right most 4x16) Y data from memory
+	#include "Transpose_Cur_Y_Right_Most_4x16.asm"						
+//	jmpi ILDB_LABEL(WRITE_URB_Y)
+
+	// Note: LEFT_TEMP_B(2) = TOP_TEMP_B(0), TOP_TEMP_B must be avail
+	mov (16)	m1<1>:ud		LEFT_TEMP_D(2)<8;8,1>		// Copy 2 GRFs to 2 URB entries (Y)
+	
+	#include "writeURB_Y_Child.asm"	
+	//-----------------------------------------------------------------
+
+	// Send notification thru Gateway to root thread, update luma Status[CurRow]
+	#include "AVC_ILDB_ForwardMsg.asm"	
+
+#if !defined(GW_DCN)		// For non-ILK chipsets
+	//child send EOT : Request type = 1
+	END_CHILD_THREAD
+#endif	// !defined(DEV_ILK)
+	
+	// The thread finishs here
+	//------------------------------------------------------------------------------
+	
+	////////////////////////////////////////////////////////////////////////////////
+	// Include other subrutines being called
+	#include "AVC_ILDB_Luma_Core.asm"
+//	#include "AVC_ILDB_Chroma_Core.asm"
+
+	
+#if !defined(COMBINED_KERNEL)		// For standalone kernel only
+.end_code
+
+.end_kernel
+#endif
diff --git a/i965_drv_video/shaders/h264/ildb/AVC_ILDB_Chroma_Core.asm b/i965_drv_video/shaders/h264/ildb/AVC_ILDB_Chroma_Core.asm
new file mode 100644
index 0000000..e33d022
--- /dev/null
+++ b/i965_drv_video/shaders/h264/ildb/AVC_ILDB_Chroma_Core.asm
@@ -0,0 +1,165 @@
+/*
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+#if !defined(__AVC_ILDB_CHROMA_CORE__)	// Make sure this file is only included once
+#define __AVC_ILDB_CHROMA_CORE__
+
+////////// AVC ILDB Chroma Core /////////////////////////////////////////////////////////////////////////////////
+//
+//	This core performs AVC U or V ILDB filtering on one horizontal edge (8 pixels) of a MB.
+//	If data is transposed, it can also de-block a vertical edge.
+//
+//	Bafore calling this subroutine, caller needs to set the following parameters.
+//
+//	- EdgeCntlMap1				//	Edge control map A
+//	- EdgeCntlMap2				//	Edge control map B
+//	- P_AddrReg					//	Src and dest address register for P pixels
+//	- Q_AddrReg					//	Src and dest address register for Q pixels 	
+//	- alpha						//  alpha corresponding to the edge to be filtered
+//	- beta						//  beta corresponding to the edge to be filtered
+//	- tc0						// 	tc0  corresponding to the edge to be filtered
+//
+//	U or V:
+//	+----+----+----+----+
+//	| P1 | p0 | q0 | q1 |
+//	+----+----+----+----+
+//
+//	p1 = r[P_AddrReg, 0]<16;8,2> 
+//	p0 = r[P_AddrReg, 16]<16;8,2> 
+// 	q0 = r[Q_AddrReg, 0]<16;8,2>  
+//	q1 = r[Q_AddrReg, 16]<16;8,2> 
+//
+/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+// The region is both src and dest
+// P0-P3 and Q0-Q3 should be only used if they have not been modified to new values  
+#undef 	P1
+#undef 	P0
+#undef 	Q0
+#undef 	Q1
+
+#define P1 		r[P_AddrReg,  0]<16;8,2>:ub
+#define P0 		r[P_AddrReg, 16]<16;8,2>:ub
+#define Q0 		r[Q_AddrReg,  0]<16;8,2>:ub
+#define Q1 		r[Q_AddrReg, 16]<16;8,2>:ub
+
+// New region as dest
+#undef 	NewP0
+#undef 	NewQ0
+
+#define NewP0 	r[P_AddrReg, 16]<2>:ub
+#define NewQ0 	r[Q_AddrReg,  0]<2>:ub
+
+// Filter one chroma edge 
+FILTER_UV:
+
+#if defined(_DEBUG) 
+	mov		(1)		EntrySignatureC:w			0x1112:w
+#endif
+	//---------- Derive filterSampleflag in AVC spec, equition (8-469) ----------
+	// bS is in MaskA
+
+	// Src copy of the p1, p0, q0, q1
+//	mov (8) p1(0)<1>		r[P_AddrReg, 0]<16;8,2>:ub
+//	mov (8) p0(0)<1>		r[P_AddrReg, 16]<16;8,2>:ub
+//	mov (8) q0(0)<1>		r[Q_AddrReg, 0]<16;8,2>:ub
+//	mov (8) q1(0)<1>		r[Q_AddrReg, 16]<16;8,2>:ub
+
+//	mov (1)	f0.0:uw		MaskA:uw
+
+	add (8) q0_p0(0)<1>			Q0		-P0				// q0-p0
+	add (8) TempRow0(0)<1>		P1		-P0				// p1-p0
+	add (8) TempRow1(0)<1>		Q1		-Q0				// q1-q0
+
+	// Build FilterSampleFlag
+	// abs(q0-p0) < alpha
+	(f0.0) cmp.l.f0.0 (16) null:w		(abs)q0_p0(0)			alpha:w
+	// abs(p1-p0) < Beta
+	(f0.0) cmp.l.f0.0 (16) null:w		(abs)TempRow0(0)		beta:w
+	// abs(q1-q0) < Beta
+	(f0.0) cmp.l.f0.0 (16) null:w		(abs)TempRow1(0)		beta:w
+
+	//-----------------------------------------------------------------------------------------
+
+	// if 
+    (f0.0)	if	(8)		UV_ENDIF1
+		// For channels whose edge control map1 = 1 ---> perform de-blocking
+
+//		mov (1)		f0.1:w		MaskB:w		{NoMask}		// Now check for which algorithm to apply
+
+		(f0.1)	if	(8)		UV_ELSE2
+
+			// For channels whose edge control map2 = 1 ---> bS = 4 algorithm 
+			// p0' = (2*p1 + p0 + q1 + 2) >> 2
+			// q0' = (2*q1 + q0 + p1 + 2) >> 2
+
+			// Optimized version:
+			// A = (p1 + q1 + 2)
+			// p0' = (p0 + p1 + A) >> 2
+			// q0' = (q0 + q1 + A) >> 2
+			//------------------------------------------------------------------------------------
+			
+			// p0' = (2*p1 + p0 + q1 + 2) >> 2
+			add (8) acc0<1>:w		Q1				2:w
+			mac (8) acc0<1>:w		P1				2:w
+			add (8)	acc0<1>:w		acc0<8;8,1>:w	P0
+			shr.sat	(8)	TempRow0B(0)<2>		acc0<8;8,1>:w		2:w
+			
+			// q0' = (2*q1 + q0 + p1 + 2) >> 2
+			add (8) acc0<1>:w		P1				2:w
+			mac (8) acc0<1>:w		Q1				2:w
+			add (8)	acc0<1>:w		acc0<8;8,1>:w	Q0
+			shr.sat	(8)	TempRow1B(0)<2>		acc0<8;8,1>:w		2:w
+
+			mov (8) NewP0		TempRow0B(0)					// p0'
+			mov (8) NewQ0		TempRow1B(0)					// q0'
+			
+			
+UV_ELSE2: 
+		else 	(8)		UV_ENDIF2
+			// For channels whose edge control map2 = 0 ---> bS < 4 algorithm
+			
+			// Expand tc0	(tc0 has 4 bytes)
+//			mov (8)	tc0_exp(0)<1>	tc0<1;2,0>:ub	{NoMask}				// tc0_exp = tc0, each tc0 is duplicated 2 times for 2 adjcent pixels	
+			mov (8)	acc0<1>:w	tc0<1;2,0>:ub	{NoMask}				// tc0_exp = tc0, each tc0 is duplicated 2 times for 2 adjcent pixels	
+			
+			// tc_exp = tc0_exp + 1
+//			add (8) tc_exp(0)<1>	tc0_exp(0)		1:w
+			add (8) tc_exp(0)<1>	acc0<8;8,1>:w		1:w
+
+			// delta = Clip3(-tc, tc, ((((q0 - p0)<<2) + (p1-q1) + 4) >> 3))
+			// 4 * (q0-p0) + p1 - q1 + 4
+			add (8)	acc0<1>:w		P1			4:w
+			mac (8) acc0<1>:w		q0_p0(0)	4:w	
+			add (8) acc0<1>:w		acc0<8;8,1>:w		-Q1
+			shr (8) TempRow0(0)<1>	acc0<8;8,1>:w		3:w
+
+			// tc clip
+			cmp.g.f0.0	(8) null:w		TempRow0(0)		tc_exp(0)				// Clip if > tc0
+			cmp.l.f0.1	(8) null:w		TempRow0(0)		-tc_exp(0)				// Clip if < -tc0
+			
+			(f0.0) mov (8) TempRow0(0)<1>				tc_exp(0)
+			(f0.1) mov (8) TempRow0(0)<1>				-tc_exp(0)
+			
+			// p0' = Clip1(p0 + delta) = Clip3(0, 0xFF, p0 + delta)
+			add.sat (8)	TempRow1B(0)<2>		P0			TempRow0(0)				// p0+delta
+		
+			// q0' = Clip1(q0 - delta) = Clip3(0, 0xFF, q0 - delta)
+			add.sat (8)	TempRow0B(0)<2>		Q0			-TempRow0(0)			// q0-delta
+
+			mov (8) NewP0				TempRow1B(0)			// p0'
+			mov (8) NewQ0				TempRow0B(0)			// q0'
+
+		endif
+UV_ENDIF2:
+UV_ENDIF1:
+	endif
+
+RETURN
+
+#endif	// !defined(__AVC_ILDB_CHROMA_CORE__)
diff --git a/i965_drv_video/shaders/h264/ildb/AVC_ILDB_Chroma_Core_Mbaff.asm b/i965_drv_video/shaders/h264/ildb/AVC_ILDB_Chroma_Core_Mbaff.asm
new file mode 100644
index 0000000..f567d95
--- /dev/null
+++ b/i965_drv_video/shaders/h264/ildb/AVC_ILDB_Chroma_Core_Mbaff.asm
@@ -0,0 +1,146 @@
+/*
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+////////// AVC ILDB Chroma Core Mbaff /////////////////////////////////////////////////////////////////////////////////
+//
+//	This core performs AVC U or V ILDB filtering on one horizontal edge (8 pixels) of a MB.
+//	If data is transposed, it can also de-block a vertical edge.
+//
+//	Bafore calling this subroutine, caller needs to set the following parameters.
+//
+//	- EdgeCntlMap1				//	Edge control map A
+//	- EdgeCntlMap2				//	Edge control map B
+//	- P_AddrReg					//	Src and dest address register for P pixels
+//	- Q_AddrReg					//	Src and dest address register for Q pixels 	
+//	- alpha						//  alpha corresponding to the edge to be filtered
+//	- beta						//  beta corresponding to the edge to be filtered
+//	- tc0						// 	tc0  corresponding to the edge to be filtered
+//
+//	U or V:
+//	+----+----+----+----+
+//	| P1 | p0 | q0 | q1 |
+//	+----+----+----+----+
+//
+//	p1 = r[P_AddrReg, 0]<16;8,2> 
+//	p0 = r[P_AddrReg, 16]<16;8,2> 
+// 	q0 = r[Q_AddrReg, 0]<16;8,2>  
+//	q1 = r[Q_AddrReg, 16]<16;8,2> 
+//
+/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+// The region is both src and dest
+// P0-P3 and Q0-Q3 should be only used if they have not been modified to new values  
+#undef 	P1
+#undef 	P0
+#undef 	Q0
+#undef 	Q1
+
+#define P1 		r[P_AddrReg,  0]<16;8,2>:ub
+#define P0 		r[P_AddrReg, 16]<16;8,2>:ub
+#define Q0 		r[Q_AddrReg,  0]<16;8,2>:ub
+#define Q1 		r[Q_AddrReg, 16]<16;8,2>:ub
+
+// New region as dest
+#undef 	NewP0
+#undef 	NewQ0
+
+#define NewP0 	r[P_AddrReg, 16]<2>:ub
+#define NewQ0 	r[Q_AddrReg,  0]<2>:ub
+
+// Filter one chroma edge - mbaff
+FILTER_UV_MBAFF:
+
+#if defined(_DEBUG) 
+	mov		(1)		EntrySignatureC:w			0x1112:w
+#endif
+	//---------- Derive filterSampleflag in AVC spec, equition (8-469) ----------
+
+	//===== Assume f0.0 contains MaskA when entering this routine
+//	mov (1)	f0.0:uw		MaskA:uw
+
+	add (8) q0_p0(0)<1>			Q0		-P0				// q0-p0
+	add (8) TempRow0(0)<1>		P1		-P0				// p1-p0
+	add (8) TempRow1(0)<1>		Q1		-Q0				// q1-q0
+
+	// Build FilterSampleFlag
+	// abs(q0-p0) < alpha
+	(f0.0) cmp.l.f0.0 (16) null:w		(abs)q0_p0(0)			Mbaff_ALPHA(0)
+	// abs(p1-p0) < Beta
+	(f0.0) cmp.l.f0.0 (16) null:w		(abs)TempRow0(0)		Mbaff_BETA(0)
+	// abs(q1-q0) < Beta
+	(f0.0) cmp.l.f0.0 (16) null:w		(abs)TempRow1(0)		Mbaff_BETA(0)
+
+	//-----------------------------------------------------------------------------------------
+
+	// if 
+    (f0.0)	if	(8)		MBAFF_UV_ENDIF1
+		// For channels whose edge control map1 = 1 ---> perform de-blocking
+
+//		mov (1)		f0.1:w		MaskB:w		{NoMask}		// Now check for which algorithm to apply
+
+		(f0.1)	if	(8)		MBAFF_UV_ELSE2
+
+			// For channels whose edge control map2 = 1 ---> bS = 4 algorithm 
+			// p0' = (2*p1 + P0 + q1 + 2) >> 2
+			// q0' = (2*q1 + q0 + p1 + 2) >> 2
+			//------------------------------------------------------------------------------------
+
+			// p0' = (2*p1 + p0 + q1 + 2) >> 2
+			add (8) acc0<1>:w		Q1				2:w
+			mac (8) acc0<1>:w		P1				2:w
+			add (8)	acc0<1>:w		acc0<8;8,1>:w	P0
+			shr.sat	(8)	TempRow0B(0)<2>		acc0<8;8,1>:w		2:w
+
+			// q0' = (2*q1 + q0 + p1 + 2) >> 2
+			add (8) acc0<1>:w		P1				2:w
+			mac (8) acc0<1>:w		Q1				2:w
+			add (8)	acc0<1>:w		acc0<8;8,1>:w	Q0
+			shr.sat	(8)	TempRow1B(0)<2>		acc0<8;8,1>:w		2:w
+
+			mov (8) NewP0		TempRow0B(0)					// p0'
+			mov (8) NewQ0		TempRow1B(0)					// q0'
+			
+MBAFF_UV_ELSE2: 
+		else 	(8)		MBAFF_UV_ENDIF2
+			// For channels whose edge control map2 = 0 ---> bS < 4 algorithm
+			
+			// tc_exp = tc0_exp + 1
+			add (8) tc_exp(0)<1>	Mbaff_TC0(0)		1:w
+
+			// delta = Clip3(-tc, tc, ((((q0 - p0)<<2) + (p1-q1) + 4) >> 3))
+			// 4 * (q0-p0) + p1 - q1 + 4
+			add (8)	acc0<1>:w		P1			4:w
+			mac (8) acc0<1>:w		q0_p0(0)	4:w	
+			add (8) acc0<1>:w		acc0<8;8,1>:w		-Q1
+			shr (8) TempRow0(0)<1>	acc0<8;8,1>:w		3:w
+
+			// tc clip
+			cmp.g.f0.0	(8) null:w		TempRow0(0)		tc_exp(0)				// Clip if > tc0
+			cmp.l.f0.1	(8) null:w		TempRow0(0)		-tc_exp(0)				// Clip if < -tc0
+			
+			(f0.0) mov (8) TempRow0(0)<1>				tc_exp(0)
+			(f0.1) mov (8) TempRow0(0)<1>				-tc_exp(0)
+			
+			// p0' = Clip1(p0 + delta) = Clip3(0, 0xFF, p0 + delta)
+			add.sat (8)	TempRow1B(0)<2>		P0			TempRow0(0)				// p0+delta
+		
+			// q0' = Clip1(q0 - delta) = Clip3(0, 0xFF, q0 - delta)
+			add.sat (8)	TempRow0B(0)<2>		Q0			-TempRow0(0)			// q0-delta
+
+			mov (8) NewP0				TempRow1B(0)			// p0'
+			mov (8) NewQ0				TempRow0B(0)			// q0'
+
+		endif
+MBAFF_UV_ENDIF2:
+MBAFF_UV_ENDIF1:
+	endif
+
+RETURN
+
+
+
diff --git a/i965_drv_video/shaders/h264/ildb/AVC_ILDB_CloseGateway.asm b/i965_drv_video/shaders/h264/ildb/AVC_ILDB_CloseGateway.asm
new file mode 100644
index 0000000..e522ce4
--- /dev/null
+++ b/i965_drv_video/shaders/h264/ildb/AVC_ILDB_CloseGateway.asm
@@ -0,0 +1,22 @@
+/*
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+//----- Close a Message Gateway -----
+
+#if defined(_DEBUG) 
+	mov		(1)		EntrySignature:b			0x4444:w
+#endif
+
+// Message descriptor
+// bit 31	EOD
+// 27:24	FFID = 0x0011 for msg gateway
+// 23:20	msg length = 1 MRF
+// 19:16	Response length	= 0
+// 1:0		SubFuncID = 01 for CloseGateway
+// Message descriptor: 0 000 0011 0001 0000 + 0 0 000000000000 01 ==> 0000 0011 0001 0000 0000 0000 0000 0001
+send (8)	null:ud 	m7	  r0.0:ud    MSG_GW	CGWMSGDSC
diff --git a/i965_drv_video/shaders/h264/ildb/AVC_ILDB_Dep_Check.asm b/i965_drv_video/shaders/h264/ildb/AVC_ILDB_Dep_Check.asm
new file mode 100644
index 0000000..70f8a55
--- /dev/null
+++ b/i965_drv_video/shaders/h264/ildb/AVC_ILDB_Dep_Check.asm
@@ -0,0 +1,186 @@
+/*
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+//---------- Check dependency and spawn all MBs ----------
+
+// Launch the 1st round of child threads for Vertical ILDB
+#if defined(_DEBUG) 
+	mov		(1)		EntrySignature:w			0x3333:w
+#endif
+
+//=====================================================================
+// Jump Table 1
+	// 0 0 ---> Goto ALL_SPAWNED
+	// 0 1 ---> Goto ALL_SPAWNED
+	// 1 0 ---> Goto SLEEP_ENTRY
+	// 1 1 ---> Goto POST_SLEEP
+	mov (2)		JumpTable.0<1>:d	0:d				{ NoDDClr }
+#if defined(CHROMA_ROOT) 		
+	mov (1)		JumpTable.2:d	SLEEP_ENTRY_UV_ILDB_FRAME_IP-ALL_SPAWNED_UV_ILDB_FRAME_IP:d		{ NoDDClr, NoDDChk }
+	mov (1)		JumpTable.3:d	POST_SLEEP_UV_ILDB_FRAME_IP-ALL_SPAWNED_UV_ILDB_FRAME_IP:d		{ NoDDChk }
+#else
+	mov (1)		JumpTable.2:d	SLEEP_ENTRY_Y_ILDB_FRAME_IP-ALL_SPAWNED_Y_ILDB_FRAME_IP:d		{ NoDDClr, NoDDChk }
+	mov (1)		JumpTable.3:d	POST_SLEEP_Y_ILDB_FRAME_IP-ALL_SPAWNED_Y_ILDB_FRAME_IP:d		{ NoDDChk }
+#endif
+//=====================================================================
+
+	mov (2)		f0.0<1>:w		0:w
+
+	// Get m0 most of fields ready for URB write
+	mov	(8)			MRF0<1>:ud		MSGSRC.0<8;8,1>:ud
+
+	// Add child kernel offset
+	add (1) 	CT_R0Hdr.2:ud 			r0.2:ud 		CHILD_OFFSET:w
+
+	// Init
+	mov (1)		Col_Boundary:w			2:w
+	mov (1)		Row_Boundary:w			LastRow:w
+	mov (1)		TopRowForScan:w			0:w
+	mov (2)		OutstandingThreads<1>:w	0:w
+
+	// Init Scoreboard  (idle = 0x00FF, busy = 0x0000)
+	// Low word is saved col.  High word is busy/idle status
+	mov	(16)		GatewayAperture(0)<1>	0x00FF00FF:ud		// Init r6-r7
+	mov	(16)		GatewayAperture(2)<1>	0x00FF00FF:ud		// Init r8-r9
+	mov	(16)		GatewayAperture(4)<1>	0x00FF00FF:ud		// Init r10-r11
+	mov	(16)		GatewayAperture(6)<1>	0x00FF00FF:ud		// Init r12-r13
+	mov	(16)		GatewayAperture(8)<1>	0x00FF00FF:ud		// Init r14-r15
+
+	mul	(1)	 		StatusAddr:w		CurRow:w		4:w		// dword to bytes offset conversion
+
+	//=====================================================================
+
+//SPAWN_LOOP:
+	//===== OutstandingThreads < ThreadLimit ? ============================
+	cmp.l.f0.1 (1)	null:w		OutstandingThreads:w	ThreadLimit:w		// Check the thread limit
+#if defined(CHROMA_ROOT) 
+    (f0.1) jmpi		ILDB_LABEL(POST_SLEEP_UV)
+#else	// LUMA_ROOT
+    (f0.1) jmpi		ILDB_LABEL(POST_SLEEP_Y)
+#endif
+
+#if defined(CHROMA_ROOT) 
+ILDB_LABEL(SLEEP_ENTRY_UV):
+#else	// LUMA_ROOT
+ILDB_LABEL(SLEEP_ENTRY_Y):
+#endif
+    //===== Goto Sleep ====================================================
+    // Either reached max thread limit or no child thread can be spawned due to dependency.
+	add	(1)			OutstandingThreads:w	OutstandingThreads:w	-1:w // Do this before wait is faster
+	wait 			n0.0:d												
+
+#if defined(CHROMA_ROOT) 
+ILDB_LABEL(POST_SLEEP_UV):
+#else	// LUMA_ROOT
+ILDB_LABEL(POST_SLEEP_Y):
+#endif
+	//===== Luma Status[CurRow] == busy ? =====
+	cmp.z.f0.0 (1)	null:uw		r[StatusAddr, GatewayApertureB+ScoreBd_Idx]:uw		0:uw			// Check west neighbor
+	cmp.g.f0.1 (1)	null:w		CurCol:w		LastCol:w		// Check if the curCol > LastCol
+
+#if defined(CHROMA_ROOT) 
+	mov	(16)		acc0.0<1>:w		URBOffsetUVBase<0;1,0>:w			// Add offset to UV base (MBsCntY * URB_EBTRIES_PER_MB)
+	mac (1)			URBOffset:w		CurRow:w			4:w				// 4 entries per row
+#else
+	mul	(1)			URBOffset:w		CurRow:w			4:w				// 4 entries per row
+#endif
+
+#if defined(CHROMA_ROOT) 
+	(f0.0) jmpi		ILDB_LABEL(SLEEP_ENTRY_UV)								// Current row has a child thread running, can not spawn a new child thread, go back to sleep
+	(f0.1) jmpi		ILDB_LABEL(NEXT_MB_UV)									// skip MB if the curCol > LastCol 
+#else	// LUMA_ROOT
+	(f0.0) jmpi		ILDB_LABEL(SLEEP_ENTRY_Y)								// Current row has a child thread running, can not spawn a new child thread, go back to sleep
+	(f0.1) jmpi		ILDB_LABEL(NEXT_MB_Y)									// skip MB if the curCol > LastCol 
+#endif
+		
+	//========== Spwan a child thread ========================================
+	// Save cur col and set Status[CurRow] to busy
+	mov (2)			r[StatusAddr, GatewayApertureB]<1>:uw		CurColB<2;2,1>:ub		// Store the new col
+			
+	// Increase OutstandingThreads and ProcessedMBs by 1
+	add	(2)			OutstandingThreads<1>:w		OutstandingThreads<2;2,1>:w		1:w  
+
+	#include "AVC_ILDB_SpawnChild.asm"
+
+	//===== Find next MB ===================================================
+#if defined(CHROMA_ROOT) 
+ILDB_LABEL(NEXT_MB_UV):
+#else	// LUMA_ROOT
+ILDB_LABEL(NEXT_MB_Y):
+#endif
+	// Check pic boundary, results are in f0.0 bit0 and bit1
+	cmp.ge.f0.0	(2)	null<1>:w   CurCol<2;2,1>:w 	Col_Boundary<2;2,1>:w
+
+	// Update TopRowForScan if the curCol = LastCol
+	(f0.1) add (1)	TopRowForScan:w		CurRow:w		1:w	
+
+//	cmp.l.f0.1 (1)	null<1>:w		ProcessedMBs:w		TotalBlocks:w		// Processed all blocks ?
+	// 2 sets compare
+	// ProcessedMBs:w < TotalBlocks:w		OutstandingThreads:w < ThreadLimit:wProcessedMBs:w
+	// 0 0 ---> Goto ALL_SPAWNED
+	// 0 1 ---> Goto ALL_SPAWNED
+	// 1 0 ---> Goto SLEEP_ENTRY
+	// 1 1 ---> Goto POST_SLEEP
+	cmp.l.f0.1 (2)	null<1>:w		OutstandingThreads<2;2,1>:w	ThreadLimit<2;2,1>:w
+
+	// Just do it in stalled cycles
+	mov (1)		acc0.0:w		4:w
+	mac	(1)	 	StatusAddr:w		CurRow:w		4:w						// dword to bytes offset conversion	
+	add (2)		CurCol<1>:w		CurCol<2;2,1>:w		StepToNextMB<2;2,1>:b	// CurCol -= 2 and CurRow += 1
+		
+	// Set f0.0 if turning around is needed, assuming bit 15 - 2 are zeros for correct comparison.
+	cmp.nz.f0.0 (1)	null<1>:w	f0.0:w		0x01:w
+		
+	mul (1) 	JumpAddr:w		f0.1:w		4:w		// byte offet in dword count
+		
+	// The next MB is at the row TopRowForScan
+	(f0.0) mul (1)	 	StatusAddr:w	TopRowForScan:w		4:w				// dword to bytes offset conversion
+	(f0.0) mov (1)		CurRow:w		TopRowForScan:w								{ NoDDClr }	// Restart from the top row that has MBs not deblocked yet.
+	(f0.0) add (1)		CurCol:w		r[StatusAddr, GatewayApertureB]:uw		1:w		{ NoDDChk }
+	
+	//===== Processed all blocks ? =========================================
+	// (f0.1) jmpi		SPAWN_LOOP
+
+	jmpi	r[JumpAddr, JUMPTABLE_BASE]:d
+//JUMP_BASE:
+
+	//======================================================================
+
+	// All MB are spawned at this point, check for outstanding thread count
+#if defined(CHROMA_ROOT) 
+ILDB_LABEL(ALL_SPAWNED_UV):
+#else	// LUMA_ROOT
+ILDB_LABEL(ALL_SPAWNED_Y):
+#endif
+	cmp.e.f0.1 (1) 	null:w		OutstandingThreads:w		0:w			// Check before goto sleep
+#if defined(CHROMA_ROOT) 
+	(f0.1) jmpi		ILDB_LABEL(ALL_DONE_UV)
+#else	// LUMA_ROOT
+	(f0.1) jmpi		ILDB_LABEL(ALL_DONE_Y)
+#endif
+	
+	wait 			n0.0:d												// Wake up by a finished child thread
+	add	(1)			OutstandingThreads:w	OutstandingThreads:w	-1:w
+
+#if defined(CHROMA_ROOT) 
+	// One thread is free and give it to luma thread limit --- Increase luma thread limit by one.
+	#include "AVC_ILDB_LumaThrdLimit.asm"
+#endif
+
+#if defined(CHROMA_ROOT) 
+    jmpi			ILDB_LABEL(ALL_SPAWNED_UV)							// Waked up and goto dependency check
+#else	// LUMA_ROOT
+    jmpi			ILDB_LABEL(ALL_SPAWNED_Y)							// Waked up and goto dependency check
+#endif
+
+	// All child threads are finsihed at this point 
+#if defined(CHROMA_ROOT) 
+ILDB_LABEL(ALL_DONE_UV):
+#else	// LUMA_ROOT
+ILDB_LABEL(ALL_DONE_Y):
+#endif
diff --git a/i965_drv_video/shaders/h264/ildb/AVC_ILDB_Filter_Mbaff_UV_h.asm b/i965_drv_video/shaders/h264/ildb/AVC_ILDB_Filter_Mbaff_UV_h.asm
new file mode 100644
index 0000000..ff807d5
--- /dev/null
+++ b/i965_drv_video/shaders/h264/ildb/AVC_ILDB_Filter_Mbaff_UV_h.asm
@@ -0,0 +1,223 @@
+/*
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+////////// AVC ILDB filter horizontal Mbaff UV ///////////////////////////////////////////////////////
+//
+//	This filter code prepares the src data and control data for ILDB filtering on all horizontal edges of UV.
+//
+//	It sssumes the data for horizontal de-blocking is already transposed.  
+//
+//		Chroma:
+//
+//		+-------+-------+		H0 Edge
+//		|		|		|
+//		|		|		|
+//		|		|		|
+//		+-------+-------+		H1 Edge
+//		|		|		|
+//		|		|		|
+//		|		|		|
+//		+-------+-------+
+//
+/////////////////////////////////////////////////////////////////////////////
+
+#if defined(_DEBUG) 
+	mov		(1)		EntrySignatureC:w			0xBBBC:w
+#endif	
+
+//=============== Chroma deblocking ================
+
+//---------- Deblock UV external top edge ----------
+
+	and.z.f0.0  (1) null:w		r[ECM_AddrReg, BitFlags]:ub		FilterTopMbEdgeFlag:w		// Check for FilterTopMbEdgeFlag 
+
+	mov	(1)	f0.1:w		DualFieldMode:w		// Check for dual field mode
+
+	// Get Luma maskA and maskB	
+	shr (16)	TempRow0(0)<1>		r[ECM_AddrReg, wEdgeCntlMapA_ExtTopHorz0]<0;1,0>:uw		RRampW(0)
+	shr (16)	TempRow1(0)<1>		r[ECM_AddrReg, wEdgeCntlMapB_ExtTopHorz0]<0;1,0>:uw		RRampW(0)
+
+    (f0.0)	jmpi	H0_UV_DONE				// Skip H0 UV edge
+
+	(f0.1) jmpi DUAL_FIELD_UV
+
+	// Non dual field mode	
+
+	// Extract UV MaskA and MaskB from every other bit of Y masks
+	and.nz.f0.0 (8) null:w			TempRow0(0)<16;8,2>		1:w
+	and.nz.f0.1 (8) null:w			TempRow1(0)<16;8,2>		1:w
+
+	// Ext U
+	//	p1 = Prev MB U row 0
+	//	p0 = Prev MB U row 1
+	// 	q0 = Cur MB U row 0
+	//	q1 = Cur MB U row 1
+	mov (1)	P_AddrReg:w		PREV_MB_U_BASE:w	{ NoDDClr }
+	mov (1)	Q_AddrReg:w		SRC_MB_U_BASE:w		{ NoDDChk }
+	
+	mov	(8) Mbaff_ALPHA(0,0)<1>		r[ECM_AddrReg, bAlphaTop0_Cb]<0;1,0>:ub
+	mov	(8) Mbaff_BETA(0,0)<1>		r[ECM_AddrReg, bBetaTop0_Cb]<0;1,0>:ub
+	mov (8) Mbaff_TC0(0,0)<1>		r[ECM_AddrReg, bTc0_h00_0_Cb]<1;2,0>:ub
+
+	// Store UV MaskA and MaskB
+	mov (2)		MaskA<1>:uw			f0.0<2;2,1>:uw
+
+	CALL(FILTER_UV_MBAFF, 1)	
+
+	// Ext V
+	mov (1)	P_AddrReg:w		PREV_MB_V_BASE:w	{ NoDDClr }
+	mov (1)	Q_AddrReg:w		SRC_MB_V_BASE:w		{ NoDDChk }
+
+	mov	(8) Mbaff_ALPHA(0,0)<1>		r[ECM_AddrReg, bAlphaTop0_Cr]<0;1,0>:ub
+	mov	(8) Mbaff_BETA(0,0)<1>		r[ECM_AddrReg, bBetaTop0_Cr]<0;1,0>:ub
+	mov (8) Mbaff_TC0(0,0)<1>		r[ECM_AddrReg, bTc0_h00_0_Cr]<1;2,0>:ub
+
+	// Set UV MaskA and MaskB
+	mov (2)		f0.0<1>:uw		MaskA<2;2,1>:uw
+
+	CALL(FILTER_UV_MBAFF, 1)	
+
+	jmpi H0_UV_DONE	
+	
+DUAL_FIELD_UV:
+	// Dual field mode, FieldModeCurrentMbFlag=0 && FieldModeAboveMbFlag=1
+
+	//===== Ext U, Top field
+
+	// Extract UV MaskA and MaskB from every other bit of Y masks
+	and.nz.f0.0 (8) null:w			TempRow0(0)<16;8,2>		1:w
+	and.nz.f0.1 (8) null:w			TempRow1(0)<16;8,2>		1:w
+
+	mov (1)	P_AddrReg:w		ABOVE_CUR_MB_BASE:w			{ NoDDClr }
+	mov (1)	Q_AddrReg:w		ABOVE_CUR_MB_BASE+32:w		{ NoDDChk }
+
+	mov (16) ABOVE_CUR_MB_UW(0)<1>	PREV_MB_UW(0, 0)<16;8,1>	// Copy p1, p0
+	mov (16) ABOVE_CUR_MB_UW(1)<1>	SRC_UW(0, 0)<16;8,1>		// Copy q1, q0
+
+	//===== Ext U, top field
+	mov	(8) Mbaff_ALPHA(0,0)<1>		r[ECM_AddrReg, bAlphaTop0_Cb]<0;1,0>:ub
+	mov	(8) Mbaff_BETA(0,0)<1>		r[ECM_AddrReg, bBetaTop0_Cb]<0;1,0>:ub
+	mov (8) Mbaff_TC0(0,0)<1>		r[ECM_AddrReg, bTc0_h00_0_Cb]<1;2,0>:ub
+
+	// Store UV MaskA and MaskB
+	mov (2)		MaskA<1>:uw			f0.0<2;2,1>:uw
+
+	CALL(FILTER_UV_MBAFF, 1)	// Ext U, top field
+
+	//===== Ext V, top field
+	mov (1)	P_AddrReg:w		ABOVE_CUR_MB_BASE+1:w		{ NoDDClr }
+	mov (1)	Q_AddrReg:w		ABOVE_CUR_MB_BASE+33:w		{ NoDDChk }
+
+	mov	(8) Mbaff_ALPHA(0,0)<1>		r[ECM_AddrReg, bAlphaTop0_Cr]<0;1,0>:ub
+	mov	(8) Mbaff_BETA(0,0)<1>		r[ECM_AddrReg, bBetaTop0_Cr]<0;1,0>:ub
+	mov (8) Mbaff_TC0(0,0)<1>		r[ECM_AddrReg, bTc0_h00_0_Cr]<1;2,0>:ub
+
+	// Set UV MaskA and MaskB
+	mov (2)		f0.0<1>:uw		MaskA<2;2,1>:uw
+
+	CALL(FILTER_UV_MBAFF, 1)	// Ext U, top field
+
+	// Prefetch for bottom field
+	// Get bot field Luma maskA and maskB	
+	shr (16)	TempRow0(0)<1>		r[ECM_AddrReg, wEdgeCntlMapA_ExtTopHorz1]<0;1,0>:uw		RRampW(0)
+	shr (16)	TempRow1(0)<1>		r[ECM_AddrReg, wEdgeCntlMapB_ExtTopHorz1]<0;1,0>:uw		RRampW(0)
+
+	// Save deblocked top field rows
+	mov (8) PREV_MB_UW(1, 0)<1>		ABOVE_CUR_MB_UW(0, 8)	// Copy p0
+	mov (8) SRC_UW(0, 0)<1>			ABOVE_CUR_MB_UW(1, 0)	// Copy q0
+	//==========================================================================
+
+	//===== Ext U, Bot field 
+	
+	// Extract UV MaskA and MaskB from every other bit of Y masks
+	and.nz.f0.0 (8) null:w			TempRow0(0)<16;8,2>		1:w
+	and.nz.f0.1 (8) null:w			TempRow1(0)<16;8,2>		1:w
+
+	mov (1)	P_AddrReg:w		ABOVE_CUR_MB_BASE:w			{ NoDDClr }
+	mov (1)	Q_AddrReg:w		ABOVE_CUR_MB_BASE+32:w		{ NoDDChk }
+
+	mov (16) ABOVE_CUR_MB_UW(0)<1>	PREV_MB_UW(0, 8)<16;8,1>	// Copy p1, p0
+	mov (16) ABOVE_CUR_MB_UW(1)<1>	SRC_UW(0, 8)<16;8,1>		// Copy q1, q0
+
+	//===== Ext U, bottom field
+	mov	(8) Mbaff_ALPHA(0,0)<1>		r[ECM_AddrReg, bAlphaTop1_Cb]<0;1,0>:ub
+	mov	(8) Mbaff_BETA(0,0)<1>		r[ECM_AddrReg, bBetaTop1_Cb]<0;1,0>:ub
+	mov (8) Mbaff_TC0(0,0)<1>		r[ECM_AddrReg, bTc0_h00_1_Cb]<1;2,0>:ub
+
+	// Store UV MaskA and MaskB
+	mov (2)		MaskA<1>:uw			f0.0<2;2,1>:uw
+
+	CALL(FILTER_UV_MBAFF, 1)	// Ext U, bottom field
+
+	//===== Ext V, bot field
+	mov (1)	P_AddrReg:w		ABOVE_CUR_MB_BASE+1:w		{ NoDDClr }
+	mov (1)	Q_AddrReg:w		ABOVE_CUR_MB_BASE+33:w		{ NoDDChk }
+
+	mov	(8) Mbaff_ALPHA(0,0)<1>		r[ECM_AddrReg, bAlphaTop1_Cr]<0;1,0>:ub
+	mov	(8) Mbaff_BETA(0,0)<1>		r[ECM_AddrReg, bBetaTop1_Cr]<0;1,0>:ub
+	mov (8) Mbaff_TC0(0,0)<1>		r[ECM_AddrReg, bTc0_h00_1_Cr]<1;2,0>:ub
+
+	// Set UV MaskA and MaskB
+	mov (2)		f0.0<1>:uw		MaskA<2;2,1>:uw
+
+	CALL(FILTER_UV_MBAFF, 1)	// Ext V, bottom field
+	
+	// Save deblocked bot field rows
+	mov (8) PREV_MB_UW(1, 8)<1>		ABOVE_CUR_MB_UW(0, 8)	// Copy p0
+	mov (8) SRC_UW(0, 8)<1>			ABOVE_CUR_MB_UW(1, 0)	// Copy q0
+	//========================================
+
+H0_UV_DONE:
+
+//---------- Deblock U internal horz middle edge ----------
+
+	//***** Need to take every other bit to form U maskA in core
+	shr (16)	TempRow0(0)<1>		r[ECM_AddrReg, wEdgeCntlMap_IntMidHorz]<0;1,0>:uw		RRampW(0)
+
+	//	p1 = Cur MB U row 2
+	//	p0 = Cur MB U row 3
+	// 	q0 = Cur MB U row 4
+	//	q1 = Cur MB U row 5
+	mov (1)	P_AddrReg:w		4*UV_ROW_WIDTH+SRC_MB_U_BASE:w		{ NoDDClr }
+	mov (1)	Q_AddrReg:w		8*UV_ROW_WIDTH+SRC_MB_U_BASE:w		{ NoDDChk }
+
+	mov	(8) Mbaff_ALPHA(0,0)<1>		r[ECM_AddrReg, bAlphaInternal_Cb]<0;1,0>:ub
+	mov	(8) Mbaff_BETA(0,0)<1>		r[ECM_AddrReg, bBetaInternal_Cb]<0;1,0>:ub
+	mov (8) Mbaff_TC0(0,0)<1>		r[ECM_AddrReg, bTc0_h20_Cb]<1;2,0>:ub
+
+	and.nz.f0.0 (8) null:w			TempRow0(0)<16;8,2>		1:w
+
+	// Store UV MaskA and MaskB
+	mov (1)	f0.1:uw		0:w
+	mov (1)	MaskB:uw	0:w			{ NoDDClr }
+	mov (1)	MaskA:uw	f0.0:uw		{ NoDDChk }
+
+	CALL(FILTER_UV_MBAFF, 1)	
+//-----------------------------------------------
+
+
+//---------- Deblock V internal horz middle edge ----------
+
+	//	p1 = Cur MB V row 2
+	//	p0 = Cur MB V row 3
+	// 	q0 = Cur MB V row 4
+	//	q1 = Cur MB V row 5
+	mov (1)	P_AddrReg:w		4*UV_ROW_WIDTH+SRC_MB_V_BASE:w		{ NoDDClr }
+	mov (1)	Q_AddrReg:w		8*UV_ROW_WIDTH+SRC_MB_V_BASE:w		{ NoDDChk }
+
+	mov	(8) Mbaff_ALPHA(0,0)<1>		r[ECM_AddrReg, bAlphaInternal_Cr]<0;1,0>:ub
+	mov	(8) Mbaff_BETA(0,0)<1>		r[ECM_AddrReg, bBetaInternal_Cr]<0;1,0>:ub
+	mov (8) Mbaff_TC0(0,0)<1>		r[ECM_AddrReg, bTc0_h20_Cr]<1;2,0>:ub
+
+	// Set UV MaskA and MaskB
+	mov (2)		f0.0<1>:uw		MaskA<2;2,1>:uw
+
+	CALL(FILTER_UV_MBAFF, 1)	
+//-----------------------------------------------
+
+
diff --git a/i965_drv_video/shaders/h264/ildb/AVC_ILDB_Filter_Mbaff_UV_v.asm b/i965_drv_video/shaders/h264/ildb/AVC_ILDB_Filter_Mbaff_UV_v.asm
new file mode 100644
index 0000000..c0f2678
--- /dev/null
+++ b/i965_drv_video/shaders/h264/ildb/AVC_ILDB_Filter_Mbaff_UV_v.asm
@@ -0,0 +1,209 @@
+/*
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+////////// AVC LDB filter vertical Mbaff UV ///////////////////////////////////////////////////////
+//
+//	This filter code prepares the src data and control data for ILDB filtering on all vertical edges of UV.
+//
+//	It sssumes the data for vertical de-blocking is already transposed.  
+//
+//		Chroma:
+//
+//		+-------+-------+
+//		|		|		|
+//		|		|		|
+//		|		|		|
+//		+-------+-------+
+//		|		|		|
+//		|		|		|
+//		|		|		|
+//		+-------+-------+
+//
+//		V0		V1		
+//		Edge	Edge	
+//
+/////////////////////////////////////////////////////////////////////////////
+
+#if defined(_DEBUG) 
+	mov		(1)		EntrySignatureC:w			0xBBBC:w
+#endif	
+
+//=============== Chroma deblocking ================
+
+//---------- Deblock U external left edge ----------
+
+	and.z.f0.0  (1) null:w		r[ECM_AddrReg, BitFlags]:ub		FilterLeftMbEdgeFlag:w		// Check for FilterLeftMbEdgeFlag 
+
+	cmp.z.f0.1	(1)	null:w	VertEdgePattern:uw		LEFT_FIELD_CUR_FRAME:w
+
+	// Get Luma maskA and maskB	
+	shr (16)	TempRow0(0)<1>		r[ECM_AddrReg, wEdgeCntlMapA_ExtLeftVert0]<0;1,0>:uw		RRampW(0)
+	shr (16)	TempRow1(0)<1>		r[ECM_AddrReg, wEdgeCntlMapB_ExtLeftVert0]<0;1,0>:uw		RRampW(0)
+	
+    (f0.0)	jmpi	BYPASS_V0_UV	// Do not deblock Left ext edge
+
+	cmp.z.f0.0	(1)	null:w	VertEdgePattern:uw		LEFT_FRAME_CUR_FIELD:w
+
+	(-f0.1) jmpi V0_U_NEXT1	// Jump if not LEFT_FIELD_CUR_FRAME
+
+	//----- For LEFT_FIELD_CUR_FRAME
+	
+	// Extract UV MaskA and MaskB from every other 2 bits of Y masks
+	and.nz.f0.0 (8) null:w			TempRow0(0)<4;2,1>		1:w
+	and.nz.f0.1 (8) null:w			TempRow1(0)<4;2,1>		1:w
+
+	// For FieldModeLeftMbFlag=1 && FieldModeCurrentMbFlag=0 
+	mov	(4)	Mbaff_ALPHA(0,0)<2>		r[ECM_AddrReg, bAlphaLeft0_Cb]<0;1,0>:ub	{ NoDDClr }
+	mov	(4)	Mbaff_ALPHA(0,1)<2>		r[ECM_AddrReg, bAlphaLeft1_Cb]<0;1,0>:ub	{ NoDDChk }
+	mov	(4)	Mbaff_BETA(0,0)<2>		r[ECM_AddrReg, bBetaLeft0_Cb]<0;1,0>:ub		{ NoDDClr }
+	mov	(4)	Mbaff_BETA(0,1)<2>		r[ECM_AddrReg, bBetaLeft1_Cb]<0;1,0>:ub		{ NoDDChk }
+	mov (4)	Mbaff_TC0(0,0)<2>		r[ECM_AddrReg, bTc0_v00_0_Cb]<4;4,1>:ub		{ NoDDClr }
+	mov (4)	Mbaff_TC0(0,1)<2>		r[ECM_AddrReg, bTc0_v00_1_Cb]<4;4,1>:ub		{ NoDDChk }
+
+	jmpi	V0_U_NEXT3
+
+V0_U_NEXT1:
+	
+	(-f0.0) jmpi V0_U_NEXT2			// Jump if not LEFT_FRAME_CUR_FIELD
+	
+	//----- For LEFT_FRAME_CUR_FIELD
+		
+	// Extract UV MaskA and MaskB from every other bit of Y masks
+	and.nz.f0.0 (8) null:w			TempRow0(0)<16;8,2>		1:w
+	and.nz.f0.1 (8) null:w			TempRow1(0)<16;8,2>		1:w
+
+	// For FieldModeLeftMbFlag=0 && FieldModeCurrentMbFlag=1
+	mov	(4)	Mbaff_ALPHA(0,0)<1>		r[ECM_AddrReg, bAlphaLeft0_Cb]<0;1,0>:ub	{ NoDDClr }
+	mov	(4)	Mbaff_ALPHA(0,4)<1>		r[ECM_AddrReg, bAlphaLeft1_Cb]<0;1,0>:ub	{ NoDDChk }
+	mov	(4)	Mbaff_BETA(0,0)<1>		r[ECM_AddrReg, bBetaLeft0_Cb]<0;1,0>:ub		{ NoDDClr }
+	mov	(4)	Mbaff_BETA(0,4)<1>		r[ECM_AddrReg, bBetaLeft1_Cb]<0;1,0>:ub		{ NoDDChk }
+	mov (4)	Mbaff_TC0(0,0)<1>		r[ECM_AddrReg, bTc0_v00_0_Cb]<4;4,1>:ub		{ NoDDClr }
+	mov (4)	Mbaff_TC0(0,4)<1>		r[ECM_AddrReg, bTc0_v00_1_Cb]<4;4,1>:ub		{ NoDDChk }
+
+	jmpi	V0_U_NEXT3
+	
+V0_U_NEXT2:
+
+	// Extract UV MaskA and MaskB from every other bit of Y masks
+	and.nz.f0.0 (8) null:w			TempRow0(0)<16;8,2>		1:w
+	and.nz.f0.1 (8) null:w			TempRow1(0)<16;8,2>		1:w
+	
+	// Both are frames or fields
+	mov	(8) Mbaff_ALPHA(0,0)<1>		r[ECM_AddrReg, bAlphaLeft0_Cb]<0;1,0>:ub
+	mov	(8) Mbaff_BETA(0,0)<1>		r[ECM_AddrReg, bBetaLeft0_Cb]<0;1,0>:ub
+	mov (8) Mbaff_TC0(0,0)<1>		r[ECM_AddrReg, bTc0_v00_0_Cb]<1;2,0>:ub
+
+V0_U_NEXT3:	
+
+	//	p1 = Prev MB U row 0
+	//	p0 = Prev MB U row 1
+	// 	q0 = Cur MB U row 0
+	//	q1 = Cur MB U row 1
+	mov (1)	P_AddrReg:w		PREV_MB_U_BASE:w	{ NoDDClr }
+	mov (1)	Q_AddrReg:w		SRC_MB_U_BASE:w		{ NoDDChk }
+
+	// Store UV MaskA and MaskB
+	mov (2)		MaskA<1>:uw			f0.0<2;2,1>:uw
+
+	CALL(FILTER_UV_MBAFF, 1)	
+//-----------------------------------------------
+
+//---------- Deblock V external left edge ----------
+
+	// No change to MaskA and MaskB
+
+	cmp.z.f0.0	(4)	null:w	VertEdgePattern:uw		LEFT_FIELD_CUR_FRAME:w
+	cmp.z.f0.1	(4)	null:w	VertEdgePattern:uw		LEFT_FRAME_CUR_FIELD:w
+
+	// both are frame or field
+	mov	(8) Mbaff_ALPHA(0,0)<1>		r[ECM_AddrReg, bAlphaLeft0_Cr]<0;1,0>:ub
+	mov	(8) Mbaff_BETA(0,0)<1>		r[ECM_AddrReg, bBetaLeft0_Cr]<0;1,0>:ub
+	mov (8) Mbaff_TC0(0,0)<1>		r[ECM_AddrReg, bTc0_v00_0_Cr]<1;2,0>:ub
+				
+	//	p1 = Prev MB V row 0
+	//	p0 = Prev MB V row 1
+	// 	q0 = Cur MB V row 0
+	//	q1 = Cur MB V row 1
+	mov (1)	P_AddrReg:w		PREV_MB_V_BASE:w	{ NoDDClr }
+	mov (1)	Q_AddrReg:w		SRC_MB_V_BASE:w		{ NoDDChk }
+				
+	// For FieldModeLeftMbFlag=1 && FieldModeCurrentMbFlag=0 
+	(f0.0) mov (4)	Mbaff_ALPHA(0,0)<2>		r[ECM_AddrReg, bAlphaLeft0_Cr]<0;1,0>:ub	{ NoDDClr }
+	(f0.0) mov (4)	Mbaff_ALPHA(0,1)<2>		r[ECM_AddrReg, bAlphaLeft1_Cr]<0;1,0>:ub	{ NoDDChk }	
+	(f0.0) mov (4)	Mbaff_BETA(0,0)<2>		r[ECM_AddrReg, bBetaLeft0_Cr]<0;1,0>:ub		{ NoDDClr }
+	(f0.0) mov (4)	Mbaff_BETA(0,1)<2>		r[ECM_AddrReg, bBetaLeft1_Cr]<0;1,0>:ub		{ NoDDChk }
+	(f0.0) mov (4)	Mbaff_TC0(0,0)<2>		r[ECM_AddrReg, bTc0_v00_0_Cr]<4;4,1>:ub		{ NoDDClr }
+	(f0.0) mov (4)	Mbaff_TC0(0,1)<2>		r[ECM_AddrReg, bTc0_v00_1_Cr]<4;4,1>:ub		{ NoDDChk }
+
+	// For FieldModeLeftMbFlag=0 && FieldModeCurrentMbFlag=1
+	(f0.1) mov (4)	Mbaff_ALPHA(0,0)<1>		r[ECM_AddrReg, bAlphaLeft0_Cr]<0;1,0>:ub	{ NoDDClr }
+	(f0.1) mov (4)	Mbaff_ALPHA(0,4)<1>		r[ECM_AddrReg, bAlphaLeft1_Cr]<0;1,0>:ub	{ NoDDChk }
+	(f0.1) mov (4)	Mbaff_BETA(0,0)<1>		r[ECM_AddrReg, bBetaLeft0_Cr]<0;1,0>:ub		{ NoDDClr }
+	(f0.1) mov (4)	Mbaff_BETA(0,4)<1>		r[ECM_AddrReg, bBetaLeft1_Cr]<0;1,0>:ub		{ NoDDChk }
+	(f0.1) mov (4)	Mbaff_TC0(0,0)<1>		r[ECM_AddrReg, bTc0_v00_0_Cr]<4;4,1>:ub		{ NoDDClr }
+	(f0.1) mov (4)	Mbaff_TC0(0,4)<1>		r[ECM_AddrReg, bTc0_v00_1_Cr]<4;4,1>:ub		{ NoDDChk }
+
+	// Set UV MaskA and MaskB
+	mov (2)		f0.0<1>:uw		MaskA<2;2,1>:uw
+
+	CALL(FILTER_UV_MBAFF, 1)	
+//-----------------------------------------------
+
+BYPASS_V0_UV:
+	// Set EdgeCntlMap2 = 0, so it always uses bS < 4 algorithm.
+	// Same alpha and beta for all internal vert and horiz edges 
+
+//---------- Deblock U internal vert middle edge ----------
+
+	//***** Need to take every other bit to form U or V maskA
+	shr (16) TempRow0(0)<1>			r[ECM_AddrReg, wEdgeCntlMap_IntMidVert]<0;1,0>:uw		RRampW(0)
+
+	//	p1 = Cur MB U row 2
+	//	p0 = Cur MB U row 3
+	// 	q0 = Cur MB U row 4
+	//	q1 = Cur MB U row 5
+	mov (1)	P_AddrReg:w		4*UV_ROW_WIDTH+SRC_MB_U_BASE:w		{ NoDDClr }		// Skip 2 U rows and 2 V rows
+	mov (1)	Q_AddrReg:w		8*UV_ROW_WIDTH+SRC_MB_U_BASE:w		{ NoDDChk }
+
+	mov	(8) Mbaff_ALPHA(0,0)<1>		r[ECM_AddrReg, bAlphaInternal_Cb]<0;1,0>:ub
+	mov	(8) Mbaff_BETA(0,0)<1>		r[ECM_AddrReg, bBetaInternal_Cb]<0;1,0>:ub
+	mov (8) Mbaff_TC0(0,0)<1>		r[ECM_AddrReg, bTc0_v02_Cb]<1;2,0>:ub
+
+	and.nz.f0.0 (8) null:w			TempRow0(0)<16;8,2>		1:w
+
+	// Store MaskA and MaskB
+	mov (1)	f0.1:uw		0:w			
+	mov (1)	MaskB:uw	0:w			{ NoDDClr }
+	mov (1)	MaskA:uw	f0.0:uw		{ NoDDChk }
+
+	CALL(FILTER_UV_MBAFF, 1)	
+	
+//-----------------------------------------------
+
+
+//---------- Deblock V internal vert middle edge ----------
+
+	//	P1 = Cur MB V row 2
+	//	P0 = Cur MB V row 3
+	// 	Q0 = Cur MB V row 4
+	//	Q1 = Cur MB V row 5
+	mov (1)	P_AddrReg:w		4*UV_ROW_WIDTH+SRC_MB_V_BASE:w		{ NoDDClr }		// Skip 2 U rows and 2 V rows
+	mov (1)	Q_AddrReg:w		8*UV_ROW_WIDTH+SRC_MB_V_BASE:w		{ NoDDChk }
+
+	// Put MaskA into f0.0
+	// Put MaskB into f0.1
+	mov (2)	f0.0<1>:uw		MaskA<2;2,1>:uw
+
+	mov	(8) Mbaff_ALPHA(0,0)<1>		r[ECM_AddrReg, bAlphaInternal_Cr]<0;1,0>:ub
+	mov	(8) Mbaff_BETA(0,0)<1>		r[ECM_AddrReg, bBetaInternal_Cr]<0;1,0>:ub
+	mov (8) Mbaff_TC0(0,0)<1>		r[ECM_AddrReg, bTc0_v02_Cr]<1;2,0>:ub
+
+	CALL(FILTER_UV_MBAFF, 1)	
+
+//-----------------------------------------------
+
diff --git a/i965_drv_video/shaders/h264/ildb/AVC_ILDB_Filter_Mbaff_Y_h.asm b/i965_drv_video/shaders/h264/ildb/AVC_ILDB_Filter_Mbaff_Y_h.asm
new file mode 100644
index 0000000..a98b024
--- /dev/null
+++ b/i965_drv_video/shaders/h264/ildb/AVC_ILDB_Filter_Mbaff_Y_h.asm
@@ -0,0 +1,234 @@
+/*
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+////////// AVC ILDB filter horizontal Mbaff Y ///////////////////////////////////////////////////////
+//
+//	This filter code prepares the src data and control data for ILDB filtering on all horizontal edges of Y.
+//
+//	It sssumes the data for horizontal de-blocking is already transposed.  
+//
+//		Luma:
+//
+//		+-------+-------+-------+-------+		H0  Edge
+//		|		|		|		|		|
+//		|		|		|		|		|
+//		|		|		|		|		|
+//		+-------+-------+-------+-------+		H1 Edge
+//		|		|		|		|		|
+//		|		|		|		|		|
+//		|		|		|		|		|
+//		+-------+-------+-------+-------+		H2	Edge
+//		|		|		|		|		|
+//		|		|		|		|		|
+//		|		|		|		|		|
+//		+-------+-------+-------+-------+		H3 Edge
+//		|		|		|		|		|
+//		|		|		|		|		|
+//		|		|		|		|		|
+//		+-------+-------+-------+-------+
+//
+/////////////////////////////////////////////////////////////////////////////
+
+#if defined(_DEBUG) 
+	mov		(1)		EntrySignatureC:w			0xBBBB:w
+#endif	
+	
+
+//========== Luma deblocking ==========
+
+
+//---------- Deblock Y external top edge (H0)  ----------	
+
+	// Bypass deblocking if it is the top edge of the picture.  
+	and.z.f0.0  (1) null:w		r[ECM_AddrReg, BitFlags]:ub		FilterTopMbEdgeFlag:w		// Check for FilterTopMbEdgeFlag 
+	mov	(1)	f0.1:w		DualFieldMode:w			// Check for dual field mode
+		
+	// Non dual field mode	
+
+	// Get (alpha >> 2) + 2
+	shr (16) Mbaff_ALPHA2(0,0)<1>	r[ECM_AddrReg, bAlphaTop0_Y]<0;1,0>:ub		2:w			// alpha >> 2
+
+	mov (2)	MaskA<1>:uw	r[ECM_AddrReg, wEdgeCntlMapA_ExtTopHorz0]<2;2,1>:uw
+
+	// Ext Y
+	mov	(16) Mbaff_ALPHA(0,0)<1>	r[ECM_AddrReg, bAlphaTop0_Y]<0;1,0>:ub
+	mov	(16) Mbaff_BETA(0,0)<1>		r[ECM_AddrReg, bBetaTop0_Y]<0;1,0>:ub
+	mov (16) Mbaff_TC0(0,0)<1>		r[ECM_AddrReg, bTc0_h00_0_Y]<1;4,0>:ub
+
+	add (16) Mbaff_ALPHA2(0,0)<1>		Mbaff_ALPHA2(0,0)<16;16,1>		2:w					// alpha2 = (alpha >> 2) + 2  
+
+    (f0.0) jmpi	H0_Y_DONE				// Skip Ext Y deblocking
+	(f0.1) jmpi	DUAL_FIELD_Y
+	
+	mov (1)	P_AddrReg:w		PREV_MB_Y_BASE:w		{ NoDDClr }
+	mov (1)	Q_AddrReg:w		SRC_MB_Y_BASE:w			{ NoDDChk }
+	
+	CALL(FILTER_Y_MBAFF, 1)			// Non dual field deblocking
+		
+	jmpi	H0_Y_DONE
+
+DUAL_FIELD_Y:
+	// Dual field mode, FieldModeCurrentMbFlag=0 && FieldModeAboveMbFlag=1
+
+	mov (1)	P_AddrReg:w		ABOVE_CUR_MB_BASE:w		{ NoDDClr }
+	mov (1)	Q_AddrReg:w		ABOVE_CUR_MB_BASE+64:w	{ NoDDChk }
+
+	//  Must use PREV_MB_YW.  TOP_MB_YW is not big enough.
+	// Get top field rows
+	mov (16) ABOVE_CUR_MB_YW(0)<1>	PREV_MB_YW(0, 0)<16;8,1>	// Copy p3, p2
+	mov (16) ABOVE_CUR_MB_YW(1)<1>	PREV_MB_YW(2, 0)<16;8,1>	// Copy p1, p0
+	mov (16) ABOVE_CUR_MB_YW(2)<1>	SRC_YW(0, 0)<16;8,1>		// Copy q0, q1
+	mov (16) ABOVE_CUR_MB_YW(3)<1>	SRC_YW(2, 0)<16;8,1>		// Copy q2, q3
+
+	CALL(FILTER_Y_MBAFF, 1)				// Ext Y, top field
+
+	// Save deblocked top field rows
+	mov (8) PREV_MB_YW(1, 0)<1>		ABOVE_CUR_MB_YW(0, 8)	// Copy p2
+	mov (8) PREV_MB_YW(2, 0)<1>		ABOVE_CUR_MB_YW(1, 0)	// Copy p1
+	mov (8) PREV_MB_YW(3, 0)<1>		ABOVE_CUR_MB_YW(1, 8)	// Copy p0
+	mov (8) SRC_YW(0, 0)<1>			ABOVE_CUR_MB_YW(2, 0)	// Copy q0
+	mov (8) SRC_YW(1, 0)<1>			ABOVE_CUR_MB_YW(2, 8)	// Copy q1
+	mov (8) SRC_YW(2, 0)<1>			ABOVE_CUR_MB_YW(3, 0)	// Copy q2
+
+	//==================================================================================
+	// Bottom field
+	
+	// Get (alpha >> 2) + 2
+	shr (16) Mbaff_ALPHA2(0,0)<1>	r[ECM_AddrReg, bAlphaTop1_Y]<0;1,0>:ub		2:w			// alpha >> 2
+
+	mov (1)	P_AddrReg:w		ABOVE_CUR_MB_BASE:w		{ NoDDClr }
+	mov (1)	Q_AddrReg:w		ABOVE_CUR_MB_BASE+64:w	{ NoDDChk }
+	
+	// Get bot field rows
+	mov (16) ABOVE_CUR_MB_YW(0)<1>	PREV_MB_YW(0, 8)<16;8,1>	// Copy p3, p2
+	mov (16) ABOVE_CUR_MB_YW(1)<1>	PREV_MB_YW(2, 8)<16;8,1>	// Copy p1, p0
+	mov (16) ABOVE_CUR_MB_YW(2)<1>	SRC_YW(0, 8)<16;8,1>		// Copy q0, q1
+	mov (16) ABOVE_CUR_MB_YW(3)<1>	SRC_YW(2, 8)<16;8,1>		// Copy q2, q3
+
+	mov (2)	MaskA<1>:uw	r[ECM_AddrReg, wEdgeCntlMapA_ExtTopHorz1]<2;2,1>:uw
+
+	mov	(16) Mbaff_ALPHA(0,0)<1>	r[ECM_AddrReg, bAlphaTop1_Y]<0;1,0>:ub
+	mov	(16) Mbaff_BETA(0,0)<1>		r[ECM_AddrReg, bBetaTop1_Y]<0;1,0>:ub
+	mov (16) Mbaff_TC0(0,0)<1>		r[ECM_AddrReg, bTc0_h00_1_Y]<1;4,0>:ub
+
+	add (16) Mbaff_ALPHA2(0,0)<1>		Mbaff_ALPHA2(0,0)<16;16,1>		2:w					// alpha2 = (alpha >> 2) + 2  
+
+	CALL(FILTER_Y_MBAFF, 1)				// Ext Y, bot field
+
+	// Save deblocked top field rows
+	mov (8) PREV_MB_YW(1, 8)<1>		ABOVE_CUR_MB_YW(0, 8)	// Copy p2
+	mov (8) PREV_MB_YW(2, 8)<1>		ABOVE_CUR_MB_YW(1, 0)	// Copy p1
+	mov (8) PREV_MB_YW(3, 8)<1>		ABOVE_CUR_MB_YW(1, 8)	// Copy p0
+	mov (8) SRC_YW(0, 8)<1>			ABOVE_CUR_MB_YW(2, 0)	// Copy q0
+	mov (8) SRC_YW(1, 8)<1>			ABOVE_CUR_MB_YW(2, 8)	// Copy q1
+	mov (8) SRC_YW(2, 8)<1>			ABOVE_CUR_MB_YW(3, 0)	// Copy q2
+	//==================================================================================
+
+H0_Y_DONE:
+
+//BYPASS_H0_Y:
+//------------------------------------------------------------------
+	// Same alpha, alpha2, beta and MaskB for all internal edges 
+
+	// Get (alpha >> 2) + 2
+	shr (16) Mbaff_ALPHA2(0,0)<1>	r[ECM_AddrReg, bAlphaInternal_Y]<0;1,0>:ub		2:w			// alpha >> 2
+
+	// alpha = bAlphaInternal_Y 
+	// beta = bBetaInternal_Y
+	mov	(16) Mbaff_ALPHA(0,0)<1>	r[ECM_AddrReg, bAlphaInternal_Y]<0;1,0>:ub
+	mov	(16) Mbaff_BETA(0,0)<1>		r[ECM_AddrReg, bBetaInternal_Y]<0;1,0>:ub
+
+	mov (1) MaskB:uw	0:w						// Set MaskB = 0 for all 3 edges, so it always uses bS < 4 algorithm.
+
+	add (16) Mbaff_ALPHA2(0,0)<1>		Mbaff_ALPHA2(0,0)<16;16,1>		2:w					// alpha2 = (alpha >> 2) + 2  
+
+//---------- Deblock Y internal top edge (H1)  ----------
+
+	// Bypass deblocking if FilterInternal4x4EdgesFlag = 0  
+	and.z.f0.0 (1) null:w	r[ECM_AddrReg, BitFlags]:ub		FilterInternal4x4EdgesFlag:w		// Check for FilterInternal4x4EdgesFlag 
+//    (f0.0)	jmpi	BYPASS_H1_Y
+
+	//	p3 = Cur MB Y row 0 = r[P_AddrReg, 0]<16;16,1> 
+	//	p2 = Cur MB Y row 1 = r[P_AddrReg, 16]<16;16,1>
+	//	p1 = Cur MB Y row 2 = r[P_AddrReg, 32]<16;16,1>
+	//	p0 = Cur MB Y row 3 = r[P_AddrReg, 48]<16;16,1>
+	// 	q0 = Cur MB Y row 4 = r[Q_AddrReg, 0]<16;16,1> 
+	//	q1 = Cur MB Y row 5 = r[Q_AddrReg, 16]<16;16,1>
+	//	q2 = Cur MB Y row 6 = r[Q_AddrReg, 32]<16;16,1>
+	//	q3 = Cur MB Y row 7 = r[Q_AddrReg, 48]<16;16,1>
+	mov (1)	P_AddrReg:w		SRC_MB_Y_BASE:w					{ NoDDClr }
+	mov (1)	Q_AddrReg:w		4*Y_ROW_WIDTH+SRC_MB_Y_BASE:w	{ NoDDChk }
+
+	mov (1)	MaskA:uw	r[ECM_AddrReg, wEdgeCntlMap_IntTopHorz]:uw
+
+	// tc0 has bTc0_h13_Y + bTc0_h12_Y + bTc0_h11_Y + bTc0_h10_Y		
+	mov (16) Mbaff_TC0(0,0)<1>		r[ECM_AddrReg, bTc0_h10_Y]<1;4,0>:ub
+
+//	CALL(FILTER_Y_MBAFF, 1)
+	PRED_CALL(-f0.0, FILTER_Y_MBAFF, 1)
+
+//BYPASS_H1_Y:
+//------------------------------------------------------------------
+
+
+//---------- Deblock Y internal mid horizontal edge (H2) ----------
+
+	// Bypass deblocking if FilterInternal8x8EdgesFlag = 0  
+	and.z.f0.0 (1) null:w	r[ECM_AddrReg, BitFlags]:ub		FilterInternal8x8EdgesFlag:w		// Check for FilterInternal4x4EdgesFlag 
+//    (f0.0)	jmpi	BYPASS_H2_Y
+
+	//	p3 = Cur MB Y row 4  = r[P_AddrReg, 0]<16;16,1> 
+	//	p2 = Cur MB Y row 5  = r[P_AddrReg, 16]<16;16,1>
+	//	p1 = Cur MB Y row 6  = r[P_AddrReg, 32]<16;16,1>
+	//	p0 = Cur MB Y row 7  = r[P_AddrReg, 48]<16;16,1>
+	// 	q0 = Cur MB Y row 8  = r[Q_AddrReg, 0]<16;16,1> 
+	//	q1 = Cur MB Y row 9  = r[Q_AddrReg, 16]<16;16,1>
+	//	q2 = Cur MB Y row 10 = r[Q_AddrReg, 32]<16;16,1>
+	//	q3 = Cur MB Y row 11 = r[Q_AddrReg, 48]<16;16,1>
+	mov (1)	P_AddrReg:w		4*Y_ROW_WIDTH+SRC_MB_Y_BASE:w		{ NoDDClr }
+	mov (1)	Q_AddrReg:w		8*Y_ROW_WIDTH+SRC_MB_Y_BASE:w		{ NoDDChk }
+
+	mov (1)	MaskA:uw	r[ECM_AddrReg, wEdgeCntlMap_IntMidHorz]:uw
+
+	// tc0 has bTc0_h23_Y + bTc0_h22_Y + bTc0_h21_Y + bTc0_h20_Y		
+	mov (16) Mbaff_TC0(0,0)<1>		r[ECM_AddrReg, bTc0_h20_Y]<1;4,0>:ub
+
+//	CALL(FILTER_Y_MBAFF, 1)
+	PRED_CALL(-f0.0, FILTER_Y_MBAFF, 1)
+
+//BYPASS_H2_Y:
+//-----------------------------------------------
+
+
+//---------- Deblock Y internal bottom edge (H3) ----------	 
+
+	// Bypass deblocking if FilterInternal4x4EdgesFlag = 0  
+	and.z.f0.0 (1) null:w	r[ECM_AddrReg, BitFlags]:ub		FilterInternal4x4EdgesFlag:w		// Check for FilterInternal4x4EdgesFlag 
+//    (f0.0)	jmpi	BYPASS_H3_Y
+
+	//	p3 = Cur MB Y row 8  = r[P_AddrReg, 0]<16;16,1> 
+	//	p2 = Cur MB Y row 9  = r[P_AddrReg, 16]<16;16,1>
+	//	p1 = Cur MB Y row 10 = r[P_AddrReg, 32]<16;16,1>
+	//	p0 = Cur MB Y row 11 = r[P_AddrReg, 48]<16;16,1>
+	// 	q0 = Cur MB Y row 12 = r[Q_AddrReg, 0]<16;16,1> 
+	//	q1 = Cur MB Y row 13 = r[Q_AddrReg, 16]<16;16,1>
+	//	q2 = Cur MB Y row 14 = r[Q_AddrReg, 32]<16;16,1>
+	//	q3 = Cur MB Y row 15 = r[Q_AddrReg, 48]<16;16,1>
+	mov (1)	P_AddrReg:w		8*Y_ROW_WIDTH+SRC_MB_Y_BASE:w		{ NoDDClr }
+	mov (1)	Q_AddrReg:w		12*Y_ROW_WIDTH+SRC_MB_Y_BASE:w		{ NoDDChk }
+	
+	mov (1)	MaskA:uw	r[ECM_AddrReg, wEdgeCntlMap_IntBotHorz]:uw
+
+	// tc0 has bTc0_h33_Y + bTc0_h32_Y + bTc0_h31_Y + bTc0_h30_Y
+	mov (16) Mbaff_TC0(0,0)<1>		r[ECM_AddrReg, bTc0_h30_Y]<1;4,0>:ub
+
+//	CALL(FILTER_Y_MBAFF, 1)
+	PRED_CALL(-f0.0, FILTER_Y_MBAFF, 1)
+
+//BYPASS_H3_Y:
+//-----------------------------------------------
diff --git a/i965_drv_video/shaders/h264/ildb/AVC_ILDB_Filter_Mbaff_Y_v.asm b/i965_drv_video/shaders/h264/ildb/AVC_ILDB_Filter_Mbaff_Y_v.asm
new file mode 100644
index 0000000..7846168
--- /dev/null
+++ b/i965_drv_video/shaders/h264/ildb/AVC_ILDB_Filter_Mbaff_Y_v.asm
@@ -0,0 +1,269 @@
+/*
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+////////// AVC ILDB filter vertical Mbaff Y ///////////////////////////////////////////////////////
+//
+//	This filter code prepares the src data and control data for ILDB filtering on all vertical edges of Y.
+//
+//	It sssumes the data for vertical de-blocking is already transposed.  
+//
+//		Luma:
+//
+//		+-------+-------+-------+-------+
+//		|		|		|		|		|
+//		|		|		|		|		|
+//		|		|		|		|		|
+//		+-------+-------+-------+-------+
+//		|		|		|		|		|
+//		|		|		|		|		|
+//		|		|		|		|		|
+//		+-------+-------+-------+-------+
+//		|		|		|		|		|
+//		|		|		|		|		|
+//		|		|		|		|		|
+//		+-------+-------+-------+-------+
+//		|		|		|		|		|
+//		|		|		|		|		|
+//		|		|		|		|		|
+//		+-------+-------+-------+-------+
+//
+//		V0		V1		V2		V3
+//		Edge	Edge	Edge	Edge
+//
+/////////////////////////////////////////////////////////////////////////////
+
+#if defined(_DEBUG) 
+	mov		(1)		EntrySignatureC:w			0xBBBB:w
+#endif	
+	
+
+//========== Luma deblocking ==========
+
+
+//---------- Deblock Y external left edge (V0) ----------	
+
+	cmp.z.f0.0	(8)	null:w	VertEdgePattern:uw		LEFT_FIELD_CUR_FRAME:w
+	cmp.z.f0.1	(8)	null:w	VertEdgePattern:uw		LEFT_FRAME_CUR_FIELD:w
+
+	// Intial set for both are frame or field
+	mov	(16) Mbaff_ALPHA(0,0)<1>	r[ECM_AddrReg, bAlphaLeft0_Y]<0;1,0>:ub
+	mov	(16) Mbaff_BETA(0,0)<1>		r[ECM_AddrReg, bBetaLeft0_Y]<0;1,0>:ub
+	mov (16) Mbaff_TC0(0,0)<1>		r[ECM_AddrReg, bTc0_v00_0_Y]<1;4,0>:ub
+		
+	// For FieldModeCurrentMbFlag=1 && FieldModeLeftMbFlag=0
+	(f0.0) mov (8)	Mbaff_ALPHA(0,0)<2>		r[ECM_AddrReg, bAlphaLeft0_Y]<0;1,0>:ub		{ NoDDClr }
+	(f0.0) mov (8)	Mbaff_ALPHA(0,1)<2>		r[ECM_AddrReg, bAlphaLeft1_Y]<0;1,0>:ub		{ NoDDChk }
+	(f0.0) mov (8)	Mbaff_BETA(0,0)<2>		r[ECM_AddrReg, bBetaLeft0_Y]<0;1,0>:ub		{ NoDDClr }
+	(f0.0) mov (8)	Mbaff_BETA(0,1)<2>		r[ECM_AddrReg, bBetaLeft1_Y]<0;1,0>:ub		{ NoDDChk }
+	(f0.0) mov (8)	Mbaff_TC0(0,0)<2>		r[ECM_AddrReg, bTc0_v00_0_Y]<1;2,0>:ub		{ NoDDClr }
+	(f0.0) mov (8)	Mbaff_TC0(0,1)<2>		r[ECM_AddrReg, bTc0_v00_1_Y]<1;2,0>:ub		{ NoDDChk }
+
+	and.z.f0.0  (1) null:w		r[ECM_AddrReg, BitFlags]:ub		FilterLeftMbEdgeFlag:w		// Check for FilterLeftMbEdgeFlag 
+
+	// For FieldModeCurrentMbFlag=0 && FieldModeLeftMbFlag=1
+	(f0.1) mov (8)	Mbaff_ALPHA(0,0)<1>		r[ECM_AddrReg, bAlphaLeft0_Y]<0;1,0>:ub		{ NoDDClr }
+	(f0.1) mov (8)	Mbaff_ALPHA(0,8)<1>		r[ECM_AddrReg, bAlphaLeft1_Y]<0;1,0>:ub		{ NoDDChk }
+	(f0.1) mov (8)	Mbaff_BETA(0,0)<1>		r[ECM_AddrReg, bBetaLeft0_Y]<0;1,0>:ub		{ NoDDClr }
+	(f0.1) mov (8)	Mbaff_BETA(0,8)<1>		r[ECM_AddrReg, bBetaLeft1_Y]<0;1,0>:ub		{ NoDDChk }
+	(f0.1) mov (8)	Mbaff_TC0(0,0)<1>		r[ECM_AddrReg, bTc0_v00_0_Y]<1;2,0>:ub		{ NoDDClr }
+	(f0.1) mov (8)	Mbaff_TC0(0,8)<1>		r[ECM_AddrReg, bTc0_v00_1_Y]<1;2,0>:ub		{ NoDDChk }
+
+	// Get (alpha >> 2) + 2
+	shr (16) Mbaff_ALPHA2(0,0)<1>	Mbaff_ALPHA(0)		2:w			// alpha >> 2
+
+	//	p3 = Prev MB Y row 0 = r[P_AddrReg, 0]<16;16,1>
+	//	p2 = Prev MB Y row 1 = r[P_AddrReg, 16]<16;16,1>
+	//	p1 = Prev MB Y row 2 = r[P_AddrReg, 32]<16;16,1>
+	//	p0 = Prev MB Y row 3 = r[P_AddrReg, 48]<16;16,1>
+	// 	q0 = Cur MB Y row 0  = r[Q_AddrReg, 0]<16;16,1>
+	//	q1 = Cur MB Y row 1  = r[Q_AddrReg, 16]<16;16,1>
+	//	q2 = Cur MB Y row 2  = r[Q_AddrReg, 32]<16;16,1>
+	//	q3 = Cur MB Y row 3  = r[Q_AddrReg, 48]<16;16,1>
+	mov (1)	P_AddrReg:w		PREV_MB_Y_BASE:w	{ NoDDClr }
+	mov (1)	Q_AddrReg:w		SRC_MB_Y_BASE:w		{ NoDDChk }
+
+	// Set MaskA and MaskB	
+	mov (2)	MaskA<1>:uw		r[ECM_AddrReg, wEdgeCntlMapA_ExtLeftVert0]<2;2,1>:uw
+
+	add (16) Mbaff_ALPHA2(0,0)<1>		Mbaff_ALPHA2(0,0)<16;16,1>		2:w					// alpha2 = (alpha >> 2) + 2  
+
+//	CALL(FILTER_Y_MBAFF, 1)
+	PRED_CALL(-f0.0, FILTER_Y_MBAFF, 1)
+	
+//BYPASS_V0_Y:
+//------------------------------------------------------------------
+
+
+/*
+//---------- Deblock Y external left edge (V0) ----------	
+
+	and.z.f0.0  (1) null:w		r[ECM_AddrReg, BitFlags]:ub		FilterLeftMbEdgeFlag:w		// Check for FilterLeftMbEdgeFlag 
+    (f0.0)	jmpi	ILDB_LABEL(BYPASS_EXT_LEFT_EDGE_Y)	
+
+	// Get vertical border edge control data  
+
+//	mov	(1)	f0.0		0:w
+	and	(1)	CTemp1_W:uw		r[ECM_AddrReg, BitFlags]:ub		FieldModeLeftMbFlag+FieldModeCurrentMbFlag:uw
+	cmp.z.f0.0	(1)	null:w	CTemp1_W:uw		LEFT_FIELD_CUR_FRAME:w
+	(-f0.0) jmpi LEFT_EDGE_Y_NEXT1
+
+	// For FieldModeCurrentMbFlag=1 && FieldModeLeftMbFlag=0
+	mov	(8)	Mbaff_ALPHA(0,0)<2>		r[ECM_AddrReg, bAlphaLeft0_Y]<0;1,0>:ub		{ NoDDClr }
+	mov	(8)	Mbaff_ALPHA(0,1)<2>		r[ECM_AddrReg, bAlphaLeft1_Y]<0;1,0>:ub		{ NoDDChk }
+	mov	(8)	Mbaff_BETA(0,0)<2>		r[ECM_AddrReg, bBetaLeft0_Y]<0;1,0>:ub		{ NoDDClr }
+	mov	(8)	Mbaff_BETA(0,1)<2>		r[ECM_AddrReg, bBetaLeft1_Y]<0;1,0>:ub		{ NoDDChk }
+	mov (8)	Mbaff_TC0(0,0)<2>		r[ECM_AddrReg, bTc0_v00_0_Y]<1;2,0>:ub		{ NoDDClr }
+	mov (8)	Mbaff_TC0(0,1)<2>		r[ECM_AddrReg, bTc0_v00_1_Y]<1;2,0>:ub		{ NoDDChk }
+
+	jmpi	LEFT_EDGE_Y_ALPHA_BETA_TC0_SELECTED
+
+LEFT_EDGE_Y_NEXT1:
+	cmp.z.f0.0	(1)	null:w	CTemp1_W:uw		LEFT_FRAME_CUR_FIELD:w
+	(-f0.0) jmpi LEFT_EDGE_Y_NEXT2
+
+
+	// For FieldModeCurrentMbFlag=0 && FieldModeLeftMbFlag=1
+	mov	(8)	Mbaff_ALPHA(0,0)<1>		r[ECM_AddrReg, bAlphaLeft0_Y]<0;1,0>:ub		{ NoDDClr }
+	mov	(8)	Mbaff_ALPHA(0,8)<1>		r[ECM_AddrReg, bAlphaLeft1_Y]<0;1,0>:ub		{ NoDDChk }
+	mov	(8)	Mbaff_BETA(0,0)<1>		r[ECM_AddrReg, bBetaLeft0_Y]<0;1,0>:ub		{ NoDDClr }
+	mov	(8)	Mbaff_BETA(0,8)<1>		r[ECM_AddrReg, bBetaLeft1_Y]<0;1,0>:ub		{ NoDDChk }
+	mov (8)	Mbaff_TC0(0,0)<1>		r[ECM_AddrReg, bTc0_v00_0_Y]<1;2,0>:ub		{ NoDDClr }
+	mov (8)	Mbaff_TC0(0,8)<1>		r[ECM_AddrReg, bTc0_v00_1_Y]<1;2,0>:ub		{ NoDDChk }
+
+	jmpi	LEFT_EDGE_Y_ALPHA_BETA_TC0_SELECTED
+	
+LEFT_EDGE_Y_NEXT2:
+	// both are frame or field
+	mov	(16) Mbaff_ALPHA(0,0)<1>	r[ECM_AddrReg, bAlphaLeft0_Y]<0;1,0>:ub
+	mov	(16) Mbaff_BETA(0,0)<1>		r[ECM_AddrReg, bBetaLeft0_Y]<0;1,0>:ub
+	mov (16) Mbaff_TC0(0,0)<1>		r[ECM_AddrReg, bTc0_v00_0_Y]<1;4,0>:ub
+
+LEFT_EDGE_Y_ALPHA_BETA_TC0_SELECTED:
+
+	mov (2)	MaskA<1>:uw		r[ECM_AddrReg, wEdgeCntlMapA_ExtLeftVert0]<2;2,1>:uw
+
+	//	p3 = Prev MB Y row 0 = r[P_AddrReg, 0]<16;16,1>
+	//	p2 = Prev MB Y row 1 = r[P_AddrReg, 16]<16;16,1>
+	//	p1 = Prev MB Y row 2 = r[P_AddrReg, 32]<16;16,1>
+	//	p0 = Prev MB Y row 3 = r[P_AddrReg, 48]<16;16,1>
+	// 	q0 = Cur MB Y row 0  = r[Q_AddrReg, 0]<16;16,1>
+	//	q1 = Cur MB Y row 1  = r[Q_AddrReg, 16]<16;16,1>
+	//	q2 = Cur MB Y row 2  = r[Q_AddrReg, 32]<16;16,1>
+	//	q3 = Cur MB Y row 3  = r[Q_AddrReg, 48]<16;16,1>
+	mov (1)	P_AddrReg:w		PREV_MB_Y_BASE:w	{ NoDDClr }
+	mov (1)	Q_AddrReg:w		SRC_MB_Y_BASE:w		{ NoDDChk }
+	
+	// Get (alpha >> 2) + 2
+	shr (16) Mbaff_ALPHA2(0,0)<1>	r[ECM_AddrReg, bAlphaLeft0_Y]<0;1,0>:ub		2:w			// alpha >> 2
+	add (16) Mbaff_ALPHA2(0,0)<1>		Mbaff_ALPHA2(0,0)<16;16,1>		2:w					// alpha2 = (alpha >> 2) + 2  
+	
+	CALL(FILTER_Y_MBAFF, 1)
+
+ILDB_LABEL(BYPASS_EXT_LEFT_EDGE_Y):
+//------------------------------------------------------------------
+*/
+
+	// Same alpha, alpha2, beta and MaskB for all internal edges 
+	
+	// Get (alpha >> 2) + 2
+	shr (16) Mbaff_ALPHA2(0,0)<1>	r[ECM_AddrReg, bAlphaInternal_Y]<0;1,0>:ub		2:w			// alpha >> 2
+	
+	// alpha = bAlphaInternal_Y
+	// beta = bBetaInternal_Y
+	mov	(16) Mbaff_ALPHA(0,0)<1>	r[ECM_AddrReg, bAlphaInternal_Y]<0;1,0>:ub
+	mov	(16) Mbaff_BETA(0,0)<1>		r[ECM_AddrReg, bBetaInternal_Y]<0;1,0>:ub
+
+	mov (1) MaskB:uw	0:w						// Set MaskB = 0 for all 3 edges, so it always uses bS < 4 algorithm.
+
+	add (16) Mbaff_ALPHA2(0,0)<1>		Mbaff_ALPHA2(0,0)<16;16,1>		2:w						// alpha2 = (alpha >> 2) + 2  
+
+//---------- Deblock Y internal left edge (V1) ----------
+
+	// Bypass deblocking if FilterInternal4x4EdgesFlag = 0  
+	and.z.f0.0  (1) null:w		r[ECM_AddrReg, BitFlags]:ub		FilterInternal4x4EdgesFlag:w		// Check for FilterInternal4x4EdgesFlag 
+//    (f0.0)	jmpi	BYPASS_V1_Y
+
+	//	p3 = Cur MB Y row 0 = r[P_AddrReg, 0]<16;16,1>  
+	//	p2 = Cur MB Y row 1 = r[P_AddrReg, 16]<16;16,1>
+	//	p1 = Cur MB Y row 2 = r[P_AddrReg, 32]<16;16,1>
+	//	p0 = Cur MB Y row 3 = r[P_AddrReg, 48]<16;16,1>
+	// 	q0 = Cur MB Y row 4 = r[Q_AddrReg, 0]<16;16,1> 
+	//	q1 = Cur MB Y row 5 = r[Q_AddrReg, 16]<16;16,1>
+	//	q2 = Cur MB Y row 6 = r[Q_AddrReg, 32]<16;16,1>
+	//	q3 = Cur MB Y row 7 = r[Q_AddrReg, 48]<16;16,1>
+	mov (1)	P_AddrReg:w		SRC_MB_Y_BASE:w						{ NoDDClr }
+	mov (1)	Q_AddrReg:w		4*Y_ROW_WIDTH+SRC_MB_Y_BASE:w		{ NoDDChk }
+
+	mov (1)	MaskA:uw	r[ECM_AddrReg, wEdgeCntlMap_IntLeftVert]:uw
+
+	// tc0 has bTc0_v31_Y + bTc0_v21_Y + bTc0_v11_Y + bTc0_v01_Y	
+	mov (16) Mbaff_TC0(0,0)<1>		r[ECM_AddrReg, bTc0_v01_Y]<1;4,0>:ub
+
+//	CALL(FILTER_Y_MBAFF, 1)
+	PRED_CALL(-f0.0, FILTER_Y_MBAFF, 1)
+
+BYPASS_V1_Y:
+//------------------------------------------------------------------
+
+
+//---------- Deblock Y internal mid vert edge (V2) ----------
+
+	// Bypass deblocking if FilterInternal8x8EdgesFlag = 0  
+	and.z.f0.0	(1)	null:w	r[ECM_AddrReg, BitFlags]:ub		FilterInternal8x8EdgesFlag:w		// Check for FilterInternal4x4EdgesFlag 
+//    (f0.0)	jmpi	BYPASS_V2_Y
+
+	//	p3 = Cur MB Y row 4  = r[P_AddrReg, 0]<16;16,1>  
+	//	p2 = Cur MB Y row 5  = r[P_AddrReg, 16]<16;16,1> 
+	//	p1 = Cur MB Y row 6  = r[P_AddrReg, 32]<16;16,1> 
+	//	p0 = Cur MB Y row 7  = r[P_AddrReg, 48]<16;16,1> 
+	// 	q0 = Cur MB Y row 8  = r[Q_AddrReg, 0]<16;16,1>  
+	//	q1 = Cur MB Y row 9  = r[Q_AddrReg, 16]<16;16,1> 
+	//	q2 = Cur MB Y row 10 = r[Q_AddrReg, 32]<16;16,1> 
+	//	q3 = Cur MB Y row 11 = r[Q_AddrReg, 48]<16;16,1> 
+	mov (1)	P_AddrReg:w		4*Y_ROW_WIDTH+SRC_MB_Y_BASE:w		{ NoDDClr }
+	mov (1)	Q_AddrReg:w		8*Y_ROW_WIDTH+SRC_MB_Y_BASE:w		{ NoDDChk }
+
+	mov (1)	MaskA:uw	r[ECM_AddrReg, wEdgeCntlMap_IntMidVert]:uw
+
+	// tc0 has bTc0_v32_Y + bTc0_v22_Y + bTc0_v12_Y + bTc0_v02_Y	
+	mov (16) Mbaff_TC0(0,0)<1>		r[ECM_AddrReg, bTc0_v02_Y]<1;4,0>:ub
+
+//	CALL(FILTER_Y_MBAFF, 1)
+	PRED_CALL(-f0.0, FILTER_Y_MBAFF, 1)
+
+BYPASS_V2_Y:
+//-----------------------------------------------
+
+
+//---------- Deblock Y interal right edge (V3) ----------	 
+
+	// Bypass deblocking if FilterInternal4x4EdgesFlag = 0  
+	and.z.f0.0	(1)	null:w	r[ECM_AddrReg, BitFlags]:ub		FilterInternal4x4EdgesFlag:w		// Check for FilterInternal4x4EdgesFlag 
+//    (f0.0)	jmpi	BYPASS_V3_Y
+
+	//	p3 = Cur MB Y row 8  = r[P_AddrReg, 0]<16;16,1> 
+	//	p2 = Cur MB Y row 9  = r[P_AddrReg, 16]<16;16,1>
+	//	p1 = Cur MB Y row 10 = r[P_AddrReg, 32]<16;16,1>
+	//	p0 = Cur MB Y row 11 = r[P_AddrReg, 48]<16;16,1>
+	// 	q0 = Cur MB Y row 12 = r[Q_AddrReg, 0]<16;16,1> 
+	//	q1 = Cur MB Y row 13 = r[Q_AddrReg, 16]<16;16,1>
+	//	q2 = Cur MB Y row 14 = r[Q_AddrReg, 32]<16;16,1>
+	//	q3 = Cur MB Y row 15 = r[Q_AddrReg, 48]<16;16,1>
+	mov (1)	P_AddrReg:w		8*Y_ROW_WIDTH+SRC_MB_Y_BASE:w		{ NoDDClr }
+	mov (1)	Q_AddrReg:w		12*Y_ROW_WIDTH+SRC_MB_Y_BASE:w		{ NoDDChk }
+	
+	mov (1)	MaskA:uw	r[ECM_AddrReg, wEdgeCntlMap_IntRightVert]:uw
+
+	// tc0 has bTc0_v33_Y + bTc0_v23_Y + bTc0_v13_Y + bTc0_v03_Y
+	mov (16) Mbaff_TC0(0,0)<1>		r[ECM_AddrReg, bTc0_v03_Y]<1;4,0>:ub
+
+//	CALL(FILTER_Y_MBAFF, 1)
+	PRED_CALL(-f0.0, FILTER_Y_MBAFF, 1)
+
+BYPASS_V3_Y:
+//-----------------------------------------------
diff --git a/i965_drv_video/shaders/h264/ildb/AVC_ILDB_Filter_UV_h.asm b/i965_drv_video/shaders/h264/ildb/AVC_ILDB_Filter_UV_h.asm
new file mode 100644
index 0000000..168df0f
--- /dev/null
+++ b/i965_drv_video/shaders/h264/ildb/AVC_ILDB_Filter_UV_h.asm
@@ -0,0 +1,145 @@
+/*
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+////////// AVC ILDB filter horizontal UV ///////////////////////////////////////////////////////
+//
+//	This filter code prepares the src data and control data for ILDB filtering on all horizontal edges of UV.
+//
+//	It sssumes the data for horizontal de-blocking is already transposed.  
+//
+//		Chroma:
+//
+//		+-------+-------+		H0 Edge
+//		|		|		|
+//		|		|		|
+//		|		|		|
+//		+-------+-------+		H1 Edge
+//		|		|		|
+//		|		|		|
+//		|		|		|
+//		+-------+-------+
+//
+/////////////////////////////////////////////////////////////////////////////
+
+#if defined(_DEBUG) 
+	mov		(1)		EntrySignatureC:w			0xBBBC:w
+#endif	
+
+//=============== Chroma deblocking ================
+
+//---------- Deblock U external top edge ----------
+	and.z.f0.0  (1) null:w		r[ECM_AddrReg, BitFlags]:ub		FilterTopMbEdgeFlag:w		// Check for FilterTopMbEdgeFlag 
+//    (f0.0)	jmpi	BYPASS_EXT_TOP_EDGE_UV	
+
+	// Get horizontal border edge control data.
+	
+	//***** Need to take every other bit to form U maskA and mask B
+	// Get Luma maskA and maskB	
+	shr (16)	TempRow0(0)<1>		r[ECM_AddrReg, wEdgeCntlMapA_ExtTopHorz0]<0;1,0>:uw		RRampW(0)
+	shr (16)	TempRow1(0)<1>		r[ECM_AddrReg, wEdgeCntlMapB_ExtTopHorz0]<0;1,0>:uw		RRampW(0)
+		
+    (f0.0)	jmpi	ILDB_LABEL(BYPASS_EXT_TOP_EDGE_UV)			
+
+	// Extract UV MaskA and MaskB from every other bit of Y masks
+	and.nz.f0.0 (8) null:w			TempRow0(0)<16;8,2>		1:w
+	and.nz.f0.1 (8) null:w			TempRow1(0)<16;8,2>		1:w
+
+//---------- Deblock U external edge ----------
+	//	p1 = Prev MB U row 0
+	//	p0 = Prev MB U row 1
+	// 	q0 = Cur MB U row 0
+	//	q1 = Cur MB U row 1
+//	mov (1)	P_AddrReg:w		PREV_MB_U_BASE:w									{ NoDDClr }
+	mov (1)	P_AddrReg:w		TOP_MB_U_BASE:w										{ NoDDClr }
+	mov (1)	Q_AddrReg:w		SRC_MB_U_BASE:w										{ NoDDChk }
+
+	// alpha = bAlphaTop0_Cb, beta = bBetaTop0_Cb
+	mov	(2)	alpha<1>:w	r[ECM_AddrReg, bAlphaTop0_Cb]<2;2,1>:ub					{ NoDDClr } 
+	// tc0 has bTc0_h03_0_Cb + bTc0_h02_0_Cb + bTc0_h01_0_Cb + bTc0_h00_0_Cb
+	mov (4)	tc0<1>:ub	r[ECM_AddrReg, bTc0_h00_0_Cb]<4;4,1>:ub					{ NoDDChk } 
+		
+	// UV MaskA and MaskB
+	mov (2)		MaskA<1>:uw			f0.0<2;2,1>:uw
+
+	CALL(FILTER_UV, 1)	
+
+//---------- Deblock V external top edge ----------
+	//	p1 = Prev MB V row 0
+	//	p0 = Prev MB V row 1
+	// 	q0 = Cur MB V row 0
+	//	q1 = Cur MB V row 1
+//	mov (1)	P_AddrReg:w		PREV_MB_V_BASE:w		{ NoDDClr }
+	mov (1)	P_AddrReg:w		TOP_MB_V_BASE:w		{ NoDDClr }
+	mov (1)	Q_AddrReg:w		SRC_MB_V_BASE:w			{ NoDDChk }
+
+	// alpha = bAlphaTop0_Cr, beta = bBetaTop0_Cr
+	mov	(2)	alpha<1>:w	r[ECM_AddrReg, bAlphaTop0_Cr]<2;2,1>:ub		{ NoDDClr }
+	
+	// tc0 has bTc0_h03_0_Cr + bTc0_h02_0_Cr + bTc0_h01_0_Cr + bTc0_h00_0_Cr
+	mov (4)	tc0<1>:ub	r[ECM_AddrReg, bTc0_h00_0_Cr]<4;4,1>:ub		{ NoDDChk }
+
+	// UV MaskA and MaskB
+	mov (2)		f0.0<1>:uw		MaskA<2;2,1>:uw
+
+	CALL(FILTER_UV, 1)	
+
+ILDB_LABEL(BYPASS_EXT_TOP_EDGE_UV):
+
+	// Set EdgeCntlMap2 = 0, so it always uses bS < 4 algorithm.
+
+	// Bypass deblocking if FilterInternal4x4EdgesFlag = 0  
+//	and.z.f0.0 (1) null:w	r[ECM_AddrReg, BitFlags]:ub		FilterInternal4x4EdgesFlag:w		// Check for FilterInternal4x4EdgesFlag 
+//    (f0.0)	jmpi	BYPASS_4x4_DEBLOCK_H
+
+//---------- Deblock U internal horz middle edge ----------
+
+	//***** Need to take every other bit to form U maskA
+	// Get Luma maskA and maskB	
+	shr (16)	TempRow0(0)<1>		r[ECM_AddrReg, wEdgeCntlMap_IntMidHorz]<0;1,0>:uw		RRampW(0)
+
+	//	p1 = Cur MB U row 2
+	//	p0 = Cur MB U row 3
+	// 	q0 = Cur MB U row 4
+	//	q1 = Cur MB U row 5
+	mov (1)	P_AddrReg:w		4*UV_ROW_WIDTH+SRC_MB_U_BASE:w					{ NoDDClr }		// Skip 2 U rows and 2 V rows
+	mov (1)	Q_AddrReg:w		8*UV_ROW_WIDTH+SRC_MB_U_BASE:w					{ NoDDChk }
+
+	// alpha = bAlphaInternal_Cb, beta = bBetaInternal_Cb
+	mov	(2)	alpha<1>:w	r[ECM_AddrReg, bAlphaInternal_Cb]<2;2,1>:ub 		{ NoDDClr }
+	// tc0 has bTc0_h23_Cb + bTc0_h22_Cb + bTc0_h21_Cb + bTc0_h20_Cb		
+	mov (4)	tc0<1>:ub	r[ECM_AddrReg, bTc0_h20_Cb]<4;4,1>:ub				{ NoDDChk }
+
+	// Extract UV MaskA and MaskB from every other bit of Y masks
+	and.nz.f0.0 (8) null:w			TempRow0(0)<16;8,2>		1:w
+
+	// UV MaskA and MaskB
+	mov (1) f0.1:uw		0:w
+	mov (1)	MaskB:uw	0:w													{ NoDDClr }
+	mov (1)	MaskA:uw	f0.0:uw												{ NoDDChk }
+
+	CALL(FILTER_UV, 1)	
+
+//---------- Deblock V internal horz middle edge ----------
+	//	p1 = Cur MB V row 2
+	//	p0 = Cur MB V row 3
+	// 	q0 = Cur MB V row 4
+	//	q1 = Cur MB V row 5
+	mov (1)	P_AddrReg:w		4*UV_ROW_WIDTH+SRC_MB_V_BASE:w					{ NoDDClr }		// Skip 2 U rows and 2 V rows
+	mov (1)	Q_AddrReg:w		8*UV_ROW_WIDTH+SRC_MB_V_BASE:w					{ NoDDChk }
+
+	// alpha = bAlphaInternal_Cr, beta = bBetaInternal_Cr
+	mov	(2)	alpha<1>:w	r[ECM_AddrReg, bAlphaInternal_Cr]<2;2,1>:ub 		{ NoDDClr }
+	// tc0 has bTc0_h23_Cr + bTc0_h22_Cr + bTc0_h21_Cr + bTc0_h20_Cr
+	mov (4)	tc0<1>:ub	r[ECM_AddrReg, bTc0_h20_Cr]<4;4,1>:ub				{ NoDDChk }
+
+	// UV MaskA and MaskB
+	mov (2)		f0.0<1>:uw		MaskA<2;2,1>:uw
+
+	CALL(FILTER_UV, 1)	
+
+//BYPASS_4x4_DEBLOCK_H:
diff --git a/i965_drv_video/shaders/h264/ildb/AVC_ILDB_Filter_UV_v.asm b/i965_drv_video/shaders/h264/ildb/AVC_ILDB_Filter_UV_v.asm
new file mode 100644
index 0000000..8d331a0
--- /dev/null
+++ b/i965_drv_video/shaders/h264/ildb/AVC_ILDB_Filter_UV_v.asm
@@ -0,0 +1,145 @@
+/*
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+////////// AVC LDB filter vertical UV ///////////////////////////////////////////////////////
+//
+//	This filter code prepares the src data and control data for ILDB filtering on all vertical edges of UV.
+//
+//	It sssumes the data for vertical de-blocking is already transposed.  
+//
+//		Chroma:
+//
+//		+-------+-------+
+//		|		|		|
+//		|		|		|
+//		|		|		|
+//		+-------+-------+
+//		|		|		|
+//		|		|		|
+//		|		|		|
+//		+-------+-------+
+//
+//		V0		V1		
+//		Edge	Edge	
+//
+/////////////////////////////////////////////////////////////////////////////
+
+#if defined(_DEBUG) 
+	mov		(1)		EntrySignatureC:w			0xBBBC:w
+#endif	
+
+//=============== Chroma deblocking ================
+
+	and.z.f0.0  (1) null:w		r[ECM_AddrReg, BitFlags]:ub		FilterLeftMbEdgeFlag:w		// Check for FilterLeftMbEdgeFlag 
+//    (f0.0)	jmpi	BYPASS_EXT_LEFT_EDGE_UV	
+ 
+	// Get vertical border edge control data.  
+	
+	// Get Luma maskA and maskB	
+	shr (16)	TempRow0(0)<1>		r[ECM_AddrReg, wEdgeCntlMapA_ExtLeftVert0]<0;1,0>:uw		RRampW(0)
+	shr (16)	TempRow1(0)<1>		r[ECM_AddrReg, wEdgeCntlMapB_ExtLeftVert0]<0;1,0>:uw		RRampW(0)
+	
+    (f0.0)	jmpi	ILDB_LABEL(BYPASS_EXT_LEFT_EDGE_UV)
+
+	// Extract UV MaskA and MaskB from every other bit of Y masks
+	and.nz.f0.0 (8) null:w			TempRow0(0)<16;8,2>		1:w
+	and.nz.f0.1 (8) null:w			TempRow1(0)<16;8,2>		1:w
+
+//---------- Deblock U external edge ----------
+	//	p1 = Prev MB U row 0
+	//	p0 = Prev MB U row 1
+	// 	q0 = Cur MB U row 0
+	//	q1 = Cur MB U row 1
+	mov (1)	P_AddrReg:w		PREV_MB_U_BASE:w									{ NoDDClr }
+	mov (1)	Q_AddrReg:w		SRC_MB_U_BASE:w										{ NoDDChk }
+
+	// alpha = bAlphaLeft0_Cb, beta = bBetaLeft0_Cb
+	mov	(2)	alpha<1>:w	r[ECM_AddrReg, bAlphaLeft0_Cb]<2;2,1>:ub				{ NoDDClr }
+	// tc0 has bTc0_v30_0_Cb + bTc0_v20_0_Cb + bTc0_v10_0_Cb + bTc0_v00_0_Cb
+	mov (4)	tc0<1>:ub	r[ECM_AddrReg, bTc0_v00_0_Cb]<4;4,1>:ub					{ NoDDChk }
+	
+	// UV MaskA and MaskB
+	mov (2)		MaskA<1>:uw			f0.0<2;2,1>:uw
+
+	CALL(FILTER_UV, 1)	
+
+//---------- Deblock V external edge ----------
+	//	p1 = Prev MB V row 0
+	//	p0 = Prev MB V row 1
+	// 	q0 = Cur MB V row 0
+	//	q1 = Cur MB V row 1
+	mov (1)	P_AddrReg:w		PREV_MB_V_BASE:w									{ NoDDClr }		
+	mov (1)	Q_AddrReg:w		SRC_MB_V_BASE:w										{ NoDDChk }
+
+	// for vert edge: alpha = bAlphaLeft0_Cr, beta = bBetaLeft0_Cr
+	mov	(2)	alpha<1>:w	r[ECM_AddrReg, bAlphaLeft0_Cr]<2;2,1>:ub				{ NoDDClr }
+	
+	// tc0 has bTc0_v30_0_Cr + bTc0_v20_0_Cr + bTc0_v10_0_Cr + bTc0_v00_0_Cr
+	mov (4)	tc0<1>:ub	r[ECM_AddrReg, bTc0_v00_0_Cr]<4;4,1>:ub					{ NoDDChk }
+
+	// UV MaskA and MaskB
+	mov (2)		f0.0<1>:uw		MaskA<2;2,1>:uw
+
+	CALL(FILTER_UV, 1)	
+
+
+ILDB_LABEL(BYPASS_EXT_LEFT_EDGE_UV):
+	// Set EdgeCntlMap2 = 0, so it always uses bS < 4 algorithm.
+	// Same alpha and beta for all internal vert and horiz edges 
+
+
+	//***** Need to take every other bit to form U or V maskA
+	// Get Luma maskA and maskB	
+	shr (16)	TempRow0(0)<1>		r[ECM_AddrReg, wEdgeCntlMap_IntMidVert]<0;1,0>:uw		RRampW(0)
+
+//---------- Deblock U internal edge ----------
+	//	p1 = Cur MB U row 2
+	//	p0 = Cur MB U row 3
+	// 	q0 = Cur MB U row 4
+	//	q1 = Cur MB U row 5
+	mov (1)	P_AddrReg:w		4*UV_ROW_WIDTH+SRC_MB_U_BASE:w					{ NoDDClr }
+	mov (1)	Q_AddrReg:w		8*UV_ROW_WIDTH+SRC_MB_U_BASE:w					{ NoDDChk }
+
+	// alpha = bAlphaInternal_Cb, beta = bBetaInternal_Cb
+	mov	(2)	alpha<1>:w	r[ECM_AddrReg, bAlphaInternal_Cb]<2;2,1>:ub 		{ NoDDClr }
+
+	// tc0 has bTc0_v32_Cb + bTc0_v22_Cb + bTc0_v12_Cb + bTc0_v02_Cb	
+	mov (4)	tc0<1>:ub	r[ECM_AddrReg, bTc0_v02_Cb]<4;4,1>:ub				{ NoDDChk }
+
+	// Extract UV MaskA and MaskB from every other bit of Y masks
+	and.nz.f0.0 (8) null:w			TempRow0(0)<16;8,2>		1:w
+
+	// UV MaskA and MaskB
+	mov (1) f0.1:uw		0:w
+	mov (1)	MaskB:uw	0:w													{ NoDDClr }
+	mov (1)	MaskA:uw	f0.0:uw												{ NoDDChk }
+	
+	CALL(FILTER_UV, 1)	
+
+
+//---------- Deblock V internal edge ----------
+	//	P1 = Cur MB V row 2
+	//	P0 = Cur MB V row 3
+	// 	Q0 = Cur MB V row 4
+	//	Q1 = Cur MB V row 5
+	mov (1)	P_AddrReg:w		4*UV_ROW_WIDTH+SRC_MB_V_BASE:w					{ NoDDClr }
+	mov (1)	Q_AddrReg:w		8*UV_ROW_WIDTH+SRC_MB_V_BASE:w					{ NoDDChk }
+
+	// alpha = bAlphaInternal_Cr, beta = bBetaInternal_Cr
+	mov	(2)	alpha<1>:w	r[ECM_AddrReg, bAlphaInternal_Cr]<2;2,1>:ub 		{ NoDDClr }	
+
+	// tc0 has bTc0_v32_Cr + bTc0_v22_Cr + bTc0_v12_Cr + bTc0_v02_Cr	
+	mov (4)	tc0<1>:ub	r[ECM_AddrReg, bTc0_v02_Cr]<4;4,1>:ub				{ NoDDChk }
+
+	// UV MaskA and MaskB
+	mov (2)		f0.0<1>:uw		MaskA<2;2,1>:uw
+
+	CALL(FILTER_UV, 1)	
+
+
+//BYPASS_4x4_DEBLOCK_V:
diff --git a/i965_drv_video/shaders/h264/ildb/AVC_ILDB_Filter_Y_h.asm b/i965_drv_video/shaders/h264/ildb/AVC_ILDB_Filter_Y_h.asm
new file mode 100644
index 0000000..45ab4df
--- /dev/null
+++ b/i965_drv_video/shaders/h264/ildb/AVC_ILDB_Filter_Y_h.asm
@@ -0,0 +1,199 @@
+/*
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+////////// AVC ILDB filter horizontal Y ///////////////////////////////////////////////////////
+//
+//	This filter code prepares the src data and control data for ILDB filtering on all horizontal edges of Y.
+//
+//	It sssumes the data for horizontal de-blocking is already transposed.  
+//
+//		Luma:
+//
+//		+-------+-------+-------+-------+		H0  Edge
+//		|		|		|		|		|
+//		|		|		|		|		|
+//		|		|		|		|		|
+//		+-------+-------+-------+-------+		H1 Edge
+//		|		|		|		|		|
+//		|		|		|		|		|
+//		|		|		|		|		|
+//		+-------+-------+-------+-------+		H2	Edge
+//		|		|		|		|		|
+//		|		|		|		|		|
+//		|		|		|		|		|
+//		+-------+-------+-------+-------+		H3 Edge
+//		|		|		|		|		|
+//		|		|		|		|		|
+//		|		|		|		|		|
+//		+-------+-------+-------+-------+
+//
+/////////////////////////////////////////////////////////////////////////////
+
+#if defined(_DEBUG) 
+	mov		(1)		EntrySignatureC:w			0xBBBB:w
+#endif	
+	
+
+//========== Luma deblocking ==========
+
+
+//---------- Deblock Y external top edge (H0)  ----------	
+
+	// Bypass deblocking if it is the top edge of the picture.  
+	and.z.f0.0  (1) null:w		r[ECM_AddrReg, BitFlags]:ub		FilterTopMbEdgeFlag:w		// Check for FilterTopMbEdgeFlag 
+
+//	and.z.f0.1 (1)	null:uw		r[ECM_AddrReg, wEdgeCntlMapA_ExtTopHorz0]:uw		0xFFFF:uw	// MaskA = 0? 
+
+	// Get (alpha >> 2) + 2
+	shr (1) alpha2:w		r[ECM_AddrReg, bAlphaTop0_Y]:ub		2:w			// alpha >> 2
+
+	//	p3 = Prev MB Y row 0 = r[P_AddrReg, 0]<16;16,1> 
+	//	p2 = Prev MB Y row 1 = r[P_AddrReg, 16]<16;16,1>
+	//	p1 = Prev MB Y row 2 = r[P_AddrReg, 32]<16;16,1>
+	//	p0 = Prev MB Y row 3 = r[P_AddrReg, 48]<16;16,1>
+	// 	q0 = Cur MB Y row 0  = r[Q_AddrReg, 0]<16;16,1> 
+	//	q1 = Cur MB Y row 1  = r[Q_AddrReg, 16]<16;16,1>
+	//	q2 = Cur MB Y row 2  = r[Q_AddrReg, 32]<16;16,1>
+	//	q3 = Cur MB Y row 3  = r[Q_AddrReg, 48]<16;16,1>
+//	mov (1)	P_AddrReg:w		PREV_MB_Y_BASE:w		{ NoDDClr }
+	mov (1)	P_AddrReg:w		TOP_MB_Y_BASE:w		{ NoDDClr }
+	mov (1)	Q_AddrReg:w		SRC_MB_Y_BASE:w         { NoDDChk }
+	
+	// Get horizontal border edge control data
+	// alpha = bAlphaTop0_Y 
+	// beta = bBetaTop0_Y
+	mov	(2)	alpha<1>:w	r[ECM_AddrReg, bAlphaTop0_Y]<2;2,1>:ub			{ NoDDClr }		// 2 channels for alpha and beta
+	
+	mov (2)	MaskA<1>:uw	r[ECM_AddrReg, wEdgeCntlMapA_ExtTopHorz0]<2;2,1>:uw		{ NoDDClr, NoDDChk }
+
+	// tc0 has bTc0_h03_0_Y | bTc0_h02_0_Y | bTc0_h01_0_Y | bTc0_h00_0_Y
+	mov (4)	tc0<1>:ub	r[ECM_AddrReg, bTc0_h00_0_Y]<4;4,1>:ub			{ NoDDChk }
+
+//    (f0.0)	jmpi	BYPASS_EXT_TOP_EDGE_Y	
+//	(f0.0.anyv)	 jmpi	BYPASS_EXT_TOP_EDGE_Y
+	
+	add (1) alpha2:w		alpha2:w		2:w								// alpha2 = (alpha >> 2) + 2  
+		
+//	CALL(FILTER_Y, 1)
+	PRED_CALL(-f0.0, FILTER_Y, 1)
+
+//BYPASS_EXT_TOP_EDGE_Y:
+//------------------------------------------------------------------
+	// Same alpha, alpha2, beta and MaskB for all internal edges 
+
+	// Get (alpha >> 2) + 2
+	shr (1) alpha2:w		r[ECM_AddrReg, bAlphaInternal_Y]:ub		2:w			// alpha >> 2
+
+	// alpha = bAlphaInternal_Y 
+	// beta = bBetaInternal_Y
+	mov	(2)	alpha<1>:w	r[ECM_AddrReg, bAlphaInternal_Y]<2;2,1>:ub 		{ NoDDClr }
+
+	// Set MaskB = 0 for all 3 int edges, so it always uses bS < 4 algorithm.
+	mov (1) MaskB:uw	0:w						                        { NoDDChk }
+
+	add (1) alpha2:w		alpha2:w		2:w								// alpha2 = (alpha >> 2) + 2  
+		
+
+//---------- Deblock Y internal top edge (H1)  ----------
+
+	// Bypass deblocking if FilterInternal4x4EdgesFlag = 0  
+	and.z.f0.0 (1) null:w	r[ECM_AddrReg, BitFlags]:ub		FilterInternal4x4EdgesFlag:w		// Check for FilterInternal4x4EdgesFlag 
+
+	//	p3 = Cur MB Y row 0 = r[P_AddrReg, 0]<16;16,1> 
+	//	p2 = Cur MB Y row 1 = r[P_AddrReg, 16]<16;16,1>
+	//	p1 = Cur MB Y row 2 = r[P_AddrReg, 32]<16;16,1>
+	//	p0 = Cur MB Y row 3 = r[P_AddrReg, 48]<16;16,1>
+	// 	q0 = Cur MB Y row 4 = r[Q_AddrReg, 0]<16;16,1> 
+	//	q1 = Cur MB Y row 5 = r[Q_AddrReg, 16]<16;16,1>
+	//	q2 = Cur MB Y row 6 = r[Q_AddrReg, 32]<16;16,1>
+	//	q3 = Cur MB Y row 7 = r[Q_AddrReg, 48]<16;16,1>
+	mov (1)	P_AddrReg:w		SRC_MB_Y_BASE:w					{ NoDDClr }
+	mov (1)	Q_AddrReg:w		4*Y_ROW_WIDTH+SRC_MB_Y_BASE:w   { NoDDChk }
+
+	mov (1)	MaskA:uw	r[ECM_AddrReg, wEdgeCntlMap_IntTopHorz]:uw		{ NoDDClr }
+	
+	// tc0 has bTc0_h13_Y + bTc0_h12_Y + bTc0_h11_Y + bTc0_h10_Y		
+	mov (4)	tc0<1>:ub	r[ECM_AddrReg, bTc0_h10_Y]<4;4,1>:ub			{ NoDDChk }
+
+//    (f0.0)	jmpi	BYPASS_4x4_DEBLOCK_H
+//	(f0.0.anyv)	 jmpi	BYPASS_4x4_DEBLOCK_H
+
+//	CALL(FILTER_Y, 1)
+	PRED_CALL(-f0.0, FILTER_Y, 1)
+
+//BYPASS_4x4_DEBLOCK_H:
+//------------------------------------------------------------------
+
+
+//---------- Deblock Y internal mid horizontal edge (H2) ----------
+
+	// Bypass deblocking if FilterInternal8x8EdgesFlag = 0  
+	and.z.f0.0 (1) null:w	r[ECM_AddrReg, BitFlags]:ub		FilterInternal8x8EdgesFlag:w		// Check for FilterInternal4x4EdgesFlag 
+
+//	and.z.f0.1 (1)	null:uw		r[ECM_AddrReg, wEdgeCntlMap_IntMidHorz]:uw		0xFFFF:uw	// MaskA = 0? 
+
+	//	p3 = Cur MB Y row 4  = r[P_AddrReg, 0]<16;16,1> 
+	//	p2 = Cur MB Y row 5  = r[P_AddrReg, 16]<16;16,1>
+	//	p1 = Cur MB Y row 6  = r[P_AddrReg, 32]<16;16,1>
+	//	p0 = Cur MB Y row 7  = r[P_AddrReg, 48]<16;16,1>
+	// 	q0 = Cur MB Y row 8  = r[Q_AddrReg, 0]<16;16,1> 
+	//	q1 = Cur MB Y row 9  = r[Q_AddrReg, 16]<16;16,1>
+	//	q2 = Cur MB Y row 10 = r[Q_AddrReg, 32]<16;16,1>
+	//	q3 = Cur MB Y row 11 = r[Q_AddrReg, 48]<16;16,1>
+	mov (1)	P_AddrReg:w		4*Y_ROW_WIDTH+SRC_MB_Y_BASE:w      { NoDDClr }
+	mov (1)	Q_AddrReg:w		8*Y_ROW_WIDTH+SRC_MB_Y_BASE:w      { NoDDChk }
+
+	mov (1)	MaskA:uw	r[ECM_AddrReg, wEdgeCntlMap_IntMidHorz]:uw      { NoDDClr }
+//	mov (1) MaskB:uw	0:w						// Set MaskB = 0, so it always uses bS < 4 algorithm.
+
+	// tc0 has bTc0_h23_Y + bTc0_h22_Y + bTc0_h21_Y + bTc0_h20_Y		
+	mov (4)	tc0<1>:ub	r[ECM_AddrReg, bTc0_h20_Y]<4;4,1>:ub			{ NoDDChk }
+
+//    (f0.0)	jmpi	BYPASS_8x8_DEBLOCK_H
+//	(f0.0.anyv)	 jmpi	BYPASS_8x8_DEBLOCK_H
+   
+//	CALL(FILTER_Y, 1)
+	PRED_CALL(-f0.0, FILTER_Y, 1)
+
+//BYPASS_8x8_DEBLOCK_H:
+//-----------------------------------------------
+
+
+//---------- Deblock Y internal bottom edge (H3) ----------	 
+
+	// Bypass deblocking if FilterInternal4x4EdgesFlag = 0  
+	and.z.f0.0 (1) null:w	r[ECM_AddrReg, BitFlags]:ub		FilterInternal4x4EdgesFlag:w		// Check for FilterInternal4x4EdgesFlag 
+
+//	and.z.f0.1 (1)	null:uw		r[ECM_AddrReg, wEdgeCntlMap_IntBotHorz]:uw		0xFFFF:uw	// MaskA = 0? 
+
+	//	p3 = Cur MB Y row 8  = r[P_AddrReg, 0]<16;16,1> 
+	//	p2 = Cur MB Y row 9  = r[P_AddrReg, 16]<16;16,1>
+	//	p1 = Cur MB Y row 10 = r[P_AddrReg, 32]<16;16,1>
+	//	p0 = Cur MB Y row 11 = r[P_AddrReg, 48]<16;16,1>
+	// 	q0 = Cur MB Y row 12 = r[Q_AddrReg, 0]<16;16,1> 
+	//	q1 = Cur MB Y row 13 = r[Q_AddrReg, 16]<16;16,1>
+	//	q2 = Cur MB Y row 14 = r[Q_AddrReg, 32]<16;16,1>
+	//	q3 = Cur MB Y row 15 = r[Q_AddrReg, 48]<16;16,1>
+	mov (1)	P_AddrReg:w		8*Y_ROW_WIDTH+SRC_MB_Y_BASE:w		{ NoDDClr } 
+	mov (1)	Q_AddrReg:w		12*Y_ROW_WIDTH+SRC_MB_Y_BASE:w      { NoDDChk } 
+
+	
+	mov (1)	MaskA:uw	r[ECM_AddrReg, wEdgeCntlMap_IntBotHorz]:uw      { NoDDClr }
+//	mov (1) MaskB:uw	0:w						// Set MaskB = 0, so it always uses bS < 4 algorithm.
+
+	// tc0 has bTc0_h33_Y + bTc0_h32_Y + bTc0_h31_Y + bTc0_h30_Y         
+	mov (4)	tc0<1>:ub	r[ECM_AddrReg, bTc0_h30_Y]<4;4,1>:ub			{ NoDDChk }
+
+//    (f0.0)	jmpi	BYPASS_4x4_DEBLOCK_H2
+//	(f0.0.anyv)	 jmpi	BYPASS_4x4_DEBLOCK_H2
+    
+//	CALL(FILTER_Y, 1)
+	PRED_CALL(-f0.0, FILTER_Y, 1)
+
+//BYPASS_4x4_DEBLOCK_H2:
+//-----------------------------------------------
diff --git a/i965_drv_video/shaders/h264/ildb/AVC_ILDB_Filter_Y_v.asm b/i965_drv_video/shaders/h264/ildb/AVC_ILDB_Filter_Y_v.asm
new file mode 100644
index 0000000..9d6bf0a
--- /dev/null
+++ b/i965_drv_video/shaders/h264/ildb/AVC_ILDB_Filter_Y_v.asm
@@ -0,0 +1,203 @@
+/*
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+////////// AVC ILDB filter vertical Y ///////////////////////////////////////////////////////
+//
+//	This filter code prepares the src data and control data for ILDB filtering on all vertical edges of Y.
+//
+//	It sssumes the data for vertical de-blocking is already transposed.  
+//
+//		Luma:
+//
+//		+-------+-------+-------+-------+
+//		|		|		|		|		|
+//		|		|		|		|		|
+//		|		|		|		|		|
+//		+-------+-------+-------+-------+
+//		|		|		|		|		|
+//		|		|		|		|		|
+//		|		|		|		|		|
+//		+-------+-------+-------+-------+
+//		|		|		|		|		|
+//		|		|		|		|		|
+//		|		|		|		|		|
+//		+-------+-------+-------+-------+
+//		|		|		|		|		|
+//		|		|		|		|		|
+//		|		|		|		|		|
+//		+-------+-------+-------+-------+
+//
+//		V0		V1		V2		V3
+//		Edge	Edge	Edge	Edge
+//
+/////////////////////////////////////////////////////////////////////////////
+
+#if defined(_DEBUG) 
+	mov		(1)		EntrySignatureC:w			0xBBBB:w
+#endif	
+	
+
+//========== Luma deblocking ==========
+
+
+//---------- Deblock Y external left edge (V0) ----------	
+
+	// Bypass deblocking if it is left edge of the picture.  
+	and.z.f0.0  (1) null:w		r[ECM_AddrReg, BitFlags]:ub		FilterLeftMbEdgeFlag:w		// Check for FilterLeftMbEdgeFlag 
+
+//	and.z.f0.1 (1)	null:uw		r[ECM_AddrReg, wEdgeCntlMapA_ExtLeftVert0]:uw		0xFFFF:uw	// MaskA = 0? 
+
+	// Get (alpha >> 2) + 2
+	shr (1) alpha2:w		r[ECM_AddrReg, bAlphaLeft0_Y]:ub		2:w			// alpha >> 2
+
+	//	p3 = Prev MB Y row 0 = r[P_AddrReg, 0]<16;16,1>
+	//	p2 = Prev MB Y row 1 = r[P_AddrReg, 16]<16;16,1>
+	//	p1 = Prev MB Y row 2 = r[P_AddrReg, 32]<16;16,1>
+	//	p0 = Prev MB Y row 3 = r[P_AddrReg, 48]<16;16,1>
+	// 	q0 = Cur MB Y row 0  = r[Q_AddrReg, 0]<16;16,1>
+	//	q1 = Cur MB Y row 1  = r[Q_AddrReg, 16]<16;16,1>
+	//	q2 = Cur MB Y row 2  = r[Q_AddrReg, 32]<16;16,1>
+	//	q3 = Cur MB Y row 3  = r[Q_AddrReg, 48]<16;16,1>
+	mov (1)	P_AddrReg:w		PREV_MB_Y_BASE:w		{ NoDDClr }
+	mov (1)	Q_AddrReg:w		SRC_MB_Y_BASE:w			{ NoDDChk }
+	
+	// Get vertical border edge control data  
+	// alpha = bAlphaLeft0_Y 
+	// beta = bBetaLeft0_Y
+	mov	(2)	alpha<1>:w	r[ECM_AddrReg, bAlphaLeft0_Y]<2;2,1>:ub			{ NoDDClr }		// 2 channels for alpha and beta
+
+	mov (2)	MaskA<1>:uw	r[ECM_AddrReg, wEdgeCntlMapA_ExtLeftVert0]<2;2,1>:uw	{ NoDDClr, NoDDChk }
+	
+	// tc0 has bTc0_v30_0_Y | bTc0_v20_0_Y | bTc0_v10_0_Y | bTc0_v00_0_Y
+	mov (4)	tc0<1>:ub	r[ECM_AddrReg, bTc0_v00_0_Y]<4;4,1>:ub			{ NoDDChk }
+
+//	(f0.0)	jmpi	BYPASS_EXT_LEFT_EDGE_Y	
+//	(f0.0.anyv)	 jmpi	BYPASS_EXT_LEFT_EDGE_Y
+		
+	add (1) alpha2:w		alpha2:w		2:w								// alpha2 = (alpha >> 2) + 2  
+		
+//	CALL(FILTER_Y, 1)
+	PRED_CALL(-f0.0, FILTER_Y, 1)
+
+
+//BYPASS_EXT_LEFT_EDGE_Y:
+//------------------------------------------------------------------
+	// Same alpha, alpha2, beta and MaskB for all internal edges 
+
+	// Get (alpha >> 2) + 2
+	shr (1) alpha2:w		r[ECM_AddrReg, bAlphaInternal_Y]:ub		2:w			// alpha >> 2
+
+	// alpha = bAlphaInternal_Y
+	// beta = bBetaInternal_Y
+	mov	(2)	alpha<1>:w	r[ECM_AddrReg, bAlphaInternal_Y]<2;2,1>:ub 		{ NoDDClr }
+
+	// Set MaskB = 0 for all 3 int edges, so it always uses bS < 4 algorithm.
+	mov (1) MaskB:uw	0:w												{ NoDDChk }
+
+	add (1) alpha2:w		alpha2:w		2:w								// alpha2 = (alpha >> 2) + 2  
+
+
+//---------- Deblock Y internal left edge (V1) ----------
+
+	// Bypass deblocking if FilterInternal4x4EdgesFlag = 0  
+	and.z.f0.0  (1) null:w		r[ECM_AddrReg, BitFlags]:ub		FilterInternal4x4EdgesFlag:w		// Check for FilterInternal4x4EdgesFlag 
+
+//	and.z.f0.1 (1)	null:uw		r[ECM_AddrReg, wEdgeCntlMap_IntLeftVert]:uw		0xFFFF:uw	// MaskA = 0? 
+
+	//	p3 = Cur MB Y row 0 = r[P_AddrReg, 0]<16;16,1>  
+	//	p2 = Cur MB Y row 1 = r[P_AddrReg, 16]<16;16,1>
+	//	p1 = Cur MB Y row 2 = r[P_AddrReg, 32]<16;16,1>
+	//	p0 = Cur MB Y row 3 = r[P_AddrReg, 48]<16;16,1>
+	// 	q0 = Cur MB Y row 4 = r[Q_AddrReg, 0]<16;16,1> 
+	//	q1 = Cur MB Y row 5 = r[Q_AddrReg, 16]<16;16,1>
+	//	q2 = Cur MB Y row 6 = r[Q_AddrReg, 32]<16;16,1>
+	//	q3 = Cur MB Y row 7 = r[Q_AddrReg, 48]<16;16,1>
+	mov (1)	P_AddrReg:w		SRC_MB_Y_BASE:w					{ NoDDClr }
+	mov (1)	Q_AddrReg:w		4*Y_ROW_WIDTH+SRC_MB_Y_BASE:w   { NoDDChk }
+	
+	mov (1)	MaskA:uw	r[ECM_AddrReg, wEdgeCntlMap_IntLeftVert]:uw		{ NoDDClr }
+
+	// tc0 has bTc0_v31_Y + bTc0_v21_Y + bTc0_v11_Y + bTc0_v01_Y	
+	mov (4)	tc0<1>:ub	r[ECM_AddrReg, bTc0_v01_Y]<4;4,1>:ub			{ NoDDChk }
+
+//    (f0.0)	jmpi	BYPASS_4x4_DEBLOCK_V
+//	(f0.0.anyv)	 jmpi	BYPASS_4x4_DEBLOCK_V
+
+//	CALL(FILTER_Y, 1)
+	PRED_CALL(-f0.0, FILTER_Y, 1)
+
+//BYPASS_4x4_DEBLOCK_V:
+//------------------------------------------------------------------
+
+
+//---------- Deblock Y internal mid vert edge (V2) ----------
+
+	// Bypass deblocking if FilterInternal8x8EdgesFlag = 0  
+	and.z.f0.0	(1)	null:w	r[ECM_AddrReg, BitFlags]:ub		FilterInternal8x8EdgesFlag:w		// Check for FilterInternal4x4EdgesFlag 
+
+//	and.z.f0.1 (1)	null:uw		r[ECM_AddrReg, wEdgeCntlMap_IntMidVert]:uw		0xFFFF:uw	// MaskA = 0? 
+
+	//	p3 = Cur MB Y row 4  = r[P_AddrReg, 0]<16;16,1>  
+	//	p2 = Cur MB Y row 5  = r[P_AddrReg, 16]<16;16,1> 
+	//	p1 = Cur MB Y row 6  = r[P_AddrReg, 32]<16;16,1> 
+	//	p0 = Cur MB Y row 7  = r[P_AddrReg, 48]<16;16,1> 
+	// 	q0 = Cur MB Y row 8  = r[Q_AddrReg, 0]<16;16,1>  
+	//	q1 = Cur MB Y row 9  = r[Q_AddrReg, 16]<16;16,1> 
+	//	q2 = Cur MB Y row 10 = r[Q_AddrReg, 32]<16;16,1> 
+	//	q3 = Cur MB Y row 11 = r[Q_AddrReg, 48]<16;16,1> 
+	mov (1)	P_AddrReg:w		4*Y_ROW_WIDTH+SRC_MB_Y_BASE:w	{ NoDDClr }
+	mov (1)	Q_AddrReg:w		8*Y_ROW_WIDTH+SRC_MB_Y_BASE:w   { NoDDChk }
+
+	mov (1)	MaskA:uw	r[ECM_AddrReg, wEdgeCntlMap_IntMidVert]:uw		{ NoDDClr }
+//	mov (1) MaskB:uw	0:w						// Set MaskB = 0, so it always uses bS < 4 algorithm.
+
+	// tc0 has bTc0_v32_Y + bTc0_v22_Y + bTc0_v12_Y + bTc0_v02_Y	
+	mov (4)	tc0<1>:ub	r[ECM_AddrReg, bTc0_v02_Y]<4;4,1>:ub			{ NoDDChk }
+
+//    (f0.0)	jmpi	BYPASS_8x8_DEBLOCK_V
+//	(f0.0.anyv)	 jmpi	BYPASS_8x8_DEBLOCK_V
+    
+//	CALL(FILTER_Y, 1)
+	PRED_CALL(-f0.0, FILTER_Y, 1)
+
+//BYPASS_8x8_DEBLOCK_V:
+//-----------------------------------------------
+
+
+//---------- Deblock Y interal right edge (V3) ----------	 
+
+	// Bypass deblocking if FilterInternal4x4EdgesFlag = 0  
+	and.z.f0.0	(1)	null:w	r[ECM_AddrReg, BitFlags]:ub		FilterInternal4x4EdgesFlag:w		// Check for FilterInternal4x4EdgesFlag 
+
+//	and.z.f0.1 (1)	null:uw		r[ECM_AddrReg, wEdgeCntlMap_IntRightVert]:uw		0xFFFF:uw	// MaskA = 0? 
+
+	//	p3 = Cur MB Y row 8  = r[P_AddrReg, 0]<16;16,1> 
+	//	p2 = Cur MB Y row 9  = r[P_AddrReg, 16]<16;16,1>
+	//	p1 = Cur MB Y row 10 = r[P_AddrReg, 32]<16;16,1>
+	//	p0 = Cur MB Y row 11 = r[P_AddrReg, 48]<16;16,1>
+	// 	q0 = Cur MB Y row 12 = r[Q_AddrReg, 0]<16;16,1> 
+	//	q1 = Cur MB Y row 13 = r[Q_AddrReg, 16]<16;16,1>
+	//	q2 = Cur MB Y row 14 = r[Q_AddrReg, 32]<16;16,1>
+	//	q3 = Cur MB Y row 15 = r[Q_AddrReg, 48]<16;16,1>
+	mov (1)	P_AddrReg:w		8*Y_ROW_WIDTH+SRC_MB_Y_BASE:w		{ NoDDClr }
+	mov (1)	Q_AddrReg:w		12*Y_ROW_WIDTH+SRC_MB_Y_BASE:w      { NoDDChk }
+
+	mov (1)	MaskA:uw	r[ECM_AddrReg, wEdgeCntlMap_IntRightVert]:uw	{ NoDDClr }
+//	mov (1) MaskB:uw	0:w						// Set MaskB = 0, so it always uses bS < 4 algorithm.
+
+	// tc0 has bTc0_v33_Y + bTc0_v23_Y + bTc0_v13_Y + bTc0_v03_Y
+	mov (4)	tc0<1>:ub	r[ECM_AddrReg, bTc0_v03_Y]<4;4,1>:ub			{ NoDDChk }
+
+//    (f0.0)	jmpi	BYPASS_4x4_DEBLOCK_V2
+//	(f0.0.anyv)	 jmpi	BYPASS_4x4_DEBLOCK_V2
+    
+//	CALL(FILTER_Y, 1)
+	PRED_CALL(-f0.0, FILTER_Y, 1)
+
+//BYPASS_4x4_DEBLOCK_V2:
+//-----------------------------------------------
diff --git a/i965_drv_video/shaders/h264/ildb/AVC_ILDB_ForwardMsg.asm b/i965_drv_video/shaders/h264/ildb/AVC_ILDB_ForwardMsg.asm
new file mode 100644
index 0000000..96fe828
--- /dev/null
+++ b/i965_drv_video/shaders/h264/ildb/AVC_ILDB_ForwardMsg.asm
@@ -0,0 +1,57 @@
+/*
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+//========== Forward message to root thread through gateway ==========
+// Each child thread write a byte into the root GRF r50 defiend in open Gataway.
+
+#if defined(_DEBUG) 
+mov		(1)		EntrySignatureC:w			0x7777:w
+#endif
+
+// Init payload to r0
+mov (8) 	GatewayPayload<1>:ud 	0:w								//{ NoDDClr } 
+
+// Forward a message:
+// Offset = x relative to r50 (defiend in open gataway), x = ORIX >> 4 [bit 28:16]
+// Need to shift left 16
+
+// shift 2 more bits for byte to word offset
+
+//shl	(1)		Offset_Length:ud		GateWayOffsetC:w	 	16:w		{ NoDDClr, NoDDChk }
+shl	(1)		Offset_Length:ud		GateWayOffsetC:w	 	18:w		
+
+// 2 bytes offset
+add	(1)		Offset_Length:ud			Offset_Length:ud		0x00020000:d	{ NoDDClr }
+	
+// Length = 1 byte,	[bit 10:8 = 000]
+//000 xxxxxxxxxxxxx 00000 000 00000000 ==> 000x xxxx xxxx xxxx 0000 0000 0000 0000
+
+//mov (1) 	DispatchID:ub 			r0.20:ub		// Dispatch ID
+
+//Move in EUid and Thread ID that we received from the PARENT thread
+mov (1) 	EUID_TID:uw 			r0.6:uw								{ NoDDClr, NoDDChk }
+
+mov (1) 	GatewayPayloadKey:uw 	0x1212:uw							{ NoDDClr, NoDDChk }	// Key
+
+//mov	(4)		GatewayPayload<1>:ud	0:ud								{ NoDDClr, NoDDChk }	// Init payload low 4 dword
+
+// Write back one byte (value = 0xFF) to root thread GRF to indicate this child thread is finished
+// All lower 4 bytes must be assigned to the same byte value.
+mov	(4)		GatewayPayload<1>:ub	0xFFFF:uw							{ NoDDChk }
+
+// msg descriptor bit 15 set to '1' for notification
+#ifdef GW_DCN
+// For ILK, EOT bit should also be set to terminate the thread. This is to fix a timing related HW issue.
+//
+send (8)  	null:ud 		m0	  		GatewayPayload<8;8,1>:ud    MSG_GW_EOT	FWDMSGDSC+NOTIFYMSG
+#else
+send (8)  	null:ud 		m0	  		GatewayPayload<8;8,1>:ud    MSG_GW	FWDMSGDSC+NOTIFYMSG
+#endif	// GW_DCN
+
+//========== Forward Msg Done ========================================
+
diff --git a/i965_drv_video/shaders/h264/ildb/AVC_ILDB_LumaThrdLimit.asm b/i965_drv_video/shaders/h264/ildb/AVC_ILDB_LumaThrdLimit.asm
new file mode 100644
index 0000000..714ee4d
--- /dev/null
+++ b/i965_drv_video/shaders/h264/ildb/AVC_ILDB_LumaThrdLimit.asm
@@ -0,0 +1,46 @@
+/*
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+//========== Forward message to root thread through gateway ==========
+
+// Chroma root kenrel updates luma thread limit.
+
+#if defined(_DEBUG) 
+mov		(1)		EntrySignatureC:w			0x7788:w
+#endif
+
+// Init payload to r0
+mov (8) 	GatewayPayload<1>:ud 	0:w								{ NoDDClr } 
+
+// Forward a message:
+// Offset = x relative to r50 (defiend in open gataway), x = ORIX >> 4 [bit 28:16]
+// Need to shift left 16
+
+mov	(1)		Offset_Length:ud		THREAD_LIMIT_OFFSET:ud	 			{ NoDDClr, NoDDChk }
+
+// Length = 1 byte,	[bit 10:8 = 000]
+//000 xxxxxxxxxxxxx 00000 000 00000000 ==> 000x xxxx xxxx xxxx 0000 0000 0000 0000
+
+//mov (1) 	DispatchID:ub 			r0.20:ub		// Dispatch ID
+
+//  Copy EUid and Thread ID that we received from the PARENT thread
+mov (1) 	EUID_TID:uw 			r0.6:uw								{ NoDDClr, NoDDChk }
+
+mov (1) 	GatewayPayloadKey:uw 	0x1212:uw							{ NoDDChk }	// Key
+
+//mov	(4)		GatewayPayload<1>:ud	0:ud								{ NoDDClr, NoDDChk }	// Init payload low 4 dword
+
+// Write back one byte (value = 0xFF) to root thread GRF to indicate this child thread is finished
+// All lower 4 bytes must be assigned to the same byte value.
+add	(1)		Temp1_W:w				MaxThreads:uw	-OutstandingThreads:uw
+mov	(4)		GatewayPayload<1>:ub	Temp1_B:ub
+
+send (8)  	GatewayResponse:ud 		m0	  		GatewayPayload<8;8,1>:ud    MSG_GW	FWDMSGDSC
+
+//========== Forward Msg Done ========================================
+
diff --git a/i965_drv_video/shaders/h264/ildb/AVC_ILDB_Luma_Core.asm b/i965_drv_video/shaders/h264/ildb/AVC_ILDB_Luma_Core.asm
new file mode 100644
index 0000000..edc8273
--- /dev/null
+++ b/i965_drv_video/shaders/h264/ildb/AVC_ILDB_Luma_Core.asm
@@ -0,0 +1,419 @@
+/*
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+#if !defined(__AVC_ILDB_LUMA_CORE__)	// Make sure this file is only included once
+#define __AVC_ILDB_LUMA_CORE__
+
+////////// AVC ILDB Luma Core /////////////////////////////////////////////////////////////////////////////////
+//
+//	This core performs AVC LUMA ILDB filtering on one horizontal edge (16 pixels) of a MB.  
+//	If data is transposed, it can also de-block a vertical edge.
+//
+//	Bafore calling this subroutine, caller needs to set the following parameters.
+//
+//	- EdgeCntlMap1				//	Edge control map A
+//	- EdgeCntlMap2				//	Edge control map B
+//	- P_AddrReg					//	Src and dest address register for P pixels
+//	- Q_AddrReg					//	Src and dest address register for Q pixels 	
+//	- alpha						//  alpha corresponding to the edge to be filtered
+//	- beta						//  beta corresponding to the edge to be filtered
+//	- tc0						// 	tc0  corresponding to the edge to be filtered
+//
+//
+//	+----+----+----+----+----+----+----+----+
+//	| p3 | p2 | P1 | p0 | q0 | q1 | q2 | q3 |
+//	+----+----+----+----+----+----+----+----+
+//
+//	p3 = r[P_AddrReg, 0]<16;16,1>  
+//	p2 = r[P_AddrReg, 16]<16;16,1> 
+//	p1 = r[P_AddrReg, 32]<16;16,1> 
+//	p0 = r[P_AddrReg, 48]<16;16,1> 
+// 	q0 = r[Q_AddrReg, 0]<16;16,1>  
+//	q1 = r[Q_AddrReg, 16]<16;16,1> 
+//	q2 = r[Q_AddrReg, 32]<16;16,1> 
+//	q3 = r[Q_AddrReg, 48]<16;16,1> 
+//
+/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+// The region is both src and dest
+// P0-P3 and Q0-Q3 should be only used if they have not been modified to new values
+#undef 	P3
+#undef 	P2
+#undef 	P1
+#undef 	P0
+#undef 	Q0
+#undef 	Q1
+#undef 	Q2
+#undef 	Q3
+  
+#define P3 		r[P_AddrReg,  0]<16;16,1>:ub
+#define P2 		r[P_AddrReg, 16]<16;16,1>:ub
+#define P1 		r[P_AddrReg, 32]<16;16,1>:ub
+#define P0 		r[P_AddrReg, 48]<16;16,1>:ub
+#define Q0 		r[Q_AddrReg,  0]<16;16,1>:ub
+#define Q1 		r[Q_AddrReg, 16]<16;16,1>:ub
+#define Q2 		r[Q_AddrReg, 32]<16;16,1>:ub
+#define Q3 		r[Q_AddrReg, 48]<16;16,1>:ub
+
+// New region as dest
+#undef 	NewP2
+#undef 	NewP1
+#undef 	NewP0
+#undef 	NewQ0
+#undef 	NewQ1
+#undef 	NewQ2
+
+#define NewP2 	r[P_AddrReg, 16]<1>:ub
+#define NewP1 	r[P_AddrReg, 32]<1>:ub
+#define NewP0 	r[P_AddrReg, 48]<1>:ub
+#define NewQ0 	r[Q_AddrReg,  0]<1>:ub
+#define NewQ1 	r[Q_AddrReg, 16]<1>:ub
+#define NewQ2 	r[Q_AddrReg, 32]<1>:ub
+
+// Filter one luma edge
+FILTER_Y:
+
+#if defined(_DEBUG) 
+	mov		(1)		EntrySignatureC:w			0x1111:w
+#endif
+	//---------- Derive filterSampleflag in AVC spec, equition (8-469) ----------
+	// bS is in MaskA
+
+	// Src copy of the p3, p2, p1, p0, q0, q1, q2, q3
+//	mov (16) p0123_W(0)<1>		r[P_AddrReg]<16;16,1>:uw
+//	mov (16) p0123_W(1)<1>		r[P_AddrReg, 32]<16;16,1>:uw
+//	mov (16) q0123_W(0)<1>		r[Q_AddrReg]<16;16,1>:uw
+//	mov (16) q0123_W(1)<1>		r[Q_AddrReg, 32]<16;16,1>:uw
+
+	mov (2)	f0.0<1>:uw		MaskA<2;2,1>:uw
+
+	add (16) q0_p0(0)<1>		Q0		-P0				// q0-p0
+	add (16) TempRow0(0)<1>		P1		-P0				// p1-p0
+	add (16) TempRow1(0)<1>		Q1		-Q0				// q1-q0
+
+	// Build FilterSampleFlag
+	// abs(q0-p0) < alpha
+	(f0.0) cmp.l.f0.0 (16) null:w		(abs)q0_p0(0)			alpha:w
+	// abs(p1-p0) < Beta
+	(f0.0) cmp.l.f0.0 (16) null:w		(abs)TempRow0(0)		beta:w
+	// abs(q1-q0) < Beta
+	(f0.0) cmp.l.f0.0 (16) null:w		(abs)TempRow1(0)		beta:w
+
+	//-----------------------------------------------------------------------------------------
+
+    (f0.0)	if	(16)		Y_ENDIF1
+		// For channels whose edge control map1 = 1 ---> perform de-blocking
+
+//		mov (1)		f0.1:uw		MaskB:uw	{NoMask}		// Now check for which algorithm to apply
+
+		// (abs)ap = |p2-p0|
+		add (16) ap(0)<1>		P2		-P0		// ap = p2-p0
+		// (abs)aq = |q2-q0|
+		add (16) aq(0)<1>		Q2		-Q0		// aq = q2-q0
+
+		// Make a copy of unmodified p0 and p1 for use in q0'and q1' calculation
+		mov (16) p0123_W(1)<1>		r[P_AddrReg, 32]<16;16,1>:uw		{NoMask}
+
+		(f0.1)	if	(16)		Y_ELSE2
+
+			// For channels whose edge control map2 = 1 ---> bS = 4 algorithm
+
+			// Compute q0', q1' and q2'
+			//-----------------------------------------------------------------------------
+			// bS = 4 Algorithm :			
+			//
+			// gama = |p0-q0| < ((alpha >> 2) + 2) 
+			// deltap = (ap<beta) && gama;  		// deep filter flag
+			//	if (deltap) {
+			//		p0' = (        p2 +2*p1 +2*p0 +2*q0 + q1 + 4) >> 3; 
+			// 		p1' = (        p2 +  p1 +  p0 +  q0      + 2) >> 2;
+			// 		p2' = (2*p3 +3*p2 +  p1 +  p0 +  q0      + 4) >> 3;
+			//	} else {  
+			//		p0' = (            2*p1 +  p0 +  q1      + 2) >> 2;
+			//	}
+			//-----------------------------------------------------------------------------
+
+			// gama = |p0-q0| < ((alpha >> 2) + 2) = |p0-q0| < alpha2  
+			cmp.l.f0.1 (16) null:w	(abs)q0_p0(0)	alpha2:w
+
+			// Common P01 = p0 + p1
+			add (16)	P0_plus_P1(0)<1>	P0			P1	
+
+			// Common Q01 = q0 + q1
+			add (16)	Q0_plus_Q1(0)<1>	Q0			Q1
+
+//			mov (1)	CTemp1_W:w		f0.1:uw						{NoMask}
+			mov (1)	f0.0:uw			f0.1:uw						{NoMask}
+	
+			// deltap = ((abs)ap < beta) && gama
+			(f0.1) cmp.l.f0.1 (16) null:w	(abs)ap(0)		beta<0;1,0>:w							// (abs)ap < beta ?
+
+			// deltaq = ((abs)aq < beta) && gama
+			(f0.0) cmp.l.f0.0 (16) null:w	(abs)aq(0)		beta<0;1,0>:w							// (abs)aq < beta ?
+
+
+//			mov (1)	CTemp1_W:w		f0.0:uw						{NoMask}					// gama = |p0-q0| < ((alpha >> 2) + 2) for each channel	
+//			and (1)		f0.1:w		f0.1:uw		CTemp1_W:w		{NoMask}					// deltap = (ap<beta) && gama
+
+
+			(f0.1)	if	(16)		Y_ELSE3			// for channels its deltap = true
+
+			add (16)	P2_plus_P3(0)<1>	P2		P3
+			
+			// A =  (p1 + p0) + q0 = P01 + q0
+			add (16)	A(0)<1>			P0_plus_P1(0)		Q0							// A =  P01 + q0
+
+			// Now acc0 = A
+
+			// B =  p2 + (p1 + p0 + q0) + 4 = p2 + A + 4
+//			add (16)	acc0.0<1>:w		P2				4:w								// p2 + 4 
+//			add (16)	B(0)<1>			acc0.0<16;16,1>:w		A(0)					// B = p2 + A + 4
+			add (16)	acc0.0<1>:w		acc0.0<16;16,1>:w		4:w								// p2 + 4 
+			add (16)	B(0)<1>			acc0.0<16;16,1>:w		P2					// B = p2 + A + 4
+			
+			// Now acc0 = B
+
+			// p2' = (2*p3 +3*p2 + A + 4) >> 3 = (2*(p3+p2) + B) >> 3
+//			mov	(16)	acc0.0<1>:w		B(0)
+			mac (16)	acc0.0<1>:w		P2_plus_P3(0)		2:w		
+			shr.sat (16) TempRow3B(0)<2>	acc0.0<16;16,1>:w		3:w
+			
+			// p1' = (p2 + A + 2) >> 2 = (B - 2) >> 2
+			add (16)	acc0.0<1>:w		B(0)			-2:w
+			shr.sat (16) TempRow1B(0)<2>	acc0.0<16;16,1>:w		2:w
+	
+			// p0' = (p2 +2*A + q1 + 4) >> 3 = (B + A + q1) >> 3
+			add (16)	acc0.0<1>:w		Q1				A(0)							// B + A
+			add (16)	acc0.0<1>:w		acc0.0<16;16,1>:w		B(0)							// B + A + q1
+			shr.sat (16) TempRow0B(0)<2>	acc0.0<16;16,1>:w		3:w								// (B + A + q1) >> 3
+
+			// p2' = (2*p3 +3*p2 + A + 4) >> 3 = (2*(p3+p2) + B) >> 3
+//			mov	(16)	acc0.0<1>:w		B(0)
+//			mac (16)	acc0.0<1>:w		P2_plus_P3(0)		2:w		
+//			shr.sat (16) TempRow3B(0)<2>	acc0.0<16;16,1>:w		3:w
+
+			mov (16) 	NewP2		TempRow3B(0)						// p2'
+			mov (16) 	NewP1		TempRow1B(0)						// p1'			
+			mov (16) 	NewP0		TempRow0B(0)						// p0'
+
+Y_ELSE3:
+			else (16)		Y_ENDIF3		// for channels its deltap = false
+
+			// p0' = (2*p1 + p0 + q1 + 2) >> 2 =  (p1 + P01 + q1 + 2) >> 2
+			add (16)	acc0.0<1>:w		P1			P0_plus_P1(0)			// p1 + P01 (TempRow1(0) = P01)
+			add (16)	acc0.0<1>:w		acc0.0<16;16,1>:w	Q1				
+			add (16)	acc0.0<1>:w		acc0.0<16;16,1>:w	2:w			// p1 + P01 + q1 + 2
+
+			shr.sat (16) TempRow0B(0)<2>	acc0.0<16;16,1>:w		2:w	// >> 2
+			mov (16) 	NewP0		TempRow0B(0)						// p0'
+
+			endif
+Y_ENDIF3:
+			// Compute q0', q1' and q2'
+			//-----------------------------------------------------------------------------
+			// bS = 4 Algorithm (cont):			
+			//
+			//	deltaq = (aq<beta) && gama;  		// deep filter flag
+			//	if (deltaq) {
+			//		q0' = (        q2 +2*q1 +2*q0 +2*p0 + p1 + 4) >> 3; 
+			//		q1' = (        q2 +  q1 +  q0 +  p0      + 2) >> 2;
+			//		q2' = (2*q3 +3*q2 +  q1 +  q0 +  p0      + 4) >> 3;
+			//	} else {
+			//		q0' = (            2*q1 +  q0 +  p1      + 2) >> 2;
+			//	}
+			
+			// deltaq = ((abs)aq < beta) && gama
+//			cmp.l.f0.1 (16) null:w	(abs)aq(0)		beta<0;1,0>:w							// (abs)aq < beta ?
+
+			// Common Q01 = q0 + q1
+//			add (16)	Q0_plus_Q1(0)<1>	Q0			Q1
+			
+//			and (1)		f0.1:w		f0.1:uw		CTemp1_W:w		{NoMask}				// deltaq = ((abs)ap < beta) && gama
+
+			(f0.0)	if	(16)		Y_ELSE4			// for channels its deltaq = true
+			
+			add (16)	Q2_plus_Q3(0)<1>	Q2			Q3
+
+			// A =  (q1 + q0) + p0 = Q01 + p0
+			add (16)	A(0)<1>			Q0_plus_Q1(0)		p0(0)							// A =  q1+q0 + p0
+
+			// Acc0 = A
+
+			// B =  q2 + q1 + q0 + p0 + 4 = q2 + A + 4
+			add (16)	acc0.0<1>:w		acc0.0<16;16,1>:w		4:w							// q2 + 4 
+			add (16)	B(0)<1>			acc0.0<16;16,1>:w		Q2								// B = q2 + A + 4
+
+			// Acc0 = B
+			
+			// q2' = (2*q3 +3*q2 + A + 4) >> 3 = (2*(q3+q2) + B) >> 3
+//			mov (16)	acc0.0<1>:w		B(0)	
+			mac (16)	acc0.0<1>:w		Q2_plus_Q3(0)	2:w
+			shr.sat (16) TempRow3B(0)<2>	acc0.0<16;16,1>:w		3:w
+
+			// q1' = (q2 + A + 2) >> 2 = (B - 2) >> 2
+			add (16)	acc0.0<1>:w		B(0)			-2:w
+			shr.sat (16) TempRow1B(0)<2>	acc0.0<16;16,1>:w	2:w
+			
+			// q0' = (q2 +2*A + p1 + 4) >> 3 = (B + A + p1) >> 3
+			add (16)	acc0.0<1>:w		p1(0)					A(0)
+			add (16)	acc0.0<1>:w		acc0.0<16;16,1>:w		B(0)
+			shr.sat (16) TempRow0B(0)<2>	acc0.0<16;16,1>:w	3:w
+			
+			mov (16) 	NewQ2		TempRow3B(0)						// q2'
+			mov (16) 	NewQ1		TempRow1B(0)						// q1'
+			mov (16) 	NewQ0		TempRow0B(0)						// q0'
+
+Y_ELSE4:
+			else (16)		Y_ENDIF4		// for channels its deltaq = false
+
+			// q0' = (2*q1 + q0 + p1 + 2) >> 2 =  (q1 + Q01 + p1 + 2) >> 2
+			// Use original p1 values in p1(0)
+			add (16)	acc0.0<1>:w		p1(0)			Q0_plus_Q1(0)			// p1 + P01 (TempRow1(0) = P01)
+			add (16)	acc0.0<1>:w		acc0.0<16;16,1>:w	Q1				
+			add (16)	acc0.0<1>:w		acc0.0<16;16,1>:w	2:w			// p1 + P01 + q1 + 2
+
+			shr.sat (16)	TempRow0B(0)<2>		acc0.0<16;16,1>:w		2:w								// >> 2
+			mov (16) 	NewQ0		TempRow0B(0)						// q0'
+
+			endif
+Y_ENDIF4:
+
+			
+			// Done with bS = 4 algorithm
+			
+Y_ELSE2: 
+		else 	(16)		Y_ENDIF2
+			// For channels whose edge control map2 = 0 ---> bS < 4 algorithm
+
+			//-----------------------------------------------------------------------------
+			// bS < 4 Algorithm :
+			// tc = tc0 + (|p2-p0|<Beta ? 1 : 0) + (|q2-q0|<Beta ? 1 : 0)
+			// delta = Clip3(-tc, tc, ((((q0-p0)<<2) + (p1-q1) + 4) >> 3))
+			// p0' = Clip1(p0 + delta) = Clip3(0, 0xFF, p0 + delta)
+			// q0' = Clip1(q0 - delta) = Clip3(0, 0xFF, q0 - delta)
+			// if (|p2-p0|<Beta)
+			// 		p1' = p1 + Clip3(-tc0, tc0, (p2 + ((p0+q0+1)>>1) - (p1<<1)) >> 1 )
+			// if (|q2-q0|<Beta)
+			// 		q1' = q1 + Clip3(-tc0, tc0, (q2 + ((p0+q0+1)>>1) - (q1<<1)) >> 1 )
+			//-----------------------------------------------------------------------------
+			
+			// Expand tc0
+			mov (16)	tc_exp(0)<1>	tc0<1;4,0>:ub	{NoMask}
+			mov (16)	tc0_exp(0)<1>	tc0<1;4,0>:ub	{NoMask}					// tc0_exp = tc0, each tc0 is duplicated 4 times for 4 adjcent 4 pixels	
+						
+			// tc_exp = tc0_exp + (|p2-p0|<Beta ? 1 : 0) + (|q2-q0|<Beta ? 1 : 0)			
+//			mov (16)	tc_exp(0)<1>		tc0_exp(0)									// tc = tc0_exp first
+			
+
+			cmp.l.f0.0 (16)	null:w		(abs)ap(0)			beta:w						// |p2-p0|< Beta ? ---> (abs)ap < Beta ?
+			cmp.l.f0.1 (16)	null:w		(abs)aq(0)			beta:w						// |q2-q0|< Beta ? ---> (abs)aq < Beta ?
+			
+			//--- Use free cycles here ---
+			// delta = Clip3(-tc, tc, ((((q0-p0)<<2) + (p1-q1) + 4) >> 3))
+			// 4 * (q0-p0) + p1 - q1 + 4
+			add (16) acc0<1>:w		P1			4:w							// p1 + 4
+			mac (16) acc0<1>:w		q0_p0(0)	4:w							// 4 * (q0-p0) + p1 + 4
+			add (16) acc0<1>:w		acc0<16;16,1>:w		-Q1					// 4 * (q0-p0) + p1 - q1 + 4
+			shr (16) TempRow0(0)<1> acc0<16;16,1>:w		3:w
+						
+			// Continue on getting tc_exp
+			(f0.0) add (16)	tc_exp(0)<1>	tc_exp(0)	1:w							// tc0_exp + (|p2-p0|<Beta ? 1 : 0)
+			mov (2)	CTemp1_W<1>:w		f0.0<2;2,1>:w			{NoMask}					// Save	|p2-p0|<Beta flag			
+			(f0.1) add (16)	tc_exp(0)<1>	tc_exp(0)	1:w							// tc_exp = tc0_exp + (|p2-p0|<Beta ? 1 : 0) + (|q2-q0|<Beta ? 1 : 0)
+			
+
+			// Continue on cliping tc to get delta
+			cmp.g.f0.0	(16) null:w		TempRow0(0)		tc_exp(0)					// Clip if delta' > tc
+			cmp.l.f0.1	(16) null:w		TempRow0(0)		-tc_exp(0)					// Clip if delta' < -tc
+
+			//--- Use free cycles here ---
+			// common = (p0+q0+1) >> 1 	  --->  TempRow2(0)
+			// Same as avg of p0 and q0
+			avg (16) TempRow2(0)<1>		P0			Q0
+
+			// Continue on cliping tc to get delta
+			(f0.0) mov (16) TempRow0(0)<1>				tc_exp(0)
+			(f0.1) mov (16) TempRow0(0)<1>				-tc_exp(0)
+
+			//--- Use free cycles here ---
+			mov (2)	f0.0<1>:w		CTemp1_W<2;2,1>:w	{NoMask}			// CTemp1_W = (|p2-p0|<Beta)
+																			// CTemp2_W = (|q2-q0|<Beta)		
+			//-----------------------------------------------------------------------
+
+			// p0' = Clip1(p0 + delta) = Clip3(0, 0xFF, p0 + delta)
+			// q0' = Clip1(q0 - delta) = Clip3(0, 0xFF, q0 - delta)
+			add.sat (16) TempRow1B(0)<2>		P0			TempRow0(0)					// p0+delta
+			add.sat (16) TempRow0B(0)<2>		Q0			-TempRow0(0) 				// q0-delta
+			mov (16) NewP0		TempRow1B(0)					// p0'
+			mov (16) NewQ0		TempRow0B(0)					// q0'
+			//-----------------------------------------------------------------------
+
+			// Now compute p1' and q1'
+
+			// if (|p2-p0|<Beta)
+//			mov (1)	f0.0:w		CTemp1_W:w				{NoMask}			// CTemp1_W = (|p2-p0|<Beta)
+			(f0.0)	if	(16)		Y_ENDIF6
+		
+			// p1' = p1 + Clip3(-tc0, tc0, adj)
+			// adj = (p2 + common - (p1<<1)) >> 1 = (p2 + common - (p1*2)) >> 1
+			add (16) acc0<1>:w	P2		TempRow2(0)							// TempRow2(0) = common = (p0+q0+1) >> 1
+			mac (16) acc0<1>:w	P1		-2:w
+			shr (16) TempRow1(0)<1>		acc0<16;16,1>:w		1:w
+
+			// tc clip to get tc_adj
+			cmp.g.f0.0	(16) null:w		TempRow1(0)		tc0_exp(0)					// Clip if delta' > tc
+			cmp.l.f0.1	(16) null:w		TempRow1(0)		-tc0_exp(0)					// Clip if delta' < -tc
+			
+			(f0.0) mov (16) TempRow1(0)<1>				tc0_exp(0)
+			(f0.1) mov (16) TempRow1(0)<1>				-tc0_exp(0)
+
+			//--- Use free cycles here ---
+			mov (1)	f0.1:w		CTemp2_W:w				{NoMask}			// CTemp2_W = (|q2-q0|<Beta)
+
+			// p1' = p1 + tc_adj
+			add.sat (16) TempRow1B(0)<2>		P1			TempRow1(0)					// p1+tc_adj
+			mov (16) NewP1			TempRow1B(0)				// p1'
+
+			//------------------------------------------------------------------------
+Y_ENDIF6:
+			endif
+			
+			// if (|q2-q0|<Beta)
+//			mov (1)	f0.1:w		CTemp2_W:w				{NoMask}			// CTemp2_W = (|q2-q0|<Beta)
+			(f0.1)	if	(16)		Y_ENDIF7
+					
+			// q1' = q1 + Clip3(-tc0, tc0, adj)
+			// adj = (q2 + common - (q1<<1)) >> 1 
+			// same as q2 + common - (q1 * 2)
+			add (16) acc0<1>:w	Q2		TempRow2(0)
+			mac (16) acc0<1>:w	Q1		-2:w
+			shr (16) TempRow1(0)<1>		acc0<16;16,1>:w		1:w	
+
+			// tc clip to get tc_adj
+			cmp.g.f0.0	(16) null:w		TempRow1(0)		tc0_exp(0)					// Clip if delta' > tc
+			cmp.l.f0.1	(16) null:w		TempRow1(0)		-tc0_exp(0)					// Clip if delta' < -tc
+
+			(f0.0) mov (16) TempRow1(0)<1>				tc0_exp(0)
+			(f0.1) mov (16) TempRow1(0)<1>				-tc0_exp(0)
+
+			// q1' = q1 + tc_adj
+			add.sat (16) TempRow1B(0)<2>		Q1			TempRow1(0)					// q1+tc_adj
+			mov (16) NewQ1			TempRow1B(0)				// q1'
+
+			//------------------------------------------------------------------------			
+Y_ENDIF7:
+			endif
+
+		endif
+Y_ENDIF2:
+Y_ENDIF1:
+	endif
+
+RETURN
+
+#endif	// !defined(__AVC_ILDB_LUMA_CORE__)
diff --git a/i965_drv_video/shaders/h264/ildb/AVC_ILDB_Luma_Core_Mbaff.asm b/i965_drv_video/shaders/h264/ildb/AVC_ILDB_Luma_Core_Mbaff.asm
new file mode 100644
index 0000000..0c3f752
--- /dev/null
+++ b/i965_drv_video/shaders/h264/ildb/AVC_ILDB_Luma_Core_Mbaff.asm
@@ -0,0 +1,391 @@
+/*
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+#if !defined(__AVC_ILDB_LUMA_CORE_MBAFF__)	// Make sure this file is only included once
+#define __AVC_ILDB_LUMA_CORE_MBAFF__
+
+////////// AVC ILDB Luma Core Mbaff /////////////////////////////////////////////////////////////////////////////////
+//
+//	This core performs AVC LUMA ILDB filtering on one horizontal edge (16 pixels) of a MB.  
+//	If data is transposed, it can also de-block a vertical edge.
+//
+//	Bafore calling this subroutine, caller needs to set the following parameters.
+//
+//	- EdgeCntlMap1				//	Edge control map A
+//	- EdgeCntlMap2				//	Edge control map B
+//	- P_AddrReg					//	Src and dest address register for P pixels
+//	- Q_AddrReg					//	Src and dest address register for Q pixels 	
+//	- alpha						//  alpha corresponding to the edge to be filtered
+//	- beta						//  beta corresponding to the edge to be filtered
+//	- tc0						// 	tc0  corresponding to the edge to be filtered
+//
+//
+//	+----+----+----+----+----+----+----+----+
+//	| p3 | p2 | P1 | p0 | q0 | q1 | q2 | q3 |
+//	+----+----+----+----+----+----+----+----+
+//
+//	p3 = r[P_AddrReg, 0]<16;16,1>  
+//	p2 = r[P_AddrReg, 16]<16;16,1> 
+//	p1 = r[P_AddrReg, 32]<16;16,1> 
+//	p0 = r[P_AddrReg, 48]<16;16,1> 
+// 	q0 = r[Q_AddrReg, 0]<16;16,1>  
+//	q1 = r[Q_AddrReg, 16]<16;16,1> 
+//	q2 = r[Q_AddrReg, 32]<16;16,1> 
+//	q3 = r[Q_AddrReg, 48]<16;16,1> 
+//
+/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+// The region is both src and dest
+// P0-P3 and Q0-Q3 should be only used if they have not been modified to new values  
+#undef 	P3
+#undef 	P2
+#undef 	P1
+#undef 	P0
+#undef 	Q0
+#undef 	Q1
+#undef 	Q2
+#undef 	Q3
+
+#define P3 		r[P_AddrReg,  0]<16;16,1>:ub
+#define P2 		r[P_AddrReg, 16]<16;16,1>:ub
+#define P1 		r[P_AddrReg, 32]<16;16,1>:ub
+#define P0 		r[P_AddrReg, 48]<16;16,1>:ub
+#define Q0 		r[Q_AddrReg,  0]<16;16,1>:ub
+#define Q1 		r[Q_AddrReg, 16]<16;16,1>:ub
+#define Q2 		r[Q_AddrReg, 32]<16;16,1>:ub
+#define Q3 		r[Q_AddrReg, 48]<16;16,1>:ub
+
+// New region as dest
+#undef 	NewP2
+#undef 	NewP1
+#undef 	NewP0
+#undef 	NewQ0
+#undef 	NewQ1
+#undef 	NewQ2
+
+#define NewP2 	r[P_AddrReg, 16]<1>:ub
+#define NewP1 	r[P_AddrReg, 32]<1>:ub
+#define NewP0 	r[P_AddrReg, 48]<1>:ub
+#define NewQ0 	r[Q_AddrReg,  0]<1>:ub
+#define NewQ1 	r[Q_AddrReg, 16]<1>:ub
+#define NewQ2 	r[Q_AddrReg, 32]<1>:ub
+
+
+
+// Filter one luma edge - mbaff
+FILTER_Y_MBAFF:
+
+#if defined(_DEBUG) 
+	mov		(1)		EntrySignatureC:w			0x1111:w
+#endif
+	//---------- Derive filterSampleflag in AVC spec, equition (8-469) ----------
+	// bS is in MaskA
+
+	// Src copy of the p3, p2, p1, p0, q0, q1, q2, q3
+//	mov (16) p0123_W(0)<1>		r[P_AddrReg]<16;16,1>:uw
+//	mov (16) p0123_W(1)<1>		r[P_AddrReg, 32]<16;16,1>:uw
+//	mov (16) q0123_W(0)<1>		r[Q_AddrReg]<16;16,1>:uw
+//	mov (16) q0123_W(1)<1>		r[Q_AddrReg, 32]<16;16,1>:uw
+
+	// Move MaskA and MaskB to flag regs
+	mov (2)	f0.0<1>:uw		MaskA<2;2,1>:uw
+
+	add (16) q0_p0(0)<1>		Q0			-P0				// q0-p0
+	add (16) TempRow0(0)<1>		P1			-P0				// p1-p0
+	add (16) TempRow1(0)<1>		Q1			-Q0				// q1-q0
+
+	// abs(q0-p0) < alpha
+	(f0.0) cmp.l.f0.0 (16) null:w		(abs)q0_p0(0)		Mbaff_ALPHA(0)
+	// abs(p1-p0) < Beta
+	(f0.0) cmp.l.f0.0 (16) null:w		(abs)TempRow0(0)	Mbaff_BETA(0)
+	// abs(q1-q0) < Beta
+	(f0.0) cmp.l.f0.0 (16) null:w		(abs)TempRow1(0)	Mbaff_BETA(0)
+
+	//-----------------------------------------------------------------------------------------
+
+    (f0.0)	if	(16)		MBAFF_Y_ENDIF1
+		// For channels whose edge control map1 = 1 ---> perform de-blocking
+
+//		mov (1)		f0.1:uw		MaskB:uw	{NoMask}		// Now check for which algorithm to apply
+
+		// (abs)ap = |p2-p0|
+		add (16) ap(0)<1>		P2		-P0
+
+		// (abs)aq = |q2-q0|
+		add (16) aq(0)<1>		Q2		-Q0
+
+		// Make a copy of unmodified p0 and p1 for use in q0'and q1' calculation
+		mov (16) p0123_W(1)<1>		r[P_AddrReg, 32]<16;16,1>:uw		{NoMask}
+			
+		(f0.1)	if	(16)		MBAFF_Y_ELSE2
+
+			// For channels whose edge control map2 = 1 ---> bS = 4 algorithm
+
+			// Compute q0', q1' and q2'
+			//-----------------------------------------------------------------------------
+			// bS = 4 Algorithm :			
+			//
+			// gama = |p0-q0| < ((alpha >> 2) + 2) 
+			// deltap = (ap<beta) && gama;  		// deep filter flag
+			//	if (deltap) {
+			//		p0' = (        p2 +2*p1 +2*p0 +2*q0 + q1 + 4) >> 3; 
+			// 		p1' = (        p2 +  p1 +  p0 +  q0      + 2) >> 2;
+			// 		p2' = (2*p3 +3*p2 +  p1 +  p0 +  q0      + 4) >> 3;
+			//	} else {  
+			//		p0' = (            2*p1 +  p0 +  q1      + 2) >> 2;
+			//	}
+			//-----------------------------------------------------------------------------
+
+			// gama = |p0-q0| < ((alpha >> 2) + 2) = |p0-q0| < alpha2  
+			cmp.l.f0.1 (16) null:w	(abs)q0_p0(0)	Mbaff_ALPHA2(0)
+
+			// Common P01 = p0 + p1
+			add (16)	P0_plus_P1(0)<1>	P0			P1	
+
+			// Common Q01 = q0 + q1
+			add (16)	Q0_plus_Q1(0)<1>	Q0			Q1
+
+			mov (1)	f0.0:uw			f0.1:uw						{NoMask}
+
+			// deltap = ((abs)ap < beta) && gama
+			(f0.1) cmp.l.f0.1 (16) null:w	(abs)ap(0)		Mbaff_BETA(0)							// (abs)ap < beta ?
+
+			// deltaq = ((abs)aq < beta) && gama
+			(f0.0) cmp.l.f0.0 (16) null:w	(abs)aq(0)		Mbaff_BETA(0)							// (abs)aq < beta ?
+
+
+			(f0.1)	if	(16)		MBAFF_Y_ELSE3			// for channels its deltap = true
+	
+			add (16)	P2_plus_P3(0)<1>	P2		P3
+			
+			// A =  p1 + p0 + q0 = P01 + q0
+			add (16)	A(0)<1>			P0_plus_P1(0)		Q0							// A =  P01 + q0
+
+			// Now acc0 = A
+
+			// B =  p2 + p1 + p0 + q0 + 4 = p2 + A + 4
+			add (16)	acc0.0<1>:w		acc0.0<16;16,1>:w		4:w								// p2 + 4 
+			add (16)	B(0)<1>			acc0.0<16;16,1>:w		P2					// B = p2 + A + 4
+
+			// Now acc0 = B
+
+			// p2' = (2*p3 +3*p2 + A + 4) >> 3 = (2*(p3+p2) + B) >> 3
+			mac (16)	acc0.0<1>:w		P2_plus_P3(0)		2:w		
+			shr.sat (16) TempRow3B(0)<2>	acc0.0<16;16,1>:w		3:w
+
+			// p1' = (p2 + A + 2) >> 2 = (B - 2) >> 2
+			add (16)	acc0.0<1>:w		B(0)			-2:w
+			shr.sat (16) TempRow1B(0)<2>	acc0.0<16;16,1>:w		2:w
+	
+			// p0' = (p2 +2*A + q1 + 4) >> 3 = (B + A + q1) >> 3
+			add (16)	acc0.0<1>:w		Q1				A(0)							// B + A
+			add (16)	acc0.0<1>:w		acc0.0<16;16,1>:w		B(0)							// B + A + q1
+			shr.sat (16) TempRow0B(0)<2>	acc0.0<16;16,1>:w		3:w								// (B + A + q1) >> 3
+
+			mov (16) 	NewP2		TempRow3B(0)						// p2'
+			mov (16) 	NewP1		TempRow1B(0)						// p1'			
+			mov (16) 	NewP0		TempRow0B(0)						// p0'
+
+MBAFF_Y_ELSE3:
+			else (16)		MBAFF_Y_ENDIF3		// for channels its deltap = false
+
+			// p0' = (2*p1 + p0 + q1 + 2) >> 2 =  (p1 + P01 + q1 + 2) >> 2
+			add (16)	acc0.0<1>:w		P1			P0_plus_P1(0)			// p1 + P01 (TempRow1(0) = P01)
+			add (16)	acc0.0<1>:w		acc0.0<16;16,1>:w	Q1				
+			add (16)	acc0.0<1>:w		acc0.0<16;16,1>:w	2:w			// p1 + P01 + q1 + 2
+
+			shr.sat (16) TempRow0B(0)<2>	acc0.0<16;16,1>:w		2:w	// >> 2
+			mov (16) 	NewP0		TempRow0B(0)						// p0'
+
+			endif
+
+MBAFF_Y_ENDIF3:
+			// Compute q0', q1' and q2'
+			//-----------------------------------------------------------------------------
+			// bS = 4 Algorithm (cont):			
+			//
+			//	deltaq = (aq<beta) && gama;  		// deep filter flag
+			//	if (deltaq) {
+			//		q0' = (        q2 +2*q1 +2*q0 +2*p0 + p1 + 4) >> 3; 
+			//		q1' = (        q2 +  q1 +  q0 +  p0      + 2) >> 2;
+			//		q2' = (2*q3 +3*q2 +  q1 +  q0 +  p0      + 4) >> 3;
+			//	} else {
+			//		q0' = (            2*q1 +  q0 +  p1      + 2) >> 2;
+			//	}
+			
+			(f0.0)	if	(16)		MBAFF_Y_ELSE4			// for channels its deltaq = true
+			
+			add (16)	Q2_plus_Q3(0)<1>	Q2			Q3
+
+			// A =  q1 + q0 + p0 = Q01 + p0
+			add (16)	A(0)<1>			Q0_plus_Q1(0)		p0(0)							// A =  q1+q0 + p0
+
+			// B =  q2 + q1 + q0 + p0 + 4 = q2 + A + 4
+			add (16)	acc0.0<1>:w		acc0.0<16;16,1>:w		4:w							// q2 + 4 
+			add (16)	B(0)<1>			acc0.0<16;16,1>:w		Q2								// B = q2 + A + 4
+			
+			// Acc0 = B
+
+			// q2' = (2*q3 +3*q2 + A + 4) >> 3 = (2*(q3+q2) + B) >> 3
+			mac (16)	acc0.0<1>:w		Q2_plus_Q3(0)	2:w
+			shr.sat (16) TempRow3B(0)<2>	acc0.0<16;16,1>:w		3:w
+
+			// q1' = (q2 + A + 2) >> 2 = (B - 2) >> 2
+			add (16)	acc0.0<1>:w		B(0)			-2:w
+			shr.sat (16) TempRow1B(0)<2>	acc0.0<16;16,1>:w	2:w
+			
+			// q0' = (q2 +2*A + p1 + 4) >> 3 = (B + A + p1) >> 3
+			add (16)	acc0.0<1>:w		p1(0)					A(0)
+			add (16)	acc0.0<1>:w		acc0.0<16;16,1>:w		B(0)
+			shr.sat (16) TempRow0B(0)<2>	acc0.0<16;16,1>:w	3:w
+			
+			mov (16) 	NewQ2		TempRow3B(0)						// q2'
+			mov (16) 	NewQ1		TempRow1B(0)						// q1'
+			mov (16) 	NewQ0		TempRow0B(0)						// q0'
+
+MBAFF_Y_ELSE4:
+			else (16)		MBAFF_Y_ENDIF4		// for channels its deltaq = false
+
+			// q0' = (2*q1 + q0 + p1 + 2) >> 2 =  (q1 + Q01 + p1 + 2) >> 2
+			// Use original p1 values in p1(0)
+			add (16)	acc0.0<1>:w		p1(0)			Q0_plus_Q1(0)			// p1 + P01 (TempRow1(0) = P01)
+			add (16)	acc0.0<1>:w		acc0.0<16;16,1>:w	Q1				
+			add (16)	acc0.0<1>:w		acc0.0<16;16,1>:w	2:w			// p1 + P01 + q1 + 2
+
+			shr.sat (16)	TempRow0B(0)<2>		acc0.0<16;16,1>:w		2:w								// >> 2
+			mov (16) 	NewQ0		TempRow0B(0)						// q0'
+
+			endif
+MBAFF_Y_ENDIF4:
+
+			
+			// Done with bS = 4 algorithm
+			
+MBAFF_Y_ELSE2: 
+		else 	(16)		MBAFF_Y_ENDIF2
+			// For channels whose edge control map2 = 0 ---> bS < 4 algorithm
+
+			//-----------------------------------------------------------------------------
+			// bS < 4 Algorithm :
+			// tc = tc0 + (|p2-p0|<Beta ? 1 : 0) + (|q2-q0|<Beta ? 1 : 0)
+			// delta = Clip3(-tc, tc, ((((q0-p0)<<2) + (p1-q1) + 4) >> 3))
+			// p0' = Clip1(p0 + delta) = Clip3(0, 0xFF, p0 + delta)
+			// q0' = Clip1(q0 - delta) = Clip3(0, 0xFF, q0 - delta)
+			// if (|p2-p0|<Beta)
+			// 		p1' = p1 + Clip3(-tc0, tc0, (p2 + ((p0+q0+1)>>1) - (p1<<1)) >> 1 )
+			// if (|q2-q0|<Beta)
+			// 		q1' = q1 + Clip3(-tc0, tc0, (q2 + ((p0+q0+1)>>1) - (q1<<1)) >> 1 )
+			//-----------------------------------------------------------------------------
+			
+			mov (16)	tc_exp(0)<1>		Mbaff_TC0(0)								// tc = tc0_exp first
+			
+			cmp.l.f0.0 (16)	null:w		(abs)ap(0)			Mbaff_BETA(0)				// |p2-p0|<Beta ?
+			cmp.l.f0.1 (16)	null:w		(abs)aq(0)			Mbaff_BETA(0)				// |q2-q0|<Beta ?
+				
+			//--- Use free cycles here ---
+			// delta = Clip3(-tc, tc, ((((q0-p0)<<2) + (p1-q1) + 4) >> 3))
+			// 4 * (q0-p0) + p1 - q1 + 4
+			add (16) acc0<1>:w		P1			4:w							// p1 + 4
+			mac (16) acc0<1>:w		q0_p0(0)	4:w							// 4 * (q0-p0) + p1 + 4
+			add (16) acc0<1>:w		acc0<16;16,1>:w		-Q1					// 4 * (q0-p0) + p1 - q1 + 4
+			shr (16) TempRow0(0)<1> acc0<16;16,1>:w		3:w
+						
+			// Continue on getting tc_exp
+			(f0.0) add (16)	tc_exp(0)<1>	tc_exp(0)	1:w							// tc0_exp + (|p2-p0|<Beta ? 1 : 0)
+			mov (2)	CTemp1_W<1>:w		f0.0<2;2,1>:w			{NoMask}					// Save	|p2-p0|<Beta flag			
+			(f0.1) add (16)	tc_exp(0)<1>	tc_exp(0)	1:w							// tc_exp = tc0_exp + (|p2-p0|<Beta ? 1 : 0) + (|q2-q0|<Beta ? 1 : 0)
+				
+			// Continue on cliping tc to get delta
+			cmp.g.f0.0	(16) null:w		TempRow0(0)		tc_exp(0)					// Clip if delta' > tc
+			cmp.l.f0.1	(16) null:w		TempRow0(0)		-tc_exp(0)					// Clip if delta' < -tc
+
+			//--- Use free cycles here ---
+			// common = (p0+q0+1) >> 1 	  --->  TempRow2(0)
+			// Same as avg of p0 and q0
+			avg (16) TempRow2(0)<1>		P0			Q0
+
+			// Continue on cliping tc to get delta
+			(f0.0) mov (16) TempRow0(0)<1>				tc_exp(0)
+			(f0.1) mov (16) TempRow0(0)<1>				-tc_exp(0)
+
+			//--- Use free cycles here ---
+			mov (2)	f0.0<1>:w		CTemp1_W<2;2,1>:w	{NoMask}			// CTemp1_W = (|p2-p0|<Beta)
+																			// CTemp2_W = (|q2-q0|<Beta)		
+
+			// p0' = Clip1(p0 + delta) = Clip3(0, 0xFF, p0 + delta)
+			// q0' = Clip1(q0 - delta) = Clip3(0, 0xFF, q0 - delta)
+			add.sat (16) TempRow1B(0)<2>		P0			TempRow0(0)					// p0+delta
+			add.sat (16) TempRow0B(0)<2>		Q0			-TempRow0(0) 				// q0-delta
+			
+			mov (16) NewP0		TempRow1B(0)					// p0'
+			mov (16) NewQ0		TempRow0B(0)					// q0'
+
+			//-----------------------------------------------------------------------
+
+			// Now compute p1' and q1'
+
+			// if (|p2-p0|<Beta)
+			(f0.0)	if	(16)		MBAFF_Y_ENDIF6
+
+			// p1' = p1 + Clip3(-tc0, tc0, adj)
+			// adj = (p2 + common - (p1<<1)) >> 1 = (p2 + common - (p1*2)) >> 1
+			add (16) acc0<1>:w	P2		TempRow2(0)							// TempRow2(0) = common = (p0+q0+1) >> 1
+			mac (16) acc0<1>:w	P1		-2:w
+			shr (16) TempRow1(0)<1>		acc0<16;16,1>:w		1:w
+
+			// tc clip to get tc_adj
+			cmp.g.f0.0	(16) null:w		TempRow1(0)		Mbaff_TC0(0)					// Clip if delta' > tc
+			cmp.l.f0.1	(16) null:w		TempRow1(0)		-Mbaff_TC0(0)					// Clip if delta' < -tc
+			
+			(f0.0) mov (16) TempRow1(0)<1>				Mbaff_TC0(0)
+			(f0.1) mov (16) TempRow1(0)<1>				-Mbaff_TC0(0)
+
+			//--- Use free cycles here ---
+			mov (1)	f0.1:w		CTemp2_W:w				{NoMask}			// CTemp2_W = (|q2-q0|<Beta)
+
+			// p1' = p1 + tc_adj
+			add.sat (16) TempRow1B(0)<2>		P1			TempRow1(0)					// p1+tc_adj
+			mov (16) NewP1			TempRow1B(0)				// p1'
+			//------------------------------------------------------------------------
+
+MBAFF_Y_ENDIF6:
+			endif
+			
+			// if (|q2-q0|<Beta)
+			(f0.1)	if	(16)		MBAFF_Y_ENDIF7
+
+			// q1' = q1 + Clip3(-tc0, tc0, adj)
+			// adj = (q2 + common - (q1<<1)) >> 1 
+			// same as q2 + common - (q1 * 2)
+			add (16) acc0<1>:w	Q2		TempRow2(0)
+			mac (16) acc0<1>:w	Q1		-2:w
+			shr (16) TempRow1(0)<1>		acc0<16;16,1>:w		1:w	
+					
+			// tc clip to get tc_adj
+			cmp.g.f0.0	(16) null:w		TempRow1(0)		Mbaff_TC0(0)					// Clip if delta' > tc
+			cmp.l.f0.1	(16) null:w		TempRow1(0)		-Mbaff_TC0(0)					// Clip if delta' < -tc
+
+			(f0.0) mov (16) TempRow1(0)<1>				Mbaff_TC0(0)
+			(f0.1) mov (16) TempRow1(0)<1>				-Mbaff_TC0(0)
+			
+			// q1' = q1 + tc_adj
+			add.sat (16) TempRow1B(0)<2>		Q1			TempRow1(0)					// q1+tc_adj
+			mov (16) NewQ1			TempRow1B(0)				// q1'
+			
+			//------------------------------------------------------------------------			
+MBAFF_Y_ENDIF7:
+			endif
+
+		endif
+MBAFF_Y_ENDIF2:
+MBAFF_Y_ENDIF1:
+	endif
+
+RETURN
+
+#endif	// !defined(__AVC_ILDB_LUMA_CORE_MBAFF__)
diff --git a/i965_drv_video/shaders/h264/ildb/AVC_ILDB_OpenGateway.asm b/i965_drv_video/shaders/h264/ildb/AVC_ILDB_OpenGateway.asm
new file mode 100644
index 0000000..06d1933
--- /dev/null
+++ b/i965_drv_video/shaders/h264/ildb/AVC_ILDB_OpenGateway.asm
@@ -0,0 +1,43 @@
+/*
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+//----- Open a Message Gateway -----
+// The parent thread is the recipient thread
+
+#if defined(_DEBUG) 
+	mov		(1)		EntrySignature:w			0x1111:w
+#endif
+
+mov (8) 	GatewayPayload<1>:ud 		r0.0<8;8,1>:ud			// Init payload to r0
+
+// r50- (16 GRFs) are the GRFs child thread can wtite to. 
+
+// Reg base is at bit 28:21, Gateway size is at [bit 10:8]
+// r6: 6 = 00000110
+//000 00000110 0000000000 100 00000000 ==> 0000 0000 1100 0000 0000 0100 0000 0000
+mov (1) 	RegBase_GatewaySize:ud 	0x00C00400:ud	// Reg base + Gateway size (16 GRFs)
+
+
+//000 00110010 0000000000 100 00000000 ==> 0000 0110 0100 0000 0000 0100 0000 0000
+//mov (1) 	RegBase_GatewaySize:ud 	0x06400400:ud	// Reg base (r50 = 0x640 byte offset) + Gateway size (16 GRFs)
+
+//mov (1) 	DispatchID:ub 			r0.20:ub		// Dispatch ID
+mov (1) 	GatewayPayloadKey:uw 	0x1212:uw		// Key=0x1212
+
+// Message descriptor
+// bit 31	EOD
+// 27:24	FFID = 0x0011 for msg gateway
+// 23:20	msg length = 1 MRF
+// 19:16	Response length	= 0
+// 14		AckReg = 1
+// 1:0		SubFuncID = 00 for OpenGateway
+// Message descriptor: 0 000 0011 0001 0000 + 0 1 000000000000 00 ==> 0000 0011 0001 0000 0100 0000 0000 0000
+// Send message to gateway: the ack message is put into response GRF r49 ==> Good for debugging
+send (8)  	GatewayResponse:ud	m7	  GatewayPayload<8;8,1>:ud    MSG_GW	OGWMSGDSC
+
+//----- End of Open a Message Gateway -----
diff --git a/i965_drv_video/shaders/h264/ildb/AVC_ILDB_Root_Field_UV.asm b/i965_drv_video/shaders/h264/ildb/AVC_ILDB_Root_Field_UV.asm
new file mode 100644
index 0000000..759e80a
--- /dev/null
+++ b/i965_drv_video/shaders/h264/ildb/AVC_ILDB_Root_Field_UV.asm
@@ -0,0 +1,9 @@
+/*
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+#include "AVC_ILDB_Root_UV.asm"
diff --git a/i965_drv_video/shaders/h264/ildb/AVC_ILDB_Root_Field_Y.asm b/i965_drv_video/shaders/h264/ildb/AVC_ILDB_Root_Field_Y.asm
new file mode 100644
index 0000000..f88eede
--- /dev/null
+++ b/i965_drv_video/shaders/h264/ildb/AVC_ILDB_Root_Field_Y.asm
@@ -0,0 +1,9 @@
+/*
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+#include "AVC_ILDB_Root_Y.asm"
diff --git a/i965_drv_video/shaders/h264/ildb/AVC_ILDB_Root_Mbaff_UV.asm b/i965_drv_video/shaders/h264/ildb/AVC_ILDB_Root_Mbaff_UV.asm
new file mode 100644
index 0000000..01109be
--- /dev/null
+++ b/i965_drv_video/shaders/h264/ildb/AVC_ILDB_Root_Mbaff_UV.asm
@@ -0,0 +1,140 @@
+/*
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+/////////////////////////////////////////////////////////////////////////////////////
+// Kernel name: AVC_ILDB_Root_Mbaff.asm
+//
+//  Root kernel serves as a scheduler for child threads.
+//
+//
+//	***** Note *****
+//	Initial design bundle MB pair for each thread, and share AVC_ILDB_MB_Dep_Check.asm
+//	with non mbaff kernels.
+//
+//	Optimization will be done later, putting top and bottom MBs on separate threads.
+//
+//
+/////////////////////////////////////////////////////////////////////////////////////
+//
+//  $Revision: 1 $
+//  $Date: 10/19/06 5:06p $
+//
+
+// ----------------------------------------------------
+//  AVC_ILDB_ROOT_MBAFF_UV
+// ----------------------------------------------------
+#define AVC_ILDB
+
+.kernel AVC_ILDB_ROOT_MBAFF_UV
+#if defined(COMBINED_KERNEL)
+ILDB_LABEL(AVC_ILDB_ROOT_UV):
+#endif
+
+#include "setupVPKernel.asm"
+#include "AVC_ILDB.inc"
+
+
+#if defined(_DEBUG) 
+
+/////////////////////////////////////////////////////////////////////////////////////
+// Init URB space for running on RTL.  It satisfies reading an unwritten URB entries.  
+// Will remove it for production release.
+
+
+//mov (8) m1:ud 		0x11111111:ud
+//mov (8) m2:ud 		0x22222222:ud 
+//mov (8) m3:ud 		0x33333333:ud
+//mov (8) m4:ud 		0x44444444:ud 
+
+//mov (1)	Temp1_W:w	0:w
+
+//ILDB_INIT_URB:
+//mul (1)	URBOffset:w				Temp1_W:w		4:w
+//shl (1) URBWriteMsgDescLow:uw 	URBOffset:w		4:w		// Msg descriptor: URB write dest offset (9:4)
+//mov (1) URBWriteMsgDescHigh:uw 	0x0650:uw				// Msg descriptor: URB write 5 MRFs (m0 - m4)
+//#include "writeURB.asm"
+
+//add		(1)		Temp1_W:w	Temp1_W:w	1:w				// Increase block count
+//cmp.l.f0.0 (1) 	null		Temp1_W:w	MBsCntY:w		// Check the block count limit
+//(f0.0) jmpi		ILDB_INIT_URB							// Loop back
+
+
+/////////////////////////////////////////////////////////////////////////////////////
+
+
+mov		(1)		EntrySignature:w			0xEFF0:w
+
+#endif
+//----------------------------------------------------------------------------------------------------------------
+
+// Set global variable
+mov (32) 	ChildParam:uw			0:uw								// Reset local variables
+//mul	(1)	 	TotalBlocks:w			MBsCntX:w		MBsCntY:w			// Total # of MB pairs
+//add	(1)	 	GatewayApertureE:w		MBsCntY:w 		GatewayApertureB:w	// Aperture End = aperture Head + BlockCntY
+
+
+// 2 URB entries for Y:
+// Entry 0 - Child thread R0Hdr
+// Entry 1 - input parameter to child kernel (child r1)
+
+#define 	URB_ENTRIES_PER_MB 	2
+
+// URB_ENTRIES_PER_MB in differnt form, the final desired format is (URB_ENTRIES_PER_MB-1) << 10
+mov (1) URB_EntriesPerMB_2:w		URB_ENTRIES_PER_MB-1:w
+shl (1) URB_EntriesPerMB_2:w		URB_EntriesPerMB_2:w	10:w
+
+#define 	CHROMA_ROOT														// Compiling flag for chroma only
+//mul (1)		URBOffsetUVBase:w		MBsCntY:w		URB_ENTRIES_PER_MB:w	// Right after Y entries
+
+// URB base for UV kernels
+#if defined(DEV_CL)	
+	mov (1)		URBOffsetUVBase:w		240:w
+#else
+	mov (1)		URBOffsetUVBase:w		320:w
+#endif
+
+
+mov	(1)		ChildThreadsID:uw		3:uw
+
+shr (1)		ThreadLimit:w		MaxThreads:w		1:w		// Initial luma thread limit to 50%
+mul	(1)	 	TotalBlocks:w		MBsCntX:w		MBsCntY:w	// MBs to be processed count down from TotalBlocks
+
+//***** Init CT_R0Hdr fields that are common to all threads *************************
+mov (8)	CT_R0Hdr.0:ud			r0.0<8;8,1>:ud				// Init to root R0 header
+mov (1)	CT_R0Hdr.7:ud			r0.6:ud						// Copy Parent Thread Cnt; JJ did the change on 06/20/2006
+mov (1) CT_R0Hdr.31:ub			0:w							// Reset the highest byte
+mov (1) CT_R0Hdr.3:ud 			0x00000000	 
+mov (1) CT_R0Hdr.6:uw 			sr0.0:uw					// sr0.0: state reg contains general thread states, e.g. EUID/TID.
+
+//***** Init ChildParam fields that are common to all threads ***********************
+mov (8) 	ChildParam<1>:ud	RootParam<8;8,1>:ud		// Copy all root parameters
+mov (4)		CurCol<1>:w			0:w						// Reset CurCol, CurRow
+add	(2)		LastCol<1>:w		MBsCntX<2;2,1>:w		-1:w	// Get LastCol and LastRow
+
+mov (1) URBWriteMsgDesc:ud		MSG_LEN(2)+URBWMSGDSC:ud
+
+//===================================================================================
+
+#include "AVC_ILDB_OpenGateway.asm"		// Open root thread gateway for receiving notification 
+
+#include "AVC_ILDB_Dep_Check.asm"  	// Check dependency and spawn all MBs
+
+//#include "AVC_ILDB_UpdateThrdLimit.asm"	// Update thread limit in luma root thread via gateway
+
+#include "AVC_ILDB_CloseGateway.asm"	// Close root thread gateway 
+
+// Chroma root EOT = child send EOT : Request type = 1
+	END_CHILD_THREAD
+
+#undef 	CHROMA_ROOT
+
+#if !defined(COMBINED_KERNEL)		// For standalone kernel only
+.end_code
+
+.end_kernel
+#endif
diff --git a/i965_drv_video/shaders/h264/ildb/AVC_ILDB_Root_Mbaff_Y.asm b/i965_drv_video/shaders/h264/ildb/AVC_ILDB_Root_Mbaff_Y.asm
new file mode 100644
index 0000000..ae80a36
--- /dev/null
+++ b/i965_drv_video/shaders/h264/ildb/AVC_ILDB_Root_Mbaff_Y.asm
@@ -0,0 +1,140 @@
+/*
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+/////////////////////////////////////////////////////////////////////////////////////
+// Kernel name: AVC_ILDB_Root_Mbaff.asm
+//
+//  Root kernel serves as a scheduler for child threads.
+//
+//
+//	***** Note *****
+//	Initial design bundle MB pair for each thread, and share AVC_ILDB_MB_Dep_Check.asm
+//	with non mbaff kernels.
+//
+//	Optimization will be done later, putting top and bottom MBs on separate threads.
+//
+//
+/////////////////////////////////////////////////////////////////////////////////////
+//
+//  $Revision: 1 $
+//  $Date: 10/19/06 5:06p $
+//
+
+// ----------------------------------------------------
+//  AVC_ILDB_ROOT_MBAFF_Y
+// ----------------------------------------------------
+#define AVC_ILDB
+
+.kernel AVC_ILDB_ROOT_MBAFF_Y
+#if defined(COMBINED_KERNEL)
+ILDB_LABEL(AVC_ILDB_ROOT_Y):
+#endif
+
+#include "setupVPKernel.asm"
+#include "AVC_ILDB.inc"
+
+
+#if defined(_DEBUG) 
+
+/////////////////////////////////////////////////////////////////////////////////////
+// Init URB space for running on RTL.  It satisfies reading an unwritten URB entries.  
+// Will remove it for production release.
+
+
+//mov (8) m1:ud 		0x11111111:ud
+//mov (8) m2:ud 		0x22222222:ud 
+//mov (8) m3:ud 		0x33333333:ud
+//mov (8) m4:ud 		0x44444444:ud 
+
+//mov (1)	Temp1_W:w	0:w
+
+//ILDB_INIT_URB:
+//mul (1)	URBOffset:w				Temp1_W:w		4:w
+//shl (1) URBWriteMsgDescLow:uw 	URBOffset:w		4:w		// Msg descriptor: URB write dest offset (9:4)
+//mov (1) URBWriteMsgDescHigh:uw 	0x0650:uw				// Msg descriptor: URB write 5 MRFs (m0 - m4)
+//#include "writeURB.asm"
+
+//add		(1)		Temp1_W:w	Temp1_W:w	1:w				// Increase block count
+//cmp.l.f0.0 (1) 	null		Temp1_W:w	MBsCntY:w		// Check the block count limit
+//(f0.0) jmpi		ILDB_INIT_URB							// Loop back
+
+/////////////////////////////////////////////////////////////////////////////////////
+
+
+mov		(1)		EntrySignature:w			0xEFF0:w
+
+#endif
+//----------------------------------------------------------------------------------------------------------------
+
+// Set global variable
+mov (32) 	ChildParam:uw			0:uw								// Reset local variables
+//mul	(1)	 	TotalBlocks:w			MBsCntX:w		MBsCntY:w			// Total # of MB pairs
+//add	(1)	 	GatewayApertureE:w		MBsCntY:w 		GatewayApertureB:w	// Aperture End = aperture Head + BlockCntY
+
+
+// 2 URB entries for Y:
+// Entry 0 - Child thread R0Hdr
+// Entry 1 - input parameter to child kernel (child r1)
+
+#undef 		URB_ENTRIES_PER_MB
+#define 	URB_ENTRIES_PER_MB	 	2
+
+// URB_ENTRIES_PER_MB in differnt form, the final desired format is (URB_ENTRIES_PER_MB-1) << 10
+mov (1) 	URB_EntriesPerMB_2:w		URB_ENTRIES_PER_MB-1:w
+shl (1) 	URB_EntriesPerMB_2:w		URB_EntriesPerMB_2:w	10:w
+
+mov	(1)		ChildThreadsID:uw		1:uw					// ChildThreadsID for chroma root
+
+shr (1)		ThreadLimit:w		MaxThreads:w		1:w		// Initial luma thread limit to 50%
+mul	(1)	 	TotalBlocks:w		MBsCntX:w		MBsCntY:w	// MBs to be processed count down from TotalBlocks
+
+//***** Init CT_R0Hdr fields that are common to all threads *************************
+mov (8)		CT_R0Hdr.0:ud			r0.0<8;8,1>:ud				// Init to root R0 header
+mov (1)		CT_R0Hdr.7:ud			r0.6:ud						// Copy Parent Thread Cnt; JJ did the change on 06/20/2006
+mov (1) 	CT_R0Hdr.31:ub			0:w							// Reset the highest byte
+mov (1) 	CT_R0Hdr.3:ud 			0x00000000	 
+mov (1) 	CT_R0Hdr.6:uw 			sr0.0:uw					// sr0.0: state reg contains general thread states, e.g. EUID/TID.
+
+//***** Init ChildParam fields that are common to all threads ***********************
+mov (8) 	ChildParam<1>:ud	RootParam<8;8,1>:ud		// Copy all root parameters
+mov (4)		CurCol<1>:w			0:w						// Reset CurCol, CurRow
+add	(2)		LastCol<1>:w		MBsCntX<2;2,1>:w		-1:w	// Get LastCol and LastRow
+
+mov (1) 	URBWriteMsgDesc:ud		MSG_LEN(2)+URBWMSGDSC:ud
+
+//===================================================================================
+
+#include "AVC_ILDB_OpenGateway.asm"		// Open root thread gateway for receiving notification 
+
+#if defined(DEV_CL)	
+	mov	(1)		URBOffset:uw		240:uw	// Use chroma URB offset to spawn chroma root
+#else
+	mov	(1)		URBOffset:uw		320:uw	// Use chroma URB offset to spawn chroma root
+#endif
+
+#include "AVC_ILDB_SpawnChromaRoot.asm"	// Spawn chroma root
+
+mov	(1)		URBOffset:uw		0:uw	// Use luma URB offset to spawn luma child 
+mov	(1)		ChildThreadsID:uw	2:uw	// Starting ChildThreadsID for luma child threads
+
+#include "AVC_ILDB_Dep_Check.asm"  	// Check dependency and spawn all MBs
+
+// Wait for UV root thread to finish
+ILDB_LABEL(WAIT_FOR_UV):
+cmp.l.f0.0 (1) null:w	ThreadLimit:w		MaxThreads:w
+(f0.0) 	jmpi 	ILDB_LABEL(WAIT_FOR_UV)
+
+#include "AVC_ILDB_CloseGateway.asm"	// Close root thread gateway 
+
+END_THREAD								// End of root thread
+
+#if !defined(COMBINED_KERNEL)		// For standalone kernel only
+.end_code
+
+.end_kernel
+#endif
diff --git a/i965_drv_video/shaders/h264/ildb/AVC_ILDB_Root_UV.asm b/i965_drv_video/shaders/h264/ildb/AVC_ILDB_Root_UV.asm
new file mode 100644
index 0000000..cb8e146
--- /dev/null
+++ b/i965_drv_video/shaders/h264/ildb/AVC_ILDB_Root_UV.asm
@@ -0,0 +1,127 @@
+/*
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+// Kernel name: AVC_ILDB_Root_UV.asm
+//
+//  Root kernel serves as a scheduler for child threads
+//
+//  $Revision: 1 $
+//  $Date: 10/19/06 5:06p $
+//
+
+// ----------------------------------------------------
+//  AVC_ILDB_ROOT_UV
+// ----------------------------------------------------
+#define AVC_ILDB
+
+.kernel AVC_ILDB_ROOT_UV
+#if defined(COMBINED_KERNEL)
+ILDB_LABEL(AVC_ILDB_ROOT_UV):
+#endif
+ 
+#include "setupVPKernel.asm"
+#include "AVC_ILDB.inc"
+
+#if defined(_DEBUG) 
+mov		(1)		EntrySignature:w			0xFF11:w
+#endif
+
+/////////////////////////////////////////////////////////////////////////////////////
+#if defined(_DEBUG) 
+
+// Init URB space for running on RTL.  It satisfies reading an unwritten URB entries.  
+// Will remove it for production release.
+
+mov (8) m1:ud 		0x55555555:ud
+mov (8) m2:ud 		0x66666666:ud 
+mov (8) m3:ud 		0x77777777:ud
+mov (8) m4:ud 		0x88888888:ud 
+
+mov (1)	Temp1_W:w	MBsCntY:w
+shl (1)	Temp2_W:w	MBsCntY:w		1:w
+
+ILDB_LABEL(ILDB_INIT_URB_UV):
+mul (1)	URBOffset:uw			Temp1_W:uw		4:w		// Each thread uses 4 URB entries (1 r0 + 1 inline + 2 data)
+mov (1) URBWriteMsgDesc:ud		MSG_LEN(4)+URBWMSGDSC:ud			// Msg descriptor: URB write msg length = 5
+#include "writeURB.asm"
+
+add		(1)		Temp1_W:w	Temp1_W:w	1:w				// Increase block count
+cmp.l.f0.0 (1) 	null		Temp1_W:w	Temp2_W:w		// Check the block count limit
+(f0.0) jmpi		ILDB_LABEL(ILDB_INIT_URB_UV)			// Loop back
+
+mov		(1)		EntrySignature:w			0xFFF0:w
+
+#endif
+/////////////////////////////////////////////////////////////////////////////////////
+
+// Set global variable
+mov (32) 	ChildParam:uw			0:uw								// Reset local variables, 2 GRFs
+//mul	(1)	 	TotalBlocks:w			MBsCntX:w		MBsCntY:w			// Total # of blocks
+//add	(1)	 	GatewayApertureE:w		MBsCntY:w 		GatewayApertureB:w	// Aperture End = aperture Head + BlockCntY
+
+// 4 URB entries for Y:
+// Entry 0 - Child thread R0Hdr
+// Entry 1 - input parameter to child kernel (child r1)
+// Entry 2 - Prev MB data UV 2x8
+// Entry 3 - Unused
+
+#define 	URB_ENTRIES_PER_MB 	4
+
+// URB_ENTRIES_PER_MB in differnt form, the final desired format is (URB_ENTRIES_PER_MB-1) << 10
+mov (1) 	URB_EntriesPerMB_2:w		URB_ENTRIES_PER_MB-1:w
+shl (1) 	URB_EntriesPerMB_2:w		URB_EntriesPerMB_2:w	10:w
+
+#define 	CHROMA_ROOT													// Compiling flag for chroma only
+
+// URB base for UV kernels
+#if defined(DEV_CL)	
+	mov (1)		URBOffsetUVBase:w		240:w
+#else
+	mov (1)		URBOffsetUVBase:w		320:w
+#endif
+
+
+mov	(1)		ChildThreadsID:uw		3:uw
+
+shr (1)		ThreadLimit:w		MaxThreads:w		1:w		// Initial luma thread limit to 50%
+mul	(1)	 	TotalBlocks:w		MBsCntX:w		MBsCntY:w	// MBs to be processed count down from TotalBlocks
+
+//***** Init CT_R0Hdr fields that are common to all threads *************************
+mov (8)		CT_R0Hdr.0:ud		r0.0<8;8,1>:ud				// Init to root R0 header
+mov (1) 	CT_R0Hdr.7:ud		r0.6:ud						// Copy Parent Thread Cnt; JJ did the change on 06/20/2006
+mov (1) 	CT_R0Hdr.31:ub		0:w							// Reset the highest byte
+mov (1) 	CT_R0Hdr.3:ud 		0x00000000	 
+mov (1) 	CT_R0Hdr.6:uw 		sr0.0:uw					// sr0.0: state reg contains general thread states, e.g. EUID/TID.
+
+//***** Init ChildParam fields that are common to all threads ***********************
+mov (8) 	ChildParam<1>:ud	RootParam<8;8,1>:ud		// Copy all root parameters
+mov (4)		CurCol<1>:w			0:w						// Reset CurCol, CurRow, 
+add	(2)		LastCol<1>:w		MBsCntX<2;2,1>:w		-1:w	// Get LastCol and LastRow
+
+mov (1) 	URBWriteMsgDesc:ud		MSG_LEN(2)+URBWMSGDSC:ud
+
+//===================================================================================
+
+#include "AVC_ILDB_OpenGateway.asm"		// Open gateway for receiving notification 
+
+#include "AVC_ILDB_Dep_Check.asm"  		// Check dependency and spawn all luma child threads in parallel with chroma root
+
+//#include "AVC_ILDB_LumaThrdLimit.asm"	// Update thread limit in luma root thread via gateway
+
+#include "AVC_ILDB_CloseGateway.asm"	// Close root thread gateway 
+
+// Chroma root EOT = child send EOT : Request type = 1
+	END_CHILD_THREAD
+	
+#undef 	CHROMA_ROOT
+
+#if !defined(COMBINED_KERNEL)		// For standalone kernel only
+.end_code
+
+.end_kernel
+#endif
diff --git a/i965_drv_video/shaders/h264/ildb/AVC_ILDB_Root_Y.asm b/i965_drv_video/shaders/h264/ildb/AVC_ILDB_Root_Y.asm
new file mode 100644
index 0000000..2274b93
--- /dev/null
+++ b/i965_drv_video/shaders/h264/ildb/AVC_ILDB_Root_Y.asm
@@ -0,0 +1,130 @@
+/*
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+// Kernel name: AVC_ILDB_Root_Y.asm
+//
+//  Root kernel serves as a scheduler for child threads
+//
+//  $Revision: 1 $
+//  $Date: 10/19/06 5:06p $
+//
+
+// ----------------------------------------------------
+//  AVC_ILDB_ROOT_Y
+// ----------------------------------------------------
+#define AVC_ILDB
+
+.kernel AVC_ILDB_ROOT_Y
+#if defined(COMBINED_KERNEL)
+ILDB_LABEL(AVC_ILDB_ROOT_Y):
+#endif
+
+#include "setupVPKernel.asm"
+#include "AVC_ILDB.inc"
+
+/////////////////////////////////////////////////////////////////////////////////////
+#if defined(_DEBUG) 
+
+// Init URB space for running on RTL.  It satisfies reading an unwritten URB entries.  
+// Will remove it for production release.
+
+mov (8) m1:ud 		0x11111111:ud
+mov (8) m2:ud 		0x22222222:ud 
+mov (8) m3:ud 		0x33333333:ud
+mov (8) m4:ud 		0x44444444:ud 
+
+mov (1)	Temp1_W:w	0:w
+
+ILDB_LABEL(ILDB_INIT_URB_Y):
+//mul (1)	Temp2_W:w				Temp1_W:w		4:w		// URBOffset
+//shl (1) URBWriteMsgDescLow:uw 	Temp2_W:w		4:w		// Msg descriptor: URB write dest offset (9:4)
+//mov (1) URBWriteMsgDescHigh:uw 	0x0650:uw				// Msg descriptor: URB write 5 MRFs (m0 - m4)
+
+//mul (1)	URBOffset:uw			Temp1_W:uw		4:w		// Each thread uses 4 URB entries (1 r0 + 1 inline + 2 data)
+mul (1)	URBOffset:uw			Temp1_W:uw		2:w		// Each thread uses 2 URB entries (1 r0 + 1 inline)
+mov (1) URBWriteMsgDesc:ud		MSG_LEN(2)+URBWMSGDSC:ud			// Msg descriptor: URB write msg length = 3
+#include "writeURB.asm"
+
+add		(1)		Temp1_W:w	Temp1_W:w	1:w				// Increase block count
+cmp.l.f0.0 (1) 	null		Temp1_W:w	MBsCntY:w		// Check the block count limit
+(f0.0) jmpi		ILDB_LABEL(ILDB_INIT_URB_Y)							// Loop back
+
+mov		(1)		EntrySignature:w			0xFFF0:w
+
+#endif
+/////////////////////////////////////////////////////////////////////////////////////
+
+
+// Set global variable
+mov (32) 	ChildParam:uw			0:uw								// Reset local variables, 2 GRFs
+//mul	(1)	 	TotalBlocks:w			MBsCntX:w		MBsCntY:w			// Total # of blocks
+//add	(1)	 	GatewayApertureE:w		MBsCntY:w 		GatewayApertureB:w	// Aperture End = aperture Head + BlockCntY
+
+// 4 URB entries for Y:
+// Entry 0 - Child thread R0Hdr
+// Entry 1 - input parameter to child kernel (child r1)
+// Entry 2 - Prev MB data Y 4x16, col 1 and col 0
+// Entry 3 - Prev MB data Y 4x16, col 3 and col 2
+
+#undef 		URB_ENTRIES_PER_MB
+#define 	URB_ENTRIES_PER_MB		4
+
+// URB_ENTRIES_PER_MB in differnt form, the final desired format is (URB_ENTRIES_PER_MB-1) << 10
+mov (1) 	URB_EntriesPerMB_2:w		URB_ENTRIES_PER_MB-1:w
+shl (1) 	URB_EntriesPerMB_2:w		URB_EntriesPerMB_2:w	10:w
+
+shr (1)		ThreadLimit:w		MaxThreads:w	1:w			// Initial luma thread limit to 50%
+mul	(1)	 	TotalBlocks:w		MBsCntX:w		MBsCntY:w	// MBs to be processed count down from TotalBlocks
+
+//***** Init CT_R0Hdr fields that are common to all threads *************************
+mov (8)		CT_R0Hdr.0:ud		r0.0<8;8,1>:ud				// Init to root R0 header
+mov (1) 	CT_R0Hdr.7:ud		r0.6:ud						// Copy Parent Thread Cnt; JJ did the change on 06/20/2006
+mov (1) 	CT_R0Hdr.31:ub		0:w							// Reset the highest byte
+mov (1) 	CT_R0Hdr.3:ud 		0x00000000	 
+mov (1) 	CT_R0Hdr.6:uw 		sr0.0:uw					// sr0.0: state reg contains general thread states, e.g. EUID/TID.
+
+//***** Init ChildParam fields that are common to all threads ***********************
+mov (8) 	ChildParam<1>:ud	RootParam<8;8,1>:ud		// Copy all root parameters
+mov (4)		CurCol<1>:w			0:w						// Reset CurCol, CurRow, 
+add	(2)		LastCol<1>:w		MBsCntX<2;2,1>:w		-1:w	// Get LastCol and LastRow
+	
+mov (1) 	URBWriteMsgDesc:ud		MSG_LEN(2)+URBWMSGDSC:ud
+
+//===================================================================================
+
+#include "AVC_ILDB_OpenGateway.asm"		// Open gateway for receiving notification 
+
+#if defined(DEV_CL)	
+	mov	(1)		URBOffset:uw		240:uw	// Use chroma URB offset to spawn chroma root
+#else
+	mov	(1)		URBOffset:uw		320:uw	// Use chroma URB offset to spawn chroma root
+#endif
+
+#include "AVC_ILDB_SpawnChromaRoot.asm"	// Spawn chroma root
+
+mov	(1)		URBOffset:uw		0:uw	// Use luma URB offset to spawn luma child 
+mov	(1)		ChildThreadsID:uw	2:uw	// Starting ChildThreadsID for luma child threads
+
+#include "AVC_ILDB_Dep_Check.asm"  		// Check dependency and spawn all luma child threads in parallel with chroma root
+
+
+// Wait for UV root thread to finish
+ILDB_LABEL(WAIT_FOR_UV):
+cmp.l.f0.0 (1) null:w	ThreadLimit:w		MaxThreads:w
+(f0.0) 	jmpi 	ILDB_LABEL(WAIT_FOR_UV)
+
+
+#include "AVC_ILDB_CloseGateway.asm"	// Close root thread gateway 
+
+END_THREAD								// End of root thread
+
+#if !defined(COMBINED_KERNEL)		// For standalone kernel only
+.end_code
+
+.end_kernel
+#endif
diff --git a/i965_drv_video/shaders/h264/ildb/AVC_ILDB_Spawn.asm b/i965_drv_video/shaders/h264/ildb/AVC_ILDB_Spawn.asm
new file mode 100644
index 0000000..5b5c91e
--- /dev/null
+++ b/i965_drv_video/shaders/h264/ildb/AVC_ILDB_Spawn.asm
@@ -0,0 +1,22 @@
+/*
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+//=============== Spawn a child thread for a vertical child ===============
+
+#if defined(_DEBUG) 
+	mov	(1)		EntrySignature:w	0x6666:w
+#endif
+	
+	mul	(1)		URBOffset:uw		CurRow:uw		2:w // 5:w			// Each row uses 5 URB entries (R0, child R0, 3 GRFs of data from left MB)
+
+	mov (8)		CT_R0Hdr.0:ud		r0.0<8;8,1>:ud				// Init to root R0 header
+	
+	// R0.2: Interface Discriptor Ptr.  Add offset 16 for next Interface Discriptor for child kernel
+	add (1) 	CT_R0Hdr.2:ud 		r0.2:ud 		IDesc_Child_Offset:w
+	
+	#include "AVC_ILDB_SpawnChild.asm"
diff --git a/i965_drv_video/shaders/h264/ildb/AVC_ILDB_SpawnChild.asm b/i965_drv_video/shaders/h264/ildb/AVC_ILDB_SpawnChild.asm
new file mode 100644
index 0000000..0f6950c
--- /dev/null
+++ b/i965_drv_video/shaders/h264/ildb/AVC_ILDB_SpawnChild.asm
@@ -0,0 +1,55 @@
+/*
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+//=============== Spawn a child thread for Luma or Chroma ===============
+
+	//----- Create child thread R0 header -----
+#if defined(_DEBUG) 
+	mov		(1)		EntrySignature:w			0xAAAA:w
+#endif
+
+	//***** Set CT_R0Hdr fields that change for every thread 
+	
+	// Restore CT_R0Hdr.4:ud to r0.4:ud 
+	mov (1) CT_R0Hdr.4:ud		r0.4:ud
+
+	// R0.2: Interface Discriptor Ptr.  Add a child offset for child kernel
+//	add (1) CT_R0Hdr.2:ud 		r0.2:ud 		CHILD_OFFSET:w
+
+	// Assign a new Thread Count for this child
+	mov (1) CT_R0Hdr.6:ud 		ChildThreadsID:uw
+
+	//----- Prepare URB for launching a child thread -----
+	mov (16) m2.0:w		ChildParam<16;16,1>:w
+
+	shr (1)	 MRF0.0:uw	URBOffset:uw	1:w
+
+	add	(1)	ChildThreadsID:uw		ChildThreadsID:uw	2:uw	// Luma child=even, chroma child=odd
+		
+	//--------------------------------------------------
+//	#include "writeURB.asm"
+	send  null:uw 	MRF0	 null:ud	URBWRITE	URBWriteMsgDesc:ud		// URB write	
+
+	//--------------------------------------------------
+	// Set URB handle for child thread launching:
+	// URB handle Length	 	(bit 15:10) - 0000 0000 0000 0000  yyyy yy00 0000 0000
+	// URB handle offset  		(bit 9:0) 	- 0000 0000 0000 0000  0000 00xx xxxx xxxx
+
+	or  (1) CT_R0Hdr.4:ud		URB_EntriesPerMB_2:w	URBOffset:uw
+	
+	// 2 URB entries:
+	// Entry 0 - CT_R0Hdr
+	// Entry 1 - input parameter to child kernel
+
+	//----- Spawn a child now -----
+	send (8) null:ud 	CT_R0Hdr	  null:ud    TS	TSMSGDSC
+//	send (8) null:ud 	CT_Spawn_Reg	null:ud    0x07100001
+
+
+	// Restore CT_R0Hdr.4:ud to r0.4:ud for next use
+//	mov (1) CT_R0Hdr.4:ud		r0.4:ud
diff --git a/i965_drv_video/shaders/h264/ildb/AVC_ILDB_SpawnChromaRoot.asm b/i965_drv_video/shaders/h264/ildb/AVC_ILDB_SpawnChromaRoot.asm
new file mode 100644
index 0000000..cd5e57e
--- /dev/null
+++ b/i965_drv_video/shaders/h264/ildb/AVC_ILDB_SpawnChromaRoot.asm
@@ -0,0 +1,47 @@
+/*
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+//=============== Spawn a chroma root thread ===============
+
+	//----- Create chroma root thread R0 header -----
+#if defined(_DEBUG) 
+	mov		(1)		EntrySignature:w			0xAABA:w
+#endif
+
+
+
+	// Restore CT_R0Hdr.4:ud to r0.4:ud 
+//	mov (1) CT_R0Hdr.4:ud		r0.4:ud
+
+	// R0.2: Interface Discriptor Ptr.  Add child offset for child kernel
+	add (1) CT_R0Hdr.2:ud 		r0.2:ud 		CHROMA_ROOT_OFFSET:w
+
+	// Assign a new Thread Count for this child
+	mov (1) CT_R0Hdr.6:ud 		1:w		// ThreadID=1 for chroma root
+
+	//----- Copy luma root r1 for launching chroma root thread -----
+	mov (16) m2.0:w		RootParam<16;16,1>:w
+
+	#include "writeURB.asm"
+
+	//--------------------------------------------------
+	// Set URB handle for child thread launching:
+	// URB handle Length	 	(bit 15:10) - 0000 0000 0000 0000  yyyy yy00 0000 0000
+	// URB handle offset  		(bit 9:0) 	- 0000 0000 0000 0000  0000 00xx xxxx xxxx
+
+	or  (1) CT_R0Hdr.4:ud		URB_EntriesPerMB_2:w	URBOffset:uw
+	
+	// 2 URB entries:
+	// Entry 0 - CT_R0Hdr
+	// Entry 1 - input parameter to child kernel
+
+	//----- Spawn a child now -----
+	send (8) null:ud 	CT_R0Hdr	null:ud    TS	TSMSGDSC
+
+	// Restore CT_R0Hdr.4:ud to r0.4:ud for next use 
+	mov (1) CT_R0Hdr.4:ud		r0.4:ud
diff --git a/i965_drv_video/shaders/h264/ildb/Child_Undefs.inc b/i965_drv_video/shaders/h264/ildb/Child_Undefs.inc
new file mode 100644
index 0000000..fa3ade1
--- /dev/null
+++ b/i965_drv_video/shaders/h264/ildb/Child_Undefs.inc
@@ -0,0 +1,24 @@
+/*
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+// Modual name: Child_Undefs.inc
+//
+// Undefine global symbols for new process in child thread
+//
+
+#undef		P1	
+#undef		P2	
+#undef		P3	
+#undef		P4
+#undef		P5
+#undef		P6
+#undef		P7
+#undef		P8
+#undef		EDGECNTLMAP
+#undef		CLIP_NEGATIVE
+#undef		CLIP_DONE
diff --git a/i965_drv_video/shaders/h264/ildb/ILDB_header.inc b/i965_drv_video/shaders/h264/ildb/ILDB_header.inc
new file mode 100644
index 0000000..015bf28
--- /dev/null
+++ b/i965_drv_video/shaders/h264/ildb/ILDB_header.inc
@@ -0,0 +1,306 @@
+/*
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+#if !defined(__ILDB_HEADER__)	// Make sure this file is only included once
+#define __ILDB_HEADER__
+
+// Module name: ILDB_header.inc
+//
+
+.default_execution_size	(16)
+.default_register_type	:ub
+
+#undef NULLREG
+#undef RETURN_REG
+#undef EOTMSGDSC
+#undef MSGSRC
+#undef END_THREAD
+#undef TSMSGDSC
+
+//  ----------- Common constant definitions ------------
+//
+//  Bit position constants
+//
+#define BIT0	0x01
+#define BIT1	0x02
+#define BIT2	0x04
+#define BIT3	0x08
+#define BIT4	0x10
+#define BIT5	0x20
+#define BIT6	0x40
+#define BIT7	0x80
+#define BIT8	0x0100
+#define BIT9	0x0200
+#define BIT10	0x0400
+#define BIT11	0x0800
+#define BIT12	0x1000
+#define BIT13	0x2000
+#define BIT14	0x4000
+#define BIT15	0x8000
+#define BIT16	0x00010000
+#define BIT17	0x00020000
+#define BIT18	0x00040000
+#define BIT19	0x00080000
+#define BIT20	0x00100000
+#define BIT21	0x00200000
+#define BIT22	0x00400000
+#define BIT23	0x00800000
+#define BIT24	0x01000000
+#define BIT25	0x02000000
+#define BIT26	0x04000000
+#define BIT27	0x08000000
+#define BIT28	0x10000000
+#define BIT29	0x20000000
+#define BIT30	0x40000000
+#define BIT31	0x80000000
+
+// Common constants
+//
+#define	INST_SIZE	16	// Instruction size in byte
+
+#define	GRFWIB	32		// GRF register width in byte
+#define	GRFWIW	16		// GRF register width in word
+#define	GRFWID	8		// GRF register width in dword
+
+#define TOP_FIELD	0
+#define BOTTOM_FIELD	1
+
+#define PREVIOUS_FRAME	0	// Previous frame
+#define CURRENT_FRAME	1	// Current frame
+#define NEXT_FRAME	2	// Next frame
+
+#define Y_ROW_WIDTH		16	// in bytes
+#define UV_ROW_WIDTH	8
+
+//  Useful macros
+//
+#define REGION(Width,HStride) <Width*HStride;Width,HStride>	// Region definition when ExecSize = Width
+
+#define NULLREG		null<1>:d
+#define NULLREGW	null<1>:w
+
+#define RETURN_REG	r62		// Return pointer for all sub-routine calls (type DWORD)
+
+#define CALL(subFunc, skipInst)	add (1) RETURN_REG<1>:ud   ip:ud	1+skipInst*INST_SIZE \n\
+				jmpi (1) subFunc
+
+#define	RETURN		mov (1)	ip:ud	RETURN_REG<0;1,0>:ud		// Return to calling module
+
+#define PRED_CALL(flag, subFunc, skipInst)	add (1) RETURN_REG<1>:ud   ip:ud	1+skipInst*INST_SIZE \n\
+			(flag)	jmpi (1) subFunc
+
+
+//  Definitions for surface states, GRF regions, and common data fields
+//
+//  Note: Each kernel needs to define a specific symbol before including this
+//  header file to ensure correct definitions.
+//
+
+
+
+#if defined(AVC_ILDB)	
+
+.reg_count_total    64
+.reg_count_payload  4
+
+    // Binding Table Index
+	#define	BI_CNTRL_DATA		0			// Control data map  
+    #define	BI_SRC_Y			1
+    #define	BI_SRC_UV			2
+    #define	BI_DEST_Y			3
+    #define	BI_DEST_UV			4
+	
+
+	//========== Left MB, 4x16 in r2 and r3 ==========
+	#define		PREV_MB_Y_BASE	64		//2*GRFWIB												// Byte offset to r2
+	.declare    PREV_MB_YD  Base=r2 	ElementSize=4 SrcRegion=REGION(8,1) Type=ud
+	.declare    PREV_MB_YW  Base=r2 	ElementSize=2 SrcRegion=REGION(8,1) Type=uw
+    .declare    PREV_MB_YB  Base=r2 	ElementSize=1 SrcRegion=REGION(16,1) Type=ub
+    
+    #define		PREV_MB_U_BASE	64		//2*GRFWIB		// seperate thread from Y				// Byte offset to r2
+	.declare	PREV_MB_UD	Base=r2 	ElementSize=4 SrcRegion=REGION(8,1) Type=ud
+    .declare    PREV_MB_UW  Base=r2 	ElementSize=2 SrcRegion=REGION(16,1) Type=uw
+    .declare    PREV_MB_UB  Base=r2 	ElementSize=1 SrcRegion=REGION(16,1) Type=ub
+    
+	#define		PREV_MB_V_BASE	65		//2*GRFWIB+1		// NV12									// Byte offset to r2.1
+    .declare    PREV_MB_VB	Base=r2.1 	ElementSize=1 SrcRegion=REGION(16,1) Type=ub
+
+	//========== Top MB, 16x4 in r4 and r5 ==========	
+	#define		TOP_MB_Y_BASE	128		//4*GRFWIB												// Byte offset to r4
+	.declare    TOP_MB_YD	Base=r4		ElementSize=4 SrcRegion=REGION(8,1) Type=ud
+	.declare    TOP_MB_YW	Base=r4		ElementSize=2 SrcRegion=REGION(8,1) Type=uw
+    .declare    TOP_MB_YB	Base=r4		ElementSize=1 SrcRegion=REGION(16,1) Type=ub
+    
+    #define		TOP_MB_U_BASE	128		//4*GRFWIB		// seperate thread from Y				// Byte offset to r4
+	.declare	TOP_MB_UD	Base=r4 	ElementSize=4 SrcRegion=REGION(8,1) Type=ud
+    .declare    TOP_MB_UW	Base=r4		ElementSize=2 SrcRegion=REGION(16,1) Type=uw
+    .declare    TOP_MB_UB	Base=r4 	ElementSize=1 SrcRegion=REGION(16,1) Type=ub
+    
+	#define		TOP_MB_V_BASE	129		//4*GRFWIB+1		// NV12									// Byte offset to r4.1
+    .declare    TOP_MB_VB  Base=r4.1 	ElementSize=1 SrcRegion=REGION(16,1) Type=ub
+
+    
+    //========== Current MB, 16x16 in r6-r13 ==========
+	#define		SRC_MB_Y_BASE	192 	//6*GRFWIB												// Byte offset to r6
+    .declare    SRC_YD  	Base=r6 	ElementSize=4 SrcRegion=REGION(8,1) Type=ud		// For read and write, 8 GRFs
+    .declare    SRC_YW  	Base=r6 	ElementSize=2 SrcRegion=REGION(8,1) Type=uw
+    .declare    SRC_YB  	Base=r6 	ElementSize=1 SrcRegion=REGION(16,1) Type=ub	// 8 GRFs	
+
+	#define		SRC_MB_U_BASE	192		//6*GRFWIB		// seperate thread from Y				// Byte offset to r6
+    .declare    SRC_UD  	Base=r6 	ElementSize=4 SrcRegion=REGION(8,1) Type=ud		// For read and write, 2 GRFs
+    .declare    SRC_UW  	Base=r6 	ElementSize=2 SrcRegion=REGION(16,1) Type=uw	// For read and write, 4 GRFs
+    .declare    SRC_UB  	Base=r6 	ElementSize=1 SrcRegion=REGION(16,1) Type=ub	// 2 GRFs
+          
+	#define		SRC_MB_V_BASE	193		// 6*GRFWIB+1		// NV12									// Byte offset to r6.1
+    .declare    SRC_VD  	Base=r6.1 	ElementSize=4 SrcRegion=REGION(8,1) Type=ud		// For read and write, 2 GRFs
+    .declare    SRC_VW  	Base=r6.1 	ElementSize=2 SrcRegion=REGION(16,1) Type=uw	// For read and write, 4 GRFs
+    .declare    SRC_VB  	Base=r6.1 	ElementSize=1 SrcRegion=REGION(16,1) Type=ub	// 2 GRFs
+
+#else				// No kernel specified, define nothing.
+
+.reg_count_total    64
+.reg_count_payload  2
+
+	#define	SRCAOFF	r1.0:ud		// Offset into alpha data
+	#define	SRCOFF	r1.1:ud		// Offset into source YUV data
+	#define ORIX	r1.4		// :w, H. origin of the destination block in pel
+	#define ORIY	r1.5		// :w, V. origin of the destination block in pel
+
+#endif
+
+//  ----------- Message Payload Header fields------------
+//
+#define IDP		r0.2:ud		// Interface Descriptor Pointer
+#define	BTP		r0.4:ud		// Binding Table Pointer
+
+//  ----------- Common Message Descriptor ------------
+//
+#ifdef DEV_ILK
+#define GW_DCN				// Should be enabled only for ILK-B0 and beyond
+#define MSG_GW		0x03		// Message Gateway
+#define MSG_GW_EOT	0x23		// Message Gateway plus EOT bit set (For ILK only)
+#define DAPREAD		0x04		// Data Port Read Extended Message Descriptor,
+#define DAPWRITE	0x05		// Data Port Write Extended Message Descriptor,
+#define URBWRITE	0x06		// URB
+#define TS			0x07		// Thread Spawner Extended Message Descriptor
+#define TS_EOT		0x27		// End of Thread Extended Message Descriptor
+
+#define EOTMSGDSC	0x02000000	// End of Thread Message Descriptor /w URB handle dereferenced (used by root kernel)
+#define CHILD_EOTMSGDSC	0x02000012	// End of Child Thread Message Descriptor w/o URB handle dereferenced
+
+// Data Port Message Descriptor
+#define DWBRMSGDSC_RC	 0x02086000	// DWORD Block Read Message Descriptor, reading from render cache = 6.
+#define DWBRMSGDSC_RC_TF 0x02086600	// DWORD Block Read Message Descriptor, reading from render cache = 6.
+#define DWBRMSGDSC_RC_BF 0x02086700	// DWORD Block Read Message Descriptor, reading from render cache = 6.
+#define DWBRMSGDSC_SC	 0x0208A000	// DWORD Block Read Message Descriptor, reading from sampler cache = A.
+#define DWBRMSGDSC_SC_TF 0x0208E600	// DWORD Block Read Message Descriptor, reading top field from field mode sampler cache.
+#define DWBRMSGDSC_SC_BF 0x0208E700	// DWORD Block Read Message Descriptor, reading bottom field from field mode sampler cache.
+
+#define ILDBRMSGDSC		 0x02085800	// AVC ILDB Control Data Read Msg Desc on Bearlake-C
+
+#define DWBWMSGDSC		 0x02082000	// DWORD Block Write Message Descriptor
+#define DWBWMSGDSC_WC 	 0x0218A000	// DWORD Block Write Message Descriptor + write commit
+
+// URB Message Descriptor
+#define	URBWMSGDSC	0x02080000		// URB Write Message Descriptor
+
+// Thread Spawner Message Descriptor
+#define	TSMSGDSC	0x02000001
+
+// Message Gateway Message Descriptors
+#define OGWMSGDSC	0x02000000	// OpenGateway Message Descriptor
+#define CGWMSGDSC	0x02000001	// CloseGateway Message Descriptor
+#define FWDMSGDSC	0x02000002	// ForwardMsg Message Descriptor
+#define	NOTIFYMSG	0x00008000	// Send notification with ForwardMsg message
+
+#define	RESP_LEN(len)	0x100000*len
+#define MSG_LEN(len)	0x2000000*len
+
+#else	// Pre DEV_ILK
+
+#define MSG_GW
+#define MSG_GW_EOT
+#define DAPREAD
+#define DAPWRITE
+#define URBWRITE
+#define TS
+#define TS_EOT
+
+#define EOTMSGDSC	0x87100000		// End of Thread Message Descriptor /w URB handle dereferenced (used by root kernel) 
+#define CHILD_EOTMSGDSC	0x87100012	// End of Child Thread Message Descriptor w/o URB handle dereferenced
+
+// Data Port Message Descriptor
+#define DWBRMSGDSC_RC	 0x04106000	// DWORD Block Read Message Descriptor, reading from render cache = 6.
+#define DWBRMSGDSC_RC_TF 0x04106600	// DWORD Block Read Message Descriptor, reading from render cache = 6.
+#define DWBRMSGDSC_RC_BF 0x04106700	// DWORD Block Read Message Descriptor, reading from render cache = 6.
+#define DWBRMSGDSC_SC	 0x0410A000	// DWORD Block Read Message Descriptor, reading from sampler cache = A.
+#define DWBRMSGDSC_SC_TF 0x0410A600	// DWORD Block Read Message Descriptor, reading top field from field mode sampler cache.
+#define DWBRMSGDSC_SC_BF 0x0410A700	// DWORD Block Read Message Descriptor, reading bottom field from field mode sampler cache.
+
+#define ILDBRMSGDSC		 0x04105800	// AVC ILDB Control Data Read Msg Desc on Bearlake-C
+
+#define DWBWMSGDSC		 0x05102000	// DWORD Block Write Message Descriptor
+#define DWBWMSGDSC_WC 	 0x0511A000	// DWORD Block Write Message Descriptor + write commit
+
+// URB Message Descriptor
+#define	URBWMSGDSC	0x06100000		// URB Write Message Descriptor
+
+// Thread Spawner Message Descriptor
+#define	TSMSGDSC	0x07100001
+
+// Message Gateway Message Descriptors
+#define OGWMSGDSC	0x03100000	// OpenGateway Message Descriptor
+#define CGWMSGDSC	0x03100001	// CloseGateway Message Descriptor
+#define FWDMSGDSC	0x03100002	// ForwardMsg Message Descriptor
+#define	NOTIFYMSG	0x00008000	// Send notification with ForwardMsg message
+
+#define	RESP_LEN(len)	0x10000*len
+#define MSG_LEN(len)	0x100000*len
+
+//	bits 15 - 0 = 01 011 000 00000000 = 0101 1000 0000 0000 = 5800
+// Render cache, AVC loop rd, 				  			
+#endif	// DEV_ILK
+				
+//	Enable frame/field selection in message descriptor
+#define ENMSGDSCFM	0x400		// Enable MSGDSC to select frame surface
+#define ENMSGDSCTF	0x600		// Enable MSGDSC to select top field surface
+#define ENMSGDSCBF	0x700		// Enable MSGDSC to select bottom field surface
+
+#define END_THREAD      send (8) NULLREG MSGHDR r0:ud TS_EOT	EOTMSGDSC
+#define END_CHILD_THREAD	send (8) NULLREG MSGHDR r0:ud TS_EOT	CHILD_EOTMSGDSC
+
+//  ----------- Message related register ------------
+//
+#define MSGHDR		m1		// Message Payload Header
+#define MSGHDRY		m1		// Message Payload Header register for Y data
+#define MSGHDRU		m2		// Message Payload Header register for U data
+#define MSGHDRV		m3		// Message Payload Header register for V data
+
+#define MSGHDRC		m1		// Message Payload Header register for CUR MB
+#define MSGHDRL		m2		// Message Payload Header register for LEFT MB
+#define MSGHDRT		m3		// Message Payload Header register for TOP MB
+
+#define MSGHDRYA	m4		// Second Message Payload Header register for Y data
+#define MSGSRC		r63		// Message source register
+#define MSGDSC		a0.0:ud		// Message Descriptor register (type DWORD)
+
+#define MH_ORI		MSGSRC.0	// DWORD block R/W message header block offset
+#define MH_ORIX		MSGSRC.0	// DWORD block R/W message header X offset
+#define MH_ORIY		MSGSRC.1	// DWORD block R/W message header Y offset
+#define MH_SIZE		MSGSRC.2	// DWORD block R/W message header block width & height
+
+
+//  M2 - M9 for message data payload
+.declare    MSGPAYLOADB	Base=m2 ElementSize=1 SrcRegion=REGION(16,1) Type=ub
+.declare    MSGPAYLOADW	Base=m2 ElementSize=2 SrcRegion=REGION(16,1) Type=uw
+.declare    MSGPAYLOADD	Base=m2 ElementSize=4 SrcRegion=REGION(8,1) Type=ud
+.declare    MSGPAYLOADF	Base=m2 ElementSize=4 SrcRegion=REGION(8,1) Type=f
+
+// End of ILDB_header.inc
+
+#endif	// !defined(__ILDB_HEADER__)
diff --git a/i965_drv_video/shaders/h264/ildb/Load_ILDB_Cntrl_Data.asm b/i965_drv_video/shaders/h264/ildb/Load_ILDB_Cntrl_Data.asm
new file mode 100644
index 0000000..695ae4e
--- /dev/null
+++ b/i965_drv_video/shaders/h264/ildb/Load_ILDB_Cntrl_Data.asm
@@ -0,0 +1,80 @@
+/*
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+// Module name: load_ILDB_Cntrl_Data.asm
+//
+// This module loads AVC ILDB control data for one MB.  
+//
+//----------------------------------------------------------------
+//  Symbols need to be defined before including this module
+//
+//	Source region in :ud
+//	CNTRL_DATA_D:	CNTRL_DATA_D Base=rxx ElementSize=4 SrcRegion=REGION(8,1) Type=ud			// 8 GRFs
+//
+//	Binding table index: 
+//	BI_CNTRL_DATA:	Binding table index of control data surface
+//
+//----------------------------------------------------------------
+
+	// We need to get control data offset for the bottom MB in mbaff mode.
+	// That is, get f0.1=1 if MbaffFlag==1 && BotFieldFlag==1
+	and (1)	CTemp1_W:uw 		BitFields:uw  	MbaffFlag+BotFieldFlag:uw	// Mute all other bits
+
+	and.nz.f0.0	(1)	null:w		BitFields:w		CntlDataExpFlag:w			// Get CntlDataExpFlag
+
+	cmp.e.f0.1 (1) NULLREGW 	CTemp1_W:uw  	MbaffFlag+BotFieldFlag:uw	// Check mbaff and bot flags
+
+	(f0.0)  jmpi	ILDB_LABEL(READ_BLC_CNTL_DATA) 
+
+	// On Crestline, MB control data in memory occupy 64 DWs (expanded).  
+//    mov (1)	MSGSRC.0<1>:ud	0:w						{ NoDDClr }				// Block origin X
+//    mov (1)	MSGSRC.1<1>:ud	CntrlDataOffsetY:ud		{ NoDDClr, NoDDChk }	// Block origin Y
+//    mov (1)	MSGSRC.2<1>:ud	0x000F000F:ud			{ NoDDChk }				// Block width and height (16x16=256 bytes)
+
+    mov (2)	MSGSRC.0<1>:ud	ORIX_CUR<2;2,1>:uw			{ NoDDClr }				// Block origin X,Y
+    mov (1)	MSGSRC.2<1>:ud	0x000F000F:ud				{ NoDDChk }				// Block width and height (16x16=256 bytes)
+
+	(f0.1) add (1)  MSGSRC.1:ud		MSGSRC.1:ud		16:w	// +16 to for bottom MB in a pair
+
+    send (8) CNTRL_DATA_D(0)<1>	MSGHDRY	MSGSRC<8;8,1>:ud	DAPREAD	DWBRMSGDSC_SC+0x00080000+BI_CNTRL_DATA	// Receive 8 GRFs
+	jmpi	ILDB_LABEL(READ_CNTL_DATA_DONE)
+	
+	
+ILDB_LABEL(READ_BLC_CNTL_DATA):
+	// On Bearlake-C, MB control data in memory occupy 16 DWs. Data port returns 8 GRFs with expanded control data.
+
+	// Global offset
+	mov (1)	MSGSRC.2:ud		CntrlDataOffsetY:ud	// CntrlDataOffsetY is the global offset
+
+	(f0.1) add (1) MSGSRC.2:ud		MSGSRC.2:ud		64:w	// +64 to the next MB control data (bot MB)
+
+    send (8) CNTRL_DATA_D(0)<1>	MSGHDRY	MSGSRC<8;8,1>:ud	DAPREAD	RESP_LEN(8)+ILDBRMSGDSC+BI_CNTRL_DATA	// Receive 8 GRFs
+
+ILDB_LABEL(READ_CNTL_DATA_DONE):
+
+// End of load_ILDB_Cntrl_Data.asm
+
+
+
+
+// AVC ILDB control data message header format
+
+//DWord	Bit	Description
+//M0.7	31:0	Debug 
+//M0.6	31:0	Debug
+//M0.5	31:8	Ignored
+//		7:0		Dispatch ID. // This ID is assigned by the fixed function unit and is a unique identifier for the thread.  It is used to free up resources used by the thread upon thread completion.
+//M0.4	31:0	Ignored
+//M0.3	31:0	Ignored
+//M0.2	31:0	Global Offset. Specifies the global byte offset into the buffer.
+				//	This offset must be OWord aligned (bits 3:0 MBZ) Format = U32 Range = [0,FFFFFFF0h]
+//M0.1	31:0	Ignored
+//M0.0	31:0	Ignored
+
+
+
diff --git a/i965_drv_video/shaders/h264/ildb/Load_ILDB_Cntrl_Data_16DW.asm b/i965_drv_video/shaders/h264/ildb/Load_ILDB_Cntrl_Data_16DW.asm
new file mode 100644
index 0000000..4c91a29
--- /dev/null
+++ b/i965_drv_video/shaders/h264/ildb/Load_ILDB_Cntrl_Data_16DW.asm
@@ -0,0 +1,62 @@
+/*
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+// Module name: load_ILDB_Cntrl_Data_16DW.asm
+//
+// This module loads AVC ILDB 64DW control data for one MB CTG. 
+// Dataport expands from 16DW to 64DW.
+//
+//----------------------------------------------------------------
+//  Symbols need to be defined before including this module
+//
+//	Source region in :ud
+//	CNTRL_DATA_D:	CNTRL_DATA_D Base=rxx ElementSize=4 SrcRegion=REGION(8,1) Type=ud			// 8 GRFs
+//
+//	Binding table index: 
+//	BI_CNTRL_DATA:	Binding table index of control data surface
+//
+//----------------------------------------------------------------
+
+// On CTG, MB control data in memory occupy 16 DWs. Data port returns 8 GRFs with expanded control data.
+
+#if defined(_MBAFF) 
+	// We need to get control data offset for the bottom MB in mbaff mode.
+	// That is, get f0.1=1 if MbaffFlag==1 && BotFieldFlag==1
+//	and (1)	CTemp1_W:uw 		BitFields:uw  	MbaffFlag+BotFieldFlag:uw	// Mute all other bits
+//	cmp.e.f0.1 (1) NULLREGW 	CTemp1_W:uw  	MbaffFlag+BotFieldFlag:uw	// Check mbaff and bot flags
+		
+	and.ne.f0.1 (1)	NULLREGW 	BitFields:uw  	BotFieldFlag:uw
+
+	// Global offset
+	mov (1)	MSGSRC.2:ud		CntrlDataOffsetY:ud
+		
+	(f0.1) add (1) MSGSRC.2:ud		MSGSRC.2:ud		64:w	// +64 to the next MB control data (bot MB)
+#endif
+
+    send (8) CNTRL_DATA_D(0)<1>	MSGHDRY	MSGSRC<8;8,1>:ud	DAPREAD	RESP_LEN(8)+ILDBRMSGDSC+BI_CNTRL_DATA	// Receive 8 GRFs
+
+// End of load_ILDB_Cntrl_Data_16DW.asm
+
+
+
+// AVC ILDB control data message header format
+
+//DWord	Bit	Description
+//M0.7	31:0	Debug 
+//M0.6	31:0	Debug
+//M0.5	31:8	Ignored
+//		7:0		Dispatch ID. // This ID is assigned by the fixed function unit and is a unique identifier for the thread.  It is used to free up resources used by the thread upon thread completion.
+//M0.4	31:0	Ignored
+//M0.3	31:0	Ignored
+//M0.2	31:0	Global Offset. Specifies the global byte offset into the buffer.
+				//	This offset must be OWord aligned (bits 3:0 MBZ) Format = U32 Range = [0,FFFFFFF0h]
+//M0.1	31:0	Ignored
+//M0.0	31:0	Ignored
+
+
+
diff --git a/i965_drv_video/shaders/h264/ildb/Load_ILDB_Cntrl_Data_22DW.asm b/i965_drv_video/shaders/h264/ildb/Load_ILDB_Cntrl_Data_22DW.asm
new file mode 100644
index 0000000..19e9a20
--- /dev/null
+++ b/i965_drv_video/shaders/h264/ildb/Load_ILDB_Cntrl_Data_22DW.asm
@@ -0,0 +1,36 @@
+/*
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+// Module name: load_ILDB_Cntrl_Data_22DW.asm
+//
+// ********** Apple only module **********
+//
+// This module loads AVC ILDB 22DW control data for one MB for CLN.
+// The reduced control data set is for progressive picture ONLY.
+//
+// Control data memory layout for each MB is 8x11 = 88 bytes.  
+// It ocuppies 3 GRFs after reading in.
+//
+//----------------------------------------------------------------
+//  Symbols need to be defined before including this module
+//
+//	Source region in :ud
+//	CNTRL_DATA_D:	CNTRL_DATA_D Base=rxx ElementSize=4 SrcRegion=REGION(8,1) Type=ud			// 3 GRFs
+//
+//	Binding table index: 
+//	BI_CNTRL_DATA:	Binding table index of control data surface
+//
+//----------------------------------------------------------------
+
+    mul (1)	MSGSRC.0<1>:ud	ORIX:uw			8:uw		{ NoDDClr }				// Block origin X
+    mul (1)	MSGSRC.1<1>:ud	ORIY:uw			11:uw		{ NoDDClr, NoDDChk }	// Block origin Y
+    mov (1)	MSGSRC.2<1>:ud	0x000A0007:ud				{ NoDDChk }				// Block width and height (8x11=88 bytes)
+
+    send (8) CNTRL_DATA_D(0)<1>	MSGHDRY	MSGSRC<8;8,1>:ud	DAPREAD	RESP_LEN(3)+DWBRMSGDSC_SC+BI_CNTRL_DATA	// Receive 3 GRFs
+	
+// End of load_ILDB_Cntrl_Data_22DW.asm
diff --git a/i965_drv_video/shaders/h264/ildb/Load_ILDB_Cntrl_Data_64DW.asm b/i965_drv_video/shaders/h264/ildb/Load_ILDB_Cntrl_Data_64DW.asm
new file mode 100644
index 0000000..b026afb
--- /dev/null
+++ b/i965_drv_video/shaders/h264/ildb/Load_ILDB_Cntrl_Data_64DW.asm
@@ -0,0 +1,42 @@
+/*
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+// Module name: load_ILDB_Cntrl_Data_64DW.asm
+//
+// This module loads AVC ILDB 64DW control data for one MB for CLN.  
+//
+//----------------------------------------------------------------
+//  Symbols need to be defined before including this module
+//
+//	Source region in :ud
+//	CNTRL_DATA_D:	CNTRL_DATA_D Base=rxx ElementSize=4 SrcRegion=REGION(8,1) Type=ud			// 8 GRFs
+//
+//	Binding table index: 
+//	BI_CNTRL_DATA:	Binding table index of control data surface
+//
+//----------------------------------------------------------------
+
+// On CLN, MB control data in memory occupy 64 DWs.
+
+#if defined(_MBAFF) 
+	// We need to get control data offset for the bottom MB in mbaff mode.
+	// That is, set f0.1=1 if MbaffFlag==1 && BotFieldFlag==1
+	and (1)	acc0.0:uw 		BitFields:uw  	MbaffFlag+BotFieldFlag:uw	// Mute all other bits
+	cmp.e.f0.1 (1) NULLREGW 	acc0.0:uw  	MbaffFlag+BotFieldFlag:uw	// Check mbaff and bot flags
+#endif		// CTemp1_W
+
+    mov (2)	MSGSRC.0<1>:ud	ORIX_CUR<2;2,1>:uw			{ NoDDClr }				// Block origin X,Y
+    mov (1)	MSGSRC.2<1>:ud	0x000F000F:ud				{ NoDDChk }				// Block width and height (16x16=256 bytes)
+
+#if defined(_MBAFF) 
+	(f0.1) add (1) MSGSRC.1:ud	MSGSRC.1:ud		16:w	// +16 to the bottom MB control data (bot MB)
+#endif
+
+    send (8) CNTRL_DATA_D(0)<1>	MSGHDRY	MSGSRC<8;8,1>:ud	DAPREAD	RESP_LEN(8)+DWBRMSGDSC_SC+BI_CNTRL_DATA	// Receive 8 GRFs
+	
+// End of load_ILDB_Cntrl_Data_64DW.asm
diff --git a/i965_drv_video/shaders/h264/ildb/Root_Undefs.inc b/i965_drv_video/shaders/h264/ildb/Root_Undefs.inc
new file mode 100644
index 0000000..c0ee016
--- /dev/null
+++ b/i965_drv_video/shaders/h264/ildb/Root_Undefs.inc
@@ -0,0 +1,27 @@
+/*
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+// Modual name: Root_Undefs.inc
+//
+// Undefine global symbols for new process in root thread
+//
+
+#undef 		READ_BI
+#undef 		WRITE_BI
+
+#undef		ILDB_H_INDEPENDENT
+#undef		ILDB_H_INDEPENDENT_CONT
+#undef		ILDB_H_DEPENDENT
+#undef		ILDB_H_DEPENDENT_SCAN
+#undef		ILDB_H_NO_DEPENDENT
+
+#undef		ILDB_V_INDEPENDENT
+#undef		ILDB_V_INDEPENDENT_CONT
+#undef		ILDB_V_DEPENDENT
+#undef		ILDB_V_DEPENDENT_SCAN
+#undef		ILDB_V_NO_DEPENDENT
diff --git a/i965_drv_video/shaders/h264/ildb/SetupVPKernel.asm b/i965_drv_video/shaders/h264/ildb/SetupVPKernel.asm
new file mode 100644
index 0000000..c7d9634
--- /dev/null
+++ b/i965_drv_video/shaders/h264/ildb/SetupVPKernel.asm
@@ -0,0 +1,24 @@
+/*
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+// Modual name: SetupVPKernel.asm
+//
+// Initial setup for running video-processing kernels
+//
+
+#include "ILDB_header.inc"
+
+//
+//  Now, begin source code....
+//
+
+.code
+
+    mov (8)	MSGSRC.0<1>:ud	r0.0<8;8,1>:ud	// Initialize message payload header with R0
+
+// End of SetupVPKernel
diff --git a/i965_drv_video/shaders/h264/ildb/TransposeNV12_16x16.asm b/i965_drv_video/shaders/h264/ildb/TransposeNV12_16x16.asm
new file mode 100644
index 0000000..192a89f
--- /dev/null
+++ b/i965_drv_video/shaders/h264/ildb/TransposeNV12_16x16.asm
@@ -0,0 +1,135 @@
+/*
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+//////////////////////////////////////////////////////////////////////////////////////////
+//	Module name: TransposeNV12_16x16.asm
+//	
+//	Transpose a 16x16 NV12 MB.  The output is also in NV12
+//
+//----------------------------------------------------------------------------------------
+//  Symbols need to be defined before including this module
+//
+//	Source region is :ub
+//	SRC_YB:			SRC_YB Base=rxx ElementSize=1 SrcRegion=REGION(16,1) Type=ub	// 8 GRFs
+//	SRC_UW:			SRC_UW Base=rxx ElementSize=2 SrcRegion=REGION(8,1) Type=uw	// 4 GRFs
+//
+//  Temp buffer:
+//	BUF_B:			BUF_B Base=rxx ElementSize=1 SrcRegion=REGION(16,1) Type=ub		// 8 GRFs
+//	BUF_W:			BUF_W Base=rxx ElementSize=2 SrcRegion=REGION(8,1) Type=uw		// 4 GRFs
+//
+//////////////////////////////////////////////////////////////////////////////////////////
+
+#if defined(_DEBUG) 
+	mov		(1)		EntrySignatureC:w			0xDDDA:w
+#endif
+
+
+// Transpose Y (16x16 bytes)
+
+// The first step
+mov (16)	BUF_B(0,0)<1>		SRC_YB(0,0)<16;4,1>
+mov (16)	BUF_B(0,16)<1>		SRC_YB(2,0)<16;4,1>
+mov (16)	BUF_B(1,0)<1>		SRC_YB(4,0)<16;4,1>
+mov (16)	BUF_B(1,16)<1>		SRC_YB(6,0)<16;4,1>
+
+mov (16)	BUF_B(2,0)<1>		SRC_YB(0,4)<16;4,1>
+mov (16)	BUF_B(2,16)<1>		SRC_YB(2,4)<16;4,1>
+mov (16)	BUF_B(3,0)<1>		SRC_YB(4,4)<16;4,1>
+mov (16)	BUF_B(3,16)<1>		SRC_YB(6,4)<16;4,1>
+
+mov (16)	BUF_B(4,0)<1>		SRC_YB(0,8)<16;4,1>
+mov (16)	BUF_B(4,16)<1>		SRC_YB(2,8)<16;4,1>
+mov (16)	BUF_B(5,0)<1>		SRC_YB(4,8)<16;4,1>
+mov (16)	BUF_B(5,16)<1>		SRC_YB(6,8)<16;4,1>
+
+mov (16)	BUF_B(6,0)<1>		SRC_YB(0,12)<16;4,1>
+mov (16)	BUF_B(6,16)<1>		SRC_YB(2,12)<16;4,1>
+mov (16)	BUF_B(7,0)<1>		SRC_YB(4,12)<16;4,1>
+mov (16)	BUF_B(7,16)<1>		SRC_YB(6,12)<16;4,1>
+
+// The second step
+mov (16)	SRC_YB(0,0)<1>		BUF_B(0,0)<32;8,4>
+mov (16)	SRC_YB(0,16)<1>		BUF_B(0,1)<32;8,4>
+mov (16)	SRC_YB(1,0)<1>		BUF_B(0,2)<32;8,4>
+mov (16)	SRC_YB(1,16)<1>		BUF_B(0,3)<32;8,4>
+
+mov (16)	SRC_YB(2,0)<1>		BUF_B(2,0)<32;8,4>
+mov (16)	SRC_YB(2,16)<1>		BUF_B(2,1)<32;8,4>
+mov (16)	SRC_YB(3,0)<1>		BUF_B(2,2)<32;8,4>
+mov (16)	SRC_YB(3,16)<1>		BUF_B(2,3)<32;8,4>
+
+mov (16)	SRC_YB(4,0)<1>		BUF_B(4,0)<32;8,4>
+mov (16)	SRC_YB(4,16)<1>		BUF_B(4,1)<32;8,4>
+mov (16)	SRC_YB(5,0)<1>		BUF_B(4,2)<32;8,4>
+mov (16)	SRC_YB(5,16)<1>		BUF_B(4,3)<32;8,4>
+
+mov (16)	SRC_YB(6,0)<1>		BUF_B(6,0)<32;8,4>
+mov (16)	SRC_YB(6,16)<1>		BUF_B(6,1)<32;8,4>
+mov (16)	SRC_YB(7,0)<1>		BUF_B(6,2)<32;8,4>
+mov (16)	SRC_YB(7,16)<1>		BUF_B(6,3)<32;8,4>
+
+// Y is transposed.
+
+
+//////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+// Src U and V are mixed in NV12 format. U on even bytes, V on odd bytes.
+// Transpose by treating UV pair as a word.
+
+
+// Src U 8x8 and V 8x8 are mixed. (each pix is specified as yx)
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//	|17 17 16 16 15 15 14 14 13 13 12 12 11 11 10 10 07 07 06 06 05 05 04 04 03 03 02 02 01 01 00 00|
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//	|37 37 36 36 35 35 34 34 33 33 32 32 31 31 30 30 27 27 26 26 25 25 24 24 23 23 22 22 21 21 20 20|
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//	|57 57 56 56 55 55 54 54 53 53 52 52 51 51 50 50 47 47 46 46 45 45 44 44 43 43 42 42 41 41 40 40|
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//	|77 77 76 76 75 75 74 74 73 73 72 72 71 71 70 70 67 67 66 66 65 65 64 64 63 63 62 62 61 61 60 60|
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+
+//  First step 		(16)	<1>:w <==== <8;4,1>:w
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//	|33 33 32 32 31 31 30 30 23 23 22 22 21 21 20 20 13 13 12 12 11 11 10 10 03 03 02 02 01 01 00 00|
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//	|73 73 72 72 71 71 70 70 63 63 62 62 61 61 60 60 53 53 52 52 51 51 50 50 43 43 42 42 41 41 40 40|
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//	|37 37 36 36 35 35 34 34 27 27 26 26 25 25 24 24 17 17 16 16 15 15 14 14 07 07 06 06 05 05 04 04|
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//	|77 77 76 76 75 75 74 74 67 67 66 66 65 65 64 64 57 57 56 56 55 55 54 54 47 47 46 46 45 45 44 44|
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//
+// Transpose UV (8x8 words), The first step
+mov (16)	BUF_W(0,0)<1>		SRC_UW(0,0)<8;4,1>
+mov (16)	BUF_W(1,0)<1>		SRC_UW(2,0)<8;4,1>
+mov (16)	BUF_W(2,0)<1>		SRC_UW(0,4)<8;4,1>
+mov (16)	BUF_W(3,0)<1>		SRC_UW(2,4)<8;4,1>
+
+
+//	Second step		(16)	<1>:w <=== <16;4,4>:w
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//	|71 71 61 61 51 51 41 41 31 31 21 21 11 11 01 01 70 70 60 60 50 50 40 40 30 30 20 20 10 10 00 00|
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//	|73 73 63 63 53 53 43 43 33 33 23 23 13 13 03 03 72 72 62 62 52 52 42 42 32 32 22 22 12 12 02 02|
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//	|75 75 65 65 55 55 45 45 35 35 25 25 15 15 05 05 74 74 64 64 54 54 44 44 34 34 24 24 14 14 04 04|
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//	|77 77 67 67 57 57 47 47 37 37 27 27 17 17 07 07 76 76 66 66 56 56 46 46 36 36 26 26 16 16 06 06|
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//
+// Transpose UV (8x8 words), The second step
+mov (8)		SRC_UW(0,0)<1>		BUF_W(0,0)<16;4,4>
+mov (8)		SRC_UW(0,8)<1>		BUF_W(0,1)<16;4,4>
+mov (8)		SRC_UW(1,0)<1>		BUF_W(0,2)<16;4,4>
+mov (8)		SRC_UW(1,8)<1>		BUF_W(0,3)<16;4,4>
+mov (8)		SRC_UW(2,0)<1>		BUF_W(2,0)<16;4,4>
+mov (8)		SRC_UW(2,8)<1>		BUF_W(2,1)<16;4,4>
+mov (8)		SRC_UW(3,0)<1>		BUF_W(2,2)<16;4,4>
+mov (8)		SRC_UW(3,8)<1>		BUF_W(2,3)<16;4,4>
+
+// U and V are now transposed and separated.
diff --git a/i965_drv_video/shaders/h264/ildb/TransposeNV12_4x16.asm b/i965_drv_video/shaders/h264/ildb/TransposeNV12_4x16.asm
new file mode 100644
index 0000000..cb1dcbc
--- /dev/null
+++ b/i965_drv_video/shaders/h264/ildb/TransposeNV12_4x16.asm
@@ -0,0 +1,94 @@
+/*
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+//////////////////////////////////////////////////////////////////////////////////////////
+//	Module name: TransposeNV12_4x16.asm
+//	
+//	Transpose a 4x16 internal planar to 16x4 internal planar block
+//
+//----------------------------------------------------------------------------------------
+//  Symbols need to be defined before including this module
+//
+//	Source region is :ub
+//	SRC_YB:			SRC_YB Base=rxx ElementSize=1 SrcRegion=REGION(16,1) Type=ub	// 8 GRFs
+//	SRC_UW:			SRC_UB Base=rxx ElementSize=2 SrcRegion=REGION(8,1) Type=uw		// 4 GRFs
+//
+//  Temp buffer:
+//	BUF_B:			BUF_B Base=rxx ElementSize=1 SrcRegion=REGION(16,1) Type=ub		// 8 GRFs
+//	BUF_W:			BUF_W Base=rxx ElementSize=2 SrcRegion=REGION(8,1) Type=uw		// 4 GRFs
+//
+//////////////////////////////////////////////////////////////////////////////////////////
+
+#if defined(_DEBUG) 
+	mov		(1)		EntrySignatureC:w			0xDDDB:w
+#endif
+
+// Transpose Y (4x16) right most 4 columns
+
+// The first step
+mov (16)	BUF_B(0,0)<1>		SRC_YB(0,0)<16;4,1>		// Read 2 rows, write 1 row
+mov (16)	BUF_B(0,16)<1>		SRC_YB(2,0)<16;4,1>
+mov (16)	BUF_B(1,0)<1>		SRC_YB(4,0)<16;4,1>
+mov (16)	BUF_B(1,16)<1>		SRC_YB(6,0)<16;4,1>
+
+// The second step
+mov (16)	BUF_B(2,0)<1>		BUF_B(0,0)<32;8,4> 		// Read 2 rows, write 1 row
+mov (16)	BUF_B(2,16)<1>		BUF_B(0,1)<32;8,4>
+mov (16)	BUF_B(3,0)<1>		BUF_B(0,2)<32;8,4>
+mov (16)	BUF_B(3,16)<1>		BUF_B(0,3)<32;8,4>
+
+// Y is now transposed. the result is in BUF_B(2) and BUF_B(3).
+
+
+
+// Transpose UV (4x8),  right most 2 columns in word
+// Use BUF_W(0) as temp buf
+
+// Src U 8x8 and V 8x8 are mixed. (each pix is specified as yx)
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//	|17 17 16 16 15 15 14 14 13 13 12 12 11 11 10 10 07 07 06 06 05 05 04 04 03 03 02 02 01 01 00 00|
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//	|37 37 36 36 35 35 34 34 33 33 32 32 31 31 30 30 27 27 26 26 25 25 24 24 23 23 22 22 21 21 20 20|
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//	|57 57 56 56 55 55 54 54 53 53 52 52 51 51 50 50 47 47 46 46 45 45 44 44 43 43 42 42 41 41 40 40|
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//	|77 77 76 76 75 75 74 74 73 73 72 72 71 71 70 70 67 67 66 66 65 65 64 64 63 63 62 62 61 61 60 60|
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+
+//  First step 		(8)	<1>:w <==== <8;2,1>:w
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//	|71 71 70 70 61 61 60 60 51 51 50 50 41 41 40 40 31 31 30 30 21 21 20 20 11 11 10 10 01 01 00 00|
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+mov (8)		BUF_W(0,0)<1>		SRC_UW(0,0)<8;2,1>
+mov (8)		BUF_W(0,8)<1>		SRC_UW(2,0)<8;2,1>
+
+//	Second step		(16) <1>:w <==== <1;8,2>:w
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//	|71 71 61 61 51 51 41 41 31 31 21 21 11 11 01 01 70 70 60 60 50 50 40 40 30 30 20 20 10 10 00 00|
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+mov (16)	BUF_W(1,0)<1>		BUF_W(0,0)<1;8,2>
+
+// UV are now transposed.  the result is in BUF_W(1).
+
+
+
+//The first step
+//mov (16)	BUF_B(0,0)<1>		SRC_UW(0,0)<8;2,1>		// Read 2 rows, write 1 row
+// The second step
+//mov (8)		SRC_UB(4,0)<1>		BUF_B(0,0)<16;8,2> 		// Read 1 row, write 1 row
+//mov (8)		SRC_UB(4,8)<1>		BUF_B(0,1)<16;8,2> 		// Read 1 row, write 1 row
+
+// Transpose V (8x8),  right most 2 columns
+// The first step
+//mov (16)	BUF_B(0,0)<1>		SRC_VB(0,1)<8;2,1>		// Read 2 rows, write 1 row
+// The second step
+//mov (8)		SRC_UB(4,16)<1>		BUF_B(0,0)<16;8,2> 		// Read 1 row, write 1 row
+//mov (8)		SRC_UB(4,24)<1>		BUF_B(0,1)<16;8,2> 		// Read 1 row, write 1 row
+
+// U and V are now transposed.  the result is in BUF_B(4).
+
diff --git a/i965_drv_video/shaders/h264/ildb/Transpose_Cur_UV_2x8.asm b/i965_drv_video/shaders/h264/ildb/Transpose_Cur_UV_2x8.asm
new file mode 100644
index 0000000..967e587
--- /dev/null
+++ b/i965_drv_video/shaders/h264/ildb/Transpose_Cur_UV_2x8.asm
@@ -0,0 +1,56 @@
+/*
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+//////////////////////////////////////////////////////////////////////////////////////////
+//	Module name: Transpose_UV_2x8.asm
+//	
+//	Transpose UV 2x8 to 8x2 block (2x8U + 2x8V in NV12)
+//
+//----------------------------------------------------------------------------------------
+//  Symbols need to be defined before including this module
+//
+//	Source region is :ub
+//	SRC_UW:			SRC_UB Base=rxx ElementSize=2 SrcRegion=REGION(8,1) Type=uw		// 4 GRFs
+//
+//  Temp buffer:
+//	BUF_W:			BUF_W Base=rxx ElementSize=2 SrcRegion=REGION(8,1) Type=uw		// 4 GRFs
+//
+//////////////////////////////////////////////////////////////////////////////////////////
+
+#if defined(_DEBUG) 
+	mov		(1)		EntrySignatureC:w			0xDDDB:w
+#endif
+
+// Transpose UV (4x8),  right most 2 columns in word
+// Use BUF_W(0) as temp buf
+
+// Src U 8x8 and V 8x8 are mixed. (each pix is specified as yx)
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//	|17 17 16 16 15 15 14 14 13 13 12 12 11 11 10 10 07 07 06 06 05 05 04 04 03 03 02 02 01 01 00 00|
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//	|37 37 36 36 35 35 34 34 33 33 32 32 31 31 30 30 27 27 26 26 25 25 24 24 23 23 22 22 21 21 20 20|
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//	|57 57 56 56 55 55 54 54 53 53 52 52 51 51 50 50 47 47 46 46 45 45 44 44 43 43 42 42 41 41 40 40|
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//	|77 77 76 76 75 75 74 74 73 73 72 72 71 71 70 70 67 67 66 66 65 65 64 64 63 63 62 62 61 61 60 60|
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+
+//  First step 		(8)	<1>:w <==== <8;2,1>:w
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//	|77 77 76 76 67 67 66 66 57 57 56 56 47 47 46 46 37 37 36 36 27 27 26 26 17 17 16 16 07 07 06 06|
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+mov (8)		LEFT_TEMP_W(0,0)<1>		SRC_UW(0,6)<8;2,1>		{ NoDDClr }
+mov (8)		LEFT_TEMP_W(0,8)<1>		SRC_UW(2,6)<8;2,1>		{ NoDDChk }
+
+//	Second step		(16) <1>:w <==== <1;8,2>:w
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//	|77 77 67 67 57 57 47 47 37 37 27 27 17 17 07 07 76 76 66 66 56 56 46 46 36 36 26 26 16 16 06 06|
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+mov (16)	LEFT_TEMP_W(1,0)<1>		LEFT_TEMP_W(0,0)<1;8,2>
+
+// UV are now transposed.  the result is in BUF_W(1)
diff --git a/i965_drv_video/shaders/h264/ildb/Transpose_Cur_UV_8x8.asm b/i965_drv_video/shaders/h264/ildb/Transpose_Cur_UV_8x8.asm
new file mode 100644
index 0000000..dbb7e65
--- /dev/null
+++ b/i965_drv_video/shaders/h264/ildb/Transpose_Cur_UV_8x8.asm
@@ -0,0 +1,85 @@
+/*
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+//////////////////////////////////////////////////////////////////////////////////////////
+//	Module name: Transpose_UV_8x8.asm
+//	
+//	Transpose a 8x8 UV block. (8x8U + 8x8V)  The output is also in NV12
+//
+//----------------------------------------------------------------------------------------
+//  Symbols need to be defined before including this module
+//
+//	Source region is :ub
+//	SRC_UW:			SRC_UW Base=rxx ElementSize=2 SrcRegion=REGION(8,1) Type=uw	// 4 GRFs
+//
+//  Temp buffer:
+//	BUF_W:			BUF_W Base=rxx ElementSize=2 SrcRegion=REGION(8,1) Type=uw		// 4 GRFs
+//
+//////////////////////////////////////////////////////////////////////////////////////////
+
+#if defined(_DEBUG) 
+	mov		(1)		EntrySignatureC:w			0xDDDA:w
+#endif
+
+//////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+// Src U and V are mixed in NV12 format. U on even bytes, V on odd bytes.
+// Transpose by treating UV pair as a word.
+
+
+// Src U 8x8 and V 8x8 are mixed. (each pix is specified as yx)
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//	|17 17 16 16 15 15 14 14 13 13 12 12 11 11 10 10 07 07 06 06 05 05 04 04 03 03 02 02 01 01 00 00|
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//	|37 37 36 36 35 35 34 34 33 33 32 32 31 31 30 30 27 27 26 26 25 25 24 24 23 23 22 22 21 21 20 20|
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//	|57 57 56 56 55 55 54 54 53 53 52 52 51 51 50 50 47 47 46 46 45 45 44 44 43 43 42 42 41 41 40 40|
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//	|77 77 76 76 75 75 74 74 73 73 72 72 71 71 70 70 67 67 66 66 65 65 64 64 63 63 62 62 61 61 60 60|
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+
+//  First step 		(16)	<1>:w <==== <8;4,1>:w
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//	|33 33 32 32 31 31 30 30 23 23 22 22 21 21 20 20 13 13 12 12 11 11 10 10 03 03 02 02 01 01 00 00|
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//	|73 73 72 72 71 71 70 70 63 63 62 62 61 61 60 60 53 53 52 52 51 51 50 50 43 43 42 42 41 41 40 40|
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//	|37 37 36 36 35 35 34 34 27 27 26 26 25 25 24 24 17 17 16 16 15 15 14 14 07 07 06 06 05 05 04 04|
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//	|77 77 76 76 75 75 74 74 67 67 66 66 65 65 64 64 57 57 56 56 55 55 54 54 47 47 46 46 45 45 44 44|
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//
+// Transpose UV (8x8 words), The first step
+mov (16)	CUR_TEMP_W(0,0)<1>		SRC_UW(0,0)<8;4,1>
+mov (16)	CUR_TEMP_W(1,0)<1>		SRC_UW(2,0)<8;4,1>
+mov (16)	CUR_TEMP_W(2,0)<1>		SRC_UW(0,4)<8;4,1>
+mov (16)	CUR_TEMP_W(3,0)<1>		SRC_UW(2,4)<8;4,1>
+
+
+//	Second step		(16)	<1>:w <=== <16;4,4>:w
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//	|71 71 61 61 51 51 41 41 31 31 21 21 11 11 01 01 70 70 60 60 50 50 40 40 30 30 20 20 10 10 00 00|
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//	|73 73 63 63 53 53 43 43 33 33 23 23 13 13 03 03 72 72 62 62 52 52 42 42 32 32 22 22 12 12 02 02|
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//	|75 75 65 65 55 55 45 45 35 35 25 25 15 15 05 05 74 74 64 64 54 54 44 44 34 34 24 24 14 14 04 04|
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//	|77 77 67 67 57 57 47 47 37 37 27 27 17 17 07 07 76 76 66 66 56 56 46 46 36 36 26 26 16 16 06 06|
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//
+// Transpose UV (8x8 words), The second step
+mov (8)		SRC_UW(0,0)<1>		CUR_TEMP_W(0,0)<16;4,4>		{ NoDDClr }
+mov (8)		SRC_UW(0,8)<1>		CUR_TEMP_W(0,1)<16;4,4>		{ NoDDChk }
+mov (8)		SRC_UW(1,0)<1>		CUR_TEMP_W(0,2)<16;4,4>		{ NoDDClr }
+mov (8)		SRC_UW(1,8)<1>		CUR_TEMP_W(0,3)<16;4,4>		{ NoDDChk }
+mov (8)		SRC_UW(2,0)<1>		CUR_TEMP_W(2,0)<16;4,4>		{ NoDDClr }
+mov (8)		SRC_UW(2,8)<1>		CUR_TEMP_W(2,1)<16;4,4>		{ NoDDChk }
+mov (8)		SRC_UW(3,0)<1>		CUR_TEMP_W(2,2)<16;4,4>		{ NoDDClr }
+mov (8)		SRC_UW(3,8)<1>		CUR_TEMP_W(2,3)<16;4,4>		{ NoDDChk }
+
+// U and V are now transposed and separated.
diff --git a/i965_drv_video/shaders/h264/ildb/Transpose_Cur_UV_Right_Most_2x8.asm b/i965_drv_video/shaders/h264/ildb/Transpose_Cur_UV_Right_Most_2x8.asm
new file mode 100644
index 0000000..be7feba
--- /dev/null
+++ b/i965_drv_video/shaders/h264/ildb/Transpose_Cur_UV_Right_Most_2x8.asm
@@ -0,0 +1,25 @@
+/*
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+//	Transpose Cur MB Right Most 2x8 to 8x2
+//  Assume source is LEFT_TEMP_W(0), and detination is LEFT_TEMP_W(1)
+
+//	Input from dport for transpose:	
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//	|71 71 70 70 61 61 60 60 51 51 50 50 41 41 40 40 31 31 30 30 21 21 20 20 11 11 10 10 01 01 00 00|
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//
+//	Output of transpose:	<1>	<=== <16;8,2>:w
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//	|71 71 61 61 51 51 41 41 31 31 21 21 11 11 01 01 70 70 60 60 50 50 40 40 30 30 20 20 10 10 00 00|
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+
+//	mov (8)	LEFT_TEMP_W(1,0)<1>		LEFT_TEMP_W(0,0)<16;8,2>		{ NoDDClr }
+//	mov (8)	LEFT_TEMP_W(1,8)<1>		LEFT_TEMP_W(0,1)<16;8,2>		{ NoDDChk }
+
+	mov (16)	LEFT_TEMP_W(1,0)<1>		LEFT_TEMP_W(0,0)<1;8,2>
diff --git a/i965_drv_video/shaders/h264/ildb/Transpose_Cur_Y_16x16.asm b/i965_drv_video/shaders/h264/ildb/Transpose_Cur_Y_16x16.asm
new file mode 100644
index 0000000..8c20f74
--- /dev/null
+++ b/i965_drv_video/shaders/h264/ildb/Transpose_Cur_Y_16x16.asm
@@ -0,0 +1,74 @@
+/*
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+//////////////////////////////////////////////////////////////////////////////////////////
+//	Module name: Transpose_Y_16x16.asm
+//	
+//	Transpose Y 16x16 block.
+//
+//----------------------------------------------------------------------------------------
+//  Symbols need to be defined before including this module
+//
+//	Source region is :ub
+//	SRC_YB:			SRC_YB Base=rxx ElementSize=1 SrcRegion=REGION(16,1) Type=ub	// 8 GRFs
+//
+//  Temp buffer:
+//	CUR_TEMP_B:		BUF_B Base=rxx ElementSize=1 SrcRegion=REGION(16,1) Type=ub		// 8 GRFs
+//
+//////////////////////////////////////////////////////////////////////////////////////////
+
+#if defined(_DEBUG) 
+	mov		(1)		EntrySignatureC:w			0xDDDA:w
+#endif
+
+
+// Transpose Y (16x16 bytes)
+
+// The first step
+mov (16)	CUR_TEMP_B(0,0)<1>		SRC_YB(0,0)<16;4,1>		{ NoDDClr } 
+mov (16)	CUR_TEMP_B(0,16)<1>		SRC_YB(2,0)<16;4,1>		{ NoDDChk }
+mov (16)	CUR_TEMP_B(1,0)<1>		SRC_YB(4,0)<16;4,1>		{ NoDDClr }
+mov (16)	CUR_TEMP_B(1,16)<1>		SRC_YB(6,0)<16;4,1>		{ NoDDChk }
+
+mov (16)	CUR_TEMP_B(2,0)<1>		SRC_YB(0,4)<16;4,1>		{ NoDDClr }
+mov (16)	CUR_TEMP_B(2,16)<1>		SRC_YB(2,4)<16;4,1>		{ NoDDChk }
+mov (16)	CUR_TEMP_B(3,0)<1>		SRC_YB(4,4)<16;4,1>		{ NoDDClr }
+mov (16)	CUR_TEMP_B(3,16)<1>		SRC_YB(6,4)<16;4,1>		{ NoDDChk }
+
+mov (16)	CUR_TEMP_B(4,0)<1>		SRC_YB(0,8)<16;4,1>		{ NoDDClr }
+mov (16)	CUR_TEMP_B(4,16)<1>		SRC_YB(2,8)<16;4,1>		{ NoDDChk }
+mov (16)	CUR_TEMP_B(5,0)<1>		SRC_YB(4,8)<16;4,1>		{ NoDDClr }
+mov (16)	CUR_TEMP_B(5,16)<1>		SRC_YB(6,8)<16;4,1>		{ NoDDChk }
+
+mov (16)	CUR_TEMP_B(6,0)<1>		SRC_YB(0,12)<16;4,1>	{ NoDDClr }
+mov (16)	CUR_TEMP_B(6,16)<1>		SRC_YB(2,12)<16;4,1>	{ NoDDChk }
+mov (16)	CUR_TEMP_B(7,0)<1>		SRC_YB(4,12)<16;4,1>	{ NoDDClr }
+mov (16)	CUR_TEMP_B(7,16)<1>		SRC_YB(6,12)<16;4,1>	{ NoDDChk }
+
+// The second step
+mov (16)	SRC_YB(0,0)<1>		CUR_TEMP_B(0,0)<32;8,4>		{ NoDDClr }
+mov (16)	SRC_YB(0,16)<1>		CUR_TEMP_B(0,1)<32;8,4>		{ NoDDChk }
+mov (16)	SRC_YB(1,0)<1>		CUR_TEMP_B(0,2)<32;8,4>		{ NoDDClr }
+mov (16)	SRC_YB(1,16)<1>		CUR_TEMP_B(0,3)<32;8,4>		{ NoDDChk }
+
+mov (16)	SRC_YB(2,0)<1>		CUR_TEMP_B(2,0)<32;8,4>		{ NoDDClr }
+mov (16)	SRC_YB(2,16)<1>		CUR_TEMP_B(2,1)<32;8,4>		{ NoDDChk }
+mov (16)	SRC_YB(3,0)<1>		CUR_TEMP_B(2,2)<32;8,4>		{ NoDDClr }
+mov (16)	SRC_YB(3,16)<1>		CUR_TEMP_B(2,3)<32;8,4>		{ NoDDChk }
+
+mov (16)	SRC_YB(4,0)<1>		CUR_TEMP_B(4,0)<32;8,4>		{ NoDDClr }
+mov (16)	SRC_YB(4,16)<1>		CUR_TEMP_B(4,1)<32;8,4>		{ NoDDChk }
+mov (16)	SRC_YB(5,0)<1>		CUR_TEMP_B(4,2)<32;8,4>		{ NoDDClr }
+mov (16)	SRC_YB(5,16)<1>		CUR_TEMP_B(4,3)<32;8,4>		{ NoDDChk }
+
+mov (16)	SRC_YB(6,0)<1>		CUR_TEMP_B(6,0)<32;8,4>		{ NoDDClr }
+mov (16)	SRC_YB(6,16)<1>		CUR_TEMP_B(6,1)<32;8,4>		{ NoDDChk }
+mov (16)	SRC_YB(7,0)<1>		CUR_TEMP_B(6,2)<32;8,4>		{ NoDDClr }
+mov (16)	SRC_YB(7,16)<1>		CUR_TEMP_B(6,3)<32;8,4>		{ NoDDChk }
+
+// Y is transposed.
diff --git a/i965_drv_video/shaders/h264/ildb/Transpose_Cur_Y_4x16.asm b/i965_drv_video/shaders/h264/ildb/Transpose_Cur_Y_4x16.asm
new file mode 100644
index 0000000..70c0b1c
--- /dev/null
+++ b/i965_drv_video/shaders/h264/ildb/Transpose_Cur_Y_4x16.asm
@@ -0,0 +1,75 @@
+/*
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+//////////////////////////////////////////////////////////////////////////////////////////
+//	Module name: Transpose_Y_4x16.asm
+//	
+//	Transpose a 4x16 internal planar to 16x4 internal planar block.
+//	The src block is 16x16.  Right moft 4 columns are transposed.
+//
+//----------------------------------------------------------------------------------------
+//  Symbols need to be defined before including this module
+//
+//	Source region is :ub
+//	SRC_YB:			SRC_YB Base=rxx ElementSize=1 SrcRegion=REGION(16,1) Type=ub	// 8 GRFs
+//
+//  Temp buffer:
+//	BUF_B:			BUF_B Base=rxx ElementSize=1 SrcRegion=REGION(16,1) Type=ub		// 8 GRFs
+//
+//////////////////////////////////////////////////////////////////////////////////////////
+
+#if defined(_DEBUG) 
+	mov		(1)		EntrySignatureC:w			0xDDDB:w
+#endif
+
+// Transpose Y (4x16) right most 4 columns
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//	|1f 1e 1d 1c 1b 1a 19 18 17 16 15 14 13 12 11 10 0f 0e 0d 0c 0b 0a 09 08 07 06 05 04 03 02 01 00|
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//	|3f 3e 3d 3c 3b 3a 39 38 37 36 35 34 33 32 31 30 2f 2e 2d 2c 2b 2a 29 28 27 26 25 24 23 22 21 20|
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//	|5f 5e 5d 5c 5b 5a 59 58 57 56 55 54 53 52 51 50 4f 4e 4d 4c 4b 4a 49 48 47 46 45 44 43 42 41 40|
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//	|7f 7e 7d 7c 7b 7a 79 78 77 76 75 74 73 72 71 70 6f 6e 6d 6c 6b 6a 69 68 67 66 65 64 63 62 61 60|
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//	|9f 9e 9d 9c 9b 9a 99 98 97 96 95 94 93 92 91 90 8f 8e 8d 8c 8b 8a 89 88 87 86 85 84 83 82 81 80|
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//	|bf be bd bc bb ba b9 b8 b7 b6 b5 b4 b3 b2 b1 b0 af ae ad ac ab aa a9 a8 a7 a6 a5 a4 a3 a2 a1 a0|
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//	|df de dd dc db da d9 d8 d7 d6 d5 d4 d3 d2 d1 d0 cf ce cd cc cb ca c9 c8 c7 c6 c5 c4 c3 c2 c1 c0|
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//	|ff fe fd fc fb fa f9 f8 f7 f6 f5 f4 f3 f2 f1 f0 ef ee ed ec eb ea e9 e8 e7 e6 e5 e4 e3 e2 e1 e0|
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+
+// The first step
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//	|7f 7e 7d 7c 6f 6e 6d 6c 5f 5e 5d 5c 4f 4e 4d 4c 3f 3e 3d 3c 2f 2e 2d 2c 1f 1e 1d 1c 0f 0e 0d 0c|
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//	|ff fe fd fc ef ee ed ec df de dd dc cf ce cd cc bf be bd bc af ae ad ac 9f 9e 9d 9c 8f 8e 8d 8c|
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+
+// The second step
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//	|fd ed dd cd bd ad 9d 8d 7d 6d 5d 4d 3d 2d 1d 0d fc ec dc cc bc ac 9c 8c 7c 6c 5c 4c 3c 2c 1c 0c|
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//	|ff ef df cf bf af 9f 8f 7f 6f 5f 4f 3f 2f 1f 0f fe ee de ce be ae 9e 8e 7e 6e 5e 4e 3e 2e 1e 0e|
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+
+
+mov (16)	LEFT_TEMP_B(0,0)<1>		SRC_YB(0,12)<16;4,1>		{ NoDDClr }	
+mov (16)	LEFT_TEMP_B(0,16)<1>	SRC_YB(2,12)<16;4,1>		{ NoDDChk }
+mov (16)	LEFT_TEMP_B(1,0)<1>		SRC_YB(4,12)<16;4,1>		{ NoDDClr }
+mov (16)	LEFT_TEMP_B(1,16)<1>	SRC_YB(6,12)<16;4,1>		{ NoDDChk }
+
+// The second step
+mov (16)	LEFT_TEMP_B(2,0)<1>		LEFT_TEMP_B(0,0)<32;8,4> 		{ NoDDClr }	
+mov (16)	LEFT_TEMP_B(2,16)<1>	LEFT_TEMP_B(0,1)<32;8,4>		{ NoDDChk }
+mov (16)	LEFT_TEMP_B(3,0)<1>		LEFT_TEMP_B(0,2)<32;8,4>		{ NoDDClr }
+mov (16)	LEFT_TEMP_B(3,16)<1>	LEFT_TEMP_B(0,3)<32;8,4>		{ NoDDChk }
+
+// Y is now transposed. the result is in LEFT_TEMP_B(2) and LEFT_TEMP_B(3).
diff --git a/i965_drv_video/shaders/h264/ildb/Transpose_Cur_Y_Right_Most_4x16.asm b/i965_drv_video/shaders/h264/ildb/Transpose_Cur_Y_Right_Most_4x16.asm
new file mode 100644
index 0000000..c458f85
--- /dev/null
+++ b/i965_drv_video/shaders/h264/ildb/Transpose_Cur_Y_Right_Most_4x16.asm
@@ -0,0 +1,31 @@
+/*
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+//	Transpose cur Y right most 4x16 to 16x4
+//  Assume source is LEFT_TEMP_B(0), and detination is LEFT_TEMP_B(2)
+
+
+//	Input received from dport:
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//	|73 72 71 70 63 62 61 60 53 52 51 50 43 42 41 40 33 32 31 30 23 22 21 20 13 12 11 10 03 02 01 00|
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//	|f3 f2 f1 f0 e3 e2 e1 e0 d3 d2 d1 d0 c3 c2 c1 c0 b3 b2 b1 b0 a3 a2 a1 a0 93 92 91 90 83 82 81 80|
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+
+//	Output of transpose:		<1>	<= <32;8,4>
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//	|f1 e1 d1 c1 b1 a1 91 81 71 61 51 41 31 21 11 01 f0 e0 d0 c0 b0 a0 90 80 70 60 50 40 30 20 10 00|
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//	|f3 e3 d3 c3 b3 a3 93 83 73 63 53 43 33 23 13 03 f2 e2 d2 c2 b2 a2 92 82 72 62 52 42 32 22 12 02|
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+
+	// Transpose the data, also occupy 2 GRFs
+	mov (16)	LEFT_TEMP_B(2)<1>			LEFT_TEMP_B(0, 0)<32;8,4>		{ NoDDClr }
+	mov (16)	LEFT_TEMP_B(2, 16)<1>		LEFT_TEMP_B(0, 1)<32;8,4>		{ NoDDChk }
+	mov (16)	LEFT_TEMP_B(3)<1>			LEFT_TEMP_B(0, 2)<32;8,4>		{ NoDDClr }
+	mov (16)	LEFT_TEMP_B(3, 16)<1>		LEFT_TEMP_B(0, 3)<32;8,4>		{ NoDDChk }
diff --git a/i965_drv_video/shaders/h264/ildb/Transpose_Left_UV_2x8.asm b/i965_drv_video/shaders/h264/ildb/Transpose_Left_UV_2x8.asm
new file mode 100644
index 0000000..678456e
--- /dev/null
+++ b/i965_drv_video/shaders/h264/ildb/Transpose_Left_UV_2x8.asm
@@ -0,0 +1,28 @@
+/*
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+//	Transpose left MB 2x8 to 8x2
+//  Assume source is LEFT_TEMP_W, and detination is PREV_MB_UW
+
+//	Input from dport for transpose:	
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//	|71 71 70 70 61 61 60 60 51 51 50 50 41 41 40 40 31 31 30 30 21 21 20 20 11 11 10 10 01 01 00 00|
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//
+//	Output of transpose:	<1>	<=== <16;8,2>:w
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//	|71 71 61 61 51 51 41 41 31 31 21 21 11 11 01 01 70 70 60 60 50 50 40 40 30 30 20 20 10 10 00 00|
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+
+//	mov (8)	PREV_MB_UW(0,0)<1>		BUF_W(0,0)<16;8,2>		{ NoDDClr }
+//	mov (8)	PREV_MB_UW(0,8)<1>		BUF_W(0,1)<16;8,2>		{ NoDDChk }
+	
+//	mov (8)	PREV_MB_UW(0,0)<1>		LEFT_TEMP_W(0,0)<16;8,2>		{ NoDDClr }
+//	mov (8)	PREV_MB_UW(0,8)<1>		LEFT_TEMP_W(0,1)<16;8,2>		{ NoDDChk }
+
+	mov (16)	PREV_MB_UW(0,0)<1>		LEFT_TEMP_W(0,0)<1;8,2>
diff --git a/i965_drv_video/shaders/h264/ildb/Transpose_Left_Y_4x16.asm b/i965_drv_video/shaders/h264/ildb/Transpose_Left_Y_4x16.asm
new file mode 100644
index 0000000..435996c
--- /dev/null
+++ b/i965_drv_video/shaders/h264/ildb/Transpose_Left_Y_4x16.asm
@@ -0,0 +1,31 @@
+/*
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+//	Transpose left MB 4x16 to 16x4
+//  Assume source is LEFT_TEMP_B, and detination is PREV_MB_YB
+
+
+//	Input received from dport:
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//	|73 72 71 70 63 62 61 60 53 52 51 50 43 42 41 40 33 32 31 30 23 22 21 20 13 12 11 10 03 02 01 00|
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//	|f3 f2 f1 f0 e3 e2 e1 e0 d3 d2 d1 d0 c3 c2 c1 c0 b3 b2 b1 b0 a3 a2 a1 a0 93 92 91 90 83 82 81 80|
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+
+//	Output of transpose:		<1>	<= <32;8,4>
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//	|f1 e1 d1 c1 b1 a1 91 81 71 61 51 41 31 21 11 01 f0 e0 d0 c0 b0 a0 90 80 70 60 50 40 30 20 10 00|
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//	|f3 e3 d3 c3 b3 a3 93 83 73 63 53 43 33 23 13 03 f2 e2 d2 c2 b2 a2 92 82 72 62 52 42 32 22 12 02|
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+
+	// Transpose the data, also occupy 2 GRFs
+	mov (16)	PREV_MB_YB(0)<1>			LEFT_TEMP_B(0, 0)<32;8,4>		{ NoDDClr }
+	mov (16)	PREV_MB_YB(0, 16)<1>		LEFT_TEMP_B(0, 1)<32;8,4>		{ NoDDChk }
+	mov (16)	PREV_MB_YB(1)<1>			LEFT_TEMP_B(0, 2)<32;8,4>		{ NoDDClr }
+	mov (16)	PREV_MB_YB(1, 16)<1>		LEFT_TEMP_B(0, 3)<32;8,4>		{ NoDDChk }
diff --git a/i965_drv_video/shaders/h264/ildb/loadNV12_16x16T.asm b/i965_drv_video/shaders/h264/ildb/loadNV12_16x16T.asm
new file mode 100644
index 0000000..d5aa552
--- /dev/null
+++ b/i965_drv_video/shaders/h264/ildb/loadNV12_16x16T.asm
@@ -0,0 +1,53 @@
+/*
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+// Module name: loadNV12_16x16T.asm
+//
+// Load and transpose NV12 16x16 block 
+//
+//----------------------------------------------------------------
+//  Symbols need to be defined before including this module
+//
+//	Source region in :ud
+//	SRC_YD:			SRC_YD Base=rxx ElementSize=4 SrcRegion=REGION(8,1) Type=ud			// 8 GRFs
+//	SRC_UD:			SRC_UD Base=rxx ElementSize=4 SrcRegion=REGION(8,1) Type=ud   (U+V for NV12) 	// 4 GRFs
+//
+//	Source region is :ub.  The same region as :ud region
+//	SRC_YB:			SRC_YB Base=rxx ElementSize=1 SrcRegion=REGION(16,1) Type=ub		// 8 GRFs
+//	SRC_UB:			SRC_UB Base=rxx ElementSize=1 SrcRegion=REGION(16,1) Type=ub		// 2 GRFs
+//	SRC_VB:			SRC_VB Base=rxx ElementSize=1 SrcRegion=REGION(16,1) Type=ub		// 2 GRFs
+//
+//	Binding table index: 
+//	BI_SRC_Y:		Binding table index of Y surface
+//	BI_SRC_UV:		Binding table index of UV surface (NV12)
+//
+//	Temp buffer:
+//	BUF_B:			BUF_B Base=rxx ElementSize=1 SrcRegion=REGION(16,1) Type=ub
+//
+//----------------------------------------------------------------
+
+#if defined(_DEBUG) 
+	mov		(1)		EntrySignatureC:w			0xDDD1:w
+#endif
+
+	// Read Y
+    mov (2)	MSGSRC.0<1>:ud	ORIX_CUR<2;2,1>:w		// Block origin
+    mov (1)	MSGSRC.2<1>:ud	0x000F000F:ud		// Block width and height (16x16)
+    send (8) SRC_YD(0)<1>	MSGHDRY	MSGSRC<8;8,1>:ud	DAPREAD	RESP_LEN(8)+DWBRMSGDSC_RC+BI_SRC_Y	// Read 8 GRFs
+
+	// Read U+V
+    asr (1)	MSGSRC.1:ud		MSGSRC.1:ud			1:w						// NV12 U+V block origin y = half of Y comp
+    mov (1)	MSGSRC.2<1>:ud	0x0007000F:ud		// NV12 U+V block width and height (16x8)
+    send (8) SRC_UD(0)<1>	MSGHDRU	MSGSRC<8;8,1>:ud	DAPREAD	RESP_LEN(4)+DWBRMSGDSC_RC+BI_SRC_UV	// Read 4 GRFs
+
+	#include "TransposeNV12_16x16.asm"
+
+//	#include "Transpose_Y_16x16.asm"	
+//	#include "Transpose_NV12_UV_16x8.asm"	
+		
+// End of loadNV12_16x16T
diff --git a/i965_drv_video/shaders/h264/ildb/loadNV12_16x4.asm b/i965_drv_video/shaders/h264/ildb/loadNV12_16x4.asm
new file mode 100644
index 0000000..a2e7dfd
--- /dev/null
+++ b/i965_drv_video/shaders/h264/ildb/loadNV12_16x4.asm
@@ -0,0 +1,54 @@
+/*
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+// Module Name: Loadnv12_16X4.Asm
+//
+// Load Nv12 16X4 Block 
+//
+//----------------------------------------------------------------
+//  Symbols Need To Be Defined Before Including This Module
+//
+//	Source Region In :Ud
+//	Src_Yd:			Src_Yd Base=Rxx Elementsize=4 Srcregion=Region(8,1) Type=Ud			// 3 Grfs (2 For Y, 1 For U+V)
+//
+//	Source Region Is :Ub.  The Same Region As :Ud Region
+//	Src_Yb:			Src_Yb Base=Rxx Elementsize=1 Srcregion=Region(16,1) Type=Ub		// 2 Grfs
+//	Src_Ub:			Src_Ub Base=Rxx Elementsize=1 Srcregion=Region(16,1) Type=Ub		// 0.5 Grf
+//	Src_Vb:			Src_Vb Base=Rxx Elementsize=1 Srcregion=Region(16,1) Type=Ub		// 0.5 Grf
+//
+//	Binding Table Index: 
+//	Bi_Src_Y:		Binding Table Index Of Y Surface
+//	Bi_Src_UV:		Binding Table Index Of UV Surface (Nv12)
+//
+//	Temp Buffer:
+//	Buf_D:			Buf_D Base=Rxx Elementsize=4 Srcregion=Region(8,1) Type=Ud
+//	Buf_B:			Buf_B Base=Rxx Elementsize=1 Srcregion=Region(16,1) Type=Ub
+//
+//----------------------------------------------------------------
+
+#if defined(_DEBUG) 
+	mov		(1)		EntrySignatureC:w			0xDDD2:w
+#endif
+
+	// Read Y
+    mov (2)	MSGSRC.0<1>:ud	ORIX<2;2,1>:w		// Block origin
+    mov (1)	MSGSRC.2<1>:ud	0x0003000F:ud		// Block width and height (16x4)
+    send (8) PREV_MB_YD(0)<1>	MSGHDRY	MSGSRC<8;8,1>:ud	DAPREAD	RESP_LEN(2)+DWBRMSGDSC_RC+BI_SRC_Y	// Read 2 GRFs
+
+	// Read U+V
+    asr (1)	MSGSRC.1:ud		MSGSRC.1:ud			1:w						// NV12 U+V block origin y = half of Y comp
+    mov (1)	MSGSRC.2<1>:ud	0x0001000F:ud		// NV12 U+V block width and height (16x2)
+
+	// Load NV12 U+V tp a temp buf  
+	send (8) BUF_D(0)<1>	MSGHDRU	MSGSRC<8;8,1>:ud	DAPREAD	RESP_LEN(1)+DWBRMSGDSC_RC+BI_SRC_UV	// Read 1 GRF
+
+	// Convert NV12 U+V to internal planar U and V and place them right after Y.
+//	mov (16)	SRC_UB(0,0)<1>		BUF_B(0,0)<32;16,2>
+//	mov (16)	SRC_VB(0,0)<1>		BUF_B(0,1)<32;16,2>	
+	
+// End of loadNV12_16x4.asm
diff --git a/i965_drv_video/shaders/h264/ildb/load_Cur_UV_8x8T.asm b/i965_drv_video/shaders/h264/ildb/load_Cur_UV_8x8T.asm
new file mode 100644
index 0000000..25cb96c
--- /dev/null
+++ b/i965_drv_video/shaders/h264/ildb/load_Cur_UV_8x8T.asm
@@ -0,0 +1,65 @@
+/*
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+// Module name: load_Cur_UV_8x8T.asm
+//
+// Load and transpose UV 8x8 block (NV12: 8x8U and 8x8V mixed)
+//
+//----------------------------------------------------------------
+//  Symbols need to be defined before including this module
+//
+//	Source region in :ud
+//	SRC_UD:			SRC_UD Base=rxx ElementSize=4 SrcRegion=REGION(8,1) Type=ud   (U+V for NV12) 	// 4 GRFs
+//
+//	Binding table index: 
+//	BI_SRC_UV:		Binding table index of UV surface (NV12)
+//
+//----------------------------------------------------------------
+
+#if defined(_DEBUG) 
+	mov		(1)		EntrySignatureC:w			0xDDD1:w
+#endif
+
+	// Read U+V blk
+#if defined(_PROGRESSIVE) 
+    mov (1)	MSGSRC.0:ud		ORIX_CUR:w				{ NoDDClr } 		// Block origin
+    asr (1)	MSGSRC.1:ud		ORIY_CUR:w		1:w		{ NoDDClr, NoDDChk }	// NV12 U+V block origin y = half of Y comp
+    mov (1)	MSGSRC.2:ud		0x0007000F:ud			{ NoDDChk }			// NV12 U+V block width and height (16x8 bytes)
+
+    //send (8) SRC_UD(0)<1>	MSGHDRU		MSGSRC<8;8,1>:ud	DWBRMSGDSC_SC+0x00040000+BI_SRC_UV
+    mov (1)	MSGDSC	RESP_LEN(4)+DWBRMSGDSC_SC+BI_SRC_UV:ud	
+#endif
+
+#if defined(_FIELD)
+//    cmp.z.f0.0 (1)  NULLREGW 	PicTypeC:w  	0:w						// Get pic type flag
+    and.nz.f0.1 (1) NULLREGW 	BitFields:w  	BotFieldFlag:w			// Get bottom field flag
+	// they are used later in this file
+
+    mov (1)	MSGSRC.0:ud		ORIX_CUR:w				{ NoDDClr } 		// Block origin
+    asr (1)	MSGSRC.1:ud		ORIY_CUR:w		1:w		{ NoDDClr, NoDDChk }	// NV12 U+V block origin y = half of Y comp
+    mov (1)	MSGSRC.2:ud		0x0007000F:ud			{ NoDDChk }			// NV12 U+V block width and height (16x8 bytes)
+
+    // Set message descriptor
+
+    // Frame picture
+//    (f0.0) mov (1)	MSGDSC	RESP_LEN(4)+DWBRMSGDSC_SC+BI_SRC_UV:ud			// Read 4 GRFs from SRC_UV
+//	(f0.0) jmpi		load_UV_8x8T
+
+	// Field picture
+    (f0.1) mov (1)	MSGDSC	RESP_LEN(4)+DWBRMSGDSC_SC_BF+BI_SRC_UV:ud  // Read 4 GRFs from SRC_UV bottom field
+    (-f0.1) mov (1)	MSGDSC	RESP_LEN(4)+DWBRMSGDSC_SC_TF+BI_SRC_UV:ud  // Read 4 GRFs from SRC_UV top field
+
+//load_UV_8x8T:
+
+#endif
+
+    send (8) SRC_UD(0)<1>	MSGHDRU		MSGSRC<8;8,1>:ud	DAPREAD	MSGDSC
+
+//	#include "Transpose_Cur_UV_8x8.asm"
+
+// End of load_UV_8x8T
diff --git a/i965_drv_video/shaders/h264/ildb/load_Cur_UV_8x8T_Mbaff.asm b/i965_drv_video/shaders/h264/ildb/load_Cur_UV_8x8T_Mbaff.asm
new file mode 100644
index 0000000..82b7d9e
--- /dev/null
+++ b/i965_drv_video/shaders/h264/ildb/load_Cur_UV_8x8T_Mbaff.asm
@@ -0,0 +1,62 @@
+/*
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+// Module name: load_Cur_UV_8x8T.asm
+//
+// Load and transpose UV 8x8 block (NV12: 8x8U and 8x8V mixed)
+//
+//----------------------------------------------------------------
+//  Symbols need to be defined before including this module
+//
+//	Source region in :ud
+//	SRC_UD:			SRC_UD Base=rxx ElementSize=4 SrcRegion=REGION(8,1) Type=ud   (U+V for NV12) 	// 4 GRFs
+//
+//	Binding table index: 
+//	BI_SRC_UV:		Binding table index of UV surface (NV12)
+//
+//----------------------------------------------------------------
+
+#if defined(_DEBUG) 
+	mov		(1)		EntrySignatureC:w			0xDDD1:w
+#endif
+    // FieldModeCurrentMbFlag determines how to access left MB
+	and.z.f0.0 (1) 	null:w		r[ECM_AddrReg, BitFlags]:ub		FieldModeCurrentMbFlag:w		
+
+    and.nz.f0.1 (1)	NULLREGW 	BitFields:w  	BotFieldFlag:w					// Get bottom field flag
+
+	// Read U+V
+    mov (1)	MSGSRC.0:ud		ORIX_CUR:w						{ NoDDClr } 		// Block origin
+    asr (1)	MSGSRC.1:ud		ORIY_CUR:w			1:w			{ NoDDClr, NoDDChk }	// NV12 U+V block origin y = half of Y comp
+    mov (1)	MSGSRC.2:ud		0x0007000F:ud					{ NoDDChk }			// NV12 U+V block width and height (16x8 bytes)
+
+    // Set message descriptor
+
+	(f0.0)	if	(1)		ILDB_LABEL(ELSE_UV_8X8T)
+
+    // Frame picture
+    mov (1)	MSGDSC	RESP_LEN(4)+DWBRMSGDSC_SC+BI_SRC_UV:ud			// Read 4 GRFs from SRC_UV
+
+	(f0.1) add (1)	MSGSRC.1:d	MSGSRC.1:d		8:w		// Add vertical offset 8 for bot MB in MBAFF mode
+    
+ILDB_LABEL(ELSE_UV_8X8T): 
+	else 	(1)		ILDB_LABEL(ENDIF_UV_8X8T)
+
+	// Field picture
+    (f0.1) mov (1)	MSGDSC	RESP_LEN(4)+DWBRMSGDSC_SC_BF+BI_SRC_UV:ud  // Read 4 GRFs from SRC_UV bottom field
+    (-f0.1) mov (1)	MSGDSC	RESP_LEN(4)+DWBRMSGDSC_SC_TF+BI_SRC_UV:ud  // Read 4 GRFs from SRC_UV top field
+
+	asr (1)	MSGSRC.1:d		MSGSRC.1:d		1:w					// Reduce y by half in field access mode
+
+	endif
+ILDB_LABEL(ENDIF_UV_8X8T):
+
+    send (8) SRC_UD(0)<1>	MSGHDRU	MSGSRC<8;8,1>:ud	DAPREAD	MSGDSC
+
+//	#include "Transpose_Cur_UV_8x8.asm"
+
+// End of load_UV_8x8T
diff --git a/i965_drv_video/shaders/h264/ildb/load_Cur_UV_Right_Most_2x8.asm b/i965_drv_video/shaders/h264/ildb/load_Cur_UV_Right_Most_2x8.asm
new file mode 100644
index 0000000..426a518
--- /dev/null
+++ b/i965_drv_video/shaders/h264/ildb/load_Cur_UV_Right_Most_2x8.asm
@@ -0,0 +1,61 @@
+/*
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+// Module Name: Load_Cur_UV_Right_Most_2X8.Asm
+
+#if defined(_DEBUG) 
+	mov		(1)		EntrySignatureC:w			0xDDD0:w
+#endif
+
+#if defined(_PROGRESSIVE) 
+	// Read U+V, (UV MB size = 16x8)
+    add (1)	MSGSRC.0:ud		ORIX_CUR:w			12:w			{ NoDDClr }		// Block origin
+    asr (1)	MSGSRC.1:ud		ORIY_CUR:w			1:w				{ NoDDClr, NoDDChk }		// NV12 U+V block origin y = half of Y comp
+    mov (1)	MSGSRC.2:ud		0x00070003:ud						{ NoDDChk }		// NV12 U+V block width and height (4x8)
+	send (8) LEFT_TEMP_D(0)<1>	MSGHDRU	MSGSRC<8;8,1>:ud	DAPREAD	RESP_LEN(1)+DWBRMSGDSC_RC+BI_DEST_UV	
+#endif
+
+#if defined(_FIELD) || defined(_MBAFF)
+
+    // FieldModeCurrentMbFlag determines how to access left MB
+	and.z.f0.0 (1) 	null:w		r[ECM_AddrReg, BitFlags]:ub		FieldModeCurrentMbFlag:w		
+
+    and.nz.f0.1 (1)	NULLREGW 		BitFields:w  	BotFieldFlag:w				// Get bottom field flag
+
+	// Read U+V
+    add (1)	MSGSRC.0:ud		ORIX_CUR:w			12:w				{ NoDDClr }		// Block origin
+    asr (1)	MSGSRC.1:ud		ORIY_CUR:w			1:w				{ NoDDClr, NoDDChk }		// NV12 U+V block origin y = half of Y comp
+    mov (1)	MSGSRC.2:ud		0x00070003:ud						{ NoDDChk }		// NV12 U+V block width and height (4x8)
+
+	// Load NV12 U+V 
+	
+    // Set message descriptor
+
+	(f0.0)	if	(1)		ILDB_LABEL(ELSE_Y_2x8T)
+
+    // Frame picture
+    mov (1)	MSGDSC	RESP_LEN(1)+DWBRMSGDSC_RC+BI_DEST_UV:ud			// Read 1 GRF from SRC_UV
+
+	(f0.1) add (1)	MSGSRC.1:d		MSGSRC.1:d		8:w		// Add vertical offset 8 for bot MB in MBAFF mode
+
+ILDB_LABEL(ELSE_Y_2x8T): 
+	else 	(1)		ILDB_LABEL(ENDIF_Y_2x8T)
+
+	// Field picture
+    (f0.1) mov (1)	MSGDSC	RESP_LEN(1)+DWBRMSGDSC_RC_BF+BI_DEST_UV:ud  // Read 1 GRF from SRC_Y bottom field
+    (-f0.1) mov (1)	MSGDSC	RESP_LEN(1)+DWBRMSGDSC_RC_TF+BI_DEST_UV:ud  // Read 1 GRF from SRC_Y top field
+
+	endif
+ILDB_LABEL(ENDIF_Y_2x8T):
+
+	// Read 1 GRF from DEST surface as the above MB has been deblocked.
+//	send (8) BUF_D(0)<1>	MSGHDRU	MSGSRC<8;8,1>:ud	MSGDSC	
+	send (8) LEFT_TEMP_D(0)<1>	MSGHDRU	MSGSRC<8;8,1>:ud	DAPREAD	MSGDSC	
+
+#endif
+
diff --git a/i965_drv_video/shaders/h264/ildb/load_Cur_Y_16x16T.asm b/i965_drv_video/shaders/h264/ildb/load_Cur_Y_16x16T.asm
new file mode 100644
index 0000000..d70b101
--- /dev/null
+++ b/i965_drv_video/shaders/h264/ildb/load_Cur_Y_16x16T.asm
@@ -0,0 +1,63 @@
+/*
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+// Module name: load_Y_16x16T.asm
+//
+// Load and transpose Y 16x16 block 
+//
+//----------------------------------------------------------------
+//  Symbols need to be defined before including this module
+//
+//	Source region in :ud
+//	SRC_YD:			SRC_YD Base=rxx ElementSize=4 SrcRegion=REGION(8,1) Type=ud			// 8 GRFs
+//
+//	Binding table index: 
+//	BI_SRC_Y:		Binding table index of Y surface
+//
+//----------------------------------------------------------------
+
+#if defined(_DEBUG) 
+	mov		(1)		EntrySignatureC:w			0xDDD1:w
+#endif
+	// Read Y
+	
+#if defined(_PROGRESSIVE) 
+    mov (2)	MSGSRC.0<1>:ud	ORIX_CUR<2;2,1>:w		{ NoDDClr }			// Block origin
+	mov (1)	MSGSRC.2<1>:ud	0x000F000F:ud			{ NoDDChk }			// Block width and height (16x16)
+
+    //send (8) SRC_YD(0)<1>	MSGHDRC		MSGSRC<8;8,1>:ud	DWBRMSGDSC_SMPLR+0x00080000+BI_SRC_Y
+	mov (1)	MSGDSC	RESP_LEN(8)+DWBRMSGDSC_SC+BI_SRC_Y:ud    	
+#endif
+
+    
+#if defined(_FIELD)
+//    cmp.z.f0.0 (1)  NULLREGW 	PicTypeC:w  	0:w						// Get pic type flag
+    and.nz.f0.1 (1) NULLREGW 	BitFields:w  	BotFieldFlag:w			// Get bottom field flag
+	// they are used later in this file
+
+    mov (2)	MSGSRC.0<1>:ud	ORIX_CUR<2;2,1>:w		{ NoDDClr }			// Block origin
+    mov (1)	MSGSRC.2<1>:ud	0x000F000F:ud			{ NoDDChk }			// Block width and height (16x16)
+    
+    // Set message descriptor
+    // Frame picture
+//	(f0.0) mov (1)	MSGDSC	RESP_LEN(8)+DWBRMSGDSC_SC+BI_SRC_Y:ud			// Read 8 GRFs from SRC_Y
+//	(f0.0) jmpi		load_Y_16x16T
+
+	// Non frame picture
+    (f0.1) mov (1)	MSGDSC	RESP_LEN(8)+DWBRMSGDSC_SC_BF+BI_SRC_Y:ud  // Read 8 GRFs from SRC_Y bottom field
+    (-f0.1) mov (1)	MSGDSC	RESP_LEN(8)+DWBRMSGDSC_SC_TF+BI_SRC_Y:ud  // Read 8 GRFs from SRC_Y top field
+
+//load_Y_16x16T:
+
+#endif
+
+    send (8) SRC_YD(0)<1>	MSGHDRC		MSGSRC<8;8,1>:ud	DAPREAD	MSGDSC
+    	
+//	#include "Transpose_Cur_Y_16x16.asm"
+
+// End of load_Y_16x16T
diff --git a/i965_drv_video/shaders/h264/ildb/load_Cur_Y_16x16T_Mbaff.asm b/i965_drv_video/shaders/h264/ildb/load_Cur_Y_16x16T_Mbaff.asm
new file mode 100644
index 0000000..f9c4745
--- /dev/null
+++ b/i965_drv_video/shaders/h264/ildb/load_Cur_Y_16x16T_Mbaff.asm
@@ -0,0 +1,62 @@
+/*
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+// Module name: load_Y_16x16T.asm
+//
+// Load and transpose Y 16x16 block 
+//
+//----------------------------------------------------------------
+//  Symbols need to be defined before including this module
+//
+//	Source region in :ud
+//	SRC_YD:			SRC_YD Base=rxx ElementSize=4 SrcRegion=REGION(8,1) Type=ud			// 8 GRFs
+//
+//	Binding table index: 
+//	BI_SRC_Y:		Binding table index of Y surface
+//
+//----------------------------------------------------------------
+
+#if defined(_DEBUG) 
+	mov		(1)		EntrySignatureC:w			0xDDD1:w
+#endif
+
+    // FieldModeCurrentMbFlag determines how to access left MB
+	and.z.f0.0 (1) 	null:w		r[ECM_AddrReg, BitFlags]:ub		FieldModeCurrentMbFlag:w		
+	
+    and.nz.f0.1 (1)	NULLREGW 	BitFields:w  	BotFieldFlag:w		// Get bottom field flag
+
+	// Read Y
+    mov (2)	MSGSRC.0<1>:d	ORIX_CUR<2;2,1>:w		{ NoDDClr }		// Block origin
+    mov (1)	MSGSRC.2<1>:ud	0x000F000F:ud			{ NoDDChk }		// Block width and height (16x16)
+    
+    // Set message descriptor, etc.
+    
+	(f0.0)	if	(1)		ILDB_LABEL(ELSE_Y_16x16T)
+
+    // Frame picture
+    mov (1)	MSGDSC	RESP_LEN(8)+DWBRMSGDSC_SC+BI_SRC_Y:ud			// Read 8 GRFs from SRC_Y
+    
+	(f0.1) add (1)	MSGSRC.1:d	MSGSRC.1:d		16:w		// Add vertical offset 16 for bot MB in MBAFF mode
+    
+ILDB_LABEL(ELSE_Y_16x16T): 
+	else 	(1)		ILDB_LABEL(ENDIF_Y_16x16T)
+
+	// Field picture
+    (f0.1) mov (1)	MSGDSC	RESP_LEN(8)+DWBRMSGDSC_SC_BF+BI_SRC_Y:ud  // Read 8 GRFs from SRC_Y bottom field
+    (-f0.1) mov (1)	MSGDSC	RESP_LEN(8)+DWBRMSGDSC_SC_TF+BI_SRC_Y:ud  // Read 8 GRFs from SRC_Y top field
+
+	asr (1)	MSGSRC.1:d		MSGSRC.1:d		1:w					// Reduce y by half in field access mode
+
+	endif
+ILDB_LABEL(ENDIF_Y_16x16T):
+
+    send (8) SRC_YD(0)<1>	MSGHDRY	MSGSRC<8;8,1>:ud	DAPREAD	MSGDSC
+
+//	#include "Transpose_Cur_Y_16x16.asm"
+
+// End of load_Y_16x16T
diff --git a/i965_drv_video/shaders/h264/ildb/load_Cur_Y_Right_Most_4x16.asm b/i965_drv_video/shaders/h264/ildb/load_Cur_Y_Right_Most_4x16.asm
new file mode 100644
index 0000000..cd25ace
--- /dev/null
+++ b/i965_drv_video/shaders/h264/ildb/load_Cur_Y_Right_Most_4x16.asm
@@ -0,0 +1,85 @@
+/*
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+// Module name: load_Cur_Y_Right_Most_4x16.asm
+//
+// Load luma cur MB right most 4x16 into LEFT_TEMP_B
+
+#if defined(_DEBUG) 
+	mov		(1)		EntrySignatureC:w			0xDDD0:w
+#endif
+
+
+#if defined(_PROGRESSIVE) 
+	// Read Y 
+    add (1)	MSGSRC.0<1>:ud	ORIX_CUR:w		12:w	{ NoDDClr }				// Block origin, move right 12 bytes
+    mov (1)	MSGSRC.1<1>:ud	ORIY_CUR:w				{ NoDDClr, NoDDChk }	// Block origin
+    mov (1)	MSGSRC.2<1>:ud	0x000F0003:ud			{ NoDDChk }				// Block width and height (4x16)
+    send (8) LEFT_TEMP_D(0)<1>	MSGHDRL		MSGSRC<8;8,1>:ud	DAPREAD	RESP_LEN(2)+DWBRMSGDSC_RC+BI_DEST_Y	
+#endif
+
+
+#if defined(_FIELD) || defined(_MBAFF)
+
+    // FieldModeCurrentMbFlag determines how to access left MB
+	and.z.f0.0 (1) 	null:w		r[ECM_AddrReg, BitFlags]:ub		FieldModeCurrentMbFlag:w		
+
+    and.nz.f0.1 (1)	NULLREGW 		BitFields:w  	BotFieldFlag:w	// Get bottom field flag
+
+	// Read Y
+    add (1)	MSGSRC.0<1>:ud	ORIX_CUR:w		12:w	{ NoDDClr }				// Block origin, move right 12 bytes
+    mov (1)	MSGSRC.1<1>:ud	ORIY_CUR:w				{ NoDDClr, NoDDChk }	// Block origin
+    mov (1)	MSGSRC.2<1>:ud	0x000F0003:ud			{ NoDDChk }				// Block width and height (4x16)
+    
+    // Set message descriptor, etc.
+    
+	(f0.0)	if	(1)		ILDB_LABEL(ELSE_Y_4x16T)
+
+    // Frame picture
+    mov (1)	MSGDSC	RESP_LEN(2)+DWBRMSGDSC_RC+BI_DEST_Y:ud			// Read 2 GRFs from DEST_Y
+    
+	(f0.1) add (1)	MSGSRC.1:d		MSGSRC.1:d		16:w		// Add vertical offset 16 for bot MB in MBAFF mode
+    
+ILDB_LABEL(ELSE_Y_4x16T): 
+	else 	(1)		ILDB_LABEL(ENDIF_Y_4x16T)
+
+	// Field picture
+    (f0.1) mov (1)	MSGDSC	RESP_LEN(2)+DWBRMSGDSC_RC_BF+BI_DEST_Y:ud  // Read 2 GRFs from DEST_Y bottom field
+    (-f0.1) mov (1)	MSGDSC	RESP_LEN(2)+DWBRMSGDSC_RC_TF+BI_DEST_Y:ud  // Read 2 GRFs from DEST_Y top field
+
+	endif
+ILDB_LABEL(ENDIF_Y_4x16T):
+
+//    send (8) BUF_D(0)<1>	MSGHDRY	MSGSRC<8;8,1>:ud	MSGDSC
+    send (8) LEFT_TEMP_D(0)<1>	MSGHDRL		MSGSRC<8;8,1>:ud	DAPREAD	MSGDSC
+#endif
+
+//	Transpose 4x16 to 16x4
+
+//	Input received from dport:
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//	|73 72 71 70 63 62 61 60 53 52 51 50 43 42 41 40 33 32 31 30 23 22 21 20 13 12 11 10 03 02 01 00|
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//	|f3 f2 f1 f0 e3 e2 e1 e0 d3 d2 d1 d0 c3 c2 c1 c0 b3 b2 b1 b0 a3 a2 a1 a0 93 92 91 90 83 82 81 80|
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+
+//	Output of transpose:		<1>	<= <32;8,4>
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//	|f1 e1 d1 c1 b1 a1 91 81 71 61 51 41 31 21 11 01 f0 e0 d0 c0 b0 a0 90 80 70 60 50 40 30 20 10 00|
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//	|f3 e3 d3 c3 b3 a3 93 83 73 63 53 43 33 23 13 03 f2 e2 d2 c2 b2 a2 92 82 72 62 52 42 32 22 12 02|
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+/*
+	// Transpose the data, also occupy 2 GRFs
+	mov (16)	PREV_MB_YB(0)<1>			BUF_B(0, 0)<32;8,4>		{ NoDDClr }
+	mov (16)	PREV_MB_YB(0, 16)<1>		BUF_B(0, 1)<32;8,4>		{ NoDDChk }
+	mov (16)	PREV_MB_YB(1)<1>			BUF_B(0, 2)<32;8,4>		{ NoDDClr }
+	mov (16)	PREV_MB_YB(1, 16)<1>		BUF_B(0, 3)<32;8,4>		{ NoDDChk }
+*/
+// End of load_Y_4x16T
+
diff --git a/i965_drv_video/shaders/h264/ildb/load_Left_UV_2x8T.asm b/i965_drv_video/shaders/h264/ildb/load_Left_UV_2x8T.asm
new file mode 100644
index 0000000..a5f622c
--- /dev/null
+++ b/i965_drv_video/shaders/h264/ildb/load_Left_UV_2x8T.asm
@@ -0,0 +1,76 @@
+/*
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+// Module Name: Load_Left_UV_2X8T.Asm
+//
+// Load UV 8X2 Block 
+//
+//----------------------------------------------------------------
+//  Symbols ceed To be defined before including this module
+//
+//	Source Region Is :UB
+//	BUF_D:			BUF_D Base=Rxx Elementsize=4 Srcregion=Region(8,1) Type=UD
+
+//	Binding Table Index: 
+//	BI_SRC_UV:		Binding Table Index Of UV Surface (NV12)
+//
+//----------------------------------------------------------------
+
+#if defined(_DEBUG) 
+	mov		(1)		EntrySignatureC:w			0xDDD0:w
+#endif
+
+#if defined(_PROGRESSIVE) 
+	// Read U+V
+    mov (1)	MSGSRC.0:ud		ORIX_LEFT:w							{ NoDDClr }		// Block origin
+    asr (1)	MSGSRC.1:ud		ORIY_LEFT:w			1:w				{ NoDDClr, NoDDChk }		// NV12 U+V block origin y = half of Y comp
+    mov (1)	MSGSRC.2:ud		0x00070003:ud						{ NoDDChk }		// NV12 U+V block width and height (4x8)
+
+	send (8) LEFT_TEMP_D(0)<1>	MSGHDRU	MSGSRC<8;8,1>:ud	DAPREAD	RESP_LEN(1)+DWBRMSGDSC_RC+BI_DEST_UV	
+#endif
+
+#if defined(_FIELD) || defined(_MBAFF)
+
+    // FieldModeCurrentMbFlag determines how to access left MB
+	and.z.f0.0 (1) 	null:w		r[ECM_AddrReg, BitFlags]:ub		FieldModeCurrentMbFlag:w		
+
+    and.nz.f0.1 (1)	NULLREGW 		BitFields:w  	BotFieldFlag:w				// Get bottom field flag
+
+	// Read U+V
+    mov (1)	MSGSRC.0:ud		ORIX_LEFT:w							{ NoDDClr }		// Block origin
+    asr (1)	MSGSRC.1:ud		ORIY_LEFT:w			1:w				{ NoDDClr, NoDDChk }		// NV12 U+V block origin y = half of Y comp
+    mov (1)	MSGSRC.2:ud		0x00070003:ud						{ NoDDChk }		// NV12 U+V block width and height (4x8)
+
+	// Load NV12 U+V 
+	
+    // Set message descriptor
+
+	(f0.0)	if	(1)		ILDB_LABEL(ELSE_Y_2x8T)
+
+    // Frame picture
+    mov (1)	MSGDSC	RESP_LEN(1)+DWBRMSGDSC_RC+BI_DEST_UV:ud			// Read 1 GRF from SRC_UV
+
+	(f0.1) add (1)	MSGSRC.1:d		MSGSRC.1:d		8:w		// Add vertical offset 8 for bot MB in MBAFF mode
+
+ILDB_LABEL(ELSE_Y_2x8T): 
+	else 	(1)		ILDB_LABEL(ENDIF_Y_2x8T)
+
+	// Field picture
+    (f0.1) mov (1)	MSGDSC	RESP_LEN(1)+DWBRMSGDSC_RC_BF+BI_DEST_UV:ud  // Read 1 GRF from SRC_Y bottom field
+    (-f0.1) mov (1)	MSGDSC	RESP_LEN(1)+DWBRMSGDSC_RC_TF+BI_DEST_UV:ud  // Read 1 GRF from SRC_Y top field
+
+	endif
+ILDB_LABEL(ENDIF_Y_2x8T):
+
+	// Read 1 GRF from DEST surface as the above MB has been deblocked.
+//	send (8) BUF_D(0)<1>	MSGHDRU	MSGSRC<8;8,1>:ud	MSGDSC	
+	send (8) LEFT_TEMP_D(0)<1>	MSGHDRU	MSGSRC<8;8,1>:ud	DAPREAD	MSGDSC	
+
+#endif
+
+// End of load_Left_UV_2x8T.asm
diff --git a/i965_drv_video/shaders/h264/ildb/load_Left_UV_2x8T_Mbaff.asm b/i965_drv_video/shaders/h264/ildb/load_Left_UV_2x8T_Mbaff.asm
new file mode 100644
index 0000000..fefda4f
--- /dev/null
+++ b/i965_drv_video/shaders/h264/ildb/load_Left_UV_2x8T_Mbaff.asm
@@ -0,0 +1,79 @@
+/*
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+// Module Name: Load_Left_UV_2X8T.Asm
+//
+// Load UV 8X2 Block 
+//
+//----------------------------------------------------------------
+//  Symbols ceed To be defined before including this module
+//
+//	Source Region Is :UB
+//	BUF_D:			BUF_D Base=Rxx Elementsize=4 Srcregion=Region(8,1) Type=UD
+
+//	Binding Table Index: 
+//	BI_SRC_UV:		Binding Table Index Of UV Surface (NV12)
+//
+//----------------------------------------------------------------
+
+#if defined(_DEBUG) 
+	mov		(1)		EntrySignatureC:w			0xDDD0:w
+#endif
+
+    // FieldModeCurrentMbFlag determines how to access left MB
+	and.z.f0.0 (1) 	null:w		r[ECM_AddrReg, BitFlags]:ub		FieldModeCurrentMbFlag:w		
+
+    and.nz.f0.1 (1)	NULLREGW 		BitFields:w  	BotFieldFlag:w				// Get bottom field flag
+
+	// Read U+V
+    mov (1)	MSGSRC.0:ud		ORIX_LEFT:w							{ NoDDClr }		// Block origin
+    asr (1)	MSGSRC.1:ud		ORIY_LEFT:w			1:w				{ NoDDClr, NoDDChk }		// NV12 U+V block origin y = half of Y comp
+    mov (1)	MSGSRC.2:ud		0x00070003:ud						{ NoDDChk }		// NV12 U+V block width and height (4x8)
+
+	// Load NV12 U+V 
+	
+    // Set message descriptor
+
+	(f0.0)	if	(1)		ILDB_LABEL(ELSE_Y_2x8T)
+
+    // Frame picture
+    mov (1)	MSGDSC	RESP_LEN(1)+DWBRMSGDSC_RC+BI_DEST_UV:ud			// Read 1 GRF from SRC_UV
+
+	(f0.1) add (1)	MSGSRC.1:d		MSGSRC.1:d		8:w		// Add vertical offset 8 for bot MB in MBAFF mode
+
+ILDB_LABEL(ELSE_Y_2x8T): 
+	else 	(1)		ILDB_LABEL(ENDIF_Y_2x8T)
+
+	// Field picture
+    (f0.1) mov (1)	MSGDSC	RESP_LEN(1)+DWBRMSGDSC_RC_BF+BI_DEST_UV:ud  // Read 1 GRF from SRC_Y bottom field
+    (-f0.1) mov (1)	MSGDSC	RESP_LEN(1)+DWBRMSGDSC_RC_TF+BI_DEST_UV:ud  // Read 1 GRF from SRC_Y top field
+
+	asr (1)	MSGSRC.1:d		MSGSRC.1:d		1:w					// Reduce y by half in field access mode
+
+	endif
+ILDB_LABEL(ENDIF_Y_2x8T):
+
+	// Read 1 GRF from DEST surface as the above MB has been deblocked.
+//	send (8) BUF_D(0)<1>	MSGHDRU	MSGSRC<8;8,1>:ud	MSGDSC	
+	send (8) LEFT_TEMP_D(0)<1>	MSGHDRU	MSGSRC<8;8,1>:ud	DAPREAD	MSGDSC	
+
+
+//	Input from dport for transpose:	
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//	|71 71 70 70 61 61 60 60 51 51 50 50 41 41 40 40 31 31 30 30 21 21 20 20 11 11 10 10 01 01 00 00|
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//
+//	Output of transpose:	<1>	<=== <16;8,2>:w
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//	|71 71 61 61 51 51 41 41 31 31 21 21 11 11 01 01 70 70 60 60 50 50 40 40 30 30 20 20 10 10 00 00|
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+/*
+	mov (8)	PREV_MB_UW(0,0)<1>		BUF_W(0,0)<16;8,2>		{ NoDDClr }
+	mov (8)	PREV_MB_UW(0,8)<1>		BUF_W(0,1)<16;8,2>		{ NoDDChk }
+*/
+// End of load_Left_UV_2x8T.asm
diff --git a/i965_drv_video/shaders/h264/ildb/load_Left_Y_4x16T.asm b/i965_drv_video/shaders/h264/ildb/load_Left_Y_4x16T.asm
new file mode 100644
index 0000000..ab454f1
--- /dev/null
+++ b/i965_drv_video/shaders/h264/ildb/load_Left_Y_4x16T.asm
@@ -0,0 +1,96 @@
+/*
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+// Module name: load_Y_4x16T.asm
+//
+// Load luma left MB 4x16 and transpose 4x16 to 16x4.
+//
+//----------------------------------------------------------------
+//  Symbols need to be defined before including this module
+//
+//	Source region in :ud
+//	PREV_MB_YD:		PREV_MB_YD Base=rxx ElementSize=4 SrcRegion=REGION(8,1) Type=ud			// 2 GRFs
+//
+//	Binding table index: 
+//	BI_SRC_Y:		Binding table index of Y surface
+//
+//----------------------------------------------------------------
+
+#if defined(_DEBUG) 
+	mov		(1)		EntrySignatureC:w			0xDDD0:w
+#endif
+
+
+#if defined(_PROGRESSIVE) 
+	// Read Y
+    mov (2)	MSGSRC.0<1>:ud	ORIX_LEFT<2;2,1>:w		{ NoDDClr }		// Block origin
+    mov (1)	MSGSRC.2<1>:ud	0x000F0003:ud			{ NoDDChk }		// Block width and height (4x16)
+    
+//    mov (1)	MSGDSC	DWBRMSGDSC_RC+0x00020000+BI_DEST_Y:ud			// Read 2 GRFs from DEST_Y
+    send (8) LEFT_TEMP_D(0)<1>	MSGHDRL		MSGSRC<8;8,1>:ud	DAPREAD	RESP_LEN(2)+DWBRMSGDSC_RC+BI_DEST_Y	
+#endif
+
+
+#if defined(_FIELD) || defined(_MBAFF)
+
+    // FieldModeCurrentMbFlag determines how to access left MB
+	and.z.f0.0 (1) 	null:w		r[ECM_AddrReg, BitFlags]:ub		FieldModeCurrentMbFlag:w		
+
+    and.nz.f0.1 (1)	NULLREGW 		BitFields:w  	BotFieldFlag:w	// Get bottom field flag
+
+	// Read Y
+    mov (2)	MSGSRC.0<1>:ud	ORIX_LEFT<2;2,1>:w		{ NoDDClr }		// Block origin
+    mov (1)	MSGSRC.2<1>:ud	0x000F0003:ud			{ NoDDChk }		// Block width and height (4x16)
+    
+    // Set message descriptor, etc.
+    
+	(f0.0)	if	(1)		ILDB_LABEL(ELSE_Y_4x16T)
+
+    // Frame picture
+    mov (1)	MSGDSC	RESP_LEN(2)+DWBRMSGDSC_RC+BI_DEST_Y:ud			// Read 2 GRFs from DEST_Y
+    
+	(f0.1) add (1)	MSGSRC.1:d		MSGSRC.1:d		16:w		// Add vertical offset 16 for bot MB in MBAFF mode
+    
+ILDB_LABEL(ELSE_Y_4x16T): 
+	else 	(1)		ILDB_LABEL(ENDIF_Y_4x16T)
+
+	// Field picture
+    (f0.1) mov (1)	MSGDSC	RESP_LEN(2)+DWBRMSGDSC_RC_BF+BI_DEST_Y:ud  // Read 2 GRFs from DEST_Y bottom field
+    (-f0.1) mov (1)	MSGDSC	RESP_LEN(2)+DWBRMSGDSC_RC_TF+BI_DEST_Y:ud  // Read 2 GRFs from DEST_Y top field
+
+	endif
+ILDB_LABEL(ENDIF_Y_4x16T):
+
+//    send (8) BUF_D(0)<1>	MSGHDRY	MSGSRC<8;8,1>:ud	MSGDSC
+    send (8) LEFT_TEMP_D(0)<1>	MSGHDRL		MSGSRC<8;8,1>:ud	DAPREAD	MSGDSC
+#endif
+
+//	Transpose 4x16 to 16x4
+
+//	Input received from dport:
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//	|73 72 71 70 63 62 61 60 53 52 51 50 43 42 41 40 33 32 31 30 23 22 21 20 13 12 11 10 03 02 01 00|
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//	|f3 f2 f1 f0 e3 e2 e1 e0 d3 d2 d1 d0 c3 c2 c1 c0 b3 b2 b1 b0 a3 a2 a1 a0 93 92 91 90 83 82 81 80|
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+
+//	Output of transpose:		<1>	<= <32;8,4>
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//	|f1 e1 d1 c1 b1 a1 91 81 71 61 51 41 31 21 11 01 f0 e0 d0 c0 b0 a0 90 80 70 60 50 40 30 20 10 00|
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//	|f3 e3 d3 c3 b3 a3 93 83 73 63 53 43 33 23 13 03 f2 e2 d2 c2 b2 a2 92 82 72 62 52 42 32 22 12 02|
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+/*
+	// Transpose the data, also occupy 2 GRFs
+	mov (16)	PREV_MB_YB(0)<1>			BUF_B(0, 0)<32;8,4>		{ NoDDClr }
+	mov (16)	PREV_MB_YB(0, 16)<1>		BUF_B(0, 1)<32;8,4>		{ NoDDChk }
+	mov (16)	PREV_MB_YB(1)<1>			BUF_B(0, 2)<32;8,4>		{ NoDDClr }
+	mov (16)	PREV_MB_YB(1, 16)<1>		BUF_B(0, 3)<32;8,4>		{ NoDDChk }
+*/
+// End of load_Y_4x16T
+
diff --git a/i965_drv_video/shaders/h264/ildb/load_Left_Y_4x16T_Mbaff.asm b/i965_drv_video/shaders/h264/ildb/load_Left_Y_4x16T_Mbaff.asm
new file mode 100644
index 0000000..95f73a3
--- /dev/null
+++ b/i965_drv_video/shaders/h264/ildb/load_Left_Y_4x16T_Mbaff.asm
@@ -0,0 +1,84 @@
+/*
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+// Module name: load_Y_4x16T.asm
+//
+// Load luma left MB 4x16 and transpose 4x16 to 16x4.
+//
+//----------------------------------------------------------------
+//  Symbols need to be defined before including this module
+//
+//	Source region in :ud
+//	PREV_MB_YD:		PREV_MB_YD Base=rxx ElementSize=4 SrcRegion=REGION(8,1) Type=ud			// 2 GRFs
+//
+//	Binding table index: 
+//	BI_SRC_Y:		Binding table index of Y surface
+//
+//----------------------------------------------------------------
+
+#if defined(_DEBUG) 
+	mov		(1)		EntrySignatureC:w			0xDDD0:w
+#endif
+
+    // FieldModeCurrentMbFlag determines how to access left MB
+	and.z.f0.0 (1) 	null:w		r[ECM_AddrReg, BitFlags]:ub		FieldModeCurrentMbFlag:w		
+
+    and.nz.f0.1 (1)	NULLREGW 		BitFields:w  	BotFieldFlag:w	// Get bottom field flag
+
+	// Read Y
+    mov (2)	MSGSRC.0<1>:ud	ORIX_LEFT<2;2,1>:w		{ NoDDClr }		// Block origin
+    mov (1)	MSGSRC.2<1>:ud	0x000F0003:ud			{ NoDDChk }		// Block width and height (4x16)
+    
+    // Set message descriptor, etc.
+    
+	(f0.0)	if	(1)		ELSE_Y_4x16T
+
+    // Frame picture
+    mov (1)	MSGDSC	RESP_LEN(2)+DWBRMSGDSC_RC+BI_DEST_Y:ud			// Read 2 GRFs from DEST_Y
+    
+	(f0.1) add (1)	MSGSRC.1:d		MSGSRC.1:d		16:w		// Add vertical offset 16 for bot MB in MBAFF mode
+    
+ELSE_Y_4x16T: 
+	else 	(1)		ENDIF_Y_4x16T
+
+	// Field picture
+    (f0.1) mov (1)	MSGDSC	RESP_LEN(2)+DWBRMSGDSC_RC_BF+BI_DEST_Y:ud  // Read 2 GRFs from DEST_Y bottom field
+    (-f0.1) mov (1)	MSGDSC	RESP_LEN(2)+DWBRMSGDSC_RC_TF+BI_DEST_Y:ud  // Read 2 GRFs from DEST_Y top field
+
+	asr (1)	MSGSRC.1:d		MSGSRC.1:d		1:w					// Reduce y by half in field access mode
+
+	endif
+ENDIF_Y_4x16T:
+
+//    send (8) BUF_D(0)<1>	MSGHDRY	MSGSRC<8;8,1>:ud	MSGDSC
+    send (8) LEFT_TEMP_D(0)<1>	MSGHDRL		MSGSRC<8;8,1>:ud	DAPREAD	MSGDSC
+
+
+//	Transpose 4x16 to 16x4
+
+//	Input received from dport:
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//	|73 72 71 70 63 62 61 60 53 52 51 50 43 42 41 40 33 32 31 30 23 22 21 20 13 12 11 10 03 02 01 00|
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//	|f3 f2 f1 f0 e3 e2 e1 e0 d3 d2 d1 d0 c3 c2 c1 c0 b3 b2 b1 b0 a3 a2 a1 a0 93 92 91 90 83 82 81 80|
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+
+//	Output of transpose:		<1>	<= <32;8,4>
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//	|f1 e1 d1 c1 b1 a1 91 81 71 61 51 41 31 21 11 01 f0 e0 d0 c0 b0 a0 90 80 70 60 50 40 30 20 10 00|
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//	|f3 e3 d3 c3 b3 a3 93 83 73 63 53 43 33 23 13 03 f2 e2 d2 c2 b2 a2 92 82 72 62 52 42 32 22 12 02|
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+/*
+	// Transpose the data, also occupy 2 GRFs
+	mov (16)	PREV_MB_YB(0)<1>			BUF_B(0, 0)<32;8,4>		{ NoDDClr }
+	mov (16)	PREV_MB_YB(0, 16)<1>		BUF_B(0, 1)<32;8,4>		{ NoDDChk }
+	mov (16)	PREV_MB_YB(1)<1>			BUF_B(0, 2)<32;8,4>		{ NoDDClr }
+	mov (16)	PREV_MB_YB(1, 16)<1>		BUF_B(0, 3)<32;8,4>		{ NoDDChk }
+*/
+// End of load_Y_4x16T
diff --git a/i965_drv_video/shaders/h264/ildb/load_Top_UV_8x2.asm b/i965_drv_video/shaders/h264/ildb/load_Top_UV_8x2.asm
new file mode 100644
index 0000000..844291f
--- /dev/null
+++ b/i965_drv_video/shaders/h264/ildb/load_Top_UV_8x2.asm
@@ -0,0 +1,70 @@
+/*
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+// Module Name: Load_Top_UV_8X2.Asm
+//
+// Load UV 8X2 Block 
+//
+//----------------------------------------------------------------
+//  Symbols ceed To be defined before including this module
+//
+//	Source Region Is :UB
+//	BUF_D:			BUF_D Base=Rxx Elementsize=4 Srcregion=Region(8,1) Type=UD
+
+//	Binding Table Index: 
+//	BI_SRC_UV:		Binding Table Index Of UV Surface (NV12)
+//
+//----------------------------------------------------------------
+
+#if defined(_DEBUG) 
+	mov		(1)		EntrySignatureC:w			0xDDD2:w
+#endif
+
+#if defined(_PROGRESSIVE) 
+	// Read U+V
+    mov (1)	MSGSRC.0:ud		ORIX_TOP:w						{ NoDDClr }			// Block origin
+    asr (1)	MSGSRC.1:ud		ORIY_TOP:w			1:w			{ NoDDClr, NoDDChk }	// NV12 U+V block origin y = half of Y comp
+    mov (1)	MSGSRC.2:ud		0x0001000F:ud					{ NoDDChk }			// NV12 U+V block width and height (16x2)
+
+	// Read 1 GRF from DEST surface as the above MB has been deblocked.
+	//send (8) TOP_MB_UD(0)<1>	MSGHDRU		MSGSRC<8;8,1>:ud	RESP_LEN(1)+DWBRMSGDSC_RC+BI_DEST_UV	
+	mov (1)	MSGDSC	RESP_LEN(1)+DWBRMSGDSC_RC+BI_DEST_UV:ud	
+#endif
+
+#if defined(_FIELD)
+
+//    cmp.z.f0.0 (1)  NULLREGW PicTypeC:w  	0:w							// Get pic type flag
+    and.nz.f0.1 (1)  NULLREGW 	BitFields:w  	BotFieldFlag:w			// Get bottom field flag
+	// They are used later in this file
+
+	// Read U+V
+    mov (1)	MSGSRC.0:ud		ORIX_TOP:w						{ NoDDClr }			// Block origin
+    asr (1)	MSGSRC.1:ud		ORIY_TOP:w			1:w			{ NoDDClr, NoDDChk }	// NV12 U+V block origin y = half of Y comp
+    mov (1)	MSGSRC.2:ud		0x0001000F:ud					{ NoDDChk }			// NV12 U+V block width and height (16x2)
+
+	// Load NV12 U+V 
+	
+    // Set message descriptor
+    // Frame picture
+//    (f0.0) mov (1)	MSGDSC	DWBRMSGDSC_RC+0x00010000+BI_DEST_UV:ud			// Read 1 GRF from SRC_UV
+//	(f0.0) jmpi		Load_Top_UV_8x2
+
+	// Field picture
+    (f0.1) mov (1)	MSGDSC	RESP_LEN(1)+DWBRMSGDSC_RC_BF+BI_DEST_UV:ud  // Read 1 GRF from SRC_Y bottom field
+    (-f0.1) mov (1)	MSGDSC	RESP_LEN(1)+DWBRMSGDSC_RC_TF+BI_DEST_UV:ud  // Read 1 GRF from SRC_Y top field
+
+//Load_Top_UV_8x2:
+
+	// Read 1 GRF from DEST surface as the above MB has been deblocked.
+//	send (8) PREV_MB_UD(0)<1>	MSGHDRU		MSGSRC<8;8,1>:ud	MSGDSC	
+
+#endif
+
+	send (8) TOP_MB_UD(0)<1>	MSGHDRU		MSGSRC<8;8,1>:ud	DAPREAD	MSGDSC	
+		
+// End of load_Top_UV_8x2.asm
diff --git a/i965_drv_video/shaders/h264/ildb/load_Top_UV_8x2_Mbaff.asm b/i965_drv_video/shaders/h264/ildb/load_Top_UV_8x2_Mbaff.asm
new file mode 100644
index 0000000..d60aa4e
--- /dev/null
+++ b/i965_drv_video/shaders/h264/ildb/load_Top_UV_8x2_Mbaff.asm
@@ -0,0 +1,79 @@
+/*
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+// Module Name: Load_Top_UV_8X2.Asm
+//
+// Load UV 8X2 Block 
+//
+//----------------------------------------------------------------
+//  Symbols ceed To be defined before including this module
+//
+//	Source Region Is :UB
+//	BUF_D:			BUF_D Base=Rxx Elementsize=4 Srcregion=Region(8,1) Type=UD
+
+//	Binding Table Index: 
+//	BI_SRC_UV:		Binding Table Index Of UV Surface (NV12)
+//
+//----------------------------------------------------------------
+
+#if defined(_DEBUG) 
+	mov		(1)		EntrySignatureC:w			0xDDD2:w
+#endif
+
+    // FieldModeCurrentMbFlag determines how to access above MB
+	and.z.f0.0 (1) 	null:w		r[ECM_AddrReg, BitFlags]:ub		FieldModeCurrentMbFlag:w		
+
+    and.nz.f0.1 (1) NULLREGW 	BitFields:w   	BotFieldFlag:w
+
+	// Read U+V
+    mov (1)	MSGSRC.0:ud		ORIX_TOP:w						{ NoDDClr }			// Block origin
+    asr (1)	MSGSRC.1:d		ORIY_TOP:w			1:w			{ NoDDClr, NoDDChk } 	// NV12 U+V block origin y = half of Y comp
+    mov (1)	MSGSRC.2:ud		0x0001000F:ud					{ NoDDChk }			// NV12 U+V block width and height (16x2)
+
+	// Load NV12 U+V 
+	
+    // Set message descriptor
+    
+	(f0.0)	if	(1)		ELSE_UV_8X2
+
+    // Frame picture
+    mov (1)	MSGDSC	RESP_LEN(1)+DWBRMSGDSC_RC+BI_DEST_UV:ud			// Read 1 GRF from SRC_UV
+
+	// Add vertical offset 8 for bot MB in MBAFF mode
+	(f0.1) add (1)	MSGSRC.1:d	MSGSRC.1:d		8:w		
+    
+	// Dual field mode setup
+	and.z.f0.1 (1) NULLREGW		DualFieldMode:w		1:w
+	(f0.1) jmpi NOT_DUAL_FIELD_UV
+
+    add (1)	MSGSRC.1:d		MSGSRC.1:d		-2:w			{ NoDDClr }			// Load 4 lines in stead of 2
+	mov (1)	MSGSRC.2:ud		0x0003000F:ud					{ NoDDChk }			// New block width and height (16x8)
+
+	add (1) MSGDSC			MSGDSC			RESP_LEN(1):ud	// 1 more GRF to receive
+
+NOT_DUAL_FIELD_UV:    
+    
+ELSE_UV_8X2: 
+	else 	(1)		ENDIF_UV_8X2
+
+	// Field picture
+	asr (1)	MSGSRC.1:d		ORIY_CUR:w		2:w			// asr 1: NV12 U+V block origin y = half of Y comp
+														// asr 1: Reduce y by half in field access mode
+	
+    (f0.1) mov (1)	MSGDSC	RESP_LEN(1)+DWBRMSGDSC_RC_BF+BI_DEST_UV:ud  // Read 1 GRF from SRC_Y bottom field
+    (-f0.1) mov (1)	MSGDSC	RESP_LEN(1)+DWBRMSGDSC_RC_TF+BI_DEST_UV:ud  // Read 1 GRF from SRC_Y top field
+
+	add (1) MSGSRC.1:d		MSGSRC.1:d		-2:w				// for last 2 rows of above MB
+
+	endif
+ENDIF_UV_8X2:
+
+	// Read 1 GRF from DEST surface as the above MB has been deblocked.
+	send (8) PREV_MB_UD(0)<1>	MSGHDRU	MSGSRC<8;8,1>:ud	DAPREAD	MSGDSC	
+
+// End of load_Top_UV_8x2.asm
diff --git a/i965_drv_video/shaders/h264/ildb/load_Top_Y_16x4.asm b/i965_drv_video/shaders/h264/ildb/load_Top_Y_16x4.asm
new file mode 100644
index 0000000..7590d62
--- /dev/null
+++ b/i965_drv_video/shaders/h264/ildb/load_Top_Y_16x4.asm
@@ -0,0 +1,70 @@
+/*
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+// Module Name: Load_Y_16X4.asm
+//
+// Load Y 16X4 Block to PREV_MB_YD
+//
+//----------------------------------------------------------------
+//  Symbols Need To Be Defined Before Including This Module
+//
+//	Source Region In :Ud
+//	Src_YD:			Src_Yd Base=Rxx Elementsize=4 Srcregion=Region(8,1) Type=Ud			// 3 Grfs (2 For Y, 1 For U+V)
+//
+//	Source Region Is :Ub.  The Same Region As :Ud Region
+//	Src_YB:			Src_Yb Base=Rxx Elementsize=1 Srcregion=Region(16,1) Type=Ub		// 2 Grfs
+//
+//	Binding Table Index: 
+//	Bi_Src_Y:		Binding Table Index Of Y Surface
+//
+//	Temp Buffer:
+//	Buf_D:			Buf_D Base=Rxx Elementsize=4 Srcregion=Region(8,1) Type=Ud
+//	Buf_B:			Buf_B Base=Rxx Elementsize=1 Srcregion=Region(16,1) Type=Ub
+//
+//----------------------------------------------------------------
+
+#if defined(_DEBUG) 
+	mov		(1)		EntrySignatureC:w			0xDDD2:w
+#endif
+
+#if defined(_PROGRESSIVE) 
+	// Read Y
+    mov (2)	MSGSRC.0<1>:ud	ORIX_TOP<2;2,1>:w		{ NoDDClr }		// Block origin
+    mov (1)	MSGSRC.2<1>:ud	0x0003000F:ud			{ NoDDChk }		// Block width and height (16x4)
+
+    mov (1)	MSGDSC	RESP_LEN(2)+DWBRMSGDSC_RC+BI_DEST_Y:ud			// Read 2 GRFs from SRC_Y
+#endif
+
+#if defined(_FIELD)
+
+//    cmp.z.f0.0 (1)  NULLREGW 	PicTypeC:w  	0:w						// Get pic type flag
+    and.nz.f0.1 (1) NULLREGW 	BitFields:w  	BotFieldFlag:w			// Get bottom field flag
+	// they are used later in this file
+	
+    mov (2)	MSGSRC.0<1>:ud	ORIX_TOP<2;2,1>:w		{ NoDDClr }		// Block origin
+    mov (1)	MSGSRC.2<1>:ud	0x0003000F:ud			{ NoDDChk }		// Block width and height (16x4)
+   
+    // Set message descriptor
+
+    // Frame picture
+//	(f0.0) mov (1)	MSGDSC	DWBRMSGDSC_RC+0x00020000+BI_DEST_Y:ud			// Read 2 GRFs from SRC_Y
+//	(f0.0) jmpi		load_Y_16x4
+
+	// Field picture
+    (f0.1) mov (1)	MSGDSC	RESP_LEN(2)+DWBRMSGDSC_RC_BF+BI_DEST_Y:ud  // Read 2 GRFs from SRC_Y bottom field
+    (-f0.1) mov (1)	MSGDSC	RESP_LEN(2)+DWBRMSGDSC_RC_TF+BI_DEST_Y:ud  // Read 2 GRFs from SRC_Y top field
+
+//load_Y_16x4:
+    // Read 2 GRFs from DEST surface, as the above MB has been deblocked
+//    send (8) PREV_MB_YD(0)<1>	MSGHDRY		MSGSRC<8;8,1>:ud	MSGDSC
+    
+#endif
+    
+    send (8) TOP_MB_YD(0)<1>	MSGHDRT		MSGSRC<8;8,1>:ud	DAPREAD	MSGDSC
+    	    
+// End of load_Y_16x4.asm
diff --git a/i965_drv_video/shaders/h264/ildb/load_Top_Y_16x4_Mbaff.asm b/i965_drv_video/shaders/h264/ildb/load_Top_Y_16x4_Mbaff.asm
new file mode 100644
index 0000000..0237882
--- /dev/null
+++ b/i965_drv_video/shaders/h264/ildb/load_Top_Y_16x4_Mbaff.asm
@@ -0,0 +1,81 @@
+/*
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+// Module Name: Load_Y_16X4.asm
+//
+// Load Y 16X4 Block to PREV_MB_YD
+//
+//----------------------------------------------------------------
+//  Symbols Need To Be Defined Before Including This Module
+//
+//	Source Region In :Ud
+//	Src_YD:			Src_Yd Base=Rxx Elementsize=4 Srcregion=Region(8,1) Type=Ud			// 3 Grfs (2 For Y, 1 For U+V)
+//
+//	Source Region Is :Ub.  The Same Region As :Ud Region
+//	Src_YB:			Src_Yb Base=Rxx Elementsize=1 Srcregion=Region(16,1) Type=Ub		// 2 Grfs
+//
+//	Binding Table Index: 
+//	Bi_Src_Y:		Binding Table Index Of Y Surface
+//
+//	Temp Buffer:
+//	Buf_D:			Buf_D Base=Rxx Elementsize=4 Srcregion=Region(8,1) Type=Ud
+//	Buf_B:			Buf_B Base=Rxx Elementsize=1 Srcregion=Region(16,1) Type=Ub
+//
+//----------------------------------------------------------------
+
+#if defined(_DEBUG) 
+	mov		(1)		EntrySignatureC:w			0xDDD2:w
+#endif
+    // FieldModeCurrentMbFlag determines how to access above MB
+	and.z.f0.0 (1) 	null:w		r[ECM_AddrReg, BitFlags]:ub		FieldModeCurrentMbFlag:w		
+
+    and.nz.f0.1 (1) NULLREGW 	BitFields:w   BotFieldFlag:w
+
+	// Read Y
+    mov (2)	MSGSRC.0<1>:ud	ORIX_TOP<2;2,1>:w		{ NoDDClr }		// Block origin
+    mov (1)	MSGSRC.2<1>:ud	0x0003000F:ud			{ NoDDChk }		// Block width and height (16x4)
+   
+    // Set message descriptor
+
+	(f0.0)	if	(1)		ELSE_Y_16x4
+
+    // Frame picture
+    mov (1)	MSGDSC	RESP_LEN(2)+DWBRMSGDSC_RC+BI_DEST_Y:ud			// Read 2 GRFs from SRC_Y
+
+	// Add vertical offset 16 for bot MB in MBAFF mode
+	(f0.1) add (1)	MSGSRC.1:d	MSGSRC.1:d		16:w		
+	
+	// Dual field mode setup
+	and.z.f0.1 (1) NULLREGW		DualFieldMode:w		1:w
+	(f0.1) jmpi NOT_DUAL_FIELD
+
+    add (1)	MSGSRC.1:d		MSGSRC.1:d		-4:w	{ NoDDClr }		// Load 8 lines in above MB
+	mov (1)	MSGSRC.2:ud		0x0007000F:ud			{ NoDDChk }		// New block width and height (16x8)
+	
+	add (1) MSGDSC			MSGDSC			RESP_LEN(2):ud	// 2 more GRF to receive
+
+NOT_DUAL_FIELD:
+
+ELSE_Y_16x4: 
+	else 	(1)		ENDIF_Y_16x4
+
+	asr (1)	MSGSRC.1:d		ORIY_CUR:w		1:w		// Reduce y by half in field access mode
+
+	// Field picture
+    (f0.1) mov (1)	MSGDSC	RESP_LEN(2)+DWBRMSGDSC_RC_BF+BI_DEST_Y:ud  // Read 2 GRFs from SRC_Y bottom field
+    (-f0.1) mov (1)	MSGDSC	RESP_LEN(2)+DWBRMSGDSC_RC_TF+BI_DEST_Y:ud  // Read 2 GRFs from SRC_Y top field
+
+	add (1)	MSGSRC.1:d		MSGSRC.1:d		-4:w	// for last 4 rows of above MB
+
+	endif
+ENDIF_Y_16x4:
+        
+    // Read 2 GRFs from DEST surface, as the above MB has been deblocked
+    send (8) PREV_MB_YD(0)<1>	MSGHDRY	MSGSRC<8;8,1>:ud	DAPREAD	MSGDSC
+
+// End of load_Y_16x4.asm
diff --git a/i965_drv_video/shaders/h264/ildb/saveNV12_16x16.asm b/i965_drv_video/shaders/h264/ildb/saveNV12_16x16.asm
new file mode 100644
index 0000000..1cbe27b
--- /dev/null
+++ b/i965_drv_video/shaders/h264/ildb/saveNV12_16x16.asm
@@ -0,0 +1,53 @@
+/*
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+// Module name: saveNV12_16x16.asm
+//
+// Save a NV12 16x16 block 
+//
+//----------------------------------------------------------------
+//  Symbols need to be defined before including this module
+//
+//	Source region in :ud
+//	SRC_YD:			SRC_YD Base=rxx ElementSize=4 SrcRegion=REGION(8,1) Type=ud			// 8 GRFs
+//	SRC_UD:			SRC_UD Base=rxx ElementSize=4 SrcRegion=REGION(8,1) Type=ud			// 4 GRF
+//
+//	Binding table index: 
+//	BI_DEST_Y:		Binding table index of Y surface
+//	BI_DEST_UV:		Binding table index of UV surface (NV12)
+//
+//----------------------------------------------------------------
+
+#if defined(_DEBUG) 
+	mov		(1)		EntrySignatureC:w			0xDDD4:w
+#endif
+
+
+    mov (2)	MSGSRC.0<1>:ud	ORIX_CUR<2;2,1>:w		// Block origin
+    mov (1)	MSGSRC.2<1>:ud	0x000F000F:ud		// Block width and height (16x16)
+
+	// Pack Y    
+	mov	(16)	MSGPAYLOADD(0)<1>		SRC_YD(0)		// Compressed inst
+	mov (16)	MSGPAYLOADD(2)<1>		SRC_YD(2)
+	mov (16)	MSGPAYLOADD(4)<1>		SRC_YD(4)
+	mov (16)	MSGPAYLOADD(6)<1>		SRC_YD(6)
+    
+    send (8)	NULLREG	MSGHDR	MSGSRC<8;8,1>:ud	DAPWRITE	MSG_LEN(8)+DWBWMSGDSC+BI_DEST_Y		// Write 8 GRFs
+
+
+
+    asr (1)	MSGSRC.1:ud		MSGSRC.1:ud			1:w						// NV12 U+V block origin y = half of Y comp
+    mov (1)	MSGSRC.2<1>:ud	0x0007000F:ud								// NV12 U+V block width and height (16x8)
+
+	mov (16)	MSGPAYLOADD(0)<1>		SRC_UD(0)		// Compressed inst
+	mov (16)	MSGPAYLOADD(2)<1>		SRC_UD(2)
+
+    send (8)	NULLREG	MSGHDR	MSGSRC<8;8,1>:ud	DAPWRITE	MSG_LEN(4)+DWBWMSGDSC+BI_DEST_UV		// Write 4 GRFs
+
+
+// End of saveNV12_16x16.asm
diff --git a/i965_drv_video/shaders/h264/ildb/saveNV12_16x4.asm b/i965_drv_video/shaders/h264/ildb/saveNV12_16x4.asm
new file mode 100644
index 0000000..3a99995
--- /dev/null
+++ b/i965_drv_video/shaders/h264/ildb/saveNV12_16x4.asm
@@ -0,0 +1,50 @@
+/*
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+// Module name: saveNV12_16x4.asm
+//
+// Save a NV12 16x4 block 
+//
+//----------------------------------------------------------------
+//  Symbols need to be defined before including this module
+//
+//	Source region in :ud
+//	SRC_YD:			SRC_YD Base=rxx ElementSize=4 SrcRegion=REGION(8,1) Type=ud			// 2 GRFs
+//	SRC_UD:			SRC_UD Base=rxx ElementSize=4 SrcRegion=REGION(8,1) Type=ud			// 1 GRF
+//
+//	Binding table index: 
+//	BI_DEST_Y:		Binding table index of Y surface
+//	BI_DEST_UV:		Binding table index of UV surface (NV12)
+//
+//----------------------------------------------------------------
+
+#if defined(_DEBUG) 
+	mov		(1)		EntrySignatureC:w			0xDDD5:w
+#endif
+
+    mov (2)	MSGSRC.0<1>:ud	ORIX_TOP<2;2,1>:w							// Block origin
+    mov (1)	MSGSRC.2<1>:ud	0x0003000F:ud								// Block width and height (16x4)
+
+	// Pack Y    
+	mov	(16)	MSGPAYLOADD(0)<1>		SRC_YD(0)						// Compressed inst
+    
+    send (8)	NULLREG	MSGHDR	MSGSRC<8;8,1>:ud	DAPWRITE	MSG_LEN(2)+DWBWMSGDSC+BI_DEST_Y		// Write 2 GRFs
+
+
+    asr (1)	MSGSRC.1:ud		MSGSRC.1:ud			1:w						// NV12 U+V block origin y = half of Y comp
+    mov (1)	MSGSRC.2<1>:ud	0x0001000F:ud								// NV12 U+V block width and height (16x2)
+
+	// Pack U and V
+//	mov (16)	MSGPAYLOADB(0,0)<2>		SRC_UB(0,0)
+//	mov (16)	MSGPAYLOADB(0,1)<2>		SRC_VB(0,0)
+	
+	mov (8)	MSGPAYLOADD(0,0)<1>		SRC_UD(0)	
+	
+    send (8)	NULLREG	MSGHDR	MSGSRC<8;8,1>:ud	DAPWRITE	MSG_LEN(1)+DWBWMSGDSC+BI_DEST_UV	// Write 1 GRF
+
+// End of saveNV12_16x4.asm
diff --git a/i965_drv_video/shaders/h264/ildb/saveNV12_16x4T.asm b/i965_drv_video/shaders/h264/ildb/saveNV12_16x4T.asm
new file mode 100644
index 0000000..66085d1
--- /dev/null
+++ b/i965_drv_video/shaders/h264/ildb/saveNV12_16x4T.asm
@@ -0,0 +1,113 @@
+/*
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+// Module name: saveNV12_16x4T.asm
+//
+// Transpose 16x4 to 4x16 YNV12 data and write to memory 
+//
+//----------------------------------------------------------------
+//  Symbols need to be defined before including this module
+//
+//	Left MB region:
+//	PREV_MB_YB:	  	Base=rxx 	ElementSize=1 SrcRegion=REGION(16,1) Type=ub
+//	PREV_MB_UW: 	Base=ryy 	ElementSize=2 SrcRegion=REGION(8,1) Type=uw
+
+//	Binding table index: 
+//	BI_SRC_Y:		Binding table index of Y surface
+//	BI_SRC_UV:		Binding table index of UV surface (NV12)
+//
+//	Temp buffer:
+//	BUF_B:			BUF_B Base=rxx ElementSize=1 SrcRegion=REGION(16,1) Type=ub
+//	BUF_W:			BUF_W Base=rxx ElementSize=1 SrcRegion=REGION(8,1) Type=uw
+//
+//
+#if defined(_DEBUG) 
+	mov		(1)		EntrySignatureC:w			0xDDD6:w
+#endif
+
+    mov (2)	MSGSRC.0<1>:ud	ORIX_LEFT<2;2,1>:w		// Block origin
+    mov (1)	MSGSRC.2<1>:ud	0x000F0003:ud			// 4x16
+    
+// Transpose Y, save them to MRFs
+
+//	16x4 Y src in GRF (each pix is specified as yx)
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//	|f1 e1 d1 c1 b1 a1 91 81 71 61 51 41 31 21 11 01 f0 e0 d0 c0 b0 a0 90 80 70 60 50 40 30 20 10 00|
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//	|f3 e3 d3 c3 b3 a3 93 83 73 63 53 43 33 23 13 03 f2 e2 d2 c2 b2 a2 92 82 72 62 52 42 32 22 12 02|
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//
+//  First step		(16)	<1>	<=== <16;4,1>
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//	|73 63 53 43 72 62 52 42 71 61 51 41 70 60 50 40 33 23 13 03 32 22 12 02 31 21 11 01 30 20 10 00|
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//	|f3 e3 d3 c3 f2 e2 d2 c2 f1 e1 d1 c1 f0 e0 d0 c0 b3 a3 93 83 b2 a2 92 82 b1 a1 91 81 b0 a0 90 80|
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+
+	// The first step
+	mov (16)	BUF_B(0,0)<1>			PREV_MB_YB(0,0)<16;4,1>
+	mov (16)	BUF_B(0,16)<1>			PREV_MB_YB(0,4)<16;4,1>
+	mov (16)	BUF_B(1,0)<1>			PREV_MB_YB(0,8)<16;4,1>
+	mov (16)	BUF_B(1,16)<1>			PREV_MB_YB(0,12)<16;4,1>
+
+//
+//  Second step		(16)	<1>	<=== <1;4,4>
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//	|73 72 71 70 63 62 61 60 53 52 51 50 43 42 41 40 33 32 31 30 23 22 21 20 13 12 11 10 03 02 01 00|
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//	|f3 f2 f1 f0 e3 e2 e1 e0 d3 d2 d1 d0 c3 c2 c1 c0 b3 b2 b1 b0 a3 a2 a1 a0 93 92 91 90 83 82 81 80|
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//
+	// The second step
+//	mov	(16)	MSGPAYLOADB(0,0)<1>		BUF_B(0,0)<32;8,4> 			// Read 2 rows, write 1 row
+//	mov (16)	MSGPAYLOADB(0,16)<1>	BUF_B(0,1)<32;8,4>
+//	mov (16)	MSGPAYLOADB(1,0)<1>		BUF_B(0,2)<32;8,4>
+//	mov (16)	MSGPAYLOADB(1,16)<1>	BUF_B(0,3)<32;8,4>
+
+	mov	(16)	MSGPAYLOADB(0,0)<1>		BUF_B(0,0)<1;4,4>
+	mov (16)	MSGPAYLOADB(0,16)<1>	BUF_B(0,16)<1;4,4>
+	mov (16)	MSGPAYLOADB(1,0)<1>		BUF_B(1,0)<1;4,4>
+	mov (16)	MSGPAYLOADB(1,16)<1>	BUF_B(1,16)<1;4,4>
+
+//  Transposed Y in 4x16 is ready for writting to dataport.
+//
+    send (8)	NULLREG	MSGHDR	MSGSRC<8;8,1>:ud	DAPWRITE	MSG_LEN(2)+DWBWMSGDSC+BI_DEST_Y				// Write 2 GRFs
+
+
+
+/////////////////////////////////////////////////////////////////////////////////////////////////////
+
+	// Transpose U/V, save them to MRFs in NV12 format
+    asr (1)	MSGSRC.1:ud		MSGSRC.1:ud			1:w						// NV12 U+V block origin y = half of Y comp
+    mov (1)	MSGSRC.2<1>:ud	0x00070003:ud								// NV12 U+V block width and height (4x8)
+
+
+//	16x2 UV src in GRF (each pix is specified as yx)
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//	|71 71 61 61 51 51 41 41 31 31 21 21 11 11 01 01 70 70 60 60 50 50 40 40 30 30 20 20 10 10 00 00|
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//
+//	First step		(8)		<1>	<=== <8;4,1>:w
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//	|71 71 61 61 51 51 41 41 70 70 60 60 50 50 40 40 31 31 21 21 11 11 01 01 30 30 20 20 10 10 00 00|
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+	mov (8)	BUF_W(0,0)<1>		PREV_MB_UW(0,0)<8;4,1>
+	mov (8)	BUF_W(0,8)<1>		PREV_MB_UW(0,4)<8;4,1>
+
+//	Second step		(8)		<1>	<=== <1;2,4>
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//	|71 71 70 70 61 61 60 60 51 51 50 50 41 41 40 40 31 31 30 30 21 21 20 20 11 11 10 10 01 01 00 00|
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+	mov (8)	MSGPAYLOADW(0,0)<1>		BUF_W(0,0)<1;2,4>
+	mov (8)	MSGPAYLOADW(0,8)<1>		BUF_W(0,8)<1;2,4>
+
+//  Transposed U+V in NV12 in 4x8 is ready for writting to dataport.
+ 
+    send (8)	NULLREG	MSGHDR	MSGSRC<8;8,1>:ud	DAPWRITE	MSG_LEN(1)+DWBWMSGDSC+BI_DEST_UV		// Write 1 GRF
+    
+
diff --git a/i965_drv_video/shaders/h264/ildb/save_Cur_UV_8x8.asm b/i965_drv_video/shaders/h264/ildb/save_Cur_UV_8x8.asm
new file mode 100644
index 0000000..39d4b09
--- /dev/null
+++ b/i965_drv_video/shaders/h264/ildb/save_Cur_UV_8x8.asm
@@ -0,0 +1,53 @@
+/*
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+// Module name: save_Cur_UV_8x8.asm
+//
+// Save UV 8x8 block (8x8U + 8x8V in NV12)
+//
+//----------------------------------------------------------------
+//  Symbols need to be defined before including this module
+//
+//	Source region in :ud
+//	SRC_UD:			SRC_UD Base=rxx ElementSize=4 SrcRegion=REGION(8,1) Type=ud			// 4 GRF
+//
+//	Binding table index: 
+//	BI_DEST_UV:		Binding table index of UV surface (NV12)
+//
+//----------------------------------------------------------------
+
+#if defined(_DEBUG) 
+	mov		(1)		EntrySignatureC:w			0xDDD4:w
+#endif
+
+#if defined(_FIELD)
+    and.nz.f0.1 (1) NULLREGW 	BitFields:w  	BotFieldFlag:w			// Get bottom field flag
+#endif
+
+    mov (1)	MSGSRC.0:ud		ORIX_CUR:w					{ NoDDClr } 	// Block origin
+    asr (1)	MSGSRC.1:ud		ORIY_CUR:w			1:w		{ NoDDClr, NoDDChk }	// NV12 U+V block origin y = half of Y comp
+    mov (1)	MSGSRC.2:ud		0x0007000F:ud				{ NoDDChk }		// NV12 U+V block width and height (16x8)
+
+	mov (16)	MSGPAYLOADD(0)<1>		SRC_UD(0)		// Compressed inst
+	mov (16)	MSGPAYLOADD(2)<1>		SRC_UD(2)
+	
+#if defined(_PROGRESSIVE) 
+	mov (1)		MSGDSC	MSG_LEN(4)+DWBWMSGDSC+BI_DEST_UV:ud
+//    send (8)	NULLREG		MSGHDR		MSGSRC<8;8,1>:ud	DWBWMSGDSC+0x00400000+BI_DEST_UV
+#endif
+
+#if defined(_FIELD)
+	// Field picture
+    (f0.1) mov (1)	MSGDSC	MSG_LEN(4)+DWBWMSGDSC+ENMSGDSCBF+BI_DEST_UV:ud  // Write 4 GRFs to DEST_UV bottom field
+    (-f0.1) mov (1)	MSGDSC	MSG_LEN(4)+DWBWMSGDSC+ENMSGDSCTF+BI_DEST_UV:ud  // Write 4 GRFs to DEST_UV top field
+
+#endif
+
+    send (8)	null:ud		MSGHDR		MSGSRC<8;8,1>:ud	DAPWRITE	MSGDSC
+
+// End of save_Cur_UV_8x8.asm
diff --git a/i965_drv_video/shaders/h264/ildb/save_Cur_UV_8x8_Mbaff.asm b/i965_drv_video/shaders/h264/ildb/save_Cur_UV_8x8_Mbaff.asm
new file mode 100644
index 0000000..6f469ea
--- /dev/null
+++ b/i965_drv_video/shaders/h264/ildb/save_Cur_UV_8x8_Mbaff.asm
@@ -0,0 +1,62 @@
+/*
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+// Module name: save_Cur_UV_8x8.asm
+//
+// Save UV 8x8 block (8x8U + 8x8V in NV12)
+//
+//----------------------------------------------------------------
+//  Symbols need to be defined before including this module
+//
+//	Source region in :ud
+//	SRC_UD:			SRC_UD Base=rxx ElementSize=4 SrcRegion=REGION(8,1) Type=ud			// 4 GRF
+//
+//	Binding table index: 
+//	BI_DEST_UV:		Binding table index of UV surface (NV12)
+//
+//----------------------------------------------------------------
+
+#if defined(_DEBUG) 
+	mov		(1)		EntrySignatureC:w			0xDDD4:w
+#endif
+
+	and.z.f0.0 (1) 	null:w		r[ECM_AddrReg, BitFlags]:ub		FieldModeCurrentMbFlag:w		
+
+    and.nz.f0.1 (1)	NULLREGW 	BitFields:w  	BotFieldFlag:w
+
+    mov (1)	MSGSRC.0:ud		ORIX_CUR:w					{ NoDDClr } 	// Block origin
+    asr (1)	MSGSRC.1:ud		ORIY_CUR:w			1:w		{ NoDDClr, NoDDChk }	// NV12 U+V block origin y = half of Y comp
+    mov (1)	MSGSRC.2:ud		0x0007000F:ud				{ NoDDChk }		// NV12 U+V block width and height (16x8)
+
+	mov (16)	MSGPAYLOADD(0)<1>		SRC_UD(0)		// Compressed inst
+	mov (16)	MSGPAYLOADD(2)<1>		SRC_UD(2)
+
+    // Set message descriptor
+    
+	(f0.0)	if	(1)		ELSE_UV_8X8
+    
+    // Frame picture
+    mov (1)	MSGDSC	MSG_LEN(4)+DWBWMSGDSC+BI_DEST_UV:ud			// Write 4 GRFs to DEST_UV
+
+	(f0.1) add (1)	MSGSRC.1:d	MSGSRC.1:d		8:w		// Add vertical offset 8 for bot MB in MBAFF mode
+
+ELSE_UV_8X8: 
+	else 	(1)		ENDIF_UV_8X8
+
+	// Field picture
+    (f0.1) mov (1)	MSGDSC	MSG_LEN(4)+DWBWMSGDSC+ENMSGDSCBF+BI_DEST_UV:ud  // Write 4 GRFs to DEST_UV bottom field
+    (-f0.1) mov (1)	MSGDSC	MSG_LEN(4)+DWBWMSGDSC+ENMSGDSCTF+BI_DEST_UV:ud  // Write 4 GRFs to DEST_UV top field
+
+	asr (1)	MSGSRC.1:d		MSGSRC.1:d		1:w					// Reduce y by half in field access mode
+
+	endif
+ENDIF_UV_8X8:
+    
+    send (8)	null:ud		MSGHDR		MSGSRC<8;8,1>:ud	DAPWRITE	MSGDSC
+
+// End of save_Cur_UV_8x8.asm
diff --git a/i965_drv_video/shaders/h264/ildb/save_Cur_Y_16x16.asm b/i965_drv_video/shaders/h264/ildb/save_Cur_Y_16x16.asm
new file mode 100644
index 0000000..fac22cd
--- /dev/null
+++ b/i965_drv_video/shaders/h264/ildb/save_Cur_Y_16x16.asm
@@ -0,0 +1,56 @@
+/*
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+// Module name: save_Cur_Y_16x16.asm
+//
+// Save a Y 16x16 block 
+//
+//----------------------------------------------------------------
+//  Symbols need to be defined before including this module
+//
+//	Source region in :ud
+//	SRC_YD:			SRC_YD Base=rxx ElementSize=4 SrcRegion=REGION(8,1) Type=ud			// 8 GRFs
+//
+//	Binding table index: 
+//	BI_DEST_Y:		Binding table index of Y surface
+//
+//----------------------------------------------------------------
+
+#if defined(_DEBUG) 
+	mov		(1)		EntrySignatureC:w			0xDDD4:w
+#endif
+
+#if defined(_FIELD)
+    and.nz.f0.1 (1) NULLREGW 	BitFields:w  	BotFieldFlag:w			// Get bottom field flag
+#endif
+
+    mov (2)	MSGSRC.0<1>:ud	ORIX_CUR<2;2,1>:w	{ NoDDClr }		// Block origin
+    mov (1)	MSGSRC.2<1>:ud	0x000F000F:ud		{ NoDDChk }		// Block width and height (16x16)
+
+	// Pack Y    
+	mov	(16)	MSGPAYLOADD(0)<1>		SRC_YD(0)		// Compressed inst
+	mov (16)	MSGPAYLOADD(2)<1>		SRC_YD(2)
+	mov (16)	MSGPAYLOADD(4)<1>		SRC_YD(4)
+	mov (16)	MSGPAYLOADD(6)<1>		SRC_YD(6)
+    
+
+#if defined(_PROGRESSIVE) 
+	mov (1)	MSGDSC	MSG_LEN(8)+DWBWMSGDSC+BI_DEST_Y:ud	
+//    send (8)	NULLREG		MSGHDR		MSGSRC<8;8,1>:ud	DWBWMSGDSC+0x00800000+BI_DEST_Y
+#endif
+
+#if defined(_FIELD)
+	// Field picture
+    (f0.1) mov (1)	MSGDSC	MSG_LEN(8)+DWBWMSGDSC+ENMSGDSCBF+BI_DEST_Y:ud  // Write 8 GRFs to DEST_Y bottom field
+    (-f0.1) mov (1)	MSGDSC	MSG_LEN(8)+DWBWMSGDSC+ENMSGDSCTF+BI_DEST_Y:ud  // Write 8 GRFs to DEST_Y top field
+
+#endif
+
+    send (8)	null:ud		MSGHDR		MSGSRC<8;8,1>:ud	DAPWRITE	MSGDSC
+    	
+// End of save_Cur_Y_16x16.asm
diff --git a/i965_drv_video/shaders/h264/ildb/save_Cur_Y_16x16_Mbaff.asm b/i965_drv_video/shaders/h264/ildb/save_Cur_Y_16x16_Mbaff.asm
new file mode 100644
index 0000000..6ab78dc
--- /dev/null
+++ b/i965_drv_video/shaders/h264/ildb/save_Cur_Y_16x16_Mbaff.asm
@@ -0,0 +1,64 @@
+/*
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+// Module name: save_Cur_Y_16x16.asm
+//
+// Save a Y 16x16 block 
+//
+//----------------------------------------------------------------
+//  Symbols need to be defined before including this module
+//
+//	Source region in :ud
+//	SRC_YD:			SRC_YD Base=rxx ElementSize=4 SrcRegion=REGION(8,1) Type=ud			// 8 GRFs
+//
+//	Binding table index: 
+//	BI_DEST_Y:		Binding table index of Y surface
+//
+//----------------------------------------------------------------
+
+#if defined(_DEBUG) 
+	mov		(1)		EntrySignatureC:w			0xDDD4:w
+#endif
+
+	and.z.f0.0 (1) 	null:w		r[ECM_AddrReg, BitFlags]:ub		FieldModeCurrentMbFlag:w		
+
+    and.nz.f0.1 (1)	NULLREGW 		BitFields:w  	BotFieldFlag:w
+
+    mov (2)	MSGSRC.0<1>:ud	ORIX_CUR<2;2,1>:w		{ NoDDClr }		// Block origin
+    mov (1)	MSGSRC.2<1>:ud	0x000F000F:ud			{ NoDDChk }		// Block width and height (16x16 or 12x16)
+
+	// Pack Y    
+	mov	(16)	MSGPAYLOADD(0)<1>		SRC_YD(0)		// Compressed inst
+	mov (16)	MSGPAYLOADD(2)<1>		SRC_YD(2)
+	mov (16)	MSGPAYLOADD(4)<1>		SRC_YD(4)
+	mov (16)	MSGPAYLOADD(6)<1>		SRC_YD(6)
+    
+    // Set message descriptor
+
+	(f0.0)	if	(1)		ELSE_Y_16x16
+    
+    // Frame picture
+    mov (1)	MSGDSC	MSG_LEN(8)+DWBWMSGDSC+BI_DEST_Y:ud			// Write 8 GRFs to DEST_Y
+
+	(f0.1) add (1)	MSGSRC.1:d		MSGSRC.1:d		16:w		// Add vertical offset 16 for bot MB in MBAFF mode
+
+ELSE_Y_16x16: 
+	else 	(1)		ENDIF_Y_16x16
+
+	// Field picture
+    (f0.1) mov (1)	MSGDSC	MSG_LEN(8)+DWBWMSGDSC+ENMSGDSCBF+BI_DEST_Y:ud  // Write 8 GRFs to DEST_Y bottom field
+    (-f0.1) mov (1)	MSGDSC	MSG_LEN(8)+DWBWMSGDSC+ENMSGDSCTF+BI_DEST_Y:ud  // Write 8 GRFs to DEST_Y top field
+
+	asr (1)	MSGSRC.1:d		MSGSRC.1:d		1:w					// Reduce y by half in field access mode
+
+	endif
+ENDIF_Y_16x16:
+    
+    send (8)	null:ud		MSGHDR		MSGSRC<8;8,1>:ud	DAPWRITE	MSGDSC
+
+// End of save_Cur_Y_16x16.asm
diff --git a/i965_drv_video/shaders/h264/ildb/save_Left_UV_8x2T.asm b/i965_drv_video/shaders/h264/ildb/save_Left_UV_8x2T.asm
new file mode 100644
index 0000000..172002e
--- /dev/null
+++ b/i965_drv_video/shaders/h264/ildb/save_Left_UV_8x2T.asm
@@ -0,0 +1,72 @@
+/*
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+// Module name: save_Left_UV_8x2T.asm
+//
+// Transpose 8x2 to 2x8 UV data and write to memory 
+//
+//----------------------------------------------------------------
+//  Symbols need to be defined before including this module
+//
+//	Left MB region:
+//	PREV_MB_UW: 	Base=ryy 	ElementSize=2 SrcRegion=REGION(8,1) Type=uw
+
+//	Binding table index: 
+//	BI_SRC_UV:		Binding table index of UV surface (NV12)
+//
+//	Temp buffer:
+//	BUF_W:			BUF_W Base=rxx ElementSize=1 SrcRegion=REGION(8,1) Type=uw
+//
+//
+#if defined(_DEBUG) 
+	mov		(1)		EntrySignatureC:w			0xDDD6:w
+#endif
+
+#if defined(_FIELD)
+    and.nz.f0.1 (1)  NULLREGW 	BitFields:w  	BotFieldFlag:w			// Get bottom field flag
+#endif
+
+	// Transpose U/V, save them to MRFs in NV12 format
+    mov (1)	MSGSRC.0:ud		ORIX_LEFT:w						{ NoDDClr }			// Block origin
+    asr (1)	MSGSRC.1:ud		ORIY_LEFT:w			1:w			{ NoDDClr, NoDDChk }	// NV12 U+V block origin y = half of Y comp
+    mov (1)	MSGSRC.2:ud		0x00070003:ud					{ NoDDChk }			// NV12 U+V block width and height (4x8)
+
+
+//	16x2 UV src in GRF (each pix is specified as yx)
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//	|71 71 61 61 51 51 41 41 31 31 21 21 11 11 01 01 70 70 60 60 50 50 40 40 30 30 20 20 10 10 00 00|
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//
+//	First step		(8)		<1>	<=== <8;4,1>:w
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//	|71 71 61 61 51 51 41 41 70 70 60 60 50 50 40 40 31 31 21 21 11 11 01 01 30 30 20 20 10 10 00 00|
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+	mov (8)	LEFT_TEMP_W(0,0)<1>		PREV_MB_UW(0,0)<8;4,1>		{ NoDDClr }
+	mov (8)	LEFT_TEMP_W(0,8)<1>		PREV_MB_UW(0,4)<8;4,1>		{ NoDDChk }
+
+//	Second step		(8)		<1>	<=== <1;2,4>
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//	|71 71 70 70 61 61 60 60 51 51 50 50 41 41 40 40 31 31 30 30 21 21 20 20 11 11 10 10 01 01 00 00|
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+	mov (8)	MSGPAYLOADW(0,0)<1>		LEFT_TEMP_W(0,0)<1;2,4>
+	mov (8)	MSGPAYLOADW(0,8)<1>		LEFT_TEMP_W(0,8)<1;2,4>
+
+//  Transposed U+V in NV12 in 4x8 is ready for writting to dataport.
+ 
+#if defined(_PROGRESSIVE) 
+	mov (1)	MSGDSC	MSG_LEN(1)+DWBWMSGDSC+BI_DEST_UV:ud
+//    send (8)	NULLREG		MSGHDR		MSGSRC<8;8,1>:ud	DWBWMSGDSC+0x00100000+BI_DEST_UV
+#endif
+
+#if defined(_FIELD)
+	// Field picture
+    (f0.1) mov (1)	MSGDSC	MSG_LEN(1)+DWBWMSGDSC+ENMSGDSCBF+BI_DEST_UV:ud  // Write 1 GRF to DEST_UV bottom field
+    (-f0.1) mov (1)	MSGDSC	MSG_LEN(1)+DWBWMSGDSC+ENMSGDSCTF+BI_DEST_UV:ud  // Write 1 GRF to DEST_UV top field
+
+#endif
+    send (8)	null:ud		MSGHDR		MSGSRC<8;8,1>:ud	DAPWRITE	MSGDSC
diff --git a/i965_drv_video/shaders/h264/ildb/save_Left_UV_8x2T_Mbaff.asm b/i965_drv_video/shaders/h264/ildb/save_Left_UV_8x2T_Mbaff.asm
new file mode 100644
index 0000000..f98b311
--- /dev/null
+++ b/i965_drv_video/shaders/h264/ildb/save_Left_UV_8x2T_Mbaff.asm
@@ -0,0 +1,82 @@
+/*
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+// Module name: save_Left_UV_8x2T.asm
+//
+// Transpose 8x2 to 2x8 UV data and write to memory 
+//
+//----------------------------------------------------------------
+//  Symbols need to be defined before including this module
+//
+//	Left MB region:
+//	PREV_MB_UW: 	Base=ryy 	ElementSize=2 SrcRegion=REGION(8,1) Type=uw
+
+//	Binding table index: 
+//	BI_SRC_UV:		Binding table index of UV surface (NV12)
+//
+//	Temp buffer:
+//	BUF_W:			BUF_W Base=rxx ElementSize=1 SrcRegion=REGION(8,1) Type=uw
+//
+//
+#if defined(_DEBUG) 
+	mov		(1)		EntrySignatureC:w			0xDDD6:w
+#endif
+
+	and.z.f0.0 (1) 	null:w		r[ECM_AddrReg, BitFlags]:ub		FieldModeCurrentMbFlag:w		
+   
+    and.nz.f0.1 (1)	NULLREGW 		BitFields:w  	BotFieldFlag:w
+
+	// Transpose U/V, save them to MRFs in NV12 format
+    mov (1)	MSGSRC.0:ud		ORIX_LEFT:w					{ NoDDClr } 			// Block origin
+    asr (1)	MSGSRC.1:ud		ORIY_LEFT:w			1:w		{ NoDDClr, NoDDChk }	// NV12 U+V block origin y = half of Y comp
+    mov (1)	MSGSRC.2:ud		0x00070003:ud				{ NoDDChk }				// NV12 U+V block width and height (4x8)
+
+
+//	16x2 UV src in GRF (each pix is specified as yx)
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//	|71 71 61 61 51 51 41 41 31 31 21 21 11 11 01 01 70 70 60 60 50 50 40 40 30 30 20 20 10 10 00 00|
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//
+//	First step		(8)		<1>	<=== <8;4,1>:w
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//	|71 71 61 61 51 51 41 41 70 70 60 60 50 50 40 40 31 31 21 21 11 11 01 01 30 30 20 20 10 10 00 00|
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+	mov (8)	BUF_W(0,0)<1>		PREV_MB_UW(0,0)<8;4,1>	{ NoDDClr }
+	mov (8)	BUF_W(0,8)<1>		PREV_MB_UW(0,4)<8;4,1>	{ NoDDChk }
+
+//	Second step		(8)		<1>	<=== <1;2,4>
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//	|71 71 70 70 61 61 60 60 51 51 50 50 41 41 40 40 31 31 30 30 21 21 20 20 11 11 10 10 01 01 00 00|
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+	mov (8)	MSGPAYLOADW(0,0)<1>		BUF_W(0,0)<1;2,4>
+	mov (8)	MSGPAYLOADW(0,8)<1>		BUF_W(0,8)<1;2,4>
+
+//  Transposed U+V in NV12 in 4x8 is ready for writting to dataport.
+ 
+    // Set message descriptor
+    
+	(f0.0)	if	(1)		ELSE_UV_8X2T
+    
+    // Frame picture
+    mov (1)	MSGDSC	MSG_LEN(1)+DWBWMSGDSC+BI_DEST_UV:ud			// Write 1 GRF to DEST_UV
+
+	(f0.1) add (1)	MSGSRC.1:d		MSGSRC.1:d		8:w		// Add vertical offset 8 for bot MB in MBAFF mode
+
+ELSE_UV_8X2T: 
+	else 	(1)		ENDIF_UV_8X2T
+
+	// Field picture
+    (f0.1) mov (1)	MSGDSC	MSG_LEN(1)+DWBWMSGDSC+ENMSGDSCBF+BI_DEST_UV:ud  // Write 1 GRF to DEST_UV bottom field
+    (-f0.1) mov (1)	MSGDSC	MSG_LEN(1)+DWBWMSGDSC+ENMSGDSCTF+BI_DEST_UV:ud  // Write 1 GRF to DEST_UV top field
+
+	asr (1)	MSGSRC.1:d		MSGSRC.1:d		1:w					// Reduce y by half in field access mode
+
+	endif
+ENDIF_UV_8X2T:
+
+    send (8)	null:ud		MSGHDR	MSGSRC<8;8,1>:ud	DAPWRITE	MSGDSC
diff --git a/i965_drv_video/shaders/h264/ildb/save_Left_Y_16x4T.asm b/i965_drv_video/shaders/h264/ildb/save_Left_Y_16x4T.asm
new file mode 100644
index 0000000..84d81e9
--- /dev/null
+++ b/i965_drv_video/shaders/h264/ildb/save_Left_Y_16x4T.asm
@@ -0,0 +1,89 @@
+/*
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+// Module name: save_Left_Y_16x4T.asm
+//
+// Transpose 16x4 to 4x16 Y data and write to memory 
+//
+//----------------------------------------------------------------
+//  Symbols need to be defined before including this module
+//
+//	Left MB region:
+//	PREV_MB_YB:	  	Base=rxx 	ElementSize=1 SrcRegion=REGION(16,1) Type=ub
+
+//	Binding table index: 
+//	BI_SRC_Y:		Binding table index of Y surface
+//
+//	Temp buffer:
+//	BUF_B:			BUF_B Base=rxx ElementSize=1 SrcRegion=REGION(16,1) Type=ub
+//
+//
+#if defined(_DEBUG) 
+	mov		(1)		EntrySignatureC:w			0xDDD6:w
+#endif
+
+#if defined(_FIELD)
+    and.nz.f0.1 (1) NULLREGW 	BitFields:w  	BotFieldFlag:w			// Get bottom field flag
+#endif
+
+    mov (2)	MSGSRC.0<1>:ud	ORIX_LEFT<2;2,1>:w		{ NoDDClr }		// Block origin
+    mov (1)	MSGSRC.2<1>:ud	0x000F0003:ud			{ NoDDChk }		// 4x16
+    
+// Transpose Y, save them to MRFs
+
+//	16x4 Y src in GRF (each pix is specified as yx)
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//	|f1 e1 d1 c1 b1 a1 91 81 71 61 51 41 31 21 11 01 f0 e0 d0 c0 b0 a0 90 80 70 60 50 40 30 20 10 00|
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//	|f3 e3 d3 c3 b3 a3 93 83 73 63 53 43 33 23 13 03 f2 e2 d2 c2 b2 a2 92 82 72 62 52 42 32 22 12 02|
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//
+//  First step		(16)	<1>	<=== <16;4,1>
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//	|73 63 53 43 72 62 52 42 71 61 51 41 70 60 50 40 33 23 13 03 32 22 12 02 31 21 11 01 30 20 10 00|
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//	|f3 e3 d3 c3 f2 e2 d2 c2 f1 e1 d1 c1 f0 e0 d0 c0 b3 a3 93 83 b2 a2 92 82 b1 a1 91 81 b0 a0 90 80|
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+
+	// The first step
+	mov (16)	LEFT_TEMP_B(0,0)<1>			PREV_MB_YB(0,0)<16;4,1>		{ NoDDClr }	
+	mov (16)	LEFT_TEMP_B(0,16)<1>		PREV_MB_YB(0,4)<16;4,1>		{ NoDDChk }
+	mov (16)	LEFT_TEMP_B(1,0)<1>			PREV_MB_YB(0,8)<16;4,1>		{ NoDDClr }
+	mov (16)	LEFT_TEMP_B(1,16)<1>		PREV_MB_YB(0,12)<16;4,1>	{ NoDDChk }
+
+//
+//  Second step		(16)	<1>	<=== <1;4,4>
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//	|73 72 71 70 63 62 61 60 53 52 51 50 43 42 41 40 33 32 31 30 23 22 21 20 13 12 11 10 03 02 01 00|
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//	|f3 f2 f1 f0 e3 e2 e1 e0 d3 d2 d1 d0 c3 c2 c1 c0 b3 b2 b1 b0 a3 a2 a1 a0 93 92 91 90 83 82 81 80|
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//
+	// The second step
+	mov	(16)	MSGPAYLOADB(0,0)<1>		LEFT_TEMP_B(0,0)<1;4,4>
+	mov (16)	MSGPAYLOADB(0,16)<1>	LEFT_TEMP_B(0,16)<1;4,4>
+	mov (16)	MSGPAYLOADB(1,0)<1>		LEFT_TEMP_B(1,0)<1;4,4>
+	mov (16)	MSGPAYLOADB(1,16)<1>	LEFT_TEMP_B(1,16)<1;4,4>
+
+//  Transposed Y in 4x16 is ready for writting to dataport.
+
+
+#if defined(_PROGRESSIVE) 
+	mov (1)	MSGDSC	MSG_LEN(2)+DWBWMSGDSC+BI_DEST_Y:ud
+//    send (8)	NULLREG		MSGHDR		MSGSRC<8;8,1>:ud	DWBWMSGDSC+0x00200000+BI_DEST_Y
+#endif
+
+#if defined(_FIELD)
+	// Field picture
+    (f0.1) mov (1)	MSGDSC	MSG_LEN(2)+DWBWMSGDSC+ENMSGDSCBF+BI_DEST_Y:ud  // Write 2 GRFs to DEST_Y bottom field
+    (-f0.1) mov (1)	MSGDSC	MSG_LEN(2)+DWBWMSGDSC+ENMSGDSCTF+BI_DEST_Y:ud  // Write 2 GRFs to DEST_Y top field
+
+#endif
+
+    send (8)	null:ud		MSGHDR		MSGSRC<8;8,1>:ud	DAPWRITE	MSGDSC
+
diff --git a/i965_drv_video/shaders/h264/ildb/save_Left_Y_16x4T_Mbaff.asm b/i965_drv_video/shaders/h264/ildb/save_Left_Y_16x4T_Mbaff.asm
new file mode 100644
index 0000000..977ad4f
--- /dev/null
+++ b/i965_drv_video/shaders/h264/ildb/save_Left_Y_16x4T_Mbaff.asm
@@ -0,0 +1,101 @@
+/*
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+// Module name: save_Left_Y_16x4T.asm
+//
+// Transpose 16x4 to 4x16 Y data and write to memory 
+//
+//----------------------------------------------------------------
+//  Symbols need to be defined before including this module
+//
+//	Left MB region:
+//	PREV_MB_YB:	  	Base=rxx 	ElementSize=1 SrcRegion=REGION(16,1) Type=ub
+
+//	Binding table index: 
+//	BI_SRC_Y:		Binding table index of Y surface
+//
+//	Temp buffer:
+//	BUF_B:			BUF_B Base=rxx ElementSize=1 SrcRegion=REGION(16,1) Type=ub
+//
+//
+#if defined(_DEBUG) 
+	mov		(1)		EntrySignatureC:w			0xDDD6:w
+#endif
+
+	and.z.f0.0 (1) 	null:w		r[ECM_AddrReg, BitFlags]:ub		FieldModeCurrentMbFlag:w		
+
+    and.nz.f0.1 (1)	NULLREGW 		BitFields:w  	BotFieldFlag:w
+
+    mov (2)	MSGSRC.0<1>:ud	ORIX_LEFT<2;2,1>:w		{ NoDDClr }		// Block origin
+    mov (1)	MSGSRC.2<1>:ud	0x000F0003:ud			{ NoDDChk }		// 4x16
+    
+// Transpose Y, save them to MRFs
+
+//	16x4 Y src in GRF (each pix is specified as yx)
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//	|f1 e1 d1 c1 b1 a1 91 81 71 61 51 41 31 21 11 01 f0 e0 d0 c0 b0 a0 90 80 70 60 50 40 30 20 10 00|
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//	|f3 e3 d3 c3 b3 a3 93 83 73 63 53 43 33 23 13 03 f2 e2 d2 c2 b2 a2 92 82 72 62 52 42 32 22 12 02|
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//
+//  First step		(16)	<1>	<=== <16;4,1>
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//	|73 63 53 43 72 62 52 42 71 61 51 41 70 60 50 40 33 23 13 03 32 22 12 02 31 21 11 01 30 20 10 00|
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//	|f3 e3 d3 c3 f2 e2 d2 c2 f1 e1 d1 c1 f0 e0 d0 c0 b3 a3 93 83 b2 a2 92 82 b1 a1 91 81 b0 a0 90 80|
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+
+	// The first step
+	mov (16)	BUF_B(0,0)<1>			PREV_MB_YB(0,0)<16;4,1>		{ NoDDClr }
+	mov (16)	BUF_B(0,16)<1>			PREV_MB_YB(0,4)<16;4,1>		{ NoDDChk }
+	mov (16)	BUF_B(1,0)<1>			PREV_MB_YB(0,8)<16;4,1>		{ NoDDClr }
+	mov (16)	BUF_B(1,16)<1>			PREV_MB_YB(0,12)<16;4,1>	{ NoDDChk }	
+
+//
+//  Second step		(16)	<1>	<=== <1;4,4>
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//	|73 72 71 70 63 62 61 60 53 52 51 50 43 42 41 40 33 32 31 30 23 22 21 20 13 12 11 10 03 02 01 00|
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//	|f3 f2 f1 f0 e3 e2 e1 e0 d3 d2 d1 d0 c3 c2 c1 c0 b3 b2 b1 b0 a3 a2 a1 a0 93 92 91 90 83 82 81 80|
+//	+-----------------------+-----------------------+-----------------------+-----------------------+
+//
+	// The second step
+	mov	(16)	MSGPAYLOADB(0,0)<1>		BUF_B(0,0)<1;4,4>
+	mov (16)	MSGPAYLOADB(0,16)<1>	BUF_B(0,16)<1;4,4>
+	mov (16)	MSGPAYLOADB(1,0)<1>		BUF_B(1,0)<1;4,4>
+	mov (16)	MSGPAYLOADB(1,16)<1>	BUF_B(1,16)<1;4,4>
+
+//  Transposed Y in 4x16 is ready for writting to dataport.
+
+	//***** Left MB is loaded the same as indicated by FieldModeCurrentMbFlag.
+
+    // Set message descriptor
+ 
+	(f0.0)	if	(1)		ELSE_Y_16x4T
+    
+    // Frame picture
+    mov (1)	MSGDSC	MSG_LEN(2)+DWBWMSGDSC+BI_DEST_Y:ud			// Write 2 GRFs to DEST_Y
+
+	(f0.1) add (1)	MSGSRC.1:d		MSGSRC.1:d		16:w		// Add vertical offset 16 for bot MB in MBAFF mode
+
+ELSE_Y_16x4T: 
+	else 	(1)		ENDIF_Y_16x4T
+
+	// Field picture
+    (f0.1) mov (1)	MSGDSC	MSG_LEN(2)+DWBWMSGDSC+ENMSGDSCBF+BI_DEST_Y:ud  // Write 2 GRFs to DEST_Y bottom field
+    (-f0.1) mov (1)	MSGDSC	MSG_LEN(2)+DWBWMSGDSC+ENMSGDSCTF+BI_DEST_Y:ud  // Write 2 GRFs to DEST_Y top field
+
+	asr (1)	MSGSRC.1:d		MSGSRC.1:d		1:w					// Reduce y by half in field access mode
+
+	endif
+ENDIF_Y_16x4T:
+
+    send (8)	null:ud		MSGHDR	MSGSRC<8;8,1>:ud	DAPWRITE	MSGDSC
+
+
+
diff --git a/i965_drv_video/shaders/h264/ildb/save_Top_UV_8x2.asm b/i965_drv_video/shaders/h264/ildb/save_Top_UV_8x2.asm
new file mode 100644
index 0000000..5263c35
--- /dev/null
+++ b/i965_drv_video/shaders/h264/ildb/save_Top_UV_8x2.asm
@@ -0,0 +1,52 @@
+/*
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+// Module name: save_Top_UV_8x2.asm
+//
+// Save UV 8x2 block (8x2U + 8x2V in NV12)
+//
+//----------------------------------------------------------------
+//  Symbols need to be defined before including this module
+//
+//	Source region in :ud
+//	SRC_UD:			SRC_UD Base=rxx ElementSize=4 SrcRegion=REGION(8,1) Type=ud			// 1 GRF
+//
+//	Binding table index: 
+//	BI_DEST_UV:		Binding table index of UV surface (NV12)
+//
+//----------------------------------------------------------------
+
+#if defined(_DEBUG) 
+	mov		(1)		EntrySignatureC:w			0xDDD5:w
+#endif
+	
+#if defined(_FIELD)
+    and.nz.f0.1 (1) NULLREGW 	BitFields:w  	BotFieldFlag:w			// Get bottom field flag
+#endif
+
+    mov (1)	MSGSRC.0:ud		ORIX_TOP:w					{ NoDDClr }				// Block origin
+    asr (1)	MSGSRC.1:ud		ORIY_TOP:w			1:w		{ NoDDClr, NoDDChk }	// NV12 U+V block origin y = half of Y comp
+    mov (1)	MSGSRC.2:ud		0x0001000F:ud				{ NoDDChk }				// NV12 U+V block width and height (16x2)
+
+	mov (8)	MSGPAYLOADD(0,0)<1>		TOP_MB_UD(0)	
+	
+
+#if defined(_PROGRESSIVE) 
+	mov (1)	MSGDSC	MSG_LEN(1)+DWBWMSGDSC_WC+BI_DEST_UV:ud
+//    send (8)	NULLREG		MSGHDR		MSGSRC<8;8,1>:ud	DWBWMSGDSC+0x00100000+BI_DEST_UV
+#endif
+
+#if defined(_FIELD)
+	// Field picture
+    (f0.1) mov (1)	MSGDSC	MSG_LEN(1)+DWBWMSGDSC_WC+ENMSGDSCBF+BI_DEST_UV:ud  // Write 1 GRF to DEST_Y bottom field
+    (-f0.1) mov (1)	MSGDSC	MSG_LEN(1)+DWBWMSGDSC_WC+ENMSGDSCTF+BI_DEST_UV:ud  // Write 1 GRF to DEST_Y top field
+
+#endif
+
+    send (8)	WritebackResponse(0)<1>		MSGHDR	MSGSRC<8;8,1>:ud	DAPWRITE	MSGDSC
+// End of save_Top_UV_8x2.asm
diff --git a/i965_drv_video/shaders/h264/ildb/save_Top_UV_8x2_Mbaff.asm b/i965_drv_video/shaders/h264/ildb/save_Top_UV_8x2_Mbaff.asm
new file mode 100644
index 0000000..ef2ba84
--- /dev/null
+++ b/i965_drv_video/shaders/h264/ildb/save_Top_UV_8x2_Mbaff.asm
@@ -0,0 +1,69 @@
+/*
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+// Module name: save_Top_UV_8x2.asm
+//
+// Save UV 8x2 block (8x2U + 8x2V in NV12)
+//
+//----------------------------------------------------------------
+//  Symbols need to be defined before including this module
+//
+//	Source region in :ud
+//	SRC_UD:			SRC_UD Base=rxx ElementSize=4 SrcRegion=REGION(8,1) Type=ud			// 1 GRF
+//
+//	Binding table index: 
+//	BI_DEST_UV:		Binding table index of UV surface (NV12)
+//
+//----------------------------------------------------------------
+
+#if defined(_DEBUG) 
+	mov		(1)		EntrySignatureC:w			0xDDD5:w
+#endif
+	and.z.f0.1 (8) NULLREGW		DualFieldMode<0;1,0>:w		1:w
+
+    // FieldModeCurrentMbFlag determines how to access above MB
+	and.z.f0.0 (1) 	null:w		r[ECM_AddrReg, BitFlags]:ub		FieldModeCurrentMbFlag:w		
+    
+	// Pack U and V
+    mov (1)	MSGSRC.0:ud		ORIX_TOP:w					{ NoDDClr } 			// Block origin
+    asr (1)	MSGSRC.1:ud		ORIY_TOP:w			1:w		{ NoDDClr, NoDDChk }	// NV12 U+V block origin y = half of Y comp
+    mov (1)	MSGSRC.2:ud		0x0001000F:ud				{ NoDDChk }				// NV12 U+V block width and height (16x2)
+
+	// Dual field mode
+	(f0.1) mov (8)	MSGPAYLOADD(0)<1>		PREV_MB_UD(0)
+    (-f0.1) mov (8) MSGPAYLOADD(0)<1>		PREV_MB_UD(1)	// for dual field mode, write last 2 rows
+	
+    // Set message descriptor
+
+    and.nz.f0.1 (1) NULLREGW 		BitFields:w   BotFieldFlag:w
+    
+	(f0.0)	if	(1)		ELSE_UV_8X2_SAVE
+
+    // Frame picture
+    mov (1)	MSGDSC	MSG_LEN(1)+DWBWMSGDSC_WC+BI_DEST_UV:ud			// Write 1 GRFs to DEST_UV
+
+	// Add vertical offset 8 for bot MB in MBAFF mode
+	(f0.1) add (1)	MSGSRC.1:d		MSGSRC.1:d		8:w		
+
+ELSE_UV_8X2_SAVE: 
+	else 	(1)		ENDIF_UV_8X2_SAVE
+
+	asr (1)	MSGSRC.1:d		ORIY_CUR:w		2:w			// asr 1: NV12 U+V block origin y = half of Y comp
+														// asr 1: Reduce y by half in field access mode
+	// Field picture
+    (f0.1) mov (1)	MSGDSC	MSG_LEN(1)+DWBWMSGDSC_WC+ENMSGDSCBF+BI_DEST_UV:ud  // Write 1 GRF to DEST_Y bottom field
+    (-f0.1) mov (1)	MSGDSC	MSG_LEN(1)+DWBWMSGDSC_WC+ENMSGDSCTF+BI_DEST_UV:ud  // Write 1 GRF to DEST_Y top field
+
+	add (1)	MSGSRC.1:d		MSGSRC.1:d		-2:w		// for last 4 rows of above MB
+
+	endif
+ENDIF_UV_8X2_SAVE:
+
+    send (8)	WritebackResponse(0)<1>		MSGHDR		MSGSRC<8;8,1>:ud	DAPWRITE	MSGDSC
+
+// End of save_Top_UV_8x2.asm
diff --git a/i965_drv_video/shaders/h264/ildb/save_Top_Y_16x4.asm b/i965_drv_video/shaders/h264/ildb/save_Top_Y_16x4.asm
new file mode 100644
index 0000000..8889087
--- /dev/null
+++ b/i965_drv_video/shaders/h264/ildb/save_Top_Y_16x4.asm
@@ -0,0 +1,52 @@
+/*
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+// Module name: save_Top_Y_16x4.asm
+//
+// Save a Y 16x4 block 
+//
+//----------------------------------------------------------------
+//  Symbols need to be defined before including this module
+//
+//	Source region in :ud
+//	SRC_YD:			SRC_YD Base=rxx ElementSize=4 SrcRegion=REGION(8,1) Type=ud			// 2 GRFs
+//
+//	Binding table index: 
+//	BI_DEST_Y:		Binding table index of Y surface
+//
+//----------------------------------------------------------------
+
+#if defined(_DEBUG) 
+	mov		(1)		EntrySignatureC:w			0xDDD5:w
+#endif
+
+#if defined(_FIELD)
+    and.nz.f0.1 (1) NULLREGW 	BitFields:w  	BotFieldFlag:w			// Get bottom field flag
+#endif
+
+    mov (2)	MSGSRC.0<1>:ud	ORIX_TOP<2;2,1>:w			{ NoDDClr }		// Block origin
+    mov (1)	MSGSRC.2<1>:ud	0x0003000F:ud				{ NoDDChk }		// Block width and height (16x4)
+
+	// Pack Y    
+	mov	(16)	MSGPAYLOADD(0)<1>		TOP_MB_YD(0)					// Compressed inst
+    
+
+#if defined(_PROGRESSIVE) 
+	mov (1)	MSGDSC	MSG_LEN(2)+DWBWMSGDSC_WC+BI_DEST_Y:ud
+//    send (8)	NULLREG		MSGHDR		MSGSRC<8;8,1>:ud	DWBWMSGDSC+0x00200000+BI_DEST_Y
+#endif
+
+#if defined(_FIELD)
+	// Field picture
+    (f0.1) mov (1)	MSGDSC	MSG_LEN(2)+DWBWMSGDSC_WC+ENMSGDSCBF+BI_DEST_Y:ud  // Write 2 GRFs to DEST_Y bottom field
+    (-f0.1) mov (1)	MSGDSC	MSG_LEN(2)+DWBWMSGDSC_WC+ENMSGDSCTF+BI_DEST_Y:ud  // Write 2 GRFs to DEST_Y top field
+
+#endif
+
+    send (8)	WritebackResponse(0)<1>		MSGHDR	MSGSRC<8;8,1>:ud	DAPWRITE	MSGDSC
+// End of save_Top_Y_16x4.asm
diff --git a/i965_drv_video/shaders/h264/ildb/save_Top_Y_16x4_Mbaff.asm b/i965_drv_video/shaders/h264/ildb/save_Top_Y_16x4_Mbaff.asm
new file mode 100644
index 0000000..d8bb9a7
--- /dev/null
+++ b/i965_drv_video/shaders/h264/ildb/save_Top_Y_16x4_Mbaff.asm
@@ -0,0 +1,69 @@
+/*
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+// Module name: save_Top_Y_16x4.asm
+//
+// Save a Y 16x4 block 
+//
+//----------------------------------------------------------------
+//  Symbols need to be defined before including this module
+//
+//	Source region in :ud
+//	SRC_YD:			SRC_YD Base=rxx ElementSize=4 SrcRegion=REGION(8,1) Type=ud			// 2 GRFs
+//
+//	Binding table index: 
+//	BI_DEST_Y:		Binding table index of Y surface
+//
+//----------------------------------------------------------------
+
+#if defined(_DEBUG) 
+	mov		(1)		EntrySignatureC:w			0xDDD5:w
+#endif
+
+	and.z.f0.1 (16) NULLREGW		DualFieldMode<0;1,0>:w		1:w
+
+    // FieldModeCurrentMbFlag determines how to access above MB
+	and.z.f0.0 (1) 	null:w		r[ECM_AddrReg, BitFlags]:ub		FieldModeCurrentMbFlag:w		
+
+    mov (2)	MSGSRC.0<1>:ud	ORIX_TOP<2;2,1>:w		{ NoDDClr }			// Block origin
+    mov (1)	MSGSRC.2<1>:ud	0x0003000F:ud			{ NoDDChk }			// Block width and height (16x4)
+
+	// Pack Y
+	// Dual field mode
+	(f0.1) mov	(16) MSGPAYLOADD(0)<1>		PREV_MB_YD(0)				// Compressed inst
+    (-f0.1)  mov (16) MSGPAYLOADD(0)<1>		PREV_MB_YD(2)				// for dual field mode, write last 4 rows
+    
+    // Set message descriptor
+
+    and.nz.f0.1 (1) NULLREGW 		BitFields:w   BotFieldFlag:w
+
+	(f0.0)	if	(1)		ELSE_Y_16x4_SAVE
+    
+    // Frame picture
+    mov (1)	MSGDSC	MSG_LEN(2)+DWBWMSGDSC_WC+BI_DEST_Y:ud			// Write 2 GRFs to DEST_Y
+
+	// Add vertical offset 16 for bot MB in MBAFF mode
+	(f0.1) add (1)	MSGSRC.1:d		MSGSRC.1:d		16:w		
+
+ELSE_Y_16x4_SAVE: 
+	else 	(1)		ENDIF_Y_16x4_SAVE
+
+	asr (1)	MSGSRC.1:d		ORIY_CUR:w		1:w					// Reduce y by half in field access mode
+
+	// Field picture
+    (f0.1) mov (1)	MSGDSC	MSG_LEN(2)+DWBWMSGDSC_WC+ENMSGDSCBF+BI_DEST_Y:ud  // Write 2 GRFs to DEST_Y bottom field
+    (-f0.1) mov (1)	MSGDSC	MSG_LEN(2)+DWBWMSGDSC_WC+ENMSGDSCTF+BI_DEST_Y:ud  // Write 2 GRFs to DEST_Y top field
+
+	add (1)	MSGSRC.1:d		MSGSRC.1:d		-4:w	// for last 4 rows of above MB
+
+	endif
+ENDIF_Y_16x4_SAVE:
+    
+    send (8)	WritebackResponse(0)<1>		MSGHDR		MSGSRC<8;8,1>:ud	DAPWRITE	MSGDSC
+
+// End of save_Top_Y_16x4.asm
diff --git a/i965_drv_video/shaders/h264/ildb/writeURB.asm b/i965_drv_video/shaders/h264/ildb/writeURB.asm
new file mode 100644
index 0000000..c75b220
--- /dev/null
+++ b/i965_drv_video/shaders/h264/ildb/writeURB.asm
@@ -0,0 +1,38 @@
+/*
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+// Module name: WriteURB.asm
+//
+// General purpose module to write data to URB using the URB handle/offset in r0
+//
+//----------------------------------------------------------------
+//	Assume:
+//	- a0.0 and a0.1 is meg desc, has been assign with URB offset and msg size
+//	- MRFs are alrady assigned with data.
+//----------------------------------------------------------------
+//
+//  16x16 byte pixel block can be saved using just 1 "send" instruction.
+
+#if defined(_DEBUG) 
+	mov		(1)		EntrySignature:w			0x3535:w
+#endif
+
+// URB write header:
+//mov (8) MSGSRC.0:ud 	r0.0<8;8,1>:ud			// Copy parent R0 header
+
+//shr (1)	Temp2_W:uw	URBOffset:uw	1:w	// divide by 2, because URB entry is counted by 512bits.  Offset is counted by 256bits.
+//add (1) MSGSRC.0:uw		r0.0:uw		Temp2_W:uw	
+
+
+shr (1)	MSGSRC.0:uw		URBOffset:uw	1:w	// divide by 2, because URB entry is counted by 512bits.  Offset is counted by 256bits.
+//mov (1)	MSGSRC.0:uw		URBOffset_2:uw
+
+//mov (1) MSGSRC.1:ud 	0:ud					// Reset Handle 1
+
+send  null:uw 	m0	  MSGSRC:uw		URBWRITE	URBWriteMsgDesc:ud		// URB write
+//send  null:ud 	MRF0	 null:ud	URBWriteMsgDesc:ud		// URB write	
diff --git a/i965_drv_video/shaders/h264/ildb/writeURB_UV_Child.asm b/i965_drv_video/shaders/h264/ildb/writeURB_UV_Child.asm
new file mode 100644
index 0000000..27d257a
--- /dev/null
+++ b/i965_drv_video/shaders/h264/ildb/writeURB_UV_Child.asm
@@ -0,0 +1,39 @@
+/*
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+// Module name: WriteURB_Child.asm
+//
+// General purpose module to write data to URB using the URB handle/offset in r0
+//
+//----------------------------------------------------------------
+//	Assume:
+//	- a0.0 and a0.1 is meg desc, has been assign with URB offset and msg size
+//	- MRFs are alrady assigned with data.
+//----------------------------------------------------------------
+//
+//  16x16 byte pixel block can be saved using just 1 "send" instruction.
+
+#if defined(_DEBUG) 
+	mov		(1)		EntrySignatureC:w			0x3535:w
+#endif
+
+// URB write header:
+//mov (8) MSGSRC.0:ud 	r0.0<8;8,1>:ud			// Copy parent R0 header
+
+//shr (1)	Temp2_W:uw	URBOffsetC:uw	1:w	// divide by 2, because URB entry is counted by 512bits.  Offset is counted by 256bits.
+//add (1) MSGSRC.0:uw		r0.0:uw		Temp2_W:uw	
+
+shr (1)	MSGSRC.0:uw		URBOffsetC:uw	1:w	// divide by 2, because URB entry is counted by 512bits.  Offset is counted by 256bits.
+
+//mov (1) MSGSRC.1:ud 	0:ud					// Reset Handle 1
+
+	// URB write 1 MRFs, 
+	// Current MB offset is in URBOffset, use it as write origin
+	// Add 2 to offset to store data be be passed to the right MB
+
+send  null:uw 	m0	  MSGSRC:uw		URBWRITE	MSG_LEN(1)+URBWMSGDSC+0x20		// URB write
diff --git a/i965_drv_video/shaders/h264/ildb/writeURB_Y_Child.asm b/i965_drv_video/shaders/h264/ildb/writeURB_Y_Child.asm
new file mode 100644
index 0000000..e51e4ad
--- /dev/null
+++ b/i965_drv_video/shaders/h264/ildb/writeURB_Y_Child.asm
@@ -0,0 +1,40 @@
+/*
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+// Module name: WriteURB_Child.asm
+//
+// General purpose module to write data to URB using the URB handle/offset in r0
+//
+//----------------------------------------------------------------
+//	Assume:
+//	- a0.0 and a0.1 is meg desc, has been assign with URB offset and msg size
+//	- MRFs are alrady assigned with data.
+//----------------------------------------------------------------
+//
+//  16x16 byte pixel block can be saved using just 1 "send" instruction.
+
+#if defined(_DEBUG) 
+	mov		(1)		EntrySignatureC:w			0x3535:w
+#endif
+
+// URB write header:
+//mov (8) MSGSRC.0:ud 	r0.0<8;8,1>:ud			// Copy parent R0 header
+
+//shr (1)	Temp2_W:uw	URBOffsetC:uw	1:w	// divide by 2, because URB entry is counted by 512bits.  Offset is counted by 256bits.
+//add (1) MSGSRC.0:uw		r0.0:uw		Temp2_W:uw	
+
+shr (1)	MSGSRC.0:uw		URBOffsetC:uw	1:w	// divide by 2, because URB entry is counted by 512bits.  Offset is counted by 256bits.
+
+//mov (1) MSGSRC.1:ud 	0:ud					// Reset Handle 1
+
+	// URB write 2 MRFs, 
+	// Current MB offset is in URBOffset, use it as write origin
+	// Add 2 to offset to store data be be passed to the right MB
+	//mov (1) URBWriteMsgDesc:ud		0x06300020:ud
+
+send  null:uw 	m0	  MSGSRC:uw		URBWRITE	MSG_LEN(2)+URBWMSGDSC+0x20		// URB write
diff --git a/i965_drv_video/shaders/h264/mc/AVCMCInter.asm b/i965_drv_video/shaders/h264/mc/AVCMCInter.asm
new file mode 100644
index 0000000..691fb33
--- /dev/null
+++ b/i965_drv_video/shaders/h264/mc/AVCMCInter.asm
@@ -0,0 +1,254 @@
+/*
+ * All inter-prediction macroblock kernels 
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+// Kernel name: AVCMCInter.asm
+
+#ifdef INTERLABEL
+#undef INTERLABEL
+#endif
+
+#if defined(MBAFF)
+//				< MBaff_Motion >
+#define INTERLABEL(x)	x##_##MBF
+#elif defined(FIELD)
+//				< FieldMB_Motion >
+#define INTERLABEL(x)	x##_##FLD
+#else // FRAME
+//				< FrameMB_Motion >
+#define INTERLABEL(x)	x##_##FRM
+#endif
+//
+// Decoding an inter-prediction macroblock (conditional compile)
+//	-DMBAFF : MBAff picture MB
+//	-DFRAME : Frame picture MB
+//	-DFIELD : Field picture MB
+//	-DMBAFF -DMONO : MBAff mono picture MB
+//	-DFRAME -DMONO : Frame mono picture MB
+//	-DFIELD -DMONO : Field mono picture MB
+
+
+//#if !defined(__AVCMCInter__)		// Make sure this is only included once
+//#define __AVCMCInter__
+
+
+// TODO: header files need to be in sync with intra prediction
+#include "header.inc"
+#include "inter_Header.inc"
+
+// TODO: Kernel names for mono cases
+#if defined(MBAFF)
+.kernel MBAff_Motion
+MBAFF_MB:
+#elif defined(FIELD)
+.kernel FieldMB_Motion
+FIELD_MB:
+#else // Frame
+.kernel FrameMB_Motion
+FRAME_MB:
+#endif
+
+#ifdef _DEBUG
+// WA for FULSIM so we'll know which kernel is being debugged
+#if defined(MBAFF)
+mov (1) acc0:ud 0x0aaa55a5:ud
+#elif defined(FIELD)
+mov (1) acc0:ud 0x0baa55a5:ud
+#else // Frame
+mov (1) acc0:ud 0x0caa55a5:ud
+#endif
+#endif
+
+
+#ifdef SW_SCOREBOARD
+    CALL(scoreboard_start_inter,1)
+#endif
+
+	mov (8)		gMSGSRC<1>:ud		r0.0<8;8,1>:ud		// Initialize message header payload with R0
+	
+	and (1)		gwMBTYPE<1>			gMBTYPE:ub						nMBTYPE_MASK:w		// MB type
+	shl (2)		gX<1>:w				gORIX<2;2,1>:ub					4:w // Convert MB origin to pixel unit
+	
+//	#include "process_inter16x16.asm"					// Handle B_L0_16x16 case with zero MVs and weighted pred off.
+	// In the case of B_L0_16x16 with zero MVs and weighted pred off, the kernel jumps to INTERLABEL(EXIT_LOOP).
+	
+INTERLABEL(INIT_MBPARA):
+	#include "initialize_MBPara.asm"
+	
+	
+    //========================= BEGIN - LOOP_SUBMB ===========================
+	mov (1)		gLOOP_SUBMB:uw		0:uw				// 0, 2, 4, 6
+INTERLABEL(LOOP_SUBMB):
+
+	//========================== BEGIN - LOOP_DIR ============================
+	// Prediction flag (gPREDFLAG - 0:Pred_L0, 1:Pred_L1, 2:BiPred)
+	asr (1)		gPREDFLAG:w			gSUBMB_MODE:ub					gLOOP_SUBMB:uw
+	mov (1)		gLOOP_DIR:uw		1:uw				// 1, 0
+	and (1)		gPREDFLAG:w			gPREDFLAG:w						0x3:w
+INTERLABEL(LOOP_DIR):
+
+	cmp.e.f0.0 (1) null:w			gLOOP_DIR:w						gPREDFLAG:w	
+	(f0.0) jmpi	INTERLABEL(LOOP_DIR_CONTINUE)	
+	
+    // Get binding table index 
+    // & reference picture parity (gREFPARITY - 0:top, 0x100:bottom, x:frame)
+    // & address of interpolation result
+    cmp.e.f0.1 (1) null:w			gLOOP_DIR:w						1:w
+    (f0.1) mov (1)		gpINTP:ud			nOFFSET_INTP0:ud						{NoDDClr} //
+    (f0.1) and (1)		gBIDX:w				r[pBIDX]:ub						0x7f:w	{NoDDChk} //
+    (-f0.1) mov (1)		gpINTP:ud			nOFFSET_INTP1:ud						{NoDDClr} //
+	(-f0.1) and (1)		gBIDX:w				r[pBIDX,4]:ub					0x7f:w	{NoDDChk} //
+#if defined(MBAFF) || defined(FIELD)
+    (f0.1) and (1)		gREFPARITY:w				r[pBIDX]:ub						0x80:w
+    (-f0.1) and (1)		gREFPARITY:w				r[pBIDX,4]:ub					0x80:w
+    shl (1)		gREFPARITY:w		gREFPARITY<0;1,0>:w				1:w
+#endif
+
+	// Sub MB shape
+	asr (1)		gSHAPETEMP:w		gSUBMB_SHAPE:ub					gLOOP_SUBMB:w
+	
+    // Chroma MV adjustment & Set message descriptor for frame/field read
+#if defined(MBAFF)
+	#include "chromaMVAdjust.asm" 
+    and.nz.f0.0 (1) null:uw			gFIELDMBFLAG:ub					nFIELDMB_MASK:uw
+    (f0.0) add (1) gD0:ud			gBIDX:uw						nDWBRMSGDSC_SC_TF:ud
+    (-f0.0) add (1)	gMSGDSC_R:ud	gBIDX:uw						nDWBRMSGDSC_SC:ud
+    (f0.0) add (1) gMSGDSC_R:ud		gD0:ud							gREFPARITY:uw
+#elif defined(FIELD)
+	#include "chromaMVAdjust.asm" 
+    add (1)		gMSGDSC_R:ud		gBIDX:uw						nDWBRMSGDSC_SC_TF:ud
+    add (1)		gMSGDSC_R:ud		gMSGDSC_R:ud					gREFPARITY:uw
+#else // FRAME
+	add (1)		gMSGDSC_R:ud		gBIDX:uw						nDWBRMSGDSC_SC:ud
+#endif
+
+	and.nz.f0.1 (1) null:w			gSHAPETEMP:w					3:w	
+	(f0.1) jmpi INTERLABEL(PROCESS4x4)
+	
+	//======================== BEGIN - PROCESS 8x8 ===========================
+	
+	// Reference block load
+	#include "loadRef_Y_16x13.asm"
+#ifndef MONO
+#if defined(MBAFF) || defined(FIELD)
+	add (1)		r[pMV,2]:w			r[pMV,2]:w						gCHRMVADJ:w
+#endif
+	#include "loadRef_C_10x5.asm"
+#endif
+
+	// Interpolation
+	//CALL_INTER(INTERLABEL(Interpolate_Y_8x8_Func), 1)
+	#include "interpolate_Y_8x8.asm"
+#ifndef MONO
+	//CALL_INTER(INTERLABEL(Interpolate_C_4x4_Func), 1)
+	#include "interpolate_C_4x4.asm"
+#endif
+
+	jmpi INTERLABEL(ROUND_SHIFT_C)
+	//========================= END - PROCESS 8x8 ============================
+	
+	//======================== BEGIN - LOOP_SUBMBPT ==========================
+INTERLABEL(PROCESS4x4):
+
+	mov (1)		gLOOP_SUBMBPT:uw	4:uw				// 4, 3, 2, 1
+INTERLABEL(LOOP_SUBMBPT):
+
+	// Reference block load
+	#include "loadRef_Y_16x9.asm"
+#ifndef MONO
+#if defined(MBAFF) || defined(FIELD)
+	add (1)		r[pMV,2]:w			r[pMV,2]:w						gCHRMVADJ:w
+#endif
+	#include "loadRef_C_6x3.asm"
+#endif
+
+	// Interpolation
+	#include "interpolate_Y_4x4.asm"
+#ifndef MONO
+	#include "interpolate_C_2x2.asm"
+#endif
+	
+	cmp.e.f0.0 (1) null:w			gLOOP_SUBMBPT:uw				3:w
+	add.z.f0.1 (1) gLOOP_SUBMBPT:uw gLOOP_SUBMBPT:uw				-1:w
+	add (1)		pMV:w				pMV:w							8:w	
+	(-f0.0) add (1)	gpINTP:ud		gpINTP:ud						0x00080008:ud	// 8 & 8
+	(f0.0) add (1) gpINTP:ud		gpINTP:ud						0x00180038:ud	// 24 & 56
+	(-f0.1) jmpi INTERLABEL(LOOP_SUBMBPT)
+    
+    cmp.e.f0.1	null:w				gLOOP_DIR:w						1:w
+    add (1)		pMV:w				pMV:w							-32:w
+    (f0.1) mov (1) gpINTP:ud		nOFFSET_INTP0:ud
+    (-f0.1) mov (1) gpINTP:ud		nOFFSET_INTP1:ud
+
+	mov (1)		pRESULT:uw					gpINTPC:uw
+    
+	//========================= END - LOOP_SUBMBPT ===========================
+    
+INTERLABEL(ROUND_SHIFT_C):
+    
+#ifndef MONO
+	#include "roundShift_C_4x4.asm"
+#endif
+
+INTERLABEL(LOOP_DIR_CONTINUE):
+	
+	add.nz.f0.1 (1) gLOOP_DIR:uw	gLOOP_DIR:uw					-1:w
+	add (1)		pMV:w				pMV:w							4:w
+    (-f0.1) jmpi INTERLABEL(LOOP_DIR)
+    //=========================== END - LOOP_DIR =============================
+
+INTERLABEL(Weighted_Prediction):
+	#include "weightedPred.asm"
+	
+	and.z.f0.1 (16)	null<1>:w		gLOOP_SUBMB<0;1,0>:uw			2:w
+
+	#include "recon_Y_8x8.asm"
+#ifndef MONO
+	#include "recon_C_4x4.asm"
+
+	(-f0.1) add (1)	pERRORC:w		pERRORC:w						48:w
+#endif
+
+	cmp.e.f0.1 (1) null:w			gLOOP_SUBMB:uw					6:w
+	add (1)		gLOOP_SUBMB:uw		gLOOP_SUBMB:uw					2:w
+
+	add (1)		pWGT_BIDX:ud		pWGT_BIDX:ud					0x00100001:ud	// 12 & 1
+	add (1)		pMV:w				pMV:w							gMVSTEP:w
+
+    (-f0.1) jmpi INTERLABEL(LOOP_SUBMB)
+    //========================== END - LOOP_SUBMB ============================
+    
+INTERLABEL(EXIT_LOOP):   
+	#include "writeRecon_YC.asm"    
+
+#ifdef SW_SCOREBOARD    
+	wait	n0:ud		//	Now wait for scoreboard to response
+    #include "Soreboard_update.asm"	// scorboard update function
+#else
+// Check for write commit first if SW scoreboard is disabled
+	mov	(1)	gREG_WRITE_COMMIT_Y<1>:ud	gREG_WRITE_COMMIT_Y<0;1,0>:ud		// Make sure Y write is committed
+	mov	(1)	gREG_WRITE_COMMIT_UV<1>:ud	gREG_WRITE_COMMIT_UV<0;1,0>:ud		// Make sure U/V write is committed
+#endif
+
+// Terminate the thread
+//
+    END_THREAD
+
+
+//#include "Interpolate_Y_8x8_Func.asm"
+//#include "Interpolate_C_4x4_Func.asm"
+//#include "WeightedPred_Y_Func.asm"	
+//#include "WeightedPred_C_Func.asm"	
+
+
+.end_code
+
+.end_kernel
+
+        
+//#endif	// !defined(__AVCMCInter__)
diff --git a/i965_drv_video/shaders/h264/mc/AllAVC.asm b/i965_drv_video/shaders/h264/mc/AllAVC.asm
new file mode 100644
index 0000000..a9149ff
--- /dev/null
+++ b/i965_drv_video/shaders/h264/mc/AllAVC.asm
@@ -0,0 +1,426 @@
+/*
+ * All HWMC kernels 
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+
+// Kernel name: AllAVC.asm
+//
+// All HWMC kernels merged into this file
+//
+//  $Revision: 2 $
+//  $Date: 9/10/06 2:02a $
+//
+
+// Note: To enable SW scoreboard for ILK AVC kernels, simply toggle the HW_SCOREBOARD 
+//		 and SW_SCOREBOARD definition as described below.
+//
+// ----------------------------------------------------
+//  Main: ALLINTRA
+// ----------------------------------------------------
+
+#define	COMBINED_KERNEL
+//#define	ENABLE_ILDB
+
+//	WA for *Stim tool issue, should be removed later
+
+#ifdef DEV_ILK
+#define INSTFACTOR	2	// 128-bit count as 2 instructions
+#else
+#define INSTFACTOR	1	// 128-bit is 1 instruction
+#endif	// DEV_ILK
+
+#ifdef DEV_CTG
+  #define SW_SCOREBOARD		// SW Scoreboard should be enabled for CTG and earlier
+  #undef HW_SCOREBOARD		// HW Scoreboard should be disabled for CTG and earlier
+#else
+  #define HW_SCOREBOARD		// HW Scoreboard should be enabled for ILK and beyond
+  #undef SW_SCOREBOARD		// SW Scoreboard should be disabled for ILK and beyond
+#endif	// DEV_CTG
+#include "export.inc"
+#if defined(_EXPORT)
+	#include "AllAVC_Export.inc"
+#elif defined(_BUILD)
+	#include "AllAVC.ich"			// ISAasm dumped .exports
+	#include "AllAVC_Export.inc"	// Keep jumping targets aligned, only for CTG and beyond
+	#include "AllAVC_Build.inc"
+#else
+#endif
+
+.kernel AllAVC
+
+// Build all intra prediction kernels
+//
+#ifdef INTRA_16x16_PAD_NENOP
+    $for(0; <INTRA_16x16_PAD_NENOP; 1) {
+	nenop
+	}
+#endif
+#ifdef INTRA_16x16_PAD_NOP
+    $for(0; <INTRA_16x16_PAD_NOP; 1) {
+	nop
+	}
+#endif
+    #include "Intra_16x16.asm"
+
+#ifdef INTRA_8x8_PAD_NENOP
+    $for(0; <INTRA_8x8_PAD_NENOP; 1) {
+	nenop
+	}
+#endif
+#ifdef INTRA_8x8_PAD_NOP
+    $for(0; <INTRA_8x8_PAD_NOP; 1) {
+	nop
+	}
+#endif
+    #include "Intra_8x8.asm"
+
+#ifdef INTRA_4x4_PAD_NENOP
+    $for(0; <INTRA_4x4_PAD_NENOP; 1) {
+	nenop
+	}
+#endif
+#ifdef INTRA_4x4_PAD_NOP
+    $for(0; <INTRA_4x4_PAD_NOP; 1) {
+	nop
+	}
+#endif
+    #include "Intra_4x4.asm"
+
+#ifdef INTRA_PCM_PAD_NENOP
+    $for(0; <INTRA_PCM_PAD_NENOP; 1) {
+	nenop
+	}
+#endif
+#ifdef INTRA_PCM_PAD_NOP
+    $for(0; <INTRA_PCM_PAD_NOP; 1) {
+	nop
+	}
+#endif
+    #include "Intra_PCM.asm"
+
+// Build FrameMB_Motion kernel
+//
+#define FRAME
+
+  #ifdef FRAME_MB_PAD_NENOP
+    $for(0; <FRAME_MB_PAD_NENOP; 1) {
+	nenop
+	}
+  #endif
+  #ifdef FRAME_MB_PAD_NOP
+    $for(0; <FRAME_MB_PAD_NOP; 1) {
+	nop
+	}
+  #endif
+    #include "AVCMCInter.asm"
+#undef  FRAME
+
+// Build FieldMB_Motion kernel
+//
+#define FIELD
+
+  #ifdef FIELD_MB_PAD_NENOP
+    $for(0; <FIELD_MB_PAD_NENOP; 1) {
+	nenop
+	}
+  #endif
+  #ifdef FIELD_MB_PAD_NOP
+    $for(0; <FIELD_MB_PAD_NOP; 1) {
+	nop
+	}
+  #endif
+    #include "AVCMCInter.asm"
+#undef  FIELD
+
+// Build MBAff_Motion kernel
+//
+#define MBAFF
+
+  #ifdef MBAFF_MB_PAD_NENOP
+    $for(0; <MBAFF_MB_PAD_NENOP; 1) {
+	nenop
+	}
+  #endif
+  #ifdef MBAFF_MB_PAD_NOP
+    $for(0; <MBAFF_MB_PAD_NOP; 1) {
+	nop
+	}
+  #endif
+    #include "AVCMCInter.asm"
+#undef  MBAFF
+
+#ifdef SW_SCOREBOARD    
+
+// SW scoreboard kernel for non-MBAFF
+//
+#ifdef SCOREBOARD_PAD_NENOP
+    $for(0; <SCOREBOARD_PAD_NENOP; 1) {
+	nenop
+	}
+#endif
+#ifdef SCOREBOARD_PAD_NOP
+    $for(0; <SCOREBOARD_PAD_NOP; 1) {
+	nop
+	}
+#endif
+    #include "scoreboard.asm"
+
+//	SW scoreboard kernel for MBAFF
+
+#ifdef SCOREBOARD_MBAFF_PAD_NENOP
+    $for(0; <SCOREBOARD_MBAFF_PAD_NENOP; 1) {
+	nenop
+	}
+#endif
+#ifdef SCOREBOARD_MBAFF_PAD_NOP
+    $for(0; <SCOREBOARD_MBAFF_PAD_NOP; 1) {
+	nop
+	}
+#endif
+    #include "scoreboard_MBAFF.asm"
+
+#elif defined(HW_SCOREBOARD)
+ 
+// SetHWscoreboard kernel for non-MBAFF
+//
+#ifdef SETHWSCOREBOARD_PAD_NENOP
+    $for(0; <SETHWSCOREBOARD_PAD_NENOP; 1) {
+	nenop
+	}
+#endif
+#ifdef SETHWSCOREBOARD_PAD_NOP
+    $for(0; <SETHWSCOREBOARD_PAD_NOP; 1) {
+	nop
+	}
+#endif
+    #include "SetHWScoreboard.asm"
+
+//	SetHWscoreboard kernel for MBAFF
+
+#ifdef SETHWSCOREBOARD_MBAFF_PAD_NENOP
+    $for(0; <SETHWSCOREBOARD_MBAFF_PAD_NENOP; 1) {
+	nenop
+	}
+#endif
+#ifdef SETHWSCOREBOARD_MBAFF_PAD_NOP
+    $for(0; <SETHWSCOREBOARD_MBAFF_PAD_NOP; 1) {
+	nop
+	}
+#endif
+    #include "SetHWScoreboard_MBAFF.asm"
+
+#endif	// SW_SCOREBOARD
+
+#ifdef BSDRESET_PAD_NENOP
+    $for(0; <BSDRESET_PAD_NENOP; 1) {
+	nenop
+	}
+#endif
+#ifdef BSDRESET_PAD_NOP
+    $for(0; <BSDRESET_PAD_NOP; 1) {
+	nop
+	}
+#endif
+    #include "BSDReset.asm"
+
+#ifdef DCRESETDUMMY_PAD_NENOP
+    $for(0; <DCRESETDUMMY_PAD_NENOP; 1) {
+	nenop
+	}
+#endif
+#ifdef DCRESETDUMMY_PAD_NOP
+    $for(0; <DCRESETDUMMY_PAD_NOP; 1) {
+	nop
+	}
+#endif
+    #include "DCResetDummy.asm"
+
+#ifdef ENABLE_ILDB
+
+// Build all ILDB kernels
+//
+//	Undefine some previous defined symbols since they will be re-defined/re-declared in ILDB kernels
+#undef	A
+#undef	B
+#undef	p0
+#undef	p1
+
+#define MSGPAYLOADB MSGPAYLOADB_ILDB
+#define MSGPAYLOADW MSGPAYLOADW_ILDB
+#define MSGPAYLOADD MSGPAYLOADD_ILDB
+#define MSGPAYLOADF MSGPAYLOADF_ILDB
+
+//				< Frame ILDB >
+#define _PROGRESSIVE
+#define ILDB_LABEL(x)	x##_ILDB_FRAME
+#ifdef AVC_ILDB_ROOT_Y_ILDB_FRAME_PAD_NENOP
+    $for(0; <AVC_ILDB_ROOT_Y_ILDB_FRAME_PAD_NENOP; 1) {
+	nenop
+	}
+#endif
+#ifdef AVC_ILDB_ROOT_Y_ILDB_FRAME_PAD_NOP
+    $for(0; <AVC_ILDB_ROOT_Y_ILDB_FRAME_PAD_NOP; 1) {
+	nop
+	}
+#endif
+    #include "AVC_ILDB_Root_Y.asm"
+
+#ifdef AVC_ILDB_CHILD_Y_ILDB_FRAME_PAD_NENOP
+    $for(0; <AVC_ILDB_CHILD_Y_ILDB_FRAME_PAD_NENOP; 1) {
+	nenop
+	}
+#endif
+#ifdef AVC_ILDB_CHILD_Y_ILDB_FRAME_PAD_NOP
+    $for(0; <AVC_ILDB_CHILD_Y_ILDB_FRAME_PAD_NOP; 1) {
+	nop
+	}
+#endif
+    #include "AVC_ILDB_Child_Y.asm"
+
+#ifdef AVC_ILDB_ROOT_UV_ILDB_FRAME_PAD_NENOP
+    $for(0; <AVC_ILDB_ROOT_UV_ILDB_FRAME_PAD_NENOP; 1) {
+	nenop
+	}
+#endif
+#ifdef AVC_ILDB_ROOT_UV_ILDB_FRAME_PAD_NOP
+    $for(0; <AVC_ILDB_ROOT_UV_ILDB_FRAME_PAD_NOP; 1) {
+	nop
+	}
+#endif
+    #include "AVC_ILDB_Root_UV.asm"
+
+#ifdef AVC_ILDB_CHILD_UV_ILDB_FRAME_PAD_NENOP
+    $for(0; <AVC_ILDB_CHILD_UV_ILDB_FRAME_PAD_NENOP; 1) {
+	nenop
+	}
+#endif
+#ifdef AVC_ILDB_CHILD_UV_ILDB_FRAME_PAD_NOP
+    $for(0; <AVC_ILDB_CHILD_UV_ILDB_FRAME_PAD_NOP; 1) {
+	nop
+	}
+#endif
+    #include "AVC_ILDB_Child_UV.asm"
+#undef ILDB_LABEL
+#undef _PROGRESSIVE
+
+//				< Field ILDB >
+#define _FIELD
+#define ILDB_LABEL(x)	x##_ILDB_FIELD
+#ifdef AVC_ILDB_ROOT_Y_ILDB_FIELD_PAD_NENOP
+    $for(0; <AVC_ILDB_ROOT_Y_ILDB_FIELD_PAD_NENOP; 1) {
+	nenop
+	}
+#endif
+#ifdef AVC_ILDB_ROOT_Y_ILDB_FIELD_PAD_NOP
+    $for(0; <AVC_ILDB_ROOT_Y_ILDB_FIELD_PAD_NOP; 1) {
+	nop
+	}
+#endif
+    #include "AVC_ILDB_Root_Field_Y.asm"
+
+#ifdef AVC_ILDB_CHILD_Y_ILDB_FIELD_PAD_NENOP
+    $for(0; <AVC_ILDB_CHILD_Y_ILDB_FIELD_PAD_NENOP; 1) {
+	nenop
+	}
+#endif
+#ifdef AVC_ILDB_CHILD_Y_ILDB_FIELD_PAD_NOP
+    $for(0; <AVC_ILDB_CHILD_Y_ILDB_FIELD_PAD_NOP; 1) {
+	nop
+	}
+#endif
+    #include "AVC_ILDB_Child_Field_Y.asm"
+
+#ifdef AVC_ILDB_ROOT_UV_ILDB_FIELD_PAD_NENOP
+    $for(0; <AVC_ILDB_ROOT_UV_ILDB_FIELD_PAD_NENOP; 1) {
+	nenop
+	}
+#endif
+#ifdef AVC_ILDB_ROOT_UV_ILDB_FIELD_PAD_NOP
+    $for(0; <AVC_ILDB_ROOT_UV_ILDB_FIELD_PAD_NOP; 1) {
+	nop
+	}
+#endif
+    #include "AVC_ILDB_Root_Field_UV.asm"
+
+#ifdef AVC_ILDB_CHILD_UV_ILDB_FIELD_PAD_NENOP
+    $for(0; <AVC_ILDB_CHILD_UV_ILDB_FIELD_PAD_NENOP; 1) {
+	nenop
+	}
+#endif
+#ifdef AVC_ILDB_CHILD_UV_ILDB_FIELD_PAD_NOP
+    $for(0; <AVC_ILDB_CHILD_UV_ILDB_FIELD_PAD_NOP; 1) {
+	nop
+	}
+#endif
+    #include "AVC_ILDB_Child_Field_UV.asm"
+#undef ILDB_LABEL
+#undef _FIELD
+
+//				< MBAFF Frame ILDB >
+#define _MBAFF
+#define ILDB_LABEL(x)	x##_ILDB_MBAFF
+#ifdef AVC_ILDB_ROOT_Y_ILDB_MBAFF_PAD_NENOP
+    $for(0; <AVC_ILDB_ROOT_Y_ILDB_MBAFF_PAD_NENOP; 1) {
+	nenop
+	}
+#endif
+#ifdef AVC_ILDB_ROOT_Y_ILDB_MBAFF_PAD_NOP
+    $for(0; <AVC_ILDB_ROOT_Y_ILDB_MBAFF_PAD_NOP; 1) {
+	nop
+	}
+#endif
+    #include "AVC_ILDB_Root_Mbaff_Y.asm"
+
+#ifdef AVC_ILDB_CHILD_Y_ILDB_MBAFF_PAD_NENOP
+    $for(0; <AVC_ILDB_CHILD_Y_ILDB_MBAFF_PAD_NENOP; 1) {
+	nenop
+	}
+#endif
+#ifdef AVC_ILDB_CHILD_Y_ILDB_MBAFF_PAD_NOP
+    $for(0; <AVC_ILDB_CHILD_Y_ILDB_MBAFF_PAD_NOP; 1) {
+	nop
+	}
+#endif
+    #include "AVC_ILDB_Child_Mbaff_Y.asm"
+
+#ifdef AVC_ILDB_ROOT_UV_ILDB_MBAFF_PAD_NENOP
+    $for(0; <AVC_ILDB_ROOT_UV_ILDB_MBAFF_PAD_NENOP; 1) {
+	nenop
+	}
+#endif
+#ifdef AVC_ILDB_ROOT_UV_ILDB_MBAFF_PAD_NOP
+    $for(0; <AVC_ILDB_ROOT_UV_ILDB_MBAFF_PAD_NOP; 1) {
+	nop
+	}
+#endif
+    #include "AVC_ILDB_Root_Mbaff_UV.asm"
+
+#ifdef AVC_ILDB_CHILD_UV_ILDB_MBAFF_PAD_NENOP
+    $for(0; <AVC_ILDB_CHILD_UV_ILDB_MBAFF_PAD_NENOP; 1) {
+	nenop
+	}
+#endif
+#ifdef AVC_ILDB_CHILD_UV_ILDB_MBAFF_PAD_NOP
+    $for(0; <AVC_ILDB_CHILD_UV_ILDB_MBAFF_PAD_NOP; 1) {
+	nop
+	}
+#endif
+    #include "AVC_ILDB_Child_Mbaff_UV.asm"
+#undef ILDB_LABEL
+#undef _MBAFF
+
+#endif		// ENABLE_ILDB
+
+AllAVC_END:
+nop
+// End of AllAVC
+
+.end_code
+
+.end_kernel
+
diff --git a/i965_drv_video/shaders/h264/mc/AllAVCField.asm b/i965_drv_video/shaders/h264/mc/AllAVCField.asm
new file mode 100644
index 0000000..88240c3
--- /dev/null
+++ b/i965_drv_video/shaders/h264/mc/AllAVCField.asm
@@ -0,0 +1,70 @@
+/*
+ * All field picture HWMC kernels 
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+//	2857702934	// 0xAA551616 - GUID for Intra_16x16 luma prediction mode offsets
+//    0    // Offset to Intra_16x16 luma prediction mode 0
+//    9    // Offset to Intra_16x16 luma prediction mode 1
+//   19    // Offset to Intra_16x16 luma prediction mode 2
+//   42    // Offset to Intra_16x16 luma prediction mode 3
+//	2857699336	// 0xAA550808 - GUID for Intra_8x8 luma prediction mode offsets
+//    0    // Offset to Intra_8x8 luma prediction mode 0
+//    5    // Offset to Intra_8x8 luma prediction mode 1
+//   10    // Offset to Intra_8x8 luma prediction mode 2
+//   26    // Offset to Intra_8x8 luma prediction mode 3
+//   36    // Offset to Intra_8x8 luma prediction mode 4
+//   50    // Offset to Intra_8x8 luma prediction mode 5
+//   68    // Offset to Intra_8x8 luma prediction mode 6
+//   85    // Offset to Intra_8x8 luma prediction mode 7
+//   95    // Offset to Intra_8x8 luma prediction mode 8
+//	2857698308	// 0xAA550404 - GUID for Intra_4x4 luma prediction mode offsets
+//    0    // Offset to Intra_4x4 luma prediction mode 0
+//    2    // Offset to Intra_4x4 luma prediction mode 1
+//    4    // Offset to Intra_4x4 luma prediction mode 2
+//   16    // Offset to Intra_4x4 luma prediction mode 3
+//   23    // Offset to Intra_4x4 luma prediction mode 4
+//   32    // Offset to Intra_4x4 luma prediction mode 5
+//   45    // Offset to Intra_4x4 luma prediction mode 6
+//   59    // Offset to Intra_4x4 luma prediction mode 7
+//   66    // Offset to Intra_4x4 luma prediction mode 8
+//	2857700364	// 0xAA550C0C - GUID for intra chroma prediction mode offsets
+//    0    // Offset to intra chroma prediction mode 0
+//   30    // Offset to intra chroma prediction mode 1
+//   36    // Offset to intra chroma prediction mode 2
+//   41    // Offset to intra chroma prediction mode 3
+
+// Kernel name: AllAVCField.asm
+//
+// All field picture HWMC kernels merged into this file
+//
+//  $Revision: 1 $
+//  $Date: 4/13/06 4:35p $
+//
+
+// ----------------------------------------------------
+//  Main: AllAVCField
+// ----------------------------------------------------
+
+#define	ALLHWMC
+#define	COMBINED_KERNEL
+
+.kernel AllAVCField
+
+    #include "Intra_PCM.asm"
+    #include "Intra_16x16.asm"
+    #include "Intra_8x8.asm"
+    #include "Intra_4x4.asm"
+    #include "scoreboard.asm"
+
+	#define FIELD
+	#include "AVCMCInter.asm"
+
+// End of AllAVCField
+
+.end_kernel
+
diff --git a/i965_drv_video/shaders/h264/mc/AllAVCFrame.asm b/i965_drv_video/shaders/h264/mc/AllAVCFrame.asm
new file mode 100644
index 0000000..8871627
--- /dev/null
+++ b/i965_drv_video/shaders/h264/mc/AllAVCFrame.asm
@@ -0,0 +1,69 @@
+/*
+ * All frame picture HWMC kernels 
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+//	2857702934	// 0xAA551616 - GUID for Intra_16x16 luma prediction mode offsets
+//    0    // Offset to Intra_16x16 luma prediction mode 0
+//    9    // Offset to Intra_16x16 luma prediction mode 1
+//   19    // Offset to Intra_16x16 luma prediction mode 2
+//   42    // Offset to Intra_16x16 luma prediction mode 3
+//	2857699336	// 0xAA550808 - GUID for Intra_8x8 luma prediction mode offsets
+//    0    // Offset to Intra_8x8 luma prediction mode 0
+//    5    // Offset to Intra_8x8 luma prediction mode 1
+//   10    // Offset to Intra_8x8 luma prediction mode 2
+//   26    // Offset to Intra_8x8 luma prediction mode 3
+//   36    // Offset to Intra_8x8 luma prediction mode 4
+//   50    // Offset to Intra_8x8 luma prediction mode 5
+//   68    // Offset to Intra_8x8 luma prediction mode 6
+//   85    // Offset to Intra_8x8 luma prediction mode 7
+//   95    // Offset to Intra_8x8 luma prediction mode 8
+//	2857698308	// 0xAA550404 - GUID for Intra_4x4 luma prediction mode offsets
+//    0    // Offset to Intra_4x4 luma prediction mode 0
+//    2    // Offset to Intra_4x4 luma prediction mode 1
+//    4    // Offset to Intra_4x4 luma prediction mode 2
+//   16    // Offset to Intra_4x4 luma prediction mode 3
+//   23    // Offset to Intra_4x4 luma prediction mode 4
+//   32    // Offset to Intra_4x4 luma prediction mode 5
+//   45    // Offset to Intra_4x4 luma prediction mode 6
+//   59    // Offset to Intra_4x4 luma prediction mode 7
+//   66    // Offset to Intra_4x4 luma prediction mode 8
+//	2857700364	// 0xAA550C0C - GUID for intra chroma prediction mode offsets
+//    0    // Offset to intra chroma prediction mode 0
+//   30    // Offset to intra chroma prediction mode 1
+//   36    // Offset to intra chroma prediction mode 2
+//   41    // Offset to intra chroma prediction mode 3
+
+// Kernel name: AllAVCFrame.asm
+//
+// All frame picture HWMC kernels merged into this file
+//
+//  $Revision: 1 $
+//  $Date: 4/13/06 4:35p $
+//
+
+// ----------------------------------------------------
+//  Main: AllAVCFrame
+// ----------------------------------------------------
+
+#define	ALLHWMC
+#define	COMBINED_KERNEL
+
+.kernel AllAVCFrame
+
+    #include "Intra_PCM.asm"
+    #include "Intra_16x16.asm"
+    #include "Intra_8x8.asm"
+    #include "Intra_4x4.asm"
+    #include "scoreboard.asm"
+
+	#include "AVCMCInter.asm"
+
+// End of AllAVCFrame
+
+.end_kernel
+
diff --git a/i965_drv_video/shaders/h264/mc/AllAVCMBAFF.asm b/i965_drv_video/shaders/h264/mc/AllAVCMBAFF.asm
new file mode 100644
index 0000000..1dd06ed
--- /dev/null
+++ b/i965_drv_video/shaders/h264/mc/AllAVCMBAFF.asm
@@ -0,0 +1,70 @@
+/*
+ * All MBAFF frame picture HWMC kernels 
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+//	2857702934	// 0xAA551616 - GUID for Intra_16x16 luma prediction mode offsets
+//    0    // Offset to Intra_16x16 luma prediction mode 0
+//    9    // Offset to Intra_16x16 luma prediction mode 1
+//   19    // Offset to Intra_16x16 luma prediction mode 2
+//   42    // Offset to Intra_16x16 luma prediction mode 3
+//	2857699336	// 0xAA550808 - GUID for Intra_8x8 luma prediction mode offsets
+//    0    // Offset to Intra_8x8 luma prediction mode 0
+//    5    // Offset to Intra_8x8 luma prediction mode 1
+//   10    // Offset to Intra_8x8 luma prediction mode 2
+//   26    // Offset to Intra_8x8 luma prediction mode 3
+//   36    // Offset to Intra_8x8 luma prediction mode 4
+//   50    // Offset to Intra_8x8 luma prediction mode 5
+//   68    // Offset to Intra_8x8 luma prediction mode 6
+//   85    // Offset to Intra_8x8 luma prediction mode 7
+//   95    // Offset to Intra_8x8 luma prediction mode 8
+//	2857698308	// 0xAA550404 - GUID for Intra_4x4 luma prediction mode offsets
+//    0    // Offset to Intra_4x4 luma prediction mode 0
+//    2    // Offset to Intra_4x4 luma prediction mode 1
+//    4    // Offset to Intra_4x4 luma prediction mode 2
+//   16    // Offset to Intra_4x4 luma prediction mode 3
+//   23    // Offset to Intra_4x4 luma prediction mode 4
+//   32    // Offset to Intra_4x4 luma prediction mode 5
+//   45    // Offset to Intra_4x4 luma prediction mode 6
+//   59    // Offset to Intra_4x4 luma prediction mode 7
+//   66    // Offset to Intra_4x4 luma prediction mode 8
+//	2857700364	// 0xAA550C0C - GUID for intra chroma prediction mode offsets
+//    0    // Offset to intra chroma prediction mode 0
+//   30    // Offset to intra chroma prediction mode 1
+//   36    // Offset to intra chroma prediction mode 2
+//   41    // Offset to intra chroma prediction mode 3
+
+// Kernel name: AllAVCMBAFF.asm
+//
+// All MBAFF frame picture HWMC kernels merged into this file
+//
+//  $Revision: 1 $
+//  $Date: 4/13/06 4:35p $
+//
+
+// ----------------------------------------------------
+//  Main: AllAVCMBAFF
+// ----------------------------------------------------
+
+#define	ALLHWMC
+#define	COMBINED_KERNEL
+
+.kernel AllAVCMBAFF
+
+    #include "Intra_PCM.asm"
+    #include "Intra_16x16.asm"
+    #include "Intra_8x8.asm"
+    #include "Intra_4x4.asm"
+    #include "scoreboard.asm"
+
+	#define MBAFF
+	#include "AVCMCInter.asm"
+
+// End of AllAVCMBAFF
+
+.end_kernel
+
diff --git a/i965_drv_video/shaders/h264/mc/AllAVC_Build.inc b/i965_drv_video/shaders/h264/mc/AllAVC_Build.inc
new file mode 100644
index 0000000..5bfb753
--- /dev/null
+++ b/i965_drv_video/shaders/h264/mc/AllAVC_Build.inc
@@ -0,0 +1,82 @@
+/*
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+$table {
+AllAVC_END_IP/INSTFACTOR    // Total instruction count
+#if (defined(SW_SCOREBOARD) || defined(HW_SCOREBOARD)) && defined(ENABLE_ILDB)
+//    23    // Total kernel count
+#elif defined(SW_SCOREBOARD) || defined(HW_SCOREBOARD)
+//    11    // Total kernel count
+#elif defined(ENABLE_ILDB)
+//    21    // Total kernel count
+#else
+//    11    // Total kernel count
+#endif
+INTRA_16x16_ENTRY/INSTFACTOR    // Instruction offset to 'Intra_16x16'
+INTRA_8x8_ENTRY/INSTFACTOR    // Instruction offset to 'Intra_8x8'
+INTRA_4x4_ENTRY/INSTFACTOR    // Instruction offset to 'Intra_4x4'
+INTRA_PCM_ENTRY/INSTFACTOR    // Instruction offset to 'Intra_PCM'
+FRAME_MB_ENTRY/INSTFACTOR    // Instruction offset to 'FrameMB_Motion'
+FIELD_MB_ENTRY/INSTFACTOR    // Instruction offset to 'FieldMB_Motion'
+MBAFF_MB_ENTRY/INSTFACTOR    // Instruction offset to 'MBAff_Motion'
+#ifdef SW_SCOREBOARD    
+SCOREBOARD_ENTRY/INSTFACTOR			// Instruction offset to 'scoreboard'
+SCOREBOARD_MBAFF_ENTRY/INSTFACTOR	// Instruction offset to 'scoreboard_MBAFF'
+#elif defined(HW_SCOREBOARD)
+SETHWSCOREBOARD_ENTRY/INSTFACTOR		// Instruction offset to 'AVC_SetIntraDepend'
+SETHWSCOREBOARD_MBAFF_ENTRY/INSTFACTOR	// Instruction offset to 'AVC_SetIntraDependMBAFF'
+#endif	// SW_SCOREBOARD
+#ifdef ENABLE_ILDB
+AVC_ILDB_ROOT_Y_ILDB_FRAME_ENTRY/INSTFACTOR    // Instruction offset to 'AVC_ILDB_Root_Y'
+AVC_ILDB_CHILD_Y_ILDB_FRAME_ENTRY/INSTFACTOR    // Instruction offset to 'AVC_ILDB_Child_Y'
+AVC_ILDB_ROOT_UV_ILDB_FRAME_ENTRY/INSTFACTOR    // Instruction offset to 'AVC_ILDB_Root_UV'
+AVC_ILDB_CHILD_UV_ILDB_FRAME_ENTRY/INSTFACTOR    // Instruction offset to 'AVC_ILDB_Child_UV'
+AVC_ILDB_ROOT_Y_ILDB_FIELD_ENTRY/INSTFACTOR    // Instruction offset to 'AVC_ILDB_Root_Field_Y'
+AVC_ILDB_CHILD_Y_ILDB_FIELD_ENTRY/INSTFACTOR    // Instruction offset to 'AVC_ILDB_Child_Field_Y'
+AVC_ILDB_ROOT_UV_ILDB_FIELD_ENTRY/INSTFACTOR    // Instruction offset to 'AVC_ILDB_Root_Field_UV'
+AVC_ILDB_CHILD_UV_ILDB_FIELD_ENTRY/INSTFACTOR    // Instruction offset to 'AVC_ILDB_Child_Field_UV'
+AVC_ILDB_ROOT_Y_ILDB_MBAFF_ENTRY/INSTFACTOR    // Instruction offset to 'AVC_ILDB_Root_Mbaff_Y'
+AVC_ILDB_CHILD_Y_ILDB_MBAFF_ENTRY/INSTFACTOR    // Instruction offset to 'AVC_ILDB_Child_Mbaff_Y'
+AVC_ILDB_ROOT_UV_ILDB_MBAFF_ENTRY/INSTFACTOR    // Instruction offset to 'AVC_ILDB_Root_Mbaff_UV'
+AVC_ILDB_CHILD_UV_ILDB_MBAFF_ENTRY/INSTFACTOR    // Instruction offset to 'AVC_ILDB_Child_Mbaff_UV'
+#endif	// ENABLE_ILDB
+BSDRESET_ENTRY/INSTFACTOR    // Instruction offset to 'BSDReset'
+DCRESETDUMMY_ENTRY/INSTFACTOR    // Instruction offset to 'DCResetDummy'
+
+//    0    // Instruction offset to Intra_4x4_luma_prediction_mode_0
+INTRA_4X4_HORIZONTAL_IP-INTRA_4X4_VERTICAL_IP    // Instruction offset to Intra_4x4_luma_prediction_mode_1
+INTRA_4X4_DC_IP-INTRA_4X4_VERTICAL_IP    // Instruction offset to Intra_4x4_luma_prediction_mode_2
+INTRA_4X4_DIAG_DOWN_LEFT_IP-INTRA_4X4_VERTICAL_IP    // Instruction offset to Intra_4x4_luma_prediction_mode_3
+INTRA_4X4_DIAG_DOWN_RIGHT_IP-INTRA_4X4_VERTICAL_IP    // Instruction offset to Intra_4x4_luma_prediction_mode_4
+INTRA_4X4_VERT_RIGHT_IP-INTRA_4X4_VERTICAL_IP    // Instruction offset to Intra_4x4_luma_prediction_mode_5
+INTRA_4X4_HOR_DOWN_IP-INTRA_4X4_VERTICAL_IP    // Instruction offset to Intra_4x4_luma_prediction_mode_6
+INTRA_4X4_VERT_LEFT_IP-INTRA_4X4_VERTICAL_IP    // Instruction offset to Intra_4x4_luma_prediction_mode_7
+INTRA_4X4_HOR_UP_IP-INTRA_4X4_VERTICAL_IP    // Instruction offset to Intra_4x4_luma_prediction_mode_8
+
+//    0    // Instruction offset to Intra_8x8_luma_prediction_mode_0
+INTRA_8X8_HORIZONTAL_IP-INTRA_8X8_VERTICAL_IP    // Instruction offset to Intra_8x8_luma_prediction_mode_1
+INTRA_8X8_DC_IP-INTRA_8X8_VERTICAL_IP    // Instruction offset to Intra_8x8_luma_prediction_mode_2
+INTRA_8X8_DIAG_DOWN_LEFT_IP-INTRA_8X8_VERTICAL_IP    // Instruction offset to Intra_8x8_luma_prediction_mode_3
+INTRA_8X8_DIAG_DOWN_RIGHT_IP-INTRA_8X8_VERTICAL_IP    // Instruction offset to Intra_8x8_luma_prediction_mode_4
+INTRA_8X8_VERT_RIGHT_IP-INTRA_8X8_VERTICAL_IP    // Instruction offset to Intra_8x8_luma_prediction_mode_5
+INTRA_8X8_HOR_DOWN_IP-INTRA_8X8_VERTICAL_IP    // Instruction offset to Intra_8x8_luma_prediction_mode_6
+INTRA_8X8_VERT_LEFT_IP-INTRA_8X8_VERTICAL_IP    // Instruction offset to Intra_8x8_luma_prediction_mode_7
+INTRA_8X8_HOR_UP_IP-INTRA_8X8_VERTICAL_IP    // Instruction offset to Intra_8x8_luma_prediction_mode_8
+
+//    0    // Instruction offset to Intra_16x16_luma_prediction_mode_0
+INTRA_16x16_HORIZONTAL_IP-INTRA_16x16_VERTICAL_IP    // Instruction offset to Intra_16x16_luma_prediction_mode_1
+INTRA_16x16_DC_IP-INTRA_16x16_VERTICAL_IP    // Instruction offset to Intra_16x16_luma_prediction_mode_2
+INTRA_16x16_PLANE_IP-INTRA_16x16_VERTICAL_IP    // Instruction offset to Intra_16x16_luma_prediction_mode_3
+
+//    0    // Instruction offset to intra_chroma_prediction_mode_0
+INTRA_CHROMA_HORIZONTAL_IP-INTRA_CHROMA_DC_IP    // Instruction offset to intra_chroma_prediction_mode_1
+INTRA_CHROMA_VERTICAL_IP-INTRA_CHROMA_DC_IP    // Instruction offset to intra_chroma_prediction_mode_2
+INTRA_Chroma_PLANE_IP-INTRA_CHROMA_DC_IP    // Instruction offset to intra_chroma_prediction_mode_3
+
+intra_Pred_4x4_Y_IP-ADD_ERROR_SB3_IP*0x100+intra_Pred_4x4_Y_IP-ADD_ERROR_SB2_IP*0x100+intra_Pred_4x4_Y_IP-ADD_ERROR_SB1_IP*0x100+intra_Pred_4x4_Y_IP-ADD_ERROR_SB0_IP	// Instruction offset to intra_4x4_pred_module
+}
diff --git a/i965_drv_video/shaders/h264/mc/AllAVC_Export.inc b/i965_drv_video/shaders/h264/mc/AllAVC_Export.inc
new file mode 100644
index 0000000..6bb3eff
--- /dev/null
+++ b/i965_drv_video/shaders/h264/mc/AllAVC_Export.inc
@@ -0,0 +1,172 @@
+.export entry_point INTRA_16x16
+.export entry_point INTRA_8x8
+.export entry_point INTRA_4x4
+.export entry_point INTRA_PCM
+.export entry_point FRAME_MB
+.export entry_point FIELD_MB
+.export entry_point MBAFF_MB
+#ifdef SW_SCOREBOARD    
+.export entry_point SCOREBOARD
+.export entry_point SCOREBOARD_MBAFF
+#elif defined(HW_SCOREBOARD)
+.export entry_point SETHWSCOREBOARD
+.export entry_point SETHWSCOREBOARD_MBAFF
+#endif	// SW_SCOREBOARD
+
+#ifdef ENABLE_ILDB
+.export entry_point AVC_ILDB_ROOT_Y_ILDB_FRAME
+.export entry_point AVC_ILDB_CHILD_Y_ILDB_FRAME
+.export entry_point AVC_ILDB_ROOT_UV_ILDB_FRAME
+.export entry_point AVC_ILDB_CHILD_UV_ILDB_FRAME
+.export entry_point AVC_ILDB_ROOT_Y_ILDB_FIELD
+.export entry_point AVC_ILDB_CHILD_Y_ILDB_FIELD
+.export entry_point AVC_ILDB_ROOT_UV_ILDB_FIELD
+.export entry_point AVC_ILDB_CHILD_UV_ILDB_FIELD
+.export entry_point AVC_ILDB_ROOT_Y_ILDB_MBAFF
+.export entry_point AVC_ILDB_CHILD_Y_ILDB_MBAFF
+.export entry_point AVC_ILDB_ROOT_UV_ILDB_MBAFF
+.export entry_point AVC_ILDB_CHILD_UV_ILDB_MBAFF
+#endif	// ENABLE_ILDB
+
+.export entry_point BSDRESET
+.export entry_point DCRESETDUMMY
+
+.export label INTRA_16x16_VERTICAL
+.export label INTRA_16x16_HORIZONTAL
+.export label INTRA_16x16_DC
+.export label INTRA_16x16_PLANE
+
+.export label INTRA_8X8_VERTICAL
+.export label INTRA_8X8_HORIZONTAL
+.export label INTRA_8X8_DC
+.export label INTRA_8X8_DIAG_DOWN_LEFT
+.export label INTRA_8X8_DIAG_DOWN_RIGHT
+.export label INTRA_8X8_VERT_RIGHT
+.export label INTRA_8X8_HOR_DOWN
+.export label INTRA_8X8_VERT_LEFT
+.export label INTRA_8X8_HOR_UP
+
+.export label INTRA_4X4_VERTICAL
+.export label INTRA_4X4_HORIZONTAL
+.export label INTRA_4X4_DC
+.export label INTRA_4X4_DIAG_DOWN_LEFT
+.export label INTRA_4X4_DIAG_DOWN_RIGHT
+.export label INTRA_4X4_VERT_RIGHT
+.export label INTRA_4X4_HOR_DOWN
+.export label INTRA_4X4_VERT_LEFT
+.export label INTRA_4X4_HOR_UP
+
+.export label INTRA_CHROMA_DC
+.export label INTRA_CHROMA_HORIZONTAL
+.export label INTRA_CHROMA_VERTICAL
+.export label INTRA_Chroma_PLANE
+
+.export label intra_Pred_4x4_Y
+.export label ADD_ERROR_SB0
+.export label ADD_ERROR_SB1
+.export label ADD_ERROR_SB2
+.export label ADD_ERROR_SB3
+
+.export label AllAVC_END
+
+#ifdef SW_SCOREBOARD    
+.export label MB_Loop
+.export label No_Message
+.export label Dependency_Check
+.export label Notify_MSG
+.export label Update_CurMB
+.export label MBAFF_MB_Loop
+.export label MBAFF_No_Message
+.export label MBAFF_Dependency_Check
+.export label MBAFF_Notify_MSG
+.export label MBAFF_Update_CurMB
+
+//.export label 
+
+// Definitions for first pass MC kernel building
+#ifndef No_Message_IP
+#define No_Message_IP	0
+#endif
+
+#ifndef Dependency_Check_IP
+#define Dependency_Check_IP	0
+#endif
+
+#ifndef Notify_MSG_IP
+#define Notify_MSG_IP	0
+#endif
+
+#ifndef Update_CurMB_IP
+#define Update_CurMB_IP	0
+#endif
+
+#ifndef MBAFF_No_Message_IP
+#define MBAFF_No_Message_IP	0
+#endif
+
+#ifndef MBAFF_Dependency_Check_IP
+#define MBAFF_Dependency_Check_IP	0
+#endif
+
+#ifndef MBAFF_Notify_MSG_IP
+#define MBAFF_Notify_MSG_IP	0
+#endif
+
+#ifndef	AS_ENABLED
+ #ifndef MBAFF_MB_Loop_IP
+ #define MBAFF_MB_Loop_IP	0
+ #endif
+
+ #ifndef MB_Loop_IP
+ #define MB_Loop_IP	0
+ #endif
+#endif	// End AS_ENABLED
+
+#ifndef MBAFF_Update_CurMB_IP
+#define MBAFF_Update_CurMB_IP	0
+#endif
+
+#endif	// SW_SCOREBOARD
+/*
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+
+#ifdef ENABLE_ILDB
+.export label	ALL_SPAWNED_UV_ILDB_FRAME
+.export label	SLEEP_ENTRY_UV_ILDB_FRAME
+.export label	POST_SLEEP_UV_ILDB_FRAME
+.export label	ALL_SPAWNED_Y_ILDB_FRAME
+.export label	SLEEP_ENTRY_Y_ILDB_FRAME
+.export label	POST_SLEEP_Y_ILDB_FRAME
+
+// Definitions for first pass ILDB kernel building
+#ifndef	ALL_SPAWNED_UV_ILDB_FRAME_IP
+#define	ALL_SPAWNED_UV_ILDB_FRAME_IP	0
+#endif
+
+#ifndef	SLEEP_ENTRY_UV_ILDB_FRAME_IP
+#define	SLEEP_ENTRY_UV_ILDB_FRAME_IP	0
+#endif
+
+#ifndef	POST_SLEEP_UV_ILDB_FRAME_IP
+#define	POST_SLEEP_UV_ILDB_FRAME_IP	0
+#endif
+
+#ifndef	ALL_SPAWNED_Y_ILDB_FRAME_IP
+#define	ALL_SPAWNED_Y_ILDB_FRAME_IP	0
+#endif
+
+#ifndef	SLEEP_ENTRY_Y_ILDB_FRAME_IP
+#define	SLEEP_ENTRY_Y_ILDB_FRAME_IP	0
+#endif
+
+#ifndef	POST_SLEEP_Y_ILDB_FRAME_IP
+#define	POST_SLEEP_Y_ILDB_FRAME_IP	0
+#endif
+
+#endif	// ENABLE_ILDB
diff --git a/i965_drv_video/shaders/h264/mc/AllIntra.asm b/i965_drv_video/shaders/h264/mc/AllIntra.asm
new file mode 100644
index 0000000..1cc895a
--- /dev/null
+++ b/i965_drv_video/shaders/h264/mc/AllIntra.asm
@@ -0,0 +1,68 @@
+/*
+ * All intra-prediction macroblock kernels 
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+//	2857702934	// 0xAA551616 - GUID for Intra_16x16 luma prediction mode offsets
+//    0    // Offset to Intra_16x16 luma prediction mode 0
+//    9    // Offset to Intra_16x16 luma prediction mode 1
+//   19    // Offset to Intra_16x16 luma prediction mode 2
+//   42    // Offset to Intra_16x16 luma prediction mode 3
+//	2857699336	// 0xAA550808 - GUID for Intra_8x8 luma prediction mode offsets
+//    0    // Offset to Intra_8x8 luma prediction mode 0
+//    5    // Offset to Intra_8x8 luma prediction mode 1
+//   10    // Offset to Intra_8x8 luma prediction mode 2
+//   26    // Offset to Intra_8x8 luma prediction mode 3
+//   36    // Offset to Intra_8x8 luma prediction mode 4
+//   50    // Offset to Intra_8x8 luma prediction mode 5
+//   68    // Offset to Intra_8x8 luma prediction mode 6
+//   85    // Offset to Intra_8x8 luma prediction mode 7
+//   95    // Offset to Intra_8x8 luma prediction mode 8
+//	2857698308	// 0xAA550404 - GUID for Intra_4x4 luma prediction mode offsets
+//    0    // Offset to Intra_4x4 luma prediction mode 0
+//    2    // Offset to Intra_4x4 luma prediction mode 1
+//    4    // Offset to Intra_4x4 luma prediction mode 2
+//   16    // Offset to Intra_4x4 luma prediction mode 3
+//   23    // Offset to Intra_4x4 luma prediction mode 4
+//   32    // Offset to Intra_4x4 luma prediction mode 5
+//   45    // Offset to Intra_4x4 luma prediction mode 6
+//   59    // Offset to Intra_4x4 luma prediction mode 7
+//   66    // Offset to Intra_4x4 luma prediction mode 8
+//	2857700364	// 0xAA550C0C - GUID for intra chroma prediction mode offsets
+//    0    // Offset to intra chroma prediction mode 0
+//   30    // Offset to intra chroma prediction mode 1
+//   36    // Offset to intra chroma prediction mode 2
+//   41    // Offset to intra chroma prediction mode 3
+
+// Kernel name: AllIntra.asm
+//
+// All HWMC kernels merged into this file
+//
+//  $Revision: 1 $
+//  $Date: 4/13/06 4:35p $
+//
+
+// ----------------------------------------------------
+//  Main: ALLINTRA
+// ----------------------------------------------------
+
+#define	ALLHWMC
+#define	COMBINED_KERNEL
+
+.kernel ALLINTRA
+
+    // All frame destination HWMC kernels
+    //
+    #include "Intra_PCM.asm"
+    #include "Intra_16x16.asm"
+    #include "Intra_8x8.asm"
+    #include "Intra_4x4.asm"
+
+// End of ALLINTRA
+
+.end_kernel
+
diff --git a/i965_drv_video/shaders/h264/mc/BSDReset.asm b/i965_drv_video/shaders/h264/mc/BSDReset.asm
new file mode 100644
index 0000000..5c6e5df
--- /dev/null
+++ b/i965_drv_video/shaders/h264/mc/BSDReset.asm
@@ -0,0 +1,43 @@
+/*
+ * Initial kernel for filling initial BSD command buffer
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+// Kernel name: BSDReset.asm
+//
+// Initial kernel for filling initial BSD command buffer
+//
+
+// ----------------------------------------------------
+//  Main: BSDReset
+// ----------------------------------------------------
+
+.kernel BSDReset
+BSDRESET:
+
+#include "header.inc"
+
+.code
+#ifdef SW_SCOREBOARD
+    CALL(scoreboard_start_inter,1)
+	wait	n0:ud		//	Now wait for scoreboard to response
+
+#define BSDRESET_ENABLE
+	#include "scoreboard_update.asm"	// scorboard update function
+#undef BSDRESET_ENABLE
+
+#endif	// defined(SW_SCOREBOARD)
+
+// Terminate the thread
+//
+    END_THREAD
+
+#if !defined(COMBINED_KERNEL)		// For standalone kernel only
+.end_code
+
+.end_kernel
+#endif	// !defined(COMBINED_KERNEL)
diff --git a/i965_drv_video/shaders/h264/mc/DCResetDummy.asm b/i965_drv_video/shaders/h264/mc/DCResetDummy.asm
new file mode 100644
index 0000000..d4e52a9
--- /dev/null
+++ b/i965_drv_video/shaders/h264/mc/DCResetDummy.asm
@@ -0,0 +1,34 @@
+/*
+ * Dummy kernel
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+// Kernel name: DCResetDummy.asm
+//
+// Dummy kernel used by driver for debug-counter reset SW WA
+//
+
+// ----------------------------------------------------
+//  Main: DCResetDummy
+// ----------------------------------------------------
+
+.kernel DCResetDummy
+DCRESETDUMMY:
+
+#include "header.inc"
+
+.code
+
+// Terminate the thread
+//
+    END_THREAD
+
+#if !defined(COMBINED_KERNEL)		// For standalone kernel only
+.end_code
+
+.end_kernel
+#endif	// !defined(COMBINED_KERNEL)
diff --git a/i965_drv_video/shaders/h264/mc/Decode_Chroma_Intra.asm b/i965_drv_video/shaders/h264/mc/Decode_Chroma_Intra.asm
new file mode 100644
index 0000000..7799825
--- /dev/null
+++ b/i965_drv_video/shaders/h264/mc/Decode_Chroma_Intra.asm
@@ -0,0 +1,29 @@
+/*
+ * Decode both intra chroma blocks
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+#if !defined(__DECODE_CHROMA_INTRA__)		// Make sure this is only included once
+#define __DECODE_CHROMA_INTRA__
+
+// Module name: Decode_Chroma_Intra.asm
+//
+// Decode both intra chroma blocks
+//
+
+decode_Chroma_Intra:
+#ifndef MONO
+    #include "load_Intra_Ref_UV.asm"	// Load intra U/V reference data
+    #include "intra_Pred_Chroma.asm"	// Intra predict chroma blocks
+    #include "add_Error_UV.asm"			// Add error data to predicted U/V data blocks
+#endif	// !defined(MONO)
+    #include "save_8x8_UV.asm"			// Save to destination U/V frame surface
+
+	RETURN
+// End of Decode_Chroma_Intra
+
+#endif	// !defined(__DECODE_CHROMA_INTRA__)
diff --git a/i965_drv_video/shaders/h264/mc/EndIntraThread.asm b/i965_drv_video/shaders/h264/mc/EndIntraThread.asm
new file mode 100644
index 0000000..2c78b62
--- /dev/null
+++ b/i965_drv_video/shaders/h264/mc/EndIntraThread.asm
@@ -0,0 +1,30 @@
+/*
+ * Common module to end current intra thread
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+// Kernel name: EndIntraThread.asm
+//
+// Common module to end current intra thread
+//
+#ifndef SW_SCOREBOARD
+// Check for write commit first if SW scoreboard is disabled
+	mov	(1)	REG_WRITE_COMMIT_Y<1>:ud	REG_WRITE_COMMIT_Y<0;1,0>:ud		// Make sure Y write is committed
+	mov	(1)	REG_WRITE_COMMIT_UV<1>:ud	REG_WRITE_COMMIT_UV<0;1,0>:ud		// Make sure U/V write is committed
+#endif
+
+	END_THREAD
+
+    #include "Intra_funcLib.asm"
+
+#ifndef COMBINED_KERNEL		// For standalone kernel only
+.end_code
+
+.end_kernel
+#endif	// COMBINED_KERNEL
+
+// End of EndIntraThread
diff --git a/i965_drv_video/shaders/h264/mc/HwmcOnlyHeader.inc b/i965_drv_video/shaders/h264/mc/HwmcOnlyHeader.inc
new file mode 100644
index 0000000..514cb78
--- /dev/null
+++ b/i965_drv_video/shaders/h264/mc/HwmcOnlyHeader.inc
@@ -0,0 +1,29 @@
+/*
+ * Header file used only in HWMC_ONLY mode
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+// Module name: HwmcOnlyHeader.inc
+//
+// Header file used only in HWMC_ONLY mode
+//
+
+#include "header.inc"
+
+#if !defined(__HWMCONLYHEADER__)	// Make sure the following are only included once
+#define __HWMCONLYHEADER__
+
+.reg_count_total    64
+.reg_count_payload  2
+
+//
+//  Now, begin source code....
+//
+
+.code
+#endif	// !defined(__HWMCONLYHEADER__)
+
diff --git a/i965_drv_video/shaders/h264/mc/Intra_16x16.asm b/i965_drv_video/shaders/h264/mc/Intra_16x16.asm
new file mode 100644
index 0000000..e40e6a3
--- /dev/null
+++ b/i965_drv_video/shaders/h264/mc/Intra_16x16.asm
@@ -0,0 +1,71 @@
+/*
+ * Decode Intra_16x16 macroblock
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+// Kernel name: Intra_16x16.asm
+//
+// Decoding of Intra_16x16 macroblock
+//
+//  $Revision: 8 $
+//  $Date: 10/18/06 4:10p $
+//
+
+// ----------------------------------------------------
+//  Main: Intra_16x16
+// ----------------------------------------------------
+
+#define	INTRA_16X16
+
+.kernel Intra_16x16
+INTRA_16x16:
+
+#ifdef _DEBUG
+// WA for FULSIM so we'll know which kernel is being debugged
+mov (1) acc0:ud 0x00aa55a5:ud
+#endif
+
+#include "SetupForHWMC.asm"
+
+#ifdef SW_SCOREBOARD    
+    CALL(scoreboard_start_intra,1)
+#endif
+
+#ifdef SW_SCOREBOARD 
+	wait	n0:ud		//	Now wait for scoreboard to response
+#endif
+
+//
+//  Decode Y blocks
+//
+//	Load reference data from neighboring macroblocks
+    CALL(load_Intra_Ref_Y,1)
+
+//	Intra predict Intra_16x16 luma block
+	#include "intra_pred_16x16_Y.asm"
+
+//	Add error data to predicted intra data
+	#include "add_Error_16x16_Y.asm"
+
+//	Save decoded Y picture
+	CALL(save_16x16_Y,1)
+//
+//  Decode U/V blocks
+//
+//	Note: The decoding for chroma blocks will be the same for all intra prediction mode
+//
+	CALL(decode_Chroma_Intra,1)
+
+#ifdef SW_SCOREBOARD
+    #include "scoreboard_update.asm"
+#endif
+
+// Terminate the thread
+//
+    #include "EndIntraThread.asm"
+
+// End of Intra_16x16
diff --git a/i965_drv_video/shaders/h264/mc/Intra_4x4.asm b/i965_drv_video/shaders/h264/mc/Intra_4x4.asm
new file mode 100644
index 0000000..1169983
--- /dev/null
+++ b/i965_drv_video/shaders/h264/mc/Intra_4x4.asm
@@ -0,0 +1,175 @@
+/*
+ * Decode Intra_4x4 macroblock
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+// Kernel name: Intra_4x4.asm
+//
+// Decoding of Intra_4x4 macroblock
+//
+//  $Revision: 12 $
+//  $Date: 10/18/06 4:10p $
+//
+
+// ----------------------------------------------------
+//  Main: Intra_4x4
+// ----------------------------------------------------
+
+#define	INTRA_4X4
+
+.kernel Intra_4x4
+INTRA_4x4:
+
+#ifdef _DEBUG
+// WA for FULSIM so we'll know which kernel is being debugged
+mov (1) acc0:ud 0x02aa55a5:ud
+#endif
+
+#include "SetupForHWMC.asm"
+
+#undef		PPREDBUF_Y
+#define	    PPREDBUF_Y		a0.3	// Pointer to predicted Y picture
+
+#define		REG_INTRA_PRED_AVAIL	REG_INTRA_TEMP_4
+#define		REG_INTRA_4X4_PRED		REG_INTRA_TEMP_7		// Store predicted Intra_4x4 data
+
+// Offset where 4x4 predicted data blocks are stored
+#define	PREDSUBBLK0		0*GRFWIB
+#define	PREDSUBBLK1		1*GRFWIB
+#define	PREDSUBBLK2		2*GRFWIB
+#define	PREDSUBBLK3		3*GRFWIB
+#define	PREDSUBBLK4		4*GRFWIB
+#define	PREDSUBBLK5		5*GRFWIB
+#define	PREDSUBBLK6		6*GRFWIB
+#define	PREDSUBBLK7		7*GRFWIB
+#define	PREDSUBBLK8		8*GRFWIB
+#define	PREDSUBBLK9		9*GRFWIB
+#define	PREDSUBBLK10	10*GRFWIB
+#define	PREDSUBBLK11	11*GRFWIB
+#define	PREDSUBBLK12	12*GRFWIB
+#define	PREDSUBBLK13	13*GRFWIB
+#define	PREDSUBBLK14	14*GRFWIB
+#define	PREDSUBBLK15	15*GRFWIB
+
+// 4x4 error block byte offset within the 8x8 error block
+#define ERRBLK0		0
+#define ERRBLK1		8
+#define ERRBLK2		64
+#define ERRBLK3		72
+
+#ifdef SW_SCOREBOARD    
+    CALL(scoreboard_start_intra,1)
+#endif
+
+#ifdef SW_SCOREBOARD    
+	wait	n0:ud		//	Now wait for scoreboard to response
+#endif
+
+//
+//  Decode Y blocks
+//
+//	Load reference data from neighboring macroblocks
+    CALL(load_Intra_Ref_Y,1)
+
+	mov	(1)	PERROR<1>:w	ERRBUF*GRFWIB:w			// Pointer to macroblock error data
+	mov	(1)	PPREDBUF_Y<1>:w	PREDBUF*GRFWIB:w	// Pointer to predicted data
+	shr (2)	REG_INTRA_PRED_AVAIL<1>:w	REG_INTRA_PRED_AVAIL_FLAG_BYTE<0;1,0>:ub	0x40:v
+    and.nz.f0.0 (8)	NULLREG	REG_INTRA_PRED_AVAIL_FLAG_BYTE<0;1,0>:ub	4:w	// Top-right macroblock available for intra prediction?
+	(-f0.0.any8h) mov (8)	INTRA_REF_TOP(0,16)<1>	INTRA_REF_TOP(0,15)REGION(1,0)	// Extend right boundary of MB B to C
+
+//	Intra predict Intra_4x4 luma blocks
+//
+//	Sub-macroblock 0 *****************
+	mov	(16)	REF_TOP0(0)<1>	INTRA_REF_TOP0(0)	// Top reference data
+	mov	(8)		REF_LEFT(0)<1>	INTRA_REF_LEFT(0)REGION(8,4)	// Left reference data
+	shr	(4)		PRED_MODE<1>:w	INTRA_PRED_MODE(0)<1;2,0>	0x4040:v	// Expand IntraPredMode to 1 byte/block
+	CALL(intra_Pred_4x4_Y_4,1)
+    add (1)		PERROR<1>:w	PERROR<0;1,0>:w	0x0080:w	// Pointers to next error block
+
+	or  (1)	REG_INTRA_PRED_AVAIL<1>:w	REG_INTRA_PRED_AVAIL<0;1,0>:w	0x1:w	// Left neighbor is available now
+
+//	Sub-macroblock 1 *****************
+
+	mov	(16)	REF_TOP0(0)<1>	INTRA_REF_TOP0(0,8)	// Top reference data
+	mov	(4)		REF_LEFT(0)<1>	r[PPREDBUF_Y,PREDSUBBLK1+6]<8;1,0>:ub	// Left reference data (top half)
+	mov	(4)		REF_LEFT(0,4)<1>	r[PPREDBUF_Y,PREDSUBBLK3+6]<8;1,0>:ub	// Left reference data (bottom half)
+	shr	(4)		PRED_MODE<1>:w	INTRA_PRED_MODE(0,2)<1;2,0>	0x4040:v	// Expand IntraPredMode to 1 byte/block
+	add	(1)		PPREDBUF_Y<1>:w	PPREDBUF_Y<0;1,0>:w	4*GRFWIB:w	// Pointer to predicted sub-macroblock 1
+	CALL(intra_Pred_4x4_Y_4,1)
+    add (1)		PERROR<1>:w	PERROR<0;1,0>:w	0x0080:w	// Pointers to next error block
+
+	or  (1)	REG_INTRA_PRED_AVAIL<1>:w	REG_INTRA_PRED_AVAIL.1<0;1,0>:w	0x2:w	// Top neighbor is available now
+
+//	Pack constructed data from word-aligned to byte-aligned format
+//	to speed up save_4x4_Y module later
+//	PPREDBUF_Y now points to sub-block #4
+	mov (16)	r[PPREDBUF_Y,-PREDSUBBLK4]<1>:ub	r[PPREDBUF_Y,-PREDSUBBLK4]<32;16,2>:ub		// Sub-block 0
+	mov (16)	r[PPREDBUF_Y,0-PREDSUBBLK4+16]<1>:ub	r[PPREDBUF_Y,-PREDSUBBLK3]<32;16,2>:ub	// Sub-block 1
+	mov (16)	r[PPREDBUF_Y,-PREDSUBBLK2]<1>:ub	r[PPREDBUF_Y,-PREDSUBBLK2]<32;16,2>:ub		// Sub-block 2
+	mov (16)	r[PPREDBUF_Y,0-PREDSUBBLK2+16]<1>:ub	r[PPREDBUF_Y,-PREDSUBBLK1]<32;16,2>:ub	// Sub-block 3
+
+	mov (16)	r[PPREDBUF_Y,-PREDSUBBLK3]<1>:ub	r[PPREDBUF_Y]<32;16,2>:ub				// Sub-block 4
+	mov (16)	r[PPREDBUF_Y,0-PREDSUBBLK3+16]<1>:ub	r[PPREDBUF_Y,PREDSUBBLK1]<32;16,2>:ub	// Sub-block 5
+	mov (16)	r[PPREDBUF_Y,-PREDSUBBLK1]<1>:ub	r[PPREDBUF_Y,PREDSUBBLK2]<32;16,2>:ub		// Sub-block 6
+	mov (16)	r[PPREDBUF_Y,0-PREDSUBBLK1+16]<1>:ub	r[PPREDBUF_Y,PREDSUBBLK3]<32;16,2>:ub	// Sub-block 7
+
+//	Sub-macroblock 2 *****************
+
+	mov	(4)		REF_TOP0(0)<1>		INTRA_REF_LEFT0(0,28)REGION(4,1)		// Top-left reference data
+	mov	(8)		REF_TOP0(0,4)<1>	r[PPREDBUF_Y,0-2*GRFWIB+12]<16;4,1>:ub	// Top reference data from SB 2,3
+	mov	(8)		REF_TOP0(0,12)<1>	r[PPREDBUF_Y,0-GRFWIB+12]<16;4,1>:ub	// Top reference data from SB 6,7
+	mov	(8)		REF_TOP0(0,20)<1>	r[PPREDBUF_Y,0-GRFWIB+31]<0;1,0>:ub		// Top-right reference data
+	mov	(16)	REG_INTRA_REF_TOP<1>:w	REF_TOP_W(0)		// Store top reference data for SubMB #2 and #3.
+	mov	(8)		REF_LEFT(0)<1>		INTRA_REF_LEFT(1)REGION(8,4)	// Left reference data
+	shr	(4)		PRED_MODE<1>:w		INTRA_PRED_MODE(0,4)<1;2,0>	0x4040:v	// Expand IntraPredMode to 1 byte/block
+	CALL(intra_Pred_4x4_Y_4,1)
+    add (1)		PERROR<1>:w	PERROR<0;1,0>:w	0x0080:w	// Pointers to next error block
+
+	or  (1)	REG_INTRA_PRED_AVAIL<1>:w	REG_INTRA_PRED_AVAIL<0;1,0>:w	0x1:w	// Left neighbor is available now
+
+//	Sub-macroblock 3 *****************
+
+	mov	(16)	REF_TOP0(0)<1>	INTRA_REF_TOP0(0,8)		// Top reference data
+	mov	(8)		REF_TOP0(0,16)<1>	INTRA_REF_TOP0(0,24)REGION(8,1)	// Top reference data
+	mov	(4)		REF_LEFT(0)<1>	r[PPREDBUF_Y,PREDSUBBLK1+6]<8;1,0>:ub	// Left reference data (top half)
+	mov	(4)		REF_LEFT(0,4)<1>	r[PPREDBUF_Y,PREDSUBBLK3+6]<8;1,0>:ub	// Left reference data (bottom half)
+	shr	(4)		PRED_MODE<1>:w	INTRA_PRED_MODE(0,6)<1;2,0>	0x4040:v	// Expand IntraPredMode to 1 byte/block
+	add	(1)		PPREDBUF_Y<1>:w	PPREDBUF_Y<0;1,0>:w	4*GRFWIB:w	// Pointer to predicted sub-macroblock 3
+	CALL(intra_Pred_4x4_Y_4,1)
+
+//	Pack constructed data from word-aligned to byte-aligned format
+//	to speed up save_4x4_Y module later
+//	PPREDBUF_Y now points to sub-block #12
+	mov (16)	r[PPREDBUF_Y,-PREDSUBBLK4]<1>:ub	r[PPREDBUF_Y,-PREDSUBBLK4]<32;16,2>:ub		// Sub-block 8
+	mov (16)	r[PPREDBUF_Y,0-PREDSUBBLK4+16]<1>:ub	r[PPREDBUF_Y,-PREDSUBBLK3]<32;16,2>:ub	// Sub-block 9
+	mov (16)	r[PPREDBUF_Y,-PREDSUBBLK2]<1>:ub	r[PPREDBUF_Y,-PREDSUBBLK2]<32;16,2>:ub		// Sub-block 10
+	mov (16)	r[PPREDBUF_Y,0-PREDSUBBLK2+16]<1>:ub	r[PPREDBUF_Y,-PREDSUBBLK1]<32;16,2>:ub	// Sub-block 11
+
+	mov (16)	r[PPREDBUF_Y,-PREDSUBBLK3]<1>:ub	r[PPREDBUF_Y]<32;16,2>:ub				// Sub-block 12
+	mov (16)	r[PPREDBUF_Y,0-PREDSUBBLK3+16]<1>:ub	r[PPREDBUF_Y,PREDSUBBLK1]<32;16,2>:ub	// Sub-block 13
+	mov (16)	r[PPREDBUF_Y,-PREDSUBBLK1]<1>:ub	r[PPREDBUF_Y,PREDSUBBLK2]<32;16,2>:ub		// Sub-block 14
+	mov (16)	r[PPREDBUF_Y,0-PREDSUBBLK1+16]<1>:ub	r[PPREDBUF_Y,PREDSUBBLK3]<32;16,2>:ub	// Sub-block 15
+
+//	All 4 sub-macroblock (containing 4 intra_4x4 blocks) have be constructed
+//	Save constructed Y picture
+	CALL(save_4x4_Y,1)		// Save Intra_4x4 predicted luma data.
+//
+//  Decode U/V blocks
+//
+//	Note: The decoding for chroma blocks will be the same for all intra prediction mode
+//
+	CALL(decode_Chroma_Intra,1)
+
+#ifdef SW_SCOREBOARD
+    #include "scoreboard_update.asm"
+#endif
+
+// Terminate the thread
+//
+    #include "EndIntraThread.asm"
+
+// End of Intra_4x4
diff --git a/i965_drv_video/shaders/h264/mc/Intra_8x8.asm b/i965_drv_video/shaders/h264/mc/Intra_8x8.asm
new file mode 100644
index 0000000..05a0be5
--- /dev/null
+++ b/i965_drv_video/shaders/h264/mc/Intra_8x8.asm
@@ -0,0 +1,192 @@
+/*
+ * Decode Intra_8x8 macroblock
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+// Kernel name: Intra_8x8.asm
+//
+// Decoding of Intra_8x8 macroblock
+//
+//  $Revision: 12 $
+//  $Date: 10/18/06 4:10p $
+//
+
+// ----------------------------------------------------
+//  Main: Intra_8x8
+// ----------------------------------------------------
+
+#define	INTRA_8X8
+
+.kernel Intra_8x8
+INTRA_8x8:
+
+#ifdef _DEBUG
+// WA for FULSIM so we'll know which kernel is being debugged
+mov (1) acc0:ud 0x01aa55a5:ud
+#endif
+
+#include "SetupForHWMC.asm"
+
+#define		REG_INTRA_PRED_AVAIL	REG_INTRA_TEMP_4
+#define		INTRA_PRED_AVAIL		REG_INTRA_TEMP_4.4
+
+// Offset where 8x8 predicted data blocks are stored
+#define	PREDBLK0	0*GRFWIB
+#define	PREDBLK1	4*GRFWIB
+#define	PREDBLK2	8*GRFWIB
+#define	PREDBLK3	12*GRFWIB
+
+#ifdef SW_SCOREBOARD
+
+// Update "E" flag with "F" flag information
+	mov (1)	REG_INTRA_TEMP_0<1>:w	REG_INTRA_PRED_AVAIL_FLAG_WORD<0;1,0>:w		// Store original Intra_Pred_Avail_Flag
+	and.nz.f0.0 (1)	NULLREG	REG_MBAFF_PIC	MBAFF_PIC	// Is current MBAFF picture
+	and.z.f0.1 (1) NULLREG	REG_INTRA_PRED_AVAIL_FLAG	INTRA_PRED_LEFT_TH_AVAIL_FLAG	// Is "A" not available?
+	(f0.0) and.z.f0.0 (1) NULLREG	REG_FIELD_MACROBLOCK_FLAG	FIELD_MACROBLOCK_FLAG	// Is current frame MB?
+	(f0.1) and.nz.f0.1 (1) NULLREG	REG_INTRA_PRED_8X8_BLK2_AVAIL_FLAG	INTRA_PRED_8X8_BLK2_AVAIL_FLAG	// Is "F" flag set?
+	(f0.0.allv) or (1)	REG_INTRA_PRED_AVAIL_FLAG_WORD<1>:w	REG_INTRA_PRED_AVAIL_FLAG_WORD<0;1,0>:w	INTRA_PRED_LEFT_BH_AVAIL_FLAG	// Set "E" to 1 if all conditions meet
+
+    CALL(scoreboard_start_intra,1)
+	mov (1)	REG_INTRA_PRED_AVAIL_FLAG_WORD<1>:w	REG_INTRA_TEMP_0<0;1,0>:w		// Restore original Intra_Pred_Avail_Flag
+#endif
+
+#ifdef SW_SCOREBOARD    
+	wait	n0:ud		//	Now wait for scoreboard to response
+#endif
+
+//
+//  Decode Y blocks
+//
+//	Load reference data from neighboring macroblocks
+    CALL(load_Intra_Ref_Y,1)
+
+	mov	(1)	PERROR<1>:w	ERRBUF*GRFWIB:w			// Pointer to macroblock error data
+	mov	(1)	PDECBUF_UD<1>:ud	0x00010001*PREDBUF*GRFWIB+0x00100000:ud	// Pointers to predicted data
+	shr (2)	REG_INTRA_PRED_AVAIL<1>:w	REG_INTRA_PRED_AVAIL_FLAG_BYTE<0;1,0>:ub	0x40:v
+	
+#if 1
+	mov (4) REF_LEFT_D(0,0)<1>	0:ud		// This is to make validation easier. Without it, DRAM mismatch occurs.
+#endif
+
+//	Intra predict Intra_8x8 luma blocks
+//
+//	Sub-macroblock 0 *****************
+	mov	(16)	REF_TOP_W(0)<1>	REG_INTRA_REF_TOP<16;16,1>:w		// Copy entire top reference data
+	and.nz.f0.0 (8)	NULLREG		REG_INTRA_PRED_AVAIL_FLAG	INTRA_PRED_UP_LEFT_AVAIL_FLAG	// Is "D" available?
+	(-f0.0) mov (1)	REF_TOP(0,-1)<1>	INTRA_REF_TOP(0)REGION(1,0)		// p[-1,-1] = p[0,-1]
+
+	mov	(8)		REF_LEFT(0,2)<1>	INTRA_REF_LEFT(0)	// Left reference data, (leave 2 for reference filtering)
+	(-f0.0) mov (1)		REF_LEFT(0,1)<1>	INTRA_REF_LEFT(0)REGION(1,0)			// p[-1,-1]=p[-1,0]
+	(f0.0.any2h)  mov (2)		REF_LEFT(0,0)<1>	INTRA_REF_TOP(0,-1)REGION(1,0)	// p'[-1,y] (y=0,1) = p[-1,-1]
+	and.nz.f0.1 (1)	NULLREG		REG_INTRA_PRED_AVAIL_FLAG	INTRA_PRED_UP_AVAIL_FLAG	// Is "B" available?
+	(f0.1) mov	(1)		REF_LEFT(0,0)<1>	INTRA_REF_TOP(0,0)REGION(1,0)	// p[0,-1] for left filtering
+	and.nz.f0.1 (1)	NULLREG		REG_INTRA_PRED_AVAIL_FLAG	INTRA_PRED_LEFT_TH_AVAIL_FLAG	// Is "A" available?
+	(-f0.1) mov	(1)		REF_LEFT(0,2)<1>	INTRA_REF_TOP(0,-1)REGION(1,0)	// p'[-1,2] = p[-1,-1]
+
+	and	(1)		PRED_MODE<1>:w	INTRA_PRED_MODE(0)REGION(1,0)	0x0F:w		// Intra pred mode for current block
+	mov (1)		INTRA_PRED_AVAIL<1>:w	REG_INTRA_PRED_AVAIL<0;1,0>:w		// Top/Left neighbor available flags
+	CALL(intra_Pred_8x8_Y,1)
+    add (1)		PERROR<1>:w	PERROR<0;1,0>:w	0x0080:w	// Pointers to next error block
+
+//	Sub-macroblock 1 *****************
+	mov	(16)	REF_TOP0(0)<1>	INTRA_REF_TOP(0,4)	// Top reference data
+	and.nz.f0.1 (8)	NULLREG		REG_INTRA_PRED_AVAIL_FLAG	INTRA_PRED_UP_RIGHT_AVAIL_FLAG	// Is "C" available?
+	(f0.1.any8h)  mov (8)	REF_TOP(0,8)<1>	INTRA_REF_TOP(0,16)<8;8,1>		// Take data from "C"
+	(-f0.1.any8h) mov (8)	REF_TOP(0,8)<1>	INTRA_REF_TOP(0,15)REGION(1,0)	// Repeat last pixel from "B"
+
+	mov	(4)		REF_LEFT(0,2)<1>	DEC_Y(0,14)<16;1,0>		// Left reference data (top half) (leave 2 for reference filtering)
+	mov	(4)		REF_LEFT(0,6)<1>	DEC_Y(2,14)<16;1,0>		// Left reference data (bottom half)
+	mov	(2)		REF_LEFT(0,0)<1>	INTRA_REF_TOP(0,7)REGION(1,0)		// p'[-1,y] (y=0,1) = p[-1,-1]
+	and.nz.f0.1 (1)	NULLREG		REG_INTRA_PRED_AVAIL_FLAG	INTRA_PRED_UP_AVAIL_FLAG	// Is "B" available?
+	(f0.1)  mov	(1)		REF_LEFT(0,0)<1>	INTRA_REF_TOP(0,8)REGION(1,0)	// p[-1,-1] for left filtering
+	(-f0.1) mov	(1)		REF_LEFT(0,1)<1>	DEC_Y(0,14)REGION(1,0)	// p[-1,-1] = p[-1,0]
+
+	shr	(1)		PRED_MODE<1>:w	INTRA_PRED_MODE(0)REGION(1,0)	4:w		// Intra pred mode for current block
+	add	(2)		PPREDBUF_Y<1>:w	PPREDBUF_Y<2;2,1>:w	4*GRFWIB:w			// Pointer to predicted sub-macroblock 1
+	or (1)		INTRA_PRED_AVAIL<1>:w	REG_INTRA_PRED_AVAIL<0;1,0>:w	1:w		// Left neighbor is available
+	CALL(intra_Pred_8x8_Y,1)
+    add (1)		PERROR<1>:w	PERROR<0;1,0>:w	0x0080:w	// Pointers to next error block
+
+//	Pack constructed data from word-aligned to byte-aligned format and interlace Y0 and Y1(every two Y rows)
+//	to speed up save_8x8_Y module later
+//	PPREDBUF_Y now points to sub-macroblock Y1
+	mov (32)	r[PPREDBUF_Y,-PREDBLK1]<1>:ub		DEC_Y(0)<32;16,2> {Compr}	// First 4 Y0 rows
+	mov (32)	r[PPREDBUF_Y,0-PREDBLK1+32]<1>:ub	DEC_Y(4)<32;16,2> {Compr}	// First 4 Y1 rows
+	mov (32)	r[PPREDBUF_Y,0-PREDBLK1+64]<1>:ub	DEC_Y(2)<32;16,2> {Compr}	// Second 4 Y0 rows
+	mov (32)	r[PPREDBUF_Y,0-PREDBLK1+96]<1>:ub	DEC_Y(6)<32;16,2> {Compr}	// Second 4 Y1 rows
+
+//	Sub-macroblock 2 *****************
+//	Intra_8x8 special available flag handling
+	and.nz.f0.0 (1)	NULLREG	REG_MBAFF_PIC	MBAFF_PIC	// Is current MBAFF picture
+	and.z.f0.1 (1) NULLREG	REG_INTRA_PRED_AVAIL_FLAG	INTRA_PRED_LEFT_TH_AVAIL_FLAG	// Is "A" not available?
+	(f0.0) and.z.f0.0 (1) NULLREG	REG_FIELD_MACROBLOCK_FLAG	FIELD_MACROBLOCK_FLAG	// Is current frame MB?
+	(f0.1) and.nz.f0.1 (1) NULLREG	REG_INTRA_PRED_8X8_BLK2_AVAIL_FLAG	INTRA_PRED_8X8_BLK2_AVAIL_FLAG	// Is special intra_8x8 available flag set?
+	(f0.0.allv) mov (1)	REF_TOP(0,-1)<1>	INTRA_REF_LEFT0(0,31)REGION(1,0)	// Top-left reference data
+	(f0.0.allv) jmpi (1)	INTRA_8x8_BLK2
+//	Done intra_8x8 special available flag handling
+
+	and.nz.f0.0 (8)	NULLREG	REG_INTRA_PRED_AVAIL_FLAG	INTRA_PRED_LEFT_TH_AVAIL_FLAG	// Is top-half "A" available?
+	(f0.0.any4h) mov (4)	REF_TOP0(0)<1>		INTRA_REF_LEFT0(0,28)REGION(4,1)	// Top-left reference data
+	(-f0.0) mov (1)	REF_TOP(0,-1)<1>	DEC_Y(2,24)REGION(1,0)	// p[-1,-1] = p[0,-1]
+INTRA_8x8_BLK2:
+	mov	(8)		REF_TOP(0)<1>		DEC_Y(2,24)REGION(8,1)		// Top reference data
+	mov	(8)		REF_TOP(0,8)<1>		DEC_Y(3,24)REGION(8,1)		// Top reference data
+
+	mov	(8)		REF_LEFT(0,2)<1>	INTRA_REF_LEFT(1)			// Left reference data,  (leave 2 for reference filtering)
+	mov (1)		REF_LEFT(0,0)<1>	DEC_Y(2,24)REGION(1,0)		// p'[-1,0] = p[0,-1] since "B" is always available
+	(f0.0) mov	(1)	REF_LEFT(0,1)<1>	INTRA_REF_LEFT(0,28)REGION(1,0)	// p[-1,1] = p[-1,-1] if top-half "A" available
+	(-f0.0) mov (1)	REF_LEFT(0,1)<1>	INTRA_REF_LEFT(1)REGION(1,0)	// p[-1,1] = p[-1,0]
+	and.nz.f0.1 (1)	NULLREG	REG_INTRA_PRED_AVAIL_FLAG	INTRA_PRED_LEFT_BH_AVAIL_FLAG	// Is bottom-half "A" available?
+	(-f0.1) mov	(1)	REF_LEFT(0,2)<1>	INTRA_REF_LEFT(0,28)REGION(1,0)	// p'[-1,2] = p[-1,-1]
+
+	and	(1)		PRED_MODE<1>:w			INTRA_PRED_MODE(0,1)REGION(1,0)	0x0F:w	// Intra pred mode for current block
+	or (1)		INTRA_PRED_AVAIL<1>:w	REG_INTRA_PRED_AVAIL.1<0;1,0>:w	2:w		// Top neighbor is available
+	CALL(intra_Pred_8x8_Y,1)
+    add (1)		PERROR<1>:w	PERROR<0;1,0>:w	0x0080:w	// Pointers to next error block
+
+//	Sub-macroblock 3 *****************
+	mov	(4)		REF_TOP0(0)<1>		DEC_Y(2,28)REGION(4,1)		// Top-left reference data
+	mov	(8)		REF_TOP(0)<1>		DEC_Y(3,24)REGION(8,1)		// Top reference data
+	mov	(16)	REF_TOP(0,8)<1>		DEC_Y(3,31)REGION(1,0)		// Top-right reference data
+
+	mov (4)		REF_LEFT(0,2)<1>	DEC_Y(4,14)<16;1,0>		// Left reference data (top half) (leave 2 for reference filtering)
+	mov (4)		REF_LEFT(0,6)<1>	DEC_Y(6,14)<16;1,0>		// Left reference data (bottom half)
+	mov (1)		REF_LEFT(0,0)<1>	DEC_Y(3,24)REGION(1,0)	// p[-1,0] = p[0,-1]
+	mov (1)		REF_LEFT(0,1)<1>	DEC_Y(2,31)REGION(1,0)	// p[-1,1] = p[-1,-1]
+
+	shr	(1)		PRED_MODE<1>:w	INTRA_PRED_MODE(0,1)REGION(1,0)	4:w		// Intra pred mode for current block
+	add	(2)		PPREDBUF_Y<1>:w	PPREDBUF_Y<2;2,1>:w	4*GRFWIB:w	// Pointer to predicted sub-macroblock 3
+	or (1)		INTRA_PRED_AVAIL<1>:w	REG_INTRA_PRED_AVAIL<0;1,0>:w	3:w		// Top and Left neighbor are available
+	CALL(intra_Pred_8x8_Y,1)
+
+//	Pack constructed data from word-aligned to byte-aligned format
+//	to speed up save_8x8_Y module later
+//	PPREDBUF_Y now points to sub-macroblock Y1
+	mov (32)	r[PPREDBUF_Y,-PREDBLK1]<1>:ub		DEC_Y(4)<32;16,2> {Compr}	// First 4 Y2 rows
+	mov (32)	r[PPREDBUF_Y,0-PREDBLK1+32]<1>:ub	DEC_Y(8)<32;16,2> {Compr}	// First 4 Y3 rows
+	mov (32)	r[PPREDBUF_Y,0-PREDBLK1+64]<1>:ub	DEC_Y(6)<32;16,2> {Compr}	// Second 4 Y2 rows
+	mov (32)	r[PPREDBUF_Y,0-PREDBLK1+96]<1>:ub	DEC_Y(10)<32;16,2> {Compr}	// Second 4 Y3 rows
+
+//	All 4 sub-macroblock (containing 4 intra_8x8 blocks) have be constructed
+//	Save constructed Y picture
+	CALL(save_8x8_Y,1)		// Save Intra_8x8 predicted luma data.
+//
+//  Decode U/V blocks
+//
+//	Note: The decoding for chroma blocks will be the same for all intra prediction mode
+//
+	CALL(decode_Chroma_Intra,1)
+
+#ifdef SW_SCOREBOARD
+    #include "scoreboard_update.asm"
+#endif
+
+// Terminate the thread
+//
+    #include "EndIntraThread.asm"
+
+// End of Intra_8x8
diff --git a/i965_drv_video/shaders/h264/mc/Intra_PCM.asm b/i965_drv_video/shaders/h264/mc/Intra_PCM.asm
new file mode 100644
index 0000000..6bc81af
--- /dev/null
+++ b/i965_drv_video/shaders/h264/mc/Intra_PCM.asm
@@ -0,0 +1,56 @@
+/*
+ * Decode Intra_PCM macroblock
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+// Kernel name: Intra_PCM.asm
+//
+// Decoding of I_PCM macroblock
+//
+//  $Revision: 8 $
+//  $Date: 10/18/06 4:10p $
+//
+
+// ----------------------------------------------------
+//  Main: Intra_PCM
+// ----------------------------------------------------
+
+.kernel Intra_PCM
+INTRA_PCM:
+
+#ifdef _DEBUG
+// WA for FULSIM so we'll know which kernel is being debugged
+mov (1) acc0:ud 0x03aa55a5:ud
+#endif
+
+#include "SetupForHWMC.asm"
+
+// Not actually needed here but just want to slow down the Intra-PCM to avoid race condition
+//
+#ifdef SW_SCOREBOARD
+	and (1)	  REG_INTRA_PRED_AVAIL_FLAG_WORD<1>:w	REG_INTRA_PRED_AVAIL_FLAG_WORD<0;1,0>:w	0xffe0:w	// Ensure all neighbor avail flags are "0"
+    CALL(scoreboard_start_intra,1)
+	wait	n0:ud		//	Now wait for scoreboard to response
+#endif
+
+//
+//  Decoding Y blocks
+//
+//	In I_PCM mode, the samples are already arranged in raster scan order within the macroblock.
+//	We just need to save them to picture buffers
+//
+    #include "save_I_PCM.asm"		    // Save to destination picture buffers
+
+#ifdef SW_SCOREBOARD    
+    #include "scoreboard_update.asm"
+#endif
+
+// Terminate the thread
+//
+    #include "EndIntraThread.asm"
+
+// End of Intra_PCM
diff --git a/i965_drv_video/shaders/h264/mc/Intra_funcLib.asm b/i965_drv_video/shaders/h264/mc/Intra_funcLib.asm
new file mode 100644
index 0000000..9644f7f
--- /dev/null
+++ b/i965_drv_video/shaders/h264/mc/Intra_funcLib.asm
@@ -0,0 +1,42 @@
+/*
+ * Library of common modules shared among different intra prediction kernels
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+// Module name: Intra_funcLib.asm
+//
+// Library of common modules shared among different intra prediction kernels
+//
+//  Note: Any sub-modules, if they are #included in more than one kernel,
+//	  should be moved to this module.
+//
+#if defined(INTRA_16X16)
+#undef INTRA_16X16
+    #include "load_Intra_Ref_Y.asm"		// Load intra Y reference data
+    #include "Decode_Chroma_Intra.asm"	// Decode chroma blocks
+    #include "save_16x16_Y.asm"			// Save to destination Y frame surface
+#elif defined(INTRA_8X8)
+#undef INTRA_8X8
+    #include "load_Intra_Ref_Y.asm"		// Load intra Y reference data
+    #include "Decode_Chroma_Intra.asm"	// Decode chroma blocks
+    #include "intra_Pred_8x8_Y.asm"		// Intra predict Intra_4x4 blocks
+    #include "save_8x8_Y.asm"			// Save to destination Y frame surface
+#elif defined(INTRA_4X4)
+#undef INTRA_4X4
+    #include "load_Intra_Ref_Y.asm"		// Load intra Y reference data
+    #include "Decode_Chroma_Intra.asm"	// Decode chroma blocks
+    #include "intra_Pred_4x4_Y_4.asm"	// Intra predict Intra_4x4 blocks
+    #include "save_4x4_Y.asm"			// Save to destination Y frame surface
+#else								// For all merged kernels
+#endif
+
+#ifdef SW_SCOREBOARD    
+    #include "scoreboard_start_intra.asm"	// scorboard intra start function	
+    #include "scoreboard_start_inter.asm"	// scorboard inter start function	
+#endif	// SW_SCOREBOARD
+
+// End of Intra_funcLib
diff --git a/i965_drv_video/shaders/h264/mc/Makefile.am b/i965_drv_video/shaders/h264/mc/Makefile.am
new file mode 100644
index 0000000..9f97eb0
--- /dev/null
+++ b/i965_drv_video/shaders/h264/mc/Makefile.am
@@ -0,0 +1,28 @@
+
+INTEL_G4I = 
+
+INTEL_G4A = null.g4a
+
+INTEL_G4B = null.g4b
+
+INTEL_G4B_GEN5 = null.g4b.gen5
+
+EXTRA_DIST = $(INTEL_G4I)	\
+	     $(INTEL_G4A)       \
+	     $(INTEL_G4B)    	\
+	     $(INTEL_G4B_GEN5)
+
+if HAVE_GEN4ASM
+
+SUFFIXES = .g4a .g4b
+.g4a.g4b:
+	m4 $*.g4a > $*.g4m && intel-gen4asm -o $@ $*.g4m && intel-gen4asm -g 5 -o $@.gen5 $*.g4m && rm $*.g4m
+
+$(INTEL_G4B): $(INTEL_G4I)
+
+BUILT_SOURCES= $(INTEL_G4B)
+
+clean-local:
+	-rm -f $(INTEL_G4B)
+	-rm -f $(INTEL_G4B_GEN5)
+endif    
diff --git a/i965_drv_video/shaders/h264/mc/Scoreboard_header.inc b/i965_drv_video/shaders/h264/mc/Scoreboard_header.inc
new file mode 100644
index 0000000..5e87275
--- /dev/null
+++ b/i965_drv_video/shaders/h264/mc/Scoreboard_header.inc
@@ -0,0 +1,85 @@
+/*
+ * Common header file for both scoreboard and scoreboard_MBAFF kernels
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+#if !defined(__SCOREBOARD_HEADER__)	// Make sure this file is only included once
+#define __SCOREBOARD_HEADER__
+
+// Module name: scoreboard_header.inc
+//
+// Common header file for both scoreboard and scoreboard_MBAFF kernels
+//
+
+#define ONE_MB_WA						// Enable WA for 1-MB wide pictures. To disable WA, simply comment out this line.
+
+#define	INLINE_REG_OFF	1
+#define INLINE_REG		r1
+#define INLINE_REG1		r2
+
+#define DONEFLAG	0x40		// Bit mask of "completed" thread flag
+
+// GRF r1 map
+//
+#define WIDTHINMB_1	INLINE_REG.0		// :uw type. Picture width in MB - 1
+#define HEIGHTINMB_1	INLINE_REG.1	// :uw type. Picture height in MB - 1
+#define TotalMB		INLINE_REG.2		// :uw type. Total number of macroblocks
+#define WFLen_B		INLINE_REG.3		// :uw type. Bottom MB Wavefront length (Reserved for MBAFF scoreboard)
+#define WFLen		INLINE_REG.4		// :uw type. Wavefront length (used as loop counter)
+#define WFLenY		INLINE_REG.5		// :uw type. Wavefront length (vertical component)
+#define StartX		INLINE_REG.6		// :uw type. Start X of current wavefront
+#define StartY		INLINE_REG.7		// :uw type. Start Y of current wavefront
+#define StartXD		INLINE_REG.3		// :ud type. Start (X,Y) of current wavefront
+#define	CASE00PTR	INLINE_REG.4		// :ud type. Pointer to "inter start" handler
+#define WFLen_Save	INLINE_REG.10		// :uw type. Saved Wavefront length (Reserved for MBAFF scoreboard)
+#define	CASE10PTR	INLINE_REG.6		// :ud type. Pointer to "intra start" handler
+#define	CASE11PTR	INLINE_REG.7		// :ud type. Pointer to "inter complete" handler
+
+// GRF r2 map
+//
+.declare    WFStart	Base=GRF(2) ElementSize=2 SrcRegion=REGION(4,1) Type=w	// Start MB of recent 4 wavefronts, actually use 5 WORDs
+.declare    WFStart_T	Base=GRF(2) ElementSize=2 SrcRegion=REGION(4,1) Type=w		// Start MB of recent 4 wavefronts
+.declare    WFStart_B	Base=GRF(2).4 ElementSize=2 SrcRegion=REGION(4,1) Type=w	// Start MB of recent 4 wavefronts
+
+#define NewWFOffsetD	INLINE_REG1.5	// :d type. Offsets used for new wavefront = 0x01ffff00 (0, -1, -1, 1)
+#define NewWFOffset	INLINE_REG1.20		// :b type. Offsets used for new wavefront = 0x01ffff00 (0, -1, -1, 1)
+
+#define AVAILFLAGD	INLINE_REG1.6		// :ud type. Neighbor available flags = 0x08020401 (in ACBD order)
+#define AVAILFLAG	INLINE_REG1.24		// :ub type. Neighbor available flags as above
+#define AVAILFLAG1D	INLINE_REG1.7		// :ud type. Top-half neighbor available flags = 0x80402010 (in A_Bxxx order)
+
+.declare    MBINDEX	Base=GRF(3) ElementSize=2 SrcRegion=REGION(16,1) Type=w	// MB order # of current MB group (Cur, ACBD and AC_B_D_)
+#define AR_SAVE		r3.8	// :uw type. Saved Address Register information
+
+#define	CMDPTR		a0.0	// :uw type. DWORD Pointer to the scoreboard
+#define DEPPTR		a0.0	// :uw type. Pointer to the dependency scoreboard - Current MB
+#define DEPPTRL		a0.1	// :uw type. Pointer to the dependency scoreboard - Left MB
+#define DEPPTRTR	a0.2	// :uw type. Pointer to the dependency scoreboard - Top right MB
+#define DEPPTRT		a0.3	// :uw type. Pointer to the dependency scoreboard - Top MB
+#define DEPPTRTL    a0.4    // :uw type. Pointer to the dependency scoreboard - Top left MB
+#define DEPPTRLB	a0.5	// :uw type. Pointer to the dependency scoreboard - Left bottom-half MB
+
+#define	PMSGSEL		a0.7	// :uw type. Pointer to current message in message handling table
+
+#define	CMD_SB_REG_OFF		4
+.declare    CMD_SB		Base=GRF(4) ElementSize=4 SrcRegion=REGION(8,1) Type=ud	// Command scoreboard (64 GRF)
+
+#ifdef	AS_ENABLED
+//	Definitions for Advanced Scheduler support
+#define AS_INT		BIT23	// "Preemption Exception Status" bit in cr0.1:ud control register
+#define AS_INT_EN	BIT10	// "Preemption Exception Enable" bit in cr0.1:ud control register
+#define TH_INT		BIT2	// "Thread Interrupted" bit in message descriptor
+#define TH_RES		BIT0	// "Thread Restart Enable" bit in R0 header r0.2
+
+#define AS_SAVE		34		// Surface state for saving scoreboard contents
+							// Ensure not to conflict with existing binding table entries
+#endif	// End AS_ENABLED
+
+// End of scoreboard_header
+
+#endif	// !defined(__SCOREBOARD_HEADER__)
+
diff --git a/i965_drv_video/shaders/h264/mc/SetHWScoreboard.asm b/i965_drv_video/shaders/h264/mc/SetHWScoreboard.asm
new file mode 100644
index 0000000..c2da855
--- /dev/null
+++ b/i965_drv_video/shaders/h264/mc/SetHWScoreboard.asm
@@ -0,0 +1,209 @@
+/*
+ * Set dependency control HW scoreboard kernel
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+// Kernel name: SetHWScoreboard.asm
+//
+// Set dependency control HW scoreboard kernel
+//
+
+// ----------------------------------------------------
+//  Main: SetHWScoreboard
+// ----------------------------------------------------
+
+.kernel SetHWScoreboard
+
+SETHWSCOREBOARD:
+
+#ifdef _DEBUG
+// WA for FULSIM so we'll know which kernel is being debugged
+mov (1) acc0:ud 0xf0aa55a5:ud
+#endif
+
+#include "header.inc"
+#include "SetHWScoreboard_header.inc"
+
+//
+//  Now, begin source code....
+//
+
+.code
+
+//	Separate the TotalMB so TotalMB will be multiple of 8
+//	and RemainderMB will hold the TotalMB%8
+//
+	and.z.f0.1 (1)	RemainderMB<1>:uw	TotalMB<0;1,0>:uw	0x0007:uw	// number of %8 commands
+	and.z.f0.0 (1)	TotalMB<1>:uw		TotalMB<0;1,0>:uw	0xfff8:uw	// Number of 8-command blocks
+
+	mov (1)	MB_SHIFT_MASK_W<1>:uw		0x100*16+12:w					// Set up shift values (12, 16)
+
+//	Initialize common DAP read header
+//
+	mov (8)	MRF_READ_HEADER_SRC<1>:ud	r0.0<8;8,1>:ud
+	shl (1) MRF_READ_HEADER_SRC.2<1>:ud	StartingMB<0;1,0>:uw	6:uw	// Byte-aligned offset being read
+
+//	Initialize Inter DAP write header
+ 	mov (8)	MRF_INTER_WRITE_HEADER<1>:ud	r0.0<8;8,1>:ud
+
+	(f0.0) jmpi (1)	SetHWScoreboard_Remainder							// Jump if TotalMB < 8
+
+//------------------------------------------------------------------------
+//	Command buffer parsing loop
+//	Each loop will handle 8 commands
+//------------------------------------------------------------------------
+//
+SetHWScoreboard_Loop:
+//	Load block 0 (Commands 0/1)
+	mov (8)	MRF_READ_HEADER0.0<1>:ud	MRF_READ_HEADER_SRC.0<8;8,1>:ud
+	send (16)	CMD_BUFFER_W(0)<1>	MRF_READ_HEADER0	null:uw	DAPREAD	RESP_LEN(4)+OWBRMSGDSC_SC+OWORD_8+BI_CMD_BUFFER
+
+//	Load block 1  (Commands 2/3)
+	mov (8)	MRF_READ_HEADER1.0<1>:ud	MRF_READ_HEADER_SRC.0<8;8,1>:ud
+	add	(1)	MRF_READ_HEADER1.2<1>:ud	MRF_READ_HEADER_SRC.2<0;1,0>:ud		128:ud		// Point to next 2-command block
+	send (16)	CMD_BUFFER_W(4)<1>	MRF_READ_HEADER1	null:uw	DAPREAD	RESP_LEN(4)+OWBRMSGDSC_SC+OWORD_8+BI_CMD_BUFFER
+
+//	Load block 2  (Commands 4/5)
+	mov (8)	MRF_READ_HEADER2.0<1>:ud	MRF_READ_HEADER_SRC.0<8;8,1>:ud
+	add	(1)	MRF_READ_HEADER2.2<1>:ud	MRF_READ_HEADER_SRC.2<0;1,0>:ud		256:ud		// Point to next 2-command block
+	send (16)	CMD_BUFFER_W(8)<1>	MRF_READ_HEADER2	null:uw	DAPREAD	RESP_LEN(4)+OWBRMSGDSC_SC+OWORD_8+BI_CMD_BUFFER
+
+//	Load block 3  (Commands 6/7)
+	mov (8)	MRF_READ_HEADER3.0<1>:ud	MRF_READ_HEADER_SRC.0<8;8,1>:ud
+	add	(1)	MRF_READ_HEADER3.2<1>:ud	MRF_READ_HEADER_SRC.2<0;1,0>:ud		384:ud		// Point to next 2-command block
+	send (16)	CMD_BUFFER_W(12)<1>	MRF_READ_HEADER3	null:uw	DAPREAD	RESP_LEN(4)+OWBRMSGDSC_SC+OWORD_8+BI_CMD_BUFFER
+
+//	Start parsing commands
+    $for(0; <16; 2) {
+	and.nz.f0.1 (8)	NULLREG	CMD_BUFFER_D(%1,4)<0;1,0>	IS_INTRA_MB:ud		// Is it an "Intra" MB?
+	or (1)	CMD_BUFFER_D(%1,2)<1>	CMD_BUFFER_D(%1,2)<0;1,0>	BIT21:ud	// Set "Use Scoreboard" for every MB
+	shl	(2)	CMD_BUFFER_W(%1,2)<1>	CMD_BUFFER_W(%1,14)<0;1,0>	MB_SHIFT_MASK_B<2;2,1>:b	// Set HW SB masks
+	mov (2)	CMD_BUFFER_B(%1,4)<2>	CMD_BUFFER_B(%1,20)<2;2,1>				// Set scoreboard (X,Y) for intra MB
+	(-f0.1) mov (2)	CMD_BUFFER_W(%1,2)<1>	CMD_BUFFER_B(%1,20)<2;2,1>		// Set scoreboard (X,Y) for inter MB
+	(f0.1) jmpi (1) Parse_8_Loop_%1
+
+//	Inter Macroblock
+//	Output MEDIA_OBJECT command in raster scan order
+	mul (16) acc0<1>:uw	CMD_BUFFER_B(%1,21)<0;1,0>	PicWidthMB<0;1,0>:uw	// MB offset = Y*W
+	add (16) acc0<1>:uw	acc0<8;8,1>:uw	CMD_BUFFER_B(%1,20)<0;1,0>			// MB offset = Y*W+X
+ 	shl (1)	MRF_INTER_WRITE_HEADER.2<1>:ud	acc0.2<0;1,0>:uw	6:uw		// Byte-aligned MB offset
+ 	mov (16)	MRF_INTER_WRITE_DATA0<1>:ud	CMD_BUFFER_D(%1)<8;8,1>	{Compr}	// Copy entire command to inter buffer
+	mov	(16)	CMD_BUFFER_D(%1)<1>		0:ud	{Compr}						// Clear original command
+	send (16)	NULLREGW	MRF_INTER_WRITE_HEADER	null:uw	DAPWRITE	MSG_LEN(2)+OWBWMSGDSC+OWORD_4+BI_CMD_BUFFER
+
+Parse_8_Loop_%1:
+	}
+
+	add.z.f0.0 (1)	TotalMB<1>:w	TotalMB<0;1,0>:w	-8:w				// Update remaining number of 8-command blocks
+
+//	Output modified intra commands
+//	Write block 0
+	mov (8)	MRF_INTRA_WRITE_HEADER.0<1>:ud	MRF_READ_HEADER_SRC.0<8;8,1>:ud
+    $for(0; <4; 2) {
+	mov (16)	MRF_CMD_BUF_D(%1)<1>	CMD_BUFFER_D(%1)<8;8,1>	{Compr}
+	}
+	send (16)	NULLREGW	MRF_INTRA_WRITE_HEADER	null:uw	DAPWRITE	MSG_LEN(4)+OWBWMSGDSC+OWORD_8+BI_CMD_BUFFER
+
+//	Write block 1
+	mov (8)	m1.0<1>:ud	MRF_READ_HEADER_SRC.0<8;8,1>:ud
+	add	(1)	m1.2<1>:ud	MRF_READ_HEADER_SRC.2<0;1,0>:ud		128:ud		// Point to next 2-command block
+	mov (16)	m2<1>:ud	CMD_BUFFER_D(4)<8;8,1>	{Compr}
+	mov (16)	m4<1>:ud	CMD_BUFFER_D(6)<8;8,1>	{Compr}
+	send (16)	NULLREGW	m1	null:uw	DAPWRITE	MSG_LEN(4)+OWBWMSGDSC+OWORD_8+BI_CMD_BUFFER
+
+//	Write block 2
+	add	(1)	MRF_INTRA_WRITE_HEADER.2<1>:ud	MRF_READ_HEADER_SRC.2<0;1,0>:ud		256:ud		// Point to next 2-command block
+    $for(0; <4; 2) {
+	mov (16)	MRF_CMD_BUF_D(%1)<1>	CMD_BUFFER_D(%1+8)<8;8,1>	{Compr}
+	}
+	send (16)	NULLREGW	MRF_INTRA_WRITE_HEADER	null:uw	DAPWRITE	MSG_LEN(4)+OWBWMSGDSC+OWORD_8+BI_CMD_BUFFER
+
+//	Write block 3
+	add	(1)	m1.2<1>:ud	MRF_READ_HEADER_SRC.2<0;1,0>:ud		384:ud		// Point to next 2-command block
+	mov (16)	m2<1>:ud	CMD_BUFFER_D(12)<8;8,1>	{Compr}
+	mov (16)	m4<1>:ud	CMD_BUFFER_D(14)<8;8,1>	{Compr}
+	send (16)	NULLREGW	m1	null:uw	DAPWRITE	MSG_LEN(4)+OWBWMSGDSC+OWORD_8+BI_CMD_BUFFER
+
+//	Update message header for next DAP read
+	add (1) MRF_READ_HEADER_SRC.2<1>:ud	MRF_READ_HEADER_SRC.2<0;1,0>:ud	512:ud	// Point to next block of 8-commands
+
+	cmp.z.f0.1 (1)	NULLREG	RemainderMB<0;1,0>:w	0:uw	// Check if remainder MB = 0
+	(-f0.0) jmpi (1)	SetHWScoreboard_Loop			// Continue if more command blocks remain
+
+SetHWScoreboard_Remainder:
+//	f0.1 should have been set to indicate if RemainderMB = 0
+//
+	(f0.1) jmpi (1) SetHWScoreboard_Done				// Stop if all commands have been updated
+
+//	Blindly load next 8 commands anyway
+//
+//	Load block 0 (Commands 0/1)
+	mov (8)	MRF_READ_HEADER0.0<1>:ud	MRF_READ_HEADER_SRC.0<8;8,1>:ud
+	send (16)	CMD_BUFFER_W(0)<1>	MRF_READ_HEADER0	null:uw	DAPREAD	RESP_LEN(4)+OWBRMSGDSC_SC+OWORD_8+BI_CMD_BUFFER
+
+//	Load block 1  (Commands 2/3)
+	mov (8)	MRF_READ_HEADER1.0<1>:ud	MRF_READ_HEADER_SRC.0<8;8,1>:ud
+	add	(1)	MRF_READ_HEADER1.2<1>:ud	MRF_READ_HEADER_SRC.2<0;1,0>:ud		128:ud		// Point to next 2-command block
+	send (16)	CMD_BUFFER_W(4)<1>	MRF_READ_HEADER1	null:uw	DAPREAD	RESP_LEN(4)+OWBRMSGDSC_SC+OWORD_8+BI_CMD_BUFFER
+
+//	Load block 2  (Commands 4/5)
+	mov (8)	MRF_READ_HEADER2.0<1>:ud	MRF_READ_HEADER_SRC.0<8;8,1>:ud
+	add	(1)	MRF_READ_HEADER2.2<1>:ud	MRF_READ_HEADER_SRC.2<0;1,0>:ud		256:ud		// Point to next 2-command block
+	send (16)	CMD_BUFFER_W(8)<1>	MRF_READ_HEADER2	null:uw	DAPREAD	RESP_LEN(4)+OWBRMSGDSC_SC+OWORD_8+BI_CMD_BUFFER
+
+//	Load block 3  (Commands 6/7)
+	mov (8)	MRF_READ_HEADER3.0<1>:ud	MRF_READ_HEADER_SRC.0<8;8,1>:ud
+	add	(1)	MRF_READ_HEADER3.2<1>:ud	MRF_READ_HEADER_SRC.2<0;1,0>:ud		384:ud		// Point to next 2-command block
+	send (16)	CMD_BUFFER_W(12)<1>	MRF_READ_HEADER3	null:uw	DAPREAD	RESP_LEN(4)+OWBRMSGDSC_SC+OWORD_8+BI_CMD_BUFFER
+
+//	Initialize necessary pointers
+	mov (1)	a0.1<1>:ud	((CMD_BUFFER_REG_OFF+1)*0x10000+CMD_BUFFER_REG_OFF)*32	// a0.2:w points to command buffer (first half)
+																			// a0.3:w points to command buffer (second half)
+//	Initialize Inter DAP write header
+ 	mov (8)	MRF_INTER_WRITE_HEADER<1>:ud	r0.0<8;8,1>:ud
+
+SetHWScoreboard_Remainder_Loop:
+	and.nz.f0.1 (8)	NULLREG	r[a0.2,4*4]<0;1,0>:ud	IS_INTRA_MB:ud		// Is it an "Intra" MB?
+	add.z.f0.0 (1)	RemainderMB<1>:w	RemainderMB<0;1,0>:w	-1:w	// Decrement MB #
+	or (1)	r[a0.2,2*4]<1>:ud	r[a0.2,2*4]<0;1,0>:ud	BIT21:ud		// Set "Use Scoreboard" for every MB
+	shl	(2)	r[a0.2,2*2]<1>:uw	r[a0.2,14*2]<0;1,0>:uw	MB_SHIFT_MASK_B<2;2,1>:b	// Set HW SB masks
+	mov (2)	r[a0.2,4*1]<2>:ub	r[a0.2,5*4]<2;2,1>:ub					// Set scoreboard (X,Y) for intra MB
+
+	(-f0.1) mov (2)	r[a0.2,4*1]<1>:uw	r[a0.2,5*4]<2;2,1>:ub			// Set scoreboard (X,Y) for inter MB
+	(f0.1) jmpi (1)	Output_Remainder_Intra
+
+//	Inter Macroblock
+//	Output MEDIA_OBJECT command in raster scan order
+	mul (16) acc0<1>:uw	r[a0.2,21]<0;1,0>:ub	PicWidthMB<0;1,0>:uw	// MB offset = Y*W
+	add (16) acc0<1>:uw	acc0<8;8,1>:uw	r[a0.2,20]<0;1,0>:ub			// MB offset = Y*W+X
+ 	shl (1)	MRF_INTER_WRITE_HEADER.2<1>:ud	acc0.2<0;1,0>:uw	6:uw	// Byte-aligned MB offset
+ 	mov (16)	MRF_INTER_WRITE_DATA0<1>:ud	r[a0.2]<8;8,1>:ud	{Compr}	// Copy entire command to inter buffer
+	mov	(16)	r[a0.2]<1>:ud		0:ud	{Compr}						// Clear original command
+	send (16)	NULLREGW	MRF_INTER_WRITE_HEADER	null:uw	DAPWRITE	MSG_LEN(2)+OWBWMSGDSC+OWORD_4+BI_CMD_BUFFER
+
+Output_Remainder_Intra:
+//	Intra MB command always output
+	mov (8)	MRF_INTRA_WRITE_HEADER.0<1>:ud	MRF_READ_HEADER_SRC.0<8;8,1>:ud
+ 	mov (16)	MRF_CMD_BUF_D(0)<1>		r[a0.2]<8;8,1>:ud	{Compr}		// Copy entire command to intra buffer
+	send (16)	NULLREGW	MRF_INTRA_WRITE_HEADER	null:uw	DAPWRITE	MSG_LEN(2)+OWBWMSGDSC+OWORD_4+BI_CMD_BUFFER
+
+	add	(1)	MRF_READ_HEADER_SRC.2<1>:ud		MRF_READ_HEADER_SRC.2<0;1,0>:ud		64:ud	// Point to next command
+	add (1)	a0.1<1>:ud	a0.1<0;1,0>:ud	0x00400040:ud					// Update pointers
+	(-f0.0) jmpi (1)	SetHWScoreboard_Remainder_Loop
+
+// All MBs have been decoded. Terminate the thread now
+//
+SetHWScoreboard_Done:
+    END_THREAD
+
+#if !defined(COMBINED_KERNEL)		// For standalone kernel only
+.end_code
+
+.end_kernel
+#endif
+
+// End of SetHWScoreboard
diff --git a/i965_drv_video/shaders/h264/mc/SetHWScoreboard_MBAFF.asm b/i965_drv_video/shaders/h264/mc/SetHWScoreboard_MBAFF.asm
new file mode 100644
index 0000000..c5cfeb3
--- /dev/null
+++ b/i965_drv_video/shaders/h264/mc/SetHWScoreboard_MBAFF.asm
@@ -0,0 +1,279 @@
+/*
+ * Set dependency control HW scoreboard kernel for MBAFF picture
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+// Kernel name: SetHWScoreboard_MBAFF.asm
+//
+// Set dependency control HW scoreboard kernel for MBAFF picture
+//
+
+// ----------------------------------------------------
+//  Main: SetHWScoreboard_MBAFF
+// ----------------------------------------------------
+
+.kernel SetHWScoreboard_MBAFF
+
+SETHWSCOREBOARD_MBAFF:
+
+#ifdef _DEBUG
+// WA for FULSIM so we'll know which kernel is being debugged
+mov (1) acc0:ud 0xf1aa55a5:ud
+#endif
+
+#include "header.inc"
+#include "SetHWScoreboard_header.inc"
+
+//
+//  Now, begin source code....
+//
+
+.code
+
+//	Separate the TotalMB so TotalMB will be multiple of 8
+//	and RemainderMB will hold the TotalMB%8
+//
+	and.z.f0.1 (1)	RemainderMB<1>:uw	TotalMB<0;1,0>:uw	0x0007:uw	// number of %8 commands
+	and.z.f0.0 (1)	TotalMB<1>:uw		TotalMB<0;1,0>:uw	0xfff8:uw	// Number of 8-command blocks
+
+//	Initialize common DAP read header
+//
+	mov (8)	MRF_READ_HEADER_SRC<1>:ud	r0.0<8;8,1>:ud
+	shl (1) MRF_READ_HEADER_SRC.2<1>:ud	StartingMB<0;1,0>:uw	6:uw	// Byte-aligned offset being read
+
+//	Initialize Inter DAP write header
+ 	mov (8)	MRF_INTER_WRITE_HEADER<1>:ud	r0.0<8;8,1>:ud
+
+	(f0.0) jmpi (1)	SetHWScoreboard_MBAFF_Remainder						// Jump if TatalMB < 8
+
+//------------------------------------------------------------------------
+//	Command buffer parsing loop
+//	Each loop will handle 8 commands
+//------------------------------------------------------------------------
+//
+SetHWScoreboard_MBAFF_Loop:
+//	Load block 0 (Commands 0/1)
+	mov (8)	MRF_READ_HEADER0.0<1>:ud	MRF_READ_HEADER_SRC.0<8;8,1>:ud
+	send (16)	CMD_BUFFER_W(0)<1>	MRF_READ_HEADER0	null:uw	DAPREAD	RESP_LEN(4)+OWBRMSGDSC_SC+OWORD_8+BI_CMD_BUFFER
+
+//	Load block 1  (Commands 2/3)
+	mov (8)	MRF_READ_HEADER1.0<1>:ud	MRF_READ_HEADER_SRC.0<8;8,1>:ud
+	add	(1)	MRF_READ_HEADER1.2<1>:ud	MRF_READ_HEADER_SRC.2<0;1,0>:ud		128:ud		// Point to next 2-command block
+	send (16)	CMD_BUFFER_W(4)<1>	MRF_READ_HEADER1	null:uw	DAPREAD	RESP_LEN(4)+OWBRMSGDSC_SC+OWORD_8+BI_CMD_BUFFER
+
+//	Load block 2  (Commands 4/5)
+	mov (8)	MRF_READ_HEADER2.0<1>:ud	MRF_READ_HEADER_SRC.0<8;8,1>:ud
+	add	(1)	MRF_READ_HEADER2.2<1>:ud	MRF_READ_HEADER_SRC.2<0;1,0>:ud		256:ud		// Point to next 2-command block
+	send (16)	CMD_BUFFER_W(8)<1>	MRF_READ_HEADER2	null:uw	DAPREAD	RESP_LEN(4)+OWBRMSGDSC_SC+OWORD_8+BI_CMD_BUFFER
+
+//	Load block 3  (Commands 6/7)
+	mov (8)	MRF_READ_HEADER3.0<1>:ud	MRF_READ_HEADER_SRC.0<8;8,1>:ud
+	add	(1)	MRF_READ_HEADER3.2<1>:ud	MRF_READ_HEADER_SRC.2<0;1,0>:ud		384:ud		// Point to next 2-command block
+	send (16)	CMD_BUFFER_W(12)<1>	MRF_READ_HEADER3	null:uw	DAPREAD	RESP_LEN(4)+OWBRMSGDSC_SC+OWORD_8+BI_CMD_BUFFER
+
+//	Start parsing commands
+    $for(0; <16; 2) {
+//	Adjust MB Y origin for field MBs
+//
+	mov (2)	TEMP_FD_X_W<1>:uw	CMD_BUFFER_B(%1,20)<2;2,1>					// Initialize temp (X,Y) location
+	and.nz.f0.1 (8)	NULLREG	CMD_BUFFER_D(%1,4)<0;1,0>	IS_BOT_FD:ud		// Is it a "Bottom Field MB"?
+	and.nz.f0.0 (8)	NULLREG	CMD_BUFFER_D(%1,4)<0;1,0>	IS_FIELD_MB:ud		// Is it a "Field MB"?
+	mul (8)	acc0<1>:w	CMD_BUFFER_B(%1,21)<0;1,0>	2:w
+	(-f0.1) mov (1)	TEMP_FD_Y_W<1>:w	acc0<0;1,0>:w
+	(f0.1) add (1)	TEMP_FD_Y_W<1>:w	acc0<0;1,0>:w	1:w
+	(-f0.0) mov (1)	TEMP_FD_Y_W<1>:w	CMD_BUFFER_B(%1,21)<0;1,0>			// Discard field MB Y origin handling
+
+	and.nz.f0.0 (8)	NULLREG	CMD_BUFFER_D(%1,4)<0;1,0>	IS_INTRA_MB:ud		// Is it an "Intra" MB?
+	and.nz.f0.1	(8)	NULLREG	TEMP_FD_Y_W<0;1,0>:uw	BIT0					// Is it "Bottom MB"?
+	or (1)	CMD_BUFFER_D(%1,2)<1>	CMD_BUFFER_D(%1,2)<0;1,0>	BIT21		// Set "Use Scoreboard"
+	mov (2)	CMD_BUFFER_W(%1,2)<1>	TEMP_FD_X_W<2;2,1>:uw					// Set scoreboard (X,Y) for inter MB
+	(f0.0) jmpi (1)	SET_SB_MBAFF_INTRA_%1									// Jump if intra MB.
+
+//	Inter Macroblock
+//	Output MEDIA_OBJECT command in raster scan order
+	mul (16) acc0<1>:uw	TEMP_FD_Y_W<0;1,0>:uw	PicWidthMB<0;1,0>:uw		// MB offset = Y*W
+	add (16) acc0<1>:uw	acc0<8;8,1>:uw			TEMP_FD_X_W<0;1,0>:uw		// MB offset = Y*W+X
+ 	shl (1)	MRF_INTER_WRITE_HEADER.2<1>:ud	acc0.2<0;1,0>:uw	6:uw		// Byte-aligned MB offset
+ 	mov (16)	MRF_INTER_WRITE_DATA0<1>:ud	CMD_BUFFER_D(%1)<8;8,1>	{Compr}	// Copy entire command to inter buffer
+	mov	(16)	CMD_BUFFER_D(%1)<1>		0:ud	{Compr}						// Clear original command
+	send (16)	NULLREGW	MRF_INTER_WRITE_HEADER	null:uw	DAPWRITE	MSG_LEN(2)+OWBWMSGDSC+OWORD_4+BI_CMD_BUFFER
+	jmpi (1)	NEXT_MB_MBAFF_%1			// Done for inter MB. Move to next MB.
+
+SET_SB_MBAFF_INTRA_%1:
+//	Intra MB
+//
+	and.nz.f0.0 (8)	NULLREG	CMD_BUFFER_D(%1,4)<0;1,0>	IS_FIELD_MB:ud		// Is it an "Field" MB?
+	(f0.1) sel (2)	MB_MASK_D<1>:ud		BOT_FD_MASK1_D<2;2,1>:ud	TOP_FD_MASK1_D<2;2,1>:ud	// Assume field MB
+	mov (1)	TEMP_INTRA_FLAG_W<1>:uw		CMD_BUFFER_W(%1,14)<0;1,0>			// Don't want to alter original in-line data
+	(f0.0) jmpi (1)	SET_SB_MBAFF_%1					// Jump if it's really field MB
+
+//	Frame MB
+//
+//	Derive E'
+	and.nz.f0.0	(8)	NULLREG	CMD_BUFFER_W(%1,14)<0;1,0>	E_FLAG		// Is "E" = 1
+	(f0.1) sel (2)	MB_MASK_D<1>:ud		BOT_FM_MASK1_D<2;2,1>:ud	TOP_FM_MASK1_D<2;2,1>:ud
+	and.z.f0.1 (8)	NULLREG	CMD_BUFFER_W(%1,14)<0;1,0>	A_FLAG		// "A" = 0?
+	(f0.0) jmpi (1)	SET_SB_MBAFF_%1				// If "E" flag = 1, skip the rest of derivation
+	(f0.1) and.nz.f0.1 (8)	NULLREG	CMD_BUFFER_D(%1,4)<0;1,0>	IS_INTRA8X8
+	(f0.1) and.nz.f0.1 (8)	NULLREG	CMD_BUFFER_W(%1,14)<0;1,0>	F_FLAG
+	(f0.1) or (1)	TEMP_INTRA_FLAG_W<1>:uw	CMD_BUFFER_W(%1,14)<0;1,0>	E_FLAG
+
+SET_SB_MBAFF_%1:
+	and.nz.f0.1	(16)	NULLREGW	TEMP_INTRA_FLAG_W<0;1,0>:uw	MB_MASK_B<0;8,1>:ub
+	shl	(1)	CMD_BUFFER_W(%1,2)<1>	f0.1<0;1,0>:uw	12:w		// Masks 0-3
+	and (1)	CMD_BUFFER_W(%1,3)<1>	f0.1<0;1,0>:uw	0xf000:uw	// Masks 4-7
+
+	mov (2)	CMD_BUFFER_B(%1,4)<2>	TEMP_FD_X_B<4;2,2>:ub		// Set scoreboard (X,Y) for intra MB
+
+NEXT_MB_MBAFF_%1:
+	}
+
+	add.z.f0.0 (1)	TotalMB<1>:w	TotalMB<0;1,0>:w	-8:w				// Update remaining number of 8-command blocks
+
+//	Output modified intra commands
+//	Write block 0
+	mov (8)	MRF_INTRA_WRITE_HEADER.0<1>:ud	MRF_READ_HEADER_SRC.0<8;8,1>:ud
+    $for(0; <4; 2) {
+	mov (16)	MRF_CMD_BUF_D(%1)<1>	CMD_BUFFER_D(%1)<8;8,1>	{Compr}
+	}
+	send (16)	NULLREGW	MRF_INTRA_WRITE_HEADER	null:uw	DAPWRITE	MSG_LEN(4)+OWBWMSGDSC+OWORD_8+BI_CMD_BUFFER
+
+//	Write block 1
+	mov (8)	m1.0<1>:ud	MRF_READ_HEADER_SRC.0<8;8,1>:ud
+	add	(1)	m1.2<1>:ud	MRF_READ_HEADER_SRC.2<0;1,0>:ud		128:ud		// Point to next 2-command block
+	mov (16)	m2<1>:ud	CMD_BUFFER_D(4)<8;8,1>	{Compr}
+	mov (16)	m4<1>:ud	CMD_BUFFER_D(6)<8;8,1>	{Compr}
+	send (16)	NULLREGW	m1	null:uw	DAPWRITE	MSG_LEN(4)+OWBWMSGDSC+OWORD_8+BI_CMD_BUFFER
+
+//	Write block 2
+	add	(1)	MRF_INTRA_WRITE_HEADER.2<1>:ud	MRF_READ_HEADER_SRC.2<0;1,0>:ud		256:ud		// Point to next 2-command block
+    $for(0; <4; 2) {
+	mov (16)	MRF_CMD_BUF_D(%1)<1>	CMD_BUFFER_D(%1+8)<8;8,1>	{Compr}
+	}
+	send (16)	NULLREGW	MRF_INTRA_WRITE_HEADER	null:uw	DAPWRITE	MSG_LEN(4)+OWBWMSGDSC+OWORD_8+BI_CMD_BUFFER
+
+//	Write block 3
+	add	(1)	m1.2<1>:ud	MRF_READ_HEADER_SRC.2<0;1,0>:ud		384:ud		// Point to next 2-command block
+	mov (16)	m2<1>:ud	CMD_BUFFER_D(12)<8;8,1>	{Compr}
+	mov (16)	m4<1>:ud	CMD_BUFFER_D(14)<8;8,1>	{Compr}
+	send (16)	NULLREGW	m1	null:uw	DAPWRITE	MSG_LEN(4)+OWBWMSGDSC+OWORD_8+BI_CMD_BUFFER
+
+//	Update message header for next DAP read
+	add (1) MRF_READ_HEADER_SRC.2<1>:ud	MRF_READ_HEADER_SRC.2<0;1,0>:ud	512:ud	// Point to next block of 8-commands
+
+	cmp.z.f0.1 (1)	NULLREG	RemainderMB<0;1,0>:w	0:uw		// Check if remaining MB = 0
+	(-f0.0) jmpi (1)	SetHWScoreboard_MBAFF_Loop			// Continue if more command blocks remain
+
+SetHWScoreboard_MBAFF_Remainder:
+//	f0.1 should have been set to indicate if RemainderMB = 0
+//
+	(f0.1) jmpi (1) SetHWScoreboard_MBAFF_Done				// Stop if all commands have been updated
+
+//	Blindly load next 8 commands anyway
+//
+//	Load block 0 (Commands 0/1)
+	mov (8)	MRF_READ_HEADER0.0<1>:ud	MRF_READ_HEADER_SRC.0<8;8,1>:ud
+	send (16)	CMD_BUFFER_W(0)<1>	MRF_READ_HEADER0	null:uw	DAPREAD	RESP_LEN(4)+OWBRMSGDSC_SC+OWORD_8+BI_CMD_BUFFER
+
+//	Load block 1  (Commands 2/3)
+	mov (8)	MRF_READ_HEADER1.0<1>:ud	MRF_READ_HEADER_SRC.0<8;8,1>:ud
+	add	(1)	MRF_READ_HEADER1.2<1>:ud	MRF_READ_HEADER_SRC.2<0;1,0>:ud		128:ud		// Point to next 2-command block
+	send (16)	CMD_BUFFER_W(4)<1>	MRF_READ_HEADER1	null:uw	DAPREAD	RESP_LEN(4)+OWBRMSGDSC_SC+OWORD_8+BI_CMD_BUFFER
+
+//	Load block 2  (Commands 4/5)
+	mov (8)	MRF_READ_HEADER2.0<1>:ud	MRF_READ_HEADER_SRC.0<8;8,1>:ud
+	add	(1)	MRF_READ_HEADER2.2<1>:ud	MRF_READ_HEADER_SRC.2<0;1,0>:ud		256:ud		// Point to next 2-command block
+	send (16)	CMD_BUFFER_W(8)<1>	MRF_READ_HEADER2	null:uw	DAPREAD	RESP_LEN(4)+OWBRMSGDSC_SC+OWORD_8+BI_CMD_BUFFER
+
+//	Load block 3  (Commands 6/7)
+	mov (8)	MRF_READ_HEADER3.0<1>:ud	MRF_READ_HEADER_SRC.0<8;8,1>:ud
+	add	(1)	MRF_READ_HEADER3.2<1>:ud	MRF_READ_HEADER_SRC.2<0;1,0>:ud		384:ud		// Point to next 2-command block
+	send (16)	CMD_BUFFER_W(12)<1>	MRF_READ_HEADER3	null:uw	DAPREAD	RESP_LEN(4)+OWBRMSGDSC_SC+OWORD_8+BI_CMD_BUFFER
+
+//	Initialize necessary pointers
+	mov (1)	a0.1<1>:ud	((CMD_BUFFER_REG_OFF+1)*0x10000+CMD_BUFFER_REG_OFF)*32	// a0.2:w points to command buffer (first half)
+																			// a0.3:w points to command buffer (second half)
+//	Initialize Inter DAP write header
+ 	mov (8)	MRF_INTER_WRITE_HEADER<1>:ud	r0.0<8;8,1>:ud
+
+SetHWScoreboard_MBAFF_Remainder_Loop:
+//	Adjust MB Y origin for field MBs
+//
+	mov (2)	TEMP_FD_X_W<1>:uw	r[a0.2,5*4]<2;2,1>:ub					// Initialize temp (X,Y) location
+	and.nz.f0.1 (8)	NULLREG	r[a0.2,4*4]<0;1,0>:ud	IS_BOT_FD:ud		// Is it a "Bottom Field MB"?
+	and.nz.f0.0 (8)	NULLREG	r[a0.2,4*4]<0;1,0>:ud	IS_FIELD_MB:ud		// Is it a "Field MB"?
+	mul (8)	acc0<1>:w	r[a0.2,21]<0;1,0>:ub	2:w
+	(-f0.1) mov (1)	TEMP_FD_Y_W<1>:w	acc0<0;1,0>:w
+	(f0.1) add (1)	TEMP_FD_Y_W<1>:w	acc0<0;1,0>:w	1:w
+	(-f0.0) mov (1)	TEMP_FD_Y_W<1>:w	r[a0.2,5*4+1]<0;1,0>:ub			// Discard field MB Y origin handling
+
+	and.nz.f0.0 (8)	NULLREG	r[a0.2,4*4]<0;1,0>:ud	IS_INTRA_MB:ud		// Is it an "Intra" MB?
+	add.z.f0.1 (1)	RemainderMB<1>:w	RemainderMB<0;1,0>:w	-1:w	// Decrement MB #
+	or (1)	r[a0.2,2*4]<1>:ud	r[a0.2,2*4]<0;1,0>:ud	BIT21:ud		// Set "Use Scoreboard"
+	mov (2)	r[a0.2,2*2]<1>:uw	TEMP_FD_X_W<2;2,1>:uw					// Set scoreboard (X,Y) for inter MB
+	(f0.0) jmpi (1)	SET_SB_MBAFF_REM_INTRA								// Jump if intra MB.
+
+//	Inter Macroblock
+//	Output MEDIA_OBJECT command in raster scan order
+	mul (16) acc0<1>:uw	TEMP_FD_Y_W<0;1,0>:uw	PicWidthMB<0;1,0>:uw	// MB offset = Y*W
+	add (16) acc0<1>:uw	acc0<8;8,1>:uw			TEMP_FD_X_W<0;1,0>:uw	// MB offset = Y*W+X
+ 	shl (1)	MRF_INTER_WRITE_HEADER.2<1>:ud	acc0.2<0;1,0>:uw	6:uw	// Byte-aligned MB offset
+ 	mov (16)	MRF_INTER_WRITE_DATA0<1>:ud	r[a0.2]<8;8,1>:ud {Compr}	// Copy entire command to inter buffer
+	mov	(16)	r[a0.2]<1>:ud		0:ud	{Compr}							// Clear original command
+	send (16)	NULLREGW	MRF_INTER_WRITE_HEADER	null:uw	DAPWRITE	MSG_LEN(2)+OWBWMSGDSC+OWORD_4+BI_CMD_BUFFER
+	jmpi (1)	Output_MBAFF_Remainder_Intra							// Done for inter MB. Move to dump intra MB.
+
+SET_SB_MBAFF_REM_INTRA:
+//	Intra MB
+//
+	and.nz.f0.1	(8)	NULLREG	TEMP_FD_Y_W<0;1,0>:uw	BIT0:ud			// Is it "Bottom MB"?
+	and.nz.f0.0 (8)	NULLREG	r[a0.2,4*4]<0;1,0>:ud	IS_FIELD_MB:ud	// Is it "Field MB"?
+	mov (1)	TEMP_INTRA_FLAG_W<1>:uw	r[a0.2,14*2]<0;1,0>:uw			// Don't want to alter original in-line data
+	(f0.1) sel (2)	MB_MASK_D<1>:ud		BOT_FD_MASK1_D<2;2,1>:ud	TOP_FD_MASK1_D<2;2,1>:ud	// Assume field MB
+	(f0.0) jmpi (1)	SET_SB_MBAFF_REM					// Jump if it's really field MB
+
+//	Frame MB
+//
+//	Derive E'
+	and.nz.f0.0	(8)	NULLREG	r[a0.2,14*2]<0;1,0>:uw	E_FLAG		// Is "E" = 1
+	(f0.1) sel (2)	MB_MASK_D<1>:ud		BOT_FM_MASK1_D<2;2,1>:ud	TOP_FM_MASK1_D<2;2,1>:ud
+	and.z.f0.1 (8)	NULLREG	r[a0.2,14*2]<0;1,0>:uw	A_FLAG		// "A" = 0?
+	(f0.0) jmpi (1)	SET_SB_MBAFF_REM				// If "E" flag = 1, skip the rest of derivation
+	(f0.1) and.nz.f0.1 (8)	NULLREG	r[a0.2,4*4]<0;1,0>:ud	IS_INTRA8X8
+	(f0.1) and.nz.f0.1 (8)	NULLREG	r[a0.2,14*2]<0;1,0>:uw	F_FLAG
+	(f0.1) or (1)	TEMP_INTRA_FLAG_W<1>:uw	r[a0.2,14*2]<0;1,0>:uw	E_FLAG
+
+SET_SB_MBAFF_REM:
+	and.nz.f0.0	(16)	NULLREGW	TEMP_INTRA_FLAG_W<0;1,0>:uw	MB_MASK_B<0;8,1>:ub
+	add.z.f0.1 (1)	RemainderMB<1>:w	RemainderMB<0;1,0>:w	0:w		// Check remaining MB #
+	shl	(1)	r[a0.2,2*2]<1>:uw	f0.0<0;1,0>:uw	12:w		// Masks 0-3
+	and (1)	r[a0.2,3*2]<1>:uw	f0.0<0;1,0>:uw	0xf000:uw	// Masks 4-7
+
+	mov (2)	r[a0.2,4*1]<2>:ub	TEMP_FD_X_B<4;2,2>:ub		// Set scoreboard (X,Y) for intra MB
+
+Output_MBAFF_Remainder_Intra:
+//	Intra MB command always output
+	mov (8)	MRF_INTRA_WRITE_HEADER.0<1>:ud	MRF_READ_HEADER_SRC.0<8;8,1>:ud
+ 	mov (16)	MRF_CMD_BUF_D(0)<1>		r[a0.2]<8;8,1>:ud	{Compr}		// Copy entire command to intra buffer
+	send (16)	NULLREGW	MRF_INTRA_WRITE_HEADER	null:uw	DAPWRITE	MSG_LEN(2)+OWBWMSGDSC+OWORD_4+BI_CMD_BUFFER
+
+	add	(1)	MRF_READ_HEADER_SRC.2<1>:ud		MRF_READ_HEADER_SRC.2<0;1,0>:ud		64:ud	// Point to next command
+	add (1)	a0.1<1>:ud	a0.1<0;1,0>:ud	0x00400040:ud					// Update pointers
+	(-f0.1) jmpi (1)	SetHWScoreboard_MBAFF_Remainder_Loop
+
+// All MBs have been decoded. Terminate the thread now
+//
+SetHWScoreboard_MBAFF_Done:
+    END_THREAD
+
+#if !defined(COMBINED_KERNEL)		// For standalone kernel only
+.end_code
+
+.end_kernel
+#endif
+
+// End of SetHWScoreboard_MBAFF
diff --git a/i965_drv_video/shaders/h264/mc/SetHWScoreboard_header.inc b/i965_drv_video/shaders/h264/mc/SetHWScoreboard_header.inc
new file mode 100644
index 0000000..1df91f9
--- /dev/null
+++ b/i965_drv_video/shaders/h264/mc/SetHWScoreboard_header.inc
@@ -0,0 +1,134 @@
+/*
+ * Common header file for both SetHWScoreboard and SetHWScoreboard_MBAFF kernels
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+#if !defined(__SETHWSCOREBOARD_HEADER__)	// Make sure this file is only included once
+#define __SETHWSCOREBOARD_HEADER__
+
+// Module name: SetHWScoreboard_header.inc
+//
+// Common header file for both SetHWScoreboard and SetHWScoreboard_MBAFF kernels
+//
+
+#define BI_CMD_BUF			0	// Binding table index for command buffer
+
+// GRF r1 map
+//
+// For use by setting HW scoreboard kernel for MBAFF picture
+//
+// CURBE data
+#define	TOP_FM_MASK1_D	r1.0		// Bit mask for first half of top frame MB SB mask
+#define	TOP_FM_MASK1_B	r1.0		// Bit mask for first half of top frame MB SB mask
+#define	TOP_FM_MASK2_D	r1.1		// Bit mask for second half of top frame MB SB mask
+#define	TOP_FM_MASK2_B	r1.4		// Bit mask for second half of top frame MB SB mask
+#define	BOT_FM_MASK1_D	r1.2		// Bit mask for first half of bottom frame MB SB mask
+#define	BOT_FM_MASK1_B	r1.8		// Bit mask for first half of bottom frame MB SB mask
+#define	BOT_FM_MASK2_D	r1.3		// Bit mask for second half of bottom frame MB SB mask
+#define	BOT_FM_MASK2_B	r1.12		// Bit mask for second half of bottom frame MB SB mask
+#define	TOP_FD_MASK1_D	r1.4		// Bit mask for first half of top field MB SB mask
+#define	TOP_FD_MASK1_B	r1.16		// Bit mask for first half of top field MB SB mask
+#define	TOP_FD_MASK2_D	r1.5		// Bit mask for second half of top field MB SB mask
+#define	TOP_FD_MASK2_B	r1.20		// Bit mask for second half of top field MB SB mask
+#define	BOT_FD_MASK1_D	r1.6		// Bit mask for first half of bottom field MB SB mask
+#define	BOT_FD_MASK1_B	r1.24		// Bit mask for first half of bottom field MB SB mask
+#define	BOT_FD_MASK2_D	r1.7		// Bit mask for second half of bottom field MB SB mask
+#define	BOT_FD_MASK2_B	r1.28		// Bit mask for second half of bottom field MB SB mask
+
+// For use by setting HW scoreboard kernel for non-MBAFF picture
+#define	MB_SHIFT_MASK_W		r1.0	// :w type. Shift values for two parts of the MB SB mask
+#define	MB_SHIFT_MASK_B		r1.0	// :b type. Shift values for two parts of the MB SB mask
+
+// GRF r2 map
+//
+// In-line data
+//
+#define	INLINE_REG_OFFSET	1
+#define INLINE_REG			r2
+
+#define StartingMB	INLINE_REG.0	// :uw type. Starting MB number
+#define TotalMB		INLINE_REG.1	// :uw type. Total number of MB to be processed
+#define PicWidthMB	INLINE_REG.2	// :uw type. Picture width in MB
+
+// GRF r3 map
+//
+// Temporary variables
+//
+#define RemainderMB	r3.0			// :uw type. Remainder of MB (<16) to be processed
+
+#define	TEMP_FD_X_W	r3.2			// :w type. Temporary variable for field MB X origin in MBAFF picture
+#define	TEMP_FD_X_B	r3.4			// :b type. Temporary variable for field MB X origin in MBAFF picture
+#define	TEMP_FD_Y_W	r3.3			// :w type. Temporary variable for field MB Y origin in MBAFF picture
+#define	TEMP_FD_Y_B	r3.6			// :b type. Temporary variable for field MB Y origin in MBAFF picture
+
+#define	TEMP_INTRA_FLAG_W	r3.4	// :uw type. Temporary intra available flag
+
+#define MB_MASK_D	r3.4			// :ud type. Bit masks for MBAFF MB
+#define MB_MASK_B	r3.16			// :ub type. Bit masks for MBAFF MB
+
+#define	MRF_READ_HEADER_SRC	r63
+
+// MEDIA_OBJECT_EX Command map
+//
+// In DW1 of each MEDIA_OBJECT_EX command (VFE DWORD)
+#define	CUR_X	0	// Byte 0
+#define	CUR_Y	0	// Byte 2
+
+// In DW2 of each MEDIA_OBJECT_EX command
+#define	USE_SCOREBOARD	BIT21
+
+// In DW4 of each MEDIA_OBJECT_EX command
+#define	F_FLAG		BIT4
+#define	IS_INTRA_MB	BIT13
+#define IS_FIELD_MB	BIT14
+#define IS_INTRA8X8	BIT15
+#define IS_BOT_FD	BIT24
+
+// In DW7 of each MEDIA_OBJECT_EX command
+#define	A_FLAG		BIT0
+#define	B_FLAG		BIT1
+#define	C_FLAG		BIT2
+#define	D_FLAG		BIT3
+#define	E_FLAG		BIT4
+
+#define	CMD_BUFFER_REG_OFF		4
+.declare    CMD_BUFFER_D		Base=GRF(4) ElementSize=4 SrcRegion=REGION(8,1) Type=ud		// Command buffer (32 GRF)
+.declare    CMD_BUFFER_W		Base=GRF(4) ElementSize=2 SrcRegion=REGION(16,1) Type=uw	// Command buffer (32 GRF)
+.declare    CMD_BUFFER_B		Base=GRF(4) ElementSize=1 SrcRegion=REGION(16,1) Type=ub	// Command buffer (32 GRF)
+
+#define	MRF_READ_HEADER		m1
+#define	MRF_READ_HEADER0	m1
+#define	MRF_READ_HEADER1	m2
+#define	MRF_READ_HEADER2	m3
+#define	MRF_READ_HEADER3	m4
+
+#define	MRF_INTER_WRITE_HEADER	m5
+#define	MRF_INTER_WRITE_DATA0	m6
+#define	MRF_INTER_WRITE_DATA1	m7
+
+#define	MRF_WRITE_HEADER		m11
+#define	MRF_INTRA_WRITE_HEADER	m11
+
+#define MRF_CMD_BUF_REG_OFF		12
+.declare	MRF_CMD_BUF_D		Base=m12 ElementSize=4 SrcRegion=REGION(8,1) Type=ud		// Command buffer stored in MRF
+.declare	MRF_CMD_BUF_W		Base=m12 ElementSize=2 SrcRegion=REGION(16,1) Type=uw		// Command buffer stored in MRF
+.declare	MRF_CMD_BUF_B		Base=m12 ElementSize=1 SrcRegion=REGION(16,1) Type=ub		// Command buffer stored in MRF
+
+#define	BI_CMD_BUFFER	0
+
+#define OWBRMSGDSC_SC	 0x02088000	// OWORD Block Read Message Descriptor, reading from sampler cache = A.
+#define OWBWMSGDSC		 0x02080000	// OWORD Block Write Message Descriptor
+
+#define OWORD_1	0x000
+#define OWORD_2	0x200
+#define OWORD_4	0x300
+#define OWORD_8	0x400
+
+// End of SETHWSCOREBOARD_HEADER
+
+#endif	// !defined(__SETHWSCOREBOARD_HEADER__)
+
diff --git a/i965_drv_video/shaders/h264/mc/SetupForHWMC.asm b/i965_drv_video/shaders/h264/mc/SetupForHWMC.asm
new file mode 100644
index 0000000..b6dc595
--- /dev/null
+++ b/i965_drv_video/shaders/h264/mc/SetupForHWMC.asm
@@ -0,0 +1,33 @@
+/*
+ * Initial setup for running HWMC kernels in HWMC-Only decoding mode
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+// Kernel name: SetupForHWMC.asm
+//
+// Initial setup for running HWMC kernels in HWMC-Only decoding mode
+//
+#include "header.inc"
+#include "intra_Header.inc"
+
+#if !defined(__SETUPFORHWMC__)	// Make sure the following are only included once
+#define __SETUPFORHWMC__
+
+.reg_count_total    64
+.reg_count_payload  2
+
+//
+//  Now, begin source code....
+//
+
+.code
+#endif	// !defined(__SETUPFORHWMC__)
+
+    mov (8)	MSGSRC<1>:ud	r0.0<8;8,1>:ud			// Initialize message header payload with R0
+	shl (2) I_ORIX<1>:uw	ORIX<2;2,1>:ub	4:w		// Convert MB origin to pixel unit
+
+// End of SetupForHWMC
diff --git a/i965_drv_video/shaders/h264/mc/add_Error_16x16_Y.asm b/i965_drv_video/shaders/h264/mc/add_Error_16x16_Y.asm
new file mode 100644
index 0000000..df01b99
--- /dev/null
+++ b/i965_drv_video/shaders/h264/mc/add_Error_16x16_Y.asm
@@ -0,0 +1,51 @@
+/*
+ * Add macroblock correction Y data blocks to predicted picture
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+        
+// Module name: add_Error_16x16_Y.asm
+//
+// Add macroblock correction Y data blocks to predicted picture
+//
+
+//  Every line of predicted Y data is added to Y error data if CBP bit is set
+
+    mov (1) PERROR_UD<1>:ud	0x10001*ERRBUF*GRFWIB+0x00100000:ud	// Pointers to first and second row of error block
+
+    and.z.f0.1 (1)	NULLREG    REG_CBPCY	CBP_Y_MASK
+    (f0.1) jmpi (1) End_add_Error_16x16_Y	// Skip all blocks
+
+//  Block Y0
+//
+    $for(0,0; <8; 2,1) {
+	add.sat (16)	DEC_Y(%1)<2>	r[PERROR,%2*GRFWIB]REGION(8,1):w	PRED_Y(%1)REGION(8,2) {Compr}
+    }
+
+//  Block Y1
+//
+    $for(0,0; <8; 2,1) {
+	add.sat (16)	DEC_Y(%1,16)<2>		r[PERROR,%2*GRFWIB+0x80]REGION(8,1):w	PRED_Y(%1,16)REGION(8,2) {Compr}
+    }
+
+//  Block Y2
+//
+    $for(8,0; <16; 2,1) {
+	add.sat (16)	DEC_Y(%1)<2>	r[PERROR,%2*GRFWIB+0x100]REGION(8,1):w	PRED_Y(%1)REGION(8,2) {Compr}
+    }
+
+//  Block Y3
+//
+    $for(8,0; <16; 2,1) {
+	add.sat (16)	DEC_Y(%1,16)<2>		r[PERROR,%2*GRFWIB+0x180]REGION(8,1):w	PRED_Y(%1,16)REGION(8,2) {Compr}
+    }
+
+End_add_Error_16x16_Y:
+    add (1) PERROR_UD<1>:ud	PERROR_UD:ud	0x01800180:ud	// Pointers to Y3 error block
+
+//  End of add_Error_16x16_Y
+
diff --git a/i965_drv_video/shaders/h264/mc/add_Error_UV.asm b/i965_drv_video/shaders/h264/mc/add_Error_UV.asm
new file mode 100644
index 0000000..e2c0dea
--- /dev/null
+++ b/i965_drv_video/shaders/h264/mc/add_Error_UV.asm
@@ -0,0 +1,38 @@
+/*
+ * Add macroblock correction UV data blocks to predicted picture        
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+
+#if !defined(__ADD_ERROR_UV__)		// Make sure this is only included once
+#define __ADD_ERROR_UV__
+
+// Module name: add_Error_UV.asm
+//
+// Add macroblock correction UV data blocks to predicted picture
+
+// PERROR points to error block Y3 after decoding Y component
+
+//	Update address register used in instruction compression
+//
+
+//  U component
+//
+    add (1) PERROR1<1>:w	PERROR:w	0x00010:w	// Pointers to next error row
+    $for(0,0; <8; 2,1) {
+	add.sat (16)	DEC_UV(%1)<4>	r[PERROR,%2*GRFWIB+0x80]REGION(8,1):w	PRED_UV(%1)REGION(8,4) {Compr}
+    }
+
+//  V component
+//
+    $for(0,0; <8; 2,1) {
+	add.sat (16)	DEC_UV(%1,2)<4>	r[PERROR,%2*GRFWIB+0x100]REGION(8,1):w	PRED_UV(%1,2)REGION(8,4) {Compr}
+    }
+
+//  End of add_Error_UV
+
+#endif	// !defined(__ADD_ERROR_UV__)
diff --git a/i965_drv_video/shaders/h264/mc/avc_mc.g4b b/i965_drv_video/shaders/h264/mc/avc_mc.g4b
new file mode 100644
index 0000000..5a91f32
--- /dev/null
+++ b/i965_drv_video/shaders/h264/mc/avc_mc.g4b
@@ -0,0 +1,2938 @@
+   { 0x00600001, 0x27c00021, 0x008d0000, 0x00000000 },
+   { 0x00200009, 0x27fa3e29, 0x00450064, 0x00040004 },
+   { 0x00000040, 0x27e01c01, 0x00001400, 0x00000020 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x000000d4 },
+   { 0x00000005, 0x220e3e2c, 0x00000070, 0x000f000f },
+   { 0x00000001, 0x26a00221, 0x00009c38, 0x00000000 },
+   { 0x00000220, 0x34001400, 0x00001400, 0x000006a0 },
+   { 0x00a02001, 0x24000229, 0x00b10624, 0x00000000 },
+   { 0x00a02001, 0x24400229, 0x00b10624, 0x00000000 },
+   { 0x00a02001, 0x24800229, 0x00b10624, 0x00000000 },
+   { 0x00a02001, 0x24c00229, 0x00b10624, 0x00000000 },
+   { 0x00a02001, 0x25000229, 0x00b10624, 0x00000000 },
+   { 0x00a02001, 0x25400229, 0x00b10624, 0x00000000 },
+   { 0x00a02001, 0x25800229, 0x00b10624, 0x00000000 },
+   { 0x00a02001, 0x25c00229, 0x00b10624, 0x00000000 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x00000086 },
+   { 0x00000001, 0x22080060, 0x00000000, 0x06440640 },
+   { 0x00a02001, 0x24000229, 0x00009003, 0x00000000 },
+   { 0x00a02001, 0x24400229, 0x0000900b, 0x00000000 },
+   { 0x00a02001, 0x24800229, 0x00009013, 0x00000000 },
+   { 0x00a02001, 0x24c00229, 0x0000901b, 0x00000000 },
+   { 0x00a02001, 0x25000229, 0x00009023, 0x00000000 },
+   { 0x00a02001, 0x25400229, 0x0000902b, 0x00000000 },
+   { 0x00a02001, 0x25800229, 0x00009033, 0x00000000 },
+   { 0x00a02001, 0x25c00229, 0x0000903b, 0x00000000 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x00000072 },
+   { 0x02600005, 0x20000c20, 0x0000006c, 0x00000002 },
+   { 0x00600005, 0x24000c20, 0x0000006c, 0x00000011 },
+   { 0x01600007, 0x20000c00, 0x028d0400, 0x00000011 },
+   { 0x00780001, 0x26240169, 0x00000000, 0x80808080 },
+   { 0x00780001, 0x66430231, 0x028d0624, 0x00000000 },
+   { 0x00780001, 0x66630231, 0x028d062c, 0x00000000 },
+   { 0x00780001, 0x26240231, 0x00cf0643, 0x00000000 },
+   { 0x00780001, 0x262c0231, 0x00cf0663, 0x00000000 },
+   { 0x00800040, 0x25e04629, 0x00cf0643, 0x00b10624 },
+   { 0x00600040, 0x25e02529, 0x008d05e0, 0x008d05f0 },
+   { 0x00400040, 0x25e02529, 0x006905e0, 0x006905e8 },
+   { 0x00200040, 0x25e02529, 0x004505e0, 0x004505e4 },
+   { 0x00a02040, 0x2400252c, 0x000005e0, 0x000005e2 },
+   { 0x00a02040, 0x24003d8c, 0x00b10400, 0x00100010 },
+   { 0x00a02008, 0x24003d89, 0x00b10400, 0x00050005 },
+   { 0x00a02008, 0x24403d89, 0x00b10400, 0x00050005 },
+   { 0x00a02008, 0x24803d89, 0x00b10400, 0x00050005 },
+   { 0x00a02008, 0x24c03d89, 0x00b10400, 0x00050005 },
+   { 0x00a02008, 0x25003d89, 0x00b10400, 0x00050005 },
+   { 0x00a02008, 0x25403d89, 0x00b10400, 0x00050005 },
+   { 0x00a02008, 0x25803d89, 0x00b10400, 0x00050005 },
+   { 0x00a02008, 0x25c03d89, 0x00b10400, 0x00050005 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x00000044 },
+   { 0x00600041, 0x26806e2d, 0x008d062c, 0x89abcdef },
+   { 0x00600041, 0x26906e2d, 0x008d0623, 0xfedcba98 },
+   { 0x00600041, 0x26a06e2d, 0x00cf0663, 0x89abcdef },
+   { 0x00600041, 0x26b06e2d, 0x00cf0643, 0x0fedcba9 },
+   { 0x00000041, 0x26be3e2d, 0x00000623, 0xfff8fff8 },
+   { 0x00802040, 0x268035ad, 0x008d4680, 0x008d0690 },
+   { 0x00802040, 0x268035ad, 0x008d0680, 0x008d0688 },
+   { 0x00802040, 0x268035ad, 0x008d0680, 0x008d0684 },
+   { 0x00802040, 0x268035ad, 0x008d0680, 0x008d0682 },
+   { 0x00800001, 0x240001ec, 0x00000000, 0x00200020 },
+   { 0x00200048, 0x24003dac, 0x00a00680, 0x00050005 },
+   { 0x00200008, 0x26e03d8d, 0x00450400, 0x00060006 },
+   { 0x00800001, 0x240001ec, 0x00000000, 0x00100010 },
+   { 0x00800048, 0x24003e2c, 0x00000633, 0x00100010 },
+   { 0x00800048, 0x26c03e2d, 0x0000067f, 0x00100010 },
+   { 0x00800048, 0x272055ad, 0x000006e0, 0x00b10040 },
+   { 0x00600041, 0x268055ad, 0x000006e2, 0x00ae0040 },
+   { 0x00600041, 0x26a055ad, 0x000006e2, 0x00ae0041 },
+   { 0x00a02040, 0x240035ac, 0x00b10720, 0x00b00680 },
+   { 0x80a02008, 0x44003d91, 0x00b10400, 0x00050005 },
+   { 0x00a02040, 0x240035ac, 0x00b10720, 0x00b00682 },
+   { 0x80a02008, 0x44403d91, 0x00b10400, 0x00050005 },
+   { 0x00a02040, 0x240035ac, 0x00b10720, 0x00b00684 },
+   { 0x80a02008, 0x44803d91, 0x00b10400, 0x00050005 },
+   { 0x00a02040, 0x240035ac, 0x00b10720, 0x00b00686 },
+   { 0x80a02008, 0x44c03d91, 0x00b10400, 0x00050005 },
+   { 0x00a02040, 0x240035ac, 0x00b10720, 0x00b00688 },
+   { 0x80a02008, 0x45003d91, 0x00b10400, 0x00050005 },
+   { 0x00a02040, 0x240035ac, 0x00b10720, 0x00b0068a },
+   { 0x80a02008, 0x45403d91, 0x00b10400, 0x00050005 },
+   { 0x00a02040, 0x240035ac, 0x00b10720, 0x00b0068c },
+   { 0x80a02008, 0x45803d91, 0x00b10400, 0x00050005 },
+   { 0x00a02040, 0x240035ac, 0x00b10720, 0x00b0068e },
+   { 0x80a02008, 0x45c03d91, 0x00b10400, 0x00050005 },
+   { 0x00000001, 0x22040060, 0x00000000, 0x00900080 },
+   { 0x01000005, 0x20000c20, 0x02000068, 0x00003c00 },
+   { 0x00010220, 0x34001c00, 0x02001400, 0x00000020 },
+   { 0x80802040, 0x440045b1, 0x008d8800, 0x00ae0400 },
+   { 0x80802040, 0x444045b1, 0x008d8820, 0x00ae0440 },
+   { 0x80802040, 0x448045b1, 0x008d8840, 0x00ae0480 },
+   { 0x80802040, 0x44c045b1, 0x008d8860, 0x00ae04c0 },
+   { 0x80802040, 0x441045b1, 0x008d8880, 0x00ae0410 },
+   { 0x80802040, 0x445045b1, 0x008d88a0, 0x00ae0450 },
+   { 0x80802040, 0x449045b1, 0x008d88c0, 0x00ae0490 },
+   { 0x80802040, 0x44d045b1, 0x008d88e0, 0x00ae04d0 },
+   { 0x80802040, 0x450045b1, 0x008d8900, 0x00ae0500 },
+   { 0x80802040, 0x454045b1, 0x008d8920, 0x00ae0540 },
+   { 0x80802040, 0x458045b1, 0x008d8940, 0x00ae0580 },
+   { 0x80802040, 0x45c045b1, 0x008d8960, 0x00ae05c0 },
+   { 0x80802040, 0x451045b1, 0x008d8980, 0x00ae0510 },
+   { 0x80802040, 0x455045b1, 0x008d89a0, 0x00ae0550 },
+   { 0x80802040, 0x459045b1, 0x008d89c0, 0x00ae0590 },
+   { 0x80802040, 0x45d045b1, 0x008d89e0, 0x00ae05d0 },
+   { 0x00000040, 0x22040c00, 0x00000204, 0x01800180 },
+   { 0x00000040, 0x27e01c01, 0x00001400, 0x00000020 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x000000e2 },
+   { 0x00000040, 0x27e01c01, 0x00001400, 0x00000020 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x00000018 },
+   { 0x00000001, 0x27800021, 0x00000780, 0x00000000 },
+   { 0x00000001, 0x27a00021, 0x000007a0, 0x00000000 },
+   { 0x01600031, 0x20001c20, 0x708d0000, 0x82000010 },
+   { 0x00200440, 0x27c055a5, 0x004507fa, 0x0045002a },
+   { 0x00000801, 0x27c80061, 0x00000000, 0x0000001b },
+   { 0x00000040, 0x22000d20, 0x00000062, 0x02186000 },
+   { 0x01600031, 0x26200021, 0x408d07c0, 0x00000200 },
+   { 0x00000440, 0x27c43ca5, 0x000007c4, 0x00010001 },
+   { 0x00000801, 0x27c80061, 0x00000000, 0x000f0003 },
+   { 0x00000040, 0x22000c00, 0x00000200, 0x00100000 },
+   { 0x02600031, 0x26400021, 0x408d07c0, 0x00000200 },
+   { 0x00000001, 0x34000020, 0x000007e0, 0x00000000 },
+   { 0x00000008, 0x27fc3dad, 0x000007fc, 0x00010001 },
+   { 0x00200440, 0x27c055a5, 0x004507fa, 0x0045002a },
+   { 0x00000801, 0x27c80061, 0x00000000, 0x00000013 },
+   { 0x00000040, 0x22000c00, 0x00000200, 0xefffc001 },
+   { 0x01600031, 0x26200021, 0x408d07c0, 0x00000200 },
+   { 0x00000440, 0x27c43ca5, 0x000007c4, 0x00010001 },
+   { 0x00000801, 0x27c80061, 0x00000000, 0x00070003 },
+   { 0x05600031, 0x26400021, 0x408d07c0, 0x00000200 },
+   { 0x00000008, 0x220e3e2c, 0x0000006c, 0x00060006 },
+   { 0x00000001, 0x26a002a5, 0x00009c3c, 0x00000000 },
+   { 0x00000220, 0x34001400, 0x00001400, 0x000006a0 },
+   { 0x02600005, 0x20000c20, 0x0000006c, 0x00000002 },
+   { 0x00780001, 0x26240169, 0x00000000, 0x80808080 },
+   { 0x02400005, 0x20000c20, 0x0200006c, 0x00000001 },
+   { 0x00560001, 0x46420129, 0x02690624, 0x00000000 },
+   { 0x02400005, 0x20000c20, 0x0200006c, 0x00000010 },
+   { 0x00560001, 0x46520129, 0x0269062c, 0x00000000 },
+   { 0x00780001, 0x26240129, 0x00ae0642, 0x00000000 },
+   { 0x00800040, 0x24004629, 0x00b10624, 0x00650642 },
+   { 0x00600040, 0x24002529, 0x00650400, 0x00650404 },
+   { 0x00600040, 0x25202529, 0x00050400, 0x00050404 },
+   { 0x00600040, 0x25702529, 0x00050408, 0x0005040c },
+   { 0x00560001, 0x26240169, 0x00000000, 0x80808080 },
+   { 0x00460001, 0x26240129, 0x028a0652, 0x00000000 },
+   { 0x00560001, 0x46520129, 0x02690624, 0x00000000 },
+   { 0x02400005, 0x20000c20, 0x0200006c, 0x00000001 },
+   { 0x00560001, 0x46420169, 0x02000000, 0x80808080 },
+   { 0x00460001, 0x46420129, 0x0069062c, 0x00000000 },
+   { 0x00560001, 0x262c0129, 0x008a0642, 0x00000000 },
+   { 0x00600040, 0x24004629, 0x008d0624, 0x00650652 },
+   { 0x00600040, 0x24104629, 0x00650642, 0x008d062c },
+   { 0x00600040, 0x24002529, 0x00650400, 0x00650404 },
+   { 0x00600040, 0x25302529, 0x00050408, 0x0005040c },
+   { 0x00600040, 0x25602529, 0x00050400, 0x00050404 },
+   { 0x00a02040, 0x24003d2c, 0x00b10520, 0x00040004 },
+   { 0x00a02008, 0x24003d89, 0x00b10400, 0x00030003 },
+   { 0x00a02008, 0x24403d89, 0x00b10400, 0x00030003 },
+   { 0x00a02040, 0x24003d2c, 0x00b10560, 0x00040004 },
+   { 0x00a02008, 0x24803d89, 0x00b10400, 0x00030003 },
+   { 0x00a02008, 0x24c03d89, 0x00b10400, 0x00030003 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x00000048 },
+   { 0x00000001, 0x22080060, 0x00000000, 0x06440640 },
+   { 0x00a02001, 0x24000229, 0x00059002, 0x00000000 },
+   { 0x00a02001, 0x24400229, 0x0005900a, 0x00000000 },
+   { 0x00a02001, 0x24800229, 0x00059012, 0x00000000 },
+   { 0x00a02001, 0x24c00229, 0x0005901a, 0x00000000 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x0000003c },
+   { 0x00a02001, 0x24000229, 0x00b10624, 0x00000000 },
+   { 0x00a02001, 0x24400229, 0x00b10624, 0x00000000 },
+   { 0x00a02001, 0x24800229, 0x00b10624, 0x00000000 },
+   { 0x00a02001, 0x24c00229, 0x00b10624, 0x00000000 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x00000032 },
+   { 0x00600041, 0x26806e2d, 0x008d062c, 0x44332211 },
+   { 0x00600041, 0x26906e2d, 0x008d0622, 0xffeeddcc },
+   { 0x00600041, 0x26a06e2d, 0x00650652, 0x44332211 },
+   { 0x00600041, 0x26b06e2d, 0x00650642, 0x00ffeedd },
+   { 0x00200041, 0x26bc3e2d, 0x00450622, 0xfffcfffc },
+   { 0x00802040, 0x268035ad, 0x008d0680, 0x008d0690 },
+   { 0x00802040, 0x268035ad, 0x008d0680, 0x008d0688 },
+   { 0x00802040, 0x268035ad, 0x008d0680, 0x008d0684 },
+   { 0x00800001, 0x240001ec, 0x00000000, 0x00200020 },
+   { 0x00400048, 0x24003dac, 0x00a50680, 0x00220022 },
+   { 0x00400008, 0x26e03d8d, 0x00690400, 0x00060006 },
+   { 0x00800001, 0x240001ec, 0x00000000, 0x00100010 },
+   { 0x00800048, 0x24003e2c, 0x00050632, 0x00100010 },
+   { 0x00800048, 0x26c03e2d, 0x0005065e, 0x00100010 },
+   { 0x00800048, 0x272055ad, 0x000506e0, 0x00240044 },
+   { 0x00600041, 0x268055ad, 0x000506e4, 0x00440044 },
+   { 0x00600041, 0x26a055ad, 0x000506e4, 0x00440045 },
+   { 0x00a02040, 0x240035ac, 0x00b10720, 0x00050680 },
+   { 0x80a02008, 0x44003d91, 0x00b10400, 0x00050005 },
+   { 0x00a02040, 0x240035ac, 0x00b10720, 0x00050684 },
+   { 0x80a02008, 0x44403d91, 0x00b10400, 0x00050005 },
+   { 0x00a02040, 0x240035ac, 0x00b10720, 0x00050688 },
+   { 0x80a02008, 0x44803d91, 0x00b10400, 0x00050005 },
+   { 0x00a02040, 0x240035ac, 0x00b10720, 0x0005068c },
+   { 0x80a02008, 0x44c03d91, 0x00b10400, 0x00050005 },
+   { 0x00000040, 0x22063d8c, 0x00000204, 0x00100010 },
+   { 0x80802040, 0x640045b1, 0x008d8880, 0x00cf0400 },
+   { 0x80802040, 0x644045b1, 0x008d88a0, 0x00cf0440 },
+   { 0x80802040, 0x648045b1, 0x008d88c0, 0x00cf0480 },
+   { 0x80802040, 0x64c045b1, 0x008d88e0, 0x00cf04c0 },
+   { 0x80802040, 0x640245b1, 0x008d8900, 0x00cf0402 },
+   { 0x80802040, 0x644245b1, 0x008d8920, 0x00cf0442 },
+   { 0x80802040, 0x648245b1, 0x008d8940, 0x00cf0482 },
+   { 0x80802040, 0x64c245b1, 0x008d8960, 0x00cf04c2 },
+   { 0x00000401, 0x27c80061, 0x00000000, 0x0007000f },
+   { 0x00200801, 0x27c001a1, 0x004507fa, 0x00000000 },
+   { 0x00000040, 0x22000c00, 0x00000200, 0x08004000 },
+   { 0x00800001, 0x20400232, 0x00d20400, 0x00000000 },
+   { 0x00800001, 0x20500232, 0x00d20420, 0x00000000 },
+   { 0x00800001, 0x20600232, 0x00d20440, 0x00000000 },
+   { 0x00800001, 0x20700232, 0x00d20460, 0x00000000 },
+   { 0x00800001, 0x20800232, 0x00d20480, 0x00000000 },
+   { 0x00800001, 0x20900232, 0x00d204a0, 0x00000000 },
+   { 0x00800001, 0x20a00232, 0x00d204c0, 0x00000000 },
+   { 0x00800001, 0x20b00232, 0x00d204e0, 0x00000000 },
+   { 0x01600031, 0x27a00021, 0x508d07c0, 0x00000200 },
+   { 0x00000001, 0x34000020, 0x000007e0, 0x00000000 },
+   { 0x00000401, 0x27c80061, 0x00000000, 0x000f000f },
+   { 0x00200801, 0x27c001a1, 0x004507fa, 0x00000000 },
+   { 0x00000040, 0x22000c00, 0x00000200, 0x0ff04000 },
+   { 0x00000001, 0x22080060, 0x00000000, 0x04400400 },
+   { 0x00a02001, 0x20400232, 0x00d29000, 0x00000000 },
+   { 0x00a02001, 0x20500232, 0x00d29020, 0x00000000 },
+   { 0x00a02001, 0x20800232, 0x00d29080, 0x00000000 },
+   { 0x00a02001, 0x20900232, 0x00d290a0, 0x00000000 },
+   { 0x00a02001, 0x20c00232, 0x00d29100, 0x00000000 },
+   { 0x00a02001, 0x20d00232, 0x00d29120, 0x00000000 },
+   { 0x00a02001, 0x21000232, 0x00d29180, 0x00000000 },
+   { 0x00a02001, 0x21100232, 0x00d291a0, 0x00000000 },
+   { 0x01600031, 0x27800021, 0x508d07c0, 0x00000200 },
+   { 0x00000001, 0x34000020, 0x000007e0, 0x00000000 },
+   { 0x00600001, 0x27c00021, 0x008d0000, 0x00000000 },
+   { 0x00200009, 0x27fa3e29, 0x00450064, 0x00040004 },
+   { 0x00000040, 0x27e01c01, 0x00001400, 0x00000020 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0xffffff04 },
+   { 0x00000001, 0x220401ec, 0x00000000, 0x00800080 },
+   { 0x00000001, 0x22080060, 0x00000000, 0x04100400 },
+   { 0x00200008, 0x27006e2d, 0x0000006c, 0x00000040 },
+   { 0x00400001, 0x27400061, 0x00000000, 0x00000000 },
+   { 0x00800001, 0x272001a9, 0x00b10620, 0x00000000 },
+   { 0x02600005, 0x20001c20, 0x0000006c, 0x00000008 },
+   { 0x00110001, 0x27230231, 0x00000624, 0x00000000 },
+   { 0x00600001, 0x27420231, 0x00cf0643, 0x00000000 },
+   { 0x00110001, 0x27410231, 0x00000643, 0x00000000 },
+   { 0x00240001, 0x27400231, 0x00000623, 0x00000000 },
+   { 0x02000005, 0x20001c20, 0x0200006c, 0x00000002 },
+   { 0x00010001, 0x27400231, 0x02000624, 0x00000000 },
+   { 0x02000005, 0x20001c20, 0x0200006c, 0x00000001 },
+   { 0x00110001, 0x27420231, 0x02000623, 0x00000000 },
+   { 0x00000005, 0x26803e2d, 0x00000070, 0x000f000f },
+   { 0x00000001, 0x270801ad, 0x00000700, 0x00000000 },
+   { 0x00000040, 0x27e01c01, 0x00001400, 0x00000020 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x00000084 },
+   { 0x00000040, 0x22043d8c, 0x00000204, 0x00800080 },
+   { 0x00800001, 0x27200231, 0x00b10628, 0x00000000 },
+   { 0x02600005, 0x20001c20, 0x0200006c, 0x00000004 },
+   { 0x00680001, 0x272c0231, 0x028d0634, 0x00000000 },
+   { 0x00780001, 0x272c0231, 0x02000633, 0x00000000 },
+   { 0x00400001, 0x27420231, 0x00a0040e, 0x00000000 },
+   { 0x00400001, 0x27460231, 0x00a0044e, 0x00000000 },
+   { 0x00200001, 0x27400231, 0x0000062b, 0x00000000 },
+   { 0x02000005, 0x20001c20, 0x0200006c, 0x00000002 },
+   { 0x00010001, 0x27400231, 0x0200062c, 0x00000000 },
+   { 0x00110001, 0x27410231, 0x0200040e, 0x00000000 },
+   { 0x00000008, 0x26803e2d, 0x00000070, 0x00040004 },
+   { 0x00200040, 0x22083d8c, 0x00450208, 0x00800080 },
+   { 0x00000006, 0x27083dad, 0x00000700, 0x00010001 },
+   { 0x00000040, 0x27e01c01, 0x00001400, 0x00000020 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x00000064 },
+   { 0x00000040, 0x22043d8c, 0x00000204, 0x00800080 },
+   { 0x00a02001, 0xb3800231, 0x00d20400, 0x00000000 },
+   { 0x00a02001, 0xb3a00231, 0x00d20480, 0x00000000 },
+   { 0x00a02001, 0xb3c00231, 0x00d20440, 0x00000000 },
+   { 0x00a02001, 0xb3e00231, 0x00d204c0, 0x00000000 },
+   { 0x02000005, 0x20001c20, 0x00000060, 0x00000002 },
+   { 0x01000005, 0x20001c20, 0x0200006c, 0x00000001 },
+   { 0x01010005, 0x20001c20, 0x00000060, 0x00004000 },
+   { 0x02010005, 0x20001c20, 0x02000060, 0x00000010 },
+   { 0x00030001, 0x27230231, 0x0000065f, 0x00000000 },
+   { 0x00030220, 0x34001c00, 0x00001400, 0x00000006 },
+   { 0x02600005, 0x20001c20, 0x0000006c, 0x00000001 },
+   { 0x00460001, 0x27200231, 0x0069065c, 0x00000000 },
+   { 0x00110001, 0x27230231, 0x00000458, 0x00000000 },
+   { 0x00600001, 0x27240231, 0x008d0458, 0x00000000 },
+   { 0x00600001, 0x272c0231, 0x008d0478, 0x00000000 },
+   { 0x00600001, 0x27420231, 0x00cf0663, 0x00000000 },
+   { 0x00000001, 0x27400231, 0x00000458, 0x00000000 },
+   { 0x00010001, 0x27410231, 0x0000065f, 0x00000000 },
+   { 0x00110001, 0x27410231, 0x00000663, 0x00000000 },
+   { 0x02000005, 0x20001c20, 0x0200006c, 0x00000010 },
+   { 0x00110001, 0x27420231, 0x0200065f, 0x00000000 },
+   { 0x00000005, 0x26803e2d, 0x00000071, 0x000f000f },
+   { 0x00000006, 0x27083dad, 0x00000702, 0x00020002 },
+   { 0x00000040, 0x27e01c01, 0x00001400, 0x00000020 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x00000030 },
+   { 0x00000040, 0x22043d8c, 0x00000204, 0x00800080 },
+   { 0x00400001, 0x27200231, 0x0069045c, 0x00000000 },
+   { 0x00600001, 0x27240231, 0x008d0478, 0x00000000 },
+   { 0x00800001, 0x272c0231, 0x0000047f, 0x00000000 },
+   { 0x00400001, 0x27420231, 0x00a0048e, 0x00000000 },
+   { 0x00400001, 0x27460231, 0x00a004ce, 0x00000000 },
+   { 0x00000001, 0x27400231, 0x00000478, 0x00000000 },
+   { 0x00000001, 0x27410231, 0x0000045f, 0x00000000 },
+   { 0x00000008, 0x26803e2d, 0x00000071, 0x00040004 },
+   { 0x00200040, 0x22083d8c, 0x00450208, 0x00800080 },
+   { 0x00000006, 0x27083dad, 0x00000700, 0x00030003 },
+   { 0x00000040, 0x27e01c01, 0x00001400, 0x00000020 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x00000016 },
+   { 0x00a02001, 0xb3800231, 0x00d20480, 0x00000000 },
+   { 0x00a02001, 0xb3a00231, 0x00d20500, 0x00000000 },
+   { 0x00a02001, 0xb3c00231, 0x00d204c0, 0x00000000 },
+   { 0x00a02001, 0xb3e00231, 0x00d20540, 0x00000000 },
+   { 0x00000040, 0x27e01c01, 0x00001400, 0x00000020 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x00000100 },
+   { 0x00000040, 0x27e01c01, 0x00001400, 0x00000020 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0xfffffe74 },
+   { 0x00000001, 0x27800021, 0x00000780, 0x00000000 },
+   { 0x00000001, 0x27a00021, 0x000007a0, 0x00000000 },
+   { 0x01600031, 0x20001c20, 0x708d0000, 0x82000010 },
+   { 0x00000001, 0x27340231, 0x00000733, 0x00000000 },
+   { 0x00600001, 0x274a0231, 0x00000749, 0x00000000 },
+   { 0x00800040, 0x24003e2c, 0x00b10723, 0x00020002 },
+   { 0x00800048, 0x24003e2c, 0x00b10724, 0x00020002 },
+   { 0x00800048, 0x24003e2c, 0x00b10725, 0x00010001 },
+   { 0x00800008, 0x26c03d8d, 0x008d0400, 0x00020002 },
+   { 0x00800040, 0x24003e2c, 0x00b10740, 0x00020002 },
+   { 0x00800048, 0x24003e2c, 0x00b10741, 0x00020002 },
+   { 0x00800048, 0x24003e2c, 0x00b10742, 0x00010001 },
+   { 0x00800008, 0x26a03d8d, 0x008d0400, 0x00020002 },
+   { 0x00800001, 0x27240231, 0x00d206c0, 0x00000000 },
+   { 0x00600001, 0x27400231, 0x00ae06a2, 0x00000000 },
+   { 0x00000001, 0x27230231, 0x000006a0, 0x00000000 },
+   { 0x00000005, 0x220e3dac, 0x00000680, 0x000f000f },
+   { 0x00000001, 0x26a00221, 0x00009c2c, 0x00000000 },
+   { 0x00000220, 0x34001400, 0x00001400, 0x000006a0 },
+   { 0x80800040, 0xd00045b1, 0x00b18800, 0x000d0724 },
+   { 0x80800040, 0xd02045b1, 0x00b18820, 0x000d0724 },
+   { 0x80800040, 0xd04045b1, 0x00b18840, 0x000d0724 },
+   { 0x80800040, 0xd06045b1, 0x00b18860, 0x000d0724 },
+   { 0x00000001, 0x34000020, 0x000007e0, 0x00000000 },
+   { 0x80800040, 0xd00045b1, 0x00b18800, 0x002c0740 },
+   { 0x80800040, 0xd02045b1, 0x00b18820, 0x002c0742 },
+   { 0x80800040, 0xd04045b1, 0x00b18840, 0x002c0744 },
+   { 0x80800040, 0xd06045b1, 0x00b18860, 0x002c0746 },
+   { 0x00000001, 0x34000020, 0x000007e0, 0x00000000 },
+   { 0x02800005, 0x20003da0, 0x00000708, 0x00020002 },
+   { 0x02600005, 0x20003da0, 0x02000708, 0x00010001 },
+   { 0x009a0001, 0x27200169, 0x00000000, 0x80808080 },
+   { 0x00780001, 0x27400231, 0x028d0724, 0x00000000 },
+   { 0x00780001, 0x27240231, 0x008d0740, 0x00000000 },
+   { 0x00600040, 0x25e04629, 0x008d0724, 0x008d0740 },
+   { 0x00400040, 0x25e02529, 0x006905e0, 0x006905e8 },
+   { 0x00200040, 0x25e02529, 0x004505e0, 0x004505e4 },
+   { 0x00800040, 0x2400252c, 0x000005e0, 0x000005e2 },
+   { 0x00800040, 0x24003d8c, 0x008d0400, 0x00080008 },
+   { 0x00800008, 0x26803d8d, 0x008d0400, 0x00040004 },
+   { 0x80800040, 0xd00035b1, 0x00b18800, 0x00b10680 },
+   { 0x80800040, 0xd02035b1, 0x00b18820, 0x00b10680 },
+   { 0x80800040, 0xd04035b1, 0x00b18840, 0x00b10680 },
+   { 0x80800040, 0xd06035b1, 0x00b18860, 0x00b10680 },
+   { 0x00000001, 0x34000020, 0x000007e0, 0x00000000 },
+   { 0x00600001, 0x27340231, 0x008d0733, 0x00000000 },
+   { 0x00800040, 0x24003e2c, 0x00b10726, 0x00020002 },
+   { 0x00800048, 0x24003e2c, 0x00b10725, 0x00020002 },
+   { 0x00800048, 0x24003e2c, 0x00b10724, 0x00010001 },
+   { 0x00800008, 0x26803d8d, 0x00b10400, 0x00020002 },
+   { 0x80800040, 0xd00035b1, 0x00b18800, 0x002d0680 },
+   { 0x80800040, 0xd02035b1, 0x00b18820, 0x002d0684 },
+   { 0x80800040, 0xd04035b1, 0x00b18840, 0x002d0688 },
+   { 0x80800040, 0xd06035b1, 0x00b18860, 0x002d068c },
+   { 0x00000001, 0x34000020, 0x000007e0, 0x00000000 },
+   { 0x00400009, 0x26c05421, 0x00000744, 0x00690050 },
+   { 0x00400009, 0x26d05421, 0x00000740, 0x00690050 },
+   { 0x00600001, 0x26a00231, 0x00cf06c3, 0x00000000 },
+   { 0x00800001, 0x26a80231, 0x00b10723, 0x00000000 },
+   { 0x00800040, 0x24003e2c, 0x00b106a2, 0x00020002 },
+   { 0x00800048, 0x24003e2c, 0x00b106a1, 0x00020002 },
+   { 0x00800048, 0x24003e2c, 0x00b106a0, 0x00010001 },
+   { 0x00800008, 0x26a03d8d, 0x00b10400, 0x00020002 },
+   { 0x00200040, 0x220c3eac, 0x00450056, 0x06a006a0 },
+   { 0x80800040, 0xd06035b1, 0x01ed9800, 0x00b18860 },
+   { 0x80800040, 0xd04035b1, 0x01ed9804, 0x00b18840 },
+   { 0x80800040, 0xd02035b1, 0x01ed9808, 0x00b18820 },
+   { 0x80800040, 0xd00035b1, 0x01ed980c, 0x00b18800 },
+   { 0x00000001, 0x34000020, 0x000007e0, 0x00000000 },
+   { 0x00400009, 0x26c05421, 0x00000744, 0x00690050 },
+   { 0x00400009, 0x26d05421, 0x00000740, 0x00690050 },
+   { 0x00600001, 0x26a00231, 0x00cf06c3, 0x00000000 },
+   { 0x00800001, 0x26a80231, 0x00b10723, 0x00000000 },
+   { 0x00800042, 0x25c04629, 0x00b106a8, 0x00b106a9 },
+   { 0x00800040, 0x24003e2c, 0x00b106a3, 0x00020002 },
+   { 0x00800048, 0x24003e2c, 0x00b106a2, 0x00020002 },
+   { 0x00800048, 0x24003e2c, 0x00b106a1, 0x00010001 },
+   { 0x00800008, 0x26c03d8d, 0x008d0400, 0x00020002 },
+   { 0x00600001, 0x26a00231, 0x00ae06c0, 0x00000000 },
+   { 0x00600001, 0x46a60231, 0x00ae06cc, 0x00000000 },
+   { 0x00600001, 0x46a70231, 0x00ae05c0, 0x00000000 },
+   { 0x00200040, 0x220c3eac, 0x00450036, 0x06a006a0 },
+   { 0x80800040, 0xd0603631, 0x01ee9800, 0x00b18860 },
+   { 0x80800040, 0xd0403631, 0x01ee9802, 0x00b18840 },
+   { 0x80800040, 0xd0203631, 0x01ee9804, 0x00b18820 },
+   { 0x80800040, 0xd0003631, 0x01ee9806, 0x00b18800 },
+   { 0x00000001, 0x34000020, 0x000007e0, 0x00000000 },
+   { 0x00400009, 0x26c05421, 0x00000744, 0x00690050 },
+   { 0x00400009, 0x26d05421, 0x00000740, 0x00690050 },
+   { 0x00600001, 0x26a00231, 0x00ab06c3, 0x00000000 },
+   { 0x00800001, 0x26a80231, 0x00b10723, 0x00000000 },
+   { 0x00800040, 0x24003e2c, 0x00b106a2, 0x00020002 },
+   { 0x00800048, 0x24003e2c, 0x00b106a1, 0x00020002 },
+   { 0x00800048, 0x24003e2c, 0x00b106a0, 0x00010001 },
+   { 0x00800008, 0x25c03d89, 0x008d0400, 0x00020002 },
+   { 0x00800042, 0x26a0462d, 0x00b106a0, 0x00b106a1 },
+   { 0x00600001, 0x46a10231, 0x00ae05c0, 0x00000000 },
+   { 0x00600001, 0x26b00231, 0x00ae05d0, 0x00000000 },
+   { 0x00200040, 0x220c3eac, 0x00450056, 0x06a006a0 },
+   { 0x80800040, 0xd0603631, 0x01ed9800, 0x00b18860 },
+   { 0x80800040, 0xd0403631, 0x01ed9804, 0x00b18840 },
+   { 0x80800040, 0xd0203631, 0x01ed9808, 0x00b18820 },
+   { 0x80800040, 0xd0003631, 0x01ed980c, 0x00b18800 },
+   { 0x00000001, 0x34000020, 0x000007e0, 0x00000000 },
+   { 0x00800042, 0x25c04629, 0x00b10724, 0x00b10725 },
+   { 0x00800040, 0x24003e2c, 0x00b10726, 0x00020002 },
+   { 0x00800048, 0x24003e2c, 0x00b10725, 0x00020002 },
+   { 0x00800048, 0x24003e2c, 0x00b10724, 0x00010001 },
+   { 0x00800008, 0x25e03d89, 0x00240400, 0x00020002 },
+   { 0x80800040, 0xd0003531, 0x00ad05c0, 0x00b18800 },
+   { 0x80800040, 0xd0203531, 0x00ad05c2, 0x00b18820 },
+   { 0x80800040, 0xd0403531, 0x00ad05c4, 0x00b18840 },
+   { 0x80800040, 0xd0603531, 0x00ad05c6, 0x00b18860 },
+   { 0x00000001, 0x34000020, 0x000007e0, 0x00000000 },
+   { 0x00600001, 0x27480231, 0x00000747, 0x00000000 },
+   { 0x00800042, 0x25c04629, 0x00b10740, 0x00b10741 },
+   { 0x00800040, 0x24003e2c, 0x00b10742, 0x00020002 },
+   { 0x00800048, 0x24003e2c, 0x00b10741, 0x00020002 },
+   { 0x00800048, 0x24003e2c, 0x00b10740, 0x00010001 },
+   { 0x00800008, 0x25e03d89, 0x00240400, 0x00020002 },
+   { 0x00800001, 0x45c10231, 0x00d205e0, 0x00000000 },
+   { 0x80800040, 0xd0003631, 0x004d05c0, 0x00b18800 },
+   { 0x80800040, 0xd0203631, 0x004d05c4, 0x00b18820 },
+   { 0x80800040, 0xd0403631, 0x004d05c8, 0x00b18840 },
+   { 0x80800040, 0xd0603631, 0x004d05cc, 0x00b18860 },
+   { 0x00000001, 0x34000020, 0x000007e0, 0x00000000 },
+   { 0x00000401, 0x27c80061, 0x00000000, 0x000f000f },
+   { 0x00200801, 0x27c001a1, 0x004507fa, 0x00000000 },
+   { 0x00000040, 0x22000c00, 0x00000200, 0x0ff04000 },
+   { 0x00800001, 0x20400232, 0x00cd0400, 0x00000000 },
+   { 0x00800001, 0x20500232, 0x00cd0408, 0x00000000 },
+   { 0x00800001, 0x20600232, 0x00cd0410, 0x00000000 },
+   { 0x00800001, 0x20700232, 0x00cd0418, 0x00000000 },
+   { 0x00800001, 0x20800232, 0x00cd0440, 0x00000000 },
+   { 0x00800001, 0x20900232, 0x00cd0448, 0x00000000 },
+   { 0x00800001, 0x20a00232, 0x00cd0450, 0x00000000 },
+   { 0x00800001, 0x20b00232, 0x00cd0458, 0x00000000 },
+   { 0x00800001, 0x20c00232, 0x00cd0480, 0x00000000 },
+   { 0x00800001, 0x20d00232, 0x00cd0488, 0x00000000 },
+   { 0x00800001, 0x20e00232, 0x00cd0490, 0x00000000 },
+   { 0x00800001, 0x20f00232, 0x00cd0498, 0x00000000 },
+   { 0x00800001, 0x21000232, 0x00cd04c0, 0x00000000 },
+   { 0x00800001, 0x21100232, 0x00cd04c8, 0x00000000 },
+   { 0x00800001, 0x21200232, 0x00cd04d0, 0x00000000 },
+   { 0x00800001, 0x21300232, 0x00cd04d8, 0x00000000 },
+   { 0x01600031, 0x27800021, 0x508d07c0, 0x00000200 },
+   { 0x00000001, 0x34000020, 0x000007e0, 0x00000000 },
+   { 0x00600001, 0x27c00021, 0x008d0000, 0x00000000 },
+   { 0x00200009, 0x27fa3e29, 0x00450064, 0x00040004 },
+   { 0x00000040, 0x27e01c01, 0x00001400, 0x00000020 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0xfffffd34 },
+   { 0x00000001, 0x220401ec, 0x00000000, 0x00800080 },
+   { 0x00000001, 0x220601ec, 0x00000000, 0x04000400 },
+   { 0x00200008, 0x27006e2d, 0x0000006c, 0x00000040 },
+   { 0x02600005, 0x20003e20, 0x0000006c, 0x00040004 },
+   { 0x00780001, 0x26340231, 0x00000633, 0x00000000 },
+   { 0x00800001, 0x27200231, 0x00b10620, 0x00000000 },
+   { 0x00600001, 0x27400231, 0x00cf0643, 0x00000000 },
+   { 0x00400008, 0x26806e2d, 0x00240070, 0x00004040 },
+   { 0x00000040, 0x27e01c01, 0x00001400, 0x00000020 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x0000006a },
+   { 0x00000040, 0x22043d8c, 0x00000204, 0x00800080 },
+   { 0x00000006, 0x27003dad, 0x00000700, 0x00010001 },
+   { 0x00800001, 0x27200231, 0x00b10628, 0x00000000 },
+   { 0x00400001, 0x27400231, 0x00808c26, 0x00000000 },
+   { 0x00400001, 0x27440231, 0x00808c66, 0x00000000 },
+   { 0x00400008, 0x26806e2d, 0x00240072, 0x00004040 },
+   { 0x00000040, 0x22063d8c, 0x00000206, 0x00800080 },
+   { 0x00000040, 0x27e01c01, 0x00001400, 0x00000020 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x00000058 },
+   { 0x00000040, 0x22043d8c, 0x00000204, 0x00800080 },
+   { 0x00000006, 0x27003dad, 0x00000702, 0x00020002 },
+   { 0x00800001, 0xaf800231, 0x00d28f80, 0x00000000 },
+   { 0x00800001, 0xaf900231, 0x00d28fa0, 0x00000000 },
+   { 0x00800001, 0xafc00231, 0x00d28fc0, 0x00000000 },
+   { 0x00800001, 0xafd00231, 0x00d28fe0, 0x00000000 },
+   { 0x00800001, 0xafa00231, 0x00d28c00, 0x00000000 },
+   { 0x00800001, 0xafb00231, 0x00d28c20, 0x00000000 },
+   { 0x00800001, 0xafe00231, 0x00d28c40, 0x00000000 },
+   { 0x00800001, 0xaff00231, 0x00d28c60, 0x00000000 },
+   { 0x00400001, 0x27200231, 0x0069065c, 0x00000000 },
+   { 0x00600001, 0x27240231, 0x00a98fcc, 0x00000000 },
+   { 0x00600001, 0x272c0231, 0x00a98fec, 0x00000000 },
+   { 0x00600001, 0x27340231, 0x00008fff, 0x00000000 },
+   { 0x00800001, 0x2620012d, 0x00b10720, 0x00000000 },
+   { 0x00600001, 0x27400231, 0x00cf0663, 0x00000000 },
+   { 0x00400008, 0x26806e2d, 0x00240074, 0x00004040 },
+   { 0x00000040, 0x27e01c01, 0x00001400, 0x00000020 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x00000032 },
+   { 0x00000040, 0x22043d8c, 0x00000204, 0x00800080 },
+   { 0x00000006, 0x27003dad, 0x00000700, 0x00010001 },
+   { 0x00800001, 0x27200231, 0x00b10628, 0x00000000 },
+   { 0x00600001, 0x27300231, 0x008d0638, 0x00000000 },
+   { 0x00400001, 0x27400231, 0x00808c26, 0x00000000 },
+   { 0x00400001, 0x27440231, 0x00808c66, 0x00000000 },
+   { 0x00400008, 0x26806e2d, 0x00240076, 0x00004040 },
+   { 0x00000040, 0x22063d8c, 0x00000206, 0x00800080 },
+   { 0x00000040, 0x27e01c01, 0x00001400, 0x00000020 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x0000001e },
+   { 0x00800001, 0xaf800231, 0x00d28f80, 0x00000000 },
+   { 0x00800001, 0xaf900231, 0x00d28fa0, 0x00000000 },
+   { 0x00800001, 0xafc00231, 0x00d28fc0, 0x00000000 },
+   { 0x00800001, 0xafd00231, 0x00d28fe0, 0x00000000 },
+   { 0x00800001, 0xafa00231, 0x00d28c00, 0x00000000 },
+   { 0x00800001, 0xafb00231, 0x00d28c20, 0x00000000 },
+   { 0x00800001, 0xafe00231, 0x00d28c40, 0x00000000 },
+   { 0x00800001, 0xaff00231, 0x00d28c60, 0x00000000 },
+   { 0x00000040, 0x27e01c01, 0x00001400, 0x00000020 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x000000e0 },
+   { 0x00000040, 0x27e01c01, 0x00001400, 0x00000020 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0xfffffcce },
+   { 0x00000001, 0x27800021, 0x00000780, 0x00000000 },
+   { 0x00000001, 0x27a00021, 0x000007a0, 0x00000000 },
+   { 0x01600031, 0x20001c20, 0x708d0000, 0x82000010 },
+   { 0x00600001, 0x27800231, 0x008d0740, 0x00000000 },
+   { 0x00400005, 0x22083dac, 0x00690680, 0x000f000f },
+   { 0x00400040, 0x26a04625, 0x01e09020, 0x00690058 },
+   { 0x00000001, 0x26d001ad, 0x00000700, 0x00000000 },
+   { 0x00000040, 0x27e41c01, 0x00001400, 0x00000020 },
+   { 0x00000220, 0x34001400, 0x00001400, 0x000006a0 },
+   { 0x80600040, 0xcc0035b1, 0x00898800, 0x008d0760 },
+   { 0x80600040, 0xcc1035b1, 0x00898820, 0x008d0770 },
+   { 0x00800001, 0x27200231, 0x008d0724, 0x00000000 },
+   { 0x00400001, 0x27400231, 0x00808c06, 0x00000000 },
+   { 0x00000006, 0x26d03dad, 0x00000700, 0x00010001 },
+   { 0x00000040, 0x27e41c01, 0x00001400, 0x00000020 },
+   { 0x00000220, 0x34001400, 0x00001400, 0x000006a4 },
+   { 0x80600040, 0xcc2035b1, 0x00898808, 0x008d0760 },
+   { 0x80600040, 0xcc3035b1, 0x00898828, 0x008d0770 },
+   { 0x00000001, 0x27230231, 0x00000783, 0x00000000 },
+   { 0x00400001, 0x27240231, 0x008a8c18, 0x00000000 },
+   { 0x00400001, 0x27280231, 0x008a8c38, 0x00000000 },
+   { 0x00400001, 0x272c0231, 0x00008c3e, 0x00000000 },
+   { 0x00400001, 0x27400231, 0x00690784, 0x00000000 },
+   { 0x00000006, 0x26d03dad, 0x00000700, 0x00020002 },
+   { 0x00000040, 0x27e41c01, 0x00001400, 0x00000020 },
+   { 0x00000220, 0x34001400, 0x00001400, 0x000006a8 },
+   { 0x80600040, 0xcc4035b1, 0x00898840, 0x008d0760 },
+   { 0x80600040, 0xcc5035b1, 0x00898860, 0x008d0770 },
+   { 0x00800001, 0x27200231, 0x008d0724, 0x00000000 },
+   { 0x00600001, 0x27280231, 0x00000727, 0x00000000 },
+   { 0x00400001, 0x27400231, 0x00808c46, 0x00000000 },
+   { 0x00000006, 0x26d03dad, 0x00000700, 0x00030003 },
+   { 0x00000040, 0x27e41c01, 0x00001400, 0x00000020 },
+   { 0x00000220, 0x34001400, 0x00001400, 0x000006ac },
+   { 0x80600040, 0xcc6035b1, 0x00898848, 0x008d0760 },
+   { 0x80600040, 0xcc7035b1, 0x00898868, 0x008d0770 },
+   { 0x00000001, 0x34000020, 0x000007e0, 0x00000000 },
+   { 0x00800001, 0x2760022d, 0x00090724, 0x00000000 },
+   { 0x00000001, 0x34000020, 0x000007e4, 0x00000000 },
+   { 0x00800001, 0x2760022d, 0x00280740, 0x00000000 },
+   { 0x00000001, 0x34000020, 0x000007e4, 0x00000000 },
+   { 0x02802005, 0x20003da0, 0x000006d0, 0x00020002 },
+   { 0x02802005, 0x20003da0, 0x020006d0, 0x00010001 },
+   { 0x009a0001, 0x27200169, 0x00000000, 0x80808080 },
+   { 0x00780001, 0x27400231, 0x028d0724, 0x00000000 },
+   { 0x00780001, 0x27240231, 0x008d0740, 0x00000000 },
+   { 0x00400040, 0x25e04629, 0x00690724, 0x00690740 },
+   { 0x00200040, 0x25e02529, 0x004505e0, 0x004505e4 },
+   { 0x00800040, 0x2400252c, 0x000005e0, 0x000005e2 },
+   { 0x00800040, 0x24003d8c, 0x008d0400, 0x00040004 },
+   { 0x00800008, 0x27603d8d, 0x008d0400, 0x00030003 },
+   { 0x00000001, 0x34000020, 0x000007e4, 0x00000000 },
+   { 0x00600001, 0x26c00231, 0x008d0724, 0x00000000 },
+   { 0x00400001, 0x26c80231, 0x0069072b, 0x00000000 },
+   { 0x00600040, 0x24003e2c, 0x008d06c2, 0x00020002 },
+   { 0x00600048, 0x24003e2c, 0x008d06c1, 0x00020002 },
+   { 0x00600048, 0x25e03e29, 0x008d06c0, 0x00010001 },
+   { 0x00800008, 0x27603d2d, 0x002905e0, 0x00020002 },
+   { 0x00000001, 0x34000020, 0x000007e4, 0x00000000 },
+   { 0x00400009, 0x26e05421, 0x00000740, 0x00690050 },
+   { 0x00600001, 0x26c40231, 0x008d0723, 0x00000000 },
+   { 0x00400001, 0x26c00231, 0x00ab06e3, 0x00000000 },
+   { 0x00600040, 0x24003e2c, 0x008d06c2, 0x00020002 },
+   { 0x00600048, 0x24003e2c, 0x008d06c1, 0x00020002 },
+   { 0x00600048, 0x26c03e2d, 0x008d06c0, 0x00010001 },
+   { 0x00400040, 0x22083eac, 0x00690054, 0x06c006c0 },
+   { 0x00800008, 0x27603dad, 0x01e99000, 0x00020002 },
+   { 0x00000001, 0x34000020, 0x000007e4, 0x00000000 },
+   { 0x00400009, 0x26e05421, 0x00000740, 0x00690050 },
+   { 0x00600001, 0x26c40231, 0x008d0723, 0x00000000 },
+   { 0x00400001, 0x26c00231, 0x00ab06e3, 0x00000000 },
+   { 0x00600042, 0x25c04629, 0x008d06c4, 0x008d06c5 },
+   { 0x00600040, 0x24003e2c, 0x008d06c3, 0x00020002 },
+   { 0x00600048, 0x24003e2c, 0x008d06c2, 0x00020002 },
+   { 0x00600048, 0x24003e2c, 0x008d06c1, 0x00010001 },
+   { 0x00600008, 0x26c03d8d, 0x008d0400, 0x00020002 },
+   { 0x00400001, 0x46c401ad, 0x006906c4, 0x00000000 },
+   { 0x00400001, 0x46c6012d, 0x006905c0, 0x00000000 },
+   { 0x00400040, 0x22083eac, 0x00690054, 0x06c006c0 },
+   { 0x00800001, 0x276001ad, 0x01ea9000, 0x00000000 },
+   { 0x00000001, 0x34000020, 0x000007e4, 0x00000000 },
+   { 0x00400009, 0x26e05421, 0x00000740, 0x00690050 },
+   { 0x00600001, 0x26c40231, 0x008d0723, 0x00000000 },
+   { 0x00400001, 0x26c00231, 0x00ab06e3, 0x00000000 },
+   { 0x00600042, 0x25c04629, 0x008d06c0, 0x008d06c1 },
+   { 0x00600040, 0x24003e2c, 0x008d06c2, 0x00020002 },
+   { 0x00600048, 0x24003e2c, 0x008d06c1, 0x00020002 },
+   { 0x00600048, 0x26e03e2d, 0x008d06c0, 0x00010001 },
+   { 0x00400008, 0x46c23dad, 0x006906e0, 0x00020002 },
+   { 0x00200008, 0x26d03dad, 0x004506e8, 0x00020002 },
+   { 0x00400001, 0x46c0012d, 0x006905c0, 0x00000000 },
+   { 0x00400009, 0x22083eac, 0x00690054, 0x00010001 },
+   { 0x00400040, 0x22083d8c, 0x00690208, 0x06c006c0 },
+   { 0x00800001, 0x276001ad, 0x01e99000, 0x00000000 },
+   { 0x00000001, 0x34000020, 0x000007e4, 0x00000000 },
+   { 0x00600042, 0x45c04629, 0x008d0724, 0x008d0725 },
+   { 0x00600040, 0x24003e2c, 0x008d0726, 0x00020002 },
+   { 0x00600048, 0x24003e2c, 0x008d0725, 0x00020002 },
+   { 0x00600048, 0x25e03e29, 0x008d0724, 0x00010001 },
+   { 0x00600008, 0x45c23d29, 0x008d05e0, 0x00020002 },
+   { 0x00800001, 0x2760012d, 0x002a05c0, 0x00000000 },
+   { 0x00000001, 0x34000020, 0x000007e4, 0x00000000 },
+   { 0x00600001, 0x27440231, 0x00000743, 0x00000000 },
+   { 0x00600042, 0x45c04629, 0x008d0740, 0x008d0741 },
+   { 0x00600040, 0x24003e2c, 0x008d0742, 0x00020002 },
+   { 0x00600048, 0x24003e2c, 0x008d0741, 0x00020002 },
+   { 0x00600048, 0x25e03e29, 0x008d0740, 0x00010001 },
+   { 0x00600008, 0x45c23d29, 0x008d05e0, 0x00020002 },
+   { 0x00800001, 0x2760012d, 0x004905c0, 0x00000000 },
+   { 0x00000001, 0x34000020, 0x000007e4, 0x00000000 },
+   { 0x00000401, 0x27c80061, 0x00000000, 0x000f000f },
+   { 0x00200801, 0x27c001a1, 0x004507fa, 0x00000000 },
+   { 0x00000040, 0x22000c00, 0x00000200, 0x0ff04000 },
+   { 0x00800001, 0x20400232, 0x00a90400, 0x00000000 },
+   { 0x00800001, 0x20500232, 0x00a90404, 0x00000000 },
+   { 0x00800001, 0x20600232, 0x00a90408, 0x00000000 },
+   { 0x00800001, 0x20700232, 0x00a9040c, 0x00000000 },
+   { 0x00800001, 0x20800232, 0x00a90440, 0x00000000 },
+   { 0x00800001, 0x20900232, 0x00a90444, 0x00000000 },
+   { 0x00800001, 0x20a00232, 0x00a90448, 0x00000000 },
+   { 0x00800001, 0x20b00232, 0x00a9044c, 0x00000000 },
+   { 0x00800001, 0x20c00232, 0x00a90480, 0x00000000 },
+   { 0x00800001, 0x20d00232, 0x00a90484, 0x00000000 },
+   { 0x00800001, 0x20e00232, 0x00a90488, 0x00000000 },
+   { 0x00800001, 0x20f00232, 0x00a9048c, 0x00000000 },
+   { 0x00800001, 0x21000232, 0x00a904c0, 0x00000000 },
+   { 0x00800001, 0x21100232, 0x00a904c4, 0x00000000 },
+   { 0x00800001, 0x21200232, 0x00a904c8, 0x00000000 },
+   { 0x00800001, 0x21300232, 0x00a904cc, 0x00000000 },
+   { 0x01600031, 0x27800021, 0x508d07c0, 0x00000200 },
+   { 0x00000001, 0x34000020, 0x000007e0, 0x00000000 },
+   { 0x00000000, 0x00000000, 0x00000000, 0x00000000 },
+   { 0x00600001, 0x27c00021, 0x008d0000, 0x00000000 },
+   { 0x00200009, 0x27fa3e29, 0x00450064, 0x00040004 },
+   { 0x00000401, 0x27c80061, 0x00000000, 0x000f000f },
+   { 0x00200809, 0x27c03e21, 0x00450064, 0x00040004 },
+   { 0x00000040, 0x22000d20, 0x00000062, 0x1218a000 },
+   { 0x00a02401, 0x20400232, 0x00b10080, 0x00000000 },
+   { 0x00a02801, 0x20500232, 0x00b10090, 0x00000000 },
+   { 0x00a02401, 0x20800232, 0x00b100c0, 0x00000000 },
+   { 0x00a02801, 0x20900232, 0x00b100d0, 0x00000000 },
+   { 0x00a02401, 0x20c00232, 0x00b10100, 0x00000000 },
+   { 0x00a02801, 0x20d00232, 0x00b10110, 0x00000000 },
+   { 0x00a02401, 0x21000232, 0x00b10140, 0x00000000 },
+   { 0x00a02801, 0x21100232, 0x00b10150, 0x00000000 },
+   { 0x01600031, 0x27800021, 0x508d07c0, 0x00000200 },
+   { 0x00000401, 0x20280062, 0x00000000, 0x0007000f },
+   { 0x0000080c, 0x20243c22, 0x000007c4, 0x00010001 },
+   { 0x00000040, 0x22001c00, 0x00000200, 0xf8000001 },
+   { 0x00800001, 0x40400232, 0x00b10180, 0x00000000 },
+   { 0x00800001, 0x40410232, 0x00b101c0, 0x00000000 },
+   { 0x00800001, 0x40600232, 0x00b10190, 0x00000000 },
+   { 0x00800001, 0x40610232, 0x00b101d0, 0x00000000 },
+   { 0x00800001, 0x40800232, 0x00b101a0, 0x00000000 },
+   { 0x00800001, 0x40810232, 0x00b101e0, 0x00000000 },
+   { 0x00800001, 0x40a00232, 0x00b101b0, 0x00000000 },
+   { 0x00800001, 0x40a10232, 0x00b101f0, 0x00000000 },
+   { 0x01600031, 0x27a00001, 0x508d0000, 0x00000200 },
+   { 0x00000001, 0x27800021, 0x00000780, 0x00000000 },
+   { 0x00000001, 0x27a00021, 0x000007a0, 0x00000000 },
+   { 0x01600031, 0x20001c20, 0x708d0000, 0x82000010 },
+   { 0x00000000, 0x00000000, 0x00000000, 0x00000000 },
+   { 0x00000000, 0x00000000, 0x00000000, 0x00000000 },
+   { 0x00000000, 0x00000000, 0x00000000, 0x00000000 },
+   { 0x00600001, 0x20400021, 0x008d0000, 0x00000000 },
+   { 0x00000005, 0x20203e2d, 0x00000061, 0x001f001f },
+   { 0x00200009, 0x20643e2d, 0x00450064, 0x00040004 },
+   { 0x00000001, 0x203a01ed, 0x00000000, 0x00000000 },
+   { 0x01000010, 0x20003dac, 0x00000020, 0x00160016 },
+   { 0x00110220, 0x34001c00, 0x00001400, 0x0000001e },
+   { 0x01200010, 0x20003e2c, 0x0200006c, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x02001400, 0x00000024 },
+   { 0x00800009, 0x25403dad, 0x00050064, 0x00020002 },
+   { 0x00000001, 0x203a01ed, 0x00000000, 0x00180018 },
+   { 0x00200040, 0x45483dad, 0x00660548, 0x00100010 },
+   { 0x00200040, 0x45523dad, 0x00660552, 0x00100010 },
+   { 0x00400040, 0x25583dad, 0x00690558, 0x00100010 },
+   { 0x00800040, 0x208035ad, 0x00b10080, 0x00b10540 },
+   { 0x00600040, 0x45403dad, 0x00ae0540, 0x00200020 },
+   { 0x00800040, 0x20a035ad, 0x00b100a0, 0x00b10540 },
+   { 0x00600040, 0x45423dad, 0x00ae0542, 0x00200020 },
+   { 0x00800040, 0x20e035ad, 0x00b100e0, 0x00b10540 },
+   { 0x00600040, 0x45403dad, 0x00ae0540, 0xffe0ffe0 },
+   { 0x00800040, 0x20c035ad, 0x00b100c0, 0x00b10540 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x00000014 },
+   { 0x06600010, 0x20003dac, 0x02000020, 0x00030003 },
+   { 0x00000001, 0x206c0171, 0x00000000, 0x00000000 },
+   { 0x00610001, 0x208000a5, 0x02050080, 0x00000000 },
+   { 0x00610001, 0x212000a5, 0x02090100, 0x00000000 },
+   { 0x00410001, 0x211000a5, 0x02690100, 0x00000000 },
+   { 0x00200009, 0x25403dad, 0x00450064, 0x00020002 },
+   { 0x00800040, 0x208035ad, 0x00b10080, 0x00050540 },
+   { 0x00200040, 0x40883dad, 0x00660088, 0x00200020 },
+   { 0x00200040, 0x40923dad, 0x00660092, 0x00200020 },
+   { 0x00400040, 0x20983dad, 0x00690098, 0x00200020 },
+   { 0x00200401, 0x22080060, 0x00000000, 0x03400140 },
+   { 0x00000c01, 0x220c0060, 0x00000000, 0x04400080 },
+   { 0x00000801, 0x22040060, 0x00000000, 0x01000070 },
+   { 0x00000001, 0x20200169, 0x00000000, 0x00000000 },
+   { 0x0000000c, 0x2458262d, 0x0000006d, 0x00000020 },
+   { 0x00000001, 0x210e0169, 0x00000000, 0x00010001 },
+   { 0x00000005, 0x24583dad, 0x00000458, 0x00030003 },
+   { 0x01000010, 0x200035ac, 0x0000010e, 0x00000458 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x000002fe },
+   { 0x01000010, 0x20003dac, 0x0200010e, 0x00010001 },
+   { 0x00010401, 0x24540061, 0x02000000, 0x06c00640 },
+   { 0x00010805, 0x245a3e2d, 0x02008800, 0x007f007f },
+   { 0x00110401, 0x24540061, 0x02000000, 0x04800780 },
+   { 0x00110805, 0x245a3e2d, 0x02008804, 0x007f007f },
+   { 0x0000000c, 0x211e362d, 0x0000006c, 0x00000020 },
+   { 0x00000040, 0x20780d21, 0x0000045a, 0x0208a002 },
+   { 0x02000005, 0x20003dac, 0x0200011e, 0x00030003 },
+   { 0x00010220, 0x34001c00, 0x02001400, 0x000001be },
+   { 0x01000005, 0x20003dac, 0x00009800, 0x00030003 },
+   { 0x00200005, 0x24443dad, 0x00459800, 0x00030003 },
+   { 0x0020000c, 0x24403dad, 0x00459800, 0x00020002 },
+   { 0x01600006, 0x20003dac, 0x02000446, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x00000012 },
+   { 0x00010040, 0x22000c20, 0x02000078, 0x00400000 },
+   { 0x00110040, 0x22000c20, 0x02000078, 0x00700000 },
+   { 0x00310040, 0x20401da5, 0x02450440, 0xfffffffe },
+   { 0x00110001, 0x20480061, 0x02000000, 0x000c000c },
+   { 0x00010040, 0x20401da5, 0x02000440, 0xfffffffe },
+   { 0x00010001, 0x204401a5, 0x02000442, 0x00000000 },
+   { 0x00010001, 0x20480061, 0x02000000, 0x0007000c },
+   { 0x01600031, 0x25600021, 0x408d0040, 0x00000200 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x0000000e },
+   { 0x00010040, 0x22000c20, 0x02000078, 0x00200000 },
+   { 0x00110040, 0x22000c20, 0x02000078, 0x00400000 },
+   { 0x00200001, 0x204001a5, 0x00450440, 0x00000000 },
+   { 0x00110040, 0x20441da5, 0x02000442, 0xfffffffe },
+   { 0x00110001, 0x20480061, 0x02000000, 0x000c0007 },
+   { 0x00010001, 0x20480061, 0x02000000, 0x00070007 },
+   { 0x01600031, 0x25600021, 0x408d0040, 0x00000200 },
+   { 0x0020040c, 0x24403dad, 0x00459800, 0x00030003 },
+   { 0x00200805, 0x24483dad, 0x00459800, 0x00070007 },
+   { 0x01600006, 0x20003dac, 0x0000044a, 0x00000000 },
+   { 0x00200001, 0x204001a5, 0x00450440, 0x00000000 },
+   { 0x00000009, 0x20403ca5, 0x00000040, 0x00010001 },
+   { 0x00010040, 0x22000c20, 0x00000078, 0x00200010 },
+   { 0x00110040, 0x22000c20, 0x00000078, 0x00300010 },
+   { 0x00010001, 0x20480061, 0x00000000, 0x00030009 },
+   { 0x00110001, 0x20480061, 0x00000000, 0x00040009 },
+   { 0x02600031, 0x27000021, 0x408d0040, 0x00000200 },
+   { 0x01000005, 0x20003dac, 0x00009800, 0x00030003 },
+   { 0x00110220, 0x34001c00, 0x00001400, 0x0000001a },
+   { 0x00600001, 0x26220231, 0x008d05c0, 0x00000000 },
+   { 0x00600401, 0x26120231, 0x008d05b8, 0x00000000 },
+   { 0x00600801, 0x26020231, 0x008d05b0, 0x00000000 },
+   { 0x00600401, 0x25f20231, 0x008d05a8, 0x00000000 },
+   { 0x00600801, 0x25e20231, 0x008d05a0, 0x00000000 },
+   { 0x00600401, 0x25d20231, 0x008d0598, 0x00000000 },
+   { 0x00600801, 0x25c20231, 0x008d0590, 0x00000000 },
+   { 0x00600401, 0x25b20231, 0x008d0588, 0x00000000 },
+   { 0x00600801, 0x25a20231, 0x008d0580, 0x00000000 },
+   { 0x00600401, 0x25920231, 0x008d0578, 0x00000000 },
+   { 0x00600801, 0x25820231, 0x008d0570, 0x00000000 },
+   { 0x00600001, 0x25720231, 0x008d0568, 0x00000000 },
+   { 0x00600001, 0x25620231, 0x008d0560, 0x00000000 },
+   { 0x00110001, 0x220001ec, 0x02000000, 0x05820582 },
+   { 0x00010001, 0x220001ec, 0x02000000, 0x05620562 },
+   { 0x00000001, 0x220e0128, 0x00000454, 0x00000000 },
+   { 0x01800006, 0x200035ac, 0x02000446, 0x00000444 },
+   { 0x00810001, 0xbc000229, 0x02ad8000, 0x00000000 },
+   { 0x00810001, 0xbc200229, 0x02ad8020, 0x00000000 },
+   { 0x00810001, 0xbc400229, 0x02ad8040, 0x00000000 },
+   { 0x00810001, 0xbc600229, 0x02ad8060, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x02001400, 0x0000012a },
+   { 0x00600001, 0x2024018d, 0x008d0200, 0x00000000 },
+   { 0x01000041, 0x245e35ad, 0x00000446, 0x00000444 },
+   { 0x00000040, 0x22022d08, 0x00000200, 0x00100010 },
+   { 0x02000005, 0x20003db0, 0x0200045e, 0x00010001 },
+   { 0x00200040, 0x22042d08, 0x00450200, 0x00200020 },
+   { 0x00400001, 0x244c0109, 0x00690200, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x00000066 },
+   { 0x00010220, 0x34001c00, 0x02001400, 0x00000064 },
+   { 0x00000040, 0x22003d08, 0x00000200, 0xffdeffde },
+   { 0x00000440, 0x22023d08, 0x00000202, 0xffeeffee },
+   { 0x00000801, 0x220c0060, 0x00000000, 0x04a00480 },
+   { 0x01000010, 0x20003db0, 0x0000045e, 0x00040004 },
+   { 0x00a02040, 0x2400462c, 0x00ad8000, 0x00ad8005 },
+   { 0x00a02048, 0x24003e2c, 0x00ad8001, 0xfffbfffb },
+   { 0x00a02048, 0x24003e2c, 0x00ad8002, 0x00140014 },
+   { 0x00a02048, 0x24003e2c, 0x00ad8003, 0x00140014 },
+   { 0x00a02048, 0xb8003e2d, 0x00ad8004, 0xfffbfffb },
+   { 0x00a02040, 0x2400462c, 0x00ad8040, 0x00ad8045 },
+   { 0x00a02048, 0x24003e2c, 0x00ad8041, 0xfffbfffb },
+   { 0x00a02048, 0x24003e2c, 0x00ad8042, 0x00140014 },
+   { 0x00a02048, 0x24003e2c, 0x00ad8043, 0x00140014 },
+   { 0x00a02048, 0xb8403e2d, 0x00ad8044, 0xfffbfffb },
+   { 0x00a02040, 0x2400462c, 0x00ad8080, 0x00ad8085 },
+   { 0x00a02048, 0x24003e2c, 0x00ad8081, 0xfffbfffb },
+   { 0x00a02048, 0x24003e2c, 0x00ad8082, 0x00140014 },
+   { 0x00a02048, 0x24003e2c, 0x00ad8083, 0x00140014 },
+   { 0x00a02048, 0xb8803e2d, 0x00ad8084, 0xfffbfffb },
+   { 0x00600040, 0x2400462c, 0x008d80c0, 0x008d80c5 },
+   { 0x00600048, 0x24003e2c, 0x008d80c1, 0xfffbfffb },
+   { 0x00600048, 0x24003e2c, 0x008d80c2, 0x00140014 },
+   { 0x00600048, 0x24003e2c, 0x008d80c3, 0x00140014 },
+   { 0x00600048, 0xb8c03e2d, 0x008d80c4, 0xfffbfffb },
+   { 0x00000401, 0x22000060, 0x00000000, 0x04a00480 },
+   { 0x00000c01, 0x22040060, 0x00000000, 0x04a00490 },
+   { 0x00010802, 0x220c2d28, 0x00000454, 0x04800480 },
+   { 0x00a02040, 0x24003dac, 0x00b18000, 0x02000200 },
+   { 0x00800048, 0x24003dac, 0x01ed8800, 0xfffbfffb },
+   { 0x00800048, 0x24203dac, 0x01ed8820, 0xfffbfffb },
+   { 0x00a02048, 0x24003dac, 0x00b18020, 0x00140014 },
+   { 0x00800048, 0x24003dac, 0x01ed8820, 0x00140014 },
+   { 0x00800048, 0x24203dac, 0x01ed8840, 0x00140014 },
+   { 0x00a02048, 0x24003dac, 0x00b18040, 0xfffbfffb },
+   { 0x00800048, 0x24003dac, 0x01ed8840, 0x00010001 },
+   { 0x00800048, 0x24203dac, 0x01ed8860, 0x00010001 },
+   { 0x8080000c, 0xd8003d91, 0x00b10400, 0x000a000a },
+   { 0x8080100c, 0xd8203d91, 0x00b10420, 0x000a000a },
+   { 0x00a02040, 0x24003dac, 0x00b18040, 0x02000200 },
+   { 0x00800048, 0x24003dac, 0x01ed8840, 0xfffbfffb },
+   { 0x00800048, 0x24203dac, 0x01ed8860, 0xfffbfffb },
+   { 0x00a02048, 0x24003dac, 0x00b18060, 0x00140014 },
+   { 0x00800048, 0x24003dac, 0x01ed8860, 0x00140014 },
+   { 0x00800048, 0x24203dac, 0x01ed8880, 0x00140014 },
+   { 0x00a02048, 0x24003dac, 0x00b18080, 0xfffbfffb },
+   { 0x00800048, 0x24003dac, 0x01ed8880, 0x00010001 },
+   { 0x00800048, 0x24203dac, 0x01ed88a0, 0x00010001 },
+   { 0x8080000c, 0xd8403d91, 0x00b10400, 0x000a000a },
+   { 0x8080100c, 0xd8603d91, 0x00b10420, 0x000a000a },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x000000b4 },
+   { 0x01000010, 0x20003db0, 0x00000444, 0x00000000 },
+   { 0x01000010, 0x20003db0, 0x02000446, 0x00020002 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x0000004c },
+   { 0x00010220, 0x34001c00, 0x02001400, 0x0000004a },
+   { 0x00400040, 0x22003d28, 0x0069044c, 0xfffefffe },
+   { 0x03400010, 0x20003dac, 0x00000446, 0x00020002 },
+   { 0x01000010, 0x20003db0, 0x02000444, 0x00020002 },
+   { 0x00410040, 0x22002d08, 0x00690200, 0x00100010 },
+   { 0x01000010, 0x20003dac, 0x00000446, 0x00000000 },
+   { 0x00010002, 0x220c2d28, 0x02000454, 0x04800480 },
+   { 0x00800040, 0x24003e2c, 0x01ed8000, 0x00100010 },
+   { 0x00800040, 0x24203e2c, 0x01ed8020, 0x00100010 },
+   { 0x00800048, 0x24003e2c, 0x01ed8001, 0xfffbfffb },
+   { 0x00800048, 0x24203e2c, 0x01ed8021, 0xfffbfffb },
+   { 0x00800048, 0x24003e2c, 0x01ed8002, 0x00140014 },
+   { 0x00800048, 0x24203e2c, 0x01ed8022, 0x00140014 },
+   { 0x00800048, 0x24003e2c, 0x01ed8003, 0x00140014 },
+   { 0x00800048, 0x24203e2c, 0x01ed8023, 0x00140014 },
+   { 0x00800048, 0x24003e2c, 0x01ed8004, 0xfffbfffb },
+   { 0x00800048, 0x24203e2c, 0x01ed8024, 0xfffbfffb },
+   { 0x00800048, 0x24003e2c, 0x01ed8005, 0x00010001 },
+   { 0x00800048, 0x24203e2c, 0x01ed8025, 0x00010001 },
+   { 0x8080000c, 0xd8003d91, 0x00b10400, 0x00050005 },
+   { 0x8080100c, 0xd8203d91, 0x00b10420, 0x00050005 },
+   { 0x00800040, 0x24003e2c, 0x01ed8040, 0x00100010 },
+   { 0x00800040, 0x24203e2c, 0x01ed8060, 0x00100010 },
+   { 0x00800048, 0x24003e2c, 0x01ed8041, 0xfffbfffb },
+   { 0x00800048, 0x24203e2c, 0x01ed8061, 0xfffbfffb },
+   { 0x00800048, 0x24003e2c, 0x01ed8042, 0x00140014 },
+   { 0x00800048, 0x24203e2c, 0x01ed8062, 0x00140014 },
+   { 0x00800048, 0x24003e2c, 0x01ed8043, 0x00140014 },
+   { 0x00800048, 0x24203e2c, 0x01ed8063, 0x00140014 },
+   { 0x00800048, 0x24003e2c, 0x01ed8044, 0xfffbfffb },
+   { 0x00800048, 0x24203e2c, 0x01ed8064, 0xfffbfffb },
+   { 0x00800048, 0x24003e2c, 0x01ed8045, 0x00010001 },
+   { 0x00800048, 0x24203e2c, 0x01ed8065, 0x00010001 },
+   { 0x8080000c, 0xd8403d91, 0x00b10400, 0x00050005 },
+   { 0x8080100c, 0xd8603d91, 0x00b10420, 0x00050005 },
+   { 0x00110220, 0x34001c00, 0x02001400, 0x00000004 },
+   { 0x00110220, 0x34001c00, 0x00001400, 0x0000005c },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x00000062 },
+   { 0x01000010, 0x20003db0, 0x00000446, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x00000042 },
+   { 0x00200401, 0x22000128, 0x0066044c, 0x00000000 },
+   { 0x00200c01, 0x22040128, 0x0045044e, 0x00000000 },
+   { 0x00000801, 0x220c0128, 0x00000454, 0x00000000 },
+   { 0x03400010, 0x20003dac, 0x02000444, 0x00020002 },
+   { 0x01000010, 0x20003dac, 0x00000444, 0x00000000 },
+   { 0x00410040, 0x22002d08, 0x02690200, 0x00010001 },
+   { 0x01000010, 0x20003db0, 0x02000446, 0x00020002 },
+   { 0x00110220, 0x34001c00, 0x00001400, 0x00000002 },
+   { 0x00110001, 0x220c0168, 0x02000000, 0x04800480 },
+   { 0x00a02040, 0x24003e2c, 0x00ad83e0, 0x00100010 },
+   { 0x00800048, 0x24003e2c, 0x01ed8be0, 0xfffbfffb },
+   { 0x00800048, 0x24203e2c, 0x01ed8800, 0xfffbfffb },
+   { 0x00a02048, 0x24003e2c, 0x00ad8000, 0x00140014 },
+   { 0x00800048, 0x24003e2c, 0x01ed8800, 0x00140014 },
+   { 0x00800048, 0x24203e2c, 0x01ed8820, 0x00140014 },
+   { 0x00a02048, 0x24003e2c, 0x00ad8020, 0xfffbfffb },
+   { 0x00800048, 0x24003e2c, 0x01ed8820, 0x00010001 },
+   { 0x00800048, 0x24203e2c, 0x01ed8840, 0x00010001 },
+   { 0x8080000c, 0xd8003d91, 0x00b10400, 0x00050005 },
+   { 0x8080100c, 0xd8203d91, 0x00b10420, 0x00050005 },
+   { 0x00a02040, 0x24003e2c, 0x00ad8020, 0x00100010 },
+   { 0x00800048, 0x24003e2c, 0x01ed8820, 0xfffbfffb },
+   { 0x00800048, 0x24203e2c, 0x01ed8840, 0xfffbfffb },
+   { 0x00a02048, 0x24003e2c, 0x00ad8040, 0x00140014 },
+   { 0x00800048, 0x24003e2c, 0x01ed8840, 0x00140014 },
+   { 0x00800048, 0x24203e2c, 0x01ed8860, 0x00140014 },
+   { 0x00a02048, 0x24003e2c, 0x00ad8060, 0xfffbfffb },
+   { 0x00800048, 0x24003e2c, 0x01ed8860, 0x00010001 },
+   { 0x00800048, 0x24203e2c, 0x01ed8880, 0x00010001 },
+   { 0x8080000c, 0xd8403d91, 0x00b10400, 0x00050005 },
+   { 0x8080100c, 0xd8603d91, 0x00b10420, 0x00050005 },
+   { 0x00110220, 0x34001c00, 0x00001400, 0x00000016 },
+   { 0x00010220, 0x34001c00, 0x02001400, 0x0000001c },
+   { 0x00200401, 0x22000128, 0x0045044c, 0x00000000 },
+   { 0x00000801, 0x220c0128, 0x00000454, 0x00000000 },
+   { 0x01200010, 0x20003dac, 0x00000444, 0x00030003 },
+   { 0x01200010, 0x20003dac, 0x02000446, 0x00030003 },
+   { 0x00210040, 0x22002d08, 0x00450200, 0x00010001 },
+   { 0x00210040, 0x22002d08, 0x02450200, 0x00100010 },
+   { 0x00800001, 0xb8000229, 0x01ed8000, 0x00000000 },
+   { 0x00800001, 0xb8200229, 0x01ed8020, 0x00000000 },
+   { 0x00800001, 0xb8400229, 0x01ed8040, 0x00000000 },
+   { 0x00800001, 0xb8600229, 0x01ed8060, 0x00000000 },
+   { 0x80800042, 0xd8004631, 0x00d29800, 0x00d20480 },
+   { 0x80800042, 0xd8204631, 0x00d29820, 0x00d204a0 },
+   { 0x80800042, 0xd8404631, 0x00d29840, 0x00d204c0 },
+   { 0x80800042, 0xd8604631, 0x00d29860, 0x00d204e0 },
+   { 0x00600001, 0x220001ac, 0x008d0024, 0x00000000 },
+   { 0x00200040, 0x244c3dad, 0x00450448, 0xfff8fff8 },
+   { 0x00000401, 0x220001ec, 0x00000000, 0x07000700 },
+   { 0x00000c01, 0x220201e8, 0x00000000, 0x07100710 },
+   { 0x00000801, 0x220e0128, 0x00000456, 0x00000000 },
+   { 0x00000441, 0x254635ad, 0x00000448, 0x0000044a },
+   { 0x00000c41, 0x254025ad, 0x0000444c, 0x0000444e },
+   { 0x00000c41, 0x254225ad, 0x00000448, 0x0000444e },
+   { 0x00000841, 0x254435ad, 0x0000444c, 0x0000044a },
+   { 0x00200040, 0x244c3d09, 0x00450200, 0x00100010 },
+   { 0x00800041, 0x24002628, 0x00ad8000, 0x00000540 },
+   { 0x00800041, 0x24202628, 0x00ad8020, 0x00000540 },
+   { 0x00800048, 0x24002628, 0x00ad8002, 0x00000542 },
+   { 0x00800048, 0x24202628, 0x00ad8022, 0x00000542 },
+   { 0x00200001, 0x22000128, 0x0045044c, 0x00000000 },
+   { 0x00800048, 0x24002628, 0x01ed8000, 0x00000544 },
+   { 0x00800048, 0x24202628, 0x01ed8020, 0x00000544 },
+   { 0x00800048, 0xbc002629, 0x01ed8002, 0x00000546 },
+   { 0x00801048, 0xbc202629, 0x01ed8022, 0x00000546 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x00000126 },
+   { 0x00000001, 0x20220169, 0x00000000, 0x00040004 },
+   { 0x00200005, 0x24443dad, 0x00459800, 0x00030003 },
+   { 0x0020000c, 0x24403dad, 0x00459800, 0x00020002 },
+   { 0x01600006, 0x20003dac, 0x02000446, 0x00000000 },
+   { 0x00010040, 0x22000c20, 0x02000078, 0x00200000 },
+   { 0x00110040, 0x22000c20, 0x02000078, 0x00500000 },
+   { 0x00310040, 0x20401da5, 0x02450440, 0xfffffffe },
+   { 0x00110001, 0x20480061, 0x02000000, 0x00080008 },
+   { 0x00010040, 0x20401da5, 0x02000440, 0xfffffffe },
+   { 0x00010001, 0x204401a5, 0x02000442, 0x00000000 },
+   { 0x00010001, 0x20480061, 0x02000000, 0x00030008 },
+   { 0x01600031, 0x25600021, 0x408d0040, 0x00000200 },
+   { 0x00000040, 0x22000c20, 0x00000078, 0x00100010 },
+   { 0x0020040c, 0x24403dad, 0x00459800, 0x00030003 },
+   { 0x00200805, 0x24483dad, 0x00459800, 0x00070007 },
+   { 0x00200001, 0x204001a5, 0x00450440, 0x00000000 },
+   { 0x00000009, 0x20403ca5, 0x00000040, 0x00010001 },
+   { 0x00000001, 0x20480061, 0x00000000, 0x00020005 },
+   { 0x02600031, 0x27000021, 0x408d0040, 0x00000200 },
+   { 0x00110001, 0x220001ec, 0x02000000, 0x05820582 },
+   { 0x00010001, 0x220001ec, 0x02000000, 0x05620562 },
+   { 0x00000001, 0x220e0128, 0x00000454, 0x00000000 },
+   { 0x01800006, 0x200035ac, 0x02000446, 0x00000444 },
+   { 0x00410001, 0xbc000229, 0x02698000, 0x00000000 },
+   { 0x00410001, 0xbc100229, 0x02698010, 0x00000000 },
+   { 0x00410001, 0xbc200229, 0x02698020, 0x00000000 },
+   { 0x00410001, 0xbc300229, 0x02698030, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x02001400, 0x000000be },
+   { 0x00600001, 0x2024018d, 0x008d0200, 0x00000000 },
+   { 0x01000041, 0x245e35ad, 0x00000446, 0x00000444 },
+   { 0x02000005, 0x20003db0, 0x0200045e, 0x00010001 },
+   { 0x00000040, 0x22022d08, 0x00000200, 0x00100010 },
+   { 0x00200040, 0x22042d08, 0x00450200, 0x00200020 },
+   { 0x00400001, 0x244c0109, 0x00690200, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x00000044 },
+   { 0x00010220, 0x34001c00, 0x02001400, 0x00000042 },
+   { 0x00000040, 0x22003d08, 0x00000200, 0xffdeffde },
+   { 0x00000440, 0x22023d08, 0x00000202, 0xffeeffee },
+   { 0x00000801, 0x220c0060, 0x00000000, 0x04d004c0 },
+   { 0x01000010, 0x20003db0, 0x0000045e, 0x00040004 },
+   { 0x00802040, 0x2400462c, 0x00a98000, 0x00a98005 },
+   { 0x00802048, 0x24003e2c, 0x00a98001, 0xfffbfffb },
+   { 0x00802048, 0x24003e2c, 0x00a98002, 0x00140014 },
+   { 0x00802048, 0x24003e2c, 0x00a98003, 0x00140014 },
+   { 0x00802048, 0xb8003e2d, 0x00a98004, 0xfffbfffb },
+   { 0x00802040, 0x2400462c, 0x00a98040, 0x00a98045 },
+   { 0x00802048, 0x24003e2c, 0x00a98041, 0xfffbfffb },
+   { 0x00802048, 0x24003e2c, 0x00a98042, 0x00140014 },
+   { 0x00802048, 0x24003e2c, 0x00a98043, 0x00140014 },
+   { 0x00802048, 0xb8203e2d, 0x00a98044, 0xfffbfffb },
+   { 0x00400040, 0x2400462c, 0x00698080, 0x00698085 },
+   { 0x00400048, 0x24003e2c, 0x00698081, 0xfffbfffb },
+   { 0x00400048, 0x24003e2c, 0x00698082, 0x00140014 },
+   { 0x00400048, 0x24003e2c, 0x00698083, 0x00140014 },
+   { 0x00400048, 0xb8403e2d, 0x00698084, 0xfffbfffb },
+   { 0x00000401, 0x220c0060, 0x00000000, 0x04e004d0 },
+   { 0x00000c01, 0x22000060, 0x00000000, 0x04d004c8 },
+   { 0x00000c01, 0x22040060, 0x00000000, 0x04e004d8 },
+   { 0x00000801, 0x22080060, 0x00000000, 0x04f004e8 },
+   { 0x00800040, 0x24003dac, 0x00b104c0, 0x02000200 },
+   { 0x00800048, 0x24003dac, 0x00b104e0, 0xfffbfffb },
+   { 0x00800048, 0x24003dac, 0x01ed9800, 0x00140014 },
+   { 0x00010001, 0x220c0168, 0x00000000, 0x05400540 },
+   { 0x00110001, 0x220c0168, 0x00000000, 0x04c004c0 },
+   { 0x00800048, 0x24003dac, 0x01e98000, 0xfffbfffb },
+   { 0x00800048, 0x24003dac, 0x01e98020, 0x00010001 },
+   { 0x00800048, 0x24003dac, 0x01e98800, 0x00140014 },
+   { 0x8080000c, 0xd8003d91, 0x00b10400, 0x000a000a },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x00000060 },
+   { 0x01000010, 0x20003db0, 0x00000444, 0x00000000 },
+   { 0x01000010, 0x20003db0, 0x02000446, 0x00020002 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x00000024 },
+   { 0x00010220, 0x34001c00, 0x02001400, 0x00000022 },
+   { 0x00400040, 0x22003d28, 0x0069044c, 0xfffefffe },
+   { 0x03400010, 0x20003dac, 0x00000446, 0x00020002 },
+   { 0x01000010, 0x20003db0, 0x02000444, 0x00020002 },
+   { 0x00410040, 0x22002d08, 0x00690200, 0x00100010 },
+   { 0x01000010, 0x20003dac, 0x00000446, 0x00000000 },
+   { 0x00010001, 0x220e0168, 0x02000000, 0x05400540 },
+   { 0x00110001, 0x220e0168, 0x02000000, 0x04c004c0 },
+   { 0x00800040, 0x24003e2c, 0x01e98000, 0x00100010 },
+   { 0x00800048, 0x24003e2c, 0x01e98001, 0xfffbfffb },
+   { 0x00800048, 0x24003e2c, 0x01e98002, 0x00140014 },
+   { 0x00800048, 0x24003e2c, 0x01e98003, 0x00140014 },
+   { 0x00800048, 0x24003e2c, 0x01e98004, 0xfffbfffb },
+   { 0x00800048, 0x24003e2c, 0x01e98005, 0x00010001 },
+   { 0x8080000c, 0xdc003d91, 0x00b10400, 0x00050005 },
+   { 0x00110220, 0x34001c00, 0x02001400, 0x00000004 },
+   { 0x00110220, 0x34001c00, 0x00001400, 0x00000036 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x00000036 },
+   { 0x01000010, 0x20003db0, 0x00000446, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x00000024 },
+   { 0x03600010, 0x20003dac, 0x02000444, 0x00020002 },
+   { 0x00400401, 0x22000128, 0x0069044c, 0x00000000 },
+   { 0x00400840, 0x22083d2c, 0x0069044c, 0x00100010 },
+   { 0x00610040, 0x22002d08, 0x02690200, 0x00010001 },
+   { 0x01000010, 0x20003dac, 0x00000444, 0x00000000 },
+   { 0x01000010, 0x20003db0, 0x02000446, 0x00020002 },
+   { 0x00800040, 0x24003e2c, 0x01e983e0, 0x00100010 },
+   { 0x00800048, 0x24003e2c, 0x01e98000, 0x00140014 },
+   { 0x00800048, 0x24003e2c, 0x01e98020, 0xfffbfffb },
+   { 0x00800048, 0x24003e2c, 0x01e993e0, 0xfffbfffb },
+   { 0x00800048, 0x24003e2c, 0x01e99000, 0x00140014 },
+   { 0x00800048, 0x24003e2c, 0x01e99020, 0x00010001 },
+   { 0x00000001, 0x220e0168, 0x00000000, 0x05400540 },
+   { 0x00110220, 0x34001c00, 0x00001400, 0x00000002 },
+   { 0x00110001, 0x220e0168, 0x02000000, 0x04c004c0 },
+   { 0x8080000c, 0xdc003d91, 0x00b10400, 0x00050005 },
+   { 0x00110220, 0x34001c00, 0x00001400, 0x0000000e },
+   { 0x00010220, 0x34001c00, 0x02001400, 0x0000000e },
+   { 0x00400001, 0x22000128, 0x0069044c, 0x00000000 },
+   { 0x01400010, 0x20003dac, 0x00000444, 0x00030003 },
+   { 0x01400010, 0x20003dac, 0x02000446, 0x00030003 },
+   { 0x00410040, 0x22002d08, 0x00690200, 0x00010001 },
+   { 0x00410040, 0x22002d08, 0x02690200, 0x00100010 },
+   { 0x00800001, 0x25400229, 0x01e98000, 0x00000000 },
+   { 0x80800042, 0x45404631, 0x00d20540, 0x00d204c0 },
+   { 0x00000001, 0x220c0128, 0x00000454, 0x00000000 },
+   { 0x00400001, 0xd8000231, 0x008a0540, 0x00000000 },
+   { 0x00400001, 0xd8100231, 0x008a0548, 0x00000000 },
+   { 0x00400001, 0xd8200231, 0x008a0550, 0x00000000 },
+   { 0x00400001, 0xd8300231, 0x008a0558, 0x00000000 },
+   { 0x00600001, 0x220001ac, 0x008d0024, 0x00000000 },
+   { 0x00200040, 0x244c3dad, 0x00450448, 0xfff8fff8 },
+   { 0x00000401, 0x220001ec, 0x00000000, 0x07000700 },
+   { 0x00000801, 0x220e0128, 0x00000456, 0x00000000 },
+   { 0x00000441, 0x254635ad, 0x00000448, 0x0000044a },
+   { 0x00000c41, 0x254025ad, 0x0000444c, 0x0000444e },
+   { 0x00000c41, 0x254225ad, 0x00000448, 0x0000444e },
+   { 0x00000841, 0x254435ad, 0x0000444c, 0x0000044a },
+   { 0x00600041, 0x24002628, 0x00898000, 0x00000540 },
+   { 0x00600048, 0x24002628, 0x00898002, 0x00000542 },
+   { 0x00600048, 0x24002628, 0x00898008, 0x00000544 },
+   { 0x00600048, 0x2540262d, 0x0089800a, 0x00000546 },
+   { 0x00400401, 0xbc0001a9, 0x00690540, 0x00000000 },
+   { 0x00400801, 0xbc1001a9, 0x00690548, 0x00000000 },
+   { 0x01000010, 0x20003d2c, 0x00000022, 0x00030003 },
+   { 0x01000040, 0x20223d29, 0x02000022, 0xffffffff },
+   { 0x00000040, 0x220c3d8c, 0x0000020c, 0x00080008 },
+   { 0x00110040, 0x24540c21, 0x00000454, 0x00080008 },
+   { 0x00010040, 0x24540c21, 0x00000454, 0x00180038 },
+   { 0x00110220, 0x34001c00, 0x02001400, 0xfffffee6 },
+   { 0x01800010, 0x20003dac, 0x0200010e, 0x00010001 },
+   { 0x00000040, 0x220c3d8c, 0x0000020c, 0xffe0ffe0 },
+   { 0x00010001, 0x24540061, 0x02000000, 0x06c00640 },
+   { 0x00110001, 0x24540061, 0x02000000, 0x04800780 },
+   { 0x00000001, 0x220e0128, 0x00000456, 0x00000000 },
+   { 0x00800040, 0x24003dac, 0x00b19c00, 0x00200020 },
+   { 0x00800040, 0x24203dac, 0x00b19c20, 0x00200020 },
+   { 0x8080000c, 0xdc003d91, 0x00b10400, 0x00060006 },
+   { 0x8080000c, 0xdc203d91, 0x00b10420, 0x00060006 },
+   { 0x02000040, 0x210e3d29, 0x0200010e, 0xffffffff },
+   { 0x00000040, 0x220c3d8c, 0x0000020c, 0x00040004 },
+   { 0x00110220, 0x34001c00, 0x02001400, 0xfffffcf8 },
+   { 0x01000005, 0x25643e2d, 0x00000060, 0x00c000c0 },
+   { 0x01000010, 0x20003dac, 0x02000458, 0x00020002 },
+   { 0x00110220, 0x34001c00, 0x00001400, 0x00000016 },
+   { 0x00010220, 0x34001c00, 0x02001400, 0x0000000c },
+   { 0x01000010, 0x20003dac, 0x00000458, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x00000086 },
+   { 0x00a02001, 0x46400231, 0x00d20780, 0x00000000 },
+   { 0x00a02001, 0x46800231, 0x00d207c0, 0x00000000 },
+   { 0x00a02001, 0x46c00231, 0x00d20480, 0x00000000 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x0000007e },
+   { 0x80a02042, 0x46404631, 0x00d20640, 0x00d20780 },
+   { 0x80a02042, 0x46804631, 0x00d20680, 0x00d207c0 },
+   { 0x80a02042, 0x46c04631, 0x00d206c0, 0x00d20480 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x00000076 },
+   { 0x01000010, 0x20003dac, 0x02000564, 0x00800080 },
+   { 0x00110220, 0x34001c00, 0x02001400, 0x0000000e },
+   { 0x01000010, 0x20003dac, 0x00000458, 0x00020002 },
+   { 0x00110220, 0x34001c00, 0x00001400, 0xffffffe4 },
+   { 0x00200401, 0x256801ed, 0x00000000, 0x00200020 },
+   { 0x00200801, 0x256c01ed, 0x00000000, 0x00060006 },
+   { 0x00400001, 0x258001ed, 0x00000000, 0x00000000 },
+   { 0x00600001, 0x45a001ad, 0x00058c00, 0x00000000 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x00000028 },
+   { 0x02600005, 0x20006e28, 0x02008c0c, 0x88848421 },
+   { 0x0220000c, 0x25663dad, 0x00000458, 0x00010001 },
+   { 0x0000000c, 0x25643dad, 0x00000564, 0x00060006 },
+   { 0x00310001, 0x25c401ad, 0x00000458, 0x00000000 },
+   { 0x00210001, 0x25c00061, 0x00000000, 0x00010001 },
+   { 0x00310040, 0x25c03dad, 0x004545c4, 0x00010001 },
+   { 0x00610001, 0x25a00061, 0x02000000, 0x00000080 },
+   { 0x00710001, 0x45a002ad, 0x02ae8c00, 0x00000000 },
+   { 0x00710001, 0x45a202ad, 0x02ae8c01, 0x00000000 },
+   { 0x00800041, 0x25a035ad, 0x00b105a0, 0x000905c0 },
+   { 0x01200010, 0x20003e2c, 0x0245006e, 0x00000000 },
+   { 0x00310009, 0x244c45ad, 0x02000564, 0x0045006e },
+   { 0x00210001, 0x244c01ed, 0x02000000, 0x00000000 },
+   { 0x0031000c, 0x244c3dad, 0x0245044c, 0x00010001 },
+   { 0x00200009, 0x256835ad, 0x0045044c, 0x00000566 },
+   { 0x00210040, 0x256835ad, 0x02450568, 0x00000566 },
+   { 0x00200040, 0x256c362d, 0x0045006e, 0x00000566 },
+   { 0x00400040, 0x240035ac, 0x00ab05a2, 0x00ab05a6 },
+   { 0x00400040, 0x2400358c, 0x00690400, 0x00000566 },
+   { 0x0040000c, 0x2580358d, 0x00690400, 0x00000566 },
+   { 0x00800041, 0x2400362c, 0x00d20640, 0x000005a0 },
+   { 0x00800041, 0x2420362c, 0x00d20660, 0x000005a0 },
+   { 0x00800048, 0x2400362c, 0x00d20780, 0x000005a4 },
+   { 0x00800048, 0x2420362c, 0x00d207a0, 0x000005a4 },
+   { 0x00800040, 0x2400358c, 0x00b10400, 0x00000568 },
+   { 0x00800040, 0x2420358c, 0x00b10420, 0x00000568 },
+   { 0x0080000c, 0x24c0358d, 0x00b10400, 0x0000056c },
+   { 0x0080000c, 0x24e0358d, 0x00b10420, 0x0000056c },
+   { 0x80800040, 0x464035b1, 0x00b104c0, 0x00000580 },
+   { 0x80800040, 0x466035b1, 0x00b104e0, 0x00000580 },
+   { 0x00800041, 0x2400362c, 0x00d20680, 0x000005a0 },
+   { 0x00800041, 0x2420362c, 0x00d206a0, 0x000005a0 },
+   { 0x00800048, 0x2400362c, 0x00d207c0, 0x000005a4 },
+   { 0x00800048, 0x2420362c, 0x00d207e0, 0x000005a4 },
+   { 0x00800040, 0x2400358c, 0x00b10400, 0x00000568 },
+   { 0x00800040, 0x2420358c, 0x00b10420, 0x00000568 },
+   { 0x0080000c, 0x24c0358d, 0x00b10400, 0x0000056c },
+   { 0x0080000c, 0x24e0358d, 0x00b10420, 0x0000056c },
+   { 0x80800040, 0x468035b1, 0x00b104c0, 0x00000580 },
+   { 0x80800040, 0x46a035b1, 0x00b104e0, 0x00000580 },
+   { 0x00800041, 0x2400362c, 0x00d206c0, 0x000705a8 },
+   { 0x00800041, 0x2420362c, 0x00d206e0, 0x000705a8 },
+   { 0x00800048, 0x2400362c, 0x00d20480, 0x000705ac },
+   { 0x00800048, 0x2420362c, 0x00d204a0, 0x000705ac },
+   { 0x00800040, 0x2400358c, 0x00b10400, 0x0000056a },
+   { 0x00800040, 0x2420358c, 0x00b10420, 0x0000056a },
+   { 0x0080000c, 0x24c0358d, 0x00b10400, 0x0000056e },
+   { 0x0080000c, 0x24e0358d, 0x00b10420, 0x0000056e },
+   { 0x80800040, 0x46c035b1, 0x00b104c0, 0x00050582 },
+   { 0x80800040, 0x46e035b1, 0x00b104e0, 0x00050582 },
+   { 0x01800005, 0x20003d2c, 0x02000020, 0x00020002 },
+   { 0x80800040, 0xd00045b1, 0x00b19000, 0x00d20640 },
+   { 0x80800040, 0xd02045b1, 0x00b19020, 0x00d20660 },
+   { 0x80800040, 0xd04045b1, 0x00b19040, 0x00d20680 },
+   { 0x80800040, 0xd06045b1, 0x00b19060, 0x00d206a0 },
+   { 0x00000040, 0x22083d8c, 0x00000208, 0x00800080 },
+   { 0x80400040, 0xd40045b1, 0x00699400, 0x00ab06c0 },
+   { 0x80400040, 0xd48045b1, 0x00699480, 0x00ab06c2 },
+   { 0x80400040, 0xd42045b1, 0x00699420, 0x00ab06e0 },
+   { 0x80400040, 0xd4a045b1, 0x006994a0, 0x00ab06e2 },
+   { 0x80400040, 0xd41045b1, 0x00699410, 0x00ab06d0 },
+   { 0x80400040, 0xd49045b1, 0x00699490, 0x00ab06d2 },
+   { 0x80400040, 0xd43045b1, 0x00699430, 0x00ab06f0 },
+   { 0x80400040, 0xd4b045b1, 0x006994b0, 0x00ab06f2 },
+   { 0x00000040, 0x220a3d8c, 0x0000020a, 0x00080008 },
+   { 0x00110040, 0x220a3d8c, 0x0200020a, 0x00300030 },
+   { 0x01000010, 0x20003d2c, 0x02000020, 0x00060006 },
+   { 0x00000040, 0x20203d29, 0x00000020, 0x00020002 },
+   { 0x00000040, 0x22040c00, 0x00000204, 0x00100001 },
+   { 0x00000040, 0x220c358c, 0x0000020c, 0x0000003a },
+   { 0x00110220, 0x34001c00, 0x02001400, 0xfffffc36 },
+   { 0x00000001, 0x220001ec, 0x00000000, 0x01400140 },
+   { 0x00000001, 0x220201ec, 0x00000000, 0x01c001c0 },
+   { 0x00800401, 0x20400236, 0x01ee8000, 0x00000000 },
+   { 0x00800801, 0x20500236, 0x01ee8010, 0x00000000 },
+   { 0x00800401, 0x20600236, 0x01ee8020, 0x00000000 },
+   { 0x00800801, 0x20700236, 0x01ee8030, 0x00000000 },
+   { 0x00800401, 0x20800236, 0x01ee8040, 0x00000000 },
+   { 0x00800801, 0x20900236, 0x01ee8050, 0x00000000 },
+   { 0x00800401, 0x20a00236, 0x01ee8060, 0x00000000 },
+   { 0x00800801, 0x20b00236, 0x01ee8070, 0x00000000 },
+   { 0x00800401, 0x20c00236, 0x01ee8100, 0x00000000 },
+   { 0x00800801, 0x20d00236, 0x01ee8110, 0x00000000 },
+   { 0x00800401, 0x20e00236, 0x01ee8120, 0x00000000 },
+   { 0x00800801, 0x20f00236, 0x01ee8130, 0x00000000 },
+   { 0x00800401, 0x21000236, 0x01ee8140, 0x00000000 },
+   { 0x00800801, 0x21100236, 0x01ee8150, 0x00000000 },
+   { 0x00800401, 0x21200236, 0x01ee8160, 0x00000000 },
+   { 0x00800801, 0x21300236, 0x01ee8170, 0x00000000 },
+   { 0x00200401, 0x204001a5, 0x00450064, 0x00000000 },
+   { 0x00000801, 0x20480061, 0x00000000, 0x000f000f },
+   { 0x01600031, 0x21401c21, 0x508d0040, 0x1218a000 },
+   { 0x00000001, 0x220001ec, 0x00000000, 0x03400340 },
+   { 0x00800401, 0x41600236, 0x00d28000, 0x00000000 },
+   { 0x00800801, 0x41610236, 0x00d28080, 0x00000000 },
+   { 0x00800401, 0x41800236, 0x00d28020, 0x00000000 },
+   { 0x00800801, 0x41810236, 0x00d280a0, 0x00000000 },
+   { 0x00800401, 0x41a00236, 0x00d28040, 0x00000000 },
+   { 0x00800801, 0x41a10236, 0x00d280c0, 0x00000000 },
+   { 0x00800401, 0x41c00236, 0x00d28060, 0x00000000 },
+   { 0x00800801, 0x41c10236, 0x00d280e0, 0x00000000 },
+   { 0x0000040c, 0x20443ca5, 0x00000044, 0x00010001 },
+   { 0x00000801, 0x20480061, 0x00000000, 0x0007000f },
+   { 0x0a600031, 0x21601c21, 0x508d0040, 0x0a18a001 },
+   { 0x00000001, 0x21400021, 0x00000140, 0x00000000 },
+   { 0x00000001, 0x21600021, 0x00000160, 0x00000000 },
+   { 0x01600031, 0x20001c20, 0x708d0000, 0x82000010 },
+   { 0x00600001, 0x20400021, 0x008d0000, 0x00000000 },
+   { 0x00000005, 0x20203e2d, 0x00000061, 0x001f001f },
+   { 0x00200009, 0x20643e2d, 0x00450064, 0x00040004 },
+   { 0x00000001, 0x203a01ed, 0x00000000, 0x00000000 },
+   { 0x01000010, 0x20003dac, 0x00000020, 0x00160016 },
+   { 0x00110220, 0x34001c00, 0x00001400, 0x0000001e },
+   { 0x01200010, 0x20003e2c, 0x0200006c, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x02001400, 0x00000024 },
+   { 0x00800009, 0x25403dad, 0x00050064, 0x00020002 },
+   { 0x00000001, 0x203a01ed, 0x00000000, 0x00180018 },
+   { 0x00200040, 0x45483dad, 0x00660548, 0x00100010 },
+   { 0x00200040, 0x45523dad, 0x00660552, 0x00100010 },
+   { 0x00400040, 0x25583dad, 0x00690558, 0x00100010 },
+   { 0x00800040, 0x208035ad, 0x00b10080, 0x00b10540 },
+   { 0x00600040, 0x45403dad, 0x00ae0540, 0x00200020 },
+   { 0x00800040, 0x20a035ad, 0x00b100a0, 0x00b10540 },
+   { 0x00600040, 0x45423dad, 0x00ae0542, 0x00200020 },
+   { 0x00800040, 0x20e035ad, 0x00b100e0, 0x00b10540 },
+   { 0x00600040, 0x45403dad, 0x00ae0540, 0xffe0ffe0 },
+   { 0x00800040, 0x20c035ad, 0x00b100c0, 0x00b10540 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x00000014 },
+   { 0x06600010, 0x20003dac, 0x02000020, 0x00030003 },
+   { 0x00000001, 0x206c0171, 0x00000000, 0x00000000 },
+   { 0x00610001, 0x208000a5, 0x02050080, 0x00000000 },
+   { 0x00610001, 0x212000a5, 0x02090100, 0x00000000 },
+   { 0x00410001, 0x211000a5, 0x02690100, 0x00000000 },
+   { 0x00200009, 0x25403dad, 0x00450064, 0x00020002 },
+   { 0x00800040, 0x208035ad, 0x00b10080, 0x00050540 },
+   { 0x00200040, 0x40883dad, 0x00660088, 0x00200020 },
+   { 0x00200040, 0x40923dad, 0x00660092, 0x00200020 },
+   { 0x00400040, 0x20983dad, 0x00690098, 0x00200020 },
+   { 0x00200401, 0x22080060, 0x00000000, 0x03400140 },
+   { 0x00000c01, 0x220c0060, 0x00000000, 0x04400080 },
+   { 0x00000801, 0x22040060, 0x00000000, 0x01000070 },
+   { 0x00000005, 0x203e2e29, 0x00000063, 0x00010001 },
+   { 0x00000001, 0x20200169, 0x00000000, 0x00000000 },
+   { 0x0000000c, 0x2458262d, 0x0000006d, 0x00000020 },
+   { 0x00000001, 0x210e0169, 0x00000000, 0x00010001 },
+   { 0x00000005, 0x24583dad, 0x00000458, 0x00030003 },
+   { 0x01000010, 0x200035ac, 0x0000010e, 0x00000458 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x00000316 },
+   { 0x01000010, 0x20003dac, 0x0200010e, 0x00010001 },
+   { 0x00010401, 0x24540061, 0x02000000, 0x06c00640 },
+   { 0x00010805, 0x245a3e2d, 0x02008800, 0x007f007f },
+   { 0x00110401, 0x24540061, 0x02000000, 0x04800780 },
+   { 0x00110805, 0x245a3e2d, 0x02008804, 0x007f007f },
+   { 0x00010005, 0x245c3e2d, 0x02008800, 0x00800080 },
+   { 0x00110005, 0x245c3e2d, 0x02008804, 0x00800080 },
+   { 0x00000009, 0x245c3dad, 0x0000045c, 0x00010001 },
+   { 0x0000000c, 0x211e362d, 0x0000006c, 0x00000020 },
+   { 0x00000040, 0x240035ac, 0x0000003e, 0x0000045c },
+   { 0x01000010, 0x20003d8c, 0x00210400, 0x00010001 },
+   { 0x01000010, 0x20003d8c, 0x02210400, 0x01000100 },
+   { 0x00000001, 0x203c01ed, 0x00000000, 0x00000000 },
+   { 0x00010001, 0x203c01ed, 0x00000000, 0x00020002 },
+   { 0x00010001, 0x203c01ed, 0x02000000, 0xfffefffe },
+   { 0x00000040, 0x20780d21, 0x0000045a, 0x0208e602 },
+   { 0x00000040, 0x20782421, 0x00000078, 0x0000045c },
+   { 0x02000005, 0x20003dac, 0x0200011e, 0x00030003 },
+   { 0x00010220, 0x34001c00, 0x02001400, 0x000001c0 },
+   { 0x01000005, 0x20003dac, 0x00009800, 0x00030003 },
+   { 0x00200005, 0x24443dad, 0x00459800, 0x00030003 },
+   { 0x0020000c, 0x24403dad, 0x00459800, 0x00020002 },
+   { 0x01600006, 0x20003dac, 0x02000446, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x00000012 },
+   { 0x00010040, 0x22000c20, 0x02000078, 0x00400000 },
+   { 0x00110040, 0x22000c20, 0x02000078, 0x00700000 },
+   { 0x00310040, 0x20401da5, 0x02450440, 0xfffffffe },
+   { 0x00110001, 0x20480061, 0x02000000, 0x000c000c },
+   { 0x00010040, 0x20401da5, 0x02000440, 0xfffffffe },
+   { 0x00010001, 0x204401a5, 0x02000442, 0x00000000 },
+   { 0x00010001, 0x20480061, 0x02000000, 0x0007000c },
+   { 0x01600031, 0x25600021, 0x408d0040, 0x00000200 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x0000000e },
+   { 0x00010040, 0x22000c20, 0x02000078, 0x00200000 },
+   { 0x00110040, 0x22000c20, 0x02000078, 0x00400000 },
+   { 0x00200001, 0x204001a5, 0x00450440, 0x00000000 },
+   { 0x00110040, 0x20441da5, 0x02000442, 0xfffffffe },
+   { 0x00110001, 0x20480061, 0x02000000, 0x000c0007 },
+   { 0x00010001, 0x20480061, 0x02000000, 0x00070007 },
+   { 0x01600031, 0x25600021, 0x408d0040, 0x00000200 },
+   { 0x00000040, 0xb80235ad, 0x00009802, 0x0000003c },
+   { 0x0020040c, 0x24403dad, 0x00459800, 0x00030003 },
+   { 0x00200805, 0x24483dad, 0x00459800, 0x00070007 },
+   { 0x01600006, 0x20003dac, 0x0000044a, 0x00000000 },
+   { 0x00200001, 0x204001a5, 0x00450440, 0x00000000 },
+   { 0x00000009, 0x20403ca5, 0x00000040, 0x00010001 },
+   { 0x00010040, 0x22000c20, 0x00000078, 0x00200010 },
+   { 0x00110040, 0x22000c20, 0x00000078, 0x00300010 },
+   { 0x00010001, 0x20480061, 0x00000000, 0x00030009 },
+   { 0x00110001, 0x20480061, 0x00000000, 0x00040009 },
+   { 0x02600031, 0x27000021, 0x408d0040, 0x00000200 },
+   { 0x01000005, 0x20003dac, 0x00009800, 0x00030003 },
+   { 0x00110220, 0x34001c00, 0x00001400, 0x0000001a },
+   { 0x00600001, 0x26220231, 0x008d05c0, 0x00000000 },
+   { 0x00600401, 0x26120231, 0x008d05b8, 0x00000000 },
+   { 0x00600801, 0x26020231, 0x008d05b0, 0x00000000 },
+   { 0x00600401, 0x25f20231, 0x008d05a8, 0x00000000 },
+   { 0x00600801, 0x25e20231, 0x008d05a0, 0x00000000 },
+   { 0x00600401, 0x25d20231, 0x008d0598, 0x00000000 },
+   { 0x00600801, 0x25c20231, 0x008d0590, 0x00000000 },
+   { 0x00600401, 0x25b20231, 0x008d0588, 0x00000000 },
+   { 0x00600801, 0x25a20231, 0x008d0580, 0x00000000 },
+   { 0x00600401, 0x25920231, 0x008d0578, 0x00000000 },
+   { 0x00600801, 0x25820231, 0x008d0570, 0x00000000 },
+   { 0x00600001, 0x25720231, 0x008d0568, 0x00000000 },
+   { 0x00600001, 0x25620231, 0x008d0560, 0x00000000 },
+   { 0x00110001, 0x220001ec, 0x02000000, 0x05820582 },
+   { 0x00010001, 0x220001ec, 0x02000000, 0x05620562 },
+   { 0x00000001, 0x220e0128, 0x00000454, 0x00000000 },
+   { 0x01800006, 0x200035ac, 0x02000446, 0x00000444 },
+   { 0x00810001, 0xbc000229, 0x02ad8000, 0x00000000 },
+   { 0x00810001, 0xbc200229, 0x02ad8020, 0x00000000 },
+   { 0x00810001, 0xbc400229, 0x02ad8040, 0x00000000 },
+   { 0x00810001, 0xbc600229, 0x02ad8060, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x02001400, 0x0000012a },
+   { 0x00600001, 0x2024018d, 0x008d0200, 0x00000000 },
+   { 0x01000041, 0x245e35ad, 0x00000446, 0x00000444 },
+   { 0x00000040, 0x22022d08, 0x00000200, 0x00100010 },
+   { 0x02000005, 0x20003db0, 0x0200045e, 0x00010001 },
+   { 0x00200040, 0x22042d08, 0x00450200, 0x00200020 },
+   { 0x00400001, 0x244c0109, 0x00690200, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x00000066 },
+   { 0x00010220, 0x34001c00, 0x02001400, 0x00000064 },
+   { 0x00000040, 0x22003d08, 0x00000200, 0xffdeffde },
+   { 0x00000440, 0x22023d08, 0x00000202, 0xffeeffee },
+   { 0x00000801, 0x220c0060, 0x00000000, 0x04a00480 },
+   { 0x01000010, 0x20003db0, 0x0000045e, 0x00040004 },
+   { 0x00a02040, 0x2400462c, 0x00ad8000, 0x00ad8005 },
+   { 0x00a02048, 0x24003e2c, 0x00ad8001, 0xfffbfffb },
+   { 0x00a02048, 0x24003e2c, 0x00ad8002, 0x00140014 },
+   { 0x00a02048, 0x24003e2c, 0x00ad8003, 0x00140014 },
+   { 0x00a02048, 0xb8003e2d, 0x00ad8004, 0xfffbfffb },
+   { 0x00a02040, 0x2400462c, 0x00ad8040, 0x00ad8045 },
+   { 0x00a02048, 0x24003e2c, 0x00ad8041, 0xfffbfffb },
+   { 0x00a02048, 0x24003e2c, 0x00ad8042, 0x00140014 },
+   { 0x00a02048, 0x24003e2c, 0x00ad8043, 0x00140014 },
+   { 0x00a02048, 0xb8403e2d, 0x00ad8044, 0xfffbfffb },
+   { 0x00a02040, 0x2400462c, 0x00ad8080, 0x00ad8085 },
+   { 0x00a02048, 0x24003e2c, 0x00ad8081, 0xfffbfffb },
+   { 0x00a02048, 0x24003e2c, 0x00ad8082, 0x00140014 },
+   { 0x00a02048, 0x24003e2c, 0x00ad8083, 0x00140014 },
+   { 0x00a02048, 0xb8803e2d, 0x00ad8084, 0xfffbfffb },
+   { 0x00600040, 0x2400462c, 0x008d80c0, 0x008d80c5 },
+   { 0x00600048, 0x24003e2c, 0x008d80c1, 0xfffbfffb },
+   { 0x00600048, 0x24003e2c, 0x008d80c2, 0x00140014 },
+   { 0x00600048, 0x24003e2c, 0x008d80c3, 0x00140014 },
+   { 0x00600048, 0xb8c03e2d, 0x008d80c4, 0xfffbfffb },
+   { 0x00000401, 0x22000060, 0x00000000, 0x04a00480 },
+   { 0x00000c01, 0x22040060, 0x00000000, 0x04a00490 },
+   { 0x00010802, 0x220c2d28, 0x00000454, 0x04800480 },
+   { 0x00a02040, 0x24003dac, 0x00b18000, 0x02000200 },
+   { 0x00800048, 0x24003dac, 0x01ed8800, 0xfffbfffb },
+   { 0x00800048, 0x24203dac, 0x01ed8820, 0xfffbfffb },
+   { 0x00a02048, 0x24003dac, 0x00b18020, 0x00140014 },
+   { 0x00800048, 0x24003dac, 0x01ed8820, 0x00140014 },
+   { 0x00800048, 0x24203dac, 0x01ed8840, 0x00140014 },
+   { 0x00a02048, 0x24003dac, 0x00b18040, 0xfffbfffb },
+   { 0x00800048, 0x24003dac, 0x01ed8840, 0x00010001 },
+   { 0x00800048, 0x24203dac, 0x01ed8860, 0x00010001 },
+   { 0x8080000c, 0xd8003d91, 0x00b10400, 0x000a000a },
+   { 0x8080100c, 0xd8203d91, 0x00b10420, 0x000a000a },
+   { 0x00a02040, 0x24003dac, 0x00b18040, 0x02000200 },
+   { 0x00800048, 0x24003dac, 0x01ed8840, 0xfffbfffb },
+   { 0x00800048, 0x24203dac, 0x01ed8860, 0xfffbfffb },
+   { 0x00a02048, 0x24003dac, 0x00b18060, 0x00140014 },
+   { 0x00800048, 0x24003dac, 0x01ed8860, 0x00140014 },
+   { 0x00800048, 0x24203dac, 0x01ed8880, 0x00140014 },
+   { 0x00a02048, 0x24003dac, 0x00b18080, 0xfffbfffb },
+   { 0x00800048, 0x24003dac, 0x01ed8880, 0x00010001 },
+   { 0x00800048, 0x24203dac, 0x01ed88a0, 0x00010001 },
+   { 0x8080000c, 0xd8403d91, 0x00b10400, 0x000a000a },
+   { 0x8080100c, 0xd8603d91, 0x00b10420, 0x000a000a },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x000000b4 },
+   { 0x01000010, 0x20003db0, 0x00000444, 0x00000000 },
+   { 0x01000010, 0x20003db0, 0x02000446, 0x00020002 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x0000004c },
+   { 0x00010220, 0x34001c00, 0x02001400, 0x0000004a },
+   { 0x00400040, 0x22003d28, 0x0069044c, 0xfffefffe },
+   { 0x03400010, 0x20003dac, 0x00000446, 0x00020002 },
+   { 0x01000010, 0x20003db0, 0x02000444, 0x00020002 },
+   { 0x00410040, 0x22002d08, 0x00690200, 0x00100010 },
+   { 0x01000010, 0x20003dac, 0x00000446, 0x00000000 },
+   { 0x00010002, 0x220c2d28, 0x02000454, 0x04800480 },
+   { 0x00800040, 0x24003e2c, 0x01ed8000, 0x00100010 },
+   { 0x00800040, 0x24203e2c, 0x01ed8020, 0x00100010 },
+   { 0x00800048, 0x24003e2c, 0x01ed8001, 0xfffbfffb },
+   { 0x00800048, 0x24203e2c, 0x01ed8021, 0xfffbfffb },
+   { 0x00800048, 0x24003e2c, 0x01ed8002, 0x00140014 },
+   { 0x00800048, 0x24203e2c, 0x01ed8022, 0x00140014 },
+   { 0x00800048, 0x24003e2c, 0x01ed8003, 0x00140014 },
+   { 0x00800048, 0x24203e2c, 0x01ed8023, 0x00140014 },
+   { 0x00800048, 0x24003e2c, 0x01ed8004, 0xfffbfffb },
+   { 0x00800048, 0x24203e2c, 0x01ed8024, 0xfffbfffb },
+   { 0x00800048, 0x24003e2c, 0x01ed8005, 0x00010001 },
+   { 0x00800048, 0x24203e2c, 0x01ed8025, 0x00010001 },
+   { 0x8080000c, 0xd8003d91, 0x00b10400, 0x00050005 },
+   { 0x8080100c, 0xd8203d91, 0x00b10420, 0x00050005 },
+   { 0x00800040, 0x24003e2c, 0x01ed8040, 0x00100010 },
+   { 0x00800040, 0x24203e2c, 0x01ed8060, 0x00100010 },
+   { 0x00800048, 0x24003e2c, 0x01ed8041, 0xfffbfffb },
+   { 0x00800048, 0x24203e2c, 0x01ed8061, 0xfffbfffb },
+   { 0x00800048, 0x24003e2c, 0x01ed8042, 0x00140014 },
+   { 0x00800048, 0x24203e2c, 0x01ed8062, 0x00140014 },
+   { 0x00800048, 0x24003e2c, 0x01ed8043, 0x00140014 },
+   { 0x00800048, 0x24203e2c, 0x01ed8063, 0x00140014 },
+   { 0x00800048, 0x24003e2c, 0x01ed8044, 0xfffbfffb },
+   { 0x00800048, 0x24203e2c, 0x01ed8064, 0xfffbfffb },
+   { 0x00800048, 0x24003e2c, 0x01ed8045, 0x00010001 },
+   { 0x00800048, 0x24203e2c, 0x01ed8065, 0x00010001 },
+   { 0x8080000c, 0xd8403d91, 0x00b10400, 0x00050005 },
+   { 0x8080100c, 0xd8603d91, 0x00b10420, 0x00050005 },
+   { 0x00110220, 0x34001c00, 0x02001400, 0x00000004 },
+   { 0x00110220, 0x34001c00, 0x00001400, 0x0000005c },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x00000062 },
+   { 0x01000010, 0x20003db0, 0x00000446, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x00000042 },
+   { 0x00200401, 0x22000128, 0x0066044c, 0x00000000 },
+   { 0x00200c01, 0x22040128, 0x0045044e, 0x00000000 },
+   { 0x00000801, 0x220c0128, 0x00000454, 0x00000000 },
+   { 0x03400010, 0x20003dac, 0x02000444, 0x00020002 },
+   { 0x01000010, 0x20003dac, 0x00000444, 0x00000000 },
+   { 0x00410040, 0x22002d08, 0x02690200, 0x00010001 },
+   { 0x01000010, 0x20003db0, 0x02000446, 0x00020002 },
+   { 0x00110220, 0x34001c00, 0x00001400, 0x00000002 },
+   { 0x00110001, 0x220c0168, 0x02000000, 0x04800480 },
+   { 0x00a02040, 0x24003e2c, 0x00ad83e0, 0x00100010 },
+   { 0x00800048, 0x24003e2c, 0x01ed8be0, 0xfffbfffb },
+   { 0x00800048, 0x24203e2c, 0x01ed8800, 0xfffbfffb },
+   { 0x00a02048, 0x24003e2c, 0x00ad8000, 0x00140014 },
+   { 0x00800048, 0x24003e2c, 0x01ed8800, 0x00140014 },
+   { 0x00800048, 0x24203e2c, 0x01ed8820, 0x00140014 },
+   { 0x00a02048, 0x24003e2c, 0x00ad8020, 0xfffbfffb },
+   { 0x00800048, 0x24003e2c, 0x01ed8820, 0x00010001 },
+   { 0x00800048, 0x24203e2c, 0x01ed8840, 0x00010001 },
+   { 0x8080000c, 0xd8003d91, 0x00b10400, 0x00050005 },
+   { 0x8080100c, 0xd8203d91, 0x00b10420, 0x00050005 },
+   { 0x00a02040, 0x24003e2c, 0x00ad8020, 0x00100010 },
+   { 0x00800048, 0x24003e2c, 0x01ed8820, 0xfffbfffb },
+   { 0x00800048, 0x24203e2c, 0x01ed8840, 0xfffbfffb },
+   { 0x00a02048, 0x24003e2c, 0x00ad8040, 0x00140014 },
+   { 0x00800048, 0x24003e2c, 0x01ed8840, 0x00140014 },
+   { 0x00800048, 0x24203e2c, 0x01ed8860, 0x00140014 },
+   { 0x00a02048, 0x24003e2c, 0x00ad8060, 0xfffbfffb },
+   { 0x00800048, 0x24003e2c, 0x01ed8860, 0x00010001 },
+   { 0x00800048, 0x24203e2c, 0x01ed8880, 0x00010001 },
+   { 0x8080000c, 0xd8403d91, 0x00b10400, 0x00050005 },
+   { 0x8080100c, 0xd8603d91, 0x00b10420, 0x00050005 },
+   { 0x00110220, 0x34001c00, 0x00001400, 0x00000016 },
+   { 0x00010220, 0x34001c00, 0x02001400, 0x0000001c },
+   { 0x00200401, 0x22000128, 0x0045044c, 0x00000000 },
+   { 0x00000801, 0x220c0128, 0x00000454, 0x00000000 },
+   { 0x01200010, 0x20003dac, 0x00000444, 0x00030003 },
+   { 0x01200010, 0x20003dac, 0x02000446, 0x00030003 },
+   { 0x00210040, 0x22002d08, 0x00450200, 0x00010001 },
+   { 0x00210040, 0x22002d08, 0x02450200, 0x00100010 },
+   { 0x00800001, 0xb8000229, 0x01ed8000, 0x00000000 },
+   { 0x00800001, 0xb8200229, 0x01ed8020, 0x00000000 },
+   { 0x00800001, 0xb8400229, 0x01ed8040, 0x00000000 },
+   { 0x00800001, 0xb8600229, 0x01ed8060, 0x00000000 },
+   { 0x80800042, 0xd8004631, 0x00d29800, 0x00d20480 },
+   { 0x80800042, 0xd8204631, 0x00d29820, 0x00d204a0 },
+   { 0x80800042, 0xd8404631, 0x00d29840, 0x00d204c0 },
+   { 0x80800042, 0xd8604631, 0x00d29860, 0x00d204e0 },
+   { 0x00600001, 0x220001ac, 0x008d0024, 0x00000000 },
+   { 0x00200040, 0x244c3dad, 0x00450448, 0xfff8fff8 },
+   { 0x00000401, 0x220001ec, 0x00000000, 0x07000700 },
+   { 0x00000c01, 0x220201e8, 0x00000000, 0x07100710 },
+   { 0x00000801, 0x220e0128, 0x00000456, 0x00000000 },
+   { 0x00000441, 0x254635ad, 0x00000448, 0x0000044a },
+   { 0x00000c41, 0x254025ad, 0x0000444c, 0x0000444e },
+   { 0x00000c41, 0x254225ad, 0x00000448, 0x0000444e },
+   { 0x00000841, 0x254435ad, 0x0000444c, 0x0000044a },
+   { 0x00200040, 0x244c3d09, 0x00450200, 0x00100010 },
+   { 0x00800041, 0x24002628, 0x00ad8000, 0x00000540 },
+   { 0x00800041, 0x24202628, 0x00ad8020, 0x00000540 },
+   { 0x00800048, 0x24002628, 0x00ad8002, 0x00000542 },
+   { 0x00800048, 0x24202628, 0x00ad8022, 0x00000542 },
+   { 0x00200001, 0x22000128, 0x0045044c, 0x00000000 },
+   { 0x00800048, 0x24002628, 0x01ed8000, 0x00000544 },
+   { 0x00800048, 0x24202628, 0x01ed8020, 0x00000544 },
+   { 0x00800048, 0xbc002629, 0x01ed8002, 0x00000546 },
+   { 0x00801048, 0xbc202629, 0x01ed8022, 0x00000546 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x00000128 },
+   { 0x00000001, 0x20220169, 0x00000000, 0x00040004 },
+   { 0x00200005, 0x24443dad, 0x00459800, 0x00030003 },
+   { 0x0020000c, 0x24403dad, 0x00459800, 0x00020002 },
+   { 0x01600006, 0x20003dac, 0x02000446, 0x00000000 },
+   { 0x00010040, 0x22000c20, 0x02000078, 0x00200000 },
+   { 0x00110040, 0x22000c20, 0x02000078, 0x00500000 },
+   { 0x00310040, 0x20401da5, 0x02450440, 0xfffffffe },
+   { 0x00110001, 0x20480061, 0x02000000, 0x00080008 },
+   { 0x00010040, 0x20401da5, 0x02000440, 0xfffffffe },
+   { 0x00010001, 0x204401a5, 0x02000442, 0x00000000 },
+   { 0x00010001, 0x20480061, 0x02000000, 0x00030008 },
+   { 0x01600031, 0x25600021, 0x408d0040, 0x00000200 },
+   { 0x00000040, 0xb80235ad, 0x00009802, 0x0000003c },
+   { 0x00000040, 0x22000c20, 0x00000078, 0x00100010 },
+   { 0x0020040c, 0x24403dad, 0x00459800, 0x00030003 },
+   { 0x00200805, 0x24483dad, 0x00459800, 0x00070007 },
+   { 0x00200001, 0x204001a5, 0x00450440, 0x00000000 },
+   { 0x00000009, 0x20403ca5, 0x00000040, 0x00010001 },
+   { 0x00000001, 0x20480061, 0x00000000, 0x00020005 },
+   { 0x02600031, 0x27000021, 0x408d0040, 0x00000200 },
+   { 0x00110001, 0x220001ec, 0x02000000, 0x05820582 },
+   { 0x00010001, 0x220001ec, 0x02000000, 0x05620562 },
+   { 0x00000001, 0x220e0128, 0x00000454, 0x00000000 },
+   { 0x01800006, 0x200035ac, 0x02000446, 0x00000444 },
+   { 0x00410001, 0xbc000229, 0x02698000, 0x00000000 },
+   { 0x00410001, 0xbc100229, 0x02698010, 0x00000000 },
+   { 0x00410001, 0xbc200229, 0x02698020, 0x00000000 },
+   { 0x00410001, 0xbc300229, 0x02698030, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x02001400, 0x000000be },
+   { 0x00600001, 0x2024018d, 0x008d0200, 0x00000000 },
+   { 0x01000041, 0x245e35ad, 0x00000446, 0x00000444 },
+   { 0x02000005, 0x20003db0, 0x0200045e, 0x00010001 },
+   { 0x00000040, 0x22022d08, 0x00000200, 0x00100010 },
+   { 0x00200040, 0x22042d08, 0x00450200, 0x00200020 },
+   { 0x00400001, 0x244c0109, 0x00690200, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x00000044 },
+   { 0x00010220, 0x34001c00, 0x02001400, 0x00000042 },
+   { 0x00000040, 0x22003d08, 0x00000200, 0xffdeffde },
+   { 0x00000440, 0x22023d08, 0x00000202, 0xffeeffee },
+   { 0x00000801, 0x220c0060, 0x00000000, 0x04d004c0 },
+   { 0x01000010, 0x20003db0, 0x0000045e, 0x00040004 },
+   { 0x00802040, 0x2400462c, 0x00a98000, 0x00a98005 },
+   { 0x00802048, 0x24003e2c, 0x00a98001, 0xfffbfffb },
+   { 0x00802048, 0x24003e2c, 0x00a98002, 0x00140014 },
+   { 0x00802048, 0x24003e2c, 0x00a98003, 0x00140014 },
+   { 0x00802048, 0xb8003e2d, 0x00a98004, 0xfffbfffb },
+   { 0x00802040, 0x2400462c, 0x00a98040, 0x00a98045 },
+   { 0x00802048, 0x24003e2c, 0x00a98041, 0xfffbfffb },
+   { 0x00802048, 0x24003e2c, 0x00a98042, 0x00140014 },
+   { 0x00802048, 0x24003e2c, 0x00a98043, 0x00140014 },
+   { 0x00802048, 0xb8203e2d, 0x00a98044, 0xfffbfffb },
+   { 0x00400040, 0x2400462c, 0x00698080, 0x00698085 },
+   { 0x00400048, 0x24003e2c, 0x00698081, 0xfffbfffb },
+   { 0x00400048, 0x24003e2c, 0x00698082, 0x00140014 },
+   { 0x00400048, 0x24003e2c, 0x00698083, 0x00140014 },
+   { 0x00400048, 0xb8403e2d, 0x00698084, 0xfffbfffb },
+   { 0x00000401, 0x220c0060, 0x00000000, 0x04e004d0 },
+   { 0x00000c01, 0x22000060, 0x00000000, 0x04d004c8 },
+   { 0x00000c01, 0x22040060, 0x00000000, 0x04e004d8 },
+   { 0x00000801, 0x22080060, 0x00000000, 0x04f004e8 },
+   { 0x00800040, 0x24003dac, 0x00b104c0, 0x02000200 },
+   { 0x00800048, 0x24003dac, 0x00b104e0, 0xfffbfffb },
+   { 0x00800048, 0x24003dac, 0x01ed9800, 0x00140014 },
+   { 0x00010001, 0x220c0168, 0x00000000, 0x05400540 },
+   { 0x00110001, 0x220c0168, 0x00000000, 0x04c004c0 },
+   { 0x00800048, 0x24003dac, 0x01e98000, 0xfffbfffb },
+   { 0x00800048, 0x24003dac, 0x01e98020, 0x00010001 },
+   { 0x00800048, 0x24003dac, 0x01e98800, 0x00140014 },
+   { 0x8080000c, 0xd8003d91, 0x00b10400, 0x000a000a },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x00000060 },
+   { 0x01000010, 0x20003db0, 0x00000444, 0x00000000 },
+   { 0x01000010, 0x20003db0, 0x02000446, 0x00020002 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x00000024 },
+   { 0x00010220, 0x34001c00, 0x02001400, 0x00000022 },
+   { 0x00400040, 0x22003d28, 0x0069044c, 0xfffefffe },
+   { 0x03400010, 0x20003dac, 0x00000446, 0x00020002 },
+   { 0x01000010, 0x20003db0, 0x02000444, 0x00020002 },
+   { 0x00410040, 0x22002d08, 0x00690200, 0x00100010 },
+   { 0x01000010, 0x20003dac, 0x00000446, 0x00000000 },
+   { 0x00010001, 0x220e0168, 0x02000000, 0x05400540 },
+   { 0x00110001, 0x220e0168, 0x02000000, 0x04c004c0 },
+   { 0x00800040, 0x24003e2c, 0x01e98000, 0x00100010 },
+   { 0x00800048, 0x24003e2c, 0x01e98001, 0xfffbfffb },
+   { 0x00800048, 0x24003e2c, 0x01e98002, 0x00140014 },
+   { 0x00800048, 0x24003e2c, 0x01e98003, 0x00140014 },
+   { 0x00800048, 0x24003e2c, 0x01e98004, 0xfffbfffb },
+   { 0x00800048, 0x24003e2c, 0x01e98005, 0x00010001 },
+   { 0x8080000c, 0xdc003d91, 0x00b10400, 0x00050005 },
+   { 0x00110220, 0x34001c00, 0x02001400, 0x00000004 },
+   { 0x00110220, 0x34001c00, 0x00001400, 0x00000036 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x00000036 },
+   { 0x01000010, 0x20003db0, 0x00000446, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x00000024 },
+   { 0x03600010, 0x20003dac, 0x02000444, 0x00020002 },
+   { 0x00400401, 0x22000128, 0x0069044c, 0x00000000 },
+   { 0x00400840, 0x22083d2c, 0x0069044c, 0x00100010 },
+   { 0x00610040, 0x22002d08, 0x02690200, 0x00010001 },
+   { 0x01000010, 0x20003dac, 0x00000444, 0x00000000 },
+   { 0x01000010, 0x20003db0, 0x02000446, 0x00020002 },
+   { 0x00800040, 0x24003e2c, 0x01e983e0, 0x00100010 },
+   { 0x00800048, 0x24003e2c, 0x01e98000, 0x00140014 },
+   { 0x00800048, 0x24003e2c, 0x01e98020, 0xfffbfffb },
+   { 0x00800048, 0x24003e2c, 0x01e993e0, 0xfffbfffb },
+   { 0x00800048, 0x24003e2c, 0x01e99000, 0x00140014 },
+   { 0x00800048, 0x24003e2c, 0x01e99020, 0x00010001 },
+   { 0x00000001, 0x220e0168, 0x00000000, 0x05400540 },
+   { 0x00110220, 0x34001c00, 0x00001400, 0x00000002 },
+   { 0x00110001, 0x220e0168, 0x02000000, 0x04c004c0 },
+   { 0x8080000c, 0xdc003d91, 0x00b10400, 0x00050005 },
+   { 0x00110220, 0x34001c00, 0x00001400, 0x0000000e },
+   { 0x00010220, 0x34001c00, 0x02001400, 0x0000000e },
+   { 0x00400001, 0x22000128, 0x0069044c, 0x00000000 },
+   { 0x01400010, 0x20003dac, 0x00000444, 0x00030003 },
+   { 0x01400010, 0x20003dac, 0x02000446, 0x00030003 },
+   { 0x00410040, 0x22002d08, 0x00690200, 0x00010001 },
+   { 0x00410040, 0x22002d08, 0x02690200, 0x00100010 },
+   { 0x00800001, 0x25400229, 0x01e98000, 0x00000000 },
+   { 0x80800042, 0x45404631, 0x00d20540, 0x00d204c0 },
+   { 0x00000001, 0x220c0128, 0x00000454, 0x00000000 },
+   { 0x00400001, 0xd8000231, 0x008a0540, 0x00000000 },
+   { 0x00400001, 0xd8100231, 0x008a0548, 0x00000000 },
+   { 0x00400001, 0xd8200231, 0x008a0550, 0x00000000 },
+   { 0x00400001, 0xd8300231, 0x008a0558, 0x00000000 },
+   { 0x00600001, 0x220001ac, 0x008d0024, 0x00000000 },
+   { 0x00200040, 0x244c3dad, 0x00450448, 0xfff8fff8 },
+   { 0x00000401, 0x220001ec, 0x00000000, 0x07000700 },
+   { 0x00000801, 0x220e0128, 0x00000456, 0x00000000 },
+   { 0x00000441, 0x254635ad, 0x00000448, 0x0000044a },
+   { 0x00000c41, 0x254025ad, 0x0000444c, 0x0000444e },
+   { 0x00000c41, 0x254225ad, 0x00000448, 0x0000444e },
+   { 0x00000841, 0x254435ad, 0x0000444c, 0x0000044a },
+   { 0x00600041, 0x24002628, 0x00898000, 0x00000540 },
+   { 0x00600048, 0x24002628, 0x00898002, 0x00000542 },
+   { 0x00600048, 0x24002628, 0x00898008, 0x00000544 },
+   { 0x00600048, 0x2540262d, 0x0089800a, 0x00000546 },
+   { 0x00400401, 0xbc0001a9, 0x00690540, 0x00000000 },
+   { 0x00400801, 0xbc1001a9, 0x00690548, 0x00000000 },
+   { 0x01000010, 0x20003d2c, 0x00000022, 0x00030003 },
+   { 0x01000040, 0x20223d29, 0x02000022, 0xffffffff },
+   { 0x00000040, 0x220c3d8c, 0x0000020c, 0x00080008 },
+   { 0x00110040, 0x24540c21, 0x00000454, 0x00080008 },
+   { 0x00010040, 0x24540c21, 0x00000454, 0x00180038 },
+   { 0x00110220, 0x34001c00, 0x02001400, 0xfffffee4 },
+   { 0x01800010, 0x20003dac, 0x0200010e, 0x00010001 },
+   { 0x00000040, 0x220c3d8c, 0x0000020c, 0xffe0ffe0 },
+   { 0x00010001, 0x24540061, 0x02000000, 0x06c00640 },
+   { 0x00110001, 0x24540061, 0x02000000, 0x04800780 },
+   { 0x00000001, 0x220e0128, 0x00000456, 0x00000000 },
+   { 0x00800040, 0x24003dac, 0x00b19c00, 0x00200020 },
+   { 0x00800040, 0x24203dac, 0x00b19c20, 0x00200020 },
+   { 0x8080000c, 0xdc003d91, 0x00b10400, 0x00060006 },
+   { 0x8080000c, 0xdc203d91, 0x00b10420, 0x00060006 },
+   { 0x02000040, 0x210e3d29, 0x0200010e, 0xffffffff },
+   { 0x00000040, 0x220c3d8c, 0x0000020c, 0x00040004 },
+   { 0x00110220, 0x34001c00, 0x02001400, 0xfffffce0 },
+   { 0x01000005, 0x25643e2d, 0x00000060, 0x00c000c0 },
+   { 0x01000010, 0x20003dac, 0x02000458, 0x00020002 },
+   { 0x00110220, 0x34001c00, 0x00001400, 0x00000016 },
+   { 0x00010220, 0x34001c00, 0x02001400, 0x0000000c },
+   { 0x01000010, 0x20003dac, 0x00000458, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x00000086 },
+   { 0x00a02001, 0x46400231, 0x00d20780, 0x00000000 },
+   { 0x00a02001, 0x46800231, 0x00d207c0, 0x00000000 },
+   { 0x00a02001, 0x46c00231, 0x00d20480, 0x00000000 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x0000007e },
+   { 0x80a02042, 0x46404631, 0x00d20640, 0x00d20780 },
+   { 0x80a02042, 0x46804631, 0x00d20680, 0x00d207c0 },
+   { 0x80a02042, 0x46c04631, 0x00d206c0, 0x00d20480 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x00000076 },
+   { 0x01000010, 0x20003dac, 0x02000564, 0x00800080 },
+   { 0x00110220, 0x34001c00, 0x02001400, 0x0000000e },
+   { 0x01000010, 0x20003dac, 0x00000458, 0x00020002 },
+   { 0x00110220, 0x34001c00, 0x00001400, 0xffffffe4 },
+   { 0x00200401, 0x256801ed, 0x00000000, 0x00200020 },
+   { 0x00200801, 0x256c01ed, 0x00000000, 0x00060006 },
+   { 0x00400001, 0x258001ed, 0x00000000, 0x00000000 },
+   { 0x00600001, 0x45a001ad, 0x00058c00, 0x00000000 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x00000028 },
+   { 0x02600005, 0x20006e28, 0x02008c0c, 0x88848421 },
+   { 0x0220000c, 0x25663dad, 0x00000458, 0x00010001 },
+   { 0x0000000c, 0x25643dad, 0x00000564, 0x00060006 },
+   { 0x00310001, 0x25c401ad, 0x00000458, 0x00000000 },
+   { 0x00210001, 0x25c00061, 0x00000000, 0x00010001 },
+   { 0x00310040, 0x25c03dad, 0x004545c4, 0x00010001 },
+   { 0x00610001, 0x25a00061, 0x02000000, 0x00000080 },
+   { 0x00710001, 0x45a002ad, 0x02ae8c00, 0x00000000 },
+   { 0x00710001, 0x45a202ad, 0x02ae8c01, 0x00000000 },
+   { 0x00800041, 0x25a035ad, 0x00b105a0, 0x000905c0 },
+   { 0x01200010, 0x20003e2c, 0x0245006e, 0x00000000 },
+   { 0x00310009, 0x244c45ad, 0x02000564, 0x0045006e },
+   { 0x00210001, 0x244c01ed, 0x02000000, 0x00000000 },
+   { 0x0031000c, 0x244c3dad, 0x0245044c, 0x00010001 },
+   { 0x00200009, 0x256835ad, 0x0045044c, 0x00000566 },
+   { 0x00210040, 0x256835ad, 0x02450568, 0x00000566 },
+   { 0x00200040, 0x256c362d, 0x0045006e, 0x00000566 },
+   { 0x00400040, 0x240035ac, 0x00ab05a2, 0x00ab05a6 },
+   { 0x00400040, 0x2400358c, 0x00690400, 0x00000566 },
+   { 0x0040000c, 0x2580358d, 0x00690400, 0x00000566 },
+   { 0x00800041, 0x2400362c, 0x00d20640, 0x000005a0 },
+   { 0x00800041, 0x2420362c, 0x00d20660, 0x000005a0 },
+   { 0x00800048, 0x2400362c, 0x00d20780, 0x000005a4 },
+   { 0x00800048, 0x2420362c, 0x00d207a0, 0x000005a4 },
+   { 0x00800040, 0x2400358c, 0x00b10400, 0x00000568 },
+   { 0x00800040, 0x2420358c, 0x00b10420, 0x00000568 },
+   { 0x0080000c, 0x24c0358d, 0x00b10400, 0x0000056c },
+   { 0x0080000c, 0x24e0358d, 0x00b10420, 0x0000056c },
+   { 0x80800040, 0x464035b1, 0x00b104c0, 0x00000580 },
+   { 0x80800040, 0x466035b1, 0x00b104e0, 0x00000580 },
+   { 0x00800041, 0x2400362c, 0x00d20680, 0x000005a0 },
+   { 0x00800041, 0x2420362c, 0x00d206a0, 0x000005a0 },
+   { 0x00800048, 0x2400362c, 0x00d207c0, 0x000005a4 },
+   { 0x00800048, 0x2420362c, 0x00d207e0, 0x000005a4 },
+   { 0x00800040, 0x2400358c, 0x00b10400, 0x00000568 },
+   { 0x00800040, 0x2420358c, 0x00b10420, 0x00000568 },
+   { 0x0080000c, 0x24c0358d, 0x00b10400, 0x0000056c },
+   { 0x0080000c, 0x24e0358d, 0x00b10420, 0x0000056c },
+   { 0x80800040, 0x468035b1, 0x00b104c0, 0x00000580 },
+   { 0x80800040, 0x46a035b1, 0x00b104e0, 0x00000580 },
+   { 0x00800041, 0x2400362c, 0x00d206c0, 0x000705a8 },
+   { 0x00800041, 0x2420362c, 0x00d206e0, 0x000705a8 },
+   { 0x00800048, 0x2400362c, 0x00d20480, 0x000705ac },
+   { 0x00800048, 0x2420362c, 0x00d204a0, 0x000705ac },
+   { 0x00800040, 0x2400358c, 0x00b10400, 0x0000056a },
+   { 0x00800040, 0x2420358c, 0x00b10420, 0x0000056a },
+   { 0x0080000c, 0x24c0358d, 0x00b10400, 0x0000056e },
+   { 0x0080000c, 0x24e0358d, 0x00b10420, 0x0000056e },
+   { 0x80800040, 0x46c035b1, 0x00b104c0, 0x00050582 },
+   { 0x80800040, 0x46e035b1, 0x00b104e0, 0x00050582 },
+   { 0x01800005, 0x20003d2c, 0x02000020, 0x00020002 },
+   { 0x80800040, 0xd00045b1, 0x00b19000, 0x00d20640 },
+   { 0x80800040, 0xd02045b1, 0x00b19020, 0x00d20660 },
+   { 0x80800040, 0xd04045b1, 0x00b19040, 0x00d20680 },
+   { 0x80800040, 0xd06045b1, 0x00b19060, 0x00d206a0 },
+   { 0x00000040, 0x22083d8c, 0x00000208, 0x00800080 },
+   { 0x80400040, 0xd40045b1, 0x00699400, 0x00ab06c0 },
+   { 0x80400040, 0xd48045b1, 0x00699480, 0x00ab06c2 },
+   { 0x80400040, 0xd42045b1, 0x00699420, 0x00ab06e0 },
+   { 0x80400040, 0xd4a045b1, 0x006994a0, 0x00ab06e2 },
+   { 0x80400040, 0xd41045b1, 0x00699410, 0x00ab06d0 },
+   { 0x80400040, 0xd49045b1, 0x00699490, 0x00ab06d2 },
+   { 0x80400040, 0xd43045b1, 0x00699430, 0x00ab06f0 },
+   { 0x80400040, 0xd4b045b1, 0x006994b0, 0x00ab06f2 },
+   { 0x00000040, 0x220a3d8c, 0x0000020a, 0x00080008 },
+   { 0x00110040, 0x220a3d8c, 0x0200020a, 0x00300030 },
+   { 0x01000010, 0x20003d2c, 0x02000020, 0x00060006 },
+   { 0x00000040, 0x20203d29, 0x00000020, 0x00020002 },
+   { 0x00000040, 0x22040c00, 0x00000204, 0x00100001 },
+   { 0x00000040, 0x220c358c, 0x0000020c, 0x0000003a },
+   { 0x00110220, 0x34001c00, 0x02001400, 0xfffffc1e },
+   { 0x00000001, 0x220001ec, 0x00000000, 0x01400140 },
+   { 0x00000001, 0x220201ec, 0x00000000, 0x01c001c0 },
+   { 0x00800401, 0x20400236, 0x01ee8000, 0x00000000 },
+   { 0x00800801, 0x20500236, 0x01ee8010, 0x00000000 },
+   { 0x00800401, 0x20600236, 0x01ee8020, 0x00000000 },
+   { 0x00800801, 0x20700236, 0x01ee8030, 0x00000000 },
+   { 0x00800401, 0x20800236, 0x01ee8040, 0x00000000 },
+   { 0x00800801, 0x20900236, 0x01ee8050, 0x00000000 },
+   { 0x00800401, 0x20a00236, 0x01ee8060, 0x00000000 },
+   { 0x00800801, 0x20b00236, 0x01ee8070, 0x00000000 },
+   { 0x00800401, 0x20c00236, 0x01ee8100, 0x00000000 },
+   { 0x00800801, 0x20d00236, 0x01ee8110, 0x00000000 },
+   { 0x00800401, 0x20e00236, 0x01ee8120, 0x00000000 },
+   { 0x00800801, 0x20f00236, 0x01ee8130, 0x00000000 },
+   { 0x00800401, 0x21000236, 0x01ee8140, 0x00000000 },
+   { 0x00800801, 0x21100236, 0x01ee8150, 0x00000000 },
+   { 0x00800401, 0x21200236, 0x01ee8160, 0x00000000 },
+   { 0x00800801, 0x21300236, 0x01ee8170, 0x00000000 },
+   { 0x00000040, 0x22000d20, 0x00000062, 0x1218a600 },
+   { 0x00200401, 0x204001a5, 0x00450064, 0x00000000 },
+   { 0x00000801, 0x20480061, 0x00000000, 0x000f000f },
+   { 0x01600031, 0x21400021, 0x508d0040, 0x00000200 },
+   { 0x00000001, 0x220001ec, 0x00000000, 0x03400340 },
+   { 0x00800401, 0x41600236, 0x00d28000, 0x00000000 },
+   { 0x00800801, 0x41610236, 0x00d28080, 0x00000000 },
+   { 0x00800401, 0x41800236, 0x00d28020, 0x00000000 },
+   { 0x00800801, 0x41810236, 0x00d280a0, 0x00000000 },
+   { 0x00800401, 0x41a00236, 0x00d28040, 0x00000000 },
+   { 0x00800801, 0x41a10236, 0x00d280c0, 0x00000000 },
+   { 0x00800401, 0x41c00236, 0x00d28060, 0x00000000 },
+   { 0x00800801, 0x41c10236, 0x00d280e0, 0x00000000 },
+   { 0x00000040, 0x22000d20, 0x00000062, 0x0a18a601 },
+   { 0x0000040c, 0x20443ca5, 0x00000044, 0x00010001 },
+   { 0x00000801, 0x20480061, 0x00000000, 0x0007000f },
+   { 0x0a600031, 0x21600021, 0x508d0040, 0x00000200 },
+   { 0x00000001, 0x21400021, 0x00000140, 0x00000000 },
+   { 0x00000001, 0x21600021, 0x00000160, 0x00000000 },
+   { 0x01600031, 0x20001c20, 0x708d0000, 0x82000010 },
+   { 0x00000000, 0x00000000, 0x00000000, 0x00000000 },
+   { 0x00600001, 0x20400021, 0x008d0000, 0x00000000 },
+   { 0x00000005, 0x20203e2d, 0x00000061, 0x001f001f },
+   { 0x00200009, 0x20643e2d, 0x00450064, 0x00040004 },
+   { 0x00000001, 0x203a01ed, 0x00000000, 0x00000000 },
+   { 0x01000010, 0x20003dac, 0x00000020, 0x00160016 },
+   { 0x00110220, 0x34001c00, 0x00001400, 0x0000001e },
+   { 0x01200010, 0x20003e2c, 0x0200006c, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x02001400, 0x00000024 },
+   { 0x00800009, 0x25403dad, 0x00050064, 0x00020002 },
+   { 0x00000001, 0x203a01ed, 0x00000000, 0x00180018 },
+   { 0x00200040, 0x45483dad, 0x00660548, 0x00100010 },
+   { 0x00200040, 0x45523dad, 0x00660552, 0x00100010 },
+   { 0x00400040, 0x25583dad, 0x00690558, 0x00100010 },
+   { 0x00800040, 0x208035ad, 0x00b10080, 0x00b10540 },
+   { 0x00600040, 0x45403dad, 0x00ae0540, 0x00200020 },
+   { 0x00800040, 0x20a035ad, 0x00b100a0, 0x00b10540 },
+   { 0x00600040, 0x45423dad, 0x00ae0542, 0x00200020 },
+   { 0x00800040, 0x20e035ad, 0x00b100e0, 0x00b10540 },
+   { 0x00600040, 0x45403dad, 0x00ae0540, 0xffe0ffe0 },
+   { 0x00800040, 0x20c035ad, 0x00b100c0, 0x00b10540 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x00000014 },
+   { 0x06600010, 0x20003dac, 0x02000020, 0x00030003 },
+   { 0x00000001, 0x206c0171, 0x00000000, 0x00000000 },
+   { 0x00610001, 0x208000a5, 0x02050080, 0x00000000 },
+   { 0x00610001, 0x212000a5, 0x02090100, 0x00000000 },
+   { 0x00410001, 0x211000a5, 0x02690100, 0x00000000 },
+   { 0x00200009, 0x25403dad, 0x00450064, 0x00020002 },
+   { 0x00800040, 0x208035ad, 0x00b10080, 0x00050540 },
+   { 0x00200040, 0x40883dad, 0x00660088, 0x00200020 },
+   { 0x00200040, 0x40923dad, 0x00660092, 0x00200020 },
+   { 0x00400040, 0x20983dad, 0x00690098, 0x00200020 },
+   { 0x00200401, 0x22080060, 0x00000000, 0x03400140 },
+   { 0x00000c01, 0x220c0060, 0x00000000, 0x04400080 },
+   { 0x00000801, 0x22040060, 0x00000000, 0x01000070 },
+   { 0x02000005, 0x20002e28, 0x00000061, 0x00400040 },
+   { 0x00010005, 0x203e2e29, 0x00000063, 0x00010001 },
+   { 0x00110001, 0x203e0169, 0x00000000, 0x00030003 },
+   { 0x00000001, 0x20200169, 0x00000000, 0x00000000 },
+   { 0x0000000c, 0x2458262d, 0x0000006d, 0x00000020 },
+   { 0x00000001, 0x210e0169, 0x00000000, 0x00010001 },
+   { 0x00000005, 0x24583dad, 0x00000458, 0x00030003 },
+   { 0x01000010, 0x200035ac, 0x0000010e, 0x00000458 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x0000031a },
+   { 0x01000010, 0x20003dac, 0x0200010e, 0x00010001 },
+   { 0x00010401, 0x24540061, 0x02000000, 0x06c00640 },
+   { 0x00010805, 0x245a3e2d, 0x02008800, 0x007f007f },
+   { 0x00110401, 0x24540061, 0x02000000, 0x04800780 },
+   { 0x00110805, 0x245a3e2d, 0x02008804, 0x007f007f },
+   { 0x00010005, 0x245c3e2d, 0x02008800, 0x00800080 },
+   { 0x00110005, 0x245c3e2d, 0x02008804, 0x00800080 },
+   { 0x00000009, 0x245c3dad, 0x0000045c, 0x00010001 },
+   { 0x0000000c, 0x211e362d, 0x0000006c, 0x00000020 },
+   { 0x00000040, 0x240035ac, 0x0000003e, 0x0000045c },
+   { 0x01000010, 0x20003d8c, 0x00210400, 0x00010001 },
+   { 0x01000010, 0x20003d8c, 0x02210400, 0x01000100 },
+   { 0x00000001, 0x203c01ed, 0x00000000, 0x00000000 },
+   { 0x00010001, 0x203c01ed, 0x00000000, 0x00020002 },
+   { 0x00010001, 0x203c01ed, 0x02000000, 0xfffefffe },
+   { 0x02000005, 0x20002e28, 0x00000061, 0x00400040 },
+   { 0x00010040, 0x244c0d21, 0x0000045a, 0x0208e602 },
+   { 0x00110040, 0x20780d21, 0x0000045a, 0x0208a002 },
+   { 0x00010040, 0x20782421, 0x0000044c, 0x0000045c },
+   { 0x02000005, 0x20003dac, 0x0200011e, 0x00030003 },
+   { 0x00010220, 0x34001c00, 0x02001400, 0x000001c0 },
+   { 0x01000005, 0x20003dac, 0x00009800, 0x00030003 },
+   { 0x00200005, 0x24443dad, 0x00459800, 0x00030003 },
+   { 0x0020000c, 0x24403dad, 0x00459800, 0x00020002 },
+   { 0x01600006, 0x20003dac, 0x02000446, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x00000012 },
+   { 0x00010040, 0x22000c20, 0x02000078, 0x00400000 },
+   { 0x00110040, 0x22000c20, 0x02000078, 0x00700000 },
+   { 0x00310040, 0x20401da5, 0x02450440, 0xfffffffe },
+   { 0x00110001, 0x20480061, 0x02000000, 0x000c000c },
+   { 0x00010040, 0x20401da5, 0x02000440, 0xfffffffe },
+   { 0x00010001, 0x204401a5, 0x02000442, 0x00000000 },
+   { 0x00010001, 0x20480061, 0x02000000, 0x0007000c },
+   { 0x01600031, 0x25600021, 0x408d0040, 0x00000200 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x0000000e },
+   { 0x00010040, 0x22000c20, 0x02000078, 0x00200000 },
+   { 0x00110040, 0x22000c20, 0x02000078, 0x00400000 },
+   { 0x00200001, 0x204001a5, 0x00450440, 0x00000000 },
+   { 0x00110040, 0x20441da5, 0x02000442, 0xfffffffe },
+   { 0x00110001, 0x20480061, 0x02000000, 0x000c0007 },
+   { 0x00010001, 0x20480061, 0x02000000, 0x00070007 },
+   { 0x01600031, 0x25600021, 0x408d0040, 0x00000200 },
+   { 0x00000040, 0xb80235ad, 0x00009802, 0x0000003c },
+   { 0x0020040c, 0x24403dad, 0x00459800, 0x00030003 },
+   { 0x00200805, 0x24483dad, 0x00459800, 0x00070007 },
+   { 0x01600006, 0x20003dac, 0x0000044a, 0x00000000 },
+   { 0x00200001, 0x204001a5, 0x00450440, 0x00000000 },
+   { 0x00000009, 0x20403ca5, 0x00000040, 0x00010001 },
+   { 0x00010040, 0x22000c20, 0x00000078, 0x00200010 },
+   { 0x00110040, 0x22000c20, 0x00000078, 0x00300010 },
+   { 0x00010001, 0x20480061, 0x00000000, 0x00030009 },
+   { 0x00110001, 0x20480061, 0x00000000, 0x00040009 },
+   { 0x02600031, 0x27000021, 0x408d0040, 0x00000200 },
+   { 0x01000005, 0x20003dac, 0x00009800, 0x00030003 },
+   { 0x00110220, 0x34001c00, 0x00001400, 0x0000001a },
+   { 0x00600001, 0x26220231, 0x008d05c0, 0x00000000 },
+   { 0x00600401, 0x26120231, 0x008d05b8, 0x00000000 },
+   { 0x00600801, 0x26020231, 0x008d05b0, 0x00000000 },
+   { 0x00600401, 0x25f20231, 0x008d05a8, 0x00000000 },
+   { 0x00600801, 0x25e20231, 0x008d05a0, 0x00000000 },
+   { 0x00600401, 0x25d20231, 0x008d0598, 0x00000000 },
+   { 0x00600801, 0x25c20231, 0x008d0590, 0x00000000 },
+   { 0x00600401, 0x25b20231, 0x008d0588, 0x00000000 },
+   { 0x00600801, 0x25a20231, 0x008d0580, 0x00000000 },
+   { 0x00600401, 0x25920231, 0x008d0578, 0x00000000 },
+   { 0x00600801, 0x25820231, 0x008d0570, 0x00000000 },
+   { 0x00600001, 0x25720231, 0x008d0568, 0x00000000 },
+   { 0x00600001, 0x25620231, 0x008d0560, 0x00000000 },
+   { 0x00110001, 0x220001ec, 0x02000000, 0x05820582 },
+   { 0x00010001, 0x220001ec, 0x02000000, 0x05620562 },
+   { 0x00000001, 0x220e0128, 0x00000454, 0x00000000 },
+   { 0x01800006, 0x200035ac, 0x02000446, 0x00000444 },
+   { 0x00810001, 0xbc000229, 0x02ad8000, 0x00000000 },
+   { 0x00810001, 0xbc200229, 0x02ad8020, 0x00000000 },
+   { 0x00810001, 0xbc400229, 0x02ad8040, 0x00000000 },
+   { 0x00810001, 0xbc600229, 0x02ad8060, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x02001400, 0x0000012a },
+   { 0x00600001, 0x2024018d, 0x008d0200, 0x00000000 },
+   { 0x01000041, 0x245e35ad, 0x00000446, 0x00000444 },
+   { 0x00000040, 0x22022d08, 0x00000200, 0x00100010 },
+   { 0x02000005, 0x20003db0, 0x0200045e, 0x00010001 },
+   { 0x00200040, 0x22042d08, 0x00450200, 0x00200020 },
+   { 0x00400001, 0x244c0109, 0x00690200, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x00000066 },
+   { 0x00010220, 0x34001c00, 0x02001400, 0x00000064 },
+   { 0x00000040, 0x22003d08, 0x00000200, 0xffdeffde },
+   { 0x00000440, 0x22023d08, 0x00000202, 0xffeeffee },
+   { 0x00000801, 0x220c0060, 0x00000000, 0x04a00480 },
+   { 0x01000010, 0x20003db0, 0x0000045e, 0x00040004 },
+   { 0x00a02040, 0x2400462c, 0x00ad8000, 0x00ad8005 },
+   { 0x00a02048, 0x24003e2c, 0x00ad8001, 0xfffbfffb },
+   { 0x00a02048, 0x24003e2c, 0x00ad8002, 0x00140014 },
+   { 0x00a02048, 0x24003e2c, 0x00ad8003, 0x00140014 },
+   { 0x00a02048, 0xb8003e2d, 0x00ad8004, 0xfffbfffb },
+   { 0x00a02040, 0x2400462c, 0x00ad8040, 0x00ad8045 },
+   { 0x00a02048, 0x24003e2c, 0x00ad8041, 0xfffbfffb },
+   { 0x00a02048, 0x24003e2c, 0x00ad8042, 0x00140014 },
+   { 0x00a02048, 0x24003e2c, 0x00ad8043, 0x00140014 },
+   { 0x00a02048, 0xb8403e2d, 0x00ad8044, 0xfffbfffb },
+   { 0x00a02040, 0x2400462c, 0x00ad8080, 0x00ad8085 },
+   { 0x00a02048, 0x24003e2c, 0x00ad8081, 0xfffbfffb },
+   { 0x00a02048, 0x24003e2c, 0x00ad8082, 0x00140014 },
+   { 0x00a02048, 0x24003e2c, 0x00ad8083, 0x00140014 },
+   { 0x00a02048, 0xb8803e2d, 0x00ad8084, 0xfffbfffb },
+   { 0x00600040, 0x2400462c, 0x008d80c0, 0x008d80c5 },
+   { 0x00600048, 0x24003e2c, 0x008d80c1, 0xfffbfffb },
+   { 0x00600048, 0x24003e2c, 0x008d80c2, 0x00140014 },
+   { 0x00600048, 0x24003e2c, 0x008d80c3, 0x00140014 },
+   { 0x00600048, 0xb8c03e2d, 0x008d80c4, 0xfffbfffb },
+   { 0x00000401, 0x22000060, 0x00000000, 0x04a00480 },
+   { 0x00000c01, 0x22040060, 0x00000000, 0x04a00490 },
+   { 0x00010802, 0x220c2d28, 0x00000454, 0x04800480 },
+   { 0x00a02040, 0x24003dac, 0x00b18000, 0x02000200 },
+   { 0x00800048, 0x24003dac, 0x01ed8800, 0xfffbfffb },
+   { 0x00800048, 0x24203dac, 0x01ed8820, 0xfffbfffb },
+   { 0x00a02048, 0x24003dac, 0x00b18020, 0x00140014 },
+   { 0x00800048, 0x24003dac, 0x01ed8820, 0x00140014 },
+   { 0x00800048, 0x24203dac, 0x01ed8840, 0x00140014 },
+   { 0x00a02048, 0x24003dac, 0x00b18040, 0xfffbfffb },
+   { 0x00800048, 0x24003dac, 0x01ed8840, 0x00010001 },
+   { 0x00800048, 0x24203dac, 0x01ed8860, 0x00010001 },
+   { 0x8080000c, 0xd8003d91, 0x00b10400, 0x000a000a },
+   { 0x8080100c, 0xd8203d91, 0x00b10420, 0x000a000a },
+   { 0x00a02040, 0x24003dac, 0x00b18040, 0x02000200 },
+   { 0x00800048, 0x24003dac, 0x01ed8840, 0xfffbfffb },
+   { 0x00800048, 0x24203dac, 0x01ed8860, 0xfffbfffb },
+   { 0x00a02048, 0x24003dac, 0x00b18060, 0x00140014 },
+   { 0x00800048, 0x24003dac, 0x01ed8860, 0x00140014 },
+   { 0x00800048, 0x24203dac, 0x01ed8880, 0x00140014 },
+   { 0x00a02048, 0x24003dac, 0x00b18080, 0xfffbfffb },
+   { 0x00800048, 0x24003dac, 0x01ed8880, 0x00010001 },
+   { 0x00800048, 0x24203dac, 0x01ed88a0, 0x00010001 },
+   { 0x8080000c, 0xd8403d91, 0x00b10400, 0x000a000a },
+   { 0x8080100c, 0xd8603d91, 0x00b10420, 0x000a000a },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x000000b4 },
+   { 0x01000010, 0x20003db0, 0x00000444, 0x00000000 },
+   { 0x01000010, 0x20003db0, 0x02000446, 0x00020002 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x0000004c },
+   { 0x00010220, 0x34001c00, 0x02001400, 0x0000004a },
+   { 0x00400040, 0x22003d28, 0x0069044c, 0xfffefffe },
+   { 0x03400010, 0x20003dac, 0x00000446, 0x00020002 },
+   { 0x01000010, 0x20003db0, 0x02000444, 0x00020002 },
+   { 0x00410040, 0x22002d08, 0x00690200, 0x00100010 },
+   { 0x01000010, 0x20003dac, 0x00000446, 0x00000000 },
+   { 0x00010002, 0x220c2d28, 0x02000454, 0x04800480 },
+   { 0x00800040, 0x24003e2c, 0x01ed8000, 0x00100010 },
+   { 0x00800040, 0x24203e2c, 0x01ed8020, 0x00100010 },
+   { 0x00800048, 0x24003e2c, 0x01ed8001, 0xfffbfffb },
+   { 0x00800048, 0x24203e2c, 0x01ed8021, 0xfffbfffb },
+   { 0x00800048, 0x24003e2c, 0x01ed8002, 0x00140014 },
+   { 0x00800048, 0x24203e2c, 0x01ed8022, 0x00140014 },
+   { 0x00800048, 0x24003e2c, 0x01ed8003, 0x00140014 },
+   { 0x00800048, 0x24203e2c, 0x01ed8023, 0x00140014 },
+   { 0x00800048, 0x24003e2c, 0x01ed8004, 0xfffbfffb },
+   { 0x00800048, 0x24203e2c, 0x01ed8024, 0xfffbfffb },
+   { 0x00800048, 0x24003e2c, 0x01ed8005, 0x00010001 },
+   { 0x00800048, 0x24203e2c, 0x01ed8025, 0x00010001 },
+   { 0x8080000c, 0xd8003d91, 0x00b10400, 0x00050005 },
+   { 0x8080100c, 0xd8203d91, 0x00b10420, 0x00050005 },
+   { 0x00800040, 0x24003e2c, 0x01ed8040, 0x00100010 },
+   { 0x00800040, 0x24203e2c, 0x01ed8060, 0x00100010 },
+   { 0x00800048, 0x24003e2c, 0x01ed8041, 0xfffbfffb },
+   { 0x00800048, 0x24203e2c, 0x01ed8061, 0xfffbfffb },
+   { 0x00800048, 0x24003e2c, 0x01ed8042, 0x00140014 },
+   { 0x00800048, 0x24203e2c, 0x01ed8062, 0x00140014 },
+   { 0x00800048, 0x24003e2c, 0x01ed8043, 0x00140014 },
+   { 0x00800048, 0x24203e2c, 0x01ed8063, 0x00140014 },
+   { 0x00800048, 0x24003e2c, 0x01ed8044, 0xfffbfffb },
+   { 0x00800048, 0x24203e2c, 0x01ed8064, 0xfffbfffb },
+   { 0x00800048, 0x24003e2c, 0x01ed8045, 0x00010001 },
+   { 0x00800048, 0x24203e2c, 0x01ed8065, 0x00010001 },
+   { 0x8080000c, 0xd8403d91, 0x00b10400, 0x00050005 },
+   { 0x8080100c, 0xd8603d91, 0x00b10420, 0x00050005 },
+   { 0x00110220, 0x34001c00, 0x02001400, 0x00000004 },
+   { 0x00110220, 0x34001c00, 0x00001400, 0x0000005c },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x00000062 },
+   { 0x01000010, 0x20003db0, 0x00000446, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x00000042 },
+   { 0x00200401, 0x22000128, 0x0066044c, 0x00000000 },
+   { 0x00200c01, 0x22040128, 0x0045044e, 0x00000000 },
+   { 0x00000801, 0x220c0128, 0x00000454, 0x00000000 },
+   { 0x03400010, 0x20003dac, 0x02000444, 0x00020002 },
+   { 0x01000010, 0x20003dac, 0x00000444, 0x00000000 },
+   { 0x00410040, 0x22002d08, 0x02690200, 0x00010001 },
+   { 0x01000010, 0x20003db0, 0x02000446, 0x00020002 },
+   { 0x00110220, 0x34001c00, 0x00001400, 0x00000002 },
+   { 0x00110001, 0x220c0168, 0x02000000, 0x04800480 },
+   { 0x00a02040, 0x24003e2c, 0x00ad83e0, 0x00100010 },
+   { 0x00800048, 0x24003e2c, 0x01ed8be0, 0xfffbfffb },
+   { 0x00800048, 0x24203e2c, 0x01ed8800, 0xfffbfffb },
+   { 0x00a02048, 0x24003e2c, 0x00ad8000, 0x00140014 },
+   { 0x00800048, 0x24003e2c, 0x01ed8800, 0x00140014 },
+   { 0x00800048, 0x24203e2c, 0x01ed8820, 0x00140014 },
+   { 0x00a02048, 0x24003e2c, 0x00ad8020, 0xfffbfffb },
+   { 0x00800048, 0x24003e2c, 0x01ed8820, 0x00010001 },
+   { 0x00800048, 0x24203e2c, 0x01ed8840, 0x00010001 },
+   { 0x8080000c, 0xd8003d91, 0x00b10400, 0x00050005 },
+   { 0x8080100c, 0xd8203d91, 0x00b10420, 0x00050005 },
+   { 0x00a02040, 0x24003e2c, 0x00ad8020, 0x00100010 },
+   { 0x00800048, 0x24003e2c, 0x01ed8820, 0xfffbfffb },
+   { 0x00800048, 0x24203e2c, 0x01ed8840, 0xfffbfffb },
+   { 0x00a02048, 0x24003e2c, 0x00ad8040, 0x00140014 },
+   { 0x00800048, 0x24003e2c, 0x01ed8840, 0x00140014 },
+   { 0x00800048, 0x24203e2c, 0x01ed8860, 0x00140014 },
+   { 0x00a02048, 0x24003e2c, 0x00ad8060, 0xfffbfffb },
+   { 0x00800048, 0x24003e2c, 0x01ed8860, 0x00010001 },
+   { 0x00800048, 0x24203e2c, 0x01ed8880, 0x00010001 },
+   { 0x8080000c, 0xd8403d91, 0x00b10400, 0x00050005 },
+   { 0x8080100c, 0xd8603d91, 0x00b10420, 0x00050005 },
+   { 0x00110220, 0x34001c00, 0x00001400, 0x00000016 },
+   { 0x00010220, 0x34001c00, 0x02001400, 0x0000001c },
+   { 0x00200401, 0x22000128, 0x0045044c, 0x00000000 },
+   { 0x00000801, 0x220c0128, 0x00000454, 0x00000000 },
+   { 0x01200010, 0x20003dac, 0x00000444, 0x00030003 },
+   { 0x01200010, 0x20003dac, 0x02000446, 0x00030003 },
+   { 0x00210040, 0x22002d08, 0x00450200, 0x00010001 },
+   { 0x00210040, 0x22002d08, 0x02450200, 0x00100010 },
+   { 0x00800001, 0xb8000229, 0x01ed8000, 0x00000000 },
+   { 0x00800001, 0xb8200229, 0x01ed8020, 0x00000000 },
+   { 0x00800001, 0xb8400229, 0x01ed8040, 0x00000000 },
+   { 0x00800001, 0xb8600229, 0x01ed8060, 0x00000000 },
+   { 0x80800042, 0xd8004631, 0x00d29800, 0x00d20480 },
+   { 0x80800042, 0xd8204631, 0x00d29820, 0x00d204a0 },
+   { 0x80800042, 0xd8404631, 0x00d29840, 0x00d204c0 },
+   { 0x80800042, 0xd8604631, 0x00d29860, 0x00d204e0 },
+   { 0x00600001, 0x220001ac, 0x008d0024, 0x00000000 },
+   { 0x00200040, 0x244c3dad, 0x00450448, 0xfff8fff8 },
+   { 0x00000401, 0x220001ec, 0x00000000, 0x07000700 },
+   { 0x00000c01, 0x220201e8, 0x00000000, 0x07100710 },
+   { 0x00000801, 0x220e0128, 0x00000456, 0x00000000 },
+   { 0x00000441, 0x254635ad, 0x00000448, 0x0000044a },
+   { 0x00000c41, 0x254025ad, 0x0000444c, 0x0000444e },
+   { 0x00000c41, 0x254225ad, 0x00000448, 0x0000444e },
+   { 0x00000841, 0x254435ad, 0x0000444c, 0x0000044a },
+   { 0x00200040, 0x244c3d09, 0x00450200, 0x00100010 },
+   { 0x00800041, 0x24002628, 0x00ad8000, 0x00000540 },
+   { 0x00800041, 0x24202628, 0x00ad8020, 0x00000540 },
+   { 0x00800048, 0x24002628, 0x00ad8002, 0x00000542 },
+   { 0x00800048, 0x24202628, 0x00ad8022, 0x00000542 },
+   { 0x00200001, 0x22000128, 0x0045044c, 0x00000000 },
+   { 0x00800048, 0x24002628, 0x01ed8000, 0x00000544 },
+   { 0x00800048, 0x24202628, 0x01ed8020, 0x00000544 },
+   { 0x00800048, 0xbc002629, 0x01ed8002, 0x00000546 },
+   { 0x00801048, 0xbc202629, 0x01ed8022, 0x00000546 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x00000128 },
+   { 0x00000001, 0x20220169, 0x00000000, 0x00040004 },
+   { 0x00200005, 0x24443dad, 0x00459800, 0x00030003 },
+   { 0x0020000c, 0x24403dad, 0x00459800, 0x00020002 },
+   { 0x01600006, 0x20003dac, 0x02000446, 0x00000000 },
+   { 0x00010040, 0x22000c20, 0x02000078, 0x00200000 },
+   { 0x00110040, 0x22000c20, 0x02000078, 0x00500000 },
+   { 0x00310040, 0x20401da5, 0x02450440, 0xfffffffe },
+   { 0x00110001, 0x20480061, 0x02000000, 0x00080008 },
+   { 0x00010040, 0x20401da5, 0x02000440, 0xfffffffe },
+   { 0x00010001, 0x204401a5, 0x02000442, 0x00000000 },
+   { 0x00010001, 0x20480061, 0x02000000, 0x00030008 },
+   { 0x01600031, 0x25600021, 0x408d0040, 0x00000200 },
+   { 0x00000040, 0xb80235ad, 0x00009802, 0x0000003c },
+   { 0x00000040, 0x22000c20, 0x00000078, 0x00100010 },
+   { 0x0020040c, 0x24403dad, 0x00459800, 0x00030003 },
+   { 0x00200805, 0x24483dad, 0x00459800, 0x00070007 },
+   { 0x00200001, 0x204001a5, 0x00450440, 0x00000000 },
+   { 0x00000009, 0x20403ca5, 0x00000040, 0x00010001 },
+   { 0x00000001, 0x20480061, 0x00000000, 0x00020005 },
+   { 0x02600031, 0x27000021, 0x408d0040, 0x00000200 },
+   { 0x00110001, 0x220001ec, 0x02000000, 0x05820582 },
+   { 0x00010001, 0x220001ec, 0x02000000, 0x05620562 },
+   { 0x00000001, 0x220e0128, 0x00000454, 0x00000000 },
+   { 0x01800006, 0x200035ac, 0x02000446, 0x00000444 },
+   { 0x00410001, 0xbc000229, 0x02698000, 0x00000000 },
+   { 0x00410001, 0xbc100229, 0x02698010, 0x00000000 },
+   { 0x00410001, 0xbc200229, 0x02698020, 0x00000000 },
+   { 0x00410001, 0xbc300229, 0x02698030, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x02001400, 0x000000be },
+   { 0x00600001, 0x2024018d, 0x008d0200, 0x00000000 },
+   { 0x01000041, 0x245e35ad, 0x00000446, 0x00000444 },
+   { 0x02000005, 0x20003db0, 0x0200045e, 0x00010001 },
+   { 0x00000040, 0x22022d08, 0x00000200, 0x00100010 },
+   { 0x00200040, 0x22042d08, 0x00450200, 0x00200020 },
+   { 0x00400001, 0x244c0109, 0x00690200, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x00000044 },
+   { 0x00010220, 0x34001c00, 0x02001400, 0x00000042 },
+   { 0x00000040, 0x22003d08, 0x00000200, 0xffdeffde },
+   { 0x00000440, 0x22023d08, 0x00000202, 0xffeeffee },
+   { 0x00000801, 0x220c0060, 0x00000000, 0x04d004c0 },
+   { 0x01000010, 0x20003db0, 0x0000045e, 0x00040004 },
+   { 0x00802040, 0x2400462c, 0x00a98000, 0x00a98005 },
+   { 0x00802048, 0x24003e2c, 0x00a98001, 0xfffbfffb },
+   { 0x00802048, 0x24003e2c, 0x00a98002, 0x00140014 },
+   { 0x00802048, 0x24003e2c, 0x00a98003, 0x00140014 },
+   { 0x00802048, 0xb8003e2d, 0x00a98004, 0xfffbfffb },
+   { 0x00802040, 0x2400462c, 0x00a98040, 0x00a98045 },
+   { 0x00802048, 0x24003e2c, 0x00a98041, 0xfffbfffb },
+   { 0x00802048, 0x24003e2c, 0x00a98042, 0x00140014 },
+   { 0x00802048, 0x24003e2c, 0x00a98043, 0x00140014 },
+   { 0x00802048, 0xb8203e2d, 0x00a98044, 0xfffbfffb },
+   { 0x00400040, 0x2400462c, 0x00698080, 0x00698085 },
+   { 0x00400048, 0x24003e2c, 0x00698081, 0xfffbfffb },
+   { 0x00400048, 0x24003e2c, 0x00698082, 0x00140014 },
+   { 0x00400048, 0x24003e2c, 0x00698083, 0x00140014 },
+   { 0x00400048, 0xb8403e2d, 0x00698084, 0xfffbfffb },
+   { 0x00000401, 0x220c0060, 0x00000000, 0x04e004d0 },
+   { 0x00000c01, 0x22000060, 0x00000000, 0x04d004c8 },
+   { 0x00000c01, 0x22040060, 0x00000000, 0x04e004d8 },
+   { 0x00000801, 0x22080060, 0x00000000, 0x04f004e8 },
+   { 0x00800040, 0x24003dac, 0x00b104c0, 0x02000200 },
+   { 0x00800048, 0x24003dac, 0x00b104e0, 0xfffbfffb },
+   { 0x00800048, 0x24003dac, 0x01ed9800, 0x00140014 },
+   { 0x00010001, 0x220c0168, 0x00000000, 0x05400540 },
+   { 0x00110001, 0x220c0168, 0x00000000, 0x04c004c0 },
+   { 0x00800048, 0x24003dac, 0x01e98000, 0xfffbfffb },
+   { 0x00800048, 0x24003dac, 0x01e98020, 0x00010001 },
+   { 0x00800048, 0x24003dac, 0x01e98800, 0x00140014 },
+   { 0x8080000c, 0xd8003d91, 0x00b10400, 0x000a000a },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x00000060 },
+   { 0x01000010, 0x20003db0, 0x00000444, 0x00000000 },
+   { 0x01000010, 0x20003db0, 0x02000446, 0x00020002 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x00000024 },
+   { 0x00010220, 0x34001c00, 0x02001400, 0x00000022 },
+   { 0x00400040, 0x22003d28, 0x0069044c, 0xfffefffe },
+   { 0x03400010, 0x20003dac, 0x00000446, 0x00020002 },
+   { 0x01000010, 0x20003db0, 0x02000444, 0x00020002 },
+   { 0x00410040, 0x22002d08, 0x00690200, 0x00100010 },
+   { 0x01000010, 0x20003dac, 0x00000446, 0x00000000 },
+   { 0x00010001, 0x220e0168, 0x02000000, 0x05400540 },
+   { 0x00110001, 0x220e0168, 0x02000000, 0x04c004c0 },
+   { 0x00800040, 0x24003e2c, 0x01e98000, 0x00100010 },
+   { 0x00800048, 0x24003e2c, 0x01e98001, 0xfffbfffb },
+   { 0x00800048, 0x24003e2c, 0x01e98002, 0x00140014 },
+   { 0x00800048, 0x24003e2c, 0x01e98003, 0x00140014 },
+   { 0x00800048, 0x24003e2c, 0x01e98004, 0xfffbfffb },
+   { 0x00800048, 0x24003e2c, 0x01e98005, 0x00010001 },
+   { 0x8080000c, 0xdc003d91, 0x00b10400, 0x00050005 },
+   { 0x00110220, 0x34001c00, 0x02001400, 0x00000004 },
+   { 0x00110220, 0x34001c00, 0x00001400, 0x00000036 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x00000036 },
+   { 0x01000010, 0x20003db0, 0x00000446, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x00000024 },
+   { 0x03600010, 0x20003dac, 0x02000444, 0x00020002 },
+   { 0x00400401, 0x22000128, 0x0069044c, 0x00000000 },
+   { 0x00400840, 0x22083d2c, 0x0069044c, 0x00100010 },
+   { 0x00610040, 0x22002d08, 0x02690200, 0x00010001 },
+   { 0x01000010, 0x20003dac, 0x00000444, 0x00000000 },
+   { 0x01000010, 0x20003db0, 0x02000446, 0x00020002 },
+   { 0x00800040, 0x24003e2c, 0x01e983e0, 0x00100010 },
+   { 0x00800048, 0x24003e2c, 0x01e98000, 0x00140014 },
+   { 0x00800048, 0x24003e2c, 0x01e98020, 0xfffbfffb },
+   { 0x00800048, 0x24003e2c, 0x01e993e0, 0xfffbfffb },
+   { 0x00800048, 0x24003e2c, 0x01e99000, 0x00140014 },
+   { 0x00800048, 0x24003e2c, 0x01e99020, 0x00010001 },
+   { 0x00000001, 0x220e0168, 0x00000000, 0x05400540 },
+   { 0x00110220, 0x34001c00, 0x00001400, 0x00000002 },
+   { 0x00110001, 0x220e0168, 0x02000000, 0x04c004c0 },
+   { 0x8080000c, 0xdc003d91, 0x00b10400, 0x00050005 },
+   { 0x00110220, 0x34001c00, 0x00001400, 0x0000000e },
+   { 0x00010220, 0x34001c00, 0x02001400, 0x0000000e },
+   { 0x00400001, 0x22000128, 0x0069044c, 0x00000000 },
+   { 0x01400010, 0x20003dac, 0x00000444, 0x00030003 },
+   { 0x01400010, 0x20003dac, 0x02000446, 0x00030003 },
+   { 0x00410040, 0x22002d08, 0x00690200, 0x00010001 },
+   { 0x00410040, 0x22002d08, 0x02690200, 0x00100010 },
+   { 0x00800001, 0x25400229, 0x01e98000, 0x00000000 },
+   { 0x80800042, 0x45404631, 0x00d20540, 0x00d204c0 },
+   { 0x00000001, 0x220c0128, 0x00000454, 0x00000000 },
+   { 0x00400001, 0xd8000231, 0x008a0540, 0x00000000 },
+   { 0x00400001, 0xd8100231, 0x008a0548, 0x00000000 },
+   { 0x00400001, 0xd8200231, 0x008a0550, 0x00000000 },
+   { 0x00400001, 0xd8300231, 0x008a0558, 0x00000000 },
+   { 0x00600001, 0x220001ac, 0x008d0024, 0x00000000 },
+   { 0x00200040, 0x244c3dad, 0x00450448, 0xfff8fff8 },
+   { 0x00000401, 0x220001ec, 0x00000000, 0x07000700 },
+   { 0x00000801, 0x220e0128, 0x00000456, 0x00000000 },
+   { 0x00000441, 0x254635ad, 0x00000448, 0x0000044a },
+   { 0x00000c41, 0x254025ad, 0x0000444c, 0x0000444e },
+   { 0x00000c41, 0x254225ad, 0x00000448, 0x0000444e },
+   { 0x00000841, 0x254435ad, 0x0000444c, 0x0000044a },
+   { 0x00600041, 0x24002628, 0x00898000, 0x00000540 },
+   { 0x00600048, 0x24002628, 0x00898002, 0x00000542 },
+   { 0x00600048, 0x24002628, 0x00898008, 0x00000544 },
+   { 0x00600048, 0x2540262d, 0x0089800a, 0x00000546 },
+   { 0x00400401, 0xbc0001a9, 0x00690540, 0x00000000 },
+   { 0x00400801, 0xbc1001a9, 0x00690548, 0x00000000 },
+   { 0x01000010, 0x20003d2c, 0x00000022, 0x00030003 },
+   { 0x01000040, 0x20223d29, 0x02000022, 0xffffffff },
+   { 0x00000040, 0x220c3d8c, 0x0000020c, 0x00080008 },
+   { 0x00110040, 0x24540c21, 0x00000454, 0x00080008 },
+   { 0x00010040, 0x24540c21, 0x00000454, 0x00180038 },
+   { 0x00110220, 0x34001c00, 0x02001400, 0xfffffee4 },
+   { 0x01800010, 0x20003dac, 0x0200010e, 0x00010001 },
+   { 0x00000040, 0x220c3d8c, 0x0000020c, 0xffe0ffe0 },
+   { 0x00010001, 0x24540061, 0x02000000, 0x06c00640 },
+   { 0x00110001, 0x24540061, 0x02000000, 0x04800780 },
+   { 0x00000001, 0x220e0128, 0x00000456, 0x00000000 },
+   { 0x00800040, 0x24003dac, 0x00b19c00, 0x00200020 },
+   { 0x00800040, 0x24203dac, 0x00b19c20, 0x00200020 },
+   { 0x8080000c, 0xdc003d91, 0x00b10400, 0x00060006 },
+   { 0x8080000c, 0xdc203d91, 0x00b10420, 0x00060006 },
+   { 0x02000040, 0x210e3d29, 0x0200010e, 0xffffffff },
+   { 0x00000040, 0x220c3d8c, 0x0000020c, 0x00040004 },
+   { 0x00110220, 0x34001c00, 0x02001400, 0xfffffcdc },
+   { 0x01000005, 0x25643e2d, 0x00000060, 0x00c000c0 },
+   { 0x01000010, 0x20003dac, 0x02000458, 0x00020002 },
+   { 0x00110220, 0x34001c00, 0x00001400, 0x00000016 },
+   { 0x00010220, 0x34001c00, 0x02001400, 0x0000000c },
+   { 0x01000010, 0x20003dac, 0x00000458, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x00000086 },
+   { 0x00a02001, 0x46400231, 0x00d20780, 0x00000000 },
+   { 0x00a02001, 0x46800231, 0x00d207c0, 0x00000000 },
+   { 0x00a02001, 0x46c00231, 0x00d20480, 0x00000000 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x0000007e },
+   { 0x80a02042, 0x46404631, 0x00d20640, 0x00d20780 },
+   { 0x80a02042, 0x46804631, 0x00d20680, 0x00d207c0 },
+   { 0x80a02042, 0x46c04631, 0x00d206c0, 0x00d20480 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x00000076 },
+   { 0x01000010, 0x20003dac, 0x02000564, 0x00800080 },
+   { 0x00110220, 0x34001c00, 0x02001400, 0x0000000e },
+   { 0x01000010, 0x20003dac, 0x00000458, 0x00020002 },
+   { 0x00110220, 0x34001c00, 0x00001400, 0xffffffe4 },
+   { 0x00200401, 0x256801ed, 0x00000000, 0x00200020 },
+   { 0x00200801, 0x256c01ed, 0x00000000, 0x00060006 },
+   { 0x00400001, 0x258001ed, 0x00000000, 0x00000000 },
+   { 0x00600001, 0x45a001ad, 0x00058c00, 0x00000000 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x00000028 },
+   { 0x02600005, 0x20006e28, 0x02008c0c, 0x88848421 },
+   { 0x0220000c, 0x25663dad, 0x00000458, 0x00010001 },
+   { 0x0000000c, 0x25643dad, 0x00000564, 0x00060006 },
+   { 0x00310001, 0x25c401ad, 0x00000458, 0x00000000 },
+   { 0x00210001, 0x25c00061, 0x00000000, 0x00010001 },
+   { 0x00310040, 0x25c03dad, 0x004545c4, 0x00010001 },
+   { 0x00610001, 0x25a00061, 0x02000000, 0x00000080 },
+   { 0x00710001, 0x45a002ad, 0x02ae8c00, 0x00000000 },
+   { 0x00710001, 0x45a202ad, 0x02ae8c01, 0x00000000 },
+   { 0x00800041, 0x25a035ad, 0x00b105a0, 0x000905c0 },
+   { 0x01200010, 0x20003e2c, 0x0245006e, 0x00000000 },
+   { 0x00310009, 0x244c45ad, 0x02000564, 0x0045006e },
+   { 0x00210001, 0x244c01ed, 0x02000000, 0x00000000 },
+   { 0x0031000c, 0x244c3dad, 0x0245044c, 0x00010001 },
+   { 0x00200009, 0x256835ad, 0x0045044c, 0x00000566 },
+   { 0x00210040, 0x256835ad, 0x02450568, 0x00000566 },
+   { 0x00200040, 0x256c362d, 0x0045006e, 0x00000566 },
+   { 0x00400040, 0x240035ac, 0x00ab05a2, 0x00ab05a6 },
+   { 0x00400040, 0x2400358c, 0x00690400, 0x00000566 },
+   { 0x0040000c, 0x2580358d, 0x00690400, 0x00000566 },
+   { 0x00800041, 0x2400362c, 0x00d20640, 0x000005a0 },
+   { 0x00800041, 0x2420362c, 0x00d20660, 0x000005a0 },
+   { 0x00800048, 0x2400362c, 0x00d20780, 0x000005a4 },
+   { 0x00800048, 0x2420362c, 0x00d207a0, 0x000005a4 },
+   { 0x00800040, 0x2400358c, 0x00b10400, 0x00000568 },
+   { 0x00800040, 0x2420358c, 0x00b10420, 0x00000568 },
+   { 0x0080000c, 0x24c0358d, 0x00b10400, 0x0000056c },
+   { 0x0080000c, 0x24e0358d, 0x00b10420, 0x0000056c },
+   { 0x80800040, 0x464035b1, 0x00b104c0, 0x00000580 },
+   { 0x80800040, 0x466035b1, 0x00b104e0, 0x00000580 },
+   { 0x00800041, 0x2400362c, 0x00d20680, 0x000005a0 },
+   { 0x00800041, 0x2420362c, 0x00d206a0, 0x000005a0 },
+   { 0x00800048, 0x2400362c, 0x00d207c0, 0x000005a4 },
+   { 0x00800048, 0x2420362c, 0x00d207e0, 0x000005a4 },
+   { 0x00800040, 0x2400358c, 0x00b10400, 0x00000568 },
+   { 0x00800040, 0x2420358c, 0x00b10420, 0x00000568 },
+   { 0x0080000c, 0x24c0358d, 0x00b10400, 0x0000056c },
+   { 0x0080000c, 0x24e0358d, 0x00b10420, 0x0000056c },
+   { 0x80800040, 0x468035b1, 0x00b104c0, 0x00000580 },
+   { 0x80800040, 0x46a035b1, 0x00b104e0, 0x00000580 },
+   { 0x00800041, 0x2400362c, 0x00d206c0, 0x000705a8 },
+   { 0x00800041, 0x2420362c, 0x00d206e0, 0x000705a8 },
+   { 0x00800048, 0x2400362c, 0x00d20480, 0x000705ac },
+   { 0x00800048, 0x2420362c, 0x00d204a0, 0x000705ac },
+   { 0x00800040, 0x2400358c, 0x00b10400, 0x0000056a },
+   { 0x00800040, 0x2420358c, 0x00b10420, 0x0000056a },
+   { 0x0080000c, 0x24c0358d, 0x00b10400, 0x0000056e },
+   { 0x0080000c, 0x24e0358d, 0x00b10420, 0x0000056e },
+   { 0x80800040, 0x46c035b1, 0x00b104c0, 0x00050582 },
+   { 0x80800040, 0x46e035b1, 0x00b104e0, 0x00050582 },
+   { 0x01800005, 0x20003d2c, 0x02000020, 0x00020002 },
+   { 0x80800040, 0xd00045b1, 0x00b19000, 0x00d20640 },
+   { 0x80800040, 0xd02045b1, 0x00b19020, 0x00d20660 },
+   { 0x80800040, 0xd04045b1, 0x00b19040, 0x00d20680 },
+   { 0x80800040, 0xd06045b1, 0x00b19060, 0x00d206a0 },
+   { 0x00000040, 0x22083d8c, 0x00000208, 0x00800080 },
+   { 0x80400040, 0xd40045b1, 0x00699400, 0x00ab06c0 },
+   { 0x80400040, 0xd48045b1, 0x00699480, 0x00ab06c2 },
+   { 0x80400040, 0xd42045b1, 0x00699420, 0x00ab06e0 },
+   { 0x80400040, 0xd4a045b1, 0x006994a0, 0x00ab06e2 },
+   { 0x80400040, 0xd41045b1, 0x00699410, 0x00ab06d0 },
+   { 0x80400040, 0xd49045b1, 0x00699490, 0x00ab06d2 },
+   { 0x80400040, 0xd43045b1, 0x00699430, 0x00ab06f0 },
+   { 0x80400040, 0xd4b045b1, 0x006994b0, 0x00ab06f2 },
+   { 0x00000040, 0x220a3d8c, 0x0000020a, 0x00080008 },
+   { 0x00110040, 0x220a3d8c, 0x0200020a, 0x00300030 },
+   { 0x01000010, 0x20003d2c, 0x02000020, 0x00060006 },
+   { 0x00000040, 0x20203d29, 0x00000020, 0x00020002 },
+   { 0x00000040, 0x22040c00, 0x00000204, 0x00100001 },
+   { 0x00000040, 0x220c358c, 0x0000020c, 0x0000003a },
+   { 0x00110220, 0x34001c00, 0x02001400, 0xfffffc1a },
+   { 0x00000001, 0x220001ec, 0x00000000, 0x01400140 },
+   { 0x00000001, 0x220201ec, 0x00000000, 0x01c001c0 },
+   { 0x00800401, 0x20400236, 0x01ee8000, 0x00000000 },
+   { 0x00800801, 0x20500236, 0x01ee8010, 0x00000000 },
+   { 0x00800401, 0x20600236, 0x01ee8020, 0x00000000 },
+   { 0x00800801, 0x20700236, 0x01ee8030, 0x00000000 },
+   { 0x00800401, 0x20800236, 0x01ee8040, 0x00000000 },
+   { 0x00800801, 0x20900236, 0x01ee8050, 0x00000000 },
+   { 0x00800401, 0x20a00236, 0x01ee8060, 0x00000000 },
+   { 0x00800801, 0x20b00236, 0x01ee8070, 0x00000000 },
+   { 0x00800401, 0x20c00236, 0x01ee8100, 0x00000000 },
+   { 0x00800801, 0x20d00236, 0x01ee8110, 0x00000000 },
+   { 0x00800401, 0x20e00236, 0x01ee8120, 0x00000000 },
+   { 0x00800801, 0x20f00236, 0x01ee8130, 0x00000000 },
+   { 0x00800401, 0x21000236, 0x01ee8140, 0x00000000 },
+   { 0x00800801, 0x21100236, 0x01ee8150, 0x00000000 },
+   { 0x00800401, 0x21200236, 0x01ee8160, 0x00000000 },
+   { 0x00800801, 0x21300236, 0x01ee8170, 0x00000000 },
+   { 0x00000040, 0x22000d20, 0x00000062, 0x1218a000 },
+   { 0x00200401, 0x204001a5, 0x00450064, 0x00000000 },
+   { 0x00000801, 0x20480061, 0x00000000, 0x000f000f },
+   { 0x01600031, 0x21400021, 0x508d0040, 0x00000200 },
+   { 0x00000001, 0x220001ec, 0x00000000, 0x03400340 },
+   { 0x00800401, 0x41600236, 0x00d28000, 0x00000000 },
+   { 0x00800801, 0x41610236, 0x00d28080, 0x00000000 },
+   { 0x00800401, 0x41800236, 0x00d28020, 0x00000000 },
+   { 0x00800801, 0x41810236, 0x00d280a0, 0x00000000 },
+   { 0x00800401, 0x41a00236, 0x00d28040, 0x00000000 },
+   { 0x00800801, 0x41a10236, 0x00d280c0, 0x00000000 },
+   { 0x00800401, 0x41c00236, 0x00d28060, 0x00000000 },
+   { 0x00800801, 0x41c10236, 0x00d280e0, 0x00000000 },
+   { 0x00000040, 0x22000d20, 0x00000062, 0x0a18a001 },
+   { 0x0000040c, 0x20443ca5, 0x00000044, 0x00010001 },
+   { 0x00000801, 0x20480061, 0x00000000, 0x0007000f },
+   { 0x0a600031, 0x21600021, 0x508d0040, 0x00000200 },
+   { 0x00000001, 0x21400021, 0x00000140, 0x00000000 },
+   { 0x00000001, 0x21600021, 0x00000160, 0x00000000 },
+   { 0x01600031, 0x20001c20, 0x708d0000, 0x82000010 },
+   { 0x00000000, 0x00000000, 0x00000000, 0x00000000 },
+   { 0x01000005, 0x20602d29, 0x02000042, 0x00070007 },
+   { 0x01000005, 0x20422d29, 0x00000042, 0xfff8fff8 },
+   { 0x00000001, 0x202001e9, 0x00000000, 0x100c100c },
+   { 0x00600001, 0x27e00021, 0x008d0000, 0x00000000 },
+   { 0x00000009, 0x27e82d21, 0x00000040, 0x00060006 },
+   { 0x00600001, 0x20a00022, 0x008d0000, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x00000100 },
+   { 0x00600001, 0x20200022, 0x008d07e0, 0x00000000 },
+   { 0x01800031, 0x20801d09, 0x408d0000, 0x02488400 },
+   { 0x00600001, 0x20400022, 0x008d07e0, 0x00000000 },
+   { 0x00000040, 0x20480c22, 0x000007e8, 0x00000080 },
+   { 0x02800031, 0x21001d09, 0x408d0000, 0x02488400 },
+   { 0x00600001, 0x20600022, 0x008d07e0, 0x00000000 },
+   { 0x00000040, 0x20680c22, 0x000007e8, 0x00000100 },
+   { 0x03800031, 0x21801d09, 0x408d0000, 0x02488400 },
+   { 0x00600001, 0x20800022, 0x008d07e0, 0x00000000 },
+   { 0x00000040, 0x20880c22, 0x000007e8, 0x00000180 },
+   { 0x04800031, 0x22001d09, 0x408d0000, 0x02488400 },
+   { 0x02600005, 0x20000c20, 0x02000090, 0x00002000 },
+   { 0x00000006, 0x20880c21, 0x00000088, 0x00200000 },
+   { 0x00200009, 0x20845529, 0x0000009c, 0x00450020 },
+   { 0x00200001, 0x40840231, 0x00450094, 0x00000000 },
+   { 0x00310001, 0x20840229, 0x02450094, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x02001400, 0x0000000c },
+   { 0x00800041, 0x24002628, 0x00000095, 0x00000044 },
+   { 0x00800040, 0x24004508, 0x008d0400, 0x00000094 },
+   { 0x00000009, 0x20a82d02, 0x00000404, 0x00060006 },
+   { 0x00802001, 0x20c00022, 0x008d0080, 0x00000000 },
+   { 0x00802001, 0x20800061, 0x00000000, 0x00000000 },
+   { 0x05800031, 0x20001d0c, 0x508d0000, 0x06080300 },
+   { 0x02600005, 0x20000c20, 0x020000d0, 0x00002000 },
+   { 0x00000006, 0x20c80c21, 0x000000c8, 0x00200000 },
+   { 0x00200009, 0x20c45529, 0x000000dc, 0x00450020 },
+   { 0x00200001, 0x40c40231, 0x004500d4, 0x00000000 },
+   { 0x00310001, 0x20c40229, 0x024500d4, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x02001400, 0x0000000c },
+   { 0x00800041, 0x24002628, 0x000000d5, 0x00000044 },
+   { 0x00800040, 0x24004508, 0x008d0400, 0x000000d4 },
+   { 0x00000009, 0x20a82d02, 0x00000404, 0x00060006 },
+   { 0x00802001, 0x20c00022, 0x008d00c0, 0x00000000 },
+   { 0x00802001, 0x20c00061, 0x00000000, 0x00000000 },
+   { 0x05800031, 0x20001d0c, 0x508d0000, 0x06080300 },
+   { 0x02600005, 0x20000c20, 0x02000110, 0x00002000 },
+   { 0x00000006, 0x21080c21, 0x00000108, 0x00200000 },
+   { 0x00200009, 0x21045529, 0x0000011c, 0x00450020 },
+   { 0x00200001, 0x41040231, 0x00450114, 0x00000000 },
+   { 0x00310001, 0x21040229, 0x02450114, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x02001400, 0x0000000c },
+   { 0x00800041, 0x24002628, 0x00000115, 0x00000044 },
+   { 0x00800040, 0x24004508, 0x008d0400, 0x00000114 },
+   { 0x00000009, 0x20a82d02, 0x00000404, 0x00060006 },
+   { 0x00802001, 0x20c00022, 0x008d0100, 0x00000000 },
+   { 0x00802001, 0x21000061, 0x00000000, 0x00000000 },
+   { 0x05800031, 0x20001d0c, 0x508d0000, 0x06080300 },
+   { 0x02600005, 0x20000c20, 0x02000150, 0x00002000 },
+   { 0x00000006, 0x21480c21, 0x00000148, 0x00200000 },
+   { 0x00200009, 0x21445529, 0x0000015c, 0x00450020 },
+   { 0x00200001, 0x41440231, 0x00450154, 0x00000000 },
+   { 0x00310001, 0x21440229, 0x02450154, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x02001400, 0x0000000c },
+   { 0x00800041, 0x24002628, 0x00000155, 0x00000044 },
+   { 0x00800040, 0x24004508, 0x008d0400, 0x00000154 },
+   { 0x00000009, 0x20a82d02, 0x00000404, 0x00060006 },
+   { 0x00802001, 0x20c00022, 0x008d0140, 0x00000000 },
+   { 0x00802001, 0x21400061, 0x00000000, 0x00000000 },
+   { 0x05800031, 0x20001d0c, 0x508d0000, 0x06080300 },
+   { 0x02600005, 0x20000c20, 0x02000190, 0x00002000 },
+   { 0x00000006, 0x21880c21, 0x00000188, 0x00200000 },
+   { 0x00200009, 0x21845529, 0x0000019c, 0x00450020 },
+   { 0x00200001, 0x41840231, 0x00450194, 0x00000000 },
+   { 0x00310001, 0x21840229, 0x02450194, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x02001400, 0x0000000c },
+   { 0x00800041, 0x24002628, 0x00000195, 0x00000044 },
+   { 0x00800040, 0x24004508, 0x008d0400, 0x00000194 },
+   { 0x00000009, 0x20a82d02, 0x00000404, 0x00060006 },
+   { 0x00802001, 0x20c00022, 0x008d0180, 0x00000000 },
+   { 0x00802001, 0x21800061, 0x00000000, 0x00000000 },
+   { 0x05800031, 0x20001d0c, 0x508d0000, 0x06080300 },
+   { 0x02600005, 0x20000c20, 0x020001d0, 0x00002000 },
+   { 0x00000006, 0x21c80c21, 0x000001c8, 0x00200000 },
+   { 0x00200009, 0x21c45529, 0x000001dc, 0x00450020 },
+   { 0x00200001, 0x41c40231, 0x004501d4, 0x00000000 },
+   { 0x00310001, 0x21c40229, 0x024501d4, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x02001400, 0x0000000c },
+   { 0x00800041, 0x24002628, 0x000001d5, 0x00000044 },
+   { 0x00800040, 0x24004508, 0x008d0400, 0x000001d4 },
+   { 0x00000009, 0x20a82d02, 0x00000404, 0x00060006 },
+   { 0x00802001, 0x20c00022, 0x008d01c0, 0x00000000 },
+   { 0x00802001, 0x21c00061, 0x00000000, 0x00000000 },
+   { 0x05800031, 0x20001d0c, 0x508d0000, 0x06080300 },
+   { 0x02600005, 0x20000c20, 0x02000210, 0x00002000 },
+   { 0x00000006, 0x22080c21, 0x00000208, 0x00200000 },
+   { 0x00200009, 0x22045529, 0x0000021c, 0x00450020 },
+   { 0x00200001, 0x42040231, 0x00450214, 0x00000000 },
+   { 0x00310001, 0x22040229, 0x02450214, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x02001400, 0x0000000c },
+   { 0x00800041, 0x24002628, 0x00000215, 0x00000044 },
+   { 0x00800040, 0x24004508, 0x008d0400, 0x00000214 },
+   { 0x00000009, 0x20a82d02, 0x00000404, 0x00060006 },
+   { 0x00802001, 0x20c00022, 0x008d0200, 0x00000000 },
+   { 0x00802001, 0x22000061, 0x00000000, 0x00000000 },
+   { 0x05800031, 0x20001d0c, 0x508d0000, 0x06080300 },
+   { 0x02600005, 0x20000c20, 0x02000250, 0x00002000 },
+   { 0x00000006, 0x22480c21, 0x00000248, 0x00200000 },
+   { 0x00200009, 0x22445529, 0x0000025c, 0x00450020 },
+   { 0x00200001, 0x42440231, 0x00450254, 0x00000000 },
+   { 0x00310001, 0x22440229, 0x02450254, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x02001400, 0x0000000c },
+   { 0x00800041, 0x24002628, 0x00000255, 0x00000044 },
+   { 0x00800040, 0x24004508, 0x008d0400, 0x00000254 },
+   { 0x00000009, 0x20a82d02, 0x00000404, 0x00060006 },
+   { 0x00802001, 0x20c00022, 0x008d0240, 0x00000000 },
+   { 0x00802001, 0x22400061, 0x00000000, 0x00000000 },
+   { 0x05800031, 0x20001d0c, 0x508d0000, 0x06080300 },
+   { 0x01000040, 0x20423dad, 0x00000042, 0xfff8fff8 },
+   { 0x00600001, 0x21600022, 0x008d07e0, 0x00000000 },
+   { 0x00802001, 0x21800022, 0x008d0080, 0x00000000 },
+   { 0x00802001, 0x21c00022, 0x008d00c0, 0x00000000 },
+   { 0x0b800031, 0x20001d0c, 0x508d0000, 0x0a080400 },
+   { 0x00600001, 0x20200022, 0x008d07e0, 0x00000000 },
+   { 0x00000040, 0x20280c22, 0x000007e8, 0x00000080 },
+   { 0x00802001, 0x20400022, 0x008d0100, 0x00000000 },
+   { 0x00802001, 0x20800022, 0x008d0140, 0x00000000 },
+   { 0x01800031, 0x20001d0c, 0x508d0000, 0x0a080400 },
+   { 0x00000040, 0x21680c22, 0x000007e8, 0x00000100 },
+   { 0x00802001, 0x21800022, 0x008d0180, 0x00000000 },
+   { 0x00802001, 0x21c00022, 0x008d01c0, 0x00000000 },
+   { 0x0b800031, 0x20001d0c, 0x508d0000, 0x0a080400 },
+   { 0x00000040, 0x20280c22, 0x000007e8, 0x00000180 },
+   { 0x00802001, 0x20400022, 0x008d0200, 0x00000000 },
+   { 0x00802001, 0x20800022, 0x008d0240, 0x00000000 },
+   { 0x01800031, 0x20001d0c, 0x508d0000, 0x0a080400 },
+   { 0x00000040, 0x27e80c21, 0x000007e8, 0x00000200 },
+   { 0x01000010, 0x20002da0, 0x02000060, 0x00000000 },
+   { 0x00110220, 0x34001c00, 0x00001400, 0xffffff00 },
+   { 0x00010220, 0x34001c00, 0x02001400, 0x00000040 },
+   { 0x00600001, 0x20200022, 0x008d07e0, 0x00000000 },
+   { 0x01800031, 0x20801d09, 0x408d0000, 0x02488400 },
+   { 0x00600001, 0x20400022, 0x008d07e0, 0x00000000 },
+   { 0x00000040, 0x20480c22, 0x000007e8, 0x00000080 },
+   { 0x02800031, 0x21001d09, 0x408d0000, 0x02488400 },
+   { 0x00600001, 0x20600022, 0x008d07e0, 0x00000000 },
+   { 0x00000040, 0x20680c22, 0x000007e8, 0x00000100 },
+   { 0x03800031, 0x21801d09, 0x408d0000, 0x02488400 },
+   { 0x00600001, 0x20800022, 0x008d07e0, 0x00000000 },
+   { 0x00000040, 0x20880c22, 0x000007e8, 0x00000180 },
+   { 0x04800031, 0x22001d09, 0x408d0000, 0x02488400 },
+   { 0x00000001, 0x220400e0, 0x00000000, 0x00a00080 },
+   { 0x00600001, 0x20a00022, 0x008d0000, 0x00000000 },
+   { 0x02600005, 0x20000c20, 0x02008810, 0x00002000 },
+   { 0x01000040, 0x20603dad, 0x00000060, 0xffffffff },
+   { 0x00000006, 0xa8080c21, 0x00008808, 0x00200000 },
+   { 0x00200009, 0xa8045529, 0x0000881c, 0x00450020 },
+   { 0x00200001, 0xc8040231, 0x00458814, 0x00000000 },
+   { 0x00310001, 0xa8040229, 0x02458814, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x02001400, 0x0000000c },
+   { 0x00800041, 0x24002628, 0x00008815, 0x00000044 },
+   { 0x00800040, 0x24004508, 0x008d0400, 0x00008814 },
+   { 0x00000009, 0x20a82d02, 0x00000404, 0x00060006 },
+   { 0x00802001, 0x20c00022, 0x008d8800, 0x00000000 },
+   { 0x00802001, 0xa8000061, 0x00000000, 0x00000000 },
+   { 0x05800031, 0x20001d0c, 0x508d0000, 0x06080300 },
+   { 0x00600001, 0x21600022, 0x008d07e0, 0x00000000 },
+   { 0x00802001, 0x21800022, 0x008d8800, 0x00000000 },
+   { 0x0b800031, 0x20001d0c, 0x508d0000, 0x06080300 },
+   { 0x00000040, 0x27e80c21, 0x000007e8, 0x00000040 },
+   { 0x00000040, 0x22040c00, 0x00000204, 0x00400040 },
+   { 0x00110220, 0x34001c00, 0x00001400, 0xffffffda },
+   { 0x01600031, 0x20001c20, 0x708d0000, 0x82000010 },
+   { 0x00000000, 0x00000000, 0x00000000, 0x00000000 },
+   { 0x00000000, 0x00000000, 0x00000000, 0x00000000 },
+   { 0x00000000, 0x00000000, 0x00000000, 0x00000000 },
+   { 0x01000005, 0x20602d29, 0x02000042, 0x00070007 },
+   { 0x01000005, 0x20422d29, 0x00000042, 0xfff8fff8 },
+   { 0x00600001, 0x27e00021, 0x008d0000, 0x00000000 },
+   { 0x00000009, 0x27e82d21, 0x00000040, 0x00060006 },
+   { 0x00600001, 0x20a00022, 0x008d0000, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x00000260 },
+   { 0x00600001, 0x20200022, 0x008d07e0, 0x00000000 },
+   { 0x01800031, 0x20801d09, 0x408d0000, 0x02488400 },
+   { 0x00600001, 0x20400022, 0x008d07e0, 0x00000000 },
+   { 0x00000040, 0x20480c22, 0x000007e8, 0x00000080 },
+   { 0x02800031, 0x21001d09, 0x408d0000, 0x02488400 },
+   { 0x00600001, 0x20600022, 0x008d07e0, 0x00000000 },
+   { 0x00000040, 0x20680c22, 0x000007e8, 0x00000100 },
+   { 0x03800031, 0x21801d09, 0x408d0000, 0x02488400 },
+   { 0x00600001, 0x20800022, 0x008d07e0, 0x00000000 },
+   { 0x00000040, 0x20880c22, 0x000007e8, 0x00000180 },
+   { 0x04800031, 0x22001d09, 0x408d0000, 0x02488400 },
+   { 0x00200001, 0x20640229, 0x00450094, 0x00000000 },
+   { 0x02600005, 0x20000c20, 0x02000090, 0x01000000 },
+   { 0x02600005, 0x20000c20, 0x00000090, 0x00004000 },
+   { 0x00600041, 0x24003e2c, 0x00000095, 0x00020002 },
+   { 0x00110001, 0x2066018d, 0x02000400, 0x00000000 },
+   { 0x00010040, 0x20663d8d, 0x02000400, 0x00010001 },
+   { 0x00110001, 0x2066022d, 0x00000095, 0x00000000 },
+   { 0x02600005, 0x20000c20, 0x00000090, 0x00002000 },
+   { 0x02600005, 0x20001d20, 0x02000066, 0x00000001 },
+   { 0x00000006, 0x20881c21, 0x00000088, 0x00200000 },
+   { 0x00200001, 0x20840129, 0x00450064, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x0000000e },
+   { 0x00800041, 0x24002528, 0x00000066, 0x00000044 },
+   { 0x00800040, 0x24002508, 0x008d0400, 0x00000064 },
+   { 0x00000009, 0x20a82d02, 0x00000404, 0x00060006 },
+   { 0x00802001, 0x20c00022, 0x008d0080, 0x00000000 },
+   { 0x00802001, 0x20800061, 0x00000000, 0x00000000 },
+   { 0x05800031, 0x20001d0c, 0x508d0000, 0x06080300 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x0000001e },
+   { 0x02600005, 0x20000c20, 0x00000090, 0x00004000 },
+   { 0x00210002, 0x20700421, 0x02450038, 0x00450030 },
+   { 0x00000001, 0x20680129, 0x0000009c, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x0000000e },
+   { 0x02600005, 0x20001d20, 0x0000009c, 0x00000010 },
+   { 0x00210002, 0x20700421, 0x02450028, 0x00450020 },
+   { 0x01600005, 0x20001d20, 0x0200009c, 0x00000001 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x00000006 },
+   { 0x02610005, 0x20001c20, 0x02000090, 0x00008000 },
+   { 0x02610005, 0x20001d20, 0x0200009c, 0x00000010 },
+   { 0x00010006, 0x20681d29, 0x0200009c, 0x00000010 },
+   { 0x02800005, 0x2000452c, 0x02000068, 0x000d0070 },
+   { 0x00000009, 0x20843d09, 0x00000602, 0x000c000c },
+   { 0x00000005, 0x20862d09, 0x00000602, 0xf000f000 },
+   { 0x00200001, 0x40840231, 0x00660064, 0x00000000 },
+   { 0x00200001, 0x20640229, 0x004500d4, 0x00000000 },
+   { 0x02600005, 0x20000c20, 0x020000d0, 0x01000000 },
+   { 0x02600005, 0x20000c20, 0x000000d0, 0x00004000 },
+   { 0x00600041, 0x24003e2c, 0x000000d5, 0x00020002 },
+   { 0x00110001, 0x2066018d, 0x02000400, 0x00000000 },
+   { 0x00010040, 0x20663d8d, 0x02000400, 0x00010001 },
+   { 0x00110001, 0x2066022d, 0x000000d5, 0x00000000 },
+   { 0x02600005, 0x20000c20, 0x000000d0, 0x00002000 },
+   { 0x02600005, 0x20001d20, 0x02000066, 0x00000001 },
+   { 0x00000006, 0x20c81c21, 0x000000c8, 0x00200000 },
+   { 0x00200001, 0x20c40129, 0x00450064, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x0000000e },
+   { 0x00800041, 0x24002528, 0x00000066, 0x00000044 },
+   { 0x00800040, 0x24002508, 0x008d0400, 0x00000064 },
+   { 0x00000009, 0x20a82d02, 0x00000404, 0x00060006 },
+   { 0x00802001, 0x20c00022, 0x008d00c0, 0x00000000 },
+   { 0x00802001, 0x20c00061, 0x00000000, 0x00000000 },
+   { 0x05800031, 0x20001d0c, 0x508d0000, 0x06080300 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x0000001e },
+   { 0x02600005, 0x20000c20, 0x000000d0, 0x00004000 },
+   { 0x00210002, 0x20700421, 0x02450038, 0x00450030 },
+   { 0x00000001, 0x20680129, 0x000000dc, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x0000000e },
+   { 0x02600005, 0x20001d20, 0x000000dc, 0x00000010 },
+   { 0x00210002, 0x20700421, 0x02450028, 0x00450020 },
+   { 0x01600005, 0x20001d20, 0x020000dc, 0x00000001 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x00000006 },
+   { 0x02610005, 0x20001c20, 0x020000d0, 0x00008000 },
+   { 0x02610005, 0x20001d20, 0x020000dc, 0x00000010 },
+   { 0x00010006, 0x20681d29, 0x020000dc, 0x00000010 },
+   { 0x02800005, 0x2000452c, 0x02000068, 0x000d0070 },
+   { 0x00000009, 0x20c43d09, 0x00000602, 0x000c000c },
+   { 0x00000005, 0x20c62d09, 0x00000602, 0xf000f000 },
+   { 0x00200001, 0x40c40231, 0x00660064, 0x00000000 },
+   { 0x00200001, 0x20640229, 0x00450114, 0x00000000 },
+   { 0x02600005, 0x20000c20, 0x02000110, 0x01000000 },
+   { 0x02600005, 0x20000c20, 0x00000110, 0x00004000 },
+   { 0x00600041, 0x24003e2c, 0x00000115, 0x00020002 },
+   { 0x00110001, 0x2066018d, 0x02000400, 0x00000000 },
+   { 0x00010040, 0x20663d8d, 0x02000400, 0x00010001 },
+   { 0x00110001, 0x2066022d, 0x00000115, 0x00000000 },
+   { 0x02600005, 0x20000c20, 0x00000110, 0x00002000 },
+   { 0x02600005, 0x20001d20, 0x02000066, 0x00000001 },
+   { 0x00000006, 0x21081c21, 0x00000108, 0x00200000 },
+   { 0x00200001, 0x21040129, 0x00450064, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x0000000e },
+   { 0x00800041, 0x24002528, 0x00000066, 0x00000044 },
+   { 0x00800040, 0x24002508, 0x008d0400, 0x00000064 },
+   { 0x00000009, 0x20a82d02, 0x00000404, 0x00060006 },
+   { 0x00802001, 0x20c00022, 0x008d0100, 0x00000000 },
+   { 0x00802001, 0x21000061, 0x00000000, 0x00000000 },
+   { 0x05800031, 0x20001d0c, 0x508d0000, 0x06080300 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x0000001e },
+   { 0x02600005, 0x20000c20, 0x00000110, 0x00004000 },
+   { 0x00210002, 0x20700421, 0x02450038, 0x00450030 },
+   { 0x00000001, 0x20680129, 0x0000011c, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x0000000e },
+   { 0x02600005, 0x20001d20, 0x0000011c, 0x00000010 },
+   { 0x00210002, 0x20700421, 0x02450028, 0x00450020 },
+   { 0x01600005, 0x20001d20, 0x0200011c, 0x00000001 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x00000006 },
+   { 0x02610005, 0x20001c20, 0x02000110, 0x00008000 },
+   { 0x02610005, 0x20001d20, 0x0200011c, 0x00000010 },
+   { 0x00010006, 0x20681d29, 0x0200011c, 0x00000010 },
+   { 0x02800005, 0x2000452c, 0x02000068, 0x000d0070 },
+   { 0x00000009, 0x21043d09, 0x00000602, 0x000c000c },
+   { 0x00000005, 0x21062d09, 0x00000602, 0xf000f000 },
+   { 0x00200001, 0x41040231, 0x00660064, 0x00000000 },
+   { 0x00200001, 0x20640229, 0x00450154, 0x00000000 },
+   { 0x02600005, 0x20000c20, 0x02000150, 0x01000000 },
+   { 0x02600005, 0x20000c20, 0x00000150, 0x00004000 },
+   { 0x00600041, 0x24003e2c, 0x00000155, 0x00020002 },
+   { 0x00110001, 0x2066018d, 0x02000400, 0x00000000 },
+   { 0x00010040, 0x20663d8d, 0x02000400, 0x00010001 },
+   { 0x00110001, 0x2066022d, 0x00000155, 0x00000000 },
+   { 0x02600005, 0x20000c20, 0x00000150, 0x00002000 },
+   { 0x02600005, 0x20001d20, 0x02000066, 0x00000001 },
+   { 0x00000006, 0x21481c21, 0x00000148, 0x00200000 },
+   { 0x00200001, 0x21440129, 0x00450064, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x0000000e },
+   { 0x00800041, 0x24002528, 0x00000066, 0x00000044 },
+   { 0x00800040, 0x24002508, 0x008d0400, 0x00000064 },
+   { 0x00000009, 0x20a82d02, 0x00000404, 0x00060006 },
+   { 0x00802001, 0x20c00022, 0x008d0140, 0x00000000 },
+   { 0x00802001, 0x21400061, 0x00000000, 0x00000000 },
+   { 0x05800031, 0x20001d0c, 0x508d0000, 0x06080300 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x0000001e },
+   { 0x02600005, 0x20000c20, 0x00000150, 0x00004000 },
+   { 0x00210002, 0x20700421, 0x02450038, 0x00450030 },
+   { 0x00000001, 0x20680129, 0x0000015c, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x0000000e },
+   { 0x02600005, 0x20001d20, 0x0000015c, 0x00000010 },
+   { 0x00210002, 0x20700421, 0x02450028, 0x00450020 },
+   { 0x01600005, 0x20001d20, 0x0200015c, 0x00000001 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x00000006 },
+   { 0x02610005, 0x20001c20, 0x02000150, 0x00008000 },
+   { 0x02610005, 0x20001d20, 0x0200015c, 0x00000010 },
+   { 0x00010006, 0x20681d29, 0x0200015c, 0x00000010 },
+   { 0x02800005, 0x2000452c, 0x02000068, 0x000d0070 },
+   { 0x00000009, 0x21443d09, 0x00000602, 0x000c000c },
+   { 0x00000005, 0x21462d09, 0x00000602, 0xf000f000 },
+   { 0x00200001, 0x41440231, 0x00660064, 0x00000000 },
+   { 0x00200001, 0x20640229, 0x00450194, 0x00000000 },
+   { 0x02600005, 0x20000c20, 0x02000190, 0x01000000 },
+   { 0x02600005, 0x20000c20, 0x00000190, 0x00004000 },
+   { 0x00600041, 0x24003e2c, 0x00000195, 0x00020002 },
+   { 0x00110001, 0x2066018d, 0x02000400, 0x00000000 },
+   { 0x00010040, 0x20663d8d, 0x02000400, 0x00010001 },
+   { 0x00110001, 0x2066022d, 0x00000195, 0x00000000 },
+   { 0x02600005, 0x20000c20, 0x00000190, 0x00002000 },
+   { 0x02600005, 0x20001d20, 0x02000066, 0x00000001 },
+   { 0x00000006, 0x21881c21, 0x00000188, 0x00200000 },
+   { 0x00200001, 0x21840129, 0x00450064, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x0000000e },
+   { 0x00800041, 0x24002528, 0x00000066, 0x00000044 },
+   { 0x00800040, 0x24002508, 0x008d0400, 0x00000064 },
+   { 0x00000009, 0x20a82d02, 0x00000404, 0x00060006 },
+   { 0x00802001, 0x20c00022, 0x008d0180, 0x00000000 },
+   { 0x00802001, 0x21800061, 0x00000000, 0x00000000 },
+   { 0x05800031, 0x20001d0c, 0x508d0000, 0x06080300 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x0000001e },
+   { 0x02600005, 0x20000c20, 0x00000190, 0x00004000 },
+   { 0x00210002, 0x20700421, 0x02450038, 0x00450030 },
+   { 0x00000001, 0x20680129, 0x0000019c, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x0000000e },
+   { 0x02600005, 0x20001d20, 0x0000019c, 0x00000010 },
+   { 0x00210002, 0x20700421, 0x02450028, 0x00450020 },
+   { 0x01600005, 0x20001d20, 0x0200019c, 0x00000001 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x00000006 },
+   { 0x02610005, 0x20001c20, 0x02000190, 0x00008000 },
+   { 0x02610005, 0x20001d20, 0x0200019c, 0x00000010 },
+   { 0x00010006, 0x20681d29, 0x0200019c, 0x00000010 },
+   { 0x02800005, 0x2000452c, 0x02000068, 0x000d0070 },
+   { 0x00000009, 0x21843d09, 0x00000602, 0x000c000c },
+   { 0x00000005, 0x21862d09, 0x00000602, 0xf000f000 },
+   { 0x00200001, 0x41840231, 0x00660064, 0x00000000 },
+   { 0x00200001, 0x20640229, 0x004501d4, 0x00000000 },
+   { 0x02600005, 0x20000c20, 0x020001d0, 0x01000000 },
+   { 0x02600005, 0x20000c20, 0x000001d0, 0x00004000 },
+   { 0x00600041, 0x24003e2c, 0x000001d5, 0x00020002 },
+   { 0x00110001, 0x2066018d, 0x02000400, 0x00000000 },
+   { 0x00010040, 0x20663d8d, 0x02000400, 0x00010001 },
+   { 0x00110001, 0x2066022d, 0x000001d5, 0x00000000 },
+   { 0x02600005, 0x20000c20, 0x000001d0, 0x00002000 },
+   { 0x02600005, 0x20001d20, 0x02000066, 0x00000001 },
+   { 0x00000006, 0x21c81c21, 0x000001c8, 0x00200000 },
+   { 0x00200001, 0x21c40129, 0x00450064, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x0000000e },
+   { 0x00800041, 0x24002528, 0x00000066, 0x00000044 },
+   { 0x00800040, 0x24002508, 0x008d0400, 0x00000064 },
+   { 0x00000009, 0x20a82d02, 0x00000404, 0x00060006 },
+   { 0x00802001, 0x20c00022, 0x008d01c0, 0x00000000 },
+   { 0x00802001, 0x21c00061, 0x00000000, 0x00000000 },
+   { 0x05800031, 0x20001d0c, 0x508d0000, 0x06080300 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x0000001e },
+   { 0x02600005, 0x20000c20, 0x000001d0, 0x00004000 },
+   { 0x00210002, 0x20700421, 0x02450038, 0x00450030 },
+   { 0x00000001, 0x20680129, 0x000001dc, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x0000000e },
+   { 0x02600005, 0x20001d20, 0x000001dc, 0x00000010 },
+   { 0x00210002, 0x20700421, 0x02450028, 0x00450020 },
+   { 0x01600005, 0x20001d20, 0x020001dc, 0x00000001 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x00000006 },
+   { 0x02610005, 0x20001c20, 0x020001d0, 0x00008000 },
+   { 0x02610005, 0x20001d20, 0x020001dc, 0x00000010 },
+   { 0x00010006, 0x20681d29, 0x020001dc, 0x00000010 },
+   { 0x02800005, 0x2000452c, 0x02000068, 0x000d0070 },
+   { 0x00000009, 0x21c43d09, 0x00000602, 0x000c000c },
+   { 0x00000005, 0x21c62d09, 0x00000602, 0xf000f000 },
+   { 0x00200001, 0x41c40231, 0x00660064, 0x00000000 },
+   { 0x00200001, 0x20640229, 0x00450214, 0x00000000 },
+   { 0x02600005, 0x20000c20, 0x02000210, 0x01000000 },
+   { 0x02600005, 0x20000c20, 0x00000210, 0x00004000 },
+   { 0x00600041, 0x24003e2c, 0x00000215, 0x00020002 },
+   { 0x00110001, 0x2066018d, 0x02000400, 0x00000000 },
+   { 0x00010040, 0x20663d8d, 0x02000400, 0x00010001 },
+   { 0x00110001, 0x2066022d, 0x00000215, 0x00000000 },
+   { 0x02600005, 0x20000c20, 0x00000210, 0x00002000 },
+   { 0x02600005, 0x20001d20, 0x02000066, 0x00000001 },
+   { 0x00000006, 0x22081c21, 0x00000208, 0x00200000 },
+   { 0x00200001, 0x22040129, 0x00450064, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x0000000e },
+   { 0x00800041, 0x24002528, 0x00000066, 0x00000044 },
+   { 0x00800040, 0x24002508, 0x008d0400, 0x00000064 },
+   { 0x00000009, 0x20a82d02, 0x00000404, 0x00060006 },
+   { 0x00802001, 0x20c00022, 0x008d0200, 0x00000000 },
+   { 0x00802001, 0x22000061, 0x00000000, 0x00000000 },
+   { 0x05800031, 0x20001d0c, 0x508d0000, 0x06080300 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x0000001e },
+   { 0x02600005, 0x20000c20, 0x00000210, 0x00004000 },
+   { 0x00210002, 0x20700421, 0x02450038, 0x00450030 },
+   { 0x00000001, 0x20680129, 0x0000021c, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x0000000e },
+   { 0x02600005, 0x20001d20, 0x0000021c, 0x00000010 },
+   { 0x00210002, 0x20700421, 0x02450028, 0x00450020 },
+   { 0x01600005, 0x20001d20, 0x0200021c, 0x00000001 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x00000006 },
+   { 0x02610005, 0x20001c20, 0x02000210, 0x00008000 },
+   { 0x02610005, 0x20001d20, 0x0200021c, 0x00000010 },
+   { 0x00010006, 0x20681d29, 0x0200021c, 0x00000010 },
+   { 0x02800005, 0x2000452c, 0x02000068, 0x000d0070 },
+   { 0x00000009, 0x22043d09, 0x00000602, 0x000c000c },
+   { 0x00000005, 0x22062d09, 0x00000602, 0xf000f000 },
+   { 0x00200001, 0x42040231, 0x00660064, 0x00000000 },
+   { 0x00200001, 0x20640229, 0x00450254, 0x00000000 },
+   { 0x02600005, 0x20000c20, 0x02000250, 0x01000000 },
+   { 0x02600005, 0x20000c20, 0x00000250, 0x00004000 },
+   { 0x00600041, 0x24003e2c, 0x00000255, 0x00020002 },
+   { 0x00110001, 0x2066018d, 0x02000400, 0x00000000 },
+   { 0x00010040, 0x20663d8d, 0x02000400, 0x00010001 },
+   { 0x00110001, 0x2066022d, 0x00000255, 0x00000000 },
+   { 0x02600005, 0x20000c20, 0x00000250, 0x00002000 },
+   { 0x02600005, 0x20001d20, 0x02000066, 0x00000001 },
+   { 0x00000006, 0x22481c21, 0x00000248, 0x00200000 },
+   { 0x00200001, 0x22440129, 0x00450064, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x0000000e },
+   { 0x00800041, 0x24002528, 0x00000066, 0x00000044 },
+   { 0x00800040, 0x24002508, 0x008d0400, 0x00000064 },
+   { 0x00000009, 0x20a82d02, 0x00000404, 0x00060006 },
+   { 0x00802001, 0x20c00022, 0x008d0240, 0x00000000 },
+   { 0x00802001, 0x22400061, 0x00000000, 0x00000000 },
+   { 0x05800031, 0x20001d0c, 0x508d0000, 0x06080300 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x0000001e },
+   { 0x02600005, 0x20000c20, 0x00000250, 0x00004000 },
+   { 0x00210002, 0x20700421, 0x02450038, 0x00450030 },
+   { 0x00000001, 0x20680129, 0x0000025c, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x0000000e },
+   { 0x02600005, 0x20001d20, 0x0000025c, 0x00000010 },
+   { 0x00210002, 0x20700421, 0x02450028, 0x00450020 },
+   { 0x01600005, 0x20001d20, 0x0200025c, 0x00000001 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x00000006 },
+   { 0x02610005, 0x20001c20, 0x02000250, 0x00008000 },
+   { 0x02610005, 0x20001d20, 0x0200025c, 0x00000010 },
+   { 0x00010006, 0x20681d29, 0x0200025c, 0x00000010 },
+   { 0x02800005, 0x2000452c, 0x02000068, 0x000d0070 },
+   { 0x00000009, 0x22443d09, 0x00000602, 0x000c000c },
+   { 0x00000005, 0x22462d09, 0x00000602, 0xf000f000 },
+   { 0x00200001, 0x42440231, 0x00660064, 0x00000000 },
+   { 0x01000040, 0x20423dad, 0x00000042, 0xfff8fff8 },
+   { 0x00600001, 0x21600022, 0x008d07e0, 0x00000000 },
+   { 0x00802001, 0x21800022, 0x008d0080, 0x00000000 },
+   { 0x00802001, 0x21c00022, 0x008d00c0, 0x00000000 },
+   { 0x0b800031, 0x20001d0c, 0x508d0000, 0x0a080400 },
+   { 0x00600001, 0x20200022, 0x008d07e0, 0x00000000 },
+   { 0x00000040, 0x20280c22, 0x000007e8, 0x00000080 },
+   { 0x00802001, 0x20400022, 0x008d0100, 0x00000000 },
+   { 0x00802001, 0x20800022, 0x008d0140, 0x00000000 },
+   { 0x01800031, 0x20001d0c, 0x508d0000, 0x0a080400 },
+   { 0x00000040, 0x21680c22, 0x000007e8, 0x00000100 },
+   { 0x00802001, 0x21800022, 0x008d0180, 0x00000000 },
+   { 0x00802001, 0x21c00022, 0x008d01c0, 0x00000000 },
+   { 0x0b800031, 0x20001d0c, 0x508d0000, 0x0a080400 },
+   { 0x00000040, 0x20280c22, 0x000007e8, 0x00000180 },
+   { 0x00802001, 0x20400022, 0x008d0200, 0x00000000 },
+   { 0x00802001, 0x20800022, 0x008d0240, 0x00000000 },
+   { 0x01800031, 0x20001d0c, 0x508d0000, 0x0a080400 },
+   { 0x00000040, 0x27e80c21, 0x000007e8, 0x00000200 },
+   { 0x01000010, 0x20002da0, 0x02000060, 0x00000000 },
+   { 0x00110220, 0x34001c00, 0x00001400, 0xfffffda0 },
+   { 0x00010220, 0x34001c00, 0x02001400, 0x0000006e },
+   { 0x00600001, 0x20200022, 0x008d07e0, 0x00000000 },
+   { 0x01800031, 0x20801d09, 0x408d0000, 0x02488400 },
+   { 0x00600001, 0x20400022, 0x008d07e0, 0x00000000 },
+   { 0x00000040, 0x20480c22, 0x000007e8, 0x00000080 },
+   { 0x02800031, 0x21001d09, 0x408d0000, 0x02488400 },
+   { 0x00600001, 0x20600022, 0x008d07e0, 0x00000000 },
+   { 0x00000040, 0x20680c22, 0x000007e8, 0x00000100 },
+   { 0x03800031, 0x21801d09, 0x408d0000, 0x02488400 },
+   { 0x00600001, 0x20800022, 0x008d07e0, 0x00000000 },
+   { 0x00000040, 0x20880c22, 0x000007e8, 0x00000180 },
+   { 0x04800031, 0x22001d09, 0x408d0000, 0x02488400 },
+   { 0x00000001, 0x220400e0, 0x00000000, 0x00a00080 },
+   { 0x00600001, 0x20a00022, 0x008d0000, 0x00000000 },
+   { 0x00200001, 0x20640229, 0x00458814, 0x00000000 },
+   { 0x02600005, 0x20000c20, 0x02008810, 0x01000000 },
+   { 0x02600005, 0x20000c20, 0x00008810, 0x00004000 },
+   { 0x00600041, 0x24003e2c, 0x00008815, 0x00020002 },
+   { 0x00110001, 0x2066018d, 0x02000400, 0x00000000 },
+   { 0x00010040, 0x20663d8d, 0x02000400, 0x00010001 },
+   { 0x00110001, 0x2066022d, 0x00008815, 0x00000000 },
+   { 0x02600005, 0x20000c20, 0x00008810, 0x00002000 },
+   { 0x01000040, 0x20603dad, 0x02000060, 0xffffffff },
+   { 0x00000006, 0xa8080c21, 0x00008808, 0x00200000 },
+   { 0x00200001, 0xa8040129, 0x00450064, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x0000000e },
+   { 0x00800041, 0x24002528, 0x00000066, 0x00000044 },
+   { 0x00800040, 0x24002508, 0x008d0400, 0x00000064 },
+   { 0x00000009, 0x20a82d02, 0x00000404, 0x00060006 },
+   { 0x00802001, 0x20c00022, 0x008d8800, 0x00000000 },
+   { 0x00802001, 0xa8000061, 0x00000000, 0x00000000 },
+   { 0x05800031, 0x20001d0c, 0x508d0000, 0x06080300 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x00000022 },
+   { 0x02600005, 0x20000d20, 0x02000066, 0x00000001 },
+   { 0x02600005, 0x20000c20, 0x00008810, 0x00004000 },
+   { 0x00000001, 0x20680129, 0x0000881c, 0x00000000 },
+   { 0x00210002, 0x20700421, 0x02450038, 0x00450030 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x0000000e },
+   { 0x02600005, 0x20001d20, 0x0000881c, 0x00000010 },
+   { 0x00210002, 0x20700421, 0x02450028, 0x00450020 },
+   { 0x01600005, 0x20001d20, 0x0200881c, 0x00000001 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x00000006 },
+   { 0x02610005, 0x20001c20, 0x02008810, 0x00008000 },
+   { 0x02610005, 0x20001d20, 0x0200881c, 0x00000010 },
+   { 0x00010006, 0x20681d29, 0x0200881c, 0x00000010 },
+   { 0x02800005, 0x2000452c, 0x00000068, 0x000d0070 },
+   { 0x01000040, 0x20603dad, 0x02000060, 0x00000000 },
+   { 0x00000009, 0xa8043d09, 0x00000600, 0x000c000c },
+   { 0x00000005, 0xa8062d09, 0x00000600, 0xf000f000 },
+   { 0x00200001, 0xc8040231, 0x00660064, 0x00000000 },
+   { 0x00600001, 0x21600022, 0x008d07e0, 0x00000000 },
+   { 0x00802001, 0x21800022, 0x008d8800, 0x00000000 },
+   { 0x0b800031, 0x20001d0c, 0x508d0000, 0x06080300 },
+   { 0x00000040, 0x27e80c21, 0x000007e8, 0x00000040 },
+   { 0x00000040, 0x22040c00, 0x00000204, 0x00400040 },
+   { 0x00110220, 0x34001c00, 0x02001400, 0xffffffac },
+   { 0x01600031, 0x20001c20, 0x708d0000, 0x82000010 },
+   { 0x01600031, 0x20001c20, 0x708d0000, 0x82000010 },
+   { 0x01600031, 0x20001c20, 0x708d0000, 0x82000010 },
+   { 0x0000007e, 0x00000000, 0x00000000, 0x00000000 },
diff --git a/i965_drv_video/shaders/h264/mc/avc_mc.g4b.gen5 b/i965_drv_video/shaders/h264/mc/avc_mc.g4b.gen5
new file mode 100644
index 0000000..5a91f32
--- /dev/null
+++ b/i965_drv_video/shaders/h264/mc/avc_mc.g4b.gen5
@@ -0,0 +1,2938 @@
+   { 0x00600001, 0x27c00021, 0x008d0000, 0x00000000 },
+   { 0x00200009, 0x27fa3e29, 0x00450064, 0x00040004 },
+   { 0x00000040, 0x27e01c01, 0x00001400, 0x00000020 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x000000d4 },
+   { 0x00000005, 0x220e3e2c, 0x00000070, 0x000f000f },
+   { 0x00000001, 0x26a00221, 0x00009c38, 0x00000000 },
+   { 0x00000220, 0x34001400, 0x00001400, 0x000006a0 },
+   { 0x00a02001, 0x24000229, 0x00b10624, 0x00000000 },
+   { 0x00a02001, 0x24400229, 0x00b10624, 0x00000000 },
+   { 0x00a02001, 0x24800229, 0x00b10624, 0x00000000 },
+   { 0x00a02001, 0x24c00229, 0x00b10624, 0x00000000 },
+   { 0x00a02001, 0x25000229, 0x00b10624, 0x00000000 },
+   { 0x00a02001, 0x25400229, 0x00b10624, 0x00000000 },
+   { 0x00a02001, 0x25800229, 0x00b10624, 0x00000000 },
+   { 0x00a02001, 0x25c00229, 0x00b10624, 0x00000000 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x00000086 },
+   { 0x00000001, 0x22080060, 0x00000000, 0x06440640 },
+   { 0x00a02001, 0x24000229, 0x00009003, 0x00000000 },
+   { 0x00a02001, 0x24400229, 0x0000900b, 0x00000000 },
+   { 0x00a02001, 0x24800229, 0x00009013, 0x00000000 },
+   { 0x00a02001, 0x24c00229, 0x0000901b, 0x00000000 },
+   { 0x00a02001, 0x25000229, 0x00009023, 0x00000000 },
+   { 0x00a02001, 0x25400229, 0x0000902b, 0x00000000 },
+   { 0x00a02001, 0x25800229, 0x00009033, 0x00000000 },
+   { 0x00a02001, 0x25c00229, 0x0000903b, 0x00000000 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x00000072 },
+   { 0x02600005, 0x20000c20, 0x0000006c, 0x00000002 },
+   { 0x00600005, 0x24000c20, 0x0000006c, 0x00000011 },
+   { 0x01600007, 0x20000c00, 0x028d0400, 0x00000011 },
+   { 0x00780001, 0x26240169, 0x00000000, 0x80808080 },
+   { 0x00780001, 0x66430231, 0x028d0624, 0x00000000 },
+   { 0x00780001, 0x66630231, 0x028d062c, 0x00000000 },
+   { 0x00780001, 0x26240231, 0x00cf0643, 0x00000000 },
+   { 0x00780001, 0x262c0231, 0x00cf0663, 0x00000000 },
+   { 0x00800040, 0x25e04629, 0x00cf0643, 0x00b10624 },
+   { 0x00600040, 0x25e02529, 0x008d05e0, 0x008d05f0 },
+   { 0x00400040, 0x25e02529, 0x006905e0, 0x006905e8 },
+   { 0x00200040, 0x25e02529, 0x004505e0, 0x004505e4 },
+   { 0x00a02040, 0x2400252c, 0x000005e0, 0x000005e2 },
+   { 0x00a02040, 0x24003d8c, 0x00b10400, 0x00100010 },
+   { 0x00a02008, 0x24003d89, 0x00b10400, 0x00050005 },
+   { 0x00a02008, 0x24403d89, 0x00b10400, 0x00050005 },
+   { 0x00a02008, 0x24803d89, 0x00b10400, 0x00050005 },
+   { 0x00a02008, 0x24c03d89, 0x00b10400, 0x00050005 },
+   { 0x00a02008, 0x25003d89, 0x00b10400, 0x00050005 },
+   { 0x00a02008, 0x25403d89, 0x00b10400, 0x00050005 },
+   { 0x00a02008, 0x25803d89, 0x00b10400, 0x00050005 },
+   { 0x00a02008, 0x25c03d89, 0x00b10400, 0x00050005 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x00000044 },
+   { 0x00600041, 0x26806e2d, 0x008d062c, 0x89abcdef },
+   { 0x00600041, 0x26906e2d, 0x008d0623, 0xfedcba98 },
+   { 0x00600041, 0x26a06e2d, 0x00cf0663, 0x89abcdef },
+   { 0x00600041, 0x26b06e2d, 0x00cf0643, 0x0fedcba9 },
+   { 0x00000041, 0x26be3e2d, 0x00000623, 0xfff8fff8 },
+   { 0x00802040, 0x268035ad, 0x008d4680, 0x008d0690 },
+   { 0x00802040, 0x268035ad, 0x008d0680, 0x008d0688 },
+   { 0x00802040, 0x268035ad, 0x008d0680, 0x008d0684 },
+   { 0x00802040, 0x268035ad, 0x008d0680, 0x008d0682 },
+   { 0x00800001, 0x240001ec, 0x00000000, 0x00200020 },
+   { 0x00200048, 0x24003dac, 0x00a00680, 0x00050005 },
+   { 0x00200008, 0x26e03d8d, 0x00450400, 0x00060006 },
+   { 0x00800001, 0x240001ec, 0x00000000, 0x00100010 },
+   { 0x00800048, 0x24003e2c, 0x00000633, 0x00100010 },
+   { 0x00800048, 0x26c03e2d, 0x0000067f, 0x00100010 },
+   { 0x00800048, 0x272055ad, 0x000006e0, 0x00b10040 },
+   { 0x00600041, 0x268055ad, 0x000006e2, 0x00ae0040 },
+   { 0x00600041, 0x26a055ad, 0x000006e2, 0x00ae0041 },
+   { 0x00a02040, 0x240035ac, 0x00b10720, 0x00b00680 },
+   { 0x80a02008, 0x44003d91, 0x00b10400, 0x00050005 },
+   { 0x00a02040, 0x240035ac, 0x00b10720, 0x00b00682 },
+   { 0x80a02008, 0x44403d91, 0x00b10400, 0x00050005 },
+   { 0x00a02040, 0x240035ac, 0x00b10720, 0x00b00684 },
+   { 0x80a02008, 0x44803d91, 0x00b10400, 0x00050005 },
+   { 0x00a02040, 0x240035ac, 0x00b10720, 0x00b00686 },
+   { 0x80a02008, 0x44c03d91, 0x00b10400, 0x00050005 },
+   { 0x00a02040, 0x240035ac, 0x00b10720, 0x00b00688 },
+   { 0x80a02008, 0x45003d91, 0x00b10400, 0x00050005 },
+   { 0x00a02040, 0x240035ac, 0x00b10720, 0x00b0068a },
+   { 0x80a02008, 0x45403d91, 0x00b10400, 0x00050005 },
+   { 0x00a02040, 0x240035ac, 0x00b10720, 0x00b0068c },
+   { 0x80a02008, 0x45803d91, 0x00b10400, 0x00050005 },
+   { 0x00a02040, 0x240035ac, 0x00b10720, 0x00b0068e },
+   { 0x80a02008, 0x45c03d91, 0x00b10400, 0x00050005 },
+   { 0x00000001, 0x22040060, 0x00000000, 0x00900080 },
+   { 0x01000005, 0x20000c20, 0x02000068, 0x00003c00 },
+   { 0x00010220, 0x34001c00, 0x02001400, 0x00000020 },
+   { 0x80802040, 0x440045b1, 0x008d8800, 0x00ae0400 },
+   { 0x80802040, 0x444045b1, 0x008d8820, 0x00ae0440 },
+   { 0x80802040, 0x448045b1, 0x008d8840, 0x00ae0480 },
+   { 0x80802040, 0x44c045b1, 0x008d8860, 0x00ae04c0 },
+   { 0x80802040, 0x441045b1, 0x008d8880, 0x00ae0410 },
+   { 0x80802040, 0x445045b1, 0x008d88a0, 0x00ae0450 },
+   { 0x80802040, 0x449045b1, 0x008d88c0, 0x00ae0490 },
+   { 0x80802040, 0x44d045b1, 0x008d88e0, 0x00ae04d0 },
+   { 0x80802040, 0x450045b1, 0x008d8900, 0x00ae0500 },
+   { 0x80802040, 0x454045b1, 0x008d8920, 0x00ae0540 },
+   { 0x80802040, 0x458045b1, 0x008d8940, 0x00ae0580 },
+   { 0x80802040, 0x45c045b1, 0x008d8960, 0x00ae05c0 },
+   { 0x80802040, 0x451045b1, 0x008d8980, 0x00ae0510 },
+   { 0x80802040, 0x455045b1, 0x008d89a0, 0x00ae0550 },
+   { 0x80802040, 0x459045b1, 0x008d89c0, 0x00ae0590 },
+   { 0x80802040, 0x45d045b1, 0x008d89e0, 0x00ae05d0 },
+   { 0x00000040, 0x22040c00, 0x00000204, 0x01800180 },
+   { 0x00000040, 0x27e01c01, 0x00001400, 0x00000020 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x000000e2 },
+   { 0x00000040, 0x27e01c01, 0x00001400, 0x00000020 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x00000018 },
+   { 0x00000001, 0x27800021, 0x00000780, 0x00000000 },
+   { 0x00000001, 0x27a00021, 0x000007a0, 0x00000000 },
+   { 0x01600031, 0x20001c20, 0x708d0000, 0x82000010 },
+   { 0x00200440, 0x27c055a5, 0x004507fa, 0x0045002a },
+   { 0x00000801, 0x27c80061, 0x00000000, 0x0000001b },
+   { 0x00000040, 0x22000d20, 0x00000062, 0x02186000 },
+   { 0x01600031, 0x26200021, 0x408d07c0, 0x00000200 },
+   { 0x00000440, 0x27c43ca5, 0x000007c4, 0x00010001 },
+   { 0x00000801, 0x27c80061, 0x00000000, 0x000f0003 },
+   { 0x00000040, 0x22000c00, 0x00000200, 0x00100000 },
+   { 0x02600031, 0x26400021, 0x408d07c0, 0x00000200 },
+   { 0x00000001, 0x34000020, 0x000007e0, 0x00000000 },
+   { 0x00000008, 0x27fc3dad, 0x000007fc, 0x00010001 },
+   { 0x00200440, 0x27c055a5, 0x004507fa, 0x0045002a },
+   { 0x00000801, 0x27c80061, 0x00000000, 0x00000013 },
+   { 0x00000040, 0x22000c00, 0x00000200, 0xefffc001 },
+   { 0x01600031, 0x26200021, 0x408d07c0, 0x00000200 },
+   { 0x00000440, 0x27c43ca5, 0x000007c4, 0x00010001 },
+   { 0x00000801, 0x27c80061, 0x00000000, 0x00070003 },
+   { 0x05600031, 0x26400021, 0x408d07c0, 0x00000200 },
+   { 0x00000008, 0x220e3e2c, 0x0000006c, 0x00060006 },
+   { 0x00000001, 0x26a002a5, 0x00009c3c, 0x00000000 },
+   { 0x00000220, 0x34001400, 0x00001400, 0x000006a0 },
+   { 0x02600005, 0x20000c20, 0x0000006c, 0x00000002 },
+   { 0x00780001, 0x26240169, 0x00000000, 0x80808080 },
+   { 0x02400005, 0x20000c20, 0x0200006c, 0x00000001 },
+   { 0x00560001, 0x46420129, 0x02690624, 0x00000000 },
+   { 0x02400005, 0x20000c20, 0x0200006c, 0x00000010 },
+   { 0x00560001, 0x46520129, 0x0269062c, 0x00000000 },
+   { 0x00780001, 0x26240129, 0x00ae0642, 0x00000000 },
+   { 0x00800040, 0x24004629, 0x00b10624, 0x00650642 },
+   { 0x00600040, 0x24002529, 0x00650400, 0x00650404 },
+   { 0x00600040, 0x25202529, 0x00050400, 0x00050404 },
+   { 0x00600040, 0x25702529, 0x00050408, 0x0005040c },
+   { 0x00560001, 0x26240169, 0x00000000, 0x80808080 },
+   { 0x00460001, 0x26240129, 0x028a0652, 0x00000000 },
+   { 0x00560001, 0x46520129, 0x02690624, 0x00000000 },
+   { 0x02400005, 0x20000c20, 0x0200006c, 0x00000001 },
+   { 0x00560001, 0x46420169, 0x02000000, 0x80808080 },
+   { 0x00460001, 0x46420129, 0x0069062c, 0x00000000 },
+   { 0x00560001, 0x262c0129, 0x008a0642, 0x00000000 },
+   { 0x00600040, 0x24004629, 0x008d0624, 0x00650652 },
+   { 0x00600040, 0x24104629, 0x00650642, 0x008d062c },
+   { 0x00600040, 0x24002529, 0x00650400, 0x00650404 },
+   { 0x00600040, 0x25302529, 0x00050408, 0x0005040c },
+   { 0x00600040, 0x25602529, 0x00050400, 0x00050404 },
+   { 0x00a02040, 0x24003d2c, 0x00b10520, 0x00040004 },
+   { 0x00a02008, 0x24003d89, 0x00b10400, 0x00030003 },
+   { 0x00a02008, 0x24403d89, 0x00b10400, 0x00030003 },
+   { 0x00a02040, 0x24003d2c, 0x00b10560, 0x00040004 },
+   { 0x00a02008, 0x24803d89, 0x00b10400, 0x00030003 },
+   { 0x00a02008, 0x24c03d89, 0x00b10400, 0x00030003 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x00000048 },
+   { 0x00000001, 0x22080060, 0x00000000, 0x06440640 },
+   { 0x00a02001, 0x24000229, 0x00059002, 0x00000000 },
+   { 0x00a02001, 0x24400229, 0x0005900a, 0x00000000 },
+   { 0x00a02001, 0x24800229, 0x00059012, 0x00000000 },
+   { 0x00a02001, 0x24c00229, 0x0005901a, 0x00000000 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x0000003c },
+   { 0x00a02001, 0x24000229, 0x00b10624, 0x00000000 },
+   { 0x00a02001, 0x24400229, 0x00b10624, 0x00000000 },
+   { 0x00a02001, 0x24800229, 0x00b10624, 0x00000000 },
+   { 0x00a02001, 0x24c00229, 0x00b10624, 0x00000000 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x00000032 },
+   { 0x00600041, 0x26806e2d, 0x008d062c, 0x44332211 },
+   { 0x00600041, 0x26906e2d, 0x008d0622, 0xffeeddcc },
+   { 0x00600041, 0x26a06e2d, 0x00650652, 0x44332211 },
+   { 0x00600041, 0x26b06e2d, 0x00650642, 0x00ffeedd },
+   { 0x00200041, 0x26bc3e2d, 0x00450622, 0xfffcfffc },
+   { 0x00802040, 0x268035ad, 0x008d0680, 0x008d0690 },
+   { 0x00802040, 0x268035ad, 0x008d0680, 0x008d0688 },
+   { 0x00802040, 0x268035ad, 0x008d0680, 0x008d0684 },
+   { 0x00800001, 0x240001ec, 0x00000000, 0x00200020 },
+   { 0x00400048, 0x24003dac, 0x00a50680, 0x00220022 },
+   { 0x00400008, 0x26e03d8d, 0x00690400, 0x00060006 },
+   { 0x00800001, 0x240001ec, 0x00000000, 0x00100010 },
+   { 0x00800048, 0x24003e2c, 0x00050632, 0x00100010 },
+   { 0x00800048, 0x26c03e2d, 0x0005065e, 0x00100010 },
+   { 0x00800048, 0x272055ad, 0x000506e0, 0x00240044 },
+   { 0x00600041, 0x268055ad, 0x000506e4, 0x00440044 },
+   { 0x00600041, 0x26a055ad, 0x000506e4, 0x00440045 },
+   { 0x00a02040, 0x240035ac, 0x00b10720, 0x00050680 },
+   { 0x80a02008, 0x44003d91, 0x00b10400, 0x00050005 },
+   { 0x00a02040, 0x240035ac, 0x00b10720, 0x00050684 },
+   { 0x80a02008, 0x44403d91, 0x00b10400, 0x00050005 },
+   { 0x00a02040, 0x240035ac, 0x00b10720, 0x00050688 },
+   { 0x80a02008, 0x44803d91, 0x00b10400, 0x00050005 },
+   { 0x00a02040, 0x240035ac, 0x00b10720, 0x0005068c },
+   { 0x80a02008, 0x44c03d91, 0x00b10400, 0x00050005 },
+   { 0x00000040, 0x22063d8c, 0x00000204, 0x00100010 },
+   { 0x80802040, 0x640045b1, 0x008d8880, 0x00cf0400 },
+   { 0x80802040, 0x644045b1, 0x008d88a0, 0x00cf0440 },
+   { 0x80802040, 0x648045b1, 0x008d88c0, 0x00cf0480 },
+   { 0x80802040, 0x64c045b1, 0x008d88e0, 0x00cf04c0 },
+   { 0x80802040, 0x640245b1, 0x008d8900, 0x00cf0402 },
+   { 0x80802040, 0x644245b1, 0x008d8920, 0x00cf0442 },
+   { 0x80802040, 0x648245b1, 0x008d8940, 0x00cf0482 },
+   { 0x80802040, 0x64c245b1, 0x008d8960, 0x00cf04c2 },
+   { 0x00000401, 0x27c80061, 0x00000000, 0x0007000f },
+   { 0x00200801, 0x27c001a1, 0x004507fa, 0x00000000 },
+   { 0x00000040, 0x22000c00, 0x00000200, 0x08004000 },
+   { 0x00800001, 0x20400232, 0x00d20400, 0x00000000 },
+   { 0x00800001, 0x20500232, 0x00d20420, 0x00000000 },
+   { 0x00800001, 0x20600232, 0x00d20440, 0x00000000 },
+   { 0x00800001, 0x20700232, 0x00d20460, 0x00000000 },
+   { 0x00800001, 0x20800232, 0x00d20480, 0x00000000 },
+   { 0x00800001, 0x20900232, 0x00d204a0, 0x00000000 },
+   { 0x00800001, 0x20a00232, 0x00d204c0, 0x00000000 },
+   { 0x00800001, 0x20b00232, 0x00d204e0, 0x00000000 },
+   { 0x01600031, 0x27a00021, 0x508d07c0, 0x00000200 },
+   { 0x00000001, 0x34000020, 0x000007e0, 0x00000000 },
+   { 0x00000401, 0x27c80061, 0x00000000, 0x000f000f },
+   { 0x00200801, 0x27c001a1, 0x004507fa, 0x00000000 },
+   { 0x00000040, 0x22000c00, 0x00000200, 0x0ff04000 },
+   { 0x00000001, 0x22080060, 0x00000000, 0x04400400 },
+   { 0x00a02001, 0x20400232, 0x00d29000, 0x00000000 },
+   { 0x00a02001, 0x20500232, 0x00d29020, 0x00000000 },
+   { 0x00a02001, 0x20800232, 0x00d29080, 0x00000000 },
+   { 0x00a02001, 0x20900232, 0x00d290a0, 0x00000000 },
+   { 0x00a02001, 0x20c00232, 0x00d29100, 0x00000000 },
+   { 0x00a02001, 0x20d00232, 0x00d29120, 0x00000000 },
+   { 0x00a02001, 0x21000232, 0x00d29180, 0x00000000 },
+   { 0x00a02001, 0x21100232, 0x00d291a0, 0x00000000 },
+   { 0x01600031, 0x27800021, 0x508d07c0, 0x00000200 },
+   { 0x00000001, 0x34000020, 0x000007e0, 0x00000000 },
+   { 0x00600001, 0x27c00021, 0x008d0000, 0x00000000 },
+   { 0x00200009, 0x27fa3e29, 0x00450064, 0x00040004 },
+   { 0x00000040, 0x27e01c01, 0x00001400, 0x00000020 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0xffffff04 },
+   { 0x00000001, 0x220401ec, 0x00000000, 0x00800080 },
+   { 0x00000001, 0x22080060, 0x00000000, 0x04100400 },
+   { 0x00200008, 0x27006e2d, 0x0000006c, 0x00000040 },
+   { 0x00400001, 0x27400061, 0x00000000, 0x00000000 },
+   { 0x00800001, 0x272001a9, 0x00b10620, 0x00000000 },
+   { 0x02600005, 0x20001c20, 0x0000006c, 0x00000008 },
+   { 0x00110001, 0x27230231, 0x00000624, 0x00000000 },
+   { 0x00600001, 0x27420231, 0x00cf0643, 0x00000000 },
+   { 0x00110001, 0x27410231, 0x00000643, 0x00000000 },
+   { 0x00240001, 0x27400231, 0x00000623, 0x00000000 },
+   { 0x02000005, 0x20001c20, 0x0200006c, 0x00000002 },
+   { 0x00010001, 0x27400231, 0x02000624, 0x00000000 },
+   { 0x02000005, 0x20001c20, 0x0200006c, 0x00000001 },
+   { 0x00110001, 0x27420231, 0x02000623, 0x00000000 },
+   { 0x00000005, 0x26803e2d, 0x00000070, 0x000f000f },
+   { 0x00000001, 0x270801ad, 0x00000700, 0x00000000 },
+   { 0x00000040, 0x27e01c01, 0x00001400, 0x00000020 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x00000084 },
+   { 0x00000040, 0x22043d8c, 0x00000204, 0x00800080 },
+   { 0x00800001, 0x27200231, 0x00b10628, 0x00000000 },
+   { 0x02600005, 0x20001c20, 0x0200006c, 0x00000004 },
+   { 0x00680001, 0x272c0231, 0x028d0634, 0x00000000 },
+   { 0x00780001, 0x272c0231, 0x02000633, 0x00000000 },
+   { 0x00400001, 0x27420231, 0x00a0040e, 0x00000000 },
+   { 0x00400001, 0x27460231, 0x00a0044e, 0x00000000 },
+   { 0x00200001, 0x27400231, 0x0000062b, 0x00000000 },
+   { 0x02000005, 0x20001c20, 0x0200006c, 0x00000002 },
+   { 0x00010001, 0x27400231, 0x0200062c, 0x00000000 },
+   { 0x00110001, 0x27410231, 0x0200040e, 0x00000000 },
+   { 0x00000008, 0x26803e2d, 0x00000070, 0x00040004 },
+   { 0x00200040, 0x22083d8c, 0x00450208, 0x00800080 },
+   { 0x00000006, 0x27083dad, 0x00000700, 0x00010001 },
+   { 0x00000040, 0x27e01c01, 0x00001400, 0x00000020 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x00000064 },
+   { 0x00000040, 0x22043d8c, 0x00000204, 0x00800080 },
+   { 0x00a02001, 0xb3800231, 0x00d20400, 0x00000000 },
+   { 0x00a02001, 0xb3a00231, 0x00d20480, 0x00000000 },
+   { 0x00a02001, 0xb3c00231, 0x00d20440, 0x00000000 },
+   { 0x00a02001, 0xb3e00231, 0x00d204c0, 0x00000000 },
+   { 0x02000005, 0x20001c20, 0x00000060, 0x00000002 },
+   { 0x01000005, 0x20001c20, 0x0200006c, 0x00000001 },
+   { 0x01010005, 0x20001c20, 0x00000060, 0x00004000 },
+   { 0x02010005, 0x20001c20, 0x02000060, 0x00000010 },
+   { 0x00030001, 0x27230231, 0x0000065f, 0x00000000 },
+   { 0x00030220, 0x34001c00, 0x00001400, 0x00000006 },
+   { 0x02600005, 0x20001c20, 0x0000006c, 0x00000001 },
+   { 0x00460001, 0x27200231, 0x0069065c, 0x00000000 },
+   { 0x00110001, 0x27230231, 0x00000458, 0x00000000 },
+   { 0x00600001, 0x27240231, 0x008d0458, 0x00000000 },
+   { 0x00600001, 0x272c0231, 0x008d0478, 0x00000000 },
+   { 0x00600001, 0x27420231, 0x00cf0663, 0x00000000 },
+   { 0x00000001, 0x27400231, 0x00000458, 0x00000000 },
+   { 0x00010001, 0x27410231, 0x0000065f, 0x00000000 },
+   { 0x00110001, 0x27410231, 0x00000663, 0x00000000 },
+   { 0x02000005, 0x20001c20, 0x0200006c, 0x00000010 },
+   { 0x00110001, 0x27420231, 0x0200065f, 0x00000000 },
+   { 0x00000005, 0x26803e2d, 0x00000071, 0x000f000f },
+   { 0x00000006, 0x27083dad, 0x00000702, 0x00020002 },
+   { 0x00000040, 0x27e01c01, 0x00001400, 0x00000020 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x00000030 },
+   { 0x00000040, 0x22043d8c, 0x00000204, 0x00800080 },
+   { 0x00400001, 0x27200231, 0x0069045c, 0x00000000 },
+   { 0x00600001, 0x27240231, 0x008d0478, 0x00000000 },
+   { 0x00800001, 0x272c0231, 0x0000047f, 0x00000000 },
+   { 0x00400001, 0x27420231, 0x00a0048e, 0x00000000 },
+   { 0x00400001, 0x27460231, 0x00a004ce, 0x00000000 },
+   { 0x00000001, 0x27400231, 0x00000478, 0x00000000 },
+   { 0x00000001, 0x27410231, 0x0000045f, 0x00000000 },
+   { 0x00000008, 0x26803e2d, 0x00000071, 0x00040004 },
+   { 0x00200040, 0x22083d8c, 0x00450208, 0x00800080 },
+   { 0x00000006, 0x27083dad, 0x00000700, 0x00030003 },
+   { 0x00000040, 0x27e01c01, 0x00001400, 0x00000020 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x00000016 },
+   { 0x00a02001, 0xb3800231, 0x00d20480, 0x00000000 },
+   { 0x00a02001, 0xb3a00231, 0x00d20500, 0x00000000 },
+   { 0x00a02001, 0xb3c00231, 0x00d204c0, 0x00000000 },
+   { 0x00a02001, 0xb3e00231, 0x00d20540, 0x00000000 },
+   { 0x00000040, 0x27e01c01, 0x00001400, 0x00000020 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x00000100 },
+   { 0x00000040, 0x27e01c01, 0x00001400, 0x00000020 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0xfffffe74 },
+   { 0x00000001, 0x27800021, 0x00000780, 0x00000000 },
+   { 0x00000001, 0x27a00021, 0x000007a0, 0x00000000 },
+   { 0x01600031, 0x20001c20, 0x708d0000, 0x82000010 },
+   { 0x00000001, 0x27340231, 0x00000733, 0x00000000 },
+   { 0x00600001, 0x274a0231, 0x00000749, 0x00000000 },
+   { 0x00800040, 0x24003e2c, 0x00b10723, 0x00020002 },
+   { 0x00800048, 0x24003e2c, 0x00b10724, 0x00020002 },
+   { 0x00800048, 0x24003e2c, 0x00b10725, 0x00010001 },
+   { 0x00800008, 0x26c03d8d, 0x008d0400, 0x00020002 },
+   { 0x00800040, 0x24003e2c, 0x00b10740, 0x00020002 },
+   { 0x00800048, 0x24003e2c, 0x00b10741, 0x00020002 },
+   { 0x00800048, 0x24003e2c, 0x00b10742, 0x00010001 },
+   { 0x00800008, 0x26a03d8d, 0x008d0400, 0x00020002 },
+   { 0x00800001, 0x27240231, 0x00d206c0, 0x00000000 },
+   { 0x00600001, 0x27400231, 0x00ae06a2, 0x00000000 },
+   { 0x00000001, 0x27230231, 0x000006a0, 0x00000000 },
+   { 0x00000005, 0x220e3dac, 0x00000680, 0x000f000f },
+   { 0x00000001, 0x26a00221, 0x00009c2c, 0x00000000 },
+   { 0x00000220, 0x34001400, 0x00001400, 0x000006a0 },
+   { 0x80800040, 0xd00045b1, 0x00b18800, 0x000d0724 },
+   { 0x80800040, 0xd02045b1, 0x00b18820, 0x000d0724 },
+   { 0x80800040, 0xd04045b1, 0x00b18840, 0x000d0724 },
+   { 0x80800040, 0xd06045b1, 0x00b18860, 0x000d0724 },
+   { 0x00000001, 0x34000020, 0x000007e0, 0x00000000 },
+   { 0x80800040, 0xd00045b1, 0x00b18800, 0x002c0740 },
+   { 0x80800040, 0xd02045b1, 0x00b18820, 0x002c0742 },
+   { 0x80800040, 0xd04045b1, 0x00b18840, 0x002c0744 },
+   { 0x80800040, 0xd06045b1, 0x00b18860, 0x002c0746 },
+   { 0x00000001, 0x34000020, 0x000007e0, 0x00000000 },
+   { 0x02800005, 0x20003da0, 0x00000708, 0x00020002 },
+   { 0x02600005, 0x20003da0, 0x02000708, 0x00010001 },
+   { 0x009a0001, 0x27200169, 0x00000000, 0x80808080 },
+   { 0x00780001, 0x27400231, 0x028d0724, 0x00000000 },
+   { 0x00780001, 0x27240231, 0x008d0740, 0x00000000 },
+   { 0x00600040, 0x25e04629, 0x008d0724, 0x008d0740 },
+   { 0x00400040, 0x25e02529, 0x006905e0, 0x006905e8 },
+   { 0x00200040, 0x25e02529, 0x004505e0, 0x004505e4 },
+   { 0x00800040, 0x2400252c, 0x000005e0, 0x000005e2 },
+   { 0x00800040, 0x24003d8c, 0x008d0400, 0x00080008 },
+   { 0x00800008, 0x26803d8d, 0x008d0400, 0x00040004 },
+   { 0x80800040, 0xd00035b1, 0x00b18800, 0x00b10680 },
+   { 0x80800040, 0xd02035b1, 0x00b18820, 0x00b10680 },
+   { 0x80800040, 0xd04035b1, 0x00b18840, 0x00b10680 },
+   { 0x80800040, 0xd06035b1, 0x00b18860, 0x00b10680 },
+   { 0x00000001, 0x34000020, 0x000007e0, 0x00000000 },
+   { 0x00600001, 0x27340231, 0x008d0733, 0x00000000 },
+   { 0x00800040, 0x24003e2c, 0x00b10726, 0x00020002 },
+   { 0x00800048, 0x24003e2c, 0x00b10725, 0x00020002 },
+   { 0x00800048, 0x24003e2c, 0x00b10724, 0x00010001 },
+   { 0x00800008, 0x26803d8d, 0x00b10400, 0x00020002 },
+   { 0x80800040, 0xd00035b1, 0x00b18800, 0x002d0680 },
+   { 0x80800040, 0xd02035b1, 0x00b18820, 0x002d0684 },
+   { 0x80800040, 0xd04035b1, 0x00b18840, 0x002d0688 },
+   { 0x80800040, 0xd06035b1, 0x00b18860, 0x002d068c },
+   { 0x00000001, 0x34000020, 0x000007e0, 0x00000000 },
+   { 0x00400009, 0x26c05421, 0x00000744, 0x00690050 },
+   { 0x00400009, 0x26d05421, 0x00000740, 0x00690050 },
+   { 0x00600001, 0x26a00231, 0x00cf06c3, 0x00000000 },
+   { 0x00800001, 0x26a80231, 0x00b10723, 0x00000000 },
+   { 0x00800040, 0x24003e2c, 0x00b106a2, 0x00020002 },
+   { 0x00800048, 0x24003e2c, 0x00b106a1, 0x00020002 },
+   { 0x00800048, 0x24003e2c, 0x00b106a0, 0x00010001 },
+   { 0x00800008, 0x26a03d8d, 0x00b10400, 0x00020002 },
+   { 0x00200040, 0x220c3eac, 0x00450056, 0x06a006a0 },
+   { 0x80800040, 0xd06035b1, 0x01ed9800, 0x00b18860 },
+   { 0x80800040, 0xd04035b1, 0x01ed9804, 0x00b18840 },
+   { 0x80800040, 0xd02035b1, 0x01ed9808, 0x00b18820 },
+   { 0x80800040, 0xd00035b1, 0x01ed980c, 0x00b18800 },
+   { 0x00000001, 0x34000020, 0x000007e0, 0x00000000 },
+   { 0x00400009, 0x26c05421, 0x00000744, 0x00690050 },
+   { 0x00400009, 0x26d05421, 0x00000740, 0x00690050 },
+   { 0x00600001, 0x26a00231, 0x00cf06c3, 0x00000000 },
+   { 0x00800001, 0x26a80231, 0x00b10723, 0x00000000 },
+   { 0x00800042, 0x25c04629, 0x00b106a8, 0x00b106a9 },
+   { 0x00800040, 0x24003e2c, 0x00b106a3, 0x00020002 },
+   { 0x00800048, 0x24003e2c, 0x00b106a2, 0x00020002 },
+   { 0x00800048, 0x24003e2c, 0x00b106a1, 0x00010001 },
+   { 0x00800008, 0x26c03d8d, 0x008d0400, 0x00020002 },
+   { 0x00600001, 0x26a00231, 0x00ae06c0, 0x00000000 },
+   { 0x00600001, 0x46a60231, 0x00ae06cc, 0x00000000 },
+   { 0x00600001, 0x46a70231, 0x00ae05c0, 0x00000000 },
+   { 0x00200040, 0x220c3eac, 0x00450036, 0x06a006a0 },
+   { 0x80800040, 0xd0603631, 0x01ee9800, 0x00b18860 },
+   { 0x80800040, 0xd0403631, 0x01ee9802, 0x00b18840 },
+   { 0x80800040, 0xd0203631, 0x01ee9804, 0x00b18820 },
+   { 0x80800040, 0xd0003631, 0x01ee9806, 0x00b18800 },
+   { 0x00000001, 0x34000020, 0x000007e0, 0x00000000 },
+   { 0x00400009, 0x26c05421, 0x00000744, 0x00690050 },
+   { 0x00400009, 0x26d05421, 0x00000740, 0x00690050 },
+   { 0x00600001, 0x26a00231, 0x00ab06c3, 0x00000000 },
+   { 0x00800001, 0x26a80231, 0x00b10723, 0x00000000 },
+   { 0x00800040, 0x24003e2c, 0x00b106a2, 0x00020002 },
+   { 0x00800048, 0x24003e2c, 0x00b106a1, 0x00020002 },
+   { 0x00800048, 0x24003e2c, 0x00b106a0, 0x00010001 },
+   { 0x00800008, 0x25c03d89, 0x008d0400, 0x00020002 },
+   { 0x00800042, 0x26a0462d, 0x00b106a0, 0x00b106a1 },
+   { 0x00600001, 0x46a10231, 0x00ae05c0, 0x00000000 },
+   { 0x00600001, 0x26b00231, 0x00ae05d0, 0x00000000 },
+   { 0x00200040, 0x220c3eac, 0x00450056, 0x06a006a0 },
+   { 0x80800040, 0xd0603631, 0x01ed9800, 0x00b18860 },
+   { 0x80800040, 0xd0403631, 0x01ed9804, 0x00b18840 },
+   { 0x80800040, 0xd0203631, 0x01ed9808, 0x00b18820 },
+   { 0x80800040, 0xd0003631, 0x01ed980c, 0x00b18800 },
+   { 0x00000001, 0x34000020, 0x000007e0, 0x00000000 },
+   { 0x00800042, 0x25c04629, 0x00b10724, 0x00b10725 },
+   { 0x00800040, 0x24003e2c, 0x00b10726, 0x00020002 },
+   { 0x00800048, 0x24003e2c, 0x00b10725, 0x00020002 },
+   { 0x00800048, 0x24003e2c, 0x00b10724, 0x00010001 },
+   { 0x00800008, 0x25e03d89, 0x00240400, 0x00020002 },
+   { 0x80800040, 0xd0003531, 0x00ad05c0, 0x00b18800 },
+   { 0x80800040, 0xd0203531, 0x00ad05c2, 0x00b18820 },
+   { 0x80800040, 0xd0403531, 0x00ad05c4, 0x00b18840 },
+   { 0x80800040, 0xd0603531, 0x00ad05c6, 0x00b18860 },
+   { 0x00000001, 0x34000020, 0x000007e0, 0x00000000 },
+   { 0x00600001, 0x27480231, 0x00000747, 0x00000000 },
+   { 0x00800042, 0x25c04629, 0x00b10740, 0x00b10741 },
+   { 0x00800040, 0x24003e2c, 0x00b10742, 0x00020002 },
+   { 0x00800048, 0x24003e2c, 0x00b10741, 0x00020002 },
+   { 0x00800048, 0x24003e2c, 0x00b10740, 0x00010001 },
+   { 0x00800008, 0x25e03d89, 0x00240400, 0x00020002 },
+   { 0x00800001, 0x45c10231, 0x00d205e0, 0x00000000 },
+   { 0x80800040, 0xd0003631, 0x004d05c0, 0x00b18800 },
+   { 0x80800040, 0xd0203631, 0x004d05c4, 0x00b18820 },
+   { 0x80800040, 0xd0403631, 0x004d05c8, 0x00b18840 },
+   { 0x80800040, 0xd0603631, 0x004d05cc, 0x00b18860 },
+   { 0x00000001, 0x34000020, 0x000007e0, 0x00000000 },
+   { 0x00000401, 0x27c80061, 0x00000000, 0x000f000f },
+   { 0x00200801, 0x27c001a1, 0x004507fa, 0x00000000 },
+   { 0x00000040, 0x22000c00, 0x00000200, 0x0ff04000 },
+   { 0x00800001, 0x20400232, 0x00cd0400, 0x00000000 },
+   { 0x00800001, 0x20500232, 0x00cd0408, 0x00000000 },
+   { 0x00800001, 0x20600232, 0x00cd0410, 0x00000000 },
+   { 0x00800001, 0x20700232, 0x00cd0418, 0x00000000 },
+   { 0x00800001, 0x20800232, 0x00cd0440, 0x00000000 },
+   { 0x00800001, 0x20900232, 0x00cd0448, 0x00000000 },
+   { 0x00800001, 0x20a00232, 0x00cd0450, 0x00000000 },
+   { 0x00800001, 0x20b00232, 0x00cd0458, 0x00000000 },
+   { 0x00800001, 0x20c00232, 0x00cd0480, 0x00000000 },
+   { 0x00800001, 0x20d00232, 0x00cd0488, 0x00000000 },
+   { 0x00800001, 0x20e00232, 0x00cd0490, 0x00000000 },
+   { 0x00800001, 0x20f00232, 0x00cd0498, 0x00000000 },
+   { 0x00800001, 0x21000232, 0x00cd04c0, 0x00000000 },
+   { 0x00800001, 0x21100232, 0x00cd04c8, 0x00000000 },
+   { 0x00800001, 0x21200232, 0x00cd04d0, 0x00000000 },
+   { 0x00800001, 0x21300232, 0x00cd04d8, 0x00000000 },
+   { 0x01600031, 0x27800021, 0x508d07c0, 0x00000200 },
+   { 0x00000001, 0x34000020, 0x000007e0, 0x00000000 },
+   { 0x00600001, 0x27c00021, 0x008d0000, 0x00000000 },
+   { 0x00200009, 0x27fa3e29, 0x00450064, 0x00040004 },
+   { 0x00000040, 0x27e01c01, 0x00001400, 0x00000020 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0xfffffd34 },
+   { 0x00000001, 0x220401ec, 0x00000000, 0x00800080 },
+   { 0x00000001, 0x220601ec, 0x00000000, 0x04000400 },
+   { 0x00200008, 0x27006e2d, 0x0000006c, 0x00000040 },
+   { 0x02600005, 0x20003e20, 0x0000006c, 0x00040004 },
+   { 0x00780001, 0x26340231, 0x00000633, 0x00000000 },
+   { 0x00800001, 0x27200231, 0x00b10620, 0x00000000 },
+   { 0x00600001, 0x27400231, 0x00cf0643, 0x00000000 },
+   { 0x00400008, 0x26806e2d, 0x00240070, 0x00004040 },
+   { 0x00000040, 0x27e01c01, 0x00001400, 0x00000020 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x0000006a },
+   { 0x00000040, 0x22043d8c, 0x00000204, 0x00800080 },
+   { 0x00000006, 0x27003dad, 0x00000700, 0x00010001 },
+   { 0x00800001, 0x27200231, 0x00b10628, 0x00000000 },
+   { 0x00400001, 0x27400231, 0x00808c26, 0x00000000 },
+   { 0x00400001, 0x27440231, 0x00808c66, 0x00000000 },
+   { 0x00400008, 0x26806e2d, 0x00240072, 0x00004040 },
+   { 0x00000040, 0x22063d8c, 0x00000206, 0x00800080 },
+   { 0x00000040, 0x27e01c01, 0x00001400, 0x00000020 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x00000058 },
+   { 0x00000040, 0x22043d8c, 0x00000204, 0x00800080 },
+   { 0x00000006, 0x27003dad, 0x00000702, 0x00020002 },
+   { 0x00800001, 0xaf800231, 0x00d28f80, 0x00000000 },
+   { 0x00800001, 0xaf900231, 0x00d28fa0, 0x00000000 },
+   { 0x00800001, 0xafc00231, 0x00d28fc0, 0x00000000 },
+   { 0x00800001, 0xafd00231, 0x00d28fe0, 0x00000000 },
+   { 0x00800001, 0xafa00231, 0x00d28c00, 0x00000000 },
+   { 0x00800001, 0xafb00231, 0x00d28c20, 0x00000000 },
+   { 0x00800001, 0xafe00231, 0x00d28c40, 0x00000000 },
+   { 0x00800001, 0xaff00231, 0x00d28c60, 0x00000000 },
+   { 0x00400001, 0x27200231, 0x0069065c, 0x00000000 },
+   { 0x00600001, 0x27240231, 0x00a98fcc, 0x00000000 },
+   { 0x00600001, 0x272c0231, 0x00a98fec, 0x00000000 },
+   { 0x00600001, 0x27340231, 0x00008fff, 0x00000000 },
+   { 0x00800001, 0x2620012d, 0x00b10720, 0x00000000 },
+   { 0x00600001, 0x27400231, 0x00cf0663, 0x00000000 },
+   { 0x00400008, 0x26806e2d, 0x00240074, 0x00004040 },
+   { 0x00000040, 0x27e01c01, 0x00001400, 0x00000020 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x00000032 },
+   { 0x00000040, 0x22043d8c, 0x00000204, 0x00800080 },
+   { 0x00000006, 0x27003dad, 0x00000700, 0x00010001 },
+   { 0x00800001, 0x27200231, 0x00b10628, 0x00000000 },
+   { 0x00600001, 0x27300231, 0x008d0638, 0x00000000 },
+   { 0x00400001, 0x27400231, 0x00808c26, 0x00000000 },
+   { 0x00400001, 0x27440231, 0x00808c66, 0x00000000 },
+   { 0x00400008, 0x26806e2d, 0x00240076, 0x00004040 },
+   { 0x00000040, 0x22063d8c, 0x00000206, 0x00800080 },
+   { 0x00000040, 0x27e01c01, 0x00001400, 0x00000020 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x0000001e },
+   { 0x00800001, 0xaf800231, 0x00d28f80, 0x00000000 },
+   { 0x00800001, 0xaf900231, 0x00d28fa0, 0x00000000 },
+   { 0x00800001, 0xafc00231, 0x00d28fc0, 0x00000000 },
+   { 0x00800001, 0xafd00231, 0x00d28fe0, 0x00000000 },
+   { 0x00800001, 0xafa00231, 0x00d28c00, 0x00000000 },
+   { 0x00800001, 0xafb00231, 0x00d28c20, 0x00000000 },
+   { 0x00800001, 0xafe00231, 0x00d28c40, 0x00000000 },
+   { 0x00800001, 0xaff00231, 0x00d28c60, 0x00000000 },
+   { 0x00000040, 0x27e01c01, 0x00001400, 0x00000020 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x000000e0 },
+   { 0x00000040, 0x27e01c01, 0x00001400, 0x00000020 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0xfffffcce },
+   { 0x00000001, 0x27800021, 0x00000780, 0x00000000 },
+   { 0x00000001, 0x27a00021, 0x000007a0, 0x00000000 },
+   { 0x01600031, 0x20001c20, 0x708d0000, 0x82000010 },
+   { 0x00600001, 0x27800231, 0x008d0740, 0x00000000 },
+   { 0x00400005, 0x22083dac, 0x00690680, 0x000f000f },
+   { 0x00400040, 0x26a04625, 0x01e09020, 0x00690058 },
+   { 0x00000001, 0x26d001ad, 0x00000700, 0x00000000 },
+   { 0x00000040, 0x27e41c01, 0x00001400, 0x00000020 },
+   { 0x00000220, 0x34001400, 0x00001400, 0x000006a0 },
+   { 0x80600040, 0xcc0035b1, 0x00898800, 0x008d0760 },
+   { 0x80600040, 0xcc1035b1, 0x00898820, 0x008d0770 },
+   { 0x00800001, 0x27200231, 0x008d0724, 0x00000000 },
+   { 0x00400001, 0x27400231, 0x00808c06, 0x00000000 },
+   { 0x00000006, 0x26d03dad, 0x00000700, 0x00010001 },
+   { 0x00000040, 0x27e41c01, 0x00001400, 0x00000020 },
+   { 0x00000220, 0x34001400, 0x00001400, 0x000006a4 },
+   { 0x80600040, 0xcc2035b1, 0x00898808, 0x008d0760 },
+   { 0x80600040, 0xcc3035b1, 0x00898828, 0x008d0770 },
+   { 0x00000001, 0x27230231, 0x00000783, 0x00000000 },
+   { 0x00400001, 0x27240231, 0x008a8c18, 0x00000000 },
+   { 0x00400001, 0x27280231, 0x008a8c38, 0x00000000 },
+   { 0x00400001, 0x272c0231, 0x00008c3e, 0x00000000 },
+   { 0x00400001, 0x27400231, 0x00690784, 0x00000000 },
+   { 0x00000006, 0x26d03dad, 0x00000700, 0x00020002 },
+   { 0x00000040, 0x27e41c01, 0x00001400, 0x00000020 },
+   { 0x00000220, 0x34001400, 0x00001400, 0x000006a8 },
+   { 0x80600040, 0xcc4035b1, 0x00898840, 0x008d0760 },
+   { 0x80600040, 0xcc5035b1, 0x00898860, 0x008d0770 },
+   { 0x00800001, 0x27200231, 0x008d0724, 0x00000000 },
+   { 0x00600001, 0x27280231, 0x00000727, 0x00000000 },
+   { 0x00400001, 0x27400231, 0x00808c46, 0x00000000 },
+   { 0x00000006, 0x26d03dad, 0x00000700, 0x00030003 },
+   { 0x00000040, 0x27e41c01, 0x00001400, 0x00000020 },
+   { 0x00000220, 0x34001400, 0x00001400, 0x000006ac },
+   { 0x80600040, 0xcc6035b1, 0x00898848, 0x008d0760 },
+   { 0x80600040, 0xcc7035b1, 0x00898868, 0x008d0770 },
+   { 0x00000001, 0x34000020, 0x000007e0, 0x00000000 },
+   { 0x00800001, 0x2760022d, 0x00090724, 0x00000000 },
+   { 0x00000001, 0x34000020, 0x000007e4, 0x00000000 },
+   { 0x00800001, 0x2760022d, 0x00280740, 0x00000000 },
+   { 0x00000001, 0x34000020, 0x000007e4, 0x00000000 },
+   { 0x02802005, 0x20003da0, 0x000006d0, 0x00020002 },
+   { 0x02802005, 0x20003da0, 0x020006d0, 0x00010001 },
+   { 0x009a0001, 0x27200169, 0x00000000, 0x80808080 },
+   { 0x00780001, 0x27400231, 0x028d0724, 0x00000000 },
+   { 0x00780001, 0x27240231, 0x008d0740, 0x00000000 },
+   { 0x00400040, 0x25e04629, 0x00690724, 0x00690740 },
+   { 0x00200040, 0x25e02529, 0x004505e0, 0x004505e4 },
+   { 0x00800040, 0x2400252c, 0x000005e0, 0x000005e2 },
+   { 0x00800040, 0x24003d8c, 0x008d0400, 0x00040004 },
+   { 0x00800008, 0x27603d8d, 0x008d0400, 0x00030003 },
+   { 0x00000001, 0x34000020, 0x000007e4, 0x00000000 },
+   { 0x00600001, 0x26c00231, 0x008d0724, 0x00000000 },
+   { 0x00400001, 0x26c80231, 0x0069072b, 0x00000000 },
+   { 0x00600040, 0x24003e2c, 0x008d06c2, 0x00020002 },
+   { 0x00600048, 0x24003e2c, 0x008d06c1, 0x00020002 },
+   { 0x00600048, 0x25e03e29, 0x008d06c0, 0x00010001 },
+   { 0x00800008, 0x27603d2d, 0x002905e0, 0x00020002 },
+   { 0x00000001, 0x34000020, 0x000007e4, 0x00000000 },
+   { 0x00400009, 0x26e05421, 0x00000740, 0x00690050 },
+   { 0x00600001, 0x26c40231, 0x008d0723, 0x00000000 },
+   { 0x00400001, 0x26c00231, 0x00ab06e3, 0x00000000 },
+   { 0x00600040, 0x24003e2c, 0x008d06c2, 0x00020002 },
+   { 0x00600048, 0x24003e2c, 0x008d06c1, 0x00020002 },
+   { 0x00600048, 0x26c03e2d, 0x008d06c0, 0x00010001 },
+   { 0x00400040, 0x22083eac, 0x00690054, 0x06c006c0 },
+   { 0x00800008, 0x27603dad, 0x01e99000, 0x00020002 },
+   { 0x00000001, 0x34000020, 0x000007e4, 0x00000000 },
+   { 0x00400009, 0x26e05421, 0x00000740, 0x00690050 },
+   { 0x00600001, 0x26c40231, 0x008d0723, 0x00000000 },
+   { 0x00400001, 0x26c00231, 0x00ab06e3, 0x00000000 },
+   { 0x00600042, 0x25c04629, 0x008d06c4, 0x008d06c5 },
+   { 0x00600040, 0x24003e2c, 0x008d06c3, 0x00020002 },
+   { 0x00600048, 0x24003e2c, 0x008d06c2, 0x00020002 },
+   { 0x00600048, 0x24003e2c, 0x008d06c1, 0x00010001 },
+   { 0x00600008, 0x26c03d8d, 0x008d0400, 0x00020002 },
+   { 0x00400001, 0x46c401ad, 0x006906c4, 0x00000000 },
+   { 0x00400001, 0x46c6012d, 0x006905c0, 0x00000000 },
+   { 0x00400040, 0x22083eac, 0x00690054, 0x06c006c0 },
+   { 0x00800001, 0x276001ad, 0x01ea9000, 0x00000000 },
+   { 0x00000001, 0x34000020, 0x000007e4, 0x00000000 },
+   { 0x00400009, 0x26e05421, 0x00000740, 0x00690050 },
+   { 0x00600001, 0x26c40231, 0x008d0723, 0x00000000 },
+   { 0x00400001, 0x26c00231, 0x00ab06e3, 0x00000000 },
+   { 0x00600042, 0x25c04629, 0x008d06c0, 0x008d06c1 },
+   { 0x00600040, 0x24003e2c, 0x008d06c2, 0x00020002 },
+   { 0x00600048, 0x24003e2c, 0x008d06c1, 0x00020002 },
+   { 0x00600048, 0x26e03e2d, 0x008d06c0, 0x00010001 },
+   { 0x00400008, 0x46c23dad, 0x006906e0, 0x00020002 },
+   { 0x00200008, 0x26d03dad, 0x004506e8, 0x00020002 },
+   { 0x00400001, 0x46c0012d, 0x006905c0, 0x00000000 },
+   { 0x00400009, 0x22083eac, 0x00690054, 0x00010001 },
+   { 0x00400040, 0x22083d8c, 0x00690208, 0x06c006c0 },
+   { 0x00800001, 0x276001ad, 0x01e99000, 0x00000000 },
+   { 0x00000001, 0x34000020, 0x000007e4, 0x00000000 },
+   { 0x00600042, 0x45c04629, 0x008d0724, 0x008d0725 },
+   { 0x00600040, 0x24003e2c, 0x008d0726, 0x00020002 },
+   { 0x00600048, 0x24003e2c, 0x008d0725, 0x00020002 },
+   { 0x00600048, 0x25e03e29, 0x008d0724, 0x00010001 },
+   { 0x00600008, 0x45c23d29, 0x008d05e0, 0x00020002 },
+   { 0x00800001, 0x2760012d, 0x002a05c0, 0x00000000 },
+   { 0x00000001, 0x34000020, 0x000007e4, 0x00000000 },
+   { 0x00600001, 0x27440231, 0x00000743, 0x00000000 },
+   { 0x00600042, 0x45c04629, 0x008d0740, 0x008d0741 },
+   { 0x00600040, 0x24003e2c, 0x008d0742, 0x00020002 },
+   { 0x00600048, 0x24003e2c, 0x008d0741, 0x00020002 },
+   { 0x00600048, 0x25e03e29, 0x008d0740, 0x00010001 },
+   { 0x00600008, 0x45c23d29, 0x008d05e0, 0x00020002 },
+   { 0x00800001, 0x2760012d, 0x004905c0, 0x00000000 },
+   { 0x00000001, 0x34000020, 0x000007e4, 0x00000000 },
+   { 0x00000401, 0x27c80061, 0x00000000, 0x000f000f },
+   { 0x00200801, 0x27c001a1, 0x004507fa, 0x00000000 },
+   { 0x00000040, 0x22000c00, 0x00000200, 0x0ff04000 },
+   { 0x00800001, 0x20400232, 0x00a90400, 0x00000000 },
+   { 0x00800001, 0x20500232, 0x00a90404, 0x00000000 },
+   { 0x00800001, 0x20600232, 0x00a90408, 0x00000000 },
+   { 0x00800001, 0x20700232, 0x00a9040c, 0x00000000 },
+   { 0x00800001, 0x20800232, 0x00a90440, 0x00000000 },
+   { 0x00800001, 0x20900232, 0x00a90444, 0x00000000 },
+   { 0x00800001, 0x20a00232, 0x00a90448, 0x00000000 },
+   { 0x00800001, 0x20b00232, 0x00a9044c, 0x00000000 },
+   { 0x00800001, 0x20c00232, 0x00a90480, 0x00000000 },
+   { 0x00800001, 0x20d00232, 0x00a90484, 0x00000000 },
+   { 0x00800001, 0x20e00232, 0x00a90488, 0x00000000 },
+   { 0x00800001, 0x20f00232, 0x00a9048c, 0x00000000 },
+   { 0x00800001, 0x21000232, 0x00a904c0, 0x00000000 },
+   { 0x00800001, 0x21100232, 0x00a904c4, 0x00000000 },
+   { 0x00800001, 0x21200232, 0x00a904c8, 0x00000000 },
+   { 0x00800001, 0x21300232, 0x00a904cc, 0x00000000 },
+   { 0x01600031, 0x27800021, 0x508d07c0, 0x00000200 },
+   { 0x00000001, 0x34000020, 0x000007e0, 0x00000000 },
+   { 0x00000000, 0x00000000, 0x00000000, 0x00000000 },
+   { 0x00600001, 0x27c00021, 0x008d0000, 0x00000000 },
+   { 0x00200009, 0x27fa3e29, 0x00450064, 0x00040004 },
+   { 0x00000401, 0x27c80061, 0x00000000, 0x000f000f },
+   { 0x00200809, 0x27c03e21, 0x00450064, 0x00040004 },
+   { 0x00000040, 0x22000d20, 0x00000062, 0x1218a000 },
+   { 0x00a02401, 0x20400232, 0x00b10080, 0x00000000 },
+   { 0x00a02801, 0x20500232, 0x00b10090, 0x00000000 },
+   { 0x00a02401, 0x20800232, 0x00b100c0, 0x00000000 },
+   { 0x00a02801, 0x20900232, 0x00b100d0, 0x00000000 },
+   { 0x00a02401, 0x20c00232, 0x00b10100, 0x00000000 },
+   { 0x00a02801, 0x20d00232, 0x00b10110, 0x00000000 },
+   { 0x00a02401, 0x21000232, 0x00b10140, 0x00000000 },
+   { 0x00a02801, 0x21100232, 0x00b10150, 0x00000000 },
+   { 0x01600031, 0x27800021, 0x508d07c0, 0x00000200 },
+   { 0x00000401, 0x20280062, 0x00000000, 0x0007000f },
+   { 0x0000080c, 0x20243c22, 0x000007c4, 0x00010001 },
+   { 0x00000040, 0x22001c00, 0x00000200, 0xf8000001 },
+   { 0x00800001, 0x40400232, 0x00b10180, 0x00000000 },
+   { 0x00800001, 0x40410232, 0x00b101c0, 0x00000000 },
+   { 0x00800001, 0x40600232, 0x00b10190, 0x00000000 },
+   { 0x00800001, 0x40610232, 0x00b101d0, 0x00000000 },
+   { 0x00800001, 0x40800232, 0x00b101a0, 0x00000000 },
+   { 0x00800001, 0x40810232, 0x00b101e0, 0x00000000 },
+   { 0x00800001, 0x40a00232, 0x00b101b0, 0x00000000 },
+   { 0x00800001, 0x40a10232, 0x00b101f0, 0x00000000 },
+   { 0x01600031, 0x27a00001, 0x508d0000, 0x00000200 },
+   { 0x00000001, 0x27800021, 0x00000780, 0x00000000 },
+   { 0x00000001, 0x27a00021, 0x000007a0, 0x00000000 },
+   { 0x01600031, 0x20001c20, 0x708d0000, 0x82000010 },
+   { 0x00000000, 0x00000000, 0x00000000, 0x00000000 },
+   { 0x00000000, 0x00000000, 0x00000000, 0x00000000 },
+   { 0x00000000, 0x00000000, 0x00000000, 0x00000000 },
+   { 0x00600001, 0x20400021, 0x008d0000, 0x00000000 },
+   { 0x00000005, 0x20203e2d, 0x00000061, 0x001f001f },
+   { 0x00200009, 0x20643e2d, 0x00450064, 0x00040004 },
+   { 0x00000001, 0x203a01ed, 0x00000000, 0x00000000 },
+   { 0x01000010, 0x20003dac, 0x00000020, 0x00160016 },
+   { 0x00110220, 0x34001c00, 0x00001400, 0x0000001e },
+   { 0x01200010, 0x20003e2c, 0x0200006c, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x02001400, 0x00000024 },
+   { 0x00800009, 0x25403dad, 0x00050064, 0x00020002 },
+   { 0x00000001, 0x203a01ed, 0x00000000, 0x00180018 },
+   { 0x00200040, 0x45483dad, 0x00660548, 0x00100010 },
+   { 0x00200040, 0x45523dad, 0x00660552, 0x00100010 },
+   { 0x00400040, 0x25583dad, 0x00690558, 0x00100010 },
+   { 0x00800040, 0x208035ad, 0x00b10080, 0x00b10540 },
+   { 0x00600040, 0x45403dad, 0x00ae0540, 0x00200020 },
+   { 0x00800040, 0x20a035ad, 0x00b100a0, 0x00b10540 },
+   { 0x00600040, 0x45423dad, 0x00ae0542, 0x00200020 },
+   { 0x00800040, 0x20e035ad, 0x00b100e0, 0x00b10540 },
+   { 0x00600040, 0x45403dad, 0x00ae0540, 0xffe0ffe0 },
+   { 0x00800040, 0x20c035ad, 0x00b100c0, 0x00b10540 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x00000014 },
+   { 0x06600010, 0x20003dac, 0x02000020, 0x00030003 },
+   { 0x00000001, 0x206c0171, 0x00000000, 0x00000000 },
+   { 0x00610001, 0x208000a5, 0x02050080, 0x00000000 },
+   { 0x00610001, 0x212000a5, 0x02090100, 0x00000000 },
+   { 0x00410001, 0x211000a5, 0x02690100, 0x00000000 },
+   { 0x00200009, 0x25403dad, 0x00450064, 0x00020002 },
+   { 0x00800040, 0x208035ad, 0x00b10080, 0x00050540 },
+   { 0x00200040, 0x40883dad, 0x00660088, 0x00200020 },
+   { 0x00200040, 0x40923dad, 0x00660092, 0x00200020 },
+   { 0x00400040, 0x20983dad, 0x00690098, 0x00200020 },
+   { 0x00200401, 0x22080060, 0x00000000, 0x03400140 },
+   { 0x00000c01, 0x220c0060, 0x00000000, 0x04400080 },
+   { 0x00000801, 0x22040060, 0x00000000, 0x01000070 },
+   { 0x00000001, 0x20200169, 0x00000000, 0x00000000 },
+   { 0x0000000c, 0x2458262d, 0x0000006d, 0x00000020 },
+   { 0x00000001, 0x210e0169, 0x00000000, 0x00010001 },
+   { 0x00000005, 0x24583dad, 0x00000458, 0x00030003 },
+   { 0x01000010, 0x200035ac, 0x0000010e, 0x00000458 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x000002fe },
+   { 0x01000010, 0x20003dac, 0x0200010e, 0x00010001 },
+   { 0x00010401, 0x24540061, 0x02000000, 0x06c00640 },
+   { 0x00010805, 0x245a3e2d, 0x02008800, 0x007f007f },
+   { 0x00110401, 0x24540061, 0x02000000, 0x04800780 },
+   { 0x00110805, 0x245a3e2d, 0x02008804, 0x007f007f },
+   { 0x0000000c, 0x211e362d, 0x0000006c, 0x00000020 },
+   { 0x00000040, 0x20780d21, 0x0000045a, 0x0208a002 },
+   { 0x02000005, 0x20003dac, 0x0200011e, 0x00030003 },
+   { 0x00010220, 0x34001c00, 0x02001400, 0x000001be },
+   { 0x01000005, 0x20003dac, 0x00009800, 0x00030003 },
+   { 0x00200005, 0x24443dad, 0x00459800, 0x00030003 },
+   { 0x0020000c, 0x24403dad, 0x00459800, 0x00020002 },
+   { 0x01600006, 0x20003dac, 0x02000446, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x00000012 },
+   { 0x00010040, 0x22000c20, 0x02000078, 0x00400000 },
+   { 0x00110040, 0x22000c20, 0x02000078, 0x00700000 },
+   { 0x00310040, 0x20401da5, 0x02450440, 0xfffffffe },
+   { 0x00110001, 0x20480061, 0x02000000, 0x000c000c },
+   { 0x00010040, 0x20401da5, 0x02000440, 0xfffffffe },
+   { 0x00010001, 0x204401a5, 0x02000442, 0x00000000 },
+   { 0x00010001, 0x20480061, 0x02000000, 0x0007000c },
+   { 0x01600031, 0x25600021, 0x408d0040, 0x00000200 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x0000000e },
+   { 0x00010040, 0x22000c20, 0x02000078, 0x00200000 },
+   { 0x00110040, 0x22000c20, 0x02000078, 0x00400000 },
+   { 0x00200001, 0x204001a5, 0x00450440, 0x00000000 },
+   { 0x00110040, 0x20441da5, 0x02000442, 0xfffffffe },
+   { 0x00110001, 0x20480061, 0x02000000, 0x000c0007 },
+   { 0x00010001, 0x20480061, 0x02000000, 0x00070007 },
+   { 0x01600031, 0x25600021, 0x408d0040, 0x00000200 },
+   { 0x0020040c, 0x24403dad, 0x00459800, 0x00030003 },
+   { 0x00200805, 0x24483dad, 0x00459800, 0x00070007 },
+   { 0x01600006, 0x20003dac, 0x0000044a, 0x00000000 },
+   { 0x00200001, 0x204001a5, 0x00450440, 0x00000000 },
+   { 0x00000009, 0x20403ca5, 0x00000040, 0x00010001 },
+   { 0x00010040, 0x22000c20, 0x00000078, 0x00200010 },
+   { 0x00110040, 0x22000c20, 0x00000078, 0x00300010 },
+   { 0x00010001, 0x20480061, 0x00000000, 0x00030009 },
+   { 0x00110001, 0x20480061, 0x00000000, 0x00040009 },
+   { 0x02600031, 0x27000021, 0x408d0040, 0x00000200 },
+   { 0x01000005, 0x20003dac, 0x00009800, 0x00030003 },
+   { 0x00110220, 0x34001c00, 0x00001400, 0x0000001a },
+   { 0x00600001, 0x26220231, 0x008d05c0, 0x00000000 },
+   { 0x00600401, 0x26120231, 0x008d05b8, 0x00000000 },
+   { 0x00600801, 0x26020231, 0x008d05b0, 0x00000000 },
+   { 0x00600401, 0x25f20231, 0x008d05a8, 0x00000000 },
+   { 0x00600801, 0x25e20231, 0x008d05a0, 0x00000000 },
+   { 0x00600401, 0x25d20231, 0x008d0598, 0x00000000 },
+   { 0x00600801, 0x25c20231, 0x008d0590, 0x00000000 },
+   { 0x00600401, 0x25b20231, 0x008d0588, 0x00000000 },
+   { 0x00600801, 0x25a20231, 0x008d0580, 0x00000000 },
+   { 0x00600401, 0x25920231, 0x008d0578, 0x00000000 },
+   { 0x00600801, 0x25820231, 0x008d0570, 0x00000000 },
+   { 0x00600001, 0x25720231, 0x008d0568, 0x00000000 },
+   { 0x00600001, 0x25620231, 0x008d0560, 0x00000000 },
+   { 0x00110001, 0x220001ec, 0x02000000, 0x05820582 },
+   { 0x00010001, 0x220001ec, 0x02000000, 0x05620562 },
+   { 0x00000001, 0x220e0128, 0x00000454, 0x00000000 },
+   { 0x01800006, 0x200035ac, 0x02000446, 0x00000444 },
+   { 0x00810001, 0xbc000229, 0x02ad8000, 0x00000000 },
+   { 0x00810001, 0xbc200229, 0x02ad8020, 0x00000000 },
+   { 0x00810001, 0xbc400229, 0x02ad8040, 0x00000000 },
+   { 0x00810001, 0xbc600229, 0x02ad8060, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x02001400, 0x0000012a },
+   { 0x00600001, 0x2024018d, 0x008d0200, 0x00000000 },
+   { 0x01000041, 0x245e35ad, 0x00000446, 0x00000444 },
+   { 0x00000040, 0x22022d08, 0x00000200, 0x00100010 },
+   { 0x02000005, 0x20003db0, 0x0200045e, 0x00010001 },
+   { 0x00200040, 0x22042d08, 0x00450200, 0x00200020 },
+   { 0x00400001, 0x244c0109, 0x00690200, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x00000066 },
+   { 0x00010220, 0x34001c00, 0x02001400, 0x00000064 },
+   { 0x00000040, 0x22003d08, 0x00000200, 0xffdeffde },
+   { 0x00000440, 0x22023d08, 0x00000202, 0xffeeffee },
+   { 0x00000801, 0x220c0060, 0x00000000, 0x04a00480 },
+   { 0x01000010, 0x20003db0, 0x0000045e, 0x00040004 },
+   { 0x00a02040, 0x2400462c, 0x00ad8000, 0x00ad8005 },
+   { 0x00a02048, 0x24003e2c, 0x00ad8001, 0xfffbfffb },
+   { 0x00a02048, 0x24003e2c, 0x00ad8002, 0x00140014 },
+   { 0x00a02048, 0x24003e2c, 0x00ad8003, 0x00140014 },
+   { 0x00a02048, 0xb8003e2d, 0x00ad8004, 0xfffbfffb },
+   { 0x00a02040, 0x2400462c, 0x00ad8040, 0x00ad8045 },
+   { 0x00a02048, 0x24003e2c, 0x00ad8041, 0xfffbfffb },
+   { 0x00a02048, 0x24003e2c, 0x00ad8042, 0x00140014 },
+   { 0x00a02048, 0x24003e2c, 0x00ad8043, 0x00140014 },
+   { 0x00a02048, 0xb8403e2d, 0x00ad8044, 0xfffbfffb },
+   { 0x00a02040, 0x2400462c, 0x00ad8080, 0x00ad8085 },
+   { 0x00a02048, 0x24003e2c, 0x00ad8081, 0xfffbfffb },
+   { 0x00a02048, 0x24003e2c, 0x00ad8082, 0x00140014 },
+   { 0x00a02048, 0x24003e2c, 0x00ad8083, 0x00140014 },
+   { 0x00a02048, 0xb8803e2d, 0x00ad8084, 0xfffbfffb },
+   { 0x00600040, 0x2400462c, 0x008d80c0, 0x008d80c5 },
+   { 0x00600048, 0x24003e2c, 0x008d80c1, 0xfffbfffb },
+   { 0x00600048, 0x24003e2c, 0x008d80c2, 0x00140014 },
+   { 0x00600048, 0x24003e2c, 0x008d80c3, 0x00140014 },
+   { 0x00600048, 0xb8c03e2d, 0x008d80c4, 0xfffbfffb },
+   { 0x00000401, 0x22000060, 0x00000000, 0x04a00480 },
+   { 0x00000c01, 0x22040060, 0x00000000, 0x04a00490 },
+   { 0x00010802, 0x220c2d28, 0x00000454, 0x04800480 },
+   { 0x00a02040, 0x24003dac, 0x00b18000, 0x02000200 },
+   { 0x00800048, 0x24003dac, 0x01ed8800, 0xfffbfffb },
+   { 0x00800048, 0x24203dac, 0x01ed8820, 0xfffbfffb },
+   { 0x00a02048, 0x24003dac, 0x00b18020, 0x00140014 },
+   { 0x00800048, 0x24003dac, 0x01ed8820, 0x00140014 },
+   { 0x00800048, 0x24203dac, 0x01ed8840, 0x00140014 },
+   { 0x00a02048, 0x24003dac, 0x00b18040, 0xfffbfffb },
+   { 0x00800048, 0x24003dac, 0x01ed8840, 0x00010001 },
+   { 0x00800048, 0x24203dac, 0x01ed8860, 0x00010001 },
+   { 0x8080000c, 0xd8003d91, 0x00b10400, 0x000a000a },
+   { 0x8080100c, 0xd8203d91, 0x00b10420, 0x000a000a },
+   { 0x00a02040, 0x24003dac, 0x00b18040, 0x02000200 },
+   { 0x00800048, 0x24003dac, 0x01ed8840, 0xfffbfffb },
+   { 0x00800048, 0x24203dac, 0x01ed8860, 0xfffbfffb },
+   { 0x00a02048, 0x24003dac, 0x00b18060, 0x00140014 },
+   { 0x00800048, 0x24003dac, 0x01ed8860, 0x00140014 },
+   { 0x00800048, 0x24203dac, 0x01ed8880, 0x00140014 },
+   { 0x00a02048, 0x24003dac, 0x00b18080, 0xfffbfffb },
+   { 0x00800048, 0x24003dac, 0x01ed8880, 0x00010001 },
+   { 0x00800048, 0x24203dac, 0x01ed88a0, 0x00010001 },
+   { 0x8080000c, 0xd8403d91, 0x00b10400, 0x000a000a },
+   { 0x8080100c, 0xd8603d91, 0x00b10420, 0x000a000a },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x000000b4 },
+   { 0x01000010, 0x20003db0, 0x00000444, 0x00000000 },
+   { 0x01000010, 0x20003db0, 0x02000446, 0x00020002 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x0000004c },
+   { 0x00010220, 0x34001c00, 0x02001400, 0x0000004a },
+   { 0x00400040, 0x22003d28, 0x0069044c, 0xfffefffe },
+   { 0x03400010, 0x20003dac, 0x00000446, 0x00020002 },
+   { 0x01000010, 0x20003db0, 0x02000444, 0x00020002 },
+   { 0x00410040, 0x22002d08, 0x00690200, 0x00100010 },
+   { 0x01000010, 0x20003dac, 0x00000446, 0x00000000 },
+   { 0x00010002, 0x220c2d28, 0x02000454, 0x04800480 },
+   { 0x00800040, 0x24003e2c, 0x01ed8000, 0x00100010 },
+   { 0x00800040, 0x24203e2c, 0x01ed8020, 0x00100010 },
+   { 0x00800048, 0x24003e2c, 0x01ed8001, 0xfffbfffb },
+   { 0x00800048, 0x24203e2c, 0x01ed8021, 0xfffbfffb },
+   { 0x00800048, 0x24003e2c, 0x01ed8002, 0x00140014 },
+   { 0x00800048, 0x24203e2c, 0x01ed8022, 0x00140014 },
+   { 0x00800048, 0x24003e2c, 0x01ed8003, 0x00140014 },
+   { 0x00800048, 0x24203e2c, 0x01ed8023, 0x00140014 },
+   { 0x00800048, 0x24003e2c, 0x01ed8004, 0xfffbfffb },
+   { 0x00800048, 0x24203e2c, 0x01ed8024, 0xfffbfffb },
+   { 0x00800048, 0x24003e2c, 0x01ed8005, 0x00010001 },
+   { 0x00800048, 0x24203e2c, 0x01ed8025, 0x00010001 },
+   { 0x8080000c, 0xd8003d91, 0x00b10400, 0x00050005 },
+   { 0x8080100c, 0xd8203d91, 0x00b10420, 0x00050005 },
+   { 0x00800040, 0x24003e2c, 0x01ed8040, 0x00100010 },
+   { 0x00800040, 0x24203e2c, 0x01ed8060, 0x00100010 },
+   { 0x00800048, 0x24003e2c, 0x01ed8041, 0xfffbfffb },
+   { 0x00800048, 0x24203e2c, 0x01ed8061, 0xfffbfffb },
+   { 0x00800048, 0x24003e2c, 0x01ed8042, 0x00140014 },
+   { 0x00800048, 0x24203e2c, 0x01ed8062, 0x00140014 },
+   { 0x00800048, 0x24003e2c, 0x01ed8043, 0x00140014 },
+   { 0x00800048, 0x24203e2c, 0x01ed8063, 0x00140014 },
+   { 0x00800048, 0x24003e2c, 0x01ed8044, 0xfffbfffb },
+   { 0x00800048, 0x24203e2c, 0x01ed8064, 0xfffbfffb },
+   { 0x00800048, 0x24003e2c, 0x01ed8045, 0x00010001 },
+   { 0x00800048, 0x24203e2c, 0x01ed8065, 0x00010001 },
+   { 0x8080000c, 0xd8403d91, 0x00b10400, 0x00050005 },
+   { 0x8080100c, 0xd8603d91, 0x00b10420, 0x00050005 },
+   { 0x00110220, 0x34001c00, 0x02001400, 0x00000004 },
+   { 0x00110220, 0x34001c00, 0x00001400, 0x0000005c },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x00000062 },
+   { 0x01000010, 0x20003db0, 0x00000446, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x00000042 },
+   { 0x00200401, 0x22000128, 0x0066044c, 0x00000000 },
+   { 0x00200c01, 0x22040128, 0x0045044e, 0x00000000 },
+   { 0x00000801, 0x220c0128, 0x00000454, 0x00000000 },
+   { 0x03400010, 0x20003dac, 0x02000444, 0x00020002 },
+   { 0x01000010, 0x20003dac, 0x00000444, 0x00000000 },
+   { 0x00410040, 0x22002d08, 0x02690200, 0x00010001 },
+   { 0x01000010, 0x20003db0, 0x02000446, 0x00020002 },
+   { 0x00110220, 0x34001c00, 0x00001400, 0x00000002 },
+   { 0x00110001, 0x220c0168, 0x02000000, 0x04800480 },
+   { 0x00a02040, 0x24003e2c, 0x00ad83e0, 0x00100010 },
+   { 0x00800048, 0x24003e2c, 0x01ed8be0, 0xfffbfffb },
+   { 0x00800048, 0x24203e2c, 0x01ed8800, 0xfffbfffb },
+   { 0x00a02048, 0x24003e2c, 0x00ad8000, 0x00140014 },
+   { 0x00800048, 0x24003e2c, 0x01ed8800, 0x00140014 },
+   { 0x00800048, 0x24203e2c, 0x01ed8820, 0x00140014 },
+   { 0x00a02048, 0x24003e2c, 0x00ad8020, 0xfffbfffb },
+   { 0x00800048, 0x24003e2c, 0x01ed8820, 0x00010001 },
+   { 0x00800048, 0x24203e2c, 0x01ed8840, 0x00010001 },
+   { 0x8080000c, 0xd8003d91, 0x00b10400, 0x00050005 },
+   { 0x8080100c, 0xd8203d91, 0x00b10420, 0x00050005 },
+   { 0x00a02040, 0x24003e2c, 0x00ad8020, 0x00100010 },
+   { 0x00800048, 0x24003e2c, 0x01ed8820, 0xfffbfffb },
+   { 0x00800048, 0x24203e2c, 0x01ed8840, 0xfffbfffb },
+   { 0x00a02048, 0x24003e2c, 0x00ad8040, 0x00140014 },
+   { 0x00800048, 0x24003e2c, 0x01ed8840, 0x00140014 },
+   { 0x00800048, 0x24203e2c, 0x01ed8860, 0x00140014 },
+   { 0x00a02048, 0x24003e2c, 0x00ad8060, 0xfffbfffb },
+   { 0x00800048, 0x24003e2c, 0x01ed8860, 0x00010001 },
+   { 0x00800048, 0x24203e2c, 0x01ed8880, 0x00010001 },
+   { 0x8080000c, 0xd8403d91, 0x00b10400, 0x00050005 },
+   { 0x8080100c, 0xd8603d91, 0x00b10420, 0x00050005 },
+   { 0x00110220, 0x34001c00, 0x00001400, 0x00000016 },
+   { 0x00010220, 0x34001c00, 0x02001400, 0x0000001c },
+   { 0x00200401, 0x22000128, 0x0045044c, 0x00000000 },
+   { 0x00000801, 0x220c0128, 0x00000454, 0x00000000 },
+   { 0x01200010, 0x20003dac, 0x00000444, 0x00030003 },
+   { 0x01200010, 0x20003dac, 0x02000446, 0x00030003 },
+   { 0x00210040, 0x22002d08, 0x00450200, 0x00010001 },
+   { 0x00210040, 0x22002d08, 0x02450200, 0x00100010 },
+   { 0x00800001, 0xb8000229, 0x01ed8000, 0x00000000 },
+   { 0x00800001, 0xb8200229, 0x01ed8020, 0x00000000 },
+   { 0x00800001, 0xb8400229, 0x01ed8040, 0x00000000 },
+   { 0x00800001, 0xb8600229, 0x01ed8060, 0x00000000 },
+   { 0x80800042, 0xd8004631, 0x00d29800, 0x00d20480 },
+   { 0x80800042, 0xd8204631, 0x00d29820, 0x00d204a0 },
+   { 0x80800042, 0xd8404631, 0x00d29840, 0x00d204c0 },
+   { 0x80800042, 0xd8604631, 0x00d29860, 0x00d204e0 },
+   { 0x00600001, 0x220001ac, 0x008d0024, 0x00000000 },
+   { 0x00200040, 0x244c3dad, 0x00450448, 0xfff8fff8 },
+   { 0x00000401, 0x220001ec, 0x00000000, 0x07000700 },
+   { 0x00000c01, 0x220201e8, 0x00000000, 0x07100710 },
+   { 0x00000801, 0x220e0128, 0x00000456, 0x00000000 },
+   { 0x00000441, 0x254635ad, 0x00000448, 0x0000044a },
+   { 0x00000c41, 0x254025ad, 0x0000444c, 0x0000444e },
+   { 0x00000c41, 0x254225ad, 0x00000448, 0x0000444e },
+   { 0x00000841, 0x254435ad, 0x0000444c, 0x0000044a },
+   { 0x00200040, 0x244c3d09, 0x00450200, 0x00100010 },
+   { 0x00800041, 0x24002628, 0x00ad8000, 0x00000540 },
+   { 0x00800041, 0x24202628, 0x00ad8020, 0x00000540 },
+   { 0x00800048, 0x24002628, 0x00ad8002, 0x00000542 },
+   { 0x00800048, 0x24202628, 0x00ad8022, 0x00000542 },
+   { 0x00200001, 0x22000128, 0x0045044c, 0x00000000 },
+   { 0x00800048, 0x24002628, 0x01ed8000, 0x00000544 },
+   { 0x00800048, 0x24202628, 0x01ed8020, 0x00000544 },
+   { 0x00800048, 0xbc002629, 0x01ed8002, 0x00000546 },
+   { 0x00801048, 0xbc202629, 0x01ed8022, 0x00000546 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x00000126 },
+   { 0x00000001, 0x20220169, 0x00000000, 0x00040004 },
+   { 0x00200005, 0x24443dad, 0x00459800, 0x00030003 },
+   { 0x0020000c, 0x24403dad, 0x00459800, 0x00020002 },
+   { 0x01600006, 0x20003dac, 0x02000446, 0x00000000 },
+   { 0x00010040, 0x22000c20, 0x02000078, 0x00200000 },
+   { 0x00110040, 0x22000c20, 0x02000078, 0x00500000 },
+   { 0x00310040, 0x20401da5, 0x02450440, 0xfffffffe },
+   { 0x00110001, 0x20480061, 0x02000000, 0x00080008 },
+   { 0x00010040, 0x20401da5, 0x02000440, 0xfffffffe },
+   { 0x00010001, 0x204401a5, 0x02000442, 0x00000000 },
+   { 0x00010001, 0x20480061, 0x02000000, 0x00030008 },
+   { 0x01600031, 0x25600021, 0x408d0040, 0x00000200 },
+   { 0x00000040, 0x22000c20, 0x00000078, 0x00100010 },
+   { 0x0020040c, 0x24403dad, 0x00459800, 0x00030003 },
+   { 0x00200805, 0x24483dad, 0x00459800, 0x00070007 },
+   { 0x00200001, 0x204001a5, 0x00450440, 0x00000000 },
+   { 0x00000009, 0x20403ca5, 0x00000040, 0x00010001 },
+   { 0x00000001, 0x20480061, 0x00000000, 0x00020005 },
+   { 0x02600031, 0x27000021, 0x408d0040, 0x00000200 },
+   { 0x00110001, 0x220001ec, 0x02000000, 0x05820582 },
+   { 0x00010001, 0x220001ec, 0x02000000, 0x05620562 },
+   { 0x00000001, 0x220e0128, 0x00000454, 0x00000000 },
+   { 0x01800006, 0x200035ac, 0x02000446, 0x00000444 },
+   { 0x00410001, 0xbc000229, 0x02698000, 0x00000000 },
+   { 0x00410001, 0xbc100229, 0x02698010, 0x00000000 },
+   { 0x00410001, 0xbc200229, 0x02698020, 0x00000000 },
+   { 0x00410001, 0xbc300229, 0x02698030, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x02001400, 0x000000be },
+   { 0x00600001, 0x2024018d, 0x008d0200, 0x00000000 },
+   { 0x01000041, 0x245e35ad, 0x00000446, 0x00000444 },
+   { 0x02000005, 0x20003db0, 0x0200045e, 0x00010001 },
+   { 0x00000040, 0x22022d08, 0x00000200, 0x00100010 },
+   { 0x00200040, 0x22042d08, 0x00450200, 0x00200020 },
+   { 0x00400001, 0x244c0109, 0x00690200, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x00000044 },
+   { 0x00010220, 0x34001c00, 0x02001400, 0x00000042 },
+   { 0x00000040, 0x22003d08, 0x00000200, 0xffdeffde },
+   { 0x00000440, 0x22023d08, 0x00000202, 0xffeeffee },
+   { 0x00000801, 0x220c0060, 0x00000000, 0x04d004c0 },
+   { 0x01000010, 0x20003db0, 0x0000045e, 0x00040004 },
+   { 0x00802040, 0x2400462c, 0x00a98000, 0x00a98005 },
+   { 0x00802048, 0x24003e2c, 0x00a98001, 0xfffbfffb },
+   { 0x00802048, 0x24003e2c, 0x00a98002, 0x00140014 },
+   { 0x00802048, 0x24003e2c, 0x00a98003, 0x00140014 },
+   { 0x00802048, 0xb8003e2d, 0x00a98004, 0xfffbfffb },
+   { 0x00802040, 0x2400462c, 0x00a98040, 0x00a98045 },
+   { 0x00802048, 0x24003e2c, 0x00a98041, 0xfffbfffb },
+   { 0x00802048, 0x24003e2c, 0x00a98042, 0x00140014 },
+   { 0x00802048, 0x24003e2c, 0x00a98043, 0x00140014 },
+   { 0x00802048, 0xb8203e2d, 0x00a98044, 0xfffbfffb },
+   { 0x00400040, 0x2400462c, 0x00698080, 0x00698085 },
+   { 0x00400048, 0x24003e2c, 0x00698081, 0xfffbfffb },
+   { 0x00400048, 0x24003e2c, 0x00698082, 0x00140014 },
+   { 0x00400048, 0x24003e2c, 0x00698083, 0x00140014 },
+   { 0x00400048, 0xb8403e2d, 0x00698084, 0xfffbfffb },
+   { 0x00000401, 0x220c0060, 0x00000000, 0x04e004d0 },
+   { 0x00000c01, 0x22000060, 0x00000000, 0x04d004c8 },
+   { 0x00000c01, 0x22040060, 0x00000000, 0x04e004d8 },
+   { 0x00000801, 0x22080060, 0x00000000, 0x04f004e8 },
+   { 0x00800040, 0x24003dac, 0x00b104c0, 0x02000200 },
+   { 0x00800048, 0x24003dac, 0x00b104e0, 0xfffbfffb },
+   { 0x00800048, 0x24003dac, 0x01ed9800, 0x00140014 },
+   { 0x00010001, 0x220c0168, 0x00000000, 0x05400540 },
+   { 0x00110001, 0x220c0168, 0x00000000, 0x04c004c0 },
+   { 0x00800048, 0x24003dac, 0x01e98000, 0xfffbfffb },
+   { 0x00800048, 0x24003dac, 0x01e98020, 0x00010001 },
+   { 0x00800048, 0x24003dac, 0x01e98800, 0x00140014 },
+   { 0x8080000c, 0xd8003d91, 0x00b10400, 0x000a000a },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x00000060 },
+   { 0x01000010, 0x20003db0, 0x00000444, 0x00000000 },
+   { 0x01000010, 0x20003db0, 0x02000446, 0x00020002 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x00000024 },
+   { 0x00010220, 0x34001c00, 0x02001400, 0x00000022 },
+   { 0x00400040, 0x22003d28, 0x0069044c, 0xfffefffe },
+   { 0x03400010, 0x20003dac, 0x00000446, 0x00020002 },
+   { 0x01000010, 0x20003db0, 0x02000444, 0x00020002 },
+   { 0x00410040, 0x22002d08, 0x00690200, 0x00100010 },
+   { 0x01000010, 0x20003dac, 0x00000446, 0x00000000 },
+   { 0x00010001, 0x220e0168, 0x02000000, 0x05400540 },
+   { 0x00110001, 0x220e0168, 0x02000000, 0x04c004c0 },
+   { 0x00800040, 0x24003e2c, 0x01e98000, 0x00100010 },
+   { 0x00800048, 0x24003e2c, 0x01e98001, 0xfffbfffb },
+   { 0x00800048, 0x24003e2c, 0x01e98002, 0x00140014 },
+   { 0x00800048, 0x24003e2c, 0x01e98003, 0x00140014 },
+   { 0x00800048, 0x24003e2c, 0x01e98004, 0xfffbfffb },
+   { 0x00800048, 0x24003e2c, 0x01e98005, 0x00010001 },
+   { 0x8080000c, 0xdc003d91, 0x00b10400, 0x00050005 },
+   { 0x00110220, 0x34001c00, 0x02001400, 0x00000004 },
+   { 0x00110220, 0x34001c00, 0x00001400, 0x00000036 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x00000036 },
+   { 0x01000010, 0x20003db0, 0x00000446, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x00000024 },
+   { 0x03600010, 0x20003dac, 0x02000444, 0x00020002 },
+   { 0x00400401, 0x22000128, 0x0069044c, 0x00000000 },
+   { 0x00400840, 0x22083d2c, 0x0069044c, 0x00100010 },
+   { 0x00610040, 0x22002d08, 0x02690200, 0x00010001 },
+   { 0x01000010, 0x20003dac, 0x00000444, 0x00000000 },
+   { 0x01000010, 0x20003db0, 0x02000446, 0x00020002 },
+   { 0x00800040, 0x24003e2c, 0x01e983e0, 0x00100010 },
+   { 0x00800048, 0x24003e2c, 0x01e98000, 0x00140014 },
+   { 0x00800048, 0x24003e2c, 0x01e98020, 0xfffbfffb },
+   { 0x00800048, 0x24003e2c, 0x01e993e0, 0xfffbfffb },
+   { 0x00800048, 0x24003e2c, 0x01e99000, 0x00140014 },
+   { 0x00800048, 0x24003e2c, 0x01e99020, 0x00010001 },
+   { 0x00000001, 0x220e0168, 0x00000000, 0x05400540 },
+   { 0x00110220, 0x34001c00, 0x00001400, 0x00000002 },
+   { 0x00110001, 0x220e0168, 0x02000000, 0x04c004c0 },
+   { 0x8080000c, 0xdc003d91, 0x00b10400, 0x00050005 },
+   { 0x00110220, 0x34001c00, 0x00001400, 0x0000000e },
+   { 0x00010220, 0x34001c00, 0x02001400, 0x0000000e },
+   { 0x00400001, 0x22000128, 0x0069044c, 0x00000000 },
+   { 0x01400010, 0x20003dac, 0x00000444, 0x00030003 },
+   { 0x01400010, 0x20003dac, 0x02000446, 0x00030003 },
+   { 0x00410040, 0x22002d08, 0x00690200, 0x00010001 },
+   { 0x00410040, 0x22002d08, 0x02690200, 0x00100010 },
+   { 0x00800001, 0x25400229, 0x01e98000, 0x00000000 },
+   { 0x80800042, 0x45404631, 0x00d20540, 0x00d204c0 },
+   { 0x00000001, 0x220c0128, 0x00000454, 0x00000000 },
+   { 0x00400001, 0xd8000231, 0x008a0540, 0x00000000 },
+   { 0x00400001, 0xd8100231, 0x008a0548, 0x00000000 },
+   { 0x00400001, 0xd8200231, 0x008a0550, 0x00000000 },
+   { 0x00400001, 0xd8300231, 0x008a0558, 0x00000000 },
+   { 0x00600001, 0x220001ac, 0x008d0024, 0x00000000 },
+   { 0x00200040, 0x244c3dad, 0x00450448, 0xfff8fff8 },
+   { 0x00000401, 0x220001ec, 0x00000000, 0x07000700 },
+   { 0x00000801, 0x220e0128, 0x00000456, 0x00000000 },
+   { 0x00000441, 0x254635ad, 0x00000448, 0x0000044a },
+   { 0x00000c41, 0x254025ad, 0x0000444c, 0x0000444e },
+   { 0x00000c41, 0x254225ad, 0x00000448, 0x0000444e },
+   { 0x00000841, 0x254435ad, 0x0000444c, 0x0000044a },
+   { 0x00600041, 0x24002628, 0x00898000, 0x00000540 },
+   { 0x00600048, 0x24002628, 0x00898002, 0x00000542 },
+   { 0x00600048, 0x24002628, 0x00898008, 0x00000544 },
+   { 0x00600048, 0x2540262d, 0x0089800a, 0x00000546 },
+   { 0x00400401, 0xbc0001a9, 0x00690540, 0x00000000 },
+   { 0x00400801, 0xbc1001a9, 0x00690548, 0x00000000 },
+   { 0x01000010, 0x20003d2c, 0x00000022, 0x00030003 },
+   { 0x01000040, 0x20223d29, 0x02000022, 0xffffffff },
+   { 0x00000040, 0x220c3d8c, 0x0000020c, 0x00080008 },
+   { 0x00110040, 0x24540c21, 0x00000454, 0x00080008 },
+   { 0x00010040, 0x24540c21, 0x00000454, 0x00180038 },
+   { 0x00110220, 0x34001c00, 0x02001400, 0xfffffee6 },
+   { 0x01800010, 0x20003dac, 0x0200010e, 0x00010001 },
+   { 0x00000040, 0x220c3d8c, 0x0000020c, 0xffe0ffe0 },
+   { 0x00010001, 0x24540061, 0x02000000, 0x06c00640 },
+   { 0x00110001, 0x24540061, 0x02000000, 0x04800780 },
+   { 0x00000001, 0x220e0128, 0x00000456, 0x00000000 },
+   { 0x00800040, 0x24003dac, 0x00b19c00, 0x00200020 },
+   { 0x00800040, 0x24203dac, 0x00b19c20, 0x00200020 },
+   { 0x8080000c, 0xdc003d91, 0x00b10400, 0x00060006 },
+   { 0x8080000c, 0xdc203d91, 0x00b10420, 0x00060006 },
+   { 0x02000040, 0x210e3d29, 0x0200010e, 0xffffffff },
+   { 0x00000040, 0x220c3d8c, 0x0000020c, 0x00040004 },
+   { 0x00110220, 0x34001c00, 0x02001400, 0xfffffcf8 },
+   { 0x01000005, 0x25643e2d, 0x00000060, 0x00c000c0 },
+   { 0x01000010, 0x20003dac, 0x02000458, 0x00020002 },
+   { 0x00110220, 0x34001c00, 0x00001400, 0x00000016 },
+   { 0x00010220, 0x34001c00, 0x02001400, 0x0000000c },
+   { 0x01000010, 0x20003dac, 0x00000458, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x00000086 },
+   { 0x00a02001, 0x46400231, 0x00d20780, 0x00000000 },
+   { 0x00a02001, 0x46800231, 0x00d207c0, 0x00000000 },
+   { 0x00a02001, 0x46c00231, 0x00d20480, 0x00000000 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x0000007e },
+   { 0x80a02042, 0x46404631, 0x00d20640, 0x00d20780 },
+   { 0x80a02042, 0x46804631, 0x00d20680, 0x00d207c0 },
+   { 0x80a02042, 0x46c04631, 0x00d206c0, 0x00d20480 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x00000076 },
+   { 0x01000010, 0x20003dac, 0x02000564, 0x00800080 },
+   { 0x00110220, 0x34001c00, 0x02001400, 0x0000000e },
+   { 0x01000010, 0x20003dac, 0x00000458, 0x00020002 },
+   { 0x00110220, 0x34001c00, 0x00001400, 0xffffffe4 },
+   { 0x00200401, 0x256801ed, 0x00000000, 0x00200020 },
+   { 0x00200801, 0x256c01ed, 0x00000000, 0x00060006 },
+   { 0x00400001, 0x258001ed, 0x00000000, 0x00000000 },
+   { 0x00600001, 0x45a001ad, 0x00058c00, 0x00000000 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x00000028 },
+   { 0x02600005, 0x20006e28, 0x02008c0c, 0x88848421 },
+   { 0x0220000c, 0x25663dad, 0x00000458, 0x00010001 },
+   { 0x0000000c, 0x25643dad, 0x00000564, 0x00060006 },
+   { 0x00310001, 0x25c401ad, 0x00000458, 0x00000000 },
+   { 0x00210001, 0x25c00061, 0x00000000, 0x00010001 },
+   { 0x00310040, 0x25c03dad, 0x004545c4, 0x00010001 },
+   { 0x00610001, 0x25a00061, 0x02000000, 0x00000080 },
+   { 0x00710001, 0x45a002ad, 0x02ae8c00, 0x00000000 },
+   { 0x00710001, 0x45a202ad, 0x02ae8c01, 0x00000000 },
+   { 0x00800041, 0x25a035ad, 0x00b105a0, 0x000905c0 },
+   { 0x01200010, 0x20003e2c, 0x0245006e, 0x00000000 },
+   { 0x00310009, 0x244c45ad, 0x02000564, 0x0045006e },
+   { 0x00210001, 0x244c01ed, 0x02000000, 0x00000000 },
+   { 0x0031000c, 0x244c3dad, 0x0245044c, 0x00010001 },
+   { 0x00200009, 0x256835ad, 0x0045044c, 0x00000566 },
+   { 0x00210040, 0x256835ad, 0x02450568, 0x00000566 },
+   { 0x00200040, 0x256c362d, 0x0045006e, 0x00000566 },
+   { 0x00400040, 0x240035ac, 0x00ab05a2, 0x00ab05a6 },
+   { 0x00400040, 0x2400358c, 0x00690400, 0x00000566 },
+   { 0x0040000c, 0x2580358d, 0x00690400, 0x00000566 },
+   { 0x00800041, 0x2400362c, 0x00d20640, 0x000005a0 },
+   { 0x00800041, 0x2420362c, 0x00d20660, 0x000005a0 },
+   { 0x00800048, 0x2400362c, 0x00d20780, 0x000005a4 },
+   { 0x00800048, 0x2420362c, 0x00d207a0, 0x000005a4 },
+   { 0x00800040, 0x2400358c, 0x00b10400, 0x00000568 },
+   { 0x00800040, 0x2420358c, 0x00b10420, 0x00000568 },
+   { 0x0080000c, 0x24c0358d, 0x00b10400, 0x0000056c },
+   { 0x0080000c, 0x24e0358d, 0x00b10420, 0x0000056c },
+   { 0x80800040, 0x464035b1, 0x00b104c0, 0x00000580 },
+   { 0x80800040, 0x466035b1, 0x00b104e0, 0x00000580 },
+   { 0x00800041, 0x2400362c, 0x00d20680, 0x000005a0 },
+   { 0x00800041, 0x2420362c, 0x00d206a0, 0x000005a0 },
+   { 0x00800048, 0x2400362c, 0x00d207c0, 0x000005a4 },
+   { 0x00800048, 0x2420362c, 0x00d207e0, 0x000005a4 },
+   { 0x00800040, 0x2400358c, 0x00b10400, 0x00000568 },
+   { 0x00800040, 0x2420358c, 0x00b10420, 0x00000568 },
+   { 0x0080000c, 0x24c0358d, 0x00b10400, 0x0000056c },
+   { 0x0080000c, 0x24e0358d, 0x00b10420, 0x0000056c },
+   { 0x80800040, 0x468035b1, 0x00b104c0, 0x00000580 },
+   { 0x80800040, 0x46a035b1, 0x00b104e0, 0x00000580 },
+   { 0x00800041, 0x2400362c, 0x00d206c0, 0x000705a8 },
+   { 0x00800041, 0x2420362c, 0x00d206e0, 0x000705a8 },
+   { 0x00800048, 0x2400362c, 0x00d20480, 0x000705ac },
+   { 0x00800048, 0x2420362c, 0x00d204a0, 0x000705ac },
+   { 0x00800040, 0x2400358c, 0x00b10400, 0x0000056a },
+   { 0x00800040, 0x2420358c, 0x00b10420, 0x0000056a },
+   { 0x0080000c, 0x24c0358d, 0x00b10400, 0x0000056e },
+   { 0x0080000c, 0x24e0358d, 0x00b10420, 0x0000056e },
+   { 0x80800040, 0x46c035b1, 0x00b104c0, 0x00050582 },
+   { 0x80800040, 0x46e035b1, 0x00b104e0, 0x00050582 },
+   { 0x01800005, 0x20003d2c, 0x02000020, 0x00020002 },
+   { 0x80800040, 0xd00045b1, 0x00b19000, 0x00d20640 },
+   { 0x80800040, 0xd02045b1, 0x00b19020, 0x00d20660 },
+   { 0x80800040, 0xd04045b1, 0x00b19040, 0x00d20680 },
+   { 0x80800040, 0xd06045b1, 0x00b19060, 0x00d206a0 },
+   { 0x00000040, 0x22083d8c, 0x00000208, 0x00800080 },
+   { 0x80400040, 0xd40045b1, 0x00699400, 0x00ab06c0 },
+   { 0x80400040, 0xd48045b1, 0x00699480, 0x00ab06c2 },
+   { 0x80400040, 0xd42045b1, 0x00699420, 0x00ab06e0 },
+   { 0x80400040, 0xd4a045b1, 0x006994a0, 0x00ab06e2 },
+   { 0x80400040, 0xd41045b1, 0x00699410, 0x00ab06d0 },
+   { 0x80400040, 0xd49045b1, 0x00699490, 0x00ab06d2 },
+   { 0x80400040, 0xd43045b1, 0x00699430, 0x00ab06f0 },
+   { 0x80400040, 0xd4b045b1, 0x006994b0, 0x00ab06f2 },
+   { 0x00000040, 0x220a3d8c, 0x0000020a, 0x00080008 },
+   { 0x00110040, 0x220a3d8c, 0x0200020a, 0x00300030 },
+   { 0x01000010, 0x20003d2c, 0x02000020, 0x00060006 },
+   { 0x00000040, 0x20203d29, 0x00000020, 0x00020002 },
+   { 0x00000040, 0x22040c00, 0x00000204, 0x00100001 },
+   { 0x00000040, 0x220c358c, 0x0000020c, 0x0000003a },
+   { 0x00110220, 0x34001c00, 0x02001400, 0xfffffc36 },
+   { 0x00000001, 0x220001ec, 0x00000000, 0x01400140 },
+   { 0x00000001, 0x220201ec, 0x00000000, 0x01c001c0 },
+   { 0x00800401, 0x20400236, 0x01ee8000, 0x00000000 },
+   { 0x00800801, 0x20500236, 0x01ee8010, 0x00000000 },
+   { 0x00800401, 0x20600236, 0x01ee8020, 0x00000000 },
+   { 0x00800801, 0x20700236, 0x01ee8030, 0x00000000 },
+   { 0x00800401, 0x20800236, 0x01ee8040, 0x00000000 },
+   { 0x00800801, 0x20900236, 0x01ee8050, 0x00000000 },
+   { 0x00800401, 0x20a00236, 0x01ee8060, 0x00000000 },
+   { 0x00800801, 0x20b00236, 0x01ee8070, 0x00000000 },
+   { 0x00800401, 0x20c00236, 0x01ee8100, 0x00000000 },
+   { 0x00800801, 0x20d00236, 0x01ee8110, 0x00000000 },
+   { 0x00800401, 0x20e00236, 0x01ee8120, 0x00000000 },
+   { 0x00800801, 0x20f00236, 0x01ee8130, 0x00000000 },
+   { 0x00800401, 0x21000236, 0x01ee8140, 0x00000000 },
+   { 0x00800801, 0x21100236, 0x01ee8150, 0x00000000 },
+   { 0x00800401, 0x21200236, 0x01ee8160, 0x00000000 },
+   { 0x00800801, 0x21300236, 0x01ee8170, 0x00000000 },
+   { 0x00200401, 0x204001a5, 0x00450064, 0x00000000 },
+   { 0x00000801, 0x20480061, 0x00000000, 0x000f000f },
+   { 0x01600031, 0x21401c21, 0x508d0040, 0x1218a000 },
+   { 0x00000001, 0x220001ec, 0x00000000, 0x03400340 },
+   { 0x00800401, 0x41600236, 0x00d28000, 0x00000000 },
+   { 0x00800801, 0x41610236, 0x00d28080, 0x00000000 },
+   { 0x00800401, 0x41800236, 0x00d28020, 0x00000000 },
+   { 0x00800801, 0x41810236, 0x00d280a0, 0x00000000 },
+   { 0x00800401, 0x41a00236, 0x00d28040, 0x00000000 },
+   { 0x00800801, 0x41a10236, 0x00d280c0, 0x00000000 },
+   { 0x00800401, 0x41c00236, 0x00d28060, 0x00000000 },
+   { 0x00800801, 0x41c10236, 0x00d280e0, 0x00000000 },
+   { 0x0000040c, 0x20443ca5, 0x00000044, 0x00010001 },
+   { 0x00000801, 0x20480061, 0x00000000, 0x0007000f },
+   { 0x0a600031, 0x21601c21, 0x508d0040, 0x0a18a001 },
+   { 0x00000001, 0x21400021, 0x00000140, 0x00000000 },
+   { 0x00000001, 0x21600021, 0x00000160, 0x00000000 },
+   { 0x01600031, 0x20001c20, 0x708d0000, 0x82000010 },
+   { 0x00600001, 0x20400021, 0x008d0000, 0x00000000 },
+   { 0x00000005, 0x20203e2d, 0x00000061, 0x001f001f },
+   { 0x00200009, 0x20643e2d, 0x00450064, 0x00040004 },
+   { 0x00000001, 0x203a01ed, 0x00000000, 0x00000000 },
+   { 0x01000010, 0x20003dac, 0x00000020, 0x00160016 },
+   { 0x00110220, 0x34001c00, 0x00001400, 0x0000001e },
+   { 0x01200010, 0x20003e2c, 0x0200006c, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x02001400, 0x00000024 },
+   { 0x00800009, 0x25403dad, 0x00050064, 0x00020002 },
+   { 0x00000001, 0x203a01ed, 0x00000000, 0x00180018 },
+   { 0x00200040, 0x45483dad, 0x00660548, 0x00100010 },
+   { 0x00200040, 0x45523dad, 0x00660552, 0x00100010 },
+   { 0x00400040, 0x25583dad, 0x00690558, 0x00100010 },
+   { 0x00800040, 0x208035ad, 0x00b10080, 0x00b10540 },
+   { 0x00600040, 0x45403dad, 0x00ae0540, 0x00200020 },
+   { 0x00800040, 0x20a035ad, 0x00b100a0, 0x00b10540 },
+   { 0x00600040, 0x45423dad, 0x00ae0542, 0x00200020 },
+   { 0x00800040, 0x20e035ad, 0x00b100e0, 0x00b10540 },
+   { 0x00600040, 0x45403dad, 0x00ae0540, 0xffe0ffe0 },
+   { 0x00800040, 0x20c035ad, 0x00b100c0, 0x00b10540 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x00000014 },
+   { 0x06600010, 0x20003dac, 0x02000020, 0x00030003 },
+   { 0x00000001, 0x206c0171, 0x00000000, 0x00000000 },
+   { 0x00610001, 0x208000a5, 0x02050080, 0x00000000 },
+   { 0x00610001, 0x212000a5, 0x02090100, 0x00000000 },
+   { 0x00410001, 0x211000a5, 0x02690100, 0x00000000 },
+   { 0x00200009, 0x25403dad, 0x00450064, 0x00020002 },
+   { 0x00800040, 0x208035ad, 0x00b10080, 0x00050540 },
+   { 0x00200040, 0x40883dad, 0x00660088, 0x00200020 },
+   { 0x00200040, 0x40923dad, 0x00660092, 0x00200020 },
+   { 0x00400040, 0x20983dad, 0x00690098, 0x00200020 },
+   { 0x00200401, 0x22080060, 0x00000000, 0x03400140 },
+   { 0x00000c01, 0x220c0060, 0x00000000, 0x04400080 },
+   { 0x00000801, 0x22040060, 0x00000000, 0x01000070 },
+   { 0x00000005, 0x203e2e29, 0x00000063, 0x00010001 },
+   { 0x00000001, 0x20200169, 0x00000000, 0x00000000 },
+   { 0x0000000c, 0x2458262d, 0x0000006d, 0x00000020 },
+   { 0x00000001, 0x210e0169, 0x00000000, 0x00010001 },
+   { 0x00000005, 0x24583dad, 0x00000458, 0x00030003 },
+   { 0x01000010, 0x200035ac, 0x0000010e, 0x00000458 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x00000316 },
+   { 0x01000010, 0x20003dac, 0x0200010e, 0x00010001 },
+   { 0x00010401, 0x24540061, 0x02000000, 0x06c00640 },
+   { 0x00010805, 0x245a3e2d, 0x02008800, 0x007f007f },
+   { 0x00110401, 0x24540061, 0x02000000, 0x04800780 },
+   { 0x00110805, 0x245a3e2d, 0x02008804, 0x007f007f },
+   { 0x00010005, 0x245c3e2d, 0x02008800, 0x00800080 },
+   { 0x00110005, 0x245c3e2d, 0x02008804, 0x00800080 },
+   { 0x00000009, 0x245c3dad, 0x0000045c, 0x00010001 },
+   { 0x0000000c, 0x211e362d, 0x0000006c, 0x00000020 },
+   { 0x00000040, 0x240035ac, 0x0000003e, 0x0000045c },
+   { 0x01000010, 0x20003d8c, 0x00210400, 0x00010001 },
+   { 0x01000010, 0x20003d8c, 0x02210400, 0x01000100 },
+   { 0x00000001, 0x203c01ed, 0x00000000, 0x00000000 },
+   { 0x00010001, 0x203c01ed, 0x00000000, 0x00020002 },
+   { 0x00010001, 0x203c01ed, 0x02000000, 0xfffefffe },
+   { 0x00000040, 0x20780d21, 0x0000045a, 0x0208e602 },
+   { 0x00000040, 0x20782421, 0x00000078, 0x0000045c },
+   { 0x02000005, 0x20003dac, 0x0200011e, 0x00030003 },
+   { 0x00010220, 0x34001c00, 0x02001400, 0x000001c0 },
+   { 0x01000005, 0x20003dac, 0x00009800, 0x00030003 },
+   { 0x00200005, 0x24443dad, 0x00459800, 0x00030003 },
+   { 0x0020000c, 0x24403dad, 0x00459800, 0x00020002 },
+   { 0x01600006, 0x20003dac, 0x02000446, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x00000012 },
+   { 0x00010040, 0x22000c20, 0x02000078, 0x00400000 },
+   { 0x00110040, 0x22000c20, 0x02000078, 0x00700000 },
+   { 0x00310040, 0x20401da5, 0x02450440, 0xfffffffe },
+   { 0x00110001, 0x20480061, 0x02000000, 0x000c000c },
+   { 0x00010040, 0x20401da5, 0x02000440, 0xfffffffe },
+   { 0x00010001, 0x204401a5, 0x02000442, 0x00000000 },
+   { 0x00010001, 0x20480061, 0x02000000, 0x0007000c },
+   { 0x01600031, 0x25600021, 0x408d0040, 0x00000200 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x0000000e },
+   { 0x00010040, 0x22000c20, 0x02000078, 0x00200000 },
+   { 0x00110040, 0x22000c20, 0x02000078, 0x00400000 },
+   { 0x00200001, 0x204001a5, 0x00450440, 0x00000000 },
+   { 0x00110040, 0x20441da5, 0x02000442, 0xfffffffe },
+   { 0x00110001, 0x20480061, 0x02000000, 0x000c0007 },
+   { 0x00010001, 0x20480061, 0x02000000, 0x00070007 },
+   { 0x01600031, 0x25600021, 0x408d0040, 0x00000200 },
+   { 0x00000040, 0xb80235ad, 0x00009802, 0x0000003c },
+   { 0x0020040c, 0x24403dad, 0x00459800, 0x00030003 },
+   { 0x00200805, 0x24483dad, 0x00459800, 0x00070007 },
+   { 0x01600006, 0x20003dac, 0x0000044a, 0x00000000 },
+   { 0x00200001, 0x204001a5, 0x00450440, 0x00000000 },
+   { 0x00000009, 0x20403ca5, 0x00000040, 0x00010001 },
+   { 0x00010040, 0x22000c20, 0x00000078, 0x00200010 },
+   { 0x00110040, 0x22000c20, 0x00000078, 0x00300010 },
+   { 0x00010001, 0x20480061, 0x00000000, 0x00030009 },
+   { 0x00110001, 0x20480061, 0x00000000, 0x00040009 },
+   { 0x02600031, 0x27000021, 0x408d0040, 0x00000200 },
+   { 0x01000005, 0x20003dac, 0x00009800, 0x00030003 },
+   { 0x00110220, 0x34001c00, 0x00001400, 0x0000001a },
+   { 0x00600001, 0x26220231, 0x008d05c0, 0x00000000 },
+   { 0x00600401, 0x26120231, 0x008d05b8, 0x00000000 },
+   { 0x00600801, 0x26020231, 0x008d05b0, 0x00000000 },
+   { 0x00600401, 0x25f20231, 0x008d05a8, 0x00000000 },
+   { 0x00600801, 0x25e20231, 0x008d05a0, 0x00000000 },
+   { 0x00600401, 0x25d20231, 0x008d0598, 0x00000000 },
+   { 0x00600801, 0x25c20231, 0x008d0590, 0x00000000 },
+   { 0x00600401, 0x25b20231, 0x008d0588, 0x00000000 },
+   { 0x00600801, 0x25a20231, 0x008d0580, 0x00000000 },
+   { 0x00600401, 0x25920231, 0x008d0578, 0x00000000 },
+   { 0x00600801, 0x25820231, 0x008d0570, 0x00000000 },
+   { 0x00600001, 0x25720231, 0x008d0568, 0x00000000 },
+   { 0x00600001, 0x25620231, 0x008d0560, 0x00000000 },
+   { 0x00110001, 0x220001ec, 0x02000000, 0x05820582 },
+   { 0x00010001, 0x220001ec, 0x02000000, 0x05620562 },
+   { 0x00000001, 0x220e0128, 0x00000454, 0x00000000 },
+   { 0x01800006, 0x200035ac, 0x02000446, 0x00000444 },
+   { 0x00810001, 0xbc000229, 0x02ad8000, 0x00000000 },
+   { 0x00810001, 0xbc200229, 0x02ad8020, 0x00000000 },
+   { 0x00810001, 0xbc400229, 0x02ad8040, 0x00000000 },
+   { 0x00810001, 0xbc600229, 0x02ad8060, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x02001400, 0x0000012a },
+   { 0x00600001, 0x2024018d, 0x008d0200, 0x00000000 },
+   { 0x01000041, 0x245e35ad, 0x00000446, 0x00000444 },
+   { 0x00000040, 0x22022d08, 0x00000200, 0x00100010 },
+   { 0x02000005, 0x20003db0, 0x0200045e, 0x00010001 },
+   { 0x00200040, 0x22042d08, 0x00450200, 0x00200020 },
+   { 0x00400001, 0x244c0109, 0x00690200, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x00000066 },
+   { 0x00010220, 0x34001c00, 0x02001400, 0x00000064 },
+   { 0x00000040, 0x22003d08, 0x00000200, 0xffdeffde },
+   { 0x00000440, 0x22023d08, 0x00000202, 0xffeeffee },
+   { 0x00000801, 0x220c0060, 0x00000000, 0x04a00480 },
+   { 0x01000010, 0x20003db0, 0x0000045e, 0x00040004 },
+   { 0x00a02040, 0x2400462c, 0x00ad8000, 0x00ad8005 },
+   { 0x00a02048, 0x24003e2c, 0x00ad8001, 0xfffbfffb },
+   { 0x00a02048, 0x24003e2c, 0x00ad8002, 0x00140014 },
+   { 0x00a02048, 0x24003e2c, 0x00ad8003, 0x00140014 },
+   { 0x00a02048, 0xb8003e2d, 0x00ad8004, 0xfffbfffb },
+   { 0x00a02040, 0x2400462c, 0x00ad8040, 0x00ad8045 },
+   { 0x00a02048, 0x24003e2c, 0x00ad8041, 0xfffbfffb },
+   { 0x00a02048, 0x24003e2c, 0x00ad8042, 0x00140014 },
+   { 0x00a02048, 0x24003e2c, 0x00ad8043, 0x00140014 },
+   { 0x00a02048, 0xb8403e2d, 0x00ad8044, 0xfffbfffb },
+   { 0x00a02040, 0x2400462c, 0x00ad8080, 0x00ad8085 },
+   { 0x00a02048, 0x24003e2c, 0x00ad8081, 0xfffbfffb },
+   { 0x00a02048, 0x24003e2c, 0x00ad8082, 0x00140014 },
+   { 0x00a02048, 0x24003e2c, 0x00ad8083, 0x00140014 },
+   { 0x00a02048, 0xb8803e2d, 0x00ad8084, 0xfffbfffb },
+   { 0x00600040, 0x2400462c, 0x008d80c0, 0x008d80c5 },
+   { 0x00600048, 0x24003e2c, 0x008d80c1, 0xfffbfffb },
+   { 0x00600048, 0x24003e2c, 0x008d80c2, 0x00140014 },
+   { 0x00600048, 0x24003e2c, 0x008d80c3, 0x00140014 },
+   { 0x00600048, 0xb8c03e2d, 0x008d80c4, 0xfffbfffb },
+   { 0x00000401, 0x22000060, 0x00000000, 0x04a00480 },
+   { 0x00000c01, 0x22040060, 0x00000000, 0x04a00490 },
+   { 0x00010802, 0x220c2d28, 0x00000454, 0x04800480 },
+   { 0x00a02040, 0x24003dac, 0x00b18000, 0x02000200 },
+   { 0x00800048, 0x24003dac, 0x01ed8800, 0xfffbfffb },
+   { 0x00800048, 0x24203dac, 0x01ed8820, 0xfffbfffb },
+   { 0x00a02048, 0x24003dac, 0x00b18020, 0x00140014 },
+   { 0x00800048, 0x24003dac, 0x01ed8820, 0x00140014 },
+   { 0x00800048, 0x24203dac, 0x01ed8840, 0x00140014 },
+   { 0x00a02048, 0x24003dac, 0x00b18040, 0xfffbfffb },
+   { 0x00800048, 0x24003dac, 0x01ed8840, 0x00010001 },
+   { 0x00800048, 0x24203dac, 0x01ed8860, 0x00010001 },
+   { 0x8080000c, 0xd8003d91, 0x00b10400, 0x000a000a },
+   { 0x8080100c, 0xd8203d91, 0x00b10420, 0x000a000a },
+   { 0x00a02040, 0x24003dac, 0x00b18040, 0x02000200 },
+   { 0x00800048, 0x24003dac, 0x01ed8840, 0xfffbfffb },
+   { 0x00800048, 0x24203dac, 0x01ed8860, 0xfffbfffb },
+   { 0x00a02048, 0x24003dac, 0x00b18060, 0x00140014 },
+   { 0x00800048, 0x24003dac, 0x01ed8860, 0x00140014 },
+   { 0x00800048, 0x24203dac, 0x01ed8880, 0x00140014 },
+   { 0x00a02048, 0x24003dac, 0x00b18080, 0xfffbfffb },
+   { 0x00800048, 0x24003dac, 0x01ed8880, 0x00010001 },
+   { 0x00800048, 0x24203dac, 0x01ed88a0, 0x00010001 },
+   { 0x8080000c, 0xd8403d91, 0x00b10400, 0x000a000a },
+   { 0x8080100c, 0xd8603d91, 0x00b10420, 0x000a000a },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x000000b4 },
+   { 0x01000010, 0x20003db0, 0x00000444, 0x00000000 },
+   { 0x01000010, 0x20003db0, 0x02000446, 0x00020002 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x0000004c },
+   { 0x00010220, 0x34001c00, 0x02001400, 0x0000004a },
+   { 0x00400040, 0x22003d28, 0x0069044c, 0xfffefffe },
+   { 0x03400010, 0x20003dac, 0x00000446, 0x00020002 },
+   { 0x01000010, 0x20003db0, 0x02000444, 0x00020002 },
+   { 0x00410040, 0x22002d08, 0x00690200, 0x00100010 },
+   { 0x01000010, 0x20003dac, 0x00000446, 0x00000000 },
+   { 0x00010002, 0x220c2d28, 0x02000454, 0x04800480 },
+   { 0x00800040, 0x24003e2c, 0x01ed8000, 0x00100010 },
+   { 0x00800040, 0x24203e2c, 0x01ed8020, 0x00100010 },
+   { 0x00800048, 0x24003e2c, 0x01ed8001, 0xfffbfffb },
+   { 0x00800048, 0x24203e2c, 0x01ed8021, 0xfffbfffb },
+   { 0x00800048, 0x24003e2c, 0x01ed8002, 0x00140014 },
+   { 0x00800048, 0x24203e2c, 0x01ed8022, 0x00140014 },
+   { 0x00800048, 0x24003e2c, 0x01ed8003, 0x00140014 },
+   { 0x00800048, 0x24203e2c, 0x01ed8023, 0x00140014 },
+   { 0x00800048, 0x24003e2c, 0x01ed8004, 0xfffbfffb },
+   { 0x00800048, 0x24203e2c, 0x01ed8024, 0xfffbfffb },
+   { 0x00800048, 0x24003e2c, 0x01ed8005, 0x00010001 },
+   { 0x00800048, 0x24203e2c, 0x01ed8025, 0x00010001 },
+   { 0x8080000c, 0xd8003d91, 0x00b10400, 0x00050005 },
+   { 0x8080100c, 0xd8203d91, 0x00b10420, 0x00050005 },
+   { 0x00800040, 0x24003e2c, 0x01ed8040, 0x00100010 },
+   { 0x00800040, 0x24203e2c, 0x01ed8060, 0x00100010 },
+   { 0x00800048, 0x24003e2c, 0x01ed8041, 0xfffbfffb },
+   { 0x00800048, 0x24203e2c, 0x01ed8061, 0xfffbfffb },
+   { 0x00800048, 0x24003e2c, 0x01ed8042, 0x00140014 },
+   { 0x00800048, 0x24203e2c, 0x01ed8062, 0x00140014 },
+   { 0x00800048, 0x24003e2c, 0x01ed8043, 0x00140014 },
+   { 0x00800048, 0x24203e2c, 0x01ed8063, 0x00140014 },
+   { 0x00800048, 0x24003e2c, 0x01ed8044, 0xfffbfffb },
+   { 0x00800048, 0x24203e2c, 0x01ed8064, 0xfffbfffb },
+   { 0x00800048, 0x24003e2c, 0x01ed8045, 0x00010001 },
+   { 0x00800048, 0x24203e2c, 0x01ed8065, 0x00010001 },
+   { 0x8080000c, 0xd8403d91, 0x00b10400, 0x00050005 },
+   { 0x8080100c, 0xd8603d91, 0x00b10420, 0x00050005 },
+   { 0x00110220, 0x34001c00, 0x02001400, 0x00000004 },
+   { 0x00110220, 0x34001c00, 0x00001400, 0x0000005c },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x00000062 },
+   { 0x01000010, 0x20003db0, 0x00000446, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x00000042 },
+   { 0x00200401, 0x22000128, 0x0066044c, 0x00000000 },
+   { 0x00200c01, 0x22040128, 0x0045044e, 0x00000000 },
+   { 0x00000801, 0x220c0128, 0x00000454, 0x00000000 },
+   { 0x03400010, 0x20003dac, 0x02000444, 0x00020002 },
+   { 0x01000010, 0x20003dac, 0x00000444, 0x00000000 },
+   { 0x00410040, 0x22002d08, 0x02690200, 0x00010001 },
+   { 0x01000010, 0x20003db0, 0x02000446, 0x00020002 },
+   { 0x00110220, 0x34001c00, 0x00001400, 0x00000002 },
+   { 0x00110001, 0x220c0168, 0x02000000, 0x04800480 },
+   { 0x00a02040, 0x24003e2c, 0x00ad83e0, 0x00100010 },
+   { 0x00800048, 0x24003e2c, 0x01ed8be0, 0xfffbfffb },
+   { 0x00800048, 0x24203e2c, 0x01ed8800, 0xfffbfffb },
+   { 0x00a02048, 0x24003e2c, 0x00ad8000, 0x00140014 },
+   { 0x00800048, 0x24003e2c, 0x01ed8800, 0x00140014 },
+   { 0x00800048, 0x24203e2c, 0x01ed8820, 0x00140014 },
+   { 0x00a02048, 0x24003e2c, 0x00ad8020, 0xfffbfffb },
+   { 0x00800048, 0x24003e2c, 0x01ed8820, 0x00010001 },
+   { 0x00800048, 0x24203e2c, 0x01ed8840, 0x00010001 },
+   { 0x8080000c, 0xd8003d91, 0x00b10400, 0x00050005 },
+   { 0x8080100c, 0xd8203d91, 0x00b10420, 0x00050005 },
+   { 0x00a02040, 0x24003e2c, 0x00ad8020, 0x00100010 },
+   { 0x00800048, 0x24003e2c, 0x01ed8820, 0xfffbfffb },
+   { 0x00800048, 0x24203e2c, 0x01ed8840, 0xfffbfffb },
+   { 0x00a02048, 0x24003e2c, 0x00ad8040, 0x00140014 },
+   { 0x00800048, 0x24003e2c, 0x01ed8840, 0x00140014 },
+   { 0x00800048, 0x24203e2c, 0x01ed8860, 0x00140014 },
+   { 0x00a02048, 0x24003e2c, 0x00ad8060, 0xfffbfffb },
+   { 0x00800048, 0x24003e2c, 0x01ed8860, 0x00010001 },
+   { 0x00800048, 0x24203e2c, 0x01ed8880, 0x00010001 },
+   { 0x8080000c, 0xd8403d91, 0x00b10400, 0x00050005 },
+   { 0x8080100c, 0xd8603d91, 0x00b10420, 0x00050005 },
+   { 0x00110220, 0x34001c00, 0x00001400, 0x00000016 },
+   { 0x00010220, 0x34001c00, 0x02001400, 0x0000001c },
+   { 0x00200401, 0x22000128, 0x0045044c, 0x00000000 },
+   { 0x00000801, 0x220c0128, 0x00000454, 0x00000000 },
+   { 0x01200010, 0x20003dac, 0x00000444, 0x00030003 },
+   { 0x01200010, 0x20003dac, 0x02000446, 0x00030003 },
+   { 0x00210040, 0x22002d08, 0x00450200, 0x00010001 },
+   { 0x00210040, 0x22002d08, 0x02450200, 0x00100010 },
+   { 0x00800001, 0xb8000229, 0x01ed8000, 0x00000000 },
+   { 0x00800001, 0xb8200229, 0x01ed8020, 0x00000000 },
+   { 0x00800001, 0xb8400229, 0x01ed8040, 0x00000000 },
+   { 0x00800001, 0xb8600229, 0x01ed8060, 0x00000000 },
+   { 0x80800042, 0xd8004631, 0x00d29800, 0x00d20480 },
+   { 0x80800042, 0xd8204631, 0x00d29820, 0x00d204a0 },
+   { 0x80800042, 0xd8404631, 0x00d29840, 0x00d204c0 },
+   { 0x80800042, 0xd8604631, 0x00d29860, 0x00d204e0 },
+   { 0x00600001, 0x220001ac, 0x008d0024, 0x00000000 },
+   { 0x00200040, 0x244c3dad, 0x00450448, 0xfff8fff8 },
+   { 0x00000401, 0x220001ec, 0x00000000, 0x07000700 },
+   { 0x00000c01, 0x220201e8, 0x00000000, 0x07100710 },
+   { 0x00000801, 0x220e0128, 0x00000456, 0x00000000 },
+   { 0x00000441, 0x254635ad, 0x00000448, 0x0000044a },
+   { 0x00000c41, 0x254025ad, 0x0000444c, 0x0000444e },
+   { 0x00000c41, 0x254225ad, 0x00000448, 0x0000444e },
+   { 0x00000841, 0x254435ad, 0x0000444c, 0x0000044a },
+   { 0x00200040, 0x244c3d09, 0x00450200, 0x00100010 },
+   { 0x00800041, 0x24002628, 0x00ad8000, 0x00000540 },
+   { 0x00800041, 0x24202628, 0x00ad8020, 0x00000540 },
+   { 0x00800048, 0x24002628, 0x00ad8002, 0x00000542 },
+   { 0x00800048, 0x24202628, 0x00ad8022, 0x00000542 },
+   { 0x00200001, 0x22000128, 0x0045044c, 0x00000000 },
+   { 0x00800048, 0x24002628, 0x01ed8000, 0x00000544 },
+   { 0x00800048, 0x24202628, 0x01ed8020, 0x00000544 },
+   { 0x00800048, 0xbc002629, 0x01ed8002, 0x00000546 },
+   { 0x00801048, 0xbc202629, 0x01ed8022, 0x00000546 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x00000128 },
+   { 0x00000001, 0x20220169, 0x00000000, 0x00040004 },
+   { 0x00200005, 0x24443dad, 0x00459800, 0x00030003 },
+   { 0x0020000c, 0x24403dad, 0x00459800, 0x00020002 },
+   { 0x01600006, 0x20003dac, 0x02000446, 0x00000000 },
+   { 0x00010040, 0x22000c20, 0x02000078, 0x00200000 },
+   { 0x00110040, 0x22000c20, 0x02000078, 0x00500000 },
+   { 0x00310040, 0x20401da5, 0x02450440, 0xfffffffe },
+   { 0x00110001, 0x20480061, 0x02000000, 0x00080008 },
+   { 0x00010040, 0x20401da5, 0x02000440, 0xfffffffe },
+   { 0x00010001, 0x204401a5, 0x02000442, 0x00000000 },
+   { 0x00010001, 0x20480061, 0x02000000, 0x00030008 },
+   { 0x01600031, 0x25600021, 0x408d0040, 0x00000200 },
+   { 0x00000040, 0xb80235ad, 0x00009802, 0x0000003c },
+   { 0x00000040, 0x22000c20, 0x00000078, 0x00100010 },
+   { 0x0020040c, 0x24403dad, 0x00459800, 0x00030003 },
+   { 0x00200805, 0x24483dad, 0x00459800, 0x00070007 },
+   { 0x00200001, 0x204001a5, 0x00450440, 0x00000000 },
+   { 0x00000009, 0x20403ca5, 0x00000040, 0x00010001 },
+   { 0x00000001, 0x20480061, 0x00000000, 0x00020005 },
+   { 0x02600031, 0x27000021, 0x408d0040, 0x00000200 },
+   { 0x00110001, 0x220001ec, 0x02000000, 0x05820582 },
+   { 0x00010001, 0x220001ec, 0x02000000, 0x05620562 },
+   { 0x00000001, 0x220e0128, 0x00000454, 0x00000000 },
+   { 0x01800006, 0x200035ac, 0x02000446, 0x00000444 },
+   { 0x00410001, 0xbc000229, 0x02698000, 0x00000000 },
+   { 0x00410001, 0xbc100229, 0x02698010, 0x00000000 },
+   { 0x00410001, 0xbc200229, 0x02698020, 0x00000000 },
+   { 0x00410001, 0xbc300229, 0x02698030, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x02001400, 0x000000be },
+   { 0x00600001, 0x2024018d, 0x008d0200, 0x00000000 },
+   { 0x01000041, 0x245e35ad, 0x00000446, 0x00000444 },
+   { 0x02000005, 0x20003db0, 0x0200045e, 0x00010001 },
+   { 0x00000040, 0x22022d08, 0x00000200, 0x00100010 },
+   { 0x00200040, 0x22042d08, 0x00450200, 0x00200020 },
+   { 0x00400001, 0x244c0109, 0x00690200, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x00000044 },
+   { 0x00010220, 0x34001c00, 0x02001400, 0x00000042 },
+   { 0x00000040, 0x22003d08, 0x00000200, 0xffdeffde },
+   { 0x00000440, 0x22023d08, 0x00000202, 0xffeeffee },
+   { 0x00000801, 0x220c0060, 0x00000000, 0x04d004c0 },
+   { 0x01000010, 0x20003db0, 0x0000045e, 0x00040004 },
+   { 0x00802040, 0x2400462c, 0x00a98000, 0x00a98005 },
+   { 0x00802048, 0x24003e2c, 0x00a98001, 0xfffbfffb },
+   { 0x00802048, 0x24003e2c, 0x00a98002, 0x00140014 },
+   { 0x00802048, 0x24003e2c, 0x00a98003, 0x00140014 },
+   { 0x00802048, 0xb8003e2d, 0x00a98004, 0xfffbfffb },
+   { 0x00802040, 0x2400462c, 0x00a98040, 0x00a98045 },
+   { 0x00802048, 0x24003e2c, 0x00a98041, 0xfffbfffb },
+   { 0x00802048, 0x24003e2c, 0x00a98042, 0x00140014 },
+   { 0x00802048, 0x24003e2c, 0x00a98043, 0x00140014 },
+   { 0x00802048, 0xb8203e2d, 0x00a98044, 0xfffbfffb },
+   { 0x00400040, 0x2400462c, 0x00698080, 0x00698085 },
+   { 0x00400048, 0x24003e2c, 0x00698081, 0xfffbfffb },
+   { 0x00400048, 0x24003e2c, 0x00698082, 0x00140014 },
+   { 0x00400048, 0x24003e2c, 0x00698083, 0x00140014 },
+   { 0x00400048, 0xb8403e2d, 0x00698084, 0xfffbfffb },
+   { 0x00000401, 0x220c0060, 0x00000000, 0x04e004d0 },
+   { 0x00000c01, 0x22000060, 0x00000000, 0x04d004c8 },
+   { 0x00000c01, 0x22040060, 0x00000000, 0x04e004d8 },
+   { 0x00000801, 0x22080060, 0x00000000, 0x04f004e8 },
+   { 0x00800040, 0x24003dac, 0x00b104c0, 0x02000200 },
+   { 0x00800048, 0x24003dac, 0x00b104e0, 0xfffbfffb },
+   { 0x00800048, 0x24003dac, 0x01ed9800, 0x00140014 },
+   { 0x00010001, 0x220c0168, 0x00000000, 0x05400540 },
+   { 0x00110001, 0x220c0168, 0x00000000, 0x04c004c0 },
+   { 0x00800048, 0x24003dac, 0x01e98000, 0xfffbfffb },
+   { 0x00800048, 0x24003dac, 0x01e98020, 0x00010001 },
+   { 0x00800048, 0x24003dac, 0x01e98800, 0x00140014 },
+   { 0x8080000c, 0xd8003d91, 0x00b10400, 0x000a000a },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x00000060 },
+   { 0x01000010, 0x20003db0, 0x00000444, 0x00000000 },
+   { 0x01000010, 0x20003db0, 0x02000446, 0x00020002 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x00000024 },
+   { 0x00010220, 0x34001c00, 0x02001400, 0x00000022 },
+   { 0x00400040, 0x22003d28, 0x0069044c, 0xfffefffe },
+   { 0x03400010, 0x20003dac, 0x00000446, 0x00020002 },
+   { 0x01000010, 0x20003db0, 0x02000444, 0x00020002 },
+   { 0x00410040, 0x22002d08, 0x00690200, 0x00100010 },
+   { 0x01000010, 0x20003dac, 0x00000446, 0x00000000 },
+   { 0x00010001, 0x220e0168, 0x02000000, 0x05400540 },
+   { 0x00110001, 0x220e0168, 0x02000000, 0x04c004c0 },
+   { 0x00800040, 0x24003e2c, 0x01e98000, 0x00100010 },
+   { 0x00800048, 0x24003e2c, 0x01e98001, 0xfffbfffb },
+   { 0x00800048, 0x24003e2c, 0x01e98002, 0x00140014 },
+   { 0x00800048, 0x24003e2c, 0x01e98003, 0x00140014 },
+   { 0x00800048, 0x24003e2c, 0x01e98004, 0xfffbfffb },
+   { 0x00800048, 0x24003e2c, 0x01e98005, 0x00010001 },
+   { 0x8080000c, 0xdc003d91, 0x00b10400, 0x00050005 },
+   { 0x00110220, 0x34001c00, 0x02001400, 0x00000004 },
+   { 0x00110220, 0x34001c00, 0x00001400, 0x00000036 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x00000036 },
+   { 0x01000010, 0x20003db0, 0x00000446, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x00000024 },
+   { 0x03600010, 0x20003dac, 0x02000444, 0x00020002 },
+   { 0x00400401, 0x22000128, 0x0069044c, 0x00000000 },
+   { 0x00400840, 0x22083d2c, 0x0069044c, 0x00100010 },
+   { 0x00610040, 0x22002d08, 0x02690200, 0x00010001 },
+   { 0x01000010, 0x20003dac, 0x00000444, 0x00000000 },
+   { 0x01000010, 0x20003db0, 0x02000446, 0x00020002 },
+   { 0x00800040, 0x24003e2c, 0x01e983e0, 0x00100010 },
+   { 0x00800048, 0x24003e2c, 0x01e98000, 0x00140014 },
+   { 0x00800048, 0x24003e2c, 0x01e98020, 0xfffbfffb },
+   { 0x00800048, 0x24003e2c, 0x01e993e0, 0xfffbfffb },
+   { 0x00800048, 0x24003e2c, 0x01e99000, 0x00140014 },
+   { 0x00800048, 0x24003e2c, 0x01e99020, 0x00010001 },
+   { 0x00000001, 0x220e0168, 0x00000000, 0x05400540 },
+   { 0x00110220, 0x34001c00, 0x00001400, 0x00000002 },
+   { 0x00110001, 0x220e0168, 0x02000000, 0x04c004c0 },
+   { 0x8080000c, 0xdc003d91, 0x00b10400, 0x00050005 },
+   { 0x00110220, 0x34001c00, 0x00001400, 0x0000000e },
+   { 0x00010220, 0x34001c00, 0x02001400, 0x0000000e },
+   { 0x00400001, 0x22000128, 0x0069044c, 0x00000000 },
+   { 0x01400010, 0x20003dac, 0x00000444, 0x00030003 },
+   { 0x01400010, 0x20003dac, 0x02000446, 0x00030003 },
+   { 0x00410040, 0x22002d08, 0x00690200, 0x00010001 },
+   { 0x00410040, 0x22002d08, 0x02690200, 0x00100010 },
+   { 0x00800001, 0x25400229, 0x01e98000, 0x00000000 },
+   { 0x80800042, 0x45404631, 0x00d20540, 0x00d204c0 },
+   { 0x00000001, 0x220c0128, 0x00000454, 0x00000000 },
+   { 0x00400001, 0xd8000231, 0x008a0540, 0x00000000 },
+   { 0x00400001, 0xd8100231, 0x008a0548, 0x00000000 },
+   { 0x00400001, 0xd8200231, 0x008a0550, 0x00000000 },
+   { 0x00400001, 0xd8300231, 0x008a0558, 0x00000000 },
+   { 0x00600001, 0x220001ac, 0x008d0024, 0x00000000 },
+   { 0x00200040, 0x244c3dad, 0x00450448, 0xfff8fff8 },
+   { 0x00000401, 0x220001ec, 0x00000000, 0x07000700 },
+   { 0x00000801, 0x220e0128, 0x00000456, 0x00000000 },
+   { 0x00000441, 0x254635ad, 0x00000448, 0x0000044a },
+   { 0x00000c41, 0x254025ad, 0x0000444c, 0x0000444e },
+   { 0x00000c41, 0x254225ad, 0x00000448, 0x0000444e },
+   { 0x00000841, 0x254435ad, 0x0000444c, 0x0000044a },
+   { 0x00600041, 0x24002628, 0x00898000, 0x00000540 },
+   { 0x00600048, 0x24002628, 0x00898002, 0x00000542 },
+   { 0x00600048, 0x24002628, 0x00898008, 0x00000544 },
+   { 0x00600048, 0x2540262d, 0x0089800a, 0x00000546 },
+   { 0x00400401, 0xbc0001a9, 0x00690540, 0x00000000 },
+   { 0x00400801, 0xbc1001a9, 0x00690548, 0x00000000 },
+   { 0x01000010, 0x20003d2c, 0x00000022, 0x00030003 },
+   { 0x01000040, 0x20223d29, 0x02000022, 0xffffffff },
+   { 0x00000040, 0x220c3d8c, 0x0000020c, 0x00080008 },
+   { 0x00110040, 0x24540c21, 0x00000454, 0x00080008 },
+   { 0x00010040, 0x24540c21, 0x00000454, 0x00180038 },
+   { 0x00110220, 0x34001c00, 0x02001400, 0xfffffee4 },
+   { 0x01800010, 0x20003dac, 0x0200010e, 0x00010001 },
+   { 0x00000040, 0x220c3d8c, 0x0000020c, 0xffe0ffe0 },
+   { 0x00010001, 0x24540061, 0x02000000, 0x06c00640 },
+   { 0x00110001, 0x24540061, 0x02000000, 0x04800780 },
+   { 0x00000001, 0x220e0128, 0x00000456, 0x00000000 },
+   { 0x00800040, 0x24003dac, 0x00b19c00, 0x00200020 },
+   { 0x00800040, 0x24203dac, 0x00b19c20, 0x00200020 },
+   { 0x8080000c, 0xdc003d91, 0x00b10400, 0x00060006 },
+   { 0x8080000c, 0xdc203d91, 0x00b10420, 0x00060006 },
+   { 0x02000040, 0x210e3d29, 0x0200010e, 0xffffffff },
+   { 0x00000040, 0x220c3d8c, 0x0000020c, 0x00040004 },
+   { 0x00110220, 0x34001c00, 0x02001400, 0xfffffce0 },
+   { 0x01000005, 0x25643e2d, 0x00000060, 0x00c000c0 },
+   { 0x01000010, 0x20003dac, 0x02000458, 0x00020002 },
+   { 0x00110220, 0x34001c00, 0x00001400, 0x00000016 },
+   { 0x00010220, 0x34001c00, 0x02001400, 0x0000000c },
+   { 0x01000010, 0x20003dac, 0x00000458, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x00000086 },
+   { 0x00a02001, 0x46400231, 0x00d20780, 0x00000000 },
+   { 0x00a02001, 0x46800231, 0x00d207c0, 0x00000000 },
+   { 0x00a02001, 0x46c00231, 0x00d20480, 0x00000000 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x0000007e },
+   { 0x80a02042, 0x46404631, 0x00d20640, 0x00d20780 },
+   { 0x80a02042, 0x46804631, 0x00d20680, 0x00d207c0 },
+   { 0x80a02042, 0x46c04631, 0x00d206c0, 0x00d20480 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x00000076 },
+   { 0x01000010, 0x20003dac, 0x02000564, 0x00800080 },
+   { 0x00110220, 0x34001c00, 0x02001400, 0x0000000e },
+   { 0x01000010, 0x20003dac, 0x00000458, 0x00020002 },
+   { 0x00110220, 0x34001c00, 0x00001400, 0xffffffe4 },
+   { 0x00200401, 0x256801ed, 0x00000000, 0x00200020 },
+   { 0x00200801, 0x256c01ed, 0x00000000, 0x00060006 },
+   { 0x00400001, 0x258001ed, 0x00000000, 0x00000000 },
+   { 0x00600001, 0x45a001ad, 0x00058c00, 0x00000000 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x00000028 },
+   { 0x02600005, 0x20006e28, 0x02008c0c, 0x88848421 },
+   { 0x0220000c, 0x25663dad, 0x00000458, 0x00010001 },
+   { 0x0000000c, 0x25643dad, 0x00000564, 0x00060006 },
+   { 0x00310001, 0x25c401ad, 0x00000458, 0x00000000 },
+   { 0x00210001, 0x25c00061, 0x00000000, 0x00010001 },
+   { 0x00310040, 0x25c03dad, 0x004545c4, 0x00010001 },
+   { 0x00610001, 0x25a00061, 0x02000000, 0x00000080 },
+   { 0x00710001, 0x45a002ad, 0x02ae8c00, 0x00000000 },
+   { 0x00710001, 0x45a202ad, 0x02ae8c01, 0x00000000 },
+   { 0x00800041, 0x25a035ad, 0x00b105a0, 0x000905c0 },
+   { 0x01200010, 0x20003e2c, 0x0245006e, 0x00000000 },
+   { 0x00310009, 0x244c45ad, 0x02000564, 0x0045006e },
+   { 0x00210001, 0x244c01ed, 0x02000000, 0x00000000 },
+   { 0x0031000c, 0x244c3dad, 0x0245044c, 0x00010001 },
+   { 0x00200009, 0x256835ad, 0x0045044c, 0x00000566 },
+   { 0x00210040, 0x256835ad, 0x02450568, 0x00000566 },
+   { 0x00200040, 0x256c362d, 0x0045006e, 0x00000566 },
+   { 0x00400040, 0x240035ac, 0x00ab05a2, 0x00ab05a6 },
+   { 0x00400040, 0x2400358c, 0x00690400, 0x00000566 },
+   { 0x0040000c, 0x2580358d, 0x00690400, 0x00000566 },
+   { 0x00800041, 0x2400362c, 0x00d20640, 0x000005a0 },
+   { 0x00800041, 0x2420362c, 0x00d20660, 0x000005a0 },
+   { 0x00800048, 0x2400362c, 0x00d20780, 0x000005a4 },
+   { 0x00800048, 0x2420362c, 0x00d207a0, 0x000005a4 },
+   { 0x00800040, 0x2400358c, 0x00b10400, 0x00000568 },
+   { 0x00800040, 0x2420358c, 0x00b10420, 0x00000568 },
+   { 0x0080000c, 0x24c0358d, 0x00b10400, 0x0000056c },
+   { 0x0080000c, 0x24e0358d, 0x00b10420, 0x0000056c },
+   { 0x80800040, 0x464035b1, 0x00b104c0, 0x00000580 },
+   { 0x80800040, 0x466035b1, 0x00b104e0, 0x00000580 },
+   { 0x00800041, 0x2400362c, 0x00d20680, 0x000005a0 },
+   { 0x00800041, 0x2420362c, 0x00d206a0, 0x000005a0 },
+   { 0x00800048, 0x2400362c, 0x00d207c0, 0x000005a4 },
+   { 0x00800048, 0x2420362c, 0x00d207e0, 0x000005a4 },
+   { 0x00800040, 0x2400358c, 0x00b10400, 0x00000568 },
+   { 0x00800040, 0x2420358c, 0x00b10420, 0x00000568 },
+   { 0x0080000c, 0x24c0358d, 0x00b10400, 0x0000056c },
+   { 0x0080000c, 0x24e0358d, 0x00b10420, 0x0000056c },
+   { 0x80800040, 0x468035b1, 0x00b104c0, 0x00000580 },
+   { 0x80800040, 0x46a035b1, 0x00b104e0, 0x00000580 },
+   { 0x00800041, 0x2400362c, 0x00d206c0, 0x000705a8 },
+   { 0x00800041, 0x2420362c, 0x00d206e0, 0x000705a8 },
+   { 0x00800048, 0x2400362c, 0x00d20480, 0x000705ac },
+   { 0x00800048, 0x2420362c, 0x00d204a0, 0x000705ac },
+   { 0x00800040, 0x2400358c, 0x00b10400, 0x0000056a },
+   { 0x00800040, 0x2420358c, 0x00b10420, 0x0000056a },
+   { 0x0080000c, 0x24c0358d, 0x00b10400, 0x0000056e },
+   { 0x0080000c, 0x24e0358d, 0x00b10420, 0x0000056e },
+   { 0x80800040, 0x46c035b1, 0x00b104c0, 0x00050582 },
+   { 0x80800040, 0x46e035b1, 0x00b104e0, 0x00050582 },
+   { 0x01800005, 0x20003d2c, 0x02000020, 0x00020002 },
+   { 0x80800040, 0xd00045b1, 0x00b19000, 0x00d20640 },
+   { 0x80800040, 0xd02045b1, 0x00b19020, 0x00d20660 },
+   { 0x80800040, 0xd04045b1, 0x00b19040, 0x00d20680 },
+   { 0x80800040, 0xd06045b1, 0x00b19060, 0x00d206a0 },
+   { 0x00000040, 0x22083d8c, 0x00000208, 0x00800080 },
+   { 0x80400040, 0xd40045b1, 0x00699400, 0x00ab06c0 },
+   { 0x80400040, 0xd48045b1, 0x00699480, 0x00ab06c2 },
+   { 0x80400040, 0xd42045b1, 0x00699420, 0x00ab06e0 },
+   { 0x80400040, 0xd4a045b1, 0x006994a0, 0x00ab06e2 },
+   { 0x80400040, 0xd41045b1, 0x00699410, 0x00ab06d0 },
+   { 0x80400040, 0xd49045b1, 0x00699490, 0x00ab06d2 },
+   { 0x80400040, 0xd43045b1, 0x00699430, 0x00ab06f0 },
+   { 0x80400040, 0xd4b045b1, 0x006994b0, 0x00ab06f2 },
+   { 0x00000040, 0x220a3d8c, 0x0000020a, 0x00080008 },
+   { 0x00110040, 0x220a3d8c, 0x0200020a, 0x00300030 },
+   { 0x01000010, 0x20003d2c, 0x02000020, 0x00060006 },
+   { 0x00000040, 0x20203d29, 0x00000020, 0x00020002 },
+   { 0x00000040, 0x22040c00, 0x00000204, 0x00100001 },
+   { 0x00000040, 0x220c358c, 0x0000020c, 0x0000003a },
+   { 0x00110220, 0x34001c00, 0x02001400, 0xfffffc1e },
+   { 0x00000001, 0x220001ec, 0x00000000, 0x01400140 },
+   { 0x00000001, 0x220201ec, 0x00000000, 0x01c001c0 },
+   { 0x00800401, 0x20400236, 0x01ee8000, 0x00000000 },
+   { 0x00800801, 0x20500236, 0x01ee8010, 0x00000000 },
+   { 0x00800401, 0x20600236, 0x01ee8020, 0x00000000 },
+   { 0x00800801, 0x20700236, 0x01ee8030, 0x00000000 },
+   { 0x00800401, 0x20800236, 0x01ee8040, 0x00000000 },
+   { 0x00800801, 0x20900236, 0x01ee8050, 0x00000000 },
+   { 0x00800401, 0x20a00236, 0x01ee8060, 0x00000000 },
+   { 0x00800801, 0x20b00236, 0x01ee8070, 0x00000000 },
+   { 0x00800401, 0x20c00236, 0x01ee8100, 0x00000000 },
+   { 0x00800801, 0x20d00236, 0x01ee8110, 0x00000000 },
+   { 0x00800401, 0x20e00236, 0x01ee8120, 0x00000000 },
+   { 0x00800801, 0x20f00236, 0x01ee8130, 0x00000000 },
+   { 0x00800401, 0x21000236, 0x01ee8140, 0x00000000 },
+   { 0x00800801, 0x21100236, 0x01ee8150, 0x00000000 },
+   { 0x00800401, 0x21200236, 0x01ee8160, 0x00000000 },
+   { 0x00800801, 0x21300236, 0x01ee8170, 0x00000000 },
+   { 0x00000040, 0x22000d20, 0x00000062, 0x1218a600 },
+   { 0x00200401, 0x204001a5, 0x00450064, 0x00000000 },
+   { 0x00000801, 0x20480061, 0x00000000, 0x000f000f },
+   { 0x01600031, 0x21400021, 0x508d0040, 0x00000200 },
+   { 0x00000001, 0x220001ec, 0x00000000, 0x03400340 },
+   { 0x00800401, 0x41600236, 0x00d28000, 0x00000000 },
+   { 0x00800801, 0x41610236, 0x00d28080, 0x00000000 },
+   { 0x00800401, 0x41800236, 0x00d28020, 0x00000000 },
+   { 0x00800801, 0x41810236, 0x00d280a0, 0x00000000 },
+   { 0x00800401, 0x41a00236, 0x00d28040, 0x00000000 },
+   { 0x00800801, 0x41a10236, 0x00d280c0, 0x00000000 },
+   { 0x00800401, 0x41c00236, 0x00d28060, 0x00000000 },
+   { 0x00800801, 0x41c10236, 0x00d280e0, 0x00000000 },
+   { 0x00000040, 0x22000d20, 0x00000062, 0x0a18a601 },
+   { 0x0000040c, 0x20443ca5, 0x00000044, 0x00010001 },
+   { 0x00000801, 0x20480061, 0x00000000, 0x0007000f },
+   { 0x0a600031, 0x21600021, 0x508d0040, 0x00000200 },
+   { 0x00000001, 0x21400021, 0x00000140, 0x00000000 },
+   { 0x00000001, 0x21600021, 0x00000160, 0x00000000 },
+   { 0x01600031, 0x20001c20, 0x708d0000, 0x82000010 },
+   { 0x00000000, 0x00000000, 0x00000000, 0x00000000 },
+   { 0x00600001, 0x20400021, 0x008d0000, 0x00000000 },
+   { 0x00000005, 0x20203e2d, 0x00000061, 0x001f001f },
+   { 0x00200009, 0x20643e2d, 0x00450064, 0x00040004 },
+   { 0x00000001, 0x203a01ed, 0x00000000, 0x00000000 },
+   { 0x01000010, 0x20003dac, 0x00000020, 0x00160016 },
+   { 0x00110220, 0x34001c00, 0x00001400, 0x0000001e },
+   { 0x01200010, 0x20003e2c, 0x0200006c, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x02001400, 0x00000024 },
+   { 0x00800009, 0x25403dad, 0x00050064, 0x00020002 },
+   { 0x00000001, 0x203a01ed, 0x00000000, 0x00180018 },
+   { 0x00200040, 0x45483dad, 0x00660548, 0x00100010 },
+   { 0x00200040, 0x45523dad, 0x00660552, 0x00100010 },
+   { 0x00400040, 0x25583dad, 0x00690558, 0x00100010 },
+   { 0x00800040, 0x208035ad, 0x00b10080, 0x00b10540 },
+   { 0x00600040, 0x45403dad, 0x00ae0540, 0x00200020 },
+   { 0x00800040, 0x20a035ad, 0x00b100a0, 0x00b10540 },
+   { 0x00600040, 0x45423dad, 0x00ae0542, 0x00200020 },
+   { 0x00800040, 0x20e035ad, 0x00b100e0, 0x00b10540 },
+   { 0x00600040, 0x45403dad, 0x00ae0540, 0xffe0ffe0 },
+   { 0x00800040, 0x20c035ad, 0x00b100c0, 0x00b10540 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x00000014 },
+   { 0x06600010, 0x20003dac, 0x02000020, 0x00030003 },
+   { 0x00000001, 0x206c0171, 0x00000000, 0x00000000 },
+   { 0x00610001, 0x208000a5, 0x02050080, 0x00000000 },
+   { 0x00610001, 0x212000a5, 0x02090100, 0x00000000 },
+   { 0x00410001, 0x211000a5, 0x02690100, 0x00000000 },
+   { 0x00200009, 0x25403dad, 0x00450064, 0x00020002 },
+   { 0x00800040, 0x208035ad, 0x00b10080, 0x00050540 },
+   { 0x00200040, 0x40883dad, 0x00660088, 0x00200020 },
+   { 0x00200040, 0x40923dad, 0x00660092, 0x00200020 },
+   { 0x00400040, 0x20983dad, 0x00690098, 0x00200020 },
+   { 0x00200401, 0x22080060, 0x00000000, 0x03400140 },
+   { 0x00000c01, 0x220c0060, 0x00000000, 0x04400080 },
+   { 0x00000801, 0x22040060, 0x00000000, 0x01000070 },
+   { 0x02000005, 0x20002e28, 0x00000061, 0x00400040 },
+   { 0x00010005, 0x203e2e29, 0x00000063, 0x00010001 },
+   { 0x00110001, 0x203e0169, 0x00000000, 0x00030003 },
+   { 0x00000001, 0x20200169, 0x00000000, 0x00000000 },
+   { 0x0000000c, 0x2458262d, 0x0000006d, 0x00000020 },
+   { 0x00000001, 0x210e0169, 0x00000000, 0x00010001 },
+   { 0x00000005, 0x24583dad, 0x00000458, 0x00030003 },
+   { 0x01000010, 0x200035ac, 0x0000010e, 0x00000458 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x0000031a },
+   { 0x01000010, 0x20003dac, 0x0200010e, 0x00010001 },
+   { 0x00010401, 0x24540061, 0x02000000, 0x06c00640 },
+   { 0x00010805, 0x245a3e2d, 0x02008800, 0x007f007f },
+   { 0x00110401, 0x24540061, 0x02000000, 0x04800780 },
+   { 0x00110805, 0x245a3e2d, 0x02008804, 0x007f007f },
+   { 0x00010005, 0x245c3e2d, 0x02008800, 0x00800080 },
+   { 0x00110005, 0x245c3e2d, 0x02008804, 0x00800080 },
+   { 0x00000009, 0x245c3dad, 0x0000045c, 0x00010001 },
+   { 0x0000000c, 0x211e362d, 0x0000006c, 0x00000020 },
+   { 0x00000040, 0x240035ac, 0x0000003e, 0x0000045c },
+   { 0x01000010, 0x20003d8c, 0x00210400, 0x00010001 },
+   { 0x01000010, 0x20003d8c, 0x02210400, 0x01000100 },
+   { 0x00000001, 0x203c01ed, 0x00000000, 0x00000000 },
+   { 0x00010001, 0x203c01ed, 0x00000000, 0x00020002 },
+   { 0x00010001, 0x203c01ed, 0x02000000, 0xfffefffe },
+   { 0x02000005, 0x20002e28, 0x00000061, 0x00400040 },
+   { 0x00010040, 0x244c0d21, 0x0000045a, 0x0208e602 },
+   { 0x00110040, 0x20780d21, 0x0000045a, 0x0208a002 },
+   { 0x00010040, 0x20782421, 0x0000044c, 0x0000045c },
+   { 0x02000005, 0x20003dac, 0x0200011e, 0x00030003 },
+   { 0x00010220, 0x34001c00, 0x02001400, 0x000001c0 },
+   { 0x01000005, 0x20003dac, 0x00009800, 0x00030003 },
+   { 0x00200005, 0x24443dad, 0x00459800, 0x00030003 },
+   { 0x0020000c, 0x24403dad, 0x00459800, 0x00020002 },
+   { 0x01600006, 0x20003dac, 0x02000446, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x00000012 },
+   { 0x00010040, 0x22000c20, 0x02000078, 0x00400000 },
+   { 0x00110040, 0x22000c20, 0x02000078, 0x00700000 },
+   { 0x00310040, 0x20401da5, 0x02450440, 0xfffffffe },
+   { 0x00110001, 0x20480061, 0x02000000, 0x000c000c },
+   { 0x00010040, 0x20401da5, 0x02000440, 0xfffffffe },
+   { 0x00010001, 0x204401a5, 0x02000442, 0x00000000 },
+   { 0x00010001, 0x20480061, 0x02000000, 0x0007000c },
+   { 0x01600031, 0x25600021, 0x408d0040, 0x00000200 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x0000000e },
+   { 0x00010040, 0x22000c20, 0x02000078, 0x00200000 },
+   { 0x00110040, 0x22000c20, 0x02000078, 0x00400000 },
+   { 0x00200001, 0x204001a5, 0x00450440, 0x00000000 },
+   { 0x00110040, 0x20441da5, 0x02000442, 0xfffffffe },
+   { 0x00110001, 0x20480061, 0x02000000, 0x000c0007 },
+   { 0x00010001, 0x20480061, 0x02000000, 0x00070007 },
+   { 0x01600031, 0x25600021, 0x408d0040, 0x00000200 },
+   { 0x00000040, 0xb80235ad, 0x00009802, 0x0000003c },
+   { 0x0020040c, 0x24403dad, 0x00459800, 0x00030003 },
+   { 0x00200805, 0x24483dad, 0x00459800, 0x00070007 },
+   { 0x01600006, 0x20003dac, 0x0000044a, 0x00000000 },
+   { 0x00200001, 0x204001a5, 0x00450440, 0x00000000 },
+   { 0x00000009, 0x20403ca5, 0x00000040, 0x00010001 },
+   { 0x00010040, 0x22000c20, 0x00000078, 0x00200010 },
+   { 0x00110040, 0x22000c20, 0x00000078, 0x00300010 },
+   { 0x00010001, 0x20480061, 0x00000000, 0x00030009 },
+   { 0x00110001, 0x20480061, 0x00000000, 0x00040009 },
+   { 0x02600031, 0x27000021, 0x408d0040, 0x00000200 },
+   { 0x01000005, 0x20003dac, 0x00009800, 0x00030003 },
+   { 0x00110220, 0x34001c00, 0x00001400, 0x0000001a },
+   { 0x00600001, 0x26220231, 0x008d05c0, 0x00000000 },
+   { 0x00600401, 0x26120231, 0x008d05b8, 0x00000000 },
+   { 0x00600801, 0x26020231, 0x008d05b0, 0x00000000 },
+   { 0x00600401, 0x25f20231, 0x008d05a8, 0x00000000 },
+   { 0x00600801, 0x25e20231, 0x008d05a0, 0x00000000 },
+   { 0x00600401, 0x25d20231, 0x008d0598, 0x00000000 },
+   { 0x00600801, 0x25c20231, 0x008d0590, 0x00000000 },
+   { 0x00600401, 0x25b20231, 0x008d0588, 0x00000000 },
+   { 0x00600801, 0x25a20231, 0x008d0580, 0x00000000 },
+   { 0x00600401, 0x25920231, 0x008d0578, 0x00000000 },
+   { 0x00600801, 0x25820231, 0x008d0570, 0x00000000 },
+   { 0x00600001, 0x25720231, 0x008d0568, 0x00000000 },
+   { 0x00600001, 0x25620231, 0x008d0560, 0x00000000 },
+   { 0x00110001, 0x220001ec, 0x02000000, 0x05820582 },
+   { 0x00010001, 0x220001ec, 0x02000000, 0x05620562 },
+   { 0x00000001, 0x220e0128, 0x00000454, 0x00000000 },
+   { 0x01800006, 0x200035ac, 0x02000446, 0x00000444 },
+   { 0x00810001, 0xbc000229, 0x02ad8000, 0x00000000 },
+   { 0x00810001, 0xbc200229, 0x02ad8020, 0x00000000 },
+   { 0x00810001, 0xbc400229, 0x02ad8040, 0x00000000 },
+   { 0x00810001, 0xbc600229, 0x02ad8060, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x02001400, 0x0000012a },
+   { 0x00600001, 0x2024018d, 0x008d0200, 0x00000000 },
+   { 0x01000041, 0x245e35ad, 0x00000446, 0x00000444 },
+   { 0x00000040, 0x22022d08, 0x00000200, 0x00100010 },
+   { 0x02000005, 0x20003db0, 0x0200045e, 0x00010001 },
+   { 0x00200040, 0x22042d08, 0x00450200, 0x00200020 },
+   { 0x00400001, 0x244c0109, 0x00690200, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x00000066 },
+   { 0x00010220, 0x34001c00, 0x02001400, 0x00000064 },
+   { 0x00000040, 0x22003d08, 0x00000200, 0xffdeffde },
+   { 0x00000440, 0x22023d08, 0x00000202, 0xffeeffee },
+   { 0x00000801, 0x220c0060, 0x00000000, 0x04a00480 },
+   { 0x01000010, 0x20003db0, 0x0000045e, 0x00040004 },
+   { 0x00a02040, 0x2400462c, 0x00ad8000, 0x00ad8005 },
+   { 0x00a02048, 0x24003e2c, 0x00ad8001, 0xfffbfffb },
+   { 0x00a02048, 0x24003e2c, 0x00ad8002, 0x00140014 },
+   { 0x00a02048, 0x24003e2c, 0x00ad8003, 0x00140014 },
+   { 0x00a02048, 0xb8003e2d, 0x00ad8004, 0xfffbfffb },
+   { 0x00a02040, 0x2400462c, 0x00ad8040, 0x00ad8045 },
+   { 0x00a02048, 0x24003e2c, 0x00ad8041, 0xfffbfffb },
+   { 0x00a02048, 0x24003e2c, 0x00ad8042, 0x00140014 },
+   { 0x00a02048, 0x24003e2c, 0x00ad8043, 0x00140014 },
+   { 0x00a02048, 0xb8403e2d, 0x00ad8044, 0xfffbfffb },
+   { 0x00a02040, 0x2400462c, 0x00ad8080, 0x00ad8085 },
+   { 0x00a02048, 0x24003e2c, 0x00ad8081, 0xfffbfffb },
+   { 0x00a02048, 0x24003e2c, 0x00ad8082, 0x00140014 },
+   { 0x00a02048, 0x24003e2c, 0x00ad8083, 0x00140014 },
+   { 0x00a02048, 0xb8803e2d, 0x00ad8084, 0xfffbfffb },
+   { 0x00600040, 0x2400462c, 0x008d80c0, 0x008d80c5 },
+   { 0x00600048, 0x24003e2c, 0x008d80c1, 0xfffbfffb },
+   { 0x00600048, 0x24003e2c, 0x008d80c2, 0x00140014 },
+   { 0x00600048, 0x24003e2c, 0x008d80c3, 0x00140014 },
+   { 0x00600048, 0xb8c03e2d, 0x008d80c4, 0xfffbfffb },
+   { 0x00000401, 0x22000060, 0x00000000, 0x04a00480 },
+   { 0x00000c01, 0x22040060, 0x00000000, 0x04a00490 },
+   { 0x00010802, 0x220c2d28, 0x00000454, 0x04800480 },
+   { 0x00a02040, 0x24003dac, 0x00b18000, 0x02000200 },
+   { 0x00800048, 0x24003dac, 0x01ed8800, 0xfffbfffb },
+   { 0x00800048, 0x24203dac, 0x01ed8820, 0xfffbfffb },
+   { 0x00a02048, 0x24003dac, 0x00b18020, 0x00140014 },
+   { 0x00800048, 0x24003dac, 0x01ed8820, 0x00140014 },
+   { 0x00800048, 0x24203dac, 0x01ed8840, 0x00140014 },
+   { 0x00a02048, 0x24003dac, 0x00b18040, 0xfffbfffb },
+   { 0x00800048, 0x24003dac, 0x01ed8840, 0x00010001 },
+   { 0x00800048, 0x24203dac, 0x01ed8860, 0x00010001 },
+   { 0x8080000c, 0xd8003d91, 0x00b10400, 0x000a000a },
+   { 0x8080100c, 0xd8203d91, 0x00b10420, 0x000a000a },
+   { 0x00a02040, 0x24003dac, 0x00b18040, 0x02000200 },
+   { 0x00800048, 0x24003dac, 0x01ed8840, 0xfffbfffb },
+   { 0x00800048, 0x24203dac, 0x01ed8860, 0xfffbfffb },
+   { 0x00a02048, 0x24003dac, 0x00b18060, 0x00140014 },
+   { 0x00800048, 0x24003dac, 0x01ed8860, 0x00140014 },
+   { 0x00800048, 0x24203dac, 0x01ed8880, 0x00140014 },
+   { 0x00a02048, 0x24003dac, 0x00b18080, 0xfffbfffb },
+   { 0x00800048, 0x24003dac, 0x01ed8880, 0x00010001 },
+   { 0x00800048, 0x24203dac, 0x01ed88a0, 0x00010001 },
+   { 0x8080000c, 0xd8403d91, 0x00b10400, 0x000a000a },
+   { 0x8080100c, 0xd8603d91, 0x00b10420, 0x000a000a },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x000000b4 },
+   { 0x01000010, 0x20003db0, 0x00000444, 0x00000000 },
+   { 0x01000010, 0x20003db0, 0x02000446, 0x00020002 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x0000004c },
+   { 0x00010220, 0x34001c00, 0x02001400, 0x0000004a },
+   { 0x00400040, 0x22003d28, 0x0069044c, 0xfffefffe },
+   { 0x03400010, 0x20003dac, 0x00000446, 0x00020002 },
+   { 0x01000010, 0x20003db0, 0x02000444, 0x00020002 },
+   { 0x00410040, 0x22002d08, 0x00690200, 0x00100010 },
+   { 0x01000010, 0x20003dac, 0x00000446, 0x00000000 },
+   { 0x00010002, 0x220c2d28, 0x02000454, 0x04800480 },
+   { 0x00800040, 0x24003e2c, 0x01ed8000, 0x00100010 },
+   { 0x00800040, 0x24203e2c, 0x01ed8020, 0x00100010 },
+   { 0x00800048, 0x24003e2c, 0x01ed8001, 0xfffbfffb },
+   { 0x00800048, 0x24203e2c, 0x01ed8021, 0xfffbfffb },
+   { 0x00800048, 0x24003e2c, 0x01ed8002, 0x00140014 },
+   { 0x00800048, 0x24203e2c, 0x01ed8022, 0x00140014 },
+   { 0x00800048, 0x24003e2c, 0x01ed8003, 0x00140014 },
+   { 0x00800048, 0x24203e2c, 0x01ed8023, 0x00140014 },
+   { 0x00800048, 0x24003e2c, 0x01ed8004, 0xfffbfffb },
+   { 0x00800048, 0x24203e2c, 0x01ed8024, 0xfffbfffb },
+   { 0x00800048, 0x24003e2c, 0x01ed8005, 0x00010001 },
+   { 0x00800048, 0x24203e2c, 0x01ed8025, 0x00010001 },
+   { 0x8080000c, 0xd8003d91, 0x00b10400, 0x00050005 },
+   { 0x8080100c, 0xd8203d91, 0x00b10420, 0x00050005 },
+   { 0x00800040, 0x24003e2c, 0x01ed8040, 0x00100010 },
+   { 0x00800040, 0x24203e2c, 0x01ed8060, 0x00100010 },
+   { 0x00800048, 0x24003e2c, 0x01ed8041, 0xfffbfffb },
+   { 0x00800048, 0x24203e2c, 0x01ed8061, 0xfffbfffb },
+   { 0x00800048, 0x24003e2c, 0x01ed8042, 0x00140014 },
+   { 0x00800048, 0x24203e2c, 0x01ed8062, 0x00140014 },
+   { 0x00800048, 0x24003e2c, 0x01ed8043, 0x00140014 },
+   { 0x00800048, 0x24203e2c, 0x01ed8063, 0x00140014 },
+   { 0x00800048, 0x24003e2c, 0x01ed8044, 0xfffbfffb },
+   { 0x00800048, 0x24203e2c, 0x01ed8064, 0xfffbfffb },
+   { 0x00800048, 0x24003e2c, 0x01ed8045, 0x00010001 },
+   { 0x00800048, 0x24203e2c, 0x01ed8065, 0x00010001 },
+   { 0x8080000c, 0xd8403d91, 0x00b10400, 0x00050005 },
+   { 0x8080100c, 0xd8603d91, 0x00b10420, 0x00050005 },
+   { 0x00110220, 0x34001c00, 0x02001400, 0x00000004 },
+   { 0x00110220, 0x34001c00, 0x00001400, 0x0000005c },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x00000062 },
+   { 0x01000010, 0x20003db0, 0x00000446, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x00000042 },
+   { 0x00200401, 0x22000128, 0x0066044c, 0x00000000 },
+   { 0x00200c01, 0x22040128, 0x0045044e, 0x00000000 },
+   { 0x00000801, 0x220c0128, 0x00000454, 0x00000000 },
+   { 0x03400010, 0x20003dac, 0x02000444, 0x00020002 },
+   { 0x01000010, 0x20003dac, 0x00000444, 0x00000000 },
+   { 0x00410040, 0x22002d08, 0x02690200, 0x00010001 },
+   { 0x01000010, 0x20003db0, 0x02000446, 0x00020002 },
+   { 0x00110220, 0x34001c00, 0x00001400, 0x00000002 },
+   { 0x00110001, 0x220c0168, 0x02000000, 0x04800480 },
+   { 0x00a02040, 0x24003e2c, 0x00ad83e0, 0x00100010 },
+   { 0x00800048, 0x24003e2c, 0x01ed8be0, 0xfffbfffb },
+   { 0x00800048, 0x24203e2c, 0x01ed8800, 0xfffbfffb },
+   { 0x00a02048, 0x24003e2c, 0x00ad8000, 0x00140014 },
+   { 0x00800048, 0x24003e2c, 0x01ed8800, 0x00140014 },
+   { 0x00800048, 0x24203e2c, 0x01ed8820, 0x00140014 },
+   { 0x00a02048, 0x24003e2c, 0x00ad8020, 0xfffbfffb },
+   { 0x00800048, 0x24003e2c, 0x01ed8820, 0x00010001 },
+   { 0x00800048, 0x24203e2c, 0x01ed8840, 0x00010001 },
+   { 0x8080000c, 0xd8003d91, 0x00b10400, 0x00050005 },
+   { 0x8080100c, 0xd8203d91, 0x00b10420, 0x00050005 },
+   { 0x00a02040, 0x24003e2c, 0x00ad8020, 0x00100010 },
+   { 0x00800048, 0x24003e2c, 0x01ed8820, 0xfffbfffb },
+   { 0x00800048, 0x24203e2c, 0x01ed8840, 0xfffbfffb },
+   { 0x00a02048, 0x24003e2c, 0x00ad8040, 0x00140014 },
+   { 0x00800048, 0x24003e2c, 0x01ed8840, 0x00140014 },
+   { 0x00800048, 0x24203e2c, 0x01ed8860, 0x00140014 },
+   { 0x00a02048, 0x24003e2c, 0x00ad8060, 0xfffbfffb },
+   { 0x00800048, 0x24003e2c, 0x01ed8860, 0x00010001 },
+   { 0x00800048, 0x24203e2c, 0x01ed8880, 0x00010001 },
+   { 0x8080000c, 0xd8403d91, 0x00b10400, 0x00050005 },
+   { 0x8080100c, 0xd8603d91, 0x00b10420, 0x00050005 },
+   { 0x00110220, 0x34001c00, 0x00001400, 0x00000016 },
+   { 0x00010220, 0x34001c00, 0x02001400, 0x0000001c },
+   { 0x00200401, 0x22000128, 0x0045044c, 0x00000000 },
+   { 0x00000801, 0x220c0128, 0x00000454, 0x00000000 },
+   { 0x01200010, 0x20003dac, 0x00000444, 0x00030003 },
+   { 0x01200010, 0x20003dac, 0x02000446, 0x00030003 },
+   { 0x00210040, 0x22002d08, 0x00450200, 0x00010001 },
+   { 0x00210040, 0x22002d08, 0x02450200, 0x00100010 },
+   { 0x00800001, 0xb8000229, 0x01ed8000, 0x00000000 },
+   { 0x00800001, 0xb8200229, 0x01ed8020, 0x00000000 },
+   { 0x00800001, 0xb8400229, 0x01ed8040, 0x00000000 },
+   { 0x00800001, 0xb8600229, 0x01ed8060, 0x00000000 },
+   { 0x80800042, 0xd8004631, 0x00d29800, 0x00d20480 },
+   { 0x80800042, 0xd8204631, 0x00d29820, 0x00d204a0 },
+   { 0x80800042, 0xd8404631, 0x00d29840, 0x00d204c0 },
+   { 0x80800042, 0xd8604631, 0x00d29860, 0x00d204e0 },
+   { 0x00600001, 0x220001ac, 0x008d0024, 0x00000000 },
+   { 0x00200040, 0x244c3dad, 0x00450448, 0xfff8fff8 },
+   { 0x00000401, 0x220001ec, 0x00000000, 0x07000700 },
+   { 0x00000c01, 0x220201e8, 0x00000000, 0x07100710 },
+   { 0x00000801, 0x220e0128, 0x00000456, 0x00000000 },
+   { 0x00000441, 0x254635ad, 0x00000448, 0x0000044a },
+   { 0x00000c41, 0x254025ad, 0x0000444c, 0x0000444e },
+   { 0x00000c41, 0x254225ad, 0x00000448, 0x0000444e },
+   { 0x00000841, 0x254435ad, 0x0000444c, 0x0000044a },
+   { 0x00200040, 0x244c3d09, 0x00450200, 0x00100010 },
+   { 0x00800041, 0x24002628, 0x00ad8000, 0x00000540 },
+   { 0x00800041, 0x24202628, 0x00ad8020, 0x00000540 },
+   { 0x00800048, 0x24002628, 0x00ad8002, 0x00000542 },
+   { 0x00800048, 0x24202628, 0x00ad8022, 0x00000542 },
+   { 0x00200001, 0x22000128, 0x0045044c, 0x00000000 },
+   { 0x00800048, 0x24002628, 0x01ed8000, 0x00000544 },
+   { 0x00800048, 0x24202628, 0x01ed8020, 0x00000544 },
+   { 0x00800048, 0xbc002629, 0x01ed8002, 0x00000546 },
+   { 0x00801048, 0xbc202629, 0x01ed8022, 0x00000546 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x00000128 },
+   { 0x00000001, 0x20220169, 0x00000000, 0x00040004 },
+   { 0x00200005, 0x24443dad, 0x00459800, 0x00030003 },
+   { 0x0020000c, 0x24403dad, 0x00459800, 0x00020002 },
+   { 0x01600006, 0x20003dac, 0x02000446, 0x00000000 },
+   { 0x00010040, 0x22000c20, 0x02000078, 0x00200000 },
+   { 0x00110040, 0x22000c20, 0x02000078, 0x00500000 },
+   { 0x00310040, 0x20401da5, 0x02450440, 0xfffffffe },
+   { 0x00110001, 0x20480061, 0x02000000, 0x00080008 },
+   { 0x00010040, 0x20401da5, 0x02000440, 0xfffffffe },
+   { 0x00010001, 0x204401a5, 0x02000442, 0x00000000 },
+   { 0x00010001, 0x20480061, 0x02000000, 0x00030008 },
+   { 0x01600031, 0x25600021, 0x408d0040, 0x00000200 },
+   { 0x00000040, 0xb80235ad, 0x00009802, 0x0000003c },
+   { 0x00000040, 0x22000c20, 0x00000078, 0x00100010 },
+   { 0x0020040c, 0x24403dad, 0x00459800, 0x00030003 },
+   { 0x00200805, 0x24483dad, 0x00459800, 0x00070007 },
+   { 0x00200001, 0x204001a5, 0x00450440, 0x00000000 },
+   { 0x00000009, 0x20403ca5, 0x00000040, 0x00010001 },
+   { 0x00000001, 0x20480061, 0x00000000, 0x00020005 },
+   { 0x02600031, 0x27000021, 0x408d0040, 0x00000200 },
+   { 0x00110001, 0x220001ec, 0x02000000, 0x05820582 },
+   { 0x00010001, 0x220001ec, 0x02000000, 0x05620562 },
+   { 0x00000001, 0x220e0128, 0x00000454, 0x00000000 },
+   { 0x01800006, 0x200035ac, 0x02000446, 0x00000444 },
+   { 0x00410001, 0xbc000229, 0x02698000, 0x00000000 },
+   { 0x00410001, 0xbc100229, 0x02698010, 0x00000000 },
+   { 0x00410001, 0xbc200229, 0x02698020, 0x00000000 },
+   { 0x00410001, 0xbc300229, 0x02698030, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x02001400, 0x000000be },
+   { 0x00600001, 0x2024018d, 0x008d0200, 0x00000000 },
+   { 0x01000041, 0x245e35ad, 0x00000446, 0x00000444 },
+   { 0x02000005, 0x20003db0, 0x0200045e, 0x00010001 },
+   { 0x00000040, 0x22022d08, 0x00000200, 0x00100010 },
+   { 0x00200040, 0x22042d08, 0x00450200, 0x00200020 },
+   { 0x00400001, 0x244c0109, 0x00690200, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x00000044 },
+   { 0x00010220, 0x34001c00, 0x02001400, 0x00000042 },
+   { 0x00000040, 0x22003d08, 0x00000200, 0xffdeffde },
+   { 0x00000440, 0x22023d08, 0x00000202, 0xffeeffee },
+   { 0x00000801, 0x220c0060, 0x00000000, 0x04d004c0 },
+   { 0x01000010, 0x20003db0, 0x0000045e, 0x00040004 },
+   { 0x00802040, 0x2400462c, 0x00a98000, 0x00a98005 },
+   { 0x00802048, 0x24003e2c, 0x00a98001, 0xfffbfffb },
+   { 0x00802048, 0x24003e2c, 0x00a98002, 0x00140014 },
+   { 0x00802048, 0x24003e2c, 0x00a98003, 0x00140014 },
+   { 0x00802048, 0xb8003e2d, 0x00a98004, 0xfffbfffb },
+   { 0x00802040, 0x2400462c, 0x00a98040, 0x00a98045 },
+   { 0x00802048, 0x24003e2c, 0x00a98041, 0xfffbfffb },
+   { 0x00802048, 0x24003e2c, 0x00a98042, 0x00140014 },
+   { 0x00802048, 0x24003e2c, 0x00a98043, 0x00140014 },
+   { 0x00802048, 0xb8203e2d, 0x00a98044, 0xfffbfffb },
+   { 0x00400040, 0x2400462c, 0x00698080, 0x00698085 },
+   { 0x00400048, 0x24003e2c, 0x00698081, 0xfffbfffb },
+   { 0x00400048, 0x24003e2c, 0x00698082, 0x00140014 },
+   { 0x00400048, 0x24003e2c, 0x00698083, 0x00140014 },
+   { 0x00400048, 0xb8403e2d, 0x00698084, 0xfffbfffb },
+   { 0x00000401, 0x220c0060, 0x00000000, 0x04e004d0 },
+   { 0x00000c01, 0x22000060, 0x00000000, 0x04d004c8 },
+   { 0x00000c01, 0x22040060, 0x00000000, 0x04e004d8 },
+   { 0x00000801, 0x22080060, 0x00000000, 0x04f004e8 },
+   { 0x00800040, 0x24003dac, 0x00b104c0, 0x02000200 },
+   { 0x00800048, 0x24003dac, 0x00b104e0, 0xfffbfffb },
+   { 0x00800048, 0x24003dac, 0x01ed9800, 0x00140014 },
+   { 0x00010001, 0x220c0168, 0x00000000, 0x05400540 },
+   { 0x00110001, 0x220c0168, 0x00000000, 0x04c004c0 },
+   { 0x00800048, 0x24003dac, 0x01e98000, 0xfffbfffb },
+   { 0x00800048, 0x24003dac, 0x01e98020, 0x00010001 },
+   { 0x00800048, 0x24003dac, 0x01e98800, 0x00140014 },
+   { 0x8080000c, 0xd8003d91, 0x00b10400, 0x000a000a },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x00000060 },
+   { 0x01000010, 0x20003db0, 0x00000444, 0x00000000 },
+   { 0x01000010, 0x20003db0, 0x02000446, 0x00020002 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x00000024 },
+   { 0x00010220, 0x34001c00, 0x02001400, 0x00000022 },
+   { 0x00400040, 0x22003d28, 0x0069044c, 0xfffefffe },
+   { 0x03400010, 0x20003dac, 0x00000446, 0x00020002 },
+   { 0x01000010, 0x20003db0, 0x02000444, 0x00020002 },
+   { 0x00410040, 0x22002d08, 0x00690200, 0x00100010 },
+   { 0x01000010, 0x20003dac, 0x00000446, 0x00000000 },
+   { 0x00010001, 0x220e0168, 0x02000000, 0x05400540 },
+   { 0x00110001, 0x220e0168, 0x02000000, 0x04c004c0 },
+   { 0x00800040, 0x24003e2c, 0x01e98000, 0x00100010 },
+   { 0x00800048, 0x24003e2c, 0x01e98001, 0xfffbfffb },
+   { 0x00800048, 0x24003e2c, 0x01e98002, 0x00140014 },
+   { 0x00800048, 0x24003e2c, 0x01e98003, 0x00140014 },
+   { 0x00800048, 0x24003e2c, 0x01e98004, 0xfffbfffb },
+   { 0x00800048, 0x24003e2c, 0x01e98005, 0x00010001 },
+   { 0x8080000c, 0xdc003d91, 0x00b10400, 0x00050005 },
+   { 0x00110220, 0x34001c00, 0x02001400, 0x00000004 },
+   { 0x00110220, 0x34001c00, 0x00001400, 0x00000036 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x00000036 },
+   { 0x01000010, 0x20003db0, 0x00000446, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x00000024 },
+   { 0x03600010, 0x20003dac, 0x02000444, 0x00020002 },
+   { 0x00400401, 0x22000128, 0x0069044c, 0x00000000 },
+   { 0x00400840, 0x22083d2c, 0x0069044c, 0x00100010 },
+   { 0x00610040, 0x22002d08, 0x02690200, 0x00010001 },
+   { 0x01000010, 0x20003dac, 0x00000444, 0x00000000 },
+   { 0x01000010, 0x20003db0, 0x02000446, 0x00020002 },
+   { 0x00800040, 0x24003e2c, 0x01e983e0, 0x00100010 },
+   { 0x00800048, 0x24003e2c, 0x01e98000, 0x00140014 },
+   { 0x00800048, 0x24003e2c, 0x01e98020, 0xfffbfffb },
+   { 0x00800048, 0x24003e2c, 0x01e993e0, 0xfffbfffb },
+   { 0x00800048, 0x24003e2c, 0x01e99000, 0x00140014 },
+   { 0x00800048, 0x24003e2c, 0x01e99020, 0x00010001 },
+   { 0x00000001, 0x220e0168, 0x00000000, 0x05400540 },
+   { 0x00110220, 0x34001c00, 0x00001400, 0x00000002 },
+   { 0x00110001, 0x220e0168, 0x02000000, 0x04c004c0 },
+   { 0x8080000c, 0xdc003d91, 0x00b10400, 0x00050005 },
+   { 0x00110220, 0x34001c00, 0x00001400, 0x0000000e },
+   { 0x00010220, 0x34001c00, 0x02001400, 0x0000000e },
+   { 0x00400001, 0x22000128, 0x0069044c, 0x00000000 },
+   { 0x01400010, 0x20003dac, 0x00000444, 0x00030003 },
+   { 0x01400010, 0x20003dac, 0x02000446, 0x00030003 },
+   { 0x00410040, 0x22002d08, 0x00690200, 0x00010001 },
+   { 0x00410040, 0x22002d08, 0x02690200, 0x00100010 },
+   { 0x00800001, 0x25400229, 0x01e98000, 0x00000000 },
+   { 0x80800042, 0x45404631, 0x00d20540, 0x00d204c0 },
+   { 0x00000001, 0x220c0128, 0x00000454, 0x00000000 },
+   { 0x00400001, 0xd8000231, 0x008a0540, 0x00000000 },
+   { 0x00400001, 0xd8100231, 0x008a0548, 0x00000000 },
+   { 0x00400001, 0xd8200231, 0x008a0550, 0x00000000 },
+   { 0x00400001, 0xd8300231, 0x008a0558, 0x00000000 },
+   { 0x00600001, 0x220001ac, 0x008d0024, 0x00000000 },
+   { 0x00200040, 0x244c3dad, 0x00450448, 0xfff8fff8 },
+   { 0x00000401, 0x220001ec, 0x00000000, 0x07000700 },
+   { 0x00000801, 0x220e0128, 0x00000456, 0x00000000 },
+   { 0x00000441, 0x254635ad, 0x00000448, 0x0000044a },
+   { 0x00000c41, 0x254025ad, 0x0000444c, 0x0000444e },
+   { 0x00000c41, 0x254225ad, 0x00000448, 0x0000444e },
+   { 0x00000841, 0x254435ad, 0x0000444c, 0x0000044a },
+   { 0x00600041, 0x24002628, 0x00898000, 0x00000540 },
+   { 0x00600048, 0x24002628, 0x00898002, 0x00000542 },
+   { 0x00600048, 0x24002628, 0x00898008, 0x00000544 },
+   { 0x00600048, 0x2540262d, 0x0089800a, 0x00000546 },
+   { 0x00400401, 0xbc0001a9, 0x00690540, 0x00000000 },
+   { 0x00400801, 0xbc1001a9, 0x00690548, 0x00000000 },
+   { 0x01000010, 0x20003d2c, 0x00000022, 0x00030003 },
+   { 0x01000040, 0x20223d29, 0x02000022, 0xffffffff },
+   { 0x00000040, 0x220c3d8c, 0x0000020c, 0x00080008 },
+   { 0x00110040, 0x24540c21, 0x00000454, 0x00080008 },
+   { 0x00010040, 0x24540c21, 0x00000454, 0x00180038 },
+   { 0x00110220, 0x34001c00, 0x02001400, 0xfffffee4 },
+   { 0x01800010, 0x20003dac, 0x0200010e, 0x00010001 },
+   { 0x00000040, 0x220c3d8c, 0x0000020c, 0xffe0ffe0 },
+   { 0x00010001, 0x24540061, 0x02000000, 0x06c00640 },
+   { 0x00110001, 0x24540061, 0x02000000, 0x04800780 },
+   { 0x00000001, 0x220e0128, 0x00000456, 0x00000000 },
+   { 0x00800040, 0x24003dac, 0x00b19c00, 0x00200020 },
+   { 0x00800040, 0x24203dac, 0x00b19c20, 0x00200020 },
+   { 0x8080000c, 0xdc003d91, 0x00b10400, 0x00060006 },
+   { 0x8080000c, 0xdc203d91, 0x00b10420, 0x00060006 },
+   { 0x02000040, 0x210e3d29, 0x0200010e, 0xffffffff },
+   { 0x00000040, 0x220c3d8c, 0x0000020c, 0x00040004 },
+   { 0x00110220, 0x34001c00, 0x02001400, 0xfffffcdc },
+   { 0x01000005, 0x25643e2d, 0x00000060, 0x00c000c0 },
+   { 0x01000010, 0x20003dac, 0x02000458, 0x00020002 },
+   { 0x00110220, 0x34001c00, 0x00001400, 0x00000016 },
+   { 0x00010220, 0x34001c00, 0x02001400, 0x0000000c },
+   { 0x01000010, 0x20003dac, 0x00000458, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x00000086 },
+   { 0x00a02001, 0x46400231, 0x00d20780, 0x00000000 },
+   { 0x00a02001, 0x46800231, 0x00d207c0, 0x00000000 },
+   { 0x00a02001, 0x46c00231, 0x00d20480, 0x00000000 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x0000007e },
+   { 0x80a02042, 0x46404631, 0x00d20640, 0x00d20780 },
+   { 0x80a02042, 0x46804631, 0x00d20680, 0x00d207c0 },
+   { 0x80a02042, 0x46c04631, 0x00d206c0, 0x00d20480 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x00000076 },
+   { 0x01000010, 0x20003dac, 0x02000564, 0x00800080 },
+   { 0x00110220, 0x34001c00, 0x02001400, 0x0000000e },
+   { 0x01000010, 0x20003dac, 0x00000458, 0x00020002 },
+   { 0x00110220, 0x34001c00, 0x00001400, 0xffffffe4 },
+   { 0x00200401, 0x256801ed, 0x00000000, 0x00200020 },
+   { 0x00200801, 0x256c01ed, 0x00000000, 0x00060006 },
+   { 0x00400001, 0x258001ed, 0x00000000, 0x00000000 },
+   { 0x00600001, 0x45a001ad, 0x00058c00, 0x00000000 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x00000028 },
+   { 0x02600005, 0x20006e28, 0x02008c0c, 0x88848421 },
+   { 0x0220000c, 0x25663dad, 0x00000458, 0x00010001 },
+   { 0x0000000c, 0x25643dad, 0x00000564, 0x00060006 },
+   { 0x00310001, 0x25c401ad, 0x00000458, 0x00000000 },
+   { 0x00210001, 0x25c00061, 0x00000000, 0x00010001 },
+   { 0x00310040, 0x25c03dad, 0x004545c4, 0x00010001 },
+   { 0x00610001, 0x25a00061, 0x02000000, 0x00000080 },
+   { 0x00710001, 0x45a002ad, 0x02ae8c00, 0x00000000 },
+   { 0x00710001, 0x45a202ad, 0x02ae8c01, 0x00000000 },
+   { 0x00800041, 0x25a035ad, 0x00b105a0, 0x000905c0 },
+   { 0x01200010, 0x20003e2c, 0x0245006e, 0x00000000 },
+   { 0x00310009, 0x244c45ad, 0x02000564, 0x0045006e },
+   { 0x00210001, 0x244c01ed, 0x02000000, 0x00000000 },
+   { 0x0031000c, 0x244c3dad, 0x0245044c, 0x00010001 },
+   { 0x00200009, 0x256835ad, 0x0045044c, 0x00000566 },
+   { 0x00210040, 0x256835ad, 0x02450568, 0x00000566 },
+   { 0x00200040, 0x256c362d, 0x0045006e, 0x00000566 },
+   { 0x00400040, 0x240035ac, 0x00ab05a2, 0x00ab05a6 },
+   { 0x00400040, 0x2400358c, 0x00690400, 0x00000566 },
+   { 0x0040000c, 0x2580358d, 0x00690400, 0x00000566 },
+   { 0x00800041, 0x2400362c, 0x00d20640, 0x000005a0 },
+   { 0x00800041, 0x2420362c, 0x00d20660, 0x000005a0 },
+   { 0x00800048, 0x2400362c, 0x00d20780, 0x000005a4 },
+   { 0x00800048, 0x2420362c, 0x00d207a0, 0x000005a4 },
+   { 0x00800040, 0x2400358c, 0x00b10400, 0x00000568 },
+   { 0x00800040, 0x2420358c, 0x00b10420, 0x00000568 },
+   { 0x0080000c, 0x24c0358d, 0x00b10400, 0x0000056c },
+   { 0x0080000c, 0x24e0358d, 0x00b10420, 0x0000056c },
+   { 0x80800040, 0x464035b1, 0x00b104c0, 0x00000580 },
+   { 0x80800040, 0x466035b1, 0x00b104e0, 0x00000580 },
+   { 0x00800041, 0x2400362c, 0x00d20680, 0x000005a0 },
+   { 0x00800041, 0x2420362c, 0x00d206a0, 0x000005a0 },
+   { 0x00800048, 0x2400362c, 0x00d207c0, 0x000005a4 },
+   { 0x00800048, 0x2420362c, 0x00d207e0, 0x000005a4 },
+   { 0x00800040, 0x2400358c, 0x00b10400, 0x00000568 },
+   { 0x00800040, 0x2420358c, 0x00b10420, 0x00000568 },
+   { 0x0080000c, 0x24c0358d, 0x00b10400, 0x0000056c },
+   { 0x0080000c, 0x24e0358d, 0x00b10420, 0x0000056c },
+   { 0x80800040, 0x468035b1, 0x00b104c0, 0x00000580 },
+   { 0x80800040, 0x46a035b1, 0x00b104e0, 0x00000580 },
+   { 0x00800041, 0x2400362c, 0x00d206c0, 0x000705a8 },
+   { 0x00800041, 0x2420362c, 0x00d206e0, 0x000705a8 },
+   { 0x00800048, 0x2400362c, 0x00d20480, 0x000705ac },
+   { 0x00800048, 0x2420362c, 0x00d204a0, 0x000705ac },
+   { 0x00800040, 0x2400358c, 0x00b10400, 0x0000056a },
+   { 0x00800040, 0x2420358c, 0x00b10420, 0x0000056a },
+   { 0x0080000c, 0x24c0358d, 0x00b10400, 0x0000056e },
+   { 0x0080000c, 0x24e0358d, 0x00b10420, 0x0000056e },
+   { 0x80800040, 0x46c035b1, 0x00b104c0, 0x00050582 },
+   { 0x80800040, 0x46e035b1, 0x00b104e0, 0x00050582 },
+   { 0x01800005, 0x20003d2c, 0x02000020, 0x00020002 },
+   { 0x80800040, 0xd00045b1, 0x00b19000, 0x00d20640 },
+   { 0x80800040, 0xd02045b1, 0x00b19020, 0x00d20660 },
+   { 0x80800040, 0xd04045b1, 0x00b19040, 0x00d20680 },
+   { 0x80800040, 0xd06045b1, 0x00b19060, 0x00d206a0 },
+   { 0x00000040, 0x22083d8c, 0x00000208, 0x00800080 },
+   { 0x80400040, 0xd40045b1, 0x00699400, 0x00ab06c0 },
+   { 0x80400040, 0xd48045b1, 0x00699480, 0x00ab06c2 },
+   { 0x80400040, 0xd42045b1, 0x00699420, 0x00ab06e0 },
+   { 0x80400040, 0xd4a045b1, 0x006994a0, 0x00ab06e2 },
+   { 0x80400040, 0xd41045b1, 0x00699410, 0x00ab06d0 },
+   { 0x80400040, 0xd49045b1, 0x00699490, 0x00ab06d2 },
+   { 0x80400040, 0xd43045b1, 0x00699430, 0x00ab06f0 },
+   { 0x80400040, 0xd4b045b1, 0x006994b0, 0x00ab06f2 },
+   { 0x00000040, 0x220a3d8c, 0x0000020a, 0x00080008 },
+   { 0x00110040, 0x220a3d8c, 0x0200020a, 0x00300030 },
+   { 0x01000010, 0x20003d2c, 0x02000020, 0x00060006 },
+   { 0x00000040, 0x20203d29, 0x00000020, 0x00020002 },
+   { 0x00000040, 0x22040c00, 0x00000204, 0x00100001 },
+   { 0x00000040, 0x220c358c, 0x0000020c, 0x0000003a },
+   { 0x00110220, 0x34001c00, 0x02001400, 0xfffffc1a },
+   { 0x00000001, 0x220001ec, 0x00000000, 0x01400140 },
+   { 0x00000001, 0x220201ec, 0x00000000, 0x01c001c0 },
+   { 0x00800401, 0x20400236, 0x01ee8000, 0x00000000 },
+   { 0x00800801, 0x20500236, 0x01ee8010, 0x00000000 },
+   { 0x00800401, 0x20600236, 0x01ee8020, 0x00000000 },
+   { 0x00800801, 0x20700236, 0x01ee8030, 0x00000000 },
+   { 0x00800401, 0x20800236, 0x01ee8040, 0x00000000 },
+   { 0x00800801, 0x20900236, 0x01ee8050, 0x00000000 },
+   { 0x00800401, 0x20a00236, 0x01ee8060, 0x00000000 },
+   { 0x00800801, 0x20b00236, 0x01ee8070, 0x00000000 },
+   { 0x00800401, 0x20c00236, 0x01ee8100, 0x00000000 },
+   { 0x00800801, 0x20d00236, 0x01ee8110, 0x00000000 },
+   { 0x00800401, 0x20e00236, 0x01ee8120, 0x00000000 },
+   { 0x00800801, 0x20f00236, 0x01ee8130, 0x00000000 },
+   { 0x00800401, 0x21000236, 0x01ee8140, 0x00000000 },
+   { 0x00800801, 0x21100236, 0x01ee8150, 0x00000000 },
+   { 0x00800401, 0x21200236, 0x01ee8160, 0x00000000 },
+   { 0x00800801, 0x21300236, 0x01ee8170, 0x00000000 },
+   { 0x00000040, 0x22000d20, 0x00000062, 0x1218a000 },
+   { 0x00200401, 0x204001a5, 0x00450064, 0x00000000 },
+   { 0x00000801, 0x20480061, 0x00000000, 0x000f000f },
+   { 0x01600031, 0x21400021, 0x508d0040, 0x00000200 },
+   { 0x00000001, 0x220001ec, 0x00000000, 0x03400340 },
+   { 0x00800401, 0x41600236, 0x00d28000, 0x00000000 },
+   { 0x00800801, 0x41610236, 0x00d28080, 0x00000000 },
+   { 0x00800401, 0x41800236, 0x00d28020, 0x00000000 },
+   { 0x00800801, 0x41810236, 0x00d280a0, 0x00000000 },
+   { 0x00800401, 0x41a00236, 0x00d28040, 0x00000000 },
+   { 0x00800801, 0x41a10236, 0x00d280c0, 0x00000000 },
+   { 0x00800401, 0x41c00236, 0x00d28060, 0x00000000 },
+   { 0x00800801, 0x41c10236, 0x00d280e0, 0x00000000 },
+   { 0x00000040, 0x22000d20, 0x00000062, 0x0a18a001 },
+   { 0x0000040c, 0x20443ca5, 0x00000044, 0x00010001 },
+   { 0x00000801, 0x20480061, 0x00000000, 0x0007000f },
+   { 0x0a600031, 0x21600021, 0x508d0040, 0x00000200 },
+   { 0x00000001, 0x21400021, 0x00000140, 0x00000000 },
+   { 0x00000001, 0x21600021, 0x00000160, 0x00000000 },
+   { 0x01600031, 0x20001c20, 0x708d0000, 0x82000010 },
+   { 0x00000000, 0x00000000, 0x00000000, 0x00000000 },
+   { 0x01000005, 0x20602d29, 0x02000042, 0x00070007 },
+   { 0x01000005, 0x20422d29, 0x00000042, 0xfff8fff8 },
+   { 0x00000001, 0x202001e9, 0x00000000, 0x100c100c },
+   { 0x00600001, 0x27e00021, 0x008d0000, 0x00000000 },
+   { 0x00000009, 0x27e82d21, 0x00000040, 0x00060006 },
+   { 0x00600001, 0x20a00022, 0x008d0000, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x00000100 },
+   { 0x00600001, 0x20200022, 0x008d07e0, 0x00000000 },
+   { 0x01800031, 0x20801d09, 0x408d0000, 0x02488400 },
+   { 0x00600001, 0x20400022, 0x008d07e0, 0x00000000 },
+   { 0x00000040, 0x20480c22, 0x000007e8, 0x00000080 },
+   { 0x02800031, 0x21001d09, 0x408d0000, 0x02488400 },
+   { 0x00600001, 0x20600022, 0x008d07e0, 0x00000000 },
+   { 0x00000040, 0x20680c22, 0x000007e8, 0x00000100 },
+   { 0x03800031, 0x21801d09, 0x408d0000, 0x02488400 },
+   { 0x00600001, 0x20800022, 0x008d07e0, 0x00000000 },
+   { 0x00000040, 0x20880c22, 0x000007e8, 0x00000180 },
+   { 0x04800031, 0x22001d09, 0x408d0000, 0x02488400 },
+   { 0x02600005, 0x20000c20, 0x02000090, 0x00002000 },
+   { 0x00000006, 0x20880c21, 0x00000088, 0x00200000 },
+   { 0x00200009, 0x20845529, 0x0000009c, 0x00450020 },
+   { 0x00200001, 0x40840231, 0x00450094, 0x00000000 },
+   { 0x00310001, 0x20840229, 0x02450094, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x02001400, 0x0000000c },
+   { 0x00800041, 0x24002628, 0x00000095, 0x00000044 },
+   { 0x00800040, 0x24004508, 0x008d0400, 0x00000094 },
+   { 0x00000009, 0x20a82d02, 0x00000404, 0x00060006 },
+   { 0x00802001, 0x20c00022, 0x008d0080, 0x00000000 },
+   { 0x00802001, 0x20800061, 0x00000000, 0x00000000 },
+   { 0x05800031, 0x20001d0c, 0x508d0000, 0x06080300 },
+   { 0x02600005, 0x20000c20, 0x020000d0, 0x00002000 },
+   { 0x00000006, 0x20c80c21, 0x000000c8, 0x00200000 },
+   { 0x00200009, 0x20c45529, 0x000000dc, 0x00450020 },
+   { 0x00200001, 0x40c40231, 0x004500d4, 0x00000000 },
+   { 0x00310001, 0x20c40229, 0x024500d4, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x02001400, 0x0000000c },
+   { 0x00800041, 0x24002628, 0x000000d5, 0x00000044 },
+   { 0x00800040, 0x24004508, 0x008d0400, 0x000000d4 },
+   { 0x00000009, 0x20a82d02, 0x00000404, 0x00060006 },
+   { 0x00802001, 0x20c00022, 0x008d00c0, 0x00000000 },
+   { 0x00802001, 0x20c00061, 0x00000000, 0x00000000 },
+   { 0x05800031, 0x20001d0c, 0x508d0000, 0x06080300 },
+   { 0x02600005, 0x20000c20, 0x02000110, 0x00002000 },
+   { 0x00000006, 0x21080c21, 0x00000108, 0x00200000 },
+   { 0x00200009, 0x21045529, 0x0000011c, 0x00450020 },
+   { 0x00200001, 0x41040231, 0x00450114, 0x00000000 },
+   { 0x00310001, 0x21040229, 0x02450114, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x02001400, 0x0000000c },
+   { 0x00800041, 0x24002628, 0x00000115, 0x00000044 },
+   { 0x00800040, 0x24004508, 0x008d0400, 0x00000114 },
+   { 0x00000009, 0x20a82d02, 0x00000404, 0x00060006 },
+   { 0x00802001, 0x20c00022, 0x008d0100, 0x00000000 },
+   { 0x00802001, 0x21000061, 0x00000000, 0x00000000 },
+   { 0x05800031, 0x20001d0c, 0x508d0000, 0x06080300 },
+   { 0x02600005, 0x20000c20, 0x02000150, 0x00002000 },
+   { 0x00000006, 0x21480c21, 0x00000148, 0x00200000 },
+   { 0x00200009, 0x21445529, 0x0000015c, 0x00450020 },
+   { 0x00200001, 0x41440231, 0x00450154, 0x00000000 },
+   { 0x00310001, 0x21440229, 0x02450154, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x02001400, 0x0000000c },
+   { 0x00800041, 0x24002628, 0x00000155, 0x00000044 },
+   { 0x00800040, 0x24004508, 0x008d0400, 0x00000154 },
+   { 0x00000009, 0x20a82d02, 0x00000404, 0x00060006 },
+   { 0x00802001, 0x20c00022, 0x008d0140, 0x00000000 },
+   { 0x00802001, 0x21400061, 0x00000000, 0x00000000 },
+   { 0x05800031, 0x20001d0c, 0x508d0000, 0x06080300 },
+   { 0x02600005, 0x20000c20, 0x02000190, 0x00002000 },
+   { 0x00000006, 0x21880c21, 0x00000188, 0x00200000 },
+   { 0x00200009, 0x21845529, 0x0000019c, 0x00450020 },
+   { 0x00200001, 0x41840231, 0x00450194, 0x00000000 },
+   { 0x00310001, 0x21840229, 0x02450194, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x02001400, 0x0000000c },
+   { 0x00800041, 0x24002628, 0x00000195, 0x00000044 },
+   { 0x00800040, 0x24004508, 0x008d0400, 0x00000194 },
+   { 0x00000009, 0x20a82d02, 0x00000404, 0x00060006 },
+   { 0x00802001, 0x20c00022, 0x008d0180, 0x00000000 },
+   { 0x00802001, 0x21800061, 0x00000000, 0x00000000 },
+   { 0x05800031, 0x20001d0c, 0x508d0000, 0x06080300 },
+   { 0x02600005, 0x20000c20, 0x020001d0, 0x00002000 },
+   { 0x00000006, 0x21c80c21, 0x000001c8, 0x00200000 },
+   { 0x00200009, 0x21c45529, 0x000001dc, 0x00450020 },
+   { 0x00200001, 0x41c40231, 0x004501d4, 0x00000000 },
+   { 0x00310001, 0x21c40229, 0x024501d4, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x02001400, 0x0000000c },
+   { 0x00800041, 0x24002628, 0x000001d5, 0x00000044 },
+   { 0x00800040, 0x24004508, 0x008d0400, 0x000001d4 },
+   { 0x00000009, 0x20a82d02, 0x00000404, 0x00060006 },
+   { 0x00802001, 0x20c00022, 0x008d01c0, 0x00000000 },
+   { 0x00802001, 0x21c00061, 0x00000000, 0x00000000 },
+   { 0x05800031, 0x20001d0c, 0x508d0000, 0x06080300 },
+   { 0x02600005, 0x20000c20, 0x02000210, 0x00002000 },
+   { 0x00000006, 0x22080c21, 0x00000208, 0x00200000 },
+   { 0x00200009, 0x22045529, 0x0000021c, 0x00450020 },
+   { 0x00200001, 0x42040231, 0x00450214, 0x00000000 },
+   { 0x00310001, 0x22040229, 0x02450214, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x02001400, 0x0000000c },
+   { 0x00800041, 0x24002628, 0x00000215, 0x00000044 },
+   { 0x00800040, 0x24004508, 0x008d0400, 0x00000214 },
+   { 0x00000009, 0x20a82d02, 0x00000404, 0x00060006 },
+   { 0x00802001, 0x20c00022, 0x008d0200, 0x00000000 },
+   { 0x00802001, 0x22000061, 0x00000000, 0x00000000 },
+   { 0x05800031, 0x20001d0c, 0x508d0000, 0x06080300 },
+   { 0x02600005, 0x20000c20, 0x02000250, 0x00002000 },
+   { 0x00000006, 0x22480c21, 0x00000248, 0x00200000 },
+   { 0x00200009, 0x22445529, 0x0000025c, 0x00450020 },
+   { 0x00200001, 0x42440231, 0x00450254, 0x00000000 },
+   { 0x00310001, 0x22440229, 0x02450254, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x02001400, 0x0000000c },
+   { 0x00800041, 0x24002628, 0x00000255, 0x00000044 },
+   { 0x00800040, 0x24004508, 0x008d0400, 0x00000254 },
+   { 0x00000009, 0x20a82d02, 0x00000404, 0x00060006 },
+   { 0x00802001, 0x20c00022, 0x008d0240, 0x00000000 },
+   { 0x00802001, 0x22400061, 0x00000000, 0x00000000 },
+   { 0x05800031, 0x20001d0c, 0x508d0000, 0x06080300 },
+   { 0x01000040, 0x20423dad, 0x00000042, 0xfff8fff8 },
+   { 0x00600001, 0x21600022, 0x008d07e0, 0x00000000 },
+   { 0x00802001, 0x21800022, 0x008d0080, 0x00000000 },
+   { 0x00802001, 0x21c00022, 0x008d00c0, 0x00000000 },
+   { 0x0b800031, 0x20001d0c, 0x508d0000, 0x0a080400 },
+   { 0x00600001, 0x20200022, 0x008d07e0, 0x00000000 },
+   { 0x00000040, 0x20280c22, 0x000007e8, 0x00000080 },
+   { 0x00802001, 0x20400022, 0x008d0100, 0x00000000 },
+   { 0x00802001, 0x20800022, 0x008d0140, 0x00000000 },
+   { 0x01800031, 0x20001d0c, 0x508d0000, 0x0a080400 },
+   { 0x00000040, 0x21680c22, 0x000007e8, 0x00000100 },
+   { 0x00802001, 0x21800022, 0x008d0180, 0x00000000 },
+   { 0x00802001, 0x21c00022, 0x008d01c0, 0x00000000 },
+   { 0x0b800031, 0x20001d0c, 0x508d0000, 0x0a080400 },
+   { 0x00000040, 0x20280c22, 0x000007e8, 0x00000180 },
+   { 0x00802001, 0x20400022, 0x008d0200, 0x00000000 },
+   { 0x00802001, 0x20800022, 0x008d0240, 0x00000000 },
+   { 0x01800031, 0x20001d0c, 0x508d0000, 0x0a080400 },
+   { 0x00000040, 0x27e80c21, 0x000007e8, 0x00000200 },
+   { 0x01000010, 0x20002da0, 0x02000060, 0x00000000 },
+   { 0x00110220, 0x34001c00, 0x00001400, 0xffffff00 },
+   { 0x00010220, 0x34001c00, 0x02001400, 0x00000040 },
+   { 0x00600001, 0x20200022, 0x008d07e0, 0x00000000 },
+   { 0x01800031, 0x20801d09, 0x408d0000, 0x02488400 },
+   { 0x00600001, 0x20400022, 0x008d07e0, 0x00000000 },
+   { 0x00000040, 0x20480c22, 0x000007e8, 0x00000080 },
+   { 0x02800031, 0x21001d09, 0x408d0000, 0x02488400 },
+   { 0x00600001, 0x20600022, 0x008d07e0, 0x00000000 },
+   { 0x00000040, 0x20680c22, 0x000007e8, 0x00000100 },
+   { 0x03800031, 0x21801d09, 0x408d0000, 0x02488400 },
+   { 0x00600001, 0x20800022, 0x008d07e0, 0x00000000 },
+   { 0x00000040, 0x20880c22, 0x000007e8, 0x00000180 },
+   { 0x04800031, 0x22001d09, 0x408d0000, 0x02488400 },
+   { 0x00000001, 0x220400e0, 0x00000000, 0x00a00080 },
+   { 0x00600001, 0x20a00022, 0x008d0000, 0x00000000 },
+   { 0x02600005, 0x20000c20, 0x02008810, 0x00002000 },
+   { 0x01000040, 0x20603dad, 0x00000060, 0xffffffff },
+   { 0x00000006, 0xa8080c21, 0x00008808, 0x00200000 },
+   { 0x00200009, 0xa8045529, 0x0000881c, 0x00450020 },
+   { 0x00200001, 0xc8040231, 0x00458814, 0x00000000 },
+   { 0x00310001, 0xa8040229, 0x02458814, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x02001400, 0x0000000c },
+   { 0x00800041, 0x24002628, 0x00008815, 0x00000044 },
+   { 0x00800040, 0x24004508, 0x008d0400, 0x00008814 },
+   { 0x00000009, 0x20a82d02, 0x00000404, 0x00060006 },
+   { 0x00802001, 0x20c00022, 0x008d8800, 0x00000000 },
+   { 0x00802001, 0xa8000061, 0x00000000, 0x00000000 },
+   { 0x05800031, 0x20001d0c, 0x508d0000, 0x06080300 },
+   { 0x00600001, 0x21600022, 0x008d07e0, 0x00000000 },
+   { 0x00802001, 0x21800022, 0x008d8800, 0x00000000 },
+   { 0x0b800031, 0x20001d0c, 0x508d0000, 0x06080300 },
+   { 0x00000040, 0x27e80c21, 0x000007e8, 0x00000040 },
+   { 0x00000040, 0x22040c00, 0x00000204, 0x00400040 },
+   { 0x00110220, 0x34001c00, 0x00001400, 0xffffffda },
+   { 0x01600031, 0x20001c20, 0x708d0000, 0x82000010 },
+   { 0x00000000, 0x00000000, 0x00000000, 0x00000000 },
+   { 0x00000000, 0x00000000, 0x00000000, 0x00000000 },
+   { 0x00000000, 0x00000000, 0x00000000, 0x00000000 },
+   { 0x01000005, 0x20602d29, 0x02000042, 0x00070007 },
+   { 0x01000005, 0x20422d29, 0x00000042, 0xfff8fff8 },
+   { 0x00600001, 0x27e00021, 0x008d0000, 0x00000000 },
+   { 0x00000009, 0x27e82d21, 0x00000040, 0x00060006 },
+   { 0x00600001, 0x20a00022, 0x008d0000, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x00000260 },
+   { 0x00600001, 0x20200022, 0x008d07e0, 0x00000000 },
+   { 0x01800031, 0x20801d09, 0x408d0000, 0x02488400 },
+   { 0x00600001, 0x20400022, 0x008d07e0, 0x00000000 },
+   { 0x00000040, 0x20480c22, 0x000007e8, 0x00000080 },
+   { 0x02800031, 0x21001d09, 0x408d0000, 0x02488400 },
+   { 0x00600001, 0x20600022, 0x008d07e0, 0x00000000 },
+   { 0x00000040, 0x20680c22, 0x000007e8, 0x00000100 },
+   { 0x03800031, 0x21801d09, 0x408d0000, 0x02488400 },
+   { 0x00600001, 0x20800022, 0x008d07e0, 0x00000000 },
+   { 0x00000040, 0x20880c22, 0x000007e8, 0x00000180 },
+   { 0x04800031, 0x22001d09, 0x408d0000, 0x02488400 },
+   { 0x00200001, 0x20640229, 0x00450094, 0x00000000 },
+   { 0x02600005, 0x20000c20, 0x02000090, 0x01000000 },
+   { 0x02600005, 0x20000c20, 0x00000090, 0x00004000 },
+   { 0x00600041, 0x24003e2c, 0x00000095, 0x00020002 },
+   { 0x00110001, 0x2066018d, 0x02000400, 0x00000000 },
+   { 0x00010040, 0x20663d8d, 0x02000400, 0x00010001 },
+   { 0x00110001, 0x2066022d, 0x00000095, 0x00000000 },
+   { 0x02600005, 0x20000c20, 0x00000090, 0x00002000 },
+   { 0x02600005, 0x20001d20, 0x02000066, 0x00000001 },
+   { 0x00000006, 0x20881c21, 0x00000088, 0x00200000 },
+   { 0x00200001, 0x20840129, 0x00450064, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x0000000e },
+   { 0x00800041, 0x24002528, 0x00000066, 0x00000044 },
+   { 0x00800040, 0x24002508, 0x008d0400, 0x00000064 },
+   { 0x00000009, 0x20a82d02, 0x00000404, 0x00060006 },
+   { 0x00802001, 0x20c00022, 0x008d0080, 0x00000000 },
+   { 0x00802001, 0x20800061, 0x00000000, 0x00000000 },
+   { 0x05800031, 0x20001d0c, 0x508d0000, 0x06080300 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x0000001e },
+   { 0x02600005, 0x20000c20, 0x00000090, 0x00004000 },
+   { 0x00210002, 0x20700421, 0x02450038, 0x00450030 },
+   { 0x00000001, 0x20680129, 0x0000009c, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x0000000e },
+   { 0x02600005, 0x20001d20, 0x0000009c, 0x00000010 },
+   { 0x00210002, 0x20700421, 0x02450028, 0x00450020 },
+   { 0x01600005, 0x20001d20, 0x0200009c, 0x00000001 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x00000006 },
+   { 0x02610005, 0x20001c20, 0x02000090, 0x00008000 },
+   { 0x02610005, 0x20001d20, 0x0200009c, 0x00000010 },
+   { 0x00010006, 0x20681d29, 0x0200009c, 0x00000010 },
+   { 0x02800005, 0x2000452c, 0x02000068, 0x000d0070 },
+   { 0x00000009, 0x20843d09, 0x00000602, 0x000c000c },
+   { 0x00000005, 0x20862d09, 0x00000602, 0xf000f000 },
+   { 0x00200001, 0x40840231, 0x00660064, 0x00000000 },
+   { 0x00200001, 0x20640229, 0x004500d4, 0x00000000 },
+   { 0x02600005, 0x20000c20, 0x020000d0, 0x01000000 },
+   { 0x02600005, 0x20000c20, 0x000000d0, 0x00004000 },
+   { 0x00600041, 0x24003e2c, 0x000000d5, 0x00020002 },
+   { 0x00110001, 0x2066018d, 0x02000400, 0x00000000 },
+   { 0x00010040, 0x20663d8d, 0x02000400, 0x00010001 },
+   { 0x00110001, 0x2066022d, 0x000000d5, 0x00000000 },
+   { 0x02600005, 0x20000c20, 0x000000d0, 0x00002000 },
+   { 0x02600005, 0x20001d20, 0x02000066, 0x00000001 },
+   { 0x00000006, 0x20c81c21, 0x000000c8, 0x00200000 },
+   { 0x00200001, 0x20c40129, 0x00450064, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x0000000e },
+   { 0x00800041, 0x24002528, 0x00000066, 0x00000044 },
+   { 0x00800040, 0x24002508, 0x008d0400, 0x00000064 },
+   { 0x00000009, 0x20a82d02, 0x00000404, 0x00060006 },
+   { 0x00802001, 0x20c00022, 0x008d00c0, 0x00000000 },
+   { 0x00802001, 0x20c00061, 0x00000000, 0x00000000 },
+   { 0x05800031, 0x20001d0c, 0x508d0000, 0x06080300 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x0000001e },
+   { 0x02600005, 0x20000c20, 0x000000d0, 0x00004000 },
+   { 0x00210002, 0x20700421, 0x02450038, 0x00450030 },
+   { 0x00000001, 0x20680129, 0x000000dc, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x0000000e },
+   { 0x02600005, 0x20001d20, 0x000000dc, 0x00000010 },
+   { 0x00210002, 0x20700421, 0x02450028, 0x00450020 },
+   { 0x01600005, 0x20001d20, 0x020000dc, 0x00000001 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x00000006 },
+   { 0x02610005, 0x20001c20, 0x020000d0, 0x00008000 },
+   { 0x02610005, 0x20001d20, 0x020000dc, 0x00000010 },
+   { 0x00010006, 0x20681d29, 0x020000dc, 0x00000010 },
+   { 0x02800005, 0x2000452c, 0x02000068, 0x000d0070 },
+   { 0x00000009, 0x20c43d09, 0x00000602, 0x000c000c },
+   { 0x00000005, 0x20c62d09, 0x00000602, 0xf000f000 },
+   { 0x00200001, 0x40c40231, 0x00660064, 0x00000000 },
+   { 0x00200001, 0x20640229, 0x00450114, 0x00000000 },
+   { 0x02600005, 0x20000c20, 0x02000110, 0x01000000 },
+   { 0x02600005, 0x20000c20, 0x00000110, 0x00004000 },
+   { 0x00600041, 0x24003e2c, 0x00000115, 0x00020002 },
+   { 0x00110001, 0x2066018d, 0x02000400, 0x00000000 },
+   { 0x00010040, 0x20663d8d, 0x02000400, 0x00010001 },
+   { 0x00110001, 0x2066022d, 0x00000115, 0x00000000 },
+   { 0x02600005, 0x20000c20, 0x00000110, 0x00002000 },
+   { 0x02600005, 0x20001d20, 0x02000066, 0x00000001 },
+   { 0x00000006, 0x21081c21, 0x00000108, 0x00200000 },
+   { 0x00200001, 0x21040129, 0x00450064, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x0000000e },
+   { 0x00800041, 0x24002528, 0x00000066, 0x00000044 },
+   { 0x00800040, 0x24002508, 0x008d0400, 0x00000064 },
+   { 0x00000009, 0x20a82d02, 0x00000404, 0x00060006 },
+   { 0x00802001, 0x20c00022, 0x008d0100, 0x00000000 },
+   { 0x00802001, 0x21000061, 0x00000000, 0x00000000 },
+   { 0x05800031, 0x20001d0c, 0x508d0000, 0x06080300 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x0000001e },
+   { 0x02600005, 0x20000c20, 0x00000110, 0x00004000 },
+   { 0x00210002, 0x20700421, 0x02450038, 0x00450030 },
+   { 0x00000001, 0x20680129, 0x0000011c, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x0000000e },
+   { 0x02600005, 0x20001d20, 0x0000011c, 0x00000010 },
+   { 0x00210002, 0x20700421, 0x02450028, 0x00450020 },
+   { 0x01600005, 0x20001d20, 0x0200011c, 0x00000001 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x00000006 },
+   { 0x02610005, 0x20001c20, 0x02000110, 0x00008000 },
+   { 0x02610005, 0x20001d20, 0x0200011c, 0x00000010 },
+   { 0x00010006, 0x20681d29, 0x0200011c, 0x00000010 },
+   { 0x02800005, 0x2000452c, 0x02000068, 0x000d0070 },
+   { 0x00000009, 0x21043d09, 0x00000602, 0x000c000c },
+   { 0x00000005, 0x21062d09, 0x00000602, 0xf000f000 },
+   { 0x00200001, 0x41040231, 0x00660064, 0x00000000 },
+   { 0x00200001, 0x20640229, 0x00450154, 0x00000000 },
+   { 0x02600005, 0x20000c20, 0x02000150, 0x01000000 },
+   { 0x02600005, 0x20000c20, 0x00000150, 0x00004000 },
+   { 0x00600041, 0x24003e2c, 0x00000155, 0x00020002 },
+   { 0x00110001, 0x2066018d, 0x02000400, 0x00000000 },
+   { 0x00010040, 0x20663d8d, 0x02000400, 0x00010001 },
+   { 0x00110001, 0x2066022d, 0x00000155, 0x00000000 },
+   { 0x02600005, 0x20000c20, 0x00000150, 0x00002000 },
+   { 0x02600005, 0x20001d20, 0x02000066, 0x00000001 },
+   { 0x00000006, 0x21481c21, 0x00000148, 0x00200000 },
+   { 0x00200001, 0x21440129, 0x00450064, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x0000000e },
+   { 0x00800041, 0x24002528, 0x00000066, 0x00000044 },
+   { 0x00800040, 0x24002508, 0x008d0400, 0x00000064 },
+   { 0x00000009, 0x20a82d02, 0x00000404, 0x00060006 },
+   { 0x00802001, 0x20c00022, 0x008d0140, 0x00000000 },
+   { 0x00802001, 0x21400061, 0x00000000, 0x00000000 },
+   { 0x05800031, 0x20001d0c, 0x508d0000, 0x06080300 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x0000001e },
+   { 0x02600005, 0x20000c20, 0x00000150, 0x00004000 },
+   { 0x00210002, 0x20700421, 0x02450038, 0x00450030 },
+   { 0x00000001, 0x20680129, 0x0000015c, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x0000000e },
+   { 0x02600005, 0x20001d20, 0x0000015c, 0x00000010 },
+   { 0x00210002, 0x20700421, 0x02450028, 0x00450020 },
+   { 0x01600005, 0x20001d20, 0x0200015c, 0x00000001 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x00000006 },
+   { 0x02610005, 0x20001c20, 0x02000150, 0x00008000 },
+   { 0x02610005, 0x20001d20, 0x0200015c, 0x00000010 },
+   { 0x00010006, 0x20681d29, 0x0200015c, 0x00000010 },
+   { 0x02800005, 0x2000452c, 0x02000068, 0x000d0070 },
+   { 0x00000009, 0x21443d09, 0x00000602, 0x000c000c },
+   { 0x00000005, 0x21462d09, 0x00000602, 0xf000f000 },
+   { 0x00200001, 0x41440231, 0x00660064, 0x00000000 },
+   { 0x00200001, 0x20640229, 0x00450194, 0x00000000 },
+   { 0x02600005, 0x20000c20, 0x02000190, 0x01000000 },
+   { 0x02600005, 0x20000c20, 0x00000190, 0x00004000 },
+   { 0x00600041, 0x24003e2c, 0x00000195, 0x00020002 },
+   { 0x00110001, 0x2066018d, 0x02000400, 0x00000000 },
+   { 0x00010040, 0x20663d8d, 0x02000400, 0x00010001 },
+   { 0x00110001, 0x2066022d, 0x00000195, 0x00000000 },
+   { 0x02600005, 0x20000c20, 0x00000190, 0x00002000 },
+   { 0x02600005, 0x20001d20, 0x02000066, 0x00000001 },
+   { 0x00000006, 0x21881c21, 0x00000188, 0x00200000 },
+   { 0x00200001, 0x21840129, 0x00450064, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x0000000e },
+   { 0x00800041, 0x24002528, 0x00000066, 0x00000044 },
+   { 0x00800040, 0x24002508, 0x008d0400, 0x00000064 },
+   { 0x00000009, 0x20a82d02, 0x00000404, 0x00060006 },
+   { 0x00802001, 0x20c00022, 0x008d0180, 0x00000000 },
+   { 0x00802001, 0x21800061, 0x00000000, 0x00000000 },
+   { 0x05800031, 0x20001d0c, 0x508d0000, 0x06080300 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x0000001e },
+   { 0x02600005, 0x20000c20, 0x00000190, 0x00004000 },
+   { 0x00210002, 0x20700421, 0x02450038, 0x00450030 },
+   { 0x00000001, 0x20680129, 0x0000019c, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x0000000e },
+   { 0x02600005, 0x20001d20, 0x0000019c, 0x00000010 },
+   { 0x00210002, 0x20700421, 0x02450028, 0x00450020 },
+   { 0x01600005, 0x20001d20, 0x0200019c, 0x00000001 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x00000006 },
+   { 0x02610005, 0x20001c20, 0x02000190, 0x00008000 },
+   { 0x02610005, 0x20001d20, 0x0200019c, 0x00000010 },
+   { 0x00010006, 0x20681d29, 0x0200019c, 0x00000010 },
+   { 0x02800005, 0x2000452c, 0x02000068, 0x000d0070 },
+   { 0x00000009, 0x21843d09, 0x00000602, 0x000c000c },
+   { 0x00000005, 0x21862d09, 0x00000602, 0xf000f000 },
+   { 0x00200001, 0x41840231, 0x00660064, 0x00000000 },
+   { 0x00200001, 0x20640229, 0x004501d4, 0x00000000 },
+   { 0x02600005, 0x20000c20, 0x020001d0, 0x01000000 },
+   { 0x02600005, 0x20000c20, 0x000001d0, 0x00004000 },
+   { 0x00600041, 0x24003e2c, 0x000001d5, 0x00020002 },
+   { 0x00110001, 0x2066018d, 0x02000400, 0x00000000 },
+   { 0x00010040, 0x20663d8d, 0x02000400, 0x00010001 },
+   { 0x00110001, 0x2066022d, 0x000001d5, 0x00000000 },
+   { 0x02600005, 0x20000c20, 0x000001d0, 0x00002000 },
+   { 0x02600005, 0x20001d20, 0x02000066, 0x00000001 },
+   { 0x00000006, 0x21c81c21, 0x000001c8, 0x00200000 },
+   { 0x00200001, 0x21c40129, 0x00450064, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x0000000e },
+   { 0x00800041, 0x24002528, 0x00000066, 0x00000044 },
+   { 0x00800040, 0x24002508, 0x008d0400, 0x00000064 },
+   { 0x00000009, 0x20a82d02, 0x00000404, 0x00060006 },
+   { 0x00802001, 0x20c00022, 0x008d01c0, 0x00000000 },
+   { 0x00802001, 0x21c00061, 0x00000000, 0x00000000 },
+   { 0x05800031, 0x20001d0c, 0x508d0000, 0x06080300 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x0000001e },
+   { 0x02600005, 0x20000c20, 0x000001d0, 0x00004000 },
+   { 0x00210002, 0x20700421, 0x02450038, 0x00450030 },
+   { 0x00000001, 0x20680129, 0x000001dc, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x0000000e },
+   { 0x02600005, 0x20001d20, 0x000001dc, 0x00000010 },
+   { 0x00210002, 0x20700421, 0x02450028, 0x00450020 },
+   { 0x01600005, 0x20001d20, 0x020001dc, 0x00000001 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x00000006 },
+   { 0x02610005, 0x20001c20, 0x020001d0, 0x00008000 },
+   { 0x02610005, 0x20001d20, 0x020001dc, 0x00000010 },
+   { 0x00010006, 0x20681d29, 0x020001dc, 0x00000010 },
+   { 0x02800005, 0x2000452c, 0x02000068, 0x000d0070 },
+   { 0x00000009, 0x21c43d09, 0x00000602, 0x000c000c },
+   { 0x00000005, 0x21c62d09, 0x00000602, 0xf000f000 },
+   { 0x00200001, 0x41c40231, 0x00660064, 0x00000000 },
+   { 0x00200001, 0x20640229, 0x00450214, 0x00000000 },
+   { 0x02600005, 0x20000c20, 0x02000210, 0x01000000 },
+   { 0x02600005, 0x20000c20, 0x00000210, 0x00004000 },
+   { 0x00600041, 0x24003e2c, 0x00000215, 0x00020002 },
+   { 0x00110001, 0x2066018d, 0x02000400, 0x00000000 },
+   { 0x00010040, 0x20663d8d, 0x02000400, 0x00010001 },
+   { 0x00110001, 0x2066022d, 0x00000215, 0x00000000 },
+   { 0x02600005, 0x20000c20, 0x00000210, 0x00002000 },
+   { 0x02600005, 0x20001d20, 0x02000066, 0x00000001 },
+   { 0x00000006, 0x22081c21, 0x00000208, 0x00200000 },
+   { 0x00200001, 0x22040129, 0x00450064, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x0000000e },
+   { 0x00800041, 0x24002528, 0x00000066, 0x00000044 },
+   { 0x00800040, 0x24002508, 0x008d0400, 0x00000064 },
+   { 0x00000009, 0x20a82d02, 0x00000404, 0x00060006 },
+   { 0x00802001, 0x20c00022, 0x008d0200, 0x00000000 },
+   { 0x00802001, 0x22000061, 0x00000000, 0x00000000 },
+   { 0x05800031, 0x20001d0c, 0x508d0000, 0x06080300 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x0000001e },
+   { 0x02600005, 0x20000c20, 0x00000210, 0x00004000 },
+   { 0x00210002, 0x20700421, 0x02450038, 0x00450030 },
+   { 0x00000001, 0x20680129, 0x0000021c, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x0000000e },
+   { 0x02600005, 0x20001d20, 0x0000021c, 0x00000010 },
+   { 0x00210002, 0x20700421, 0x02450028, 0x00450020 },
+   { 0x01600005, 0x20001d20, 0x0200021c, 0x00000001 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x00000006 },
+   { 0x02610005, 0x20001c20, 0x02000210, 0x00008000 },
+   { 0x02610005, 0x20001d20, 0x0200021c, 0x00000010 },
+   { 0x00010006, 0x20681d29, 0x0200021c, 0x00000010 },
+   { 0x02800005, 0x2000452c, 0x02000068, 0x000d0070 },
+   { 0x00000009, 0x22043d09, 0x00000602, 0x000c000c },
+   { 0x00000005, 0x22062d09, 0x00000602, 0xf000f000 },
+   { 0x00200001, 0x42040231, 0x00660064, 0x00000000 },
+   { 0x00200001, 0x20640229, 0x00450254, 0x00000000 },
+   { 0x02600005, 0x20000c20, 0x02000250, 0x01000000 },
+   { 0x02600005, 0x20000c20, 0x00000250, 0x00004000 },
+   { 0x00600041, 0x24003e2c, 0x00000255, 0x00020002 },
+   { 0x00110001, 0x2066018d, 0x02000400, 0x00000000 },
+   { 0x00010040, 0x20663d8d, 0x02000400, 0x00010001 },
+   { 0x00110001, 0x2066022d, 0x00000255, 0x00000000 },
+   { 0x02600005, 0x20000c20, 0x00000250, 0x00002000 },
+   { 0x02600005, 0x20001d20, 0x02000066, 0x00000001 },
+   { 0x00000006, 0x22481c21, 0x00000248, 0x00200000 },
+   { 0x00200001, 0x22440129, 0x00450064, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x0000000e },
+   { 0x00800041, 0x24002528, 0x00000066, 0x00000044 },
+   { 0x00800040, 0x24002508, 0x008d0400, 0x00000064 },
+   { 0x00000009, 0x20a82d02, 0x00000404, 0x00060006 },
+   { 0x00802001, 0x20c00022, 0x008d0240, 0x00000000 },
+   { 0x00802001, 0x22400061, 0x00000000, 0x00000000 },
+   { 0x05800031, 0x20001d0c, 0x508d0000, 0x06080300 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x0000001e },
+   { 0x02600005, 0x20000c20, 0x00000250, 0x00004000 },
+   { 0x00210002, 0x20700421, 0x02450038, 0x00450030 },
+   { 0x00000001, 0x20680129, 0x0000025c, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x0000000e },
+   { 0x02600005, 0x20001d20, 0x0000025c, 0x00000010 },
+   { 0x00210002, 0x20700421, 0x02450028, 0x00450020 },
+   { 0x01600005, 0x20001d20, 0x0200025c, 0x00000001 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x00000006 },
+   { 0x02610005, 0x20001c20, 0x02000250, 0x00008000 },
+   { 0x02610005, 0x20001d20, 0x0200025c, 0x00000010 },
+   { 0x00010006, 0x20681d29, 0x0200025c, 0x00000010 },
+   { 0x02800005, 0x2000452c, 0x02000068, 0x000d0070 },
+   { 0x00000009, 0x22443d09, 0x00000602, 0x000c000c },
+   { 0x00000005, 0x22462d09, 0x00000602, 0xf000f000 },
+   { 0x00200001, 0x42440231, 0x00660064, 0x00000000 },
+   { 0x01000040, 0x20423dad, 0x00000042, 0xfff8fff8 },
+   { 0x00600001, 0x21600022, 0x008d07e0, 0x00000000 },
+   { 0x00802001, 0x21800022, 0x008d0080, 0x00000000 },
+   { 0x00802001, 0x21c00022, 0x008d00c0, 0x00000000 },
+   { 0x0b800031, 0x20001d0c, 0x508d0000, 0x0a080400 },
+   { 0x00600001, 0x20200022, 0x008d07e0, 0x00000000 },
+   { 0x00000040, 0x20280c22, 0x000007e8, 0x00000080 },
+   { 0x00802001, 0x20400022, 0x008d0100, 0x00000000 },
+   { 0x00802001, 0x20800022, 0x008d0140, 0x00000000 },
+   { 0x01800031, 0x20001d0c, 0x508d0000, 0x0a080400 },
+   { 0x00000040, 0x21680c22, 0x000007e8, 0x00000100 },
+   { 0x00802001, 0x21800022, 0x008d0180, 0x00000000 },
+   { 0x00802001, 0x21c00022, 0x008d01c0, 0x00000000 },
+   { 0x0b800031, 0x20001d0c, 0x508d0000, 0x0a080400 },
+   { 0x00000040, 0x20280c22, 0x000007e8, 0x00000180 },
+   { 0x00802001, 0x20400022, 0x008d0200, 0x00000000 },
+   { 0x00802001, 0x20800022, 0x008d0240, 0x00000000 },
+   { 0x01800031, 0x20001d0c, 0x508d0000, 0x0a080400 },
+   { 0x00000040, 0x27e80c21, 0x000007e8, 0x00000200 },
+   { 0x01000010, 0x20002da0, 0x02000060, 0x00000000 },
+   { 0x00110220, 0x34001c00, 0x00001400, 0xfffffda0 },
+   { 0x00010220, 0x34001c00, 0x02001400, 0x0000006e },
+   { 0x00600001, 0x20200022, 0x008d07e0, 0x00000000 },
+   { 0x01800031, 0x20801d09, 0x408d0000, 0x02488400 },
+   { 0x00600001, 0x20400022, 0x008d07e0, 0x00000000 },
+   { 0x00000040, 0x20480c22, 0x000007e8, 0x00000080 },
+   { 0x02800031, 0x21001d09, 0x408d0000, 0x02488400 },
+   { 0x00600001, 0x20600022, 0x008d07e0, 0x00000000 },
+   { 0x00000040, 0x20680c22, 0x000007e8, 0x00000100 },
+   { 0x03800031, 0x21801d09, 0x408d0000, 0x02488400 },
+   { 0x00600001, 0x20800022, 0x008d07e0, 0x00000000 },
+   { 0x00000040, 0x20880c22, 0x000007e8, 0x00000180 },
+   { 0x04800031, 0x22001d09, 0x408d0000, 0x02488400 },
+   { 0x00000001, 0x220400e0, 0x00000000, 0x00a00080 },
+   { 0x00600001, 0x20a00022, 0x008d0000, 0x00000000 },
+   { 0x00200001, 0x20640229, 0x00458814, 0x00000000 },
+   { 0x02600005, 0x20000c20, 0x02008810, 0x01000000 },
+   { 0x02600005, 0x20000c20, 0x00008810, 0x00004000 },
+   { 0x00600041, 0x24003e2c, 0x00008815, 0x00020002 },
+   { 0x00110001, 0x2066018d, 0x02000400, 0x00000000 },
+   { 0x00010040, 0x20663d8d, 0x02000400, 0x00010001 },
+   { 0x00110001, 0x2066022d, 0x00008815, 0x00000000 },
+   { 0x02600005, 0x20000c20, 0x00008810, 0x00002000 },
+   { 0x01000040, 0x20603dad, 0x02000060, 0xffffffff },
+   { 0x00000006, 0xa8080c21, 0x00008808, 0x00200000 },
+   { 0x00200001, 0xa8040129, 0x00450064, 0x00000000 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x0000000e },
+   { 0x00800041, 0x24002528, 0x00000066, 0x00000044 },
+   { 0x00800040, 0x24002508, 0x008d0400, 0x00000064 },
+   { 0x00000009, 0x20a82d02, 0x00000404, 0x00060006 },
+   { 0x00802001, 0x20c00022, 0x008d8800, 0x00000000 },
+   { 0x00802001, 0xa8000061, 0x00000000, 0x00000000 },
+   { 0x05800031, 0x20001d0c, 0x508d0000, 0x06080300 },
+   { 0x00000220, 0x34001c00, 0x00001400, 0x00000022 },
+   { 0x02600005, 0x20000d20, 0x02000066, 0x00000001 },
+   { 0x02600005, 0x20000c20, 0x00008810, 0x00004000 },
+   { 0x00000001, 0x20680129, 0x0000881c, 0x00000000 },
+   { 0x00210002, 0x20700421, 0x02450038, 0x00450030 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x0000000e },
+   { 0x02600005, 0x20001d20, 0x0000881c, 0x00000010 },
+   { 0x00210002, 0x20700421, 0x02450028, 0x00450020 },
+   { 0x01600005, 0x20001d20, 0x0200881c, 0x00000001 },
+   { 0x00010220, 0x34001c00, 0x00001400, 0x00000006 },
+   { 0x02610005, 0x20001c20, 0x02008810, 0x00008000 },
+   { 0x02610005, 0x20001d20, 0x0200881c, 0x00000010 },
+   { 0x00010006, 0x20681d29, 0x0200881c, 0x00000010 },
+   { 0x02800005, 0x2000452c, 0x00000068, 0x000d0070 },
+   { 0x01000040, 0x20603dad, 0x02000060, 0x00000000 },
+   { 0x00000009, 0xa8043d09, 0x00000600, 0x000c000c },
+   { 0x00000005, 0xa8062d09, 0x00000600, 0xf000f000 },
+   { 0x00200001, 0xc8040231, 0x00660064, 0x00000000 },
+   { 0x00600001, 0x21600022, 0x008d07e0, 0x00000000 },
+   { 0x00802001, 0x21800022, 0x008d8800, 0x00000000 },
+   { 0x0b800031, 0x20001d0c, 0x508d0000, 0x06080300 },
+   { 0x00000040, 0x27e80c21, 0x000007e8, 0x00000040 },
+   { 0x00000040, 0x22040c00, 0x00000204, 0x00400040 },
+   { 0x00110220, 0x34001c00, 0x02001400, 0xffffffac },
+   { 0x01600031, 0x20001c20, 0x708d0000, 0x82000010 },
+   { 0x01600031, 0x20001c20, 0x708d0000, 0x82000010 },
+   { 0x01600031, 0x20001c20, 0x708d0000, 0x82000010 },
+   { 0x0000007e, 0x00000000, 0x00000000, 0x00000000 },
diff --git a/i965_drv_video/shaders/h264/mc/chromaMVAdjust.asm b/i965_drv_video/shaders/h264/mc/chromaMVAdjust.asm
new file mode 100644
index 0000000..063f554
--- /dev/null
+++ b/i965_drv_video/shaders/h264/mc/chromaMVAdjust.asm
@@ -0,0 +1,27 @@
+/*
+ * Adjust chrom MV
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+// Kernel name: ChromaMVAdjust.asm
+//
+//
+
+
+//#if !defined(__ChromaMVAdjust__)		// Make sure this is only included once
+//#define __ChromaMVAdjust__
+
+
+	// Chroma MV adjustment
+	add (1)		acc0:w				gPARITY:w						gREFPARITY:w
+	cmp.e.f0.0 (1) null:w			acc0:w							0x1:w
+	cmp.e.f0.1 (1) null:w			acc0:w							0x100:w
+	mov (1)		gCHRMVADJ:w			0:w
+	(f0.0) mov (1)	gCHRMVADJ:w		2:w	
+	(f0.1) mov (1)	gCHRMVADJ:w		-2:w
+        
+//#endif	// !defined(__ChromaMVAdjust__)
diff --git a/i965_drv_video/shaders/h264/mc/export.inc b/i965_drv_video/shaders/h264/mc/export.inc
new file mode 100644
index 0000000..1113841
--- /dev/null
+++ b/i965_drv_video/shaders/h264/mc/export.inc
@@ -0,0 +1,209 @@
+#define INTRA_16x16_IP 0
+#define INTRA_16x16_VERTICAL_IP 112
+#define INTRA_16x16_HORIZONTAL_IP 256
+#define INTRA_16x16_DC_IP 416
+#define INTRA_16x16_PLANE_IP 784
+#define End_intra_Pred_16x16_Y_IP 1328
+#define End_add_Error_16x16_Y_IP 1632
+#define load_Intra_Ref_Y_IP 1760
+#define decode_Chroma_Intra_IP 1904
+#define INTRA_CHROMA_DC_IP 2080
+#define INTRA_CHROMA_HORIZONTAL_IP 2560
+#define INTRA_CHROMA_VERTICAL_IP 2656
+#define INTRA_Chroma_PLANE_IP 2736
+#define End_of_intra_Pred_Chroma_IP 3136
+#define save_16x16_Y_IP 3488
+#define INTRA_8x8_IP 3712
+#define INTRA_8x8_BLK2_IP 4544
+#define intra_Pred_8x8_Y_IP 5120
+#define INTRA_8X8_VERTICAL_IP 5376
+#define INTRA_8X8_HORIZONTAL_IP 5456
+#define INTRA_8X8_DC_IP 5536
+#define INTRA_8X8_DIAG_DOWN_LEFT_IP 5792
+#define INTRA_8X8_DIAG_DOWN_RIGHT_IP 5952
+#define INTRA_8X8_VERT_RIGHT_IP 6176
+#define INTRA_8X8_HOR_DOWN_IP 6464
+#define INTRA_8X8_VERT_LEFT_IP 6736
+#define INTRA_8X8_HOR_UP_IP 6896
+#define save_8x8_Y_IP 7088
+#define INTRA_4x4_IP 7424
+#define intra_Pred_4x4_Y_4_IP 8496
+#define ADD_ERROR_SB0_IP 8592
+#define ADD_ERROR_SB1_IP 8704
+#define ADD_ERROR_SB2_IP 8864
+#define ADD_ERROR_SB3_IP 8992
+#define intra_Pred_4x4_Y_IP 9040
+#define INTRA_4X4_VERTICAL_IP 9040
+#define INTRA_4X4_HORIZONTAL_IP 9072
+#define INTRA_4X4_DC_IP 9104
+#define INTRA_4X4_DIAG_DOWN_LEFT_IP 9280
+#define INTRA_4X4_DIAG_DOWN_RIGHT_IP 9392
+#define INTRA_4X4_VERT_RIGHT_IP 9536
+#define INTRA_4X4_HOR_DOWN_IP 9744
+#define INTRA_4X4_VERT_LEFT_IP 9968
+#define INTRA_4X4_HOR_UP_IP 10080
+#define save_4x4_Y_IP 10208
+#define INTRA_PCM_IP 10560
+#define FRAME_MB_IP 11072
+#define INIT_MBPARA_FRM_IP 11120
+#define NOT_8x8_MODE_FRM_IP 11408
+#define CONVERT_MVS_FRM_IP 11488
+#define INIT_ADDRESS_REGS_FRM_IP 11568
+#define LOOP_SUBMB_FRM_IP 11632
+#define LOOP_DIR_FRM_IP 11680
+#define LOADREF_MVXZERO_FRM_IP 12080
+#define EXIT_LOADREF_Y_16x13_FRM_IP 12192
+#define Interpolate_Y_8x8_Func_FRM_IP 12352
+#define Interpolate_Y_8x8_Func2_FRM_IP 12592
+#define Interpolate_Y_H_8x8_FRM_IP 13664
+#define Interpolate_Y_V_8x8_FRM_IP 14320
+#define VFILTER_8x8_FRM_IP 14496
+#define Interpolate_Y_I_8x8_FRM_IP 14880
+#define Average_8x8_FRM_IP 15040
+#define Return_Interpolate_Y_8x8_FRM_IP 15104
+#define Exit_Interpolate_Y_8x8_FRM_IP 15120
+#define Interpolate_C_4x4_Func_FRM_IP 15120
+#define PROCESS4x4_FRM_IP 15424
+#define LOOP_SUBMBPT_FRM_IP 15440
+#define Interpolate_Y_H_4x4_FRM_IP 16528
+#define Interpolate_Y_V_4x4_FRM_IP 16864
+#define VFILTER_4x4_FRM_IP 17136
+#define Interpolate_Y_I_4x4_FRM_IP 17184
+#define Average_4x4_FRM_IP 17280
+#define Return_Interpolate_Y_4x4_FRM_IP 17296
+#define Exit_Interpolate_Y_4x4_FRM_IP 17392
+#define ROUND_SHIFT_C_FRM_IP 17776
+#define LOOP_DIR_CONTINUE_FRM_IP 17840
+#define Weighted_Prediction_FRM_IP 17888
+#define DefaultWeightedPred_UniPred_FRM_IP 17952
+#define DefaultWeightedPred_BiPred_FRM_IP 18048
+#define WeightedPred_FRM_IP 18112
+#define WeightedPred_Explicit_FRM_IP 18256
+#define WeightedPred_LOOP_FRM_IP 18576
+#define Return_WeightedPred_FRM_IP 19056
+#define EXIT_LOOP_FRM_IP 19392
+#define FIELD_MB_IP 19968
+#define INIT_MBPARA_FLD_IP 20016
+#define NOT_8x8_MODE_FLD_IP 20304
+#define CONVERT_MVS_FLD_IP 20384
+#define INIT_ADDRESS_REGS_FLD_IP 20464
+#define LOOP_SUBMB_FLD_IP 20544
+#define LOOP_DIR_FLD_IP 20592
+#define LOADREF_MVXZERO_FLD_IP 21152
+#define EXIT_LOADREF_Y_16x13_FLD_IP 21264
+#define Interpolate_Y_8x8_Func_FLD_IP 21440
+#define Interpolate_Y_8x8_Func2_FLD_IP 21680
+#define Interpolate_Y_H_8x8_FLD_IP 22752
+#define Interpolate_Y_V_8x8_FLD_IP 23408
+#define VFILTER_8x8_FLD_IP 23584
+#define Interpolate_Y_I_8x8_FLD_IP 23968
+#define Average_8x8_FLD_IP 24128
+#define Return_Interpolate_Y_8x8_FLD_IP 24192
+#define Exit_Interpolate_Y_8x8_FLD_IP 24208
+#define Interpolate_C_4x4_Func_FLD_IP 24208
+#define PROCESS4x4_FLD_IP 24512
+#define LOOP_SUBMBPT_FLD_IP 24528
+#define Interpolate_Y_H_4x4_FLD_IP 25632
+#define Interpolate_Y_V_4x4_FLD_IP 25968
+#define VFILTER_4x4_FLD_IP 26240
+#define Interpolate_Y_I_4x4_FLD_IP 26288
+#define Average_4x4_FLD_IP 26384
+#define Return_Interpolate_Y_4x4_FLD_IP 26400
+#define Exit_Interpolate_Y_4x4_FLD_IP 26496
+#define ROUND_SHIFT_C_FLD_IP 26880
+#define LOOP_DIR_CONTINUE_FLD_IP 26944
+#define Weighted_Prediction_FLD_IP 26992
+#define DefaultWeightedPred_UniPred_FLD_IP 27056
+#define DefaultWeightedPred_BiPred_FLD_IP 27152
+#define WeightedPred_FLD_IP 27216
+#define WeightedPred_Explicit_FLD_IP 27360
+#define WeightedPred_LOOP_FLD_IP 27680
+#define Return_WeightedPred_FLD_IP 28160
+#define EXIT_LOOP_FLD_IP 28496
+#define MBAFF_MB_IP 29120
+#define INIT_MBPARA_MBF_IP 29168
+#define NOT_8x8_MODE_MBF_IP 29456
+#define CONVERT_MVS_MBF_IP 29536
+#define INIT_ADDRESS_REGS_MBF_IP 29616
+#define LOOP_SUBMB_MBF_IP 29728
+#define LOOP_DIR_MBF_IP 29776
+#define LOADREF_MVXZERO_MBF_IP 30368
+#define EXIT_LOADREF_Y_16x13_MBF_IP 30480
+#define Interpolate_Y_8x8_Func_MBF_IP 30656
+#define Interpolate_Y_8x8_Func2_MBF_IP 30896
+#define Interpolate_Y_H_8x8_MBF_IP 31968
+#define Interpolate_Y_V_8x8_MBF_IP 32624
+#define VFILTER_8x8_MBF_IP 32800
+#define Interpolate_Y_I_8x8_MBF_IP 33184
+#define Average_8x8_MBF_IP 33344
+#define Return_Interpolate_Y_8x8_MBF_IP 33408
+#define Exit_Interpolate_Y_8x8_MBF_IP 33424
+#define Interpolate_C_4x4_Func_MBF_IP 33424
+#define PROCESS4x4_MBF_IP 33728
+#define LOOP_SUBMBPT_MBF_IP 33744
+#define Interpolate_Y_H_4x4_MBF_IP 34848
+#define Interpolate_Y_V_4x4_MBF_IP 35184
+#define VFILTER_4x4_MBF_IP 35456
+#define Interpolate_Y_I_4x4_MBF_IP 35504
+#define Average_4x4_MBF_IP 35600
+#define Return_Interpolate_Y_4x4_MBF_IP 35616
+#define Exit_Interpolate_Y_4x4_MBF_IP 35712
+#define ROUND_SHIFT_C_MBF_IP 36096
+#define LOOP_DIR_CONTINUE_MBF_IP 36160
+#define Weighted_Prediction_MBF_IP 36208
+#define DefaultWeightedPred_UniPred_MBF_IP 36272
+#define DefaultWeightedPred_BiPred_MBF_IP 36368
+#define WeightedPred_MBF_IP 36432
+#define WeightedPred_Explicit_MBF_IP 36576
+#define WeightedPred_LOOP_MBF_IP 36896
+#define Return_WeightedPred_MBF_IP 37376
+#define EXIT_LOOP_MBF_IP 37712
+#define SETHWSCOREBOARD_IP 38336
+#define SetHWScoreboard_Loop_IP 38448
+#define Parse_8_Loop_0_IP 38816
+#define Parse_8_Loop_2_IP 39008
+#define Parse_8_Loop_4_IP 39200
+#define Parse_8_Loop_6_IP 39392
+#define Parse_8_Loop_8_IP 39584
+#define Parse_8_Loop_10_IP 39776
+#define Parse_8_Loop_12_IP 39968
+#define Parse_8_Loop_14_IP 40160
+#define SetHWScoreboard_Remainder_IP 40496
+#define SetHWScoreboard_Remainder_Loop_IP 40720
+#define Output_Remainder_Intra_IP 40928
+#define SetHWScoreboard_Done_IP 41024
+#define SETHWSCOREBOARD_MBAFF_IP 41088
+#define SetHWScoreboard_MBAFF_Loop_IP 41184
+#define SET_SB_MBAFF_INTRA_0_IP 41664
+#define SET_SB_MBAFF_0_IP 41840
+#define NEXT_MB_MBAFF_0_IP 41904
+#define SET_SB_MBAFF_INTRA_2_IP 42208
+#define SET_SB_MBAFF_2_IP 42384
+#define NEXT_MB_MBAFF_2_IP 42448
+#define SET_SB_MBAFF_INTRA_4_IP 42752
+#define SET_SB_MBAFF_4_IP 42928
+#define NEXT_MB_MBAFF_4_IP 42992
+#define SET_SB_MBAFF_INTRA_6_IP 43296
+#define SET_SB_MBAFF_6_IP 43472
+#define NEXT_MB_MBAFF_6_IP 43536
+#define SET_SB_MBAFF_INTRA_8_IP 43840
+#define SET_SB_MBAFF_8_IP 44016
+#define NEXT_MB_MBAFF_8_IP 44080
+#define SET_SB_MBAFF_INTRA_10_IP 44384
+#define SET_SB_MBAFF_10_IP 44560
+#define NEXT_MB_MBAFF_10_IP 44624
+#define SET_SB_MBAFF_INTRA_12_IP 44928
+#define SET_SB_MBAFF_12_IP 45104
+#define NEXT_MB_MBAFF_12_IP 45168
+#define SET_SB_MBAFF_INTRA_14_IP 45472
+#define SET_SB_MBAFF_14_IP 45648
+#define NEXT_MB_MBAFF_14_IP 45712
+#define SetHWScoreboard_MBAFF_Remainder_IP 46048
+#define SetHWScoreboard_MBAFF_Remainder_Loop_IP 46272
+#define SET_SB_MBAFF_REM_INTRA_IP 46576
+#define SET_SB_MBAFF_REM_IP 46768
+#define Output_MBAFF_Remainder_Intra_IP 46848
+#define SetHWScoreboard_MBAFF_Done_IP 46944
+#define BSDRESET_IP 46960
+#define DCRESETDUMMY_IP 46976
+#define AllAVC_END_IP 46992
diff --git a/i965_drv_video/shaders/h264/mc/export.inc.gen5 b/i965_drv_video/shaders/h264/mc/export.inc.gen5
new file mode 100644
index 0000000..63accd9
--- /dev/null
+++ b/i965_drv_video/shaders/h264/mc/export.inc.gen5
@@ -0,0 +1,209 @@
+#define INTRA_16x16_IP_GEN5 0
+#define INTRA_16x16_VERTICAL_IP_GEN5 112
+#define INTRA_16x16_HORIZONTAL_IP_GEN5 256
+#define INTRA_16x16_DC_IP_GEN5 416
+#define INTRA_16x16_PLANE_IP_GEN5 784
+#define End_intra_Pred_16x16_Y_IP_GEN5 1328
+#define End_add_Error_16x16_Y_IP_GEN5 1632
+#define load_Intra_Ref_Y_IP_GEN5 1760
+#define decode_Chroma_Intra_IP_GEN5 1904
+#define INTRA_CHROMA_DC_IP_GEN5 2080
+#define INTRA_CHROMA_HORIZONTAL_IP_GEN5 2560
+#define INTRA_CHROMA_VERTICAL_IP_GEN5 2656
+#define INTRA_Chroma_PLANE_IP_GEN5 2736
+#define End_of_intra_Pred_Chroma_IP_GEN5 3136
+#define save_16x16_Y_IP_GEN5 3488
+#define INTRA_8x8_IP_GEN5 3712
+#define INTRA_8x8_BLK2_IP_GEN5 4544
+#define intra_Pred_8x8_Y_IP_GEN5 5120
+#define INTRA_8X8_VERTICAL_IP_GEN5 5376
+#define INTRA_8X8_HORIZONTAL_IP_GEN5 5456
+#define INTRA_8X8_DC_IP_GEN5 5536
+#define INTRA_8X8_DIAG_DOWN_LEFT_IP_GEN5 5792
+#define INTRA_8X8_DIAG_DOWN_RIGHT_IP_GEN5 5952
+#define INTRA_8X8_VERT_RIGHT_IP_GEN5 6176
+#define INTRA_8X8_HOR_DOWN_IP_GEN5 6464
+#define INTRA_8X8_VERT_LEFT_IP_GEN5 6736
+#define INTRA_8X8_HOR_UP_IP_GEN5 6896
+#define save_8x8_Y_IP_GEN5 7088
+#define INTRA_4x4_IP_GEN5 7424
+#define intra_Pred_4x4_Y_4_IP_GEN5 8496
+#define ADD_ERROR_SB0_IP_GEN5 8592
+#define ADD_ERROR_SB1_IP_GEN5 8704
+#define ADD_ERROR_SB2_IP_GEN5 8864
+#define ADD_ERROR_SB3_IP_GEN5 8992
+#define intra_Pred_4x4_Y_IP_GEN5 9040
+#define INTRA_4X4_VERTICAL_IP_GEN5 9040
+#define INTRA_4X4_HORIZONTAL_IP_GEN5 9072
+#define INTRA_4X4_DC_IP_GEN5 9104
+#define INTRA_4X4_DIAG_DOWN_LEFT_IP_GEN5 9280
+#define INTRA_4X4_DIAG_DOWN_RIGHT_IP_GEN5 9392
+#define INTRA_4X4_VERT_RIGHT_IP_GEN5 9536
+#define INTRA_4X4_HOR_DOWN_IP_GEN5 9744
+#define INTRA_4X4_VERT_LEFT_IP_GEN5 9968
+#define INTRA_4X4_HOR_UP_IP_GEN5 10080
+#define save_4x4_Y_IP_GEN5 10208
+#define INTRA_PCM_IP_GEN5 10560
+#define FRAME_MB_IP_GEN5 11072
+#define INIT_MBPARA_FRM_IP_GEN5 11120
+#define NOT_8x8_MODE_FRM_IP_GEN5 11408
+#define CONVERT_MVS_FRM_IP_GEN5 11488
+#define INIT_ADDRESS_REGS_FRM_IP_GEN5 11568
+#define LOOP_SUBMB_FRM_IP_GEN5 11632
+#define LOOP_DIR_FRM_IP_GEN5 11680
+#define LOADREF_MVXZERO_FRM_IP_GEN5 12080
+#define EXIT_LOADREF_Y_16x13_FRM_IP_GEN5 12192
+#define Interpolate_Y_8x8_Func_FRM_IP_GEN5 12352
+#define Interpolate_Y_8x8_Func2_FRM_IP_GEN5 12592
+#define Interpolate_Y_H_8x8_FRM_IP_GEN5 13664
+#define Interpolate_Y_V_8x8_FRM_IP_GEN5 14320
+#define VFILTER_8x8_FRM_IP_GEN5 14496
+#define Interpolate_Y_I_8x8_FRM_IP_GEN5 14880
+#define Average_8x8_FRM_IP_GEN5 15040
+#define Return_Interpolate_Y_8x8_FRM_IP_GEN5 15104
+#define Exit_Interpolate_Y_8x8_FRM_IP_GEN5 15120
+#define Interpolate_C_4x4_Func_FRM_IP_GEN5 15120
+#define PROCESS4x4_FRM_IP_GEN5 15424
+#define LOOP_SUBMBPT_FRM_IP_GEN5 15440
+#define Interpolate_Y_H_4x4_FRM_IP_GEN5 16528
+#define Interpolate_Y_V_4x4_FRM_IP_GEN5 16864
+#define VFILTER_4x4_FRM_IP_GEN5 17136
+#define Interpolate_Y_I_4x4_FRM_IP_GEN5 17184
+#define Average_4x4_FRM_IP_GEN5 17280
+#define Return_Interpolate_Y_4x4_FRM_IP_GEN5 17296
+#define Exit_Interpolate_Y_4x4_FRM_IP_GEN5 17392
+#define ROUND_SHIFT_C_FRM_IP_GEN5 17776
+#define LOOP_DIR_CONTINUE_FRM_IP_GEN5 17840
+#define Weighted_Prediction_FRM_IP_GEN5 17888
+#define DefaultWeightedPred_UniPred_FRM_IP_GEN5 17952
+#define DefaultWeightedPred_BiPred_FRM_IP_GEN5 18048
+#define WeightedPred_FRM_IP_GEN5 18112
+#define WeightedPred_Explicit_FRM_IP_GEN5 18256
+#define WeightedPred_LOOP_FRM_IP_GEN5 18576
+#define Return_WeightedPred_FRM_IP_GEN5 19056
+#define EXIT_LOOP_FRM_IP_GEN5 19392
+#define FIELD_MB_IP_GEN5 19968
+#define INIT_MBPARA_FLD_IP_GEN5 20016
+#define NOT_8x8_MODE_FLD_IP_GEN5 20304
+#define CONVERT_MVS_FLD_IP_GEN5 20384
+#define INIT_ADDRESS_REGS_FLD_IP_GEN5 20464
+#define LOOP_SUBMB_FLD_IP_GEN5 20544
+#define LOOP_DIR_FLD_IP_GEN5 20592
+#define LOADREF_MVXZERO_FLD_IP_GEN5 21152
+#define EXIT_LOADREF_Y_16x13_FLD_IP_GEN5 21264
+#define Interpolate_Y_8x8_Func_FLD_IP_GEN5 21440
+#define Interpolate_Y_8x8_Func2_FLD_IP_GEN5 21680
+#define Interpolate_Y_H_8x8_FLD_IP_GEN5 22752
+#define Interpolate_Y_V_8x8_FLD_IP_GEN5 23408
+#define VFILTER_8x8_FLD_IP_GEN5 23584
+#define Interpolate_Y_I_8x8_FLD_IP_GEN5 23968
+#define Average_8x8_FLD_IP_GEN5 24128
+#define Return_Interpolate_Y_8x8_FLD_IP_GEN5 24192
+#define Exit_Interpolate_Y_8x8_FLD_IP_GEN5 24208
+#define Interpolate_C_4x4_Func_FLD_IP_GEN5 24208
+#define PROCESS4x4_FLD_IP_GEN5 24512
+#define LOOP_SUBMBPT_FLD_IP_GEN5 24528
+#define Interpolate_Y_H_4x4_FLD_IP_GEN5 25632
+#define Interpolate_Y_V_4x4_FLD_IP_GEN5 25968
+#define VFILTER_4x4_FLD_IP_GEN5 26240
+#define Interpolate_Y_I_4x4_FLD_IP_GEN5 26288
+#define Average_4x4_FLD_IP_GEN5 26384
+#define Return_Interpolate_Y_4x4_FLD_IP_GEN5 26400
+#define Exit_Interpolate_Y_4x4_FLD_IP_GEN5 26496
+#define ROUND_SHIFT_C_FLD_IP_GEN5 26880
+#define LOOP_DIR_CONTINUE_FLD_IP_GEN5 26944
+#define Weighted_Prediction_FLD_IP_GEN5 26992
+#define DefaultWeightedPred_UniPred_FLD_IP_GEN5 27056
+#define DefaultWeightedPred_BiPred_FLD_IP_GEN5 27152
+#define WeightedPred_FLD_IP_GEN5 27216
+#define WeightedPred_Explicit_FLD_IP_GEN5 27360
+#define WeightedPred_LOOP_FLD_IP_GEN5 27680
+#define Return_WeightedPred_FLD_IP_GEN5 28160
+#define EXIT_LOOP_FLD_IP_GEN5 28496
+#define MBAFF_MB_IP_GEN5 29120
+#define INIT_MBPARA_MBF_IP_GEN5 29168
+#define NOT_8x8_MODE_MBF_IP_GEN5 29456
+#define CONVERT_MVS_MBF_IP_GEN5 29536
+#define INIT_ADDRESS_REGS_MBF_IP_GEN5 29616
+#define LOOP_SUBMB_MBF_IP_GEN5 29728
+#define LOOP_DIR_MBF_IP_GEN5 29776
+#define LOADREF_MVXZERO_MBF_IP_GEN5 30368
+#define EXIT_LOADREF_Y_16x13_MBF_IP_GEN5 30480
+#define Interpolate_Y_8x8_Func_MBF_IP_GEN5 30656
+#define Interpolate_Y_8x8_Func2_MBF_IP_GEN5 30896
+#define Interpolate_Y_H_8x8_MBF_IP_GEN5 31968
+#define Interpolate_Y_V_8x8_MBF_IP_GEN5 32624
+#define VFILTER_8x8_MBF_IP_GEN5 32800
+#define Interpolate_Y_I_8x8_MBF_IP_GEN5 33184
+#define Average_8x8_MBF_IP_GEN5 33344
+#define Return_Interpolate_Y_8x8_MBF_IP_GEN5 33408
+#define Exit_Interpolate_Y_8x8_MBF_IP_GEN5 33424
+#define Interpolate_C_4x4_Func_MBF_IP_GEN5 33424
+#define PROCESS4x4_MBF_IP_GEN5 33728
+#define LOOP_SUBMBPT_MBF_IP_GEN5 33744
+#define Interpolate_Y_H_4x4_MBF_IP_GEN5 34848
+#define Interpolate_Y_V_4x4_MBF_IP_GEN5 35184
+#define VFILTER_4x4_MBF_IP_GEN5 35456
+#define Interpolate_Y_I_4x4_MBF_IP_GEN5 35504
+#define Average_4x4_MBF_IP_GEN5 35600
+#define Return_Interpolate_Y_4x4_MBF_IP_GEN5 35616
+#define Exit_Interpolate_Y_4x4_MBF_IP_GEN5 35712
+#define ROUND_SHIFT_C_MBF_IP_GEN5 36096
+#define LOOP_DIR_CONTINUE_MBF_IP_GEN5 36160
+#define Weighted_Prediction_MBF_IP_GEN5 36208
+#define DefaultWeightedPred_UniPred_MBF_IP_GEN5 36272
+#define DefaultWeightedPred_BiPred_MBF_IP_GEN5 36368
+#define WeightedPred_MBF_IP_GEN5 36432
+#define WeightedPred_Explicit_MBF_IP_GEN5 36576
+#define WeightedPred_LOOP_MBF_IP_GEN5 36896
+#define Return_WeightedPred_MBF_IP_GEN5 37376
+#define EXIT_LOOP_MBF_IP_GEN5 37712
+#define SETHWSCOREBOARD_IP_GEN5 38336
+#define SetHWScoreboard_Loop_IP_GEN5 38448
+#define Parse_8_Loop_0_IP_GEN5 38816
+#define Parse_8_Loop_2_IP_GEN5 39008
+#define Parse_8_Loop_4_IP_GEN5 39200
+#define Parse_8_Loop_6_IP_GEN5 39392
+#define Parse_8_Loop_8_IP_GEN5 39584
+#define Parse_8_Loop_10_IP_GEN5 39776
+#define Parse_8_Loop_12_IP_GEN5 39968
+#define Parse_8_Loop_14_IP_GEN5 40160
+#define SetHWScoreboard_Remainder_IP_GEN5 40496
+#define SetHWScoreboard_Remainder_Loop_IP_GEN5 40720
+#define Output_Remainder_Intra_IP_GEN5 40928
+#define SetHWScoreboard_Done_IP_GEN5 41024
+#define SETHWSCOREBOARD_MBAFF_IP_GEN5 41088
+#define SetHWScoreboard_MBAFF_Loop_IP_GEN5 41184
+#define SET_SB_MBAFF_INTRA_0_IP_GEN5 41664
+#define SET_SB_MBAFF_0_IP_GEN5 41840
+#define NEXT_MB_MBAFF_0_IP_GEN5 41904
+#define SET_SB_MBAFF_INTRA_2_IP_GEN5 42208
+#define SET_SB_MBAFF_2_IP_GEN5 42384
+#define NEXT_MB_MBAFF_2_IP_GEN5 42448
+#define SET_SB_MBAFF_INTRA_4_IP_GEN5 42752
+#define SET_SB_MBAFF_4_IP_GEN5 42928
+#define NEXT_MB_MBAFF_4_IP_GEN5 42992
+#define SET_SB_MBAFF_INTRA_6_IP_GEN5 43296
+#define SET_SB_MBAFF_6_IP_GEN5 43472
+#define NEXT_MB_MBAFF_6_IP_GEN5 43536
+#define SET_SB_MBAFF_INTRA_8_IP_GEN5 43840
+#define SET_SB_MBAFF_8_IP_GEN5 44016
+#define NEXT_MB_MBAFF_8_IP_GEN5 44080
+#define SET_SB_MBAFF_INTRA_10_IP_GEN5 44384
+#define SET_SB_MBAFF_10_IP_GEN5 44560
+#define NEXT_MB_MBAFF_10_IP_GEN5 44624
+#define SET_SB_MBAFF_INTRA_12_IP_GEN5 44928
+#define SET_SB_MBAFF_12_IP_GEN5 45104
+#define NEXT_MB_MBAFF_12_IP_GEN5 45168
+#define SET_SB_MBAFF_INTRA_14_IP_GEN5 45472
+#define SET_SB_MBAFF_14_IP_GEN5 45648
+#define NEXT_MB_MBAFF_14_IP_GEN5 45712
+#define SetHWScoreboard_MBAFF_Remainder_IP_GEN5 46048
+#define SetHWScoreboard_MBAFF_Remainder_Loop_IP_GEN5 46272
+#define SET_SB_MBAFF_REM_INTRA_IP_GEN5 46576
+#define SET_SB_MBAFF_REM_IP_GEN5 46768
+#define Output_MBAFF_Remainder_Intra_IP_GEN5 46848
+#define SetHWScoreboard_MBAFF_Done_IP_GEN5 46944
+#define BSDRESET_IP_GEN5 46960
+#define DCRESETDUMMY_IP_GEN5 46976
+#define AllAVC_END_IP_GEN5 46992
diff --git a/i965_drv_video/shaders/h264/mc/header.inc b/i965_drv_video/shaders/h264/mc/header.inc
new file mode 100644
index 0000000..4a0eecf
--- /dev/null
+++ b/i965_drv_video/shaders/h264/mc/header.inc
@@ -0,0 +1,303 @@
+/*
+ * Common header file for all AVC MC kernels
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+#if !defined(__HEADER__)	// Make sure this file is only included once
+#define __HEADER__
+
+// Module name: header.inc
+//
+// Common header file for all AVC MC kernels
+//
+
+#ifndef	COMBINED_KERNEL
+#ifdef DEV_CTG
+  #define SW_SCOREBOARD		// SW Scoreboard should be enabled for CTG and earlier
+  #undef HW_SCOREBOARD		// HW Scoreboard should be disabled for CTG and earlier
+#else
+  #define HW_SCOREBOARD		// HW Scoreboard should be enabled for ILK and beyond
+  #undef SW_SCOREBOARD		// SW Scoreboard should be disabled for ILK and beyond
+#endif	// DEV_CTG
+#endif	// COMBINED_KERNEL
+
+//#define MONO				// Build Monochrome kernels
+
+//  Surface state definition
+//
+#define	DESTY		0
+#define	DESTUV		1
+#define	REFYFM0		2
+#define	REFYFM1		3
+#define	REFYFM2		4
+#define	REFYFM3		5
+#define	REFYFM4		6
+#define	REFYFM5		7
+#define	REFYFM6		8
+#define	REFYFM7		9
+#define	REFYFM8		10
+#define	REFYFM9		11
+#define	REFYFM10	12
+#define	REFYFM11	13
+#define	REFYFM12	14
+#define	REFYFM13	15
+#define	REFYFM14	16
+#define	REFYFM15	17
+#define	REFUVFM0	18
+#define	REFUVFM1	19
+#define	REFUVFM2	20
+#define	REFUVFM3	21
+#define	REFUVFM4	22
+#define	REFUVFM5	23
+#define	REFUVFM6	24
+#define	REFUVFM7	25
+#define	REFUVFM8	26
+#define	REFUVFM9	27
+#define	REFUVFM10	28
+#define	REFUVFM11	29
+#define	REFUVFM12	30
+#define	REFUVFM13	31
+#define	REFUVFM14	32
+#define	REFUVFM15	33
+
+.default_execution_size	(16)
+.default_register_type	:ub
+
+//  ----------- Common constant definitions ------------
+//
+//  Bit position constants
+//
+#define BIT0	0x01
+#define BIT1	0x02
+#define BIT2	0x04
+#define BIT3	0x08
+#define BIT4	0x10
+#define BIT5	0x20
+#define BIT6	0x40
+#define BIT7	0x80
+#define BIT8	0x0100
+#define BIT9	0x0200
+#define BIT10	0x0400
+#define BIT11	0x0800
+#define BIT12	0x1000
+#define BIT13	0x2000
+#define BIT14	0x4000
+#define BIT15	0x8000
+#define BIT16	0x00010000
+#define BIT17	0x00020000
+#define BIT18	0x00040000
+#define BIT19	0x00080000
+#define BIT20	0x00100000
+#define BIT21	0x00200000
+#define BIT22	0x00400000
+#define BIT23	0x00800000
+#define BIT24	0x01000000
+#define BIT25	0x02000000
+#define BIT26	0x04000000
+#define BIT27	0x08000000
+#define BIT28	0x10000000
+#define BIT29	0x20000000
+#define BIT30	0x40000000
+#define BIT31	0x80000000
+
+#define	GRFWIB	32		// GRF register width in byte
+#define	GRFWIW	16		// GRF register width in word
+#define	GRFWID	8		// GRF register width in dword
+
+#define INST_SIZE   16		// Instruction size = 128b = 16 Bytes
+
+#define REGION(Width,HStride) <Width*HStride;Width,HStride>
+
+#define NULLREG		null<1>:ud
+#define NULLREGW	null<1>:w
+
+#define TOP_FIELD		0
+#define BOTTOM_FIELD	1
+
+//  M2 - M9 for date writing message payload
+.declare    MSGPAYLOAD	Base=m2 ElementSize=1 SrcRegion=REGION(16,1) Type=ub
+.declare    MSGPAYLOADB	Base=m2 ElementSize=1 SrcRegion=REGION(16,1) Type=ub
+.declare    MSGPAYLOADW	Base=m2 ElementSize=2 SrcRegion=REGION(16,1) Type=uw
+.declare    MSGPAYLOADD	Base=m2 ElementSize=4 SrcRegion=REGION(8,1) Type=ud
+
+//  ----------- Common Message Descriptor ------------
+//
+#ifdef DEV_ILK
+#define MSG_GW		0x03		// Message Gateway Extended Message Descriptor,
+#define DAPREAD		0x04		// Data Port Read Extended Message Descriptor,
+#define DAPWRITE	0x05		// Data Port Write Extended Message Descriptor,
+#define TS			0x07		// Thread Spawner Extended Message Descriptor
+#define TS_EOT		0x27		// End of Thread Extended Message Descriptor
+
+#define EOTMSGDSC	0x02000010	// End of Thread Message Descriptor, don't deference URB handle
+
+// Data Port Message Descriptor
+#define DWBRMSGDSC_RC	 0x02086000	// DWORD Block Read Message Descriptor, reading from render cache = 6.
+#define DWBRMSGDSC_RC_TF 0x02086600	// DWORD Block Read Message Descriptor, reading from render cache = 6.
+#define DWBRMSGDSC_RC_BF 0x02086700	// DWORD Block Read Message Descriptor, reading from render cache = 6.
+#define DWBRMSGDSC_SC	 0x0208A000	// DWORD Block Read Message Descriptor, reading from sampler cache = A.
+#define DWBRMSGDSC_SC_TF 0x0208E600	// DWORD Block Read Message Descriptor, reading top field from field mode sampler cache.
+#define DWBRMSGDSC_SC_BF 0x0208E700	// DWORD Block Read Message Descriptor, reading bottom field from field mode sampler cache.
+
+#define DWBWMSGDSC		 0x02082000	// DWORD Block Write Message Descriptor
+#define DWBWMSGDSC_WC 	 0x0218A000	// DWORD Block Write Message Descriptor + write commit
+
+// Enable Write Commit writeback mesage
+#define	ENWRCOM		0x00108000	// Enable "write commit" and set response length = 1
+
+// Thread Spawner Message Descriptor
+#define	TSMSGDSC	0x02000011
+
+// Message Gateway Message Descriptors
+#define OGWMSGDSC	0x02000000	// OpenGateway Message Descriptor
+#define CGWMSGDSC	0x02000001	// CloseGateway Message Descriptor
+#define FWDMSGDSC	0x02000002	// ForwardMsg Message Descriptor
+
+#define	NOTIFYMSG	0x00008000	// Send notification with ForwardMsg message
+
+#define	RESP_LEN(len)	0x100000*len
+#define MSG_LEN(len)	0x2000000*len
+
+#else	// Pre DEV_ILK
+
+#define MSG_GW
+#define DAPREAD
+#define DAPWRITE
+#define TS
+#define TS_EOT
+
+#define EOTMSGDSC	0x87100010	// End of Thread Message Descriptor, don't deference URB handle
+
+// Data Port Message Descriptor
+#define DWBRMSGDSC_RC	 0x04106000	// DWORD Block Read Message Descriptor, reading from render cache = 6.
+#define DWBRMSGDSC_RC_TF 0x04106600	// DWORD Block Read Message Descriptor, reading from render cache = 6.
+#define DWBRMSGDSC_RC_BF 0x04106700	// DWORD Block Read Message Descriptor, reading from render cache = 6.
+#define DWBRMSGDSC_SC	 0x0410A000	// DWORD Block Read Message Descriptor, reading from sampler cache = A.
+#define DWBRMSGDSC_SC_TF 0x0410A600	// DWORD Block Read Message Descriptor, reading top field from field mode sampler cache.
+#define DWBRMSGDSC_SC_BF 0x0410A700	// DWORD Block Read Message Descriptor, reading bottom field from field mode sampler cache.
+
+#define DWBWMSGDSC		 0x05102000	// DWORD Block Write Message Descriptor
+#define DWBWMSGDSC_WC 	 0x0511A000	// DWORD Block Write Message Descriptor + write commit
+
+// Enable Write Commit writeback mesage
+#define	ENWRCOM		0x00018000	// Enable "write commit" and set response length = 1
+
+// Thread Spawner Message Descriptor
+#define	TSMSGDSC	0x07100011
+
+// Message Gateway Message Descriptors
+#define OGWMSGDSC	0x03100000	// OpenGateway Message Descriptor
+#define CGWMSGDSC	0x03100001	// CloseGateway Message Descriptor
+#define FWDMSGDSC	0x03100002	// ForwardMsg Message Descriptor
+
+#define	NOTIFYMSG	0x00008000	// Send notification with ForwardMsg message
+#define	ACKREQMSG	0x00014000	// Acknowledgement required so response length should be 1
+
+#define	RESP_LEN(len)	0x10000*len
+#define MSG_LEN(len)	0x100000*len
+
+#endif	// DEV_ILK
+
+// Enable frame/field selection in message descriptor
+#define ENMSGDSCFM	0x400		// Enable MSGDSC to select frame surface
+#define ENMSGDSCTF	0x600		// Enable MSGDSC to select top field surface
+#define ENMSGDSCBF	0x700		// Enable MSGDSC to select bottom field surface
+
+//  ----------- Message related register ------------
+//
+#define MSGHDR		m1		// Message Payload Header
+#define MSGHDRY		m1		// Message Payload Header register for Y data
+#define MSGHDRY0	m1		// Message Payload Header register for Y data
+#define MSGHDRY1	m2		// Message Payload Header register for Y data
+#define MSGHDRY2	m3		// Message Payload Header register for Y data
+#define MSGHDRY3	m4		// Message Payload Header register for Y data
+#define MSGHDRUV	m5		// Message Payload Header register for U/V data
+#define MSGSRC		r62		// Message source register, should never be used for other purposes
+#define MSGDSC		a0.0:ud	// Message Descriptor register (type DWORD)
+
+#define MH_ORI		MSGSRC.0	// DWORD block R/W message header block offset
+#define MH_ORIX		MSGSRC.0	// DWORD block R/W message header X offset
+#define MH_ORIY		MSGSRC.1	// DWORD block R/W message header Y offset
+#define MH_SIZE		MSGSRC.2	// DWORD block R/W message header block width & height
+
+// Data necessary for kernel operations
+//
+//  Address registers used as pointers
+//
+//  Note: Please keep the register order as is since they are used in compressed instructions
+//
+#define	    PPREDBUF_Y		a0.4	// Pointer to predicted Y picture
+#define	    PPREDBUF_Y1		a0.5	// Pointer to predicted Y picture for extended instruction
+
+#define	    PPREDBUF_UV		a0.4	// Pointer to predicted U/V picture
+#define	    PPREDBUF_UV1	a0.5	// Pointer to predicted U/V picture for extended instruction
+
+#define	    PDECBUF		a0.4	// Pointer to decoded picture data
+#define	    PDECBUF_UD	a0.2	// Pointer to decoded picture data in DWORD unit
+
+//  ----------- R63 is reserved for global variables ------------
+//
+//  Note: Don't program it with values other than what are defined here. 
+
+#define G_REG		r63
+
+#define RETURN_REG	G_REG.0		// Return pointer for all sub-routine calls (type DWORD)
+#define RETURN_REG1	G_REG.1		// Return pointer for second-level calls
+
+#define I_ORIX		G_REG.13	// :uw, H. origin of the macroblock in pixel unit, don't overwrite in-line data
+#define I_ORIY		G_REG.14	// :uw, V. origin of the macroblock in pixel unit, don't overwrite in-line data
+
+//  Macros
+//
+//  Note: For macros that require multiple line expansion, insert "\n" at the end of each line.
+//
+#define	GRF(reg)	r##reg
+#ifdef DEV_ILK
+#define END_THREAD			send (8) NULLREG MSGHDR r0:ud TS_EOT	EOTMSGDSC
+#else
+#define END_THREAD			send (8) NULLREG MSGHDR r0:ud EOTMSGDSC
+#endif	// DEV_ILK
+
+#define CALL(subFunc, skipInst)	add (1) RETURN_REG<1>:ud   ip:ud	(1+skipInst)*INST_SIZE \n\
+				jmpi (1) subFunc
+
+#define CALL_1(subFunc, skipInst)	add (1) RETURN_REG1<1>:ud   ip:ud	(1+skipInst)*INST_SIZE \n\
+				jmpi (1) subFunc
+
+#define	RETURN		mov (1)	ip:ud	RETURN_REG<0;1,0>:ud		// Return to calling module
+#define	RETURN_1	mov (1)	ip:ud	RETURN_REG1<0;1,0>:ud		// Return to second-level calling module
+																// To support iterative calling
+#ifdef SW_SCOREBOARD    
+
+#ifdef DEV_CTG_A
+  #define LEADING_THREAD	1		// For CTG A, no SRT is needed. Only PRT is necessary
+#else
+  #define LEADING_THREAD	0		// For CTG B0 and beyond, PRT doesn't take into debug count
+  #define DOUBLE_SB					// Scoreboard size needs to be doubled
+#endif
+
+#ifdef	DOUBLE_SB					// Scoreboard size needs to be doubled
+  #define SB_MASK		0x1ff		// Scoreboard wrap-around mask (for 512 entries)
+#else
+  #define SB_MASK		0xff		// Scoreboard wrap-around mask (for 256 entries)
+#endif	// defined(DOUBLE_SB)
+
+// Scoreboard related definitions
+
+#define	TEMPX		r50
+#define	TEMPY		r51
+#define	DELTA		r52
+
+#define M05_STORE	r0.13		// :uw, reuse r0.6:ud upper-word to store M0.5 header information for scoreboard
+
+
+#endif	// SW_SCOREBOARD
+
+// End of header.inc
+
+#endif	// !defined(__HEADER__)
+
diff --git a/i965_drv_video/shaders/h264/mc/initialize_MBPara.asm b/i965_drv_video/shaders/h264/mc/initialize_MBPara.asm
new file mode 100644
index 0000000..bd651cf
--- /dev/null
+++ b/i965_drv_video/shaders/h264/mc/initialize_MBPara.asm
@@ -0,0 +1,125 @@
+/*
+ * Initialize parameters
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+// Kernel name: Initialize_MBPara.asm
+//
+
+
+//#if !defined(__INITIALIZE_MBPARA__)		// Make sure this is only included once
+//#define __INITIALIZE_MBPARA__
+
+
+// WA for weighted prediction - 2007/09/06		// shlee
+//	mov (1)		guwW128(0)<1>			guwR1(0)<0;1,0>		// Copy the unique number indicating weight/offset=(128,0)
+
+
+
+//	MB Type		Category
+//	1			B_L0_16x16
+//	2			B_L1_16x16
+//	3			B_Bi_16x16
+//	4			B_L0_L0_16x8
+//	5			B_L0_L0_8x16
+//	6			B_L1_L1_16x8
+//	7			B_L1_L1_8x16
+//	8			B_L0_L1_16x8
+//	9			B_L0_L1_8x16
+//	10			B_L1_L0_16x8
+//	11			B_L1_L0_8x16
+//	12			B_L0_Bi_16x8
+//	13			B_L0_Bi_8x16
+//	14			B_L1_Bi_16x8
+//	15			B_L1_Bi_8x16
+//	16			B_Bi_L0_16x8
+//	17			B_Bi_L0_8x16
+//	18			B_Bi_L1_16x8
+//	19			B_Bi_L1_8x16
+//	20			B_Bi_Bi_16x8
+//	21			B_Bi_Bi_8x16
+//	22			B_8x8
+
+	// TODO:
+	// Initialize interpolation area to eliminate uninitialized registers making the results of mac instructions XX.
+	// This issue was reported by Sharath on 5/25/2006, and why multiplication by zero still yields XX has not been understood yet.
+#if 0
+	mov (16)	gudINTPY0(0)<1>		0:ud	{Compr}
+	mov (16)	gudINTPY0(2)<1>		0:ud	{Compr}
+	mov (16)	gudINTPY1(0)<1>		0:ud	{Compr}
+	mov (16)	gudINTPY1(2)<1>		0:ud	{Compr}
+	mov (16)	gudINTPC0(0)<1>		0:ud	{Compr}
+	mov (16)	gudINTPC1(0)<1>		0:ud	{Compr}
+#endif
+
+	mov (1)		gMVSTEP:w			0:w								// Address increament for MV read
+
+	cmp.e.f0.0 (1) null:w			gwMBTYPE<0;1,0>					22:w
+	(-f0.0)		jmpi				INTERLABEL(NOT_8x8_MODE)
+
+	//--- 8x8 mode
+		
+	// Starting address of error data blocks
+	cmp.e.f0.1 (2) null<1>:w		gSUBMB_SHAPE<0;1,0>:ub			0:w
+	(f0.1) jmpi INTERLABEL(CONVERT_MVS)
+
+	// Note: MVs and Weights/Offsets are already expanded by HW or driver
+	
+	// MV conversion - Convert each MV to absolute coord. (= MV + MB org. + block offset) 
+	shl (16)	gwTEMP(0)<1>		gX<0;2,1>:w						2:w // Convert MB origin to 1/4-pel unit
+	mov (1)		gMVSTEP:w			24:w							// Address increament for MV read
+	add (2)		gwTEMP(0,4)<2>		gwTEMP(0,4)<4;2,2>				16:w
+	add (2)		gwTEMP(0,9)<2>		gwTEMP(0,9)<4;2,2>				16:w
+	add (4)		gwTEMP(0,12)<1>		gwTEMP(0,12)<4;4,1>				16:w
+	
+	add (16)	gMV<1>:w			gMV<16;16,1>:w					gwTEMP(0)<16;16,1>
+	add (8)		gwTEMP(0)<2>		gwTEMP(0)<16;8,2>				32:w
+	add (16)	gwMV(1,0)<1>		gwMV(1,0)<16;16,1>				gwTEMP(0)<16;16,1>	
+	add (8)		gwTEMP(0,1)<2>		gwTEMP(0,1)<16;8,2>				32:w
+	add (16)	gwMV(3,0)<1>		gwMV(3,0)<16;16,1>				gwTEMP(0)<16;16,1>	
+	add (8)		gwTEMP(0)<2>		gwTEMP(0)<16;8,2>				-32:w
+	add (16)	gwMV(2,0)<1>		gwMV(2,0)<16;16,1>				gwTEMP(0)<16;16,1>	
+
+	jmpi INTERLABEL(INIT_ADDRESS_REGS)
+
+INTERLABEL(NOT_8x8_MODE):
+
+	//--- !8x8 mode (16x16, 16x8, 8x16)
+
+	// MVs and Weights/Offsets are expanded
+	cmp.le.f0.1 (8) null<1>:w		gwMBTYPE<0;1,0>					3:w // Check 16x16
+	mov (1)		gSUBMB_SHAPE:ub		0:uw							// subMB shape
+	(f0.1) mov (8)	gMV<1>:d		gMV<0;2,1>:d					
+	(f0.1) mov (8)	gdWGT(1,0)<1>	gWGT<0;4,1>:d					
+	(f0.1) mov (4)	gdWGT(0,4)<1>	gWGT<4;4,1>:d					
+	
+INTERLABEL(CONVERT_MVS):
+	// MV conversion - Convert each MV to absolute coord. (= MV + MB org. + block offset)
+	shl (2)		gwTEMP(0)<1>		gX<2;2,1>:w						2:w // Convert MB origin to 1/4-pel unit
+	add (16)	gMV<1>:w			gMV<16;16,1>:w					gwTEMP(0)<0;2,1>
+	add (2)		gwMV(0,4)<2>		gwMV(0,4)<4;2,2>				32:w	//{NoDDClr}
+	add (2)		gwMV(0,9)<2>		gwMV(0,9)<4;2,2>				32:w	//{NoDDChk,NoDDClr}
+	add (4)		gwMV(0,12)<1>		gwMV(0,12)<4;4,1>				32:w	//{NoDDChk}
+		
+INTERLABEL(INIT_ADDRESS_REGS):
+	// Initialize the address registers
+	mov (2)		pERRORYC:ud			nOFFSET_ERROR:ud				{NoDDClr} // Address of Y and C error blocks
+	mov (1)		pRECON_MV:ud		nOFFSET_RECON_MV:ud				{NoDDChk,NoDDClr} // Address of recon area and motion vectors
+	mov (1)		pWGT_BIDX:ud		nOFFSET_WGT_BIDX:ud				{NoDDChk} // Address of weights/offsets and binding tbl idx
+	
+	// Read the parity of the current field (gPARITY - 0:top, 1:bottom, 3:frame)
+	// and set message descriptor for frame/field write
+#if defined(MBAFF)
+	and.nz.f0.0 (1) null:uw			gFIELDMBFLAG:ub					nFIELDMB_MASK:uw
+	(f0.0) and (1)	gPARITY:uw		gMBPARITY:ub					nMBPARITY_MASK:uw
+	(-f0.0) mov (1) gPARITY:uw		3:uw
+#elif defined(FIELD)
+	and (1)		gPARITY:uw			gMBPARITY:ub					nMBPARITY_MASK:uw
+#endif
+	
+        
+//#endif	// !defined(__INITIALIZE_MBPARA__)
diff --git a/i965_drv_video/shaders/h264/mc/inter_Header.inc b/i965_drv_video/shaders/h264/mc/inter_Header.inc
new file mode 100644
index 0000000..bd10c22
--- /dev/null
+++ b/i965_drv_video/shaders/h264/mc/inter_Header.inc
@@ -0,0 +1,371 @@
+/*
+ * Header file for all AVC INTER prediction kernels
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+#if !defined(__INTER_HEADER__)	// Make sure this file is only included once
+#define __INTER_HEADER__
+
+// Module name: inter_header.inc
+//
+// Header file for all AVC INTER prediction kernels
+//
+
+#define INTER_KERNEL
+
+//-------------------------------------------------------------------------------------------
+// TODO: The followings will be merged with the above definitions later
+//-------------------------------------------------------------------------------------------
+
+
+//------------ Input parameters & bit masks
+
+// SW WA for weighted prediction - 2007/09/06	
+//.declare	guwR1			Base=r1 ElementSize=2 Type=uw	
+//.declare	guwW128			Base=r63.13 ElementSize=2 Type=uw
+
+#ifdef DEV_ILK
+// #define SW_W_128		// Enable SW WA for special Weight=128 case. Can be commented to disable it
+#else	// Pre DEV_ILK
+#define SW_W_128		// Enable SW WA for special Weight=128 case.
+#endif	// DEV_ILK
+
+#ifdef	SW_W_128
+.declare	gudW128			Base=r1.0 ElementSize=4 Type=ud
+#else
+#endif	// SW_W_128
+
+#define		gORIX			r3.4				// :ub, X origin
+#define		gORIY			r3.5				// :ub, Y origin
+
+#define		gCBP			r3.9				// :ub, CBP (0, 0, Y0, Y1, Y2, Y3, Cb, Cr)
+#define		nCBPY_MASK		0x3c
+#define		nCBPU_MASK		0x2
+#define		nCBPV_MASK		0x1
+
+#define		gFIELDFLAGS		r3.1				// :uw - To compute message descriptor for write
+
+#define		gMBTYPE			r3.1				// :ub, MB type
+#define		nMBTYPE_MASK	0x1f
+#define		gFIELDMBFLAG	r3.1				// :ub, Field MB flag
+#define		nFIELDMB_MASK	0x40
+#define		gMBPARITY		r3.3				// :ub, Bottom field flag
+#define		nMBPARITY_MASK	0x01
+
+#define		gWPREDFLAG		r3.0				// :ub, Weighted pred flag
+#define		nWBIDIR_MASK	0xc0
+
+#define		gSUBMB_SHAPE	r3.12				// :ub, Sub-MB shape
+#define		gSUBMB_MODE		r3.13				// :ub, Sub-MB prediction mode
+.declare	guwSUBMB_SHAPE_MODE	Base=r3.6 ElementSize=2 Type=uw
+
+#define		gYWDENOM		r3.14				// :ub, Luma log2 weight denom
+#define		gCWDENOM		r3.15				// :ub, Chroma log2 weight denom
+
+#define		gADDR			r3.24				// :ub, Register addresses of error data / MV
+
+.declare	gubBIDX			Base=r3.16 ElementSize=1 Type=ub
+
+#define		gWGT			r8					// Weights/offsets
+.declare    gdWGT			Base=r8  ElementSize=4 Type=d
+.declare    gwWGT			Base=r8  ElementSize=2 Type=w
+#define		gMV				r4					// MVs
+.declare    gwMV			Base=r4  ElementSize=2 Type=w
+.declare    gdMV			Base=r4  ElementSize=4 Type=d
+
+.declare	gwERRORY		Base=r10 ElementSize=2 Type=w		// 16 GRFs
+.declare	gubERRORY		Base=r10 ElementSize=1 Type=ub
+.declare	gwERRORC		Base=r26 ElementSize=2 Type=w		// 8 GRFs
+.declare	gubERRORC		Base=r26 ElementSize=2 Type=ub
+
+//------------ Address registers
+#define		pMSGDSC			a0.0				// ud: Must be the leading dword of the address register
+#define		pREF			a0.0
+
+#define		pBIDX			a0.2				
+#define		pWGT			a0.3
+#define		pERRORYC		a0.2				// :ud	
+#define		pERRORY			a0.4
+#define		pERRORC			a0.5
+#define		pMV				a0.6	
+
+#define		pWGT_BIDX		a0.1				// :ud, WGT & BIDX
+#define		pRECON_MV		a0.3				// :ud, RECON & MV
+
+#define		pREF0			a0.0				// :uw
+#define		pREF0D			a0.0				// :ud
+#define		pREF1			a0.1
+#define		pREF2			a0.2
+#define		pREF2D			a0.1				// :ud
+#define		pREF3			a0.3
+#define		pREF4			a0.4
+#define		pREF4D			a0.2				// :ud
+#define		pREF5			a0.5
+#define		pREF6			a0.6
+#define		pREF6D			a0.3				// :ud
+#define		pREF7			a0.7
+
+#define		pRES			a0.6
+#define		pRESD			a0.3				// :ud
+#define		pRESULT			a0.7
+
+#define		p0				a0.0
+#define		p1				a0.1
+
+//------------ Constants for static/inline/indirect
+#define		nOFFSET_BIDX	112					// = 32*3+4*4
+
+#define		nOFFSET_WGT		256					// = 32*8
+#define		nOFFSET_WGT_BIDX 0x01000070			// = (256<<16)+112
+#define		nOFFSET_ERROR	0x03400140			// = (320+128*4)<<16+320=0x03400140
+#define		nOFFSET_ERRORY	0x0140
+#define		nOFFSET_ERRORC	0x0340
+#define		nOFFSET_MV		128					// = 32*4
+#define		nOFFSET_RECON_MV 0x04400080			// = (1088<<16)+128		// TODO: OFFSET_RECON is obsolete
+
+//------------ Constants for kernel internal variables
+#define		nOFFSET_INTPY0	0x0640				// = 32*50
+#define		nOFFSET_INTPY1	0x0780				// = 32*60
+#define		nOFFSET_INTPC0	0x06c0				// = 32*54
+#define		nOFFSET_INTPC1	0x0480				// = 32*36
+#define		nOFFSET_INTP0	0x06c00640
+#define		nOFFSET_INTP1	0x04800780
+
+#define		nOFFSET_INTERIM		0x0480				// = 32*36
+#define		nOFFSET_INTERIM2	0x04A00480			// = ((32*37)<<16)|(32*36)
+#define		nOFFSET_INTERIM3	0x04A00480			// = ((32*36+32)<<16)|(32*36)
+#define		nOFFSET_INTERIM4	0x04A00490			// = ((32*37)<<16)|(32*36+16)
+
+#define		nOFFSET_INTERIM4x4		0x04C0			// = 32*38
+#define		nOFFSET_INTERIM4x4_4	0x04E004D0		// = ((32*38+32)<<16)|(32*38+16)
+#define		nOFFSET_INTERIM4x4_5	0x04D004C0		// = ((32*38+16)<<16)|(32*38)
+#define		nOFFSET_INTERIM4x4_6	0x04E004C0		// = ((32*38+32)<<16)|(32*38)
+#define		nOFFSET_INTERIM4x4_7	0x04D004C8		// = ((32*38+16)<<16)|(32*38+8)
+#define		nOFFSET_INTERIM4x4_8	0x04E004D8		// = ((32*38+32)<<16)|(32*38+24)
+#define		nOFFSET_INTERIM4x4_9	0x04F004E8		// = ((32*38+48)<<16)|(32*38+40)
+
+#define		nOFFSET_RES		0x540				// = 32*42
+#define		nOFFSET_REF		0x560				// = 32*43
+#define		nOFFSET_REFC	0x700				// = 32*56
+
+			// Binding table index
+#define		nBDIX_DESTY		0
+#define		nBDIX_DESTC		1
+#define		nBI_LC_DIFF		0x10				// Binding table index diff between luma and chroma
+
+#define		nGRFWIB			32
+#define		nGRFHWIB		16
+
+//------------ Regions
+
+.declare    gudREF			Base=r43 ElementSize=4 SrcRegion=<16;16,1> Type=ud
+.declare    gubREF			Base=r43 ElementSize=1 Type=ub
+.declare    gudREFC			Base=r56 ElementSize=4 SrcRegion=<16;16,1> Type=ud
+
+// 16x16 handling
+.declare    gudREF21x21		Base=r58 ElementSize=4 SrcRegion=<16;16,1> Type=ud
+.declare    gudREF18x10		Base=r66 ElementSize=4 SrcRegion=<16;16,1> Type=ud
+.declare    gubREF18x10		Base=r66 ElementSize=1 SrcRegion=<16;16,1> Type=ub
+
+
+
+.declare    gudREF16x16		Base=r38 ElementSize=4 Type=ud			// 8 GRFs
+.declare    gubREF16x16		Base=r38 ElementSize=1 Type=ub
+.declare    gudREFC16x8		Base=r46 ElementSize=4 Type=ud			// 4 GRFs
+.declare    gubREFC16x8		Base=r46 ElementSize=1 Type=ub
+
+// TODO
+.declare    gubAVG			Base=r56 ElementSize=1 Type=ub
+.declare	gubREFY_BWD		Base=r64 ElementSize=1 Type=ub
+.declare	gubREFC_BWD		Base=r72 ElementSize=1 Type=ub
+
+
+.declare    guwINTPY0		Base=r50 ElementSize=2 SrcRegion=<16;16,1> Type=uw
+.declare	gudINTPY0		Base=r50 ElementSize=4 Type=ud
+.declare    gubINTPY0		Base=r50 ElementSize=1 SrcRegion=<32;16,2> Type=ub
+.declare    guwINTPY1		Base=r60 ElementSize=2 SrcRegion=<16;16,1> Type=uw
+.declare	gudINTPY1		Base=r60 ElementSize=4 Type=ud
+.declare    gubINTPY1		Base=r60 ElementSize=1 SrcRegion=<32;16,2> Type=ub
+.declare    guwYPRED		Base=r50 ElementSize=2 SrcRegion=<8;8,1> Type=uw
+.declare    gubYPRED		Base=r50 ElementSize=1 SrcRegion=<32;16,2> Type=ub
+
+.declare    guwINTPC0		Base=r54 ElementSize=2 SrcRegion=<16;16,1> Type=uw
+.declare    gwINTPC0		Base=r54 ElementSize=2 SrcRegion=<16;16,1> Type=w
+.declare	gudINTPC0		Base=r54 ElementSize=4 Type=ud
+.declare    gubINTPC0		Base=r54 ElementSize=1 SrcRegion=<32;16,2> Type=ub
+.declare    guwINTPC1		Base=r36 ElementSize=2 SrcRegion=<16;16,1> Type=uw
+.declare	gudINTPC1		Base=r36 ElementSize=4 Type=ud
+.declare    gubINTPC1		Base=r36 ElementSize=1 SrcRegion=<32;16,2> Type=ub
+.declare    guwCPRED		Base=r54 ElementSize=2 SrcRegion=<16;8,2> Type=uw
+.declare    gubCPRED		Base=r54 ElementSize=1 SrcRegion=<32;8,4> Type=ub
+
+#define		gINTERIM		r36
+.declare	gubINTERIM_BUF	Base=r36 ElementSize=1 SrcRegion=<32;16,2> Type=ub
+#define		gINTERIM4x4		r38
+.declare	gubINTERIM4x4_BUF Base=r38 ElementSize=1 SrcRegion=<32;16,2> Type=ub
+.declare	gwINTERIM4x4_BUF Base=r38 ElementSize=2  Type=w
+
+.declare	gubINTERIM_BUF2	Base=r42 ElementSize=1 SrcRegion=<8;4,2> Type=ub
+.declare	gwINTERIM_BUF2	Base=r42 ElementSize=2 SrcRegion=<16;16,1> Type=w	
+.declare	guwINTERIM_BUF2	Base=r42 ElementSize=2 Type=uw	
+
+.declare	gwINTERIM_BUF3	Base=r38 ElementSize=2 SrcRegion=<16;16,1> Type=w		// 2 GRFs
+.declare	gubINTERIM_BUF3	Base=r38 ElementSize=1 Type=ub							
+
+.declare	gwTEMP			Base=r42 ElementSize=2 SrcRegion=<16;16,1> Type=w
+
+//------------ General registers
+
+#define		gX				r3.2				// w
+#define		gY				r3.3				// w
+
+#define		gMSGDSC_R		r3.6				// ud
+#define		gMSGDSC_W		r3.7				// ud
+
+#ifdef	SW_W_128
+.declare	gwMBTYPE		Base=r8.6 ElementSize=2 Type=w			// Shared with gLOOP_SUBMB
+
+// TODO
+#define		gLOOP_SUBMB		r8.6
+#define		gLOOP_SUBMBPT	r8.7
+#define		gLOOP_DIR		r9.6
+#define		gLOOPCNT		r9.7				// Loop counter for submodules
+#else
+.declare	gwMBTYPE		Base=r1.0 ElementSize=2 Type=w			// Shared with gLOOP_SUBMB
+
+// TODO
+#define		gLOOP_SUBMB		r1.0
+#define		gLOOP_SUBMBPT	r1.1
+#define		gLOOP_DIR		r8.7
+#define		gLOOPCNT		r9.7				// Loop counter for submodules
+#endif	// SW_W_128
+
+#define		gW0				r34.6				// Temporary WORD 
+#define		gW1				r34.7				// Temporary WORD 
+#define		gW2				r34.8				// Temporary WORD 
+#define		gW3				r34.9				// Temporary WORD 
+#define		gD0				r34.3				// Temporary DWORD
+
+#define		gW4				r34.15
+
+//
+
+#define		gMVX_INT		r34.0				// :w
+#define		gMVY_INT		r34.1				// :w
+#define		gMVX_FRAC		r34.2				// :w
+#define		gMVY_FRAC		r34.3				// :w
+#define		gMVX_FRACC		r34.4				// :w
+#define		gMVY_FRACC		r34.5				// :w
+
+#define		gpINTPY			r34.10
+#define		gpINTPC			r34.11
+#define		gpINTP			r34.5				// DW
+
+#define		gPREDFLAG		r34.12
+#define		gBIDX			r34.13
+#define		gREFPARITY		r34.14
+#define		gCHRMVADJ		r1.14
+#define		gPARITY			r1.15
+#define		gCBP_MASK		r1.1
+
+#define		gMVSTEP			r1.13
+
+#define		gpADDR			r1.2				// :uw (8 words)
+
+#define		gSHAPETEMP		r8.15				// :uw
+
+#define		gCOEFA			r42.0				
+#define		gCOEFB			r42.1				
+#define		gCOEFC			r42.2				
+#define		gCOEFD			r42.3
+
+// Weighted prediction
+#define		gPREDFLAG0		r46.0
+#define		gPREDFLAG1		r46.2
+
+#define		gWEIGHTFLAG		r43.2
+#define		gBIPRED			r43.3
+#define		gYADD			r43.4
+#define		gCADD			r43.5
+#define		gYSHIFT			r43.6
+#define		gCSHIFT			r43.7
+
+#define		gOFFSET			r44.0
+#define		gUOFFSET		r44.1
+#define		gVOFFSET		r44.2
+
+#define		gWT0			r45.0
+#define		gO0				r45.1
+#define		gWT1			r45.2
+#define		gO1				r45.3
+#define		gUW0			r45.4
+#define		gUO0			r45.5
+#define		gUW1			r45.6
+#define		gUO1			r45.7	
+#define		gVW0			r45.8	
+#define		gVO0			r45.9	
+#define		gVW1			r45.10	
+#define		gVO1			r45.11
+
+#define		gWT0_D			r45.0	
+#define		gUW0_D			r45.2	
+
+//------------ Message-related Registers & constants
+#define		gMSGSRC			r2					// Message Source
+
+#define		mMSGHDR			m1		
+#define		mMSGHDRY		m1		
+#define		mMSGHDRC		m2		
+#define		mMSGHDR1		m1		
+#define		mMSGHDR2		m2		
+#define		mMSGHDR3		m3		
+#define		mMSGHDR4		m4		
+#define		mMSGHDRYW		m1		
+#define		mMSGHDRCW		m10		
+
+#ifdef DEV_ILK
+	// 0000 0100(read)  0001(msg len) xxxx(resp len) 1010 (sampler cache) xxxx (field/frame) xxxx xxxx (bidx)
+#define		nDWBRMSGDSC_SC		0x0208A002	// DWORD Block Read Message Descriptor through Data Port, Sampler Cache
+#define		nDWBRMSGDSC_SC_TF	0x0208E602	// DWORD Block Read Message Descriptor through Data Port, Sampler Cache
+#define		nDWBRMSGDSC_SC_BF	0x0208E702	// DWORD Block Read Message Descriptor through Data Port, Sampler Cache
+	// 0000 0101(write) 0001(msg len) xxxx(resp len) 0010 (render cache)  xxxx (field/frame) xxxx xxxx (bidx)										
+#define		nDWBWMSGDSC		0x02082000  // DWORD Block Write Message Descriptor through Data Port, Render Cache
+#define		nDWBWMSGDSC_TF	0x02082600  // DWORD Block Write Message Descriptor through Data Port, Render Cache
+#define		nDWBWMSGDSC_BF	0x02082700  // DWORD Block Write Message Descriptor through Data Port, Render Cache										
+
+#else	// Pre DEV_ILK
+	// 0000 0100(read)  0001(msg len) xxxx(resp len) 1010 (sampler cache) xxxx (field/frame) xxxx xxxx (bidx)
+#define		nDWBRMSGDSC_SC		0x0410A002	// DWORD Block Read Message Descriptor through Data Port, Sampler Cache
+#define		nDWBRMSGDSC_SC_TF	0x0410A602	// DWORD Block Read Message Descriptor through Data Port, Sampler Cache
+#define		nDWBRMSGDSC_SC_BF	0x0410A702	// DWORD Block Read Message Descriptor through Data Port, Sampler Cache
+	// 0000 0101(write) 0001(msg len) xxxx(resp len) 0010 (render cache)  xxxx (field/frame) xxxx xxxx (bidx)										
+#define		nDWBWMSGDSC		0x05102000  // DWORD Block Write Message Descriptor through Data Port, Render Cache
+#define		nDWBWMSGDSC_TF	0x05102600  // DWORD Block Write Message Descriptor through Data Port, Render Cache
+#define		nDWBWMSGDSC_BF	0x05102700  // DWORD Block Write Message Descriptor through Data Port, Render Cache										
+#endif	// DEV_ILK
+
+#define		nDWB_FIELD_MASK	0x0600
+										
+// message data payload
+.declare    mbMSGPAYLOADY	Base=m2  ElementSize=1 SrcRegion=REGION(16,1) Type=b
+.declare    mbMSGPAYLOADC	Base=m11 ElementSize=1 SrcRegion=REGION(16,1) Type=b
+
+// Destination registers for write commit
+#define		gREG_WRITE_COMMIT_Y		r10.0
+#define		gREG_WRITE_COMMIT_UV	r11.0
+
+#define RETURN_REG_INTER	r1.5		// Return pointer for all sub-routine calls (type DWORD)
+
+#define CALL_INTER(subFunc, skipInst)	add (1) RETURN_REG_INTER<1>:ud   ip:ud	1+skipInst*INST_SIZE \n\
+				jmpi (1) subFunc
+#define	RETURN_INTER		mov (1)	ip:ud	RETURN_REG_INTER<0;1,0>:ud		// Return to calling module
+
+
+// End of inter_header.inc
+
+#endif	// !defined(__INTER_HEADER__)
+
diff --git a/i965_drv_video/shaders/h264/mc/interpolate_C_2x2.asm b/i965_drv_video/shaders/h264/mc/interpolate_C_2x2.asm
new file mode 100644
index 0000000..ffa65cf
--- /dev/null
+++ b/i965_drv_video/shaders/h264/mc/interpolate_C_2x2.asm
@@ -0,0 +1,57 @@
+/*
+ * Interpolation kernel for chrominance 2x2 motion compensation
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+//	Kernel name: Interpolate_C_2x2.asm
+//
+//	Interpolation kernel for chrominance 2x2 motion compensation
+//
+//  $Revision: 8 $
+//  $Date: 10/09/06 4:00p $
+//
+
+
+//#if !defined(__Interpolate_C_2x2__)		// Make sure this is only included once
+//#define __Interpolate_C_2x2__
+
+	
+	// (8-xFrac) and (8-yFrac)
+    add (2)		gW0<1>:w			gMVX_FRACC<2;2,1>:w				-0x08:w
+    
+	// Compute the GRF address of the starting position of the reference area
+    mov (1)		pREF0:w				nOFFSET_REFC:w		{NoDDClr}
+	mov (1)		pRESULT:uw			gpINTPC:uw			{NoDDChk}
+
+	// gCOEFA = (8-xFrac)*(8-yFrac)
+    // gCOEFB = xFrac*(8-yFrac)  
+    // gCOEFC = (8-xFrac)*yFrac
+    // gCOEFD = xFrac*yFrac 
+    mul (1)		gCOEFD:w	        gMVX_FRACC:w					gMVY_FRACC:w	{NoDDClr}
+    mul (1)		gCOEFA:w			-gW0:w							-gW1:uw		{NoDDClr,NoDDChk}
+    mul (1)		gCOEFB:w			gMVX_FRACC:w					-gW1:uw		{NoDDClr,NoDDChk}
+    mul (1)		gCOEFC:w		    -gW0:w							gMVY_FRACC:w {NoDDChk}
+    
+    // (8-xFrac)*(8-yFrac)*A
+    // ---------------------
+    mul (8)		acc0<1>:uw			r[pREF0,0]<8;4,1>:ub			gCOEFA:uw
+        
+    // xFrac*(8-yFrac)*B
+    // -------------------
+    mac (8)		acc0<1>:uw			r[pREF0,2]<8;4,1>:ub			gCOEFB:uw
+          
+    // (8-xFrac)*yFrac*C
+    // -------------------
+    mac (8)		acc0<1>:uw			r[pREF0,8]<8;4,1>:ub			gCOEFC:uw
+            
+    // xFrac*yFrac*D
+    // -----------------
+    mac (8)		gwINTERIM_BUF2(0)<1>	r[pREF0,10]<8;4,1>:ub		gCOEFD:uw
+    mov (4)		r[pRESULT]<1>:uw		gwINTERIM_BUF2(0)<4;4,1>		{NoDDClr}
+	mov (4)		r[pRESULT,16]<1>:uw		gwINTERIM_BUF2(0,4)<4;4,1>		{NoDDChk}
+    
+//#endif	// !defined(__Interpolate_C_2x2__)
diff --git a/i965_drv_video/shaders/h264/mc/interpolate_C_4x4.asm b/i965_drv_video/shaders/h264/mc/interpolate_C_4x4.asm
new file mode 100644
index 0000000..ea23b11
--- /dev/null
+++ b/i965_drv_video/shaders/h264/mc/interpolate_C_4x4.asm
@@ -0,0 +1,67 @@
+/*
+ * Interpolation kernel for chrominance 4x4 motion compensation
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+//	Kernel name: Interpolate_C_4x4_Func.asm
+//
+//	Interpolation kernel for chrominance 4x4 motion compensation
+//
+//  $Revision: 8 $
+//  $Date: 10/09/06 4:00p $
+//
+
+
+//#if !defined(__Interpolate_C_4x4_Func__)		// Make sure this is only included once
+//#define __Interpolate_C_4x4_Func__
+
+
+INTERLABEL(Interpolate_C_4x4_Func):
+
+
+	// (8-xFrac) and (8-yFrac)
+    add (2)		gW0<1>:w			gMVX_FRACC<2;2,1>:w				-0x08:w
+
+	// Compute the GRF address of the starting position of the reference area
+    mov (1)		pREF0:w				nOFFSET_REFC:w		{NoDDClr}
+	mov (1)		pREF1:uw			nOFFSET_REFC+16:w	{NoDDChk,NoDDClr}
+	mov (1)		pRESULT:uw			gpINTPC:uw			{NoDDChk}
+
+	// gCOEFA = (8-xFrac)*(8-yFrac)
+    // gCOEFB = xFrac*(8-yFrac)  
+    // gCOEFC = (8-xFrac)*yFrac
+    // gCOEFD = xFrac*yFrac 
+    mul (1)		gCOEFD:w	        gMVX_FRACC:w					gMVY_FRACC:w	{NoDDClr}
+    mul (1)		gCOEFA:w			-gW0:w							-gW1:uw		{NoDDClr,NoDDChk}
+    mul (1)		gCOEFB:w			gMVX_FRACC:w					-gW1:uw		{NoDDClr,NoDDChk}
+    mul (1)		gCOEFC:w		    -gW0:w							gMVY_FRACC:w {NoDDChk}
+
+	add (2)		gW0<1>:uw			pREF0<2;2,1>:uw					16:w
+
+    // (8-xFrac)*(8-yFrac)*A
+    // ---------------------
+    mul (16)	acc0<1>:uw			r[pREF0,0]<16;8,1>:ub			gCOEFA:uw
+    mul (16)	acc1<1>:uw			r[pREF0,nGRFWIB]<16;8,1>:ub		gCOEFA:uw
+        
+    // xFrac*(8-yFrac)*B
+    // -------------------
+    mac (16)	acc0<1>:uw          r[pREF0,2]<16;8,1>:ub			gCOEFB:uw
+    mac (16)	acc1<1>:uw          r[pREF0,nGRFWIB+2]<16;8,1>:ub	gCOEFB:uw
+
+    // (8-xFrac)*yFrac*C
+    // -------------------
+    mov (2)		pREF0<1>:uw			gW0<2;2,1>:uw
+    mac (16)	acc0<1>:uw          r[pREF0,0]<8,1>:ub				gCOEFC:uw
+    mac (16)	acc1<1>:uw          r[pREF0,nGRFWIB]<8,1>:ub		gCOEFC:uw
+            
+    // xFrac*yFrac*D
+    // -----------------
+    mac (16)	r[pRESULT]<1>:uw	r[pREF0,2]<8,1>:ub				gCOEFD:uw
+    mac (16)	r[pRESULT,GRFWIB]<1>:uw r[pREF0,nGRFWIB+2]<8,1>:ub gCOEFD:uw {SecHalf}
+
+   
+//#endif	// !defined(__Interpolate_C_4x4_Func__)
diff --git a/i965_drv_video/shaders/h264/mc/interpolate_Y_4x4.asm b/i965_drv_video/shaders/h264/mc/interpolate_Y_4x4.asm
new file mode 100644
index 0000000..dbb5733
--- /dev/null
+++ b/i965_drv_video/shaders/h264/mc/interpolate_Y_4x4.asm
@@ -0,0 +1,217 @@
+/*
+ * Interpolation kernel for luminance motion compensation
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+// Kernel name: Interpolate_Y_4x4.asm
+//
+// Interpolation kernel for luminance motion compensation
+//
+//  $Revision: 10 $
+//  $Date: 10/09/06 4:00p $
+//
+
+
+	// Compute the GRF address of the starting position of the reference area
+#if 1
+    (-f0.1) mov (1)	pREF:w			nOFFSET_REF+2+nGRFWIB:w
+    (f0.1) mov (1)	pREF:w			nOFFSET_REF+2:w		
+	mov (1)		pRESULT:uw			gpINTPY:uw											
+#else
+    mov (1)		pREF:w				nOFFSET_REF+2+nGRFWIB:w	{NoDDClr}
+	mov (1)		pRESULT:uw			gpINTPY:uw				{NoDDChk}
+#endif
+	
+	/*
+	 *			 |		 |
+	 *		 - - 0 1 2 3 + - 
+	 *			 4 5 6 7
+	 *			 8 9 A B
+	 *			 C D E F
+	 *		 - - + - - - + -
+     *			 |		 |
+	 */
+	
+	// Case 0
+	or.z.f0.1 (16) null:w			gMVY_FRAC<0;1,0>:w				gMVX_FRAC<0;1,0>:w	
+	(f0.1) mov (4)	r[pRESULT]<1>:uw	r[pREF0]<4;4,1>:ub
+	(f0.1) mov (4)	r[pRESULT,16]<1>:uw	r[pREF0,16]<4;4,1>:ub
+	(f0.1) mov (4)	r[pRESULT,32]<1>:uw r[pREF0,32]<4;4,1>:ub
+	(f0.1) mov (4)	r[pRESULT,48]<1>:uw r[pREF0,48]<4;4,1>:ub
+	(f0.1) jmpi INTERLABEL(Exit_Interpolate_Y_4x4)
+	
+	// Store all address registers
+	mov (8)		gpADDR<1>:w			a0<8;8,1>:w
+	
+	mul.z.f0.0 (1) gW4:w			gMVY_FRAC:w						gMVX_FRAC:w
+	and.nz.f0.1 (1) null			gW4:w							1:w
+
+	add (1)		pREF1:uw			pREF0:uw						nGRFWIB/2:uw
+	add (2)		pREF2<1>:uw			pREF0<2;2,1>:uw					nGRFWIB:uw
+	mov (4)		gW0<1>:uw			pREF0<4;4,1>:uw
+
+	(f0.0) jmpi INTERLABEL(Interpolate_Y_H_4x4)
+	(f0.1) jmpi INTERLABEL(Interpolate_Y_H_4x4)	
+	
+	//-----------------------------------------------------------------------
+	// CASE: A69BE (H/V interpolation)
+	//-----------------------------------------------------------------------
+
+	// Compute interim horizontal intepolation 
+	add (1)		pREF0<1>:uw			pREF0<0;1,0>:uw					-34:w 
+	add (1)		pREF1<1>:uw			pREF1<0;1,0>:uw					-18:w {NoDDClr}
+	mov (1)		pRESD:ud			nOFFSET_INTERIM4x4_5:ud				{NoDDChk} // Case 69be
+	
+	// Check whether this position is 'A'
+	cmp.e.f0.0 (1) null				gW4:w							4:w
+
+    $for(0;<2;1) {
+	add (16)	acc0<1>:w			r[pREF0,nGRFWIB*2*%1]<16;4,1>:ub			r[pREF0,nGRFWIB*2*%1+5]<16;4,1>:ub		{Compr}
+	mac (16)	acc0<1>:w			r[pREF0,nGRFWIB*2*%1+1]<16;4,1>:ub			-5:w	{Compr}
+	mac (16)	acc0<1>:w			r[pREF0,nGRFWIB*2*%1+2]<16;4,1>:ub			20:w	{Compr}
+	mac (16)	acc0<1>:w			r[pREF0,nGRFWIB*2*%1+3]<16;4,1>:ub			20:w	{Compr}
+	mac (16)	r[pRES,nGRFWIB*%1]<1>:w		r[pREF0,nGRFWIB*2*%1+4]<16;4,1>:ub	-5:w	{Compr}
+	}
+	// last line
+	add (4)		acc0<1>:w			r[pREF0,nGRFWIB*2*2]<4;4,1>:ub				r[pREF0,nGRFWIB*2*2+5]<4;4,1>:ub
+	mac (4)		acc0<1>:w			r[pREF0,nGRFWIB*2*2+1]<4;4,1>:ub			-5:w
+	mac (4)		acc0<1>:w			r[pREF0,nGRFWIB*2*2+2]<4;4,1>:ub			20:w
+	mac (4)		acc0<1>:w			r[pREF0,nGRFWIB*2*2+3]<4;4,1>:ub			20:w
+	mac (4)		r[pRES,nGRFWIB*2]<1>:w		r[pREF0,nGRFWIB*2*2+4]<4;4,1>:ub	-5:w
+	
+    // Compute interim/output vertical interpolation 
+	mov (1)		pREF6D:ud			nOFFSET_INTERIM4x4_4:ud		{NoDDClr}
+	mov (1)		pREF0D:ud			nOFFSET_INTERIM4x4_7:ud		{NoDDChk,NoDDClr}
+	mov (1)		pREF2D:ud			nOFFSET_INTERIM4x4_8:ud		{NoDDChk,NoDDClr}
+	mov (1)		pREF4D:ud			nOFFSET_INTERIM4x4_9:ud		{NoDDChk}
+
+ 	add (16)	acc0<1>:w			gwINTERIM4x4_BUF(0)<16;16,1>		512:w
+	mac (16)	acc0<1>:w			gwINTERIM4x4_BUF(1)<16;16,1>		-5:w
+	mac (16)	acc0<1>:w			r[pREF6,0]<8,1>:w				20:w
+	
+	(f0.0) mov (1) pRES:uw			nOFFSET_RES:uw					// Case a
+	(-f0.0) mov (1) pRES:uw			nOFFSET_INTERIM4x4:uw				// Case 69be
+	
+	mac (16)	acc0<1>:w			r[pREF0,0]<4,1>:w				-5:w
+	mac (16)	acc0<1>:w			r[pREF0,nGRFWIB]<4,1>:w			1:w
+	mac (16)	acc0<1>:w			r[pREF2,0]<4,1>:w				20:w	
+	asr.sat (16) r[pRES]<2>:ub		acc0<16;16,1>:w					10:w  
+	
+	(f0.0) jmpi INTERLABEL(Return_Interpolate_Y_4x4)
+
+INTERLABEL(Interpolate_Y_H_4x4):
+	
+	cmp.e.f0.0 (1) null				gMVX_FRAC:w						0:w
+	cmp.e.f0.1 (1) null				gMVY_FRAC:w						2:w
+	(f0.0) jmpi INTERLABEL(Interpolate_Y_V_4x4)
+	(f0.1) jmpi INTERLABEL(Interpolate_Y_V_4x4)
+
+	//-----------------------------------------------------------------------
+	// CASE: 123567DEF (H interpolation)
+	//-----------------------------------------------------------------------
+	
+	add (4)		pREF0<1>:uw			gW0<4;4,1>:uw					-2:w		
+	cmp.g.f0.0 (4) null:w			gMVY_FRAC<0;1,0>:w				2:w
+	cmp.e.f0.1 (1) null				gMVX_FRAC:w						2:w
+	(f0.0) add (4) pREF0<1>:uw		pREF0<4;4,1>:uw					nGRFWIB/2:uw
+	
+	cmp.e.f0.0 (1) null:w			gMVY_FRAC<0;1,0>:w				0:w
+
+	(f0.1) mov (1) pRESULT:uw		nOFFSET_RES:uw					// Case 26E
+	(-f0.1) mov (1) pRESULT:uw		nOFFSET_INTERIM4x4:uw			// Case 1357DF
+	
+	// Compute interim/output horizontal interpolation
+	add (16)	acc0<1>:w			r[pREF0]<4,1>:ub				16:w
+	mac (16)	acc0<1>:w			r[pREF0,1]<4,1>:ub				-5:w
+	mac (16)	acc0<1>:w			r[pREF0,2]<4,1>:ub				20:w
+	mac (16)	acc0<1>:w			r[pREF0,3]<4,1>:ub				20:w
+	mac (16)	acc0<1>:w			r[pREF0,4]<4,1>:ub				-5:w
+	mac (16)	acc0<1>:w			r[pREF0,5]<4,1>:ub				1:w
+	asr.sat (16) r[pRESULT]<2>:ub	acc0<16;16,1>:w					5:w
+	
+	(-f0.1) jmpi INTERLABEL(Interpolate_Y_V_4x4)
+	(-f0.0) jmpi INTERLABEL(Average_4x4)
+	
+	jmpi INTERLABEL(Return_Interpolate_Y_4x4)
+
+INTERLABEL(Interpolate_Y_V_4x4):
+
+	cmp.e.f0.0 (1) null				gMVY_FRAC:w						0:w
+	(f0.0) jmpi INTERLABEL(Interpolate_Y_I_4x4)
+	
+	//-----------------------------------------------------------------------
+	// CASE: 48C59D7BF (V interpolation)
+	//-----------------------------------------------------------------------
+	
+	cmp.g.f0.1 (8) null:w			gMVX_FRAC<0;1,0>:w				2:w
+
+	mov (4)		pREF0<1>:uw			gW0<4;4,1>:uw							{NoDDClr}
+	add (4)		pREF4<1>:w			gW0<4;4,1>:uw					16:w	{NoDDChk}
+	
+	(f0.1) add (8) pREF0<1>:uw		pREF0<4;4,1>:uw					1:uw
+
+	cmp.e.f0.0 (1) null:w			gMVX_FRAC<0;1,0>:w				0:w
+	cmp.e.f0.1 (1) null				gMVY_FRAC:w						2:w
+
+	// Compute interim/output vertical interpolation
+	add (16)	acc0<1>:w			r[pREF0,-nGRFWIB]<4,1>:ub		16:w
+	mac (16)	acc0<1>:w			r[pREF0]<4,1>:ub				20:w
+	mac (16)	acc0<1>:w			r[pREF0,nGRFWIB]<4,1>:ub		-5:w
+	mac (16)	acc0<1>:w			r[pREF4,-nGRFWIB]<4,1>:ub		-5:w
+	mac (16)	acc0<1>:w			r[pREF4]<4,1>:ub				20:w	
+	mac (16)	acc0<1>:w			r[pREF4,nGRFWIB]<4,1>:ub		1:w
+	
+	mov (1)		pRESULT:uw			nOFFSET_RES:uw
+	(-f0.0) jmpi INTERLABEL(VFILTER_4x4)
+	(-f0.1) mov (1) pRESULT:uw		nOFFSET_INTERIM4x4:uw
+ 
+ INTERLABEL(VFILTER_4x4):
+ 
+	asr.sat (16) r[pRESULT]<2>:ub	acc0<16;16,1>:w					5:w
+	
+	(-f0.0) jmpi INTERLABEL(Average_4x4)
+	(f0.1) jmpi INTERLABEL(Return_Interpolate_Y_4x4	)
+
+INTERLABEL(Interpolate_Y_I_4x4):
+
+	//-----------------------------------------------------------------------
+	// CASE: 134C (Integer position)
+	//-----------------------------------------------------------------------
+	
+	mov (4)		pREF0<1>:uw			gW0<4;4,1>:uw
+		
+	cmp.e.f0.0 (4) null:w			gMVX_FRAC<0;1,0>:w				3:w
+	cmp.e.f0.1 (4) null:w			gMVY_FRAC<0;1,0>:w				3:w
+	(f0.0) add (4) pREF0<1>:uw		pREF0<4;4,1>:uw					1:uw 
+	(f0.1) add (4) pREF0<1>:uw		pREF0<4;4,1>:uw					nGRFWIB/2:uw
+	
+	mov (16)	guwINTERIM_BUF2(0)<1>	r[pREF0]<4,1>:ub
+	
+INTERLABEL(Average_4x4):
+
+	//-----------------------------------------------------------------------
+	// CASE: 13456789BCDEF (Average)
+	//-----------------------------------------------------------------------
+	
+	// Average two interim results
+	avg.sat (16) gubINTERIM_BUF2(0)<2>	gubINTERIM_BUF2(0)<32;16,2>		gINTERIM4x4<32;16,2>:ub
+
+INTERLABEL(Return_Interpolate_Y_4x4):
+	// Move result
+	mov (1)		pRES:uw				gpINTPY:uw
+	mov (4)		r[pRES,0]<2>:ub		gubINTERIM_BUF2(0,0)
+	mov (4)		r[pRES,16]<2>:ub	gubINTERIM_BUF2(0,8)
+	mov (4)		r[pRES,32]<2>:ub	gubINTERIM_BUF2(0,16)
+	mov (4)		r[pRES,48]<2>:ub	gubINTERIM_BUF2(0,24)
+
+	// Restore all address registers
+	mov (8)		a0<1>:w					gpADDR<8;8,1>:w
+	
+INTERLABEL(Exit_Interpolate_Y_4x4):
+	
+        
+// end of file
diff --git a/i965_drv_video/shaders/h264/mc/interpolate_Y_8x8.asm b/i965_drv_video/shaders/h264/mc/interpolate_Y_8x8.asm
new file mode 100644
index 0000000..e7e3ff9
--- /dev/null
+++ b/i965_drv_video/shaders/h264/mc/interpolate_Y_8x8.asm
@@ -0,0 +1,262 @@
+/*
+ * Interpolation kernel for luminance motion compensation
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+// Kernel name: Interpolate_Y_8x8.asm
+//
+// Interpolation kernel for luminance motion compensation
+//
+//  $Revision: 13 $
+//  $Date: 10/09/06 4:00p $
+//
+
+
+//---------------------------------------------------------------
+// In: pMV => Source address of MV
+// In: gMVX_FRAC<2;2,1>:w => MV fractional components
+// In: f0.1 (1) => If 1, vertical MV is integer
+// In: gpINTPY:uw => Destination address for interpolated result
+// In: Reference area staring from R43
+//		If horizontal/vertical MVs are all integer, 8x8 pixels are on R43~R44 (2 GRFs)
+//		If only horz MV is integer, 8x13 pixels are on R43~R46 (4 GRFs)
+//		If only vert MV is integer, 13x8 pixels are on R43~R46 (4 GRFs)
+//		If no MVs are integer, 13x13 pixels are on R43~R49 (7 GRFs)
+//---------------------------------------------------------------
+
+
+INTERLABEL(Interpolate_Y_8x8_Func):
+
+
+
+	// Check whether MVX is integer MV
+	and.z.f0.0 (1) null:w			r[pMV,0]<0;1,0>:w				0x3:w
+	(-f0.0)	jmpi (1) INTERLABEL(Interpolate_Y_8x8_Func2)
+		
+	// TODO: remove this back-to-back read - huge latency..
+	mov (8)	gubREF(6,2)<1>	gubREF(3,0)<8;8,1>
+    mov (8)	gubREF(5,18)<1>	gubREF(2,24)<8;8,1>		{NoDDClr}
+	mov (8)	gubREF(5,2)<1>	gubREF(2,16)<8;8,1>		{NoDDChk}
+	mov (8)	gubREF(4,18)<1>	gubREF(2,8)<8;8,1>		{NoDDClr}
+	mov (8)	gubREF(4,2)<1>	gubREF(2,0)<8;8,1>		{NoDDChk}
+	mov (8)	gubREF(3,18)<1>	gubREF(1,24)<8;8,1>		{NoDDClr}
+	mov (8)	gubREF(3,2)<1>	gubREF(1,16)<8;8,1>		{NoDDChk}
+	mov (8)	gubREF(2,18)<1>	gubREF(1,8)<8;8,1>		{NoDDClr}
+	mov (8)	gubREF(2,2)<1>	gubREF(1,0)<8;8,1>		{NoDDChk}
+	mov (8)	gubREF(1,18)<1>	gubREF(0,24)<8;8,1>		{NoDDClr}
+	mov (8)	gubREF(1,2)<1>	gubREF(0,16)<8;8,1>		{NoDDChk}
+	mov (8)	gubREF(0,18)<1>	gubREF(0,8)<8;8,1>	
+    mov (8)	gubREF(0,2)<1>	gubREF(0,0)<8;8,1>
+
+INTERLABEL(Interpolate_Y_8x8_Func2):
+
+	// Compute the GRF address of the starting position of the reference area
+    (-f0.1) mov (1)	pREF:w			nOFFSET_REF+2+nGRFWIB:w	
+    (f0.1) mov (1)	pREF:w			nOFFSET_REF+2:w			
+	mov (1)		pRESULT:uw			gpINTPY:uw	
+	
+	/*
+	 *			 |		 |
+	 *		 - - 0 1 2 3 + - 
+	 *			 4 5 6 7
+	 *			 8 9 A B
+	 *			 C D E F
+	 *		 - - + - - - + -
+     *			 |		 |
+	 */
+	
+	// Case 0
+	or.z.f0.1 (16) null:w			gMVY_FRAC<0;1,0>:w				gMVX_FRAC<0;1,0>:w	
+	(f0.1) mov (16)	r[pRESULT]<1>:uw				r[pREF]<16;8,1>:ub
+	(f0.1) mov (16)	r[pRESULT,nGRFWIB]<1>:uw		r[pREF,nGRFWIB]<16;8,1>:ub
+	(f0.1) mov (16)	r[pRESULT,nGRFWIB*2]<1>:uw		r[pREF,nGRFWIB*2]<16;8,1>:ub
+	(f0.1) mov (16)	r[pRESULT,nGRFWIB*3]<1>:uw		r[pREF,nGRFWIB*3]<16;8,1>:ub
+	(f0.1) jmpi INTERLABEL(Exit_Interpolate_Y_8x8)
+	
+	// Store all address registers
+	mov (8)		gpADDR<1>:w			a0<8;8,1>:w
+	
+	mul.z.f0.0 (1) gW4:w			gMVY_FRAC:w						gMVX_FRAC:w
+	add (1)		pREF1:uw			pREF0:uw						nGRFWIB/2:uw
+	and.nz.f0.1 (1) null			gW4:w							1:w
+	add (2)		pREF2<1>:uw			pREF0<2;2,1>:uw					nGRFWIB:uw
+	mov (4)		gW0<1>:uw			pREF0<4;4,1>:uw
+
+	(f0.0) jmpi INTERLABEL(Interpolate_Y_H_8x8)
+	(f0.1) jmpi INTERLABEL(Interpolate_Y_H_8x8)
+	
+	//-----------------------------------------------------------------------
+	// CASE: A69BE (H/V interpolation)
+	//-----------------------------------------------------------------------
+	
+	// Compute interim horizontal intepolation of 12 lines (not 9 lines)
+//	add (1)		pREF0<1>:ud			pREF0<0;1,0>:ud					0xffeeffde:ud	// (-18<<16)|(-34)
+	add (1)		pREF0<1>:uw			pREF0<0;1,0>:uw					-34:w	
+	add (1)		pREF1<1>:uw			pREF1<0;1,0>:uw					-18:w {NoDDClr}	
+	mov (1)		pRESD:ud			nOFFSET_INTERIM3:ud					{NoDDChk}			
+	
+	// Check whether this position is 'A'    
+	cmp.e.f0.0 (1) null				gW4:w							4:w
+	
+	$for(0;<6;2) {
+	add (32)	acc0<1>:w			r[pREF,nGRFWIB*%1]<16;8,1>:ub			r[pREF0,nGRFWIB*%1+5]<16;8,1>:ub		{Compr}
+	mac (32)	acc0<1>:w			r[pREF,nGRFWIB*%1+1]<16;8,1>:ub			-5:w	{Compr}
+	mac (32)	acc0<1>:w			r[pREF,nGRFWIB*%1+2]<16;8,1>:ub			20:w	{Compr}
+	mac (32)	acc0<1>:w			r[pREF,nGRFWIB*%1+3]<16;8,1>:ub			20:w	{Compr}
+	mac (32)	r[pRES,nGRFWIB*%1]<1>:w		r[pREF,nGRFWIB*%1+4]<16;8,1>:ub	-5:w	{Compr}
+	}
+	// last line
+	add (8)		acc0<1>:w			r[pREF,nGRFWIB*6]<8;8,1>:ub				r[pREF,nGRFWIB*6+5]<8;8,1>:ub
+	mac (8)		acc0<1>:w			r[pREF,nGRFWIB*6+1]<8;8,1>:ub			-5:w
+	mac (8)		acc0<1>:w			r[pREF,nGRFWIB*6+2]<8;8,1>:ub			20:w
+	mac (8)		acc0<1>:w			r[pREF,nGRFWIB*6+3]<8;8,1>:ub			20:w
+	mac (8)		r[pRES,nGRFWIB*6]<1>:w		r[pREF,nGRFWIB*6+4]<8;8,1>:ub	-5:w
+
+    // Compute interim/output vertical interpolation 
+    mov (1)		pREF0:ud			nOFFSET_INTERIM2:ud	{NoDDClr}			// set pREF0 and pREF1 at the same time
+	mov (1)		pREF2D:ud			nOFFSET_INTERIM4:ud	{NoDDChk,NoDDClr}	// set pREF2 and pREF3 at the same time
+	(f0.0) sel (1) pRES:uw			gpINTPY:uw	nOFFSET_INTERIM:uw {NoDDChk} // Case A vs. 69BE
+    
+	$for(0;<4;2) {
+	add (32)	acc0<1>:w			r[pREF0,nGRFWIB*%1]<16;16,1>:w				512:w	{Compr}
+	mac (16)	acc0<1>:w			r[pREF2,nGRFWIB*%1]<8,1>:w					-5:w
+	mac (16)	acc1<1>:w			r[pREF2,nGRFWIB*%1+nGRFWIB]<8,1>:w			-5:w
+	mac (32)	acc0<1>:w			r[pREF0,nGRFWIB*%1+nGRFWIB]<16;16,1>:w		20:w	{Compr}
+	mac (16)	acc0<1>:w			r[pREF2,nGRFWIB*%1+nGRFWIB]<8,1>:w			20:w	
+	mac (16)	acc1<1>:w			r[pREF2,nGRFWIB*%1+nGRFWIB+nGRFWIB]<8,1>:w	20:w	
+	mac (32)	acc0<1>:w			r[pREF0,(2+%1)*nGRFWIB]<16;16,1>:w			-5:w	{Compr}
+	mac (16)	acc0<1>:w			r[pREF2,(2+%1)*nGRFWIB]<8,1>:w				1:w
+	mac (16)	acc1<1>:w			r[pREF2,(2+%1)*nGRFWIB+nGRFWIB]<8,1>:w		1:w
+	asr.sat (16) r[pRES,nGRFWIB*%1]<2>:ub			acc0<16;16,1>:w				10:w
+	asr.sat (16) r[pRES,nGRFWIB*%1+nGRFWIB]<2>:ub	acc1<16;16,1>:w				10:w {SecHalf}
+	}
+	
+	(f0.0) jmpi INTERLABEL(Return_Interpolate_Y_8x8)
+	
+INTERLABEL(Interpolate_Y_H_8x8):
+	
+	cmp.e.f0.0 (1) null				gMVX_FRAC:w						0:w
+	cmp.e.f0.1 (1) null				gMVY_FRAC:w						2:w
+	(f0.0) jmpi INTERLABEL(Interpolate_Y_V_8x8)
+	(f0.1) jmpi INTERLABEL(Interpolate_Y_V_8x8)
+	
+	//-----------------------------------------------------------------------
+	// CASE: 123567DEF (H interpolation)
+	//-----------------------------------------------------------------------
+
+	add (4)		pREF0<1>:uw			gW0<4;4,1>:uw					-2:w		
+	cmp.g.f0.0 (4) null:w			gMVY_FRAC<0;1,0>:w				2:w
+	cmp.e.f0.1 (1) null				gMVX_FRAC:w						2:w
+	(f0.0) add (4) pREF0<1>:uw		pREF0<4;4,1>:uw					nGRFWIB/2:uw
+
+	cmp.e.f0.0 (1) null:w			gMVY_FRAC<0;1,0>:w				0:w
+
+	(f0.1) sel (1) pRES:uw			gpINTPY:uw						nOFFSET_INTERIM:uw // Case 26E vs. 1357DF
+	
+	// Compute interim/output horizontal interpolation
+	$for(0;<4;2) {
+	add (16)	acc0<1>:w			r[pREF0,nGRFWIB*%1]<8,1>:ub				16:w
+	add (16)	acc1<1>:w			r[pREF0,nGRFWIB*%1+nGRFWIB]<8,1>:ub		16:w
+	mac (16)	acc0<1>:w			r[pREF0,nGRFWIB*%1+1]<8,1>:ub			-5:w
+	mac (16)	acc1<1>:w			r[pREF0,nGRFWIB*%1+1+nGRFWIB]<8,1>:ub	-5:w
+	mac (16)	acc0<1>:w			r[pREF0,nGRFWIB*%1+2]<8,1>:ub			20:w
+	mac (16)	acc1<1>:w			r[pREF0,nGRFWIB*%1+2+nGRFWIB]<8,1>:ub	20:w
+	mac (16)	acc0<1>:w			r[pREF0,nGRFWIB*%1+3]<8,1>:ub			20:w
+	mac (16)	acc1<1>:w			r[pREF0,nGRFWIB*%1+3+nGRFWIB]<8,1>:ub	20:w
+	mac (16)	acc0<1>:w			r[pREF0,nGRFWIB*%1+4]<8,1>:ub			-5:w
+	mac (16)	acc1<1>:w			r[pREF0,nGRFWIB*%1+4+nGRFWIB]<8,1>:ub	-5:w
+	mac (16)	acc0<1>:w			r[pREF0,nGRFWIB*%1+5]<8,1>:ub			1:w
+	mac (16)	acc1<1>:w			r[pREF0,nGRFWIB*%1+5+nGRFWIB]<8,1>:ub	1:w
+	asr.sat (16) r[pRES,nGRFWIB*%1]<2>:ub			acc0<16;16,1>:w		5:w
+	asr.sat (16) r[pRES,nGRFWIB*%1+nGRFWIB]<2>:ub	acc1<16;16,1>:w		5:w {SecHalf}
+    }
+    
+    (-f0.1) jmpi INTERLABEL(Interpolate_Y_V_8x8)
+	(-f0.0) jmpi INTERLABEL(Average_8x8)
+	
+	jmpi INTERLABEL(Return_Interpolate_Y_8x8)
+
+INTERLABEL(Interpolate_Y_V_8x8):
+
+	cmp.e.f0.0 (1) null				gMVY_FRAC:w						0:w
+	(f0.0) jmpi INTERLABEL(Interpolate_Y_I_8x8)
+	
+	//-----------------------------------------------------------------------
+	// CASE: 48C59D7BF (V interpolation)
+	//-----------------------------------------------------------------------
+
+	mov (2)		pREF0<1>:uw			gW0<4;2,2>:uw	{NoDDClr}
+	mov (2)		pREF2<1>:uw			gW1<2;2,1>:uw	{NoDDChk,NoDDClr}
+	mov (1)		pRES:uw				gpINTPY:uw		{NoDDChk}
+
+	cmp.g.f0.1 (4) null:w			gMVX_FRAC<0;1,0>:w				2:w
+	cmp.e.f0.0 (1) null:w			gMVX_FRAC<0;1,0>:w				0:w
+	(f0.1) add (4) pREF0<1>:uw		pREF0<4;4,1>:uw					1:uw
+
+	cmp.e.f0.1 (1) null				gMVY_FRAC:w						2:w
+	(-f0.0) jmpi INTERLABEL(VFILTER_8x8)
+	(-f0.1) mov (1) pRES:uw		nOFFSET_INTERIM:uw
+	
+  INTERLABEL(VFILTER_8x8): 
+
+	// Compute interim/output vertical interpolation
+	$for(0;<4;2) {
+	add (32)	acc0<1>:w			r[pREF0,nGRFWIB*%1-nGRFWIB]<16;8,1>:ub			16:w {Compr}
+	mac (16)	acc0<1>:w			r[pREF2,nGRFWIB*%1-nGRFWIB]<8,1>:ub				-5:w
+	mac (16)	acc1<1>:w			r[pREF2,nGRFWIB*%1]<8,1>:ub						-5:w
+	mac (32)	acc0<1>:w			r[pREF0,nGRFWIB*%1]<16;8,1>:ub					20:w {Compr}
+	mac (16)	acc0<1>:w			r[pREF2,nGRFWIB*%1]<8,1>:ub						20:w	
+	mac (16)	acc1<1>:w			r[pREF2,nGRFWIB*%1+nGRFWIB]<8,1>:ub				20:w	
+	mac (32)	acc0<1>:w			r[pREF0,nGRFWIB*%1+nGRFWIB]<16;8,1>:ub			-5:w {Compr}
+	mac (16)	acc0<1>:w			r[pREF2,nGRFWIB*%1+nGRFWIB]<8,1>:ub				1:w
+	mac (16)	acc1<1>:w			r[pREF2,nGRFWIB*%1+nGRFWIB+nGRFWIB]<8,1>:ub		1:w
+	asr.sat (16) r[pRES,nGRFWIB*%1]<2>:ub			acc0<16;16,1>:w					5:w
+	asr.sat (16) r[pRES,nGRFWIB*%1+nGRFWIB]<2>:ub	acc1<16;16,1>:w					5:w	{SecHalf}
+	}
+
+	(-f0.0) jmpi INTERLABEL(Average_8x8)
+	(f0.1) jmpi INTERLABEL(Return_Interpolate_Y_8x8)
+
+INTERLABEL(Interpolate_Y_I_8x8):
+
+	//-----------------------------------------------------------------------
+	// CASE: 134C (Integer position)
+	//-----------------------------------------------------------------------
+	
+	mov (2)		pREF0<1>:uw			gW0<2;2,1>:uw		{NoDDClr}
+			
+	mov (1)		pRES:uw				gpINTPY:uw			{NoDDChk}
+
+	cmp.e.f0.0 (2) null:w			gMVX_FRAC<0;1,0>:w				3:w
+	cmp.e.f0.1 (2) null:w			gMVY_FRAC<0;1,0>:w				3:w
+	(f0.0) add (2) pREF0<1>:uw		pREF0<2;2,1>:uw					1:uw 
+	(f0.1) add (2) pREF0<1>:uw		pREF0<2;2,1>:uw					nGRFWIB/2:uw
+	
+	mov (16)	r[pRES]<1>:uw			r[pREF0]<8,1>:ub
+	mov (16)	r[pRES,nGRFWIB]<1>:uw	r[pREF0,nGRFWIB]<8,1>:ub
+	mov (16)	r[pRES,nGRFWIB*2]<1>:uw	r[pREF0,nGRFWIB*2]<8,1>:ub
+	mov (16)	r[pRES,nGRFWIB*3]<1>:uw	r[pREF0,nGRFWIB*3]<8,1>:ub
+	
+INTERLABEL(Average_8x8):
+
+	//-----------------------------------------------------------------------
+	// CASE: 13456789BCDEF (Average)
+	//-----------------------------------------------------------------------
+
+	// Average two interim results
+	avg.sat (16) r[pRES,0]<2>:ub			r[pRES,0]<32;16,2>:ub			gubINTERIM_BUF(0)	
+	avg.sat (16) r[pRES,nGRFWIB]<2>:ub		r[pRES,nGRFWIB]<32;16,2>:ub		gubINTERIM_BUF(1)	
+	avg.sat (16) r[pRES,nGRFWIB*2]<2>:ub	r[pRES,nGRFWIB*2]<32;16,2>:ub	gubINTERIM_BUF(2)	
+	avg.sat (16) r[pRES,nGRFWIB*3]<2>:ub	r[pRES,nGRFWIB*3]<32;16,2>:ub	gubINTERIM_BUF(3)	
+
+INTERLABEL(Return_Interpolate_Y_8x8):
+	// Restore all address registers
+	mov (8)		a0<1>:w					gpADDR<8;8,1>:w
+	
+INTERLABEL(Exit_Interpolate_Y_8x8):
+	        
+// end of file
diff --git a/i965_drv_video/shaders/h264/mc/intra_Header.inc b/i965_drv_video/shaders/h264/mc/intra_Header.inc
new file mode 100644
index 0000000..501c7a8
--- /dev/null
+++ b/i965_drv_video/shaders/h264/mc/intra_Header.inc
@@ -0,0 +1,276 @@
+/*
+ * Header file for all AVC intra prediction kernels
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+#if !defined(__INTRA_HEADER__)	// Make sure this file is only included once
+#define __INTRA_HEADER__
+
+// Module name: intra_header.inc
+//
+// Header file for all AVC intra prediction kernels
+//
+//	This header file defines everything that's specific to intra macroblock kernels
+
+
+//  ----------- Various data buffers and pointers ------------
+//
+//	I_PCM data buffer
+//
+#define		I_PCM_BUF_Y			4
+#define		I_PCM_BUF_UV		12
+
+#define		REG_I_PCM_BUF_Y		r4
+#define		REG_I_PCM_BUF_UV	r12
+
+.declare    I_PCM_Y  Base=REG_I_PCM_BUF_Y  ElementSize=1 SrcRegion=REGION(16,1) Type=ub	// 8-bit I_PCM Y data
+.declare    I_PCM_UV Base=REG_I_PCM_BUF_UV ElementSize=1 SrcRegion=REGION(16,1) Type=ub	// 8-bit I_PCM U/V data
+
+//	Intra macroblock error data blocks
+//
+#define	    ERRBUF		4		// Starting GRF index for error data
+#define		REG_ERRBUF	r4
+.declare    MBBLOCKW Base=REG_ERRBUF ElementSize=2 SrcRegion=REGION(16,1) Type=w	// For 16-bit inter MB
+.declare    MBBLOCKD Base=REG_ERRBUF ElementSize=2 SrcRegion=REGION(16,1) Type=uw	// For use in "send" command
+
+#define	    PERROR		a0.2	// Pointer to macroblock error data
+#define	    PERROR1		a0.3	// Pointer to macroblock error data used by instruction compression
+#define	    PERROR_UD	a0.1	// Pointer to macroblock error data in DWORD unit
+
+//	Intra macroblock reference data
+//
+#define		REG_INTRA_REF_TOP	r49		// Must be an odd numbered GRF register
+.declare    INTRA_REF_TOP0		Base=REG_INTRA_REF_TOP	 ElementSize=1 SrcRegion=REGION(16,1) Type=ub
+.declare    INTRA_REF_TOP		Base=REG_INTRA_REF_TOP.4 ElementSize=1 SrcRegion=REGION(16,1) Type=ub
+										// Actual top row reference data start at offset 4 in BYTE
+.declare    INTRA_REF_TOP_W		Base=REG_INTRA_REF_TOP.2 ElementSize=2 SrcRegion=REGION(16,1) Type=uw
+										// Actual top row reference data start at offset 2 in WORD
+.declare    INTRA_REF_TOP_D		Base=REG_INTRA_REF_TOP ElementSize=4 DstRegion=<1> Type=ud	// Only used in "send" instruction
+
+#define		INTRA_REF_LEFT_ID	50
+#define		REG_INTRA_REF_LEFT	r50
+.declare    INTRA_REF_LEFT0		Base=REG_INTRA_REF_LEFT ElementSize=1 SrcRegion=REGION(8,4) Type=ub
+.declare    INTRA_REF_LEFT		Base=REG_INTRA_REF_LEFT.3 ElementSize=1 SrcRegion=REGION(8,4) Type=ub
+										// Actual left column reference data are located at offset 3 in BYTE
+.declare    INTRA_REF_LEFT_UV	Base=REG_INTRA_REF_LEFT.2 ElementSize=1 SrcRegion=REGION(8,4) Type=ub
+										// Actual left column U/V reference data are located at offset 2 in BYTE
+.declare    INTRA_REF_LEFT_W	Base=REG_INTRA_REF_LEFT.1 ElementSize=2 SrcRegion=REGION(8,2) Type=uw
+										// Actual left column reference data are located at offset 1 in WORD
+.declare    INTRA_REF_LEFT_D	Base=REG_INTRA_REF_LEFT ElementSize=4 DstRegion=<1> Type=ud	// Only used in "send" instruction
+
+#define		PREF_LEFT		a0.4	// Pointer to left reference data
+#define		PREF_LEFT_UD	a0.2	// Pointer in DWORD to left reference data
+
+#define		INTRA_TEMP_0	52
+#define		INTRA_TEMP_1	53
+#define		INTRA_TEMP_2	54
+#define		INTRA_TEMP_3	55
+#define		INTRA_TEMP_4	56
+#define		INTRA_TEMP_5	57
+#define		INTRA_TEMP_6	58
+
+#define		REG_INTRA_TEMP_0	r52
+#define		REG_INTRA_TEMP_1	r53
+#define		REG_INTRA_TEMP_2	r54
+#define		REG_INTRA_TEMP_3	r55
+#define		REG_INTRA_TEMP_4	r56
+#define		REG_INTRA_TEMP_5	r57
+#define		REG_INTRA_TEMP_6	r58
+#define		REG_INTRA_TEMP_7	r59
+#define		REG_INTRA_TEMP_8	r60
+
+// Destination registers for write commit
+#define		REG_WRITE_COMMIT_Y	r60.0
+#define		REG_WRITE_COMMIT_UV	r61.0
+
+//  ----------- Various data buffers and pointers ------------
+//  R32 - R47 for predicted picture buffer (for both Y and U/V blocks)
+//
+#define	    PREDBUF		32		// Starting GRF index for predicted buffer
+#define		REG_PREDBUF	r32
+
+.declare    PRED_Y		Base=REG_PREDBUF ElementSize=1 SrcRegion=REGION(16,1) Type=ub	// Predicted Y picture
+.declare    PRED_YW		Base=REG_PREDBUF ElementSize=2 SrcRegion=REGION(16,1) Type=uw	// Predicted Y picture stored in WORD
+.declare    PRED_Y_FM	Base=REG_PREDBUF ElementSize=1 SrcRegion=REGION(16,1) Type=ub	// Predicted Y picture frame
+.declare    PRED_Y_TF	Base=REG_PREDBUF ElementSize=1 SrcRegion=REGION(16,1) Type=ub	// Predicted Y picture Top field
+
+.declare    PRED_UV		Base=REG_PREDBUF ElementSize=1 SrcRegion=REGION(16,1) Type=ub	// Predicted U/V picture
+.declare    PRED_UVW	Base=REG_PREDBUF ElementSize=2 SrcRegion=REGION(16,1) Type=uw	// Predicted U/V picture stored in WORD
+.declare    PRED_UV_FM	Base=REG_PREDBUF ElementSize=1 SrcRegion=REGION(16,1) Type=ub	// Predicted U/V picture frame
+.declare    PRED_UV_TF	Base=REG_PREDBUF ElementSize=1 SrcRegion=REGION(16,1) Type=ub	// Predicted U/V picture top field
+.declare    PRED_UV_BF	Base=REG_PREDBUF.16 ElementSize=1 SrcRegion=REGION(16,1) Type=ub	// Predicted U/V picture bottom field
+
+//  The same region will also be used as finally decoded Y blocks shared with U/V blocks
+//
+#define	    DECBUF		32
+#define		REG_DECBUF	r32
+.declare    DEC_Y		Base=REG_DECBUF ElementSize=1 SrcRegion=REGION(16,1) Type=ub	// Decoded Y picture
+.declare    DEC_UV		Base=REG_DECBUF ElementSize=1 SrcRegion=REGION(16,1) Type=ub	// Decoded U/V P-/B-picture
+.declare    DEC_UD		Base=REG_DECBUF ElementSize=4 SrcRegion=REGION(8,1) Type=ud		// Decoded buffer in UD type
+
+//	Reference buffer for intra_NxN prediction
+//
+#define		PRED_MODE	REG_INTRA_TEMP_0
+.declare    REF_TOP0	Base=REG_INTRA_TEMP_5	ElementSize=1 SrcRegion=REGION(16,1) Type=ub
+.declare    REF_TOP		Base=REG_INTRA_TEMP_5.4 ElementSize=1 SrcRegion=REGION(16,1) Type=ub
+									// Actual top reference data start from offset 3,i.e. p[-1,-1]
+.declare    REF_TOP_W	Base=REG_INTRA_TEMP_5 ElementSize=2 SrcRegion=REGION(16,1) Type=uw
+.declare    REF_TOP_D	Base=REG_INTRA_TEMP_5 ElementSize=4 SrcRegion=REGION(8,1) Type=ud
+.declare    REF_LEFT	Base=REG_INTRA_TEMP_6 ElementSize=1 SrcRegion=REGION(16,1) Type=ub
+.declare    REF_LEFT_D	Base=REG_INTRA_TEMP_6 ElementSize=4 SrcRegion=REGION(8,1) Type=ud
+
+// For intra prediction plane mode
+//
+.declare    H1	Base=REG_INTRA_TEMP_0 ElementSize=2 SrcRegion=REGION(8,1) Type=w	// Make sure it's an even GRF
+.declare    H2	Base=REG_INTRA_TEMP_0.8 ElementSize=2 SrcRegion=REGION(8,1) Type=w
+.declare    V1	Base=REG_INTRA_TEMP_1 ElementSize=2 SrcRegion=REGION(8,1) Type=w	// Make sure it's the following odd GRF
+.declare    V2	Base=REG_INTRA_TEMP_1.8 ElementSize=2 SrcRegion=REGION(8,1) Type=w
+
+.declare	CP	Base=REG_INTRA_TEMP_2 ElementSize=2 SrcRegion=REGION(16,1) Type=w
+
+#define		PINTRAPRED_Y	a0.7	// Used as luma intra prediction mode pointer
+#define		PINTRAPRED_UV	a0.7	// Used as chroma intra prediction mode pointer
+#define		PINTRA4X4_Y		a0.4	// Used as luma intra_4x4 prediction mode pointer
+
+#define		PBWDCOPY_4		a0.4	// a0.4 - a0.7 used in intra_4x4 prediction for moving data backward
+#define		PBWDCOPY_8		a0.6	// a0.6 - a0.7 used in intra_8x8 prediction for moving data backward
+
+// For Intra_4x4 prediction mode
+//
+.declare    INTRA_4X4_MODE	Base=REG_INTRA_TEMP_1 ElementSize=4 SrcRegion=REGION(1,0) DstRegion=<1> Type=d	// Actually only need 1 DWORD
+
+//  ----------- Intra CURBE constants ------------
+//
+#define		REG_CURBE1	r1
+#define		REG_CURBE2	r2
+#define		INTRA_4X4_OFFSET	1*GRFWIB		// 9 Bytes
+#define		INTRA_8X8_OFFSET	1*GRFWIB+12		// 9 Bytes starting sub-register r1.3:ud
+#define		INTRA_16X16_OFFSET	1*GRFWIB+24		// 4 Bytes starting sub-register r1.6:ud
+#define		INTRA_CHROMA_OFFSET	1*GRFWIB+28		// 4 Bytes starting sub-register r1.7:ud
+
+#define		TOP_REF_OFFSET		REG_CURBE1.10	// r1.5:w
+
+//	Constants used in plane intra prediction mode
+#define		XY_3	REG_CURBE2.4	// Stored BYTE constants x-3 for x=0...7, i.e. -3,-2,...3,4 for U/V, need duplicate to every other byte
+#define		XY_3_1	REG_CURBE2.5	// Stored BYTE constants x-3 for x=0...7, i.e. -3,-2,...3,4 for 2nd instruction in {Comp}
+#define		XY_7	REG_CURBE2.0	// Stored BYTE constants x-7 for x=0...15, i.e. -7,-6,...7,8 for Y
+#define		XY_7_1	REG_CURBE2.1	// Stored BYTE constants x-7 for x=0...15, i.e. -7,-6,...7,8 for 2nd instruction in {Comp}
+
+#define		INV_SHIFT	REG_CURBE2.16
+
+#define		INV_TRANS4	REG_CURBE2.20	// For reverse data transfer for intra_4x4 (0x00020406)
+#define		INV_TRANS48	REG_CURBE2.22	// For reverse data transfer for intra_4x4 (0x0002)
+#define		INV_TRANS8	REG_CURBE1.22	// For reverse data transfer for intra_8x8 (0x0001)
+
+#define		INTRA_MODE	REG_CURBE2.24	// Offset to intra_Pred_4x4_Y from each sub-block
+
+//  ----------- In-line parameters ------------
+//
+#define REG_INLINE	r3
+
+#define INLINE_DW0	REG_INLINE.0<0;1,0>:ud
+#define INLINE_DW1	REG_INLINE.1<0;1,0>:ud
+#define INLINE_DW2	REG_INLINE.2<0;1,0>:ud
+#define INLINE_DW3	REG_INLINE.3<0;1,0>:ud
+#define INLINE_DW4	REG_INLINE.4<0;1,0>:ud
+#define INLINE_DW5	REG_INLINE.5<0;1,0>:ud
+#define INLINE_DW6	REG_INLINE.6<0;1,0>:ud
+#define INLINE_DW7	REG_INLINE.7<0;1,0>:ud
+
+//	Intra macroblock in-line data
+//
+//	In-line DWORD 0
+#define REG_MBAFF_FIELD				REG_INLINE.1	// :uw, can be added directly to lower-word of MSGDSC
+#define MBAFF_FIELD					BIT26+BIT25		// Bits 26:25 - MBAFF field macroblock flag
+													//  00 = Current macroblock is not an MBAFF field macroblock
+													//  11 = Current macroblock is an MBAFF field macroblock
+
+#define REG_FIELD_PARITY			INLINE_DW0
+#define FIELD_PARITY				BIT24			// Bit 24 - Macroblock field parity flag
+													//  0 = Current field is a top field
+													//  1 = Current field is a bottom field
+
+#define REG_FIELD_MACROBLOCK_FLAG	INLINE_DW0
+#define FIELD_MACROBLOCK_FLAG		BIT14			// Bit 14 - Field macroblock flag
+													//  0 = Current macroblock is not a field macroblock
+													//  1 = Current macroblock is a field macroblock
+#define REG_MACROBLOCK_TYPE			INLINE_DW0
+#define MACROBLOCK_TYPE				BIT12+BIT11+BIT10+BIT9+BIT8		// Bit 12:8 - Intra macroblock flag
+
+#define REG_CHROMA_FORMAT_IDC		INLINE_DW0
+#define CHROMA_FORMAT_IDC			BIT3+BIT2		// Bit 3:2 - Chroma format
+													// 00 = Luma only (Monochrome)
+													// 01 = YUV420
+													// 10 = YUV422
+													// 11 = YUV444
+#define	REG_MBAFF_PIC				INLINE_DW0
+#define MBAFF_PIC					BIT1			// Bit 1 - MBAFF Frame picture
+													// 0 = Not an MBAFF frame picture
+													// 1 = An MBAFF frame picture
+#define REG_INTRA_PRED_8X8_BLK2_AVAIL_FLAG	INLINE_DW0
+#define INTRA_PRED_8X8_BLK2_AVAIL_FLAG	BIT4		// Bit 4: Pixel available for block 2 in an intra_8x8 MB.
+
+//	In-line DWORD 1
+#define ORIX			REG_INLINE.4	// :ub, H. origin of the macroblock in macroblock unit
+#define ORIY			REG_INLINE.5	// :ub, V. origin of the macroblock in macroblock unit
+
+//	In-line DWORD 2
+#define	REG_CBPCYB					REG_INLINE.9	// :ub, Coded block pattern
+#define	REG_CBPCY					INLINE_DW2		// Bits 13:8 - Coded block pattern
+													// reflect Y0, Y1, Y2, Y3, Cb4, Cr5
+													// Bit 13 - Y0
+													// Bit 12 - Y1
+													// Bit 11 - Y2
+													// Bit 10 - Y3
+													// Bit 9 - U4
+													// Bit 8 - V5
+#define CBP_MASK					0x3F00:ud		// Bit mask for all CBP bits
+#define CBP_Y_MASK					0x3C00:ud		// Bit mask for CBP Y bits
+#define CBP_UV_MASK					0x0300:ud		// Bit mask for CBP U/V bits
+
+#define CBP_Y0_MASK					BIT13:ud		// Bit mask for CBP Y0 bit
+#define CBP_Y1_MASK					BIT12:ud		// Bit mask for CBP Y1 bit
+#define CBP_Y2_MASK					BIT11:ud		// Bit mask for CBP Y2 bit
+#define CBP_Y3_MASK					BIT10:ud		// Bit mask for CBP Y3 bit
+#define CBP_U_MASK					BIT9:ud			// Bit mask for CBP U bit
+#define CBP_V_MASK					BIT8:ud			// Bit mask for CBP V bit
+
+//	In-line DWORD 3
+#define REG_INTRA_CHROMA_PRED_MODE	REG_INLINE.12	// :ub - Intra chroma prediction mode
+#define INTRA_CHROMA_PRED_MODE		BIT7+BIT6		// Bit 7:6 - Intra chroma prediction mode
+													// 00 = Intra DC prediction
+													// 01 = Intra horizontal prediction
+													// 10 = Intra vertical prediction
+													// 11 = Intra plane prediction
+#define INTRA_CHROMA_PRED_MODE_SHIFT	6			// Intra chroma prediction mode shift
+
+#define REG_INTRA_PRED_AVAIL_FLAG	INLINE_DW3
+#define INTRA_PRED_AVAIL_FLAG		BIT4+BIT3+BIT2+BIT1+BIT0	// Bits 4:0 - Intra prediction available flag
+													// Bit 0: Macroblock A (the left neighbor) entire or top half
+													// Bit 1: Macroblock B (the upper neighbor)
+													// Bit 2: Macroblock C (the above-right neighbor)
+													// Bit 3: Macroblock D (the above-left neighbor)
+													// Bit 4: Macroblock A (the left neighbor) bottom half
+													// Each bit is defined below
+													// 0 = The macroblock is not available for intra prediction
+													// 1 = The macroblock is available for intra prediction
+#define INTRA_PRED_LEFT_TH_AVAIL_FLAG	BIT0		// Bit 0: Macroblock A (the left neighbor) entire or top half
+#define INTRA_PRED_UP_AVAIL_FLAG		BIT1		// Bit 1: Macroblock B (the upper neighbor)
+#define INTRA_PRED_UP_RIGHT_AVAIL_FLAG	BIT2		// Bit 2: Macroblock C (the above-right neighbor)
+#define INTRA_PRED_UP_LEFT_AVAIL_FLAG	BIT3		// Bit 3: Macroblock D (the above-left neighbor)
+#define INTRA_PRED_LEFT_BH_AVAIL_FLAG	BIT4		// Bit 4: Macroblock A (the left neighbor) bottom half
+//#define INTRA_PRED_8X8_BLK2_AVAIL_FLAG	BIT5		// Bit 5: Pixel available for block 2 in an intra_8x8 MB.
+#define REG_INTRA_PRED_AVAIL_FLAG_BYTE	REG_INLINE.12	// Byte location of Intra_Pred_Avail_Flag
+#define REG_INTRA_PRED_AVAIL_FLAG_WORD	REG_INLINE.6	// Word location of Intra_Pred_Avail_Flag
+
+
+.declare    INTRA_PRED_MODE  Base=REG_INLINE.16 ElementSize=1 SrcRegion=REGION(16,1) Type=ub	// Intra prediction mode
+
+// End of intra_header.inc
+
+#endif	// !defined(__INTRA_HEADER__)
+
diff --git a/i965_drv_video/shaders/h264/mc/intra_Pred_4x4_Y_4.asm b/i965_drv_video/shaders/h264/mc/intra_Pred_4x4_Y_4.asm
new file mode 100644
index 0000000..584d012
--- /dev/null
+++ b/i965_drv_video/shaders/h264/mc/intra_Pred_4x4_Y_4.asm
@@ -0,0 +1,240 @@
+/*
+ * Intra predict 4 Intra_4x4 luma blocks
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+#if !defined(__INTRA_PRED_4X4_Y_4__)		// Make sure this is only included once
+#define __INTRA_PRED_4X4_Y_4__
+
+// Module name: intra_Pred_4x4_Y_4.asm
+//
+// Intra predict 4 Intra_4x4 luma blocks
+//
+//--------------------------------------------------------------------------
+//  Input data:
+//
+//  REF_TOP:	Top reference data stored in BYTE with p[-1,-1] at REF_TOP(0,-1)
+//  REF_LEFT:	Left reference data stored in BYTE with p[-1,0] at REF_LEFT(0,0)
+//	PRED_MODE:	Intra prediction mode stored in 4 words (4 LSB)
+//	REG_INTRA_PRED_AVAIL:	Top/Left available flag, (Bit0: Left, Bit1: Top)
+//
+//--------------------------------------------------------------------------
+
+#undef	INTRA_PRED_AVAIL
+#undef	INTRA_REF
+#undef	REF_LEFT_BACK
+#undef	REF_TMP
+#undef	REF_TMP1
+
+#define	INTRA_PRED_AVAIL	REG_INTRA_TEMP_2.8
+#define INTRA_REF			REG_INTRA_TEMP_2
+#define	REF_LEFT_BACK		REG_INTRA_TEMP_8
+#define	REF_TMP				REG_INTRA_TEMP_3
+#define REF_TMP1			REG_INTRA_TEMP_4
+
+intra_Pred_4x4_Y_4:
+
+	mov	(8)		REF_LEFT_BACK<1>:ub	REF_LEFT(0)REGION(8,1)	// Store left referece data
+//	Set up pointers to each intra_4x4 prediction mode
+//
+	and	(4)		PINTRA4X4_Y<1>:w	PRED_MODE<4;4,1>:w	0x0F:w
+	add (4)		INTRA_4X4_MODE(0)	r[PINTRA4X4_Y, INTRA_4X4_OFFSET]<1,0>:ub	INTRA_MODE<4;4,1>:ub
+
+//	Sub-block 0 *****************
+	mov (1)		INTRA_PRED_AVAIL<1>:w	REG_INTRA_PRED_AVAIL<0;1,0>:w		// Top/Left neighbor available flags
+	CALL_1(INTRA_4X4_MODE(0),1)
+
+//	Add error data to predicted intra data
+ADD_ERROR_SB0:
+	add.sat (8)	r[PPREDBUF_Y,PREDSUBBLK0]<2>:ub	r[PERROR,ERRBLK0]<8;4,1>:w		REG_INTRA_4X4_PRED<8;8,1>:w		// Too bad indexed src can't
+	add.sat (8)	r[PPREDBUF_Y,PREDSUBBLK0+16]<2>:ub	r[PERROR,ERRBLK0+32]<8;4,1>:w	REG_INTRA_4X4_PRED.8<8;8,1>:w	// cross 2 GRFs
+
+//	Sub-block 1 *****************
+	mov	(16)	REF_TOP0(0)<1>	REF_TOP0(0,4)REGION(8,1)		// Top reference data
+	mov	(4)		REF_LEFT(0)<1>	r[PPREDBUF_Y,PREDSUBBLK0+6]<8;1,0>:ub	// New left referece data from sub-block 0
+	or (1)		INTRA_PRED_AVAIL<1>:w	REG_INTRA_PRED_AVAIL<0;1,0>:w	1:w		// Left neighbor is available
+	CALL_1(INTRA_4X4_MODE(0,1),1)
+
+//	Add error data to predicted intra data
+ADD_ERROR_SB1:
+	add.sat (8)	r[PPREDBUF_Y,PREDSUBBLK1]<2>:ub	r[PERROR,ERRBLK1]<8;4,1>:w		REG_INTRA_4X4_PRED<8;8,1>:w		// Too bad indexed src can't
+	add.sat (8)	r[PPREDBUF_Y,PREDSUBBLK1+16]<2>:ub	r[PERROR,ERRBLK1+32]<8;4,1>:w	REG_INTRA_4X4_PRED.8<8;8,1>:w	// cross 2 GRFs
+
+//	Sub-block 2 *****************
+	mov	(1)		REF_TOP0(0,3)<1>	REF_LEFT_BACK.3<0;1,0>:ub		// Top-left reference data from stored left referece data
+	mov	(4)		REF_TOP0(0,4)<1>	r[PPREDBUF_Y,PREDSUBBLK0+24]REGION(4,2):ub	// Top reference data
+	mov	(4)		REF_TOP0(0,8)<1>	r[PPREDBUF_Y,PREDSUBBLK0+24+32]REGION(4,2):ub	// Too bad indexed src can't cross 2 GRFs
+	mov	(4)		REF_TOP0(0,12)<1>	r[PPREDBUF_Y,PREDSUBBLK0+30+32]REGION(1,0):ub	// Extended top-right reference data
+	mov	(4)		REF_LEFT(0)<1>		REF_LEFT_BACK.4<4;4,1>:ub	// From stored left referece data
+	or (1)		INTRA_PRED_AVAIL<1>:w	REG_INTRA_PRED_AVAIL<0;1,0>:w	2:w		// Top neighbor is available
+	CALL_1(INTRA_4X4_MODE(0,2),1)
+
+//	Add error data to predicted intra data
+ADD_ERROR_SB2:
+	add.sat (8)	r[PPREDBUF_Y,PREDSUBBLK2]<2>:ub	r[PERROR,ERRBLK2]<8;4,1>:w		REG_INTRA_4X4_PRED<8;8,1>:w		// Too bad indexed src can't
+	add.sat (8)	r[PPREDBUF_Y,PREDSUBBLK2+16]<2>:ub	r[PERROR,ERRBLK2+32]<8;4,1>:w	REG_INTRA_4X4_PRED.8<8;8,1>:w	// cross 2 GRFs
+
+//	Sub-block 3 *****************
+	mov	(16)	REF_TOP0(0)<1>		REF_TOP0(0,4)REGION(8,1)	// Top reference data
+	mov	(8)		REF_TOP0(0,8)<1>	REF_TOP0(0,7)<0;1,0>	// Extended top-right reference data
+	mov	(4)		REF_LEFT(0)<1>	r[PPREDBUF_Y,PREDSUBBLK2+6]<8;1,0>:ub	// Left referece data from sub-block 0
+	or (1)		INTRA_PRED_AVAIL<1>:w	REG_INTRA_PRED_AVAIL<0;1,0>:w	3:w		// Top/Left neighbor are available
+	CALL_1(INTRA_4X4_MODE(0,3),1)
+
+//	Add error data to predicted intra data
+ADD_ERROR_SB3:
+	add.sat (8)	r[PPREDBUF_Y,PREDSUBBLK3]<2>:ub	r[PERROR,ERRBLK3]<8;4,1>:w		REG_INTRA_4X4_PRED<8;8,1>:w		// Too bad indexed src can't
+	add.sat (8)	r[PPREDBUF_Y,PREDSUBBLK3+16]<2>:ub	r[PERROR,ERRBLK3+32]<8;4,1>:w	REG_INTRA_4X4_PRED.8<8;8,1>:w	// cross 2 GRFs
+
+	RETURN
+
+//--------------------------------------------------------------------------
+//  Actual module that performs Intra_4x4 prediction and construction
+//
+//  REF_TOP:		Top reference data stored in BYTE with p[-1,-1] at REF_TOP(0,-1)
+//  REF_LEFT:		Left reference data stored in BYTE with p[-1,0] at REF_LEFT(0,0)
+//	PINTRA4X4_Y:	Intra prediction mode
+//	INTRA_PRED_AVAIL:	Top/Left available flag, (Bit0: Left, Bit1: Top)
+//
+//	Output data:
+//
+//	REG_INTRA_4X4_PRED: Predicted 4x4 block data stored in 1 GRF register
+//--------------------------------------------------------------------------
+intra_Pred_4x4_Y:
+// Mode 0
+INTRA_4X4_VERTICAL:
+	mov (16)	REG_INTRA_4X4_PRED<1>:w	REF_TOP(0)<0;4,1>
+	RETURN_1
+
+// Mode 1
+INTRA_4X4_HORIZONTAL:
+	mov (16)	REG_INTRA_4X4_PRED<1>:w	REF_LEFT(0)<1;4,0>
+	RETURN_1
+
+// Mode 2
+INTRA_4X4_DC:
+// Rearrange reference samples for unified DC prediction code
+//
+    and.nz.f0.0 (16)	NULLREG		INTRA_PRED_AVAIL<0;1,0>:w	2:w  {Compr}
+    and.nz.f0.1 (16)	NULLREG		INTRA_PRED_AVAIL<0;1,0>:w	1:w  {Compr}
+	(-f0.0.any16h) mov (16)	REF_TOP_W(0)<1>	0x8080:uw				// Top macroblock not available for intra prediction
+	(-f0.1.any8h) mov (8)	REF_LEFT(0)<1>	REF_TOP(0)REGION(8,1)	// Left macroblock not available for intra prediction
+	(-f0.0.any8h) mov (8)	REF_TOP(0)<1>	REF_LEFT(0)REGION(8,1)	// Top macroblock not available for intra prediction
+// Perform DC prediction
+//
+	add (4)		PRED_YW(15)<1>	REF_TOP(0)REGION(4,1)	REF_LEFT(0)REGION(4,1)
+	add (2)		PRED_YW(15)<1>	PRED_YW(15)REGION(2,1)	PRED_YW(15,2)REGION(2,1)
+	add (16)	acc0<1>:w		PRED_YW(15)REGION(1,0)	PRED_YW(15,1)REGION(1,0)
+	add	(16)	acc0<1>:w		acc0:w	4:w
+	shr (16)	REG_INTRA_4X4_PRED<1>:w	acc0:w	3:w
+	RETURN_1
+
+// Mode 3
+INTRA_4X4_DIAG_DOWN_LEFT:
+	mov	(8)		INTRA_REF<1>:ub	REF_TOP(0)REGION(8,1)		// Keep REF_TOP untouched for future use
+	mov	(4)		INTRA_REF.8<1>:ub	REF_TOP(0,7)REGION(4,1)	// p[8,-1] = p[7,-1]
+	add (8)		acc0<1>:w		INTRA_REF.2<8;8,1>	2:w		// p[x+2]+2
+	mac (8)		acc0<1>:w		INTRA_REF.1<8;8,1>	2:w		// 2*p[x+1]+p[x+2]+2
+	mac (8)		PRED_YW(15)<1>	INTRA_REF.0<8;8,1>	1:w		// p[x]+2*p[x+1]+p[x+2]+2
+
+	shr (16)	REG_INTRA_4X4_PRED<1>:w	PRED_YW(15)<1;4,1>	2:w		// (p[x]+2*p[x+1]+p[x+2]+2)>>2
+	RETURN_1
+
+// Mode 4
+INTRA_4X4_DIAG_DOWN_RIGHT:
+
+//	Set inverse shift count
+	shl	(4)		REF_TMP<1>:ud	REF_LEFT_D(0)REGION(1,0)	INV_SHIFT<4;4,1>:b
+	mov	(8)		INTRA_REF.4<1>:ub	REF_TOP(0,-1)REGION(8,1)	// INTRA_REF holds all reference data
+	mov	(4)		INTRA_REF<1>:ub	REF_TMP.3<16;4,4>:ub
+
+	add (8)		acc0<1>:w		INTRA_REF.2<8;8,1>:ub	2:w		// p[x+2]+2
+	mac (8)		acc0<1>:w		INTRA_REF.1<8;8,1>:ub	2:w		// 2*p[x+1]+p[x+2]+2
+	mac (8)		INTRA_REF<1>:w	INTRA_REF<8;8,1>:ub		1:w		// p[x]+2*p[x+1]+p[x+2]+2
+
+//	Store data in reversed order
+	add (4)		PBWDCOPY_4<1>:w	INV_TRANS4<4;4,1>:b	INTRA_TEMP_2*GRFWIB:w	// Must match with INTRA_REF
+	shr (16)	REG_INTRA_4X4_PRED<1>:w	r[PBWDCOPY_4]<4,1>:w	2:w
+	RETURN_1
+
+// Mode 5
+INTRA_4X4_VERT_RIGHT:
+
+//	Set inverse shift count
+	shl	(4)		REF_TMP<1>:ud	REF_LEFT_D(0)REGION(1,0)	INV_SHIFT<4;4,1>:b
+	mov	(8)		INTRA_REF.4<1>:ub	REF_TOP(0,-1)REGION(8,1)	// INTRA_REF holds all reference data
+	mov	(4)		INTRA_REF<1>:ub	REF_TMP.3<16;4,4>:ub
+
+	// Even rows
+	avg (8)		PRED_YW(14)<1>	INTRA_REF.4<8;8,1>	INTRA_REF.5<8;8,1>	// avg(p[x-1],p[x])
+	// Odd rows
+	add (8)		acc0<1>:w		INTRA_REF.3<8;8,1>:ub		2:w		// p[x]+2
+	mac (8)		acc0<1>:w		INTRA_REF.2<8;8,1>:ub		2:w		// 2*p[x-1]+p[x]+2
+	mac (8)		acc0<1>:w		INTRA_REF.1<8;8,1>:ub		1:w		// p[x-2]+2*p[x-1]+p[x]+2
+	shr (8)		INTRA_REF<1>:w	acc0:w	2:w		// (p[x-2]+2*p[x-1]+p[x]+2)>>2
+
+	mov	(4)		INTRA_REF.2<2>:w	INTRA_REF.2<4;4,1>:w	// Keep zVR = -2,-3 unchanged
+	mov	(4)		INTRA_REF.3<2>:w	PRED_YW(14)REGION(4,1)	// Combining even rows
+
+	add (4)		PBWDCOPY_4<1>:w	INV_TRANS4<4;4,1>:b	INTRA_TEMP_2*GRFWIB:w	// Must match with INTRA_REF
+	mov (16)	REG_INTRA_4X4_PRED<1>:w	r[PBWDCOPY_4]<4,2>:w
+	RETURN_1
+
+// Mode 6
+INTRA_4X4_HOR_DOWN:
+//	Set inverse shift count
+	shl	(4)		REF_TMP<1>:ud	REF_LEFT_D(0)REGION(1,0)	INV_SHIFT<4;4,1>:b
+	mov	(8)		INTRA_REF.4<1>:ub	REF_TOP(0,-1)REGION(8,1)	// INTRA_REF holds all reference data
+	mov	(4)		INTRA_REF<1>:ub	REF_TMP.3<16;4,4>:ub
+
+	// Even pixels
+	avg (8)		PRED_YW(14)<1>	INTRA_REF<8;8,1>	INTRA_REF.1<8;8,1>	// avg(p[y-1],p[y])
+	// Odd pixels
+	add (8)		acc0<1>:w		INTRA_REF.2<8;8,1>:ub	2:w		// p[y]+2
+	mac (8)		acc0<1>:w		INTRA_REF.1<8;8,1>:ub	2:w		// 2*p[y-1]+p[y]+2
+	mac (8)		REF_TMP<1>:w	INTRA_REF.0<8;8,1>:ub	1:w		// p[y-2]+2*p[y-1]+p[y]+2
+	shr (4)		INTRA_REF.1<2>:w	REF_TMP<4;4,1>:w	2:w		// (p[y-2]+2*p[y-1]+p[y]+2)>>2
+
+	shr	(2)		INTRA_REF.8<1>:w	REF_TMP.4<2;2,1>:w	2:w		// Keep zVR = -2,-3 unchanged
+	mov	(4)		INTRA_REF.0<2>:w	PRED_YW(14)REGION(4,1)	// Combining even pixels
+
+	shl (4)		PBWDCOPY_4<1>:w	INV_TRANS4<4;4,1>:b	1:w		// Convert to WORD offset
+	add (4)		PBWDCOPY_4<1>:w	PBWDCOPY_4<4;4,1>:w	INTRA_TEMP_2*GRFWIB:w	// Must match with INTRA_REF
+	mov (16)	REG_INTRA_4X4_PRED<1>:w	r[PBWDCOPY_4]<4,1>:w
+	RETURN_1
+
+// Mode 7
+INTRA_4X4_VERT_LEFT:
+	// Even rows
+	avg (8)		PRED_YW(14)<2>	REF_TOP(0)REGION(8,1)	REF_TOP(0,1)REGION(8,1)	// avg(p[x],p[x+1])
+	// Odd rows
+	add (8)		acc0<1>:w		REF_TOP(0,2)REGION(8,1)	2:w		// p[x+2]+2
+	mac (8)		acc0<1>:w		REF_TOP(0,1)REGION(8,1)	2:w		// 2*p[x+1]+p[x+2]+2
+	mac (8)		PRED_YW(15)<1>	REF_TOP(0)REGION(8,1)		1:w		// p[x]+2*p[x+1]+p[x+2]+2
+	shr (8)		PRED_YW(14,1)<2>	PRED_YW(15)REGION(8,1)	2:w
+
+	mov (16)	REG_INTRA_4X4_PRED<1>:w	PRED_YW(14)<1;4,2>
+	RETURN_1
+
+// Mode 8
+INTRA_4X4_HOR_UP:
+//	Set extra left reference pixels for unified prediction
+	mov	(8)		REF_LEFT(0,4)<1>	REF_LEFT(0,3)REGION(1,0)	// Copy p[-1,3] to p[-1,y],y=4...7
+	// Even pixels
+	avg (8)		PRED_YW(14)<2>	REF_LEFT(0)REGION(8,1)	REF_LEFT(0,1)REGION(8,1)	// avg(p[y],p[y+1])
+	// Odd pixels
+	add (8)		acc0<1>:w		REF_LEFT(0,2)REGION(8,1)	2:w		// p[y+2]+2
+	mac (8)		acc0<1>:w		REF_LEFT(0,1)REGION(8,1)	2:w		// 2*p[y+1]+p[y+2]+2
+	mac (8)		PRED_YW(15)<1>	REF_LEFT(0)REGION(8,1)		1:w		// p[y]+2*p[y+1]+p[y+2]+2
+	shr (8)		PRED_YW(14,1)<2>	PRED_YW(15)REGION(8,1)	2:w		// (p[y]+2*p[y+1]+p[y+2]+2)>>2
+
+	mov (16)	REG_INTRA_4X4_PRED<1>:w	PRED_YW(14)<2;4,1>
+	RETURN_1
+
+// End of intra_Pred_4x4_Y_4
+
+#endif	// !defined(__INTRA_PRED_4X4_Y_4__)
diff --git a/i965_drv_video/shaders/h264/mc/intra_Pred_8x8_Y.asm b/i965_drv_video/shaders/h264/mc/intra_Pred_8x8_Y.asm
new file mode 100644
index 0000000..ce77771
--- /dev/null
+++ b/i965_drv_video/shaders/h264/mc/intra_Pred_8x8_Y.asm
@@ -0,0 +1,246 @@
+/*
+ * Intra predict 8X8 luma block
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+#if !defined(__INTRA_PRED_8X8_Y__)		// Make sure this is only included once
+#define __INTRA_PRED_8X8_Y__
+
+// Module name: intra_Pred_8X8_Y.asm
+//
+// Intra predict 8X8 luma block
+//
+//--------------------------------------------------------------------------
+//  Input data:
+//
+//  REF_TOP:	Top reference data stored in BYTE with p[-1,-1] at REF_TOP(0,-1), p[-1,-1] and [15,-1] adjusted
+//  REF_LEFT:	Left reference data stored in BYTE with p[-1,0] at REF_LEFT(0,2), REF_LEFT(0,1) (p[-1,-1]) adjusted
+//	PRED_MODE:	Intra prediction mode stored in 4 LSBs
+//	INTRA_PRED_AVAIL:	Top/Left available flag, (Bit0: Left, Bit1: Top)
+//
+//	Output data:
+//
+//	REG_INTRA_8X8_PRED: Predicted 8X8 block data
+//--------------------------------------------------------------------------
+
+#define INTRA_REF	REG_INTRA_TEMP_1
+#define REF_TMP		REG_INTRA_TEMP_2
+
+intra_Pred_8x8_Y:
+
+//	Reference sample filtering
+//
+	// Set up boundary pixels for unified filtering
+	mov (1)		REF_TOP(0,16)<1>	REF_TOP(0,15)REGION(1,0)	// p[16,-1] = p[15,-1]
+	mov	(8)		REF_LEFT(0,2+8)<1>	REF_LEFT(0,2+7)REGION(1,0)	// p[-1,8] = p[-1,7]
+
+	// Top reference sample filtering (!!Consider instruction compression later)
+	add (16)	acc0<1>:w	REF_TOP(0,-1)REGION(16,1)	2:w		// p[x-1,-1]+2
+	mac (16)	acc0<1>:w	REF_TOP(0)REGION(16,1)		2:w		// p[x-1,-1]+2*p[x,-1]+2
+	mac (16)	acc0<1>:w	REF_TOP(0,1)REGION(16,1)	1:w		// p[x-1,-1]+2*p[x,-1]+p[x+1,-1]+2
+	shr	(16)	REF_TMP<1>:w	acc0:w	2:w		// (p[x-1,-1]+2*p[x,-1]+p[x+1,-1]+2)>>2
+
+	// Left reference sample filtering
+	add (16)	acc0<1>:w	REF_LEFT(0)REGION(16,1)		2:w		// p[-1,y-1]+2
+	mac (16)	acc0<1>:w	REF_LEFT(0,1)REGION(16,1)	2:w		// p[-1,y-1]+2*p[-1,y]+2
+	mac (16)	acc0<1>:w	REF_LEFT(0,2)REGION(16,1)	1:w		// p[-1,y-1]+2*p[-1,y]+p[-1,y+1]+2
+	shr	(16)	INTRA_REF<1>:w	acc0:w	2:w		// (p[-1,y-1]+2*p[-1,y]+p[-1,y+1]+2)>>2
+
+	// Re-assign filtered reference samples
+	mov	(16)	REF_TOP(0)<1>	REF_TMP<32;16,2>:ub			// p'[x,-1], x=0...15
+	mov	(8)		REF_LEFT(0)<1>	INTRA_REF.2<16;8,2>:ub		// p'[-1,y], y=0...7
+	mov	(1)		REF_TOP(0,-1)<1>	INTRA_REF<0;1,0>:ub		// p'[-1,-1]
+
+//	Select intra_8x8 prediction mode
+//
+	and	(1)	PINTRAPRED_Y<1>:w	PRED_MODE<0;1,0>:w	0x0F:w
+	// WA for "jmpi" restriction
+	mov (1)	REG_INTRA_TEMP_1<1>:ud	r[PINTRAPRED_Y, INTRA_8X8_OFFSET]:ub
+	jmpi (1) REG_INTRA_TEMP_1<0;1,0>:d
+
+// Mode 0
+#define	PTMP	a0.6
+#define PTMP_D	a0.3
+INTRA_8X8_VERTICAL:
+    $for(0,0; <4; 1,32) {
+	add.sat (16)	r[PPREDBUF_Y,%2]<2>:ub	r[PERROR,%2]<16;16,1>:w	REF_TOP(0)<0;8,1>
+	}
+	RETURN
+
+// Mode 1
+INTRA_8X8_HORIZONTAL:
+    $for(0,0; <8; 2,32) {
+	add.sat (16)	r[PPREDBUF_Y,%2]<2>:ub	r[PERROR,%2]<16;16,1>:w	REF_LEFT(0,%1)<1;8,0>
+	}
+	RETURN
+
+// Mode 2
+INTRA_8X8_DC:
+// Rearrange reference samples for unified DC prediction code
+//
+    and.nz.f0.0 (16)	NULLREG		INTRA_PRED_AVAIL<0;1,0>:w	2:w	// Top macroblock available for intra prediction?
+    and.nz.f0.1 (8)		NULLREG		INTRA_PRED_AVAIL<0;1,0>:w	1:w	// Left macroblock available for intra prediction?
+	(-f0.0.any16h) mov (16)	REF_TOP_W(0)<1>	0x8080:uw
+	(-f0.1.any8h) mov (8)	REF_LEFT(0)<1>	REF_TOP(0)REGION(8,1)
+	(-f0.0.any8h) mov (8)	REF_TOP(0)<1>	REF_LEFT(0)REGION(8,1)
+
+// Perform DC prediction
+//
+	add (8)		PRED_YW(15)<1>	REF_TOP(0)REGION(8,1)	REF_LEFT(0)REGION(8,1)
+	add (4)		PRED_YW(15)<1>	PRED_YW(15)REGION(4,1)	PRED_YW(15,4)REGION(4,1)
+	add (2)		PRED_YW(15)<1>	PRED_YW(15)REGION(2,1)	PRED_YW(15,2)REGION(2,1)
+	add (16)	acc0<1>:w		PRED_YW(15)REGION(1,0)	PRED_YW(15,1)REGION(1,0)
+	add	(16)	acc0<1>:w		acc0:w	8:w
+	shr (16)	REG_INTRA_TEMP_0<1>:w	acc0:w	4:w
+
+	// Add error block
+    $for(0,0; <4; 1,32) {
+	add.sat (16)	r[PPREDBUF_Y,%2]<2>:ub	r[PERROR,%2]<16;16,1>:w	REG_INTRA_TEMP_0<16;16,1>:w
+	}
+	RETURN
+
+// Mode 3
+INTRA_8X8_DIAG_DOWN_LEFT:
+	mov	(8)		REF_TOP(0,16)<1>	REF_TOP(0,15)REGION(8,1)	// p[16,-1] = p[15,-1]
+	add (16)	acc0<1>:w		REF_TOP(0,2)REGION(16,1)	2:w		// p[x+2]+2
+	mac (16)	acc0<1>:w		REF_TOP(0,1)REGION(16,1)	2:w		// 2*p[x+1]+p[x+2]+2
+	mac (16)	acc0<1>:w		REF_TOP(0)REGION(16,1)		1:w		// p[x]+2*p[x+1]+p[x+2]+2
+	shr (16)	REG_INTRA_TEMP_0<1>:w	acc0<16;16,1>:w		2:w		// (p[x]+2*p[x+1]+p[x+2]+2)>>2
+
+	// Add error block
+    $for(0,0; <8; 2,32) {
+	add.sat (16)	r[PPREDBUF_Y,%2]<2>:ub	r[PERROR,%2]<16;16,1>:w	REG_INTRA_TEMP_0.%1<1;8,1>:w
+	}
+	RETURN
+
+// Mode 4
+INTRA_8X8_DIAG_DOWN_RIGHT:
+#define INTRA_REF	REG_INTRA_TEMP_1
+#define REF_TMP		REG_INTRA_TEMP_2
+
+//	Set inverse shift count
+	shl	(4)		REF_TMP<1>:ud	REF_LEFT_D(0,1)REGION(1,0)	INV_SHIFT<4;4,1>:b	// Reverse order bottom 4 pixels of left ref.
+	shl	(4)		REF_TMP.4<1>:ud	REF_LEFT_D(0)REGION(1,0)	INV_SHIFT<4;4,1>:b	// Reverse order top 4 pixels of left ref.
+	mov	(8)		INTRA_REF<1>:ub	REF_TMP.3<32;8,4>:ub
+	mov	(16)	INTRA_REF.8<1>:ub	REF_TOP(0,-1)REGION(16,1)	// INTRA_REF holds all reference data
+
+	add (16)	acc0<1>:w		INTRA_REF.2<16;16,1>:ub		2:w		// p[x+2]+2
+	mac (16)	acc0<1>:w		INTRA_REF.1<16;16,1>:ub		2:w		// 2*p[x+1]+p[x+2]+2
+	mac (16)	acc0<1>:w		INTRA_REF<16;16,1>:ub		1:w		// p[x]+2*p[x+1]+p[x+2]+2
+	shr (16)	INTRA_REF<1>:w	acc0<16;16,1>:w				2:w		// (p[x]+2*p[x+1]+p[x+2]+2)>>2
+
+//	Store data in reversed order
+	add (2)		PBWDCOPY_8<1>:w	INV_TRANS48<2;2,1>:b	INTRA_TEMP_1*GRFWIB:w	// Must match with INTRA_REF
+
+	// Add error block
+    $for(0,96; <8; 2,-32) {
+	add.sat (16)	r[PPREDBUF_Y,%2]<2>:ub	r[PBWDCOPY_8,%1*2]<8,1>:w	r[PERROR,%2]<16;16,1>:w
+	}
+	RETURN
+
+// Mode 5
+INTRA_8X8_VERT_RIGHT:
+#define INTRA_REF	REG_INTRA_TEMP_1
+#define REF_TMP		REG_INTRA_TEMP_2
+#define REF_TMP1	REG_INTRA_TEMP_3
+
+//	Set inverse shift count
+	shl	(4)		REF_TMP<1>:ud	REF_LEFT_D(0,1)REGION(1,0)	INV_SHIFT<4;4,1>:b	// Reverse order bottom 4 pixels of left ref.
+	shl	(4)		REF_TMP.4<1>:ud	REF_LEFT_D(0)REGION(1,0)	INV_SHIFT<4;4,1>:b	// Reverse order top 4 pixels of left ref.
+	mov	(8)		INTRA_REF<1>:ub	REF_TMP.3<32;8,4>:ub
+	mov	(16)	INTRA_REF.8<1>:ub	REF_TOP(0,-1)REGION(16,1)	// INTRA_REF holds all reference data
+
+	// Even rows
+	avg (16)	PRED_YW(14)<1>	INTRA_REF.8<16;16,1>	INTRA_REF.9<16;16,1>	// avg(p[x-1],p[x])
+	// Odd rows
+	add (16)	acc0<1>:w		INTRA_REF.3<16;16,1>:ub		2:w		// p[x]+2
+	mac (16)	acc0<1>:w		INTRA_REF.2<16;16,1>:ub		2:w		// 2*p[x-1]+p[x]+2
+	mac (16)	acc0<1>:w		INTRA_REF.1<16;16,1>:ub		1:w		// p[x-2]+2*p[x-1]+p[x]+2
+	shr (16)	REF_TMP<1>:w	acc0:w	2:w		// (p[x-2]+2*p[x-1]+p[x]+2)>>2
+
+	mov	(8)		INTRA_REF<1>:ub		REF_TMP<16;8,2>:ub		// Keep zVR = -1,-2,-3,-4,-5,-6,-7 sequencially
+	mov	(8)		INTRA_REF.6<2>:ub	REF_TMP.12<16;8,2>:ub	// Keep zVR = -1,1,3,5,7,9,11,13 at even byte
+	mov	(8)		INTRA_REF.7<2>:ub	PRED_Y(14)REGION(8,2)	// Combining zVR = 0,2,4,6,8,10,12,14 at odd byte
+
+	add (2)		PBWDCOPY_8<1>:w	INV_TRANS8<2;2,1>:b	INTRA_TEMP_1*GRFWIB:w	// Must match with INTRA_REF
+
+	// Add error block
+    $for(0,96; <8; 2,-32) {
+	add.sat (16)	r[PPREDBUF_Y,%2]<2>:ub	r[PBWDCOPY_8,%1]<8,2>:ub	r[PERROR,%2]<16;16,1>:w
+	}
+	RETURN
+
+// Mode 6
+INTRA_8X8_HOR_DOWN:
+//	Set inverse shift count
+	shl	(4)		REF_TMP<1>:ud	REF_LEFT_D(0,1)REGION(1,0)	INV_SHIFT<4;4,1>:b	// Reverse order bottom 4 pixels of left ref.
+	shl	(4)		REF_TMP.4<1>:ud	REF_LEFT_D(0)REGION(1,0)	INV_SHIFT<4;4,1>:b	// Reverse order top 4 pixels of left ref.
+	mov	(8)		INTRA_REF<1>:ub	REF_TMP.3<16;4,4>:ub
+	mov	(16)	INTRA_REF.8<1>:ub	REF_TOP(0,-1)REGION(16,1)	// INTRA_REF holds all reference data
+
+	// Odd pixels
+	add (16)	acc0<1>:w	INTRA_REF.2<16;16,1>:ub		2:w		// p[y]+2
+	mac (16)	acc0<1>:w	INTRA_REF.1<16;16,1>:ub		2:w		// 2*p[y-1]+p[y]+2
+	mac (16)	acc0<1>:w	INTRA_REF.0<16;16,1>:ub		1:w		// p[y-2]+2*p[y-1]+p[y]+2
+	shr (16)	PRED_YW(14)<1>	acc0:w	2:w		// (p[y-2]+2*p[y-1]+p[y]+2)>>2
+	// Even pixels
+	avg (16)	INTRA_REF<1>:w	INTRA_REF<16;16,1>:ub	INTRA_REF.1<16;16,1>:ub	// avg(p[y-1],p[y])
+
+	mov	(8)		INTRA_REF.1<2>:ub	PRED_Y(14)REGION(8,2)		// Combining odd pixels to form byte type
+	mov	(8)		INTRA_REF.16<1>:ub	PRED_Y(14,16)REGION(8,2)	// Keep zVR = -2,-3,-4,-5,-6,-7 unchanged
+	// Now INTRA_REF.0 - INTRA_REF.21 contain predicted data
+
+	add (2)		PBWDCOPY_8<1>:w	INV_TRANS48<2;2,1>:b	INTRA_TEMP_1*GRFWIB:w	// Must match with INTRA_REF
+
+	// Add error block
+    $for(0,96; <13; 4,-32) {
+	add.sat (16)	r[PPREDBUF_Y,%2]<2>:ub	r[PBWDCOPY_8,%1]<8,1>:ub	r[PERROR,%2]<16;16,1>:w
+	}
+	RETURN
+
+// Mode 7
+INTRA_8X8_VERT_LEFT:
+	// Even rows
+	avg (16)		PRED_YW(14)<1>	REF_TOP(0)REGION(16,1)	REF_TOP(0,1)REGION(16,1)	// avg(p[x],p[x+1])
+	// Odd rows
+	add (16)		acc0<1>:w		REF_TOP(0,2)REGION(16,1)	2:w		// p[x+2]+2
+	mac (16)		acc0<1>:w		REF_TOP(0,1)REGION(16,1)	2:w		// 2*p[x+1]+p[x+2]+2
+	mac (16)		acc0<1>:w		REF_TOP(0)REGION(16,1)		1:w		// p[x]+2*p[x+1]+p[x+2]+2
+	shr (16)		PRED_YW(15)<1>	acc0<1>:w	2:w		// (p[x]+2*p[x+1]+p[x+2]+2)>>2
+
+	// Add error block
+    $for(0,0; <4; 1,32) {
+	add.sat (16)	r[PPREDBUF_Y,%2]<2>:ub	PRED_YW(14,%1)<16;8,1>	r[PERROR,%2]<16;16,1>:w
+	}
+	RETURN
+
+// Mode 8
+INTRA_8X8_HOR_UP:
+//	Set extra left reference pixels for unified prediction
+	mov	(8)		REF_LEFT(0,8)<1>	REF_LEFT(0,7)REGION(1,0)	// Copy p[-1,7] to p[-1,y],y=8...15
+
+	// Even pixels
+	avg (16)	PRED_YW(14)<1>	REF_LEFT(0)REGION(16,1)	REF_LEFT(0,1)REGION(16,1)	// avg(p[y],p[y+1])
+	// Odd pixels
+	add (16)	acc0<1>:w		REF_LEFT(0,2)REGION(16,1)	2:w		// p[y+2]+2
+	mac (16)	acc0<1>:w		REF_LEFT(0,1)REGION(16,1)	2:w		// 2*p[y+1]+p[y+2]+2
+	mac (16)	acc0<1>:w		REF_LEFT(0)REGION(16,1)		1:w		// p[y]+2*p[y+1]+p[y+2]+2
+	shr (16)	PRED_YW(15)<1>	acc0<1>:w	2:w		// (p[y]+2*p[y+1]+p[y+2]+2)>>2
+
+	// Merge even/odd pixels
+	// The predicted data need to be stored in byte type (22 bytes are required)
+	mov (16)	PRED_Y(14,1)<2>	PRED_Y(15)REGION(16,2)
+
+	// Add error block
+    $for(0,0; <4; 1,32) {
+	add.sat (16)	r[PPREDBUF_Y,%2]<2>:ub	PRED_Y(14,%1*4)<2;8,1>	r[PERROR,%2]<16;16,1>:w
+	}
+	RETURN
+
+// End of intra_Pred_8X8_Y
+
+#endif	// !defined(__INTRA_PRED_8X8_Y__)
diff --git a/i965_drv_video/shaders/h264/mc/intra_Pred_Chroma.asm b/i965_drv_video/shaders/h264/mc/intra_Pred_Chroma.asm
new file mode 100644
index 0000000..a1e1697
--- /dev/null
+++ b/i965_drv_video/shaders/h264/mc/intra_Pred_Chroma.asm
@@ -0,0 +1,155 @@
+/*
+ * Intra predict 8x8 chroma block
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+#if !defined(__INTRA_PRED_CHROMA__)		// Make sure this is only included once
+#define __INTRA_PRED_CHROMA__
+
+// Module name: intra_Pred_Chroma.asm
+//
+// Intra predict 8x8 chroma block
+//
+
+	shr	(1)	PINTRAPRED_UV<1>:w	REG_INTRA_CHROMA_PRED_MODE<0;1,0>:ub	INTRA_CHROMA_PRED_MODE_SHIFT:w	// Bits 1:0 = intra chroma pred mode
+	// WA for "jmpi" restriction
+	mov (1)	REG_INTRA_TEMP_1<1>:d	r[PINTRAPRED_UV, INTRA_CHROMA_OFFSET]:b
+	jmpi (1) REG_INTRA_TEMP_1<0;1,0>:d
+
+// Mode 0
+INTRA_CHROMA_DC:
+    and.nz.f0.0 (8)		NULLREG		REG_INTRA_PRED_AVAIL_FLAG	INTRA_PRED_UP_AVAIL_FLAG:ud	// Top macroblock available for intra prediction?
+
+// Calculate DC values for sub-block 0 and 3
+//
+// Rearrange reference samples for unified DC prediction code
+//	Need to check INTRA_PRED_LEFT_TH_AVAIL_FLAG for blk0 and INTRA_PRED_LEFT_BH_AVAIL_FLAG for blk3
+// 
+	(-f0.0.any8h)	mov (8)		INTRA_REF_TOP_W(0)<1>	0x8080:uw	// Up not available
+
+    and.nz.f0.1 (4)	NULLREG		REG_INTRA_PRED_AVAIL_FLAG	INTRA_PRED_LEFT_TH_AVAIL_FLAG:ud
+	(-f0.1.any4h)	mov (4)		INTRA_REF_LEFT_W(0)<2>	INTRA_REF_TOP_W(0)REGION(4,1)	// Left top half macroblock not available for intra prediction
+    and.nz.f0.1 (4)	NULLREG		REG_INTRA_PRED_AVAIL_FLAG	INTRA_PRED_LEFT_BH_AVAIL_FLAG:ud
+	(-f0.1.any4h)	mov (4)		INTRA_REF_LEFT_W(0,8)<2>	INTRA_REF_TOP_W(0,4)REGION(4,1)	// Left bottom half macroblock not available for intra prediction
+
+	(-f0.0.any8h)	mov (8)		INTRA_REF_TOP_W(0)<1>	INTRA_REF_LEFT_W(0)REGION(8,2)	// Up not available
+// Calculate DC prediction
+//
+	add (16)	PRED_UVW(0)<1>	INTRA_REF_TOP(0)REGION(16,1)	INTRA_REF_LEFT_UV(0)<4;2,1>	// Sum of top and left reference
+	add (8)		PRED_UVW(0)<1>	PRED_UVW(0)<4;2,1>	PRED_UVW(0,2)<4;2,1>	// Sum of first half (blk #0) and second half (blk #3)
+
+	add (8)		PRED_UVW(9)<1>	PRED_UVW(0)<0;2,1>	PRED_UVW(0,2)<0;2,1>	// Sum of blk #0
+	add (8)		PRED_UVW(11,8)<1>	PRED_UVW(0,4)<0;2,1>	PRED_UVW(0,6)<0;2,1>	// Sum of blk #3
+
+// Calculate DC values for sub-block 1 and 2
+//
+// Rearrange reference samples for unified DC prediction code
+//
+	// Blk #2
+	(-f0.0.any4h)	mov (4)		INTRA_REF_TOP_W(0)<1>	0x8080:uw
+	(f0.1.any4h)	mov (4)		INTRA_REF_TOP_W(0)<1>	INTRA_REF_LEFT_W(0,8)REGION(4,2)	// Always use available left reference
+	(-f0.1.any4h)	mov (4)		INTRA_REF_LEFT_W(0,8)<2>	INTRA_REF_TOP_W(0)REGION(4,1)
+
+	// Blk #1
+    and.nz.f0.1 (4)	NULLREG		REG_INTRA_PRED_AVAIL_FLAG	INTRA_PRED_LEFT_TH_AVAIL_FLAG:ud
+	(-f0.1.any4h)	mov (4)		INTRA_REF_LEFT_W(0)<2>	0x8080:uw
+	(f0.0.any4h)	mov (4)		INTRA_REF_LEFT_W(0)<2>	INTRA_REF_TOP_W(0,4)REGION(4,1)	// Always use available top reference
+	(-f0.0.any4h)	mov (4)		INTRA_REF_TOP_W(0,4)<1>	INTRA_REF_LEFT_W(0)REGION(4,2)
+
+// Calculate DC prediction
+//
+	add (8)	PRED_UVW(0)<1>		INTRA_REF_TOP(0)REGION(8,1)	INTRA_REF_LEFT_UV(0,16)<4;2,1>	// Sum of top and left reference for blk #2
+	add (8)	PRED_UVW(0,8)<1>	INTRA_REF_LEFT_UV(0)<4;2,1>	INTRA_REF_TOP(0,8)REGION(8,1)	// Sum of top and left reference for blk #1
+	add (8)	PRED_UVW(0)<1>		PRED_UVW(0)<4;2,1>		PRED_UVW(0,2)<4;2,1>	// Sum of first half (blk #2) and second half (blk #1)
+
+	add (8)	PRED_UVW(9,8)<1>	PRED_UVW(0,4)<0;2,1>	PRED_UVW(0,6)<0;2,1>	// Sum of blk #1
+	add (8)	PRED_UVW(11)<1>		PRED_UVW(0)<0;2,1>		PRED_UVW(0,2)<0;2,1>	// Sum of blk #2
+
+// Now, PRED_UVW(9) holds sums for blks #0 and #1 and PRED_UVW(11) holds sums for blks #2 and #3
+//
+	add (32)	acc0<1>:w	PRED_UVW(9)REGION(16,1)		4:w {Compr}		// Add rounder
+    $for(0; <4; 2) {
+	shr (32)	PRED_UVW(%1)<1>	acc0:w		3:w {Compr}
+	}
+
+	add (32)	acc0<1>:w	PRED_UVW(11)REGION(16,1)	4:w {Compr}		// Add rounder
+    $for(4; <8; 2) {
+	shr (32)	PRED_UVW(%1)<1>	acc0:w		3:w {Compr}
+	}
+	jmpi (1)	End_of_intra_Pred_Chroma
+
+// Mode 1
+INTRA_CHROMA_HORIZONTAL:
+	mov (1)		PREF_LEFT_UD<1>:ud	INTRA_REF_LEFT_ID*GRFWIB*0x00010001+0x00040000:ud	// Set address registers for instruction compression
+    $for(0,0; <8; 2,8) {
+	mov (32)	PRED_UVW(%1)<1>	r[PREF_LEFT,%2+2]<0;2,1>:ub {Compr}	// Actual left column reference data start at offset 2
+	}
+	jmpi (1)	End_of_intra_Pred_Chroma
+
+// Mode 2
+INTRA_CHROMA_VERTICAL:
+    $for(0; <8; 2) {
+	mov (32)	PRED_UVW(%1)<1>	INTRA_REF_TOP(0) {Compr}
+	}
+	jmpi (1)	End_of_intra_Pred_Chroma
+
+// Mode 3
+INTRA_Chroma_PLANE:
+// Refer to H.264/AVC spec Section 8.3.4.4
+
+#undef	C
+
+#define A		REG_INTRA_TEMP_2.0		// All are WORD type
+#define B		REG_INTRA_TEMP_3.0		// B[U] & B[V]
+#define C		REG_INTRA_TEMP_3.2		// C[U] & C[V]
+#define YP		REG_INTRA_TEMP_0		// Store intermediate results of c*(y-3). Make sure it's an even GRF
+#define YP1		REG_INTRA_TEMP_1		// Store intermediate results of c*(y-3). Make sure it's an odd GRF
+#define XP		REG_INTRA_TEMP_5		// Store intermediate results of a+b*(x-3)+16. Make sure it's an odd GRF
+
+// First Calculate constants H and V
+//	H1 = sum((x'+1)*p[4+x',-1]), x'=0,1,2,3
+//	H2 =  sum((-x'-1)*p[2-x',-1]), x'=3,2,1,0
+//	H = H1 + H2
+//	The same calculation holds for V
+//
+	mul (8)	H1(0)<1>	INTRA_REF_TOP(0,8)REGION(8,1)	0x44332211:v
+	mul (8)	H2(0)<1>	INTRA_REF_TOP(0,-2)REGION(8,1)	0xFFEEDDCC:v
+
+	mul (8)	V1(0)<1>	INTRA_REF_LEFT_UV(0,4*4)<4;2,1>	0x44332211:v
+	mul (8)	V2(0)<1>	INTRA_REF_LEFT_UV(0)<4;2,1>		0x00FFEEDD:v
+	mul (2)	V2(0,6)<1>	INTRA_REF_TOP(0,-2)REGION(2,1)	-4:w		// Replace 0*p[-1,3] with -4*p[-1,-1]
+	// Now, REG_INTRA_TEMP_0 holds [H2, H1] and REG_INTRA_TEMP_1 holds [V2, V1]
+
+	// Sum up [H2, H1] and [V2, V1] using instruction compression
+	// ExecSize = 16 is restricted by B-spec for instruction compression
+	// Actual intermediate results are in lower sub-registers after each summing step
+	add	(16)	H1(0)<1>	H1(0)	H2(0) {Compr}	// Results in lower 8 WORDs
+	add	(16)	H1(0)<1>	H1(0)	H1(0,4) {Compr}	// Results in lower 4 WORDs
+	add	(16)	H1(0)<1>	H1(0)	H1(0,2) {Compr}	// Results in lower 2 WORDs
+
+//	Calculate a, b, c and further derivations
+	mov	(16)	acc0<1>:w	32:w
+	mac	(4)		acc0<1>:w	H1(0)<16;2,1>	34:w
+	shr	(4)		B<1>:w		acc0:w	6:w		// Done b,c
+	mov	(16)	acc0<1>:w	16:w
+	mac	(16)	acc0<1>:w	INTRA_REF_TOP(0,7*2)<0;2,1>		16:w
+	mac	(16)	A<1>:w		INTRA_REF_LEFT_UV(0,7*4)<0;2,1>	16:w	// A = a+16
+	mac (16)	XP<1>:w		B<0;2,1>:w		XY_3<1;2,0>:b		// XP = A+b*(x-3)
+	mul	(8)		YP<1>:w		C<0;2,1>:w		XY_3<2;2,0>:b		// YP = c*(y-3), Even portion
+	mul	(8)		YP1<1>:w	C<0;2,1>:w		XY_3_1<2;2,0>:b	// YP = c*(y-3), Odd portion
+
+//	Finally the intra_Chroma plane prediction
+    $for(0; <8; 2) {
+	add (32)	acc0<1>:w		XP<16;16,1>:w	YP.%1<0;2,1>:w {Compr}
+	shr.sat (32)	PRED_UV(%1)<2>	acc0<16;16,1>:w	5:w {Compr}
+	}
+
+End_of_intra_Pred_Chroma:
+
+// End of intra_Pred_Chroma
+
+#endif	// !defined(__INTRA_PRED_CHROMA__)
diff --git a/i965_drv_video/shaders/h264/mc/intra_pred_16x16_Y.asm b/i965_drv_video/shaders/h264/mc/intra_pred_16x16_Y.asm
new file mode 100644
index 0000000..94ccb07
--- /dev/null
+++ b/i965_drv_video/shaders/h264/mc/intra_pred_16x16_Y.asm
@@ -0,0 +1,111 @@
+/*
+ * Intra predict 16x16 luma block
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+// Module name: intra_Pred_16x16_Y.asm
+//
+// Intra predict 16x16 luma block
+//
+	and	(1)	PINTRAPRED_Y<1>:w	INTRA_PRED_MODE(0)REGION(1,0)	0x0F:w
+	// WA for "jmpi" restriction
+	mov (1)	REG_INTRA_TEMP_1<1>:ud	r[PINTRAPRED_Y, INTRA_16X16_OFFSET]:ub
+	jmpi (1) REG_INTRA_TEMP_1<0;1,0>:d
+
+// Mode 0
+INTRA_16x16_VERTICAL:
+    $for(0; <16; 2) {
+	mov (32)	PRED_YW(%1)<1>	INTRA_REF_TOP(0) {Compr}
+	}
+	jmpi (1) End_intra_Pred_16x16_Y
+
+// Mode 1
+INTRA_16x16_HORIZONTAL:
+	mov (1)		PREF_LEFT_UD<1>:ud	INTRA_REF_LEFT_ID*GRFWIB*0x00010001+0x00040000:ud	// Set address registers for instruction compression
+    $for(0,0; <16; 2,8) {
+	mov (32)	PRED_YW(%1)<1>	r[PREF_LEFT,%2+3]<0;1,0>:ub {Compr}	// Actual left column reference data start at offset 3
+	}
+	jmpi (1) End_intra_Pred_16x16_Y
+
+// Mode 2
+INTRA_16x16_DC:
+    and.nz.f0.0 (8)	NULLREG		REG_INTRA_PRED_AVAIL_FLAG	INTRA_PRED_UP_AVAIL_FLAG:ud	// Top macroblock available for intra prediction?
+    and (8)			acc0<1>:ud	REG_INTRA_PRED_AVAIL_FLAG	INTRA_PRED_LEFT_TH_AVAIL_FLAG+INTRA_PRED_LEFT_BH_AVAIL_FLAG:ud	// Left macroblock available for intra prediction?
+    xor.z.f0.1 (8)	NULLREG		acc0:ud	INTRA_PRED_LEFT_TH_AVAIL_FLAG+INTRA_PRED_LEFT_BH_AVAIL_FLAG:ud	// Left macroblock available for intra prediction?
+// Rearrange reference samples for unified DC prediction code
+//
+	(-f0.0.any8h)	mov (8)	INTRA_REF_TOP_W(0)<1>	0x8080:uw
+	(-f0.1.any8h)	mov (8)	INTRA_REF_LEFT(0)<4>	INTRA_REF_TOP(0)REGION(8,1)
+	(-f0.1.any8h)	mov (8)	INTRA_REF_LEFT(1)<4>	INTRA_REF_TOP(0,8)REGION(8,1)
+	(-f0.0.any8h)	mov (8)	INTRA_REF_TOP(0)<1>		INTRA_REF_LEFT(0)REGION(8,4)
+	(-f0.0.any8h)	mov (8)	INTRA_REF_TOP(0,8)<1>	INTRA_REF_LEFT(1)REGION(8,4)	// Split due to HW limitation
+// Perform DC prediction
+//
+	add (16)	PRED_YW(15)<1>	INTRA_REF_LEFT(0)REGION(8,4)	INTRA_REF_TOP(0)REGION(16,1)
+	add (8)		PRED_YW(15)<1>	PRED_YW(15)REGION(8,1)	PRED_YW(15,8)REGION(8,1)
+	add (4)		PRED_YW(15)<1>	PRED_YW(15)REGION(4,1)	PRED_YW(15,4)REGION(4,1)
+	add (2)		PRED_YW(15)<1>	PRED_YW(15)REGION(2,1)	PRED_YW(15,2)REGION(2,1)
+	add (32)	acc0<1>:w		PRED_YW(15)REGION(1,0)	PRED_YW(15,1)REGION(1,0) {Compr}	// Set up both acc0 and acc1
+	add	(32)	acc0<1>:w		acc0:w	16:w {Compr}
+
+    $for(0; <16; 2) {
+	shr (32)	PRED_YW(%1)<1>	acc0:w	5:w {Compr}
+	}
+	jmpi (1) End_intra_Pred_16x16_Y
+
+// Mode 3
+INTRA_16x16_PLANE:
+// Refer to H.264/AVC spec Section 8.3.3.4
+
+#define A		REG_INTRA_TEMP_2.0		// All are WORD type
+#define B		REG_INTRA_TEMP_3.0
+#define C		REG_INTRA_TEMP_3.1
+#define YP		REG_INTRA_TEMP_0		// Store intermediate results of c*(y-7). Make sure it's an even GRF
+#define YP1		REG_INTRA_TEMP_1		// Store intermediate results of c*(y-7). Make sure it's an odd GRF, used in {Comp}
+#define XP		REG_INTRA_TEMP_5		// Store intermediate results of a+b*(x-7)+16. Make sure it's an odd GRF
+
+// First Calculate constants H and V
+//	H1 = sum((-x'-1)*p[8+x',-1]), x'=0,1,...7
+//	H2 =  sum((-x'-1)*p[6-x',-1]), x'=7,6,...0
+//	H = -H1 + H2
+//	The same calculation holds for V
+//
+	mul (8)	H1(0)<1>	INTRA_REF_TOP(0,8)REGION(8,1)		0x89ABCDEF:v
+	mul (8)	H2(0)<1>	INTRA_REF_TOP(0,-1)REGION(8,1)		0xFEDCBA98:v
+
+	mul (8)	V1(0)<1>	INTRA_REF_LEFT(0,8*4)REGION(8,4)	0x89ABCDEF:v
+	mul (8)	V2(0)<1>	INTRA_REF_LEFT(0)REGION(8,4)		0x0FEDCBA9:v
+	mul (1)	V2(0,7)<1>	INTRA_REF_TOP(0,-1)<0;1,0>	-8:w		// Replace 0*p[-1,7] with -8*p[-1,-1]
+	// Now, REG_INTRA_TEMP_0 holds [H2, -H1] and REG_INTRA_TEMP_1 holds [V2, -V1]
+
+	// Sum up [H2, -H1] and [V2, -V1] using instruction compression
+	// ExecSize = 16 is restricted by B-spec for instruction compression
+	// Actual intermediate results are in lower sub-registers after each summing step
+	add	(16)	H1(0)<1>	-H1(0)	H2(0)	{Compr}	// Results in lower 8 WORDs
+	add	(16)	H1(0)<1>	H1(0)	H1(0,4) {Compr}	// Results in lower 4 WORDs
+	add	(16)	H1(0)<1>	H1(0)	H1(0,2) {Compr}	// Results in lower 2 WORDs
+	add	(16)	H1(0)<1>	H1(0)	H1(0,1) {Compr}	// Results in lower 1 WORD
+
+//	Calculate a, b, c and further derivations
+	mov	(16)	acc0<1>:w	32:w
+	mac	(2)		acc0<1>:w	H1(0)<16;1,0>	5:w
+	shr	(2)		B<1>:w		acc0:w	6:w		// Done b,c
+	mov	(16)	acc0<1>:w	16:w
+	mac	(16)	acc0<1>:w	INTRA_REF_TOP(0,15)<0;1,0>	16:w
+	mac	(16)	A<1>:w		INTRA_REF_LEFT(0,15*4)<0;1,0>	16:w	// A = a+16
+	mac (16)	XP<1>:w		B<0;1,0>:w		XY_7<16;16,1>:b			// XP = A+b*(x-7)
+	mul	(8)		YP<1>:w		C<0;1,0>:w		XY_7<16;8,2>:b			// YP = c*(y-7), even portion
+	mul	(8)		YP1<1>:w	C<0;1,0>:w		XY_7_1<16;8,2>:b		// YP = c*(y-7), odd portion
+
+//	Finally the intra_16x16 plane prediction
+    $for(0,0; <16; 2,1) {
+	add (32)	acc0<1>:w		XP<16;16,1>:w	YP.%2<16;16,0>:w {Compr}	// Set Width!= 1 to trick EU to use YP_1.%2 for 2nd instruction
+	shr.sat (32)	PRED_Y(%1)<2>	acc0<16;16,1>:w	5:w {Compr}
+	}
+
+End_intra_Pred_16x16_Y:
+// End of intra_Pred_16x16_Y
diff --git a/i965_drv_video/shaders/h264/mc/loadRef_C_10x5.asm b/i965_drv_video/shaders/h264/mc/loadRef_C_10x5.asm
new file mode 100644
index 0000000..3c0e851
--- /dev/null
+++ b/i965_drv_video/shaders/h264/mc/loadRef_C_10x5.asm
@@ -0,0 +1,57 @@
+/*
+ * Load reference 10x5 area for chroma NV12 4x4 MC
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+// Kernel name: LoadRef_C_10x5.asm
+//
+// Load reference 10x5 area for chroma NV12 4x4 MC
+
+
+//#if !defined(__LOADREF_C_10x5__)		// Make sure this is only included once
+//#define __LOADREF_C_10x5__
+
+
+#if 1
+
+	// Compute integer and fractional components of MV
+    asr (2)		gMVX_INT<1>:w		r[pMV,0]<2;2,1>:w				0x03:w {NoDDClr}
+    and (2)		gMVX_FRACC<1>:w		r[pMV,0]<2;2,1>:w				0x07:w {NoDDChk}
+    
+    // Check whether MVY is integer
+	or.z.f0.0 (8) null:w			gMVY_FRACC<0;1,0>:w				0:w
+	
+	// Compute top-left corner position to be loaded
+    mov (2)		gMSGSRC.0<1>:d		gMVX_INT<2;2,1>:w
+	shl (1)		gMSGSRC.0:d			gMSGSRC.0:d						1:w
+
+	(f0.0) add (1)	pMSGDSC:ud		gMSGDSC_R:ud					RESP_LEN(2)+nBI_LC_DIFF:ud
+	(-f0.0) add (1) pMSGDSC:ud		gMSGDSC_R:ud					RESP_LEN(3)+nBI_LC_DIFF:ud
+	
+    // Read 16x5 pixels - TODO: Reading 12x5 instead of 16x5 took more time on CL. Why?
+    (f0.0) mov (1)	gMSGSRC.2:ud	0x00030009:ud					//{NoDDChk}
+    (-f0.0) mov (1)	gMSGSRC.2:ud	0x00040009:ud					//{NoDDChk}
+    send (8)	gudREFC(0)<1>	    mMSGHDRC						gMSGSRC<8;8,1>:ud	DAPREAD	pMSGDSC:ud
+
+#else
+
+	add (1)		pMSGDSC:ud			gMSGDSC_R:ud					RESP_LEN(3)+nBI_LC_DIFF:ud
+
+	// Compute integer and fractional components of MV
+    asr (2)		gMVX_INT<1>:w		r[pMV,0]<2;2,1>:w				0x03:w {NoDDClr}
+    and (2)		gMVX_FRACC<1>:w		r[pMV,0]<2;2,1>:w				0x07:w {NoDDChk}
+	
+	// Compute top-left corner position to be loaded
+    mov (2)		gMSGSRC.0<1>:d		gMVX_INT<2;2,1>:w
+	shl (1)		gMSGSRC.0:d			gMSGSRC.0:d						1:w
+
+    // Read 16x5 pixels
+    mov (1)		gMSGSRC.2:ud		0x00040009:ud					{NoDDChk}
+    send (8)	gudREFC(0)<1>	    mMSGHDRC						gMSGSRC<8;8,1>:ud	DAPREAD	pMSGDSC:ud
+#endif
+        
+//#endif	// !defined(__LOADREF_C_10x5__)
diff --git a/i965_drv_video/shaders/h264/mc/loadRef_C_6x3.asm b/i965_drv_video/shaders/h264/mc/loadRef_C_6x3.asm
new file mode 100644
index 0000000..5ed7b69
--- /dev/null
+++ b/i965_drv_video/shaders/h264/mc/loadRef_C_6x3.asm
@@ -0,0 +1,38 @@
+/*
+ * Load reference 6x3 area for chroma NV12 4x4 MC
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+// Kernel name: LoadRef_C_6x3.asm
+//
+// Load reference 6x3 area for chroma NV12 4x4 MC
+
+
+//#if !defined(__LOADREF_C_6x3__)		// Make sure this is only included once
+//#define __LOADREF_C_6x3__
+
+
+#ifdef DEV_ILK
+	add (1)		pMSGDSC:ud			gMSGDSC_R:ud					0x00100010:ud
+#else
+	add (1)		pMSGDSC:ud			gMSGDSC_R:ud					0x00010010:ud
+#endif	// DEV_ILK
+
+	// Compute integer and fractional components of MV
+    asr (2)		gMVX_INT<1>:w		r[pMV,0]<2;2,1>:w				0x03:w {NoDDClr}
+    and (2)		gMVX_FRACC<1>:w		r[pMV,0]<2;2,1>:w				0x07:w {NoDDChk}
+	
+	// Compute top-left corner position to be loaded
+    mov (2)		gMSGSRC.0<1>:d		gMVX_INT<2;2,1>:w
+	shl (1)		gMSGSRC.0:d			gMSGSRC.0:d						1:w
+
+    // Read 8x3 pixels
+    mov (1)		gMSGSRC.2:ud		0x00020005:ud
+    send (8)	gudREFC(0)<1>	    mMSGHDRC						gMSGSRC<8;8,1>:ud	DAPREAD	pMSGDSC:ud
+
+        
+//#endif	// !defined(__LOADREF_C_6x3__)
diff --git a/i965_drv_video/shaders/h264/mc/loadRef_Y_16x13.asm b/i965_drv_video/shaders/h264/mc/loadRef_Y_16x13.asm
new file mode 100644
index 0000000..b233ea1
--- /dev/null
+++ b/i965_drv_video/shaders/h264/mc/loadRef_Y_16x13.asm
@@ -0,0 +1,127 @@
+/*
+ * Load reference 16x13 area for luma 8x8 MC
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+// Kernel name: LoadRef_Y_16x13.asm
+//
+// Load reference 16x13 area for luma 8x8 MC
+
+
+//#if !defined(__LOADREF_Y_16x13__)		// Make sure this is only included once
+//#define __LOADREF_Y_16x13__
+
+#if 1
+
+#if 1
+
+	// Check whether MVX is integer MV
+	and.z.f0.0 (1) null:w			r[pMV,0]<0;1,0>:w				0x3:w
+
+	// Compute integer and fractional components of MV
+    and (2)		gMVX_FRAC<1>:w		r[pMV,0]<2;2,1>:w				0x03:w	//{NoDDClr}
+    asr (2)		gMVX_INT<1>:w		r[pMV,0]<2;2,1>:w				0x02:w	//{NoDDChk}
+    
+    // Check whether MVY is integer
+	or.z.f0.1 (8) null:w			gMVY_FRAC<0;1,0>:w				0:w
+	
+	// If MVX is a multiple of 4 (..., -4, 0, 4, ...) integer MV, do special handling
+	(f0.0)	jmpi (1)	INTERLABEL(LOADREF_MVXZERO)	
+	
+    // Set message descriptor
+    (f0.1) add (1)	pMSGDSC:ud		gMSGDSC_R:ud					RESP_LEN(4):ud	
+	(-f0.1) add (1)	pMSGDSC:ud		gMSGDSC_R:ud					RESP_LEN(7):ud
+	
+	// Compute top-left corner position to be loaded
+	// TODO: sel
+    (-f0.1) add (2)	gMSGSRC.0<1>:d	gMVX_INT<2;2,1>:w				-0x02:d //{NoDDClr}
+    (-f0.1) mov (1)	gMSGSRC.2:ud	0x000c000c:ud							//{NoDDChk}
+    (f0.1) add (1)	gMSGSRC.0<1>:d	gMVX_INT<0;1,0>:w				-0x02:d //{NoDDClr}
+	(f0.1) mov (1)	gMSGSRC.1<1>:d	gMVY_INT<0;1,0>:w						//{NoDDChk,NoDDClr}
+    (f0.1) mov (1)	gMSGSRC.2:ud	0x0007000c:ud							//{NoDDChk}
+
+    // Read 16x13 pixels
+    send (8)	gudREF(0)<1>		mMSGHDRY						gMSGSRC<8;8,1>:ud	DAPREAD	pMSGDSC:ud
+    
+    jmpi INTERLABEL(EXIT_LOADREF_Y_16x13)
+    
+INTERLABEL(LOADREF_MVXZERO):
+    
+    // Set message descriptor
+#ifdef DEV_ILK
+    (f0.1) add (1)	pMSGDSC:ud		gMSGDSC_R:ud					0x00200000:ud	
+	(-f0.1) add (1)	pMSGDSC:ud		gMSGDSC_R:ud					0x00400000:ud
+#else
+    (f0.1) add (1)	pMSGDSC:ud		gMSGDSC_R:ud					0x00020000:ud	
+	(-f0.1) add (1)	pMSGDSC:ud		gMSGDSC_R:ud					0x00040000:ud
+#endif
+	
+	// Compute top-left corner position to be loaded
+	// TODO: sel
+	mov (2)	gMSGSRC.0<1>:d	gMVX_INT<2;2,1>:w
+    (-f0.1) add (1)	gMSGSRC.1<1>:d	gMVY_INT<0;1,0>:w				-0x02:d
+    (-f0.1) mov (1)	gMSGSRC.2:ud	0x000c0007:ud							//{NoDDChk}
+    (f0.1) mov (1)	gMSGSRC.2:ud	0x00070007:ud							//{NoDDChk}
+
+    // Read 16x13 pixels
+    send (8)	gudREF(0)<1>		mMSGHDRY						gMSGSRC<8;8,1>:ud	DAPREAD	pMSGDSC:ud
+    
+
+#else
+	// Compute integer and fractional components of MV
+    and (2)		gMVX_FRAC<1>:w		r[pMV,0]<2;2,1>:w				0x03:w	//{NoDDClr}
+    asr (2)		gMVX_INT<1>:w		r[pMV,0]<2;2,1>:w				0x02:w	//{NoDDChk}
+    
+    // Check whether MVY is integer
+	or.z.f0.1 (8) null:w			gMVY_FRAC<0;1,0>:w				0:w
+	
+    // Set message descriptor
+#ifdef DEV_ILK
+    (f0.1) add (1)	pMSGDSC:ud		gMSGDSC_R:ud					0x00400000:ud	
+	(-f0.1) add (1)	pMSGDSC:ud		gMSGDSC_R:ud					0x00700000:ud
+#else
+    (f0.1) add (1)	pMSGDSC:ud		gMSGDSC_R:ud					0x00040000:ud	
+	(-f0.1) add (1)	pMSGDSC:ud		gMSGDSC_R:ud					0x00070000:ud
+#endif
+	
+	// Compute top-left corner position to be loaded
+	// TODO: sel
+    (-f0.1) add (2)	gMSGSRC.0<1>:d	gMVX_INT<2;2,1>:w				-0x02:d //{NoDDClr}
+    (-f0.1) mov (1)	gMSGSRC.2:ud	0x000c000c:ud							//{NoDDChk}
+    (f0.1) add (1)	gMSGSRC.0<1>:d	gMVX_INT<0;1,0>:w				-0x02:d //{NoDDClr}
+	(f0.1) mov (1)	gMSGSRC.1<1>:d	gMVY_INT<0;1,0>:w						//{NoDDChk,NoDDClr}
+    (f0.1) mov (1)	gMSGSRC.2:ud	0x0007000c:ud							//{NoDDChk}
+
+    // Read 16x13 pixels
+    send (8)	gudREF(0)<1>		mMSGHDRY						gMSGSRC<8;8,1>:ud	DAPREAD	pMSGDSC:ud
+#endif
+    
+#else   
+
+	// Compute integer and fractional components of MV
+    and (2)		gMVX_FRAC<1>:w		r[pMV,0]<2;2,1>:w				0x03:w	{NoDDClr} //
+    asr (2)		gMVX_INT<1>:w		r[pMV,0]<2;2,1>:w				0x02:w	{NoDDChk} //
+    
+    // Set message descriptor
+#ifdef DEV_ILK
+    add (1)		pMSGDSC:ud			gMSGDSC_R:ud					0x00700000:ud
+#else
+    add (1)		pMSGDSC:ud			gMSGDSC_R:ud					0x00070000:ud
+#endif	// DEV_ILK
+    
+	// Compute top-left corner position to be loaded
+    add (2)		gMSGSRC.0<1>:d		gMVX_INT<2;2,1>:w				-0x02:d {NoDDClr} //
+    mov (1)		gMSGSRC.2:ud		0x000c000c:ud							{NoDDChk} //
+
+    // Read 16x13 pixels
+    send (8)	gudREF(0)<1>	    mMSGHDRY						gMSGSRC<8;8,1>:ud	DAPREAD	pMSGDSC:ud
+    
+#endif
+
+INTERLABEL(EXIT_LOADREF_Y_16x13):
+
+//#endif	// !defined(__LOADREF_Y_16x13__)
diff --git a/i965_drv_video/shaders/h264/mc/loadRef_Y_16x9.asm b/i965_drv_video/shaders/h264/mc/loadRef_Y_16x9.asm
new file mode 100644
index 0000000..e48151e
--- /dev/null
+++ b/i965_drv_video/shaders/h264/mc/loadRef_Y_16x9.asm
@@ -0,0 +1,61 @@
+/*
+ * Load reference 16x9 area for luma 4x4 MC
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+// Kernel name: LoadRef_Y_16x9.asm
+//
+// Load reference 16x9 area for luma 4x4 MC
+
+
+//#if !defined(__LOADREF_Y_16x9__)		// Make sure this is only included once
+//#define __LOADREF_Y_16x9__
+
+#if 1
+
+	// Compute integer and fractional components of MV
+    and (2)		gMVX_FRAC<1>:w		r[pMV,0]<2;2,1>:w				0x03:w	//{NoDDClr}
+    asr (2)		gMVX_INT<1>:w		r[pMV,0]<2;2,1>:w				0x02:w	//{NoDDChk}
+ 
+    // Check whether MVY is integer
+	or.z.f0.1 (8) null:w			gMVY_FRAC<0;1,0>:w				0:w
+	   
+	// Set message descriptor
+	(f0.1) add (1)	pMSGDSC:ud		gMSGDSC_R:ud					RESP_LEN(2):ud
+	(-f0.1) add (1)	pMSGDSC:ud		gMSGDSC_R:ud					RESP_LEN(5):ud
+
+	// Compute top-left corner position to be loaded
+	// TODO: sel
+    (-f0.1) add (2)	gMSGSRC.0<1>:d	gMVX_INT<2;2,1>:w				-0x02:d	//{NoDDClr}
+    (-f0.1) mov (1)	gMSGSRC.2:ud	0x00080008:ud							//{NoDDChk}
+    (f0.1) add (1)	gMSGSRC.0<1>:d	gMVX_INT<0;1,0>:w				-0x02:d //{NoDDClr}
+	(f0.1) mov (1)	gMSGSRC.1<1>:d	gMVY_INT<0;1,0>:w						//{NoDDChk,NoDDClr}
+    (f0.1) mov (1)	gMSGSRC.2:ud	0x00030008:ud							//{NoDDChk}
+
+    // Read 16x9 pixels
+    send (8)	gudREF(0)<1>	    mMSGHDRY						gMSGSRC<8;8,1>:ud	DAPREAD pMSGDSC:ud
+
+#else
+
+	// Compute integer and fractional components of MV
+    and (2)		gMVX_FRAC<1>:w		r[pMV,0]<2;2,1>:w				0x03:w {NoDDClr} //
+    asr (2)		gMVX_INT<1>:w		r[pMV,0]<2;2,1>:w				0x02:w {NoDDChk} //
+
+	// Set message descriptor
+	add (1)		pMSGDSC:ud			gMSGDSC_R:ud					RESP_LEN(5):ud
+    
+	// Compute top-left corner position to be loaded 
+    add (2)		gMSGSRC.0<1>:d		gMVX_INT<2;2,1>:w				-0x02:d	{NoDDClr} //
+    mov (1)		gMSGSRC.2:ud		0x00080008:ud							{NoDDChk} //
+
+    // Read 16x9 pixels
+    send (8)	gudREF(0)<1>	    mMSGHDRY						gMSGSRC<8;8,1>:ud	DAPREAD	pMSGDSC:ud
+
+#endif
+
+        
+//#endif	// !defined(__LOADREF_Y_16x9__)
diff --git a/i965_drv_video/shaders/h264/mc/load_Intra_Ref_UV.asm b/i965_drv_video/shaders/h264/mc/load_Intra_Ref_UV.asm
new file mode 100644
index 0000000..34adbe6
--- /dev/null
+++ b/i965_drv_video/shaders/h264/mc/load_Intra_Ref_UV.asm
@@ -0,0 +1,44 @@
+/*
+ * Load all reference U/V samples from neighboring macroblocks
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+#if !defined(__LOAD_INTRA_REF_UV__)		// Make sure this is only included once
+#define __LOAD_INTRA_REF_UV__
+
+// Module name: load_Intra_Ref_UV.asm
+//
+// Load all reference U/V samples from neighboring macroblocks
+//
+// Note: Since loading of U/V data always follows writing of Y, the message descriptor is manipulated
+// to avoid recalculating due to frame/field variztions.
+
+// First load top 20x1 row U/V reference samples
+// 4 from macroblock D (actually use 2), 16 from macroblock B
+//
+    shr	(1)	I_ORIY<1>:w		I_ORIY<0;1,0>:w	1:w		// Adjust I_ORIY for NV12 format
+    add	(2)	MSGSRC.0<1>:d	I_ORIX<2;2,1>:w	TOP_REF_OFFSET<2;2,1>:b	{NoDDClr}	// Reference samples positioned at (-4, -1)
+    mov (1)	MSGSRC.2:ud		0x00000013:ud {NoDDChk}			// Block width and height (20x1)
+
+//  Update message descriptor based on previous Y block write
+//
+#ifdef DEV_ILK
+    add (1)	MSGDSC	MSGDSC	RESP_LEN(1)+DWBRMSGDSC_RC+DESTUV-DWBWMSGDSC_WC-0x10000000-DESTY:ud  // Set message descriptor
+#else
+    add (1)	MSGDSC	MSGDSC	RESP_LEN(1)+DWBRMSGDSC_RC+DESTUV-DWBWMSGDSC_WC-0x00800000-DESTY:ud  // Set message descriptor
+#endif	// DEV_ILK
+
+    send (8)	INTRA_REF_TOP_D(0)	MSGHDR	MSGSRC<8;8,1>:ud	DAPREAD	MSGDSC
+
+// Then load left 4x8 reference samples (actually use 1x8 column)
+//
+    add	(1)	MSGSRC.1<1>:d	MSGSRC.1<0;1,0>:d	1:w {NoDDClr}	// Reference samples positioned next row
+    mov (1)	MSGSRC.2:ud		0x00070003:ud {NoDDChk}			// Block width and height (4x8)
+    send (8)	INTRA_REF_LEFT_D(0)	MSGHDRUV	MSGSRC<8;8,1>:ud	DAPREAD	MSGDSC
+
+// End of load_Intra_Ref_UV
+#endif	// !defined(__LOAD_INTRA_REF_UV__)
diff --git a/i965_drv_video/shaders/h264/mc/load_Intra_Ref_Y.asm b/i965_drv_video/shaders/h264/mc/load_Intra_Ref_Y.asm
new file mode 100644
index 0000000..de8ec49
--- /dev/null
+++ b/i965_drv_video/shaders/h264/mc/load_Intra_Ref_Y.asm
@@ -0,0 +1,37 @@
+/*
+ * Load all reference Y samples from neighboring macroblocks
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+#if !defined(__LOAD_INTRA_REF_Y__)		// Make sure this is only included once
+#define __LOAD_INTRA_REF_Y__
+
+// Module name: load_Intra_Ref_Y.asm
+//
+// Load all reference Y samples from neighboring macroblocks
+//
+load_Intra_Ref_Y:
+//	shl (2) I_ORIX<1>:uw	ORIX<2;2,1>:ub	4:w		// Convert MB origin to pixel unit
+
+// First load top 28x1 row reference samples
+// 4 from macroblock D (actually use 1), 16 from macroblock B, and 8 from macroblock C
+//
+    add	(2)	MSGSRC.0<1>:d	I_ORIX<2;2,1>:w	TOP_REF_OFFSET<2;2,1>:b	{NoDDClr}	// Reference samples positioned at (-4, -1)
+    mov (1)	MSGSRC.2:ud		0x0000001B:ud {NoDDChk}								// Block width and height (28x1)
+    add (1)	MSGDSC	REG_MBAFF_FIELD<0;1,0>:uw	RESP_LEN(1)+DWBRMSGDSC_RC+DESTY:ud  // Set message descriptor
+    send (8)	INTRA_REF_TOP_D(0)	MSGHDRY0	MSGSRC<8;8,1>:ud	DAPREAD	MSGDSC
+
+// Then load left 4x16 reference samples (actually use 1x16 column)
+//
+    add	(1)	MSGSRC.1<1>:d	MSGSRC.1<0;1,0>:d	1:w {NoDDClr}	// Reference samples positioned next row
+    mov (1)	MSGSRC.2:ud		0x00F0003:ud	{NoDDChk}			// Block width and height (4x16)
+    add (1)	MSGDSC			MSGDSC	RESP_LEN(1):ud	// Need to read 1 more GRF register
+    send (8)	INTRA_REF_LEFT_D(0)	MSGHDRY1	MSGSRC<8;8,1>:ud	DAPREAD	MSGDSC
+
+	RETURN
+// End of load_Intra_Ref_Y
+#endif	// !defined(__LOAD_INTRA_REF_Y__)
diff --git a/i965_drv_video/shaders/h264/mc/null.g4a b/i965_drv_video/shaders/h264/mc/null.g4a
new file mode 100644
index 0000000..f138029
--- /dev/null
+++ b/i965_drv_video/shaders/h264/mc/null.g4a
@@ -0,0 +1,43 @@
+/*
+ * Copyright © 2009 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *
+ * Author:
+ *    Zou Nan hai <nanhai.zou@intel.com>
+ *    Xiang Haihao <haihao.xiang@intel.com>
+ *
+ */
+define(`YUV_color',`0xFFFFFFFFUD')
+shl(2) g62.0<1>UD g3.4<2,2,1>UB 4UW {align1};
+mov(1) g62.8<1>UD 0x000f000fUD {align1};
+mov(16) m1<1>UD YUV_color {align1 compr};
+mov(16) m3<1>UD YUV_color {align1 compr};
+mov(16) m5<1>UD YUV_color {align1 compr};
+mov(16) m7<1>UD YUV_color {align1 compr};
+send(16) 0 acc0<1>UW g62<8,8,1>UW write(0, 0, 2, 0) mlen 9 rlen 0 {align1};
+
+shr(1) g62.4<1>UD g62.4<1,1,1>UD 1UW {align1};
+mov(1) g62.8<1>UD 0x0007000fUD {align1};
+mov(16) m1<1>UD YUV_color {align1 compr};
+mov(16) m3<1>UD YUV_color {align1 compr};
+send(16) 0 acc0<1>UW g62<8,8,1>UW write(1, 0, 2, 0) mlen 5 rlen 0 {align1};
+
+send(16) 0 acc0<1>UW g0<8,8,1>UW thread_spawner(0, 0, 0) mlen 1 rlen 0 {align1 EOT};
diff --git a/i965_drv_video/shaders/h264/mc/null.g4b b/i965_drv_video/shaders/h264/mc/null.g4b
new file mode 100644
index 0000000..fdd18e6
--- /dev/null
+++ b/i965_drv_video/shaders/h264/mc/null.g4b
@@ -0,0 +1,13 @@
+   { 0x00200009, 0x27c02e21, 0x00450064, 0x00040004 },
+   { 0x00000001, 0x27c80061, 0x00000000, 0x000f000f },
+   { 0x00802001, 0x20200062, 0x00000000, 0xffffffff },
+   { 0x00802001, 0x20600062, 0x00000000, 0xffffffff },
+   { 0x00802001, 0x20a00062, 0x00000000, 0xffffffff },
+   { 0x00802001, 0x20e00062, 0x00000000, 0xffffffff },
+   { 0x00800031, 0x24001d28, 0x008d07c0, 0x05902000 },
+   { 0x00000008, 0x27c42c21, 0x002107c4, 0x00010001 },
+   { 0x00000001, 0x27c80061, 0x00000000, 0x0007000f },
+   { 0x00802001, 0x20200062, 0x00000000, 0xffffffff },
+   { 0x00802001, 0x20600062, 0x00000000, 0xffffffff },
+   { 0x00800031, 0x24001d28, 0x008d07c0, 0x05502001 },
+   { 0x00800031, 0x24001d28, 0x008d0000, 0x87100000 },
diff --git a/i965_drv_video/shaders/h264/mc/null.g4b.gen5 b/i965_drv_video/shaders/h264/mc/null.g4b.gen5
new file mode 100644
index 0000000..7ecb90d
--- /dev/null
+++ b/i965_drv_video/shaders/h264/mc/null.g4b.gen5
@@ -0,0 +1,13 @@
+   { 0x00200009, 0x27c02e21, 0x00450064, 0x00040004 },
+   { 0x00000001, 0x27c80061, 0x00000000, 0x000f000f },
+   { 0x00802001, 0x20200062, 0x00000000, 0xffffffff },
+   { 0x00802001, 0x20600062, 0x00000000, 0xffffffff },
+   { 0x00802001, 0x20a00062, 0x00000000, 0xffffffff },
+   { 0x00802001, 0x20e00062, 0x00000000, 0xffffffff },
+   { 0x00800031, 0x24001d28, 0x508d07c0, 0x12082000 },
+   { 0x00000008, 0x27c42c21, 0x002107c4, 0x00010001 },
+   { 0x00000001, 0x27c80061, 0x00000000, 0x0007000f },
+   { 0x00802001, 0x20200062, 0x00000000, 0xffffffff },
+   { 0x00802001, 0x20600062, 0x00000000, 0xffffffff },
+   { 0x00800031, 0x24001d28, 0x508d07c0, 0x0a082001 },
+   { 0x00800031, 0x24001d28, 0x748d0000, 0x82000000 },
diff --git a/i965_drv_video/shaders/h264/mc/recon_C_4x4.asm b/i965_drv_video/shaders/h264/mc/recon_C_4x4.asm
new file mode 100644
index 0000000..3a2a921
--- /dev/null
+++ b/i965_drv_video/shaders/h264/mc/recon_C_4x4.asm
@@ -0,0 +1,37 @@
+/*
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+// Kernel name: Recon_C_4x4.asm
+//
+//  $Revision: 11 $
+//  $Date: 10/03/06 5:28p $
+//
+
+
+//#if !defined(__RECON_C_4x4__)		// Make sure this is only included once
+//#define __RECON_C_4x4__
+
+
+	// TODO: Use instruction compression
+	add.sat (4) r[pERRORC,0]<2>:ub			r[pERRORC,0]<4;4,1>:w			gubCPRED(0)<16;4,4>
+	add.sat (4) r[pERRORC,128]<2>:ub		r[pERRORC,128]<4;4,1>:w			gubCPRED(0,2)<16;4,4>
+	add.sat (4) r[pERRORC,32]<2>:ub			r[pERRORC,32]<4;4,1>:w			gubCPRED(1)<16;4,4>
+	add.sat (4) r[pERRORC,128+32]<2>:ub		r[pERRORC,128+32]<4;4,1>:w		gubCPRED(1,2)<16;4,4>
+	
+	add.sat (4) r[pERRORC,16]<2>:ub			r[pERRORC,16]<4;4,1>:w			gubCPRED(0,16)<16;4,4>
+	add.sat (4) r[pERRORC,128+16]<2>:ub		r[pERRORC,128+16]<4;4,1>:w		gubCPRED(0,18)<16;4,4>
+	add.sat (4) r[pERRORC,48]<2>:ub			r[pERRORC,48]<4;4,1>:w			gubCPRED(1,16)<16;4,4>
+	add.sat (4) r[pERRORC,128+48]<2>:ub		r[pERRORC,128+48]<4;4,1>:w		gubCPRED(1,18)<16;4,4>
+
+	// Increase chroma error block offset	
+#ifndef MONO
+	add (1)		pERRORC:w			pERRORC:w						8:w
+#endif
+
+        
+//#endif	// !defined(__RECON_C_4x4__)
diff --git a/i965_drv_video/shaders/h264/mc/recon_Y_8x8.asm b/i965_drv_video/shaders/h264/mc/recon_Y_8x8.asm
new file mode 100644
index 0000000..6017790
--- /dev/null
+++ b/i965_drv_video/shaders/h264/mc/recon_Y_8x8.asm
@@ -0,0 +1,27 @@
+/*
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+// Kernel name: Recon_Y_8x8.asm
+//
+//  $Revision: 10 $
+//  $Date: 9/22/06 2:50p $
+//
+
+
+//#if !defined(__RECON_Y_8x8__)		// Make sure this is only included once
+//#define __RECON_Y_8x8__
+
+
+	add.sat (16)		r[pERRORY,0]<2>:ub			r[pERRORY,0]<16;16,1>:w				gubYPRED(0)
+	add.sat (16)		r[pERRORY,nGRFWIB]<2>:ub	r[pERRORY,nGRFWIB]<16;16,1>:w		gubYPRED(1)
+	add.sat (16)		r[pERRORY,nGRFWIB*2]<2>:ub	r[pERRORY,nGRFWIB*2]<16;16,1>:w		gubYPRED(2)
+	add.sat (16)		r[pERRORY,nGRFWIB*3]<2>:ub	r[pERRORY,nGRFWIB*3]<16;16,1>:w		gubYPRED(3)
+	
+	add (1)				pERRORY:w					pERRORY:w							128:w
+
+//#endif	// !defined(__RECON_Y_8x8__)
diff --git a/i965_drv_video/shaders/h264/mc/roundShift_C_4x4.asm b/i965_drv_video/shaders/h264/mc/roundShift_C_4x4.asm
new file mode 100644
index 0000000..c609159
--- /dev/null
+++ b/i965_drv_video/shaders/h264/mc/roundShift_C_4x4.asm
@@ -0,0 +1,26 @@
+/*
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+//	Kernel name: RoundShift_C_4x4.asm
+//
+//	Do (...+32)>>6 to 4x4 (NV12 8x4) interpolated chrominance data
+//
+
+
+//#if !defined(__RoundShift_C_4x4__)		// Make sure this is only included once
+//#define __RoundShift_C_4x4__
+
+
+	// TODO: Optimize using instruction compression
+	add (16)	acc0<1>:w					r[pRESULT,0]<16;16,1>:w			32:w
+	add (16)	acc1<1>:w					r[pRESULT,nGRFWIB]<16;16,1>:w	32:w
+	asr.sat (16) r[pRESULT,0]<2>:ub			acc0<16;16,1>:w					6:w
+	asr.sat (16) r[pRESULT,nGRFWIB]<2>:ub	acc1<16;16,1>:w					6:w
+	
+
+//#endif	// !defined(__RoundShift_C_4x4__)
diff --git a/i965_drv_video/shaders/h264/mc/save_16x16_Y.asm b/i965_drv_video/shaders/h264/mc/save_16x16_Y.asm
new file mode 100644
index 0000000..713e12c
--- /dev/null
+++ b/i965_drv_video/shaders/h264/mc/save_16x16_Y.asm
@@ -0,0 +1,42 @@
+/*
+ * Save decoded Y picture data to frame buffer
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+#if !defined(__SAVE_16X16_Y__)		// Make sure this is only included once
+#define __SAVE_16X16_Y__
+
+// Module name: save_16x16_Y.asm
+//
+// Save decoded Y picture data to frame buffer
+//
+
+save_16x16_Y:
+
+    mov (1) MSGSRC.2:ud		0x000F000F:ud {NoDDClr}		// Block width and height (16x16)
+    mov (2) MSGSRC.0:ud		I_ORIX<2;2,1>:w {NoDDChk}	// X, Y offset
+#ifdef DEV_ILK
+    add (1)		MSGDSC	MSGDSC MSG_LEN(8)+DWBWMSGDSC_WC-DWBRMSGDSC_RC-0x00200000:ud  // Set message descriptor
+#else
+    add (1)		MSGDSC	MSGDSC MSG_LEN(8)+DWBWMSGDSC_WC-DWBRMSGDSC_RC-0x00020000:ud  // Set message descriptor
+#endif	// DEV_ILK
+
+    mov (1) PDECBUF_UD<1>:ud	0x10001*DECBUF*GRFWIB+0x00400000:ud	// Pointers to row 0 and 2 of decoded data
+
+    $for(0,0; <8; 2,4) {
+	mov (32)	MSGPAYLOAD(%1)<1>	r[PDECBUF, %2*GRFWIB]REGION(16,2) {Compr}		// Block Y0/Y2
+	mov (32)	MSGPAYLOAD(%1,16)<1>	r[PDECBUF, (1+%2)*GRFWIB]REGION(16,2) {Compr}	// Block Y1/Y3
+    }
+
+//  Update message descriptor based on previous read setup
+//
+    send (8)	REG_WRITE_COMMIT_Y<1>:ud	MSGHDR	MSGSRC<8;8,1>:ud	DAPWRITE	MSGDSC
+
+    RETURN
+// End of save_16x16_Y
+
+#endif	// !defined(__SAVE_16X16_Y__)
diff --git a/i965_drv_video/shaders/h264/mc/save_4x4_Y.asm b/i965_drv_video/shaders/h264/mc/save_4x4_Y.asm
new file mode 100644
index 0000000..415034a
--- /dev/null
+++ b/i965_drv_video/shaders/h264/mc/save_4x4_Y.asm
@@ -0,0 +1,43 @@
+/*
+ * Save Intra_4x4 decoded Y picture data to frame buffer
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+#if !defined(__SAVE_4X4_Y__)		// Make sure this is only included once
+#define __SAVE_4X4_Y__
+
+// Module name: save_4x4_Y.asm
+//
+// Save Intra_4x4 decoded Y picture data to frame buffer
+// Note: Each 4x4 block is stored in 1 GRF register in the order of block raster scan order,
+// i.e. 0, 1, 4, 5, 2, 3, 6, 7, 8, 9, 12, 13, 10, 11, 14, 15
+
+save_4x4_Y:
+
+    mov (1) MSGSRC.2:ud		0x000F000F:ud {NoDDClr}		// Block width and height (16x16)
+    mov (2) MSGSRC.0:ud		I_ORIX<2;2,1>:w {NoDDChk}	// X, Y offset
+#ifdef DEV_ILK
+    add (1)		MSGDSC	MSGDSC MSG_LEN(8)+DWBWMSGDSC_WC-DWBRMSGDSC_RC-0x00200000:ud  // Set message descriptor
+#else
+    add (1)		MSGDSC	MSGDSC MSG_LEN(8)+DWBWMSGDSC_WC-DWBRMSGDSC_RC-0x00020000:ud  // Set message descriptor
+#endif	// DEV_ILK
+
+    $for(0; <8; 2) {
+	mov (16)	MSGPAYLOAD(%1)<1>		DEC_Y(%1)<16;4,1>
+	mov (16)	MSGPAYLOAD(%1,16)<1>	DEC_Y(%1,4)<16;4,1>
+	mov (16)	MSGPAYLOAD(%1+1)<1>		DEC_Y(%1,8)<16;4,1>
+	mov (16)	MSGPAYLOAD(%1+1,16)<1>	DEC_Y(%1,12)<16;4,1>
+    }
+
+//  Update message descriptor based on previous read setup
+//
+    send (8)	REG_WRITE_COMMIT_Y<1>:ud	MSGHDR	MSGSRC<8;8,1>:ud	DAPWRITE	MSGDSC
+
+    RETURN
+// End of save_4x4_Y
+
+#endif	// !defined(__SAVE_4X4_Y__)
diff --git a/i965_drv_video/shaders/h264/mc/save_8x8_UV.asm b/i965_drv_video/shaders/h264/mc/save_8x8_UV.asm
new file mode 100644
index 0000000..aa76af9
--- /dev/null
+++ b/i965_drv_video/shaders/h264/mc/save_8x8_UV.asm
@@ -0,0 +1,51 @@
+/*
+ * Save decoded U/V picture data to frame buffer
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+#if !defined(__SAVE_8x8_UV__)		// Make sure this is only included once
+#define __SAVE_8x8_UV__
+
+// Module name: save_8x8_UV.asm
+//
+// Save decoded U/V picture data to frame buffer
+//
+
+    mov (1) MSGSRC.2:ud	    0x0007000F:ud {NoDDClr}		// Block width and height (16x8)
+    mov (2) MSGSRC.0<1>:ud  I_ORIX<2;2,1>:w	{NoDDChk}	// I_ORIX has already been adjusted for NV12
+
+//  Update message descriptor based on previous read setup
+//
+#ifdef DEV_ILK
+    add (1)		MSGDSC	MSGDSC MSG_LEN(4)+DWBWMSGDSC_WC-DWBRMSGDSC_RC-0x00100000:ud  // Set message descriptor
+#else
+    add (1)		MSGDSC	MSGDSC MSG_LEN(4)+DWBWMSGDSC_WC-DWBRMSGDSC_RC-0x00010000:ud  // Set message descriptor
+#endif	// DEV_ILK
+
+// Write U/V picture data
+//
+#ifndef MONO
+    mov	    MSGPAYLOAD(0,0)<1>	DEC_UV(0)REGION(16,2)	// U/V row 0
+    mov	    MSGPAYLOAD(0,16)<1>	DEC_UV(1)REGION(16,2)	// U/V row 1
+    mov	    MSGPAYLOAD(1,0)<1>	DEC_UV(2)REGION(16,2)	// U/V row 2
+    mov	    MSGPAYLOAD(1,16)<1>	DEC_UV(3)REGION(16,2)	// U/V row 3
+    mov	    MSGPAYLOAD(2,0)<1>	DEC_UV(4)REGION(16,2)	// U/V row 4
+    mov	    MSGPAYLOAD(2,16)<1>	DEC_UV(5)REGION(16,2)	// U/V row 5
+    mov	    MSGPAYLOAD(3,0)<1>	DEC_UV(6)REGION(16,2)	// U/V row 6
+    mov	    MSGPAYLOAD(3,16)<1>	DEC_UV(7)REGION(16,2)	// U/V row 7
+#else	// defined(MONO)
+    $for(0; <4; 2) {
+	mov (16)	MSGPAYLOADD(%1)<1>		0x80808080:ud {Compr}
+	}
+
+#endif	// !defined(MONO)
+
+	send (8)	REG_WRITE_COMMIT_UV<1>:ud	MSGHDR	MSGSRC<8;8,1>:ud	DAPWRITE	MSGDSC
+
+// End of save_8x8_UV
+
+#endif	// !defined(__SAVE_8x8_UV__)
diff --git a/i965_drv_video/shaders/h264/mc/save_8x8_Y.asm b/i965_drv_video/shaders/h264/mc/save_8x8_Y.asm
new file mode 100644
index 0000000..3ffca79
--- /dev/null
+++ b/i965_drv_video/shaders/h264/mc/save_8x8_Y.asm
@@ -0,0 +1,56 @@
+/*
+ * Save Intra_8x8 decoded Y picture data to frame buffer
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+#if !defined(__SAVE_8X8_Y__)		// Make sure this is only included once
+#define __SAVE_8X8_Y__
+
+// Module name: save_8x8_Y.asm
+//
+// Save Intra_8x8 decoded Y picture data to frame buffer
+// NotE: Every 4 rows of Y data are interleaved with the horizontal neighboring blcok
+//
+save_8x8_Y:
+
+    mov (1) MSGSRC.2:ud		0x000F000F:ud {NoDDClr}		// Block width and height (16x16)
+    mov (2) MSGSRC.0:ud		I_ORIX<2;2,1>:w {NoDDChk}	// X, Y offset
+
+//  Update message descriptor based on previous read setup
+//
+#ifdef DEV_ILK
+    add (1)		MSGDSC	MSGDSC MSG_LEN(8)+DWBWMSGDSC_WC-DWBRMSGDSC_RC-0x00200000:ud  // Set message descriptor
+#else
+    add (1)		MSGDSC	MSGDSC MSG_LEN(8)+DWBWMSGDSC_WC-DWBRMSGDSC_RC-0x00020000:ud  // Set message descriptor
+#endif	// DEV_ILK
+
+	mov (16)	MSGPAYLOAD(0)<1>	DEC_Y(0)<32;8,1>
+	mov (16)	MSGPAYLOAD(0,16)<1>	DEC_Y(0,8)<32;8,1>
+	mov (16)	MSGPAYLOAD(1,0)<1>	DEC_Y(0,16)<32;8,1>
+	mov (16)	MSGPAYLOAD(1,16)<1>	DEC_Y(0,24)<32;8,1>
+
+	mov (16)	MSGPAYLOAD(2)<1>	DEC_Y(2)<32;8,1>
+	mov (16)	MSGPAYLOAD(2,16)<1>	DEC_Y(2,8)<32;8,1>
+	mov (16)	MSGPAYLOAD(3,0)<1>	DEC_Y(2,16)<32;8,1>
+	mov (16)	MSGPAYLOAD(3,16)<1>	DEC_Y(2,24)<32;8,1>
+
+	mov (16)	MSGPAYLOAD(4)<1>	DEC_Y(4)<32;8,1>
+	mov (16)	MSGPAYLOAD(4,16)<1>	DEC_Y(4,8)<32;8,1>
+	mov (16)	MSGPAYLOAD(5,0)<1>	DEC_Y(4,16)<32;8,1>
+	mov (16)	MSGPAYLOAD(5,16)<1>	DEC_Y(4,24)<32;8,1>
+
+	mov (16)	MSGPAYLOAD(6)<1>	DEC_Y(6)<32;8,1>
+	mov (16)	MSGPAYLOAD(6,16)<1>	DEC_Y(6,8)<32;8,1>
+	mov (16)	MSGPAYLOAD(7,0)<1>	DEC_Y(6,16)<32;8,1>
+	mov (16)	MSGPAYLOAD(7,16)<1>	DEC_Y(6,24)<32;8,1>
+
+    send (8)	REG_WRITE_COMMIT_Y<1>:ud	MSGHDR	MSGSRC<8;8,1>:ud	DAPWRITE	MSGDSC
+
+    RETURN
+// End of save_8x8_Y
+
+#endif	// !defined(__SAVE_8X8_Y__)
diff --git a/i965_drv_video/shaders/h264/mc/save_I_PCM.asm b/i965_drv_video/shaders/h264/mc/save_I_PCM.asm
new file mode 100644
index 0000000..77be35e
--- /dev/null
+++ b/i965_drv_video/shaders/h264/mc/save_I_PCM.asm
@@ -0,0 +1,56 @@
+/*
+ * Save I_PCM Y samples to Y picture buffer
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+// Module name: save_I_PCM.asm
+//
+// First save I_PCM Y samples to Y picture buffer
+//
+    mov (1) MSGSRC.2:ud		0x000F000F:ud {NoDDClr}			// Block width and height (16x16)
+	shl (2) MSGSRC.0:ud		ORIX<2;2,1>:ub	4:w	{NoDDChk}	// Convert MB origin in pixel unit
+
+    add (1)	MSGDSC	REG_MBAFF_FIELD<0;1,0>:uw	MSG_LEN(8)+DWBWMSGDSC_WC+DESTY:ud  // Set message descriptor
+
+    $for(0; <8; 2) {
+	mov (32)	MSGPAYLOAD(%1)<1>		I_PCM_Y(%1)REGION(16,1) {Compr,NoDDClr}
+	mov (32)	MSGPAYLOAD(%1,16)<1>	I_PCM_Y(%1,16)REGION(16,1) {Compr,NoDDChk}
+    }
+
+    send (8)	REG_WRITE_COMMIT_Y<1>:ud	MSGHDR	MSGSRC<8;8,1>:ud	DAPWRITE	MSGDSC
+
+// Then save I_PCM U/V samples to U/V picture buffer
+//
+    mov (1) MSGHDR.2:ud		0x0007000F:ud			{NoDDClr}	// Block width and height (16x8)
+    asr (1) MSGHDR.1:ud		MSGSRC.1<0;1,0>:ud	1:w {NoDDChk}	// Y offset should be halved
+    add (1)	MSGDSC			MSGDSC			0x0-MSG_LEN(4)+0x1:d	// Set message descriptor for U/V
+
+#if 0
+    and.z.f0.0 (1)  NULLREG REG_CHROMA_FORMAT_IDC  CHROMA_FORMAT_IDC:ud
+	(f0.0) jmpi (1) MONOCHROME_I_PCM
+#endif
+
+#ifndef MONO
+// Non-monochrome picture
+//
+    $for(0,0; <4; 2,1) {
+	mov (16)	MSGPAYLOAD(%1)<2>		I_PCM_UV(%2)REGION(16,1)		// U data
+	mov (16)	MSGPAYLOAD(%1,1)<2>		I_PCM_UV(%2+2)REGION(16,1)		// V data
+	mov (16)	MSGPAYLOAD(%1+1)<2>		I_PCM_UV(%2,16)REGION(16,1)		// U data
+	mov (16)	MSGPAYLOAD(%1+1,1)<2>	I_PCM_UV(%2+2,16)REGION(16,1)	// V data
+	}
+#else	// defined(MONO)
+MONOCHROME_I_PCM:
+    $for(0; <4; 2) {
+	mov (16)	MSGPAYLOADD(%1)<1>		0x80808080:ud {Compr}
+	}
+
+#endif	// !defined(MONO)
+
+    send (8)	REG_WRITE_COMMIT_UV<1>:ud	MSGHDR	null:ud	DAPWRITE	MSGDSC
+
+// End of save_I_PCM
diff --git a/i965_drv_video/shaders/h264/mc/scoreboard.asm b/i965_drv_video/shaders/h264/mc/scoreboard.asm
new file mode 100644
index 0000000..6fb41cf
--- /dev/null
+++ b/i965_drv_video/shaders/h264/mc/scoreboard.asm
@@ -0,0 +1,282 @@
+/*
+ * Dependency control scoreboard kernel
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+// Kernel name: scoreboard.asm
+//
+// Dependency control scoreboard kernel
+//
+//  $Revision: 16 $
+//  $Date: 10/18/06 4:10p $
+//
+
+// ----------------------------------------------------
+//  Main: scoreboard
+// ----------------------------------------------------
+// ----------------------------------------------------
+//  Scoreboard structure
+// ----------------------------------------------------
+//
+//	1 DWORD per thread
+//
+//	Bit 31:	"Checking" thread, i.e. an intra MB that sends "check dependency" message
+//	Bit 30: "Completed" thread. This bit set by an "update" message from intra/inter MB.
+//	Bits 29:28:	Must set to 0
+//	Bits 27:24:	EUID
+//	Bits 23:18: Reserved
+//	Bits 17:16: TID
+//	Bits 15:8:	X offset of current MB
+//	Bits 15:5:	Reserved
+//	Bits 4:0: 5 bits of available neighbor MB flags
+
+.kernel scoreboard
+SCOREBOARD:
+
+#ifdef _DEBUG
+// WA for FULSIM so we'll know which kernel is being debugged
+mov (1) acc0:ud 0xf0aa55a5:ud
+#endif
+
+#include "header.inc"
+#include "scoreboard_header.inc"
+
+//
+//  Now, begin source code....
+//
+
+.code
+
+#ifdef	AS_ENABLED
+	and.z.f0.1	(1)	NULLREG	r0.2<0;1,0>:ud	TH_RES	// Is this a restarted thread previously interrupted?
+	(f0.1) jmpi	(1)	Scoreboard_Init
+
+	#include "scoreboard_restore_AS.asm"
+
+	jmpi (1)	Scoreboard_OpenGW
+Scoreboard_Init:
+#endif	// End AS_ENABLED
+
+// Scoreboard must be initialized to 0xc000ffff, meaning all "completed"
+// And it also avoids message mis-handling for the first MB
+    $for(0; <32; 2) {
+	mov (16)	CMD_SB(%1)<1>	0xc000ffff:ud {Compr}
+	}
+#ifdef	DOUBLE_SB					// Scoreboard size needs to be doubled
+    $for(32; <64; 2) {
+	mov (16)	CMD_SB(%1)<1>	0xc000ffff:ud {Compr}
+	}
+#endif	// DOUBLE_SB
+
+//----------------------------------------------------------
+//	Open message gateway for the scoreboard thread
+//
+//	RegBase = r4 (0x04)
+//	Gateway Size = 64 GRF registers (0x6)
+//	Dispatch ID = r0.20:ub
+//	Scoreboard Thread Key = 0
+//----------------------------------------------------------
+Scoreboard_OpenGW:
+    mov (8)	MSGHDRY0<1>:ud	0x00000000:ud			// Initialize message header payload with 0
+
+	// Send a message with register base RegBase=0x04(r4) and Gateway size = 0x6 = 64 GRF reg and Key = 0
+	// 000 00000100 00000 00000 110 00000000 ==> 0000 0000 1000 0000 0000 0110 0000 0000
+#ifdef	AS_ENABLED
+	add (1) MSGHDRY0.5<1>:ud r0.20:ub	0x00800700:ud	// Allocate 128 GRFs for message gateway - for SIP to send notification MSG
+#else
+  #ifdef	DOUBLE_SB
+	add (1) MSGHDRY0.5<1>:ud r0.20:ub	0x00800600:ud	// 64 GRF's for CTG-B
+  #else
+	add (1) MSGHDRY0.5<1>:ud r0.20:ub	0x00800500:ud	// 32 GRF's for CTG-A
+  #endif	// DOUBLE_SB
+#endif
+	send (8)	NULLREG  MSGHDRY0	null:ud    MSG_GW	OGWMSGDSC
+
+//------------------------------------------------------------------------
+//	Send Thread Spawning Message to start dispatching macroblock threads
+//
+//------------------------------------------------------------------------
+#ifdef	AS_ENABLED
+	mov (8)	acc0<1>:ud	CMD_SB(31)<8;8,1>			// Ensure scoreboard data have been completely restored
+#endif	// End AS_ENABLED
+    mov (8)	MSGHDRY1<1>:ud		r0<8;8,1>:ud		// Initialize message header payload with R0
+    mov (1)	MSGHDRY1.4<1>:ud	0x00000400:ud		// Dispatch URB length = 1
+
+	send (8)	NULLREG  MSGHDRY1	null:ud    TS	TSMSGDSC
+
+    mov (8)	MSGHDRY0<1>:ud		0x00000000:ud		// Initialize message header payload with 0
+
+//------------------------------------------------------------------------
+//	Scoreboard control data initialization
+//------------------------------------------------------------------------
+#ifdef	AS_ENABLED
+	or	(1)	cr0.1:ud	cr0.1:ud	AS_INT_EN		// Enable interrupt
+	(f0.1) jmpi	(1)	Scoreboard_State_Init	// Jump if not restarted thread
+
+	// Restore scoreboard kernel control data to r1 - r3
+    mov (1)	m4.1:ud	64:ud				// Starting r1
+    mov (1)	m4.2:ud	0x0002001f:ud		// for 3 registers
+    send (8)	r1.0<1>:ud	m4	null:ud	DWBRMSGDSC_SC+0x00030000+AS_SAVE	// Restore r1 - r3
+	mov	(8)	a0.0<1>:uw	AR_SAVE<8;8,1>:uw				// Restore all address registers
+
+// Check whether all MBs have been decoded
+	cmp.e.f0.0 (1)	NULLREG	TotalMB<0;1,0>:w	0:w	// Set "Last MB" flag
+	(-f0.0) jmpi (1)	Before_First_MB
+    END_THREAD
+
+// Check whether it is before the first MB
+Before_First_MB:
+	cmp.e.f0.0 (1)	NULLREG	AVAILFLAGD<1>:ud	0x08020401:ud	// in ACBD order
+	(f0.0) jmpi (1)	Wavefront_Walk
+
+Scoreboard_State_Init:
+#endif	// End AS_ENABLED
+	mov (2) WFLen_B<2>:w		HEIGHTINMB_1<0;1,0>:w
+	mov (1)	AVAILFLAGD<1>:ud	0x08020401:ud	// in ACBD order
+	mov	(1) CASE00PTR<1>:ud	Notify_MSG_IP-No_Message_IP:ud		// Inter kernel starts
+	mov	(1) CASE10PTR<1>:ud	Dependency_Check_IP-No_Message_IP:ud	// Intra kernel starts
+#ifdef	AS_ENABLED
+	mov	(1) CASE11PTR<1>:ud	0:ud		// No message
+#else
+	mov	(1) CASE11PTR<1>:ud	MB_Loop_IP-No_Message_IP:ud		// No message
+#endif	// End AS_ENABLED
+	mov	(1) StartXD<1>:ud	0:ud
+	mov	(1) NewWFOffsetD<1>:ud	0x01ffff00:ud
+
+	mov (4) WFStart(0)<1>	0xffff:w
+	mov (1) WFStart(0)<1>	0:w
+
+	mov	(8)	a0.0<1>:uw	0x0:uw						// Initialize all pointers to 0
+
+//------------------------------------------------------------------------
+//	Scoreboard message handling loop
+//------------------------------------------------------------------------
+//
+Scoreboard_Loop:
+	// Calculate current wavefront length
+	add.ge.f0.1 (16)	acc0<1>:w	StartX<0;1,0>:w	0:w		// Used for x>2*y check
+	mac.g.f0.0 (16)	NULLREGW	WFLenY<0;1,0>:w	-2:w		// X - 2*Y > 0 ??
+	(f0.0) mov (1)	WFLen<1>:w	WFLenY<0;1,0>:w				// Use smaller vertical wavefront length
+	(-f0.0) asr.sat (1)	WFLen<1>:uw	StartX<0;1,0>:w	1:w		// Horizontal wavefront length is smaller
+
+	// Initialize 5-MB group
+#ifdef ONE_MB_WA
+	mov (2) MBINDEX(0)<1>		WFStart(0)<2;2,1>
+	(f0.1) add (4) MBINDEX(0,2)<1>		WFStart(0,1)<4;4,1>	-1:w
+	(-f0.1) add (4) MBINDEX(0,2)<1>		WFStart(0,0)<4;4,1>	-1:w
+	(-f0.1) mov (1) StartX<1>:w		0:w					// WA for 1-MB wide pictures
+#else
+	mov (2) MBINDEX(0)<1>		WFStart(0)<2;2,1>			{NoDDClr}
+	add (4) MBINDEX(0,2)<1>		WFStart(0,1)<4;4,1>	-1:w	{NoDDChk}
+#endif
+
+	// Update WFStart
+	mov (8)	acc0<1>:w	WFStart(0)<0;1,0>					// Move WFStart(0) to acc0 to remove dependency later
+	mov (4)	WFStart(0,1)<1>	WFStart(0)<4;4,1>	{NoDDClr}	// Shift WFStart(0:2) to WFStart(1:3)
+	add (1)	WFStart(0)<1>	acc0.0<0;1,0>:w		WFLen<0;1,0>:w	{NoDDChk}	// WFStart(0) = WFStart(0) + WFLen
+
+	mul (8)	MBINDEX(0)<1>	MBINDEX(0)<8;8,1>	4:w	// Adjust MB order # to be DWORD aligned
+	and (1)	DEPPTR<1>:uw	acc0<0;1,0>:w	SB_MASK*4:uw {NoDDClr}	// Wrap around scoreboard entries for current MB
+	and (4)	DEPPTRL<1>:uw	acc0.1<4;4,1>:w	SB_MASK*4:uw {NoDDChk}	// Wrap around scoreboard entries for neighbor MBs
+
+Wavefront_Walk:
+	wait	n0:ud
+//	Check for combined "checking" or "completed" threads in forwarded message
+//	2 MSB of scoreboard message indicate:
+//	0b00 = "inter start" message
+//	0b10 = "intra start" message
+//	0b11 = "No Message" or "inter complete" message
+//	0b01 = Reserved (should never occur)
+//
+MB_Loop:
+	shr	(1)	PMSGSEL<1>:uw	r[CMDPTR,CMD_SB_REG_OFF*GRFWIB+2]<0;1,0>:uw	12:w					// DWORD aligned pointer to message handler
+	and.nz.f0.1 (4) NULLREG	r[CMDPTR,CMD_SB_REG_OFF*GRFWIB]<0;1,0>:ub	AVAILFLAG<4;4,1>:ub		// f0.1 4 LSB will have the available flags in ACBD order
+	mov (1) MSGHDRY0.4<1>:ud	r[CMDPTR,CMD_SB_REG_OFF*GRFWIB]<0;1,0>:ud		// Copy MB thread info from scoreboard
+	jmpi (1)	r[PMSGSEL, INLINE_REG_OFF*GRFWIB+16]<0;1,0>:d
+
+//	Now determine whether this is "inter done" or "no message"
+//	through checking debug_counter
+//
+No_Message:
+#ifdef	AS_ENABLED
+	cmp.z.f0.1 (1)	NULLREG	n0:ud	0	// Are all messages handled?
+	and.z.f0.0 (1)	NULLREG	cr0.1:ud	AS_INT	// Poll interrupt bit
+	(-f0.1) jmpi (1)	MB_Loop			// Continue polling the remaining message from current thread
+
+// All messages have been handled
+	(f0.0) jmpi (1) Wavefront_Walk		// No interrupt occurs. Wait for next one
+
+// Interrupt has been detected
+// Save all contents and terminate the scoreboard
+//
+	#include "scoreboard_save_AS.asm"
+
+	// Save scoreboard control data as well
+	//
+	mov (8) AR_SAVE<1>:uw	a0.0<8;8,1>:uw		// All address registers needs to be saved
+    mov (1)	MSGHDR.1:ud		64:ud
+    mov (1)	MSGHDR.2:ud		0x0002001f:ud	// for 3 registers
+	$for(0; <3; 1) {
+	mov (8)	MSGPAYLOADD(%1)<1>	CMD_SB(%1-3)REGION(8,1)
+	}
+    send (8)	NULLREG	MSGHDR	null:ud	DWBWMSGDSC+0x00300000+AS_SAVE	// Save r1 - r3
+
+	send (8) NULLREG MSGHDR r0:ud EOTMSGDSC+TH_INT	// Terminate with "Thread Interrupted" bit set
+#endif	// End AS_ENABLED
+
+Dependency_Check:
+//	Current thread is "checking" but not "completed" (0b10 case).
+//	Check for dependency clear using all availability bits
+//
+	(f0.1) and.z.f0.1 (4)	NULLREG	r[DEPPTRL,CMD_SB_REG_OFF*GRFWIB+3]<1,0>:ub	DONEFLAG:uw	// f0.1 4 LSB contains dependency clear
+	(f0.1.any4h) jmpi (1)	Dependency_Check		// Dependency not clear, keep polling..
+
+//	"Checking" thread and dependency cleared, send a message to let the thread go
+//
+Notify_MSG:
+	send (8)	NULLREG  MSGHDRY0	null:ud    MSG_GW	FWDMSGDSC+NOTIFYMSG
+
+//	Current macroblock has been serviced. Update to next macroblock in special zig-zag order
+//
+Update_CurMB:
+#if 0
+	add.ge.f0.0 (1)	WFLen<1>:w	WFLen<0;1,0>:w	-1:w 			// Set "End of wavefront" flag
+	add (1)	TotalMB<1>:w	TotalMB<0;1,0>:w	-1:w 			// Decrement "TotalMB"
+#else
+	add.ge.f0.0 (2)	TotalMB<2>:w	TotalMB<4;2,2>:w	-1:w 	// Set "End of wavefront" flag and decrement "TotalMB"
+#endif
+	add (8)	MBINDEX(0)<1>	MBINDEX(0)<8;8,1>	4:w				// Increment MB indices
+	and (1)	DEPPTR<1>:uw	acc0<0;1,0>:w	SB_MASK*4:uw {NoDDClr}	// Wrap around 256 scoreboard entries for current MB
+	and (4)	DEPPTRL<1>:uw	acc0.1<4;4,1>:w	SB_MASK*4:uw {NoDDChk}	// Wrap around 256 scoreboard entries for neighbor MBs
+	cmp.e.f0.1 (16)	NULLREGW  StartX<0;1,0>:uw	WIDTHINMB_1<0;1,0>:uw	// Set "on picture right boundary" flag
+#if 0
+	(f0.0) jmpi (1) Wavefront_Walk			// Continue wavefront walking
+#else
+	(f0.0.all2h) jmpi (1) Wavefront_Walk	// Continue wavefront walking
+#endif
+
+//	Start new wavefront
+//
+	cmp.e.f0.0 (1)	NULLREG	TotalMB<0;1,0>:w		0:w	// Set "Last MB" flag
+	(f0.1) add (4)	WFLen<1>:w	WFLen<4;4,1>:w		NewWFOffset<4;4,1>:b
+	(f0.1) add (4)	WFStart(0)<1>	WFStart(0)<4;4,1>	1:w
+	(-f0.1) add (1)	StartX<1>:w		StartX<0;1,0>:w	1:w		// Move to right MB
+	(-f0.1) add (1)	WFStart(0)<1>	WFStart(0)<0;1,0>	1:w
+
+	(-f0.0) jmpi (1)	Scoreboard_Loop				// Not last MB, start new wavefront walking
+
+// All MBs have decoded. Terminate the thread now
+//
+    END_THREAD
+
+#if !defined(COMBINED_KERNEL)		// For standalone kernel only
+.end_code
+
+.end_kernel
+#endif
+
+// End of scoreboard
diff --git a/i965_drv_video/shaders/h264/mc/scoreboard_MBAFF.asm b/i965_drv_video/shaders/h264/mc/scoreboard_MBAFF.asm
new file mode 100644
index 0000000..02a49d8
--- /dev/null
+++ b/i965_drv_video/shaders/h264/mc/scoreboard_MBAFF.asm
@@ -0,0 +1,299 @@
+/*
+ * Dependency control scoreboard kernel for MBAFF frame
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+// Kernel name: scoreboard_MBAFF.asm
+//
+// Dependency control scoreboard kernel for MBAFF frame
+//
+//  $Revision: 16 $
+//  $Date: 10/18/06 4:10p $
+//
+
+// ----------------------------------------------------
+//  Main: scoreboard_MBAFF
+// ----------------------------------------------------
+// ----------------------------------------------------
+//  Scoreboard structure
+// ----------------------------------------------------
+//
+//	1 DWORD per thread
+//
+//	Bit 31:	"Checking" thread, i.e. an intra MB that sends "check dependency" message
+//	Bit 30: "Completed" thread. This bit set by an "update" message from intra/inter MB.
+//	Bits 29:28:	Must set to 0
+//	Bits 27:24:	EUID
+//	Bits 23:18: Reserved
+//	Bits 17:16: TID
+//	Bits 15:8:	X offset of current MB
+//	Bits 15:5:	Reserved
+//	Bits 4:0: 5 bits of available neighbor MB flags
+
+.kernel scoreboard_MBAFF
+SCOREBOARD_MBAFF:
+
+#ifdef _DEBUG
+// WA for FULSIM so we'll know which kernel is being debugged
+mov (1) acc0:ud 0xffaa55a5:ud
+#endif
+
+#include "header.inc"
+#include "scoreboard_header.inc"
+
+//
+//  Now, begin source code....
+//
+
+.code
+
+#ifdef	AS_ENABLED
+	and.z.f0.1	(1)	NULLREG	r0.2<0;1,0>:ud	TH_RES	// Is this a restarted thread previously interrupted?
+	(f0.1) jmpi	(1)	MBAFF_Scoreboard_Init
+
+	#include "scoreboard_restore_AS.asm"
+
+	jmpi (1)	MBAFF_Scoreboard_OpenGW
+MBAFF_Scoreboard_Init:
+#endif	// End AS_ENABLED
+
+// Scoreboard must be initialized to 0xc000ffff, meaning all "completed"
+// And it also avoids message mis-handling for the first MB
+    $for(0; <32; 2) {
+	mov (16)	CMD_SB(%1)<1>	0xc000ffff:ud {Compr}
+	}
+#ifdef	DOUBLE_SB					// Scoreboard size needs to be doubled
+    $for(32; <64; 2) {
+	mov (16)	CMD_SB(%1)<1>	0xc000ffff:ud {Compr}
+	}
+#endif	// DOUBLE_SB
+
+//----------------------------------------------------------
+//	Open message gateway for the scoreboard thread
+//
+//	RegBase = r4 (0x04)
+//	Gateway Size = 64 GRF registers (0x6)
+//	Dispatch ID = r0.20:ub
+//	Scoreboard Thread Key = 0
+//----------------------------------------------------------
+MBAFF_Scoreboard_OpenGW:
+    mov (8)	MSGHDRY0<1>:ud	0x00000000:ud			// Initialize message header payload with 0
+
+	// Send a message with register base RegBase=0x04(r4) and Gateway size = 0x6 = 64 GRF reg and Key = 0
+	// 000 00000100 00000 00000 110 00000000 ==> 0000 0000 1000 0000 0000 0110 0000 0000
+#ifdef	AS_ENABLED
+	add (1) MSGHDRY0.5<1>:ud r0.20:ub	0x00800700:ud	// Allocate 128 GRFs for message gateway - for SIP to send notification MSG
+#else
+  #ifdef	DOUBLE_SB
+	add (1) MSGHDRY0.5<1>:ud r0.20:ub	0x00800600:ud	// 64 GRF's for CTG-B
+  #else
+	add (1) MSGHDRY0.5<1>:ud r0.20:ub	0x00800500:ud	// 32 GRF's for CTG-A
+  #endif	// DOUBLE_SB
+#endif
+
+	send (8)	NULLREG  MSGHDRY0	null:ud    MSG_GW	OGWMSGDSC
+
+//------------------------------------------------------------------------
+//	Send Thread Spawning Message to start dispatching macroblock threads
+//
+//------------------------------------------------------------------------
+#ifdef	AS_ENABLED
+	mov (8)	acc0<1>:ud	CMD_SB(31)<8;8,1>			// Ensure scoreboard data have been completely restored
+#endif	// End AS_ENABLED
+    mov (8)	MSGHDRY1<1>:ud		r0<8;8,1>:ud		// Initialize message header payload with R0
+    mov (1)	MSGHDRY1.4<1>:ud	0x00000400:ud		// Dispatch URB length = 1
+
+	send (8)	NULLREG  MSGHDRY1	null:ud    TS	TSMSGDSC
+
+    mov (8)	MSGHDRY0<1>:ud		0x00000000:ud		// Initialize message header payload with 0
+
+//------------------------------------------------------------------------
+//	Scoreboard control data initialization
+//------------------------------------------------------------------------
+#ifdef	AS_ENABLED
+	or	(1)	cr0.1:ud	cr0.1:ud	AS_INT_EN		// Enable interrupt
+	(f0.1) jmpi	(1)	MBAFF_Scoreboard_State_Init	// Jump if not restarted thread
+
+	// Restore scoreboard kernel control data to r1 - r3
+    mov (1)	m4.1:ud	64:ud				// Starting r1
+    mov (1)	m4.2:ud	0x0002001f:ud		// for 3 registers
+    send (8)	r1.0<1>:ud	m4	null:ud	DWBRMSGDSC_SC+0x00030000+AS_SAVE	// Restore r1 - r3
+	and (1)	CMDPTR<1>:uw	MBINDEX(0)<0;1,0>	SB_MASK*4:uw 	// Restore scoreboard entries for current MB
+
+// EOT if all MBs have been decoded
+	cmp.e.f0.0 (1)	NULLREG	TotalMB<0;1,0>:w	0:w	// Set "Last MB" flag
+	(-f0.0) jmpi (1)	MBAFF_Before_First_MB
+    END_THREAD
+
+// Check whether it is before the first MB
+MBAFF_Before_First_MB:
+	cmp.e.f0.0 (1)	NULLREG	AVAILFLAGD<1>:ud	0x08020401:ud	// in ACBD order
+	(f0.0) jmpi (1)	MBAFF_Wavefront_Walk
+
+MBAFF_Scoreboard_State_Init:
+#endif	// End AS_ENABLED
+	mov (2) WFLen_B<2>:w		HEIGHTINMB_1<0;1,0>:w
+	mov (1)	AVAILFLAGD<1>:ud	0x08020401:ud	// in ACBD order
+	mov (1)	AVAILFLAG1D<1>:ud	0x08020410:ud	// in A_C_B_D_ order
+	mov	(1) CASE00PTR<1>:ud	MBAFF_Notify_MSG_IP-MBAFF_No_Message_IP:ud		// Inter kernel starts
+	mov	(1) CASE10PTR<1>:ud	MBAFF_Dependency_Check_IP-MBAFF_No_Message_IP:ud	// Intra kernel starts
+#ifdef	AS_ENABLED
+	mov	(1) CASE11PTR<1>:ud	0:ud		// No message
+#else
+	mov	(1) CASE11PTR<1>:ud	MBAFF_MB_Loop_IP-MBAFF_No_Message_IP:ud		// No message
+#endif	// End AS_ENABLED
+	mov	(1) StartXD<1>:ud	0:ud
+	mov	(1) NewWFOffsetD<1>:ud	0x01ffff00:ud
+
+	mov (8) WFStart_T(0)<1>	0xffff:w
+	mov (1) WFStart_T(0)<1>	0:w
+
+	mov	(8)	a0.0<1>:uw	0x0:uw						// Initialize all pointers to 0
+
+//------------------------------------------------------------------------
+//	Scoreboard message handling loop
+//------------------------------------------------------------------------
+//
+MBAFF_Scoreboard_Loop:
+// Calculate current wavefront length (same for top and bottom MB wavefronts)
+	add.ge.f0.1 (16)	acc0<1>:w	StartX<0;1,0>:w	0:w	// Used for x>2*y check
+	mac.g.f0.0 (16)	NULLREGW	WFLenY<0;1,0>:w	-2:w	// X - 2*Y > 0 ??
+	(f0.0) mov (2)	WFLen_B<1>:w	WFLenY<0;1,0>:w		// Use smaller vertical wavefront length
+	(f0.0) mov (1)	WFLen_Save<1>:w	WFLenY<0;1,0>:w		// Save current wave front length
+	(-f0.0) asr.sat (2)	WFLen_B<1>:uw	StartX<0;1,0>:w	1:w	// Horizontal wavefront length is smaller
+	(-f0.0) asr.sat (1)	WFLen_Save<1>:uw	StartX<0;1,0>:w	1:w	// Save current wave front length
+
+// Initialize 9-MB group for top macroblock wavefront
+#ifdef ONE_MB_WA_MBAFF
+	mov (2) MBINDEX(0)<1>		WFStart_T(0)<2;2,1>
+	(f0.1) add (4) MBINDEX(0,2)<1>		WFStart_B(0,1)<4;4,1>	-1:w
+	(-f0.1) add (4) MBINDEX(0,2)<1>		WFStart_B(0,0)<4;4,1>	-1:w
+	mov (1) MBINDEX(0,5)<1>		WFStart_B(0,1)<0;1,0>
+	(-f0.1) mov (1) StartX<1>:w		0:w					// WA for 1-MB wide pictures
+#else
+	mov (2) MBINDEX(0)<1>		WFStart_T(0)<2;2,1>			{NoDDClr}
+	add (4) MBINDEX(0,2)<1>		WFStart_B(0,1)<4;4,1>	-1:w	{NoDDChk,NoDDClr}
+	mov (1) MBINDEX(0,5)<1>		WFStart_B(0,1)<0;1,0>		{NoDDChk,NoDDClr}
+	add (4) MBINDEX(0,6)<1>		WFStart_T(0,1)<4;4,1>	-1:w	{NoDDChk}	// Upper MB group (C_B_D_x)
+#endif
+
+// Update WFStart_B[0]
+	add (8)	acc0<1>:w	WFLen<0;1,0>:w	1:w				// WFLen + 1
+	add (1)	WFStart_B(0,0)<1>	acc0<0;1,0>:w	WFStart_T(0,0)<0;1,0>	// WFStart_T[0] + WFLen + 1
+
+MBAFF_Start_Wavefront:
+	mul (16)	MBINDEX(0)<1>	MBINDEX(0)REGION(16,1)	4:w		// Adjust MB order # to be DWORD aligned
+	and (1)	CMDPTR<1>:uw	acc0<0;1,0>:w	SB_MASK*4:uw 	// Wrap around scoreboard entries for current MB
+
+MBAFF_Wavefront_Walk:
+	wait	n0:ud
+
+//	Check for combined "checking" or "completed" threads in forwarded message
+//	2 MSB of scoreboard message indicate:
+//	0b00 = "inter start" message
+//	0b10 = "intra start" message
+//	0b11 = "No Message" or "inter complete" message
+//	0b01 = Reserved (should never occur)
+//
+MBAFF_MB_Loop:
+	shr	(1)	PMSGSEL<1>:uw	r[CMDPTR,CMD_SB_REG_OFF*GRFWIB+2]<0;1,0>:uw	12:w					// DWORD aligned pointer to message handler
+	and.nz.f0.1 (8) NULLREG	r[CMDPTR,CMD_SB_REG_OFF*GRFWIB]<0;1,0>:ub	AVAILFLAG<8;8,1>:ub		// f0.1 8 LSB will have the available flags in ACBDA_C_B_D_ order
+	mov (1) MSGHDRY0.4<1>:ud	r[CMDPTR,CMD_SB_REG_OFF*GRFWIB]<0;1,0>:ud		// Copy MB thread info from scoreboard
+	jmpi (1)	r[PMSGSEL, INLINE_REG_OFF*GRFWIB+16]<0;1,0>:d
+
+//	Now determine whether this is "inter done" or "no message"
+//	through checking debug_counter
+//
+MBAFF_No_Message:
+#ifdef	AS_ENABLED
+	cmp.z.f0.1 (1)	NULLREG	n0:ud	0	// Are all messages handled?
+	and.z.f0.0 (1)	NULLREG	cr0.1:ud	AS_INT	// Poll interrupt bit
+	(-f0.1) jmpi (1)	MBAFF_MB_Loop			// Continue polling the remaining message from current thread
+
+// All messages have been handled
+	(f0.0) jmpi (1) MBAFF_Wavefront_Walk		// No interrupt occurs. Wait for next one
+
+// Interrupt has been detected
+// Save all contents and terminate the scoreboard
+//
+	#include "scoreboard_save_AS.asm"
+
+	// Save scoreboard control data as well
+	//
+    mov (1)	MSGHDR.1:ud		64:ud
+    mov (1)	MSGHDR.2:ud		0x0002001f:ud	// for 3 registers
+	$for(0; <3; 1) {
+	mov (8)	MSGPAYLOADD(%1)<1>	CMD_SB(%1-3)REGION(8,1)
+	}
+    send (8)	NULLREG	MSGHDR	null:ud	DWBWMSGDSC+0x00300000+AS_SAVE	// Save r1 - r3
+
+	send (8) NULLREG MSGHDR r0:ud EOTMSGDSC+TH_INT	// Terminate with "Thread Interrupted" bit set
+#endif	// End AS_ENABLED
+
+MBAFF_Dependency_Check:
+//	Current thread is "checking" but not "completed" (0b10 case).
+//	Check for dependency clear using all availability bits
+//
+	and (8)	DEPPTR<1>:uw	MBINDEX(0,1)REGION(8,1)	SB_MASK*4:uw	// Wrap around scoreboard entries for current MB
+MBAFF_Dependency_Polling:
+	(f0.1) and.z.f0.1 (8)	NULLREG	r[DEPPTR,CMD_SB_REG_OFF*GRFWIB+3]<1,0>:ub	DONEFLAG:uw	// f0.1 8 LSB contains dependency clear
+	(f0.1.any8h) jmpi (1)	MBAFF_Dependency_Polling		// Dependency not clear, keep polling..
+
+//	"Checking" thread and dependency cleared, send a message to let the thread go
+//
+MBAFF_Notify_MSG:
+	send (8)	NULLREG  MSGHDRY0	null:ud    MSG_GW	FWDMSGDSC+NOTIFYMSG
+
+//	Current macroblock has been serviced. Update to next macroblock in special zig-zag order
+//
+MBAFF_Update_CurMB:
+	add.ge.f0.0 (2)	TotalMB<2>:w	TotalMB<4;2,2>:w	-1:w 	// Set "End of wavefront" flag and decrement "TotalMB"
+	add (16)	MBINDEX(0)<1>	MBINDEX(0)REGION(16,1)	4:w		// Increment MB indices
+	and (1)	CMDPTR<1>:uw	acc0<0;1,0>:w	SB_MASK*4:uw // Wrap around scoreboard entries for current MB
+	(f0.0.all2h) jmpi (1) MBAFF_Wavefront_Walk	// Continue wavefront walking
+
+// Top macroblock wavefront walk done, start bottom MB wavefront
+	add.ge.f0.0 (1)	WFLen<1>:w	WFLen_B<0;1,0>:w	0:w	{NoDDClr}		// Set bottom MB wavefront length
+	mov (1)	WFLen_B<1>:w	-1:w	{NoDDChk}			// Reset bottom MB wavefront length
+	
+// Initialize 9-MB group for bottom macroblock wavefront
+	mov (8) MBINDEX(0)<1>		WFStart_B(0)<1;4,0>			{NoDDClr}	// Initialize with WFStart_B[0] and WFStart_B[1]
+	mov (4) MBINDEX(0,1)<1>		WFStart_T(0,1)<0;1,0>		{NoDDChk,NoDDClr}	// Initialize with WFStart_T[1]
+	mov (2) MBINDEX(0,2)<1>		WFStart_T(0)<0;1,0>			{NoDDChk,NoDDClr}	// Initialize with WFStart_T[0]
+	add (4) MBINDEX(0,6)<1>		WFStart_B(0,1)<4;4,1>	-1:w	{NoDDChk}	// Upper MB group (C_B_D_x)
+
+	(f0.0) jmpi (1) MBAFF_Start_Wavefront				// Start bottom MB wavefront walk
+
+//	Start new wavefront
+//
+	cmp.e.f0.1 (16)	NULLREGW  StartX<0;1,0>:uw	WIDTHINMB_1<0;1,0>:uw	// Set "on picture right boundary" flag
+
+	// Update WFStart_T and WFStart_B
+	add (8)	acc0<1>:w	WFStart_T(0)REGION(1,0)	1:w				// Move WFStart_T[0]+1 to acc0 to remove dependency later
+	mov (8)	WFStart_T(0,1)<1>	WFStart_T(0)<8;8,1>	{NoDDClr}	// Shift WFStart_T(B)[0:2] to WFStart_T(B)[1:3]
+	mac (1)	WFStart_T(0,0)<1>	WFLen_Save<0;1,0>:w	2:w {NoDDChk}	// WFStart_T[0] = WFStart_T[0] + 2*WFLen
+
+	cmp.e.f0.0 (1)	NULLREG	TotalMB<0;1,0>:w	0:w	// Set "Last MB" flag
+
+	(f0.1) add (4)	WFLen<1>:w	WFLen<4;4,1>:w	NewWFOffset<4;4,1>:b	// + (0, -1, -1, 1)
+	(f0.1) add (8)	WFStart_T(0)<1>	WFStart_T(0)REGION(4,1)	1:w
+	(-f0.1) add (1)	StartX<1>:w		StartX<0;1,0>:w	1:w		// Move to right MB
+	(-f0.1) add (1)	WFStart_T(0)<1>	WFStart_T(0)REGION(1,0)	1:w
+
+	(-f0.0) jmpi (1)	MBAFF_Scoreboard_Loop				// Not last MB, start new wavefront walking
+
+// All MBs have decoded. Terminate the thread now
+//
+    END_THREAD
+
+#if !defined(COMBINED_KERNEL)		// For standalone kernel only
+.end_code
+
+.end_kernel
+#endif
+
+// End of scoreboard_MBAFF
diff --git a/i965_drv_video/shaders/h264/mc/scoreboard_restore_AS.asm b/i965_drv_video/shaders/h264/mc/scoreboard_restore_AS.asm
new file mode 100644
index 0000000..7d95330
--- /dev/null
+++ b/i965_drv_video/shaders/h264/mc/scoreboard_restore_AS.asm
@@ -0,0 +1,54 @@
+/*
+ * Restore previously stored scoreboard data after content switching back
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+// Module name: scoreboard_restore_AS.asm
+//
+// Restore previously stored scoreboard data after content switching back
+//
+//
+	// Restore scoreboard data to r4 - r67
+	// They are saved in a 2D surface with width of 32 and height of 80.
+	// Each row corresponds to one GRF register in the following order
+	// r4 - r67	: Scoreboard message
+	//
+    mov (8)	MSGSRC<1>:ud	r0.0<8;8,1>:ud {NoDDClr}	// Initialize message header payload with r0
+
+    mov (2)	MSGSRC.0:ud		0:ud {NoDDClr, NoDDChk}		// Starting r4
+    mov (1)	MSGSRC.2:ud		0x0007001f:ud {NoDDChk}		// for 8 registers
+    send (8)	CMD_SB(0)<1>	m1	MSGSRC<8;8,1>:ud	DWBRMSGDSC_SC+0x00080000+AS_SAVE	// Restore r4 - r11
+
+    mov (8)	m2:ud		MSGSRC<8;8,1>:ud
+    mov (1)	m2.1:ud		8:ud
+    send (8)	CMD_SB(8)<1>	m2	null:ud	DWBRMSGDSC_SC+0x00080000+AS_SAVE	// Restore r12 - r19
+
+    mov (8)	m3:ud		MSGSRC<8;8,1>:ud
+    mov (1)	m3.1:ud		16:ud
+    send (8)	CMD_SB(16)<1>	m3	null:ud	DWBRMSGDSC_SC+0x00080000+AS_SAVE	// Restore r20 - r27
+
+    mov (8)	m4:ud		MSGSRC<8;8,1>:ud
+    mov (1)	m4.1:ud		24:ud
+    send (8)	CMD_SB(24)<1>	m4	null:ud	DWBRMSGDSC_SC+0x00080000+AS_SAVE	// Restore r28 - r35
+
+    mov (8)	m5:ud		MSGSRC<8;8,1>:ud
+    mov (1)	m5.1:ud		32:ud
+    send (8)	CMD_SB(32)<1>	m5	null:ud	DWBRMSGDSC_SC+0x00080000+AS_SAVE	// Restore r36 - r43
+
+    mov (8)	m6:ud		MSGSRC<8;8,1>:ud
+    mov (1)	m6.1:ud		40:ud
+    send (8)	CMD_SB(40)<1>	m6	null:ud	DWBRMSGDSC_SC+0x00080000+AS_SAVE	// Restore r44 - r51
+
+    mov (8)	m7:ud		MSGSRC<8;8,1>:ud
+    mov (1)	m7.1:ud		48:ud
+    send (8)	CMD_SB(48)<1>	m7	null:ud	DWBRMSGDSC_SC+0x00080000+AS_SAVE	// Restore r52 - r59
+
+    mov (8)	m8:ud		MSGSRC<8;8,1>:ud
+    mov (1)	m8.1:ud		56:ud
+    send (8)	CMD_SB(56)<1>	m8	null:ud	DWBRMSGDSC_SC+0x00080000+AS_SAVE	// Restore r60 - r67
+
+// End of scoreboard_restore_AS
diff --git a/i965_drv_video/shaders/h264/mc/scoreboard_save_AS.asm b/i965_drv_video/shaders/h264/mc/scoreboard_save_AS.asm
new file mode 100644
index 0000000..13abe0e
--- /dev/null
+++ b/i965_drv_video/shaders/h264/mc/scoreboard_save_AS.asm
@@ -0,0 +1,72 @@
+/*
+ * Save scoreboard data before content switching
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+// Module name: scoreboard_save_AS.asm
+//
+// Save scoreboard data before content switching
+//
+//
+	//	r1 - r35 need to be saved
+	// They are saved in a 2D surface with width of 32 and height of 64.
+	// Each row corresponds to one GRF register in the following order
+	// r4 - r35	: Scoreboard message
+	// r1 - r3  : Scoreboard kernel control data
+
+    mov (8)	MSGHDR<1>:ud	r0.0<8;8,1>:ud	// Initialize message header payload with r0
+    mov (1)	MSGHDR.2:ud		0x0007001f:ud	// for 8 registers
+
+    mov (2)	MSGHDR.0:ud		0:ud
+	$for(0; <8; 2) {
+	mov (16)	MSGPAYLOADD(%1)<1>	CMD_SB(%1)REGION(8,1) {Compr}
+	}
+    send (8)	NULLREG	MSGHDR	null:ud	DWBWMSGDSC+0x00800000+AS_SAVE	// Save r4 - r11
+
+    mov (1)	MSGHDR.1:ud		8:ud
+	$for(0; <8; 2) {
+	mov (16)	MSGPAYLOADD(%1)<1>	CMD_SB(%1+8)REGION(8,1) {Compr}
+	}
+    send (8)	NULLREG	MSGHDR	null:ud	DWBWMSGDSC+0x00800000+AS_SAVE	// Save r12 - r19
+
+    mov (1)	MSGHDR.1:ud		16:ud
+	$for(0; <8; 2) {
+	mov (16)	MSGPAYLOADD(%1)<1>	CMD_SB(%1+16)REGION(8,1) {Compr}
+	}
+    send (8)	NULLREG	MSGHDR	null:ud	DWBWMSGDSC+0x00800000+AS_SAVE	// Save r20 - r27
+
+    mov (1)	MSGHDR.1:ud		24:ud
+	$for(0; <8; 2) {
+	mov (16)	MSGPAYLOADD(%1)<1>	CMD_SB(%1+24)REGION(8,1) {Compr}
+	}
+    send (8)	NULLREG	MSGHDR	null:ud	DWBWMSGDSC+0x00800000+AS_SAVE	// Save r28 - r35
+
+    mov (1)	MSGHDR.1:ud		32:ud
+	$for(0; <8; 2) {
+	mov (16)	MSGPAYLOADD(%1)<1>	CMD_SB(%1+32)REGION(8,1) {Compr}
+	}
+    send (8)	NULLREG	MSGHDR	null:ud	DWBWMSGDSC+0x00800000+AS_SAVE	// Save r36 - r43
+
+    mov (1)	MSGHDR.1:ud		40:ud
+	$for(0; <8; 2) {
+	mov (16)	MSGPAYLOADD(%1)<1>	CMD_SB(%1+40)REGION(8,1) {Compr}
+	}
+    send (8)	NULLREG	MSGHDR	null:ud	DWBWMSGDSC+0x00800000+AS_SAVE	// Save r44 - r51
+
+    mov (1)	MSGHDR.1:ud		48:ud
+	$for(0; <8; 2) {
+	mov (16)	MSGPAYLOADD(%1)<1>	CMD_SB(%1+48)REGION(8,1) {Compr}
+	}
+    send (8)	NULLREG	MSGHDR	null:ud	DWBWMSGDSC+0x00800000+AS_SAVE	// Save r52 - r59
+
+    mov (1)	MSGHDR.1:ud		56:ud
+	$for(0; <8; 2) {
+	mov (16)	MSGPAYLOADD(%1)<1>	CMD_SB(%1+56)REGION(8,1) {Compr}
+	}
+    send (8)	NULLREG	MSGHDR	null:ud	DWBWMSGDSC+0x00800000+AS_SAVE	// Save r60 - r67
+
+// End of scoreboard_save_AS
diff --git a/i965_drv_video/shaders/h264/mc/scoreboard_sip.asm b/i965_drv_video/shaders/h264/mc/scoreboard_sip.asm
new file mode 100644
index 0000000..6330ea1
--- /dev/null
+++ b/i965_drv_video/shaders/h264/mc/scoreboard_sip.asm
@@ -0,0 +1,34 @@
+/*
+ * Scoreboard interrupt handler
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+// Kernel name: scoreboard_sip.asm
+//
+// scoreboard interrupt handler
+//
+// Simply send a notification message to scoreboard thread
+
+    mov (8)		m0<1>:ud	0x00000000:ud			// Initialize message header payload with 0
+#ifdef	DOUBLE_SB
+	mov (1)		m0.5<1>:ud	0x08000200:ud			// Message length = 1 DWORD, sent to GRF offset 64 registers
+#else
+	mov (1)		m0.5<1>:ud	0x04000200:ud			// Message length = 1 DWORD, sent to GRF offset 32 registers
+#endif
+	send (8)	null<1>:ud  m0	null:ud    0x03108002	// Send notification message to scoreboard kernel
+
+	and (1)		cr0.1:ud	cr0.1:ud	0x00800000		// Clear preempt exception bit
+	and (1)		cr0.0:ud	cr0.0:ud	0x7fffffff:ud	// Exit SIP routine
+	nop													// Required by B-spec
+
+.end_code
+
+
+
+
+
+
diff --git a/i965_drv_video/shaders/h264/mc/scoreboard_start_inter.asm b/i965_drv_video/shaders/h264/mc/scoreboard_start_inter.asm
new file mode 100644
index 0000000..831b841
--- /dev/null
+++ b/i965_drv_video/shaders/h264/mc/scoreboard_start_inter.asm
@@ -0,0 +1,47 @@
+/*
+ * Scoreboard function for starting inter prediction kernels
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+#if !defined(__SCOREBOARD_START_INTER__)
+#define __SCOREBOARD_START_INTER__
+//
+// Module name: scoreboard_start_inter.asm
+//
+//	Scoreboard function for starting inter prediction kernels
+//	This function is only used by inter prediction kernels to send message to
+//	scoreboard in order to announce the inter kernel has started
+//
+//  $Revision: 5 $
+//  $Date: 10/18/06 4:11p $
+//
+scoreboard_start_inter:
+
+// First open message gateway since intra kernels need wake-up message to resume
+// 
+    mov (8)	MSGHDRY0<1>:ud	0x00000000:ud			// Initialize message header payload with 0
+
+    // Send a message with register base RegBase = r0 (0x0) and Size = 0x0
+    // 000 00000000 00000 00000 000 00000000 ==> 0000 0000 0000 0000 0000 0000 0000 0000
+    // ---------------------------------------------------------------------------------
+	send (8)	NULLREG  MSGHDRY0	null:ud    MSG_GW	OGWMSGDSC
+
+//	Derive the scoreboard location where the inter thread writes to
+//
+    mov (8)		MSGHDRY1<1>:ud	0x00000000:ud			// Initialize message header payload with 0
+
+	// Compose M0.5:ud
+	#include "set_SB_offset.asm"
+
+	// Compose M0.0:ud, i.e. message payload
+	or	(1)		MSGHDRY1.1<1>:uw	sr0.0<0;1,0>:uw		0x0000:uw	// Set EUID/TID bits + inter start bit
+
+	send (8)	NULLREG  MSGHDRY1	null:ud    MSG_GW	FWDMSGDSC+NOTIFYMSG	// Send "Inter start" message to scoreboard kernel
+
+    RETURN
+
+#endif	// !defined(__SCOREBOARD_START_INTER__)
diff --git a/i965_drv_video/shaders/h264/mc/scoreboard_start_intra.asm b/i965_drv_video/shaders/h264/mc/scoreboard_start_intra.asm
new file mode 100644
index 0000000..6d6d916
--- /dev/null
+++ b/i965_drv_video/shaders/h264/mc/scoreboard_start_intra.asm
@@ -0,0 +1,52 @@
+/*
+ * Scoreboard function for starting intra prediction kernels
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+#if !defined(__SCOREBOARD_START_INTRA__)
+#define __SCOREBOARD_START_INTRA__
+//
+// Module name: scoreboard_start_intra.asm
+//
+//	Scoreboard function for starting intra prediction kernels
+//	This function is only used by intra prediction kernels to send message to
+//	scoreboard in order to check dependency clearance
+//
+//  $Revision: 5 $
+//  $Date: 10/18/06 4:11p $
+//
+scoreboard_start_intra:
+
+// First open message gateway since intra kernels need wake-up message to resume
+// 
+    mov (8)	MSGHDRY0<1>:ud	0x00000000:ud			// Initialize message header payload with 0
+
+    // Send a message with register base RegBase = r0 (0x0) and Size = 0x0
+    // 000 00000000 00000 00000 000 00000000 ==> 0000 0000 0000 0000 0000 0000 0000 0000
+    // ---------------------------------------------------------------------------------
+	and (1)		MSGHDRY0.8<1>:uw	REG_INTRA_PRED_AVAIL_FLAG_BYTE<0;1,0>:ub	0x1f:uw		// Set lower word of key
+	send (8)	NULLREG  MSGHDRY0	null:ud    MSG_GW	OGWMSGDSC
+
+// Send "check dependency" message to scoreboard thread
+// --------------------------
+
+//	Derive the scoreboard location where the intra thread writes to
+//
+    mov (8)		MSGHDRY1<1>:ud	0x00000000:ud			// Initialize message header payload with 0
+
+	// Compose M0.5:ud
+	#include "set_SB_offset.asm"
+
+	// Compose M0.0:ud, i.e. message payload
+	and (1)		MSGHDRY1.0<1>:uw	REG_INTRA_PRED_AVAIL_FLAG_BYTE<0;1,0>:ub	0x1f:uw		// Set lower word of message
+	or	(1)		MSGHDRY1.1<1>:uw	sr0.0<0;1,0>:uw		0x8000:uw	// Set EUID/TID bits + intra start bit
+
+	send (8)	NULLREG  MSGHDRY1	null:ud    MSG_GW	FWDMSGDSC+NOTIFYMSG	// Send "Intra start" message to scoreboard kernel
+
+    RETURN
+
+#endif	// !defined(__SCOREBOARD_START_INTRA__)
diff --git a/i965_drv_video/shaders/h264/mc/scoreboard_update.asm b/i965_drv_video/shaders/h264/mc/scoreboard_update.asm
new file mode 100644
index 0000000..f519e4a
--- /dev/null
+++ b/i965_drv_video/shaders/h264/mc/scoreboard_update.asm
@@ -0,0 +1,41 @@
+/*
+ * Scoreboard update function for decoding kernels
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+//
+// Module name: scoreboard_update.asm
+//
+//	Scoreboard update function for decoding kernels
+//
+//	This module is used by decoding kernels to send message to scoreboard to update the
+//	"complete" status, thus the dependency of the MB can be cleared.
+//
+//  $Revision: 6 $
+//  $Date: 10/16/06 5:19p $
+//
+    mov (8)		MSGHDRY1<1>:ud	0x00000000:ud				// Initialize message header payload with 0
+
+	// Compose M0.5:ud information
+	add (1)	MSGHDRY1.10<1>:uw	r0.20:ub	0x0200:uw				// Message length = 1 DWORD
+	and (1) MSGHDRY1.11<1>:uw	M05_STORE<0;1,0>:uw	SB_MASK*4:uw	// Retrieve stored value and wrap around scoreboard
+
+	or (1)	MSGHDRY1.0<1>:ud	M05_STORE<0;1,0>:uw	0xc0000000:ud	// Set "Completed" bits
+
+#ifndef BSDRESET_ENABLE
+#ifdef INTER_KERNEL
+	mov	(1)	gREG_WRITE_COMMIT_Y<1>:ud	gREG_WRITE_COMMIT_Y<0;1,0>:ud		// Make sure Y write is committed
+	mov	(1)	gREG_WRITE_COMMIT_UV<1>:ud	gREG_WRITE_COMMIT_UV<0;1,0>:ud		// Make sure U/V write is committed
+#else
+	mov	(1)	REG_WRITE_COMMIT_Y<1>:ud	REG_WRITE_COMMIT_Y<0;1,0>:ud		// Make sure Y write is committed
+	mov	(1)	REG_WRITE_COMMIT_UV<1>:ud	REG_WRITE_COMMIT_UV<0;1,0>:ud		// Make sure U/V write is committed
+#endif	// INTER_KERNEL
+#endif	// BSDRESET_ENABLE
+
+	send (8)	NULLREG  MSGHDRY1	null:ud    MSG_GW	FWDMSGDSC
+
+// End of scoreboard_update
diff --git a/i965_drv_video/shaders/h264/mc/set_SB_offset.asm b/i965_drv_video/shaders/h264/mc/set_SB_offset.asm
new file mode 100644
index 0000000..0b166e4
--- /dev/null
+++ b/i965_drv_video/shaders/h264/mc/set_SB_offset.asm
@@ -0,0 +1,26 @@
+/*
+ * Common module to set offset into the scoreboard
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+//
+// Module name: set_SB_offset.asm
+//
+// Common module to set offset into the scoreboard
+//	Note: This is to encapsulate the way M0.5:ud in ForwardMsg is filled.
+//
+//  $Revision: 2 $
+//  $Date: 10/16/06 5:19p $
+//
+	add (1)		MSGHDRY1.10<1>:uw r0.20:ub	0x0200:uw			// Message length = 1 DWORD
+
+	add	(16)	acc0<1>:w	r0.12<0;1,0>:uw	-LEADING_THREAD:w	// 0-based thread count derived from r0.6:ud
+	shl (1)		M05_STORE<1>:uw		acc0<0;1,0>:uw	0x2:uw		// Store for future "update" use, in DWORD unit
+	and	(16)	acc0<1>:w	acc0<16;16,1>:uw	SB_MASK:uw		// Wrap around scoreboard
+	shl (1)		MSGHDRY1.11<1>:uw	acc0<0;1,0>:uw	0x2:uw		// Convert to DWORD offset
+
+// End of set_SB_offset
\ No newline at end of file
diff --git a/i965_drv_video/shaders/h264/mc/weightedPred.asm b/i965_drv_video/shaders/h264/mc/weightedPred.asm
new file mode 100644
index 0000000..76525f9
--- /dev/null
+++ b/i965_drv_video/shaders/h264/mc/weightedPred.asm
@@ -0,0 +1,140 @@
+/*
+ * Weighted prediction of luminance and chrominance
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+// Kernel name: WeightedPred.asm
+//
+// Weighted prediction of luminance and chrominance
+//
+
+
+//#if !defined(__WeightedPred__)		// Make sure this is only included once
+//#define __WeightedPred__
+
+
+	and.z.f0.0 (1) gWEIGHTFLAG:w	gWPREDFLAG:ub					nWBIDIR_MASK:w
+	cmp.e.f0.1 (1) null:w			gPREDFLAG:w						2:w
+	(-f0.0)	jmpi INTERLABEL(WeightedPred)
+	(f0.1) jmpi INTERLABEL(DefaultWeightedPred_BiPred)
+	
+INTERLABEL(DefaultWeightedPred_UniPred):
+
+	cmp.e.f0.0 (1) null:w			gPREDFLAG:w						0:w
+	(f0.0) jmpi INTERLABEL(Return_WeightedPred)
+
+	// luma
+	mov (32)	gubYPRED(0)<2>		gubINTPY1(0)	{Compr}
+	mov (32)	gubYPRED(2)<2>		gubINTPY1(2)	{Compr}
+
+#ifndef MONO
+	// chroma	
+	mov (32)	gubCPRED(0)<2>		gubINTPC1(0)	{Compr}
+#endif
+
+	jmpi INTERLABEL(Return_WeightedPred)
+	
+INTERLABEL(DefaultWeightedPred_BiPred):
+
+	// luma
+	avg.sat (32) gubYPRED(0)<2>		gubINTPY0(0)					gubINTPY1(0)	{Compr}
+	avg.sat (32) gubYPRED(2)<2>		gubINTPY0(2)					gubINTPY1(2)	{Compr}
+	
+#ifndef MONO
+	// chroma
+	avg.sat (32) gubCPRED(0)<2>		gubINTPC0(0)					gubINTPC1(0)	{Compr}
+#endif
+	
+	jmpi INTERLABEL(Return_WeightedPred)
+	
+INTERLABEL(WeightedPred):
+	cmp.e.f0.1 (1) null:w			gWEIGHTFLAG:w					0x80:w
+	(-f0.1) jmpi INTERLABEL(WeightedPred_Explicit)
+	
+	cmp.e.f0.0 (1) null:w			gPREDFLAG:w						2:w
+	(-f0.0) jmpi INTERLABEL(DefaultWeightedPred_UniPred)
+
+	mov (2)		gYADD<1>:w			32:w								{NoDDClr}	
+	mov (2)		gYSHIFT<1>:w		6:w									{NoDDChk}
+	mov (4)		gOFFSET<1>:w		0:w
+	mov (8)		gWT0<2>:w			r[pWGT,0]<0;2,1>:w
+	
+	jmpi INTERLABEL(WeightedPred_LOOP)
+	
+	// Explicit Prediction
+INTERLABEL(WeightedPred_Explicit):
+	
+	// WA for weighted prediction - 2007/09/06	
+#ifdef	SW_W_128		// CTG SW WA
+	cmp.e.f0.1 (8) null:ud			r[pWGT,0]<8;8,1>:uw				gudW128(0)<0;1,0>
+#else					// ILK HW solution
+	and.ne.f0.1 (8) null:uw			r[pWGT,12]<0;1,0>:ub			0x88848421:v	// Expand W=128 flag to all components. 2 MSB are don't care
+#endif	
+	asr.nz.f0.0 (2)	gBIPRED<1>:w	gPREDFLAG<0;1,0>:w				1:w
+	asr (1)		gWEIGHTFLAG:w		gWEIGHTFLAG:w					6:w	
+	(-f0.0) mov (2)	gPREDFLAG1<1>:w	gPREDFLAG<0;1,0>:w								
+	(f0.0) mov (2)	gPREDFLAG0<1>:ud 0x00010001:ud
+	(-f0.0) add (2) gPREDFLAG0<1>:w	-gPREDFLAG1<2;2,1>:w			1:w
+	
+	// WA for weighted prediction - 2007/09/06	
+	(f0.1) mov (8)	gWT0<1>:ud		0x00000080:ud
+	(-f0.1) mov (8) gWT0<2>:w		r[pWGT,0]<16;8,2>:b
+	(-f0.1) mov (8) gO0<2>:w		r[pWGT,1]<16;8,2>:b
+	mul (16)		gWT0<1>:w		gWT0<16;16,1>:w					gPREDFLAG0<0;4,1>:w
+
+	// Compute addition
+	cmp.e.f0.1 (2) null<1>:w		gYWDENOM<2;2,1>:ub				0:w
+	(-f0.1) shl (2) gW0<1>:w		gWEIGHTFLAG<0;1,0>:w			gYWDENOM<2;2,1>:ub
+	(f0.1) mov (2) gW0<1>:w			0:w
+	(-f0.1) asr (2) gW0<1>:w		gW0<2;2,1>:w					1:w
+	shl (2)		gYADD<1>:w			gW0<2;2,1>:w					gBIPRED<0;1,0>:w
+	(f0.1) add (2)	gYADD<1>:w		gYADD<2;2,1>:w					gBIPRED<0;1,0>:w
+	
+	// Compute shift
+	add (2)		gYSHIFT<1>:w		gYWDENOM<2;2,1>:ub				gBIPRED<0;1,0>:w
+	
+	// Compute offset
+	add (4)		acc0<1>:w			gO0<16;4,4>:w					gO1<16;4,4>:w
+	add (4)		acc0<1>:w			acc0<4;4,1>:w					gBIPRED<0;1,0>:w
+	asr (4)		gOFFSET<1>:w		acc0<4;4,1>:w					gBIPRED<0;1,0>:w
+
+INTERLABEL(WeightedPred_LOOP):	
+	// luma
+	$for(0;<4;2) {	
+	mul (16)	acc0<1>:w			gubINTPY0(%1)					gWT0<0;1,0>:w
+	mul (16)	acc1<1>:w			gubINTPY0(%1+1)					gWT0<0;1,0>:w
+	mac (16)	acc0<1>:w			gubINTPY1(%1)					gWT1<0;1,0>:w
+	mac (16)	acc1<1>:w			gubINTPY1(%1+1)					gWT1<0;1,0>:w
+	add (16)	acc0<1>:w			acc0<16;16,1>:w					gYADD:w
+	add (16)	acc1<1>:w			acc1<16;16,1>:w					gYADD:w
+	// Accumulator cannot be used as destination for ASR
+	asr (16)	gwINTERIM_BUF3(0)<1> acc0<16;16,1>:w				gYSHIFT:w
+	asr (16)	gwINTERIM_BUF3(1)<1> acc1<16;16,1>:w				gYSHIFT:w
+	add.sat (16) gubYPRED(%1)<2>	gwINTERIM_BUF3(0)				gOFFSET:w
+	add.sat (16) gubYPRED(%1+1)<2>	gwINTERIM_BUF3(1)				gOFFSET:w
+	}	
+
+#ifndef MONO
+	// chroma
+	mul (16)	acc0<1>:w			gubINTPC0(0)					gUW0<0;2,4>:w
+	mul (16)	acc1<1>:w			gubINTPC0(1)					gUW0<0;2,4>:w
+	mac (16)	acc0<1>:w			gubINTPC1(0)					gUW1<0;2,4>:w
+	mac (16)	acc1<1>:w			gubINTPC1(1)					gUW1<0;2,4>:w
+	add (16)	acc0<1>:w			acc0<16;16,1>:w					gCADD:w
+	add (16)	acc1<1>:w			acc1<16;16,1>:w					gCADD:w
+	// Accumulator cannot be used as destination for ASR
+	asr (16)	gwINTERIM_BUF3(0)<1> acc0<16;16,1>:w				gCSHIFT:w
+	asr (16)	gwINTERIM_BUF3(1)<1> acc1<16;16,1>:w				gCSHIFT:w
+	add.sat (16) gubCPRED(0)<2>		gwINTERIM_BUF3(0)				gUOFFSET<0;2,1>:w
+	add.sat (16) gubCPRED(1)<2>		gwINTERIM_BUF3(1)				gUOFFSET<0;2,1>:w
+#endif
+
+
+INTERLABEL(Return_WeightedPred):
+
+        
+//#endif	// !defined(__WeightedPred__)
diff --git a/i965_drv_video/shaders/h264/mc/writeRecon_C_8x4.asm b/i965_drv_video/shaders/h264/mc/writeRecon_C_8x4.asm
new file mode 100644
index 0000000..be7585e
--- /dev/null
+++ b/i965_drv_video/shaders/h264/mc/writeRecon_C_8x4.asm
@@ -0,0 +1,46 @@
+/*
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+// Kernel name: WriteRecon_C_8x4.asm
+//
+//  $Revision: 10 $
+//  $Date: 10/03/06 5:28p $
+//
+
+
+//#if !defined(__WRITERECON_C_8x4__)		// Make sure this is only included once
+//#define __WRITERECON_C_8x4__
+
+
+	// TODO: Why did I use p0?
+#ifndef MONO
+    add (1)		p0:w					pERRORC:w				-16:w
+	mov (16)	mbMSGPAYLOADC(0,0)<2>	r[p0,0]<32;16,2>:ub				{NoDDClr}
+	mov (16)	mbMSGPAYLOADC(0,1)<2>	r[p0,128]<32;16,2>:ub			{NoDDChk}
+	mov (16)	mbMSGPAYLOADC(1,0)<2>	r[p0,32]<32;16,2>:ub			{NoDDClr}
+	mov (16)	mbMSGPAYLOADC(1,1)<2>	r[p0,128+32]<32;16,2>:ub		{NoDDChk}
+#else	// defined(MONO)
+	mov (16)	mbMSGPAYLOADC(0)<1>		0x80808080:ud {Compr}
+#endif	// !defined(MONO)
+
+ #if defined(MBAFF)
+	add (1)		pMSGDSC:ud				gFIELDFLAGS:uw			MSG_LEN(2)+nDWBWMSGDSC+nBDIX_DESTC+ENWRCOM:ud
+ #elif defined(FIELD)
+	add (1)		pMSGDSC:ud				gFIELDFLAGS:uw			MSG_LEN(2)+nDWBWMSGDSC_TF+nBDIX_DESTC+ENWRCOM:ud
+ #endif
+
+    asr (1)		gMSGSRC.1:d				gMSGSRC.1:d					1:w	{NoDDClr}
+    mov (1)		gMSGSRC.2:ud			0x0003000f:ud					{NoDDChk} // NV12 (16x4)
+
+#if defined(FRAME)
+    send (8)	gREG_WRITE_COMMIT_UV<1>:ud		mMSGHDRCW				gMSGSRC<8;8,1>:ud		DAPWRITE	MSG_LEN(2)+nDWBWMSGDSC+nBDIX_DESTC+ENWRCOM
+#else
+    send (8)	gREG_WRITE_COMMIT_UV<1>:ud		mMSGHDRCW				gMSGSRC<8;8,1>:ud		DAPWRITE	pMSGDSC:ud
+#endif	// defined(FRAME)
+
+//#endif	// !defined(__WRITERECON_C_8x4__)
diff --git a/i965_drv_video/shaders/h264/mc/writeRecon_YC.asm b/i965_drv_video/shaders/h264/mc/writeRecon_YC.asm
new file mode 100644
index 0000000..ff84aff
--- /dev/null
+++ b/i965_drv_video/shaders/h264/mc/writeRecon_YC.asm
@@ -0,0 +1,79 @@
+/*
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+// Kernel name: WriteRecon_YC.asm
+//
+//  $Revision: 10 $
+//  $Date: 10/03/06 5:28p $
+//
+
+
+//#if !defined(__WRITERECON_YC__)		// Make sure this is only included once
+//#define __WRITERECON_YC__
+
+    // TODO: Merge two inst to one.
+    mov (1)		p0:w					nOFFSET_ERRORY:w
+    mov (1)		p1:w					nOFFSET_ERRORY+128:w
+    
+	$for(0; <4; 1) {
+    mov (16)	mbMSGPAYLOADY(%1,0)<1>	r[p0,%1*32+0]<8,2>:ub		{NoDDClr}
+    mov (16)	mbMSGPAYLOADY(%1,16)<1>	r[p0,%1*32+16]<8,2>:ub		{NoDDChk}
+    }    
+	$for(0; <4; 1) {
+    mov (16)	mbMSGPAYLOADY(%1+4,0)<1>	r[p0,%1*32+256]<8,2>:ub			{NoDDClr}
+    mov (16)	mbMSGPAYLOADY(%1+4,16)<1>	r[p0,%1*32+16+256]<8,2>:ub		{NoDDChk}
+    }    
+    
+ 
+ #if defined(MBAFF)
+	add (1)		pMSGDSC:ud				gFIELDFLAGS:uw			MSG_LEN(8)+nDWBWMSGDSC+nBDIX_DESTY+ENWRCOM:ud
+ #elif defined(FIELD)
+	add (1)		pMSGDSC:ud				gFIELDFLAGS:uw			MSG_LEN(8)+nDWBWMSGDSC_TF+nBDIX_DESTY+ENWRCOM:ud
+ #endif
+
+    mov	(2)		gMSGSRC.0<1>:d			gX<2;2,1>:w		{NoDDClr}
+    mov (1)		gMSGSRC.2:ud			0x000f000f:ud	{NoDDChk}
+    
+#if defined(FRAME)
+    send (8)	gREG_WRITE_COMMIT_Y<1>:ud		mMSGHDRYW				gMSGSRC<8;8,1>:ud		DAPWRITE	MSG_LEN(8)+nDWBWMSGDSC+nBDIX_DESTY+ENWRCOM
+#else
+    send (8)	gREG_WRITE_COMMIT_Y<1>:ud		mMSGHDRYW				gMSGSRC<8;8,1>:ud		DAPWRITE	pMSGDSC:ud
+#endif
+
+#ifndef MONO
+	// TODO: Why did I use p0?
+    mov (1)		p0:w					nOFFSET_ERRORC:w
+	mov (16)	mbMSGPAYLOADC(0,0)<2>	r[p0,0]<32;16,2>:ub				{NoDDClr}
+	mov (16)	mbMSGPAYLOADC(0,1)<2>	r[p0,128]<32;16,2>:ub			{NoDDChk}
+	mov (16)	mbMSGPAYLOADC(1,0)<2>	r[p0,32]<32;16,2>:ub			{NoDDClr}
+	mov (16)	mbMSGPAYLOADC(1,1)<2>	r[p0,128+32]<32;16,2>:ub		{NoDDChk}
+	mov (16)	mbMSGPAYLOADC(2,0)<2>	r[p0,64]<32;16,2>:ub			{NoDDClr}
+	mov (16)	mbMSGPAYLOADC(2,1)<2>	r[p0,128+64]<32;16,2>:ub		{NoDDChk}
+	mov (16)	mbMSGPAYLOADC(3,0)<2>	r[p0,96]<32;16,2>:ub			{NoDDClr}
+	mov (16)	mbMSGPAYLOADC(3,1)<2>	r[p0,128+96]<32;16,2>:ub		{NoDDChk}
+
+
+ #if defined(MBAFF)
+	add (1)		pMSGDSC:ud				gFIELDFLAGS:uw			MSG_LEN(4)+nDWBWMSGDSC+nBDIX_DESTC+ENWRCOM:ud
+ #elif defined(FIELD)
+	add (1)		pMSGDSC:ud				gFIELDFLAGS:uw			MSG_LEN(4)+nDWBWMSGDSC_TF+nBDIX_DESTC+ENWRCOM:ud
+ #endif
+
+    asr (1)		gMSGSRC.1:d				gMSGSRC.1:d					1:w	{NoDDClr}
+    mov (1)		gMSGSRC.2:ud			0x0007000f:ud					{NoDDChk} // NV12 (16x4)
+
+#if defined(FRAME)
+    send (8)	gREG_WRITE_COMMIT_UV<1>:ud		mMSGHDRCW				gMSGSRC<8;8,1>:ud		DAPWRITE	MSG_LEN(4)+nDWBWMSGDSC+nBDIX_DESTC+ENWRCOM
+#else
+    send (8)	gREG_WRITE_COMMIT_UV<1>:ud		mMSGHDRCW				gMSGSRC<8;8,1>:ud		DAPWRITE	pMSGDSC:ud
+#endif	// defined(FRAME)
+
+#endif	// !defined(MONO)
+
+
+//#endif	// !defined(__WRITERECON_YC__)
diff --git a/i965_drv_video/shaders/h264/mc/writeRecon_Y_16x8.asm b/i965_drv_video/shaders/h264/mc/writeRecon_Y_16x8.asm
new file mode 100644
index 0000000..509a2ec
--- /dev/null
+++ b/i965_drv_video/shaders/h264/mc/writeRecon_Y_16x8.asm
@@ -0,0 +1,43 @@
+/*
+ * Copyright © <2010>, Intel Corporation.
+ *
+ * This program is licensed under the terms and conditions of the
+ * Eclipse Public License (EPL), version 1.0.  The full text of the EPL is at
+ * http://www.opensource.org/licenses/eclipse-1.0.php.
+ *
+ */
+// Kernel name: WriteRecon_Y_16x8.asm
+//
+//  $Revision: 10 $
+//  $Date: 10/03/06 5:28p $
+//
+
+
+//#if !defined(__WRITERECON_Y_16x8__)		// Make sure this is only included once
+//#define __WRITERECON_Y_16x8__
+
+
+    add (1)		p0:w					pERRORY:w				-256:w
+    add (1)		p1:w					pERRORY:w				-128:w
+    
+	$for(0; <4; 1) {
+    mov (16)	mbMSGPAYLOADY(%1,0)<1>	r[p0,%1*32+0]<8,2>:ub		{NoDDClr}
+    mov (16)	mbMSGPAYLOADY(%1,16)<1>	r[p0,%1*32+16]<8,2>:ub		{NoDDChk}
+    }    
+ 
+ #if defined(MBAFF)
+	add (1)		pMSGDSC:ud				gFIELDFLAGS:uw			MSG_LEN(4)+nDWBWMSGDSC+nBDIX_DESTY+ENWRCOM:ud
+ #elif defined(FIELD)
+	add (1)		pMSGDSC:ud				gFIELDFLAGS:uw			MSG_LEN(4)+nDWBWMSGDSC_TF+nBDIX_DESTY+ENWRCOM:ud
+ #endif
+
+    mov	(2)		gMSGSRC.0<1>:d			gX<2;2,1>:w		{NoDDClr}
+    mov (1)		gMSGSRC.2:ud			0x0007000f:ud	{NoDDChk}
+    
+#if defined(FRAME)
+    send (8)	gREG_WRITE_COMMIT_Y<1>:ud		mMSGHDRYW				gMSGSRC<8;8,1>:ud		DAPWRITE	MSG_LEN(4)+nDWBWMSGDSC+nBDIX_DESTY+ENWRCOM
+#else
+    send (8)	gREG_WRITE_COMMIT_Y<1>:ud		mMSGHDRYW				gMSGSRC<8;8,1>:ud		DAPWRITE	pMSGDSC:ud
+#endif
+
+//#endif	// !defined(__WRITERECON_Y_16x8__)
diff --git a/i965_drv_video/shaders/render/exa_wm.g4i b/i965_drv_video/shaders/render/exa_wm.g4i
index 5d3d45b..8163de5 100644
--- a/i965_drv_video/shaders/render/exa_wm.g4i
+++ b/i965_drv_video/shaders/render/exa_wm.g4i
@@ -35,6 +35,9 @@ define(`dst_y_uw',  `g1.10<2,4,0>UW')
 define(`screen_x0', `g1.0<0,1,0>F')
 define(`screen_y0', `g1.4<0,1,0>F')
 
+/* UV flag */
+define(`interleaved_uv', `g2.0<0,1,0>UW')
+
 /* Source transformation parameters */
 define(`src_du_dx', `g3.0<0,1,0>F')
 define(`src_du_dy', `g3.4<0,1,0>F')
diff --git a/i965_drv_video/shaders/render/exa_wm_src_sample_planar.g4a b/i965_drv_video/shaders/render/exa_wm_src_sample_planar.g4a
index ca77b48..8cbb289 100644
--- a/i965_drv_video/shaders/render/exa_wm_src_sample_planar.g4a
+++ b/i965_drv_video/shaders/render/exa_wm_src_sample_planar.g4a
@@ -34,23 +34,18 @@ include(`exa_wm.g4i')
 /* use simd16 sampler, param 0 is u, param 1 is v. */
 /* 'payload' loading, assuming tex coord start from g4 */
 
+and.nz (1) null interleaved_uv 0x01UW {align1};
+(f0) jmpi INTERLEAVED_UV;
+
 /* load r */
 mov (1) g0.8<1>UD	0x0000e000UD { align1 mask_disable };
 
 /* src_msg will be copied with g0, as it contains send desc */
 /* emit sampler 'send' cmd */
 
-/* sample Y */
-send (16) src_msg_ind		/* msg reg index */
-	src_sample_g<1>UW 	/* readback */
-	g0<8,8,1>UW		/* copy to msg start reg*/
-	sampler (1,0,F)		/* sampler message description, (binding_table,sampler_index,datatype)
-				/* here(src->dst) we should use src_sampler and src_surface */
-	mlen 5 rlen 2 { align1 };   /* required message len 5, readback len 8 */
-	
 /* sample U (Cr) */
 send (16) src_msg_ind		/* msg reg index */
-	src_sample_r<1>UW 	/* readback */
+	src_sample_g<1>UW 	/* readback */
 	g0<8,8,1>UW		/* copy to msg start reg*/
 	sampler (3,2,F)		/* sampler message description, (binding_table,sampler_index,datatype)
 				/* here(src->dst) we should use src_sampler and src_surface */
@@ -63,3 +58,30 @@ send (16) src_msg_ind		/* msg reg index */
 	sampler (5,4,F)		/* sampler message description, (binding_table,sampler_index,datatype)
 				/* here(src->dst) we should use src_sampler and src_surface */
 	mlen 5 rlen 2 { align1 };   /* required message len 5, readback len 8 */
+
+jmpi SAMPLE_Y;
+
+INTERLEAVED_UV:
+/* load r */
+mov (1) g0.8<1>UD	0x0000c000UD { align1 mask_disable };
+
+/* sample UV (CrCb) */
+send (16) src_msg_ind		/* msg reg index */
+	src_sample_g<1>UW 	/* readback */
+	g0<8,8,1>UW		/* copy to msg start reg*/
+	sampler (3,2,F)		/* sampler message description, (binding_table,sampler_index,datatype)
+				/* here(src->dst) we should use src_sampler and src_surface */
+	mlen 5 rlen 4 { align1 };   /* required message len 5, readback len 8 */
+
+/* load r */
+mov (1) g0.8<1>UD	0x0000e000UD { align1 mask_disable };
+
+SAMPLE_Y:
+/* sample Y */
+send (16) src_msg_ind		/* msg reg index */
+	src_sample_r<1>UW 	/* readback */
+	g0<8,8,1>UW		/* copy to msg start reg*/
+	sampler (1,0,F)		/* sampler message description, (binding_table,sampler_index,datatype)
+				/* here(src->dst) we should use src_sampler and src_surface */
+	mlen 5 rlen 2 { align1 };   /* required message len 5, readback len 8 */
+	
diff --git a/i965_drv_video/shaders/render/exa_wm_src_sample_planar.g4b b/i965_drv_video/shaders/render/exa_wm_src_sample_planar.g4b
index 77a5c23..94f2f3b 100644
--- a/i965_drv_video/shaders/render/exa_wm_src_sample_planar.g4b
+++ b/i965_drv_video/shaders/render/exa_wm_src_sample_planar.g4b
@@ -1,4 +1,10 @@
+   { 0x02000005, 0x20002d3c, 0x00000040, 0x00010001 },
+   { 0x00010020, 0x34001c00, 0x00001400, 0x00000004 },
    { 0x00000201, 0x20080061, 0x00000000, 0x0000e000 },
-   { 0x01800031, 0x22001d29, 0x008d0000, 0x02520001 },
-   { 0x01800031, 0x21c01d29, 0x008d0000, 0x02520203 },
+   { 0x01800031, 0x22001d29, 0x008d0000, 0x02520203 },
    { 0x01800031, 0x22401d29, 0x008d0000, 0x02520405 },
+   { 0x00000020, 0x34001c00, 0x00001400, 0x00000003 },
+   { 0x00000201, 0x20080061, 0x00000000, 0x0000c000 },
+   { 0x01800031, 0x22001d29, 0x008d0000, 0x02540203 },
+   { 0x00000201, 0x20080061, 0x00000000, 0x0000e000 },
+   { 0x01800031, 0x21c01d29, 0x008d0000, 0x02520001 },
diff --git a/i965_drv_video/shaders/render/exa_wm_src_sample_planar.g4b.gen5 b/i965_drv_video/shaders/render/exa_wm_src_sample_planar.g4b.gen5
index a381e68..c645723 100644
--- a/i965_drv_video/shaders/render/exa_wm_src_sample_planar.g4b.gen5
+++ b/i965_drv_video/shaders/render/exa_wm_src_sample_planar.g4b.gen5
@@ -1,4 +1,10 @@
+   { 0x02000005, 0x20002d3c, 0x00000040, 0x00010001 },
+   { 0x00010020, 0x34001c00, 0x00001400, 0x00000008 },
    { 0x00000201, 0x20080061, 0x00000000, 0x0000e000 },
-   { 0x01800031, 0x22001d29, 0x208d0000, 0x0a2a0001 },
-   { 0x01800031, 0x21c01d29, 0x208d0000, 0x0a2a0203 },
+   { 0x01800031, 0x22001d29, 0x208d0000, 0x0a2a0203 },
    { 0x01800031, 0x22401d29, 0x208d0000, 0x0a2a0405 },
+   { 0x00000020, 0x34001c00, 0x00001400, 0x00000006 },
+   { 0x00000201, 0x20080061, 0x00000000, 0x0000c000 },
+   { 0x01800031, 0x22001d29, 0x208d0000, 0x0a4a0203 },
+   { 0x00000201, 0x20080061, 0x00000000, 0x0000e000 },
+   { 0x01800031, 0x21c01d29, 0x208d0000, 0x0a2a0001 },
diff --git a/i965_drv_video/shaders/render/exa_wm_yuv_rgb.g4a b/i965_drv_video/shaders/render/exa_wm_yuv_rgb.g4a
index c16037e..5b9e625 100644
--- a/i965_drv_video/shaders/render/exa_wm_yuv_rgb.g4a
+++ b/i965_drv_video/shaders/render/exa_wm_yuv_rgb.g4a
@@ -30,25 +30,25 @@ include(`exa_wm.g4i')
 
 define(`YCbCr_base',	`src_sample_base')
 
-define(`Cr',		`src_sample_r')
-define(`Cr_01',		`src_sample_r_01')
-define(`Cr_23',		`src_sample_r_23')
+define(`Cr',		`src_sample_b')
+define(`Cr_01',		`src_sample_b_01')
+define(`Cr_23',		`src_sample_b_23')
 
-define(`Y',		`src_sample_g')
-define(`Y_01',		`src_sample_g_01')
-define(`Y_23',		`src_sample_g_23')
+define(`Y',		`src_sample_r')
+define(`Y_01',		`src_sample_r_01')
+define(`Y_23',		`src_sample_r_23')
 
-define(`Cb',		`src_sample_b')
-define(`Cb_01',		`src_sample_b_01')
-define(`Cb_23',		`src_sample_b_23')
+define(`Cb',		`src_sample_g')
+define(`Cb_01',		`src_sample_g_01')
+define(`Cb_23',		`src_sample_g_23')
 
-define(`Crn',		`mask_sample_r')
-define(`Crn_01',	`mask_sample_r_01')
-define(`Crn_23',	`mask_sample_r_23')
+define(`Crn',		`mask_sample_g')
+define(`Crn_01',	`mask_sample_g_01')
+define(`Crn_23',	`mask_sample_g_23')
 
-define(`Yn',		`mask_sample_g')
-define(`Yn_01',		`mask_sample_g_01')
-define(`Yn_23',		`mask_sample_g_23')
+define(`Yn',		`mask_sample_r')
+define(`Yn_01',		`mask_sample_r_01')
+define(`Yn_23',		`mask_sample_r_23')
 
 define(`Cbn',		`mask_sample_b')
 define(`Cbn_01',	`mask_sample_b_01')
diff --git a/i965_drv_video/shaders/render/exa_wm_yuv_rgb.g4b b/i965_drv_video/shaders/render/exa_wm_yuv_rgb.g4b
index ce19e1a..6a76da4 100644
--- a/i965_drv_video/shaders/render/exa_wm_yuv_rgb.g4b
+++ b/i965_drv_video/shaders/render/exa_wm_yuv_rgb.g4b
@@ -1,11 +1,11 @@
-   { 0x00802040, 0x23007fbd, 0x008d0200, 0xbd808081 },
-   { 0x00802041, 0x23007fbd, 0x008d0300, 0x3f94fdf4 },
-   { 0x00802040, 0x22c07fbd, 0x008d01c0, 0xbf008084 },
-   { 0x00802040, 0x23407fbd, 0x008d0240, 0xbf008084 },
-   { 0x00802001, 0x240003bc, 0x008d0300, 0x00000000 },
-   { 0x80802048, 0x21c07fbd, 0x008d02c0, 0x3fcc49ba },
-   { 0x00802001, 0x240003bc, 0x008d0300, 0x00000000 },
-   { 0x00802048, 0x24007fbc, 0x008d02c0, 0xbf5020c5 },
+   { 0x00802040, 0x22c07fbd, 0x008d01c0, 0xbd808081 },
+   { 0x00802041, 0x22c07fbd, 0x008d02c0, 0x3f94fdf4 },
+   { 0x00802040, 0x23007fbd, 0x008d0240, 0xbf008084 },
+   { 0x00802040, 0x23407fbd, 0x008d0200, 0xbf008084 },
+   { 0x00802001, 0x240003bc, 0x008d02c0, 0x00000000 },
+   { 0x80802048, 0x21c07fbd, 0x008d0300, 0x3fcc49ba },
+   { 0x00802001, 0x240003bc, 0x008d02c0, 0x00000000 },
+   { 0x00802048, 0x24007fbc, 0x008d0300, 0xbf5020c5 },
    { 0x80802048, 0x22007fbd, 0x008d0340, 0xbec8b439 },
-   { 0x00802001, 0x240003bc, 0x008d0300, 0x00000000 },
+   { 0x00802001, 0x240003bc, 0x008d02c0, 0x00000000 },
    { 0x80802048, 0x22407fbd, 0x008d0340, 0x40011687 },
diff --git a/i965_drv_video/shaders/render/exa_wm_yuv_rgb.g4b.gen5 b/i965_drv_video/shaders/render/exa_wm_yuv_rgb.g4b.gen5
index ce19e1a..6a76da4 100644
--- a/i965_drv_video/shaders/render/exa_wm_yuv_rgb.g4b.gen5
+++ b/i965_drv_video/shaders/render/exa_wm_yuv_rgb.g4b.gen5
@@ -1,11 +1,11 @@
-   { 0x00802040, 0x23007fbd, 0x008d0200, 0xbd808081 },
-   { 0x00802041, 0x23007fbd, 0x008d0300, 0x3f94fdf4 },
-   { 0x00802040, 0x22c07fbd, 0x008d01c0, 0xbf008084 },
-   { 0x00802040, 0x23407fbd, 0x008d0240, 0xbf008084 },
-   { 0x00802001, 0x240003bc, 0x008d0300, 0x00000000 },
-   { 0x80802048, 0x21c07fbd, 0x008d02c0, 0x3fcc49ba },
-   { 0x00802001, 0x240003bc, 0x008d0300, 0x00000000 },
-   { 0x00802048, 0x24007fbc, 0x008d02c0, 0xbf5020c5 },
+   { 0x00802040, 0x22c07fbd, 0x008d01c0, 0xbd808081 },
+   { 0x00802041, 0x22c07fbd, 0x008d02c0, 0x3f94fdf4 },
+   { 0x00802040, 0x23007fbd, 0x008d0240, 0xbf008084 },
+   { 0x00802040, 0x23407fbd, 0x008d0200, 0xbf008084 },
+   { 0x00802001, 0x240003bc, 0x008d02c0, 0x00000000 },
+   { 0x80802048, 0x21c07fbd, 0x008d0300, 0x3fcc49ba },
+   { 0x00802001, 0x240003bc, 0x008d02c0, 0x00000000 },
+   { 0x00802048, 0x24007fbc, 0x008d0300, 0xbf5020c5 },
    { 0x80802048, 0x22007fbd, 0x008d0340, 0xbec8b439 },
-   { 0x00802001, 0x240003bc, 0x008d0300, 0x00000000 },
+   { 0x00802001, 0x240003bc, 0x008d02c0, 0x00000000 },
    { 0x80802048, 0x22407fbd, 0x008d0340, 0x40011687 },
