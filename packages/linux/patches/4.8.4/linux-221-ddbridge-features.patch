diff --git a/drivers/media/dvb-core/Makefile b/drivers/media/dvb-core/Makefile
index 8f22bcd..5ff851a 100644
--- a/drivers/media/dvb-core/Makefile
+++ b/drivers/media/dvb-core/Makefile
@@ -6,6 +6,6 @@ dvb-net-$(CONFIG_DVB_NET) := dvb_net.o
 
 dvb-core-objs := dvbdev.o dmxdev.o dvb_demux.o dvb_filter.o 	\
 		 dvb_ca_en50221.o dvb_frontend.o 		\
-		 $(dvb-net-y) dvb_ringbuffer.o dvb_math.o
+		 $(dvb-net-y) dvb_ringbuffer.o dvb_math.o dvb_netstream.o
 
 obj-$(CONFIG_DVB_CORE) += dvb-core.o
diff --git a/drivers/media/dvb-core/dvb_ca_en50221.c b/drivers/media/dvb-core/dvb_ca_en50221.c
index b5b5b19..2cb8415 100644
--- a/drivers/media/dvb-core/dvb_ca_en50221.c
+++ b/drivers/media/dvb-core/dvb_ca_en50221.c
@@ -344,7 +344,7 @@ static int dvb_ca_en50221_link_init(struct dvb_ca_private *ca, int slot)
 	/* read the buffer size from the CAM */
 	if ((ret = ca->pub->write_cam_control(ca->pub, slot, CTRLIF_COMMAND, IRQEN | CMDREG_SR)) != 0)
 		return ret;
-	if ((ret = dvb_ca_en50221_wait_if_status(ca, slot, STATUSREG_DA, HZ / 10)) != 0)
+	if ((ret = dvb_ca_en50221_wait_if_status(ca, slot, STATUSREG_DA, HZ)) != 0)
 		return ret;
 	if ((ret = dvb_ca_en50221_read_data(ca, slot, buf, 2)) != 2)
 		return -EIO;
@@ -641,65 +641,78 @@ static int dvb_ca_en50221_read_data(struct dvb_ca_private *ca, int slot, u8 * eb
 		}
 	}
 
-	/* check if there is data available */
-	if ((status = ca->pub->read_cam_control(ca->pub, slot, CTRLIF_STATUS)) < 0)
-		goto exit;
-	if (!(status & STATUSREG_DA)) {
-		/* no data */
-		status = 0;
-		goto exit;
-	}
-
-	/* read the amount of data */
-	if ((status = ca->pub->read_cam_control(ca->pub, slot, CTRLIF_SIZE_HIGH)) < 0)
-		goto exit;
-	bytes_read = status << 8;
-	if ((status = ca->pub->read_cam_control(ca->pub, slot, CTRLIF_SIZE_LOW)) < 0)
-		goto exit;
-	bytes_read |= status;
+	if (ca->pub->read_data && (ca->slot_info[slot].slot_state != DVB_CA_SLOTSTATE_LINKINIT)) {
+		if (ebuf == NULL)
+			status = ca->pub->read_data(ca->pub, slot, buf, sizeof(buf));
+		else
+			status = ca->pub->read_data(ca->pub, slot, buf, ecount);
+		if (status < 0)
+			return status;
+		bytes_read =  status;
+		if (status == 0)
+			goto exit;
+	} else {
 
-	/* check it will fit */
-	if (ebuf == NULL) {
-		if (bytes_read > ca->slot_info[slot].link_buf_size) {
-			printk("dvb_ca adapter %d: CAM tried to send a buffer larger than the link buffer size (%i > %i)!\n",
-			       ca->dvbdev->adapter->num, bytes_read, ca->slot_info[slot].link_buf_size);
-			ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_LINKINIT;
-			status = -EIO;
+		/* check if there is data available */
+		if ((status = ca->pub->read_cam_control(ca->pub, slot, CTRLIF_STATUS)) < 0)
 			goto exit;
-		}
-		if (bytes_read < 2) {
-			printk("dvb_ca adapter %d: CAM sent a buffer that was less than 2 bytes!\n",
-			       ca->dvbdev->adapter->num);
-			ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_LINKINIT;
-			status = -EIO;
+		if (!(status & STATUSREG_DA)) {
+			/* no data */
+			status = 0;
 			goto exit;
 		}
-	} else {
-		if (bytes_read > ecount) {
-			printk("dvb_ca adapter %d: CAM tried to send a buffer larger than the ecount size!\n",
-			       ca->dvbdev->adapter->num);
-			status = -EIO;
+
+		/* read the amount of data */
+		if ((status = ca->pub->read_cam_control(ca->pub, slot, CTRLIF_SIZE_HIGH)) < 0)
+			goto exit;
+		bytes_read = status << 8;
+		if ((status = ca->pub->read_cam_control(ca->pub, slot, CTRLIF_SIZE_LOW)) < 0)
 			goto exit;
+		bytes_read |= status;
+
+		/* check it will fit */
+		if (ebuf == NULL) {
+			if (bytes_read > ca->slot_info[slot].link_buf_size) {
+				printk("dvb_ca adapter %d: CAM tried to send a buffer larger than the link buffer size (%i > %i)!\n",
+				       ca->dvbdev->adapter->num, bytes_read, ca->slot_info[slot].link_buf_size);
+				ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_LINKINIT;
+				status = -EIO;
+				goto exit;
+			}
+			if (bytes_read < 2) {
+				printk("dvb_ca adapter %d: CAM sent a buffer that was less than 2 bytes!\n",
+				       ca->dvbdev->adapter->num);
+				ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_LINKINIT;
+				status = -EIO;
+				goto exit;
+			}
+		} else {
+			if (bytes_read > ecount) {
+				printk("dvb_ca adapter %d: CAM tried to send a buffer larger than the ecount size!\n",
+				       ca->dvbdev->adapter->num);
+				status = -EIO;
+				goto exit;
+			}
 		}
-	}
 
-	/* fill the buffer */
-	for (i = 0; i < bytes_read; i++) {
-		/* read byte and check */
-		if ((status = ca->pub->read_cam_control(ca->pub, slot, CTRLIF_DATA)) < 0)
-			goto exit;
+		/* fill the buffer */
+		for (i = 0; i < bytes_read; i++) {
+			/* read byte and check */
+			if ((status = ca->pub->read_cam_control(ca->pub, slot, CTRLIF_DATA)) < 0)
+				goto exit;
 
-		/* OK, store it in the buffer */
-		buf[i] = status;
-	}
+			/* OK, store it in the buffer */
+			buf[i] = status;
+		}
 
-	/* check for read error (RE should now be 0) */
-	if ((status = ca->pub->read_cam_control(ca->pub, slot, CTRLIF_STATUS)) < 0)
-		goto exit;
-	if (status & STATUSREG_RE) {
-		ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_LINKINIT;
-		status = -EIO;
-		goto exit;
+		/* check for read error (RE should now be 0) */
+		if ((status = ca->pub->read_cam_control(ca->pub, slot, CTRLIF_STATUS)) < 0)
+			goto exit;
+		if (status & STATUSREG_RE) {
+			ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_LINKINIT;
+			status = -EIO;
+			goto exit;
+		}
 	}
 
 	/* OK, add it to the receive buffer, or copy into external buffer if supplied */
@@ -751,6 +764,9 @@ static int dvb_ca_en50221_write_data(struct dvb_ca_private *ca, int slot, u8 * b
 	if (bytes_write > ca->slot_info[slot].link_buf_size)
 		return -EINVAL;
 
+	if (ca->pub->write_data && (ca->slot_info[slot].slot_state != DVB_CA_SLOTSTATE_LINKINIT))
+		return ca->pub->write_data(ca->pub, slot, buf, bytes_write);
+
 	/* it is possible we are dealing with a single buffer implementation,
 	   thus if there is data available for read or if there is even a read
 	   already in progress, we do nothing but awake the kernel thread to
@@ -1086,7 +1102,8 @@ static int dvb_ca_en50221_thread(void *data)
 
 					printk("dvb_ca adapter %d: Invalid PC card inserted :(\n",
 					       ca->dvbdev->adapter->num);
-					ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_INVALID;
+					printk("dvb_ca adapter %d: Trying to read attribute memory again (some CAMs are slow)\n",
+						ca->dvbdev->adapter->num);
 					dvb_ca_en50221_thread_update_delay(ca);
 					break;
 				}
@@ -1116,7 +1133,10 @@ static int dvb_ca_en50221_thread(void *data)
 				if (time_after(jiffies, ca->slot_info[slot].timeout)) {
 					printk("dvb_ca adapter %d: DVB CAM did not respond :(\n",
 					       ca->dvbdev->adapter->num);
-					ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_INVALID;
+					printk("dvb_ca adapter %d: Ignoring missing FR (some CAMs are broken)\n",
+					       ca->dvbdev->adapter->num);
+					ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_LINKINIT;
+					ca->wakeup = 1;
 					dvb_ca_en50221_thread_update_delay(ca);
 					break;
 				}
@@ -1142,7 +1162,7 @@ static int dvb_ca_en50221_thread(void *data)
 					}
 
 					printk("dvb_ca adapter %d: DVB CAM link initialisation failed :(\n", ca->dvbdev->adapter->num);
-					ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_INVALID;
+					ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_UNINITIALISED;
 					dvb_ca_en50221_thread_update_delay(ca);
 					break;
 				}
diff --git a/drivers/media/dvb-core/dvb_ca_en50221.h b/drivers/media/dvb-core/dvb_ca_en50221.h
index 1e4bbbd..056d10c 100644
--- a/drivers/media/dvb-core/dvb_ca_en50221.h
+++ b/drivers/media/dvb-core/dvb_ca_en50221.h
@@ -41,6 +41,8 @@
  * @write_attribute_mem: function for writing attribute memory on the CAM
  * @read_cam_control:	function for reading the control interface on the CAM
  * @write_cam_control:	function for reading the control interface on the CAM
+ * @read_data:		function for reading data
+ * @write_data:		function for writing data
  * @slot_reset:		function to reset the CAM slot
  * @slot_shutdown:	function to shutdown a CAM slot
  * @slot_ts_enable:	function to enable the Transport Stream on a CAM slot
@@ -66,6 +68,11 @@ struct dvb_ca_en50221 {
 	int (*write_cam_control)(struct dvb_ca_en50221 *ca,
 				 int slot, u8 address, u8 value);
 
+	int (*read_data)(struct dvb_ca_en50221* ca,
+				int slot, u8 *ebuf, int ecount);
+	int (*write_data)(struct dvb_ca_en50221* ca,
+				int slot, u8 *ebuf, int ecount);
+
 	int (*slot_reset)(struct dvb_ca_en50221 *ca, int slot);
 	int (*slot_shutdown)(struct dvb_ca_en50221 *ca, int slot);
 	int (*slot_ts_enable)(struct dvb_ca_en50221 *ca, int slot);
diff --git a/drivers/media/dvb-core/dvb_frontend.c b/drivers/media/dvb-core/dvb_frontend.c
index be99c8d..254f89d 100644
--- a/drivers/media/dvb-core/dvb_frontend.c
+++ b/drivers/media/dvb-core/dvb_frontend.c
@@ -1037,6 +1037,7 @@ static struct dtv_cmds_h dtv_cmds[DTV_MAX_COMMAND + 1] = {
 	_DTV_CMD(DTV_STREAM_ID, 1, 0),
 	_DTV_CMD(DTV_DVBT2_PLP_ID_LEGACY, 1, 0),
 	_DTV_CMD(DTV_LNA, 1, 0),
+	_DTV_CMD(DTV_INPUT, 1, 0),
 
 	/* Get */
 	_DTV_CMD(DTV_DISEQC_SLAVE_REPLY, 0, 1),
@@ -1467,6 +1468,14 @@ static int dtv_property_process_get(struct dvb_frontend *fe,
 		tvp->u.data = c->lna;
 		break;
 
+	case DTV_INPUT:
+		tvp->u.buffer.data[0] = c->input;
+		tvp->u.buffer.data[1] = fe->ops.xbar[0];
+		tvp->u.buffer.data[2] = fe->ops.xbar[1];
+		tvp->u.buffer.data[3] = fe->ops.xbar[2];
+		tvp->u.buffer.len = 4;
+		break;
+
 	/* Fill quality measures */
 	case DTV_STAT_SIGNAL_STRENGTH:
 		tvp->u.st = c->strength;
@@ -1902,6 +1911,12 @@ static int dtv_property_process_set(struct dvb_frontend *fe,
 			c->lna = LNA_AUTO;
 		break;
 
+	case DTV_INPUT:
+		c->input = tvp->u.data;
+		if (fe->ops.set_input)
+			r = fe->ops.set_input(fe, c->input);
+		break;
+
 	default:
 		return -EINVAL;
 	}
diff --git a/drivers/media/dvb-core/dvb_frontend.h b/drivers/media/dvb-core/dvb_frontend.h
index fb6e848..3efb21b 100644
--- a/drivers/media/dvb-core/dvb_frontend.h
+++ b/drivers/media/dvb-core/dvb_frontend.h
@@ -452,6 +452,7 @@ struct dvb_frontend_ops {
 	int (*i2c_gate_ctrl)(struct dvb_frontend* fe, int enable);
 	int (*ts_bus_ctrl)(struct dvb_frontend* fe, int acquire);
 	int (*set_lna)(struct dvb_frontend *);
+	int (*set_input)(struct dvb_frontend *, int);
 
 	/*
 	 * These callbacks are for devices that implement their own
@@ -464,6 +465,8 @@ struct dvb_frontend_ops {
 
 	int (*set_property)(struct dvb_frontend* fe, struct dtv_property* tvp);
 	int (*get_property)(struct dvb_frontend* fe, struct dtv_property* tvp);
+
+	u8 xbar[3];
 };
 
 #ifdef __DVB_CORE__
@@ -613,6 +616,7 @@ struct dtv_frontend_properties {
 	u8			atscmh_sccc_code_mode_d;
 
 	u32			lna;
+	s32                     input;
 
 	/* statistics data */
 	struct dtv_fe_stats	strength;
diff --git a/drivers/media/dvb-core/dvb_netstream.c b/drivers/media/dvb-core/dvb_netstream.c
new file mode 100644
index 0000000..0d80780
--- /dev/null
+++ b/drivers/media/dvb-core/dvb_netstream.c
@@ -0,0 +1,259 @@
+/*
+ * dvb_netstream.c: support for DVB to network streaming hardware
+ *
+ * Copyright (C) 2012-2013 Marcus and Ralph Metzler
+ *                         for Digital Devices GmbH
+ *
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 only, as published by the Free Software Foundation.
+ *
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA
+ * Or, point your browser to http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/net.h>
+#include "dvb_netstream.h"
+
+static ssize_t ns_write(struct file *file, const char *buf,
+			size_t count, loff_t *ppos)
+{
+	pr_info("%s\n", __func__);
+	return 0;
+}
+
+static ssize_t ns_read(struct file *file, char *buf,
+		       size_t count, loff_t *ppos)
+{
+	pr_info("%s\n", __func__);
+	return 0;
+}
+
+static unsigned int ns_poll(struct file *file, poll_table *wait)
+{
+	pr_info("%s\n", __func__);
+	return 0;
+}
+
+static int ns_stop(struct dvbnss *nss)
+{
+	struct dvb_netstream *ns = nss->ns;
+
+	mutex_lock(&ns->mutex);
+	if (nss->running && ns->stop) {
+		ns->stop(nss);
+		nss->running = 0;
+	}
+	mutex_unlock(&ns->mutex);
+	return 0;
+}
+
+static int ns_release(struct inode *inode, struct file *file)
+{
+	struct dvbnss *nss = file->private_data;
+	struct dvb_netstream *ns = nss->ns;
+
+	ns_stop(nss);
+	if (ns->free)
+		ns->free(nss);
+	mutex_lock(&ns->mutex);
+	list_del(&nss->nssl);
+	mutex_unlock(&ns->mutex);
+	vfree(nss);
+	return 0;
+}
+
+static int ns_open(struct inode *inode, struct file *file)
+{
+	struct dvb_device *dvbdev = file->private_data;
+	struct dvb_netstream *ns = dvbdev->priv;
+	struct dvbnss *nss;
+
+	nss = vmalloc(sizeof(*nss));
+	if (!nss)
+		return -ENOMEM;
+	nss->ns = ns;
+	if (ns->alloc && ns->alloc(nss) < 0) {
+		vfree(nss);
+		return -EBUSY;
+	}
+	file->private_data = nss;
+	nss->running = 0;
+	mutex_lock(&ns->mutex);
+	list_add(&nss->nssl, &ns->nssl);
+	mutex_unlock(&ns->mutex);
+	return 0;
+}
+
+static int set_net(struct dvbnss *nss, struct dvb_ns_params *p)
+{
+	return 0;
+}
+
+static int do_ioctl(struct file *file, unsigned int cmd, void *parg)
+{
+	struct dvbnss *nss = file->private_data;
+	struct dvb_netstream *ns = nss->ns;
+	/*unsigned long arg = (unsigned long) parg;*/
+	int ret = 0;
+
+	switch (cmd) {
+	case NS_SET_RTCP_MSG:
+	{
+		struct dvb_ns_rtcp *rtcpm = parg;
+
+		if (ns->set_rtcp_msg)
+			ret = ns->set_rtcp_msg(nss, rtcpm->msg, rtcpm->len);
+		break;
+	}
+
+	case NS_SET_NET:
+		memcpy(&nss->params, parg, sizeof(nss->params));
+		if (ns->set_net)
+			ret = ns->set_net(nss);
+		else
+			ret = set_net(nss, (struct dvb_ns_params *) parg);
+		break;
+
+	case NS_START:
+		mutex_lock(&ns->mutex);
+		if (nss->running) {
+			ret = -EBUSY;
+		} else if (ns->start) {
+			ret = ns->start(nss);
+			nss->running = 1;
+		}
+		mutex_unlock(&ns->mutex);
+		break;
+
+	case NS_STOP:
+		ns_stop(nss);
+		break;
+
+	case NS_SET_PACKETS:
+	{
+		struct dvb_ns_packet *packet =  parg;
+
+		if (ns->set_ts_packets)
+			ret = ns->set_ts_packets(nss, packet->buf,
+						 packet->count * 188);
+		break;
+	}
+
+	case NS_INSERT_PACKETS:
+	{
+		u8 count = *(u8 *) parg;
+
+		if (ns->insert_ts_packets)
+			ret = ns->insert_ts_packets(nss, count);
+		break;
+	}
+
+	case NS_SET_PID:
+	{
+		u16 pid = *(u16 *) parg;
+		u16 byte = (pid & 0x1fff) >> 3;
+		u8 bit = 1 << (pid & 7);
+
+		if (pid & 0x2000) {
+			if (pid & 0x8000)
+				memset(nss->pids, 0xff, 0x400);
+			else
+				memset(nss->pids, 0x00, 0x400);
+		} else {
+			if (pid & 0x8000)
+				nss->pids[byte] |= bit;
+			else
+				nss->pids[byte] &= ~bit;
+		}
+		if (ns->set_pid)
+			ret = ns->set_pid(nss, pid);
+		break;
+	}
+
+	case NS_SET_PIDS:
+		ret = copy_from_user(nss->pids, *(u8 **) parg, 0x400);
+		if (ret < 0)
+			return ret;
+		if (ns->set_pids)
+			ret = ns->set_pids(nss);
+		break;
+
+	case NS_SET_CI:
+	{
+		u8 ci = *(u8 *) parg;
+
+		if (nss->running)
+			ret = -EBUSY;
+		else if (ns->set_ci)
+			ret = ns->set_ci(nss, ci);
+		break;
+	}
+
+	default:
+		ret = -EINVAL;
+		break;
+	}
+	return ret;
+}
+
+static long ns_ioctl(struct file *file,
+		     unsigned int cmd, unsigned long arg)
+{
+	return dvb_usercopy(file, cmd, arg, do_ioctl);
+}
+
+static const struct file_operations ns_fops = {
+	.owner   = THIS_MODULE,
+	.read    = ns_read,
+	.write   = ns_write,
+	.open    = ns_open,
+	.release = ns_release,
+	.poll    = ns_poll,
+	.mmap    = 0,
+	.unlocked_ioctl = ns_ioctl,
+};
+
+static struct dvb_device ns_dev = {
+	.priv    = 0,
+	.readers = 1,
+	.writers = 1,
+	.users   = 1,
+	.fops    = &ns_fops,
+};
+
+
+int dvb_netstream_init(struct dvb_adapter *dvb_adapter,
+		       struct dvb_netstream *ns)
+{
+	mutex_init(&ns->mutex);
+	spin_lock_init(&ns->lock);
+	ns->exit = 0;
+	dvb_register_device(dvb_adapter, &ns->dvbdev, &ns_dev, ns,
+			    DVB_DEVICE_NS, 0);
+	INIT_LIST_HEAD(&ns->nssl);
+	return 0;
+}
+EXPORT_SYMBOL(dvb_netstream_init);
+
+void dvb_netstream_release(struct dvb_netstream *ns)
+{
+	ns->exit = 1;
+	if (ns->dvbdev->users > 1) {
+		wait_event(ns->dvbdev->wait_queue,
+			   ns->dvbdev->users == 1);
+	}
+	dvb_unregister_device(ns->dvbdev);
+}
+EXPORT_SYMBOL(dvb_netstream_release);
diff --git a/drivers/media/dvb-core/dvb_netstream.h b/drivers/media/dvb-core/dvb_netstream.h
new file mode 100644
index 0000000..a40f1f1
--- /dev/null
+++ b/drivers/media/dvb-core/dvb_netstream.h
@@ -0,0 +1,93 @@
+/*
+ * dvb_netstream.c: support for DVB to network streaming hardware
+ *
+ * Copyright (C) 2012-2013 Marcus and Ralph Metzler
+ *                         for Digital Devices GmbH
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 only, as published by the Free Software Foundation.
+ *
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA
+ * Or, point your browser to http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifndef _DVB_NETSTREAM_H_
+#define _DVB_NETSTREAM_H_
+
+#include <linux/sched.h>
+#include <linux/spinlock.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <linux/module.h>
+#include <linux/poll.h>
+#include <linux/ioctl.h>
+#include <linux/wait.h>
+#include <linux/socket.h>
+#include <linux/in.h>
+#include <asm/uaccess.h>
+#include <linux/dvb/ns.h>
+
+#include "dvbdev.h"
+
+#define DVBNS_MAXPIDS 32
+
+struct dvbnss {
+	struct dvb_netstream *ns;
+	void *priv;
+
+	u8  pids[1024];
+	u8  packet[1328];
+	u32 pp;
+
+	struct socket *sock;
+	struct sockaddr_in sadr;
+	u32    sn;
+
+	struct dvb_ns_params params;
+
+	struct list_head nssl;
+	int                running;
+};
+
+#define MAX_DVBNSS 32
+
+struct dvb_netstream {
+	void              *priv;
+
+	struct mutex       mutex;
+	spinlock_t         lock;
+	struct dvb_device *dvbdev;
+	int                exit;
+
+	struct list_head nssl;
+
+	int (*set_net)(struct dvbnss *);
+	int (*set_pid)(struct dvbnss *, u16);
+	int (*set_pids)(struct dvbnss *);
+	int (*set_ci)(struct dvbnss *, u8);
+	int (*set_rtcp_msg)(struct dvbnss *, u8 *, u32);
+	int (*set_ts_packets)(struct dvbnss *, u8 *, u32);
+	int (*insert_ts_packets)(struct dvbnss *, u8);
+	int (*start)(struct dvbnss *);
+	int (*stop)(struct dvbnss *);
+	int (*alloc)(struct dvbnss *);
+	void (*free)(struct dvbnss *);
+};
+
+
+void dvb_netstream_release(struct dvb_netstream *);
+int  dvb_netstream_init(struct dvb_adapter *, struct dvb_netstream *);
+
+
+#endif
diff --git a/drivers/media/dvb-core/dvbdev.c b/drivers/media/dvb-core/dvbdev.c
index 75a3f4b..3f309b4 100644
--- a/drivers/media/dvb-core/dvbdev.c
+++ b/drivers/media/dvb-core/dvbdev.c
@@ -50,7 +50,7 @@ static DEFINE_MUTEX(dvbdev_register_lock);
 
 static const char * const dnames[] = {
 	"video", "audio", "sec", "frontend", "demux", "dvr", "ca",
-	"net", "osd"
+	"net", "osd", "ci", "mod", "ns", "nsd"
 };
 
 #ifdef CONFIG_DVB_DYNAMIC_MINORS
@@ -900,6 +900,7 @@ int dvb_usercopy(struct file *file,
 	kfree(mbuf);
 	return err;
 }
+EXPORT_SYMBOL(dvb_usercopy);
 
 static int dvb_uevent(struct device *dev, struct kobj_uevent_env *env)
 {
diff --git a/drivers/media/dvb-core/dvbdev.h b/drivers/media/dvb-core/dvbdev.h
index 4aff7bd..ae4f4d1 100644
--- a/drivers/media/dvb-core/dvbdev.h
+++ b/drivers/media/dvb-core/dvbdev.h
@@ -48,6 +48,10 @@
 #define DVB_DEVICE_CA         6
 #define DVB_DEVICE_NET        7
 #define DVB_DEVICE_OSD        8
+#define DVB_DEVICE_CI         9
+#define DVB_DEVICE_MOD       10
+#define DVB_DEVICE_NS        11
+#define DVB_DEVICE_NSD       12
 
 #define DVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr) \
 	static short adapter_nr[] = \
diff --git a/drivers/media/dvb-frontends/Kconfig b/drivers/media/dvb-frontends/Kconfig
index c645aa8..f5ff222 100644
--- a/drivers/media/dvb-frontends/Kconfig
+++ b/drivers/media/dvb-frontends/Kconfig
@@ -28,6 +28,14 @@ config DVB_STV090x
 	  DVB-S/S2/DSS Multistandard Professional/Broadcast demodulators.
 	  Say Y when you want to support these frontends.
 
+config DVB_STV0910
+	tristate "STV0910 based"
+	depends on DVB_CORE && I2C
+	default m if !MEDIA_SUBDRV_AUTOSELECT
+	help
+	  ST STV0910 DVB-S/S2 demodulator.
+	  Say Y when you want to support these frontends.
+
 config DVB_STV6110x
 	tristate "STV6110/(A) based tuners"
 	depends on DVB_CORE && I2C
@@ -35,6 +43,21 @@ config DVB_STV6110x
 	help
 	  A Silicon tuner that supports DVB-S and DVB-S2 modes
 
+config DVB_STV6111
+	tristate "STV6111 based tuners"
+	depends on DVB_CORE && I2C
+	default m if !MEDIA_SUBDRV_AUTOSELECT
+	help
+	  A Silicon tuner that supports DVB-S and DVB-S2 modes
+
+config DVB_MXL5XX
+	tristate "Maxlinear MX58x based"
+	depends on DVB_CORE && I2C
+	default m if !MEDIA_SUBDRV_AUTOSELECT
+	help
+	  Maxlinear MX58x family of tuners/demods.
+	  Say Y when you want to support these frontends.
+
 config DVB_M88DS3103
 	tristate "Montage Technology M88DS3103"
 	depends on DVB_CORE && I2C && I2C_MUX
@@ -89,6 +112,24 @@ config DVB_MN88473
 	help
 	  Say Y when you want to support this frontend.
 
+config DVB_STV0367DD
+	tristate "STV 0367 (DD)"
+	depends on DVB_CORE && I2C
+	default m if !MEDIA_SUBDRV_AUTOSELECT
+	help
+	  STV 0367 DVB-C/T demodulator (Digital Devices driver).
+
+	  Say Y when you want to support this frontend.
+
+config DVB_CXD2843
+	tristate "Sony CXD2843 DVB-C/T demodulator family"
+	depends on DVB_CORE && I2C
+	default m if !MEDIA_SUBDRV_AUTOSELECT
+	help
+	  Sony CXD2843 demodulator (Digital Devices driver).
+
+	  Say Y when you want to support this frontend.
+
 comment "DVB-S (satellite) frontends"
 	depends on DVB_CORE
 
diff --git a/drivers/media/dvb-frontends/Makefile b/drivers/media/dvb-frontends/Makefile
index e90165a..d3fed98 100644
--- a/drivers/media/dvb-frontends/Makefile
+++ b/drivers/media/dvb-frontends/Makefile
@@ -111,6 +111,11 @@ obj-$(CONFIG_DVB_CXD2820R) += cxd2820r.o
 obj-$(CONFIG_DVB_CXD2841ER) += cxd2841er.o
 obj-$(CONFIG_DVB_DRXK) += drxk.o
 obj-$(CONFIG_DVB_TDA18271C2DD) += tda18271c2dd.o
+obj-$(CONFIG_DVB_STV0367DD) += stv0367dd.o
+obj-$(CONFIG_DVB_CXD2843) += cxd2843.o
+obj-$(CONFIG_DVB_STV0910) += stv0910.o
+obj-$(CONFIG_DVB_STV6111) += stv6111.o
+obj-$(CONFIG_DVB_MXL5XX) += mxl5xx.o
 obj-$(CONFIG_DVB_SI2165) += si2165.o
 obj-$(CONFIG_DVB_A8293) += a8293.o
 obj-$(CONFIG_DVB_SP2) += sp2.o
diff --git a/drivers/media/dvb-frontends/cxd2843.c b/drivers/media/dvb-frontends/cxd2843.c
new file mode 100644
index 0000000..959e4ab
--- /dev/null
+++ b/drivers/media/dvb-frontends/cxd2843.c
@@ -0,0 +1,2063 @@
+/*
+ * Driver for the Sony CXD2843ER DVB-T/T2/C/C2 demodulator.
+ * Also supports the CXD2837ER DVB-T/T2/C and the
+ * CXD2838ER ISDB-T demodulator.
+ *
+ * Copyright (C) 2013-2015 Digital Devices GmbH
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 only, as published by the Free Software Foundation.
+ *
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA
+ * Or, point your browser to http://www.gnu.org/copyleft/gpl.html
+ */
+
+#undef pr_fmt
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/firmware.h>
+#include <linux/i2c.h>
+#include <linux/mutex.h>
+#include <asm/div64.h>
+
+#include "dvb_frontend.h"
+#include "dvb_math.h"
+#include "cxd2843.h"
+
+#define FE_STATUS_FULL_LOCK (FE_HAS_SIGNAL \
+			| FE_HAS_CARRIER \
+			| FE_HAS_VITERBI \
+			| FE_HAS_SYNC \
+			| FE_HAS_LOCK)
+
+#define INTLOG10X100(x) ((u32) (((u64) intlog10(x) * 100) >> 24))
+
+#define USE_ALGO 1
+
+enum demod_type { CXD2843, CXD2837, CXD2838 };
+enum demod_state { Unknown, Shutdown, Sleep, ActiveT,
+		   ActiveT2, ActiveC, ActiveC2, ActiveIT };
+enum t2_profile { T2P_Base, T2P_Lite };
+
+struct cxd_state {
+	struct dvb_frontend   frontend;
+	struct i2c_adapter   *i2c;
+	struct mutex          mutex;
+
+	u8  adrt;
+	u8  curbankt;
+
+	u8  adrx;
+	u8  curbankx;
+
+	enum demod_type  type;
+	enum demod_state state;
+	enum t2_profile T2Profile;
+	enum fe_delivery_system delsys;
+
+	u8    IF_FS;
+	int   ContinuousClock;
+	int   SerialMode;
+	u8    SerialClockFrequency;
+
+	u32   LockTimeout;
+	u32   TSLockTimeout;
+	u32   L1PostTimeout;
+	u32   DataSliceID;
+	int   FirstTimeLock;
+	u32   plp;
+	u32   last_status;
+
+	u32   bandwidth;
+	u32   bw;
+
+	unsigned long tune_time;
+
+	u32   LastBERNominator;
+	u32   LastBERDenominator;
+	u8    BERScaleMax;
+};
+
+static int i2c_write(struct i2c_adapter *adap, u8 adr, u8 *data, int len)
+{
+	struct i2c_msg msg = {
+		.addr = adr, .flags = 0, .buf = data, .len = len};
+
+	if (i2c_transfer(adap, &msg, 1) != 1) {
+		pr_err("i2c_write error\n");
+		return -EREMOTEIO;
+	}
+	return 0;
+}
+
+static int writeregs(struct cxd_state *state, u8 adr, u8 reg,
+		     u8 *regd, u16 len)
+{
+	u8 data[len + 1];
+
+	data[0] = reg;
+	memcpy(data + 1, regd, len);
+	return i2c_write(state->i2c, adr, data, len + 1);
+}
+
+static int writereg(struct cxd_state *state, u8 adr, u8 reg, u8 dat)
+{
+	u8 mm[2] = {reg, dat};
+
+	return i2c_write(state->i2c, adr, mm, 2);
+}
+
+static int i2c_read(struct i2c_adapter *adap,
+		    u8 adr, u8 *msg, int len, u8 *answ, int alen)
+{
+	struct i2c_msg msgs[2] = { { .addr = adr, .flags = 0,
+				     .buf = msg, .len = len},
+				   { .addr = adr, .flags = I2C_M_RD,
+				     .buf = answ, .len = alen } };
+	if (i2c_transfer(adap, msgs, 2) != 2) {
+		pr_err("i2c_read error\n");
+		return -EREMOTEIO;
+	}
+	return 0;
+}
+
+static int readregs(struct cxd_state *state, u8 adr, u8 reg,
+		    u8 *val, int count)
+{
+	return i2c_read(state->i2c, adr, &reg, 1, val, count);
+}
+
+static int readregst_unlocked(struct cxd_state *cxd, u8 bank,
+			      u8 Address, u8 *pValue, u16 count)
+{
+	int status = 0;
+
+	if (bank != 0xFF && cxd->curbankt != bank) {
+		status = writereg(cxd, cxd->adrt, 0, bank);
+		if (status < 0) {
+			cxd->curbankt = 0xFF;
+			return status;
+		}
+		cxd->curbankt = bank;
+	}
+	status = readregs(cxd, cxd->adrt, Address, pValue, count);
+	return status;
+}
+
+static int readregst(struct cxd_state *cxd, u8 Bank,
+		     u8 Address, u8 *pValue, u16 count)
+{
+	int status;
+
+	mutex_lock(&cxd->mutex);
+	status = readregst_unlocked(cxd, Bank, Address, pValue, count);
+	mutex_unlock(&cxd->mutex);
+	return status;
+}
+
+static int readregsx_unlocked(struct cxd_state *cxd, u8 Bank,
+			      u8 Address, u8 *pValue, u16 count)
+{
+	int status = 0;
+
+	if (Bank != 0xFF && cxd->curbankx != Bank) {
+		status = writereg(cxd, cxd->adrx, 0, Bank);
+		if (status < 0) {
+			cxd->curbankx = 0xFF;
+			return status;
+		}
+		cxd->curbankx = Bank;
+	}
+	status = readregs(cxd, cxd->adrx, Address, pValue, count);
+	return status;
+}
+
+static int readregsx(struct cxd_state *cxd, u8 Bank,
+		     u8 Address, u8 *pValue, u16 count)
+{
+	int status;
+
+	mutex_lock(&cxd->mutex);
+	status = readregsx_unlocked(cxd, Bank, Address, pValue, count);
+	mutex_unlock(&cxd->mutex);
+	return status;
+}
+
+static int writeregsx_unlocked(struct cxd_state *cxd, u8 Bank,
+			       u8 Address, u8 *pValue, u16 count)
+{
+	int status = 0;
+
+	if (Bank != 0xFF && cxd->curbankx != Bank) {
+		status = writereg(cxd, cxd->adrx, 0, Bank);
+		if (status < 0) {
+			cxd->curbankx = 0xFF;
+			return status;
+		}
+		cxd->curbankx = Bank;
+	}
+	status = writeregs(cxd, cxd->adrx, Address, pValue, count);
+	return status;
+}
+
+static int writeregsx(struct cxd_state *cxd, u8 Bank, u8 Address,
+		      u8 *pValue, u16 count)
+{
+	int status;
+
+	mutex_lock(&cxd->mutex);
+	status = writeregsx_unlocked(cxd, Bank, Address, pValue, count);
+	mutex_unlock(&cxd->mutex);
+	return status;
+}
+
+static int writeregx(struct cxd_state *cxd, u8 Bank, u8 Address, u8 val)
+{
+	return writeregsx(cxd, Bank, Address, &val, 1);
+}
+
+static int writeregst_unlocked(struct cxd_state *cxd, u8 Bank,
+			       u8 Address, u8 *pValue, u16 count)
+{
+	int status = 0;
+
+	if (Bank != 0xFF && cxd->curbankt != Bank) {
+		status = writereg(cxd, cxd->adrt, 0, Bank);
+		if (status < 0) {
+			cxd->curbankt = 0xFF;
+			return status;
+		}
+		cxd->curbankt = Bank;
+	}
+	status = writeregs(cxd, cxd->adrt, Address, pValue, count);
+	return status;
+}
+
+static int writeregst(struct cxd_state *cxd, u8 Bank, u8 Address,
+		      u8 *pValue, u16 count)
+{
+	int status;
+
+	mutex_lock(&cxd->mutex);
+	status = writeregst_unlocked(cxd, Bank, Address, pValue, count);
+	mutex_unlock(&cxd->mutex);
+	return status;
+}
+
+static int writeregt(struct cxd_state *cxd, u8 Bank, u8 Address, u8 val)
+{
+	return writeregst(cxd, Bank, Address, &val, 1);
+}
+
+static int writebitsx(struct cxd_state *cxd, u8 Bank, u8 Address,
+		      u8 Value, u8 Mask)
+{
+	int status = 0;
+	u8 tmp;
+
+	mutex_lock(&cxd->mutex);
+	status = readregsx_unlocked(cxd, Bank, Address, &tmp, 1);
+	if (status < 0)
+		return status;
+	tmp = (tmp & ~Mask) | Value;
+	status = writeregsx_unlocked(cxd, Bank, Address, &tmp, 1);
+	mutex_unlock(&cxd->mutex);
+	return status;
+}
+
+static int writebitst(struct cxd_state *cxd, u8 Bank, u8 Address,
+		      u8 Value, u8 Mask)
+{
+	int status = 0;
+	u8 Tmp = 0x00;
+
+	mutex_lock(&cxd->mutex);
+	status = readregst_unlocked(cxd, Bank, Address, &Tmp, 1);
+	if (status < 0)
+		return status;
+	Tmp = (Tmp & ~Mask) | Value;
+	status = writeregst_unlocked(cxd, Bank, Address, &Tmp, 1);
+	mutex_unlock(&cxd->mutex);
+	return status;
+}
+
+static int freeze_regst(struct cxd_state *cxd)
+{
+	mutex_lock(&cxd->mutex);
+	return writereg(cxd, cxd->adrt, 1, 1);
+}
+
+static int unfreeze_regst(struct cxd_state *cxd)
+{
+	int status = 0;
+
+	status = writereg(cxd, cxd->adrt, 1, 0);
+	mutex_unlock(&cxd->mutex);
+	return status;
+}
+
+static inline u32 MulDiv32(u32 a, u32 b, u32 c)
+{
+	u64 tmp64;
+
+	tmp64 = (u64)a * (u64)b;
+	do_div(tmp64, c);
+
+	return (u32) tmp64;
+}
+
+/* TPSData[0] [7:6]  CNST[1:0] */
+/* TPSData[0] [5:3]  HIER[2:0] */
+/* TPSData[0] [2:0]  HRATE[2:0] */
+/* TPSData[1] [7:5]  LRATE[2:0] */
+/* TPSData[1] [4:3]  GI[1:0] */
+/* TPSData[1] [2:1]  MODE[1:0] */
+/* TPSData[2] [7:6]  FNUM[1:0] */
+/* TPSData[2] [5:0]  LENGTH_INDICATOR[5:0] */
+/* TPSData[3] [7:0]  CELLID[15:8] */
+/* TPSData[4] [7:0]  CELLID[7:0] */
+/* TPSData[5] [5:0]  RESERVE_EVEN[5:0] */
+/* TPSData[6] [5:0]  RESERVE_ODD[5:0] */
+
+static int read_tps(struct cxd_state *state, u8 *tps)
+{
+	if (state->last_status != FE_STATUS_FULL_LOCK)
+		return 0;
+
+	freeze_regst(state);
+	readregst_unlocked(state, 0x10, 0x2f, tps, 7);
+	unfreeze_regst(state);
+	return 0;
+}
+
+static void Active_to_Sleep(struct cxd_state *state)
+{
+	if (state->state <= Sleep)
+		return;
+
+	writeregt(state, 0x00, 0xC3, 0x01); /* Disable TS */
+	writeregt(state, 0x00, 0x80, 0x3F); /* Enable HighZ 1 */
+	writeregt(state, 0x00, 0x81, 0xFF); /* Enable HighZ 2 */
+	writeregx(state, 0x00, 0x18, 0x01); /* Disable ADC 4 */
+	writeregt(state, 0x00, 0x43, 0x0A); /* Disable ADC 2 */
+	writeregt(state, 0x00, 0x41, 0x0A); /* Disable ADC 1 */
+	writeregt(state, 0x00, 0x30, 0x00); /* Disable ADC Clock */
+	writeregt(state, 0x00, 0x2F, 0x00); /* Disable RF level Monitor */
+	writeregt(state, 0x00, 0x2C, 0x00); /* Disable Demod Clock */
+	state->state = Sleep;
+}
+
+static void ActiveT2_to_Sleep(struct cxd_state *state)
+{
+	if (state->state <= Sleep)
+		return;
+
+	writeregt(state, 0x00, 0xC3, 0x01); /* Disable TS */
+	writeregt(state, 0x00, 0x80, 0x3F); /* Enable HighZ 1 */
+	writeregt(state, 0x00, 0x81, 0xFF); /* Enable HighZ 2 */
+
+	writeregt(state, 0x13, 0x83, 0x40);
+	writeregt(state, 0x13, 0x86, 0x21);
+	writebitst(state, 0x13, 0x9E, 0x09, 0x0F);
+	writeregt(state, 0x13, 0x9F, 0xFB);
+
+	writeregx(state, 0x00, 0x18, 0x01); /* Disable ADC 4 */
+	writeregt(state, 0x00, 0x43, 0x0A); /* Disable ADC 2 */
+	writeregt(state, 0x00, 0x41, 0x0A); /* Disable ADC 1 */
+	writeregt(state, 0x00, 0x30, 0x00); /* Disable ADC Clock */
+	writeregt(state, 0x00, 0x2F, 0x00); /* Disable RF level Monitor */
+	writeregt(state, 0x00, 0x2C, 0x00); /* Disable Demod Clock */
+	state->state = Sleep;
+}
+
+static void ActiveC2_to_Sleep(struct cxd_state *state)
+{
+	if (state->state <= Sleep)
+		return;
+
+	writeregt(state, 0x00, 0xC3, 0x01); /* Disable TS */
+	writeregt(state, 0x00, 0x80, 0x3F); /* Enable HighZ 1 */
+	writeregt(state, 0x00, 0x81, 0xFF); /* Enable HighZ 2 */
+
+	writeregt(state, 0x20, 0xC2, 0x11);
+	writebitst(state, 0x25, 0x6A, 0x02, 0x03);
+	{
+		static u8 data[3] = { 0x07, 0x61, 0x36 };
+
+		writeregst(state, 0x25, 0x89, data, sizeof(data));
+	}
+	writebitst(state, 0x25, 0xCB, 0x05, 0x07);
+	{
+		static u8 data[4] = { 0x2E, 0xE0, 0x2E, 0xE0 };
+
+		writeregst(state, 0x25, 0xDC, data, sizeof(data));
+	}
+	writeregt(state, 0x25, 0xE2, 0x2F);
+	writeregt(state, 0x25, 0xE5, 0x2F);
+	writebitst(state, 0x27, 0x20, 0x00, 0x01);
+	writebitst(state, 0x27, 0x35, 0x00, 0x01);
+	writebitst(state, 0x27, 0xD9, 0x19, 0x3F);
+	writebitst(state, 0x2A, 0x78, 0x01, 0x07);
+	writeregt(state, 0x2A, 0x86, 0x08);
+	writeregt(state, 0x2A, 0x88, 0x14);
+	writebitst(state, 0x2B, 0x2B, 0x00, 0x1F);
+	{
+		u8 data[2] = { 0x75, 0x75 };
+
+		writeregst(state, 0x2D, 0x24, data, sizeof(data));
+	}
+
+	writeregx(state, 0x00, 0x18, 0x01); /* Disable ADC 4 */
+	writeregt(state, 0x00, 0x43, 0x0A); /* Disable ADC 2 */
+	writeregt(state, 0x00, 0x41, 0x0A); /* Disable ADC 1 */
+	writeregt(state, 0x00, 0x30, 0x00); /* Disable ADC Clock */
+	writeregt(state, 0x00, 0x2F, 0x00); /* Disable RF level Monitor */
+	writeregt(state, 0x00, 0x2C, 0x00); /* Disable Demod Clock */
+	state->state = Sleep;
+}
+
+static int ConfigureTS(struct cxd_state *state,
+		       enum demod_state newDemodState)
+{
+	int status = 0;
+	u8 OSERCKMODE = state->SerialMode ?  1 : 0;
+	u8 OSERDUTYMODE = state->SerialMode ?  1 : 0;
+	u8 OTSCKPERIOD = 8;
+	u8 OREG_CKSEL_TSIF = state->SerialMode ?
+		state->SerialClockFrequency : 0;
+
+	if (state->SerialMode && state->SerialClockFrequency >= 3) {
+		OSERCKMODE = 2;
+		OSERDUTYMODE = 2;
+		OTSCKPERIOD = 16;
+		OREG_CKSEL_TSIF = state->SerialClockFrequency - 3;
+	}
+	writebitst(state, 0x00, 0xC4, OSERCKMODE, 0x03); /* OSERCKMODE */
+	writebitst(state, 0x00, 0xD1, OSERDUTYMODE, 0x03); /* OSERDUTYMODE */
+	writeregt(state, 0x00, 0xD9, OTSCKPERIOD); /* OTSCKPERIOD */
+	writebitst(state, 0x00, 0x32, 0x00, 0x01); /* Disable TS IF */
+	/* OREG_CKSEL_TSIF */
+	writebitst(state, 0x00, 0x33, OREG_CKSEL_TSIF, 0x03);
+	writebitst(state, 0x00, 0x32, 0x01, 0x01); /* Enable TS IF */
+
+	if (newDemodState == ActiveT)
+		writebitst(state, 0x10, 0x66, 0x01, 0x01);
+	if (newDemodState == ActiveC)
+		writebitst(state, 0x40, 0x66, 0x01, 0x01);
+
+	return status;
+}
+
+static void BandSettingT(struct cxd_state *state, u32 iffreq)
+{
+	u8 IF_data[3] = { (iffreq >> 16) & 0xff,
+			  (iffreq >> 8) & 0xff, iffreq & 0xff};
+
+	switch (state->bw) {
+	default:
+	case 8:
+	{
+		u8 TR_data[] = { 0x11, 0xF0, 0x00, 0x00, 0x00 };
+		u8 CL_data[] = { 0x01, 0xE0 };
+		u8 NF_data[] = { 0x01, 0x02 };
+
+		writeregst(state, 0x10, 0x9F, TR_data, sizeof(TR_data));
+		writeregst(state, 0x10, 0xB6, IF_data, sizeof(IF_data));
+		writebitst(state, 0x10, 0xD7, 0x00, 0x07);
+		writeregst(state, 0x10, 0xD9, CL_data, sizeof(CL_data));
+		writeregst(state, 0x17, 0x38, NF_data, sizeof(NF_data));
+		break;
+	}
+	case 7:
+	{
+		u8 TR_data[] = { 0x14, 0x80, 0x00, 0x00, 0x00 };
+		u8 CL_data[] = { 0x12, 0xF8 };
+		u8 NF_data[] = { 0x00, 0x03 };
+
+		writeregst(state, 0x10, 0x9F, TR_data, sizeof(TR_data));
+		writeregst(state, 0x10, 0xB6, IF_data, sizeof(IF_data));
+		writebitst(state, 0x10, 0xD7, 0x02, 0x07);
+		writeregst(state, 0x10, 0xD9, CL_data, sizeof(CL_data));
+		writeregst(state, 0x17, 0x38, NF_data, sizeof(NF_data));
+		break;
+	}
+	case 6:
+	{
+		u8 TR_data[] = { 0x17, 0xEA, 0xAA, 0xAA, 0xAA };
+		u8 CL_data[] = { 0x1F, 0xDC };
+		u8 NF_data[] = { 0x00, 0x03 };
+
+		writeregst(state, 0x10, 0x9F, TR_data, sizeof(TR_data));
+		writeregst(state, 0x10, 0xB6, IF_data, sizeof(IF_data));
+		writebitst(state, 0x10, 0xD7, 0x04, 0x07);
+		writeregst(state, 0x10, 0xD9, CL_data, sizeof(CL_data));
+		writeregst(state, 0x17, 0x38, NF_data, sizeof(NF_data));
+		break;
+	}
+	case 5:
+	{
+		static u8 TR_data[] = { 0x1C, 0xB3, 0x33, 0x33, 0x33 };
+		static u8 CL_data[] = { 0x26, 0x3C };
+		static u8 NF_data[] = { 0x00, 0x03 };
+
+		writeregst(state, 0x10, 0x9F, TR_data, sizeof(TR_data));
+		writeregst(state, 0x10, 0xB6, IF_data, sizeof(IF_data));
+		writebitst(state, 0x10, 0xD7, 0x06, 0x07);
+		writeregst(state, 0x10, 0xD9, CL_data, sizeof(CL_data));
+		writeregst(state, 0x17, 0x38, NF_data, sizeof(NF_data));
+		break;
+	}
+	}
+}
+
+static void Sleep_to_ActiveT(struct cxd_state *state, u32 iffreq)
+{
+	ConfigureTS(state, ActiveT);
+	writeregx(state, 0x00, 0x17, 0x01);   /* Mode */
+	writeregt(state, 0x00, 0x2C, 0x01);   /* Demod Clock */
+	writeregt(state, 0x00, 0x2F, 0x00);   /* Disable RF Monitor */
+	writeregt(state, 0x00, 0x30, 0x00);   /* Enable ADC Clock */
+	writeregt(state, 0x00, 0x41, 0x1A);   /* Enable ADC1 */
+	{
+		u8 data[2] = { 0x09, 0x54 };  /* 20.5 MHz */
+		/*u8 data[2] = { 0x0A, 0xD4 }; */  /* 41 MHz */
+
+		writeregst(state, 0x00, 0x43, data, 2);   /* Enable ADC 2+3 */
+	}
+	writeregx(state, 0x00, 0x18, 0x00);   /* Enable ADC 4 */
+
+	writebitst(state, 0x10, 0xD2, 0x0C, 0x1F); /* IF AGC Gain */
+	writeregt(state, 0x11, 0x6A, 0x48); /* BB AGC Target Level */
+
+	writebitst(state, 0x10, 0xA5, 0x00, 0x01); /* ASCOT Off */
+
+	writebitst(state, 0x18, 0x36, 0x40, 0x07); /* Pre RS Monitoring */
+	writebitst(state, 0x18, 0x30, 0x01, 0x01); /* FEC Autorecover */
+	writebitst(state, 0x18, 0x31, 0x01, 0x01); /* FEC Autorecover */
+
+	writebitst(state, 0x00, 0xCE, 0x01, 0x01); /* TSIF ONOPARITY */
+	writebitst(state, 0x00, 0xCF, 0x01, 0x01);/*TSIF ONOPARITY_MANUAL_ON*/
+
+	BandSettingT(state, iffreq);
+
+	writebitst(state, 0x10, 0x60, 0x11, 0x1f); /* BER scaling */
+
+	writeregt(state, 0x00, 0x80, 0x28); /* Disable HiZ Setting 1 */
+	writeregt(state, 0x00, 0x81, 0x00); /* Disable HiZ Setting 2 */
+}
+
+static void BandSettingT2(struct cxd_state *state, u32 iffreq)
+{
+	u8 IF_data[3] = {(iffreq >> 16) & 0xff, (iffreq >> 8) & 0xff,
+			 iffreq & 0xff};
+
+	switch (state->bw) {
+	default:
+	case 8:
+	{
+		u8 TR_data[] = { 0x11, 0xF0, 0x00, 0x00, 0x00 };
+
+		/* Timing recovery */
+		writeregst(state, 0x20, 0x9F, TR_data, sizeof(TR_data));
+		/* Add EQ Optimisation for tuner here */
+		writeregst(state, 0x10, 0xB6, IF_data, sizeof(IF_data));
+		/* System Bandwidth */
+		writebitst(state, 0x10, 0xD7, 0x00, 0x07);
+	}
+	break;
+	case 7:
+	{
+		u8 TR_data[] = { 0x14, 0x80, 0x00, 0x00, 0x00 };
+
+		writeregst(state, 0x20, 0x9F, TR_data, sizeof(TR_data));
+		writeregst(state, 0x10, 0xB6, IF_data, sizeof(IF_data));
+		writebitst(state, 0x10, 0xD7, 0x02, 0x07);
+	}
+	break;
+	case 6:
+	{
+		u8 TR_data[] = { 0x17, 0xEA, 0xAA, 0xAA, 0xAA };
+
+		writeregst(state, 0x20, 0x9F, TR_data, sizeof(TR_data));
+		writeregst(state, 0x10, 0xB6, IF_data, sizeof(IF_data));
+		writebitst(state, 0x10, 0xD7, 0x04, 0x07);
+	}
+	break;
+	case 5:
+	{
+		u8 TR_data[] = { 0x1C, 0xB3, 0x33, 0x33, 0x33 };
+
+		writeregst(state, 0x20, 0x9F, TR_data, sizeof(TR_data));
+		writeregst(state, 0x10, 0xB6, IF_data, sizeof(IF_data));
+		writebitst(state, 0x10, 0xD7, 0x06, 0x07);
+	}
+	break;
+	case 2: /* 1.7 MHz */
+	{
+		u8 TR_data[] = { 0x58, 0xE2, 0xAF, 0xE0, 0xBC };
+
+		writeregst(state, 0x20, 0x9F, TR_data, sizeof(TR_data));
+		writeregst(state, 0x10, 0xB6, IF_data, sizeof(IF_data));
+		writebitst(state, 0x10, 0xD7, 0x03, 0x07);
+	}
+	break;
+	}
+}
+
+
+static void Sleep_to_ActiveT2(struct cxd_state *state, u32 iffreq)
+{
+	ConfigureTS(state, ActiveT2);
+
+	writeregx(state, 0x00, 0x17, 0x02);   /* Mode */
+	writeregt(state, 0x00, 0x2C, 0x01);   /* Demod Clock */
+	writeregt(state, 0x00, 0x2F, 0x00);   /* Disable RF Monitor */
+	writeregt(state, 0x00, 0x30, 0x00);   /* Enable ADC Clock */
+	writeregt(state, 0x00, 0x41, 0x1A);   /* Enable ADC1 */
+
+	{
+		u8 data[2] = { 0x09, 0x54 };  /* 20.5 MHz */
+		/*u8 data[2] = { 0x0A, 0xD4 }; */  /* 41 MHz */
+
+		writeregst(state, 0x00, 0x43, data, 2);   /* Enable ADC 2+3 */
+	}
+	writeregx(state, 0x00, 0x18, 0x00);   /* Enable ADC 4 */
+
+	writebitst(state, 0x10, 0xD2, 0x0C, 0x1F); /* IFAGC  coarse gain */
+	writeregt(state, 0x11, 0x6A, 0x50); /* BB AGC Target Level */
+	writebitst(state, 0x10, 0xA5, 0x00, 0x01); /* ASCOT Off */
+
+	writeregt(state, 0x20, 0x8B, 0x3C); /* SNR Good count */
+	writebitst(state, 0x2B, 0x76, 0x20, 0x70); /* Noise Gain ACQ */
+
+	writebitst(state, 0x00, 0xCE, 0x01, 0x01); /* TSIF ONOPARITY */
+	writebitst(state, 0x00, 0xCF, 0x01, 0x01);/*TSIF ONOPARITY_MANUAL_ON*/
+
+	writeregt(state, 0x13, 0x83, 0x10); /* T2 Inital settings */
+	writeregt(state, 0x13, 0x86, 0x34);
+	writebitst(state, 0x13, 0x9E, 0x09, 0x0F);
+	writeregt(state, 0x13, 0x9F, 0xD8);
+
+	BandSettingT2(state, iffreq);
+
+	writebitst(state, 0x20, 0x72, 0x08, 0x0f); /* BER scaling */
+
+	writeregt(state, 0x00, 0x80, 0x28); /* Disable HiZ Setting 1 */
+	writeregt(state, 0x00, 0x81, 0x00); /* Disable HiZ Setting 2 */
+}
+
+
+static void BandSettingC(struct cxd_state *state, u32 iffreq)
+{
+	u8 data[3];
+
+	data[0] = (iffreq >> 16) & 0xFF;
+	data[1] = (iffreq >>  8) & 0xFF;
+	data[2] = (iffreq) & 0xFF;
+	writeregst(state, 0x10, 0xB6, data, 3);
+}
+
+static void Sleep_to_ActiveC(struct cxd_state *state, u32 iffreq)
+{
+	ConfigureTS(state, ActiveC);
+
+	writeregx(state, 0x00, 0x17, 0x04);   /* Mode */
+	writeregt(state, 0x00, 0x2C, 0x01);   /* Demod Clock */
+	writeregt(state, 0x00, 0x2F, 0x00);   /* Disable RF Monitor */
+	writeregt(state, 0x00, 0x30, 0x00);   /* Enable ADC Clock */
+	writeregt(state, 0x00, 0x41, 0x1A);   /* Enable ADC1 */
+
+	{
+		u8 data[2] = { 0x09, 0x54 };  /* 20.5 MHz */
+		/*u8 data[2] = { 0x0A, 0xD4 }; */  /* 41 MHz */
+
+		writeregst(state, 0x00, 0x43, data, 2);   /* Enable ADC 2+3 */
+	}
+	writeregx(state, 0x00, 0x18, 0x00);   /* Enable ADC 4 */
+
+	writebitst(state, 0x10, 0xD2, 0x09, 0x1F); /* IF AGC Gain */
+	writeregt(state, 0x11, 0x6A, 0x48); /* BB AGC Target Level */
+	writebitst(state, 0x10, 0xA5, 0x00, 0x01); /* ASCOT Off */
+
+	writebitst(state, 0x40, 0xC3, 0x00, 0x04); /* OREG_BNDET_EN_64 */
+
+	writebitst(state, 0x00, 0xCE, 0x01, 0x01); /* TSIF ONOPARITY */
+	writebitst(state, 0x00, 0xCF, 0x01, 0x01);/*TSIF ONOPARITY_MANUAL_ON*/
+
+	BandSettingC(state, iffreq);
+
+	writebitst(state, 0x40, 0x60, 0x11, 0x1f); /* BER scaling */
+
+	writeregt(state, 0x00, 0x80, 0x28); /* Disable HiZ Setting 1 */
+	writeregt(state, 0x00, 0x81, 0x00); /* Disable HiZ Setting 2 */
+}
+
+static void BandSettingC2(struct cxd_state *state, u32 iffreq)
+{
+	u8 IF_data[3] = { (iffreq >> 16) & 0xff,
+			  (iffreq >> 8) & 0xff, iffreq & 0xff};
+
+	switch (state->bw) {
+	default:
+	case 8:
+	{
+		u8 TR_data[] = { 0x11, 0xF0, 0x00, 0x00, 0x00 };
+		u8 data[2] = { 0x11, 0x9E };
+
+		writeregst(state, 0x20, 0x9F, TR_data, sizeof(TR_data));
+		writeregst(state, 0x10, 0xB6, IF_data, sizeof(IF_data));
+		writebitst(state, 0x10, 0xD7, 0x00, 0x07);
+		writeregst(state, 0x50, 0xEC, data, sizeof(data));
+		writeregt(state, 0x50, 0xEF, 0x11);
+		writeregt(state, 0x50, 0xF1, 0x9E);
+	}
+	break;
+	case 6:
+	{
+		u8 TR_data[] = { 0x17, 0xEA, 0xAA, 0xAA, 0xAA };
+		u8 data[2] = { 0x17, 0x70 };
+
+		writeregst(state, 0x20, 0x9F, TR_data, sizeof(TR_data));
+		writeregst(state, 0x10, 0xB6, IF_data, sizeof(IF_data));
+		writebitst(state, 0x10, 0xD7, 0x04, 0x07);
+		writeregst(state, 0x50, 0xEC, data, sizeof(data));
+		writeregt(state, 0x50, 0xEF, 0x17);
+		writeregt(state, 0x50, 0xF1, 0x70);
+	}
+	break;
+	}
+}
+
+static void Sleep_to_ActiveC2(struct cxd_state *state, u32 iffreq)
+{
+	ConfigureTS(state, ActiveC2);
+
+	writeregx(state, 0x00, 0x17, 0x05);   /* Mode */
+	writeregt(state, 0x00, 0x2C, 0x01);   /* Demod Clock */
+	writeregt(state, 0x00, 0x2F, 0x00);   /* Disable RF Monitor */
+	writeregt(state, 0x00, 0x30, 0x00);   /* Enable ADC Clock */
+	writeregt(state, 0x00, 0x41, 0x1A);   /* Enable ADC1 */
+
+	{
+		u8 data[2] = { 0x09, 0x54 };  /* 20.5 MHz */
+		/*u8 data[2] = { 0x0A, 0xD4 }; */  /* 41 MHz */
+
+		writeregst(state, 0x00, 0x43, data, sizeof(data));
+		/* Enable ADC 2+3 */
+	}
+	writeregx(state, 0x00, 0x18, 0x00);   /* Enable ADC 4 */
+
+	writebitst(state, 0x10, 0xD2, 0x0C, 0x1F); /* IFAGC  coarse gain */
+	writeregt(state, 0x11, 0x6A, 0x50); /* BB AGC Target Level */
+	writebitst(state, 0x10, 0xA5, 0x00, 0x01); /* ASCOT Off */
+
+	writebitst(state, 0x00, 0xCE, 0x01, 0x01); /* TSIF ONOPARITY */
+	writebitst(state, 0x00, 0xCF, 0x01, 0x01);/*TSIF ONOPARITY_MANUAL_ON*/
+
+	writeregt(state, 0x20, 0xC2, 0x00);
+	writebitst(state, 0x25, 0x6A, 0x00, 0x03);
+	{
+		u8 data[3] = { 0x0C, 0xD1, 0x40 };
+
+		writeregst(state, 0x25, 0x89, data, sizeof(data));
+	}
+	writebitst(state, 0x25, 0xCB, 0x01, 0x07);
+	{
+		u8 data[4] = { 0x7B, 0x00, 0x7B, 0x00 };
+
+		writeregst(state, 0x25, 0xDC, data, sizeof(data));
+	}
+	writeregt(state, 0x25, 0xE2, 0x30);
+	writeregt(state, 0x25, 0xE5, 0x30);
+	writebitst(state, 0x27, 0x20, 0x01, 0x01);
+	writebitst(state, 0x27, 0x35, 0x01, 0x01);
+	writebitst(state, 0x27, 0xD9, 0x18, 0x3F);
+	writebitst(state, 0x2A, 0x78, 0x00, 0x07);
+	writeregt(state, 0x2A, 0x86, 0x20);
+	writeregt(state, 0x2A, 0x88, 0x32);
+	writebitst(state, 0x2B, 0x2B, 0x10, 0x1F);
+	{
+		u8 data[2] = { 0x01, 0x01 };
+
+		writeregst(state, 0x2D, 0x24, data, sizeof(data));
+	}
+
+	BandSettingC2(state, iffreq);
+
+	writeregt(state, 0x00, 0x80, 0x28); /* Disable HiZ Setting 1 */
+	writeregt(state, 0x00, 0x81, 0x00); /* Disable HiZ Setting 2 */
+}
+
+
+static void BandSettingIT(struct cxd_state *state, u32 iffreq)
+{
+	u8 IF_data[3] = { (iffreq >> 16) & 0xff,
+			  (iffreq >> 8) & 0xff, iffreq & 0xff};
+
+	switch (state->bw) {
+	default:
+	case 8:
+	{
+		u8 TR_data[] = { 0x0F, 0x22, 0x80, 0x00, 0x00 }; /* 20.5/41 */
+		u8 CL_data[] = { 0x15, 0xA8 };
+
+		/*u8 TR_data[] = { 0x11, 0xB8, 0x00, 0x00, 0x00 }; */ /* 24 */
+		writeregst(state, 0x10, 0x9F, TR_data, sizeof(TR_data));
+		/* Add EQ Optimisation for tuner here */
+		writeregst(state, 0x10, 0xB6, IF_data, sizeof(IF_data));
+
+		writeregt(state, 0x10, 0xD7, 0x00);   /* System Bandwidth */
+		/*u8 CL_data[] = { 0x13, 0xFC }; */
+		writeregst(state, 0x10, 0xD9, CL_data, sizeof(CL_data));
+	}
+	break;
+	case 7:
+	{
+		u8 TR_data[] = { 0x11, 0x4c, 0x00, 0x00, 0x00 };
+		u8 CL_data[] = { 0x1B, 0x5D };
+
+		/*u8 TR_data[] = { 0x14, 0x40, 0x00, 0x00, 0x00 }; */
+		writeregst(state, 0x10, 0x9F, TR_data, sizeof(TR_data));
+		writeregst(state, 0x10, 0xB6, IF_data, sizeof(IF_data));
+
+		writeregt(state, 0x10, 0xD7, 0x02);
+		/*static u8 CL_data[] = { 0x1A, 0xFA };*/
+		writeregst(state, 0x10, 0xD9, CL_data, sizeof(CL_data));
+	}
+	break;
+	case 6:
+	{
+		u8 TR_data[] = { 0x14, 0x2E, 0x00, 0x00, 0x00 };
+		u8 CL_data[] = { 0x1F, 0xEC };
+		/*u8 TR_data[] = { 0x17, 0xA0, 0x00, 0x00, 0x00 }; */
+		/*u8 CL_data[] = { 0x1F, 0x79 }; */
+
+		writeregst(state, 0x10, 0x9F, TR_data, sizeof(TR_data));
+		writeregst(state, 0x10, 0xB6, IF_data, sizeof(IF_data));
+		writeregt(state, 0x10, 0xD7, 0x04);
+		writeregst(state, 0x10, 0xD9, CL_data, sizeof(CL_data));
+	}
+	break;
+	}
+}
+
+static void Sleep_to_ActiveIT(struct cxd_state *state, u32 iffreq)
+{
+	u8 data2[3] = { 0xB9, 0xBA, 0x63 };  /* 20.5/41 MHz */
+	/*u8 data2[3] = { 0xB7,0x1B,0x00 }; */  /* 24 MHz */
+	u8 TSIF_data[2] = { 0x61, 0x60 } ; /* 20.5/41 MHz */
+	/*u8 TSIF_data[2] = { 0x60,0x00 } ; */ /* 24 MHz */
+
+
+	ConfigureTS(state, ActiveIT);
+
+	/* writeregx(state, 0x00,0x17,0x01); */  /* 2838 has only one Mode */
+	writeregt(state, 0x00, 0x2C, 0x01);   /* Demod Clock */
+	writeregt(state, 0x00, 0x2F, 0x00);   /* Disable RF Monitor */
+	writeregt(state, 0x00, 0x30, 0x00);   /* Enable ADC Clock */
+	writeregt(state, 0x00, 0x41, 0x1A);   /* Enable ADC1 */
+
+	{
+		u8 data[2] = { 0x09, 0x54 };  /* 20.5 MHz, 24 MHz */
+		/*u8 data[2] = { 0x0A, 0xD4 }; */  /* 41 MHz */
+
+		writeregst(state, 0x00, 0x43, data, 2);   /* Enable ADC 2+3 */
+	}
+	writeregx(state, 0x00, 0x18, 0x00);   /* Enable ADC 4 */
+
+	writeregst(state, 0x60, 0xA8, data2, sizeof(data2));
+
+	writeregst(state, 0x10, 0xBF, TSIF_data, sizeof(TSIF_data));
+
+	writeregt(state, 0x10, 0xE2, 0xCE); /* OREG_PNC_DISABLE */
+	writebitst(state, 0x10, 0xA5, 0x00, 0x01); /* ASCOT Off */
+
+	BandSettingIT(state, iffreq);
+
+	writeregt(state, 0x00, 0x80, 0x28); /* Disable HiZ Setting 1 */
+	writeregt(state, 0x00, 0x81, 0x00); /* Disable HiZ Setting 2 */
+}
+
+static void T2_SetParameters(struct cxd_state *state)
+{
+	u8 Profile = 0x01;    /* Profile Base */
+	u8 notT2time = 12;    /* early unlock detection time */
+
+	if (state->T2Profile == T2P_Lite) {
+		Profile = 0x05;
+		notT2time = 40;
+	}
+
+	if (state->plp != 0xffffffff) {
+		state->T2Profile = ((state->plp & 0x100) != 0) ?
+			T2P_Lite : T2P_Base;
+		writeregt(state, 0x23, 0xAF, state->plp);
+		writeregt(state, 0x23, 0xAD, 0x01);
+	} else {
+		state->T2Profile = T2P_Base;
+		writeregt(state, 0x23, 0xAD, 0x00);
+	}
+
+	writebitst(state, 0x2E, 0x10, Profile, 0x07);
+	writeregt(state, 0x2B, 0x19, notT2time);
+}
+
+static void C2_ReleasePreset(struct cxd_state *state)
+{
+	{
+		static u8 data[2] = { 0x02, 0x80};
+
+		writeregst(state, 0x27, 0xF4, data, sizeof(data));
+	}
+	writebitst(state, 0x27, 0x51, 0x40, 0xF0);
+	writebitst(state, 0x27, 0x73, 0x07, 0x0F);
+	writebitst(state, 0x27, 0x74, 0x19, 0x3F);
+	writebitst(state, 0x27, 0x75, 0x19, 0x3F);
+	writebitst(state, 0x27, 0x76, 0x19, 0x3F);
+	if (state->bw == 6) {
+		static u8 data[5] = { 0x17, 0xEA, 0xAA, 0xAA, 0xAA};
+
+		writeregst(state, 0x20, 0x9F, data, sizeof(data));
+	} else {
+		static u8 data[5] = { 0x11, 0xF0, 0x00, 0x00, 0x00};
+
+		writeregst(state, 0x20, 0x9F, data, sizeof(data));
+	}
+	writebitst(state, 0x27, 0xC9, 0x07, 0x07);
+	writebitst(state, 0x20, 0xC2, 0x11, 0x33);
+	{
+		static u8 data[10] = { 0x16, 0xF0, 0x2B, 0xD8,
+				       0x16, 0x16, 0xF0, 0x2C, 0xD8, 0x16 };
+
+		writeregst(state, 0x2A, 0x20, data, sizeof(data));
+	}
+	{
+		static u8 data[4] = { 0x00, 0x00, 0x00, 0x00 };
+
+		writeregst(state, 0x50, 0x6B, data, sizeof(data));
+	}
+	writebitst(state, 0x50, 0x6F, 0x00, 0x40); /* Disable Preset */
+}
+
+static void C2_DemodSetting2(struct cxd_state *state)
+{
+	u8 data[6];
+	u32 TunePosition =
+		state->frontend.dtv_property_cache.frequency / 1000;
+
+	if (state->bw == 6)
+		TunePosition = ((TunePosition * 1792) / 3) / 1000;
+	else
+		TunePosition = (TunePosition * 448) / 1000;
+
+	TunePosition = ((TunePosition + 6) / 12) * 12;
+
+	pr_info("TunePosition = %u\n", TunePosition);
+
+	data[0] = ((TunePosition >> 16) & 0xFF);
+	data[1] = ((TunePosition >>  8) & 0xFF);
+	data[2] = (TunePosition & 0xFF);
+	data[3] = 0x02;
+	data[4] = (state->DataSliceID & 0xFF);
+	data[5] = (state->plp & 0xFF);
+	writeregst(state, 0x50, 0x7A, data, sizeof(data));
+	writebitst(state, 0x50, 0x87, 0x01, 0x01); /* Preset Clear */
+}
+
+static void Stop(struct cxd_state *state)
+{
+
+	writeregt(state, 0x00, 0xC3, 0x01); /* Disable TS */
+}
+
+static void ShutDown(struct cxd_state *state)
+{
+	switch (state->state) {
+	case ActiveT2:
+		ActiveT2_to_Sleep(state);
+		break;
+	case ActiveC2:
+		ActiveC2_to_Sleep(state);
+		break;
+	default:
+		Active_to_Sleep(state);
+		break;
+	}
+}
+
+static int gate_ctrl(struct dvb_frontend *fe, int enable)
+{
+	struct cxd_state *state = fe->demodulator_priv;
+
+	return writebitsx(state, 0xFF, 0x08, enable ? 0x01 : 0x00, 0x01);
+}
+
+static void release(struct dvb_frontend *fe)
+{
+	struct cxd_state *state = fe->demodulator_priv;
+
+	Stop(state);
+	ShutDown(state);
+	kfree(state);
+}
+
+static int sleep(struct dvb_frontend *fe)
+{
+	struct cxd_state *state = fe->demodulator_priv;
+
+	Stop(state);
+	ShutDown(state);
+	return 0;
+}
+
+static int Start(struct cxd_state *state, u32 IntermediateFrequency)
+{
+	enum demod_state newDemodState = Unknown;
+	u32 iffreq;
+
+	if (state->state < Sleep)
+		return -EINVAL;
+
+	iffreq = MulDiv32(IntermediateFrequency, 16777216, 41000000);
+
+	switch (state->delsys) {
+	case SYS_DVBT:
+		if (state->type == CXD2838)
+			return -EINVAL;
+		newDemodState = ActiveT;
+		break;
+	case SYS_DVBT2:
+		if (state->type == CXD2838)
+			return -EINVAL;
+		newDemodState = ActiveT2;
+		break;
+	case SYS_DVBC_ANNEX_A:
+		if (state->type == CXD2838)
+			return -EINVAL;
+		newDemodState = ActiveC;
+		break;
+	case SYS_ISDBT:
+		if (state->type != CXD2838)
+			return -EINVAL;
+		newDemodState = ActiveIT;
+		break;
+	case SYS_DVBC2:
+		if (state->type != CXD2843)
+			return -EINVAL;
+		newDemodState = ActiveC2;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	state->LockTimeout = 0;
+	state->TSLockTimeout = 0;
+	state->L1PostTimeout = 0;
+	state->last_status = 0;
+	state->FirstTimeLock = 1;
+	state->LastBERNominator = 0;
+	state->LastBERDenominator = 1;
+	state->BERScaleMax = 19;
+
+	if (state->state == newDemodState) {
+		writeregt(state, 0x00, 0xC3, 0x01);   /* Disable TS Output */
+		switch (newDemodState) {
+		case ActiveT:
+			/* Stick with HP ( 0x01 = LP ) */
+			writeregt(state, 0x10, 0x67, 0x00);
+			BandSettingT(state, iffreq);
+			state->BERScaleMax = 18;
+			break;
+		case ActiveT2:
+			T2_SetParameters(state);
+			BandSettingT2(state, iffreq);
+			state->BERScaleMax = 12;
+			break;
+		case ActiveC:
+			BandSettingC(state, iffreq);
+			state->BERScaleMax = 19;
+			break;
+		case ActiveC2:
+			BandSettingC2(state, iffreq);
+			C2_ReleasePreset(state);
+			C2_DemodSetting2(state);
+			break;
+		case ActiveIT:
+			BandSettingIT(state, iffreq);
+			break;
+		default:
+			break;
+		}
+	} else {
+		if (state->state > Sleep) {
+			switch (state->state) {
+			case ActiveT2:
+				ActiveT2_to_Sleep(state);
+				break;
+			case ActiveC2:
+				ActiveC2_to_Sleep(state);
+				break;
+			default:
+				Active_to_Sleep(state);
+				break;
+			}
+		}
+		switch (newDemodState) {
+		case ActiveT:
+			/* Stick with HP ( 0x01 = LP ) */
+			writeregt(state, 0x10, 0x67, 0x00);
+			Sleep_to_ActiveT(state, iffreq);
+			state->BERScaleMax = 18;
+			break;
+		case ActiveT2:
+			T2_SetParameters(state);
+			Sleep_to_ActiveT2(state, iffreq);
+			state->BERScaleMax = 12;
+			break;
+		case ActiveC:
+			Sleep_to_ActiveC(state, iffreq);
+			state->BERScaleMax = 19;
+			break;
+		case ActiveC2:
+			Sleep_to_ActiveC2(state, iffreq);
+			C2_ReleasePreset(state);
+			C2_DemodSetting2(state);
+			break;
+		case ActiveIT:
+			Sleep_to_ActiveIT(state, iffreq);
+			break;
+		default:
+			break;
+		}
+	}
+	state->state = newDemodState;
+	writeregt(state, 0x00, 0xFE, 0x01);   /* SW Reset */
+	writeregt(state, 0x00, 0xC3, 0x00);   /* Enable TS Output */
+
+	return 0;
+}
+
+static int set_parameters(struct dvb_frontend *fe)
+{
+	int stat;
+	struct cxd_state *state = fe->demodulator_priv;
+	u32 IF;
+
+	switch (fe->dtv_property_cache.delivery_system) {
+	case SYS_DVBC_ANNEX_A:
+	case SYS_DVBC2:
+	case SYS_DVBT:
+	case SYS_DVBT2:
+	case SYS_ISDBT:
+		state->delsys = fe->dtv_property_cache.delivery_system;
+		break;
+	default:
+		return -EINVAL;
+	}
+	if (fe->ops.tuner_ops.set_params)
+		fe->ops.tuner_ops.set_params(fe);
+	state->bandwidth = fe->dtv_property_cache.bandwidth_hz;
+	state->bw = (fe->dtv_property_cache.bandwidth_hz + 999999) / 1000000;
+	if (fe->dtv_property_cache.stream_id == 0xffffffff) {
+		state->DataSliceID = 0xffffffff;
+		state->plp = 0xffffffff;
+	} else {
+		state->DataSliceID = (fe->dtv_property_cache.stream_id >> 8)
+			& 0xff;
+		state->plp = fe->dtv_property_cache.stream_id & 0xff;
+	}
+	/* printk("PLP = %08x, bw = %u\n", state->plp, state->bw); */
+	if (fe->ops.tuner_ops.get_if_frequency)
+		fe->ops.tuner_ops.get_if_frequency(fe, &IF);
+	stat = Start(state, IF);
+	return stat;
+}
+
+
+static void init(struct cxd_state *state)
+{
+	u8 data[2] = {0x00, 0x00}; /* 20.5 MHz */
+
+	state->delsys = SYS_UNDEFINED;
+	state->state  = Unknown;
+
+	writeregx(state, 0xFF, 0x02, 0x00);
+	usleep_range(4000, 5000);
+	writeregx(state, 0x00, 0x15, 0x01);
+	if (state->type != CXD2838)
+		writeregx(state, 0x00, 0x17, 0x01);
+	usleep_range(4000, 5000);
+
+	writeregx(state, 0x00, 0x10, 0x01);
+
+	writeregsx(state, 0x00, 0x13, data, 2);
+	writeregx(state, 0x00, 0x15, 0x00);
+	usleep_range(3000, 4000);
+	writeregx(state, 0x00, 0x10, 0x00);
+	usleep_range(2000, 3000);
+
+	state->curbankx = 0xFF;
+	state->curbankt = 0xFF;
+
+	writeregt(state, 0x00, 0x43, 0x0A);
+	writeregt(state, 0x00, 0x41, 0x0A);
+	if (state->type == CXD2838)
+		writeregt(state, 0x60, 0x5A, 0x00);
+
+	writebitst(state, 0x10, 0xCB, 0x00, 0x40);
+	writeregt(state, 0x10, 0xCD, state->IF_FS);
+
+	writebitst(state, 0x00, 0xC4, state->SerialMode ? 0x80 : 0x00, 0x98);
+	writebitst(state, 0x00, 0xC5, 0x01, 0x07);
+	writebitst(state, 0x00, 0xCB, 0x00, 0x01);
+	writebitst(state, 0x00, 0xC6, 0x00, 0x1D);
+	writebitst(state, 0x00, 0xC8, 0x01, 0x1D);
+	writebitst(state, 0x00, 0xC9, 0x00, 0x1D);
+	writebitst(state, 0x00, 0x83, 0x00, 0x07);
+	writeregt(state, 0x00, 0x84, 0x00);
+	writebitst(state, 0x00, 0xD3,
+		   (state->type == CXD2838) ? 0x01 : 0x00, 0x01);
+	writebitst(state, 0x00, 0xDE, 0x00, 0x01);
+
+	state->state = Sleep;
+}
+
+
+static void init_state(struct cxd_state *state, struct cxd2843_cfg *cfg)
+{
+	state->adrt = cfg->adr;
+	state->adrx = cfg->adr + 0x02;
+	state->curbankt = 0xff;
+	state->curbankx = 0xff;
+	mutex_init(&state->mutex);
+
+	state->SerialMode = cfg->parallel ? 0 : 1;
+	state->ContinuousClock = 1;
+	state->SerialClockFrequency =
+		(cfg->ts_clock >= 1 && cfg->ts_clock <= 5) ?
+		cfg->ts_clock :  1; /* 1 = fastest (82 MBit/s), 5 = slowest */
+	/* IF Fullscale 0x50 = 1.4V, 0x39 = 1V, 0x28 = 0.7V */
+	state->IF_FS = 0x50;
+}
+
+static int read_status(struct dvb_frontend *fe, enum fe_status *status)
+{
+	struct cxd_state *state = fe->demodulator_priv;
+	u8 rdata;
+
+	*status = 0;
+	switch (state->state) {
+	case ActiveC:
+		readregst(state, 0x40, 0x88, &rdata, 1);
+		if (rdata & 0x02)
+			break;
+		if (rdata & 0x01) {
+			*status |= (FE_HAS_SIGNAL
+				| FE_HAS_CARRIER
+				| FE_HAS_VITERBI);
+			readregst(state, 0x40, 0x10, &rdata, 1);
+			if (rdata & 0x20)
+				*status |= (FE_HAS_SIGNAL
+					| FE_HAS_CARRIER
+					| FE_HAS_VITERBI
+					| FE_HAS_SYNC
+					| FE_HAS_LOCK);
+		}
+		break;
+	case ActiveT:
+		readregst(state, 0x10, 0x10, &rdata, 1);
+		if (rdata & 0x10)
+			break;
+		if ((rdata & 0x07) == 0x06) {
+			*status |= (FE_HAS_SIGNAL
+				| FE_HAS_CARRIER
+				| FE_HAS_VITERBI);
+			if (rdata & 0x20)
+				*status |= (FE_HAS_SIGNAL
+					| FE_HAS_CARRIER
+					| FE_HAS_VITERBI
+					| FE_HAS_SYNC
+					| FE_HAS_LOCK);
+		}
+		break;
+	case ActiveT2:
+		readregst(state, 0x20, 0x10, &rdata, 1);
+		if (rdata & 0x10)
+			break;
+		if ((rdata & 0x07) == 0x06) {
+			*status |= (FE_HAS_SIGNAL
+				| FE_HAS_CARRIER
+				| FE_HAS_VITERBI);
+			if (rdata & 0x20)
+				*status |= FE_HAS_SYNC;
+		}
+		if (*status & 0x08) {
+			readregst(state, 0x22, 0x12, &rdata, 1);
+			if (rdata & 0x01)
+				*status |= FE_HAS_LOCK;
+		}
+		break;
+	case ActiveC2:
+		readregst(state, 0x20, 0x10, &rdata, 1);
+		if (rdata & 0x10)
+			break;
+		if ((rdata & 0x07) == 0x06) {
+			*status |= (FE_HAS_SIGNAL
+				| FE_HAS_CARRIER
+				| FE_HAS_VITERBI);
+			if (rdata & 0x20)
+				*status |= (FE_HAS_SYNC | FE_HAS_LOCK);
+		}
+		if ((*status & FE_HAS_LOCK) && state->FirstTimeLock) {
+			u8 data;
+
+			/* Change1stTrial */
+			readregst(state, 0x28, 0xE6, &rdata, 1);
+			data = rdata & 1;
+			readregst(state, 0x50, 0x15, &rdata, 1);
+			data |= ((rdata & 0x18) >> 2);
+			/*writebitst(state, 0x50,0x6F,rdata,0x07);*/
+			state->FirstTimeLock = 0;
+		}
+		break;
+	case ActiveIT:
+		readregst(state, 0x60, 0x10, &rdata, 1);
+		if (rdata & 0x10)
+			break;
+		if (rdata & 0x02) {
+			*status |= (FE_HAS_SIGNAL
+				| FE_HAS_CARRIER
+				| FE_HAS_VITERBI);
+			if (rdata & 0x01)
+				*status |= (FE_HAS_SYNC | FE_HAS_LOCK);
+		}
+		break;
+	default:
+		break;
+	}
+	state->last_status = *status;
+	return 0;
+}
+
+static int get_ber_t(struct cxd_state *state, u32 *n, u32 *d)
+{
+	u8 BERRegs[3];
+	u8 Scale;
+
+	*n = 0;
+	*d = 1;
+
+	readregst(state, 0x10, 0x62, BERRegs, 3);
+	readregst(state, 0x10, 0x60, &Scale, 1);
+	Scale &= 0x1F;
+
+	if (BERRegs[0] & 0x80) {
+		state->LastBERNominator = (((u32) BERRegs[0] & 0x3F) << 16) |
+			(((u32) BERRegs[1]) << 8) | BERRegs[2];
+		state->LastBERDenominator = 1632 << Scale;
+		if (state->LastBERNominator < 256 &&
+		    Scale < state->BERScaleMax) {
+			writebitst(state, 0x10, 0x60, Scale + 1, 0x1F);
+		} else if (state->LastBERNominator > 512 && Scale > 11)
+			writebitst(state, 0x10, 0x60, Scale - 1, 0x1F);
+	}
+	*n = state->LastBERNominator;
+	*d = state->LastBERDenominator;
+
+	return 0;
+}
+
+static int get_ber_t2(struct cxd_state *state, u32 *n, u32 *d)
+{
+	*n = 0;
+	*d = 1;
+	return 0;
+}
+
+static int get_ber_c(struct cxd_state *state, u32 *n, u32 *d)
+{
+	u8 BERRegs[3];
+	u8 Scale;
+
+	*n = 0;
+	*d = 1;
+
+	readregst(state, 0x40, 0x62, BERRegs, 3);
+	readregst(state, 0x40, 0x60, &Scale, 1);
+	Scale &= 0x1F;
+
+	if (BERRegs[0] & 0x80) {
+		state->LastBERNominator = (((u32) BERRegs[0] & 0x3F) << 16) |
+			(((u32) BERRegs[1]) << 8) | BERRegs[2];
+		state->LastBERDenominator = 1632 << Scale;
+		if (state->LastBERNominator < 256 &&
+		    Scale < state->BERScaleMax) {
+			writebitst(state, 0x40, 0x60, Scale + 1, 0x1F);
+		} else if (state->LastBERNominator > 512 && Scale > 11)
+			writebitst(state, 0x40, 0x60, Scale - 1, 0x1F);
+	}
+	*n = state->LastBERNominator;
+	*d = state->LastBERDenominator;
+
+	return 0;
+}
+
+static int get_ber_c2(struct cxd_state *state, u32 *n, u32 *d)
+{
+	*n = 0;
+	*d = 1;
+	return 0;
+}
+
+static int get_ber_it(struct cxd_state *state, u32 *n, u32 *d)
+{
+	*n = 0;
+	*d = 1;
+	return 0;
+}
+
+static int read_ber(struct dvb_frontend *fe, u32 *ber, u32 *n, u32 *d)
+{
+	struct cxd_state *state = fe->demodulator_priv;
+	int s = 0;
+
+	*ber = 0;
+	*n = 0;
+	*d = 1;
+
+	switch (state->state) {
+	case ActiveT:
+		s = get_ber_t(state, n, d);
+		break;
+	case ActiveT2:
+		s = get_ber_t2(state, n, d);
+		break;
+	case ActiveC:
+		s = get_ber_c(state, n, d);
+		break;
+	case ActiveC2:
+		s = get_ber_c2(state, n, d);
+		break;
+	case ActiveIT:
+		s = get_ber_it(state, n, d);
+		break;
+	default:
+		break;
+	}
+
+	if (s)
+		return s;
+
+	if (d)
+		*ber = (*n * 1000) / *d;
+
+	return 0;
+}
+
+static u32 snrreg_to_db_t_c2_it(u32 reg, u32 max, u32 offset)
+{
+	s32 snr;
+
+	if (reg == 0)
+		return 0;
+
+	snr = 100 * ((INTLOG10X100(reg) - INTLOG10X100(max - reg)) + offset);
+
+	if (snr < 0)
+		return 0;
+
+	return snr;
+}
+
+static u32 snrreg_to_db_c(u32 reg, u32 max, u32 mult)
+{
+	return (reg != 0 ? ((max - INTLOG10X100(reg)) * mult + 500) / 10 : 0);
+}
+
+static int GetSignalToNoiseIT(struct cxd_state *state, u32 *snr)
+{
+	u8 Data[2];
+	u32 reg;
+
+	freeze_regst(state);
+	readregst_unlocked(state, 0x60, 0x28, Data, sizeof(Data));
+	unfreeze_regst(state);
+
+	reg = (Data[0] << 8) | Data[1];
+
+	switch (state->bw) {
+	case 8:
+		if (reg > 1143)
+			reg = 1143;
+		*snr = snrreg_to_db_t_c2_it(reg, 1200, 220);
+		break;
+	default:
+		if (reg > 51441)
+			reg = 51441;
+
+		*snr = (reg > 0 ? (INTLOG10X100(reg) - 90) : 0);
+		break;
+	}
+
+	return 0;
+}
+
+static int GetSignalToNoiseC2(struct cxd_state *state, u32 *snr)
+{
+	u8 Data[2];
+	u32 reg;
+
+	freeze_regst(state);
+	readregst_unlocked(state, 0x20, 0x28, Data, sizeof(Data));
+	unfreeze_regst(state);
+
+	reg = (Data[0] << 8) | Data[1];
+	if (reg > 51441)
+		reg = 51441;
+
+	*snr = snrreg_to_db_t_c2_it(reg, 55000, 384);
+
+	return 0;
+}
+
+
+static int GetSignalToNoiseT2(struct cxd_state *state, u32 *snr)
+{
+	u8 Data[2];
+	u32 reg;
+
+	freeze_regst(state);
+	readregst_unlocked(state, 0x20, 0x28, Data, sizeof(Data));
+	unfreeze_regst(state);
+
+	reg = (Data[0] << 8) | Data[1];
+	if (reg > 10876)
+		reg = 10876;
+
+	*snr = snrreg_to_db_t_c2_it(reg, 12600, 320);
+
+	return 0;
+}
+
+static int GetSignalToNoiseT(struct cxd_state *state, u32 *snr)
+{
+	u8 Data[2];
+	u32 reg;
+
+	freeze_regst(state);
+	readregst_unlocked(state, 0x10, 0x28, Data, sizeof(Data));
+	unfreeze_regst(state);
+
+	reg = (Data[0] << 8) | Data[1];
+	if (reg > 4996)
+		reg = 4996;
+
+	*snr = snrreg_to_db_t_c2_it(reg, 5350, 285);
+
+	return 0;
+}
+
+static int GetSignalToNoiseC(struct cxd_state *state, u32 *snr)
+{
+	u8 Data[2];
+	u8 Constellation = 0;
+	u32 reg;
+
+	*snr = 0;
+
+	freeze_regst(state);
+	readregst_unlocked(state, 0x40, 0x19, &Constellation, 1);
+	readregst_unlocked(state, 0x40, 0x4C, Data, sizeof(Data));
+	unfreeze_regst(state);
+
+	reg = ((u32)(Data[0] & 0x1F) << 8) | (Data[1]);
+	if (reg == 0)
+		return 0;
+
+	switch (Constellation & 0x07) {
+	case 0: /* QAM 16 */
+	case 2: /* QAM 64 */
+	case 4: /* QAM 256 */
+		if (reg < 126)
+			reg = 126;
+		*snr = snrreg_to_db_c(reg, 439, 2134);
+		break;
+	case 1: /* QAM 32 */
+	case 3: /* QAM 128 */
+		if (reg < 69)
+			reg = 69;
+		*snr = snrreg_to_db_c(reg, 432, 2015);
+		break;
+	}
+
+	return 0;
+}
+
+static u32 read_snr(struct dvb_frontend *fe, u16 *snr)
+{
+	u32 ret = 0;
+	struct cxd_state *state = fe->demodulator_priv;
+
+	if (state->last_status != FE_STATUS_FULL_LOCK)
+		return 0;
+
+	switch (state->state) {
+	case ActiveC:
+		GetSignalToNoiseC(state, &ret);
+		break;
+	case ActiveC2:
+		GetSignalToNoiseC2(state, &ret);
+		break;
+	case ActiveT:
+		GetSignalToNoiseT(state, &ret);
+		break;
+	case ActiveT2:
+		GetSignalToNoiseT2(state, &ret);
+		break;
+	case ActiveIT:
+		GetSignalToNoiseIT(state, &ret);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	*snr = ret & 0xffff;
+	return 0;
+}
+
+static int read_agc_gain_c_t_t2(struct dvb_frontend *fe, u16 *strength)
+{
+	struct cxd_state *state = fe->demodulator_priv;
+	u8 data[2];
+	u8 regbank;
+
+	switch (state->state) {
+	case ActiveC:
+	case ActiveT:
+		regbank = 0x10;
+		break;
+	case ActiveT2:
+		regbank = 0x20;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	freeze_regst(state);
+	readregst_unlocked(state, regbank, 0x26, data, sizeof(data));
+	unfreeze_regst(state);
+
+	*strength = 65535 -
+		(((((u16)data[0] & 0x0F) << 8)
+		| (u16)(data[1] & 0xFF))
+		<< 4);
+
+	return 0;
+}
+
+static int tune(struct dvb_frontend *fe, bool re_tune,
+		unsigned int mode_flags,
+		unsigned int *delay, enum fe_status *status)
+{
+	struct cxd_state *state = fe->demodulator_priv;
+	int r;
+
+	if (re_tune) {
+		r = set_parameters(fe);
+		if (r)
+			return r;
+		state->tune_time = jiffies;
+
+	}
+	if (*status & FE_HAS_LOCK)
+		return 0;
+	/* *delay = 50; */
+	r = read_status(fe, status);
+	if (r)
+		return r;
+	return 0;
+}
+
+static enum dvbfe_search search(struct dvb_frontend *fe)
+{
+	int r;
+	u32 loops = 20, i;
+	enum fe_status status;
+
+	r = set_parameters(fe);
+
+	for (i = 0; i < loops; i++)  {
+		msleep(50);
+		r = read_status(fe, &status);
+		if (r)
+			return DVBFE_ALGO_SEARCH_ERROR;
+		if (status & FE_HAS_LOCK)
+			break;
+	}
+
+	if (status & FE_HAS_LOCK)
+		return DVBFE_ALGO_SEARCH_SUCCESS;
+	else
+		return DVBFE_ALGO_SEARCH_AGAIN;
+}
+
+static int get_algo(struct dvb_frontend *fe)
+{
+	return DVBFE_ALGO_HW;
+}
+
+static int get_fe_t(struct cxd_state *state)
+{
+	struct dvb_frontend *fe = &state->frontend;
+	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
+	u8 tps[7];
+
+	read_tps(state, tps);
+
+/*  TPSData[0] [7:6]  CNST[1:0]
+ *  TPSData[0] [5:3]  HIER[2:0]
+ *  TPSData[0] [2:0]  HRATE[2:0]
+ */
+	switch ((tps[0] >> 6) & 0x03) {
+	case 0:
+		p->modulation = QPSK;
+		break;
+	case 1:
+		p->modulation = QAM_16;
+		break;
+	case 2:
+		p->modulation = QAM_64;
+		break;
+	}
+	switch ((tps[0] >> 3) & 0x07) {
+	case 0:
+		p->hierarchy = HIERARCHY_NONE;
+		break;
+	case 1:
+		p->hierarchy = HIERARCHY_1;
+		break;
+	case 2:
+		p->hierarchy = HIERARCHY_2;
+		break;
+	case 3:
+		p->hierarchy = HIERARCHY_4;
+		break;
+	}
+	switch ((tps[0] >> 0) & 0x07) {
+	case 0:
+		p->code_rate_HP = FEC_1_2;
+		break;
+	case 1:
+		p->code_rate_HP = FEC_2_3;
+		break;
+	case 2:
+		p->code_rate_HP = FEC_3_4;
+		break;
+	case 3:
+		p->code_rate_HP = FEC_5_6;
+		break;
+	case 4:
+		p->code_rate_HP = FEC_7_8;
+		break;
+	}
+
+/*  TPSData[1] [7:5]  LRATE[2:0]
+ *  TPSData[1] [4:3]  GI[1:0]
+ *  TPSData[1] [2:1]  MODE[1:0]
+ */
+	switch ((tps[1] >> 5) & 0x07) {
+	case 0:
+		p->code_rate_LP = FEC_1_2;
+		break;
+	case 1:
+		p->code_rate_LP = FEC_2_3;
+		break;
+	case 2:
+		p->code_rate_LP = FEC_3_4;
+		break;
+	case 3:
+		p->code_rate_LP = FEC_5_6;
+		break;
+	case 4:
+		p->code_rate_LP = FEC_7_8;
+		break;
+	}
+	switch ((tps[1] >> 3) & 0x03) {
+	case 0:
+		p->guard_interval = GUARD_INTERVAL_1_32;
+		break;
+	case 1:
+		p->guard_interval = GUARD_INTERVAL_1_16;
+		break;
+	case 2:
+		p->guard_interval = GUARD_INTERVAL_1_8;
+		break;
+	case 3:
+		p->guard_interval = GUARD_INTERVAL_1_4;
+		break;
+	}
+	switch ((tps[1] >> 1) & 0x03) {
+	case 0:
+		p->transmission_mode = TRANSMISSION_MODE_2K;
+		break;
+	case 1:
+		p->transmission_mode = TRANSMISSION_MODE_8K;
+		break;
+	}
+
+	return 0;
+}
+
+static int get_fe_c(struct cxd_state *state)
+{
+	struct dvb_frontend *fe = &state->frontend;
+	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
+	u8 qam;
+
+	freeze_regst(state);
+	readregst_unlocked(state, 0x40, 0x19, &qam, 1);
+	unfreeze_regst(state);
+	p->modulation = 1 + (qam & 0x07);
+	return 0;
+}
+
+static int get_frontend(struct dvb_frontend *fe,
+			struct dtv_frontend_properties *p)
+{
+	struct cxd_state *state = fe->demodulator_priv;
+	enum fe_status status = 0;
+	int tmp;
+	u16 snr = 0, strength = 0;
+	u32 ber = 0, bernom = 0, berdenom = 1;
+
+	tmp = read_status(fe, &status);
+
+	p->strength.len = 1;
+	p->cnr.len = 1;
+	p->pre_bit_error.len = 1;
+	p->pre_bit_count.len = 1;
+	p->post_bit_error.len = 1;
+
+	if (state->last_status != FE_STATUS_FULL_LOCK) {
+		p->strength.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+		p->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+		p->pre_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+		p->pre_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+		p->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+
+		return 0;
+	}
+
+	if (state->state == ActiveT)
+		get_fe_t(state);
+	else if (state->state == ActiveC)
+		get_fe_c(state);
+
+	if (read_agc_gain_c_t_t2(fe, &strength))
+		p->strength.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+	else {
+		p->strength.stat[0].scale = FE_SCALE_RELATIVE;
+		p->strength.stat[0].uvalue = strength;
+	}
+
+	if (read_snr(fe, &snr))
+		p->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+	else {
+		p->cnr.stat[0].scale = FE_SCALE_DECIBEL;
+		p->cnr.stat[0].svalue = snr;
+	}
+
+	if (read_ber(fe, &ber, &bernom, &berdenom)) {
+		p->pre_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+		p->pre_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+		p->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+	} else {
+		p->pre_bit_error.stat[0].scale = FE_SCALE_COUNTER;
+		p->pre_bit_error.stat[0].uvalue = bernom;
+		p->pre_bit_count.stat[0].scale = FE_SCALE_COUNTER;
+		p->pre_bit_count.stat[0].uvalue = berdenom;
+		p->post_bit_error.stat[0].scale = FE_SCALE_COUNTER;
+		p->post_bit_error.stat[0].uvalue = ber;
+	}
+
+	return 0;
+}
+
+static struct dvb_frontend_ops common_ops_2843 = {
+	.delsys = { SYS_DVBC_ANNEX_A, SYS_DVBT, SYS_DVBT2, SYS_DVBC2 },
+	.info = {
+		.name = "CXD2843 DVB-C/C2 DVB-T/T2",
+		.frequency_stepsize = 166667,	/* DVB-T only */
+		.frequency_min = 47000000,	/* DVB-T: 47125000 */
+		.frequency_max = 865000000,	/* DVB-C: 862000000 */
+		.symbol_rate_min = 870000,
+		.symbol_rate_max = 11700000,
+		.caps = FE_CAN_QPSK | FE_CAN_QAM_16 | FE_CAN_QAM_32 |
+			FE_CAN_QAM_64 | FE_CAN_QAM_128 | FE_CAN_QAM_256 |
+			FE_CAN_QAM_AUTO |
+			FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |
+			FE_CAN_FEC_4_5 |
+			FE_CAN_FEC_5_6 | FE_CAN_FEC_7_8 | FE_CAN_FEC_AUTO |
+			FE_CAN_TRANSMISSION_MODE_AUTO |
+			FE_CAN_GUARD_INTERVAL_AUTO | FE_CAN_HIERARCHY_AUTO |
+			FE_CAN_RECOVER | FE_CAN_MUTE_TS | FE_CAN_2G_MODULATION
+	},
+	.release = release,
+	.sleep = sleep,
+	.i2c_gate_ctrl = gate_ctrl,
+	.set_frontend = set_parameters,
+
+	.read_status = read_status,
+	.get_frontend = get_frontend,
+#ifdef USE_ALGO
+	.get_frontend_algo = get_algo,
+	.search = search,
+	.tune = tune,
+#endif
+};
+
+static struct dvb_frontend_ops common_ops_2837 = {
+	.delsys = { SYS_DVBC_ANNEX_A, SYS_DVBT, SYS_DVBT2 },
+	.info = {
+		.name = "CXD2837 DVB-C DVB-T/T2",
+		.frequency_stepsize = 166667,	/* DVB-T only */
+		.frequency_min = 47000000,	/* DVB-T: 47125000 */
+		.frequency_max = 865000000,	/* DVB-C: 862000000 */
+		.symbol_rate_min = 870000,
+		.symbol_rate_max = 11700000,
+		.caps = FE_CAN_QPSK | FE_CAN_QAM_16 | FE_CAN_QAM_32 |
+			FE_CAN_QAM_64 | FE_CAN_QAM_128 | FE_CAN_QAM_256 |
+			FE_CAN_QAM_AUTO |
+			FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |
+			FE_CAN_FEC_4_5 |
+			FE_CAN_FEC_5_6 | FE_CAN_FEC_7_8 | FE_CAN_FEC_AUTO |
+			FE_CAN_TRANSMISSION_MODE_AUTO |
+			FE_CAN_GUARD_INTERVAL_AUTO | FE_CAN_HIERARCHY_AUTO |
+			FE_CAN_RECOVER | FE_CAN_MUTE_TS | FE_CAN_2G_MODULATION
+	},
+	.release = release,
+	.sleep = sleep,
+	.i2c_gate_ctrl = gate_ctrl,
+	.set_frontend = set_parameters,
+
+	.read_status = read_status,
+	.get_frontend = get_frontend,
+#ifdef USE_ALGO
+	.get_frontend_algo = get_algo,
+	.search = search,
+	.tune = tune,
+#endif
+};
+
+static struct dvb_frontend_ops common_ops_2838 = {
+	.delsys = { SYS_ISDBT },
+	.info = {
+		.name = "CXD2838 ISDB-T",
+		.frequency_stepsize = 166667,
+		.frequency_min = 47000000,
+		.frequency_max = 865000000,
+		.symbol_rate_min = 870000,
+		.symbol_rate_max = 11700000,
+		.caps = FE_CAN_QPSK | FE_CAN_QAM_16 | FE_CAN_QAM_64 |
+			FE_CAN_QAM_AUTO | FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 |
+			FE_CAN_FEC_3_4 | FE_CAN_FEC_4_5 |
+			FE_CAN_FEC_5_6 | FE_CAN_FEC_7_8 | FE_CAN_FEC_AUTO |
+			FE_CAN_TRANSMISSION_MODE_AUTO |
+			FE_CAN_GUARD_INTERVAL_AUTO | FE_CAN_HIERARCHY_AUTO |
+			FE_CAN_RECOVER | FE_CAN_MUTE_TS | FE_CAN_2G_MODULATION
+	},
+	.release = release,
+	.sleep = sleep,
+	.i2c_gate_ctrl = gate_ctrl,
+	.set_frontend = set_parameters,
+
+	.read_status = read_status,
+#ifdef USE_ALGO
+	.get_frontend_algo = get_algo,
+	.search = search,
+	.tune = tune,
+#endif
+};
+
+static int probe(struct cxd_state *state)
+{
+	u8 ChipID = 0x00;
+	int status;
+
+	status = readregst(state, 0x00, 0xFD, &ChipID, 1);
+
+	if (status)
+		status = readregsx(state, 0x00, 0xFD, &ChipID, 1);
+	if (status)
+		return status;
+
+	/*printk("ChipID  = %02X\n", ChipID);*/
+	switch (ChipID) {
+	case 0xa4:
+		state->type = CXD2843;
+		memcpy(&state->frontend.ops, &common_ops_2843,
+		       sizeof(struct dvb_frontend_ops));
+		break;
+	case 0xb1:
+		state->type = CXD2837;
+		memcpy(&state->frontend.ops, &common_ops_2837,
+		       sizeof(struct dvb_frontend_ops));
+		break;
+	case 0xb0:
+		state->type = CXD2838;
+		memcpy(&state->frontend.ops, &common_ops_2838,
+		       sizeof(struct dvb_frontend_ops));
+		break;
+	default:
+		return -ENODEV;
+	}
+
+	pr_info("%s with ChipID %02X found at adr %02X on %s\n",
+		state->frontend.ops.info.name, ChipID, state->adrt,
+		dev_name(&state->i2c->dev));
+
+	state->frontend.demodulator_priv = state;
+	return 0;
+}
+
+struct dvb_frontend *cxd2843_attach(struct i2c_adapter *i2c,
+				    struct cxd2843_cfg *cfg)
+{
+	struct cxd_state *state = NULL;
+
+	state = kzalloc(sizeof(struct cxd_state), GFP_KERNEL);
+	if (!state)
+		return NULL;
+
+	state->i2c = i2c;
+	init_state(state, cfg);
+	if (probe(state) == 0) {
+		init(state);
+		return &state->frontend;
+	}
+	pr_err("No supported demodulator found at adr %02X on %s\n",
+		cfg->adr, dev_name(&i2c->dev));
+	kfree(state);
+	return NULL;
+}
+EXPORT_SYMBOL(cxd2843_attach);
+
+MODULE_DESCRIPTION("CXD2843/37/38 driver");
+MODULE_AUTHOR("Ralph Metzler, Manfred Voelkel");
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/dvb-frontends/cxd2843.h b/drivers/media/dvb-frontends/cxd2843.h
new file mode 100644
index 0000000..2467a6b
--- /dev/null
+++ b/drivers/media/dvb-frontends/cxd2843.h
@@ -0,0 +1,30 @@
+#ifndef _CXD2843_H_
+#define _CXD2843_H_
+
+#include <linux/types.h>
+#include <linux/i2c.h>
+
+struct cxd2843_cfg {
+	u8  adr;
+	u32 ts_clock;
+	u8  parallel;
+};
+
+#if IS_REACHABLE(CONFIG_DVB_CXD2843)
+
+extern struct dvb_frontend *cxd2843_attach(struct i2c_adapter *i2c,
+					   struct cxd2843_cfg *cfg);
+
+
+#else
+
+static inline struct dvb_frontend *cxd2843_attach(struct i2c_adapter *i2c,
+					   struct cxd2843_cfg *cfg)
+{
+	pr_warn("%s: driver disabled by Kconfig\n", __func__);
+	return NULL;
+}
+
+#endif /* CONFIG_DVB_CXD2843 */
+
+#endif /* _CXD2843_H_ */
diff --git a/drivers/media/dvb-frontends/mxl5xx.c b/drivers/media/dvb-frontends/mxl5xx.c
new file mode 100644
index 0000000..4413fd2
--- /dev/null
+++ b/drivers/media/dvb-frontends/mxl5xx.c
@@ -0,0 +1,1749 @@
+/*
+ * Driver for the Maxlinear MX58x family of tuners/demods
+ *
+ * Copyright (C) 2014-2015 Ralph Metzler <rjkm@metzlerbros.de>
+ *                         Marcus Metzler <mocm@metzlerbros.de>
+ *                         developed for Digital Devices GmbH
+ *
+ * based on code:
+ * Copyright (c) 2011-2013 MaxLinear, Inc. All rights reserved
+ * which was released under GPL V2
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2, as published by the Free Software Foundation.
+ *
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA
+ * Or, point your browser to http://www.gnu.org/copyleft/gpl.html
+ */
+
+#undef pr_fmt
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/firmware.h>
+#include <linux/i2c.h>
+#include <linux/version.h>
+#include <linux/mutex.h>
+#include <linux/vmalloc.h>
+#include <asm/div64.h>
+#include <asm/unaligned.h>
+
+#include "dvb_frontend.h"
+#include "mxl5xx.h"
+#include "mxl5xx_regs.h"
+#include "mxl5xx_defs.h"
+
+#define BYTE0(v) ((v >>  0) & 0xff)
+#define BYTE1(v) ((v >>  8) & 0xff)
+#define BYTE2(v) ((v >> 16) & 0xff)
+#define BYTE3(v) ((v >> 24) & 0xff)
+
+
+LIST_HEAD(mxllist);
+
+struct mxl_base {
+	struct list_head     mxllist;
+	struct list_head     mxls;
+
+	u8                   adr;
+	struct i2c_adapter  *i2c;
+
+	u32                  count;
+	u32                  type;
+	u32                  sku_type;
+	u32                  chipversion;
+	u32                  clock;
+	u32                  fwversion;
+
+	u8                  *ts_map;
+	u8                   can_clkout;
+	u8                   chan_bond;
+	u8                   demod_num;
+	u8                   tuner_num;
+
+	unsigned long        next_tune;
+
+	struct mutex         i2c_lock;
+	struct mutex         status_lock;
+	struct mutex         tune_lock;
+
+	u8                   buf[MXL_HYDRA_OEM_MAX_CMD_BUFF_LEN];
+
+	u32                  cmd_size;
+	u8                   cmd_data[MAX_CMD_DATA];
+};
+
+struct mxl {
+	struct list_head     mxl;
+
+	struct mxl_base     *base;
+	struct dvb_frontend  fe;
+	u32                  demod;
+	u32                  tuner;
+	u32                  tuner_in_use;
+
+	unsigned long        tune_time;
+};
+
+static void convert_endian(u8 flag, u32 size, u8 *d)
+{
+	u32 i;
+
+	if (!flag)
+		return;
+	for (i = 0; i < (size & ~3); i += 4) {
+		d[i + 0] ^= d[i + 3];
+		d[i + 3] ^= d[i + 0];
+		d[i + 0] ^= d[i + 3];
+
+		d[i + 1] ^= d[i + 2];
+		d[i + 2] ^= d[i + 1];
+		d[i + 1] ^= d[i + 2];
+	}
+
+	switch (size & 3) {
+	case 0:
+	case 1:
+		/* do nothing */
+		break;
+	case 2:
+		d[i + 0] ^= d[i + 1];
+		d[i + 1] ^= d[i + 0];
+		d[i + 0] ^= d[i + 1];
+		break;
+
+	case 3:
+		d[i + 0] ^= d[i + 2];
+		d[i + 2] ^= d[i + 0];
+		d[i + 0] ^= d[i + 2];
+		break;
+	}
+
+}
+
+static int i2c_write(struct i2c_adapter *adap, u8 adr,
+			    u8 *data, u32 len)
+{
+	struct i2c_msg msg = {.addr = adr, .flags = 0,
+			      .buf = data, .len = len};
+
+	return (i2c_transfer(adap, &msg, 1) == 1) ? 0 : -1;
+}
+
+static int i2c_read(struct i2c_adapter *adap, u8 adr,
+			   u8 *data, u32 len)
+{
+	struct i2c_msg msg = {.addr = adr, .flags = I2C_M_RD,
+			      .buf = data, .len = len};
+
+	return (i2c_transfer(adap, &msg, 1) == 1) ? 0 : -1;
+}
+
+static int i2cread(struct mxl *state, u8 *data, int len)
+{
+	return i2c_read(state->base->i2c, state->base->adr, data, len);
+}
+
+static int i2cwrite(struct mxl *state, u8 *data, int len)
+{
+	return i2c_write(state->base->i2c, state->base->adr, data, len);
+}
+
+static int read_register_unlocked(struct mxl *state, u32 reg, u32 *val)
+{
+	int stat;
+	u8 data[MXL_HYDRA_REG_SIZE_IN_BYTES + MXL_HYDRA_I2C_HDR_SIZE] = {
+		MXL_HYDRA_PLID_REG_READ, 0x04,
+		GET_BYTE(reg, 0), GET_BYTE(reg, 1),
+		GET_BYTE(reg, 2), GET_BYTE(reg, 3),
+	};
+
+	stat = i2cwrite(state, data,
+			MXL_HYDRA_REG_SIZE_IN_BYTES + MXL_HYDRA_I2C_HDR_SIZE);
+	if (stat)
+		pr_err("i2c read error 1\n");
+	if (!stat)
+		stat = i2cread(state, (u8 *) val, MXL_HYDRA_REG_SIZE_IN_BYTES);
+	le32_to_cpus(val);
+	if (stat)
+		pr_err("i2c read error 2\n");
+	return stat;
+}
+
+
+#define DMA_I2C_INTERRUPT_ADDR 0x8000011C
+#define DMA_INTR_PROT_WR_CMP 0x08
+
+static int send_command(struct mxl *state, u32 size, u8 *buf)
+{
+	int stat;
+	u32 val, count = 10;
+
+	mutex_lock(&state->base->i2c_lock);
+	if (state->base->fwversion > 0x02010109)  {
+		read_register_unlocked(state, DMA_I2C_INTERRUPT_ADDR, &val);
+		if (DMA_INTR_PROT_WR_CMP & val)
+			pr_info("send_command busy\n");
+		while ((DMA_INTR_PROT_WR_CMP & val) && --count) {
+			mutex_unlock(&state->base->i2c_lock);
+			usleep_range(1000, 2000);
+			mutex_lock(&state->base->i2c_lock);
+			read_register_unlocked(state, DMA_I2C_INTERRUPT_ADDR, &val);
+		}
+		if (!count) {
+			pr_info("send_command busy\n");
+			mutex_unlock(&state->base->i2c_lock);
+			return -EBUSY;
+		}
+	}
+	stat = i2cwrite(state, buf, size);
+	mutex_unlock(&state->base->i2c_lock);
+	return stat;
+}
+
+static int write_register(struct mxl *state, u32 reg, u32 val)
+{
+	int stat;
+	u8 data[MXL_HYDRA_REG_WRITE_LEN] = {
+		MXL_HYDRA_PLID_REG_WRITE, 0x08,
+		BYTE0(reg), BYTE1(reg), BYTE2(reg), BYTE3(reg),
+		BYTE0(val), BYTE1(val), BYTE2(val), BYTE3(val),
+	};
+	mutex_lock(&state->base->i2c_lock);
+	stat = i2cwrite(state, data, sizeof(data));
+	mutex_unlock(&state->base->i2c_lock);
+	if (stat)
+		pr_err("i2c write error\n");
+	return stat;
+}
+
+static int write_firmware_block(struct mxl *state,
+				u32 reg, u32 size, u8 *regDataPtr)
+{
+	int stat;
+	u8 *buf = state->base->buf;
+
+	mutex_lock(&state->base->i2c_lock);
+	buf[0] = MXL_HYDRA_PLID_REG_WRITE;
+	buf[1] = size + 4;
+	buf[2] = GET_BYTE(reg, 0);
+	buf[3] = GET_BYTE(reg, 1);
+	buf[4] = GET_BYTE(reg, 2);
+	buf[5] = GET_BYTE(reg, 3);
+	memcpy(&buf[6], regDataPtr, size);
+	stat = i2cwrite(state, buf,
+			MXL_HYDRA_I2C_HDR_SIZE +
+			MXL_HYDRA_REG_SIZE_IN_BYTES + size);
+	mutex_unlock(&state->base->i2c_lock);
+	if (stat)
+		pr_err("fw block write failed\n");
+	return stat;
+}
+
+static int read_register(struct mxl *state, u32 reg, u32 *val)
+{
+	int stat;
+	u8 data[MXL_HYDRA_REG_SIZE_IN_BYTES + MXL_HYDRA_I2C_HDR_SIZE] = {
+		MXL_HYDRA_PLID_REG_READ, 0x04,
+		GET_BYTE(reg, 0), GET_BYTE(reg, 1),
+		GET_BYTE(reg, 2), GET_BYTE(reg, 3),
+	};
+
+	mutex_lock(&state->base->i2c_lock);
+	stat = i2cwrite(state, data,
+			MXL_HYDRA_REG_SIZE_IN_BYTES + MXL_HYDRA_I2C_HDR_SIZE);
+	if (stat)
+		pr_err("i2c read error 1\n");
+	if (!stat)
+		stat = i2cread(state, (u8 *) val, MXL_HYDRA_REG_SIZE_IN_BYTES);
+	mutex_unlock(&state->base->i2c_lock);
+	le32_to_cpus(val);
+	if (stat)
+		pr_err("i2c read error 2\n");
+	return stat;
+}
+
+static int read_register_block(struct mxl *state, u32 reg, u32 size, u8 *data)
+{
+	int stat;
+	u8 *buf = state->base->buf;
+
+	mutex_lock(&state->base->i2c_lock);
+
+	buf[0] = MXL_HYDRA_PLID_REG_READ;
+	buf[1] = size + 4;
+	buf[2] = GET_BYTE(reg, 0);
+	buf[3] = GET_BYTE(reg, 1);
+	buf[4] = GET_BYTE(reg, 2);
+	buf[5] = GET_BYTE(reg, 3);
+	stat = i2cwrite(state, buf,
+			MXL_HYDRA_I2C_HDR_SIZE + MXL_HYDRA_REG_SIZE_IN_BYTES);
+	if (!stat) {
+		stat = i2cread(state, data, size);
+		convert_endian(MXL_ENABLE_BIG_ENDIAN, size, data);
+	}
+	mutex_unlock(&state->base->i2c_lock);
+	return stat;
+}
+
+static int read_by_mnemonic(struct mxl *state,
+			    u32 reg, u8 lsbloc, u8 numofbits, u32 *val)
+{
+	u32 data = 0, mask = 0;
+	int stat;
+
+	stat = read_register(state, reg, &data);
+	if (stat)
+		return stat;
+	mask = MXL_GET_REG_MASK_32(lsbloc, numofbits);
+	data &= mask;
+	data >>= lsbloc;
+	*val = data;
+	return 0;
+}
+
+
+static int update_by_mnemonic(struct mxl *state,
+			      u32 reg, u8 lsbloc, u8 numofbits, u32 val)
+{
+	u32 data, mask;
+	int stat;
+
+	stat = read_register(state, reg, &data);
+	if (stat)
+		return stat;
+	mask = MXL_GET_REG_MASK_32(lsbloc, numofbits);
+	data = (data & ~mask) | ((val << lsbloc) & mask);
+	stat = write_register(state, reg, data);
+	return stat;
+}
+
+static int firmware_is_alive(struct mxl *state)
+{
+	u32 hb0, hb1;
+
+	if (read_register(state, HYDRA_HEAR_BEAT, &hb0))
+		return 0;
+	msleep(20);
+	if (read_register(state, HYDRA_HEAR_BEAT, &hb1))
+		return 0;
+	if (hb1 == hb0)
+		return 0;
+	return 1;
+}
+
+static int init(struct dvb_frontend *fe)
+{
+	return 0;
+}
+
+static void release(struct dvb_frontend *fe)
+{
+	struct mxl *state = fe->demodulator_priv;
+
+	list_del(&state->mxl);
+	/* Release one frontend, two more shall take its place! */
+	state->base->count--;
+	if (state->base->count == 0) {
+		list_del(&state->base->mxllist);
+		kfree(state->base);
+	}
+	kfree(state);
+}
+
+static int get_algo(struct dvb_frontend *fe)
+{
+	return DVBFE_ALGO_HW;
+}
+
+static int CfgDemodAbortTune(struct mxl *state)
+{
+	MXL_HYDRA_DEMOD_ABORT_TUNE_T abortTuneCmd;
+	u8 cmdSize = sizeof(abortTuneCmd);
+	u8 cmdBuff[MXL_HYDRA_OEM_MAX_CMD_BUFF_LEN];
+
+	abortTuneCmd.demodId = state->demod;
+	BUILD_HYDRA_CMD(MXL_HYDRA_ABORT_TUNE_CMD, MXL_CMD_WRITE, cmdSize, &abortTuneCmd, cmdBuff);
+	return send_command(state, cmdSize + MXL_HYDRA_CMD_HEADER_SIZE, &cmdBuff[0]);
+}
+
+static int send_master_cmd(struct dvb_frontend *fe,
+			   struct dvb_diseqc_master_cmd *cmd)
+{
+	/*struct mxl *state = fe->demodulator_priv;*/
+
+	return 0; /*CfgDemodAbortTune(state);*/
+}
+
+static int set_parameters(struct dvb_frontend *fe)
+{
+	struct mxl *state = fe->demodulator_priv;
+	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
+	MXL_HYDRA_DEMOD_PARAM_T demodChanCfg;
+	u8 cmdSize = sizeof(demodChanCfg);
+	u8 cmdBuff[MXL_HYDRA_OEM_MAX_CMD_BUFF_LEN];
+	u32 srange = 10;
+	int stat;
+
+	if (p->frequency < 950000 || p->frequency > 2150000)
+		return -EINVAL;
+	if (p->symbol_rate < 1000000 || p->symbol_rate > 45000000)
+		return -EINVAL;
+
+	/* CfgDemodAbortTune(state); */
+
+	switch (p->delivery_system) {
+	case SYS_DSS:
+		demodChanCfg.standard = MXL_HYDRA_DSS;
+		demodChanCfg.rollOff = MXL_HYDRA_ROLLOFF_AUTO;
+		break;
+	case SYS_DVBS:
+		srange = p->symbol_rate / 1000000;
+		if (srange > 10)
+			srange = 10;
+		demodChanCfg.standard = MXL_HYDRA_DVBS;
+		demodChanCfg.rollOff = MXL_HYDRA_ROLLOFF_0_35;
+		demodChanCfg.modulationScheme = MXL_HYDRA_MOD_QPSK;
+		demodChanCfg.pilots = MXL_HYDRA_PILOTS_OFF;
+		break;
+	case SYS_DVBS2:
+		demodChanCfg.standard = MXL_HYDRA_DVBS2;
+		demodChanCfg.rollOff = MXL_HYDRA_ROLLOFF_AUTO;
+		demodChanCfg.modulationScheme = MXL_HYDRA_MOD_AUTO;
+		demodChanCfg.pilots = MXL_HYDRA_PILOTS_AUTO;
+		/* cfg_scrambler(state); */
+		break;
+	default:
+		return -EINVAL;
+	}
+	demodChanCfg.tunerIndex = state->tuner;
+	demodChanCfg.demodIndex = state->demod;
+	demodChanCfg.frequencyInHz = p->frequency * 1000;
+	demodChanCfg.symbolRateInHz = p->symbol_rate;
+	demodChanCfg.maxCarrierOffsetInMHz = srange;
+	demodChanCfg.spectrumInversion = MXL_HYDRA_SPECTRUM_AUTO;
+	demodChanCfg.fecCodeRate = MXL_HYDRA_FEC_AUTO;
+
+	mutex_lock(&state->base->tune_lock);
+	if (time_after(jiffies + msecs_to_jiffies(200), state->base->next_tune))
+		while (time_before(jiffies, state->base->next_tune))
+			usleep_range(10000, 11000);
+	state->base->next_tune = jiffies + msecs_to_jiffies(100);
+	state->tuner_in_use = state->tuner;
+	BUILD_HYDRA_CMD(MXL_HYDRA_DEMOD_SET_PARAM_CMD, MXL_CMD_WRITE,
+			cmdSize, &demodChanCfg, cmdBuff);
+	stat = send_command(state, cmdSize + MXL_HYDRA_CMD_HEADER_SIZE, &cmdBuff[0]);
+	mutex_unlock(&state->base->tune_lock);
+	return stat;
+}
+
+static int enable_tuner(struct mxl *state, u32 tuner, u32 enable);
+
+static int sleep(struct dvb_frontend *fe)
+{
+	struct mxl *state = fe->demodulator_priv;
+	struct mxl *p;
+
+	CfgDemodAbortTune(state);
+	if (state->tuner_in_use != 0xffffffff) {
+		mutex_lock(&state->base->tune_lock);
+		state->tuner_in_use = 0xffffffff;
+		list_for_each_entry(p, &state->base->mxls, mxl) {
+			if (p->tuner_in_use == state->tuner)
+				break;
+		}
+		if (&p->mxl == &state->base->mxls)
+			enable_tuner(state, state->tuner, 0);
+		mutex_unlock(&state->base->tune_lock);
+	}
+	return 0;
+}
+
+static int read_snr(struct dvb_frontend *fe, u16 *snr)
+{
+	struct mxl *state = fe->demodulator_priv;
+	int stat;
+	u32 regData = 0;
+	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
+
+	mutex_lock(&state->base->status_lock);
+	HYDRA_DEMOD_STATUS_LOCK(state, state->demod);
+	stat = read_register(state, (HYDRA_DMD_SNR_ADDR_OFFSET +
+				     HYDRA_DMD_STATUS_OFFSET(state->demod)),
+			     &regData);
+	HYDRA_DEMOD_STATUS_UNLOCK(state, state->demod);
+	mutex_unlock(&state->base->status_lock);
+
+	p->cnr.len = 1;
+	p->cnr.stat[0].scale = FE_SCALE_DECIBEL;
+	p->cnr.stat[0].svalue = (s16)regData * 10;
+
+	if (regData > 2000) regData = 2000;
+	*snr = (s16)(regData/10) * 328; /* 20dB = 100% */
+
+	return stat;
+}
+
+static int read_ber(struct dvb_frontend *fe, u32 *ber)
+{
+	struct mxl *state = fe->demodulator_priv;
+	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
+	u32 reg[8];
+	int stat;
+
+	mutex_lock(&state->base->status_lock);
+	HYDRA_DEMOD_STATUS_LOCK(state, state->demod);
+	stat = read_register_block(state,
+				   (HYDRA_DMD_DVBS_1ST_CORR_RS_ERRORS_ADDR_OFFSET +
+				    HYDRA_DMD_STATUS_OFFSET(state->demod)),
+				   (4 * sizeof(u32)),
+				   (u8 *) &reg[0]);
+	HYDRA_DEMOD_STATUS_UNLOCK(state, state->demod);
+
+	switch (p->delivery_system) {
+	case SYS_DSS:
+	case SYS_DVBS:
+		p->pre_bit_error.len = 1;
+		p->pre_bit_error.stat[0].scale = FE_SCALE_COUNTER;
+		p->pre_bit_error.stat[0].uvalue = reg[2];
+		p->pre_bit_count.len = 1;
+		p->pre_bit_count.stat[0].scale = FE_SCALE_COUNTER;
+		p->pre_bit_count.stat[0].uvalue = reg[3];
+		break;
+	default:
+		break;
+	}
+
+	stat = read_register_block(state,
+				   (HYDRA_DMD_DVBS2_CRC_ERRORS_ADDR_OFFSET +
+				    HYDRA_DMD_STATUS_OFFSET(state->demod)),
+				   (7 * sizeof(u32)),
+				   (u8 *) &reg[0]);
+
+	switch (p->delivery_system) {
+	case SYS_DSS:
+	case SYS_DVBS:
+		p->post_bit_error.len = 1;
+		p->post_bit_error.stat[0].scale = FE_SCALE_COUNTER;
+		p->post_bit_error.stat[0].uvalue = reg[5];
+		p->post_bit_count.len = 1;
+		p->post_bit_count.stat[0].scale = FE_SCALE_COUNTER;
+		p->post_bit_count.stat[0].uvalue = reg[6];
+		break;
+	case SYS_DVBS2:
+		p->post_bit_error.len = 1;
+		p->post_bit_error.stat[0].scale = FE_SCALE_COUNTER;
+		p->post_bit_error.stat[0].uvalue = reg[1];
+		p->post_bit_count.len = 1;
+		p->post_bit_count.stat[0].scale = FE_SCALE_COUNTER;
+		p->post_bit_count.stat[0].uvalue = reg[2];
+		break;
+	default:
+		break;
+	}
+
+	*ber = p->post_bit_error.stat[0].uvalue;
+
+	mutex_unlock(&state->base->status_lock);
+
+	return 0;
+}
+
+static int read_signal_strength(struct dvb_frontend *fe, u16 *strength)
+{
+	struct mxl *state = fe->demodulator_priv;
+	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
+	int stat;
+	u32 regData = 0;
+
+	mutex_lock(&state->base->status_lock);
+	HYDRA_DEMOD_STATUS_LOCK(state, state->demod);
+	stat = read_register(state, (HYDRA_DMD_STATUS_INPUT_POWER_ADDR +
+				     HYDRA_DMD_STATUS_OFFSET(state->demod)),
+			     &regData);
+	HYDRA_DEMOD_STATUS_UNLOCK(state, state->demod);
+	mutex_unlock(&state->base->status_lock);
+
+	p->strength.len = 1;
+	p->strength.stat[0].scale = FE_SCALE_DECIBEL;
+	p->strength.stat[0].svalue = (s16)regData *10;
+
+	*strength = (100 + (s16)regData/100) * 656;
+	return stat;
+}
+
+static int read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)
+{
+	return 0;
+}
+
+static int read_status(struct dvb_frontend *fe, enum fe_status *status)
+{
+	struct mxl *state = fe->demodulator_priv;
+
+	int stat;
+	u32 regData = 0;
+	u16 val;
+
+	mutex_lock(&state->base->status_lock);
+	HYDRA_DEMOD_STATUS_LOCK(state, state->demod);
+	stat = read_register(state, (HYDRA_DMD_LOCK_STATUS_ADDR_OFFSET +
+				     HYDRA_DMD_STATUS_OFFSET(state->demod)),
+			     &regData);
+	HYDRA_DEMOD_STATUS_UNLOCK(state, state->demod);
+	mutex_unlock(&state->base->status_lock);
+
+	*status = (regData == 1) ? 0x1f : 0;
+	read_signal_strength(fe, &val);
+	if (*status) {
+		read_snr(fe, &val);
+		read_ber(fe, &regData);
+	}
+
+	return 0;
+}
+
+static int tune(struct dvb_frontend *fe, bool re_tune,
+		unsigned int mode_flags,
+		unsigned int *delay, enum fe_status *status)
+{
+	struct mxl *state = fe->demodulator_priv;
+	int r = 0;
+
+	*delay = HZ / 2;
+	if (re_tune) {
+		r = set_parameters(fe);
+		if (r)
+			return r;
+		state->tune_time = jiffies;
+		return 0;
+	}
+	if (*status & FE_HAS_LOCK)
+		return 0;
+
+	r = read_status(fe, status);
+	if (r)
+		return r;
+
+	return 0;
+}
+
+static enum fe_code_rate conv_fec(MXL_HYDRA_FEC_E fec)
+{
+	enum fe_code_rate fec2fec[11] = {
+		FEC_NONE, FEC_1_2, FEC_3_5, FEC_2_3,
+		FEC_3_4, FEC_4_5, FEC_5_6, FEC_6_7,
+		FEC_7_8, FEC_8_9, FEC_9_10
+	};
+
+	if (fec > MXL_HYDRA_FEC_9_10)
+		return FEC_NONE;
+	return fec2fec[fec];
+}
+
+static int get_frontend(struct dvb_frontend *fe,
+			struct dtv_frontend_properties *p)
+{
+	struct mxl *state = fe->demodulator_priv;
+	u32 regData[MXL_DEMOD_CHAN_PARAMS_BUFF_SIZE];
+	u32 freq;
+	int stat;
+
+	mutex_lock(&state->base->status_lock);
+	HYDRA_DEMOD_STATUS_LOCK(state, state->demod);
+	stat = read_register_block(state,
+		(HYDRA_DMD_STANDARD_ADDR_OFFSET +
+		HYDRA_DMD_STATUS_OFFSET(state->demod)),
+		(MXL_DEMOD_CHAN_PARAMS_BUFF_SIZE * 4), /* 25 * 4 bytes */
+		(u8 *) &regData[0]);
+	/* read demod channel parameters */
+	stat = read_register_block(state,
+		(HYDRA_DMD_STATUS_CENTER_FREQ_IN_KHZ_ADDR +
+		HYDRA_DMD_STATUS_OFFSET(state->demod)),
+		(4), /* 4 bytes */
+		(u8 *) &freq);
+	HYDRA_DEMOD_STATUS_UNLOCK(state, state->demod);
+	mutex_unlock(&state->base->status_lock);
+
+	pr_debug("freq=%u delsys=%u srate=%u\n",
+		freq * 1000, regData[DMD_STANDARD_ADDR],
+		regData[DMD_SYMBOL_RATE_ADDR]);
+	p->symbol_rate = regData[DMD_SYMBOL_RATE_ADDR];
+	p->frequency = freq;
+	/*
+	 * p->delivery_system = (MXL_HYDRA_BCAST_STD_E )regData[DMD_STANDARD_ADDR];
+	 * p->inversion = (MXL_HYDRA_SPECTRUM_E )regData[DMD_SPECTRUM_INVERSION_ADDR];
+	 * freqSearchRangeKHz = (regData[DMD_FREQ_SEARCH_RANGE_IN_KHZ_ADDR]);
+	 */
+
+	p->fec_inner = conv_fec(regData[DMD_FEC_CODE_RATE_ADDR]);
+	switch (p->delivery_system) {
+	case SYS_DSS:
+		break;
+	case SYS_DVBS2:
+		switch ((MXL_HYDRA_PILOTS_E) regData[DMD_DVBS2_PILOT_ON_OFF_ADDR]) {
+		case MXL_HYDRA_PILOTS_OFF:
+			p->pilot = PILOT_OFF;
+			break;
+		case MXL_HYDRA_PILOTS_ON:
+			p->pilot = PILOT_ON;
+			break;
+		default:
+			break;
+		}
+	case SYS_DVBS:
+		switch ((MXL_HYDRA_MODULATION_E) regData[DMD_MODULATION_SCHEME_ADDR]) {
+		case MXL_HYDRA_MOD_QPSK:
+			p->modulation = QPSK;
+			break;
+		case MXL_HYDRA_MOD_8PSK:
+			p->modulation = PSK_8;
+			break;
+		default:
+			break;
+		}
+		switch ((MXL_HYDRA_ROLLOFF_E) regData[DMD_SPECTRUM_ROLL_OFF_ADDR]) {
+		case MXL_HYDRA_ROLLOFF_0_20:
+			p->rolloff = ROLLOFF_20;
+			break;
+		case MXL_HYDRA_ROLLOFF_0_35:
+			p->rolloff = ROLLOFF_35;
+			break;
+		case MXL_HYDRA_ROLLOFF_0_25:
+			p->rolloff = ROLLOFF_25;
+			break;
+		default:
+			break;
+		}
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int set_input(struct dvb_frontend *fe, int input)
+{
+	struct mxl *state = fe->demodulator_priv;
+	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
+
+	state->tuner = p->input = input;
+	return 0;
+}
+
+static struct dvb_frontend_ops mxl_ops = {
+	.delsys = { SYS_DVBS, SYS_DVBS2, SYS_DSS },
+	.xbar   = { 4, 0, 8 }, /* tuner_max, demod id, demod_max */
+	.info = {
+		.name			= "MXL5XX",
+		.frequency_min		= 950000,
+		.frequency_max		= 2150000,
+		.frequency_stepsize	= 0,
+		.frequency_tolerance	= 0,
+		.symbol_rate_min	= 1000000,
+		.symbol_rate_max	= 45000000,
+		.caps			= FE_CAN_INVERSION_AUTO |
+					  FE_CAN_FEC_AUTO       |
+					  FE_CAN_QPSK           |
+					  FE_CAN_2G_MODULATION
+	},
+	.init				= init,
+	.release                        = release,
+	.get_frontend_algo              = get_algo,
+	.tune                           = tune,
+	.read_status			= read_status,
+	.sleep				= sleep,
+	.read_snr			= read_snr,
+	.read_ber			= read_ber,
+	.read_signal_strength		= read_signal_strength,
+	.read_ucblocks			= read_ucblocks,
+	.get_frontend                   = get_frontend,
+	.set_input                      = set_input,
+	.diseqc_send_master_cmd		= send_master_cmd,
+};
+
+static struct mxl_base *match_base(struct i2c_adapter  *i2c, u8 adr)
+{
+	struct mxl_base *p;
+
+	list_for_each_entry(p, &mxllist, mxllist)
+		if (p->i2c == i2c && p->adr == adr)
+			return p;
+	return NULL;
+}
+
+static void cfg_dev_xtal(struct mxl *state, u32 freq, u32 cap, u32 enable)
+{
+	if (state->base->can_clkout || !enable)
+		SET_REG_FIELD_DATA(AFE_REG_D2A_XTAL_EN_CLKOUT_1P8, enable);
+
+	if (freq == 24000000)
+		write_register(state, HYDRA_CRYSTAL_SETTING, 0);
+	else
+		write_register(state, HYDRA_CRYSTAL_SETTING, 1);
+
+	write_register(state, HYDRA_CRYSTAL_CAP, cap);
+}
+
+static u32 get_big_endian(u8 numOfBits, const u8 buf[])
+{
+	u32 retValue = 0;
+
+	switch (numOfBits) {
+	case 24:
+		retValue = (((u32) buf[0]) << 16) |
+			(((u32) buf[1]) << 8) | buf[2];
+		break;
+	case 32:
+		retValue = (((u32) buf[0]) << 24) |
+			(((u32) buf[1]) << 16) |
+			(((u32) buf[2]) << 8) | buf[3];
+		break;
+	default:
+		break;
+	}
+
+	return retValue;
+}
+
+static int write_fw_segment(struct mxl *state,
+			    u32 MemAddr, u32 totalSize, u8 *dataPtr)
+{
+	int status;
+	u32 dataCount = 0;
+	u32 size = 0;
+	u32 origSize = 0;
+	u8 *wBufPtr = NULL;
+	u32 blockSize = ((MXL_HYDRA_OEM_MAX_BLOCK_WRITE_LENGTH -
+			  (MXL_HYDRA_I2C_HDR_SIZE + MXL_HYDRA_REG_SIZE_IN_BYTES)) / 4) * 4;
+	u8 wMsgBuffer[MXL_HYDRA_OEM_MAX_BLOCK_WRITE_LENGTH -
+		      (MXL_HYDRA_I2C_HDR_SIZE + MXL_HYDRA_REG_SIZE_IN_BYTES)];
+
+	do {
+		size = origSize = (((u32)(dataCount + blockSize)) > totalSize) ?
+			(totalSize - dataCount) : blockSize;
+
+		if (origSize & 3)
+			size = (origSize + 4) & ~3;
+		wBufPtr = &wMsgBuffer[0];
+		memset((void *) wBufPtr, 0, size);
+		memcpy((void *) wBufPtr, (void *) dataPtr, origSize);
+		convert_endian(1, size, wBufPtr);
+		status  = write_firmware_block(state, MemAddr, size, wBufPtr);
+		if (status)
+			return status;
+		dataCount += size;
+		MemAddr   += size;
+		dataPtr   += size;
+	} while (dataCount < totalSize);
+
+	return status;
+}
+
+static int do_firmware_download(struct mxl *state, u8 *mbinBufferPtr, u32 mbinBufferSize)
+
+{
+	int status;
+	u32 index = 0;
+	u32 segLength = 0;
+	u32 segAddress = 0;
+	MBIN_FILE_T *mbinPtr  = (MBIN_FILE_T *)mbinBufferPtr;
+	MBIN_SEGMENT_T *segmentPtr;
+	MXL_BOOL_E xcpuFwFlag = MXL_FALSE;
+
+	if (mbinPtr->header.id != MBIN_FILE_HEADER_ID) {
+		pr_err("%s: Invalid file header ID (%c)\n",
+		       __func__, mbinPtr->header.id);
+		return -EINVAL;
+	}
+	status = write_register(state, FW_DL_SIGN_ADDR, 0);
+	if (status)
+		return status;
+	segmentPtr = (MBIN_SEGMENT_T *) (&mbinPtr->data[0]);
+	for (index = 0; index < mbinPtr->header.numSegments; index++) {
+		if (segmentPtr->header.id != MBIN_SEGMENT_HEADER_ID) {
+			pr_err("%s: Invalid segment header ID (%c)\n",
+			       __func__, segmentPtr->header.id);
+			return -EINVAL;
+		}
+		segLength  = get_big_endian(24, &(segmentPtr->header.len24[0]));
+		segAddress = get_big_endian(32, &(segmentPtr->header.address[0]));
+
+		if (state->base->type == MXL_HYDRA_DEVICE_568) {
+			if ((((segAddress & 0x90760000) == 0x90760000) ||
+			     ((segAddress & 0x90740000) == 0x90740000)) &&
+			    (xcpuFwFlag == MXL_FALSE)) {
+				SET_REG_FIELD_DATA(PRCM_PRCM_CPU_SOFT_RST_N, 1);
+				msleep(200);
+				write_register(state, 0x90720000, 0);
+				usleep_range(10000, 11000);
+				xcpuFwFlag = MXL_TRUE;
+			}
+			status = write_fw_segment(state, segAddress,
+						  segLength, (u8 *) segmentPtr->data);
+		} else {
+			if (((segAddress & 0x90760000) != 0x90760000) &&
+			    ((segAddress & 0x90740000) != 0x90740000))
+				status = write_fw_segment(state, segAddress,
+							  segLength, (u8 *) segmentPtr->data);
+		}
+		if (status)
+			return status;
+		segmentPtr = (MBIN_SEGMENT_T *)
+			&(segmentPtr->data[((segLength + 3) / 4) * 4]);
+	}
+	return status;
+}
+
+static int check_fw(u8 *mbin, u32 mbin_len)
+{
+	MBIN_FILE_HEADER_T *fh = (MBIN_FILE_HEADER_T *) mbin;
+	u32 flen = (fh->imageSize24[0] << 16) |
+		(fh->imageSize24[1] <<  8) | fh->imageSize24[2];
+	u8 *fw, cs = 0;
+	u32 i;
+
+	if (fh->id != 'M' || fh->fmtVersion != '1' || flen > 0x3FFF0) {
+		pr_info("Invalid FW Header\n");
+		return -1;
+	}
+	fw = mbin + sizeof(MBIN_FILE_HEADER_T);
+	for (i = 0; i < flen; i += 1)
+		cs += fw[i];
+	if (cs != fh->imageChecksum) {
+		pr_info("Invalid FW Checksum\n");
+		return -1;
+	}
+	return 0;
+}
+
+static int firmware_download(struct mxl *state, u8 *mbin, u32 mbin_len)
+{
+	int status;
+	u32 regData = 0;
+	MXL_HYDRA_SKU_COMMAND_T devSkuCfg;
+	u8 cmdSize = sizeof(MXL_HYDRA_SKU_COMMAND_T);
+	u8 cmdBuff[sizeof(MXL_HYDRA_SKU_COMMAND_T) + 6];
+
+	if (check_fw(mbin, mbin_len))
+		return -1;
+
+	/* put CPU into reset */
+	status = SET_REG_FIELD_DATA(PRCM_PRCM_CPU_SOFT_RST_N, 0);
+	if (status)
+		return status;
+	usleep_range(1000, 2000);
+
+	/* Reset TX FIFO's, BBAND, XBAR */
+	status = write_register(state, HYDRA_RESET_TRANSPORT_FIFO_REG,
+				HYDRA_RESET_TRANSPORT_FIFO_DATA);
+	if (status)
+		return status;
+	status = write_register(state, HYDRA_RESET_BBAND_REG,
+				HYDRA_RESET_BBAND_DATA);
+	if (status)
+		return status;
+	status = write_register(state, HYDRA_RESET_XBAR_REG,
+				HYDRA_RESET_XBAR_DATA);
+	if (status)
+		return status;
+
+	/* Disable clock to Baseband, Wideband, SerDes, Alias ext & Transport modules */
+	status = write_register(state, HYDRA_MODULES_CLK_2_REG, HYDRA_DISABLE_CLK_2);
+	if (status)
+		return status;
+	/* Clear Software & Host interrupt status - (Clear on read) */
+	status = read_register(state, HYDRA_PRCM_ROOT_CLK_REG, &regData);
+	if (status)
+		return status;
+	status = do_firmware_download(state, mbin, mbin_len);
+	if (status)
+		return status;
+
+	if (state->base->type == MXL_HYDRA_DEVICE_568) {
+		usleep_range(10000, 11000);
+
+		/* bring XCPU out of reset */
+		status = write_register(state, 0x90720000, 1);
+		if (status)
+			return status;
+		msleep(500);
+
+		/* Enable XCPU UART message processing in MCPU */
+		status = write_register(state, 0x9076B510, 1);
+		if (status)
+			return status;
+	} else {
+		/* Bring CPU out of reset */
+		status = SET_REG_FIELD_DATA(PRCM_PRCM_CPU_SOFT_RST_N, 1);
+		if (status)
+			return status;
+		/* Wait until FW boots */
+		msleep(150);
+	}
+
+	/* Initilize XPT XBAR */
+	status = write_register(state, XPT_DMD0_BASEADDR, 0x76543210);
+	if (status)
+		return status;
+
+	if (!firmware_is_alive(state))
+		return -1;
+
+	pr_info("Hydra FW alive. Hail!\n");
+
+	/* sometimes register values are wrong shortly after first heart beats */
+	msleep(50);
+
+	devSkuCfg.skuType = state->base->sku_type;
+	BUILD_HYDRA_CMD(MXL_HYDRA_DEV_CFG_SKU_CMD, MXL_CMD_WRITE,
+			cmdSize, &devSkuCfg, cmdBuff);
+	status = send_command(state, cmdSize + MXL_HYDRA_CMD_HEADER_SIZE, &cmdBuff[0]);
+
+	return status;
+}
+
+static int cfg_ts_pad_mux(struct mxl *state, MXL_BOOL_E enableSerialTS)
+{
+	int status = 0;
+	u32 padMuxValue = 0;
+
+	if (enableSerialTS == MXL_TRUE) {
+		padMuxValue = 0;
+		if ((state->base->type == MXL_HYDRA_DEVICE_541) ||
+		    (state->base->type == MXL_HYDRA_DEVICE_541S))
+			padMuxValue = 2;
+	} else {
+		if ((state->base->type == MXL_HYDRA_DEVICE_581) ||
+		    (state->base->type == MXL_HYDRA_DEVICE_581S))
+			padMuxValue = 2;
+		else
+			padMuxValue = 3;
+	}
+
+	switch (state->base->type) {
+	case MXL_HYDRA_DEVICE_561:
+	case MXL_HYDRA_DEVICE_581:
+	case MXL_HYDRA_DEVICE_541:
+	case MXL_HYDRA_DEVICE_541S:
+	case MXL_HYDRA_DEVICE_561S:
+	case MXL_HYDRA_DEVICE_581S:
+		status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_14_PINMUX_SEL, padMuxValue);
+		status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_15_PINMUX_SEL, padMuxValue);
+		status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_16_PINMUX_SEL, padMuxValue);
+		status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_17_PINMUX_SEL, padMuxValue);
+		status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_18_PINMUX_SEL, padMuxValue);
+		status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_19_PINMUX_SEL, padMuxValue);
+		status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_20_PINMUX_SEL, padMuxValue);
+		status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_21_PINMUX_SEL, padMuxValue);
+		status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_22_PINMUX_SEL, padMuxValue);
+		status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_23_PINMUX_SEL, padMuxValue);
+		status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_24_PINMUX_SEL, padMuxValue);
+		status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_25_PINMUX_SEL, padMuxValue);
+		status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_26_PINMUX_SEL, padMuxValue);
+		break;
+
+	case MXL_HYDRA_DEVICE_544:
+	case MXL_HYDRA_DEVICE_542:
+		status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_01_PINMUX_SEL, 1);
+		status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_02_PINMUX_SEL, 0);
+		status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_03_PINMUX_SEL, 0);
+		status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_04_PINMUX_SEL, 0);
+		status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_08_PINMUX_SEL, 0);
+		status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_27_PINMUX_SEL, 1);
+		status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_28_PINMUX_SEL, 1);
+		status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_29_PINMUX_SEL, 1);
+		status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_30_PINMUX_SEL, 1);
+		status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_32_PINMUX_SEL, 1);
+		status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_33_PINMUX_SEL, 1);
+		if (enableSerialTS == MXL_ENABLE) {
+			status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_09_PINMUX_SEL, 0);
+			status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_10_PINMUX_SEL, 0);
+			status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_11_PINMUX_SEL, 0);
+			status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_12_PINMUX_SEL, 0);
+			status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_13_PINMUX_SEL, 1);
+			status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_14_PINMUX_SEL, 1);
+			status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_15_PINMUX_SEL, 2);
+			status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_16_PINMUX_SEL, 2);
+			status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_17_PINMUX_SEL, 2);
+			status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_18_PINMUX_SEL, 2);
+			status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_19_PINMUX_SEL, 2);
+			status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_20_PINMUX_SEL, 2);
+			status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_21_PINMUX_SEL, 2);
+			status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_22_PINMUX_SEL, 2);
+			status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_23_PINMUX_SEL, 2);
+			status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_24_PINMUX_SEL, 2);
+			status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_25_PINMUX_SEL, 2);
+			status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_26_PINMUX_SEL, 2);
+		} else {
+			status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_09_PINMUX_SEL, 3);
+			status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_10_PINMUX_SEL, 3);
+			status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_11_PINMUX_SEL, 3);
+			status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_12_PINMUX_SEL, 3);
+			status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_13_PINMUX_SEL, 3);
+			status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_14_PINMUX_SEL, 3);
+			status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_15_PINMUX_SEL, 3);
+			status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_16_PINMUX_SEL, 3);
+			status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_17_PINMUX_SEL, 3);
+			status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_18_PINMUX_SEL, 3);
+			status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_19_PINMUX_SEL, 3);
+			status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_20_PINMUX_SEL, 3);
+			status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_21_PINMUX_SEL, 1);
+			status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_22_PINMUX_SEL, 1);
+			status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_23_PINMUX_SEL, 1);
+			status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_24_PINMUX_SEL, 1);
+			status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_25_PINMUX_SEL, 1);
+			status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_26_PINMUX_SEL, 1);
+		}
+		break;
+
+	case MXL_HYDRA_DEVICE_568:
+		if (enableSerialTS == MXL_FALSE) {
+			status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_02_PINMUX_SEL, 5);
+			status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_03_PINMUX_SEL, 5);
+			status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_04_PINMUX_SEL, 5);
+			status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_05_PINMUX_SEL, 5);
+			status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_06_PINMUX_SEL, 5);
+			status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_07_PINMUX_SEL, 5);
+			status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_08_PINMUX_SEL, 5);
+			status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_09_PINMUX_SEL, 5);
+			status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_10_PINMUX_SEL, 5);
+			status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_11_PINMUX_SEL, 5);
+			status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_12_PINMUX_SEL, 5);
+			status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_13_PINMUX_SEL, 5);
+
+			status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_14_PINMUX_SEL, padMuxValue);
+			status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_16_PINMUX_SEL, padMuxValue);
+			status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_17_PINMUX_SEL, padMuxValue);
+			status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_18_PINMUX_SEL, padMuxValue);
+			status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_19_PINMUX_SEL, padMuxValue);
+			status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_20_PINMUX_SEL, padMuxValue);
+			status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_21_PINMUX_SEL, padMuxValue);
+			status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_22_PINMUX_SEL, padMuxValue);
+			status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_23_PINMUX_SEL, padMuxValue);
+			status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_24_PINMUX_SEL, padMuxValue);
+			status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_25_PINMUX_SEL, padMuxValue);
+
+			status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_26_PINMUX_SEL, 5);
+			status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_27_PINMUX_SEL, 5);
+			status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_28_PINMUX_SEL, 5);
+			status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_29_PINMUX_SEL, 5);
+			status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_30_PINMUX_SEL, 5);
+			status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_31_PINMUX_SEL, 5);
+			status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_32_PINMUX_SEL, 5);
+			status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_33_PINMUX_SEL, 5);
+		} else {
+			status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_09_PINMUX_SEL, padMuxValue);
+			status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_10_PINMUX_SEL, padMuxValue);
+			status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_11_PINMUX_SEL, padMuxValue);
+			status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_12_PINMUX_SEL, padMuxValue);
+			status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_13_PINMUX_SEL, padMuxValue);
+			status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_14_PINMUX_SEL, padMuxValue);
+			status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_15_PINMUX_SEL, padMuxValue);
+			status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_16_PINMUX_SEL, padMuxValue);
+			status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_17_PINMUX_SEL, padMuxValue);
+			status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_18_PINMUX_SEL, padMuxValue);
+			status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_19_PINMUX_SEL, padMuxValue);
+		}
+		break;
+
+
+	case MXL_HYDRA_DEVICE_584:
+	default:
+		status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_09_PINMUX_SEL, padMuxValue);
+		status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_10_PINMUX_SEL, padMuxValue);
+		status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_11_PINMUX_SEL, padMuxValue);
+		status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_12_PINMUX_SEL, padMuxValue);
+		status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_13_PINMUX_SEL, padMuxValue);
+		status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_14_PINMUX_SEL, padMuxValue);
+		status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_15_PINMUX_SEL, padMuxValue);
+		status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_16_PINMUX_SEL, padMuxValue);
+		status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_17_PINMUX_SEL, padMuxValue);
+		status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_18_PINMUX_SEL, padMuxValue);
+		status |= SET_REG_FIELD_DATA(PAD_MUX_DIGIO_19_PINMUX_SEL, padMuxValue);
+		break;
+	}
+	return status;
+}
+
+
+static int set_drive_strength(struct mxl *state,
+			      MXL_HYDRA_TS_DRIVE_STRENGTH_E tsDriveStrength)
+{
+	int stat = 0;
+	u32 val;
+
+	read_register(state, 0x90000194, &val);
+	pr_info("DIGIO = %08x\n", val);
+	pr_info("set drive_strength = %u\n", tsDriveStrength);
+
+
+	stat |= SET_REG_FIELD_DATA(PAD_MUX_PAD_DRV_DIGIO_00, tsDriveStrength);
+	stat |= SET_REG_FIELD_DATA(PAD_MUX_PAD_DRV_DIGIO_05, tsDriveStrength);
+	stat |= SET_REG_FIELD_DATA(PAD_MUX_PAD_DRV_DIGIO_06, tsDriveStrength);
+	stat |= SET_REG_FIELD_DATA(PAD_MUX_PAD_DRV_DIGIO_11, tsDriveStrength);
+	stat |= SET_REG_FIELD_DATA(PAD_MUX_PAD_DRV_DIGIO_12, tsDriveStrength);
+	stat |= SET_REG_FIELD_DATA(PAD_MUX_PAD_DRV_DIGIO_13, tsDriveStrength);
+	stat |= SET_REG_FIELD_DATA(PAD_MUX_PAD_DRV_DIGIO_14, tsDriveStrength);
+	stat |= SET_REG_FIELD_DATA(PAD_MUX_PAD_DRV_DIGIO_16, tsDriveStrength);
+	stat |= SET_REG_FIELD_DATA(PAD_MUX_PAD_DRV_DIGIO_17, tsDriveStrength);
+	stat |= SET_REG_FIELD_DATA(PAD_MUX_PAD_DRV_DIGIO_18, tsDriveStrength);
+	stat |= SET_REG_FIELD_DATA(PAD_MUX_PAD_DRV_DIGIO_22, tsDriveStrength);
+	stat |= SET_REG_FIELD_DATA(PAD_MUX_PAD_DRV_DIGIO_23, tsDriveStrength);
+	stat |= SET_REG_FIELD_DATA(PAD_MUX_PAD_DRV_DIGIO_24, tsDriveStrength);
+	stat |= SET_REG_FIELD_DATA(PAD_MUX_PAD_DRV_DIGIO_25, tsDriveStrength);
+	stat |= SET_REG_FIELD_DATA(PAD_MUX_PAD_DRV_DIGIO_29, tsDriveStrength);
+	stat |= SET_REG_FIELD_DATA(PAD_MUX_PAD_DRV_DIGIO_30, tsDriveStrength);
+	stat |= SET_REG_FIELD_DATA(PAD_MUX_PAD_DRV_DIGIO_31, tsDriveStrength);
+
+	return stat;
+}
+
+
+static int enable_tuner(struct mxl *state, u32 tuner, u32 enable)
+{
+	int stat = 0;
+	MxL_HYDRA_TUNER_CMD ctrlTunerCmd;
+	u8 cmdSize = sizeof(ctrlTunerCmd);
+	u8 cmdBuff[MXL_HYDRA_OEM_MAX_CMD_BUFF_LEN];
+	u32 val, count = 10;
+
+	ctrlTunerCmd.tunerId = tuner;
+	ctrlTunerCmd.enable = enable;
+	BUILD_HYDRA_CMD(MXL_HYDRA_TUNER_ACTIVATE_CMD, MXL_CMD_WRITE,
+			cmdSize, &ctrlTunerCmd, cmdBuff);
+	stat = send_command(state, cmdSize + MXL_HYDRA_CMD_HEADER_SIZE, &cmdBuff[0]);
+	if (stat)
+		return stat;
+	read_register(state, HYDRA_TUNER_ENABLE_COMPLETE, &val);
+	while (--count && ((val >> tuner) & 1) != enable) {
+		msleep(20);
+		read_register(state, HYDRA_TUNER_ENABLE_COMPLETE, &val);
+	}
+	if (!count)
+		return -1;
+	read_register(state, HYDRA_TUNER_ENABLE_COMPLETE, &val);
+	pr_info("tuner %u ready = %u\n", tuner, (val >> tuner) & 1);
+
+	return 0;
+}
+
+
+static int config_ts(struct mxl *state, MXL_HYDRA_DEMOD_ID_E demodId,
+		     MXL_HYDRA_MPEGOUT_PARAM_T *mpegOutParamPtr)
+{
+	int status = 0;
+	u32 ncoCountMin = 0;
+	u32 clkType = 0;
+
+	MXL_REG_FIELD_T xpt_sync_polarity[MXL_HYDRA_DEMOD_MAX] = {
+		{XPT_SYNC_POLARITY0}, {XPT_SYNC_POLARITY1},
+		{XPT_SYNC_POLARITY2}, {XPT_SYNC_POLARITY3},
+		{XPT_SYNC_POLARITY4}, {XPT_SYNC_POLARITY5},
+		{XPT_SYNC_POLARITY6}, {XPT_SYNC_POLARITY7} };
+	MXL_REG_FIELD_T xpt_clock_polarity[MXL_HYDRA_DEMOD_MAX] = {
+		{XPT_CLOCK_POLARITY0}, {XPT_CLOCK_POLARITY1},
+		{XPT_CLOCK_POLARITY2}, {XPT_CLOCK_POLARITY3},
+		{XPT_CLOCK_POLARITY4}, {XPT_CLOCK_POLARITY5},
+		{XPT_CLOCK_POLARITY6}, {XPT_CLOCK_POLARITY7} };
+	MXL_REG_FIELD_T xpt_valid_polarity[MXL_HYDRA_DEMOD_MAX] = {
+		{XPT_VALID_POLARITY0}, {XPT_VALID_POLARITY1},
+		{XPT_VALID_POLARITY2}, {XPT_VALID_POLARITY3},
+		{XPT_VALID_POLARITY4}, {XPT_VALID_POLARITY5},
+		{XPT_VALID_POLARITY6}, {XPT_VALID_POLARITY7} };
+	MXL_REG_FIELD_T xpt_ts_clock_phase[MXL_HYDRA_DEMOD_MAX] = {
+		{XPT_TS_CLK_PHASE0}, {XPT_TS_CLK_PHASE1},
+		{XPT_TS_CLK_PHASE2}, {XPT_TS_CLK_PHASE3},
+		{XPT_TS_CLK_PHASE4}, {XPT_TS_CLK_PHASE5},
+		{XPT_TS_CLK_PHASE6}, {XPT_TS_CLK_PHASE7} };
+	MXL_REG_FIELD_T xpt_lsb_first[MXL_HYDRA_DEMOD_MAX] = {
+		{XPT_LSB_FIRST0}, {XPT_LSB_FIRST1}, {XPT_LSB_FIRST2}, {XPT_LSB_FIRST3},
+		{XPT_LSB_FIRST4}, {XPT_LSB_FIRST5}, {XPT_LSB_FIRST6}, {XPT_LSB_FIRST7} };
+	MXL_REG_FIELD_T xpt_sync_byte[MXL_HYDRA_DEMOD_MAX] = {
+		{XPT_SYNC_FULL_BYTE0}, {XPT_SYNC_FULL_BYTE1},
+		{XPT_SYNC_FULL_BYTE2}, {XPT_SYNC_FULL_BYTE3},
+		{XPT_SYNC_FULL_BYTE4}, {XPT_SYNC_FULL_BYTE5},
+		{XPT_SYNC_FULL_BYTE6}, {XPT_SYNC_FULL_BYTE7} };
+	MXL_REG_FIELD_T xpt_enable_output[MXL_HYDRA_DEMOD_MAX] = {
+		{XPT_ENABLE_OUTPUT0}, {XPT_ENABLE_OUTPUT1},
+		{XPT_ENABLE_OUTPUT2}, {XPT_ENABLE_OUTPUT3},
+		{XPT_ENABLE_OUTPUT4}, {XPT_ENABLE_OUTPUT5},
+		{XPT_ENABLE_OUTPUT6}, {XPT_ENABLE_OUTPUT7} };
+	MXL_REG_FIELD_T xpt_err_replace_sync[MXL_HYDRA_DEMOD_MAX] = {
+		{XPT_ERROR_REPLACE_SYNC0}, {XPT_ERROR_REPLACE_SYNC1},
+		{XPT_ERROR_REPLACE_SYNC2}, {XPT_ERROR_REPLACE_SYNC3},
+		{XPT_ERROR_REPLACE_SYNC4}, {XPT_ERROR_REPLACE_SYNC5},
+		{XPT_ERROR_REPLACE_SYNC6}, {XPT_ERROR_REPLACE_SYNC7} };
+	MXL_REG_FIELD_T xpt_err_replace_valid[MXL_HYDRA_DEMOD_MAX] = {
+		{XPT_ERROR_REPLACE_VALID0}, {XPT_ERROR_REPLACE_VALID1},
+		{XPT_ERROR_REPLACE_VALID2}, {XPT_ERROR_REPLACE_VALID3},
+		{XPT_ERROR_REPLACE_VALID4}, {XPT_ERROR_REPLACE_VALID5},
+		{XPT_ERROR_REPLACE_VALID6}, {XPT_ERROR_REPLACE_VALID7} };
+	MXL_REG_FIELD_T xpt_continuous_clock[MXL_HYDRA_DEMOD_MAX] = {
+		{XPT_TS_CLK_OUT_EN0}, {XPT_TS_CLK_OUT_EN1},
+		{XPT_TS_CLK_OUT_EN2}, {XPT_TS_CLK_OUT_EN3},
+		{XPT_TS_CLK_OUT_EN4}, {XPT_TS_CLK_OUT_EN5},
+		{XPT_TS_CLK_OUT_EN6}, {XPT_TS_CLK_OUT_EN7} };
+	MXL_REG_FIELD_T xpt_nco_clock_rate[MXL_HYDRA_DEMOD_MAX] = {
+		{XPT_NCO_COUNT_MIN0}, {XPT_NCO_COUNT_MIN1},
+		{XPT_NCO_COUNT_MIN2}, {XPT_NCO_COUNT_MIN3},
+		{XPT_NCO_COUNT_MIN4}, {XPT_NCO_COUNT_MIN5},
+		{XPT_NCO_COUNT_MIN6}, {XPT_NCO_COUNT_MIN7} };
+
+	demodId = state->base->ts_map[demodId];
+
+	if (mpegOutParamPtr->enable == MXL_ENABLE) {
+		if (mpegOutParamPtr->mpegMode == MXL_HYDRA_MPEG_MODE_PARALLEL)	{
+		} else {
+			cfg_ts_pad_mux(state, MXL_TRUE);
+			SET_REG_FIELD_DATA(XPT_ENABLE_PARALLEL_OUTPUT, MXL_FALSE);
+		}
+	}
+
+	ncoCountMin = (u32)(MXL_HYDRA_NCO_CLK/mpegOutParamPtr->maxMpegClkRate);
+
+	if (state->base->chipversion >= 2) {
+		status |= update_by_mnemonic(state,
+					     xpt_nco_clock_rate[demodId].regAddr, /* Reg Addr */
+					     xpt_nco_clock_rate[demodId].lsbPos, /* LSB pos */
+					     xpt_nco_clock_rate[demodId].numOfBits, /* Num of bits */
+					     ncoCountMin); /* Data */
+	} else
+		SET_REG_FIELD_DATA(XPT_NCO_COUNT_MIN, ncoCountMin);
+
+	if (mpegOutParamPtr->mpegClkType == MXL_HYDRA_MPEG_CLK_CONTINUOUS)
+		clkType = 1;
+
+	if (mpegOutParamPtr->mpegMode < MXL_HYDRA_MPEG_MODE_PARALLEL) {
+		status  |= update_by_mnemonic(state,
+					      xpt_continuous_clock[demodId].regAddr,
+					      xpt_continuous_clock[demodId].lsbPos,
+					      xpt_continuous_clock[demodId].numOfBits,
+					      clkType);
+	} else
+		SET_REG_FIELD_DATA(XPT_TS_CLK_OUT_EN_PARALLEL, clkType);
+
+	status |= update_by_mnemonic(state,
+				     xpt_sync_polarity[demodId].regAddr,
+				     xpt_sync_polarity[demodId].lsbPos,
+				     xpt_sync_polarity[demodId].numOfBits,
+				     mpegOutParamPtr->mpegSyncPol);
+
+	status |= update_by_mnemonic(state,
+				     xpt_valid_polarity[demodId].regAddr,
+				     xpt_valid_polarity[demodId].lsbPos,
+				     xpt_valid_polarity[demodId].numOfBits,
+				     mpegOutParamPtr->mpegValidPol);
+
+	status |= update_by_mnemonic(state,
+				     xpt_clock_polarity[demodId].regAddr,
+				     xpt_clock_polarity[demodId].lsbPos,
+				     xpt_clock_polarity[demodId].numOfBits,
+				     mpegOutParamPtr->mpegClkPol);
+
+	status |= update_by_mnemonic(state,
+				     xpt_sync_byte[demodId].regAddr,
+				     xpt_sync_byte[demodId].lsbPos,
+				     xpt_sync_byte[demodId].numOfBits,
+				     mpegOutParamPtr->mpegSyncPulseWidth);
+
+	status |= update_by_mnemonic(state,
+				     xpt_ts_clock_phase[demodId].regAddr,
+				     xpt_ts_clock_phase[demodId].lsbPos,
+				     xpt_ts_clock_phase[demodId].numOfBits,
+				     mpegOutParamPtr->mpegClkPhase);
+
+	status |= update_by_mnemonic(state,
+				     xpt_lsb_first[demodId].regAddr,
+				     xpt_lsb_first[demodId].lsbPos,
+				     xpt_lsb_first[demodId].numOfBits,
+				     mpegOutParamPtr->lsbOrMsbFirst);
+
+	switch (mpegOutParamPtr->mpegErrorIndication) {
+	case MXL_HYDRA_MPEG_ERR_REPLACE_SYNC:
+		status |= update_by_mnemonic(state,
+					     xpt_err_replace_sync[demodId].regAddr,
+					     xpt_err_replace_sync[demodId].lsbPos,
+					     xpt_err_replace_sync[demodId].numOfBits,
+					     MXL_TRUE);
+		status |= update_by_mnemonic(state,
+					     xpt_err_replace_valid[demodId].regAddr,
+					     xpt_err_replace_valid[demodId].lsbPos,
+					     xpt_err_replace_valid[demodId].numOfBits,
+					     MXL_FALSE);
+		break;
+
+	case MXL_HYDRA_MPEG_ERR_REPLACE_VALID:
+		status |= update_by_mnemonic(state,
+					     xpt_err_replace_sync[demodId].regAddr,
+					     xpt_err_replace_sync[demodId].lsbPos,
+					     xpt_err_replace_sync[demodId].numOfBits,
+					     MXL_FALSE);
+
+		status |= update_by_mnemonic(state,
+					     xpt_err_replace_valid[demodId].regAddr,
+					     xpt_err_replace_valid[demodId].lsbPos,
+					     xpt_err_replace_valid[demodId].numOfBits,
+					     MXL_TRUE);
+		break;
+
+	case MXL_HYDRA_MPEG_ERR_INDICATION_DISABLED:
+	default:
+		status |= update_by_mnemonic(state,
+					     xpt_err_replace_sync[demodId].regAddr,
+					     xpt_err_replace_sync[demodId].lsbPos,
+					     xpt_err_replace_sync[demodId].numOfBits,
+					     MXL_FALSE);
+
+		status |= update_by_mnemonic(state,
+					     xpt_err_replace_valid[demodId].regAddr,
+					     xpt_err_replace_valid[demodId].lsbPos,
+					     xpt_err_replace_valid[demodId].numOfBits,
+					     MXL_FALSE);
+
+		break;
+
+	}
+
+	if (mpegOutParamPtr->mpegMode != MXL_HYDRA_MPEG_MODE_PARALLEL) {
+		status |= update_by_mnemonic(state,
+					     xpt_enable_output[demodId].regAddr,
+					     xpt_enable_output[demodId].lsbPos,
+					     xpt_enable_output[demodId].numOfBits,
+					     mpegOutParamPtr->enable);
+	}
+	return status;
+}
+
+static int config_mux(struct mxl *state)
+{
+	SET_REG_FIELD_DATA(XPT_ENABLE_OUTPUT0, 0);
+	SET_REG_FIELD_DATA(XPT_ENABLE_OUTPUT1, 0);
+	SET_REG_FIELD_DATA(XPT_ENABLE_OUTPUT2, 0);
+	SET_REG_FIELD_DATA(XPT_ENABLE_OUTPUT3, 0);
+	SET_REG_FIELD_DATA(XPT_ENABLE_OUTPUT4, 0);
+	SET_REG_FIELD_DATA(XPT_ENABLE_OUTPUT5, 0);
+	SET_REG_FIELD_DATA(XPT_ENABLE_OUTPUT6, 0);
+	SET_REG_FIELD_DATA(XPT_ENABLE_OUTPUT7, 0);
+	SET_REG_FIELD_DATA(XPT_STREAM_MUXMODE0, 1);
+	SET_REG_FIELD_DATA(XPT_STREAM_MUXMODE1, 1);
+	return 0;
+}
+
+static int load_fw(struct mxl *state, struct mxl5xx_cfg *cfg)
+{
+	int stat = 0;
+	u8 *buf;
+
+	if (cfg->fw)
+		return firmware_download(state, cfg->fw, cfg->fw_len);
+
+	if (!cfg->fw_read)
+		return -1;
+
+	buf = vmalloc(0x40000);
+	if (!buf)
+		return -ENOMEM;
+
+	cfg->fw_read(cfg->fw_priv, buf, 0x40000);
+	stat = firmware_download(state, buf, 0x40000);
+	vfree(buf);
+
+	return stat;
+}
+
+static int validate_sku(struct mxl *state)
+{
+	u32 padMuxBond, prcmChipId, prcmSoCId;
+	int status;
+	u32 type = state->base->type;
+
+	status = GET_REG_FIELD_DATA(PAD_MUX_BOND_OPTION, &padMuxBond);
+	status |= GET_REG_FIELD_DATA(PRCM_PRCM_CHIP_ID, &prcmChipId);
+	status |= GET_REG_FIELD_DATA(PRCM_AFE_SOC_ID, &prcmSoCId);
+	if (status)
+		return -1;
+
+	pr_info("padMuxBond=%08x, prcmChipId=%08x, prcmSoCId=%08x\n",
+		padMuxBond, prcmChipId, prcmSoCId);
+
+	if (prcmChipId != 0x560) {
+		switch (padMuxBond) {
+		case MXL_HYDRA_SKU_ID_581:
+			if (type == MXL_HYDRA_DEVICE_581)
+				return 0;
+			if (type == MXL_HYDRA_DEVICE_581S) {
+				state->base->type = MXL_HYDRA_DEVICE_581;
+				return 0;
+			}
+			break;
+		case MXL_HYDRA_SKU_ID_584:
+			if (type == MXL_HYDRA_DEVICE_584)
+				return 0;
+			break;
+		case MXL_HYDRA_SKU_ID_544:
+			if (type == MXL_HYDRA_DEVICE_544)
+				return 0;
+			if (type == MXL_HYDRA_DEVICE_542)
+				return 0;
+			break;
+		case MXL_HYDRA_SKU_ID_582:
+			if (type == MXL_HYDRA_DEVICE_582)
+				return 0;
+			break;
+		default:
+			return -1;
+		}
+	} else {
+
+	}
+	return -1;
+}
+
+static int get_fwinfo(struct mxl *state)
+{
+	int status;
+	u32 val = 0;
+
+	status = GET_REG_FIELD_DATA(PAD_MUX_BOND_OPTION, &val);
+	if (status)
+		return status;
+	pr_info("chipID=%08x\n", val);
+
+	status = GET_REG_FIELD_DATA(PRCM_AFE_CHIP_MMSK_VER, &val);
+	if (status)
+		return status;
+	pr_info("chipVer=%08x\n", val);
+
+	status = read_register(state, HYDRA_FIRMWARE_VERSION, &val);
+	if (status)
+		return status;
+	pr_info("FWVer=%08x\n", val);
+
+	state->base->fwversion = val;
+	return status;
+}
+
+
+static u8 tsMap1_to_1[MXL_HYDRA_DEMOD_MAX] = {
+	MXL_HYDRA_DEMOD_ID_0,
+	MXL_HYDRA_DEMOD_ID_1,
+	MXL_HYDRA_DEMOD_ID_2,
+	MXL_HYDRA_DEMOD_ID_3,
+	MXL_HYDRA_DEMOD_ID_4,
+	MXL_HYDRA_DEMOD_ID_5,
+	MXL_HYDRA_DEMOD_ID_6,
+	MXL_HYDRA_DEMOD_ID_7,
+};
+
+static u8 tsMap54x[MXL_HYDRA_DEMOD_MAX] = {
+	MXL_HYDRA_DEMOD_ID_2,
+	MXL_HYDRA_DEMOD_ID_3,
+	MXL_HYDRA_DEMOD_ID_4,
+	MXL_HYDRA_DEMOD_ID_5,
+	MXL_HYDRA_DEMOD_MAX,
+	MXL_HYDRA_DEMOD_MAX,
+	MXL_HYDRA_DEMOD_MAX,
+	MXL_HYDRA_DEMOD_MAX,
+};
+
+static int probe(struct mxl *state, struct mxl5xx_cfg *cfg)
+{
+	u32 chipver;
+	int fw, status, j;
+	MXL_HYDRA_MPEGOUT_PARAM_T mpegInterfaceCfg;
+
+	state->base->ts_map = tsMap1_to_1;
+
+	switch (state->base->type) {
+	case MXL_HYDRA_DEVICE_581:
+	case MXL_HYDRA_DEVICE_581S:
+		state->base->can_clkout = 1;
+		state->base->demod_num = 8;
+		state->base->tuner_num = 1;
+		state->base->sku_type = MXL_HYDRA_SKU_TYPE_581;
+		break;
+	case MXL_HYDRA_DEVICE_582:
+		state->base->can_clkout = 1;
+		state->base->demod_num = 8;
+		state->base->tuner_num = 3;
+		state->base->sku_type = MXL_HYDRA_SKU_TYPE_582;
+		break;
+	case MXL_HYDRA_DEVICE_585:
+		state->base->can_clkout = 0;
+		state->base->demod_num = 8;
+		state->base->tuner_num = 4;
+		state->base->sku_type = MXL_HYDRA_SKU_TYPE_585;
+		break;
+	case MXL_HYDRA_DEVICE_544:
+		state->base->can_clkout = 0;
+		state->base->demod_num = 4;
+		state->base->tuner_num = 4;
+		state->base->sku_type = MXL_HYDRA_SKU_TYPE_544;
+		state->base->ts_map = tsMap54x;
+		break;
+	case MXL_HYDRA_DEVICE_541:
+	case MXL_HYDRA_DEVICE_541S:
+		state->base->can_clkout = 0;
+		state->base->demod_num = 4;
+		state->base->tuner_num = 1;
+		state->base->sku_type = MXL_HYDRA_SKU_TYPE_541;
+		state->base->ts_map = tsMap54x;
+		break;
+	case MXL_HYDRA_DEVICE_561:
+	case MXL_HYDRA_DEVICE_561S:
+		state->base->can_clkout = 0;
+		state->base->demod_num = 6;
+		state->base->tuner_num = 1;
+		state->base->sku_type = MXL_HYDRA_SKU_TYPE_561;
+		break;
+	case MXL_HYDRA_DEVICE_568:
+		state->base->can_clkout = 0;
+		state->base->demod_num = 8;
+		state->base->tuner_num = 1;
+		state->base->chan_bond = 1;
+		state->base->sku_type = MXL_HYDRA_SKU_TYPE_568;
+		break;
+	case MXL_HYDRA_DEVICE_542:
+		state->base->can_clkout = 1;
+		state->base->demod_num = 4;
+		state->base->tuner_num = 3;
+		state->base->sku_type = MXL_HYDRA_SKU_TYPE_542;
+		state->base->ts_map = tsMap54x;
+		break;
+	case MXL_HYDRA_DEVICE_TEST:
+	case MXL_HYDRA_DEVICE_584:
+	default:
+		state->base->can_clkout = 0;
+		state->base->demod_num = 8;
+		state->base->tuner_num = 4;
+		state->base->sku_type = MXL_HYDRA_SKU_TYPE_584;
+		break;
+	}
+
+	status = validate_sku(state);
+	if (status)
+		return status;
+
+	SET_REG_FIELD_DATA(PRCM_AFE_REG_CLOCK_ENABLE, 1);
+	SET_REG_FIELD_DATA(PRCM_PRCM_AFE_REG_SOFT_RST_N, 1);
+	status = GET_REG_FIELD_DATA(PRCM_CHIP_VERSION, &chipver);
+	if (status)
+		state->base->chipversion = 0;
+	else
+		state->base->chipversion = (chipver == 2) ? 2 : 1;
+	pr_info("Hydra chip version %u\n", state->base->chipversion);
+
+	cfg_dev_xtal(state, cfg->clk, cfg->cap, 0);
+
+	fw = firmware_is_alive(state);
+	if (!fw) {
+		status = load_fw(state, cfg);
+		if (status)
+			return status;
+	}
+	get_fwinfo(state);
+
+	config_mux(state);
+	mpegInterfaceCfg.enable = MXL_ENABLE;
+	mpegInterfaceCfg.lsbOrMsbFirst = MXL_HYDRA_MPEG_SERIAL_MSB_1ST;
+	/*  supports only (0-104&139)MHz */
+	if (cfg->ts_clk)
+		mpegInterfaceCfg.maxMpegClkRate = cfg->ts_clk;
+	else
+		mpegInterfaceCfg.maxMpegClkRate = 69; /* 139; */
+	mpegInterfaceCfg.mpegClkPhase = MXL_HYDRA_MPEG_CLK_PHASE_SHIFT_0_DEG;
+	mpegInterfaceCfg.mpegClkPol = MXL_HYDRA_MPEG_CLK_IN_PHASE;
+	/* MXL_HYDRA_MPEG_CLK_GAPPED; */
+	mpegInterfaceCfg.mpegClkType = MXL_HYDRA_MPEG_CLK_CONTINUOUS;
+	mpegInterfaceCfg.mpegErrorIndication =
+		MXL_HYDRA_MPEG_ERR_INDICATION_DISABLED;
+	mpegInterfaceCfg.mpegMode = MXL_HYDRA_MPEG_MODE_SERIAL_3_WIRE;
+	mpegInterfaceCfg.mpegSyncPol  = MXL_HYDRA_MPEG_ACTIVE_HIGH;
+	mpegInterfaceCfg.mpegSyncPulseWidth  = MXL_HYDRA_MPEG_SYNC_WIDTH_BIT;
+	mpegInterfaceCfg.mpegValidPol  = MXL_HYDRA_MPEG_ACTIVE_HIGH;
+
+
+	for (j = 0; j < state->base->demod_num; j++) {
+		status = config_ts(state, (MXL_HYDRA_DEMOD_ID_E) j,
+				   &mpegInterfaceCfg);
+		if (status)
+			return status;
+	}
+	set_drive_strength(state, 1);
+	return 0;
+}
+
+struct dvb_frontend *mxl5xx_attach(struct i2c_adapter *i2c,
+				   struct mxl5xx_cfg *cfg,
+				   u32 demod, u32 tuner)
+{
+	struct mxl *state;
+	struct mxl_base *base;
+
+	state = kzalloc(sizeof(struct mxl), GFP_KERNEL);
+	if (!state)
+		return NULL;
+
+	state->demod = demod;
+	state->tuner = tuner;
+	state->tuner_in_use = 0xffffffff;
+
+	base = match_base(i2c, cfg->adr);
+	if (base) {
+		base->count++;
+		if (base->count > base->demod_num)
+			goto fail;
+		state->base = base;
+	} else {
+		base = kzalloc(sizeof(struct mxl_base), GFP_KERNEL);
+		if (!base)
+			goto fail;
+		base->i2c = i2c;
+		base->adr = cfg->adr;
+		base->type = cfg->type;
+		base->count = 1;
+		mutex_init(&base->i2c_lock);
+		mutex_init(&base->status_lock);
+		mutex_init(&base->tune_lock);
+		INIT_LIST_HEAD(&base->mxls);
+
+		state->base = base;
+		if (probe(state, cfg) < 0) {
+			kfree(base);
+			goto fail;
+		}
+		list_add(&base->mxllist, &mxllist);
+	}
+	state->fe.ops               = mxl_ops;
+	state->fe.ops.xbar[1]       = demod;
+	state->fe.demodulator_priv  = state;
+	state->fe.dtv_property_cache.input = tuner;
+	list_add(&state->mxl, &base->mxls);
+	return &state->fe;
+
+fail:
+	kfree(state);
+	return NULL;
+}
+EXPORT_SYMBOL_GPL(mxl5xx_attach);
+
+
+MODULE_DESCRIPTION("MXL5XX driver");
+MODULE_AUTHOR("Ralph and Marcus Metzler, Metzler Brothers Systementwicklung GbR");
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/dvb-frontends/mxl5xx.h b/drivers/media/dvb-frontends/mxl5xx.h
new file mode 100644
index 0000000..e02ba1d
--- /dev/null
+++ b/drivers/media/dvb-frontends/mxl5xx.h
@@ -0,0 +1,39 @@
+#ifndef _MXL5XX_H_
+#define _MXL5XX_H_
+
+#include <linux/types.h>
+#include <linux/i2c.h>
+
+struct mxl5xx_cfg {
+	u8   adr;
+	u8   type;
+	u32  cap;
+	u32  clk;
+	u32  ts_clk;
+
+	u8  *fw;
+	u32  fw_len;
+
+	int (*fw_read)(void *priv, u8 *buf, u32 len);
+	void *fw_priv;
+};
+
+#if IS_REACHABLE(CONFIG_DVB_MXL5XX)
+
+extern struct dvb_frontend *mxl5xx_attach(struct i2c_adapter *i2c,
+					  struct mxl5xx_cfg *cfg,
+					  u32 demod, u32 tuner);
+
+#else
+
+static inline struct dvb_frontend *mxl5xx_attach(struct i2c_adapter *i2c,
+						 struct mxl5xx_cfg *cfg,
+						 u32 demod, u32 tuner)
+{
+	pr_warn("%s: driver disabled by Kconfig\n", __func__);
+	return NULL;
+}
+
+#endif /* CONFIG_DVB_MXL5XX */
+
+#endif /* _MXL5XX_H_ */
diff --git a/drivers/media/dvb-frontends/mxl5xx_defs.h b/drivers/media/dvb-frontends/mxl5xx_defs.h
new file mode 100644
index 0000000..35b5c0b
--- /dev/null
+++ b/drivers/media/dvb-frontends/mxl5xx_defs.h
@@ -0,0 +1,818 @@
+/*
+ * Defines for the Maxlinear MX58x family of tuners/demods
+ *
+ * Copyright (C) 2014 Digital Devices GmbH
+ *
+ * based on code:
+ * Copyright (c) 2011-2013 MaxLinear, Inc. All rights reserved
+ * which was released under GPL V2
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2, as published by the Free Software Foundation.
+ */
+
+typedef enum
+{
+  MXL_DISABLE = 0,
+  MXL_ENABLE  = 1,
+
+  MXL_FALSE = 0,
+  MXL_TRUE  = 1,
+
+  MXL_INVALID = 0,
+  MXL_VALID   = 1,
+
+  MXL_NO      = 0,
+  MXL_YES     = 1,
+
+  MXL_OFF     = 0,
+  MXL_ON      = 1
+} MXL_BOOL_E;
+
+// Firmware-Host Command IDs
+typedef enum
+{
+  //--Device command IDs--
+  MXL_HYDRA_DEV_NO_OP_CMD = 0, //No OP
+
+  MXL_HYDRA_DEV_SET_POWER_MODE_CMD = 1,
+  MXL_HYDRA_DEV_SET_OVERWRITE_DEF_CMD = 2,
+
+  // Host-used CMD, not used by firmware
+  MXL_HYDRA_DEV_FIRMWARE_DOWNLOAD_CMD = 3,
+
+  // Additional CONTROL types from DTV
+  MXL_HYDRA_DEV_SET_BROADCAST_PID_STB_ID_CMD = 4,
+  MXL_HYDRA_DEV_GET_PMM_SLEEP_CMD = 5,
+
+  //--Tuner command IDs--
+  MXL_HYDRA_TUNER_TUNE_CMD = 6,
+  MXL_HYDRA_TUNER_GET_STATUS_CMD = 7,
+
+  //--Demod command IDs--
+  MXL_HYDRA_DEMOD_SET_PARAM_CMD = 8,
+  MXL_HYDRA_DEMOD_GET_STATUS_CMD = 9,
+
+  MXL_HYDRA_DEMOD_RESET_FEC_COUNTER_CMD = 10,
+
+  MXL_HYDRA_DEMOD_SET_PKT_NUM_CMD = 11,
+
+  MXL_HYDRA_DEMOD_SET_IQ_SOURCE_CMD = 12,
+  MXL_HYDRA_DEMOD_GET_IQ_DATA_CMD = 13,
+
+  MXL_HYDRA_DEMOD_GET_M68HC05_VER_CMD = 14,
+
+  MXL_HYDRA_DEMOD_SET_ERROR_COUNTER_MODE_CMD = 15,
+
+  //--- ABORT channel tune
+  MXL_HYDRA_ABORT_TUNE_CMD = 16, // Abort current tune command.
+
+  //--SWM/FSK command IDs--
+  MXL_HYDRA_FSK_RESET_CMD = 17,
+  MXL_HYDRA_FSK_MSG_CMD = 18,
+  MXL_HYDRA_FSK_SET_OP_MODE_CMD = 19,
+
+  //--DiSeqC command IDs--
+  MXL_HYDRA_DISEQC_MSG_CMD = 20,
+  MXL_HYDRA_DISEQC_COPY_MSG_TO_MAILBOX = 21,
+  MXL_HYDRA_DISEQC_CFG_MSG_CMD = 22,
+
+  //--- FFT Debug Command IDs--
+  MXL_HYDRA_REQ_FFT_SPECTRUM_CMD = 23,
+
+  // -- Demod scramblle code
+  MXL_HYDRA_DEMOD_SCRAMBLE_CODE_CMD = 24,
+
+  //---For host to know how many commands in total---
+  MXL_HYDRA_LAST_HOST_CMD = 25,
+
+  MXL_HYDRA_DEMOD_INTR_TYPE_CMD = 47,
+  MXL_HYDRA_DEV_INTR_CLEAR_CMD = 48,
+  MXL_HYDRA_TUNER_SPECTRUM_REQ_CMD = 53,
+  MXL_HYDRA_TUNER_ACTIVATE_CMD = 55,
+  MXL_HYDRA_DEV_CFG_POWER_MODE_CMD = 56,
+  MXL_HYDRA_DEV_XTAL_CAP_CMD = 57,
+  MXL_HYDRA_DEV_CFG_SKU_CMD = 58,
+  MXL_HYDRA_TUNER_SPECTRUM_MIN_GAIN_CMD = 59,
+  MXL_HYDRA_DISEQC_CONT_TONE_CFG = 60,
+  MXL_HYDRA_DEV_RF_WAKE_UP_CMD = 61,
+  MXL_HYDRA_DEMOD_CFG_EQ_CTRL_PARAM_CMD = 62,
+  MXL_HYDRA_DEMOD_FREQ_OFFSET_SEARCH_RANGE_CMD = 63,
+  MXL_HYDRA_DEV_REQ_PWR_FROM_ADCRSSI_CMD = 64,
+
+  MXL_XCPU_PID_FLT_CFG_CMD = 65,
+  MXL_XCPU_SHMEM_TEST_CMD = 66,
+  MXL_XCPU_ABORT_TUNE_CMD = 67,
+  MXL_XCPU_CHAN_TUNE_CMD = 68,
+  MXL_XCPU_FLT_BOND_HDRS_CMD = 69,
+
+  MXL_HYDRA_DEV_BROADCAST_WAKE_UP_CMD = 70,
+  MXL_HYDRA_FSK_CFG_FSK_FREQ_CMD = 71,
+  MXL_HYDRA_FSK_POWER_DOWN_CMD = 72,
+  MXL_XCPU_CLEAR_CB_STATS_CMD = 73,
+  MXL_XCPU_CHAN_BOND_RESTART_CMD = 74
+} MXL_HYDRA_HOST_CMD_ID_E;
+
+#define MXL_ENABLE_BIG_ENDIAN        (0)
+
+#define MXL_HYDRA_OEM_MAX_BLOCK_WRITE_LENGTH   248
+
+#define MXL_HYDRA_OEM_MAX_CMD_BUFF_LEN        (248)
+
+#define MXL_HYDRA_CAP_MIN     10
+#define MXL_HYDRA_CAP_MAX     33
+
+#define MXL_HYDRA_PLID_REG_READ       0xFB   // Read register PLID
+#define MXL_HYDRA_PLID_REG_WRITE      0xFC   // Write register PLID
+
+#define MXL_HYDRA_PLID_CMD_READ       0xFD   // Command Read PLID
+#define MXL_HYDRA_PLID_CMD_WRITE      0xFE   // Command Write PLID
+
+#define MXL_HYDRA_REG_SIZE_IN_BYTES   4      // Hydra register size in bytes
+#define MXL_HYDRA_I2C_HDR_SIZE        (2 * sizeof(u8))   // PLID + LEN(0xFF)
+#define MXL_HYDRA_CMD_HEADER_SIZE     (MXL_HYDRA_REG_SIZE_IN_BYTES + MXL_HYDRA_I2C_HDR_SIZE)
+
+#define MXL_HYDRA_SKU_ID_581 0
+#define MXL_HYDRA_SKU_ID_584 1
+#define MXL_HYDRA_SKU_ID_585 2
+#define MXL_HYDRA_SKU_ID_544 3
+#define MXL_HYDRA_SKU_ID_561 4
+#define MXL_HYDRA_SKU_ID_582 5
+#define MXL_HYDRA_SKU_ID_568 6
+
+// macro for register write data buffer size (PLID + LEN (0xFF) + RegAddr + RegData)
+#define MXL_HYDRA_REG_WRITE_LEN       (MXL_HYDRA_I2C_HDR_SIZE + (2 * MXL_HYDRA_REG_SIZE_IN_BYTES))
+
+// maro to extract a single byte from 4-byte(32-bit) data
+#define GET_BYTE(x,n)  (((x) >> (8*(n))) & 0xFF)
+
+#define MAX_CMD_DATA 512
+
+#define MXL_GET_REG_MASK_32(lsbLoc,numOfBits) ((0xFFFFFFFF >> (32 - (numOfBits))) << (lsbLoc))
+
+#define GET_REG_FIELD_DATA(fieldName, dataPtr) read_by_mnemonic(state, fieldName, dataPtr);
+#define SET_REG_FIELD_DATA(fieldName, data) update_by_mnemonic(state, fieldName, data);
+
+#define FW_DL_SIGN (0xDEADBEEF)
+
+#define MBIN_FORMAT_VERSION               '1'
+#define MBIN_FILE_HEADER_ID               'M'
+#define MBIN_SEGMENT_HEADER_ID            'S'
+#define MBIN_MAX_FILE_LENGTH              (1<<23)
+
+typedef struct
+{
+	u8 id;
+	u8 fmtVersion;
+	u8 headerLen;
+	u8 numSegments;
+	u8 entryAddress[4];
+	u8 imageSize24[3];
+	u8 imageChecksum;
+	u8 reserved[4];
+} MBIN_FILE_HEADER_T;
+
+typedef struct
+{
+	MBIN_FILE_HEADER_T  header;
+	u8 data[1];
+} MBIN_FILE_T;
+
+typedef struct
+{
+	u8 id;
+	u8 len24[3];
+	u8 address[4];
+} MBIN_SEGMENT_HEADER_T;
+
+
+typedef struct
+{
+	MBIN_SEGMENT_HEADER_T header;
+	u8 data[1];
+} MBIN_SEGMENT_T;
+
+
+typedef enum { MXL_CMD_WRITE = 0, MXL_CMD_READ} MXL_CMD_TYPE_E;
+
+#define BUILD_HYDRA_CMD(cmdID, reqType, size, dataPtr, cmdBuff)		\
+	do {								\
+		cmdBuff[0] = ((reqType == MXL_CMD_WRITE) ? MXL_HYDRA_PLID_CMD_WRITE : MXL_HYDRA_PLID_CMD_READ); \
+		cmdBuff[1] = (size > 251) ? 0xff : (u8) (size + 4);	\
+		cmdBuff[2] = size;					\
+		cmdBuff[3] = cmdID;					\
+		cmdBuff[4] = 0x00;					\
+		cmdBuff[5] = 0x00;					\
+		convert_endian(MXL_ENABLE_BIG_ENDIAN, size, (u8 *)dataPtr); \
+		memcpy((void *)&cmdBuff[6], dataPtr, size);		\
+	} while(0) //;
+
+typedef struct {
+	u32 regAddr;
+	u8 lsbPos;
+	u8 numOfBits;
+} MXL_REG_FIELD_T;
+
+typedef struct {
+	u32 dataSize;
+	u8 data[MAX_CMD_DATA];
+} MXL_DEV_CMD_DATA_T;
+
+typedef enum
+{
+  MXL_HYDRA_SKU_TYPE_MIN = 0x00,
+  MXL_HYDRA_SKU_TYPE_581 = 0x00,
+  MXL_HYDRA_SKU_TYPE_584 = 0x01,
+  MXL_HYDRA_SKU_TYPE_585 = 0x02,
+  MXL_HYDRA_SKU_TYPE_544 = 0x03,
+  MXL_HYDRA_SKU_TYPE_561 = 0x04,
+  MXL_HYDRA_SKU_TYPE_5xx = 0x05,
+  MXL_HYDRA_SKU_TYPE_5yy = 0x06,
+  MXL_HYDRA_SKU_TYPE_511 = 0x07,
+  MXL_HYDRA_SKU_TYPE_561_DE = 0x08,
+  MXL_HYDRA_SKU_TYPE_582 = 0x09,
+  MXL_HYDRA_SKU_TYPE_541 = 0x0A,
+  MXL_HYDRA_SKU_TYPE_568 = 0x0B,
+  MXL_HYDRA_SKU_TYPE_542 = 0x0C,
+  MXL_HYDRA_SKU_TYPE_MAX = 0x0D,
+} MXL_HYDRA_SKU_TYPE_E;
+
+typedef struct
+{
+  MXL_HYDRA_SKU_TYPE_E skuType;
+} MXL_HYDRA_SKU_COMMAND_T;
+
+
+typedef  enum
+{
+  MXL_HYDRA_DEMOD_ID_0 = 0,
+  MXL_HYDRA_DEMOD_ID_1,
+  MXL_HYDRA_DEMOD_ID_2,
+  MXL_HYDRA_DEMOD_ID_3,
+  MXL_HYDRA_DEMOD_ID_4,
+  MXL_HYDRA_DEMOD_ID_5,
+  MXL_HYDRA_DEMOD_ID_6,
+  MXL_HYDRA_DEMOD_ID_7,
+  MXL_HYDRA_DEMOD_MAX
+} MXL_HYDRA_DEMOD_ID_E;
+
+#define MXL_DEMOD_SCRAMBLE_SEQ_LEN  12
+
+#define MAX_STEP_SIZE_24_XTAL_102_05_KHZ  195
+#define MAX_STEP_SIZE_24_XTAL_204_10_KHZ  215
+#define MAX_STEP_SIZE_24_XTAL_306_15_KHZ  203
+#define MAX_STEP_SIZE_24_XTAL_408_20_KHZ  177
+
+#define MAX_STEP_SIZE_27_XTAL_102_05_KHZ  195
+#define MAX_STEP_SIZE_27_XTAL_204_10_KHZ  215
+#define MAX_STEP_SIZE_27_XTAL_306_15_KHZ  203
+#define MAX_STEP_SIZE_27_XTAL_408_20_KHZ  177
+
+#define MXL_HYDRA_SPECTRUM_MIN_FREQ_KHZ  300000
+#define MXL_HYDRA_SPECTRUM_MAX_FREQ_KHZ 2350000
+
+typedef enum
+{
+  DMD_STANDARD_ADDR = 0,
+  DMD_SPECTRUM_INVERSION_ADDR,
+  DMD_SPECTRUM_ROLL_OFF_ADDR,
+  DMD_SYMBOL_RATE_ADDR,
+  DMD_MODULATION_SCHEME_ADDR,
+  DMD_FEC_CODE_RATE_ADDR,
+  DMD_SNR_ADDR,
+  DMD_FREQ_OFFSET_ADDR,
+  DMD_CTL_FREQ_OFFSET_ADDR,
+  DMD_STR_FREQ_OFFSET_ADDR,
+  DMD_FTL_FREQ_OFFSET_ADDR,
+  DMD_STR_NBC_SYNC_LOCK_ADDR,
+  DMD_CYCLE_SLIP_COUNT_ADDR,
+  DMD_DISPLAY_IQ_ADDR,
+  DMD_DVBS2_CRC_ERRORS_ADDR,
+  DMD_DVBS2_PER_COUNT_ADDR,
+  DMD_DVBS2_PER_WINDOW_ADDR,
+  DMD_DVBS_CORR_RS_ERRORS_ADDR,
+  DMD_DVBS_UNCORR_RS_ERRORS_ADDR,
+  DMD_DVBS_BER_COUNT_ADDR,
+  DMD_DVBS_BER_WINDOW_ADDR,
+  DMD_TUNER_ID_ADDR,
+  DMD_DVBS2_PILOT_ON_OFF_ADDR,
+  DMD_FREQ_SEARCH_RANGE_IN_KHZ_ADDR,
+
+  MXL_DEMOD_CHAN_PARAMS_BUFF_SIZE,
+} MXL_DEMOD_CHAN_PARAMS_OFFSET_E;
+
+typedef enum
+{
+  MXL_HYDRA_TUNER_ID_0 = 0,
+  MXL_HYDRA_TUNER_ID_1,
+  MXL_HYDRA_TUNER_ID_2,
+  MXL_HYDRA_TUNER_ID_3,
+  MXL_HYDRA_TUNER_MAX
+} MXL_HYDRA_TUNER_ID_E;
+
+typedef enum
+{
+  MXL_HYDRA_DSS = 0,
+  MXL_HYDRA_DVBS,
+  MXL_HYDRA_DVBS2,
+} MXL_HYDRA_BCAST_STD_E;
+
+typedef enum
+{
+  MXL_HYDRA_FEC_AUTO = 0,
+  MXL_HYDRA_FEC_1_2,
+  MXL_HYDRA_FEC_3_5,
+  MXL_HYDRA_FEC_2_3,
+  MXL_HYDRA_FEC_3_4,
+  MXL_HYDRA_FEC_4_5,
+  MXL_HYDRA_FEC_5_6,
+  MXL_HYDRA_FEC_6_7,
+  MXL_HYDRA_FEC_7_8,
+  MXL_HYDRA_FEC_8_9,
+  MXL_HYDRA_FEC_9_10,
+} MXL_HYDRA_FEC_E;
+
+typedef enum
+{
+  MXL_HYDRA_MOD_AUTO = 0,
+  MXL_HYDRA_MOD_QPSK,
+  MXL_HYDRA_MOD_8PSK
+} MXL_HYDRA_MODULATION_E;
+
+typedef enum
+{
+  MXL_HYDRA_SPECTRUM_AUTO = 0,
+  MXL_HYDRA_SPECTRUM_INVERTED,
+  MXL_HYDRA_SPECTRUM_NON_INVERTED,
+} MXL_HYDRA_SPECTRUM_E;
+
+typedef enum
+{
+  MXL_HYDRA_ROLLOFF_AUTO  = 0,
+  MXL_HYDRA_ROLLOFF_0_20,
+  MXL_HYDRA_ROLLOFF_0_25,
+  MXL_HYDRA_ROLLOFF_0_35
+} MXL_HYDRA_ROLLOFF_E;
+
+typedef enum
+{
+  MXL_HYDRA_PILOTS_OFF  = 0,
+  MXL_HYDRA_PILOTS_ON,
+  MXL_HYDRA_PILOTS_AUTO
+} MXL_HYDRA_PILOTS_E;
+
+typedef enum
+{
+  MXL_HYDRA_FORMATTER = 0,
+  MXL_HYDRA_LEGACY_FEC,
+  MXL_HYDRA_FREQ_RECOVERY,
+  MXL_HYDRA_NBC,
+  MXL_HYDRA_CTL,
+  MXL_HYDRA_EQ,
+} MXL_HYDRA_CONSTELLATION_SRC_E;
+
+typedef struct
+{
+  int agcLock;     // AGC lock info
+  int fecLock;     // Demod FEC block lock info
+} MXL_HYDRA_DEMOD_LOCK_T;
+
+typedef struct
+{
+  u32 rsErrors;          // RS decoder err counter
+  u32 berWindow;         // Ber Windows
+  u32 berCount;          // BER count
+  u32 berWindow_Iter1;   // Ber Windows - post viterbi
+  u32 berCount_Iter1;    // BER count - post viterbi
+} MXL_HYDRA_DEMOD_STATUS_DVBS_T;
+
+typedef struct
+{
+  u32 rsErrors;    // RS decoder err counter
+  u32 berWindow;   // Ber Windows
+  u32 berCount;    // BER count
+} MXL_HYDRA_DEMOD_STATUS_DSS_T;
+
+typedef struct
+{
+  u32 crcErrors;         // CRC error counter
+  u32 packetErrorCount;  // Number of packet errors
+  u32 totalPackets;      // Total packets
+} MXL_HYDRA_DEMOD_STATUS_DVBS2_T;
+
+typedef struct
+{
+  MXL_HYDRA_BCAST_STD_E standardMask;                // Standard DVB-S, DVB-S2 or DSS
+
+  union
+  {
+    MXL_HYDRA_DEMOD_STATUS_DVBS_T demodStatus_DVBS;    // DVB-S demod status
+    MXL_HYDRA_DEMOD_STATUS_DVBS2_T demodStatus_DVBS2;  // DVB-S2 demod status
+    MXL_HYDRA_DEMOD_STATUS_DSS_T demodStatus_DSS;      // DSS demod status
+  } u;
+
+} MXL_HYDRA_DEMOD_STATUS_T;
+
+typedef struct
+{
+  s32 carrierOffsetInHz;       // CRL offset info
+  s32 symbolOffsetInSymbol;    // SRL offset info
+} MXL_HYDRA_DEMOD_SIG_OFFSET_INFO_T;
+
+typedef struct
+{
+  u8 scrambleSequence[MXL_DEMOD_SCRAMBLE_SEQ_LEN];   // scramble sequence
+  u32 scrambleCode;                                  // scramble gold code
+} MXL_HYDRA_DEMOD_SCRAMBLE_INFO_T;
+
+typedef enum
+{
+  MXL_HYDRA_STEP_SIZE_24_XTAL_102_05KHZ,  // 102.05 KHz for 24 MHz XTAL
+  MXL_HYDRA_STEP_SIZE_24_XTAL_204_10KHZ,  // 204.10 KHz for 24 MHz XTAL
+  MXL_HYDRA_STEP_SIZE_24_XTAL_306_15KHZ,  // 306.15 KHz for 24 MHz XTAL
+  MXL_HYDRA_STEP_SIZE_24_XTAL_408_20KHZ,  // 408.20 KHz for 24 MHz XTAL
+
+  MXL_HYDRA_STEP_SIZE_27_XTAL_102_05KHZ,  // 102.05 KHz for 27 MHz XTAL
+  MXL_HYDRA_STEP_SIZE_27_XTAL_204_35KHZ,  // 204.35 KHz for 27 MHz XTAL
+  MXL_HYDRA_STEP_SIZE_27_XTAL_306_52KHZ,  // 306.52 KHz for 27 MHz XTAL
+  MXL_HYDRA_STEP_SIZE_27_XTAL_408_69KHZ,  // 408.69 KHz for 27 MHz XTAL
+
+} MXL_HYDRA_SPECTRUM_STEP_SIZE_E;
+
+typedef enum
+{
+  MXL_HYDRA_SPECTRUM_RESOLUTION_00_1_DB, // 0.1 dB
+  MXL_HYDRA_SPECTRUM_RESOLUTION_01_0_DB, // 1.0 dB
+  MXL_HYDRA_SPECTRUM_RESOLUTION_05_0_DB, // 5.0 dB
+  MXL_HYDRA_SPECTRUM_RESOLUTION_10_0_DB, // 10 dB
+} MXL_HYDRA_SPECTRUM_RESOLUTION_E;
+
+typedef enum
+{
+    MXL_SPECTRUM_NO_ERROR,
+    MXL_SPECTRUM_INVALID_PARAMETER,
+    MXL_SPECTRUM_INVALID_STEP_SIZE,
+    MXL_SPECTRUM_BW_CANNOT_BE_COVERED,
+    MXL_SPECTRUM_DEMOD_BUSY,
+    MXL_SPECTRUM_TUNER_NOT_ENABLED,
+
+} MXL_HYDRA_SPECTRUM_ERROR_CODE_E;
+
+typedef struct
+{
+  u32 tunerIndex;        // TUNER Ctrl: one of MXL58x_TUNER_ID_E
+  u32 demodIndex;        // DEMOD Ctrl: one of MXL58x_DEMOD_ID_E
+  MXL_HYDRA_SPECTRUM_STEP_SIZE_E stepSizeInKHz;
+  u32 startingFreqInkHz;
+  u32 totalSteps;
+  MXL_HYDRA_SPECTRUM_RESOLUTION_E spectrumDivision;
+} MXL_HYDRA_SPECTRUM_REQ_T;
+
+typedef enum
+{
+ MXL_HYDRA_SEARCH_MAX_OFFSET = 0, // DMD searches for max freq offset (i.e. 5MHz)
+ MXL_HYDRA_SEARCH_BW_PLUS_ROLLOFF, // DMD searches for BW + ROLLOFF/2
+} MXL_HYDRA_SEARCH_FREQ_OFFSET_TYPE_E;
+
+typedef struct
+{
+  u32 demodIndex;
+  MXL_HYDRA_SEARCH_FREQ_OFFSET_TYPE_E searchType;
+} MXL58x_CFG_FREQ_OFF_SEARCH_RANGE_T;
+
+
+
+
+// there are two slices
+// slice0 - TS0, TS1, TS2 & TS3
+// slice1 - TS4, TS5, TS6 & TS7
+#define MXL_HYDRA_TS_SLICE_MAX  2
+
+#define MAX_FIXED_PID_NUM   32
+
+#define MXL_HYDRA_NCO_CLK   418 // 418 MHz
+
+#define MXL_HYDRA_MAX_TS_CLOCK  139 // 139 MHz
+
+#define MXL_HYDRA_TS_FIXED_PID_FILT_SIZE          32
+
+#define MXL_HYDRA_SHARED_PID_FILT_SIZE_DEFAULT    33   // Shared PID filter size in 1-1 mux mode
+#define MXL_HYDRA_SHARED_PID_FILT_SIZE_2_TO_1     66   // Shared PID filter size in 2-1 mux mode
+#define MXL_HYDRA_SHARED_PID_FILT_SIZE_4_TO_1     132  // Shared PID filter size in 4-1 mux mode
+
+typedef enum
+{
+  MXL_HYDRA_SOFTWARE_PID_BANK = 0,
+  MXL_HYDRA_HARDWARE_PID_BANK,
+} MXL_HYDRA_PID_BANK_TYPE_E;
+
+typedef enum
+{
+  MXL_HYDRA_TS_MUX_PID_REMAP = 0,
+  MXL_HYDRA_TS_MUX_PREFIX_EXTRA_HEADER = 1,
+} MXL_HYDRA_TS_MUX_MODE_E;
+
+typedef enum
+{
+  MXL_HYDRA_TS_MUX_DISABLE = 0,  // No Mux ( 1 TSIF to 1 TSIF)
+  MXL_HYDRA_TS_MUX_2_TO_1,       // Mux 2 TSIF to 1 TSIF
+  MXL_HYDRA_TS_MUX_4_TO_1,       // Mux 4 TSIF to 1 TSIF
+} MXL_HYDRA_TS_MUX_TYPE_E;
+
+typedef enum
+{
+  MXL_HYDRA_TS_GROUP_0_3 = 0,     // TS group 0 to 3 (TS0, TS1, TS2 & TS3)
+  MXL_HYDRA_TS_GROUP_4_7,         // TS group 0 to 3 (TS4, TS5, TS6 & TS7)
+} MXL_HYDRA_TS_GROUP_E;
+
+typedef enum
+{
+  MXL_HYDRA_TS_PIDS_ALLOW_ALL = 0,    // Allow all pids
+  MXL_HYDRA_TS_PIDS_DROP_ALL,         // Drop all pids
+  MXL_HYDRA_TS_INVALIDATE_PID_FILTER, // Delete current PD filter in the device
+
+} MXL_HYDRA_TS_PID_FLT_CTRL_E;
+
+typedef enum
+{
+  MXL_HYDRA_TS_PID_FIXED = 0,
+  MXL_HYDRA_TS_PID_REGULAR,
+} MXL_HYDRA_TS_PID_TYPE_E;
+
+typedef struct
+{
+	u16 originalPid;           // pid from TS
+	u16 remappedPid;           // remapped pid
+	MXL_BOOL_E enable;            // enable or disable pid
+	MXL_BOOL_E allowOrDrop;       // allow or drop pid
+	MXL_BOOL_E enablePidRemap;    // enable or disable pid remap
+	u8 bondId;                 // Bond ID in A0 always 0 - Only for 568 Sku
+	u8 destId;                 // Output port ID for the PID - Only for 568 Sku
+} MXL_HYDRA_TS_PID_T;
+
+typedef struct
+{
+  MXL_BOOL_E enable;
+  u8 numByte;
+  u8 header[12];
+} MXL_HYDRA_TS_MUX_PREFIX_HEADER_T;
+
+typedef enum
+{
+  MXL_HYDRA_PID_BANK_A = 0,
+  MXL_HYDRA_PID_BANK_B,
+} MXL_HYDRA_PID_FILTER_BANK_E;
+
+typedef enum
+{
+  MXL_HYDRA_MPEG_SERIAL_MSB_1ST = 0,
+  MXL_HYDRA_MPEG_SERIAL_LSB_1ST,
+
+  MXL_HYDRA_MPEG_SYNC_WIDTH_BIT = 0,
+  MXL_HYDRA_MPEG_SYNC_WIDTH_BYTE
+} MXL_HYDRA_MPEG_DATA_FMT_E;
+
+typedef enum
+{
+  MXL_HYDRA_MPEG_MODE_SERIAL_4_WIRE = 0,   // MPEG 4 Wire serial mode
+  MXL_HYDRA_MPEG_MODE_SERIAL_3_WIRE,       // MPEG 3 Wire serial mode
+  MXL_HYDRA_MPEG_MODE_SERIAL_2_WIRE,       // MPEG 2 Wire serial mode
+  MXL_HYDRA_MPEG_MODE_PARALLEL             // MPEG parallel mode - valid only for MxL581
+} MXL_HYDRA_MPEG_MODE_E;
+
+typedef enum
+{
+  MXL_HYDRA_MPEG_CLK_CONTINUOUS = 0,  // Continuous MPEG clock
+  MXL_HYDRA_MPEG_CLK_GAPPED,          // Gapped (gated) MPEG clock
+} MXL_HYDRA_MPEG_CLK_TYPE_E;
+
+typedef enum
+{
+  MXL_HYDRA_MPEG_ACTIVE_LOW = 0,
+  MXL_HYDRA_MPEG_ACTIVE_HIGH,
+
+  MXL_HYDRA_MPEG_CLK_NEGATIVE = 0,
+  MXL_HYDRA_MPEG_CLK_POSITIVE,
+
+  MXL_HYDRA_MPEG_CLK_IN_PHASE = 0,
+  MXL_HYDRA_MPEG_CLK_INVERTED,
+} MXL_HYDRA_MPEG_CLK_FMT_E;
+
+typedef enum
+{
+  MXL_HYDRA_MPEG_CLK_PHASE_SHIFT_0_DEG = 0,
+  MXL_HYDRA_MPEG_CLK_PHASE_SHIFT_90_DEG,
+  MXL_HYDRA_MPEG_CLK_PHASE_SHIFT_180_DEG,
+  MXL_HYDRA_MPEG_CLK_PHASE_SHIFT_270_DEG
+} MXL_HYDRA_MPEG_CLK_PHASE_E;
+
+typedef enum
+{
+  MXL_HYDRA_MPEG_ERR_REPLACE_SYNC = 0,
+  MXL_HYDRA_MPEG_ERR_REPLACE_VALID,
+  MXL_HYDRA_MPEG_ERR_INDICATION_DISABLED
+} MXL_HYDRA_MPEG_ERR_INDICATION_E;
+
+typedef struct
+{
+  int                        enable;               // Enable or Disable MPEG OUT
+  MXL_HYDRA_MPEG_CLK_TYPE_E         mpegClkType;          // Continuous or gapped
+  MXL_HYDRA_MPEG_CLK_FMT_E          mpegClkPol;           // MPEG Clk polarity
+  u8                             maxMpegClkRate;       // Max MPEG Clk rate (0  104 MHz, 139 MHz)
+  MXL_HYDRA_MPEG_CLK_PHASE_E        mpegClkPhase;         // MPEG Clk phase
+  MXL_HYDRA_MPEG_DATA_FMT_E         lsbOrMsbFirst;        // LSB first or MSB first in TS transmission
+  MXL_HYDRA_MPEG_DATA_FMT_E         mpegSyncPulseWidth;   // MPEG SYNC pulse width (1-bit or 1-byte)
+  MXL_HYDRA_MPEG_CLK_FMT_E          mpegValidPol;         // MPEG VALID polarity
+  MXL_HYDRA_MPEG_CLK_FMT_E          mpegSyncPol;          // MPEG SYNC polarity
+  MXL_HYDRA_MPEG_MODE_E             mpegMode;             // config 4/3/2-wire serial or parallel TS out
+  MXL_HYDRA_MPEG_ERR_INDICATION_E   mpegErrorIndication;  // Enable or Disable MPEG error indication
+} MXL_HYDRA_MPEGOUT_PARAM_T;
+
+typedef enum
+{
+  MXL_HYDRA_EXT_TS_IN_0 = 0,
+  MXL_HYDRA_EXT_TS_IN_1,
+  MXL_HYDRA_EXT_TS_IN_2,
+  MXL_HYDRA_EXT_TS_IN_3,
+  MXL_HYDRA_EXT_TS_IN_MAX
+
+} MXL_HYDRA_EXT_TS_IN_ID_E;
+
+typedef  enum
+{
+  MXL_HYDRA_TS_OUT_0 = 0,
+  MXL_HYDRA_TS_OUT_1,
+  MXL_HYDRA_TS_OUT_2,
+  MXL_HYDRA_TS_OUT_3,
+  MXL_HYDRA_TS_OUT_4,
+  MXL_HYDRA_TS_OUT_5,
+  MXL_HYDRA_TS_OUT_6,
+  MXL_HYDRA_TS_OUT_7,
+  MXL_HYDRA_TS_OUT_MAX
+
+} MXL_HYDRA_TS_OUT_ID_E;
+
+typedef  enum
+{
+  MXL_HYDRA_TS_DRIVE_STRENGTH_1x = 0,
+  MXL_HYDRA_TS_DRIVE_STRENGTH_2x,
+  MXL_HYDRA_TS_DRIVE_STRENGTH_3x,
+  MXL_HYDRA_TS_DRIVE_STRENGTH_4x,
+  MXL_HYDRA_TS_DRIVE_STRENGTH_5x,
+  MXL_HYDRA_TS_DRIVE_STRENGTH_6x,
+  MXL_HYDRA_TS_DRIVE_STRENGTH_7x,
+  MXL_HYDRA_TS_DRIVE_STRENGTH_8x
+
+} MXL_HYDRA_TS_DRIVE_STRENGTH_E;
+
+typedef enum
+{
+  MXL_HYDRA_DEVICE_581 = 0,
+  MXL_HYDRA_DEVICE_584,
+  MXL_HYDRA_DEVICE_585,
+  MXL_HYDRA_DEVICE_544,
+  MXL_HYDRA_DEVICE_561,
+  MXL_HYDRA_DEVICE_TEST,
+  MXL_HYDRA_DEVICE_582,
+  MXL_HYDRA_DEVICE_541,
+  MXL_HYDRA_DEVICE_568,
+  MXL_HYDRA_DEVICE_542,
+  MXL_HYDRA_DEVICE_541S,
+  MXL_HYDRA_DEVICE_561S,
+  MXL_HYDRA_DEVICE_581S,
+  MXL_HYDRA_DEVICE_MAX
+} MXL_HYDRA_DEVICE_E;
+
+
+// Demod IQ data
+typedef struct
+{
+  u32 demodId;
+  u32 sourceOfIQ;                  // ==0, it means I/Q comes from Formatter
+                                      // ==1, Legacy FEC
+                                      // ==2, Frequency Recovery
+                                      // ==3, NBC
+                                      // ==4, CTL
+                                      // ==5, EQ
+                                      // ==6, FPGA
+} MXL_HYDRA_DEMOD_IQ_SRC_T;
+
+typedef struct
+{
+  u32 demodId;
+} MXL_HYDRA_DEMOD_ABORT_TUNE_T;
+
+typedef struct
+{
+  u8 tunerId;
+  u8 enable;
+} MxL_HYDRA_TUNER_CMD;
+
+// Demod Para for Channel Tune
+typedef struct
+{
+  u32 tunerIndex;
+  u32 demodIndex;
+  u32 frequencyInHz;     // Frequency
+  u32 standard;          // one of MXL_HYDRA_BCAST_STD_E
+  u32 spectrumInversion; // Input : Spectrum inversion.
+  u32 rollOff;           /* rollOff (alpha) factor */
+  u32 symbolRateInHz;    /* Symbol rate */
+  u32 pilots;            /* TRUE = pilots enabled */
+  u32 modulationScheme;  // Input : Modulation Scheme is one of MXL_HYDRA_MODULATION_E
+  u32 fecCodeRate;       // Input : Forward error correction rate. Is one of MXL_HYDRA_FEC_E
+  u32 maxCarrierOffsetInMHz; // Maximum carrier freq offset in MHz. Same as freqSearchRangeKHz, but in unit of MHz.
+} MXL_HYDRA_DEMOD_PARAM_T;
+
+typedef struct
+{
+	u32 demodIndex;
+	u8 scrambleSequence[12];       // scramble sequence
+	u32 scrambleCode;              // scramble gold code
+} MXL_HYDRA_DEMOD_SCRAMBLE_CODE_T;
+
+typedef struct
+{
+  u32  intrType;
+  u32  intrDurationInNanoSecs;
+  u32  intrMask;
+} MXL_INTR_CFG_T;
+
+typedef struct
+{
+   u8 powerMode;       // enumeration values are defined in MXL_HYDRA_PWR_MODE_E (device API.h)
+} MxL_HYDRA_POWER_MODE_CMD;
+
+
+typedef struct
+{
+  u32  timeIntervalInSeconds; // in seconds
+  u32  tunerIndex;
+  s32  rssiThreshold;
+
+} MXL_HYDRA_RF_WAKEUP_PARAM_T;
+
+typedef struct
+{
+  u32  tunerCount;
+  MXL_HYDRA_RF_WAKEUP_PARAM_T params;
+} MXL_HYDRA_RF_WAKEUP_CFG_T;
+
+
+typedef enum
+{
+  MXL_HYDRA_AUX_CTRL_MODE_FSK = 0,  // Select FSK controller
+  MXL_HYDRA_AUX_CTRL_MODE_DISEQC,   // Select DiSEqC controller
+} MXL_HYDRA_AUX_CTRL_MODE_E;
+
+
+typedef enum
+{
+  MXL_HYDRA_DISEQC_ENVELOPE_MODE = 0,
+  MXL_HYDRA_DISEQC_TONE_MODE,
+} MXL_HYDRA_DISEQC_OPMODE_E;
+
+typedef enum
+{
+  MXL_HYDRA_DISEQC_1_X = 0,    // Config DiSEqC 1.x mode
+  MXL_HYDRA_DISEQC_2_X,        // Config DiSEqC 2.x mode
+  MXL_HYDRA_DISEQC_DISABLE     // Disable DiSEqC
+} MXL_HYDRA_DISEQC_VER_E;
+
+typedef enum
+{
+  MXL_HYDRA_DISEQC_CARRIER_FREQ_22KHZ= 0,   // DiSEqC signal frequency of 22 KHz
+  MXL_HYDRA_DISEQC_CARRIER_FREQ_33KHZ,      // DiSEqC signal frequency of 33 KHz
+  MXL_HYDRA_DISEQC_CARRIER_FREQ_44KHZ       // DiSEqC signal frequency of 44 KHz
+} MXL_HYDRA_DISEQC_CARRIER_FREQ_E;
+
+typedef enum
+{
+  MXL_HYDRA_DISEQC_ID_0 = 0,
+  MXL_HYDRA_DISEQC_ID_1,
+  MXL_HYDRA_DISEQC_ID_2,
+  MXL_HYDRA_DISEQC_ID_3
+} MXL_HYDRA_DISEQC_ID_E;
+
+typedef enum
+{
+  MXL_HYDRA_FSK_CFG_TYPE_39KPBS = 0,    // 39.0kbps
+  MXL_HYDRA_FSK_CFG_TYPE_39_017KPBS,    // 39.017kbps
+  MXL_HYDRA_FSK_CFG_TYPE_115_2KPBS      // 115.2kbps
+} MXL_HYDRA_FSK_OP_MODE_E;
+
+
+typedef struct
+{
+	u32 diseqcId;  // DSQ 0, 1, 2 or 3
+	u32 opMode;   // Envelope mode (0) or internal tone mode (1)
+	u32 version;   // 0: 1.0 , 1: 1.1 , 2: Disable
+	u32 centerFreq; // 0: 22KHz, 1: 33KHz and 2: 44 KHz
+}MXL58x_DSQ_OP_MODE_T;
+
+typedef struct
+{
+	u32 diseqcId;
+	u32 contToneFlag;  // 1: Enable , 0: Disable
+} MXL_HYDRA_DISEQC_CFG_CONT_TONE_T;
diff --git a/drivers/media/dvb-frontends/mxl5xx_regs.h b/drivers/media/dvb-frontends/mxl5xx_regs.h
new file mode 100644
index 0000000..e983d0b
--- /dev/null
+++ b/drivers/media/dvb-frontends/mxl5xx_regs.h
@@ -0,0 +1,941 @@
+/*
+* Copyright (c) 2011-2013 MaxLinear, Inc. All rights reserved
+*
+* License type: GPLv2
+*
+* This program is free software; you can redistribute it and/or modify it under
+* the terms of the GNU General Public License as published by the Free Software
+* Foundation.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+* FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along with
+* this program; if not, write to the Free Software Foundation, Inc.,
+* 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
+*
+* This program may alternatively be licensed under a proprietary license from
+* MaxLinear, Inc.
+*
+* See terms and conditions defined in file 'LICENSE.txt', which is part of this
+* source code package.
+*/
+
+#ifndef __MXL58X_REGISTERS_H__
+#define __MXL58X_REGISTERS_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define HYDRA_INTR_STATUS_REG               0x80030008
+#define HYDRA_INTR_MASK_REG                 0x8003000C
+
+#define HYDRA_CRYSTAL_SETTING               0x3FFFC5F0 // 0 - 24 MHz & 1 - 27 MHz
+#define HYDRA_CRYSTAL_CAP                   0x3FFFEDA4 // 0 - 24 MHz & 1 - 27 MHz
+
+#define HYDRA_CPU_RESET_REG                 0x8003003C
+#define HYDRA_CPU_RESET_DATA                0x00000400
+
+#define HYDRA_RESET_TRANSPORT_FIFO_REG      0x80030028
+#define HYDRA_RESET_TRANSPORT_FIFO_DATA     0x00000000
+
+#define HYDRA_RESET_BBAND_REG               0x80030024
+#define HYDRA_RESET_BBAND_DATA              0x00000000
+
+#define HYDRA_RESET_XBAR_REG                0x80030020
+#define HYDRA_RESET_XBAR_DATA               0x00000000
+
+#define HYDRA_MODULES_CLK_1_REG             0x80030014
+#define HYDRA_DISABLE_CLK_1                 0x00000000
+
+#define HYDRA_MODULES_CLK_2_REG             0x8003001C
+#define HYDRA_DISABLE_CLK_2                 0x0000000B
+
+#define HYDRA_PRCM_ROOT_CLK_REG             0x80030018
+#define HYDRA_PRCM_ROOT_CLK_DISABLE         0x00000000
+
+#define HYDRA_CPU_RESET_CHECK_REG           0x80030008
+#define HYDRA_CPU_RESET_CHECK_OFFSET        0x40000000  //  <bit 30>
+
+#define HYDRA_SKU_ID_REG                    0x90000190
+
+#define FW_DL_SIGN_ADDR                     0x3FFFEAE0
+
+// Register to check if FW is running or not
+#define HYDRA_HEAR_BEAT                     0x3FFFEDDC
+
+// Firmware version
+#define HYDRA_FIRMWARE_VERSION              0x3FFFEDB8
+#define HYDRA_FW_RC_VERSION                 0x3FFFCFAC
+
+// Firmware patch version
+#define HYDRA_FIRMWARE_PATCH_VERSION        0x3FFFEDC2
+
+// SOC operating temperature in C
+#define HYDRA_TEMPARATURE                   0x3FFFEDB4
+
+// Demod & Tuner status registers
+// Demod 0 status base address
+#define HYDRA_DEMOD_0_BASE_ADDR             0x3FFFC64C
+
+// Tuner 0 status base address
+#define HYDRA_TUNER_0_BASE_ADDR             0x3FFFCE4C
+
+#define POWER_FROM_ADCRSSI_READBACK         0x3FFFEB6C
+
+// Macros to determine base address of respective demod or tuner
+#define HYDRA_DMD_STATUS_OFFSET(demodID)        ((demodID) * 0x100)
+#define HYDRA_TUNER_STATUS_OFFSET(tunerID)      ((tunerID) * 0x40)
+
+// Demod status address offset from respective demod's base address
+#define HYDRA_DMD_AGC_DIG_LEVEL_ADDR_OFFSET               0x3FFFC64C
+#define HYDRA_DMD_LOCK_STATUS_ADDR_OFFSET                 0x3FFFC650
+#define HYDRA_DMD_ACQ_STATUS_ADDR_OFFSET                  0x3FFFC654
+
+#define HYDRA_DMD_STANDARD_ADDR_OFFSET                    0x3FFFC658
+#define HYDRA_DMD_SPECTRUM_INVERSION_ADDR_OFFSET          0x3FFFC65C
+#define HYDRA_DMD_SPECTRUM_ROLL_OFF_ADDR_OFFSET           0x3FFFC660
+#define HYDRA_DMD_SYMBOL_RATE_ADDR_OFFSET                 0x3FFFC664
+#define HYDRA_DMD_MODULATION_SCHEME_ADDR_OFFSET           0x3FFFC668
+#define HYDRA_DMD_FEC_CODE_RATE_ADDR_OFFSET               0x3FFFC66C
+
+#define HYDRA_DMD_SNR_ADDR_OFFSET                         0x3FFFC670
+#define HYDRA_DMD_FREQ_OFFSET_ADDR_OFFSET                 0x3FFFC674
+#define HYDRA_DMD_CTL_FREQ_OFFSET_ADDR_OFFSET             0x3FFFC678
+#define HYDRA_DMD_STR_FREQ_OFFSET_ADDR_OFFSET             0x3FFFC67C
+#define HYDRA_DMD_FTL_FREQ_OFFSET_ADDR_OFFSET             0x3FFFC680
+#define HYDRA_DMD_STR_NBC_SYNC_LOCK_ADDR_OFFSET           0x3FFFC684
+#define HYDRA_DMD_CYCLE_SLIP_COUNT_ADDR_OFFSET            0x3FFFC688
+
+#define HYDRA_DMD_DISPLAY_I_ADDR_OFFSET                   0x3FFFC68C
+#define HYDRA_DMD_DISPLAY_Q_ADDR_OFFSET                   0x3FFFC68E
+
+#define HYDRA_DMD_DVBS2_CRC_ERRORS_ADDR_OFFSET            0x3FFFC690
+#define HYDRA_DMD_DVBS2_PER_COUNT_ADDR_OFFSET             0x3FFFC694
+#define HYDRA_DMD_DVBS2_PER_WINDOW_ADDR_OFFSET            0x3FFFC698
+
+#define HYDRA_DMD_DVBS_CORR_RS_ERRORS_ADDR_OFFSET         0x3FFFC69C
+#define HYDRA_DMD_DVBS_UNCORR_RS_ERRORS_ADDR_OFFSET       0x3FFFC6A0
+#define HYDRA_DMD_DVBS_BER_COUNT_ADDR_OFFSET              0x3FFFC6A4
+#define HYDRA_DMD_DVBS_BER_WINDOW_ADDR_OFFSET             0x3FFFC6A8
+
+// Debug-purpose DVB-S DMD 0
+#define HYDRA_DMD_DVBS_1ST_CORR_RS_ERRORS_ADDR_OFFSET     0x3FFFC6C8  // corrected RS Errors: 1st iteration
+#define HYDRA_DMD_DVBS_1ST_UNCORR_RS_ERRORS_ADDR_OFFSET   0x3FFFC6CC  // uncorrected RS Errors: 1st iteration
+#define HYDRA_DMD_DVBS_BER_COUNT_1ST_ADDR_OFFSET          0x3FFFC6D0
+#define HYDRA_DMD_DVBS_BER_WINDOW_1ST_ADDR_OFFSET         0x3FFFC6D4
+
+#define HYDRA_DMD_TUNER_ID_ADDR_OFFSET                    0x3FFFC6AC
+#define HYDRA_DMD_DVBS2_PILOT_ON_OFF_ADDR_OFFSET          0x3FFFC6B0
+#define HYDRA_DMD_FREQ_SEARCH_RANGE_KHZ_ADDR_OFFSET       0x3FFFC6B4
+#define HYDRA_DMD_STATUS_LOCK_ADDR_OFFSET                 0x3FFFC6B8
+#define HYDRA_DMD_STATUS_CENTER_FREQ_IN_KHZ_ADDR          0x3FFFC704
+#define HYDRA_DMD_STATUS_INPUT_POWER_ADDR                 0x3FFFC708
+
+// DVB-S new scaled_BER_count for a new BER API, see HYDRA-1343 "DVB-S post viterbi information"
+#define DMD0_STATUS_DVBS_1ST_SCALED_BER_COUNT_ADDR        0x3FFFC710 // DMD 0: 1st iteration BER count scaled by HYDRA_BER_COUNT_SCALING_FACTOR
+#define DMD0_STATUS_DVBS_SCALED_BER_COUNT_ADDR            0x3FFFC714 // DMD 0: 2nd iteration BER count scaled by HYDRA_BER_COUNT_SCALING_FACTOR
+
+#define DMD0_SPECTRUM_MIN_GAIN_STATUS                     0x3FFFC73C
+#define DMD0_SPECTRUM_MIN_GAIN_WB_SAGC_VALUE              0x3FFFC740
+#define DMD0_SPECTRUM_ MIN_GAIN_NB_SAGC_VALUE             0x3FFFC744
+
+#define HYDRA_DMD_STATUS_END_ADDR_OFFSET                  0x3FFFC748
+
+// Tuner status address offset from respective tuners's base address
+#define HYDRA_TUNER_DEMOD_ID_ADDR_OFFSET                  0x3FFFCE4C
+#define HYDRA_TUNER_AGC_LOCK_OFFSET                       0x3FFFCE50
+#define HYDRA_TUNER_SPECTRUM_STATUS_OFFSET                0x3FFFCE54
+#define HYDRA_TUNER_SPECTRUM_BIN_SIZE_OFFSET              0x3FFFCE58
+#define HYDRA_TUNER_SPECTRUM_ADDRESS_OFFSET               0x3FFFCE5C
+#define HYDRA_TUNER_ENABLE_COMPLETE                       0x3FFFEB78
+
+#define HYDRA_DEMOD_STATUS_LOCK(devId, demodId)   write_register(devId, (HYDRA_DMD_STATUS_LOCK_ADDR_OFFSET + HYDRA_DMD_STATUS_OFFSET(demodId)), MXL_YES)
+#define HYDRA_DEMOD_STATUS_UNLOCK(devId, demodId) write_register(devId, (HYDRA_DMD_STATUS_LOCK_ADDR_OFFSET + HYDRA_DMD_STATUS_OFFSET(demodId)), MXL_NO)
+
+#define HYDRA_TUNER_STATUS_LOCK(devId,tunerId)   MxLWare_HYDRA_WriteRegister(devId,(HYDRA_TUNER_STATUS_LOCK_ADDR_OFFSET + HYDRA_TUNER_STATUS_OFFSET(tunerId)), MXL_YES)
+#define HYDRA_TUNER_STATUS_UNLOCK(devId,tunerId) MxLWare_HYDRA_WriteRegister(devId,(HYDRA_TUNER_STATUS_LOCK_ADDR_OFFSET + HYDRA_TUNER_STATUS_OFFSET(tunerId)), MXL_NO)
+
+#define HYDRA_VERSION                                     0x3FFFEDB8
+#define HYDRA_DEMOD0_VERSION                              0x3FFFEDBC
+#define HYDRA_DEMOD1_VERSION                              0x3FFFEDC0
+#define HYDRA_DEMOD2_VERSION                              0x3FFFEDC4
+#define HYDRA_DEMOD3_VERSION                              0x3FFFEDC8
+#define HYDRA_DEMOD4_VERSION                              0x3FFFEDCC
+#define HYDRA_DEMOD5_VERSION                              0x3FFFEDD0
+#define HYDRA_DEMOD6_VERSION                              0x3FFFEDD4
+#define HYDRA_DEMOD7_VERSION                              0x3FFFEDD8
+#define HYDRA_HEAR_BEAT                                   0x3FFFEDDC
+#define HYDRA_SKU_MGMT                                    0x3FFFEBC0
+
+#define MXL_HYDRA_FPGA_A_ADDRESS                          0x91C00000
+#define MXL_HYDRA_FPGA_B_ADDRESS                          0x91D00000
+
+// TS control base address
+#define HYDRA_TS_CTRL_BASE_ADDR                           0x90700000
+
+#define MPEG_MUX_MODE_SLICE0_REG            HYDRA_TS_CTRL_BASE_ADDR + 0x08
+#define MPEG_MUX_MODE_SLICE0_OFFSET         (0),(2)
+
+#define MPEG_MUX_MODE_SLICE1_REG            HYDRA_TS_CTRL_BASE_ADDR + 0x08
+#define MPEG_MUX_MODE_SLICE1_OFFSET         (2),(2)
+
+#define PID_BANK_SEL_SLICE0_REG             HYDRA_TS_CTRL_BASE_ADDR + 0x190
+#define PID_BANK_SEL_SLICE1_REG             HYDRA_TS_CTRL_BASE_ADDR + 0x1B0
+
+#define SW_REGULAR_PID_SW_BANK_OFFSET       0,1
+#define SW_FIXED_PID_SW_BANK_OFFSET         1,1
+
+#define HW_REGULAR_PID_BANK_OFFSET          8,4
+#define HW_FIXED_PID_BANK_OFFSET            4,4
+
+#define MPEG_CLK_GATED_REG                  HYDRA_TS_CTRL_BASE_ADDR + 0x20
+#define MPEG_CLK_GATED_OFFSET               0,1
+
+#define MPEG_CLK_ALWAYS_ON_REG              HYDRA_TS_CTRL_BASE_ADDR + 0x1D4
+#define MPEG_CLK_ALWAYS_ON_OFFSET           0,1
+
+#define HYDRA_REGULAR_PID_BANK_A_REG        HYDRA_TS_CTRL_BASE_ADDR + 0x190
+#define HYDRA_REGULAR_PID_BAN K_A_OFFSET     0,1
+
+#define HYDRA_FIXED_PID_BANK_A_REG          HYDRA_TS_CTRL_BASE_ADDR + 0x190
+#define HYDRA_FIXED_PID_BANK_A_OFFSET       1,1
+
+#define HYDRA_REGULAR_PID_BANK_B_REG        HYDRA_TS_CTRL_BASE_ADDR + 0x1B0
+#define HYDRA_REGULAR_PID_BANK_B_OFFSET     0,1
+
+#define HYDRA_FIXED_PID_BANK_B_REG          HYDRA_TS_CTRL_BASE_ADDR + 0x1B0
+#define HYDRA_FIXED_PID_BANK_B_OFFSET       1,1
+
+#define FIXED_PID_TBL_REG_ADDRESS_0         HYDRA_TS_CTRL_BASE_ADDR + 0x9000
+#define FIXED_PID_TBL_REG_ADDRESS_1         HYDRA_TS_CTRL_BASE_ADDR + 0x9100
+#define FIXED_PID_TBL_REG_ADDRESS_2         HYDRA_TS_CTRL_BASE_ADDR + 0x9200
+#define FIXED_PID_TBL_REG_ADDRESS_3         HYDRA_TS_CTRL_BASE_ADDR + 0x9300
+
+#define FIXED_PID_TBL_REG_ADDRESS_4         HYDRA_TS_CTRL_BASE_ADDR + 0xB000
+#define FIXED_PID_TBL_REG_ADDRESS_5         HYDRA_TS_CTRL_BASE_ADDR + 0xB100
+#define FIXED_PID_TBL_REG_ADDRESS_6         HYDRA_TS_CTRL_BASE_ADDR + 0xB200
+#define FIXED_PID_TBL_REG_ADDRESS_7         HYDRA_TS_CTRL_BASE_ADDR + 0xB300
+
+#define REGULAR_PID_TBL_REG_ADDRESS_0       HYDRA_TS_CTRL_BASE_ADDR + 0x8000
+#define REGULAR_PID_TBL_REG_ADDRESS_1       HYDRA_TS_CTRL_BASE_ADDR + 0x8200
+#define REGULAR_PID_TBL_REG_ADDRESS_2       HYDRA_TS_CTRL_BASE_ADDR + 0x8400
+#define REGULAR_PID_TBL_REG_ADDRESS_3       HYDRA_TS_CTRL_BASE_ADDR + 0x8600
+
+#define REGULAR_PID_TBL_REG_ADDRESS_4       HYDRA_TS_CTRL_BASE_ADDR + 0xA000
+#define REGULAR_PID_TBL_REG_ADDRESS_5       HYDRA_TS_CTRL_BASE_ADDR + 0xA200
+#define REGULAR_PID_TBL_REG_ADDRESS_6       HYDRA_TS_CTRL_BASE_ADDR + 0xA400
+#define REGULAR_PID_TBL_REG_ADDRESS_7       HYDRA_TS_CTRL_BASE_ADDR + 0xA600
+
+#define PID_VALID_OFFSET                    0,1
+#define PID_DROP_OFFSET                     1,1
+#define PID_REMAP_ENABLE_OFFSET             2,1
+#define PID_VALUE_OFFSET                    4,13
+#define PID_MASK_OFFSET                     19,13
+
+#define REGULAR_PID_REMAP_VALUE_OFFSET      0,13
+#define FIXED_PID_REMAP_VALUE_OFFSET        0,16
+#define PID_DEMODID_OFFSET                  16,3
+
+
+///////////////////////////////////////////////
+
+#if 0
+#define AFE_REG_D2A_TA_ADC_CLK_OUT_FLIP 0x90200004,12,1
+#define AFE_REG_D2A_TA_RFFE_LNACAPLOAD_1P8 0x90200028,24,4
+#define AFE_REG_D2A_TA_RFFE_RF1_EN_1P8 0x90200028,5,1
+#define AFE_REG_D2A_TA_RFFE_SPARE_1P8 0x90200028,8,8
+#define AFE_REG_D2A_TB_ADC_CLK_OUT_FLIP 0x9020000C,23,1
+#define AFE_REG_D2A_TB_RFFE_LNACAPLOAD_1P8 0x90200030,16,4
+#define AFE_REG_D2A_TB_RFFE_RF1_EN_1P8 0x9020002C,21,1
+#define AFE_REG_D2A_TB_RFFE_SPARE_1P8 0x90200030,0,8
+#define AFE_REG_D2A_TC_ADC_CLK_OUT_FLIP 0x90200018,7,1
+#define AFE_REG_D2A_TC_RFFE_LNACAPLOAD_1P8 0x90200038,2,4
+#define AFE_REG_D2A_TC_RFFE_RF1_EN_1P8 0x90200034,14,1
+#define AFE_REG_D2A_TC_RFFE_SPARE_1P8 0x90200034,17,8
+#define AFE_REG_D2A_TD_ADC_CLK_OUT_FLIP 0x90200020,18,1
+#define AFE_REG_D2A_TD_RFFE_LNACAPLOAD_1P8 0x9020003C,17,4
+#define AFE_REG_D2A_TD_RFFE_RF1_EN_1P8 0x90200038,29,1
+#define AFE_REG_D2A_TD_RFFE_SPARE_1P8 0x9020003C,1,8
+#endif
+#define AFE_REG_D2A_XTAL_EN_CLKOUT_1P8 0x90200054,23,1
+
+#define   PAD_MUX_TS0_IN_CLK_PINMUX_SEL                          0x90000018,0,3
+#define   PAD_MUX_TS0_IN_DATA_PINMUX_SEL                         0x90000018,4,3
+#define   PAD_MUX_TS1_IN_CLK_PINMUX_SEL                          0x90000018,8,3
+#define   PAD_MUX_TS1_IN_DATA_PINMUX_SEL                         0x90000018,12,3
+#define   PAD_MUX_TS2_IN_CLK_PINMUX_SEL                          0x90000018,16,3
+#define   PAD_MUX_TS2_IN_DATA_PINMUX_SEL                         0x90000018,20,3
+#define   PAD_MUX_TS3_IN_CLK_PINMUX_SEL                          0x90000018,24,3
+#define   PAD_MUX_TS3_IN_DATA_PINMUX_SEL                         0x90000018,28,3
+
+#define   PAD_MUX_GPIO_00_SYNC_BASEADDR                          0x90000188
+#define   PAD_MUX_GPIO_01_SYNC_IN                                PAD_MUX_GPIO_00_SYNC_BASEADDR,1,1
+
+#define PRCM_AFE_SOC_ID 0x80030004,24,8
+
+#define PAD_MUX_UART_RX_C_PINMUX_BASEADDR 0x9000001C
+#define PAD_MUX_UART_RX_C_PINMUX_SEL PAD_MUX_UART_RX_C_PINMUX_BASEADDR,0,3
+#define PAD_MUX_UART_RX_D_PINMUX_SEL PAD_MUX_UART_RX_C_PINMUX_BASEADDR,4,3
+#define PAD_MUX_BOND_OPTION 0x90000190,0,3
+#define PAD_MUX_DIGIO_01_PINMUX_SEL 0x9000016C,4,3
+#define PAD_MUX_DIGIO_02_PINMUX_SEL 0x9000016C,8,3
+#define PAD_MUX_DIGIO_03_PINMUX_SEL 0x9000016C,12,3
+#define PAD_MUX_DIGIO_04_PINMUX_SEL 0x9000016C,16,3
+#define PAD_MUX_DIGIO_05_PINMUX_SEL 0x9000016C,20,3
+#define PAD_MUX_DIGIO_06_PINMUX_SEL 0x9000016C,24,3
+#define PAD_MUX_DIGIO_07_PINMUX_SEL 0x9000016C,28,3
+#define PAD_MUX_DIGIO_08_PINMUX_SEL 0x90000170,0,3
+#define PAD_MUX_DIGIO_09_PINMUX_SEL 0x90000170,4,3
+#define PAD_MUX_DIGIO_10_PINMUX_SEL 0x90000170,8,3
+#define PAD_MUX_DIGIO_11_PINMUX_SEL 0x90000170,12,3
+#define PAD_MUX_DIGIO_12_PINMUX_SEL 0x90000170,16,3
+#define PAD_MUX_DIGIO_13_PINMUX_SEL 0x90000170,20,3
+#define PAD_MUX_DIGIO_14_PINMUX_SEL 0x90000170,24,3
+#define PAD_MUX_DIGIO_15_PINMUX_SEL 0x90000170,28,3
+#define PAD_MUX_DIGIO_16_PINMUX_SEL 0x90000174,0,3
+#define PAD_MUX_DIGIO_17_PINMUX_SEL 0x90000174,4,3
+#define PAD_MUX_DIGIO_18_PINMUX_SEL 0x90000174,8,3
+#define PAD_MUX_DIGIO_19_PINMUX_SEL 0x90000174,12,3
+#define PAD_MUX_DIGIO_20_PINMUX_SEL 0x90000174,16,3
+#define PAD_MUX_DIGIO_21_PINMUX_SEL 0x90000174,20,3
+#define PAD_MUX_DIGIO_22_PINMUX_SEL 0x90000174,24,3
+#define PAD_MUX_DIGIO_23_PINMUX_SEL 0x90000174,28,3
+#define PAD_MUX_DIGIO_24_PINMUX_SEL 0x90000178,0,3
+#define PAD_MUX_DIGIO_25_PINMUX_SEL 0x90000178,4,3
+#define PAD_MUX_DIGIO_26_PINMUX_SEL 0x90000178,8,3
+#define PAD_MUX_DIGIO_27_PINMUX_SEL 0x90000178,12,3
+#define PAD_MUX_DIGIO_28_PINMUX_SEL 0x90000178,16,3
+#define PAD_MUX_DIGIO_29_PINMUX_SEL 0x90000178,20,3
+#define PAD_MUX_DIGIO_30_PINMUX_SEL 0x90000178,24,3
+#define PAD_MUX_DIGIO_31_PINMUX_SEL 0x90000178,28,3
+#define PAD_MUX_DIGIO_32_PINMUX_SEL 0x9000017C,0,3
+#define PAD_MUX_DIGIO_33_PINMUX_SEL 0x9000017C,4,3
+#define PAD_MUX_DIGIO_34_PINMUX_SEL 0x9000017C,8,3
+#define PAD_MUX_EJTAG_TCK_PINMUX_SEL 0x90000020,0,3
+#define PAD_MUX_EJTAG_TDI_PINMUX_SEL 0x90000020,8,3
+#define PAD_MUX_EJTAG_TMS_PINMUX_SEL 0x90000020,4,3
+#define PAD_MUX_EJTAG_TRSTN_PINMUX_SEL 0x90000020,12,3
+#define PAD_MUX_PAD_DRV_DIGIO_00 0x90000194,0,3
+#define PAD_MUX_PAD_DRV_DIGIO_05 0x90000194,20,3
+#define PAD_MUX_PAD_DRV_DIGIO_06 0x90000194,24,3
+#define PAD_MUX_PAD_DRV_DIGIO_11 0x90000198,12,3
+#define PAD_MUX_PAD_DRV_DIGIO_12 0x90000198,16,3
+#define PAD_MUX_PAD_DRV_DIGIO_13 0x90000198,20,3
+#define PAD_MUX_PAD_DRV_DIGIO_14 0x90000198,24,3
+#define PAD_MUX_PAD_DRV_DIGIO_16 0x9000019C,0,3
+#define PAD_MUX_PAD_DRV_DIGIO_17 0x9000019C,4,3
+#define PAD_MUX_PAD_DRV_DIGIO_18 0x9000019C,8,3
+#define PAD_MUX_PAD_DRV_DIGIO_22 0x9000019C,24,3
+#define PAD_MUX_PAD_DRV_DIGIO_23 0x9000019C,28,3
+#define PAD_MUX_PAD_DRV_DIGIO_24 0x900001A0,0,3
+#define PAD_MUX_PAD_DRV_DIGIO_25 0x900001A0,4,3
+#define PAD_MUX_PAD_DRV_DIGIO_29 0x900001A0,20,3
+#define PAD_MUX_PAD_DRV_DIGIO_30 0x900001A0,24,3
+#define PAD_MUX_PAD_DRV_DIGIO_31 0x900001A0,28,3
+#define PRCM_AFE_REG_CLOCK_ENABLE 0x80030014,9,1
+#define PRCM_CHIP_VERSION 0x80030000,12,4
+#define PRCM_AFE_CHIP_MMSK_VER 0x80030004,8,8
+#define PRCM_PRCM_AFE_REG_SOFT_RST_N 0x8003003C,12,1
+#define PRCM_PRCM_CPU_SOFT_RST_N 0x8003003C,0,1
+#define PRCM_PRCM_DIGRF_APB_DATA_BB0 0x80030074,0,20
+#define PRCM_PRCM_DIGRF_APB_DATA_BB1 0x80030078,0,20
+#define PRCM_PRCM_DIGRF_APB_DATA_BB2 0x8003007C,0,20
+#define PRCM_PRCM_DIGRF_APB_DATA_BB3 0x80030080,0,20
+#define PRCM_PRCM_DIGRF_APB_DATA_BB4 0x80030084,0,20
+#define PRCM_PRCM_DIGRF_APB_DATA_BB5 0x80030088,0,20
+#define PRCM_PRCM_DIGRF_APB_DATA_BB6 0x8003008C,0,20
+#define PRCM_PRCM_DIGRF_APB_DATA_BB7 0x80030090,0,20
+#define PRCM_PRCM_DIGRF_CAPT_DONE 0x80030070,24,8
+#define PRCM_PRCM_DIGRF_START_CAPT 0x80030064,2,1
+#define PRCM_PRCM_PAD_MUX_SOFT_RST_N 0x8003003C,11,1
+#define PRCM_PRCM_XPT_PARALLEL_FIFO_RST_N 0x80030028,20,1
+#define XPT_APPEND_BYTES0 0x90700008,4,2
+#define XPT_APPEND_BYTES1 0x90700008,6,2
+#define XPT_CLOCK_POLARITY0 0x90700010,16,1
+#define XPT_CLOCK_POLARITY1 0x90700010,17,1
+#define XPT_CLOCK_POLARITY2 0x90700010,18,1
+#define XPT_CLOCK_POLARITY3 0x90700010,19,1
+#define XPT_CLOCK_POLARITY4 0x90700010,20,1
+#define XPT_CLOCK_POLARITY5 0x90700010,21,1
+#define XPT_CLOCK_POLARITY6 0x90700010,22,1
+#define XPT_CLOCK_POLARITY7 0x90700010,23,1
+#define XPT_DSS_DVB_ENCAP_EN0 0x90700000,16,1
+#define XPT_DSS_DVB_ENCAP_EN1 0x90700000,17,1
+#define XPT_DSS_DVB_ENCAP_EN2 0x90700000,18,1
+#define XPT_DSS_DVB_ENCAP_EN3 0x90700000,19,1
+#define XPT_DSS_DVB_ENCAP_EN4 0x90700000,20,1
+#define XPT_DSS_DVB_ENCAP_EN5 0x90700000,21,1
+#define XPT_DSS_DVB_ENCAP_EN6 0x90700000,22,1
+#define XPT_DSS_DVB_ENCAP_EN7 0x90700000,23,1
+#define XPT_DVB_MATCH_BYTE 0x9070017C,16,8
+#define XPT_DVB_PACKET_SIZE0 0x90700180,0,8
+#define XPT_DVB_PACKET_SIZE1 0x90700180,8,8
+#define XPT_DVB_PACKET_SIZE2 0x90700180,16,8
+#define XPT_DVB_PACKET_SIZE3 0x90700180,24,8
+#define XPT_ENABLE_DVB_INPUT0 0x90700178,0,1
+#define XPT_ENABLE_DVB_INPUT1 0x90700178,1,1
+#define XPT_ENABLE_DVB_INPUT2 0x90700178,2,1
+#define XPT_ENABLE_DVB_INPUT3 0x90700178,3,1
+#define XPT_ENABLE_INPUT0 0x90700000,0,1
+#define XPT_ENABLE_INPUT1 0x90700000,1,1
+#define XPT_ENABLE_INPUT2 0x90700000,2,1
+#define XPT_ENABLE_INPUT3 0x90700000,3,1
+#define XPT_ENABLE_INPUT4 0x90700000,4,1
+#define XPT_ENABLE_INPUT5 0x90700000,5,1
+#define XPT_ENABLE_INPUT6 0x90700000,6,1
+#define XPT_ENABLE_INPUT7 0x90700000,7,1
+#define XPT_ENABLE_OUTPUT0 0x9070000C,0,1
+#define XPT_ENABLE_OUTPUT1 0x9070000C,1,1
+#define XPT_ENABLE_OUTPUT2 0x9070000C,2,1
+#define XPT_ENABLE_OUTPUT3 0x9070000C,3,1
+#define XPT_ENABLE_OUTPUT4 0x9070000C,4,1
+#define XPT_ENABLE_OUTPUT5 0x9070000C,5,1
+#define XPT_ENABLE_OUTPUT6 0x9070000C,6,1
+#define XPT_ENABLE_OUTPUT7 0x9070000C,7,1
+#define XPT_ENABLE_PARALLEL_OUTPUT 0x90700010,27,1
+#define XPT_ENABLE_PCR_COUNT 0x90700184,1,1
+#define XPT_ERROR_REPLACE_SYNC0 0x9070000C,24,1
+#define XPT_ERROR_REPLACE_SYNC1 0x9070000C,25,1
+#define XPT_ERROR_REPLACE_SYNC2 0x9070000C,26,1
+#define XPT_ERROR_REPLACE_SYNC3 0x9070000C,27,1
+#define XPT_ERROR_REPLACE_SYNC4 0x9070000C,28,1
+#define XPT_ERROR_REPLACE_SYNC5 0x9070000C,29,1
+#define XPT_ERROR_REPLACE_SYNC6 0x9070000C,30,1
+#define XPT_ERROR_REPLACE_SYNC7 0x9070000C,31,1
+#define XPT_ERROR_REPLACE_VALID0 0x90700014,8,1
+#define XPT_ERROR_REPLACE_VALID1 0x90700014,9,1
+#define XPT_ERROR_REPLACE_VALID2 0x90700014,10,1
+#define XPT_ERROR_REPLACE_VALID3 0x90700014,11,1
+#define XPT_ERROR_REPLACE_VALID4 0x90700014,12,1
+#define XPT_ERROR_REPLACE_VALID5 0x90700014,13,1
+#define XPT_ERROR_REPLACE_VALID6 0x90700014,14,1
+#define XPT_ERROR_REPLACE_VALID7 0x90700014,15,1
+#define XPT_INP0_MERGE_HDR0 0x90700058,0,32
+#define XPT_INP0_MERGE_HDR1 0x9070005C,0,32
+#define XPT_INP0_MERGE_HDR2 0x90700060,0,32
+#define XPT_INP1_MERGE_HDR0 0x90700064,0,32
+#define XPT_INP1_MERGE_HDR1 0x90700068,0,32
+#define XPT_INP1_MERGE_HDR2 0x9070006C,0,32
+#define XPT_INP2_MERGE_HDR0 0x90700070,0,32
+#define XPT_INP2_MERGE_HDR1 0x90700074,0,32
+#define XPT_INP2_MERGE_HDR2 0x90700078,0,32
+#define XPT_INP3_MERGE_HDR0 0x9070007C,0,32
+#define XPT_INP3_MERGE_HDR1 0x90700080,0,32
+#define XPT_INP3_MERGE_HDR2 0x90700084,0,32
+#define XPT_INP4_MERGE_HDR0 0x90700088,0,32
+#define XPT_INP4_MERGE_HDR1 0x9070008C,0,32
+#define XPT_INP4_MERGE_HDR2 0x90700090,0,32
+#define XPT_INP5_MERGE_HDR0 0x90700094,0,32
+#define XPT_INP5_MERGE_HDR1 0x90700098,0,32
+#define XPT_INP5_MERGE_HDR2 0x9070009C,0,32
+#define XPT_INP6_MERGE_HDR0 0x907000A0,0,32
+#define XPT_INP6_MERGE_HDR1 0x907000A4,0,32
+#define XPT_INP6_MERGE_HDR2 0x907000A8,0,32
+#define XPT_INP7_MERGE_HDR0 0x907000AC,0,32
+#define XPT_INP7_MERGE_HDR1 0x907000B0,0,32
+#define XPT_INP7_MERGE_HDR2 0x907000B4,0,32
+#define XPT_INP_MODE_DSS0 0x90700000,8,1
+#define XPT_INP_MODE_DSS1 0x90700000,9,1
+#define XPT_INP_MODE_DSS2 0x90700000,10,1
+#define XPT_INP_MODE_DSS3 0x90700000,11,1
+#define XPT_INP_MODE_DSS4 0x90700000,12,1
+#define XPT_INP_MODE_DSS5 0x90700000,13,1
+#define XPT_INP_MODE_DSS6 0x90700000,14,1
+#define XPT_INP_MODE_DSS7 0x90700000,15,1
+#define XPT_KNOWN_PID_MUX_SELECT0 0x90700190,8,4
+#define XPT_KNOWN_PID_MUX_SELECT1 0x907001B0,8,4
+#define XPT_LSB_FIRST0 0x9070000C,16,1
+#define XPT_LSB_FIRST1 0x9070000C,17,1
+#define XPT_LSB_FIRST2 0x9070000C,18,1
+#define XPT_LSB_FIRST3 0x9070000C,19,1
+#define XPT_LSB_FIRST4 0x9070000C,20,1
+#define XPT_LSB_FIRST5 0x9070000C,21,1
+#define XPT_LSB_FIRST6 0x9070000C,22,1
+#define XPT_LSB_FIRST7 0x9070000C,23,1
+#define XPT_MODE_27MHZ 0x90700184,0,1
+#define XPT_NCO_COUNT_MIN 0x90700044,16,8
+#define XPT_OUTPUT_MODE_DSS0 0x9070000C,8,1
+#define XPT_OUTPUT_MODE_DSS1 0x9070000C,9,1
+#define XPT_OUTPUT_MODE_DSS2 0x9070000C,10,1
+#define XPT_OUTPUT_MODE_DSS3 0x9070000C,11,1
+#define XPT_OUTPUT_MODE_DSS4 0x9070000C,12,1
+#define XPT_OUTPUT_MODE_DSS5 0x9070000C,13,1
+#define XPT_OUTPUT_MODE_DSS6 0x9070000C,14,1
+#define XPT_OUTPUT_MODE_DSS7 0x9070000C,15,1
+#define XPT_OUTPUT_MODE_MUXGATING0 0x90700020,0,1
+#define XPT_OUTPUT_MODE_MUXGATING1 0x90700020,1,1
+#define XPT_OUTPUT_MODE_MUXGATING2 0x90700020,2,1
+#define XPT_OUTPUT_MODE_MUXGATING3 0x90700020,3,1
+#define XPT_OUTPUT_MODE_MUXGATING4 0x90700020,4,1
+#define XPT_OUTPUT_MODE_MUXGATING5 0x90700020,5,1
+#define XPT_OUTPUT_MODE_MUXGATING6 0x90700020,6,1
+#define XPT_OUTPUT_MODE_MUXGATING7 0x90700020,7,1
+#define XPT_OUTPUT_MUXSELECT0 0x9070001C,0,3
+#define XPT_OUTPUT_MUXSELECT1 0x9070001C,4,3
+#define XPT_OUTPUT_MUXSELECT2 0x9070001C,8,3
+#define XPT_OUTPUT_MUXSELECT3 0x9070001C,12,3
+#define XPT_OUTPUT_MUXSELECT4 0x9070001C,16,3
+#define XPT_OUTPUT_MUXSELECT5 0x9070001C,20,3
+#define XPT_PCR_RTS_CORRECTION_ENABLE 0x90700008,14,1
+#define XPT_PID_DEFAULT_DROP0 0x90700190,12,1
+#define XPT_PID_DEFAULT_DROP1 0x90700190,13,1
+#define XPT_PID_DEFAULT_DROP2 0x90700190,14,1
+#define XPT_PID_DEFAULT_DROP3 0x90700190,15,1
+#define XPT_PID_DEFAULT_DROP4 0x907001B0,12,1
+#define XPT_PID_DEFAULT_DROP5 0x907001B0,13,1
+#define XPT_PID_DEFAULT_DROP6 0x907001B0,14,1
+#define XPT_PID_DEFAULT_DROP7 0x907001B0,15,1
+#define XPT_PID_MUX_SELECT0 0x90700190,4,4
+#define XPT_PID_MUX_SELECT1 0x907001B0,4,4
+#define XPT_STREAM_MUXMODE0 0x90700008,0,2
+#define XPT_STREAM_MUXMODE1 0x90700008,2,2
+#define XPT_SYNC_FULL_BYTE0 0x90700010,0,1
+#define XPT_SYNC_FULL_BYTE1 0x90700010,1,1
+#define XPT_SYNC_FULL_BYTE2 0x90700010,2,1
+#define XPT_SYNC_FULL_BYTE3 0x90700010,3,1
+#define XPT_SYNC_FULL_BYTE4 0x90700010,4,1
+#define XPT_SYNC_FULL_BYTE5 0x90700010,5,1
+#define XPT_SYNC_FULL_BYTE6 0x90700010,6,1
+#define XPT_SYNC_FULL_BYTE7 0x90700010,7,1
+#define XPT_SYNC_LOCK_THRESHOLD 0x9070017C,0,8
+#define XPT_SYNC_MISS_THRESHOLD 0x9070017C,8,8
+#define XPT_SYNC_POLARITY0 0x90700010,8,1
+#define XPT_SYNC_POLARITY1 0x90700010,9,1
+#define XPT_SYNC_POLARITY2 0x90700010,10,1
+#define XPT_SYNC_POLARITY3 0x90700010,11,1
+#define XPT_SYNC_POLARITY4 0x90700010,12,1
+#define XPT_SYNC_POLARITY5 0x90700010,13,1
+#define XPT_SYNC_POLARITY6 0x90700010,14,1
+#define XPT_SYNC_POLARITY7 0x90700010,15,1
+#define XPT_TS_CLK_OUT_EN0 0x907001D4,0,1
+#define XPT_TS_CLK_OUT_EN1 0x907001D4,1,1
+#define XPT_TS_CLK_OUT_EN2 0x907001D4,2,1
+#define XPT_TS_CLK_OUT_EN3 0x907001D4,3,1
+#define XPT_TS_CLK_OUT_EN4 0x907001D4,4,1
+#define XPT_TS_CLK_OUT_EN5 0x907001D4,5,1
+#define XPT_TS_CLK_OUT_EN6 0x907001D4,6,1
+#define XPT_TS_CLK_OUT_EN7 0x907001D4,7,1
+#define XPT_TS_CLK_OUT_EN_PARALLEL 0x907001D4,8,1
+#define XPT_TS_CLK_PHASE0 0x90700018,0,3
+#define XPT_TS_CLK_PHASE1 0x90700018,4,3
+#define XPT_TS_CLK_PHASE2 0x90700018,8,3
+#define XPT_TS_CLK_PHASE3 0x90700018,12,3
+#define XPT_TS_CLK_PHASE4 0x90700018,16,3
+#define XPT_TS_CLK_PHASE5 0x90700018,20,3
+#define XPT_TS_CLK_PHASE6 0x90700018,24,3
+#define XPT_TS_CLK_PHASE7 0x90700018,28,3
+#define XPT_VALID_POLARITY0 0x90700014,0,1
+#define XPT_VALID_POLARITY1 0x90700014,1,1
+#define XPT_VALID_POLARITY2 0x90700014,2,1
+#define XPT_VALID_POLARITY3 0x90700014,3,1
+#define XPT_VALID_POLARITY4 0x90700014,4,1
+#define XPT_VALID_POLARITY5 0x90700014,5,1
+#define XPT_VALID_POLARITY6 0x90700014,6,1
+#define XPT_VALID_POLARITY7 0x90700014,7,1
+#define XPT_ZERO_FILL_COUNT 0x90700008,8,6
+
+#define   XPT_PACKET_GAP_MIN_BASEADDR                            0x90700044
+#define   XPT_PACKET_GAP_MIN_TIMER                               XPT_PACKET_GAP_MIN_BASEADDR,0,16
+#define   XPT_NCO_COUNT_MIN0 XPT_PACKET_GAP_MIN_BASEADDR,16,8
+#define   XPT_NCO_COUNT_BASEADDR                                 0x90700238
+#define   XPT_NCO_COUNT_MIN1 XPT_NCO_COUNT_BASEADDR,0,8
+#define   XPT_NCO_COUNT_MIN2 XPT_NCO_COUNT_BASEADDR,8,8
+#define   XPT_NCO_COUNT_MIN3 XPT_NCO_COUNT_BASEADDR,16,8
+#define   XPT_NCO_COUNT_MIN4 XPT_NCO_COUNT_BASEADDR,24,8
+
+#define   XPT_NCO_COUNT_BASEADDR1                                0x9070023C
+#define   XPT_NCO_COUNT_MIN5 XPT_NCO_COUNT_BASEADDR1,0,8
+#define   XPT_NCO_COUNT_MIN6 XPT_NCO_COUNT_BASEADDR1,8,8
+#define   XPT_NCO_COUNT_MIN7 XPT_NCO_COUNT_BASEADDR1,16,8
+
+// V2 DigRF status register
+#define   BB0_DIGRF_CAPT_DONE                                    0x908000CC,0,1
+#define   PRCM_PRCM_CHIP_ID                                      0x80030000,0,12
+
+#define   XPT_PID_BASEADDR                                       0x90708000
+#define   XPT_PID_VALID0                                         XPT_PID_BASEADDR,0,1
+#define   XPT_PID_DROP0                                          XPT_PID_BASEADDR,1,1
+#define   XPT_PID_REMAP0                                         XPT_PID_BASEADDR,2,1
+#define   XPT_PID_VALUE0                                         XPT_PID_BASEADDR,4,13
+#define   XPT_PID_MASK0                                          XPT_PID_BASEADDR,19,13
+
+#define   XPT_PID_REMAP_BASEADDR                                 0x90708004
+#define   XPT_PID_REMAP_VALUE0                                   XPT_PID_REMAP_BASEADDR,0,13
+#define   XPT_PID_PORT_ID0                                       XPT_PID_REMAP_BASEADDR,16,3
+
+#define   XPT_KNOWN_PID_BASEADDR                                 0x90709000
+#define   XPT_KNOWN_PID_VALID0                                   XPT_KNOWN_PID_BASEADDR,0,1
+#define   XPT_KNOWN_PID_DROP0                                    XPT_KNOWN_PID_BASEADDR,1,1
+#define   XPT_KNOWN_PID_REMAP0                                   XPT_KNOWN_PID_BASEADDR,2,1
+#define   XPT_KNOWN_PID_REMAP_VALUE0                             XPT_KNOWN_PID_BASEADDR,16,13
+
+#define   XPT_PID_BASEADDR1                                      0x9070A000
+#define   XPT_PID_VALID1                                         XPT_PID_BASEADDR1,0,1
+#define   XPT_PID_DROP1                                          XPT_PID_BASEADDR1,1,1
+#define   XPT_PID_REMAP1                                         XPT_PID_BASEADDR1,2,1
+#define   XPT_PID_VALUE1                                         XPT_PID_BASEADDR1,4,13
+#define   XPT_PID_MASK1                                          XPT_PID_BASEADDR1,19,13
+
+#define   XPT_PID_REMAP_BASEADDR1                                0x9070A004
+#define   XPT_PID_REMAP_VALUE1                                   XPT_PID_REMAP_BASEADDR1,0,13
+
+#define   XPT_KNOWN_PID_BASEADDR1                                0x9070B000
+#define   XPT_KNOWN_PID_VALID1                                   XPT_KNOWN_PID_BASEADDR1,0,1
+#define   XPT_KNOWN_PID_DROP1                                    XPT_KNOWN_PID_BASEADDR1,1,1
+#define   XPT_KNOWN_PID_REMAP1                                   XPT_KNOWN_PID_BASEADDR1,2,1
+#define   XPT_KNOWN_PID_REMAP_VALUE1                             XPT_KNOWN_PID_BASEADDR1,16,13
+
+#define   XPT_BERT_LOCK_BASEADDR                                 0x907000B8
+#define   XPT_BERT_LOCK_THRESHOLD                                XPT_BERT_LOCK_BASEADDR,0,8
+#define   XPT_BERT_LOCK_WINDOW                                   XPT_BERT_LOCK_BASEADDR,8,8
+
+#define   XPT_BERT_BASEADDR                                      0x907000BC
+#define   XPT_BERT_ENABLE0                                       XPT_BERT_BASEADDR,0,1
+#define   XPT_BERT_ENABLE1                                       XPT_BERT_BASEADDR,1,1
+#define   XPT_BERT_ENABLE2                                       XPT_BERT_BASEADDR,2,1
+#define   XPT_BERT_ENABLE3                                       XPT_BERT_BASEADDR,3,1
+#define   XPT_BERT_ENABLE4                                       XPT_BERT_BASEADDR,4,1
+#define   XPT_BERT_ENABLE5                                       XPT_BERT_BASEADDR,5,1
+#define   XPT_BERT_ENABLE6                                       XPT_BERT_BASEADDR,6,1
+#define   XPT_BERT_ENABLE7                                       XPT_BERT_BASEADDR,7,1
+#define   XPT_BERT_SEQUENCE_PN23_0                               XPT_BERT_BASEADDR,8,1
+#define   XPT_BERT_SEQUENCE_PN23_1                               XPT_BERT_BASEADDR,9,1
+#define   XPT_BERT_SEQUENCE_PN23_2                               XPT_BERT_BASEADDR,10,1
+#define   XPT_BERT_SEQUENCE_PN23_3                               XPT_BERT_BASEADDR,11,1
+#define   XPT_BERT_SEQUENCE_PN23_4                               XPT_BERT_BASEADDR,12,1
+#define   XPT_BERT_SEQUENCE_PN23_5                               XPT_BERT_BASEADDR,13,1
+#define   XPT_BERT_SEQUENCE_PN23_6                               XPT_BERT_BASEADDR,14,1
+#define   XPT_BERT_SEQUENCE_PN23_7                               XPT_BERT_BASEADDR,15,1
+#define   XPT_LOCK_RESYNC0                                       XPT_BERT_BASEADDR,16,1
+#define   XPT_LOCK_RESYNC1                                       XPT_BERT_BASEADDR,17,1
+#define   XPT_LOCK_RESYNC2                                       XPT_BERT_BASEADDR,18,1
+#define   XPT_LOCK_RESYNC3                                       XPT_BERT_BASEADDR,19,1
+#define   XPT_LOCK_RESYNC4                                       XPT_BERT_BASEADDR,20,1
+#define   XPT_LOCK_RESYNC5                                       XPT_BERT_BASEADDR,21,1
+#define   XPT_LOCK_RESYNC6                                       XPT_BERT_BASEADDR,22,1
+#define   XPT_LOCK_RESYNC7                                       XPT_BERT_BASEADDR,23,1
+#define   XPT_BERT_DATA_POLARITY0                                XPT_BERT_BASEADDR,24,1
+#define   XPT_BERT_DATA_POLARITY1                                XPT_BERT_BASEADDR,25,1
+#define   XPT_BERT_DATA_POLARITY2                                XPT_BERT_BASEADDR,26,1
+#define   XPT_BERT_DATA_POLARITY3                                XPT_BERT_BASEADDR,27,1
+#define   XPT_BERT_DATA_POLARITY4                                XPT_BERT_BASEADDR,28,1
+#define   XPT_BERT_DATA_POLARITY5                                XPT_BERT_BASEADDR,29,1
+#define   XPT_BERT_DATA_POLARITY6                                XPT_BERT_BASEADDR,30,1
+#define   XPT_BERT_DATA_POLARITY7                                XPT_BERT_BASEADDR,31,1
+
+#define   XPT_BERT_INVERT_BASEADDR                               0x907000C0
+#define   XPT_BERT_INVERT_DATA0                                  XPT_BERT_INVERT_BASEADDR,0,1
+#define   XPT_BERT_INVERT_DATA1                                  XPT_BERT_INVERT_BASEADDR,1,1
+#define   XPT_BERT_INVERT_DATA2                                  XPT_BERT_INVERT_BASEADDR,2,1
+#define   XPT_BERT_INVERT_DATA3                                  XPT_BERT_INVERT_BASEADDR,3,1
+#define   XPT_BERT_INVERT_DATA4                                  XPT_BERT_INVERT_BASEADDR,4,1
+#define   XPT_BERT_INVERT_DATA5                                  XPT_BERT_INVERT_BASEADDR,5,1
+#define   XPT_BERT_INVERT_DATA6                                  XPT_BERT_INVERT_BASEADDR,6,1
+#define   XPT_BERT_INVERT_DATA7                                  XPT_BERT_INVERT_BASEADDR,7,1
+#define   XPT_BERT_INVERT_SEQUENCE0                              XPT_BERT_INVERT_BASEADDR,8,1
+#define   XPT_BERT_INVERT_SEQUENCE1                              XPT_BERT_INVERT_BASEADDR,9,1
+#define   XPT_BERT_INVERT_SEQUENCE2                              XPT_BERT_INVERT_BASEADDR,10,1
+#define   XPT_BERT_INVERT_SEQUENCE3                              XPT_BERT_INVERT_BASEADDR,11,1
+#define   XPT_BERT_INVERT_SEQUENCE4                              XPT_BERT_INVERT_BASEADDR,12,1
+#define   XPT_BERT_INVERT_SEQUENCE5                              XPT_BERT_INVERT_BASEADDR,13,1
+#define   XPT_BERT_INVERT_SEQUENCE6                              XPT_BERT_INVERT_BASEADDR,14,1
+#define   XPT_BERT_INVERT_SEQUENCE7                              XPT_BERT_INVERT_BASEADDR,15,1
+#define   XPT_BERT_OUTPUT_POLARITY0                              XPT_BERT_INVERT_BASEADDR,16,1
+#define   XPT_BERT_OUTPUT_POLARITY1                              XPT_BERT_INVERT_BASEADDR,17,1
+#define   XPT_BERT_OUTPUT_POLARITY2                              XPT_BERT_INVERT_BASEADDR,18,1
+#define   XPT_BERT_OUTPUT_POLARITY3                              XPT_BERT_INVERT_BASEADDR,19,1
+#define   XPT_BERT_OUTPUT_POLARITY4                              XPT_BERT_INVERT_BASEADDR,20,1
+#define   XPT_BERT_OUTPUT_POLARITY5                              XPT_BERT_INVERT_BASEADDR,21,1
+#define   XPT_BERT_OUTPUT_POLARITY6                              XPT_BERT_INVERT_BASEADDR,22,1
+#define   XPT_BERT_OUTPUT_POLARITY7                              XPT_BERT_INVERT_BASEADDR,23,1
+
+#define   XPT_BERT_HEADER_BASEADDR                               0x907000C4
+#define   XPT_BERT_HEADER_MODE0                                  XPT_BERT_HEADER_BASEADDR,0,2
+#define   XPT_BERT_HEADER_MODE1                                  XPT_BERT_HEADER_BASEADDR,2,2
+#define   XPT_BERT_HEADER_MODE2                                  XPT_BERT_HEADER_BASEADDR,4,2
+#define   XPT_BERT_HEADER_MODE3                                  XPT_BERT_HEADER_BASEADDR,6,2
+#define   XPT_BERT_HEADER_MODE4                                  XPT_BERT_HEADER_BASEADDR,8,2
+#define   XPT_BERT_HEADER_MODE5                                  XPT_BERT_HEADER_BASEADDR,10,2
+#define   XPT_BERT_HEADER_MODE6                                  XPT_BERT_HEADER_BASEADDR,12,2
+#define   XPT_BERT_HEADER_MODE7                                  XPT_BERT_HEADER_BASEADDR,14,2
+
+#define   XPT_BERT_BASEADDR1                                     0x907000C8
+#define   XPT_BERT_LOCKED0                                       XPT_BERT_BASEADDR1,0,1
+#define   XPT_BERT_LOCKED1                                       XPT_BERT_BASEADDR1,1,1
+#define   XPT_BERT_LOCKED2                                       XPT_BERT_BASEADDR1,2,1
+#define   XPT_BERT_LOCKED3                                       XPT_BERT_BASEADDR1,3,1
+#define   XPT_BERT_LOCKED4                                       XPT_BERT_BASEADDR1,4,1
+#define   XPT_BERT_LOCKED5                                       XPT_BERT_BASEADDR1,5,1
+#define   XPT_BERT_LOCKED6                                       XPT_BERT_BASEADDR1,6,1
+#define   XPT_BERT_LOCKED7                                       XPT_BERT_BASEADDR1,7,1
+#define   XPT_BERT_BIT_COUNT_SAT0                                XPT_BERT_BASEADDR1,8,1
+#define   XPT_BERT_BIT_COUNT_SAT1                                XPT_BERT_BASEADDR1,9,1
+#define   XPT_BERT_BIT_COUNT_SAT2                                XPT_BERT_BASEADDR1,10,1
+#define   XPT_BERT_BIT_COUNT_SAT3                                XPT_BERT_BASEADDR1,11,1
+#define   XPT_BERT_BIT_COUNT_SAT4                                XPT_BERT_BASEADDR1,12,1
+#define   XPT_BERT_BIT_COUNT_SAT5                                XPT_BERT_BASEADDR1,13,1
+#define   XPT_BERT_BIT_COUNT_SAT6                                XPT_BERT_BASEADDR1,14,1
+#define   XPT_BERT_BIT_COUNT_SAT7                                XPT_BERT_BASEADDR1,15,1
+
+#define   XPT_BERT_BIT_COUNT0_BASEADDR                           0x907000CC
+#define   XPT_BERT_BIT_COUNT0_LO                                 XPT_BERT_BIT_COUNT0_BASEADDR,0,32
+
+#define   XPT_BERT_BIT_COUNT0_BASEADDR1                          0x907000D0
+#define   XPT_BERT_BIT_COUNT0_HI                                 XPT_BERT_BIT_COUNT0_BASEADDR1,0,18
+
+#define   XPT_BERT_BIT_COUNT1_BASEADDR                           0x907000D4
+#define   XPT_BERT_BIT_COUNT1_LO                                 XPT_BERT_BIT_COUNT1_BASEADDR,0,32
+
+#define   XPT_BERT_BIT_COUNT1_BASEADDR1                          0x907000D8
+#define   XPT_BERT_BIT_COUNT1_HI                                 XPT_BERT_BIT_COUNT1_BASEADDR1,0,18
+
+#define   XPT_BERT_BIT_COUNT2_BASEADDR                           0x907000DC
+#define   XPT_BERT_BIT_COUNT2_LO                                 XPT_BERT_BIT_COUNT2_BASEADDR,0,32
+
+#define   XPT_BERT_BIT_COUNT2_BASEADDR1                          0x907000E0
+#define   XPT_BERT_BIT_COUNT2_HI                                 XPT_BERT_BIT_COUNT2_BASEADDR1,0,18
+
+#define   XPT_BERT_BIT_COUNT3_BASEADDR                           0x907000E4
+#define   XPT_BERT_BIT_COUNT3_LO                                 XPT_BERT_BIT_COUNT3_BASEADDR,0,32
+
+#define   XPT_BERT_BIT_COUNT3_BASEADDR1                          0x907000E8
+#define   XPT_BERT_BIT_COUNT3_HI                                 XPT_BERT_BIT_COUNT3_BASEADDR1,0,18
+
+#define   XPT_BERT_BIT_COUNT4_BASEADDR                           0x907000EC
+#define   XPT_BERT_BIT_COUNT4_LO                                 XPT_BERT_BIT_COUNT4_BASEADDR,0,32
+
+#define   XPT_BERT_BIT_COUNT4_BASEADDR1                          0x907000F0
+#define   XPT_BERT_BIT_COUNT4_HI                                 XPT_BERT_BIT_COUNT4_BASEADDR1,0,18
+
+#define   XPT_BERT_BIT_COUNT5_BASEADDR                           0x907000F4
+#define   XPT_BERT_BIT_COUNT5_LO                                 XPT_BERT_BIT_COUNT5_BASEADDR,0,32
+
+#define   XPT_BERT_BIT_COUNT5_BASEADDR1                          0x907000F8
+#define   XPT_BERT_BIT_COUNT5_HI                                 XPT_BERT_BIT_COUNT5_BASEADDR1,0,18
+
+#define   XPT_BERT_BIT_COUNT6_BASEADDR                           0x907000FC
+#define   XPT_BERT_BIT_COUNT6_LO                                 XPT_BERT_BIT_COUNT6_BASEADDR,0,32
+
+#define   XPT_BERT_BIT_COUNT6_BASEADDR1                          0x90700100
+#define   XPT_BERT_BIT_COUNT6_HI                                 XPT_BERT_BIT_COUNT6_BASEADDR1,0,18
+
+#define   XPT_BERT_BIT_COUNT7_BASEADDR                           0x90700104
+#define   XPT_BERT_BIT_COUNT7_LO                                 XPT_BERT_BIT_COUNT7_BASEADDR,0,32
+
+#define   XPT_BERT_BIT_COUNT7_BASEADDR1                          0x90700108
+#define   XPT_BERT_BIT_COUNT7_HI                                 XPT_BERT_BIT_COUNT7_BASEADDR1,0,18
+
+#define   XPT_BERT_ERR_COUNT0_BASEADDR                           0x9070010C
+#define   XPT_BERT_ERR_COUNT0_LO                                 XPT_BERT_ERR_COUNT0_BASEADDR,0,32
+
+#define   XPT_BERT_ERR_COUNT0_BASEADDR1                          0x90700110
+#define   XPT_BERT_ERR_COUNT0_HI                                 XPT_BERT_ERR_COUNT0_BASEADDR1,0,8
+
+#define   XPT_BERT_ERR_COUNT1_BASEADDR                           0x90700114
+#define   XPT_BERT_ERR_COUNT1_LO                                 XPT_BERT_ERR_COUNT1_BASEADDR,0,32
+
+#define   XPT_BERT_ERR_COUNT1_BASEADDR1                          0x90700118
+#define   XPT_BERT_ERR_COUNT1_HI                                 XPT_BERT_ERR_COUNT1_BASEADDR1,0,8
+
+#define   XPT_BERT_ERR_COUNT2_BASEADDR                           0x9070011C
+#define   XPT_BERT_ERR_COUNT2_LO                                 XPT_BERT_ERR_COUNT2_BASEADDR,0,32
+
+#define   XPT_BERT_ERR_COUNT2_BASEADDR1                          0x90700120
+#define   XPT_BERT_ERR_COUNT2_HI                                 XPT_BERT_ERR_COUNT2_BASEADDR1,0,8
+
+#define   XPT_BERT_ERR_COUNT3_BASEADDR                           0x90700124
+#define   XPT_BERT_ERR_COUNT3_LO                                 XPT_BERT_ERR_COUNT3_BASEADDR,0,32
+
+#define   XPT_BERT_ERR_COUNT3_BASEADDR1                          0x90700128
+#define   XPT_BERT_ERR_COUNT3_HI                                 XPT_BERT_ERR_COUNT3_BASEADDR1,0,8
+
+#define   XPT_BERT_ERR_COUNT4_BASEADDR                           0x9070012C
+#define   XPT_BERT_ERR_COUNT4_LO                                 XPT_BERT_ERR_COUNT4_BASEADDR,0,32
+
+#define   XPT_BERT_ERR_COUNT4_BASEADDR1                          0x90700130
+#define   XPT_BERT_ERR_COUNT4_HI                                 XPT_BERT_ERR_COUNT4_BASEADDR1,0,8
+
+#define   XPT_BERT_ERR_COUNT5_BASEADDR                           0x90700134
+#define   XPT_BERT_ERR_COUNT5_LO                                 XPT_BERT_ERR_COUNT5_BASEADDR,0,32
+
+#define   XPT_BERT_ERR_COUNT5_BASEADDR1                          0x90700138
+#define   XPT_BERT_ERR_COUNT5_HI                                 XPT_BERT_ERR_COUNT5_BASEADDR1,0,8
+
+#define   XPT_BERT_ERR_COUNT6_BASEADDR                           0x9070013C
+#define   XPT_BERT_ERR_COUNT6_LO                                 XPT_BERT_ERR_COUNT6_BASEADDR,0,32
+
+#define   XPT_BERT_ERR_COUNT6_BASEADDR1                          0x90700140
+#define   XPT_BERT_ERR_COUNT6_HI                                 XPT_BERT_ERR_COUNT6_BASEADDR1,0,8
+
+#define   XPT_BERT_ERR_COUNT7_BASEADDR                           0x90700144
+#define   XPT_BERT_ERR_COUNT7_LO                                 XPT_BERT_ERR_COUNT7_BASEADDR,0,32
+
+#define   XPT_BERT_ERR_COUNT7_BASEADDR1                          0x90700148
+#define   XPT_BERT_ERR_COUNT7_HI                                 XPT_BERT_ERR_COUNT7_BASEADDR1,0,8
+
+#define   XPT_BERT_ERROR_BASEADDR                                0x9070014C
+#define   XPT_BERT_ERROR_INSERT                                  XPT_BERT_ERROR_BASEADDR,0,24
+
+#define   XPT_BERT_ANALYZER_BASEADDR                             0x90700150
+#define   XPT_BERT_ANALYZER_ENABLE                               XPT_BERT_ANALYZER_BASEADDR,0,1
+#define   XPT_BERT_ANALYZER_PORT                                 XPT_BERT_ANALYZER_BASEADDR,4,3
+#define   XPT_BERT_ANALYZER_ERR_THRES                            XPT_BERT_ANALYZER_BASEADDR,15,17
+
+#define   XPT_BERT_ANALYZER_BASEADDR1                            0x90700154
+#define   XPT_BERT_ANALYZER_START                                XPT_BERT_ANALYZER_BASEADDR1,0,32
+
+#define   XPT_BERT_ANALYZER_BASEADDR2                            0x90700158
+#define   XPT_BERT_ANALYZER_TSTAMP0                              XPT_BERT_ANALYZER_BASEADDR2,0,32
+
+#define   XPT_BERT_ANALYZER_BASEADDR3                            0x9070015C
+#define   XPT_BERT_ANALYZER_TSTAMP1                              XPT_BERT_ANALYZER_BASEADDR3,0,32
+
+#define   XPT_BERT_ANALYZER_BASEADDR4                            0x90700160
+#define   XPT_BERT_ANALYZER_TSTAMP2                              XPT_BERT_ANALYZER_BASEADDR4,0,32
+
+#define   XPT_BERT_ANALYZER_BASEADDR5                            0x90700164
+#define   XPT_BERT_ANALYZER_TSTAMP3                              XPT_BERT_ANALYZER_BASEADDR5,0,32
+
+#define   XPT_BERT_ANALYZER_BASEADDR6                            0x90700168
+#define   XPT_BERT_ANALYZER_TSTAMP4                              XPT_BERT_ANALYZER_BASEADDR6,0,32
+
+#define   XPT_BERT_ANALYZER_BASEADDR7                            0x9070016C
+#define   XPT_BERT_ANALYZER_TSTAMP5                              XPT_BERT_ANALYZER_BASEADDR7,0,32
+
+#define   XPT_BERT_ANALYZER_BASEADDR8                            0x90700170
+#define   XPT_BERT_ANALYZER_TSTAMP6                              XPT_BERT_ANALYZER_BASEADDR8,0,32
+
+#define   XPT_BERT_ANALYZER_BASEADDR9                            0x90700174
+#define   XPT_BERT_ANALYZER_TSTAMP7                              XPT_BERT_ANALYZER_BASEADDR9,0,32
+
+#define   XPT_DMD0_BASEADDR                                      0x9070024C
+#define   XPT_DMD0_SEL                                           XPT_DMD0_BASEADDR,0,3
+#define   XPT_DMD1_SEL                                           XPT_DMD0_BASEADDR,4,3
+#define   XPT_DMD2_SEL                                           XPT_DMD0_BASEADDR,8,3
+#define   XPT_DMD3_SEL                                           XPT_DMD0_BASEADDR,12,3
+#define   XPT_DMD4_SEL                                           XPT_DMD0_BASEADDR,16,3
+#define   XPT_DMD5_SEL                                           XPT_DMD0_BASEADDR,20,3
+#define   XPT_DMD6_SEL                                           XPT_DMD0_BASEADDR,24,3
+#define   XPT_DMD7_SEL                                           XPT_DMD0_BASEADDR,28,3
+
+// V2 AGC Gain Freeze & step
+#define   DBG_ENABLE_DISABLE_AGC                                 (0x3FFFCF60) // 1: DISABLE, 0:ENABLE
+#define   WB_DFE0_DFE_FB_RF1_BASEADDR                            0x903004A4
+#define   WB_DFE0_DFE_FB_RF1_BO                                  WB_DFE0_DFE_FB_RF1_BASEADDR,0,3
+#define   WB_DFE0_DFE_FB_RF2_BO                                  WB_DFE0_DFE_FB_RF1_BASEADDR,4,4
+#define   WB_DFE0_DFE_FB_LNA_BO                                  WB_DFE0_DFE_FB_RF1_BASEADDR,8,2
+
+#define   WB_DFE1_DFE_FB_RF1_BASEADDR                            0x904004A4
+#define   WB_DFE1_DFE_FB_RF1_BO                                  WB_DFE1_DFE_FB_RF1_BASEADDR,0,3
+#define   WB_DFE1_DFE_FB_RF2_BO                                  WB_DFE1_DFE_FB_RF1_BASEADDR,4,4
+#define   WB_DFE1_DFE_FB_LNA_BO                                  WB_DFE1_DFE_FB_RF1_BASEADDR,8,2
+
+#define   WB_DFE2_DFE_FB_RF1_BASEADDR                            0x905004A4
+#define   WB_DFE2_DFE_FB_RF1_BO                                  WB_DFE2_DFE_FB_RF1_BASEADDR,0,3
+#define   WB_DFE2_DFE_FB_RF2_BO                                  WB_DFE2_DFE_FB_RF1_BASEADDR,4,4
+#define   WB_DFE2_DFE_FB_LNA_BO                                  WB_DFE2_DFE_FB_RF1_BASEADDR,8,2
+
+#define   WB_DFE3_DFE_FB_RF1_BASEADDR                            0x906004A4
+#define   WB_DFE3_DFE_FB_RF1_BO                                  WB_DFE3_DFE_FB_RF1_BASEADDR,0,3
+#define   WB_DFE3_DFE_FB_RF2_BO                                  WB_DFE3_DFE_FB_RF1_BASEADDR,4,4
+#define   WB_DFE3_DFE_FB_LNA_BO                                  WB_DFE3_DFE_FB_RF1_BASEADDR,8,2
+
+#define   AFE_REG_D2A_TA_RFFE_LNA_BO_1P8_BASEADDR                0x90200104
+#define   AFE_REG_D2A_TA_RFFE_LNA_BO_1P8_2                       AFE_REG_D2A_TA_RFFE_LNA_BO_1P8_BASEADDR,0,1
+#define   AFE_REG_D2A_TA_RFFE_RF1_BO_1P8_3                       AFE_REG_D2A_TA_RFFE_LNA_BO_1P8_BASEADDR,1,1
+#define   AFE_REG_D2A_TB_RFFE_LNA_BO_1P8_2                       AFE_REG_D2A_TA_RFFE_LNA_BO_1P8_BASEADDR,2,1
+#define   AFE_REG_D2A_TB_RFFE_RF1_BO_1P8_3                       AFE_REG_D2A_TA_RFFE_LNA_BO_1P8_BASEADDR,3,1
+#define   AFE_REG_D2A_TC_RFFE_LNA_BO_1P8_2                       AFE_REG_D2A_TA_RFFE_LNA_BO_1P8_BASEADDR,4,1
+#define   AFE_REG_D2A_TC_RFFE_RF1_BO_1P8_3                       AFE_REG_D2A_TA_RFFE_LNA_BO_1P8_BASEADDR,5,1
+#define   AFE_REG_D2A_TD_RFFE_LNA_BO_1P8_2                       AFE_REG_D2A_TA_RFFE_LNA_BO_1P8_BASEADDR,6,1
+#define   AFE_REG_D2A_TD_RFFE_RF1_BO_1P8_3                       AFE_REG_D2A_TA_RFFE_LNA_BO_1P8_BASEADDR,7,1
+
+#define   AFE_REG_AFE_REG_SPARE_BASEADDR                         0x902000A0
+#define   AFE_REG_D2A_TA_RFFE_RF1_CAP_1P8                        AFE_REG_AFE_REG_SPARE_BASEADDR,13,5
+
+#define   AFE_REG_AFE_REG_SPARE_BASEADDR1                        0x902000B4
+#define   AFE_REG_D2A_TB_RFFE_RF1_CAP_1P8                        AFE_REG_AFE_REG_SPARE_BASEADDR1,13,5
+
+#define   AFE_REG_AFE_REG_SPARE_BASEADDR2                        0x902000C4
+#define   AFE_REG_D2A_TC_RFFE_RF1_CAP_1P8                        AFE_REG_AFE_REG_SPARE_BASEADDR2,13,5
+
+#define   AFE_REG_AFE_REG_SPARE_BASEADDR3                        0x902000D4
+#define   AFE_REG_D2A_TD_RFFE_RF1_CAP_1P8                        AFE_REG_AFE_REG_SPARE_BASEADDR3,13,5
+
+#define   WB_DFE0_DFE_FB_AGC_BASEADDR                            0x90300498
+#define   WB_DFE0_DFE_FB_AGC_APPLY                               WB_DFE0_DFE_FB_AGC_BASEADDR,0,1
+
+#define   WB_DFE1_DFE_FB_AGC_BASEADDR                            0x90400498
+#define   WB_DFE1_DFE_FB_AGC_APPLY                               WB_DFE1_DFE_FB_AGC_BASEADDR,0,1
+
+#define   WB_DFE2_DFE_FB_AGC_BASEADDR                            0x90500498
+#define   WB_DFE2_DFE_FB_AGC_APPLY                               WB_DFE2_DFE_FB_AGC_BASEADDR,0,1
+
+#define   WB_DFE3_DFE_FB_AGC_BASEADDR                            0x90600498
+#define   WB_DFE3_DFE_FB_AGC_APPLY                               WB_DFE3_DFE_FB_AGC_BASEADDR,0,1
+
+#define   WDT_WD_INT_BASEADDR                                    0x8002000C
+#define   WDT_WD_INT_STATUS                                      WDT_WD_INT_BASEADDR,0,1
+
+#define   FSK_TX_FTM_BASEADDR                                    0x80090000
+#define   FSK_TX_FTM_OE                                          FSK_TX_FTM_BASEADDR,12,1
+#define   FSK_TX_FTM_TX_EN                                       FSK_TX_FTM_BASEADDR,10,1
+#define   FSK_TX_FTM_FORCE_CARRIER_ON                            FSK_TX_FTM_BASEADDR,1,1
+#define   FSK_TX_FTM_FORCE_MARK_SPACE                            FSK_TX_FTM_BASEADDR,0,1
+
+#define   FSK_TX_FTM_TX_CNT_BASEADDR                             0x80090018
+#define   FSK_TX_FTM_TX_CNT_INT                                  FSK_TX_FTM_TX_CNT_BASEADDR,8,4
+#define   FSK_TX_FTM_TX_INT_EN                                   FSK_TX_FTM_TX_CNT_BASEADDR,4,1
+#define   FSK_TX_FTM_TX_INT_SRC_SEL                              FSK_TX_FTM_TX_CNT_BASEADDR,0,2
+
+#define   AFE_REG_D2A_FSK_BIAS_BASEADDR                          0x90200040
+#define   AFE_REG_D2A_FSK_BIAS_EN                                AFE_REG_D2A_FSK_BIAS_BASEADDR,0,1
+#define   AFE_REG_D2A_FSK_TEST_EN                                AFE_REG_D2A_FSK_BIAS_BASEADDR,10,1
+#define   AFE_REG_D2A_FSK_TEST_MODE                              AFE_REG_D2A_FSK_BIAS_BASEADDR,11,4
+#define   AFE_REG_D2A_FSK_TERM_INT_EN                            AFE_REG_D2A_FSK_BIAS_BASEADDR,15,1
+#define   AFE_REG_D2A_FSK_RESETB_1P8                             AFE_REG_D2A_FSK_BIAS_BASEADDR,16,1
+#define   AFE_REG_D2A_FSK_REG_EN_1P8                             AFE_REG_D2A_FSK_BIAS_BASEADDR,17,1
+#define   AFE_REG_D2A_FSK_REG_EN_LKG_1P8                         AFE_REG_D2A_FSK_BIAS_BASEADDR,18,1
+#define   AFE_REG_D2A_FSK_REG_AMP_1P8                            AFE_REG_D2A_FSK_BIAS_BASEADDR,19,3
+#define   AFE_REG_D2A_FSK_REG_TEST_CTRL_1P8                      AFE_REG_D2A_FSK_BIAS_BASEADDR,22,2
+#define   AFE_REG_D2A_DSQ_RX_MODE                                AFE_REG_D2A_FSK_BIAS_BASEADDR,24,1
+#define   AFE_REG_D2A_DSQ_RX_EN                                  AFE_REG_D2A_FSK_BIAS_BASEADDR,25,1
+#define   AFE_REG_D2A_DSQ_HYST                                   AFE_REG_D2A_FSK_BIAS_BASEADDR,26,2
+#define   AFE_REG_D2A_DSQ_RESETB_1P8                             AFE_REG_D2A_FSK_BIAS_BASEADDR,28,1
+#define   AFE_REG_D2A_FSK_CLKRX_ENA                              AFE_REG_D2A_FSK_BIAS_BASEADDR,29,1
+
+#define   DMD_TEI_BASEADDR                                       0x3FFFEBE0
+#define   DMD_TEI_ENA                                            DMD_TEI_BASEADDR,0,1
+
+#define   xpt_shm_input_control0  0x90700270,0,8
+#define   xpt_shm_input_control1  0x90700270,8,8
+#define   xpt_shm_input_control2  0x90700270,16,8
+#define   xpt_shm_input_control3  0x90700270,24,8
+#define   xpt_shm_input_control4  0x90700274,0,8
+#define   xpt_shm_input_control5  0x90700274,8,8
+#define   xpt_shm_input_control6  0x90700274,16,8
+#define   xpt_shm_input_control7  0x90700274,24,8
+
+
+#define   xpt_shm_output_control0  0x90700278,0,8
+#define   xpt_shm_output_control1  0x90700278,8,8
+#define   xpt_shm_output_control2  0x90700278,16,8
+#define   xpt_shm_output_control3  0x90700278,24,8
+#define   xpt_shm_output_control4  0x9070027C,0,8
+#define   xpt_shm_output_control5  0x9070027C,8,8
+#define   xpt_shm_output_control6  0x9070027C,16,8
+#define   xpt_shm_output_control7  0x9070027C,24,8
+
+#define   xpt_mode_27mhz           0x90700184,0,1
+#define   xpt_enable_pcr_count     0x90700184,1,1
+
+#define   xcpu_ctrl_003c_reg       0x9072003C,0,4
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif //__MXL58X_REGISTERS_H__
diff --git a/drivers/media/dvb-frontends/stv0367dd.c b/drivers/media/dvb-frontends/stv0367dd.c
new file mode 100644
index 0000000..fcb7704
--- /dev/null
+++ b/drivers/media/dvb-frontends/stv0367dd.c
@@ -0,0 +1,1874 @@
+/*
+ * stv0367dd: STV0367 DVB-C/T demodulator driver
+ *
+ * Copyright (C) 2011 Digital Devices GmbH
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 only, as published by the Free Software Foundation.
+ *
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA
+ * Or, point your browser to http://www.gnu.org/copyleft/gpl.html
+ */
+
+#undef pr_fmt
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/firmware.h>
+#include <linux/i2c.h>
+#include <asm/div64.h>
+
+#include "dvb_frontend.h"
+#include "dvb_math.h"
+#include "stv0367dd.h"
+#include "stv0367dd_regs.h"
+
+#define INTLOG10X100(x) ((u32) (((u64) intlog10(x) * 100) >> 24))
+
+enum {  QAM_MOD_QAM4 = 0,
+	QAM_MOD_QAM16,
+	QAM_MOD_QAM32,
+	QAM_MOD_QAM64,
+	QAM_MOD_QAM128,
+	QAM_MOD_QAM256,
+	QAM_MOD_QAM512,
+	QAM_MOD_QAM1024
+};
+
+enum {QAM_SPECT_NORMAL, QAM_SPECT_INVERTED };
+
+enum {
+	QAM_FEC_A = 1,					/* J83 Annex A */
+	QAM_FEC_B = (1<<1),				/* J83 Annex B */
+	QAM_FEC_C = (1<<2)				/* J83 Annex C */
+};
+
+enum EDemodState { Off, QAMSet, OFDMSet, QAMStarted, OFDMStarted };
+
+struct stv_state {
+	struct dvb_frontend frontend;
+	enum fe_modulation modulation;
+	u32 symbol_rate;
+	u32 bandwidth;
+	struct device *dev;
+
+	struct i2c_adapter *i2c;
+	u8     adr;
+	u8     cont_clock;
+	void  *priv;
+
+	struct mutex mutex;
+	struct mutex ctlock;
+
+	u32 master_clock;
+	u32 adc_clock;
+	u8 ID;
+	u8 I2CRPT;
+	enum fe_delivery_system delsys;
+	u8  qam_inversion;
+
+	s32 IF;
+
+	s32    m_FECTimeOut;
+	s32    m_DemodTimeOut;
+	s32    m_SignalTimeOut;
+	s32    m_DemodLockTime;
+	s32    m_FFTTimeOut;
+	s32    m_TSTimeOut;
+
+	bool    m_bFirstTimeLock;
+
+	u8    m_Save_QAM_AGC_CTL;
+
+	enum EDemodState demod_state;
+
+	u8    m_OFDM_FFTMode;      /* 0 = 2k, 1 = 8k, 2 = 4k */
+	u8    m_OFDM_Modulation;
+	u8    m_OFDM_FEC;
+	u8    m_OFDM_Guard;
+
+	u32   ucblocks;
+	u32   ber;
+};
+
+struct init_table {
+	u16  adr;
+	u8   data;
+};
+
+struct init_table base_init[] = {
+	{ R367_IOCFG0,     0x80 },
+	{ R367_DAC0R,      0x00 },
+	{ R367_IOCFG1,     0x00 },
+	{ R367_DAC1R,      0x00 },
+	{ R367_IOCFG2,     0x00 },
+	{ R367_SDFR,       0x00 },
+	{ R367_AUX_CLK,    0x00 },
+	{ R367_FREESYS1,   0x00 },
+	{ R367_FREESYS2,   0x00 },
+	{ R367_FREESYS3,   0x00 },
+	{ R367_GPIO_CFG,   0x55 },
+	{ R367_GPIO_CMD,   0x01 },
+	{ R367_TSTRES,     0x00 },
+	{ R367_ANACTRL,    0x00 },
+	{ R367_TSTBUS,     0x00 },
+	{ R367_RF_AGC2,    0x20 },
+	{ R367_ANADIGCTRL, 0x0b },
+	{ R367_PLLMDIV,    0x01 },
+	{ R367_PLLNDIV,    0x08 },
+	{ R367_PLLSETUP,   0x18 },
+	{ R367_DUAL_AD12,  0x04 },
+	{ R367_TSTBIST,    0x00 },
+	{ 0x0000,          0x00 }
+};
+
+struct init_table qam_init[] = {
+	{ R367_QAM_CTRL_1,                  0x06 }, /* Orginal 0x04 */
+	{ R367_QAM_CTRL_2,                  0x03 },
+	{ R367_QAM_IT_STATUS1,              0x2b },
+	{ R367_QAM_IT_STATUS2,              0x08 },
+	{ R367_QAM_IT_EN1,                  0x00 },
+	{ R367_QAM_IT_EN2,                  0x00 },
+	{ R367_QAM_CTRL_STATUS,             0x04 },
+	{ R367_QAM_TEST_CTL,                0x00 },
+	{ R367_QAM_AGC_CTL,                 0x73 },
+	{ R367_QAM_AGC_IF_CFG,              0x50 },
+	{ R367_QAM_AGC_RF_CFG,              0x02 }, /* RF Freeze */
+	{ R367_QAM_AGC_PWM_CFG,             0x03 },
+	{ R367_QAM_AGC_PWR_REF_L,           0x5a },
+	{ R367_QAM_AGC_PWR_REF_H,           0x00 },
+	{ R367_QAM_AGC_RF_TH_L,             0xff },
+	{ R367_QAM_AGC_RF_TH_H,             0x07 },
+	{ R367_QAM_AGC_IF_LTH_L,            0x00 },
+	{ R367_QAM_AGC_IF_LTH_H,            0x08 },
+	{ R367_QAM_AGC_IF_HTH_L,            0xff },
+	{ R367_QAM_AGC_IF_HTH_H,            0x07 },
+	{ R367_QAM_AGC_PWR_RD_L,            0xa0 },
+	{ R367_QAM_AGC_PWR_RD_M,            0xe9 },
+	{ R367_QAM_AGC_PWR_RD_H,            0x03 },
+	{ R367_QAM_AGC_PWM_IFCMD_L,         0xe4 },
+	{ R367_QAM_AGC_PWM_IFCMD_H,         0x00 },
+	{ R367_QAM_AGC_PWM_RFCMD_L,         0xff },
+	{ R367_QAM_AGC_PWM_RFCMD_H,         0x07 },
+	{ R367_QAM_IQDEM_CFG,               0x01 },
+	{ R367_QAM_MIX_NCO_LL,              0x22 },
+	{ R367_QAM_MIX_NCO_HL,              0x96 },
+	{ R367_QAM_MIX_NCO_HH,              0x55 },
+	{ R367_QAM_SRC_NCO_LL,              0xff },
+	{ R367_QAM_SRC_NCO_LH,              0x0c },
+	{ R367_QAM_SRC_NCO_HL,              0xf5 },
+	{ R367_QAM_SRC_NCO_HH,              0x20 },
+	{ R367_QAM_IQDEM_GAIN_SRC_L,        0x06 },
+	{ R367_QAM_IQDEM_GAIN_SRC_H,        0x01 },
+	{ R367_QAM_IQDEM_DCRM_CFG_LL,       0xfe },
+	{ R367_QAM_IQDEM_DCRM_CFG_LH,       0xff },
+	{ R367_QAM_IQDEM_DCRM_CFG_HL,       0x0f },
+	{ R367_QAM_IQDEM_DCRM_CFG_HH,       0x00 },
+	{ R367_QAM_IQDEM_ADJ_COEFF0,        0x34 },
+	{ R367_QAM_IQDEM_ADJ_COEFF1,        0xae },
+	{ R367_QAM_IQDEM_ADJ_COEFF2,        0x46 },
+	{ R367_QAM_IQDEM_ADJ_COEFF3,        0x77 },
+	{ R367_QAM_IQDEM_ADJ_COEFF4,        0x96 },
+	{ R367_QAM_IQDEM_ADJ_COEFF5,        0x69 },
+	{ R367_QAM_IQDEM_ADJ_COEFF6,        0xc7 },
+	{ R367_QAM_IQDEM_ADJ_COEFF7,        0x01 },
+	{ R367_QAM_IQDEM_ADJ_EN,            0x04 },
+	{ R367_QAM_IQDEM_ADJ_AGC_REF,       0x94 },
+	{ R367_QAM_ALLPASSFILT1,            0xc9 },
+	{ R367_QAM_ALLPASSFILT2,            0x2d },
+	{ R367_QAM_ALLPASSFILT3,            0xa3 },
+	{ R367_QAM_ALLPASSFILT4,            0xfb },
+	{ R367_QAM_ALLPASSFILT5,            0xf6 },
+	{ R367_QAM_ALLPASSFILT6,            0x45 },
+	{ R367_QAM_ALLPASSFILT7,            0x6f },
+	{ R367_QAM_ALLPASSFILT8,            0x7e },
+	{ R367_QAM_ALLPASSFILT9,            0x05 },
+	{ R367_QAM_ALLPASSFILT10,           0x0a },
+	{ R367_QAM_ALLPASSFILT11,           0x51 },
+	{ R367_QAM_TRL_AGC_CFG,             0x20 },
+	{ R367_QAM_TRL_LPF_CFG,             0x28 },
+	{ R367_QAM_TRL_LPF_ACQ_GAIN,        0x44 },
+	{ R367_QAM_TRL_LPF_TRK_GAIN,        0x22 },
+	{ R367_QAM_TRL_LPF_OUT_GAIN,        0x03 },
+	{ R367_QAM_TRL_LOCKDET_LTH,         0x04 },
+	{ R367_QAM_TRL_LOCKDET_HTH,         0x11 },
+	{ R367_QAM_TRL_LOCKDET_TRGVAL,      0x20 },
+	{ R367_QAM_IQ_QAM,                  0x01 },
+	{ R367_QAM_FSM_STATE,               0xa0 },
+	{ R367_QAM_FSM_CTL,                 0x08 },
+	{ R367_QAM_FSM_STS,                 0x0c },
+	{ R367_QAM_FSM_SNR0_HTH,            0x00 },
+	{ R367_QAM_FSM_SNR1_HTH,            0x00 },
+	{ R367_QAM_FSM_SNR2_HTH,            0x00 },
+	{ R367_QAM_FSM_SNR0_LTH,            0x00 },
+	{ R367_QAM_FSM_SNR1_LTH,            0x00 },
+	{ R367_QAM_FSM_EQA1_HTH,            0x00 },
+	{ R367_QAM_FSM_TEMPO,               0x32 },
+	{ R367_QAM_FSM_CONFIG,              0x03 },
+	{ R367_QAM_EQU_I_TESTTAP_L,         0x11 },
+	{ R367_QAM_EQU_I_TESTTAP_M,         0x00 },
+	{ R367_QAM_EQU_I_TESTTAP_H,         0x00 },
+	{ R367_QAM_EQU_TESTAP_CFG,          0x00 },
+	{ R367_QAM_EQU_Q_TESTTAP_L,         0xff },
+	{ R367_QAM_EQU_Q_TESTTAP_M,         0x00 },
+	{ R367_QAM_EQU_Q_TESTTAP_H,         0x00 },
+	{ R367_QAM_EQU_TAP_CTRL,            0x00 },
+	{ R367_QAM_EQU_CTR_CRL_CONTROL_L,   0x11 },
+	{ R367_QAM_EQU_CTR_CRL_CONTROL_H,   0x05 },
+	{ R367_QAM_EQU_CTR_HIPOW_L,         0x00 },
+	{ R367_QAM_EQU_CTR_HIPOW_H,         0x00 },
+	{ R367_QAM_EQU_I_EQU_LO,            0xef },
+	{ R367_QAM_EQU_I_EQU_HI,            0x00 },
+	{ R367_QAM_EQU_Q_EQU_LO,            0xee },
+	{ R367_QAM_EQU_Q_EQU_HI,            0x00 },
+	{ R367_QAM_EQU_MAPPER,              0xc5 },
+	{ R367_QAM_EQU_SWEEP_RATE,          0x80 },
+	{ R367_QAM_EQU_SNR_LO,              0x64 },
+	{ R367_QAM_EQU_SNR_HI,              0x03 },
+	{ R367_QAM_EQU_GAMMA_LO,            0x00 },
+	{ R367_QAM_EQU_GAMMA_HI,            0x00 },
+	{ R367_QAM_EQU_ERR_GAIN,            0x36 },
+	{ R367_QAM_EQU_RADIUS,              0xaa },
+	{ R367_QAM_EQU_FFE_MAINTAP,         0x00 },
+	{ R367_QAM_EQU_FFE_LEAKAGE,         0x63 },
+	{ R367_QAM_EQU_FFE_MAINTAP_POS,     0xdf },
+	{ R367_QAM_EQU_GAIN_WIDE,           0x88 },
+	{ R367_QAM_EQU_GAIN_NARROW,         0x41 },
+	{ R367_QAM_EQU_CTR_LPF_GAIN,        0xd1 },
+	{ R367_QAM_EQU_CRL_LPF_GAIN,        0xa7 },
+	{ R367_QAM_EQU_GLOBAL_GAIN,         0x06 },
+	{ R367_QAM_EQU_CRL_LD_SEN,          0x85 },
+	{ R367_QAM_EQU_CRL_LD_VAL,          0xe2 },
+	{ R367_QAM_EQU_CRL_TFR,             0x20 },
+	{ R367_QAM_EQU_CRL_BISTH_LO,        0x00 },
+	{ R367_QAM_EQU_CRL_BISTH_HI,        0x00 },
+	{ R367_QAM_EQU_SWEEP_RANGE_LO,      0x00 },
+	{ R367_QAM_EQU_SWEEP_RANGE_HI,      0x00 },
+	{ R367_QAM_EQU_CRL_LIMITER,         0x40 },
+	{ R367_QAM_EQU_MODULUS_MAP,         0x90 },
+	{ R367_QAM_EQU_PNT_GAIN,            0xa7 },
+	{ R367_QAM_FEC_AC_CTR_0,            0x16 },
+	{ R367_QAM_FEC_AC_CTR_1,            0x0b },
+	{ R367_QAM_FEC_AC_CTR_2,            0x88 },
+	{ R367_QAM_FEC_AC_CTR_3,            0x02 },
+	{ R367_QAM_FEC_STATUS,              0x12 },
+	{ R367_QAM_RS_COUNTER_0,            0x7d },
+	{ R367_QAM_RS_COUNTER_1,            0xd0 },
+	{ R367_QAM_RS_COUNTER_2,            0x19 },
+	{ R367_QAM_RS_COUNTER_3,            0x0b },
+	{ R367_QAM_RS_COUNTER_4,            0xa3 },
+	{ R367_QAM_RS_COUNTER_5,            0x00 },
+	{ R367_QAM_BERT_0,                  0x01 },
+	{ R367_QAM_BERT_1,                  0x25 },
+	{ R367_QAM_BERT_2,                  0x41 },
+	{ R367_QAM_BERT_3,                  0x39 },
+	{ R367_QAM_OUTFORMAT_0,             0xc2 },
+	{ R367_QAM_OUTFORMAT_1,             0x22 },
+	{ R367_QAM_SMOOTHER_2,              0x28 },
+	{ R367_QAM_TSMF_CTRL_0,             0x01 },
+	{ R367_QAM_TSMF_CTRL_1,             0xc6 },
+	{ R367_QAM_TSMF_CTRL_3,             0x43 },
+	{ R367_QAM_TS_ON_ID_0,              0x00 },
+	{ R367_QAM_TS_ON_ID_1,              0x00 },
+	{ R367_QAM_TS_ON_ID_2,              0x00 },
+	{ R367_QAM_TS_ON_ID_3,              0x00 },
+	{ R367_QAM_RE_STATUS_0,             0x00 },
+	{ R367_QAM_RE_STATUS_1,             0x00 },
+	{ R367_QAM_RE_STATUS_2,             0x00 },
+	{ R367_QAM_RE_STATUS_3,             0x00 },
+	{ R367_QAM_TS_STATUS_0,             0x00 },
+	{ R367_QAM_TS_STATUS_1,             0x00 },
+	{ R367_QAM_TS_STATUS_2,             0xa0 },
+	{ R367_QAM_TS_STATUS_3,             0x00 },
+	{ R367_QAM_T_O_ID_0,                0x00 },
+	{ R367_QAM_T_O_ID_1,                0x00 },
+	{ R367_QAM_T_O_ID_2,                0x00 },
+	{ R367_QAM_T_O_ID_3,                0x00 },
+	{ 0x0000, 0x00 } /* EOT */
+};
+
+struct init_table ofdm_init[] = {
+	{ R367_OFDM_AGC2MAX,                0xff },
+	{ R367_OFDM_AGC2MIN,                0x00 },
+	{ R367_OFDM_AGC1MAX,                0xff },
+	{ R367_OFDM_AGC1MIN,                0x00 },
+	{ R367_OFDM_AGCR,                   0xbc },
+	{ R367_OFDM_AGC2TH,                 0x00 },
+	{ R367_OFDM_AGCCTRL1,               0x85 },
+	{ R367_OFDM_AGCCTRL2,               0x1f },
+	{ R367_OFDM_AGC1VAL1,               0x00 },
+	{ R367_OFDM_AGC1VAL2,               0x00 },
+	{ R367_OFDM_AGC2VAL1,               0x6f },
+	{ R367_OFDM_AGC2VAL2,               0x05 },
+	{ R367_OFDM_AGC2PGA,                0x00 },
+	{ R367_OFDM_OVF_RATE1,              0x00 },
+	{ R367_OFDM_OVF_RATE2,              0x00 },
+	{ R367_OFDM_GAIN_SRC1,              0x2b },
+	{ R367_OFDM_GAIN_SRC2,              0x04 },
+	{ R367_OFDM_INC_DEROT1,             0x55 },
+	{ R367_OFDM_INC_DEROT2,             0x55 },
+	{ R367_OFDM_PPM_CPAMP_DIR,          0x2c },
+	{ R367_OFDM_PPM_CPAMP_INV,          0x00 },
+	{ R367_OFDM_FREESTFE_1,             0x00 },
+	{ R367_OFDM_FREESTFE_2,             0x1c },
+	{ R367_OFDM_DCOFFSET,               0x00 },
+	{ R367_OFDM_EN_PROCESS,             0x05 },
+	{ R367_OFDM_SDI_SMOOTHER,           0x80 },
+	{ R367_OFDM_FE_LOOP_OPEN,           0x1c },
+	{ R367_OFDM_FREQOFF1,               0x00 },
+	{ R367_OFDM_FREQOFF2,               0x00 },
+	{ R367_OFDM_FREQOFF3,               0x00 },
+	{ R367_OFDM_TIMOFF1,                0x00 },
+	{ R367_OFDM_TIMOFF2,                0x00 },
+	{ R367_OFDM_EPQ,                    0x02 },
+	{ R367_OFDM_EPQAUTO,                0x01 },
+	{ R367_OFDM_SYR_UPDATE,             0xf5 },
+	{ R367_OFDM_CHPFREE,                0x00 },
+	{ R367_OFDM_PPM_STATE_MAC,          0x23 },
+	{ R367_OFDM_INR_THRESHOLD,          0xff },
+	{ R367_OFDM_EPQ_TPS_ID_CELL,        0xf9 },
+	{ R367_OFDM_EPQ_CFG,                0x00 },
+	{ R367_OFDM_EPQ_STATUS,             0x01 },
+	{ R367_OFDM_AUTORELOCK,             0x81 },
+	{ R367_OFDM_BER_THR_VMSB,           0x00 },
+	{ R367_OFDM_BER_THR_MSB,            0x00 },
+	{ R367_OFDM_BER_THR_LSB,            0x00 },
+	{ R367_OFDM_CCD,                    0x83 },
+	{ R367_OFDM_SPECTR_CFG,             0x00 },
+	{ R367_OFDM_CHC_DUMMY,              0x18 },
+	{ R367_OFDM_INC_CTL,                0x88 },
+	{ R367_OFDM_INCTHRES_COR1,          0xb4 },
+	{ R367_OFDM_INCTHRES_COR2,          0x96 },
+	{ R367_OFDM_INCTHRES_DET1,          0x0e },
+	{ R367_OFDM_INCTHRES_DET2,          0x11 },
+	{ R367_OFDM_IIR_CELLNB,             0x8d },
+	{ R367_OFDM_IIRCX_COEFF1_MSB,       0x00 },
+	{ R367_OFDM_IIRCX_COEFF1_LSB,       0x00 },
+	{ R367_OFDM_IIRCX_COEFF2_MSB,       0x09 },
+	{ R367_OFDM_IIRCX_COEFF2_LSB,       0x18 },
+	{ R367_OFDM_IIRCX_COEFF3_MSB,       0x14 },
+	{ R367_OFDM_IIRCX_COEFF3_LSB,       0x9c },
+	{ R367_OFDM_IIRCX_COEFF4_MSB,       0x00 },
+	{ R367_OFDM_IIRCX_COEFF4_LSB,       0x00 },
+	{ R367_OFDM_IIRCX_COEFF5_MSB,       0x36 },
+	{ R367_OFDM_IIRCX_COEFF5_LSB,       0x42 },
+	{ R367_OFDM_FEPATH_CFG,             0x00 },
+	{ R367_OFDM_PMC1_FUNC,              0x65 },
+	{ R367_OFDM_PMC1_FOR,               0x00 },
+	{ R367_OFDM_PMC2_FUNC,              0x00 },
+	{ R367_OFDM_STATUS_ERR_DA,          0xe0 },
+	{ R367_OFDM_DIG_AGC_R,              0xfe },
+	{ R367_OFDM_COMAGC_TARMSB,          0x0b },
+	{ R367_OFDM_COM_AGC_TAR_ENMODE,     0x41 },
+	{ R367_OFDM_COM_AGC_CFG,            0x3e },
+	{ R367_OFDM_COM_AGC_GAIN1,          0x39 },
+	{ R367_OFDM_AUT_AGC_TARGETMSB,      0x0b },
+	{ R367_OFDM_LOCK_DET_MSB,           0x01 },
+	{ R367_OFDM_AGCTAR_LOCK_LSBS,       0x40 },
+	{ R367_OFDM_AUT_GAIN_EN,            0xf4 },
+	{ R367_OFDM_AUT_CFG,                0xf0 },
+	{ R367_OFDM_LOCKN,                  0x23 },
+	{ R367_OFDM_INT_X_3,                0x00 },
+	{ R367_OFDM_INT_X_2,                0x03 },
+	{ R367_OFDM_INT_X_1,                0x8d },
+	{ R367_OFDM_INT_X_0,                0xa0 },
+	{ R367_OFDM_MIN_ERRX_MSB,           0x00 },
+	{ R367_OFDM_COR_CTL,                0x00 },
+	{ R367_OFDM_COR_STAT,               0xf6 },
+	{ R367_OFDM_COR_INTEN,              0x00 },
+	{ R367_OFDM_COR_INTSTAT,            0x3f },
+	{ R367_OFDM_COR_MODEGUARD,          0x03 },
+	{ R367_OFDM_AGC_CTL,                0x08 },
+	{ R367_OFDM_AGC_MANUAL1,            0x00 },
+	{ R367_OFDM_AGC_MANUAL2,            0x00 },
+	{ R367_OFDM_AGC_TARG,               0x16 },
+	{ R367_OFDM_AGC_GAIN1,              0x53 },
+	{ R367_OFDM_AGC_GAIN2,              0x1d },
+	{ R367_OFDM_RESERVED_1,             0x00 },
+	{ R367_OFDM_RESERVED_2,             0x00 },
+	{ R367_OFDM_RESERVED_3,             0x00 },
+	{ R367_OFDM_CAS_CTL,                0x44 },
+	{ R367_OFDM_CAS_FREQ,               0xb3 },
+	{ R367_OFDM_CAS_DAGCGAIN,           0x12 },
+	{ R367_OFDM_SYR_CTL,                0x04 },
+	{ R367_OFDM_SYR_STAT,               0x10 },
+	{ R367_OFDM_SYR_NCO1,               0x00 },
+	{ R367_OFDM_SYR_NCO2,               0x00 },
+	{ R367_OFDM_SYR_OFFSET1,            0x00 },
+	{ R367_OFDM_SYR_OFFSET2,            0x00 },
+	{ R367_OFDM_FFT_CTL,                0x00 },
+	{ R367_OFDM_SCR_CTL,                0x70 },
+	{ R367_OFDM_PPM_CTL1,               0xf8 },
+	{ R367_OFDM_TRL_CTL,                0xac },
+	{ R367_OFDM_TRL_NOMRATE1,           0x1e },
+	{ R367_OFDM_TRL_NOMRATE2,           0x58 },
+	{ R367_OFDM_TRL_TIME1,              0x1d },
+	{ R367_OFDM_TRL_TIME2,              0xfc },
+	{ R367_OFDM_CRL_CTL,                0x24 },
+	{ R367_OFDM_CRL_FREQ1,              0xad },
+	{ R367_OFDM_CRL_FREQ2,              0x9d },
+	{ R367_OFDM_CRL_FREQ3,              0xff },
+	{ R367_OFDM_CHC_CTL,                0x01 },
+	{ R367_OFDM_CHC_SNR,                0xf0 },
+	{ R367_OFDM_BDI_CTL,                0x00 },
+	{ R367_OFDM_DMP_CTL,                0x00 },
+	{ R367_OFDM_TPS_RCVD1,              0x30 },
+	{ R367_OFDM_TPS_RCVD2,              0x02 },
+	{ R367_OFDM_TPS_RCVD3,              0x01 },
+	{ R367_OFDM_TPS_RCVD4,              0x00 },
+	{ R367_OFDM_TPS_ID_CELL1,           0x00 },
+	{ R367_OFDM_TPS_ID_CELL2,           0x00 },
+	{ R367_OFDM_TPS_RCVD5_SET1,         0x02 },
+	{ R367_OFDM_TPS_SET2,               0x02 },
+	{ R367_OFDM_TPS_SET3,               0x01 },
+	{ R367_OFDM_TPS_CTL,                0x00 },
+	{ R367_OFDM_CTL_FFTOSNUM,           0x34 },
+	{ R367_OFDM_TESTSELECT,             0x09 },
+	{ R367_OFDM_MSC_REV,                0x0a },
+	{ R367_OFDM_PIR_CTL,                0x00 },
+	{ R367_OFDM_SNR_CARRIER1,           0xa1 },
+	{ R367_OFDM_SNR_CARRIER2,           0x9a },
+	{ R367_OFDM_PPM_CPAMP,              0x2c },
+	{ R367_OFDM_TSM_AP0,                0x00 },
+	{ R367_OFDM_TSM_AP1,                0x00 },
+	{ R367_OFDM_TSM_AP2,                0x00 },
+	{ R367_OFDM_TSM_AP3,                0x00 },
+	{ R367_OFDM_TSM_AP4,                0x00 },
+	{ R367_OFDM_TSM_AP5,                0x00 },
+	{ R367_OFDM_TSM_AP6,                0x00 },
+	{ R367_OFDM_TSM_AP7,                0x00 },
+	{ R367_OFDM_CONSTMODE,              0x01 },
+	{ R367_OFDM_CONSTCARR1,             0x00 },
+	{ R367_OFDM_CONSTCARR2,             0x00 },
+	{ R367_OFDM_ICONSTEL,               0x0a },
+	{ R367_OFDM_QCONSTEL,               0x15 },
+	{ R367_OFDM_TSTBISTRES0,            0x00 },
+	{ R367_OFDM_TSTBISTRES1,            0x00 },
+	{ R367_OFDM_TSTBISTRES2,            0x28 },
+	{ R367_OFDM_TSTBISTRES3,            0x00 },
+	{ R367_OFDM_SYR_TARGET_FFTADJT_MSB, 0x00 },
+	{ R367_OFDM_SYR_TARGET_FFTADJT_LSB, 0x00 },
+	{ R367_OFDM_SYR_TARGET_CHCADJT_MSB, 0x00 },
+	{ R367_OFDM_SYR_TARGET_CHCADJT_LSB, 0x00 },
+	{ R367_OFDM_SYR_FLAG,               0x00 },
+	{ R367_OFDM_CRL_TARGET1,            0x00 },
+	{ R367_OFDM_CRL_TARGET2,            0x00 },
+	{ R367_OFDM_CRL_TARGET3,            0x00 },
+	{ R367_OFDM_CRL_TARGET4,            0x00 },
+	{ R367_OFDM_CRL_FLAG,               0x00 },
+	{ R367_OFDM_TRL_TARGET1,            0x00 },
+	{ R367_OFDM_TRL_TARGET2,            0x00 },
+	{ R367_OFDM_TRL_CHC,                0x00 },
+	{ R367_OFDM_CHC_SNR_TARG,           0x00 },
+	{ R367_OFDM_TOP_TRACK,              0x00 },
+	{ R367_OFDM_TRACKER_FREE1,          0x00 },
+	{ R367_OFDM_ERROR_CRL1,             0x00 },
+	{ R367_OFDM_ERROR_CRL2,             0x00 },
+	{ R367_OFDM_ERROR_CRL3,             0x00 },
+	{ R367_OFDM_ERROR_CRL4,             0x00 },
+	{ R367_OFDM_DEC_NCO1,               0x2c },
+	{ R367_OFDM_DEC_NCO2,               0x0f },
+	{ R367_OFDM_DEC_NCO3,               0x20 },
+	{ R367_OFDM_SNR,                    0xf1 },
+	{ R367_OFDM_SYR_FFTADJ1,            0x00 },
+	{ R367_OFDM_SYR_FFTADJ2,            0x00 },
+	{ R367_OFDM_SYR_CHCADJ1,            0x00 },
+	{ R367_OFDM_SYR_CHCADJ2,            0x00 },
+	{ R367_OFDM_SYR_OFF,                0x00 },
+	{ R367_OFDM_PPM_OFFSET1,            0x00 },
+	{ R367_OFDM_PPM_OFFSET2,            0x03 },
+	{ R367_OFDM_TRACKER_FREE2,          0x00 },
+	{ R367_OFDM_DEBG_LT10,              0x00 },
+	{ R367_OFDM_DEBG_LT11,              0x00 },
+	{ R367_OFDM_DEBG_LT12,              0x00 },
+	{ R367_OFDM_DEBG_LT13,              0x00 },
+	{ R367_OFDM_DEBG_LT14,              0x00 },
+	{ R367_OFDM_DEBG_LT15,              0x00 },
+	{ R367_OFDM_DEBG_LT16,              0x00 },
+	{ R367_OFDM_DEBG_LT17,              0x00 },
+	{ R367_OFDM_DEBG_LT18,              0x00 },
+	{ R367_OFDM_DEBG_LT19,              0x00 },
+	{ R367_OFDM_DEBG_LT1A,              0x00 },
+	{ R367_OFDM_DEBG_LT1B,              0x00 },
+	{ R367_OFDM_DEBG_LT1C,              0x00 },
+	{ R367_OFDM_DEBG_LT1D,              0x00 },
+	{ R367_OFDM_DEBG_LT1E,              0x00 },
+	{ R367_OFDM_DEBG_LT1F,              0x00 },
+	{ R367_OFDM_RCCFGH,                 0x00 },
+	{ R367_OFDM_RCCFGM,                 0x00 },
+	{ R367_OFDM_RCCFGL,                 0x00 },
+	{ R367_OFDM_RCINSDELH,              0x00 },
+	{ R367_OFDM_RCINSDELM,              0x00 },
+	{ R367_OFDM_RCINSDELL,              0x00 },
+	{ R367_OFDM_RCSTATUS,               0x00 },
+	{ R367_OFDM_RCSPEED,                0x6f },
+	{ R367_OFDM_RCDEBUGM,               0xe7 },
+	{ R367_OFDM_RCDEBUGL,               0x9b },
+	{ R367_OFDM_RCOBSCFG,               0x00 },
+	{ R367_OFDM_RCOBSM,                 0x00 },
+	{ R367_OFDM_RCOBSL,                 0x00 },
+	{ R367_OFDM_RCFECSPY,               0x00 },
+	{ R367_OFDM_RCFSPYCFG,              0x00 },
+	{ R367_OFDM_RCFSPYDATA,             0x00 },
+	{ R367_OFDM_RCFSPYOUT,              0x00 },
+	{ R367_OFDM_RCFSTATUS,              0x00 },
+	{ R367_OFDM_RCFGOODPACK,            0x00 },
+	{ R367_OFDM_RCFPACKCNT,             0x00 },
+	{ R367_OFDM_RCFSPYMISC,             0x00 },
+	{ R367_OFDM_RCFBERCPT4,             0x00 },
+	{ R367_OFDM_RCFBERCPT3,             0x00 },
+	{ R367_OFDM_RCFBERCPT2,             0x00 },
+	{ R367_OFDM_RCFBERCPT1,             0x00 },
+	{ R367_OFDM_RCFBERCPT0,             0x00 },
+	{ R367_OFDM_RCFBERERR2,             0x00 },
+	{ R367_OFDM_RCFBERERR1,             0x00 },
+	{ R367_OFDM_RCFBERERR0,             0x00 },
+	{ R367_OFDM_RCFSTATESM,             0x00 },
+	{ R367_OFDM_RCFSTATESL,             0x00 },
+	{ R367_OFDM_RCFSPYBER,              0x00 },
+	{ R367_OFDM_RCFSPYDISTM,            0x00 },
+	{ R367_OFDM_RCFSPYDISTL,            0x00 },
+	{ R367_OFDM_RCFSPYOBS7,             0x00 },
+	{ R367_OFDM_RCFSPYOBS6,             0x00 },
+	{ R367_OFDM_RCFSPYOBS5,             0x00 },
+	{ R367_OFDM_RCFSPYOBS4,             0x00 },
+	{ R367_OFDM_RCFSPYOBS3,             0x00 },
+	{ R367_OFDM_RCFSPYOBS2,             0x00 },
+	{ R367_OFDM_RCFSPYOBS1,             0x00 },
+	{ R367_OFDM_RCFSPYOBS0,             0x00 },
+	{ R367_OFDM_FECM,                   0x01 },
+	{ R367_OFDM_VTH12,                  0xff },
+	{ R367_OFDM_VTH23,                  0xa1 },
+	{ R367_OFDM_VTH34,                  0x64 },
+	{ R367_OFDM_VTH56,                  0x40 },
+	{ R367_OFDM_VTH67,                  0x00 },
+	{ R367_OFDM_VTH78,                  0x2c },
+	{ R367_OFDM_VITCURPUN,              0x12 },
+	{ R367_OFDM_VERROR,                 0x01 },
+	{ R367_OFDM_PRVIT,                  0x3f },
+	{ R367_OFDM_VAVSRVIT,               0x00 },
+	{ R367_OFDM_VSTATUSVIT,             0xbd },
+	{ R367_OFDM_VTHINUSE,               0xa1 },
+	{ R367_OFDM_KDIV12,                 0x20 },
+	{ R367_OFDM_KDIV23,                 0x40 },
+	{ R367_OFDM_KDIV34,                 0x20 },
+	{ R367_OFDM_KDIV56,                 0x30 },
+	{ R367_OFDM_KDIV67,                 0x00 },
+	{ R367_OFDM_KDIV78,                 0x30 },
+	{ R367_OFDM_SIGPOWER,               0x54 },
+	{ R367_OFDM_DEMAPVIT,               0x40 },
+	{ R367_OFDM_VITSCALE,               0x00 },
+	{ R367_OFDM_FFEC1PRG,               0x00 },
+	{ R367_OFDM_FVITCURPUN,             0x12 },
+	{ R367_OFDM_FVERROR,                0x01 },
+	{ R367_OFDM_FVSTATUSVIT,            0xbd },
+	{ R367_OFDM_DEBUG_LT1,              0x00 },
+	{ R367_OFDM_DEBUG_LT2,              0x00 },
+	{ R367_OFDM_DEBUG_LT3,              0x00 },
+	{ R367_OFDM_TSTSFMET,               0x00 },
+	{ R367_OFDM_SELOUT,                 0x00 },
+	{ R367_OFDM_TSYNC,                  0x00 },
+	{ R367_OFDM_TSTERR,                 0x00 },
+	{ R367_OFDM_TSFSYNC,                0x00 },
+	{ R367_OFDM_TSTSFERR,               0x00 },
+	{ R367_OFDM_TSTTSSF1,               0x01 },
+	{ R367_OFDM_TSTTSSF2,               0x1f },
+	{ R367_OFDM_TSTTSSF3,               0x00 },
+	{ R367_OFDM_TSTTS1,                 0x00 },
+	{ R367_OFDM_TSTTS2,                 0x1f },
+	{ R367_OFDM_TSTTS3,                 0x01 },
+	{ R367_OFDM_TSTTS4,                 0x00 },
+	{ R367_OFDM_TSTTSRC,                0x00 },
+	{ R367_OFDM_TSTTSRS,                0x00 },
+	{ R367_OFDM_TSSTATEM,               0xb0 },
+	{ R367_OFDM_TSSTATEL,               0x40 },
+	{ R367_OFDM_TSCFGH,                 0x80 },
+	{ R367_OFDM_TSCFGM,                 0x00 },
+	{ R367_OFDM_TSCFGL,                 0x20 },
+	{ R367_OFDM_TSSYNC,                 0x00 },
+	{ R367_OFDM_TSINSDELH,              0x00 },
+	{ R367_OFDM_TSINSDELM,              0x00 },
+	{ R367_OFDM_TSINSDELL,              0x00 },
+	{ R367_OFDM_TSDIVN,                 0x03 },
+	{ R367_OFDM_TSDIVPM,                0x00 },
+	{ R367_OFDM_TSDIVPL,                0x00 },
+	{ R367_OFDM_TSDIVQM,                0x00 },
+	{ R367_OFDM_TSDIVQL,                0x00 },
+	{ R367_OFDM_TSDILSTKM,              0x00 },
+	{ R367_OFDM_TSDILSTKL,              0x00 },
+	{ R367_OFDM_TSSPEED,                0x6f },
+	{ R367_OFDM_TSSTATUS,               0x81 },
+	{ R367_OFDM_TSSTATUS2,              0x6a },
+	{ R367_OFDM_TSBITRATEM,             0x0f },
+	{ R367_OFDM_TSBITRATEL,             0xc6 },
+	{ R367_OFDM_TSPACKLENM,             0x00 },
+	{ R367_OFDM_TSPACKLENL,             0xfc },
+	{ R367_OFDM_TSBLOCLENM,             0x0a },
+	{ R367_OFDM_TSBLOCLENL,             0x80 },
+	{ R367_OFDM_TSDLYH,                 0x90 },
+	{ R367_OFDM_TSDLYM,                 0x68 },
+	{ R367_OFDM_TSDLYL,                 0x01 },
+	{ R367_OFDM_TSNPDAV,                0x00 },
+	{ R367_OFDM_TSBUFSTATH,             0x00 },
+	{ R367_OFDM_TSBUFSTATM,             0x00 },
+	{ R367_OFDM_TSBUFSTATL,             0x00 },
+	{ R367_OFDM_TSDEBUGM,               0xcf },
+	{ R367_OFDM_TSDEBUGL,               0x1e },
+	{ R367_OFDM_TSDLYSETH,              0x00 },
+	{ R367_OFDM_TSDLYSETM,              0x68 },
+	{ R367_OFDM_TSDLYSETL,              0x00 },
+	{ R367_OFDM_TSOBSCFG,               0x00 },
+	{ R367_OFDM_TSOBSM,                 0x47 },
+	{ R367_OFDM_TSOBSL,                 0x1f },
+	{ R367_OFDM_ERRCTRL1,               0x95 },
+	{ R367_OFDM_ERRCNT1H,               0x80 },
+	{ R367_OFDM_ERRCNT1M,               0x00 },
+	{ R367_OFDM_ERRCNT1L,               0x00 },
+	{ R367_OFDM_ERRCTRL2,               0x95 },
+	{ R367_OFDM_ERRCNT2H,               0x00 },
+	{ R367_OFDM_ERRCNT2M,               0x00 },
+	{ R367_OFDM_ERRCNT2L,               0x00 },
+	{ R367_OFDM_FECSPY,                 0x88 },
+	{ R367_OFDM_FSPYCFG,                0x2c },
+	{ R367_OFDM_FSPYDATA,               0x3a },
+	{ R367_OFDM_FSPYOUT,                0x06 },
+	{ R367_OFDM_FSTATUS,                0x61 },
+	{ R367_OFDM_FGOODPACK,              0xff },
+	{ R367_OFDM_FPACKCNT,               0xff },
+	{ R367_OFDM_FSPYMISC,               0x66 },
+	{ R367_OFDM_FBERCPT4,               0x00 },
+	{ R367_OFDM_FBERCPT3,               0x00 },
+	{ R367_OFDM_FBERCPT2,               0x36 },
+	{ R367_OFDM_FBERCPT1,               0x36 },
+	{ R367_OFDM_FBERCPT0,               0x14 },
+	{ R367_OFDM_FBERERR2,               0x00 },
+	{ R367_OFDM_FBERERR1,               0x03 },
+	{ R367_OFDM_FBERERR0,               0x28 },
+	{ R367_OFDM_FSTATESM,               0x00 },
+	{ R367_OFDM_FSTATESL,               0x02 },
+	{ R367_OFDM_FSPYBER,                0x00 },
+	{ R367_OFDM_FSPYDISTM,              0x01 },
+	{ R367_OFDM_FSPYDISTL,              0x9f },
+	{ R367_OFDM_FSPYOBS7,               0xc9 },
+	{ R367_OFDM_FSPYOBS6,               0x99 },
+	{ R367_OFDM_FSPYOBS5,               0x08 },
+	{ R367_OFDM_FSPYOBS4,               0xec },
+	{ R367_OFDM_FSPYOBS3,               0x01 },
+	{ R367_OFDM_FSPYOBS2,               0x0f },
+	{ R367_OFDM_FSPYOBS1,               0xf5 },
+	{ R367_OFDM_FSPYOBS0,               0x08 },
+	{ R367_OFDM_SFDEMAP,                0x40 },
+	{ R367_OFDM_SFERROR,                0x00 },
+	{ R367_OFDM_SFAVSR,                 0x30 },
+	{ R367_OFDM_SFECSTATUS,             0xcc },
+	{ R367_OFDM_SFKDIV12,               0x20 },
+	{ R367_OFDM_SFKDIV23,               0x40 },
+	{ R367_OFDM_SFKDIV34,               0x20 },
+	{ R367_OFDM_SFKDIV56,               0x20 },
+	{ R367_OFDM_SFKDIV67,               0x00 },
+	{ R367_OFDM_SFKDIV78,               0x20 },
+	{ R367_OFDM_SFDILSTKM,              0x00 },
+	{ R367_OFDM_SFDILSTKL,              0x00 },
+	{ R367_OFDM_SFSTATUS,               0xb5 },
+	{ R367_OFDM_SFDLYH,                 0x90 },
+	{ R367_OFDM_SFDLYM,                 0x60 },
+	{ R367_OFDM_SFDLYL,                 0x01 },
+	{ R367_OFDM_SFDLYSETH,              0xc0 },
+	{ R367_OFDM_SFDLYSETM,              0x60 },
+	{ R367_OFDM_SFDLYSETL,              0x00 },
+	{ R367_OFDM_SFOBSCFG,               0x00 },
+	{ R367_OFDM_SFOBSM,                 0x47 },
+	{ R367_OFDM_SFOBSL,                 0x05 },
+	{ R367_OFDM_SFECINFO,               0x40 },
+	{ R367_OFDM_SFERRCTRL,              0x74 },
+	{ R367_OFDM_SFERRCNTH,              0x80 },
+	{ R367_OFDM_SFERRCNTM,              0x00 },
+	{ R367_OFDM_SFERRCNTL,              0x00 },
+	{ R367_OFDM_SYMBRATEM,              0x2f },
+	{ R367_OFDM_SYMBRATEL,              0x50 },
+	{ R367_OFDM_SYMBSTATUS,             0x7f },
+	{ R367_OFDM_SYMBCFG,                0x00 },
+	{ R367_OFDM_SYMBFIFOM,              0xf4 },
+	{ R367_OFDM_SYMBFIFOL,              0x0d },
+	{ R367_OFDM_SYMBOFFSM,              0xf0 },
+	{ R367_OFDM_SYMBOFFSL,              0x2d },
+	{ 0x0000, 0x00 } /* EOT */
+};
+
+static inline u32 MulDiv32(u32 a, u32 b, u32 c)
+{
+	u64 tmp64;
+
+	tmp64 = (u64)a * (u64)b;
+	do_div(tmp64, c);
+
+	return (u32) tmp64;
+}
+
+static int i2c_write(struct i2c_adapter *adap, u8 adr, u8 *data, int len)
+{
+	struct i2c_msg msg = {
+		.addr = adr, .flags = 0, .buf = data, .len = len };
+
+	if (i2c_transfer(adap, &msg, 1) != 1) {
+		pr_warn("i2c_write error ([%02x] %04x: %02x)\n",
+			adr, (data[0] << 8) | data[1],
+			(len > 2 ? data[2] : 0));
+		return -EREMOTEIO;
+	}
+	return 0;
+}
+
+static int i2c_read(struct i2c_adapter *adap, u8 adr, u16 reg, u8 *val, int count)
+{
+	u8 msg[2] = {reg >> 8, reg & 0xff};
+	struct i2c_msg msgs[2] = {
+		{.addr = adr, .flags = 0, .buf = msg, .len = 2 },
+		{.addr = adr, .flags = I2C_M_RD, .buf = val, .len = count } };
+
+	if (i2c_transfer(adap, msgs, 2) != 2) {
+		pr_warn("i2c_read error ([%02x] %04x)\n",
+			adr, reg);
+		return -EREMOTEIO;
+	}
+
+	return 0;
+}
+
+static int writereg(struct stv_state *state, u16 reg, u8 dat)
+{
+	u8 mm[3] = { (reg >> 8), reg & 0xff, dat };
+
+	return i2c_write(state->i2c, state->adr, mm, 3);
+}
+
+static int readreg(struct stv_state *state, u16 reg, u8 *val)
+{
+	return i2c_read(state->i2c, state->adr, reg, val, 1);
+}
+
+static int readregs(struct stv_state *state, u16 reg, u8 *val, int count)
+{
+	return i2c_read(state->i2c, state->adr, reg, val, count);
+}
+
+static int write_init_table(struct stv_state *state, struct init_table *tab)
+{
+	while (1) {
+		if (!tab->adr)
+			break;
+		if (writereg(state, tab->adr, tab->data) < 0)
+			return -EREMOTEIO;
+		tab++;
+	}
+
+	return 0;
+}
+
+static int qam_set_modulation(struct stv_state *state)
+{
+	int stat = 0;
+
+	switch (state->modulation) {
+	case QAM_16:
+		writereg(state, R367_QAM_EQU_MAPPER,
+			state->qam_inversion | QAM_MOD_QAM16);
+		/* Set analog AGC reference */
+		writereg(state, R367_QAM_AGC_PWR_REF_L, 0x64);
+		/* Set digital AGC reference */
+		writereg(state, R367_QAM_IQDEM_ADJ_AGC_REF, 0x00);
+		writereg(state, R367_QAM_FSM_STATE, 0x90);
+		writereg(state, R367_QAM_EQU_CTR_LPF_GAIN, 0xc1);
+		writereg(state, R367_QAM_EQU_CRL_LPF_GAIN, 0xa7);
+		writereg(state, R367_QAM_EQU_CRL_LD_SEN, 0x95);
+		writereg(state, R367_QAM_EQU_CRL_LIMITER, 0x40);
+		writereg(state, R367_QAM_EQU_PNT_GAIN, 0x8a);
+		break;
+	case QAM_32:
+		writereg(state, R367_QAM_EQU_MAPPER,
+			state->qam_inversion | QAM_MOD_QAM32);
+		/* Set analog AGC reference */
+		writereg(state, R367_QAM_AGC_PWR_REF_L, 0x6e);
+		/* Set digital AGC reference */
+		writereg(state, R367_QAM_IQDEM_ADJ_AGC_REF, 0x00);
+		writereg(state, R367_QAM_FSM_STATE, 0xb0);
+		writereg(state, R367_QAM_EQU_CTR_LPF_GAIN, 0xc1);
+		writereg(state, R367_QAM_EQU_CRL_LPF_GAIN, 0xb7);
+		writereg(state, R367_QAM_EQU_CRL_LD_SEN, 0x9d);
+		writereg(state, R367_QAM_EQU_CRL_LIMITER, 0x7f);
+		writereg(state, R367_QAM_EQU_PNT_GAIN, 0xa7);
+		break;
+	case QAM_64:
+		writereg(state, R367_QAM_EQU_MAPPER,
+			state->qam_inversion | QAM_MOD_QAM64);
+		/* Set analog AGC reference */
+		writereg(state, R367_QAM_AGC_PWR_REF_L, 0x5a);
+		/* Set digital AGC reference */
+		writereg(state, R367_QAM_IQDEM_ADJ_AGC_REF, 0x82);
+
+		if (state->symbol_rate > 4500000) {
+			writereg(state, R367_QAM_FSM_STATE, 0xb0);
+			writereg(state, R367_QAM_EQU_CTR_LPF_GAIN, 0xc1);
+			writereg(state, R367_QAM_EQU_CRL_LPF_GAIN, 0xa5);
+		} else if (state->symbol_rate > 2500000) { /* 25000000 */
+			writereg(state, R367_QAM_FSM_STATE, 0xa0);
+			writereg(state, R367_QAM_EQU_CTR_LPF_GAIN, 0xc1);
+			writereg(state, R367_QAM_EQU_CRL_LPF_GAIN, 0xa6);
+		} else {
+			writereg(state, R367_QAM_FSM_STATE, 0xa0);
+			writereg(state, R367_QAM_EQU_CTR_LPF_GAIN, 0xd1);
+			writereg(state, R367_QAM_EQU_CRL_LPF_GAIN, 0xa7);
+		}
+		writereg(state, R367_QAM_EQU_CRL_LD_SEN, 0x95);
+		writereg(state, R367_QAM_EQU_CRL_LIMITER, 0x40);
+		writereg(state, R367_QAM_EQU_PNT_GAIN, 0x99);
+		break;
+	case QAM_128:
+		writereg(state, R367_QAM_EQU_MAPPER,
+			state->qam_inversion | QAM_MOD_QAM128);
+		/* Set analog AGC reference */
+		writereg(state, R367_QAM_AGC_PWR_REF_L, 0x76);
+		/* Set digital AGC reference */
+		writereg(state, R367_QAM_IQDEM_ADJ_AGC_REF, 0x00);
+		writereg(state, R367_QAM_FSM_STATE, 0x90);
+		writereg(state, R367_QAM_EQU_CTR_LPF_GAIN, 0xb1);
+		if (state->symbol_rate > 4500000) { /* 45000000 */
+			writereg(state, R367_QAM_EQU_CRL_LPF_GAIN, 0xa7);
+		} else if (state->symbol_rate > 2500000) { /* 25000000 */
+			writereg(state, R367_QAM_EQU_CRL_LPF_GAIN, 0xa6);
+		} else {
+			writereg(state, R367_QAM_EQU_CRL_LPF_GAIN, 0x97);
+		}
+		writereg(state, R367_QAM_EQU_CRL_LD_SEN, 0x8e);
+		writereg(state, R367_QAM_EQU_CRL_LIMITER, 0x7f);
+		writereg(state, R367_QAM_EQU_PNT_GAIN, 0xa7);
+		break;
+	case QAM_256:
+		writereg(state, R367_QAM_EQU_MAPPER,
+			state->qam_inversion | QAM_MOD_QAM256);
+		/* Set analog AGC reference */
+		writereg(state, R367_QAM_AGC_PWR_REF_L, 0x5a);
+		/* Set digital AGC reference */
+		writereg(state, R367_QAM_IQDEM_ADJ_AGC_REF, 0x94);
+		writereg(state, R367_QAM_FSM_STATE, 0xa0);
+
+		if (state->symbol_rate > 4500000) { /* 45000000 */
+			writereg(state, R367_QAM_EQU_CTR_LPF_GAIN, 0xc1);
+		} else if (state->symbol_rate > 2500000) { /* 25000000 */
+			writereg(state, R367_QAM_EQU_CTR_LPF_GAIN, 0xc1);
+		} else {
+			writereg(state, R367_QAM_EQU_CTR_LPF_GAIN, 0xd1);
+		}
+		writereg(state, R367_QAM_EQU_CRL_LPF_GAIN, 0xa7);
+		writereg(state, R367_QAM_EQU_CRL_LD_SEN, 0x85);
+		writereg(state, R367_QAM_EQU_CRL_LIMITER, 0x40);
+		writereg(state, R367_QAM_EQU_PNT_GAIN, 0xa7);
+		break;
+	default:
+		stat = -EINVAL;
+		break;
+	}
+	return stat;
+}
+
+static int QAM_SetSymbolRate(struct stv_state *state)
+{
+	int status = 0;
+	u32 sr = state->symbol_rate;
+	u32 Corr = 0;
+	u32 Temp, Temp1, AdpClk;
+
+	switch (state->modulation) {
+	default:
+	case QAM_16:
+		Corr = 1032;
+		break;
+	case QAM_32:
+		Corr =  954;
+		break;
+	case QAM_64:
+		Corr =  983;
+		break;
+	case QAM_128:
+		Corr =  957;
+		break;
+	case QAM_256:
+		Corr =  948;
+		break;
+	}
+
+	/* Transfer ration */
+	Temp = (256*sr) / state->adc_clock;
+	writereg(state, R367_QAM_EQU_CRL_TFR, (Temp));
+
+	/* Symbol rate and SRC gain calculation */
+	/* TRL works at half the system clock */
+	AdpClk = (state->master_clock) / 2000;
+
+	Temp = state->symbol_rate;
+	Temp1 = sr;
+
+	if (sr < 2097152) { /* 2097152 = 2^21 */
+		Temp  = ((((sr * 2048) / AdpClk) * 16384) / 125) * 8;
+		Temp1 = (((((sr * 2048) / 439) * 256) / AdpClk)
+			* Corr * 9) / 10000000;
+	} else if (sr < 4194304) { /* 4194304 = 2**22 */
+		Temp  = ((((sr * 1024) / AdpClk) * 16384) / 125) * 16;
+		Temp1 = (((((sr * 1024) / 439) * 256) / AdpClk)
+			* Corr * 9) / 5000000;
+	} else if (sr < 8388608) { /* 8388608 = 2**23 */
+		Temp  = ((((sr * 512) / AdpClk) * 16384) / 125) * 32;
+		Temp1 = (((((sr * 512) / 439) * 256) / AdpClk)
+			* Corr * 9) / 2500000;
+	} else {
+		Temp  = ((((sr * 256) / AdpClk) * 16384) / 125) * 64;
+		Temp1 = (((((sr * 256) / 439) * 256) / AdpClk)
+			* Corr * 9) / 1250000;
+	}
+
+	writereg(state, R367_QAM_SRC_NCO_LL, (Temp));
+	writereg(state, R367_QAM_SRC_NCO_LH, (Temp>>8));
+	writereg(state, R367_QAM_SRC_NCO_HL, (Temp>>16));
+	writereg(state, R367_QAM_SRC_NCO_HH, (Temp>>24));
+
+	writereg(state, R367_QAM_IQDEM_GAIN_SRC_L, (Temp1));
+	writereg(state, R367_QAM_IQDEM_GAIN_SRC_H, (Temp1>>8));
+	return status;
+}
+
+static int QAM_SetDerotFrequency(struct stv_state *state, u32 DerotFrequency)
+{
+	int status = 0;
+	u32 Sampled_IF;
+
+	do {
+		if (DerotFrequency > state->adc_clock)
+			/* User Alias */
+			DerotFrequency = DerotFrequency - state->adc_clock;
+
+		Sampled_IF = ((32768 * (DerotFrequency/1000))
+			/ (state->adc_clock/1000)) * 256;
+		if (Sampled_IF > 8388607)
+			Sampled_IF = 8388607;
+
+		writereg(state, R367_QAM_MIX_NCO_LL, (Sampled_IF));
+		writereg(state, R367_QAM_MIX_NCO_HL, (Sampled_IF>>8));
+		writereg(state, R367_QAM_MIX_NCO_HH, (Sampled_IF>>16));
+	} while (0);
+
+	return status;
+}
+
+static int QAM_Start(struct stv_state *state, s32 offsetFreq,
+	s32 IntermediateFrequency)
+{
+	int status = 0;
+	u32 AGCTimeOut = 25;
+	u32 TRLTimeOut = 100000000 / state->symbol_rate;
+	u32 CRLSymbols = 0;
+	u32 EQLTimeOut = 100;
+	u32 SearchRange = state->symbol_rate / 25;
+	u32 CRLTimeOut;
+	u8 Temp;
+
+	if (state->demod_state != QAMSet) {
+		writereg(state, R367_DEBUG_LT4, 0x00);
+		writereg(state, R367_DEBUG_LT5, 0x01);
+		writereg(state, R367_DEBUG_LT6, 0x06); /* R367_QAM_CTRL_1 */
+		writereg(state, R367_DEBUG_LT7, 0x03); /* R367_QAM_CTRL_2 */
+		writereg(state, R367_DEBUG_LT8, 0x00);
+		writereg(state, R367_DEBUG_LT9, 0x00);
+
+		/* Tuner Setup */
+		/* Buffer Q disabled, I Enabled, signed ADC */
+		writereg(state, R367_ANADIGCTRL, 0x8B);
+		/* ADCQ disabled */
+		writereg(state, R367_DUAL_AD12, 0x04);
+
+		/* Clock setup */
+		/* PLL bypassed and disabled */
+		writereg(state, R367_ANACTRL, 0x0D);
+		/* Set QAM */
+		writereg(state, R367_TOPCTRL, 0x10);
+
+		/* IC runs at 58 MHz with a 27 MHz crystal */
+		writereg(state, R367_PLLMDIV, 27);
+		writereg(state, R367_PLLNDIV, 232);
+		/* ADC clock is equal to system clock */
+		writereg(state, R367_PLLSETUP, 0x18);
+
+		msleep(50);
+		/* PLL enabled and used */
+		writereg(state, R367_ANACTRL, 0x00);
+
+		state->master_clock = 58000000;
+		state->adc_clock = 58000000;
+
+		state->demod_state = QAMSet;
+	}
+
+	state->m_bFirstTimeLock = true;
+	state->m_DemodLockTime  = -1;
+
+	qam_set_modulation(state);
+	QAM_SetSymbolRate(state);
+
+	/* Will make problems on low symbol rates ( < 2500000 ) */
+
+	switch (state->modulation) {
+	default:
+	case QAM_16:
+		CRLSymbols = 150000;
+		break;
+	case QAM_32:
+		CRLSymbols = 250000;
+		break;
+	case QAM_64:
+		CRLSymbols = 200000;
+		break;
+	case QAM_128:
+		CRLSymbols = 250000;
+		break;
+	case QAM_256:
+		CRLSymbols = 250000;
+		break;
+	}
+
+	CRLTimeOut = (25 * CRLSymbols * (SearchRange/1000))
+		/ (state->symbol_rate/1000);
+	CRLTimeOut = (1000 * CRLTimeOut) / state->symbol_rate;
+	if (CRLTimeOut < 50)
+		CRLTimeOut = 50;
+
+	state->m_FECTimeOut = 20;
+	state->m_DemodTimeOut = AGCTimeOut + TRLTimeOut + CRLTimeOut
+		+ EQLTimeOut;
+	state->m_SignalTimeOut = AGCTimeOut + TRLTimeOut;
+
+	/* QAM_AGC_ACCUMRSTSEL = 0 */
+	readreg(state, R367_QAM_AGC_CTL, &state->m_Save_QAM_AGC_CTL);
+	writereg(state, R367_QAM_AGC_CTL, state->m_Save_QAM_AGC_CTL & ~0x0F);
+
+	/* QAM_MODULUSMAP_EN = 0 */
+	readreg(state, R367_QAM_EQU_PNT_GAIN, &Temp);
+	writereg(state, R367_QAM_EQU_PNT_GAIN, Temp & ~0x40);
+
+	/* QAM_SWEEP_EN = 0 */
+	readreg(state, R367_QAM_EQU_CTR_LPF_GAIN, &Temp);
+	writereg(state, R367_QAM_EQU_CTR_LPF_GAIN, Temp & ~0x08);
+
+	QAM_SetDerotFrequency(state, IntermediateFrequency);
+
+	/* Release TRL */
+	writereg(state, R367_QAM_CTRL_1, 0x00);
+
+	state->IF = IntermediateFrequency;
+	state->demod_state = QAMStarted;
+
+	return status;
+}
+
+static int OFDM_Start(struct stv_state *state, s32 offsetFreq,
+	s32 IntermediateFrequency)
+{
+	int status = 0;
+	u8 GAIN_SRC1;
+	u32 Derot;
+	u8 SYR_CTL;
+	u8 tmp1;
+	u8 tmp2;
+
+	if (state->demod_state != OFDMSet) {
+		/* QAM Disable */
+		writereg(state, R367_DEBUG_LT4, 0x00);
+		writereg(state, R367_DEBUG_LT5, 0x00);
+		writereg(state, R367_DEBUG_LT6, 0x00); /* R367_QAM_CTRL_1 */
+		writereg(state, R367_DEBUG_LT7, 0x00); /* R367_QAM_CTRL_2 */
+		writereg(state, R367_DEBUG_LT8, 0x00);
+		writereg(state, R367_DEBUG_LT9, 0x00);
+
+		/* Tuner Setup */
+		/* Buffer Q disabled, I Enabled, unsigned ADC */
+		writereg(state, R367_ANADIGCTRL, 0x89);
+		writereg(state, R367_DUAL_AD12, 0x04); /* ADCQ disabled */
+
+		/* Clock setup */
+		/* PLL bypassed and disabled */
+		writereg(state, R367_ANACTRL, 0x0D);
+		writereg(state, R367_TOPCTRL, 0x00); /* Set OFDM */
+
+		/* IC runs at 54 MHz with a 27 MHz crystal */
+		writereg(state, R367_PLLMDIV, 1);
+		writereg(state, R367_PLLNDIV, 8);
+		/* ADC clock is equal to system clock */
+		writereg(state, R367_PLLSETUP, 0x18);
+
+		msleep(50);
+		/* PLL enabled and used */
+		writereg(state, R367_ANACTRL, 0x00);
+
+		state->master_clock = 54000000;
+		state->adc_clock    = 54000000;
+
+		state->demod_state = OFDMSet;
+	}
+
+	state->m_bFirstTimeLock = true;
+	state->m_DemodLockTime  = -1;
+
+	/* Set inversion in GAIN_SRC1 (fixed from init)
+	 * is in GAIN_SRC1, see below
+	 */
+
+	GAIN_SRC1 = 0xA0;
+	/* Bandwidth */
+
+	/* Fixed values for 54 MHz */
+	switch (state->bandwidth) {
+	case 0:
+	case 8000000:
+		/* Normrate = 44384 */
+		writereg(state, R367_OFDM_TRL_CTL, 0x14);
+		writereg(state, R367_OFDM_TRL_NOMRATE1, 0xB0);
+		writereg(state, R367_OFDM_TRL_NOMRATE2, 0x56);
+		/* Gain SRC = 2774 */
+		writereg(state, R367_OFDM_GAIN_SRC1, 0x0A | GAIN_SRC1);
+		writereg(state, R367_OFDM_GAIN_SRC2, 0xD6);
+		break;
+	case 7000000:
+		/* Normrate = 38836 */
+		writereg(state, R367_OFDM_TRL_CTL, 0x14);
+		writereg(state, R367_OFDM_TRL_NOMRATE1, 0xDA);
+		writereg(state, R367_OFDM_TRL_NOMRATE2, 0x4B);
+		/* Gain SRC = 2427 */
+		writereg(state, R367_OFDM_GAIN_SRC1, 0x09 | GAIN_SRC1);
+		writereg(state, R367_OFDM_GAIN_SRC2, 0x7B);
+		break;
+	case 6000000:
+		/* Normrate = 33288 */
+		writereg(state, R367_OFDM_TRL_CTL, 0x14);
+		writereg(state, R367_OFDM_TRL_NOMRATE1, 0x04);
+		writereg(state, R367_OFDM_TRL_NOMRATE2, 0x41);
+		/* Gain SRC = 2080 */
+		writereg(state, R367_OFDM_GAIN_SRC1, 0x08 | GAIN_SRC1);
+		writereg(state, R367_OFDM_GAIN_SRC2, 0x20);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	Derot = ((IntermediateFrequency / 1000) * 65536)
+		/ (state->master_clock / 1000);
+
+	writereg(state, R367_OFDM_INC_DEROT1, (Derot>>8));
+	writereg(state, R367_OFDM_INC_DEROT2, (Derot));
+
+	readreg(state, R367_OFDM_SYR_CTL, &SYR_CTL);
+	SYR_CTL &= ~0x78;
+	writereg(state, R367_OFDM_SYR_CTL, SYR_CTL); /* EchoPos = 0 */
+
+
+	/* Force = 0, Mode = 0, Guard = 3 */
+	writereg(state, R367_OFDM_COR_MODEGUARD, 0x03);
+	SYR_CTL &= 0x01;
+	writereg(state, R367_OFDM_SYR_CTL, SYR_CTL); /* SYR_TR_DIS = 0 */
+
+	usleep_range(5000, 6000);
+
+	writereg(state, R367_OFDM_COR_CTL, 0x20); /* Start core */
+
+	/* -- Begin M.V.
+	 * Reset FEC and Read Solomon
+	 */
+	readreg(state, R367_OFDM_SFDLYSETH, &tmp1);
+	readreg(state, R367_TSGENERAL, &tmp2);
+	writereg(state, R367_OFDM_SFDLYSETH, tmp1 | 0x08);
+	writereg(state, R367_TSGENERAL, tmp2 | 0x01);
+	/* -- End M.V. */
+
+	state->m_SignalTimeOut = 200;
+	state->IF = IntermediateFrequency;
+	state->demod_state = OFDMStarted;
+	state->m_DemodTimeOut = 0;
+	state->m_FECTimeOut = 0;
+	state->m_TSTimeOut = 0;
+
+	return status;
+}
+
+static int QAM_GetSignalToNoise(struct stv_state *state, u16 *snr)
+{
+	u32 RegValAvg = 0, tmpval;
+	s32 snrval;
+	u8 RegVal[2];
+	int i;
+
+	*snr = 0;
+	for (i = 0; i < 10; i += 1) {
+		readregs(state, R367_QAM_EQU_SNR_LO, RegVal, 2);
+		RegValAvg += RegVal[0] + 256 * RegVal[1];
+	}
+	if (RegValAvg != 0) {
+		s32 Power = 1;
+
+		switch (state->modulation) {
+		case QAM_16:
+			Power = 20480;
+			break;
+		case QAM_32:
+			Power = 23040;
+			break;
+		case QAM_64:
+			Power = 21504;
+			break;
+		case QAM_128:
+			Power = 23616;
+			break;
+		case QAM_256:
+			Power = 21760;
+			break;
+		default:
+			break;
+		}
+		tmpval = (Power * 320) / RegValAvg;
+		snrval = ((tmpval != 0) ? INTLOG10X100(tmpval) : 0);
+	} else {
+		snrval = 380;
+	}
+
+	*snr = 0xffff & (snrval * 100);
+	return 0;
+}
+
+static int OFDM_GetSignalToNoise(struct stv_state *state, u16 *snr)
+{
+	u8 CHC_SNR = 0;
+
+	*snr = 0;
+
+	if (readreg(state, R367_OFDM_CHC_SNR, &CHC_SNR) >= 0) {
+		/* Note: very unclear documentation on this.
+		 * Datasheet states snr = CHC_SNR/4 dB  -> way to high values!
+		 * Software snr = ( 1000 * CHC_SNR ) / 8 / 32 / 10;
+		 *   -> to low values
+		 * Comment in SW states this should be
+		 *   ( 1000 * CHC_SNR ) / 4 / 32 / 10; for the 367
+		 * 361/362 Datasheet: snr = CHC_SNR/8 dB -> this looks best
+		 */
+		*snr = ((u16)CHC_SNR * 1000) / 8;
+		return 0;
+	}
+	return -EINVAL;
+}
+
+static int attach_init(struct stv_state *state)
+{
+	int stat = 0;
+
+	stat = readreg(state, R367_ID, &state->ID);
+	if (stat < 0 || state->ID != 0x60)
+		return -ENODEV;
+
+	pr_info("%s demod with ChipID %02X found at adr %02X on %s\n",
+		state->frontend.ops.info.name, state->ID, state->adr,
+		dev_name(&state->i2c->dev));
+
+	writereg(state, R367_TOPCTRL, 0x10);
+	write_init_table(state, base_init);
+	write_init_table(state, qam_init);
+
+	writereg(state, R367_TOPCTRL, 0x00);
+	write_init_table(state, ofdm_init);
+
+	writereg(state, R367_OFDM_GAIN_SRC1, 0x2A);
+	writereg(state, R367_OFDM_GAIN_SRC2, 0xD6);
+	writereg(state, R367_OFDM_INC_DEROT1, 0x55);
+	writereg(state, R367_OFDM_INC_DEROT2, 0x55);
+	writereg(state, R367_OFDM_TRL_CTL, 0x14);
+	writereg(state, R367_OFDM_TRL_NOMRATE1, 0xAE);
+	writereg(state, R367_OFDM_TRL_NOMRATE2, 0x56);
+	writereg(state, R367_OFDM_FEPATH_CFG, 0x0);
+
+	/* OFDM TS Setup */
+
+	writereg(state, R367_OFDM_TSCFGH, 0x70);
+	writereg(state, R367_OFDM_TSCFGM, 0xC0);
+	writereg(state, R367_OFDM_TSCFGL, 0x20);
+	writereg(state, R367_OFDM_TSSPEED, 0x40); /* Fixed at 54 MHz */
+
+	writereg(state, R367_OFDM_TSCFGH, 0x71);
+
+	if (state->cont_clock)
+		writereg(state, R367_OFDM_TSCFGH, 0xf0);
+	else
+		writereg(state, R367_OFDM_TSCFGH, 0x70);
+
+	writereg(state, R367_TOPCTRL, 0x10);
+
+	/* Also needed for QAM */
+	writereg(state, R367_OFDM_AGC12C, 0x01); /* AGC Pin setup */
+
+	writereg(state, R367_OFDM_AGCCTRL1, 0x8A);
+
+	/* QAM TS setup, note exact format also depends on descrambler */
+	/* settings */
+	/* Inverted Clock, Swap, serial */
+	writereg(state, R367_QAM_OUTFORMAT_0, 0x85);
+
+	/* Clock setup */
+	writereg(state, R367_ANACTRL, 0x0D); /* PLL bypassed and disabled */
+
+	if (state->master_clock == 58000000) {
+		/* IC runs at 58 MHz with a 27 MHz crystal */
+		writereg(state, R367_PLLMDIV, 27);
+		writereg(state, R367_PLLNDIV, 232);
+	} else {
+		/* IC runs at 54 MHz with a 27 MHz crystal */
+		writereg(state, R367_PLLMDIV, 1);
+		writereg(state, R367_PLLNDIV, 8);
+	}
+
+	/* ADC clock is equal to system clock */
+	writereg(state, R367_PLLSETUP, 0x18);
+
+	/* Tuner setup */
+	/* Buffer Q disabled, I Enabled, signed ADC */
+	writereg(state, R367_ANADIGCTRL, 0x8b);
+	writereg(state, R367_DUAL_AD12, 0x04); /* ADCQ disabled */
+
+	/* Improves the C/N lock limit */
+	writereg(state, R367_QAM_FSM_SNR2_HTH, 0x23);
+	writereg(state, R367_QAM_IQ_QAM, 0x01); /* ZIF/IF Automatic mode */
+	/* Improving burst noise performances */
+	writereg(state, R367_QAM_EQU_FFE_LEAKAGE, 0x83);
+	/* Improving ACI performances */
+	writereg(state, R367_QAM_IQDEM_ADJ_EN, 0x05);
+
+	writereg(state, R367_ANACTRL, 0x00); /* PLL enabled and used */
+
+	writereg(state, R367_I2CRPT, state->I2CRPT);
+	state->demod_state = QAMSet;
+	return stat;
+}
+
+static void release(struct dvb_frontend *fe)
+{
+	struct stv_state *state = fe->demodulator_priv;
+
+	pr_info("%s()\n", __func__);
+	kfree(state);
+}
+
+static int gate_ctrl(struct dvb_frontend *fe, int enable)
+{
+	struct stv_state *state = fe->demodulator_priv;
+	u8 i2crpt = state->I2CRPT & ~0x80;
+
+	if (enable)
+		i2crpt |= 0x80;
+	if (writereg(state, R367_I2CRPT, i2crpt) < 0)
+		return -EIO;
+	state->I2CRPT = i2crpt;
+	return 0;
+}
+
+static int ofdm_lock(struct stv_state *state)
+{
+	int status = 0;
+	u8 OFDM_Status;
+	s32 DemodTimeOut = 10;
+	s32 FECTimeOut = 0;
+	s32 TSTimeOut = 0;
+	u8 CPAMPMin = 255;
+	u8 CPAMPValue;
+	u8 SYR_STAT;
+	u8 FFTMode;
+	u8 TSStatus;
+
+	msleep(state->m_SignalTimeOut);
+	readreg(state, R367_OFDM_STATUS, &OFDM_Status);
+
+	if (!(OFDM_Status & 0x40))
+		return -EIO;
+
+	readreg(state, R367_OFDM_SYR_STAT, &SYR_STAT);
+	FFTMode = (SYR_STAT & 0x0C) >> 2;
+
+	switch (FFTMode) {
+	case 0: /* 2K */
+		DemodTimeOut = 10;
+		FECTimeOut = 150;
+		TSTimeOut = 125;
+		CPAMPMin = 20;
+		break;
+	case 1: /* 8K */
+		DemodTimeOut = 55;
+		FECTimeOut = 600;
+		TSTimeOut = 500;
+		CPAMPMin = 80;
+		break;
+	case 2: /* 4K */
+		DemodTimeOut = 40;
+		FECTimeOut = 300;
+		TSTimeOut = 250;
+		CPAMPMin = 30;
+		break;
+	}
+	state->m_OFDM_FFTMode = FFTMode;
+	readreg(state, R367_OFDM_PPM_CPAMP_DIR, &CPAMPValue);
+	msleep(DemodTimeOut);
+	{
+	    /* Release FEC and Read Solomon Reset */
+	    u8 tmp1;
+	    u8 tmp2;
+
+	    readreg(state, R367_OFDM_SFDLYSETH, &tmp1);
+	    readreg(state, R367_TSGENERAL, &tmp2);
+	    writereg(state, R367_OFDM_SFDLYSETH, tmp1 & ~0x08);
+	    writereg(state, R367_TSGENERAL, tmp2 & ~0x01);
+	}
+	msleep(FECTimeOut);
+	if ((OFDM_Status & 0x98) != 0x98)
+		;/* return -1; */
+	/* printk("lock 2\n"); */
+
+	{
+	    u8 Guard = (SYR_STAT & 0x03);
+
+	    if (Guard < 2) {
+		u8 tmp;
+
+		readreg(state, R367_OFDM_SYR_CTL, &tmp);
+		/* Clear AUTO_LE_EN */
+		writereg(state, R367_OFDM_SYR_CTL, tmp & ~0x04);
+		readreg(state, R367_OFDM_SYR_UPDATE, &tmp);
+		/* Clear SYR_FILTER */
+		writereg(state, R367_OFDM_SYR_UPDATE, tmp & ~0x10);
+	    } else {
+		u8 tmp;
+
+		readreg(state, R367_OFDM_SYR_CTL, &tmp);
+		/* Set AUTO_LE_EN */
+		writereg(state, R367_OFDM_SYR_CTL, tmp | 0x04);
+		readreg(state, R367_OFDM_SYR_UPDATE, &tmp);
+		/* Set SYR_FILTER */
+		writereg(state, R367_OFDM_SYR_UPDATE, tmp | 0x10);
+	    }
+
+	    /* apply Sfec workaround if 8K 64QAM CR!=1/2 */
+	    if (FFTMode == 1) {
+		u8 tmp[2];
+
+		readregs(state, R367_OFDM_TPS_RCVD2, tmp, 2);
+		if (((tmp[0] & 0x03) == 0x02) && ((tmp[1] & 0x07) != 0)) {
+			writereg(state, R367_OFDM_SFDLYSETH, 0xc0);
+			writereg(state, R367_OFDM_SFDLYSETM, 0x60);
+			writereg(state, R367_OFDM_SFDLYSETL, 0x00);
+		} else {
+			writereg(state, R367_OFDM_SFDLYSETH, 0x00);
+		}
+	    }
+	}
+	msleep(TSTimeOut);
+	readreg(state, R367_OFDM_TSSTATUS, &TSStatus);
+	if ((TSStatus & 0x80) != 0x80)
+		return -EIO;
+
+	return status;
+}
+
+static int set_parameters(struct dvb_frontend *fe)
+{
+	int stat;
+	struct stv_state *state = fe->demodulator_priv;
+	u32 OF = 0;
+	u32 IF;
+
+	switch (fe->dtv_property_cache.delivery_system) {
+	case SYS_DVBC_ANNEX_A:
+		/* symbol rate 0 might cause an oops */
+		if (fe->dtv_property_cache.symbol_rate == 0) {
+			pr_err("Invalid symbol rate\n");
+			return -EINVAL;
+		}
+		break;
+	case SYS_DVBT:
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	state->delsys = fe->dtv_property_cache.delivery_system;
+
+	if (fe->ops.tuner_ops.set_params)
+		fe->ops.tuner_ops.set_params(fe);
+	state->modulation = fe->dtv_property_cache.modulation;
+	state->symbol_rate = fe->dtv_property_cache.symbol_rate;
+	state->bandwidth = fe->dtv_property_cache.bandwidth_hz;
+	fe->ops.tuner_ops.get_if_frequency(fe, &IF);
+
+	switch (state->delsys) {
+	case SYS_DVBT:
+		stat = OFDM_Start(state, OF, IF);
+		ofdm_lock(state);
+		break;
+	case SYS_DVBC_ANNEX_A:
+		stat = QAM_Start(state, OF, IF);
+		break;
+	default:
+		stat = -EINVAL;
+	}
+
+	return stat;
+}
+
+static int read_status(struct dvb_frontend *fe, enum fe_status *status)
+{
+	struct stv_state *state = fe->demodulator_priv;
+	*status = 0;
+
+	switch (state->demod_state) {
+	case QAMStarted:
+	{
+		u8 FEC_Lock;
+		u8 QAM_Lock;
+
+		readreg(state, R367_QAM_FSM_STS, &QAM_Lock);
+		QAM_Lock &= 0x0F;
+		if (QAM_Lock > 10)
+			*status |= (FE_HAS_SIGNAL
+				| FE_HAS_CARRIER
+				| FE_HAS_VITERBI);
+		readreg(state, R367_QAM_FEC_STATUS, &FEC_Lock);
+		if (FEC_Lock&2)
+			*status |= (FE_HAS_SIGNAL
+				| FE_HAS_CARRIER
+				| FE_HAS_VITERBI
+				| FE_HAS_SYNC
+				| FE_HAS_LOCK);
+		if (state->m_bFirstTimeLock) {
+			state->m_bFirstTimeLock = false;
+			/* QAM_AGC_ACCUMRSTSEL to Tracking */
+			writereg(state, R367_QAM_AGC_CTL,
+				state->m_Save_QAM_AGC_CTL);
+		}
+		break;
+	}
+	case OFDMStarted:
+	{
+		u8 OFDM_Status;
+		u8 TSStatus;
+
+		readreg(state, R367_OFDM_TSSTATUS, &TSStatus);
+
+		readreg(state, R367_OFDM_STATUS, &OFDM_Status);
+		if (OFDM_Status & 0x40)
+			*status |= FE_HAS_SIGNAL;
+
+		if ((OFDM_Status & 0x98) == 0x98)
+			*status |= (FE_HAS_SIGNAL
+				| FE_HAS_CARRIER
+				| FE_HAS_VITERBI
+				| FE_HAS_SYNC);
+
+		if (TSStatus & 0x80)
+			*status |= (FE_HAS_SIGNAL
+				| FE_HAS_CARRIER
+				| FE_HAS_VITERBI
+				| FE_HAS_SYNC
+				| FE_HAS_LOCK);
+		break;
+	}
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static int read_ber_ter(struct dvb_frontend *fe, u32 *ber)
+{
+	struct stv_state *state = fe->demodulator_priv;
+	u32 err;
+	u8 cnth, cntm, cntl;
+
+	readreg(state, R367_OFDM_SFERRCNTH, &cnth);
+
+	if (cnth & 0x80) {
+		*ber = state->ber;
+		return 0;
+	}
+
+	readreg(state, R367_OFDM_SFERRCNTM, &cntm);
+	readreg(state, R367_OFDM_SFERRCNTL, &cntl);
+
+	err = ((cnth & 0x7f) << 16) | (cntm << 8) | cntl;
+
+	*ber = state->ber = err;
+	return 0;
+}
+
+static int read_ber_cab(struct dvb_frontend *fe, u32 *ber)
+{
+	struct stv_state *state = fe->demodulator_priv;
+	u32 err;
+	u8 cntm, cntl, ctrl;
+
+	readreg(state, R367_QAM_BERT_1, &ctrl);
+	if (!(ctrl & 0x20)) {
+		readreg(state, R367_QAM_BERT_2, &cntl);
+		readreg(state, R367_QAM_BERT_3, &cntm);
+		err = (cntm << 8) | cntl;
+		state->ber = err;
+		writereg(state, R367_QAM_BERT_1, 0x27);
+	}
+	*ber = (u32) state->ber;
+	return 0;
+}
+
+static int read_ber(struct dvb_frontend *fe, u32 *ber)
+{
+	struct stv_state *state = fe->demodulator_priv;
+
+	if (state->demod_state == QAMStarted)
+		return read_ber_cab(fe, ber);
+	if (state->demod_state == OFDMStarted)
+		return read_ber_ter(fe, ber);
+	*ber = 0;
+	return 0;
+}
+
+static int read_signal_strength(struct dvb_frontend *fe, u16 *strength)
+{
+	if (fe->ops.tuner_ops.get_rf_strength)
+		fe->ops.tuner_ops.get_rf_strength(fe, strength);
+	else
+		*strength = 0;
+	return 0;
+}
+
+static int read_snr(struct dvb_frontend *fe, u16 *snr)
+{
+	struct stv_state *state = fe->demodulator_priv;
+
+	*snr = 0;
+
+	switch (state->demod_state) {
+	case QAMStarted:
+		return QAM_GetSignalToNoise(state, snr);
+	case OFDMStarted:
+		return OFDM_GetSignalToNoise(state, snr);
+	default:
+		break;
+	}
+
+	return -EINVAL;
+}
+
+static int read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)
+{
+	struct stv_state *state = fe->demodulator_priv;
+	u8 errl, errm, errh;
+	u8 val;
+
+	switch (state->demod_state) {
+	case QAMStarted:
+		readreg(state, R367_QAM_RS_COUNTER_4, &errl);
+		readreg(state, R367_QAM_RS_COUNTER_5, &errm);
+		*ucblocks = (errm << 8) | errl;
+		break;
+	case OFDMStarted:
+		readreg(state, R367_OFDM_SFERRCNTH, &val);
+		if ((val & 0x80) == 0) {
+			readreg(state, R367_OFDM_ERRCNT1H, &errh);
+			readreg(state, R367_OFDM_ERRCNT1M, &errl);
+			readreg(state, R367_OFDM_ERRCNT1L, &errm);
+			state->ucblocks = (errh << 16) | (errm << 8) | errl;
+		}
+		*ucblocks = state->ucblocks;
+		break;
+	default:
+		*ucblocks = 0;
+		break;
+	}
+	return 0;
+}
+
+static int c_get_tune_settings(struct dvb_frontend *fe,
+				    struct dvb_frontend_tune_settings *sets)
+{
+	sets->min_delay_ms = 3000;
+	sets->max_drift = 0;
+	sets->step_size = 0;
+	return 0;
+}
+
+static int get_tune_settings(struct dvb_frontend *fe,
+			     struct dvb_frontend_tune_settings *sets)
+{
+	switch (fe->dtv_property_cache.delivery_system) {
+	case SYS_DVBC_ANNEX_A:
+	case SYS_DVBC_ANNEX_C:
+		return c_get_tune_settings(fe, sets);
+	default:
+		/* DVB-T: Use info.frequency_stepsize. */
+		return -EINVAL;
+	}
+}
+
+static int get_frontend(struct dvb_frontend *fe,
+			struct dtv_frontend_properties *p)
+{
+	//struct stv_state *state = fe->demodulator_priv;
+	enum fe_status status = 0;
+	int tmp;
+	u16 snr = 0, strength = 0;
+	u32 ber = 0, ucblocks = 0;
+
+	tmp = read_status(fe, &status);
+
+	p->strength.len = 1;
+	p->cnr.len = 1;
+	p->post_bit_error.len = 1;
+	p->block_error.len = 1;
+
+	if (!(status & FE_HAS_LOCK)) {
+		p->strength.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+		p->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+		p->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+		p->block_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+		return 0;
+	}
+
+	if (read_snr(fe, &snr))
+		p->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+	else {
+		p->cnr.stat[0].scale = FE_SCALE_DECIBEL;
+		p->cnr.stat[0].svalue = snr;
+	}
+
+	if (read_signal_strength(fe, &strength))
+		p->strength.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+	else {
+		p->strength.stat[0].scale = FE_SCALE_RELATIVE;
+		p->strength.stat[0].svalue = strength;
+	}
+
+	if (read_ber(fe, &ber))
+		p->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+	else {
+		p->post_bit_error.stat[0].scale = FE_SCALE_COUNTER;
+		p->post_bit_error.stat[0].uvalue = ber;
+	}
+
+	if (read_ucblocks(fe, &ucblocks))
+		p->block_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+	else {
+		p->block_error.stat[0].scale = FE_SCALE_COUNTER;
+		p->block_error.stat[0].uvalue = ucblocks;
+	}
+
+	return 0;
+}
+
+
+static struct dvb_frontend_ops common_ops = {
+	.delsys = { SYS_DVBC_ANNEX_A, SYS_DVBT },
+	.info = {
+		.name = "STV0367 DVB-C DVB-T",
+		.frequency_stepsize = 166667,	/* DVB-T only */
+		.frequency_min = 47000000,	/* DVB-T: 47125000 */
+		.frequency_max = 865000000,	/* DVB-C: 862000000 */
+		.symbol_rate_min = 870000,
+		.symbol_rate_max = 11700000,
+		.caps = /* DVB-C */
+			FE_CAN_QAM_16 | FE_CAN_QAM_32 | FE_CAN_QAM_64 |
+			FE_CAN_QAM_128 | FE_CAN_QAM_256 |
+			FE_CAN_FEC_AUTO |
+			/* DVB-T */
+			FE_CAN_QAM_16 | FE_CAN_QAM_64 | FE_CAN_QAM_AUTO |
+			FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |
+			FE_CAN_FEC_5_6 | FE_CAN_FEC_7_8 | FE_CAN_FEC_AUTO |
+			FE_CAN_TRANSMISSION_MODE_AUTO |
+			FE_CAN_GUARD_INTERVAL_AUTO | FE_CAN_HIERARCHY_AUTO |
+			FE_CAN_RECOVER | FE_CAN_MUTE_TS
+	},
+	.release = release,
+	.i2c_gate_ctrl = gate_ctrl,
+
+	.get_tune_settings = get_tune_settings,
+
+	.set_frontend = set_parameters,
+	.get_frontend = get_frontend,
+
+	.read_status = read_status,
+};
+
+
+static void init_state(struct stv_state *state, struct stv0367dd_cfg *cfg)
+{
+	u32 ulENARPTLEVEL = 5;
+	u32 ulQAMInversion = 2;
+
+	state->delsys = SYS_UNDEFINED;
+	state->adr = cfg->adr;
+	state->cont_clock = cfg->cont_clock;
+
+	mutex_init(&state->mutex);
+	mutex_init(&state->ctlock);
+
+	memcpy(&state->frontend.ops, &common_ops,
+		sizeof(struct dvb_frontend_ops));
+
+	state->frontend.demodulator_priv = state;
+
+	state->master_clock = 58000000;
+	state->adc_clock = 58000000;
+	state->I2CRPT = 0x08 | ((ulENARPTLEVEL & 0x07) << 4);
+	state->qam_inversion = ((ulQAMInversion & 3) << 6);
+	state->demod_state   = Off;
+}
+
+struct dvb_frontend *stv0367dd_attach(struct i2c_adapter *i2c,
+	struct stv0367dd_cfg *cfg, struct dvb_frontend **fe_t)
+{
+	struct stv_state *state = NULL;
+
+	state = kzalloc(sizeof(struct stv_state), GFP_KERNEL);
+	if (!state)
+		return NULL;
+
+	state->i2c = i2c;
+	init_state(state, cfg);
+
+	if (attach_init(state) < 0)
+		goto error;
+	return &state->frontend;
+
+error:
+	pr_err("No supported demodulator found at adr %02X on %s\n",
+		cfg->adr, dev_name(&i2c->dev));
+
+	kfree(state);
+	return NULL;
+}
+EXPORT_SYMBOL(stv0367dd_attach);
+
+MODULE_DESCRIPTION("STV0367DD driver");
+MODULE_AUTHOR("Ralph Metzler, Manfred Voelkel");
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/dvb-frontends/stv0367dd.h b/drivers/media/dvb-frontends/stv0367dd.h
new file mode 100644
index 0000000..2c0b426
--- /dev/null
+++ b/drivers/media/dvb-frontends/stv0367dd.h
@@ -0,0 +1,31 @@
+#ifndef _STV0367DD_H_
+#define _STV0367DD_H_
+
+#include <linux/types.h>
+#include <linux/i2c.h>
+
+struct stv0367dd_cfg {
+	u8  adr;
+	u32 xtal;
+	u8 parallel;
+	u8 cont_clock;
+};
+
+#if IS_REACHABLE(CONFIG_DVB_STV0367DD)
+
+extern struct dvb_frontend *stv0367dd_attach(struct i2c_adapter *i2c,
+					     struct stv0367dd_cfg *cfg,
+					     struct dvb_frontend **fe_t);
+
+#else
+
+static inline struct dvb_frontend *stv0367dd_attach(struct i2c_adapter *i2c,
+	struct stv0367dd_cfg *cfg, struct dvb_frontend **fe_t)
+{
+	pr_warn("%s: driver disabled by Kconfig\n", __func__);
+	return NULL;
+}
+
+#endif /* CONFIG_DVB_STV0367DD */
+
+#endif /* _STV0367DD_H_ */
diff --git a/drivers/media/dvb-frontends/stv0367dd_regs.h b/drivers/media/dvb-frontends/stv0367dd_regs.h
new file mode 100644
index 0000000..4f22ae6
--- /dev/null
+++ b/drivers/media/dvb-frontends/stv0367dd_regs.h
@@ -0,0 +1,3429 @@
+/* @DVB-C/DVB-T STMicroelectronics STV0367 register defintions
+ * Author Manfred Voelkel, Februar 2011
+ * (c) 2010 DigitalDevices GmbH Germany.  All rights reserved
+ *
+ * ======================================================================
+ *  -- Registers Declaration
+ *  -- -------------------------
+ *  -- Each register (R367_XXXXX) is defined by its address (2 bytes).
+ *  --
+ *  -- Each field (F367_XXXXX)is defined as follow:
+ *  -- [register address -- 2bytes][field sign -- 1byte][field mask -- 1byte]
+ * ======================================================================
+ */
+
+/* ID */
+#define	R367_ID		0xF000
+#define	F367_IDENTIFICATIONREG		0xF00000FF
+
+/* I2CRPT */
+#define	R367_I2CRPT		0xF001
+#define	F367_I2CT_ON		0xF0010080
+#define	F367_ENARPT_LEVEL		0xF0010070
+#define	F367_SCLT_DELAY		0xF0010008
+#define	F367_SCLT_NOD		0xF0010004
+#define	F367_STOP_ENABLE		0xF0010002
+#define	F367_SDAT_NOD		0xF0010001
+
+/* TOPCTRL */
+#define	R367_TOPCTRL		0xF002
+#define	F367_STDBY		0xF0020080
+#define	F367_STDBY_FEC		0xF0020040
+#define	F367_STDBY_CORE		0xF0020020
+#define	F367_QAM_COFDM		0xF0020010
+#define	F367_TS_DIS		0xF0020008
+#define	F367_DIR_CLK_216		0xF0020004
+#define	F367_TUNER_BB		0xF0020002
+#define	F367_DVBT_H		0xF0020001
+
+/* IOCFG0 */
+#define	R367_IOCFG0		0xF003
+#define	F367_OP0_SD		0xF0030080
+#define	F367_OP0_VAL		0xF0030040
+#define	F367_OP0_OD		0xF0030020
+#define	F367_OP0_INV		0xF0030010
+#define	F367_OP0_DACVALUE_HI		0xF003000F
+
+/* DAC0R */
+#define	R367_DAC0R		0xF004
+#define	F367_OP0_DACVALUE_LO		0xF00400FF
+
+/* IOCFG1 */
+#define	R367_IOCFG1		0xF005
+#define	F367_IP0		0xF0050040
+#define	F367_OP1_OD		0xF0050020
+#define	F367_OP1_INV		0xF0050010
+#define	F367_OP1_DACVALUE_HI		0xF005000F
+
+/* DAC1R */
+#define	R367_DAC1R		0xF006
+#define	F367_OP1_DACVALUE_LO		0xF00600FF
+
+/* IOCFG2 */
+#define	R367_IOCFG2		0xF007
+#define	F367_OP2_LOCK_CONF		0xF00700E0
+#define	F367_OP2_OD		0xF0070010
+#define	F367_OP2_VAL		0xF0070008
+#define	F367_OP1_LOCK_CONF		0xF0070007
+
+/* SDFR */
+#define	R367_SDFR		0xF008
+#define	F367_OP0_FREQ		0xF00800F0
+#define	F367_OP1_FREQ		0xF008000F
+
+/* STATUS */
+#define	R367_OFDM_STATUS		0xF009
+#define	F367_TPS_LOCK		0xF0090080
+#define	F367_SYR_LOCK		0xF0090040
+#define	F367_AGC_LOCK		0xF0090020
+#define	F367_PRF		0xF0090010
+#define	F367_LK		0xF0090008
+#define	F367_PR		0xF0090007
+
+/* AUX_CLK */
+#define	R367_AUX_CLK		0xF00A
+#define	F367_AUXFEC_CTL		0xF00A00C0
+#define	F367_DIS_CKX4		0xF00A0020
+#define	F367_CKSEL		0xF00A0018
+#define	F367_CKDIV_PROG		0xF00A0006
+#define	F367_AUXCLK_ENA		0xF00A0001
+
+/* FREESYS1 */
+#define	R367_FREESYS1		0xF00B
+#define	F367_FREE_SYS1		0xF00B00FF
+
+/* FREESYS2 */
+#define	R367_FREESYS2		0xF00C
+#define	F367_FREE_SYS2		0xF00C00FF
+
+/* FREESYS3 */
+#define	R367_FREESYS3		0xF00D
+#define	F367_FREE_SYS3		0xF00D00FF
+
+/* GPIO_CFG */
+#define	R367_GPIO_CFG		0xF00E
+#define	F367_GPIO7_NOD		0xF00E0080
+#define	F367_GPIO7_CFG		0xF00E0040
+#define	F367_GPIO6_NOD		0xF00E0020
+#define	F367_GPIO6_CFG		0xF00E0010
+#define	F367_GPIO5_NOD		0xF00E0008
+#define	F367_GPIO5_CFG		0xF00E0004
+#define	F367_GPIO4_NOD		0xF00E0002
+#define	F367_GPIO4_CFG		0xF00E0001
+
+/* GPIO_CMD */
+#define	R367_GPIO_CMD		0xF00F
+#define	F367_GPIO7_VAL		0xF00F0008
+#define	F367_GPIO6_VAL		0xF00F0004
+#define	F367_GPIO5_VAL		0xF00F0002
+#define	F367_GPIO4_VAL		0xF00F0001
+
+/* AGC2MAX */
+#define	R367_OFDM_AGC2MAX		0xF010
+#define	F367_OFDM_AGC2_MAX		0xF01000FF
+
+/* AGC2MIN */
+#define	R367_OFDM_AGC2MIN		0xF011
+#define	F367_OFDM_AGC2_MIN		0xF01100FF
+
+/* AGC1MAX */
+#define	R367_OFDM_AGC1MAX		0xF012
+#define	F367_OFDM_AGC1_MAX		0xF01200FF
+
+/* AGC1MIN */
+#define	R367_OFDM_AGC1MIN		0xF013
+#define	F367_OFDM_AGC1_MIN		0xF01300FF
+
+/* AGCR */
+#define	R367_OFDM_AGCR		0xF014
+#define	F367_OFDM_RATIO_A		0xF01400E0
+#define	F367_OFDM_RATIO_B		0xF0140018
+#define	F367_OFDM_RATIO_C		0xF0140007
+
+/* AGC2TH */
+#define	R367_OFDM_AGC2TH		0xF015
+#define	F367_OFDM_AGC2_THRES		0xF01500FF
+
+/* AGC12C */
+#define	R367_OFDM_AGC12C		0xF016
+#define	F367_OFDM_AGC1_IV		0xF0160080
+#define	F367_OFDM_AGC1_OD		0xF0160040
+#define	F367_OFDM_AGC1_LOAD		0xF0160020
+#define	F367_OFDM_AGC2_IV		0xF0160010
+#define	F367_OFDM_AGC2_OD		0xF0160008
+#define	F367_OFDM_AGC2_LOAD		0xF0160004
+#define	F367_OFDM_AGC12_MODE		0xF0160003
+
+/* AGCCTRL1 */
+#define	R367_OFDM_AGCCTRL1		0xF017
+#define	F367_OFDM_DAGC_ON		0xF0170080
+#define	F367_OFDM_INVERT_AGC12		0xF0170040
+#define	F367_OFDM_AGC1_MODE		0xF0170008
+#define	F367_OFDM_AGC2_MODE		0xF0170007
+
+/* AGCCTRL2 */
+#define	R367_OFDM_AGCCTRL2		0xF018
+#define	F367_OFDM_FRZ2_CTRL		0xF0180060
+#define	F367_OFDM_FRZ1_CTRL		0xF0180018
+#define	F367_OFDM_TIME_CST		0xF0180007
+
+/* AGC1VAL1 */
+#define	R367_OFDM_AGC1VAL1		0xF019
+#define	F367_OFDM_AGC1_VAL_LO		0xF01900FF
+
+/* AGC1VAL2 */
+#define	R367_OFDM_AGC1VAL2		0xF01A
+#define	F367_OFDM_AGC1_VAL_HI		0xF01A000F
+
+/* AGC2VAL1 */
+#define	R367_OFDM_AGC2VAL1		0xF01B
+#define	F367_OFDM_AGC2_VAL_LO		0xF01B00FF
+
+/* AGC2VAL2 */
+#define	R367_OFDM_AGC2VAL2		0xF01C
+#define	F367_OFDM_AGC2_VAL_HI		0xF01C000F
+
+/* AGC2PGA */
+#define	R367_OFDM_AGC2PGA		0xF01D
+#define	F367_OFDM_AGC2_PGA		0xF01D00FF
+
+/* OVF_RATE1 */
+#define	R367_OFDM_OVF_RATE1		0xF01E
+#define	F367_OFDM_OVF_RATE_HI		0xF01E000F
+
+/* OVF_RATE2 */
+#define	R367_OFDM_OVF_RATE2		0xF01F
+#define	F367_OFDM_OVF_RATE_LO		0xF01F00FF
+
+/* GAIN_SRC1 */
+#define	R367_OFDM_GAIN_SRC1		0xF020
+#define	F367_OFDM_INV_SPECTR		0xF0200080
+#define	F367_OFDM_IQ_INVERT		0xF0200040
+#define	F367_OFDM_INR_BYPASS		0xF0200020
+#define	F367_OFDM_STATUS_INV_SPECRUM		0xF0200010
+#define	F367_OFDM_GAIN_SRC_HI		0xF020000F
+
+/* GAIN_SRC2 */
+#define	R367_OFDM_GAIN_SRC2		0xF021
+#define	F367_OFDM_GAIN_SRC_LO		0xF02100FF
+
+/* INC_DEROT1 */
+#define	R367_OFDM_INC_DEROT1		0xF022
+#define	F367_OFDM_INC_DEROT_HI		0xF02200FF
+
+/* INC_DEROT2 */
+#define	R367_OFDM_INC_DEROT2		0xF023
+#define	F367_OFDM_INC_DEROT_LO		0xF02300FF
+
+/* PPM_CPAMP_DIR */
+#define	R367_OFDM_PPM_CPAMP_DIR		0xF024
+#define	F367_OFDM_PPM_CPAMP_DIRECT		0xF02400FF
+
+/* PPM_CPAMP_INV */
+#define	R367_OFDM_PPM_CPAMP_INV		0xF025
+#define	F367_OFDM_PPM_CPAMP_INVER		0xF02500FF
+
+/* FREESTFE_1 */
+#define	R367_OFDM_FREESTFE_1		0xF026
+#define	F367_OFDM_SYMBOL_NUMBER_INC		0xF02600C0
+#define	F367_OFDM_SEL_LSB		0xF0260004
+#define	F367_OFDM_AVERAGE_ON		0xF0260002
+#define	F367_OFDM_DC_ADJ		0xF0260001
+
+/* FREESTFE_2 */
+#define	R367_OFDM_FREESTFE_2		0xF027
+#define	F367_OFDM_SEL_SRCOUT		0xF02700C0
+#define	F367_OFDM_SEL_SYRTHR		0xF027001F
+
+/* DCOFFSET */
+#define	R367_OFDM_DCOFFSET		0xF028
+#define	F367_OFDM_SELECT_I_Q		0xF0280080
+#define	F367_OFDM_DC_OFFSET		0xF028007F
+
+/* EN_PROCESS */
+#define	R367_OFDM_EN_PROCESS		0xF029
+#define	F367_OFDM_FREE		0xF02900F0
+#define	F367_OFDM_ENAB_MANUAL		0xF0290001
+
+/* SDI_SMOOTHER */
+#define	R367_OFDM_SDI_SMOOTHER		0xF02A
+#define	F367_OFDM_DIS_SMOOTH		0xF02A0080
+#define	F367_OFDM_SDI_INC_SMOOTHER		0xF02A007F
+
+/* FE_LOOP_OPEN */
+#define	R367_OFDM_FE_LOOP_OPEN		0xF02B
+#define	F367_OFDM_TRL_LOOP_OP		0xF02B0002
+#define	F367_OFDM_CRL_LOOP_OP		0xF02B0001
+
+/* FREQOFF1 */
+#define	R367_OFDM_FREQOFF1		0xF02C
+#define	F367_OFDM_FREQ_OFFSET_LOOP_OPEN_VHI		0xF02C00FF
+
+/* FREQOFF2 */
+#define	R367_OFDM_FREQOFF2		0xF02D
+#define	F367_OFDM_FREQ_OFFSET_LOOP_OPEN_HI		0xF02D00FF
+
+/* FREQOFF3 */
+#define	R367_OFDM_FREQOFF3		0xF02E
+#define	F367_OFDM_FREQ_OFFSET_LOOP_OPEN_LO		0xF02E00FF
+
+/* TIMOFF1 */
+#define	R367_OFDM_TIMOFF1		0xF02F
+#define	F367_OFDM_TIM_OFFSET_LOOP_OPEN_HI		0xF02F00FF
+
+/* TIMOFF2 */
+#define	R367_OFDM_TIMOFF2		0xF030
+#define	F367_OFDM_TIM_OFFSET_LOOP_OPEN_LO		0xF03000FF
+
+/* EPQ */
+#define	R367_OFDM_EPQ		0xF031
+#define	F367_OFDM_EPQ1		0xF03100FF
+
+/* EPQAUTO */
+#define	R367_OFDM_EPQAUTO		0xF032
+#define	F367_OFDM_EPQ2		0xF03200FF
+
+/* SYR_UPDATE */
+#define	R367_OFDM_SYR_UPDATE		0xF033
+#define	F367_OFDM_SYR_PROTV		0xF0330080
+#define	F367_OFDM_SYR_PROTV_GAIN		0xF0330060
+#define	F367_OFDM_SYR_FILTER		0xF0330010
+#define	F367_OFDM_SYR_TRACK_THRES		0xF033000C
+
+/* CHPFREE */
+#define	R367_OFDM_CHPFREE		0xF034
+#define	F367_OFDM_CHP_FREE		0xF03400FF
+
+/* PPM_STATE_MAC */
+#define	R367_OFDM_PPM_STATE_MAC		0xF035
+#define	F367_OFDM_PPM_STATE_MACHINE_DECODER		0xF035003F
+
+/* INR_THRESHOLD */
+#define	R367_OFDM_INR_THRESHOLD		0xF036
+#define	F367_OFDM_INR_THRESH		0xF03600FF
+
+/* EPQ_TPS_ID_CELL */
+#define	R367_OFDM_EPQ_TPS_ID_CELL		0xF037
+#define	F367_OFDM_ENABLE_LGTH_TO_CF		0xF0370080
+#define	F367_OFDM_DIS_TPS_RSVD		0xF0370040
+#define	F367_OFDM_DIS_BCH		0xF0370020
+#define	F367_OFDM_DIS_ID_CEL		0xF0370010
+#define	F367_OFDM_TPS_ADJUST_SYM		0xF037000F
+
+/* EPQ_CFG */
+#define	R367_OFDM_EPQ_CFG		0xF038
+#define	F367_OFDM_EPQ_RANGE		0xF0380002
+#define	F367_OFDM_EPQ_SOFT		0xF0380001
+
+/* EPQ_STATUS */
+#define	R367_OFDM_EPQ_STATUS		0xF039
+#define	F367_OFDM_SLOPE_INC		0xF03900FC
+#define	F367_OFDM_TPS_FIELD		0xF0390003
+
+/* AUTORELOCK */
+#define	R367_OFDM_AUTORELOCK		0xF03A
+#define	F367_OFDM_BYPASS_BER_TEMPO		0xF03A0080
+#define	F367_OFDM_BER_TEMPO		0xF03A0070
+#define	F367_OFDM_BYPASS_COFDM_TEMPO		0xF03A0008
+#define	F367_OFDM_COFDM_TEMPO		0xF03A0007
+
+/* BER_THR_VMSB */
+#define	R367_OFDM_BER_THR_VMSB		0xF03B
+#define	F367_OFDM_BER_THRESHOLD_HI		0xF03B00FF
+
+/* BER_THR_MSB */
+#define	R367_OFDM_BER_THR_MSB		0xF03C
+#define	F367_OFDM_BER_THRESHOLD_MID		0xF03C00FF
+
+/* BER_THR_LSB */
+#define	R367_OFDM_BER_THR_LSB		0xF03D
+#define	F367_OFDM_BER_THRESHOLD_LO		0xF03D00FF
+
+/* CCD */
+#define	R367_OFDM_CCD		0xF03E
+#define	F367_OFDM_CCD_DETECTED		0xF03E0080
+#define	F367_OFDM_CCD_RESET		0xF03E0040
+#define	F367_OFDM_CCD_THRESHOLD		0xF03E000F
+
+/* SPECTR_CFG */
+#define	R367_OFDM_SPECTR_CFG		0xF03F
+#define	F367_OFDM_SPECT_CFG		0xF03F0003
+
+/* CONSTMU_MSB */
+#define	R367_OFDM_CONSTMU_MSB		0xF040
+#define	F367_OFDM_CONSTMU_FREEZE		0xF0400080
+#define	F367_OFDM_CONSTNU_FORCE_EN		0xF0400040
+#define	F367_OFDM_CONST_MU_MSB		0xF040003F
+
+/* CONSTMU_LSB */
+#define	R367_OFDM_CONSTMU_LSB		0xF041
+#define	F367_OFDM_CONST_MU_LSB		0xF04100FF
+
+/* CONSTMU_MAX_MSB */
+#define	R367_OFDM_CONSTMU_MAX_MSB		0xF042
+#define	F367_OFDM_CONST_MU_MAX_MSB		0xF042003F
+
+/* CONSTMU_MAX_LSB */
+#define	R367_OFDM_CONSTMU_MAX_LSB		0xF043
+#define	F367_OFDM_CONST_MU_MAX_LSB		0xF04300FF
+
+/* ALPHANOISE */
+#define	R367_OFDM_ALPHANOISE		0xF044
+#define	F367_OFDM_USE_ALLFILTER		0xF0440080
+#define	F367_OFDM_INTER_ON		0xF0440040
+#define	F367_OFDM_ALPHA_NOISE		0xF044001F
+
+/* MAXGP_MSB */
+#define	R367_OFDM_MAXGP_MSB		0xF045
+#define	F367_OFDM_MUFILTER_LENGTH		0xF04500F0
+#define	F367_OFDM_MAX_GP_MSB		0xF045000F
+
+/* MAXGP_LSB */
+#define	R367_OFDM_MAXGP_LSB		0xF046
+#define	F367_OFDM_MAX_GP_LSB		0xF04600FF
+
+/* ALPHAMSB */
+#define	R367_OFDM_ALPHAMSB		0xF047
+#define	F367_OFDM_CHC_DATARATE		0xF04700C0
+#define	F367_OFDM_ALPHA_MSB		0xF047003F
+
+/* ALPHALSB */
+#define	R367_OFDM_ALPHALSB		0xF048
+#define	F367_OFDM_ALPHA_LSB		0xF04800FF
+
+/* PILOT_ACCU */
+#define	R367_OFDM_PILOT_ACCU		0xF049
+#define	F367_OFDM_USE_SCAT4ADDAPT		0xF0490080
+#define	F367_OFDM_PILOT_ACC		0xF049001F
+
+/* PILOTMU_ACCU */
+#define	R367_OFDM_PILOTMU_ACCU		0xF04A
+#define	F367_OFDM_DISCARD_BAD_SP		0xF04A0080
+#define	F367_OFDM_DISCARD_BAD_CP		0xF04A0040
+#define	F367_OFDM_PILOT_MU_ACCU		0xF04A001F
+
+/* FILT_CHANNEL_EST */
+#define	R367_OFDM_FILT_CHANNEL_EST		0xF04B
+#define	F367_OFDM_USE_FILT_PILOT		0xF04B0080
+#define	F367_OFDM_FILT_CHANNEL		0xF04B007F
+
+/* ALPHA_NOPISE_FREQ */
+#define	R367_OFDM_ALPHA_NOPISE_FREQ		0xF04C
+#define	F367_OFDM_NOISE_FREQ_FILT		0xF04C0040
+#define	F367_OFDM_ALPHA_NOISE_FREQ		0xF04C003F
+
+/* RATIO_PILOT */
+#define	R367_OFDM_RATIO_PILOT		0xF04D
+#define	F367_OFDM_RATIO_MEAN_SP		0xF04D00F0
+#define	F367_OFDM_RATIO_MEAN_CP		0xF04D000F
+
+/* CHC_CTL */
+#define	R367_OFDM_CHC_CTL		0xF04E
+#define	F367_OFDM_TRACK_EN		0xF04E0080
+#define	F367_OFDM_NOISE_NORM_EN		0xF04E0040
+#define	F367_OFDM_FORCE_CHC_RESET		0xF04E0020
+#define	F367_OFDM_SHORT_TIME		0xF04E0010
+#define	F367_OFDM_FORCE_STATE_EN		0xF04E0008
+#define	F367_OFDM_FORCE_STATE		0xF04E0007
+
+/* EPQ_ADJUST */
+#define	R367_OFDM_EPQ_ADJUST		0xF04F
+#define	F367_OFDM_ADJUST_SCAT_IND		0xF04F00C0
+#define	F367_OFDM_ONE_SYMBOL		0xF04F0010
+#define	F367_OFDM_EPQ_DECAY		0xF04F000E
+#define	F367_OFDM_HOLD_SLOPE		0xF04F0001
+
+/* EPQ_THRES */
+#define	R367_OFDM_EPQ_THRES		0xF050
+#define	F367_OFDM_EPQ_THR		0xF05000FF
+
+/* OMEGA_CTL */
+#define	R367_OFDM_OMEGA_CTL		0xF051
+#define	F367_OFDM_OMEGA_RST		0xF0510080
+#define	F367_OFDM_FREEZE_OMEGA		0xF0510040
+#define	F367_OFDM_OMEGA_SEL		0xF051003F
+
+/* GP_CTL */
+#define	R367_OFDM_GP_CTL		0xF052
+#define	F367_OFDM_CHC_STATE		0xF05200E0
+#define	F367_OFDM_FREEZE_GP		0xF0520010
+#define	F367_OFDM_GP_SEL		0xF052000F
+
+/* MUMSB */
+#define	R367_OFDM_MUMSB		0xF053
+#define	F367_OFDM_MU_MSB		0xF053007F
+
+/* MULSB */
+#define	R367_OFDM_MULSB		0xF054
+#define	F367_OFDM_MU_LSB		0xF05400FF
+
+/* GPMSB */
+#define	R367_OFDM_GPMSB		0xF055
+#define	F367_OFDM_CSI_THRESHOLD		0xF05500E0
+#define	F367_OFDM_GP_MSB		0xF055000F
+
+/* GPLSB */
+#define	R367_OFDM_GPLSB		0xF056
+#define	F367_OFDM_GP_LSB		0xF05600FF
+
+/* OMEGAMSB */
+#define	R367_OFDM_OMEGAMSB		0xF057
+#define	F367_OFDM_OMEGA_MSB		0xF057007F
+
+/* OMEGALSB */
+#define	R367_OFDM_OMEGALSB		0xF058
+#define	F367_OFDM_OMEGA_LSB		0xF05800FF
+
+/* SCAT_NB */
+#define	R367_OFDM_SCAT_NB		0xF059
+#define	F367_OFDM_CHC_TEST		0xF05900F8
+#define	F367_OFDM_SCAT_NUMB		0xF0590003
+
+/* CHC_DUMMY */
+#define	R367_OFDM_CHC_DUMMY		0xF05A
+#define	F367_OFDM_CHC_DUM		0xF05A00FF
+
+/* INC_CTL */
+#define	R367_OFDM_INC_CTL		0xF05B
+#define	F367_OFDM_INC_BYPASS		0xF05B0080
+#define	F367_OFDM_INC_NDEPTH		0xF05B000C
+#define	F367_OFDM_INC_MADEPTH		0xF05B0003
+
+/* INCTHRES_COR1 */
+#define	R367_OFDM_INCTHRES_COR1		0xF05C
+#define	F367_OFDM_INC_THRES_COR1		0xF05C00FF
+
+/* INCTHRES_COR2 */
+#define	R367_OFDM_INCTHRES_COR2		0xF05D
+#define	F367_OFDM_INC_THRES_COR2		0xF05D00FF
+
+/* INCTHRES_DET1 */
+#define	R367_OFDM_INCTHRES_DET1		0xF05E
+#define	F367_OFDM_INC_THRES_DET1		0xF05E003F
+
+/* INCTHRES_DET2 */
+#define	R367_OFDM_INCTHRES_DET2		0xF05F
+#define	F367_OFDM_INC_THRES_DET2		0xF05F003F
+
+/* IIR_CELLNB */
+#define	R367_OFDM_IIR_CELLNB		0xF060
+#define	F367_OFDM_NRST_IIR		0xF0600080
+#define	F367_OFDM_IIR_CELL_NB		0xF0600007
+
+/* IIRCX_COEFF1_MSB */
+#define	R367_OFDM_IIRCX_COEFF1_MSB		0xF061
+#define	F367_OFDM_IIR_CX_COEFF1_MSB		0xF06100FF
+
+/* IIRCX_COEFF1_LSB */
+#define	R367_OFDM_IIRCX_COEFF1_LSB		0xF062
+#define	F367_OFDM_IIR_CX_COEFF1_LSB		0xF06200FF
+
+/* IIRCX_COEFF2_MSB */
+#define	R367_OFDM_IIRCX_COEFF2_MSB		0xF063
+#define	F367_OFDM_IIR_CX_COEFF2_MSB		0xF06300FF
+
+/* IIRCX_COEFF2_LSB */
+#define	R367_OFDM_IIRCX_COEFF2_LSB		0xF064
+#define	F367_OFDM_IIR_CX_COEFF2_LSB		0xF06400FF
+
+/* IIRCX_COEFF3_MSB */
+#define	R367_OFDM_IIRCX_COEFF3_MSB		0xF065
+#define	F367_OFDM_IIR_CX_COEFF3_MSB		0xF06500FF
+
+/* IIRCX_COEFF3_LSB */
+#define	R367_OFDM_IIRCX_COEFF3_LSB		0xF066
+#define	F367_OFDM_IIR_CX_COEFF3_LSB		0xF06600FF
+
+/* IIRCX_COEFF4_MSB */
+#define	R367_OFDM_IIRCX_COEFF4_MSB		0xF067
+#define	F367_OFDM_IIR_CX_COEFF4_MSB		0xF06700FF
+
+/* IIRCX_COEFF4_LSB */
+#define	R367_OFDM_IIRCX_COEFF4_LSB		0xF068
+#define	F367_OFDM_IIR_CX_COEFF4_LSB		0xF06800FF
+
+/* IIRCX_COEFF5_MSB */
+#define	R367_OFDM_IIRCX_COEFF5_MSB		0xF069
+#define	F367_OFDM_IIR_CX_COEFF5_MSB		0xF06900FF
+
+/* IIRCX_COEFF5_LSB */
+#define	R367_OFDM_IIRCX_COEFF5_LSB		0xF06A
+#define	F367_OFDM_IIR_CX_COEFF5_LSB		0xF06A00FF
+
+/* FEPATH_CFG */
+#define	R367_OFDM_FEPATH_CFG		0xF06B
+#define	F367_OFDM_DEMUX_SWAP		0xF06B0004
+#define	F367_OFDM_DIGAGC_SWAP		0xF06B0002
+#define	F367_OFDM_LONGPATH_IF		0xF06B0001
+
+/* PMC1_FUNC */
+#define	R367_OFDM_PMC1_FUNC		0xF06C
+#define	F367_OFDM_SOFT_RSTN		0xF06C0080
+#define	F367_OFDM_PMC1_AVERAGE_TIME		0xF06C0078
+#define	F367_OFDM_PMC1_WAIT_TIME		0xF06C0006
+#define	F367_OFDM_PMC1_2N_SEL		0xF06C0001
+
+/* PMC1_FOR */
+#define	R367_OFDM_PMC1_FOR		0xF06D
+#define	F367_OFDM_PMC1_FORCE		0xF06D0080
+#define	F367_OFDM_PMC1_FORCE_VALUE		0xF06D007C
+
+/* PMC2_FUNC */
+#define	R367_OFDM_PMC2_FUNC		0xF06E
+#define	F367_OFDM_PMC2_SOFT_STN		0xF06E0080
+#define	F367_OFDM_PMC2_ACCU_TIME		0xF06E0070
+#define	F367_OFDM_PMC2_CMDP_MN		0xF06E0008
+#define	F367_OFDM_PMC2_SWAP		0xF06E0004
+
+/* STATUS_ERR_DA */
+#define	R367_OFDM_STATUS_ERR_DA		0xF06F
+#define	F367_OFDM_COM_USEGAINTRK		0xF06F0080
+#define	F367_OFDM_COM_AGCLOCK		0xF06F0040
+#define	F367_OFDM_AUT_AGCLOCK		0xF06F0020
+#define	F367_OFDM_MIN_ERR_X_LSB		0xF06F000F
+
+/* DIG_AGC_R */
+#define	R367_OFDM_DIG_AGC_R		0xF070
+#define	F367_OFDM_COM_SOFT_RSTN		0xF0700080
+#define	F367_OFDM_COM_AGC_ON		0xF0700040
+#define	F367_OFDM_COM_EARLY		0xF0700020
+#define	F367_OFDM_AUT_SOFT_RESETN		0xF0700010
+#define	F367_OFDM_AUT_AGC_ON		0xF0700008
+#define	F367_OFDM_AUT_EARLY		0xF0700004
+#define	F367_OFDM_AUT_ROT_EN		0xF0700002
+#define	F367_OFDM_LOCK_SOFT_RESETN		0xF0700001
+
+/* COMAGC_TARMSB */
+#define	R367_OFDM_COMAGC_TARMSB		0xF071
+#define	F367_OFDM_COM_AGC_TARGET_MSB		0xF07100FF
+
+/* COM_AGC_TAR_ENMODE */
+#define	R367_OFDM_COM_AGC_TAR_ENMODE		0xF072
+#define	F367_OFDM_COM_AGC_TARGET_LSB		0xF07200F0
+#define	F367_OFDM_COM_ENMODE		0xF072000F
+
+/* COM_AGC_CFG */
+#define	R367_OFDM_COM_AGC_CFG		0xF073
+#define	F367_OFDM_COM_N		0xF07300F8
+#define	F367_OFDM_COM_STABMODE		0xF0730006
+#define	F367_OFDM_ERR_SEL		0xF0730001
+
+/* COM_AGC_GAIN1 */
+#define	R367_OFDM_COM_AGC_GAIN1		0xF074
+#define	F367_OFDM_COM_GAIN1ACK		0xF07400F0
+#define	F367_OFDM_COM_GAIN1TRK		0xF074000F
+
+/* AUT_AGC_TARGETMSB */
+#define	R367_OFDM_AUT_AGC_TARGETMSB		0xF075
+#define	F367_OFDM_AUT_AGC_TARGET_MSB		0xF07500FF
+
+/* LOCK_DET_MSB */
+#define	R367_OFDM_LOCK_DET_MSB		0xF076
+#define	F367_OFDM_LOCK_DETECT_MSB		0xF07600FF
+
+/* AGCTAR_LOCK_LSBS */
+#define	R367_OFDM_AGCTAR_LOCK_LSBS		0xF077
+#define	F367_OFDM_AUT_AGC_TARGET_LSB		0xF07700F0
+#define	F367_OFDM_LOCK_DETECT_LSB		0xF077000F
+
+/* AUT_GAIN_EN */
+#define	R367_OFDM_AUT_GAIN_EN		0xF078
+#define	F367_OFDM_AUT_ENMODE		0xF07800F0
+#define	F367_OFDM_AUT_GAIN2		0xF078000F
+
+/* AUT_CFG */
+#define	R367_OFDM_AUT_CFG		0xF079
+#define	F367_OFDM_AUT_N		0xF07900F8
+#define	F367_OFDM_INT_CHOICE		0xF0790006
+#define	F367_OFDM_INT_LOAD		0xF0790001
+
+/* LOCKN */
+#define	R367_OFDM_LOCKN		0xF07A
+#define	F367_OFDM_LOCK_N		0xF07A00F8
+#define	F367_OFDM_SEL_IQNTAR		0xF07A0004
+#define	F367_OFDM_LOCK_DETECT_CHOICE		0xF07A0003
+
+/* INT_X_3 */
+#define	R367_OFDM_INT_X_3		0xF07B
+#define	F367_OFDM_INT_X3		0xF07B00FF
+
+/* INT_X_2 */
+#define	R367_OFDM_INT_X_2		0xF07C
+#define	F367_OFDM_INT_X2		0xF07C00FF
+
+/* INT_X_1 */
+#define	R367_OFDM_INT_X_1		0xF07D
+#define	F367_OFDM_INT_X1		0xF07D00FF
+
+/* INT_X_0 */
+#define	R367_OFDM_INT_X_0		0xF07E
+#define	F367_OFDM_INT_X0		0xF07E00FF
+
+/* MIN_ERRX_MSB */
+#define	R367_OFDM_MIN_ERRX_MSB		0xF07F
+#define	F367_OFDM_MIN_ERR_X_MSB		0xF07F00FF
+
+/* COR_CTL */
+#define	R367_OFDM_COR_CTL		0xF080
+#define	F367_OFDM_CORE_ACTIVE		0xF0800020
+#define	F367_OFDM_HOLD		0xF0800010
+#define	F367_OFDM_CORE_STATE_CTL		0xF080000F
+
+/* COR_STAT */
+#define	R367_OFDM_COR_STAT		0xF081
+#define	F367_OFDM_SCATT_LOCKED		0xF0810080
+#define	F367_OFDM_TPS_LOCKED		0xF0810040
+#define	F367_OFDM_SYR_LOCKED_COR		0xF0810020
+#define	F367_OFDM_AGC_LOCKED_STAT		0xF0810010
+#define	F367_OFDM_CORE_STATE_STAT		0xF081000F
+
+/* COR_INTEN */
+#define	R367_OFDM_COR_INTEN		0xF082
+#define	F367_OFDM_INTEN		0xF0820080
+#define	F367_OFDM_INTEN_SYR		0xF0820020
+#define	F367_OFDM_INTEN_FFT		0xF0820010
+#define	F367_OFDM_INTEN_AGC		0xF0820008
+#define	F367_OFDM_INTEN_TPS1		0xF0820004
+#define	F367_OFDM_INTEN_TPS2		0xF0820002
+#define	F367_OFDM_INTEN_TPS3		0xF0820001
+
+/* COR_INTSTAT */
+#define	R367_OFDM_COR_INTSTAT		0xF083
+#define	F367_OFDM_INTSTAT_SYR		0xF0830020
+#define	F367_OFDM_INTSTAT_FFT		0xF0830010
+#define	F367_OFDM_INTSAT_AGC		0xF0830008
+#define	F367_OFDM_INTSTAT_TPS1		0xF0830004
+#define	F367_OFDM_INTSTAT_TPS2		0xF0830002
+#define	F367_OFDM_INTSTAT_TPS3		0xF0830001
+
+/* COR_MODEGUARD */
+#define	R367_OFDM_COR_MODEGUARD		0xF084
+#define	F367_OFDM_FORCE		0xF0840010
+#define	F367_OFDM_MODE		0xF084000C
+#define	F367_OFDM_GUARD		0xF0840003
+
+/* AGC_CTL */
+#define	R367_OFDM_AGC_CTL		0xF085
+#define	F367_OFDM_AGC_TIMING_FACTOR		0xF08500E0
+#define	F367_OFDM_AGC_LAST		0xF0850010
+#define	F367_OFDM_AGC_GAIN		0xF085000C
+#define	F367_OFDM_AGC_NEG		0xF0850002
+#define	F367_OFDM_AGC_SET		0xF0850001
+
+/* AGC_MANUAL1 */
+#define	R367_OFDM_AGC_MANUAL1		0xF086
+#define	F367_OFDM_AGC_VAL_LO		0xF08600FF
+
+/* AGC_MANUAL2 */
+#define	R367_OFDM_AGC_MANUAL2		0xF087
+#define	F367_OFDM_AGC_VAL_HI		0xF087000F
+
+/* AGC_TARG */
+#define	R367_OFDM_AGC_TARG		0xF088
+#define	F367_OFDM_AGC_TARGET		0xF08800FF
+
+/* AGC_GAIN1 */
+#define	R367_OFDM_AGC_GAIN1		0xF089
+#define	F367_OFDM_AGC_GAIN_LO		0xF08900FF
+
+/* AGC_GAIN2 */
+#define	R367_OFDM_AGC_GAIN2		0xF08A
+#define	F367_OFDM_AGC_LOCKED_GAIN2		0xF08A0010
+#define	F367_OFDM_AGC_GAIN_HI		0xF08A000F
+
+/* RESERVED_1 */
+#define	R367_OFDM_RESERVED_1		0xF08B
+#define	F367_OFDM_RESERVED1		0xF08B00FF
+
+/* RESERVED_2 */
+#define	R367_OFDM_RESERVED_2		0xF08C
+#define	F367_OFDM_RESERVED2		0xF08C00FF
+
+/* RESERVED_3 */
+#define	R367_OFDM_RESERVED_3		0xF08D
+#define	F367_OFDM_RESERVED3		0xF08D00FF
+
+/* CAS_CTL */
+#define	R367_OFDM_CAS_CTL		0xF08E
+#define	F367_OFDM_CCS_ENABLE		0xF08E0080
+#define	F367_OFDM_ACS_DISABLE		0xF08E0040
+#define	F367_OFDM_DAGC_DIS		0xF08E0020
+#define	F367_OFDM_DAGC_GAIN		0xF08E0018
+#define	F367_OFDM_CCSMU		0xF08E0007
+
+/* CAS_FREQ */
+#define	R367_OFDM_CAS_FREQ		0xF08F
+#define	F367_OFDM_CCS_FREQ		0xF08F00FF
+
+/* CAS_DAGCGAIN */
+#define	R367_OFDM_CAS_DAGCGAIN		0xF090
+#define	F367_OFDM_CAS_DAGC_GAIN		0xF09000FF
+
+/* SYR_CTL */
+#define	R367_OFDM_SYR_CTL		0xF091
+#define	F367_OFDM_SICTH_ENABLE		0xF0910080
+#define	F367_OFDM_LONG_ECHO		0xF0910078
+#define	F367_OFDM_AUTO_LE_EN		0xF0910004
+#define	F367_OFDM_SYR_BYPASS		0xF0910002
+#define	F367_OFDM_SYR_TR_DIS		0xF0910001
+
+/* SYR_STAT */
+#define	R367_OFDM_SYR_STAT		0xF092
+#define	F367_OFDM_SYR_LOCKED_STAT		0xF0920010
+#define	F367_OFDM_SYR_MODE		0xF092000C
+#define	F367_OFDM_SYR_GUARD		0xF0920003
+
+/* SYR_NCO1 */
+#define	R367_OFDM_SYR_NCO1		0xF093
+#define	F367_OFDM_SYR_NCO_LO		0xF09300FF
+
+/* SYR_NCO2 */
+#define	R367_OFDM_SYR_NCO2		0xF094
+#define	F367_OFDM_SYR_NCO_HI		0xF094003F
+
+/* SYR_OFFSET1 */
+#define	R367_OFDM_SYR_OFFSET1		0xF095
+#define	F367_OFDM_SYR_OFFSET_LO		0xF09500FF
+
+/* SYR_OFFSET2 */
+#define	R367_OFDM_SYR_OFFSET2		0xF096
+#define	F367_OFDM_SYR_OFFSET_HI		0xF096003F
+
+/* FFT_CTL */
+#define	R367_OFDM_FFT_CTL		0xF097
+#define	F367_OFDM_SHIFT_FFT_TRIG		0xF0970018
+#define	F367_OFDM_FFT_TRIGGER		0xF0970004
+#define	F367_OFDM_FFT_MANUAL		0xF0970002
+#define	F367_OFDM_IFFT_MODE		0xF0970001
+
+/* SCR_CTL */
+#define	R367_OFDM_SCR_CTL		0xF098
+#define	F367_OFDM_SYRADJDECAY		0xF0980070
+#define	F367_OFDM_SCR_CPEDIS		0xF0980002
+#define	F367_OFDM_SCR_DIS		0xF0980001
+
+/* PPM_CTL1 */
+#define	R367_OFDM_PPM_CTL1		0xF099
+#define	F367_OFDM_PPM_MAXFREQ		0xF0990030
+#define	F367_OFDM_PPM_MAXTIM		0xF0990008
+#define	F367_OFDM_PPM_INVSEL		0xF0990004
+#define	F367_OFDM_PPM_SCATDIS		0xF0990002
+#define	F367_OFDM_PPM_BYP		0xF0990001
+
+/* TRL_CTL */
+#define	R367_OFDM_TRL_CTL		0xF09A
+#define	F367_OFDM_TRL_NOMRATE_LSB		0xF09A0080
+#define	F367_OFDM_TRL_GAIN_FACTOR		0xF09A0078
+#define	F367_OFDM_TRL_LOOPGAIN		0xF09A0007
+
+/* TRL_NOMRATE1 */
+#define	R367_OFDM_TRL_NOMRATE1		0xF09B
+#define	F367_OFDM_TRL_NOMRATE_LO		0xF09B00FF
+
+/* TRL_NOMRATE2 */
+#define	R367_OFDM_TRL_NOMRATE2		0xF09C
+#define	F367_OFDM_TRL_NOMRATE_HI		0xF09C00FF
+
+/* TRL_TIME1 */
+#define	R367_OFDM_TRL_TIME1		0xF09D
+#define	F367_OFDM_TRL_TOFFSET_LO		0xF09D00FF
+
+/* TRL_TIME2 */
+#define	R367_OFDM_TRL_TIME2		0xF09E
+#define	F367_OFDM_TRL_TOFFSET_HI		0xF09E00FF
+
+/* CRL_CTL */
+#define	R367_OFDM_CRL_CTL		0xF09F
+#define	F367_OFDM_CRL_DIS		0xF09F0080
+#define	F367_OFDM_CRL_GAIN_FACTOR		0xF09F0078
+#define	F367_OFDM_CRL_LOOPGAIN		0xF09F0007
+
+/* CRL_FREQ1 */
+#define	R367_OFDM_CRL_FREQ1		0xF0A0
+#define	F367_OFDM_CRL_FOFFSET_LO		0xF0A000FF
+
+/* CRL_FREQ2 */
+#define	R367_OFDM_CRL_FREQ2		0xF0A1
+#define	F367_OFDM_CRL_FOFFSET_HI		0xF0A100FF
+
+/* CRL_FREQ3 */
+#define	R367_OFDM_CRL_FREQ3		0xF0A2
+#define	F367_OFDM_CRL_FOFFSET_VHI		0xF0A200FF
+
+/* TPS_SFRAME_CTL */
+#define	R367_OFDM_TPS_SFRAME_CTL		0xF0A3
+#define	F367_OFDM_TPS_SFRAME_SYNC		0xF0A30001
+
+/* CHC_SNR */
+#define	R367_OFDM_CHC_SNR		0xF0A4
+#define	F367_OFDM_CHCSNR		0xF0A400FF
+
+/* BDI_CTL */
+#define	R367_OFDM_BDI_CTL		0xF0A5
+#define	F367_OFDM_BDI_LPSEL		0xF0A50002
+#define	F367_OFDM_BDI_SERIAL		0xF0A50001
+
+/* DMP_CTL */
+#define	R367_OFDM_DMP_CTL		0xF0A6
+#define	F367_OFDM_DMP_SCALING_FACTOR		0xF0A6001E
+#define	F367_OFDM_DMP_SDDIS		0xF0A60001
+
+/* TPS_RCVD1 */
+#define	R367_OFDM_TPS_RCVD1		0xF0A7
+#define	F367_OFDM_TPS_CHANGE		0xF0A70040
+#define	F367_OFDM_BCH_OK		0xF0A70020
+#define	F367_OFDM_TPS_SYNC		0xF0A70010
+#define	F367_OFDM_TPS_FRAME		0xF0A70003
+
+/* TPS_RCVD2 */
+#define	R367_OFDM_TPS_RCVD2		0xF0A8
+#define	F367_OFDM_TPS_HIERMODE		0xF0A80070
+#define	F367_OFDM_TPS_CONST		0xF0A80003
+
+/* TPS_RCVD3 */
+#define	R367_OFDM_TPS_RCVD3		0xF0A9
+#define	F367_OFDM_TPS_LPCODE		0xF0A90070
+#define	F367_OFDM_TPS_HPCODE		0xF0A90007
+
+/* TPS_RCVD4 */
+#define	R367_OFDM_TPS_RCVD4		0xF0AA
+#define	F367_OFDM_TPS_GUARD		0xF0AA0030
+#define	F367_OFDM_TPS_MODE		0xF0AA0003
+
+/* TPS_ID_CELL1 */
+#define	R367_OFDM_TPS_ID_CELL1		0xF0AB
+#define	F367_OFDM_TPS_ID_CELL_LO		0xF0AB00FF
+
+/* TPS_ID_CELL2 */
+#define	R367_OFDM_TPS_ID_CELL2		0xF0AC
+#define	F367_OFDM_TPS_ID_CELL_HI		0xF0AC00FF
+
+/* TPS_RCVD5_SET1 */
+#define	R367_OFDM_TPS_RCVD5_SET1		0xF0AD
+#define	F367_OFDM_TPS_NA		0xF0AD00FC
+#define	F367_OFDM_TPS_SETFRAME		0xF0AD0003
+
+/* TPS_SET2 */
+#define	R367_OFDM_TPS_SET2		0xF0AE
+#define	F367_OFDM_TPS_SETHIERMODE		0xF0AE0070
+#define	F367_OFDM_TPS_SETCONST		0xF0AE0003
+
+/* TPS_SET3 */
+#define	R367_OFDM_TPS_SET3		0xF0AF
+#define	F367_OFDM_TPS_SETLPCODE		0xF0AF0070
+#define	F367_OFDM_TPS_SETHPCODE		0xF0AF0007
+
+/* TPS_CTL */
+#define	R367_OFDM_TPS_CTL		0xF0B0
+#define	F367_OFDM_TPS_IMM		0xF0B00004
+#define	F367_OFDM_TPS_BCHDIS		0xF0B00002
+#define	F367_OFDM_TPS_UPDDIS		0xF0B00001
+
+/* CTL_FFTOSNUM */
+#define	R367_OFDM_CTL_FFTOSNUM		0xF0B1
+#define	F367_OFDM_SYMBOL_NUMBER		0xF0B1007F
+
+/* TESTSELECT */
+#define	R367_OFDM_TESTSELECT		0xF0B2
+#define	F367_OFDM_TEST_SELECT		0xF0B2001F
+
+/* MSC_REV */
+#define	R367_OFDM_MSC_REV		0xF0B3
+#define	F367_OFDM_REV_NUMBER		0xF0B300FF
+
+/* PIR_CTL */
+#define	R367_OFDM_PIR_CTL		0xF0B4
+#define	F367_OFDM_FREEZE		0xF0B40001
+
+/* SNR_CARRIER1 */
+#define	R367_OFDM_SNR_CARRIER1		0xF0B5
+#define	F367_OFDM_SNR_CARRIER_LO		0xF0B500FF
+
+/* SNR_CARRIER2 */
+#define	R367_OFDM_SNR_CARRIER2		0xF0B6
+#define	F367_OFDM_MEAN		0xF0B600C0
+#define	F367_OFDM_SNR_CARRIER_HI		0xF0B6001F
+
+/* PPM_CPAMP */
+#define	R367_OFDM_PPM_CPAMP		0xF0B7
+#define	F367_OFDM_PPM_CPC		0xF0B700FF
+
+/* TSM_AP0 */
+#define	R367_OFDM_TSM_AP0		0xF0B8
+#define	F367_OFDM_ADDRESS_BYTE_0		0xF0B800FF
+
+/* TSM_AP1 */
+#define	R367_OFDM_TSM_AP1		0xF0B9
+#define	F367_OFDM_ADDRESS_BYTE_1		0xF0B900FF
+
+/* TSM_AP2 */
+#define	R367_OFDM_TSM_AP2		0xF0BA
+#define	F367_OFDM_DATA_BYTE_0		0xF0BA00FF
+
+/* TSM_AP3 */
+#define	R367_OFDM_TSM_AP3		0xF0BB
+#define	F367_OFDM_DATA_BYTE_1		0xF0BB00FF
+
+/* TSM_AP4 */
+#define	R367_OFDM_TSM_AP4		0xF0BC
+#define	F367_OFDM_DATA_BYTE_2		0xF0BC00FF
+
+/* TSM_AP5 */
+#define	R367_OFDM_TSM_AP5		0xF0BD
+#define	F367_OFDM_DATA_BYTE_3		0xF0BD00FF
+
+/* TSM_AP6 */
+#define	R367_OFDM_TSM_AP6		0xF0BE
+#define	F367_OFDM_TSM_AP_6		0xF0BE00FF
+
+/* TSM_AP7 */
+#define	R367_OFDM_TSM_AP7		0xF0BF
+#define	F367_OFDM_MEM_SELECT_BYTE		0xF0BF00FF
+
+/* TSTRES */
+#define	R367_TSTRES		0xF0C0
+#define	F367_FRES_DISPLAY		0xF0C00080
+#define	F367_FRES_FIFO_AD		0xF0C00020
+#define	F367_FRESRS		0xF0C00010
+#define	F367_FRESACS		0xF0C00008
+#define	F367_FRESFEC		0xF0C00004
+#define	F367_FRES_PRIF		0xF0C00002
+#define	F367_FRESCORE		0xF0C00001
+
+/* ANACTRL */
+#define	R367_ANACTRL		0xF0C1
+#define	F367_BYPASS_XTAL		0xF0C10040
+#define	F367_BYPASS_PLLXN		0xF0C1000C
+#define	F367_DIS_PAD_OSC		0xF0C10002
+#define	F367_STDBY_PLLXN		0xF0C10001
+
+/* TSTBUS */
+#define	R367_TSTBUS		0xF0C2
+#define	F367_TS_BYTE_CLK_INV		0xF0C20080
+#define	F367_CFG_IP		0xF0C20070
+#define	F367_CFG_TST		0xF0C2000F
+
+/* TSTRATE */
+#define	R367_TSTRATE		0xF0C6
+#define	F367_FORCEPHA		0xF0C60080
+#define	F367_FNEWPHA		0xF0C60010
+#define	F367_FROT90		0xF0C60008
+#define	F367_FR		0xF0C60007
+
+/* CONSTMODE */
+#define	R367_OFDM_CONSTMODE		0xF0CB
+#define	F367_OFDM_TST_PRIF		0xF0CB00E0
+#define	F367_OFDM_CAR_TYPE		0xF0CB0018
+#define	F367_OFDM_CONST_MODE		0xF0CB0003
+
+/* CONSTCARR1 */
+#define	R367_OFDM_CONSTCARR1		0xF0CC
+#define	F367_OFDM_CONST_CARR_LO		0xF0CC00FF
+
+/* CONSTCARR2 */
+#define	R367_OFDM_CONSTCARR2		0xF0CD
+#define	F367_OFDM_CONST_CARR_HI		0xF0CD001F
+
+/* ICONSTEL */
+#define	R367_OFDM_ICONSTEL		0xF0CE
+#define	F367_OFDM_PICONSTEL		0xF0CE00FF
+
+/* QCONSTEL */
+#define	R367_OFDM_QCONSTEL		0xF0CF
+#define	F367_OFDM_PQCONSTEL		0xF0CF00FF
+
+/* TSTBISTRES0 */
+#define	R367_OFDM_TSTBISTRES0		0xF0D0
+#define	F367_OFDM_BEND_PPM		0xF0D00080
+#define	F367_OFDM_BBAD_PPM		0xF0D00040
+#define	F367_OFDM_BEND_FFTW		0xF0D00020
+#define	F367_OFDM_BBAD_FFTW		0xF0D00010
+#define	F367_OFDM_BEND_FFT_BUF		0xF0D00008
+#define	F367_OFDM_BBAD_FFT_BUF		0xF0D00004
+#define	F367_OFDM_BEND_SYR		0xF0D00002
+#define	F367_OFDM_BBAD_SYR		0xF0D00001
+
+/* TSTBISTRES1 */
+#define	R367_OFDM_TSTBISTRES1		0xF0D1
+#define	F367_OFDM_BEND_CHC_CP		0xF0D10080
+#define	F367_OFDM_BBAD_CHC_CP		0xF0D10040
+#define	F367_OFDM_BEND_CHCI		0xF0D10020
+#define	F367_OFDM_BBAD_CHCI		0xF0D10010
+#define	F367_OFDM_BEND_BDI		0xF0D10008
+#define	F367_OFDM_BBAD_BDI		0xF0D10004
+#define	F367_OFDM_BEND_SDI		0xF0D10002
+#define	F367_OFDM_BBAD_SDI		0xF0D10001
+
+/* TSTBISTRES2 */
+#define	R367_OFDM_TSTBISTRES2		0xF0D2
+#define	F367_OFDM_BEND_CHC_INC		0xF0D20080
+#define	F367_OFDM_BBAD_CHC_INC		0xF0D20040
+#define	F367_OFDM_BEND_CHC_SPP		0xF0D20020
+#define	F367_OFDM_BBAD_CHC_SPP		0xF0D20010
+#define	F367_OFDM_BEND_CHC_CPP		0xF0D20008
+#define	F367_OFDM_BBAD_CHC_CPP		0xF0D20004
+#define	F367_OFDM_BEND_CHC_SP		0xF0D20002
+#define	F367_OFDM_BBAD_CHC_SP		0xF0D20001
+
+/* TSTBISTRES3 */
+#define	R367_OFDM_TSTBISTRES3		0xF0D3
+#define	F367_OFDM_BEND_QAM		0xF0D30080
+#define	F367_OFDM_BBAD_QAM		0xF0D30040
+#define	F367_OFDM_BEND_SFEC_VIT		0xF0D30020
+#define	F367_OFDM_BBAD_SFEC_VIT		0xF0D30010
+#define	F367_OFDM_BEND_SFEC_DLINE		0xF0D30008
+#define	F367_OFDM_BBAD_SFEC_DLINE		0xF0D30004
+#define	F367_OFDM_BEND_SFEC_HW		0xF0D30002
+#define	F367_OFDM_BBAD_SFEC_HW		0xF0D30001
+
+/* RF_AGC1 */
+#define	R367_RF_AGC1		0xF0D4
+#define	F367_RF_AGC1_LEVEL_HI		0xF0D400FF
+
+/* RF_AGC2 */
+#define	R367_RF_AGC2		0xF0D5
+#define	F367_REF_ADGP		0xF0D50080
+#define	F367_STDBY_ADCGP		0xF0D50020
+#define	F367_CHANNEL_SEL		0xF0D5001C
+#define	F367_RF_AGC1_LEVEL_LO		0xF0D50003
+
+/* ANADIGCTRL */
+#define	R367_ANADIGCTRL		0xF0D7
+#define	F367_SEL_CLKDEM		0xF0D70020
+#define	F367_EN_BUFFER_Q		0xF0D70010
+#define	F367_EN_BUFFER_I		0xF0D70008
+#define	F367_ADC_RIS_EGDE		0xF0D70004
+#define	F367_SGN_ADC		0xF0D70002
+#define	F367_SEL_AD12_SYNC		0xF0D70001
+
+/* PLLMDIV */
+#define	R367_PLLMDIV		0xF0D8
+#define	F367_PLL_MDIV		0xF0D800FF
+
+/* PLLNDIV */
+#define	R367_PLLNDIV		0xF0D9
+#define	F367_PLL_NDIV		0xF0D900FF
+
+/* PLLSETUP */
+#define	R367_PLLSETUP		0xF0DA
+#define	F367_PLL_PDIV		0xF0DA0070
+#define	F367_PLL_KDIV		0xF0DA000F
+
+/* DUAL_AD12 */
+#define	R367_DUAL_AD12		0xF0DB
+#define	F367_FS20M		0xF0DB0020
+#define	F367_FS50M		0xF0DB0010
+#define	F367_INMODE0		0xF0DB0008
+#define	F367_POFFQ		0xF0DB0004
+#define	F367_POFFI		0xF0DB0002
+#define	F367_INMODE1		0xF0DB0001
+
+/* TSTBIST */
+#define	R367_TSTBIST		0xF0DC
+#define	F367_TST_BYP_CLK		0xF0DC0080
+#define	F367_TST_GCLKENA_STD		0xF0DC0040
+#define	F367_TST_GCLKENA		0xF0DC0020
+#define	F367_TST_MEMBIST		0xF0DC001F
+
+/* PAD_COMP_CTRL */
+#define	R367_PAD_COMP_CTRL		0xF0DD
+#define	F367_COMPTQ		0xF0DD0010
+#define	F367_COMPEN		0xF0DD0008
+#define	F367_FREEZE2		0xF0DD0004
+#define	F367_SLEEP_INHBT		0xF0DD0002
+#define	F367_CHIP_SLEEP		0xF0DD0001
+
+/* PAD_COMP_WR */
+#define	R367_PAD_COMP_WR		0xF0DE
+#define	F367_WR_ASRC		0xF0DE007F
+
+/* PAD_COMP_RD */
+#define	R367_PAD_COMP_RD		0xF0DF
+#define	F367_COMPOK		0xF0DF0080
+#define	F367_RD_ASRC		0xF0DF007F
+
+/* SYR_TARGET_FFTADJT_MSB */
+#define	R367_OFDM_SYR_TARGET_FFTADJT_MSB		0xF100
+#define	F367_OFDM_SYR_START		0xF1000080
+#define	F367_OFDM_SYR_TARGET_FFTADJ_HI		0xF100000F
+
+/* SYR_TARGET_FFTADJT_LSB */
+#define	R367_OFDM_SYR_TARGET_FFTADJT_LSB		0xF101
+#define	F367_OFDM_SYR_TARGET_FFTADJ_LO		0xF10100FF
+
+/* SYR_TARGET_CHCADJT_MSB */
+#define	R367_OFDM_SYR_TARGET_CHCADJT_MSB		0xF102
+#define	F367_OFDM_SYR_TARGET_CHCADJ_HI		0xF102000F
+
+/* SYR_TARGET_CHCADJT_LSB */
+#define	R367_OFDM_SYR_TARGET_CHCADJT_LSB		0xF103
+#define	F367_OFDM_SYR_TARGET_CHCADJ_LO		0xF10300FF
+
+/* SYR_FLAG */
+#define	R367_OFDM_SYR_FLAG		0xF104
+#define	F367_OFDM_TRIG_FLG1		0xF1040080
+#define	F367_OFDM_TRIG_FLG0		0xF1040040
+#define	F367_OFDM_FFT_FLG1		0xF1040008
+#define	F367_OFDM_FFT_FLG0		0xF1040004
+#define	F367_OFDM_CHC_FLG1		0xF1040002
+#define	F367_OFDM_CHC_FLG0		0xF1040001
+
+/* CRL_TARGET1 */
+#define	R367_OFDM_CRL_TARGET1		0xF105
+#define	F367_OFDM_CRL_START		0xF1050080
+#define	F367_OFDM_CRL_TARGET_VHI		0xF105000F
+
+/* CRL_TARGET2 */
+#define	R367_OFDM_CRL_TARGET2		0xF106
+#define	F367_OFDM_CRL_TARGET_HI		0xF10600FF
+
+/* CRL_TARGET3 */
+#define	R367_OFDM_CRL_TARGET3		0xF107
+#define	F367_OFDM_CRL_TARGET_LO		0xF10700FF
+
+/* CRL_TARGET4 */
+#define	R367_OFDM_CRL_TARGET4		0xF108
+#define	F367_OFDM_CRL_TARGET_VLO		0xF10800FF
+
+/* CRL_FLAG */
+#define	R367_OFDM_CRL_FLAG		0xF109
+#define	F367_OFDM_CRL_FLAG1		0xF1090002
+#define	F367_OFDM_CRL_FLAG0		0xF1090001
+
+/* TRL_TARGET1 */
+#define	R367_OFDM_TRL_TARGET1		0xF10A
+#define	F367_OFDM_TRL_TARGET_HI		0xF10A00FF
+
+/* TRL_TARGET2 */
+#define	R367_OFDM_TRL_TARGET2		0xF10B
+#define	F367_OFDM_TRL_TARGET_LO		0xF10B00FF
+
+/* TRL_CHC */
+#define	R367_OFDM_TRL_CHC		0xF10C
+#define	F367_OFDM_TRL_START		0xF10C0080
+#define	F367_OFDM_CHC_START		0xF10C0040
+#define	F367_OFDM_TRL_FLAG1		0xF10C0002
+#define	F367_OFDM_TRL_FLAG0		0xF10C0001
+
+/* CHC_SNR_TARG */
+#define	R367_OFDM_CHC_SNR_TARG		0xF10D
+#define	F367_OFDM_CHC_SNR_TARGET		0xF10D00FF
+
+/* TOP_TRACK */
+#define	R367_OFDM_TOP_TRACK		0xF10E
+#define	F367_OFDM_TOP_START		0xF10E0080
+#define	F367_OFDM_FIRST_FLAG		0xF10E0070
+#define	F367_OFDM_TOP_FLAG1		0xF10E0008
+#define	F367_OFDM_TOP_FLAG0		0xF10E0004
+#define	F367_OFDM_CHC_FLAG1		0xF10E0002
+#define	F367_OFDM_CHC_FLAG0		0xF10E0001
+
+/* TRACKER_FREE1 */
+#define	R367_OFDM_TRACKER_FREE1		0xF10F
+#define	F367_OFDM_TRACKER_FREE_1		0xF10F00FF
+
+/* ERROR_CRL1 */
+#define	R367_OFDM_ERROR_CRL1		0xF110
+#define	F367_OFDM_ERROR_CRL_VHI		0xF11000FF
+
+/* ERROR_CRL2 */
+#define	R367_OFDM_ERROR_CRL2		0xF111
+#define	F367_OFDM_ERROR_CRL_HI		0xF11100FF
+
+/* ERROR_CRL3 */
+#define	R367_OFDM_ERROR_CRL3		0xF112
+#define	F367_OFDM_ERROR_CRL_LOI		0xF11200FF
+
+/* ERROR_CRL4 */
+#define	R367_OFDM_ERROR_CRL4		0xF113
+#define	F367_OFDM_ERROR_CRL_VLO		0xF11300FF
+
+/* DEC_NCO1 */
+#define	R367_OFDM_DEC_NCO1		0xF114
+#define	F367_OFDM_DEC_NCO_VHI		0xF11400FF
+
+/* DEC_NCO2 */
+#define	R367_OFDM_DEC_NCO2		0xF115
+#define	F367_OFDM_DEC_NCO_HI		0xF11500FF
+
+/* DEC_NCO3 */
+#define	R367_OFDM_DEC_NCO3		0xF116
+#define	F367_OFDM_DEC_NCO_LO		0xF11600FF
+
+/* SNR */
+#define	R367_OFDM_SNR		0xF117
+#define	F367_OFDM_SNRATIO		0xF11700FF
+
+/* SYR_FFTADJ1 */
+#define	R367_OFDM_SYR_FFTADJ1		0xF118
+#define	F367_OFDM_SYR_FFTADJ_HI		0xF11800FF
+
+/* SYR_FFTADJ2 */
+#define	R367_OFDM_SYR_FFTADJ2		0xF119
+#define	F367_OFDM_SYR_FFTADJ_LO		0xF11900FF
+
+/* SYR_CHCADJ1 */
+#define	R367_OFDM_SYR_CHCADJ1		0xF11A
+#define	F367_OFDM_SYR_CHCADJ_HI		0xF11A00FF
+
+/* SYR_CHCADJ2 */
+#define	R367_OFDM_SYR_CHCADJ2		0xF11B
+#define	F367_OFDM_SYR_CHCADJ_LO		0xF11B00FF
+
+/* SYR_OFF */
+#define	R367_OFDM_SYR_OFF		0xF11C
+#define	F367_OFDM_SYR_OFFSET		0xF11C00FF
+
+/* PPM_OFFSET1 */
+#define	R367_OFDM_PPM_OFFSET1		0xF11D
+#define	F367_OFDM_PPM_OFFSET_HI		0xF11D00FF
+
+/* PPM_OFFSET2 */
+#define	R367_OFDM_PPM_OFFSET2		0xF11E
+#define	F367_OFDM_PPM_OFFSET_LO		0xF11E00FF
+
+/* TRACKER_FREE2 */
+#define	R367_OFDM_TRACKER_FREE2		0xF11F
+#define	F367_OFDM_TRACKER_FREE_2		0xF11F00FF
+
+/* DEBG_LT10 */
+#define	R367_OFDM_DEBG_LT10		0xF120
+#define	F367_OFDM_DEBUG_LT10		0xF12000FF
+
+/* DEBG_LT11 */
+#define	R367_OFDM_DEBG_LT11		0xF121
+#define	F367_OFDM_DEBUG_LT11		0xF12100FF
+
+/* DEBG_LT12 */
+#define	R367_OFDM_DEBG_LT12		0xF122
+#define	F367_OFDM_DEBUG_LT12		0xF12200FF
+
+/* DEBG_LT13 */
+#define	R367_OFDM_DEBG_LT13		0xF123
+#define	F367_OFDM_DEBUG_LT13		0xF12300FF
+
+/* DEBG_LT14 */
+#define	R367_OFDM_DEBG_LT14		0xF124
+#define	F367_OFDM_DEBUG_LT14		0xF12400FF
+
+/* DEBG_LT15 */
+#define	R367_OFDM_DEBG_LT15		0xF125
+#define	F367_OFDM_DEBUG_LT15		0xF12500FF
+
+/* DEBG_LT16 */
+#define	R367_OFDM_DEBG_LT16		0xF126
+#define	F367_OFDM_DEBUG_LT16		0xF12600FF
+
+/* DEBG_LT17 */
+#define	R367_OFDM_DEBG_LT17		0xF127
+#define	F367_OFDM_DEBUG_LT17		0xF12700FF
+
+/* DEBG_LT18 */
+#define	R367_OFDM_DEBG_LT18		0xF128
+#define	F367_OFDM_DEBUG_LT18		0xF12800FF
+
+/* DEBG_LT19 */
+#define	R367_OFDM_DEBG_LT19		0xF129
+#define	F367_OFDM_DEBUG_LT19		0xF12900FF
+
+/* DEBG_LT1A */
+#define	R367_OFDM_DEBG_LT1A		0xF12A
+#define	F367_OFDM_DEBUG_LT1A		0xF12A00FF
+
+/* DEBG_LT1B */
+#define	R367_OFDM_DEBG_LT1B		0xF12B
+#define	F367_OFDM_DEBUG_LT1B		0xF12B00FF
+
+/* DEBG_LT1C */
+#define	R367_OFDM_DEBG_LT1C		0xF12C
+#define	F367_OFDM_DEBUG_LT1C		0xF12C00FF
+
+/* DEBG_LT1D */
+#define	R367_OFDM_DEBG_LT1D		0xF12D
+#define	F367_OFDM_DEBUG_LT1D		0xF12D00FF
+
+/* DEBG_LT1E */
+#define	R367_OFDM_DEBG_LT1E		0xF12E
+#define	F367_OFDM_DEBUG_LT1E		0xF12E00FF
+
+/* DEBG_LT1F */
+#define	R367_OFDM_DEBG_LT1F		0xF12F
+#define	F367_OFDM_DEBUG_LT1F		0xF12F00FF
+
+/* RCCFGH */
+#define	R367_OFDM_RCCFGH		0xF200
+#define	F367_OFDM_TSRCFIFO_DVBCI		0xF2000080
+#define	F367_OFDM_TSRCFIFO_SERIAL		0xF2000040
+#define	F367_OFDM_TSRCFIFO_DISABLE		0xF2000020
+#define	F367_OFDM_TSFIFO_2TORC		0xF2000010
+#define	F367_OFDM_TSRCFIFO_HSGNLOUT		0xF2000008
+#define	F367_OFDM_TSRCFIFO_ERRMODE		0xF2000006
+#define	F367_OFDM_RCCFGH_0		0xF2000001
+
+/* RCCFGM */
+#define	R367_OFDM_RCCFGM		0xF201
+#define	F367_OFDM_TSRCFIFO_MANSPEED		0xF20100C0
+#define	F367_OFDM_TSRCFIFO_PERMDATA		0xF2010020
+#define	F367_OFDM_TSRCFIFO_NONEWSGNL		0xF2010010
+#define	F367_OFDM_RCBYTE_OVERSAMPLING		0xF201000E
+#define	F367_OFDM_TSRCFIFO_INVDATA		0xF2010001
+
+/* RCCFGL */
+#define	R367_OFDM_RCCFGL		0xF202
+#define	F367_OFDM_TSRCFIFO_BCLKDEL1CK		0xF20200C0
+#define	F367_OFDM_RCCFGL_5		0xF2020020
+#define	F367_OFDM_TSRCFIFO_DUTY50		0xF2020010
+#define	F367_OFDM_TSRCFIFO_NSGNL2DATA		0xF2020008
+#define	F367_OFDM_TSRCFIFO_DISSERMUX		0xF2020004
+#define	F367_OFDM_RCCFGL_1		0xF2020002
+#define	F367_OFDM_TSRCFIFO_STOPCKDIS		0xF2020001
+
+/* RCINSDELH */
+#define	R367_OFDM_RCINSDELH		0xF203
+#define	F367_OFDM_TSRCDEL_SYNCBYTE		0xF2030080
+#define	F367_OFDM_TSRCDEL_XXHEADER		0xF2030040
+#define	F367_OFDM_TSRCDEL_BBHEADER		0xF2030020
+#define	F367_OFDM_TSRCDEL_DATAFIELD		0xF2030010
+#define	F367_OFDM_TSRCINSDEL_ISCR		0xF2030008
+#define	F367_OFDM_TSRCINSDEL_NPD		0xF2030004
+#define	F367_OFDM_TSRCINSDEL_RSPARITY		0xF2030002
+#define	F367_OFDM_TSRCINSDEL_CRC8		0xF2030001
+
+/* RCINSDELM */
+#define	R367_OFDM_RCINSDELM		0xF204
+#define	F367_OFDM_TSRCINS_BBPADDING		0xF2040080
+#define	F367_OFDM_TSRCINS_BCHFEC		0xF2040040
+#define	F367_OFDM_TSRCINS_LDPCFEC		0xF2040020
+#define	F367_OFDM_TSRCINS_EMODCOD		0xF2040010
+#define	F367_OFDM_TSRCINS_TOKEN		0xF2040008
+#define	F367_OFDM_TSRCINS_XXXERR		0xF2040004
+#define	F367_OFDM_TSRCINS_MATYPE		0xF2040002
+#define	F367_OFDM_TSRCINS_UPL		0xF2040001
+
+/* RCINSDELL */
+#define	R367_OFDM_RCINSDELL		0xF205
+#define	F367_OFDM_TSRCINS_DFL		0xF2050080
+#define	F367_OFDM_TSRCINS_SYNCD		0xF2050040
+#define	F367_OFDM_TSRCINS_BLOCLEN		0xF2050020
+#define	F367_OFDM_TSRCINS_SIGPCOUNT		0xF2050010
+#define	F367_OFDM_TSRCINS_FIFO		0xF2050008
+#define	F367_OFDM_TSRCINS_REALPACK		0xF2050004
+#define	F367_OFDM_TSRCINS_TSCONFIG		0xF2050002
+#define	F367_OFDM_TSRCINS_LATENCY		0xF2050001
+
+/* RCSTATUS */
+#define	R367_OFDM_RCSTATUS		0xF206
+#define	F367_OFDM_TSRCFIFO_LINEOK		0xF2060080
+#define	F367_OFDM_TSRCFIFO_ERROR		0xF2060040
+#define	F367_OFDM_TSRCFIFO_DATA7		0xF2060020
+#define	F367_OFDM_RCSTATUS_4		0xF2060010
+#define	F367_OFDM_TSRCFIFO_DEMODSEL		0xF2060008
+#define	F367_OFDM_TSRC1FIFOSPEED_STORE		0xF2060004
+#define	F367_OFDM_RCSTATUS_1		0xF2060002
+#define	F367_OFDM_TSRCSERIAL_IMPOSSIBLE		0xF2060001
+
+/* RCSPEED */
+#define	R367_OFDM_RCSPEED		0xF207
+#define	F367_OFDM_TSRCFIFO_OUTSPEED		0xF20700FF
+
+/* RCDEBUGM */
+#define	R367_OFDM_RCDEBUGM		0xF208
+#define	F367_OFDM_SD_UNSYNC		0xF2080080
+#define	F367_OFDM_ULFLOCK_DETECTM		0xF2080040
+#define	F367_OFDM_SUL_SELECTOS		0xF2080020
+#define	F367_OFDM_DILUL_NOSCRBLE		0xF2080010
+#define	F367_OFDM_NUL_SCRB		0xF2080008
+#define	F367_OFDM_UL_SCRB		0xF2080004
+#define	F367_OFDM_SCRAULBAD		0xF2080002
+#define	F367_OFDM_SCRAUL_UNSYNC		0xF2080001
+
+/* RCDEBUGL */
+#define	R367_OFDM_RCDEBUGL		0xF209
+#define	F367_OFDM_RS_ERR		0xF2090080
+#define	F367_OFDM_LLFLOCK_DETECTM		0xF2090040
+#define	F367_OFDM_NOT_SUL_SELECTOS		0xF2090020
+#define	F367_OFDM_DILLL_NOSCRBLE		0xF2090010
+#define	F367_OFDM_NLL_SCRB		0xF2090008
+#define	F367_OFDM_LL_SCRB		0xF2090004
+#define	F367_OFDM_SCRALLBAD		0xF2090002
+#define	F367_OFDM_SCRALL_UNSYNC		0xF2090001
+
+/* RCOBSCFG */
+#define	R367_OFDM_RCOBSCFG		0xF20A
+#define	F367_OFDM_TSRCFIFO_OBSCFG		0xF20A00FF
+
+/* RCOBSM */
+#define	R367_OFDM_RCOBSM		0xF20B
+#define	F367_OFDM_TSRCFIFO_OBSDATA_HI		0xF20B00FF
+
+/* RCOBSL */
+#define	R367_OFDM_RCOBSL		0xF20C
+#define	F367_OFDM_TSRCFIFO_OBSDATA_LO		0xF20C00FF
+
+/* RCFECSPY */
+#define	R367_OFDM_RCFECSPY		0xF210
+#define	F367_OFDM_SPYRC_ENABLE		0xF2100080
+#define	F367_OFDM_RCNO_SYNCBYTE		0xF2100040
+#define	F367_OFDM_RCSERIAL_MODE		0xF2100020
+#define	F367_OFDM_RCUNUSUAL_PACKET		0xF2100010
+#define	F367_OFDM_BERRCMETER_DATAMODE		0xF210000C
+#define	F367_OFDM_BERRCMETER_LMODE		0xF2100002
+#define	F367_OFDM_BERRCMETER_RESET		0xF2100001
+
+/* RCFSPYCFG */
+#define	R367_OFDM_RCFSPYCFG		0xF211
+#define	F367_OFDM_FECSPYRC_INPUT		0xF21100C0
+#define	F367_OFDM_RCRST_ON_ERROR		0xF2110020
+#define	F367_OFDM_RCONE_SHOT		0xF2110010
+#define	F367_OFDM_RCI2C_MODE		0xF211000C
+#define	F367_OFDM_SPYRC_HSTERESIS		0xF2110003
+
+/* RCFSPYDATA */
+#define	R367_OFDM_RCFSPYDATA		0xF212
+#define	F367_OFDM_SPYRC_STUFFING		0xF2120080
+#define	F367_OFDM_RCNOERR_PKTJITTER		0xF2120040
+#define	F367_OFDM_SPYRC_CNULLPKT		0xF2120020
+#define	F367_OFDM_SPYRC_OUTDATA_MODE		0xF212001F
+
+/* RCFSPYOUT */
+#define	R367_OFDM_RCFSPYOUT		0xF213
+#define	F367_OFDM_FSPYRC_DIRECT		0xF2130080
+#define	F367_OFDM_RCFSPYOUT_6		0xF2130040
+#define	F367_OFDM_SPYRC_OUTDATA_BUS		0xF2130038
+#define	F367_OFDM_RCSTUFF_MODE		0xF2130007
+
+/* RCFSTATUS */
+#define	R367_OFDM_RCFSTATUS		0xF214
+#define	F367_OFDM_SPYRC_ENDSIM		0xF2140080
+#define	F367_OFDM_RCVALID_SIM		0xF2140040
+#define	F367_OFDM_RCFOUND_SIGNAL		0xF2140020
+#define	F367_OFDM_RCDSS_SYNCBYTE		0xF2140010
+#define	F367_OFDM_RCRESULT_STATE		0xF214000F
+
+/* RCFGOODPACK */
+#define	R367_OFDM_RCFGOODPACK		0xF215
+#define	F367_OFDM_RCGOOD_PACKET		0xF21500FF
+
+/* RCFPACKCNT */
+#define	R367_OFDM_RCFPACKCNT		0xF216
+#define	F367_OFDM_RCPACKET_COUNTER		0xF21600FF
+
+/* RCFSPYMISC */
+#define	R367_OFDM_RCFSPYMISC		0xF217
+#define	F367_OFDM_RCLABEL_COUNTER		0xF21700FF
+
+/* RCFBERCPT4 */
+#define	R367_OFDM_RCFBERCPT4		0xF218
+#define	F367_OFDM_FBERRCMETER_CPT_MMMMSB		0xF21800FF
+
+/* RCFBERCPT3 */
+#define	R367_OFDM_RCFBERCPT3		0xF219
+#define	F367_OFDM_FBERRCMETER_CPT_MMMSB		0xF21900FF
+
+/* RCFBERCPT2 */
+#define	R367_OFDM_RCFBERCPT2		0xF21A
+#define	F367_OFDM_FBERRCMETER_CPT_MMSB		0xF21A00FF
+
+/* RCFBERCPT1 */
+#define	R367_OFDM_RCFBERCPT1		0xF21B
+#define	F367_OFDM_FBERRCMETER_CPT_MSB		0xF21B00FF
+
+/* RCFBERCPT0 */
+#define	R367_OFDM_RCFBERCPT0		0xF21C
+#define	F367_OFDM_FBERRCMETER_CPT_LSB		0xF21C00FF
+
+/* RCFBERERR2 */
+#define	R367_OFDM_RCFBERERR2		0xF21D
+#define	F367_OFDM_FBERRCMETER_ERR_HI		0xF21D00FF
+
+/* RCFBERERR1 */
+#define	R367_OFDM_RCFBERERR1		0xF21E
+#define	F367_OFDM_FBERRCMETER_ERR		0xF21E00FF
+
+/* RCFBERERR0 */
+#define	R367_OFDM_RCFBERERR0		0xF21F
+#define	F367_OFDM_FBERRCMETER_ERR_LO		0xF21F00FF
+
+/* RCFSTATESM */
+#define	R367_OFDM_RCFSTATESM		0xF220
+#define	F367_OFDM_RCRSTATE_F		0xF2200080
+#define	F367_OFDM_RCRSTATE_E		0xF2200040
+#define	F367_OFDM_RCRSTATE_D		0xF2200020
+#define	F367_OFDM_RCRSTATE_C		0xF2200010
+#define	F367_OFDM_RCRSTATE_B		0xF2200008
+#define	F367_OFDM_RCRSTATE_A		0xF2200004
+#define	F367_OFDM_RCRSTATE_9		0xF2200002
+#define	F367_OFDM_RCRSTATE_8		0xF2200001
+
+/* RCFSTATESL */
+#define	R367_OFDM_RCFSTATESL		0xF221
+#define	F367_OFDM_RCRSTATE_7		0xF2210080
+#define	F367_OFDM_RCRSTATE_6		0xF2210040
+#define	F367_OFDM_RCRSTATE_5		0xF2210020
+#define	F367_OFDM_RCRSTATE_4		0xF2210010
+#define	F367_OFDM_RCRSTATE_3		0xF2210008
+#define	F367_OFDM_RCRSTATE_2		0xF2210004
+#define	F367_OFDM_RCRSTATE_1		0xF2210002
+#define	F367_OFDM_RCRSTATE_0		0xF2210001
+
+/* RCFSPYBER */
+#define	R367_OFDM_RCFSPYBER		0xF222
+#define	F367_OFDM_RCFSPYBER_7		0xF2220080
+#define	F367_OFDM_SPYRCOBS_XORREAD		0xF2220040
+#define	F367_OFDM_FSPYRCBER_OBSMODE		0xF2220020
+#define	F367_OFDM_FSPYRCBER_SYNCBYT		0xF2220010
+#define	F367_OFDM_FSPYRCBER_UNSYNC		0xF2220008
+#define	F367_OFDM_FSPYRCBER_CTIME		0xF2220007
+
+/* RCFSPYDISTM */
+#define	R367_OFDM_RCFSPYDISTM		0xF223
+#define	F367_OFDM_RCPKTTIME_DISTANCE_HI		0xF22300FF
+
+/* RCFSPYDISTL */
+#define	R367_OFDM_RCFSPYDISTL		0xF224
+#define	F367_OFDM_RCPKTTIME_DISTANCE_LO		0xF22400FF
+
+/* RCFSPYOBS7 */
+#define	R367_OFDM_RCFSPYOBS7		0xF228
+#define	F367_OFDM_RCSPYOBS_SPYFAIL		0xF2280080
+#define	F367_OFDM_RCSPYOBS_SPYFAIL1		0xF2280040
+#define	F367_OFDM_RCSPYOBS_ERROR		0xF2280020
+#define	F367_OFDM_RCSPYOBS_STROUT		0xF2280010
+#define	F367_OFDM_RCSPYOBS_RESULTSTATE1		0xF228000F
+
+/* RCFSPYOBS6 */
+#define	R367_OFDM_RCFSPYOBS6		0xF229
+#define	F367_OFDM_RCSPYOBS_RESULTSTATE0		0xF22900F0
+#define	F367_OFDM_RCSPYOBS_RESULTSTATEM1		0xF229000F
+
+/* RCFSPYOBS5 */
+#define	R367_OFDM_RCFSPYOBS5		0xF22A
+#define	F367_OFDM_RCSPYOBS_BYTEOFPACKET1		0xF22A00FF
+
+/* RCFSPYOBS4 */
+#define	R367_OFDM_RCFSPYOBS4		0xF22B
+#define	F367_OFDM_RCSPYOBS_BYTEVALUE1		0xF22B00FF
+
+/* RCFSPYOBS3 */
+#define	R367_OFDM_RCFSPYOBS3		0xF22C
+#define	F367_OFDM_RCSPYOBS_DATA1		0xF22C00FF
+
+/* RCFSPYOBS2 */
+#define	R367_OFDM_RCFSPYOBS2		0xF22D
+#define	F367_OFDM_RCSPYOBS_DATA0		0xF22D00FF
+
+/* RCFSPYOBS1 */
+#define	R367_OFDM_RCFSPYOBS1		0xF22E
+#define	F367_OFDM_RCSPYOBS_DATAM1		0xF22E00FF
+
+/* RCFSPYOBS0 */
+#define	R367_OFDM_RCFSPYOBS0		0xF22F
+#define	F367_OFDM_RCSPYOBS_DATAM2		0xF22F00FF
+
+/* TSGENERAL */
+#define	R367_TSGENERAL		0xF230
+#define	F367_TSGENERAL_7		0xF2300080
+#define	F367_TSGENERAL_6		0xF2300040
+#define	F367_TSFIFO_BCLK1ALL		0xF2300020
+#define	F367_TSGENERAL_4		0xF2300010
+#define	F367_MUXSTREAM_OUTMODE		0xF2300008
+#define	F367_TSFIFO_PERMPARAL		0xF2300006
+#define	F367_RST_REEDSOLO		0xF2300001
+
+/* RC1SPEED */
+#define	R367_RC1SPEED		0xF231
+#define	F367_TSRCFIFO1_OUTSPEED		0xF23100FF
+
+/* TSGSTATUS */
+#define	R367_TSGSTATUS		0xF232
+#define	F367_TSGSTATUS_7		0xF2320080
+#define	F367_TSGSTATUS_6		0xF2320040
+#define	F367_RSMEM_FULL		0xF2320020
+#define	F367_RS_MULTCALC		0xF2320010
+#define	F367_RSIN_OVERTIME		0xF2320008
+#define	F367_TSFIFO3_DEMODSEL		0xF2320004
+#define	F367_TSFIFO2_DEMODSEL		0xF2320002
+#define	F367_TSFIFO1_DEMODSEL		0xF2320001
+
+
+/* FECM */
+#define	R367_OFDM_FECM		0xF233
+#define	F367_OFDM_DSS_DVB		0xF2330080
+#define	F367_OFDM_DEMOD_BYPASS		0xF2330040
+#define	F367_OFDM_CMP_SLOWMODE		0xF2330020
+#define	F367_OFDM_DSS_SRCH		0xF2330010
+#define	F367_OFDM_FECM_3		0xF2330008
+#define	F367_OFDM_DIFF_MODEVIT		0xF2330004
+#define	F367_OFDM_SYNCVIT		0xF2330002
+#define	F367_OFDM_I2CSYM		0xF2330001
+
+/* VTH12 */
+#define	R367_OFDM_VTH12		0xF234
+#define	F367_OFDM_VTH_12		0xF23400FF
+
+/* VTH23 */
+#define	R367_OFDM_VTH23		0xF235
+#define	F367_OFDM_VTH_23		0xF23500FF
+
+/* VTH34 */
+#define	R367_OFDM_VTH34		0xF236
+#define	F367_OFDM_VTH_34		0xF23600FF
+
+/* VTH56 */
+#define	R367_OFDM_VTH56		0xF237
+#define	F367_OFDM_VTH_56		0xF23700FF
+
+/* VTH67 */
+#define	R367_OFDM_VTH67		0xF238
+#define	F367_OFDM_VTH_67		0xF23800FF
+
+/* VTH78 */
+#define	R367_OFDM_VTH78		0xF239
+#define	F367_OFDM_VTH_78		0xF23900FF
+
+/* VITCURPUN */
+#define	R367_OFDM_VITCURPUN		0xF23A
+#define	F367_OFDM_VIT_MAPPING		0xF23A00E0
+#define	F367_OFDM_VIT_CURPUN		0xF23A001F
+
+/* VERROR */
+#define	R367_OFDM_VERROR		0xF23B
+#define	F367_OFDM_REGERR_VIT		0xF23B00FF
+
+/* PRVIT */
+#define	R367_OFDM_PRVIT		0xF23C
+#define	F367_OFDM_PRVIT_7		0xF23C0080
+#define	F367_OFDM_DIS_VTHLOCK		0xF23C0040
+#define	F367_OFDM_E7_8VIT		0xF23C0020
+#define	F367_OFDM_E6_7VIT		0xF23C0010
+#define	F367_OFDM_E5_6VIT		0xF23C0008
+#define	F367_OFDM_E3_4VIT		0xF23C0004
+#define	F367_OFDM_E2_3VIT		0xF23C0002
+#define	F367_OFDM_E1_2VIT		0xF23C0001
+
+/* VAVSRVIT */
+#define	R367_OFDM_VAVSRVIT		0xF23D
+#define	F367_OFDM_AMVIT		0xF23D0080
+#define	F367_OFDM_FROZENVIT		0xF23D0040
+#define	F367_OFDM_SNVIT		0xF23D0030
+#define	F367_OFDM_TOVVIT		0xF23D000C
+#define	F367_OFDM_HYPVIT		0xF23D0003
+
+/* VSTATUSVIT */
+#define	R367_OFDM_VSTATUSVIT		0xF23E
+#define	F367_OFDM_VITERBI_ON		0xF23E0080
+#define	F367_OFDM_END_LOOPVIT		0xF23E0040
+#define	F367_OFDM_VITERBI_DEPRF		0xF23E0020
+#define	F367_OFDM_PRFVIT		0xF23E0010
+#define	F367_OFDM_LOCKEDVIT		0xF23E0008
+#define	F367_OFDM_VITERBI_DELOCK		0xF23E0004
+#define	F367_OFDM_VIT_DEMODSEL		0xF23E0002
+#define	F367_OFDM_VITERBI_COMPOUT		0xF23E0001
+
+/* VTHINUSE */
+#define	R367_OFDM_VTHINUSE		0xF23F
+#define	F367_OFDM_VIT_INUSE		0xF23F00FF
+
+/* KDIV12 */
+#define	R367_OFDM_KDIV12		0xF240
+#define	F367_OFDM_KDIV12_MANUAL		0xF2400080
+#define	F367_OFDM_K_DIVIDER_12		0xF240007F
+
+/* KDIV23 */
+#define	R367_OFDM_KDIV23		0xF241
+#define	F367_OFDM_KDIV23_MANUAL		0xF2410080
+#define	F367_OFDM_K_DIVIDER_23		0xF241007F
+
+/* KDIV34 */
+#define	R367_OFDM_KDIV34		0xF242
+#define	F367_OFDM_KDIV34_MANUAL		0xF2420080
+#define	F367_OFDM_K_DIVIDER_34		0xF242007F
+
+/* KDIV56 */
+#define	R367_OFDM_KDIV56		0xF243
+#define	F367_OFDM_KDIV56_MANUAL		0xF2430080
+#define	F367_OFDM_K_DIVIDER_56		0xF243007F
+
+/* KDIV67 */
+#define	R367_OFDM_KDIV67		0xF244
+#define	F367_OFDM_KDIV67_MANUAL		0xF2440080
+#define	F367_OFDM_K_DIVIDER_67		0xF244007F
+
+/* KDIV78 */
+#define	R367_OFDM_KDIV78		0xF245
+#define	F367_OFDM_KDIV78_MANUAL		0xF2450080
+#define	F367_OFDM_K_DIVIDER_78		0xF245007F
+
+/* SIGPOWER */
+#define	R367_OFDM_SIGPOWER		0xF246
+#define	F367_OFDM_SIGPOWER_MANUAL		0xF2460080
+#define	F367_OFDM_SIG_POWER		0xF246007F
+
+/* DEMAPVIT */
+#define	R367_OFDM_DEMAPVIT		0xF247
+#define	F367_OFDM_DEMAPVIT_7		0xF2470080
+#define	F367_OFDM_K_DIVIDER_VIT		0xF247007F
+
+/* VITSCALE */
+#define	R367_OFDM_VITSCALE		0xF248
+#define	F367_OFDM_NVTH_NOSRANGE		0xF2480080
+#define	F367_OFDM_VERROR_MAXMODE		0xF2480040
+#define	F367_OFDM_KDIV_MODE		0xF2480030
+#define	F367_OFDM_NSLOWSN_LOCKED		0xF2480008
+#define	F367_OFDM_DELOCK_PRFLOSS		0xF2480004
+#define	F367_OFDM_DIS_RSFLOCK		0xF2480002
+#define	F367_OFDM_VITSCALE_0		0xF2480001
+
+/* FFEC1PRG */
+#define	R367_OFDM_FFEC1PRG		0xF249
+#define	F367_OFDM_FDSS_DVB		0xF2490080
+#define	F367_OFDM_FDSS_SRCH		0xF2490040
+#define	F367_OFDM_FFECPROG_5		0xF2490020
+#define	F367_OFDM_FFECPROG_4		0xF2490010
+#define	F367_OFDM_FFECPROG_3		0xF2490008
+#define	F367_OFDM_FFECPROG_2		0xF2490004
+#define	F367_OFDM_FTS1_DISABLE		0xF2490002
+#define	F367_OFDM_FTS2_DISABLE		0xF2490001
+
+/* FVITCURPUN */
+#define	R367_OFDM_FVITCURPUN		0xF24A
+#define	F367_OFDM_FVIT_MAPPING		0xF24A00E0
+#define	F367_OFDM_FVIT_CURPUN		0xF24A001F
+
+/* FVERROR */
+#define	R367_OFDM_FVERROR		0xF24B
+#define	F367_OFDM_FREGERR_VIT		0xF24B00FF
+
+/* FVSTATUSVIT */
+#define	R367_OFDM_FVSTATUSVIT		0xF24C
+#define	F367_OFDM_FVITERBI_ON		0xF24C0080
+#define	F367_OFDM_F1END_LOOPVIT		0xF24C0040
+#define	F367_OFDM_FVITERBI_DEPRF		0xF24C0020
+#define	F367_OFDM_FPRFVIT		0xF24C0010
+#define	F367_OFDM_FLOCKEDVIT		0xF24C0008
+#define	F367_OFDM_FVITERBI_DELOCK		0xF24C0004
+#define	F367_OFDM_FVIT_DEMODSEL		0xF24C0002
+#define	F367_OFDM_FVITERBI_COMPOUT		0xF24C0001
+
+/* DEBUG_LT1 */
+#define	R367_OFDM_DEBUG_LT1		0xF24D
+#define	F367_OFDM_DBG_LT1		0xF24D00FF
+
+/* DEBUG_LT2 */
+#define	R367_OFDM_DEBUG_LT2		0xF24E
+#define	F367_OFDM_DBG_LT2		0xF24E00FF
+
+/* DEBUG_LT3 */
+#define	R367_OFDM_DEBUG_LT3		0xF24F
+#define	F367_OFDM_DBG_LT3		0xF24F00FF
+
+	/*	TSTSFMET */
+#define	R367_OFDM_TSTSFMET			0xF250
+#define F367_OFDM_TSTSFEC_METRIQUES	0xF25000FF
+
+	/*	SELOUT */
+#define	R367_OFDM_SELOUT				0xF252
+#define	F367_OFDM_EN_SYNC			0xF2520080
+#define	F367_OFDM_EN_TBUSDEMAP       0xF2520040
+#define	F367_OFDM_SELOUT_5			0xF2520020
+#define	F367_OFDM_SELOUT_4			0xF2520010
+#define	F367_OFDM_TSTSYNCHRO_MODE    0xF2520002
+
+	/*	TSYNC */
+#define R367_OFDM_TSYNC				0xF253
+#define F367_OFDM_CURPUN_INCMODE		0xF2530080
+#define F367_OFDM_CERR_TSTMODE		0xF2530040
+#define F367_OFDM_SHIFTSOF_MODE		0xF2530030
+#define F367_OFDM_SLOWPHA_MODE		0xF2530008
+#define F367_OFDM_PXX_BYPALL			0xF2530004
+#define F367_OFDM_FROTA45_FIRST		0xF2530002
+#define F367_OFDM_TST_BCHERROR		0xF2530001
+
+	/*	TSTERR */
+#define R367_OFDM_TSTERR				0xF254
+#define F367_OFDM_TST_LONGPKT		0xF2540080
+#define F367_OFDM_TST_ISSYION		0xF2540040
+#define F367_OFDM_TST_NPDON			0xF2540020
+#define F367_OFDM_TSTERR_4			0xF2540010
+#define F367_OFDM_TRACEBACK_MODE		0xF2540008
+#define F367_OFDM_TST_RSPARITY		0xF2540004
+#define F367_OFDM_METRIQUE_MODE		0xF2540003
+
+	/*	TSFSYNC */
+#define R367_OFDM_TSFSYNC			0xF255
+#define F367_OFDM_EN_SFECSYNC		0xF2550080
+#define F367_OFDM_EN_SFECDEMAP		0xF2550040
+#define F367_OFDM_SFCERR_TSTMODE		0xF2550020
+#define F367_OFDM_SFECPXX_BYPALL		0xF2550010
+#define F367_OFDM_SFECTSTSYNCHRO_MODE 0xF255000F
+
+	/*	TSTSFERR */
+#define R367_OFDM_TSTSFERR			0xF256
+#define F367_OFDM_TSTSTERR_7			0xF2560080
+#define F367_OFDM_TSTSTERR_6			0xF2560040
+#define F367_OFDM_TSTSTERR_5		0xF2560020
+#define F367_OFDM_TSTSTERR_4			0xF2560010
+#define F367_OFDM_SFECTRACEBACK_MODE	0xF2560008
+#define F367_OFDM_SFEC_NCONVPROG		0xF2560004
+#define F367_OFDM_SFECMETRIQUE_MODE	0xF2560003
+
+	/*	TSTTSSF1 */
+#define R367_OFDM_TSTTSSF1			0xF258
+#define F367_OFDM_TSTERSSF			0xF2580080
+#define F367_OFDM_TSTTSSFEN			0xF2580040
+#define F367_OFDM_SFEC_OUTMODE		0xF2580030
+#define F367_OFDM_XLSF_NOFTHRESHOLD  0xF2580008
+#define F367_OFDM_TSTTSSF_STACKSEL	0xF2580007
+
+	/*	TSTTSSF2 */
+#define R367_OFDM_TSTTSSF2			0xF259
+#define F367_OFDM_DILSF_DBBHEADER	0xF2590080
+#define F367_OFDM_TSTTSSF_DISBUG		0xF2590040
+#define F367_OFDM_TSTTSSF_NOBADSTART	0xF2590020
+#define F367_OFDM_TSTTSSF_SELECT	0xF259001F
+
+	/*	TSTTSSF3 */
+#define R367_OFDM_TSTTSSF3			0xF25A
+#define F367_OFDM_TSTTSSF3_7			0xF25A0080
+#define F367_OFDM_TSTTSSF3_6			0xF25A0040
+#define F367_OFDM_TSTTSSF3_5			0xF25A0020
+#define F367_OFDM_TSTTSSF3_4			0xF25A0010
+#define F367_OFDM_TSTTSSF3_3			0xF25A0008
+#define F367_OFDM_TSTTSSF3_2			0xF25A0004
+#define F367_OFDM_TSTTSSF3_1			0xF25A0002
+#define F367_OFDM_DISSF_CLKENABLE    0xF25A0001
+
+	/*	TSTTS1 */
+#define R367_OFDM_TSTTS1				0xF25C
+#define F367_OFDM_TSTERS				0xF25C0080
+#define F367_OFDM_TSFIFO_DSSSYNCB	0xF25C0040
+#define F367_OFDM_TSTTS_FSPYBEFRS	0xF25C0020
+#define F367_OFDM_NFORCE_SYNCBYTE	0xF25C0010
+#define F367_OFDM_XL_NOFTHRESHOLD	0xF25C0008
+#define F367_OFDM_TSTTS_FRFORCEPKT	0xF25C0004
+#define F367_OFDM_DESCR_NOTAUTO		0xF25C0002
+#define F367_OFDM_TSTTSEN			0xF25C0001
+
+	/*	TSTTS2 */
+#define R367_OFDM_TSTTS2				0xF25D
+#define F367_OFDM_DIL_DBBHEADER		0xF25D0080
+#define F367_OFDM_TSTTS_NOBADXXX		0xF25D0040
+#define F367_OFDM_TSFIFO_DELSPEEDUP	0xF25D0020
+#define F367_OFDM_TSTTS_SELECT		0xF25D001F
+
+	/*	TSTTS3 */
+#define R367_OFDM_TSTTS3				0xF25E
+#define F367_OFDM_TSTTS_NOPKTGAIN	0xF25E0080
+#define F367_OFDM_TSTTS_NOPKTENE		0xF25E0040
+#define F367_OFDM_TSTTS_ISOLATION	0xF25E0020
+#define F367_OFDM_TSTTS_DISBUG		0xF25E0010
+#define F367_OFDM_TSTTS_NOBADSTART	0xF25E0008
+#define F367_OFDM_TSTTS_STACKSEL		0xF25E0007
+
+	/*	TSTTS4 */
+#define R367_OFDM_TSTTS4				0xF25F
+#define F367_OFDM_TSTTS4_7			0xF25F0080
+#define F367_OFDM_TSTTS4_6			0xF25F0040
+#define F367_OFDM_TSTTS4_5			0xF25F0020
+#define F367_OFDM_TSTTS_DISDSTATE	0xF25F0010
+#define F367_OFDM_TSTTS_FASTNOSYNC	0xF25F0008
+#define F367_OFDM_EXT_FECSPYIN		0xF25F0004
+#define F367_OFDM_TSTTS_NODPZERO		0xF25F0002
+#define F367_OFDM_TSTTS_NODIV3		0xF25F0001
+
+	/*	TSTTSRC */
+#define R367_OFDM_TSTTSRC				0xF26C
+#define F367_OFDM_TSTTSRC_7				0xF26C0080
+#define F367_OFDM_TSRCFIFO_DSSSYNCB		0xF26C0040
+#define F367_OFDM_TSRCFIFO_DPUNACTIVE	0xF26C0020
+#define F367_OFDM_TSRCFIFO_DELSPEEDUP	0xF26C0010
+#define F367_OFDM_TSTTSRC_NODIV3			0xF26C0008
+#define F367_OFDM_TSTTSRC_FRFORCEPKT		0xF26C0004
+#define F367_OFDM_SAT25_SDDORIGINE		0xF26C0002
+#define F367_OFDM_TSTTSRC_INACTIVE		0xF26C0001
+
+	/*	TSTTSRS */
+#define R367_OFDM_TSTTSRS				0xF26D
+#define F367_OFDM_TSTTSRS_7				0xF26D0080
+#define F367_OFDM_TSTTSRS_6				0xF26D0040
+#define F367_OFDM_TSTTSRS_5				0xF26D0020
+#define F367_OFDM_TSTTSRS_4				0xF26D0010
+#define F367_OFDM_TSTTSRS_3				0xF26D0008
+#define F367_OFDM_TSTTSRS_2				0xF26D0004
+#define F367_OFDM_TSTRS_DISRS2			0xF26D0002
+#define F367_OFDM_TSTRS_DISRS1			0xF26D0001
+
+/* TSSTATEM */
+#define	R367_OFDM_TSSTATEM		0xF270
+#define	F367_OFDM_TSDIL_ON		0xF2700080
+#define	F367_OFDM_TSSKIPRS_ON		0xF2700040
+#define	F367_OFDM_TSRS_ON		0xF2700020
+#define	F367_OFDM_TSDESCRAMB_ON		0xF2700010
+#define	F367_OFDM_TSFRAME_MODE		0xF2700008
+#define	F367_OFDM_TS_DISABLE		0xF2700004
+#define	F367_OFDM_TSACM_MODE		0xF2700002
+#define	F367_OFDM_TSOUT_NOSYNC		0xF2700001
+
+/* TSSTATEL */
+#define	R367_OFDM_TSSTATEL		0xF271
+#define	F367_OFDM_TSNOSYNCBYTE		0xF2710080
+#define	F367_OFDM_TSPARITY_ON		0xF2710040
+#define	F367_OFDM_TSSYNCOUTRS_ON		0xF2710020
+#define	F367_OFDM_TSDVBS2_MODE		0xF2710010
+#define	F367_OFDM_TSISSYI_ON		0xF2710008
+#define	F367_OFDM_TSNPD_ON		0xF2710004
+#define	F367_OFDM_TSCRC8_ON		0xF2710002
+#define	F367_OFDM_TSDSS_PACKET		0xF2710001
+
+/* TSCFGH */
+#define	R367_OFDM_TSCFGH		0xF272
+#define	F367_OFDM_TSFIFO_DVBCI		0xF2720080
+#define	F367_OFDM_TSFIFO_SERIAL		0xF2720040
+#define	F367_OFDM_TSFIFO_TEIUPDATE		0xF2720020
+#define	F367_OFDM_TSFIFO_DUTY50		0xF2720010
+#define	F367_OFDM_TSFIFO_HSGNLOUT		0xF2720008
+#define	F367_OFDM_TSFIFO_ERRMODE		0xF2720006
+#define	F367_OFDM_RST_HWARE		0xF2720001
+
+/* TSCFGM */
+#define	R367_OFDM_TSCFGM		0xF273
+#define	F367_OFDM_TSFIFO_MANSPEED		0xF27300C0
+#define	F367_OFDM_TSFIFO_PERMDATA		0xF2730020
+#define	F367_OFDM_TSFIFO_NONEWSGNL		0xF2730010
+#define	F367_OFDM_TSFIFO_BITSPEED		0xF2730008
+#define	F367_OFDM_NPD_SPECDVBS2		0xF2730004
+#define	F367_OFDM_TSFIFO_STOPCKDIS		0xF2730002
+#define	F367_OFDM_TSFIFO_INVDATA		0xF2730001
+
+/* TSCFGL */
+#define	R367_OFDM_TSCFGL		0xF274
+#define	F367_OFDM_TSFIFO_BCLKDEL1CK		0xF27400C0
+#define	F367_OFDM_BCHERROR_MODE		0xF2740030
+#define	F367_OFDM_TSFIFO_NSGNL2DATA		0xF2740008
+#define	F367_OFDM_TSFIFO_EMBINDVB		0xF2740004
+#define	F367_OFDM_TSFIFO_DPUNACT		0xF2740002
+#define	F367_OFDM_TSFIFO_NPDOFF		0xF2740001
+
+/* TSSYNC */
+#define	R367_OFDM_TSSYNC		0xF275
+#define	F367_OFDM_TSFIFO_PERMUTE		0xF2750080
+#define	F367_OFDM_TSFIFO_FISCR3B		0xF2750060
+#define	F367_OFDM_TSFIFO_SYNCMODE		0xF2750018
+#define	F367_OFDM_TSFIFO_SYNCSEL		0xF2750007
+
+/* TSINSDELH */
+#define	R367_OFDM_TSINSDELH		0xF276
+#define	F367_OFDM_TSDEL_SYNCBYTE		0xF2760080
+#define	F367_OFDM_TSDEL_XXHEADER		0xF2760040
+#define	F367_OFDM_TSDEL_BBHEADER		0xF2760020
+#define	F367_OFDM_TSDEL_DATAFIELD		0xF2760010
+#define	F367_OFDM_TSINSDEL_ISCR		0xF2760008
+#define	F367_OFDM_TSINSDEL_NPD		0xF2760004
+#define	F367_OFDM_TSINSDEL_RSPARITY		0xF2760002
+#define	F367_OFDM_TSINSDEL_CRC8		0xF2760001
+
+/* TSINSDELM */
+#define	R367_OFDM_TSINSDELM		0xF277
+#define	F367_OFDM_TSINS_BBPADDING		0xF2770080
+#define	F367_OFDM_TSINS_BCHFEC		0xF2770040
+#define	F367_OFDM_TSINS_LDPCFEC		0xF2770020
+#define	F367_OFDM_TSINS_EMODCOD		0xF2770010
+#define	F367_OFDM_TSINS_TOKEN		0xF2770008
+#define	F367_OFDM_TSINS_XXXERR		0xF2770004
+#define	F367_OFDM_TSINS_MATYPE		0xF2770002
+#define	F367_OFDM_TSINS_UPL		0xF2770001
+
+/* TSINSDELL */
+#define	R367_OFDM_TSINSDELL		0xF278
+#define	F367_OFDM_TSINS_DFL		0xF2780080
+#define	F367_OFDM_TSINS_SYNCD		0xF2780040
+#define	F367_OFDM_TSINS_BLOCLEN		0xF2780020
+#define	F367_OFDM_TSINS_SIGPCOUNT		0xF2780010
+#define	F367_OFDM_TSINS_FIFO		0xF2780008
+#define	F367_OFDM_TSINS_REALPACK		0xF2780004
+#define	F367_OFDM_TSINS_TSCONFIG		0xF2780002
+#define	F367_OFDM_TSINS_LATENCY		0xF2780001
+
+/* TSDIVN */
+#define	R367_OFDM_TSDIVN		0xF279
+#define	F367_OFDM_TSFIFO_LOWSPEED		0xF2790080
+#define	F367_OFDM_BYTE_OVERSAMPLING		0xF2790070
+#define	F367_OFDM_TSMANUAL_PACKETNBR		0xF279000F
+
+/* TSDIVPM */
+#define	R367_OFDM_TSDIVPM		0xF27A
+#define	F367_OFDM_TSMANUAL_P_HI		0xF27A00FF
+
+/* TSDIVPL */
+#define	R367_OFDM_TSDIVPL		0xF27B
+#define	F367_OFDM_TSMANUAL_P_LO		0xF27B00FF
+
+/* TSDIVQM */
+#define	R367_OFDM_TSDIVQM		0xF27C
+#define	F367_OFDM_TSMANUAL_Q_HI		0xF27C00FF
+
+/* TSDIVQL */
+#define	R367_OFDM_TSDIVQL		0xF27D
+#define	F367_OFDM_TSMANUAL_Q_LO		0xF27D00FF
+
+/* TSDILSTKM */
+#define	R367_OFDM_TSDILSTKM		0xF27E
+#define	F367_OFDM_TSFIFO_DILSTK_HI		0xF27E00FF
+
+/* TSDILSTKL */
+#define	R367_OFDM_TSDILSTKL		0xF27F
+#define	F367_OFDM_TSFIFO_DILSTK_LO		0xF27F00FF
+
+/* TSSPEED */
+#define	R367_OFDM_TSSPEED		0xF280
+#define	F367_OFDM_TSFIFO_OUTSPEED		0xF28000FF
+
+/* TSSTATUS */
+#define	R367_OFDM_TSSTATUS		0xF281
+#define	F367_OFDM_TSFIFO_LINEOK		0xF2810080
+#define	F367_OFDM_TSFIFO_ERROR		0xF2810040
+#define	F367_OFDM_TSFIFO_DATA7		0xF2810020
+#define	F367_OFDM_TSFIFO_NOSYNC		0xF2810010
+#define	F367_OFDM_ISCR_INITIALIZED		0xF2810008
+#define	F367_OFDM_ISCR_UPDATED		0xF2810004
+#define	F367_OFDM_SOFFIFO_UNREGUL		0xF2810002
+#define	F367_OFDM_DIL_READY		0xF2810001
+
+/* TSSTATUS2 */
+#define	R367_OFDM_TSSTATUS2		0xF282
+#define	F367_OFDM_TSFIFO_DEMODSEL		0xF2820080
+#define	F367_OFDM_TSFIFOSPEED_STORE		0xF2820040
+#define	F367_OFDM_DILXX_RESET		0xF2820020
+#define	F367_OFDM_TSSERIAL_IMPOSSIBLE		0xF2820010
+#define	F367_OFDM_TSFIFO_UNDERSPEED		0xF2820008
+#define	F367_OFDM_BITSPEED_EVENT		0xF2820004
+#define	F367_OFDM_UL_SCRAMBDETECT		0xF2820002
+#define	F367_OFDM_ULDTV67_FALSELOCK		0xF2820001
+
+/* TSBITRATEM */
+#define	R367_OFDM_TSBITRATEM		0xF283
+#define	F367_OFDM_TSFIFO_BITRATE_HI		0xF28300FF
+
+/* TSBITRATEL */
+#define	R367_OFDM_TSBITRATEL		0xF284
+#define	F367_OFDM_TSFIFO_BITRATE_LO		0xF28400FF
+
+/* TSPACKLENM */
+#define	R367_OFDM_TSPACKLENM		0xF285
+#define	F367_OFDM_TSFIFO_PACKCPT		0xF28500E0
+#define	F367_OFDM_DIL_RPLEN_HI		0xF285001F
+
+/* TSPACKLENL */
+#define	R367_OFDM_TSPACKLENL		0xF286
+#define	F367_OFDM_DIL_RPLEN_LO		0xF28600FF
+
+/* TSBLOCLENM */
+#define	R367_OFDM_TSBLOCLENM		0xF287
+#define	F367_OFDM_TSFIFO_PFLEN_HI		0xF28700FF
+
+/* TSBLOCLENL */
+#define	R367_OFDM_TSBLOCLENL		0xF288
+#define	F367_OFDM_TSFIFO_PFLEN_LO		0xF28800FF
+
+/* TSDLYH */
+#define	R367_OFDM_TSDLYH		0xF289
+#define	F367_OFDM_SOFFIFO_TSTIMEVALID		0xF2890080
+#define	F367_OFDM_SOFFIFO_SPEEDUP		0xF2890040
+#define	F367_OFDM_SOFFIFO_STOP		0xF2890020
+#define	F367_OFDM_SOFFIFO_REGULATED		0xF2890010
+#define	F367_OFDM_SOFFIFO_REALSBOFF_HI		0xF289000F
+
+/* TSDLYM */
+#define	R367_OFDM_TSDLYM		0xF28A
+#define	F367_OFDM_SOFFIFO_REALSBOFF_MED		0xF28A00FF
+
+/* TSDLYL */
+#define	R367_OFDM_TSDLYL		0xF28B
+#define	F367_OFDM_SOFFIFO_REALSBOFF_LO		0xF28B00FF
+
+/* TSNPDAV */
+#define	R367_OFDM_TSNPDAV		0xF28C
+#define	F367_OFDM_TSNPD_AVERAGE		0xF28C00FF
+
+/* TSBUFSTATH */
+#define	R367_OFDM_TSBUFSTATH		0xF28D
+#define	F367_OFDM_TSISCR_3BYTES		0xF28D0080
+#define	F367_OFDM_TSISCR_NEWDATA		0xF28D0040
+#define	F367_OFDM_TSISCR_BUFSTAT_HI		0xF28D003F
+
+/* TSBUFSTATM */
+#define	R367_OFDM_TSBUFSTATM		0xF28E
+#define	F367_OFDM_TSISCR_BUFSTAT_MED		0xF28E00FF
+
+/* TSBUFSTATL */
+#define	R367_OFDM_TSBUFSTATL		0xF28F
+#define	F367_OFDM_TSISCR_BUFSTAT_LO		0xF28F00FF
+
+/* TSDEBUGM */
+#define	R367_OFDM_TSDEBUGM		0xF290
+#define	F367_OFDM_TSFIFO_ILLPACKET		0xF2900080
+#define	F367_OFDM_DIL_NOSYNC		0xF2900040
+#define	F367_OFDM_DIL_ISCR		0xF2900020
+#define	F367_OFDM_DILOUT_BSYNCB		0xF2900010
+#define	F367_OFDM_TSFIFO_EMPTYPKT		0xF2900008
+#define	F367_OFDM_TSFIFO_EMPTYRD		0xF2900004
+#define	F367_OFDM_SOFFIFO_STOPM		0xF2900002
+#define	F367_OFDM_SOFFIFO_SPEEDUPM		0xF2900001
+
+/* TSDEBUGL */
+#define	R367_OFDM_TSDEBUGL		0xF291
+#define	F367_OFDM_TSFIFO_PACKLENFAIL		0xF2910080
+#define	F367_OFDM_TSFIFO_SYNCBFAIL		0xF2910040
+#define	F367_OFDM_TSFIFO_VITLIBRE		0xF2910020
+#define	F367_OFDM_TSFIFO_BOOSTSPEEDM		0xF2910010
+#define	F367_OFDM_TSFIFO_UNDERSPEEDM		0xF2910008
+#define	F367_OFDM_TSFIFO_ERROR_EVNT		0xF2910004
+#define	F367_OFDM_TSFIFO_FULL		0xF2910002
+#define	F367_OFDM_TSFIFO_OVERFLOWM		0xF2910001
+
+/* TSDLYSETH */
+#define	R367_OFDM_TSDLYSETH		0xF292
+#define	F367_OFDM_SOFFIFO_OFFSET		0xF29200E0
+#define	F367_OFDM_SOFFIFO_SYMBOFFSET_HI		0xF292001F
+
+/* TSDLYSETM */
+#define	R367_OFDM_TSDLYSETM		0xF293
+#define	F367_OFDM_SOFFIFO_SYMBOFFSET_MED		0xF29300FF
+
+/* TSDLYSETL */
+#define	R367_OFDM_TSDLYSETL		0xF294
+#define	F367_OFDM_SOFFIFO_SYMBOFFSET_LO		0xF29400FF
+
+/* TSOBSCFG */
+#define	R367_OFDM_TSOBSCFG		0xF295
+#define	F367_OFDM_TSFIFO_OBSCFG		0xF29500FF
+
+/* TSOBSM */
+#define	R367_OFDM_TSOBSM		0xF296
+#define	F367_OFDM_TSFIFO_OBSDATA_HI		0xF29600FF
+
+/* TSOBSL */
+#define	R367_OFDM_TSOBSL		0xF297
+#define	F367_OFDM_TSFIFO_OBSDATA_LO		0xF29700FF
+
+/* ERRCTRL1 */
+#define	R367_OFDM_ERRCTRL1		0xF298
+#define	F367_OFDM_ERR_SRC1		0xF29800F0
+#define	F367_OFDM_ERRCTRL1_3		0xF2980008
+#define	F367_OFDM_NUM_EVT1		0xF2980007
+
+/* ERRCNT1H */
+#define	R367_OFDM_ERRCNT1H		0xF299
+#define	F367_OFDM_ERRCNT1_OLDVALUE		0xF2990080
+#define	F367_OFDM_ERR_CNT1		0xF299007F
+
+/* ERRCNT1M */
+#define	R367_OFDM_ERRCNT1M		0xF29A
+#define	F367_OFDM_ERR_CNT1_HI		0xF29A00FF
+
+/* ERRCNT1L */
+#define	R367_OFDM_ERRCNT1L		0xF29B
+#define	F367_OFDM_ERR_CNT1_LO		0xF29B00FF
+
+/* ERRCTRL2 */
+#define	R367_OFDM_ERRCTRL2		0xF29C
+#define	F367_OFDM_ERR_SRC2		0xF29C00F0
+#define	F367_OFDM_ERRCTRL2_3		0xF29C0008
+#define	F367_OFDM_NUM_EVT2		0xF29C0007
+
+/* ERRCNT2H */
+#define	R367_OFDM_ERRCNT2H		0xF29D
+#define	F367_OFDM_ERRCNT2_OLDVALUE		0xF29D0080
+#define	F367_OFDM_ERR_CNT2_HI		0xF29D007F
+
+/* ERRCNT2M */
+#define	R367_OFDM_ERRCNT2M		0xF29E
+#define	F367_OFDM_ERR_CNT2_MED		0xF29E00FF
+
+/* ERRCNT2L */
+#define	R367_OFDM_ERRCNT2L		0xF29F
+#define	F367_OFDM_ERR_CNT2_LO		0xF29F00FF
+
+/* FECSPY */
+#define	R367_OFDM_FECSPY		0xF2A0
+#define	F367_OFDM_SPY_ENABLE		0xF2A00080
+#define	F367_OFDM_NO_SYNCBYTE		0xF2A00040
+#define	F367_OFDM_SERIAL_MODE		0xF2A00020
+#define	F367_OFDM_UNUSUAL_PACKET		0xF2A00010
+#define	F367_OFDM_BERMETER_DATAMODE		0xF2A0000C
+#define	F367_OFDM_BERMETER_LMODE		0xF2A00002
+#define	F367_OFDM_BERMETER_RESET		0xF2A00001
+
+/* FSPYCFG */
+#define	R367_OFDM_FSPYCFG		0xF2A1
+#define	F367_OFDM_FECSPY_INPUT		0xF2A100C0
+#define	F367_OFDM_RST_ON_ERROR		0xF2A10020
+#define	F367_OFDM_ONE_SHOT		0xF2A10010
+#define	F367_OFDM_I2C_MOD		0xF2A1000C
+#define	F367_OFDM_SPY_HYSTERESIS		0xF2A10003
+
+/* FSPYDATA */
+#define	R367_OFDM_FSPYDATA		0xF2A2
+#define	F367_OFDM_SPY_STUFFING		0xF2A20080
+#define	F367_OFDM_NOERROR_PKTJITTER		0xF2A20040
+#define	F367_OFDM_SPY_CNULLPKT		0xF2A20020
+#define	F367_OFDM_SPY_OUTDATA_MODE		0xF2A2001F
+
+/* FSPYOUT */
+#define	R367_OFDM_FSPYOUT		0xF2A3
+#define	F367_OFDM_FSPY_DIRECT		0xF2A30080
+#define	F367_OFDM_FSPYOUT_6		0xF2A30040
+#define	F367_OFDM_SPY_OUTDATA_BUS		0xF2A30038
+#define	F367_OFDM_STUFF_MODE		0xF2A30007
+
+/* FSTATUS */
+#define	R367_OFDM_FSTATUS		0xF2A4
+#define	F367_OFDM_SPY_ENDSIM		0xF2A40080
+#define	F367_OFDM_VALID_SIM		0xF2A40040
+#define	F367_OFDM_FOUND_SIGNAL		0xF2A40020
+#define	F367_OFDM_DSS_SYNCBYTE		0xF2A40010
+#define	F367_OFDM_RESULT_STATE		0xF2A4000F
+
+/* FGOODPACK */
+#define	R367_OFDM_FGOODPACK		0xF2A5
+#define	F367_OFDM_FGOOD_PACKET		0xF2A500FF
+
+/* FPACKCNT */
+#define	R367_OFDM_FPACKCNT		0xF2A6
+#define	F367_OFDM_FPACKET_COUNTER		0xF2A600FF
+
+/* FSPYMISC */
+#define	R367_OFDM_FSPYMISC		0xF2A7
+#define	F367_OFDM_FLABEL_COUNTER		0xF2A700FF
+
+/* FBERCPT4 */
+#define	R367_OFDM_FBERCPT4		0xF2A8
+#define	F367_OFDM_FBERMETER_CPT5		0xF2A800FF
+
+/* FBERCPT3 */
+#define	R367_OFDM_FBERCPT3		0xF2A9
+#define	F367_OFDM_FBERMETER_CPT4		0xF2A900FF
+
+/* FBERCPT2 */
+#define	R367_OFDM_FBERCPT2		0xF2AA
+#define	F367_OFDM_FBERMETER_CPT3		0xF2AA00FF
+
+/* FBERCPT1 */
+#define	R367_OFDM_FBERCPT1		0xF2AB
+#define	F367_OFDM_FBERMETER_CPT2		0xF2AB00FF
+
+/* FBERCPT0 */
+#define	R367_OFDM_FBERCPT0		0xF2AC
+#define	F367_OFDM_FBERMETER_CPT1		0xF2AC00FF
+
+/* FBERERR2 */
+#define	R367_OFDM_FBERERR2		0xF2AD
+#define	F367_OFDM_FBERMETER_ERR_HI		0xF2AD00FF
+
+/* FBERERR1 */
+#define	R367_OFDM_FBERERR1		0xF2AE
+#define	F367_OFDM_FBERMETER_ERR_MED		0xF2AE00FF
+
+/* FBERERR0 */
+#define	R367_OFDM_FBERERR0		0xF2AF
+#define	F367_OFDM_FBERMETER_ERR_LO		0xF2AF00FF
+
+/* FSTATESM */
+#define	R367_OFDM_FSTATESM		0xF2B0
+#define	F367_OFDM_RSTATE_F		0xF2B00080
+#define	F367_OFDM_RSTATE_E		0xF2B00040
+#define	F367_OFDM_RSTATE_D		0xF2B00020
+#define	F367_OFDM_RSTATE_C		0xF2B00010
+#define	F367_OFDM_RSTATE_B		0xF2B00008
+#define	F367_OFDM_RSTATE_A		0xF2B00004
+#define	F367_OFDM_RSTATE_9		0xF2B00002
+#define	F367_OFDM_RSTATE_8		0xF2B00001
+
+/* FSTATESL */
+#define	R367_OFDM_FSTATESL		0xF2B1
+#define	F367_OFDM_RSTATE_7		0xF2B10080
+#define	F367_OFDM_RSTATE_6		0xF2B10040
+#define	F367_OFDM_RSTATE_5		0xF2B10020
+#define	F367_OFDM_RSTATE_4		0xF2B10010
+#define	F367_OFDM_RSTATE_3		0xF2B10008
+#define	F367_OFDM_RSTATE_2		0xF2B10004
+#define	F367_OFDM_RSTATE_1		0xF2B10002
+#define	F367_OFDM_RSTATE_0		0xF2B10001
+
+/* FSPYBER */
+#define	R367_OFDM_FSPYBER		0xF2B2
+#define	F367_OFDM_FSPYBER_7		0xF2B20080
+#define	F367_OFDM_FSPYOBS_XORREAD		0xF2B20040
+#define	F367_OFDM_FSPYBER_OBSMODE		0xF2B20020
+#define	F367_OFDM_FSPYBER_SYNCBYTE		0xF2B20010
+#define	F367_OFDM_FSPYBER_UNSYNC		0xF2B20008
+#define	F367_OFDM_FSPYBER_CTIME		0xF2B20007
+
+/* FSPYDISTM */
+#define	R367_OFDM_FSPYDISTM		0xF2B3
+#define	F367_OFDM_PKTTIME_DISTANCE_HI		0xF2B300FF
+
+/* FSPYDISTL */
+#define	R367_OFDM_FSPYDISTL		0xF2B4
+#define	F367_OFDM_PKTTIME_DISTANCE_LO		0xF2B400FF
+
+/* FSPYOBS7 */
+#define	R367_OFDM_FSPYOBS7		0xF2B8
+#define	F367_OFDM_FSPYOBS_SPYFAIL		0xF2B80080
+#define	F367_OFDM_FSPYOBS_SPYFAIL1		0xF2B80040
+#define	F367_OFDM_FSPYOBS_ERROR		0xF2B80020
+#define	F367_OFDM_FSPYOBS_STROUT		0xF2B80010
+#define	F367_OFDM_FSPYOBS_RESULTSTATE1		0xF2B8000F
+
+/* FSPYOBS6 */
+#define	R367_OFDM_FSPYOBS6		0xF2B9
+#define	F367_OFDM_FSPYOBS_RESULTSTATE0		0xF2B900F0
+#define	F367_OFDM_FSPYOBS_RESULTSTATEM1		0xF2B9000F
+
+/* FSPYOBS5 */
+#define	R367_OFDM_FSPYOBS5		0xF2BA
+#define	F367_OFDM_FSPYOBS_BYTEOFPACKET1		0xF2BA00FF
+
+/* FSPYOBS4 */
+#define	R367_OFDM_FSPYOBS4		0xF2BB
+#define	F367_OFDM_FSPYOBS_BYTEVALUE1		0xF2BB00FF
+
+/* FSPYOBS3 */
+#define	R367_OFDM_FSPYOBS3		0xF2BC
+#define	F367_OFDM_FSPYOBS_DATA1		0xF2BC00FF
+
+/* FSPYOBS2 */
+#define	R367_OFDM_FSPYOBS2		0xF2BD
+#define	F367_OFDM_FSPYOBS_DATA0		0xF2BD00FF
+
+/* FSPYOBS1 */
+#define	R367_OFDM_FSPYOBS1		0xF2BE
+#define	F367_OFDM_FSPYOBS_DATAM1		0xF2BE00FF
+
+/* FSPYOBS0 */
+#define	R367_OFDM_FSPYOBS0		0xF2BF
+#define	F367_OFDM_FSPYOBS_DATAM2		0xF2BF00FF
+
+/* SFDEMAP */
+#define	R367_OFDM_SFDEMAP		0xF2C0
+#define	F367_OFDM_SFDEMAP_7		0xF2C00080
+#define	F367_OFDM_SFEC_K_DIVIDER_VIT		0xF2C0007F
+
+/* SFERROR */
+#define	R367_OFDM_SFERROR		0xF2C1
+#define	F367_OFDM_SFEC_REGERR_VIT		0xF2C100FF
+
+/* SFAVSR */
+#define	R367_OFDM_SFAVSR		0xF2C2
+#define	F367_OFDM_SFEC_SUMERRORS		0xF2C20080
+#define	F367_OFDM_SERROR_MAXMODE		0xF2C20040
+#define	F367_OFDM_SN_SFEC		0xF2C20030
+#define	F367_OFDM_KDIV_MODE_SFEC		0xF2C2000C
+#define	F367_OFDM_SFAVSR_1		0xF2C20002
+#define	F367_OFDM_SFAVSR_0		0xF2C20001
+
+/* SFECSTATUS */
+#define	R367_OFDM_SFECSTATUS		0xF2C3
+#define	F367_OFDM_SFEC_ON		0xF2C30080
+#define	F367_OFDM_SFSTATUS_6		0xF2C30040
+#define	F367_OFDM_SFSTATUS_5		0xF2C30020
+#define	F367_OFDM_SFSTATUS_4		0xF2C30010
+#define	F367_OFDM_LOCKEDSFEC		0xF2C30008
+#define	F367_OFDM_SFEC_DELOCK		0xF2C30004
+#define	F367_OFDM_SFEC_DEMODSEL1		0xF2C30002
+#define	F367_OFDM_SFEC_OVFON		0xF2C30001
+
+/* SFKDIV12 */
+#define	R367_OFDM_SFKDIV12		0xF2C4
+#define	F367_OFDM_SFECKDIV12_MAN		0xF2C40080
+#define	F367_OFDM_SFEC_K_DIVIDER_12		0xF2C4007F
+
+/* SFKDIV23 */
+#define	R367_OFDM_SFKDIV23		0xF2C5
+#define	F367_OFDM_SFECKDIV23_MAN		0xF2C50080
+#define	F367_OFDM_SFEC_K_DIVIDER_23		0xF2C5007F
+
+/* SFKDIV34 */
+#define	R367_OFDM_SFKDIV34		0xF2C6
+#define	F367_OFDM_SFECKDIV34_MAN		0xF2C60080
+#define	F367_OFDM_SFEC_K_DIVIDER_34		0xF2C6007F
+
+/* SFKDIV56 */
+#define	R367_OFDM_SFKDIV56		0xF2C7
+#define	F367_OFDM_SFECKDIV56_MAN		0xF2C70080
+#define	F367_OFDM_SFEC_K_DIVIDER_56		0xF2C7007F
+
+/* SFKDIV67 */
+#define	R367_OFDM_SFKDIV67		0xF2C8
+#define	F367_OFDM_SFECKDIV67_MAN		0xF2C80080
+#define	F367_OFDM_SFEC_K_DIVIDER_67		0xF2C8007F
+
+/* SFKDIV78 */
+#define	R367_OFDM_SFKDIV78		0xF2C9
+#define	F367_OFDM_SFECKDIV78_MAN		0xF2C90080
+#define	F367_OFDM_SFEC_K_DIVIDER_78		0xF2C9007F
+
+/* SFDILSTKM */
+#define	R367_OFDM_SFDILSTKM		0xF2CA
+#define	F367_OFDM_SFEC_PACKCPT		0xF2CA00E0
+#define	F367_OFDM_SFEC_DILSTK_HI		0xF2CA001F
+
+/* SFDILSTKL */
+#define	R367_OFDM_SFDILSTKL		0xF2CB
+#define	F367_OFDM_SFEC_DILSTK_LO		0xF2CB00FF
+
+/* SFSTATUS */
+#define	R367_OFDM_SFSTATUS		0xF2CC
+#define	F367_OFDM_SFEC_LINEOK		0xF2CC0080
+#define	F367_OFDM_SFEC_ERROR		0xF2CC0040
+#define	F367_OFDM_SFEC_DATA7		0xF2CC0020
+#define	F367_OFDM_SFEC_OVERFLOW		0xF2CC0010
+#define	F367_OFDM_SFEC_DEMODSEL2		0xF2CC0008
+#define	F367_OFDM_SFEC_NOSYNC		0xF2CC0004
+#define	F367_OFDM_SFEC_UNREGULA		0xF2CC0002
+#define	F367_OFDM_SFEC_READY		0xF2CC0001
+
+/* SFDLYH */
+#define	R367_OFDM_SFDLYH		0xF2CD
+#define	F367_OFDM_SFEC_TSTIMEVALID		0xF2CD0080
+#define	F367_OFDM_SFEC_SPEEDUP		0xF2CD0040
+#define	F367_OFDM_SFEC_STOP		0xF2CD0020
+#define	F367_OFDM_SFEC_REGULATED		0xF2CD0010
+#define	F367_OFDM_SFEC_REALSYMBOFFSET		0xF2CD000F
+
+/* SFDLYM */
+#define	R367_OFDM_SFDLYM		0xF2CE
+#define	F367_OFDM_SFEC_REALSYMBOFFSET_HI		0xF2CE00FF
+
+/* SFDLYL */
+#define	R367_OFDM_SFDLYL		0xF2CF
+#define	F367_OFDM_SFEC_REALSYMBOFFSET_LO		0xF2CF00FF
+
+/* SFDLYSETH */
+#define	R367_OFDM_SFDLYSETH		0xF2D0
+#define	F367_OFDM_SFEC_OFFSET		0xF2D000E0
+#define	F367_OFDM_SFECDLYSETH_4		0xF2D00010
+#define	F367_OFDM_RST_SFEC		0xF2D00008
+#define	F367_OFDM_SFECDLYSETH_2		0xF2D00004
+#define	F367_OFDM_SFEC_DISABLE		0xF2D00002
+#define	F367_OFDM_SFEC_UNREGUL		0xF2D00001
+
+/* SFDLYSETM */
+#define	R367_OFDM_SFDLYSETM		0xF2D1
+#define	F367_OFDM_SFECDLYSETM_7		0xF2D10080
+#define	F367_OFDM_SFEC_SYMBOFFSET_HI		0xF2D1007F
+
+/* SFDLYSETL */
+#define	R367_OFDM_SFDLYSETL		0xF2D2
+#define	F367_OFDM_SFEC_SYMBOFFSET_LO		0xF2D200FF
+
+/* SFOBSCFG */
+#define	R367_OFDM_SFOBSCFG		0xF2D3
+#define	F367_OFDM_SFEC_OBSCFG		0xF2D300FF
+
+/* SFOBSM */
+#define	R367_OFDM_SFOBSM		0xF2D4
+#define	F367_OFDM_SFEC_OBSDATA_HI		0xF2D400FF
+
+/* SFOBSL */
+#define	R367_OFDM_SFOBSL		0xF2D5
+#define	F367_OFDM_SFEC_OBSDATA_LO		0xF2D500FF
+
+/* SFECINFO */
+#define	R367_OFDM_SFECINFO		0xF2D6
+#define	F367_OFDM_SFECINFO_7		0xF2D60080
+#define	F367_OFDM_SFEC_SYNCDLSB		0xF2D60070
+#define	F367_OFDM_SFCE_S1CPHASE		0xF2D6000F
+
+/* SFERRCTRL */
+#define	R367_OFDM_SFERRCTRL		0xF2D8
+#define	F367_OFDM_SFEC_ERR_SOURCE		0xF2D800F0
+#define	F367_OFDM_SFERRCTRL_3		0xF2D80008
+#define	F367_OFDM_SFEC_NUM_EVENT		0xF2D80007
+
+/* SFERRCNTH */
+#define	R367_OFDM_SFERRCNTH		0xF2D9
+#define	F367_OFDM_SFERRC_OLDVALUE		0xF2D90080
+#define	F367_OFDM_SFEC_ERR_CNT		0xF2D9007F
+
+/* SFERRCNTM */
+#define	R367_OFDM_SFERRCNTM		0xF2DA
+#define	F367_OFDM_SFEC_ERR_CNT_HI		0xF2DA00FF
+
+/* SFERRCNTL */
+#define	R367_OFDM_SFERRCNTL		0xF2DB
+#define	F367_OFDM_SFEC_ERR_CNT_LO		0xF2DB00FF
+
+/* SYMBRATEM */
+#define	R367_OFDM_SYMBRATEM		0xF2E0
+#define	F367_OFDM_DEFGEN_SYMBRATE_HI		0xF2E000FF
+
+/* SYMBRATEL */
+#define	R367_OFDM_SYMBRATEL		0xF2E1
+#define	F367_OFDM_DEFGEN_SYMBRATE_LO		0xF2E100FF
+
+/* SYMBSTATUS */
+#define	R367_OFDM_SYMBSTATUS		0xF2E2
+#define	F367_OFDM_SYMBDLINE2_OFF		0xF2E20080
+#define	F367_OFDM_SDDL_REINIT1		0xF2E20040
+#define	F367_OFDM_SDD_REINIT1		0xF2E20020
+#define	F367_OFDM_TOKENID_ERROR		0xF2E20010
+#define	F367_OFDM_SYMBRATE_OVERFLOW		0xF2E20008
+#define	F367_OFDM_SYMBRATE_UNDERFLOW		0xF2E20004
+#define	F367_OFDM_TOKENID_RSTEVENT		0xF2E20002
+#define	F367_OFDM_TOKENID_RESET1		0xF2E20001
+
+/* SYMBCFG */
+#define	R367_OFDM_SYMBCFG		0xF2E3
+#define	F367_OFDM_SYMBCFG_7		0xF2E30080
+#define	F367_OFDM_SYMBCFG_6		0xF2E30040
+#define	F367_OFDM_SYMBCFG_5		0xF2E30020
+#define	F367_OFDM_SYMBCFG_4		0xF2E30010
+#define	F367_OFDM_SYMRATE_FSPEED		0xF2E3000C
+#define	F367_OFDM_SYMRATE_SSPEED		0xF2E30003
+
+/* SYMBFIFOM */
+#define	R367_OFDM_SYMBFIFOM		0xF2E4
+#define	F367_OFDM_SYMBFIFOM_7		0xF2E40080
+#define	F367_OFDM_SYMBFIFOM_6		0xF2E40040
+#define	F367_OFDM_DEFGEN_SYMFIFO_HI		0xF2E4003F
+
+/* SYMBFIFOL */
+#define	R367_OFDM_SYMBFIFOL		0xF2E5
+#define	F367_OFDM_DEFGEN_SYMFIFO_LO		0xF2E500FF
+
+/* SYMBOFFSM */
+#define	R367_OFDM_SYMBOFFSM		0xF2E6
+#define	F367_OFDM_TOKENID_RESET2		0xF2E60080
+#define	F367_OFDM_SDDL_REINIT2		0xF2E60040
+#define	F367_OFDM_SDD_REINIT2		0xF2E60020
+#define	F367_OFDM_SYMBOFFSM_4		0xF2E60010
+#define	F367_OFDM_SYMBOFFSM_3		0xF2E60008
+#define	F367_OFDM_DEFGEN_SYMBOFFSET_HI		0xF2E60007
+
+/* SYMBOFFSL */
+#define	R367_OFDM_SYMBOFFSL		0xF2E7
+#define	F367_OFDM_DEFGEN_SYMBOFFSET_LO		0xF2E700FF
+
+/* DEBUG_LT4 */
+#define	R367_DEBUG_LT4		0xF400
+#define	F367_F_DEBUG_LT4		0xF40000FF
+
+/* DEBUG_LT5 */
+#define	R367_DEBUG_LT5		0xF401
+#define	F367_F_DEBUG_LT5		0xF40100FF
+
+/* DEBUG_LT6 */
+#define	R367_DEBUG_LT6		0xF402
+#define	F367_F_DEBUG_LT6		0xF40200FF
+
+/* DEBUG_LT7 */
+#define	R367_DEBUG_LT7		0xF403
+#define	F367_F_DEBUG_LT7		0xF40300FF
+
+/* DEBUG_LT8 */
+#define	R367_DEBUG_LT8		0xF404
+#define	F367_F_DEBUG_LT8		0xF40400FF
+
+/* DEBUG_LT9 */
+#define	R367_DEBUG_LT9		0xF405
+#define	F367_F_DEBUG_LT9		0xF40500FF
+
+/* CTRL_1 */
+#define	R367_QAM_CTRL_1		0xF402
+#define	F367_QAM_SOFT_RST		0xF4020080
+#define	F367_QAM_EQU_RST		0xF4020008
+#define	F367_QAM_CRL_RST		0xF4020004
+#define	F367_QAM_TRL_RST		0xF4020002
+#define	F367_QAM_AGC_RST		0xF4020001
+
+/* CTRL_2 */
+#define	R367_QAM_CTRL_2		0xF403
+#define	F367_QAM_DEINT_RST		0xF4030008
+#define	F367_QAM_RS_RST		0xF4030004
+
+/* IT_STATUS1 */
+#define	R367_QAM_IT_STATUS1		0xF408
+#define	F367_QAM_SWEEP_OUT		0xF4080080
+#define	F367_QAM_FSM_CRL		0xF4080040
+#define	F367_QAM_CRL_LOCK		0xF4080020
+#define	F367_QAM_MFSM		0xF4080010
+#define	F367_QAM_TRL_LOCK		0xF4080008
+#define	F367_QAM_TRL_AGC_LIMIT		0xF4080004
+#define	F367_QAM_ADJ_AGC_LOCK		0xF4080002
+#define	F367_QAM_AGC_QAM_LOCK		0xF4080001
+
+/* IT_STATUS2 */
+#define	R367_QAM_IT_STATUS2		0xF409
+#define	F367_QAM_TSMF_CNT		0xF4090080
+#define	F367_QAM_TSMF_EOF		0xF4090040
+#define	F367_QAM_TSMF_RDY		0xF4090020
+#define	F367_QAM_FEC_NOCORR		0xF4090010
+#define	F367_QAM_SYNCSTATE		0xF4090008
+#define	F367_QAM_DEINT_LOCK		0xF4090004
+#define	F367_QAM_FADDING_FRZ		0xF4090002
+#define	F367_QAM_TAPMON_ALARM		0xF4090001
+
+/* IT_EN1 */
+#define	R367_QAM_IT_EN1		0xF40A
+#define	F367_QAM_SWEEP_OUTE		0xF40A0080
+#define	F367_QAM_FSM_CRLE		0xF40A0040
+#define	F367_QAM_CRL_LOCKE		0xF40A0020
+#define	F367_QAM_MFSME		0xF40A0010
+#define	F367_QAM_TRL_LOCKE		0xF40A0008
+#define	F367_QAM_TRL_AGC_LIMITE		0xF40A0004
+#define	F367_QAM_ADJ_AGC_LOCKE		0xF40A0002
+#define	F367_QAM_AGC_LOCKE		0xF40A0001
+
+/* IT_EN2 */
+#define	R367_QAM_IT_EN2		0xF40B
+#define	F367_QAM_TSMF_CNTE		0xF40B0080
+#define	F367_QAM_TSMF_EOFE		0xF40B0040
+#define	F367_QAM_TSMF_RDYE		0xF40B0020
+#define	F367_QAM_FEC_NOCORRE		0xF40B0010
+#define	F367_QAM_SYNCSTATEE		0xF40B0008
+#define	F367_QAM_DEINT_LOCKE		0xF40B0004
+#define	F367_QAM_FADDING_FRZE		0xF40B0002
+#define	F367_QAM_TAPMON_ALARME		0xF40B0001
+
+/* CTRL_STATUS */
+#define	R367_QAM_CTRL_STATUS		0xF40C
+#define	F367_QAM_QAMFEC_LOCK		0xF40C0004
+#define	F367_QAM_TSMF_LOCK		0xF40C0002
+#define	F367_QAM_TSMF_ERROR		0xF40C0001
+
+/* TEST_CTL */
+#define	R367_QAM_TEST_CTL		0xF40F
+#define	F367_QAM_TST_BLK_SEL		0xF40F0060
+#define	F367_QAM_TST_BUS_SEL		0xF40F001F
+
+/* AGC_CTL */
+#define	R367_QAM_AGC_CTL		0xF410
+#define	F367_QAM_AGC_LCK_TH		0xF41000F0
+#define	F367_QAM_AGC_ACCUMRSTSEL		0xF4100007
+
+/* AGC_IF_CFG */
+#define	R367_QAM_AGC_IF_CFG		0xF411
+#define	F367_QAM_AGC_IF_BWSEL		0xF41100F0
+#define	F367_QAM_AGC_IF_FREEZE		0xF4110002
+
+/* AGC_RF_CFG */
+#define	R367_QAM_AGC_RF_CFG		0xF412
+#define	F367_QAM_AGC_RF_BWSEL		0xF4120070
+#define	F367_QAM_AGC_RF_FREEZE		0xF4120002
+
+/* AGC_PWM_CFG */
+#define	R367_QAM_AGC_PWM_CFG		0xF413
+#define	F367_QAM_AGC_RF_PWM_TST		0xF4130080
+#define	F367_QAM_AGC_RF_PWM_INV		0xF4130040
+#define	F367_QAM_AGC_IF_PWM_TST		0xF4130008
+#define	F367_QAM_AGC_IF_PWM_INV		0xF4130004
+#define	F367_QAM_AGC_PWM_CLKDIV		0xF4130003
+
+/* AGC_PWR_REF_L */
+#define	R367_QAM_AGC_PWR_REF_L		0xF414
+#define	F367_QAM_AGC_PWRREF_LO		0xF41400FF
+
+/* AGC_PWR_REF_H */
+#define	R367_QAM_AGC_PWR_REF_H		0xF415
+#define	F367_QAM_AGC_PWRREF_HI		0xF4150003
+
+/* AGC_RF_TH_L */
+#define	R367_QAM_AGC_RF_TH_L		0xF416
+#define	F367_QAM_AGC_RF_TH_LO		0xF41600FF
+
+/* AGC_RF_TH_H */
+#define	R367_QAM_AGC_RF_TH_H		0xF417
+#define	F367_QAM_AGC_RF_TH_HI		0xF417000F
+
+/* AGC_IF_LTH_L */
+#define	R367_QAM_AGC_IF_LTH_L		0xF418
+#define	F367_QAM_AGC_IF_THLO_LO		0xF41800FF
+
+/* AGC_IF_LTH_H */
+#define	R367_QAM_AGC_IF_LTH_H		0xF419
+#define	F367_QAM_AGC_IF_THLO_HI		0xF419000F
+
+/* AGC_IF_HTH_L */
+#define	R367_QAM_AGC_IF_HTH_L		0xF41A
+#define	F367_QAM_AGC_IF_THHI_LO		0xF41A00FF
+
+/* AGC_IF_HTH_H */
+#define	R367_QAM_AGC_IF_HTH_H		0xF41B
+#define	F367_QAM_AGC_IF_THHI_HI		0xF41B000F
+
+/* AGC_PWR_RD_L */
+#define	R367_QAM_AGC_PWR_RD_L		0xF41C
+#define	F367_QAM_AGC_PWR_WORD_LO		0xF41C00FF
+
+/* AGC_PWR_RD_M */
+#define	R367_QAM_AGC_PWR_RD_M		0xF41D
+#define	F367_QAM_AGC_PWR_WORD_ME		0xF41D00FF
+
+/* AGC_PWR_RD_H */
+#define	R367_QAM_AGC_PWR_RD_H		0xF41E
+#define	F367_QAM_AGC_PWR_WORD_HI		0xF41E0003
+
+/* AGC_PWM_IFCMD_L */
+#define	R367_QAM_AGC_PWM_IFCMD_L		0xF420
+#define	F367_QAM_AGC_IF_PWMCMD_LO		0xF42000FF
+
+/* AGC_PWM_IFCMD_H */
+#define	R367_QAM_AGC_PWM_IFCMD_H		0xF421
+#define	F367_QAM_AGC_IF_PWMCMD_HI		0xF421000F
+
+/* AGC_PWM_RFCMD_L */
+#define	R367_QAM_AGC_PWM_RFCMD_L		0xF422
+#define	F367_QAM_AGC_RF_PWMCMD_LO		0xF42200FF
+
+/* AGC_PWM_RFCMD_H */
+#define	R367_QAM_AGC_PWM_RFCMD_H		0xF423
+#define	F367_QAM_AGC_RF_PWMCMD_HI		0xF423000F
+
+/* IQDEM_CFG */
+#define	R367_QAM_IQDEM_CFG		0xF424
+#define	F367_QAM_IQDEM_CLK_SEL		0xF4240004
+#define	F367_QAM_IQDEM_INVIQ		0xF4240002
+#define	F367_QAM_IQDEM_A2DTYPE		0xF4240001
+
+/* MIX_NCO_LL */
+#define	R367_QAM_MIX_NCO_LL		0xF425
+#define	F367_QAM_MIX_NCO_INC_LL		0xF42500FF
+
+/* MIX_NCO_HL */
+#define	R367_QAM_MIX_NCO_HL		0xF426
+#define	F367_QAM_MIX_NCO_INC_HL		0xF42600FF
+
+/* MIX_NCO_HH */
+#define	R367_QAM_MIX_NCO_HH		0xF427
+#define	F367_QAM_MIX_NCO_INVCNST		0xF4270080
+#define	F367_QAM_MIX_NCO_INC_HH		0xF427007F
+
+/* SRC_NCO_LL */
+#define	R367_QAM_SRC_NCO_LL		0xF428
+#define	F367_QAM_SRC_NCO_INC_LL		0xF42800FF
+
+/* SRC_NCO_LH */
+#define	R367_QAM_SRC_NCO_LH		0xF429
+#define	F367_QAM_SRC_NCO_INC_LH		0xF42900FF
+
+/* SRC_NCO_HL */
+#define	R367_QAM_SRC_NCO_HL		0xF42A
+#define	F367_QAM_SRC_NCO_INC_HL		0xF42A00FF
+
+/* SRC_NCO_HH */
+#define	R367_QAM_SRC_NCO_HH		0xF42B
+#define	F367_QAM_SRC_NCO_INC_HH		0xF42B007F
+
+/* IQDEM_GAIN_SRC_L */
+#define	R367_QAM_IQDEM_GAIN_SRC_L		0xF42C
+#define	F367_QAM_GAIN_SRC_LO		0xF42C00FF
+
+/* IQDEM_GAIN_SRC_H */
+#define	R367_QAM_IQDEM_GAIN_SRC_H		0xF42D
+#define	F367_QAM_GAIN_SRC_HI		0xF42D0003
+
+/* IQDEM_DCRM_CFG_LL */
+#define	R367_QAM_IQDEM_DCRM_CFG_LL		0xF430
+#define	F367_QAM_DCRM0_DCIN_L		0xF43000FF
+
+/* IQDEM_DCRM_CFG_LH */
+#define	R367_QAM_IQDEM_DCRM_CFG_LH		0xF431
+#define	F367_QAM_DCRM1_I_DCIN_L		0xF43100FC
+#define	F367_QAM_DCRM0_DCIN_H		0xF4310003
+
+/* IQDEM_DCRM_CFG_HL */
+#define	R367_QAM_IQDEM_DCRM_CFG_HL		0xF432
+#define	F367_QAM_DCRM1_Q_DCIN_L		0xF43200F0
+#define	F367_QAM_DCRM1_I_DCIN_H		0xF432000F
+
+/* IQDEM_DCRM_CFG_HH */
+#define	R367_QAM_IQDEM_DCRM_CFG_HH		0xF433
+#define	F367_QAM_DCRM1_FRZ		0xF4330080
+#define	F367_QAM_DCRM0_FRZ		0xF4330040
+#define	F367_QAM_DCRM1_Q_DCIN_H		0xF433003F
+
+/* IQDEM_ADJ_COEFF0 */
+#define	R367_QAM_IQDEM_ADJ_COEFF0		0xF434
+#define	F367_QAM_ADJIIR_COEFF10_L		0xF43400FF
+
+/* IQDEM_ADJ_COEFF1 */
+#define	R367_QAM_IQDEM_ADJ_COEFF1		0xF435
+#define	F367_QAM_ADJIIR_COEFF11_L		0xF43500FC
+#define	F367_QAM_ADJIIR_COEFF10_H		0xF4350003
+
+/* IQDEM_ADJ_COEFF2 */
+#define	R367_QAM_IQDEM_ADJ_COEFF2		0xF436
+#define	F367_QAM_ADJIIR_COEFF12_L		0xF43600F0
+#define	F367_QAM_ADJIIR_COEFF11_H		0xF436000F
+
+/* IQDEM_ADJ_COEFF3 */
+#define	R367_QAM_IQDEM_ADJ_COEFF3		0xF437
+#define	F367_QAM_ADJIIR_COEFF20_L		0xF43700C0
+#define	F367_QAM_ADJIIR_COEFF12_H		0xF437003F
+
+/* IQDEM_ADJ_COEFF4 */
+#define	R367_QAM_IQDEM_ADJ_COEFF4		0xF438
+#define	F367_QAM_ADJIIR_COEFF20_H		0xF43800FF
+
+/* IQDEM_ADJ_COEFF5 */
+#define	R367_QAM_IQDEM_ADJ_COEFF5		0xF439
+#define	F367_QAM_ADJIIR_COEFF21_L		0xF43900FF
+
+/* IQDEM_ADJ_COEFF6 */
+#define	R367_QAM_IQDEM_ADJ_COEFF6		0xF43A
+#define	F367_QAM_ADJIIR_COEFF22_L		0xF43A00FC
+#define	F367_QAM_ADJIIR_COEFF21_H		0xF43A0003
+
+/* IQDEM_ADJ_COEFF7 */
+#define	R367_QAM_IQDEM_ADJ_COEFF7		0xF43B
+#define	F367_QAM_ADJIIR_COEFF22_H		0xF43B000F
+
+/* IQDEM_ADJ_EN */
+#define	R367_QAM_IQDEM_ADJ_EN		0xF43C
+#define	F367_QAM_ALLPASSFILT_EN		0xF43C0008
+#define	F367_QAM_ADJ_AGC_EN		0xF43C0004
+#define	F367_QAM_ADJ_COEFF_FRZ		0xF43C0002
+#define	F367_QAM_ADJ_EN		0xF43C0001
+
+/* IQDEM_ADJ_AGC_REF */
+#define	R367_QAM_IQDEM_ADJ_AGC_REF		0xF43D
+#define	F367_QAM_ADJ_AGC_REF		0xF43D00FF
+
+/* ALLPASSFILT1 */
+#define	R367_QAM_ALLPASSFILT1		0xF440
+#define	F367_QAM_ALLPASSFILT_COEFF1_LO		0xF44000FF
+
+/* ALLPASSFILT2 */
+#define	R367_QAM_ALLPASSFILT2		0xF441
+#define	F367_QAM_ALLPASSFILT_COEFF1_ME		0xF44100FF
+
+/* ALLPASSFILT3 */
+#define	R367_QAM_ALLPASSFILT3		0xF442
+#define	F367_QAM_ALLPASSFILT_COEFF2_LO		0xF44200C0
+#define	F367_QAM_ALLPASSFILT_COEFF1_HI		0xF442003F
+
+/* ALLPASSFILT4 */
+#define	R367_QAM_ALLPASSFILT4		0xF443
+#define	F367_QAM_ALLPASSFILT_COEFF2_MEL		0xF44300FF
+
+/* ALLPASSFILT5 */
+#define	R367_QAM_ALLPASSFILT5		0xF444
+#define	F367_QAM_ALLPASSFILT_COEFF2_MEH		0xF44400FF
+
+/* ALLPASSFILT6 */
+#define	R367_QAM_ALLPASSFILT6		0xF445
+#define	F367_QAM_ALLPASSFILT_COEFF3_LO		0xF44500F0
+#define	F367_QAM_ALLPASSFILT_COEFF2_HI		0xF445000F
+
+/* ALLPASSFILT7 */
+#define	R367_QAM_ALLPASSFILT7		0xF446
+#define	F367_QAM_ALLPASSFILT_COEFF3_MEL		0xF44600FF
+
+/* ALLPASSFILT8 */
+#define	R367_QAM_ALLPASSFILT8		0xF447
+#define	F367_QAM_ALLPASSFILT_COEFF3_MEH		0xF44700FF
+
+/* ALLPASSFILT9 */
+#define	R367_QAM_ALLPASSFILT9		0xF448
+#define	F367_QAM_ALLPASSFILT_COEFF4_LO		0xF44800FC
+#define	F367_QAM_ALLPASSFILT_COEFF3_HI		0xF4480003
+
+/* ALLPASSFILT10 */
+#define	R367_QAM_ALLPASSFILT10		0xF449
+#define	F367_QAM_ALLPASSFILT_COEFF4_ME		0xF44900FF
+
+/* ALLPASSFILT11 */
+#define	R367_QAM_ALLPASSFILT11		0xF44A
+#define	F367_QAM_ALLPASSFILT_COEFF4_HI		0xF44A00FF
+
+/* TRL_AGC_CFG */
+#define	R367_QAM_TRL_AGC_CFG		0xF450
+#define	F367_QAM_TRL_AGC_FREEZE		0xF4500080
+#define	F367_QAM_TRL_AGC_REF		0xF450007F
+
+/* TRL_LPF_CFG */
+#define	R367_QAM_TRL_LPF_CFG		0xF454
+#define	F367_QAM_NYQPOINT_INV		0xF4540040
+#define	F367_QAM_TRL_SHIFT		0xF4540030
+#define	F367_QAM_NYQ_COEFF_SEL		0xF454000C
+#define	F367_QAM_TRL_LPF_FREEZE		0xF4540002
+#define	F367_QAM_TRL_LPF_CRT		0xF4540001
+
+/* TRL_LPF_ACQ_GAIN */
+#define	R367_QAM_TRL_LPF_ACQ_GAIN		0xF455
+#define	F367_QAM_TRL_GDIR_ACQ		0xF4550070
+#define	F367_QAM_TRL_GINT_ACQ		0xF4550007
+
+/* TRL_LPF_TRK_GAIN */
+#define	R367_QAM_TRL_LPF_TRK_GAIN		0xF456
+#define	F367_QAM_TRL_GDIR_TRK		0xF4560070
+#define	F367_QAM_TRL_GINT_TRK		0xF4560007
+
+/* TRL_LPF_OUT_GAIN */
+#define	R367_QAM_TRL_LPF_OUT_GAIN		0xF457
+#define	F367_QAM_TRL_GAIN_OUT		0xF4570007
+
+/* TRL_LOCKDET_LTH */
+#define	R367_QAM_TRL_LOCKDET_LTH		0xF458
+#define	F367_QAM_TRL_LCK_THLO		0xF4580007
+
+/* TRL_LOCKDET_HTH */
+#define	R367_QAM_TRL_LOCKDET_HTH		0xF459
+#define	F367_QAM_TRL_LCK_THHI		0xF45900FF
+
+/* TRL_LOCKDET_TRGVAL */
+#define	R367_QAM_TRL_LOCKDET_TRGVAL		0xF45A
+#define	F367_QAM_TRL_LCK_TRG		0xF45A00FF
+
+/* IQ_QAM */
+#define	R367_QAM_IQ_QAM		0xF45C
+#define	F367_QAM_IQ_INPUT		0xF45C0008
+#define	F367_QAM_DETECT_MODE		0xF45C0007
+
+/* FSM_STATE */
+#define	R367_QAM_FSM_STATE		0xF460
+#define	F367_QAM_CRL_DFE		0xF4600080
+#define	F367_QAM_DFE_START		0xF4600040
+#define	F367_QAM_CTRLG_START		0xF4600030
+#define	F367_QAM_FSM_FORCESTATE		0xF460000F
+
+/* FSM_CTL */
+#define	R367_QAM_FSM_CTL		0xF461
+#define	F367_QAM_FEC2_EN		0xF4610040
+#define	F367_QAM_SIT_EN		0xF4610020
+#define	F367_QAM_TRL_AHEAD		0xF4610010
+#define	F367_QAM_TRL2_EN		0xF4610008
+#define	F367_QAM_FSM_EQA1_EN		0xF4610004
+#define	F367_QAM_FSM_BKP_DIS		0xF4610002
+#define	F367_QAM_FSM_FORCE_EN		0xF4610001
+
+/* FSM_STS */
+#define	R367_QAM_FSM_STS		0xF462
+#define	F367_QAM_FSM_STATUS		0xF462000F
+
+/* FSM_SNR0_HTH */
+#define	R367_QAM_FSM_SNR0_HTH		0xF463
+#define	F367_QAM_SNR0_HTH		0xF46300FF
+
+/* FSM_SNR1_HTH */
+#define	R367_QAM_FSM_SNR1_HTH		0xF464
+#define	F367_QAM_SNR1_HTH		0xF46400FF
+
+/* FSM_SNR2_HTH */
+#define	R367_QAM_FSM_SNR2_HTH		0xF465
+#define	F367_QAM_SNR2_HTH		0xF46500FF
+
+/* FSM_SNR0_LTH */
+#define	R367_QAM_FSM_SNR0_LTH		0xF466
+#define	F367_QAM_SNR0_LTH		0xF46600FF
+
+/* FSM_SNR1_LTH */
+#define	R367_QAM_FSM_SNR1_LTH		0xF467
+#define	F367_QAM_SNR1_LTH		0xF46700FF
+
+/* FSM_EQA1_HTH */
+#define	R367_QAM_FSM_EQA1_HTH		0xF468
+#define	F367_QAM_SNR3_HTH_LO		0xF46800F0
+#define	F367_QAM_EQA1_HTH		0xF468000F
+
+/* FSM_TEMPO */
+#define	R367_QAM_FSM_TEMPO		0xF469
+#define	F367_QAM_SIT		0xF46900C0
+#define	F367_QAM_WST		0xF4690038
+#define	F367_QAM_ELT		0xF4690006
+#define	F367_QAM_SNR3_HTH_HI		0xF4690001
+
+/* FSM_CONFIG */
+#define	R367_QAM_FSM_CONFIG		0xF46A
+#define	F367_QAM_FEC2_DFEOFF		0xF46A0004
+#define	F367_QAM_PRIT_STATE		0xF46A0002
+#define	F367_QAM_MODMAP_STATE		0xF46A0001
+
+/* EQU_I_TESTTAP_L */
+#define	R367_QAM_EQU_I_TESTTAP_L		0xF474
+#define	F367_QAM_I_TEST_TAP_L		0xF47400FF
+
+/* EQU_I_TESTTAP_M */
+#define	R367_QAM_EQU_I_TESTTAP_M		0xF475
+#define	F367_QAM_I_TEST_TAP_M		0xF47500FF
+
+/* EQU_I_TESTTAP_H */
+#define	R367_QAM_EQU_I_TESTTAP_H		0xF476
+#define	F367_QAM_I_TEST_TAP_H		0xF476001F
+
+/* EQU_TESTAP_CFG */
+#define	R367_QAM_EQU_TESTAP_CFG		0xF477
+#define	F367_QAM_TEST_FFE_DFE_SEL		0xF4770040
+#define	F367_QAM_TEST_TAP_SELECT		0xF477003F
+
+/* EQU_Q_TESTTAP_L */
+#define	R367_QAM_EQU_Q_TESTTAP_L		0xF478
+#define	F367_QAM_Q_TEST_TAP_L		0xF47800FF
+
+/* EQU_Q_TESTTAP_M */
+#define	R367_QAM_EQU_Q_TESTTAP_M		0xF479
+#define	F367_QAM_Q_TEST_TAP_M		0xF47900FF
+
+/* EQU_Q_TESTTAP_H */
+#define	R367_QAM_EQU_Q_TESTTAP_H		0xF47A
+#define	F367_QAM_Q_TEST_TAP_H		0xF47A001F
+
+/* EQU_TAP_CTRL */
+#define	R367_QAM_EQU_TAP_CTRL		0xF47B
+#define	F367_QAM_MTAP_FRZ		0xF47B0010
+#define	F367_QAM_PRE_FREEZE		0xF47B0008
+#define	F367_QAM_DFE_TAPMON_EN		0xF47B0004
+#define	F367_QAM_FFE_TAPMON_EN		0xF47B0002
+#define	F367_QAM_MTAP_ONLY		0xF47B0001
+
+/* EQU_CTR_CRL_CONTROL_L */
+#define	R367_QAM_EQU_CTR_CRL_CONTROL_L		0xF47C
+#define	F367_QAM_EQU_CTR_CRL_CONTROL_LO		0xF47C00FF
+
+/* EQU_CTR_CRL_CONTROL_H */
+#define	R367_QAM_EQU_CTR_CRL_CONTROL_H		0xF47D
+#define	F367_QAM_EQU_CTR_CRL_CONTROL_HI		0xF47D00FF
+
+/* EQU_CTR_HIPOW_L */
+#define	R367_QAM_EQU_CTR_HIPOW_L		0xF47E
+#define	F367_QAM_CTR_HIPOW_L		0xF47E00FF
+
+/* EQU_CTR_HIPOW_H */
+#define	R367_QAM_EQU_CTR_HIPOW_H		0xF47F
+#define	F367_QAM_CTR_HIPOW_H		0xF47F00FF
+
+/* EQU_I_EQU_LO */
+#define	R367_QAM_EQU_I_EQU_LO		0xF480
+#define	F367_QAM_EQU_I_EQU_L		0xF48000FF
+
+/* EQU_I_EQU_HI */
+#define	R367_QAM_EQU_I_EQU_HI		0xF481
+#define	F367_QAM_EQU_I_EQU_H		0xF4810003
+
+/* EQU_Q_EQU_LO */
+#define	R367_QAM_EQU_Q_EQU_LO		0xF482
+#define	F367_QAM_EQU_Q_EQU_L		0xF48200FF
+
+/* EQU_Q_EQU_HI */
+#define	R367_QAM_EQU_Q_EQU_HI		0xF483
+#define	F367_QAM_EQU_Q_EQU_H		0xF4830003
+
+/* EQU_MAPPER */
+#define	R367_QAM_EQU_MAPPER		0xF484
+#define	F367_QAM_QUAD_AUTO		0xF4840080
+#define	F367_QAM_QUAD_INV		0xF4840040
+#define	F367_QAM_QAM_MODE		0xF4840007
+
+/* EQU_SWEEP_RATE */
+#define	R367_QAM_EQU_SWEEP_RATE		0xF485
+#define	F367_QAM_SNR_PER		0xF48500C0
+#define	F367_QAM_SWEEP_RATE		0xF485003F
+
+/* EQU_SNR_LO */
+#define	R367_QAM_EQU_SNR_LO		0xF486
+#define	F367_QAM_SNR_LO		0xF48600FF
+
+/* EQU_SNR_HI */
+#define	R367_QAM_EQU_SNR_HI		0xF487
+#define	F367_QAM_SNR_HI		0xF48700FF
+
+/* EQU_GAMMA_LO */
+#define	R367_QAM_EQU_GAMMA_LO		0xF488
+#define	F367_QAM_GAMMA_LO		0xF48800FF
+
+/* EQU_GAMMA_HI */
+#define	R367_QAM_EQU_GAMMA_HI		0xF489
+#define	F367_QAM_GAMMA_ME		0xF48900FF
+
+/* EQU_ERR_GAIN */
+#define	R367_QAM_EQU_ERR_GAIN		0xF48A
+#define	F367_QAM_EQA1MU		0xF48A0070
+#define	F367_QAM_CRL2MU		0xF48A000E
+#define	F367_QAM_GAMMA_HI		0xF48A0001
+
+/* EQU_RADIUS */
+#define	R367_QAM_EQU_RADIUS		0xF48B
+#define	F367_QAM_RADIUS		0xF48B00FF
+
+/* EQU_FFE_MAINTAP */
+#define	R367_QAM_EQU_FFE_MAINTAP		0xF48C
+#define	F367_QAM_FFE_MAINTAP_INIT		0xF48C00FF
+
+/* EQU_FFE_LEAKAGE */
+#define	R367_QAM_EQU_FFE_LEAKAGE		0xF48E
+#define	F367_QAM_LEAK_PER		0xF48E00F0
+#define	F367_QAM_EQU_OUTSEL		0xF48E0002
+#define	F367_QAM_PNT2DFE		0xF48E0001
+
+/* EQU_FFE_MAINTAP_POS */
+#define	R367_QAM_EQU_FFE_MAINTAP_POS		0xF48F
+#define	F367_QAM_FFE_LEAK_EN		0xF48F0080
+#define	F367_QAM_DFE_LEAK_EN		0xF48F0040
+#define	F367_QAM_FFE_MAINTAP_POS		0xF48F003F
+
+/* EQU_GAIN_WIDE */
+#define	R367_QAM_EQU_GAIN_WIDE		0xF490
+#define	F367_QAM_DFE_GAIN_WIDE		0xF49000F0
+#define	F367_QAM_FFE_GAIN_WIDE		0xF490000F
+
+/* EQU_GAIN_NARROW */
+#define	R367_QAM_EQU_GAIN_NARROW		0xF491
+#define	F367_QAM_DFE_GAIN_NARROW		0xF49100F0
+#define	F367_QAM_FFE_GAIN_NARROW		0xF491000F
+
+/* EQU_CTR_LPF_GAIN */
+#define	R367_QAM_EQU_CTR_LPF_GAIN		0xF492
+#define	F367_QAM_CTR_GTO		0xF4920080
+#define	F367_QAM_CTR_GDIR		0xF4920070
+#define	F367_QAM_SWEEP_EN		0xF4920008
+#define	F367_QAM_CTR_GINT		0xF4920007
+
+/* EQU_CRL_LPF_GAIN */
+#define	R367_QAM_EQU_CRL_LPF_GAIN		0xF493
+#define	F367_QAM_CRL_GTO		0xF4930080
+#define	F367_QAM_CRL_GDIR		0xF4930070
+#define	F367_QAM_SWEEP_DIR		0xF4930008
+#define	F367_QAM_CRL_GINT		0xF4930007
+
+/* EQU_GLOBAL_GAIN */
+#define	R367_QAM_EQU_GLOBAL_GAIN		0xF494
+#define	F367_QAM_CRL_GAIN		0xF49400F8
+#define	F367_QAM_CTR_INC_GAIN		0xF4940004
+#define	F367_QAM_CTR_FRAC		0xF4940003
+
+/* EQU_CRL_LD_SEN */
+#define	R367_QAM_EQU_CRL_LD_SEN		0xF495
+#define	F367_QAM_CTR_BADPOINT_EN		0xF4950080
+#define	F367_QAM_CTR_GAIN		0xF4950070
+#define	F367_QAM_LIMANEN		0xF4950008
+#define	F367_QAM_CRL_LD_SEN		0xF4950007
+
+/* EQU_CRL_LD_VAL */
+#define	R367_QAM_EQU_CRL_LD_VAL		0xF496
+#define	F367_QAM_CRL_BISTH_LIMIT		0xF4960080
+#define	F367_QAM_CARE_EN		0xF4960040
+#define	F367_QAM_CRL_LD_PER		0xF4960030
+#define	F367_QAM_CRL_LD_WST		0xF496000C
+#define	F367_QAM_CRL_LD_TFS		0xF4960003
+
+/* EQU_CRL_TFR */
+#define	R367_QAM_EQU_CRL_TFR		0xF497
+#define	F367_QAM_CRL_LD_TFR		0xF49700FF
+
+/* EQU_CRL_BISTH_LO */
+#define	R367_QAM_EQU_CRL_BISTH_LO		0xF498
+#define	F367_QAM_CRL_BISTH_LO		0xF49800FF
+
+/* EQU_CRL_BISTH_HI */
+#define	R367_QAM_EQU_CRL_BISTH_HI		0xF499
+#define	F367_QAM_CRL_BISTH_HI		0xF49900FF
+
+/* EQU_SWEEP_RANGE_LO */
+#define	R367_QAM_EQU_SWEEP_RANGE_LO		0xF49A
+#define	F367_QAM_SWEEP_RANGE_LO		0xF49A00FF
+
+/* EQU_SWEEP_RANGE_HI */
+#define	R367_QAM_EQU_SWEEP_RANGE_HI		0xF49B
+#define	F367_QAM_SWEEP_RANGE_HI		0xF49B00FF
+
+/* EQU_CRL_LIMITER */
+#define	R367_QAM_EQU_CRL_LIMITER		0xF49C
+#define	F367_QAM_BISECTOR_EN		0xF49C0080
+#define	F367_QAM_PHEST128_EN		0xF49C0040
+#define	F367_QAM_CRL_LIM		0xF49C003F
+
+/* EQU_MODULUS_MAP */
+#define	R367_QAM_EQU_MODULUS_MAP		0xF49D
+#define	F367_QAM_PNT_DEPTH		0xF49D00E0
+#define	F367_QAM_MODULUS_CMP		0xF49D001F
+
+/* EQU_PNT_GAIN */
+#define	R367_QAM_EQU_PNT_GAIN		0xF49E
+#define	F367_QAM_PNT_EN		0xF49E0080
+#define	F367_QAM_MODULUSMAP_EN		0xF49E0040
+#define	F367_QAM_PNT_GAIN		0xF49E003F
+
+/* FEC_AC_CTR_0 */
+#define	R367_QAM_FEC_AC_CTR_0		0xF4A8
+#define	F367_QAM_BE_BYPASS		0xF4A80020
+#define	F367_QAM_REFRESH47		0xF4A80010
+#define	F367_QAM_CT_NBST		0xF4A80008
+#define	F367_QAM_TEI_ENA		0xF4A80004
+#define	F367_QAM_DS_ENA		0xF4A80002
+#define	F367_QAM_TSMF_EN		0xF4A80001
+
+/* FEC_AC_CTR_1 */
+#define	R367_QAM_FEC_AC_CTR_1		0xF4A9
+#define	F367_QAM_DEINT_DEPTH		0xF4A900FF
+
+/* FEC_AC_CTR_2 */
+#define	R367_QAM_FEC_AC_CTR_2		0xF4AA
+#define	F367_QAM_DEINT_M		0xF4AA00F8
+#define	F367_QAM_DIS_UNLOCK		0xF4AA0004
+#define	F367_QAM_DESCR_MODE		0xF4AA0003
+
+/* FEC_AC_CTR_3 */
+#define	R367_QAM_FEC_AC_CTR_3		0xF4AB
+#define	F367_QAM_DI_UNLOCK		0xF4AB0080
+#define	F367_QAM_DI_FREEZE		0xF4AB0040
+#define	F367_QAM_MISMATCH		0xF4AB0030
+#define	F367_QAM_ACQ_MODE		0xF4AB000C
+#define	F367_QAM_TRK_MODE		0xF4AB0003
+
+/* FEC_STATUS */
+#define	R367_QAM_FEC_STATUS		0xF4AC
+#define	F367_QAM_DEINT_SMCNTR		0xF4AC00E0
+#define	F367_QAM_DEINT_SYNCSTATE		0xF4AC0018
+#define	F367_QAM_DEINT_SYNLOST		0xF4AC0004
+#define	F367_QAM_DESCR_SYNCSTATE		0xF4AC0002
+
+/* RS_COUNTER_0 */
+#define	R367_QAM_RS_COUNTER_0		0xF4AE
+#define	F367_QAM_BK_CT_L		0xF4AE00FF
+
+/* RS_COUNTER_1 */
+#define	R367_QAM_RS_COUNTER_1		0xF4AF
+#define	F367_QAM_BK_CT_H		0xF4AF00FF
+
+/* RS_COUNTER_2 */
+#define	R367_QAM_RS_COUNTER_2		0xF4B0
+#define	F367_QAM_CORR_CT_L		0xF4B000FF
+
+/* RS_COUNTER_3 */
+#define	R367_QAM_RS_COUNTER_3		0xF4B1
+#define	F367_QAM_CORR_CT_H		0xF4B100FF
+
+/* RS_COUNTER_4 */
+#define	R367_QAM_RS_COUNTER_4		0xF4B2
+#define	F367_QAM_UNCORR_CT_L		0xF4B200FF
+
+/* RS_COUNTER_5 */
+#define	R367_QAM_RS_COUNTER_5		0xF4B3
+#define	F367_QAM_UNCORR_CT_H		0xF4B300FF
+
+/* BERT_0 */
+#define	R367_QAM_BERT_0		0xF4B4
+#define	F367_QAM_RS_NOCORR		0xF4B40004
+#define	F367_QAM_CT_HOLD		0xF4B40002
+#define	F367_QAM_CT_CLEAR		0xF4B40001
+
+/* BERT_1 */
+#define	R367_QAM_BERT_1		0xF4B5
+#define	F367_QAM_BERT_ON		0xF4B50020
+#define	F367_QAM_BERT_ERR_SRC		0xF4B50010
+#define	F367_QAM_BERT_ERR_MODE		0xF4B50008
+#define	F367_QAM_BERT_NBYTE		0xF4B50007
+
+/* BERT_2 */
+#define	R367_QAM_BERT_2		0xF4B6
+#define	F367_QAM_BERT_ERRCOUNT_L		0xF4B600FF
+
+/* BERT_3 */
+#define	R367_QAM_BERT_3		0xF4B7
+#define	F367_QAM_BERT_ERRCOUNT_H		0xF4B700FF
+
+/* OUTFORMAT_0 */
+#define	R367_QAM_OUTFORMAT_0		0xF4B8
+#define	F367_QAM_CLK_POLARITY		0xF4B80080
+#define	F367_QAM_FEC_TYPE		0xF4B80040
+#define	F367_QAM_SYNC_STRIP		0xF4B80008
+#define	F367_QAM_TS_SWAP		0xF4B80004
+#define	F367_QAM_OUTFORMAT		0xF4B80003
+
+/* OUTFORMAT_1 */
+#define	R367_QAM_OUTFORMAT_1		0xF4B9
+#define	F367_QAM_CI_DIVRANGE		0xF4B900FF
+
+/* SMOOTHER_2 */
+#define	R367_QAM_SMOOTHER_2		0xF4BE
+#define	F367_QAM_FIFO_BYPASS		0xF4BE0020
+
+/* TSMF_CTRL_0 */
+#define	R367_QAM_TSMF_CTRL_0		0xF4C0
+#define	F367_QAM_TS_NUMBER		0xF4C0001E
+#define	F367_QAM_SEL_MODE		0xF4C00001
+
+/* TSMF_CTRL_1 */
+#define	R367_QAM_TSMF_CTRL_1		0xF4C1
+#define	F367_QAM_CHECK_ERROR_BIT		0xF4C10080
+#define	F367_QAM_CHCK_F_SYNC		0xF4C10040
+#define	F367_QAM_H_MODE		0xF4C10008
+#define	F367_QAM_D_V_MODE		0xF4C10004
+#define	F367_QAM_MODE		0xF4C10003
+
+/* TSMF_CTRL_3 */
+#define	R367_QAM_TSMF_CTRL_3		0xF4C3
+#define	F367_QAM_SYNC_IN_COUNT		0xF4C300F0
+#define	F367_QAM_SYNC_OUT_COUNT		0xF4C3000F
+
+/* TS_ON_ID_0 */
+#define	R367_QAM_TS_ON_ID_0		0xF4C4
+#define	F367_QAM_TS_ID_L		0xF4C400FF
+
+/* TS_ON_ID_1 */
+#define	R367_QAM_TS_ON_ID_1		0xF4C5
+#define	F367_QAM_TS_ID_H		0xF4C500FF
+
+/* TS_ON_ID_2 */
+#define	R367_QAM_TS_ON_ID_2		0xF4C6
+#define	F367_QAM_ON_ID_L		0xF4C600FF
+
+/* TS_ON_ID_3 */
+#define	R367_QAM_TS_ON_ID_3		0xF4C7
+#define	F367_QAM_ON_ID_H		0xF4C700FF
+
+/* RE_STATUS_0 */
+#define	R367_QAM_RE_STATUS_0		0xF4C8
+#define	F367_QAM_RECEIVE_STATUS_L		0xF4C800FF
+
+/* RE_STATUS_1 */
+#define	R367_QAM_RE_STATUS_1		0xF4C9
+#define	F367_QAM_RECEIVE_STATUS_LH		0xF4C900FF
+
+/* RE_STATUS_2 */
+#define	R367_QAM_RE_STATUS_2		0xF4CA
+#define	F367_QAM_RECEIVE_STATUS_HL		0xF4CA00FF
+
+/* RE_STATUS_3 */
+#define	R367_QAM_RE_STATUS_3		0xF4CB
+#define	F367_QAM_RECEIVE_STATUS_HH		0xF4CB003F
+
+/* TS_STATUS_0 */
+#define	R367_QAM_TS_STATUS_0		0xF4CC
+#define	F367_QAM_TS_STATUS_L		0xF4CC00FF
+
+/* TS_STATUS_1 */
+#define	R367_QAM_TS_STATUS_1		0xF4CD
+#define	F367_QAM_TS_STATUS_H		0xF4CD007F
+
+/* TS_STATUS_2 */
+#define	R367_QAM_TS_STATUS_2		0xF4CE
+#define	F367_QAM_ERROR		0xF4CE0080
+#define	F367_QAM_EMERGENCY		0xF4CE0040
+#define	F367_QAM_CRE_TS		0xF4CE0030
+#define	F367_QAM_VER		0xF4CE000E
+#define	F367_QAM_M_LOCK		0xF4CE0001
+
+/* TS_STATUS_3 */
+#define	R367_QAM_TS_STATUS_3		0xF4CF
+#define	F367_QAM_UPDATE_READY		0xF4CF0080
+#define	F367_QAM_END_FRAME_HEADER		0xF4CF0040
+#define	F367_QAM_CONTCNT		0xF4CF0020
+#define	F367_QAM_TS_IDENTIFIER_SEL		0xF4CF000F
+
+/* T_O_ID_0 */
+#define	R367_QAM_T_O_ID_0		0xF4D0
+#define	F367_QAM_ON_ID_I_L		0xF4D000FF
+
+/* T_O_ID_1 */
+#define	R367_QAM_T_O_ID_1		0xF4D1
+#define	F367_QAM_ON_ID_I_H		0xF4D100FF
+
+/* T_O_ID_2 */
+#define	R367_QAM_T_O_ID_2		0xF4D2
+#define	F367_QAM_TS_ID_I_L		0xF4D200FF
+
+/* T_O_ID_3 */
+#define	R367_QAM_T_O_ID_3		0xF4D3
+#define	F367_QAM_TS_ID_I_H		0xF4D300FF
diff --git a/drivers/media/dvb-frontends/stv0910.c b/drivers/media/dvb-frontends/stv0910.c
new file mode 100644
index 0000000..730ba5f
--- /dev/null
+++ b/drivers/media/dvb-frontends/stv0910.c
@@ -0,0 +1,1526 @@
+/*
+ * Driver for the ST STV0910 DVB-S/S2 demodulator.
+ *
+ * Copyright (C) 2014-2015 Ralph Metzler <rjkm@metzlerbros.de>
+ *                         Marcus Metzler <mocm@metzlerbros.de>
+ *                         developed for Digital Devices GmbH
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 only, as published by the Free Software Foundation.
+ *
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA
+ * Or, point your browser to http://www.gnu.org/copyleft/gpl.html
+ */
+
+#undef pr_fmt
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/firmware.h>
+#include <linux/i2c.h>
+#include <asm/div64.h>
+
+#include "dvb_math.h"
+#include "dvb_frontend.h"
+#include "stv0910.h"
+#include "stv0910_regs.h"
+
+#define INTLOG10X100(x) ((u32) (((u64) intlog10(x) * 100) >> 24))
+
+#define TUNING_DELAY    200
+#define BER_SRC_S    0x20
+#define BER_SRC_S2   0x20
+
+LIST_HEAD(stvlist);
+
+enum ReceiveMode { Mode_None, Mode_DVBS, Mode_DVBS2, Mode_Auto };
+
+enum DVBS2_FECType { DVBS2_64K, DVBS2_16K };
+
+enum DVBS2_ModCod {
+	DVBS2_DUMMY_PLF, DVBS2_QPSK_1_4, DVBS2_QPSK_1_3, DVBS2_QPSK_2_5,
+	DVBS2_QPSK_1_2, DVBS2_QPSK_3_5, DVBS2_QPSK_2_3,	DVBS2_QPSK_3_4,
+	DVBS2_QPSK_4_5,	DVBS2_QPSK_5_6,	DVBS2_QPSK_8_9,	DVBS2_QPSK_9_10,
+	DVBS2_8PSK_3_5,	DVBS2_8PSK_2_3,	DVBS2_8PSK_3_4,	DVBS2_8PSK_5_6,
+	DVBS2_8PSK_8_9,	DVBS2_8PSK_9_10, DVBS2_16APSK_2_3, DVBS2_16APSK_3_4,
+	DVBS2_16APSK_4_5, DVBS2_16APSK_5_6, DVBS2_16APSK_8_9, DVBS2_16APSK_9_10,
+	DVBS2_32APSK_3_4, DVBS2_32APSK_4_5, DVBS2_32APSK_5_6, DVBS2_32APSK_8_9,
+	DVBS2_32APSK_9_10
+};
+
+enum FE_STV0910_ModCod {
+	FE_DUMMY_PLF, FE_QPSK_14, FE_QPSK_13, FE_QPSK_25,
+	FE_QPSK_12, FE_QPSK_35, FE_QPSK_23, FE_QPSK_34,
+	FE_QPSK_45, FE_QPSK_56, FE_QPSK_89, FE_QPSK_910,
+	FE_8PSK_35, FE_8PSK_23, FE_8PSK_34, FE_8PSK_56,
+	FE_8PSK_89, FE_8PSK_910, FE_16APSK_23, FE_16APSK_34,
+	FE_16APSK_45, FE_16APSK_56, FE_16APSK_89, FE_16APSK_910,
+	FE_32APSK_34, FE_32APSK_45, FE_32APSK_56, FE_32APSK_89,
+	FE_32APSK_910
+};
+
+enum FE_STV0910_RollOff { FE_SAT_35, FE_SAT_25, FE_SAT_20, FE_SAT_15 };
+
+static inline u32 MulDiv32(u32 a, u32 b, u32 c)
+{
+	u64 tmp64;
+
+	tmp64 = (u64)a * (u64)b;
+	do_div(tmp64, c);
+
+	return (u32) tmp64;
+}
+
+struct stv_base {
+	struct list_head     stvlist;
+
+	u8                   adr;
+	struct i2c_adapter  *i2c;
+	struct mutex         i2c_lock;
+	struct mutex         reg_lock;
+	int                  count;
+
+	u32                  extclk;
+	u32                  mclk;
+};
+
+struct stv {
+	struct stv_base     *base;
+	struct dvb_frontend  fe;
+	int                  nr;
+	u16                  regoff;
+	u8                   i2crpt;
+	u8                   tscfgh;
+	u8                   tsgeneral;
+	u8                   tsspeed;
+	unsigned long        tune_time;
+
+	s32                  SearchRange;
+	u32                  Started;
+	u32                  DemodLockTime;
+	enum ReceiveMode     ReceiveMode;
+	u32                  DemodTimeout;
+	u32                  FecTimeout;
+	u32                  FirstTimeLock;
+	u8                   DEMOD;
+	u32                  SymbolRate;
+
+	u8                      LastViterbiRate;
+	enum fe_code_rate       PunctureRate;
+	enum FE_STV0910_ModCod  ModCod;
+	enum DVBS2_FECType      FECType;
+	u32                     Pilots;
+	enum FE_STV0910_RollOff FERollOff;
+
+	u32   LastBERNumerator;
+	u32   LastBERDenominator;
+	u8    BERScale;
+};
+
+struct SInitTable {
+	u16  Address;
+	u8   Data;
+};
+
+struct SLookup {
+	s16  Value;
+	u16  RegValue;
+};
+
+static inline int i2c_write(struct i2c_adapter *adap, u8 adr,
+			    u8 *data, int len)
+{
+	struct i2c_msg msg = {.addr = adr, .flags = 0,
+			      .buf = data, .len = len};
+
+	if (i2c_transfer(adap, &msg, 1) != 1) {
+		pr_warn("i2c_write_error ([%02x] %04x: %02x)\n",
+			adr, (data[0] << 8) | data[1],
+			(len > 2 ? data[2] : 0));
+		return -EREMOTEIO;
+	}
+	return 0;
+}
+
+static int i2c_write_reg16(struct i2c_adapter *adap, u8 adr, u16 reg, u8 val)
+{
+	u8 msg[3] = {reg >> 8, reg & 0xff, val};
+
+	return i2c_write(adap, adr, msg, 3);
+}
+
+static int write_reg(struct stv *state, u16 reg, u8 val)
+{
+	return i2c_write_reg16(state->base->i2c, state->base->adr, reg, val);
+}
+
+static inline int i2c_read_regs16(struct i2c_adapter *adapter, u8 adr,
+				 u16 reg, u8 *val, int count)
+{
+	u8 msg[2] = {reg >> 8, reg & 0xff};
+	struct i2c_msg msgs[2] = {{.addr = adr, .flags = 0,
+				   .buf  = msg, .len   = 2},
+				  {.addr = adr, .flags = I2C_M_RD,
+				   .buf  = val, .len   = count } };
+
+	if (i2c_transfer(adapter, msgs, 2) != 2) {
+		pr_warn("i2c_read error ([%02x] %04x)\n",
+			adr, reg);
+		return -EREMOTEIO;
+	}
+	return 0;
+}
+
+static int read_reg(struct stv *state, u16 reg, u8 *val)
+{
+	return i2c_read_regs16(state->base->i2c, state->base->adr,
+		reg, val, 1);
+}
+
+static int read_regs(struct stv *state, u16 reg, u8 *val, int len)
+{
+	return i2c_read_regs16(state->base->i2c, state->base->adr,
+			       reg, val, len);
+}
+
+struct SLookup S1_SN_Lookup[] = {
+	{   0,    9242  },  /*C/N=  0dB*/
+	{  05,    9105  },  /*C/N=0.5dB*/
+	{  10,    8950  },  /*C/N=1.0dB*/
+	{  15,    8780  },  /*C/N=1.5dB*/
+	{  20,    8566  },  /*C/N=2.0dB*/
+	{  25,    8366  },  /*C/N=2.5dB*/
+	{  30,    8146  },  /*C/N=3.0dB*/
+	{  35,    7908  },  /*C/N=3.5dB*/
+	{  40,    7666  },  /*C/N=4.0dB*/
+	{  45,    7405  },  /*C/N=4.5dB*/
+	{  50,    7136  },  /*C/N=5.0dB*/
+	{  55,    6861  },  /*C/N=5.5dB*/
+	{  60,    6576  },  /*C/N=6.0dB*/
+	{  65,    6330  },  /*C/N=6.5dB*/
+	{  70,    6048  },  /*C/N=7.0dB*/
+	{  75,    5768  },  /*C/N=7.5dB*/
+	{  80,    5492  },  /*C/N=8.0dB*/
+	{  85,    5224  },  /*C/N=8.5dB*/
+	{  90,    4959  },  /*C/N=9.0dB*/
+	{  95,    4709  },  /*C/N=9.5dB*/
+	{  100,   4467  },  /*C/N=10.0dB*/
+	{  105,   4236  },  /*C/N=10.5dB*/
+	{  110,   4013  },  /*C/N=11.0dB*/
+	{  115,   3800  },  /*C/N=11.5dB*/
+	{  120,   3598  },  /*C/N=12.0dB*/
+	{  125,   3406  },  /*C/N=12.5dB*/
+	{  130,   3225  },  /*C/N=13.0dB*/
+	{  135,   3052  },  /*C/N=13.5dB*/
+	{  140,   2889  },  /*C/N=14.0dB*/
+	{  145,   2733  },  /*C/N=14.5dB*/
+	{  150,   2587  },  /*C/N=15.0dB*/
+	{  160,   2318  },  /*C/N=16.0dB*/
+	{  170,   2077  },  /*C/N=17.0dB*/
+	{  180,   1862  },  /*C/N=18.0dB*/
+	{  190,   1670  },  /*C/N=19.0dB*/
+	{  200,   1499  },  /*C/N=20.0dB*/
+	{  210,   1347  },  /*C/N=21.0dB*/
+	{  220,   1213  },  /*C/N=22.0dB*/
+	{  230,   1095  },  /*C/N=23.0dB*/
+	{  240,    992  },  /*C/N=24.0dB*/
+	{  250,    900  },  /*C/N=25.0dB*/
+	{  260,    826  },  /*C/N=26.0dB*/
+	{  270,    758  },  /*C/N=27.0dB*/
+	{  280,    702  },  /*C/N=28.0dB*/
+	{  290,    653  },  /*C/N=29.0dB*/
+	{  300,    613  },  /*C/N=30.0dB*/
+	{  310,    579  },  /*C/N=31.0dB*/
+	{  320,    550  },  /*C/N=32.0dB*/
+	{  330,    526  },  /*C/N=33.0dB*/
+	{  350,    490  },  /*C/N=33.0dB*/
+	{  400,    445  },  /*C/N=40.0dB*/
+	{  450,    430  },  /*C/N=45.0dB*/
+	{  500,    426  },  /*C/N=50.0dB*/
+	{  510,    425  }   /*C/N=51.0dB*/
+};
+
+struct SLookup S2_SN_Lookup[] = {
+	{  -30,  13950  },  /*C/N=-2.5dB*/
+	{  -25,  13580  },  /*C/N=-2.5dB*/
+	{  -20,  13150  },  /*C/N=-2.0dB*/
+	{  -15,  12760  },  /*C/N=-1.5dB*/
+	{  -10,  12345  },  /*C/N=-1.0dB*/
+	{  -05,  11900  },  /*C/N=-0.5dB*/
+	{    0,  11520  },  /*C/N=   0dB*/
+	{   05,  11080  },  /*C/N= 0.5dB*/
+	{   10,  10630  },  /*C/N= 1.0dB*/
+	{   15,  10210  },  /*C/N= 1.5dB*/
+	{   20,   9790  },  /*C/N= 2.0dB*/
+	{   25,   9390  },  /*C/N= 2.5dB*/
+	{   30,   8970  },  /*C/N= 3.0dB*/
+	{   35,   8575  },  /*C/N= 3.5dB*/
+	{   40,   8180  },  /*C/N= 4.0dB*/
+	{   45,   7800  },  /*C/N= 4.5dB*/
+	{   50,   7430  },  /*C/N= 5.0dB*/
+	{   55,   7080  },  /*C/N= 5.5dB*/
+	{   60,   6720  },  /*C/N= 6.0dB*/
+	{   65,   6320  },  /*C/N= 6.5dB*/
+	{   70,   6060  },  /*C/N= 7.0dB*/
+	{   75,   5760  },  /*C/N= 7.5dB*/
+	{   80,   5480  },  /*C/N= 8.0dB*/
+	{   85,   5200  },  /*C/N= 8.5dB*/
+	{   90,   4930  },  /*C/N= 9.0dB*/
+	{   95,   4680  },  /*C/N= 9.5dB*/
+	{  100,   4425  },  /*C/N=10.0dB*/
+	{  105,   4210  },  /*C/N=10.5dB*/
+	{  110,   3980  },  /*C/N=11.0dB*/
+	{  115,   3765  },  /*C/N=11.5dB*/
+	{  120,   3570  },  /*C/N=12.0dB*/
+	{  125,   3315  },  /*C/N=12.5dB*/
+	{  130,   3140  },  /*C/N=13.0dB*/
+	{  135,   2980  },  /*C/N=13.5dB*/
+	{  140,   2820  },  /*C/N=14.0dB*/
+	{  145,   2670  },  /*C/N=14.5dB*/
+	{  150,   2535  },  /*C/N=15.0dB*/
+	{  160,   2270  },  /*C/N=16.0dB*/
+	{  170,   2035  },  /*C/N=17.0dB*/
+	{  180,   1825  },  /*C/N=18.0dB*/
+	{  190,   1650  },  /*C/N=19.0dB*/
+	{  200,   1485  },  /*C/N=20.0dB*/
+	{  210,   1340  },  /*C/N=21.0dB*/
+	{  220,   1212  },  /*C/N=22.0dB*/
+	{  230,   1100  },  /*C/N=23.0dB*/
+	{  240,   1000  },  /*C/N=24.0dB*/
+	{  250,    910  },  /*C/N=25.0dB*/
+	{  260,    836  },  /*C/N=26.0dB*/
+	{  270,    772  },  /*C/N=27.0dB*/
+	{  280,    718  },  /*C/N=28.0dB*/
+	{  290,    671  },  /*C/N=29.0dB*/
+	{  300,    635  },  /*C/N=30.0dB*/
+	{  310,    602  },  /*C/N=31.0dB*/
+	{  320,    575  },  /*C/N=32.0dB*/
+	{  330,    550  },  /*C/N=33.0dB*/
+	{  350,    517  },  /*C/N=35.0dB*/
+	{  400,    480  },  /*C/N=40.0dB*/
+	{  450,    466  },  /*C/N=45.0dB*/
+	{  500,    464  },  /*C/N=50.0dB*/
+	{  510,    463  },  /*C/N=51.0dB*/
+};
+
+/*********************************************************************
+ * Tracking carrier loop carrier QPSK 1/4 to 8PSK 9/10 long Frame
+ *********************************************************************/
+static u8 S2CarLoop[] =	{
+	/* Modcod  2MPon 2MPoff 5MPon 5MPoff 10MPon 10MPoff
+	 * 20MPon 20MPoff 30MPon 30MPoff
+	 */
+
+	/* FE_QPSK_14  */
+	0x0C,  0x3C,  0x0B,  0x3C,  0x2A,  0x2C,  0x2A,  0x1C,  0x3A,  0x3B,
+	/* FE_QPSK_13  */
+	0x0C,  0x3C,  0x0B,  0x3C,  0x2A,  0x2C,  0x3A,  0x0C,  0x3A,  0x2B,
+	/* FE_QPSK_25  */
+	0x1C,  0x3C,  0x1B,  0x3C,  0x3A,  0x1C,  0x3A,  0x3B,  0x3A,  0x2B,
+	/* FE_QPSK_12  */
+	0x0C,  0x1C,  0x2B,  0x1C,  0x0B,  0x2C,  0x0B,  0x0C,  0x2A,  0x2B,
+	/* FE_QPSK_35  */
+	0x1C,  0x1C,  0x2B,  0x1C,  0x0B,  0x2C,  0x0B,  0x0C,  0x2A,  0x2B,
+	/* FE_QPSK_23  */
+	0x2C,  0x2C,  0x2B,  0x1C,  0x0B,  0x2C,  0x0B,  0x0C,  0x2A,  0x2B,
+	/* FE_QPSK_34  */
+	0x3C,  0x2C,  0x3B,  0x2C,  0x1B,  0x1C,  0x1B,  0x3B,  0x3A,  0x1B,
+	/* FE_QPSK_45  */
+	0x0D,  0x3C,  0x3B,  0x2C,  0x1B,  0x1C,  0x1B,  0x3B,  0x3A,  0x1B,
+	/* FE_QPSK_56  */
+	0x1D,  0x3C,  0x0C,  0x2C,  0x2B,  0x1C,  0x1B,  0x3B,  0x0B,  0x1B,
+	/* FE_QPSK_89  */
+	0x3D,  0x0D,  0x0C,  0x2C,  0x2B,  0x0C,  0x2B,  0x2B,  0x0B,  0x0B,
+	/* FE_QPSK_910 */
+	0x1E,  0x0D,  0x1C,  0x2C,  0x3B,  0x0C,  0x2B,  0x2B,  0x1B,  0x0B,
+	/* FE_8PSK_35  */
+	0x28,  0x09,  0x28,  0x09,  0x28,  0x09,  0x28,  0x08,  0x28,  0x27,
+	/* FE_8PSK_23  */
+	0x19,  0x29,  0x19,  0x29,  0x19,  0x29,  0x38,  0x19,  0x28,  0x09,
+	/* FE_8PSK_34  */
+	0x1A,  0x0B,  0x1A,  0x3A,  0x0A,  0x2A,  0x39,  0x2A,  0x39,  0x1A,
+	/* FE_8PSK_56  */
+	0x2B,  0x2B,  0x1B,  0x1B,  0x0B,  0x1B,  0x1A,  0x0B,  0x1A,  0x1A,
+	/* FE_8PSK_89  */
+	0x0C,  0x0C,  0x3B,  0x3B,  0x1B,  0x1B,  0x2A,  0x0B,  0x2A,  0x2A,
+	/* FE_8PSK_910 */
+	0x0C,  0x1C,  0x0C,  0x3B,  0x2B,  0x1B,  0x3A,  0x0B,  0x2A,  0x2A,
+
+	/**********************************************************************
+	 * Tracking carrier loop carrier 16APSK 2/3 to 32APSK 9/10 long Frame
+	 **********************************************************************/
+
+	/* Modcod 2MPon  2MPoff 5MPon 5MPoff 10MPon 10MPoff 20MPon
+	 * 20MPoff 30MPon 30MPoff
+	 */
+
+	/* FE_16APSK_23  */
+	0x0A,  0x0A,  0x0A,  0x0A,  0x1A,  0x0A,  0x39,  0x0A,  0x29,  0x0A,
+	/* FE_16APSK_34  */
+	0x0A,  0x0A,  0x0A,  0x0A,  0x0B,  0x0A,  0x2A,  0x0A,  0x1A,  0x0A,
+	/* FE_16APSK_45  */
+	0x0A,  0x0A,  0x0A,  0x0A,  0x1B,  0x0A,  0x3A,  0x0A,  0x2A,  0x0A,
+	/* FE_16APSK_56  */
+	0x0A,  0x0A,  0x0A,  0x0A,  0x1B,  0x0A,  0x3A,  0x0A,  0x2A,  0x0A,
+	/* FE_16APSK_89  */
+	0x0A,  0x0A,  0x0A,  0x0A,  0x2B,  0x0A,  0x0B,  0x0A,  0x3A,  0x0A,
+	/* FE_16APSK_910 */
+	0x0A,  0x0A,  0x0A,  0x0A,  0x2B,  0x0A,  0x0B,  0x0A,  0x3A,  0x0A,
+	/* FE_32APSK_34  */
+	0x09,  0x09,  0x09,  0x09,  0x09,  0x09,  0x09,  0x09,  0x09,  0x09,
+	/* FE_32APSK_45  */
+	0x09,  0x09,  0x09,  0x09,  0x09,  0x09,  0x09,  0x09,  0x09,  0x09,
+	/* FE_32APSK_56  */
+	0x09,  0x09,  0x09,  0x09,  0x09,  0x09,  0x09,  0x09,  0x09,  0x09,
+	/* FE_32APSK_89  */
+	0x09,  0x09,  0x09,  0x09,  0x09,  0x09,  0x09,  0x09,  0x09,  0x09,
+	/* FE_32APSK_910 */
+	0x09,  0x09,  0x09,  0x09,  0x09,  0x09,  0x09,  0x09,  0x09,  0x09,
+};
+
+static u8 get_optim_cloop(struct stv *state,
+			  enum FE_STV0910_ModCod ModCod, u32 Pilots)
+{
+	int i = 0;
+
+	if (ModCod >= FE_32APSK_910)
+		i = ((int)FE_32APSK_910 - (int)FE_QPSK_14) * 10;
+	else if (ModCod >= FE_QPSK_14)
+		i = ((int)ModCod - (int)FE_QPSK_14) * 10;
+
+	if (state->SymbolRate <= 3000000)
+		i += 0;
+	else if (state->SymbolRate <=  7000000)
+		i += 2;
+	else if (state->SymbolRate <= 15000000)
+		i += 4;
+	else if (state->SymbolRate <= 25000000)
+		i += 6;
+	else
+		i += 8;
+
+	if (!Pilots)
+		i += 1;
+
+	return S2CarLoop[i];
+}
+
+static int GetCurSymbolRate(struct stv *state, u32 *pSymbolRate)
+{
+	int status = 0;
+	u8 SymbFreq0;
+	u8 SymbFreq1;
+	u8 SymbFreq2;
+	u8 SymbFreq3;
+	u8 TimOffs0;
+	u8 TimOffs1;
+	u8 TimOffs2;
+	u32 SymbolRate;
+	s32 TimingOffset;
+
+	*pSymbolRate = 0;
+	if (!state->Started)
+		return status;
+
+	read_reg(state, RSTV0910_P2_SFR3 + state->regoff, &SymbFreq3);
+	read_reg(state, RSTV0910_P2_SFR2 + state->regoff, &SymbFreq2);
+	read_reg(state, RSTV0910_P2_SFR1 + state->regoff, &SymbFreq1);
+	read_reg(state, RSTV0910_P2_SFR0 + state->regoff, &SymbFreq0);
+	read_reg(state, RSTV0910_P2_TMGREG2 + state->regoff, &TimOffs2);
+	read_reg(state, RSTV0910_P2_TMGREG1 + state->regoff, &TimOffs1);
+	read_reg(state, RSTV0910_P2_TMGREG0 + state->regoff, &TimOffs0);
+
+	SymbolRate = ((u32) SymbFreq3 << 24) | ((u32) SymbFreq2 << 16) |
+		((u32) SymbFreq1 << 8) | (u32) SymbFreq0;
+	TimingOffset = ((u32) TimOffs2 << 16) | ((u32) TimOffs1 << 8) |
+		(u32) TimOffs0;
+
+	if ((TimingOffset & (1<<23)) != 0)
+		TimingOffset |= 0xFF000000; /* Sign extent */
+
+	SymbolRate = (u32) (((u64) SymbolRate * state->base->mclk) >> 32);
+	TimingOffset = (s32) (((s64) SymbolRate * (s64) TimingOffset) >> 29);
+
+	*pSymbolRate = SymbolRate + TimingOffset;
+
+	return 0;
+}
+
+static int GetSignalParameters(struct stv *state)
+{
+	if (!state->Started)
+		return -EINVAL;
+
+	if (state->ReceiveMode == Mode_DVBS2) {
+		u8 tmp;
+		u8 rolloff;
+
+		read_reg(state, RSTV0910_P2_DMDMODCOD + state->regoff, &tmp);
+		state->ModCod = (enum FE_STV0910_ModCod) ((tmp & 0x7c) >> 2);
+		state->Pilots = (tmp & 0x01) != 0;
+		state->FECType = (enum DVBS2_FECType) ((tmp & 0x02) >> 1);
+
+		read_reg(state, RSTV0910_P2_TMGOBS + state->regoff, &rolloff);
+		rolloff = rolloff >> 6;
+		state->FERollOff = (enum FE_STV0910_RollOff) rolloff;
+
+	} else if (state->ReceiveMode == Mode_DVBS) {
+		/* todo */
+	}
+	return 0;
+}
+
+static int TrackingOptimization(struct stv *state)
+{
+	u32 SymbolRate = 0;
+	u8 tmp;
+
+	GetCurSymbolRate(state, &SymbolRate);
+	read_reg(state, RSTV0910_P2_DMDCFGMD + state->regoff, &tmp);
+	tmp &= ~0xC0;
+
+	switch (state->ReceiveMode) {
+	case Mode_DVBS:
+		tmp |= 0x40; break;
+	case Mode_DVBS2:
+		tmp |= 0x80; break;
+	default:
+		tmp |= 0xC0; break;
+	}
+	write_reg(state, RSTV0910_P2_DMDCFGMD + state->regoff, tmp);
+
+	if (state->ReceiveMode == Mode_DVBS2) {
+		/* force to PRE BCH Rate */
+		write_reg(state, RSTV0910_P2_ERRCTRL1 + state->regoff,
+			  BER_SRC_S2 | state->BERScale);
+
+		if (state->FECType == DVBS2_64K) {
+			u8 aclc = get_optim_cloop(state, state->ModCod,
+						  state->Pilots);
+
+			if (state->ModCod <= FE_QPSK_910) {
+				write_reg(state, RSTV0910_P2_ACLC2S2Q +
+					  state->regoff, aclc);
+			} else if (state->ModCod <= FE_8PSK_910) {
+				write_reg(state, RSTV0910_P2_ACLC2S2Q +
+					  state->regoff, 0x2a);
+				write_reg(state, RSTV0910_P2_ACLC2S28 +
+					  state->regoff, aclc);
+			} else if (state->ModCod <= FE_16APSK_910) {
+				write_reg(state, RSTV0910_P2_ACLC2S2Q +
+					  state->regoff, 0x2a);
+				write_reg(state, RSTV0910_P2_ACLC2S216A +
+					  state->regoff, aclc);
+			} else if (state->ModCod <= FE_32APSK_910) {
+				write_reg(state, RSTV0910_P2_ACLC2S2Q +
+					  state->regoff, 0x2a);
+				write_reg(state, RSTV0910_P2_ACLC2S232A +
+					  state->regoff, aclc);
+			}
+		}
+	}
+	if (state->ReceiveMode == Mode_DVBS) {
+		u8 tmp;
+
+		read_reg(state, RSTV0910_P2_VITCURPUN + state->regoff, &tmp);
+		state->PunctureRate = FEC_NONE;
+		switch (tmp & 0x1F) {
+		case 0x0d:
+			state->PunctureRate = FEC_1_2;
+			break;
+		case 0x12:
+			state->PunctureRate = FEC_2_3;
+			break;
+		case 0x15:
+			state->PunctureRate = FEC_3_4;
+			break;
+		case 0x18:
+			state->PunctureRate = FEC_5_6;
+			break;
+		case 0x1A:
+			state->PunctureRate = FEC_7_8;
+			break;
+		}
+	}
+	return 0;
+}
+
+static s32 TableLookup(struct SLookup *Table,
+		       int TableSize, u16 RegValue)
+{
+	s32 Value;
+	int imin = 0;
+	int imax = TableSize - 1;
+	int i;
+	s32 RegDiff;
+
+	/* Assumes Table[0].RegValue > Table[imax].RegValue */
+	if (RegValue >= Table[0].RegValue)
+		Value = Table[0].Value;
+	else if (RegValue <= Table[imax].RegValue)
+		Value = Table[imax].Value;
+	else {
+		while (imax-imin > 1) {
+			i = (imax + imin) / 2;
+			if ((Table[imin].RegValue >= RegValue) &&
+				(RegValue >= Table[i].RegValue))
+				imax = i;
+			else
+				imin = i;
+		}
+
+		RegDiff = Table[imax].RegValue - Table[imin].RegValue;
+		Value = Table[imin].Value;
+		if (RegDiff != 0)
+			Value += ((s32)(RegValue - Table[imin].RegValue) *
+				  (s32)(Table[imax].Value
+					- Table[imin].Value))
+					/ (RegDiff);
+	}
+
+	return Value;
+}
+
+static int GetSignalToNoise(struct stv *state, s32 *SignalToNoise)
+{
+	u8 Data0;
+	u8 Data1;
+	u16 Data;
+	int nLookup;
+	struct SLookup *Lookup;
+
+	*SignalToNoise = 0;
+
+	if (!state->Started)
+		return 0;
+
+	if (state->ReceiveMode == Mode_DVBS2) {
+		read_reg(state, RSTV0910_P2_NNOSPLHT1 + state->regoff, &Data1);
+		read_reg(state, RSTV0910_P2_NNOSPLHT0 + state->regoff, &Data0);
+		nLookup = ARRAY_SIZE(S2_SN_Lookup);
+		Lookup = S2_SN_Lookup;
+	} else {
+		read_reg(state, RSTV0910_P2_NNOSDATAT1 + state->regoff, &Data1);
+		read_reg(state, RSTV0910_P2_NNOSDATAT0 + state->regoff, &Data0);
+		nLookup = ARRAY_SIZE(S1_SN_Lookup);
+		Lookup = S1_SN_Lookup;
+	}
+	Data = (((u16)Data1) << 8) | (u16) Data0;
+	*SignalToNoise = TableLookup(Lookup, nLookup, Data);
+	return 0;
+}
+
+static int GetBitErrorRateS(struct stv *state, u32 *BERNumerator,
+			    u32 *BERDenominator)
+{
+	u8 Regs[3];
+
+	int status = read_regs(state, RSTV0910_P2_ERRCNT12 + state->regoff,
+			       Regs, 3);
+
+	if (status)
+		return -EINVAL;
+
+	if ((Regs[0] & 0x80) == 0) {
+		state->LastBERDenominator = 1 << ((state->BERScale * 2) +
+						  10 + 3);
+		state->LastBERNumerator = ((u32) (Regs[0] & 0x7F) << 16) |
+			((u32) Regs[1] << 8) | Regs[2];
+		if (state->LastBERNumerator < 256 && state->BERScale < 6) {
+			state->BERScale += 1;
+			status = write_reg(state, RSTV0910_P2_ERRCTRL1 +
+					   state->regoff,
+					   0x20 | state->BERScale);
+		} else if (state->LastBERNumerator > 1024 &&
+			   state->BERScale > 2) {
+			state->BERScale -= 1;
+			status = write_reg(state, RSTV0910_P2_ERRCTRL1 +
+					   state->regoff, 0x20 |
+					   state->BERScale);
+		}
+	}
+	*BERNumerator = state->LastBERNumerator;
+	*BERDenominator = state->LastBERDenominator;
+	return 0;
+}
+
+static u32 DVBS2_nBCH(enum DVBS2_ModCod ModCod, enum DVBS2_FECType FECType)
+{
+	static u32 nBCH[][2] = {
+		{16200,  3240}, /* QPSK_1_4, */
+		{21600,  5400}, /* QPSK_1_3, */
+		{25920,  6480}, /* QPSK_2_5, */
+		{32400,  7200}, /* QPSK_1_2, */
+		{38880,  9720}, /* QPSK_3_5, */
+		{43200, 10800}, /* QPSK_2_3, */
+		{48600, 11880}, /* QPSK_3_4, */
+		{51840, 12600}, /* QPSK_4_5, */
+		{54000, 13320}, /* QPSK_5_6, */
+		{57600, 14400}, /* QPSK_8_9, */
+		{58320, 16000}, /* QPSK_9_10, */
+		{43200,  9720}, /* 8PSK_3_5, */
+		{48600, 10800}, /* 8PSK_2_3, */
+		{51840, 11880}, /* 8PSK_3_4, */
+		{54000, 13320}, /* 8PSK_5_6, */
+		{57600, 14400}, /* 8PSK_8_9, */
+		{58320, 16000}, /* 8PSK_9_10, */
+		{43200, 10800}, /* 16APSK_2_3, */
+		{48600, 11880}, /* 16APSK_3_4, */
+		{51840, 12600}, /* 16APSK_4_5, */
+		{54000, 13320}, /* 16APSK_5_6, */
+		{57600, 14400}, /* 16APSK_8_9, */
+		{58320, 16000}, /* 16APSK_9_10 */
+		{48600, 11880}, /* 32APSK_3_4, */
+		{51840, 12600}, /* 32APSK_4_5, */
+		{54000, 13320}, /* 32APSK_5_6, */
+		{57600, 14400}, /* 32APSK_8_9, */
+		{58320, 16000}, /* 32APSK_9_10 */
+	};
+
+	if (ModCod >= DVBS2_QPSK_1_4 &&
+	    ModCod <= DVBS2_32APSK_9_10 && FECType <= DVBS2_16K)
+		return nBCH[FECType][ModCod];
+	return 64800;
+}
+
+static int GetBitErrorRateS2(struct stv *state, u32 *BERNumerator,
+			     u32 *BERDenominator)
+{
+	u8 Regs[3];
+
+	int status = read_regs(state, RSTV0910_P2_ERRCNT12 + state->regoff,
+			       Regs, 3);
+
+	if (status)
+		return -EINVAL;
+
+	if ((Regs[0] & 0x80) == 0) {
+		state->LastBERDenominator =
+			DVBS2_nBCH((enum DVBS2_ModCod) state->ModCod,
+				   state->FECType) <<
+			(state->BERScale * 2);
+		state->LastBERNumerator = (((u32) Regs[0] & 0x7F) << 16) |
+			((u32) Regs[1] << 8) | Regs[2];
+		if (state->LastBERNumerator < 256 && state->BERScale < 6) {
+			state->BERScale += 1;
+			write_reg(state, RSTV0910_P2_ERRCTRL1 + state->regoff,
+				  0x20 | state->BERScale);
+		} else if (state->LastBERNumerator > 1024 &&
+			   state->BERScale > 2) {
+			state->BERScale -= 1;
+			write_reg(state, RSTV0910_P2_ERRCTRL1 + state->regoff,
+				  0x20 | state->BERScale);
+		}
+	}
+	*BERNumerator = state->LastBERNumerator;
+	*BERDenominator = state->LastBERDenominator;
+	return status;
+}
+
+static int GetBitErrorRate(struct stv *state, u32 *BERNumerator,
+			   u32 *BERDenominator)
+{
+	*BERNumerator = 0;
+	*BERDenominator = 1;
+
+	switch (state->ReceiveMode) {
+	case Mode_DVBS:
+		return GetBitErrorRateS(state, BERNumerator, BERDenominator);
+	case Mode_DVBS2:
+		return GetBitErrorRateS2(state, BERNumerator, BERDenominator);
+	default:
+		break;
+	}
+	return 0;
+}
+
+static int set_mclock(struct stv *state, u32 MasterClock)
+{
+	u32 idf = 1;
+	u32 odf = 4;
+	u32 quartz = state->base->extclk / 1000000;
+	u32 Fphi = MasterClock / 1000000;
+	u32 ndiv = (Fphi * odf * idf) / quartz;
+	u32 cp = 7;
+	u32 fvco;
+
+	if (ndiv >= 7 && ndiv <= 71)
+		cp = 7;
+	else if (ndiv >=  72 && ndiv <=  79)
+		cp = 8;
+	else if (ndiv >=  80 && ndiv <=  87)
+		cp = 9;
+	else if (ndiv >=  88 && ndiv <=  95)
+		cp = 10;
+	else if (ndiv >=  96 && ndiv <= 103)
+		cp = 11;
+	else if (ndiv >= 104 && ndiv <= 111)
+		cp = 12;
+	else if (ndiv >= 112 && ndiv <= 119)
+		cp = 13;
+	else if (ndiv >= 120 && ndiv <= 127)
+		cp = 14;
+	else if (ndiv >= 128 && ndiv <= 135)
+		cp = 15;
+	else if (ndiv >= 136 && ndiv <= 143)
+		cp = 16;
+	else if (ndiv >= 144 && ndiv <= 151)
+		cp = 17;
+	else if (ndiv >= 152 && ndiv <= 159)
+		cp = 18;
+	else if (ndiv >= 160 && ndiv <= 167)
+		cp = 19;
+	else if (ndiv >= 168 && ndiv <= 175)
+		cp = 20;
+	else if (ndiv >= 176 && ndiv <= 183)
+		cp = 21;
+	else if (ndiv >= 184 && ndiv <= 191)
+		cp = 22;
+	else if (ndiv >= 192 && ndiv <= 199)
+		cp = 23;
+	else if (ndiv >= 200 && ndiv <= 207)
+		cp = 24;
+	else if (ndiv >= 208 && ndiv <= 215)
+		cp = 25;
+	else if (ndiv >= 216 && ndiv <= 223)
+		cp = 26;
+	else if (ndiv >= 224 && ndiv <= 225)
+		cp = 27;
+
+	write_reg(state, RSTV0910_NCOARSE, (cp << 3) | idf);
+	write_reg(state, RSTV0910_NCOARSE2, odf);
+	write_reg(state, RSTV0910_NCOARSE1, ndiv);
+
+	fvco = (quartz * 2 * ndiv) / idf;
+	state->base->mclk = fvco / (2 * odf) * 1000000;
+
+	return 0;
+}
+
+static int Stop(struct stv *state)
+{
+	if (state->Started) {
+		u8 tmp;
+
+		write_reg(state, RSTV0910_P2_TSCFGH + state->regoff,
+			  state->tscfgh | 0x01);
+		read_reg(state, RSTV0910_P2_PDELCTRL1 + state->regoff, &tmp);
+		tmp &= ~0x01; /*release reset DVBS2 packet delin*/
+		write_reg(state, RSTV0910_P2_PDELCTRL1 + state->regoff, tmp);
+		/* Blind optim*/
+		write_reg(state, RSTV0910_P2_AGC2O + state->regoff, 0x5B);
+		/* Stop the demod */
+		write_reg(state, RSTV0910_P2_DMDISTATE + state->regoff, 0x5c);
+		state->Started = 0;
+	}
+	state->ReceiveMode = Mode_None;
+	return 0;
+}
+
+
+static int Start(struct stv *state, struct dtv_frontend_properties *p)
+{
+	s32 Freq;
+	u8  regDMDCFGMD;
+	u16 symb;
+
+	if (p->symbol_rate < 100000 || p->symbol_rate > 70000000)
+		return -EINVAL;
+
+	state->ReceiveMode = Mode_None;
+	state->DemodLockTime = 0;
+
+	/* Demod Stop*/
+	if (state->Started)
+		write_reg(state, RSTV0910_P2_DMDISTATE + state->regoff, 0x5C);
+
+	if (p->symbol_rate <= 1000000) {  /*SR <=1Msps*/
+		state->DemodTimeout = 3000;
+		state->FecTimeout = 2000;
+	} else if (p->symbol_rate <= 2000000) {  /*1Msps < SR <=2Msps*/
+		state->DemodTimeout = 2500;
+		state->FecTimeout = 1300;
+	} else if (p->symbol_rate <= 5000000) {  /*2Msps< SR <=5Msps*/
+		state->DemodTimeout = 1000;
+	    state->FecTimeout = 650;
+	} else if (p->symbol_rate <= 10000000) {  /*5Msps< SR <=10Msps*/
+		state->DemodTimeout = 700;
+		state->FecTimeout = 350;
+	} else if (p->symbol_rate < 20000000) {  /*10Msps< SR <=20Msps*/
+		state->DemodTimeout = 400;
+		state->FecTimeout = 200;
+	} else {  /*SR >=20Msps*/
+		state->DemodTimeout = 300;
+		state->FecTimeout = 200;
+	}
+
+	/* Set the Init Symbol rate*/
+	symb = MulDiv32(p->symbol_rate, 65536, state->base->mclk);
+	write_reg(state, RSTV0910_P2_SFRINIT1 + state->regoff,
+		  ((symb >> 8) & 0x7F));
+	write_reg(state, RSTV0910_P2_SFRINIT0 + state->regoff, (symb & 0xFF));
+
+	state->DEMOD |= 0x80;
+	write_reg(state, RSTV0910_P2_DEMOD + state->regoff, state->DEMOD);
+
+	/* FE_STV0910_SetSearchStandard */
+	read_reg(state, RSTV0910_P2_DMDCFGMD + state->regoff, &regDMDCFGMD);
+	write_reg(state, RSTV0910_P2_DMDCFGMD + state->regoff,
+		  regDMDCFGMD |= 0xC0);
+
+	/* Disable DSS */
+	write_reg(state, RSTV0910_P2_FECM  + state->regoff, 0x00);
+	write_reg(state, RSTV0910_P2_PRVIT + state->regoff, 0x2F);
+
+	/* 8PSK 3/5, 8PSK 2/3 Poff tracking optimization WA*/
+	write_reg(state, RSTV0910_P2_ACLC2S2Q + state->regoff, 0x0B);
+	write_reg(state, RSTV0910_P2_ACLC2S28 + state->regoff, 0x0A);
+	write_reg(state, RSTV0910_P2_BCLC2S2Q + state->regoff, 0x84);
+	write_reg(state, RSTV0910_P2_BCLC2S28 + state->regoff, 0x84);
+	write_reg(state, RSTV0910_P2_CARHDR + state->regoff, 0x1C);
+	/* Reset demod */
+	write_reg(state, RSTV0910_P2_DMDISTATE + state->regoff, 0x1F);
+
+	write_reg(state, RSTV0910_P2_CARCFG + state->regoff, 0x46);
+
+	Freq = (state->SearchRange / 2000) + 600;
+	if (p->symbol_rate <= 5000000)
+		Freq -= (600 + 80);
+	Freq = (Freq << 16) / (state->base->mclk / 1000);
+
+	write_reg(state, RSTV0910_P2_CFRUP1 + state->regoff,
+		  (Freq >> 8) & 0xff);
+	write_reg(state, RSTV0910_P2_CFRUP0 + state->regoff, (Freq & 0xff));
+	/*CFR Low Setting*/
+	Freq = -Freq;
+	write_reg(state, RSTV0910_P2_CFRLOW1 + state->regoff,
+		  (Freq >> 8) & 0xff);
+	write_reg(state, RSTV0910_P2_CFRLOW0 + state->regoff, (Freq & 0xff));
+
+	/* init the demod frequency offset to 0 */
+	write_reg(state, RSTV0910_P2_CFRINIT1 + state->regoff, 0);
+	write_reg(state, RSTV0910_P2_CFRINIT0 + state->regoff, 0);
+
+	write_reg(state, RSTV0910_P2_DMDISTATE + state->regoff, 0x1F);
+	/* Trigger acq */
+	write_reg(state, RSTV0910_P2_DMDISTATE + state->regoff, 0x15);
+
+	state->DemodLockTime += TUNING_DELAY;
+	state->Started = 1;
+
+	return 0;
+}
+
+static int init_diseqc(struct stv *state)
+{
+	u16 offs = state->nr ? 0x40 : 0;  /* Address offset */
+	u8 Freq = ((state->base->mclk + 11000 * 32) / (22000 * 32));
+
+	/* Disable receiver */
+	write_reg(state, RSTV0910_P1_DISRXCFG + offs, 0x00);
+	write_reg(state, RSTV0910_P1_DISTXCFG + offs, 0xBA); /* Reset = 1 */
+	write_reg(state, RSTV0910_P1_DISTXCFG + offs, 0x3A); /* Reset = 0 */
+	write_reg(state, RSTV0910_P1_DISTXF22 + offs, Freq);
+	return 0;
+}
+
+static int probe(struct stv *state)
+{
+	u8 id;
+
+	state->ReceiveMode = Mode_None;
+	state->Started = 0;
+
+	if (read_reg(state, RSTV0910_MID, &id) < 0)
+		return -ENODEV;
+
+	if (id != 0x51)
+		return -EINVAL;
+
+	 /* Configure the I2C repeater to off */
+	write_reg(state, RSTV0910_P1_I2CRPT, 0x24);
+	/* Configure the I2C repeater to off */
+	write_reg(state, RSTV0910_P2_I2CRPT, 0x24);
+	/* Set the I2C to oversampling ratio */
+	write_reg(state, RSTV0910_I2CCFG, 0x88);
+
+	write_reg(state, RSTV0910_OUTCFG,    0x00);  /* OUTCFG */
+	write_reg(state, RSTV0910_PADCFG,    0x05);  /* RF AGC Pads Dev = 05 */
+	write_reg(state, RSTV0910_SYNTCTRL,  0x02);  /* SYNTCTRL */
+	write_reg(state, RSTV0910_TSGENERAL, state->tsgeneral);  /* TSGENERAL */
+	write_reg(state, RSTV0910_CFGEXT,    0x02);  /* CFGEXT */
+	write_reg(state, RSTV0910_GENCFG,    0x15);  /* GENCFG */
+
+
+	write_reg(state, RSTV0910_TSTRES0, 0x80); /* LDPC Reset */
+	write_reg(state, RSTV0910_TSTRES0, 0x00);
+
+	set_mclock(state, 135000000);
+
+	/* TS output */
+	write_reg(state, RSTV0910_P1_TSCFGH, state->tscfgh | 0x01);
+	write_reg(state, RSTV0910_P1_TSCFGH, state->tscfgh);
+	write_reg(state, RSTV0910_P1_TSCFGM, 0xC0);  /* Manual speed */
+	write_reg(state, RSTV0910_P1_TSCFGL, 0x20);
+
+	/* Speed = 67.5 MHz */
+	write_reg(state, RSTV0910_P1_TSSPEED, state->tsspeed);
+
+	write_reg(state, RSTV0910_P2_TSCFGH, state->tscfgh | 0x01);
+	write_reg(state, RSTV0910_P2_TSCFGH, state->tscfgh);
+	write_reg(state, RSTV0910_P2_TSCFGM, 0xC0);  /* Manual speed */
+	write_reg(state, RSTV0910_P2_TSCFGL, 0x20);
+
+	/* Speed = 67.5 MHz */
+	write_reg(state, RSTV0910_P2_TSSPEED, state->tsspeed);
+
+	/* Reset stream merger */
+	write_reg(state, RSTV0910_P1_TSCFGH, state->tscfgh | 0x01);
+	write_reg(state, RSTV0910_P2_TSCFGH, state->tscfgh | 0x01);
+	write_reg(state, RSTV0910_P1_TSCFGH, state->tscfgh);
+	write_reg(state, RSTV0910_P2_TSCFGH, state->tscfgh);
+
+	write_reg(state, RSTV0910_P1_I2CRPT, state->i2crpt);
+	write_reg(state, RSTV0910_P2_I2CRPT, state->i2crpt);
+
+	init_diseqc(state);
+	return 0;
+}
+
+
+static int gate_ctrl(struct dvb_frontend *fe, int enable)
+{
+	struct stv *state = fe->demodulator_priv;
+	u8 i2crpt = state->i2crpt & ~0x86;
+
+	if (enable)
+		mutex_lock(&state->base->i2c_lock);
+
+	if (enable)
+		i2crpt |= 0x80;
+	else
+		i2crpt |= 0x02;
+
+	if (write_reg(state, state->nr ? RSTV0910_P2_I2CRPT :
+		      RSTV0910_P1_I2CRPT, i2crpt) < 0)
+		return -EIO;
+
+	state->i2crpt = i2crpt;
+
+	if (!enable)
+		mutex_unlock(&state->base->i2c_lock);
+	return 0;
+}
+
+static void release(struct dvb_frontend *fe)
+{
+	struct stv *state = fe->demodulator_priv;
+
+	state->base->count--;
+	if (state->base->count == 0) {
+		list_del(&state->base->stvlist);
+		kfree(state->base);
+	}
+	kfree(state);
+}
+
+static int set_parameters(struct dvb_frontend *fe)
+{
+	int stat = 0;
+	struct stv *state = fe->demodulator_priv;
+	u32 IF;
+	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
+
+	Stop(state);
+	if (fe->ops.tuner_ops.set_params)
+		fe->ops.tuner_ops.set_params(fe);
+	if (fe->ops.tuner_ops.get_if_frequency)
+		fe->ops.tuner_ops.get_if_frequency(fe, &IF);
+	state->SymbolRate = p->symbol_rate;
+	stat = Start(state, p);
+	return stat;
+}
+
+static int read_snr(struct dvb_frontend *fe, u16 *snr)
+{
+	struct stv *state = fe->demodulator_priv;
+	s32 SNR;
+
+	*snr = 0;
+	if (GetSignalToNoise(state, &SNR))
+		return -EIO;
+
+	*snr = 100 * SNR;
+
+	return 0;
+}
+
+static int read_ber(struct dvb_frontend *fe, u32 *ber, u32 *n, u32 *d)
+{
+	struct stv *state = fe->demodulator_priv;
+
+	*n = 0;
+	*d = 1;
+
+	GetBitErrorRate(state, n, d);
+	if (d)
+		*ber = *n / *d;
+	else
+		*ber = 0;
+
+	return 0;
+}
+
+static int read_signal_strength(struct dvb_frontend *fe, u16 *strength)
+{
+	struct stv *state = fe->demodulator_priv;
+	u8 Reg[2];
+	s32 bbgain;
+	s32 Power = 0;
+	int i;
+
+	read_regs(state, RSTV0910_P2_AGCIQIN1 + state->regoff, Reg, 2);
+
+	*strength = (((u32) Reg[0]) << 8) | Reg[1];
+
+	for (i = 0; i < 5; i += 1) {
+		read_regs(state, RSTV0910_P2_POWERI + state->regoff, Reg, 2);
+		Power += (u32) Reg[0] * (u32) Reg[0]
+			+ (u32) Reg[1] * (u32) Reg[1];
+		usleep_range(3000, 4000);
+	}
+	Power /= 5;
+
+	bbgain = (465 - INTLOG10X100(Power)) * 10;
+
+	if (fe->ops.tuner_ops.get_rf_strength)
+		fe->ops.tuner_ops.get_rf_strength(fe, strength);
+	else
+		*strength = 0;
+
+	if (bbgain < (s32) *strength)
+		*strength -= bbgain;
+	else
+		*strength = 0;
+
+	if (*strength > 0)
+		*strength = 10 * (s64) (s16) *strength - 108750;
+
+	return 0;
+}
+
+static int read_status(struct dvb_frontend *fe, enum fe_status *status)
+{
+	struct stv *state = fe->demodulator_priv;
+	u8 DmdState = 0;
+	u8 DStatus  = 0;
+	enum ReceiveMode CurReceiveMode = Mode_None;
+	u32 FECLock = 0;
+
+	read_reg(state, RSTV0910_P2_DMDSTATE + state->regoff, &DmdState);
+
+	if (DmdState & 0x40) {
+		read_reg(state, RSTV0910_P2_DSTATUS + state->regoff, &DStatus);
+		if (DStatus & 0x08)
+			CurReceiveMode = (DmdState & 0x20) ?
+				Mode_DVBS : Mode_DVBS2;
+	}
+	if (CurReceiveMode == Mode_None) {
+		*status = 0;
+		return 0;
+	}
+
+	*status |= (FE_HAS_SIGNAL
+		| FE_HAS_CARRIER
+		| FE_HAS_VITERBI
+		| FE_HAS_SYNC);
+
+	if (state->ReceiveMode == Mode_None) {
+		state->ReceiveMode = CurReceiveMode;
+		state->DemodLockTime = jiffies;
+		state->FirstTimeLock = 1;
+
+		write_reg(state, RSTV0910_P2_TSCFGH + state->regoff,
+			  state->tscfgh);
+		usleep_range(3000, 4000);
+		write_reg(state, RSTV0910_P2_TSCFGH + state->regoff,
+			  state->tscfgh | 0x01);
+		write_reg(state, RSTV0910_P2_TSCFGH + state->regoff,
+			  state->tscfgh);
+	}
+	if (DmdState & 0x40) {
+		if (state->ReceiveMode == Mode_DVBS2) {
+			u8 PDELStatus;
+
+			read_reg(state,
+				 RSTV0910_P2_PDELSTATUS1 + state->regoff,
+				 &PDELStatus);
+			FECLock = (PDELStatus & 0x02) != 0;
+		} else {
+			u8 VStatus;
+
+			read_reg(state,
+				 RSTV0910_P2_VSTATUSVIT + state->regoff,
+				 &VStatus);
+			FECLock = (VStatus & 0x08) != 0;
+		}
+	}
+
+	if (!FECLock)
+		return 0;
+
+	*status |= FE_HAS_LOCK;
+
+	if (state->FirstTimeLock) {
+		u8 tmp;
+
+		state->FirstTimeLock = 0;
+		GetSignalParameters(state);
+
+		if (state->ReceiveMode == Mode_DVBS2) {
+			/* FSTV0910_P2_MANUALSX_ROLLOFF,
+			 * FSTV0910_P2_MANUALS2_ROLLOFF = 0
+			 */
+			state->DEMOD &= ~0x84;
+			write_reg(state, RSTV0910_P2_DEMOD + state->regoff,
+				  state->DEMOD);
+			read_reg(state, RSTV0910_P2_PDELCTRL2 + state->regoff,
+				 &tmp);
+			/*reset DVBS2 packet delinator error counter */
+			tmp |= 0x40;
+			write_reg(state, RSTV0910_P2_PDELCTRL2 + state->regoff,
+				  tmp);
+			/*reset DVBS2 packet delinator error counter */
+			tmp &= ~0x40;
+			write_reg(state, RSTV0910_P2_PDELCTRL2 + state->regoff,
+				  tmp);
+
+			state->BERScale = 2;
+			state->LastBERNumerator = 0;
+			state->LastBERDenominator = 1;
+			/* force to PRE BCH Rate */
+			write_reg(state, RSTV0910_P2_ERRCTRL1 + state->regoff,
+				  BER_SRC_S2 | state->BERScale);
+		} else {
+			state->BERScale = 2;
+			state->LastBERNumerator = 0;
+			state->LastBERDenominator = 1;
+			/* force to PRE RS Rate */
+			write_reg(state, RSTV0910_P2_ERRCTRL1 + state->regoff,
+				  BER_SRC_S | state->BERScale);
+		}
+		/*Reset the Total packet counter */
+		write_reg(state, RSTV0910_P2_FBERCPT4 + state->regoff, 0x00);
+		/* Reset the packet Error counter2 (and Set it to
+		 * infinit error count mode )
+		 */
+		write_reg(state, RSTV0910_P2_ERRCTRL2 + state->regoff, 0xc1);
+
+		TrackingOptimization(state);
+	}
+	return 0;
+}
+
+static int get_frontend(struct dvb_frontend *fe,
+			struct dtv_frontend_properties *p)
+{
+	struct stv *state = fe->demodulator_priv;
+	enum fe_status status;
+	u16 snr = 0, strength = 0;
+	u32 ber = 0, bernom = 0, berdenom = 0;
+	u8 tmp;
+
+	if (state->ReceiveMode == Mode_DVBS2) {
+		u32 mc;
+		enum fe_modulation modcod2mod[0x20] = {
+			QPSK, QPSK, QPSK, QPSK,
+			QPSK, QPSK, QPSK, QPSK,
+			QPSK, QPSK, QPSK, QPSK,
+			PSK_8, PSK_8, PSK_8, PSK_8,
+			PSK_8, PSK_8, APSK_16, APSK_16,
+			APSK_16, APSK_16, APSK_16, APSK_16,
+			APSK_32, APSK_32, APSK_32, APSK_32,
+			APSK_32,
+		};
+		enum fe_code_rate modcod2fec[0x20] = {
+			FEC_NONE, FEC_1_4, FEC_1_3, FEC_2_5,
+			FEC_1_2, FEC_3_5, FEC_2_3, FEC_3_4,
+			FEC_4_5, FEC_5_6, FEC_8_9, FEC_9_10,
+			FEC_3_5, FEC_2_3, FEC_3_4, FEC_5_6,
+			FEC_8_9, FEC_9_10, FEC_2_3, FEC_3_4,
+			FEC_4_5, FEC_5_6, FEC_8_9, FEC_9_10,
+			FEC_3_4, FEC_4_5, FEC_5_6, FEC_8_9,
+			FEC_9_10
+		};
+		read_reg(state, RSTV0910_P2_DMDMODCOD + state->regoff, &tmp);
+		mc = ((tmp & 0x7c) >> 2);
+		p->pilot = (tmp & 0x01) ? PILOT_ON : PILOT_OFF;
+		p->modulation = modcod2mod[mc];
+		p->fec_inner = modcod2fec[mc];
+	} else if (state->ReceiveMode == Mode_DVBS) {
+		read_reg(state, RSTV0910_P2_VITCURPUN + state->regoff, &tmp);
+		switch (tmp & 0x1F) {
+		case 0x0d:
+			p->fec_inner = FEC_1_2;
+			break;
+		case 0x12:
+			p->fec_inner = FEC_2_3;
+			break;
+		case 0x15:
+			p->fec_inner = FEC_3_4;
+			break;
+		case 0x18:
+			p->fec_inner = FEC_5_6;
+			break;
+		case 0x1a:
+			p->fec_inner = FEC_7_8;
+			break;
+		default:
+			p->fec_inner = FEC_NONE;
+			break;
+		}
+		p->rolloff = ROLLOFF_35;
+	}
+
+	tmp = read_status(fe, &status);
+
+	p->strength.len = 1;
+	p->cnr.len = 1;
+	p->pre_bit_error.len = 1;
+	p->pre_bit_count.len = 1;
+	p->post_bit_error.len = 1;
+
+	if (!(status & FE_HAS_LOCK)) {
+		p->strength.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+		p->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+		p->pre_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+		p->pre_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+		p->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+		return 0;
+	}
+
+	if (read_snr(fe, &snr))
+		p->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+	else {
+		p->cnr.stat[0].scale = FE_SCALE_DECIBEL;
+		p->cnr.stat[0].svalue = snr;
+	}
+
+	if (read_signal_strength(fe, &strength))
+		p->strength.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+	else {
+		p->strength.stat[0].scale = FE_SCALE_DECIBEL;
+		p->strength.stat[0].svalue = strength;
+	}
+
+	if (read_ber(fe, &ber, &bernom, &berdenom)) {
+		p->pre_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+		p->pre_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+		p->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+	} else {
+		p->pre_bit_error.stat[0].scale = FE_SCALE_COUNTER;
+		p->pre_bit_error.stat[0].uvalue = bernom;
+		p->pre_bit_count.stat[0].scale = FE_SCALE_COUNTER;
+		p->pre_bit_count.stat[0].uvalue = berdenom;
+		p->post_bit_error.stat[0].scale = FE_SCALE_COUNTER;
+		p->post_bit_error.stat[0].uvalue = ber;
+	}
+
+	return 0;
+}
+
+static int tune(struct dvb_frontend *fe, bool re_tune,
+		unsigned int mode_flags,
+		unsigned int *delay, enum fe_status *status)
+{
+	struct stv *state = fe->demodulator_priv;
+	int r;
+
+	if (re_tune) {
+		r = set_parameters(fe);
+		if (r)
+			return r;
+		state->tune_time = jiffies;
+	}
+	if (*status & FE_HAS_LOCK)
+		return 0;
+	*delay = HZ;
+
+	r = read_status(fe, status);
+	if (r)
+		return r;
+	return 0;
+}
+
+
+static int get_algo(struct dvb_frontend *fe)
+{
+	return DVBFE_ALGO_HW;
+}
+
+static int set_tone(struct dvb_frontend *fe, enum fe_sec_tone_mode tone)
+{
+	struct stv *state = fe->demodulator_priv;
+	u16 offs = state->nr ? 0x40 : 0;
+
+	switch (tone) {
+	case SEC_TONE_ON:
+		return write_reg(state, RSTV0910_P1_DISTXCFG + offs, 0x38);
+	case SEC_TONE_OFF:
+		return write_reg(state, RSTV0910_P1_DISTXCFG + offs, 0x3a);
+	default:
+		break;
+	}
+	return -EINVAL;
+}
+
+static int wait_dis(struct stv *state, u8 flag, u8 val)
+{
+	int i;
+	u8 stat;
+	u16 offs = state->nr ? 0x40 : 0;
+
+	for (i = 0; i < 10; i++) {
+		read_reg(state, RSTV0910_P1_DISTXSTATUS + offs, &stat);
+		if ((stat & flag) == val)
+			return 0;
+		usleep_range(10000, 11000);
+	}
+	return -ETIMEDOUT;
+}
+
+static int send_master_cmd(struct dvb_frontend *fe,
+			   struct dvb_diseqc_master_cmd *cmd)
+{
+	struct stv *state = fe->demodulator_priv;
+	u16 offs = state->nr ? 0x40 : 0;
+	int i;
+
+	write_reg(state, RSTV0910_P1_DISTXCFG + offs, 0x3E);
+	for (i = 0; i < cmd->msg_len; i++) {
+		wait_dis(state, 0x40, 0x00);
+		write_reg(state, RSTV0910_P1_DISTXFIFO + offs, cmd->msg[i]);
+	}
+	write_reg(state, RSTV0910_P1_DISTXCFG + offs, 0x3A);
+	wait_dis(state, 0x20, 0x20);
+	return 0;
+}
+
+static int sleep(struct dvb_frontend *fe)
+{
+	struct stv *state = fe->demodulator_priv;
+
+	Stop(state);
+	return 0;
+}
+
+static struct dvb_frontend_ops stv0910_ops = {
+	.delsys = { SYS_DVBS, SYS_DVBS2, SYS_DSS },
+	.info = {
+		.name			= "STV0910",
+		.frequency_min		= 950000,
+		.frequency_max		= 2150000,
+		.frequency_stepsize	= 0,
+		.frequency_tolerance	= 0,
+		.symbol_rate_min	= 1000000,
+		.symbol_rate_max	= 70000000,
+		.caps			= FE_CAN_INVERSION_AUTO |
+					  FE_CAN_FEC_AUTO       |
+					  FE_CAN_QPSK           |
+					  FE_CAN_2G_MODULATION
+	},
+	.sleep				= sleep,
+	.release                        = release,
+	.i2c_gate_ctrl                  = gate_ctrl,
+	.get_frontend_algo              = get_algo,
+	.get_frontend                   = get_frontend,
+	.tune                           = tune,
+	.read_status			= read_status,
+	.set_tone			= set_tone,
+
+	.diseqc_send_master_cmd		= send_master_cmd,
+};
+
+static struct stv_base *match_base(struct i2c_adapter  *i2c, u8 adr)
+{
+	struct stv_base *p;
+
+	list_for_each_entry(p, &stvlist, stvlist)
+		if (p->i2c == i2c && p->adr == adr)
+			return p;
+	return NULL;
+}
+
+struct dvb_frontend *stv0910_attach(struct i2c_adapter *i2c,
+				    struct stv0910_cfg *cfg,
+				    int nr)
+{
+	struct stv *state;
+	struct stv_base *base;
+
+	state = kzalloc(sizeof(struct stv), GFP_KERNEL);
+	if (!state)
+		return NULL;
+
+	state->tscfgh = 0x20 | (cfg->parallel ? 0 : 0x40);
+	state->tsgeneral = (cfg->parallel == 2) ? 0x02 : 0x00;
+	state->i2crpt = 0x0A | ((cfg->rptlvl & 0x07) << 4);
+	state->tsspeed = 0x28;
+	state->nr = nr;
+	state->regoff = state->nr ? 0 : 0x200;
+	state->SearchRange = 16000000;
+	state->DEMOD = 0x10;     /* Inversion : Auto with reset to 0 */
+	state->ReceiveMode   = Mode_None;
+
+	base = match_base(i2c, cfg->adr);
+	if (base) {
+		base->count++;
+		state->base = base;
+	} else {
+		base = kzalloc(sizeof(struct stv_base), GFP_KERNEL);
+		if (!base)
+			goto fail;
+		base->i2c = i2c;
+		base->adr = cfg->adr;
+		base->count = 1;
+		base->extclk = cfg->clk ? cfg->clk : 30000000;
+
+		mutex_init(&base->i2c_lock);
+		mutex_init(&base->reg_lock);
+		state->base = base;
+		if (probe(state) < 0) {
+			kfree(base);
+			goto fail;
+		}
+		list_add(&base->stvlist, &stvlist);
+	}
+	state->fe.ops               = stv0910_ops;
+	state->fe.demodulator_priv  = state;
+	state->nr = nr;
+
+	return &state->fe;
+
+fail:
+	kfree(state);
+	return NULL;
+}
+EXPORT_SYMBOL_GPL(stv0910_attach);
+
+MODULE_DESCRIPTION("STV0910 driver");
+MODULE_AUTHOR("Ralph Metzler, Manfred Voelkel");
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/dvb-frontends/stv0910.h b/drivers/media/dvb-frontends/stv0910.h
new file mode 100644
index 0000000..de73fb9
--- /dev/null
+++ b/drivers/media/dvb-frontends/stv0910.h
@@ -0,0 +1,31 @@
+#ifndef _STV0910_H_
+#define _STV0910_H_
+
+#include <linux/types.h>
+#include <linux/i2c.h>
+
+struct stv0910_cfg {
+	u32 clk;
+	u8  adr;
+	u8  parallel;
+	u8  rptlvl;
+};
+
+#if IS_REACHABLE(CONFIG_DVB_STV0910)
+
+extern struct dvb_frontend *stv0910_attach(struct i2c_adapter *i2c,
+					   struct stv0910_cfg *cfg, int nr);
+
+#else
+
+static inline struct dvb_frontend *stv0910_attach(struct i2c_adapter *i2c,
+						  struct stv0910_cfg *cfg,
+						  int nr)
+{
+	pr_warn("%s: driver disabled by Kconfig\n", __func__);
+	return NULL;
+}
+
+#endif /* CONFIG_DVB_STV0910 */
+
+#endif /* _STV0910_H_ */
diff --git a/drivers/media/dvb-frontends/stv0910_regs.h b/drivers/media/dvb-frontends/stv0910_regs.h
new file mode 100644
index 0000000..33cb481
--- /dev/null
+++ b/drivers/media/dvb-frontends/stv0910_regs.h
@@ -0,0 +1,3997 @@
+/* @DVB-S/DVB-S2 STMicroelectronics STV0900 register defintions
+ * Author Manfred Voelkel, August 2013
+ * (c) 2013 Digital Devices GmbH Germany.  All rights reserved
+ *
+ * =======================================================================
+ * Registers Declaration (Internal ST, All Applications )
+ * -------------------------
+ * Each register (RSTV0910__XXXXX) is defined by its address (2 bytes).
+ *
+ * Each field (FSTV0910__XXXXX)is defined as follow:
+ * [register address -- 2bytes][field sign -- 1byte][field mask -- 1byte]
+ *  ======================================================================
+ */
+
+/*MID*/
+#define RSTV0910_MID  0xf100
+#define FSTV0910_MCHIP_IDENT  0xf10000f0
+#define FSTV0910_MRELEASE  0xf100000f
+
+/*DID*/
+#define RSTV0910_DID  0xf101
+#define FSTV0910_DEVICE_ID  0xf10100ff
+
+/*DACR1*/
+#define RSTV0910_DACR1  0xf113
+#define FSTV0910_DAC_MODE  0xf11300e0
+#define FSTV0910_DAC_VALUE1  0xf113000f
+
+/*DACR2*/
+#define RSTV0910_DACR2  0xf114
+#define FSTV0910_DAC_VALUE0  0xf11400ff
+
+/*PADCFG*/
+#define RSTV0910_PADCFG  0xf11a
+#define FSTV0910_AGCRF2_OPD  0xf11a0008
+#define FSTV0910_AGCRF2_XOR  0xf11a0004
+#define FSTV0910_AGCRF1_OPD  0xf11a0002
+#define FSTV0910_AGCRF1_XOR  0xf11a0001
+
+/*OUTCFG2*/
+#define RSTV0910_OUTCFG2  0xf11b
+#define FSTV0910_TS2_ERROR_XOR  0xf11b0080
+#define FSTV0910_TS2_DPN_XOR  0xf11b0040
+#define FSTV0910_TS2_STROUT_XOR  0xf11b0020
+#define FSTV0910_TS2_CLOCKOUT_XOR  0xf11b0010
+#define FSTV0910_TS1_ERROR_XOR  0xf11b0008
+#define FSTV0910_TS1_DPN_XOR  0xf11b0004
+#define FSTV0910_TS1_STROUT_XOR  0xf11b0002
+#define FSTV0910_TS1_CLOCKOUT_XOR  0xf11b0001
+
+/*OUTCFG*/
+#define RSTV0910_OUTCFG  0xf11c
+#define FSTV0910_INV_DATA6  0xf11c0080
+#define FSTV0910_TS2_OUTSER_HZ  0xf11c0020
+#define FSTV0910_TS1_OUTSER_HZ  0xf11c0010
+#define FSTV0910_TS2_OUTPAR_HZ  0xf11c0008
+#define FSTV0910_TS1_OUTPAR_HZ  0xf11c0004
+#define FSTV0910_TS_SERDATA0  0xf11c0002
+
+/*IRQSTATUS3*/
+#define RSTV0910_IRQSTATUS3  0xf120
+#define FSTV0910_SPLL_LOCK  0xf1200020
+#define FSTV0910_SSTREAM_LCK_1  0xf1200010
+#define FSTV0910_SSTREAM_LCK_2  0xf1200008
+#define FSTV0910_SDVBS1_PRF_2  0xf1200002
+#define FSTV0910_SDVBS1_PRF_1  0xf1200001
+
+/*IRQSTATUS2*/
+#define RSTV0910_IRQSTATUS2  0xf121
+#define FSTV0910_SSPY_ENDSIM_1  0xf1210080
+#define FSTV0910_SSPY_ENDSIM_2  0xf1210040
+#define FSTV0910_SPKTDEL_ERROR_2  0xf1210010
+#define FSTV0910_SPKTDEL_LOCKB_2  0xf1210008
+#define FSTV0910_SPKTDEL_LOCK_2  0xf1210004
+#define FSTV0910_SPKTDEL_ERROR_1  0xf1210002
+#define FSTV0910_SPKTDEL_LOCKB_1  0xf1210001
+
+/*IRQSTATUS1*/
+#define RSTV0910_IRQSTATUS1  0xf122
+#define FSTV0910_SPKTDEL_LOCK_1  0xf1220080
+#define FSTV0910_SFEC_LOCKB_2  0xf1220040
+#define FSTV0910_SFEC_LOCK_2  0xf1220020
+#define FSTV0910_SFEC_LOCKB_1  0xf1220010
+#define FSTV0910_SFEC_LOCK_1  0xf1220008
+#define FSTV0910_SDEMOD_LOCKB_2  0xf1220004
+#define FSTV0910_SDEMOD_LOCK_2  0xf1220002
+#define FSTV0910_SDEMOD_IRQ_2  0xf1220001
+
+/*IRQSTATUS0*/
+#define RSTV0910_IRQSTATUS0  0xf123
+#define FSTV0910_SDEMOD_LOCKB_1  0xf1230080
+#define FSTV0910_SDEMOD_LOCK_1  0xf1230040
+#define FSTV0910_SDEMOD_IRQ_1  0xf1230020
+#define FSTV0910_SBCH_ERRFLAG  0xf1230010
+#define FSTV0910_SECW2_IRQ  0xf1230008
+#define FSTV0910_SDISEQC2_IRQ  0xf1230004
+#define FSTV0910_SECW1_IRQ  0xf1230002
+#define FSTV0910_SDISEQC1_IRQ  0xf1230001
+
+/*IRQMASK3*/
+#define RSTV0910_IRQMASK3  0xf124
+#define FSTV0910_MPLL_LOCK  0xf1240020
+#define FSTV0910_MSTREAM_LCK_1  0xf1240010
+#define FSTV0910_MSTREAM_LCK_2  0xf1240008
+#define FSTV0910_MDVBS1_PRF_2  0xf1240002
+#define FSTV0910_MDVBS1_PRF_1  0xf1240001
+
+/*IRQMASK2*/
+#define RSTV0910_IRQMASK2  0xf125
+#define FSTV0910_MSPY_ENDSIM_1  0xf1250080
+#define FSTV0910_MSPY_ENDSIM_2  0xf1250040
+#define FSTV0910_MPKTDEL_ERROR_2  0xf1250010
+#define FSTV0910_MPKTDEL_LOCKB_2  0xf1250008
+#define FSTV0910_MPKTDEL_LOCK_2  0xf1250004
+#define FSTV0910_MPKTDEL_ERROR_1  0xf1250002
+#define FSTV0910_MPKTDEL_LOCKB_1  0xf1250001
+
+/*IRQMASK1*/
+#define RSTV0910_IRQMASK1  0xf126
+#define FSTV0910_MPKTDEL_LOCK_1  0xf1260080
+#define FSTV0910_MFEC_LOCKB_2  0xf1260040
+#define FSTV0910_MFEC_LOCK_2  0xf1260020
+#define FSTV0910_MFEC_LOCKB_1  0xf1260010
+#define FSTV0910_MFEC_LOCK_1  0xf1260008
+#define FSTV0910_MDEMOD_LOCKB_2  0xf1260004
+#define FSTV0910_MDEMOD_LOCK_2  0xf1260002
+#define FSTV0910_MDEMOD_IRQ_2  0xf1260001
+
+/*IRQMASK0*/
+#define RSTV0910_IRQMASK0  0xf127
+#define FSTV0910_MDEMOD_LOCKB_1  0xf1270080
+#define FSTV0910_MDEMOD_LOCK_1  0xf1270040
+#define FSTV0910_MDEMOD_IRQ_1  0xf1270020
+#define FSTV0910_MBCH_ERRFLAG  0xf1270010
+#define FSTV0910_MECW2_IRQ  0xf1270008
+#define FSTV0910_MDISEQC2_IRQ  0xf1270004
+#define FSTV0910_MECW1_IRQ  0xf1270002
+#define FSTV0910_MDISEQC1_IRQ  0xf1270001
+
+/*I2CCFG*/
+#define RSTV0910_I2CCFG  0xf129
+#define FSTV0910_I2C2_FASTMODE  0xf1290080
+#define FSTV0910_STATUS_WR2  0xf1290040
+#define FSTV0910_I2C2ADDR_INC  0xf1290030
+#define FSTV0910_I2C_FASTMODE  0xf1290008
+#define FSTV0910_STATUS_WR  0xf1290004
+#define FSTV0910_I2CADDR_INC  0xf1290003
+
+/*P1_I2CRPT*/
+#define RSTV0910_P1_I2CRPT  0xf12a
+#define FSTV0910_P1_I2CT_ON  0xf12a0080
+#define FSTV0910_P1_ENARPT_LEVEL  0xf12a0070
+#define FSTV0910_P1_SCLT_DELAY  0xf12a0008
+#define FSTV0910_P1_STOP_ENABLE  0xf12a0004
+#define FSTV0910_P1_STOP_SDAT2SDA  0xf12a0002
+
+/*P2_I2CRPT*/
+#define RSTV0910_P2_I2CRPT  0xf12b
+#define FSTV0910_P2_I2CT_ON  0xf12b0080
+#define FSTV0910_P2_ENARPT_LEVEL  0xf12b0070
+#define FSTV0910_P2_SCLT_DELAY  0xf12b0008
+#define FSTV0910_P2_STOP_ENABLE  0xf12b0004
+#define FSTV0910_P2_STOP_SDAT2SDA  0xf12b0002
+
+/*GPIO0CFG*/
+#define RSTV0910_GPIO0CFG  0xf140
+#define FSTV0910_GPIO0_OPD  0xf1400080
+#define FSTV0910_GPIO0_CONFIG  0xf140007e
+#define FSTV0910_GPIO0_XOR  0xf1400001
+
+/*GPIO1CFG*/
+#define RSTV0910_GPIO1CFG  0xf141
+#define FSTV0910_GPIO1_OPD  0xf1410080
+#define FSTV0910_GPIO1_CONFIG  0xf141007e
+#define FSTV0910_GPIO1_XOR  0xf1410001
+
+/*GPIO2CFG*/
+#define RSTV0910_GPIO2CFG  0xf142
+#define FSTV0910_GPIO2_OPD  0xf1420080
+#define FSTV0910_GPIO2_CONFIG  0xf142007e
+#define FSTV0910_GPIO2_XOR  0xf1420001
+
+/*GPIO3CFG*/
+#define RSTV0910_GPIO3CFG  0xf143
+#define FSTV0910_GPIO3_OPD  0xf1430080
+#define FSTV0910_GPIO3_CONFIG  0xf143007e
+#define FSTV0910_GPIO3_XOR  0xf1430001
+
+/*GPIO4CFG*/
+#define RSTV0910_GPIO4CFG  0xf144
+#define FSTV0910_GPIO4_OPD  0xf1440080
+#define FSTV0910_GPIO4_CONFIG  0xf144007e
+#define FSTV0910_GPIO4_XOR  0xf1440001
+
+/*GPIO5CFG*/
+#define RSTV0910_GPIO5CFG  0xf145
+#define FSTV0910_GPIO5_OPD  0xf1450080
+#define FSTV0910_GPIO5_CONFIG  0xf145007e
+#define FSTV0910_GPIO5_XOR  0xf1450001
+
+/*GPIO6CFG*/
+#define RSTV0910_GPIO6CFG  0xf146
+#define FSTV0910_GPIO6_OPD  0xf1460080
+#define FSTV0910_GPIO6_CONFIG  0xf146007e
+#define FSTV0910_GPIO6_XOR  0xf1460001
+
+/*GPIO7CFG*/
+#define RSTV0910_GPIO7CFG  0xf147
+#define FSTV0910_GPIO7_OPD  0xf1470080
+#define FSTV0910_GPIO7_CONFIG  0xf147007e
+#define FSTV0910_GPIO7_XOR  0xf1470001
+
+/*GPIO8CFG*/
+#define RSTV0910_GPIO8CFG  0xf148
+#define FSTV0910_GPIO8_OPD  0xf1480080
+#define FSTV0910_GPIO8_CONFIG  0xf148007e
+#define FSTV0910_GPIO8_XOR  0xf1480001
+
+/*GPIO9CFG*/
+#define RSTV0910_GPIO9CFG  0xf149
+#define FSTV0910_GPIO9_OPD  0xf1490080
+#define FSTV0910_GPIO9_CONFIG  0xf149007e
+#define FSTV0910_GPIO9_XOR  0xf1490001
+
+/*GPIO10CFG*/
+#define RSTV0910_GPIO10CFG  0xf14a
+#define FSTV0910_GPIO10_OPD  0xf14a0080
+#define FSTV0910_GPIO10_CONFIG  0xf14a007e
+#define FSTV0910_GPIO10_XOR  0xf14a0001
+
+/*GPIO11CFG*/
+#define RSTV0910_GPIO11CFG  0xf14b
+#define FSTV0910_GPIO11_OPD  0xf14b0080
+#define FSTV0910_GPIO11_CONFIG  0xf14b007e
+#define FSTV0910_GPIO11_XOR  0xf14b0001
+
+/*GPIO12CFG*/
+#define RSTV0910_GPIO12CFG  0xf14c
+#define FSTV0910_GPIO12_OPD  0xf14c0080
+#define FSTV0910_GPIO12_CONFIG  0xf14c007e
+#define FSTV0910_GPIO12_XOR  0xf14c0001
+
+/*GPIO13CFG*/
+#define RSTV0910_GPIO13CFG  0xf14d
+#define FSTV0910_GPIO13_OPD  0xf14d0080
+#define FSTV0910_GPIO13_CONFIG  0xf14d007e
+#define FSTV0910_GPIO13_XOR  0xf14d0001
+
+/*GPIO14CFG*/
+#define RSTV0910_GPIO14CFG  0xf14e
+#define FSTV0910_GPIO14_OPD  0xf14e0080
+#define FSTV0910_GPIO14_CONFIG  0xf14e007e
+#define FSTV0910_GPIO14_XOR  0xf14e0001
+
+/*GPIO15CFG*/
+#define RSTV0910_GPIO15CFG  0xf14f
+#define FSTV0910_GPIO15_OPD  0xf14f0080
+#define FSTV0910_GPIO15_CONFIG  0xf14f007e
+#define FSTV0910_GPIO15_XOR  0xf14f0001
+
+/*GPIO16CFG*/
+#define RSTV0910_GPIO16CFG  0xf150
+#define FSTV0910_GPIO16_OPD  0xf1500080
+#define FSTV0910_GPIO16_CONFIG  0xf150007e
+#define FSTV0910_GPIO16_XOR  0xf1500001
+
+/*GPIO17CFG*/
+#define RSTV0910_GPIO17CFG  0xf151
+#define FSTV0910_GPIO17_OPD  0xf1510080
+#define FSTV0910_GPIO17_CONFIG  0xf151007e
+#define FSTV0910_GPIO17_XOR  0xf1510001
+
+/*GPIO18CFG*/
+#define RSTV0910_GPIO18CFG  0xf152
+#define FSTV0910_GPIO18_OPD  0xf1520080
+#define FSTV0910_GPIO18_CONFIG  0xf152007e
+#define FSTV0910_GPIO18_XOR  0xf1520001
+
+/*GPIO19CFG*/
+#define RSTV0910_GPIO19CFG  0xf153
+#define FSTV0910_GPIO19_OPD  0xf1530080
+#define FSTV0910_GPIO19_CONFIG  0xf153007e
+#define FSTV0910_GPIO19_XOR  0xf1530001
+
+/*GPIO20CFG*/
+#define RSTV0910_GPIO20CFG  0xf154
+#define FSTV0910_GPIO20_OPD  0xf1540080
+#define FSTV0910_GPIO20_CONFIG  0xf154007e
+#define FSTV0910_GPIO20_XOR  0xf1540001
+
+/*GPIO21CFG*/
+#define RSTV0910_GPIO21CFG  0xf155
+#define FSTV0910_GPIO21_OPD  0xf1550080
+#define FSTV0910_GPIO21_CONFIG  0xf155007e
+#define FSTV0910_GPIO21_XOR  0xf1550001
+
+/*GPIO22CFG*/
+#define RSTV0910_GPIO22CFG  0xf156
+#define FSTV0910_GPIO22_OPD  0xf1560080
+#define FSTV0910_GPIO22_CONFIG  0xf156007e
+#define FSTV0910_GPIO22_XOR  0xf1560001
+
+/*STRSTATUS1*/
+#define RSTV0910_STRSTATUS1  0xf16a
+#define FSTV0910_STRSTATUS_SEL2  0xf16a00f0
+#define FSTV0910_STRSTATUS_SEL1  0xf16a000f
+
+/*STRSTATUS2*/
+#define RSTV0910_STRSTATUS2  0xf16b
+#define FSTV0910_STRSTATUS_SEL4  0xf16b00f0
+#define FSTV0910_STRSTATUS_SEL3  0xf16b000f
+
+/*STRSTATUS3*/
+#define RSTV0910_STRSTATUS3  0xf16c
+#define FSTV0910_STRSTATUS_SEL6  0xf16c00f0
+#define FSTV0910_STRSTATUS_SEL5  0xf16c000f
+
+/*FSKTFC2*/
+#define RSTV0910_FSKTFC2  0xf170
+#define FSTV0910_FSKT_KMOD  0xf17000fc
+#define FSTV0910_FSKT_CAR2  0xf1700003
+
+/*FSKTFC1*/
+#define RSTV0910_FSKTFC1  0xf171
+#define FSTV0910_FSKT_CAR1  0xf17100ff
+
+/*FSKTFC0*/
+#define RSTV0910_FSKTFC0  0xf172
+#define FSTV0910_FSKT_CAR0  0xf17200ff
+
+/*FSKTDELTAF1*/
+#define RSTV0910_FSKTDELTAF1  0xf173
+#define FSTV0910_FSKT_DELTAF1  0xf173000f
+
+/*FSKTDELTAF0*/
+#define RSTV0910_FSKTDELTAF0  0xf174
+#define FSTV0910_FSKT_DELTAF0  0xf17400ff
+
+/*FSKTCTRL*/
+#define RSTV0910_FSKTCTRL  0xf175
+#define FSTV0910_FSKT_PINSEL  0xf1750080
+#define FSTV0910_FSKT_EN_SGN  0xf1750040
+#define FSTV0910_FSKT_MOD_SGN  0xf1750020
+#define FSTV0910_FSKT_MOD_EN  0xf175001c
+#define FSTV0910_FSKT_DACMODE  0xf1750003
+
+/*FSKRFC2*/
+#define RSTV0910_FSKRFC2  0xf176
+#define FSTV0910_FSKR_DETSGN  0xf1760040
+#define FSTV0910_FSKR_OUTSGN  0xf1760020
+#define FSTV0910_FSKR_KAGC  0xf176001c
+#define FSTV0910_FSKR_CAR2  0xf1760003
+
+/*FSKRFC1*/
+#define RSTV0910_FSKRFC1  0xf177
+#define FSTV0910_FSKR_CAR1  0xf17700ff
+
+/*FSKRFC0*/
+#define RSTV0910_FSKRFC0  0xf178
+#define FSTV0910_FSKR_CAR0  0xf17800ff
+
+/*FSKRK1*/
+#define RSTV0910_FSKRK1  0xf179
+#define FSTV0910_FSKR_K1_EXP  0xf17900e0
+#define FSTV0910_FSKR_K1_MANT  0xf179001f
+
+/*FSKRK2*/
+#define RSTV0910_FSKRK2  0xf17a
+#define FSTV0910_FSKR_K2_EXP  0xf17a00e0
+#define FSTV0910_FSKR_K2_MANT  0xf17a001f
+
+/*FSKRAGCR*/
+#define RSTV0910_FSKRAGCR  0xf17b
+#define FSTV0910_FSKR_OUTCTL  0xf17b00c0
+#define FSTV0910_FSKR_AGC_REF  0xf17b003f
+
+/*FSKRAGC*/
+#define RSTV0910_FSKRAGC  0xf17c
+#define FSTV0910_FSKR_AGC_ACCU  0xf17c00ff
+
+/*FSKRALPHA*/
+#define RSTV0910_FSKRALPHA  0xf17d
+#define FSTV0910_FSKR_ALPHA_EXP  0xf17d001c
+#define FSTV0910_FSKR_ALPHA_M  0xf17d0003
+
+/*FSKRPLTH1*/
+#define RSTV0910_FSKRPLTH1  0xf17e
+#define FSTV0910_FSKR_BETA  0xf17e00f0
+#define FSTV0910_FSKR_PLL_TRESH1  0xf17e000f
+
+/*FSKRPLTH0*/
+#define RSTV0910_FSKRPLTH0  0xf17f
+#define FSTV0910_FSKR_PLL_TRESH0  0xf17f00ff
+
+/*FSKRDF1*/
+#define RSTV0910_FSKRDF1  0xf180
+#define FSTV0910_FSKR_OUT  0xf1800080
+#define FSTV0910_FSKR_STATE  0xf1800060
+#define FSTV0910_FSKR_DELTAF1  0xf180001f
+
+/*FSKRDF0*/
+#define RSTV0910_FSKRDF0  0xf181
+#define FSTV0910_FSKR_DELTAF0  0xf18100ff
+
+/*FSKRSTEPP*/
+#define RSTV0910_FSKRSTEPP  0xf182
+#define FSTV0910_FSKR_STEP_PLUS  0xf18200ff
+
+/*FSKRSTEPM*/
+#define RSTV0910_FSKRSTEPM  0xf183
+#define FSTV0910_FSKR_STEP_MINUS  0xf18300ff
+
+/*FSKRDET1*/
+#define RSTV0910_FSKRDET1  0xf184
+#define FSTV0910_FSKR_DETECT  0xf1840080
+#define FSTV0910_FSKR_CARDET_ACCU1  0xf184000f
+
+/*FSKRDET0*/
+#define RSTV0910_FSKRDET0  0xf185
+#define FSTV0910_FSKR_CARDET_ACCU0  0xf18500ff
+
+/*FSKRDTH1*/
+#define RSTV0910_FSKRDTH1  0xf186
+#define FSTV0910_FSKR_CARLOSS_THRESH1  0xf18600f0
+#define FSTV0910_FSKR_CARDET_THRESH1  0xf186000f
+
+/*FSKRDTH0*/
+#define RSTV0910_FSKRDTH0  0xf187
+#define FSTV0910_FSKR_CARDET_THRESH0  0xf18700ff
+
+/*FSKRLOSS*/
+#define RSTV0910_FSKRLOSS  0xf188
+#define FSTV0910_FSKR_CARLOSS_THRESH0  0xf18800ff
+
+/*NCOARSE*/
+#define RSTV0910_NCOARSE  0xf1b3
+#define FSTV0910_CP  0xf1b300f8
+#define FSTV0910_IDF  0xf1b30007
+
+/*NCOARSE1*/
+#define RSTV0910_NCOARSE1  0xf1b4
+#define FSTV0910_N_DIV  0xf1b400ff
+
+/*NCOARSE2*/
+#define RSTV0910_NCOARSE2  0xf1b5
+#define FSTV0910_ODF  0xf1b5003f
+
+/*SYNTCTRL*/
+#define RSTV0910_SYNTCTRL  0xf1b6
+#define FSTV0910_STANDBY  0xf1b60080
+#define FSTV0910_BYPASSPLLCORE  0xf1b60040
+#define FSTV0910_STOP_PLL  0xf1b60008
+#define FSTV0910_OSCI_E  0xf1b60002
+
+/*FILTCTRL*/
+#define RSTV0910_FILTCTRL  0xf1b7
+#define FSTV0910_INV_CLKFSK  0xf1b70002
+#define FSTV0910_BYPASS_APPLI  0xf1b70001
+
+/*PLLSTAT*/
+#define RSTV0910_PLLSTAT  0xf1b8
+#define FSTV0910_PLL_BIST_END  0xf1b80004
+#define FSTV0910_PLLLOCK  0xf1b80001
+
+/*STOPCLK1*/
+#define RSTV0910_STOPCLK1  0xf1c2
+#define FSTV0910_INV_CLKADCI2  0xf1c20004
+#define FSTV0910_INV_CLKADCI1  0xf1c20001
+
+/*STOPCLK2*/
+#define RSTV0910_STOPCLK2  0xf1c3
+#define FSTV0910_STOP_DVBS2FEC2  0xf1c30020
+#define FSTV0910_STOP_DVBS2FEC  0xf1c30010
+#define FSTV0910_STOP_DVBS1FEC2  0xf1c30008
+#define FSTV0910_STOP_DVBS1FEC  0xf1c30004
+#define FSTV0910_STOP_DEMOD2  0xf1c30002
+#define FSTV0910_STOP_DEMOD  0xf1c30001
+
+/*PREGCTL*/
+#define RSTV0910_PREGCTL  0xf1c8
+#define FSTV0910_REG3V3TO2V5_POFF  0xf1c80080
+
+/*TSTTNR0*/
+#define RSTV0910_TSTTNR0  0xf1df
+#define FSTV0910_FSK_PON  0xf1df0004
+#define FSTV0910_FSK_OPENLOOP  0xf1df0002
+
+/*TSTTNR1*/
+#define RSTV0910_TSTTNR1  0xf1e0
+#define FSTV0910_BYPASS_ADC1  0xf1e00080
+#define FSTV0910_INVADC1_CKOUT  0xf1e00040
+#define FSTV0910_SELIQSRC1  0xf1e00030
+#define FSTV0910_DEMOD2_SELADC  0xf1e00008
+#define FSTV0910_DEMOD1_SELADC  0xf1e00004
+#define FSTV0910_ADC1_PON  0xf1e00002
+
+/*TSTTNR2*/
+#define RSTV0910_TSTTNR2  0xf1e1
+#define FSTV0910_I2C_DISEQC_BYPASS  0xf1e10080
+#define FSTV0910_I2C_DISEQC_ENCH  0xf1e10040
+#define FSTV0910_I2C_DISEQC_PON  0xf1e10020
+#define FSTV0910_DISEQC_CLKDIV  0xf1e1000f
+
+/*TSTTNR3*/
+#define RSTV0910_TSTTNR3  0xf1e2
+#define FSTV0910_BYPASS_ADC2  0xf1e20080
+#define FSTV0910_INVADC2_CKOUT  0xf1e20040
+#define FSTV0910_SELIQSRC2  0xf1e20030
+#define FSTV0910_ADC2_PON  0xf1e20002
+
+/*P2_IQCONST*/
+#define RSTV0910_P2_IQCONST  0xf200
+#define FSTV0910_P2_CONSTEL_SELECT  0xf2000060
+#define FSTV0910_P2_IQSYMB_SEL  0xf200001f
+
+/*P2_NOSCFG*/
+#define RSTV0910_P2_NOSCFG  0xf201
+#define FSTV0910_P2_DIS_ACMRATIO  0xf2010080
+#define FSTV0910_P2_NOSIN_EGALSEL  0xf2010040
+#define FSTV0910_P2_DUMMYPL_NOSDATA  0xf2010020
+#define FSTV0910_P2_NOSPLH_BETA  0xf2010018
+#define FSTV0910_P2_NOSDATA_BETA  0xf2010007
+
+/*P2_ISYMB*/
+#define RSTV0910_P2_ISYMB  0xf202
+#define FSTV0910_P2_I_SYMBOL  0xf20201ff
+
+/*P2_QSYMB*/
+#define RSTV0910_P2_QSYMB  0xf203
+#define FSTV0910_P2_Q_SYMBOL  0xf20301ff
+
+/*P2_AGC1CFG*/
+#define RSTV0910_P2_AGC1CFG  0xf204
+#define FSTV0910_P2_DC_FROZEN  0xf2040080
+#define FSTV0910_P2_DC_CORRECT  0xf2040040
+#define FSTV0910_P2_AMM_FROZEN  0xf2040020
+#define FSTV0910_P2_AMM_CORRECT  0xf2040010
+#define FSTV0910_P2_QUAD_FROZEN  0xf2040008
+#define FSTV0910_P2_QUAD_CORRECT  0xf2040004
+#define FSTV0910_P2_DCCOMP_SLOW  0xf2040002
+#define FSTV0910_P2_IQMISM_SLOW  0xf2040001
+
+/*P2_AGC1CN*/
+#define RSTV0910_P2_AGC1CN  0xf206
+#define FSTV0910_P2_AGC1_LOCKED  0xf2060080
+#define FSTV0910_P2_AGC1_OVERFLOW  0xf2060040
+#define FSTV0910_P2_AGC1_NOSLOWLK  0xf2060020
+#define FSTV0910_P2_AGC1_MINPOWER  0xf2060010
+#define FSTV0910_P2_AGCOUT_FAST  0xf2060008
+#define FSTV0910_P2_AGCIQ_BETA  0xf2060007
+
+/*P2_AGC1REF*/
+#define RSTV0910_P2_AGC1REF  0xf207
+#define FSTV0910_P2_AGCIQ_REF  0xf20700ff
+
+/*P2_IDCCOMP*/
+#define RSTV0910_P2_IDCCOMP  0xf208
+#define FSTV0910_P2_IAVERAGE_ADJ  0xf20801ff
+
+/*P2_QDCCOMP*/
+#define RSTV0910_P2_QDCCOMP  0xf209
+#define FSTV0910_P2_QAVERAGE_ADJ  0xf20901ff
+
+/*P2_POWERI*/
+#define RSTV0910_P2_POWERI  0xf20a
+#define FSTV0910_P2_POWER_I  0xf20a00ff
+
+/*P2_POWERQ*/
+#define RSTV0910_P2_POWERQ  0xf20b
+#define FSTV0910_P2_POWER_Q  0xf20b00ff
+
+/*P2_AGC1AMM*/
+#define RSTV0910_P2_AGC1AMM  0xf20c
+#define FSTV0910_P2_AMM_VALUE  0xf20c00ff
+
+/*P2_AGC1QUAD*/
+#define RSTV0910_P2_AGC1QUAD  0xf20d
+#define FSTV0910_P2_QUAD_VALUE  0xf20d01ff
+
+/*P2_AGCIQIN1*/
+#define RSTV0910_P2_AGCIQIN1  0xf20e
+#define FSTV0910_P2_AGCIQ_VALUE1  0xf20e00ff
+
+/*P2_AGCIQIN0*/
+#define RSTV0910_P2_AGCIQIN0  0xf20f
+#define FSTV0910_P2_AGCIQ_VALUE0  0xf20f00ff
+
+/*P2_DEMOD*/
+#define RSTV0910_P2_DEMOD  0xf210
+#define FSTV0910_P2_MANUALS2_ROLLOFF  0xf2100080
+#define FSTV0910_P2_SPECINV_CONTROL  0xf2100030
+#define FSTV0910_P2_MANUALSX_ROLLOFF  0xf2100004
+#define FSTV0910_P2_ROLLOFF_CONTROL  0xf2100003
+
+/*P2_DMDMODCOD*/
+#define RSTV0910_P2_DMDMODCOD  0xf211
+#define FSTV0910_P2_MANUAL_MODCOD  0xf2110080
+#define FSTV0910_P2_DEMOD_MODCOD  0xf211007c
+#define FSTV0910_P2_DEMOD_TYPE  0xf2110003
+
+/*P2_DSTATUS*/
+#define RSTV0910_P2_DSTATUS  0xf212
+#define FSTV0910_P2_CAR_LOCK  0xf2120080
+#define FSTV0910_P2_TMGLOCK_QUALITY  0xf2120060
+#define FSTV0910_P2_SDVBS1_ENABLE  0xf2120010
+#define FSTV0910_P2_LOCK_DEFINITIF  0xf2120008
+#define FSTV0910_P2_TIMING_IS_LOCKED  0xf2120004
+#define FSTV0910_P2_DEMOD_SYSCFG  0xf2120002
+#define FSTV0910_P2_OVADC_DETECT  0xf2120001
+
+/*P2_DSTATUS2*/
+#define RSTV0910_P2_DSTATUS2  0xf213
+#define FSTV0910_P2_DEMOD_DELOCK  0xf2130080
+#define FSTV0910_P2_DEMOD_TIMEOUT  0xf2130040
+#define FSTV0910_P2_MODCODRQ_SYNCTAG  0xf2130020
+#define FSTV0910_P2_POLYPH_SATEVENT  0xf2130010
+#define FSTV0910_P2_AGC1_NOSIGNALACK  0xf2130008
+#define FSTV0910_P2_AGC2_OVERFLOW  0xf2130004
+#define FSTV0910_P2_CFR_OVERFLOW  0xf2130002
+#define FSTV0910_P2_GAMMA_OVERUNDER  0xf2130001
+
+/*P2_DMDCFGMD*/
+#define RSTV0910_P2_DMDCFGMD  0xf214
+#define FSTV0910_P2_DVBS2_ENABLE  0xf2140080
+#define FSTV0910_P2_DVBS1_ENABLE  0xf2140040
+#define FSTV0910_P2_SCAN_ENABLE  0xf2140010
+#define FSTV0910_P2_CFR_AUTOSCAN  0xf2140008
+#define FSTV0910_P2_NOFORCE_RELOCK  0xf2140004
+#define FSTV0910_P2_TUN_RNG  0xf2140003
+
+/*P2_DMDCFG2*/
+#define RSTV0910_P2_DMDCFG2  0xf215
+#define FSTV0910_P2_AGC1_WAITLOCK  0xf2150080
+#define FSTV0910_P2_S1S2_SEQUENTIAL  0xf2150040
+#define FSTV0910_P2_BLINDPEA_MODE  0xf2150020
+#define FSTV0910_P2_INFINITE_RELOCK  0xf2150010
+#define FSTV0910_P2_BWOFFSET_COLDWARM  0xf2150008
+#define FSTV0910_P2_TMGLOCK_NSCANSTOP  0xf2150004
+#define FSTV0910_P2_COARSE_LK3MODE  0xf2150002
+#define FSTV0910_P2_COARSE_LK2MODE  0xf2150001
+
+/*P2_DMDISTATE*/
+#define RSTV0910_P2_DMDISTATE  0xf216
+#define FSTV0910_P2_I2C_NORESETDMODE  0xf2160080
+#define FSTV0910_P2_FORCE_ETAPED  0xf2160040
+#define FSTV0910_P2_SDMDRST_DIRCLK  0xf2160020
+#define FSTV0910_P2_I2C_DEMOD_MODE  0xf216001f
+
+/*P2_DMDT0M*/
+#define RSTV0910_P2_DMDT0M  0xf217
+#define FSTV0910_P2_DMDT0_MIN  0xf21700ff
+
+/*P2_DMDSTATE*/
+#define RSTV0910_P2_DMDSTATE  0xf21b
+#define FSTV0910_P2_DEMOD_LOCKED  0xf21b0080
+#define FSTV0910_P2_HEADER_MODE  0xf21b0060
+#define FSTV0910_P2_DEMOD_MODE  0xf21b001f
+
+/*P2_DMDFLYW*/
+#define RSTV0910_P2_DMDFLYW  0xf21c
+#define FSTV0910_P2_I2C_IRQVAL  0xf21c00f0
+#define FSTV0910_P2_FLYWHEEL_CPT  0xf21c000f
+
+/*P2_DSTATUS3*/
+#define RSTV0910_P2_DSTATUS3  0xf21d
+#define FSTV0910_P2_CFR_ZIGZAG  0xf21d0080
+#define FSTV0910_P2_DEMOD_CFGMODE  0xf21d0060
+#define FSTV0910_P2_GAMMA_LOWBAUDRATE  0xf21d0010
+#define FSTV0910_P2_RELOCK_MODE  0xf21d0008
+#define FSTV0910_P2_DEMOD_FAIL  0xf21d0004
+#define FSTV0910_P2_ETAPE1A_DVBXMEM  0xf21d0003
+
+/*P2_DMDCFG3*/
+#define RSTV0910_P2_DMDCFG3  0xf21e
+#define FSTV0910_P2_DVBS1_TMGWAIT  0xf21e0080
+#define FSTV0910_P2_NO_BWCENTERING  0xf21e0040
+#define FSTV0910_P2_INV_SEQSRCH  0xf21e0020
+#define FSTV0910_P2_DIS_SFRUPLOW_TRK  0xf21e0010
+#define FSTV0910_P2_NOSTOP_FIFOFULL  0xf21e0008
+#define FSTV0910_P2_LOCKTIME_MODE  0xf21e0007
+
+/*P2_DMDCFG4*/
+#define RSTV0910_P2_DMDCFG4  0xf21f
+#define FSTV0910_P2_DIS_VITLOCK  0xf21f0080
+#define FSTV0910_P2_S1S2TOUT_FAST  0xf21f0040
+#define FSTV0910_P2_DEMOD_FASTLOCK  0xf21f0020
+#define FSTV0910_P2_S1HIER_ENABLE  0xf21f0010
+#define FSTV0910_P2_TUNER_NRELAUNCH  0xf21f0008
+#define FSTV0910_P2_DIS_CLKENABLE  0xf21f0004
+#define FSTV0910_P2_DIS_HDRDIVLOCK  0xf21f0002
+#define FSTV0910_P2_NO_TNRWBINIT  0xf21f0001
+
+/*P2_CORRELMANT*/
+#define RSTV0910_P2_CORRELMANT  0xf220
+#define FSTV0910_P2_CORREL_MANT  0xf22000ff
+
+/*P2_CORRELABS*/
+#define RSTV0910_P2_CORRELABS  0xf221
+#define FSTV0910_P2_CORREL_ABS  0xf22100ff
+
+/*P2_CORRELEXP*/
+#define RSTV0910_P2_CORRELEXP  0xf222
+#define FSTV0910_P2_CORREL_ABSEXP  0xf22200f0
+#define FSTV0910_P2_CORREL_EXP  0xf222000f
+
+/*P2_PLHMODCOD*/
+#define RSTV0910_P2_PLHMODCOD  0xf224
+#define FSTV0910_P2_SPECINV_DEMOD  0xf2240080
+#define FSTV0910_P2_PLH_MODCOD  0xf224007c
+#define FSTV0910_P2_PLH_TYPE  0xf2240003
+
+/*P2_DMDREG*/
+#define RSTV0910_P2_DMDREG  0xf225
+#define FSTV0910_P2_EXTPSK_MODE  0xf2250080
+#define FSTV0910_P2_HIER_SHORTFRAME  0xf2250002
+#define FSTV0910_P2_DECIM_PLFRAMES  0xf2250001
+
+/*P2_AGC2O*/
+#define RSTV0910_P2_AGC2O  0xf22c
+#define FSTV0910_P2_CSTENV_MODE  0xf22c00c0
+#define FSTV0910_P2_AGC2_LKSQRT  0xf22c0020
+#define FSTV0910_P2_AGC2_LKMODE  0xf22c0010
+#define FSTV0910_P2_AGC2_LKEQUA  0xf22c0008
+#define FSTV0910_P2_AGC2_COEF  0xf22c0007
+
+/*P2_AGC2REF*/
+#define RSTV0910_P2_AGC2REF  0xf22d
+#define FSTV0910_P2_AGC2_REF  0xf22d00ff
+
+/*P2_AGC1ADJ*/
+#define RSTV0910_P2_AGC1ADJ  0xf22e
+#define FSTV0910_P2_AGC1ADJ_MANUAL  0xf22e0080
+#define FSTV0910_P2_AGC1_ADJUSTED  0xf22e007f
+
+/*P2_AGC2I1*/
+#define RSTV0910_P2_AGC2I1  0xf236
+#define FSTV0910_P2_AGC2_INTEGRATOR1  0xf23600ff
+
+/*P2_AGC2I0*/
+#define RSTV0910_P2_AGC2I0  0xf237
+#define FSTV0910_P2_AGC2_INTEGRATOR0  0xf23700ff
+
+/*P2_CARCFG*/
+#define RSTV0910_P2_CARCFG  0xf238
+#define FSTV0910_P2_CFRUPLOW_AUTO  0xf2380080
+#define FSTV0910_P2_CFRUPLOW_TEST  0xf2380040
+#define FSTV0910_P2_WIDE_FREQDET  0xf2380020
+#define FSTV0910_P2_CARHDR_NODIV8  0xf2380010
+#define FSTV0910_P2_I2C_ROTA  0xf2380008
+#define FSTV0910_P2_ROTAON  0xf2380004
+#define FSTV0910_P2_PH_DET_ALGO  0xf2380003
+
+/*P2_ACLC*/
+#define RSTV0910_P2_ACLC  0xf239
+#define FSTV0910_P2_CARS1_ANOSAUTO  0xf2390040
+#define FSTV0910_P2_CAR_ALPHA_MANT  0xf2390030
+#define FSTV0910_P2_CAR_ALPHA_EXP  0xf239000f
+
+/*P2_BCLC*/
+#define RSTV0910_P2_BCLC  0xf23a
+#define FSTV0910_P2_CARS1_BNOSAUTO  0xf23a0040
+#define FSTV0910_P2_CAR_BETA_MANT  0xf23a0030
+#define FSTV0910_P2_CAR_BETA_EXP  0xf23a000f
+
+/*P2_CARFREQ*/
+#define RSTV0910_P2_CARFREQ  0xf23d
+#define FSTV0910_P2_KC_COARSE_EXP  0xf23d00f0
+#define FSTV0910_P2_BETA_FREQ  0xf23d000f
+
+/*P2_CARHDR*/
+#define RSTV0910_P2_CARHDR  0xf23e
+#define FSTV0910_P2_K_FREQ_HDR  0xf23e00ff
+
+/*P2_LDT*/
+#define RSTV0910_P2_LDT  0xf23f
+#define FSTV0910_P2_CARLOCK_THRES  0xf23f01ff
+
+/*P2_LDT2*/
+#define RSTV0910_P2_LDT2  0xf240
+#define FSTV0910_P2_CARLOCK_THRES2  0xf24001ff
+
+/*P2_CFRICFG*/
+#define RSTV0910_P2_CFRICFG  0xf241
+#define FSTV0910_P2_CFRINIT_UNVALRNG  0xf2410080
+#define FSTV0910_P2_CFRINIT_LUNVALCPT  0xf2410040
+#define FSTV0910_P2_CFRINIT_ABORTDBL  0xf2410020
+#define FSTV0910_P2_CFRINIT_ABORTPRED  0xf2410010
+#define FSTV0910_P2_CFRINIT_UNVALSKIP  0xf2410008
+#define FSTV0910_P2_CFRINIT_CSTINC  0xf2410004
+#define FSTV0910_P2_CFRIROLL_GARDER  0xf2410002
+#define FSTV0910_P2_NEG_CFRSTEP  0xf2410001
+
+/*P2_CFRUP1*/
+#define RSTV0910_P2_CFRUP1  0xf242
+#define FSTV0910_P2_CFR_UP1  0xf24201ff
+
+/*P2_CFRUP0*/
+#define RSTV0910_P2_CFRUP0  0xf243
+#define FSTV0910_P2_CFR_UP0  0xf24300ff
+
+/*P2_CFRIBASE1*/
+#define RSTV0910_P2_CFRIBASE1  0xf244
+#define FSTV0910_P2_CFRINIT_BASE1  0xf24400ff
+
+/*P2_CFRIBASE0*/
+#define RSTV0910_P2_CFRIBASE0  0xf245
+#define FSTV0910_P2_CFRINIT_BASE0  0xf24500ff
+
+/*P2_CFRLOW1*/
+#define RSTV0910_P2_CFRLOW1  0xf246
+#define FSTV0910_P2_CFR_LOW1  0xf24601ff
+
+/*P2_CFRLOW0*/
+#define RSTV0910_P2_CFRLOW0  0xf247
+#define FSTV0910_P2_CFR_LOW0  0xf24700ff
+
+/*P2_CFRINIT1*/
+#define RSTV0910_P2_CFRINIT1  0xf248
+#define FSTV0910_P2_CFR_INIT1  0xf24801ff
+
+/*P2_CFRINIT0*/
+#define RSTV0910_P2_CFRINIT0  0xf249
+#define FSTV0910_P2_CFR_INIT0  0xf24900ff
+
+/*P2_CFRINC1*/
+#define RSTV0910_P2_CFRINC1  0xf24a
+#define FSTV0910_P2_MANUAL_CFRINC  0xf24a0080
+#define FSTV0910_P2_CFR_INC1  0xf24a003f
+
+/*P2_CFRINC0*/
+#define RSTV0910_P2_CFRINC0  0xf24b
+#define FSTV0910_P2_CFR_INC0  0xf24b00ff
+
+/*P2_CFR2*/
+#define RSTV0910_P2_CFR2  0xf24c
+#define FSTV0910_P2_CAR_FREQ2  0xf24c01ff
+
+/*P2_CFR1*/
+#define RSTV0910_P2_CFR1  0xf24d
+#define FSTV0910_P2_CAR_FREQ1  0xf24d00ff
+
+/*P2_CFR0*/
+#define RSTV0910_P2_CFR0  0xf24e
+#define FSTV0910_P2_CAR_FREQ0  0xf24e00ff
+
+/*P2_LDI*/
+#define RSTV0910_P2_LDI  0xf24f
+#define FSTV0910_P2_LOCK_DET_INTEGR  0xf24f01ff
+
+/*P2_TMGCFG*/
+#define RSTV0910_P2_TMGCFG  0xf250
+#define FSTV0910_P2_TMGLOCK_BETA  0xf25000c0
+#define FSTV0910_P2_DO_TIMING_CORR  0xf2500010
+#define FSTV0910_P2_MANUAL_SCAN  0xf250000c
+#define FSTV0910_P2_TMG_MINFREQ  0xf2500003
+
+/*P2_RTC*/
+#define RSTV0910_P2_RTC  0xf251
+#define FSTV0910_P2_TMGALPHA_EXP  0xf25100f0
+#define FSTV0910_P2_TMGBETA_EXP  0xf251000f
+
+/*P2_RTCS2*/
+#define RSTV0910_P2_RTCS2  0xf252
+#define FSTV0910_P2_TMGALPHAS2_EXP  0xf25200f0
+#define FSTV0910_P2_TMGBETAS2_EXP  0xf252000f
+
+/*P2_TMGTHRISE*/
+#define RSTV0910_P2_TMGTHRISE  0xf253
+#define FSTV0910_P2_TMGLOCK_THRISE  0xf25300ff
+
+/*P2_TMGTHFALL*/
+#define RSTV0910_P2_TMGTHFALL  0xf254
+#define FSTV0910_P2_TMGLOCK_THFALL  0xf25400ff
+
+/*P2_SFRUPRATIO*/
+#define RSTV0910_P2_SFRUPRATIO  0xf255
+#define FSTV0910_P2_SFR_UPRATIO  0xf25500ff
+
+/*P2_SFRLOWRATIO*/
+#define RSTV0910_P2_SFRLOWRATIO  0xf256
+#define FSTV0910_P2_SFR_LOWRATIO  0xf25600ff
+
+/*P2_KTTMG*/
+#define RSTV0910_P2_KTTMG  0xf257
+#define FSTV0910_P2_KT_TMG_EXP  0xf25700f0
+
+/*P2_KREFTMG*/
+#define RSTV0910_P2_KREFTMG  0xf258
+#define FSTV0910_P2_KREF_TMG  0xf25800ff
+
+/*P2_SFRSTEP*/
+#define RSTV0910_P2_SFRSTEP  0xf259
+#define FSTV0910_P2_SFR_SCANSTEP  0xf25900f0
+#define FSTV0910_P2_SFR_CENTERSTEP  0xf259000f
+
+/*P2_TMGCFG2*/
+#define RSTV0910_P2_TMGCFG2  0xf25a
+#define FSTV0910_P2_KREFTMG2_DECMODE  0xf25a00c0
+#define FSTV0910_P2_DIS_AUTOSAMP  0xf25a0008
+#define FSTV0910_P2_SCANINIT_QUART  0xf25a0004
+#define FSTV0910_P2_NOTMG_DVBS1DERAT  0xf25a0002
+#define FSTV0910_P2_SFRRATIO_FINE  0xf25a0001
+
+/*P2_KREFTMG2*/
+#define RSTV0910_P2_KREFTMG2  0xf25b
+#define FSTV0910_P2_KREF_TMG2  0xf25b00ff
+
+/*P2_TMGCFG3*/
+#define RSTV0910_P2_TMGCFG3  0xf25d
+#define FSTV0910_P2_CFRINC_MODE  0xf25d0070
+#define FSTV0910_P2_CONT_TMGCENTER  0xf25d0008
+#define FSTV0910_P2_AUTO_GUP  0xf25d0004
+#define FSTV0910_P2_AUTO_GLOW  0xf25d0002
+#define FSTV0910_P2_SFRVAL_MINMODE  0xf25d0001
+
+/*P2_SFRINIT1*/
+#define RSTV0910_P2_SFRINIT1  0xf25e
+#define FSTV0910_P2_SFR_INIT1  0xf25e00ff
+
+/*P2_SFRINIT0*/
+#define RSTV0910_P2_SFRINIT0  0xf25f
+#define FSTV0910_P2_SFR_INIT0  0xf25f00ff
+
+/*P2_SFRUP1*/
+#define RSTV0910_P2_SFRUP1  0xf260
+#define FSTV0910_P2_SYMB_FREQ_UP1  0xf26000ff
+
+/*P2_SFRUP0*/
+#define RSTV0910_P2_SFRUP0  0xf261
+#define FSTV0910_P2_SYMB_FREQ_UP0  0xf26100ff
+
+/*P2_SFRLOW1*/
+#define RSTV0910_P2_SFRLOW1  0xf262
+#define FSTV0910_P2_SYMB_FREQ_LOW1  0xf26200ff
+
+/*P2_SFRLOW0*/
+#define RSTV0910_P2_SFRLOW0  0xf263
+#define FSTV0910_P2_SYMB_FREQ_LOW0  0xf26300ff
+
+/*P2_SFR3*/
+#define RSTV0910_P2_SFR3  0xf264
+#define FSTV0910_P2_SYMB_FREQ3  0xf26400ff
+
+/*P2_SFR2*/
+#define RSTV0910_P2_SFR2  0xf265
+#define FSTV0910_P2_SYMB_FREQ2  0xf26500ff
+
+/*P2_SFR1*/
+#define RSTV0910_P2_SFR1  0xf266
+#define FSTV0910_P2_SYMB_FREQ1  0xf26600ff
+
+/*P2_SFR0*/
+#define RSTV0910_P2_SFR0  0xf267
+#define FSTV0910_P2_SYMB_FREQ0  0xf26700ff
+
+/*P2_TMGREG2*/
+#define RSTV0910_P2_TMGREG2  0xf268
+#define FSTV0910_P2_TMGREG2  0xf26800ff
+
+/*P2_TMGREG1*/
+#define RSTV0910_P2_TMGREG1  0xf269
+#define FSTV0910_P2_TMGREG1  0xf26900ff
+
+/*P2_TMGREG0*/
+#define RSTV0910_P2_TMGREG0  0xf26a
+#define FSTV0910_P2_TMGREG0  0xf26a00ff
+
+/*P2_TMGLOCK1*/
+#define RSTV0910_P2_TMGLOCK1  0xf26b
+#define FSTV0910_P2_TMGLOCK_LEVEL1  0xf26b01ff
+
+/*P2_TMGLOCK0*/
+#define RSTV0910_P2_TMGLOCK0  0xf26c
+#define FSTV0910_P2_TMGLOCK_LEVEL0  0xf26c00ff
+
+/*P2_TMGOBS*/
+#define RSTV0910_P2_TMGOBS  0xf26d
+#define FSTV0910_P2_ROLLOFF_STATUS  0xf26d00c0
+#define FSTV0910_P2_SCAN_SIGN  0xf26d0030
+#define FSTV0910_P2_TMG_SCANNING  0xf26d0008
+#define FSTV0910_P2_CHCENTERING_MODE  0xf26d0004
+#define FSTV0910_P2_TMG_SCANFAIL  0xf26d0002
+
+/*P2_EQUALCFG*/
+#define RSTV0910_P2_EQUALCFG  0xf26f
+#define FSTV0910_P2_NOTMG_NEGALWAIT  0xf26f0080
+#define FSTV0910_P2_EQUAL_ON  0xf26f0040
+#define FSTV0910_P2_SEL_EQUALCOR  0xf26f0038
+#define FSTV0910_P2_MU_EQUALDFE  0xf26f0007
+
+/*P2_EQUAI1*/
+#define RSTV0910_P2_EQUAI1  0xf270
+#define FSTV0910_P2_EQUA_ACCI1  0xf27001ff
+
+/*P2_EQUAQ1*/
+#define RSTV0910_P2_EQUAQ1  0xf271
+#define FSTV0910_P2_EQUA_ACCQ1  0xf27101ff
+
+/*P2_EQUAI2*/
+#define RSTV0910_P2_EQUAI2  0xf272
+#define FSTV0910_P2_EQUA_ACCI2  0xf27201ff
+
+/*P2_EQUAQ2*/
+#define RSTV0910_P2_EQUAQ2  0xf273
+#define FSTV0910_P2_EQUA_ACCQ2  0xf27301ff
+
+/*P2_EQUAI3*/
+#define RSTV0910_P2_EQUAI3  0xf274
+#define FSTV0910_P2_EQUA_ACCI3  0xf27401ff
+
+/*P2_EQUAQ3*/
+#define RSTV0910_P2_EQUAQ3  0xf275
+#define FSTV0910_P2_EQUA_ACCQ3  0xf27501ff
+
+/*P2_EQUAI4*/
+#define RSTV0910_P2_EQUAI4  0xf276
+#define FSTV0910_P2_EQUA_ACCI4  0xf27601ff
+
+/*P2_EQUAQ4*/
+#define RSTV0910_P2_EQUAQ4  0xf277
+#define FSTV0910_P2_EQUA_ACCQ4  0xf27701ff
+
+/*P2_EQUAI5*/
+#define RSTV0910_P2_EQUAI5  0xf278
+#define FSTV0910_P2_EQUA_ACCI5  0xf27801ff
+
+/*P2_EQUAQ5*/
+#define RSTV0910_P2_EQUAQ5  0xf279
+#define FSTV0910_P2_EQUA_ACCQ5  0xf27901ff
+
+/*P2_EQUAI6*/
+#define RSTV0910_P2_EQUAI6  0xf27a
+#define FSTV0910_P2_EQUA_ACCI6  0xf27a01ff
+
+/*P2_EQUAQ6*/
+#define RSTV0910_P2_EQUAQ6  0xf27b
+#define FSTV0910_P2_EQUA_ACCQ6  0xf27b01ff
+
+/*P2_EQUAI7*/
+#define RSTV0910_P2_EQUAI7  0xf27c
+#define FSTV0910_P2_EQUA_ACCI7  0xf27c01ff
+
+/*P2_EQUAQ7*/
+#define RSTV0910_P2_EQUAQ7  0xf27d
+#define FSTV0910_P2_EQUA_ACCQ7  0xf27d01ff
+
+/*P2_EQUAI8*/
+#define RSTV0910_P2_EQUAI8  0xf27e
+#define FSTV0910_P2_EQUA_ACCI8  0xf27e01ff
+
+/*P2_EQUAQ8*/
+#define RSTV0910_P2_EQUAQ8  0xf27f
+#define FSTV0910_P2_EQUA_ACCQ8  0xf27f01ff
+
+/*P2_NNOSDATAT1*/
+#define RSTV0910_P2_NNOSDATAT1  0xf280
+#define FSTV0910_P2_NOSDATAT_NORMED1  0xf28000ff
+
+/*P2_NNOSDATAT0*/
+#define RSTV0910_P2_NNOSDATAT0  0xf281
+#define FSTV0910_P2_NOSDATAT_NORMED0  0xf28100ff
+
+/*P2_NNOSDATA1*/
+#define RSTV0910_P2_NNOSDATA1  0xf282
+#define FSTV0910_P2_NOSDATA_NORMED1  0xf28200ff
+
+/*P2_NNOSDATA0*/
+#define RSTV0910_P2_NNOSDATA0  0xf283
+#define FSTV0910_P2_NOSDATA_NORMED0  0xf28300ff
+
+/*P2_NNOSPLHT1*/
+#define RSTV0910_P2_NNOSPLHT1  0xf284
+#define FSTV0910_P2_NOSPLHT_NORMED1  0xf28400ff
+
+/*P2_NNOSPLHT0*/
+#define RSTV0910_P2_NNOSPLHT0  0xf285
+#define FSTV0910_P2_NOSPLHT_NORMED0  0xf28500ff
+
+/*P2_NNOSPLH1*/
+#define RSTV0910_P2_NNOSPLH1  0xf286
+#define FSTV0910_P2_NOSPLH_NORMED1  0xf28600ff
+
+/*P2_NNOSPLH0*/
+#define RSTV0910_P2_NNOSPLH0  0xf287
+#define FSTV0910_P2_NOSPLH_NORMED0  0xf28700ff
+
+/*P2_NOSDATAT1*/
+#define RSTV0910_P2_NOSDATAT1  0xf288
+#define FSTV0910_P2_NOSDATAT_UNNORMED1  0xf28800ff
+
+/*P2_NOSDATAT0*/
+#define RSTV0910_P2_NOSDATAT0  0xf289
+#define FSTV0910_P2_NOSDATAT_UNNORMED0  0xf28900ff
+
+/*P2_NNOSFRAME1*/
+#define RSTV0910_P2_NNOSFRAME1  0xf28a
+#define FSTV0910_P2_NOSFRAME_NORMED1  0xf28a00ff
+
+/*P2_NNOSFRAME0*/
+#define RSTV0910_P2_NNOSFRAME0  0xf28b
+#define FSTV0910_P2_NOSFRAME_NORMED0  0xf28b00ff
+
+/*P2_NNOSRAD1*/
+#define RSTV0910_P2_NNOSRAD1  0xf28c
+#define FSTV0910_P2_NOSRADIAL_NORMED1  0xf28c00ff
+
+/*P2_NNOSRAD0*/
+#define RSTV0910_P2_NNOSRAD0  0xf28d
+#define FSTV0910_P2_NOSRADIAL_NORMED0  0xf28d00ff
+
+/*P2_NOSCFGF1*/
+#define RSTV0910_P2_NOSCFGF1  0xf28e
+#define FSTV0910_P2_LOWNOISE_MESURE  0xf28e0080
+#define FSTV0910_P2_NOS_DELFRAME  0xf28e0040
+#define FSTV0910_P2_NOSDATA_MODE  0xf28e0030
+#define FSTV0910_P2_FRAMESEL_TYPESEL  0xf28e000c
+#define FSTV0910_P2_FRAMESEL_TYPE  0xf28e0003
+
+/*P2_CAR2CFG*/
+#define RSTV0910_P2_CAR2CFG  0xf290
+#define FSTV0910_P2_DESCRAMB_OFF  0xf2900080
+#define FSTV0910_P2_EN_PHNOSRAM  0xf2900020
+#define FSTV0910_P2_STOP_CFR2UPDATE  0xf2900010
+#define FSTV0910_P2_STOP_NCO2UPDATE  0xf2900008
+#define FSTV0910_P2_ROTA2ON  0xf2900004
+#define FSTV0910_P2_PH_DET_ALGO2  0xf2900003
+
+/*P2_CFR2CFR1*/
+#define RSTV0910_P2_CFR2CFR1  0xf291
+#define FSTV0910_P2_CFR2_S2CONTROL  0xf29100c0
+#define FSTV0910_P2_EN_S2CAR2CENTER  0xf2910020
+#define FSTV0910_P2_BCHERRCFR2_MODE  0xf2910018
+#define FSTV0910_P2_CFR2TOCFR1_BETA  0xf2910007
+
+/*P2_CAR3CFG*/
+#define RSTV0910_P2_CAR3CFG  0xf292
+#define FSTV0910_P2_CARRIER23_MODE  0xf29200c0
+#define FSTV0910_P2_CAR3INTERM_DVBS1  0xf2920020
+#define FSTV0910_P2_ABAMPLIF_MODE  0xf2920018
+#define FSTV0910_P2_CARRIER3_ALPHA3DL  0xf2920007
+
+/*P2_CFR22*/
+#define RSTV0910_P2_CFR22  0xf293
+#define FSTV0910_P2_CAR2_FREQ2  0xf29301ff
+
+/*P2_CFR21*/
+#define RSTV0910_P2_CFR21  0xf294
+#define FSTV0910_P2_CAR2_FREQ1  0xf29400ff
+
+/*P2_CFR20*/
+#define RSTV0910_P2_CFR20  0xf295
+#define FSTV0910_P2_CAR2_FREQ0  0xf29500ff
+
+/*P2_ACLC2S2Q*/
+#define RSTV0910_P2_ACLC2S2Q  0xf297
+#define FSTV0910_P2_ENAB_SPSKSYMB  0xf2970080
+#define FSTV0910_P2_CAR2S2_QANOSAUTO  0xf2970040
+#define FSTV0910_P2_CAR2S2_Q_ALPH_M  0xf2970030
+#define FSTV0910_P2_CAR2S2_Q_ALPH_E  0xf297000f
+
+/*P2_ACLC2S28*/
+#define RSTV0910_P2_ACLC2S28  0xf298
+#define FSTV0910_P2_OLDI3Q_MODE  0xf2980080
+#define FSTV0910_P2_CAR2S2_8ANOSAUTO  0xf2980040
+#define FSTV0910_P2_CAR2S2_8_ALPH_M  0xf2980030
+#define FSTV0910_P2_CAR2S2_8_ALPH_E  0xf298000f
+
+/*P2_ACLC2S216A*/
+#define RSTV0910_P2_ACLC2S216A  0xf299
+#define FSTV0910_P2_CAR2S2_16ANOSAUTO  0xf2990040
+#define FSTV0910_P2_CAR2S2_16A_ALPH_M  0xf2990030
+#define FSTV0910_P2_CAR2S2_16A_ALPH_E  0xf299000f
+
+/*P2_ACLC2S232A*/
+#define RSTV0910_P2_ACLC2S232A  0xf29a
+#define FSTV0910_P2_CAR2S2_32ANOSUATO  0xf29a0040
+#define FSTV0910_P2_CAR2S2_32A_ALPH_M  0xf29a0030
+#define FSTV0910_P2_CAR2S2_32A_ALPH_E  0xf29a000f
+
+/*P2_BCLC2S2Q*/
+#define RSTV0910_P2_BCLC2S2Q  0xf29c
+#define FSTV0910_P2_DVBS2S2Q_NIP  0xf29c0080
+#define FSTV0910_P2_CAR2S2_QBNOSAUTO  0xf29c0040
+#define FSTV0910_P2_CAR2S2_Q_BETA_M  0xf29c0030
+#define FSTV0910_P2_CAR2S2_Q_BETA_E  0xf29c000f
+
+/*P2_BCLC2S28*/
+#define RSTV0910_P2_BCLC2S28  0xf29d
+#define FSTV0910_P2_DVBS2S28_NIP  0xf29d0080
+#define FSTV0910_P2_CAR2S2_8BNOSAUTO  0xf29d0040
+#define FSTV0910_P2_CAR2S2_8_BETA_M  0xf29d0030
+#define FSTV0910_P2_CAR2S2_8_BETA_E  0xf29d000f
+
+/*P2_PLROOT2*/
+#define RSTV0910_P2_PLROOT2  0xf2ac
+#define FSTV0910_P2_PLHAUTO_DISPLH  0xf2ac0040
+#define FSTV0910_P2_PLHAUTO_FASTMODE  0xf2ac0020
+#define FSTV0910_P2_PLHAUTO_ENABLE  0xf2ac0010
+#define FSTV0910_P2_PLSCRAMB_MODE  0xf2ac000c
+#define FSTV0910_P2_PLSCRAMB_ROOT2  0xf2ac0003
+
+/*P2_PLROOT1*/
+#define RSTV0910_P2_PLROOT1  0xf2ad
+#define FSTV0910_P2_PLSCRAMB_ROOT1  0xf2ad00ff
+
+/*P2_PLROOT0*/
+#define RSTV0910_P2_PLROOT0  0xf2ae
+#define FSTV0910_P2_PLSCRAMB_ROOT0  0xf2ae00ff
+
+/*P2_MODCODLST7*/
+#define RSTV0910_P2_MODCODLST7  0xf2b7
+#define FSTV0910_P2_MODCOD_NNOSFILTER  0xf2b70080
+#define FSTV0910_P2_MODCODLST_NOSTYPE  0xf2b70040
+#define FSTV0910_P2_DIS_8PSK_9_10  0xf2b70030
+#define FSTV0910_P2_DIS_8P_8_9  0xf2b7000f
+
+/*P2_MODCODLST8*/
+#define RSTV0910_P2_MODCODLST8  0xf2b8
+#define FSTV0910_P2_DIS_8P_5_6  0xf2b800f0
+#define FSTV0910_P2_DIS_8P_3_4  0xf2b8000f
+
+/*P2_MODCODLST9*/
+#define RSTV0910_P2_MODCODLST9  0xf2b9
+#define FSTV0910_P2_DIS_8P_2_3  0xf2b900f0
+#define FSTV0910_P2_DIS_8P_3_5  0xf2b9000f
+
+/*P2_MODCODLSTA*/
+#define RSTV0910_P2_MODCODLSTA  0xf2ba
+#define FSTV0910_P2_NOSFILTER_LIMITE  0xf2ba0080
+#define FSTV0910_P2_NOSFILTER_MODE  0xf2ba0040
+#define FSTV0910_P2_DIS_QPSK_9_10  0xf2ba0030
+#define FSTV0910_P2_DIS_QP_8_9  0xf2ba000f
+
+/*P2_MODCODLSTB*/
+#define RSTV0910_P2_MODCODLSTB  0xf2bb
+#define FSTV0910_P2_DIS_QP_5_6  0xf2bb00f0
+#define FSTV0910_P2_DIS_QP_4_5  0xf2bb000f
+
+/*P2_MODCODLSTC*/
+#define RSTV0910_P2_MODCODLSTC  0xf2bc
+#define FSTV0910_P2_DIS_QP_3_4  0xf2bc00f0
+#define FSTV0910_P2_DIS_QP_2_3  0xf2bc000f
+
+/*P2_MODCODLSTD*/
+#define RSTV0910_P2_MODCODLSTD  0xf2bd
+#define FSTV0910_P2_DIS_QPSK_3_5  0xf2bd00f0
+#define FSTV0910_P2_DIS_QPSK_1_2  0xf2bd000f
+
+/*P2_GAUSSR0*/
+#define RSTV0910_P2_GAUSSR0  0xf2c0
+#define FSTV0910_P2_EN_CCIMODE  0xf2c00080
+#define FSTV0910_P2_R0_GAUSSIEN  0xf2c0007f
+
+/*P2_CCIR0*/
+#define RSTV0910_P2_CCIR0  0xf2c1
+#define FSTV0910_P2_CCIDETECT_PLHONLY  0xf2c10080
+#define FSTV0910_P2_R0_CCI  0xf2c1007f
+
+/*P2_CCIQUANT*/
+#define RSTV0910_P2_CCIQUANT  0xf2c2
+#define FSTV0910_P2_CCI_BETA  0xf2c200e0
+#define FSTV0910_P2_CCI_QUANT  0xf2c2001f
+
+/*P2_CCITHRES*/
+#define RSTV0910_P2_CCITHRES  0xf2c3
+#define FSTV0910_P2_CCI_THRESHOLD  0xf2c300ff
+
+/*P2_CCIACC*/
+#define RSTV0910_P2_CCIACC  0xf2c4
+#define FSTV0910_P2_CCI_VALUE  0xf2c400ff
+
+/*P2_DSTATUS4*/
+#define RSTV0910_P2_DSTATUS4  0xf2c5
+#define FSTV0910_P2_RAINFADE_DETECT  0xf2c50080
+#define FSTV0910_P2_NOTHRES2_FAIL  0xf2c50040
+#define FSTV0910_P2_NOTHRES1_FAIL  0xf2c50020
+#define FSTV0910_P2_PILOT_FAILDETECT  0xf2c50010
+#define FSTV0910_P2_HIER_DETECT  0xf2c50008
+#define FSTV0910_P2_DMDPROG_ERROR  0xf2c50004
+#define FSTV0910_P2_CSTENV_DETECT  0xf2c50002
+#define FSTV0910_P2_DETECTION_TRIAX  0xf2c50001
+
+/*P2_DMDRESCFG*/
+#define RSTV0910_P2_DMDRESCFG  0xf2c6
+#define FSTV0910_P2_DMDRES_RESET  0xf2c60080
+#define FSTV0910_P2_DMDRES_NOISESQR  0xf2c60010
+#define FSTV0910_P2_DMDRES_STRALL  0xf2c60008
+#define FSTV0910_P2_DMDRES_NEWONLY  0xf2c60004
+#define FSTV0910_P2_DMDRES_NOSTORE  0xf2c60002
+#define FSTV0910_P2_DMDRES_AGC2MEM  0xf2c60001
+
+/*P2_DMDRESADR*/
+#define RSTV0910_P2_DMDRESADR  0xf2c7
+#define FSTV0910_P2_SUSP_PREDCANAL  0xf2c70080
+#define FSTV0910_P2_DMDRES_VALIDCFR  0xf2c70040
+#define FSTV0910_P2_DMDRES_MEMFULL  0xf2c70030
+#define FSTV0910_P2_DMDRES_RESNBR  0xf2c7000f
+
+/*P2_DMDRESDATA7*/
+#define RSTV0910_P2_DMDRESDATA7  0xf2c8
+#define FSTV0910_P2_DMDRES_DATA7  0xf2c800ff
+
+/*P2_DMDRESDATA6*/
+#define RSTV0910_P2_DMDRESDATA6  0xf2c9
+#define FSTV0910_P2_DMDRES_DATA6  0xf2c900ff
+
+/*P2_DMDRESDATA5*/
+#define RSTV0910_P2_DMDRESDATA5  0xf2ca
+#define FSTV0910_P2_DMDRES_DATA5  0xf2ca00ff
+
+/*P2_DMDRESDATA4*/
+#define RSTV0910_P2_DMDRESDATA4  0xf2cb
+#define FSTV0910_P2_DMDRES_DATA4  0xf2cb00ff
+
+/*P2_DMDRESDATA3*/
+#define RSTV0910_P2_DMDRESDATA3  0xf2cc
+#define FSTV0910_P2_DMDRES_DATA3  0xf2cc00ff
+
+/*P2_DMDRESDATA2*/
+#define RSTV0910_P2_DMDRESDATA2  0xf2cd
+#define FSTV0910_P2_DMDRES_DATA2  0xf2cd00ff
+
+/*P2_DMDRESDATA1*/
+#define RSTV0910_P2_DMDRESDATA1  0xf2ce
+#define FSTV0910_P2_DMDRES_DATA1  0xf2ce00ff
+
+/*P2_DMDRESDATA0*/
+#define RSTV0910_P2_DMDRESDATA0  0xf2cf
+#define FSTV0910_P2_DMDRES_DATA0  0xf2cf00ff
+
+/*P2_FFEI1*/
+#define RSTV0910_P2_FFEI1  0xf2d0
+#define FSTV0910_P2_FFE_ACCI1  0xf2d001ff
+
+/*P2_FFEQ1*/
+#define RSTV0910_P2_FFEQ1  0xf2d1
+#define FSTV0910_P2_FFE_ACCQ1  0xf2d101ff
+
+/*P2_FFEI2*/
+#define RSTV0910_P2_FFEI2  0xf2d2
+#define FSTV0910_P2_FFE_ACCI2  0xf2d201ff
+
+/*P2_FFEQ2*/
+#define RSTV0910_P2_FFEQ2  0xf2d3
+#define FSTV0910_P2_FFE_ACCQ2  0xf2d301ff
+
+/*P2_FFEI3*/
+#define RSTV0910_P2_FFEI3  0xf2d4
+#define FSTV0910_P2_FFE_ACCI3  0xf2d401ff
+
+/*P2_FFEQ3*/
+#define RSTV0910_P2_FFEQ3  0xf2d5
+#define FSTV0910_P2_FFE_ACCQ3  0xf2d501ff
+
+/*P2_FFEI4*/
+#define RSTV0910_P2_FFEI4  0xf2d6
+#define FSTV0910_P2_FFE_ACCI4  0xf2d601ff
+
+/*P2_FFEQ4*/
+#define RSTV0910_P2_FFEQ4  0xf2d7
+#define FSTV0910_P2_FFE_ACCQ4  0xf2d701ff
+
+/*P2_FFECFG*/
+#define RSTV0910_P2_FFECFG  0xf2d8
+#define FSTV0910_P2_EQUALFFE_ON  0xf2d80040
+#define FSTV0910_P2_EQUAL_USEDSYMB  0xf2d80030
+#define FSTV0910_P2_MU_EQUALFFE  0xf2d80007
+
+/*P2_TNRCFG2*/
+#define RSTV0910_P2_TNRCFG2  0xf2e1
+#define FSTV0910_P2_TUN_IQSWAP  0xf2e10080
+#define FSTV0910_P2_STB6110_STEP2MHZ  0xf2e10040
+#define FSTV0910_P2_STB6120_DBLI2C  0xf2e10020
+#define FSTV0910_P2_TUNER_WIDEBAND  0xf2e10010
+#define FSTV0910_P2_TUNER_OBSPAGE  0xf2e10008
+#define FSTV0910_P2_DIS_BWCALC  0xf2e10004
+#define FSTV0910_P2_SHORT_WAITSTATES  0xf2e10002
+#define FSTV0910_P2_DIS_2BWAGC1  0xf2e10001
+
+/*P2_SMAPCOEF7*/
+#define RSTV0910_P2_SMAPCOEF7  0xf300
+#define FSTV0910_P2_DIS_QSCALE  0xf3000080
+#define FSTV0910_P2_SMAPCOEF_Q_LLR12  0xf300017f
+
+/*P2_SMAPCOEF6*/
+#define RSTV0910_P2_SMAPCOEF6  0xf301
+#define FSTV0910_P2_DIS_AGC2SCALE  0xf3010080
+#define FSTV0910_P2_DIS_16IQMULT  0xf3010040
+#define FSTV0910_P2_OLD_16APSK47  0xf3010020
+#define FSTV0910_P2_OLD_16APSK12  0xf3010010
+#define FSTV0910_P2_DIS_NEWSCALE  0xf3010008
+#define FSTV0910_P2_ADJ_8PSKLLR1  0xf3010004
+#define FSTV0910_P2_OLD_8PSKLLR1  0xf3010002
+#define FSTV0910_P2_DIS_AB8PSK  0xf3010001
+
+/*P2_SMAPCOEF5*/
+#define RSTV0910_P2_SMAPCOEF5  0xf302
+#define FSTV0910_P2_DIS_8SCALE  0xf3020080
+#define FSTV0910_P2_SMAPCOEF_8P_LLR23  0xf302017f
+
+/*P2_NOSTHRES1*/
+#define RSTV0910_P2_NOSTHRES1  0xf309
+#define FSTV0910_P2_NOS_THRESHOLD1  0xf30900ff
+
+/*P2_NOSTHRES2*/
+#define RSTV0910_P2_NOSTHRES2  0xf30a
+#define FSTV0910_P2_NOS_THRESHOLD2  0xf30a00ff
+
+/*P2_NOSDIFF1*/
+#define RSTV0910_P2_NOSDIFF1  0xf30b
+#define FSTV0910_P2_NOSTHRES1_DIFF  0xf30b00ff
+
+/*P2_RAINFADE*/
+#define RSTV0910_P2_RAINFADE  0xf30c
+#define FSTV0910_P2_NOSTHRES_DATAT  0xf30c0080
+#define FSTV0910_P2_RAINFADE_CNLIMIT  0xf30c0070
+#define FSTV0910_P2_RAINFADE_TIMEOUT  0xf30c0007
+
+/*P2_NOSRAMCFG*/
+#define RSTV0910_P2_NOSRAMCFG  0xf30d
+#define FSTV0910_P2_NOSRAM_DVBS2DATA  0xf30d0080
+#define FSTV0910_P2_NOSRAM_QUADRAT  0xf30d0040
+#define FSTV0910_P2_NOSRAM_ACTIVATION  0xf30d0030
+#define FSTV0910_P2_NOSRAM_CNRONLY  0xf30d0008
+#define FSTV0910_P2_NOSRAM_LGNCNR1  0xf30d0007
+
+/*P2_NOSRAMPOS*/
+#define RSTV0910_P2_NOSRAMPOS  0xf30e
+#define FSTV0910_P2_NOSRAM_LGNCNR0  0xf30e00f0
+#define FSTV0910_P2_NOSRAM_VALIDE  0xf30e0004
+#define FSTV0910_P2_NOSRAM_CNRVAL1  0xf30e0003
+
+/*P2_NOSRAMVAL*/
+#define RSTV0910_P2_NOSRAMVAL  0xf30f
+#define FSTV0910_P2_NOSRAM_CNRVAL0  0xf30f00ff
+
+/*P2_DMDPLHSTAT*/
+#define RSTV0910_P2_DMDPLHSTAT  0xf320
+#define FSTV0910_P2_PLH_STATISTIC  0xf32000ff
+
+/*P2_LOCKTIME3*/
+#define RSTV0910_P2_LOCKTIME3  0xf322
+#define FSTV0910_P2_DEMOD_LOCKTIME3  0xf32200ff
+
+/*P2_LOCKTIME2*/
+#define RSTV0910_P2_LOCKTIME2  0xf323
+#define FSTV0910_P2_DEMOD_LOCKTIME2  0xf32300ff
+
+/*P2_LOCKTIME1*/
+#define RSTV0910_P2_LOCKTIME1  0xf324
+#define FSTV0910_P2_DEMOD_LOCKTIME1  0xf32400ff
+
+/*P2_LOCKTIME0*/
+#define RSTV0910_P2_LOCKTIME0  0xf325
+#define FSTV0910_P2_DEMOD_LOCKTIME0  0xf32500ff
+
+/*P2_VITSCALE*/
+#define RSTV0910_P2_VITSCALE  0xf332
+#define FSTV0910_P2_NVTH_NOSRANGE  0xf3320080
+#define FSTV0910_P2_VERROR_MAXMODE  0xf3320040
+#define FSTV0910_P2_KDIV_MODE  0xf3320030
+#define FSTV0910_P2_NSLOWSN_LOCKED  0xf3320008
+#define FSTV0910_P2_DELOCK_PRFLOSS  0xf3320004
+#define FSTV0910_P2_DIS_RSFLOCK  0xf3320002
+
+/*P2_FECM*/
+#define RSTV0910_P2_FECM  0xf333
+#define FSTV0910_P2_DSS_DVB  0xf3330080
+#define FSTV0910_P2_DEMOD_BYPASS  0xf3330040
+#define FSTV0910_P2_CMP_SLOWMODE  0xf3330020
+#define FSTV0910_P2_DSS_SRCH  0xf3330010
+#define FSTV0910_P2_DIFF_MODEVIT  0xf3330004
+#define FSTV0910_P2_SYNCVIT  0xf3330002
+#define FSTV0910_P2_IQINV  0xf3330001
+
+/*P2_VTH12*/
+#define RSTV0910_P2_VTH12  0xf334
+#define FSTV0910_P2_VTH12  0xf33400ff
+
+/*P2_VTH23*/
+#define RSTV0910_P2_VTH23  0xf335
+#define FSTV0910_P2_VTH23  0xf33500ff
+
+/*P2_VTH34*/
+#define RSTV0910_P2_VTH34  0xf336
+#define FSTV0910_P2_VTH34  0xf33600ff
+
+/*P2_VTH56*/
+#define RSTV0910_P2_VTH56  0xf337
+#define FSTV0910_P2_VTH56  0xf33700ff
+
+/*P2_VTH67*/
+#define RSTV0910_P2_VTH67  0xf338
+#define FSTV0910_P2_VTH67  0xf33800ff
+
+/*P2_VTH78*/
+#define RSTV0910_P2_VTH78  0xf339
+#define FSTV0910_P2_VTH78  0xf33900ff
+
+/*P2_VITCURPUN*/
+#define RSTV0910_P2_VITCURPUN  0xf33a
+#define FSTV0910_P2_CYCLESLIP_VIT  0xf33a0080
+#define FSTV0910_P2_VIT_ROTA180  0xf33a0040
+#define FSTV0910_P2_VIT_ROTA90  0xf33a0020
+#define FSTV0910_P2_VIT_CURPUN  0xf33a001f
+
+/*P2_VERROR*/
+#define RSTV0910_P2_VERROR  0xf33b
+#define FSTV0910_P2_REGERR_VIT  0xf33b00ff
+
+/*P2_PRVIT*/
+#define RSTV0910_P2_PRVIT  0xf33c
+#define FSTV0910_P2_DIS_VTHLOCK  0xf33c0040
+#define FSTV0910_P2_E7_8VIT  0xf33c0020
+#define FSTV0910_P2_E6_7VIT  0xf33c0010
+#define FSTV0910_P2_E5_6VIT  0xf33c0008
+#define FSTV0910_P2_E3_4VIT  0xf33c0004
+#define FSTV0910_P2_E2_3VIT  0xf33c0002
+#define FSTV0910_P2_E1_2VIT  0xf33c0001
+
+/*P2_VAVSRVIT*/
+#define RSTV0910_P2_VAVSRVIT  0xf33d
+#define FSTV0910_P2_AMVIT  0xf33d0080
+#define FSTV0910_P2_FROZENVIT  0xf33d0040
+#define FSTV0910_P2_SNVIT  0xf33d0030
+#define FSTV0910_P2_TOVVIT  0xf33d000c
+#define FSTV0910_P2_HYPVIT  0xf33d0003
+
+/*P2_VSTATUSVIT*/
+#define RSTV0910_P2_VSTATUSVIT  0xf33e
+#define FSTV0910_P2_VITERBI_ON  0xf33e0080
+#define FSTV0910_P2_END_LOOPVIT  0xf33e0040
+#define FSTV0910_P2_VITERBI_DEPRF  0xf33e0020
+#define FSTV0910_P2_PRFVIT  0xf33e0010
+#define FSTV0910_P2_LOCKEDVIT  0xf33e0008
+#define FSTV0910_P2_VITERBI_DELOCK  0xf33e0004
+#define FSTV0910_P2_VIT_DEMODSEL  0xf33e0002
+#define FSTV0910_P2_VITERBI_COMPOUT  0xf33e0001
+
+/*P2_VTHINUSE*/
+#define RSTV0910_P2_VTHINUSE  0xf33f
+#define FSTV0910_P2_VIT_INUSE  0xf33f00ff
+
+/*P2_KDIV12*/
+#define RSTV0910_P2_KDIV12  0xf340
+#define FSTV0910_P2_KDIV12_MANUAL  0xf3400080
+#define FSTV0910_P2_K_DIVIDER_12  0xf340007f
+
+/*P2_KDIV23*/
+#define RSTV0910_P2_KDIV23  0xf341
+#define FSTV0910_P2_KDIV23_MANUAL  0xf3410080
+#define FSTV0910_P2_K_DIVIDER_23  0xf341007f
+
+/*P2_KDIV34*/
+#define RSTV0910_P2_KDIV34  0xf342
+#define FSTV0910_P2_KDIV34_MANUAL  0xf3420080
+#define FSTV0910_P2_K_DIVIDER_34  0xf342007f
+
+/*P2_KDIV56*/
+#define RSTV0910_P2_KDIV56  0xf343
+#define FSTV0910_P2_KDIV56_MANUAL  0xf3430080
+#define FSTV0910_P2_K_DIVIDER_56  0xf343007f
+
+/*P2_KDIV67*/
+#define RSTV0910_P2_KDIV67  0xf344
+#define FSTV0910_P2_KDIV67_MANUAL  0xf3440080
+#define FSTV0910_P2_K_DIVIDER_67  0xf344007f
+
+/*P2_KDIV78*/
+#define RSTV0910_P2_KDIV78  0xf345
+#define FSTV0910_P2_KDIV78_MANUAL  0xf3450080
+#define FSTV0910_P2_K_DIVIDER_78  0xf345007f
+
+/*P2_PDELCTRL0*/
+#define RSTV0910_P2_PDELCTRL0  0xf34f
+#define FSTV0910_P2_ISIOBS_MODE  0xf34f0030
+#define FSTV0910_P2_PDELDIS_BITWISE  0xf34f0004
+
+/*P2_PDELCTRL1*/
+#define RSTV0910_P2_PDELCTRL1  0xf350
+#define FSTV0910_P2_INV_MISMASK  0xf3500080
+#define FSTV0910_P2_FORCE_ACCEPTED  0xf3500040
+#define FSTV0910_P2_FILTER_EN  0xf3500020
+#define FSTV0910_P2_FORCE_PKTDELINUSE  0xf3500010
+#define FSTV0910_P2_HYSTEN  0xf3500008
+#define FSTV0910_P2_HYSTSWRST  0xf3500004
+#define FSTV0910_P2_EN_MIS00  0xf3500002
+#define FSTV0910_P2_ALGOSWRST  0xf3500001
+
+/*P2_PDELCTRL2*/
+#define RSTV0910_P2_PDELCTRL2  0xf351
+#define FSTV0910_P2_FORCE_CONTINUOUS  0xf3510080
+#define FSTV0910_P2_RESET_UPKO_COUNT  0xf3510040
+#define FSTV0910_P2_USER_PKTDELIN_NB  0xf3510020
+#define FSTV0910_P2_DATA_UNBBSCRAMBLED  0xf3510008
+#define FSTV0910_P2_FORCE_LONGPKT  0xf3510004
+#define FSTV0910_P2_FRAME_MODE  0xf3510002
+
+/*P2_HYSTTHRESH*/
+#define RSTV0910_P2_HYSTTHRESH  0xf354
+#define FSTV0910_P2_DELIN_LOCKTHRES  0xf35400f0
+#define FSTV0910_P2_DELIN_UNLOCKTHRES  0xf354000f
+
+/*P2_ISIENTRY*/
+#define RSTV0910_P2_ISIENTRY  0xf35e
+#define FSTV0910_P2_ISI_ENTRY  0xf35e00ff
+
+/*P2_ISIBITENA*/
+#define RSTV0910_P2_ISIBITENA  0xf35f
+#define FSTV0910_P2_ISI_BIT_EN  0xf35f00ff
+
+/*P2_MATSTR1*/
+#define RSTV0910_P2_MATSTR1  0xf360
+#define FSTV0910_P2_MATYPE_CURRENT1  0xf36000ff
+
+/*P2_MATSTR0*/
+#define RSTV0910_P2_MATSTR0  0xf361
+#define FSTV0910_P2_MATYPE_CURRENT0  0xf36100ff
+
+/*P2_UPLSTR1*/
+#define RSTV0910_P2_UPLSTR1  0xf362
+#define FSTV0910_P2_UPL_CURRENT1  0xf36200ff
+
+/*P2_UPLSTR0*/
+#define RSTV0910_P2_UPLSTR0  0xf363
+#define FSTV0910_P2_UPL_CURRENT0  0xf36300ff
+
+/*P2_DFLSTR1*/
+#define RSTV0910_P2_DFLSTR1  0xf364
+#define FSTV0910_P2_DFL_CURRENT1  0xf36400ff
+
+/*P2_DFLSTR0*/
+#define RSTV0910_P2_DFLSTR0  0xf365
+#define FSTV0910_P2_DFL_CURRENT0  0xf36500ff
+
+/*P2_SYNCSTR*/
+#define RSTV0910_P2_SYNCSTR  0xf366
+#define FSTV0910_P2_SYNC_CURRENT  0xf36600ff
+
+/*P2_SYNCDSTR1*/
+#define RSTV0910_P2_SYNCDSTR1  0xf367
+#define FSTV0910_P2_SYNCD_CURRENT1  0xf36700ff
+
+/*P2_SYNCDSTR0*/
+#define RSTV0910_P2_SYNCDSTR0  0xf368
+#define FSTV0910_P2_SYNCD_CURRENT0  0xf36800ff
+
+/*P2_PDELSTATUS1*/
+#define RSTV0910_P2_PDELSTATUS1  0xf369
+#define FSTV0910_P2_PKTDELIN_DELOCK  0xf3690080
+#define FSTV0910_P2_SYNCDUPDFL_BADDFL  0xf3690040
+#define FSTV0910_P2_CONTINUOUS_STREAM  0xf3690020
+#define FSTV0910_P2_UNACCEPTED_STREAM  0xf3690010
+#define FSTV0910_P2_BCH_ERROR_FLAG  0xf3690008
+#define FSTV0910_P2_BBHCRCKO  0xf3690004
+#define FSTV0910_P2_PKTDELIN_LOCK  0xf3690002
+#define FSTV0910_P2_FIRST_LOCK  0xf3690001
+
+/*P2_PDELSTATUS2*/
+#define RSTV0910_P2_PDELSTATUS2  0xf36a
+#define FSTV0910_P2_PKTDEL_DEMODSEL  0xf36a0080
+#define FSTV0910_P2_FRAME_MODCOD  0xf36a007c
+#define FSTV0910_P2_FRAME_TYPE  0xf36a0003
+
+/*P2_BBFCRCKO1*/
+#define RSTV0910_P2_BBFCRCKO1  0xf36b
+#define FSTV0910_P2_BBHCRC_KOCNT1  0xf36b00ff
+
+/*P2_BBFCRCKO0*/
+#define RSTV0910_P2_BBFCRCKO0  0xf36c
+#define FSTV0910_P2_BBHCRC_KOCNT0  0xf36c00ff
+
+/*P2_UPCRCKO1*/
+#define RSTV0910_P2_UPCRCKO1  0xf36d
+#define FSTV0910_P2_PKTCRC_KOCNT1  0xf36d00ff
+
+/*P2_UPCRCKO0*/
+#define RSTV0910_P2_UPCRCKO0  0xf36e
+#define FSTV0910_P2_PKTCRC_KOCNT0  0xf36e00ff
+
+/*P2_PDELCTRL3*/
+#define RSTV0910_P2_PDELCTRL3  0xf36f
+#define FSTV0910_P2_PKTDEL_CONTFAIL  0xf36f0080
+#define FSTV0910_P2_PKTDEL_ENLONGPKT  0xf36f0040
+#define FSTV0910_P2_NOFIFO_BCHERR  0xf36f0020
+#define FSTV0910_P2_PKTDELIN_DELACMERR  0xf36f0010
+#define FSTV0910_P2_SATURATE_BBPKTKO  0xf36f0004
+#define FSTV0910_P2_PKTDEL_BCHERRCONT  0xf36f0002
+#define FSTV0910_P2_ETHERNET_DISFCS  0xf36f0001
+
+/*P2_TSSTATEM*/
+#define RSTV0910_P2_TSSTATEM  0xf370
+#define FSTV0910_P2_TSDIL_ON  0xf3700080
+#define FSTV0910_P2_TSSKIPRS_ON  0xf3700040
+#define FSTV0910_P2_TSRS_ON  0xf3700020
+#define FSTV0910_P2_TSDESCRAMB_ON  0xf3700010
+#define FSTV0910_P2_TSFRAME_MODE  0xf3700008
+#define FSTV0910_P2_TS_DISABLE  0xf3700004
+#define FSTV0910_P2_TSACM_MODE  0xf3700002
+#define FSTV0910_P2_TSOUT_NOSYNC  0xf3700001
+
+/*P2_TSCFGH*/
+#define RSTV0910_P2_TSCFGH  0xf372
+#define FSTV0910_P2_TSFIFO_DVBCI  0xf3720080
+#define FSTV0910_P2_TSFIFO_SERIAL  0xf3720040
+#define FSTV0910_P2_TSFIFO_TEIUPDATE  0xf3720020
+#define FSTV0910_P2_TSFIFO_DUTY50  0xf3720010
+#define FSTV0910_P2_TSFIFO_HSGNLOUT  0xf3720008
+#define FSTV0910_P2_TSFIFO_ERRMODE  0xf3720006
+#define FSTV0910_P2_RST_HWARE  0xf3720001
+
+/*P2_TSCFGM*/
+#define RSTV0910_P2_TSCFGM  0xf373
+#define FSTV0910_P2_TSFIFO_MANSPEED  0xf37300c0
+#define FSTV0910_P2_TSFIFO_PERMDATA  0xf3730020
+#define FSTV0910_P2_TSFIFO_NONEWSGNL  0xf3730010
+#define FSTV0910_P2_NPD_SPECDVBS2  0xf3730004
+#define FSTV0910_P2_TSFIFO_DPUNACTIVE  0xf3730002
+#define FSTV0910_P2_TSFIFO_INVDATA  0xf3730001
+
+/*P2_TSCFGL*/
+#define RSTV0910_P2_TSCFGL  0xf374
+#define FSTV0910_P2_TSFIFO_BCLKDEL1CK  0xf37400c0
+#define FSTV0910_P2_BCHERROR_MODE  0xf3740030
+#define FSTV0910_P2_TSFIFO_NSGNL2DATA  0xf3740008
+#define FSTV0910_P2_TSFIFO_EMBINDVB  0xf3740004
+#define FSTV0910_P2_TSFIFO_BITSPEED  0xf3740003
+
+/*P2_TSINSDELH*/
+#define RSTV0910_P2_TSINSDELH  0xf376
+#define FSTV0910_P2_TSDEL_SYNCBYTE  0xf3760080
+#define FSTV0910_P2_TSDEL_XXHEADER  0xf3760040
+#define FSTV0910_P2_TSDEL_BBHEADER  0xf3760020
+#define FSTV0910_P2_TSDEL_DATAFIELD  0xf3760010
+#define FSTV0910_P2_TSINSDEL_ISCR  0xf3760008
+#define FSTV0910_P2_TSINSDEL_NPD  0xf3760004
+#define FSTV0910_P2_TSINSDEL_RSPARITY  0xf3760002
+#define FSTV0910_P2_TSINSDEL_CRC8  0xf3760001
+
+/*P2_TSDIVN*/
+#define RSTV0910_P2_TSDIVN  0xf379
+#define FSTV0910_P2_TSFIFO_SPEEDMODE  0xf37900c0
+#define FSTV0910_P2_BYTE_OVERSAMPLING  0xf3790038
+#define FSTV0910_P2_TSFIFO_RISEOK  0xf3790007
+
+/*P2_TSCFG4*/
+#define RSTV0910_P2_TSCFG4  0xf37a
+#define FSTV0910_P2_TSFIFO_TSSPEEDMODE  0xf37a00c0
+#define FSTV0910_P2_TSFIFO_HIERSEL  0xf37a0020
+#define FSTV0910_P2_TSFIFO_SPECTOKEN  0xf37a0010
+#define FSTV0910_P2_TSFIFO_MAXMODE  0xf37a0008
+#define FSTV0910_P2_TSFIFO_FRFORCEPKT  0xf37a0004
+#define FSTV0910_P2_EXT_FECSPYIN  0xf37a0002
+#define FSTV0910_P2_TSFIFO_DELSPEEDUP  0xf37a0001
+
+/*P2_TSSPEED*/
+#define RSTV0910_P2_TSSPEED  0xf380
+#define FSTV0910_P2_TSFIFO_OUTSPEED  0xf38000ff
+
+/*P2_TSSTATUS*/
+#define RSTV0910_P2_TSSTATUS  0xf381
+#define FSTV0910_P2_TSFIFO_LINEOK  0xf3810080
+#define FSTV0910_P2_TSFIFO_ERROR  0xf3810040
+#define FSTV0910_P2_TSFIFO_DATA7  0xf3810020
+#define FSTV0910_P2_TSFIFO_NOSYNC  0xf3810010
+#define FSTV0910_P2_ISCR_INITIALIZED  0xf3810008
+#define FSTV0910_P2_TSREGUL_ERROR  0xf3810004
+#define FSTV0910_P2_SOFFIFO_UNREGUL  0xf3810002
+#define FSTV0910_P2_DIL_READY  0xf3810001
+
+/*P2_TSSTATUS2*/
+#define RSTV0910_P2_TSSTATUS2  0xf382
+#define FSTV0910_P2_TSFIFO_DEMODSEL  0xf3820080
+#define FSTV0910_P2_TSFIFOSPEED_STORE  0xf3820040
+#define FSTV0910_P2_DILXX_RESET  0xf3820020
+#define FSTV0910_P2_TSSPEED_IMPOSSIBLE  0xf3820010
+#define FSTV0910_P2_TSFIFO_LINENOK  0xf3820008
+#define FSTV0910_P2_TSFIFO_MUXSTREAM  0xf3820004
+#define FSTV0910_P2_SCRAMBDETECT  0xf3820002
+#define FSTV0910_P2_ULDTV67_FALSELOCK  0xf3820001
+
+/*P2_TSBITRATE1*/
+#define RSTV0910_P2_TSBITRATE1  0xf383
+#define FSTV0910_P2_TSFIFO_BITRATE1  0xf38300ff
+
+/*P2_TSBITRATE0*/
+#define RSTV0910_P2_TSBITRATE0  0xf384
+#define FSTV0910_P2_TSFIFO_BITRATE0  0xf38400ff
+
+/*P2_ERRCTRL1*/
+#define RSTV0910_P2_ERRCTRL1  0xf398
+#define FSTV0910_P2_ERR_SOURCE1  0xf39800f0
+#define FSTV0910_P2_NUM_EVENT1  0xf3980007
+
+/*P2_ERRCNT12*/
+#define RSTV0910_P2_ERRCNT12  0xf399
+#define FSTV0910_P2_ERRCNT1_OLDVALUE  0xf3990080
+#define FSTV0910_P2_ERR_CNT12  0xf399007f
+
+/*P2_ERRCNT11*/
+#define RSTV0910_P2_ERRCNT11  0xf39a
+#define FSTV0910_P2_ERR_CNT11  0xf39a00ff
+
+/*P2_ERRCNT10*/
+#define RSTV0910_P2_ERRCNT10  0xf39b
+#define FSTV0910_P2_ERR_CNT10  0xf39b00ff
+
+/*P2_ERRCTRL2*/
+#define RSTV0910_P2_ERRCTRL2  0xf39c
+#define FSTV0910_P2_ERR_SOURCE2  0xf39c00f0
+#define FSTV0910_P2_NUM_EVENT2  0xf39c0007
+
+/*P2_ERRCNT22*/
+#define RSTV0910_P2_ERRCNT22  0xf39d
+#define FSTV0910_P2_ERRCNT2_OLDVALUE  0xf39d0080
+#define FSTV0910_P2_ERR_CNT22  0xf39d007f
+
+/*P2_ERRCNT21*/
+#define RSTV0910_P2_ERRCNT21  0xf39e
+#define FSTV0910_P2_ERR_CNT21  0xf39e00ff
+
+/*P2_ERRCNT20*/
+#define RSTV0910_P2_ERRCNT20  0xf39f
+#define FSTV0910_P2_ERR_CNT20  0xf39f00ff
+
+/*P2_FECSPY*/
+#define RSTV0910_P2_FECSPY  0xf3a0
+#define FSTV0910_P2_SPY_ENABLE  0xf3a00080
+#define FSTV0910_P2_NO_SYNCBYTE  0xf3a00040
+#define FSTV0910_P2_SERIAL_MODE  0xf3a00020
+#define FSTV0910_P2_UNUSUAL_PACKET  0xf3a00010
+#define FSTV0910_P2_BERMETER_DATAMODE  0xf3a0000c
+#define FSTV0910_P2_BERMETER_LMODE  0xf3a00002
+#define FSTV0910_P2_BERMETER_RESET  0xf3a00001
+
+/*P2_FSPYCFG*/
+#define RSTV0910_P2_FSPYCFG  0xf3a1
+#define FSTV0910_P2_FECSPY_INPUT  0xf3a100c0
+#define FSTV0910_P2_RST_ON_ERROR  0xf3a10020
+#define FSTV0910_P2_ONE_SHOT  0xf3a10010
+#define FSTV0910_P2_I2C_MODE  0xf3a1000c
+#define FSTV0910_P2_SPY_HYSTERESIS  0xf3a10003
+
+/*P2_FSPYDATA*/
+#define RSTV0910_P2_FSPYDATA  0xf3a2
+#define FSTV0910_P2_SPY_STUFFING  0xf3a20080
+#define FSTV0910_P2_NOERROR_PKTJITTER  0xf3a20040
+#define FSTV0910_P2_SPY_CNULLPKT  0xf3a20020
+#define FSTV0910_P2_SPY_OUTDATA_MODE  0xf3a2001f
+
+/*P2_FSPYOUT*/
+#define RSTV0910_P2_FSPYOUT  0xf3a3
+#define FSTV0910_P2_FSPY_DIRECT  0xf3a30080
+#define FSTV0910_P2_SPY_OUTDATA_BUS  0xf3a30038
+#define FSTV0910_P2_STUFF_MODE  0xf3a30007
+
+/*P2_FSTATUS*/
+#define RSTV0910_P2_FSTATUS  0xf3a4
+#define FSTV0910_P2_SPY_ENDSIM  0xf3a40080
+#define FSTV0910_P2_VALID_SIM  0xf3a40040
+#define FSTV0910_P2_FOUND_SIGNAL  0xf3a40020
+#define FSTV0910_P2_DSS_SYNCBYTE  0xf3a40010
+#define FSTV0910_P2_RESULT_STATE  0xf3a4000f
+
+/*P2_FBERCPT4*/
+#define RSTV0910_P2_FBERCPT4  0xf3a8
+#define FSTV0910_P2_FBERMETER_CPT4  0xf3a800ff
+
+/*P2_FBERCPT3*/
+#define RSTV0910_P2_FBERCPT3  0xf3a9
+#define FSTV0910_P2_FBERMETER_CPT3  0xf3a900ff
+
+/*P2_FBERCPT2*/
+#define RSTV0910_P2_FBERCPT2  0xf3aa
+#define FSTV0910_P2_FBERMETER_CPT2  0xf3aa00ff
+
+/*P2_FBERCPT1*/
+#define RSTV0910_P2_FBERCPT1  0xf3ab
+#define FSTV0910_P2_FBERMETER_CPT1  0xf3ab00ff
+
+/*P2_FBERCPT0*/
+#define RSTV0910_P2_FBERCPT0  0xf3ac
+#define FSTV0910_P2_FBERMETER_CPT0  0xf3ac00ff
+
+/*P2_FBERERR2*/
+#define RSTV0910_P2_FBERERR2  0xf3ad
+#define FSTV0910_P2_FBERMETER_ERR2  0xf3ad00ff
+
+/*P2_FBERERR1*/
+#define RSTV0910_P2_FBERERR1  0xf3ae
+#define FSTV0910_P2_FBERMETER_ERR1  0xf3ae00ff
+
+/*P2_FBERERR0*/
+#define RSTV0910_P2_FBERERR0  0xf3af
+#define FSTV0910_P2_FBERMETER_ERR0  0xf3af00ff
+
+/*P2_FSPYBER*/
+#define RSTV0910_P2_FSPYBER  0xf3b2
+#define FSTV0910_P2_FSPYOBS_XORREAD  0xf3b20040
+#define FSTV0910_P2_FSPYBER_OBSMODE  0xf3b20020
+#define FSTV0910_P2_FSPYBER_SYNCBYTE  0xf3b20010
+#define FSTV0910_P2_FSPYBER_UNSYNC  0xf3b20008
+#define FSTV0910_P2_FSPYBER_CTIME  0xf3b20007
+
+/*P2_SFERROR*/
+#define RSTV0910_P2_SFERROR  0xf3c1
+#define FSTV0910_P2_SFEC_REGERR_VIT  0xf3c100ff
+
+/*P2_SFECSTATUS*/
+#define RSTV0910_P2_SFECSTATUS  0xf3c3
+#define FSTV0910_P2_SFEC_ON  0xf3c30080
+#define FSTV0910_P2_SFEC_OFF  0xf3c30040
+#define FSTV0910_P2_LOCKEDSFEC  0xf3c30008
+#define FSTV0910_P2_SFEC_DELOCK  0xf3c30004
+#define FSTV0910_P2_SFEC_DEMODSEL  0xf3c30002
+#define FSTV0910_P2_SFEC_OVFON  0xf3c30001
+
+/*P2_SFKDIV12*/
+#define RSTV0910_P2_SFKDIV12  0xf3c4
+#define FSTV0910_P2_SFECKDIV12_MAN  0xf3c40080
+#define FSTV0910_P2_SFEC_K_DIVIDER_12  0xf3c4007f
+
+/*P2_SFKDIV23*/
+#define RSTV0910_P2_SFKDIV23  0xf3c5
+#define FSTV0910_P2_SFECKDIV23_MAN  0xf3c50080
+#define FSTV0910_P2_SFEC_K_DIVIDER_23  0xf3c5007f
+
+/*P2_SFKDIV34*/
+#define RSTV0910_P2_SFKDIV34  0xf3c6
+#define FSTV0910_P2_SFECKDIV34_MAN  0xf3c60080
+#define FSTV0910_P2_SFEC_K_DIVIDER_34  0xf3c6007f
+
+/*P2_SFKDIV56*/
+#define RSTV0910_P2_SFKDIV56  0xf3c7
+#define FSTV0910_P2_SFECKDIV56_MAN  0xf3c70080
+#define FSTV0910_P2_SFEC_K_DIVIDER_56  0xf3c7007f
+
+/*P2_SFKDIV67*/
+#define RSTV0910_P2_SFKDIV67  0xf3c8
+#define FSTV0910_P2_SFECKDIV67_MAN  0xf3c80080
+#define FSTV0910_P2_SFEC_K_DIVIDER_67  0xf3c8007f
+
+/*P2_SFKDIV78*/
+#define RSTV0910_P2_SFKDIV78  0xf3c9
+#define FSTV0910_P2_SFECKDIV78_MAN  0xf3c90080
+#define FSTV0910_P2_SFEC_K_DIVIDER_78  0xf3c9007f
+
+/*P2_SFSTATUS*/
+#define RSTV0910_P2_SFSTATUS  0xf3cc
+#define FSTV0910_P2_SFEC_LINEOK  0xf3cc0080
+#define FSTV0910_P2_SFEC_ERROR  0xf3cc0040
+#define FSTV0910_P2_SFEC_DATA7  0xf3cc0020
+#define FSTV0910_P2_SFEC_PKTDNBRFAIL  0xf3cc0010
+#define FSTV0910_P2_TSSFEC_DEMODSEL  0xf3cc0008
+#define FSTV0910_P2_SFEC_NOSYNC  0xf3cc0004
+#define FSTV0910_P2_SFEC_UNREGULA  0xf3cc0002
+#define FSTV0910_P2_SFEC_READY  0xf3cc0001
+
+/*P2_SFDLYSET2*/
+#define RSTV0910_P2_SFDLYSET2  0xf3d0
+#define FSTV0910_P2_SFEC_OFFSET  0xf3d000c0
+#define FSTV0910_P2_RST_SFEC  0xf3d00008
+#define FSTV0910_P2_DILDLINE_ERROR  0xf3d00004
+#define FSTV0910_P2_SFEC_DISABLE  0xf3d00002
+#define FSTV0910_P2_SFEC_UNREGUL  0xf3d00001
+
+/*P2_SFERRCTRL*/
+#define RSTV0910_P2_SFERRCTRL  0xf3d8
+#define FSTV0910_P2_SFEC_ERR_SOURCE  0xf3d800f0
+#define FSTV0910_P2_SFEC_NUM_EVENT  0xf3d80007
+
+/*P2_SFERRCNT2*/
+#define RSTV0910_P2_SFERRCNT2  0xf3d9
+#define FSTV0910_P2_SFERRC_OLDVALUE  0xf3d90080
+#define FSTV0910_P2_SFEC_ERR_CNT2  0xf3d9007f
+
+/*P2_SFERRCNT1*/
+#define RSTV0910_P2_SFERRCNT1  0xf3da
+#define FSTV0910_P2_SFEC_ERR_CNT1  0xf3da00ff
+
+/*P2_SFERRCNT0*/
+#define RSTV0910_P2_SFERRCNT0  0xf3db
+#define FSTV0910_P2_SFEC_ERR_CNT0  0xf3db00ff
+
+/*P1_IQCONST*/
+#define RSTV0910_P1_IQCONST  0xf400
+#define FSTV0910_P1_CONSTEL_SELECT  0xf4000060
+#define FSTV0910_P1_IQSYMB_SEL  0xf400001f
+
+/*P1_NOSCFG*/
+#define RSTV0910_P1_NOSCFG  0xf401
+#define FSTV0910_P1_DIS_ACMRATIO  0xf4010080
+#define FSTV0910_P1_NOSIN_EGALSEL  0xf4010040
+#define FSTV0910_P1_DUMMYPL_NOSDATA  0xf4010020
+#define FSTV0910_P1_NOSPLH_BETA  0xf4010018
+#define FSTV0910_P1_NOSDATA_BETA  0xf4010007
+
+/*P1_ISYMB*/
+#define RSTV0910_P1_ISYMB  0xf402
+#define FSTV0910_P1_I_SYMBOL  0xf40201ff
+
+/*P1_QSYMB*/
+#define RSTV0910_P1_QSYMB  0xf403
+#define FSTV0910_P1_Q_SYMBOL  0xf40301ff
+
+/*P1_AGC1CFG*/
+#define RSTV0910_P1_AGC1CFG  0xf404
+#define FSTV0910_P1_DC_FROZEN  0xf4040080
+#define FSTV0910_P1_DC_CORRECT  0xf4040040
+#define FSTV0910_P1_AMM_FROZEN  0xf4040020
+#define FSTV0910_P1_AMM_CORRECT  0xf4040010
+#define FSTV0910_P1_QUAD_FROZEN  0xf4040008
+#define FSTV0910_P1_QUAD_CORRECT  0xf4040004
+#define FSTV0910_P1_DCCOMP_SLOW  0xf4040002
+#define FSTV0910_P1_IQMISM_SLOW  0xf4040001
+
+/*P1_AGC1CN*/
+#define RSTV0910_P1_AGC1CN  0xf406
+#define FSTV0910_P1_AGC1_LOCKED  0xf4060080
+#define FSTV0910_P1_AGC1_OVERFLOW  0xf4060040
+#define FSTV0910_P1_AGC1_NOSLOWLK  0xf4060020
+#define FSTV0910_P1_AGC1_MINPOWER  0xf4060010
+#define FSTV0910_P1_AGCOUT_FAST  0xf4060008
+#define FSTV0910_P1_AGCIQ_BETA  0xf4060007
+
+/*P1_AGC1REF*/
+#define RSTV0910_P1_AGC1REF  0xf407
+#define FSTV0910_P1_AGCIQ_REF  0xf40700ff
+
+/*P1_IDCCOMP*/
+#define RSTV0910_P1_IDCCOMP  0xf408
+#define FSTV0910_P1_IAVERAGE_ADJ  0xf40801ff
+
+/*P1_QDCCOMP*/
+#define RSTV0910_P1_QDCCOMP  0xf409
+#define FSTV0910_P1_QAVERAGE_ADJ  0xf40901ff
+
+/*P1_POWERI*/
+#define RSTV0910_P1_POWERI  0xf40a
+#define FSTV0910_P1_POWER_I  0xf40a00ff
+
+/*P1_POWERQ*/
+#define RSTV0910_P1_POWERQ  0xf40b
+#define FSTV0910_P1_POWER_Q  0xf40b00ff
+
+/*P1_AGC1AMM*/
+#define RSTV0910_P1_AGC1AMM  0xf40c
+#define FSTV0910_P1_AMM_VALUE  0xf40c00ff
+
+/*P1_AGC1QUAD*/
+#define RSTV0910_P1_AGC1QUAD  0xf40d
+#define FSTV0910_P1_QUAD_VALUE  0xf40d01ff
+
+/*P1_AGCIQIN1*/
+#define RSTV0910_P1_AGCIQIN1  0xf40e
+#define FSTV0910_P1_AGCIQ_VALUE1  0xf40e00ff
+
+/*P1_AGCIQIN0*/
+#define RSTV0910_P1_AGCIQIN0  0xf40f
+#define FSTV0910_P1_AGCIQ_VALUE0  0xf40f00ff
+
+/*P1_DEMOD*/
+#define RSTV0910_P1_DEMOD  0xf410
+#define FSTV0910_P1_MANUALS2_ROLLOFF  0xf4100080
+#define FSTV0910_P1_SPECINV_CONTROL  0xf4100030
+#define FSTV0910_P1_MANUALSX_ROLLOFF  0xf4100004
+#define FSTV0910_P1_ROLLOFF_CONTROL  0xf4100003
+
+/*P1_DMDMODCOD*/
+#define RSTV0910_P1_DMDMODCOD  0xf411
+#define FSTV0910_P1_MANUAL_MODCOD  0xf4110080
+#define FSTV0910_P1_DEMOD_MODCOD  0xf411007c
+#define FSTV0910_P1_DEMOD_TYPE  0xf4110003
+
+/*P1_DSTATUS*/
+#define RSTV0910_P1_DSTATUS  0xf412
+#define FSTV0910_P1_CAR_LOCK  0xf4120080
+#define FSTV0910_P1_TMGLOCK_QUALITY  0xf4120060
+#define FSTV0910_P1_SDVBS1_ENABLE  0xf4120010
+#define FSTV0910_P1_LOCK_DEFINITIF  0xf4120008
+#define FSTV0910_P1_TIMING_IS_LOCKED  0xf4120004
+#define FSTV0910_P1_DEMOD_SYSCFG  0xf4120002
+#define FSTV0910_P1_OVADC_DETECT  0xf4120001
+
+/*P1_DSTATUS2*/
+#define RSTV0910_P1_DSTATUS2  0xf413
+#define FSTV0910_P1_DEMOD_DELOCK  0xf4130080
+#define FSTV0910_P1_DEMOD_TIMEOUT  0xf4130040
+#define FSTV0910_P1_MODCODRQ_SYNCTAG  0xf4130020
+#define FSTV0910_P1_POLYPH_SATEVENT  0xf4130010
+#define FSTV0910_P1_AGC1_NOSIGNALACK  0xf4130008
+#define FSTV0910_P1_AGC2_OVERFLOW  0xf4130004
+#define FSTV0910_P1_CFR_OVERFLOW  0xf4130002
+#define FSTV0910_P1_GAMMA_OVERUNDER  0xf4130001
+
+/*P1_DMDCFGMD*/
+#define RSTV0910_P1_DMDCFGMD  0xf414
+#define FSTV0910_P1_DVBS2_ENABLE  0xf4140080
+#define FSTV0910_P1_DVBS1_ENABLE  0xf4140040
+#define FSTV0910_P1_SCAN_ENABLE  0xf4140010
+#define FSTV0910_P1_CFR_AUTOSCAN  0xf4140008
+#define FSTV0910_P1_NOFORCE_RELOCK  0xf4140004
+#define FSTV0910_P1_TUN_RNG  0xf4140003
+
+/*P1_DMDCFG2*/
+#define RSTV0910_P1_DMDCFG2  0xf415
+#define FSTV0910_P1_AGC1_WAITLOCK  0xf4150080
+#define FSTV0910_P1_S1S2_SEQUENTIAL  0xf4150040
+#define FSTV0910_P1_BLINDPEA_MODE  0xf4150020
+#define FSTV0910_P1_INFINITE_RELOCK  0xf4150010
+#define FSTV0910_P1_BWOFFSET_COLDWARM  0xf4150008
+#define FSTV0910_P1_TMGLOCK_NSCANSTOP  0xf4150004
+#define FSTV0910_P1_COARSE_LK3MODE  0xf4150002
+#define FSTV0910_P1_COARSE_LK2MODE  0xf4150001
+
+/*P1_DMDISTATE*/
+#define RSTV0910_P1_DMDISTATE  0xf416
+#define FSTV0910_P1_I2C_NORESETDMODE  0xf4160080
+#define FSTV0910_P1_FORCE_ETAPED  0xf4160040
+#define FSTV0910_P1_SDMDRST_DIRCLK  0xf4160020
+#define FSTV0910_P1_I2C_DEMOD_MODE  0xf416001f
+
+/*P1_DMDT0M*/
+#define RSTV0910_P1_DMDT0M  0xf417
+#define FSTV0910_P1_DMDT0_MIN  0xf41700ff
+
+/*P1_DMDSTATE*/
+#define RSTV0910_P1_DMDSTATE  0xf41b
+#define FSTV0910_P1_DEMOD_LOCKED  0xf41b0080
+#define FSTV0910_P1_HEADER_MODE  0xf41b0060
+#define FSTV0910_P1_DEMOD_MODE  0xf41b001f
+
+/*P1_DMDFLYW*/
+#define RSTV0910_P1_DMDFLYW  0xf41c
+#define FSTV0910_P1_I2C_IRQVAL  0xf41c00f0
+#define FSTV0910_P1_FLYWHEEL_CPT  0xf41c000f
+
+/*P1_DSTATUS3*/
+#define RSTV0910_P1_DSTATUS3  0xf41d
+#define FSTV0910_P1_CFR_ZIGZAG  0xf41d0080
+#define FSTV0910_P1_DEMOD_CFGMODE  0xf41d0060
+#define FSTV0910_P1_GAMMA_LOWBAUDRATE  0xf41d0010
+#define FSTV0910_P1_RELOCK_MODE  0xf41d0008
+#define FSTV0910_P1_DEMOD_FAIL  0xf41d0004
+#define FSTV0910_P1_ETAPE1A_DVBXMEM  0xf41d0003
+
+/*P1_DMDCFG3*/
+#define RSTV0910_P1_DMDCFG3  0xf41e
+#define FSTV0910_P1_DVBS1_TMGWAIT  0xf41e0080
+#define FSTV0910_P1_NO_BWCENTERING  0xf41e0040
+#define FSTV0910_P1_INV_SEQSRCH  0xf41e0020
+#define FSTV0910_P1_DIS_SFRUPLOW_TRK  0xf41e0010
+#define FSTV0910_P1_NOSTOP_FIFOFULL  0xf41e0008
+#define FSTV0910_P1_LOCKTIME_MODE  0xf41e0007
+
+/*P1_DMDCFG4*/
+#define RSTV0910_P1_DMDCFG4  0xf41f
+#define FSTV0910_P1_DIS_VITLOCK  0xf41f0080
+#define FSTV0910_P1_S1S2TOUT_FAST  0xf41f0040
+#define FSTV0910_P1_DEMOD_FASTLOCK  0xf41f0020
+#define FSTV0910_P1_S1HIER_ENABLE  0xf41f0010
+#define FSTV0910_P1_TUNER_NRELAUNCH  0xf41f0008
+#define FSTV0910_P1_DIS_CLKENABLE  0xf41f0004
+#define FSTV0910_P1_DIS_HDRDIVLOCK  0xf41f0002
+#define FSTV0910_P1_NO_TNRWBINIT  0xf41f0001
+
+/*P1_CORRELMANT*/
+#define RSTV0910_P1_CORRELMANT  0xf420
+#define FSTV0910_P1_CORREL_MANT  0xf42000ff
+
+/*P1_CORRELABS*/
+#define RSTV0910_P1_CORRELABS  0xf421
+#define FSTV0910_P1_CORREL_ABS  0xf42100ff
+
+/*P1_CORRELEXP*/
+#define RSTV0910_P1_CORRELEXP  0xf422
+#define FSTV0910_P1_CORREL_ABSEXP  0xf42200f0
+#define FSTV0910_P1_CORREL_EXP  0xf422000f
+
+/*P1_PLHMODCOD*/
+#define RSTV0910_P1_PLHMODCOD  0xf424
+#define FSTV0910_P1_SPECINV_DEMOD  0xf4240080
+#define FSTV0910_P1_PLH_MODCOD  0xf424007c
+#define FSTV0910_P1_PLH_TYPE  0xf4240003
+
+/*P1_DMDREG*/
+#define RSTV0910_P1_DMDREG  0xf425
+#define FSTV0910_P1_EXTPSK_MODE  0xf4250080
+#define FSTV0910_P1_HIER_SHORTFRAME  0xf4250002
+#define FSTV0910_P1_DECIM_PLFRAMES  0xf4250001
+
+/*P1_AGC2O*/
+#define RSTV0910_P1_AGC2O  0xf42c
+#define FSTV0910_P1_CSTENV_MODE  0xf42c00c0
+#define FSTV0910_P1_AGC2_LKSQRT  0xf42c0020
+#define FSTV0910_P1_AGC2_LKMODE  0xf42c0010
+#define FSTV0910_P1_AGC2_LKEQUA  0xf42c0008
+#define FSTV0910_P1_AGC2_COEF  0xf42c0007
+
+/*P1_AGC2REF*/
+#define RSTV0910_P1_AGC2REF  0xf42d
+#define FSTV0910_P1_AGC2_REF  0xf42d00ff
+
+/*P1_AGC1ADJ*/
+#define RSTV0910_P1_AGC1ADJ  0xf42e
+#define FSTV0910_P1_AGC1ADJ_MANUAL  0xf42e0080
+#define FSTV0910_P1_AGC1_ADJUSTED  0xf42e007f
+
+/*P1_AGC2I1*/
+#define RSTV0910_P1_AGC2I1  0xf436
+#define FSTV0910_P1_AGC2_INTEGRATOR1  0xf43600ff
+
+/*P1_AGC2I0*/
+#define RSTV0910_P1_AGC2I0  0xf437
+#define FSTV0910_P1_AGC2_INTEGRATOR0  0xf43700ff
+
+/*P1_CARCFG*/
+#define RSTV0910_P1_CARCFG  0xf438
+#define FSTV0910_P1_CFRUPLOW_AUTO  0xf4380080
+#define FSTV0910_P1_CFRUPLOW_TEST  0xf4380040
+#define FSTV0910_P1_WIDE_FREQDET  0xf4380020
+#define FSTV0910_P1_CARHDR_NODIV8  0xf4380010
+#define FSTV0910_P1_I2C_ROTA  0xf4380008
+#define FSTV0910_P1_ROTAON  0xf4380004
+#define FSTV0910_P1_PH_DET_ALGO  0xf4380003
+
+/*P1_ACLC*/
+#define RSTV0910_P1_ACLC  0xf439
+#define FSTV0910_P1_CARS1_ANOSAUTO  0xf4390040
+#define FSTV0910_P1_CAR_ALPHA_MANT  0xf4390030
+#define FSTV0910_P1_CAR_ALPHA_EXP  0xf439000f
+
+/*P1_BCLC*/
+#define RSTV0910_P1_BCLC  0xf43a
+#define FSTV0910_P1_CARS1_BNOSAUTO  0xf43a0040
+#define FSTV0910_P1_CAR_BETA_MANT  0xf43a0030
+#define FSTV0910_P1_CAR_BETA_EXP  0xf43a000f
+
+/*P1_CARFREQ*/
+#define RSTV0910_P1_CARFREQ  0xf43d
+#define FSTV0910_P1_KC_COARSE_EXP  0xf43d00f0
+#define FSTV0910_P1_BETA_FREQ  0xf43d000f
+
+/*P1_CARHDR*/
+#define RSTV0910_P1_CARHDR  0xf43e
+#define FSTV0910_P1_K_FREQ_HDR  0xf43e00ff
+
+/*P1_LDT*/
+#define RSTV0910_P1_LDT  0xf43f
+#define FSTV0910_P1_CARLOCK_THRES  0xf43f01ff
+
+/*P1_LDT2*/
+#define RSTV0910_P1_LDT2  0xf440
+#define FSTV0910_P1_CARLOCK_THRES2  0xf44001ff
+
+/*P1_CFRICFG*/
+#define RSTV0910_P1_CFRICFG  0xf441
+#define FSTV0910_P1_CFRINIT_UNVALRNG  0xf4410080
+#define FSTV0910_P1_CFRINIT_LUNVALCPT  0xf4410040
+#define FSTV0910_P1_CFRINIT_ABORTDBL  0xf4410020
+#define FSTV0910_P1_CFRINIT_ABORTPRED  0xf4410010
+#define FSTV0910_P1_CFRINIT_UNVALSKIP  0xf4410008
+#define FSTV0910_P1_CFRINIT_CSTINC  0xf4410004
+#define FSTV0910_P1_CFRIROLL_GARDER  0xf4410002
+#define FSTV0910_P1_NEG_CFRSTEP  0xf4410001
+
+/*P1_CFRUP1*/
+#define RSTV0910_P1_CFRUP1  0xf442
+#define FSTV0910_P1_CFR_UP1  0xf44201ff
+
+/*P1_CFRUP0*/
+#define RSTV0910_P1_CFRUP0  0xf443
+#define FSTV0910_P1_CFR_UP0  0xf44300ff
+
+/*P1_CFRIBASE1*/
+#define RSTV0910_P1_CFRIBASE1  0xf444
+#define FSTV0910_P1_CFRINIT_BASE1  0xf44400ff
+
+/*P1_CFRIBASE0*/
+#define RSTV0910_P1_CFRIBASE0  0xf445
+#define FSTV0910_P1_CFRINIT_BASE0  0xf44500ff
+
+/*P1_CFRLOW1*/
+#define RSTV0910_P1_CFRLOW1  0xf446
+#define FSTV0910_P1_CFR_LOW1  0xf44601ff
+
+/*P1_CFRLOW0*/
+#define RSTV0910_P1_CFRLOW0  0xf447
+#define FSTV0910_P1_CFR_LOW0  0xf44700ff
+
+/*P1_CFRINIT1*/
+#define RSTV0910_P1_CFRINIT1  0xf448
+#define FSTV0910_P1_CFR_INIT1  0xf44801ff
+
+/*P1_CFRINIT0*/
+#define RSTV0910_P1_CFRINIT0  0xf449
+#define FSTV0910_P1_CFR_INIT0  0xf44900ff
+
+/*P1_CFRINC1*/
+#define RSTV0910_P1_CFRINC1  0xf44a
+#define FSTV0910_P1_MANUAL_CFRINC  0xf44a0080
+#define FSTV0910_P1_CFR_INC1  0xf44a003f
+
+/*P1_CFRINC0*/
+#define RSTV0910_P1_CFRINC0  0xf44b
+#define FSTV0910_P1_CFR_INC0  0xf44b00ff
+
+/*P1_CFR2*/
+#define RSTV0910_P1_CFR2  0xf44c
+#define FSTV0910_P1_CAR_FREQ2  0xf44c01ff
+
+/*P1_CFR1*/
+#define RSTV0910_P1_CFR1  0xf44d
+#define FSTV0910_P1_CAR_FREQ1  0xf44d00ff
+
+/*P1_CFR0*/
+#define RSTV0910_P1_CFR0  0xf44e
+#define FSTV0910_P1_CAR_FREQ0  0xf44e00ff
+
+/*P1_LDI*/
+#define RSTV0910_P1_LDI  0xf44f
+#define FSTV0910_P1_LOCK_DET_INTEGR  0xf44f01ff
+
+/*P1_TMGCFG*/
+#define RSTV0910_P1_TMGCFG  0xf450
+#define FSTV0910_P1_TMGLOCK_BETA  0xf45000c0
+#define FSTV0910_P1_DO_TIMING_CORR  0xf4500010
+#define FSTV0910_P1_MANUAL_SCAN  0xf450000c
+#define FSTV0910_P1_TMG_MINFREQ  0xf4500003
+
+/*P1_RTC*/
+#define RSTV0910_P1_RTC  0xf451
+#define FSTV0910_P1_TMGALPHA_EXP  0xf45100f0
+#define FSTV0910_P1_TMGBETA_EXP  0xf451000f
+
+/*P1_RTCS2*/
+#define RSTV0910_P1_RTCS2  0xf452
+#define FSTV0910_P1_TMGALPHAS2_EXP  0xf45200f0
+#define FSTV0910_P1_TMGBETAS2_EXP  0xf452000f
+
+/*P1_TMGTHRISE*/
+#define RSTV0910_P1_TMGTHRISE  0xf453
+#define FSTV0910_P1_TMGLOCK_THRISE  0xf45300ff
+
+/*P1_TMGTHFALL*/
+#define RSTV0910_P1_TMGTHFALL  0xf454
+#define FSTV0910_P1_TMGLOCK_THFALL  0xf45400ff
+
+/*P1_SFRUPRATIO*/
+#define RSTV0910_P1_SFRUPRATIO  0xf455
+#define FSTV0910_P1_SFR_UPRATIO  0xf45500ff
+
+/*P1_SFRLOWRATIO*/
+#define RSTV0910_P1_SFRLOWRATIO  0xf456
+#define FSTV0910_P1_SFR_LOWRATIO  0xf45600ff
+
+/*P1_KTTMG*/
+#define RSTV0910_P1_KTTMG  0xf457
+#define FSTV0910_P1_KT_TMG_EXP  0xf45700f0
+
+/*P1_KREFTMG*/
+#define RSTV0910_P1_KREFTMG  0xf458
+#define FSTV0910_P1_KREF_TMG  0xf45800ff
+
+/*P1_SFRSTEP*/
+#define RSTV0910_P1_SFRSTEP  0xf459
+#define FSTV0910_P1_SFR_SCANSTEP  0xf45900f0
+#define FSTV0910_P1_SFR_CENTERSTEP  0xf459000f
+
+/*P1_TMGCFG2*/
+#define RSTV0910_P1_TMGCFG2  0xf45a
+#define FSTV0910_P1_KREFTMG2_DECMODE  0xf45a00c0
+#define FSTV0910_P1_DIS_AUTOSAMP  0xf45a0008
+#define FSTV0910_P1_SCANINIT_QUART  0xf45a0004
+#define FSTV0910_P1_NOTMG_DVBS1DERAT  0xf45a0002
+#define FSTV0910_P1_SFRRATIO_FINE  0xf45a0001
+
+/*P1_KREFTMG2*/
+#define RSTV0910_P1_KREFTMG2  0xf45b
+#define FSTV0910_P1_KREF_TMG2  0xf45b00ff
+
+/*P1_TMGCFG3*/
+#define RSTV0910_P1_TMGCFG3  0xf45d
+#define FSTV0910_P1_CFRINC_MODE  0xf45d0070
+#define FSTV0910_P1_CONT_TMGCENTER  0xf45d0008
+#define FSTV0910_P1_AUTO_GUP  0xf45d0004
+#define FSTV0910_P1_AUTO_GLOW  0xf45d0002
+#define FSTV0910_P1_SFRVAL_MINMODE  0xf45d0001
+
+/*P1_SFRINIT1*/
+#define RSTV0910_P1_SFRINIT1  0xf45e
+#define FSTV0910_P1_SFR_INIT1  0xf45e00ff
+
+/*P1_SFRINIT0*/
+#define RSTV0910_P1_SFRINIT0  0xf45f
+#define FSTV0910_P1_SFR_INIT0  0xf45f00ff
+
+/*P1_SFRUP1*/
+#define RSTV0910_P1_SFRUP1  0xf460
+#define FSTV0910_P1_SYMB_FREQ_UP1  0xf46000ff
+
+/*P1_SFRUP0*/
+#define RSTV0910_P1_SFRUP0  0xf461
+#define FSTV0910_P1_SYMB_FREQ_UP0  0xf46100ff
+
+/*P1_SFRLOW1*/
+#define RSTV0910_P1_SFRLOW1  0xf462
+#define FSTV0910_P1_SYMB_FREQ_LOW1  0xf46200ff
+
+/*P1_SFRLOW0*/
+#define RSTV0910_P1_SFRLOW0  0xf463
+#define FSTV0910_P1_SYMB_FREQ_LOW0  0xf46300ff
+
+/*P1_SFR3*/
+#define RSTV0910_P1_SFR3  0xf464
+#define FSTV0910_P1_SYMB_FREQ3  0xf46400ff
+
+/*P1_SFR2*/
+#define RSTV0910_P1_SFR2  0xf465
+#define FSTV0910_P1_SYMB_FREQ2  0xf46500ff
+
+/*P1_SFR1*/
+#define RSTV0910_P1_SFR1  0xf466
+#define FSTV0910_P1_SYMB_FREQ1  0xf46600ff
+
+/*P1_SFR0*/
+#define RSTV0910_P1_SFR0  0xf467
+#define FSTV0910_P1_SYMB_FREQ0  0xf46700ff
+
+/*P1_TMGREG2*/
+#define RSTV0910_P1_TMGREG2  0xf468
+#define FSTV0910_P1_TMGREG2  0xf46800ff
+
+/*P1_TMGREG1*/
+#define RSTV0910_P1_TMGREG1  0xf469
+#define FSTV0910_P1_TMGREG1  0xf46900ff
+
+/*P1_TMGREG0*/
+#define RSTV0910_P1_TMGREG0  0xf46a
+#define FSTV0910_P1_TMGREG0  0xf46a00ff
+
+/*P1_TMGLOCK1*/
+#define RSTV0910_P1_TMGLOCK1  0xf46b
+#define FSTV0910_P1_TMGLOCK_LEVEL1  0xf46b01ff
+
+/*P1_TMGLOCK0*/
+#define RSTV0910_P1_TMGLOCK0  0xf46c
+#define FSTV0910_P1_TMGLOCK_LEVEL0  0xf46c00ff
+
+/*P1_TMGOBS*/
+#define RSTV0910_P1_TMGOBS  0xf46d
+#define FSTV0910_P1_ROLLOFF_STATUS  0xf46d00c0
+#define FSTV0910_P1_SCAN_SIGN  0xf46d0030
+#define FSTV0910_P1_TMG_SCANNING  0xf46d0008
+#define FSTV0910_P1_CHCENTERING_MODE  0xf46d0004
+#define FSTV0910_P1_TMG_SCANFAIL  0xf46d0002
+
+/*P1_EQUALCFG*/
+#define RSTV0910_P1_EQUALCFG  0xf46f
+#define FSTV0910_P1_NOTMG_NEGALWAIT  0xf46f0080
+#define FSTV0910_P1_EQUAL_ON  0xf46f0040
+#define FSTV0910_P1_SEL_EQUALCOR  0xf46f0038
+#define FSTV0910_P1_MU_EQUALDFE  0xf46f0007
+
+/*P1_EQUAI1*/
+#define RSTV0910_P1_EQUAI1  0xf470
+#define FSTV0910_P1_EQUA_ACCI1  0xf47001ff
+
+/*P1_EQUAQ1*/
+#define RSTV0910_P1_EQUAQ1  0xf471
+#define FSTV0910_P1_EQUA_ACCQ1  0xf47101ff
+
+/*P1_EQUAI2*/
+#define RSTV0910_P1_EQUAI2  0xf472
+#define FSTV0910_P1_EQUA_ACCI2  0xf47201ff
+
+/*P1_EQUAQ2*/
+#define RSTV0910_P1_EQUAQ2  0xf473
+#define FSTV0910_P1_EQUA_ACCQ2  0xf47301ff
+
+/*P1_EQUAI3*/
+#define RSTV0910_P1_EQUAI3  0xf474
+#define FSTV0910_P1_EQUA_ACCI3  0xf47401ff
+
+/*P1_EQUAQ3*/
+#define RSTV0910_P1_EQUAQ3  0xf475
+#define FSTV0910_P1_EQUA_ACCQ3  0xf47501ff
+
+/*P1_EQUAI4*/
+#define RSTV0910_P1_EQUAI4  0xf476
+#define FSTV0910_P1_EQUA_ACCI4  0xf47601ff
+
+/*P1_EQUAQ4*/
+#define RSTV0910_P1_EQUAQ4  0xf477
+#define FSTV0910_P1_EQUA_ACCQ4  0xf47701ff
+
+/*P1_EQUAI5*/
+#define RSTV0910_P1_EQUAI5  0xf478
+#define FSTV0910_P1_EQUA_ACCI5  0xf47801ff
+
+/*P1_EQUAQ5*/
+#define RSTV0910_P1_EQUAQ5  0xf479
+#define FSTV0910_P1_EQUA_ACCQ5  0xf47901ff
+
+/*P1_EQUAI6*/
+#define RSTV0910_P1_EQUAI6  0xf47a
+#define FSTV0910_P1_EQUA_ACCI6  0xf47a01ff
+
+/*P1_EQUAQ6*/
+#define RSTV0910_P1_EQUAQ6  0xf47b
+#define FSTV0910_P1_EQUA_ACCQ6  0xf47b01ff
+
+/*P1_EQUAI7*/
+#define RSTV0910_P1_EQUAI7  0xf47c
+#define FSTV0910_P1_EQUA_ACCI7  0xf47c01ff
+
+/*P1_EQUAQ7*/
+#define RSTV0910_P1_EQUAQ7  0xf47d
+#define FSTV0910_P1_EQUA_ACCQ7  0xf47d01ff
+
+/*P1_EQUAI8*/
+#define RSTV0910_P1_EQUAI8  0xf47e
+#define FSTV0910_P1_EQUA_ACCI8  0xf47e01ff
+
+/*P1_EQUAQ8*/
+#define RSTV0910_P1_EQUAQ8  0xf47f
+#define FSTV0910_P1_EQUA_ACCQ8  0xf47f01ff
+
+/*P1_NNOSDATAT1*/
+#define RSTV0910_P1_NNOSDATAT1  0xf480
+#define FSTV0910_P1_NOSDATAT_NORMED1  0xf48000ff
+
+/*P1_NNOSDATAT0*/
+#define RSTV0910_P1_NNOSDATAT0  0xf481
+#define FSTV0910_P1_NOSDATAT_NORMED0  0xf48100ff
+
+/*P1_NNOSDATA1*/
+#define RSTV0910_P1_NNOSDATA1  0xf482
+#define FSTV0910_P1_NOSDATA_NORMED1  0xf48200ff
+
+/*P1_NNOSDATA0*/
+#define RSTV0910_P1_NNOSDATA0  0xf483
+#define FSTV0910_P1_NOSDATA_NORMED0  0xf48300ff
+
+/*P1_NNOSPLHT1*/
+#define RSTV0910_P1_NNOSPLHT1  0xf484
+#define FSTV0910_P1_NOSPLHT_NORMED1  0xf48400ff
+
+/*P1_NNOSPLHT0*/
+#define RSTV0910_P1_NNOSPLHT0  0xf485
+#define FSTV0910_P1_NOSPLHT_NORMED0  0xf48500ff
+
+/*P1_NNOSPLH1*/
+#define RSTV0910_P1_NNOSPLH1  0xf486
+#define FSTV0910_P1_NOSPLH_NORMED1  0xf48600ff
+
+/*P1_NNOSPLH0*/
+#define RSTV0910_P1_NNOSPLH0  0xf487
+#define FSTV0910_P1_NOSPLH_NORMED0  0xf48700ff
+
+/*P1_NOSDATAT1*/
+#define RSTV0910_P1_NOSDATAT1  0xf488
+#define FSTV0910_P1_NOSDATAT_UNNORMED1  0xf48800ff
+
+/*P1_NOSDATAT0*/
+#define RSTV0910_P1_NOSDATAT0  0xf489
+#define FSTV0910_P1_NOSDATAT_UNNORMED0  0xf48900ff
+
+/*P1_NNOSFRAME1*/
+#define RSTV0910_P1_NNOSFRAME1  0xf48a
+#define FSTV0910_P1_NOSFRAME_NORMED1  0xf48a00ff
+
+/*P1_NNOSFRAME0*/
+#define RSTV0910_P1_NNOSFRAME0  0xf48b
+#define FSTV0910_P1_NOSFRAME_NORMED0  0xf48b00ff
+
+/*P1_NNOSRAD1*/
+#define RSTV0910_P1_NNOSRAD1  0xf48c
+#define FSTV0910_P1_NOSRADIAL_NORMED1  0xf48c00ff
+
+/*P1_NNOSRAD0*/
+#define RSTV0910_P1_NNOSRAD0  0xf48d
+#define FSTV0910_P1_NOSRADIAL_NORMED0  0xf48d00ff
+
+/*P1_NOSCFGF1*/
+#define RSTV0910_P1_NOSCFGF1  0xf48e
+#define FSTV0910_P1_LOWNOISE_MESURE  0xf48e0080
+#define FSTV0910_P1_NOS_DELFRAME  0xf48e0040
+#define FSTV0910_P1_NOSDATA_MODE  0xf48e0030
+#define FSTV0910_P1_FRAMESEL_TYPESEL  0xf48e000c
+#define FSTV0910_P1_FRAMESEL_TYPE  0xf48e0003
+
+/*P1_CAR2CFG*/
+#define RSTV0910_P1_CAR2CFG  0xf490
+#define FSTV0910_P1_DESCRAMB_OFF  0xf4900080
+#define FSTV0910_P1_EN_PHNOSRAM  0xf4900020
+#define FSTV0910_P1_STOP_CFR2UPDATE  0xf4900010
+#define FSTV0910_P1_STOP_NCO2UPDATE  0xf4900008
+#define FSTV0910_P1_ROTA2ON  0xf4900004
+#define FSTV0910_P1_PH_DET_ALGO2  0xf4900003
+
+/*P1_CFR2CFR1*/
+#define RSTV0910_P1_CFR2CFR1  0xf491
+#define FSTV0910_P1_CFR2_S2CONTROL  0xf49100c0
+#define FSTV0910_P1_EN_S2CAR2CENTER  0xf4910020
+#define FSTV0910_P1_BCHERRCFR2_MODE  0xf4910018
+#define FSTV0910_P1_CFR2TOCFR1_BETA  0xf4910007
+
+/*P1_CAR3CFG*/
+#define RSTV0910_P1_CAR3CFG  0xf492
+#define FSTV0910_P1_CARRIER23_MODE  0xf49200c0
+#define FSTV0910_P1_CAR3INTERM_DVBS1  0xf4920020
+#define FSTV0910_P1_ABAMPLIF_MODE  0xf4920018
+#define FSTV0910_P1_CARRIER3_ALPHA3DL  0xf4920007
+
+/*P1_CFR22*/
+#define RSTV0910_P1_CFR22  0xf493
+#define FSTV0910_P1_CAR2_FREQ2  0xf49301ff
+
+/*P1_CFR21*/
+#define RSTV0910_P1_CFR21  0xf494
+#define FSTV0910_P1_CAR2_FREQ1  0xf49400ff
+
+/*P1_CFR20*/
+#define RSTV0910_P1_CFR20  0xf495
+#define FSTV0910_P1_CAR2_FREQ0  0xf49500ff
+
+/*P1_ACLC2S2Q*/
+#define RSTV0910_P1_ACLC2S2Q  0xf497
+#define FSTV0910_P1_ENAB_SPSKSYMB  0xf4970080
+#define FSTV0910_P1_CAR2S2_QANOSAUTO  0xf4970040
+#define FSTV0910_P1_CAR2S2_Q_ALPH_M  0xf4970030
+#define FSTV0910_P1_CAR2S2_Q_ALPH_E  0xf497000f
+
+/*P1_ACLC2S28*/
+#define RSTV0910_P1_ACLC2S28  0xf498
+#define FSTV0910_P1_OLDI3Q_MODE  0xf4980080
+#define FSTV0910_P1_CAR2S2_8ANOSAUTO  0xf4980040
+#define FSTV0910_P1_CAR2S2_8_ALPH_M  0xf4980030
+#define FSTV0910_P1_CAR2S2_8_ALPH_E  0xf498000f
+
+/*P1_ACLC2S216A*/
+#define RSTV0910_P1_ACLC2S216A  0xf499
+#define FSTV0910_P1_CAR2S2_16ANOSAUTO  0xf4990040
+#define FSTV0910_P1_CAR2S2_16A_ALPH_M  0xf4990030
+#define FSTV0910_P1_CAR2S2_16A_ALPH_E  0xf499000f
+
+/*P1_ACLC2S232A*/
+#define RSTV0910_P1_ACLC2S232A  0xf49a
+#define FSTV0910_P1_CAR2S2_32ANOSUATO  0xf49a0040
+#define FSTV0910_P1_CAR2S2_32A_ALPH_M  0xf49a0030
+#define FSTV0910_P1_CAR2S2_32A_ALPH_E  0xf49a000f
+
+/*P1_BCLC2S2Q*/
+#define RSTV0910_P1_BCLC2S2Q  0xf49c
+#define FSTV0910_P1_DVBS2S2Q_NIP  0xf49c0080
+#define FSTV0910_P1_CAR2S2_QBNOSAUTO  0xf49c0040
+#define FSTV0910_P1_CAR2S2_Q_BETA_M  0xf49c0030
+#define FSTV0910_P1_CAR2S2_Q_BETA_E  0xf49c000f
+
+/*P1_BCLC2S28*/
+#define RSTV0910_P1_BCLC2S28  0xf49d
+#define FSTV0910_P1_DVBS2S28_NIP  0xf49d0080
+#define FSTV0910_P1_CAR2S2_8BNOSAUTO  0xf49d0040
+#define FSTV0910_P1_CAR2S2_8_BETA_M  0xf49d0030
+#define FSTV0910_P1_CAR2S2_8_BETA_E  0xf49d000f
+
+/*P1_PLROOT2*/
+#define RSTV0910_P1_PLROOT2  0xf4ac
+#define FSTV0910_P1_PLHAUTO_DISPLH  0xf4ac0040
+#define FSTV0910_P1_PLHAUTO_FASTMODE  0xf4ac0020
+#define FSTV0910_P1_PLHAUTO_ENABLE  0xf4ac0010
+#define FSTV0910_P1_PLSCRAMB_MODE  0xf4ac000c
+#define FSTV0910_P1_PLSCRAMB_ROOT2  0xf4ac0003
+
+/*P1_PLROOT1*/
+#define RSTV0910_P1_PLROOT1  0xf4ad
+#define FSTV0910_P1_PLSCRAMB_ROOT1  0xf4ad00ff
+
+/*P1_PLROOT0*/
+#define RSTV0910_P1_PLROOT0  0xf4ae
+#define FSTV0910_P1_PLSCRAMB_ROOT0  0xf4ae00ff
+
+/*P1_MODCODLST7*/
+#define RSTV0910_P1_MODCODLST7  0xf4b7
+#define FSTV0910_P1_MODCOD_NNOSFILTER  0xf4b70080
+#define FSTV0910_P1_MODCODLST_NOSTYPE  0xf4b70040
+#define FSTV0910_P1_DIS_8PSK_9_10  0xf4b70030
+#define FSTV0910_P1_DIS_8P_8_9  0xf4b7000f
+
+/*P1_MODCODLST8*/
+#define RSTV0910_P1_MODCODLST8  0xf4b8
+#define FSTV0910_P1_DIS_8P_5_6  0xf4b800f0
+#define FSTV0910_P1_DIS_8P_3_4  0xf4b8000f
+
+/*P1_MODCODLST9*/
+#define RSTV0910_P1_MODCODLST9  0xf4b9
+#define FSTV0910_P1_DIS_8P_2_3  0xf4b900f0
+#define FSTV0910_P1_DIS_8P_3_5  0xf4b9000f
+
+/*P1_MODCODLSTA*/
+#define RSTV0910_P1_MODCODLSTA  0xf4ba
+#define FSTV0910_P1_NOSFILTER_LIMITE  0xf4ba0080
+#define FSTV0910_P1_NOSFILTER_MODE  0xf4ba0040
+#define FSTV0910_P1_DIS_QPSK_9_10  0xf4ba0030
+#define FSTV0910_P1_DIS_QP_8_9  0xf4ba000f
+
+/*P1_MODCODLSTB*/
+#define RSTV0910_P1_MODCODLSTB  0xf4bb
+#define FSTV0910_P1_DIS_QP_5_6  0xf4bb00f0
+#define FSTV0910_P1_DIS_QP_4_5  0xf4bb000f
+
+/*P1_MODCODLSTC*/
+#define RSTV0910_P1_MODCODLSTC  0xf4bc
+#define FSTV0910_P1_DIS_QP_3_4  0xf4bc00f0
+#define FSTV0910_P1_DIS_QP_2_3  0xf4bc000f
+
+/*P1_MODCODLSTD*/
+#define RSTV0910_P1_MODCODLSTD  0xf4bd
+#define FSTV0910_P1_DIS_QPSK_3_5  0xf4bd00f0
+#define FSTV0910_P1_DIS_QPSK_1_2  0xf4bd000f
+
+/*P1_GAUSSR0*/
+#define RSTV0910_P1_GAUSSR0  0xf4c0
+#define FSTV0910_P1_EN_CCIMODE  0xf4c00080
+#define FSTV0910_P1_R0_GAUSSIEN  0xf4c0007f
+
+/*P1_CCIR0*/
+#define RSTV0910_P1_CCIR0  0xf4c1
+#define FSTV0910_P1_CCIDETECT_PLHONLY  0xf4c10080
+#define FSTV0910_P1_R0_CCI  0xf4c1007f
+
+/*P1_CCIQUANT*/
+#define RSTV0910_P1_CCIQUANT  0xf4c2
+#define FSTV0910_P1_CCI_BETA  0xf4c200e0
+#define FSTV0910_P1_CCI_QUANT  0xf4c2001f
+
+/*P1_CCITHRES*/
+#define RSTV0910_P1_CCITHRES  0xf4c3
+#define FSTV0910_P1_CCI_THRESHOLD  0xf4c300ff
+
+/*P1_CCIACC*/
+#define RSTV0910_P1_CCIACC  0xf4c4
+#define FSTV0910_P1_CCI_VALUE  0xf4c400ff
+
+/*P1_DSTATUS4*/
+#define RSTV0910_P1_DSTATUS4  0xf4c5
+#define FSTV0910_P1_RAINFADE_DETECT  0xf4c50080
+#define FSTV0910_P1_NOTHRES2_FAIL  0xf4c50040
+#define FSTV0910_P1_NOTHRES1_FAIL  0xf4c50020
+#define FSTV0910_P1_PILOT_FAILDETECT  0xf4c50010
+#define FSTV0910_P1_HIER_DETECT  0xf4c50008
+#define FSTV0910_P1_DMDPROG_ERROR  0xf4c50004
+#define FSTV0910_P1_CSTENV_DETECT  0xf4c50002
+#define FSTV0910_P1_DETECTION_TRIAX  0xf4c50001
+
+/*P1_DMDRESCFG*/
+#define RSTV0910_P1_DMDRESCFG  0xf4c6
+#define FSTV0910_P1_DMDRES_RESET  0xf4c60080
+#define FSTV0910_P1_DMDRES_NOISESQR  0xf4c60010
+#define FSTV0910_P1_DMDRES_STRALL  0xf4c60008
+#define FSTV0910_P1_DMDRES_NEWONLY  0xf4c60004
+#define FSTV0910_P1_DMDRES_NOSTORE  0xf4c60002
+#define FSTV0910_P1_DMDRES_AGC2MEM  0xf4c60001
+
+/*P1_DMDRESADR*/
+#define RSTV0910_P1_DMDRESADR  0xf4c7
+#define FSTV0910_P1_SUSP_PREDCANAL  0xf4c70080
+#define FSTV0910_P1_DMDRES_VALIDCFR  0xf4c70040
+#define FSTV0910_P1_DMDRES_MEMFULL  0xf4c70030
+#define FSTV0910_P1_DMDRES_RESNBR  0xf4c7000f
+
+/*P1_DMDRESDATA7*/
+#define RSTV0910_P1_DMDRESDATA7  0xf4c8
+#define FSTV0910_P1_DMDRES_DATA7  0xf4c800ff
+
+/*P1_DMDRESDATA6*/
+#define RSTV0910_P1_DMDRESDATA6  0xf4c9
+#define FSTV0910_P1_DMDRES_DATA6  0xf4c900ff
+
+/*P1_DMDRESDATA5*/
+#define RSTV0910_P1_DMDRESDATA5  0xf4ca
+#define FSTV0910_P1_DMDRES_DATA5  0xf4ca00ff
+
+/*P1_DMDRESDATA4*/
+#define RSTV0910_P1_DMDRESDATA4  0xf4cb
+#define FSTV0910_P1_DMDRES_DATA4  0xf4cb00ff
+
+/*P1_DMDRESDATA3*/
+#define RSTV0910_P1_DMDRESDATA3  0xf4cc
+#define FSTV0910_P1_DMDRES_DATA3  0xf4cc00ff
+
+/*P1_DMDRESDATA2*/
+#define RSTV0910_P1_DMDRESDATA2  0xf4cd
+#define FSTV0910_P1_DMDRES_DATA2  0xf4cd00ff
+
+/*P1_DMDRESDATA1*/
+#define RSTV0910_P1_DMDRESDATA1  0xf4ce
+#define FSTV0910_P1_DMDRES_DATA1  0xf4ce00ff
+
+/*P1_DMDRESDATA0*/
+#define RSTV0910_P1_DMDRESDATA0  0xf4cf
+#define FSTV0910_P1_DMDRES_DATA0  0xf4cf00ff
+
+/*P1_FFEI1*/
+#define RSTV0910_P1_FFEI1  0xf4d0
+#define FSTV0910_P1_FFE_ACCI1  0xf4d001ff
+
+/*P1_FFEQ1*/
+#define RSTV0910_P1_FFEQ1  0xf4d1
+#define FSTV0910_P1_FFE_ACCQ1  0xf4d101ff
+
+/*P1_FFEI2*/
+#define RSTV0910_P1_FFEI2  0xf4d2
+#define FSTV0910_P1_FFE_ACCI2  0xf4d201ff
+
+/*P1_FFEQ2*/
+#define RSTV0910_P1_FFEQ2  0xf4d3
+#define FSTV0910_P1_FFE_ACCQ2  0xf4d301ff
+
+/*P1_FFEI3*/
+#define RSTV0910_P1_FFEI3  0xf4d4
+#define FSTV0910_P1_FFE_ACCI3  0xf4d401ff
+
+/*P1_FFEQ3*/
+#define RSTV0910_P1_FFEQ3  0xf4d5
+#define FSTV0910_P1_FFE_ACCQ3  0xf4d501ff
+
+/*P1_FFEI4*/
+#define RSTV0910_P1_FFEI4  0xf4d6
+#define FSTV0910_P1_FFE_ACCI4  0xf4d601ff
+
+/*P1_FFEQ4*/
+#define RSTV0910_P1_FFEQ4  0xf4d7
+#define FSTV0910_P1_FFE_ACCQ4  0xf4d701ff
+
+/*P1_FFECFG*/
+#define RSTV0910_P1_FFECFG  0xf4d8
+#define FSTV0910_P1_EQUALFFE_ON  0xf4d80040
+#define FSTV0910_P1_EQUAL_USEDSYMB  0xf4d80030
+#define FSTV0910_P1_MU_EQUALFFE  0xf4d80007
+
+/*P1_TNRCFG2*/
+#define RSTV0910_P1_TNRCFG2  0xf4e1
+#define FSTV0910_P1_TUN_IQSWAP  0xf4e10080
+#define FSTV0910_P1_STB6110_STEP2MHZ  0xf4e10040
+#define FSTV0910_P1_STB6120_DBLI2C  0xf4e10020
+#define FSTV0910_P1_TUNER_WIDEBAND  0xf4e10010
+#define FSTV0910_P1_TUNER_OBSPAGE  0xf4e10008
+#define FSTV0910_P1_DIS_BWCALC  0xf4e10004
+#define FSTV0910_P1_SHORT_WAITSTATES  0xf4e10002
+#define FSTV0910_P1_DIS_2BWAGC1  0xf4e10001
+
+/*P1_SMAPCOEF7*/
+#define RSTV0910_P1_SMAPCOEF7  0xf500
+#define FSTV0910_P1_DIS_QSCALE  0xf5000080
+#define FSTV0910_P1_SMAPCOEF_Q_LLR12  0xf500017f
+
+/*P1_SMAPCOEF6*/
+#define RSTV0910_P1_SMAPCOEF6  0xf501
+#define FSTV0910_P1_DIS_AGC2SCALE  0xf5010080
+#define FSTV0910_P1_DIS_16IQMULT  0xf5010040
+#define FSTV0910_P1_OLD_16APSK47  0xf5010020
+#define FSTV0910_P1_OLD_16APSK12  0xf5010010
+#define FSTV0910_P1_DIS_NEWSCALE  0xf5010008
+#define FSTV0910_P1_ADJ_8PSKLLR1  0xf5010004
+#define FSTV0910_P1_OLD_8PSKLLR1  0xf5010002
+#define FSTV0910_P1_DIS_AB8PSK  0xf5010001
+
+/*P1_SMAPCOEF5*/
+#define RSTV0910_P1_SMAPCOEF5  0xf502
+#define FSTV0910_P1_DIS_8SCALE  0xf5020080
+#define FSTV0910_P1_SMAPCOEF_8P_LLR23  0xf502017f
+
+/*P1_NOSTHRES1*/
+#define RSTV0910_P1_NOSTHRES1  0xf509
+#define FSTV0910_P1_NOS_THRESHOLD1  0xf50900ff
+
+/*P1_NOSTHRES2*/
+#define RSTV0910_P1_NOSTHRES2  0xf50a
+#define FSTV0910_P1_NOS_THRESHOLD2  0xf50a00ff
+
+/*P1_NOSDIFF1*/
+#define RSTV0910_P1_NOSDIFF1  0xf50b
+#define FSTV0910_P1_NOSTHRES1_DIFF  0xf50b00ff
+
+/*P1_RAINFADE*/
+#define RSTV0910_P1_RAINFADE  0xf50c
+#define FSTV0910_P1_NOSTHRES_DATAT  0xf50c0080
+#define FSTV0910_P1_RAINFADE_CNLIMIT  0xf50c0070
+#define FSTV0910_P1_RAINFADE_TIMEOUT  0xf50c0007
+
+/*P1_NOSRAMCFG*/
+#define RSTV0910_P1_NOSRAMCFG  0xf50d
+#define FSTV0910_P1_NOSRAM_DVBS2DATA  0xf50d0080
+#define FSTV0910_P1_NOSRAM_QUADRAT  0xf50d0040
+#define FSTV0910_P1_NOSRAM_ACTIVATION  0xf50d0030
+#define FSTV0910_P1_NOSRAM_CNRONLY  0xf50d0008
+#define FSTV0910_P1_NOSRAM_LGNCNR1  0xf50d0007
+
+/*P1_NOSRAMPOS*/
+#define RSTV0910_P1_NOSRAMPOS  0xf50e
+#define FSTV0910_P1_NOSRAM_LGNCNR0  0xf50e00f0
+#define FSTV0910_P1_NOSRAM_VALIDE  0xf50e0004
+#define FSTV0910_P1_NOSRAM_CNRVAL1  0xf50e0003
+
+/*P1_NOSRAMVAL*/
+#define RSTV0910_P1_NOSRAMVAL  0xf50f
+#define FSTV0910_P1_NOSRAM_CNRVAL0  0xf50f00ff
+
+/*P1_DMDPLHSTAT*/
+#define RSTV0910_P1_DMDPLHSTAT  0xf520
+#define FSTV0910_P1_PLH_STATISTIC  0xf52000ff
+
+/*P1_LOCKTIME3*/
+#define RSTV0910_P1_LOCKTIME3  0xf522
+#define FSTV0910_P1_DEMOD_LOCKTIME3  0xf52200ff
+
+/*P1_LOCKTIME2*/
+#define RSTV0910_P1_LOCKTIME2  0xf523
+#define FSTV0910_P1_DEMOD_LOCKTIME2  0xf52300ff
+
+/*P1_LOCKTIME1*/
+#define RSTV0910_P1_LOCKTIME1  0xf524
+#define FSTV0910_P1_DEMOD_LOCKTIME1  0xf52400ff
+
+/*P1_LOCKTIME0*/
+#define RSTV0910_P1_LOCKTIME0  0xf525
+#define FSTV0910_P1_DEMOD_LOCKTIME0  0xf52500ff
+
+/*P1_VITSCALE*/
+#define RSTV0910_P1_VITSCALE  0xf532
+#define FSTV0910_P1_NVTH_NOSRANGE  0xf5320080
+#define FSTV0910_P1_VERROR_MAXMODE  0xf5320040
+#define FSTV0910_P1_KDIV_MODE  0xf5320030
+#define FSTV0910_P1_NSLOWSN_LOCKED  0xf5320008
+#define FSTV0910_P1_DELOCK_PRFLOSS  0xf5320004
+#define FSTV0910_P1_DIS_RSFLOCK  0xf5320002
+
+/*P1_FECM*/
+#define RSTV0910_P1_FECM  0xf533
+#define FSTV0910_P1_DSS_DVB  0xf5330080
+#define FSTV0910_P1_DEMOD_BYPASS  0xf5330040
+#define FSTV0910_P1_CMP_SLOWMODE  0xf5330020
+#define FSTV0910_P1_DSS_SRCH  0xf5330010
+#define FSTV0910_P1_DIFF_MODEVIT  0xf5330004
+#define FSTV0910_P1_SYNCVIT  0xf5330002
+#define FSTV0910_P1_IQINV  0xf5330001
+
+/*P1_VTH12*/
+#define RSTV0910_P1_VTH12  0xf534
+#define FSTV0910_P1_VTH12  0xf53400ff
+
+/*P1_VTH23*/
+#define RSTV0910_P1_VTH23  0xf535
+#define FSTV0910_P1_VTH23  0xf53500ff
+
+/*P1_VTH34*/
+#define RSTV0910_P1_VTH34  0xf536
+#define FSTV0910_P1_VTH34  0xf53600ff
+
+/*P1_VTH56*/
+#define RSTV0910_P1_VTH56  0xf537
+#define FSTV0910_P1_VTH56  0xf53700ff
+
+/*P1_VTH67*/
+#define RSTV0910_P1_VTH67  0xf538
+#define FSTV0910_P1_VTH67  0xf53800ff
+
+/*P1_VTH78*/
+#define RSTV0910_P1_VTH78  0xf539
+#define FSTV0910_P1_VTH78  0xf53900ff
+
+/*P1_VITCURPUN*/
+#define RSTV0910_P1_VITCURPUN  0xf53a
+#define FSTV0910_P1_CYCLESLIP_VIT  0xf53a0080
+#define FSTV0910_P1_VIT_ROTA180  0xf53a0040
+#define FSTV0910_P1_VIT_ROTA90  0xf53a0020
+#define FSTV0910_P1_VIT_CURPUN  0xf53a001f
+
+/*P1_VERROR*/
+#define RSTV0910_P1_VERROR  0xf53b
+#define FSTV0910_P1_REGERR_VIT  0xf53b00ff
+
+/*P1_PRVIT*/
+#define RSTV0910_P1_PRVIT  0xf53c
+#define FSTV0910_P1_DIS_VTHLOCK  0xf53c0040
+#define FSTV0910_P1_E7_8VIT  0xf53c0020
+#define FSTV0910_P1_E6_7VIT  0xf53c0010
+#define FSTV0910_P1_E5_6VIT  0xf53c0008
+#define FSTV0910_P1_E3_4VIT  0xf53c0004
+#define FSTV0910_P1_E2_3VIT  0xf53c0002
+#define FSTV0910_P1_E1_2VIT  0xf53c0001
+
+/*P1_VAVSRVIT*/
+#define RSTV0910_P1_VAVSRVIT  0xf53d
+#define FSTV0910_P1_AMVIT  0xf53d0080
+#define FSTV0910_P1_FROZENVIT  0xf53d0040
+#define FSTV0910_P1_SNVIT  0xf53d0030
+#define FSTV0910_P1_TOVVIT  0xf53d000c
+#define FSTV0910_P1_HYPVIT  0xf53d0003
+
+/*P1_VSTATUSVIT*/
+#define RSTV0910_P1_VSTATUSVIT  0xf53e
+#define FSTV0910_P1_VITERBI_ON  0xf53e0080
+#define FSTV0910_P1_END_LOOPVIT  0xf53e0040
+#define FSTV0910_P1_VITERBI_DEPRF  0xf53e0020
+#define FSTV0910_P1_PRFVIT  0xf53e0010
+#define FSTV0910_P1_LOCKEDVIT  0xf53e0008
+#define FSTV0910_P1_VITERBI_DELOCK  0xf53e0004
+#define FSTV0910_P1_VIT_DEMODSEL  0xf53e0002
+#define FSTV0910_P1_VITERBI_COMPOUT  0xf53e0001
+
+/*P1_VTHINUSE*/
+#define RSTV0910_P1_VTHINUSE  0xf53f
+#define FSTV0910_P1_VIT_INUSE  0xf53f00ff
+
+/*P1_KDIV12*/
+#define RSTV0910_P1_KDIV12  0xf540
+#define FSTV0910_P1_KDIV12_MANUAL  0xf5400080
+#define FSTV0910_P1_K_DIVIDER_12  0xf540007f
+
+/*P1_KDIV23*/
+#define RSTV0910_P1_KDIV23  0xf541
+#define FSTV0910_P1_KDIV23_MANUAL  0xf5410080
+#define FSTV0910_P1_K_DIVIDER_23  0xf541007f
+
+/*P1_KDIV34*/
+#define RSTV0910_P1_KDIV34  0xf542
+#define FSTV0910_P1_KDIV34_MANUAL  0xf5420080
+#define FSTV0910_P1_K_DIVIDER_34  0xf542007f
+
+/*P1_KDIV56*/
+#define RSTV0910_P1_KDIV56  0xf543
+#define FSTV0910_P1_KDIV56_MANUAL  0xf5430080
+#define FSTV0910_P1_K_DIVIDER_56  0xf543007f
+
+/*P1_KDIV67*/
+#define RSTV0910_P1_KDIV67  0xf544
+#define FSTV0910_P1_KDIV67_MANUAL  0xf5440080
+#define FSTV0910_P1_K_DIVIDER_67  0xf544007f
+
+/*P1_KDIV78*/
+#define RSTV0910_P1_KDIV78  0xf545
+#define FSTV0910_P1_KDIV78_MANUAL  0xf5450080
+#define FSTV0910_P1_K_DIVIDER_78  0xf545007f
+
+/*P1_PDELCTRL0*/
+#define RSTV0910_P1_PDELCTRL0  0xf54f
+#define FSTV0910_P1_ISIOBS_MODE  0xf54f0030
+#define FSTV0910_P1_PDELDIS_BITWISE  0xf54f0004
+
+/*P1_PDELCTRL1*/
+#define RSTV0910_P1_PDELCTRL1  0xf550
+#define FSTV0910_P1_INV_MISMASK  0xf5500080
+#define FSTV0910_P1_FORCE_ACCEPTED  0xf5500040
+#define FSTV0910_P1_FILTER_EN  0xf5500020
+#define FSTV0910_P1_FORCE_PKTDELINUSE  0xf5500010
+#define FSTV0910_P1_HYSTEN  0xf5500008
+#define FSTV0910_P1_HYSTSWRST  0xf5500004
+#define FSTV0910_P1_EN_MIS00  0xf5500002
+#define FSTV0910_P1_ALGOSWRST  0xf5500001
+
+/*P1_PDELCTRL2*/
+#define RSTV0910_P1_PDELCTRL2  0xf551
+#define FSTV0910_P1_FORCE_CONTINUOUS  0xf5510080
+#define FSTV0910_P1_RESET_UPKO_COUNT  0xf5510040
+#define FSTV0910_P1_USER_PKTDELIN_NB  0xf5510020
+#define FSTV0910_P1_DATA_UNBBSCRAMBLED  0xf5510008
+#define FSTV0910_P1_FORCE_LONGPKT  0xf5510004
+#define FSTV0910_P1_FRAME_MODE  0xf5510002
+
+/*P1_HYSTTHRESH*/
+#define RSTV0910_P1_HYSTTHRESH  0xf554
+#define FSTV0910_P1_DELIN_LOCKTHRES  0xf55400f0
+#define FSTV0910_P1_DELIN_UNLOCKTHRES  0xf554000f
+
+/*P1_ISIENTRY*/
+#define RSTV0910_P1_ISIENTRY  0xf55e
+#define FSTV0910_P1_ISI_ENTRY  0xf55e00ff
+
+/*P1_ISIBITENA*/
+#define RSTV0910_P1_ISIBITENA  0xf55f
+#define FSTV0910_P1_ISI_BIT_EN  0xf55f00ff
+
+/*P1_MATSTR1*/
+#define RSTV0910_P1_MATSTR1  0xf560
+#define FSTV0910_P1_MATYPE_CURRENT1  0xf56000ff
+
+/*P1_MATSTR0*/
+#define RSTV0910_P1_MATSTR0  0xf561
+#define FSTV0910_P1_MATYPE_CURRENT0  0xf56100ff
+
+/*P1_UPLSTR1*/
+#define RSTV0910_P1_UPLSTR1  0xf562
+#define FSTV0910_P1_UPL_CURRENT1  0xf56200ff
+
+/*P1_UPLSTR0*/
+#define RSTV0910_P1_UPLSTR0  0xf563
+#define FSTV0910_P1_UPL_CURRENT0  0xf56300ff
+
+/*P1_DFLSTR1*/
+#define RSTV0910_P1_DFLSTR1  0xf564
+#define FSTV0910_P1_DFL_CURRENT1  0xf56400ff
+
+/*P1_DFLSTR0*/
+#define RSTV0910_P1_DFLSTR0  0xf565
+#define FSTV0910_P1_DFL_CURRENT0  0xf56500ff
+
+/*P1_SYNCSTR*/
+#define RSTV0910_P1_SYNCSTR  0xf566
+#define FSTV0910_P1_SYNC_CURRENT  0xf56600ff
+
+/*P1_SYNCDSTR1*/
+#define RSTV0910_P1_SYNCDSTR1  0xf567
+#define FSTV0910_P1_SYNCD_CURRENT1  0xf56700ff
+
+/*P1_SYNCDSTR0*/
+#define RSTV0910_P1_SYNCDSTR0  0xf568
+#define FSTV0910_P1_SYNCD_CURRENT0  0xf56800ff
+
+/*P1_PDELSTATUS1*/
+#define RSTV0910_P1_PDELSTATUS1  0xf569
+#define FSTV0910_P1_PKTDELIN_DELOCK  0xf5690080
+#define FSTV0910_P1_SYNCDUPDFL_BADDFL  0xf5690040
+#define FSTV0910_P1_CONTINUOUS_STREAM  0xf5690020
+#define FSTV0910_P1_UNACCEPTED_STREAM  0xf5690010
+#define FSTV0910_P1_BCH_ERROR_FLAG  0xf5690008
+#define FSTV0910_P1_BBHCRCKO  0xf5690004
+#define FSTV0910_P1_PKTDELIN_LOCK  0xf5690002
+#define FSTV0910_P1_FIRST_LOCK  0xf5690001
+
+/*P1_PDELSTATUS2*/
+#define RSTV0910_P1_PDELSTATUS2  0xf56a
+#define FSTV0910_P1_PKTDEL_DEMODSEL  0xf56a0080
+#define FSTV0910_P1_FRAME_MODCOD  0xf56a007c
+#define FSTV0910_P1_FRAME_TYPE  0xf56a0003
+
+/*P1_BBFCRCKO1*/
+#define RSTV0910_P1_BBFCRCKO1  0xf56b
+#define FSTV0910_P1_BBHCRC_KOCNT1  0xf56b00ff
+
+/*P1_BBFCRCKO0*/
+#define RSTV0910_P1_BBFCRCKO0  0xf56c
+#define FSTV0910_P1_BBHCRC_KOCNT0  0xf56c00ff
+
+/*P1_UPCRCKO1*/
+#define RSTV0910_P1_UPCRCKO1  0xf56d
+#define FSTV0910_P1_PKTCRC_KOCNT1  0xf56d00ff
+
+/*P1_UPCRCKO0*/
+#define RSTV0910_P1_UPCRCKO0  0xf56e
+#define FSTV0910_P1_PKTCRC_KOCNT0  0xf56e00ff
+
+/*P1_PDELCTRL3*/
+#define RSTV0910_P1_PDELCTRL3  0xf56f
+#define FSTV0910_P1_PKTDEL_CONTFAIL  0xf56f0080
+#define FSTV0910_P1_PKTDEL_ENLONGPKT  0xf56f0040
+#define FSTV0910_P1_NOFIFO_BCHERR  0xf56f0020
+#define FSTV0910_P1_PKTDELIN_DELACMERR  0xf56f0010
+#define FSTV0910_P1_SATURATE_BBPKTKO  0xf56f0004
+#define FSTV0910_P1_PKTDEL_BCHERRCONT  0xf56f0002
+#define FSTV0910_P1_ETHERNET_DISFCS  0xf56f0001
+
+/*P1_TSSTATEM*/
+#define RSTV0910_P1_TSSTATEM  0xf570
+#define FSTV0910_P1_TSDIL_ON  0xf5700080
+#define FSTV0910_P1_TSSKIPRS_ON  0xf5700040
+#define FSTV0910_P1_TSRS_ON  0xf5700020
+#define FSTV0910_P1_TSDESCRAMB_ON  0xf5700010
+#define FSTV0910_P1_TSFRAME_MODE  0xf5700008
+#define FSTV0910_P1_TS_DISABLE  0xf5700004
+#define FSTV0910_P1_TSACM_MODE  0xf5700002
+#define FSTV0910_P1_TSOUT_NOSYNC  0xf5700001
+
+/*P1_TSCFGH*/
+#define RSTV0910_P1_TSCFGH  0xf572
+#define FSTV0910_P1_TSFIFO_DVBCI  0xf5720080
+#define FSTV0910_P1_TSFIFO_SERIAL  0xf5720040
+#define FSTV0910_P1_TSFIFO_TEIUPDATE  0xf5720020
+#define FSTV0910_P1_TSFIFO_DUTY50  0xf5720010
+#define FSTV0910_P1_TSFIFO_HSGNLOUT  0xf5720008
+#define FSTV0910_P1_TSFIFO_ERRMODE  0xf5720006
+#define FSTV0910_P1_RST_HWARE  0xf5720001
+
+/*P1_TSCFGM*/
+#define RSTV0910_P1_TSCFGM  0xf573
+#define FSTV0910_P1_TSFIFO_MANSPEED  0xf57300c0
+#define FSTV0910_P1_TSFIFO_PERMDATA  0xf5730020
+#define FSTV0910_P1_TSFIFO_NONEWSGNL  0xf5730010
+#define FSTV0910_P1_NPD_SPECDVBS2  0xf5730004
+#define FSTV0910_P1_TSFIFO_DPUNACTIVE  0xf5730002
+#define FSTV0910_P1_TSFIFO_INVDATA  0xf5730001
+
+/*P1_TSCFGL*/
+#define RSTV0910_P1_TSCFGL  0xf574
+#define FSTV0910_P1_TSFIFO_BCLKDEL1CK  0xf57400c0
+#define FSTV0910_P1_BCHERROR_MODE  0xf5740030
+#define FSTV0910_P1_TSFIFO_NSGNL2DATA  0xf5740008
+#define FSTV0910_P1_TSFIFO_EMBINDVB  0xf5740004
+#define FSTV0910_P1_TSFIFO_BITSPEED  0xf5740003
+
+/*P1_TSINSDELH*/
+#define RSTV0910_P1_TSINSDELH  0xf576
+#define FSTV0910_P1_TSDEL_SYNCBYTE  0xf5760080
+#define FSTV0910_P1_TSDEL_XXHEADER  0xf5760040
+#define FSTV0910_P1_TSDEL_BBHEADER  0xf5760020
+#define FSTV0910_P1_TSDEL_DATAFIELD  0xf5760010
+#define FSTV0910_P1_TSINSDEL_ISCR  0xf5760008
+#define FSTV0910_P1_TSINSDEL_NPD  0xf5760004
+#define FSTV0910_P1_TSINSDEL_RSPARITY  0xf5760002
+#define FSTV0910_P1_TSINSDEL_CRC8  0xf5760001
+
+/*P1_TSDIVN*/
+#define RSTV0910_P1_TSDIVN  0xf579
+#define FSTV0910_P1_TSFIFO_SPEEDMODE  0xf57900c0
+#define FSTV0910_P1_BYTE_OVERSAMPLING  0xf5790038
+#define FSTV0910_P1_TSFIFO_RISEOK  0xf5790007
+
+/*P1_TSCFG4*/
+#define RSTV0910_P1_TSCFG4  0xf57a
+#define FSTV0910_P1_TSFIFO_TSSPEEDMODE  0xf57a00c0
+#define FSTV0910_P1_TSFIFO_HIERSEL  0xf57a0020
+#define FSTV0910_P1_TSFIFO_SPECTOKEN  0xf57a0010
+#define FSTV0910_P1_TSFIFO_MAXMODE  0xf57a0008
+#define FSTV0910_P1_TSFIFO_FRFORCEPKT  0xf57a0004
+#define FSTV0910_P1_EXT_FECSPYIN  0xf57a0002
+#define FSTV0910_P1_TSFIFO_DELSPEEDUP  0xf57a0001
+
+/*P1_TSSPEED*/
+#define RSTV0910_P1_TSSPEED  0xf580
+#define FSTV0910_P1_TSFIFO_OUTSPEED  0xf58000ff
+
+/*P1_TSSTATUS*/
+#define RSTV0910_P1_TSSTATUS  0xf581
+#define FSTV0910_P1_TSFIFO_LINEOK  0xf5810080
+#define FSTV0910_P1_TSFIFO_ERROR  0xf5810040
+#define FSTV0910_P1_TSFIFO_DATA7  0xf5810020
+#define FSTV0910_P1_TSFIFO_NOSYNC  0xf5810010
+#define FSTV0910_P1_ISCR_INITIALIZED  0xf5810008
+#define FSTV0910_P1_TSREGUL_ERROR  0xf5810004
+#define FSTV0910_P1_SOFFIFO_UNREGUL  0xf5810002
+#define FSTV0910_P1_DIL_READY  0xf5810001
+
+/*P1_TSSTATUS2*/
+#define RSTV0910_P1_TSSTATUS2  0xf582
+#define FSTV0910_P1_TSFIFO_DEMODSEL  0xf5820080
+#define FSTV0910_P1_TSFIFOSPEED_STORE  0xf5820040
+#define FSTV0910_P1_DILXX_RESET  0xf5820020
+#define FSTV0910_P1_TSSPEED_IMPOSSIBLE  0xf5820010
+#define FSTV0910_P1_TSFIFO_LINENOK  0xf5820008
+#define FSTV0910_P1_TSFIFO_MUXSTREAM  0xf5820004
+#define FSTV0910_P1_SCRAMBDETECT  0xf5820002
+#define FSTV0910_P1_ULDTV67_FALSELOCK  0xf5820001
+
+/*P1_TSBITRATE1*/
+#define RSTV0910_P1_TSBITRATE1  0xf583
+#define FSTV0910_P1_TSFIFO_BITRATE1  0xf58300ff
+
+/*P1_TSBITRATE0*/
+#define RSTV0910_P1_TSBITRATE0  0xf584
+#define FSTV0910_P1_TSFIFO_BITRATE0  0xf58400ff
+
+/*P1_ERRCTRL1*/
+#define RSTV0910_P1_ERRCTRL1  0xf598
+#define FSTV0910_P1_ERR_SOURCE1  0xf59800f0
+#define FSTV0910_P1_NUM_EVENT1  0xf5980007
+
+/*P1_ERRCNT12*/
+#define RSTV0910_P1_ERRCNT12  0xf599
+#define FSTV0910_P1_ERRCNT1_OLDVALUE  0xf5990080
+#define FSTV0910_P1_ERR_CNT12  0xf599007f
+
+/*P1_ERRCNT11*/
+#define RSTV0910_P1_ERRCNT11  0xf59a
+#define FSTV0910_P1_ERR_CNT11  0xf59a00ff
+
+/*P1_ERRCNT10*/
+#define RSTV0910_P1_ERRCNT10  0xf59b
+#define FSTV0910_P1_ERR_CNT10  0xf59b00ff
+
+/*P1_ERRCTRL2*/
+#define RSTV0910_P1_ERRCTRL2  0xf59c
+#define FSTV0910_P1_ERR_SOURCE2  0xf59c00f0
+#define FSTV0910_P1_NUM_EVENT2  0xf59c0007
+
+/*P1_ERRCNT22*/
+#define RSTV0910_P1_ERRCNT22  0xf59d
+#define FSTV0910_P1_ERRCNT2_OLDVALUE  0xf59d0080
+#define FSTV0910_P1_ERR_CNT22  0xf59d007f
+
+/*P1_ERRCNT21*/
+#define RSTV0910_P1_ERRCNT21  0xf59e
+#define FSTV0910_P1_ERR_CNT21  0xf59e00ff
+
+/*P1_ERRCNT20*/
+#define RSTV0910_P1_ERRCNT20  0xf59f
+#define FSTV0910_P1_ERR_CNT20  0xf59f00ff
+
+/*P1_FECSPY*/
+#define RSTV0910_P1_FECSPY  0xf5a0
+#define FSTV0910_P1_SPY_ENABLE  0xf5a00080
+#define FSTV0910_P1_NO_SYNCBYTE  0xf5a00040
+#define FSTV0910_P1_SERIAL_MODE  0xf5a00020
+#define FSTV0910_P1_UNUSUAL_PACKET  0xf5a00010
+#define FSTV0910_P1_BERMETER_DATAMODE  0xf5a0000c
+#define FSTV0910_P1_BERMETER_LMODE  0xf5a00002
+#define FSTV0910_P1_BERMETER_RESET  0xf5a00001
+
+/*P1_FSPYCFG*/
+#define RSTV0910_P1_FSPYCFG  0xf5a1
+#define FSTV0910_P1_FECSPY_INPUT  0xf5a100c0
+#define FSTV0910_P1_RST_ON_ERROR  0xf5a10020
+#define FSTV0910_P1_ONE_SHOT  0xf5a10010
+#define FSTV0910_P1_I2C_MODE  0xf5a1000c
+#define FSTV0910_P1_SPY_HYSTERESIS  0xf5a10003
+
+/*P1_FSPYDATA*/
+#define RSTV0910_P1_FSPYDATA  0xf5a2
+#define FSTV0910_P1_SPY_STUFFING  0xf5a20080
+#define FSTV0910_P1_NOERROR_PKTJITTER  0xf5a20040
+#define FSTV0910_P1_SPY_CNULLPKT  0xf5a20020
+#define FSTV0910_P1_SPY_OUTDATA_MODE  0xf5a2001f
+
+/*P1_FSPYOUT*/
+#define RSTV0910_P1_FSPYOUT  0xf5a3
+#define FSTV0910_P1_FSPY_DIRECT  0xf5a30080
+#define FSTV0910_P1_SPY_OUTDATA_BUS  0xf5a30038
+#define FSTV0910_P1_STUFF_MODE  0xf5a30007
+
+/*P1_FSTATUS*/
+#define RSTV0910_P1_FSTATUS  0xf5a4
+#define FSTV0910_P1_SPY_ENDSIM  0xf5a40080
+#define FSTV0910_P1_VALID_SIM  0xf5a40040
+#define FSTV0910_P1_FOUND_SIGNAL  0xf5a40020
+#define FSTV0910_P1_DSS_SYNCBYTE  0xf5a40010
+#define FSTV0910_P1_RESULT_STATE  0xf5a4000f
+
+/*P1_FBERCPT4*/
+#define RSTV0910_P1_FBERCPT4  0xf5a8
+#define FSTV0910_P1_FBERMETER_CPT4  0xf5a800ff
+
+/*P1_FBERCPT3*/
+#define RSTV0910_P1_FBERCPT3  0xf5a9
+#define FSTV0910_P1_FBERMETER_CPT3  0xf5a900ff
+
+/*P1_FBERCPT2*/
+#define RSTV0910_P1_FBERCPT2  0xf5aa
+#define FSTV0910_P1_FBERMETER_CPT2  0xf5aa00ff
+
+/*P1_FBERCPT1*/
+#define RSTV0910_P1_FBERCPT1  0xf5ab
+#define FSTV0910_P1_FBERMETER_CPT1  0xf5ab00ff
+
+/*P1_FBERCPT0*/
+#define RSTV0910_P1_FBERCPT0  0xf5ac
+#define FSTV0910_P1_FBERMETER_CPT0  0xf5ac00ff
+
+/*P1_FBERERR2*/
+#define RSTV0910_P1_FBERERR2  0xf5ad
+#define FSTV0910_P1_FBERMETER_ERR2  0xf5ad00ff
+
+/*P1_FBERERR1*/
+#define RSTV0910_P1_FBERERR1  0xf5ae
+#define FSTV0910_P1_FBERMETER_ERR1  0xf5ae00ff
+
+/*P1_FBERERR0*/
+#define RSTV0910_P1_FBERERR0  0xf5af
+#define FSTV0910_P1_FBERMETER_ERR0  0xf5af00ff
+
+/*P1_FSPYBER*/
+#define RSTV0910_P1_FSPYBER  0xf5b2
+#define FSTV0910_P1_FSPYOBS_XORREAD  0xf5b20040
+#define FSTV0910_P1_FSPYBER_OBSMODE  0xf5b20020
+#define FSTV0910_P1_FSPYBER_SYNCBYTE  0xf5b20010
+#define FSTV0910_P1_FSPYBER_UNSYNC  0xf5b20008
+#define FSTV0910_P1_FSPYBER_CTIME  0xf5b20007
+
+/*P1_SFERROR*/
+#define RSTV0910_P1_SFERROR  0xf5c1
+#define FSTV0910_P1_SFEC_REGERR_VIT  0xf5c100ff
+
+/*P1_SFECSTATUS*/
+#define RSTV0910_P1_SFECSTATUS  0xf5c3
+#define FSTV0910_P1_SFEC_ON  0xf5c30080
+#define FSTV0910_P1_SFEC_OFF  0xf5c30040
+#define FSTV0910_P1_LOCKEDSFEC  0xf5c30008
+#define FSTV0910_P1_SFEC_DELOCK  0xf5c30004
+#define FSTV0910_P1_SFEC_DEMODSEL  0xf5c30002
+#define FSTV0910_P1_SFEC_OVFON  0xf5c30001
+
+/*P1_SFKDIV12*/
+#define RSTV0910_P1_SFKDIV12  0xf5c4
+#define FSTV0910_P1_SFECKDIV12_MAN  0xf5c40080
+#define FSTV0910_P1_SFEC_K_DIVIDER_12  0xf5c4007f
+
+/*P1_SFKDIV23*/
+#define RSTV0910_P1_SFKDIV23  0xf5c5
+#define FSTV0910_P1_SFECKDIV23_MAN  0xf5c50080
+#define FSTV0910_P1_SFEC_K_DIVIDER_23  0xf5c5007f
+
+/*P1_SFKDIV34*/
+#define RSTV0910_P1_SFKDIV34  0xf5c6
+#define FSTV0910_P1_SFECKDIV34_MAN  0xf5c60080
+#define FSTV0910_P1_SFEC_K_DIVIDER_34  0xf5c6007f
+
+/*P1_SFKDIV56*/
+#define RSTV0910_P1_SFKDIV56  0xf5c7
+#define FSTV0910_P1_SFECKDIV56_MAN  0xf5c70080
+#define FSTV0910_P1_SFEC_K_DIVIDER_56  0xf5c7007f
+
+/*P1_SFKDIV67*/
+#define RSTV0910_P1_SFKDIV67  0xf5c8
+#define FSTV0910_P1_SFECKDIV67_MAN  0xf5c80080
+#define FSTV0910_P1_SFEC_K_DIVIDER_67  0xf5c8007f
+
+/*P1_SFKDIV78*/
+#define RSTV0910_P1_SFKDIV78  0xf5c9
+#define FSTV0910_P1_SFECKDIV78_MAN  0xf5c90080
+#define FSTV0910_P1_SFEC_K_DIVIDER_78  0xf5c9007f
+
+/*P1_SFSTATUS*/
+#define RSTV0910_P1_SFSTATUS  0xf5cc
+#define FSTV0910_P1_SFEC_LINEOK  0xf5cc0080
+#define FSTV0910_P1_SFEC_ERROR  0xf5cc0040
+#define FSTV0910_P1_SFEC_DATA7  0xf5cc0020
+#define FSTV0910_P1_SFEC_PKTDNBRFAIL  0xf5cc0010
+#define FSTV0910_P1_TSSFEC_DEMODSEL  0xf5cc0008
+#define FSTV0910_P1_SFEC_NOSYNC  0xf5cc0004
+#define FSTV0910_P1_SFEC_UNREGULA  0xf5cc0002
+#define FSTV0910_P1_SFEC_READY  0xf5cc0001
+
+/*P1_SFDLYSET2*/
+#define RSTV0910_P1_SFDLYSET2  0xf5d0
+#define FSTV0910_P1_SFEC_OFFSET  0xf5d000c0
+#define FSTV0910_P1_RST_SFEC  0xf5d00008
+#define FSTV0910_P1_DILDLINE_ERROR  0xf5d00004
+#define FSTV0910_P1_SFEC_DISABLE  0xf5d00002
+#define FSTV0910_P1_SFEC_UNREGUL  0xf5d00001
+
+/*P1_SFERRCTRL*/
+#define RSTV0910_P1_SFERRCTRL  0xf5d8
+#define FSTV0910_P1_SFEC_ERR_SOURCE  0xf5d800f0
+#define FSTV0910_P1_SFEC_NUM_EVENT  0xf5d80007
+
+/*P1_SFERRCNT2*/
+#define RSTV0910_P1_SFERRCNT2  0xf5d9
+#define FSTV0910_P1_SFERRC_OLDVALUE  0xf5d90080
+#define FSTV0910_P1_SFEC_ERR_CNT2  0xf5d9007f
+
+/*P1_SFERRCNT1*/
+#define RSTV0910_P1_SFERRCNT1  0xf5da
+#define FSTV0910_P1_SFEC_ERR_CNT1  0xf5da00ff
+
+/*P1_SFERRCNT0*/
+#define RSTV0910_P1_SFERRCNT0  0xf5db
+#define FSTV0910_P1_SFEC_ERR_CNT0  0xf5db00ff
+
+/*TSGENERAL*/
+#define RSTV0910_TSGENERAL  0xf630
+#define FSTV0910_EN_LGNERROR  0xf6300080
+#define FSTV0910_TSFIFO_DISTS2PAR  0xf6300040
+#define FSTV0910_MUXSTREAM_COMPMOSE  0xf6300030
+#define FSTV0910_MUXSTREAM_OUTMODE  0xf6300008
+#define FSTV0910_TSFIFO_PERMPARAL  0xf6300006
+#define FSTV0910_RST_REEDSOLO  0xf6300001
+
+/*P1_DISIRQCFG*/
+#define RSTV0910_P1_DISIRQCFG  0xf700
+#define FSTV0910_P1_ENRXEND  0xf7000040
+#define FSTV0910_P1_ENRXFIFO8B  0xf7000020
+#define FSTV0910_P1_ENTRFINISH  0xf7000010
+#define FSTV0910_P1_ENTIMEOUT  0xf7000008
+#define FSTV0910_P1_ENTXEND  0xf7000004
+#define FSTV0910_P1_ENTXFIFO64B  0xf7000002
+#define FSTV0910_P1_ENGAPBURST  0xf7000001
+
+/*P1_DISIRQSTAT*/
+#define RSTV0910_P1_DISIRQSTAT  0xf701
+#define FSTV0910_P1_IRQRXEND  0xf7010040
+#define FSTV0910_P1_IRQRXFIFO8B  0xf7010020
+#define FSTV0910_P1_IRQTRFINISH  0xf7010010
+#define FSTV0910_P1_IRQTIMEOUT  0xf7010008
+#define FSTV0910_P1_IRQTXEND  0xf7010004
+#define FSTV0910_P1_IRQTXFIFO64B  0xf7010002
+#define FSTV0910_P1_IRQGAPBURST  0xf7010001
+
+/*P1_DISTXCFG*/
+#define RSTV0910_P1_DISTXCFG  0xf702
+#define FSTV0910_P1_DISTX_RESET  0xf7020080
+#define FSTV0910_P1_TIM_OFF  0xf7020040
+#define FSTV0910_P1_TIM_CMD  0xf7020030
+#define FSTV0910_P1_ENVELOP  0xf7020008
+#define FSTV0910_P1_DIS_PRECHARGE  0xf7020004
+#define FSTV0910_P1_DISEQC_MODE  0xf7020003
+
+/*P1_DISTXSTATUS*/
+#define RSTV0910_P1_DISTXSTATUS  0xf703
+#define FSTV0910_P1_TX_FIFO_FULL  0xf7030040
+#define FSTV0910_P1_TX_IDLE  0xf7030020
+#define FSTV0910_P1_GAP_BURST  0xf7030010
+#define FSTV0910_P1_TX_FIFO64B  0xf7030008
+#define FSTV0910_P1_TX_END  0xf7030004
+#define FSTV0910_P1_TR_TIMEOUT  0xf7030002
+#define FSTV0910_P1_TR_FINISH  0xf7030001
+
+/*P1_DISTXBYTES*/
+#define RSTV0910_P1_DISTXBYTES  0xf704
+#define FSTV0910_P1_TXFIFO_BYTES  0xf70400ff
+
+/*P1_DISTXFIFO*/
+#define RSTV0910_P1_DISTXFIFO  0xf705
+#define FSTV0910_P1_DISEQC_TX_FIFO  0xf70500ff
+
+/*P1_DISTXF22*/
+#define RSTV0910_P1_DISTXF22  0xf706
+#define FSTV0910_P1_F22TX  0xf70600ff
+
+/*P1_DISTIMEOCFG*/
+#define RSTV0910_P1_DISTIMEOCFG  0xf708
+#define FSTV0910_P1_RXCHOICE  0xf7080006
+#define FSTV0910_P1_TIMEOUT_OFF  0xf7080001
+
+/*P1_DISTIMEOUT*/
+#define RSTV0910_P1_DISTIMEOUT  0xf709
+#define FSTV0910_P1_TIMEOUT_COUNT  0xf70900ff
+
+/*P1_DISRXCFG*/
+#define RSTV0910_P1_DISRXCFG  0xf70a
+#define FSTV0910_P1_DISRX_RESET  0xf70a0080
+#define FSTV0910_P1_EXTENVELOP  0xf70a0040
+#define FSTV0910_P1_PINSELECT  0xf70a0038
+#define FSTV0910_P1_IGNORE_SHORT22K  0xf70a0004
+#define FSTV0910_P1_SIGNED_RXIN  0xf70a0002
+#define FSTV0910_P1_DISRX_ON  0xf70a0001
+
+/*P1_DISRXSTAT1*/
+#define RSTV0910_P1_DISRXSTAT1  0xf70b
+#define FSTV0910_P1_RXEND  0xf70b0080
+#define FSTV0910_P1_RXACTIVE  0xf70b0040
+#define FSTV0910_P1_RXDETECT  0xf70b0020
+#define FSTV0910_P1_CONTTONE  0xf70b0010
+#define FSTV0910_P1_8BFIFOREADY  0xf70b0008
+#define FSTV0910_P1_FIFOEMPTY  0xf70b0004
+
+/*P1_DISRXSTAT0*/
+#define RSTV0910_P1_DISRXSTAT0  0xf70c
+#define FSTV0910_P1_RXFAIL  0xf70c0080
+#define FSTV0910_P1_FIFOPFAIL  0xf70c0040
+#define FSTV0910_P1_RXNONBYTE  0xf70c0020
+#define FSTV0910_P1_FIFOOVF  0xf70c0010
+#define FSTV0910_P1_SHORT22K  0xf70c0008
+#define FSTV0910_P1_RXMSGLOST  0xf70c0004
+
+/*P1_DISRXBYTES*/
+#define RSTV0910_P1_DISRXBYTES  0xf70d
+#define FSTV0910_P1_RXFIFO_BYTES  0xf70d001f
+
+/*P1_DISRXPARITY1*/
+#define RSTV0910_P1_DISRXPARITY1  0xf70e
+#define FSTV0910_P1_DISRX_PARITY1  0xf70e00ff
+
+/*P1_DISRXPARITY0*/
+#define RSTV0910_P1_DISRXPARITY0  0xf70f
+#define FSTV0910_P1_DISRX_PARITY0  0xf70f00ff
+
+/*P1_DISRXFIFO*/
+#define RSTV0910_P1_DISRXFIFO  0xf710
+#define FSTV0910_P1_DISEQC_RX_FIFO  0xf71000ff
+
+/*P1_DISRXDC1*/
+#define RSTV0910_P1_DISRXDC1  0xf711
+#define FSTV0910_P1_DC_VALUE1  0xf7110103
+
+/*P1_DISRXDC0*/
+#define RSTV0910_P1_DISRXDC0  0xf712
+#define FSTV0910_P1_DC_VALUE0  0xf71200ff
+
+/*P1_DISRXF221*/
+#define RSTV0910_P1_DISRXF221  0xf714
+#define FSTV0910_P1_F22RX1  0xf714000f
+
+/*P1_DISRXF220*/
+#define RSTV0910_P1_DISRXF220  0xf715
+#define FSTV0910_P1_F22RX0  0xf71500ff
+
+/*P1_DISRXF100*/
+#define RSTV0910_P1_DISRXF100  0xf716
+#define FSTV0910_P1_F100RX  0xf71600ff
+
+/*P1_DISRXSHORT22K*/
+#define RSTV0910_P1_DISRXSHORT22K  0xf71c
+#define FSTV0910_P1_SHORT22K_LENGTH  0xf71c001f
+
+/*P1_ACRPRESC*/
+#define RSTV0910_P1_ACRPRESC  0xf71e
+#define FSTV0910_P1_ACR_CODFRDY  0xf71e0008
+#define FSTV0910_P1_ACR_PRESC  0xf71e0007
+
+/*P1_ACRDIV*/
+#define RSTV0910_P1_ACRDIV  0xf71f
+#define FSTV0910_P1_ACR_DIV  0xf71f00ff
+
+/*P2_DISIRQCFG*/
+#define RSTV0910_P2_DISIRQCFG  0xf740
+#define FSTV0910_P2_ENRXEND  0xf7400040
+#define FSTV0910_P2_ENRXFIFO8B  0xf7400020
+#define FSTV0910_P2_ENTRFINISH  0xf7400010
+#define FSTV0910_P2_ENTIMEOUT  0xf7400008
+#define FSTV0910_P2_ENTXEND  0xf7400004
+#define FSTV0910_P2_ENTXFIFO64B  0xf7400002
+#define FSTV0910_P2_ENGAPBURST  0xf7400001
+
+/*P2_DISIRQSTAT*/
+#define RSTV0910_P2_DISIRQSTAT  0xf741
+#define FSTV0910_P2_IRQRXEND  0xf7410040
+#define FSTV0910_P2_IRQRXFIFO8B  0xf7410020
+#define FSTV0910_P2_IRQTRFINISH  0xf7410010
+#define FSTV0910_P2_IRQTIMEOUT  0xf7410008
+#define FSTV0910_P2_IRQTXEND  0xf7410004
+#define FSTV0910_P2_IRQTXFIFO64B  0xf7410002
+#define FSTV0910_P2_IRQGAPBURST  0xf7410001
+
+/*P2_DISTXCFG*/
+#define RSTV0910_P2_DISTXCFG  0xf742
+#define FSTV0910_P2_DISTX_RESET  0xf7420080
+#define FSTV0910_P2_TIM_OFF  0xf7420040
+#define FSTV0910_P2_TIM_CMD  0xf7420030
+#define FSTV0910_P2_ENVELOP  0xf7420008
+#define FSTV0910_P2_DIS_PRECHARGE  0xf7420004
+#define FSTV0910_P2_DISEQC_MODE  0xf7420003
+
+/*P2_DISTXSTATUS*/
+#define RSTV0910_P2_DISTXSTATUS  0xf743
+#define FSTV0910_P2_TX_FIFO_FULL  0xf7430040
+#define FSTV0910_P2_TX_IDLE  0xf7430020
+#define FSTV0910_P2_GAP_BURST  0xf7430010
+#define FSTV0910_P2_TX_FIFO64B  0xf7430008
+#define FSTV0910_P2_TX_END  0xf7430004
+#define FSTV0910_P2_TR_TIMEOUT  0xf7430002
+#define FSTV0910_P2_TR_FINISH  0xf7430001
+
+/*P2_DISTXBYTES*/
+#define RSTV0910_P2_DISTXBYTES  0xf744
+#define FSTV0910_P2_TXFIFO_BYTES  0xf74400ff
+
+/*P2_DISTXFIFO*/
+#define RSTV0910_P2_DISTXFIFO  0xf745
+#define FSTV0910_P2_DISEQC_TX_FIFO  0xf74500ff
+
+/*P2_DISTXF22*/
+#define RSTV0910_P2_DISTXF22  0xf746
+#define FSTV0910_P2_F22TX  0xf74600ff
+
+/*P2_DISTIMEOCFG*/
+#define RSTV0910_P2_DISTIMEOCFG  0xf748
+#define FSTV0910_P2_RXCHOICE  0xf7480006
+#define FSTV0910_P2_TIMEOUT_OFF  0xf7480001
+
+/*P2_DISTIMEOUT*/
+#define RSTV0910_P2_DISTIMEOUT  0xf749
+#define FSTV0910_P2_TIMEOUT_COUNT  0xf74900ff
+
+/*P2_DISRXCFG*/
+#define RSTV0910_P2_DISRXCFG  0xf74a
+#define FSTV0910_P2_DISRX_RESET  0xf74a0080
+#define FSTV0910_P2_EXTENVELOP  0xf74a0040
+#define FSTV0910_P2_PINSELECT  0xf74a0038
+#define FSTV0910_P2_IGNORE_SHORT22K  0xf74a0004
+#define FSTV0910_P2_SIGNED_RXIN  0xf74a0002
+#define FSTV0910_P2_DISRX_ON  0xf74a0001
+
+/*P2_DISRXSTAT1*/
+#define RSTV0910_P2_DISRXSTAT1  0xf74b
+#define FSTV0910_P2_RXEND  0xf74b0080
+#define FSTV0910_P2_RXACTIVE  0xf74b0040
+#define FSTV0910_P2_RXDETECT  0xf74b0020
+#define FSTV0910_P2_CONTTONE  0xf74b0010
+#define FSTV0910_P2_8BFIFOREADY  0xf74b0008
+#define FSTV0910_P2_FIFOEMPTY  0xf74b0004
+
+/*P2_DISRXSTAT0*/
+#define RSTV0910_P2_DISRXSTAT0  0xf74c
+#define FSTV0910_P2_RXFAIL  0xf74c0080
+#define FSTV0910_P2_FIFOPFAIL  0xf74c0040
+#define FSTV0910_P2_RXNONBYTE  0xf74c0020
+#define FSTV0910_P2_FIFOOVF  0xf74c0010
+#define FSTV0910_P2_SHORT22K  0xf74c0008
+#define FSTV0910_P2_RXMSGLOST  0xf74c0004
+
+/*P2_DISRXBYTES*/
+#define RSTV0910_P2_DISRXBYTES  0xf74d
+#define FSTV0910_P2_RXFIFO_BYTES  0xf74d001f
+
+/*P2_DISRXPARITY1*/
+#define RSTV0910_P2_DISRXPARITY1  0xf74e
+#define FSTV0910_P2_DISRX_PARITY1  0xf74e00ff
+
+/*P2_DISRXPARITY0*/
+#define RSTV0910_P2_DISRXPARITY0  0xf74f
+#define FSTV0910_P2_DISRX_PARITY0  0xf74f00ff
+
+/*P2_DISRXFIFO*/
+#define RSTV0910_P2_DISRXFIFO  0xf750
+#define FSTV0910_P2_DISEQC_RX_FIFO  0xf75000ff
+
+/*P2_DISRXDC1*/
+#define RSTV0910_P2_DISRXDC1  0xf751
+#define FSTV0910_P2_DC_VALUE1  0xf7510103
+
+/*P2_DISRXDC0*/
+#define RSTV0910_P2_DISRXDC0  0xf752
+#define FSTV0910_P2_DC_VALUE0  0xf75200ff
+
+/*P2_DISRXF221*/
+#define RSTV0910_P2_DISRXF221  0xf754
+#define FSTV0910_P2_F22RX1  0xf754000f
+
+/*P2_DISRXF220*/
+#define RSTV0910_P2_DISRXF220  0xf755
+#define FSTV0910_P2_F22RX0  0xf75500ff
+
+/*P2_DISRXF100*/
+#define RSTV0910_P2_DISRXF100  0xf756
+#define FSTV0910_P2_F100RX  0xf75600ff
+
+/*P2_DISRXSHORT22K*/
+#define RSTV0910_P2_DISRXSHORT22K  0xf75c
+#define FSTV0910_P2_SHORT22K_LENGTH  0xf75c001f
+
+/*P2_ACRPRESC*/
+#define RSTV0910_P2_ACRPRESC  0xf75e
+#define FSTV0910_P2_ACR_CODFRDY  0xf75e0008
+#define FSTV0910_P2_ACR_PRESC  0xf75e0007
+
+/*P2_ACRDIV*/
+#define RSTV0910_P2_ACRDIV  0xf75f
+#define FSTV0910_P2_ACR_DIV  0xf75f00ff
+
+/*P1_NBITER_NF4*/
+#define RSTV0910_P1_NBITER_NF4  0xfa03
+#define FSTV0910_P1_NBITER_NF_QPSK_1_2  0xfa0300ff
+
+/*P1_NBITER_NF5*/
+#define RSTV0910_P1_NBITER_NF5  0xfa04
+#define FSTV0910_P1_NBITER_NF_QPSK_3_5  0xfa0400ff
+
+/*P1_NBITER_NF6*/
+#define RSTV0910_P1_NBITER_NF6  0xfa05
+#define FSTV0910_P1_NBITER_NF_QPSK_2_3  0xfa0500ff
+
+/*P1_NBITER_NF7*/
+#define RSTV0910_P1_NBITER_NF7  0xfa06
+#define FSTV0910_P1_NBITER_NF_QPSK_3_4  0xfa0600ff
+
+/*P1_NBITER_NF8*/
+#define RSTV0910_P1_NBITER_NF8  0xfa07
+#define FSTV0910_P1_NBITER_NF_QPSK_4_5  0xfa0700ff
+
+/*P1_NBITER_NF9*/
+#define RSTV0910_P1_NBITER_NF9  0xfa08
+#define FSTV0910_P1_NBITER_NF_QPSK_5_6  0xfa0800ff
+
+/*P1_NBITER_NF10*/
+#define RSTV0910_P1_NBITER_NF10  0xfa09
+#define FSTV0910_P1_NBITER_NF_QPSK_8_9  0xfa0900ff
+
+/*P1_NBITER_NF11*/
+#define RSTV0910_P1_NBITER_NF11  0xfa0a
+#define FSTV0910_P1_NBITER_NF_QPSK_9_10  0xfa0a00ff
+
+/*P1_NBITER_NF12*/
+#define RSTV0910_P1_NBITER_NF12  0xfa0b
+#define FSTV0910_P1_NBITER_NF_8PSK_3_5  0xfa0b00ff
+
+/*P1_NBITER_NF13*/
+#define RSTV0910_P1_NBITER_NF13  0xfa0c
+#define FSTV0910_P1_NBITER_NF_8PSK_2_3  0xfa0c00ff
+
+/*P1_NBITER_NF14*/
+#define RSTV0910_P1_NBITER_NF14  0xfa0d
+#define FSTV0910_P1_NBITER_NF_8PSK_3_4  0xfa0d00ff
+
+/*P1_NBITER_NF15*/
+#define RSTV0910_P1_NBITER_NF15  0xfa0e
+#define FSTV0910_P1_NBITER_NF_8PSK_5_6  0xfa0e00ff
+
+/*P1_NBITER_NF16*/
+#define RSTV0910_P1_NBITER_NF16  0xfa0f
+#define FSTV0910_P1_NBITER_NF_8PSK_8_9  0xfa0f00ff
+
+/*P1_NBITER_NF17*/
+#define RSTV0910_P1_NBITER_NF17  0xfa10
+#define FSTV0910_P1_NBITER_NF_8PSK_9_10  0xfa1000ff
+
+/*GAINLLR_NF4*/
+#define RSTV0910_GAINLLR_NF4  0xfa43
+#define FSTV0910_GAINLLR_NF_QPSK_1_2  0xfa43007f
+
+/*GAINLLR_NF5*/
+#define RSTV0910_GAINLLR_NF5  0xfa44
+#define FSTV0910_GAINLLR_NF_QPSK_3_5  0xfa44007f
+
+/*GAINLLR_NF6*/
+#define RSTV0910_GAINLLR_NF6  0xfa45
+#define FSTV0910_GAINLLR_NF_QPSK_2_3  0xfa45007f
+
+/*GAINLLR_NF7*/
+#define RSTV0910_GAINLLR_NF7  0xfa46
+#define FSTV0910_GAINLLR_NF_QPSK_3_4  0xfa46007f
+
+/*GAINLLR_NF8*/
+#define RSTV0910_GAINLLR_NF8  0xfa47
+#define FSTV0910_GAINLLR_NF_QPSK_4_5  0xfa47007f
+
+/*GAINLLR_NF9*/
+#define RSTV0910_GAINLLR_NF9  0xfa48
+#define FSTV0910_GAINLLR_NF_QPSK_5_6  0xfa48007f
+
+/*GAINLLR_NF10*/
+#define RSTV0910_GAINLLR_NF10  0xfa49
+#define FSTV0910_GAINLLR_NF_QPSK_8_9  0xfa49007f
+
+/*GAINLLR_NF11*/
+#define RSTV0910_GAINLLR_NF11  0xfa4a
+#define FSTV0910_GAINLLR_NF_QPSK_9_10  0xfa4a007f
+
+/*GAINLLR_NF12*/
+#define RSTV0910_GAINLLR_NF12  0xfa4b
+#define FSTV0910_GAINLLR_NF_8PSK_3_5  0xfa4b007f
+
+/*GAINLLR_NF13*/
+#define RSTV0910_GAINLLR_NF13  0xfa4c
+#define FSTV0910_GAINLLR_NF_8PSK_2_3  0xfa4c007f
+
+/*GAINLLR_NF14*/
+#define RSTV0910_GAINLLR_NF14  0xfa4d
+#define FSTV0910_GAINLLR_NF_8PSK_3_4  0xfa4d007f
+
+/*GAINLLR_NF15*/
+#define RSTV0910_GAINLLR_NF15  0xfa4e
+#define FSTV0910_GAINLLR_NF_8PSK_5_6  0xfa4e007f
+
+/*GAINLLR_NF16*/
+#define RSTV0910_GAINLLR_NF16  0xfa4f
+#define FSTV0910_GAINLLR_NF_8PSK_8_9  0xfa4f007f
+
+/*GAINLLR_NF17*/
+#define RSTV0910_GAINLLR_NF17  0xfa50
+#define FSTV0910_GAINLLR_NF_8PSK_9_10  0xfa50007f
+
+/*CFGEXT*/
+#define RSTV0910_CFGEXT  0xfa80
+#define FSTV0910_BYPFIFOBCH  0xfa800080
+#define FSTV0910_BYPBCH  0xfa800040
+#define FSTV0910_BYPLDPC  0xfa800020
+#define FSTV0910_BYPFIFOBCHF  0xfa800010
+#define FSTV0910_INVLLRSIGN  0xfa800008
+#define FSTV0910_SHORTMULT  0xfa800004
+#define FSTV0910_ENSTOPDEC  0xfa800002
+
+/*GENCFG*/
+#define RSTV0910_GENCFG  0xfa86
+#define FSTV0910_LEG_ITER  0xfa860040
+#define FSTV0910_NOSHFRD1  0xfa860020
+#define FSTV0910_BROADCAST  0xfa860010
+#define FSTV0910_NOSHFRD2  0xfa860008
+#define FSTV0910_BCHERRFLAG  0xfa860004
+#define FSTV0910_CROSSINPUT  0xfa860002
+#define FSTV0910_DDEMOD  0xfa860001
+
+/*LDPCERR1*/
+#define RSTV0910_LDPCERR1  0xfa96
+#define FSTV0910_LDPC_ERRORS1  0xfa9600ff
+
+/*LDPCERR0*/
+#define RSTV0910_LDPCERR0  0xfa97
+#define FSTV0910_LDPC_ERRORS0  0xfa9700ff
+
+/*BCHERR*/
+#define RSTV0910_BCHERR  0xfa98
+#define FSTV0910_ERRORFLAG  0xfa980010
+#define FSTV0910_BCH_ERRORS_COUNTER  0xfa98000f
+
+/*P1_MAXEXTRAITER*/
+#define RSTV0910_P1_MAXEXTRAITER  0xfab1
+#define FSTV0910_P1_MAX_EXTRA_ITER  0xfab100ff
+
+/*P2_MAXEXTRAITER*/
+#define RSTV0910_P2_MAXEXTRAITER  0xfab6
+#define FSTV0910_P2_MAX_EXTRA_ITER  0xfab600ff
+
+/*P1_STATUSITER*/
+#define RSTV0910_P1_STATUSITER  0xfabc
+#define FSTV0910_P1_STATUS_ITER  0xfabc00ff
+
+/*P1_STATUSMAXITER*/
+#define RSTV0910_P1_STATUSMAXITER  0xfabd
+#define FSTV0910_P1_STATUS_MAX_ITER  0xfabd00ff
+
+/*P2_STATUSITER*/
+#define RSTV0910_P2_STATUSITER  0xfabe
+#define FSTV0910_P2_STATUS_ITER  0xfabe00ff
+
+/*P2_STATUSMAXITER*/
+#define RSTV0910_P2_STATUSMAXITER  0xfabf
+#define FSTV0910_P2_STATUS_MAX_ITER  0xfabf00ff
+
+/*P2_NBITER_NF4*/
+#define RSTV0910_P2_NBITER_NF4  0xfac3
+#define FSTV0910_P2_NBITER_NF_QPSK_1_2  0xfac300ff
+
+/*P2_NBITER_NF5*/
+#define RSTV0910_P2_NBITER_NF5  0xfac4
+#define FSTV0910_P2_NBITER_NF_QPSK_3_5  0xfac400ff
+
+/*P2_NBITER_NF6*/
+#define RSTV0910_P2_NBITER_NF6  0xfac5
+#define FSTV0910_P2_NBITER_NF_QPSK_2_3  0xfac500ff
+
+/*P2_NBITER_NF7*/
+#define RSTV0910_P2_NBITER_NF7  0xfac6
+#define FSTV0910_P2_NBITER_NF_QPSK_3_4  0xfac600ff
+
+/*P2_NBITER_NF8*/
+#define RSTV0910_P2_NBITER_NF8  0xfac7
+#define FSTV0910_P2_NBITER_NF_QPSK_4_5  0xfac700ff
+
+/*P2_NBITER_NF9*/
+#define RSTV0910_P2_NBITER_NF9  0xfac8
+#define FSTV0910_P2_NBITER_NF_QPSK_5_6  0xfac800ff
+
+/*P2_NBITER_NF10*/
+#define RSTV0910_P2_NBITER_NF10  0xfac9
+#define FSTV0910_P2_NBITER_NF_QPSK_8_9  0xfac900ff
+
+/*P2_NBITER_NF11*/
+#define RSTV0910_P2_NBITER_NF11  0xfaca
+#define FSTV0910_P2_NBITER_NF_QPSK_9_10  0xfaca00ff
+
+/*P2_NBITER_NF12*/
+#define RSTV0910_P2_NBITER_NF12  0xfacb
+#define FSTV0910_P2_NBITER_NF_8PSK_3_5  0xfacb00ff
+
+/*P2_NBITER_NF13*/
+#define RSTV0910_P2_NBITER_NF13  0xfacc
+#define FSTV0910_P2_NBITER_NF_8PSK_2_3  0xfacc00ff
+
+/*P2_NBITER_NF14*/
+#define RSTV0910_P2_NBITER_NF14  0xfacd
+#define FSTV0910_P2_NBITER_NF_8PSK_3_4  0xfacd00ff
+
+/*P2_NBITER_NF15*/
+#define RSTV0910_P2_NBITER_NF15  0xface
+#define FSTV0910_P2_NBITER_NF_8PSK_5_6  0xface00ff
+
+/*P2_NBITER_NF16*/
+#define RSTV0910_P2_NBITER_NF16  0xfacf
+#define FSTV0910_P2_NBITER_NF_8PSK_8_9  0xfacf00ff
+
+/*P2_NBITER_NF17*/
+#define RSTV0910_P2_NBITER_NF17  0xfad0
+#define FSTV0910_P2_NBITER_NF_8PSK_9_10  0xfad000ff
+
+/*TSTRES0*/
+#define RSTV0910_TSTRES0  0xff11
+#define FSTV0910_FRESFEC  0xff110080
+#define FSTV0910_FRESTS  0xff110040
+#define FSTV0910_FRESVIT1  0xff110020
+#define FSTV0910_FRESVIT2  0xff110010
+#define FSTV0910_FRESSYM1  0xff110008
+#define FSTV0910_FRESSYM2  0xff110004
+#define FSTV0910_FRESMAS  0xff110002
+#define FSTV0910_FRESINT  0xff110001
+
+/*P2_TCTL4*/
+#define RSTV0910_P2_TCTL4  0xff28
+#define FSTV0910_P2_CFR2TOCFR1_DVBS1  0xff2800c0
+#define FSTV0910_P2_TSTINV_PHERR  0xff280020
+#define FSTV0910_P2_EN_PLHCALC  0xff280010
+#define FSTV0910_P2_TETA3L_RSTTETA3D  0xff280008
+#define FSTV0910_P2_DIS_FORCEBETA2  0xff280004
+#define FSTV0910_P2_CAR3_NOTRACEBACK  0xff280002
+#define FSTV0910_P2_CAR3_NOFORWARD  0xff280001
+
+/*P1_TCTL4*/
+#define RSTV0910_P1_TCTL4  0xff48
+#define FSTV0910_P1_CFR2TOCFR1_DVBS1  0xff4800c0
+#define FSTV0910_P1_TSTINV_PHERR  0xff480020
+#define FSTV0910_P1_EN_PLHCALC  0xff480010
+#define FSTV0910_P1_TETA3L_RSTTETA3D  0xff480008
+#define FSTV0910_P1_DIS_FORCEBETA2  0xff480004
+#define FSTV0910_P1_CAR3_NOTRACEBACK  0xff480002
+#define FSTV0910_P1_CAR3_NOFORWARD  0xff480001
+
+#define STV0910_NBREGS		735
+#define STV0910_NBFIELDS		1776
diff --git a/drivers/media/dvb-frontends/stv6111.c b/drivers/media/dvb-frontends/stv6111.c
new file mode 100644
index 0000000..827fe48
--- /dev/null
+++ b/drivers/media/dvb-frontends/stv6111.c
@@ -0,0 +1,684 @@
+/*
+ * Driver for the ST STV6111 tuner
+ *
+ * Copyright (C) 2014 Digital Devices GmbH
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 only, as published by the Free Software Foundation.
+ *
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA
+ * Or, point your browser to http://www.gnu.org/copyleft/gpl.html
+ */
+
+#undef pr_fmt
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/firmware.h>
+#include <linux/i2c.h>
+#include <asm/div64.h>
+
+#include "dvb_frontend.h"
+
+struct stv {
+	struct i2c_adapter *i2c;
+	u8 adr;
+
+	u8 reg[11];
+	u32 ref_freq;
+	u32 Frequency;
+};
+
+struct SLookup {
+	s16 Value;
+	u16 RegValue;
+};
+
+static struct SLookup LNAGain_NF_LookUp[] = {
+	/*Gain *100dB*/      /*Reg*/
+	{ 2572,	0 },
+	{ 2575, 1 },
+	{ 2580, 2 },
+	{ 2588, 3 },
+	{ 2596, 4 },
+	{ 2611, 5 },
+	{ 2633, 6 },
+	{ 2664, 7 },
+	{ 2701, 8 },
+	{ 2753, 9 },
+	{ 2816, 10 },
+	{ 2902, 11 },
+	{ 2995, 12 },
+	{ 3104, 13 },
+	{ 3215, 14 },
+	{ 3337, 15 },
+	{ 3492, 16 },
+	{ 3614, 17 },
+	{ 3731, 18 },
+	{ 3861, 19 },
+	{ 3988, 20 },
+	{ 4124, 21 },
+	{ 4253, 22 },
+	{ 4386,	23 },
+	{ 4505,	24 },
+	{ 4623,	25 },
+	{ 4726,	26 },
+	{ 4821,	27 },
+	{ 4903,	28 },
+	{ 4979,	29 },
+	{ 5045,	30 },
+	{ 5102,	31 }
+};
+
+static struct SLookup LNAGain_IIP3_LookUp[] = {
+	/*Gain *100dB*/   /*reg*/
+	{ 1548,	0 },
+	{ 1552,	1 },
+	{ 1569,	2 },
+	{ 1565,	3 },
+	{ 1577,	4 },
+	{ 1594,	5 },
+	{ 1627,	6 },
+	{ 1656,	7 },
+	{ 1700,	8 },
+	{ 1748,	9 },
+	{ 1805,	10 },
+	{ 1896,	11 },
+	{ 1995,	12 },
+	{ 2113,	13 },
+	{ 2233,	14 },
+	{ 2366,	15 },
+	{ 2543,	16 },
+	{ 2687,	17 },
+	{ 2842,	18 },
+	{ 2999,	19 },
+	{ 3167,	20 },
+	{ 3342,	21 },
+	{ 3507,	22 },
+	{ 3679,	23 },
+	{ 3827,	24 },
+	{ 3970,	25 },
+	{ 4094,	26 },
+	{ 4210,	27 },
+	{ 4308,	28 },
+	{ 4396,	29 },
+	{ 4468,	30 },
+	{ 4535,	31 }
+};
+
+static struct SLookup Gain_RFAGC_LookUp[] = {
+	/*Gain *100dB*/   /*reg*/
+	{ 4870,	0x3000 },
+	{ 4850,	0x3C00 },
+	{ 4800,	0x4500 },
+	{ 4750,	0x4800 },
+	{ 4700,	0x4B00 },
+	{ 4650,	0x4D00 },
+	{ 4600,	0x4F00 },
+	{ 4550,	0x5100 },
+	{ 4500,	0x5200 },
+	{ 4420,	0x5500 },
+	{ 4316,	0x5800 },
+	{ 4200,	0x5B00 },
+	{ 4119,	0x5D00 },
+	{ 3999,	0x6000 },
+	{ 3950,	0x6100 },
+	{ 3876,	0x6300 },
+	{ 3755,	0x6600 },
+	{ 3641,	0x6900 },
+	{ 3567,	0x6B00 },
+	{ 3425,	0x6F00 },
+	{ 3350,	0x7100 },
+	{ 3236,	0x7400 },
+	{ 3118,	0x7700 },
+	{ 3004,	0x7A00 },
+	{ 2917,	0x7C00 },
+	{ 2776,	0x7F00 },
+	{ 2635,	0x8200 },
+	{ 2516,	0x8500 },
+	{ 2406,	0x8800 },
+	{ 2290,	0x8B00 },
+	{ 2170,	0x8E00 },
+	{ 2073,	0x9100 },
+	{ 1949,	0x9400 },
+	{ 1836,	0x9700 },
+	{ 1712,	0x9A00 },
+	{ 1631,	0x9C00 },
+	{ 1515,	0x9F00 },
+	{ 1400,	0xA200 },
+	{ 1323,	0xA400 },
+	{ 1203,	0xA700 },
+	{ 1091,	0xAA00 },
+	{ 1011,	0xAC00 },
+	{ 904,	0xAF00 },
+	{ 787,	0xB200 },
+	{ 685,	0xB500 },
+	{ 571,	0xB800 },
+	{ 464,	0xBB00 },
+	{ 374,	0xBE00 },
+	{ 275,	0xC200 },
+	{ 181,	0xC600 },
+	{ 102,	0xCC00 },
+	{ 49,	0xD900 }
+};
+
+/*
+ * This table is 6 dB too low comapred to the others (probably created with
+ * a different BB_MAG setting)
+*/
+static struct SLookup Gain_Channel_AGC_NF_LookUp[] = {
+	/*Gain *100dB*/   /*reg*/
+	{ 7082,	0x3000 },
+	{ 7052,	0x4000 },
+	{ 7007,	0x4600 },
+	{ 6954,	0x4A00 },
+	{ 6909,	0x4D00 },
+	{ 6833,	0x5100 },
+	{ 6753,	0x5400 },
+	{ 6659,	0x5700 },
+	{ 6561,	0x5A00 },
+	{ 6472,	0x5C00 },
+	{ 6366,	0x5F00 },
+	{ 6259,	0x6100 },
+	{ 6151,	0x6400 },
+	{ 6026,	0x6700 },
+	{ 5920,	0x6900 },
+	{ 5835,	0x6B00 },
+	{ 5770,	0x6C00 },
+	{ 5681,	0x6E00 },
+	{ 5596,	0x7000 },
+	{ 5503,	0x7200 },
+	{ 5429,	0x7300 },
+	{ 5319,	0x7500 },
+	{ 5220,	0x7700 },
+	{ 5111,	0x7900 },
+	{ 4983,	0x7B00 },
+	{ 4876,	0x7D00 },
+	{ 4755,	0x7F00 },
+	{ 4635,	0x8100 },
+	{ 4499,	0x8300 },
+	{ 4405,	0x8500 },
+	{ 4323,	0x8600 },
+	{ 4233,	0x8800 },
+	{ 4156,	0x8A00 },
+	{ 4038,	0x8C00 },
+	{ 3935,	0x8E00 },
+	{ 3823,	0x9000 },
+	{ 3712,	0x9200 },
+	{ 3601,	0x9500 },
+	{ 3511,	0x9700 },
+	{ 3413,	0x9900 },
+	{ 3309,	0x9B00 },
+	{ 3213,	0x9D00 },
+	{ 3088,	0x9F00 },
+	{ 2992,	0xA100 },
+	{ 2878,	0xA400 },
+	{ 2769,	0xA700 },
+	{ 2645,	0xAA00 },
+	{ 2538,	0xAD00 },
+	{ 2441,	0xB000 },
+	{ 2350,	0xB600 },
+	{ 2237,	0xBA00 },
+	{ 2137,	0xBF00 },
+	{ 2039,	0xC500 },
+	{ 1938,	0xDF00 },
+	{ 1927,	0xFF00 }
+};
+
+static struct SLookup Gain_Channel_AGC_IIP3_LookUp[] = {
+	/*Gain *100dB*/   /*reg*/
+	{ 7070,	0x3000 },
+	{ 7028,	0x4000 },
+	{ 7019,	0x4600 },
+	{ 6900,	0x4A00 },
+	{ 6811,	0x4D00 },
+	{ 6763,	0x5100 },
+	{ 6690,	0x5400 },
+	{ 6644,	0x5700 },
+	{ 6617,	0x5A00 },
+	{ 6598,	0x5C00 },
+	{ 6462,	0x5F00 },
+	{ 6348,	0x6100 },
+	{ 6197,	0x6400 },
+	{ 6154,	0x6700 },
+	{ 6098,	0x6900 },
+	{ 5893,	0x6B00 },
+	{ 5812,	0x6C00 },
+	{ 5773,	0x6E00 },
+	{ 5723,	0x7000 },
+	{ 5661,	0x7200 },
+	{ 5579,	0x7300 },
+	{ 5460,	0x7500 },
+	{ 5308,	0x7700 },
+	{ 5099,	0x7900 },
+	{ 4910,	0x7B00 },
+	{ 4800,	0x7D00 },
+	{ 4785,	0x7F00 },
+	{ 4635,	0x8100 },
+	{ 4466,	0x8300 },
+	{ 4314,	0x8500 },
+	{ 4295,	0x8600 },
+	{ 4144,	0x8800 },
+	{ 3920,	0x8A00 },
+	{ 3889,	0x8C00 },
+	{ 3771,	0x8E00 },
+	{ 3655,	0x9000 },
+	{ 3446,	0x9200 },
+	{ 3298,	0x9500 },
+	{ 3083,	0x9700 },
+	{ 3015,	0x9900 },
+	{ 2833,	0x9B00 },
+	{ 2746,	0x9D00 },
+	{ 2632,	0x9F00 },
+	{ 2598,	0xA100 },
+	{ 2480,	0xA400 },
+	{ 2236,	0xA700 },
+	{ 2171,	0xAA00 },
+	{ 2060,	0xAD00 },
+	{ 1999,	0xB000 },
+	{ 1974,	0xB600 },
+	{ 1820,	0xBA00 },
+	{ 1741,	0xBF00 },
+	{ 1655,	0xC500 },
+	{ 1444,	0xDF00 },
+	{ 1325,	0xFF00 },
+};
+
+static inline u32 MulDiv32(u32 a, u32 b, u32 c)
+{
+	u64 tmp64;
+
+	tmp64 = (u64)a * (u64)b;
+	do_div(tmp64, c);
+
+	return (u32) tmp64;
+}
+
+static int i2c_read(struct i2c_adapter *adap,
+		    u8 adr, u8 *msg, int len, u8 *answ, int alen)
+{
+	struct i2c_msg msgs[2] = { { .addr = adr, .flags = 0,
+				     .buf = msg, .len = len},
+				   { .addr = adr, .flags = I2C_M_RD,
+				     .buf = answ, .len = alen } };
+	if (i2c_transfer(adap, msgs, 2) != 2) {
+		pr_err("i2c_read error\n");
+		return -EREMOTEIO;
+	}
+	return 0;
+}
+
+static int i2c_write(struct i2c_adapter *adap, u8 adr, u8 *data, int len)
+{
+	struct i2c_msg msg = {.addr = adr, .flags = 0,
+			      .buf = data, .len = len};
+
+	if (i2c_transfer(adap, &msg, 1) != 1) {
+		pr_err("i2c_write error\n");
+		return -EREMOTEIO;
+	}
+	return 0;
+}
+
+static int write_regs(struct stv *state, int reg, int len)
+{
+	u8 d[12];
+
+	memcpy(&d[1], &state->reg[reg], len);
+	d[0] = reg;
+	return i2c_write(state->i2c, state->adr, d, len + 1);
+}
+
+static int write_reg(struct stv *state, u8 reg, u8 val)
+{
+	u8 d[2] = {reg, val};
+
+	return i2c_write(state->i2c, state->adr, d, 2);
+}
+
+static int read_reg(struct stv *state, u8 reg, u8 *val)
+{
+	return i2c_read(state->i2c, state->adr, &reg, 1, val, 1);
+}
+
+static int wait_for_call_done(struct stv *state, u8 mask)
+{
+	int status = 0;
+	u32 LockRetryCount = 10;
+
+	while (LockRetryCount > 0) {
+		u8 Status;
+
+		status = read_reg(state, 9, &Status);
+		if (status < 0)
+			return status;
+
+		if ((Status & mask) == 0)
+			break;
+		usleep_range(4000, 6000);
+		LockRetryCount -= 1;
+
+		status = -EIO;
+	}
+	return status;
+}
+
+static void init_state(struct stv *state)
+{
+	u32 clkdiv = 0;
+	u32 agcmode = 0;
+	u32 agcref = 2;
+	u32 agcset = 0xffffffff;
+	u32 bbmode = 0xffffffff;
+
+	state->reg[0] = 0x08;
+	state->reg[1] = 0x41;
+	state->reg[2] = 0x8f;
+	state->reg[3] = 0x00;
+	state->reg[4] = 0xce;
+	state->reg[5] = 0x54;
+	state->reg[6] = 0x55;
+	state->reg[7] = 0x45;
+	state->reg[8] = 0x46;
+	state->reg[9] = 0xbd;
+	state->reg[10] = 0x11;
+
+	state->ref_freq = 16000;
+
+	if (clkdiv <= 3)
+		state->reg[0x00] |= (clkdiv & 0x03);
+	if (agcmode <= 3) {
+		state->reg[0x03] |= (agcmode << 5);
+		if (agcmode == 0x01)
+			state->reg[0x01] |= 0x30;
+	}
+	if (bbmode <= 3)
+		state->reg[0x01] = (state->reg[0x01] & ~0x30) | (bbmode << 4);
+	if (agcref <= 7)
+		state->reg[0x03] |= agcref;
+	if (agcset <= 31)
+		state->reg[0x02] = (state->reg[0x02] & ~0x1F) | agcset | 0x40;
+}
+
+static int attach_init(struct stv *state)
+{
+	if (write_regs(state, 0, 11))
+		return -ENODEV;
+	return 0;
+}
+
+static int release(struct dvb_frontend *fe)
+{
+	kfree(fe->tuner_priv);
+	fe->tuner_priv = NULL;
+	return 0;
+}
+
+static int set_bandwidth(struct dvb_frontend *fe, u32 CutOffFrequency)
+{
+	struct stv *state = fe->tuner_priv;
+	u32 index = (CutOffFrequency + 999999) / 1000000;
+
+	if (index < 6)
+		index = 6;
+	if (index > 50)
+		index = 50;
+	if ((state->reg[0x08] & ~0xFC) == ((index-6) << 2))
+		return 0;
+
+	state->reg[0x08] = (state->reg[0x08] & ~0xFC) | ((index-6) << 2);
+	state->reg[0x09] = (state->reg[0x09] & ~0x0C) | 0x08;
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 1);
+	write_regs(state, 0x08, 2);
+	wait_for_call_done(state, 0x08);
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 0);
+	return 0;
+}
+
+static int set_lof(struct stv *state, u32 LocalFrequency, u32 CutOffFrequency)
+{
+	u32 index = (CutOffFrequency + 999999) / 1000000;
+	u32 Frequency = (LocalFrequency + 500) / 1000;
+	u32 p = 1, psel = 0, fvco, div, frac;
+	u8 Icp, tmp;
+
+	if (index < 6)
+		index = 6;
+	if (index > 50)
+		index = 50;
+
+	if (Frequency <= 1300000) {
+		p =  4;
+		psel = 1;
+	} else {
+		p =  2;
+		psel = 0;
+	}
+	fvco = Frequency * p;
+	div = fvco / state->ref_freq;
+	frac = fvco % state->ref_freq;
+	frac = MulDiv32(frac, 0x40000, state->ref_freq);
+
+	Icp = 0;
+	if (fvco < 2700000)
+		Icp = 0;
+	else if (fvco < 2950000)
+		Icp = 1;
+	else if (fvco < 3300000)
+		Icp = 2;
+	else if (fvco < 3700000)
+		Icp = 3;
+	else if (fvco < 4200000)
+		Icp = 5;
+	else if (fvco < 4800000)
+		Icp = 6;
+	else
+		Icp = 7;
+
+	state->reg[0x02] |= 0x80;   /* LNA IIP3 Mode */
+
+	state->reg[0x03] = (state->reg[0x03] & ~0x80) | (psel << 7);
+	state->reg[0x04] = (div & 0xFF);
+	state->reg[0x05] = (((div >> 8) & 0x01) | ((frac & 0x7F) << 1)) & 0xff;
+	state->reg[0x06] = ((frac >> 7) & 0xFF);
+	state->reg[0x07] = (state->reg[0x07] & ~0x07) | ((frac >> 15) & 0x07);
+	state->reg[0x07] = (state->reg[0x07] & ~0xE0) | (Icp << 5);
+
+	state->reg[0x08] = (state->reg[0x08] & ~0xFC) | ((index - 6) << 2);
+	/* Start cal vco,CF */
+	state->reg[0x09] = (state->reg[0x09] & ~0x0C) | 0x0C;
+	write_regs(state, 2, 8);
+
+	wait_for_call_done(state, 0x0C);
+
+	usleep_range(10000, 12000);
+
+	read_reg(state, 0x03, &tmp);
+	if (tmp & 0x10)	{
+		state->reg[0x02] &= ~0x80;   /* LNA NF Mode */
+		write_regs(state, 2, 1);
+	}
+	read_reg(state, 0x08, &tmp);
+
+	state->Frequency = Frequency;
+
+	return 0;
+}
+
+static int set_params(struct dvb_frontend *fe)
+{
+	struct stv *state = fe->tuner_priv;
+	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
+	u32 freq, symb, cutoff;
+
+	if (p->delivery_system != SYS_DVBS && p->delivery_system != SYS_DVBS2)
+		return -EINVAL;
+
+	freq = p->frequency * 1000;
+	symb = p->symbol_rate;
+	cutoff = 5000000 + MulDiv32(p->symbol_rate, 135, 200);
+
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 1);
+	set_lof(state, freq, cutoff);
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 0);
+	return 0;
+}
+
+static s32 TableLookup(struct SLookup *Table, int TableSize, u16 RegValue)
+{
+	s32 Gain;
+	s32 RegDiff;
+	int imin = 0;
+	int imax = TableSize - 1;
+	int i;
+
+	/* Assumes Table[0].RegValue < Table[imax].RegValue */
+	if (RegValue <= Table[0].RegValue)
+		Gain = Table[0].Value;
+	else if (RegValue >= Table[imax].RegValue)
+		Gain = Table[imax].Value;
+	else {
+		while (imax-imin > 1) {
+			i = (imax + imin) / 2;
+			if ((Table[imin].RegValue <= RegValue) &&
+			    (RegValue <= Table[i].RegValue))
+				imax = i;
+			else
+				imin = i;
+		}
+		RegDiff = Table[imax].RegValue - Table[imin].RegValue;
+		Gain = Table[imin].Value;
+		if (RegDiff != 0)
+			Gain += ((s32) (RegValue - Table[imin].RegValue) *
+				(s32)(Table[imax].Value
+				- Table[imin].Value))/(RegDiff);
+	}
+	return Gain;
+}
+
+static int get_rf_strength(struct dvb_frontend *fe, u16 *st)
+{
+	struct stv *state = fe->tuner_priv;
+	u16 RFAgc = *st;
+	s32 Gain;
+
+	if ((state->reg[0x03] & 0x60) == 0) {
+		/* RF Mode, Read AGC ADC */
+		u8 Reg = 0;
+
+		if (fe->ops.i2c_gate_ctrl)
+			fe->ops.i2c_gate_ctrl(fe, 1);
+		write_reg(state, 0x02, state->reg[0x02] | 0x20);
+		read_reg(state, 2, &Reg);
+		if (Reg & 0x20)
+			read_reg(state, 2, &Reg);
+		if (fe->ops.i2c_gate_ctrl)
+			fe->ops.i2c_gate_ctrl(fe, 0);
+
+		if ((state->reg[0x02] & 0x80) == 0)
+			/* NF */
+			Gain = TableLookup(LNAGain_NF_LookUp,
+				ARRAY_SIZE(LNAGain_NF_LookUp), Reg & 0x1F);
+		else
+			/* IIP3 */
+			Gain = TableLookup(LNAGain_IIP3_LookUp,
+				ARRAY_SIZE(LNAGain_IIP3_LookUp), Reg & 0x1F);
+
+		Gain += TableLookup(Gain_RFAGC_LookUp,
+				ARRAY_SIZE(Gain_RFAGC_LookUp), RFAgc);
+		Gain -= 2400;
+	} else {
+		/* Channel Mode */
+		if ((state->reg[0x02] & 0x80) == 0) {
+			/* NF */
+			Gain = TableLookup(Gain_Channel_AGC_NF_LookUp,
+				ARRAY_SIZE(Gain_Channel_AGC_NF_LookUp), RFAgc);
+			Gain += 600;
+		} else {
+			/* IIP3 */
+			Gain = TableLookup(Gain_Channel_AGC_IIP3_LookUp,
+				ARRAY_SIZE(Gain_Channel_AGC_IIP3_LookUp),
+					RFAgc);
+		}
+	}
+
+	if (state->Frequency > 0)
+		/* Tilt correction ( 0.00016 dB/MHz ) */
+		Gain -= ((((s32)(state->Frequency / 1000) - 1550) * 2) / 12);
+
+	/* + (BBGain * 10); */
+	Gain +=  (s32)((state->reg[0x01] & 0xC0) >> 6) * 600 - 1300;
+
+	if (Gain < 0)
+		Gain = 0;
+	else if (Gain > 10000)
+		Gain = 10000;
+
+	*st = 10000 - Gain;
+
+	return 0;
+}
+
+static struct dvb_tuner_ops tuner_ops = {
+	.info = {
+		.name = "STV6111",
+		.frequency_min  =  950000,
+		.frequency_max  = 2150000,
+		.frequency_step =       0
+	},
+	.set_params        = set_params,
+	.release           = release,
+	.get_rf_strength   = get_rf_strength,
+	.set_bandwidth     = set_bandwidth,
+};
+
+struct dvb_frontend *stv6111_attach(struct dvb_frontend *fe,
+				    struct i2c_adapter *i2c, u8 adr)
+{
+	struct stv *state;
+	int stat;
+
+	state = kzalloc(sizeof(struct stv), GFP_KERNEL);
+	if (!state)
+		return NULL;
+	state->adr = adr;
+	state->i2c = i2c;
+	memcpy(&fe->ops.tuner_ops, &tuner_ops, sizeof(struct dvb_tuner_ops));
+	init_state(state);
+
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 1);
+	stat = attach_init(state);
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 0);
+	if (stat < 0) {
+		kfree(state);
+		return 0;
+	}
+	fe->tuner_priv = state;
+	return fe;
+}
+EXPORT_SYMBOL_GPL(stv6111_attach);
+
+MODULE_DESCRIPTION("STV6111 driver");
+MODULE_AUTHOR("Ralph Metzler, Manfred Voelkel");
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/dvb-frontends/stv6111.h b/drivers/media/dvb-frontends/stv6111.h
new file mode 100644
index 0000000..55b5ddc
--- /dev/null
+++ b/drivers/media/dvb-frontends/stv6111.h
@@ -0,0 +1,20 @@
+#ifndef _STV6111_H_
+#define _STV6111_H_
+
+#if IS_REACHABLE(CONFIG_DVB_STV6111)
+
+extern struct dvb_frontend *stv6111_attach(struct dvb_frontend *fe,
+				struct i2c_adapter *i2c, u8 adr);
+
+#else
+
+static inline struct dvb_frontend *stv6111_attach(struct dvb_frontend *fe,
+				struct i2c_adapter *i2c, u8 adr);
+{
+	pr_warn("%s: Driver disabled by Kconfig\n", __func__);
+	return NULL;
+}
+
+#endif /* CONFIG_DVB_STV6111 */
+
+#endif /* _STV6111_H_ */
diff --git a/drivers/media/pci/ddbridge/Kconfig b/drivers/media/pci/ddbridge/Kconfig
index 44e5dc1..eed08a4 100644
--- a/drivers/media/pci/ddbridge/Kconfig
+++ b/drivers/media/pci/ddbridge/Kconfig
@@ -1,11 +1,20 @@
 config DVB_DDBRIDGE
 	tristate "Digital Devices bridge support"
 	depends on DVB_CORE && PCI && I2C
+	select STAGING_MEDIA
+	select DVB_CXD2099
 	select DVB_LNBP21 if MEDIA_SUBDRV_AUTOSELECT
 	select DVB_STV6110x if MEDIA_SUBDRV_AUTOSELECT
 	select DVB_STV090x if MEDIA_SUBDRV_AUTOSELECT
+	select DVB_LNBH25 if MEDIA_SUBDRV_AUTOSELECT
+	select DVB_STV6111 if MEDIA_SUBDRV_AUTOSELECT
+	select DVB_STV0910 if MEDIA_SUBDRV_AUTOSELECT
 	select DVB_DRXK if MEDIA_SUBDRV_AUTOSELECT
+	select MEDIA_TUNER_TDA18212 if MEDIA_SUBDRV_AUTOSELECT
 	select DVB_TDA18271C2DD if MEDIA_SUBDRV_AUTOSELECT
+	select DVB_STV0367DD if MEDIA_SUBDRV_AUTOSELECT
+	select DVB_CXD2843 if MEDIA_SUBDRV_AUTOSELECT
+	select DVB_MXL5XX if MEDIA_SUBDRV_AUTOSELECT
 	---help---
 	  Support for cards with the Digital Devices PCI express bridge:
 	  - Octopus PCIe Bridge
@@ -13,6 +22,24 @@ config DVB_DDBRIDGE
 	  - Octopus LE
 	  - DuoFlex S2 Octopus
 	  - DuoFlex CT Octopus
-	  - cineS2(v6)
+	  - cineS2(v6.x)
+	  - cineCT(v6.x, v7)
+	  - Max A8 C2/T2
+	  - Max S8
 
 	  Say Y if you own such a card and want to use it.
+
+config DVB_DDBRIDGE_MSIENABLE
+	bool "Enable Message Signaled Interrupts (MSI) per default (EXPERIMENTAL)"
+	depends on DVB_DDBRIDGE
+	depends on PCI_MSI
+	default n
+	---help---
+	  Use PCI MSI (Message Signaled Interrupts) per default. Enabling this
+	  might lead to I2C errors originating from the bridge in conjunction
+	  with certain SATA controllers, requiring a reload of the ddbridge
+	  module. MSI can still be disabled by passing msi=0 as option, as
+	  this will just change the msi option default value.
+
+	  If you're unsure, concerned about stability and don't want to pass
+	  module options in case of troubles, say N.
diff --git a/drivers/media/pci/ddbridge/Makefile b/drivers/media/pci/ddbridge/Makefile
index 7446c8b..28e89f0 100644
--- a/drivers/media/pci/ddbridge/Makefile
+++ b/drivers/media/pci/ddbridge/Makefile
@@ -2,9 +2,7 @@
 # Makefile for the ddbridge device driver
 #
 
-ddbridge-objs := ddbridge-core.o
-
-obj-$(CONFIG_DVB_DDBRIDGE) += ddbridge.o
+obj-$(CONFIG_DVB_DDBRIDGE) += ddbridge.o octonet.o
 
 ccflags-y += -Idrivers/media/dvb-core/
 ccflags-y += -Idrivers/media/dvb-frontends/
diff --git a/drivers/media/pci/ddbridge/ddbridge-core.c b/drivers/media/pci/ddbridge/ddbridge-core.c
index 47def73..82c1938 100644
--- a/drivers/media/pci/ddbridge/ddbridge-core.c
+++ b/drivers/media/pci/ddbridge/ddbridge-core.c
@@ -1,7 +1,10 @@
 /*
- * ddbridge.c: Digital Devices PCIe bridge driver
+ * ddbridge-core.c: Digital Devices bridge core functions
+ *
+ * Copyright (C) 2010-2015 Digital Devices GmbH
+ *                         Marcus Metzler <mocm@metzlerbros.de>
+ *                         Ralph Metzler <rjkm@metzlerbros.de>
  *
- * Copyright (C) 2010-2011 Digital Devices GmbH
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -21,306 +24,289 @@
  * Or, point your browser to http://www.gnu.org/copyleft/gpl.html
  */
 
-#include <linux/module.h>
-#include <linux/init.h>
-#include <linux/interrupt.h>
-#include <linux/delay.h>
-#include <linux/slab.h>
-#include <linux/poll.h>
-#include <linux/io.h>
-#include <linux/pci.h>
-#include <linux/pci_ids.h>
-#include <linux/timer.h>
-#include <linux/i2c.h>
-#include <linux/swab.h>
-#include <linux/vmalloc.h>
-#include "ddbridge.h"
-
-#include "ddbridge-regs.h"
-
-#include "tda18271c2dd.h"
-#include "stv6110x.h"
-#include "stv090x.h"
-#include "lnbh24.h"
-#include "drxk.h"
+DEFINE_MUTEX(redirect_lock);
+
+static int ci_bitrate = 72000;
+module_param(ci_bitrate, int, 0444);
+MODULE_PARM_DESC(ci_bitrate, " Bitrate for output to CI.");
+
+static int ts_loop = -1;
+module_param(ts_loop, int, 0444);
+MODULE_PARM_DESC(ts_loop, "TS in/out test loop on port ts_loop");
+
+static int vlan;
+module_param(vlan, int, 0444);
+MODULE_PARM_DESC(vlan, "VLAN and QoS IDs enabled");
+
+static int tt;
+module_param(tt, int, 0444);
+MODULE_PARM_DESC(tt, "");
+
+static int fmode;
+module_param(fmode, int, 0444);
+MODULE_PARM_DESC(fmode, "frontend emulation mode");
+
+static int old_quattro;
+module_param(old_quattro, int, 0444);
+MODULE_PARM_DESC(old_quattro, "old quattro LNB input order ");
+
+#define DDB_MAX_ADAPTER 64
+static struct ddb *ddbs[DDB_MAX_ADAPTER];
 
 DVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);
 
-/* MSI had problems with lost interrupts, fixed but needs testing */
-#undef CONFIG_PCI_MSI
+#include "ddbridge-mod.c"
+#include "ddbridge-i2c.c"
+#include "ddbridge-ns.c"
 
-/******************************************************************************/
 
-static int i2c_read(struct i2c_adapter *adapter, u8 adr, u8 *val)
+static void ddb_set_dma_table(struct ddb *dev, struct ddb_dma *dma)
 {
-	struct i2c_msg msgs[1] = {{.addr = adr,  .flags = I2C_M_RD,
-				   .buf  = val,  .len   = 1 } };
-	return (i2c_transfer(adapter, msgs, 1) == 1) ? 0 : -1;
-}
+	u32 i, base;
+	u64 mem;
 
-static int i2c_read_reg(struct i2c_adapter *adapter, u8 adr, u8 reg, u8 *val)
-{
-	struct i2c_msg msgs[2] = {{.addr = adr,  .flags = 0,
-				   .buf  = &reg, .len   = 1 },
-				  {.addr = adr,  .flags = I2C_M_RD,
-				   .buf  = val,  .len   = 1 } };
-	return (i2c_transfer(adapter, msgs, 2) == 2) ? 0 : -1;
+	if (!dma)
+		return;
+	base = DMA_BASE_ADDRESS_TABLE + dma->nr * 0x100;
+	for (i = 0; i < dma->num; i++) {
+		mem = dma->pbuf[i];
+		ddbwritel(dev, mem & 0xffffffff, base + i * 8);
+		ddbwritel(dev, mem >> 32, base + i * 8 + 4);
+	}
+	dma->bufreg = (dma->div << 16) |
+		((dma->num & 0x1f) << 11) |
+		((dma->size >> 7) & 0x7ff);
 }
 
-static int i2c_read_reg16(struct i2c_adapter *adapter, u8 adr,
-			  u16 reg, u8 *val)
+static void ddb_set_dma_tables(struct ddb *dev)
 {
-	u8 msg[2] = {reg>>8, reg&0xff};
-	struct i2c_msg msgs[2] = {{.addr = adr, .flags = 0,
-				   .buf  = msg, .len   = 2},
-				  {.addr = adr, .flags = I2C_M_RD,
-				   .buf  = val, .len   = 1} };
-	return (i2c_transfer(adapter, msgs, 2) == 2) ? 0 : -1;
+	u32 i;
+
+	for (i = 0; i < dev->link[0].info->port_num * 2; i++)
+		ddb_set_dma_table(dev, dev->input[i].dma);
+	for (i = 0; i < dev->link[0].info->port_num; i++)
+		ddb_set_dma_table(dev, dev->output[i].dma);
 }
 
-static int ddb_i2c_cmd(struct ddb_i2c *i2c, u32 adr, u32 cmd)
-{
-	struct ddb *dev = i2c->dev;
-	long stat;
-	u32 val;
 
-	i2c->done = 0;
-	ddbwritel((adr << 9) | cmd, i2c->regs + I2C_COMMAND);
-	stat = wait_event_timeout(i2c->wq, i2c->done == 1, HZ);
-	if (stat == 0) {
-		printk(KERN_ERR "I2C timeout\n");
-		{ /* MSI debugging*/
-			u32 istat = ddbreadl(INTERRUPT_STATUS);
-			printk(KERN_ERR "IRS %08x\n", istat);
-			ddbwritel(istat, INTERRUPT_ACK);
-		}
-		return -EIO;
-	}
-	val = ddbreadl(i2c->regs+I2C_COMMAND);
-	if (val & 0x70000)
-		return -EIO;
-	return 0;
-}
+/****************************************************************************/
+/****************************************************************************/
+/****************************************************************************/
 
-static int ddb_i2c_master_xfer(struct i2c_adapter *adapter,
-			       struct i2c_msg msg[], int num)
+static void ddb_redirect_dma(struct ddb *dev,
+			     struct ddb_dma *sdma,
+			     struct ddb_dma *ddma)
 {
-	struct ddb_i2c *i2c = (struct ddb_i2c *)i2c_get_adapdata(adapter);
-	struct ddb *dev = i2c->dev;
-	u8 addr = 0;
-
-	if (num)
-		addr = msg[0].addr;
+	u32 i, base;
+	u64 mem;
 
-	if (num == 2 && msg[1].flags & I2C_M_RD &&
-	    !(msg[0].flags & I2C_M_RD)) {
-		memcpy_toio(dev->regs + I2C_TASKMEM_BASE + i2c->wbuf,
-			    msg[0].buf, msg[0].len);
-		ddbwritel(msg[0].len|(msg[1].len << 16),
-			  i2c->regs+I2C_TASKLENGTH);
-		if (!ddb_i2c_cmd(i2c, addr, 1)) {
-			memcpy_fromio(msg[1].buf,
-				      dev->regs + I2C_TASKMEM_BASE + i2c->rbuf,
-				      msg[1].len);
-			return num;
-		}
+	sdma->bufreg = ddma->bufreg;
+	base = DMA_BASE_ADDRESS_TABLE + sdma->nr * 0x100;
+	for (i = 0; i < ddma->num; i++) {
+		mem = ddma->pbuf[i];
+		ddbwritel(dev, mem & 0xffffffff, base + i * 8);
+		ddbwritel(dev, mem >> 32, base + i * 8 + 4);
 	}
+}
 
-	if (num == 1 && !(msg[0].flags & I2C_M_RD)) {
-		ddbcpyto(I2C_TASKMEM_BASE + i2c->wbuf, msg[0].buf, msg[0].len);
-		ddbwritel(msg[0].len, i2c->regs + I2C_TASKLENGTH);
-		if (!ddb_i2c_cmd(i2c, addr, 2))
-			return num;
+static int ddb_unredirect(struct ddb_port *port)
+{
+	struct ddb_input *oredi, *iredi = 0;
+	struct ddb_output *iredo = 0;
+
+	/*pr_info("unredirect %d.%d\n", port->dev->nr, port->nr);*/
+	mutex_lock(&redirect_lock);
+	if (port->output->dma->running) {
+		mutex_unlock(&redirect_lock);
+		return -EBUSY;
 	}
-	if (num == 1 && (msg[0].flags & I2C_M_RD)) {
-		ddbwritel(msg[0].len << 16, i2c->regs + I2C_TASKLENGTH);
-		if (!ddb_i2c_cmd(i2c, addr, 3)) {
-			ddbcpyfrom(msg[0].buf,
-				   I2C_TASKMEM_BASE + i2c->rbuf, msg[0].len);
-			return num;
+	oredi = port->output->redi;
+	if (!oredi)
+		goto done;
+	if (port->input[0]) {
+		iredi = port->input[0]->redi;
+		iredo = port->input[0]->redo;
+
+		if (iredo) {
+			iredo->port->output->redi = oredi;
+			if (iredo->port->input[0]) {
+				iredo->port->input[0]->redi = iredi;
+				ddb_redirect_dma(oredi->port->dev,
+						 oredi->dma, iredo->dma);
+			}
+			port->input[0]->redo = 0;
+			ddb_set_dma_table(port->dev, port->input[0]->dma);
 		}
+		oredi->redi = iredi;
+		port->input[0]->redi = 0;
 	}
-	return -EIO;
-}
+	oredi->redo = 0;
+	port->output->redi = 0;
 
+	ddb_set_dma_table(oredi->port->dev, oredi->dma);
+done:
+	mutex_unlock(&redirect_lock);
+	return 0;
+}
 
-static u32 ddb_i2c_functionality(struct i2c_adapter *adap)
+static int ddb_redirect(u32 i, u32 p)
 {
-	return I2C_FUNC_SMBUS_EMUL;
-}
+	struct ddb *idev = ddbs[(i >> 4) & 0x1f];
+	struct ddb_input *input, *input2;
+	struct ddb *pdev = ddbs[(p >> 4) & 0x1f];
+	struct ddb_port *port;
 
-static struct i2c_algorithm ddb_i2c_algo = {
-	.master_xfer   = ddb_i2c_master_xfer,
-	.functionality = ddb_i2c_functionality,
-};
+	if (!idev->has_dma || !pdev->has_dma)
+		return -EINVAL;
+	if (!idev || !pdev)
+		return -EINVAL;
 
-static void ddb_i2c_release(struct ddb *dev)
-{
-	int i;
-	struct ddb_i2c *i2c;
-	struct i2c_adapter *adap;
+	port = &pdev->port[p & 0x0f];
+	if (!port->output)
+		return -EINVAL;
+	if (ddb_unredirect(port))
+		return -EBUSY;
 
-	for (i = 0; i < dev->info->port_num; i++) {
-		i2c = &dev->i2c[i];
-		adap = &i2c->adap;
-		i2c_del_adapter(adap);
-	}
-}
+	if (i == 8)
+		return 0;
 
-static int ddb_i2c_init(struct ddb *dev)
-{
-	int i, j, stat = 0;
-	struct ddb_i2c *i2c;
-	struct i2c_adapter *adap;
+	input = &idev->input[i & 7];
+	if (!input)
+		return -EINVAL;
 
-	for (i = 0; i < dev->info->port_num; i++) {
-		i2c = &dev->i2c[i];
-		i2c->dev = dev;
-		i2c->nr = i;
-		i2c->wbuf = i * (I2C_TASKMEM_SIZE / 4);
-		i2c->rbuf = i2c->wbuf + (I2C_TASKMEM_SIZE / 8);
-		i2c->regs = 0x80 + i * 0x20;
-		ddbwritel(I2C_SPEED_100, i2c->regs + I2C_TIMING);
-		ddbwritel((i2c->rbuf << 16) | i2c->wbuf,
-			  i2c->regs + I2C_TASKADDRESS);
-		init_waitqueue_head(&i2c->wq);
-
-		adap = &i2c->adap;
-		i2c_set_adapdata(adap, i2c);
-#ifdef I2C_ADAP_CLASS_TV_DIGITAL
-		adap->class = I2C_ADAP_CLASS_TV_DIGITAL|I2C_CLASS_TV_ANALOG;
-#else
-#ifdef I2C_CLASS_TV_ANALOG
-		adap->class = I2C_CLASS_TV_ANALOG;
-#endif
-#endif
-		strcpy(adap->name, "ddbridge");
-		adap->algo = &ddb_i2c_algo;
-		adap->algo_data = (void *)i2c;
-		adap->dev.parent = &dev->pdev->dev;
-		stat = i2c_add_adapter(adap);
-		if (stat)
-			break;
+	mutex_lock(&redirect_lock);
+	if (port->output->dma->running || input->dma->running) {
+		mutex_unlock(&redirect_lock);
+		return -EBUSY;
 	}
-	if (stat)
-		for (j = 0; j < i; j++) {
-			i2c = &dev->i2c[j];
-			adap = &i2c->adap;
-			i2c_del_adapter(adap);
-		}
-	return stat;
-}
+	input2 = port->input[0];
+	if (input2) {
+		if (input->redi) {
+			input2->redi = input->redi;
+			input->redi = 0;
+		} else
+			input2->redi = input;
+	}
+	input->redo = port->output;
+	port->output->redi = input;
 
+	ddb_redirect_dma(input->port->dev, input->dma, port->output->dma);
+	mutex_unlock(&redirect_lock);
+	return 0;
+}
 
-/******************************************************************************/
-/******************************************************************************/
-/******************************************************************************/
+/****************************************************************************/
+/****************************************************************************/
+/****************************************************************************/
 
-#if 0
-static void set_table(struct ddb *dev, u32 off,
-		      dma_addr_t *pbuf, u32 num)
+#ifdef DDB_ALT_DMA
+static void dma_free(struct pci_dev *pdev, struct ddb_dma *dma, int dir)
 {
-	u32 i, base;
-	u64 mem;
+	int i;
 
-	base = DMA_BASE_ADDRESS_TABLE + off;
-	for (i = 0; i < num; i++) {
-		mem = pbuf[i];
-		ddbwritel(mem & 0xffffffff, base + i * 8);
-		ddbwritel(mem >> 32, base + i * 8 + 4);
+	if (!dma)
+		return;
+	for (i = 0; i < dma->num; i++) {
+		if (dma->vbuf[i]) {
+			dma_unmap_single(&pdev->dev, dma->pbuf[i],
+					 dma->size,
+					 dir ? DMA_TO_DEVICE :
+					 DMA_FROM_DEVICE);
+			kfree(dma->vbuf[i]);
+			dma->vbuf[i] = NULL;
+		}
 	}
 }
-#endif
 
-static void ddb_address_table(struct ddb *dev)
+static int dma_alloc(struct pci_dev *pdev, struct ddb_dma *dma, int dir)
 {
-	u32 i, j, base;
-	u64 mem;
-	dma_addr_t *pbuf;
-
-	for (i = 0; i < dev->info->port_num * 2; i++) {
-		base = DMA_BASE_ADDRESS_TABLE + i * 0x100;
-		pbuf = dev->input[i].pbuf;
-		for (j = 0; j < dev->input[i].dma_buf_num; j++) {
-			mem = pbuf[j];
-			ddbwritel(mem & 0xffffffff, base + j * 8);
-			ddbwritel(mem >> 32, base + j * 8 + 4);
-		}
-	}
-	for (i = 0; i < dev->info->port_num; i++) {
-		base = DMA_BASE_ADDRESS_TABLE + 0x800 + i * 0x100;
-		pbuf = dev->output[i].pbuf;
-		for (j = 0; j < dev->output[i].dma_buf_num; j++) {
-			mem = pbuf[j];
-			ddbwritel(mem & 0xffffffff, base + j * 8);
-			ddbwritel(mem >> 32, base + j * 8 + 4);
+	int i;
+
+	if (!dma)
+		return 0;
+	for (i = 0; i < dma->num; i++) {
+		dma->vbuf[i] = kmalloc(dma->size, __GFP_REPEAT);
+		if (!dma->vbuf[i])
+			return -ENOMEM;
+		dma->pbuf[i] = dma_map_single(&pdev->dev, dma->vbuf[i],
+					      dma->size,
+					      dir ? DMA_TO_DEVICE :
+					      DMA_FROM_DEVICE);
+		if (dma_mapping_error(&pdev->dev, dma->pbuf[i])) {
+			kfree(dma->vbuf[i]);
+			return -ENOMEM;
 		}
 	}
+	return 0;
 }
+#else
 
-static void io_free(struct pci_dev *pdev, u8 **vbuf,
-		    dma_addr_t *pbuf, u32 size, int num)
+static void dma_free(struct pci_dev *pdev, struct ddb_dma *dma, int dir)
 {
 	int i;
 
-	for (i = 0; i < num; i++) {
-		if (vbuf[i]) {
-			pci_free_consistent(pdev, size, vbuf[i], pbuf[i]);
-			vbuf[i] = NULL;
+	if (!dma)
+		return;
+	for (i = 0; i < dma->num; i++) {
+		if (dma->vbuf[i]) {
+			dma_free_coherent(&pdev->dev, dma->size,
+					    dma->vbuf[i], dma->pbuf[i]);
+			dma->vbuf[i] = NULL;
 		}
 	}
 }
 
-static int io_alloc(struct pci_dev *pdev, u8 **vbuf,
-		    dma_addr_t *pbuf, u32 size, int num)
+static int dma_alloc(struct pci_dev *pdev, struct ddb_dma *dma, int dir)
 {
 	int i;
 
-	for (i = 0; i < num; i++) {
-		vbuf[i] = pci_alloc_consistent(pdev, size, &pbuf[i]);
-		if (!vbuf[i])
+	if (!dma)
+		return 0;
+	for (i = 0; i < dma->num; i++) {
+		dma->vbuf[i] = dma_alloc_coherent(&pdev->dev, dma->size,
+						  &dma->pbuf[i], GFP_KERNEL);
+		if (!dma->vbuf[i])
 			return -ENOMEM;
 	}
 	return 0;
 }
+#endif
 
 static int ddb_buffers_alloc(struct ddb *dev)
 {
 	int i;
 	struct ddb_port *port;
 
-	for (i = 0; i < dev->info->port_num; i++) {
+	for (i = 0; i < dev->link[0].info->port_num; i++) {
 		port = &dev->port[i];
 		switch (port->class) {
 		case DDB_PORT_TUNER:
-			if (io_alloc(dev->pdev, port->input[0]->vbuf,
-				     port->input[0]->pbuf,
-				     port->input[0]->dma_buf_size,
-				     port->input[0]->dma_buf_num) < 0)
-				return -1;
-			if (io_alloc(dev->pdev, port->input[1]->vbuf,
-				     port->input[1]->pbuf,
-				     port->input[1]->dma_buf_size,
-				     port->input[1]->dma_buf_num) < 0)
-				return -1;
+			if (port->input[0]->dma)
+				if (dma_alloc(dev->pdev, port->input[0]->dma, 0)
+					< 0)
+					return -1;
+			if (port->input[1]->dma)
+				if (dma_alloc(dev->pdev, port->input[1]->dma, 0)
+					< 0)
+					return -1;
 			break;
 		case DDB_PORT_CI:
-			if (io_alloc(dev->pdev, port->input[0]->vbuf,
-				     port->input[0]->pbuf,
-				     port->input[0]->dma_buf_size,
-				     port->input[0]->dma_buf_num) < 0)
-				return -1;
-			if (io_alloc(dev->pdev, port->output->vbuf,
-				     port->output->pbuf,
-				     port->output->dma_buf_size,
-				     port->output->dma_buf_num) < 0)
-				return -1;
+		case DDB_PORT_LOOP:
+			if (port->input[0]->dma)
+				if (dma_alloc(dev->pdev, port->input[0]->dma, 0)
+					< 0)
+					return -1;
+		case DDB_PORT_MOD:
+			if (port->output->dma)
+				if (dma_alloc(dev->pdev, port->output->dma, 1)
+					< 0)
+					return -1;
 			break;
 		default:
 			break;
 		}
 	}
-	ddb_address_table(dev);
+	ddb_set_dma_tables(dev);
 	return 0;
 }
 
@@ -329,111 +315,198 @@ static void ddb_buffers_free(struct ddb *dev)
 	int i;
 	struct ddb_port *port;
 
-	for (i = 0; i < dev->info->port_num; i++) {
+	for (i = 0; i < dev->link[0].info->port_num; i++) {
 		port = &dev->port[i];
-		io_free(dev->pdev, port->input[0]->vbuf,
-			port->input[0]->pbuf,
-			port->input[0]->dma_buf_size,
-			port->input[0]->dma_buf_num);
-		io_free(dev->pdev, port->input[1]->vbuf,
-			port->input[1]->pbuf,
-			port->input[1]->dma_buf_size,
-			port->input[1]->dma_buf_num);
-		io_free(dev->pdev, port->output->vbuf,
-			port->output->pbuf,
-			port->output->dma_buf_size,
-			port->output->dma_buf_num);
+
+		if (port->input[0] && port->input[0]->dma)
+			dma_free(dev->pdev, port->input[0]->dma, 0);
+		if (port->input[1] && port->input[1]->dma)
+			dma_free(dev->pdev, port->input[1]->dma, 0);
+		if (port->output && port->output->dma)
+			dma_free(dev->pdev, port->output->dma, 1);
 	}
 }
 
-static void ddb_input_start(struct ddb_input *input)
+static void ddb_output_start(struct ddb_output *output)
 {
-	struct ddb *dev = input->port->dev;
+	struct ddb *dev = output->port->dev;
+	u32 con2;
 
-	spin_lock_irq(&input->lock);
-	input->cbuf = 0;
-	input->coff = 0;
+	con2 = ((output->port->obr << 13) + 71999) / 72000;
+	con2 = (con2 << 16) | output->port->gap;
 
-	/* reset */
-	ddbwritel(0, TS_INPUT_CONTROL(input->nr));
-	ddbwritel(2, TS_INPUT_CONTROL(input->nr));
-	ddbwritel(0, TS_INPUT_CONTROL(input->nr));
+	if (output->dma) {
+		spin_lock_irq(&output->dma->lock);
+		output->dma->cbuf = 0;
+		output->dma->coff = 0;
+		output->dma->stat = 0;
+		ddbwritel(dev, 0, DMA_BUFFER_CONTROL(output->dma->nr));
+	}
+	if (output->port->class == DDB_PORT_MOD)
+		ddbridge_mod_output_start(output);
+	else {
+		ddbwritel(dev, 0, TS_OUTPUT_CONTROL(output->nr));
+		ddbwritel(dev, 2, TS_OUTPUT_CONTROL(output->nr));
+		ddbwritel(dev, 0, TS_OUTPUT_CONTROL(output->nr));
+		ddbwritel(dev, 0x3c, TS_OUTPUT_CONTROL(output->nr));
+		ddbwritel(dev, con2, TS_OUTPUT_CONTROL2(output->nr));
+	}
+	if (output->dma) {
+		ddbwritel(dev, output->dma->bufreg,
+			  DMA_BUFFER_SIZE(output->dma->nr));
+		ddbwritel(dev, 0, DMA_BUFFER_ACK(output->dma->nr));
+		ddbwritel(dev, 1, DMA_BASE_READ);
+		ddbwritel(dev, 3, DMA_BUFFER_CONTROL(output->dma->nr));
+	}
+	if (output->port->class != DDB_PORT_MOD) {
+		if (output->port->input[0]->port->class == DDB_PORT_LOOP)
+			ddbwritel(dev, (1 << 13) | 0x15,
+				  TS_OUTPUT_CONTROL(output->nr));
+		else
+			ddbwritel(dev, 0x11d, TS_OUTPUT_CONTROL(output->nr));
+	}
+	if (output->dma) {
+		output->dma->running = 1;
+		spin_unlock_irq(&output->dma->lock);
+	}
+}
 
-	ddbwritel((1 << 16) |
-		  (input->dma_buf_num << 11) |
-		  (input->dma_buf_size >> 7),
-		  DMA_BUFFER_SIZE(input->nr));
-	ddbwritel(0, DMA_BUFFER_ACK(input->nr));
+static void ddb_output_stop(struct ddb_output *output)
+{
+	struct ddb *dev = output->port->dev;
 
-	ddbwritel(1, DMA_BASE_WRITE);
-	ddbwritel(3, DMA_BUFFER_CONTROL(input->nr));
-	ddbwritel(9, TS_INPUT_CONTROL(input->nr));
-	input->running = 1;
-	spin_unlock_irq(&input->lock);
+	if (output->dma)
+		spin_lock_irq(&output->dma->lock);
+	if (output->port->class == DDB_PORT_MOD)
+		ddbridge_mod_output_stop(output);
+	else
+		ddbwritel(dev, 0, TS_OUTPUT_CONTROL(output->nr));
+	if (output->dma) {
+		ddbwritel(dev, 0, DMA_BUFFER_CONTROL(output->dma->nr));
+		output->dma->running = 0;
+		spin_unlock_irq(&output->dma->lock);
+	}
 }
 
 static void ddb_input_stop(struct ddb_input *input)
 {
 	struct ddb *dev = input->port->dev;
+	u32 tag = DDB_LINK_TAG(input->port->lnr);
+
+	if (input->dma)
+		spin_lock_irq(&input->dma->lock);
+	ddbwritel(dev, 0, tag | TS_INPUT_CONTROL(input->nr));
+	if (input->dma) {
+		ddbwritel(dev, 0, DMA_BUFFER_CONTROL(input->dma->nr));
+		input->dma->running = 0;
+		spin_unlock_irq(&input->dma->lock);
+	}
+}
+
+static void ddb_input_start(struct ddb_input *input)
+{
+	struct ddb *dev = input->port->dev;
+	/* u32 tsbase = TS_INPUT_BASE + input->nr * 0x10; */
+	u32 tag = DDB_LINK_TAG(input->port->lnr);
+
+	if (input->dma) {
+		spin_lock_irq(&input->dma->lock);
+		input->dma->cbuf = 0;
+		input->dma->coff = 0;
+		input->dma->stat = 0;
+		ddbwritel(dev, 0, DMA_BUFFER_CONTROL(input->dma->nr));
+	}
+	ddbwritel(dev, 0, tag | TS_INPUT_CONTROL2(input->nr));
+	ddbwritel(dev, 0, tag | TS_INPUT_CONTROL(input->nr));
+	ddbwritel(dev, 2, tag | TS_INPUT_CONTROL(input->nr));
+	ddbwritel(dev, 0, tag | TS_INPUT_CONTROL(input->nr));
+
+	if (input->dma) {
+		ddbwritel(dev, input->dma->bufreg,
+			  DMA_BUFFER_SIZE(input->dma->nr));
+		ddbwritel(dev, 0, DMA_BUFFER_ACK(input->dma->nr));
+		ddbwritel(dev, 1, DMA_BASE_WRITE);
+		ddbwritel(dev, 3, DMA_BUFFER_CONTROL(input->dma->nr));
+	}
+	if (dev->link[0].info->type == DDB_OCTONET)
+		ddbwritel(dev, 0x01, tag | TS_INPUT_CONTROL(input->nr));
+	else
+		ddbwritel(dev, 0x09, tag | TS_INPUT_CONTROL(input->nr));
+	if (input->dma) {
+		input->dma->running = 1;
+		spin_unlock_irq(&input->dma->lock);
+	}
+}
 
-	spin_lock_irq(&input->lock);
-	ddbwritel(0, TS_INPUT_CONTROL(input->nr));
-	ddbwritel(0, DMA_BUFFER_CONTROL(input->nr));
-	input->running = 0;
-	spin_unlock_irq(&input->lock);
+
+static int ddb_dvb_ns_input_start(struct ddb_input *input)
+{
+	struct ddb_dvb *dvb = &input->port->dvb[input->nr & 1];
+
+	if (!dvb->users)
+		ddb_input_start(input);
+
+	return ++dvb->users;
 }
 
-static void ddb_output_start(struct ddb_output *output)
+static int ddb_dvb_ns_input_stop(struct ddb_input *input)
 {
-	struct ddb *dev = output->port->dev;
+	struct ddb_dvb *dvb = &input->port->dvb[input->nr & 1];
+
+	if (--dvb->users)
+		return dvb->users;
 
-	spin_lock_irq(&output->lock);
-	output->cbuf = 0;
-	output->coff = 0;
-	ddbwritel(0, TS_OUTPUT_CONTROL(output->nr));
-	ddbwritel(2, TS_OUTPUT_CONTROL(output->nr));
-	ddbwritel(0, TS_OUTPUT_CONTROL(output->nr));
-	ddbwritel(0x3c, TS_OUTPUT_CONTROL(output->nr));
-	ddbwritel((1 << 16) |
-		  (output->dma_buf_num << 11) |
-		  (output->dma_buf_size >> 7),
-		  DMA_BUFFER_SIZE(output->nr + 8));
-	ddbwritel(0, DMA_BUFFER_ACK(output->nr + 8));
-
-	ddbwritel(1, DMA_BASE_READ);
-	ddbwritel(3, DMA_BUFFER_CONTROL(output->nr + 8));
-	/* ddbwritel(0xbd, TS_OUTPUT_CONTROL(output->nr)); */
-	ddbwritel(0x1d, TS_OUTPUT_CONTROL(output->nr));
-	output->running = 1;
-	spin_unlock_irq(&output->lock);
+	ddb_input_stop(input);
+	return 0;
 }
 
-static void ddb_output_stop(struct ddb_output *output)
+static void ddb_input_start_all(struct ddb_input *input)
 {
-	struct ddb *dev = output->port->dev;
+	struct ddb_input *i = input;
+	struct ddb_output *o;
+
+	mutex_lock(&redirect_lock);
+	while (i && (o = i->redo)) {
+		ddb_output_start(o);
+		i = o->port->input[0];
+		if (i)
+			ddb_input_start(i);
+	}
+	ddb_input_start(input);
+	mutex_unlock(&redirect_lock);
+}
+
+static void ddb_input_stop_all(struct ddb_input *input)
+{
+	struct ddb_input *i = input;
+	struct ddb_output *o;
 
-	spin_lock_irq(&output->lock);
-	ddbwritel(0, TS_OUTPUT_CONTROL(output->nr));
-	ddbwritel(0, DMA_BUFFER_CONTROL(output->nr + 8));
-	output->running = 0;
-	spin_unlock_irq(&output->lock);
+	mutex_lock(&redirect_lock);
+	ddb_input_stop(input);
+	while (i && (o = i->redo)) {
+		ddb_output_stop(o);
+		i = o->port->input[0];
+		if (i)
+			ddb_input_stop(i);
+	}
+	mutex_unlock(&redirect_lock);
 }
 
 static u32 ddb_output_free(struct ddb_output *output)
 {
-	u32 idx, off, stat = output->stat;
+	u32 idx, off, stat = output->dma->stat;
 	s32 diff;
 
 	idx = (stat >> 11) & 0x1f;
 	off = (stat & 0x7ff) << 7;
 
-	if (output->cbuf != idx) {
-		if ((((output->cbuf + 1) % output->dma_buf_num) == idx) &&
-		    (output->dma_buf_size - output->coff <= 188))
+	if (output->dma->cbuf != idx) {
+		if ((((output->dma->cbuf + 1) % output->dma->num) == idx) &&
+		    (output->dma->size - output->dma->coff <= 188))
 			return 0;
 		return 188;
 	}
-	diff = off - output->coff;
+	diff = off - output->dma->coff;
 	if (diff <= 0 || diff > 188)
 		return 188;
 	return 0;
@@ -443,46 +516,53 @@ static ssize_t ddb_output_write(struct ddb_output *output,
 				const __user u8 *buf, size_t count)
 {
 	struct ddb *dev = output->port->dev;
-	u32 idx, off, stat = output->stat;
+	u32 idx, off, stat = output->dma->stat;
 	u32 left = count, len;
 
 	idx = (stat >> 11) & 0x1f;
 	off = (stat & 0x7ff) << 7;
 
 	while (left) {
-		len = output->dma_buf_size - output->coff;
-		if ((((output->cbuf + 1) % output->dma_buf_num) == idx) &&
+		len = output->dma->size - output->dma->coff;
+		if ((((output->dma->cbuf + 1) % output->dma->num) == idx) &&
 		    (off == 0)) {
 			if (len <= 188)
 				break;
 			len -= 188;
 		}
-		if (output->cbuf == idx) {
-			if (off > output->coff) {
-#if 1
-				len = off - output->coff;
+		if (output->dma->cbuf == idx) {
+			if (off > output->dma->coff) {
+				len = off - output->dma->coff;
 				len -= (len % 188);
 				if (len <= 188)
-
-#endif
 					break;
 				len -= 188;
 			}
 		}
 		if (len > left)
 			len = left;
-		if (copy_from_user(output->vbuf[output->cbuf] + output->coff,
+		if (copy_from_user(output->dma->vbuf[output->dma->cbuf] +
+				   output->dma->coff,
 				   buf, len))
 			return -EIO;
+#ifdef DDB_ALT_DMA
+		dma_sync_single_for_device(dev->dev,
+					   output->dma->pbuf[
+						   output->dma->cbuf],
+					   output->dma->size, DMA_TO_DEVICE);
+#endif
 		left -= len;
 		buf += len;
-		output->coff += len;
-		if (output->coff == output->dma_buf_size) {
-			output->coff = 0;
-			output->cbuf = ((output->cbuf + 1) % output->dma_buf_num);
+		output->dma->coff += len;
+		if (output->dma->coff == output->dma->size) {
+			output->dma->coff = 0;
+			output->dma->cbuf = ((output->dma->cbuf + 1) %
+					     output->dma->num);
 		}
-		ddbwritel((output->cbuf << 11) | (output->coff >> 7),
-			  DMA_BUFFER_ACK(output->nr + 8));
+		ddbwritel(dev,
+			  (output->dma->cbuf << 11) |
+			  (output->dma->coff >> 7),
+			  DMA_BUFFER_ACK(output->dma->nr));
 	}
 	return count - left;
 }
@@ -490,81 +570,276 @@ static ssize_t ddb_output_write(struct ddb_output *output,
 static u32 ddb_input_avail(struct ddb_input *input)
 {
 	struct ddb *dev = input->port->dev;
-	u32 idx, off, stat = input->stat;
-	u32 ctrl = ddbreadl(DMA_BUFFER_CONTROL(input->nr));
+	u32 idx, off, stat = input->dma->stat;
+	u32 ctrl = ddbreadl(dev, DMA_BUFFER_CONTROL(input->dma->nr));
 
 	idx = (stat >> 11) & 0x1f;
 	off = (stat & 0x7ff) << 7;
 
 	if (ctrl & 4) {
-		printk(KERN_ERR "IA %d %d %08x\n", idx, off, ctrl);
-		ddbwritel(input->stat, DMA_BUFFER_ACK(input->nr));
+		pr_err("IA %d %d %08x\n", idx, off, ctrl);
+		ddbwritel(dev, stat, DMA_BUFFER_ACK(input->dma->nr));
 		return 0;
 	}
-	if (input->cbuf != idx)
+	if (input->dma->cbuf != idx)
 		return 188;
 	return 0;
 }
 
-static ssize_t ddb_input_read(struct ddb_input *input, __user u8 *buf, size_t count)
+static size_t ddb_input_read(struct ddb_input *input,
+		__user u8 *buf, size_t count)
 {
 	struct ddb *dev = input->port->dev;
 	u32 left = count;
-	u32 idx, free, stat = input->stat;
+	u32 idx, off, free, stat = input->dma->stat;
 	int ret;
 
 	idx = (stat >> 11) & 0x1f;
+	off = (stat & 0x7ff) << 7;
 
 	while (left) {
-		if (input->cbuf == idx)
+		if (input->dma->cbuf == idx)
 			return count - left;
-		free = input->dma_buf_size - input->coff;
+		free = input->dma->size - input->dma->coff;
 		if (free > left)
 			free = left;
-		ret = copy_to_user(buf, input->vbuf[input->cbuf] +
-				   input->coff, free);
+#ifdef DDB_ALT_DMA
+		dma_sync_single_for_cpu(dev->dev,
+					input->dma->pbuf[input->dma->cbuf],
+					input->dma->size, DMA_FROM_DEVICE);
+#endif
+		ret = copy_to_user(buf, input->dma->vbuf[input->dma->cbuf] +
+				   input->dma->coff, free);
 		if (ret)
 			return -EFAULT;
-		input->coff += free;
-		if (input->coff == input->dma_buf_size) {
-			input->coff = 0;
-			input->cbuf = (input->cbuf+1) % input->dma_buf_num;
+		input->dma->coff += free;
+		if (input->dma->coff == input->dma->size) {
+			input->dma->coff = 0;
+			input->dma->cbuf = (input->dma->cbuf + 1) %
+				input->dma->num;
 		}
 		left -= free;
-		ddbwritel((input->cbuf << 11) | (input->coff >> 7),
-			  DMA_BUFFER_ACK(input->nr));
+		ddbwritel(dev,
+			  (input->dma->cbuf << 11) | (input->dma->coff >> 7),
+			  DMA_BUFFER_ACK(input->dma->nr));
 	}
 	return count;
 }
 
-/******************************************************************************/
-/******************************************************************************/
-/******************************************************************************/
+/****************************************************************************/
+/****************************************************************************/
+
+static ssize_t ts_write(struct file *file, const __user char *buf,
+			size_t count, loff_t *ppos)
+{
+	struct dvb_device *dvbdev = file->private_data;
+	struct ddb_output *output = dvbdev->priv;
+	struct ddb *dev = output->port->dev;
+	size_t left = count;
+	int stat;
+
+	if (!dev->has_dma)
+		return -EINVAL;
+	while (left) {
+		if (ddb_output_free(output) < 188) {
+			if (file->f_flags & O_NONBLOCK)
+				break;
+			if (wait_event_interruptible(
+				    output->dma->wq,
+				    ddb_output_free(output) >= 188) < 0)
+				break;
+		}
+		stat = ddb_output_write(output, buf, left);
+		if (stat < 0)
+			return stat;
+		buf += stat;
+		left -= stat;
+	}
+	return (left == count) ? -EAGAIN : (count - left);
+}
+
+static ssize_t ts_read(struct file *file, __user char *buf,
+		       size_t count, loff_t *ppos)
+{
+	struct dvb_device *dvbdev = file->private_data;
+	struct ddb_output *output = dvbdev->priv;
+	struct ddb_input *input = output->port->input[0];
+	struct ddb *dev = output->port->dev;
+	size_t left = count;
+	int stat;
+
+	if (!dev->has_dma)
+		return -EINVAL;
+	while (left) {
+		if (ddb_input_avail(input) < 188) {
+			if (file->f_flags & O_NONBLOCK)
+				break;
+			if (wait_event_interruptible(
+				    input->dma->wq,
+				    ddb_input_avail(input) >= 188) < 0)
+				break;
+		}
+		stat = ddb_input_read(input, buf, left);
+		if (stat < 0)
+			return stat;
+		left -= stat;
+		buf += stat;
+	}
+	return (count && (left == count)) ? -EAGAIN : (count - left);
+}
+
+static unsigned int ts_poll(struct file *file, poll_table *wait)
+{
+	struct dvb_device *dvbdev = file->private_data;
+	struct ddb_output *output = dvbdev->priv;
+	struct ddb_input *input = output->port->input[0];
+
+	unsigned int mask = 0;
+
+	poll_wait(file, &input->dma->wq, wait);
+	poll_wait(file, &output->dma->wq, wait);
+	if (ddb_input_avail(input) >= 188)
+		mask |= POLLIN | POLLRDNORM;
+	if (ddb_output_free(output) >= 188)
+		mask |= POLLOUT | POLLWRNORM;
+	return mask;
+}
 
-#if 0
-static struct ddb_input *fe2input(struct ddb *dev, struct dvb_frontend *fe)
+static int ts_release(struct inode *inode, struct file *file)
 {
-	int i;
+	struct dvb_device *dvbdev = file->private_data;
+	struct ddb_output *output = dvbdev->priv;
+	struct ddb_input *input = output->port->input[0];
 
-	for (i = 0; i < dev->info->port_num * 2; i++) {
-		if (dev->input[i].fe == fe)
-			return &dev->input[i];
+	if ((file->f_flags & O_ACCMODE) == O_RDONLY) {
+		if (!input)
+			return -EINVAL;
+		ddb_input_stop(input);
+	} else if ((file->f_flags & O_ACCMODE) == O_WRONLY) {
+		if (!output)
+			return -EINVAL;
+		ddb_output_stop(output);
 	}
-	return NULL;
+	return dvb_generic_release(inode, file);
 }
-#endif
 
-static int drxk_gate_ctrl(struct dvb_frontend *fe, int enable)
+static int ts_open(struct inode *inode, struct file *file)
+{
+	int err;
+	struct dvb_device *dvbdev = file->private_data;
+	struct ddb_output *output = dvbdev->priv;
+	struct ddb_input *input = output->port->input[0];
+
+	if ((file->f_flags & O_ACCMODE) == O_RDONLY) {
+		if (!input)
+			return -EINVAL;
+		if (input->redo || input->redi)
+			return -EBUSY;
+	} else if ((file->f_flags & O_ACCMODE) == O_WRONLY) {
+		if (!output)
+			return -EINVAL;
+	} else
+		return -EINVAL;
+	err = dvb_generic_open(inode, file);
+	if (err < 0)
+		return err;
+	if ((file->f_flags & O_ACCMODE) == O_RDONLY)
+		ddb_input_start(input);
+	else if ((file->f_flags & O_ACCMODE) == O_WRONLY)
+		ddb_output_start(output);
+	return err;
+}
+
+static int mod_release(struct inode *inode, struct file *file)
+{
+	struct dvb_device *dvbdev = file->private_data;
+	struct ddb_output *output = dvbdev->priv;
+
+	if ((file->f_flags & O_ACCMODE) == O_WRONLY) {
+		if (!output)
+			return -EINVAL;
+		ddb_output_stop(output);
+	}
+	return dvb_generic_release(inode, file);
+}
+
+static int mod_open(struct inode *inode, struct file *file)
+{
+	int err;
+	struct dvb_device *dvbdev = file->private_data;
+	struct ddb_output *output = dvbdev->priv;
+
+	if ((file->f_flags & O_ACCMODE) == O_WRONLY) {
+		if (!output)
+			return -EINVAL;
+	}
+	err = dvb_generic_open(inode, file);
+	if (err < 0)
+		return err;
+	if ((file->f_flags & O_ACCMODE) == O_WRONLY)
+		ddb_output_start(output);
+	return err;
+}
+static const struct file_operations ci_fops = {
+	.owner   = THIS_MODULE,
+	.read    = ts_read,
+	.write   = ts_write,
+	.open    = ts_open,
+	.release = ts_release,
+	.poll    = ts_poll,
+	.mmap    = 0,
+};
+
+static struct dvb_device dvbdev_ci = {
+	.priv    = 0,
+	.readers = 1,
+	.writers = 1,
+	.users   = 2,
+	.fops    = &ci_fops,
+};
+
+
+/****************************************************************************/
+/****************************************************************************/
+
+static long mod_ioctl(struct file *file,
+		      unsigned int cmd, unsigned long arg)
+{
+	return dvb_usercopy(file, cmd, arg, ddbridge_mod_do_ioctl);
+}
+
+static const struct file_operations mod_fops = {
+	.owner   = THIS_MODULE,
+	.read    = ts_read,
+	.write   = ts_write,
+	.open    = mod_open,
+	.release = mod_release,
+	.poll    = ts_poll,
+	.mmap    = 0,
+	.unlocked_ioctl = mod_ioctl,
+};
+
+static struct dvb_device dvbdev_mod = {
+	.priv    = 0,
+	.readers = 1,
+	.writers = 1,
+	.users   = 2,
+	.fops    = &mod_fops,
+};
+
+
+static int locked_gate_ctrl(struct dvb_frontend *fe, int enable)
 {
 	struct ddb_input *input = fe->sec_priv;
 	struct ddb_port *port = input->port;
+	struct ddb_dvb *dvb = &port->dvb[input->nr & 1];
 	int status;
 
 	if (enable) {
 		mutex_lock(&port->i2c_gate_lock);
-		status = input->gate_ctrl(fe, 1);
+		status = dvb->i2c_gate_ctrl(fe, 1);
 	} else {
-		status = input->gate_ctrl(fe, 0);
+		status = dvb->i2c_gate_ctrl(fe, 0);
 		mutex_unlock(&port->i2c_gate_lock);
 	}
 	return status;
@@ -573,45 +848,158 @@ static int drxk_gate_ctrl(struct dvb_frontend *fe, int enable)
 static int demod_attach_drxk(struct ddb_input *input)
 {
 	struct i2c_adapter *i2c = &input->port->i2c->adap;
+	struct ddb_dvb *dvb = &input->port->dvb[input->nr & 1];
 	struct dvb_frontend *fe;
 	struct drxk_config config;
 
 	memset(&config, 0, sizeof(config));
-	config.microcode_name = "drxk_a3.mc";
-	config.qam_demod_parameter_count = 4;
 	config.adr = 0x29 + (input->nr & 1);
+	config.microcode_name = "drxk_a3.mc";
 
-	fe = input->fe = dvb_attach(drxk_attach, &config, i2c);
-	if (!input->fe) {
-		printk(KERN_ERR "No DRXK found!\n");
+	fe = dvb->fe = dvb_attach(drxk_attach, &config, i2c);
+	if (!fe) {
+		pr_err("No DRXK found!\n");
 		return -ENODEV;
 	}
 	fe->sec_priv = input;
-	input->gate_ctrl = fe->ops.i2c_gate_ctrl;
-	fe->ops.i2c_gate_ctrl = drxk_gate_ctrl;
+	dvb->i2c_gate_ctrl = fe->ops.i2c_gate_ctrl;
+	fe->ops.i2c_gate_ctrl = locked_gate_ctrl;
 	return 0;
 }
 
-static int tuner_attach_tda18271(struct ddb_input *input)
-{
-	struct i2c_adapter *i2c = &input->port->i2c->adap;
-	struct dvb_frontend *fe;
+struct cxd2843_cfg cxd2843_0 = {
+	.adr = 0x6c,
+	.ts_clock = 1,
+};
 
-	if (input->fe->ops.i2c_gate_ctrl)
-		input->fe->ops.i2c_gate_ctrl(input->fe, 1);
-	fe = dvb_attach(tda18271c2dd_attach, input->fe, i2c, 0x60);
+struct cxd2843_cfg cxd2843_1 = {
+	.adr = 0x6d,
+	.ts_clock = 1,
+};
+
+struct cxd2843_cfg cxd2843p_0 = {
+	.adr = 0x6c,
+	.parallel = 1,
+};
+
+struct cxd2843_cfg cxd2843p_1 = {
+	.adr = 0x6d,
+	.parallel = 1,
+};
+
+static int demod_attach_cxd2843(struct ddb_input *input, int par)
+{
+	struct i2c_adapter *i2c = &input->port->i2c->adap;
+	struct ddb_dvb *dvb = &input->port->dvb[input->nr & 1];
+	struct dvb_frontend *fe;
+
+	if (par)
+		fe = dvb->fe = dvb_attach(cxd2843_attach, i2c,
+					  (input->nr & 1) ?
+					  &cxd2843p_1 : &cxd2843p_0);
+	else
+		fe = dvb->fe = dvb_attach(cxd2843_attach, i2c,
+					  (input->nr & 1) ?
+					  &cxd2843_1 : &cxd2843_0);
+	if (!dvb->fe) {
+		pr_err("No cxd2837/38/43 found!\n");
+		return -ENODEV;
+	}
+	fe->sec_priv = input;
+	dvb->i2c_gate_ctrl = fe->ops.i2c_gate_ctrl;
+	fe->ops.i2c_gate_ctrl = locked_gate_ctrl;
+	return 0;
+}
+
+static int demod_attach_stv0367dd(struct ddb_input *input)
+{
+	struct i2c_adapter *i2c = &input->port->i2c->adap;
+	struct ddb_dvb *dvb = &input->port->dvb[input->nr & 1];
+	struct dvb_frontend *fe;
+	struct stv0367dd_cfg cfg = { .cont_clock = 0 };
+
+	cfg.adr = 0x1f - (input->nr & 1);
+	if (input->port->dev->link[input->port->lnr].info->con_clock)
+		cfg.cont_clock = 1;
+	fe = dvb->fe = dvb_attach(stv0367dd_attach, i2c,
+				  &cfg,
+				  &dvb->fe2);
+	if (!dvb->fe) {
+		pr_err("No stv0367 found!\n");
+		return -ENODEV;
+	}
+	fe->sec_priv = input;
+	dvb->i2c_gate_ctrl = fe->ops.i2c_gate_ctrl;
+	fe->ops.i2c_gate_ctrl = locked_gate_ctrl;
+	return 0;
+}
+
+static int tuner_attach_tda18271(struct ddb_input *input)
+{
+	struct i2c_adapter *i2c = &input->port->i2c->adap;
+	struct ddb_dvb *dvb = &input->port->dvb[input->nr & 1];
+	struct dvb_frontend *fe;
+
+	if (dvb->fe->ops.i2c_gate_ctrl)
+		dvb->fe->ops.i2c_gate_ctrl(dvb->fe, 1);
+	fe = dvb_attach(tda18271c2dd_attach, dvb->fe, i2c, 0x60);
+	if (dvb->fe->ops.i2c_gate_ctrl)
+		dvb->fe->ops.i2c_gate_ctrl(dvb->fe, 0);
 	if (!fe) {
-		printk(KERN_ERR "No TDA18271 found!\n");
+		pr_err("No TDA18271 found!\n");
 		return -ENODEV;
 	}
-	if (input->fe->ops.i2c_gate_ctrl)
-		input->fe->ops.i2c_gate_ctrl(input->fe, 0);
 	return 0;
 }
 
-/******************************************************************************/
-/******************************************************************************/
-/******************************************************************************/
+static int tuner_attach_tda18212(struct ddb_input *input)
+{
+	struct i2c_adapter *adapter = &input->port->i2c->adap;
+	struct ddb_dvb *dvb = &input->port->dvb[input->nr & 1];
+	struct i2c_client *client;
+	struct tda18212_config config = {
+		.fe = dvb->fe,
+		.if_dvbt_6 = 3550,
+		.if_dvbt_7 = 3700,
+		.if_dvbt_8 = 4150,
+		.if_dvbt2_6 = 3250,
+		.if_dvbt2_7 = 4000,
+		.if_dvbt2_8 = 4000,
+		.if_dvbc = 5000,
+		.init_flags = TDA18212_INIT_RETRY,
+	};
+	struct i2c_board_info board_info = {
+		.type = "tda18212",
+		.platform_data = &config,
+	};
+
+	if (input->nr & 1)
+		board_info.addr = 0x63;
+	else
+		board_info.addr = 0x60;
+
+	request_module(board_info.type);
+
+	client = i2c_new_device(adapter, &board_info);
+	if (client == NULL || client->dev.driver == NULL)
+		goto err;
+
+	if (!try_module_get(client->dev.driver->owner)) {
+		i2c_unregister_device(client);
+		goto err;
+	}
+
+	dvb->i2c_client[0] = client;
+
+	return 0;
+err:
+	dev_notice(input->port->dev->dev, "TDA18212 tuner not found. Device is not fully operational.\n");
+	return -ENODEV;
+}
+
+/****************************************************************************/
+/****************************************************************************/
+/****************************************************************************/
 
 static struct stv090x_config stv0900 = {
 	.device         = STV0900,
@@ -624,6 +1012,9 @@ static struct stv090x_config stv0900 = {
 	.ts1_mode       = STV090x_TSMODE_SERIAL_PUNCTURED,
 	.ts2_mode       = STV090x_TSMODE_SERIAL_PUNCTURED,
 
+	.ts1_tei        = 1,
+	.ts2_tei        = 1,
+
 	.repeater_level = STV090x_RPTLEVEL_16,
 
 	.adc1_range	= STV090x_ADC_1Vpp,
@@ -643,6 +1034,9 @@ static struct stv090x_config stv0900_aa = {
 	.ts1_mode       = STV090x_TSMODE_SERIAL_PUNCTURED,
 	.ts2_mode       = STV090x_TSMODE_SERIAL_PUNCTURED,
 
+	.ts1_tei        = 1,
+	.ts2_tei        = 1,
+
 	.repeater_level = STV090x_RPTLEVEL_16,
 
 	.adc1_range	= STV090x_ADC_1Vpp,
@@ -667,18 +1061,19 @@ static int demod_attach_stv0900(struct ddb_input *input, int type)
 {
 	struct i2c_adapter *i2c = &input->port->i2c->adap;
 	struct stv090x_config *feconf = type ? &stv0900_aa : &stv0900;
+	struct ddb_dvb *dvb = &input->port->dvb[input->nr & 1];
 
-	input->fe = dvb_attach(stv090x_attach, feconf, i2c,
-			       (input->nr & 1) ? STV090x_DEMODULATOR_1
-			       : STV090x_DEMODULATOR_0);
-	if (!input->fe) {
-		printk(KERN_ERR "No STV0900 found!\n");
+	dvb->fe = dvb_attach(stv090x_attach, feconf, i2c,
+			     (input->nr & 1) ? STV090x_DEMODULATOR_1
+			     : STV090x_DEMODULATOR_0);
+	if (!dvb->fe) {
+		pr_err("No STV0900 found!\n");
 		return -ENODEV;
 	}
-	if (!dvb_attach(lnbh24_attach, input->fe, i2c, 0,
+	if (!dvb_attach(lnbh24_attach, dvb->fe, i2c, 0,
 			0, (input->nr & 1) ?
 			(0x09 - type) : (0x0b - type))) {
-		printk(KERN_ERR "No LNBH24 found!\n");
+		pr_err("No LNBH24 found!\n");
 		return -ENODEV;
 	}
 	return 0;
@@ -687,18 +1082,19 @@ static int demod_attach_stv0900(struct ddb_input *input, int type)
 static int tuner_attach_stv6110(struct ddb_input *input, int type)
 {
 	struct i2c_adapter *i2c = &input->port->i2c->adap;
+	struct ddb_dvb *dvb = &input->port->dvb[input->nr & 1];
 	struct stv090x_config *feconf = type ? &stv0900_aa : &stv0900;
 	struct stv6110x_config *tunerconf = (input->nr & 1) ?
 		&stv6110b : &stv6110a;
 	const struct stv6110x_devctl *ctl;
 
-	ctl = dvb_attach(stv6110x_attach, input->fe, tunerconf, i2c);
+	ctl = dvb_attach(stv6110x_attach, dvb->fe, tunerconf, i2c);
 	if (!ctl) {
-		printk(KERN_ERR "No STV6110X found!\n");
+		pr_err("No STV6110X found!\n");
 		return -ENODEV;
 	}
-	printk(KERN_INFO "attach tuner input %d adr %02x\n",
-			 input->nr, tunerconf->addr);
+	pr_info("attach tuner input %d adr %02x\n",
+		input->nr, tunerconf->addr);
 
 	feconf->tuner_init          = ctl->tuner_init;
 	feconf->tuner_sleep         = ctl->tuner_sleep;
@@ -715,10 +1111,431 @@ static int tuner_attach_stv6110(struct ddb_input *input, int type)
 	return 0;
 }
 
+static struct stv0910_cfg stv0910_p = {
+	.adr      = 0x68,
+	.parallel = 1,
+	.rptlvl   = 4,
+	.clk      = 30000000,
+};
+
+static struct lnbh25_config lnbh25_conf_0_0 = {
+	.i2c_address = 0x0c << 1,
+	.data2_config = LNBH25_TEN | LNBH25_EXTM
+};
+
+static struct lnbh25_config lnbh25_conf_0_1 = {
+	.i2c_address = 0x0d << 1,
+	.data2_config = LNBH25_TEN | LNBH25_EXTM
+};
+
+static struct lnbh25_config lnbh25_conf_1_0 = {
+	.i2c_address = 0x08 << 1,
+	.data2_config = LNBH25_TEN | LNBH25_EXTM
+};
+
+static struct lnbh25_config lnbh25_conf_1_1 = {
+	.i2c_address = 0x09 << 1,
+	.data2_config = LNBH25_TEN | LNBH25_EXTM
+};
+
+
+static int demod_attach_stv0910(struct ddb_input *input, int type)
+{
+	struct i2c_adapter *i2c = &input->port->i2c->adap;
+	struct ddb_dvb *dvb = &input->port->dvb[input->nr & 1];
+	struct stv0910_cfg cfg = stv0910_p;
+
+	if (type)
+		cfg.parallel = 2;
+	dvb->fe = dvb_attach(stv0910_attach, i2c, &cfg, (input->nr & 1));
+	if (!dvb->fe) {
+		cfg.adr = 0x6c;
+		dvb->fe = dvb_attach(stv0910_attach, i2c,
+				     &cfg, (input->nr & 1));
+	}
+	if (!dvb->fe) {
+		pr_err("No STV0910 found!\n");
+		return -ENODEV;
+	}
+
+	if (!dvb_attach(lnbh25_attach, dvb->fe,
+		((input->nr & 1) ? &lnbh25_conf_0_1 : &lnbh25_conf_0_0),
+		i2c)) {
+		if (!dvb_attach(lnbh25_attach, dvb->fe,
+			((input->nr & 1) ? &lnbh25_conf_1_1 : &lnbh25_conf_1_0),
+			i2c)) {
+			pr_err("No LNBH25 found!\n");
+			return -ENODEV;
+		}
+	}
+
+	return 0;
+}
+
+static int tuner_attach_stv6111(struct ddb_input *input, int type)
+{
+	struct i2c_adapter *i2c = &input->port->i2c->adap;
+	struct ddb_dvb *dvb = &input->port->dvb[input->nr & 1];
+	struct dvb_frontend *fe;
+	u8 adr = (type ? 0 : 4) + ((input->nr & 1) ? 0x63 : 0x60);
+
+	fe = dvb_attach(stv6111_attach, dvb->fe, i2c, adr);
+	if (!fe) {
+		fe = dvb_attach(stv6111_attach, dvb->fe, i2c, adr & ~4);
+		if (!fe) {
+			pr_err("No STV6111 found at 0x%02x!\n", adr);
+			return -ENODEV;
+		}
+	}
+	return 0;
+}
+
+static int lnb_command(struct ddb *dev, u32 link, u32 lnb, u32 cmd)
+{
+	u32 c, v = 0, tag = DDB_LINK_TAG(link);
+
+	v = LNB_TONE & (dev->link[link].lnb.tone << (15 - lnb));
+	ddbwritel(dev, cmd | v, tag | LNB_CONTROL(lnb));
+	for (c = 0; c < 10; c++) {
+		v = ddbreadl(dev, tag | LNB_CONTROL(lnb));
+		if ((v & LNB_BUSY) == 0)
+			break;
+		msleep(20);
+	}
+	if (c == 10)
+		pr_info("lnb_command lnb = %08x  cmd = %08x\n", lnb, cmd);
+	return 0;
+}
+
+static int max_send_master_cmd(struct dvb_frontend *fe,
+			       struct dvb_diseqc_master_cmd *cmd)
+{
+	struct ddb_input *input = fe->sec_priv;
+	struct ddb_port *port = input->port;
+	struct ddb *dev = port->dev;
+	struct ddb_dvb *dvb = &port->dvb[input->nr & 1];
+	u32 tag = DDB_LINK_TAG(port->lnr);
+	int i;
+	u32 fmode = dev->link[port->lnr].lnb.fmode;
+
+	if (fmode == 2 || fmode == 1)
+		return 0;
+	if (dvb->diseqc_send_master_cmd)
+		dvb->diseqc_send_master_cmd(fe, cmd);
+
+	mutex_lock(&dev->link[port->lnr].lnb.lock);
+	ddbwritel(dev, 0, tag | LNB_BUF_LEVEL(dvb->input));
+	for (i = 0; i < cmd->msg_len; i++)
+		ddbwritel(dev, cmd->msg[i], tag | LNB_BUF_WRITE(dvb->input));
+	lnb_command(dev, port->lnr, dvb->input, LNB_CMD_DISEQC);
+	mutex_unlock(&dev->link[port->lnr].lnb.lock);
+	return 0;
+}
+
+static int lnb_set_tone(struct ddb *dev, u32 link, u32 input,
+	enum fe_sec_tone_mode tone)
+{
+	int s = 0;
+	u32 mask = (1ULL << input);
+
+	switch (tone) {
+	case SEC_TONE_OFF:
+		if (!(dev->link[link].lnb.tone & mask))
+			return 0;
+		dev->link[link].lnb.tone &= ~(1ULL << input);
+		break;
+	case SEC_TONE_ON:
+		if (dev->link[link].lnb.tone & mask)
+			return 0;
+		dev->link[link].lnb.tone |= (1ULL << input);
+		break;
+	default:
+		s = -EINVAL;
+		break;
+	};
+	if (!s)
+		s = lnb_command(dev, link, input, LNB_CMD_NOP);
+	return s;
+}
+
+static int lnb_set_voltage(struct ddb *dev, u32 link, u32 input,
+	enum fe_sec_voltage voltage)
+{
+	int s = 0;
+
+	if (dev->link[link].lnb.oldvoltage[input] == voltage)
+		return 0;
+	switch (voltage) {
+	case SEC_VOLTAGE_OFF:
+		if (dev->link[link].lnb.voltage[input])
+			return 0;
+		lnb_command(dev, link, input, LNB_CMD_OFF);
+		break;
+	case SEC_VOLTAGE_13:
+		lnb_command(dev, link, input, LNB_CMD_LOW);
+		break;
+	case SEC_VOLTAGE_18:
+		lnb_command(dev, link, input, LNB_CMD_HIGH);
+		break;
+	default:
+		s = -EINVAL;
+		break;
+	};
+	dev->link[link].lnb.oldvoltage[input] = voltage;
+	return s;
+}
+
+static int max_set_input_unlocked(struct dvb_frontend *fe, int in)
+{
+	struct ddb_input *input = fe->sec_priv;
+	struct ddb_port *port = input->port;
+	struct ddb *dev = port->dev;
+	struct ddb_dvb *dvb = &port->dvb[input->nr & 1];
+	int res = 0;
+
+	if (in > 3)
+		return -EINVAL;
+	if (dvb->input != in) {
+		u32 bit = (1ULL << input->nr);
+		u32 obit = dev->link[port->lnr].lnb.voltage[dvb->input] & bit;
+
+		dev->link[port->lnr].lnb.voltage[dvb->input] &= ~bit;
+		dvb->input = in;
+		dev->link[port->lnr].lnb.voltage[dvb->input] |= obit;
+	}
+	res = dvb->set_input(fe, in);
+	return res;
+}
+
+static int max_set_input(struct dvb_frontend *fe, int in)
+{
+	struct ddb_input *input = fe->sec_priv;
+	struct ddb_port *port = input->port;
+	struct ddb *dev = input->port->dev;
+	int res;
+
+	mutex_lock(&dev->link[port->lnr].lnb.lock);
+	res = max_set_input_unlocked(fe, in);
+	mutex_unlock(&dev->link[port->lnr].lnb.lock);
+	return res;
+}
+
+static int max_set_tone(struct dvb_frontend *fe, enum fe_sec_tone_mode tone)
+{
+	struct ddb_input *input = fe->sec_priv;
+	struct ddb_port *port = input->port;
+	struct ddb *dev = port->dev;
+	struct ddb_dvb *dvb = &port->dvb[input->nr & 1];
+	int tuner = 0;
+	int res = 0;
+	u32 fmode = dev->link[port->lnr].lnb.fmode;
+
+	mutex_lock(&dev->link[port->lnr].lnb.lock);
+	dvb->tone = tone;
+	switch (fmode) {
+	default:
+	case 0:
+	case 3:
+		res = lnb_set_tone(dev, port->lnr, dvb->input, tone);
+		break;
+	case 1:
+	case 2:
+		if (old_quattro) {
+			if (dvb->tone == SEC_TONE_ON)
+				tuner |= 2;
+			if (dvb->voltage == SEC_VOLTAGE_18)
+				tuner |= 1;
+		} else {
+			if (dvb->tone == SEC_TONE_ON)
+				tuner |= 1;
+			if (dvb->voltage == SEC_VOLTAGE_18)
+				tuner |= 2;
+		}
+		res = max_set_input_unlocked(fe, tuner);
+		break;
+	}
+	mutex_unlock(&dev->link[port->lnr].lnb.lock);
+	return res;
+}
+
+static int max_set_voltage(struct dvb_frontend *fe, enum fe_sec_voltage voltage)
+{
+	struct ddb_input *input = fe->sec_priv;
+	struct ddb_port *port = input->port;
+	struct ddb *dev = port->dev;
+	struct ddb_dvb *dvb = &port->dvb[input->nr & 1];
+	int tuner = 0;
+	u32 nv, ov = dev->link[port->lnr].lnb.voltages;
+	int res = 0;
+	u32 fmode = dev->link[port->lnr].lnb.fmode;
+
+	mutex_lock(&dev->link[port->lnr].lnb.lock);
+	dvb->voltage = voltage;
+
+	switch (fmode) {
+	case 3:
+	default:
+	case 0:
+		if (fmode == 3)
+			max_set_input_unlocked(fe, 0);
+		if (voltage == SEC_VOLTAGE_OFF)
+			dev->link[port->lnr].lnb.voltage[dvb->input] &= ~(1ULL << input->nr);
+		else
+			dev->link[port->lnr].lnb.voltage[dvb->input] |= (1ULL << input->nr);
+
+		res = lnb_set_voltage(dev, port->lnr, dvb->input, voltage);
+		break;
+	case 1:
+	case 2:
+		if (voltage == SEC_VOLTAGE_OFF)
+			dev->link[port->lnr].lnb.voltages &= ~(1ULL << input->nr);
+		else
+			dev->link[port->lnr].lnb.voltages |= (1ULL << input->nr);
+		nv = dev->link[port->lnr].lnb.voltages;
+
+		if (old_quattro) {
+			if (dvb->tone == SEC_TONE_ON)
+				tuner |= 2;
+			if (dvb->voltage == SEC_VOLTAGE_18)
+				tuner |= 1;
+		} else {
+			if (dvb->tone == SEC_TONE_ON)
+				tuner |= 1;
+			if (dvb->voltage == SEC_VOLTAGE_18)
+				tuner |= 2;
+		}
+		res = max_set_input_unlocked(fe, tuner);
+
+		if (nv != ov) {
+			if (nv) {
+				lnb_set_voltage(dev, port->lnr, 0, SEC_VOLTAGE_13);
+				if (fmode == 1) {
+					lnb_set_voltage(dev, port->lnr, 0, SEC_VOLTAGE_13);
+					if (old_quattro) {
+						lnb_set_voltage(dev, port->lnr, 1, SEC_VOLTAGE_18);
+						lnb_set_voltage(dev, port->lnr, 2, SEC_VOLTAGE_13);
+					} else {
+						lnb_set_voltage(dev, port->lnr, 1, SEC_VOLTAGE_13);
+						lnb_set_voltage(dev, port->lnr, 2, SEC_VOLTAGE_18);
+					}
+					lnb_set_voltage(dev, port->lnr, 3, SEC_VOLTAGE_18);
+				}
+			} else {
+				lnb_set_voltage(dev, port->lnr, 0, SEC_VOLTAGE_OFF);
+				if (fmode == 1) {
+					lnb_set_voltage(dev, port->lnr, 1, SEC_VOLTAGE_OFF);
+					lnb_set_voltage(dev, port->lnr, 2, SEC_VOLTAGE_OFF);
+					lnb_set_voltage(dev, port->lnr, 3, SEC_VOLTAGE_OFF);
+				}
+			}
+		}
+		break;
+	}
+	mutex_unlock(&dev->link[port->lnr].lnb.lock);
+	return res;
+}
+
+static int max_enable_high_lnb_voltage(struct dvb_frontend *fe, long arg)
+{
+
+	return 0;
+}
+
+static int max_send_burst(struct dvb_frontend *fe, enum fe_sec_mini_cmd burst)
+{
+	return 0;
+}
+
+static int mxl_fw_read(void *priv, u8 *buf, u32 len)
+{
+	struct ddb_link *link = priv;
+	struct ddb *dev = link->dev;
+
+	pr_info("Read mxl_fw from link %u\n", link->nr);
+
+	return ddbridge_flashread(dev, link->nr, buf, 0xc0000, len);
+}
+
+static int lnb_init_fmode(struct ddb *dev, struct ddb_link *link, u32 fm)
+{
+	u32 l = link->nr;
+
+	if (link->lnb.fmode == fm)
+		return 0;
+	pr_info("Set fmode link %u = %u\n", l, fm);
+	mutex_lock(&link->lnb.lock);
+	if (fm == 2 || fm == 1) {
+		lnb_set_tone(dev, l, 0, SEC_TONE_OFF);
+		if (old_quattro) {
+			lnb_set_tone(dev, l, 1, SEC_TONE_OFF);
+			lnb_set_tone(dev, l, 2, SEC_TONE_ON);
+		} else {
+			lnb_set_tone(dev, l, 1, SEC_TONE_ON);
+			lnb_set_tone(dev, l, 2, SEC_TONE_OFF);
+		}
+		lnb_set_tone(dev, l, 3, SEC_TONE_ON);
+	}
+	link->lnb.fmode = fm;
+	mutex_unlock(&link->lnb.lock);
+	return 0;
+}
+
+static struct mxl5xx_cfg mxl5xx = {
+	.adr      = 0x60,
+	.type     = 0x01,
+	.clk      = 27000000,
+	.ts_clk   = 139,
+	.cap      = 12,
+	.fw_read  = mxl_fw_read,
+};
+
+static int fe_attach_mxl5xx(struct ddb_input *input)
+{
+	struct ddb *dev = input->port->dev;
+	struct i2c_adapter *i2c = &input->port->i2c->adap;
+	struct ddb_dvb *dvb = &input->port->dvb[input->nr & 1];
+	struct ddb_port *port = input->port;
+	struct ddb_link *link = &dev->link[port->lnr];
+	struct mxl5xx_cfg cfg;
+	int demod, tuner;
+
+	cfg = mxl5xx;
+	cfg.fw_priv = link;
+	if (dev->link[0].info->type == DDB_OCTONET)
+		; /* cfg.ts_clk = 69; */
+
+	demod = input->nr;
+	tuner = demod & 3;
+	if (fmode == 3)
+		tuner = 0;
+	dvb->fe = dvb_attach(mxl5xx_attach, i2c, &cfg, demod, tuner);
+	if (!dvb->fe) {
+		pr_err("No MXL5XX found!\n");
+		return -ENODEV;
+	}
+	if (input->nr < 4) {
+		lnb_command(dev, port->lnr, input->nr, LNB_CMD_INIT);
+		lnb_set_voltage(dev, port->lnr, input->nr, SEC_VOLTAGE_OFF);
+	}
+	lnb_init_fmode(dev, link, fmode);
+
+	dvb->fe->ops.set_voltage = max_set_voltage;
+	dvb->fe->ops.enable_high_lnb_voltage = max_enable_high_lnb_voltage;
+	dvb->fe->ops.set_tone = max_set_tone;
+	dvb->diseqc_send_master_cmd = dvb->fe->ops.diseqc_send_master_cmd;
+	dvb->fe->ops.diseqc_send_master_cmd = max_send_master_cmd;
+	dvb->fe->ops.diseqc_send_burst = max_send_burst;
+	dvb->fe->sec_priv = input;
+	dvb->set_input = dvb->fe->ops.set_input;
+	dvb->fe->ops.set_input = max_set_input;
+	dvb->input = tuner;
+	return 0;
+}
+
 static int my_dvb_dmx_ts_card_init(struct dvb_demux *dvbdemux, char *id,
-			    int (*start_feed)(struct dvb_demux_feed *),
-			    int (*stop_feed)(struct dvb_demux_feed *),
-			    void *priv)
+				   int (*start_feed)(struct dvb_demux_feed *),
+				   int (*stop_feed)(struct dvb_demux_feed *),
+				   void *priv)
 {
 	dvbdemux->priv = priv;
 
@@ -734,10 +1551,10 @@ static int my_dvb_dmx_ts_card_init(struct dvb_demux *dvbdemux, char *id,
 }
 
 static int my_dvb_dmxdev_ts_card_init(struct dmxdev *dmxdev,
-			       struct dvb_demux *dvbdemux,
-			       struct dmx_frontend *hw_frontend,
-			       struct dmx_frontend *mem_frontend,
-			       struct dvb_adapter *dvb_adapter)
+				      struct dvb_demux *dvbdemux,
+				      struct dmx_frontend *hw_frontend,
+				      struct dmx_frontend *mem_frontend,
+				      struct dvb_adapter *dvb_adapter)
 {
 	int ret;
 
@@ -759,999 +1576,3010 @@ static int start_feed(struct dvb_demux_feed *dvbdmxfeed)
 {
 	struct dvb_demux *dvbdmx = dvbdmxfeed->demux;
 	struct ddb_input *input = dvbdmx->priv;
+	struct ddb_dvb *dvb = &input->port->dvb[input->nr & 1];
 
-	if (!input->users)
-		ddb_input_start(input);
+	if (!dvb->users)
+		ddb_input_start_all(input);
 
-	return ++input->users;
+	return ++dvb->users;
 }
 
 static int stop_feed(struct dvb_demux_feed *dvbdmxfeed)
 {
 	struct dvb_demux *dvbdmx = dvbdmxfeed->demux;
 	struct ddb_input *input = dvbdmx->priv;
+	struct ddb_dvb *dvb = &input->port->dvb[input->nr & 1];
 
-	if (--input->users)
-		return input->users;
+	if (--dvb->users)
+		return dvb->users;
 
-	ddb_input_stop(input);
+	ddb_input_stop_all(input);
 	return 0;
 }
 
-
 static void dvb_input_detach(struct ddb_input *input)
 {
-	struct dvb_adapter *adap = &input->adap;
-	struct dvb_demux *dvbdemux = &input->demux;
-
-	switch (input->attached) {
-	case 5:
-		if (input->fe2)
-			dvb_unregister_frontend(input->fe2);
-		if (input->fe) {
-			dvb_unregister_frontend(input->fe);
-			dvb_frontend_detach(input->fe);
-			input->fe = NULL;
+	struct ddb_dvb *dvb = &input->port->dvb[input->nr & 1];
+	struct dvb_demux *dvbdemux = &dvb->demux;
+	struct i2c_client *client;
+
+	switch (dvb->attached) {
+	case 0x31:
+		client = dvb->i2c_client[0];
+		if (client) {
+			module_put(client->dev.driver->owner);
+			i2c_unregister_device(client);
 		}
-	case 4:
-		dvb_net_release(&input->dvbnet);
-
-	case 3:
+		if (dvb->fe2)
+			dvb_unregister_frontend(dvb->fe2);
+		if (dvb->fe)
+			dvb_unregister_frontend(dvb->fe);
+		/* fallthrough */
+	case 0x30:
+		if (dvb->fe2)
+			dvb_frontend_detach(dvb->fe2);
+		if (dvb->fe)
+			dvb_frontend_detach(dvb->fe);
+		dvb->fe = dvb->fe2 = NULL;
+		/* fallthrough */
+	case 0x21:
+		if (input->port->dev->ns_num)
+			dvb_netstream_release(&dvb->dvbns);
+		/* fallthrough */
+	case 0x20:
+		dvb_net_release(&dvb->dvbnet);
+		/* fallthrough */
+	case 0x11:
 		dvbdemux->dmx.close(&dvbdemux->dmx);
 		dvbdemux->dmx.remove_frontend(&dvbdemux->dmx,
-					      &input->hw_frontend);
+					      &dvb->hw_frontend);
 		dvbdemux->dmx.remove_frontend(&dvbdemux->dmx,
-					      &input->mem_frontend);
-		dvb_dmxdev_release(&input->dmxdev);
+					      &dvb->mem_frontend);
+		dvb_dmxdev_release(&dvb->dmxdev);
+		/* fallthrough */
+	case 0x10:
+		dvb_dmx_release(&dvb->demux);
+		/* fallthrough */
+	case 0x01:
+		break;
+	}
+	dvb->attached = 0x00;
+}
 
-	case 2:
-		dvb_dmx_release(&input->demux);
+static int dvb_register_adapters(struct ddb *dev)
+{
+	int i, ret = 0;
+	struct ddb_port *port;
+	struct dvb_adapter *adap;
+
+	if (adapter_alloc == 3 || dev->link[0].info->type == DDB_MOD ||
+	     dev->link[0].info->type == DDB_OCTONET) {
+		port = &dev->port[0];
+		adap = port->dvb[0].adap;
+		ret = dvb_register_adapter(adap, "DDBridge", THIS_MODULE,
+					   port->dev->dev,
+					   adapter_nr);
+		if (ret < 0)
+			return ret;
+		port->dvb[0].adap_registered = 1;
+		for (i = 0; i < dev->port_num; i++) {
+			port = &dev->port[i];
+			port->dvb[0].adap = adap;
+			port->dvb[1].adap = adap;
+		}
+		return 0;
+	}
 
-	case 1:
-		dvb_unregister_adapter(adap);
+	for (i = 0; i < dev->port_num; i++) {
+		port = &dev->port[i];
+		switch (port->class) {
+		case DDB_PORT_TUNER:
+			adap = port->dvb[0].adap;
+			ret = dvb_register_adapter(adap, "DDBridge",
+						   THIS_MODULE,
+						   port->dev->dev,
+						   adapter_nr);
+			if (ret < 0)
+				return ret;
+			port->dvb[0].adap_registered = 1;
+
+			if (adapter_alloc > 0) {
+				port->dvb[1].adap = port->dvb[0].adap;
+				break;
+			}
+			adap = port->dvb[1].adap;
+			ret = dvb_register_adapter(adap, "DDBridge",
+						   THIS_MODULE,
+						   port->dev->dev,
+						   adapter_nr);
+			if (ret < 0)
+				return ret;
+			port->dvb[1].adap_registered = 1;
+			break;
+
+		case DDB_PORT_CI:
+		case DDB_PORT_LOOP:
+			adap = port->dvb[0].adap;
+			ret = dvb_register_adapter(adap, "DDBridge",
+						   THIS_MODULE,
+						   port->dev->dev,
+						   adapter_nr);
+			if (ret < 0)
+				return ret;
+			port->dvb[0].adap_registered = 1;
+			break;
+		default:
+			if (adapter_alloc < 2)
+				break;
+			adap = port->dvb[0].adap;
+			ret = dvb_register_adapter(adap, "DDBridge",
+						   THIS_MODULE,
+						   port->dev->dev,
+						   adapter_nr);
+			if (ret < 0)
+				return ret;
+			port->dvb[0].adap_registered = 1;
+			break;
+		}
+	}
+	return ret;
+}
+
+static void dvb_unregister_adapters(struct ddb *dev)
+{
+	int i;
+	struct ddb_port *port;
+	struct ddb_dvb *dvb;
+
+	for (i = 0; i < dev->link[0].info->port_num; i++) {
+		port = &dev->port[i];
+
+		dvb = &port->dvb[0];
+		if (dvb->adap_registered)
+			dvb_unregister_adapter(dvb->adap);
+		dvb->adap_registered = 0;
+
+		dvb = &port->dvb[1];
+		if (dvb->adap_registered)
+			dvb_unregister_adapter(dvb->adap);
+		dvb->adap_registered = 0;
 	}
-	input->attached = 0;
 }
 
 static int dvb_input_attach(struct ddb_input *input)
 {
-	int ret;
+	int ret = 0;
+	struct ddb_dvb *dvb = &input->port->dvb[input->nr & 1];
 	struct ddb_port *port = input->port;
-	struct dvb_adapter *adap = &input->adap;
-	struct dvb_demux *dvbdemux = &input->demux;
-
-	ret = dvb_register_adapter(adap, "DDBridge", THIS_MODULE,
-				   &input->port->dev->pdev->dev,
-				   adapter_nr);
-	if (ret < 0) {
-		printk(KERN_ERR "ddbridge: Could not register adapter."
-		       "Check if you enabled enough adapters in dvb-core!\n");
-		return ret;
-	}
-	input->attached = 1;
+	struct dvb_adapter *adap = dvb->adap;
+	struct dvb_demux *dvbdemux = &dvb->demux;
+	int par = 0;
+
+	dvb->attached = 0x01;
 
 	ret = my_dvb_dmx_ts_card_init(dvbdemux, "SW demux",
 				      start_feed,
 				      stop_feed, input);
 	if (ret < 0)
 		return ret;
-	input->attached = 2;
+	dvb->attached = 0x10;
 
-	ret = my_dvb_dmxdev_ts_card_init(&input->dmxdev, &input->demux,
-					 &input->hw_frontend,
-					 &input->mem_frontend, adap);
+	ret = my_dvb_dmxdev_ts_card_init(&dvb->dmxdev,
+					 &dvb->demux,
+					 &dvb->hw_frontend,
+					 &dvb->mem_frontend, adap);
 	if (ret < 0)
 		return ret;
-	input->attached = 3;
+	dvb->attached = 0x11;
 
-	ret = dvb_net_init(adap, &input->dvbnet, input->dmxdev.demux);
+	ret = dvb_net_init(adap, &dvb->dvbnet, dvb->dmxdev.demux);
 	if (ret < 0)
 		return ret;
-	input->attached = 4;
+	dvb->attached = 0x20;
 
-	input->fe = NULL;
+	if (input->port->dev->ns_num) {
+		ret = netstream_init(input);
+		if (ret < 0)
+			return ret;
+		dvb->attached = 0x21;
+	}
+	dvb->fe = dvb->fe2 = NULL;
 	switch (port->type) {
+	case DDB_TUNER_MXL5XX:
+		if (fe_attach_mxl5xx(input) < 0)
+			return -ENODEV;
+		break;
 	case DDB_TUNER_DVBS_ST:
 		if (demod_attach_stv0900(input, 0) < 0)
 			return -ENODEV;
 		if (tuner_attach_stv6110(input, 0) < 0)
 			return -ENODEV;
-		if (input->fe) {
-			if (dvb_register_frontend(adap, input->fe) < 0)
-				return -ENODEV;
-		}
 		break;
 	case DDB_TUNER_DVBS_ST_AA:
 		if (demod_attach_stv0900(input, 1) < 0)
 			return -ENODEV;
 		if (tuner_attach_stv6110(input, 1) < 0)
 			return -ENODEV;
-		if (input->fe) {
-			if (dvb_register_frontend(adap, input->fe) < 0)
-				return -ENODEV;
-		}
 		break;
-	case DDB_TUNER_DVBCT_TR:
-		if (demod_attach_drxk(input) < 0)
+	case DDB_TUNER_DVBS_STV0910:
+		if (demod_attach_stv0910(input, 0) < 0)
+			return -ENODEV;
+		if (tuner_attach_stv6111(input, 0) < 0)
+			return -ENODEV;
+		break;
+	case DDB_TUNER_DVBS_STV0910_PR:
+		if (demod_attach_stv0910(input, 1) < 0)
+			return -ENODEV;
+		if (tuner_attach_stv6111(input, 1) < 0)
+			return -ENODEV;
+		break;
+	case DDB_TUNER_DVBS_STV0910_P:
+		if (demod_attach_stv0910(input, 0) < 0)
+			return -ENODEV;
+		if (tuner_attach_stv6111(input, 1) < 0)
+			return -ENODEV;
+		break;
+	case DDB_TUNER_DVBCT_TR:
+		if (demod_attach_drxk(input) < 0)
 			return -ENODEV;
 		if (tuner_attach_tda18271(input) < 0)
 			return -ENODEV;
-		if (dvb_register_frontend(adap, input->fe) < 0)
+		break;
+	case DDB_TUNER_DVBCT_ST:
+		if (demod_attach_stv0367dd(input) < 0)
+			return -ENODEV;
+		if (tuner_attach_tda18212(input) < 0)
+		{
+			if(dvb->fe2)
+				dvb_frontend_detach(dvb->fe2);
+			if(dvb->fe)
+				dvb_frontend_detach(dvb->fe);
+			return -ENODEV;
+		}
+		break;
+	case DDB_TUNER_DVBCT2_SONY_P:
+	case DDB_TUNER_DVBC2T2_SONY_P:
+	case DDB_TUNER_ISDBT_SONY_P:
+		if (input->port->dev->link[input->port->lnr].info->ts_quirks
+			& TS_QUIRK_SERIAL)
+			par = 0;
+		else
+			par = 1;
+	case DDB_TUNER_DVBCT2_SONY:
+	case DDB_TUNER_DVBC2T2_SONY:
+	case DDB_TUNER_ISDBT_SONY:
+		if (demod_attach_cxd2843(input, par) < 0)
+			return -ENODEV;
+		if (tuner_attach_tda18212(input) < 0)
+		{
+			if(dvb->fe2)
+				dvb_frontend_detach(dvb->fe2);
+			if(dvb->fe)
+				dvb_frontend_detach(dvb->fe);
+			return -ENODEV;
+		}
+		break;
+	default:
+		return 0;
+	}
+	dvb->attached = 0x30;
+	if (dvb->fe) {
+		if (dvb_register_frontend(adap, dvb->fe) < 0)
+			return -ENODEV;
+	}
+	if (dvb->fe2) {
+		if (dvb_register_frontend(adap, dvb->fe2) < 0)
 			return -ENODEV;
-		if (input->fe2) {
-			if (dvb_register_frontend(adap, input->fe2) < 0)
-				return -ENODEV;
-			input->fe2->tuner_priv = input->fe->tuner_priv;
-			memcpy(&input->fe2->ops.tuner_ops,
-			       &input->fe->ops.tuner_ops,
-			       sizeof(struct dvb_tuner_ops));
+		dvb->fe2->tuner_priv = dvb->fe->tuner_priv;
+		memcpy(&dvb->fe2->ops.tuner_ops,
+		       &dvb->fe->ops.tuner_ops,
+		       sizeof(struct dvb_tuner_ops));
+	}
+	dvb->attached = 0x31;
+	return 0;
+}
+
+
+static int port_has_encti(struct ddb_port *port)
+{
+	u8 val;
+	int ret = i2c_read_reg(&port->i2c->adap, 0x20, 0, &val);
+
+	if (!ret)
+		pr_info("[0x20]=0x%02x\n", val);
+	return ret ? 0 : 1;
+}
+
+static int port_has_cxd(struct ddb_port *port, u8 *type)
+{
+	u8 val;
+	u8 probe[4] = { 0xe0, 0x00, 0x00, 0x00 }, data[4];
+	struct i2c_msg msgs[2] = {{ .addr = 0x40,  .flags = 0,
+				    .buf  = probe, .len   = 4 },
+				  { .addr = 0x40,  .flags = I2C_M_RD,
+				    .buf  = data,  .len   = 4 } };
+	val = i2c_transfer(&port->i2c->adap, msgs, 2);
+	if (val != 2)
+		return 0;
+
+	if (data[0] == 0x02 && data[1] == 0x2b && data[3] == 0x43)
+		*type = 2;
+	else
+		*type = 1;
+	return 1;
+}
+
+static int port_has_xo2(struct ddb_port *port, u8 *type, u8 *id)
+{
+	u8 probe[1] = { 0x00 }, data[4];
+
+	if (i2c_io(&port->i2c->adap, 0x10, probe, 1, data, 4))
+		return 0;
+	if (data[0] == 'D' && data[1] == 'F') {
+		*id = data[2];
+		*type = 1;
+		return 1;
+	}
+	if (data[0] == 'C' && data[1] == 'I') {
+		*id = data[2];
+		*type = 2;
+		return 1;
+	}
+	return 0;
+}
+
+static int port_has_stv0900(struct ddb_port *port)
+{
+	u8 val;
+
+	if (i2c_read_reg16(&port->i2c->adap, 0x69, 0xf100, &val) < 0)
+		return 0;
+	return 1;
+}
+
+static int port_has_stv0900_aa(struct ddb_port *port, u8 *id)
+{
+	if (i2c_read_reg16(&port->i2c->adap, 0x68, 0xf100, id) < 0)
+		return 0;
+	return 1;
+}
+
+static int port_has_drxks(struct ddb_port *port)
+{
+	u8 val;
+
+	if (i2c_read(&port->i2c->adap, 0x29, &val) < 0)
+		return 0;
+	if (i2c_read(&port->i2c->adap, 0x2a, &val) < 0)
+		return 0;
+	return 1;
+}
+
+static int port_has_stv0367(struct ddb_port *port)
+{
+	u8 val;
+
+	if (i2c_read_reg16(&port->i2c->adap, 0x1e, 0xf000, &val) < 0)
+		return 0;
+	if (val != 0x60)
+		return 0;
+	if (i2c_read_reg16(&port->i2c->adap, 0x1f, 0xf000, &val) < 0)
+		return 0;
+	if (val != 0x60)
+		return 0;
+	return 1;
+}
+
+static int init_xo2(struct ddb_port *port)
+{
+	struct i2c_adapter *i2c = &port->i2c->adap;
+	struct ddb *dev = port->dev;
+	u8 val, data[2];
+	int res;
+
+	res = i2c_read_regs(i2c, 0x10, 0x04, data, 2);
+	if (res < 0)
+		return res;
+
+	if (data[0] != 0x01)  {
+		pr_info("Port %d: invalid XO2\n", port->nr);
+		return -1;
+	}
+
+	i2c_read_reg(i2c, 0x10, 0x08, &val);
+	if (val != 0) {
+		i2c_write_reg(i2c, 0x10, 0x08, 0x00);
+		msleep(100);
+	}
+	/* Enable tuner power, disable pll, reset demods */
+	i2c_write_reg(i2c, 0x10, 0x08, 0x04);
+	usleep_range(2000, 3000);
+	/* Release demod resets */
+	i2c_write_reg(i2c, 0x10, 0x08, 0x07);
+
+	/* speed: 0=55,1=75,2=90,3=104 MBit/s */
+	i2c_write_reg(i2c, 0x10, 0x09, 2);
+
+	if (dev->link[port->lnr].info->con_clock) {
+		pr_info("Setting continuous clock for XO2\n");
+		i2c_write_reg(i2c, 0x10, 0x0a, 0x03);
+		i2c_write_reg(i2c, 0x10, 0x0b, 0x03);
+	} else {
+		i2c_write_reg(i2c, 0x10, 0x0a, 0x01);
+		i2c_write_reg(i2c, 0x10, 0x0b, 0x01);
+	}
+
+	usleep_range(2000, 3000);
+	/* Start XO2 PLL */
+	i2c_write_reg(i2c, 0x10, 0x08, 0x87);
+
+	return 0;
+}
+
+static int init_xo2_ci(struct ddb_port *port)
+{
+	struct i2c_adapter *i2c = &port->i2c->adap;
+	struct ddb *dev = port->dev;
+	u8 val, data[2];
+	int res;
+
+	res = i2c_read_regs(i2c, 0x10, 0x04, data, 2);
+	if (res < 0)
+		return res;
+
+	if (data[0] > 1)  {
+		pr_info("Port %d: invalid XO2 CI %02x\n",
+			port->nr, data[0]);
+		return -1;
+	}
+	pr_info("Port %d: DuoFlex CI %u.%u\n", port->nr, data[0], data[1]);
+
+	i2c_read_reg(i2c, 0x10, 0x08, &val);
+	if (val != 0) {
+		i2c_write_reg(i2c, 0x10, 0x08, 0x00);
+		msleep(100);
+	}
+	/* Enable both CI */
+	i2c_write_reg(i2c, 0x10, 0x08, 3);
+	usleep_range(2000, 3000);
+
+
+	/* speed: 0=55,1=75,2=90,3=104 MBit/s */
+	i2c_write_reg(i2c, 0x10, 0x09, 1);
+
+	i2c_write_reg(i2c, 0x10, 0x08, 0x83);
+	usleep_range(2000, 3000);
+
+	if (dev->link[port->lnr].info->con_clock) {
+		pr_info("Setting continuous clock for DuoFLex CI\n");
+		i2c_write_reg(i2c, 0x10, 0x0a, 0x03);
+		i2c_write_reg(i2c, 0x10, 0x0b, 0x03);
+	} else {
+		i2c_write_reg(i2c, 0x10, 0x0a, 0x01);
+		i2c_write_reg(i2c, 0x10, 0x0b, 0x01);
+	}
+	return 0;
+}
+
+static int port_has_cxd28xx(struct ddb_port *port, u8 *id)
+{
+	struct i2c_adapter *i2c = &port->i2c->adap;
+	int status;
+
+	status = i2c_write_reg(&port->i2c->adap, 0x6e, 0, 0);
+	if (status)
+		return 0;
+	status = i2c_read_reg(i2c, 0x6e, 0xfd, id);
+	if (status)
+		return 0;
+	return 1;
+}
+
+static char *xo2names[] = {
+	"DUAL DVB-S2", "DUAL DVB-C/T/T2",
+	"DUAL DVB-ISDBT", "DUAL DVB-C/C2/T/T2",
+	"DUAL ATSC", "DUAL DVB-C/C2/T/T2",
+	"", ""
+};
+
+static char *xo2types[] = {
+	"DVBS_ST", "DVBCT2_SONY",
+	"ISDBT_SONY", "DVBC2T2_SONY",
+	"ATSC_ST", "DVBC2T2_ST"
+};
+
+static void ddb_port_probe(struct ddb_port *port)
+{
+	struct ddb *dev = port->dev;
+	u32 l = port->lnr;
+	u8 id, type;
+
+	port->name = "NO MODULE";
+	port->type_name = "NONE";
+	port->class = DDB_PORT_NONE;
+
+	/* Handle missing ports and ports without I2C */
+
+	if (port->nr == ts_loop) {
+		port->name = "TS LOOP";
+		port->class = DDB_PORT_LOOP;
+		return;
+	}
+
+	if (port->nr == 1 && dev->link[l].info->type == DDB_OCTOPUS_CI &&
+	    dev->link[l].info->i2c_mask == 1) {
+		port->name = "NO TAB";
+		port->class = DDB_PORT_NONE;
+		return;
+	}
+
+	if (dev->link[l].info->type == DDB_OCTOPUS_MAX) {
+		port->name = "DUAL DVB-S2 MAX";
+		port->type_name = "MXL5XX";
+		port->class = DDB_PORT_TUNER;
+		port->type = DDB_TUNER_MXL5XX;
+		if (port->i2c)
+			ddbwritel(dev, I2C_SPEED_400,
+				  port->i2c->regs + I2C_TIMING);
+		return;
+	}
+
+	if (dev->link[l].info->type == DDB_MOD) {
+		port->name = "MOD";
+		port->class = DDB_PORT_MOD;
+		return;
+	}
+
+	if (port->nr > 1 && dev->link[l].info->type == DDB_OCTOPUS_CI) {
+		port->name = "CI internal";
+		port->type_name = "INTERNAL";
+		port->class = DDB_PORT_CI;
+		port->type = DDB_CI_INTERNAL;
+	}
+
+	if (!port->i2c)
+		return;
+
+	/* Probe ports with I2C */
+
+	if (port_has_cxd(port, &id)) {
+		if (id == 1) {
+			port->name = "CI";
+			port->type_name = "CXD2099";
+			port->class = DDB_PORT_CI;
+			port->type = DDB_CI_EXTERNAL_SONY;
+			ddbwritel(dev, I2C_SPEED_400,
+				  port->i2c->regs + I2C_TIMING);
+		} else {
+			pr_info("Port %d: Uninitialized DuoFlex\n",
+			       port->nr);
+			return;
+		}
+	} else if (port_has_xo2(port, &type, &id)) {
+		ddbwritel(dev, I2C_SPEED_400, port->i2c->regs + I2C_TIMING);
+		/*pr_info("XO2 ID %02x\n", id);*/
+		if (type == 2) {
+			port->name = "DuoFlex CI";
+			port->class = DDB_PORT_CI;
+			port->type = DDB_CI_EXTERNAL_XO2;
+			port->type_name = "CI_XO2";
+			init_xo2_ci(port);
+			return;
+		}
+		id >>= 2;
+		if (id > 5) {
+			port->name = "unknown XO2 DuoFlex";
+			port->type_name = "UNKNOWN";
+		} else {
+			port->name = xo2names[id];
+			port->class = DDB_PORT_TUNER;
+			port->type = DDB_TUNER_XO2 + id;
+			port->type_name = xo2types[id];
+			init_xo2(port);
+		}
+	} else if (port_has_cxd28xx(port, &id)) {
+		switch (id) {
+		case 0xa4:
+			port->name = "DUAL DVB-C2T2 CXD2843";
+			port->type = DDB_TUNER_DVBC2T2_SONY_P;
+			port->type_name = "DVBC2T2_SONY";
+			break;
+		case 0xb1:
+			port->name = "DUAL DVB-CT2 CXD2837";
+			port->type = DDB_TUNER_DVBCT2_SONY_P;
+			port->type_name = "DVBCT2_SONY";
+			break;
+		case 0xb0:
+			port->name = "DUAL ISDB-T CXD2838";
+			port->type = DDB_TUNER_ISDBT_SONY_P;
+			port->type_name = "ISDBT_SONY";
+			break;
+		default:
+			return;
+		}
+		port->class = DDB_PORT_TUNER;
+		ddbwritel(dev, I2C_SPEED_400, port->i2c->regs + I2C_TIMING);
+	} else if (port_has_stv0900(port)) {
+		port->name = "DUAL DVB-S2";
+		port->class = DDB_PORT_TUNER;
+		port->type = DDB_TUNER_DVBS_ST;
+		port->type_name = "DVBS_ST";
+		ddbwritel(dev, I2C_SPEED_100, port->i2c->regs + I2C_TIMING);
+	} else if (port_has_stv0900_aa(port, &id)) {
+		port->name = "DUAL DVB-S2";
+		port->class = DDB_PORT_TUNER;
+		if (id == 0x51) {
+			if (port->nr == 0 &&
+			    dev->link[l].info->ts_quirks & TS_QUIRK_REVERSED)
+				port->type = DDB_TUNER_DVBS_STV0910_PR;
+			else
+				port->type = DDB_TUNER_DVBS_STV0910_P;
+			port->type_name = "DVBS_ST_0910";
+		} else {
+			port->type = DDB_TUNER_DVBS_ST_AA;
+			port->type_name = "DVBS_ST_AA";
 		}
+		ddbwritel(dev, I2C_SPEED_100, port->i2c->regs + I2C_TIMING);
+	} else if (port_has_drxks(port)) {
+		port->name = "DUAL DVB-C/T";
+		port->class = DDB_PORT_TUNER;
+		port->type = DDB_TUNER_DVBCT_TR;
+		port->type_name = "DVBCT_TR";
+		ddbwritel(dev, I2C_SPEED_400, port->i2c->regs + I2C_TIMING);
+	} else if (port_has_stv0367(port)) {
+		port->name = "DUAL DVB-C/T";
+		port->class = DDB_PORT_TUNER;
+		port->type = DDB_TUNER_DVBCT_ST;
+		port->type_name = "DVBCT_ST";
+		ddbwritel(dev, I2C_SPEED_100, port->i2c->regs + I2C_TIMING);
+	} else if (port_has_encti(port)) {
+		port->name = "ENCTI";
+		port->class = DDB_PORT_LOOP;
+	}
+}
+
+
+/****************************************************************************/
+/****************************************************************************/
+/****************************************************************************/
+
+static int wait_ci_ready(struct ddb_ci *ci)
+{
+	u32 count = 10;
+
+	ndelay(500);
+	do {
+		if (ddbreadl(ci->port->dev,
+			     CI_CONTROL(ci->nr)) & CI_READY)
+			break;
+		usleep_range(1, 2);
+		if ((--count) == 0)
+			return -1;
+	} while (1);
+	return 0;
+}
+
+static int read_attribute_mem(struct dvb_ca_en50221 *ca,
+			      int slot, int address)
+{
+	struct ddb_ci *ci = ca->data;
+	u32 val, off = (address >> 1) & (CI_BUFFER_SIZE - 1);
+
+	if (address > CI_BUFFER_SIZE)
+		return -1;
+	ddbwritel(ci->port->dev, CI_READ_CMD | (1 << 16) | address,
+		  CI_DO_READ_ATTRIBUTES(ci->nr));
+	wait_ci_ready(ci);
+	val = 0xff & ddbreadl(ci->port->dev, CI_BUFFER(ci->nr) + off);
+	return val;
+}
+
+static int write_attribute_mem(struct dvb_ca_en50221 *ca, int slot,
+			       int address, u8 value)
+{
+	struct ddb_ci *ci = ca->data;
+
+	ddbwritel(ci->port->dev, CI_WRITE_CMD | (value << 16) | address,
+		  CI_DO_ATTRIBUTE_RW(ci->nr));
+	wait_ci_ready(ci);
+	return 0;
+}
+
+static int read_cam_control(struct dvb_ca_en50221 *ca,
+			    int slot, u8 address)
+{
+	u32 count = 100;
+	struct ddb_ci *ci = ca->data;
+	u32 res;
+
+	ddbwritel(ci->port->dev, CI_READ_CMD | address,
+		  CI_DO_IO_RW(ci->nr));
+	ndelay(500);
+	do {
+		res = ddbreadl(ci->port->dev, CI_READDATA(ci->nr));
+		if (res & CI_READY)
+			break;
+		usleep_range(1, 2);
+		if ((--count) == 0)
+			return -1;
+	} while (1);
+	return 0xff & res;
+}
+
+static int write_cam_control(struct dvb_ca_en50221 *ca, int slot,
+			     u8 address, u8 value)
+{
+	struct ddb_ci *ci = ca->data;
+
+	ddbwritel(ci->port->dev, CI_WRITE_CMD | (value << 16) | address,
+		  CI_DO_IO_RW(ci->nr));
+	wait_ci_ready(ci);
+	return 0;
+}
+
+static int slot_reset(struct dvb_ca_en50221 *ca, int slot)
+{
+	struct ddb_ci *ci = ca->data;
+
+	ddbwritel(ci->port->dev, CI_POWER_ON,
+		  CI_CONTROL(ci->nr));
+	msleep(100);
+	ddbwritel(ci->port->dev, CI_POWER_ON | CI_RESET_CAM,
+		  CI_CONTROL(ci->nr));
+	ddbwritel(ci->port->dev, CI_ENABLE | CI_POWER_ON | CI_RESET_CAM,
+		  CI_CONTROL(ci->nr));
+	udelay(20);
+	ddbwritel(ci->port->dev, CI_ENABLE | CI_POWER_ON,
+		  CI_CONTROL(ci->nr));
+	return 0;
+}
+
+static int slot_shutdown(struct dvb_ca_en50221 *ca, int slot)
+{
+	struct ddb_ci *ci = ca->data;
+
+	ddbwritel(ci->port->dev, 0, CI_CONTROL(ci->nr));
+	msleep(300);
+	return 0;
+}
+
+static int slot_ts_enable(struct dvb_ca_en50221 *ca, int slot)
+{
+	struct ddb_ci *ci = ca->data;
+	u32 val = ddbreadl(ci->port->dev, CI_CONTROL(ci->nr));
+
+	ddbwritel(ci->port->dev, val | CI_BYPASS_DISABLE,
+		  CI_CONTROL(ci->nr));
+	return 0;
+}
+
+static int poll_slot_status(struct dvb_ca_en50221 *ca, int slot, int open)
+{
+	struct ddb_ci *ci = ca->data;
+	u32 val = ddbreadl(ci->port->dev, CI_CONTROL(ci->nr));
+	int stat = 0;
+
+	if (val & CI_CAM_DETECT)
+		stat |= DVB_CA_EN50221_POLL_CAM_PRESENT;
+	if (val & CI_CAM_READY)
+		stat |= DVB_CA_EN50221_POLL_CAM_READY;
+	return stat;
+}
+
+static struct dvb_ca_en50221 en_templ = {
+	.read_attribute_mem  = read_attribute_mem,
+	.write_attribute_mem = write_attribute_mem,
+	.read_cam_control    = read_cam_control,
+	.write_cam_control   = write_cam_control,
+	.slot_reset          = slot_reset,
+	.slot_shutdown       = slot_shutdown,
+	.slot_ts_enable      = slot_ts_enable,
+	.poll_slot_status    = poll_slot_status,
+};
+
+static void ci_attach(struct ddb_port *port)
+{
+	struct ddb_ci *ci = 0;
+
+	ci = kzalloc(sizeof(*ci), GFP_KERNEL);
+	if (!ci)
+		return;
+	memcpy(&ci->en, &en_templ, sizeof(en_templ));
+	ci->en.data = ci;
+	port->en = &ci->en;
+	ci->port = port;
+	ci->nr = port->nr - 2;
+}
+
+/****************************************************************************/
+/****************************************************************************/
+/****************************************************************************/
+
+static int write_creg(struct ddb_ci *ci, u8 data, u8 mask)
+{
+	struct i2c_adapter *i2c = &ci->port->i2c->adap;
+	u8 adr = (ci->port->type == DDB_CI_EXTERNAL_XO2) ? 0x12 : 0x13;
+
+	ci->port->creg = (ci->port->creg & ~mask) | data;
+	return i2c_write_reg(i2c, adr, 0x02, ci->port->creg);
+}
+
+static int read_attribute_mem_xo2(struct dvb_ca_en50221 *ca,
+				  int slot, int address)
+{
+	struct ddb_ci *ci = ca->data;
+	struct i2c_adapter *i2c = &ci->port->i2c->adap;
+	u8 adr = (ci->port->type == DDB_CI_EXTERNAL_XO2) ? 0x12 : 0x13;
+	int res;
+	u8 val;
+
+	res = i2c_read_reg16(i2c, adr, 0x8000 | address, &val);
+	return res ? res : val;
+}
+
+static int write_attribute_mem_xo2(struct dvb_ca_en50221 *ca, int slot,
+				   int address, u8 value)
+{
+	struct ddb_ci *ci = ca->data;
+	struct i2c_adapter *i2c = &ci->port->i2c->adap;
+	u8 adr = (ci->port->type == DDB_CI_EXTERNAL_XO2) ? 0x12 : 0x13;
+
+	return i2c_write_reg16(i2c, adr, 0x8000 | address, value);
+}
+
+static int read_cam_control_xo2(struct dvb_ca_en50221 *ca,
+				int slot, u8 address)
+{
+	struct ddb_ci *ci = ca->data;
+	struct i2c_adapter *i2c = &ci->port->i2c->adap;
+	u8 adr = (ci->port->type == DDB_CI_EXTERNAL_XO2) ? 0x12 : 0x13;
+	u8 val;
+	int res;
+
+	res = i2c_read_reg(i2c, adr, 0x20 | (address & 3), &val);
+	return res ? res : val;
+}
+
+static int write_cam_control_xo2(struct dvb_ca_en50221 *ca, int slot,
+				 u8 address, u8 value)
+{
+	struct ddb_ci *ci = ca->data;
+	struct i2c_adapter *i2c = &ci->port->i2c->adap;
+	u8 adr = (ci->port->type == DDB_CI_EXTERNAL_XO2) ? 0x12 : 0x13;
+
+	return i2c_write_reg(i2c, adr, 0x20 | (address & 3), value);
+}
+
+static int slot_reset_xo2(struct dvb_ca_en50221 *ca, int slot)
+{
+	struct ddb_ci *ci = ca->data;
+
+	pr_info("%s\n", __func__);
+	write_creg(ci, 0x01, 0x01);
+	write_creg(ci, 0x04, 0x04);
+	msleep(20);
+	write_creg(ci, 0x02, 0x02);
+	write_creg(ci, 0x00, 0x04);
+	write_creg(ci, 0x18, 0x18);
+	return 0;
+}
+
+static int slot_shutdown_xo2(struct dvb_ca_en50221 *ca, int slot)
+{
+	struct ddb_ci *ci = ca->data;
+
+	pr_info("%s\n", __func__);
+	write_creg(ci, 0x10, 0xff);
+	write_creg(ci, 0x08, 0x08);
+	return 0;
+}
+
+static int slot_ts_enable_xo2(struct dvb_ca_en50221 *ca, int slot)
+{
+	struct ddb_ci *ci = ca->data;
+
+	pr_info("%s\n", __func__);
+	write_creg(ci, 0x00, 0x10);
+	return 0;
+}
+
+static int poll_slot_status_xo2(struct dvb_ca_en50221 *ca, int slot, int open)
+{
+	struct ddb_ci *ci = ca->data;
+	struct i2c_adapter *i2c = &ci->port->i2c->adap;
+	u8 adr = (ci->port->type == DDB_CI_EXTERNAL_XO2) ? 0x12 : 0x13;
+	u8 val = 0;
+	int stat = 0;
+
+	i2c_read_reg(i2c, adr, 0x01, &val);
+
+	if (val & 2)
+		stat |= DVB_CA_EN50221_POLL_CAM_PRESENT;
+	if (val & 1)
+		stat |= DVB_CA_EN50221_POLL_CAM_READY;
+	return stat;
+}
+
+static struct dvb_ca_en50221 en_xo2_templ = {
+	.read_attribute_mem  = read_attribute_mem_xo2,
+	.write_attribute_mem = write_attribute_mem_xo2,
+	.read_cam_control    = read_cam_control_xo2,
+	.write_cam_control   = write_cam_control_xo2,
+	.slot_reset          = slot_reset_xo2,
+	.slot_shutdown       = slot_shutdown_xo2,
+	.slot_ts_enable      = slot_ts_enable_xo2,
+	.poll_slot_status    = poll_slot_status_xo2,
+};
+
+static void ci_xo2_attach(struct ddb_port *port)
+{
+	struct ddb_ci *ci = 0;
+	struct i2c_adapter *i2c;
+
+	ci = kzalloc(sizeof(*ci), GFP_KERNEL);
+	if (!ci)
+		return;
+	memcpy(&ci->en, &en_xo2_templ, sizeof(en_xo2_templ));
+	ci->en.data = ci;
+	port->en = &ci->en;
+	ci->port = port;
+	ci->nr = port->nr - 2;
+	ci->port->creg = 0;
+	i2c = &ci->port->i2c->adap;
+	write_creg(ci, 0x10, 0xff);
+	write_creg(ci, 0x08, 0x08);
+}
+
+/****************************************************************************/
+/****************************************************************************/
+/****************************************************************************/
+
+
+struct cxd2099_cfg cxd_cfg = {
+	.bitrate =  72000,
+	.adr     =  0x40,
+	.polarity = 1,
+	.clock_mode = 1,
+	.max_i2c = 512,
+};
+
+static int ddb_ci_attach(struct ddb_port *port)
+{
+	switch (port->type) {
+	case DDB_CI_EXTERNAL_SONY:
+		cxd_cfg.bitrate = ci_bitrate;
+		port->en = cxd2099_attach(&cxd_cfg, port, &port->i2c->adap);
+		if (!port->en)
+			return -ENODEV;
+		dvb_ca_en50221_init(port->dvb[0].adap,
+				    port->en, 0, 1);
+		break;
+
+	case DDB_CI_EXTERNAL_XO2:
+	case DDB_CI_EXTERNAL_XO2_B:
+		ci_xo2_attach(port);
+		if (!port->en)
+			return -ENODEV;
+		dvb_ca_en50221_init(port->dvb[0].adap, port->en, 0, 1);
+		break;
+
+	case DDB_CI_INTERNAL:
+		ci_attach(port);
+		if (!port->en)
+			return -ENODEV;
+		dvb_ca_en50221_init(port->dvb[0].adap, port->en, 0, 1);
+		break;
+	}
+	return 0;
+}
+
+static int ddb_port_attach(struct ddb_port *port)
+{
+	int ret = 0;
+
+	switch (port->class) {
+	case DDB_PORT_TUNER:
+		ret = dvb_input_attach(port->input[0]);
+		if (ret < 0)
+			break;
+		ret = dvb_input_attach(port->input[1]);
+		if (ret < 0)
+			break;
+		port->input[0]->redi = port->input[0];
+		port->input[1]->redi = port->input[1];
+		break;
+	case DDB_PORT_CI:
+		ret = ddb_ci_attach(port);
+		if (ret < 0)
+			break;
+	case DDB_PORT_LOOP:
+		ret = dvb_register_device(port->dvb[0].adap,
+					  &port->dvb[0].dev,
+					  &dvbdev_ci, (void *) port->output,
+					  DVB_DEVICE_CI, 0);
+		break;
+	case DDB_PORT_MOD:
+		ret = dvb_register_device(port->dvb[0].adap,
+					  &port->dvb[0].dev,
+					  &dvbdev_mod, (void *) port->output,
+					  DVB_DEVICE_MOD, 0);
+		break;
+	default:
+		break;
+	}
+	if (ret < 0)
+		pr_err("port_attach on port %d failed\n", port->nr);
+	return ret;
+}
+
+static int ddb_ports_attach(struct ddb *dev)
+{
+	int i, ret = 0;
+	struct ddb_port *port;
+
+	dev->ns_num = dev->link[0].info->ns_num;
+	for (i = 0; i < dev->ns_num; i++)
+		dev->ns[i].nr = i;
+	pr_info("%d netstream channels\n", dev->ns_num);
+
+	if (dev->port_num) {
+		ret = dvb_register_adapters(dev);
+		if (ret < 0) {
+			pr_err("Registering adapters failed. Check DVB_MAX_ADAPTERS in config.\n");
+			return ret;
+		}
+	}
+	for (i = 0; i < dev->port_num; i++) {
+		port = &dev->port[i];
+		ret = ddb_port_attach(port);
+	}
+	return ret;
+}
+
+static void ddb_ports_detach(struct ddb *dev)
+{
+	int i;
+	struct ddb_port *port;
+
+	for (i = 0; i < dev->port_num; i++) {
+		port = &dev->port[i];
+
+		switch (port->class) {
+		case DDB_PORT_TUNER:
+			dvb_input_detach(port->input[0]);
+			dvb_input_detach(port->input[1]);
+			break;
+		case DDB_PORT_CI:
+		case DDB_PORT_LOOP:
+			if (port->dvb[0].dev)
+				dvb_unregister_device(port->dvb[0].dev);
+			if (port->en) {
+				dvb_ca_en50221_release(port->en);
+				kfree(port->en);
+				port->en = NULL;
+			}
+			break;
+		case DDB_PORT_MOD:
+			if (port->dvb[0].dev)
+				dvb_unregister_device(port->dvb[0].dev);
+			break;
+		}
+	}
+	dvb_unregister_adapters(dev);
+}
+
+
+/* Copy input DMA pointers to output DMA and ACK. */
+
+static void input_write_output(struct ddb_input *input,
+			       struct ddb_output *output)
+{
+	ddbwritel(output->port->dev,
+		  input->dma->stat, DMA_BUFFER_ACK(output->dma->nr));
+	output->dma->cbuf = (input->dma->stat >> 11) & 0x1f;
+	output->dma->coff = (input->dma->stat & 0x7ff) << 7;
+}
+
+static void output_ack_input(struct ddb_output *output,
+			     struct ddb_input *input)
+{
+	ddbwritel(input->port->dev,
+		  output->dma->stat, DMA_BUFFER_ACK(input->dma->nr));
+}
+
+static void input_write_dvb(struct ddb_input *input,
+			    struct ddb_input *input2)
+{
+	struct ddb_dvb *dvb = &input2->port->dvb[input2->nr & 1];
+	struct ddb_dma *dma, *dma2;
+	struct ddb *dev = input->port->dev;
+	int ack = 1;
+
+	dma = dma2 = input->dma;
+	/* if there also is an output connected, do not ACK.
+	 * input_write_output will ACK.
+	 */
+	if (input->redo) {
+		dma2 = input->redo->dma;
+		ack = 0;
+	}
+	while (dma->cbuf != ((dma->stat >> 11) & 0x1f)
+	       || (4 & dma->ctrl)) {
+		if (4 & dma->ctrl) {
+			/*pr_err("Overflow dma %d\n", dma->nr);*/
+			ack = 1;
+		}
+#ifdef DDB_ALT_DMA
+		dma_sync_single_for_cpu(dev->dev, dma2->pbuf[dma->cbuf],
+					dma2->size, DMA_FROM_DEVICE);
+#endif
+		dvb_dmx_swfilter_packets(&dvb->demux,
+					 dma2->vbuf[dma->cbuf],
+					 dma2->size / 188);
+		dma->cbuf = (dma->cbuf + 1) % dma2->num;
+		if (ack)
+			ddbwritel(dev, (dma->cbuf << 11),
+				  DMA_BUFFER_ACK(dma->nr));
+		dma->stat = ddbreadl(dev, DMA_BUFFER_CURRENT(dma->nr));
+		dma->ctrl = ddbreadl(dev, DMA_BUFFER_CONTROL(dma->nr));
+	}
+}
+
+#ifdef DDB_USE_WORK
+static void input_work(struct work_struct *work)
+{
+	struct ddb_dma *dma = container_of(work, struct ddb_dma, work);
+	struct ddb_input *input = (struct ddb_input *) dma->io;
+#else
+static void input_tasklet(unsigned long data)
+{
+	struct ddb_input *input = (struct ddb_input *) data;
+	struct ddb_dma *dma = input->dma;
+#endif
+	struct ddb *dev = input->port->dev;
+	unsigned long flags;
+
+	spin_lock_irqsave(&dma->lock, flags);
+	if (!dma->running) {
+		spin_unlock_irqrestore(&dma->lock, flags);
+		return;
+	}
+	dma->stat = ddbreadl(dev, DMA_BUFFER_CURRENT(dma->nr));
+	dma->ctrl = ddbreadl(dev, DMA_BUFFER_CONTROL(dma->nr));
+
+	if (input->redi)
+		input_write_dvb(input, input->redi);
+	if (input->redo)
+		input_write_output(input, input->redo);
+	wake_up(&dma->wq);
+	spin_unlock_irqrestore(&dma->lock, flags);
+}
+
+static void input_handler(unsigned long data)
+{
+	struct ddb_input *input = (struct ddb_input *) data;
+	struct ddb_dma *dma = input->dma;
+
+
+	/* If there is no input connected, input_tasklet() will
+	 * just copy pointers and ACK. So, there is no need to go
+	 * through the tasklet scheduler.
+	 */
+#ifdef DDB_USE_WORK
+	if (input->redi)
+		queue_work(ddb_wq, &dma->work);
+	else
+		input_work(&dma->work);
+#else
+	if (input->redi)
+		tasklet_schedule(&dma->tasklet);
+	else
+		input_tasklet(data);
+#endif
+}
+
+static void output_handler(unsigned long data)
+{
+	struct ddb_output *output = (struct ddb_output *) data;
+	struct ddb_dma *dma = output->dma;
+	struct ddb *dev = output->port->dev;
+
+	spin_lock(&dma->lock);
+	if (!dma->running) {
+		spin_unlock(&dma->lock);
+		return;
+	}
+	dma->stat = ddbreadl(dev, DMA_BUFFER_CURRENT(dma->nr));
+	dma->ctrl = ddbreadl(dev, DMA_BUFFER_CONTROL(dma->nr));
+	if (output->redi)
+		output_ack_input(output, output->redi);
+	wake_up(&dma->wq);
+	spin_unlock(&dma->lock);
+}
+
+
+/****************************************************************************/
+/****************************************************************************/
+
+
+static void ddb_dma_init(struct ddb_dma *dma, int nr, void *io, int out)
+{
+#ifndef DDB_USE_WORK
+	unsigned long priv = (unsigned long) io;
+#endif
+
+	dma->io = io;
+	dma->nr = nr;
+	spin_lock_init(&dma->lock);
+	init_waitqueue_head(&dma->wq);
+	if (out) {
+		dma->num = OUTPUT_DMA_BUFS;
+		dma->size = OUTPUT_DMA_SIZE;
+		dma->div = OUTPUT_DMA_IRQ_DIV;
+	} else {
+#ifdef DDB_USE_WORK
+		INIT_WORK(&dma->work, input_work);
+#else
+		tasklet_init(&dma->tasklet, input_tasklet, priv);
+#endif
+		dma->num = INPUT_DMA_BUFS;
+		dma->size = INPUT_DMA_SIZE;
+		dma->div = INPUT_DMA_IRQ_DIV;
+	}
+}
+
+static void ddb_input_init(struct ddb_port *port, int nr, int pnr,
+	int dma_nr, int anr)
+{
+	struct ddb *dev = port->dev;
+	struct ddb_input *input = &dev->input[anr];
+
+	if (dev->has_dma) {
+		dev->handler[dma_nr + 8] = input_handler;
+		dev->handler_data[dma_nr + 8] = (unsigned long) input;
+	}
+	port->input[pnr] = input;
+	input->nr = nr;
+	input->port = port;
+	if (dev->has_dma) {
+		input->dma = &dev->dma[dma_nr];
+		ddb_dma_init(input->dma, dma_nr, (void *) input, 0);
+	}
+	ddbwritel(dev, 0, TS_INPUT_CONTROL(nr));
+	ddbwritel(dev, 2, TS_INPUT_CONTROL(nr));
+	ddbwritel(dev, 0, TS_INPUT_CONTROL(nr));
+	if (input->dma)
+		ddbwritel(dev, 0, DMA_BUFFER_ACK(input->dma->nr));
+}
+
+static void ddb_output_init(struct ddb_port *port, int nr, int dma_nr)
+{
+	struct ddb *dev = port->dev;
+	struct ddb_output *output = &dev->output[nr];
+
+	if (dev->has_dma) {
+		dev->handler[dma_nr + 8] = output_handler;
+		dev->handler_data[dma_nr + 8] = (unsigned long) output;
+	}
+	port->output = output;
+	output->nr = nr;
+	output->port = port;
+	if (dev->has_dma) {
+		output->dma = &dev->dma[dma_nr];
+		ddb_dma_init(output->dma, dma_nr, (void *) output, 1);
+	}
+	if (output->port->class == DDB_PORT_MOD) {
+		/*ddbwritel(dev, 0, CHANNEL_CONTROL(output->nr));*/
+	} else {
+		ddbwritel(dev, 0, TS_OUTPUT_CONTROL(nr));
+		ddbwritel(dev, 2, TS_OUTPUT_CONTROL(nr));
+		ddbwritel(dev, 0, TS_OUTPUT_CONTROL(nr));
+	}
+	if (output->dma)
+		ddbwritel(dev, 0, DMA_BUFFER_ACK(output->dma->nr));
+}
+
+static int ddb_port_match_i2c(struct ddb_port *port)
+{
+	struct ddb *dev = port->dev;
+	u32 i;
+
+	for (i = 0; i < dev->i2c_num; i++) {
+		if (dev->i2c[i].link == port->lnr &&
+		    dev->i2c[i].nr == port->nr) {
+			port->i2c = &dev->i2c[i];
+			return 1;
+		}
+	}
+	return 0;
+}
+
+static void ddb_ports_init(struct ddb *dev)
+{
+	u32 i, l, p, li2c;
+	struct ddb_port *port;
+	struct ddb_info *info;
+	struct ddb_regmap *rm;
+	int portmatch;
+
+	for (p = l = 0; l < DDB_MAX_LINK; l++) {
+		info = dev->link[l].info;
+		if (!info)
+			continue;
+		rm = info->regmap;
+		if (!rm)
+			continue;
+		for (li2c = 0; li2c < dev->i2c_num; li2c++)
+			if (dev->i2c[li2c].link == l)
+				break;
+		for (i = 0; i < info->port_num; i++, p++) {
+			port = &dev->port[p];
+			port->dev = dev;
+			port->nr = i;
+			port->lnr = l;
+			port->pnr = p;
+			port->gap = 4;
+			port->obr = ci_bitrate;
+			mutex_init(&port->i2c_gate_lock);
+
+			portmatch = ddb_port_match_i2c(port);
+			if (!portmatch) {
+				if (info->type == DDB_OCTOPUS_MAX)
+					port->i2c = &dev->i2c[li2c];
+			}
+
+			ddb_port_probe(port);
+
+			port->dvb[0].adap = &dev->adap[2 * p];
+			port->dvb[1].adap = &dev->adap[2 * p + 1];
+
+			if ((port->class == DDB_PORT_NONE) && i &&
+			    dev->port[p - 1].type == DDB_CI_EXTERNAL_XO2) {
+				port->class = DDB_PORT_CI;
+				port->type = DDB_CI_EXTERNAL_XO2_B;
+				port->name = "DuoFlex CI_B";
+				port->i2c = dev->port[p - 1].i2c;
+			}
+
+			pr_info("Port %u: Link %u, Link Port %u (TAB %u): %s\n",
+				port->pnr, port->lnr, port->nr, port->nr + 1,
+				port->name);
+
+			if (port->class == DDB_PORT_CI &&
+			    port->type == DDB_CI_EXTERNAL_XO2) {
+				ddb_input_init(port, 2 * i, 0, 2 * i, 2 * i);
+				ddb_output_init(port, i, i + 8);
+				continue;
+			}
+
+			if (port->class == DDB_PORT_CI &&
+			    port->type == DDB_CI_EXTERNAL_XO2_B) {
+				ddb_input_init(port, 2 * i - 1, 0, 2 * i - 1,
+						2 * i - 1);
+				ddb_output_init(port, i, i + 8);
+				continue;
+			}
+
+			switch (dev->link[l].info->type) {
+			case DDB_OCTOPUS_CI:
+				if (i >= 2) {
+					ddb_input_init(port, 2 + i, 0, 2 + i,
+						2 + i);
+					ddb_input_init(port, 4 + i, 1, 4 + i,
+						4 + i);
+					ddb_output_init(port, i, i + 8);
+					break;
+				} /* fallthrough */
+			case DDB_OCTONET:
+			case DDB_OCTOPUS:
+				ddb_input_init(port, 2 * i, 0, 2 * i, 2 * i);
+				ddb_input_init(port, 2 * i + 1, 1, 2 * i + 1,
+					2 * i + 1);
+				ddb_output_init(port, i, i + 8);
+				break;
+			case DDB_OCTOPUS_MAX:
+			case DDB_OCTOPUS_MAX_CT:
+				ddb_input_init(port, 2 * i, 0, 2 * i, 2 * p);
+				ddb_input_init(port, 2 * i + 1, 1, 2 * i + 1,
+					2 * p + 1);
+				break;
+			case DDB_MOD:
+				ddb_output_init(port, i, i);
+				dev->handler[i + 18] = ddbridge_mod_rate_handler;
+				dev->handler_data[i + 18] =
+					(unsigned long) &dev->output[i];
+				break;
+			default:
+				break;
+			}
+		}
+	}
+	dev->port_num = p;
+}
+
+static void ddb_ports_release(struct ddb *dev)
+{
+	int i;
+	struct ddb_port *port;
+
+	for (i = 0; i < dev->port_num; i++) {
+		port = &dev->port[i];
+#ifdef DDB_USE_WORK
+		if (port->input[0] && port->input[0]->dma)
+			cancel_work_sync(&port->input[0]->dma->work);
+		if (port->input[1] && port->input[1]->dma)
+			cancel_work_sync(&port->input[1]->dma->work);
+		if (port->output && port->output->dma)
+			cancel_work_sync(&port->output->dma->work);
+#else
+		if (port->input[0] && port->input[0]->dma)
+			tasklet_kill(&port->input[0]->dma->tasklet);
+		if (port->input[1] && port->input[1]->dma)
+			tasklet_kill(&port->input[1]->dma->tasklet);
+		if (port->output && port->output->dma)
+			tasklet_kill(&port->output->dma->tasklet);
+#endif
+	}
+}
+
+/****************************************************************************/
+/****************************************************************************/
+/****************************************************************************/
+
+#define IRQ_HANDLE(_nr) \
+	do { if ((s & (1UL << _nr)) && dev->handler[_nr]) \
+		dev->handler[_nr](dev->handler_data[_nr]); } \
+	while (0)
+
+static void irq_handle_msg(struct ddb *dev, u32 s)
+{
+	dev->i2c_irq++;
+	IRQ_HANDLE(0);
+	IRQ_HANDLE(1);
+	IRQ_HANDLE(2);
+	IRQ_HANDLE(3);
+}
+
+static void irq_handle_io(struct ddb *dev, u32 s)
+{
+	dev->ts_irq++;
+	if ((s & 0x000000f0)) {
+		IRQ_HANDLE(4);
+		IRQ_HANDLE(5);
+		IRQ_HANDLE(6);
+		IRQ_HANDLE(7);
+	}
+	if ((s & 0x0000ff00)) {
+		IRQ_HANDLE(8);
+		IRQ_HANDLE(9);
+		IRQ_HANDLE(10);
+		IRQ_HANDLE(11);
+		IRQ_HANDLE(12);
+		IRQ_HANDLE(13);
+		IRQ_HANDLE(14);
+		IRQ_HANDLE(15);
+	}
+	if ((s & 0x00ff0000)) {
+		IRQ_HANDLE(16);
+		IRQ_HANDLE(17);
+		IRQ_HANDLE(18);
+		IRQ_HANDLE(19);
+		IRQ_HANDLE(20);
+		IRQ_HANDLE(21);
+		IRQ_HANDLE(22);
+		IRQ_HANDLE(23);
+	}
+	if ((s & 0xff000000)) {
+		IRQ_HANDLE(24);
+		IRQ_HANDLE(25);
+		IRQ_HANDLE(26);
+		IRQ_HANDLE(27);
+		IRQ_HANDLE(28);
+		IRQ_HANDLE(29);
+		IRQ_HANDLE(30);
+		IRQ_HANDLE(31);
+	}
+}
+
+#ifdef DDB_USE_MSI_IRQHANDLERS
+static irqreturn_t irq_handler0(int irq, void *dev_id)
+{
+	struct ddb *dev = (struct ddb *) dev_id;
+	u32 s = ddbreadl(dev, INTERRUPT_STATUS);
+
+	do {
+		if (s == 0xffffffff)
+			return IRQ_NONE;
+		if (!(s & 0xfff00))
+			return IRQ_NONE;
+		ddbwritel(dev, s, INTERRUPT_ACK);
+		irq_handle_io(dev, s);
+	} while ((s = ddbreadl(dev, INTERRUPT_STATUS)));
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t irq_handler1(int irq, void *dev_id)
+{
+	struct ddb *dev = (struct ddb *) dev_id;
+	u32 s = ddbreadl(dev, INTERRUPT_STATUS);
+
+	do {
+		if (s & 0x80000000)
+			return IRQ_NONE;
+		if (!(s & 0x0000f))
+			return IRQ_NONE;
+		ddbwritel(dev, s, INTERRUPT_ACK);
+		irq_handle_msg(dev, s);
+	} while ((s = ddbreadl(dev, INTERRUPT_STATUS)));
+
+	return IRQ_HANDLED;
+}
+#endif
+
+static irqreturn_t irq_handler(int irq, void *dev_id)
+{
+	struct ddb *dev = (struct ddb *) dev_id;
+	u32 s = ddbreadl(dev, INTERRUPT_STATUS);
+	int ret = IRQ_HANDLED;
+
+	if (!s)
+		return IRQ_NONE;
+	do {
+		if (s & 0x80000000)
+			return IRQ_NONE;
+		ddbwritel(dev, s, INTERRUPT_ACK);
+
+		if (s & 0x0000000f)
+			irq_handle_msg(dev, s);
+		if (s & 0x0fffff00) {
+			irq_handle_io(dev, s);
+#ifdef DDB_TEST_THREADED
+		ret = IRQ_WAKE_THREAD;
+#endif
+		}
+	} while ((s = ddbreadl(dev, INTERRUPT_STATUS)));
+
+	return ret;
+}
+
+#ifdef DDB_TEST_THREADED
+static irqreturn_t irq_thread(int irq, void *dev_id)
+{
+	/* struct ddb *dev = (struct ddb *) dev_id; */
+
+	/*pr_info("%s\n", __func__);*/
+
+	return IRQ_HANDLED;
+}
+#endif
+
+/****************************************************************************/
+/****************************************************************************/
+/****************************************************************************/
+
+static ssize_t nsd_read(struct file *file, char *buf,
+			size_t count, loff_t *ppos)
+{
+	return 0;
+}
+
+static unsigned int nsd_poll(struct file *file, poll_table *wait)
+{
+	return 0;
+}
+
+static int nsd_release(struct inode *inode, struct file *file)
+{
+	return dvb_generic_release(inode, file);
+}
+
+static int nsd_open(struct inode *inode, struct file *file)
+{
+	return dvb_generic_open(inode, file);
+}
+
+static struct ddb_input *plugtoinput(struct ddb *dev, u8 plug)
+{
+	int i, j;
+
+	for (i = j = 0; i < dev->port_num; i++) {
+		if (dev->port[i].class == DDB_PORT_TUNER) {
+			if (j == plug)
+				return dev->port[i].input[0];
+			if (j + 1 == plug)
+				return dev->port[i].input[1];
+			j += 2;
+		}
+	}
+	return 0;
+}
+
+static int nsd_do_ioctl(struct file *file, unsigned int cmd, void *parg)
+{
+	struct dvb_device *dvbdev = file->private_data;
+	struct ddb *dev = dvbdev->priv;
+
+	/* unsigned long arg = (unsigned long) parg; */
+	int ret = 0;
+
+	switch (cmd) {
+	case NSD_START_GET_TS:
+	{
+		struct dvb_nsd_ts *ts = parg;
+		struct ddb_input *input = plugtoinput(dev, ts->input);
+		u32 ctrl;
+		u32 to;
+
+		if (!input)
+			return -EINVAL;
+		ctrl = (input->port->lnr << 16) | ((input->nr & 7) << 8) |
+			((ts->filter_mask & 3) << 2);
+		if (ddbreadl(dev, TS_CAPTURE_CONTROL) & 1) {
+			pr_info("ts capture busy\n");
+			return -EBUSY;
+		}
+		ddb_dvb_ns_input_start(input);
+
+		ddbwritel(dev, ctrl, TS_CAPTURE_CONTROL);
+		ddbwritel(dev, ts->pid, TS_CAPTURE_PID);
+		ddbwritel(dev, (ts->section_id << 16) |
+			  (ts->table << 8) | ts->section,
+			  TS_CAPTURE_TABLESECTION);
+		/* 1024 ms default timeout if timeout set to 0 */
+		if (ts->timeout)
+			to = ts->timeout;
+		else
+			to = 1024;
+		/* 21 packets default if num set to 0 */
+		if (ts->num)
+			to |= ((u32) ts->num << 16);
+		else
+			to |= (21 << 16);
+		ddbwritel(dev, to, TS_CAPTURE_TIMEOUT);
+		if (ts->mode)
+			ctrl |= 2;
+		ddbwritel(dev, ctrl | 1, TS_CAPTURE_CONTROL);
+		break;
+	}
+	case NSD_POLL_GET_TS:
+	{
+		struct dvb_nsd_ts *ts = parg;
+		u32 ctrl = ddbreadl(dev, TS_CAPTURE_CONTROL);
+
+		if (ctrl & 1)
+			return -EBUSY;
+		if (ctrl & (1 << 14)) {
+			/*pr_info("ts capture timeout\n");*/
+			return -EAGAIN;
+		}
+		ddbcpyfrom(dev, dev->tsbuf, TS_CAPTURE_MEMORY,
+			   TS_CAPTURE_LEN);
+		ts->len = ddbreadl(dev, TS_CAPTURE_RECEIVED) & 0x1fff;
+		if (copy_to_user(ts->ts, dev->tsbuf, ts->len))
+			return -EIO;
+		break;
+	}
+	case NSD_CANCEL_GET_TS:
+	{
+		u32 ctrl = 0;
+
+		/*pr_info("cancel ts capture: 0x%x\n", ctrl);*/
+		ddbwritel(dev, ctrl, TS_CAPTURE_CONTROL);
+		ctrl = ddbreadl(dev, TS_CAPTURE_CONTROL);
+		/*pr_info("control register is 0x%x\n", ctrl);*/
+		break;
+	}
+	case NSD_STOP_GET_TS:
+	{
+		struct dvb_nsd_ts *ts = parg;
+		struct ddb_input *input = plugtoinput(dev, ts->input);
+		u32 ctrl = ddbreadl(dev, TS_CAPTURE_CONTROL);
+
+		if (!input)
+			return -EINVAL;
+		if (ctrl & 1) {
+			pr_info("cannot stop ts capture, while it was neither finished not canceled\n");
+			return -EBUSY;
+		}
+		/*pr_info("ts capture stopped\n");*/
+		ddb_dvb_ns_input_stop(input);
+		break;
+	}
+	default:
+		ret = -EINVAL;
+		break;
+	}
+	return ret;
+}
+
+static long nsd_ioctl(struct file *file,
+		      unsigned int cmd, unsigned long arg)
+{
+	return dvb_usercopy(file, cmd, arg, nsd_do_ioctl);
+}
+
+static const struct file_operations nsd_fops = {
+	.owner   = THIS_MODULE,
+	.read    = nsd_read,
+	.open    = nsd_open,
+	.release = nsd_release,
+	.poll    = nsd_poll,
+	.unlocked_ioctl = nsd_ioctl,
+};
+
+static struct dvb_device dvbdev_nsd = {
+	.priv    = 0,
+	.readers = 1,
+	.writers = 1,
+	.users   = 1,
+	.fops    = &nsd_fops,
+};
+
+static int ddb_nsd_attach(struct ddb *dev)
+{
+	int ret;
+
+	if (!dev->link[0].info->ns_num)
+		return 0;
+	ret = dvb_register_device(&dev->adap[0],
+				  &dev->nsd_dev,
+				  &dvbdev_nsd, (void *) dev,
+				  DVB_DEVICE_NSD, 0);
+	return ret;
+}
+
+static void ddb_nsd_detach(struct ddb *dev)
+{
+	if (!dev->link[0].info->ns_num)
+		return;
+
+	if (dev->nsd_dev->users > 2) {
+		wait_event(dev->nsd_dev->wait_queue,
+			   dev->nsd_dev->users == 2);
+	}
+	dvb_unregister_device(dev->nsd_dev);
+}
+
+
+/****************************************************************************/
+/****************************************************************************/
+/****************************************************************************/
+
+static int reg_wait(struct ddb *dev, u32 reg, u32 bit)
+{
+	u32 count = 0;
+
+	while (ddbreadl(dev, reg) & bit) {
+		ndelay(10);
+		if (++count == 100)
+			return -1;
+	}
+	return 0;
+}
+
+static int flashio(struct ddb *dev, u32 lnr, u8 *wbuf, u32 wlen, u8 *rbuf,
+	u32 rlen)
+{
+	u32 data, shift;
+	u32 tag = DDB_LINK_TAG(lnr);
+	struct ddb_link *link = &dev->link[lnr];
+
+	mutex_lock(&link->flash_mutex);
+	if (wlen > 4)
+		ddbwritel(dev, 1, tag | SPI_CONTROL);
+	while (wlen > 4) {
+		/* FIXME: check for big-endian */
+		data = swab32(*(u32 *) wbuf);
+		wbuf += 4;
+		wlen -= 4;
+		ddbwritel(dev, data, tag | SPI_DATA);
+		if (reg_wait(dev, tag | SPI_CONTROL, 4))
+			goto fail;
+	}
+	if (rlen)
+		ddbwritel(dev, 0x0001 | ((wlen << (8 + 3)) & 0x1f00),
+			  tag | SPI_CONTROL);
+	else
+		ddbwritel(dev, 0x0003 | ((wlen << (8 + 3)) & 0x1f00),
+			  tag | SPI_CONTROL);
+
+	data = 0;
+	shift = ((4 - wlen) * 8);
+	while (wlen) {
+		data <<= 8;
+		data |= *wbuf;
+		wlen--;
+		wbuf++;
+	}
+	if (shift)
+		data <<= shift;
+	ddbwritel(dev, data, tag | SPI_DATA);
+	if (reg_wait(dev, tag | SPI_CONTROL, 4))
+		goto fail;
+
+	if (!rlen) {
+		ddbwritel(dev, 0, tag | SPI_CONTROL);
+		goto exit;
+	}
+	if (rlen > 4)
+		ddbwritel(dev, 1, tag | SPI_CONTROL);
+
+	while (rlen > 4) {
+		ddbwritel(dev, 0xffffffff, tag | SPI_DATA);
+		if (reg_wait(dev, tag | SPI_CONTROL, 4))
+			goto fail;
+		data = ddbreadl(dev, tag | SPI_DATA);
+		*(u32 *) rbuf = swab32(data);
+		rbuf += 4;
+		rlen -= 4;
+	}
+	ddbwritel(dev, 0x0003 | ((rlen << (8 + 3)) & 0x1F00),
+		tag | SPI_CONTROL);
+	ddbwritel(dev, 0xffffffff, tag | SPI_DATA);
+	if (reg_wait(dev, tag | SPI_CONTROL, 4))
+		goto fail;
+
+	data = ddbreadl(dev, tag | SPI_DATA);
+	ddbwritel(dev, 0, tag | SPI_CONTROL);
+
+	if (rlen < 4)
+		data <<= ((4 - rlen) * 8);
+
+	while (rlen > 0) {
+		*rbuf = ((data >> 24) & 0xff);
+		data <<= 8;
+		rbuf++;
+		rlen--;
+	}
+exit:
+	mutex_unlock(&link->flash_mutex);
+	return 0;
+fail:
+	mutex_unlock(&link->flash_mutex);
+	return -1;
+}
+
+int ddbridge_flashread(struct ddb *dev, u32 link, u8 *buf, u32 addr, u32 len)
+{
+	u8 cmd[4] = {0x03, (addr >> 16) & 0xff,
+		     (addr >> 8) & 0xff, addr & 0xff};
+
+	return flashio(dev, link, cmd, 4, buf, len);
+}
+
+static int mdio_write(struct ddb *dev, u8 adr, u8 reg, u16 val)
+{
+	ddbwritel(dev, adr, MDIO_ADR);
+	ddbwritel(dev, reg, MDIO_REG);
+	ddbwritel(dev, val, MDIO_VAL);
+	ddbwritel(dev, 0x03, MDIO_CTRL);
+	while (ddbreadl(dev, MDIO_CTRL) & 0x02)
+		ndelay(500);
+	return 0;
+}
+
+static u16 mdio_read(struct ddb *dev, u8 adr, u8 reg)
+{
+	ddbwritel(dev, adr, MDIO_ADR);
+	ddbwritel(dev, reg, MDIO_REG);
+	ddbwritel(dev, 0x07, MDIO_CTRL);
+	while (ddbreadl(dev, MDIO_CTRL) & 0x02)
+		ndelay(500);
+	return ddbreadl(dev, MDIO_VAL);
+}
+
+#define DDB_MAGIC 'd'
+
+struct ddb_flashio {
+	__u8 *write_buf;
+	__u32 write_len;
+	__u8 *read_buf;
+	__u32 read_len;
+	__u32 link;
+};
+
+struct ddb_gpio {
+	__u32 mask;
+	__u32 data;
+};
+
+struct ddb_id {
+	__u16 vendor;
+	__u16 device;
+	__u16 subvendor;
+	__u16 subdevice;
+	__u32 hw;
+	__u32 regmap;
+};
+
+struct ddb_reg {
+	__u32 reg;
+	__u32 val;
+};
+
+struct ddb_mem {
+	__u32  off;
+	__u8  *buf;
+	__u32  len;
+};
+
+struct ddb_mdio {
+	__u8   adr;
+	__u8   reg;
+	__u16  val;
+};
+
+struct ddb_i2c_msg {
+	__u8   bus;
+	__u8   adr;
+	__u8  *hdr;
+	__u32  hlen;
+	__u8  *msg;
+	__u32  mlen;
+};
+
+#define IOCTL_DDB_FLASHIO    _IOWR(DDB_MAGIC, 0x00, struct ddb_flashio)
+#define IOCTL_DDB_GPIO_IN    _IOWR(DDB_MAGIC, 0x01, struct ddb_gpio)
+#define IOCTL_DDB_GPIO_OUT   _IOWR(DDB_MAGIC, 0x02, struct ddb_gpio)
+#define IOCTL_DDB_ID         _IOR(DDB_MAGIC, 0x03, struct ddb_id)
+#define IOCTL_DDB_READ_REG   _IOWR(DDB_MAGIC, 0x04, struct ddb_reg)
+#define IOCTL_DDB_WRITE_REG  _IOW(DDB_MAGIC, 0x05, struct ddb_reg)
+#define IOCTL_DDB_READ_MEM   _IOWR(DDB_MAGIC, 0x06, struct ddb_mem)
+#define IOCTL_DDB_WRITE_MEM  _IOR(DDB_MAGIC, 0x07, struct ddb_mem)
+#define IOCTL_DDB_READ_MDIO  _IOWR(DDB_MAGIC, 0x08, struct ddb_mdio)
+#define IOCTL_DDB_WRITE_MDIO _IOR(DDB_MAGIC, 0x09, struct ddb_mdio)
+#define IOCTL_DDB_READ_I2C   _IOWR(DDB_MAGIC, 0x0a, struct ddb_i2c_msg)
+#define IOCTL_DDB_WRITE_I2C  _IOR(DDB_MAGIC, 0x0b, struct ddb_i2c_msg)
+
+#define DDB_NAME "ddbridge"
+
+static u32 ddb_num;
+static int ddb_major;
+static DEFINE_MUTEX(ddb_mutex);
+
+static int ddb_release(struct inode *inode, struct file *file)
+{
+	struct ddb *dev = file->private_data;
+
+	dev->ddb_dev_users--;
+	return 0;
+}
+
+static int ddb_open(struct inode *inode, struct file *file)
+{
+	struct ddb *dev = ddbs[iminor(inode)];
+
+	if (dev->ddb_dev_users)
+		return -EBUSY;
+	dev->ddb_dev_users++;
+	file->private_data = dev;
+	return 0;
+}
+
+static long ddb_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	struct ddb *dev = file->private_data;
+	void *parg = (void *)arg;
+	int res;
+
+	switch (cmd) {
+	case IOCTL_DDB_FLASHIO:
+	{
+		struct ddb_flashio fio;
+		u8 *rbuf, *wbuf;
+
+		if (copy_from_user(&fio, parg, sizeof(fio)))
+			return -EFAULT;
+		if (fio.write_len > 1028 || fio.read_len > 1028)
+			return -EINVAL;
+		if (fio.write_len + fio.read_len > 1028)
+			return -EINVAL;
+		if (fio.link > 3)
+			return -EINVAL;
+
+		wbuf = &dev->iobuf[0];
+		rbuf = wbuf + fio.write_len;
+
+		if (copy_from_user(wbuf, fio.write_buf, fio.write_len))
+			return -EFAULT;
+		res = flashio(dev, fio.link, wbuf, fio.write_len, rbuf,
+			fio.read_len);
+		if (res)
+			return res;
+		if (copy_to_user(fio.read_buf, rbuf, fio.read_len))
+			return -EFAULT;
+		break;
+	}
+	case IOCTL_DDB_GPIO_OUT:
+	{
+		struct ddb_gpio gpio;
+
+		if (copy_from_user(&gpio, parg, sizeof(gpio)))
+			return -EFAULT;
+		ddbwritel(dev, gpio.mask, GPIO_DIRECTION);
+		ddbwritel(dev, gpio.data, GPIO_OUTPUT);
+		break;
+	}
+	case IOCTL_DDB_ID:
+	{
+		struct ddb_id ddbid;
+
+		ddbid.vendor = dev->link[0].ids.vendor;
+		ddbid.device = dev->link[0].ids.device;
+		ddbid.subvendor = dev->link[0].ids.subvendor;
+		ddbid.subdevice = dev->link[0].ids.subdevice;
+		ddbid.hw = ddbreadl(dev, 0);
+		ddbid.regmap = ddbreadl(dev, 4);
+		if (copy_to_user(parg, &ddbid, sizeof(ddbid)))
+			return -EFAULT;
+		break;
+	}
+	case IOCTL_DDB_READ_REG:
+	{
+		struct ddb_reg reg;
+
+		if (copy_from_user(&reg, parg, sizeof(reg)))
+			return -EFAULT;
+		if ((reg.reg & 0xfffffff) >= dev->regs_len)
+			return -EINVAL;
+		reg.val = ddbreadl(dev, reg.reg);
+		if (copy_to_user(parg, &reg, sizeof(reg)))
+			return -EFAULT;
+		break;
+	}
+	case IOCTL_DDB_WRITE_REG:
+	{
+		struct ddb_reg reg;
+
+		if (copy_from_user(&reg, parg, sizeof(reg)))
+			return -EFAULT;
+		if ((reg.reg & 0xfffffff) >= dev->regs_len)
+			return -EINVAL;
+		ddbwritel(dev, reg.val, reg.reg);
+		break;
+	}
+	case IOCTL_DDB_READ_MDIO:
+	{
+		struct ddb_mdio mdio;
+
+		if (!dev->link[0].info->mdio_num)
+			return -EIO;
+		if (copy_from_user(&mdio, parg, sizeof(mdio)))
+			return -EFAULT;
+		mdio.val = mdio_read(dev, mdio.adr, mdio.reg);
+		if (copy_to_user(parg, &mdio, sizeof(mdio)))
+			return -EFAULT;
+		break;
+	}
+	case IOCTL_DDB_WRITE_MDIO:
+	{
+		struct ddb_mdio mdio;
+
+		if (!dev->link[0].info->mdio_num)
+			return -EIO;
+		if (copy_from_user(&mdio, parg, sizeof(mdio)))
+			return -EFAULT;
+		mdio_write(dev, mdio.adr, mdio.reg, mdio.val);
+		break;
+	}
+	case IOCTL_DDB_READ_MEM:
+	{
+		struct ddb_mem mem;
+		u8 *buf = &dev->iobuf[0];
+
+		if (copy_from_user(&mem, parg, sizeof(mem)))
+			return -EFAULT;
+		if ((((mem.len + mem.off) & 0xfffffff) > dev->regs_len) ||
+		    mem.len > 1024)
+			return -EINVAL;
+		ddbcpyfrom(dev, buf, mem.off, mem.len);
+		if (copy_to_user(mem.buf, buf, mem.len))
+			return -EFAULT;
+		break;
+	}
+	case IOCTL_DDB_WRITE_MEM:
+	{
+		struct ddb_mem mem;
+		u8 *buf = &dev->iobuf[0];
+
+		if (copy_from_user(&mem, parg, sizeof(mem)))
+			return -EFAULT;
+		if ((((mem.len + mem.off) & 0xfffffff) > dev->regs_len) ||
+		    mem.len > 1024)
+			return -EINVAL;
+		if (copy_from_user(buf, mem.buf, mem.len))
+			return -EFAULT;
+		ddbcpyto(dev, mem.off, buf, mem.len);
 		break;
 	}
-	input->attached = 5;
-	return 0;
-}
+	case IOCTL_DDB_READ_I2C:
+	{
+		struct ddb_i2c_msg i2c;
+		struct i2c_adapter *adap;
+		u8 *mbuf, *hbuf = &dev->iobuf[0];
 
-/****************************************************************************/
-/****************************************************************************/
+		if (copy_from_user(&i2c, parg, sizeof(i2c)))
+			return -EFAULT;
+		if (i2c.bus > dev->link[0].info->regmap->i2c->num)
+			return -EINVAL;
+		if (i2c.mlen + i2c.hlen > 512)
+			return -EINVAL;
 
-static ssize_t ts_write(struct file *file, const __user char *buf,
-			size_t count, loff_t *ppos)
-{
-	struct dvb_device *dvbdev = file->private_data;
-	struct ddb_output *output = dvbdev->priv;
-	size_t left = count;
-	int stat;
+		adap = &dev->i2c[i2c.bus].adap;
+		mbuf = hbuf + i2c.hlen;
 
-	while (left) {
-		if (ddb_output_free(output) < 188) {
-			if (file->f_flags & O_NONBLOCK)
-				break;
-			if (wait_event_interruptible(
-				    output->wq, ddb_output_free(output) >= 188) < 0)
-				break;
-		}
-		stat = ddb_output_write(output, buf, left);
-		if (stat < 0)
-			break;
-		buf += stat;
-		left -= stat;
+
+		if (copy_from_user(hbuf, i2c.hdr, i2c.hlen))
+			return -EFAULT;
+		if (i2c_io(adap, i2c.adr, hbuf, i2c.hlen, mbuf, i2c.mlen) < 0)
+			return -EIO;
+		if (copy_to_user(i2c.msg, mbuf, i2c.mlen))
+			return -EFAULT;
+		break;
 	}
-	return (left == count) ? -EAGAIN : (count - left);
-}
+	case IOCTL_DDB_WRITE_I2C:
+	{
+		struct ddb_i2c_msg i2c;
+		struct i2c_adapter *adap;
+		u8 *buf = &dev->iobuf[0];
 
-static ssize_t ts_read(struct file *file, __user char *buf,
-		       size_t count, loff_t *ppos)
-{
-	struct dvb_device *dvbdev = file->private_data;
-	struct ddb_output *output = dvbdev->priv;
-	struct ddb_input *input = output->port->input[0];
-	int left, read;
+		if (copy_from_user(&i2c, parg, sizeof(i2c)))
+			return -EFAULT;
+		if (i2c.bus > dev->link[0].info->regmap->i2c->num)
+			return -EINVAL;
+		if (i2c.mlen + i2c.hlen > 250)
+			return -EINVAL;
 
-	count -= count % 188;
-	left = count;
-	while (left) {
-		if (ddb_input_avail(input) < 188) {
-			if (file->f_flags & O_NONBLOCK)
-				break;
-			if (wait_event_interruptible(
-				    input->wq, ddb_input_avail(input) >= 188) < 0)
-				break;
-		}
-		read = ddb_input_read(input, buf, left);
-		if (read < 0)
-			return read;
-		left -= read;
-		buf += read;
+		adap = &dev->i2c[i2c.bus].adap;
+		if (copy_from_user(buf, i2c.hdr, i2c.hlen))
+			return -EFAULT;
+		if (copy_from_user(buf + i2c.hlen, i2c.msg, i2c.mlen))
+			return -EFAULT;
+		if (i2c_write(adap, i2c.adr, buf, i2c.hlen + i2c.mlen) < 0)
+			return -EIO;
+		break;
 	}
-	return (left == count) ? -EAGAIN : (count - left);
+	default:
+		return -ENOTTY;
+	}
+	return 0;
 }
 
-static unsigned int ts_poll(struct file *file, poll_table *wait)
-{
-	/*
-	struct dvb_device *dvbdev = file->private_data;
-	struct ddb_output *output = dvbdev->priv;
-	struct ddb_input *input = output->port->input[0];
-	*/
-	unsigned int mask = 0;
+static const struct file_operations ddb_fops = {
+	.unlocked_ioctl = ddb_ioctl,
+	.open           = ddb_open,
+	.release        = ddb_release,
+};
 
-#if 0
-	if (data_avail_to_read)
-		mask |= POLLIN | POLLRDNORM;
-	if (data_avail_to_write)
-		mask |= POLLOUT | POLLWRNORM;
+static char *ddb_devnode(struct device *device, umode_t *mode)
+{
+	struct ddb *dev = dev_get_drvdata(device);
 
-	poll_wait(file, &read_queue, wait);
-	poll_wait(file, &write_queue, wait);
-#endif
-	return mask;
+	return kasprintf(GFP_KERNEL, "ddbridge/card%d", dev->nr);
 }
 
-static const struct file_operations ci_fops = {
-	.owner   = THIS_MODULE,
-	.read    = ts_read,
-	.write   = ts_write,
-	.open    = dvb_generic_open,
-	.release = dvb_generic_release,
-	.poll    = ts_poll,
-};
-
-static struct dvb_device dvbdev_ci = {
-	.readers = -1,
-	.writers = -1,
-	.users   = -1,
-	.fops    = &ci_fops,
-};
+#define __ATTR_MRO(_name, _show) {				\
+	.attr	= { .name = __stringify(_name), .mode = 0444 },	\
+	.show	= _show,					\
+}
 
-/****************************************************************************/
-/****************************************************************************/
-/****************************************************************************/
+#define __ATTR_MWO(_name, _store) {				\
+	.attr	= { .name = __stringify(_name), .mode = 0222 },	\
+	.store	= _store,					\
+}
 
-static void input_tasklet(unsigned long data)
+static ssize_t ports_show(struct device *device,
+			  struct device_attribute *attr, char *buf)
 {
-	struct ddb_input *input = (struct ddb_input *) data;
-	struct ddb *dev = input->port->dev;
+	struct ddb *dev = dev_get_drvdata(device);
 
-	spin_lock(&input->lock);
-	if (!input->running) {
-		spin_unlock(&input->lock);
-		return;
-	}
-	input->stat = ddbreadl(DMA_BUFFER_CURRENT(input->nr));
+	return sprintf(buf, "%d\n", dev->link[0].info->port_num);
+}
 
-	if (input->port->class == DDB_PORT_TUNER) {
-		if (4&ddbreadl(DMA_BUFFER_CONTROL(input->nr)))
-			printk(KERN_ERR "Overflow input %d\n", input->nr);
-		while (input->cbuf != ((input->stat >> 11) & 0x1f)
-		       || (4&ddbreadl(DMA_BUFFER_CONTROL(input->nr)))) {
-			dvb_dmx_swfilter_packets(&input->demux,
-						 input->vbuf[input->cbuf],
-						 input->dma_buf_size / 188);
+static ssize_t ts_irq_show(struct device *device,
+			   struct device_attribute *attr, char *buf)
+{
+	struct ddb *dev = dev_get_drvdata(device);
 
-			input->cbuf = (input->cbuf + 1) % input->dma_buf_num;
-			ddbwritel((input->cbuf << 11),
-				  DMA_BUFFER_ACK(input->nr));
-			input->stat = ddbreadl(DMA_BUFFER_CURRENT(input->nr));
-		       }
-	}
-	if (input->port->class == DDB_PORT_CI)
-		wake_up(&input->wq);
-	spin_unlock(&input->lock);
+	return sprintf(buf, "%d\n", dev->ts_irq);
 }
 
-static void output_tasklet(unsigned long data)
+static ssize_t i2c_irq_show(struct device *device,
+			    struct device_attribute *attr, char *buf)
 {
-	struct ddb_output *output = (struct ddb_output *) data;
-	struct ddb *dev = output->port->dev;
+	struct ddb *dev = dev_get_drvdata(device);
 
-	spin_lock(&output->lock);
-	if (!output->running) {
-		spin_unlock(&output->lock);
-		return;
-	}
-	output->stat = ddbreadl(DMA_BUFFER_CURRENT(output->nr + 8));
-	wake_up(&output->wq);
-	spin_unlock(&output->lock);
+	return sprintf(buf, "%d\n", dev->i2c_irq);
 }
 
-
-static struct cxd2099_cfg cxd_cfg = {
-	.bitrate =  62000,
-	.adr     =  0x40,
-	.polarity = 1,
-	.clock_mode = 1,
+static char *class_name[] = {
+	"NONE", "CI", "TUNER", "LOOP", "MOD"
 };
 
-static int ddb_ci_attach(struct ddb_port *port)
+static ssize_t fan_show(struct device *device,
+			struct device_attribute *attr, char *buf)
 {
-	int ret;
+	struct ddb *dev = dev_get_drvdata(device);
+	u32 val;
 
-	ret = dvb_register_adapter(&port->output->adap,
-				   "DDBridge",
-				   THIS_MODULE,
-				   &port->dev->pdev->dev,
-				   adapter_nr);
-	if (ret < 0)
-		return ret;
-	port->en = cxd2099_attach(&cxd_cfg, port, &port->i2c->adap);
-	if (!port->en) {
-		dvb_unregister_adapter(&port->output->adap);
-		return -ENODEV;
-	}
-	ddb_input_start(port->input[0]);
-	ddb_output_start(port->output);
-	dvb_ca_en50221_init(&port->output->adap,
-			    port->en, 0, 1);
-	ret = dvb_register_device(&port->output->adap, &port->output->dev,
-				  &dvbdev_ci, (void *) port->output,
-				  DVB_DEVICE_SEC, 0);
-	return ret;
+	val = ddbreadl(dev, GPIO_OUTPUT) & 1;
+	return sprintf(buf, "%d\n", val);
 }
 
-static int ddb_port_attach(struct ddb_port *port)
+static ssize_t fan_store(struct device *device, struct device_attribute *d,
+			 const char *buf, size_t count)
 {
-	int ret = 0;
+	struct ddb *dev = dev_get_drvdata(device);
+	unsigned val;
 
-	switch (port->class) {
-	case DDB_PORT_TUNER:
-		ret = dvb_input_attach(port->input[0]);
-		if (ret < 0)
-			break;
-		ret = dvb_input_attach(port->input[1]);
-		break;
-	case DDB_PORT_CI:
-		ret = ddb_ci_attach(port);
-		break;
-	default:
-		break;
-	}
-	if (ret < 0)
-		printk(KERN_ERR "port_attach on port %d failed\n", port->nr);
-	return ret;
+	if (sscanf(buf, "%u\n", &val) != 1)
+		return -EINVAL;
+	ddbwritel(dev, 1, GPIO_DIRECTION);
+	ddbwritel(dev, val & 1, GPIO_OUTPUT);
+	return count;
 }
 
-static int ddb_ports_attach(struct ddb *dev)
+static ssize_t temp_show(struct device *device,
+			 struct device_attribute *attr, char *buf)
 {
-	int i, ret = 0;
-	struct ddb_port *port;
+	struct ddb *dev = dev_get_drvdata(device);
+	struct i2c_adapter *adap;
+	int temp, temp2, temp3, i;
+	u8 tmp[2];
 
-	for (i = 0; i < dev->info->port_num; i++) {
-		port = &dev->port[i];
-		ret = ddb_port_attach(port);
-		if (ret < 0)
-			break;
+	if (dev->link[0].info->type == DDB_MOD) {
+		ddbwritel(dev, 1, TEMPMON_CONTROL);
+		for (i = 0; i < 10; i++) {
+			if (0 == (1 & ddbreadl(dev, TEMPMON_CONTROL)))
+				break;
+			usleep_range(1000, 2000);
+		}
+		temp = ddbreadl(dev, TEMPMON_SENSOR1);
+		temp2 = ddbreadl(dev, TEMPMON_SENSOR2);
+		temp = (temp * 1000) >> 8;
+		temp2 = (temp2 * 1000) >> 8;
+		if (ddbreadl(dev, TEMPMON_CONTROL) & 0x8000) {
+			temp3 = ddbreadl(dev, TEMPMON_CORE);
+			temp3 = (temp3 * 1000) >> 8;
+			return sprintf(buf, "%d %d %d\n", temp, temp2, temp3);
+		}
+		return sprintf(buf, "%d %d\n", temp, temp2);
 	}
-	return ret;
+	if (!dev->link[0].info->temp_num)
+		return sprintf(buf, "no sensor\n");
+	adap = &dev->i2c[dev->link[0].info->temp_bus].adap;
+	if (i2c_read_regs(adap, 0x48, 0, tmp, 2) < 0)
+		return sprintf(buf, "read_error\n");
+	temp = (tmp[0] << 3) | (tmp[1] >> 5);
+	temp *= 125;
+	if (dev->link[0].info->temp_num == 2) {
+		if (i2c_read_regs(adap, 0x49, 0, tmp, 2) < 0)
+			return sprintf(buf, "read_error\n");
+		temp2 = (tmp[0] << 3) | (tmp[1] >> 5);
+		temp2 *= 125;
+		return sprintf(buf, "%d %d\n", temp, temp2);
+	}
+	return sprintf(buf, "%d\n", temp);
 }
 
-static void ddb_ports_detach(struct ddb *dev)
+static ssize_t ctemp_show(struct device *device,
+		struct device_attribute *attr, char *buf)
 {
-	int i;
-	struct ddb_port *port;
+	struct ddb *dev = dev_get_drvdata(device);
+	struct i2c_adapter *adap;
+	int temp;
+	u8 tmp[2];
+	int num = attr->attr.name[4] - 0x30;
 
-	for (i = 0; i < dev->info->port_num; i++) {
-		port = &dev->port[i];
-		switch (port->class) {
-		case DDB_PORT_TUNER:
-			dvb_input_detach(port->input[0]);
-			dvb_input_detach(port->input[1]);
-			break;
-		case DDB_PORT_CI:
-			dvb_unregister_device(port->output->dev);
-			if (port->en) {
-				ddb_input_stop(port->input[0]);
-				ddb_output_stop(port->output);
-				dvb_ca_en50221_release(port->en);
-				kfree(port->en);
-				port->en = NULL;
-				dvb_unregister_adapter(&port->output->adap);
-			}
-			break;
-		}
-	}
+	adap = &dev->i2c[num].adap;
+	if (!adap)
+		return 0;
+	if (i2c_read_regs(adap, 0x49, 0, tmp, 2) < 0)
+		if (i2c_read_regs(adap, 0x4d, 0, tmp, 2) < 0)
+			return sprintf(buf, "no sensor\n");
+	temp = tmp[0] * 1000;
+	return sprintf(buf, "%d\n", temp);
 }
 
-/****************************************************************************/
-/****************************************************************************/
-
-static int port_has_ci(struct ddb_port *port)
+static ssize_t mod_show(struct device *device,
+			struct device_attribute *attr, char *buf)
 {
-	u8 val;
-	return i2c_read_reg(&port->i2c->adap, 0x40, 0, &val) ? 0 : 1;
+	struct ddb *dev = dev_get_drvdata(device);
+	int num = attr->attr.name[3] - 0x30;
+
+	return sprintf(buf, "%s:%s\n",
+		       class_name[dev->port[num].class],
+		       dev->port[num].type_name);
 }
 
-static int port_has_stv0900(struct ddb_port *port)
+static ssize_t led_show(struct device *device,
+			struct device_attribute *attr, char *buf)
 {
-	u8 val;
-	if (i2c_read_reg16(&port->i2c->adap, 0x69, 0xf100, &val) < 0)
-		return 0;
-	return 1;
+	struct ddb *dev = dev_get_drvdata(device);
+	int num = attr->attr.name[3] - 0x30;
+
+	return sprintf(buf, "%d\n", dev->leds & (1 << num) ? 1 : 0);
 }
 
-static int port_has_stv0900_aa(struct ddb_port *port)
+
+static void ddb_set_led(struct ddb *dev, int num, int val)
 {
-	u8 val;
-	if (i2c_read_reg16(&port->i2c->adap, 0x68, 0xf100, &val) < 0)
-		return 0;
-	return 1;
+	if (!dev->link[0].info->led_num)
+		return;
+	switch (dev->port[num].class) {
+	case DDB_PORT_TUNER:
+		switch (dev->port[num].type) {
+		case DDB_TUNER_DVBS_ST:
+			i2c_write_reg16(&dev->i2c[num].adap,
+					0x69, 0xf14c, val ? 2 : 0);
+			break;
+		case DDB_TUNER_DVBCT_ST:
+			i2c_write_reg16(&dev->i2c[num].adap,
+					0x1f, 0xf00e, 0);
+			i2c_write_reg16(&dev->i2c[num].adap,
+					0x1f, 0xf00f, val ? 1 : 0);
+			break;
+		case DDB_TUNER_XO2 ... DDB_TUNER_DVBC2T2_ST:
+		{
+			u8 v;
+
+			i2c_read_reg(&dev->i2c[num].adap, 0x10, 0x08, &v);
+			v = (v & ~0x10) | (val ? 0x10 : 0);
+			i2c_write_reg(&dev->i2c[num].adap, 0x10, 0x08, v);
+			break;
+		}
+		default:
+			break;
+		}
+		break;
+	}
 }
 
-static int port_has_drxks(struct ddb_port *port)
+static ssize_t led_store(struct device *device,
+			 struct device_attribute *attr,
+			 const char *buf, size_t count)
 {
-	u8 val;
-	if (i2c_read(&port->i2c->adap, 0x29, &val) < 0)
-		return 0;
-	if (i2c_read(&port->i2c->adap, 0x2a, &val) < 0)
-		return 0;
-	return 1;
+	struct ddb *dev = dev_get_drvdata(device);
+	int num = attr->attr.name[3] - 0x30;
+	unsigned val;
+
+	if (sscanf(buf, "%u\n", &val) != 1)
+		return -EINVAL;
+	if (val)
+		dev->leds |= (1 << num);
+	else
+		dev->leds &= ~(1 << num);
+	ddb_set_led(dev, num, val);
+	return count;
 }
 
-static void ddb_port_probe(struct ddb_port *port)
+static ssize_t snr_show(struct device *device,
+			struct device_attribute *attr, char *buf)
 {
-	struct ddb *dev = port->dev;
-	char *modname = "NO MODULE";
-
-	port->class = DDB_PORT_NONE;
+	struct ddb *dev = dev_get_drvdata(device);
+	char snr[32];
+	int num = attr->attr.name[3] - 0x30;
 
-	if (port_has_ci(port)) {
-		modname = "CI";
-		port->class = DDB_PORT_CI;
-		ddbwritel(I2C_SPEED_400, port->i2c->regs + I2C_TIMING);
-	} else if (port_has_stv0900(port)) {
-		modname = "DUAL DVB-S2";
-		port->class = DDB_PORT_TUNER;
-		port->type = DDB_TUNER_DVBS_ST;
-		ddbwritel(I2C_SPEED_100, port->i2c->regs + I2C_TIMING);
-	} else if (port_has_stv0900_aa(port)) {
-		modname = "DUAL DVB-S2";
-		port->class = DDB_PORT_TUNER;
-		port->type = DDB_TUNER_DVBS_ST_AA;
-		ddbwritel(I2C_SPEED_100, port->i2c->regs + I2C_TIMING);
-	} else if (port_has_drxks(port)) {
-		modname = "DUAL DVB-C/T";
-		port->class = DDB_PORT_TUNER;
-		port->type = DDB_TUNER_DVBCT_TR;
-		ddbwritel(I2C_SPEED_400, port->i2c->regs + I2C_TIMING);
+	if (dev->port[num].type >= DDB_TUNER_XO2) {
+		if (i2c_read_regs(&dev->i2c[num].adap, 0x10, 0x10, snr, 16) < 0)
+			return sprintf(buf, "NO SNR\n");
+		snr[16] = 0;
+	} else {
+		/* serial number at 0x100-0x11f */
+		if (i2c_read_regs16(&dev->i2c[num].adap,
+				    0x57, 0x100, snr, 32) < 0)
+			if (i2c_read_regs16(&dev->i2c[num].adap,
+					    0x50, 0x100, snr, 32) < 0)
+				return sprintf(buf, "NO SNR\n");
+		snr[31] = 0; /* in case it is not terminated on EEPROM */
 	}
-	printk(KERN_INFO "Port %d (TAB %d): %s\n",
-			 port->nr, port->nr+1, modname);
+	return sprintf(buf, "%s\n", snr);
 }
 
-static void ddb_input_init(struct ddb_port *port, int nr)
-{
-	struct ddb *dev = port->dev;
-	struct ddb_input *input = &dev->input[nr];
 
-	input->nr = nr;
-	input->port = port;
-	input->dma_buf_num = INPUT_DMA_BUFS;
-	input->dma_buf_size = INPUT_DMA_SIZE;
-	ddbwritel(0, TS_INPUT_CONTROL(nr));
-	ddbwritel(2, TS_INPUT_CONTROL(nr));
-	ddbwritel(0, TS_INPUT_CONTROL(nr));
-	ddbwritel(0, DMA_BUFFER_ACK(nr));
-	tasklet_init(&input->tasklet, input_tasklet, (unsigned long) input);
-	spin_lock_init(&input->lock);
-	init_waitqueue_head(&input->wq);
+static ssize_t snr_store(struct device *device, struct device_attribute *attr,
+			 const char *buf, size_t count)
+{
+	struct ddb *dev = dev_get_drvdata(device);
+	int num = attr->attr.name[3] - 0x30;
+	u8 snr[34] = { 0x01, 0x00 };
+
+	return 0; /* NOE: remove completely? */
+	if (count > 31)
+		return -EINVAL;
+	if (dev->port[num].type >= DDB_TUNER_XO2)
+		return -EINVAL;
+	memcpy(snr + 2, buf, count);
+	i2c_write(&dev->i2c[num].adap, 0x57, snr, 34);
+	i2c_write(&dev->i2c[num].adap, 0x50, snr, 34);
+	return count;
 }
 
-static void ddb_output_init(struct ddb_port *port, int nr)
+static ssize_t bsnr_show(struct device *device,
+			 struct device_attribute *attr, char *buf)
 {
-	struct ddb *dev = port->dev;
-	struct ddb_output *output = &dev->output[nr];
-	output->nr = nr;
-	output->port = port;
-	output->dma_buf_num = OUTPUT_DMA_BUFS;
-	output->dma_buf_size = OUTPUT_DMA_SIZE;
+	struct ddb *dev = dev_get_drvdata(device);
+	char snr[16];
 
-	ddbwritel(0, TS_OUTPUT_CONTROL(nr));
-	ddbwritel(2, TS_OUTPUT_CONTROL(nr));
-	ddbwritel(0, TS_OUTPUT_CONTROL(nr));
-	tasklet_init(&output->tasklet, output_tasklet, (unsigned long) output);
-	init_waitqueue_head(&output->wq);
+	ddbridge_flashread(dev, 0, snr, 0x10, 15);
+	snr[15] = 0; /* in case it is not terminated on EEPROM */
+	return sprintf(buf, "%s\n", snr);
 }
 
-static void ddb_ports_init(struct ddb *dev)
+static ssize_t bpsnr_show(struct device *device,
+			 struct device_attribute *attr, char *buf)
 {
-	int i;
-	struct ddb_port *port;
+	struct ddb *dev = dev_get_drvdata(device);
+	char snr[32];
 
-	for (i = 0; i < dev->info->port_num; i++) {
-		port = &dev->port[i];
-		port->dev = dev;
-		port->nr = i;
-		port->i2c = &dev->i2c[i];
-		port->input[0] = &dev->input[2 * i];
-		port->input[1] = &dev->input[2 * i + 1];
-		port->output = &dev->output[i];
+	if (!dev->i2c_num)
+		return 0;
 
-		mutex_init(&port->i2c_gate_lock);
-		ddb_port_probe(port);
-		ddb_input_init(port, 2 * i);
-		ddb_input_init(port, 2 * i + 1);
-		ddb_output_init(port, i);
-	}
+	if (i2c_read_regs16(&dev->i2c[0].adap,
+			    0x50, 0x0000, snr, 32) < 0 ||
+	    snr[0] == 0xff)
+		return sprintf(buf, "NO SNR\n");
+	snr[31] = 0; /* in case it is not terminated on EEPROM */
+	return sprintf(buf, "%s\n", snr);
 }
 
-static void ddb_ports_release(struct ddb *dev)
+static ssize_t redirect_show(struct device *device,
+			     struct device_attribute *attr, char *buf)
 {
-	int i;
-	struct ddb_port *port;
-
-	for (i = 0; i < dev->info->port_num; i++) {
-		port = &dev->port[i];
-		port->dev = dev;
-		tasklet_kill(&port->input[0]->tasklet);
-		tasklet_kill(&port->input[1]->tasklet);
-		tasklet_kill(&port->output->tasklet);
-	}
+	return 0;
 }
 
-/****************************************************************************/
-/****************************************************************************/
-/****************************************************************************/
-
-static void irq_handle_i2c(struct ddb *dev, int n)
+static ssize_t redirect_store(struct device *device,
+			      struct device_attribute *attr,
+			      const char *buf, size_t count)
 {
-	struct ddb_i2c *i2c = &dev->i2c[n];
+	unsigned int i, p;
+	int res;
 
-	i2c->done = 1;
-	wake_up(&i2c->wq);
+	if (sscanf(buf, "%x %x\n", &i, &p) != 2)
+		return -EINVAL;
+	res = ddb_redirect(i, p);
+	if (res < 0)
+		return res;
+	pr_info("redirect: %02x, %02x\n", i, p);
+	return count;
 }
 
-static irqreturn_t irq_handler(int irq, void *dev_id)
+static ssize_t gap_show(struct device *device,
+			struct device_attribute *attr, char *buf)
 {
-	struct ddb *dev = (struct ddb *) dev_id;
-	u32 s = ddbreadl(INTERRUPT_STATUS);
-
-	if (!s)
-		return IRQ_NONE;
+	struct ddb *dev = dev_get_drvdata(device);
+	int num = attr->attr.name[3] - 0x30;
 
-	do {
-		ddbwritel(s, INTERRUPT_ACK);
-
-		if (s & 0x00000001)
-			irq_handle_i2c(dev, 0);
-		if (s & 0x00000002)
-			irq_handle_i2c(dev, 1);
-		if (s & 0x00000004)
-			irq_handle_i2c(dev, 2);
-		if (s & 0x00000008)
-			irq_handle_i2c(dev, 3);
-
-		if (s & 0x00000100)
-			tasklet_schedule(&dev->input[0].tasklet);
-		if (s & 0x00000200)
-			tasklet_schedule(&dev->input[1].tasklet);
-		if (s & 0x00000400)
-			tasklet_schedule(&dev->input[2].tasklet);
-		if (s & 0x00000800)
-			tasklet_schedule(&dev->input[3].tasklet);
-		if (s & 0x00001000)
-			tasklet_schedule(&dev->input[4].tasklet);
-		if (s & 0x00002000)
-			tasklet_schedule(&dev->input[5].tasklet);
-		if (s & 0x00004000)
-			tasklet_schedule(&dev->input[6].tasklet);
-		if (s & 0x00008000)
-			tasklet_schedule(&dev->input[7].tasklet);
-
-		if (s & 0x00010000)
-			tasklet_schedule(&dev->output[0].tasklet);
-		if (s & 0x00020000)
-			tasklet_schedule(&dev->output[1].tasklet);
-		if (s & 0x00040000)
-			tasklet_schedule(&dev->output[2].tasklet);
-		if (s & 0x00080000)
-			tasklet_schedule(&dev->output[3].tasklet);
-
-		/* if (s & 0x000f0000)	printk(KERN_DEBUG "%08x\n", istat); */
-	} while ((s = ddbreadl(INTERRUPT_STATUS)));
+	return sprintf(buf, "%d\n", dev->port[num].gap);
 
-	return IRQ_HANDLED;
 }
 
-/******************************************************************************/
-/******************************************************************************/
-/******************************************************************************/
-
-static int flashio(struct ddb *dev, u8 *wbuf, u32 wlen, u8 *rbuf, u32 rlen)
+static ssize_t gap_store(struct device *device, struct device_attribute *attr,
+			 const char *buf, size_t count)
 {
-	u32 data, shift;
-
-	if (wlen > 4)
-		ddbwritel(1, SPI_CONTROL);
-	while (wlen > 4) {
-		/* FIXME: check for big-endian */
-		data = swab32(*(u32 *)wbuf);
-		wbuf += 4;
-		wlen -= 4;
-		ddbwritel(data, SPI_DATA);
-		while (ddbreadl(SPI_CONTROL) & 0x0004)
-			;
-	}
-
-	if (rlen)
-		ddbwritel(0x0001 | ((wlen << (8 + 3)) & 0x1f00), SPI_CONTROL);
-	else
-		ddbwritel(0x0003 | ((wlen << (8 + 3)) & 0x1f00), SPI_CONTROL);
+	struct ddb *dev = dev_get_drvdata(device);
+	int num = attr->attr.name[3] - 0x30;
+	unsigned int val;
+
+	if (sscanf(buf, "%u\n", &val) != 1)
+		return -EINVAL;
+	if (val > 20)
+		return -EINVAL;
+	dev->port[num].gap = val;
+	return count;
+}
 
-	data = 0;
-	shift = ((4 - wlen) * 8);
-	while (wlen) {
-		data <<= 8;
-		data |= *wbuf;
-		wlen--;
-		wbuf++;
-	}
-	if (shift)
-		data <<= shift;
-	ddbwritel(data, SPI_DATA);
-	while (ddbreadl(SPI_CONTROL) & 0x0004)
-		;
+static ssize_t version_show(struct device *device,
+			    struct device_attribute *attr, char *buf)
+{
+	struct ddb *dev = dev_get_drvdata(device);
 
-	if (!rlen) {
-		ddbwritel(0, SPI_CONTROL);
-		return 0;
-	}
-	if (rlen > 4)
-		ddbwritel(1, SPI_CONTROL);
+	return sprintf(buf, "%08x %08x\n",
+		       dev->link[0].ids.hwid, dev->link[0].ids.regmapid);
+}
 
-	while (rlen > 4) {
-		ddbwritel(0xffffffff, SPI_DATA);
-		while (ddbreadl(SPI_CONTROL) & 0x0004)
-			;
-		data = ddbreadl(SPI_DATA);
-		*(u32 *) rbuf = swab32(data);
-		rbuf += 4;
-		rlen -= 4;
-	}
-	ddbwritel(0x0003 | ((rlen << (8 + 3)) & 0x1F00), SPI_CONTROL);
-	ddbwritel(0xffffffff, SPI_DATA);
-	while (ddbreadl(SPI_CONTROL) & 0x0004)
-		;
+static ssize_t hwid_show(struct device *device,
+			 struct device_attribute *attr, char *buf)
+{
+	struct ddb *dev = dev_get_drvdata(device);
 
-	data = ddbreadl(SPI_DATA);
-	ddbwritel(0, SPI_CONTROL);
+	return sprintf(buf, "0x%08X\n", dev->link[0].ids.hwid);
+}
 
-	if (rlen < 4)
-		data <<= ((4 - rlen) * 8);
+static ssize_t regmap_show(struct device *device,
+			   struct device_attribute *attr, char *buf)
+{
+	struct ddb *dev = dev_get_drvdata(device);
 
-	while (rlen > 0) {
-		*rbuf = ((data >> 24) & 0xff);
-		data <<= 8;
-		rbuf++;
-		rlen--;
-	}
-	return 0;
+	return sprintf(buf, "0x%08X\n", dev->link[0].ids.regmapid);
 }
 
-#define DDB_MAGIC 'd'
+static ssize_t vlan_show(struct device *device,
+			 struct device_attribute *attr, char *buf)
+{
+	struct ddb *dev = dev_get_drvdata(device);
 
-struct ddb_flashio {
-	__user __u8 *write_buf;
-	__u32 write_len;
-	__user __u8 *read_buf;
-	__u32 read_len;
-};
+	return sprintf(buf, "%u\n", dev->vlan);
+}
 
-#define IOCTL_DDB_FLASHIO  _IOWR(DDB_MAGIC, 0x00, struct ddb_flashio)
+static ssize_t vlan_store(struct device *device, struct device_attribute *attr,
+			  const char *buf, size_t count)
+{
+	struct ddb *dev = dev_get_drvdata(device);
+	unsigned int val;
+
+	if (sscanf(buf, "%u\n", &val) != 1)
+		return -EINVAL;
+	if (val > 1)
+		return -EINVAL;
+	if (!dev->link[0].info->ns_num)
+		return -EINVAL;
+	ddbwritel(dev, 14 + (val ? 4 : 0), ETHER_LENGTH);
+	dev->vlan = val;
+	return count;
+}
 
-#define DDB_NAME "ddbridge"
+static ssize_t fmode_show(struct device *device,
+			 struct device_attribute *attr, char *buf)
+{
+	int num = attr->attr.name[5] - 0x30;
+	struct ddb *dev = dev_get_drvdata(device);
 
-static u32 ddb_num;
-static struct ddb *ddbs[32];
-static struct class *ddb_class;
-static int ddb_major;
+	return sprintf(buf, "%u\n", dev->link[num].lnb.fmode);
+}
 
-static int ddb_open(struct inode *inode, struct file *file)
+static ssize_t devid_show(struct device *device,
+			  struct device_attribute *attr, char *buf)
 {
-	struct ddb *dev = ddbs[iminor(inode)];
+	int num = attr->attr.name[5] - 0x30;
+	struct ddb *dev = dev_get_drvdata(device);
 
-	file->private_data = dev;
-	return 0;
+	return sprintf(buf, "%08x\n", dev->link[num].ids.devid);
 }
 
-static long ddb_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+static ssize_t fmode_store(struct device *device, struct device_attribute *attr,
+			  const char *buf, size_t count)
 {
-	struct ddb *dev = file->private_data;
-	__user void *parg = (__user void *)arg;
-	int res;
+	struct ddb *dev = dev_get_drvdata(device);
+	int num = attr->attr.name[5] - 0x30;
+	unsigned int val;
+
+	if (sscanf(buf, "%u\n", &val) != 1)
+		return -EINVAL;
+	if (val > 3)
+		return -EINVAL;
+	lnb_init_fmode(dev, &dev->link[num], val);
+	return count;
+}
 
-	switch (cmd) {
-	case IOCTL_DDB_FLASHIO:
-	{
-		struct ddb_flashio fio;
-		u8 *rbuf, *wbuf;
+static struct device_attribute ddb_attrs[] = {
+	__ATTR_RO(version),
+	__ATTR_RO(ports),
+	__ATTR_RO(ts_irq),
+	__ATTR_RO(i2c_irq),
+	__ATTR(gap0, 0664, gap_show, gap_store),
+	__ATTR(gap1, 0664, gap_show, gap_store),
+	__ATTR(gap2, 0664, gap_show, gap_store),
+	__ATTR(gap3, 0664, gap_show, gap_store),
+	__ATTR(vlan, 0664, vlan_show, vlan_store),
+	__ATTR(fmode0, 0664, fmode_show, fmode_store),
+	__ATTR(fmode1, 0664, fmode_show, fmode_store),
+	__ATTR(fmode2, 0664, fmode_show, fmode_store),
+	__ATTR(fmode3, 0664, fmode_show, fmode_store),
+	__ATTR_MRO(devid0, devid_show),
+	__ATTR_MRO(devid1, devid_show),
+	__ATTR_MRO(devid2, devid_show),
+	__ATTR_MRO(devid3, devid_show),
+	__ATTR_RO(hwid),
+	__ATTR_RO(regmap),
+	__ATTR(redirect, 0664, redirect_show, redirect_store),
+	__ATTR_MRO(snr,  bsnr_show),
+	__ATTR_RO(bpsnr),
+	__ATTR_NULL,
+};
 
-		if (copy_from_user(&fio, parg, sizeof(fio)))
-			return -EFAULT;
+static struct device_attribute ddb_attrs_temp[] = {
+	__ATTR_RO(temp),
+};
 
-		if (fio.write_len > 1028 || fio.read_len > 1028)
-			return -EINVAL;
-		if (fio.write_len + fio.read_len > 1028)
-			return -EINVAL;
+static struct device_attribute ddb_attrs_mod[] = {
+	__ATTR_MRO(mod0, mod_show),
+	__ATTR_MRO(mod1, mod_show),
+	__ATTR_MRO(mod2, mod_show),
+	__ATTR_MRO(mod3, mod_show),
+	__ATTR_MRO(mod4, mod_show),
+	__ATTR_MRO(mod5, mod_show),
+	__ATTR_MRO(mod6, mod_show),
+	__ATTR_MRO(mod7, mod_show),
+	__ATTR_MRO(mod8, mod_show),
+	__ATTR_MRO(mod9, mod_show),
+};
 
-		wbuf = &dev->iobuf[0];
-		rbuf = wbuf + fio.write_len;
+static struct device_attribute ddb_attrs_fan[] = {
+	__ATTR(fan, 0664, fan_show, fan_store),
+};
 
-		if (copy_from_user(wbuf, fio.write_buf, fio.write_len))
-			return -EFAULT;
-		res = flashio(dev, wbuf, fio.write_len, rbuf, fio.read_len);
-		if (res)
-			return res;
-		if (copy_to_user(fio.read_buf, rbuf, fio.read_len))
-			return -EFAULT;
-		break;
-	}
-	default:
-		return -ENOTTY;
-	}
-	return 0;
-}
+static struct device_attribute ddb_attrs_snr[] = {
+	__ATTR(snr0, 0664, snr_show, snr_store),
+	__ATTR(snr1, 0664, snr_show, snr_store),
+	__ATTR(snr2, 0664, snr_show, snr_store),
+	__ATTR(snr3, 0664, snr_show, snr_store),
+};
 
-static const struct file_operations ddb_fops = {
-	.unlocked_ioctl = ddb_ioctl,
-	.open           = ddb_open,
+static struct device_attribute ddb_attrs_ctemp[] = {
+	__ATTR_MRO(temp0, ctemp_show),
+	__ATTR_MRO(temp1, ctemp_show),
+	__ATTR_MRO(temp2, ctemp_show),
+	__ATTR_MRO(temp3, ctemp_show),
 };
 
-static char *ddb_devnode(struct device *device, umode_t *mode)
-{
-	struct ddb *dev = dev_get_drvdata(device);
+static struct device_attribute ddb_attrs_led[] = {
+	__ATTR(led0, 0664, led_show, led_store),
+	__ATTR(led1, 0664, led_show, led_store),
+	__ATTR(led2, 0664, led_show, led_store),
+	__ATTR(led3, 0664, led_show, led_store),
+};
 
-	return kasprintf(GFP_KERNEL, "ddbridge/card%d", dev->nr);
-}
+static struct class ddb_class = {
+	.name		= "ddbridge",
+	.owner          = THIS_MODULE,
+	.devnode        = ddb_devnode,
+};
 
 static int ddb_class_create(void)
 {
 	ddb_major = register_chrdev(0, DDB_NAME, &ddb_fops);
 	if (ddb_major < 0)
 		return ddb_major;
-
-	ddb_class = class_create(THIS_MODULE, DDB_NAME);
-	if (IS_ERR(ddb_class)) {
-		unregister_chrdev(ddb_major, DDB_NAME);
-		return PTR_ERR(ddb_class);
-	}
-	ddb_class->devnode = ddb_devnode;
+	if (class_register(&ddb_class) < 0)
+		return -1;
 	return 0;
 }
 
 static void ddb_class_destroy(void)
 {
-	class_destroy(ddb_class);
+	class_unregister(&ddb_class);
 	unregister_chrdev(ddb_major, DDB_NAME);
 }
 
+static void ddb_device_attrs_del(struct ddb *dev)
+{
+	int i;
+
+	for (i = 0; i < dev->link[0].info->temp_num; i++)
+		device_remove_file(dev->ddb_dev, &ddb_attrs_temp[i]);
+	for (i = 0; i < dev->link[0].info->port_num; i++)
+		device_remove_file(dev->ddb_dev, &ddb_attrs_mod[i]);
+	for (i = 0; i < dev->link[0].info->fan_num; i++)
+		device_remove_file(dev->ddb_dev, &ddb_attrs_fan[i]);
+	for (i = 0; i < dev->i2c_num && i < 4; i++) {
+		if (dev->link[0].info->led_num)
+			device_remove_file(dev->ddb_dev, &ddb_attrs_led[i]);
+		device_remove_file(dev->ddb_dev, &ddb_attrs_snr[i]);
+		device_remove_file(dev->ddb_dev, &ddb_attrs_ctemp[i]);
+	}
+	for (i = 0; ddb_attrs[i].attr.name; i++)
+		device_remove_file(dev->ddb_dev, &ddb_attrs[i]);
+}
+
+static int ddb_device_attrs_add(struct ddb *dev)
+{
+	int i;
+
+	for (i = 0; ddb_attrs[i].attr.name; i++)
+		if (device_create_file(dev->ddb_dev, &ddb_attrs[i]))
+			goto fail;
+	for (i = 0; i < dev->link[0].info->temp_num; i++)
+		if (device_create_file(dev->ddb_dev, &ddb_attrs_temp[i]))
+			goto fail;
+	for (i = 0; i < dev->link[0].info->port_num; i++)
+		if (device_create_file(dev->ddb_dev, &ddb_attrs_mod[i]))
+			goto fail;
+	for (i = 0; i < dev->link[0].info->fan_num; i++)
+		if (device_create_file(dev->ddb_dev, &ddb_attrs_fan[i]))
+			goto fail;
+	for (i = 0; i < dev->i2c_num && i < 4; i++) {
+		if (device_create_file(dev->ddb_dev, &ddb_attrs_snr[i]))
+			goto fail;
+		if (device_create_file(dev->ddb_dev, &ddb_attrs_ctemp[i]))
+			goto fail;
+		if (dev->link[0].info->led_num)
+			if (device_create_file(dev->ddb_dev,
+					       &ddb_attrs_led[i]))
+				goto fail;
+	}
+	return 0;
+fail:
+	return -1;
+}
+
 static int ddb_device_create(struct ddb *dev)
 {
-	dev->nr = ddb_num++;
-	dev->ddb_dev = device_create(ddb_class, NULL,
+	int res = 0;
+
+	if (ddb_num == DDB_MAX_ADAPTER)
+		return -ENOMEM;
+	mutex_lock(&ddb_mutex);
+	dev->nr = ddb_num;
+	ddbs[dev->nr] = dev;
+	dev->ddb_dev = device_create(&ddb_class, dev->dev,
 				     MKDEV(ddb_major, dev->nr),
 				     dev, "ddbridge%d", dev->nr);
-	ddbs[dev->nr] = dev;
-	if (IS_ERR(dev->ddb_dev))
-		return -1;
-	return 0;
+	if (IS_ERR(dev->ddb_dev)) {
+		res = PTR_ERR(dev->ddb_dev);
+		pr_info("Could not create ddbridge%d\n", dev->nr);
+		goto fail;
+	}
+	res = ddb_device_attrs_add(dev);
+	if (res) {
+		ddb_device_attrs_del(dev);
+		device_destroy(&ddb_class, MKDEV(ddb_major, dev->nr));
+		ddbs[dev->nr] = 0;
+		dev->ddb_dev = ERR_PTR(-ENODEV);
+	} else
+		ddb_num++;
+fail:
+	mutex_unlock(&ddb_mutex);
+	return res;
 }
 
 static void ddb_device_destroy(struct ddb *dev)
 {
-	ddb_num--;
 	if (IS_ERR(dev->ddb_dev))
 		return;
-	device_destroy(ddb_class, MKDEV(ddb_major, 0));
+	ddb_device_attrs_del(dev);
+	device_destroy(&ddb_class, MKDEV(ddb_major, dev->nr));
 }
 
+#define LINK_IRQ_HANDLE(_nr)				  \
+	do { if ((s & (1UL << _nr)) && dev->handler[_nr + off]) \
+		dev->handler[_nr + off](dev->handler_data[_nr + off]); } \
+	while (0)
 
-/****************************************************************************/
-/****************************************************************************/
-/****************************************************************************/
-
-static void ddb_unmap(struct ddb *dev)
+static void gtl_link_handler(unsigned long priv)
 {
-	if (dev->regs)
-		iounmap(dev->regs);
-	vfree(dev);
-}
+	struct ddb *dev = (struct ddb *) priv;
+	u32 regs = dev->link[0].info->regmap->gtl->base;
 
+	pr_info("GT link change: %u\n",
+	       (1 & ddbreadl(dev, regs)));
+}
 
-static void ddb_remove(struct pci_dev *pdev)
+static void link_tasklet(unsigned long data)
 {
-	struct ddb *dev = pci_get_drvdata(pdev);
-
-	ddb_ports_detach(dev);
-	ddb_i2c_release(dev);
+	struct ddb_link *link = (struct ddb_link *) data;
+	struct ddb *dev = link->dev;
+	u32 s, off = 32 * link->nr, tag = DDB_LINK_TAG(link->nr);
 
-	ddbwritel(0, INTERRUPT_ENABLE);
-	free_irq(dev->pdev->irq, dev);
-#ifdef CONFIG_PCI_MSI
-	if (dev->msi)
-		pci_disable_msi(dev->pdev);
-#endif
-	ddb_ports_release(dev);
-	ddb_buffers_free(dev);
-	ddb_device_destroy(dev);
+	s = ddbreadl(dev, tag | INTERRUPT_STATUS);
+	pr_info("gtl_irq %08x = %08x\n", tag | INTERRUPT_STATUS, s);
 
-	ddb_unmap(dev);
-	pci_set_drvdata(pdev, NULL);
-	pci_disable_device(pdev);
+	if (!s)
+		return;
+	ddbwritel(dev, s, tag | INTERRUPT_ACK);
+	LINK_IRQ_HANDLE(0);
+	LINK_IRQ_HANDLE(1);
+	LINK_IRQ_HANDLE(2);
+	LINK_IRQ_HANDLE(3);
 }
 
-
-static int ddb_probe(struct pci_dev *pdev, const struct pci_device_id *id)
+static void gtl_irq_handler(unsigned long priv)
 {
-	struct ddb *dev;
-	int stat = 0;
-	int irq_flag = IRQF_SHARED;
-
-	if (pci_enable_device(pdev) < 0)
-		return -ENODEV;
-
-	dev = vzalloc(sizeof(struct ddb));
-	if (dev == NULL)
-		return -ENOMEM;
-
-	dev->pdev = pdev;
-	pci_set_drvdata(pdev, dev);
-	dev->info = (struct ddb_info *) id->driver_data;
-	printk(KERN_INFO "DDBridge driver detected: %s\n", dev->info->name);
-
-	dev->regs = ioremap(pci_resource_start(dev->pdev, 0),
-			    pci_resource_len(dev->pdev, 0));
-	if (!dev->regs) {
-		stat = -ENOMEM;
-		goto fail;
-	}
-	printk(KERN_INFO "HW %08x FW %08x\n", ddbreadl(0), ddbreadl(4));
-
-#ifdef CONFIG_PCI_MSI
-	if (pci_msi_enabled())
-		stat = pci_enable_msi(dev->pdev);
-	if (stat) {
-		printk(KERN_INFO ": MSI not available.\n");
-	} else {
-		irq_flag = 0;
-		dev->msi = 1;
-	}
-#endif
-	stat = request_irq(dev->pdev->irq, irq_handler,
-			   irq_flag, "DDBridge", (void *) dev);
-	if (stat < 0)
-		goto fail1;
-	ddbwritel(0, DMA_BASE_WRITE);
-	ddbwritel(0, DMA_BASE_READ);
-	ddbwritel(0xffffffff, INTERRUPT_ACK);
-	ddbwritel(0xfff0f, INTERRUPT_ENABLE);
-	ddbwritel(0, MSI1_ENABLE);
-
-	if (ddb_i2c_init(dev) < 0)
-		goto fail1;
-	ddb_ports_init(dev);
-	if (ddb_buffers_alloc(dev) < 0) {
-		printk(KERN_INFO ": Could not allocate buffer memory\n");
-		goto fail2;
+	struct ddb_link *link = (struct ddb_link *) priv;
+	struct ddb *dev = link->dev;
+	u32 s, off = 32 * link->nr, tag = DDB_LINK_TAG(link->nr);
+
+	while ((s = ddbreadl(dev, tag | INTERRUPT_STATUS)))  {
+		ddbwritel(dev, s, tag | INTERRUPT_ACK);
+		LINK_IRQ_HANDLE(0);
+		LINK_IRQ_HANDLE(1);
+		LINK_IRQ_HANDLE(2);
+		LINK_IRQ_HANDLE(3);
 	}
-	if (ddb_ports_attach(dev) < 0)
-		goto fail3;
-	ddb_device_create(dev);
-	return 0;
-
-fail3:
-	ddb_ports_detach(dev);
-	printk(KERN_ERR "fail3\n");
-	ddb_ports_release(dev);
-fail2:
-	printk(KERN_ERR "fail2\n");
-	ddb_buffers_free(dev);
-fail1:
-	printk(KERN_ERR "fail1\n");
-	if (dev->msi)
-		pci_disable_msi(dev->pdev);
-	if (stat == 0)
-		free_irq(dev->pdev->irq, dev);
-fail:
-	printk(KERN_ERR "fail\n");
-	ddb_unmap(dev);
-	pci_set_drvdata(pdev, NULL);
-	pci_disable_device(pdev);
-	return -1;
 }
 
-/******************************************************************************/
-/******************************************************************************/
-/******************************************************************************/
-
-static struct ddb_info ddb_none = {
-	.type     = DDB_NONE,
-	.name     = "Digital Devices PCIe bridge",
+static struct ddb_regset octopus_max_gtl_i2c = {
+	.base = 0x80,
+	.num  = 0x01,
+	.size = 0x20,
 };
 
-static struct ddb_info ddb_octopus = {
-	.type     = DDB_OCTOPUS,
-	.name     = "Digital Devices Octopus DVB adapter",
-	.port_num = 4,
+static struct ddb_regset octopus_max_gtl_i2c_buf = {
+	.base = 0x1000,
+	.num  = 0x01,
+	.size = 0x200,
 };
 
-static struct ddb_info ddb_octopus_le = {
-	.type     = DDB_OCTOPUS,
-	.name     = "Digital Devices Octopus LE DVB adapter",
-	.port_num = 2,
+static struct ddb_regmap octopus_max_gtl_map = {
+	.i2c = &octopus_max_gtl_i2c,
+	.i2c_buf = &octopus_max_gtl_i2c_buf,
 };
 
-static struct ddb_info ddb_octopus_mini = {
-	.type     = DDB_OCTOPUS,
-	.name     = "Digital Devices Octopus Mini",
+static struct ddb_info octopus_max_gtl = {
+	.type     = DDB_OCTOPUS_MAX,
+	.name     = "Digital Devices Octopus MAX GTL",
+	.regmap   = &octopus_max_gtl_map,
 	.port_num = 4,
+	.i2c_mask = 0x01,
+	.board_control = 1,
 };
 
-static struct ddb_info ddb_v6 = {
-	.type     = DDB_OCTOPUS,
-	.name     = "Digital Devices Cine S2 V6 DVB adapter",
-	.port_num = 3,
-};
-static struct ddb_info ddb_v6_5 = {
-	.type     = DDB_OCTOPUS,
-	.name     = "Digital Devices Cine S2 V6.5 DVB adapter",
-	.port_num = 4,
+
+static struct ddb_regset octopus_maxct_gtl_i2c = {
+	.base = 0x80,
+	.num  = 0x04,
+	.size = 0x20,
 };
 
-static struct ddb_info ddb_dvbct = {
-	.type     = DDB_OCTOPUS,
-	.name     = "Digital Devices DVBCT V6.1 DVB adapter",
-	.port_num = 3,
+static struct ddb_regset octopus_maxct_gtl_i2c_buf = {
+	.base = 0x1000,
+	.num  = 0x04,
+	.size = 0x200,
 };
 
-static struct ddb_info ddb_satixS2v3 = {
-	.type     = DDB_OCTOPUS,
-	.name     = "Mystique SaTiX-S2 V3 DVB adapter",
-	.port_num = 3,
+static struct ddb_regmap octopus_maxct_gtl_map = {
+	.i2c = &octopus_maxct_gtl_i2c,
+	.i2c_buf = &octopus_maxct_gtl_i2c_buf,
 };
 
-static struct ddb_info ddb_octopusv3 = {
-	.type     = DDB_OCTOPUS,
-	.name     = "Digital Devices Octopus V3 DVB adapter",
+static struct ddb_info octopus_ct_gtl = {
+	.type     = DDB_OCTOPUS_MAX_CT,
+	.name     = "Digital Devices Octopus MAX CT GTL",
+	.regmap   = &octopus_maxct_gtl_map,
 	.port_num = 4,
+	.i2c_mask = 0x0f,
+	.board_control = 0xff,
+	.board_control_2 = 0xf00,
+	.ts_quirks = TS_QUIRK_SERIAL,
 };
 
-#define DDVID 0xdd01 /* Digital Devices Vendor ID */
-
-#define DDB_ID(_vend, _dev, _subvend, _subdev, _driverdata) {	\
-	.vendor      = _vend,    .device    = _dev, \
-	.subvendor   = _subvend, .subdevice = _subdev, \
-	.driver_data = (unsigned long)&_driverdata }
-
-static const struct pci_device_id ddb_id_tbl[] = {
-	DDB_ID(DDVID, 0x0002, DDVID, 0x0001, ddb_octopus),
-	DDB_ID(DDVID, 0x0003, DDVID, 0x0001, ddb_octopus),
-	DDB_ID(DDVID, 0x0003, DDVID, 0x0002, ddb_octopus_le),
-	DDB_ID(DDVID, 0x0003, DDVID, 0x0010, ddb_octopus_mini),
-	DDB_ID(DDVID, 0x0003, DDVID, 0x0020, ddb_v6),
-	DDB_ID(DDVID, 0x0003, DDVID, 0x0021, ddb_v6_5),
-	DDB_ID(DDVID, 0x0003, DDVID, 0x0030, ddb_dvbct),
-	DDB_ID(DDVID, 0x0003, DDVID, 0xdb03, ddb_satixS2v3),
-	DDB_ID(DDVID, 0x0005, DDVID, 0x0004, ddb_octopusv3),
-	/* in case sub-ids got deleted in flash */
-	DDB_ID(DDVID, 0x0003, PCI_ANY_ID, PCI_ANY_ID, ddb_none),
-	{0}
-};
-MODULE_DEVICE_TABLE(pci, ddb_id_tbl);
 
+static int ddb_gtl_init_link(struct ddb *dev, u32 l)
+{
+	struct ddb_link *link = &dev->link[l];
+	u32 regs = dev->link[0].info->regmap->gtl->base +
+		(l - 1) * dev->link[0].info->regmap->gtl->size;
+	u32 id;
+
+	pr_info("Checking GT link %u: regs = %08x\n", l, regs);
+
+	spin_lock_init(&link->lock);
+	mutex_init(&link->lnb.lock);
+	link->lnb.fmode = 0xffffffff;
+	mutex_init(&link->flash_mutex);
+
+	if (!(1 & ddbreadl(dev, regs))) {
+		u32 c;
+
+		for (c = 0; c < 5; c++) {
+			ddbwritel(dev, 2, regs);
+			msleep(20);
+			ddbwritel(dev, 0, regs);
+			msleep(200);
+			if (1 & ddbreadl(dev, regs))
+				break;
+		}
+		if (c == 5)
+			return -1;
+	}
+	link->nr = l;
+	link->dev = dev;
+	link->regs = regs;
+
+	id = ddbreadl(dev, DDB_LINK_TAG(l) | 8);
+	switch (id) {
+	case 0x0007dd01:
+		link->info = &octopus_max_gtl;
+		break;
+	case 0x0008dd01:
+		link->info = &octopus_ct_gtl;
+		break;
+	default:
+		pr_info("DDBridge: Detected GT link but found invalid ID %08x. You might have to update (flash) the add-on card first.",
+			id);
+		return -1;
+	}
+	link->ids.devid = id;
+
+	ddbwritel(dev, 1, 0x1a0);
 
-static struct pci_driver ddb_pci_driver = {
-	.name        = "DDBridge",
-	.id_table    = ddb_id_tbl,
-	.probe       = ddb_probe,
-	.remove      = ddb_remove,
-};
+	dev->handler_data[11] = (unsigned long) link;
+	dev->handler[11] = gtl_irq_handler;
+
+	pr_info("GTL %s\n", dev->link[l].info->name);
+	pr_info("GTL HW %08x REGMAP %08x\n",
+		ddbreadl(dev, DDB_LINK_TAG(l) | 0),
+		ddbreadl(dev, DDB_LINK_TAG(l) | 4));
+	pr_info("GTL ID %08x\n",
+		ddbreadl(dev, DDB_LINK_TAG(l) | 8));
+
+	tasklet_init(&link->tasklet, link_tasklet, (unsigned long) link);
+	ddbwritel(dev, 0xffffffff, DDB_LINK_TAG(l) | INTERRUPT_ACK);
+	ddbwritel(dev, 0xf, DDB_LINK_TAG(l) | INTERRUPT_ENABLE);
 
-static __init int module_init_ddbridge(void)
+	return 0;
+}
+
+static int ddb_gtl_init(struct ddb *dev)
 {
-	int ret;
+	u32 l;
 
-	printk(KERN_INFO "Digital Devices PCIE bridge driver, "
-	       "Copyright (C) 2010-11 Digital Devices GmbH\n");
+	dev->handler_data[10] = (unsigned long) dev;
+	dev->handler[10] = gtl_link_handler;
 
-	ret = ddb_class_create();
-	if (ret < 0)
-		return ret;
-	ret = pci_register_driver(&ddb_pci_driver);
-	if (ret < 0)
-		ddb_class_destroy();
-	return ret;
+	for (l = 1; l < dev->link[0].info->regmap->gtl->num + 1; l++)
+		ddb_gtl_init_link(dev, l);
+	return 0;
 }
 
-static __exit void module_exit_ddbridge(void)
+static int ddb_init_boards(struct ddb *dev)
 {
-	pci_unregister_driver(&ddb_pci_driver);
-	ddb_class_destroy();
+	struct ddb_info *info;
+	u32 l;
+
+	for (l = 0; l < DDB_MAX_LINK; l++) {
+		info = dev->link[l].info;
+		if (!info)
+			continue;
+		if (info->board_control) {
+			ddbwritel(dev, 0, DDB_LINK_TAG(l) | BOARD_CONTROL);
+			msleep(100);
+			ddbwritel(dev, info->board_control_2,
+				DDB_LINK_TAG(l) | BOARD_CONTROL);
+			usleep_range(2000, 3000);
+			ddbwritel(dev,
+				info->board_control_2 | info->board_control,
+				DDB_LINK_TAG(l) | BOARD_CONTROL);
+			usleep_range(2000, 3000);
+		}
+	}
+	return 0;
 }
 
-module_init(module_init_ddbridge);
-module_exit(module_exit_ddbridge);
+static int ddb_init(struct ddb *dev)
+{
+	if (dev->link[0].info->ns_num) {
+		ddbwritel(dev, 1, ETHER_CONTROL);
+		dev->vlan = vlan;
+		ddbwritel(dev, 14 + (dev->vlan ? 4 : 0), ETHER_LENGTH);
+	}
+
+	mutex_init(&dev->link[0].lnb.lock);
+	mutex_init(&dev->link[0].flash_mutex);
+
+	if (dev->link[0].info->regmap->gtl)
+		ddb_gtl_init(dev);
+
+	ddb_init_boards(dev);
+
+	if (ddb_i2c_init(dev) < 0)
+		goto fail;
+	ddb_ports_init(dev);
+	if (ddb_buffers_alloc(dev) < 0) {
+		pr_info(": Could not allocate buffer memory\n");
+		goto fail2;
+	}
+	ddb_ports_attach(dev);
+
+	ddb_nsd_attach(dev);
+
+	ddb_device_create(dev);
+
+	if (dev->link[0].info->fan_num)	{
+		ddbwritel(dev, 1, GPIO_DIRECTION);
+		ddbwritel(dev, 1, GPIO_OUTPUT);
+	}
+	if (dev->link[0].info->type == DDB_MOD)
+		ddbridge_mod_init(dev);
+	return 0;
 
-MODULE_DESCRIPTION("Digital Devices PCIe Bridge");
-MODULE_AUTHOR("Ralph Metzler");
-MODULE_LICENSE("GPL");
-MODULE_VERSION("0.5");
+fail2:
+	pr_err("fail2\n");
+	ddb_buffers_free(dev);
+	ddb_i2c_release(dev);
+fail:
+	pr_err("fail1\n");
+	return -1;
+}
diff --git a/drivers/media/pci/ddbridge/ddbridge-i2c.c b/drivers/media/pci/ddbridge/ddbridge-i2c.c
new file mode 100644
index 0000000..1e2e1da
--- /dev/null
+++ b/drivers/media/pci/ddbridge/ddbridge-i2c.c
@@ -0,0 +1,290 @@
+/*
+ * ddbridge-i2c.c: Digital Devices bridge i2c driver
+ *
+ * Copyright (C) 2010-2015 Digital Devices GmbH
+ *                         Ralph Metzler <rjkm@metzlerbros.de>
+ *                         Marcus Metzler <mocm@metzlerbros.de>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 only, as published by the Free Software Foundation.
+ *
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA
+ * Or, point your browser to http://www.gnu.org/copyleft/gpl.html
+ */
+
+static int i2c_io(struct i2c_adapter *adapter, u8 adr,
+		  u8 *wbuf, u32 wlen, u8 *rbuf, u32 rlen)
+{
+	struct i2c_msg msgs[2] = {{.addr = adr,  .flags = 0,
+				   .buf  = wbuf, .len   = wlen },
+				  {.addr = adr,  .flags = I2C_M_RD,
+				   .buf  = rbuf,  .len   = rlen } };
+	return (i2c_transfer(adapter, msgs, 2) == 2) ? 0 : -1;
+}
+
+static int i2c_write(struct i2c_adapter *adap, u8 adr, u8 *data, int len)
+{
+	struct i2c_msg msg = {.addr = adr, .flags = 0,
+			      .buf = data, .len = len};
+
+	return (i2c_transfer(adap, &msg, 1) == 1) ? 0 : -1;
+}
+
+static int i2c_read(struct i2c_adapter *adapter, u8 adr, u8 *val)
+{
+	struct i2c_msg msgs[1] = {{.addr = adr,  .flags = I2C_M_RD,
+				   .buf  = val,  .len   = 1 } };
+	return (i2c_transfer(adapter, msgs, 1) == 1) ? 0 : -1;
+}
+
+static int i2c_read_regs(struct i2c_adapter *adapter,
+			 u8 adr, u8 reg, u8 *val, u8 len)
+{
+	struct i2c_msg msgs[2] = {{.addr = adr,  .flags = 0,
+				   .buf  = &reg, .len   = 1 },
+				  {.addr = adr,  .flags = I2C_M_RD,
+				   .buf  = val,  .len   = len } };
+	return (i2c_transfer(adapter, msgs, 2) == 2) ? 0 : -1;
+}
+
+static int i2c_read_regs16(struct i2c_adapter *adapter,
+			   u8 adr, u16 reg, u8 *val, u8 len)
+{
+	u8 reg16[2] = { reg >> 8, reg };
+	struct i2c_msg msgs[2] = {{.addr = adr,  .flags = 0,
+				   .buf  = reg16, .len   = 2 },
+				  {.addr = adr,  .flags = I2C_M_RD,
+				   .buf  = val,  .len   = len } };
+	return (i2c_transfer(adapter, msgs, 2) == 2) ? 0 : -1;
+}
+
+static int i2c_read_reg(struct i2c_adapter *adapter, u8 adr, u8 reg, u8 *val)
+{
+	struct i2c_msg msgs[2] = {{.addr = adr,  .flags = 0,
+				   .buf  = &reg, .len   = 1},
+				  {.addr = adr,  .flags = I2C_M_RD,
+				   .buf  = val,  .len   = 1 } };
+	return (i2c_transfer(adapter, msgs, 2) == 2) ? 0 : -1;
+}
+
+static int i2c_read_reg16(struct i2c_adapter *adapter, u8 adr,
+			  u16 reg, u8 *val)
+{
+	u8 msg[2] = {reg >> 8, reg & 0xff};
+	struct i2c_msg msgs[2] = {{.addr = adr, .flags = 0,
+				   .buf  = msg, .len   = 2},
+				  {.addr = adr, .flags = I2C_M_RD,
+				   .buf  = val, .len   = 1 } };
+	return (i2c_transfer(adapter, msgs, 2) == 2) ? 0 : -1;
+}
+
+static int i2c_write_reg16(struct i2c_adapter *adap, u8 adr,
+			   u16 reg, u8 val)
+{
+	u8 msg[3] = {reg >> 8, reg & 0xff, val};
+
+	return i2c_write(adap, adr, msg, 3);
+}
+
+static int i2c_write_reg(struct i2c_adapter *adap, u8 adr,
+			 u8 reg, u8 val)
+{
+	u8 msg[2] = {reg, val};
+
+	return i2c_write(adap, adr, msg, 2);
+}
+
+static int ddb_i2c_cmd(struct ddb_i2c *i2c, u32 adr, u32 cmd)
+{
+	struct ddb *dev = i2c->dev;
+	unsigned long stat;
+	u32 val;
+
+	ddbwritel(dev, (adr << 9) | cmd, i2c->regs + I2C_COMMAND);
+	stat = wait_for_completion_timeout(&i2c->completion, HZ);
+	val = ddbreadl(dev, i2c->regs + I2C_COMMAND);
+	if (stat == 0) {
+		pr_err("DDBridge I2C timeout, card %d, port %d, link %u\n",
+		       dev->nr, i2c->nr, i2c->link);
+		{
+			u32 istat = ddbreadl(dev, INTERRUPT_STATUS);
+
+			dev_err(dev->dev, "DDBridge IRS %08x\n", istat);
+			if (i2c->link) {
+				u32 listat = ddbreadl(dev,
+					DDB_LINK_TAG(i2c->link) |
+					INTERRUPT_STATUS);
+
+				dev_err(dev->dev, "DDBridge link %u IRS %08x\n",
+					i2c->link, listat);
+			}
+			if (istat & 1) {
+				ddbwritel(dev, istat & 1, INTERRUPT_ACK);
+			} else {
+				u32 mon = ddbreadl(dev,
+					i2c->regs + I2C_MONITOR);
+
+				dev_err(dev->dev, "I2C cmd=%08x mon=%08x\n",
+					val, mon);
+			}
+		}
+		return -EIO;
+	}
+	if (val & 0x70000)
+		return -EIO;
+	return 0;
+}
+
+static int ddb_i2c_master_xfer(struct i2c_adapter *adapter,
+			       struct i2c_msg msg[], int num)
+{
+	struct ddb_i2c *i2c = (struct ddb_i2c *) i2c_get_adapdata(adapter);
+	struct ddb *dev = i2c->dev;
+	u8 addr = 0;
+
+	if (num != 1 && num != 2)
+		return -EIO;
+	addr = msg[0].addr;
+	if (msg[0].len > i2c->bsize)
+		return -EIO;
+	if (num == 2 && msg[1].flags & I2C_M_RD &&
+	    !(msg[0].flags & I2C_M_RD)) {
+		if (msg[1].len > i2c->bsize)
+			return -EIO;
+		ddbcpyto(dev, i2c->wbuf, msg[0].buf, msg[0].len);
+		ddbwritel(dev, msg[0].len | (msg[1].len << 16),
+			  i2c->regs + I2C_TASKLENGTH);
+		if (!ddb_i2c_cmd(i2c, addr, 1)) {
+			ddbcpyfrom(dev, msg[1].buf,
+				   i2c->rbuf,
+				   msg[1].len);
+			return num;
+		}
+	}
+	if (num == 1 && !(msg[0].flags & I2C_M_RD)) {
+		ddbcpyto(dev, i2c->wbuf, msg[0].buf, msg[0].len);
+		ddbwritel(dev, msg[0].len, i2c->regs + I2C_TASKLENGTH);
+		if (!ddb_i2c_cmd(i2c, addr, 2))
+			return num;
+	}
+	if (num == 1 && (msg[0].flags & I2C_M_RD)) {
+		ddbwritel(dev, msg[0].len << 16, i2c->regs + I2C_TASKLENGTH);
+		if (!ddb_i2c_cmd(i2c, addr, 3)) {
+			ddbcpyfrom(dev, msg[0].buf,
+				   i2c->rbuf, msg[0].len);
+			return num;
+		}
+	}
+	return -EIO;
+}
+
+static u32 ddb_i2c_functionality(struct i2c_adapter *adap)
+{
+	return I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;
+}
+
+struct i2c_algorithm ddb_i2c_algo = {
+	.master_xfer   = ddb_i2c_master_xfer,
+	.functionality = ddb_i2c_functionality,
+};
+
+static void ddb_i2c_release(struct ddb *dev)
+{
+	int i;
+	struct ddb_i2c *i2c;
+
+	for (i = 0; i < dev->i2c_num; i++) {
+		i2c = &dev->i2c[i];
+		i2c_del_adapter(&i2c->adap);
+	}
+}
+
+static void i2c_handler(unsigned long priv)
+{
+	struct ddb_i2c *i2c = (struct ddb_i2c *) priv;
+
+	complete(&i2c->completion);
+}
+
+static int ddb_i2c_add(struct ddb *dev, struct ddb_i2c *i2c,
+		       struct ddb_regmap *regmap, int link, int i, int num)
+{
+	struct i2c_adapter *adap;
+
+	i2c->nr = i;
+	i2c->dev = dev;
+	i2c->link = link;
+	i2c->bsize = regmap->i2c_buf->size;
+	i2c->wbuf = DDB_LINK_TAG(link) |
+		(regmap->i2c_buf->base + i2c->bsize * i);
+	i2c->rbuf = i2c->wbuf; /* + i2c->bsize / 2 */
+	i2c->regs = DDB_LINK_TAG(link) |
+		(regmap->i2c->base + regmap->i2c->size * i);
+	ddbwritel(dev, I2C_SPEED_100, i2c->regs + I2C_TIMING);
+	ddbwritel(dev, ((i2c->rbuf & 0xffff) << 16) | (i2c->wbuf & 0xffff),
+		i2c->regs + I2C_TASKADDRESS);
+	init_completion(&i2c->completion);
+
+	adap = &i2c->adap;
+	i2c_set_adapdata(adap, i2c);
+#ifdef I2C_ADAP_CLASS_TV_DIGITAL
+	adap->class = I2C_ADAP_CLASS_TV_DIGITAL|I2C_CLASS_TV_ANALOG;
+#else
+#ifdef I2C_CLASS_TV_ANALOG
+	adap->class = I2C_CLASS_TV_ANALOG;
+#endif
+#endif
+	strcpy(adap->name, "ddbridge");
+	adap->algo = &ddb_i2c_algo;
+	adap->algo_data = (void *)i2c;
+	adap->dev.parent = dev->dev;
+	return i2c_add_adapter(adap);
+}
+
+static int ddb_i2c_init(struct ddb *dev)
+{
+	int stat = 0;
+	u32 i, j, num = 0, l;
+	struct ddb_i2c *i2c;
+	struct i2c_adapter *adap;
+	struct ddb_regmap *regmap;
+
+	for (l = 0; l < DDB_MAX_LINK; l++) {
+		if (!dev->link[l].info)
+			continue;
+		regmap = dev->link[l].info->regmap;
+		if (!regmap || !regmap->i2c)
+			continue;
+		for (i = 0; i < regmap->i2c->num; i++) {
+			if (!(dev->link[l].info->i2c_mask & (1 << i)))
+				continue;
+			i2c = &dev->i2c[num];
+			dev->handler_data[i + l * 32] = (unsigned long) i2c;
+			dev->handler[i + l * 32] = i2c_handler;
+			stat = ddb_i2c_add(dev, i2c, regmap, l, i, num);
+			if (stat)
+				break;
+			num++;
+		}
+	}
+	if (stat) {
+		for (j = 0; j < num; j++) {
+			i2c = &dev->i2c[j];
+			adap = &i2c->adap;
+			i2c_del_adapter(adap);
+		}
+	} else
+		dev->i2c_num = num;
+	return stat;
+}
diff --git a/drivers/media/pci/ddbridge/ddbridge-i2c.h b/drivers/media/pci/ddbridge/ddbridge-i2c.h
new file mode 100644
index 0000000..c20a2ba
--- /dev/null
+++ b/drivers/media/pci/ddbridge/ddbridge-i2c.h
@@ -0,0 +1,116 @@
+/*
+ * ddbridge-i2c.h: Digital Devices bridge i2c driver
+ *
+ * Copyright (C) 2010-2015 Digital Devices GmbH
+ *                         Marcus Metzler <mocm@metzlerbros.de>
+ *                         Ralph Metzler <rjkm@metzlerbros.de>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 only, as published by the Free Software Foundation.
+ *
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA
+ * Or, point your browser to http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifndef _DDBRIDGE_I2C_H_
+#define _DDBRIDGE_I2C_H_
+
+#include <linux/i2c.h>
+#include <linux/types.h>
+
+static inline int i2c_io(struct i2c_adapter *adapter, u8 adr,
+			 u8 *wbuf, u32 wlen, u8 *rbuf, u32 rlen)
+{
+	struct i2c_msg msgs[2] = {{.addr = adr,  .flags = 0,
+				   .buf  = wbuf, .len   = wlen },
+				  {.addr = adr,  .flags = I2C_M_RD,
+				   .buf  = rbuf,  .len   = rlen } };
+	return (i2c_transfer(adapter, msgs, 2) == 2) ? 0 : -1;
+}
+
+static inline int i2c_write(struct i2c_adapter *adap, u8 adr,
+			    u8 *data, int len)
+{
+	struct i2c_msg msg = {.addr = adr, .flags = 0,
+			      .buf = data, .len = len};
+
+	return (i2c_transfer(adap, &msg, 1) == 1) ? 0 : -1;
+}
+
+static inline int i2c_read(struct i2c_adapter *adapter, u8 adr, u8 *val)
+{
+	struct i2c_msg msgs[1] = {{.addr = adr,  .flags = I2C_M_RD,
+				   .buf  = val,  .len   = 1 } };
+	return (i2c_transfer(adapter, msgs, 1) == 1) ? 0 : -1;
+}
+
+static inline int i2c_read_regs(struct i2c_adapter *adapter,
+				u8 adr, u8 reg, u8 *val, u8 len)
+{
+	struct i2c_msg msgs[2] = {{.addr = adr,  .flags = 0,
+				   .buf  = &reg, .len   = 1 },
+				  {.addr = adr,  .flags = I2C_M_RD,
+				   .buf  = val,  .len   = len } };
+	return (i2c_transfer(adapter, msgs, 2) == 2) ? 0 : -1;
+}
+
+static inline int i2c_read_regs16(struct i2c_adapter *adapter,
+				  u8 adr, u16 reg, u8 *val, u8 len)
+{
+	u8 reg16[2] = { reg >> 8, reg };
+	struct i2c_msg msgs[2] = {{.addr = adr,  .flags = 0,
+				   .buf  = reg16, .len   = 2 },
+				  {.addr = adr,  .flags = I2C_M_RD,
+				   .buf  = val,  .len   = len } };
+	return (i2c_transfer(adapter, msgs, 2) == 2) ? 0 : -1;
+}
+
+static inline int i2c_read_reg(struct i2c_adapter *adapter, u8 adr,
+			       u8 reg, u8 *val)
+{
+	struct i2c_msg msgs[2] = {{.addr = adr,  .flags = 0,
+				   .buf  = &reg, .len   = 1},
+				  {.addr = adr,  .flags = I2C_M_RD,
+				   .buf  = val,  .len   = 1 } };
+	return (i2c_transfer(adapter, msgs, 2) == 2) ? 0 : -1;
+}
+
+static inline int i2c_read_reg16(struct i2c_adapter *adapter, u8 adr,
+				 u16 reg, u8 *val)
+{
+	u8 msg[2] = {reg >> 8, reg & 0xff};
+	struct i2c_msg msgs[2] = {{.addr = adr, .flags = 0,
+				   .buf  = msg, .len   = 2},
+				  {.addr = adr, .flags = I2C_M_RD,
+				   .buf  = val, .len   = 1 } };
+	return (i2c_transfer(adapter, msgs, 2) == 2) ? 0 : -1;
+}
+
+static inline int i2c_write_reg16(struct i2c_adapter *adap, u8 adr,
+				  u16 reg, u8 val)
+{
+	u8 msg[3] = {reg >> 8, reg & 0xff, val};
+
+	return i2c_write(adap, adr, msg, 3);
+}
+
+static inline int i2c_write_reg(struct i2c_adapter *adap, u8 adr,
+				u8 reg, u8 val)
+{
+	u8 msg[2] = {reg, val};
+
+	return i2c_write(adap, adr, msg, 2);
+}
+
+#endif
diff --git a/drivers/media/pci/ddbridge/ddbridge-mod.c b/drivers/media/pci/ddbridge/ddbridge-mod.c
new file mode 100644
index 0000000..fa1e92f
--- /dev/null
+++ b/drivers/media/pci/ddbridge/ddbridge-mod.c
@@ -0,0 +1,1118 @@
+/*
+ * ddbridge.c: Digital Devices PCIe bridge driver
+ *
+ * Copyright (C) 2010-2015 Digital Devices GmbH
+ *                         Marcus Metzler <mocm@metzlerbros.de>
+ *                         Ralph Metzler <rjkm@metzlerbros.de>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 only, as published by the Free Software Foundation.
+ *
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA
+ * Or, point your browser to http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include "ddbridge.h"
+#include "ddbridge-regs.h"
+
+#include <linux/dvb/mod.h>
+
+inline s64 ConvertPCR(s64 a)
+{
+	s32 ext;
+	s64 b;
+
+	b = div_s64_rem(a, 300 << 22, &ext);
+
+	return (b << 31) | ext;
+
+}
+
+inline s64 NegConvertPCR(s64 a)
+{
+	s32 ext;
+	s64 b;
+
+	b = -div_s64_rem(a, 300 << 22, &ext);
+
+	if (ext != 0) {
+		ext = (300 << 22) - ext;
+		b -= 1;
+	}
+	return (b << 31) | ext;
+}
+
+inline s64 RoundPCR(s64 a)
+{
+	s64 b = a + (HW_LSB_MASK>>1);
+
+	return b & ~(HW_LSB_MASK - 1);
+}
+
+inline s64 RoundPCRUp(s64 a)
+{
+	s64 b = a + (HW_LSB_MASK - 1);
+
+	return b & ~(HW_LSB_MASK - 1);
+}
+
+inline s64 RoundPCRDown(s64 a)
+{
+	return a & ~(HW_LSB_MASK - 1);
+}
+
+static int mod_busy(struct ddb *dev, int chan)
+{
+	u32 creg;
+
+	while (1) {
+		creg = ddbreadl(dev, CHANNEL_CONTROL(chan));
+		if (creg == 0xffffffff)
+			return -EFAULT;
+		if ((creg & CHANNEL_CONTROL_BUSY) == 0)
+			break;
+	}
+	return 0;
+}
+
+void ddbridge_mod_output_stop(struct ddb_output *output)
+{
+	struct ddb *dev = output->port->dev;
+	struct mod_state *mod = &dev->mod[output->nr];
+
+	mod->State = CM_IDLE;
+	mod->Control = 0;
+	ddbwritel(dev, 0, CHANNEL_CONTROL(output->nr));
+	mod_busy(dev, output->nr);
+	pr_info("mod_output_stop %d.%d\n", dev->nr, output->nr);
+}
+
+static void mod_set_incs(struct ddb_output *output)
+{
+	s64 pcr;
+	struct ddb *dev = output->port->dev;
+	struct mod_state *mod = &dev->mod[output->nr];
+
+	pcr = ConvertPCR(mod->PCRIncrement);
+	ddbwritel(dev,	pcr & 0xffffffff,
+		  CHANNEL_PCR_ADJUST_OUTL(output->nr));
+	ddbwritel(dev,	(pcr >> 32) & 0xffffffff,
+		  CHANNEL_PCR_ADJUST_OUTH(output->nr));
+	mod_busy(dev, output->nr);
+
+	pcr = NegConvertPCR(mod->PCRDecrement);
+	ddbwritel(dev,	pcr & 0xffffffff,
+		  CHANNEL_PCR_ADJUST_INL(output->nr));
+	ddbwritel(dev,	(pcr >> 32) & 0xffffffff,
+		  CHANNEL_PCR_ADJUST_INH(output->nr));
+	mod_busy(dev, output->nr);
+
+}
+
+static void mod_set_rateinc(struct ddb *dev, u32 chan)
+{
+	ddbwritel(dev, dev->mod[chan].rate_inc, CHANNEL_RATE_INCR(chan));
+	mod_busy(dev, chan);
+}
+
+static u32 qamtab[6] = { 0x000, 0x600, 0x601, 0x602, 0x903, 0x604 };
+
+void ddbridge_mod_output_start(struct ddb_output *output)
+{
+	struct ddb *dev = output->port->dev;
+	struct mod_state *mod = &dev->mod[output->nr];
+
+	/*PCRIncrement = RoundPCR(PCRIncrement);*/
+	/*PCRDecrement = RoundPCR(PCRDecrement);*/
+
+	mod->LastInPacketCount = 0;
+	mod->LastOutPacketCount = 0;
+	mod->InOverflowPacketCount = 0;
+	mod->OutOverflowPacketCount = 0;
+	mod->LastInPackets = 0;
+	mod->LastOutPackets = 0;
+	mod->LastPCRAdjust = 0;
+	mod->PCRRunningCorr = 0;
+	/* we interrupt every 0x80000=524288 packets */
+	mod->MinInputPackets = 524288 / 2;
+	mod->PCRIncrement = 0;
+	mod->PCRDecrement = 0;
+
+	mod->State = CM_STARTUP;
+	mod->StateCounter = CM_STARTUP_DELAY;
+
+	ddbwritel(dev, 0, CHANNEL_CONTROL(output->nr));
+	udelay(10);
+	ddbwritel(dev, CHANNEL_CONTROL_RESET, CHANNEL_CONTROL(output->nr));
+	udelay(10);
+	ddbwritel(dev, 0, CHANNEL_CONTROL(output->nr));
+
+	/* QAM: 600 601 602 903 604 = 16 32 64 128 256 */
+	/* ddbwritel(dev, 0x604, CHANNEL_SETTINGS(output->nr)); */
+	ddbwritel(dev, qamtab[mod->modulation], CHANNEL_SETTINGS(output->nr));
+
+	mod_set_rateinc(dev, output->nr);
+	mod_set_incs(output);
+
+	mod->Control = (CHANNEL_CONTROL_ENABLE_IQ |
+			CHANNEL_CONTROL_ENABLE_DVB |
+			CHANNEL_CONTROL_ENABLE_SOURCE);
+
+	ddbwritel(dev, mod->Control, CHANNEL_CONTROL(output->nr));
+	pr_info("mod_output_start %d.%d\n", dev->nr, output->nr);
+}
+
+/****************************************************************************/
+/****************************************************************************/
+/****************************************************************************/
+
+static void mod_write_dac_register(struct ddb *dev, u8 Index, u8 Value)
+{
+	u32 RegValue = 0;
+
+	ddbwritel(dev, Value, DAC_WRITE_DATA);
+	ddbwritel(dev, DAC_CONTROL_STARTIO | Index, DAC_CONTROL);
+	do {
+		RegValue = ddbreadl(dev, DAC_CONTROL);
+	} while ((RegValue & DAC_CONTROL_STARTIO) != 0);
+}
+
+static void mod_write_dac_register2(struct ddb *dev, u8 Index, u16 Value)
+{
+	u32 RegValue = 0;
+
+	ddbwritel(dev, Value, DAC_WRITE_DATA);
+	ddbwritel(dev, DAC_CONTROL_STARTIO | 0x20 | Index, DAC_CONTROL);
+	do {
+		RegValue = ddbreadl(dev, DAC_CONTROL);
+	} while ((RegValue & DAC_CONTROL_STARTIO) != 0);
+}
+
+static int mod_read_dac_register(struct ddb *dev, u8 Index, u8 *pValue)
+{
+	u32 RegValue = 0;
+
+	ddbwritel(dev, DAC_CONTROL_STARTIO | 0x80 | Index, DAC_CONTROL);
+	do {
+		RegValue = ddbreadl(dev, DAC_CONTROL);
+	} while ((RegValue & DAC_CONTROL_STARTIO) != 0);
+
+	RegValue = ddbreadl(dev, DAC_READ_DATA);
+	*pValue = (u8) RegValue;
+	return 0;
+}
+
+static void mod_set_up_converter_vco1(struct ddb *dev, u32 Value)
+{
+	u32 RegValue = 0;
+
+	/* Extra delay before writing N divider */
+	if ((Value & 0x03) == 0x02)
+		msleep(50);
+	do {
+		RegValue = ddbreadl(dev, VCO1_CONTROL);
+	} while ((RegValue & VCO1_CONTROL_WRITE) != 0);
+
+	if ((RegValue & VCO1_CONTROL_CE) == 0) {
+		RegValue |= VCO1_CONTROL_CE;
+		ddbwritel(dev, RegValue, VCO1_CONTROL);
+		msleep(20);
+	}
+
+	ddbwritel(dev, Value, VCO1_DATA);
+	ddbwritel(dev, RegValue | VCO1_CONTROL_WRITE, VCO1_CONTROL);
+}
+
+static void mod_set_up_converter_vco2(struct ddb *dev, u32 Value)
+{
+	u32 RegValue = 0;
+
+	/* Extra delay before writing N divider */
+	if ((Value & 0x03) == 0x02)
+		msleep(50);
+	do {
+		RegValue = ddbreadl(dev, VCO2_CONTROL);
+	} while ((RegValue & VCO2_CONTROL_WRITE) != 0);
+
+	if ((RegValue & VCO2_CONTROL_CE) == 0) {
+		RegValue |= VCO2_CONTROL_CE;
+		ddbwritel(dev, RegValue, VCO2_CONTROL);
+		msleep(20);
+	}
+
+	ddbwritel(dev, Value, VCO2_DATA);
+	ddbwritel(dev, RegValue | VCO2_CONTROL_WRITE, VCO2_CONTROL);
+}
+
+static void mod_set_down_converter_vco(struct ddb *dev, u32 Value)
+{
+	u32 RegValue = 0;
+
+	do {
+		RegValue = ddbreadl(dev, VCO3_CONTROL);
+	} while ((RegValue & VCO3_CONTROL_WRITE) != 0);
+
+	if ((RegValue & VCO3_CONTROL_CE) == 0) {
+		RegValue |= VCO3_CONTROL_CE;
+		ddbwritel(dev, RegValue, VCO3_CONTROL);
+		msleep(20);
+	}
+	ddbwritel(dev, Value, VCO3_DATA);
+	ddbwritel(dev, RegValue | VCO3_CONTROL_WRITE, VCO3_CONTROL);
+}
+
+static int mod_set_attenuator(struct ddb *dev, u32 Value)
+{
+	if (Value > 31)
+		return -EINVAL;
+	ddbwritel(dev, Value, RF_ATTENUATOR);
+	return 0;
+}
+
+static void mod_si598_readreg(struct ddb *dev, u8 index, u8 *val)
+{
+	ddbwritel(dev, index, CLOCKGEN_INDEX);
+	ddbwritel(dev, 1, CLOCKGEN_CONTROL);
+	usleep_range(5000, 6000);
+	*val = ddbreadl(dev, CLOCKGEN_READDATA);
+}
+
+static void mod_si598_writereg(struct ddb *dev, u8 index, u8 val)
+{
+	ddbwritel(dev, index, CLOCKGEN_INDEX);
+	ddbwritel(dev, val, CLOCKGEN_WRITEDATA);
+	ddbwritel(dev, 3, CLOCKGEN_CONTROL);
+	usleep_range(5000, 6000);
+}
+
+static int mod_set_si598(struct ddb *dev, u32 freq)
+{
+	u8 Data[6];
+	u64 fDCO = 0;
+	u64 RFreq = 0;
+	u32 fOut = 10000000;
+	u64 m_fXtal = 0;
+	u32 N = 0;
+	u64 HSDiv = 0;
+
+	u32 fxtal;
+	u64 MinDiv, MaxDiv, Div;
+	u64 RF;
+
+	if (freq < 10000000 || freq > 525000000)
+		return -EINVAL;
+	mod_si598_writereg(dev, 137, 0x10);
+
+	if (m_fXtal == 0) {
+		mod_si598_writereg(dev, 135, 0x01);
+		mod_si598_readreg(dev, 7, &Data[0]);
+		mod_si598_readreg(dev, 8, &Data[1]);
+		mod_si598_readreg(dev, 9, &Data[2]);
+		mod_si598_readreg(dev, 10, &Data[3]);
+		mod_si598_readreg(dev, 11, &Data[4]);
+		mod_si598_readreg(dev, 12, &Data[5]);
+
+		pr_info(" Data = %02x %02x %02x %02x %02x %02x\n",
+			Data[0], Data[1], Data[2], Data[3], Data[4], Data[5]);
+		RFreq = (((u64)Data[1] & 0x3F) << 32) | ((u64)Data[2] << 24) |
+			((u64)Data[3] << 16) | ((u64)Data[4] << 8) |
+			((u64)Data[5]);
+		if (RFreq == 0)
+			return -EINVAL;
+		HSDiv = ((Data[0] & 0xE0) >> 5) + 4;
+		if (HSDiv == 8 || HSDiv == 10)
+			return -EINVAL;
+		N = (((u32)(Data[0] & 0x1F) << 2) |
+		     ((u32)(Data[1] & 0xE0) >> 6)) + 1;
+		fDCO = fOut * (u64)(HSDiv * N);
+		m_fXtal = fDCO << 28;
+		pr_info("fxtal %016llx  rfreq %016llx\n", m_fXtal, RFreq);
+
+		m_fXtal += RFreq >> 1;
+		m_fXtal = div64_u64(m_fXtal, RFreq);
+
+		pr_info("fOut = %d fXtal = %d fDCO = %d HDIV = %2d, N = %3d\n",
+			(u32) fOut, (u32) m_fXtal, (u32) fDCO, (u32) HSDiv, N);
+	}
+
+	fOut = freq;
+	MinDiv = 4850000000ULL; do_div(MinDiv, freq); MinDiv += 1;
+	MaxDiv = 5670000000ULL; do_div(MaxDiv, freq);
+	Div    = 5260000000ULL; do_div(Div, freq);
+
+	if (Div < MinDiv)
+		Div = Div + 1;
+	pr_info(" fOut = %u MinDiv = %llu MaxDiv = %llu StartDiv = %llu\n",
+		fOut, MinDiv, MaxDiv, Div);
+
+	if (Div <= 11) {
+		N = 1;
+		HSDiv = Div;
+	} else {
+		int retry = 100;
+
+		while (retry > 0) {
+			N = 0;
+			HSDiv = Div;
+			while ((HSDiv > 11) /*|| ((HSDiv * N) != Div)*/) {
+				N = N + 2;
+				HSDiv = Div;
+				do_div(HSDiv, N);
+				if (N > 128)
+					break;
+			}
+			pr_info(" %3d: %llu %llu %llu %u\n",
+				retry, Div, HSDiv * N, HSDiv, N);
+			if (HSDiv * N < MinDiv)
+				Div = Div + 2;
+			else if (HSDiv * N > MaxDiv)
+				Div = Div - 2;
+			else
+				break;
+			retry = retry - 1;
+		}
+		if (retry == 0) {
+			pr_err(" FAIL\n");
+			return -EINVAL;
+		}
+	}
+
+	if (HSDiv == 8 || HSDiv == 10)	{
+		HSDiv = HSDiv >> 1;
+		N = N * 2;
+	}
+
+	if (HSDiv < 4)
+		return -EINVAL;
+
+
+	fDCO = (u64)fOut * (u64)N * (u64)HSDiv;
+	pr_info("fdco %16llx\n", fDCO);
+	RFreq = fDCO<<28;
+	pr_info("%16llx %16llx\n", fDCO, RFreq);
+
+	fxtal = m_fXtal;
+	do_div(RFreq, fxtal);
+	pr_info("%16llx %d\n", RFreq, fxtal);
+	RF = RFreq;
+
+	pr_info("fOut = %u fXtal = %llu fDCO = %llu HSDIV = %llu, N = %u, RFreq = %llu\n",
+		fOut, m_fXtal, fDCO, HSDiv, N, RFreq);
+
+	Data[0] = (u8)(((HSDiv - 4) << 5) | ((N - 1) >> 2));
+	Data[1] = (u8)((((N - 1) & 0x03) << 6) | ((RF >> 32) & 0x3F));
+	Data[2] = (u8)((RF >> 24) & 0xFF);
+	Data[3] = (u8)((RF >> 16) & 0xFF);
+	Data[4] = (u8)((RF >>  8) & 0xFF);
+	Data[5] = (u8)((RF)       & 0xFF);
+
+	pr_info(" Data = %02x %02x %02x %02x %02x %02x\n",
+		Data[0], Data[1], Data[2], Data[3], Data[4], Data[5]);
+	mod_si598_writereg(dev, 7, Data[0]);
+	mod_si598_writereg(dev, 8, Data[1]);
+	mod_si598_writereg(dev, 9, Data[2]);
+	mod_si598_writereg(dev, 10, Data[3]);
+	mod_si598_writereg(dev, 11, Data[4]);
+	mod_si598_writereg(dev, 12, Data[5]);
+
+	mod_si598_writereg(dev, 137, 0x00);
+	mod_si598_writereg(dev, 135, 0x40);
+	return 0;
+}
+
+
+static void mod_bypass_equalizer(struct ddb *dev, int bypass)
+{
+	u32  RegValue;
+
+	RegValue = ddbreadl(dev, IQOUTPUT_CONTROL);
+	RegValue &= ~IQOUTPUT_CONTROL_BYPASS_EQUALIZER;
+	RegValue |= (bypass ? IQOUTPUT_CONTROL_BYPASS_EQUALIZER : 0x00);
+	ddbwritel(dev, RegValue, IQOUTPUT_CONTROL);
+}
+
+static int mod_set_equalizer(struct ddb *dev, u32 Num, s16 *cTable)
+{
+	u32 i, adr = IQOUTPUT_EQUALIZER_0;
+
+	if (Num > 11)
+		return -EINVAL;
+
+	for (i = 0; i < 11 - Num; i += 1) {
+		ddbwritel(dev, 0, adr);
+		adr += 4;
+	}
+	for (i = 0; i < Num; i += 1) {
+		ddbwritel(dev, (u32) cTable[i], adr);
+		adr += 4;
+	}
+	return 0;
+}
+
+static int mod_init_dac_input(struct ddb *dev)
+{
+	u8 Set = 0;
+	u8 Hld = 0;
+	u8 Sample = 0;
+
+	u8 Seek = 0;
+	u8 ReadSeek = 0;
+
+	u8 SetTable[32];
+	u8 HldTable[32];
+	u8 SeekTable[32];
+
+	u8 Sample1 = 0xFF;
+	u8 Sample2 = 0xFF;
+
+	u8 SelectSample = 0xFF;
+	u8 DiffMin = 0xFF;
+
+	for (Sample = 0; Sample < 32; Sample++) {
+		Set = 0;
+		Hld = 0;
+
+		mod_write_dac_register(dev, 0x04, Set << 4 | Hld);
+		mod_write_dac_register(dev, 0x05, Sample);
+		mod_read_dac_register(dev, 0x06, &ReadSeek);
+		Seek = ReadSeek & 0x01;
+		SeekTable[Sample] = Seek;
+
+		HldTable[Sample] = 15;
+
+		for (Hld = 1; Hld < 16; Hld += 1) {
+			mod_write_dac_register(dev, 0x04, Set << 4 | Hld);
+			mod_read_dac_register(dev, 0x06, &ReadSeek);
+
+			if ((ReadSeek & 0x01) != Seek) {
+				HldTable[Sample] = Hld;
+				break;
+			}
+		}
+
+		Hld = 0;
+		SetTable[Sample] = 15;
+		for (Set = 1; Set < 16; Set += 1) {
+			mod_write_dac_register(dev, 0x04, Set << 4 | Hld);
+			mod_read_dac_register(dev, 0x06, &ReadSeek);
+
+			if ((ReadSeek & 0x01) != Seek) {
+				SetTable[Sample] = Set;
+				break;
+			}
+		}
+	}
+
+	Seek = 1;
+	for (Sample = 0; Sample < 32; Sample += 1) {
+		if (Sample1 == 0xFF && SeekTable[Sample] == 1 && Seek == 0)
+			Sample1 = Sample;
+		if (Sample1 != 0xFF && Sample2 == 0xFF &&
+		    SeekTable[Sample] == 0 && Seek == 1)
+			Sample2 = Sample;
+		Seek = SeekTable[Sample];
+	}
+
+	if (Sample1 == 0xFF || Sample2 == 0xFF) {
+		pr_err(" No valid window found\n");
+		return -EINVAL;
+	}
+
+	pr_err(" Window = %d - %d\n", Sample1, Sample2);
+
+	for (Sample = Sample1; Sample < Sample2; Sample += 1) {
+		if (SetTable[Sample] < HldTable[Sample]) {
+			if (HldTable[Sample] - SetTable[Sample] < DiffMin) {
+				DiffMin = HldTable[Sample] - SetTable[Sample];
+				SelectSample = Sample;
+			}
+		}
+	}
+
+	pr_info("Select Sample %d\n", SelectSample);
+
+	if (SelectSample == 0xFF) {
+		pr_err("No valid sample found\n");
+		return -EINVAL;
+	}
+
+	if (HldTable[SelectSample] + SetTable[SelectSample] < 8) {
+		pr_err("Too high jitter\n");
+		return -EINVAL;
+	}
+
+	mod_write_dac_register(dev, 0x04, 0x00);
+	mod_write_dac_register(dev, 0x05, (SelectSample - 1) & 0x1F);
+	mod_read_dac_register(dev, 0x06, &Seek);
+	mod_write_dac_register(dev, 0x05, (SelectSample + 1) & 0x1F);
+	mod_read_dac_register(dev, 0x06, &ReadSeek);
+	Seek &= ReadSeek;
+
+	mod_write_dac_register(dev, 0x05, SelectSample);
+	mod_read_dac_register(dev, 0x06, &ReadSeek);
+	Seek &= ReadSeek;
+	if ((Seek & 0x01) == 0) {
+		pr_err("Insufficient timing margin\n");
+		return -EINVAL;
+	}
+	pr_info("Done\n");
+	return 0;
+}
+
+static void mod_set_up1(struct ddb *dev, u32 Frequency, u32 Ref, u32 Ext)
+{
+	u32 RDiv = Ext / Ref;
+
+	Frequency = Frequency / Ref;
+	mod_set_up_converter_vco1(dev, 0x360001 | (RDiv << 2));
+	mod_set_up_converter_vco1(dev, 0x0ff128);
+	mod_set_up_converter_vco1(dev, 0x02 | (Frequency << 8));
+}
+
+static void mod_set_up2(struct ddb *dev, u32 Frequency, u32 Ref, u32 Ext)
+{
+	u32 Rdiv = Ext / Ref;
+	u32 PreScale = 8;
+
+	Frequency = Frequency / Ref;
+	mod_set_up_converter_vco2(dev, 0x360001 | (Rdiv << 2));
+	mod_set_up_converter_vco2(dev, 0x0fc128 |
+				  (((PreScale - 8) / 8) << 22));
+	mod_set_up_converter_vco2(dev, 0x02 | ((Frequency / PreScale) << 8)
+				  | (Frequency & (PreScale - 1)) << 2);
+}
+
+static int mod_set_down(struct ddb *dev, u32 Frequency, u32 Ref, u32 Ext)
+{
+	u32 BandSelect = Ref * 8;
+	u32 RefMul = 1;
+	u32 RefDiv2 = 1;
+	u32 RefDiv = Ext * RefMul / (Ref * RefDiv2);
+
+	if (Frequency < 2200 || Frequency > 4000)
+		return -EINVAL;
+
+	Frequency = Frequency / Ref;
+
+	mod_set_down_converter_vco(dev, 0x0080003C |
+				   ((BandSelect & 0xFF) << 12));
+	mod_set_down_converter_vco(dev, 0x00000003);
+	mod_set_down_converter_vco(dev, 0x18001E42 | ((RefMul-1) << 25) |
+				   ((RefDiv2-1) << 24) | (RefDiv << 14));
+	mod_set_down_converter_vco(dev, 0x08008021);
+	mod_set_down_converter_vco(dev, Frequency << 15);
+	return 0;
+}
+
+static int mod_set_dac_clock(struct ddb *dev, u32 Frequency)
+{
+	int hr, i;
+
+	if (Frequency) {
+		ddbwritel(dev, DAC_CONTROL_RESET, DAC_CONTROL);
+		msleep(20);
+		if (mod_set_si598(dev, Frequency)) {
+			pr_err("mod_set_si598 failed\n");
+			return -1;
+		}
+		msleep(50);
+		ddbwritel(dev, 0x000, DAC_CONTROL);
+		msleep(20);
+		mod_write_dac_register(dev, 0, 0x02);
+	}
+
+	for (i = 0; i < 10; i++) {
+		hr = mod_init_dac_input(dev);
+		if (hr == 0)
+			break;
+		msleep(100);
+	}
+	pr_info("mod_set_dac_clock OK\n");
+	return hr;
+}
+
+static void mod_set_dac_current(struct ddb *dev, u32 Current1, u32 Current2)
+{
+	mod_write_dac_register2(dev, 0x0b, Current1 & 0x3ff);
+	mod_write_dac_register2(dev, 0x0f, Current2 & 0x3ff);
+}
+
+static void mod_output_enable(struct ddb *dev, int enable)
+{
+
+	u32  RegValue;
+
+	RegValue = ddbreadl(dev, IQOUTPUT_CONTROL);
+	RegValue &= ~(IQOUTPUT_CONTROL_ENABLE | IQOUTPUT_CONTROL_RESET);
+	ddbwritel(dev, RegValue, IQOUTPUT_CONTROL);
+
+	if (enable) {
+		ddbwritel(dev, RegValue | IQOUTPUT_CONTROL_RESET,
+			  IQOUTPUT_CONTROL);
+		msleep(20);
+		ddbwritel(dev, RegValue, IQOUTPUT_CONTROL);
+		ddbwritel(dev, RegValue | IQOUTPUT_CONTROL_ENABLE,
+			  IQOUTPUT_CONTROL);
+	}
+}
+
+static int mod_set_iq(struct ddb *dev, u32 steps, u32 chan, u32 freq)
+{
+	u32 i, j, k, fac = 8;
+	u32 s1 = 22, s2 = 33;
+	u64 amp = (1ULL << 17) - 1ULL;
+	u64 s = 0, c = (amp << s1), ss;
+	u64 frq = 0xC90FDAA22168C235ULL; /* PI << 62 */
+	u32 *iqtab;
+	u32 iqtabadr;
+	u32 regval;
+
+	iqtab = kmalloc((steps + 1) * 4, GFP_KERNEL);
+	if (!iqtab)
+		return -ENOMEM;
+	frq = div64_u64(frq, steps * fac) >> (61 - s2);
+
+	/* create sine table */
+	for (i = 0; i <= steps * fac / 4; i++) {
+		if (!(i & (fac - 1))) {
+			j = i / fac;
+			ss = s >> s1;
+			/* round? ss = ((s >> (s1 - 1)) + 1) >> 1; */
+			iqtab[j] = iqtab[steps / 2 - j] = ss;
+			iqtab[steps / 2 + j] = iqtab[steps - j] = -ss;
+		}
+		c -= ((s * frq) >> s2);
+		s += ((c * frq) >> s2);
+	}
+	iqtabadr = chan << 16;
+	ddbwritel(dev, chan & 0x0f, MODULATOR_IQTABLE_INDEX);
+	for (i = j = 0, k = steps / 4; i < steps; i++) {
+		ddbwritel(dev, (iqtabadr + i) | MODULATOR_IQTABLE_INDEX_SEL_I,
+			  MODULATOR_IQTABLE_INDEX);
+		ddbwritel(dev, iqtab[j], MODULATOR_IQTABLE_DATA);
+		regval = ddbreadl(dev, MODULATOR_CONTROL);
+		ddbwritel(dev, (iqtabadr + i) | MODULATOR_IQTABLE_INDEX_SEL_Q,
+			  MODULATOR_IQTABLE_INDEX);
+		ddbwritel(dev, iqtab[k], MODULATOR_IQTABLE_DATA);
+		regval = ddbreadl(dev, MODULATOR_CONTROL);
+		j += freq;
+		j %= steps;
+		k += freq;
+		k %= steps;
+	}
+	ddbwritel(dev, steps - 1, MODULATOR_IQTABLE_END);
+	kfree(iqtab);
+	return 0;
+}
+
+u32 eqtab[] = {
+	0x0000FFDB, 0x00000121, 0x0000FF0A, 0x000003D7,
+	0x000001C4, 0x000005A5, 0x000009CC, 0x0000F50D,
+	0x00001B23, 0x0000EEB7, 0x00006A28
+};
+
+static int mod_set_modulation(struct ddb *dev, int chan, enum fe_modulation mod)
+{
+	if (mod > QAM_256 || mod < QAM_16)
+		return -EINVAL;
+	dev->mod[chan].modulation = mod;
+	dev->mod[chan].obitrate = 0x0061072787900000ULL * (mod + 3);
+	dev->mod[chan].ibitrate = dev->mod[chan].obitrate;
+	ddbwritel(dev, qamtab[mod], CHANNEL_SETTINGS(chan));
+	return 0;
+}
+
+static void mod_set_channelsumshift(struct ddb *dev, u32 shift)
+{
+	ddbwritel(dev, (shift & 3) << 2, MODULATOR_CONTROL);
+}
+
+static void mod_pre_eq_gain(struct ddb *dev, u16 gain)
+{
+	ddbwritel(dev, gain, IQOUTPUT_PRESCALER);
+}
+
+static void mod_post_eq_gain(struct ddb *dev, u16 igain, u16 qgain)
+{
+	ddbwritel(dev, ((u32)qgain << 16) | igain, IQOUTPUT_POSTSCALER);
+}
+
+static int set_base_frequency(struct ddb *dev, u32 freq)
+{
+	u32 Ext = 40;
+	u32 UP1Frequency = 290;
+	u32 UP2Frequency = 1896;
+	u32 down, freq10;
+
+	pr_info("set base to %u\n", freq);
+	dev->mod_base.frequency = freq;
+	freq /= 1000000;
+	freq10 = dev->mod_base.flat_start + 4;
+	down = freq + 9 * 8 + freq10 + UP1Frequency + UP2Frequency;
+
+	if ((freq10 + 9 * 8) > (dev->mod_base.flat_end - 4)) {
+		pr_err("Frequency out of range %d\n", freq10);
+		return -EINVAL;
+	}
+	if (down % 8) {
+		pr_err(" Invalid Frequency %d\n", down);
+		return -EINVAL;
+	}
+	return mod_set_down(dev, down, 8, Ext);
+}
+
+static int mod_init(struct ddb *dev, u32 Frequency)
+{
+	int stat = 0;
+	u8 *buffer;
+	struct DDMOD_FLASH *flash;
+	u32 Ext = 40;
+	u32 UP1Frequency = 290;
+	u32 UP2Frequency = 1896;
+	u32 DownFrequency;
+	u32 FrequencyCH10;
+	u32 iqfreq, iqsteps, i;
+
+	buffer = kmalloc(4096, GFP_KERNEL);
+	if (!buffer)
+		return -ENOMEM;
+	flash = (struct DDMOD_FLASH *) buffer;
+
+	ddbridge_flashread(dev, 0, buffer, DDMOD_FLASH_START, 4096);
+
+	if (flash->Magic != DDMOD_FLASH_MAGIC && flash->Magic != 1) {
+		stat = -EINVAL;
+		goto fail;
+	}
+	pr_info("srate = %d\n", flash->DataSet[0].Symbolrate * 1000);
+
+	mod_output_enable(dev, 0);
+	stat = mod_set_dac_clock(dev, flash->DataSet[0].DACFrequency * 1000);
+	if (stat < 0) {
+		pr_err("setting DAC clock failed\n");
+		goto fail;
+	}
+	mod_set_dac_current(dev, 512, 512);
+
+	ddbwritel(dev, flash->DataSet[0].Control2, IQOUTPUT_CONTROL2);
+
+	mod_set_up1(dev, UP1Frequency, 5, Ext);
+	mod_set_up2(dev, UP2Frequency, 8, Ext);
+
+	dev->mod_base.flat_start = flash->DataSet[0].FlatStart;
+	dev->mod_base.flat_end = flash->DataSet[0].FlatEnd;
+
+	Frequency /= 1000000;
+	FrequencyCH10 = flash->DataSet[0].FlatStart + 4;
+	DownFrequency = Frequency + 9 * 8 + FrequencyCH10 +
+		UP1Frequency + UP2Frequency;
+	pr_info("CH10 = %d, Down = %d\n", FrequencyCH10, DownFrequency);
+
+	if ((FrequencyCH10 + 9 * 8) > (flash->DataSet[0].FlatEnd - 4)) {
+		pr_err("Frequency out of range %d\n", FrequencyCH10);
+		stat = -EINVAL;
+		goto fail;
+	}
+
+	if (DownFrequency % 8 != 0) {
+		pr_err(" Invalid Frequency %d\n", DownFrequency);
+		stat = -EINVAL;
+		goto fail;
+	}
+
+	mod_set_down(dev, DownFrequency, 8, Ext);
+
+	for (i = 0; i < 10; i++) {
+		ddbwritel(dev, 0, CHANNEL_CONTROL(i));
+
+		iqfreq = flash->DataSet[0].FrequencyFactor *
+			(FrequencyCH10 + (9 - i) * 8);
+		iqsteps = flash->DataSet[0].IQTableLength;
+		mod_set_iq(dev, iqsteps, i, iqfreq);
+		mod_set_modulation(dev, i, QAM_256);
+	}
+
+	mod_bypass_equalizer(dev, 1);
+	mod_set_equalizer(dev, 11, flash->DataSet[0].EQTap);
+	mod_bypass_equalizer(dev, 0);
+	mod_post_eq_gain(dev, flash->DataSet[0].PostScaleI,
+			 flash->DataSet[0].PostScaleQ);
+	mod_pre_eq_gain(dev, flash->DataSet[0].PreScale);
+	/*mod_pre_eq_gain(dev, 0x0680);*/
+	pr_info("prescaler %04x\n", flash->DataSet[0].PreScale);
+	mod_set_channelsumshift(dev, 2);
+	mod_output_enable(dev, 1);
+
+	/*mod_set_attenuator(dev, 10);*/
+fail:
+	kfree(buffer);
+	return stat;
+}
+
+#define PACKET_CLOCKS  (27000000ULL*1504)
+#define FACTOR         (1ULL << 22)
+
+/*
+ * double Increment =  FACTOR*PACKET_CLOCKS/double(m_OutputBitrate);
+ * double Decrement =  FACTOR*PACKET_CLOCKS/double(m_InputBitrate);
+ * 27000000 * 1504 * 2^22 / (6900000 * 188 / 204) = 26785190066.1
+ */
+
+void ddbridge_mod_rate_handler(unsigned long data)
+{
+	struct ddb_output *output = (struct ddb_output *) data;
+	struct ddb_dma *dma = output->dma;
+	struct ddb *dev = output->port->dev;
+	struct mod_state *mod = &dev->mod[output->nr];
+
+	u32 chan = output->nr;
+	u32 OutPacketCount;
+	u32 InPacketCount;
+	u64 OutPackets, InPackets;
+	s64 PCRAdjust;
+	u32 PCRAdjustExt, PCRAdjustExtFrac, InPacketDiff, OutPacketDiff;
+	s32 PCRCorr;
+
+	s64 pcr;
+	s64 PCRIncrementDiff;
+	s64 PCRIncrement;
+	u64 mul;
+
+	if (!mod->pcr_correction)
+		return;
+	spin_lock(&dma->lock);
+	ddbwritel(dev, mod->Control | CHANNEL_CONTROL_FREEZE_STATUS,
+		  CHANNEL_CONTROL(output->nr));
+
+	OutPacketCount = ddbreadl(dev, CHANNEL_PKT_COUNT_OUT(chan));
+	if (OutPacketCount < mod->LastOutPacketCount)
+		mod->OutOverflowPacketCount += 1;
+	mod->LastOutPacketCount = OutPacketCount;
+
+	InPacketCount = ddbreadl(dev, CHANNEL_PKT_COUNT_IN(chan));
+	if (InPacketCount < mod->LastInPacketCount)
+		mod->InOverflowPacketCount += 1;
+	mod->LastInPacketCount = InPacketCount;
+
+	OutPackets = ((u64) (mod->OutOverflowPacketCount) << 20) |
+		OutPacketCount;
+	InPackets = ((u64) (mod->InOverflowPacketCount) << 20) |
+		InPacketCount;
+
+	PCRAdjust = (s64) ((u64) ddbreadl(dev,
+					  CHANNEL_PCR_ADJUST_ACCUL(chan)) |
+			   (((u64) ddbreadl(dev,
+					    CHANNEL_PCR_ADJUST_ACCUH(chan))
+			     << 32)));
+	PCRAdjustExt = (u32)((PCRAdjust & 0x7FFFFFFF) >> 22);
+	PCRAdjustExtFrac = (u32)((PCRAdjust & 0x003FFFFF) >> 12);
+	PCRAdjust >>= 31;
+	InPacketDiff = (u32) (InPackets - mod->LastInPackets);
+	OutPacketDiff = (u32) (OutPackets - mod->LastOutPackets);
+	PCRCorr = 0;
+
+	switch (mod->State) {
+	case CM_STARTUP:
+		if (mod->StateCounter) {
+			if (mod->StateCounter == 1) {
+				if (mod->ibitrate == 0) {
+					mul = (0x1000000 *
+					       (u64) (OutPacketDiff -
+						      InPacketDiff -
+						      InPacketDiff/1000));
+					if (OutPacketDiff)
+						mod->rate_inc = div_u64(mul,
+							 OutPacketDiff);
+					else
+						mod->rate_inc = 0;
+					mod_set_rateinc(dev, output->nr);
+					mod->PCRIncrement =
+						div_u64(26785190066ULL,
+							mod->modulation + 3);
+					if (InPacketDiff)
+						mod->PCRDecrement = div_u64(
+							mod->PCRIncrement *
+							(u64) OutPacketDiff,
+							InPacketDiff);
+					else
+						mod->PCRDecrement = 0;
+					mod_set_incs(output);
+				} else {
+					mod->PCRIncrement =
+						div_u64(26785190066ULL,
+							mod->modulation + 3);
+					mod->PCRDecrement =
+						div_u64(FACTOR*PACKET_CLOCKS,
+							mod->ibitrate >> 32);
+					mod_set_incs(output);
+				}
+			}
+			mod->StateCounter--;
+			break;
+		} else if (InPacketDiff >= mod->MinInputPackets) {
+			mod->State = CM_ADJUST;
+			mod->Control |= CHANNEL_CONTROL_ENABLE_PCRADJUST;
+			mod->InPacketsSum = 0;
+			mod->OutPacketsSum = 0;
+			mod->PCRAdjustSum = 0;
+			mod->StateCounter = CM_AVERAGE;
+		}
+		break;
+
+	case CM_ADJUST:
+		if (InPacketDiff < mod->MinInputPackets) {
+			pr_info("PCR Adjust reset  IN: %u  Min: %u\n",
+				InPacketDiff, mod->MinInputPackets);
+			mod->InPacketsSum = 0;
+			mod->OutPacketsSum = 0;
+			mod->PCRAdjustSum = 0;
+			mod->StateCounter = CM_AVERAGE;
+			ddbwritel(dev,
+				  (mod->Control |
+				   CHANNEL_CONTROL_FREEZE_STATUS) &
+				  ~CHANNEL_CONTROL_ENABLE_PCRADJUST,
+				  CHANNEL_CONTROL(chan));
+			break;
+		}
+
+		mod->PCRAdjustSum += (s32) PCRAdjust;
+		mod->InPacketsSum += InPacketDiff;
+		mod->OutPacketsSum += OutPacketDiff;
+		if (mod->StateCounter--)
+			break;
+
+		if (mod->OutPacketsSum)
+			PCRIncrement = div_s64((s64)mod->InPacketsSum *
+					       (s64)mod->PCRDecrement +
+					       (s64)(mod->OutPacketsSum >> 1),
+					       mod->OutPacketsSum);
+		else
+			PCRIncrement = 0;
+
+		if (mod->PCRAdjustSum > 0)
+			PCRIncrement = RoundPCRDown(PCRIncrement);
+		else
+			PCRIncrement = RoundPCRUp(PCRIncrement);
+
+		PCRIncrementDiff = PCRIncrement - mod->PCRIncrement;
+		if (PCRIncrementDiff > HW_LSB_MASK)
+			PCRIncrementDiff = HW_LSB_MASK;
+		if (PCRIncrementDiff < -HW_LSB_MASK)
+			PCRIncrementDiff = -HW_LSB_MASK;
+
+		mod->PCRIncrement += PCRIncrementDiff;
+		pcr = ConvertPCR(mod->PCRIncrement);
+		pr_info("outl %016llx\n", pcr);
+		ddbwritel(dev,	pcr & 0xffffffff,
+			  CHANNEL_PCR_ADJUST_OUTL(output->nr));
+		ddbwritel(dev,	(pcr >> 32) & 0xffffffff,
+			  CHANNEL_PCR_ADJUST_OUTH(output->nr));
+		mod_busy(dev, chan);
+
+		PCRCorr = (s32) (PCRIncrementDiff >> HW_LSB_SHIFT);
+		mod->PCRRunningCorr += PCRCorr;
+
+		mod->InPacketsSum = 0;
+		mod->OutPacketsSum = 0;
+		mod->PCRAdjustSum = 0;
+		mod->StateCounter = CM_AVERAGE;
+		break;
+
+	default:
+		break;
+	}
+	ddbwritel(dev, mod->Control, CHANNEL_CONTROL(chan));
+
+	mod->LastInPackets = InPackets;
+	mod->LastOutPackets = OutPackets;
+	mod->LastPCRAdjust = (s32) PCRAdjust;
+
+	spin_unlock(&dma->lock);
+
+	pr_info("chan %d out %016llx in %016llx indiff %08x\n",
+		chan, OutPackets, InPackets, InPacketDiff);
+	pr_info("cnt  %d pcra %016llx pcraext %08x pcraextfrac %08x pcrcorr %08x pcri %016llx\n",
+		mod->StateCounter, PCRAdjust, PCRAdjustExt,
+		PCRAdjustExtFrac, PCRCorr, mod->PCRIncrement);
+}
+
+int ddbridge_mod_do_ioctl(struct file *file, unsigned int cmd, void *parg)
+{
+	struct dvb_device *dvbdev = file->private_data;
+	struct ddb_output *output = dvbdev->priv;
+	struct ddb *dev = output->port->dev;
+
+	/* unsigned long arg = (unsigned long) parg; */
+	int ret = 0;
+
+	switch (cmd) {
+	case DVB_MOD_SET:
+	{
+		struct dvb_mod_params *mp = parg;
+
+		pr_info("set base freq\n");
+		if (mp->base_frequency != dev->mod_base.frequency)
+			if (set_base_frequency(dev, mp->base_frequency))
+				return -EINVAL;
+		pr_info("set attenuator\n");
+		mod_set_attenuator(dev, mp->attenuator);
+		break;
+	}
+	case DVB_MOD_CHANNEL_SET:
+	{
+		struct dvb_mod_channel_params *cp = parg;
+		int res;
+		u32 ri;
+
+		pr_info("set modulation\n");
+		res = mod_set_modulation(dev, output->nr, cp->modulation);
+		if (res)
+			return res;
+
+		if (cp->input_bitrate > dev->mod[output->nr].obitrate)
+			return -EINVAL;
+		dev->mod[output->nr].ibitrate = cp->input_bitrate;
+		dev->mod[output->nr].pcr_correction = cp->pcr_correction;
+
+		pr_info("ibitrate %llu\n", dev->mod[output->nr].ibitrate);
+		pr_info("obitrate %llu\n", dev->mod[output->nr].obitrate);
+		if (cp->input_bitrate != 0) {
+			u64 d = dev->mod[output->nr].obitrate -
+				dev->mod[output->nr].ibitrate;
+
+			d = div64_u64(d, dev->mod[output->nr].obitrate >> 24);
+			if (d > 0xfffffe)
+				ri = 0xfffffe;
+			else
+				ri = d;
+		} else
+			ri = 0;
+		dev->mod[output->nr].rate_inc = ri;
+		pr_info("ibr=%llu, obr=%llu, ri=0x%06x\n",
+			dev->mod[output->nr].ibitrate >> 32,
+			dev->mod[output->nr].obitrate >> 32,
+			ri);
+		break;
+	}
+	default:
+		ret = -EINVAL;
+		break;
+	}
+	return ret;
+}
+
+int ddbridge_mod_init(struct ddb *dev)
+{
+	return mod_init(dev, 722000000);
+}
diff --git a/drivers/media/pci/ddbridge/ddbridge-ns.c b/drivers/media/pci/ddbridge/ddbridge-ns.c
new file mode 100644
index 0000000..7b6d659
--- /dev/null
+++ b/drivers/media/pci/ddbridge/ddbridge-ns.c
@@ -0,0 +1,491 @@
+/*
+ * ddbridge-ns.c: Digital Devices PCIe bridge driver net streaming
+ *
+ * Copyright (C) 2010-2015 Marcus Metzler <mocm@metzlerbros.de>
+ *                         Ralph Metzler <rjkm@metzlerbros.de>
+ *                         Digital Devices GmbH
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 only, as published by the Free Software Foundation.
+ *
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA
+ * Or, point your browser to http://www.gnu.org/copyleft/gpl.html
+ */
+
+static int ddb_dvb_ns_input_start(struct ddb_input *input);
+static int ddb_dvb_ns_input_stop(struct ddb_input *input);
+
+static u16 calc_pcs(struct dvb_ns_params *p)
+{
+	u32 sum = 0;
+	u16 pcs;
+
+	sum += (p->sip[0] << 8) | p->sip[1];
+	sum += (p->sip[2] << 8) | p->sip[3];
+	sum += (p->dip[0] << 8) | p->dip[1];
+	sum += (p->dip[2] << 8) | p->dip[3];
+	sum += 0x11; /* UDP proto */
+	sum = (sum >> 16) + (sum & 0xffff);
+	pcs = sum;
+	return pcs;
+}
+
+static u16 calc_pcs16(struct dvb_ns_params *p, int ipv)
+{
+	u32 sum = 0, i;
+	u16 pcs;
+
+	for (i = 0; i < ipv ? 16 : 4; i += 2) {
+		sum += (p->sip[i] << 8) | p->sip[i + 1];
+		sum += (p->dip[i] << 8) | p->dip[i + 1];
+	}
+	sum += 0x11; /* UDP proto */
+	sum = (sum >> 16) + (sum & 0xffff);
+	pcs = sum;
+	return pcs;
+}
+
+/****************************************************************************/
+/****************************************************************************/
+/****************************************************************************/
+
+static void ns_free(struct dvbnss *nss)
+{
+	struct ddb_ns *dns = (struct ddb_ns *) nss->priv;
+	struct dvb_netstream *ns = nss->ns;
+	struct ddb_input *input = ns->priv;
+	struct ddb *dev = input->port->dev;
+
+	mutex_lock(&dev->mutex);
+	dns->input = 0;
+	mutex_unlock(&dev->mutex);
+}
+
+static int ns_alloc(struct dvbnss *nss)
+{
+	struct dvb_netstream *ns = nss->ns;
+	struct ddb_input *input = ns->priv;
+	struct ddb *dev = input->port->dev;
+	int i, ret = -EBUSY;
+
+	mutex_lock(&dev->mutex);
+	for (i = 0; i < dev->ns_num; i++) {
+		if (dev->ns[i].input)
+			continue;
+		dev->ns[i].input = input;
+		dev->ns[i].fe = input;
+		nss->priv = &dev->ns[i];
+		ret = 0;
+		/*pr_info("%s i=%d fe=%d\n", __func__, i, input->nr); */
+		break;
+	}
+	ddbwritel(dev, 0x03, RTP_MASTER_CONTROL);
+	mutex_unlock(&dev->mutex);
+	return ret;
+}
+
+static int ns_set_pids(struct dvbnss *nss)
+{
+	struct dvb_netstream *ns = nss->ns;
+	struct ddb_input *input = ns->priv;
+	struct ddb *dev = input->port->dev;
+	struct ddb_ns *dns = (struct ddb_ns *) nss->priv;
+
+	if (dev->link[0].ids.devid == 0x0301dd01) {
+		u32 sys = 0;
+		int pid, j = 1;
+
+		sys |= nss->pids[0] & 3;
+		sys |= (nss->pids[2] & 0x1f) << 4;
+		ddbwritel(dev, sys, PID_FILTER_SYSTEM_PIDS(dns->nr));
+		for (pid = 20; j < 5 && pid < 8192; pid++)
+			if (nss->pids[pid >> 3] & (1 << (pid & 7))) {
+				ddbwritel(dev, 0x8000 | pid,
+					  PID_FILTER_PID(dns->nr, j));
+				j++;
+			}
+		/* disable unused pids */
+		for (; j < 5; j++)
+			ddbwritel(dev, 0, PID_FILTER_PID(dns->nr, j));
+	} else
+		ddbcpyto(dev, STREAM_PIDS(dns->nr), nss->pids, 0x400);
+	return 0;
+}
+
+static int ns_set_pid(struct dvbnss *nss, u16 pid)
+{
+	struct dvb_netstream *ns = nss->ns;
+	struct ddb_input *input = ns->priv;
+	struct ddb *dev = input->port->dev;
+	struct ddb_ns *dns = (struct ddb_ns *) nss->priv;
+	u16 byte = (pid & 0x1fff) >> 3;
+	u8 bit = 1 << (pid & 7);
+	u32 off = STREAM_PIDS(dns->nr);
+
+	if (dev->link[0].ids.devid == 0x0301dd01) {
+		if (pid & 0x2000) {
+			if (pid & 0x8000)
+				memset(nss->pids, 0xff, 0x400);
+			else
+				memset(nss->pids, 0x00, 0x400);
+		} else {
+			if (pid & 0x8000)
+				nss->pids[byte] |= bit;
+			else
+				nss->pids[byte] &= ~bit;
+		}
+		ns_set_pids(nss);
+	} else {
+		if (pid & 0x2000) {
+			if (pid & 0x8000)
+				ddbmemset(dev, off, 0xff, 0x400);
+			else
+				ddbmemset(dev, off, 0x00, 0x400);
+		} else {
+			u8 val = ddbreadb(dev, off + byte);
+
+			if (pid & 0x8000)
+				ddbwriteb(dev, val | bit, off + byte);
+			else
+				ddbwriteb(dev, val & ~bit, off + byte);
+		}
+	}
+	return 0;
+}
+
+static int citoport(struct ddb *dev, u8 ci)
+{
+	int i, j;
+
+	for (i = j = 0; i < dev->link[0].info->port_num; i++) {
+		if (dev->port[i].class == DDB_PORT_CI) {
+			if (j == ci)
+				return i;
+			j++;
+		}
+	}
+	return -1;
+}
+
+static int ns_set_ci(struct dvbnss *nss, u8 ci)
+{
+	struct dvb_netstream *ns = nss->ns;
+	struct ddb_input *input = ns->priv;
+	struct ddb *dev = input->port->dev;
+	struct ddb_ns *dns = (struct ddb_ns *) nss->priv;
+	int ciport;
+
+	if (ci == 255) {
+		dns->fe = input;
+		return 0;
+	}
+	ciport = citoport(dev, ci);
+	if (ciport < 0)
+		return -EINVAL;
+
+	pr_info("input %d.%d to ci %d at port %d\n", input->port->lnr,
+		input->nr, ci, ciport);
+	ddbwritel(dev, (input->port->lnr << 21) | (input->nr << 16) | 0x1c,
+		TS_OUTPUT_CONTROL(ciport));
+	usleep_range(1, 5);
+	ddbwritel(dev, (input->port->lnr << 21) | (input->nr << 16) | 0x1d,
+		TS_OUTPUT_CONTROL(ciport));
+	dns->fe = dev->port[ciport].input[0];
+	return 0;
+}
+
+static u8 rtp_head[]  = {
+	0x80, 0x21,
+	0x00, 0x00, /* seq number */
+	0x00, 0x00, 0x00, 0x00, /* time stamp*/
+	0x91, 0x82, 0x73, 0x64, /* SSRC */
+};
+
+static u8 rtcp_head[] = {
+	/* SR off 42:8 len 28*/
+	0x80, 0xc8, /* SR type */
+	0x00, 0x06, /* len  */
+	0x91, 0x82, 0x73, 0x64, /* SSRC */
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* NTP */
+	0x73, 0x64, 0x00, 0x00, /* RTP TS */
+	0x00, 0x00, 0x00, 0x00, /* packet count */
+	0x00, 0x00, 0x00, 0x00, /* octet count */
+	/* SDES off 70:36 len 20 */
+	0x81, 0xca, /* SDES */
+	0x00, 0x03, /* len */
+	0x91, 0x82, 0x73, 0x64, /* SSRC */
+	0x01, 0x05, /* CNAME item */
+	0x53, 0x41, 0x54, 0x49, 0x50, /* "SATIP" */
+	0x00, /* item type 0 */
+	/*  APP off 86:52 len 16+string  length */
+	0x80, 0xcc, /* APP */
+	0x00, 0x04, /* len */
+	0x91, 0x82, 0x73, 0x64, /* SSRC */
+	0x53, 0x45, 0x53, 0x31, /* "SES1" */
+	0x00, 0x00, /* identifier */
+	0x00, 0x00, /* string length */
+	/* string off 102:68 */
+};
+
+static int ns_set_rtcp_msg(struct dvbnss *nss, u8 *msg, u32 len)
+{
+	struct dvb_netstream *ns = nss->ns;
+	struct ddb_input *input = ns->priv;
+	struct ddb *dev = input->port->dev;
+	struct ddb_ns *dns = (struct ddb_ns *) nss->priv;
+	u32 off = STREAM_PACKET_ADR(dns->nr);
+	u32 coff = 96;
+	u16 wlen;
+
+	if (!len) {
+		ddbwritel(dev, ddbreadl(dev, STREAM_CONTROL(dns->nr)) &
+			  ~0x10,
+			  STREAM_CONTROL(dns->nr));
+		return 0;
+	}
+	if (copy_from_user(dns->p + coff + dns->rtcp_len, msg, len))
+		return -EFAULT;
+	dns->p[coff + dns->rtcp_len - 2] = (len >> 8);
+	dns->p[coff + dns->rtcp_len - 1] = (len & 0xff);
+	if (len & 3) {
+		u32 pad = 4 - (len & 3);
+
+		memset(dns->p + coff + dns->rtcp_len + len, 0, pad);
+		len += pad;
+	}
+	wlen = len / 4;
+	wlen += 3;
+	dns->p[coff + dns->rtcp_len - 14] = (wlen >> 8);
+	dns->p[coff + dns->rtcp_len - 13] = (wlen & 0xff);
+	ddbcpyto(dev, off, dns->p, sizeof(dns->p));
+	ddbwritel(dev, (dns->rtcp_udplen + len) |
+		  ((STREAM_PACKET_OFF(dns->nr) + coff) << 16),
+		  STREAM_RTCP_PACKET(dns->nr));
+	ddbwritel(dev, ddbreadl(dev, STREAM_CONTROL(dns->nr)) | 0x10,
+		  STREAM_CONTROL(dns->nr));
+	return 0;
+}
+
+static u32 set_nsbuf(struct dvb_ns_params *p, u8 *buf,
+		     u32 *udplen, int rtcp, int vlan)
+{
+	u32 c = 0;
+	u16 pcs;
+	u16 sport, dport;
+
+	sport = rtcp ? p->sport2 : p->sport;
+	dport = rtcp ? p->dport2 : p->dport;
+
+	/* MAC header */
+	memcpy(buf + c, p->dmac, 6);
+	memcpy(buf + c + 6, p->smac, 6);
+	c += 12;
+	if (vlan) {
+		buf[c + 0] = 0x81;
+		buf[c + 1] = 0x00;
+		buf[c + 2] = ((p->qos & 7) << 5) | ((p->vlan & 0xf00) >> 8);
+		buf[c + 3] = p->vlan & 0xff;
+		c += 4;
+	}
+	buf[c + 0] = 0x08;
+	buf[c + 1] = 0x00;
+	c += 2;
+
+	/* IP header */
+	if (p->flags & DVB_NS_IPV6) {
+		u8 ip6head[8]  = { 0x65, 0x00, 0x00, 0x00,
+				    0x00, 0x00, 0x11, 0x00, };
+		memcpy(buf + c, ip6head, sizeof(ip6head));
+		buf[c + 7] = p->ttl;
+		memcpy(buf + c +  8, p->sip, 16);
+		memcpy(buf + c + 24, p->dip, 16);
+		c += 40;
+
+		/* UDP */
+		buf[c + 0] = sport >> 8;
+		buf[c + 1] = sport & 0xff;
+		buf[c + 2] = dport >> 8;
+		buf[c + 3] = dport & 0xff;
+		buf[c + 4] = 0; /* length */
+		buf[c + 5] = 0;
+		pcs = calc_pcs16(p, p->flags & DVB_NS_IPV6);
+		buf[c + 6] = pcs >> 8;
+		buf[c + 7] = pcs & 0xff;
+		c += 8;
+		*udplen = 8;
+
+	} else {
+		u8 ip4head[12]  = { 0x45, 0x00, 0x00, 0x00, 0x00, 0x00,
+				    0x40, 0x00, 0x40, 0x11, 0x00, 0x00 };
+
+		memcpy(buf + c, ip4head, sizeof(ip4head));
+		buf[c + 8] = p->ttl;
+		memcpy(buf + c + 12, p->sip, 4);
+		memcpy(buf + c + 16, p->dip, 4);
+		c += 20;
+
+		/* UDP */
+		buf[c + 0] = sport >> 8;
+		buf[c + 1] = sport & 0xff;
+		buf[c + 2] = dport >> 8;
+		buf[c + 3] = dport & 0xff;
+		buf[c + 4] = 0; /* length */
+		buf[c + 5] = 0;
+		pcs = calc_pcs(p);
+		buf[c + 6] = pcs >> 8;
+		buf[c + 7] = pcs & 0xff;
+		c += 8;
+		*udplen = 8;
+	}
+
+	if (rtcp) {
+		memcpy(buf + c, rtcp_head, sizeof(rtcp_head));
+		memcpy(buf + c +  4, p->ssrc, 4);
+		memcpy(buf + c + 32, p->ssrc, 4);
+		memcpy(buf + c + 48, p->ssrc, 4);
+		c += sizeof(rtcp_head);
+		*udplen += sizeof(rtcp_head);
+	} else if (p->flags & DVB_NS_RTP) {
+		memcpy(buf + c, rtp_head, sizeof(rtp_head));
+		memcpy(buf + c + 8, p->ssrc, 4);
+		c += sizeof(rtp_head);
+		*udplen += sizeof(rtp_head);
+	}
+	return c;
+}
+
+static int ns_set_ts_packets(struct dvbnss *nss, u8 *buf, u32 len)
+{
+	struct ddb_ns *dns = (struct ddb_ns *) nss->priv;
+	struct dvb_netstream *ns = nss->ns;
+	struct ddb_input *input = ns->priv;
+	struct ddb *dev = input->port->dev;
+	u32 off = STREAM_PACKET_ADR(dns->nr);
+
+	if (nss->params.flags & DVB_NS_RTCP)
+		return -EINVAL;
+
+	if (copy_from_user(dns->p + dns->ts_offset, buf, len))
+		return -EFAULT;
+	ddbcpyto(dev, off, dns->p, sizeof(dns->p));
+	return 0;
+}
+
+static int ns_insert_ts_packets(struct dvbnss *nss, u8 count)
+{
+	struct ddb_ns *dns = (struct ddb_ns *) nss->priv;
+	struct dvb_netstream *ns = nss->ns;
+	struct ddb_input *input = ns->priv;
+	struct ddb *dev = input->port->dev;
+	u32 value = count;
+
+	if (nss->params.flags & DVB_NS_RTCP)
+		return -EINVAL;
+
+	if (count < 1 || count > 2)
+		return -EINVAL;
+
+	ddbwritel(dev, value, STREAM_INSERT_PACKET(dns->nr));
+	return 0;
+}
+
+static int ns_set_net(struct dvbnss *nss)
+{
+	struct dvb_netstream *ns = nss->ns;
+	struct ddb_input *input = ns->priv;
+	struct ddb *dev = input->port->dev;
+	struct dvb_ns_params *p = &nss->params;
+	struct ddb_ns *dns = (struct ddb_ns *) nss->priv;
+	u32 off = STREAM_PACKET_ADR(dns->nr);
+	u32 coff = 96;
+
+	dns->ts_offset = set_nsbuf(p, dns->p, &dns->udplen, 0, dev->vlan);
+	if (nss->params.flags & DVB_NS_RTCP)
+		dns->rtcp_len = set_nsbuf(p, dns->p + coff,
+					  &dns->rtcp_udplen, 1, dev->vlan);
+	ddbcpyto(dev, off, dns->p, sizeof(dns->p));
+	ddbwritel(dev, dns->udplen | (STREAM_PACKET_OFF(dns->nr) << 16),
+		  STREAM_RTP_PACKET(dns->nr));
+	ddbwritel(dev, dns->rtcp_udplen |
+		  ((STREAM_PACKET_OFF(dns->nr) + coff) << 16),
+		  STREAM_RTCP_PACKET(dns->nr));
+	return 0;
+}
+
+static int ns_start(struct dvbnss *nss)
+{
+	struct ddb_ns *dns = (struct ddb_ns *) nss->priv;
+	struct dvb_netstream *ns = nss->ns;
+	struct ddb_input *input = ns->priv;
+	struct ddb *dev = input->port->dev;
+	u32 reg = 0x8003;
+
+	if (nss->params.flags & DVB_NS_RTCP)
+		reg |= 0x10;
+	if (nss->params.flags & DVB_NS_RTP_TO)
+		reg |= 0x20;
+	if (nss->params.flags & DVB_NS_RTP)
+		reg |= 0x40;
+	if (nss->params.flags & DVB_NS_IPV6)
+		reg |= 0x80;
+	if (dns->fe != input)
+		ddb_dvb_ns_input_start(dns->fe);
+	ddb_dvb_ns_input_start(input);
+	pr_info("ns start ns %u, fe %u link %u\n",
+		dns->nr, dns->fe->nr, dns->fe->port->lnr);
+	ddbwritel(dev, reg | (dns->fe->nr << 8) | (dns->fe->port->lnr << 16),
+		  STREAM_CONTROL(dns->nr));
+	return 0;
+}
+
+static int ns_stop(struct dvbnss *nss)
+{
+	struct ddb_ns *dns = (struct ddb_ns *) nss->priv;
+	struct dvb_netstream *ns = nss->ns;
+	struct ddb_input *input = ns->priv;
+	struct ddb *dev = input->port->dev;
+
+	ddbwritel(dev, 0x00, STREAM_CONTROL(dns->nr));
+	ddb_dvb_ns_input_stop(input);
+	if (dns->fe != input)
+		ddb_dvb_ns_input_stop(dns->fe);
+	return 0;
+}
+
+static int netstream_init(struct ddb_input *input)
+{
+	struct ddb_dvb *dvb = &input->port->dvb[input->nr & 1];
+	struct dvb_adapter *adap = dvb->adap;
+	struct dvb_netstream *ns = &dvb->dvbns;
+	struct ddb *dev = input->port->dev;
+	int i, res;
+
+	ddbmemset(dev, STREAM_PIDS(input->nr), 0x00, 0x400);
+	for (i = 0; i < dev->ns_num; i++)
+		dev->ns[i].nr = i;
+	ns->priv = input;
+	ns->set_net = ns_set_net;
+	ns->set_rtcp_msg = ns_set_rtcp_msg;
+	ns->set_ts_packets = ns_set_ts_packets;
+	ns->insert_ts_packets = ns_insert_ts_packets;
+	ns->set_pid = ns_set_pid;
+	ns->set_pids = ns_set_pids;
+	ns->set_ci = ns_set_ci;
+	ns->start = ns_start;
+	ns->stop = ns_stop;
+	ns->alloc = ns_alloc;
+	ns->free = ns_free;
+	res = dvb_netstream_init(adap, ns);
+	return res;
+}
diff --git a/drivers/media/pci/ddbridge/ddbridge-regs.h b/drivers/media/pci/ddbridge/ddbridge-regs.h
index a3ccb31..596f322 100644
--- a/drivers/media/pci/ddbridge/ddbridge-regs.h
+++ b/drivers/media/pci/ddbridge/ddbridge-regs.h
@@ -1,7 +1,7 @@
 /*
  * ddbridge-regs.h: Digital Devices PCIe bridge driver
  *
- * Copyright (C) 2010-2011 Digital Devices GmbH
+ * Copyright (C) 2010-2015 Digital Devices GmbH
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -21,11 +21,11 @@
  * Or, point your browser to http://www.gnu.org/copyleft/gpl.html
  */
 
-/* DD-DVBBridgeV1.h 273 2010-09-17 05:03:16Z manfred */
-
 /* Register Definitions */
 
-#define CUR_REGISTERMAP_VERSION 0x10000
+#define CUR_REGISTERMAP_VERSION     0x10003
+#define CUR_REGISTERMAP_VERSION_CI  0x10000
+#define CUR_REGISTERMAP_VERSION_MOD 0x10000
 
 #define HARDWARE_VERSION       0x00
 #define REGISTERMAP_VERSION    0x04
@@ -37,10 +37,30 @@
 #define SPI_DATA        0x14
 
 /* ------------------------------------------------------------------------- */
+/* GPIO */
+
+#define GPIO_OUTPUT      0x20
+#define GPIO_INPUT       0x24
+#define GPIO_DIRECTION   0x28
+
+/* ------------------------------------------------------------------------- */
+/* MDIO */
+
+#define MDIO_CTRL        0x20
+#define MDIO_ADR         0x24
+#define MDIO_REG         0x28
+#define MDIO_VAL         0x2C
+
+/* ------------------------------------------------------------------------- */
+
+#define BOARD_CONTROL    0x30
+
+/* ------------------------------------------------------------------------- */
 
-/* Interrupt controller                                     */
-/* How many MSI's are available depends on HW (Min 2 max 8) */
-/* How many are usable also depends on Host platform        */
+/* Interrupt controller
+ * How many MSI's are available depends on HW (Min 2 max 8)
+ * How many are usable also depends on Host platform
+ */
 
 #define INTERRUPT_BASE   (0x40)
 
@@ -57,6 +77,9 @@
 #define INTERRUPT_STATUS (INTERRUPT_BASE + 0x20)
 #define INTERRUPT_ACK    (INTERRUPT_BASE + 0x20)
 
+#define INTMASK_CLOCKGEN    (0x00000001)
+#define INTMASK_TEMPMON     (0x00000002)
+
 #define INTMASK_I2C1        (0x00000001)
 #define INTMASK_I2C2        (0x00000002)
 #define INTMASK_I2C3        (0x00000004)
@@ -81,6 +104,35 @@
 #define INTMASK_TSOUTPUT3   (0x00040000)
 #define INTMASK_TSOUTPUT4   (0x00080000)
 
+
+
+/* Modulator registers */
+
+/*  Clock Generator ( Sil598 @ 0xAA I2c ) */
+#define CLOCKGEN_BASE       (0x80)
+#define CLOCKGEN_CONTROL    (CLOCKGEN_BASE + 0x00)
+#define CLOCKGEN_INDEX      (CLOCKGEN_BASE + 0x04)
+#define CLOCKGEN_WRITEDATA  (CLOCKGEN_BASE + 0x08)
+#define CLOCKGEN_READDATA   (CLOCKGEN_BASE + 0x0C)
+
+/* DAC ( AD9781/AD9783 SPI ) */
+#define DAC_BASE            (0x090)
+#define DAC_CONTROL         (DAC_BASE)
+#define DAC_WRITE_DATA      (DAC_BASE+4)
+#define DAC_READ_DATA       (DAC_BASE+8)
+
+#define DAC_CONTROL_INSTRUCTION_REG (0xFF)
+#define DAC_CONTROL_STARTIO         (0x100)
+#define DAC_CONTROL_RESET           (0x200)
+
+/* Temperature Monitor ( 2x LM75A @ 0x90,0x92 I2c ) */
+#define TEMPMON_BASE        (0xA0)
+#define TEMPMON_CONTROL    (TEMPMON_BASE + 0x00)
+/* SHORT Temperature in C x 256 */
+#define TEMPMON_CORE       (TEMPMON_BASE + 0x04)
+#define TEMPMON_SENSOR1    (TEMPMON_BASE + 0x08)
+#define TEMPMON_SENSOR2    (TEMPMON_BASE + 0x0C)
+
 /* ------------------------------------------------------------------------- */
 /* I2C Master Controller */
 
@@ -90,19 +142,10 @@
 #define I2C_TIMING      (0x04)
 #define I2C_TASKLENGTH  (0x08)     /* High read, low write */
 #define I2C_TASKADDRESS (0x0C)     /* High read, low write */
-
 #define I2C_MONITOR     (0x1C)
 
-#define I2C_BASE_1      (I2C_BASE + 0x00)
-#define I2C_BASE_2      (I2C_BASE + 0x20)
-#define I2C_BASE_3      (I2C_BASE + 0x40)
-#define I2C_BASE_4      (I2C_BASE + 0x60)
-
-#define I2C_BASE_N(i)   (I2C_BASE + (i) * 0x20)
-
-#define I2C_TASKMEM_BASE    (0x1000)    /* Byte offset */
-#define I2C_TASKMEM_SIZE    (0x1000)
 
+#define I2C_SPEED_666   (0x02010202)
 #define I2C_SPEED_400   (0x04030404)
 #define I2C_SPEED_200   (0x09080909)
 #define I2C_SPEED_154   (0x0C0B0C0C)
@@ -117,35 +160,273 @@
 #define DMA_BASE_WRITE        (0x100)
 #define DMA_BASE_READ         (0x140)
 
-#define DMA_CONTROL     (0x00)                  /* 64 */
-#define DMA_ERROR       (0x04)                  /* 65 ( only read instance ) */
-
-#define DMA_DIAG_CONTROL                (0x1C)  /* 71 */
-#define DMA_DIAG_PACKETCOUNTER_LOW      (0x20)  /* 72 */
-#define DMA_DIAG_PACKETCOUNTER_HIGH     (0x24)  /* 73 */
-#define DMA_DIAG_TIMECOUNTER_LOW        (0x28)  /* 74 */
-#define DMA_DIAG_TIMECOUNTER_HIGH       (0x2C)  /* 75 */
-#define DMA_DIAG_RECHECKCOUNTER         (0x30)  /* 76  ( Split completions on read ) */
-#define DMA_DIAG_WAITTIMEOUTINIT        (0x34)  /* 77 */
-#define DMA_DIAG_WAITOVERFLOWCOUNTER    (0x38)  /* 78 */
-#define DMA_DIAG_WAITCOUNTER            (0x3C)  /* 79 */
+#define DMA_CONTROL     (0x00)
+#define DMA_ERROR       (0x04)
 
-/* ------------------------------------------------------------------------- */
-/* DMA  Buffer */
+#define DMA_DIAG_CONTROL                (0x1C)
+#define DMA_DIAG_PACKETCOUNTER_LOW      (0x20)
+#define DMA_DIAG_PACKETCOUNTER_HIGH     (0x24)
+#define DMA_DIAG_TIMECOUNTER_LOW        (0x28)
+#define DMA_DIAG_TIMECOUNTER_HIGH       (0x2C)
+#define DMA_DIAG_RECHECKCOUNTER         (0x30)
+#define DMA_DIAG_WAITTIMEOUTINIT        (0x34)
+#define DMA_DIAG_WAITOVERFLOWCOUNTER    (0x38)
+#define DMA_DIAG_WAITCOUNTER            (0x3C)
 
 #define TS_INPUT_BASE       (0x200)
-#define TS_INPUT_CONTROL(i)         (TS_INPUT_BASE + (i) * 16 + 0x00)
+#define TS_INPUT_CONTROL(i)         (TS_INPUT_BASE + (i) * 0x10 + 0x00)
+#define TS_INPUT_CONTROL2(i)        (TS_INPUT_BASE + (i) * 0x10 + 0x04)
 
 #define TS_OUTPUT_BASE       (0x280)
-#define TS_OUTPUT_CONTROL(i)         (TS_OUTPUT_BASE + (i) * 16 + 0x00)
+#define TS_OUTPUT_CONTROL(i)        (TS_OUTPUT_BASE + (i) * 0x10 + 0x00)
+#define TS_OUTPUT_CONTROL2(i)       (TS_OUTPUT_BASE + (i) * 0x10 + 0x04)
+
+/* ------------------------------------------------------------------------- */
+/* DMA  Buffer */
 
 #define DMA_BUFFER_BASE     (0x300)
 
-#define DMA_BUFFER_CONTROL(i)       (DMA_BUFFER_BASE + (i) * 16 + 0x00)
-#define DMA_BUFFER_ACK(i)           (DMA_BUFFER_BASE + (i) * 16 + 0x04)
-#define DMA_BUFFER_CURRENT(i)       (DMA_BUFFER_BASE + (i) * 16 + 0x08)
-#define DMA_BUFFER_SIZE(i)          (DMA_BUFFER_BASE + (i) * 16 + 0x0c)
+#define DMA_BUFFER_CONTROL(i)       (DMA_BUFFER_BASE + (i) * 0x10 + 0x00)
+#define DMA_BUFFER_ACK(i)           (DMA_BUFFER_BASE + (i) * 0x10 + 0x04)
+#define DMA_BUFFER_CURRENT(i)       (DMA_BUFFER_BASE + (i) * 0x10 + 0x08)
+#define DMA_BUFFER_SIZE(i)          (DMA_BUFFER_BASE + (i) * 0x10 + 0x0c)
 
 #define DMA_BASE_ADDRESS_TABLE  (0x2000)
 #define DMA_BASE_ADDRESS_TABLE_ENTRIES (512)
 
+
+/* ------------------------------------------------------------------------- */
+
+#define LNB_BASE                     (0x400)
+#define LNB_CONTROL(i)               (LNB_BASE + (i) * 0x20 + 0x00)
+#define LNB_CMD   (7ULL <<  0)
+#define LNB_CMD_NOP    0
+#define LNB_CMD_INIT   1
+#define LNB_CMD_STATUS 2
+#define LNB_CMD_LOW    3
+#define LNB_CMD_HIGH   4
+#define LNB_CMD_OFF    5
+#define LNB_CMD_DISEQC 6
+#define LNB_CMD_UNI    7
+
+#define LNB_BUSY  (1ULL <<  4)
+#define LNB_TONE  (1ULL << 15)
+
+#define LNB_STATUS(i)                (LNB_BASE + (i) * 0x20 + 0x04)
+#define LNB_VOLTAGE(i)               (LNB_BASE + (i) * 0x20 + 0x08)
+#define LNB_CONFIG(i)                (LNB_BASE + (i) * 0x20 + 0x0c)
+#define LNB_BUF_LEVEL(i)             (LNB_BASE + (i) * 0x20 + 0x10)
+#define LNB_BUF_WRITE(i)             (LNB_BASE + (i) * 0x20 + 0x14)
+
+/* ------------------------------------------------------------------------- */
+/* CI Interface (only CI-Bridge) */
+
+#define CI_BASE                     (0x400)
+#define CI_CONTROL(i)               (CI_BASE + (i) * 32 + 0x00)
+
+#define CI_DO_ATTRIBUTE_RW(i)       (CI_BASE + (i) * 32 + 0x04)
+#define CI_DO_IO_RW(i)              (CI_BASE + (i) * 32 + 0x08)
+#define CI_READDATA(i)              (CI_BASE + (i) * 32 + 0x0c)
+#define CI_DO_READ_ATTRIBUTES(i)    (CI_BASE + (i) * 32 + 0x10)
+
+#define CI_RESET_CAM                    (0x00000001)
+#define CI_POWER_ON                     (0x00000002)
+#define CI_ENABLE                       (0x00000004)
+#define CI_BLOCKIO_ENABLE               (0x00000008)
+#define CI_BYPASS_DISABLE               (0x00000010)
+#define CI_DISABLE_AUTO_OFF             (0x00000020)
+
+#define CI_CAM_READY                    (0x00010000)
+#define CI_CAM_DETECT                   (0x00020000)
+#define CI_READY                        (0x80000000)
+#define CI_BLOCKIO_ACTIVE               (0x40000000)
+#define CI_BLOCKIO_RCVDATA              (0x20000000)
+#define CI_BLOCKIO_SEND_PENDING         (0x10000000)
+#define CI_BLOCKIO_SEND_COMPLETE        (0x08000000)
+
+#define CI_READ_CMD                     (0x40000000)
+#define CI_WRITE_CMD                    (0x80000000)
+
+#define CI_BLOCKIO_SEND(i)              (CI_BASE + (i) * 32 + 0x14)
+#define CI_BLOCKIO_RECEIVE(i)           (CI_BASE + (i) * 32 + 0x18)
+
+#define CI_BLOCKIO_SEND_COMMAND         (0x80000000)
+#define CI_BLOCKIO_SEND_COMPLETE_ACK    (0x40000000)
+#define CI_BLOCKIO_RCVDATA_ACK          (0x40000000)
+
+#define CI_BUFFER_BASE                  (0x3000)
+#define CI_BUFFER_SIZE                  (0x0800)
+#define CI_BLOCKIO_BUFFER_SIZE          (CI_BUFFER_SIZE/2)
+
+#define CI_BUFFER(i)                  (CI_BUFFER_BASE + (i) * CI_BUFFER_SIZE)
+#define CI_BLOCKIO_RECEIVE_BUFFER(i)  (CI_BUFFER_BASE + (i) * CI_BUFFER_SIZE)
+#define CI_BLOCKIO_SEND_BUFFER(i)  \
+	(CI_BUFFER_BASE + (i) * CI_BUFFER_SIZE + CI_BLOCKIO_BUFFER_SIZE)
+
+#define VCO1_BASE           (0xC0)
+#define VCO1_CONTROL        (VCO1_BASE + 0x00)
+#define VCO1_DATA           (VCO1_BASE + 0x04)  /* 24 Bit */
+/* 1 = Trigger write, resets when done */
+#define VCO1_CONTROL_WRITE  (0x00000001)
+/* 0 = Put VCO into power down */
+#define VCO1_CONTROL_CE     (0x00000002)
+/* Muxout from VCO (usually = Lock) */
+#define VCO1_CONTROL_MUXOUT (0x00000004)
+
+#define VCO2_BASE           (0xC8)
+#define VCO2_CONTROL        (VCO2_BASE + 0x00)
+#define VCO2_DATA           (VCO2_BASE + 0x04)  /* 24 Bit */
+/* 1 = Trigger write, resets when done */
+#define VCO2_CONTROL_WRITE  (0x00000001)
+/* 0 = Put VCO into power down */
+#define VCO2_CONTROL_CE     (0x00000002)
+/* Muxout from VCO (usually = Lock) */
+#define VCO2_CONTROL_MUXOUT (0x00000004)
+
+#define VCO3_BASE           (0xD0)
+#define VCO3_CONTROL        (VCO3_BASE + 0x00)
+#define VCO3_DATA           (VCO3_BASE + 0x04)  /* 32 Bit */
+/* 1 = Trigger write, resets when done */
+#define VCO3_CONTROL_WRITE  (0x00000001)
+/* 0 = Put VCO into power down */
+#define VCO3_CONTROL_CE     (0x00000002)
+/* Muxout from VCO (usually = Lock) */
+#define VCO3_CONTROL_MUXOUT (0x00000004)
+
+#define RF_ATTENUATOR   (0xD8)
+/*  0x00 =  0 dB
+ *  0x01 =  1 dB
+ *    ...
+ *  0x1F = 31 dB
+ */
+
+#define RF_POWER        (0xE0)
+#define RF_POWER_BASE       (0xE0)
+#define RF_POWER_CONTROL    (RF_POWER_BASE + 0x00)
+#define RF_POWER_DATA       (RF_POWER_BASE + 0x04)
+
+#define RF_POWER_CONTROL_START     (0x00000001)
+#define RF_POWER_CONTROL_DONE      (0x00000002)
+#define RF_POWER_CONTROL_VALIDMASK (0x00000700)
+#define RF_POWER_CONTROL_VALID     (0x00000500)
+
+
+/* --------------------------------------------------------------------------
+ * Output control
+ */
+
+#define IQOUTPUT_BASE           (0x240)
+#define IQOUTPUT_CONTROL        (IQOUTPUT_BASE + 0x00)
+#define IQOUTPUT_CONTROL2       (IQOUTPUT_BASE + 0x04)
+#define IQOUTPUT_PEAK_DETECTOR  (IQOUTPUT_BASE + 0x08)
+#define IQOUTPUT_POSTSCALER     (IQOUTPUT_BASE + 0x0C)
+#define IQOUTPUT_PRESCALER      (IQOUTPUT_BASE + 0x10)
+
+#define IQOUTPUT_EQUALIZER_0    (IQOUTPUT_BASE + 0x14)
+#define IQOUTPUT_EQUALIZER_1    (IQOUTPUT_BASE + 0x18)
+#define IQOUTPUT_EQUALIZER_2    (IQOUTPUT_BASE + 0x1C)
+#define IQOUTPUT_EQUALIZER_3    (IQOUTPUT_BASE + 0x20)
+#define IQOUTPUT_EQUALIZER_4    (IQOUTPUT_BASE + 0x24)
+#define IQOUTPUT_EQUALIZER_5    (IQOUTPUT_BASE + 0x28)
+#define IQOUTPUT_EQUALIZER_6    (IQOUTPUT_BASE + 0x2C)
+#define IQOUTPUT_EQUALIZER_7    (IQOUTPUT_BASE + 0x30)
+#define IQOUTPUT_EQUALIZER_8    (IQOUTPUT_BASE + 0x34)
+#define IQOUTPUT_EQUALIZER_9    (IQOUTPUT_BASE + 0x38)
+#define IQOUTPUT_EQUALIZER_10   (IQOUTPUT_BASE + 0x3C)
+
+#define IQOUTPUT_EQUALIZER(i)   (IQOUTPUT_EQUALIZER_0 + (i) * 4)
+
+#define IQOUTPUT_CONTROL_RESET              (0x00000001)
+#define IQOUTPUT_CONTROL_ENABLE             (0x00000002)
+#define IQOUTPUT_CONTROL_RESET_PEAK         (0x00000004)
+#define IQOUTPUT_CONTROL_ENABLE_PEAK        (0x00000008)
+#define IQOUTPUT_CONTROL_BYPASS_EQUALIZER   (0x00000010)
+
+
+/* Modulator Base */
+
+#define MODULATOR_BASE          (0x200)
+#define MODULATOR_CONTROL         (MODULATOR_BASE)
+#define MODULATOR_IQTABLE_END     (MODULATOR_BASE+4)
+#define MODULATOR_IQTABLE_INDEX   (MODULATOR_BASE+8)
+#define MODULATOR_IQTABLE_DATA    (MODULATOR_BASE+12)
+
+#define MODULATOR_IQTABLE_INDEX_CHANNEL_MASK  (0x000F0000)
+#define MODULATOR_IQTABLE_INDEX_IQ_MASK       (0x00008000)
+#define MODULATOR_IQTABLE_INDEX_ADDRESS_MASK  (0x000007FF)
+#define MODULATOR_IQTABLE_INDEX_SEL_I         (0x00000000)
+#define MODULATOR_IQTABLE_INDEX_SEL_Q     (MODULATOR_IQTABLE_INDEX_IQ_MASK)
+#define MODULATOR_IQTABLE_SIZE    (2048)
+
+
+/* Modulator Channels */
+
+#define CHANNEL_BASE                (0x400)
+#define CHANNEL_CONTROL(i)          (CHANNEL_BASE + (i) * 64 + 0x00)
+#define CHANNEL_SETTINGS(i)         (CHANNEL_BASE + (i) * 64 + 0x04)
+#define CHANNEL_RATE_INCR(i)        (CHANNEL_BASE + (i) * 64 + 0x0C)
+#define CHANNEL_PCR_ADJUST_OUTL(i)  (CHANNEL_BASE + (i) * 64 + 0x10)
+#define CHANNEL_PCR_ADJUST_OUTH(i)  (CHANNEL_BASE + (i) * 64 + 0x14)
+#define CHANNEL_PCR_ADJUST_INL(i)   (CHANNEL_BASE + (i) * 64 + 0x18)
+#define CHANNEL_PCR_ADJUST_INH(i)   (CHANNEL_BASE + (i) * 64 + 0x1C)
+#define CHANNEL_PCR_ADJUST_ACCUL(i) (CHANNEL_BASE + (i) * 64 + 0x20)
+#define CHANNEL_PCR_ADJUST_ACCUH(i) (CHANNEL_BASE + (i) * 64 + 0x24)
+#define CHANNEL_PKT_COUNT_OUT(i)    (CHANNEL_BASE + (i) * 64 + 0x28)
+#define CHANNEL_PKT_COUNT_IN(i)     (CHANNEL_BASE + (i) * 64 + 0x2C)
+
+#define CHANNEL_CONTROL_RESET               (0x00000001)
+#define CHANNEL_CONTROL_ENABLE_DVB          (0x00000002)
+#define CHANNEL_CONTROL_ENABLE_IQ           (0x00000004)
+#define CHANNEL_CONTROL_ENABLE_SOURCE       (0x00000008)
+#define CHANNEL_CONTROL_ENABLE_PCRADJUST    (0x00000010)
+#define CHANNEL_CONTROL_FREEZE_STATUS       (0x00000100)
+
+#define CHANNEL_CONTROL_RESET_ERROR         (0x00010000)
+#define CHANNEL_CONTROL_BUSY                (0x01000000)
+#define CHANNEL_CONTROL_ERROR_SYNC          (0x20000000)
+#define CHANNEL_CONTROL_ERROR_UNDERRUN      (0x40000000)
+#define CHANNEL_CONTROL_ERROR_FATAL         (0x80000000)
+
+#define CHANNEL_SETTINGS_QAM_MASK           (0x00000007)
+#define CHANNEL_SETTINGS_QAM16              (0x00000000)
+#define CHANNEL_SETTINGS_QAM32              (0x00000001)
+#define CHANNEL_SETTINGS_QAM64              (0x00000002)
+#define CHANNEL_SETTINGS_QAM128             (0x00000003)
+#define CHANNEL_SETTINGS_QAM256             (0x00000004)
+
+
+/* OCTONET */
+
+#define ETHER_BASE       (0x100)
+#define ETHER_CONTROL    (ETHER_BASE + 0x00)
+#define ETHER_LENGTH     (ETHER_BASE + 0x04)
+
+#define RTP_MASTER_BASE      (0x120)
+#define RTP_MASTER_CONTROL          (RTP_MASTER_BASE + 0x00)
+#define RTP_RTCP_INTERRUPT          (RTP_MASTER_BASE + 0x04)
+#define RTP_MASTER_RTCP_SETTINGS    (RTP_MASTER_BASE + 0x0c)
+
+#define STREAM_BASE       (0x400)
+#define STREAM_CONTROL(i)        (STREAM_BASE + (i) * 0x20 + 0x00)
+#define STREAM_RTP_PACKET(i)        (STREAM_BASE + (i) * 0x20 + 0x04)
+#define STREAM_RTCP_PACKET(i)       (STREAM_BASE + (i) * 0x20 + 0x08)
+#define STREAM_RTP_SETTINGS(i)      (STREAM_BASE + (i) * 0x20 + 0x0c)
+#define STREAM_INSERT_PACKET(i)     (STREAM_BASE + (i) * 0x20 + 0x10)
+
+#define STREAM_PACKET_OFF(i) ((i) * 0x200)
+#define STREAM_PACKET_ADR(i) (0x2000 + (STREAM_PACKET_OFF(i)))
+
+#define STREAM_PIDS(i) (0x4000 + (i) * 0x400)
+
+#define TS_CAPTURE_BASE (0x0140)
+#define TS_CAPTURE_CONTROL       (TS_CAPTURE_BASE + 0x00)
+#define TS_CAPTURE_PID           (TS_CAPTURE_BASE + 0x04)
+#define TS_CAPTURE_RECEIVED      (TS_CAPTURE_BASE + 0x08)
+#define TS_CAPTURE_TIMEOUT       (TS_CAPTURE_BASE + 0x0c)
+#define TS_CAPTURE_TABLESECTION  (TS_CAPTURE_BASE + 0x10)
+
+#define TS_CAPTURE_MEMORY (0x7000)
+
+#define PID_FILTER_BASE       (0x800)
+#define PID_FILTER_SYSTEM_PIDS(i)     (PID_FILTER_BASE + (i) * 0x20)
+#define PID_FILTER_PID(i, j)     (PID_FILTER_BASE + (i) * 0x20 + (j) * 4)
diff --git a/drivers/media/pci/ddbridge/ddbridge.c b/drivers/media/pci/ddbridge/ddbridge.c
new file mode 100644
index 0000000..b9d93f2
--- /dev/null
+++ b/drivers/media/pci/ddbridge/ddbridge.c
@@ -0,0 +1,541 @@
+/*
+ * ddbridge.c: Digital Devices PCIe bridge driver
+ *
+ * Copyright (C) 2010-2015 Digital Devices GmbH
+ *                         Ralph Metzler <rjkm@metzlerbros.de>
+ *                         Marcus Metzler <mocm@metzlerbros.de>
+ *
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 only, as published by the Free Software Foundation.
+ *
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA
+ * Or, point your browser to http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*#define DDB_ALT_DMA*/
+#define DDB_USE_WORK
+/*#define DDB_TEST_THREADED*/
+
+#include "ddbridge.h"
+#include "ddbridge-regs.h"
+
+static struct workqueue_struct *ddb_wq;
+
+static int adapter_alloc;
+module_param(adapter_alloc, int, 0444);
+MODULE_PARM_DESC(adapter_alloc,
+		 "0-one adapter per io, 1-one per tab with io, 2-one per tab, 3-one for all");
+
+#ifdef CONFIG_PCI_MSI
+#define DDB_USE_MSI_IRQHANDLERS
+#ifdef CONFIG_DVB_DDBRIDGE_MSIENABLE
+static int msi = 1;
+#else
+static int msi = 0;
+#endif
+module_param(msi, int, 0444);
+MODULE_PARM_DESC(msi,
+#ifdef CONFIG_DVB_DDBRIDGE_MSIENABLE
+		 " Control MSI interrupts: 0-disable, 1-enable (default)");
+#else
+		 " Control MSI interrupts: 0-disable (default), 1-enable");
+#endif
+#endif
+
+#include "ddbridge-core.c"
+
+/****************************************************************************/
+/****************************************************************************/
+/****************************************************************************/
+
+static void ddb_unmap(struct ddb *dev)
+{
+	if (dev->regs)
+		iounmap(dev->regs);
+	vfree(dev);
+}
+
+
+static void ddb_remove(struct pci_dev *pdev)
+{
+	struct ddb *dev = (struct ddb *) pci_get_drvdata(pdev);
+
+	ddb_device_destroy(dev);
+	ddb_nsd_detach(dev);
+	ddb_ports_detach(dev);
+	ddb_i2c_release(dev);
+
+	if (dev->link[0].info->ns_num)
+		ddbwritel(dev, 0, ETHER_CONTROL);
+	ddbwritel(dev, 0, INTERRUPT_ENABLE);
+
+	ddbwritel(dev, 0, MSI1_ENABLE);
+	if (dev->msi == 2)
+		free_irq(dev->pdev->irq + 1, dev);
+	free_irq(dev->pdev->irq, dev);
+#ifdef CONFIG_PCI_MSI
+	if (dev->msi)
+		pci_disable_msi(dev->pdev);
+#endif
+	ddb_ports_release(dev);
+	ddb_buffers_free(dev);
+
+	ddb_unmap(dev);
+	pci_set_drvdata(pdev, NULL);
+	pci_disable_device(pdev);
+}
+
+static int ddb_probe(struct pci_dev *pdev,
+			       const struct pci_device_id *id)
+{
+	struct ddb *dev;
+	int stat = 0;
+	int irq_flag = IRQF_SHARED;
+
+	if (pci_enable_device(pdev) < 0)
+		return -ENODEV;
+
+	dev = vzalloc(sizeof(struct ddb));
+	if (dev == NULL)
+		return -ENOMEM;
+
+	mutex_init(&dev->mutex);
+	dev->has_dma = 1;
+	dev->pdev = pdev;
+	dev->dev = &pdev->dev;
+	pci_set_drvdata(pdev, dev);
+
+	dev->link[0].ids.vendor = id->vendor;
+	dev->link[0].ids.device = id->device;
+	dev->link[0].ids.subvendor = id->subvendor;
+	dev->link[0].ids.subdevice = id->subdevice;
+
+	dev->link[0].dev = dev;
+	dev->link[0].info = (struct ddb_info *) id->driver_data;
+	pr_info("DDBridge driver detected: %s\n", dev->link[0].info->name);
+
+	dev->regs_len = pci_resource_len(dev->pdev, 0);
+	dev->regs = ioremap(pci_resource_start(dev->pdev, 0),
+			    pci_resource_len(dev->pdev, 0));
+
+	if (!dev->regs) {
+		pr_err("DDBridge: not enough memory for register map\n");
+		stat = -ENOMEM;
+		goto fail;
+	}
+	if (ddbreadl(dev, 0) == 0xffffffff) {
+		pr_err("DDBridge: cannot read registers\n");
+		stat = -ENODEV;
+		goto fail;
+	}
+
+	dev->link[0].ids.hwid = ddbreadl(dev, 0);
+	dev->link[0].ids.regmapid = ddbreadl(dev, 4);
+
+	pr_info("DDBridge: HW %08x REGMAP %08x\n",
+		dev->link[0].ids.hwid, dev->link[0].ids.regmapid);
+
+	if (dev->link[0].info->ns_num) {
+		int i;
+
+		ddbwritel(dev, 0, ETHER_CONTROL);
+		for (i = 0; i < 16; i++)
+			ddbwritel(dev, 0x00, TS_OUTPUT_CONTROL(i));
+		usleep_range(5000, 6000);
+	}
+	ddbwritel(dev, 0x00000000, INTERRUPT_ENABLE);
+	ddbwritel(dev, 0x00000000, MSI1_ENABLE);
+	ddbwritel(dev, 0x00000000, MSI2_ENABLE);
+	ddbwritel(dev, 0x00000000, MSI3_ENABLE);
+	ddbwritel(dev, 0x00000000, MSI4_ENABLE);
+	ddbwritel(dev, 0x00000000, MSI5_ENABLE);
+	ddbwritel(dev, 0x00000000, MSI6_ENABLE);
+	ddbwritel(dev, 0x00000000, MSI7_ENABLE);
+
+#ifdef CONFIG_PCI_MSI
+	if (msi && pci_msi_enabled()) {
+		stat = pci_enable_msi_range(dev->pdev, 1, 2);
+		if (stat >= 1) {
+			dev->msi = stat;
+			pr_info("DDBridge: using %d MSI interrupt(s)\n",
+				dev->msi);
+			irq_flag = 0;
+		} else
+			pr_info("DDBridge: MSI not available.\n");
+	}
+	if (dev->msi == 2) {
+		stat = request_irq(dev->pdev->irq, irq_handler0,
+				   irq_flag, "ddbridge", (void *) dev);
+		if (stat < 0)
+			goto fail0;
+		stat = request_irq(dev->pdev->irq + 1, irq_handler1,
+				   irq_flag, "ddbridge", (void *) dev);
+		if (stat < 0) {
+			free_irq(dev->pdev->irq, dev);
+			goto fail0;
+		}
+	} else
+#endif
+	{
+#ifdef DDB_TEST_THREADED
+		stat = request_threaded_irq(dev->pdev->irq, irq_handler,
+					    irq_thread,
+					    irq_flag,
+					    "ddbridge", (void *) dev);
+#else
+		stat = request_irq(dev->pdev->irq, irq_handler,
+				   irq_flag, "ddbridge", (void *) dev);
+#endif
+		if (stat < 0)
+			goto fail0;
+	}
+	ddbwritel(dev, 0, DMA_BASE_READ);
+	if (dev->link[0].info->type != DDB_MOD)
+		ddbwritel(dev, 0, DMA_BASE_WRITE);
+
+	if (dev->link[0].info->type == DDB_MOD) {
+		if  (ddbreadl(dev, 0x1c) == 4)
+			dev->link[0].info->port_num = 4;
+	}
+
+	/*ddbwritel(dev, 0xffffffff, INTERRUPT_ACK);*/
+	if (dev->msi == 2) {
+		ddbwritel(dev, 0x0fffff00, INTERRUPT_ENABLE);
+		ddbwritel(dev, 0x0000000f, MSI1_ENABLE);
+	} else {
+		ddbwritel(dev, 0x0fffff0f, INTERRUPT_ENABLE);
+		ddbwritel(dev, 0x00000000, MSI1_ENABLE);
+	}
+	if (ddb_init(dev) == 0)
+		return 0;
+
+	ddbwritel(dev, 0, INTERRUPT_ENABLE);
+	ddbwritel(dev, 0, MSI1_ENABLE);
+	free_irq(dev->pdev->irq, dev);
+	if (dev->msi == 2)
+		free_irq(dev->pdev->irq + 1, dev);
+fail0:
+	pr_err("fail0\n");
+	if (dev->msi)
+		pci_disable_msi(dev->pdev);
+fail:
+	pr_err("fail\n");
+
+	ddb_unmap(dev);
+	pci_set_drvdata(pdev, NULL);
+	pci_disable_device(pdev);
+	return -1;
+}
+
+/****************************************************************************/
+/****************************************************************************/
+/****************************************************************************/
+
+static struct ddb_regset octopus_i2c = {
+	.base = 0x80,
+	.num  = 0x04,
+	.size = 0x20,
+};
+
+static struct ddb_regset octopus_i2c_buf = {
+	.base = 0x1000,
+	.num  = 0x04,
+	.size = 0x200,
+};
+
+/****************************************************************************/
+
+
+static struct ddb_regmap octopus_map = {
+	.i2c = &octopus_i2c,
+	.i2c_buf = &octopus_i2c_buf,
+};
+
+static struct ddb_regmap octopus_net_map = {
+	.i2c = &octopus_i2c,
+	.i2c_buf = &octopus_i2c_buf,
+};
+
+static struct ddb_regmap octopus_mod_map = {
+};
+
+
+/****************************************************************************/
+
+static struct ddb_info ddb_none = {
+	.type     = DDB_NONE,
+	.name     = "unknown Digital Devices PCIe card, install newer driver",
+	.regmap   = &octopus_map,
+};
+
+static struct ddb_info ddb_octopus = {
+	.type     = DDB_OCTOPUS,
+	.name     = "Digital Devices Octopus DVB adapter",
+	.regmap   = &octopus_map,
+	.port_num = 4,
+	.i2c_mask = 0x0f,
+};
+
+static struct ddb_info ddb_octopusv3 = {
+	.type     = DDB_OCTOPUS,
+	.name     = "Digital Devices Octopus V3 DVB adapter",
+	.regmap   = &octopus_map,
+	.port_num = 4,
+	.i2c_mask = 0x0f,
+};
+
+static struct ddb_info ddb_octopus_le = {
+	.type     = DDB_OCTOPUS,
+	.name     = "Digital Devices Octopus LE DVB adapter",
+	.regmap   = &octopus_map,
+	.port_num = 2,
+	.i2c_mask = 0x03,
+};
+
+static struct ddb_info ddb_octopus_oem = {
+	.type     = DDB_OCTOPUS,
+	.name     = "Digital Devices Octopus OEM",
+	.regmap   = &octopus_map,
+	.port_num = 4,
+	.i2c_mask = 0x0f,
+	.led_num  = 1,
+	.fan_num  = 1,
+	.temp_num = 1,
+	.temp_bus = 0,
+};
+
+static struct ddb_info ddb_octopus_mini = {
+	.type     = DDB_OCTOPUS,
+	.name     = "Digital Devices Octopus Mini",
+	.regmap   = &octopus_map,
+	.port_num = 4,
+	.i2c_mask = 0x0f,
+};
+
+static struct ddb_info ddb_v6 = {
+	.type     = DDB_OCTOPUS,
+	.name     = "Digital Devices Cine S2 V6 DVB adapter",
+	.regmap   = &octopus_map,
+	.port_num = 3,
+	.i2c_mask = 0x07,
+};
+
+static struct ddb_info ddb_v6_5 = {
+	.type     = DDB_OCTOPUS,
+	.name     = "Digital Devices Cine S2 V6.5 DVB adapter",
+	.regmap   = &octopus_map,
+	.port_num = 4,
+	.i2c_mask = 0x0f,
+};
+
+static struct ddb_info ddb_v7 = {
+	.type     = DDB_OCTOPUS,
+	.name     = "Digital Devices Cine S2 V7 DVB adapter",
+	.regmap   = &octopus_map,
+	.port_num = 4,
+	.i2c_mask = 0x0f,
+	.board_control   = 2,
+	.board_control_2 = 4,
+	.ts_quirks = TS_QUIRK_REVERSED,
+};
+
+static struct ddb_info ddb_ctv7 = {
+	.type     = DDB_OCTOPUS,
+	.name     = "Digital Devices Cine CT V7 DVB adapter",
+	.regmap   = &octopus_map,
+	.port_num = 4,
+	.i2c_mask = 0x0f,
+	.board_control   = 3,
+	.board_control_2 = 4,
+};
+
+static struct ddb_info ddb_satixS2v3 = {
+	.type     = DDB_OCTOPUS,
+	.name     = "Mystique SaTiX-S2 V3 DVB adapter",
+	.regmap   = &octopus_map,
+	.port_num = 3,
+	.i2c_mask = 0x07,
+};
+
+static struct ddb_info ddb_ci = {
+	.type     = DDB_OCTOPUS_CI,
+	.name     = "Digital Devices Octopus CI",
+	.regmap   = &octopus_map,
+	.port_num = 4,
+	.i2c_mask = 0x03,
+};
+
+static struct ddb_info ddb_cis = {
+	.type     = DDB_OCTOPUS_CI,
+	.name     = "Digital Devices Octopus CI single",
+	.regmap   = &octopus_map,
+	.port_num = 3,
+	.i2c_mask = 0x03,
+};
+
+static struct ddb_info ddb_ci_s2_pro = {
+	.type     = DDB_OCTOPUS_CI,
+	.name     = "Digital Devices Octopus CI S2 Pro",
+	.regmap   = &octopus_map,
+	.port_num = 4,
+	.i2c_mask = 0x01,
+	.board_control   = 2,
+	.board_control_2 = 4,
+};
+
+static struct ddb_info ddb_dvbct = {
+	.type     = DDB_OCTOPUS,
+	.name     = "Digital Devices DVBCT V6.1 DVB adapter",
+	.regmap   = &octopus_map,
+	.port_num = 3,
+	.i2c_mask = 0x07,
+};
+
+/****************************************************************************/
+
+static struct ddb_info ddb_s2_48 = {
+	.type     = DDB_OCTOPUS_MAX,
+	.name     = "Digital Devices MAX S8 4/8",
+	.regmap   = &octopus_map,
+	.port_num = 4,
+	.i2c_mask = 0x01,
+	.board_control = 1,
+};
+
+static struct ddb_info ddb_ct_8 = {
+	.type     = DDB_OCTOPUS_MAX_CT,
+	.name     = "Digital Devices MAX CT8",
+	.regmap   = &octopus_map,
+	.port_num = 4,
+	.i2c_mask = 0x0f,
+	.board_control   = 0x0ff,
+	.board_control_2 = 0xf00,
+	.ts_quirks = TS_QUIRK_SERIAL,
+};
+
+static struct ddb_info ddb_mod = {
+	.type     = DDB_MOD,
+	.name     = "Digital Devices DVB-C modulator",
+	.regmap   = &octopus_mod_map,
+	.port_num = 10,
+	.temp_num = 1,
+};
+
+static struct ddb_info ddb_octopus_net = {
+	.type     = DDB_OCTONET,
+	.name     = "Digital Devices OctopusNet network DVB adapter",
+	.regmap   = &octopus_net_map,
+	.port_num = 10,
+	.i2c_mask = 0x3ff,
+	.ns_num   = 12,
+	.mdio_num = 1,
+};
+
+/****************************************************************************/
+/****************************************************************************/
+/****************************************************************************/
+
+#define DDVID 0xdd01 /* Digital Devices Vendor ID */
+
+#define DDB_ID(_vend, _dev, _subvend, _subdev, _driverdata) { \
+	.vendor      = _vend,    .device    = _dev, \
+	.subvendor   = _subvend, .subdevice = _subdev, \
+	.driver_data = (unsigned long)&_driverdata }
+
+static const struct pci_device_id ddb_id_tbl[] = {
+	DDB_ID(DDVID, 0x0002, DDVID, 0x0001, ddb_octopus),
+	DDB_ID(DDVID, 0x0003, DDVID, 0x0001, ddb_octopus),
+	DDB_ID(DDVID, 0x0005, DDVID, 0x0004, ddb_octopusv3),
+	DDB_ID(DDVID, 0x0003, DDVID, 0x0002, ddb_octopus_le),
+	DDB_ID(DDVID, 0x0003, DDVID, 0x0003, ddb_octopus_oem),
+	DDB_ID(DDVID, 0x0003, DDVID, 0x0010, ddb_octopus_mini),
+	DDB_ID(DDVID, 0x0005, DDVID, 0x0011, ddb_octopus_mini),
+	DDB_ID(DDVID, 0x0003, DDVID, 0x0020, ddb_v6),
+	DDB_ID(DDVID, 0x0003, DDVID, 0x0021, ddb_v6_5),
+	DDB_ID(DDVID, 0x0006, DDVID, 0x0022, ddb_v7),
+	DDB_ID(DDVID, 0x0003, DDVID, 0x0030, ddb_dvbct),
+	DDB_ID(DDVID, 0x0003, DDVID, 0xdb03, ddb_satixS2v3),
+	DDB_ID(DDVID, 0x0006, DDVID, 0x0031, ddb_ctv7),
+	DDB_ID(DDVID, 0x0006, DDVID, 0x0032, ddb_ctv7),
+	DDB_ID(DDVID, 0x0006, DDVID, 0x0033, ddb_ctv7),
+	DDB_ID(DDVID, 0x0007, DDVID, 0x0023, ddb_s2_48),
+	DDB_ID(DDVID, 0x0008, DDVID, 0x0034, ddb_ct_8),
+	DDB_ID(DDVID, 0x0008, DDVID, 0x0035, ddb_ct_8),
+	DDB_ID(DDVID, 0x0008, DDVID, 0x0036, ddb_ct_8),
+	DDB_ID(DDVID, 0x0011, DDVID, 0x0040, ddb_ci),
+	DDB_ID(DDVID, 0x0011, DDVID, 0x0041, ddb_cis),
+	DDB_ID(DDVID, 0x0012, DDVID, 0x0042, ddb_ci),
+	DDB_ID(DDVID, 0x0013, DDVID, 0x0043, ddb_ci_s2_pro),
+	DDB_ID(DDVID, 0x0201, DDVID, 0x0001, ddb_mod),
+	DDB_ID(DDVID, 0x0201, DDVID, 0x0002, ddb_mod),
+	DDB_ID(DDVID, 0x0320, PCI_ANY_ID, PCI_ANY_ID, ddb_octopus_net),
+	/* in case sub-ids got deleted in flash */
+	DDB_ID(DDVID, 0x0003, PCI_ANY_ID, PCI_ANY_ID, ddb_none),
+	DDB_ID(DDVID, 0x0005, PCI_ANY_ID, PCI_ANY_ID, ddb_none),
+	DDB_ID(DDVID, 0x0006, PCI_ANY_ID, PCI_ANY_ID, ddb_none),
+	DDB_ID(DDVID, 0x0007, PCI_ANY_ID, PCI_ANY_ID, ddb_none),
+	DDB_ID(DDVID, 0x0008, PCI_ANY_ID, PCI_ANY_ID, ddb_none),
+	DDB_ID(DDVID, 0x0011, PCI_ANY_ID, PCI_ANY_ID, ddb_none),
+	DDB_ID(DDVID, 0x0013, PCI_ANY_ID, PCI_ANY_ID, ddb_none),
+	DDB_ID(DDVID, 0x0201, PCI_ANY_ID, PCI_ANY_ID, ddb_none),
+	DDB_ID(DDVID, 0x0320, PCI_ANY_ID, PCI_ANY_ID, ddb_none),
+	{0}
+};
+MODULE_DEVICE_TABLE(pci, ddb_id_tbl);
+
+static struct pci_driver ddb_pci_driver = {
+	.name        = "ddbridge",
+	.id_table    = ddb_id_tbl,
+	.probe       = ddb_probe,
+	.remove      = ddb_remove,
+};
+
+static __init int module_init_ddbridge(void)
+{
+	int stat = -1;
+
+	pr_info("Digital Devices PCIE bridge driver "
+		DDBRIDGE_VERSION
+		", Copyright (C) 2010-15 Digital Devices GmbH\n");
+	if (ddb_class_create() < 0)
+		return -1;
+	ddb_wq = create_workqueue("ddbridge");
+	if (ddb_wq == NULL)
+		goto exit1;
+	stat = pci_register_driver(&ddb_pci_driver);
+	if (stat < 0)
+		goto exit2;
+	return stat;
+exit2:
+	destroy_workqueue(ddb_wq);
+exit1:
+	ddb_class_destroy();
+	return stat;
+}
+
+static __exit void module_exit_ddbridge(void)
+{
+	pci_unregister_driver(&ddb_pci_driver);
+	destroy_workqueue(ddb_wq);
+	ddb_class_destroy();
+}
+
+module_init(module_init_ddbridge);
+module_exit(module_exit_ddbridge);
+
+MODULE_DESCRIPTION("Digital Devices PCIe Bridge");
+MODULE_AUTHOR("Ralph and Marcus Metzler, Metzler Brothers Systementwicklung GbR");
+MODULE_LICENSE("GPL");
+MODULE_VERSION(DDBRIDGE_VERSION);
diff --git a/drivers/media/pci/ddbridge/ddbridge.h b/drivers/media/pci/ddbridge/ddbridge.h
index be87fbd..edc42de 100644
--- a/drivers/media/pci/ddbridge/ddbridge.h
+++ b/drivers/media/pci/ddbridge/ddbridge.h
@@ -1,7 +1,8 @@
 /*
  * ddbridge.h: Digital Devices PCIe bridge driver
  *
- * Copyright (C) 2010-2011 Digital Devices GmbH
+ * Copyright (C) 2010-2015 Digital Devices GmbH
+ *                         Ralph Metzler <rmetzler@digitaldevices.de>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -24,16 +25,41 @@
 #ifndef _DDBRIDGE_H_
 #define _DDBRIDGE_H_
 
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/poll.h>
+#include <linux/io.h>
+#include <linux/pci.h>
+#include <linux/timer.h>
+#include <linux/i2c.h>
+#include <linux/swab.h>
+#include <linux/vmalloc.h>
+#include <linux/workqueue.h>
+#include <linux/kthread.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/spi/spi.h>
+#include <linux/gpio.h>
+#include <linux/completion.h>
+
 #include <linux/types.h>
 #include <linux/sched.h>
 #include <linux/interrupt.h>
-#include <linux/i2c.h>
 #include <linux/mutex.h>
 #include <asm/dma.h>
-#include <linux/dvb/frontend.h>
+#include <asm/irq.h>
+#include <linux/io.h>
+#include <linux/uaccess.h>
+
 #include <linux/dvb/ca.h>
 #include <linux/socket.h>
+#include <linux/device.h>
+#include <linux/io.h>
 
+#include "dvb_netstream.h"
 #include "dmxdev.h"
 #include "dvbdev.h"
 #include "dvb_demux.h"
@@ -41,143 +67,582 @@
 #include "dvb_ringbuffer.h"
 #include "dvb_ca_en50221.h"
 #include "dvb_net.h"
+
+#include "tda18271c2dd.h"
+#include "stv6110x.h"
+#include "stv090x.h"
+#include "lnbh24.h"
+#include "drxk.h"
+#include "stv0367dd.h"
+#include "tda18212.h"
+#include "cxd2843.h"
 #include "cxd2099.h"
+#include "stv0910.h"
+#include "stv6111.h"
+#include "lnbh25.h"
+#include "mxl5xx.h"
+
+#define DDB_MAX_I2C    16
+#define DDB_MAX_PORT   16
+#define DDB_MAX_INPUT  44
+#define DDB_MAX_OUTPUT 10
+#define DDB_MAX_LINK    4
+#define DDB_LINK_SHIFT 28
+
+#define DDB_LINK_TAG(_x) (_x << DDB_LINK_SHIFT)
+
+struct ddb_regset {
+	u32 base;
+	u32 num;
+	u32 size;
+};
+
+struct ddb_ports {
+	u32 base;
+	u32 num;
+	u32 size;
+};
+
+struct ddb_regmap {
+	struct ddb_ports  *bc;
+	struct ddb_regset *i2c;
+	struct ddb_regset *i2c_buf;
+	struct ddb_regset *dma;
+	struct ddb_regset *dma_buf;
+	struct ddb_regset *input;
+	struct ddb_regset *output;
+	struct ddb_regset *channel;
+	struct ddb_regset *ci;
+	struct ddb_regset *pid_filter;
+	struct ddb_regset *ns;
+	struct ddb_regset *gtl;
+};
 
-#define DDB_MAX_I2C     4
-#define DDB_MAX_PORT    4
-#define DDB_MAX_INPUT   8
-#define DDB_MAX_OUTPUT  4
+struct ddb_ids {
+	u16 vendor;
+	u16 device;
+	u16 subvendor;
+	u16 subdevice;
+
+	u32 hwid;
+	u32 regmapid;
+	u32 devid;
+	u32 mac;
+};
 
 struct ddb_info {
 	int   type;
 #define DDB_NONE         0
 #define DDB_OCTOPUS      1
+#define DDB_OCTOPUS_CI   2
+#define DDB_MOD          3
+#define DDB_OCTONET      4
+#define DDB_OCTOPUS_MAX  5
+#define DDB_OCTOPUS_MAX_CT  6
 	char *name;
-	int   port_num;
-	u32   port_type[DDB_MAX_PORT];
+	u32   i2c_mask;
+	u8    port_num;
+	u8    led_num;
+	u8    fan_num;
+	u8    temp_num;
+	u8    temp_bus;
+	u32   board_control;
+	u32   board_control_2;
+	u8    ns_num;
+	u8    mdio_num;
+	u8    con_clock; /* use a continuous clock */
+	u8    ts_quirks;
+#define TS_QUIRK_SERIAL   1
+#define TS_QUIRK_REVERSED 2
+	struct ddb_regmap *regmap;
 };
 
-/* DMA_SIZE MUST be divisible by 188 and 128 !!! */
+/* DMA_SIZE MUST be smaller than 256k and
+ * MUST be divisible by 188 and 128 !!!
+ */
+
+#define DMA_MAX_BUFS 32      /* hardware table limit */
 
-#define INPUT_DMA_MAX_BUFS 32      /* hardware table limit */
 #define INPUT_DMA_BUFS 8
 #define INPUT_DMA_SIZE (128*47*21)
+#define INPUT_DMA_IRQ_DIV 1
 
-#define OUTPUT_DMA_MAX_BUFS 32
 #define OUTPUT_DMA_BUFS 8
 #define OUTPUT_DMA_SIZE (128*47*21)
+#define OUTPUT_DMA_IRQ_DIV 1
 
 struct ddb;
 struct ddb_port;
 
-struct ddb_input {
-	struct ddb_port       *port;
+struct ddb_dma {
+	void                  *io;
 	u32                    nr;
-	int                    attached;
-
-	dma_addr_t             pbuf[INPUT_DMA_MAX_BUFS];
-	u8                    *vbuf[INPUT_DMA_MAX_BUFS];
-	u32                    dma_buf_num;
-	u32                    dma_buf_size;
+	dma_addr_t             pbuf[DMA_MAX_BUFS];
+	u8                    *vbuf[DMA_MAX_BUFS];
+	u32                    num;
+	u32                    size;
+	u32                    div;
+	u32                    bufreg;
 
+#ifdef DDB_USE_WORK
+	struct work_struct     work;
+#else
 	struct tasklet_struct  tasklet;
+#endif
 	spinlock_t             lock;
 	wait_queue_head_t      wq;
 	int                    running;
 	u32                    stat;
+	u32                    ctrl;
 	u32                    cbuf;
 	u32                    coff;
+};
 
-	struct dvb_adapter     adap;
+struct ddb_dvb {
+	struct dvb_adapter    *adap;
+	int                    adap_registered;
 	struct dvb_device     *dev;
+	struct i2c_client     *i2c_client[1];
 	struct dvb_frontend   *fe;
 	struct dvb_frontend   *fe2;
 	struct dmxdev          dmxdev;
 	struct dvb_demux       demux;
 	struct dvb_net         dvbnet;
+	struct dvb_netstream   dvbns;
 	struct dmx_frontend    hw_frontend;
 	struct dmx_frontend    mem_frontend;
 	int                    users;
-	int (*gate_ctrl)(struct dvb_frontend *, int);
+	u32                    attached;
+	u8                     input;
+
+	enum fe_sec_tone_mode  tone;
+	enum fe_sec_voltage    voltage;
+
+	int (*i2c_gate_ctrl)(struct dvb_frontend *, int);
+	int (*set_voltage)(struct dvb_frontend *fe,
+		enum fe_sec_voltage voltage);
+	int (*set_input)(struct dvb_frontend *fe, int input);
+	int (*diseqc_send_master_cmd)(struct dvb_frontend *fe,
+		struct dvb_diseqc_master_cmd *cmd);
 };
 
-struct ddb_output {
+struct ddb_ci {
+	struct dvb_ca_en50221  en;
 	struct ddb_port       *port;
 	u32                    nr;
-	dma_addr_t             pbuf[OUTPUT_DMA_MAX_BUFS];
-	u8                    *vbuf[OUTPUT_DMA_MAX_BUFS];
-	u32                    dma_buf_num;
-	u32                    dma_buf_size;
-	struct tasklet_struct  tasklet;
-	spinlock_t             lock;
-	wait_queue_head_t      wq;
-	int                    running;
-	u32                    stat;
-	u32                    cbuf;
-	u32                    coff;
+	struct mutex           lock;
+};
 
-	struct dvb_adapter     adap;
-	struct dvb_device     *dev;
+struct ddb_io {
+	struct ddb_port       *port;
+	u32                    nr;
+	struct ddb_dma        *dma;
+	struct ddb_io         *redo;
+	struct ddb_io         *redi;
 };
 
+#define ddb_output ddb_io
+#define ddb_input ddb_io
+
 struct ddb_i2c {
 	struct ddb            *dev;
 	u32                    nr;
-	struct i2c_adapter     adap;
-	struct i2c_adapter     adap2;
 	u32                    regs;
+	u32                    link;
+	struct i2c_adapter     adap;
 	u32                    rbuf;
 	u32                    wbuf;
-	int                    done;
-	wait_queue_head_t      wq;
+	u32                    bsize;
+	struct completion      completion;
 };
 
 struct ddb_port {
 	struct ddb            *dev;
 	u32                    nr;
+	u32                    pnr;
+	u32                    regs;
+	u32                    lnr;
 	struct ddb_i2c        *i2c;
 	struct mutex           i2c_gate_lock;
 	u32                    class;
 #define DDB_PORT_NONE           0
 #define DDB_PORT_CI             1
 #define DDB_PORT_TUNER          2
-	u32                    type;
-#define DDB_TUNER_NONE          0
-#define DDB_TUNER_DVBS_ST       1
-#define DDB_TUNER_DVBS_ST_AA    2
-#define DDB_TUNER_DVBCT_TR     16
-#define DDB_TUNER_DVBCT_ST     17
-	u32                    adr;
+#define DDB_PORT_LOOP           3
+#define DDB_PORT_MOD            4
+	char                   *name;
+	char                   *type_name;
+	u32                     type;
+#define DDB_TUNER_NONE           0
+#define DDB_TUNER_DVBS_ST        1
+#define DDB_TUNER_DVBS_ST_AA     2
+#define DDB_TUNER_DVBCT_TR       3
+#define DDB_TUNER_DVBCT_ST       4
+#define DDB_CI_INTERNAL          5
+#define DDB_CI_EXTERNAL_SONY     6
+#define DDB_TUNER_DVBCT2_SONY_P  7
+#define DDB_TUNER_DVBC2T2_SONY_P 8
+#define DDB_TUNER_ISDBT_SONY_P   9
+#define DDB_TUNER_DVBS_STV0910_P 10
+#define DDB_TUNER_MXL5XX         11
+#define DDB_CI_EXTERNAL_XO2      12
+#define DDB_CI_EXTERNAL_XO2_B    13
+#define DDB_TUNER_DVBS_STV0910_PR 14
+
+#define DDB_TUNER_XO2            32
+#define DDB_TUNER_DVBS_STV0910   (DDB_TUNER_XO2 + 0)
+#define DDB_TUNER_DVBCT2_SONY    (DDB_TUNER_XO2 + 1)
+#define DDB_TUNER_ISDBT_SONY     (DDB_TUNER_XO2 + 2)
+#define DDB_TUNER_DVBC2T2_SONY   (DDB_TUNER_XO2 + 3)
+#define DDB_TUNER_ATSC_ST        (DDB_TUNER_XO2 + 4)
+#define DDB_TUNER_DVBC2T2_ST     (DDB_TUNER_XO2 + 5)
 
 	struct ddb_input      *input[2];
 	struct ddb_output     *output;
 	struct dvb_ca_en50221 *en;
+	struct ddb_dvb         dvb[2];
+	u32                    gap;
+	u32                    obr;
+	u8                     creg;
+};
+
+struct mod_base {
+	u32                    frequency;
+	u32                    flat_start;
+	u32                    flat_end;
+};
+
+struct mod_state {
+	u32                    modulation;
+	u64                    obitrate;
+	u64                    ibitrate;
+	u32                    pcr_correction;
+
+	u32                    rate_inc;
+	u32                    Control;
+	u32                    State;
+	u32                    StateCounter;
+	s32                    LastPCRAdjust;
+	s32                    PCRAdjustSum;
+	s32                    InPacketsSum;
+	s32                    OutPacketsSum;
+	s64                    PCRIncrement;
+	s64                    PCRDecrement;
+	s32                    PCRRunningCorr;
+	u32                    OutOverflowPacketCount;
+	u32                    InOverflowPacketCount;
+	u32                    LastOutPacketCount;
+	u32                    LastInPacketCount;
+	u64                    LastOutPackets;
+	u64                    LastInPackets;
+	u32                    MinInputPackets;
+};
+
+#define CM_STARTUP_DELAY 2
+#define CM_AVERAGE  20
+#define CM_GAIN     10
+
+#define HW_LSB_SHIFT    12
+#define HW_LSB_MASK     0x1000
+
+#define CM_IDLE    0
+#define CM_STARTUP 1
+#define CM_ADJUST  2
+
+#define TS_CAPTURE_LEN  (4096)
+
+/* net streaming hardware block */
+
+#define DDB_NS_MAX 15
+
+struct ddb_ns {
+	struct ddb_input      *input;
+	int                    nr;
+	struct ddb_input      *fe;
+	u32                    rtcp_udplen;
+	u32                    rtcp_len;
+	u32                    ts_offset;
+	u32                    udplen;
+	u8                     p[512];
+};
+
+struct ddb_lnb {
+	struct mutex           lock;
+	u32                    tone;
+	enum fe_sec_voltage    oldvoltage[4];
+	u32                    voltage[4];
+	u32                    voltages;
+	u32                    fmode;
+};
+
+struct ddb_link {
+	struct ddb            *dev;
+	struct ddb_info       *info;
+	u32                    nr;
+	u32                    regs;
+	spinlock_t             lock;
+	struct mutex           flash_mutex;
+	struct ddb_lnb         lnb;
+	struct tasklet_struct  tasklet;
+	struct ddb_ids         ids;
 };
 
 struct ddb {
 	struct pci_dev        *pdev;
-	unsigned char __iomem *regs;
+	struct platform_device *pfdev;
+	struct device         *dev;
+
+	int                    msi;
+	struct workqueue_struct *wq;
+	u32                    has_dma;
+	u32                    has_ns;
+	struct ddb_link        link[DDB_MAX_LINK];
+	unsigned char         *regs;
+	u32                    regs_len;
+	u32                    port_num;
 	struct ddb_port        port[DDB_MAX_PORT];
+	u32                    i2c_num;
 	struct ddb_i2c         i2c[DDB_MAX_I2C];
 	struct ddb_input       input[DDB_MAX_INPUT];
 	struct ddb_output      output[DDB_MAX_OUTPUT];
+	struct dvb_adapter     adap[DDB_MAX_INPUT];
+	struct ddb_dma         dma[DDB_MAX_INPUT + DDB_MAX_OUTPUT];
+
+	void                   (*handler[128])(unsigned long);
+	unsigned long          handler_data[128];
 
 	struct device         *ddb_dev;
-	int                    nr;
+	u32                    ddb_dev_users;
+	u32                    nr;
 	u8                     iobuf[1028];
 
-	struct ddb_info       *info;
-	int                    msi;
+	u8                     leds;
+	u32                    ts_irq;
+	u32                    i2c_irq;
+	int                    ns_num;
+
+	struct ddb_ns          ns[DDB_NS_MAX];
+	int                    vlan;
+	struct mutex           mutex;
+
+	struct dvb_device     *nsd_dev;
+	u8                     tsbuf[TS_CAPTURE_LEN];
+
+	struct mod_base        mod_base;
+	struct mod_state       mod[10];
 };
 
-/****************************************************************************/
+static inline void ddbwriteb(struct ddb *dev, u32 val, u32 adr)
+{
+	writeb(val, (char *) (dev->regs + (adr)));
+}
+
+static inline u32 ddbreadb(struct ddb *dev, u32 adr)
+{
+	return readb((char *) (dev->regs + (adr)));
+}
+
+static inline void ddbwritel0(struct ddb_link *link, u32 val, u32 adr)
+{
+	writel(val, (char *) (link->dev->regs + (adr)));
+}
+
+static inline u32 ddbreadl0(struct ddb_link *link, u32 adr)
+{
+	return readl((char *) (link->dev->regs + (adr)));
+}
+
+static inline void gtlw(struct ddb_link *link)
+{
+	while (1 & ddbreadl0(link, link->regs + 0x10))
+		;
+}
+
+static u32 ddbreadl(struct ddb *dev, u32 adr)
+{
+	if (unlikely(adr & 0xf0000000)) {
+		unsigned long flags;
+		u32 val, l = (adr >> DDB_LINK_SHIFT);
+		struct ddb_link *link = &dev->link[l];
+
+		spin_lock_irqsave(&link->lock, flags);
+		gtlw(link);
+		ddbwritel0(link, adr & 0xfffc, link->regs + 0x14);
+		ddbwritel0(link, 3, link->regs + 0x10);
+		gtlw(link);
+		val = ddbreadl0(link, link->regs + 0x1c);
+		spin_unlock_irqrestore(&link->lock, flags);
+		return val;
+	}
+	return readl((char *) (dev->regs + (adr)));
+}
+
+static void ddbwritel(struct ddb *dev, u32 val, u32 adr)
+{
+	if (unlikely(adr & 0xf0000000)) {
+		unsigned long flags;
+		u32 l = (adr >> DDB_LINK_SHIFT);
+		struct ddb_link *link = &dev->link[l];
 
-#define ddbwritel(_val, _adr)        writel((_val), \
-				     dev->regs+(_adr))
-#define ddbreadl(_adr)               readl(dev->regs+(_adr))
-#define ddbcpyto(_adr, _src, _count) memcpy_toio(dev->regs+(_adr), (_src), (_count))
-#define ddbcpyfrom(_dst, _adr, _count) memcpy_fromio((_dst), dev->regs+(_adr), (_count))
+		spin_lock_irqsave(&link->lock, flags);
+		gtlw(link);
+		ddbwritel0(link, 0xf0000 | (adr & 0xfffc), link->regs + 0x14);
+		ddbwritel0(link, val, link->regs + 0x18);
+		ddbwritel0(link, 1, link->regs + 0x10);
+		spin_unlock_irqrestore(&link->lock, flags);
+		return;
+	}
+	writel(val, (char *) (dev->regs + (adr)));
+}
 
+static void gtlcpyto(struct ddb *dev, u32 adr, const u8 *buf,
+		     unsigned int count)
+{
+	u32 val = 0, p = adr;
+	u32 aa = p & 3;
+
+	if (aa) {
+		while (p & 3 && count) {
+			val >>= 8;
+			val |= *buf << 24;
+			p++;
+			buf++;
+			count--;
+		}
+		ddbwritel(dev, val, adr);
+	}
+	while (count >= 4) {
+		val = buf[0] | (buf[1] << 8) | (buf[2] << 16) | (buf[3] << 24);
+		ddbwritel(dev, val, p);
+		p += 4;
+		buf += 4;
+		count -= 4;
+	}
+	if (count) {
+		val = buf[0];
+		if (count > 1)
+			val |= buf[1] << 8;
+		if (count > 2)
+			val |= buf[2] << 16;
+		ddbwritel(dev, val, p);
+	}
+}
+
+static void gtlcpyfrom(struct ddb *dev, u8 *buf, u32 adr, long count)
+{
+	u32 val = 0, p = adr;
+	u32 a = p & 3;
+
+	if (a) {
+		val = ddbreadl(dev, p) >> (8 * a);
+		while (p & 3 && count) {
+			*buf = val & 0xff;
+			val >>= 8;
+			p++;
+			buf++;
+			count--;
+		}
+	}
+	while (count >= 4) {
+		val = ddbreadl(dev, p);
+		buf[0] = val & 0xff;
+		buf[1] = (val >> 8) & 0xff;
+		buf[2] = (val >> 16) & 0xff;
+		buf[3] = (val >> 24) & 0xff;
+		p += 4;
+		buf += 4;
+		count -= 4;
+	}
+	if (count) {
+		val = ddbreadl(dev, p);
+		buf[0] = val & 0xff;
+		if (count > 1)
+			buf[1] = (val >> 8) & 0xff;
+		if (count > 2)
+			buf[2] = (val >> 16) & 0xff;
+	}
+}
+
+static void ddbcpyto(struct ddb *dev, u32 adr, void *src, long count)
+{
+	if (unlikely(adr & 0xf0000000))
+		return gtlcpyto(dev, adr, src, count);
+	return memcpy_toio((char *) (dev->regs + adr), src, count);
+}
+
+static void ddbcpyfrom(struct ddb *dev, void *dst, u32 adr, long count)
+{
+	if (unlikely(adr & 0xf0000000))
+		return gtlcpyfrom(dev, dst, adr, count);
+	return memcpy_fromio(dst, (char *) (dev->regs + adr), count);
+}
+
+#define ddbmemset(_dev, _adr, _val, _count) \
+	memset_io((char *) (_dev->regs + (_adr)), (_val), (_count))
+
+
+/****************************************************************************/
 /****************************************************************************/
+/****************************************************************************/
+
+#define dd_uint8    u8
+#define dd_uint16   u16
+#define dd_int16    s16
+#define dd_uint32   u32
+#define dd_int32    s32
+#define dd_uint64   u64
+#define dd_int64    s64
+
+#define DDMOD_FLASH_START  0x1000
+
+struct DDMOD_FLASH_DS {
+	dd_uint32   Symbolrate;             /* kSymbols/s */
+	dd_uint32   DACFrequency;           /* kHz        */
+	dd_uint16   FrequencyResolution;    /* kHz        */
+	dd_uint16   IQTableLength;
+	dd_uint16   FrequencyFactor;
+	dd_int16    PhaseCorr;              /* TBD        */
+	dd_uint32   Control2;
+	dd_uint16   PostScaleI;
+	dd_uint16   PostScaleQ;
+	dd_uint16   PreScale;
+	dd_int16    EQTap[11];
+	dd_uint16   FlatStart;
+	dd_uint16   FlatEnd;
+	dd_uint32   FlashOffsetPrecalculatedIQTables;       /* 0 = none */
+	dd_uint8    Reserved[28];
+
+};
+
+struct DDMOD_FLASH {
+	dd_uint32   Magic;
+	dd_uint16   Version;
+	dd_uint16   DataSets;
+
+	dd_uint16   VCORefFrequency;    /* MHz */
+	dd_uint16   VCO1Frequency;      /* MHz */
+	dd_uint16   VCO2Frequency;      /* MHz */
+
+	dd_uint16   DACAux1;    /* TBD */
+	dd_uint16   DACAux2;    /* TBD */
+
+	dd_uint8    Reserved1[238];
+
+	struct DDMOD_FLASH_DS DataSet[1];
+};
+
+#define DDMOD_FLASH_MAGIC   0x5F564d5F
+
+
+int ddbridge_mod_do_ioctl(struct file *file, unsigned int cmd, void *parg);
+int ddbridge_mod_init(struct ddb *dev);
+void ddbridge_mod_output_stop(struct ddb_output *output);
+void ddbridge_mod_output_start(struct ddb_output *output);
+void ddbridge_mod_rate_handler(unsigned long data);
+
+
+int ddbridge_flashread(struct ddb *dev, u32 link, u8 *buf, u32 addr, u32 len);
+
+#define DDBRIDGE_VERSION "0.9.23"
 
 #endif
diff --git a/drivers/media/pci/ddbridge/octonet.c b/drivers/media/pci/ddbridge/octonet.c
new file mode 100644
index 0000000..3546f96
--- /dev/null
+++ b/drivers/media/pci/ddbridge/octonet.c
@@ -0,0 +1,262 @@
+/*
+ * octonet.c: Digital Devices network tuner driver
+ *
+ * Copyright (C) 2012-15 Digital Devices GmbH
+ *                       Marcus Metzler <mocm@metzlerbros.de>
+ *                       Ralph Metzler <rjkm@metzlerbros.de>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 only, as published by the Free Software Foundation.
+ *
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA
+ * Or, point your browser to http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include "ddbridge.h"
+#include "ddbridge-regs.h"
+
+static int adapter_alloc = 3;
+module_param(adapter_alloc, int, 0444);
+MODULE_PARM_DESC(adapter_alloc,
+"0-one adapter per io, 1-one per tab with io, 2-one per tab, 3-one for all");
+
+#include "ddbridge-core.c"
+
+static struct ddb_regset octopus_i2c = {
+	.base = 0x80,
+	.num  = 0x04,
+	.size = 0x20,
+};
+
+static struct ddb_regset octopus_i2c_buf = {
+	.base = 0x1000,
+	.num  = 0x04,
+	.size = 0x200,
+};
+
+static struct ddb_regmap octopus_net_map = {
+	.i2c = &octopus_i2c,
+	.i2c_buf = &octopus_i2c_buf,
+};
+
+static struct ddb_regset octopus_gtl = {
+	.base = 0x180,
+	.num  = 0x01,
+	.size = 0x20,
+};
+
+static struct ddb_regmap octopus_net_gtl = {
+	.i2c = &octopus_i2c,
+	.i2c_buf = &octopus_i2c_buf,
+	.gtl = &octopus_gtl,
+};
+
+static struct ddb_info ddb_octonet = {
+	.type     = DDB_OCTONET,
+	.name     = "Digital Devices OctopusNet network DVB adapter",
+	.regmap   = &octopus_net_map,
+	.port_num = 4,
+	.i2c_mask = 0x0f,
+	.ns_num   = 12,
+	.mdio_num = 1,
+};
+
+static struct ddb_info ddb_octonet_jse = {
+	.type     = DDB_OCTONET,
+	.name     = "Digital Devices OctopusNet network DVB adapter JSE",
+	.regmap   = &octopus_net_map,
+	.port_num = 4,
+	.i2c_mask = 0x0f,
+	.ns_num   = 15,
+	.mdio_num = 1,
+};
+
+static struct ddb_info ddb_octonet_gtl = {
+	.type     = DDB_OCTONET,
+	.name     = "Digital Devices OctopusNet GTL",
+	.regmap   = &octopus_net_gtl,
+	.port_num = 4,
+	.i2c_mask = 0x05,
+	.ns_num   = 12,
+	.mdio_num = 1,
+	.con_clock = 1,
+};
+
+static struct ddb_info ddb_octonet_tbd = {
+	.type     = DDB_OCTONET,
+	.name     = "Digital Devices OctopusNet",
+	.regmap   = &octopus_net_map,
+};
+
+static void octonet_unmap(struct ddb *dev)
+{
+	if (dev->regs)
+		iounmap(dev->regs);
+	vfree(dev);
+}
+
+static int octonet_remove(struct platform_device *pdev)
+{
+	struct ddb *dev;
+
+	dev = platform_get_drvdata(pdev);
+
+	ddb_device_destroy(dev);
+	ddb_nsd_detach(dev);
+	ddb_ports_detach(dev);
+	ddb_i2c_release(dev);
+
+	if (dev->link[0].info->ns_num)
+		ddbwritel(dev, 0, ETHER_CONTROL);
+	ddbwritel(dev, 0, INTERRUPT_ENABLE);
+
+	free_irq(platform_get_irq(dev->pfdev, 0), dev);
+	ddb_ports_release(dev);
+	octonet_unmap(dev);
+	platform_set_drvdata(pdev, 0);
+	return 0;
+}
+
+static int octonet_probe(struct platform_device *pdev)
+{
+	struct ddb *dev;
+	struct resource *regs;
+	int irq;
+	int i;
+
+	dev = vzalloc(sizeof(struct ddb));
+	if (!dev)
+		return -ENOMEM;
+	platform_set_drvdata(pdev, dev);
+	dev->dev = &pdev->dev;
+	dev->pfdev = pdev;
+
+	mutex_init(&dev->mutex);
+	regs = platform_get_resource(dev->pfdev, IORESOURCE_MEM, 0);
+	if (!regs)
+		return -ENXIO;
+	dev->regs_len = (regs->end - regs->start) + 1;
+	dev_info(dev->dev, "regs_start=%08x regs_len=%08x\n",
+		 (u32) regs->start, (u32) dev->regs_len);
+	dev->regs = ioremap(regs->start, dev->regs_len);
+
+	if (!dev->regs) {
+		dev_err(dev->dev, "ioremap failed\n");
+		return -ENOMEM;
+	}
+
+	dev->link[0].ids.hwid = ddbreadl(dev, 0);
+	dev->link[0].ids.regmapid = ddbreadl(dev, 4);
+	dev->link[0].ids.devid = ddbreadl(dev, 8);
+	dev->link[0].ids.mac = ddbreadl(dev, 12);
+
+	dev->link[0].ids.vendor = dev->link[0].ids.devid & 0xffff;
+	dev->link[0].ids.device = dev->link[0].ids.devid >> 16;
+	dev->link[0].ids.subvendor = dev->link[0].ids.devid & 0xffff;
+	dev->link[0].ids.subdevice = dev->link[0].ids.devid >> 16;
+
+	dev->link[0].dev = dev;
+	if (dev->link[0].ids.devid == 0x0300dd01)
+		dev->link[0].info = &ddb_octonet;
+	else if (dev->link[0].ids.devid == 0x0301dd01)
+		dev->link[0].info = &ddb_octonet_jse;
+	else if (dev->link[0].ids.devid == 0x0307dd01)
+		dev->link[0].info = &ddb_octonet_gtl;
+	else
+		dev->link[0].info = &ddb_octonet_tbd;
+
+	pr_info("HW  %08x REGMAP %08x\n", dev->link[0].ids.hwid,
+		dev->link[0].ids.regmapid);
+	pr_info("MAC %08x DEVID  %08x\n", dev->link[0].ids.mac,
+		dev->link[0].ids.devid);
+
+	ddbwritel(dev, 0, ETHER_CONTROL);
+	ddbwritel(dev, 0x00000000, INTERRUPT_ENABLE);
+	ddbwritel(dev, 0xffffffff, INTERRUPT_STATUS);
+	for (i = 0; i < 16; i++)
+		ddbwritel(dev, 0x00, TS_OUTPUT_CONTROL(i));
+	usleep_range(5000, 6000);
+
+	irq = platform_get_irq(dev->pfdev, 0);
+	if (irq < 0)
+		goto fail;
+	if (request_irq(irq, irq_handler,
+			IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,
+			"octonet-dvb", (void *) dev) < 0)
+		goto fail;
+	ddbwritel(dev, 0x0fffff0f, INTERRUPT_ENABLE);
+
+	if (ddb_init(dev) == 0)
+		return 0;
+
+fail:
+	dev_err(dev->dev, "fail\n");
+	ddbwritel(dev, 0, ETHER_CONTROL);
+	ddbwritel(dev, 0, INTERRUPT_ENABLE);
+	octonet_unmap(dev);
+	platform_set_drvdata(pdev, 0);
+	return -1;
+}
+
+#ifdef CONFIG_OF
+static const struct of_device_id octonet_dt_ids[] = {
+	{ .compatible = "digitaldevices,octonet-dvb" },
+	{ /* sentinel */ }
+};
+
+MODULE_DEVICE_TABLE(of, octonet_dt_ids);
+#endif
+
+static struct platform_driver octonet_driver = {
+	.remove	= __exit_p(octonet_remove),
+	.probe	= octonet_probe,
+	.driver		= {
+		.name	= "octonet-dvb",
+		.owner	= THIS_MODULE,
+#ifdef CONFIG_OF
+		.of_match_table = of_match_ptr(octonet_dt_ids),
+#endif
+	},
+};
+
+static int init_octonet(void)
+{
+	int res;
+
+	pr_info("Digital Devices OctopusNet driver " DDBRIDGE_VERSION
+		", Copyright (C) 2010-15 Digital Devices GmbH\n");
+	res = ddb_class_create();
+	if (res)
+		return res;
+	res = platform_driver_probe(&octonet_driver, octonet_probe);
+	if (res) {
+		ddb_class_destroy();
+		return res;
+	}
+	return 0;
+}
+
+static void exit_octonet(void)
+{
+	platform_driver_unregister(&octonet_driver);
+	ddb_class_destroy();
+}
+
+module_init(init_octonet);
+module_exit(exit_octonet);
+
+MODULE_DESCRIPTION("GPL");
+MODULE_AUTHOR("Marcus and Ralph Metzler, Metzler Brothers Systementwicklung GbR");
+MODULE_LICENSE("GPL");
+MODULE_VERSION("0.6");
diff --git a/drivers/media/platform/sti/c8sectpfe/c8sectpfe-dvb.c b/drivers/media/platform/sti/c8sectpfe/c8sectpfe-dvb.c
index 2c0015b..03688ee 100644
--- a/drivers/media/platform/sti/c8sectpfe/c8sectpfe-dvb.c
+++ b/drivers/media/platform/sti/c8sectpfe/c8sectpfe-dvb.c
@@ -111,6 +111,7 @@ static struct tda18212_config tda18212_conf = {
 	.if_dvbt_7 = 4150,
 	.if_dvbt_8 = 4500,
 	.if_dvbc = 5000,
+	.init_flags = 0,
 };
 
 int c8sectpfe_frontend_attach(struct dvb_frontend **fe,
diff --git a/drivers/media/tuners/tda18212.c b/drivers/media/tuners/tda18212.c
index 7b80683..2488537 100644
--- a/drivers/media/tuners/tda18212.c
+++ b/drivers/media/tuners/tda18212.c
@@ -220,6 +220,11 @@ static int tda18212_probe(struct i2c_client *client,
 		fe->ops.i2c_gate_ctrl(fe, 1); /* open I2C-gate */
 
 	ret = regmap_read(dev->regmap, 0x00, &chip_id);
+
+	/* retry probe if desired */
+	if (ret && (cfg->init_flags & TDA18212_INIT_RETRY))
+		ret = regmap_read(dev->regmap, 0x00, &chip_id);
+
 	dev_dbg(&dev->client->dev, "chip_id=%02x\n", chip_id);
 
 	if (fe->ops.i2c_gate_ctrl)
diff --git a/drivers/media/tuners/tda18212.h b/drivers/media/tuners/tda18212.h
index e58c909..457ae72 100644
--- a/drivers/media/tuners/tda18212.h
+++ b/drivers/media/tuners/tda18212.h
@@ -24,6 +24,8 @@
 #include <linux/kconfig.h>
 #include "dvb_frontend.h"
 
+#define TDA18212_INIT_RETRY	(1 << 0)
+
 struct tda18212_config {
 	u16 if_dvbt_6;
 	u16 if_dvbt_7;
@@ -37,6 +39,11 @@ struct tda18212_config {
 	u16 if_atsc_qam;
 
 	/*
+	 * flags for tuner init control
+	 */
+	u32 init_flags;
+
+	/*
 	 * pointer to DVB frontend
 	 */
 	struct dvb_frontend *fe;
diff --git a/drivers/media/usb/dvb-usb-v2/anysee.c b/drivers/media/usb/dvb-usb-v2/anysee.c
index ae917c0..02d22eb 100644
--- a/drivers/media/usb/dvb-usb-v2/anysee.c
+++ b/drivers/media/usb/dvb-usb-v2/anysee.c
@@ -336,6 +336,7 @@ static struct tda18212_config anysee_tda18212_config = {
 	.if_dvbt_7 = 4150,
 	.if_dvbt_8 = 4150,
 	.if_dvbc = 5000,
+	.init_flags = 0,
 };
 
 static struct tda18212_config anysee_tda18212_config2 = {
@@ -346,6 +347,7 @@ static struct tda18212_config anysee_tda18212_config2 = {
 	.if_dvbt2_7 = 4000,
 	.if_dvbt2_8 = 4000,
 	.if_dvbc = 5000,
+	.init_flags = 0,
 };
 
 static struct cx24116_config anysee_cx24116_config = {
diff --git a/drivers/media/usb/em28xx/em28xx-dvb.c b/drivers/media/usb/em28xx/em28xx-dvb.c
index 8cedef0..7bc7778 100644
--- a/drivers/media/usb/em28xx/em28xx-dvb.c
+++ b/drivers/media/usb/em28xx/em28xx-dvb.c
@@ -376,6 +376,7 @@ static struct tda18271_config kworld_ub435q_v2_config = {
 static struct tda18212_config kworld_ub435q_v3_config = {
 	.if_atsc_vsb	= 3600,
 	.if_atsc_qam	= 3600,
+	.init_flags	= 0,
 };
 
 static struct zl10353_config em28xx_zl10353_xc3028_no_i2c_gate = {
diff --git a/drivers/staging/media/cxd2099/cxd2099.c b/drivers/staging/media/cxd2099/cxd2099.c
index 692ba3e..a965edc 100644
--- a/drivers/staging/media/cxd2099/cxd2099.c
+++ b/drivers/staging/media/cxd2099/cxd2099.c
@@ -1,7 +1,7 @@
 /*
  * cxd2099.c: Driver for the CXD2099AR Common Interface Controller
  *
- * Copyright (C) 2010-2011 Digital Devices GmbH
+ * Copyright (C) 2010-2013 Digital Devices GmbH
  *
  *
  * This program is free software; you can redistribute it and/or
@@ -22,6 +22,7 @@
  * Or, point your browser to http://www.gnu.org/copyleft/gpl.html
  */
 
+#include <linux/version.h>
 #include <linux/slab.h>
 #include <linux/kernel.h>
 #include <linux/module.h>
@@ -33,7 +34,9 @@
 
 #include "cxd2099.h"
 
-#define MAX_BUFFER_SIZE 248
+/* #define BUFFER_MODE 1 */
+
+static int read_data(struct dvb_ca_en50221 *ca, int slot, u8 *ebuf, int ecount);
 
 struct cxd {
 	struct dvb_ca_en50221 en;
@@ -48,6 +51,7 @@ struct cxd {
 	int    mode;
 	int    ready;
 	int    dr;
+	int    write_busy;
 	int    slot_stat;
 
 	u8     amem[1024];
@@ -55,6 +59,9 @@ struct cxd {
 
 	int    cammode;
 	struct mutex lock;
+
+	u8     rbuf[1028];
+	u8     wbuf[1028];
 };
 
 static int i2c_write_reg(struct i2c_adapter *adapter, u8 adr,
@@ -73,7 +80,7 @@ static int i2c_write_reg(struct i2c_adapter *adapter, u8 adr,
 }
 
 static int i2c_write(struct i2c_adapter *adapter, u8 adr,
-		     u8 *data, u8 len)
+		     u8 *data, u16 len)
 {
 	struct i2c_msg msg = {.addr = adr, .flags = 0, .buf = data, .len = len};
 
@@ -100,7 +107,7 @@ static int i2c_read_reg(struct i2c_adapter *adapter, u8 adr,
 }
 
 static int i2c_read(struct i2c_adapter *adapter, u8 adr,
-		    u8 reg, u8 *data, u8 n)
+		    u8 reg, u8 *data, u16 n)
 {
 	struct i2c_msg msgs[2] = {{.addr = adr, .flags = 0,
 				 .buf = &reg, .len = 1},
@@ -114,14 +121,27 @@ static int i2c_read(struct i2c_adapter *adapter, u8 adr,
 	return 0;
 }
 
-static int read_block(struct cxd *ci, u8 adr, u8 *data, u8 n)
+static int read_block(struct cxd *ci, u8 adr, u8 *data, u16 n)
 {
-	int status;
+	int status = 0;
 
-	status = i2c_write_reg(ci->i2c, ci->cfg.adr, 0, adr);
+	if (ci->lastaddress != adr)
+		status = i2c_write_reg(ci->i2c, ci->cfg.adr, 0, adr);
 	if (!status) {
 		ci->lastaddress = adr;
-		status = i2c_read(ci->i2c, ci->cfg.adr, 1, data, n);
+
+		while (n) {
+			int len = n;
+
+			if (ci->cfg.max_i2c &&
+			    len > ci->cfg.max_i2c)
+				len = ci->cfg.max_i2c;
+			status = i2c_read(ci->i2c, ci->cfg.adr, 1, data, len);
+			if (status)
+				return status;
+			data += len;
+			n -= len;
+		}
 	}
 	return status;
 }
@@ -181,46 +201,18 @@ static int write_io(struct cxd *ci, u16 address, u8 val)
 	return status;
 }
 
-#if 0
-static int read_io_data(struct cxd *ci, u8 *data, u8 n)
-{
-	int status;
-	u8 addr[3] = { 2, 0, 0 };
-
-	status = i2c_write(ci->i2c, ci->cfg.adr, addr, 3);
-	if (!status)
-		status = i2c_read(ci->i2c, ci->cfg.adr, 3, data, n);
-	return 0;
-}
-
-static int write_io_data(struct cxd *ci, u8 *data, u8 n)
-{
-	int status;
-	u8 addr[3] = {2, 0, 0};
-
-	status = i2c_write(ci->i2c, ci->cfg.adr, addr, 3);
-	if (!status) {
-		u8 buf[256] = {3};
-
-		memcpy(buf+1, data, n);
-		status = i2c_write(ci->i2c, ci->cfg.adr, buf, n + 1);
-	}
-	return 0;
-}
-#endif
-
 static int write_regm(struct cxd *ci, u8 reg, u8 val, u8 mask)
 {
-	int status;
+	int status = 0;
 
-	status = i2c_write_reg(ci->i2c, ci->cfg.adr, 0, reg);
+	if (ci->lastaddress != reg)
+		status = i2c_write_reg(ci->i2c, ci->cfg.adr, 0, reg);
 	if (!status && reg >= 6 && reg <= 8 && mask != 0xff)
 		status = i2c_read_reg(ci->i2c, ci->cfg.adr, 1, &ci->regs[reg]);
+	ci->lastaddress = reg;
 	ci->regs[reg] = (ci->regs[reg] & (~mask)) | val;
-	if (!status) {
-		ci->lastaddress = reg;
+	if (!status)
 		status = i2c_write_reg(ci->i2c, ci->cfg.adr, 1, ci->regs[reg]);
-	}
 	if (reg == 0x20)
 		ci->regs[reg] &= 0x7f;
 	return status;
@@ -232,16 +224,32 @@ static int write_reg(struct cxd *ci, u8 reg, u8 val)
 }
 
 #ifdef BUFFER_MODE
-static int write_block(struct cxd *ci, u8 adr, u8 *data, int n)
+static int write_block(struct cxd *ci, u8 adr, u8 *data, u16 n)
 {
-	int status;
-	u8 buf[256] = {1};
-
-	status = i2c_write_reg(ci->i2c, ci->cfg.adr, 0, adr);
-	if (!status) {
-		ci->lastaddress = adr;
-		memcpy(buf + 1, data, n);
-		status = i2c_write(ci->i2c, ci->cfg.adr, buf, n + 1);
+	int status = 0;
+	u8 *buf = ci->wbuf;
+
+	if (ci->lastaddress != adr)
+		status = i2c_write_reg(ci->i2c, ci->cfg.adr, 0, adr);
+	if (status)
+		return status;
+	dev_info(&ci->i2c->dev, "write_block %d\n", n);
+
+	ci->lastaddress = adr;
+	buf[0] = 1;
+	while (n) {
+		int len = n;
+
+		if (ci->cfg.max_i2c &&
+		    len + 1 > ci->cfg.max_i2c)
+			len = ci->cfg.max_i2c - 1;
+		dev_info(&ci->i2c->dev, "write %d\n", len);
+		memcpy(buf + 1, data, len);
+		status = i2c_write(ci->i2c, ci->cfg.adr, buf, len + 1);
+		if (status)
+			return status;
+		n -= len;
+		data += len;
 	}
 	return status;
 }
@@ -267,6 +275,8 @@ static void set_mode(struct cxd *ci, int mode)
 
 static void cam_mode(struct cxd *ci, int mode)
 {
+	u8 dummy;
+
 	if (mode == ci->cammode)
 		return;
 
@@ -275,16 +285,15 @@ static void cam_mode(struct cxd *ci, int mode)
 		write_regm(ci, 0x20, 0x80, 0x80);
 		break;
 	case 0x01:
-#ifdef BUFFER_MODE
 		if (!ci->en.read_data)
 			return;
+		ci->write_busy = 0;
 		dev_info(&ci->i2c->dev, "enable cam buffer mode\n");
-		/* write_reg(ci, 0x0d, 0x00); */
-		/* write_reg(ci, 0x0e, 0x01); */
+		write_reg(ci, 0x0d, 0x00);
+		write_reg(ci, 0x0e, 0x01);
 		write_regm(ci, 0x08, 0x40, 0x40);
-		/* read_reg(ci, 0x12, &dummy); */
+		read_reg(ci, 0x12, &dummy);
 		write_regm(ci, 0x08, 0x80, 0x80);
-#endif
 		break;
 	default:
 		break;
@@ -292,8 +301,6 @@ static void cam_mode(struct cxd *ci, int mode)
 	ci->cammode = mode;
 }
 
-
-
 static int init(struct cxd *ci)
 {
 	int status;
@@ -329,12 +336,6 @@ static int init(struct cxd *ci)
 		if (status < 0)
 			break;
 
-#if 0
-		/* Input Mode C, BYPass Serial, TIVAL = low, MSB */
-		status = write_reg(ci, 0x09, 0x4D);
-		if (status < 0)
-			break;
-#endif
 		/* TOSTRT = 8, Mode B (gated clock), falling Edge,
 		 * Serial, POL=HIGH, MSB */
 		status = write_reg(ci, 0x0A, 0xA7);
@@ -361,7 +362,10 @@ static int init(struct cxd *ci)
 		if (status < 0)
 			break;
 
-		if (ci->cfg.clock_mode) {
+		if (ci->cfg.clock_mode == 2) {
+			/* bitrate*2^13/ 72000 */
+			u32 reg = ((ci->cfg.bitrate << 13) + 71999) / 72000;
+
 			if (ci->cfg.polarity) {
 				status = write_reg(ci, 0x09, 0x6f);
 				if (status < 0)
@@ -371,6 +375,25 @@ static int init(struct cxd *ci)
 				if (status < 0)
 					break;
 			}
+			status = write_reg(ci, 0x20, 0x08);
+			if (status < 0)
+				break;
+			status = write_reg(ci, 0x21, (reg >> 8) & 0xff);
+			if (status < 0)
+				break;
+			status = write_reg(ci, 0x22, reg & 0xff);
+			if (status < 0)
+				break;
+		} else if (ci->cfg.clock_mode == 1) {
+			if (ci->cfg.polarity) {
+				status = write_reg(ci, 0x09, 0x6f); /* D */
+				if (status < 0)
+					break;
+			} else {
+				status = write_reg(ci, 0x09, 0x6d);
+				if (status < 0)
+					break;
+			}
 			status = write_reg(ci, 0x20, 0x68);
 			if (status < 0)
 				break;
@@ -382,7 +405,7 @@ static int init(struct cxd *ci)
 				break;
 		} else {
 			if (ci->cfg.polarity) {
-				status = write_reg(ci, 0x09, 0x4f);
+				status = write_reg(ci, 0x09, 0x4f); /* C */
 				if (status < 0)
 					break;
 			} else {
@@ -390,7 +413,6 @@ static int init(struct cxd *ci)
 				if (status < 0)
 					break;
 			}
-
 			status = write_reg(ci, 0x20, 0x28);
 			if (status < 0)
 				break;
@@ -431,23 +453,6 @@ static int read_attribute_mem(struct dvb_ca_en50221 *ca,
 			      int slot, int address)
 {
 	struct cxd *ci = ca->data;
-#if 0
-	if (ci->amem_read) {
-		if (address <= 0 || address > 1024)
-			return -EIO;
-		return ci->amem[address];
-	}
-
-	mutex_lock(&ci->lock);
-	write_regm(ci, 0x06, 0x00, 0x05);
-	read_pccard(ci, 0, &ci->amem[0], 128);
-	read_pccard(ci, 128, &ci->amem[0], 128);
-	read_pccard(ci, 256, &ci->amem[0], 128);
-	read_pccard(ci, 384, &ci->amem[0], 128);
-	write_regm(ci, 0x06, 0x05, 0x05);
-	mutex_unlock(&ci->lock);
-	return ci->amem[address];
-#else
 	u8 val;
 
 	mutex_lock(&ci->lock);
@@ -456,7 +461,6 @@ static int read_attribute_mem(struct dvb_ca_en50221 *ca,
 	mutex_unlock(&ci->lock);
 	/* printk(KERN_INFO "%02x:%02x\n", address,val); */
 	return val;
-#endif
 }
 
 static int write_attribute_mem(struct dvb_ca_en50221 *ca, int slot,
@@ -500,16 +504,10 @@ static int slot_reset(struct dvb_ca_en50221 *ca, int slot)
 {
 	struct cxd *ci = ca->data;
 
+	if (ci->cammode)
+		read_data(ca, slot, ci->rbuf, 0);
+
 	mutex_lock(&ci->lock);
-#if 0
-	write_reg(ci, 0x00, 0x21);
-	write_reg(ci, 0x06, 0x1F);
-	write_reg(ci, 0x00, 0x31);
-#else
-#if 0
-	write_reg(ci, 0x06, 0x1F);
-	write_reg(ci, 0x06, 0x2F);
-#else
 	cam_mode(ci, 0);
 	write_reg(ci, 0x00, 0x21);
 	write_reg(ci, 0x06, 0x1F);
@@ -517,25 +515,14 @@ static int slot_reset(struct dvb_ca_en50221 *ca, int slot)
 	write_regm(ci, 0x20, 0x80, 0x80);
 	write_reg(ci, 0x03, 0x02);
 	ci->ready = 0;
-#endif
-#endif
 	ci->mode = -1;
 	{
 		int i;
-#if 0
-		u8 val;
-#endif
+
 		for (i = 0; i < 100; i++) {
 			usleep_range(10000, 11000);
-#if 0
-			read_reg(ci, 0x06, &val);
-			dev_info(&ci->i2c->dev, "%d:%02x\n", i, val);
-			if (!(val&0x10))
-				break;
-#else
 			if (ci->ready)
 				break;
-#endif
 		}
 	}
 	mutex_unlock(&ci->lock);
@@ -548,11 +535,19 @@ static int slot_shutdown(struct dvb_ca_en50221 *ca, int slot)
 	struct cxd *ci = ca->data;
 
 	dev_info(&ci->i2c->dev, "slot_shutdown\n");
+	if (ci->cammode)
+		read_data(ca, slot, ci->rbuf, 0);
 	mutex_lock(&ci->lock);
+	write_reg(ci, 0x00, 0x21);
+	write_reg(ci, 0x06, 0x1F);
+	msleep(300);
+
 	write_regm(ci, 0x09, 0x08, 0x08);
 	write_regm(ci, 0x20, 0x80, 0x80); /* Reset CAM Mode */
 	write_regm(ci, 0x06, 0x07, 0x07); /* Clear IO Mode */
+
 	ci->mode = -1;
+	ci->write_busy = 0;
 	mutex_unlock(&ci->lock);
 	return 0;
 }
@@ -564,9 +559,7 @@ static int slot_ts_enable(struct dvb_ca_en50221 *ca, int slot)
 	mutex_lock(&ci->lock);
 	write_regm(ci, 0x09, 0x00, 0x08);
 	set_mode(ci, 0);
-#ifdef BUFFER_MODE
 	cam_mode(ci, 1);
-#endif
 	mutex_unlock(&ci->lock);
 	return 0;
 }
@@ -585,8 +578,10 @@ static int campoll(struct cxd *ci)
 		ci->dr = 1;
 		dev_info(&ci->i2c->dev, "DR\n");
 	}
-	if (istat&0x20)
+	if (istat&0x20) {
+		ci->write_busy = 0;
 		dev_info(&ci->i2c->dev, "WC\n");
+	}
 
 	if (istat&2) {
 		u8 slotstat;
@@ -594,7 +589,7 @@ static int campoll(struct cxd *ci)
 		read_reg(ci, 0x01, &slotstat);
 		if (!(2&slotstat)) {
 			if (!ci->slot_stat) {
-				ci->slot_stat = DVB_CA_EN50221_POLL_CAM_PRESENT;
+				ci->slot_stat |= DVB_CA_EN50221_POLL_CAM_PRESENT;
 				write_regm(ci, 0x03, 0x08, 0x08);
 			}
 
@@ -606,8 +601,8 @@ static int campoll(struct cxd *ci)
 				ci->ready = 0;
 			}
 		}
-		if (istat&8 &&
-		    ci->slot_stat == DVB_CA_EN50221_POLL_CAM_PRESENT) {
+		if ((istat&8) &&
+		    (ci->slot_stat == DVB_CA_EN50221_POLL_CAM_PRESENT)) {
 			ci->ready = 1;
 			ci->slot_stat |= DVB_CA_EN50221_POLL_CAM_READY;
 		}
@@ -629,7 +624,6 @@ static int poll_slot_status(struct dvb_ca_en50221 *ca, int slot, int open)
 	return ci->slot_stat;
 }
 
-#ifdef BUFFER_MODE
 static int read_data(struct dvb_ca_en50221 *ca, int slot, u8 *ebuf, int ecount)
 {
 	struct cxd *ci = ca->data;
@@ -647,23 +641,33 @@ static int read_data(struct dvb_ca_en50221 *ca, int slot, u8 *ebuf, int ecount)
 	mutex_lock(&ci->lock);
 	read_reg(ci, 0x0f, &msb);
 	read_reg(ci, 0x10, &lsb);
-	len = (msb<<8)|lsb;
+	len = ((u16) msb << 8) | lsb;
+	if (len > ecount || len < 2) {
+		/* read it anyway or cxd may hang */
+		read_block(ci, 0x12, ci->rbuf, len);
+		mutex_unlock(&ci->lock);
+		return -EIO;
+	}
 	read_block(ci, 0x12, ebuf, len);
 	ci->dr = 0;
 	mutex_unlock(&ci->lock);
-
 	return len;
 }
 
+#ifdef BUFFER_MODE
+
 static int write_data(struct dvb_ca_en50221 *ca, int slot, u8 *ebuf, int ecount)
 {
 	struct cxd *ci = ca->data;
 
+	if (ci->write_busy)
+		return -EAGAIN;
 	mutex_lock(&ci->lock);
-	printk(kern_INFO "write_data %d\n", ecount);
+	dev_info(&ci->i2c->dev, "write_data %d\n", ecount);
 	write_reg(ci, 0x0d, ecount>>8);
 	write_reg(ci, 0x0e, ecount&0xff);
 	write_block(ci, 0x11, ebuf, ecount);
+	ci->write_busy = 1;
 	mutex_unlock(&ci->lock);
 	return ecount;
 }
diff --git a/drivers/staging/media/cxd2099/cxd2099.h b/drivers/staging/media/cxd2099/cxd2099.h
index 0eb607c..f4b29b1 100644
--- a/drivers/staging/media/cxd2099/cxd2099.h
+++ b/drivers/staging/media/cxd2099/cxd2099.h
@@ -30,8 +30,10 @@
 struct cxd2099_cfg {
 	u32 bitrate;
 	u8  adr;
-	u8  polarity:1;
-	u8  clock_mode:1;
+	u8  polarity;
+	u8  clock_mode;
+
+	u32 max_i2c;
 };
 
 #if defined(CONFIG_DVB_CXD2099) || \
diff --git a/include/uapi/linux/dvb/frontend.h b/include/uapi/linux/dvb/frontend.h
index 00a20cd..bf9d16b 100644
--- a/include/uapi/linux/dvb/frontend.h
+++ b/include/uapi/linux/dvb/frontend.h
@@ -156,6 +156,8 @@ enum fe_code_rate {
 	FEC_3_5,
 	FEC_9_10,
 	FEC_2_5,
+	FEC_1_4,
+	FEC_1_3,
 };
 
 enum fe_modulation {
@@ -307,7 +309,9 @@ enum fe_interleaving {
 #define DTV_STAT_ERROR_BLOCK_COUNT	68
 #define DTV_STAT_TOTAL_BLOCK_COUNT	69
 
-#define DTV_MAX_COMMAND		DTV_STAT_TOTAL_BLOCK_COUNT
+#define DTV_INPUT			70
+
+#define DTV_MAX_COMMAND			DTV_INPUT
 
 enum fe_pilot {
 	PILOT_ON,
@@ -342,6 +346,7 @@ enum fe_delivery_system {
 	SYS_DVBT2,
 	SYS_TURBO,
 	SYS_DVBC_ANNEX_C,
+	SYS_DVBC2,
 };
 
 /* backward compatibility */
diff --git a/include/uapi/linux/dvb/mod.h b/include/uapi/linux/dvb/mod.h
new file mode 100644
index 0000000..f595a2c
--- /dev/null
+++ b/include/uapi/linux/dvb/mod.h
@@ -0,0 +1,22 @@
+#ifndef _UAPI_DVBMOD_H_
+#define _UAPI_DVBMOD_H_
+
+#include <linux/types.h>
+#include "frontend.h"
+
+struct dvb_mod_params {
+	__u32 base_frequency;
+	__u32 attenuator;
+};
+
+struct dvb_mod_channel_params {
+	enum fe_modulation modulation;
+	__u64 input_bitrate;         /* 2^-32 Hz */
+	int   pcr_correction;
+};
+
+
+#define DVB_MOD_SET              _IOW('o', 208, struct dvb_mod_params)
+#define DVB_MOD_CHANNEL_SET      _IOW('o', 209, struct dvb_mod_channel_params)
+
+#endif /*_UAPI_DVBMOD_H_*/
diff --git a/include/uapi/linux/dvb/ns.h b/include/uapi/linux/dvb/ns.h
new file mode 100644
index 0000000..4cfd9f0
--- /dev/null
+++ b/include/uapi/linux/dvb/ns.h
@@ -0,0 +1,69 @@
+#ifndef _UAPI_DVBNS_H_
+#define _UAPI_DVBNS_H_
+
+#include <linux/types.h>
+
+struct dvb_ns_params {
+	__u8     smac[6];
+	__u8     dmac[6];
+	__u8     sip[16];
+	__u8     dip[16];
+	__u16    sport;
+	__u16    dport;
+	__u16    sport2;
+	__u16    dport2;
+	__u8     ssrc[8];
+	__u8     flags;
+	__u8     qos;
+	__u16    vlan;
+	__u8     ttl;
+};
+
+#define DVB_NS_IPV6    0x01
+#define DVB_NS_RTP     0x02
+#define DVB_NS_RTCP    0x04
+#define DVB_NS_RTP_TO  0x08
+#define DVB_NS_VLAN    0x10
+
+struct dvb_ns_rtcp {
+	__u8    *msg;
+	__u16    len;
+};
+
+struct dvb_ns_packet {
+	__u8    *buf;
+	__u8     count;
+};
+
+struct dvb_nsd_ts {
+	__u16    pid;
+	__u16    num;
+	__u16    input;
+	__u16    timeout;
+	__u16    len;
+	__u8    *ts;
+	__u8     mode;
+	__u8     table;
+
+	__u8	 filter_mask;
+ 	__u8     section;
+	__u16	 section_id;
+};
+
+#define NS_SET_NET               _IOW('o', 192, struct dvb_ns_params)
+#define NS_START                 _IO('o', 193)
+#define NS_STOP                  _IO('o', 194)
+#define NS_SET_PID               _IOW('o', 195, __u16)
+#define NS_SET_PIDS              _IOW('o', 196, __u8 *)
+#define NS_SET_RTCP_MSG          _IOW('o', 197, struct dvb_ns_rtcp)
+
+#define NSD_START_GET_TS         _IOWR('o', 198, struct dvb_nsd_ts)
+#define NSD_STOP_GET_TS          _IOWR('o', 199, struct dvb_nsd_ts)
+#define NSD_CANCEL_GET_TS        _IO('o', 200)
+#define NSD_POLL_GET_TS          _IOWR('o', 201, struct dvb_nsd_ts)
+
+#define NS_SET_PACKETS           _IOW('o', 202, struct dvb_ns_packet)
+#define NS_INSERT_PACKETS	 _IOW('o', 203, __u8)
+#define NS_SET_CI	         _IOW('o', 204, __u8)
+
+#endif /*_UAPI_DVBNS_H_*/
