diff --git a/CREDITS b/CREDITS
index 1d39a6d..dca6abc 100644
--- a/CREDITS
+++ b/CREDITS
@@ -1677,7 +1677,7 @@ W: http://www.codemonkey.org.uk
 D: Assorted VIA x86 support.
 D: 2.5 AGPGART overhaul.
 D: CPUFREQ maintenance.
-D: Fedora kernel maintainence.
+D: Fedora kernel maintenance.
 D: Misc/Other.
 S: 314 Littleton Rd, Westford, MA 01886, USA
 
@@ -3211,7 +3211,7 @@ N: James Simmons
 E: jsimmons@infradead.org
 E: jsimmons@users.sf.net 
 D: Frame buffer device maintainer
-D: input layer developement 
+D: input layer development
 D: tty/console layer
 D: various mipsel devices 
 S: 115 Carmel Avenue 
@@ -3290,7 +3290,7 @@ S: USA
 N: Manfred Spraul
 E: manfred@colorfullife.com
 W: http://www.colorfullife.com/~manfred
-D: Lots of tiny hacks. Larger improvments to SysV IPC msg,
+D: Lots of tiny hacks. Larger improvements to SysV IPC msg,
 D: slab, pipe, select.
 S: 71701 Schwieberdingen
 S: Germany
diff --git a/Documentation/ABI/testing/sysfs-bus-css b/Documentation/ABI/testing/sysfs-bus-css
index b585ec2..2979c40 100644
--- a/Documentation/ABI/testing/sysfs-bus-css
+++ b/Documentation/ABI/testing/sysfs-bus-css
@@ -29,7 +29,7 @@ Contact:	Cornelia Huck <cornelia.huck@de.ibm.com>
 		linux-s390@vger.kernel.org
 Description:	Contains the PIM/PAM/POM values, as reported by the
 		channel subsystem when last queried by the common I/O
-		layer (this implies that this attribute is not neccessarily
+		layer (this implies that this attribute is not necessarily
 		in sync with the values current in the channel subsystem).
 		Note: This is an I/O-subchannel specific attribute.
 Users:		s390-tools, HAL
diff --git a/Documentation/ABI/testing/sysfs-class-led b/Documentation/ABI/testing/sysfs-class-led
index edff663..3646ec8 100644
--- a/Documentation/ABI/testing/sysfs-class-led
+++ b/Documentation/ABI/testing/sysfs-class-led
@@ -33,5 +33,5 @@ Contact:	Richard Purdie <rpurdie@rpsys.net>
 Description:
 		Invert the LED on/off state. This parameter is specific to
 		gpio and backlight triggers. In case of the backlight trigger,
-		it is usefull when driving a LED which is intended to indicate
+		it is useful when driving a LED which is intended to indicate
 		a device in a standby like state.
diff --git a/Documentation/DocBook/dvb/dvbproperty.xml b/Documentation/DocBook/dvb/dvbproperty.xml
index 5f57c7c..97f397e 100644
--- a/Documentation/DocBook/dvb/dvbproperty.xml
+++ b/Documentation/DocBook/dvb/dvbproperty.xml
@@ -40,7 +40,7 @@
 
 			<para>Central frequency of the channel.</para>
 
-			<para>For ISDB-T the channels are usally transmitted with an offset of 143kHz. E.g. a
+			<para>For ISDB-T the channels are usually transmitted with an offset of 143kHz. E.g. a
 				valid frequncy could be 474143 kHz. The stepping is bound to the bandwidth of
 				the channel which is 6MHz.</para>
 
diff --git a/Documentation/DocBook/dvb/frontend.xml b/Documentation/DocBook/dvb/frontend.xml
index 78d756d..60c6976 100644
--- a/Documentation/DocBook/dvb/frontend.xml
+++ b/Documentation/DocBook/dvb/frontend.xml
@@ -139,7 +139,7 @@ consistently to the DiSEqC commands as described in the DiSEqC spec.</para>
 <section id="frontend_sec_tone">
 <title>SEC continuous tone</title>
 
-<para>The continous 22KHz tone is usually used with non-DiSEqC capable LNBs to switch the
+<para>The continuous 22KHz tone is usually used with non-DiSEqC capable LNBs to switch the
 high/low band of a dual-band LNB. When using DiSEqC epuipment this voltage has to
 be switched consistently to the DiSEqC commands as described in the DiSEqC
 spec.</para>
diff --git a/Documentation/DocBook/kernel-locking.tmpl b/Documentation/DocBook/kernel-locking.tmpl
index f66f4df..67e7ab4 100644
--- a/Documentation/DocBook/kernel-locking.tmpl
+++ b/Documentation/DocBook/kernel-locking.tmpl
@@ -1763,7 +1763,7 @@ as it would be on UP.
 There is a furthur optimization possible here: remember our original
 cache code, where there were no reference counts and the caller simply
 held the lock whenever using the object?  This is still possible: if
-you hold the lock, noone can delete the object, so you don't need to
+you hold the lock, no one can delete the object, so you don't need to
 get and put the reference count.
 </para>
 
diff --git a/Documentation/DocBook/libata.tmpl b/Documentation/DocBook/libata.tmpl
index 8c5411c..cdd1bb9 100644
--- a/Documentation/DocBook/libata.tmpl
+++ b/Documentation/DocBook/libata.tmpl
@@ -1032,7 +1032,7 @@ and other resources, etc.
 	   <listitem>
 	   <para>
 	   This is indicated by ICRC bit in the ERROR register and
-	   means that corruption occurred during data transfer.  Upto
+	   means that corruption occurred during data transfer.  Up to
 	   ATA/ATAPI-7, the standard specifies that this bit is only
 	   applicable to UDMA transfers but ATA/ATAPI-8 draft revision
 	   1f says that the bit may be applicable to multiword DMA and
@@ -1045,10 +1045,10 @@ and other resources, etc.
 	   <term>ABRT error during data transfer or on completion</term>
 	   <listitem>
 	   <para>
-	   Upto ATA/ATAPI-7, the standard specifies that ABRT could be
+	   Up to ATA/ATAPI-7, the standard specifies that ABRT could be
 	   set on ICRC errors and on cases where a device is not able
 	   to complete a command.  Combined with the fact that MWDMA
-	   and PIO transfer errors aren't allowed to use ICRC bit upto
+	   and PIO transfer errors aren't allowed to use ICRC bit up to
 	   ATA/ATAPI-7, it seems to imply that ABRT bit alone could
 	   indicate tranfer errors.
 	   </para>
@@ -1122,7 +1122,7 @@ and other resources, etc.
 	<para>
 	Depending on commands, not all STATUS/ERROR bits are
 	applicable.  These non-applicable bits are marked with
-	&quot;na&quot; in the output descriptions but upto ATA/ATAPI-7
+	&quot;na&quot; in the output descriptions but up to ATA/ATAPI-7
 	no definition of &quot;na&quot; can be found.  However,
 	ATA/ATAPI-8 draft revision 1f describes &quot;N/A&quot; as
 	follows.
@@ -1507,7 +1507,7 @@ and other resources, etc.
 
 	<listitem>
 	<para>
-	CHS set up with INITIALIZE DEVICE PARAMETERS (seldomly used)
+	CHS set up with INITIALIZE DEVICE PARAMETERS (seldom used)
 	</para>
 	</listitem>
 
diff --git a/Documentation/DocBook/mtdnand.tmpl b/Documentation/DocBook/mtdnand.tmpl
index 620eb3f..6f242d5 100644
--- a/Documentation/DocBook/mtdnand.tmpl
+++ b/Documentation/DocBook/mtdnand.tmpl
@@ -485,7 +485,7 @@ static void board_select_chip (struct mtd_info *mtd, int chip)
 				Reed-Solomon library.
 			</para>
 			<para>
-				The ECC bytes must be placed immidiately after the data
+				The ECC bytes must be placed immediately after the data
 				bytes in order to make the syndrome generator work. This
 				is contrary to the usual layout used by software ECC. The
 				separation of data and out of band area is not longer
@@ -629,7 +629,7 @@ static void board_select_chip (struct mtd_info *mtd, int chip)
 				holds the bad block table. Store a pointer to the pattern  
 				in the pattern field. Further the length of the pattern has to be 
 				stored in len and the offset in the spare area must be given
-				in the offs member of the nand_bbt_descr stucture. For mirrored
+				in the offs member of the nand_bbt_descr structure. For mirrored
 				bad block tables different patterns are mandatory.</para></listitem>
 				<listitem><para>Table creation</para>
 				<para>Set the option NAND_BBT_CREATE to enable the table creation
@@ -648,7 +648,7 @@ static void board_select_chip (struct mtd_info *mtd, int chip)
 				<listitem><para>Table version control</para>
 				<para>Set the option NAND_BBT_VERSION to enable the table version control.
 				It's highly recommended to enable this for mirrored tables with write
-				support. It makes sure that the risk of loosing the bad block
+				support. It makes sure that the risk of losing the bad block
 				table information is reduced to the loss of the information about the
 				one worn out block which should be marked bad. The version is stored in
 				4 consecutive bytes in the spare area of the device. The position of
@@ -1060,19 +1060,19 @@ data in this page</entry>
 <row>
 <entry>0x3D</entry>
 <entry>ECC byte 21</entry>
-<entry>Error correction code byte 0 of the eigth 256 Bytes of data
+<entry>Error correction code byte 0 of the eighth 256 Bytes of data
 in this page</entry>
 </row>
 <row>
 <entry>0x3E</entry>
 <entry>ECC byte 22</entry>
-<entry>Error correction code byte 1 of the eigth 256 Bytes of data
+<entry>Error correction code byte 1 of the eighth 256 Bytes of data
 in this page</entry>
 </row>
 <row>
 <entry>0x3F</entry>
 <entry>ECC byte 23</entry>
-<entry>Error correction code byte 2 of the eigth 256 Bytes of data
+<entry>Error correction code byte 2 of the eighth 256 Bytes of data
 in this page</entry>
 </row>
 </tbody></tgroup></informaltable>
diff --git a/Documentation/DocBook/regulator.tmpl b/Documentation/DocBook/regulator.tmpl
index 53f4f8d..346e552 100644
--- a/Documentation/DocBook/regulator.tmpl
+++ b/Documentation/DocBook/regulator.tmpl
@@ -267,8 +267,8 @@
      <sect1 id="machine-constraint">
        <title>Constraints</title>
        <para>
-	 As well as definining the connections the machine interface
-	 also provides constraints definining the operations that
+	 As well as defining the connections the machine interface
+	 also provides constraints defining the operations that
 	 clients are allowed to perform and the parameters that may be
 	 set.  This is required since generally regulator devices will
 	 offer more flexibility than it is safe to use on a given
diff --git a/Documentation/DocBook/uio-howto.tmpl b/Documentation/DocBook/uio-howto.tmpl
index b4665b9..7c4b514d 100644
--- a/Documentation/DocBook/uio-howto.tmpl
+++ b/Documentation/DocBook/uio-howto.tmpl
@@ -797,7 +797,7 @@ framework to set up sysfs files for this region. Simply leave it alone.
 	perform some initialization. After that, your hardware
 	starts working and will generate an interrupt as soon
 	as it's finished, has some data available, or needs your
-	attention because an error occured.
+	attention because an error occurred.
 	</para>
 	<para>
 	<filename>/dev/uioX</filename> is a read-only file. A
diff --git a/Documentation/DocBook/usb.tmpl b/Documentation/DocBook/usb.tmpl
index af29360..8d57c18 100644
--- a/Documentation/DocBook/usb.tmpl
+++ b/Documentation/DocBook/usb.tmpl
@@ -690,7 +690,7 @@ usbdev_ioctl (int fd, int ifno, unsigned request, void *param)
 		    </para><para>
 		    This request lets kernel drivers talk to user mode code
 		    through filesystem operations even when they don't create
-		    a charactor or block special device.
+		    a character or block special device.
 		    It's also been used to do things like ask devices what
 		    device special file should be used.
 		    Two pre-defined ioctls are used
diff --git a/Documentation/DocBook/v4l/common.xml b/Documentation/DocBook/v4l/common.xml
index dbab79c..9028721 100644
--- a/Documentation/DocBook/v4l/common.xml
+++ b/Documentation/DocBook/v4l/common.xml
@@ -100,7 +100,7 @@ linux-kernel@vger.kernel.org, 2002-11-20. --></para>
 
       <para>By convention system administrators create various
 character device special files with these major and minor numbers in
-the <filename>/dev</filename> directory. The names recomended for the
+the <filename>/dev</filename> directory. The names recommended for the
 different V4L2 device types are listed in <xref linkend="devices" />.
 </para>
 
diff --git a/Documentation/DocBook/v4l/controls.xml b/Documentation/DocBook/v4l/controls.xml
index 2fae3e8..a920ee8 100644
--- a/Documentation/DocBook/v4l/controls.xml
+++ b/Documentation/DocBook/v4l/controls.xml
@@ -1243,7 +1243,7 @@ values are:</entry>
 	      </row><row><entry spanname="descr">Mutes the audio when
 capturing. This is not done by muting audio hardware, which can still
 produce a slight hiss, but in the encoder itself, guaranteeing a fixed
-and reproducable audio bitstream. 0 = unmuted, 1 = muted.</entry>
+and reproducible audio bitstream. 0 = unmuted, 1 = muted.</entry>
 	      </row>
 	      <row><entry></entry></row>
 	      <row id="v4l2-mpeg-video-encoding">
diff --git a/Documentation/DocBook/v4l/dev-subdev.xml b/Documentation/DocBook/v4l/dev-subdev.xml
index 21caff6..05c8fef 100644
--- a/Documentation/DocBook/v4l/dev-subdev.xml
+++ b/Documentation/DocBook/v4l/dev-subdev.xml
@@ -90,7 +90,7 @@
     processing hardware.</para>
 
     <figure id="pipeline-scaling">
-      <title>Image Format Negotation on Pipelines</title>
+      <title>Image Format Negotiation on Pipelines</title>
       <mediaobject>
 	<imageobject>
 	  <imagedata fileref="pipeline.pdf" format="PS" />
diff --git a/Documentation/DocBook/v4l/libv4l.xml b/Documentation/DocBook/v4l/libv4l.xml
index c14fc3d..3cb10ec 100644
--- a/Documentation/DocBook/v4l/libv4l.xml
+++ b/Documentation/DocBook/v4l/libv4l.xml
@@ -140,7 +140,7 @@ and is not locked sets the cid to the scaled value.
 			<para>int v4l2_get_control(int fd, int cid) -
 This function returns a value of 0 - 65535, scaled to from the actual range
 of the given v4l control id. when the cid does not exist, could not be
-accessed for some reason, or some error occured 0 is returned.
+accessed for some reason, or some error occurred 0 is returned.
 </para></listitem>
 </itemizedlist>
 		</section>
diff --git a/Documentation/DocBook/v4l/remote_controllers.xml b/Documentation/DocBook/v4l/remote_controllers.xml
index 3c3b667..160e464 100644
--- a/Documentation/DocBook/v4l/remote_controllers.xml
+++ b/Documentation/DocBook/v4l/remote_controllers.xml
@@ -133,7 +133,7 @@ different IR's. Due to that, V4L2 API now specifies a standard for mapping Media
 <row><entry><constant>KEY_LEFT</constant></entry><entry>Left key</entry><entry>LEFT</entry></row>
 <row><entry><constant>KEY_RIGHT</constant></entry><entry>Right key</entry><entry>RIGHT</entry></row>
 
-<row><entry><emphasis role="bold">Miscelaneous keys</emphasis></entry></row>
+<row><entry><emphasis role="bold">Miscellaneous keys</emphasis></entry></row>
 
 <row><entry><constant>KEY_DOT</constant></entry><entry>Return a dot</entry><entry>.</entry></row>
 <row><entry><constant>KEY_FN</constant></entry><entry>Select a function</entry><entry>FUNCTION</entry></row>
diff --git a/Documentation/DocBook/writing-an-alsa-driver.tmpl b/Documentation/DocBook/writing-an-alsa-driver.tmpl
index 0ba149d..58ced23 100644
--- a/Documentation/DocBook/writing-an-alsa-driver.tmpl
+++ b/Documentation/DocBook/writing-an-alsa-driver.tmpl
@@ -4784,7 +4784,7 @@ struct _snd_pcm_runtime {
         FM registers can be directly accessed through the direct-FM API,
       defined in <filename>&lt;sound/asound_fm.h&gt;</filename>. In
       ALSA native mode, FM registers are accessed through
-      the Hardware-Dependant Device direct-FM extension API, whereas in
+      the Hardware-Dependent Device direct-FM extension API, whereas in
       OSS compatible mode, FM registers can be accessed with the OSS
       direct-FM compatible API in <filename>/dev/dmfmX</filename> device. 
       </para>
diff --git a/Documentation/PCI/MSI-HOWTO.txt b/Documentation/PCI/MSI-HOWTO.txt
index dcf7acc..3f5e0b0 100644
--- a/Documentation/PCI/MSI-HOWTO.txt
+++ b/Documentation/PCI/MSI-HOWTO.txt
@@ -253,8 +253,8 @@ In constrast, MSI is restricted to a maximum of 32 interrupts (and
 must be a power of two).  In addition, the MSI interrupt vectors must
 be allocated consecutively, so the system may not be able to allocate
 as many vectors for MSI as it could for MSI-X.  On some platforms, MSI
-interrupts must all be targetted at the same set of CPUs whereas MSI-X
-interrupts can all be targetted at different CPUs.
+interrupts must all be targeted at the same set of CPUs whereas MSI-X
+interrupts can all be targeted at different CPUs.
 
 4.5.2 Spinlocks
 
diff --git a/Documentation/SecurityBugs b/Documentation/SecurityBugs
index 26c3b36..a660d49 100644
--- a/Documentation/SecurityBugs
+++ b/Documentation/SecurityBugs
@@ -28,7 +28,7 @@ expect these delays to be short, measurable in days, not weeks or months.
 A disclosure date is negotiated by the security team working with the
 bug submitter as well as vendors.  However, the kernel security team
 holds the final say when setting a disclosure date.  The timeframe for
-disclosure is from immediate (esp. if it's already publically known)
+disclosure is from immediate (esp. if it's already publicly known)
 to a few weeks.  As a basic default policy, we expect report date to
 disclosure date to be on the order of 7 days.
 
diff --git a/Documentation/SubmittingDrivers b/Documentation/SubmittingDrivers
index 38d2aab..319baa8 100644
--- a/Documentation/SubmittingDrivers
+++ b/Documentation/SubmittingDrivers
@@ -101,7 +101,7 @@ PM support:	Since Linux is used on many portable and desktop systems, your
 		complete overview of the power management issues related to
 		drivers see Documentation/power/devices.txt .
 
-Control:	In general if there is active maintainance of a driver by
+Control:	In general if there is active maintenance of a driver by
 		the author then patches will be redirected to them unless
 		they are totally obvious and without need of checking.
 		If you want to be the contact and update point for the
diff --git a/Documentation/SubmittingPatches b/Documentation/SubmittingPatches
index 689e237..e439cd0 100644
--- a/Documentation/SubmittingPatches
+++ b/Documentation/SubmittingPatches
@@ -729,7 +729,7 @@ Linus Torvalds's mail on the canonical patch format:
   <http://lkml.org/lkml/2005/4/7/183>
 
 Andi Kleen, "On submitting kernel patches"
-  Some strategies to get difficult or controversal changes in.
+  Some strategies to get difficult or controversial changes in.
   http://halobates.de/on-submitting-patches.pdf
 
 --
diff --git a/Documentation/arm/IXP4xx b/Documentation/arm/IXP4xx
index 133c5fa..7b9351f 100644
--- a/Documentation/arm/IXP4xx
+++ b/Documentation/arm/IXP4xx
@@ -36,7 +36,7 @@ Linux currently supports the following features on the IXP4xx chips:
 - Timers (watchdog, OS)
 
 The following components of the chips are not supported by Linux and
-require the use of Intel's propietary CSR softare:
+require the use of Intel's proprietary CSR softare:
 
 - USB device interface
 - Network interfaces (HSS, Utopia, NPEs, etc)
@@ -47,7 +47,7 @@ software from:
 
    http://developer.intel.com/design/network/products/npfamily/ixp425.htm    
 
-DO NOT POST QUESTIONS TO THE LINUX MAILING LISTS REGARDING THE PROPIETARY
+DO NOT POST QUESTIONS TO THE LINUX MAILING LISTS REGARDING THE PROPRIETARY
 SOFTWARE.
 
 There are several websites that provide directions/pointers on using
diff --git a/Documentation/arm/Samsung-S3C24XX/Suspend.txt b/Documentation/arm/Samsung-S3C24XX/Suspend.txt
index 7edd0e2..1ca63b3 100644
--- a/Documentation/arm/Samsung-S3C24XX/Suspend.txt
+++ b/Documentation/arm/Samsung-S3C24XX/Suspend.txt
@@ -116,7 +116,7 @@ Configuration
     Allows the entire memory to be checksummed before and after the
     suspend to see if there has been any corruption of the contents.
 
-    Note, the time to calculate the CRC is dependant on the CPU speed
+    Note, the time to calculate the CRC is dependent on the CPU speed
     and the size of memory. For an 64Mbyte RAM area on an 200MHz
     S3C2410, this can take approximately 4 seconds to complete.
 
diff --git a/Documentation/arm/Samsung/GPIO.txt b/Documentation/arm/Samsung/GPIO.txt
index 05850c6..513f256 100644
--- a/Documentation/arm/Samsung/GPIO.txt
+++ b/Documentation/arm/Samsung/GPIO.txt
@@ -5,7 +5,7 @@ Introduction
 ------------
 
 This outlines the Samsung GPIO implementation and the architecture
-specfic calls provided alongisde the drivers/gpio core.
+specific calls provided alongisde the drivers/gpio core.
 
 
 S3C24XX (Legacy)
diff --git a/Documentation/block/biodoc.txt b/Documentation/block/biodoc.txt
index 2a7b38c..c6d84cf 100644
--- a/Documentation/block/biodoc.txt
+++ b/Documentation/block/biodoc.txt
@@ -497,7 +497,7 @@ The scatter gather list is in the form of an array of <page, offset, len>
 entries with their corresponding dma address mappings filled in at the
 appropriate time. As an optimization, contiguous physical pages can be
 covered by a single entry where <page> refers to the first page and <len>
-covers the range of pages (upto 16 contiguous pages could be covered this
+covers the range of pages (up to 16 contiguous pages could be covered this
 way). There is a helper routine (blk_rq_map_sg) which drivers can use to build
 the sg list.
 
@@ -565,7 +565,7 @@ struct request {
 	.
 	int tag;	/* command tag associated with request */
 	void *special;  /* same as before */
-	char *buffer;   /* valid only for low memory buffers upto
+	char *buffer;   /* valid only for low memory buffers up to
 			 current_nr_sectors */
 	.
 	.
diff --git a/Documentation/cpu-hotplug.txt b/Documentation/cpu-hotplug.txt
index 45d5a21..a20bfd4 100644
--- a/Documentation/cpu-hotplug.txt
+++ b/Documentation/cpu-hotplug.txt
@@ -196,7 +196,7 @@ the state as 0 when a cpu if offline and 1 when its online.
 	#To display the current cpu state.
 	#cat /sys/devices/system/cpu/cpuX/online
 
-Q: Why cant i remove CPU0 on some systems?
+Q: Why can't i remove CPU0 on some systems?
 A: Some architectures may have some special dependency on a certain CPU.
 
 For e.g in IA64 platforms we have ability to sent platform interrupts to the
diff --git a/Documentation/dell_rbu.txt b/Documentation/dell_rbu.txt
index 1517498..d262e22 100644
--- a/Documentation/dell_rbu.txt
+++ b/Documentation/dell_rbu.txt
@@ -62,7 +62,7 @@ image file and then arrange all these packets back to back in to one single
 file.
 This file is then copied to /sys/class/firmware/dell_rbu/data.
 Once this file gets to the driver, the driver extracts packet_size data from
-the file and spreads it accross the physical memory in contiguous packet_sized
+the file and spreads it across the physical memory in contiguous packet_sized
 space.
 This method makes sure that all the packets get to the driver in a single operation.
 
diff --git a/Documentation/device-mapper/dm-service-time.txt b/Documentation/device-mapper/dm-service-time.txt
index 7d00668..fb1d4a0 100644
--- a/Documentation/device-mapper/dm-service-time.txt
+++ b/Documentation/device-mapper/dm-service-time.txt
@@ -37,7 +37,7 @@ Algorithm
 =========
 
 dm-service-time adds the I/O size to 'in-flight-size' when the I/O is
-dispatched and substracts when completed.
+dispatched and subtracts when completed.
 Basically, dm-service-time selects a path having minimum service time
 which is calculated by:
 
diff --git a/Documentation/devicetree/bindings/fb/sm501fb.txt b/Documentation/devicetree/bindings/fb/sm501fb.txt
index 7d319fb..9d9f009 100644
--- a/Documentation/devicetree/bindings/fb/sm501fb.txt
+++ b/Documentation/devicetree/bindings/fb/sm501fb.txt
@@ -18,9 +18,9 @@ Optional properties:
 - edid : verbatim EDID data block describing attached display.
   Data from the detailed timing descriptor will be used to
   program the display controller.
-- little-endian: availiable on big endian systems, to
+- little-endian: available on big endian systems, to
   set different foreign endian.
-- big-endian: availiable on little endian systems, to
+- big-endian: available on little endian systems, to
   set different foreign endian.
 
 Example for MPC5200:
diff --git a/Documentation/devicetree/bindings/mtd/fsl-upm-nand.txt b/Documentation/devicetree/bindings/mtd/fsl-upm-nand.txt
index a48b2ca..00f1f54 100644
--- a/Documentation/devicetree/bindings/mtd/fsl-upm-nand.txt
+++ b/Documentation/devicetree/bindings/mtd/fsl-upm-nand.txt
@@ -15,7 +15,7 @@ Optional properties:
 - gpios : may specify optional GPIOs connected to the Ready-Not-Busy pins
 	(R/B#). For multi-chip devices, "n" GPIO definitions are required
 	according to the number of chips.
-- chip-delay : chip dependent delay for transfering data from array to
+- chip-delay : chip dependent delay for transferring data from array to
 	read registers (tR). Required if property "gpios" is not used
 	(R/B# pins not connected).
 
diff --git a/Documentation/devicetree/bindings/net/can/sja1000.txt b/Documentation/devicetree/bindings/net/can/sja1000.txt
index d6d209d..c2dbcec 100644
--- a/Documentation/devicetree/bindings/net/can/sja1000.txt
+++ b/Documentation/devicetree/bindings/net/can/sja1000.txt
@@ -39,7 +39,7 @@ Optional properties:
 
 - nxp,no-comparator-bypass : Allows to disable the CAN input comperator.
 
-For futher information, please have a look to the SJA1000 data sheet.
+For further information, please have a look to the SJA1000 data sheet.
 
 Examples:
 
diff --git a/Documentation/devicetree/bindings/powerpc/fsl/mpic.txt b/Documentation/devicetree/bindings/powerpc/fsl/mpic.txt
index 8aa10f4..4f61458 100644
--- a/Documentation/devicetree/bindings/powerpc/fsl/mpic.txt
+++ b/Documentation/devicetree/bindings/powerpc/fsl/mpic.txt
@@ -199,7 +199,7 @@ EXAMPLE 4
 
 EXAMPLE 5
 	/*
-	 * Definition of an error interrupt (interupt type 1).
+	 * Definition of an error interrupt (interrupt type 1).
 	 * SoC interrupt number is 16 and the specific error
          * interrupt bit in the error interrupt summary register
 	 * is 23.
diff --git a/Documentation/dvb/README.dvb-usb b/Documentation/dvb/README.dvb-usb
index c8238e4..c4d963a 100644
--- a/Documentation/dvb/README.dvb-usb
+++ b/Documentation/dvb/README.dvb-usb
@@ -138,7 +138,7 @@ Hotplug is able to load the driver, when it is needed (because you plugged
 in the device).
 
 If you want to enable debug output, you have to load the driver manually and
-from withing the dvb-kernel cvs repository.
+from within the dvb-kernel cvs repository.
 
 first have a look, which debug level are available:
 
diff --git a/Documentation/dvb/ci.txt b/Documentation/dvb/ci.txt
index 4a0c2b5..6c3bda5 100644
--- a/Documentation/dvb/ci.txt
+++ b/Documentation/dvb/ci.txt
@@ -47,7 +47,7 @@ so on.
 
 * CI modules that are supported
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-The CI module support is largely dependant upon the firmware on the cards
+The CI module support is largely dependent upon the firmware on the cards
 Some cards do support almost all of the available CI modules. There is
 nothing much that can be done in order to make additional CI modules
 working with these cards.
diff --git a/Documentation/dvb/faq.txt b/Documentation/dvb/faq.txt
index 121832e..97b1373 100644
--- a/Documentation/dvb/faq.txt
+++ b/Documentation/dvb/faq.txt
@@ -106,7 +106,7 @@ Some very frequently asked questions about linuxtv-dvb
 5. The dvb_net device doesn't give me any packets at all
 
 	Run tcpdump on the dvb0_0 interface. This sets the interface
-	into promiscous mode so it accepts any packets from the PID
+	into promiscuous mode so it accepts any packets from the PID
 	you have configured with the dvbnet utility. Check if there
 	are any packets with the IP addr and MAC addr you have
 	configured with ifconfig.
diff --git a/Documentation/edac.txt b/Documentation/edac.txt
index ccc07c2..249822c 100644
--- a/Documentation/edac.txt
+++ b/Documentation/edac.txt
@@ -741,7 +741,7 @@ were done at i7core_edac driver. This chapter will cover those differences
    As EDAC API maps the minimum unity is csrows, the driver sequencially
    maps channel/dimm into different csrows.
 
-   For example, suposing the following layout:
+   For example, supposing the following layout:
 	Ch0 phy rd0, wr0 (0x063f4031): 2 ranks, UDIMMs
 	  dimm 0 1024 Mb offset: 0, bank: 8, rank: 1, row: 0x4000, col: 0x400
 	  dimm 1 1024 Mb offset: 4, bank: 8, rank: 1, row: 0x4000, col: 0x400
diff --git a/Documentation/eisa.txt b/Documentation/eisa.txt
index f297fc1..38cf0c7 100644
--- a/Documentation/eisa.txt
+++ b/Documentation/eisa.txt
@@ -84,7 +84,7 @@ struct eisa_driver {
 
 id_table	: an array of NULL terminated EISA id strings,
 		  followed by an empty string. Each string can
-		  optionally be paired with a driver-dependant value
+		  optionally be paired with a driver-dependent value
 		  (driver_data).
 
 driver		: a generic driver, such as described in
diff --git a/Documentation/fb/viafb.txt b/Documentation/fb/viafb.txt
index 1a2e8aa..444e34b 100644
--- a/Documentation/fb/viafb.txt
+++ b/Documentation/fb/viafb.txt
@@ -204,7 +204,7 @@ Notes:
 
     supported_output_devices
 
-        This read-only file contains a full ',' seperated list containing all
+        This read-only file contains a full ',' separated list containing all
         output devices that could be available on your platform. It is likely
         that not all of those have a connector on your hardware but it should
         provide a good starting point to figure out which of those names match
@@ -225,7 +225,7 @@ Notes:
         This can happen for example if only one (the other) iga is used.
         Writing to these files allows adjusting the output devices during
         runtime. One can add new devices, remove existing ones or switch
-        between igas. Essentially you can write a ',' seperated list of device
+        between igas. Essentially you can write a ',' separated list of device
         names (or a single one) in the same format as the output to those
         files. You can add a '+' or '-' as a prefix allowing simple addition
         and removal of devices. So a prefix '+' adds the devices from your list
diff --git a/Documentation/filesystems/autofs4-mount-control.txt b/Documentation/filesystems/autofs4-mount-control.txt
index 51986bf..4c95935 100644
--- a/Documentation/filesystems/autofs4-mount-control.txt
+++ b/Documentation/filesystems/autofs4-mount-control.txt
@@ -309,7 +309,7 @@ ioctlfd field set to the descriptor obtained from the open call.
 AUTOFS_DEV_IOCTL_TIMEOUT_CMD
 ----------------------------
 
-Set the expire timeout for mounts withing an autofs mount point.
+Set the expire timeout for mounts within an autofs mount point.
 
 The call requires an initialized struct autofs_dev_ioctl with the
 ioctlfd field set to the descriptor obtained from the open call.
diff --git a/Documentation/filesystems/caching/netfs-api.txt b/Documentation/filesystems/caching/netfs-api.txt
index 1902c57..a167ab8 100644
--- a/Documentation/filesystems/caching/netfs-api.txt
+++ b/Documentation/filesystems/caching/netfs-api.txt
@@ -95,7 +95,7 @@ restraints as possible on how an index is structured and where it is placed in
 the tree.  The netfs can even mix indices and data files at the same level, but
 it's not recommended.
 
-Each index entry consists of a key of indeterminate length plus some auxilliary
+Each index entry consists of a key of indeterminate length plus some auxiliary
 data, also of indeterminate length.
 
 There are some limits on indices:
@@ -203,23 +203,23 @@ This has the following fields:
 
      If the function is absent, a file size of 0 is assumed.
 
- (6) A function to retrieve auxilliary data from the netfs [optional].
+ (6) A function to retrieve auxiliary data from the netfs [optional].
 
      This function will be called with the netfs data that was passed to the
-     cookie acquisition function and the maximum length of auxilliary data that
-     it may provide.  It should write the auxilliary data into the given buffer
+     cookie acquisition function and the maximum length of auxiliary data that
+     it may provide.  It should write the auxiliary data into the given buffer
      and return the quantity it wrote.
 
-     If this function is absent, the auxilliary data length will be set to 0.
+     If this function is absent, the auxiliary data length will be set to 0.
 
-     The length of the auxilliary data buffer may be dependent on the key
+     The length of the auxiliary data buffer may be dependent on the key
      length.  A netfs mustn't rely on being able to provide more than 400 bytes
      for both.
 
- (7) A function to check the auxilliary data [optional].
+ (7) A function to check the auxiliary data [optional].
 
      This function will be called to check that a match found in the cache for
-     this object is valid.  For instance with AFS it could check the auxilliary
+     this object is valid.  For instance with AFS it could check the auxiliary
      data against the data version number returned by the server to determine
      whether the index entry in a cache is still valid.
 
@@ -232,7 +232,7 @@ This has the following fields:
 	(*) FSCACHE_CHECKAUX_NEEDS_UPDATE	- the entry requires update
 	(*) FSCACHE_CHECKAUX_OBSOLETE		- the entry should be deleted
 
-     This function can also be used to extract data from the auxilliary data in
+     This function can also be used to extract data from the auxiliary data in
      the cache and copy it into the netfs's structures.
 
  (8) A pair of functions to manage contexts for the completion callback
diff --git a/Documentation/filesystems/configfs/configfs.txt b/Documentation/filesystems/configfs/configfs.txt
index fabcb0e..dd57bb6 100644
--- a/Documentation/filesystems/configfs/configfs.txt
+++ b/Documentation/filesystems/configfs/configfs.txt
@@ -409,7 +409,7 @@ As a consequence of this, default_groups cannot be removed directly via
 rmdir(2).  They also are not considered when rmdir(2) on the parent
 group is checking for children.
 
-[Dependant Subsystems]
+[Dependent Subsystems]
 
 Sometimes other drivers depend on particular configfs items.  For
 example, ocfs2 mounts depend on a heartbeat region item.  If that
diff --git a/Documentation/filesystems/ext4.txt b/Documentation/filesystems/ext4.txt
index 6b05046..c79ec58 100644
--- a/Documentation/filesystems/ext4.txt
+++ b/Documentation/filesystems/ext4.txt
@@ -97,7 +97,7 @@ Note: More extensive information for getting started with ext4 can be
 * Inode allocation using large virtual block groups via flex_bg
 * delayed allocation
 * large block (up to pagesize) support
-* efficent new ordered mode in JBD2 and ext4(avoid using buffer head to force
+* efficient new ordered mode in JBD2 and ext4(avoid using buffer head to force
   the ordering)
 
 [1] Filesystems with a block size of 1k may see a limit imposed by the
@@ -106,7 +106,7 @@ directory hash tree having a maximum depth of two.
 2.2 Candidate features for future inclusion
 
 * Online defrag (patches available but not well tested)
-* reduced mke2fs time via lazy itable initialization in conjuction with
+* reduced mke2fs time via lazy itable initialization in conjunction with
   the uninit_bg feature (capability to do this is available in e2fsprogs
   but a kernel thread to do lazy zeroing of unused inode table blocks
   after filesystem is first mounted is required for safety)
diff --git a/Documentation/filesystems/gfs2-uevents.txt b/Documentation/filesystems/gfs2-uevents.txt
index fd966dc..d818896 100644
--- a/Documentation/filesystems/gfs2-uevents.txt
+++ b/Documentation/filesystems/gfs2-uevents.txt
@@ -62,7 +62,7 @@ be fixed.
 
 The REMOVE uevent is generated at the end of an unsuccessful mount
 or at the end of a umount of the filesystem. All REMOVE uevents will
-have been preceeded by at least an ADD uevent for the same fileystem,
+have been preceded by at least an ADD uevent for the same fileystem,
 and unlike the other uevents is generated automatically by the kernel's
 kobject subsystem.
 
diff --git a/Documentation/filesystems/gfs2.txt b/Documentation/filesystems/gfs2.txt
index 0b59c02..4cda926 100644
--- a/Documentation/filesystems/gfs2.txt
+++ b/Documentation/filesystems/gfs2.txt
@@ -11,7 +11,7 @@ their I/O so file system consistency is maintained.  One of the nifty
 features of GFS is perfect consistency -- changes made to the file system
 on one machine show up immediately on all other machines in the cluster.
 
-GFS uses interchangable inter-node locking mechanisms, the currently
+GFS uses interchangeable inter-node locking mechanisms, the currently
 supported mechanisms are:
 
   lock_nolock -- allows gfs to be used as a local file system
diff --git a/Documentation/filesystems/ntfs.txt b/Documentation/filesystems/ntfs.txt
index 933bc66..791af8d 100644
--- a/Documentation/filesystems/ntfs.txt
+++ b/Documentation/filesystems/ntfs.txt
@@ -350,7 +350,7 @@ Note the "Should sync?" parameter "nosync" means that the two mirrors are
 already in sync which will be the case on a clean shutdown of Windows.  If the
 mirrors are not clean, you can specify the "sync" option instead of "nosync"
 and the Device-Mapper driver will then copy the entirety of the "Source Device"
-to the "Target Device" or if you specified multipled target devices to all of
+to the "Target Device" or if you specified multiple target devices to all of
 them.
 
 Once you have your table, save it in a file somewhere (e.g. /etc/ntfsvolume1),
diff --git a/Documentation/filesystems/ocfs2.txt b/Documentation/filesystems/ocfs2.txt
index 5393e66..9ed920a 100644
--- a/Documentation/filesystems/ocfs2.txt
+++ b/Documentation/filesystems/ocfs2.txt
@@ -80,7 +80,7 @@ user_xattr	(*)	Enables Extended User Attributes.
 nouser_xattr		Disables Extended User Attributes.
 acl			Enables POSIX Access Control Lists support.
 noacl		(*)	Disables POSIX Access Control Lists support.
-resv_level=2	(*)	Set how agressive allocation reservations will be.
+resv_level=2	(*)	Set how aggressive allocation reservations will be.
 			Valid values are between 0 (reservations off) to 8
 			(maximum space for reservations).
 dir_resv_level=	(*)	By default, directory reservations will scale with file
diff --git a/Documentation/filesystems/path-lookup.txt b/Documentation/filesystems/path-lookup.txt
index eb59c8b..3571667 100644
--- a/Documentation/filesystems/path-lookup.txt
+++ b/Documentation/filesystems/path-lookup.txt
@@ -42,7 +42,7 @@ Path walking overview
 A name string specifies a start (root directory, cwd, fd-relative) and a
 sequence of elements (directory entry names), which together refer to a path in
 the namespace. A path is represented as a (dentry, vfsmount) tuple. The name
-elements are sub-strings, seperated by '/'.
+elements are sub-strings, separated by '/'.
 
 Name lookups will want to find a particular path that a name string refers to
 (usually the final element, or parent of final element). This is done by taking
@@ -354,7 +354,7 @@ vfstest 24185492        4945    708725(2.9%) 1076136(4.4%)     0        2651
 
 What this shows is that failed rcu-walk lookups, ie. ones that are restarted
 entirely with ref-walk, are quite rare. Even the "vfstest" case which
-specifically has concurrent renames/mkdir/rmdir/ creat/unlink/etc to excercise
+specifically has concurrent renames/mkdir/rmdir/ creat/unlink/etc to exercise
 such races is not showing a huge amount of restarts.
 
 Dropping from rcu-walk to ref-walk mean that we have encountered a dentry where
diff --git a/Documentation/filesystems/pohmelfs/network_protocol.txt b/Documentation/filesystems/pohmelfs/network_protocol.txt
index 40ea6c2..65e03dd 100644
--- a/Documentation/filesystems/pohmelfs/network_protocol.txt
+++ b/Documentation/filesystems/pohmelfs/network_protocol.txt
@@ -20,7 +20,7 @@ Commands can be embedded into transaction command (which in turn has own command
 so one can extend protocol as needed without breaking backward compatibility as long
 as old commands are supported. All string lengths include tail 0 byte.
 
-All commans are transfered over the network in big-endian. CPU endianess is used at the end peers.
+All commands are transferred over the network in big-endian. CPU endianess is used at the end peers.
 
 @cmd - command number, which specifies command to be processed. Following
 	commands are used currently:
diff --git a/Documentation/filesystems/proc.txt b/Documentation/filesystems/proc.txt
index 23cae65..b0b814d 100644
--- a/Documentation/filesystems/proc.txt
+++ b/Documentation/filesystems/proc.txt
@@ -543,7 +543,7 @@ just those considered 'most important'.  The new vectors are:
   their statistics are used by kernel developers and interested users to
   determine the occurrence of interrupts of the given type.
 
-The above IRQ vectors are displayed only when relevent.  For example,
+The above IRQ vectors are displayed only when relevant.  For example,
 the threshold vector does not exist on x86_64 platforms.  Others are
 suppressed when the system is a uniprocessor.  As of this writing, only
 i386 and x86_64 platforms support the new IRQ vector displays.
@@ -1202,7 +1202,7 @@ The columns are:
                        W = can do write operations
                        U = can do unblank
   flags                E = it is enabled
-                       C = it is prefered console
+                       C = it is preferred console
                        B = it is primary boot console
                        p = it is used for printk buffer
                        b = it is not a TTY but a Braille device
@@ -1331,7 +1331,7 @@ NOTICE: /proc/<pid>/oom_adj is deprecated and will be removed, please see
 Documentation/feature-removal-schedule.txt.
 
 Caveat: when a parent task is selected, the oom killer will sacrifice any first
-generation children with seperate address spaces instead, if possible.  This
+generation children with separate address spaces instead, if possible.  This
 avoids servers and important system daemons from being killed and loses the
 minimal amount of work.
 
diff --git a/Documentation/filesystems/squashfs.txt b/Documentation/filesystems/squashfs.txt
index 2d78f19..d4d4146 100644
--- a/Documentation/filesystems/squashfs.txt
+++ b/Documentation/filesystems/squashfs.txt
@@ -219,7 +219,7 @@ or if it is stored out of line (in which case the value field stores a
 reference to where the actual value is stored).  This allows large values
 to be stored out of line improving scanning and lookup performance and it
 also allows values to be de-duplicated, the value being stored once, and
-all other occurences holding an out of line reference to that value.
+all other occurrences holding an out of line reference to that value.
 
 The xattr lists are packed into compressed 8K metadata blocks.
 To reduce overhead in inodes, rather than storing the on-disk
diff --git a/Documentation/filesystems/sysfs.txt b/Documentation/filesystems/sysfs.txt
index f806e50..597f728 100644
--- a/Documentation/filesystems/sysfs.txt
+++ b/Documentation/filesystems/sysfs.txt
@@ -62,7 +62,7 @@ values of the same type.
 
 Mixing types, expressing multiple lines of data, and doing fancy
 formatting of data is heavily frowned upon. Doing these things may get
-you publically humiliated and your code rewritten without notice. 
+you publicly humiliated and your code rewritten without notice. 
 
 
 An attribute definition is simply:
diff --git a/Documentation/filesystems/vfs.txt b/Documentation/filesystems/vfs.txt
index 80815ed..21a7dc4 100644
--- a/Documentation/filesystems/vfs.txt
+++ b/Documentation/filesystems/vfs.txt
@@ -97,7 +97,7 @@ functions:
 The passed struct file_system_type describes your filesystem. When a
 request is made to mount a filesystem onto a directory in your namespace,
 the VFS will call the appropriate mount() method for the specific
-filesystem.  New vfsmount refering to the tree returned by ->mount()
+filesystem.  New vfsmount referring to the tree returned by ->mount()
 will be attached to the mountpoint, so that when pathname resolution
 reaches the mountpoint it will jump into the root of that vfsmount.
 
diff --git a/Documentation/filesystems/xfs-delayed-logging-design.txt b/Documentation/filesystems/xfs-delayed-logging-design.txt
index 5282e3e..2ce3643 100644
--- a/Documentation/filesystems/xfs-delayed-logging-design.txt
+++ b/Documentation/filesystems/xfs-delayed-logging-design.txt
@@ -42,7 +42,7 @@ the aggregation of all the previous changes currently held only in the log.
 This relogging technique also allows objects to be moved forward in the log so
 that an object being relogged does not prevent the tail of the log from ever
 moving forward.  This can be seen in the table above by the changing
-(increasing) LSN of each subsquent transaction - the LSN is effectively a
+(increasing) LSN of each subsequent transaction - the LSN is effectively a
 direct encoding of the location in the log of the transaction.
 
 This relogging is also used to implement long-running, multiple-commit
@@ -338,7 +338,7 @@ the same time another transaction modifies the item and inserts the log item
 into the new CIL, then checkpoint transaction commit code cannot use log items
 to store the list of log vectors that need to be written into the transaction.
 Hence log vectors need to be able to be chained together to allow them to be
-detatched from the log items. That is, when the CIL is flushed the memory
+detached from the log items. That is, when the CIL is flushed the memory
 buffer and log vector attached to each log item needs to be attached to the
 checkpoint context so that the log item can be released. In diagrammatic form,
 the CIL would look like this before the flush:
@@ -577,7 +577,7 @@ only becomes unpinned when all the transactions complete and there are no
 pending transactions. Thus the pinning and unpinning of a log item is symmetric
 as there is a 1:1 relationship with transaction commit and log item completion.
 
-For delayed logging, however, we have an assymetric transaction commit to
+For delayed logging, however, we have an asymmetric transaction commit to
 completion relationship. Every time an object is relogged in the CIL it goes
 through the commit process without a corresponding completion being registered.
 That is, we now have a many-to-one relationship between transaction commit and
@@ -780,7 +780,7 @@ With delayed logging, there are new steps inserted into the life cycle:
 From this, it can be seen that the only life cycle differences between the two
 logging methods are in the middle of the life cycle - they still have the same
 beginning and end and execution constraints. The only differences are in the
-commiting of the log items to the log itself and the completion processing.
+committing of the log items to the log itself and the completion processing.
 Hence delayed logging should not introduce any constraints on log item
 behaviour, allocation or freeing that don't already exist.
 
diff --git a/Documentation/hwmon/abituguru b/Documentation/hwmon/abituguru
index 5eb3b9d..915f320 100644
--- a/Documentation/hwmon/abituguru
+++ b/Documentation/hwmon/abituguru
@@ -78,7 +78,7 @@ motherboards (most modern Abit motherboards).
 
 The first and second revision of the uGuru chip in reality is a Winbond
 W83L950D in disguise (despite Abit claiming it is "a new microprocessor
-designed by the ABIT Engineers"). Unfortunatly this doesn't help since the
+designed by the ABIT Engineers"). Unfortunately this doesn't help since the
 W83L950D is a generic microcontroller with a custom Abit application running
 on it.
 
diff --git a/Documentation/hwmon/abituguru-datasheet b/Documentation/hwmon/abituguru-datasheet
index d9251ef..8d2be8a 100644
--- a/Documentation/hwmon/abituguru-datasheet
+++ b/Documentation/hwmon/abituguru-datasheet
@@ -5,9 +5,9 @@ First of all, what I know about uGuru is no fact based on any help, hints or
 datasheet from Abit. The data I have got on uGuru have I assembled through
 my weak knowledge in "backwards engineering".
 And just for the record, you may have noticed uGuru isn't a chip developed by
-Abit, as they claim it to be. It's realy just an microprocessor (uC) created by
+Abit, as they claim it to be. It's really just an microprocessor (uC) created by
 Winbond (W83L950D). And no, reading the manual for this specific uC or
-mailing  Windbond for help won't give any usefull data about uGuru, as it is
+mailing  Windbond for help won't give any useful data about uGuru, as it is
 the program inside the uC that is responding to calls.
 
 Olle Sandberg <ollebull@gmail.com>, 2005-05-25
@@ -41,7 +41,7 @@ later on attached again data-port will hold 0x08, more about this later.
 
 After wider testing of the Linux kernel driver some variants of the uGuru have
 turned up which will hold 0x00 instead of 0xAC at the CMD port, thus we also
-have to test CMD for two different values. On these uGuru's DATA will initally
+have to test CMD for two different values. On these uGuru's DATA will initially
 hold 0x09 and will only hold 0x08 after reading CMD first, so CMD must be read
 first!
 
@@ -308,5 +308,5 @@ the voltage / clock programming out, I tried reading and only reading banks
 resulted in a _permanent_ reprogramming of the voltages, luckily I had the
 sensors part configured so that it would shutdown my system on any out of spec
 voltages which proprably safed my computer (after a reboot I managed to
-immediatly enter the bios and reload the defaults). This probably means that
+immediately enter the bios and reload the defaults). This probably means that
 the read/write cycle for the non sensor part is different from the sensor part.
diff --git a/Documentation/hwmon/abituguru3 b/Documentation/hwmon/abituguru3
index fa598aa..a6ccfe4 100644
--- a/Documentation/hwmon/abituguru3
+++ b/Documentation/hwmon/abituguru3
@@ -47,7 +47,7 @@ This driver supports the hardware monitoring features of the third revision of
 the Abit uGuru chip, found on recent Abit uGuru featuring motherboards.
 
 The 3rd revision of the uGuru chip in reality is a Winbond W83L951G.
-Unfortunatly this doesn't help since the W83L951G is a generic microcontroller
+Unfortunately this doesn't help since the W83L951G is a generic microcontroller
 with a custom Abit application running on it.
 
 Despite Abit not releasing any information regarding the uGuru revision 3,
diff --git a/Documentation/hwmon/pmbus b/Documentation/hwmon/pmbus
index f2d42e8..dc4933e 100644
--- a/Documentation/hwmon/pmbus
+++ b/Documentation/hwmon/pmbus
@@ -150,11 +150,11 @@ The following attributes are supported. Limits are read-write; all other
 attributes are read-only.
 
 inX_input		Measured voltage. From READ_VIN or READ_VOUT register.
-inX_min			Minumum Voltage.
+inX_min			Minimum Voltage.
 			From VIN_UV_WARN_LIMIT or VOUT_UV_WARN_LIMIT register.
 inX_max			Maximum voltage.
 			From VIN_OV_WARN_LIMIT or VOUT_OV_WARN_LIMIT register.
-inX_lcrit		Critical minumum Voltage.
+inX_lcrit		Critical minimum Voltage.
 			From VIN_UV_FAULT_LIMIT or VOUT_UV_FAULT_LIMIT register.
 inX_crit		Critical maximum voltage.
 			From VIN_OV_FAULT_LIMIT or VOUT_OV_FAULT_LIMIT register.
@@ -169,7 +169,7 @@ inX_label		"vin", "vcap", or "voutY"
 currX_input		Measured current. From READ_IIN or READ_IOUT register.
 currX_max		Maximum current.
 			From IIN_OC_WARN_LIMIT or IOUT_OC_WARN_LIMIT register.
-currX_lcrit		Critical minumum output current.
+currX_lcrit		Critical minimum output current.
 			From IOUT_UC_FAULT_LIMIT register.
 currX_crit		Critical maximum current.
 			From IIN_OC_FAULT_LIMIT or IOUT_OC_FAULT_LIMIT register.
diff --git a/Documentation/hwmon/sysfs-interface b/Documentation/hwmon/sysfs-interface
index 83a6987..8f63c24 100644
--- a/Documentation/hwmon/sysfs-interface
+++ b/Documentation/hwmon/sysfs-interface
@@ -579,7 +579,7 @@ channel should not be trusted.
 fan[1-*]_fault
 temp[1-*]_fault
 		Input fault condition
-		0: no fault occured
+		0: no fault occurred
 		1: fault condition
 		RO
 
diff --git a/Documentation/hwmon/w83781d b/Documentation/hwmon/w83781d
index ecbc1e4..129b0a3 100644
--- a/Documentation/hwmon/w83781d
+++ b/Documentation/hwmon/w83781d
@@ -403,7 +403,7 @@ found out the following values do work as a form of coarse pwm:
 
 0x80 - seems to turn fans off after some time(1-2 minutes)... might be
 some form of auto-fan-control based on temp? hmm (Qfan? this mobo is an
-old ASUS, it isn't marketed as Qfan. Maybe some beta pre-attemp at Qfan
+old ASUS, it isn't marketed as Qfan. Maybe some beta pre-attempt at Qfan
 that was dropped at the BIOS)
 0x81 - off
 0x82 - slightly "on-ner" than off, but my fans do not get to move. I can
diff --git a/Documentation/hwmon/w83791d b/Documentation/hwmon/w83791d
index 5663e49..90387c3 100644
--- a/Documentation/hwmon/w83791d
+++ b/Documentation/hwmon/w83791d
@@ -93,7 +93,7 @@ The sysfs interface to the beep bitmask has migrated from the original legacy
 method of a single sysfs beep_mask file to a newer method using multiple
 *_beep files as described in .../Documentation/hwmon/sysfs-interface.
 
-A similar change has occured for the bitmap corresponding to the alarms. The
+A similar change has occurred for the bitmap corresponding to the alarms. The
 original legacy method used a single sysfs alarms file containing a bitmap
 of triggered alarms. The newer method uses multiple sysfs *_alarm files
 (again following the pattern described in sysfs-interface).
diff --git a/Documentation/i2c/busses/i2c-parport-light b/Documentation/i2c/busses/i2c-parport-light
index bdc9cbb..c22ee06 100644
--- a/Documentation/i2c/busses/i2c-parport-light
+++ b/Documentation/i2c/busses/i2c-parport-light
@@ -4,7 +4,7 @@ Author: Jean Delvare <khali@linux-fr.org>
 
 This driver is a light version of i2c-parport. It doesn't depend        
 on the parport driver, and uses direct I/O access instead. This might be
-prefered on embedded systems where wasting memory for the clean but heavy
+preferred on embedded systems where wasting memory for the clean but heavy
 parport handling is not an option. The drawback is a reduced portability
 and the impossibility to daisy-chain other parallel port devices.                 
   
diff --git a/Documentation/i2c/busses/i2c-sis96x b/Documentation/i2c/busses/i2c-sis96x
index 70e6a0c..0b979f3 100644
--- a/Documentation/i2c/busses/i2c-sis96x
+++ b/Documentation/i2c/busses/i2c-sis96x
@@ -35,7 +35,7 @@ or perhaps this...
 
 (kernel versions later than 2.4.18 may fill in the "Unknown"s)
 
-If you cant see it please look on quirk_sis_96x_smbus
+If you can't see it please look on quirk_sis_96x_smbus
 (drivers/pci/quirks.c) (also if southbridge detection fails)
 
 I suspect that this driver could be made to work for the following SiS
diff --git a/Documentation/i2c/busses/i2c-taos-evm b/Documentation/i2c/busses/i2c-taos-evm
index 9146e33..63f62bc 100644
--- a/Documentation/i2c/busses/i2c-taos-evm
+++ b/Documentation/i2c/busses/i2c-taos-evm
@@ -13,7 +13,7 @@ Currently supported devices are:
 
 * TAOS TSL2550 EVM
 
-For addtional information on TAOS products, please see
+For additional information on TAOS products, please see
   http://www.taosinc.com/
 
 
diff --git a/Documentation/i2o/README b/Documentation/i2o/README
index 0ebf58c..ee91e26 100644
--- a/Documentation/i2o/README
+++ b/Documentation/i2o/README
@@ -53,7 +53,7 @@ Symbios Logic (Now LSI)
 BoxHill Corporation
 	Loan of initial FibreChannel disk array used for development work.
 
-European Comission
+European Commission
 	Funding the work done by the University of Helsinki
 
 SysKonnect
diff --git a/Documentation/ia64/aliasing-test.c b/Documentation/ia64/aliasing-test.c
index 3dfb76c..5caa2af 100644
--- a/Documentation/ia64/aliasing-test.c
+++ b/Documentation/ia64/aliasing-test.c
@@ -177,7 +177,7 @@ static int scan_rom(char *path, char *file)
 
 			/*
 			 * It's OK if the ROM is unreadable.  Maybe there
-			 * is no ROM, or some other error ocurred.  The
+			 * is no ROM, or some other error occurred.  The
 			 * important thing is that no MCA happened.
 			 */
 			if (rc > 0)
diff --git a/Documentation/input/joystick-parport.txt b/Documentation/input/joystick-parport.txt
index 1c856f3..56870c7 100644
--- a/Documentation/input/joystick-parport.txt
+++ b/Documentation/input/joystick-parport.txt
@@ -272,7 +272,7 @@ if you want to use gamecon.c.
 
   Also, the connection is a bit more complex. You'll need a bunch of diodes,
 and one pullup resistor. First, you connect the Directions and the button
-the same as for db9, however with the diodes inbetween.
+the same as for db9, however with the diodes between.
 
 	    Diodes
 (pin 2) -----|<|----> Up
diff --git a/Documentation/input/rotary-encoder.txt b/Documentation/input/rotary-encoder.txt
index 8b4129d..943e8f6 100644
--- a/Documentation/input/rotary-encoder.txt
+++ b/Documentation/input/rotary-encoder.txt
@@ -46,7 +46,7 @@ c) Falling edge on channel A, channel B in high state
 
 d) Falling edge on channel B, channel A in low state
 	Parking position. If the encoder enters this state, a full transition
-	should have happend, unless it flipped back on half the way. The
+	should have happened, unless it flipped back on half the way. The
 	'armed' state tells us about that.
 
 2. Platform requirements
diff --git a/Documentation/input/walkera0701.txt b/Documentation/input/walkera0701.txt
index 8f4289e..561385d 100644
--- a/Documentation/input/walkera0701.txt
+++ b/Documentation/input/walkera0701.txt
@@ -77,7 +77,7 @@ pulse length:
 
 24 bin+oct values + 1 bin value = 24*4+1 bits  = 97 bits
 
-(Warning, pulses on ACK ar inverted by transistor, irq is rised up on sync
+(Warning, pulses on ACK are inverted by transistor, irq is raised up on sync
 to bin change or octal value to bin change).
 
 Binary data representations:
diff --git a/Documentation/irqflags-tracing.txt b/Documentation/irqflags-tracing.txt
index 6a44487..67aa71e 100644
--- a/Documentation/irqflags-tracing.txt
+++ b/Documentation/irqflags-tracing.txt
@@ -53,5 +53,5 @@ implementation in an architecture: lockdep will detect that and will
 turn itself off. I.e. the lock validator will still be reliable. There
 should be no crashes due to irq-tracing bugs. (except if the assembly
 changes break other code by modifying conditions or registers that
-shouldnt be)
+shouldn't be)
 
diff --git a/Documentation/isdn/INTERFACE.CAPI b/Documentation/isdn/INTERFACE.CAPI
index 309eb5e..1688b5a 100644
--- a/Documentation/isdn/INTERFACE.CAPI
+++ b/Documentation/isdn/INTERFACE.CAPI
@@ -240,7 +240,7 @@ Functions capi_cmsg2message() and capi_message2cmsg() are provided to convert
 messages between their transport encoding described in the CAPI 2.0 standard
 and their _cmsg structure representation. Note that capi_cmsg2message() does
 not know or check the size of its destination buffer. The caller must make
-sure it is big enough to accomodate the resulting CAPI message.
+sure it is big enough to accommodate the resulting CAPI message.
 
 
 5. Lower Layer Interface Functions
diff --git a/Documentation/kbuild/kbuild.txt b/Documentation/kbuild/kbuild.txt
index f1431d0..7c2a89b 100644
--- a/Documentation/kbuild/kbuild.txt
+++ b/Documentation/kbuild/kbuild.txt
@@ -26,11 +26,11 @@ Additional options to the assembler (for built-in and modules).
 
 AFLAGS_MODULE
 --------------------------------------------------
-Addtional module specific options to use for $(AS).
+Additional module specific options to use for $(AS).
 
 AFLAGS_KERNEL
 --------------------------------------------------
-Addtional options for $(AS) when used for assembler
+Additional options for $(AS) when used for assembler
 code for code that is compiled as built-in.
 
 KCFLAGS
@@ -39,12 +39,12 @@ Additional options to the C compiler (for built-in and modules).
 
 CFLAGS_KERNEL
 --------------------------------------------------
-Addtional options for $(CC) when used to compile
+Additional options for $(CC) when used to compile
 code that is compiled as built-in.
 
 CFLAGS_MODULE
 --------------------------------------------------
-Addtional module specific options to use for $(CC).
+Additional module specific options to use for $(CC).
 
 LDFLAGS_MODULE
 --------------------------------------------------
diff --git a/Documentation/kernel-parameters.txt b/Documentation/kernel-parameters.txt
index d2b5150..cc85a92 100644
--- a/Documentation/kernel-parameters.txt
+++ b/Documentation/kernel-parameters.txt
@@ -699,7 +699,7 @@ bytes respectively. Such letter suffixes can also be entirely omitted.
 	ekgdboc=	[X86,KGDB] Allow early kernel console debugging
 			ekgdboc=kbd
 
-			This is desgined to be used in conjunction with
+			This is designed to be used in conjunction with
 			the boot argument: earlyprintk=vga
 
 	edd=		[EDD]
diff --git a/Documentation/kvm/mmu.txt b/Documentation/kvm/mmu.txt
index 142cc51..f46aa58 100644
--- a/Documentation/kvm/mmu.txt
+++ b/Documentation/kvm/mmu.txt
@@ -23,7 +23,7 @@ The mmu code attempts to satisfy the following requirements:
                and framebuffer-based displays
 - footprint:   keep the amount of pinned kernel memory low (most memory
                should be shrinkable)
-- reliablity:  avoid multipage or GFP_ATOMIC allocations
+- reliability:  avoid multipage or GFP_ATOMIC allocations
 
 Acronyms
 ========
diff --git a/Documentation/kvm/ppc-pv.txt b/Documentation/kvm/ppc-pv.txt
index a7f2244..3ab969c 100644
--- a/Documentation/kvm/ppc-pv.txt
+++ b/Documentation/kvm/ppc-pv.txt
@@ -136,7 +136,7 @@ Patched instructions
 ====================
 
 The "ld" and "std" instructions are transormed to "lwz" and "stw" instructions
-respectively on 32 bit systems with an added offset of 4 to accomodate for big
+respectively on 32 bit systems with an added offset of 4 to accommodate for big
 endianness.
 
 The following is a list of mapping the Linux kernel performs when running as
diff --git a/Documentation/kvm/timekeeping.txt b/Documentation/kvm/timekeeping.txt
index 0c5033a..df89463 100644
--- a/Documentation/kvm/timekeeping.txt
+++ b/Documentation/kvm/timekeeping.txt
@@ -81,7 +81,7 @@ Mode 0: Single Timeout.   This is a one-shot software timeout that counts down
  when the gate is high (always true for timers 0 and 1).  When the count
  reaches zero, the output goes high.
 
-Mode 1: Triggered One-shot.  The output is intially set high.  When the gate
+Mode 1: Triggered One-shot.  The output is initially set high.  When the gate
  line is set high, a countdown is initiated (which does not stop if the gate is
  lowered), during which the output is set low.  When the count reaches zero,
  the output goes high.
diff --git a/Documentation/media-framework.txt b/Documentation/media-framework.txt
index fd48add..76a2087 100644
--- a/Documentation/media-framework.txt
+++ b/Documentation/media-framework.txt
@@ -194,7 +194,7 @@ each pad.
 
 Links are represented by a struct media_link instance, defined in
 include/media/media-entity.h. Each entity stores all links originating at or
-targetting any of its pads in a links array. A given link is thus stored
+targeting any of its pads in a links array. A given link is thus stored
 twice, once in the source entity and once in the target entity. The array is
 pre-allocated and grows dynamically as needed.
 
@@ -348,6 +348,6 @@ a streaming entity. Links that can be modified while streaming must be marked
 with the MEDIA_LNK_FL_DYNAMIC flag.
 
 If other operations need to be disallowed on streaming entities (such as
-changing entities configuration parameters) drivers can explictly check the
+changing entities configuration parameters) drivers can explicitly check the
 media_entity stream_count field to find out if an entity is streaming. This
 operation must be done with the media_device graph_mutex held.
diff --git a/Documentation/mips/AU1xxx_IDE.README b/Documentation/mips/AU1xxx_IDE.README
index 8ace35e..cc887ec 100644
--- a/Documentation/mips/AU1xxx_IDE.README
+++ b/Documentation/mips/AU1xxx_IDE.README
@@ -39,13 +39,13 @@ Note: for more information, please refer "AMD Alchemy Au1200/Au1550 IDE
       Interface and Linux Device Driver" Application Note.
 
 
-FILES, CONFIGS AND COMPATABILITY
+FILES, CONFIGS AND COMPATIBILITY
 --------------------------------
 
 Two files are introduced:
 
   a) 'arch/mips/include/asm/mach-au1x00/au1xxx_ide.h'
-     containes : struct _auide_hwif
+     contains : struct _auide_hwif
                  timing parameters for PIO mode 0/1/2/3/4
                  timing parameters for MWDMA 0/1/2
 
diff --git a/Documentation/misc-devices/ics932s401 b/Documentation/misc-devices/ics932s401
index 07a739f..bdac67f 100644
--- a/Documentation/misc-devices/ics932s401
+++ b/Documentation/misc-devices/ics932s401
@@ -5,7 +5,7 @@ Supported chips:
   * IDT ICS932S401
     Prefix: 'ics932s401'
     Addresses scanned: I2C 0x69
-    Datasheet: Publically available at the IDT website
+    Datasheet: Publicly available at the IDT website
 
 Author: Darrick J. Wong
 
diff --git a/Documentation/networking/3c359.txt b/Documentation/networking/3c359.txt
index 4af8071..dadfe81 100644
--- a/Documentation/networking/3c359.txt
+++ b/Documentation/networking/3c359.txt
@@ -45,7 +45,7 @@ debugging messages on, that must be done by modified the source code.
 
 Variable MTU size:
 
-The driver can handle a MTU size upto either 4500 or 18000 depending upon 
+The driver can handle a MTU size up to either 4500 or 18000 depending upon 
 ring speed.  The driver also changes the size of the receive buffers as part
 of the mtu re-sizing, so if you set mtu = 18000, you will need to be able
 to allocate 16 * (sk_buff with 18000 buffer size) call it 18500 bytes per ring 
diff --git a/Documentation/networking/README.ipw2200 b/Documentation/networking/README.ipw2200
index 616a8e5..b7658be 100644
--- a/Documentation/networking/README.ipw2200
+++ b/Documentation/networking/README.ipw2200
@@ -256,7 +256,7 @@ You can set the debug level via:
 
 Where $VALUE would be a number in the case of this sysfs entry.  The 
 input to sysfs files does not have to be a number.  For example, the 
-firmware loader used by hotplug utilizes sysfs entries for transfering 
+firmware loader used by hotplug utilizes sysfs entries for transferring 
 the firmware image from user space into the driver.
 
 The Intel(R) PRO/Wireless 2915ABG Driver for Linux exposes sysfs entries 
diff --git a/Documentation/networking/bonding.txt b/Documentation/networking/bonding.txt
index b36e741..e27202b 100644
--- a/Documentation/networking/bonding.txt
+++ b/Documentation/networking/bonding.txt
@@ -368,7 +368,7 @@ fail_over_mac
 		gratuitous ARP is lost, communication may be
 		disrupted.
 
-		When this policy is used in conjuction with the mii
+		When this policy is used in conjunction with the mii
 		monitor, devices which assert link up prior to being
 		able to actually transmit and receive are particularly
 		susceptible to loss of the gratuitous ARP, and an
diff --git a/Documentation/networking/caif/Linux-CAIF.txt b/Documentation/networking/caif/Linux-CAIF.txt
index 7fe7a9a..e52fd62 100644
--- a/Documentation/networking/caif/Linux-CAIF.txt
+++ b/Documentation/networking/caif/Linux-CAIF.txt
@@ -136,7 +136,7 @@ The CAIF Protocol implementation contains:
       - CFMUX CAIF Mux layer. Handles multiplexing between multiple
 	physical bearers and multiple channels such as VEI, Datagram, etc.
 	The MUX keeps track of the existing CAIF Channels and
-	Physical Instances and selects the apropriate instance based
+	Physical Instances and selects the appropriate instance based
 	on Channel-Id and Physical-ID.
 
       - CFFRML CAIF Framing layer. Handles Framing i.e. Frame length
diff --git a/Documentation/networking/caif/spi_porting.txt b/Documentation/networking/caif/spi_porting.txt
index 0cb8cb9..9efd068 100644
--- a/Documentation/networking/caif/spi_porting.txt
+++ b/Documentation/networking/caif/spi_porting.txt
@@ -150,7 +150,7 @@ static int sspi_init_xfer(struct cfspi_xfer *xfer, struct cfspi_dev *dev)
 void sspi_sig_xfer(bool xfer, struct cfspi_dev *dev)
 {
 	/* If xfer is true then you should assert the SPI_INT to indicate to
-	 * the master that you are ready to recieve the data from the master
+	 * the master that you are ready to receive the data from the master
 	 * SPI. If xfer is false then you should de-assert SPI_INT to indicate
 	 * that the transfer is done.
 	 */
diff --git a/Documentation/networking/can.txt b/Documentation/networking/can.txt
index 5b04b67..56ca3b7 100644
--- a/Documentation/networking/can.txt
+++ b/Documentation/networking/can.txt
@@ -240,7 +240,7 @@ solution for a couple of reasons:
   the user application using the common CAN filter mechanisms. Inside
   this filter definition the (interested) type of errors may be
   selected. The reception of error frames is disabled by default.
-  The format of the CAN error frame is briefly decribed in the Linux
+  The format of the CAN error frame is briefly described in the Linux
   header file "include/linux/can/error.h".
 
 4. How to use Socket CAN
diff --git a/Documentation/networking/ieee802154.txt b/Documentation/networking/ieee802154.txt
index 23c995e..f41ea24 100644
--- a/Documentation/networking/ieee802154.txt
+++ b/Documentation/networking/ieee802154.txt
@@ -9,7 +9,7 @@ The Linux-ZigBee project goal is to provide complete implementation
 of IEEE 802.15.4 / ZigBee / 6LoWPAN protocols. IEEE 802.15.4 is a stack
 of protocols for organizing Low-Rate Wireless Personal Area Networks.
 
-Currently only IEEE 802.15.4 layer is implemented. We have choosen
+Currently only IEEE 802.15.4 layer is implemented. We have chosen
 to use plain Berkeley socket API, the generic Linux networking stack
 to transfer IEEE 802.15.4 messages and a special protocol over genetlink
 for configuration/management
diff --git a/Documentation/networking/olympic.txt b/Documentation/networking/olympic.txt
index c65a940..b95b5bf 100644
--- a/Documentation/networking/olympic.txt
+++ b/Documentation/networking/olympic.txt
@@ -65,7 +65,7 @@ together.
 
 Variable MTU size:
 
-The driver can handle a MTU size upto either 4500 or 18000 depending upon 
+The driver can handle a MTU size up to either 4500 or 18000 depending upon 
 ring speed.  The driver also changes the size of the receive buffers as part
 of the mtu re-sizing, so if you set mtu = 18000, you will need to be able
 to allocate 16 * (sk_buff with 18000 buffer size) call it 18500 bytes per ring 
diff --git a/Documentation/networking/packet_mmap.txt b/Documentation/networking/packet_mmap.txt
index 073894d..4acea66 100644
--- a/Documentation/networking/packet_mmap.txt
+++ b/Documentation/networking/packet_mmap.txt
@@ -223,7 +223,7 @@ we will get the following buffer structure:
 
 A frame can be of any size with the only condition it can fit in a block. A block
 can only hold an integer number of frames, or in other words, a frame cannot 
-be spawned accross two blocks, so there are some details you have to take into 
+be spawned across two blocks, so there are some details you have to take into 
 account when choosing the frame_size. See "Mapping and use of the circular 
 buffer (ring)".
 
diff --git a/Documentation/networking/s2io.txt b/Documentation/networking/s2io.txt
index 9d4e0f4..4be0c03 100644
--- a/Documentation/networking/s2io.txt
+++ b/Documentation/networking/s2io.txt
@@ -37,7 +37,7 @@ To associate an interface with a physical adapter use "ethtool -p <ethX>".
 The corresponding adapter's LED will blink multiple times.
 
 3.	Features supported:
-a. Jumbo frames. Xframe I/II supports MTU upto 9600 bytes,
+a. Jumbo frames. Xframe I/II supports MTU up to 9600 bytes,
 modifiable using ifconfig command.
 
 b. Offloads. Supports checksum offload(TCP/UDP/IP) on transmit
@@ -49,7 +49,7 @@ significant performance improvement on certain platforms(SGI Altix,
 IBM xSeries).
 
 d. MSI/MSI-X. Can be enabled on platforms which support this feature
-(IA64, Xeon) resulting in noticeable performance improvement(upto 7%
+(IA64, Xeon) resulting in noticeable performance improvement(up to 7%
 on certain platforms).
 
 e. Statistics. Comprehensive MAC-level and software statistics displayed
diff --git a/Documentation/networking/tc-actions-env-rules.txt b/Documentation/networking/tc-actions-env-rules.txt
index dcadf6f..70d6cf6 100644
--- a/Documentation/networking/tc-actions-env-rules.txt
+++ b/Documentation/networking/tc-actions-env-rules.txt
@@ -1,5 +1,5 @@
 
-The "enviromental" rules for authors of any new tc actions are:
+The "environmental" rules for authors of any new tc actions are:
 
 1) If you stealeth or borroweth any packet thou shalt be branching
 from the righteous path and thou shalt cloneth.
@@ -20,7 +20,7 @@ this way any action downstream can stomp on the packet.
 3) Dropping packets you don't own is a no-no. You simply return
 TC_ACT_SHOT to the caller and they will drop it.
 
-The "enviromental" rules for callers of actions (qdiscs etc) are:
+The "environmental" rules for callers of actions (qdiscs etc) are:
 
 *) Thou art responsible for freeing anything returned as being
 TC_ACT_SHOT/STOLEN/QUEUED. If none of TC_ACT_SHOT/STOLEN/QUEUED is
diff --git a/Documentation/power/devices.txt b/Documentation/power/devices.txt
index f023ba6..1971bcf 100644
--- a/Documentation/power/devices.txt
+++ b/Documentation/power/devices.txt
@@ -367,7 +367,7 @@ Drivers need to be able to handle hardware which has been reset since the
 suspend methods were called, for example by complete reinitialization.
 This may be the hardest part, and the one most protected by NDA'd documents
 and chip errata.  It's simplest if the hardware state hasn't changed since
-the suspend was carried out, but that can't be guaranteed (in fact, it ususally
+the suspend was carried out, but that can't be guaranteed (in fact, it usually
 is not the case).
 
 Drivers must also be prepared to notice that the device has been removed
diff --git a/Documentation/power/notifiers.txt b/Documentation/power/notifiers.txt
index ae1b7ec..cf98070 100644
--- a/Documentation/power/notifiers.txt
+++ b/Documentation/power/notifiers.txt
@@ -24,7 +24,7 @@ PM_HIBERNATION_PREPARE	The system is going to hibernate or suspend, tasks will
 			be frozen immediately.
 
 PM_POST_HIBERNATION	The system memory state has been restored from a
-			hibernation image or an error occured during the
+			hibernation image or an error occurred during the
 			hibernation.  Device drivers' .resume() callbacks have
 			been executed and tasks have been thawed.
 
@@ -38,7 +38,7 @@ PM_POST_RESTORE		An error occurred during the hibernation restore.
 
 PM_SUSPEND_PREPARE	The system is preparing for a suspend.
 
-PM_POST_SUSPEND		The system has just resumed or an error occured during
+PM_POST_SUSPEND		The system has just resumed or an error occurred during
 			the suspend.	Device drivers' .resume() callbacks have
 			been executed and tasks have been thawed.
 
diff --git a/Documentation/power/opp.txt b/Documentation/power/opp.txt
index cd44558..5ae70a1 100644
--- a/Documentation/power/opp.txt
+++ b/Documentation/power/opp.txt
@@ -178,7 +178,7 @@ opp_find_freq_ceil - Search for an available OPP which is *at least* the
 		if (!IS_ERR(opp))
 			soc_switch_to_freq_voltage(freq);
 		else
-			/* do something when we cant satisfy the req */
+			/* do something when we can't satisfy the req */
 		/* do other stuff */
 	 }
 
diff --git a/Documentation/power/swsusp.txt b/Documentation/power/swsusp.txt
index ea71889..ac190cf 100644
--- a/Documentation/power/swsusp.txt
+++ b/Documentation/power/swsusp.txt
@@ -192,7 +192,7 @@ Q: There don't seem to be any generally useful behavioral
 distinctions between SUSPEND and FREEZE.
 
 A: Doing SUSPEND when you are asked to do FREEZE is always correct,
-but it may be unneccessarily slow. If you want your driver to stay simple,
+but it may be unnecessarily slow. If you want your driver to stay simple,
 slowness may not matter to you. It can always be fixed later.
 
 For devices like disk it does matter, you do not want to spindown for
@@ -237,7 +237,7 @@ disk. Whole sequence goes like
 
       running system, user asks for suspend-to-disk
 
-      user processes are stopped (in common case there are none, but with resume-from-initrd, noone knows)
+      user processes are stopped (in common case there are none, but with resume-from-initrd, no one knows)
 
       read image from disk
 
diff --git a/Documentation/power/userland-swsusp.txt b/Documentation/power/userland-swsusp.txt
index 81680f9..1101bee 100644
--- a/Documentation/power/userland-swsusp.txt
+++ b/Documentation/power/userland-swsusp.txt
@@ -98,7 +98,7 @@ SNAPSHOT_S2RAM - suspend to RAM; using this call causes the kernel to
 The device's read() operation can be used to transfer the snapshot image from
 the kernel.  It has the following limitations:
 - you cannot read() more than one virtual memory page at a time
-- read()s accross page boundaries are impossible (ie. if ypu read() 1/2 of
+- read()s across page boundaries are impossible (ie. if ypu read() 1/2 of
 	a page in the previous call, you will only be able to read()
 	_at_ _most_ 1/2 of the page in the next call)
 
@@ -137,7 +137,7 @@ mechanism and the userland utilities using the interface SHOULD use additional
 means, such as checksums, to ensure the integrity of the snapshot image.
 
 The suspending and resuming utilities MUST lock themselves in memory,
-preferrably using mlockall(), before calling SNAPSHOT_FREEZE.
+preferably using mlockall(), before calling SNAPSHOT_FREEZE.
 
 The suspending utility MUST check the value stored by SNAPSHOT_CREATE_IMAGE
 in the memory location pointed to by the last argument of ioctl() and proceed
@@ -147,7 +147,7 @@ in accordance with it:
 	(a)	The suspending utility MUST NOT close the snapshot device
 		_unless_ the whole suspend procedure is to be cancelled, in
 		which case, if the snapshot image has already been saved, the
-		suspending utility SHOULD destroy it, preferrably by zapping
+		suspending utility SHOULD destroy it, preferably by zapping
 		its header.  If the suspend is not to be cancelled, the
 		system MUST be powered off or rebooted after the snapshot
 		image has been saved.
diff --git a/Documentation/powerpc/hvcs.txt b/Documentation/powerpc/hvcs.txt
index 6d8be34..a730ca5 100644
--- a/Documentation/powerpc/hvcs.txt
+++ b/Documentation/powerpc/hvcs.txt
@@ -528,7 +528,7 @@ this driver assignment of hotplug added vty-servers may be in a different
 order than how they would be exposed on module load.  Rebooting or
 reloading the module after dynamic addition may result in the /dev/hvcs*
 and vty-server coupling changing if a vty-server adapter was added in a
-slot inbetween two other vty-server adapters.  Refer to the section above
+slot between two other vty-server adapters.  Refer to the section above
 on how to determine which vty-server goes with which /dev/hvcs* node.
 Hint; look at the sysfs "index" attribute for the vty-server.
 
diff --git a/Documentation/scsi/ChangeLog.lpfc b/Documentation/scsi/ChangeLog.lpfc
index 5e83769..c56ec99 100644
--- a/Documentation/scsi/ChangeLog.lpfc
+++ b/Documentation/scsi/ChangeLog.lpfc
@@ -352,7 +352,7 @@ Changes from 20041229 to 20050110
 	  lpfc_scsiport.c
 	* In remote port changes: no longer nulling target->pnode when
 	  removing from mapped list. Pnode get nulled when the node is
-	  freed (after nodev tmo). This bug was causing i/o recieved in
+	  freed (after nodev tmo). This bug was causing i/o received in
 	  the small window while the device was blocked to be errored w/
 	  did_no_connect. With the fix, it returns host_busy
 	  (per the pre-remote port changes).
@@ -530,7 +530,7 @@ Changes from 20041018 to 20041123
 	  coherent mappings.  Note: There are more consistent mappings
 	  that are using pci_dma_sync calls. Probably these should be
 	  removed as well.
-	* Modified lpfc_free_scsi_buf to accomodate all three scsi_buf
+	* Modified lpfc_free_scsi_buf to accommodate all three scsi_buf
 	  free types to alleviate miscellaneous panics with cable pull
 	  testing.
 	* Set hotplug to default 0 and lpfc_target_remove to not remove
@@ -583,7 +583,7 @@ Changes from 20041018 to 20041123
 	  included more than once.
 	* Replaced "set_current_state(TASK_UNINTERRUPTIBLE);
 	  schedule_timeout(timeout)" with "msleep(timeout)".
-	* Fixnode was loosing starget when rediscovered. We saw messages
+	* Fixnode was losing starget when rediscovered. We saw messages
 	  like: lpfc 0000:04:02.0: 0:0263 Cannot block scsi target as a
 	  result.  Moved starget field into struct lpfc_target which is
 	  referenced from the node.
@@ -604,7 +604,7 @@ Changes from 20041018 to 20041123
 	* Make 3 functions static: lpfc_get_hba_sym_node_name,
 	  lpfc_intr_prep and lpfc_setup_slim_access.  Move lpfc_intr_prep
 	  and lpfc_setup_slim_access so they're defined before being used.
-	* Remove an unecessary list_del() in lpfc_hbadisc.c.
+	* Remove an unnecessary list_del() in lpfc_hbadisc.c.
 	* Set nlp_state before calling lpfc_nlp_list() since this will
 	  potentially call fc_target_unblock which may cause a race in
 	  queuecommand by releasing host_lock.
@@ -753,7 +753,7 @@ Changes from 20040908 to 20040920
 	* Changed version number to 8.0.12
 	* Removed used #defines: DEFAULT_PCI_LATENCY_CLOCKS and
 	  PCI_LATENCY_VALUE from lpfc_hw.h.
-	* Changes to accomodate rnid.
+	* Changes to accommodate rnid.
 	* Fix RSCN handling so RSCN NS queries only effect NPorts found in
 	  RSCN data.
 	* If we rcv a plogi on a NPort queued up for discovery, clear the
@@ -813,7 +813,7 @@ Changes from 20040908 to 20040920
 	  counter instead, brd_no isn't reused anymore.  Also some tiny
 	  whitespace cleanups in surrounding code.
 	* Reorder functions in lpfc_els.c to remove need for prototypes.
-	* Removed unsed prototypes from lpfc_crtn.h -
+	* Removed unused prototypes from lpfc_crtn.h -
 	  lpfc_ip_timeout_handler, lpfc_read_pci and lpfc_revoke.
 	* Removed some unused prototypes from lpfc_crtn.h -
 	  lpfc_scsi_hba_reset, lpfc_scsi_issue_inqsn,
@@ -863,7 +863,7 @@ Changes from 20040823 to 20040908
 	* Minimal support for SCSI flat space addressing/volume set
 	  addressing.  Use 16 bits of LUN address so that flat
 	  addressing/VSA will work.
-	* Changed 2 occurences of if( 1 != f(x)) to if(f(x) != 1)
+	* Changed 2 occurrences of if( 1 != f(x)) to if(f(x) != 1)
 	* Drop include of lpfc_cfgparm.h.
 	* Reduce stack usage of lpfc_fdmi_cmd in lpfc_ct.c.
 	* Add minimum range checking property to /sys write/store
@@ -1449,7 +1449,7 @@ Changes from 20040402 to 20040409
 	* Removed lpfc_els_chk_latt from the lpfc_config_post function.
 	  lpfc_els_chk_latt will enable the link event interrupts when
 	  flogi is pending which causes two discovery state machines
-	  running parallely.
+	  running parallelly.
 	* Add pci_disable_device to unload path.
 	* Move lpfc_sleep_event from lpfc_fcp.c to lpfc_util_ioctl.c
 	* Call dma_map_single() & pci_map_single() directly instead of via
@@ -1590,7 +1590,7 @@ Changes from 20040326 to 20040402
 	  ELX_WRITE_HS ELX_WRITE_HA ELX_WRITE_CA ELX_READ_HC
 	  ELX_READ_HS ELX_READ_HA ELX_READ_CA ELX_READ_MB ELX_RESET
 	  ELX_READ_HBA ELX_INSTANCE ELX_LIP.  Also introduced
-	  attribute "set" to be used in conjuction with the above
+	  attribute "set" to be used in conjunction with the above
 	  attributes.
 	* Removed DLINK, enque and deque declarations now that clock
 	  doesn't use them anymore
diff --git a/Documentation/scsi/ChangeLog.megaraid b/Documentation/scsi/ChangeLog.megaraid
index 5e07d32..d2052fd 100644
--- a/Documentation/scsi/ChangeLog.megaraid
+++ b/Documentation/scsi/ChangeLog.megaraid
@@ -168,7 +168,7 @@ Older Version	: 2.20.4.6 (scsi module), 2.20.2.6 (cmm module)
 
 1.	Sorted out PCI IDs to remove megaraid support overlaps.
 	Based on the patch from Daniel, sorted out PCI IDs along with
-	charactor node name change from 'megadev' to 'megadev_legacy' to avoid
+	character node name change from 'megadev' to 'megadev_legacy' to avoid
 	conflict.
 	---
 	Hopefully we'll be getting the build restriction zapped much sooner, 
diff --git a/Documentation/scsi/ChangeLog.ncr53c8xx b/Documentation/scsi/ChangeLog.ncr53c8xx
index 8b278c1..9288e3d 100644
--- a/Documentation/scsi/ChangeLog.ncr53c8xx
+++ b/Documentation/scsi/ChangeLog.ncr53c8xx
@@ -200,7 +200,7 @@ Sun Feb  14:00 1999 Gerard Roudier (groudier@club-internet.fr)
 	  By default the driver uses both IRQF_SHARED and IRQF_DISABLED.
 	  Option 'ncr53c8xx=irqm:0x20' may be used when an IRQ is shared by 
 	  a 53C8XX adapter and a network board.
-	- Tiny mispelling fixed (ABORT instead of ABRT). Was fortunately 
+	- Tiny misspelling fixed (ABORT instead of ABRT). Was fortunately 
 	  harmless.
 	- Negotiate SYNC data transfers with CCS devices.
 
diff --git a/Documentation/scsi/ChangeLog.sym53c8xx b/Documentation/scsi/ChangeLog.sym53c8xx
index 02ffbc1..c193370 100644
--- a/Documentation/scsi/ChangeLog.sym53c8xx
+++ b/Documentation/scsi/ChangeLog.sym53c8xx
@@ -457,7 +457,7 @@ Fri Jan  1  20:00 1999 Gerard Roudier (groudier@club-internet.fr)
 Sat Dec 19  21:00 1998 Gerard Roudier (groudier@club-internet.fr)
 	* version sym53c8xx-1.0
 	- Define some new IO registers for the 896 (istat1, mbox0, mbox1)
-	- Revamp slighly the Symbios NVRAM lay-out based on the excerpt of 
+	- Revamp slightly the Symbios NVRAM lay-out based on the excerpt of 
 	  the header file I received from Symbios.
 	- Check the PCI bus number for the boot order (Using a fast 
 	  PCI controller behing a PCI-PCI bridge seems sub-optimal).
diff --git a/Documentation/scsi/aha152x.txt b/Documentation/scsi/aha152x.txt
index 29ce6d8..9484873 100644
--- a/Documentation/scsi/aha152x.txt
+++ b/Documentation/scsi/aha152x.txt
@@ -124,7 +124,7 @@ in the partition table and therefore every operating system has to know
 the right geometry to be able to interpret it.
 
 Moreover there are certain limitations to the C/H/S addressing scheme,
-namely the address space is limited to upto 255 heads, upto 63 sectors
+namely the address space is limited to up to 255 heads, up to 63 sectors
 and a maximum of 1023 cylinders.
 
 The AHA-1522 BIOS calculates the geometry by fixing the number of heads
diff --git a/Documentation/scsi/aic79xx.txt b/Documentation/scsi/aic79xx.txt
index 16e054c..64ac709 100644
--- a/Documentation/scsi/aic79xx.txt
+++ b/Documentation/scsi/aic79xx.txt
@@ -267,7 +267,7 @@ The following information is available in this file:
               Option: tag_info:{{value[,value...]}[,{value[,value...]}...]}
           Definition: Set the per-target tagged queue depth on a
                       per controller basis.  Both controllers and targets
-                      may be ommitted indicating that they should retain
+                      may be omitted indicating that they should retain
                       the default tag depth.
             Examples: tag_info:{{16,32,32,64,8,8,,32,32,32,32,32,32,32,32,32}
                         On Controller 0
@@ -291,7 +291,7 @@ The following information is available in this file:
                       The rd_strm_bitmask is a 16 bit hex value in which
                       each bit represents a target.  Setting the target's
                       bit to '1' enables read streaming for that
-                      target.  Controllers may be ommitted indicating that
+                      target.  Controllers may be omitted indicating that
                       they should retain the default read streaming setting.
              Example: rd_strm:{0x0041}
                         On Controller 0
@@ -313,7 +313,7 @@ The following information is available in this file:
    -----------------------------------------------------------------
               Option: dv: {value[,value...]}
           Definition: Set Domain Validation Policy on a per-controller basis.
-                      Controllers may be ommitted indicating that
+                      Controllers may be omitted indicating that
                       they should retain the default read streaming setting.
              Example: dv:{-1,0,,1,1,0}
                         On Controller 0 leave DV at its default setting.
@@ -340,7 +340,7 @@ The following information is available in this file:
               Option: precomp: {value[,value...]}
           Definition: Set IO Cell precompensation value on a per-controller
                       basis.
-                      Controllers may be ommitted indicating that
+                      Controllers may be omitted indicating that
                       they should retain the default precompensation setting.
              Example: precomp:{0x1}
                         On Controller 0 set precompensation to 1.
@@ -353,7 +353,7 @@ The following information is available in this file:
    -----------------------------------------------------------------
               Option: slewrate: {value[,value...]}
           Definition: Set IO Cell slew rate on a per-controller basis.
-                      Controllers may be ommitted indicating that
+                      Controllers may be omitted indicating that
                       they should retain the default slew rate setting.
              Example: slewrate:{0x1}
                         On Controller 0 set slew rate to 1.
@@ -366,7 +366,7 @@ The following information is available in this file:
    -----------------------------------------------------------------
               Option: amplitude: {value[,value...]}
           Definition: Set IO Cell signal amplitude on a per-controller basis.
-                      Controllers may be ommitted indicating that
+                      Controllers may be omitted indicating that
                       they should retain the default read streaming setting.
              Example: amplitude:{0x1}
                         On Controller 0 set amplitude to 1.
diff --git a/Documentation/scsi/ibmmca.txt b/Documentation/scsi/ibmmca.txt
index 45d61ad..ac41a9f 100644
--- a/Documentation/scsi/ibmmca.txt
+++ b/Documentation/scsi/ibmmca.txt
@@ -303,7 +303,7 @@
    (scb) and calls a local function issue_cmd(), which writes a scb 
    command into subsystem I/O ports. Once the scb command is carried out, 
    the interrupt_handler() is invoked. If a device is determined to be 
-   existant and it has not assigned any ldn, it gets one dynamically.
+   existent and it has not assigned any ldn, it gets one dynamically.
    For this, the whole stuff is done in ibmmca_queuecommand().
 
    2.6 Abort & Reset Commands
@@ -741,7 +741,7 @@
       some error appeared, else it is undefined. Now, this is fixed. Before
       any SCB command gets queued, the tsb.dev_status is set to 0, so the 
       cmd->result won't screw up Linux higher level drivers.
-   2) The reset-function has slightly improved. This is still planed for 
+   2) The reset-function has slightly improved. This is still planned for 
       abort. During the abort and the reset function, no interrupts are 
       allowed. This is however quite hard to cope with, so the INT-status
       register is read. When the interrupt gets queued, one can find its
diff --git a/Documentation/scsi/scsi-changer.txt b/Documentation/scsi/scsi-changer.txt
index 032399b..ade046e 100644
--- a/Documentation/scsi/scsi-changer.txt
+++ b/Documentation/scsi/scsi-changer.txt
@@ -102,7 +102,7 @@ Trouble?
 
 If you insmod the driver with "insmod debug=1", it will be verbose and
 prints a lot of stuff to the syslog.  Compiling the kernel with
-CONFIG_SCSI_CONSTANTS=y improves the quality of the error messages alot
+CONFIG_SCSI_CONSTANTS=y improves the quality of the error messages a lot
 because the kernel will translate the error codes into human-readable
 strings then.
 
diff --git a/Documentation/scsi/scsi_eh.txt b/Documentation/scsi/scsi_eh.txt
index 7acbebb..6ff16b6 100644
--- a/Documentation/scsi/scsi_eh.txt
+++ b/Documentation/scsi/scsi_eh.txt
@@ -290,7 +290,7 @@ scmd->allowed.
 	SCSI transports/LLDDs automatically acquire sense data on
 	command failures (autosense).  Autosense is recommended for
 	performance reasons and as sense information could get out of
-	sync inbetween occurrence of CHECK CONDITION and this action.
+	sync between occurrence of CHECK CONDITION and this action.
 
 	Note that if autosense is not supported, scmd->sense_buffer
 	contains invalid sense data when error-completing the scmd
diff --git a/Documentation/scsi/scsi_fc_transport.txt b/Documentation/scsi/scsi_fc_transport.txt
index e00192d..f79282f 100644
--- a/Documentation/scsi/scsi_fc_transport.txt
+++ b/Documentation/scsi/scsi_fc_transport.txt
@@ -291,7 +291,7 @@ Transport <-> LLDD Interfaces :
 Vport support by LLDD:
 
   The LLDD indicates support for vports by supplying a vport_create()
-  function in the transport template.  The presense of this function will
+  function in the transport template.  The presence of this function will
   cause the creation of the new attributes on the fc_host.  As part of
   the physical port completing its initialization relative to the
   transport, it should set the max_npiv_vports attribute to indicate the
diff --git a/Documentation/serial/moxa-smartio b/Documentation/serial/moxa-smartio
index d104439..5d2a33b 100644
--- a/Documentation/serial/moxa-smartio
+++ b/Documentation/serial/moxa-smartio
@@ -473,7 +473,7 @@ Content
    spd_normal	  Use  38.4kb  when  the application requests 38.4kb.
    spd_cust	  Use  the custom divisor to set the speed when  the
 		  application requests 38.4kb.
-   divisor	  This option set the custom divison.
+   divisor	  This option set the custom division.
    baud_base	  This option set the base baud rate.
 
 -----------------------------------------------------------------------------
diff --git a/Documentation/serial/n_gsm.txt b/Documentation/serial/n_gsm.txt
index 397f41a..a5d9112 100644
--- a/Documentation/serial/n_gsm.txt
+++ b/Documentation/serial/n_gsm.txt
@@ -34,7 +34,7 @@ Major parts of the initialization program :
 	/* configure the serial port : speed, flow control ... */
 
 	/* send the AT commands to switch the modem to CMUX mode
-	   and check that it's succesful (should return OK) */
+	   and check that it's successful (should return OK) */
 	write(fd, "AT+CMUX=0\r", 10);
 
 	/* experience showed that some modems need some time before
diff --git a/Documentation/sound/alsa/ALSA-Configuration.txt b/Documentation/sound/alsa/ALSA-Configuration.txt
index 181ba5b..9822afb 100644
--- a/Documentation/sound/alsa/ALSA-Configuration.txt
+++ b/Documentation/sound/alsa/ALSA-Configuration.txt
@@ -322,7 +322,7 @@ Prior to version 0.9.0rc4 options had a 'snd_' prefix. This was removed.
     "port" needs to match the BASE ADDRESS jumper on the card (0x220 or 0x240)
     or the value stored in the card's EEPROM for cards that have an EEPROM and
     their "CONFIG MODE" jumper set to "EEPROM SETTING". The other values can
-    be choosen freely from the options enumerated above.
+    be chosen freely from the options enumerated above.
 
     If dma2 is specified and different from dma1, the card will operate in
     full-duplex mode. When dma1=3, only dma2=0 is valid and the only way to
@@ -356,7 +356,7 @@ Prior to version 0.9.0rc4 options had a 'snd_' prefix. This was removed.
     "port" needs to match the BASE ADDRESS jumper on the card (0x220 or 0x240)
     or the value stored in the card's EEPROM for cards that have an EEPROM and
     their "CONFIG MODE" jumper set to "EEPROM SETTING". The other values can
-    be choosen freely from the options enumerated above.
+    be chosen freely from the options enumerated above.
 
     If dma2 is specified and different from dma1, the card will operate in
     full-duplex mode. When dma1=3, only dma2=0 is valid and the only way to
diff --git a/Documentation/sound/oss/README.OSS b/Documentation/sound/oss/README.OSS
index c615deb..4be2594 100644
--- a/Documentation/sound/oss/README.OSS
+++ b/Documentation/sound/oss/README.OSS
@@ -1352,7 +1352,7 @@ OSS-mixer.
 The PCM20 contains a radio tuner, which is also controlled by
 ACI. This radio tuner is supported by the ACI driver together with the
 miropcm20.o module. Also the 7-band equalizer is integrated
-(limited by the OSS-design). Developement has started and maybe
+(limited by the OSS-design). Development has started and maybe
 finished for the RDS decoder on this card, too. You will be able to
 read RadioText, the Programme Service name, Programme TYpe and
 others. Even the v4l radio module benefits from it with a refined
diff --git a/Documentation/spi/pxa2xx b/Documentation/spi/pxa2xx
index 68a4fe3..493dada 100644
--- a/Documentation/spi/pxa2xx
+++ b/Documentation/spi/pxa2xx
@@ -143,7 +143,7 @@ configured to use SSPFRM instead.
 NOTE: the SPI driver cannot control the chip select if SSPFRM is used, so the
 chipselect is dropped after each spi_transfer.  Most devices need chip select
 asserted around the complete message.  Use SSPFRM as a GPIO (through cs_control)
-to accomodate these chips.
+to accommodate these chips.
 
 
 NSSP SLAVE SAMPLE
diff --git a/Documentation/spi/spi-lm70llp b/Documentation/spi/spi-lm70llp
index 34a9cfd..463f6d0 100644
--- a/Documentation/spi/spi-lm70llp
+++ b/Documentation/spi/spi-lm70llp
@@ -46,7 +46,7 @@ The hardware interfacing on the LM70 LLP eval board is as follows:
 
 Note that since the LM70 uses a "3-wire" variant of SPI, the SI/SO pin
 is connected to both pin D7 (as Master Out) and Select (as Master In)
-using an arrangment that lets either the parport or the LM70 pull the
+using an arrangement that lets either the parport or the LM70 pull the
 pin low.  This can't be shared with true SPI devices, but other 3-wire
 devices might share the same SI/SO pin.
 
diff --git a/Documentation/telephony/ixj.txt b/Documentation/telephony/ixj.txt
index 4fb314d..db94fb6 100644
--- a/Documentation/telephony/ixj.txt
+++ b/Documentation/telephony/ixj.txt
@@ -51,7 +51,7 @@ be removed to protect the rights of others.
 Specifically, very old Internet PhoneJACK cards have non-standard
 G.723.1 codecs (due to the early nature of the DSPs in those days).
 The auto-conversion code to bring those cards into compliance with
-todays standards is available as a binary only module to those people
+today's standards is available as a binary only module to those people
 needing it.  If you bought your card after 1997 or so, you are OK -
 it's only the very old cards that are affected.
 
diff --git a/Documentation/trace/ring-buffer-design.txt b/Documentation/trace/ring-buffer-design.txt
index d299ff3..7d350b4 100644
--- a/Documentation/trace/ring-buffer-design.txt
+++ b/Documentation/trace/ring-buffer-design.txt
@@ -237,7 +237,7 @@ with the previous write.
       |written  |
       +---------+
       |written  |
-      +---------+  <--- next positon for write (current commit)
+      +---------+  <--- next position for write (current commit)
       | empty   |
       +---------+
 
diff --git a/Documentation/video4linux/README.pvrusb2 b/Documentation/video4linux/README.pvrusb2
index a747200..2137b58 100644
--- a/Documentation/video4linux/README.pvrusb2
+++ b/Documentation/video4linux/README.pvrusb2
@@ -172,7 +172,7 @@ Source file list / functional overview:
     to provide a streaming API usable by a read() system call style of
     I/O.  Right now this is the only layer on top of pvrusb2-io.[ch],
     however the underlying architecture here was intended to allow for
-    other styles of I/O to be implemented with additonal modules, like
+    other styles of I/O to be implemented with additional modules, like
     mmap()'ed buffers or something even more exotic.
 
   pvrusb2-main.c - This is the top level of the driver.  Module level
diff --git a/Documentation/video4linux/bttv/README b/Documentation/video4linux/bttv/README
index 3a367cd..7cbf4fb 100644
--- a/Documentation/video4linux/bttv/README
+++ b/Documentation/video4linux/bttv/README
@@ -70,7 +70,7 @@ If you have trouble with some specific TV card, try to ask there
 instead of mailing me directly.  The chance that someone with the
 same card listens there is much higher...
 
-For problems with sound:  There are alot of different systems used
+For problems with sound:  There are a lot of different systems used
 for TV sound all over the world.  And there are also different chips
 which decode the audio signal.  Reports about sound problems ("stereo
 does'nt work") are pretty useless unless you include some details
diff --git a/Documentation/video4linux/bttv/README.freeze b/Documentation/video4linux/bttv/README.freeze
index 4259dcc..5eddfa0 100644
--- a/Documentation/video4linux/bttv/README.freeze
+++ b/Documentation/video4linux/bttv/README.freeze
@@ -33,7 +33,7 @@ state is stuck.
 
 I've seen reports that bttv 0.7.x crashes whereas 0.8.x works rock solid
 for some people.  Thus probably a small buglet left somewhere in bttv
-0.7.x.  I have no idea where exactly, it works stable for me and alot of
+0.7.x.  I have no idea where exactly, it works stable for me and a lot of
 other people.  But in case you have problems with the 0.7.x versions you
 can give 0.8.x a try ...
 
diff --git a/Documentation/video4linux/bttv/Sound-FAQ b/Documentation/video4linux/bttv/Sound-FAQ
index bc5e41d..395f6c6 100644
--- a/Documentation/video4linux/bttv/Sound-FAQ
+++ b/Documentation/video4linux/bttv/Sound-FAQ
@@ -2,7 +2,7 @@
 bttv and sound mini howto
 =========================
 
-There are alot of different bt848/849/878/879 based boards available.
+There are a lot of different bt848/849/878/879 based boards available.
 Making video work often is not a big deal, because this is handled
 completely by the bt8xx chip, which is common on all boards.  But
 sound is handled in slightly different ways on each board.
diff --git a/Documentation/video4linux/pxa_camera.txt b/Documentation/video4linux/pxa_camera.txt
index 4f6d0ca..51ed157 100644
--- a/Documentation/video4linux/pxa_camera.txt
+++ b/Documentation/video4linux/pxa_camera.txt
@@ -84,12 +84,12 @@ DMA usage
        transfer is not started. On "End Of Frame" interrupt, the irq handler
        starts the DMA chain.
      - capture of one videobuffer
-       The DMA chain starts transfering data into videobuffer RAM pages.
-       When all pages are transfered, the DMA irq is raised on "ENDINTR" status
+       The DMA chain starts transferring data into videobuffer RAM pages.
+       When all pages are transferred, the DMA irq is raised on "ENDINTR" status
      - finishing one videobuffer
        The DMA irq handler marks the videobuffer as "done", and removes it from
        the active running queue
-       Meanwhile, the next videobuffer (if there is one), is transfered by DMA
+       Meanwhile, the next videobuffer (if there is one), is transferred by DMA
      - finishing the last videobuffer
        On the DMA irq of the last videobuffer, the QCI is stopped.
 
@@ -101,7 +101,7 @@ DMA usage
 
      This structure is pointed by dma->sg_cpu.
      The descriptors are used as follows :
-      - desc-sg[i]: i-th descriptor, transfering the i-th sg
+      - desc-sg[i]: i-th descriptor, transferring the i-th sg
         element to the video buffer scatter gather
       - finisher: has ddadr=DADDR_STOP, dcmd=ENDIRQEN
       - linker: has ddadr= desc-sg[0] of next video buffer, dcmd=0
diff --git a/Documentation/video4linux/v4l2-framework.txt b/Documentation/video4linux/v4l2-framework.txt
index 3b15608..cf21f7a 100644
--- a/Documentation/video4linux/v4l2-framework.txt
+++ b/Documentation/video4linux/v4l2-framework.txt
@@ -343,7 +343,7 @@ ignored. If you want to check for errors use this:
 	err = v4l2_device_call_until_err(v4l2_dev, 0, core, g_chip_ident, &chip);
 
 Any error except -ENOIOCTLCMD will exit the loop with that error. If no
-errors (except -ENOIOCTLCMD) occured, then 0 is returned.
+errors (except -ENOIOCTLCMD) occurred, then 0 is returned.
 
 The second argument to both calls is a group ID. If 0, then all subdevs are
 called. If non-zero, then only those whose group ID match that value will
diff --git a/Documentation/vm/active_mm.txt b/Documentation/vm/active_mm.txt
index 4ee1f64..dbf4581 100644
--- a/Documentation/vm/active_mm.txt
+++ b/Documentation/vm/active_mm.txt
@@ -74,7 +74,7 @@ we have a user context", and is generally done by the page fault handler
 and things like that).
 
 Anyway, I put a pre-patch-2.3.13-1 on ftp.kernel.org just a moment ago,
-because it slightly changes the interfaces to accomodate the alpha (who
+because it slightly changes the interfaces to accommodate the alpha (who
 would have thought it, but the alpha actually ends up having one of the
 ugliest context switch codes - unlike the other architectures where the MM
 and register state is separate, the alpha PALcode joins the two, and you
diff --git a/Documentation/vm/hugetlbpage.txt b/Documentation/vm/hugetlbpage.txt
index 457634c..f8551b3 100644
--- a/Documentation/vm/hugetlbpage.txt
+++ b/Documentation/vm/hugetlbpage.txt
@@ -72,7 +72,7 @@ number of huge pages requested.  This is the most reliable method of
 allocating huge pages as memory has not yet become fragmented.
 
 Some platforms support multiple huge page sizes.  To allocate huge pages
-of a specific size, one must preceed the huge pages boot command parameters
+of a specific size, one must precede the huge pages boot command parameters
 with a huge page size selection parameter "hugepagesz=<size>".  <size> must
 be specified in bytes with optional scale suffix [kKmMgG].  The default huge
 page size may be selected with the "default_hugepagesz=<size>" boot parameter.
diff --git a/Documentation/vm/overcommit-accounting b/Documentation/vm/overcommit-accounting
index 21c7b1f..706d7ed 100644
--- a/Documentation/vm/overcommit-accounting
+++ b/Documentation/vm/overcommit-accounting
@@ -4,7 +4,7 @@ The Linux kernel supports the following overcommit handling modes
 		address space are refused. Used for a typical system. It
 		ensures a seriously wild allocation fails while allowing
 		overcommit to reduce swap usage.  root is allowed to 
-		allocate slighly more memory in this mode. This is the 
+		allocate slightly more memory in this mode. This is the 
 		default.
 
 1	-	Always overcommit. Appropriate for some scientific
diff --git a/Documentation/w1/slaves/w1_ds2423 b/Documentation/w1/slaves/w1_ds2423
index 90a65d2..3f98b50 100644
--- a/Documentation/w1/slaves/w1_ds2423
+++ b/Documentation/w1/slaves/w1_ds2423
@@ -21,8 +21,8 @@ value and associated ram buffer is outpputed to own line.
 
 Each lines will contain the values of 42 bytes read from the counter and
 memory page along the crc=YES or NO for indicating whether the read operation
-was successfull and CRC matched.
-If the operation was successfull, there is also in the end of each line
+was successful and CRC matched.
+If the operation was successful, there is also in the end of each line
 a counter value expressed as an integer after c=
 
 Meaning of 42 bytes represented is following:
@@ -34,7 +34,7 @@ Meaning of 42 bytes represented is following:
  - crc=YES/NO indicating whether read was ok and crc matched
  - c=<int> current counter value
 
-example from the successfull read:
+example from the successful read:
 00 02 00 00 00 00 00 00 00 6d 38 00 ff ff 00 00 fe ff 00 00 ff ff 00 00 ff ff 00 00 ff ff 00 00 ff ff 00 00 ff ff 00 00 ff ff crc=YES c=2
 00 02 00 00 00 00 00 00 00 e0 1f 00 ff ff 00 00 ff ff 00 00 ff ff 00 00 ff ff 00 00 ff ff 00 00 ff ff 00 00 ff ff 00 00 ff ff crc=YES c=2
 00 29 c6 5d 18 00 00 00 00 04 37 00 ff ff 00 00 ff ff 00 00 ff ff 00 00 ff ff 00 00 ff ff 00 00 ff ff 00 00 ff ff 00 00 ff ff crc=YES c=408798761
diff --git a/Documentation/w1/w1.netlink b/Documentation/w1/w1.netlink
index 804445f..f59a319 100644
--- a/Documentation/w1/w1.netlink
+++ b/Documentation/w1/w1.netlink
@@ -81,7 +81,7 @@ which will contain list of all registered master ids in the following
 format:
 
 	cn_msg (CN_W1_IDX.CN_W1_VAL as id, len is equal to sizeof(struct
-	w1_netlink_msg) plus number of masters multipled by 4)
+	w1_netlink_msg) plus number of masters multiplied by 4)
 	w1_netlink_msg (type: W1_LIST_MASTERS, len is equal to
 		number of masters multiplied by 4 (u32 size))
 	id0 ... idN
diff --git a/Documentation/watchdog/hpwdt.txt b/Documentation/watchdog/hpwdt.txt
index 9c24d5f..9488078 100644
--- a/Documentation/watchdog/hpwdt.txt
+++ b/Documentation/watchdog/hpwdt.txt
@@ -8,7 +8,7 @@ Last reviewed: 06/02/2009
  The HP iLO2 NMI Watchdog driver is a kernel module that provides basic
  watchdog functionality and the added benefit of NMI sourcing. Both the
  watchdog functionality and the NMI sourcing capability need to be enabled
- by the user. Remember that the two modes are not dependant on one another.
+ by the user. Remember that the two modes are not dependent on one another.
  A user can have the NMI sourcing without the watchdog timer and vice-versa.
 
  Watchdog functionality is enabled like any other common watchdog driver. That
diff --git a/Makefile b/Makefile
index 8392b64..6770699 100644
--- a/Makefile
+++ b/Makefile
@@ -1,7 +1,7 @@
 VERSION = 2
 PATCHLEVEL = 6
 SUBLEVEL = 39
-EXTRAVERSION = -rc2
+EXTRAVERSION = -rc2-git2
 NAME = Flesh-Eating Bats with Fangs
 
 # *DOCUMENTATION*
diff --git a/arch/alpha/include/asm/elf.h b/arch/alpha/include/asm/elf.h
index 9baae8a..da5449e 100644
--- a/arch/alpha/include/asm/elf.h
+++ b/arch/alpha/include/asm/elf.h
@@ -101,7 +101,7 @@ typedef elf_fpreg_t elf_fpregset_t[ELF_NFPREG];
 
 #define ELF_PLAT_INIT(_r, load_addr)	_r->r0 = 0
 
-/* The registers are layed out in pt_regs for PAL and syscall
+/* The registers are laid out in pt_regs for PAL and syscall
    convenience.  Re-order them for the linear elf_gregset_t.  */
 
 struct pt_regs;
diff --git a/arch/alpha/kernel/core_lca.c b/arch/alpha/kernel/core_lca.c
index 4843f6e..cb2801c 100644
--- a/arch/alpha/kernel/core_lca.c
+++ b/arch/alpha/kernel/core_lca.c
@@ -133,7 +133,7 @@ conf_read(unsigned long addr)
 
 	local_irq_save(flags);
 
-	/* Reset status register to avoid loosing errors.  */
+	/* Reset status register to avoid losing errors.  */
 	stat0 = *(vulp)LCA_IOC_STAT0;
 	*(vulp)LCA_IOC_STAT0 = stat0;
 	mb();
@@ -170,7 +170,7 @@ conf_write(unsigned long addr, unsigned int value)
 
 	local_irq_save(flags);	/* avoid getting hit by machine check */
 
-	/* Reset status register to avoid loosing errors.  */
+	/* Reset status register to avoid losing errors.  */
 	stat0 = *(vulp)LCA_IOC_STAT0;
 	*(vulp)LCA_IOC_STAT0 = stat0;
 	mb();
diff --git a/arch/alpha/kernel/err_marvel.c b/arch/alpha/kernel/err_marvel.c
index 648ae88..ae54ad9 100644
--- a/arch/alpha/kernel/err_marvel.c
+++ b/arch/alpha/kernel/err_marvel.c
@@ -1027,7 +1027,7 @@ marvel_process_logout_frame(struct ev7_lf_subpackets *lf_subpackets, int print)
 	 * normal operation, dismiss them.
 	 *
 	 * Dismiss if:
-	 *	C_STAT		= 0x14 		(Error Reponse)
+	 *	C_STAT		= 0x14 		(Error Response)
 	 *	C_STS<3>	= 0    		(C_ADDR valid)
 	 *	C_ADDR<42>	= 1    		(I/O)
 	 *	C_ADDR<31:22>	= 111110xxb	(PCI Config space)
diff --git a/arch/alpha/lib/ev67-strrchr.S b/arch/alpha/lib/ev67-strrchr.S
index 3fd8bf4..dd0d8c6 100644
--- a/arch/alpha/lib/ev67-strrchr.S
+++ b/arch/alpha/lib/ev67-strrchr.S
@@ -82,7 +82,7 @@ $loop:
 $eos:
 	negq	t1, t4		# E : isolate first null byte match
 	and	t1, t4, t4	# E :
-	subq	t4, 1, t5	# E : build a mask of the bytes upto...
+	subq	t4, 1, t5	# E : build a mask of the bytes up to...
 	or	t4, t5, t4	# E : ... and including the null
 
 	and	t3, t4, t3	# E : mask out char matches after null
diff --git a/arch/alpha/lib/fls.c b/arch/alpha/lib/fls.c
index 32afaa3..ddd048c 100644
--- a/arch/alpha/lib/fls.c
+++ b/arch/alpha/lib/fls.c
@@ -6,7 +6,7 @@
 #include <linux/bitops.h>
 
 /* This is fls(x)-1, except zero is held to zero.  This allows most
-   efficent input into extbl, plus it allows easy handling of fls(0)=0.  */
+   efficient input into extbl, plus it allows easy handling of fls(0)=0.  */
 
 const unsigned char __flsm1_tab[256] = 
 {
diff --git a/arch/alpha/lib/strrchr.S b/arch/alpha/lib/strrchr.S
index 82cfd0a..1970dc0 100644
--- a/arch/alpha/lib/strrchr.S
+++ b/arch/alpha/lib/strrchr.S
@@ -54,7 +54,7 @@ $loop:
 $eos:
 	negq	t1, t4		# e0    : isolate first null byte match
 	and	t1, t4, t4	# e1    :
-	subq	t4, 1, t5	# e0    : build a mask of the bytes upto...
+	subq	t4, 1, t5	# e0    : build a mask of the bytes up to...
 	or	t4, t5, t4	# e1    : ... and including the null
 
 	and	t3, t4, t3	# e0    : mask out char matches after null
diff --git a/arch/alpha/oprofile/op_model_ev67.c b/arch/alpha/oprofile/op_model_ev67.c
index 7030208..5b9d178 100644
--- a/arch/alpha/oprofile/op_model_ev67.c
+++ b/arch/alpha/oprofile/op_model_ev67.c
@@ -192,7 +192,7 @@ ev67_handle_interrupt(unsigned long which, struct pt_regs *regs,
 		case TRAP_INVALID1:
 		case TRAP_INVALID2:
 		case TRAP_INVALID3:
-			/* Pipeline redirection ocurred. PMPC points
+			/* Pipeline redirection occurred. PMPC points
 			   to PALcode. Recognize ITB miss by PALcode
 			   offset address, and get actual PC from
 			   EXC_ADDR.  */
diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig
index 5b9f78b..fdc9d4d 100644
--- a/arch/arm/Kconfig
+++ b/arch/arm/Kconfig
@@ -694,7 +694,7 @@ config ARCH_S3C2410
 	  the Samsung SMDK2410 development board (and derivatives).
 
 	  Note, the S3C2416 and the S3C2450 are so close that they even share
-	  the same SoC ID code. This means that there is no seperate machine
+	  the same SoC ID code. This means that there is no separate machine
 	  directory (no arch/arm/mach-s3c2450) as the S3C2416 was first.
 
 config ARCH_S3C64XX
diff --git a/arch/arm/Kconfig-nommu b/arch/arm/Kconfig-nommu
index 901e6df..2cef8e1 100644
--- a/arch/arm/Kconfig-nommu
+++ b/arch/arm/Kconfig-nommu
@@ -34,7 +34,7 @@ config PROCESSOR_ID
 	  used instead of the auto-probing which utilizes the register.
 
 config REMAP_VECTORS_TO_RAM
-	bool 'Install vectors to the begining of RAM' if DRAM_BASE
+	bool 'Install vectors to the beginning of RAM' if DRAM_BASE
 	depends on DRAM_BASE
 	help
 	  The kernel needs to change the hardware exception vectors.
diff --git a/arch/arm/common/pl330.c b/arch/arm/common/pl330.c
index 8f0f86d..97912fa 100644
--- a/arch/arm/common/pl330.c
+++ b/arch/arm/common/pl330.c
@@ -1045,7 +1045,7 @@ static inline int _loop(unsigned dry_run, u8 buf[],
 	unsigned lcnt0, lcnt1, ljmp0, ljmp1;
 	struct _arg_LPEND lpend;
 
-	/* Max iterations possibile in DMALP is 256 */
+	/* Max iterations possible in DMALP is 256 */
 	if (*bursts >= 256*256) {
 		lcnt1 = 256;
 		lcnt0 = 256;
@@ -1446,7 +1446,7 @@ int pl330_update(const struct pl330_info *pi)
 	}
 
 	for (ev = 0; ev < pi->pcfg.num_events; ev++) {
-		if (val & (1 << ev)) { /* Event occured */
+		if (val & (1 << ev)) { /* Event occurred */
 			struct pl330_thread *thrd;
 			u32 inten = readl(regs + INTEN);
 			int active;
diff --git a/arch/arm/include/asm/fpstate.h b/arch/arm/include/asm/fpstate.h
index ee5e03e..3ad4c10 100644
--- a/arch/arm/include/asm/fpstate.h
+++ b/arch/arm/include/asm/fpstate.h
@@ -18,7 +18,7 @@
  * VFP storage area has:
  *  - FPEXC, FPSCR, FPINST and FPINST2.
  *  - 16 or 32 double precision data registers
- *  - an implementation-dependant word of state for FLDMX/FSTMX (pre-ARMv6)
+ *  - an implementation-dependent word of state for FLDMX/FSTMX (pre-ARMv6)
  * 
  *  FPEXC will always be non-zero once the VFP has been used in this process.
  */
diff --git a/arch/arm/include/asm/glue-cache.h b/arch/arm/include/asm/glue-cache.h
index c7afbc5..7e30874 100644
--- a/arch/arm/include/asm/glue-cache.h
+++ b/arch/arm/include/asm/glue-cache.h
@@ -126,7 +126,7 @@
 #endif
 
 #if !defined(_CACHE) && !defined(MULTI_CACHE)
-#error Unknown cache maintainence model
+#error Unknown cache maintenance model
 #endif
 
 #ifndef MULTI_CACHE
diff --git a/arch/arm/include/asm/glue.h b/arch/arm/include/asm/glue.h
index 0ec35d1..fbf71d7 100644
--- a/arch/arm/include/asm/glue.h
+++ b/arch/arm/include/asm/glue.h
@@ -10,8 +10,8 @@
  *
  *  This file provides the glue to stick the processor-specific bits
  *  into the kernel in an efficient manner.  The idea is to use branches
- *  when we're only targetting one class of TLB, or indirect calls
- *  when we're targetting multiple classes of TLBs.
+ *  when we're only targeting one class of TLB, or indirect calls
+ *  when we're targeting multiple classes of TLBs.
  */
 #ifdef __KERNEL__
 
diff --git a/arch/arm/include/asm/hardware/pl080.h b/arch/arm/include/asm/hardware/pl080.h
index f35b86e..e4a04e4 100644
--- a/arch/arm/include/asm/hardware/pl080.h
+++ b/arch/arm/include/asm/hardware/pl080.h
@@ -16,7 +16,7 @@
  * make it not entierly compatible with the PL080 specification from
  * ARM. When in doubt, check the Samsung documentation first.
  *
- * The Samsung defines are PL080S, and add an extra controll register,
+ * The Samsung defines are PL080S, and add an extra control register,
  * the ability to move more than 2^11 counts of data and some extra
  * OneNAND features.
 */
diff --git a/arch/arm/include/asm/system.h b/arch/arm/include/asm/system.h
index 9a87823..885be09 100644
--- a/arch/arm/include/asm/system.h
+++ b/arch/arm/include/asm/system.h
@@ -249,7 +249,7 @@ do {									\
  * cache totally.  This means that the cache becomes inconsistent, and,
  * since we use normal loads/stores as well, this is really bad.
  * Typically, this causes oopsen in filp_close, but could have other,
- * more disasterous effects.  There are two work-arounds:
+ * more disastrous effects.  There are two work-arounds:
  *  1. Disable interrupts and emulate the atomic swap
  *  2. Clean the cache, perform atomic swap, flush the cache
  *
diff --git a/arch/arm/include/asm/ucontext.h b/arch/arm/include/asm/ucontext.h
index 47f023a..14749ae 100644
--- a/arch/arm/include/asm/ucontext.h
+++ b/arch/arm/include/asm/ucontext.h
@@ -47,7 +47,7 @@ struct crunch_sigframe {
 #endif
 
 #ifdef CONFIG_IWMMXT
-/* iwmmxt_area is 0x98 bytes long, preceeded by 8 bytes of signature */
+/* iwmmxt_area is 0x98 bytes long, preceded by 8 bytes of signature */
 #define IWMMXT_MAGIC		0x12ef842a
 #define IWMMXT_STORAGE_SIZE	(IWMMXT_SIZE + 8)
 
diff --git a/arch/arm/kernel/swp_emulate.c b/arch/arm/kernel/swp_emulate.c
index 7a57609..40ee7e5 100644
--- a/arch/arm/kernel/swp_emulate.c
+++ b/arch/arm/kernel/swp_emulate.c
@@ -158,7 +158,7 @@ static int emulate_swpX(unsigned int address, unsigned int *data,
 
 	if (res == 0) {
 		/*
-		 * Barrier also required between aquiring a lock for a
+		 * Barrier also required between acquiring a lock for a
 		 * protected resource and accessing the resource. Inserted for
 		 * same reason as above.
 		 */
diff --git a/arch/arm/mach-at91/board-carmeva.c b/arch/arm/mach-at91/board-carmeva.c
index 2e74a19..295e1e7 100644
--- a/arch/arm/mach-at91/board-carmeva.c
+++ b/arch/arm/mach-at91/board-carmeva.c
@@ -76,7 +76,7 @@ static struct at91_udc_data __initdata carmeva_udc_data = {
 	.pullup_pin	= AT91_PIN_PD9,
 };
 
-/* FIXME: user dependant */
+/* FIXME: user dependent */
 // static struct at91_cf_data __initdata carmeva_cf_data = {
 //	.det_pin	= AT91_PIN_PB0,
 //	.rst_pin	= AT91_PIN_PC5,
diff --git a/arch/arm/mach-at91/include/mach/at91_mci.h b/arch/arm/mach-at91/include/mach/at91_mci.h
index 27ac6f5..02182c1 100644
--- a/arch/arm/mach-at91/include/mach/at91_mci.h
+++ b/arch/arm/mach-at91/include/mach/at91_mci.h
@@ -102,7 +102,7 @@
 #define		AT91_MCI_RDIRE		(1 << 17)	/* Response Direction Error */
 #define		AT91_MCI_RCRCE		(1 << 18)	/* Response CRC Error */
 #define		AT91_MCI_RENDE		(1 << 19)	/* Response End Bit Error */
-#define		AT91_MCI_RTOE		(1 << 20)	/* Reponse Time-out Error */
+#define		AT91_MCI_RTOE		(1 << 20)	/* Response Time-out Error */
 #define		AT91_MCI_DCRCE		(1 << 21)	/* Data CRC Error */
 #define		AT91_MCI_DTOE		(1 << 22)	/* Data Time-out Error */
 #define		AT91_MCI_OVRE		(1 << 30)	/* Overrun */
diff --git a/arch/arm/mach-at91/include/mach/gpio.h b/arch/arm/mach-at91/include/mach/gpio.h
index ddeb645..056dc66 100644
--- a/arch/arm/mach-at91/include/mach/gpio.h
+++ b/arch/arm/mach-at91/include/mach/gpio.h
@@ -208,7 +208,7 @@ extern void at91_gpio_resume(void);
 
 /*-------------------------------------------------------------------------*/
 
-/* wrappers for "new style" GPIO calls. the old AT91-specfic ones should
+/* wrappers for "new style" GPIO calls. the old AT91-specific ones should
  * eventually be removed (along with this errno.h inclusion), and the
  * gpio request/free calls should probably be implemented.
  */
diff --git a/arch/arm/mach-bcmring/csp/dmac/dmacHw_extra.c b/arch/arm/mach-bcmring/csp/dmac/dmacHw_extra.c
index 77f84b4..a1f3283 100644
--- a/arch/arm/mach-bcmring/csp/dmac/dmacHw_extra.c
+++ b/arch/arm/mach-bcmring/csp/dmac/dmacHw_extra.c
@@ -551,7 +551,7 @@ int dmacHw_calculateDescriptorCount(dmacHw_CONFIG_t *pConfig,	/*   [ IN ] Config
 
 /****************************************************************************/
 /**
-*  @brief   Check the existance of pending descriptor
+*  @brief   Check the existence of pending descriptor
 *
 *  This function confirmes if there is any pending descriptor in the chain
 *  to program the channel
@@ -775,7 +775,7 @@ int dmacHw_setVariableDataDescriptor(dmacHw_HANDLE_t handle,	/*   [ IN ] DMA Cha
 /**
 *  @brief   Read data DMAed to memory
 *
-*  This function will read data that has been DMAed to memory while transfering from:
+*  This function will read data that has been DMAed to memory while transferring from:
 *          - Memory to memory
 *          - Peripheral to memory
 *
@@ -941,7 +941,7 @@ int dmacHw_setControlDescriptor(dmacHw_CONFIG_t *pConfig,	/*   [ IN ] Configurat
 /**
 *  @brief   Sets channel specific user data
 *
-*  This function associates user data to a specif DMA channel
+*  This function associates user data to a specific DMA channel
 *
 */
 /****************************************************************************/
diff --git a/arch/arm/mach-bcmring/dma.c b/arch/arm/mach-bcmring/dma.c
index 8d1baf3..d87ad30 100644
--- a/arch/arm/mach-bcmring/dma.c
+++ b/arch/arm/mach-bcmring/dma.c
@@ -629,7 +629,7 @@ EXPORT_SYMBOL(dma_get_device_descriptor_ring);
 *   Configures a DMA channel.
 *
 *   @return
-*       >= 0    - Initialization was successfull.
+*       >= 0    - Initialization was successful.
 *
 *       -EBUSY  - Device is currently being used.
 *       -ENODEV - Device handed in is invalid.
@@ -673,7 +673,7 @@ static int ConfigChannel(DMA_Handle_t handle)
 /**
 *   Initializes all of the data structures associated with the DMA.
 *   @return
-*       >= 0    - Initialization was successfull.
+*       >= 0    - Initialization was successful.
 *
 *       -EBUSY  - Device is currently being used.
 *       -ENODEV - Device handed in is invalid.
diff --git a/arch/arm/mach-bcmring/include/csp/dmacHw.h b/arch/arm/mach-bcmring/include/csp/dmacHw.h
index 6c8da2b..e6a1dc4 100644
--- a/arch/arm/mach-bcmring/include/csp/dmacHw.h
+++ b/arch/arm/mach-bcmring/include/csp/dmacHw.h
@@ -362,7 +362,7 @@ int dmacHw_setControlDescriptor(dmacHw_CONFIG_t *pConfig,	/*  [ IN ] Configurati
 /**
 *  @brief   Read data DMA transferred to memory
 *
-*  This function will read data that has been DMAed to memory while transfering from:
+*  This function will read data that has been DMAed to memory while transferring from:
 *          - Memory to memory
 *          - Peripheral to memory
 *
@@ -446,7 +446,7 @@ void dmacHw_stopTransfer(dmacHw_HANDLE_t handle	/*   [ IN ] DMA Channel handle *
 
 /****************************************************************************/
 /**
-*  @brief   Check the existance of pending descriptor
+*  @brief   Check the existence of pending descriptor
 *
 *  This function confirmes if there is any pending descriptor in the chain
 *  to program the channel
@@ -542,7 +542,7 @@ dmacHw_HANDLE_t dmacHw_getInterruptSource(void);
 /**
 *  @brief   Sets channel specific user data
 *
-*  This function associates user data to a specif DMA channel
+*  This function associates user data to a specific DMA channel
 *
 */
 /****************************************************************************/
diff --git a/arch/arm/mach-bcmring/include/mach/csp/chipcHw_def.h b/arch/arm/mach-bcmring/include/mach/csp/chipcHw_def.h
index 70eaea8..1619733 100644
--- a/arch/arm/mach-bcmring/include/mach/csp/chipcHw_def.h
+++ b/arch/arm/mach-bcmring/include/mach/csp/chipcHw_def.h
@@ -180,7 +180,7 @@ typedef enum {
 
 #define chipcHw_XTAL_FREQ_Hz                    25000000	/* Reference clock frequency in Hz */
 
-/* Programable pin defines */
+/* Programmable pin defines */
 #define chipcHw_PIN_GPIO(n)                     ((((n) >= 0) && ((n) < (chipcHw_GPIO_COUNT))) ? (n) : 0xFFFFFFFF)
 									     /* GPIO pin 0 - 60 */
 #define chipcHw_PIN_UARTTXD                     (chipcHw_GPIO_COUNT + 0)	/* UART Transmit */
diff --git a/arch/arm/mach-bcmring/include/mach/csp/chipcHw_inline.h b/arch/arm/mach-bcmring/include/mach/csp/chipcHw_inline.h
index c78833a..03238c2 100644
--- a/arch/arm/mach-bcmring/include/mach/csp/chipcHw_inline.h
+++ b/arch/arm/mach-bcmring/include/mach/csp/chipcHw_inline.h
@@ -832,7 +832,7 @@ static inline void chipcHw_setUsbDevice(void)
 
 /****************************************************************************/
 /**
-*  @brief   Lower layer funtion to enable/disable a clock of a certain device
+*  @brief   Lower layer function to enable/disable a clock of a certain device
 *
 *  This function enables/disables a core clock
 *
diff --git a/arch/arm/mach-bcmring/include/mach/csp/intcHw_reg.h b/arch/arm/mach-bcmring/include/mach/csp/intcHw_reg.h
index e01fc46..0aeb6a6 100644
--- a/arch/arm/mach-bcmring/include/mach/csp/intcHw_reg.h
+++ b/arch/arm/mach-bcmring/include/mach/csp/intcHw_reg.h
@@ -109,9 +109,9 @@
 #define INTCHW_INTC0_DMA0C0               (1<<INTCHW_INTC0_DMA0C0_BITNUM)
 
 /* INTC1 - interrupt controller 1 */
-#define INTCHW_INTC1_DDRVPMP_BITNUM       27	/* DDR and VPM PLL clock phase relationship interupt (Not for A0) */
+#define INTCHW_INTC1_DDRVPMP_BITNUM       27	/* DDR and VPM PLL clock phase relationship interrupt (Not for A0) */
 #define INTCHW_INTC1_DDRVPMT_BITNUM       26	/* DDR and VPM HW phase align timeout interrupt (Not for A0) */
-#define INTCHW_INTC1_DDRP_BITNUM          26	/* DDR and PLL clock phase relationship interupt (For A0 only)) */
+#define INTCHW_INTC1_DDRP_BITNUM          26	/* DDR and PLL clock phase relationship interrupt (For A0 only)) */
 #define INTCHW_INTC1_RTC2_BITNUM          25	/* Real time clock tamper interrupt */
 #define INTCHW_INTC1_VDEC_BITNUM          24	/* Hantro Video Decoder interrupt */
 /* Bits 13-23 are non-secure versions of the corresponding secure bits in SINTC bits 0-10. */
diff --git a/arch/arm/mach-bcmring/include/mach/reg_umi.h b/arch/arm/mach-bcmring/include/mach/reg_umi.h
index 06a3554..0992842 100644
--- a/arch/arm/mach-bcmring/include/mach/reg_umi.h
+++ b/arch/arm/mach-bcmring/include/mach/reg_umi.h
@@ -88,7 +88,7 @@
 /* REG_UMI_FLASH0/1/2_TCR, REG_UMI_SRAM0/1_TCR bits */
 /* Enable wait pin during burst write or read */
 #define REG_UMI_TCR_WAITEN              0x80000000
-/* Enable mem ctrlr to work iwth ext mem of lower freq than AHB clk */
+/* Enable mem ctrlr to work with ext mem of lower freq than AHB clk */
 #define REG_UMI_TCR_LOWFREQ             0x40000000
 /* 1=synch write, 0=async write */
 #define REG_UMI_TCR_MEMTYPE_SYNCWRITE   0x20000000
diff --git a/arch/arm/mach-davinci/board-neuros-osd2.c b/arch/arm/mach-davinci/board-neuros-osd2.c
index 6c389ff..3e7be2d 100644
--- a/arch/arm/mach-davinci/board-neuros-osd2.c
+++ b/arch/arm/mach-davinci/board-neuros-osd2.c
@@ -11,7 +11,7 @@
  * DM644X-EVM board. It has:
  * 	DM6446M02 module with 256MB NAND, 256MB RAM, TLV320AIC32 AIC,
  * 	USB, Ethernet, SD/MMC, UART, THS8200, TVP7000 for video.
- * 	Additionaly realtime clock, IR remote control receiver,
+ * 	Additionally realtime clock, IR remote control receiver,
  * 	IR Blaster based on MSP430 (firmware although is different
  * 	from used in DM644X-EVM), internal ATA-6 3.5 HDD drive
  * 	with PATA interface, two muxed red-green leds.
diff --git a/arch/arm/mach-davinci/cpufreq.c b/arch/arm/mach-davinci/cpufreq.c
index 4a68c2b..0a95be1 100644
--- a/arch/arm/mach-davinci/cpufreq.c
+++ b/arch/arm/mach-davinci/cpufreq.c
@@ -167,7 +167,7 @@ static int davinci_cpu_init(struct cpufreq_policy *policy)
 	/*
 	 * Time measurement across the target() function yields ~1500-1800us
 	 * time taken with no drivers on notification list.
-	 * Setting the latency to 2000 us to accomodate addition of drivers
+	 * Setting the latency to 2000 us to accommodate addition of drivers
 	 * to pre/post change notification list.
 	 */
 	policy->cpuinfo.transition_latency = 2000 * 1000;
diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index 68fe4c2..b95b919 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -1123,7 +1123,7 @@ void __init da850_init(void)
 	 * This helps keeping the peripherals on this domain insulated
 	 * from CPU frequency changes caused by DVFS. The firmware sets
 	 * both PLL0 and PLL1 to the same frequency so, there should not
-	 * be any noticible change even in non-DVFS use cases.
+	 * be any noticeable change even in non-DVFS use cases.
 	 */
 	da850_set_async3_src(1);
 
diff --git a/arch/arm/mach-davinci/dm355.c b/arch/arm/mach-davinci/dm355.c
index 76364d1..f680122 100644
--- a/arch/arm/mach-davinci/dm355.c
+++ b/arch/arm/mach-davinci/dm355.c
@@ -314,7 +314,7 @@ static struct clk timer2_clk = {
 	.name = "timer2",
 	.parent = &pll1_aux_clk,
 	.lpsc = DAVINCI_LPSC_TIMER2,
-	.usecount = 1,              /* REVISIT: why cant' this be disabled? */
+	.usecount = 1,              /* REVISIT: why can't' this be disabled? */
 };
 
 static struct clk timer3_clk = {
diff --git a/arch/arm/mach-davinci/dm644x.c b/arch/arm/mach-davinci/dm644x.c
index 9a2376b..5f8a654 100644
--- a/arch/arm/mach-davinci/dm644x.c
+++ b/arch/arm/mach-davinci/dm644x.c
@@ -274,7 +274,7 @@ static struct clk timer2_clk = {
 	.name = "timer2",
 	.parent = &pll1_aux_clk,
 	.lpsc = DAVINCI_LPSC_TIMER2,
-	.usecount = 1,              /* REVISIT: why cant' this be disabled? */
+	.usecount = 1,              /* REVISIT: why can't' this be disabled? */
 };
 
 static struct clk_lookup dm644x_clks[] = {
diff --git a/arch/arm/mach-davinci/include/mach/cputype.h b/arch/arm/mach-davinci/include/mach/cputype.h
index cea6b89..957fb87 100644
--- a/arch/arm/mach-davinci/include/mach/cputype.h
+++ b/arch/arm/mach-davinci/include/mach/cputype.h
@@ -4,7 +4,7 @@
  * Author: Kevin Hilman, Deep Root Systems, LLC
  *
  * Defines the cpu_is_*() macros for runtime detection of DaVinci
- * device type.  In addtion, if support for a given device is not
+ * device type.  In addition, if support for a given device is not
  * compiled in to the kernel, the macros return 0 so that
  * resulting code can be optimized out.
  *
diff --git a/arch/arm/mach-ep93xx/gpio.c b/arch/arm/mach-ep93xx/gpio.c
index 180b8a9..a5a9ff7 100644
--- a/arch/arm/mach-ep93xx/gpio.c
+++ b/arch/arm/mach-ep93xx/gpio.c
@@ -101,7 +101,7 @@ static void ep93xx_gpio_ab_irq_handler(unsigned int irq, struct irq_desc *desc)
 static void ep93xx_gpio_f_irq_handler(unsigned int irq, struct irq_desc *desc)
 {
 	/*
-	 * map discontiguous hw irq range to continous sw irq range:
+	 * map discontiguous hw irq range to continuous sw irq range:
 	 *
 	 *  IRQ_EP93XX_GPIO{0..7}MUX -> gpio_to_irq(EP93XX_GPIO_LINE_F({0..7})
 	 */
diff --git a/arch/arm/mach-exynos4/include/mach/gpio.h b/arch/arm/mach-exynos4/include/mach/gpio.h
index 939728b..be9266b 100644
--- a/arch/arm/mach-exynos4/include/mach/gpio.h
+++ b/arch/arm/mach-exynos4/include/mach/gpio.h
@@ -18,7 +18,7 @@
 #define gpio_cansleep	__gpio_cansleep
 #define gpio_to_irq	__gpio_to_irq
 
-/* Practically, GPIO banks upto GPZ are the configurable gpio banks */
+/* Practically, GPIO banks up to GPZ are the configurable gpio banks */
 
 /* GPIO bank sizes */
 #define EXYNOS4_GPIO_A0_NR	(8)
diff --git a/arch/arm/mach-exynos4/mct.c b/arch/arm/mach-exynos4/mct.c
index af82a8f..14ac10b 100644
--- a/arch/arm/mach-exynos4/mct.c
+++ b/arch/arm/mach-exynos4/mct.c
@@ -276,7 +276,7 @@ static void exynos4_mct_tick_start(unsigned long cycles,
 	/* update interrupt count buffer */
 	exynos4_mct_write(tmp, mevt->base + MCT_L_ICNTB_OFFSET);
 
-	/* enable MCT tick interupt */
+	/* enable MCT tick interrupt */
 	exynos4_mct_write(0x1, mevt->base + MCT_L_INT_ENB_OFFSET);
 
 	tmp = __raw_readl(mevt->base + MCT_L_TCON_OFFSET);
diff --git a/arch/arm/mach-exynos4/setup-sdhci-gpio.c b/arch/arm/mach-exynos4/setup-sdhci-gpio.c
index 1b3d3a2d..e8d08bf 100644
--- a/arch/arm/mach-exynos4/setup-sdhci-gpio.c
+++ b/arch/arm/mach-exynos4/setup-sdhci-gpio.c
@@ -38,14 +38,14 @@ void exynos4_setup_sdhci0_cfg_gpio(struct platform_device *dev, int width)
 	switch (width) {
 	case 8:
 		for (gpio = EXYNOS4_GPK1(3); gpio <= EXYNOS4_GPK1(6); gpio++) {
-			/* Data pin GPK1[3:6] to special-funtion 3 */
+			/* Data pin GPK1[3:6] to special-function 3 */
 			s3c_gpio_cfgpin(gpio, S3C_GPIO_SFN(3));
 			s3c_gpio_setpull(gpio, S3C_GPIO_PULL_UP);
 			s5p_gpio_set_drvstr(gpio, S5P_GPIO_DRVSTR_LV4);
 		}
 	case 4:
 		for (gpio = EXYNOS4_GPK0(3); gpio <= EXYNOS4_GPK0(6); gpio++) {
-			/* Data pin GPK0[3:6] to special-funtion 2 */
+			/* Data pin GPK0[3:6] to special-function 2 */
 			s3c_gpio_cfgpin(gpio, S3C_GPIO_SFN(2));
 			s3c_gpio_setpull(gpio, S3C_GPIO_PULL_UP);
 			s5p_gpio_set_drvstr(gpio, S5P_GPIO_DRVSTR_LV4);
diff --git a/arch/arm/mach-exynos4/setup-sdhci.c b/arch/arm/mach-exynos4/setup-sdhci.c
index 85f9433..1e83f8c 100644
--- a/arch/arm/mach-exynos4/setup-sdhci.c
+++ b/arch/arm/mach-exynos4/setup-sdhci.c
@@ -35,7 +35,7 @@ void exynos4_setup_sdhci_cfg_card(struct platform_device *dev, void __iomem *r,
 {
 	u32 ctrl2, ctrl3;
 
-	/* don't need to alter anything acording to card-type */
+	/* don't need to alter anything according to card-type */
 
 	ctrl2 = readl(r + S3C_SDHCI_CONTROL2);
 
diff --git a/arch/arm/mach-iop13xx/pci.c b/arch/arm/mach-iop13xx/pci.c
index 773ea0c..ba3dae3 100644
--- a/arch/arm/mach-iop13xx/pci.c
+++ b/arch/arm/mach-iop13xx/pci.c
@@ -225,7 +225,7 @@ static u32 iop13xx_atue_cfg_address(struct pci_bus *bus, int devfn, int where)
 /* This routine checks the status of the last configuration cycle.  If an error
  * was detected it returns >0, else it returns a 0.  The errors being checked
  * are parity, master abort, target abort (master and target).  These types of
- * errors occure during a config cycle where there is no device, like during
+ * errors occur during a config cycle where there is no device, like during
  * the discovery stage.
  */
 static int iop13xx_atux_pci_status(int clear)
@@ -332,7 +332,7 @@ static struct pci_ops iop13xx_atux_ops = {
 /* This routine checks the status of the last configuration cycle.  If an error
  * was detected it returns >0, else it returns a 0.  The errors being checked
  * are parity, master abort, target abort (master and target).  These types of
- * errors occure during a config cycle where there is no device, like during
+ * errors occur during a config cycle where there is no device, like during
  * the discovery stage.
  */
 static int iop13xx_atue_pci_status(int clear)
diff --git a/arch/arm/mach-kirkwood/tsx1x-common.c b/arch/arm/mach-kirkwood/tsx1x-common.c
index f781164..24294b2 100644
--- a/arch/arm/mach-kirkwood/tsx1x-common.c
+++ b/arch/arm/mach-kirkwood/tsx1x-common.c
@@ -15,7 +15,7 @@
 
 /****************************************************************************
  * 16 MiB NOR flash. The struct mtd_partition is not in the same order as the
- *     partitions on the device because we want to keep compatability with
+ *     partitions on the device because we want to keep compatibility with
  *     the QNAP firmware.
  * Layout as used by QNAP:
  *  0x00000000-0x00080000 : "U-Boot"
diff --git a/arch/arm/mach-lpc32xx/pm.c b/arch/arm/mach-lpc32xx/pm.c
index e76d41b..b9c8059 100644
--- a/arch/arm/mach-lpc32xx/pm.c
+++ b/arch/arm/mach-lpc32xx/pm.c
@@ -41,7 +41,7 @@
  * DRAM clocking and refresh are slightly different for systems with DDR
  * DRAM or regular SDRAM devices. If SDRAM is used in the system, the
  * SDRAM will still be accessible in direct-run mode. In DDR based systems,
- * a transistion to direct-run mode will stop all DDR accesses (no clocks).
+ * a transition to direct-run mode will stop all DDR accesses (no clocks).
  * Because of this, the code to switch power modes and the code to enter
  * and exit DRAM self-refresh modes must not be executed in DRAM. A small
  * section of IRAM is used instead for this.
diff --git a/arch/arm/mach-mmp/time.c b/arch/arm/mach-mmp/time.c
index aeb9ae2..99833b9 100644
--- a/arch/arm/mach-mmp/time.c
+++ b/arch/arm/mach-mmp/time.c
@@ -9,7 +9,7 @@
  *   2008-04-11: Jason Chagas <Jason.chagas@marvell.com>
  *   2008-10-08: Bin Yang <bin.yang@marvell.com>
  *
- * The timers module actually includes three timers, each timer with upto
+ * The timers module actually includes three timers, each timer with up to
  * three match comparators. Timer #0 is used here in free-running mode as
  * the clock source, and match comparator #1 used as clock event device.
  *
diff --git a/arch/arm/mach-msm/acpuclock-arm11.c b/arch/arm/mach-msm/acpuclock-arm11.c
index 7ffbd98..805d4ee 100644
--- a/arch/arm/mach-msm/acpuclock-arm11.c
+++ b/arch/arm/mach-msm/acpuclock-arm11.c
@@ -343,7 +343,7 @@ int acpuclk_set_rate(unsigned long rate, int for_power_collapse)
 		}
 	}
 
-	/* Set wait states for CPU inbetween frequency changes */
+	/* Set wait states for CPU between frequency changes */
 	reg_clkctl = readl(A11S_CLK_CNTL_ADDR);
 	reg_clkctl |= (100 << 16); /* set WT_ST_CNT */
 	writel(reg_clkctl, A11S_CLK_CNTL_ADDR);
diff --git a/arch/arm/mach-msm/scm.c b/arch/arm/mach-msm/scm.c
index cfa808d..232f97a 100644
--- a/arch/arm/mach-msm/scm.c
+++ b/arch/arm/mach-msm/scm.c
@@ -46,7 +46,7 @@ static DEFINE_MUTEX(scm_lock);
  * @id: command to be executed
  * @buf: buffer returned from scm_get_command_buffer()
  *
- * An SCM command is layed out in memory as follows:
+ * An SCM command is laid out in memory as follows:
  *
  *	------------------- <--- struct scm_command
  *	| command header  |
diff --git a/arch/arm/mach-omap1/ams-delta-fiq-handler.S b/arch/arm/mach-omap1/ams-delta-fiq-handler.S
index 927d5a1..c1c5fb6 100644
--- a/arch/arm/mach-omap1/ams-delta-fiq-handler.S
+++ b/arch/arm/mach-omap1/ams-delta-fiq-handler.S
@@ -79,7 +79,7 @@
 
 
 /*
- * Register useage
+ * Register usage
  * r8  - temporary
  * r9  - the driver buffer
  * r10 - temporary
diff --git a/arch/arm/mach-omap1/board-sx1.c b/arch/arm/mach-omap1/board-sx1.c
index d41fe2d..0ad781d 100644
--- a/arch/arm/mach-omap1/board-sx1.c
+++ b/arch/arm/mach-omap1/board-sx1.c
@@ -399,7 +399,7 @@ static void __init omap_sx1_init(void)
 	sx1_mmc_init();
 
 	/* turn on USB power */
-	/* sx1_setusbpower(1); cant do it here because i2c is not ready */
+	/* sx1_setusbpower(1); can't do it here because i2c is not ready */
 	gpio_request(1, "A_IRDA_OFF");
 	gpio_request(11, "A_SWITCH");
 	gpio_request(15, "A_USB_ON");
diff --git a/arch/arm/mach-omap1/devices.c b/arch/arm/mach-omap1/devices.c
index b0f4c23..36f26c3 100644
--- a/arch/arm/mach-omap1/devices.c
+++ b/arch/arm/mach-omap1/devices.c
@@ -281,7 +281,7 @@ static inline void omap_init_audio(void) {}
  * Claiming GPIOs, and setting their direction and initial values, is the
  * responsibility of the device drivers.  So is responding to probe().
  *
- * Board-specific knowlege like creating devices or pin setup is to be
+ * Board-specific knowledge like creating devices or pin setup is to be
  * kept out of drivers as much as possible.  In particular, pin setup
  * may be handled by the boot loader, and drivers should expect it will
  * normally have been done by the time they're probed.
diff --git a/arch/arm/mach-omap1/include/mach/ams-delta-fiq.h b/arch/arm/mach-omap1/include/mach/ams-delta-fiq.h
index 7a2df29..23eed00 100644
--- a/arch/arm/mach-omap1/include/mach/ams-delta-fiq.h
+++ b/arch/arm/mach-omap1/include/mach/ams-delta-fiq.h
@@ -31,7 +31,7 @@
 #endif
 
 /*
- * These are the offsets from the begining of the fiq_buffer. They are put here
+ * These are the offsets from the beginning of the fiq_buffer. They are put here
  * since the buffer and header need to be accessed by drivers servicing devices
  * which generate GPIO interrupts - e.g. keyboard, modem, hook switch.
  */
diff --git a/arch/arm/mach-omap2/board-igep0020.c b/arch/arm/mach-omap2/board-igep0020.c
index 5f8a2fd..34cf982 100644
--- a/arch/arm/mach-omap2/board-igep0020.c
+++ b/arch/arm/mach-omap2/board-igep0020.c
@@ -696,7 +696,7 @@ static void __init igep2_init(void)
 	igep2_init_smsc911x();
 
 	/*
-	 * WLAN-BT combo module from MuRata wich has a Marvell WLAN
+	 * WLAN-BT combo module from MuRata which has a Marvell WLAN
 	 * (88W8686) + CSR Bluetooth chipset. Uses SDIO interface.
 	 */
 	igep2_wlan_bt_init();
diff --git a/arch/arm/mach-omap2/board-igep0030.c b/arch/arm/mach-omap2/board-igep0030.c
index b10db0e..2cf86c3 100644
--- a/arch/arm/mach-omap2/board-igep0030.c
+++ b/arch/arm/mach-omap2/board-igep0030.c
@@ -440,7 +440,7 @@ static void __init igep3_init(void)
 	igep3_leds_init();
 
 	/*
-	 * WLAN-BT combo module from MuRata wich has a Marvell WLAN
+	 * WLAN-BT combo module from MuRata which has a Marvell WLAN
 	 * (88W8686) + CSR Bluetooth chipset. Uses SDIO interface.
 	 */
 	igep3_wifi_bt_init();
diff --git a/arch/arm/mach-omap2/clockdomain.c b/arch/arm/mach-omap2/clockdomain.c
index ab87854..6cb6c03 100644
--- a/arch/arm/mach-omap2/clockdomain.c
+++ b/arch/arm/mach-omap2/clockdomain.c
@@ -258,7 +258,7 @@ static void _resolve_clkdm_deps(struct clockdomain *clkdm,
  * clkdm_init - set up the clockdomain layer
  * @clkdms: optional pointer to an array of clockdomains to register
  * @init_autodeps: optional pointer to an array of autodeps to register
- * @custom_funcs: func pointers for arch specfic implementations
+ * @custom_funcs: func pointers for arch specific implementations
  *
  * Set up internal state.  If a pointer to an array of clockdomains
  * @clkdms was supplied, loop through the list of clockdomains,
diff --git a/arch/arm/mach-omap2/clockdomain.h b/arch/arm/mach-omap2/clockdomain.h
index 85b3dce..5823584 100644
--- a/arch/arm/mach-omap2/clockdomain.h
+++ b/arch/arm/mach-omap2/clockdomain.h
@@ -125,7 +125,7 @@ struct clockdomain {
 };
 
 /**
- * struct clkdm_ops - Arch specfic function implementations
+ * struct clkdm_ops - Arch specific function implementations
  * @clkdm_add_wkdep: Add a wakeup dependency between clk domains
  * @clkdm_del_wkdep: Delete a wakeup dependency between clk domains
  * @clkdm_read_wkdep: Read wakeup dependency state between clk domains
diff --git a/arch/arm/mach-omap2/cpuidle34xx.c b/arch/arm/mach-omap2/cpuidle34xx.c
index a44c523..1c240ef 100644
--- a/arch/arm/mach-omap2/cpuidle34xx.c
+++ b/arch/arm/mach-omap2/cpuidle34xx.c
@@ -297,8 +297,8 @@ DEFINE_PER_CPU(struct cpuidle_device, omap3_idle_dev);
 
 /**
  * omap3_cpuidle_update_states() - Update the cpuidle states
- * @mpu_deepest_state:	Enable states upto and including this for mpu domain
- * @core_deepest_state:	Enable states upto and including this for core domain
+ * @mpu_deepest_state:	Enable states up to and including this for mpu domain
+ * @core_deepest_state:	Enable states up to and including this for core domain
  *
  * This goes through the list of states available and enables and disables the
  * validity of C states based on deepest state that can be achieved for the
diff --git a/arch/arm/mach-omap2/devices.c b/arch/arm/mach-omap2/devices.c
index 84d1b73..7b85585 100644
--- a/arch/arm/mach-omap2/devices.c
+++ b/arch/arm/mach-omap2/devices.c
@@ -253,7 +253,7 @@ int __init omap4_keyboard_init(struct omap4_keypad_platform_data
 			ARRAY_SIZE(omap_keyboard_latency), 0);
 
 	if (IS_ERR(od)) {
-		WARN(1, "Cant build omap_device for %s:%s.\n",
+		WARN(1, "Can't build omap_device for %s:%s.\n",
 						name, oh->name);
 		return PTR_ERR(od);
 	}
@@ -373,7 +373,7 @@ static int omap_mcspi_init(struct omap_hwmod *oh, void *unused)
 	od = omap_device_build(name, spi_num, oh, pdata,
 				sizeof(*pdata),	omap_mcspi_latency,
 				ARRAY_SIZE(omap_mcspi_latency), 0);
-	WARN(IS_ERR(od), "Cant build omap_device for %s:%s\n",
+	WARN(IS_ERR(od), "Can't build omap_device for %s:%s\n",
 				name, oh->name);
 	kfree(pdata);
 	return 0;
@@ -725,7 +725,7 @@ static int __init omap_init_wdt(void)
 	od = omap_device_build(dev_name, id, oh, NULL, 0,
 				omap_wdt_latency,
 				ARRAY_SIZE(omap_wdt_latency), 0);
-	WARN(IS_ERR(od), "Cant build omap_device for %s:%s.\n",
+	WARN(IS_ERR(od), "Can't build omap_device for %s:%s.\n",
 				dev_name, oh->name);
 	return 0;
 }
diff --git a/arch/arm/mach-omap2/dma.c b/arch/arm/mach-omap2/dma.c
index 34922b2..c9ff0e7 100644
--- a/arch/arm/mach-omap2/dma.c
+++ b/arch/arm/mach-omap2/dma.c
@@ -262,7 +262,7 @@ static int __init omap2_system_dma_init_dev(struct omap_hwmod *oh, void *unused)
 			omap2_dma_latency, ARRAY_SIZE(omap2_dma_latency), 0);
 	kfree(p);
 	if (IS_ERR(od)) {
-		pr_err("%s: Cant build omap_device for %s:%s.\n",
+		pr_err("%s: Can't build omap_device for %s:%s.\n",
 			__func__, name, oh->name);
 		return PTR_ERR(od);
 	}
diff --git a/arch/arm/mach-omap2/gpio.c b/arch/arm/mach-omap2/gpio.c
index 413de18..9529842 100644
--- a/arch/arm/mach-omap2/gpio.c
+++ b/arch/arm/mach-omap2/gpio.c
@@ -82,7 +82,7 @@ static int omap2_gpio_dev_init(struct omap_hwmod *oh, void *unused)
 	kfree(pdata);
 
 	if (IS_ERR(od)) {
-		WARN(1, "Cant build omap_device for %s:%s.\n",
+		WARN(1, "Can't build omap_device for %s:%s.\n",
 					name, oh->name);
 		return PTR_ERR(od);
 	}
diff --git a/arch/arm/mach-omap2/hsmmc.c b/arch/arm/mach-omap2/hsmmc.c
index 137e1a5..b2f30be 100644
--- a/arch/arm/mach-omap2/hsmmc.c
+++ b/arch/arm/mach-omap2/hsmmc.c
@@ -465,7 +465,7 @@ void __init omap_init_hsmmc(struct omap2_hsmmc_info *hsmmcinfo, int ctrl_nr)
 	od = omap_device_build(name, ctrl_nr - 1, oh, mmc_data,
 		sizeof(struct omap_mmc_platform_data), ohl, ohl_cnt, false);
 	if (IS_ERR(od)) {
-		WARN(1, "Cant build omap_device for %s:%s.\n", name, oh->name);
+		WARN(1, "Can't build omap_device for %s:%s.\n", name, oh->name);
 		kfree(mmc_data->slots[0].name);
 		goto done;
 	}
diff --git a/arch/arm/mach-omap2/mcbsp.c b/arch/arm/mach-omap2/mcbsp.c
index 565b906..4a6ef6a 100644
--- a/arch/arm/mach-omap2/mcbsp.c
+++ b/arch/arm/mach-omap2/mcbsp.c
@@ -149,7 +149,7 @@ static int omap_init_mcbsp(struct omap_hwmod *oh, void *unused)
 				ARRAY_SIZE(omap2_mcbsp_latency), false);
 	kfree(pdata);
 	if (IS_ERR(od))  {
-		pr_err("%s: Cant build omap_device for %s:%s.\n", __func__,
+		pr_err("%s: Can't build omap_device for %s:%s.\n", __func__,
 					name, oh->name);
 		return PTR_ERR(od);
 	}
diff --git a/arch/arm/mach-omap2/mux.c b/arch/arm/mach-omap2/mux.c
index bb043cb..a4ab1e3 100644
--- a/arch/arm/mach-omap2/mux.c
+++ b/arch/arm/mach-omap2/mux.c
@@ -518,7 +518,7 @@ static int omap_mux_dbg_board_show(struct seq_file *s, void *unused)
 			seq_printf(s, "/* %s */\n", m->muxnames[mode]);
 
 		/*
-		 * XXX: Might be revisited to support differences accross
+		 * XXX: Might be revisited to support differences across
 		 * same OMAP generation.
 		 */
 		seq_printf(s, "OMAP%d_MUX(%s, ", omap_gen, m0_def);
diff --git a/arch/arm/mach-omap2/mux2430.h b/arch/arm/mach-omap2/mux2430.h
index adbea0d..9fd9314 100644
--- a/arch/arm/mach-omap2/mux2430.h
+++ b/arch/arm/mach-omap2/mux2430.h
@@ -22,7 +22,7 @@
  * absolute addresses.  The name in the macro is the mode-0 name of
  * the pin.  NOTE: These registers are 8-bits wide.
  *
- * Note that these defines use SDMMC instead of MMC for compability
+ * Note that these defines use SDMMC instead of MMC for compatibility
  * with signal names used in 3630.
  */
 #define OMAP2430_CONTROL_PADCONF_GPMC_CLK_OFFSET		0x000
diff --git a/arch/arm/mach-omap2/omap_hwmod_2430_data.c b/arch/arm/mach-omap2/omap_hwmod_2430_data.c
index a860fb5..e6e3810 100644
--- a/arch/arm/mach-omap2/omap_hwmod_2430_data.c
+++ b/arch/arm/mach-omap2/omap_hwmod_2430_data.c
@@ -1559,7 +1559,7 @@ static struct omap_hwmod omap2430_i2c1_hwmod = {
 			 * I2CHS IP's do not follow the usual pattern.
 			 * prcm_reg_id alone cannot be used to program
 			 * the iclk and fclk. Needs to be handled using
-			 * additonal flags when clk handling is moved
+			 * additional flags when clk handling is moved
 			 * to hwmod framework.
 			 */
 			.module_offs = CORE_MOD,
diff --git a/arch/arm/mach-omap2/omap_phy_internal.c b/arch/arm/mach-omap2/omap_phy_internal.c
index e2e605f..05f6abc 100644
--- a/arch/arm/mach-omap2/omap_phy_internal.c
+++ b/arch/arm/mach-omap2/omap_phy_internal.c
@@ -112,12 +112,12 @@ int omap4430_phy_power(struct device *dev, int ID, int on)
 		else
 			/*
 			 * Enable VBUS Valid, AValid and IDDIG
-			 * high impedence
+			 * high impedance
 			 */
 			__raw_writel(IDDIG | AVALID | VBUSVALID,
 						ctrl_base + USBOTGHS_CONTROL);
 	} else {
-		/* Enable session END and IDIG to high impedence. */
+		/* Enable session END and IDIG to high impedance. */
 		__raw_writel(SESSEND | IDDIG, ctrl_base +
 					USBOTGHS_CONTROL);
 	}
diff --git a/arch/arm/mach-omap2/omap_twl.c b/arch/arm/mach-omap2/omap_twl.c
index 0a8e74e..07d6140 100644
--- a/arch/arm/mach-omap2/omap_twl.c
+++ b/arch/arm/mach-omap2/omap_twl.c
@@ -308,7 +308,7 @@ int __init omap3_twl_init(void)
  * Strategy Software Scaling Mode (ENABLE_VMODE=0), for setting the voltages,
  * in those scenarios this bit is to be cleared (enable = false).
  *
- * Returns 0 on sucess, error is returned if I2C read/write fails.
+ * Returns 0 on success, error is returned if I2C read/write fails.
  */
 int __init omap3_twl_set_sr_bit(bool enable)
 {
diff --git a/arch/arm/mach-omap2/powerdomain.c b/arch/arm/mach-omap2/powerdomain.c
index 49c6513..9af0847 100644
--- a/arch/arm/mach-omap2/powerdomain.c
+++ b/arch/arm/mach-omap2/powerdomain.c
@@ -196,7 +196,7 @@ static int _pwrdm_post_transition_cb(struct powerdomain *pwrdm, void *unused)
 /**
  * pwrdm_init - set up the powerdomain layer
  * @pwrdm_list: array of struct powerdomain pointers to register
- * @custom_funcs: func pointers for arch specfic implementations
+ * @custom_funcs: func pointers for arch specific implementations
  *
  * Loop through the array of powerdomains @pwrdm_list, registering all
  * that are available on the current CPU. If pwrdm_list is supplied
diff --git a/arch/arm/mach-omap2/powerdomain.h b/arch/arm/mach-omap2/powerdomain.h
index 027f40b..d23d979 100644
--- a/arch/arm/mach-omap2/powerdomain.h
+++ b/arch/arm/mach-omap2/powerdomain.h
@@ -121,7 +121,7 @@ struct powerdomain {
 };
 
 /**
- * struct pwrdm_ops - Arch specfic function implementations
+ * struct pwrdm_ops - Arch specific function implementations
  * @pwrdm_set_next_pwrst: Set the target power state for a pd
  * @pwrdm_read_next_pwrst: Read the target power state set for a pd
  * @pwrdm_read_pwrst: Read the current power state of a pd
diff --git a/arch/arm/mach-omap2/powerdomains3xxx_data.c b/arch/arm/mach-omap2/powerdomains3xxx_data.c
index 9c9c113..469a920 100644
--- a/arch/arm/mach-omap2/powerdomains3xxx_data.c
+++ b/arch/arm/mach-omap2/powerdomains3xxx_data.c
@@ -72,7 +72,7 @@ static struct powerdomain mpu_3xxx_pwrdm = {
 
 /*
  * The USBTLL Save-and-Restore mechanism is broken on
- * 3430s upto ES3.0 and 3630ES1.0. Hence this feature
+ * 3430s up to ES3.0 and 3630ES1.0. Hence this feature
  * needs to be disabled on these chips.
  * Refer: 3430 errata ID i459 and 3630 errata ID i579
  *
diff --git a/arch/arm/mach-omap2/smartreflex.c b/arch/arm/mach-omap2/smartreflex.c
index 8f674c9..13e24f9 100644
--- a/arch/arm/mach-omap2/smartreflex.c
+++ b/arch/arm/mach-omap2/smartreflex.c
@@ -247,7 +247,7 @@ static void sr_stop_vddautocomp(struct omap_sr *sr)
  * driver register and sr device intializtion API's. Only one call
  * will ultimately succeed.
  *
- * Currenly this function registers interrrupt handler for a particular SR
+ * Currently this function registers interrrupt handler for a particular SR
  * if smartreflex class driver is already registered and has
  * requested for interrupts and the SR interrupt line in present.
  */
diff --git a/arch/arm/mach-omap2/voltage.c b/arch/arm/mach-omap2/voltage.c
index c6facf7..6fb5209 100644
--- a/arch/arm/mach-omap2/voltage.c
+++ b/arch/arm/mach-omap2/voltage.c
@@ -851,7 +851,7 @@ int omap_voltage_scale_vdd(struct voltagedomain *voltdm,
  * @voltdm:	pointer to the VDD whose voltage is to be reset.
  *
  * This API finds out the correct voltage the voltage domain is supposed
- * to be at and resets the voltage to that level. Should be used expecially
+ * to be at and resets the voltage to that level. Should be used especially
  * while disabling any voltage compensation modules.
  */
 void omap_voltage_reset(struct voltagedomain *voltdm)
@@ -912,7 +912,7 @@ void omap_voltage_get_volttable(struct voltagedomain *voltdm,
  * This API searches only through the non-compensated voltages int the
  * voltage table.
  * Returns pointer to the voltage table entry corresponding to volt on
- * sucess. Returns -ENODATA if no voltage table exisits for the passed voltage
+ * success. Returns -ENODATA if no voltage table exisits for the passed voltage
  * domain or if there is no matching entry.
  */
 struct omap_volt_data *omap_voltage_get_voltdata(struct voltagedomain *voltdm,
diff --git a/arch/arm/mach-orion5x/addr-map.c b/arch/arm/mach-orion5x/addr-map.c
index 1a5d6a0..5ceafdc 100644
--- a/arch/arm/mach-orion5x/addr-map.c
+++ b/arch/arm/mach-orion5x/addr-map.c
@@ -19,7 +19,7 @@
 #include "common.h"
 
 /*
- * The Orion has fully programable address map. There's a separate address
+ * The Orion has fully programmable address map. There's a separate address
  * map for each of the device _master_ interfaces, e.g. CPU, PCI, PCIe, USB,
  * Gigabit Ethernet, DMA/XOR engines, etc. Each interface has its own
  * address decode windows that allow it to access any of the Orion resources.
diff --git a/arch/arm/mach-orion5x/net2big-setup.c b/arch/arm/mach-orion5x/net2big-setup.c
index 429ecaf..a5930f8 100644
--- a/arch/arm/mach-orion5x/net2big-setup.c
+++ b/arch/arm/mach-orion5x/net2big-setup.c
@@ -190,7 +190,7 @@ err_free_1:
  * The power front LEDs (blue and red) and SATA red LEDs are controlled via a
  * single GPIO line and are compatible with the leds-gpio driver.
  *
- * The SATA blue LEDs have some hardware blink capabilities which are detailled
+ * The SATA blue LEDs have some hardware blink capabilities which are detailed
  * in the following array:
  *
  * SATAx blue LED | SATAx activity | LED state
diff --git a/arch/arm/mach-orion5x/ts209-setup.c b/arch/arm/mach-orion5x/ts209-setup.c
index f0f43e1..e6d6449 100644
--- a/arch/arm/mach-orion5x/ts209-setup.c
+++ b/arch/arm/mach-orion5x/ts209-setup.c
@@ -36,7 +36,7 @@
 
 /****************************************************************************
  * 8MiB NOR flash. The struct mtd_partition is not in the same order as the
- *     partitions on the device because we want to keep compatability with
+ *     partitions on the device because we want to keep compatibility with
  *     existing QNAP firmware.
  *
  * Layout as used by QNAP:
diff --git a/arch/arm/mach-orion5x/ts409-setup.c b/arch/arm/mach-orion5x/ts409-setup.c
index 92f393f..9eac819 100644
--- a/arch/arm/mach-orion5x/ts409-setup.c
+++ b/arch/arm/mach-orion5x/ts409-setup.c
@@ -56,7 +56,7 @@
 
 /****************************************************************************
  * 8MiB NOR flash. The struct mtd_partition is not in the same order as the
- *     partitions on the device because we want to keep compatability with
+ *     partitions on the device because we want to keep compatibility with
  *     existing QNAP firmware.
  *
  * Layout as used by QNAP:
diff --git a/arch/arm/mach-pxa/include/mach/pxa3xx-regs.h b/arch/arm/mach-pxa/include/mach/pxa3xx-regs.h
index e4fb466..207ecb4 100644
--- a/arch/arm/mach-pxa/include/mach/pxa3xx-regs.h
+++ b/arch/arm/mach-pxa/include/mach/pxa3xx-regs.h
@@ -38,7 +38,7 @@
 #define PCMD(x)		__REG(0x40F50110 + ((x) << 2))
 
 /*
- * Slave Power Managment Unit
+ * Slave Power Management Unit
  */
 #define ASCR		__REG(0x40f40000)	/* Application Subsystem Power Status/Configuration */
 #define ARSR		__REG(0x40f40004)	/* Application Subsystem Reset Status */
diff --git a/arch/arm/mach-pxa/include/mach/zeus.h b/arch/arm/mach-pxa/include/mach/zeus.h
index faa408a..0641f31 100644
--- a/arch/arm/mach-pxa/include/mach/zeus.h
+++ b/arch/arm/mach-pxa/include/mach/zeus.h
@@ -64,7 +64,7 @@
 
 /*
  * CPLD registers:
- * Only 4 registers, but spreaded over a 32MB address space.
+ * Only 4 registers, but spread over a 32MB address space.
  * Be gentle, and remap that over 32kB...
  */
 
diff --git a/arch/arm/mach-pxa/mioa701.c b/arch/arm/mach-pxa/mioa701.c
index dd13bb6..23925db 100644
--- a/arch/arm/mach-pxa/mioa701.c
+++ b/arch/arm/mach-pxa/mioa701.c
@@ -458,7 +458,7 @@ static struct platform_device strataflash = {
 /*
  * Suspend/Resume bootstrap management
  *
- * MIO A701 reboot sequence is highly ROM dependant. From the one dissassembled,
+ * MIO A701 reboot sequence is highly ROM dependent. From the one dissassembled,
  * this sequence is as follows :
  *   - disables interrupts
  *   - initialize SDRAM (self refresh RAM into active RAM)
diff --git a/arch/arm/mach-s3c2410/include/mach/dma.h b/arch/arm/mach-s3c2410/include/mach/dma.h
index cf68136..b2b2a5b 100644
--- a/arch/arm/mach-s3c2410/include/mach/dma.h
+++ b/arch/arm/mach-s3c2410/include/mach/dma.h
@@ -19,7 +19,7 @@
 #define MAX_DMA_TRANSFER_SIZE   0x100000 /* Data Unit is half word  */
 
 /* We use `virtual` dma channels to hide the fact we have only a limited
- * number of DMA channels, and not of all of them (dependant on the device)
+ * number of DMA channels, and not of all of them (dependent on the device)
  * can be attached to any DMA source. We therefore let the DMA core handle
  * the allocation of hardware channels to clients.
 */
diff --git a/arch/arm/mach-s3c2410/include/mach/regs-mem.h b/arch/arm/mach-s3c2410/include/mach/regs-mem.h
index 7f7c529..988a686 100644
--- a/arch/arm/mach-s3c2410/include/mach/regs-mem.h
+++ b/arch/arm/mach-s3c2410/include/mach/regs-mem.h
@@ -101,7 +101,7 @@
 #define S3C2410_BANKCON_PMC16		(0x03)
 
 /* bank configurations for banks 0..7, note banks
- * 6 and 7 have differnt configurations depending on
+ * 6 and 7 have different configurations depending on
  * the memory type bits */
 
 #define S3C2410_BANKCON_Tacp2		(0x0 << 2)
diff --git a/arch/arm/mach-s3c2410/mach-n30.c b/arch/arm/mach-s3c2410/mach-n30.c
index 66f4444..079dcaa 100644
--- a/arch/arm/mach-s3c2410/mach-n30.c
+++ b/arch/arm/mach-s3c2410/mach-n30.c
@@ -252,7 +252,7 @@ static struct s3c24xx_led_platdata n30_blue_led_pdata = {
 	.def_trigger	= "",
 };
 
-/* This is the blue LED on the device. Originaly used to indicate GPS activity
+/* This is the blue LED on the device. Originally used to indicate GPS activity
  * by flashing. */
 static struct s3c24xx_led_platdata n35_blue_led_pdata = {
 	.name		= "blue_led",
diff --git a/arch/arm/mach-s3c2440/mach-mini2440.c b/arch/arm/mach-s3c2440/mach-mini2440.c
index dfedc9c..dd3120d 100644
--- a/arch/arm/mach-s3c2440/mach-mini2440.c
+++ b/arch/arm/mach-s3c2440/mach-mini2440.c
@@ -155,7 +155,7 @@ static struct s3c2410fb_display mini2440_lcd_cfg[] __initdata = {
 	 * the same timings, however, anything smaller than 1024x768
 	 * will only be displayed in the top left corner of a 1024x768
 	 * XGA output unless you add optional dip switches to the shield.
-	 * Therefore timings for other resolutions have been ommited here.
+	 * Therefore timings for other resolutions have been omitted here.
 	 */
 	[2] = {
 		_LCD_DECLARE(
diff --git a/arch/arm/mach-s3c64xx/dma.c b/arch/arm/mach-s3c64xx/dma.c
index c35585c..b197171 100644
--- a/arch/arm/mach-s3c64xx/dma.c
+++ b/arch/arm/mach-s3c64xx/dma.c
@@ -315,7 +315,7 @@ int s3c2410_dma_ctrl(unsigned int channel, enum s3c2410_chan_op op)
 	case S3C2410_DMAOP_FLUSH:
 		return s3c64xx_dma_flush(chan);
 
-	/* belive PAUSE/RESUME are no-ops */
+	/* believe PAUSE/RESUME are no-ops */
 	case S3C2410_DMAOP_PAUSE:
 	case S3C2410_DMAOP_RESUME:
 	case S3C2410_DMAOP_STARTED:
diff --git a/arch/arm/mach-s5pc100/include/mach/regs-fb.h b/arch/arm/mach-s5pc100/include/mach/regs-fb.h
index 4be4cc9..07aa4d6 100644
--- a/arch/arm/mach-s5pc100/include/mach/regs-fb.h
+++ b/arch/arm/mach-s5pc100/include/mach/regs-fb.h
@@ -29,7 +29,7 @@
 #define WPALCON_H					(0x19c)
 #define WPALCON_L					(0x1a0)
 
-/* Pallete contro for WPAL0 and WPAL1 is the same as in S3C64xx, but
+/* Palette control for WPAL0 and WPAL1 is the same as in S3C64xx, but
  * different for WPAL2-4
  */
 /* In WPALCON_L (aka WPALCON) */
diff --git a/arch/arm/mach-s5pc100/setup-sdhci.c b/arch/arm/mach-s5pc100/setup-sdhci.c
index f16946e..be25879 100644
--- a/arch/arm/mach-s5pc100/setup-sdhci.c
+++ b/arch/arm/mach-s5pc100/setup-sdhci.c
@@ -40,7 +40,7 @@ void s5pc100_setup_sdhci0_cfg_card(struct platform_device *dev,
 {
 	u32 ctrl2, ctrl3;
 
-	/* don't need to alter anything acording to card-type */
+	/* don't need to alter anything according to card-type */
 
 	writel(S3C64XX_SDHCI_CONTROL4_DRIVE_9mA, r + S3C64XX_SDHCI_CONTROL4);
 
diff --git a/arch/arm/mach-s5pv210/include/mach/gpio.h b/arch/arm/mach-s5pv210/include/mach/gpio.h
index 1f4b595..a5a1e33 100644
--- a/arch/arm/mach-s5pv210/include/mach/gpio.h
+++ b/arch/arm/mach-s5pv210/include/mach/gpio.h
@@ -18,7 +18,7 @@
 #define gpio_cansleep	__gpio_cansleep
 #define gpio_to_irq	__gpio_to_irq
 
-/* Practically, GPIO banks upto MP03 are the configurable gpio banks */
+/* Practically, GPIO banks up to MP03 are the configurable gpio banks */
 
 /* GPIO bank sizes */
 #define S5PV210_GPIO_A0_NR	(8)
diff --git a/arch/arm/mach-s5pv210/setup-sdhci-gpio.c b/arch/arm/mach-s5pv210/setup-sdhci-gpio.c
index 746777d..3e3ac05 100644
--- a/arch/arm/mach-s5pv210/setup-sdhci-gpio.c
+++ b/arch/arm/mach-s5pv210/setup-sdhci-gpio.c
@@ -32,10 +32,10 @@ void s5pv210_setup_sdhci0_cfg_gpio(struct platform_device *dev, int width)
 
 	switch (width) {
 	case 8:
-		/* GPG1[3:6] special-funtion 3 */
+		/* GPG1[3:6] special-function 3 */
 		s3c_gpio_cfgrange_nopull(S5PV210_GPG1(3), 4, S3C_GPIO_SFN(3));
 	case 4:
-		/* GPG0[3:6] special-funtion 2 */
+		/* GPG0[3:6] special-function 2 */
 		s3c_gpio_cfgrange_nopull(S5PV210_GPG0(3), 4, S3C_GPIO_SFN(2));
 	default:
 		break;
diff --git a/arch/arm/mach-s5pv210/setup-sdhci.c b/arch/arm/mach-s5pv210/setup-sdhci.c
index c32e202..a83b6c9 100644
--- a/arch/arm/mach-s5pv210/setup-sdhci.c
+++ b/arch/arm/mach-s5pv210/setup-sdhci.c
@@ -38,7 +38,7 @@ void s5pv210_setup_sdhci_cfg_card(struct platform_device *dev,
 {
 	u32 ctrl2, ctrl3;
 
-	/* don't need to alter anything acording to card-type */
+	/* don't need to alter anything according to card-type */
 
 	writel(S3C64XX_SDHCI_CONTROL4_DRIVE_9mA, r + S3C64XX_SDHCI_CONTROL4);
 
diff --git a/arch/arm/mach-sa1100/Makefile b/arch/arm/mach-sa1100/Makefile
index e697691..41252d2 100644
--- a/arch/arm/mach-sa1100/Makefile
+++ b/arch/arm/mach-sa1100/Makefile
@@ -50,7 +50,7 @@ led-$(CONFIG_SA1100_SIMPAD)		+= leds-simpad.o
 # LEDs support
 obj-$(CONFIG_LEDS) += $(led-y)
 
-# Miscelaneous functions
+# Miscellaneous functions
 obj-$(CONFIG_PM)			+= pm.o sleep.o
 obj-$(CONFIG_SA1100_SSP)		+= ssp.o
 
diff --git a/arch/arm/mach-sa1100/cpu-sa1100.c b/arch/arm/mach-sa1100/cpu-sa1100.c
index 07d4e8b..aaa8acf 100644
--- a/arch/arm/mach-sa1100/cpu-sa1100.c
+++ b/arch/arm/mach-sa1100/cpu-sa1100.c
@@ -68,7 +68,7 @@
  * clock change in ROM and jump to that code from the kernel. The main
  * disadvantage is that the ROM has to be modified, which is not
  * possible on all SA-1100 platforms. Another disadvantage is that
- * jumping to ROM makes clock switching unecessary complicated.
+ * jumping to ROM makes clock switching unnecessary complicated.
  *
  * The idea behind this driver is that the memory configuration can be
  * changed while running from DRAM (even with interrupts turned on!)
diff --git a/arch/arm/mach-sa1100/include/mach/SA-1100.h b/arch/arm/mach-sa1100/include/mach/SA-1100.h
index 4f7ea01..bae8296 100644
--- a/arch/arm/mach-sa1100/include/mach/SA-1100.h
+++ b/arch/arm/mach-sa1100/include/mach/SA-1100.h
@@ -1794,7 +1794,7 @@
                 	(DDAR_DevRd + DDAR_Brst4 + DDAR_16BitDev + \
                 	 DDAR_Ser4SSPRc + DDAR_DevAdd (__PREG(Ser4SSDR)))
 
-#define DCSR_RUN	0x00000001	/* DMA RUNing                      */
+#define DCSR_RUN	0x00000001	/* DMA running                     */
 #define DCSR_IE 	0x00000002	/* DMA Interrupt Enable            */
 #define DCSR_ERROR	0x00000004	/* DMA ERROR                       */
 #define DCSR_DONEA	0x00000008	/* DONE DMA transfer buffer A      */
diff --git a/arch/arm/mach-sa1100/jornada720_ssp.c b/arch/arm/mach-sa1100/jornada720_ssp.c
index 9d490c6..f50b00b 100644
--- a/arch/arm/mach-sa1100/jornada720_ssp.c
+++ b/arch/arm/mach-sa1100/jornada720_ssp.c
@@ -29,7 +29,7 @@ static unsigned long jornada_ssp_flags;
 /**
  * jornada_ssp_reverse - reverses input byte
  *
- * we need to reverse all data we recieve from the mcu due to its physical location
+ * we need to reverse all data we receive from the mcu due to its physical location
  * returns : 01110111 -> 11101110
  */
 u8 inline jornada_ssp_reverse(u8 byte)
@@ -179,7 +179,7 @@ static int __devinit jornada_ssp_probe(struct platform_device *dev)
 
 static int jornada_ssp_remove(struct platform_device *dev)
 {
-	/* Note that this doesnt actually remove the driver, since theres nothing to remove
+	/* Note that this doesn't actually remove the driver, since theres nothing to remove
 	 * It just makes sure everything is turned off */
 	GPSR = GPIO_GPIO25;
 	ssp_exit();
diff --git a/arch/arm/mach-shmobile/board-ap4evb.c b/arch/arm/mach-shmobile/board-ap4evb.c
index 783b66f..1e35fa9 100644
--- a/arch/arm/mach-shmobile/board-ap4evb.c
+++ b/arch/arm/mach-shmobile/board-ap4evb.c
@@ -947,7 +947,7 @@ static struct platform_device *ap4evb_devices[] __initdata = {
 	&ap4evb_camera,
 };
 
-static int __init hdmi_init_pm_clock(void)
+static void __init hdmi_init_pm_clock(void)
 {
 	struct clk *hdmi_ick = clk_get(&hdmi_device.dev, "ick");
 	int ret;
@@ -988,20 +988,15 @@ static int __init hdmi_init_pm_clock(void)
 	pr_debug("PLLC2 set frequency %lu\n", rate);
 
 	ret = clk_set_parent(hdmi_ick, &sh7372_pllc2_clk);
-	if (ret < 0) {
+	if (ret < 0)
 		pr_err("Cannot set HDMI parent: %d\n", ret);
-		goto out;
-	}
 
 out:
 	if (!IS_ERR(hdmi_ick))
 		clk_put(hdmi_ick);
-	return ret;
 }
 
-device_initcall(hdmi_init_pm_clock);
-
-static int __init fsi_init_pm_clock(void)
+static void __init fsi_init_pm_clock(void)
 {
 	struct clk *fsia_ick;
 	int ret;
@@ -1010,7 +1005,7 @@ static int __init fsi_init_pm_clock(void)
 	if (IS_ERR(fsia_ick)) {
 		ret = PTR_ERR(fsia_ick);
 		pr_err("Cannot get FSI ICK: %d\n", ret);
-		return ret;
+		return;
 	}
 
 	ret = clk_set_parent(fsia_ick, &sh7372_fsiack_clk);
@@ -1018,10 +1013,7 @@ static int __init fsi_init_pm_clock(void)
 		pr_err("Cannot set FSI-A parent: %d\n", ret);
 
 	clk_put(fsia_ick);
-
-	return ret;
 }
-device_initcall(fsi_init_pm_clock);
 
 /*
  * FIXME !!
@@ -1348,6 +1340,9 @@ static void __init ap4evb_init(void)
 	__raw_writel(srcr4 & ~(1 << 13), SRCR4);
 
 	platform_add_devices(ap4evb_devices, ARRAY_SIZE(ap4evb_devices));
+
+	hdmi_init_pm_clock();
+	fsi_init_pm_clock();
 }
 
 static void __init ap4evb_timer_init(void)
diff --git a/arch/arm/mach-shmobile/board-mackerel.c b/arch/arm/mach-shmobile/board-mackerel.c
index 8184d4d..7da2ca2 100644
--- a/arch/arm/mach-shmobile/board-mackerel.c
+++ b/arch/arm/mach-shmobile/board-mackerel.c
@@ -423,7 +423,7 @@ static struct platform_device fsi_hdmi_device = {
 	.name		= "sh_fsi2_b_hdmi",
 };
 
-static int __init hdmi_init_pm_clock(void)
+static void __init hdmi_init_pm_clock(void)
 {
 	struct clk *hdmi_ick = clk_get(&hdmi_device.dev, "ick");
 	int ret;
@@ -467,17 +467,13 @@ static int __init hdmi_init_pm_clock(void)
 	pr_debug("PLLC2 set frequency %lu\n", rate);
 
 	ret = clk_set_parent(hdmi_ick, &sh7372_pllc2_clk);
-	if (ret < 0) {
+	if (ret < 0)
 		pr_err("Cannot set HDMI parent: %d\n", ret);
-		goto out;
-	}
 
 out:
 	if (!IS_ERR(hdmi_ick))
 		clk_put(hdmi_ick);
-	return ret;
 }
-device_initcall(hdmi_init_pm_clock);
 
 /* USB1 (Host) */
 static void usb1_host_port_power(int port, int power)
@@ -1218,6 +1214,8 @@ static void __init mackerel_init(void)
 	sh7372_add_standard_devices();
 
 	platform_add_devices(mackerel_devices, ARRAY_SIZE(mackerel_devices));
+
+	hdmi_init_pm_clock();
 }
 
 static void __init mackerel_timer_init(void)
diff --git a/arch/arm/mach-shmobile/include/mach/mmc.h b/arch/arm/mach-shmobile/include/mach/mmc.h
index e11560a..21a59db 100644
--- a/arch/arm/mach-shmobile/include/mach/mmc.h
+++ b/arch/arm/mach-shmobile/include/mach/mmc.h
@@ -9,7 +9,7 @@
 
 #ifdef CONFIG_MACH_AP4EVB
 #include "mach/mmc-ap4eb.h"
-#elif CONFIG_MACH_MACKEREL
+#elif defined(CONFIG_MACH_MACKEREL)
 #include "mach/mmc-mackerel.h"
 #else
 #error "unsupported board."
diff --git a/arch/arm/mach-shmobile/include/mach/zboot.h b/arch/arm/mach-shmobile/include/mach/zboot.h
index 6d6a205..9320aff 100644
--- a/arch/arm/mach-shmobile/include/mach/zboot.h
+++ b/arch/arm/mach-shmobile/include/mach/zboot.h
@@ -13,7 +13,7 @@
 #ifdef CONFIG_MACH_AP4EVB
 #define MACH_TYPE	MACH_TYPE_AP4EVB
 #include "mach/head-ap4evb.txt"
-#elif CONFIG_MACH_MACKEREL
+#elif defined(CONFIG_MACH_MACKEREL)
 #define MACH_TYPE	MACH_TYPE_MACKEREL
 #include "mach/head-mackerel.txt"
 #else
diff --git a/arch/arm/mach-tegra/dma.c b/arch/arm/mach-tegra/dma.c
index e945ae2..f4ef5eb 100644
--- a/arch/arm/mach-tegra/dma.c
+++ b/arch/arm/mach-tegra/dma.c
@@ -223,7 +223,7 @@ int tegra_dma_dequeue_req(struct tegra_dma_channel *ch,
 	 *  - Change the source selector to invalid to stop the DMA from
 	 *    FIFO to memory.
 	 *  - Read the status register to know the number of pending
-	 *    bytes to be transfered.
+	 *    bytes to be transferred.
 	 *  - Finally stop or program the DMA to the next buffer in the
 	 *    list.
 	 */
@@ -244,7 +244,7 @@ int tegra_dma_dequeue_req(struct tegra_dma_channel *ch,
 	if (status & STA_BUSY)
 		req->bytes_transferred -= to_transfer;
 
-	/* In continous transfer mode, DMA only tracks the count of the
+	/* In continuous transfer mode, DMA only tracks the count of the
 	 * half DMA buffer. So, if the DMA already finished half the DMA
 	 * then add the half buffer to the completed count.
 	 *
diff --git a/arch/arm/mach-tegra/include/mach/dma.h b/arch/arm/mach-tegra/include/mach/dma.h
index 39011bd..d0132e8 100644
--- a/arch/arm/mach-tegra/include/mach/dma.h
+++ b/arch/arm/mach-tegra/include/mach/dma.h
@@ -92,11 +92,11 @@ struct tegra_dma_req {
 	/*  This is a called from the DMA ISR context when the DMA is still in
 	 *  progress and is actively filling same buffer.
 	 *
-	 *  In case of continous mode receive, this threshold is 1/2 the buffer
+	 *  In case of continuous mode receive, this threshold is 1/2 the buffer
 	 *  size. In other cases, this will not even be called as there is no
 	 *  hardware support for it.
 	 *
-	 * In the case of continous mode receive, if there is next req already
+	 * In the case of continuous mode receive, if there is next req already
 	 * queued, DMA programs the HW to use that req when this req is
 	 * completed. If there is no "next req" queued, then DMA ISR doesn't do
 	 * anything before calling this callback.
diff --git a/arch/arm/mach-u300/clock.c b/arch/arm/mach-u300/clock.c
index fabcc49..5535dd0 100644
--- a/arch/arm/mach-u300/clock.c
+++ b/arch/arm/mach-u300/clock.c
@@ -263,7 +263,7 @@ static void disable_i2s0_vcxo(void)
 	val = readw(U300_SYSCON_VBASE + U300_SYSCON_CCR);
 	val &= ~U300_SYSCON_CCR_I2S0_USE_VCXO;
 	writew(val, U300_SYSCON_VBASE + U300_SYSCON_CCR);
-	/* Deactivate VCXO if noone else is using VCXO */
+	/* Deactivate VCXO if no one else is using VCXO */
 	if (!(val & U300_SYSCON_CCR_I2S1_USE_VCXO))
 		val &= ~U300_SYSCON_CCR_TURN_VCXO_ON;
 	writew(val, U300_SYSCON_VBASE + U300_SYSCON_CCR);
@@ -283,7 +283,7 @@ static void disable_i2s1_vcxo(void)
 	val = readw(U300_SYSCON_VBASE + U300_SYSCON_CCR);
 	val &= ~U300_SYSCON_CCR_I2S1_USE_VCXO;
 	writew(val, U300_SYSCON_VBASE + U300_SYSCON_CCR);
-	/* Deactivate VCXO if noone else is using VCXO */
+	/* Deactivate VCXO if no one else is using VCXO */
 	if (!(val & U300_SYSCON_CCR_I2S0_USE_VCXO))
 		val &= ~U300_SYSCON_CCR_TURN_VCXO_ON;
 	writew(val, U300_SYSCON_VBASE + U300_SYSCON_CCR);
@@ -649,7 +649,7 @@ static unsigned long clk_round_rate_cpuclk(struct clk *clk, unsigned long rate)
  */
 long clk_round_rate(struct clk *clk, unsigned long rate)
 {
-	/* TODO: get apropriate switches for EMIFCLK, AHBCLK and MCLK */
+	/* TODO: get appropriate switches for EMIFCLK, AHBCLK and MCLK */
 	/* Else default to fixed value */
 
 	if (clk->round_rate) {
diff --git a/arch/arm/mach-ux500/board-mop500.c b/arch/arm/mach-ux500/board-mop500.c
index dc8746d..af91374 100644
--- a/arch/arm/mach-ux500/board-mop500.c
+++ b/arch/arm/mach-ux500/board-mop500.c
@@ -52,7 +52,7 @@ static struct ab8500_gpio_platform_data ab8500_gpio_pdata = {
 	 * on value present in GpioSel1 to GpioSel6 and AlternatFunction
 	 * register. This is the array of 7 configuration settings.
 	 * One has to compile time decide these settings. Below is the
-	 * explaination of these setting
+	 * explanation of these setting
 	 * GpioSel1 = 0x00 => Pins GPIO1 to GPIO8 are not used as GPIO
 	 * GpioSel2 = 0x1E => Pins GPIO10 to GPIO13 are configured as GPIO
 	 * GpioSel3 = 0x80 => Pin GPIO24 is configured as GPIO
diff --git a/arch/arm/mach-ux500/include/mach/db8500-regs.h b/arch/arm/mach-ux500/include/mach/db8500-regs.h
index 0fefb34..16647b2 100644
--- a/arch/arm/mach-ux500/include/mach/db8500-regs.h
+++ b/arch/arm/mach-ux500/include/mach/db8500-regs.h
@@ -58,7 +58,7 @@
 #define U8500_GPIO2_BASE	(U8500_PER2_BASE + 0xE000)
 #define U8500_GPIO3_BASE	(U8500_PER5_BASE + 0x1E000)
 
-/* per7 base addressess */
+/* per7 base addresses */
 #define U8500_CR_BASE_ED	(U8500_PER7_BASE_ED + 0x8000)
 #define U8500_MTU0_BASE_ED	(U8500_PER7_BASE_ED + 0xa000)
 #define U8500_MTU1_BASE_ED	(U8500_PER7_BASE_ED + 0xb000)
@@ -68,7 +68,7 @@
 #define U8500_UART0_BASE	(U8500_PER1_BASE + 0x0000)
 #define U8500_UART1_BASE	(U8500_PER1_BASE + 0x1000)
 
-/* per6 base addressess */
+/* per6 base addresses */
 #define U8500_RNG_BASE		(U8500_PER6_BASE + 0x0000)
 #define U8500_PKA_BASE		(U8500_PER6_BASE + 0x1000)
 #define U8500_PKAM_BASE		(U8500_PER6_BASE + 0x2000)
@@ -79,11 +79,11 @@
 #define U8500_CRYPTO1_BASE	(U8500_PER6_BASE + 0xb000)
 #define U8500_CLKRST6_BASE	(U8500_PER6_BASE + 0xf000)
 
-/* per5 base addressess */
+/* per5 base addresses */
 #define U8500_USBOTG_BASE	(U8500_PER5_BASE + 0x00000)
 #define U8500_CLKRST5_BASE	(U8500_PER5_BASE + 0x1f000)
 
-/* per4 base addressess */
+/* per4 base addresses */
 #define U8500_BACKUPRAM0_BASE	(U8500_PER4_BASE + 0x00000)
 #define U8500_BACKUPRAM1_BASE	(U8500_PER4_BASE + 0x01000)
 #define U8500_RTT0_BASE		(U8500_PER4_BASE + 0x02000)
@@ -106,7 +106,7 @@
 #define U8500_SDI5_BASE		(U8500_PER3_BASE + 0x8000)
 #define U8500_CLKRST3_BASE	(U8500_PER3_BASE + 0xf000)
 
-/* per2 base addressess */
+/* per2 base addresses */
 #define U8500_I2C3_BASE		(U8500_PER2_BASE + 0x0000)
 #define U8500_SPI2_BASE		(U8500_PER2_BASE + 0x1000)
 #define U8500_SPI1_BASE		(U8500_PER2_BASE + 0x2000)
diff --git a/arch/arm/mm/cache-v4wb.S b/arch/arm/mm/cache-v4wb.S
index d3644db..f40c696 100644
--- a/arch/arm/mm/cache-v4wb.S
+++ b/arch/arm/mm/cache-v4wb.S
@@ -32,7 +32,7 @@
 /*
  * This is the size at which it becomes more efficient to
  * clean the whole cache, rather than using the individual
- * cache line maintainence instructions.
+ * cache line maintenance instructions.
  *
  *  Size  Clean (ticks) Dirty (ticks)
  *   4096   21  20  21    53  55  54
diff --git a/arch/arm/mm/cache-v4wt.S b/arch/arm/mm/cache-v4wt.S
index 49c2b66..a7b276d 100644
--- a/arch/arm/mm/cache-v4wt.S
+++ b/arch/arm/mm/cache-v4wt.S
@@ -34,7 +34,7 @@
 /*
  * This is the size at which it becomes more efficient to
  * clean the whole cache, rather than using the individual
- * cache line maintainence instructions.
+ * cache line maintenance instructions.
  *
  * *** This needs benchmarking
  */
diff --git a/arch/arm/mm/cache-v7.S b/arch/arm/mm/cache-v7.S
index 6136e68..dc18d81 100644
--- a/arch/arm/mm/cache-v7.S
+++ b/arch/arm/mm/cache-v7.S
@@ -96,7 +96,7 @@ ENDPROC(v7_flush_dcache_all)
  *	Flush the entire cache system.
  *  The data cache flush is now achieved using atomic clean / invalidates
  *  working outwards from L1 cache. This is done using Set/Way based cache
- *  maintainance instructions.
+ *  maintenance instructions.
  *  The instruction cache can still be invalidated back to the point of
  *  unification in a single instruction.
  *
diff --git a/arch/arm/mm/proc-arm1020.S b/arch/arm/mm/proc-arm1020.S
index 226e3d8..6c4e7fd 100644
--- a/arch/arm/mm/proc-arm1020.S
+++ b/arch/arm/mm/proc-arm1020.S
@@ -64,7 +64,7 @@
 /*
  * This is the size at which it becomes more efficient to
  * clean the whole cache, rather than using the individual
- * cache line maintainence instructions.
+ * cache line maintenance instructions.
  */
 #define CACHE_DLIMIT	32768
 
diff --git a/arch/arm/mm/proc-arm1020e.S b/arch/arm/mm/proc-arm1020e.S
index 86d9c2c..4ce947c 100644
--- a/arch/arm/mm/proc-arm1020e.S
+++ b/arch/arm/mm/proc-arm1020e.S
@@ -64,7 +64,7 @@
 /*
  * This is the size at which it becomes more efficient to
  * clean the whole cache, rather than using the individual
- * cache line maintainence instructions.
+ * cache line maintenance instructions.
  */
 #define CACHE_DLIMIT	32768
 
diff --git a/arch/arm/mm/proc-arm1022.S b/arch/arm/mm/proc-arm1022.S
index 83d3dd3..c8884c5 100644
--- a/arch/arm/mm/proc-arm1022.S
+++ b/arch/arm/mm/proc-arm1022.S
@@ -53,7 +53,7 @@
 /*
  * This is the size at which it becomes more efficient to
  * clean the whole cache, rather than using the individual
- * cache line maintainence instructions.
+ * cache line maintenance instructions.
  */
 #define CACHE_DLIMIT	32768
 
diff --git a/arch/arm/mm/proc-arm1026.S b/arch/arm/mm/proc-arm1026.S
index 686043e..4136846 100644
--- a/arch/arm/mm/proc-arm1026.S
+++ b/arch/arm/mm/proc-arm1026.S
@@ -53,7 +53,7 @@
 /*
  * This is the size at which it becomes more efficient to
  * clean the whole cache, rather than using the individual
- * cache line maintainence instructions.
+ * cache line maintenance instructions.
  */
 #define CACHE_DLIMIT	32768
 
diff --git a/arch/arm/mm/proc-arm720.S b/arch/arm/mm/proc-arm720.S
index 665266d..7a06e59 100644
--- a/arch/arm/mm/proc-arm720.S
+++ b/arch/arm/mm/proc-arm720.S
@@ -63,7 +63,7 @@ ENTRY(cpu_arm720_proc_fin)
 /*
  * Function: arm720_proc_do_idle(void)
  * Params  : r0 = unused
- * Purpose : put the processer in proper idle mode
+ * Purpose : put the processor in proper idle mode
  */
 ENTRY(cpu_arm720_do_idle)
 		mov	pc, lr
diff --git a/arch/arm/mm/proc-arm920.S b/arch/arm/mm/proc-arm920.S
index 219980e..b46eb21 100644
--- a/arch/arm/mm/proc-arm920.S
+++ b/arch/arm/mm/proc-arm920.S
@@ -53,7 +53,7 @@
 /*
  * This is the size at which it becomes more efficient to
  * clean the whole cache, rather than using the individual
- * cache line maintainence instructions.
+ * cache line maintenance instructions.
  */
 #define CACHE_DLIMIT	65536
 
diff --git a/arch/arm/mm/proc-arm922.S b/arch/arm/mm/proc-arm922.S
index 36154b1..95ba1fc 100644
--- a/arch/arm/mm/proc-arm922.S
+++ b/arch/arm/mm/proc-arm922.S
@@ -54,7 +54,7 @@
 /*
  * This is the size at which it becomes more efficient to
  * clean the whole cache, rather than using the individual
- * cache line maintainence instructions.  (I think this should
+ * cache line maintenance instructions.  (I think this should
  * be 32768).
  */
 #define CACHE_DLIMIT	8192
diff --git a/arch/arm/mm/proc-arm925.S b/arch/arm/mm/proc-arm925.S
index 89c5e000..541e477 100644
--- a/arch/arm/mm/proc-arm925.S
+++ b/arch/arm/mm/proc-arm925.S
@@ -77,7 +77,7 @@
 /*
  * This is the size at which it becomes more efficient to
  * clean the whole cache, rather than using the individual
- * cache line maintainence instructions.
+ * cache line maintenance instructions.
  */
 #define CACHE_DLIMIT	8192
 
diff --git a/arch/arm/mm/proc-macros.S b/arch/arm/mm/proc-macros.S
index e32fa49..34261f9 100644
--- a/arch/arm/mm/proc-macros.S
+++ b/arch/arm/mm/proc-macros.S
@@ -85,7 +85,7 @@
 
 /*
  * Sanity check the PTE configuration for the code below - which makes
- * certain assumptions about how these bits are layed out.
+ * certain assumptions about how these bits are laid out.
  */
 #ifdef CONFIG_MMU
 #if L_PTE_SHARED != PTE_EXT_SHARED
diff --git a/arch/arm/mm/proc-v6.S b/arch/arm/mm/proc-v6.S
index 832b6bd..bfa0c9f 100644
--- a/arch/arm/mm/proc-v6.S
+++ b/arch/arm/mm/proc-v6.S
@@ -132,7 +132,7 @@ ENTRY(cpu_v6_do_suspend)
 	mrc	p15, 0, r6, c3, c0, 0	@ Domain ID
 	mrc	p15, 0, r7, c2, c0, 0	@ Translation table base 0
 	mrc	p15, 0, r8, c2, c0, 1	@ Translation table base 1
-	mrc	p15, 0, r9, c1, c0, 1	@ auxillary control register
+	mrc	p15, 0, r9, c1, c0, 1	@ auxiliary control register
 	mrc	p15, 0, r10, c1, c0, 2	@ co-processor access control
 	mrc	p15, 0, r11, c1, c0, 0	@ control register
 	stmia	r0, {r4 - r11}
@@ -151,7 +151,7 @@ ENTRY(cpu_v6_do_resume)
 	mcr	p15, 0, r6, c3, c0, 0	@ Domain ID
 	mcr	p15, 0, r7, c2, c0, 0	@ Translation table base 0
 	mcr	p15, 0, r8, c2, c0, 1	@ Translation table base 1
-	mcr	p15, 0, r9, c1, c0, 1	@ auxillary control register
+	mcr	p15, 0, r9, c1, c0, 1	@ auxiliary control register
 	mcr	p15, 0, r10, c1, c0, 2	@ co-processor access control
 	mcr	p15, 0, ip, c2, c0, 2	@ TTB control register
 	mcr	p15, 0, ip, c7, c5, 4	@ ISB
diff --git a/arch/arm/mm/proc-v7.S b/arch/arm/mm/proc-v7.S
index 262fa88..c35618e 100644
--- a/arch/arm/mm/proc-v7.S
+++ b/arch/arm/mm/proc-v7.S
@@ -237,7 +237,7 @@ ENTRY(cpu_v7_do_resume)
 	mcr	p15, 0, r7, c2, c0, 0	@ TTB 0
 	mcr	p15, 0, r8, c2, c0, 1	@ TTB 1
 	mcr	p15, 0, ip, c2, c0, 2	@ TTB control register
-	mcr	p15, 0, r10, c1, c0, 1	@ Auxillary control register
+	mcr	p15, 0, r10, c1, c0, 1	@ Auxiliary control register
 	mcr	p15, 0, r11, c1, c0, 2	@ Co-processor access control
 	ldr	r4, =PRRR		@ PRRR
 	ldr	r5, =NMRR		@ NMRR
diff --git a/arch/arm/plat-mxc/cpufreq.c b/arch/arm/plat-mxc/cpufreq.c
index ce81481..4268a2b 100644
--- a/arch/arm/plat-mxc/cpufreq.c
+++ b/arch/arm/plat-mxc/cpufreq.c
@@ -13,7 +13,7 @@
 
 /*
  * A driver for the Freescale Semiconductor i.MXC CPUfreq module.
- * The CPUFREQ driver is for controling CPU frequency. It allows you to change
+ * The CPUFREQ driver is for controlling CPU frequency. It allows you to change
  * the CPU clock speed on the fly.
  */
 
diff --git a/arch/arm/plat-mxc/include/mach/entry-macro.S b/arch/arm/plat-mxc/include/mach/entry-macro.S
index bd9bb97..2e49e71 100644
--- a/arch/arm/plat-mxc/include/mach/entry-macro.S
+++ b/arch/arm/plat-mxc/include/mach/entry-macro.S
@@ -33,9 +33,9 @@
 	.macro  arch_ret_to_user, tmp1, tmp2
 	.endm
 
-	@ this macro checks which interrupt occured
+	@ this macro checks which interrupt occurred
 	@ and returns its number in irqnr
-	@ and returns if an interrupt occured in irqstat
+	@ and returns if an interrupt occurred in irqstat
 	.macro	get_irqnr_and_base, irqnr, irqstat, base, tmp
 #ifndef CONFIG_MXC_TZIC
 	@ Load offset & priority of the highest priority
diff --git a/arch/arm/plat-mxc/include/mach/mxc_nand.h b/arch/arm/plat-mxc/include/mach/mxc_nand.h
index 04c0d06..6bb96ef 100644
--- a/arch/arm/plat-mxc/include/mach/mxc_nand.h
+++ b/arch/arm/plat-mxc/include/mach/mxc_nand.h
@@ -24,7 +24,7 @@
 
 struct mxc_nand_platform_data {
 	unsigned int width;	/* data bus width in bytes */
-	unsigned int hw_ecc:1;	/* 0 if supress hardware ECC */
+	unsigned int hw_ecc:1;	/* 0 if suppress hardware ECC */
 	unsigned int flash_bbt:1; /* set to 1 to use a flash based bbt */
 	struct mtd_partition *parts;	/* partition table */
 	int nr_parts;			/* size of parts */
diff --git a/arch/arm/plat-omap/devices.c b/arch/arm/plat-omap/devices.c
index 7d9f815..ea28f98 100644
--- a/arch/arm/plat-omap/devices.c
+++ b/arch/arm/plat-omap/devices.c
@@ -280,7 +280,7 @@ EXPORT_SYMBOL(omap_dsp_get_mempool_base);
  * Claiming GPIOs, and setting their direction and initial values, is the
  * responsibility of the device drivers.  So is responding to probe().
  *
- * Board-specific knowlege like creating devices or pin setup is to be
+ * Board-specific knowledge like creating devices or pin setup is to be
  * kept out of drivers as much as possible.  In particular, pin setup
  * may be handled by the boot loader, and drivers should expect it will
  * normally have been done by the time they're probed.
diff --git a/arch/arm/plat-omap/dma.c b/arch/arm/plat-omap/dma.c
index 2ec3b5d..c22217c 100644
--- a/arch/arm/plat-omap/dma.c
+++ b/arch/arm/plat-omap/dma.c
@@ -1019,7 +1019,7 @@ EXPORT_SYMBOL(omap_set_dma_callback);
  * If the channel is running the caller must disable interrupts prior calling
  * this function and process the returned value before re-enabling interrupt to
  * prevent races with the interrupt handler. Note that in continuous mode there
- * is a chance for CSSA_L register overflow inbetween the two reads resulting
+ * is a chance for CSSA_L register overflow between the two reads resulting
  * in incorrect return value.
  */
 dma_addr_t omap_get_dma_src_pos(int lch)
@@ -1046,7 +1046,7 @@ EXPORT_SYMBOL(omap_get_dma_src_pos);
  * If the channel is running the caller must disable interrupts prior calling
  * this function and process the returned value before re-enabling interrupt to
  * prevent races with the interrupt handler. Note that in continuous mode there
- * is a chance for CDSA_L register overflow inbetween the two reads resulting
+ * is a chance for CDSA_L register overflow between the two reads resulting
  * in incorrect return value.
  */
 dma_addr_t omap_get_dma_dst_pos(int lch)
diff --git a/arch/arm/plat-omap/include/plat/gpio.h b/arch/arm/plat-omap/include/plat/gpio.h
index d6f9fa0..cac2e8a 100644
--- a/arch/arm/plat-omap/include/plat/gpio.h
+++ b/arch/arm/plat-omap/include/plat/gpio.h
@@ -93,7 +93,7 @@ extern void omap_gpio_restore_context(void);
 /* Wrappers for "new style" GPIO calls, using the new infrastructure
  * which lets us plug in FPGA, I2C, and other implementations.
  * *
- * The original OMAP-specfic calls should eventually be removed.
+ * The original OMAP-specific calls should eventually be removed.
  */
 
 #include <linux/errno.h>
diff --git a/arch/arm/plat-omap/include/plat/gpmc.h b/arch/arm/plat-omap/include/plat/gpmc.h
index 12b3161..1527929 100644
--- a/arch/arm/plat-omap/include/plat/gpmc.h
+++ b/arch/arm/plat-omap/include/plat/gpmc.h
@@ -90,7 +90,7 @@ enum omap_ecc {
 		/* 1-bit ecc: stored at end of spare area */
 	OMAP_ECC_HAMMING_CODE_DEFAULT = 0, /* Default, s/w method */
 	OMAP_ECC_HAMMING_CODE_HW, /* gpmc to detect the error */
-		/* 1-bit ecc: stored at begining of spare area as romcode */
+		/* 1-bit ecc: stored at beginning of spare area as romcode */
 	OMAP_ECC_HAMMING_CODE_HW_ROMCODE, /* gpmc method & romcode layout */
 };
 
diff --git a/arch/arm/plat-omap/mcbsp.c b/arch/arm/plat-omap/mcbsp.c
index d598d9f..5587acf 100644
--- a/arch/arm/plat-omap/mcbsp.c
+++ b/arch/arm/plat-omap/mcbsp.c
@@ -1103,7 +1103,7 @@ int omap_mcbsp_pollread(unsigned int id, u16 *buf)
 		/* resend */
 		return -1;
 	} else {
-		/* wait for recieve confirmation */
+		/* wait for receive confirmation */
 		int attemps = 0;
 		while (!(MCBSP_READ(mcbsp, SPCR1) & RRDY)) {
 			if (attemps++ > 1000) {
diff --git a/arch/arm/plat-pxa/include/plat/mfp.h b/arch/arm/plat-pxa/include/plat/mfp.h
index 75f6564..89e68e0 100644
--- a/arch/arm/plat-pxa/include/plat/mfp.h
+++ b/arch/arm/plat-pxa/include/plat/mfp.h
@@ -434,7 +434,7 @@ typedef unsigned long mfp_cfg_t;
  *
  * mfp_init_addr() - accepts a table of "mfp_addr_map" structure, which
  * represents a range of MFP pins from "start" to "end", with the offset
- * begining at "offset", to define a single pin, let "end" = -1.
+ * beginning at "offset", to define a single pin, let "end" = -1.
  *
  * use
  *
diff --git a/arch/arm/plat-s3c24xx/Makefile b/arch/arm/plat-s3c24xx/Makefile
index c2064c3..0291bd6 100644
--- a/arch/arm/plat-s3c24xx/Makefile
+++ b/arch/arm/plat-s3c24xx/Makefile
@@ -23,7 +23,7 @@ obj-$(CONFIG_S3C24XX_DCLK)	+= clock-dclk.o
 obj-$(CONFIG_CPU_FREQ_S3C24XX)	+= cpu-freq.o
 obj-$(CONFIG_CPU_FREQ_S3C24XX_DEBUGFS) += cpu-freq-debugfs.o
 
-# Architecture dependant builds
+# Architecture dependent builds
 
 obj-$(CONFIG_PM_SIMTEC)		+= pm-simtec.o
 obj-$(CONFIG_PM)		+= pm.o
diff --git a/arch/arm/plat-s3c24xx/cpu-freq.c b/arch/arm/plat-s3c24xx/cpu-freq.c
index eea75ff..b3d3d02 100644
--- a/arch/arm/plat-s3c24xx/cpu-freq.c
+++ b/arch/arm/plat-s3c24xx/cpu-freq.c
@@ -455,7 +455,7 @@ static int s3c_cpufreq_resume(struct cpufreq_policy *policy)
 
 	/* whilst we will be called later on, we try and re-set the
 	 * cpu frequencies as soon as possible so that we do not end
-	 * up resuming devices and then immediatley having to re-set
+	 * up resuming devices and then immediately having to re-set
 	 * a number of settings once these devices have restarted.
 	 *
 	 * as a note, it is expected devices are not used until they
diff --git a/arch/arm/plat-s3c24xx/dma.c b/arch/arm/plat-s3c24xx/dma.c
index 6ad274e..27ea852 100644
--- a/arch/arm/plat-s3c24xx/dma.c
+++ b/arch/arm/plat-s3c24xx/dma.c
@@ -557,7 +557,7 @@ s3c2410_dma_lastxfer(struct s3c2410_dma_chan *chan)
 		break;
 
 	case S3C2410_DMALOAD_1LOADED_1RUNNING:
-		/* I belive in this case we do not have anything to do
+		/* I believe in this case we do not have anything to do
 		 * until the next buffer comes along, and we turn off the
 		 * reload */
 		return;
diff --git a/arch/arm/plat-s5p/irq-gpioint.c b/arch/arm/plat-s5p/irq-gpioint.c
index 46dd078..cd6d67c 100644
--- a/arch/arm/plat-s5p/irq-gpioint.c
+++ b/arch/arm/plat-s5p/irq-gpioint.c
@@ -208,7 +208,7 @@ static __init int s5p_gpioint_add(struct s3c_gpio_chip *chip)
 	}
 
 	/*
-	 * chained GPIO irq has been sucessfully registered, allocate new gpio
+	 * chained GPIO irq has been successfully registered, allocate new gpio
 	 * int group and assign irq nubmers
 	 */
 
diff --git a/arch/arm/plat-samsung/include/plat/clock.h b/arch/arm/plat-samsung/include/plat/clock.h
index 9a82b88..983c578 100644
--- a/arch/arm/plat-samsung/include/plat/clock.h
+++ b/arch/arm/plat-samsung/include/plat/clock.h
@@ -21,7 +21,7 @@ struct clk;
  * @set_parent: set the clock's parent, see clk_set_parent().
  *
  * Group the common clock implementations together so that we
- * don't have to keep setting the same fiels again. We leave
+ * don't have to keep setting the same fields again. We leave
  * enable in struct clk.
  *
  * Adding an extra layer of indirection into the process should
diff --git a/arch/arm/plat-samsung/include/plat/gpio-cfg-helpers.h b/arch/arm/plat-samsung/include/plat/gpio-cfg-helpers.h
index 5603db0..3ad8386 100644
--- a/arch/arm/plat-samsung/include/plat/gpio-cfg-helpers.h
+++ b/arch/arm/plat-samsung/include/plat/gpio-cfg-helpers.h
@@ -114,7 +114,7 @@ extern unsigned s3c_gpio_getcfg_s3c24xx_a(struct s3c_gpio_chip *chip,
  * of control per GPIO, generally in the form of:
  *	0000 = Input
  *	0001 = Output
- *	others = Special functions (dependant on bank)
+ *	others = Special functions (dependent on bank)
  *
  * Note, since the code to deal with the case where there are two control
  * registers instead of one, we do not have a separate set of functions for
diff --git a/arch/arm/plat-samsung/include/plat/gpio-cfg.h b/arch/arm/plat-samsung/include/plat/gpio-cfg.h
index 5e04fa6..1762dcb 100644
--- a/arch/arm/plat-samsung/include/plat/gpio-cfg.h
+++ b/arch/arm/plat-samsung/include/plat/gpio-cfg.h
@@ -125,7 +125,7 @@ extern int s3c_gpio_cfgpin_range(unsigned int start, unsigned int nr,
  *
  * These values control the state of the weak pull-{up,down} resistors
  * available on most pins on the S3C series. Not all chips support both
- * up or down settings, and it may be dependant on the chip that is being
+ * up or down settings, and it may be dependent on the chip that is being
  * used to whether the particular mode is available.
  */
 #define S3C_GPIO_PULL_NONE	((__force s3c_gpio_pull_t)0x00)
@@ -138,7 +138,7 @@ extern int s3c_gpio_cfgpin_range(unsigned int start, unsigned int nr,
  * @pull: The configuration for the pull resistor.
  *
  * This function sets the state of the pull-{up,down} resistor for the
- * specified pin. It will return 0 if successfull, or a negative error
+ * specified pin. It will return 0 if successful, or a negative error
  * code if the pin cannot support the requested pull setting.
  *
  * @pull is one of S3C_GPIO_PULL_NONE, S3C_GPIO_PULL_DOWN or S3C_GPIO_PULL_UP.
@@ -202,7 +202,7 @@ extern s5p_gpio_drvstr_t s5p_gpio_get_drvstr(unsigned int pin);
  * @drvstr: The new value of the driver strength
  *
  * This function sets the driver strength value for the specified pin.
- * It will return 0 if successfull, or a negative error code if the pin
+ * It will return 0 if successful, or a negative error code if the pin
  * cannot support the requested setting.
 */
 extern int s5p_gpio_set_drvstr(unsigned int pin, s5p_gpio_drvstr_t drvstr);
diff --git a/arch/arm/plat-samsung/include/plat/gpio-core.h b/arch/arm/plat-samsung/include/plat/gpio-core.h
index dac35d0..8cad4cf 100644
--- a/arch/arm/plat-samsung/include/plat/gpio-core.h
+++ b/arch/arm/plat-samsung/include/plat/gpio-core.h
@@ -108,7 +108,7 @@ extern void s3c_gpiolib_add(struct s3c_gpio_chip *chip);
  * of control per GPIO, generally in the form of:
  * 0000 = Input
  * 0001 = Output
- * others = Special functions (dependant on bank)
+ * others = Special functions (dependent on bank)
  *
  * Note, since the code to deal with the case where there are two control
  * registers instead of one, we do not have a separate set of function
diff --git a/arch/arm/plat-samsung/include/plat/sdhci.h b/arch/arm/plat-samsung/include/plat/sdhci.h
index b0bdf16..058e096 100644
--- a/arch/arm/plat-samsung/include/plat/sdhci.h
+++ b/arch/arm/plat-samsung/include/plat/sdhci.h
@@ -57,7 +57,7 @@ enum clk_types {
  * @cfg_gpio: Configure the GPIO for a specific card bit-width
  * @cfg_card: Configure the interface for a specific card and speed. This
  *            is necessary the controllers and/or GPIO blocks require the
- *	      changing of driver-strength and other controls dependant on
+ *	      changing of driver-strength and other controls dependent on
  *	      the card and speed of operation.
  *
  * Initialisation data specific to either the machine or the platform
@@ -108,7 +108,7 @@ extern struct s3c_sdhci_platdata s3c_hsmmc1_def_platdata;
 extern struct s3c_sdhci_platdata s3c_hsmmc2_def_platdata;
 extern struct s3c_sdhci_platdata s3c_hsmmc3_def_platdata;
 
-/* Helper function availablity */
+/* Helper function availability */
 
 extern void s3c2416_setup_sdhci0_cfg_gpio(struct platform_device *, int w);
 extern void s3c2416_setup_sdhci1_cfg_gpio(struct platform_device *, int w);
diff --git a/arch/arm/plat-samsung/s3c-pl330.c b/arch/arm/plat-samsung/s3c-pl330.c
index b4ff8d7..f85638c 100644
--- a/arch/arm/plat-samsung/s3c-pl330.c
+++ b/arch/arm/plat-samsung/s3c-pl330.c
@@ -68,7 +68,7 @@ struct s3c_pl330_xfer {
  * @req: Two requests to communicate with the PL330 engine.
  * @callback_fn: Callback function to the client.
  * @rqcfg: Channel configuration for the xfers.
- * @xfer_head: Pointer to the xfer to be next excecuted.
+ * @xfer_head: Pointer to the xfer to be next executed.
  * @dmac: Pointer to the DMAC that manages this channel, NULL if the
  * 	channel is available to be acquired.
  * @client: Client of this channel. NULL if the
diff --git a/arch/arm/plat-spear/include/plat/clock.h b/arch/arm/plat-spear/include/plat/clock.h
index 2ae6606..fcc0d0a 100644
--- a/arch/arm/plat-spear/include/plat/clock.h
+++ b/arch/arm/plat-spear/include/plat/clock.h
@@ -89,7 +89,7 @@ struct rate_config {
  * @sibling: node for list of clocks having same parents
  * @private_data: clock specific private data
  * @node: list to maintain clocks linearly
- * @cl: clocklook up assoicated with this clock
+ * @cl: clocklook up associated with this clock
  * @dent: object for debugfs
  */
 struct clk {
diff --git a/arch/blackfin/Kconfig.debug b/arch/blackfin/Kconfig.debug
index acb8379..2641731 100644
--- a/arch/blackfin/Kconfig.debug
+++ b/arch/blackfin/Kconfig.debug
@@ -59,7 +59,7 @@ config EXACT_HWERR
           be reported multiple cycles after the error happens. This delay
 	  can cause the wrong application, or even the kernel to receive a
 	  signal to be killed. If you are getting HW errors in your system,
-	  try turning this on to ensure they are at least comming from the
+	  try turning this on to ensure they are at least coming from the
 	  proper thread.
 
 	  On production systems, it is safe (and a small optimization) to say N.
diff --git a/arch/blackfin/include/asm/traps.h b/arch/blackfin/include/asm/traps.h
index 9fe0da6..70c4e51 100644
--- a/arch/blackfin/include/asm/traps.h
+++ b/arch/blackfin/include/asm/traps.h
@@ -57,7 +57,7 @@
 #define HWC_x3(level) \
 	"External Memory Addressing Error\n"
 #define EXC_0x04(level) \
-	"Unimplmented exception occured\n" \
+	"Unimplmented exception occurred\n" \
 	level " - Maybe you forgot to install a custom exception handler?\n"
 #define HWC_x12(level) \
 	"Performance Monitor Overflow\n"
diff --git a/arch/blackfin/kernel/kgdb.c b/arch/blackfin/kernel/kgdb.c
index b8cfe34..9b80b15 100644
--- a/arch/blackfin/kernel/kgdb.c
+++ b/arch/blackfin/kernel/kgdb.c
@@ -181,7 +181,7 @@ static int bfin_set_hw_break(unsigned long addr, int len, enum kgdb_bptype type)
 		return -ENOSPC;
 	}
 
-	/* Becasue hardware data watchpoint impelemented in current
+	/* Because hardware data watchpoint impelemented in current
 	 * Blackfin can not trigger an exception event as the hardware
 	 * instrction watchpoint does, we ignaore all data watch point here.
 	 * They can be turned on easily after future blackfin design
diff --git a/arch/blackfin/kernel/traps.c b/arch/blackfin/kernel/traps.c
index 59c1df7..655f25d 100644
--- a/arch/blackfin/kernel/traps.c
+++ b/arch/blackfin/kernel/traps.c
@@ -98,7 +98,7 @@ asmlinkage notrace void trap_c(struct pt_regs *fp)
 	/* send the appropriate signal to the user program */
 	switch (trapnr) {
 
-	/* This table works in conjuction with the one in ./mach-common/entry.S
+	/* This table works in conjunction with the one in ./mach-common/entry.S
 	 * Some exceptions are handled there (in assembly, in exception space)
 	 * Some are handled here, (in C, in interrupt space)
 	 * Some, like CPLB, are handled in both, where the normal path is
diff --git a/arch/blackfin/lib/ins.S b/arch/blackfin/lib/ins.S
index 3edbd8d..79cacce 100644
--- a/arch/blackfin/lib/ins.S
+++ b/arch/blackfin/lib/ins.S
@@ -67,7 +67,7 @@
  *  - DMA version, which do not suffer from this issue. DMA versions have
  *      different name (prefixed by dma_ ), and are located in
  *      ../kernel/bfin_dma_5xx.c
- * Using the dma related functions are recommended for transfering large
+ * Using the dma related functions are recommended for transferring large
  * buffers in/out of FIFOs.
  */
 
diff --git a/arch/blackfin/lib/memmove.S b/arch/blackfin/lib/memmove.S
index 80c240a..4eca566 100644
--- a/arch/blackfin/lib/memmove.S
+++ b/arch/blackfin/lib/memmove.S
@@ -60,7 +60,7 @@ ENTRY(_memmove)
 	[P0++] = R1;
 
 	CC = P2 == 0;             /* any remaining bytes? */
-	P3 = I0;                  /* Ammend P3 to updated ptr. */
+	P3 = I0;                  /* Amend P3 to updated ptr. */
 	IF !CC JUMP .Lbytes;
 	P3 = I1;
 	RTS;
diff --git a/arch/blackfin/mach-bf537/boards/stamp.c b/arch/blackfin/mach-bf537/boards/stamp.c
index 2c69785..3fa3354 100644
--- a/arch/blackfin/mach-bf537/boards/stamp.c
+++ b/arch/blackfin/mach-bf537/boards/stamp.c
@@ -2530,7 +2530,7 @@ static struct resource bfin_pata_resources[] = {
 static struct pata_platform_info bfin_pata_platform_data = {
 	.ioport_shift = 0,
 };
-/* CompactFlash Storage Card Memory Mapped Adressing
+/* CompactFlash Storage Card Memory Mapped Addressing
  * /REG = A11 = 1
  */
 static struct resource bfin_pata_resources[] = {
diff --git a/arch/blackfin/mach-common/entry.S b/arch/blackfin/mach-common/entry.S
index 46ab457..f96933f 100644
--- a/arch/blackfin/mach-common/entry.S
+++ b/arch/blackfin/mach-common/entry.S
@@ -268,7 +268,7 @@ ENTRY(_handle_bad_cplb)
 	/* To get here, we just tried and failed to change a CPLB
 	 * so, handle things in trap_c (C code), by lowering to
 	 * IRQ5, just like we normally do. Since this is not a
-	 * "normal" return path, we have a do alot of stuff to
+	 * "normal" return path, we have a do a lot of stuff to
 	 * the stack to get ready so, we can fall through - we
 	 * need to make a CPLB exception look like a normal exception
 	 */
@@ -817,7 +817,7 @@ _new_old_task:
 	rets = [sp++];
 
 	/*
-	 * When we come out of resume, r0 carries "old" task, becuase we are
+	 * When we come out of resume, r0 carries "old" task, because we are
 	 * in "new" task.
 	 */
 	rts;
diff --git a/arch/blackfin/mach-common/head.S b/arch/blackfin/mach-common/head.S
index 581e2b0..76de572 100644
--- a/arch/blackfin/mach-common/head.S
+++ b/arch/blackfin/mach-common/head.S
@@ -174,7 +174,7 @@ ENTRY(__start)
 	sp.l = lo(KERNEL_CLOCK_STACK);
 	sp.h = hi(KERNEL_CLOCK_STACK);
 	call _init_clocks;
-	sp = usp;	/* usp hasnt been touched, so restore from there */
+	sp = usp;	/* usp hasn't been touched, so restore from there */
 #endif
 
 	/* This section keeps the processor in supervisor mode
diff --git a/arch/cris/arch-v10/README.mm b/arch/cris/arch-v10/README.mm
index 517d1f0..67731d7 100644
--- a/arch/cris/arch-v10/README.mm
+++ b/arch/cris/arch-v10/README.mm
@@ -38,7 +38,7 @@ space. We also use it to keep the user-mode virtual mapping in the same
 map during kernel-mode, so that the kernel easily can access the corresponding
 user-mode process' data.
 
-As a comparision, the Linux/i386 2.0 puts the kernel and physical RAM at
+As a comparison, the Linux/i386 2.0 puts the kernel and physical RAM at
 address 0, overlapping with the user-mode virtual space, so that descriptor
 registers are needed for each memory access to specify which MMU space to
 map through. That changed in 2.2, putting the kernel/physical RAM at 
diff --git a/arch/cris/arch-v10/drivers/sync_serial.c b/arch/cris/arch-v10/drivers/sync_serial.c
index 399dc1e..85026537 100644
--- a/arch/cris/arch-v10/drivers/sync_serial.c
+++ b/arch/cris/arch-v10/drivers/sync_serial.c
@@ -31,7 +31,7 @@
 #include <asm/sync_serial.h>
 #include <arch/io_interface_mux.h>
 
-/* The receiver is a bit tricky beacuse of the continuous stream of data.*/
+/* The receiver is a bit tricky because of the continuous stream of data.*/
 /*                                                                       */
 /* Three DMA descriptors are linked together. Each DMA descriptor is     */
 /* responsible for port->bufchunk of a common buffer.                    */
diff --git a/arch/cris/arch-v32/drivers/axisflashmap.c b/arch/cris/arch-v32/drivers/axisflashmap.c
index 3d75125..7b155f8 100644
--- a/arch/cris/arch-v32/drivers/axisflashmap.c
+++ b/arch/cris/arch-v32/drivers/axisflashmap.c
@@ -215,7 +215,7 @@ static struct mtd_partition main_partition = {
 };
 #endif
 
-/* Auxilliary partition if we find another flash */
+/* Auxiliary partition if we find another flash */
 static struct mtd_partition aux_partition = {
 	.name = "aux",
 	.size = 0,
diff --git a/arch/cris/arch-v32/drivers/mach-a3/nandflash.c b/arch/cris/arch-v32/drivers/mach-a3/nandflash.c
index 25d6f2b..f58f2c1 100644
--- a/arch/cris/arch-v32/drivers/mach-a3/nandflash.c
+++ b/arch/cris/arch-v32/drivers/mach-a3/nandflash.c
@@ -165,7 +165,7 @@ struct mtd_info *__init crisv32_nand_flash_probe(void)
 	/* Enable the following for a flash based bad block table */
 	/* this->options = NAND_USE_FLASH_BBT; */
 
-	/* Scan to find existance of the device */
+	/* Scan to find existence of the device */
 	if (nand_scan(crisv32_mtd, 1)) {
 		err = -ENXIO;
 		goto out_mtd;
diff --git a/arch/cris/arch-v32/drivers/mach-fs/nandflash.c b/arch/cris/arch-v32/drivers/mach-fs/nandflash.c
index c5a0f54..d5b0cc9 100644
--- a/arch/cris/arch-v32/drivers/mach-fs/nandflash.c
+++ b/arch/cris/arch-v32/drivers/mach-fs/nandflash.c
@@ -156,7 +156,7 @@ struct mtd_info *__init crisv32_nand_flash_probe(void)
 	/* Enable the following for a flash based bad block table */
 	/* this->options = NAND_USE_FLASH_BBT; */
 
-	/* Scan to find existance of the device */
+	/* Scan to find existence of the device */
 	if (nand_scan(crisv32_mtd, 1)) {
 		err = -ENXIO;
 		goto out_ior;
diff --git a/arch/cris/arch-v32/drivers/sync_serial.c b/arch/cris/arch-v32/drivers/sync_serial.c
index c8637a9..a6a180b 100644
--- a/arch/cris/arch-v32/drivers/sync_serial.c
+++ b/arch/cris/arch-v32/drivers/sync_serial.c
@@ -33,7 +33,7 @@
 #include <asm/sync_serial.h>
 
 
-/* The receiver is a bit tricky beacuse of the continuous stream of data.*/
+/* The receiver is a bit tricky because of the continuous stream of data.*/
 /*                                                                       */
 /* Three DMA descriptors are linked together. Each DMA descriptor is     */
 /* responsible for port->bufchunk of a common buffer.                    */
diff --git a/arch/cris/arch-v32/kernel/entry.S b/arch/cris/arch-v32/kernel/entry.S
index 0ecb50b..3abf12c 100644
--- a/arch/cris/arch-v32/kernel/entry.S
+++ b/arch/cris/arch-v32/kernel/entry.S
@@ -182,7 +182,7 @@ _syscall_traced:
 	move.d	$r0, [$sp]
 
 	;; The registers carrying parameters (R10-R13) are intact. The optional
-	;; fifth and sixth parameters is in MOF and SRP respectivly. Put them
+	;; fifth and sixth parameters is in MOF and SRP respectively. Put them
 	;; back on the stack.
 	subq	4, $sp
 	move	$srp, [$sp]
diff --git a/arch/cris/arch-v32/kernel/irq.c b/arch/cris/arch-v32/kernel/irq.c
index 8023176..68a1a59 100644
--- a/arch/cris/arch-v32/kernel/irq.c
+++ b/arch/cris/arch-v32/kernel/irq.c
@@ -374,7 +374,7 @@ crisv32_do_multiple(struct pt_regs* regs)
 	irq_enter();
 
 	for (i = 0; i < NBR_REGS; i++) {
-		/* Get which IRQs that happend. */
+		/* Get which IRQs that happened. */
 		masked[i] = REG_RD_INT_VECT(intr_vect, irq_regs[cpu],
 			r_masked_vect, i);
 
diff --git a/arch/cris/arch-v32/kernel/kgdb.c b/arch/cris/arch-v32/kernel/kgdb.c
index 6b65332..c0343c3 100644
--- a/arch/cris/arch-v32/kernel/kgdb.c
+++ b/arch/cris/arch-v32/kernel/kgdb.c
@@ -925,7 +925,7 @@ stub_is_stopped(int sigval)
 
 					if (reg.eda >= bp_d_regs[bp * 2] &&
 					    reg.eda <= bp_d_regs[bp * 2 + 1]) {
-						/* EDA withing range for this BP; it must be the one
+						/* EDA within range for this BP; it must be the one
 						   we're looking for. */
 						stopped_data_address = reg.eda;
 						break;
diff --git a/arch/cris/arch-v32/kernel/process.c b/arch/cris/arch-v32/kernel/process.c
index 562f847..0570e8c 100644
--- a/arch/cris/arch-v32/kernel/process.c
+++ b/arch/cris/arch-v32/kernel/process.c
@@ -149,7 +149,7 @@ copy_thread(unsigned long clone_flags, unsigned long usp,
         childregs->r10 = 0;	/* Child returns 0 after a fork/clone. */
 
 	/* Set a new TLS ?
-	 * The TLS is in $mof beacuse it is the 5th argument to sys_clone.
+	 * The TLS is in $mof because it is the 5th argument to sys_clone.
 	 */
 	if (p->mm && (clone_flags & CLONE_SETTLS)) {
 		task_thread_info(p)->tls = regs->mof;
diff --git a/arch/cris/arch-v32/kernel/signal.c b/arch/cris/arch-v32/kernel/signal.c
index b3a05ae..ce4ab1a 100644
--- a/arch/cris/arch-v32/kernel/signal.c
+++ b/arch/cris/arch-v32/kernel/signal.c
@@ -610,7 +610,7 @@ ugdb_trap_user(struct thread_info *ti, int sig)
 		user_regs(ti)->spc = 0;
 	}
 	/* FIXME: Filter out false h/w breakpoint hits (i.e. EDA
-	   not withing any configured h/w breakpoint range). Synchronize with
+	   not within any configured h/w breakpoint range). Synchronize with
 	   what already exists for kernel debugging.  */
 	if (((user_regs(ti)->exs & 0xff00) >> 8) == BREAK_8_INTR_VECT) {
 		/* Break 8: subtract 2 from ERP unless in a delay slot. */
diff --git a/arch/cris/arch-v32/mach-a3/arbiter.c b/arch/cris/arch-v32/mach-a3/arbiter.c
index 8b924db..15f5c9d 100644
--- a/arch/cris/arch-v32/mach-a3/arbiter.c
+++ b/arch/cris/arch-v32/mach-a3/arbiter.c
@@ -568,7 +568,7 @@ crisv32_foo_arbiter_irq(int irq, void *dev_id)
 	REG_WR(marb_foo_bp, watch->instance, rw_ack, ack);
 	REG_WR(marb_foo, regi_marb_foo, rw_ack_intr, ack_intr);
 
-	printk(KERN_DEBUG "IRQ occured at %X\n", (unsigned)get_irq_regs());
+	printk(KERN_DEBUG "IRQ occurred at %X\n", (unsigned)get_irq_regs());
 
 	if (watch->cb)
 		watch->cb();
@@ -624,7 +624,7 @@ crisv32_bar_arbiter_irq(int irq, void *dev_id)
 	REG_WR(marb_bar_bp, watch->instance, rw_ack, ack);
 	REG_WR(marb_bar, regi_marb_bar, rw_ack_intr, ack_intr);
 
-	printk(KERN_DEBUG "IRQ occured at %X\n", (unsigned)get_irq_regs()->erp);
+	printk(KERN_DEBUG "IRQ occurred at %X\n", (unsigned)get_irq_regs()->erp);
 
 	if (watch->cb)
 		watch->cb();
diff --git a/arch/cris/arch-v32/mach-fs/arbiter.c b/arch/cris/arch-v32/mach-fs/arbiter.c
index 82ef293..3f8ebb5 100644
--- a/arch/cris/arch-v32/mach-fs/arbiter.c
+++ b/arch/cris/arch-v32/mach-fs/arbiter.c
@@ -395,7 +395,7 @@ static irqreturn_t crisv32_arbiter_irq(int irq, void *dev_id)
 	REG_WR(marb_bp, watch->instance, rw_ack, ack);
 	REG_WR(marb, regi_marb, rw_ack_intr, ack_intr);
 
-	printk(KERN_INFO "IRQ occured at %lX\n", get_irq_regs()->erp);
+	printk(KERN_INFO "IRQ occurred at %lX\n", get_irq_regs()->erp);
 
 	if (watch->cb)
 		watch->cb();
diff --git a/arch/cris/boot/rescue/head_v10.S b/arch/cris/boot/rescue/head_v10.S
index 2fafe24..af55df0 100644
--- a/arch/cris/boot/rescue/head_v10.S
+++ b/arch/cris/boot/rescue/head_v10.S
@@ -7,7 +7,7 @@
  * for each partition that this code should check.
  *
  * If any of the checksums fail, we assume the flash is so
- * corrupt that we cant use it to boot into the ftp flash
+ * corrupt that we can't use it to boot into the ftp flash
  * loader, and instead we initialize the serial port to
  * receive a flash-loader and new flash image. we dont include
  * any flash code here, but just accept a certain amount of
diff --git a/arch/cris/include/arch-v32/arch/hwregs/Makefile b/arch/cris/include/arch-v32/arch/hwregs/Makefile
index f9a05d2..b8b3f8d 100644
--- a/arch/cris/include/arch-v32/arch/hwregs/Makefile
+++ b/arch/cris/include/arch-v32/arch/hwregs/Makefile
@@ -1,6 +1,6 @@
 # Makefile to generate or copy the latest register definitions
 # and related datastructures and helpermacros.
-# The offical place for these files is at:
+# The official place for these files is at:
 RELEASE ?= r1_alfa5
 OFFICIAL_INCDIR = /n/asic/projects/guinness/releases/$(RELEASE)/design/top/sw/include/
 
diff --git a/arch/cris/include/arch-v32/arch/hwregs/iop/Makefile b/arch/cris/include/arch-v32/arch/hwregs/iop/Makefile
index a90056a..0747a22 100644
--- a/arch/cris/include/arch-v32/arch/hwregs/iop/Makefile
+++ b/arch/cris/include/arch-v32/arch/hwregs/iop/Makefile
@@ -1,7 +1,7 @@
 # $Id: Makefile,v 1.3 2004/01/07 20:34:55 johana Exp $
 # Makefile to generate or copy the latest register definitions
 # and related datastructures and helpermacros.
-# The offical place for these files is probably at:
+# The official place for these files is probably at:
 RELEASE ?= r1_alfa5
 IOPOFFICIAL_INCDIR = /n/asic/projects/guinness/releases/$(RELEASE)/design/top/sw/include/
 
diff --git a/arch/cris/include/asm/pgtable.h b/arch/cris/include/asm/pgtable.h
index 9eaae21..7df4301 100644
--- a/arch/cris/include/asm/pgtable.h
+++ b/arch/cris/include/asm/pgtable.h
@@ -97,7 +97,7 @@ extern unsigned long empty_zero_page;
 #define pte_clear(mm,addr,xp)	do { pte_val(*(xp)) = 0; } while (0)
 
 #define pmd_none(x)     (!pmd_val(x))
-/* by removing the _PAGE_KERNEL bit from the comparision, the same pmd_bad
+/* by removing the _PAGE_KERNEL bit from the comparison, the same pmd_bad
  * works for both _PAGE_TABLE and _KERNPG_TABLE pmd entries.
  */
 #define	pmd_bad(x)	((pmd_val(x) & (~PAGE_MASK & ~_PAGE_KERNEL)) != _PAGE_TABLE)
diff --git a/arch/cris/kernel/traps.c b/arch/cris/kernel/traps.c
index 541efbf0..8da53f3 100644
--- a/arch/cris/kernel/traps.c
+++ b/arch/cris/kernel/traps.c
@@ -183,7 +183,7 @@ __initcall(oops_nmi_register);
 
 /*
  * This gets called from entry.S when the watchdog has bitten. Show something
- * similiar to an Oops dump, and if the kernel is configured to be a nice
+ * similar to an Oops dump, and if the kernel is configured to be a nice
  * doggy, then halt instead of reboot.
  */
 void
diff --git a/arch/frv/include/asm/pci.h b/arch/frv/include/asm/pci.h
index 0d59979..ef03baf 100644
--- a/arch/frv/include/asm/pci.h
+++ b/arch/frv/include/asm/pci.h
@@ -54,7 +54,7 @@ static inline void pci_dma_burst_advice(struct pci_dev *pdev,
 #endif
 
 /*
- *	These are pretty much arbitary with the CoMEM implementation.
+ *	These are pretty much arbitrary with the CoMEM implementation.
  *	We have the whole address space to ourselves.
  */
 #define PCIBIOS_MIN_IO		0x100
diff --git a/arch/frv/include/asm/spr-regs.h b/arch/frv/include/asm/spr-regs.h
index 01e6af5..d388302 100644
--- a/arch/frv/include/asm/spr-regs.h
+++ b/arch/frv/include/asm/spr-regs.h
@@ -274,7 +274,7 @@
 #define MSR0_RD			0xc0000000	/* rounding mode */
 #define MSR0_RD_NEAREST		0x00000000	/* - nearest */
 #define MSR0_RD_ZERO		0x40000000	/* - zero */
-#define MSR0_RD_POS_INF		0x80000000	/* - postive infinity */
+#define MSR0_RD_POS_INF		0x80000000	/* - positive infinity */
 #define MSR0_RD_NEG_INF		0xc0000000	/* - negative infinity */
 
 /*
diff --git a/arch/frv/include/asm/virtconvert.h b/arch/frv/include/asm/virtconvert.h
index 59788fa..b26d70a 100644
--- a/arch/frv/include/asm/virtconvert.h
+++ b/arch/frv/include/asm/virtconvert.h
@@ -1,4 +1,4 @@
-/* virtconvert.h: virtual/physical/page address convertion
+/* virtconvert.h: virtual/physical/page address conversion
  *
  * Copyright (C) 2004 Red Hat, Inc. All Rights Reserved.
  * Written by David Howells (dhowells@redhat.com)
diff --git a/arch/frv/kernel/entry-table.S b/arch/frv/kernel/entry-table.S
index bf35f33..06c5ae1 100644
--- a/arch/frv/kernel/entry-table.S
+++ b/arch/frv/kernel/entry-table.S
@@ -86,7 +86,7 @@ __break_usertrap_fixup_table:
 	.globl		__break_kerneltrap_fixup_table
 __break_kerneltrap_fixup_table:
 
-	# handler declaration for a sofware or program interrupt
+	# handler declaration for a software or program interrupt
 .macro VECTOR_SOFTPROG tbr_tt, vec
 	.section .trap.user
 	.org		\tbr_tt
@@ -145,7 +145,7 @@ __break_kerneltrap_fixup_table:
 	.long		\vec
 .endm
 
-	# handler declaration for an MMU only sofware or program interrupt
+	# handler declaration for an MMU only software or program interrupt
 .macro VECTOR_SP_MMU tbr_tt, vec
 #ifdef CONFIG_MMU
  	VECTOR_SOFTPROG	\tbr_tt, \vec
diff --git a/arch/ia64/Kconfig b/arch/ia64/Kconfig
index c4ea092..e5cc56a 100644
--- a/arch/ia64/Kconfig
+++ b/arch/ia64/Kconfig
@@ -414,11 +414,11 @@ config PERMIT_BSP_REMOVE
 	support. 
 
 config FORCE_CPEI_RETARGET
-	bool "Force assumption that CPEI can be re-targetted"
+	bool "Force assumption that CPEI can be re-targeted"
 	depends on PERMIT_BSP_REMOVE
 	default n
 	---help---
-	Say Y if you need to force the assumption that CPEI can be re-targetted to
+	Say Y if you need to force the assumption that CPEI can be re-targeted to
 	any cpu in the system. This hint is available via ACPI 3.0 specifications.
 	Tiger4 systems are capable of re-directing CPEI to any CPU other than BSP.
 	This option it useful to enable this feature on older BIOS's as well.
diff --git a/arch/ia64/include/asm/pal.h b/arch/ia64/include/asm/pal.h
index 6a29250..2e69284 100644
--- a/arch/ia64/include/asm/pal.h
+++ b/arch/ia64/include/asm/pal.h
@@ -1669,7 +1669,7 @@ typedef union pal_vp_info_u {
 } pal_vp_info_u_t;
 
 /*
- * Returns infomation about virtual processor features
+ * Returns information about virtual processor features
  */
 static inline s64
 ia64_pal_vp_info (u64 feature_set, u64 vp_buffer, u64 *vp_info, u64 *vmm_id)
diff --git a/arch/ia64/include/asm/perfmon_default_smpl.h b/arch/ia64/include/asm/perfmon_default_smpl.h
index 74724b2..a2d560c 100644
--- a/arch/ia64/include/asm/perfmon_default_smpl.h
+++ b/arch/ia64/include/asm/perfmon_default_smpl.h
@@ -67,8 +67,8 @@ typedef struct {
         unsigned long   ip;                     /* where did the overflow interrupt happened  */
         unsigned long   tstamp;                 /* ar.itc when entering perfmon intr. handler */
 
-        unsigned short  cpu;                    /* cpu on which the overflow occured */
-        unsigned short  set;                    /* event set active when overflow ocurred   */
+        unsigned short  cpu;                    /* cpu on which the overflow occurred */
+        unsigned short  set;                    /* event set active when overflow occurred   */
         int    		tgid;              	/* thread group id (for NPTL, this is getpid()) */
 } pfm_default_smpl_entry_t;
 
diff --git a/arch/ia64/include/asm/sn/bte.h b/arch/ia64/include/asm/sn/bte.h
index 96798d2..cc6c4db 100644
--- a/arch/ia64/include/asm/sn/bte.h
+++ b/arch/ia64/include/asm/sn/bte.h
@@ -216,7 +216,7 @@ extern void bte_error_handler(unsigned long);
 	bte_copy(0, dest, len, ((mode) | BTE_ZERO_FILL), notification)
 
 /*
- * The following is the prefered way of calling bte_unaligned_copy
+ * The following is the preferred way of calling bte_unaligned_copy
  * If the copy is fully cache line aligned, then bte_copy is
  * used instead.  Since bte_copy is inlined, this saves a call
  * stack.  NOTE: bte_copy is called synchronously and does block
diff --git a/arch/ia64/include/asm/sn/shub_mmr.h b/arch/ia64/include/asm/sn/shub_mmr.h
index 7de1d1d..a84d870 100644
--- a/arch/ia64/include/asm/sn/shub_mmr.h
+++ b/arch/ia64/include/asm/sn/shub_mmr.h
@@ -459,7 +459,7 @@
 /* ==================================================================== */
 /* Some MMRs are functionally identical (or close enough) on both SHUB1 */
 /* and SHUB2 that it makes sense to define a geberic name for the MMR.  */
-/* It is acceptible to use (for example) SH_IPI_INT to reference the    */
+/* It is acceptable to use (for example) SH_IPI_INT to reference the    */
 /* the IPI MMR. The value of SH_IPI_INT is determined at runtime based  */
 /* on the type of the SHUB. Do not use these #defines in performance    */
 /* critical code  or loops - there is a small performance penalty.      */
diff --git a/arch/ia64/include/asm/sn/shubio.h b/arch/ia64/include/asm/sn/shubio.h
index 6052422..ecb8a49 100644
--- a/arch/ia64/include/asm/sn/shubio.h
+++ b/arch/ia64/include/asm/sn/shubio.h
@@ -1383,7 +1383,7 @@ typedef union ii_ibcr_u {
  * response is capture in IXSM and IXSS, and IXSS[VALID] is set. The    *
  * errant header is thereby captured, and no further spurious read      *
  * respones are captured until IXSS[VALID] is cleared by setting the    *
- * appropriate bit in IECLR.Everytime a spurious read response is       *
+ * appropriate bit in IECLR. Every time a spurious read response is     *
  * detected, the SPUR_RD bit of the PRB corresponding to the incoming   *
  * message's SIDN field is set. This always happens, regarless of       *
  * whether a header is captured. The programmer should check            *
@@ -2738,7 +2738,7 @@ typedef union ii_ippr_u {
 /************************************************************************
  *									*
  * The following defines which were not formed into structures are	*
- * probably indentical to another register, and the name of the		*
+ * probably identical to another register, and the name of the		*
  * register is provided against each of these registers. This		*
  * information needs to be checked carefully				*
  *									*
diff --git a/arch/ia64/kernel/cyclone.c b/arch/ia64/kernel/cyclone.c
index d52f1f7..1b811c6 100644
--- a/arch/ia64/kernel/cyclone.c
+++ b/arch/ia64/kernel/cyclone.c
@@ -31,7 +31,7 @@ static struct clocksource clocksource_cyclone = {
         .rating         = 300,
         .read           = read_cyclone,
         .mask           = (1LL << 40) - 1,
-        .mult           = 0, /*to be caluclated*/
+        .mult           = 0, /*to be calculated*/
         .shift          = 16,
         .flags          = CLOCK_SOURCE_IS_CONTINUOUS,
 };
diff --git a/arch/ia64/kernel/perfmon_default_smpl.c b/arch/ia64/kernel/perfmon_default_smpl.c
index 5f637bb..30c644e 100644
--- a/arch/ia64/kernel/perfmon_default_smpl.c
+++ b/arch/ia64/kernel/perfmon_default_smpl.c
@@ -150,7 +150,7 @@ default_handler(struct task_struct *task, void *buf, pfm_ovfl_arg_t *arg, struct
 	 * current = task running at the time of the overflow.
 	 *
 	 * per-task mode:
-	 * 	- this is ususally the task being monitored.
+	 * 	- this is usually the task being monitored.
 	 * 	  Under certain conditions, it might be a different task
 	 *
 	 * system-wide:
diff --git a/arch/ia64/kernel/smpboot.c b/arch/ia64/kernel/smpboot.c
index 44f11ee..14ec641 100644
--- a/arch/ia64/kernel/smpboot.c
+++ b/arch/ia64/kernel/smpboot.c
@@ -703,7 +703,7 @@ int migrate_platform_irqs(unsigned int cpu)
 				data->chip->irq_disable(data);
 				data->chip->irq_set_affinity(data, mask, false);
 				data->chip->irq_enable(data);
-				printk ("Re-targetting CPEI to cpu %d\n", new_cpei_cpu);
+				printk ("Re-targeting CPEI to cpu %d\n", new_cpei_cpu);
 			}
 		}
 		if (!data) {
diff --git a/arch/ia64/kernel/topology.c b/arch/ia64/kernel/topology.c
index 0baa1bb..0e0e0cc 100644
--- a/arch/ia64/kernel/topology.c
+++ b/arch/ia64/kernel/topology.c
@@ -43,7 +43,7 @@ int __ref arch_register_cpu(int num)
 {
 #ifdef CONFIG_ACPI
 	/*
-	 * If CPEI can be re-targetted or if this is not
+	 * If CPEI can be re-targeted or if this is not
 	 * CPEI target, then it is hotpluggable
 	 */
 	if (can_cpei_retarget() || !is_cpu_cpei_target(num))
diff --git a/arch/ia64/kvm/process.c b/arch/ia64/kvm/process.c
index bb862fb..b039874 100644
--- a/arch/ia64/kvm/process.c
+++ b/arch/ia64/kvm/process.c
@@ -987,7 +987,7 @@ static void vmm_sanity_check(struct kvm_vcpu *vcpu)
 
 static void kvm_do_resume_op(struct kvm_vcpu *vcpu)
 {
-	vmm_sanity_check(vcpu); /*Guarantee vcpu runing on healthy vmm!*/
+	vmm_sanity_check(vcpu); /*Guarantee vcpu running on healthy vmm!*/
 
 	if (test_and_clear_bit(KVM_REQ_RESUME, &vcpu->requests)) {
 		vcpu_do_resume(vcpu);
diff --git a/arch/ia64/lib/do_csum.S b/arch/ia64/lib/do_csum.S
index 6bec2fc..1a431a5 100644
--- a/arch/ia64/lib/do_csum.S
+++ b/arch/ia64/lib/do_csum.S
@@ -201,7 +201,7 @@ GLOBAL_ENTRY(do_csum)
 	;;
 (p6)	adds result1[0]=1,result1[0]
 (p9)	br.cond.sptk .do_csum_exit	// if (count == 1) exit
-	// Fall through to caluculate the checksum, feeding result1[0] as
+	// Fall through to calculate the checksum, feeding result1[0] as
 	// the initial value in result1[0].
 	//
 	// Calculate the checksum loading two 8-byte words per loop.
diff --git a/arch/ia64/sn/kernel/irq.c b/arch/ia64/sn/kernel/irq.c
index 139c018..81a1f4e 100644
--- a/arch/ia64/sn/kernel/irq.c
+++ b/arch/ia64/sn/kernel/irq.c
@@ -227,7 +227,7 @@ void sn_set_err_irq_affinity(unsigned int irq)
 {
         /*
          * On systems which support CPU disabling (SHub2), all error interrupts
-         * are targetted at the boot CPU.
+         * are targeted at the boot CPU.
          */
         if (is_shub2() && sn_prom_feature_available(PRF_CPU_DISABLE_SUPPORT))
                 set_irq_affinity_info(irq, cpu_physical_id(0), 0);
@@ -435,7 +435,7 @@ static void sn_check_intr(int irq, struct sn_irq_info *sn_irq_info)
 	/*
 	 * Bridge types attached to TIO (anything but PIC) do not need this WAR
 	 * since they do not target Shub II interrupt registers.  If that
-	 * ever changes, this check needs to accomodate.
+	 * ever changes, this check needs to accommodate.
 	 */
 	if (sn_irq_info->irq_bridge_type != PCIIO_ASIC_TYPE_PIC)
 		return;
diff --git a/arch/ia64/sn/pci/pcibr/pcibr_dma.c b/arch/ia64/sn/pci/pcibr/pcibr_dma.c
index c659ad5..33def66 100644
--- a/arch/ia64/sn/pci/pcibr/pcibr_dma.c
+++ b/arch/ia64/sn/pci/pcibr/pcibr_dma.c
@@ -227,7 +227,7 @@ pcibr_dma_unmap(struct pci_dev *hwdev, dma_addr_t dma_handle, int direction)
  * after doing the read.  For PIC this routine then forces a fake interrupt
  * on another line, which is logically associated with the slot that the PIO
  * is addressed to.  It then spins while watching the memory location that
- * the interrupt is targetted to.  When the interrupt response arrives, we 
+ * the interrupt is targeted to.  When the interrupt response arrives, we 
  * are sure that the DMA has landed in memory and it is safe for the driver
  * to proceed.	For TIOCP use the Device(x) Write Request Buffer Flush 
  * Bridge register since it ensures the data has entered the coherence domain,
diff --git a/arch/m32r/include/asm/m32104ut/m32104ut_pld.h b/arch/m32r/include/asm/m32104ut/m32104ut_pld.h
index 2dc89d6..1feae97 100644
--- a/arch/m32r/include/asm/m32104ut/m32104ut_pld.h
+++ b/arch/m32r/include/asm/m32104ut/m32104ut_pld.h
@@ -4,7 +4,7 @@
 /*
  * include/asm-m32r/m32104ut/m32104ut_pld.h
  *
- * Definitions for Programable Logic Device(PLD) on M32104UT board.
+ * Definitions for Programmable Logic Device(PLD) on M32104UT board.
  * Based on m32700ut_pld.h
  *
  * Copyright (c) 2002	Takeo Takahashi
diff --git a/arch/m32r/include/asm/m32700ut/m32700ut_pld.h b/arch/m32r/include/asm/m32700ut/m32700ut_pld.h
index 57623be..3529467 100644
--- a/arch/m32r/include/asm/m32700ut/m32700ut_pld.h
+++ b/arch/m32r/include/asm/m32700ut/m32700ut_pld.h
@@ -4,7 +4,7 @@
 /*
  * include/asm-m32r/m32700ut/m32700ut_pld.h
  *
- * Definitions for Programable Logic Device(PLD) on M32700UT board.
+ * Definitions for Programmable Logic Device(PLD) on M32700UT board.
  *
  * Copyright (c) 2002	Takeo Takahashi
  *
diff --git a/arch/m32r/include/asm/opsput/opsput_pld.h b/arch/m32r/include/asm/opsput/opsput_pld.h
index 3f11ea1..6901401 100644
--- a/arch/m32r/include/asm/opsput/opsput_pld.h
+++ b/arch/m32r/include/asm/opsput/opsput_pld.h
@@ -4,7 +4,7 @@
 /*
  * include/asm-m32r/opsput/opsput_pld.h
  *
- * Definitions for Programable Logic Device(PLD) on OPSPUT board.
+ * Definitions for Programmable Logic Device(PLD) on OPSPUT board.
  *
  * Copyright (c) 2002	Takeo Takahashi
  *
diff --git a/arch/m32r/include/asm/pgtable-2level.h b/arch/m32r/include/asm/pgtable-2level.h
index bca3475..9cdaf73 100644
--- a/arch/m32r/include/asm/pgtable-2level.h
+++ b/arch/m32r/include/asm/pgtable-2level.h
@@ -44,7 +44,7 @@ static inline int pgd_present(pgd_t pgd)	{ return 1; }
 #define set_pte_at(mm,addr,ptep,pteval) set_pte(ptep,pteval)
 
 /*
- * (pmds are folded into pgds so this doesnt get actually called,
+ * (pmds are folded into pgds so this doesn't get actually called,
  * but the define is needed for a generic inline function.)
  */
 #define set_pmd(pmdptr, pmdval) (*(pmdptr) = pmdval)
diff --git a/arch/m32r/mm/fault.c b/arch/m32r/mm/fault.c
index b8ec002..2c9aeb4 100644
--- a/arch/m32r/mm/fault.c
+++ b/arch/m32r/mm/fault.c
@@ -120,7 +120,7 @@ asmlinkage void do_page_fault(struct pt_regs *regs, unsigned long error_code,
 
 	/* When running in the kernel we expect faults to occur only to
 	 * addresses in user space.  All other faults represent errors in the
-	 * kernel and should generate an OOPS.  Unfortunatly, in the case of an
+	 * kernel and should generate an OOPS.  Unfortunately, in the case of an
 	 * erroneous fault occurring in a code path which already holds mmap_sem
 	 * we will deadlock attempting to validate the fault against the
 	 * address space.  Luckily the kernel only validly references user
@@ -128,7 +128,7 @@ asmlinkage void do_page_fault(struct pt_regs *regs, unsigned long error_code,
 	 * exceptions table.
 	 *
 	 * As the vast majority of faults will be valid we will only perform
-	 * the source reference check when there is a possibilty of a deadlock.
+	 * the source reference check when there is a possibility of a deadlock.
 	 * Attempt to lock the address space, if we cannot we then validate the
 	 * source.  If this is invalid we can skip the address space check,
 	 * thus avoiding the deadlock.
diff --git a/arch/m68k/atari/atakeyb.c b/arch/m68k/atari/atakeyb.c
index 5890897..b995513 100644
--- a/arch/m68k/atari/atakeyb.c
+++ b/arch/m68k/atari/atakeyb.c
@@ -130,7 +130,7 @@ KEYBOARD_STATE kb_state;
  * it's really hard to decide whether they're mouse or keyboard bytes. Since
  * overruns usually occur when moving the Atari mouse rapidly, they're seen as
  * mouse bytes here. If this is wrong, only a make code of the keyboard gets
- * lost, which isn't too bad. Loosing a break code would be disastrous,
+ * lost, which isn't too bad. Losing a break code would be disastrous,
  * because then the keyboard repeat strikes...
  */
 
diff --git a/arch/m68k/fpsp040/bindec.S b/arch/m68k/fpsp040/bindec.S
index 72f1159..f2e7952 100644
--- a/arch/m68k/fpsp040/bindec.S
+++ b/arch/m68k/fpsp040/bindec.S
@@ -609,7 +609,7 @@ do_fint:
 |      A6.  This test occurs only on the first pass.  If the
 |      result is exactly 10^LEN, decrement ILOG and divide
 |      the mantissa by 10.  The calculation of 10^LEN cannot
-|      be inexact, since all powers of ten upto 10^27 are exact
+|      be inexact, since all powers of ten up to 10^27 are exact
 |      in extended precision, so the use of a previous power-of-ten
 |      table will introduce no error.
 |
diff --git a/arch/m68k/ifpsp060/src/fpsp.S b/arch/m68k/ifpsp060/src/fpsp.S
index 26e85e2..78cb60f 100644
--- a/arch/m68k/ifpsp060/src/fpsp.S
+++ b/arch/m68k/ifpsp060/src/fpsp.S
@@ -11813,7 +11813,7 @@ fmul_unfl_ena:
 	bne.b		fmul_unfl_ena_sd	# no, sgl or dbl
 
 # if the rnd mode is anything but RZ, then we have to re-do the above
-# multiplication becuase we used RZ for all.
+# multiplication because we used RZ for all.
 	fmov.l		L_SCR3(%a6),%fpcr	# set FPCR
 
 fmul_unfl_ena_cont:
@@ -18095,7 +18095,7 @@ fscc_mem_op:
 
 	rts
 
-# addresing mode is post-increment. write the result byte. if the write
+# addressing mode is post-increment. write the result byte. if the write
 # fails then don't update the address register. if write passes then
 # call inc_areg() to update the address register.
 fscc_mem_inc:
@@ -20876,7 +20876,7 @@ dst_get_dupper:
 	swap		%d0			# d0 now in upper word
 	lsl.l		&0x4,%d0		# d0 in proper place for dbl prec exp
 	tst.b		FTEMP_EX(%a0)		# test sign
-	bpl.b		dst_get_dman		# if postive, go process mantissa
+	bpl.b		dst_get_dman		# if positive, go process mantissa
 	bset		&0x1f,%d0		# if negative, set sign
 dst_get_dman:
 	mov.l		FTEMP_HI(%a0),%d1	# get ms mantissa
@@ -22943,7 +22943,7 @@ tbl_ovfl_result:
 #	FP_SRC(a6) = packed operand now as a binary FP number		#
 #									#
 # ALGORITHM ***********************************************************	#
-#	Get the correct <ea> whihc is the value on the exception stack	#
+#	Get the correct <ea> which is the value on the exception stack	#
 # frame w/ maybe a correction factor if the <ea> is -(an) or (an)+.	#
 # Then, fetch the operand from memory. If the fetch fails, exit		#
 # through facc_in_x().							#
@@ -24096,7 +24096,7 @@ do_fint12:
 #      A6.  This test occurs only on the first pass.  If the
 #      result is exactly 10^LEN, decrement ILOG and divide
 #      the mantissa by 10.  The calculation of 10^LEN cannot
-#      be inexact, since all powers of ten upto 10^27 are exact
+#      be inexact, since all powers of ten up to 10^27 are exact
 #      in extended precision, so the use of a previous power-of-ten
 #      table will introduce no error.
 #
diff --git a/arch/m68k/ifpsp060/src/pfpsp.S b/arch/m68k/ifpsp060/src/pfpsp.S
index e71ba0a..4aedef9 100644
--- a/arch/m68k/ifpsp060/src/pfpsp.S
+++ b/arch/m68k/ifpsp060/src/pfpsp.S
@@ -7777,7 +7777,7 @@ dst_get_dupper:
 	swap		%d0			# d0 now in upper word
 	lsl.l		&0x4,%d0		# d0 in proper place for dbl prec exp
 	tst.b		FTEMP_EX(%a0)		# test sign
-	bpl.b		dst_get_dman		# if postive, go process mantissa
+	bpl.b		dst_get_dman		# if positive, go process mantissa
 	bset		&0x1f,%d0		# if negative, set sign
 dst_get_dman:
 	mov.l		FTEMP_HI(%a0),%d1	# get ms mantissa
@@ -8244,7 +8244,7 @@ fmul_unfl_ena:
 	bne.b		fmul_unfl_ena_sd	# no, sgl or dbl
 
 # if the rnd mode is anything but RZ, then we have to re-do the above
-# multiplication becuase we used RZ for all.
+# multiplication because we used RZ for all.
 	fmov.l		L_SCR3(%a6),%fpcr	# set FPCR
 
 fmul_unfl_ena_cont:
@@ -12903,7 +12903,7 @@ store_fpreg_7:
 #	FP_SRC(a6) = packed operand now as a binary FP number		#
 #									#
 # ALGORITHM ***********************************************************	#
-#	Get the correct <ea> whihc is the value on the exception stack	#
+#	Get the correct <ea> which is the value on the exception stack	#
 # frame w/ maybe a correction factor if the <ea> is -(an) or (an)+.	#
 # Then, fetch the operand from memory. If the fetch fails, exit		#
 # through facc_in_x().							#
@@ -14056,7 +14056,7 @@ do_fint12:
 #      A6.  This test occurs only on the first pass.  If the
 #      result is exactly 10^LEN, decrement ILOG and divide
 #      the mantissa by 10.  The calculation of 10^LEN cannot
-#      be inexact, since all powers of ten upto 10^27 are exact
+#      be inexact, since all powers of ten up to 10^27 are exact
 #      in extended precision, so the use of a previous power-of-ten
 #      table will introduce no error.
 #
diff --git a/arch/m68k/include/asm/atariints.h b/arch/m68k/include/asm/atariints.h
index f597892..656bbbf 100644
--- a/arch/m68k/include/asm/atariints.h
+++ b/arch/m68k/include/asm/atariints.h
@@ -146,7 +146,7 @@ static inline void clear_mfp_bit( unsigned irq, int type )
 
 /*
  * {en,dis}able_irq have the usual semantics of temporary blocking the
- * interrupt, but not loosing requests that happen between disabling and
+ * interrupt, but not losing requests that happen between disabling and
  * enabling. This is done with the MFP mask registers.
  */
 
diff --git a/arch/m68k/include/asm/bootstd.h b/arch/m68k/include/asm/bootstd.h
index bdc1a4a..e518f5a 100644
--- a/arch/m68k/include/asm/bootstd.h
+++ b/arch/m68k/include/asm/bootstd.h
@@ -31,7 +31,7 @@
 #define __BN_flash_write_range		20
 
 /* Calling conventions compatible to (uC)linux/68k
- * We use simmilar macros to call into the bootloader as for uClinux
+ * We use similar macros to call into the bootloader as for uClinux
  */
 
 #define __bsc_return(type, res) \
diff --git a/arch/m68k/include/asm/commproc.h b/arch/m68k/include/asm/commproc.h
index edf5eb6..a739985 100644
--- a/arch/m68k/include/asm/commproc.h
+++ b/arch/m68k/include/asm/commproc.h
@@ -88,7 +88,7 @@ typedef struct cpm_buf_desc {
 
 
 /* rx bd status/control bits */
-#define BD_SC_EMPTY	((ushort)0x8000)	/* Recieve is empty */
+#define BD_SC_EMPTY	((ushort)0x8000)	/* Receive is empty */
 #define BD_SC_WRAP	((ushort)0x2000)	/* Last buffer descriptor in table */
 #define BD_SC_INTRPT	((ushort)0x1000)	/* Interrupt on change */
 #define BD_SC_LAST	((ushort)0x0800)	/* Last buffer in frame OR control char */
@@ -96,7 +96,7 @@ typedef struct cpm_buf_desc {
 #define BD_SC_FIRST	((ushort)0x0400)	/* 1st buffer in an HDLC frame */
 #define BD_SC_ADDR	((ushort)0x0400)	/* 1st byte is a multidrop address */
 
-#define BD_SC_CM	((ushort)0x0200)	/* Continous mode */
+#define BD_SC_CM	((ushort)0x0200)	/* Continuous mode */
 #define BD_SC_ID	((ushort)0x0100)	/* Received too many idles */
 
 #define BD_SC_AM	((ushort)0x0080)	/* Multidrop address match */
diff --git a/arch/m68k/include/asm/delay_no.h b/arch/m68k/include/asm/delay_no.h
index 55cbd62..c3a0edc 100644
--- a/arch/m68k/include/asm/delay_no.h
+++ b/arch/m68k/include/asm/delay_no.h
@@ -16,7 +16,7 @@ static inline void __delay(unsigned long loops)
 	 * long word alignment which is the faster version.
 	 * The 0x4a8e is of course a 'tstl %fp' instruction.  This is better
 	 * than using a NOP (0x4e71) instruction because it executes in one
-	 * cycle not three and doesn't allow for an arbitary delay waiting
+	 * cycle not three and doesn't allow for an arbitrary delay waiting
 	 * for bus cycles to finish.  Also fp/a6 isn't likely to cause a
 	 * stall waiting for the register to become valid if such is added
 	 * to the coldfire at some stage.
diff --git a/arch/m68k/include/asm/gpio.h b/arch/m68k/include/asm/gpio.h
index c64c7b7..b204683 100644
--- a/arch/m68k/include/asm/gpio.h
+++ b/arch/m68k/include/asm/gpio.h
@@ -31,7 +31,7 @@
  * GPIOs in a single control area, others have some GPIOs implemented in
  * different modules.
  *
- * This implementation attempts accomodate the differences while presenting
+ * This implementation attempts accommodate the differences while presenting
  * a generic interface that will optimize to as few instructions as possible.
  */
 #if defined(CONFIG_M5206) || defined(CONFIG_M5206e) || \
diff --git a/arch/m68k/include/asm/m520xsim.h b/arch/m68k/include/asm/m520xsim.h
index 55d5a4c5..b6bf2c5 100644
--- a/arch/m68k/include/asm/m520xsim.h
+++ b/arch/m68k/include/asm/m520xsim.h
@@ -157,7 +157,7 @@
 #define	MCFFEC_SIZE		0x800		/* Register set size */
 
 /*
- *  Reset Controll Unit.
+ *  Reset Control Unit.
  */
 #define	MCF_RCR			0xFC0A0000
 #define	MCF_RSR			0xFC0A0001
diff --git a/arch/m68k/include/asm/m523xsim.h b/arch/m68k/include/asm/m523xsim.h
index 8996df6..6235921 100644
--- a/arch/m68k/include/asm/m523xsim.h
+++ b/arch/m68k/include/asm/m523xsim.h
@@ -48,7 +48,7 @@
 #define	MCFSIM_DMR1		(MCF_IPSBAR + 0x54)	/* Address mask 1 */
 
 /*
- *  Reset Controll Unit (relative to IPSBAR).
+ *  Reset Control Unit (relative to IPSBAR).
  */
 #define	MCF_RCR			0x110000
 #define	MCF_RSR			0x110001
diff --git a/arch/m68k/include/asm/m527xsim.h b/arch/m68k/include/asm/m527xsim.h
index 74855a6..758810e 100644
--- a/arch/m68k/include/asm/m527xsim.h
+++ b/arch/m68k/include/asm/m527xsim.h
@@ -283,7 +283,7 @@
 #endif
 
 /*
- *  Reset Controll Unit (relative to IPSBAR).
+ *  Reset Control Unit (relative to IPSBAR).
  */
 #define	MCF_RCR			0x110000
 #define	MCF_RSR			0x110001
diff --git a/arch/m68k/include/asm/m5307sim.h b/arch/m68k/include/asm/m5307sim.h
index 4c94c01..8f8609f 100644
--- a/arch/m68k/include/asm/m5307sim.h
+++ b/arch/m68k/include/asm/m5307sim.h
@@ -29,7 +29,7 @@
 #define	MCFSIM_SWSR		0x03		/* SW Watchdog service (r/w) */
 #define	MCFSIM_PAR		0x04		/* Pin Assignment reg (r/w) */
 #define	MCFSIM_IRQPAR		0x06		/* Interrupt Assignment reg (r/w) */
-#define	MCFSIM_PLLCR		0x08		/* PLL Controll Reg*/
+#define	MCFSIM_PLLCR		0x08		/* PLL Control Reg*/
 #define	MCFSIM_MPARK		0x0C		/* BUS Master Control Reg*/
 #define	MCFSIM_IPR		0x40		/* Interrupt Pend reg (r/w) */
 #define	MCFSIM_IMR		0x44		/* Interrupt Mask reg (r/w) */
diff --git a/arch/m68k/include/asm/m5407sim.h b/arch/m68k/include/asm/m5407sim.h
index 762c58c..51e00b0 100644
--- a/arch/m68k/include/asm/m5407sim.h
+++ b/arch/m68k/include/asm/m5407sim.h
@@ -29,7 +29,7 @@
 #define	MCFSIM_SWSR		0x03		/* SW Watchdog service (r/w) */
 #define	MCFSIM_PAR		0x04		/* Pin Assignment reg (r/w) */
 #define	MCFSIM_IRQPAR		0x06		/* Interrupt Assignment reg (r/w) */
-#define	MCFSIM_PLLCR		0x08		/* PLL Controll Reg*/
+#define	MCFSIM_PLLCR		0x08		/* PLL Control Reg*/
 #define	MCFSIM_MPARK		0x0C		/* BUS Master Control Reg*/
 #define	MCFSIM_IPR		0x40		/* Interrupt Pend reg (r/w) */
 #define	MCFSIM_IMR		0x44		/* Interrupt Mask reg (r/w) */
diff --git a/arch/m68k/include/asm/m68360_quicc.h b/arch/m68k/include/asm/m68360_quicc.h
index 6d40f4d..59414cc 100644
--- a/arch/m68k/include/asm/m68360_quicc.h
+++ b/arch/m68k/include/asm/m68360_quicc.h
@@ -32,7 +32,7 @@ struct user_data {
     /* BASE + 0x000: user data memory */
     volatile unsigned char      udata_bd_ucode[0x400]; /*user data bd's Ucode*/
     volatile unsigned char      udata_bd[0x200];       /*user data Ucode     */
-    volatile unsigned char      ucode_ext[0x100];      /*Ucode Extention ram */
+    volatile unsigned char      ucode_ext[0x100];      /*Ucode Extension ram */
     volatile unsigned char      RESERVED1[0x500];      /* Reserved area      */
 };
 #else
diff --git a/arch/m68k/include/asm/mac_oss.h b/arch/m68k/include/asm/mac_oss.h
index 7221f72..3cf2b6e 100644
--- a/arch/m68k/include/asm/mac_oss.h
+++ b/arch/m68k/include/asm/mac_oss.h
@@ -61,7 +61,7 @@
 /*
  * OSS Interrupt levels for various sub-systems
  *
- * This mapping is layed out with two things in mind: first, we try to keep
+ * This mapping is laid out with two things in mind: first, we try to keep
  * things on their own levels to avoid having to do double-dispatches. Second,
  * the levels match as closely as possible the alternate IRQ mapping mode (aka
  * "A/UX mode") available on some VIA machines.
diff --git a/arch/m68k/include/asm/mac_via.h b/arch/m68k/include/asm/mac_via.h
index 39afb43..a59665e 100644
--- a/arch/m68k/include/asm/mac_via.h
+++ b/arch/m68k/include/asm/mac_via.h
@@ -204,7 +204,7 @@
 #define vT2CL	0x1000  /* [VIA only] Timer two counter low. */
 #define vT2CH	0x1200  /* [VIA only] Timer two counter high. */
 #define vSR	0x1400  /* [VIA only] Shift register. */
-#define vACR	0x1600  /* [VIA only] Auxilary control register. */
+#define vACR	0x1600  /* [VIA only] Auxiliary control register. */
 #define vPCR	0x1800  /* [VIA only] Peripheral control register. */
                         /*            CHRP sez never ever to *write* this.
 			 *            Mac family says never to *change* this.
diff --git a/arch/m68k/include/asm/macintosh.h b/arch/m68k/include/asm/macintosh.h
index 50db359..c2a1c5e 100644
--- a/arch/m68k/include/asm/macintosh.h
+++ b/arch/m68k/include/asm/macintosh.h
@@ -14,7 +14,7 @@ extern void mac_init_IRQ(void);
 extern int mac_irq_pending(unsigned int);
 
 /*
- *	Floppy driver magic hook - probably shouldnt be here
+ *	Floppy driver magic hook - probably shouldn't be here
  */
 
 extern void via1_set_head(int);
diff --git a/arch/m68k/include/asm/mcftimer.h b/arch/m68k/include/asm/mcftimer.h
index 92b276f..351c272 100644
--- a/arch/m68k/include/asm/mcftimer.h
+++ b/arch/m68k/include/asm/mcftimer.h
@@ -27,7 +27,7 @@
 
 /*
  *	Bit definitions for the Timer Mode Register (TMR).
- *	Register bit flags are common accross ColdFires.
+ *	Register bit flags are common across ColdFires.
  */
 #define	MCFTIMER_TMR_PREMASK	0xff00		/* Prescalar mask */
 #define	MCFTIMER_TMR_DISCE	0x0000		/* Disable capture */
diff --git a/arch/m68k/kernel/head.S b/arch/m68k/kernel/head.S
index ef54128..27622b3 100644
--- a/arch/m68k/kernel/head.S
+++ b/arch/m68k/kernel/head.S
@@ -134,7 +134,7 @@
  *	Thanks to a small helping routine enabling the mmu got quite simple
  * and there is only one way left. mmu_engage makes a complete a new mapping
  * that only includes the absolute necessary to be able to jump to the final
- * postion and to restore the original mapping.
+ * position and to restore the original mapping.
  * As this code doesn't need a transparent translation register anymore this
  * means all registers are free to be used by machines that needs them for
  * other purposes.
@@ -969,7 +969,7 @@ L(mmu_init_amiga):
 	is_not_040_or_060(1f)
 
 	/*
-	 * 040: Map the 16Meg range physical 0x0 upto logical 0x8000.0000
+	 * 040: Map the 16Meg range physical 0x0 up to logical 0x8000.0000
 	 */
 	mmu_map		#0x80000000,#0,#0x01000000,#_PAGE_NOCACHE_S
 	/*
@@ -982,7 +982,7 @@ L(mmu_init_amiga):
 
 1:
 	/*
-	 * 030:	Map the 32Meg range physical 0x0 upto logical 0x8000.0000
+	 * 030:	Map the 32Meg range physical 0x0 up to logical 0x8000.0000
 	 */
 	mmu_map		#0x80000000,#0,#0x02000000,#_PAGE_NOCACHE030
 	mmu_map_tt	#1,#0x40000000,#0x20000000,#_PAGE_NOCACHE030
@@ -1074,7 +1074,7 @@ L(notq40):
 	is_040(1f)
 
 	/*
-	 * 030: Map the 32Meg range physical 0x0 upto logical 0xf000.0000
+	 * 030: Map the 32Meg range physical 0x0 up to logical 0xf000.0000
 	 */
 	mmu_map	#0xf0000000,#0,#0x02000000,#_PAGE_NOCACHE030
 
@@ -1082,7 +1082,7 @@ L(notq40):
 
 1:
 	/*
-	 * 040: Map the 16Meg range physical 0x0 upto logical 0xf000.0000
+	 * 040: Map the 16Meg range physical 0x0 up to logical 0xf000.0000
 	 */
 	mmu_map #0xf0000000,#0,#0x01000000,#_PAGE_NOCACHE_S
 
@@ -3078,7 +3078,7 @@ func_start	serial_putc,%d0/%d1/%a0/%a1
 	/*
 	 * If the loader gave us a board type then we can use that to
 	 * select an appropriate output routine; otherwise we just use
-	 * the Bug code.  If we haev to use the Bug that means the Bug
+	 * the Bug code.  If we have to use the Bug that means the Bug
 	 * workspace has to be valid, which means the Bug has to use
 	 * the SRAM, which is non-standard.
 	 */
diff --git a/arch/m68k/kernel/vmlinux.lds_no.S b/arch/m68k/kernel/vmlinux.lds_no.S
index 47e15eb..f4d715c 100644
--- a/arch/m68k/kernel/vmlinux.lds_no.S
+++ b/arch/m68k/kernel/vmlinux.lds_no.S
@@ -3,7 +3,7 @@
  *
  *	(C) Copyright 2002-2006, Greg Ungerer <gerg@snapgear.com>
  *
- *	This linker script is equiped to build either ROM loaded or RAM
+ *	This linker script is equipped to build either ROM loaded or RAM
  *	run kernels.
  */
 
diff --git a/arch/m68k/platform/523x/config.c b/arch/m68k/platform/523x/config.c
index 418a76f..71f4436 100644
--- a/arch/m68k/platform/523x/config.c
+++ b/arch/m68k/platform/523x/config.c
@@ -3,7 +3,7 @@
 /*
  *	linux/arch/m68knommu/platform/523x/config.c
  *
- *	Sub-architcture dependant initialization code for the Freescale
+ *	Sub-architcture dependent initialization code for the Freescale
  *	523x CPUs.
  *
  *	Copyright (C) 1999-2005, Greg Ungerer (gerg@snapgear.com)
diff --git a/arch/m68k/platform/5272/intc.c b/arch/m68k/platform/5272/intc.c
index 43e6e96..7e715df 100644
--- a/arch/m68k/platform/5272/intc.c
+++ b/arch/m68k/platform/5272/intc.c
@@ -33,7 +33,7 @@
  *
  * Note that the external interrupts are edge triggered (unlike the
  * internal interrupt sources which are level triggered). Which means
- * they also need acknowledgeing via acknowledge bits.
+ * they also need acknowledging via acknowledge bits.
  */
 struct irqmap {
 	unsigned char	icr;
diff --git a/arch/m68k/platform/527x/config.c b/arch/m68k/platform/527x/config.c
index fa35959..3ebc769 100644
--- a/arch/m68k/platform/527x/config.c
+++ b/arch/m68k/platform/527x/config.c
@@ -3,7 +3,7 @@
 /*
  *	linux/arch/m68knommu/platform/527x/config.c
  *
- *	Sub-architcture dependant initialization code for the Freescale
+ *	Sub-architcture dependent initialization code for the Freescale
  *	5270/5271 CPUs.
  *
  *	Copyright (C) 1999-2004, Greg Ungerer (gerg@snapgear.com)
diff --git a/arch/m68k/platform/528x/config.c b/arch/m68k/platform/528x/config.c
index ac39fc6..7abe77a 100644
--- a/arch/m68k/platform/528x/config.c
+++ b/arch/m68k/platform/528x/config.c
@@ -3,7 +3,7 @@
 /*
  *	linux/arch/m68knommu/platform/528x/config.c
  *
- *	Sub-architcture dependant initialization code for the Freescale
+ *	Sub-architcture dependent initialization code for the Freescale
  *	5280, 5281 and 5282 CPUs.
  *
  *	Copyright (C) 1999-2003, Greg Ungerer (gerg@snapgear.com)
diff --git a/arch/m68k/platform/coldfire/cache.c b/arch/m68k/platform/coldfire/cache.c
index 235d3c4..71beeaf 100644
--- a/arch/m68k/platform/coldfire/cache.c
+++ b/arch/m68k/platform/coldfire/cache.c
@@ -1,7 +1,7 @@
 /***************************************************************************/
 
 /*
- *	cache.c -- general ColdFire Cache maintainence code
+ *	cache.c -- general ColdFire Cache maintenance code
  *
  *	Copyright (C) 2010, Greg Ungerer (gerg@snapgear.com)
  */
diff --git a/arch/m68k/platform/coldfire/entry.S b/arch/m68k/platform/coldfire/entry.S
index 5837cf0..eab63f0 100644
--- a/arch/m68k/platform/coldfire/entry.S
+++ b/arch/m68k/platform/coldfire/entry.S
@@ -163,7 +163,7 @@ Lsignal_return:
 
 /*
  * This is the generic interrupt handler (for all hardware interrupt
- * sources). Calls upto high level code to do all the work.
+ * sources). Calls up to high level code to do all the work.
  */
 ENTRY(inthandler)
 	SAVE_ALL
diff --git a/arch/m68k/platform/coldfire/head.S b/arch/m68k/platform/coldfire/head.S
index 129bff49..6ae91a4 100644
--- a/arch/m68k/platform/coldfire/head.S
+++ b/arch/m68k/platform/coldfire/head.S
@@ -20,7 +20,7 @@
 
 /*
  *	If we don't have a fixed memory size, then lets build in code
- *	to auto detect the DRAM size. Obviously this is the prefered
+ *	to auto detect the DRAM size. Obviously this is the preferred
  *	method, and should work for most boards. It won't work for those
  *	that do not have their RAM starting at address 0, and it only
  *	works on SDRAM (not boards fitted with SRAM).
diff --git a/arch/m68k/platform/coldfire/intc.c b/arch/m68k/platform/coldfire/intc.c
index c28a6ed..0bbb414 100644
--- a/arch/m68k/platform/coldfire/intc.c
+++ b/arch/m68k/platform/coldfire/intc.c
@@ -37,7 +37,7 @@ unsigned char mcf_irq2imr[NR_IRQS];
 /*
  * In the early version 2 core ColdFire parts the IMR register was 16 bits
  * in size. Version 3 (and later version 2) core parts have a 32 bit
- * sized IMR register. Provide some size independant methods to access the
+ * sized IMR register. Provide some size independent methods to access the
  * IMR register.
  */
 #ifdef MCFSIM_IMR_IS_16BITS
diff --git a/arch/m68k/platform/coldfire/sltimers.c b/arch/m68k/platform/coldfire/sltimers.c
index 0a1b937..6a85daf 100644
--- a/arch/m68k/platform/coldfire/sltimers.c
+++ b/arch/m68k/platform/coldfire/sltimers.c
@@ -106,7 +106,7 @@ static cycle_t mcfslt_read_clk(struct clocksource *cs)
 	cycles = mcfslt_cnt;
 	local_irq_restore(flags);
 
-	/* substract because slice timers count down */
+	/* subtract because slice timers count down */
 	return cycles - scnt;
 }
 
diff --git a/arch/m68k/q40/README b/arch/m68k/q40/README
index f877b72..b26d5f5 100644
--- a/arch/m68k/q40/README
+++ b/arch/m68k/q40/README
@@ -89,7 +89,7 @@ The main interrupt register IIRQ_REG will indicate whether an IRQ was internal
 or from some ISA devices, EIRQ_REG can distinguish up to 8 ISA IRQs.
 
 The Q40 custom chip is programmable to provide 2 periodic timers:
-	- 50 or 200 Hz - level 2, !!THIS CANT BE DISABLED!!
+	- 50 or 200 Hz - level 2, !!THIS CAN'T BE DISABLED!!
 	- 10 or 20 KHz - level 4, used for dma-sound
 
 Linux uses the 200 Hz interrupt for timer and beep by default.
diff --git a/arch/microblaze/Makefile b/arch/microblaze/Makefile
index 6f432e6..b23c40e 100644
--- a/arch/microblaze/Makefile
+++ b/arch/microblaze/Makefile
@@ -18,7 +18,7 @@ export CPU_VER CPU_MAJOR CPU_MINOR CPU_REV
 # rather than bools y/n
 
 # Work out HW multipler support. This is tricky.
-# 1. Spartan2 has no HW multiplers.
+# 1. Spartan2 has no HW multipliers.
 # 2. MicroBlaze v3.x always uses them, except in Spartan 2
 # 3. All other FPGa/CPU ver combos, we can trust the CONFIG_ settings
 ifeq (,$(findstring spartan2,$(CONFIG_XILINX_MICROBLAZE0_FAMILY)))
diff --git a/arch/microblaze/include/asm/io.h b/arch/microblaze/include/asm/io.h
index eae3222..8cdac14 100644
--- a/arch/microblaze/include/asm/io.h
+++ b/arch/microblaze/include/asm/io.h
@@ -70,7 +70,7 @@ static inline void __raw_writeq(unsigned long v, volatile void __iomem *addr)
 
 /*
  * read (readb, readw, readl, readq) and write (writeb, writew,
- * writel, writeq) accessors are for PCI and thus littel endian.
+ * writel, writeq) accessors are for PCI and thus little endian.
  * Linux 2.4 for Microblaze had this wrong.
  */
 static inline unsigned char readb(const volatile void __iomem *addr)
diff --git a/arch/microblaze/include/asm/pci-bridge.h b/arch/microblaze/include/asm/pci-bridge.h
index 1071766..746df91 100644
--- a/arch/microblaze/include/asm/pci-bridge.h
+++ b/arch/microblaze/include/asm/pci-bridge.h
@@ -76,7 +76,7 @@ struct pci_controller {
 	 * Used for variants of PCI indirect handling and possible quirks:
 	 *  SET_CFG_TYPE - used on 4xx or any PHB that does explicit type0/1
 	 *  EXT_REG - provides access to PCI-e extended registers
-	 *  SURPRESS_PRIMARY_BUS - we surpress the setting of PCI_PRIMARY_BUS
+	 *  SURPRESS_PRIMARY_BUS - we suppress the setting of PCI_PRIMARY_BUS
 	 *   on Freescale PCI-e controllers since they used the PCI_PRIMARY_BUS
 	 *   to determine which bus number to match on when generating type0
 	 *   config cycles
diff --git a/arch/microblaze/include/asm/pci.h b/arch/microblaze/include/asm/pci.h
index 2232ff94..ba65cf4 100644
--- a/arch/microblaze/include/asm/pci.h
+++ b/arch/microblaze/include/asm/pci.h
@@ -158,7 +158,7 @@ extern void pci_resource_to_user(const struct pci_dev *dev, int bar,
 extern void pcibios_setup_bus_devices(struct pci_bus *bus);
 extern void pcibios_setup_bus_self(struct pci_bus *bus);
 
-/* This part of code was originaly in xilinx-pci.h */
+/* This part of code was originally in xilinx-pci.h */
 #ifdef CONFIG_PCI_XILINX
 extern void __init xilinx_pci_init(void);
 #else
diff --git a/arch/microblaze/kernel/cpu/cache.c b/arch/microblaze/kernel/cpu/cache.c
index cf0afd9..4b7d8a3 100644
--- a/arch/microblaze/kernel/cpu/cache.c
+++ b/arch/microblaze/kernel/cpu/cache.c
@@ -129,7 +129,7 @@ do {									\
  * to use for simple wdc or wic.
  *
  * start address is cache aligned
- * end address is not aligned, if end is aligned then I have to substract
+ * end address is not aligned, if end is aligned then I have to subtract
  * cacheline length because I can't flush/invalidate the next cacheline.
  * If is not, I align it because I will flush/invalidate whole line.
  */
diff --git a/arch/microblaze/lib/memcpy.c b/arch/microblaze/lib/memcpy.c
index cc495d7..52746e7 100644
--- a/arch/microblaze/lib/memcpy.c
+++ b/arch/microblaze/lib/memcpy.c
@@ -63,8 +63,8 @@ void *memcpy(void *v_dst, const void *v_src, __kernel_size_t c)
 	if (likely(c >= 4)) {
 		unsigned  value, buf_hold;
 
-		/* Align the dstination to a word boundry. */
-		/* This is done in an endian independant manner. */
+		/* Align the destination to a word boundary. */
+		/* This is done in an endian independent manner. */
 		switch ((unsigned long)dst & 3) {
 		case 1:
 			*dst++ = *src++;
@@ -80,7 +80,7 @@ void *memcpy(void *v_dst, const void *v_src, __kernel_size_t c)
 		i_dst = (void *)dst;
 
 		/* Choose a copy scheme based on the source */
-		/* alignment relative to dstination. */
+		/* alignment relative to destination. */
 		switch ((unsigned long)src & 3) {
 		case 0x0:	/* Both byte offsets are aligned */
 			i_src  = (const void *)src;
@@ -173,7 +173,7 @@ void *memcpy(void *v_dst, const void *v_src, __kernel_size_t c)
 	}
 
 	/* Finish off any remaining bytes */
-	/* simple fast copy, ... unless a cache boundry is crossed */
+	/* simple fast copy, ... unless a cache boundary is crossed */
 	switch (c) {
 	case 3:
 		*dst++ = *src++;
diff --git a/arch/microblaze/lib/memmove.c b/arch/microblaze/lib/memmove.c
index 810fd68..2146c37 100644
--- a/arch/microblaze/lib/memmove.c
+++ b/arch/microblaze/lib/memmove.c
@@ -83,8 +83,8 @@ void *memmove(void *v_dst, const void *v_src, __kernel_size_t c)
 	if (c >= 4) {
 		unsigned  value, buf_hold;
 
-		/* Align the destination to a word boundry. */
-		/* This is done in an endian independant manner. */
+		/* Align the destination to a word boundary. */
+		/* This is done in an endian independent manner. */
 
 		switch ((unsigned long)dst & 3) {
 		case 3:
@@ -193,7 +193,7 @@ void *memmove(void *v_dst, const void *v_src, __kernel_size_t c)
 		dst = (void *)i_dst;
 	}
 
-	/* simple fast copy, ... unless a cache boundry is crossed */
+	/* simple fast copy, ... unless a cache boundary is crossed */
 	/* Finish off any remaining bytes */
 	switch (c) {
 	case 4:
diff --git a/arch/microblaze/lib/memset.c b/arch/microblaze/lib/memset.c
index 834565d..ddf6793 100644
--- a/arch/microblaze/lib/memset.c
+++ b/arch/microblaze/lib/memset.c
@@ -64,7 +64,7 @@ void *memset(void *v_src, int c, __kernel_size_t n)
 
 	if (likely(n >= 4)) {
 		/* Align the destination to a word boundary */
-		/* This is done in an endian independant manner */
+		/* This is done in an endian independent manner */
 		switch ((unsigned) src & 3) {
 		case 1:
 			*src++ = c;
diff --git a/arch/microblaze/pci/indirect_pci.c b/arch/microblaze/pci/indirect_pci.c
index 25f18f0..4196eb6 100644
--- a/arch/microblaze/pci/indirect_pci.c
+++ b/arch/microblaze/pci/indirect_pci.c
@@ -108,7 +108,7 @@ indirect_write_config(struct pci_bus *bus, unsigned int devfn, int offset,
 		out_le32(hose->cfg_addr, (0x80000000 | (bus_no << 16) |
 			 (devfn << 8) | reg | cfg_type));
 
-	/* surpress setting of PCI_PRIMARY_BUS */
+	/* suppress setting of PCI_PRIMARY_BUS */
 	if (hose->indirect_type & INDIRECT_TYPE_SURPRESS_PRIMARY_BUS)
 		if ((offset == PCI_PRIMARY_BUS) &&
 			(bus->number == hose->first_busno))
diff --git a/arch/microblaze/platform/generic/Kconfig.auto b/arch/microblaze/platform/generic/Kconfig.auto
index 5d86fc1..25a6f01 100644
--- a/arch/microblaze/platform/generic/Kconfig.auto
+++ b/arch/microblaze/platform/generic/Kconfig.auto
@@ -29,7 +29,7 @@ config KERNEL_BASE_ADDR
 	  BASE Address for kernel
 
 config XILINX_MICROBLAZE0_FAMILY
-	string "Targetted FPGA family"
+	string "Targeted FPGA family"
 	default "virtex5"
 
 config XILINX_MICROBLAZE0_USE_MSR_INSTR
diff --git a/arch/mips/Kconfig b/arch/mips/Kconfig
index 83aa5fb..8e256cc 100644
--- a/arch/mips/Kconfig
+++ b/arch/mips/Kconfig
@@ -1135,7 +1135,7 @@ config CPU_LOONGSON2E
 	  The Loongson 2E processor implements the MIPS III instruction set
 	  with many extensions.
 
-	  It has an internal FPGA northbridge, which is compatiable to
+	  It has an internal FPGA northbridge, which is compatible to
 	  bonito64.
 
 config CPU_LOONGSON2F
diff --git a/arch/mips/Makefile b/arch/mips/Makefile
index ac1d5b6..53e3514 100644
--- a/arch/mips/Makefile
+++ b/arch/mips/Makefile
@@ -101,7 +101,7 @@ cflags-y += -ffreestanding
 # carefully avoid to add it redundantly because gcc 3.3/3.4 complains
 # when fed the toolchain default!
 #
-# Certain gcc versions upto gcc 4.1.1 (probably 4.2-subversion as of
+# Certain gcc versions up to gcc 4.1.1 (probably 4.2-subversion as of
 # 2006-10-10 don't properly change the predefined symbols if -EB / -EL
 # are used, so we kludge that here.  A bug has been filed at
 # http://gcc.gnu.org/bugzilla/show_bug.cgi?id=29413.
@@ -314,5 +314,5 @@ define archhelp
 	echo '  vmlinuz.bin          - Raw binary zboot image'
 	echo '  vmlinuz.srec         - SREC zboot image'
 	echo
-	echo '  These will be default as apropriate for a configured platform.'
+	echo '  These will be default as appropriate for a configured platform.'
 endef
diff --git a/arch/mips/alchemy/common/clocks.c b/arch/mips/alchemy/common/clocks.c
index af0fe41..f38298a 100644
--- a/arch/mips/alchemy/common/clocks.c
+++ b/arch/mips/alchemy/common/clocks.c
@@ -75,7 +75,7 @@ void set_au1x00_uart_baud_base(unsigned long new_baud_base)
  * counter, if it exists.  If we don't have an accurate processor
  * speed, all of the peripherals that derive their clocks based on
  * this advertised speed will introduce error and sometimes not work
- * properly.  This function is futher convoluted to still allow configurations
+ * properly.  This function is further convoluted to still allow configurations
  * to do that in case they have really, really old silicon with a
  * write-only PLL register.			-- Dan
  */
diff --git a/arch/mips/cavium-octeon/executive/octeon-model.c b/arch/mips/cavium-octeon/executive/octeon-model.c
index 9afc379..c8d3568 100644
--- a/arch/mips/cavium-octeon/executive/octeon-model.c
+++ b/arch/mips/cavium-octeon/executive/octeon-model.c
@@ -75,7 +75,7 @@ const char *octeon_model_get_string_buffer(uint32_t chip_id, char *buffer)
 
 	num_cores = cvmx_octeon_num_cores();
 
-	/* Make sure the non existant devices look disabled */
+	/* Make sure the non existent devices look disabled */
 	switch ((chip_id >> 8) & 0xff) {
 	case 6:		/* CN50XX */
 	case 2:		/* CN30XX */
diff --git a/arch/mips/cavium-octeon/octeon-platform.c b/arch/mips/cavium-octeon/octeon-platform.c
index cecaf62..cd61d72 100644
--- a/arch/mips/cavium-octeon/octeon-platform.c
+++ b/arch/mips/cavium-octeon/octeon-platform.c
@@ -75,7 +75,7 @@ static int __init octeon_cf_device_init(void)
 		 * zero.
 		 */
 
-		/* Asume that CS1 immediately follows. */
+		/* Assume that CS1 immediately follows. */
 		mio_boot_reg_cfg.u64 =
 			cvmx_read_csr(CVMX_MIO_BOOT_REG_CFGX(i + 1));
 		region_base = mio_boot_reg_cfg.s.base << 16;
diff --git a/arch/mips/cavium-octeon/setup.c b/arch/mips/cavium-octeon/setup.c
index 8b139bf..0707fae 100644
--- a/arch/mips/cavium-octeon/setup.c
+++ b/arch/mips/cavium-octeon/setup.c
@@ -662,7 +662,7 @@ void __init plat_mem_setup(void)
 	 * some memory vectors. When SPARSEMEM is in use, it doesn't
 	 * verify that the size is big enough for the final
 	 * vectors. Making the smallest chuck 4MB seems to be enough
-	 * to consistantly work.
+	 * to consistently work.
 	 */
 	mem_alloc_size = 4 << 20;
 	if (mem_alloc_size > MAX_MEMORY)
diff --git a/arch/mips/fw/arc/promlib.c b/arch/mips/fw/arc/promlib.c
index c508c00..b7f9dd3 100644
--- a/arch/mips/fw/arc/promlib.c
+++ b/arch/mips/fw/arc/promlib.c
@@ -4,7 +4,7 @@
  * for more details.
  *
  * Copyright (C) 1996 David S. Miller (dm@sgi.com)
- * Compability with board caches, Ulf Carlsson
+ * Compatibility with board caches, Ulf Carlsson
  */
 #include <linux/kernel.h>
 #include <asm/sgialib.h>
diff --git a/arch/mips/include/asm/dec/prom.h b/arch/mips/include/asm/dec/prom.h
index b9c8203..c0ead63 100644
--- a/arch/mips/include/asm/dec/prom.h
+++ b/arch/mips/include/asm/dec/prom.h
@@ -108,7 +108,7 @@ extern int (*__pmax_close)(int);
 
 /*
  * On MIPS64 we have to call PROM functions via a helper
- * dispatcher to accomodate ABI incompatibilities.
+ * dispatcher to accommodate ABI incompatibilities.
  */
 #define __DEC_PROM_O32(fun, arg) fun arg __asm__(#fun); \
 				 __asm__(#fun " = call_o32")
diff --git a/arch/mips/include/asm/floppy.h b/arch/mips/include/asm/floppy.h
index 992d232..c5c7c0e 100644
--- a/arch/mips/include/asm/floppy.h
+++ b/arch/mips/include/asm/floppy.h
@@ -24,7 +24,7 @@ static inline void fd_cacheflush(char * addr, long size)
  * And on Mips's the CMOS info fails also ...
  *
  * FIXME: This information should come from the ARC configuration tree
- *        or whereever a particular machine has stored this ...
+ *        or wherever a particular machine has stored this ...
  */
 #define FLOPPY0_TYPE 		fd_drive_type(0)
 #define FLOPPY1_TYPE		fd_drive_type(1)
diff --git a/arch/mips/include/asm/hw_irq.h b/arch/mips/include/asm/hw_irq.h
index aca05a4..77adda2 100644
--- a/arch/mips/include/asm/hw_irq.h
+++ b/arch/mips/include/asm/hw_irq.h
@@ -13,7 +13,7 @@
 extern atomic_t irq_err_count;
 
 /*
- * interrupt-retrigger: NOP for now. This may not be apropriate for all
+ * interrupt-retrigger: NOP for now. This may not be appropriate for all
  * machines, we'll see ...
  */
 
diff --git a/arch/mips/include/asm/io.h b/arch/mips/include/asm/io.h
index 5b017f2..b04e4de 100644
--- a/arch/mips/include/asm/io.h
+++ b/arch/mips/include/asm/io.h
@@ -242,7 +242,7 @@ static inline void __iomem * __ioremap_mode(phys_t offset, unsigned long size,
  * This version of ioremap ensures that the memory is marked uncachable
  * on the CPU as well as honouring existing caching rules from things like
  * the PCI bus. Note that there are other caches and buffers on many
- * busses. In paticular driver authors should read up on PCI writes
+ * busses. In particular driver authors should read up on PCI writes
  *
  * It's useful if some control registers are in such an area and
  * write combining or read caching is not desirable:
diff --git a/arch/mips/include/asm/irqflags.h b/arch/mips/include/asm/irqflags.h
index 9ef3b0d..309cbcd 100644
--- a/arch/mips/include/asm/irqflags.h
+++ b/arch/mips/include/asm/irqflags.h
@@ -174,7 +174,7 @@ __asm__(
 	"mtc0	\\flags, $2, 1						\n"
 #elif defined(CONFIG_CPU_MIPSR2) && defined(CONFIG_IRQ_CPU)
 	/*
-	 * Slow, but doesn't suffer from a relativly unlikely race
+	 * Slow, but doesn't suffer from a relatively unlikely race
 	 * condition we're having since days 1.
 	 */
 	"	beqz	\\flags, 1f					\n"
diff --git a/arch/mips/include/asm/mach-bcm63xx/bcm963xx_tag.h b/arch/mips/include/asm/mach-bcm63xx/bcm963xx_tag.h
index 5325084..32978d3 100644
--- a/arch/mips/include/asm/mach-bcm63xx/bcm963xx_tag.h
+++ b/arch/mips/include/asm/mach-bcm63xx/bcm963xx_tag.h
@@ -4,7 +4,7 @@
 #define TAGVER_LEN		4	/* Length of Tag Version */
 #define TAGLAYOUT_LEN		4	/* Length of FlashLayoutVer */
 #define SIG1_LEN		20	/* Company Signature 1 Length */
-#define SIG2_LEN		14	/* Company Signature 2 Lenght */
+#define SIG2_LEN		14	/* Company Signature 2 Length */
 #define BOARDID_LEN		16	/* Length of BoardId */
 #define ENDIANFLAG_LEN		2	/* Endian Flag Length */
 #define CHIPID_LEN		6	/* Chip Id Length */
diff --git a/arch/mips/include/asm/mach-ip32/mc146818rtc.h b/arch/mips/include/asm/mach-ip32/mc146818rtc.h
index c28ba8d..6b6bab4 100644
--- a/arch/mips/include/asm/mach-ip32/mc146818rtc.h
+++ b/arch/mips/include/asm/mach-ip32/mc146818rtc.h
@@ -26,7 +26,7 @@ static inline void CMOS_WRITE(unsigned char data, unsigned long addr)
 }
 
 /*
- * FIXME: Do it right. For now just assume that noone lives in 20th century
+ * FIXME: Do it right. For now just assume that no one lives in 20th century
  * and no O2 user in 22th century ;-)
  */
 #define mc146818_decode_year(year) ((year) + 2000)
diff --git a/arch/mips/include/asm/mach-loongson/cs5536/cs5536.h b/arch/mips/include/asm/mach-loongson/cs5536/cs5536.h
index 021f77c..2a8e2bb 100644
--- a/arch/mips/include/asm/mach-loongson/cs5536/cs5536.h
+++ b/arch/mips/include/asm/mach-loongson/cs5536/cs5536.h
@@ -1,5 +1,5 @@
 /*
- * The header file of cs5536 sourth bridge.
+ * The header file of cs5536 south bridge.
  *
  * Copyright (C) 2007 Lemote, Inc.
  * Author : jlliu <liujl@lemote.com>
diff --git a/arch/mips/include/asm/mach-pb1x00/pb1000.h b/arch/mips/include/asm/mach-pb1x00/pb1000.h
index 6d1ff90..6505925 100644
--- a/arch/mips/include/asm/mach-pb1x00/pb1000.h
+++ b/arch/mips/include/asm/mach-pb1x00/pb1000.h
@@ -1,5 +1,5 @@
 /*
- * Alchemy Semi Pb1000 Referrence Board
+ * Alchemy Semi Pb1000 Reference Board
  *
  * Copyright 2001, 2008 MontaVista Software Inc.
  * Author: MontaVista Software, Inc. <source@mvista.com>
diff --git a/arch/mips/include/asm/mach-pb1x00/pb1200.h b/arch/mips/include/asm/mach-pb1x00/pb1200.h
index 962eb55..fce4332 100644
--- a/arch/mips/include/asm/mach-pb1x00/pb1200.h
+++ b/arch/mips/include/asm/mach-pb1x00/pb1200.h
@@ -1,5 +1,5 @@
 /*
- * AMD Alchemy Pb1200 Referrence Board
+ * AMD Alchemy Pb1200 Reference Board
  * Board Registers defines.
  *
  * ########################################################################
diff --git a/arch/mips/include/asm/mach-pb1x00/pb1550.h b/arch/mips/include/asm/mach-pb1x00/pb1550.h
index fc4d766..f835c88 100644
--- a/arch/mips/include/asm/mach-pb1x00/pb1550.h
+++ b/arch/mips/include/asm/mach-pb1x00/pb1550.h
@@ -1,5 +1,5 @@
 /*
- * AMD Alchemy Semi PB1550 Referrence Board
+ * AMD Alchemy Semi PB1550 Reference Board
  * Board Registers defines.
  *
  * Copyright 2004 Embedded Edge LLC.
diff --git a/arch/mips/include/asm/mach-powertv/dma-coherence.h b/arch/mips/include/asm/mach-powertv/dma-coherence.h
index f76029c..a8e72cf 100644
--- a/arch/mips/include/asm/mach-powertv/dma-coherence.h
+++ b/arch/mips/include/asm/mach-powertv/dma-coherence.h
@@ -48,7 +48,7 @@ static inline unsigned long virt_to_phys_from_pte(void *addr)
 				/* check for a valid page */
 				if (pte_present(pte)) {
 					/* get the physical address the page is
-					 * refering to */
+					 * referring to */
 					phys_addr = (unsigned long)
 						page_to_phys(pte_page(pte));
 					/* add the offset within the page */
diff --git a/arch/mips/include/asm/mipsregs.h b/arch/mips/include/asm/mipsregs.h
index 4d98709..6a6f8a8 100644
--- a/arch/mips/include/asm/mipsregs.h
+++ b/arch/mips/include/asm/mipsregs.h
@@ -922,7 +922,7 @@ do {									\
 #define write_c0_config7(val)	__write_32bit_c0_register($16, 7, val)
 
 /*
- * The WatchLo register.  There may be upto 8 of them.
+ * The WatchLo register.  There may be up to 8 of them.
  */
 #define read_c0_watchlo0()	__read_ulong_c0_register($18, 0)
 #define read_c0_watchlo1()	__read_ulong_c0_register($18, 1)
@@ -942,7 +942,7 @@ do {									\
 #define write_c0_watchlo7(val)	__write_ulong_c0_register($18, 7, val)
 
 /*
- * The WatchHi register.  There may be upto 8 of them.
+ * The WatchHi register.  There may be up to 8 of them.
  */
 #define read_c0_watchhi0()	__read_32bit_c0_register($19, 0)
 #define read_c0_watchhi1()	__read_32bit_c0_register($19, 1)
diff --git a/arch/mips/include/asm/octeon/cvmx-bootinfo.h b/arch/mips/include/asm/octeon/cvmx-bootinfo.h
index f3c23a4..4e4c3a8 100644
--- a/arch/mips/include/asm/octeon/cvmx-bootinfo.h
+++ b/arch/mips/include/asm/octeon/cvmx-bootinfo.h
@@ -200,7 +200,7 @@ enum cvmx_chip_types_enum {
 	CVMX_CHIP_TYPE_MAX,
 };
 
-/* Compatability alias for NAC38 name change, planned to be removed
+/* Compatibility alias for NAC38 name change, planned to be removed
  * from SDK 1.7 */
 #define CVMX_BOARD_TYPE_NAO38	CVMX_BOARD_TYPE_NAC38
 
diff --git a/arch/mips/include/asm/octeon/cvmx-bootmem.h b/arch/mips/include/asm/octeon/cvmx-bootmem.h
index 8e708bd..877845b 100644
--- a/arch/mips/include/asm/octeon/cvmx-bootmem.h
+++ b/arch/mips/include/asm/octeon/cvmx-bootmem.h
@@ -67,7 +67,7 @@ struct cvmx_bootmem_block_header {
 
 /*
  * Structure for named memory blocks.  Number of descriptors available
- * can be changed without affecting compatiblity, but name length
+ * can be changed without affecting compatibility, but name length
  * changes require a bump in the bootmem descriptor version Note: This
  * structure must be naturally 64 bit aligned, as a single memory
  * image will be used by both 32 and 64 bit programs.
diff --git a/arch/mips/include/asm/octeon/cvmx-l2c.h b/arch/mips/include/asm/octeon/cvmx-l2c.h
index 0b32c5b..2c8ff9e 100644
--- a/arch/mips/include/asm/octeon/cvmx-l2c.h
+++ b/arch/mips/include/asm/octeon/cvmx-l2c.h
@@ -157,7 +157,7 @@ enum cvmx_l2c_tad_event {
 
 /**
  * Configure one of the four L2 Cache performance counters to capture event
- * occurences.
+ * occurrences.
  *
  * @counter:        The counter to configure. Range 0..3.
  * @event:          The type of L2 Cache event occurrence to count.
diff --git a/arch/mips/include/asm/octeon/cvmx.h b/arch/mips/include/asm/octeon/cvmx.h
index 9d9381e..7e12867 100644
--- a/arch/mips/include/asm/octeon/cvmx.h
+++ b/arch/mips/include/asm/octeon/cvmx.h
@@ -151,7 +151,7 @@ enum cvmx_mips_space {
 #endif
 
 /**
- * Convert a memory pointer (void*) into a hardware compatable
+ * Convert a memory pointer (void*) into a hardware compatible
  * memory address (uint64_t). Octeon hardware widgets don't
  * understand logical addresses.
  *
diff --git a/arch/mips/include/asm/paccess.h b/arch/mips/include/asm/paccess.h
index c2394f8..9ce5a1e 100644
--- a/arch/mips/include/asm/paccess.h
+++ b/arch/mips/include/asm/paccess.h
@@ -7,7 +7,7 @@
  * Copyright (C) 1999, 2000 Silicon Graphics, Inc.
  *
  * Protected memory access.  Used for everything that might take revenge
- * by sending a DBE error like accessing possibly non-existant memory or
+ * by sending a DBE error like accessing possibly non-existent memory or
  * devices.
  */
 #ifndef _ASM_PACCESS_H
diff --git a/arch/mips/include/asm/pci/bridge.h b/arch/mips/include/asm/pci/bridge.h
index f1f508e..be44fb0 100644
--- a/arch/mips/include/asm/pci/bridge.h
+++ b/arch/mips/include/asm/pci/bridge.h
@@ -262,7 +262,7 @@ typedef volatile struct bridge_s {
 } bridge_t;
 
 /*
- * Field formats for Error Command Word and Auxillary Error Command Word
+ * Field formats for Error Command Word and Auxiliary Error Command Word
  * of bridge.
  */
 typedef struct bridge_err_cmdword_s {
diff --git a/arch/mips/include/asm/pmc-sierra/msp71xx/msp_regops.h b/arch/mips/include/asm/pmc-sierra/msp71xx/msp_regops.h
index 60a5a38..7d41474 100644
--- a/arch/mips/include/asm/pmc-sierra/msp71xx/msp_regops.h
+++ b/arch/mips/include/asm/pmc-sierra/msp71xx/msp_regops.h
@@ -205,7 +205,7 @@ static inline u32 blocking_read_reg32(volatile u32 *const addr)
  *   custom_read_reg32(address, tmp);	<-- Reads the address and put the value
  *						in the 'tmp' variable given
  *
- *	From here on out, you are (basicly) atomic, so don't do anything too
+ *	From here on out, you are (basically) atomic, so don't do anything too
  *	fancy!
  *	Also, this code may loop if the end of this block fails to write
  *	everything back safely due do the other CPU, so do NOT do anything
diff --git a/arch/mips/include/asm/processor.h b/arch/mips/include/asm/processor.h
index ead6928..c104f10 100644
--- a/arch/mips/include/asm/processor.h
+++ b/arch/mips/include/asm/processor.h
@@ -337,7 +337,7 @@ unsigned long get_wchan(struct task_struct *p);
 /*
  * Return_address is a replacement for __builtin_return_address(count)
  * which on certain architectures cannot reasonably be implemented in GCC
- * (MIPS, Alpha) or is unuseable with -fomit-frame-pointer (i386).
+ * (MIPS, Alpha) or is unusable with -fomit-frame-pointer (i386).
  * Note that __builtin_return_address(x>=1) is forbidden because GCC
  * aborts compilation on some CPUs.  It's simply not possible to unwind
  * some CPU's stackframes.
diff --git a/arch/mips/include/asm/sgi/ioc.h b/arch/mips/include/asm/sgi/ioc.h
index 57a9719..380347b 100644
--- a/arch/mips/include/asm/sgi/ioc.h
+++ b/arch/mips/include/asm/sgi/ioc.h
@@ -17,7 +17,7 @@
 #include <asm/sgi/pi1.h>
 
 /*
- * All registers are 8-bit wide alligned on 32-bit boundary. Bad things
+ * All registers are 8-bit wide aligned on 32-bit boundary. Bad things
  * happen if you try word access them. You have been warned.
  */
 
diff --git a/arch/mips/include/asm/sibyte/sb1250_mac.h b/arch/mips/include/asm/sibyte/sb1250_mac.h
index 591b906..77f7872 100644
--- a/arch/mips/include/asm/sibyte/sb1250_mac.h
+++ b/arch/mips/include/asm/sibyte/sb1250_mac.h
@@ -520,7 +520,7 @@
 #define G_MAC_RX_EOP_COUNTER(x)     _SB_GETVALUE(x, S_MAC_RX_EOP_COUNTER, M_MAC_RX_EOP_COUNTER)
 
 /*
- * MAC Recieve Address Filter Exact Match Registers (Table 9-21)
+ * MAC Receive Address Filter Exact Match Registers (Table 9-21)
  * Registers: MAC_ADDR0_0 through MAC_ADDR7_0
  * Registers: MAC_ADDR0_1 through MAC_ADDR7_1
  * Registers: MAC_ADDR0_2 through MAC_ADDR7_2
@@ -538,7 +538,7 @@
 /* No bitfields */
 
 /*
- * MAC Recieve Address Filter Hash Match Registers (Table 9-22)
+ * MAC Receive Address Filter Hash Match Registers (Table 9-22)
  * Registers: MAC_HASH0_0 through MAC_HASH7_0
  * Registers: MAC_HASH0_1 through MAC_HASH7_1
  * Registers: MAC_HASH0_2 through MAC_HASH7_2
diff --git a/arch/mips/include/asm/siginfo.h b/arch/mips/include/asm/siginfo.h
index 1ca64b4..20ebeb8 100644
--- a/arch/mips/include/asm/siginfo.h
+++ b/arch/mips/include/asm/siginfo.h
@@ -101,7 +101,7 @@ typedef struct siginfo {
 
 /*
  * si_code values
- * Again these have been choosen to be IRIX compatible.
+ * Again these have been chosen to be IRIX compatible.
  */
 #undef SI_ASYNCIO
 #undef SI_TIMER
diff --git a/arch/mips/include/asm/sn/klconfig.h b/arch/mips/include/asm/sn/klconfig.h
index 09e590d..fe02900 100644
--- a/arch/mips/include/asm/sn/klconfig.h
+++ b/arch/mips/include/asm/sn/klconfig.h
@@ -78,7 +78,7 @@ typedef s32 klconf_off_t;
  */
 #define MAX_SLOTS_PER_NODE	(1 + 2 + 6 + 2)
 
-/* XXX if each node is guranteed to have some memory */
+/* XXX if each node is guaranteed to have some memory */
 
 #define MAX_PCI_DEVS		8
 
@@ -539,7 +539,7 @@ typedef struct klinfo_s {                  /* Generic info */
 #define KLSTRUCT_IOC3_TTY 	24
 
 /* Early Access IO proms are compatible
-   only with KLSTRUCT values upto 24. */
+   only with KLSTRUCT values up to 24. */
 
 #define KLSTRUCT_FIBERCHANNEL 	25
 #define KLSTRUCT_MOD_SERIAL_NUM 26
diff --git a/arch/mips/include/asm/sn/sn0/hubio.h b/arch/mips/include/asm/sn/sn0/hubio.h
index 31c76c0..46286d8 100644
--- a/arch/mips/include/asm/sn/sn0/hubio.h
+++ b/arch/mips/include/asm/sn/sn0/hubio.h
@@ -622,7 +622,7 @@ typedef union h1_icrbb_u {
  */
 #define	IIO_ICRB_PROC0		0	/* Source of request is Proc 0 */
 #define	IIO_ICRB_PROC1		1	/* Source of request is Proc 1 */
-#define	IIO_ICRB_GB_REQ		2	/* Source is Guranteed BW request */
+#define	IIO_ICRB_GB_REQ		2	/* Source is Guaranteed BW request */
 #define	IIO_ICRB_IO_REQ		3	/* Source is Normal IO request	*/
 
 /*
diff --git a/arch/mips/include/asm/stackframe.h b/arch/mips/include/asm/stackframe.h
index 58730c5..b4ba244 100644
--- a/arch/mips/include/asm/stackframe.h
+++ b/arch/mips/include/asm/stackframe.h
@@ -346,7 +346,7 @@
 		 * we can't dispatch it directly without trashing
 		 * some registers, so we'll try to detect this unlikely
 		 * case and program a software interrupt in the VPE,
-		 * as would be done for a cross-VPE IPI.  To accomodate
+		 * as would be done for a cross-VPE IPI.  To accommodate
 		 * the handling of that case, we're doing a DVPE instead
 		 * of just a DMT here to protect against other threads.
 		 * This is a lot of cruft to cover a tiny window.
diff --git a/arch/mips/include/asm/war.h b/arch/mips/include/asm/war.h
index 22361d5..fa133c1 100644
--- a/arch/mips/include/asm/war.h
+++ b/arch/mips/include/asm/war.h
@@ -227,7 +227,7 @@
 #endif
 
 /*
- * On the R10000 upto version 2.6 (not sure about 2.7) there is a bug that
+ * On the R10000 up to version 2.6 (not sure about 2.7) there is a bug that
  * may cause ll / sc and lld / scd sequences to execute non-atomically.
  */
 #ifndef R10000_LLSC_WAR
diff --git a/arch/mips/jz4740/board-qi_lb60.c b/arch/mips/jz4740/board-qi_lb60.c
index bc18daa..c3b04be 100644
--- a/arch/mips/jz4740/board-qi_lb60.c
+++ b/arch/mips/jz4740/board-qi_lb60.c
@@ -65,7 +65,7 @@ static struct nand_ecclayout qi_lb60_ecclayout_1gb = {
 };
 
 /* Early prototypes of the QI LB60 had only 1GB of NAND.
- * In order to support these devices aswell the partition and ecc layout is
+ * In order to support these devices as well the partition and ecc layout is
  * initialized depending on the NAND size */
 static struct mtd_partition qi_lb60_partitions_1gb[] = {
 	{
@@ -439,7 +439,7 @@ static struct platform_device *jz_platform_devices[] __initdata = {
 static void __init board_gpio_setup(void)
 {
 	/* We only need to enable/disable pullup here for pins used in generic
-	 * drivers. Everything else is done by the drivers themselfs. */
+	 * drivers. Everything else is done by the drivers themselves. */
 	jz_gpio_disable_pullup(QI_LB60_GPIO_SD_VCC_EN_N);
 	jz_gpio_disable_pullup(QI_LB60_GPIO_SD_CD);
 }
diff --git a/arch/mips/kernel/cpu-bugs64.c b/arch/mips/kernel/cpu-bugs64.c
index b8bb8ba..f305ca1 100644
--- a/arch/mips/kernel/cpu-bugs64.c
+++ b/arch/mips/kernel/cpu-bugs64.c
@@ -73,7 +73,7 @@ static inline void mult_sh_align_mod(long *v1, long *v2, long *w,
 		: "0" (5), "1" (8), "2" (5));
 	align_mod(align, mod);
 	/*
-	 * The trailing nop is needed to fullfill the two-instruction
+	 * The trailing nop is needed to fulfill the two-instruction
 	 * requirement between reading hi/lo and staring a mult/div.
 	 * Leaving it out may cause gas insert a nop itself breaking
 	 * the desired alignment of the next chunk.
diff --git a/arch/mips/kernel/perf_event_mipsxx.c b/arch/mips/kernel/perf_event_mipsxx.c
index d9a7db7..75266ff 100644
--- a/arch/mips/kernel/perf_event_mipsxx.c
+++ b/arch/mips/kernel/perf_event_mipsxx.c
@@ -721,7 +721,7 @@ static void mipsxx_pmu_start(void)
 
 /*
  * MIPS performance counters can be per-TC. The control registers can
- * not be directly accessed accross CPUs. Hence if we want to do global
+ * not be directly accessed across CPUs. Hence if we want to do global
  * control, we need cross CPU calls. on_each_cpu() can help us, but we
  * can not make sure this function is called with interrupts enabled. So
  * here we pause local counters and then grab a rwlock and leave the
diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index ae167df..d2112d3 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -410,7 +410,7 @@ unsigned long unwind_stack(struct task_struct *task, unsigned long *sp,
 	if (!kallsyms_lookup_size_offset(pc, &size, &ofs))
 		return 0;
 	/*
-	 * Return ra if an exception occured at the first instruction
+	 * Return ra if an exception occurred at the first instruction
 	 */
 	if (unlikely(ofs == 0)) {
 		pc = *ra;
diff --git a/arch/mips/kernel/smp-mt.c b/arch/mips/kernel/smp-mt.c
index c0e8141..1ec56e6 100644
--- a/arch/mips/kernel/smp-mt.c
+++ b/arch/mips/kernel/smp-mt.c
@@ -120,7 +120,7 @@ static void vsmp_send_ipi_single(int cpu, unsigned int action)
 
 	local_irq_save(flags);
 
-	vpflags = dvpe();	/* cant access the other CPU's registers whilst MVPE enabled */
+	vpflags = dvpe();	/* can't access the other CPU's registers whilst MVPE enabled */
 
 	switch (action) {
 	case SMP_CALL_FUNCTION:
diff --git a/arch/mips/kernel/time.c b/arch/mips/kernel/time.c
index fb74974..1083ad4 100644
--- a/arch/mips/kernel/time.c
+++ b/arch/mips/kernel/time.c
@@ -102,7 +102,7 @@ static __init int cpu_has_mfc0_count_bug(void)
 	case CPU_R4400SC:
 	case CPU_R4400MC:
 		/*
-		 * The published errata for the R4400 upto 3.0 say the CPU
+		 * The published errata for the R4400 up to 3.0 say the CPU
 		 * has the mfc0 from count bug.
 		 */
 		if ((current_cpu_data.processor_id & 0xff) <= 0x30)
diff --git a/arch/mips/kernel/vpe.c b/arch/mips/kernel/vpe.c
index ab52b7c..dbb6b40 100644
--- a/arch/mips/kernel/vpe.c
+++ b/arch/mips/kernel/vpe.c
@@ -19,7 +19,7 @@
  * VPE support module
  *
  * Provides support for loading a MIPS SP program on VPE1.
- * The SP enviroment is rather simple, no tlb's.  It needs to be relocatable
+ * The SP environment is rather simple, no tlb's.  It needs to be relocatable
  * (or partially linked). You should initialise your stack in the startup
  * code. This loader looks for the symbol __start and sets up
  * execution to resume from there. The MIPS SDE kit contains suitable examples.
diff --git a/arch/mips/lib/strnlen_user.S b/arch/mips/lib/strnlen_user.S
index c768e300..6445716 100644
--- a/arch/mips/lib/strnlen_user.S
+++ b/arch/mips/lib/strnlen_user.S
@@ -17,7 +17,7 @@
 	.previous
 
 /*
- * Return the size of a string including the ending NUL character upto a
+ * Return the size of a string including the ending NUL character up to a
  * maximum of a1 or 0 in case of error.
  *
  * Note: for performance reasons we deliberately accept that a user may
diff --git a/arch/mips/math-emu/dp_fsp.c b/arch/mips/math-emu/dp_fsp.c
index 1dfbd92..daed683 100644
--- a/arch/mips/math-emu/dp_fsp.c
+++ b/arch/mips/math-emu/dp_fsp.c
@@ -62,7 +62,7 @@ ieee754dp ieee754dp_fsp(ieee754sp x)
 		break;
 	}
 
-	/* CANT possibly overflow,underflow, or need rounding
+	/* CAN'T possibly overflow,underflow, or need rounding
 	 */
 
 	/* drop the hidden bit */
diff --git a/arch/mips/math-emu/dp_mul.c b/arch/mips/math-emu/dp_mul.c
index aa566e7..09175f4 100644
--- a/arch/mips/math-emu/dp_mul.c
+++ b/arch/mips/math-emu/dp_mul.c
@@ -104,7 +104,7 @@ ieee754dp ieee754dp_mul(ieee754dp x, ieee754dp y)
 	case CLPAIR(IEEE754_CLASS_NORM, IEEE754_CLASS_NORM):
 		break;
 	}
-	/* rm = xm * ym, re = xe+ye basicly */
+	/* rm = xm * ym, re = xe+ye basically */
 	assert(xm & DP_HIDDEN_BIT);
 	assert(ym & DP_HIDDEN_BIT);
 	{
diff --git a/arch/mips/math-emu/dsemul.c b/arch/mips/math-emu/dsemul.c
index 36d975a..3c4a8c5 100644
--- a/arch/mips/math-emu/dsemul.c
+++ b/arch/mips/math-emu/dsemul.c
@@ -32,7 +32,7 @@
  * not change cp0_epc due to the instruction
  *
  * According to the spec:
- * 1) it shouldnt be a branch :-)
+ * 1) it shouldn't be a branch :-)
  * 2) it can be a COP instruction :-(
  * 3) if we are tring to run a protected memory space we must take
  *    special care on memory access instructions :-(
diff --git a/arch/mips/math-emu/sp_mul.c b/arch/mips/math-emu/sp_mul.c
index c06bb40..2722a25 100644
--- a/arch/mips/math-emu/sp_mul.c
+++ b/arch/mips/math-emu/sp_mul.c
@@ -104,7 +104,7 @@ ieee754sp ieee754sp_mul(ieee754sp x, ieee754sp y)
 	case CLPAIR(IEEE754_CLASS_NORM, IEEE754_CLASS_NORM):
 		break;
 	}
-	/* rm = xm * ym, re = xe+ye basicly */
+	/* rm = xm * ym, re = xe+ye basically */
 	assert(xm & SP_HIDDEN_BIT);
 	assert(ym & SP_HIDDEN_BIT);
 
diff --git a/arch/mips/mm/cex-sb1.S b/arch/mips/mm/cex-sb1.S
index 2d08268..89c412b 100644
--- a/arch/mips/mm/cex-sb1.S
+++ b/arch/mips/mm/cex-sb1.S
@@ -79,7 +79,7 @@ LEAF(except_vec2_sb1)
 recovered_dcache:
 	/*
 	 * Unlock CacheErr-D (which in turn unlocks CacheErr-DPA).
-	 * Ought to log the occurence of this recovered dcache error.
+	 * Ought to log the occurrence of this recovered dcache error.
 	 */
 	b	recovered
 	 mtc0	$0,C0_CERR_D
diff --git a/arch/mips/mm/tlbex.c b/arch/mips/mm/tlbex.c
index 04f9e17..5ef294f 100644
--- a/arch/mips/mm/tlbex.c
+++ b/arch/mips/mm/tlbex.c
@@ -352,7 +352,7 @@ static void __cpuinit __maybe_unused build_tlb_probe_entry(u32 **p)
 
 /*
  * Write random or indexed TLB entry, and care about the hazards from
- * the preceeding mtc0 and for the following eret.
+ * the preceding mtc0 and for the following eret.
  */
 enum tlb_write_entry { tlb_random, tlb_indexed };
 
diff --git a/arch/mips/mti-malta/malta-smtc.c b/arch/mips/mti-malta/malta-smtc.c
index e678915..49a38b0 100644
--- a/arch/mips/mti-malta/malta-smtc.c
+++ b/arch/mips/mti-malta/malta-smtc.c
@@ -130,7 +130,7 @@ int plat_set_irq_affinity(struct irq_data *d, const struct cpumask *affinity,
 	 * cleared in the affinity mask, there will never be any
 	 * interrupt forwarding.  But as soon as a program or operator
 	 * sets affinity for one of the related IRQs, we need to make
-	 * sure that we don't ever try to forward across the VPE boundry,
+	 * sure that we don't ever try to forward across the VPE boundary,
 	 * at least not until we engineer a system where the interrupt
 	 * _ack() or _end() function can somehow know that it corresponds
 	 * to an interrupt taken on another VPE, and perform the appropriate
diff --git a/arch/mips/pci/ops-pmcmsp.c b/arch/mips/pci/ops-pmcmsp.c
index 68798f8..8fbfbf2 100644
--- a/arch/mips/pci/ops-pmcmsp.c
+++ b/arch/mips/pci/ops-pmcmsp.c
@@ -344,7 +344,7 @@ static irqreturn_t bpci_interrupt(int irq, void *dev_id)
  *                              PCI_ACCESS_WRITE and PCI_ACCESS_READ.
  *
  *               bus          - pointer to the bus number of the device to
- *                              be targetted for the configuration cycle.
+ *                              be targeted for the configuration cycle.
  *                              The only element of the pci_bus structure
  *                              used is bus->number. This argument determines
  *                              if the configuration access will be Type 0 or
@@ -354,7 +354,7 @@ static irqreturn_t bpci_interrupt(int irq, void *dev_id)
  *
  *               devfn        - this is an 8-bit field. The lower three bits
  *                              specify the function number of the device to
- *                              be targetted for the configuration cycle, with
+ *                              be targeted for the configuration cycle, with
  *                              all three-bit combinations being legal. The
  *                              upper five bits specify the device number,
  *                              with legal values being 10 to 31.
diff --git a/arch/mips/pci/pci-bcm1480.c b/arch/mips/pci/pci-bcm1480.c
index 6f5e24c..af8c319 100644
--- a/arch/mips/pci/pci-bcm1480.c
+++ b/arch/mips/pci/pci-bcm1480.c
@@ -210,7 +210,7 @@ static int __init bcm1480_pcibios_init(void)
 	PCIBIOS_MIN_IO = 0x00008000UL;
 	PCIBIOS_MIN_MEM = 0x01000000UL;
 
-	/* Set I/O resource limits. - unlimited for now to accomodate HT */
+	/* Set I/O resource limits. - unlimited for now to accommodate HT */
 	ioport_resource.end = 0xffffffffUL;
 	iomem_resource.end = 0xffffffffUL;
 
diff --git a/arch/mips/pci/pci-octeon.c b/arch/mips/pci/pci-octeon.c
index 2d74fc9..ed1c542 100644
--- a/arch/mips/pci/pci-octeon.c
+++ b/arch/mips/pci/pci-octeon.c
@@ -441,7 +441,7 @@ static void octeon_pci_initialize(void)
 
 	/*
 	 * TDOMC must be set to one in PCI mode. TDOMC should be set to 4
-	 * in PCI-X mode to allow four oustanding splits. Otherwise,
+	 * in PCI-X mode to allow four outstanding splits. Otherwise,
 	 * should not change from its reset value. Don't write PCI_CFG19
 	 * in PCI mode (0x82000001 reset value), write it to 0x82000004
 	 * after PCI-X mode is known. MRBCI,MDWE,MDRE -> must be zero.
@@ -515,7 +515,7 @@ static void octeon_pci_initialize(void)
 #endif	/* USE_OCTEON_INTERNAL_ARBITER */
 
 	/*
-	 * Preferrably written to 1 to set MLTD. [RDSATI,TRTAE,
+	 * Preferably written to 1 to set MLTD. [RDSATI,TRTAE,
 	 * TWTAE,TMAE,DPPMR -> must be zero. TILT -> must not be set to
 	 * 1..7.
 	 */
diff --git a/arch/mips/pci/pci.c b/arch/mips/pci/pci.c
index 38bc280..33bba7b 100644
--- a/arch/mips/pci/pci.c
+++ b/arch/mips/pci/pci.c
@@ -125,7 +125,7 @@ void __devinit register_pci_controller(struct pci_controller *hose)
 	hose_tail = &hose->next;
 
 	/*
-	 * Do not panic here but later - this might hapen before console init.
+	 * Do not panic here but later - this might happen before console init.
 	 */
 	if (!hose->io_map_base) {
 		printk(KERN_WARNING
diff --git a/arch/mips/pmc-sierra/msp71xx/msp_setup.c b/arch/mips/pmc-sierra/msp71xx/msp_setup.c
index fb37a10..2413ea6 100644
--- a/arch/mips/pmc-sierra/msp71xx/msp_setup.c
+++ b/arch/mips/pmc-sierra/msp71xx/msp_setup.c
@@ -239,7 +239,7 @@ void __init prom_init(void)
 #ifdef CONFIG_PMCTWILED
 	/*
 	 * Setup LED states before the subsys_initcall loads other
-	 * dependant drivers/modules.
+	 * dependent drivers/modules.
 	 */
 	pmctwiled_setup();
 #endif
diff --git a/arch/mips/pnx833x/common/platform.c b/arch/mips/pnx833x/common/platform.c
index ce45df1..87167dc 100644
--- a/arch/mips/pnx833x/common/platform.c
+++ b/arch/mips/pnx833x/common/platform.c
@@ -165,7 +165,7 @@ static struct i2c_pnx0105_dev pnx833x_i2c_dev[] = {
 	{
 		.base = PNX833X_I2C0_PORTS_START,
 		.irq = -1, /* should be PNX833X_PIC_I2C0_INT but polling is faster */
-		.clock = 6,	/* 0 == 400 kHz, 4 == 100 kHz(Maximum HDMI), 6 = 50kHz(Prefered HDCP) */
+		.clock = 6,	/* 0 == 400 kHz, 4 == 100 kHz(Maximum HDMI), 6 = 50kHz(Preferred HDCP) */
 		.bus_addr = 0,	/* no slave support */
 	},
 	{
diff --git a/arch/mips/sgi-ip27/Kconfig b/arch/mips/sgi-ip27/Kconfig
index 5e960ae..bc5e976 100644
--- a/arch/mips/sgi-ip27/Kconfig
+++ b/arch/mips/sgi-ip27/Kconfig
@@ -1,7 +1,7 @@
 #config SGI_SN0_XXL
 #	bool "IP27 XXL"
 #	depends on SGI_IP27
-#	  This options adds support for userspace processes upto 16TB size.
+#	  This options adds support for userspace processes up to 16TB size.
 #	  Normally the limit is just .5TB.
 
 choice
diff --git a/arch/mips/sgi-ip27/TODO b/arch/mips/sgi-ip27/TODO
index 19f1512..160857f 100644
--- a/arch/mips/sgi-ip27/TODO
+++ b/arch/mips/sgi-ip27/TODO
@@ -13,7 +13,7 @@ being invoked on all nodes in ip27-memory.c.
 9. start_thread must turn off UX64 ... and define tlb_refill_debug.
 10. Need a bad pmd table, bad pte table. __bad_pmd_table/__bad_pagetable
 does not agree with pgd_bad/pmd_bad.
-11. All intrs (ip27_do_irq handlers) are targetted at cpu A on the node.
+11. All intrs (ip27_do_irq handlers) are targeted at cpu A on the node.
 This might need to change later. Only the timer intr is set up to be
 received on both Cpu A and B. (ip27_do_irq()/bridge_startup())
 13. Cache flushing (specially the SMP version) has to be investigated.
diff --git a/arch/mips/sgi-ip27/ip27-init.c b/arch/mips/sgi-ip27/ip27-init.c
index 51d3a4f..923c080 100644
--- a/arch/mips/sgi-ip27/ip27-init.c
+++ b/arch/mips/sgi-ip27/ip27-init.c
@@ -93,7 +93,7 @@ static void __cpuinit per_hub_init(cnodeid_t cnode)
 
 	/*
 	 * Some interrupts are reserved by hardware or by software convention.
-	 * Mark these as reserved right away so they won't be used accidently
+	 * Mark these as reserved right away so they won't be used accidentally
 	 * later.
 	 */
 	for (i = 0; i <= BASE_PCI_IRQ; i++) {
diff --git a/arch/mips/sgi-ip27/ip27-irq.c b/arch/mips/sgi-ip27/ip27-irq.c
index 1148871..0a04603 100644
--- a/arch/mips/sgi-ip27/ip27-irq.c
+++ b/arch/mips/sgi-ip27/ip27-irq.c
@@ -41,7 +41,7 @@
  * Linux has a controller-independent x86 interrupt architecture.
  * every controller has a 'controller-template', that is used
  * by the main code to do the right thing. Each driver-visible
- * interrupt source is transparently wired to the apropriate
+ * interrupt source is transparently wired to the appropriate
  * controller. Thus drivers need not be aware of the
  * interrupt-controller.
  *
diff --git a/arch/mn10300/include/asm/cpu-regs.h b/arch/mn10300/include/asm/cpu-regs.h
index 90ed4a3..c54effa 100644
--- a/arch/mn10300/include/asm/cpu-regs.h
+++ b/arch/mn10300/include/asm/cpu-regs.h
@@ -49,7 +49,7 @@ asm(" .am33_2\n");
 #define EPSW_IM_6		0x00000600	/* interrupt mode 6 */
 #define EPSW_IM_7		0x00000700	/* interrupt mode 7 */
 #define EPSW_IE			0x00000800	/* interrupt enable */
-#define EPSW_S			0x00003000	/* software auxilliary bits */
+#define EPSW_S			0x00003000	/* software auxiliary bits */
 #define EPSW_T			0x00008000	/* trace enable */
 #define EPSW_nSL		0x00010000	/* not supervisor level */
 #define EPSW_NMID		0x00020000	/* nonmaskable interrupt disable */
diff --git a/arch/parisc/include/asm/eisa_eeprom.h b/arch/parisc/include/asm/eisa_eeprom.h
index 9c9da98..8ce8b85 100644
--- a/arch/parisc/include/asm/eisa_eeprom.h
+++ b/arch/parisc/include/asm/eisa_eeprom.h
@@ -27,7 +27,7 @@ struct eeprom_header
 	u_int8_t  ver_maj;
 	u_int8_t  ver_min;
 	u_int8_t  num_slots;        /* number of EISA slots in system */
-	u_int16_t csum;             /* checksum, I don't know how to calulate this */
+	u_int16_t csum;             /* checksum, I don't know how to calculate this */
 	u_int8_t  pad[10];
 } __attribute__ ((packed));
 
diff --git a/arch/parisc/kernel/entry.S b/arch/parisc/kernel/entry.S
index e547709..ead8d2a 100644
--- a/arch/parisc/kernel/entry.S
+++ b/arch/parisc/kernel/entry.S
@@ -187,8 +187,8 @@
 
 	/* Register definitions for tlb miss handler macros */
 
-	va  = r8	/* virtual address for which the trap occured */
-	spc = r24	/* space for which the trap occured */
+	va  = r8	/* virtual address for which the trap occurred */
+	spc = r24	/* space for which the trap occurred */
 
 #ifndef CONFIG_64BIT
 
@@ -882,7 +882,7 @@ ENTRY(syscall_exit_rfi)
 	 * (we don't store them in the sigcontext), so set them
 	 * to "proper" values now (otherwise we'll wind up restoring
 	 * whatever was last stored in the task structure, which might
-	 * be inconsistent if an interrupt occured while on the gateway
+	 * be inconsistent if an interrupt occurred while on the gateway
 	 * page). Note that we may be "trashing" values the user put in
 	 * them, but we don't support the user changing them.
 	 */
@@ -1156,11 +1156,11 @@ ENDPROC(intr_save)
 	 */
 
 	t0 = r1		/* temporary register 0 */
-	va = r8		/* virtual address for which the trap occured */
+	va = r8		/* virtual address for which the trap occurred */
 	t1 = r9		/* temporary register 1 */
 	pte  = r16	/* pte/phys page # */
 	prot = r17	/* prot bits */
-	spc  = r24	/* space for which the trap occured */
+	spc  = r24	/* space for which the trap occurred */
 	ptp = r25	/* page directory/page table pointer */
 
 #ifdef CONFIG_64BIT
diff --git a/arch/parisc/kernel/head.S b/arch/parisc/kernel/head.S
index 4dbdf0e..145c5e4 100644
--- a/arch/parisc/kernel/head.S
+++ b/arch/parisc/kernel/head.S
@@ -131,7 +131,7 @@ $pgt_fill_loop:
 	ldo             THREAD_SZ_ALGN(%r6),%sp
 
 #ifdef CONFIG_SMP
-	/* Set the smp rendevous address into page zero.
+	/* Set the smp rendezvous address into page zero.
 	** It would be safer to do this in init_smp_config() but
 	** it's just way easier to deal with here because
 	** of 64-bit function ptrs and the address is local to this file.
diff --git a/arch/parisc/kernel/inventory.c b/arch/parisc/kernel/inventory.c
index d228d82..08324aa 100644
--- a/arch/parisc/kernel/inventory.c
+++ b/arch/parisc/kernel/inventory.c
@@ -93,7 +93,7 @@ void __init setup_pdc(void)
 	case 0x6:		/* 705, 710 */
 	case 0x7:		/* 715, 725 */
 	case 0x8:		/* 745, 747, 742 */
-	case 0xA:		/* 712 and similiar */
+	case 0xA:		/* 712 and similar */
 	case 0xC:		/* 715/64, at least */
 
 		pdc_type = PDC_TYPE_SNAKE;
diff --git a/arch/parisc/kernel/signal.c b/arch/parisc/kernel/signal.c
index 609a331..12c1ed3 100644
--- a/arch/parisc/kernel/signal.c
+++ b/arch/parisc/kernel/signal.c
@@ -291,7 +291,7 @@ setup_rt_frame(int sig, struct k_sigaction *ka, siginfo_t *info,
 		DBG(1,"setup_rt_frame: frame->uc = 0x%p\n", &frame->uc);
 		DBG(1,"setup_rt_frame: frame->uc.uc_mcontext = 0x%p\n", &frame->uc.uc_mcontext);
 		err |= setup_sigcontext(&frame->uc.uc_mcontext, regs, in_syscall);
-		/* FIXME: Should probably be converted aswell for the compat case */
+		/* FIXME: Should probably be converted as well for the compat case */
 		err |= __copy_to_user(&frame->uc.uc_sigmask, set, sizeof(*set));
 	}
 	
diff --git a/arch/parisc/kernel/syscall.S b/arch/parisc/kernel/syscall.S
index 68e75ce..82a52b2 100644
--- a/arch/parisc/kernel/syscall.S
+++ b/arch/parisc/kernel/syscall.S
@@ -605,7 +605,7 @@ cas_action:
 	copy	%r0, %r21
 
 3:		
-	/* Error occured on load or store */
+	/* Error occurred on load or store */
 	/* Free lock */
 	stw	%r20, 0(%sr2,%r20)
 #if ENABLE_LWS_DEBUG
diff --git a/arch/parisc/kernel/syscall_table.S b/arch/parisc/kernel/syscall_table.S
index 74867df..4be85ee 100644
--- a/arch/parisc/kernel/syscall_table.S
+++ b/arch/parisc/kernel/syscall_table.S
@@ -34,7 +34,7 @@
 /* Use ENTRY_SAME for 32-bit syscalls which are the same on wide and
  * narrow palinux.  Use ENTRY_DIFF for those where a 32-bit specific
  * implementation is required on wide palinux.  Use ENTRY_COMP where
- * the compatability layer has a useful 32-bit implementation.
+ * the compatibility layer has a useful 32-bit implementation.
  */
 #define ENTRY_SAME(_name_) .dword sys_##_name_
 #define ENTRY_DIFF(_name_) .dword sys32_##_name_
diff --git a/arch/parisc/math-emu/dfadd.c b/arch/parisc/math-emu/dfadd.c
index e147d7d..d37e2d2 100644
--- a/arch/parisc/math-emu/dfadd.c
+++ b/arch/parisc/math-emu/dfadd.c
@@ -303,7 +303,7 @@ dbl_fadd(
 	if(Dbl_iszero_hidden(resultp1))
 	    {
 	    /* Handle normalization */
-	    /* A straight foward algorithm would now shift the result
+	    /* A straight forward algorithm would now shift the result
 	     * and extension left until the hidden bit becomes one.  Not
 	     * all of the extension bits need participate in the shift.
 	     * Only the two most significant bits (round and guard) are
diff --git a/arch/parisc/math-emu/dfsub.c b/arch/parisc/math-emu/dfsub.c
index 87ebc60..2e8b5a7 100644
--- a/arch/parisc/math-emu/dfsub.c
+++ b/arch/parisc/math-emu/dfsub.c
@@ -306,7 +306,7 @@ dbl_fsub(
 	if(Dbl_iszero_hidden(resultp1))
 	    {
 	    /* Handle normalization */
-	    /* A straight foward algorithm would now shift the result
+	    /* A straight forward algorithm would now shift the result
 	     * and extension left until the hidden bit becomes one.  Not
 	     * all of the extension bits need participate in the shift.
 	     * Only the two most significant bits (round and guard) are
diff --git a/arch/parisc/math-emu/fmpyfadd.c b/arch/parisc/math-emu/fmpyfadd.c
index 5dd7f93..b067c45 100644
--- a/arch/parisc/math-emu/fmpyfadd.c
+++ b/arch/parisc/math-emu/fmpyfadd.c
@@ -531,7 +531,7 @@ dbl_fmpyfadd(
 		sign_save = Dbl_signextendedsign(resultp1);
 		if (Dbl_iszero_hidden(resultp1)) {
 			/* Handle normalization */
-		/* A straight foward algorithm would now shift the
+		/* A straightforward algorithm would now shift the
 		 * result and extension left until the hidden bit
 		 * becomes one.  Not all of the extension bits need
 		 * participate in the shift.  Only the two most 
@@ -1191,7 +1191,7 @@ unsigned int *status;
 		sign_save = Dbl_signextendedsign(resultp1);
 		if (Dbl_iszero_hidden(resultp1)) {
 			/* Handle normalization */
-		/* A straight foward algorithm would now shift the
+		/* A straightforward algorithm would now shift the
 		 * result and extension left until the hidden bit
 		 * becomes one.  Not all of the extension bits need
 		 * participate in the shift.  Only the two most 
@@ -1841,7 +1841,7 @@ unsigned int *status;
 		sign_save = Sgl_signextendedsign(resultp1);
 		if (Sgl_iszero_hidden(resultp1)) {
 			/* Handle normalization */
-		/* A straight foward algorithm would now shift the
+		/* A straightforward algorithm would now shift the
 		 * result and extension left until the hidden bit
 		 * becomes one.  Not all of the extension bits need
 		 * participate in the shift.  Only the two most 
@@ -2483,7 +2483,7 @@ unsigned int *status;
 		sign_save = Sgl_signextendedsign(resultp1);
 		if (Sgl_iszero_hidden(resultp1)) {
 			/* Handle normalization */
-		/* A straight foward algorithm would now shift the
+		/* A straightforward algorithm would now shift the
 		 * result and extension left until the hidden bit
 		 * becomes one.  Not all of the extension bits need
 		 * participate in the shift.  Only the two most 
diff --git a/arch/parisc/math-emu/sfadd.c b/arch/parisc/math-emu/sfadd.c
index 008d721..f802cd6 100644
--- a/arch/parisc/math-emu/sfadd.c
+++ b/arch/parisc/math-emu/sfadd.c
@@ -298,7 +298,7 @@ sgl_fadd(
 	if(Sgl_iszero_hidden(result))
 	    {
 	    /* Handle normalization */
-	    /* A straight foward algorithm would now shift the result
+	    /* A straightforward algorithm would now shift the result
 	     * and extension left until the hidden bit becomes one.  Not
 	     * all of the extension bits need participate in the shift.
 	     * Only the two most significant bits (round and guard) are
diff --git a/arch/parisc/math-emu/sfsub.c b/arch/parisc/math-emu/sfsub.c
index 24eef61..5f90d0f 100644
--- a/arch/parisc/math-emu/sfsub.c
+++ b/arch/parisc/math-emu/sfsub.c
@@ -301,7 +301,7 @@ sgl_fsub(
 	if(Sgl_iszero_hidden(result))
 	    {
 	    /* Handle normalization */
-	    /* A straight foward algorithm would now shift the result
+	    /* A straightforward algorithm would now shift the result
 	     * and extension left until the hidden bit becomes one.  Not
 	     * all of the extension bits need participate in the shift.
 	     * Only the two most significant bits (round and guard) are
diff --git a/arch/powerpc/include/asm/bitops.h b/arch/powerpc/include/asm/bitops.h
index 2e56187..f18c6d9 100644
--- a/arch/powerpc/include/asm/bitops.h
+++ b/arch/powerpc/include/asm/bitops.h
@@ -209,8 +209,8 @@ static __inline__ unsigned long ffz(unsigned long x)
 		return BITS_PER_LONG;
 
 	/*
-	 * Calculate the bit position of the least signficant '1' bit in x
-	 * (since x has been changed this will actually be the least signficant
+	 * Calculate the bit position of the least significant '1' bit in x
+	 * (since x has been changed this will actually be the least significant
 	 * '0' bit in * the original x).  Note: (x & -x) gives us a mask that
 	 * is the least significant * (RIGHT-most) 1-bit of the value in x.
 	 */
diff --git a/arch/powerpc/include/asm/compat.h b/arch/powerpc/include/asm/compat.h
index 2296112..91010e8 100644
--- a/arch/powerpc/include/asm/compat.h
+++ b/arch/powerpc/include/asm/compat.h
@@ -140,7 +140,7 @@ static inline void __user *arch_compat_alloc_user_space(long len)
 	unsigned long usp = regs->gpr[1];
 
 	/*
-	 * We cant access below the stack pointer in the 32bit ABI and
+	 * We can't access below the stack pointer in the 32bit ABI and
 	 * can access 288 bytes in the 64bit ABI
 	 */
 	if (!is_32bit_task())
diff --git a/arch/powerpc/include/asm/cpm.h b/arch/powerpc/include/asm/cpm.h
index e50323f..4398a6c 100644
--- a/arch/powerpc/include/asm/cpm.h
+++ b/arch/powerpc/include/asm/cpm.h
@@ -98,7 +98,7 @@ typedef struct cpm_buf_desc {
 #define BD_SC_INTRPT	(0x1000)	/* Interrupt on change */
 #define BD_SC_LAST	(0x0800)	/* Last buffer in frame */
 #define BD_SC_TC	(0x0400)	/* Transmit CRC */
-#define BD_SC_CM	(0x0200)	/* Continous mode */
+#define BD_SC_CM	(0x0200)	/* Continuous mode */
 #define BD_SC_ID	(0x0100)	/* Rec'd too many idles */
 #define BD_SC_P		(0x0100)	/* xmt preamble */
 #define BD_SC_BR	(0x0020)	/* Break received */
diff --git a/arch/powerpc/include/asm/cpm1.h b/arch/powerpc/include/asm/cpm1.h
index bd07650d..8ee4211 100644
--- a/arch/powerpc/include/asm/cpm1.h
+++ b/arch/powerpc/include/asm/cpm1.h
@@ -4,7 +4,7 @@
  *
  * This file contains structures and information for the communication
  * processor channels.  Some CPM control and status is available
- * throught the MPC8xx internal memory map.  See immap.h for details.
+ * through the MPC8xx internal memory map.  See immap.h for details.
  * This file only contains what I need for the moment, not the total
  * CPM capabilities.  I (or someone else) will add definitions as they
  * are needed.  -- Dan
diff --git a/arch/powerpc/include/asm/hvcall.h b/arch/powerpc/include/asm/hvcall.h
index ec089ac..8edec71 100644
--- a/arch/powerpc/include/asm/hvcall.h
+++ b/arch/powerpc/include/asm/hvcall.h
@@ -122,7 +122,7 @@
 #define H_DABRX_KERNEL		(1UL<<(63-62))
 #define H_DABRX_USER		(1UL<<(63-63))
 
-/* Each control block has to be on a 4K bondary */
+/* Each control block has to be on a 4K boundary */
 #define H_CB_ALIGNMENT          4096
 
 /* pSeries hypervisor opcodes */
diff --git a/arch/powerpc/include/asm/kprobes.h b/arch/powerpc/include/asm/kprobes.h
index d0e7701..be0171a 100644
--- a/arch/powerpc/include/asm/kprobes.h
+++ b/arch/powerpc/include/asm/kprobes.h
@@ -50,7 +50,7 @@ typedef unsigned int kprobe_opcode_t;
  * Handle cases where:
  * 		- User passes a <.symbol> or <module:.symbol>
  * 		- User passes a <symbol> or <module:symbol>
- * 		- User passes a non-existant symbol, kallsyms_lookup_name
+ * 		- User passes a non-existent symbol, kallsyms_lookup_name
  * 		  returns 0. Don't deref the NULL pointer in that case
  */
 #define kprobe_lookup_name(name, addr)					\
diff --git a/arch/powerpc/include/asm/lppaca.h b/arch/powerpc/include/asm/lppaca.h
index 26b8c80..a077adc 100644
--- a/arch/powerpc/include/asm/lppaca.h
+++ b/arch/powerpc/include/asm/lppaca.h
@@ -105,7 +105,7 @@ struct lppaca {
 	// processing of external interrupts.  Note that PLIC will store the
 	// XIRR directly into the xXirrValue field so that another XIRR will
 	// not be presented until this one clears.  The layout of the low
-	// 4-bytes of this Dword is upto SLIC - PLIC just checks whether the
+	// 4-bytes of this Dword is up to SLIC - PLIC just checks whether the
 	// entire Dword is zero or not.  A non-zero value in the low order
 	// 2-bytes will result in SLIC being granted the highest thread
 	// priority upon return.  A 0 will return to SLIC as medium priority.
diff --git a/arch/powerpc/include/asm/page_64.h b/arch/powerpc/include/asm/page_64.h
index 932f88d..812b2cd 100644
--- a/arch/powerpc/include/asm/page_64.h
+++ b/arch/powerpc/include/asm/page_64.h
@@ -169,7 +169,7 @@ do {						\
 /*
  * This is the default if a program doesn't have a PT_GNU_STACK
  * program header entry. The PPC64 ELF ABI has a non executable stack
- * stack by default, so in the absense of a PT_GNU_STACK program header
+ * stack by default, so in the absence of a PT_GNU_STACK program header
  * we turn execute permission off.
  */
 #define VM_STACK_DEFAULT_FLAGS32	(VM_READ | VM_WRITE | VM_EXEC | \
diff --git a/arch/powerpc/include/asm/pasemi_dma.h b/arch/powerpc/include/asm/pasemi_dma.h
index 19fd793..eafa5a5 100644
--- a/arch/powerpc/include/asm/pasemi_dma.h
+++ b/arch/powerpc/include/asm/pasemi_dma.h
@@ -522,7 +522,7 @@ extern void *pasemi_dma_alloc_buf(struct pasemi_dmachan *chan, int size,
 extern void pasemi_dma_free_buf(struct pasemi_dmachan *chan, int size,
 				dma_addr_t *handle);
 
-/* Routines to allocate flags (events) for channel syncronization */
+/* Routines to allocate flags (events) for channel synchronization */
 extern int  pasemi_dma_alloc_flag(void);
 extern void pasemi_dma_free_flag(int flag);
 extern void pasemi_dma_set_flag(int flag);
diff --git a/arch/powerpc/include/asm/pci-bridge.h b/arch/powerpc/include/asm/pci-bridge.h
index 5e156e0..b90dbf8 100644
--- a/arch/powerpc/include/asm/pci-bridge.h
+++ b/arch/powerpc/include/asm/pci-bridge.h
@@ -106,7 +106,7 @@ struct pci_controller {
 	 * Used for variants of PCI indirect handling and possible quirks:
 	 *  SET_CFG_TYPE - used on 4xx or any PHB that does explicit type0/1
 	 *  EXT_REG - provides access to PCI-e extended registers
-	 *  SURPRESS_PRIMARY_BUS - we surpress the setting of PCI_PRIMARY_BUS
+	 *  SURPRESS_PRIMARY_BUS - we suppress the setting of PCI_PRIMARY_BUS
 	 *   on Freescale PCI-e controllers since they used the PCI_PRIMARY_BUS
 	 *   to determine which bus number to match on when generating type0
 	 *   config cycles
diff --git a/arch/powerpc/include/asm/pmac_feature.h b/arch/powerpc/include/asm/pmac_feature.h
index 00eedc5..10902c9 100644
--- a/arch/powerpc/include/asm/pmac_feature.h
+++ b/arch/powerpc/include/asm/pmac_feature.h
@@ -53,8 +53,8 @@
 
 /* Here is the infamous serie of OHare based machines
  */
-#define PMAC_TYPE_COMET			0x20	/* Beleived to be PowerBook 2400 */
-#define PMAC_TYPE_HOOPER		0x21	/* Beleived to be PowerBook 3400 */
+#define PMAC_TYPE_COMET			0x20	/* Believed to be PowerBook 2400 */
+#define PMAC_TYPE_HOOPER		0x21	/* Believed to be PowerBook 3400 */
 #define PMAC_TYPE_KANGA			0x22	/* PowerBook 3500 (first G3) */
 #define PMAC_TYPE_ALCHEMY		0x23	/* Alchemy motherboard base */
 #define PMAC_TYPE_GAZELLE		0x24	/* Spartacus, some 5xxx/6xxx */
diff --git a/arch/powerpc/include/asm/pte-common.h b/arch/powerpc/include/asm/pte-common.h
index 76bb195..811f04a 100644
--- a/arch/powerpc/include/asm/pte-common.h
+++ b/arch/powerpc/include/asm/pte-common.h
@@ -86,7 +86,7 @@ extern unsigned long bad_call_to_PMD_PAGE_SIZE(void);
 #define PTE_RPN_MASK	(~((1UL<<PTE_RPN_SHIFT)-1))
 #endif
 
-/* _PAGE_CHG_MASK masks of bits that are to be preserved accross
+/* _PAGE_CHG_MASK masks of bits that are to be preserved across
  * pgprot changes
  */
 #define _PAGE_CHG_MASK	(PTE_RPN_MASK | _PAGE_HPTEFLAGS | _PAGE_DIRTY | \
@@ -174,7 +174,7 @@ extern unsigned long bad_call_to_PMD_PAGE_SIZE(void);
 /*
  * Don't just check for any non zero bits in __PAGE_USER, since for book3e
  * and PTE_64BIT, PAGE_KERNEL_X contains _PAGE_BAP_SR which is also in
- * _PAGE_USER.  Need to explictly match _PAGE_BAP_UR bit in that case too.
+ * _PAGE_USER.  Need to explicitly match _PAGE_BAP_UR bit in that case too.
  */
 #define pte_user(val)		((val & _PAGE_USER) == _PAGE_USER)
 
diff --git a/arch/powerpc/include/asm/reg_booke.h b/arch/powerpc/include/asm/reg_booke.h
index 3b1a9b7..b316794 100644
--- a/arch/powerpc/include/asm/reg_booke.h
+++ b/arch/powerpc/include/asm/reg_booke.h
@@ -2,7 +2,7 @@
  * Contains register definitions common to the Book E PowerPC
  * specification.  Notice that while the IBM-40x series of CPUs
  * are not true Book E PowerPCs, they borrowed a number of features
- * before Book E was finalized, and are included here as well.  Unfortunatly,
+ * before Book E was finalized, and are included here as well.  Unfortunately,
  * they sometimes used different locations than true Book E CPUs did.
  *
  * This program is free software; you can redistribute it and/or
diff --git a/arch/powerpc/include/asm/spu_priv1.h b/arch/powerpc/include/asm/spu_priv1.h
index 25020a3..d8f5c60 100644
--- a/arch/powerpc/include/asm/spu_priv1.h
+++ b/arch/powerpc/include/asm/spu_priv1.h
@@ -223,7 +223,7 @@ spu_disable_spu (struct spu_context *ctx)
 }
 
 /*
- * The declarations folowing are put here for convenience
+ * The declarations following are put here for convenience
  * and only intended to be used by the platform setup code.
  */
 
diff --git a/arch/powerpc/include/asm/uninorth.h b/arch/powerpc/include/asm/uninorth.h
index f737732..ae9c899 100644
--- a/arch/powerpc/include/asm/uninorth.h
+++ b/arch/powerpc/include/asm/uninorth.h
@@ -60,7 +60,7 @@
  *
  * Obviously, the GART is not cache coherent and so any change to it
  * must be flushed to memory (or maybe just make the GART space non
- * cachable). AGP memory itself doens't seem to be cache coherent neither.
+ * cachable). AGP memory itself does't seem to be cache coherent neither.
  *
  * In order to invalidate the GART (which is probably necessary to inval
  * the bridge internal TLBs), the following sequence has to be written,
diff --git a/arch/powerpc/include/asm/vdso_datapage.h b/arch/powerpc/include/asm/vdso_datapage.h
index 25e3922..b73a819 100644
--- a/arch/powerpc/include/asm/vdso_datapage.h
+++ b/arch/powerpc/include/asm/vdso_datapage.h
@@ -57,7 +57,7 @@ struct vdso_data {
 	} version;
 
 	/* Note about the platform flags: it now only contains the lpar
-	 * bit. The actual platform number is dead and burried
+	 * bit. The actual platform number is dead and buried
 	 */
 	__u32 platform;			/* Platform flags		0x18 */
 	__u32 processor;		/* Processor type		0x1C */
diff --git a/arch/powerpc/kernel/btext.c b/arch/powerpc/kernel/btext.c
index 625942a..60b3e37 100644
--- a/arch/powerpc/kernel/btext.c
+++ b/arch/powerpc/kernel/btext.c
@@ -99,7 +99,7 @@ void __init btext_prepare_BAT(void)
 
 /* This function can be used to enable the early boot text when doing
  * OF booting or within bootx init. It must be followed by a btext_unmap()
- * call before the logical address becomes unuseable
+ * call before the logical address becomes unusable
  */
 void __init btext_setup_display(int width, int height, int depth, int pitch,
 				unsigned long address)
diff --git a/arch/powerpc/kernel/exceptions-64e.S b/arch/powerpc/kernel/exceptions-64e.S
index 5c43063..9651acc 100644
--- a/arch/powerpc/kernel/exceptions-64e.S
+++ b/arch/powerpc/kernel/exceptions-64e.S
@@ -379,7 +379,7 @@ interrupt_end_book3e:
 	mfspr	r13,SPRN_SPRG_PACA	/* get our PACA */
 	b	system_call_common
 
-/* Auxillary Processor Unavailable Interrupt */
+/* Auxiliary Processor Unavailable Interrupt */
 	START_EXCEPTION(ap_unavailable);
 	NORMAL_EXCEPTION_PROLOG(0xf20, PROLOG_ADDITION_NONE)
 	EXCEPTION_COMMON(0xf20, PACA_EXGEN, INTS_KEEP)
diff --git a/arch/powerpc/kernel/exceptions-64s.S b/arch/powerpc/kernel/exceptions-64s.S
index c532cb2..aeb739e 100644
--- a/arch/powerpc/kernel/exceptions-64s.S
+++ b/arch/powerpc/kernel/exceptions-64s.S
@@ -5,7 +5,7 @@
  * handling and other fixed offset specific things.
  *
  * This file is meant to be #included from head_64.S due to
- * position dependant assembly.
+ * position dependent assembly.
  *
  * Most of this originates from head_64.S and thus has the same
  * copyright history.
diff --git a/arch/powerpc/kernel/head_40x.S b/arch/powerpc/kernel/head_40x.S
index 9dd21a8..a91626d 100644
--- a/arch/powerpc/kernel/head_40x.S
+++ b/arch/powerpc/kernel/head_40x.S
@@ -766,7 +766,7 @@ DataAccess:
 	 * miss get to this point to load the TLB.
 	 * 	r10 - TLB_TAG value
 	 * 	r11 - Linux PTE
-	 *	r12, r9 - avilable to use
+	 *	r12, r9 - available to use
 	 *	PID - loaded with proper value when we get here
 	 *	Upon exit, we reload everything and RFI.
 	 * Actually, it will fit now, but oh well.....a common place
diff --git a/arch/powerpc/kernel/head_44x.S b/arch/powerpc/kernel/head_44x.S
index cbb3436..5e12b74 100644
--- a/arch/powerpc/kernel/head_44x.S
+++ b/arch/powerpc/kernel/head_44x.S
@@ -178,7 +178,7 @@ interrupt_base:
 	NORMAL_EXCEPTION_PROLOG
 	EXC_XFER_EE_LITE(0x0c00, DoSyscall)
 
-	/* Auxillary Processor Unavailable Interrupt */
+	/* Auxiliary Processor Unavailable Interrupt */
 	EXCEPTION(0x2020, AuxillaryProcessorUnavailable, unknown_exception, EXC_XFER_EE)
 
 	/* Decrementer Interrupt */
diff --git a/arch/powerpc/kernel/head_64.S b/arch/powerpc/kernel/head_64.S
index 271140b..3a319f9 100644
--- a/arch/powerpc/kernel/head_64.S
+++ b/arch/powerpc/kernel/head_64.S
@@ -40,7 +40,7 @@
 #include <asm/kvm_book3s_asm.h>
 #include <asm/ptrace.h>
 
-/* The physical memory is layed out such that the secondary processor
+/* The physical memory is laid out such that the secondary processor
  * spin code sits at 0x0000...0x00ff. On server, the vectors follow
  * using the layout described in exceptions-64s.S
  */
diff --git a/arch/powerpc/kernel/head_fsl_booke.S b/arch/powerpc/kernel/head_fsl_booke.S
index 3e02710..5ecf54c 100644
--- a/arch/powerpc/kernel/head_fsl_booke.S
+++ b/arch/powerpc/kernel/head_fsl_booke.S
@@ -326,7 +326,7 @@ interrupt_base:
 	NORMAL_EXCEPTION_PROLOG
 	EXC_XFER_EE_LITE(0x0c00, DoSyscall)
 
-	/* Auxillary Processor Unavailable Interrupt */
+	/* Auxiliary Processor Unavailable Interrupt */
 	EXCEPTION(0x2900, AuxillaryProcessorUnavailable, unknown_exception, EXC_XFER_EE)
 
 	/* Decrementer Interrupt */
diff --git a/arch/powerpc/kernel/l2cr_6xx.S b/arch/powerpc/kernel/l2cr_6xx.S
index 2a2f3c3..97ec855 100644
--- a/arch/powerpc/kernel/l2cr_6xx.S
+++ b/arch/powerpc/kernel/l2cr_6xx.S
@@ -151,7 +151,7 @@ END_FTR_SECTION_IFSET(CPU_FTR_ALTIVEC)
 	 /**** Might be a good idea to set L2DO here - to prevent instructions
 	       from getting into the cache.  But since we invalidate
 	       the next time we enable the cache it doesn't really matter.
-	       Don't do this unless you accomodate all processor variations.
+	       Don't do this unless you accommodate all processor variations.
 	       The bit moved on the 7450.....
 	  ****/
 
diff --git a/arch/powerpc/kernel/lparcfg.c b/arch/powerpc/kernel/lparcfg.c
index 1646836..301db65 100644
--- a/arch/powerpc/kernel/lparcfg.c
+++ b/arch/powerpc/kernel/lparcfg.c
@@ -262,7 +262,7 @@ static void parse_ppp_data(struct seq_file *m)
 	seq_printf(m, "system_active_processors=%d\n",
 	           ppp_data.active_system_procs);
 
-	/* pool related entries are apropriate for shared configs */
+	/* pool related entries are appropriate for shared configs */
 	if (lppaca_of(0).shared_proc) {
 		unsigned long pool_idle_time, pool_procs;
 
diff --git a/arch/powerpc/kernel/perf_event.c b/arch/powerpc/kernel/perf_event.c
index 97e0ae4..c4063b7 100644
--- a/arch/powerpc/kernel/perf_event.c
+++ b/arch/powerpc/kernel/perf_event.c
@@ -759,7 +759,7 @@ static int power_pmu_add(struct perf_event *event, int ef_flags)
 
 	/*
 	 * If group events scheduling transaction was started,
-	 * skip the schedulability test here, it will be peformed
+	 * skip the schedulability test here, it will be performed
 	 * at commit time(->commit_txn) as a whole
 	 */
 	if (cpuhw->group_flag & PERF_EVENT_TXN)
diff --git a/arch/powerpc/kernel/ppc_save_regs.S b/arch/powerpc/kernel/ppc_save_regs.S
index e83ba3f..1b1787d 100644
--- a/arch/powerpc/kernel/ppc_save_regs.S
+++ b/arch/powerpc/kernel/ppc_save_regs.S
@@ -15,7 +15,7 @@
 
 /*
  * Grab the register values as they are now.
- * This won't do a particularily good job because we really
+ * This won't do a particularly good job because we really
  * want our caller's caller's registers, and our caller has
  * already executed its prologue.
  * ToDo: We could reach back into the caller's save area to do
diff --git a/arch/powerpc/kernel/prom.c b/arch/powerpc/kernel/prom.c
index 05b7139..e74fa12 100644
--- a/arch/powerpc/kernel/prom.c
+++ b/arch/powerpc/kernel/prom.c
@@ -683,7 +683,7 @@ void __init early_init_devtree(void *params)
 #endif
 
 #ifdef CONFIG_PHYP_DUMP
-	/* scan tree to see if dump occured during last boot */
+	/* scan tree to see if dump occurred during last boot */
 	of_scan_flat_dt(early_init_dt_scan_phyp_dump, NULL);
 #endif
 
@@ -739,7 +739,7 @@ void __init early_init_devtree(void *params)
 
 	DBG("Scanning CPUs ...\n");
 
-	/* Retreive CPU related informations from the flat tree
+	/* Retrieve CPU related informations from the flat tree
 	 * (altivec support, boot CPU ID, ...)
 	 */
 	of_scan_flat_dt(early_init_dt_scan_cpus, NULL);
diff --git a/arch/powerpc/kernel/ptrace.c b/arch/powerpc/kernel/ptrace.c
index 895b082..55613e3 100644
--- a/arch/powerpc/kernel/ptrace.c
+++ b/arch/powerpc/kernel/ptrace.c
@@ -463,7 +463,7 @@ static int vr_set(struct task_struct *target, const struct user_regset *regset,
 #ifdef CONFIG_VSX
 /*
  * Currently to set and and get all the vsx state, you need to call
- * the fp and VMX calls aswell.  This only get/sets the lower 32
+ * the fp and VMX calls as well.  This only get/sets the lower 32
  * 128bit VSX registers.
  */
 
diff --git a/arch/powerpc/kernel/rtasd.c b/arch/powerpc/kernel/rtasd.c
index 7980ec0..67f6c3b 100644
--- a/arch/powerpc/kernel/rtasd.c
+++ b/arch/powerpc/kernel/rtasd.c
@@ -465,7 +465,7 @@ static void start_event_scan(void)
 	pr_debug("rtasd: will sleep for %d milliseconds\n",
 		 (30000 / rtas_event_scan_rate));
 
-	/* Retreive errors from nvram if any */
+	/* Retrieve errors from nvram if any */
 	retreive_nvram_error_log();
 
 	schedule_delayed_work_on(cpumask_first(cpu_online_mask),
diff --git a/arch/powerpc/kernel/swsusp_32.S b/arch/powerpc/kernel/swsusp_32.S
index b0754e2..ba4dee3 100644
--- a/arch/powerpc/kernel/swsusp_32.S
+++ b/arch/powerpc/kernel/swsusp_32.S
@@ -143,7 +143,7 @@ END_FTR_SECTION_IFSET(CPU_FTR_ALTIVEC)
 
 	/* Disable MSR:DR to make sure we don't take a TLB or
 	 * hash miss during the copy, as our hash table will
-	 * for a while be unuseable. For .text, we assume we are
+	 * for a while be unusable. For .text, we assume we are
 	 * covered by a BAT. This works only for non-G5 at this
 	 * point. G5 will need a better approach, possibly using
 	 * a small temporary hash table filled with large mappings,
diff --git a/arch/powerpc/kernel/traps.c b/arch/powerpc/kernel/traps.c
index bd74fac..5ddb801 100644
--- a/arch/powerpc/kernel/traps.c
+++ b/arch/powerpc/kernel/traps.c
@@ -959,7 +959,7 @@ void __kprobes program_check_exception(struct pt_regs *regs)
 	 * ESR_DST (!?) or 0.  In the process of chasing this with the
 	 * hardware people - not sure if it can happen on any illegal
 	 * instruction or only on FP instructions, whether there is a
-	 * pattern to occurences etc. -dgibson 31/Mar/2003 */
+	 * pattern to occurrences etc. -dgibson 31/Mar/2003 */
 	switch (do_mathemu(regs)) {
 	case 0:
 		emulate_single_step(regs);
diff --git a/arch/powerpc/kernel/udbg_16550.c b/arch/powerpc/kernel/udbg_16550.c
index b4b167b..baa33a7 100644
--- a/arch/powerpc/kernel/udbg_16550.c
+++ b/arch/powerpc/kernel/udbg_16550.c
@@ -1,5 +1,5 @@
 /*
- * udbg for NS16550 compatable serial ports
+ * udbg for NS16550 compatible serial ports
  *
  * Copyright (C) 2001-2005 PPC 64 Team, IBM Corp
  *
diff --git a/arch/powerpc/kernel/vdso32/sigtramp.S b/arch/powerpc/kernel/vdso32/sigtramp.S
index 68d49dd..cf0c9c9 100644
--- a/arch/powerpc/kernel/vdso32/sigtramp.S
+++ b/arch/powerpc/kernel/vdso32/sigtramp.S
@@ -19,7 +19,7 @@
 
 /* The nop here is a hack.  The dwarf2 unwind routines subtract 1 from
    the return address to get an address in the middle of the presumed
-   call instruction.  Since we don't have a call here, we artifically
+   call instruction.  Since we don't have a call here, we artificially
    extend the range covered by the unwind info by adding a nop before
    the real start.  */
 	nop
diff --git a/arch/powerpc/kernel/vdso64/sigtramp.S b/arch/powerpc/kernel/vdso64/sigtramp.S
index 59eb59b..45ea281 100644
--- a/arch/powerpc/kernel/vdso64/sigtramp.S
+++ b/arch/powerpc/kernel/vdso64/sigtramp.S
@@ -20,7 +20,7 @@
 
 /* The nop here is a hack.  The dwarf2 unwind routines subtract 1 from
    the return address to get an address in the middle of the presumed
-   call instruction.  Since we don't have a call here, we artifically
+   call instruction.  Since we don't have a call here, we artificially
    extend the range covered by the unwind info by padding before the
    real start.  */
 	nop
diff --git a/arch/powerpc/mm/hash_low_64.S b/arch/powerpc/mm/hash_low_64.S
index 3079f6b..5b7dd4e 100644
--- a/arch/powerpc/mm/hash_low_64.S
+++ b/arch/powerpc/mm/hash_low_64.S
@@ -192,8 +192,8 @@ htab_insert_pte:
 	rldicr	r3,r0,3,63-3		/* r3 = (hash & mask) << 3 */
 
 	/* Call ppc_md.hpte_insert */
-	ld	r6,STK_PARM(r4)(r1)	/* Retreive new pp bits */
-	mr	r4,r29			/* Retreive va */
+	ld	r6,STK_PARM(r4)(r1)	/* Retrieve new pp bits */
+	mr	r4,r29			/* Retrieve va */
 	li	r7,0			/* !bolted, !secondary */
 	li	r8,MMU_PAGE_4K		/* page size */
 	ld	r9,STK_PARM(r9)(r1)	/* segment size */
@@ -215,8 +215,8 @@ _GLOBAL(htab_call_hpte_insert1)
 	rldicr	r3,r0,3,63-3	/* r0 = (~hash & mask) << 3 */
 	
 	/* Call ppc_md.hpte_insert */
-	ld	r6,STK_PARM(r4)(r1)	/* Retreive new pp bits */
-	mr	r4,r29			/* Retreive va */
+	ld	r6,STK_PARM(r4)(r1)	/* Retrieve new pp bits */
+	mr	r4,r29			/* Retrieve va */
 	li	r7,HPTE_V_SECONDARY	/* !bolted, secondary */
 	li	r8,MMU_PAGE_4K		/* page size */
 	ld	r9,STK_PARM(r9)(r1)	/* segment size */
@@ -495,8 +495,8 @@ htab_special_pfn:
 	rldicr	r3,r0,3,63-3		/* r0 = (hash & mask) << 3 */
 
 	/* Call ppc_md.hpte_insert */
-	ld	r6,STK_PARM(r4)(r1)	/* Retreive new pp bits */
-	mr	r4,r29			/* Retreive va */
+	ld	r6,STK_PARM(r4)(r1)	/* Retrieve new pp bits */
+	mr	r4,r29			/* Retrieve va */
 	li	r7,0			/* !bolted, !secondary */
 	li	r8,MMU_PAGE_4K		/* page size */
 	ld	r9,STK_PARM(r9)(r1)	/* segment size */
@@ -522,8 +522,8 @@ _GLOBAL(htab_call_hpte_insert1)
 	rldicr	r3,r0,3,63-3		/* r0 = (~hash & mask) << 3 */
 
 	/* Call ppc_md.hpte_insert */
-	ld	r6,STK_PARM(r4)(r1)	/* Retreive new pp bits */
-	mr	r4,r29			/* Retreive va */
+	ld	r6,STK_PARM(r4)(r1)	/* Retrieve new pp bits */
+	mr	r4,r29			/* Retrieve va */
 	li	r7,HPTE_V_SECONDARY	/* !bolted, secondary */
 	li	r8,MMU_PAGE_4K		/* page size */
 	ld	r9,STK_PARM(r9)(r1)	/* segment size */
@@ -813,8 +813,8 @@ ht64_insert_pte:
 	rldicr	r3,r0,3,63-3	/* r0 = (hash & mask) << 3 */
 
 	/* Call ppc_md.hpte_insert */
-	ld	r6,STK_PARM(r4)(r1)	/* Retreive new pp bits */
-	mr	r4,r29			/* Retreive va */
+	ld	r6,STK_PARM(r4)(r1)	/* Retrieve new pp bits */
+	mr	r4,r29			/* Retrieve va */
 	li	r7,0			/* !bolted, !secondary */
 	li	r8,MMU_PAGE_64K
 	ld	r9,STK_PARM(r9)(r1)	/* segment size */
@@ -836,8 +836,8 @@ _GLOBAL(ht64_call_hpte_insert1)
 	rldicr	r3,r0,3,63-3	/* r0 = (~hash & mask) << 3 */
 
 	/* Call ppc_md.hpte_insert */
-	ld	r6,STK_PARM(r4)(r1)	/* Retreive new pp bits */
-	mr	r4,r29			/* Retreive va */
+	ld	r6,STK_PARM(r4)(r1)	/* Retrieve new pp bits */
+	mr	r4,r29			/* Retrieve va */
 	li	r7,HPTE_V_SECONDARY	/* !bolted, secondary */
 	li	r8,MMU_PAGE_64K
 	ld	r9,STK_PARM(r9)(r1)	/* segment size */
diff --git a/arch/powerpc/mm/hash_utils_64.c b/arch/powerpc/mm/hash_utils_64.c
index a5991fa..58a022d 100644
--- a/arch/powerpc/mm/hash_utils_64.c
+++ b/arch/powerpc/mm/hash_utils_64.c
@@ -753,7 +753,7 @@ void __cpuinit early_init_mmu_secondary(void)
 		mtspr(SPRN_SDR1, _SDR1);
 
 	/* Initialize STAB/SLB. We use a virtual address as it works
-	 * in real mode on pSeries and we want a virutal address on
+	 * in real mode on pSeries and we want a virtual address on
 	 * iSeries anyway
 	 */
 	if (cpu_has_feature(CPU_FTR_SLB))
diff --git a/arch/powerpc/mm/mem.c b/arch/powerpc/mm/mem.c
index a664996..57e545b 100644
--- a/arch/powerpc/mm/mem.c
+++ b/arch/powerpc/mm/mem.c
@@ -424,7 +424,7 @@ void clear_user_page(void *page, unsigned long vaddr, struct page *pg)
 	clear_page(page);
 
 	/*
-	 * We shouldnt have to do this, but some versions of glibc
+	 * We shouldn't have to do this, but some versions of glibc
 	 * require it (ld.so assumes zero filled pages are icache clean)
 	 * - Anton
 	 */
diff --git a/arch/powerpc/mm/numa.c b/arch/powerpc/mm/numa.c
index 0dc95c0..5ec1dad 100644
--- a/arch/powerpc/mm/numa.c
+++ b/arch/powerpc/mm/numa.c
@@ -440,11 +440,11 @@ static void read_drconf_cell(struct of_drconf_cell *drmem, const u32 **cellp)
 }
 
 /*
- * Retreive and validate the ibm,dynamic-memory property of the device tree.
+ * Retrieve and validate the ibm,dynamic-memory property of the device tree.
  *
  * The layout of the ibm,dynamic-memory property is a number N of memblock
  * list entries followed by N memblock list entries.  Each memblock list entry
- * contains information as layed out in the of_drconf_cell struct above.
+ * contains information as laid out in the of_drconf_cell struct above.
  */
 static int of_get_drconf_memory(struct device_node *memory, const u32 **dm)
 {
@@ -468,7 +468,7 @@ static int of_get_drconf_memory(struct device_node *memory, const u32 **dm)
 }
 
 /*
- * Retreive and validate the ibm,lmb-size property for drconf memory
+ * Retrieve and validate the ibm,lmb-size property for drconf memory
  * from the device tree.
  */
 static u64 of_get_lmb_size(struct device_node *memory)
@@ -490,7 +490,7 @@ struct assoc_arrays {
 };
 
 /*
- * Retreive and validate the list of associativity arrays for drconf
+ * Retrieve and validate the list of associativity arrays for drconf
  * memory from the ibm,associativity-lookup-arrays property of the
  * device tree..
  *
@@ -604,7 +604,7 @@ static int __cpuinit cpu_numa_callback(struct notifier_block *nfb,
  * Returns the size the region should have to enforce the memory limit.
  * This will either be the original value of size, a truncated value,
  * or zero. If the returned value of size is 0 the region should be
- * discarded as it lies wholy above the memory limit.
+ * discarded as it lies wholly above the memory limit.
  */
 static unsigned long __init numa_enforce_memory_limit(unsigned long start,
 						      unsigned long size)
diff --git a/arch/powerpc/mm/tlb_low_64e.S b/arch/powerpc/mm/tlb_low_64e.S
index 2228151..af08922 100644
--- a/arch/powerpc/mm/tlb_low_64e.S
+++ b/arch/powerpc/mm/tlb_low_64e.S
@@ -192,7 +192,7 @@ normal_tlb_miss:
 	or	r10,r15,r14
 
 BEGIN_MMU_FTR_SECTION
-	/* Set the TLB reservation and seach for existing entry. Then load
+	/* Set the TLB reservation and search for existing entry. Then load
 	 * the entry.
 	 */
 	PPC_TLBSRX_DOT(0,r16)
@@ -425,7 +425,7 @@ END_MMU_FTR_SECTION_IFSET(MMU_FTR_USE_TLBRSRV)
 
 virt_page_table_tlb_miss_fault:
 	/* If we fault here, things are a little bit tricky. We need to call
-	 * either data or instruction store fault, and we need to retreive
+	 * either data or instruction store fault, and we need to retrieve
 	 * the original fault address and ESR (for data).
 	 *
 	 * The thing is, we know that in normal circumstances, this is
diff --git a/arch/powerpc/oprofile/op_model_cell.c b/arch/powerpc/oprofile/op_model_cell.c
index c4d2b71..cb515cf 100644
--- a/arch/powerpc/oprofile/op_model_cell.c
+++ b/arch/powerpc/oprofile/op_model_cell.c
@@ -67,7 +67,7 @@
 
 #define MAX_SPU_COUNT 0xFFFFFF	/* maximum 24 bit LFSR value */
 
-/* Minumum HW interval timer setting to send value to trace buffer is 10 cycle.
+/* Minimum HW interval timer setting to send value to trace buffer is 10 cycle.
  * To configure counter to send value every N cycles set counter to
  * 2^32 - 1 - N.
  */
@@ -1470,7 +1470,7 @@ static int cell_global_start(struct op_counter_config *ctr)
  * trace buffer at the maximum rate possible.  The trace buffer is configured
  * to store the PCs, wrapping when it is full.  The performance counter is
  * initialized to the max hardware count minus the number of events, N, between
- * samples.  Once the N events have occured, a HW counter overflow occurs
+ * samples.  Once the N events have occurred, a HW counter overflow occurs
  * causing the generation of a HW counter interrupt which also stops the
  * writing of the SPU PC values to the trace buffer.  Hence the last PC
  * written to the trace buffer is the SPU PC that we want.  Unfortunately,
@@ -1656,7 +1656,7 @@ static void cell_handle_interrupt_ppu(struct pt_regs *regs,
 		 * The counters were frozen by the interrupt.
 		 * Reenable the interrupt and restart the counters.
 		 * If there was a race between the interrupt handler and
-		 * the virtual counter routine.	 The virutal counter
+		 * the virtual counter routine.	 The virtual counter
 		 * routine may have cleared the interrupts.  Hence must
 		 * use the virt_cntr_inter_mask to re-enable the interrupts.
 		 */
diff --git a/arch/powerpc/oprofile/op_model_power4.c b/arch/powerpc/oprofile/op_model_power4.c
index 8077409..8ee51a2 100644
--- a/arch/powerpc/oprofile/op_model_power4.c
+++ b/arch/powerpc/oprofile/op_model_power4.c
@@ -207,7 +207,7 @@ static unsigned long get_pc(struct pt_regs *regs)
 	unsigned long mmcra;
 	unsigned long slot;
 
-	/* Cant do much about it */
+	/* Can't do much about it */
 	if (!cur_cpu_spec->oprofile_mmcra_sihv)
 		return pc;
 
diff --git a/arch/powerpc/platforms/52xx/mpc52xx_lpbfifo.c b/arch/powerpc/platforms/52xx/mpc52xx_lpbfifo.c
index 6385d88..9940ce8 100644
--- a/arch/powerpc/platforms/52xx/mpc52xx_lpbfifo.c
+++ b/arch/powerpc/platforms/52xx/mpc52xx_lpbfifo.c
@@ -57,7 +57,7 @@ struct mpc52xx_lpbfifo {
 static struct mpc52xx_lpbfifo lpbfifo;
 
 /**
- * mpc52xx_lpbfifo_kick - Trigger the next block of data to be transfered
+ * mpc52xx_lpbfifo_kick - Trigger the next block of data to be transferred
  */
 static void mpc52xx_lpbfifo_kick(struct mpc52xx_lpbfifo_request *req)
 {
@@ -179,7 +179,7 @@ static void mpc52xx_lpbfifo_kick(struct mpc52xx_lpbfifo_request *req)
  *
  * On transmit, the dma completion irq triggers before the fifo completion
  * triggers.  Handle the dma completion here instead of the LPB FIFO Bestcomm
- * task completion irq becuase everyting is not really done until the LPB FIFO
+ * task completion irq because everything is not really done until the LPB FIFO
  * completion irq triggers.
  *
  * In other words:
@@ -195,7 +195,7 @@ static void mpc52xx_lpbfifo_kick(struct mpc52xx_lpbfifo_request *req)
  * Exit conditions:
  * 1) Transfer aborted
  * 2) FIFO complete without DMA; more data to do
- * 3) FIFO complete without DMA; all data transfered
+ * 3) FIFO complete without DMA; all data transferred
  * 4) FIFO complete using DMA
  *
  * Condition 1 can occur regardless of whether or not DMA is used.
diff --git a/arch/powerpc/platforms/52xx/mpc52xx_pic.c b/arch/powerpc/platforms/52xx/mpc52xx_pic.c
index 3ddea96..1dd1540 100644
--- a/arch/powerpc/platforms/52xx/mpc52xx_pic.c
+++ b/arch/powerpc/platforms/52xx/mpc52xx_pic.c
@@ -512,7 +512,7 @@ void __init mpc52xx_init_irq(void)
 /**
  * mpc52xx_get_irq - Get pending interrupt number hook function
  *
- * Called by the interupt handler to determine what IRQ handler needs to be
+ * Called by the interrupt handler to determine what IRQ handler needs to be
  * executed.
  *
  * Status of pending interrupts is determined by reading the encoded status
diff --git a/arch/powerpc/platforms/cell/spufs/lscsa_alloc.c b/arch/powerpc/platforms/cell/spufs/lscsa_alloc.c
index 3b894f5..1470699 100644
--- a/arch/powerpc/platforms/cell/spufs/lscsa_alloc.c
+++ b/arch/powerpc/platforms/cell/spufs/lscsa_alloc.c
@@ -90,7 +90,7 @@ int spu_alloc_lscsa(struct spu_state *csa)
 	 */
 	for (i = 0; i < SPU_LSCSA_NUM_BIG_PAGES; i++) {
 		/* XXX This is likely to fail, we should use a special pool
-		 *     similiar to what hugetlbfs does.
+		 *     similar to what hugetlbfs does.
 		 */
 		csa->lscsa_pages[i] = alloc_pages(GFP_KERNEL,
 						  SPU_64K_PAGE_ORDER);
diff --git a/arch/powerpc/platforms/cell/spufs/sched.c b/arch/powerpc/platforms/cell/spufs/sched.c
index 0b04662..6520385 100644
--- a/arch/powerpc/platforms/cell/spufs/sched.c
+++ b/arch/powerpc/platforms/cell/spufs/sched.c
@@ -846,7 +846,7 @@ static struct spu_context *grab_runnable_context(int prio, int node)
 		struct list_head *rq = &spu_prio->runq[best];
 
 		list_for_each_entry(ctx, rq, rq) {
-			/* XXX(hch): check for affinity here aswell */
+			/* XXX(hch): check for affinity here as well */
 			if (__node_allowed(ctx, node)) {
 				__spu_del_from_rq(ctx);
 				goto found;
diff --git a/arch/powerpc/platforms/cell/spufs/spu_restore.c b/arch/powerpc/platforms/cell/spufs/spu_restore.c
index 21a9c95..72c905f 100644
--- a/arch/powerpc/platforms/cell/spufs/spu_restore.c
+++ b/arch/powerpc/platforms/cell/spufs/spu_restore.c
@@ -284,7 +284,7 @@ static inline void restore_complete(void)
 		exit_instrs[3] = BR_INSTR;
 		break;
 	default:
-		/* SPU_Status[R]=1. No additonal instructions. */
+		/* SPU_Status[R]=1. No additional instructions. */
 		break;
 	}
 	spu_sync();
diff --git a/arch/powerpc/platforms/iseries/mf.c b/arch/powerpc/platforms/iseries/mf.c
index b5e026b..62dabe3 100644
--- a/arch/powerpc/platforms/iseries/mf.c
+++ b/arch/powerpc/platforms/iseries/mf.c
@@ -51,7 +51,7 @@
 static int mf_initialized;
 
 /*
- * This is the structure layout for the Machine Facilites LPAR event
+ * This is the structure layout for the Machine Facilities LPAR event
  * flows.
  */
 struct vsp_cmd_data {
diff --git a/arch/powerpc/platforms/iseries/viopath.c b/arch/powerpc/platforms/iseries/viopath.c
index b5f05d9..2376069 100644
--- a/arch/powerpc/platforms/iseries/viopath.c
+++ b/arch/powerpc/platforms/iseries/viopath.c
@@ -396,7 +396,7 @@ static void vio_handleEvent(struct HvLpEvent *event)
 			viopathStatus[remoteLp].mTargetInst)) {
 			printk(VIOPATH_KERN_WARN
 			       "message from invalid partition. "
-			       "int msg rcvd, source inst (%d) doesnt match (%d)\n",
+			       "int msg rcvd, source inst (%d) doesn't match (%d)\n",
 			       viopathStatus[remoteLp].mTargetInst,
 			       event->xSourceInstanceId);
 			return;
@@ -407,7 +407,7 @@ static void vio_handleEvent(struct HvLpEvent *event)
 			viopathStatus[remoteLp].mSourceInst)) {
 			printk(VIOPATH_KERN_WARN
 			       "message from invalid partition. "
-			       "int msg rcvd, target inst (%d) doesnt match (%d)\n",
+			       "int msg rcvd, target inst (%d) doesn't match (%d)\n",
 			       viopathStatus[remoteLp].mSourceInst,
 			       event->xTargetInstanceId);
 			return;
@@ -418,7 +418,7 @@ static void vio_handleEvent(struct HvLpEvent *event)
 		    viopathStatus[remoteLp].mSourceInst) {
 			printk(VIOPATH_KERN_WARN
 			       "message from invalid partition. "
-			       "ack msg rcvd, source inst (%d) doesnt match (%d)\n",
+			       "ack msg rcvd, source inst (%d) doesn't match (%d)\n",
 			       viopathStatus[remoteLp].mSourceInst,
 			       event->xSourceInstanceId);
 			return;
@@ -428,7 +428,7 @@ static void vio_handleEvent(struct HvLpEvent *event)
 		    viopathStatus[remoteLp].mTargetInst) {
 			printk(VIOPATH_KERN_WARN
 			       "message from invalid partition. "
-			       "viopath: ack msg rcvd, target inst (%d) doesnt match (%d)\n",
+			       "viopath: ack msg rcvd, target inst (%d) doesn't match (%d)\n",
 			       viopathStatus[remoteLp].mTargetInst,
 			       event->xTargetInstanceId);
 			return;
diff --git a/arch/powerpc/platforms/pasemi/dma_lib.c b/arch/powerpc/platforms/pasemi/dma_lib.c
index 09695ae..321a9b3 100644
--- a/arch/powerpc/platforms/pasemi/dma_lib.c
+++ b/arch/powerpc/platforms/pasemi/dma_lib.c
@@ -379,9 +379,9 @@ void pasemi_dma_free_buf(struct pasemi_dmachan *chan, int size,
 }
 EXPORT_SYMBOL(pasemi_dma_free_buf);
 
-/* pasemi_dma_alloc_flag - Allocate a flag (event) for channel syncronization
+/* pasemi_dma_alloc_flag - Allocate a flag (event) for channel synchronization
  *
- * Allocates a flag for use with channel syncronization (event descriptors).
+ * Allocates a flag for use with channel synchronization (event descriptors).
  * Returns allocated flag (0-63), < 0 on error.
  */
 int pasemi_dma_alloc_flag(void)
diff --git a/arch/powerpc/platforms/powermac/Makefile b/arch/powerpc/platforms/powermac/Makefile
index 50f1693..ea47df6 100644
--- a/arch/powerpc/platforms/powermac/Makefile
+++ b/arch/powerpc/platforms/powermac/Makefile
@@ -11,7 +11,7 @@ obj-y				+= pic.o setup.o time.o feature.o pci.o \
 obj-$(CONFIG_PMAC_BACKLIGHT)	+= backlight.o
 obj-$(CONFIG_CPU_FREQ_PMAC)	+= cpufreq_32.o
 obj-$(CONFIG_CPU_FREQ_PMAC64)	+= cpufreq_64.o
-# CONFIG_NVRAM is an arch. independant tristate symbol, for pmac32 we really
+# CONFIG_NVRAM is an arch. independent tristate symbol, for pmac32 we really
 # need this to be a bool.  Cheat here and pretend CONFIG_NVRAM=m is really
 # CONFIG_NVRAM=y
 obj-$(CONFIG_NVRAM:m=y)		+= nvram.o
diff --git a/arch/powerpc/platforms/powermac/low_i2c.c b/arch/powerpc/platforms/powermac/low_i2c.c
index 480567e..e9c8a60 100644
--- a/arch/powerpc/platforms/powermac/low_i2c.c
+++ b/arch/powerpc/platforms/powermac/low_i2c.c
@@ -904,7 +904,7 @@ static void __init smu_i2c_probe(void)
 	printk(KERN_INFO "SMU i2c %s\n", controller->full_name);
 
 	/* Look for childs, note that they might not be of the right
-	 * type as older device trees mix i2c busses and other thigns
+	 * type as older device trees mix i2c busses and other things
 	 * at the same level
 	 */
 	for (busnode = NULL;
diff --git a/arch/powerpc/platforms/powermac/pci.c b/arch/powerpc/platforms/powermac/pci.c
index ab68989..f33e08d 100644
--- a/arch/powerpc/platforms/powermac/pci.c
+++ b/arch/powerpc/platforms/powermac/pci.c
@@ -299,7 +299,7 @@ static void __init setup_chaos(struct pci_controller *hose,
  * This function deals with some "special cases" devices.
  *
  *  0 -> No special case
- *  1 -> Skip the device but act as if the access was successfull
+ *  1 -> Skip the device but act as if the access was successful
  *       (return 0xff's on reads, eventually, cache config space
  *       accesses in a later version)
  * -1 -> Hide the device (unsuccessful access)
diff --git a/arch/powerpc/platforms/pseries/dlpar.c b/arch/powerpc/platforms/pseries/dlpar.c
index b74a923..57ceb92 100644
--- a/arch/powerpc/platforms/pseries/dlpar.c
+++ b/arch/powerpc/platforms/pseries/dlpar.c
@@ -74,7 +74,7 @@ static struct device_node *dlpar_parse_cc_node(struct cc_workarea *ccwa)
 		return NULL;
 
 	/* The configure connector reported name does not contain a
-	 * preceeding '/', so we allocate a buffer large enough to
+	 * preceding '/', so we allocate a buffer large enough to
 	 * prepend this to the full_name.
 	 */
 	name = (char *)ccwa + ccwa->name_offset;
diff --git a/arch/powerpc/platforms/pseries/eeh.c b/arch/powerpc/platforms/pseries/eeh.c
index 3cc4d10..8964917 100644
--- a/arch/powerpc/platforms/pseries/eeh.c
+++ b/arch/powerpc/platforms/pseries/eeh.c
@@ -65,7 +65,7 @@
  *  with EEH.
  *
  *  Ideally, a PCI device driver, when suspecting that an isolation
- *  event has occured (e.g. by reading 0xff's), will then ask EEH
+ *  event has occurred (e.g. by reading 0xff's), will then ask EEH
  *  whether this is the case, and then take appropriate steps to
  *  reset the PCI slot, the PCI device, and then resume operations.
  *  However, until that day,  the checking is done here, with the
diff --git a/arch/powerpc/platforms/pseries/hotplug-cpu.c b/arch/powerpc/platforms/pseries/hotplug-cpu.c
index fd50ccd..ef8c454 100644
--- a/arch/powerpc/platforms/pseries/hotplug-cpu.c
+++ b/arch/powerpc/platforms/pseries/hotplug-cpu.c
@@ -216,7 +216,7 @@ static void pseries_cpu_die(unsigned int cpu)
 		       cpu, pcpu, cpu_status);
 	}
 
-	/* Isolation and deallocation are definatly done by
+	/* Isolation and deallocation are definitely done by
 	 * drslot_chrp_cpu.  If they were not they would be
 	 * done here.  Change isolate state to Isolate and
 	 * change allocation-state to Unusable.
diff --git a/arch/powerpc/platforms/pseries/iommu.c b/arch/powerpc/platforms/pseries/iommu.c
index 154c464..6d5412a 100644
--- a/arch/powerpc/platforms/pseries/iommu.c
+++ b/arch/powerpc/platforms/pseries/iommu.c
@@ -272,7 +272,7 @@ static unsigned long tce_get_pSeriesLP(struct iommu_table *tbl, long tcenum)
 	return tce_ret;
 }
 
-/* this is compatable with cells for the device tree property */
+/* this is compatible with cells for the device tree property */
 struct dynamic_dma_window_prop {
 	__be32	liobn;		/* tce table number */
 	__be64	dma_base;	/* address hi,lo */
@@ -976,7 +976,7 @@ static void pci_dma_dev_setup_pSeriesLP(struct pci_dev *dev)
 	pr_debug("pci_dma_dev_setup_pSeriesLP: %s\n", pci_name(dev));
 
 	/* dev setup for LPAR is a little tricky, since the device tree might
-	 * contain the dma-window properties per-device and not neccesarily
+	 * contain the dma-window properties per-device and not necessarily
 	 * for the bus. So we need to search upwards in the tree until we
 	 * either hit a dma-window property, OR find a parent with a table
 	 * already allocated.
@@ -1033,7 +1033,7 @@ static int dma_set_mask_pSeriesLP(struct device *dev, u64 dma_mask)
 
 		/*
 		 * the device tree might contain the dma-window properties
-		 * per-device and not neccesarily for the bus. So we need to
+		 * per-device and not necessarily for the bus. So we need to
 		 * search upwards in the tree until we either hit a dma-window
 		 * property, OR find a parent with a table already allocated.
 		 */
diff --git a/arch/powerpc/platforms/pseries/xics.c b/arch/powerpc/platforms/pseries/xics.c
index ec8fe22..d690133 100644
--- a/arch/powerpc/platforms/pseries/xics.c
+++ b/arch/powerpc/platforms/pseries/xics.c
@@ -897,7 +897,7 @@ void xics_migrate_irqs_away(void)
 		int status;
 		unsigned long flags;
 
-		/* We cant set affinity on ISA interrupts */
+		/* We can't set affinity on ISA interrupts */
 		if (virq < NUM_ISA_INTERRUPTS)
 			continue;
 		if (irq_map[virq].host != xics_host)
diff --git a/arch/powerpc/sysdev/axonram.c b/arch/powerpc/sysdev/axonram.c
index 27402c7d..1636dd8 100644
--- a/arch/powerpc/sysdev/axonram.c
+++ b/arch/powerpc/sysdev/axonram.c
@@ -95,7 +95,7 @@ axon_ram_irq_handler(int irq, void *dev)
 
 	BUG_ON(!bank);
 
-	dev_err(&device->dev, "Correctable memory error occured\n");
+	dev_err(&device->dev, "Correctable memory error occurred\n");
 	bank->ecc_counter++;
 	return IRQ_HANDLED;
 }
diff --git a/arch/powerpc/sysdev/bestcomm/bestcomm.h b/arch/powerpc/sysdev/bestcomm/bestcomm.h
index 23a95f8..a0e2e6b 100644
--- a/arch/powerpc/sysdev/bestcomm/bestcomm.h
+++ b/arch/powerpc/sysdev/bestcomm/bestcomm.h
@@ -20,7 +20,7 @@
  * struct bcom_bd - Structure describing a generic BestComm buffer descriptor
  * @status: The current status of this buffer. Exact meaning depends on the
  *          task type
- * @data: An array of u32 extra data.  Size of array is task dependant.
+ * @data: An array of u32 extra data.  Size of array is task dependent.
  *
  * Note: Don't dereference a bcom_bd pointer as an array.  The size of the
  *       bcom_bd is variable.  Use bcom_get_bd() instead.
diff --git a/arch/powerpc/sysdev/bestcomm/bestcomm_priv.h b/arch/powerpc/sysdev/bestcomm/bestcomm_priv.h
index eb0d1c8..3b52f3f 100644
--- a/arch/powerpc/sysdev/bestcomm/bestcomm_priv.h
+++ b/arch/powerpc/sysdev/bestcomm/bestcomm_priv.h
@@ -97,7 +97,7 @@ struct bcom_task_header {
 	u8	reserved[8];
 };
 
-/* Descriptors stucture & co */
+/* Descriptors structure & co */
 #define BCOM_DESC_NOP		0x000001f8
 #define BCOM_LCD_MASK		0x80000000
 #define BCOM_DRD_EXTENDED	0x40000000
diff --git a/arch/powerpc/sysdev/cpm1.c b/arch/powerpc/sysdev/cpm1.c
index 8b5aba2..e0bc944 100644
--- a/arch/powerpc/sysdev/cpm1.c
+++ b/arch/powerpc/sysdev/cpm1.c
@@ -223,7 +223,7 @@ void __init cpm_reset(void)
 
 	/* Set SDMA Bus Request priority 5.
 	 * On 860T, this also enables FEC priority 6.  I am not sure
-	 * this is what we realy want for some applications, but the
+	 * this is what we really want for some applications, but the
 	 * manual recommends it.
 	 * Bit 25, FAM can also be set to use FEC aggressive mode (860T).
 	 */
diff --git a/arch/powerpc/sysdev/indirect_pci.c b/arch/powerpc/sysdev/indirect_pci.c
index 7ed8096..82fdad8 100644
--- a/arch/powerpc/sysdev/indirect_pci.c
+++ b/arch/powerpc/sysdev/indirect_pci.c
@@ -117,7 +117,7 @@ indirect_write_config(struct pci_bus *bus, unsigned int devfn, int offset,
 		out_le32(hose->cfg_addr, (0x80000000 | (bus_no << 16) |
 			 (devfn << 8) | reg | cfg_type));
 
-	/* surpress setting of PCI_PRIMARY_BUS */
+	/* suppress setting of PCI_PRIMARY_BUS */
 	if (hose->indirect_type & PPC_INDIRECT_TYPE_SURPRESS_PRIMARY_BUS)
 		if ((offset == PCI_PRIMARY_BUS) &&
 			(bus->number == hose->first_busno))
diff --git a/arch/powerpc/sysdev/ppc4xx_pci.h b/arch/powerpc/sysdev/ppc4xx_pci.h
index 56d9e5d..c39a134 100644
--- a/arch/powerpc/sysdev/ppc4xx_pci.h
+++ b/arch/powerpc/sysdev/ppc4xx_pci.h
@@ -324,7 +324,7 @@
 #define PESDR0_460EX_IHS2		0x036D
 
 /*
- * 460SX addtional DCRs
+ * 460SX additional DCRs
  */
 #define PESDRn_460SX_RCEI		0x02
 
diff --git a/arch/s390/include/asm/atomic.h b/arch/s390/include/asm/atomic.h
index 5c5ba10..d9db138 100644
--- a/arch/s390/include/asm/atomic.h
+++ b/arch/s390/include/asm/atomic.h
@@ -9,7 +9,7 @@
  *
  * Atomic operations that C can't guarantee us.
  * Useful for resource counting etc.
- * s390 uses 'Compare And Swap' for atomicity in SMP enviroment.
+ * s390 uses 'Compare And Swap' for atomicity in SMP environment.
  *
  */
 
diff --git a/arch/s390/include/asm/cio.h b/arch/s390/include/asm/cio.h
index e34347d..fc50a33 100644
--- a/arch/s390/include/asm/cio.h
+++ b/arch/s390/include/asm/cio.h
@@ -183,7 +183,7 @@ struct esw3 {
  * The irb that is handed to the device driver when an interrupt occurs. For
  * solicited interrupts, the common I/O layer already performs checks whether
  * a field is valid; a field not being valid is always passed as %0.
- * If a unit check occured, @ecw may contain sense data; this is retrieved
+ * If a unit check occurred, @ecw may contain sense data; this is retrieved
  * by the common I/O layer itself if the device doesn't support concurrent
  * sense (so that the device driver never needs to perform basic sene itself).
  * For unsolicited interrupts, the irb is passed as-is (expect for sense data,
diff --git a/arch/s390/kernel/head.S b/arch/s390/kernel/head.S
index 7061398..fb317bf 100644
--- a/arch/s390/kernel/head.S
+++ b/arch/s390/kernel/head.S
@@ -460,7 +460,7 @@ startup:
 #ifndef CONFIG_MARCH_G5
 	# check capabilities against MARCH_{G5,Z900,Z990,Z9_109,Z10}
 	xc	__LC_STFL_FAC_LIST(8),__LC_STFL_FAC_LIST
-	stfl	__LC_STFL_FAC_LIST	# store facility list
+	.insn	s,0xb2b10000,__LC_STFL_FAC_LIST	# store facility list
 	tm	__LC_STFL_FAC_LIST,0x01	# stfle available ?
 	jz	0f
 	la	%r0,0
diff --git a/arch/s390/kernel/reipl64.S b/arch/s390/kernel/reipl64.S
index 5e73dee..9eabbc9 100644
--- a/arch/s390/kernel/reipl64.S
+++ b/arch/s390/kernel/reipl64.S
@@ -78,7 +78,7 @@ do_reipl_asm:	basr	%r13,0
  * in the ESA psw.
  * Bit 31 of the addresses has to be 0 for the
  * 31bit lpswe instruction a fact they appear to have
- * ommited from the pop.
+ * omitted from the pop.
  */
 .Lnewpsw:	.quad	0x0000000080000000
 		.quad	.Lpg1
diff --git a/arch/s390/kernel/setup.c b/arch/s390/kernel/setup.c
index ed183c2..f5434d1 100644
--- a/arch/s390/kernel/setup.c
+++ b/arch/s390/kernel/setup.c
@@ -708,7 +708,7 @@ static void __init setup_hwcaps(void)
 	 * and 1ULL<<0 as bit 63. Bits 0-31 contain the same information
 	 * as stored by stfl, bits 32-xxx contain additional facilities.
 	 * How many facility words are stored depends on the number of
-	 * doublewords passed to the instruction. The additional facilites
+	 * doublewords passed to the instruction. The additional facilities
 	 * are:
 	 *   Bit 42: decimal floating point facility is installed
 	 *   Bit 44: perform floating point operation facility is installed
diff --git a/arch/s390/kernel/switch_cpu.S b/arch/s390/kernel/switch_cpu.S
index 469f11b..20530dd 100644
--- a/arch/s390/kernel/switch_cpu.S
+++ b/arch/s390/kernel/switch_cpu.S
@@ -46,7 +46,9 @@ smp_restart_cpu:
 	ltr	%r4,%r4			/* New stack ? */
 	jz	1f
 	lr	%r15,%r4
-1:	basr	%r14,%r2
+1:	lr	%r14,%r2		/* r14: Function to call */
+	lr	%r2,%r3			/* r2 : Parameter for function*/
+	basr	%r14,%r14		/* Call function */
 
 .gprregs_addr:
 	.long	.gprregs
diff --git a/arch/s390/kernel/switch_cpu64.S b/arch/s390/kernel/switch_cpu64.S
index d94aacc..5be3f43 100644
--- a/arch/s390/kernel/switch_cpu64.S
+++ b/arch/s390/kernel/switch_cpu64.S
@@ -42,7 +42,9 @@ smp_restart_cpu:
 	ltgr	%r4,%r4			/* New stack ? */
 	jz	1f
 	lgr	%r15,%r4
-1:	basr	%r14,%r2
+1:	lgr	%r14,%r2		/* r14: Function to call */
+	lgr	%r2,%r3			/* r2 : Parameter for function*/
+	basr	%r14,%r14		/* Call function */
 
 	.section .data,"aw",@progbits
 .gprregs:
diff --git a/arch/s390/kernel/time.c b/arch/s390/kernel/time.c
index 9e7b039..87be655 100644
--- a/arch/s390/kernel/time.c
+++ b/arch/s390/kernel/time.c
@@ -724,7 +724,7 @@ static void clock_sync_cpu(struct clock_sync_data *sync)
 }
 
 /*
- * Sync the TOD clock using the port refered to by aibp. This port
+ * Sync the TOD clock using the port referred to by aibp. This port
  * has to be enabled and the other port has to be disabled. The
  * last eacr update has to be more than 1.6 seconds in the past.
  */
@@ -1012,7 +1012,7 @@ static void etr_work_fn(struct work_struct *work)
 		eacr = etr_handle_update(&aib, eacr);
 
 	/*
-	 * Select ports to enable. The prefered synchronization mode is PPS.
+	 * Select ports to enable. The preferred synchronization mode is PPS.
 	 * If a port can be enabled depends on a number of things:
 	 * 1) The port needs to be online and uptodate. A port is not
 	 *    disabled just because it is not uptodate, but it is only
@@ -1091,7 +1091,7 @@ static void etr_work_fn(struct work_struct *work)
 	/*
 	 * Update eacr and try to synchronize the clock. If the update
 	 * of eacr caused a stepping port switch (or if we have to
-	 * assume that a stepping port switch has occured) or the
+	 * assume that a stepping port switch has occurred) or the
 	 * clock syncing failed, reset the sync check control bit
 	 * and set up a timer to try again after 0.5 seconds
 	 */
diff --git a/arch/s390/kernel/vtime.c b/arch/s390/kernel/vtime.c
index 1ccdf4d..5e8ead4 100644
--- a/arch/s390/kernel/vtime.c
+++ b/arch/s390/kernel/vtime.c
@@ -44,7 +44,7 @@ static inline void set_vtimer(__u64 expires)
 	__u64 timer;
 
 	asm volatile ("  STPT %0\n"  /* Store current cpu timer value */
-		      "  SPT %1"     /* Set new value immediatly afterwards */
+		      "  SPT %1"     /* Set new value immediately afterwards */
 		      : "=m" (timer) : "m" (expires) );
 	S390_lowcore.system_timer += S390_lowcore.last_update_timer - timer;
 	S390_lowcore.last_update_timer = expires;
diff --git a/arch/s390/kvm/kvm-s390.c b/arch/s390/kvm/kvm-s390.c
index bade533..30ca85c 100644
--- a/arch/s390/kvm/kvm-s390.c
+++ b/arch/s390/kvm/kvm-s390.c
@@ -721,7 +721,7 @@ static int __init kvm_s390_init(void)
 
 	/*
 	 * guests can ask for up to 255+1 double words, we need a full page
-	 * to hold the maximum amount of facilites. On the other hand, we
+	 * to hold the maximum amount of facilities. On the other hand, we
 	 * only set facilities that are known to work in KVM.
 	 */
 	facilities = (unsigned long long *) get_zeroed_page(GFP_KERNEL|GFP_DMA);
diff --git a/arch/s390/kvm/priv.c b/arch/s390/kvm/priv.c
index 9194a4b..73c47bd 100644
--- a/arch/s390/kvm/priv.c
+++ b/arch/s390/kvm/priv.c
@@ -311,7 +311,7 @@ int kvm_s390_handle_b2(struct kvm_vcpu *vcpu)
 
 	/*
 	 * a lot of B2 instructions are priviledged. We first check for
-	 * the priviledges ones, that we can handle in the kernel. If the
+	 * the privileged ones, that we can handle in the kernel. If the
 	 * kernel can handle this instruction, we check for the problem
 	 * state bit and (a) handle the instruction or (b) send a code 2
 	 * program check.
diff --git a/arch/s390/mm/fault.c b/arch/s390/mm/fault.c
index 2c57806..9217e33 100644
--- a/arch/s390/mm/fault.c
+++ b/arch/s390/mm/fault.c
@@ -392,7 +392,7 @@ void __kprobes do_protection_exception(struct pt_regs *regs, long pgm_int_code,
 {
 	int fault;
 
-	/* Protection exception is supressing, decrement psw address. */
+	/* Protection exception is suppressing, decrement psw address. */
 	regs->psw.addr -= (pgm_int_code >> 16);
 	/*
 	 * Check for low-address protection.  This needs to be treated
diff --git a/arch/s390/oprofile/hwsampler.c b/arch/s390/oprofile/hwsampler.c
index 3d48f4d..4952872 100644
--- a/arch/s390/oprofile/hwsampler.c
+++ b/arch/s390/oprofile/hwsampler.c
@@ -517,12 +517,8 @@ stop_exit:
 
 static int check_hardware_prerequisites(void)
 {
-	unsigned long long facility_bits[2];
-
-	memcpy(facility_bits, S390_lowcore.stfle_fac_list, 32);
-	if (!(facility_bits[1] & (1ULL << 59)))
+	if (!test_facility(68))
 		return -EOPNOTSUPP;
-
 	return 0;
 }
 /*
diff --git a/arch/score/Makefile b/arch/score/Makefile
index d77dc63..974aefe 100644
--- a/arch/score/Makefile
+++ b/arch/score/Makefile
@@ -40,5 +40,5 @@ archclean:
 define archhelp
 	echo '  vmlinux.bin          - Raw binary boot image'
 	echo
-	echo '  These will be default as apropriate for a configured platform.'
+	echo '  These will be default as appropriate for a configured platform.'
 endef
diff --git a/arch/sh/Kconfig b/arch/sh/Kconfig
index bc439de..4b89da2 100644
--- a/arch/sh/Kconfig
+++ b/arch/sh/Kconfig
@@ -24,6 +24,7 @@ config SUPERH
 	select RTC_LIB
 	select GENERIC_ATOMIC64
 	select GENERIC_IRQ_SHOW
+	select ARCH_NO_SYSDEV_OPS
 	help
 	  The SuperH is a RISC processor targeted for use in embedded systems
 	  and consumer electronics; it was also used in the Sega Dreamcast
diff --git a/arch/sh/Kconfig.debug b/arch/sh/Kconfig.debug
index 12fec72..1553d56 100644
--- a/arch/sh/Kconfig.debug
+++ b/arch/sh/Kconfig.debug
@@ -82,7 +82,7 @@ config SH_NO_BSS_INIT
 	help
 	  If running in painfully slow environments, such as an RTL
 	  simulation or from remote memory via SHdebug, where the memory
-	  can already be gauranteed to ber zeroed on boot, say Y.
+	  can already be guaranteed to ber zeroed on boot, say Y.
 
 	  For all other cases, say N. If this option seems perplexing, or
 	  you aren't sure, say N.
diff --git a/arch/sh/boards/board-sh7757lcr.c b/arch/sh/boards/board-sh7757lcr.c
index a9e3356..fa2a208 100644
--- a/arch/sh/boards/board-sh7757lcr.c
+++ b/arch/sh/boards/board-sh7757lcr.c
@@ -17,7 +17,7 @@
 #include <linux/io.h>
 #include <linux/mmc/host.h>
 #include <linux/mmc/sh_mmcif.h>
-#include <linux/mfd/sh_mobile_sdhi.h>
+#include <linux/mmc/sh_mobile_sdhi.h>
 #include <cpu/sh7757.h>
 #include <asm/sh_eth.h>
 #include <asm/heartbeat.h>
diff --git a/arch/sh/boards/mach-ap325rxa/setup.c b/arch/sh/boards/mach-ap325rxa/setup.c
index 636d831..618bd56 100644
--- a/arch/sh/boards/mach-ap325rxa/setup.c
+++ b/arch/sh/boards/mach-ap325rxa/setup.c
@@ -156,24 +156,34 @@ static struct platform_device nand_flash_device = {
 #define PORT_DRVCRA	0xA405018A
 #define PORT_DRVCRB	0xA405018C
 
+static int ap320_wvga_set_brightness(void *board_data, int brightness)
+{
+	if (brightness) {
+		gpio_set_value(GPIO_PTS3, 0);
+		__raw_writew(0x100, FPGA_BKLREG);
+	} else {
+		__raw_writew(0, FPGA_BKLREG);
+		gpio_set_value(GPIO_PTS3, 1);
+	}
+	
+	return 0;
+}
+
+static int ap320_wvga_get_brightness(void *board_data)
+{
+	return gpio_get_value(GPIO_PTS3);
+}
+
 static void ap320_wvga_power_on(void *board_data, struct fb_info *info)
 {
 	msleep(100);
 
 	/* ASD AP-320/325 LCD ON */
 	__raw_writew(FPGA_LCDREG_VAL, FPGA_LCDREG);
-
-	/* backlight */
-	gpio_set_value(GPIO_PTS3, 0);
-	__raw_writew(0x100, FPGA_BKLREG);
 }
 
 static void ap320_wvga_power_off(void *board_data)
 {
-	/* backlight */
-	__raw_writew(0, FPGA_BKLREG);
-	gpio_set_value(GPIO_PTS3, 1);
-
 	/* ASD AP-320/325 LCD OFF */
 	__raw_writew(0, FPGA_LCDREG);
 }
@@ -209,6 +219,12 @@ static struct sh_mobile_lcdc_info lcdc_info = {
 		.board_cfg = {
 			.display_on = ap320_wvga_power_on,
 			.display_off = ap320_wvga_power_off,
+			.set_brightness = ap320_wvga_set_brightness,
+			.get_brightness = ap320_wvga_get_brightness,
+		},
+		.bl_info = {
+			.name = "sh_mobile_lcdc_bl",
+			.max_brightness = 1,
 		},
 	}
 };
diff --git a/arch/sh/boards/mach-dreamcast/irq.c b/arch/sh/boards/mach-dreamcast/irq.c
index 78cf2ab..f63d323 100644
--- a/arch/sh/boards/mach-dreamcast/irq.c
+++ b/arch/sh/boards/mach-dreamcast/irq.c
@@ -51,7 +51,7 @@
  */
 #define LEVEL(event) (((event) - HW_EVENT_IRQ_BASE) / 32)
 
-/* Return the hardware event's bit positon within the EMR/ESR */
+/* Return the hardware event's bit position within the EMR/ESR */
 #define EVENT_BIT(event) (((event) - HW_EVENT_IRQ_BASE) & 31)
 
 /*
diff --git a/arch/sh/boards/mach-ecovec24/setup.c b/arch/sh/boards/mach-ecovec24/setup.c
index fd4ff25..86a0d56 100644
--- a/arch/sh/boards/mach-ecovec24/setup.c
+++ b/arch/sh/boards/mach-ecovec24/setup.c
@@ -263,6 +263,18 @@ const static struct fb_videomode ecovec_dvi_modes[] = {
 	},
 };
 
+static int ecovec24_set_brightness(void *board_data, int brightness)
+{
+	gpio_set_value(GPIO_PTR1, brightness);
+
+	return 0;
+}
+
+static int ecovec24_get_brightness(void *board_data)
+{
+	return gpio_get_value(GPIO_PTR1);
+}
+
 static struct sh_mobile_lcdc_info lcdc_info = {
 	.ch[0] = {
 		.interface_type = RGB18,
@@ -273,6 +285,12 @@ static struct sh_mobile_lcdc_info lcdc_info = {
 			.height = 91,
 		},
 		.board_cfg = {
+			.set_brightness = ecovec24_set_brightness,
+			.get_brightness = ecovec24_get_brightness,
+		},
+		.bl_info = {
+			.name = "sh_mobile_lcdc_bl",
+			.max_brightness = 1,
 		},
 	}
 };
@@ -936,7 +954,7 @@ static void __init sh_eth_init(struct sh_eth_plat_data *pd)
 		return;
 	}
 
-	/* read MAC address frome EEPROM */
+	/* read MAC address from EEPROM */
 	for (i = 0; i < sizeof(pd->mac_addr); i++) {
 		pd->mac_addr[i] = mac_read(a, 0x10 + i);
 		msleep(10);
diff --git a/arch/sh/boards/mach-landisk/setup.c b/arch/sh/boards/mach-landisk/setup.c
index 94186cf..f1147ca 100644
--- a/arch/sh/boards/mach-landisk/setup.c
+++ b/arch/sh/boards/mach-landisk/setup.c
@@ -23,7 +23,7 @@
 
 static void landisk_power_off(void)
 {
-        __raw_writeb(0x01, PA_SHUTDOWN);
+	__raw_writeb(0x01, PA_SHUTDOWN);
 }
 
 static struct resource cf_ide_resources[3];
@@ -85,7 +85,7 @@ device_initcall(landisk_devices_setup);
 
 static void __init landisk_setup(char **cmdline_p)
 {
-        /* LED ON */
+	/* LED ON */
 	__raw_writeb(__raw_readb(PA_LED) | 0x03, PA_LED);
 
 	printk(KERN_INFO "I-O DATA DEVICE, INC. \"LANDISK Series\" support.\n");
@@ -97,7 +97,6 @@ static void __init landisk_setup(char **cmdline_p)
  */
 static struct sh_machine_vector mv_landisk __initmv = {
 	.mv_name = "LANDISK",
-	.mv_nr_irqs = 72,
 	.mv_setup = landisk_setup,
 	.mv_init_irq = init_landisk_IRQ,
 };
diff --git a/arch/sh/drivers/pci/pci-sh7751.h b/arch/sh/drivers/pci/pci-sh7751.h
index 4983a4d..5ede38c 100644
--- a/arch/sh/drivers/pci/pci-sh7751.h
+++ b/arch/sh/drivers/pci/pci-sh7751.h
@@ -61,7 +61,7 @@
   #define SH7751_PCICONF3_BIST7      0x80000000  /* Bist Supported */
   #define SH7751_PCICONF3_BIST6      0x40000000  /* Bist Executing */
   #define SH7751_PCICONF3_BIST3_0    0x0F000000  /* Bist Passed */
-  #define SH7751_PCICONF3_HD7        0x00800000  /* Single Funtion device */
+  #define SH7751_PCICONF3_HD7        0x00800000  /* Single Function device */
   #define SH7751_PCICONF3_HD6_0      0x007F0000  /* Configuration Layout */
   #define SH7751_PCICONF3_LAT        0x0000FF00  /* Latency Timer */
   #define SH7751_PCICONF3_CLS        0x000000FF  /* Cache Line Size */
diff --git a/arch/sh/drivers/pci/pci.c b/arch/sh/drivers/pci/pci.c
index a09c77d..194231c 100644
--- a/arch/sh/drivers/pci/pci.c
+++ b/arch/sh/drivers/pci/pci.c
@@ -84,7 +84,7 @@ int __devinit register_pci_controller(struct pci_channel *hose)
 	hose_tail = &hose->next;
 
 	/*
-	 * Do not panic here but later - this might hapen before console init.
+	 * Do not panic here but later - this might happen before console init.
 	 */
 	if (!hose->io_map_base) {
 		printk(KERN_WARNING
diff --git a/arch/sh/include/asm/page.h b/arch/sh/include/asm/page.h
index c4e0b3d..822d608 100644
--- a/arch/sh/include/asm/page.h
+++ b/arch/sh/include/asm/page.h
@@ -186,7 +186,7 @@ typedef struct page *pgtable_t;
 /*
  * While BYTES_PER_WORD == 4 on the current sh64 ABI, GCC will still
  * happily generate {ld/st}.q pairs, requiring us to have 8-byte
- * alignment to avoid traps. The kmalloc alignment is gauranteed by
+ * alignment to avoid traps. The kmalloc alignment is guaranteed by
  * virtue of L1_CACHE_BYTES, requiring this to only be special cased
  * for slab caches.
  */
diff --git a/arch/sh/include/asm/pgtable_32.h b/arch/sh/include/asm/pgtable_32.h
index b799fe7..0bce3d8 100644
--- a/arch/sh/include/asm/pgtable_32.h
+++ b/arch/sh/include/asm/pgtable_32.h
@@ -167,7 +167,7 @@ static inline unsigned long copy_ptea_attributes(unsigned long x)
 #endif
 
 /*
- * Mask of bits that are to be preserved accross pgprot changes.
+ * Mask of bits that are to be preserved across pgprot changes.
  */
 #define _PAGE_CHG_MASK \
 	(PTE_MASK | _PAGE_ACCESSED | _PAGE_CACHABLE | \
diff --git a/arch/sh/include/asm/unaligned-sh4a.h b/arch/sh/include/asm/unaligned-sh4a.h
index c48a9c3..95adc50 100644
--- a/arch/sh/include/asm/unaligned-sh4a.h
+++ b/arch/sh/include/asm/unaligned-sh4a.h
@@ -9,7 +9,7 @@
  * struct.
  *
  * The same note as with the movli.l/movco.l pair applies here, as long
- * as the load is gauranteed to be inlined, nothing else will hook in to
+ * as the load is guaranteed to be inlined, nothing else will hook in to
  * r0 and we get the return value for free.
  *
  * NOTE: Due to the fact we require r0 encoding, care should be taken to
diff --git a/arch/sh/include/mach-common/mach/highlander.h b/arch/sh/include/mach-common/mach/highlander.h
index 5d9d4d5..6ce944e 100644
--- a/arch/sh/include/mach-common/mach/highlander.h
+++ b/arch/sh/include/mach-common/mach/highlander.h
@@ -24,7 +24,7 @@
 #define PA_OBLED        (PA_BCR+0x001c) /* On Board LED control */
 #define PA_OBSW         (PA_BCR+0x001e) /* On Board Switch control */
 #define PA_AUDIOSEL     (PA_BCR+0x0020) /* Sound Interface Select control */
-#define PA_EXTPLR       (PA_BCR+0x001e) /* Extention Pin Polarity control */
+#define PA_EXTPLR       (PA_BCR+0x001e) /* Extension Pin Polarity control */
 #define PA_TPCTL        (PA_BCR+0x0100) /* Touch Panel Access control */
 #define PA_TPDCKCTL     (PA_BCR+0x0102) /* Touch Panel Access data control */
 #define PA_TPCTLCLR     (PA_BCR+0x0104) /* Touch Panel Access control */
@@ -89,7 +89,7 @@
 #define PA_OBLED	(PA_BCR+0x0018)	/* On Board LED control */
 #define PA_OBSW		(PA_BCR+0x001a)	/* On Board Switch control */
 #define PA_AUDIOSEL	(PA_BCR+0x001c)	/* Sound Interface Select control */
-#define PA_EXTPLR	(PA_BCR+0x001e)	/* Extention Pin Polarity control */
+#define PA_EXTPLR	(PA_BCR+0x001e)	/* Extension Pin Polarity control */
 #define PA_TPCTL	(PA_BCR+0x0100)	/* Touch Panel Access control */
 #define PA_TPDCKCTL	(PA_BCR+0x0102)	/* Touch Panel Access data control */
 #define PA_TPCTLCLR	(PA_BCR+0x0104)	/* Touch Panel Access control */
diff --git a/arch/sh/include/mach-common/mach/r2d.h b/arch/sh/include/mach-common/mach/r2d.h
index 0a80015..e04f75e 100644
--- a/arch/sh/include/mach-common/mach/r2d.h
+++ b/arch/sh/include/mach-common/mach/r2d.h
@@ -18,18 +18,18 @@
 #define PA_DISPCTL	0xa4000008	/* Display Timing control */
 #define PA_SDMPOW	0xa400000a	/* SD Power control */
 #define PA_RTCCE	0xa400000c	/* RTC(9701) Enable control */
-#define PA_PCICD	0xa400000e	/* PCI Extention detect control */
+#define PA_PCICD	0xa400000e	/* PCI Extension detect control */
 #define PA_VOYAGERRTS	0xa4000020	/* VOYAGER Reset control */
 
 #define PA_R2D1_AXRST		0xa4000022	/* AX_LAN Reset control */
 #define PA_R2D1_CFRST		0xa4000024	/* CF Reset control */
 #define PA_R2D1_ADMRTS		0xa4000026	/* SD Reset control */
-#define PA_R2D1_EXTRST		0xa4000028	/* Extention Reset control */
+#define PA_R2D1_EXTRST		0xa4000028	/* Extension Reset control */
 #define PA_R2D1_CFCDINTCLR	0xa400002a	/* CF Insert Interrupt clear */
 
 #define PA_R2DPLUS_CFRST	0xa4000022	/* CF Reset control */
 #define PA_R2DPLUS_ADMRTS	0xa4000024	/* SD Reset control */
-#define PA_R2DPLUS_EXTRST	0xa4000026	/* Extention Reset control */
+#define PA_R2DPLUS_EXTRST	0xa4000026	/* Extension Reset control */
 #define PA_R2DPLUS_CFCDINTCLR	0xa4000028	/* CF Insert Interrupt clear */
 #define PA_R2DPLUS_KEYCTLCLR	0xa400002a	/* Key Interrupt clear */
 
diff --git a/arch/sh/kernel/cpu/clock-cpg.c b/arch/sh/kernel/cpu/clock-cpg.c
index dd0e0f2..8f63a26 100644
--- a/arch/sh/kernel/cpu/clock-cpg.c
+++ b/arch/sh/kernel/cpu/clock-cpg.c
@@ -67,7 +67,7 @@ int __init __deprecated cpg_clk_init(void)
 }
 
 /*
- * Placeholder for compatability, until the lazy CPUs do this
+ * Placeholder for compatibility, until the lazy CPUs do this
  * on their own.
  */
 int __init __weak arch_clk_init(void)
diff --git a/arch/sh/kernel/cpu/sh4a/setup-sh7786.c b/arch/sh/kernel/cpu/sh4a/setup-sh7786.c
index 1656b8c..beba32b 100644
--- a/arch/sh/kernel/cpu/sh4a/setup-sh7786.c
+++ b/arch/sh/kernel/cpu/sh4a/setup-sh7786.c
@@ -648,7 +648,7 @@ static void __init sh7786_usb_setup(void)
 	 * The following settings are necessary
 	 * for using the USB modules.
 	 *
-	 * see "USB Inital Settings" for detail
+	 * see "USB Initial Settings" for detail
 	 */
 	__raw_writel(USBINITVAL1, USBINITREG1);
 	__raw_writel(USBINITVAL2, USBINITREG2);
diff --git a/arch/sh/kernel/irq.c b/arch/sh/kernel/irq.c
index 64ea0b1..9197110 100644
--- a/arch/sh/kernel/irq.c
+++ b/arch/sh/kernel/irq.c
@@ -183,7 +183,7 @@ asmlinkage void do_softirq(void)
 		);
 
 		/*
-		 * Shouldnt happen, we returned above if in_interrupt():
+		 * Shouldn't happen, we returned above if in_interrupt():
 		 */
 		WARN_ON_ONCE(softirq_count());
 	}
diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index 4f26716..58bff45 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -150,7 +150,7 @@ void __init check_for_initrd(void)
 	}
 
 	/*
-	 * If we got this far inspite of the boot loader's best efforts
+	 * If we got this far in spite of the boot loader's best efforts
 	 * to the contrary, assume we actually have a valid initrd and
 	 * fix up the root dev.
 	 */
diff --git a/arch/sh/lib64/copy_user_memcpy.S b/arch/sh/lib64/copy_user_memcpy.S
index 2a62816..49aeabe 100644
--- a/arch/sh/lib64/copy_user_memcpy.S
+++ b/arch/sh/lib64/copy_user_memcpy.S
@@ -27,7 +27,7 @@
 ! 2.: When there are two or three bytes in the last word of an 11-or-more
 !     bytes memory chunk to b copied, the rest of the word can be read
 !     without side effects.
-!     This could be easily changed by increasing the minumum size of
+!     This could be easily changed by increasing the minimum size of
 !     a fast memcpy and the amount subtracted from r7 before L_2l_loop be 2,
 !     however, this would cost a few extra cyles on average.
 !     For SHmedia, the assumption is that any quadword can be read in its
diff --git a/arch/sh/lib64/memcpy.S b/arch/sh/lib64/memcpy.S
index dd300c3..5d682e0 100644
--- a/arch/sh/lib64/memcpy.S
+++ b/arch/sh/lib64/memcpy.S
@@ -29,7 +29,7 @@
 ! 2.: When there are two or three bytes in the last word of an 11-or-more
 !     bytes memory chunk to b copied, the rest of the word can be read
 !     without side effects.
-!     This could be easily changed by increasing the minumum size of
+!     This could be easily changed by increasing the minimum size of
 !     a fast memcpy and the amount subtracted from r7 before L_2l_loop be 2,
 !     however, this would cost a few extra cyles on average.
 !     For SHmedia, the assumption is that any quadword can be read in its
diff --git a/arch/sparc/include/asm/hypervisor.h b/arch/sparc/include/asm/hypervisor.h
index bafe5a6..7568640 100644
--- a/arch/sparc/include/asm/hypervisor.h
+++ b/arch/sparc/include/asm/hypervisor.h
@@ -654,7 +654,7 @@ extern unsigned long sun4v_mmu_tsb_ctx0(unsigned long num_descriptions,
  * ARG3:	mmu context
  * ARG4:	flags (HV_MMU_{IMMU,DMMU})
  * RET0:	status
- * ERRORS:	EINVAL			Invalid virutal address, context, or
+ * ERRORS:	EINVAL			Invalid virtual address, context, or
  *					flags value
  *		ENOTSUPPORTED		ARG0 or ARG1 is non-zero
  *
@@ -721,7 +721,7 @@ extern void sun4v_mmu_demap_all(void);
  * ARG2:	TTE
  * ARG3:	flags (HV_MMU_{IMMU,DMMU})
  * RET0:	status
- * ERRORS:	EINVAL			Invalid virutal address or flags value
+ * ERRORS:	EINVAL			Invalid virtual address or flags value
  *		EBADPGSZ		Invalid page size value
  *		ENORADDR		Invalid real address in TTE
  *		ETOOMANY		Too many mappings (max of 8 reached)
@@ -800,7 +800,7 @@ extern unsigned long sun4v_mmu_map_perm_addr(unsigned long vaddr,
  * ARG1:	reserved, must be zero
  * ARG2:	flags (HV_MMU_{IMMU,DMMU})
  * RET0:	status
- * ERRORS:	EINVAL			Invalid virutal address or flags value
+ * ERRORS:	EINVAL			Invalid virtual address or flags value
  *		ENOMAP			Specified mapping was not found
  *
  * Demaps any permanent page mapping (established via
@@ -1205,7 +1205,7 @@ struct hv_trap_trace_control {
  * structure contents.  Attempts to do so will result in undefined
  * behavior for the guest.
  *
- * Each trap trace buffer entry is layed out as follows:
+ * Each trap trace buffer entry is laid out as follows:
  */
 #ifndef __ASSEMBLY__
 struct hv_trap_trace_entry {
@@ -1300,7 +1300,7 @@ struct hv_trap_trace_entry {
  * state in RET1.  Future systems may define various flags for the
  * enable argument (ARG0), for the moment a guest should pass
  * "(uint64_t) -1" to enable, and "(uint64_t) 0" to disable all
- * tracing - which will ensure future compatability.
+ * tracing - which will ensure future compatibility.
  */
 #define HV_FAST_TTRACE_ENABLE		0x92
 
@@ -1880,7 +1880,7 @@ extern unsigned long sun4v_vintr_set_target(unsigned long dev_handle,
  * pci_device, at pci_config_offset from the beginning of the device's
  * configuration space.  If there was no error, RET1 is set to zero and
  * RET2 is set to the data read.  Insignificant bits in RET2 are not
- * guarenteed to have any specific value and therefore must be ignored.
+ * guaranteed to have any specific value and therefore must be ignored.
  *
  * The data returned in RET2 is size based byte swapped.
  *
@@ -1941,9 +1941,9 @@ extern unsigned long sun4v_vintr_set_target(unsigned long dev_handle,
  * and return the actual data read in RET2.  The data returned is size based
  * byte swapped.
  *
- * Non-significant bits in RET2 are not guarenteed to have any specific value
+ * Non-significant bits in RET2 are not guaranteed to have any specific value
  * and therefore must be ignored.  If RET1 is returned as non-zero, the data
- * value is not guarenteed to have any specific value and should be ignored.
+ * value is not guaranteed to have any specific value and should be ignored.
  *
  * The caller must have permission to read from the given devhandle, real
  * address, which must be an IO address.  The argument real address must be a
@@ -2456,9 +2456,9 @@ extern unsigned long sun4v_vintr_set_target(unsigned long dev_handle,
  *
  * As receive queue configuration causes a reset of the queue's head and
  * tail pointers there is no way for a gues to determine how many entries
- * have been received between a preceeding ldc_get_rx_state() API call
+ * have been received between a preceding ldc_get_rx_state() API call
  * and the completion of the configuration operation.  It should be noted
- * that datagram delivery is not guarenteed via domain channels anyway,
+ * that datagram delivery is not guaranteed via domain channels anyway,
  * and therefore any higher protocol should be resilient to datagram
  * loss if necessary.  However, to overcome this specific race potential
  * it is recommended, for example, that a higher level protocol be employed
diff --git a/arch/sparc/include/asm/ns87303.h b/arch/sparc/include/asm/ns87303.h
index 686defe..af75548 100644
--- a/arch/sparc/include/asm/ns87303.h
+++ b/arch/sparc/include/asm/ns87303.h
@@ -37,7 +37,7 @@
 /* Power and Test Register (PTR) bits */
 #define PTR_LPTB_IRQ7	0x08
 #define PTR_LEVEL_IRQ	0x80	/* When not ECP/EPP: Use level IRQ           */
-#define PTR_LPT_REG_DIR	0x80	/* When ECP/EPP: LPT CTR controlls direction */
+#define PTR_LPT_REG_DIR	0x80	/* When ECP/EPP: LPT CTR controls direction */
 				/*               of the parallel port	     */
 
 /* Function Control Register (FCR) bits */
diff --git a/arch/sparc/include/asm/pcr.h b/arch/sparc/include/asm/pcr.h
index 843e4fa..288d7be 100644
--- a/arch/sparc/include/asm/pcr.h
+++ b/arch/sparc/include/asm/pcr.h
@@ -31,7 +31,7 @@ extern unsigned int picl_shift;
 
 /* In order to commonize as much of the implementation as
  * possible, we use PICH as our counter.  Mostly this is
- * to accomodate Niagara-1 which can only count insn cycles
+ * to accommodate Niagara-1 which can only count insn cycles
  * in PICH.
  */
 static inline u64 picl_value(unsigned int nmi_hz)
diff --git a/arch/sparc/include/asm/ptrace.h b/arch/sparc/include/asm/ptrace.h
index 30b0b79..c7ad3fe 100644
--- a/arch/sparc/include/asm/ptrace.h
+++ b/arch/sparc/include/asm/ptrace.h
@@ -33,7 +33,7 @@ struct pt_regs {
 	 * things like "in a system call" etc. for an arbitray
 	 * process.
 	 *
-	 * The PT_REGS_MAGIC is choosen such that it can be
+	 * The PT_REGS_MAGIC is chosen such that it can be
 	 * loaded completely using just a sethi instruction.
 	 */
 	unsigned int magic;
diff --git a/arch/sparc/kernel/entry.S b/arch/sparc/kernel/entry.S
index 906ee3e..6da784a 100644
--- a/arch/sparc/kernel/entry.S
+++ b/arch/sparc/kernel/entry.S
@@ -801,7 +801,7 @@ vac_linesize_patch_32:		subcc	%l7, 32, %l7
 	.globl	vac_hwflush_patch1_on, vac_hwflush_patch2_on
 
 /*
- * Ugly, but we cant use hardware flushing on the sun4 and we'd require
+ * Ugly, but we can't use hardware flushing on the sun4 and we'd require
  * two instructions (Anton)
  */
 vac_hwflush_patch1_on:		addcc	%l7, -PAGE_SIZE, %l7
@@ -851,7 +851,7 @@ sun4c_fault:
 	 sethi	%hi(~((1 << SUN4C_REAL_PGDIR_SHIFT) - 1)), %l4
 
 	/* If the kernel references a bum kernel pointer, or a pte which
-	 * points to a non existant page in ram, we will run this code
+	 * points to a non existent page in ram, we will run this code
 	 * _forever_ and lock up the machine!!!!! So we must check for
 	 * this condition, the AC_SYNC_ERR bits are what we must examine.
 	 * Also a parity error would make this happen as well.  So we just
diff --git a/arch/sparc/kernel/head_64.S b/arch/sparc/kernel/head_64.S
index f8f2105..aa594c7 100644
--- a/arch/sparc/kernel/head_64.S
+++ b/arch/sparc/kernel/head_64.S
@@ -85,7 +85,7 @@ sparc_ramdisk_image64:
 sparc64_boot:
 	mov	%o4, %l7
 
-	/* We need to remap the kernel.  Use position independant
+	/* We need to remap the kernel.  Use position independent
 	 * code to remap us to KERNBASE.
 	 *
 	 * SILO can invoke us with 32-bit address masking enabled,
diff --git a/arch/sparc/kernel/init_task.c b/arch/sparc/kernel/init_task.c
index 5fe3d65..35f141a 100644
--- a/arch/sparc/kernel/init_task.c
+++ b/arch/sparc/kernel/init_task.c
@@ -15,7 +15,7 @@ EXPORT_SYMBOL(init_task);
 
 /* .text section in head.S is aligned at 8k boundary and this gets linked
  * right after that so that the init_thread_union is aligned properly as well.
- * If this is not aligned on a 8k boundry, then you should change code
+ * If this is not aligned on a 8k boundary, then you should change code
  * in etrap.S which assumes it.
  */
 union thread_union init_thread_union __init_task_data =
diff --git a/arch/sparc/kernel/of_device_64.c b/arch/sparc/kernel/of_device_64.c
index 63cd4e5..5c14968 100644
--- a/arch/sparc/kernel/of_device_64.c
+++ b/arch/sparc/kernel/of_device_64.c
@@ -459,7 +459,7 @@ apply_interrupt_map(struct device_node *dp, struct device_node *pp,
 		 *
 		 * Handle this by deciding that, if we didn't get a
 		 * match in the parent's 'interrupt-map', and the
-		 * parent is an IRQ translater, then use the parent as
+		 * parent is an IRQ translator, then use the parent as
 		 * our IRQ controller.
 		 */
 		if (pp->irq_trans)
diff --git a/arch/sparc/kernel/perf_event.c b/arch/sparc/kernel/perf_event.c
index 7605786..ee8426e 100644
--- a/arch/sparc/kernel/perf_event.c
+++ b/arch/sparc/kernel/perf_event.c
@@ -1027,7 +1027,7 @@ static int sparc_pmu_add(struct perf_event *event, int ef_flags)
 
 	/*
 	 * If group events scheduling transaction was started,
-	 * skip the schedulability test here, it will be peformed
+	 * skip the schedulability test here, it will be performed
 	 * at commit time(->commit_txn) as a whole
 	 */
 	if (cpuc->group_flag & PERF_EVENT_TXN)
diff --git a/arch/sparc/math-emu/Makefile b/arch/sparc/math-emu/Makefile
index b9085ec..825dbee 100644
--- a/arch/sparc/math-emu/Makefile
+++ b/arch/sparc/math-emu/Makefile
@@ -2,7 +2,7 @@
 # Makefile for the FPU instruction emulation.
 #
 
-# supress all warnings - as math.c produces a lot!
+# suppress all warnings - as math.c produces a lot!
 ccflags-y := -w
 
 obj-y    := math_$(BITS).o
diff --git a/arch/tile/Kconfig b/arch/tile/Kconfig
index 6e2cdd5..e32b0c2 100644
--- a/arch/tile/Kconfig
+++ b/arch/tile/Kconfig
@@ -51,7 +51,7 @@ config GENERIC_TIME
 config GENERIC_CLOCKEVENTS
 	def_bool y
 
-# FIXME: tilegx can implement a more efficent rwsem.
+# FIXME: tilegx can implement a more efficient rwsem.
 config RWSEM_GENERIC_SPINLOCK
 	def_bool y
 
diff --git a/arch/tile/include/hv/drv_xgbe_intf.h b/arch/tile/include/hv/drv_xgbe_intf.h
index 146e47d..f13188a 100644
--- a/arch/tile/include/hv/drv_xgbe_intf.h
+++ b/arch/tile/include/hv/drv_xgbe_intf.h
@@ -319,7 +319,7 @@ typedef union
  *         is an error code, or zero if no error.  The val0 member is the
  *         updated value of seqno; it has been incremented by 1 for each
  *         packet sent.  That increment may be less than nentries if an
- *         error occured, or if some of the entries in the vector contain
+ *         error occurred, or if some of the entries in the vector contain
  *         handles equal to NETIO_PKT_HANDLE_NONE.  The val1 member is the
  *         updated value of nentries; it has been decremented by 1 for each
  *         vector entry processed.  Again, that decrement may be less than
diff --git a/arch/tile/include/hv/hypervisor.h b/arch/tile/include/hv/hypervisor.h
index 1b8bf03..ee41bca 100644
--- a/arch/tile/include/hv/hypervisor.h
+++ b/arch/tile/include/hv/hypervisor.h
@@ -1340,7 +1340,7 @@ typedef struct
  *  this operation.  If any permanent delivery errors were encountered,
  *  the routine returns HV_ERECIP.  In the event of permanent delivery
  *  errors, it may be the case that delivery was not attempted to all
- *  recipients; if any messages were succesfully delivered, however,
+ *  recipients; if any messages were successfully delivered, however,
  *  recipients' state values will be updated appropriately.
  *
  *  It is explicitly legal to specify a recipient structure whose state
@@ -1359,7 +1359,7 @@ typedef struct
  *  never call hv_receive_message, or could register a different state
  *  buffer, losing the message.
  *
- *  Specifiying the same recipient more than once in the recipient list
+ *  Specifying the same recipient more than once in the recipient list
  *  is an error, which will not result in an error return but which may
  *  or may not result in more than one message being delivered to the
  *  recipient tile.
diff --git a/arch/tile/kernel/pci.c b/arch/tile/kernel/pci.c
index a1ee25b..ea38f0c 100644
--- a/arch/tile/kernel/pci.c
+++ b/arch/tile/kernel/pci.c
@@ -36,7 +36,7 @@
  * Initialization flow and process
  * -------------------------------
  *
- * This files containes the routines to search for PCI buses,
+ * This files contains the routines to search for PCI buses,
  * enumerate the buses, and configure any attached devices.
  *
  * There are two entry points here:
@@ -519,7 +519,7 @@ static int __devinit tile_cfg_read(struct pci_bus *bus,
 
 
 /*
- * See tile_cfg_read() for relevent comments.
+ * See tile_cfg_read() for relevant comments.
  * Note that "val" is the value to write, not a pointer to that value.
  */
 static int __devinit tile_cfg_write(struct pci_bus *bus,
diff --git a/arch/tile/mm/fault.c b/arch/tile/mm/fault.c
index 758f597..51f8663 100644
--- a/arch/tile/mm/fault.c
+++ b/arch/tile/mm/fault.c
@@ -290,7 +290,7 @@ static int handle_page_fault(struct pt_regs *regs,
 	/*
 	 * Early on, we need to check for migrating PTE entries;
 	 * see homecache.c.  If we find a migrating PTE, we wait until
-	 * the backing page claims to be done migrating, then we procede.
+	 * the backing page claims to be done migrating, then we proceed.
 	 * For kernel PTEs, we rewrite the PTE and return and retry.
 	 * Otherwise, we treat the fault like a normal "no PTE" fault,
 	 * rather than trying to patch up the existing PTE.
diff --git a/arch/tile/mm/hugetlbpage.c b/arch/tile/mm/hugetlbpage.c
index 201a582..42cfcba 100644
--- a/arch/tile/mm/hugetlbpage.c
+++ b/arch/tile/mm/hugetlbpage.c
@@ -219,7 +219,7 @@ try_again:
 	if (mm->free_area_cache < len)
 		goto fail;
 
-	/* either no address requested or cant fit in requested address hole */
+	/* either no address requested or can't fit in requested address hole */
 	addr = (mm->free_area_cache - len) & huge_page_mask(h);
 	do {
 		/*
diff --git a/arch/um/Kconfig.net b/arch/um/Kconfig.net
index 9e9a4aa..3160b1a 100644
--- a/arch/um/Kconfig.net
+++ b/arch/um/Kconfig.net
@@ -186,7 +186,7 @@ config UML_NET_SLIRP
         other transports, SLiRP works without the need of root level
         privleges, setuid binaries, or SLIP devices on the host.  This
         also means not every type of connection is possible, but most
-        situations can be accomodated with carefully crafted slirp
+        situations can be accommodated with carefully crafted slirp
         commands that can be passed along as part of the network device's
         setup string.  The effect of this transport on the UML is similar
         that of a host behind a firewall that masquerades all network
diff --git a/arch/unicore32/include/mach/regs-umal.h b/arch/unicore32/include/mach/regs-umal.h
index 885bb62..aa22df7 100644
--- a/arch/unicore32/include/mach/regs-umal.h
+++ b/arch/unicore32/include/mach/regs-umal.h
@@ -52,7 +52,7 @@
  */
 #define UMAL_MIISTATUS		(PKUNITY_UMAL_BASE + 0x0030)
 /*
- * MII Managment Indicator UMAL_MIIIDCT
+ * MII Management Indicator UMAL_MIIIDCT
  */
 #define UMAL_MIIIDCT		(PKUNITY_UMAL_BASE + 0x0034)
 /*
@@ -91,7 +91,7 @@
 #define UMAL_FIFORAM6		(PKUNITY_UMAL_BASE + 0x0078)
 #define UMAL_FIFORAM7		(PKUNITY_UMAL_BASE + 0x007c)
 
-/* MAHBE MODUEL OF UMAL */
+/* MAHBE MODULE OF UMAL */
 /* UMAL's MAHBE module interfaces to the host system through 32-bit AHB Master
  * and Slave ports.Registers within the M-AHBE provide Control and Status
  * information concerning these transfers.
diff --git a/arch/unicore32/kernel/head.S b/arch/unicore32/kernel/head.S
index 92255f3..8caf322 100644
--- a/arch/unicore32/kernel/head.S
+++ b/arch/unicore32/kernel/head.S
@@ -164,7 +164,7 @@ ENTRY(stext)
 ENDPROC(stext)
 
 /*
- * Enable the MMU.  This completely changes the stucture of the visible
+ * Enable the MMU.  This completely changes the structure of the visible
  * memory space.  You will not be able to trace execution through this.
  *
  *  r0  = cp#0 control register
diff --git a/arch/x86/include/asm/i387.h b/arch/x86/include/asm/i387.h
index ef32890..c9e09ea 100644
--- a/arch/x86/include/asm/i387.h
+++ b/arch/x86/include/asm/i387.h
@@ -237,7 +237,7 @@ static inline void fpu_save_init(struct fpu *fpu)
 	} else if (use_fxsr()) {
 		fpu_fxsave(fpu);
 	} else {
-		asm volatile("fsave %[fx]; fwait"
+		asm volatile("fnsave %[fx]; fwait"
 			     : [fx] "=m" (fpu->state->fsave));
 		return;
 	}
diff --git a/arch/x86/kernel/setup.c b/arch/x86/kernel/setup.c
index 5a0484a..4be9b39 100644
--- a/arch/x86/kernel/setup.c
+++ b/arch/x86/kernel/setup.c
@@ -976,6 +976,11 @@ void __init setup_arch(char **cmdline_p)
 	paging_init();
 	x86_init.paging.pagetable_setup_done(swapper_pg_dir);
 
+	if (boot_cpu_data.cpuid_level >= 0) {
+		/* A CPU has %cr4 if and only if it has CPUID */
+		mmu_cr4_features = read_cr4();
+	}
+
 #ifdef CONFIG_X86_32
 	/* sync back kernel address range */
 	clone_pgd_range(initial_page_table + KERNEL_PGD_BOUNDARY,
diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c
index 58f517b..934b4c6 100644
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@ -2395,9 +2395,9 @@ static void do_cpuid_ent(struct kvm_cpuid_entry2 *entry, u32 function,
 		int i;
 
 		entry->flags |= KVM_CPUID_FLAG_SIGNIFCANT_INDEX;
-		for (i = 1; *nent < maxnent; ++i) {
-			if (entry[i - 1].eax == 0 && i != 2)
-				break;
+		for (i = 1; *nent < maxnent && i < 64; ++i) {
+			if (entry[i].eax == 0)
+				continue;
 			do_cpuid_1_ent(&entry[i], function, i);
 			entry[i].flags |=
 			       KVM_CPUID_FLAG_SIGNIFCANT_INDEX;
@@ -4958,12 +4958,6 @@ struct kvm_cpuid_entry2 *kvm_find_cpuid_entry(struct kvm_vcpu *vcpu,
 			best = e;
 			break;
 		}
-		/*
-		 * Both basic or both extended?
-		 */
-		if (((e->function ^ function) & 0x80000000) == 0)
-			if (!best || e->function > best->function)
-				best = e;
 	}
 	return best;
 }
@@ -4983,6 +4977,27 @@ not_found:
 	return 36;
 }
 
+/*
+ * If no match is found, check whether we exceed the vCPU's limit
+ * and return the content of the highest valid _standard_ leaf instead.
+ * This is to satisfy the CPUID specification.
+ */
+static struct kvm_cpuid_entry2* check_cpuid_limit(struct kvm_vcpu *vcpu,
+                                                  u32 function, u32 index)
+{
+	struct kvm_cpuid_entry2 *maxlevel;
+
+	maxlevel = kvm_find_cpuid_entry(vcpu, function & 0x80000000, 0);
+	if (!maxlevel || maxlevel->eax >= function)
+		return NULL;
+	if (function & 0x80000000) {
+		maxlevel = kvm_find_cpuid_entry(vcpu, 0, 0);
+		if (!maxlevel)
+			return NULL;
+	}
+	return kvm_find_cpuid_entry(vcpu, maxlevel->eax, index);
+}
+
 void kvm_emulate_cpuid(struct kvm_vcpu *vcpu)
 {
 	u32 function, index;
@@ -4995,6 +5010,10 @@ void kvm_emulate_cpuid(struct kvm_vcpu *vcpu)
 	kvm_register_write(vcpu, VCPU_REGS_RCX, 0);
 	kvm_register_write(vcpu, VCPU_REGS_RDX, 0);
 	best = kvm_find_cpuid_entry(vcpu, function, index);
+
+	if (!best)
+		best = check_cpuid_limit(vcpu, function, index);
+
 	if (best) {
 		kvm_register_write(vcpu, VCPU_REGS_RAX, best->eax);
 		kvm_register_write(vcpu, VCPU_REGS_RBX, best->ebx);
diff --git a/arch/x86/mm/srat_32.c b/arch/x86/mm/srat_32.c
index 48651c6..364f36b 100644
--- a/arch/x86/mm/srat_32.c
+++ b/arch/x86/mm/srat_32.c
@@ -211,10 +211,12 @@ int __init get_memcfg_from_srat(void)
 {
 	int i, j, nid;
 
-
 	if (srat_disabled())
 		goto out_fail;
 
+	if (acpi_numa_init() < 0)
+		goto out_fail;
+
 	if (num_memory_chunks == 0) {
 		printk(KERN_DEBUG
 			 "could not find any ACPI SRAT memory areas.\n");
diff --git a/arch/x86/platform/mrst/vrtc.c b/arch/x86/platform/mrst/vrtc.c
index 04cf645..73d70d6 100644
--- a/arch/x86/platform/mrst/vrtc.c
+++ b/arch/x86/platform/mrst/vrtc.c
@@ -100,9 +100,11 @@ int vrtc_set_mmss(unsigned long nowtime)
 
 void __init mrst_rtc_init(void)
 {
-	unsigned long vrtc_paddr = sfi_mrtc_array[0].phys_addr;
+	unsigned long vrtc_paddr;
 
 	sfi_table_parse(SFI_SIG_MRTC, NULL, NULL, sfi_parse_mrtc);
+
+	vrtc_paddr = sfi_mrtc_array[0].phys_addr;
 	if (!sfi_mrtc_num || !vrtc_paddr)
 		return;
 
diff --git a/arch/x86/platform/visws/visws_quirks.c b/arch/x86/platform/visws/visws_quirks.c
index fe4cf82..c7abf13 100644
--- a/arch/x86/platform/visws/visws_quirks.c
+++ b/arch/x86/platform/visws/visws_quirks.c
@@ -471,15 +471,7 @@ static unsigned int startup_piix4_master_irq(struct irq_data *data)
 {
 	legacy_pic->init(0);
 	enable_cobalt_irq(data);
-}
-
-static void end_piix4_master_irq(struct irq_data *data)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&cobalt_lock, flags);
-	enable_cobalt_irq(data);
-	spin_unlock_irqrestore(&cobalt_lock, flags);
+	return 0;
 }
 
 static struct irq_chip piix4_master_irq_type = {
@@ -492,7 +484,7 @@ static void pii4_mask(struct irq_data *data) { }
 
 static struct irq_chip piix4_virtual_irq_type = {
 	.name		= "PIIX4-virtual",
-	.mask		= pii4_mask,
+	.irq_mask	= pii4_mask,
 };
 
 /*
@@ -580,9 +572,9 @@ static struct irqaction cascade_action = {
 
 static inline void set_piix4_virtual_irq_type(void)
 {
-	piix4_virtual_irq_type.enable =	i8259A_chip.unmask;
-	piix4_virtual_irq_type.disable = i8259A_chip.mask;
-	piix4_virtual_irq_type.unmask =	i8259A_chip.unmask;
+	piix4_virtual_irq_type.irq_enable = i8259A_chip.irq_unmask;
+	piix4_virtual_irq_type.irq_disable = i8259A_chip.irq_mask;
+	piix4_virtual_irq_type.irq_unmask = i8259A_chip.irq_unmask;
 }
 
 static void __init visws_pre_intr_init(void)
@@ -599,7 +591,7 @@ static void __init visws_pre_intr_init(void)
 		else if (i == CO_IRQ_IDE0)
 			chip = &cobalt_irq_type;
 		else if (i == CO_IRQ_IDE1)
-			>chip = &cobalt_irq_type;
+			chip = &cobalt_irq_type;
 		else if (i == CO_IRQ_8259)
 			chip = &piix4_master_irq_type;
 		else if (i < CO_IRQ_APIC0)
diff --git a/arch/xtensa/include/asm/dma.h b/arch/xtensa/include/asm/dma.h
index 137ca39..bb099a3 100644
--- a/arch/xtensa/include/asm/dma.h
+++ b/arch/xtensa/include/asm/dma.h
@@ -37,7 +37,7 @@
  *	the size of the statically mapped kernel segment
  *	(XCHAL_KSEG_{CACHED,BYPASS}_SIZE), ie. 128 MB.
  *
- * NOTE: When the entire KSEG area is DMA capable, we substract
+ * NOTE: When the entire KSEG area is DMA capable, we subtract
  *	one from the max address so that the virt_to_phys() macro
  *	works correctly on the address (otherwise the address
  *	enters another area, and virt_to_phys() may not return
diff --git a/arch/xtensa/kernel/entry.S b/arch/xtensa/kernel/entry.S
index 5fd01f6..6223f33 100644
--- a/arch/xtensa/kernel/entry.S
+++ b/arch/xtensa/kernel/entry.S
@@ -1026,7 +1026,7 @@ ENTRY(fast_syscall_unrecoverable)
  * TRY	 adds an entry to the __ex_table fixup table for the immediately
  *	 following instruction.
  *
- * CATCH catches any exception that occurred at one of the preceeding TRY
+ * CATCH catches any exception that occurred at one of the preceding TRY
  *       statements and continues from there
  *
  * Usage TRY	l32i	a0, a1, 0
diff --git a/block/blk-cgroup.c b/block/blk-cgroup.c
index 2bef570..f0605ab 100644
--- a/block/blk-cgroup.c
+++ b/block/blk-cgroup.c
@@ -868,7 +868,7 @@ static void blkio_update_policy_rule(struct blkio_policy_node *oldpn,
 }
 
 /*
- * Some rules/values in blkg have changed. Propogate those to respective
+ * Some rules/values in blkg have changed. Propagate those to respective
  * policies.
  */
 static void blkio_update_blkg_policy(struct blkio_cgroup *blkcg,
@@ -903,7 +903,7 @@ static void blkio_update_blkg_policy(struct blkio_cgroup *blkcg,
 }
 
 /*
- * A policy node rule has been updated. Propogate this update to all the
+ * A policy node rule has been updated. Propagate this update to all the
  * block groups which might be affected by this update.
  */
 static void blkio_update_policy_node_blkg(struct blkio_cgroup *blkcg,
diff --git a/block/blk-core.c b/block/blk-core.c
index 725091d..90f22cc 100644
--- a/block/blk-core.c
+++ b/block/blk-core.c
@@ -1184,7 +1184,7 @@ static bool bio_attempt_front_merge(struct request_queue *q,
 
 /*
  * Attempts to merge with the plugged list in the current process. Returns
- * true if merge was succesful, otherwise false.
+ * true if merge was successful, otherwise false.
  */
 static bool attempt_plug_merge(struct task_struct *tsk, struct request_queue *q,
 			       struct bio *bio)
diff --git a/block/blk-throttle.c b/block/blk-throttle.c
index 6c98cfe..0475a22 100644
--- a/block/blk-throttle.c
+++ b/block/blk-throttle.c
@@ -916,7 +916,7 @@ static void throtl_update_blkio_group_common(struct throtl_data *td,
 /*
  * For all update functions, key should be a valid pointer because these
  * update functions are called under blkcg_lock, that means, blkg is
- * valid and in turn key is valid. queue exit path can not race becuase
+ * valid and in turn key is valid. queue exit path can not race because
  * of blkcg_lock
  *
  * Can not take queue lock in update functions as queue lock under blkcg_lock
diff --git a/block/blk.h b/block/blk.h
index c8db371..6126346 100644
--- a/block/blk.h
+++ b/block/blk.h
@@ -32,7 +32,7 @@ enum rq_atomic_flags {
 
 /*
  * EH timer and IO completion will both attempt to 'grab' the request, make
- * sure that only one of them suceeds
+ * sure that only one of them succeeds
  */
 static inline int blk_mark_rq_complete(struct request *rq)
 {
diff --git a/block/cfq-iosched.c b/block/cfq-iosched.c
index 7785169..3be881e 100644
--- a/block/cfq-iosched.c
+++ b/block/cfq-iosched.c
@@ -888,7 +888,7 @@ cfq_group_notify_queue_add(struct cfq_data *cfqd, struct cfq_group *cfqg)
 	/*
 	 * Currently put the group at the end. Later implement something
 	 * so that groups get lesser vtime based on their weights, so that
-	 * if group does not loose all if it was not continously backlogged.
+	 * if group does not loose all if it was not continuously backlogged.
 	 */
 	n = rb_last(&st->rb);
 	if (n) {
diff --git a/block/genhd.c b/block/genhd.c
index c91a2da..b364bd0 100644
--- a/block/genhd.c
+++ b/block/genhd.c
@@ -739,7 +739,7 @@ void __init printk_all_partitions(void)
 
 		/*
 		 * Don't show empty devices or things that have been
-		 * surpressed
+		 * suppressed
 		 */
 		if (get_capacity(disk) == 0 ||
 		    (disk->flags & GENHD_FL_SUPPRESS_PARTITION_INFO))
diff --git a/crypto/ansi_cprng.c b/crypto/ansi_cprng.c
index 2bc3321..ffa0245 100644
--- a/crypto/ansi_cprng.c
+++ b/crypto/ansi_cprng.c
@@ -83,7 +83,7 @@ static void xor_vectors(unsigned char *in1, unsigned char *in2,
 }
 /*
  * Returns DEFAULT_BLK_SZ bytes of random data per call
- * returns 0 if generation succeded, <0 if something went wrong
+ * returns 0 if generation succeeded, <0 if something went wrong
  */
 static int _get_more_prng_bytes(struct prng_context *ctx, int cont_test)
 {
diff --git a/crypto/async_tx/async_xor.c b/crypto/async_tx/async_xor.c
index 079ae8c..bc28337 100644
--- a/crypto/async_tx/async_xor.c
+++ b/crypto/async_tx/async_xor.c
@@ -94,7 +94,7 @@ do_async_xor(struct dma_chan *chan, struct page *dest, struct page **src_list,
 		if (unlikely(!tx))
 			async_tx_quiesce(&submit->depend_tx);
 
-		/* spin wait for the preceeding transactions to complete */
+		/* spin wait for the preceding transactions to complete */
 		while (unlikely(!tx)) {
 			dma_async_issue_pending(chan);
 			tx = dma->device_prep_dma_xor(chan, dma_dest,
diff --git a/crypto/gf128mul.c b/crypto/gf128mul.c
index a90d260..df35e4c 100644
--- a/crypto/gf128mul.c
+++ b/crypto/gf128mul.c
@@ -89,7 +89,7 @@
 }
 
 /*	Given the value i in 0..255 as the byte overflow when a field element
-    in GHASH is multipled by x^8, this function will return the values that
+    in GHASH is multiplied by x^8, this function will return the values that
     are generated in the lo 16-bit word of the field value by applying the
     modular polynomial. The values lo_byte and hi_byte are returned via the
     macro xp_fun(lo_byte, hi_byte) so that the values can be assembled into
diff --git a/crypto/vmac.c b/crypto/vmac.c
index 0999274..f35ff8a 100644
--- a/crypto/vmac.c
+++ b/crypto/vmac.c
@@ -95,7 +95,7 @@ const u64 mpoly = UINT64_C(0x1fffffff1fffffff);  /* Poly key mask     */
 
 /*
  * For highest performance the L1 NH and L2 polynomial hashes should be
- * carefully implemented to take advantage of one's target architechture.
+ * carefully implemented to take advantage of one's target architecture.
  * Here these two hash functions are defined multiple time; once for
  * 64-bit architectures, once for 32-bit SSE2 architectures, and once
  * for the rest (32-bit) architectures.
diff --git a/crypto/xts.c b/crypto/xts.c
index 555ecaa..8517054 100644
--- a/crypto/xts.c
+++ b/crypto/xts.c
@@ -45,7 +45,7 @@ static int setkey(struct crypto_tfm *parent, const u8 *key,
 		return -EINVAL;
 	}
 
-	/* we need two cipher instances: one to compute the inital 'tweak'
+	/* we need two cipher instances: one to compute the initial 'tweak'
 	 * by encrypting the IV (usually the 'plain' iv) and the other
 	 * one to encrypt and decrypt the data */
 
diff --git a/drivers/acpi/apei/ghes.c b/drivers/acpi/apei/ghes.c
index d1d484d..f703b28 100644
--- a/drivers/acpi/apei/ghes.c
+++ b/drivers/acpi/apei/ghes.c
@@ -241,7 +241,7 @@ static inline int ghes_severity(int severity)
 	case CPER_SEV_FATAL:
 		return GHES_SEV_PANIC;
 	default:
-		/* Unkown, go panic */
+		/* Unknown, go panic */
 		return GHES_SEV_PANIC;
 	}
 }
diff --git a/drivers/acpi/processor_throttling.c b/drivers/acpi/processor_throttling.c
index fa84e97..ad35017 100644
--- a/drivers/acpi/processor_throttling.c
+++ b/drivers/acpi/processor_throttling.c
@@ -1164,7 +1164,7 @@ int acpi_processor_set_throttling(struct acpi_processor *pr,
 			 */
 			if (!match_pr->flags.throttling) {
 				ACPI_DEBUG_PRINT((ACPI_DB_INFO,
-					"Throttling Controll is unsupported "
+					"Throttling Control is unsupported "
 					"on CPU %d\n", i));
 				continue;
 			}
diff --git a/drivers/acpi/video.c b/drivers/acpi/video.c
index 31e9e10..ec574fc 100644
--- a/drivers/acpi/video.c
+++ b/drivers/acpi/video.c
@@ -1354,7 +1354,7 @@ acpi_video_bus_get_devices(struct acpi_video_bus *video,
 		status = acpi_video_bus_get_one_device(dev, video);
 		if (ACPI_FAILURE(status)) {
 			printk(KERN_WARNING PREFIX
-					"Cant attach device\n");
+					"Can't attach device\n");
 			continue;
 		}
 	}
@@ -1373,7 +1373,7 @@ static int acpi_video_bus_put_one_device(struct acpi_video_device *device)
 					    acpi_video_device_notify);
 	if (ACPI_FAILURE(status)) {
 		printk(KERN_WARNING PREFIX
-		       "Cant remove video notify handler\n");
+		       "Can't remove video notify handler\n");
 	}
 	if (device->backlight) {
 		backlight_device_unregister(device->backlight);
diff --git a/drivers/amba/bus.c b/drivers/amba/bus.c
index 6d2bb25..8210405 100644
--- a/drivers/amba/bus.c
+++ b/drivers/amba/bus.c
@@ -760,7 +760,7 @@ int amba_request_regions(struct amba_device *dev, const char *name)
 }
 
 /**
- *	amba_release_regions - release mem regions assoicated with device
+ *	amba_release_regions - release mem regions associated with device
  *	@dev: amba_device structure for device
  *
  *	Release regions claimed by a successful call to amba_request_regions.
diff --git a/drivers/ata/ahci.c b/drivers/ata/ahci.c
index e62f693..39d829c 100644
--- a/drivers/ata/ahci.c
+++ b/drivers/ata/ahci.c
@@ -926,7 +926,7 @@ static bool ahci_broken_suspend(struct pci_dev *pdev)
 		/*
 		 * Acer eMachines G725 has the same problem.  BIOS
 		 * V1.03 is known to be broken.  V3.04 is known to
-		 * work.  Inbetween, there are V1.06, V2.06 and V3.03
+		 * work.  Between, there are V1.06, V2.06 and V3.03
 		 * that we don't have much idea about.  For now,
 		 * blacklist anything older than V3.04.
 		 *
diff --git a/drivers/ata/ahci.h b/drivers/ata/ahci.h
index ccaf081..3986500 100644
--- a/drivers/ata/ahci.h
+++ b/drivers/ata/ahci.h
@@ -225,7 +225,7 @@ enum {
 	/* em_ctl bits */
 	EM_CTL_RST		= (1 << 9), /* Reset */
 	EM_CTL_TM		= (1 << 8), /* Transmit Message */
-	EM_CTL_MR		= (1 << 0), /* Message Recieved */
+	EM_CTL_MR		= (1 << 0), /* Message Received */
 	EM_CTL_ALHD		= (1 << 26), /* Activity LED */
 	EM_CTL_XMT		= (1 << 25), /* Transmit Only */
 	EM_CTL_SMB		= (1 << 24), /* Single Message Buffer */
@@ -281,7 +281,7 @@ struct ahci_port_priv {
 };
 
 struct ahci_host_priv {
-	void __iomem *		mmio;		/* bus-independant mem map */
+	void __iomem *		mmio;		/* bus-independent mem map */
 	unsigned int		flags;		/* AHCI_HFLAG_* */
 	u32			cap;		/* cap to use */
 	u32			cap2;		/* cap2 to use */
diff --git a/drivers/ata/ata_piix.c b/drivers/ata/ata_piix.c
index cdec4ab..0bc3fd6 100644
--- a/drivers/ata/ata_piix.c
+++ b/drivers/ata/ata_piix.c
@@ -38,16 +38,16 @@
  *  Hardware documentation available at http://developer.intel.com/
  *
  * Documentation
- *	Publically available from Intel web site. Errata documentation
- * is also publically available. As an aide to anyone hacking on this
+ *	Publicly available from Intel web site. Errata documentation
+ * is also publicly available. As an aide to anyone hacking on this
  * driver the list of errata that are relevant is below, going back to
  * PIIX4. Older device documentation is now a bit tricky to find.
  *
  * The chipsets all follow very much the same design. The original Triton
- * series chipsets do _not_ support independant device timings, but this
+ * series chipsets do _not_ support independent device timings, but this
  * is fixed in Triton II. With the odd mobile exception the chips then
  * change little except in gaining more modes until SATA arrives. This
- * driver supports only the chips with independant timing (that is those
+ * driver supports only the chips with independent timing (that is those
  * with SITRE and the 0x44 timing register). See pata_oldpiix and pata_mpiix
  * for the early chip drivers.
  *
@@ -122,7 +122,7 @@ enum {
 	P2			= 2,  /* port 2 */
 	P3			= 3,  /* port 3 */
 	IDE			= -1, /* IDE */
-	NA			= -2, /* not avaliable */
+	NA			= -2, /* not available */
 	RV			= -3, /* reserved */
 
 	PIIX_AHCI_DEVICE	= 6,
diff --git a/drivers/ata/libata-core.c b/drivers/ata/libata-core.c
index b91e19c..423c0a6 100644
--- a/drivers/ata/libata-core.c
+++ b/drivers/ata/libata-core.c
@@ -5340,7 +5340,7 @@ int ata_host_suspend(struct ata_host *host, pm_message_t mesg)
  *
  *	Resume @host.  Actual operation is performed by EH.  This
  *	function requests EH to perform PM operations and returns.
- *	Note that all resume operations are performed parallely.
+ *	Note that all resume operations are performed parallelly.
  *
  *	LOCKING:
  *	Kernel thread context (may sleep).
diff --git a/drivers/ata/libata-eh.c b/drivers/ata/libata-eh.c
index df3f314..88cd22f 100644
--- a/drivers/ata/libata-eh.c
+++ b/drivers/ata/libata-eh.c
@@ -771,7 +771,7 @@ void ata_scsi_port_error_handler(struct Scsi_Host *host, struct ata_port *ap)
 		/* process port suspend request */
 		ata_eh_handle_port_suspend(ap);
 
-		/* Exception might have happend after ->error_handler
+		/* Exception might have happened after ->error_handler
 		 * recovered the port but before this point.  Repeat
 		 * EH in such case.
 		 */
@@ -1742,7 +1742,7 @@ void ata_eh_analyze_ncq_error(struct ata_link *link)
  *
  *	Analyze taskfile of @qc and further determine cause of
  *	failure.  This function also requests ATAPI sense data if
- *	avaliable.
+ *	available.
  *
  *	LOCKING:
  *	Kernel thread context (may sleep).
@@ -1893,7 +1893,7 @@ static int speed_down_verdict_cb(struct ata_ering_entry *ent, void *void_arg)
  *	   occurred during last 5 mins, NCQ_OFF.
  *
  *	3. If more than 8 ATA_BUS, TOUT_HSM or UNK_DEV errors
- *	   ocurred during last 5 mins, FALLBACK_TO_PIO
+ *	   occurred during last 5 mins, FALLBACK_TO_PIO
  *
  *	4. If more than 3 TOUT_HSM or UNK_DEV errors occurred
  *	   during last 10 mins, NCQ_OFF.
@@ -2577,7 +2577,7 @@ int ata_eh_reset(struct ata_link *link, int classify,
 	if (link->flags & ATA_LFLAG_NO_SRST)
 		softreset = NULL;
 
-	/* make sure each reset attemp is at least COOL_DOWN apart */
+	/* make sure each reset attempt is at least COOL_DOWN apart */
 	if (ehc->i.flags & ATA_EHI_DID_RESET) {
 		now = jiffies;
 		WARN_ON(time_after(ehc->last_reset, now));
@@ -2736,7 +2736,7 @@ int ata_eh_reset(struct ata_link *link, int classify,
 			if (!reset) {
 				ata_link_printk(link, KERN_ERR,
 						"follow-up softreset required "
-						"but no softreset avaliable\n");
+						"but no softreset available\n");
 				failed_link = link;
 				rc = -EINVAL;
 				goto fail;
diff --git a/drivers/ata/libata-scsi.c b/drivers/ata/libata-scsi.c
index a834199..e2f57e9e 100644
--- a/drivers/ata/libata-scsi.c
+++ b/drivers/ata/libata-scsi.c
@@ -999,7 +999,7 @@ static void ata_gen_passthru_sense(struct ata_queued_cmd *qc)
  *	@qc: Command that we are erroring out
  *
  *	Generate sense block for a failed ATA command @qc.  Descriptor
- *	format is used to accomodate LBA48 block address.
+ *	format is used to accommodate LBA48 block address.
  *
  *	LOCKING:
  *	None.
diff --git a/drivers/ata/libata-sff.c b/drivers/ata/libata-sff.c
index cf7acbc..f8380ce 100644
--- a/drivers/ata/libata-sff.c
+++ b/drivers/ata/libata-sff.c
@@ -2839,7 +2839,7 @@ unsigned int ata_bmdma_port_intr(struct ata_port *ap, struct ata_queued_cmd *qc)
 		bmdma_stopped = true;
 
 		if (unlikely(host_stat & ATA_DMA_ERR)) {
-			/* error when transfering data to/from memory */
+			/* error when transferring data to/from memory */
 			qc->err_mask |= AC_ERR_HOST_BUS;
 			ap->hsm_task_state = HSM_ST_ERR;
 		}
@@ -3032,7 +3032,7 @@ void ata_bmdma_start(struct ata_queued_cmd *qc)
 	 * Or maybe I'm just being paranoid.
 	 *
 	 * FIXME: The posting of this write means I/O starts are
-	 * unneccessarily delayed for MMIO
+	 * unnecessarily delayed for MMIO
 	 */
 }
 EXPORT_SYMBOL_GPL(ata_bmdma_start);
diff --git a/drivers/ata/pata_amd.c b/drivers/ata/pata_amd.c
index 620a07c..b0975a5 100644
--- a/drivers/ata/pata_amd.c
+++ b/drivers/ata/pata_amd.c
@@ -11,7 +11,7 @@
  *	Power management on ports
  *
  *
- *  Documentation publically available.
+ *  Documentation publicly available.
  */
 
 #include <linux/kernel.h>
diff --git a/drivers/ata/pata_arasan_cf.c b/drivers/ata/pata_arasan_cf.c
index 65cee74..719bb73 100644
--- a/drivers/ata/pata_arasan_cf.c
+++ b/drivers/ata/pata_arasan_cf.c
@@ -385,7 +385,7 @@ static inline int wait4buf(struct arasan_cf_dev *acdev)
 		return -ETIMEDOUT;
 	}
 
-	/* Check if PIO Error interrupt has occured */
+	/* Check if PIO Error interrupt has occurred */
 	if (acdev->dma_status & ATA_DMA_ERR)
 		return -EAGAIN;
 
@@ -450,7 +450,7 @@ static int sg_xfer(struct arasan_cf_dev *acdev, struct scatterlist *sg)
 	/*
 	 * For each sg:
 	 * MAX_XFER_COUNT data will be transferred before we get transfer
-	 * complete interrupt. Inbetween after FIFO_SIZE data
+	 * complete interrupt. Between after FIFO_SIZE data
 	 * buffer available interrupt will be generated. At this time we will
 	 * fill FIFO again: max FIFO_SIZE data.
 	 */
@@ -463,7 +463,7 @@ static int sg_xfer(struct arasan_cf_dev *acdev, struct scatterlist *sg)
 				acdev->vbase + XFER_CTR);
 		spin_unlock_irqrestore(&acdev->host->lock, flags);
 
-		/* continue dma xfers untill current sg is completed */
+		/* continue dma xfers until current sg is completed */
 		while (xfer_cnt) {
 			/* wait for read to complete */
 			if (!write) {
@@ -563,7 +563,7 @@ static void data_xfer(struct work_struct *work)
 
 chan_request_fail:
 	spin_lock_irqsave(&acdev->host->lock, flags);
-	/* error when transfering data to/from memory */
+	/* error when transferring data to/from memory */
 	qc->err_mask |= AC_ERR_HOST_BUS;
 	qc->ap->hsm_task_state = HSM_ST_ERR;
 
diff --git a/drivers/ata/pata_bf54x.c b/drivers/ata/pata_bf54x.c
index e0b58b8..ea64967 100644
--- a/drivers/ata/pata_bf54x.c
+++ b/drivers/ata/pata_bf54x.c
@@ -1342,7 +1342,7 @@ static unsigned int bfin_ata_host_intr(struct ata_port *ap,
 			ap->ops->bmdma_stop(qc);
 
 			if (unlikely(host_stat & ATA_DMA_ERR)) {
-				/* error when transfering data to/from memory */
+				/* error when transferring data to/from memory */
 				qc->err_mask |= AC_ERR_HOST_BUS;
 				ap->hsm_task_state = HSM_ST_ERR;
 			}
diff --git a/drivers/ata/pata_cs5520.c b/drivers/ata/pata_cs5520.c
index 030952f..e3254fc 100644
--- a/drivers/ata/pata_cs5520.c
+++ b/drivers/ata/pata_cs5520.c
@@ -29,7 +29,7 @@
  * General Public License for more details.
  *
  * Documentation:
- *	Not publically available.
+ *	Not publicly available.
  */
 #include <linux/kernel.h>
 #include <linux/module.h>
diff --git a/drivers/ata/pata_mpiix.c b/drivers/ata/pata_mpiix.c
index b21f002..d8d9c58 100644
--- a/drivers/ata/pata_mpiix.c
+++ b/drivers/ata/pata_mpiix.c
@@ -15,7 +15,7 @@
  * with PCI IDE and also that we do not disable the device when our driver is
  * unloaded (as it has many other functions).
  *
- * The driver conciously keeps this logic internally to avoid pushing quirky
+ * The driver consciously keeps this logic internally to avoid pushing quirky
  * PATA history into the clean libata layer.
  *
  * Thinkpad specific note: If you boot an MPIIX using a thinkpad with a PCMCIA
diff --git a/drivers/ata/pata_rz1000.c b/drivers/ata/pata_rz1000.c
index 4a454a8..4d04471 100644
--- a/drivers/ata/pata_rz1000.c
+++ b/drivers/ata/pata_rz1000.c
@@ -112,7 +112,7 @@ static int rz1000_reinit_one(struct pci_dev *pdev)
 	if (rc)
 		return rc;
 
-	/* If this fails on resume (which is a "cant happen" case), we
+	/* If this fails on resume (which is a "can't happen" case), we
 	   must stop as any progress risks data loss */
 	if (rz1000_fifo_disable(pdev))
 		panic("rz1000 fifo");
diff --git a/drivers/ata/pata_sil680.c b/drivers/ata/pata_sil680.c
index 00eefbd..118787c 100644
--- a/drivers/ata/pata_sil680.c
+++ b/drivers/ata/pata_sil680.c
@@ -11,7 +11,7 @@
  *
  *  May be copied or modified under the terms of the GNU General Public License
  *
- *  Documentation publically available.
+ *  Documentation publicly available.
  *
  *	If you have strange problems with nVidia chipset systems please
  *	see the SI support documentation and update your system BIOS
@@ -43,7 +43,7 @@
  *
  *	Turn a config register offset into the right address in either
  *	PCI space or MMIO space to access the control register in question
- *	Thankfully this is a configuration operation so isnt performance
+ *	Thankfully this is a configuration operation so isn't performance
  *	criticial.
  */
 
diff --git a/drivers/ata/pata_sis.c b/drivers/ata/pata_sis.c
index c04abc3..be08ff9 100644
--- a/drivers/ata/pata_sis.c
+++ b/drivers/ata/pata_sis.c
@@ -331,7 +331,7 @@ static void sis_old_set_dmamode (struct ata_port *ap, struct ata_device *adev)
 
 	if (adev->dma_mode < XFER_UDMA_0) {
 		/* bits 3-0 hold recovery timing bits 8-10 active timing and
-		   the higher bits are dependant on the device */
+		   the higher bits are dependent on the device */
 		timing &= ~0x870F;
 		timing |= mwdma_bits[speed];
 	} else {
@@ -371,7 +371,7 @@ static void sis_66_set_dmamode (struct ata_port *ap, struct ata_device *adev)
 
 	if (adev->dma_mode < XFER_UDMA_0) {
 		/* bits 3-0 hold recovery timing bits 8-10 active timing and
-		   the higher bits are dependant on the device, bit 15 udma */
+		   the higher bits are dependent on the device, bit 15 udma */
 		timing &= ~0x870F;
 		timing |= mwdma_bits[speed];
 	} else {
diff --git a/drivers/ata/pata_triflex.c b/drivers/ata/pata_triflex.c
index 0d1f89e..03b6d69 100644
--- a/drivers/ata/pata_triflex.c
+++ b/drivers/ata/pata_triflex.c
@@ -30,7 +30,7 @@
  * Loosely based on the piix & svwks drivers.
  *
  * Documentation:
- *	Not publically available.
+ *	Not publicly available.
  */
 
 #include <linux/kernel.h>
diff --git a/drivers/ata/sata_fsl.c b/drivers/ata/sata_fsl.c
index 0f91e58..35a71d8 100644
--- a/drivers/ata/sata_fsl.c
+++ b/drivers/ata/sata_fsl.c
@@ -42,7 +42,7 @@ enum {
 
 	/*
 	 * SATA-FSL host controller supports a max. of (15+1) direct PRDEs, and
-	 * chained indirect PRDEs upto a max count of 63.
+	 * chained indirect PRDEs up to a max count of 63.
 	 * We are allocating an array of 63 PRDEs contiguously, but PRDE#15 will
 	 * be setup as an indirect descriptor, pointing to it's next
 	 * (contiguous) PRDE. Though chained indirect PRDE arrays are
@@ -907,7 +907,7 @@ static int sata_fsl_softreset(struct ata_link *link, unsigned int *class,
 	ata_msleep(ap, 1);
 
 	/*
-	 * SATA device enters reset state after receving a Control register
+	 * SATA device enters reset state after receiving a Control register
 	 * FIS with SRST bit asserted and it awaits another H2D Control reg.
 	 * FIS with SRST bit cleared, then the device does internal diags &
 	 * initialization, followed by indicating it's initialization status
diff --git a/drivers/ata/sata_mv.c b/drivers/ata/sata_mv.c
index cd40651..b52c051 100644
--- a/drivers/ata/sata_mv.c
+++ b/drivers/ata/sata_mv.c
@@ -1352,7 +1352,7 @@ static int mv_scr_write(struct ata_link *link, unsigned int sc_reg_in, u32 val)
 			/*
 			 * Workaround for 88SX60x1 FEr SATA#26:
 			 *
-			 * COMRESETs have to take care not to accidently
+			 * COMRESETs have to take care not to accidentally
 			 * put the drive to sleep when writing SCR_CONTROL.
 			 * Setting bits 12..15 prevents this problem.
 			 *
@@ -2044,7 +2044,7 @@ static void mv_qc_prep(struct ata_queued_cmd *qc)
 
 	cw = &pp->crqb[in_index].ata_cmd[0];
 
-	/* Sadly, the CRQB cannot accomodate all registers--there are
+	/* Sadly, the CRQB cannot accommodate all registers--there are
 	 * only 11 bytes...so we must pick and choose required
 	 * registers based on the command.  So, we drop feature and
 	 * hob_feature for [RW] DMA commands, but they are needed for
diff --git a/drivers/ata/sata_nv.c b/drivers/ata/sata_nv.c
index 42344e3..f173ef3 100644
--- a/drivers/ata/sata_nv.c
+++ b/drivers/ata/sata_nv.c
@@ -2121,7 +2121,7 @@ static int nv_swncq_sdbfis(struct ata_port *ap)
 
 	host_stat = ap->ops->bmdma_status(ap);
 	if (unlikely(host_stat & ATA_DMA_ERR)) {
-		/* error when transfering data to/from memory */
+		/* error when transferring data to/from memory */
 		ata_ehi_clear_desc(ehi);
 		ata_ehi_push_desc(ehi, "BMDMA stat 0x%x", host_stat);
 		ehi->err_mask |= AC_ERR_HOST_BUS;
diff --git a/drivers/ata/sata_via.c b/drivers/ata/sata_via.c
index 21242c5..54434db 100644
--- a/drivers/ata/sata_via.c
+++ b/drivers/ata/sata_via.c
@@ -582,7 +582,7 @@ static void svia_configure(struct pci_dev *pdev, int board_id)
 	 * When host issues HOLD, device may send up to 20DW of data
 	 * before acknowledging it with HOLDA and the host should be
 	 * able to buffer them in FIFO.  Unfortunately, some WD drives
-	 * send upto 40DW before acknowledging HOLD and, in the
+	 * send up to 40DW before acknowledging HOLD and, in the
 	 * default configuration, this ends up overflowing vt6421's
 	 * FIFO, making the controller abort the transaction with
 	 * R_ERR.
diff --git a/drivers/atm/ambassador.c b/drivers/atm/ambassador.c
index 9f47e86..a5fcb1e 100644
--- a/drivers/atm/ambassador.c
+++ b/drivers/atm/ambassador.c
@@ -497,7 +497,7 @@ static void rx_complete (amb_dev * dev, rx_out * rx) {
 	  // VC layer stats
 	  atomic_inc(&atm_vcc->stats->rx);
 	  __net_timestamp(skb);
-	  // end of our responsability
+	  // end of our responsibility
 	  atm_vcc->push (atm_vcc, skb);
 	  return;
 	  
diff --git a/drivers/atm/firestream.c b/drivers/atm/firestream.c
index 049650d..ef7a658 100644
--- a/drivers/atm/firestream.c
+++ b/drivers/atm/firestream.c
@@ -1782,7 +1782,7 @@ static int __devinit fs_init (struct fs_dev *dev)
 		write_fs (dev, RAS0, RAS0_DCD_XHLT 
 			  | (((1 << FS155_VPI_BITS) - 1) * RAS0_VPSEL)
 			  | (((1 << FS155_VCI_BITS) - 1) * RAS0_VCSEL));
-		/* We can chose the split arbitarily. We might be able to 
+		/* We can chose the split arbitrarily. We might be able to 
 		   support more. Whatever. This should do for now. */
 		dev->atm_dev->ci_range.vpi_bits = FS155_VPI_BITS;
 		dev->atm_dev->ci_range.vci_bits = FS155_VCI_BITS;
diff --git a/drivers/atm/fore200e.h b/drivers/atm/fore200e.h
index 7f97c09..ba34a02 100644
--- a/drivers/atm/fore200e.h
+++ b/drivers/atm/fore200e.h
@@ -263,7 +263,7 @@ typedef enum opcode {
 } opcode_t;
 
 
-/* virtual path / virtual channel identifers */
+/* virtual path / virtual channel identifiers */
 
 typedef struct vpvc {
     BITFIELD3(
@@ -926,7 +926,7 @@ typedef struct fore200e_vcc {
 
 #define PCA200E_PCI_LATENCY      0x40    /* maximum slave latenty            */
 #define PCA200E_PCI_MASTER_CTRL  0x41    /* master control                   */
-#define PCA200E_PCI_THRESHOLD    0x42    /* burst / continous req threshold  */
+#define PCA200E_PCI_THRESHOLD    0x42    /* burst / continuous req threshold  */
 
 /* PBI master control register */
 
diff --git a/drivers/atm/horizon.c b/drivers/atm/horizon.c
index 24761e1..d58e3fc 100644
--- a/drivers/atm/horizon.c
+++ b/drivers/atm/horizon.c
@@ -169,13 +169,13 @@ static inline void __init show_version (void) {
   Real Time (cdv and max CDT given)
   
   CBR(pcr)             pcr bandwidth always available
-  rtVBR(pcr,scr,mbs)   scr bandwidth always available, upto pcr at mbs too
+  rtVBR(pcr,scr,mbs)   scr bandwidth always available, up to pcr at mbs too
   
   Non Real Time
   
-  nrtVBR(pcr,scr,mbs)  scr bandwidth always available, upto pcr at mbs too
+  nrtVBR(pcr,scr,mbs)  scr bandwidth always available, up to pcr at mbs too
   UBR()
-  ABR(mcr,pcr)         mcr bandwidth always available, upto pcr (depending) too
+  ABR(mcr,pcr)         mcr bandwidth always available, up to pcr (depending) too
   
   mbs is max burst size (bucket)
   pcr and scr have associated cdvt values
@@ -944,7 +944,7 @@ static void hrz_close_rx (hrz_dev * dev, u16 vc) {
 // to be fixed soon, so do not define TAILRECUSRIONWORKS unless you
 // are sure it does as you may otherwise overflow the kernel stack.
 
-// giving this fn a return value would help GCC, alledgedly
+// giving this fn a return value would help GCC, allegedly
 
 static void rx_schedule (hrz_dev * dev, int irq) {
   unsigned int rx_bytes;
@@ -1036,7 +1036,7 @@ static void rx_schedule (hrz_dev * dev, int irq) {
 	  // VC layer stats
 	  atomic_inc(&vcc->stats->rx);
 	  __net_timestamp(skb);
-	  // end of our responsability
+	  // end of our responsibility
 	  vcc->push (vcc, skb);
 	}
       }
diff --git a/drivers/atm/idt77252.c b/drivers/atm/idt77252.c
index bfb7fee..048f99f 100644
--- a/drivers/atm/idt77252.c
+++ b/drivers/atm/idt77252.c
@@ -3495,7 +3495,7 @@ init_card(struct atm_dev *dev)
 		return -1;
 	}
 	if (dev->phy->ioctl == NULL) {
-		printk("%s: LT had no IOCTL funtion defined.\n", card->name);
+		printk("%s: LT had no IOCTL function defined.\n", card->name);
 		deinit_card(card);
 		return -1;
 	}
diff --git a/drivers/atm/idt77252.h b/drivers/atm/idt77252.h
index f53a43a..3a82cc2 100644
--- a/drivers/atm/idt77252.h
+++ b/drivers/atm/idt77252.h
@@ -766,7 +766,7 @@ struct idt77252_dev
 #define SAR_RCTE_BUFFSTAT_MASK 0x00003000  /* buffer status                  */
 #define SAR_RCTE_EFCI          0x00000800  /* EFCI Congestion flag           */
 #define SAR_RCTE_CLP           0x00000400  /* Cell Loss Priority flag        */
-#define SAR_RCTE_CRC           0x00000200  /* Recieved CRC Error             */
+#define SAR_RCTE_CRC           0x00000200  /* Received CRC Error             */
 #define SAR_RCTE_CELLCNT_MASK  0x000001FF  /* cell Count                     */
 
 #define SAR_RCTE_AAL0          0x00000000  /* AAL types for ALL field        */
diff --git a/drivers/atm/iphase.c b/drivers/atm/iphase.c
index d80d51b..1c674a9 100644
--- a/drivers/atm/iphase.c
+++ b/drivers/atm/iphase.c
@@ -1025,7 +1025,7 @@ static void desc_dbg(IADEV *iadev) {
 } 
   
   
-/*----------------------------- Recieving side stuff --------------------------*/  
+/*----------------------------- Receiving side stuff --------------------------*/  
  
 static void rx_excp_rcvd(struct atm_dev *dev)  
 {  
@@ -1195,7 +1195,7 @@ static void rx_intr(struct atm_dev *dev)
   if (status & RX_PKT_RCVD)  
   {  
 	/* do something */  
-	/* Basically recvd an interrupt for receving a packet.  
+	/* Basically recvd an interrupt for receiving a packet.  
 	A descriptor would have been written to the packet complete   
 	queue. Get all the descriptors and set up dma to move the   
 	packets till the packet complete queue is empty..  
@@ -1855,7 +1855,7 @@ static int open_tx(struct atm_vcc *vcc)
                     return -EINVAL; 
                 }
                 if (vcc->qos.txtp.max_pcr > iadev->LineRate) {
-                   IF_CBR(printk("PCR is not availble\n");)
+                   IF_CBR(printk("PCR is not available\n");)
                    return -1;
                 }
                 vc->type = CBR;
diff --git a/drivers/atm/lanai.c b/drivers/atm/lanai.c
index 52880c8..4e8ba56 100644
--- a/drivers/atm/lanai.c
+++ b/drivers/atm/lanai.c
@@ -1255,7 +1255,7 @@ static inline void lanai_endtx(struct lanai_dev *lanai,
 	/*
 	 * Since the "butt register" is a shared resounce on the card we
 	 * serialize all accesses to it through this spinlock.  This is
-	 * mostly just paranoia sicne the register is rarely "busy" anyway
+	 * mostly just paranoia since the register is rarely "busy" anyway
 	 * but is needed for correctness.
 	 */
 	spin_lock(&lanai->endtxlock);
@@ -1990,7 +1990,7 @@ static int __devinit lanai_pci_start(struct lanai_dev *lanai)
 
 /*
  * We _can_ use VCI==0 for normal traffic, but only for UBR (or we'll
- * get a CBRZERO interrupt), and we can use it only if noone is receiving
+ * get a CBRZERO interrupt), and we can use it only if no one is receiving
  * AAL0 traffic (since they will use the same queue) - according to the
  * docs we shouldn't even use it for AAL0 traffic
  */
diff --git a/drivers/auxdisplay/cfag12864b.c b/drivers/auxdisplay/cfag12864b.c
index 4975859..41ce4bd 100644
--- a/drivers/auxdisplay/cfag12864b.c
+++ b/drivers/auxdisplay/cfag12864b.c
@@ -49,7 +49,7 @@
 static unsigned int cfag12864b_rate = CONFIG_CFAG12864B_RATE;
 module_param(cfag12864b_rate, uint, S_IRUGO);
 MODULE_PARM_DESC(cfag12864b_rate,
-	"Refresh rate (hertzs)");
+	"Refresh rate (hertz)");
 
 unsigned int cfag12864b_getrate(void)
 {
@@ -60,7 +60,7 @@ unsigned int cfag12864b_getrate(void)
  * cfag12864b Commands
  *
  *	E = Enable signal
- *		Everytime E switch from low to high,
+ *		Every time E switch from low to high,
  *		cfag12864b/ks0108 reads the command/data.
  *
  *	CS1 = First ks0108controller.
diff --git a/drivers/base/power/runtime.c b/drivers/base/power/runtime.c
index 54597c8..3172c60 100644
--- a/drivers/base/power/runtime.c
+++ b/drivers/base/power/runtime.c
@@ -443,7 +443,7 @@ static int rpm_suspend(struct device *dev, int rpmflags)
  *
  * Check if the device's run-time PM status allows it to be resumed.  Cancel
  * any scheduled or pending requests.  If another resume has been started
- * earlier, either return imediately or wait for it to finish, depending on the
+ * earlier, either return immediately or wait for it to finish, depending on the
  * RPM_NOWAIT and RPM_ASYNC flags.  Similarly, if there's a suspend running in
  * parallel with this function, either tell the other process to resume after
  * suspending (deferred_resume) or wait for it to finish.  If the RPM_ASYNC
diff --git a/drivers/base/sys.c b/drivers/base/sys.c
index fbe72da..acde9b5 100644
--- a/drivers/base/sys.c
+++ b/drivers/base/sys.c
@@ -197,7 +197,7 @@ kset_put:
 }
 
 /**
- *	sysdev_driver_register - Register auxillary driver
+ *	sysdev_driver_register - Register auxiliary driver
  *	@cls:	Device class driver belongs to.
  *	@drv:	Driver.
  *
@@ -250,7 +250,7 @@ unlock:
 }
 
 /**
- *	sysdev_driver_unregister - Remove an auxillary driver.
+ *	sysdev_driver_unregister - Remove an auxiliary driver.
  *	@cls:	Class driver belongs to.
  *	@drv:	Driver.
  */
@@ -302,7 +302,7 @@ int sysdev_register(struct sys_device *sysdev)
 		 * code that should have called us.
 		 */
 
-		/* Notify class auxillary drivers */
+		/* Notify class auxiliary drivers */
 		list_for_each_entry(drv, &cls->drivers, entry) {
 			if (drv->add)
 				drv->add(sysdev);
@@ -335,7 +335,7 @@ void sysdev_unregister(struct sys_device *sysdev)
  *
  *	Loop over each class of system devices, and the devices in each
  *	of those classes. For each device, we call the shutdown method for
- *	each driver registered for the device - the auxillaries,
+ *	each driver registered for the device - the auxiliaries,
  *	and the class driver.
  *
  *	Note: The list is iterated in reverse order, so that we shut down
@@ -360,7 +360,7 @@ void sysdev_shutdown(void)
 			struct sysdev_driver *drv;
 			pr_debug(" %s\n", kobject_name(&sysdev->kobj));
 
-			/* Call auxillary drivers first */
+			/* Call auxiliary drivers first */
 			list_for_each_entry(drv, &cls->drivers, entry) {
 				if (drv->shutdown)
 					drv->shutdown(sysdev);
@@ -385,7 +385,7 @@ static void __sysdev_resume(struct sys_device *dev)
 	WARN_ONCE(!irqs_disabled(),
 		"Interrupts enabled after %pF\n", cls->resume);
 
-	/* Call auxillary drivers next. */
+	/* Call auxiliary drivers next. */
 	list_for_each_entry(drv, &cls->drivers, entry) {
 		if (drv->resume)
 			drv->resume(dev);
@@ -432,7 +432,7 @@ int sysdev_suspend(pm_message_t state)
 		list_for_each_entry(sysdev, &cls->kset.list, kobj.entry) {
 			pr_debug(" %s\n", kobject_name(&sysdev->kobj));
 
-			/* Call auxillary drivers first */
+			/* Call auxiliary drivers first */
 			list_for_each_entry(drv, &cls->drivers, entry) {
 				if (drv->suspend) {
 					ret = drv->suspend(sysdev, state);
diff --git a/drivers/block/DAC960.c b/drivers/block/DAC960.c
index 7988210..8066d08 100644
--- a/drivers/block/DAC960.c
+++ b/drivers/block/DAC960.c
@@ -1790,7 +1790,7 @@ static bool DAC960_V2_ReadControllerConfiguration(DAC960_Controller_T
   unsigned short LogicalDeviceNumber = 0;
   int ModelNameLength;
 
-  /* Get data into dma-able area, then copy into permanant location */
+  /* Get data into dma-able area, then copy into permanent location */
   if (!DAC960_V2_NewControllerInfo(Controller))
     return DAC960_Failure(Controller, "GET CONTROLLER INFO");
   memcpy(ControllerInfo, Controller->V2.NewControllerInformation,
diff --git a/drivers/block/drbd/drbd_actlog.c b/drivers/block/drbd/drbd_actlog.c
index 2a1642b..c6828b6 100644
--- a/drivers/block/drbd/drbd_actlog.c
+++ b/drivers/block/drbd/drbd_actlog.c
@@ -30,7 +30,7 @@
 
 /* We maintain a trivial check sum in our on disk activity log.
  * With that we can ensure correct operation even when the storage
- * device might do a partial (last) sector write while loosing power.
+ * device might do a partial (last) sector write while losing power.
  */
 struct __packed al_transaction {
 	u32       magic;
diff --git a/drivers/block/drbd/drbd_int.h b/drivers/block/drbd/drbd_int.h
index 81030d8..b2699bb 100644
--- a/drivers/block/drbd/drbd_int.h
+++ b/drivers/block/drbd/drbd_int.h
@@ -622,7 +622,7 @@ DCBP_set_pad_bits(struct p_compressed_bm *p, int n)
 /* one bitmap packet, including the p_header,
  * should fit within one _architecture independend_ page.
  * so we need to use the fixed size 4KiB page size
- * most architechtures have used for a long time.
+ * most architectures have used for a long time.
  */
 #define BM_PACKET_PAYLOAD_BYTES (4096 - sizeof(struct p_header80))
 #define BM_PACKET_WORDS (BM_PACKET_PAYLOAD_BYTES/sizeof(long))
@@ -810,7 +810,7 @@ enum {
 
 /* global flag bits */
 enum {
-	CREATE_BARRIER,		/* next P_DATA is preceeded by a P_BARRIER */
+	CREATE_BARRIER,		/* next P_DATA is preceded by a P_BARRIER */
 	SIGNAL_ASENDER,		/* whether asender wants to be interrupted */
 	SEND_PING,		/* whether asender should send a ping asap */
 
@@ -1126,7 +1126,7 @@ struct drbd_conf {
 	int c_sync_rate; /* current resync rate after syncer throttle magic */
 	struct fifo_buffer rs_plan_s; /* correction values of resync planer */
 	int rs_in_flight; /* resync sectors in flight (to proxy, in proxy and from proxy) */
-	int rs_planed;    /* resync sectors already planed */
+	int rs_planed;    /* resync sectors already planned */
 	atomic_t ap_in_flight; /* App sectors in flight (waiting for ack) */
 };
 
@@ -1144,7 +1144,7 @@ static inline unsigned int mdev_to_minor(struct drbd_conf *mdev)
 	return mdev->minor;
 }
 
-/* returns 1 if it was successfull,
+/* returns 1 if it was successful,
  * returns 0 if there was no data socket.
  * so wherever you are going to use the data.socket, e.g. do
  * if (!drbd_get_data_sock(mdev))
@@ -2079,7 +2079,7 @@ static inline void inc_ap_pending(struct drbd_conf *mdev)
 /* counts how many resync-related answers we still expect from the peer
  *		     increase			decrease
  * C_SYNC_TARGET sends P_RS_DATA_REQUEST (and expects P_RS_DATA_REPLY)
- * C_SYNC_SOURCE sends P_RS_DATA_REPLY   (and expects P_WRITE_ACK whith ID_SYNCER)
+ * C_SYNC_SOURCE sends P_RS_DATA_REPLY   (and expects P_WRITE_ACK with ID_SYNCER)
  *					   (or P_NEG_ACK with ID_SYNCER)
  */
 static inline void inc_rs_pending(struct drbd_conf *mdev)
diff --git a/drivers/block/drbd/drbd_main.c b/drivers/block/drbd/drbd_main.c
index dfc85f3..5b525c1 100644
--- a/drivers/block/drbd/drbd_main.c
+++ b/drivers/block/drbd/drbd_main.c
@@ -1561,7 +1561,7 @@ static void after_state_ch(struct drbd_conf *mdev, union drbd_state os,
 		if (drbd_send_state(mdev))
 			dev_warn(DEV, "Notified peer that I'm now diskless.\n");
 		/* corresponding get_ldev in __drbd_set_state
-		 * this may finaly trigger drbd_ldev_destroy. */
+		 * this may finally trigger drbd_ldev_destroy. */
 		put_ldev(mdev);
 	}
 
@@ -3706,7 +3706,7 @@ int drbd_md_read(struct drbd_conf *mdev, struct drbd_backing_dev *bdev)
 	buffer = (struct meta_data_on_disk *)page_address(mdev->md_io_page);
 
 	if (!drbd_md_sync_page_io(mdev, bdev, bdev->md.md_offset, READ)) {
-		/* NOTE: cant do normal error processing here as this is
+		/* NOTE: can't do normal error processing here as this is
 		   called BEFORE disk is attached */
 		dev_err(DEV, "Error while reading metadata.\n");
 		rv = ERR_IO_MD_DISK;
diff --git a/drivers/block/drbd/drbd_receiver.c b/drivers/block/drbd/drbd_receiver.c
index fe1564c..fd26666 100644
--- a/drivers/block/drbd/drbd_receiver.c
+++ b/drivers/block/drbd/drbd_receiver.c
@@ -862,7 +862,7 @@ retry:
 	msock->sk->sk_rcvtimeo = mdev->net_conf->ping_int*HZ;
 
 	/* we don't want delays.
-	 * we use TCP_CORK where apropriate, though */
+	 * we use TCP_CORK where appropriate, though */
 	drbd_tcp_nodelay(sock);
 	drbd_tcp_nodelay(msock);
 
diff --git a/drivers/block/drbd/drbd_vli.h b/drivers/block/drbd/drbd_vli.h
index fc82400..8cb1532 100644
--- a/drivers/block/drbd/drbd_vli.h
+++ b/drivers/block/drbd/drbd_vli.h
@@ -32,7 +32,7 @@
  * the bitmap transfer time can take much too long,
  * if transmitted in plain text.
  *
- * We try to reduce the transfered bitmap information
+ * We try to reduce the transferred bitmap information
  * by encoding runlengths of bit polarity.
  *
  * We never actually need to encode a "zero" (runlengths are positive).
diff --git a/drivers/block/hd.c b/drivers/block/hd.c
index 30ec6b3..007c630 100644
--- a/drivers/block/hd.c
+++ b/drivers/block/hd.c
@@ -733,7 +733,7 @@ static int __init hd_init(void)
 		 * the BIOS or CMOS.  This doesn't work all that well,
 		 * since this assumes that this is a primary or secondary
 		 * drive, and if we're using this legacy driver, it's
-		 * probably an auxilliary controller added to recover
+		 * probably an auxiliary controller added to recover
 		 * legacy data off an ST-506 drive.  Either way, it's
 		 * definitely safest to have the user explicitly specify
 		 * the information.
diff --git a/drivers/block/viodasd.c b/drivers/block/viodasd.c
index e2ff697..9a5b2a2 100644
--- a/drivers/block/viodasd.c
+++ b/drivers/block/viodasd.c
@@ -94,7 +94,7 @@ static const struct vio_error_entry viodasd_err_table[] = {
 	{ 0x0204, EIO, "Use Error" },
 	{ 0x0205, EIO, "Release Error" },
 	{ 0x0206, EINVAL, "Invalid Disk" },
-	{ 0x0207, EBUSY, "Cant Lock" },
+	{ 0x0207, EBUSY, "Can't Lock" },
 	{ 0x0208, EIO, "Already Locked" },
 	{ 0x0209, EIO, "Already Unlocked" },
 	{ 0x020A, EIO, "Invalid Arg" },
diff --git a/drivers/block/xsysace.c b/drivers/block/xsysace.c
index 73354b0..645ff76 100644
--- a/drivers/block/xsysace.c
+++ b/drivers/block/xsysace.c
@@ -621,7 +621,7 @@ static void ace_fsm_dostate(struct ace_device *ace)
 		ace_dump_mem(ace->cf_id, 512);	/* Debug: Dump out disk ID */
 
 		if (ace->data_result) {
-			/* Error occured, disable the disk */
+			/* Error occurred, disable the disk */
 			ace->media_change = 1;
 			set_capacity(ace->gd, 0);
 			dev_err(ace->dev, "error fetching CF id (%i)\n",
@@ -801,7 +801,7 @@ static int ace_interrupt_checkstate(struct ace_device *ace)
 	u32 sreg = ace_in32(ace, ACE_STATUS);
 	u16 creg = ace_in(ace, ACE_CTRL);
 
-	/* Check for error occurance */
+	/* Check for error occurrence */
 	if ((sreg & (ACE_STATUS_CFGERROR | ACE_STATUS_CFCERROR)) &&
 	    (creg & ACE_CTRL_ERRORIRQ)) {
 		dev_err(ace->dev, "transfer failure\n");
@@ -1169,7 +1169,7 @@ static int __devinit ace_probe(struct platform_device *dev)
 			irq = dev->resource[i].start;
 	}
 
-	/* Call the bus-independant setup code */
+	/* Call the bus-independent setup code */
 	return ace_alloc(&dev->dev, id, physaddr, irq, bus_width);
 }
 
@@ -1222,7 +1222,7 @@ static int __devinit ace_of_probe(struct platform_device *op)
 	if (of_find_property(op->dev.of_node, "8-bit", NULL))
 		bus_width = ACE_BUS_WIDTH_8;
 
-	/* Call the bus-independant setup code */
+	/* Call the bus-independent setup code */
 	return ace_alloc(&op->dev, id ? be32_to_cpup(id) : 0,
 						physaddr, irq, bus_width);
 }
diff --git a/drivers/bluetooth/hci_ll.c b/drivers/bluetooth/hci_ll.c
index 38595e7..7e4b435 100644
--- a/drivers/bluetooth/hci_ll.c
+++ b/drivers/bluetooth/hci_ll.c
@@ -207,7 +207,7 @@ static void ll_device_want_to_wakeup(struct hci_uart *hu)
 		/*
 		 * This state means that both the host and the BRF chip
 		 * have simultaneously sent a wake-up-indication packet.
-		 * Traditionaly, in this case, receiving a wake-up-indication
+		 * Traditionally, in this case, receiving a wake-up-indication
 		 * was enough and an additional wake-up-ack wasn't needed.
 		 * This has changed with the BRF6350, which does require an
 		 * explicit wake-up-ack. Other BRF versions, which do not
diff --git a/drivers/cdrom/cdrom.c b/drivers/cdrom/cdrom.c
index e2c48a7..514dd8e 100644
--- a/drivers/cdrom/cdrom.c
+++ b/drivers/cdrom/cdrom.c
@@ -30,7 +30,7 @@
   changelog for the 1.x series, David?
 
 2.00  Dec  2, 1997 -- Erik Andersen <andersee@debian.org>
-  -- New maintainer! As David A. van Leeuwen has been too busy to activly
+  -- New maintainer! As David A. van Leeuwen has been too busy to actively
   maintain and improve this driver, I am now carrying on the torch. If
   you have a problem with this driver, please feel free to contact me.
 
@@ -2520,7 +2520,7 @@ static int cdrom_ioctl_drive_status(struct cdrom_device_info *cdi,
 /*
  * Ok, this is where problems start.  The current interface for the
  * CDROM_DISC_STATUS ioctl is flawed.  It makes the false assumption that
- * CDs are all CDS_DATA_1 or all CDS_AUDIO, etc.  Unfortunatly, while this
+ * CDs are all CDS_DATA_1 or all CDS_AUDIO, etc.  Unfortunately, while this
  * is often the case, it is also very common for CDs to have some tracks
  * with data, and some tracks with audio.  Just because I feel like it,
  * I declare the following to be the best way to cope.  If the CD has ANY
diff --git a/drivers/char/agp/agp.h b/drivers/char/agp/agp.h
index 3e67ddd..923f99d 100644
--- a/drivers/char/agp/agp.h
+++ b/drivers/char/agp/agp.h
@@ -237,7 +237,7 @@ extern int agp_try_unsupported_boot;
 
 long compat_agp_ioctl(struct file *file, unsigned int cmd, unsigned long arg);
 
-/* Chipset independant registers (from AGP Spec) */
+/* Chipset independent registers (from AGP Spec) */
 #define AGP_APBASE	0x10
 
 #define AGPSTAT		0x4
diff --git a/drivers/char/agp/amd-k7-agp.c b/drivers/char/agp/amd-k7-agp.c
index 45681c0..f7e8878 100644
--- a/drivers/char/agp/amd-k7-agp.c
+++ b/drivers/char/agp/amd-k7-agp.c
@@ -272,7 +272,7 @@ static void amd_irongate_cleanup(void)
  * This routine could be implemented by taking the addresses
  * written to the GATT, and flushing them individually.  However
  * currently it just flushes the whole table.  Which is probably
- * more efficent, since agp_memory blocks can be a large number of
+ * more efficient, since agp_memory blocks can be a large number of
  * entries.
  */
 
diff --git a/drivers/char/agp/sworks-agp.c b/drivers/char/agp/sworks-agp.c
index 13acaaf..f02f9b0 100644
--- a/drivers/char/agp/sworks-agp.c
+++ b/drivers/char/agp/sworks-agp.c
@@ -229,7 +229,7 @@ static int serverworks_fetch_size(void)
  * This routine could be implemented by taking the addresses
  * written to the GATT, and flushing them individually.  However
  * currently it just flushes the whole table.  Which is probably
- * more efficent, since agp_memory blocks can be a large number of
+ * more efficient, since agp_memory blocks can be a large number of
  * entries.
  */
 static void serverworks_tlbflush(struct agp_memory *temp)
diff --git a/drivers/char/agp/via-agp.c b/drivers/char/agp/via-agp.c
index df67e80..8bc3849 100644
--- a/drivers/char/agp/via-agp.c
+++ b/drivers/char/agp/via-agp.c
@@ -400,7 +400,7 @@ static struct agp_device_ids via_agp_device_ids[] __devinitdata =
 	 * the traditional AGP which resides only in chipset. AGP is used
 	 * by 3D driver which wasn't available for the VT3336 and VT3364
 	 * generation until now.  Unfortunately, by testing, VT3364 works
-	 * but VT3336 doesn't. - explaination from via, just leave this as
+	 * but VT3336 doesn't. - explanation from via, just leave this as
 	 * as a placeholder to avoid future patches adding it back in.
 	 */
 #if 0
diff --git a/drivers/char/ipmi/ipmi_poweroff.c b/drivers/char/ipmi/ipmi_poweroff.c
index 0dec5da..2efa176 100644
--- a/drivers/char/ipmi/ipmi_poweroff.c
+++ b/drivers/char/ipmi/ipmi_poweroff.c
@@ -122,7 +122,7 @@ static struct ipmi_recv_msg halt_recv_msg = {
 
 
 /*
- * Code to send a message and wait for the reponse.
+ * Code to send a message and wait for the response.
  */
 
 static void receive_handler(struct ipmi_recv_msg *recv_msg, void *handler_data)
diff --git a/drivers/char/ipmi/ipmi_si_intf.c b/drivers/char/ipmi/ipmi_si_intf.c
index d28b484..cc6c9b2 100644
--- a/drivers/char/ipmi/ipmi_si_intf.c
+++ b/drivers/char/ipmi/ipmi_si_intf.c
@@ -339,7 +339,7 @@ static void return_hosed_msg(struct smi_info *smi_info, int cCode)
 		cCode = IPMI_ERR_UNSPECIFIED;
 	/* else use it as is */
 
-	/* Make it a reponse */
+	/* Make it a response */
 	msg->rsp[0] = msg->data[0] | 4;
 	msg->rsp[1] = msg->data[1];
 	msg->rsp[2] = cCode;
@@ -2927,7 +2927,7 @@ static void return_hosed_msg_badsize(struct smi_info *smi_info)
 {
 	struct ipmi_smi_msg *msg = smi_info->curr_msg;
 
-	/* Make it a reponse */
+	/* Make it a response */
 	msg->rsp[0] = msg->data[0] | 4;
 	msg->rsp[1] = msg->data[1];
 	msg->rsp[2] = CANNOT_RETURN_REQUESTED_LENGTH;
diff --git a/drivers/char/mbcs.h b/drivers/char/mbcs.h
index ba67158..1a36884 100644
--- a/drivers/char/mbcs.h
+++ b/drivers/char/mbcs.h
@@ -36,13 +36,13 @@
 #define MBCS_RD_DMA_CTRL	0x0110	/* Read DMA Control */
 #define MBCS_RD_DMA_AMO_DEST	0x0118	/* Read DMA AMO Destination */
 #define MBCS_RD_DMA_INT_DEST	0x0120	/* Read DMA Interrupt Destination */
-#define MBCS_RD_DMA_AUX_STAT	0x0130	/* Read DMA Auxillary Status */
+#define MBCS_RD_DMA_AUX_STAT	0x0130	/* Read DMA Auxiliary Status */
 #define MBCS_WR_DMA_SYS_ADDR	0x0200	/* Write DMA System Address */
 #define MBCS_WR_DMA_LOC_ADDR	0x0208	/* Write DMA Local Address */
 #define MBCS_WR_DMA_CTRL	0x0210	/* Write DMA Control */
 #define MBCS_WR_DMA_AMO_DEST	0x0218	/* Write DMA AMO Destination */
 #define MBCS_WR_DMA_INT_DEST	0x0220	/* Write DMA Interrupt Destination */
-#define MBCS_WR_DMA_AUX_STAT	0x0230	/* Write DMA Auxillary Status */
+#define MBCS_WR_DMA_AUX_STAT	0x0230	/* Write DMA Auxiliary Status */
 #define MBCS_ALG_AMO_DEST	0x0300	/* Algorithm AMO Destination */
 #define MBCS_ALG_INT_DEST	0x0308	/* Algorithm Interrupt Destination */
 #define MBCS_ALG_OFFSETS	0x0310
diff --git a/drivers/char/mwave/3780i.h b/drivers/char/mwave/3780i.h
index 270431c..fba6ab1 100644
--- a/drivers/char/mwave/3780i.h
+++ b/drivers/char/mwave/3780i.h
@@ -122,7 +122,7 @@ typedef struct {
 typedef struct {
 	unsigned char Dma:3;	/* RW: DMA channel selection */
 	unsigned char NumTransfers:2;	/* RW: Maximum # of transfers once being granted the ISA bus */
-	unsigned char ReRequest:2;	/* RW: Minumum delay between releasing the ISA bus and requesting it again */
+	unsigned char ReRequest:2;	/* RW: Minimum delay between releasing the ISA bus and requesting it again */
 	unsigned char MEMCS16:1;	/* RW: ISA signal MEMCS16: 0=disabled, 1=enabled */
 } DSP_BUSMASTER_CFG_1;
 
diff --git a/drivers/char/nwbutton.c b/drivers/char/nwbutton.c
index 8994ce3..04a480f 100644
--- a/drivers/char/nwbutton.c
+++ b/drivers/char/nwbutton.c
@@ -75,7 +75,7 @@ int button_add_callback (void (*callback) (void), int count)
  * with -EINVAL. If there is more than one entry with the same address,
  * because it searches the list from end to beginning, it will unregister the
  * last one to be registered first (FILO- First In Last Out).
- * Note that this is not neccessarily true if the entries are not submitted
+ * Note that this is not necessarily true if the entries are not submitted
  * at the same time, because another driver could have unregistered a callback
  * between the submissions creating a gap earlier in the list, which would
  * be filled first at submission time.
diff --git a/drivers/char/pcmcia/cm4000_cs.c b/drivers/char/pcmcia/cm4000_cs.c
index bcbbc71..90bd016 100644
--- a/drivers/char/pcmcia/cm4000_cs.c
+++ b/drivers/char/pcmcia/cm4000_cs.c
@@ -806,7 +806,7 @@ static void monitor_card(unsigned long p)
 		dev->flags1 = 0x01;
 		xoutb(dev->flags1, REG_FLAGS1(iobase));
 
-		/* atr is present (which doesnt mean it's valid) */
+		/* atr is present (which doesn't mean it's valid) */
 		set_bit(IS_ATR_PRESENT, &dev->flags);
 		if (dev->atr[0] == 0x03)
 			str_invert_revert(dev->atr, dev->atr_len);
diff --git a/drivers/char/pcmcia/synclink_cs.c b/drivers/char/pcmcia/synclink_cs.c
index beca80b..b575411 100644
--- a/drivers/char/pcmcia/synclink_cs.c
+++ b/drivers/char/pcmcia/synclink_cs.c
@@ -1290,7 +1290,7 @@ static int startup(MGSLPC_INFO * info, struct tty_struct *tty)
 	/* Allocate and claim adapter resources */
 	retval = claim_resources(info);
 
-	/* perform existance check and diagnostics */
+	/* perform existence check and diagnostics */
 	if ( !retval )
 		retval = adapter_test(info);
 
@@ -2680,7 +2680,7 @@ static void rx_free_buffers(MGSLPC_INFO *info)
 static int claim_resources(MGSLPC_INFO *info)
 {
 	if (rx_alloc_buffers(info) < 0 ) {
-		printk( "Cant allocate rx buffer %s\n", info->device_name);
+		printk( "Can't allocate rx buffer %s\n", info->device_name);
 		release_resources(info);
 		return -ENODEV;
 	}
diff --git a/drivers/char/random.c b/drivers/char/random.c
index 5e29e80..d4ddeba 100644
--- a/drivers/char/random.c
+++ b/drivers/char/random.c
@@ -732,7 +732,7 @@ static ssize_t extract_entropy(struct entropy_store *r, void *buf,
 			       size_t nbytes, int min, int rsvd);
 
 /*
- * This utility inline function is responsible for transfering entropy
+ * This utility inline function is responsible for transferring entropy
  * from the primary pool to the secondary extraction pool. We make
  * sure we pull enough for a 'catastrophic reseed'.
  */
diff --git a/drivers/char/sonypi.c b/drivers/char/sonypi.c
index 79e36c8..1ee8ce7 100644
--- a/drivers/char/sonypi.c
+++ b/drivers/char/sonypi.c
@@ -1241,7 +1241,7 @@ static int __devinit sonypi_setup_ioports(struct sonypi_device *dev,
 	while (check_ioport && check->port1) {
 		if (!request_region(check->port1,
 				   sonypi_device.region_size,
-				   "Sony Programable I/O Device Check")) {
+				   "Sony Programmable I/O Device Check")) {
 			printk(KERN_ERR "sonypi: ioport 0x%.4x busy, using sony-laptop? "
 					"if not use check_ioport=0\n",
 					check->port1);
@@ -1255,7 +1255,7 @@ static int __devinit sonypi_setup_ioports(struct sonypi_device *dev,
 
 		if (request_region(ioport_list->port1,
 				   sonypi_device.region_size,
-				   "Sony Programable I/O Device")) {
+				   "Sony Programmable I/O Device")) {
 			dev->ioport1 = ioport_list->port1;
 			dev->ioport2 = ioport_list->port2;
 			return 0;
diff --git a/drivers/char/xilinx_hwicap/xilinx_hwicap.c b/drivers/char/xilinx_hwicap/xilinx_hwicap.c
index d3c9d75..d6412c1 100644
--- a/drivers/char/xilinx_hwicap/xilinx_hwicap.c
+++ b/drivers/char/xilinx_hwicap/xilinx_hwicap.c
@@ -67,7 +67,7 @@
  * cp foo.bit /dev/icap0
  *
  * Note that unless foo.bit is an appropriately constructed partial
- * bitstream, this has a high likelyhood of overwriting the design
+ * bitstream, this has a high likelihood of overwriting the design
  * currently programmed in the FPGA.
  */
 
diff --git a/drivers/cpufreq/cpufreq.c b/drivers/cpufreq/cpufreq.c
index b03771d..2dafc5c 100644
--- a/drivers/cpufreq/cpufreq.c
+++ b/drivers/cpufreq/cpufreq.c
@@ -1782,7 +1782,7 @@ error_out:
  *	cpufreq_update_policy - re-evaluate an existing cpufreq policy
  *	@cpu: CPU which shall be re-evaluated
  *
- *	Usefull for policy notifiers which have different necessities
+ *	Useful for policy notifiers which have different necessities
  *	at different times.
  */
 int cpufreq_update_policy(unsigned int cpu)
diff --git a/drivers/crypto/amcc/crypto4xx_sa.c b/drivers/crypto/amcc/crypto4xx_sa.c
index 466fd94..de8a7a4 100644
--- a/drivers/crypto/amcc/crypto4xx_sa.c
+++ b/drivers/crypto/amcc/crypto4xx_sa.c
@@ -17,7 +17,7 @@
  * @file crypto4xx_sa.c
  *
  * This file implements the security context
- * assoicate format.
+ * associate format.
  */
 #include <linux/kernel.h>
 #include <linux/module.h>
diff --git a/drivers/crypto/amcc/crypto4xx_sa.h b/drivers/crypto/amcc/crypto4xx_sa.h
index 4b83ed7..1352d58 100644
--- a/drivers/crypto/amcc/crypto4xx_sa.h
+++ b/drivers/crypto/amcc/crypto4xx_sa.h
@@ -15,7 +15,7 @@
  * GNU General Public License for more details.
  *
  * This file defines the security context
- * assoicate format.
+ * associate format.
  */
 
 #ifndef __CRYPTO4XX_SA_H__
diff --git a/drivers/crypto/ixp4xx_crypto.c b/drivers/crypto/ixp4xx_crypto.c
index 0d66221..4c20c5b 100644
--- a/drivers/crypto/ixp4xx_crypto.c
+++ b/drivers/crypto/ixp4xx_crypto.c
@@ -1044,7 +1044,7 @@ static int aead_perform(struct aead_request *req, int encrypt,
 	memcpy(crypt->iv, req->iv, ivsize);
 
 	if (req->src != req->dst) {
-		BUG(); /* -ENOTSUP because of my lazyness */
+		BUG(); /* -ENOTSUP because of my laziness */
 	}
 
 	/* ASSOC data */
diff --git a/drivers/dma/at_hdmac.c b/drivers/dma/at_hdmac.c
index 3d7d705..235f53b 100644
--- a/drivers/dma/at_hdmac.c
+++ b/drivers/dma/at_hdmac.c
@@ -167,7 +167,7 @@ static void atc_desc_put(struct at_dma_chan *atchan, struct at_desc *desc)
 /**
  * atc_assign_cookie - compute and assign new cookie
  * @atchan: channel we work on
- * @desc: descriptor to asign cookie for
+ * @desc: descriptor to assign cookie for
  *
  * Called with atchan->lock held and bh disabled
  */
diff --git a/drivers/dma/coh901318.c b/drivers/dma/coh901318.c
index 00deabd..f48e540 100644
--- a/drivers/dma/coh901318.c
+++ b/drivers/dma/coh901318.c
@@ -529,7 +529,7 @@ static void coh901318_pause(struct dma_chan *chan)
 	val = readl(virtbase + COH901318_CX_CFG +
 		    COH901318_CX_CFG_SPACING * channel);
 
-	/* Stopping infinit transfer */
+	/* Stopping infinite transfer */
 	if ((val & COH901318_CX_CTRL_TC_ENABLE) == 0 &&
 	    (val & COH901318_CX_CFG_CH_ENABLE))
 		cohc->stopped = 1;
diff --git a/drivers/dma/intel_mid_dma.c b/drivers/dma/intel_mid_dma.c
index 798f46a..3d4ec38 100644
--- a/drivers/dma/intel_mid_dma.c
+++ b/drivers/dma/intel_mid_dma.c
@@ -911,8 +911,8 @@ static int intel_mid_dma_alloc_chan_resources(struct dma_chan *chan)
 
 /**
  * midc_handle_error -	Handle DMA txn error
- * @mid: controller where error occured
- * @midc: chan where error occured
+ * @mid: controller where error occurred
+ * @midc: chan where error occurred
  *
  * Scan the descriptor for error
  */
@@ -1099,7 +1099,7 @@ static int mid_setup_dma(struct pci_dev *pdev)
 		dma->mask_reg = ioremap(LNW_PERIPHRAL_MASK_BASE,
 					LNW_PERIPHRAL_MASK_SIZE);
 		if (dma->mask_reg == NULL) {
-			pr_err("ERR_MDMA:Cant map periphral intr space !!\n");
+			pr_err("ERR_MDMA:Can't map periphral intr space !!\n");
 			return -ENOMEM;
 		}
 	} else
@@ -1373,7 +1373,7 @@ int dma_resume(struct pci_dev *pci)
 	pci_restore_state(pci);
 	ret = pci_enable_device(pci);
 	if (ret) {
-		pr_err("MDMA: device cant be enabled for %x\n", pci->device);
+		pr_err("MDMA: device can't be enabled for %x\n", pci->device);
 		return ret;
 	}
 	device->state = RUNNING;
diff --git a/drivers/dma/intel_mid_dma_regs.h b/drivers/dma/intel_mid_dma_regs.h
index 709fecb..aea5ee8 100644
--- a/drivers/dma/intel_mid_dma_regs.h
+++ b/drivers/dma/intel_mid_dma_regs.h
@@ -174,8 +174,8 @@ union intel_mid_dma_cfg_hi {
  * @dma: dma device struture pointer
  * @busy: bool representing if ch is busy (active txn) or not
  * @in_use: bool representing if ch is in use or not
- * @raw_tfr: raw trf interrupt recieved
- * @raw_block: raw block interrupt recieved
+ * @raw_tfr: raw trf interrupt received
+ * @raw_block: raw block interrupt received
  */
 struct intel_mid_dma_chan {
 	struct dma_chan		chan;
diff --git a/drivers/dma/mpc512x_dma.c b/drivers/dma/mpc512x_dma.c
index 4f95d31..b9bae94 100644
--- a/drivers/dma/mpc512x_dma.c
+++ b/drivers/dma/mpc512x_dma.c
@@ -328,7 +328,7 @@ static irqreturn_t mpc_dma_irq(int irq, void *data)
 	return IRQ_HANDLED;
 }
 
-/* proccess completed descriptors */
+/* process completed descriptors */
 static void mpc_dma_process_completed(struct mpc_dma *mdma)
 {
 	dma_cookie_t last_cookie = 0;
diff --git a/drivers/dma/shdma.c b/drivers/dma/shdma.c
index 6451b58..d50da41 100644
--- a/drivers/dma/shdma.c
+++ b/drivers/dma/shdma.c
@@ -865,7 +865,12 @@ static unsigned int sh_dmae_reset(struct sh_dmae_device *shdev)
 
 static irqreturn_t sh_dmae_err(int irq, void *data)
 {
-	return IRQ_RETVAL(sh_dmae_reset(data));
+	struct sh_dmae_device *shdev = data;
+
+	if (dmaor_read(shdev) & DMAOR_AE)
+		return IRQ_RETVAL(sh_dmae_reset(data));
+	else
+		return IRQ_NONE;
 }
 
 static void dmae_do_tasklet(unsigned long data)
diff --git a/drivers/dma/ste_dma40.c b/drivers/dma/ste_dma40.c
index af955de..94ee15d 100644
--- a/drivers/dma/ste_dma40.c
+++ b/drivers/dma/ste_dma40.c
@@ -90,7 +90,7 @@ struct d40_lli_pool {
  * @lli_log: Same as above but for logical channels.
  * @lli_pool: The pool with two entries pre-allocated.
  * @lli_len: Number of llis of current descriptor.
- * @lli_current: Number of transfered llis.
+ * @lli_current: Number of transferred llis.
  * @lcla_alloc: Number of LCLA entries allocated.
  * @txd: DMA engine struct. Used for among other things for communication
  * during a transfer.
@@ -1214,7 +1214,7 @@ static void dma_tasklet(unsigned long data)
 	return;
 
  err:
-	/* Rescue manouver if receiving double interrupts */
+	/* Rescue manoeuvre if receiving double interrupts */
 	if (d40c->pending_tx > 0)
 		d40c->pending_tx--;
 	spin_unlock_irqrestore(&d40c->lock, flags);
diff --git a/drivers/edac/Kconfig b/drivers/edac/Kconfig
index fac1a20..af1a17d 100644
--- a/drivers/edac/Kconfig
+++ b/drivers/edac/Kconfig
@@ -45,7 +45,7 @@ config EDAC_DECODE_MCE
 	default y
 	---help---
 	  Enable this option if you want to decode Machine Check Exceptions
-	  occuring on your machine in human-readable form.
+	  occurring on your machine in human-readable form.
 
 	  You should definitely say Y here in case you want to decode MCEs
 	  which occur really early upon boot, before the module infrastructure
diff --git a/drivers/edac/cpc925_edac.c b/drivers/edac/cpc925_edac.c
index b9a781c..837ad8f 100644
--- a/drivers/edac/cpc925_edac.c
+++ b/drivers/edac/cpc925_edac.c
@@ -817,7 +817,7 @@ static void cpc925_del_edac_devices(void)
 	}
 }
 
-/* Convert current back-ground scrub rate into byte/sec bandwith */
+/* Convert current back-ground scrub rate into byte/sec bandwidth */
 static int cpc925_get_sdram_scrub_rate(struct mem_ctl_info *mci)
 {
 	struct cpc925_mc_pdata *pdata = mci->pvt_info;
diff --git a/drivers/edac/edac_core.h b/drivers/edac/edac_core.h
index 3d96534..eefa350 100644
--- a/drivers/edac/edac_core.h
+++ b/drivers/edac/edac_core.h
@@ -164,7 +164,7 @@ enum mem_type {
 /* chipset Error Detection and Correction capabilities and mode */
 enum edac_type {
 	EDAC_UNKNOWN = 0,	/* Unknown if ECC is available */
-	EDAC_NONE,		/* Doesnt support ECC */
+	EDAC_NONE,		/* Doesn't support ECC */
 	EDAC_RESERVED,		/* Reserved ECC type */
 	EDAC_PARITY,		/* Detects parity errors */
 	EDAC_EC,		/* Error Checking - no correction */
@@ -233,7 +233,7 @@ enum scrub_type {
  *			of these in parallel provides 64 bits which is common
  *			for a memory stick.
  *
- * Memory Stick:	A printed circuit board that agregates multiple
+ * Memory Stick:	A printed circuit board that aggregates multiple
  *			memory devices in parallel.  This is the atomic
  *			memory component that is purchaseable by Joe consumer
  *			and loaded into a memory socket.
@@ -385,7 +385,7 @@ struct mem_ctl_info {
 
 	/* Get the current sdram memory scrub rate from the internal
 	   representation and converts it to the closest matching
-	   bandwith in bytes/sec.
+	   bandwidth in bytes/sec.
 	 */
 	int (*get_sdram_scrub_rate) (struct mem_ctl_info * mci);
 
@@ -823,7 +823,7 @@ extern int edac_mc_find_csrow_by_page(struct mem_ctl_info *mci,
  * There are a limited number of error logging registers that can
  * be exausted.  When all registers are exhausted and an additional
  * error occurs then an error overflow register records that an
- * error occured and the type of error, but doesn't have any
+ * error occurred and the type of error, but doesn't have any
  * further information.  The ce/ue versions make for cleaner
  * reporting logic and function interface - reduces conditional
  * statement clutter and extra function arguments.
diff --git a/drivers/edac/edac_device.c b/drivers/edac/edac_device.c
index d5e13c9..a7408cf 100644
--- a/drivers/edac/edac_device.c
+++ b/drivers/edac/edac_device.c
@@ -672,7 +672,7 @@ void edac_device_handle_ce(struct edac_device_ctl_info *edac_dev,
 		block->counters.ce_count++;
 	}
 
-	/* Propogate the count up the 'totals' tree */
+	/* Propagate the count up the 'totals' tree */
 	instance->counters.ce_count++;
 	edac_dev->counters.ce_count++;
 
@@ -718,7 +718,7 @@ void edac_device_handle_ue(struct edac_device_ctl_info *edac_dev,
 		block->counters.ue_count++;
 	}
 
-	/* Propogate the count up the 'totals' tree */
+	/* Propagate the count up the 'totals' tree */
 	instance->counters.ue_count++;
 	edac_dev->counters.ue_count++;
 
diff --git a/drivers/edac/edac_device_sysfs.c b/drivers/edac/edac_device_sysfs.c
index 400de07..86649df 100644
--- a/drivers/edac/edac_device_sysfs.c
+++ b/drivers/edac/edac_device_sysfs.c
@@ -533,7 +533,7 @@ static int edac_device_create_block(struct edac_device_ctl_info *edac_dev,
 	memset(&block->kobj, 0, sizeof(struct kobject));
 
 	/* bump the main kobject's reference count for this controller
-	 * and this instance is dependant on the main
+	 * and this instance is dependent on the main
 	 */
 	main_kobj = kobject_get(&edac_dev->kobj);
 	if (!main_kobj) {
@@ -635,7 +635,7 @@ static int edac_device_create_instance(struct edac_device_ctl_info *edac_dev,
 	instance->ctl = edac_dev;
 
 	/* bump the main kobject's reference count for this controller
-	 * and this instance is dependant on the main
+	 * and this instance is dependent on the main
 	 */
 	main_kobj = kobject_get(&edac_dev->kobj);
 	if (!main_kobj) {
diff --git a/drivers/edac/edac_mc.c b/drivers/edac/edac_mc.c
index a4e9db2..1d80560 100644
--- a/drivers/edac/edac_mc.c
+++ b/drivers/edac/edac_mc.c
@@ -724,7 +724,7 @@ void edac_mc_handle_ce(struct mem_ctl_info *mci,
 		 * Some MC's can remap memory so that it is still available
 		 * at a different address when PCI devices map into memory.
 		 * MC's that can't do this lose the memory where PCI devices
-		 * are mapped.  This mapping is MC dependant and so we call
+		 * are mapped.  This mapping is MC dependent and so we call
 		 * back into the MC driver for it to map the MC page to
 		 * a physical (CPU) page which can then be mapped to a virtual
 		 * page - which can then be scrubbed.
diff --git a/drivers/edac/edac_mc_sysfs.c b/drivers/edac/edac_mc_sysfs.c
index 73196f7..26343fd 100644
--- a/drivers/edac/edac_mc_sysfs.c
+++ b/drivers/edac/edac_mc_sysfs.c
@@ -850,7 +850,7 @@ static void edac_remove_mci_instance_attributes(struct mem_ctl_info *mci,
 
 	/*
 	 * loop if there are attributes and until we hit a NULL entry
-	 * Remove first all the atributes
+	 * Remove first all the attributes
 	 */
 	while (sysfs_attrib) {
 		debugf4("%s() sysfs_attrib = %p\n",__func__, sysfs_attrib);
diff --git a/drivers/edac/edac_pci_sysfs.c b/drivers/edac/edac_pci_sysfs.c
index 023b01c..495198a 100644
--- a/drivers/edac/edac_pci_sysfs.c
+++ b/drivers/edac/edac_pci_sysfs.c
@@ -352,7 +352,7 @@ static int edac_pci_main_kobj_setup(void)
 		return 0;
 
 	/* First time, so create the main kobject and its
-	 * controls and atributes
+	 * controls and attributes
 	 */
 	edac_class = edac_get_sysfs_class();
 	if (edac_class == NULL) {
@@ -551,7 +551,7 @@ static void edac_pci_dev_parity_clear(struct pci_dev *dev)
 /*
  *  PCI Parity polling
  *
- *	Fucntion to retrieve the current parity status
+ *	Function to retrieve the current parity status
  *	and decode it
  *
  */
diff --git a/drivers/edac/i5000_edac.c b/drivers/edac/i5000_edac.c
index a5cefab..87f427c 100644
--- a/drivers/edac/i5000_edac.c
+++ b/drivers/edac/i5000_edac.c
@@ -1372,7 +1372,7 @@ static int i5000_probe1(struct pci_dev *pdev, int dev_idx)
 	 * actual number of slots/dimms per channel, we thus utilize the
 	 * resource as specified by the chipset. Thus, we might have
 	 * have more DIMMs per channel than actually on the mobo, but this
-	 * allows the driver to support upto the chipset max, without
+	 * allows the driver to support up to the chipset max, without
 	 * some fancy mobo determination.
 	 */
 	i5000_get_dimm_and_channel_counts(pdev, &num_dimms_per_channel,
diff --git a/drivers/edac/i5100_edac.c b/drivers/edac/i5100_edac.c
index 0448da0..bcbdeec 100644
--- a/drivers/edac/i5100_edac.c
+++ b/drivers/edac/i5100_edac.c
@@ -11,7 +11,7 @@
  *
  * The intel 5100 has two independent channels. EDAC core currently
  * can not reflect this configuration so instead the chip-select
- * rows for each respective channel are layed out one after another,
+ * rows for each respective channel are laid out one after another,
  * the first half belonging to channel 0, the second half belonging
  * to channel 1.
  */
diff --git a/drivers/edac/i5400_edac.c b/drivers/edac/i5400_edac.c
index 38a9be9..80a465e 100644
--- a/drivers/edac/i5400_edac.c
+++ b/drivers/edac/i5400_edac.c
@@ -648,7 +648,7 @@ static void i5400_process_nonfatal_error_info(struct mem_ctl_info *mci,
 		return;
 	}
 
-	/* Miscelaneous errors */
+	/* Miscellaneous errors */
 	errnum = find_first_bit(&allErrors, ARRAY_SIZE(error_name));
 
 	branch = extract_fbdchan_indx(info->ferr_nf_fbd);
@@ -1240,7 +1240,7 @@ static int i5400_probe1(struct pci_dev *pdev, int dev_idx)
 	 * actual number of slots/dimms per channel, we thus utilize the
 	 * resource as specified by the chipset. Thus, we might have
 	 * have more DIMMs per channel than actually on the mobo, but this
-	 * allows the driver to support upto the chipset max, without
+	 * allows the driver to support up to the chipset max, without
 	 * some fancy mobo determination.
 	 */
 	num_dimms_per_channel = MAX_DIMMS_PER_CHANNEL;
diff --git a/drivers/edac/i7300_edac.c b/drivers/edac/i7300_edac.c
index 76d1f57..363cc16 100644
--- a/drivers/edac/i7300_edac.c
+++ b/drivers/edac/i7300_edac.c
@@ -1065,7 +1065,7 @@ static int __devinit i7300_init_one(struct pci_dev *pdev,
 	 * actual number of slots/dimms per channel, we thus utilize the
 	 * resource as specified by the chipset. Thus, we might have
 	 * have more DIMMs per channel than actually on the mobo, but this
-	 * allows the driver to support upto the chipset max, without
+	 * allows the driver to support up to the chipset max, without
 	 * some fancy mobo determination.
 	 */
 	num_dimms_per_channel = MAX_SLOTS;
diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 81154ab..465cbc2 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -1772,7 +1772,7 @@ static void i7core_check_error(struct mem_ctl_info *mci)
 	/*
 	 * MCE first step: Copy all mce errors into a temporary buffer
 	 * We use a double buffering here, to reduce the risk of
-	 * loosing an error.
+	 * losing an error.
 	 */
 	smp_rmb();
 	count = (pvt->mce_out + MCE_LOG_LEN - pvt->mce_in)
diff --git a/drivers/edac/i82443bxgx_edac.c b/drivers/edac/i82443bxgx_edac.c
index 678405a..4329d39 100644
--- a/drivers/edac/i82443bxgx_edac.c
+++ b/drivers/edac/i82443bxgx_edac.c
@@ -203,7 +203,7 @@ static void i82443bxgx_init_csrows(struct mem_ctl_info *mci,
 		row_high_limit = ((u32) drbar << 23);
 		/* find the DRAM Chip Select Base address and mask */
 		debugf1("MC%d: %s: %s() Row=%d, "
-			"Boundry Address=%#0x, Last = %#0x\n",
+			"Boundary Address=%#0x, Last = %#0x\n",
 			mci->mc_idx, __FILE__, __func__, index, row_high_limit,
 			row_high_limit_last);
 
@@ -305,7 +305,7 @@ static int i82443bxgx_edacmc_probe1(struct pci_dev *pdev, int dev_idx)
 	i82443bxgx_init_csrows(mci, pdev, edac_mode, mtype);
 
 	/* Many BIOSes don't clear error flags on boot, so do this
-	 * here, or we get "phantom" errors occuring at module-load
+	 * here, or we get "phantom" errors occurring at module-load
 	 * time. */
 	pci_write_bits32(pdev, I82443BXGX_EAP,
 			(I82443BXGX_EAP_OFFSET_SBE |
diff --git a/drivers/edac/mce_amd_inj.c b/drivers/edac/mce_amd_inj.c
index 733a7e7..a4987e0 100644
--- a/drivers/edac/mce_amd_inj.c
+++ b/drivers/edac/mce_amd_inj.c
@@ -90,7 +90,7 @@ static ssize_t edac_inject_bank_store(struct kobject *kobj,
 
 	if (value > 5)
 		if (boot_cpu_data.x86 != 0x15 || value > 6) {
-			printk(KERN_ERR "Non-existant MCE bank: %lu\n", value);
+			printk(KERN_ERR "Non-existent MCE bank: %lu\n", value);
 			return -EINVAL;
 		}
 
diff --git a/drivers/edac/r82600_edac.c b/drivers/edac/r82600_edac.c
index 6a822c6..6785137 100644
--- a/drivers/edac/r82600_edac.c
+++ b/drivers/edac/r82600_edac.c
@@ -120,7 +120,7 @@
 				 *        write 0=NOP
 				 */
 
-#define R82600_DRBA	0x60	/* + 0x60..0x63 SDRAM Row Boundry Address
+#define R82600_DRBA	0x60	/* + 0x60..0x63 SDRAM Row Boundary Address
 				 *  Registers
 				 *
 				 * 7:0  Address lines 30:24 - upper limit of
@@ -217,7 +217,7 @@ static void r82600_init_csrows(struct mem_ctl_info *mci, struct pci_dev *pdev,
 {
 	struct csrow_info *csrow;
 	int index;
-	u8 drbar;		/* SDRAM Row Boundry Address Register */
+	u8 drbar;		/* SDRAM Row Boundary Address Register */
 	u32 row_high_limit, row_high_limit_last;
 	u32 reg_sdram, ecc_on, row_base;
 
@@ -236,7 +236,7 @@ static void r82600_init_csrows(struct mem_ctl_info *mci, struct pci_dev *pdev,
 		row_high_limit = ((u32) drbar << 24);
 /*		row_high_limit = ((u32)drbar << 24) | 0xffffffUL; */
 
-		debugf1("%s() Row=%d, Boundry Address=%#0x, Last = %#0x\n",
+		debugf1("%s() Row=%d, Boundary Address=%#0x, Last = %#0x\n",
 			__func__, index, row_high_limit, row_high_limit_last);
 
 		/* Empty row [p.57] */
diff --git a/drivers/firewire/net.c b/drivers/firewire/net.c
index 7ed08fd..3f04dd3 100644
--- a/drivers/firewire/net.c
+++ b/drivers/firewire/net.c
@@ -453,7 +453,7 @@ static bool fwnet_pd_update(struct fwnet_peer *peer,
 	memcpy(pd->pbuf + frag_off, frag_buf, frag_len);
 
 	/*
-	 * Move list entry to beginnig of list so that oldest partial
+	 * Move list entry to beginning of list so that oldest partial
 	 * datagrams percolate to the end of the list
 	 */
 	list_move_tail(&pd->pd_link, &peer->pd_list);
diff --git a/drivers/gpio/mc33880.c b/drivers/gpio/mc33880.c
index 00f6d24..4ec7975 100644
--- a/drivers/gpio/mc33880.c
+++ b/drivers/gpio/mc33880.c
@@ -45,7 +45,7 @@
  * To save time we cache them here in memory
  */
 struct mc33880 {
-	struct mutex	lock;	/* protect from simultanous accesses */
+	struct mutex	lock;	/* protect from simultaneous accesses */
 	u8		port_config;
 	struct gpio_chip chip;
 	struct spi_device *spi;
diff --git a/drivers/gpu/drm/drm_crtc.c b/drivers/gpu/drm/drm_crtc.c
index 799e149..872747c 100644
--- a/drivers/gpu/drm/drm_crtc.c
+++ b/drivers/gpu/drm/drm_crtc.c
@@ -1699,7 +1699,7 @@ int drm_mode_addfb(struct drm_device *dev,
 
 	mutex_lock(&dev->mode_config.mutex);
 
-	/* TODO check buffer is sufficently large */
+	/* TODO check buffer is sufficiently large */
 	/* TODO setup destructor callback */
 
 	fb = dev->mode_config.funcs->fb_create(dev, file_priv, r);
@@ -1750,7 +1750,7 @@ int drm_mode_rmfb(struct drm_device *dev,
 
 	mutex_lock(&dev->mode_config.mutex);
 	obj = drm_mode_object_find(dev, *id, DRM_MODE_OBJECT_FB);
-	/* TODO check that we realy get a framebuffer back. */
+	/* TODO check that we really get a framebuffer back. */
 	if (!obj) {
 		DRM_ERROR("mode invalid framebuffer id\n");
 		ret = -EINVAL;
diff --git a/drivers/gpu/drm/drm_mm.c b/drivers/gpu/drm/drm_mm.c
index add1737..5d00b0f 100644
--- a/drivers/gpu/drm/drm_mm.c
+++ b/drivers/gpu/drm/drm_mm.c
@@ -551,7 +551,7 @@ EXPORT_SYMBOL(drm_mm_scan_add_block);
  * corrupted.
  *
  * When the scan list is empty, the selected memory nodes can be freed. An
- * immediatly following drm_mm_search_free with best_match = 0 will then return
+ * immediately following drm_mm_search_free with best_match = 0 will then return
  * the just freed block (because its at the top of the free_stack list).
  *
  * Returns one if this block should be evicted, zero otherwise. Will always
diff --git a/drivers/gpu/drm/i915/i915_drv.h b/drivers/gpu/drm/i915/i915_drv.h
index 5004724..1c1b27c 100644
--- a/drivers/gpu/drm/i915/i915_drv.h
+++ b/drivers/gpu/drm/i915/i915_drv.h
@@ -630,7 +630,7 @@ typedef struct drm_i915_private {
 		 * Flag if the hardware appears to be wedged.
 		 *
 		 * This is set when attempts to idle the device timeout.
-		 * It prevents command submission from occuring and makes
+		 * It prevents command submission from occurring and makes
 		 * every pending request fail
 		 */
 		atomic_t wedged;
diff --git a/drivers/gpu/drm/i915/intel_dp.c b/drivers/gpu/drm/i915/intel_dp.c
index 0daefca..cb8578b 100644
--- a/drivers/gpu/drm/i915/intel_dp.c
+++ b/drivers/gpu/drm/i915/intel_dp.c
@@ -213,7 +213,7 @@ intel_dp_mode_valid(struct drm_connector *connector,
 			return MODE_PANEL;
 	}
 
-	/* only refuse the mode on non eDP since we have seen some wierd eDP panels
+	/* only refuse the mode on non eDP since we have seen some weird eDP panels
 	   which are outside spec tolerances but somehow work by magic */
 	if (!is_edp(intel_dp) &&
 	    (intel_dp_link_required(connector->dev, intel_dp, mode->clock)
diff --git a/drivers/gpu/drm/i915/intel_sdvo_regs.h b/drivers/gpu/drm/i915/intel_sdvo_regs.h
index a386b02..4f4e23b 100644
--- a/drivers/gpu/drm/i915/intel_sdvo_regs.h
+++ b/drivers/gpu/drm/i915/intel_sdvo_regs.h
@@ -230,7 +230,7 @@ struct intel_sdvo_set_target_input_args {
 } __attribute__((packed));
 
 /**
- * Takes a struct intel_sdvo_output_flags of which outputs are targetted by
+ * Takes a struct intel_sdvo_output_flags of which outputs are targeted by
  * future output commands.
  *
  * Affected commands inclue SET_OUTPUT_TIMINGS_PART[12],
diff --git a/drivers/gpu/drm/mga/mga_dma.c b/drivers/gpu/drm/mga/mga_dma.c
index 1e1eb1d..5ccb65d 100644
--- a/drivers/gpu/drm/mga/mga_dma.c
+++ b/drivers/gpu/drm/mga/mga_dma.c
@@ -426,7 +426,7 @@ int mga_driver_load(struct drm_device *dev, unsigned long flags)
  * Bootstrap the driver for AGP DMA.
  *
  * \todo
- * Investigate whether there is any benifit to storing the WARP microcode in
+ * Investigate whether there is any benefit to storing the WARP microcode in
  * AGP memory.  If not, the microcode may as well always be put in PCI
  * memory.
  *
diff --git a/drivers/gpu/drm/nouveau/nouveau_channel.c b/drivers/gpu/drm/nouveau/nouveau_channel.c
index 3837090..4cea35c 100644
--- a/drivers/gpu/drm/nouveau/nouveau_channel.c
+++ b/drivers/gpu/drm/nouveau/nouveau_channel.c
@@ -200,7 +200,7 @@ nouveau_channel_alloc(struct drm_device *dev, struct nouveau_channel **chan_ret,
 	/* disable the fifo caches */
 	pfifo->reassign(dev, false);
 
-	/* Construct inital RAMFC for new channel */
+	/* Construct initial RAMFC for new channel */
 	ret = pfifo->create_context(chan);
 	if (ret) {
 		nouveau_channel_put(&chan);
@@ -278,7 +278,7 @@ nouveau_channel_put_unlocked(struct nouveau_channel **pchan)
 		return;
 	}
 
-	/* noone wants the channel anymore */
+	/* no one wants the channel anymore */
 	NV_DEBUG(dev, "freeing channel %d\n", chan->id);
 	nouveau_debugfs_channel_fini(chan);
 
diff --git a/drivers/gpu/drm/nouveau/nouveau_drv.h b/drivers/gpu/drm/nouveau/nouveau_drv.h
index fff180a..57e5302 100644
--- a/drivers/gpu/drm/nouveau/nouveau_drv.h
+++ b/drivers/gpu/drm/nouveau/nouveau_drv.h
@@ -216,7 +216,7 @@ struct nouveau_channel {
 	/* mapping of the fifo itself */
 	struct drm_local_map *map;
 
-	/* mapping of the regs controling the fifo */
+	/* mapping of the regs controlling the fifo */
 	void __iomem *user;
 	uint32_t user_get;
 	uint32_t user_put;
diff --git a/drivers/gpu/drm/nouveau/nouveau_state.c b/drivers/gpu/drm/nouveau/nouveau_state.c
index 4fcbd09..5bb2859 100644
--- a/drivers/gpu/drm/nouveau/nouveau_state.c
+++ b/drivers/gpu/drm/nouveau/nouveau_state.c
@@ -963,7 +963,7 @@ int nouveau_load(struct drm_device *dev, unsigned long flags)
 	if (ret)
 		goto err_mmio;
 
-	/* Map PRAMIN BAR, or on older cards, the aperture withing BAR0 */
+	/* Map PRAMIN BAR, or on older cards, the aperture within BAR0 */
 	if (dev_priv->card_type >= NV_40) {
 		int ramin_bar = 2;
 		if (pci_resource_len(dev->pdev, ramin_bar) == 0)
diff --git a/drivers/gpu/drm/nouveau/nv04_crtc.c b/drivers/gpu/drm/nouveau/nv04_crtc.c
index a260fbb..748b9d9 100644
--- a/drivers/gpu/drm/nouveau/nv04_crtc.c
+++ b/drivers/gpu/drm/nouveau/nv04_crtc.c
@@ -164,7 +164,7 @@ nv_crtc_dpms(struct drm_crtc *crtc, int mode)
 	NV_DEBUG_KMS(dev, "Setting dpms mode %d on CRTC %d\n", mode,
 							nv_crtc->index);
 
-	if (nv_crtc->last_dpms == mode) /* Don't do unnecesary mode changes. */
+	if (nv_crtc->last_dpms == mode) /* Don't do unnecessary mode changes. */
 		return;
 
 	nv_crtc->last_dpms = mode;
@@ -677,7 +677,7 @@ static void nv_crtc_prepare(struct drm_crtc *crtc)
 
 	NVBlankScreen(dev, nv_crtc->index, true);
 
-	/* Some more preperation. */
+	/* Some more preparation. */
 	NVWriteCRTC(dev, nv_crtc->index, NV_PCRTC_CONFIG, NV_PCRTC_CONFIG_START_ADDRESS_NON_VGA);
 	if (dev_priv->card_type == NV_40) {
 		uint32_t reg900 = NVReadRAMDAC(dev, nv_crtc->index, NV_PRAMDAC_900);
diff --git a/drivers/gpu/drm/nouveau/nv40_graph.c b/drivers/gpu/drm/nouveau/nv40_graph.c
index 18d30c2..fceb44c 100644
--- a/drivers/gpu/drm/nouveau/nv40_graph.c
+++ b/drivers/gpu/drm/nouveau/nv40_graph.c
@@ -181,7 +181,7 @@ nv40_graph_load_context(struct nouveau_channel *chan)
 		  NV40_PGRAPH_CTXCTL_CUR_LOADED);
 	/* 0x32E0 records the instance address of the active FIFO's PGRAPH
 	 * context.  If at any time this doesn't match 0x40032C, you will
-	 * recieve PGRAPH_INTR_CONTEXT_SWITCH
+	 * receive PGRAPH_INTR_CONTEXT_SWITCH
 	 */
 	nv_wr32(dev, NV40_PFIFO_GRCTX_INSTANCE, inst);
 	return 0;
diff --git a/drivers/gpu/drm/radeon/atombios.h b/drivers/gpu/drm/radeon/atombios.h
index 04b269d..7fd8849 100644
--- a/drivers/gpu/drm/radeon/atombios.h
+++ b/drivers/gpu/drm/radeon/atombios.h
@@ -738,13 +738,13 @@ typedef struct _ATOM_DIG_ENCODER_CONFIG_V3
 {
 #if ATOM_BIG_ENDIAN
     UCHAR ucReserved1:1;
-    UCHAR ucDigSel:3;             // =0/1/2/3/4/5: DIG0/1/2/3/4/5 (In register spec also refered as DIGA/B/C/D/E/F)
+    UCHAR ucDigSel:3;             // =0/1/2/3/4/5: DIG0/1/2/3/4/5 (In register spec also referred as DIGA/B/C/D/E/F)
     UCHAR ucReserved:3;
     UCHAR ucDPLinkRate:1;         // =0: 1.62Ghz, =1: 2.7Ghz
 #else
     UCHAR ucDPLinkRate:1;         // =0: 1.62Ghz, =1: 2.7Ghz
     UCHAR ucReserved:3;
-    UCHAR ucDigSel:3;             // =0/1/2/3/4/5: DIG0/1/2/3/4/5 (In register spec also refered as DIGA/B/C/D/E/F)
+    UCHAR ucDigSel:3;             // =0/1/2/3/4/5: DIG0/1/2/3/4/5 (In register spec also referred as DIGA/B/C/D/E/F)
     UCHAR ucReserved1:1;
 #endif
 }ATOM_DIG_ENCODER_CONFIG_V3;
@@ -785,13 +785,13 @@ typedef struct _ATOM_DIG_ENCODER_CONFIG_V4
 {
 #if ATOM_BIG_ENDIAN
     UCHAR ucReserved1:1;
-    UCHAR ucDigSel:3;             // =0/1/2/3/4/5: DIG0/1/2/3/4/5 (In register spec also refered as DIGA/B/C/D/E/F)
+    UCHAR ucDigSel:3;             // =0/1/2/3/4/5: DIG0/1/2/3/4/5 (In register spec also referred as DIGA/B/C/D/E/F)
     UCHAR ucReserved:2;
     UCHAR ucDPLinkRate:2;         // =0: 1.62Ghz, =1: 2.7Ghz, 2=5.4Ghz    <= Changed comparing to previous version
 #else
     UCHAR ucDPLinkRate:2;         // =0: 1.62Ghz, =1: 2.7Ghz, 2=5.4Ghz    <= Changed comparing to previous version
     UCHAR ucReserved:2;
-    UCHAR ucDigSel:3;             // =0/1/2/3/4/5: DIG0/1/2/3/4/5 (In register spec also refered as DIGA/B/C/D/E/F)
+    UCHAR ucDigSel:3;             // =0/1/2/3/4/5: DIG0/1/2/3/4/5 (In register spec also referred as DIGA/B/C/D/E/F)
     UCHAR ucReserved1:1;
 #endif
 }ATOM_DIG_ENCODER_CONFIG_V4;
@@ -2126,7 +2126,7 @@ typedef struct _ATOM_MULTIMEDIA_CONFIG_INFO
 // Structures used in FirmwareInfoTable
 /****************************************************************************/	
 
-// usBIOSCapability Defintion:
+// usBIOSCapability Definition:
 // Bit 0 = 0: Bios image is not Posted, =1:Bios image is Posted; 
 // Bit 1 = 0: Dual CRTC is not supported, =1: Dual CRTC is supported; 
 // Bit 2 = 0: Extended Desktop is not supported, =1: Extended Desktop is supported; 
@@ -3341,7 +3341,7 @@ typedef struct _ATOM_SPREAD_SPECTRUM_INFO
 /****************************************************************************/	
 // Structure used in AnalogTV_InfoTable (Top level)
 /****************************************************************************/	
-//ucTVBootUpDefaultStd definiton:
+//ucTVBootUpDefaultStd definition:
 
 //ATOM_TV_NTSC                1
 //ATOM_TV_NTSCJ               2
@@ -3816,7 +3816,7 @@ typedef  struct _ATOM_EXTERNAL_DISPLAY_CONNECTION_INFO
   UCHAR                    Reserved [6];                          // for potential expansion
 }ATOM_EXTERNAL_DISPLAY_CONNECTION_INFO;
 
-//Related definitions, all records are differnt but they have a commond header
+//Related definitions, all records are different but they have a commond header
 typedef struct _ATOM_COMMON_RECORD_HEADER
 {
   UCHAR               ucRecordType;                      //An emun to indicate the record type
@@ -4365,14 +4365,14 @@ ucUMAChannelNumber:      	        System memory channel numbers.
 ulCSR_M3_ARB_CNTL_DEFAULT[10]:    Arrays with values for CSR M3 arbiter for default
 ulCSR_M3_ARB_CNTL_UVD[10]:        Arrays with values for CSR M3 arbiter for UVD playback.
 ulCSR_M3_ARB_CNTL_FS3D[10]:       Arrays with values for CSR M3 arbiter for Full Screen 3D applications.
-sAvail_SCLK[5]:                   Arrays to provide availabe list of SLCK and corresponding voltage, order from low to high  
+sAvail_SCLK[5]:                   Arrays to provide available list of SLCK and corresponding voltage, order from low to high  
 ulGMCRestoreResetTime:            GMC power restore and GMC reset time to calculate data reconnection latency. Unit in ns. 
 ulMinimumNClk:                    Minimum NCLK speed among all NB-Pstates to calcualte data reconnection latency. Unit in 10kHz. 
 ulIdleNClk:                       NCLK speed while memory runs in self-refresh state. Unit in 10kHz.
 ulDDR_DLL_PowerUpTime:            DDR PHY DLL power up time. Unit in ns.
 ulDDR_PLL_PowerUpTime:            DDR PHY PLL power up time. Unit in ns.
-usPCIEClkSSPercentage:            PCIE Clock Spred Spectrum Percentage in unit 0.01%; 100 mean 1%.
-usPCIEClkSSType:                  PCIE Clock Spred Spectrum Type. 0 for Down spread(default); 1 for Center spread.
+usPCIEClkSSPercentage:            PCIE Clock Spread Spectrum Percentage in unit 0.01%; 100 mean 1%.
+usPCIEClkSSType:                  PCIE Clock Spread Spectrum Type. 0 for Down spread(default); 1 for Center spread.
 usLvdsSSPercentage:               LVDS panel ( not include eDP ) Spread Spectrum Percentage in unit of 0.01%, =0, use VBIOS default setting. 
 usLvdsSSpreadRateIn10Hz:          LVDS panel ( not include eDP ) Spread Spectrum frequency in unit of 10Hz, =0, use VBIOS default setting. 
 usHDMISSPercentage:               HDMI Spread Spectrum Percentage in unit 0.01%; 100 mean 1%,  =0, use VBIOS default setting. 
@@ -4555,7 +4555,7 @@ typedef struct _ATOM_ASIC_INTERNAL_SS_INFO_V3
 #define ATOM_S0_SYSTEM_POWER_STATE_VALUE_LITEAC 3
 #define ATOM_S0_SYSTEM_POWER_STATE_VALUE_LIT2AC 4
 
-//Byte aligned defintion for BIOS usage
+//Byte aligned definition for BIOS usage
 #define ATOM_S0_CRT1_MONOb0             0x01
 #define ATOM_S0_CRT1_COLORb0            0x02
 #define ATOM_S0_CRT1_MASKb0             (ATOM_S0_CRT1_MONOb0+ATOM_S0_CRT1_COLORb0)
@@ -4621,7 +4621,7 @@ typedef struct _ATOM_ASIC_INTERNAL_SS_INFO_V3
 #define ATOM_S2_DISPLAY_ROTATION_ANGLE_MASK   0xC0000000L
 
 
-//Byte aligned defintion for BIOS usage
+//Byte aligned definition for BIOS usage
 #define ATOM_S2_TV1_STANDARD_MASKb0     0x0F
 #define ATOM_S2_CURRENT_BL_LEVEL_MASKb1 0xFF
 #define ATOM_S2_DEVICE_DPMS_STATEb2     0x01
@@ -4671,7 +4671,7 @@ typedef struct _ATOM_ASIC_INTERNAL_SS_INFO_V3
 #define ATOM_S3_ALLOW_FAST_PWR_SWITCH   0x40000000L
 #define ATOM_S3_RQST_GPU_USE_MIN_PWR    0x80000000L
 
-//Byte aligned defintion for BIOS usage
+//Byte aligned definition for BIOS usage
 #define ATOM_S3_CRT1_ACTIVEb0           0x01
 #define ATOM_S3_LCD1_ACTIVEb0           0x02
 #define ATOM_S3_TV1_ACTIVEb0            0x04
@@ -4707,7 +4707,7 @@ typedef struct _ATOM_ASIC_INTERNAL_SS_INFO_V3
 #define ATOM_S4_LCD1_REFRESH_MASK       0x0000FF00L
 #define ATOM_S4_LCD1_REFRESH_SHIFT      8
 
-//Byte aligned defintion for BIOS usage
+//Byte aligned definition for BIOS usage
 #define ATOM_S4_LCD1_PANEL_ID_MASKb0	  0x0FF
 #define ATOM_S4_LCD1_REFRESH_MASKb1		  ATOM_S4_LCD1_PANEL_ID_MASKb0
 #define ATOM_S4_VRAM_INFO_MASKb2        ATOM_S4_LCD1_PANEL_ID_MASKb0
@@ -4786,7 +4786,7 @@ typedef struct _ATOM_ASIC_INTERNAL_SS_INFO_V3
 #define ATOM_S6_VRI_BRIGHTNESS_CHANGE       0x40000000L
 #define ATOM_S6_CONFIG_DISPLAY_CHANGE_MASK  0x80000000L
 
-//Byte aligned defintion for BIOS usage
+//Byte aligned definition for BIOS usage
 #define ATOM_S6_DEVICE_CHANGEb0         0x01
 #define ATOM_S6_SCALER_CHANGEb0         0x02
 #define ATOM_S6_LID_CHANGEb0            0x04
@@ -5027,7 +5027,7 @@ typedef struct _ENABLE_GRAPH_SURFACE_PS_ALLOCATION
 
 typedef struct _MEMORY_CLEAN_UP_PARAMETERS
 {
-  USHORT  usMemoryStart;                //in 8Kb boundry, offset from memory base address
+  USHORT  usMemoryStart;                //in 8Kb boundary, offset from memory base address
   USHORT  usMemorySize;                 //8Kb blocks aligned
 }MEMORY_CLEAN_UP_PARAMETERS;
 #define MEMORY_CLEAN_UP_PS_ALLOCATION MEMORY_CLEAN_UP_PARAMETERS
@@ -6855,7 +6855,7 @@ typedef struct _ATOM_PPLIB_Clock_Voltage_Limit_Table
 /**************************************************************************/
 
 
-// Following definitions are for compatiblity issue in different SW components. 
+// Following definitions are for compatibility issue in different SW components. 
 #define ATOM_MASTER_DATA_TABLE_REVISION   0x01
 #define Object_Info												Object_Header			
 #define	AdjustARB_SEQ											MC_InitParameter
diff --git a/drivers/gpu/drm/radeon/evergreen_cs.c b/drivers/gpu/drm/radeon/evergreen_cs.c
index edde90b..23d3641 100644
--- a/drivers/gpu/drm/radeon/evergreen_cs.c
+++ b/drivers/gpu/drm/radeon/evergreen_cs.c
@@ -442,7 +442,7 @@ static inline int evergreen_cs_check_reg(struct radeon_cs_parser *p, u32 reg, u3
 	}
 	ib = p->ib->ptr;
 	switch (reg) {
-	/* force following reg to 0 in an attemp to disable out buffer
+	/* force following reg to 0 in an attempt to disable out buffer
 	 * which will need us to better understand how it works to perform
 	 * security check on it (Jerome)
 	 */
diff --git a/drivers/gpu/drm/radeon/r300.c b/drivers/gpu/drm/radeon/r300.c
index 8713731..55a7f19 100644
--- a/drivers/gpu/drm/radeon/r300.c
+++ b/drivers/gpu/drm/radeon/r300.c
@@ -437,7 +437,7 @@ int r300_asic_reset(struct radeon_device *rdev)
 	status = RREG32(R_000E40_RBBM_STATUS);
 	dev_info(rdev->dev, "(%s:%d) RBBM_STATUS=0x%08X\n", __func__, __LINE__, status);
 	/* resetting the CP seems to be problematic sometimes it end up
-	 * hard locking the computer, but it's necessary for successfull
+	 * hard locking the computer, but it's necessary for successful
 	 * reset more test & playing is needed on R3XX/R4XX to find a
 	 * reliable (if any solution)
 	 */
diff --git a/drivers/gpu/drm/radeon/r300_reg.h b/drivers/gpu/drm/radeon/r300_reg.h
index f0bce39..00c0d2b 100644
--- a/drivers/gpu/drm/radeon/r300_reg.h
+++ b/drivers/gpu/drm/radeon/r300_reg.h
@@ -608,7 +608,7 @@
  * My guess is that there are two bits for each zbias primitive
  * (FILL, LINE, POINT).
  *  One to enable depth test and one for depth write.
- * Yet this doesnt explain why depth writes work ...
+ * Yet this doesn't explain why depth writes work ...
  */
 #define R300_RE_OCCLUSION_CNTL		    0x42B4
 #	define R300_OCCLUSION_ON		(1<<1)
@@ -817,7 +817,7 @@
 #	define R300_TX_MIN_FILTER_LINEAR_MIP_NEAREST        (6  <<  11)
 #	define R300_TX_MIN_FILTER_LINEAR_MIP_LINEAR         (10 <<  11)
 
-/* NOTE: NEAREST doesnt seem to exist.
+/* NOTE: NEAREST doesn't seem to exist.
  * Im not seting MAG_FILTER_MASK and (3 << 11) on for all
  * anisotropy modes because that would void selected mag filter
  */
diff --git a/drivers/gpu/drm/radeon/r600_cs.c b/drivers/gpu/drm/radeon/r600_cs.c
index 3324620..fd18be9 100644
--- a/drivers/gpu/drm/radeon/r600_cs.c
+++ b/drivers/gpu/drm/radeon/r600_cs.c
@@ -921,7 +921,7 @@ static inline int r600_cs_check_reg(struct radeon_cs_parser *p, u32 reg, u32 idx
 		return 0;
 	ib = p->ib->ptr;
 	switch (reg) {
-	/* force following reg to 0 in an attemp to disable out buffer
+	/* force following reg to 0 in an attempt to disable out buffer
 	 * which will need us to better understand how it works to perform
 	 * security check on it (Jerome)
 	 */
diff --git a/drivers/gpu/drm/radeon/r600_hdmi.c b/drivers/gpu/drm/radeon/r600_hdmi.c
index 50db6d6..f5ac7e7 100644
--- a/drivers/gpu/drm/radeon/r600_hdmi.c
+++ b/drivers/gpu/drm/radeon/r600_hdmi.c
@@ -334,7 +334,7 @@ void r600_hdmi_setmode(struct drm_encoder *encoder, struct drm_display_mode *mod
 	r600_hdmi_videoinfoframe(encoder, RGB, 0, 0, 0, 0,
 		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
 
-	/* it's unknown what these bits do excatly, but it's indeed quite usefull for debugging */
+	/* it's unknown what these bits do excatly, but it's indeed quite useful for debugging */
 	WREG32(offset+R600_HDMI_AUDIO_DEBUG_0, 0x00FFFFFF);
 	WREG32(offset+R600_HDMI_AUDIO_DEBUG_1, 0x007FFFFF);
 	WREG32(offset+R600_HDMI_AUDIO_DEBUG_2, 0x00000001);
diff --git a/drivers/gpu/drm/radeon/radeon.h b/drivers/gpu/drm/radeon/radeon.h
index cfe3af1..93f5365 100644
--- a/drivers/gpu/drm/radeon/radeon.h
+++ b/drivers/gpu/drm/radeon/radeon.h
@@ -679,11 +679,11 @@ struct radeon_wb {
  * @sideport_bandwidth: sideport bandwidth the gpu has (MByte/s) (IGP)
  * @ht_bandwidth:       ht bandwidth the gpu has (MByte/s) (IGP)
  * @core_bandwidth:     core GPU bandwidth the gpu has (MByte/s) (IGP)
- * @sclk:          	GPU clock Mhz (core bandwith depends of this clock)
+ * @sclk:          	GPU clock Mhz (core bandwidth depends of this clock)
  * @needed_bandwidth:   current bandwidth needs
  *
  * It keeps track of various data needed to take powermanagement decision.
- * Bandwith need is used to determine minimun clock of the GPU and memory.
+ * Bandwidth need is used to determine minimun clock of the GPU and memory.
  * Equation between gpu/memory clock and available bandwidth is hw dependent
  * (type of memory, bus size, efficiency, ...)
  */
diff --git a/drivers/gpu/drm/radeon/radeon_cp.c b/drivers/gpu/drm/radeon/radeon_cp.c
index 3d599e3..7586779 100644
--- a/drivers/gpu/drm/radeon/radeon_cp.c
+++ b/drivers/gpu/drm/radeon/radeon_cp.c
@@ -244,7 +244,7 @@ void radeon_write_agp_base(drm_radeon_private_t *dev_priv, u64 agp_base)
 	u32 agp_base_lo = agp_base & 0xffffffff;
 	u32 r6xx_agp_base = (agp_base >> 22) & 0x3ffff;
 
-	/* R6xx/R7xx must be aligned to a 4MB boundry */
+	/* R6xx/R7xx must be aligned to a 4MB boundary */
 	if ((dev_priv->flags & RADEON_FAMILY_MASK) >= CHIP_RV770)
 		RADEON_WRITE(R700_MC_VM_AGP_BASE, r6xx_agp_base);
 	else if ((dev_priv->flags & RADEON_FAMILY_MASK) >= CHIP_R600)
diff --git a/drivers/gpu/drm/radeon/radeon_cursor.c b/drivers/gpu/drm/radeon/radeon_cursor.c
index 017ac54..bdf2fa1 100644
--- a/drivers/gpu/drm/radeon/radeon_cursor.c
+++ b/drivers/gpu/drm/radeon/radeon_cursor.c
@@ -226,7 +226,7 @@ int radeon_crtc_cursor_move(struct drm_crtc *crtc,
 		y += crtc->y;
 		DRM_DEBUG("x %d y %d c->x %d c->y %d\n", x, y, crtc->x, crtc->y);
 
-		/* avivo cursor image can't end on 128 pixel boundry or
+		/* avivo cursor image can't end on 128 pixel boundary or
 		 * go past the end of the frame if both crtcs are enabled
 		 */
 		list_for_each_entry(crtc_p, &crtc->dev->mode_config.crtc_list, head) {
diff --git a/drivers/gpu/drm/radeon/radeon_device.c b/drivers/gpu/drm/radeon/radeon_device.c
index f0209be..890217e 100644
--- a/drivers/gpu/drm/radeon/radeon_device.c
+++ b/drivers/gpu/drm/radeon/radeon_device.c
@@ -262,7 +262,7 @@ int radeon_wb_init(struct radeon_device *rdev)
  * Note: GTT start, end, size should be initialized before calling this
  * function on AGP platform.
  *
- * Note: We don't explictly enforce VRAM start to be aligned on VRAM size,
+ * Note: We don't explicitly enforce VRAM start to be aligned on VRAM size,
  * this shouldn't be a problem as we are using the PCI aperture as a reference.
  * Otherwise this would be needed for rv280, all r3xx, and all r4xx, but
  * not IGP.
diff --git a/drivers/gpu/drm/radeon/radeon_display.c b/drivers/gpu/drm/radeon/radeon_display.c
index 4be5879..bdbab5c 100644
--- a/drivers/gpu/drm/radeon/radeon_display.c
+++ b/drivers/gpu/drm/radeon/radeon_display.c
@@ -1492,7 +1492,7 @@ bool radeon_crtc_scaling_mode_fixup(struct drm_crtc *crtc,
  *
  * \return Flags, or'ed together as follows:
  *
- * DRM_SCANOUTPOS_VALID = Query successfull.
+ * DRM_SCANOUTPOS_VALID = Query successful.
  * DRM_SCANOUTPOS_INVBL = Inside vblank.
  * DRM_SCANOUTPOS_ACCURATE = Returned position is accurate. A lack of
  * this flag means that returned position may be offset by a constant but
diff --git a/drivers/gpu/drm/radeon/radeon_drv.h b/drivers/gpu/drm/radeon/radeon_drv.h
index 5cba46b..a1b59ca 100644
--- a/drivers/gpu/drm/radeon/radeon_drv.h
+++ b/drivers/gpu/drm/radeon/radeon_drv.h
@@ -271,7 +271,7 @@ typedef struct drm_radeon_private {
 
 	int have_z_offset;
 
-	/* starting from here on, data is preserved accross an open */
+	/* starting from here on, data is preserved across an open */
 	uint32_t flags;		/* see radeon_chip_flags */
 	resource_size_t fb_aper_offset;
 
diff --git a/drivers/gpu/drm/radeon/radeon_object.h b/drivers/gpu/drm/radeon/radeon_object.h
index 7f8e778..ede6c13 100644
--- a/drivers/gpu/drm/radeon/radeon_object.h
+++ b/drivers/gpu/drm/radeon/radeon_object.h
@@ -87,7 +87,7 @@ static inline void radeon_bo_unreserve(struct radeon_bo *bo)
  * Returns current GPU offset of the object.
  *
  * Note: object should either be pinned or reserved when calling this
- * function, it might be usefull to add check for this for debugging.
+ * function, it might be useful to add check for this for debugging.
  */
 static inline u64 radeon_bo_gpu_offset(struct radeon_bo *bo)
 {
diff --git a/drivers/gpu/drm/radeon/radeon_state.c b/drivers/gpu/drm/radeon/radeon_state.c
index 4ae5a3d..92e7ea7 100644
--- a/drivers/gpu/drm/radeon/radeon_state.c
+++ b/drivers/gpu/drm/radeon/radeon_state.c
@@ -980,7 +980,7 @@ static void radeon_cp_dispatch_clear(struct drm_device * dev,
 	}
 
 	/* hyper z clear */
-	/* no docs available, based on reverse engeneering by Stephane Marchesin */
+	/* no docs available, based on reverse engineering by Stephane Marchesin */
 	if ((flags & (RADEON_DEPTH | RADEON_STENCIL))
 	    && (flags & RADEON_CLEAR_FASTZ)) {
 
diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c
index cceeb42..dfe32e6 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c
@@ -245,7 +245,7 @@ void vmw_kms_cursor_snoop(struct vmw_surface *srf,
 		/* TODO handle none page aligned offsets */
 		/* TODO handle partial uploads and pitch != 256 */
 		/* TODO handle more then one copy (size != 64) */
-		DRM_ERROR("lazy programer, cant handle wierd stuff\n");
+		DRM_ERROR("lazy programmer, can't handle weird stuff\n");
 		return;
 	}
 
diff --git a/drivers/gpu/vga/vgaarb.c b/drivers/gpu/vga/vgaarb.c
index ace2b16..be8d4cb 100644
--- a/drivers/gpu/vga/vgaarb.c
+++ b/drivers/gpu/vga/vgaarb.c
@@ -151,7 +151,7 @@ static inline void vga_irq_set_state(struct vga_device *vgadev, bool state)
 static void vga_check_first_use(void)
 {
 	/* we should inform all GPUs in the system that
-	 * VGA arb has occured and to try and disable resources
+	 * VGA arb has occurred and to try and disable resources
 	 * if they can */
 	if (!vga_arbiter_used) {
 		vga_arbiter_used = true;
@@ -774,7 +774,7 @@ static ssize_t vga_arb_read(struct file *file, char __user * buf,
 	 */
 	spin_lock_irqsave(&vga_lock, flags);
 
-	/* If we are targetting the default, use it */
+	/* If we are targeting the default, use it */
 	pdev = priv->target;
 	if (pdev == NULL || pdev == PCI_INVALID_CARD) {
 		spin_unlock_irqrestore(&vga_lock, flags);
diff --git a/drivers/hid/Kconfig b/drivers/hid/Kconfig
index b7ec405..9de9e97 100644
--- a/drivers/hid/Kconfig
+++ b/drivers/hid/Kconfig
@@ -185,7 +185,7 @@ config HID_EZKEY
 	Support for Ezkey BTC 8193 keyboard.
 
 config HID_KEYTOUCH
-	tristate "Keyoutch HID devices"
+	tristate "Keytouch HID devices"
 	depends on USB_HID
 	---help---
 	Support for Keytouch HID devices not fully compliant with
@@ -340,10 +340,17 @@ config HID_NTRIG
 	Support for N-Trig touch screen.
 
 config HID_ORTEK
-	tristate "Ortek PKB-1700/WKB-2000 wireless keyboard and mouse trackpad"
+	tristate "Ortek PKB-1700/WKB-2000/Skycable wireless keyboard and mouse trackpad"
 	depends on USB_HID
 	---help---
-	Support for Ortek PKB-1700/WKB-2000 wireless keyboard + mouse trackpad.
+	There are certain devices which have LogicalMaximum wrong in the keyboard
+	usage page of their report descriptor. The most prevailing ones so far
+	are manufactured by Ortek, thus the name of the driver. Currently
+	supported devices by this driver are
+
+	   - Ortek PKB-1700
+	   - Ortek WKB-2000
+	   - Skycable wireless presenter
 
 config HID_PANTHERLORD
 	tristate "Pantherlord/GreenAsia game controller"
diff --git a/drivers/hid/hid-core.c b/drivers/hid/hid-core.c
index e968776..408c4be 100644
--- a/drivers/hid/hid-core.c
+++ b/drivers/hid/hid-core.c
@@ -306,7 +306,7 @@ static int hid_parser_global(struct hid_parser *parser, struct hid_item *item)
 	case HID_GLOBAL_ITEM_TAG_PUSH:
 
 		if (parser->global_stack_ptr == HID_GLOBAL_STACK_SIZE) {
-			dbg_hid("global enviroment stack overflow\n");
+			dbg_hid("global environment stack overflow\n");
 			return -1;
 		}
 
@@ -317,7 +317,7 @@ static int hid_parser_global(struct hid_parser *parser, struct hid_item *item)
 	case HID_GLOBAL_ITEM_TAG_POP:
 
 		if (!parser->global_stack_ptr) {
-			dbg_hid("global enviroment stack underflow\n");
+			dbg_hid("global environment stack underflow\n");
 			return -1;
 		}
 
@@ -1449,8 +1449,10 @@ static const struct hid_device_id hid_have_special_driver[] = {
 	{ HID_USB_DEVICE(USB_VENDOR_ID_ROCCAT, USB_DEVICE_ID_ROCCAT_KONEPLUS) },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_ROCCAT, USB_DEVICE_ID_ROCCAT_KOVAPLUS) },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_ROCCAT, USB_DEVICE_ID_ROCCAT_PYRA_WIRED) },
+	{ HID_USB_DEVICE(USB_VENDOR_ID_ROCCAT, USB_DEVICE_ID_ROCCAT_PYRA_WIRELESS) },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_SAMSUNG, USB_DEVICE_ID_SAMSUNG_IR_REMOTE) },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_SAMSUNG, USB_DEVICE_ID_SAMSUNG_WIRELESS_KBD_MOUSE) },
+	{ HID_USB_DEVICE(USB_VENDOR_ID_SKYCABLE, USB_DEVICE_ID_SKYCABLE_WIRELESS_PRESENTER) },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_SONY, USB_DEVICE_ID_SONY_PS3_CONTROLLER) },
 	{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_SONY, USB_DEVICE_ID_SONY_PS3_CONTROLLER) },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_SONY, USB_DEVICE_ID_SONY_VAIO_VGX_MOUSE) },
diff --git a/drivers/hid/hid-debug.c b/drivers/hid/hid-debug.c
index 555382f..bae4874 100644
--- a/drivers/hid/hid-debug.c
+++ b/drivers/hid/hid-debug.c
@@ -341,7 +341,7 @@ static const struct hid_usage_entry hid_usage_table[] = {
     { 0x85, 0x83, "DesignCapacity" },
     { 0x85, 0x85, "ManufacturerDate" },
     { 0x85, 0x89, "iDeviceChemistry" },
-    { 0x85, 0x8b, "Rechargable" },
+    { 0x85, 0x8b, "Rechargeable" },
     { 0x85, 0x8f, "iOEMInformation" },
     { 0x85, 0x8d, "CapacityGranularity1" },
     { 0x85, 0xd0, "ACPresent" },
diff --git a/drivers/hid/hid-ids.h b/drivers/hid/hid-ids.h
index 65ac53d..00a94b5 100644
--- a/drivers/hid/hid-ids.h
+++ b/drivers/hid/hid-ids.h
@@ -150,6 +150,7 @@
 #define USB_DEVICE_ID_CANDO_MULTI_TOUCH_15_6 0x0f01
 
 #define USB_VENDOR_ID_CH		0x068e
+#define USB_DEVICE_ID_CH_PRO_THROTTLE	0x00f1
 #define USB_DEVICE_ID_CH_PRO_PEDALS	0x00f2
 #define USB_DEVICE_ID_CH_COMBATSTICK	0x00f4
 #define USB_DEVICE_ID_CH_FLIGHT_SIM_ECLIPSE_YOKE       0x0051
@@ -524,6 +525,9 @@
 #define USB_DEVICE_ID_SAMSUNG_IR_REMOTE	0x0001
 #define USB_DEVICE_ID_SAMSUNG_WIRELESS_KBD_MOUSE	0x0600
 
+#define USB_VENDOR_ID_SKYCABLE			0x1223
+#define	USB_DEVICE_ID_SKYCABLE_WIRELESS_PRESENTER	0x3F07
+
 #define USB_VENDOR_ID_SONY			0x054c
 #define USB_DEVICE_ID_SONY_VAIO_VGX_MOUSE	0x024b
 #define USB_DEVICE_ID_SONY_PS3_CONTROLLER	0x0268
diff --git a/drivers/hid/hid-lgff.c b/drivers/hid/hid-lgff.c
index 90d0ef2..f099079 100644
--- a/drivers/hid/hid-lgff.c
+++ b/drivers/hid/hid-lgff.c
@@ -73,6 +73,8 @@ static const struct dev_type devices[] = {
 	{ 0x046d, 0xc293, ff_joystick },
 	{ 0x046d, 0xc294, ff_wheel },
 	{ 0x046d, 0xc295, ff_joystick },
+	{ 0x046d, 0xc298, ff_wheel },
+	{ 0x046d, 0xc299, ff_wheel },
 	{ 0x046d, 0xca03, ff_wheel },
 };
 
diff --git a/drivers/hid/hid-magicmouse.c b/drivers/hid/hid-magicmouse.c
index 318cc40..0ec91c1 100644
--- a/drivers/hid/hid-magicmouse.c
+++ b/drivers/hid/hid-magicmouse.c
@@ -76,7 +76,7 @@ MODULE_PARM_DESC(report_undeciphered, "Report undeciphered multi-touch state fie
  * This is true when single_touch_id is equal to NO_TOUCHES. If multiple touches
  * are down and the touch providing for single touch emulation is lifted,
  * single_touch_id is equal to SINGLE_TOUCH_UP. While single touch emulation is
- * occuring, single_touch_id corresponds with the tracking id of the touch used.
+ * occurring, single_touch_id corresponds with the tracking id of the touch used.
  */
 #define NO_TOUCHES -1
 #define SINGLE_TOUCH_UP -2
@@ -418,6 +418,8 @@ static void magicmouse_setup_input(struct input_dev *input, struct hid_device *h
 			input_set_abs_params(input, ABS_MT_POSITION_Y, -2456,
 				2565, 4, 0);
 		}
+
+		input_set_events_per_packet(input, 60);
 	}
 
 	if (report_undeciphered) {
diff --git a/drivers/hid/hid-ortek.c b/drivers/hid/hid-ortek.c
index f9b7dd4..0ffa1d2 100644
--- a/drivers/hid/hid-ortek.c
+++ b/drivers/hid/hid-ortek.c
@@ -1,8 +1,14 @@
 /*
- *  HID driver for Ortek PKB-1700/WKB-2000 (wireless keyboard + mouse trackpad).
- *  Fixes LogicalMaximum error in HID report description.
+ *  HID driver for various devices which are apparently based on the same chipset
+ *  from certain vendor which produces chips that contain wrong LogicalMaximum
+ *  value in their HID report descriptor. Currently supported devices are:
+ *
+ *    Ortek PKB-1700
+ *    Ortek WKB-2000
+ *    Skycable wireless presenter
  *
  *  Copyright (c) 2010 Johnathon Harris <jmharris@gmail.com>
+ *  Copyright (c) 2011 Jiri Kosina
  */
 
 /*
@@ -22,8 +28,11 @@ static __u8 *ortek_report_fixup(struct hid_device *hdev, __u8 *rdesc,
 		unsigned int *rsize)
 {
 	if (*rsize >= 56 && rdesc[54] == 0x25 && rdesc[55] == 0x01) {
-		hid_info(hdev, "Fixing up Ortek WKB-2000 report descriptor\n");
+		hid_info(hdev, "Fixing up logical minimum in report descriptor (Ortek)\n");
 		rdesc[55] = 0x92;
+	} else if (*rsize >= 54 && rdesc[52] == 0x25 && rdesc[53] == 0x01) {
+		hid_info(hdev, "Fixing up logical minimum in report descriptor (Skycable)\n");
+		rdesc[53] = 0x65;
 	}
 	return rdesc;
 }
@@ -31,6 +40,7 @@ static __u8 *ortek_report_fixup(struct hid_device *hdev, __u8 *rdesc,
 static const struct hid_device_id ortek_devices[] = {
 	{ HID_USB_DEVICE(USB_VENDOR_ID_ORTEK, USB_DEVICE_ID_ORTEK_PKB1700) },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_ORTEK, USB_DEVICE_ID_ORTEK_WKB2000) },
+	{ HID_USB_DEVICE(USB_VENDOR_ID_SKYCABLE, USB_DEVICE_ID_SKYCABLE_WIRELESS_PRESENTER) },
 	{ }
 };
 MODULE_DEVICE_TABLE(hid, ortek_devices);
diff --git a/drivers/hid/hid-picolcd.c b/drivers/hid/hid-picolcd.c
index 657da5a..b2f56a1 100644
--- a/drivers/hid/hid-picolcd.c
+++ b/drivers/hid/hid-picolcd.c
@@ -1806,13 +1806,13 @@ static ssize_t picolcd_debug_flash_write(struct file *f, const char __user *u,
 /*
  * Notes:
  * - concurrent writing is prevented by mutex and all writes must be
- *   n*64 bytes and 64-byte aligned, each write being preceeded by an
+ *   n*64 bytes and 64-byte aligned, each write being preceded by an
  *   ERASE which erases a 64byte block.
  *   If less than requested was written or an error is returned for an
  *   otherwise correct write request the next 64-byte block which should
  *   have been written is in undefined state (mostly: original, erased,
  *   (half-)written with write error)
- * - reading can happend without special restriction
+ * - reading can happen without special restriction
  */
 static const struct file_operations picolcd_debug_flash_fops = {
 	.owner    = THIS_MODULE,
diff --git a/drivers/hid/hid-roccat-kone.h b/drivers/hid/hid-roccat-kone.h
index 64abb5b..4109a02 100644
--- a/drivers/hid/hid-roccat-kone.h
+++ b/drivers/hid/hid-roccat-kone.h
@@ -166,7 +166,7 @@ enum kone_mouse_events {
 	/* osd events are thought to be display on screen */
 	kone_mouse_event_osd_dpi = 0xa0,
 	kone_mouse_event_osd_profile = 0xb0,
-	/* TODO clarify meaning and occurence of kone_mouse_event_calibration */
+	/* TODO clarify meaning and occurrence of kone_mouse_event_calibration */
 	kone_mouse_event_calibration = 0xc0,
 	kone_mouse_event_call_overlong_macro = 0xe0,
 	/* switch events notify if user changed values with mousebutton click */
diff --git a/drivers/hid/hid-roccat-pyra.c b/drivers/hid/hid-roccat-pyra.c
index 160f481..38280c0 100644
--- a/drivers/hid/hid-roccat-pyra.c
+++ b/drivers/hid/hid-roccat-pyra.c
@@ -652,7 +652,8 @@ static int pyra_raw_event(struct hid_device *hdev, struct hid_report *report,
 static const struct hid_device_id pyra_devices[] = {
 	{ HID_USB_DEVICE(USB_VENDOR_ID_ROCCAT,
 			USB_DEVICE_ID_ROCCAT_PYRA_WIRED) },
-	/* TODO add USB_DEVICE_ID_ROCCAT_PYRA_WIRELESS after testing */
+	{ HID_USB_DEVICE(USB_VENDOR_ID_ROCCAT,
+			USB_DEVICE_ID_ROCCAT_PYRA_WIRELESS) },
 	{ }
 };
 
diff --git a/drivers/hid/usbhid/hid-quirks.c b/drivers/hid/usbhid/hid-quirks.c
index 9a94b64..a8426f1 100644
--- a/drivers/hid/usbhid/hid-quirks.c
+++ b/drivers/hid/usbhid/hid-quirks.c
@@ -59,6 +59,7 @@ static const struct hid_blacklist {
 	{ USB_VENDOR_ID_CH, USB_DEVICE_ID_CH_COMBATSTICK, HID_QUIRK_NOGET },
 	{ USB_VENDOR_ID_CH, USB_DEVICE_ID_CH_FLIGHT_SIM_ECLIPSE_YOKE, HID_QUIRK_NOGET },
 	{ USB_VENDOR_ID_CH, USB_DEVICE_ID_CH_FLIGHT_SIM_YOKE, HID_QUIRK_NOGET },
+	{ USB_VENDOR_ID_CH, USB_DEVICE_ID_CH_PRO_THROTTLE, HID_QUIRK_NOGET },
 	{ USB_VENDOR_ID_CH, USB_DEVICE_ID_CH_PRO_PEDALS, HID_QUIRK_NOGET },
 	{ USB_VENDOR_ID_CH, USB_DEVICE_ID_CH_3AXIS_5BUTTON_STICK, HID_QUIRK_NOGET },
 	{ USB_VENDOR_ID_CH, USB_DEVICE_ID_CH_AXIS_295, HID_QUIRK_NOGET },
diff --git a/drivers/hwmon/abituguru.c b/drivers/hwmon/abituguru.c
index 0e05aa1..e7d4c46 100644
--- a/drivers/hwmon/abituguru.c
+++ b/drivers/hwmon/abituguru.c
@@ -1422,7 +1422,7 @@ static int __init abituguru_detect(void)
 	   at DATA and 0xAC, when this driver has already been loaded once
 	   DATA will hold 0x08. For most uGuru's CMD will hold 0xAC in either
 	   scenario but some will hold 0x00.
-	   Some uGuru's initally hold 0x09 at DATA and will only hold 0x08
+	   Some uGuru's initially hold 0x09 at DATA and will only hold 0x08
 	   after reading CMD first, so CMD must be read first! */
 	u8 cmd_val = inb_p(ABIT_UGURU_BASE + ABIT_UGURU_CMD);
 	u8 data_val = inb_p(ABIT_UGURU_BASE + ABIT_UGURU_DATA);
diff --git a/drivers/hwmon/abituguru3.c b/drivers/hwmon/abituguru3.c
index 034cebf..e89d572 100644
--- a/drivers/hwmon/abituguru3.c
+++ b/drivers/hwmon/abituguru3.c
@@ -151,7 +151,7 @@ struct abituguru3_data {
 	/* Pointer to the sensors info for the detected motherboard */
 	const struct abituguru3_sensor_info *sensors;
 
-	/* The abituguru3 supports upto 48 sensors, and thus has registers
+	/* The abituguru3 supports up to 48 sensors, and thus has registers
 	   sets for 48 sensors, for convienence reasons / simplicity of the
 	   code we always read and store all registers for all 48 sensors */
 
diff --git a/drivers/hwmon/adm1026.c b/drivers/hwmon/adm1026.c
index be0fdd5..0531867 100644
--- a/drivers/hwmon/adm1026.c
+++ b/drivers/hwmon/adm1026.c
@@ -175,7 +175,7 @@ static u16 ADM1026_REG_TEMP_OFFSET[] = { 0x1e, 0x6e, 0x6f };
  * these macros are called: arguments may be evaluated more than once.
  */
 
-/* IN are scaled acording to built-in resistors.  These are the
+/* IN are scaled according to built-in resistors.  These are the
  *   voltages corresponding to 3/4 of full scale (192 or 0xc0)
  *   NOTE: The -12V input needs an additional factor to account
  *      for the Vref pullup resistor.
diff --git a/drivers/hwmon/lm85.c b/drivers/hwmon/lm85.c
index cf47e6e..250d099 100644
--- a/drivers/hwmon/lm85.c
+++ b/drivers/hwmon/lm85.c
@@ -130,7 +130,7 @@ enum chips {
    these macros are called: arguments may be evaluated more than once.
  */
 
-/* IN are scaled acording to built-in resistors */
+/* IN are scaled according to built-in resistors */
 static const int lm85_scaling[] = {  /* .001 Volts */
 	2500, 2250, 3300, 5000, 12000,
 	3300, 1500, 1800 /*EMC6D100*/
diff --git a/drivers/hwmon/lm90.c b/drivers/hwmon/lm90.c
index 812781c..c43b4e9 100644
--- a/drivers/hwmon/lm90.c
+++ b/drivers/hwmon/lm90.c
@@ -356,7 +356,7 @@ static int lm90_read16(struct i2c_client *client, u8 regh, u8 regl, u16 *value)
 	/*
 	 * There is a trick here. We have to read two registers to have the
 	 * sensor temperature, but we have to beware a conversion could occur
-	 * inbetween the readings. The datasheet says we should either use
+	 * between the readings. The datasheet says we should either use
 	 * the one-shot conversion register, which we don't want to do
 	 * (disables hardware monitoring) or monitor the busy bit, which is
 	 * impossible (we can't read the values and monitor that bit at the
diff --git a/drivers/hwmon/sht15.c b/drivers/hwmon/sht15.c
index 1a9c32d..f4e617a 100644
--- a/drivers/hwmon/sht15.c
+++ b/drivers/hwmon/sht15.c
@@ -52,7 +52,7 @@
 #define SHT15_TSU		150	/* data setup time */
 
 /**
- * struct sht15_temppair - elements of voltage dependant temp calc
+ * struct sht15_temppair - elements of voltage dependent temp calc
  * @vdd:	supply voltage in microvolts
  * @d1:		see data sheet
  */
@@ -251,7 +251,7 @@ static inline int sht15_update_single_val(struct sht15_data *data,
 	enable_irq(gpio_to_irq(data->pdata->gpio_data));
 	if (gpio_get_value(data->pdata->gpio_data) == 0) {
 		disable_irq_nosync(gpio_to_irq(data->pdata->gpio_data));
-		/* Only relevant if the interrupt hasn't occured. */
+		/* Only relevant if the interrupt hasn't occurred. */
 		if (!atomic_read(&data->interrupt_handled))
 			schedule_work(&data->read_work);
 	}
@@ -452,7 +452,7 @@ static void sht15_bh_read_data(struct work_struct *work_s)
 		*/
 		atomic_set(&data->interrupt_handled, 0);
 		enable_irq(gpio_to_irq(data->pdata->gpio_data));
-		/* If still not occured or another handler has been scheduled */
+		/* If still not occurred or another handler has been scheduled */
 		if (gpio_get_value(data->pdata->gpio_data)
 		    || atomic_read(&data->interrupt_handled))
 			return;
diff --git a/drivers/hwmon/tmp102.c b/drivers/hwmon/tmp102.c
index 93187c3..5bd1949 100644
--- a/drivers/hwmon/tmp102.c
+++ b/drivers/hwmon/tmp102.c
@@ -166,7 +166,7 @@ static int __devinit tmp102_probe(struct i2c_client *client,
 
 	if (!i2c_check_functionality(client->adapter,
 				     I2C_FUNC_SMBUS_WORD_DATA)) {
-		dev_err(&client->dev, "adapter doesnt support SMBus word "
+		dev_err(&client->dev, "adapter doesn't support SMBus word "
 			"transactions\n");
 		return -ENODEV;
 	}
diff --git a/drivers/hwmon/w83791d.c b/drivers/hwmon/w83791d.c
index 400a88b..17cf1ab 100644
--- a/drivers/hwmon/w83791d.c
+++ b/drivers/hwmon/w83791d.c
@@ -556,7 +556,7 @@ static ssize_t show_fan_div(struct device *dev, struct device_attribute *attr,
 
 /* Note: we save and restore the fan minimum here, because its value is
    determined in part by the fan divisor.  This follows the principle of
-   least suprise; the user doesn't expect the fan minimum to change just
+   least surprise; the user doesn't expect the fan minimum to change just
    because the divisor changed. */
 static ssize_t store_fan_div(struct device *dev, struct device_attribute *attr,
 				const char *buf, size_t count)
diff --git a/drivers/hwmon/w83792d.c b/drivers/hwmon/w83792d.c
index 63841f8..f3e7130 100644
--- a/drivers/hwmon/w83792d.c
+++ b/drivers/hwmon/w83792d.c
@@ -244,7 +244,7 @@ FAN_TO_REG(long rpm, int div)
 #define TEMP1_TO_REG(val)	(SENSORS_LIMIT(((val) < 0 ? (val)+0x100*1000 \
 					: (val)) / 1000, 0, 0xff))
 #define TEMP1_FROM_REG(val)	(((val) & 0x80 ? (val)-0x100 : (val)) * 1000)
-/* for temp2 and temp3, because they need addtional resolution */
+/* for temp2 and temp3, because they need additional resolution */
 #define TEMP_ADD_FROM_REG(val1, val2) \
 	((((val1) & 0x80 ? (val1)-0x100 \
 		: (val1)) * 1000) + ((val2 & 0x80) ? 500 : 0))
diff --git a/drivers/hwmon/w83793.c b/drivers/hwmon/w83793.c
index e3bdedf..854f911 100644
--- a/drivers/hwmon/w83793.c
+++ b/drivers/hwmon/w83793.c
@@ -1921,7 +1921,7 @@ static void w83793_update_nonvolatile(struct device *dev)
 	struct w83793_data *data = i2c_get_clientdata(client);
 	int i, j;
 	/*
-	   They are somewhat "stable" registers, and to update them everytime
+	   They are somewhat "stable" registers, and to update them every time
 	   takes so much time, it's just not worthy. Update them in a long
 	   interval to avoid exception.
 	 */
diff --git a/drivers/i2c/algos/i2c-algo-pca.c b/drivers/i2c/algos/i2c-algo-pca.c
index 2b9a8f5..4ca9cf9 100644
--- a/drivers/i2c/algos/i2c-algo-pca.c
+++ b/drivers/i2c/algos/i2c-algo-pca.c
@@ -343,7 +343,7 @@ static int pca_xfer(struct i2c_adapter *i2c_adap,
 
 	ret = curmsg;
  out:
-	DEB1("}}} transfered %d/%d messages. "
+	DEB1("}}} transferred %d/%d messages. "
 	     "status is %#04x. control is %#04x\n",
 	     curmsg, num, pca_status(adap),
 	     pca_get_con(adap));
diff --git a/drivers/i2c/busses/i2c-ali1535.c b/drivers/i2c/busses/i2c-ali1535.c
index 906a3ca5..dd36417 100644
--- a/drivers/i2c/busses/i2c-ali1535.c
+++ b/drivers/i2c/busses/i2c-ali1535.c
@@ -295,7 +295,7 @@ static int ali1535_transaction(struct i2c_adapter *adap)
 	}
 
 	/* Unfortunately the ALI SMB controller maps "no response" and "bus
-	 * collision" into a single bit. No reponse is the usual case so don't
+	 * collision" into a single bit. No response is the usual case so don't
 	 * do a printk.  This means that bus collisions go unreported.
 	 */
 	if (temp & ALI1535_STS_BUSERR) {
diff --git a/drivers/i2c/busses/i2c-ali15x3.c b/drivers/i2c/busses/i2c-ali15x3.c
index b14f6d6..83e8a60 100644
--- a/drivers/i2c/busses/i2c-ali15x3.c
+++ b/drivers/i2c/busses/i2c-ali15x3.c
@@ -318,7 +318,7 @@ static int ali15x3_transaction(struct i2c_adapter *adap)
 
 	/*
 	  Unfortunately the ALI SMB controller maps "no response" and "bus
-	  collision" into a single bit. No reponse is the usual case so don't
+	  collision" into a single bit. No response is the usual case so don't
 	  do a printk.
 	  This means that bus collisions go unreported.
 	*/
diff --git a/drivers/i2c/busses/i2c-davinci.c b/drivers/i2c/busses/i2c-davinci.c
index 5795c83..a76d85f 100644
--- a/drivers/i2c/busses/i2c-davinci.c
+++ b/drivers/i2c/busses/i2c-davinci.c
@@ -355,7 +355,7 @@ i2c_davinci_xfer_msg(struct i2c_adapter *adap, struct i2c_msg *msg, int stop)
 	/*
 	 * Write mode register first as needed for correct behaviour
 	 * on OMAP-L138, but don't set STT yet to avoid a race with XRDY
-	 * occuring before we have loaded DXR
+	 * occurring before we have loaded DXR
 	 */
 	davinci_i2c_write_reg(dev, DAVINCI_I2C_MDR_REG, flag);
 
diff --git a/drivers/i2c/busses/i2c-designware.c b/drivers/i2c/busses/i2c-designware.c
index b664ed8..b7a51c4 100644
--- a/drivers/i2c/busses/i2c-designware.c
+++ b/drivers/i2c/busses/i2c-designware.c
@@ -178,7 +178,7 @@ static char *abort_sources[] = {
  * @lock: protect this struct and IO registers
  * @clk: input reference clock
  * @cmd_err: run time hadware error code
- * @msgs: points to an array of messages currently being transfered
+ * @msgs: points to an array of messages currently being transferred
  * @msgs_num: the number of elements in msgs
  * @msg_write_idx: the element index of the current tx message in the msgs
  *	array
diff --git a/drivers/i2c/busses/i2c-elektor.c b/drivers/i2c/busses/i2c-elektor.c
index e5b1a3b..37e2e82 100644
--- a/drivers/i2c/busses/i2c-elektor.c
+++ b/drivers/i2c/busses/i2c-elektor.c
@@ -22,7 +22,7 @@
 /* With some changes from Kysti Mlkki <kmalkki@cc.hut.fi> and even
    Frodo Looijaard <frodol@dds.nl> */
 
-/* Partialy rewriten by Oleg I. Vdovikin for mmapped support of
+/* Partially rewriten by Oleg I. Vdovikin for mmapped support of
    for Alpha Processor Inc. UP-2000(+) boards */
 
 #include <linux/kernel.h>
diff --git a/drivers/i2c/busses/i2c-i801.c b/drivers/i2c/busses/i2c-i801.c
index ed2e0c5..72c0415 100644
--- a/drivers/i2c/busses/i2c-i801.c
+++ b/drivers/i2c/busses/i2c-i801.c
@@ -96,7 +96,7 @@
 #define SMBHSTCFG_SMB_SMI_EN	2
 #define SMBHSTCFG_I2C_EN	4
 
-/* Auxillary control register bits, ICH4+ only */
+/* Auxiliary control register bits, ICH4+ only */
 #define SMBAUXCTL_CRC		1
 #define SMBAUXCTL_E32B		2
 
diff --git a/drivers/i2c/busses/i2c-ibm_iic.c b/drivers/i2c/busses/i2c-ibm_iic.c
index e4f88dc..3c110fb 100644
--- a/drivers/i2c/busses/i2c-ibm_iic.c
+++ b/drivers/i2c/busses/i2c-ibm_iic.c
@@ -494,7 +494,7 @@ static int iic_xfer_bytes(struct ibm_iic_private* dev, struct i2c_msg* pm,
 		if (unlikely(ret < 0))
 			break;
 		else if (unlikely(ret != count)){
-			DBG("%d: xfer_bytes, requested %d, transfered %d\n",
+			DBG("%d: xfer_bytes, requested %d, transferred %d\n",
 				dev->idx, count, ret);
 
 			/* If it's not a last part of xfer, abort it */
@@ -593,7 +593,7 @@ static int iic_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)
 	if (unlikely((in_8(&iic->extsts) & EXTSTS_BCS_MASK) != EXTSTS_BCS_FREE)){
 		DBG("%d: iic_xfer, bus is not free\n", dev->idx);
 
-		/* Usually it means something serious has happend.
+		/* Usually it means something serious has happened.
 		 * We *cannot* have unfinished previous transfer
 		 * so it doesn't make any sense to try to stop it.
 		 * Probably we were not able to recover from the
diff --git a/drivers/i2c/busses/i2c-intel-mid.c b/drivers/i2c/busses/i2c-intel-mid.c
index c714927..e828ac8 100644
--- a/drivers/i2c/busses/i2c-intel-mid.c
+++ b/drivers/i2c/busses/i2c-intel-mid.c
@@ -170,8 +170,8 @@ struct intel_mid_i2c_private {
 /* Raw Interrupt Status Register */
 #define IC_RAW_INTR_STAT	0x34		/* Read Only */
 #define GEN_CALL		(1 << 11)	/* General call */
-#define START_DET		(1 << 10)	/* (RE)START occured */
-#define STOP_DET		(1 << 9)	/* STOP occured */
+#define START_DET		(1 << 10)	/* (RE)START occurred */
+#define STOP_DET		(1 << 9)	/* STOP occurred */
 #define ACTIVITY		(1 << 8)	/* Bus busy */
 #define RX_DONE			(1 << 7)	/* Not used in Master mode */
 #define	TX_ABRT			(1 << 6)	/* Transmit Abort */
@@ -375,7 +375,7 @@ static int intel_mid_i2c_disable(struct i2c_adapter *adap)
  * I2C should be disabled prior to other register operation. If failed, an
  * errno is returned. Mask and Clear all interrpts, this should be done at
  * first.  Set common registers which will not be modified during normal
- * transfers, including: controll register, FIFO threshold and clock freq.
+ * transfers, including: control register, FIFO threshold and clock freq.
  * Check APB data width at last.
  */
 static int intel_mid_i2c_hwinit(struct intel_mid_i2c_private *i2c)
@@ -455,7 +455,7 @@ static inline bool intel_mid_i2c_address_neq(const struct i2c_msg *p1,
  *
  * By reading register IC_TX_ABRT_SOURCE, various transfer errors can be
  * distingushed. At present, no circumstances have been found out that
- * multiple errors would be occured simutaneously, so we simply use the
+ * multiple errors would be occurred simutaneously, so we simply use the
  * register value directly.
  *
  * At last the error bits are cleared. (Note clear ABRT_SBYTE_NORSTRT bit need
@@ -469,7 +469,7 @@ static void intel_mid_i2c_abort(struct intel_mid_i2c_private *i2c)
 
 	/* Single transfer error check:
 	 * According to databook, TX/RX FIFOs would be flushed when
-	 * the abort interrupt occured.
+	 * the abort interrupt occurred.
 	 */
 	if (abort & ABRT_MASTER_DIS)
 		dev_err(&adap->dev,
@@ -569,7 +569,7 @@ static int xfer_read(struct i2c_adapter *adap, unsigned char *buf, int length)
  * Return Values:
  * 0	if the read transfer succeeds
  * -ETIMEDOUT	if we cannot read the "raw" interrupt register
- * -EINVAL	if a transfer abort occured
+ * -EINVAL	if a transfer abort occurred
  *
  * For every byte, a "WRITE" command will be loaded into IC_DATA_CMD prior to
  * data transfer. The actual "write" operation will be performed when the
@@ -697,7 +697,7 @@ static int intel_mid_i2c_setup(struct i2c_adapter *adap,  struct i2c_msg *pmsg)
  * @num: number of i2c_msg
  *
  * Return Values:
- * +		number of messages transfered
+ * +		number of messages transferred
  * -ETIMEDOUT	If cannot disable I2C controller or read IC_STATUS
  * -EINVAL	If the address in i2c_msg is invalid
  *
diff --git a/drivers/i2c/busses/i2c-isch.c b/drivers/i2c/busses/i2c-isch.c
index ddc258e..0682f8f 100644
--- a/drivers/i2c/busses/i2c-isch.c
+++ b/drivers/i2c/busses/i2c-isch.c
@@ -141,7 +141,7 @@ static int sch_transaction(void)
  * This is the main access entry for i2c-sch access
  * adap is i2c_adapter pointer, addr is the i2c device bus address, read_write
  * (0 for read and 1 for write), size is i2c transaction type and data is the
- * union of transaction for data to be transfered or data read from bus.
+ * union of transaction for data to be transferred or data read from bus.
  * return 0 for success and others for failure.
  */
 static s32 sch_access(struct i2c_adapter *adap, u16 addr,
diff --git a/drivers/i2c/busses/i2c-mxs.c b/drivers/i2c/busses/i2c-mxs.c
index caf96dc..7e78f7c 100644
--- a/drivers/i2c/busses/i2c-mxs.c
+++ b/drivers/i2c/busses/i2c-mxs.c
@@ -149,7 +149,7 @@ static void mxs_i2c_pioq_setup_write(struct mxs_i2c_dev *i2c,
 	 * We have to copy the slave address (u8) and buffer (arbitrary number
 	 * of u8) into the data register (u32). To achieve that, the u8 are put
 	 * into the MSBs of 'data' which is then shifted for the next u8. When
-	 * apropriate, 'data' is written to MXS_I2C_DATA. So, the first u32
+	 * appropriate, 'data' is written to MXS_I2C_DATA. So, the first u32
 	 * looks like this:
 	 *
 	 *  3          2          1          0
diff --git a/drivers/i2c/busses/i2c-nomadik.c b/drivers/i2c/busses/i2c-nomadik.c
index 594ed50..e10e5cf 100644
--- a/drivers/i2c/busses/i2c-nomadik.c
+++ b/drivers/i2c/busses/i2c-nomadik.c
@@ -126,9 +126,9 @@ enum i2c_operation {
 /**
  * struct i2c_nmk_client - client specific data
  * @slave_adr: 7-bit slave address
- * @count: no. bytes to be transfered
+ * @count: no. bytes to be transferred
  * @buffer: client data buffer
- * @xfer_bytes: bytes transfered till now
+ * @xfer_bytes: bytes transferred till now
  * @operation: current I2C operation
  */
 struct i2c_nmk_client {
@@ -330,7 +330,7 @@ static void setup_i2c_controller(struct nmk_i2c_dev *dev)
 	 * slsu defines the data setup time after SCL clock
 	 * stretching in terms of i2c clk cycles. The
 	 * needed setup time for the three modes are 250ns,
-	 * 100ns, 10ns repectively thus leading to the values
+	 * 100ns, 10ns respectively thus leading to the values
 	 * of 14, 6, 2 for a 48 MHz i2c clk.
 	 */
 	writel(dev->cfg.slsu << 16, dev->virtbase + I2C_SCR);
@@ -364,7 +364,7 @@ static void setup_i2c_controller(struct nmk_i2c_dev *dev)
 	/*
 	 * set the speed mode. Currently we support
 	 * only standard and fast mode of operation
-	 * TODO - support for fast mode plus (upto 1Mb/s)
+	 * TODO - support for fast mode plus (up to 1Mb/s)
 	 * and high speed (up to 3.4 Mb/s)
 	 */
 	if (dev->cfg.sm > I2C_FREQ_MODE_FAST) {
diff --git a/drivers/i2c/busses/i2c-s6000.c b/drivers/i2c/busses/i2c-s6000.c
index cadc021..cb5d01e 100644
--- a/drivers/i2c/busses/i2c-s6000.c
+++ b/drivers/i2c/busses/i2c-s6000.c
@@ -318,7 +318,7 @@ static int __devinit s6i2c_probe(struct platform_device *dev)
 	rc = request_irq(iface->irq, s6i2c_interrupt_entry,
 			 IRQF_SHARED, dev->name, iface);
 	if (rc) {
-		dev_err(&p_adap->dev, "s6i2c: cant get IRQ %d\n", iface->irq);
+		dev_err(&p_adap->dev, "s6i2c: can't get IRQ %d\n", iface->irq);
 		goto err_clk_dis;
 	}
 
diff --git a/drivers/i2c/busses/i2c-stu300.c b/drivers/i2c/busses/i2c-stu300.c
index 266135d..9987961 100644
--- a/drivers/i2c/busses/i2c-stu300.c
+++ b/drivers/i2c/busses/i2c-stu300.c
@@ -497,7 +497,7 @@ static int stu300_set_clk(struct stu300_dev *dev, unsigned long clkrate)
 	u32 val;
 	int i = 0;
 
-	/* Locate the apropriate clock setting */
+	/* Locate the appropriate clock setting */
 	while (i < ARRAY_SIZE(stu300_clktable) - 1 &&
 	       stu300_clktable[i].rate < clkrate)
 		i++;
@@ -644,7 +644,7 @@ static int stu300_send_address(struct stu300_dev *dev,
 	ret = stu300_await_event(dev, STU300_EVENT_6);
 
 	/*
-	 * Clear any pending EVENT 6 no matter what happend during
+	 * Clear any pending EVENT 6 no matter what happened during
 	 * await_event.
 	 */
 	val = stu300_r8(dev->virtbase + I2C_CR);
diff --git a/drivers/i2c/busses/i2c-tegra.c b/drivers/i2c/busses/i2c-tegra.c
index 3921f66..b4ab39b 100644
--- a/drivers/i2c/busses/i2c-tegra.c
+++ b/drivers/i2c/busses/i2c-tegra.c
@@ -386,7 +386,7 @@ static irqreturn_t tegra_i2c_isr(int irq, void *dev_id)
 		dvc_writel(i2c_dev, DVC_STATUS_I2C_DONE_INTR, DVC_STATUS);
 	return IRQ_HANDLED;
 err:
-	/* An error occured, mask all interrupts */
+	/* An error occurred, mask all interrupts */
 	tegra_i2c_mask_irq(i2c_dev, I2C_INT_NO_ACK | I2C_INT_ARBITRATION_LOST |
 		I2C_INT_PACKET_XFER_COMPLETE | I2C_INT_TX_FIFO_DATA_REQ |
 		I2C_INT_RX_FIFO_DATA_REQ);
diff --git a/drivers/i2c/busses/i2c-xiic.c b/drivers/i2c/busses/i2c-xiic.c
index 9fbd7e6..e9d5ff4 100644
--- a/drivers/i2c/busses/i2c-xiic.c
+++ b/drivers/i2c/busses/i2c-xiic.c
@@ -21,7 +21,7 @@
  * to the automotive development board Russellville. The copyright holder
  * as seen in the header is Intel corporation.
  * Mocean Laboratories forked off the GNU/Linux platform work into a
- * separate company called Pelagicore AB, which commited the code to the
+ * separate company called Pelagicore AB, which committed the code to the
  * kernel.
  */
 
diff --git a/drivers/i2c/i2c-core.c b/drivers/i2c/i2c-core.c
index e5f76a0..70c30e6 100644
--- a/drivers/i2c/i2c-core.c
+++ b/drivers/i2c/i2c-core.c
@@ -348,7 +348,7 @@ EXPORT_SYMBOL(i2c_verify_client);
 
 
 /* This is a permissive address validity check, I2C address map constraints
- * are purposedly not enforced, except for the general call address. */
+ * are purposely not enforced, except for the general call address. */
 static int i2c_check_client_addr_validity(const struct i2c_client *client)
 {
 	if (client->flags & I2C_CLIENT_TEN) {
diff --git a/drivers/ide/cy82c693.c b/drivers/ide/cy82c693.c
index 9383f67..3be60da 100644
--- a/drivers/ide/cy82c693.c
+++ b/drivers/ide/cy82c693.c
@@ -67,7 +67,7 @@ static void cy82c693_set_dma_mode(ide_hwif_t *hwif, ide_drive_t *drive)
 
 	/*
 	 * note: below we set the value for Bus Master IDE TimeOut Register
-	 * I'm not absolutly sure what this does, but it solved my problem
+	 * I'm not absolutely sure what this does, but it solved my problem
 	 * with IDE DMA and sound, so I now can play sound and work with
 	 * my IDE driver at the same time :-)
 	 *
diff --git a/drivers/ide/ide-floppy.c b/drivers/ide/ide-floppy.c
index 5406b6e..5a702d0 100644
--- a/drivers/ide/ide-floppy.c
+++ b/drivers/ide/ide-floppy.c
@@ -107,7 +107,7 @@ static int ide_floppy_callback(ide_drive_t *drive, int dsc)
 static void ide_floppy_report_error(struct ide_disk_obj *floppy,
 				    struct ide_atapi_pc *pc)
 {
-	/* supress error messages resulting from Medium not present */
+	/* suppress error messages resulting from Medium not present */
 	if (floppy->sense_key == 0x02 &&
 	    floppy->asc       == 0x3a &&
 	    floppy->ascq      == 0x00)
diff --git a/drivers/ide/ide-taskfile.c b/drivers/ide/ide-taskfile.c
index 34b9872..600c89a 100644
--- a/drivers/ide/ide-taskfile.c
+++ b/drivers/ide/ide-taskfile.c
@@ -201,7 +201,7 @@ static u8 wait_drive_not_busy(ide_drive_t *drive)
 	u8 stat;
 
 	/*
-	 * Last sector was transfered, wait until device is ready.  This can
+	 * Last sector was transferred, wait until device is ready.  This can
 	 * take up to 6 ms on some ATAPI devices, so we will wait max 10 ms.
 	 */
 	for (retries = 0; retries < 1000; retries++) {
diff --git a/drivers/ide/piix.c b/drivers/ide/piix.c
index 1bdca49..b59d04c 100644
--- a/drivers/ide/piix.c
+++ b/drivers/ide/piix.c
@@ -8,8 +8,8 @@
  *
  * Documentation:
  *
- *	Publically available from Intel web site. Errata documentation
- * is also publically available. As an aide to anyone hacking on this
+ *	Publicly available from Intel web site. Errata documentation
+ * is also publicly available. As an aide to anyone hacking on this
  * driver the list of errata that are relevant is below.going back to
  * PIIX4. Older device documentation is now a bit tricky to find.
  *
diff --git a/drivers/ide/sis5513.c b/drivers/ide/sis5513.c
index db7f4e7..4a00225 100644
--- a/drivers/ide/sis5513.c
+++ b/drivers/ide/sis5513.c
@@ -53,7 +53,7 @@
 
 #define DRV_NAME "sis5513"
 
-/* registers layout and init values are chipset family dependant */
+/* registers layout and init values are chipset family dependent */
 
 #define ATA_16		0x01
 #define ATA_33		0x02
@@ -406,7 +406,7 @@ static int __devinit sis_find_family(struct pci_dev *dev)
 					pci_name(dev));
 				chipset_family = ATA_133;
 
-				/* Check for 5513 compability mapping
+				/* Check for 5513 compatibility mapping
 				 * We must use this, else the port enabled code will fail,
 				 * as it expects the enablebits at 0x4a.
 				 */
diff --git a/drivers/ide/triflex.c b/drivers/ide/triflex.c
index 7953447..e53a1b7 100644
--- a/drivers/ide/triflex.c
+++ b/drivers/ide/triflex.c
@@ -22,7 +22,7 @@
  * Loosely based on the piix & svwks drivers.
  *
  * Documentation:
- *	Not publically available.
+ *	Not publicly available.
  */
 
 #include <linux/types.h>
diff --git a/drivers/ide/via82cxxx.c b/drivers/ide/via82cxxx.c
index d2a0997..f46f49c 100644
--- a/drivers/ide/via82cxxx.c
+++ b/drivers/ide/via82cxxx.c
@@ -14,7 +14,7 @@
  *	Andre Hedrick
  *
  * Documentation:
- *	Obsolete device documentation publically available from via.com.tw
+ *	Obsolete device documentation publicly available from via.com.tw
  *	Current device documentation available under NDA only
  */
 
diff --git a/drivers/infiniband/hw/amso1100/c2_ae.c b/drivers/infiniband/hw/amso1100/c2_ae.c
index 62af742..24f9e3a 100644
--- a/drivers/infiniband/hw/amso1100/c2_ae.c
+++ b/drivers/infiniband/hw/amso1100/c2_ae.c
@@ -157,7 +157,7 @@ void c2_ae_event(struct c2_dev *c2dev, u32 mq_index)
 	int status;
 
 	/*
-	 * retreive the message
+	 * retrieve the message
 	 */
 	wr = c2_mq_consume(mq);
 	if (!wr)
diff --git a/drivers/infiniband/hw/amso1100/c2_qp.c b/drivers/infiniband/hw/amso1100/c2_qp.c
index d8f4bb8..0d7b6f23 100644
--- a/drivers/infiniband/hw/amso1100/c2_qp.c
+++ b/drivers/infiniband/hw/amso1100/c2_qp.c
@@ -612,7 +612,7 @@ void c2_free_qp(struct c2_dev *c2dev, struct c2_qp *qp)
 	c2_unlock_cqs(send_cq, recv_cq);
 
 	/*
-	 * Destory qp in the rnic...
+	 * Destroy qp in the rnic...
 	 */
 	destroy_qp(c2dev, qp);
 
diff --git a/drivers/infiniband/hw/amso1100/c2_wr.h b/drivers/infiniband/hw/amso1100/c2_wr.h
index c65fbdd..8d4b4ca 100644
--- a/drivers/infiniband/hw/amso1100/c2_wr.h
+++ b/drivers/infiniband/hw/amso1100/c2_wr.h
@@ -131,7 +131,7 @@ enum c2wr_ids {
 	 *          All the preceding IDs are fixed, and must not change.
 	 *          You can add new IDs, but must not remove or reorder
 	 *          any IDs. If you do, YOU will ruin any hope of
-	 *          compatability between versions.
+	 *          compatibility between versions.
 	 */
 	CCWR_LAST,
 
@@ -242,7 +242,7 @@ enum c2_acf {
 /*
  *  to fix bug 1815 we define the max size allowable of the
  *  terminate message (per the IETF spec).Refer to the IETF
- *  protocal specification, section 12.1.6, page 64)
+ *  protocol specification, section 12.1.6, page 64)
  *  The message is prefixed by 20 types of DDP info.
  *
  *  Then the message has 6 bytes for the terminate control
diff --git a/drivers/infiniband/hw/ipath/ipath_driver.c b/drivers/infiniband/hw/ipath/ipath_driver.c
index 47db4bf..58c0e41 100644
--- a/drivers/infiniband/hw/ipath/ipath_driver.c
+++ b/drivers/infiniband/hw/ipath/ipath_driver.c
@@ -2392,7 +2392,7 @@ void ipath_shutdown_device(struct ipath_devdata *dd)
 	/*
 	 * clear SerdesEnable and turn the leds off; do this here because
 	 * we are unloading, so don't count on interrupts to move along
-	 * Turn the LEDs off explictly for the same reason.
+	 * Turn the LEDs off explicitly for the same reason.
 	 */
 	dd->ipath_f_quiet_serdes(dd);
 
diff --git a/drivers/infiniband/hw/ipath/ipath_file_ops.c b/drivers/infiniband/hw/ipath/ipath_file_ops.c
index 6d4b29c..ee79a2d 100644
--- a/drivers/infiniband/hw/ipath/ipath_file_ops.c
+++ b/drivers/infiniband/hw/ipath/ipath_file_ops.c
@@ -1972,7 +1972,7 @@ static int ipath_do_user_init(struct file *fp,
 	 * 0 to 1.  So for those chips, we turn it off and then back on.
 	 * This will (very briefly) affect any other open ports, but the
 	 * duration is very short, and therefore isn't an issue.  We
-	 * explictly set the in-memory tail copy to 0 beforehand, so we
+	 * explicitly set the in-memory tail copy to 0 beforehand, so we
 	 * don't have to wait to be sure the DMA update has happened
 	 * (chip resets head/tail to 0 on transition to enable).
 	 */
diff --git a/drivers/infiniband/hw/ipath/ipath_init_chip.c b/drivers/infiniband/hw/ipath/ipath_init_chip.c
index fef0f42..7c1eebe 100644
--- a/drivers/infiniband/hw/ipath/ipath_init_chip.c
+++ b/drivers/infiniband/hw/ipath/ipath_init_chip.c
@@ -335,7 +335,7 @@ done:
  * @dd: the infinipath device
  *
  * sanity check at least some of the values after reset, and
- * ensure no receive or transmit (explictly, in case reset
+ * ensure no receive or transmit (explicitly, in case reset
  * failed
  */
 static int init_chip_reset(struct ipath_devdata *dd)
diff --git a/drivers/infiniband/hw/ipath/ipath_ud.c b/drivers/infiniband/hw/ipath/ipath_ud.c
index 7420715..e8a2a91 100644
--- a/drivers/infiniband/hw/ipath/ipath_ud.c
+++ b/drivers/infiniband/hw/ipath/ipath_ud.c
@@ -86,7 +86,7 @@ static void ipath_ud_loopback(struct ipath_qp *sqp, struct ipath_swqe *swqe)
 	}
 
 	/*
-	 * A GRH is expected to preceed the data even if not
+	 * A GRH is expected to precede the data even if not
 	 * present on the wire.
 	 */
 	length = swqe->length;
@@ -515,7 +515,7 @@ void ipath_ud_rcv(struct ipath_ibdev *dev, struct ipath_ib_header *hdr,
 	}
 
 	/*
-	 * A GRH is expected to preceed the data even if not
+	 * A GRH is expected to precede the data even if not
 	 * present on the wire.
 	 */
 	wc.byte_len = tlen + sizeof(struct ib_grh);
diff --git a/drivers/infiniband/hw/ipath/ipath_user_sdma.c b/drivers/infiniband/hw/ipath/ipath_user_sdma.c
index be78f66..f5cb13b 100644
--- a/drivers/infiniband/hw/ipath/ipath_user_sdma.c
+++ b/drivers/infiniband/hw/ipath/ipath_user_sdma.c
@@ -236,7 +236,7 @@ static int ipath_user_sdma_num_pages(const struct iovec *iov)
 	return 1 + ((epage - spage) >> PAGE_SHIFT);
 }
 
-/* truncate length to page boundry */
+/* truncate length to page boundary */
 static int ipath_user_sdma_page_length(unsigned long addr, unsigned long len)
 {
 	const unsigned long offset = addr & ~PAGE_MASK;
diff --git a/drivers/infiniband/hw/nes/nes_cm.c b/drivers/infiniband/hw/nes/nes_cm.c
index cfa3a2b..33c7eed 100644
--- a/drivers/infiniband/hw/nes/nes_cm.c
+++ b/drivers/infiniband/hw/nes/nes_cm.c
@@ -1397,7 +1397,7 @@ static void handle_fin_pkt(struct nes_cm_node *cm_node)
 		cleanup_retrans_entry(cm_node);
 		cm_node->state = NES_CM_STATE_CLOSING;
 		send_ack(cm_node, NULL);
-		/* Wait for ACK as this is simultanous close..
+		/* Wait for ACK as this is simultaneous close..
 		* After we receive ACK, do not send anything..
 		* Just rm the node.. Done.. */
 		break;
diff --git a/drivers/infiniband/hw/nes/nes_hw.c b/drivers/infiniband/hw/nes/nes_hw.c
index 08c1948..10d0a5e 100644
--- a/drivers/infiniband/hw/nes/nes_hw.c
+++ b/drivers/infiniband/hw/nes/nes_hw.c
@@ -80,7 +80,7 @@ static void nes_terminate_start_timer(struct nes_qp *nesqp);
 
 #ifdef CONFIG_INFINIBAND_NES_DEBUG
 static unsigned char *nes_iwarp_state_str[] = {
-	"Non-Existant",
+	"Non-Existent",
 	"Idle",
 	"RTS",
 	"Closing",
@@ -91,7 +91,7 @@ static unsigned char *nes_iwarp_state_str[] = {
 };
 
 static unsigned char *nes_tcp_state_str[] = {
-	"Non-Existant",
+	"Non-Existent",
 	"Closed",
 	"Listen",
 	"SYN Sent",
diff --git a/drivers/infiniband/hw/nes/nes_nic.c b/drivers/infiniband/hw/nes/nes_nic.c
index 2c9c193..e96b8fb 100644
--- a/drivers/infiniband/hw/nes/nes_nic.c
+++ b/drivers/infiniband/hw/nes/nes_nic.c
@@ -902,7 +902,7 @@ static void nes_netdev_set_multicast_list(struct net_device *netdev)
 		nes_write_indexed(nesdev, NES_IDX_NIC_UNICAST_ALL, nic_active);
 	}
 
-	nes_debug(NES_DBG_NIC_RX, "Number of MC entries = %d, Promiscous = %d, All Multicast = %d.\n",
+	nes_debug(NES_DBG_NIC_RX, "Number of MC entries = %d, Promiscuous = %d, All Multicast = %d.\n",
 		  mc_count, !!(netdev->flags & IFF_PROMISC),
 		  !!(netdev->flags & IFF_ALLMULTI));
 	if (!mc_all_on) {
diff --git a/drivers/infiniband/hw/qib/qib.h b/drivers/infiniband/hw/qib/qib.h
index 73225ee..769a1d9 100644
--- a/drivers/infiniband/hw/qib/qib.h
+++ b/drivers/infiniband/hw/qib/qib.h
@@ -653,7 +653,7 @@ struct diag_observer_list_elt;
 
 /* device data struct now contains only "general per-device" info.
  * fields related to a physical IB port are in a qib_pportdata struct,
- * described above) while fields only used by a particualr chip-type are in
+ * described above) while fields only used by a particular chip-type are in
  * a qib_chipdata struct, whose contents are opaque to this file.
  */
 struct qib_devdata {
diff --git a/drivers/infiniband/hw/qib/qib_file_ops.c b/drivers/infiniband/hw/qib/qib_file_ops.c
index 75bfad1..406fca5 100644
--- a/drivers/infiniband/hw/qib/qib_file_ops.c
+++ b/drivers/infiniband/hw/qib/qib_file_ops.c
@@ -1539,7 +1539,7 @@ done_chk_sdma:
 
 		/*
 		 * If process has NOT already set it's affinity, select and
-		 * reserve a processor for it, as a rendevous for all
+		 * reserve a processor for it, as a rendezvous for all
 		 * users of the driver.  If they don't actually later
 		 * set affinity to this cpu, or set it to some other cpu,
 		 * it just means that sooner or later we don't recommend
@@ -1657,7 +1657,7 @@ static int qib_do_user_init(struct file *fp,
 	 * 0 to 1.  So for those chips, we turn it off and then back on.
 	 * This will (very briefly) affect any other open ctxts, but the
 	 * duration is very short, and therefore isn't an issue.  We
-	 * explictly set the in-memory tail copy to 0 beforehand, so we
+	 * explicitly set the in-memory tail copy to 0 beforehand, so we
 	 * don't have to wait to be sure the DMA update has happened
 	 * (chip resets head/tail to 0 on transition to enable).
 	 */
diff --git a/drivers/infiniband/hw/qib/qib_iba6120.c b/drivers/infiniband/hw/qib/qib_iba6120.c
index 774dea8..7de4b7e 100644
--- a/drivers/infiniband/hw/qib/qib_iba6120.c
+++ b/drivers/infiniband/hw/qib/qib_iba6120.c
@@ -1799,7 +1799,7 @@ static int qib_6120_setup_reset(struct qib_devdata *dd)
 	/*
 	 * Keep chip from being accessed until we are ready.  Use
 	 * writeq() directly, to allow the write even though QIB_PRESENT
-	 * isnt' set.
+	 * isn't' set.
 	 */
 	dd->flags &= ~(QIB_INITTED | QIB_PRESENT);
 	dd->int_counter = 0; /* so we check interrupts work again */
@@ -2171,7 +2171,7 @@ static void rcvctrl_6120_mod(struct qib_pportdata *ppd, unsigned int op,
 		 * Init the context registers also; if we were
 		 * disabled, tail and head should both be zero
 		 * already from the enable, but since we don't
-		 * know, we have to do it explictly.
+		 * know, we have to do it explicitly.
 		 */
 		val = qib_read_ureg32(dd, ur_rcvegrindextail, ctxt);
 		qib_write_ureg(dd, ur_rcvegrindexhead, val, ctxt);
diff --git a/drivers/infiniband/hw/qib/qib_iba7220.c b/drivers/infiniband/hw/qib/qib_iba7220.c
index de799f1..74fe036 100644
--- a/drivers/infiniband/hw/qib/qib_iba7220.c
+++ b/drivers/infiniband/hw/qib/qib_iba7220.c
@@ -2111,7 +2111,7 @@ static int qib_setup_7220_reset(struct qib_devdata *dd)
 	/*
 	 * Keep chip from being accessed until we are ready.  Use
 	 * writeq() directly, to allow the write even though QIB_PRESENT
-	 * isnt' set.
+	 * isn't' set.
 	 */
 	dd->flags &= ~(QIB_INITTED | QIB_PRESENT);
 	dd->int_counter = 0; /* so we check interrupts work again */
@@ -2479,7 +2479,7 @@ static int qib_7220_set_ib_cfg(struct qib_pportdata *ppd, int which, u32 val)
 		 * we command the link down.  As with width, only write the
 		 * actual register if the link is currently down, otherwise
 		 * takes effect on next link change.  Since setting is being
-		 * explictly requested (via MAD or sysfs), clear autoneg
+		 * explicitly requested (via MAD or sysfs), clear autoneg
 		 * failure status if speed autoneg is enabled.
 		 */
 		ppd->link_speed_enabled = val;
@@ -2778,7 +2778,7 @@ static void rcvctrl_7220_mod(struct qib_pportdata *ppd, unsigned int op,
 		 * Init the context registers also; if we were
 		 * disabled, tail and head should both be zero
 		 * already from the enable, but since we don't
-		 * know, we have to do it explictly.
+		 * know, we have to do it explicitly.
 		 */
 		val = qib_read_ureg32(dd, ur_rcvegrindextail, ctxt);
 		qib_write_ureg(dd, ur_rcvegrindexhead, val, ctxt);
diff --git a/drivers/infiniband/hw/qib/qib_iba7322.c b/drivers/infiniband/hw/qib/qib_iba7322.c
index 4a2d21e..55de3cf 100644
--- a/drivers/infiniband/hw/qib/qib_iba7322.c
+++ b/drivers/infiniband/hw/qib/qib_iba7322.c
@@ -3299,7 +3299,7 @@ static int qib_do_7322_reset(struct qib_devdata *dd)
 	/*
 	 * Keep chip from being accessed until we are ready.  Use
 	 * writeq() directly, to allow the write even though QIB_PRESENT
-	 * isnt' set.
+	 * isn't' set.
 	 */
 	dd->flags &= ~(QIB_INITTED | QIB_PRESENT | QIB_BADINTR);
 	dd->flags |= QIB_DOING_RESET;
@@ -3727,7 +3727,7 @@ static int qib_7322_set_ib_cfg(struct qib_pportdata *ppd, int which, u32 val)
 		/*
 		 * As with width, only write the actual register if the
 		 * link is currently down, otherwise takes effect on next
-		 * link change.  Since setting is being explictly requested
+		 * link change.  Since setting is being explicitly requested
 		 * (via MAD or sysfs), clear autoneg failure status if speed
 		 * autoneg is enabled.
 		 */
@@ -4163,7 +4163,7 @@ static void rcvctrl_7322_mod(struct qib_pportdata *ppd, unsigned int op,
 		 * Init the context registers also; if we were
 		 * disabled, tail and head should both be zero
 		 * already from the enable, but since we don't
-		 * know, we have to do it explictly.
+		 * know, we have to do it explicitly.
 		 */
 		val = qib_read_ureg32(dd, ur_rcvegrindextail, ctxt);
 		qib_write_ureg(dd, ur_rcvegrindexhead, val, ctxt);
@@ -7483,7 +7483,7 @@ static int serdes_7322_init_new(struct qib_pportdata *ppd)
 	/*       Baseline Wander Correction Gain [13:4-0] (leave as default) */
 	/*       Baseline Wander Correction Gain [3:7-5] (leave as default) */
 	/*       Data Rate Select [5:7-6] (leave as default) */
-	/*       RX Parralel Word Width [3:10-8] (leave as default) */
+	/*       RX Parallel Word Width [3:10-8] (leave as default) */
 
 	/* RX REST */
 	/*       Single- or Multi-channel reset */
diff --git a/drivers/infiniband/hw/qib/qib_init.c b/drivers/infiniband/hw/qib/qib_init.c
index ffefb78..a01f3fc 100644
--- a/drivers/infiniband/hw/qib/qib_init.c
+++ b/drivers/infiniband/hw/qib/qib_init.c
@@ -346,7 +346,7 @@ done:
  * @dd: the qlogic_ib device
  *
  * sanity check at least some of the values after reset, and
- * ensure no receive or transmit (explictly, in case reset
+ * ensure no receive or transmit (explicitly, in case reset
  * failed
  */
 static int init_after_reset(struct qib_devdata *dd)
diff --git a/drivers/infiniband/hw/qib/qib_mad.h b/drivers/infiniband/hw/qib/qib_mad.h
index 147aff9..7840ab5 100644
--- a/drivers/infiniband/hw/qib/qib_mad.h
+++ b/drivers/infiniband/hw/qib/qib_mad.h
@@ -73,7 +73,7 @@ struct ib_mad_notice_attr {
 
 		struct {
 			__be16	reserved;
-			__be16	lid;		/* LID where change occured */
+			__be16	lid;		/* LID where change occurred */
 			u8	reserved2;
 			u8	local_changes;	/* low bit - local changes */
 			__be32	new_cap_mask;	/* new capability mask */
diff --git a/drivers/infiniband/hw/qib/qib_twsi.c b/drivers/infiniband/hw/qib/qib_twsi.c
index 6f31ca5..ddde72e 100644
--- a/drivers/infiniband/hw/qib/qib_twsi.c
+++ b/drivers/infiniband/hw/qib/qib_twsi.c
@@ -41,7 +41,7 @@
  * QLogic_IB "Two Wire Serial Interface" driver.
  * Originally written for a not-quite-i2c serial eeprom, which is
  * still used on some supported boards. Later boards have added a
- * variety of other uses, most board-specific, so teh bit-boffing
+ * variety of other uses, most board-specific, so the bit-boffing
  * part has been split off to this file, while the other parts
  * have been moved to chip-specific files.
  *
diff --git a/drivers/infiniband/hw/qib/qib_ud.c b/drivers/infiniband/hw/qib/qib_ud.c
index 4a51fd1..828609f 100644
--- a/drivers/infiniband/hw/qib/qib_ud.c
+++ b/drivers/infiniband/hw/qib/qib_ud.c
@@ -116,7 +116,7 @@ static void qib_ud_loopback(struct qib_qp *sqp, struct qib_swqe *swqe)
 	}
 
 	/*
-	 * A GRH is expected to preceed the data even if not
+	 * A GRH is expected to precede the data even if not
 	 * present on the wire.
 	 */
 	length = swqe->length;
@@ -520,7 +520,7 @@ void qib_ud_rcv(struct qib_ibport *ibp, struct qib_ib_header *hdr,
 		goto drop;
 
 	/*
-	 * A GRH is expected to preceed the data even if not
+	 * A GRH is expected to precede the data even if not
 	 * present on the wire.
 	 */
 	wc.byte_len = tlen + sizeof(struct ib_grh);
diff --git a/drivers/infiniband/hw/qib/qib_user_sdma.c b/drivers/infiniband/hw/qib/qib_user_sdma.c
index 66208bc..8244208 100644
--- a/drivers/infiniband/hw/qib/qib_user_sdma.c
+++ b/drivers/infiniband/hw/qib/qib_user_sdma.c
@@ -239,7 +239,7 @@ static int qib_user_sdma_num_pages(const struct iovec *iov)
 }
 
 /*
- * Truncate length to page boundry.
+ * Truncate length to page boundary.
  */
 static int qib_user_sdma_page_length(unsigned long addr, unsigned long len)
 {
diff --git a/drivers/infiniband/ulp/iser/iscsi_iser.h b/drivers/infiniband/ulp/iser/iscsi_iser.h
index f1df015..2f02ab0 100644
--- a/drivers/infiniband/ulp/iser/iscsi_iser.h
+++ b/drivers/infiniband/ulp/iser/iscsi_iser.h
@@ -91,7 +91,7 @@
 #define SIZE_4K	(1UL << SHIFT_4K)
 #define MASK_4K	(~(SIZE_4K-1))
 
-					/* support upto 512KB in one RDMA */
+					/* support up to 512KB in one RDMA */
 #define ISCSI_ISER_SG_TABLESIZE         (0x80000 >> SHIFT_4K)
 #define ISER_DEF_CMD_PER_LUN		128
 
diff --git a/drivers/input/joydev.c b/drivers/input/joydev.c
index 3182c9c..5688b5c 100644
--- a/drivers/input/joydev.c
+++ b/drivers/input/joydev.c
@@ -758,7 +758,7 @@ static void joydev_remove_chrdev(struct joydev *joydev)
 }
 
 /*
- * Mark device non-existant. This disables writes, ioctls and
+ * Mark device non-existent. This disables writes, ioctls and
  * prevents new users from opening the device. Already posted
  * blocking reads will stay, however new ones will fail.
  */
@@ -777,7 +777,7 @@ static void joydev_cleanup(struct joydev *joydev)
 	joydev_hangup(joydev);
 	joydev_remove_chrdev(joydev);
 
-	/* joydev is marked dead so noone else accesses joydev->open */
+	/* joydev is marked dead so no one else accesses joydev->open */
 	if (joydev->open)
 		input_close_device(handle);
 }
diff --git a/drivers/input/joystick/a3d.c b/drivers/input/joystick/a3d.c
index d259b41..1639ab2 100644
--- a/drivers/input/joystick/a3d.c
+++ b/drivers/input/joystick/a3d.c
@@ -3,7 +3,7 @@
  */
 
 /*
- * FP-Gaming Assasin 3D joystick driver for Linux
+ * FP-Gaming Assassin 3D joystick driver for Linux
  */
 
 /*
@@ -34,7 +34,7 @@
 #include <linux/input.h>
 #include <linux/jiffies.h>
 
-#define DRIVER_DESC	"FP-Gaming Assasin 3D joystick driver"
+#define DRIVER_DESC	"FP-Gaming Assassin 3D joystick driver"
 
 MODULE_AUTHOR("Vojtech Pavlik <vojtech@ucw.cz>");
 MODULE_DESCRIPTION(DRIVER_DESC);
diff --git a/drivers/input/keyboard/davinci_keyscan.c b/drivers/input/keyboard/davinci_keyscan.c
index a91ee94..cd89d17 100644
--- a/drivers/input/keyboard/davinci_keyscan.c
+++ b/drivers/input/keyboard/davinci_keyscan.c
@@ -5,7 +5,7 @@
  *
  * Author: Miguel Aguilar <miguel.aguilar@ridgerun.com>
  *
- * Intial Code: Sandeep Paulraj <s-paulraj@ti.com>
+ * Initial Code: Sandeep Paulraj <s-paulraj@ti.com>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
diff --git a/drivers/input/misc/adxl34x.c b/drivers/input/misc/adxl34x.c
index de5900d..144ddbd 100644
--- a/drivers/input/misc/adxl34x.c
+++ b/drivers/input/misc/adxl34x.c
@@ -716,7 +716,7 @@ struct adxl34x *adxl34x_probe(struct device *dev, int irq,
 	pdata = dev->platform_data;
 	if (!pdata) {
 		dev_dbg(dev,
-			"No platfrom data: Using default initialization\n");
+			"No platform data: Using default initialization\n");
 		pdata = &adxl34x_default_init;
 	}
 
diff --git a/drivers/input/misc/keyspan_remote.c b/drivers/input/misc/keyspan_remote.c
index a93c525..fc62256 100644
--- a/drivers/input/misc/keyspan_remote.c
+++ b/drivers/input/misc/keyspan_remote.c
@@ -312,7 +312,7 @@ static void keyspan_check_data(struct usb_keyspan *remote)
 			remote->data.tester = remote->data.tester >> 5;
 			remote->data.bits_left -= 5;
 		} else {
-			err("Bad message recieved, no stop bit found.\n");
+			err("Bad message received, no stop bit found.\n");
 		}
 
 		dev_dbg(&remote->udev->dev,
diff --git a/drivers/input/misc/wistron_btns.c b/drivers/input/misc/wistron_btns.c
index 12501de..52b4193 100644
--- a/drivers/input/misc/wistron_btns.c
+++ b/drivers/input/misc/wistron_btns.c
@@ -274,7 +274,7 @@ static struct key_entry keymap_fs_amilo_pro_v3505[] __initdata = {
 	{ KE_BLUETOOTH, 0x30 },                      /* Fn+F10 */
 	{ KE_KEY,       0x31, {KEY_MAIL} },          /* mail button */
 	{ KE_KEY,       0x36, {KEY_WWW} },           /* www button */
-	{ KE_WIFI,      0x78 },                      /* satelite dish button */
+	{ KE_WIFI,      0x78 },                      /* satellite dish button */
 	{ KE_END,       0 }
 };
 
diff --git a/drivers/input/mouse/bcm5974.c b/drivers/input/mouse/bcm5974.c
index 3aead91..3126983 100644
--- a/drivers/input/mouse/bcm5974.c
+++ b/drivers/input/mouse/bcm5974.c
@@ -639,7 +639,7 @@ exit:
  * device, resulting in trackpad malfunction under certain
  * circumstances. To get around this problem, there is at least one
  * example that utilizes the USB_QUIRK_RESET_RESUME quirk in order to
- * recieve a reset_resume request rather than the normal resume.
+ * receive a reset_resume request rather than the normal resume.
  * Since the implementation of reset_resume is equal to mode switch
  * plus start_traffic, it seems easier to always do the switch when
  * starting traffic on the device.
diff --git a/drivers/input/mouse/synaptics_i2c.c b/drivers/input/mouse/synaptics_i2c.c
index f6aa26d..cba3c84 100644
--- a/drivers/input/mouse/synaptics_i2c.c
+++ b/drivers/input/mouse/synaptics_i2c.c
@@ -462,7 +462,7 @@ static void synaptics_i2c_work_handler(struct work_struct *work)
 	 * While interrupt driven, there is no real need to poll the device.
 	 * But touchpads are very sensitive, so there could be errors
 	 * related to physical environment and the attention line isn't
-	 * neccesarily asserted. In such case we can lose the touchpad.
+	 * necessarily asserted. In such case we can lose the touchpad.
 	 * We poll the device once in THREAD_IRQ_SLEEP_SECS and
 	 * if error is detected, we try to reset and reconfigure the touchpad.
 	 */
diff --git a/drivers/input/mouse/vsxxxaa.c b/drivers/input/mouse/vsxxxaa.c
index bf2c0c8..eb9a3cf 100644
--- a/drivers/input/mouse/vsxxxaa.c
+++ b/drivers/input/mouse/vsxxxaa.c
@@ -334,7 +334,7 @@ static void vsxxxaa_handle_POR_packet(struct vsxxxaa *mouse)
 	 * M: manufacturer location code
 	 * R: revision code
 	 * E: Error code. If it's in the range of 0x00..0x1f, only some
-	 *    minor problem occured. Errors >= 0x20 are considered bad
+	 *    minor problem occurred. Errors >= 0x20 are considered bad
 	 *    and the device may not work properly...
 	 * D: <0010> == mouse, <0100> == tablet
 	 */
diff --git a/drivers/input/serio/hp_sdc.c b/drivers/input/serio/hp_sdc.c
index 8c0b51c..4220620 100644
--- a/drivers/input/serio/hp_sdc.c
+++ b/drivers/input/serio/hp_sdc.c
@@ -955,7 +955,7 @@ static int __init hp_sdc_init_hppa(struct parisc_device *d)
 	INIT_DELAYED_WORK(&moduleloader_work, request_module_delayed);
 
 	ret = hp_sdc_init();
-	/* after successfull initialization give SDC some time to settle
+	/* after successful initialization give SDC some time to settle
 	 * and then load the hp_sdc_mlc upper layer driver */
 	if (!ret)
 		schedule_delayed_work(&moduleloader_work,
diff --git a/drivers/input/serio/xilinx_ps2.c b/drivers/input/serio/xilinx_ps2.c
index 7540baf..80baa53 100644
--- a/drivers/input/serio/xilinx_ps2.c
+++ b/drivers/input/serio/xilinx_ps2.c
@@ -225,7 +225,7 @@ static void sxps2_close(struct serio *pserio)
 /**
  * xps2_of_probe - probe method for the PS/2 device.
  * @of_dev:	pointer to OF device structure
- * @match:	pointer to the stucture used for matching a device
+ * @match:	pointer to the structure used for matching a device
  *
  * This function probes the PS/2 device in the device tree.
  * It initializes the driver data structure and the hardware.
diff --git a/drivers/input/touchscreen/intel-mid-touch.c b/drivers/input/touchscreen/intel-mid-touch.c
index c0307b2..66c96bf 100644
--- a/drivers/input/touchscreen/intel-mid-touch.c
+++ b/drivers/input/touchscreen/intel-mid-touch.c
@@ -542,7 +542,7 @@ static int __devinit mrstouch_adc_init(struct mrstouch_dev *tsdev)
 	 * ADC power on, start, enable PENDET and set loop delay
 	 * ADC loop delay is set to 4.5 ms approximately
 	 * Loop delay more than this results in jitter in adc readings
-	 * Setting loop delay to 0 (continous loop) in MAXIM stops PENDET
+	 * Setting loop delay to 0 (continuous loop) in MAXIM stops PENDET
 	 * interrupt generation sometimes.
 	 */
 
diff --git a/drivers/input/touchscreen/ucb1400_ts.c b/drivers/input/touchscreen/ucb1400_ts.c
index 028a536..3b5b5df 100644
--- a/drivers/input/touchscreen/ucb1400_ts.c
+++ b/drivers/input/touchscreen/ucb1400_ts.c
@@ -6,7 +6,7 @@
  *  Copyright:	MontaVista Software, Inc.
  *
  * Spliting done by: Marek Vasut <marek.vasut@gmail.com>
- * If something doesnt work and it worked before spliting, e-mail me,
+ * If something doesn't work and it worked before spliting, e-mail me,
  * dont bother Nicolas please ;-)
  *
  * This program is free software; you can redistribute it and/or modify
diff --git a/drivers/input/touchscreen/wm9705.c b/drivers/input/touchscreen/wm9705.c
index 6b5be74..98e6117 100644
--- a/drivers/input/touchscreen/wm9705.c
+++ b/drivers/input/touchscreen/wm9705.c
@@ -306,7 +306,7 @@ static int wm9705_acc_enable(struct wm97xx *wm, int enable)
 	dig2 = wm->dig[2];
 
 	if (enable) {
-		/* continous mode */
+		/* continuous mode */
 		if (wm->mach_ops->acc_startup &&
 		    (ret = wm->mach_ops->acc_startup(wm)) < 0)
 			return ret;
diff --git a/drivers/input/touchscreen/wm9712.c b/drivers/input/touchscreen/wm9712.c
index 7490b05..2bc2fb8 100644
--- a/drivers/input/touchscreen/wm9712.c
+++ b/drivers/input/touchscreen/wm9712.c
@@ -419,7 +419,7 @@ static int wm9712_acc_enable(struct wm97xx *wm, int enable)
 	dig2 = wm->dig[2];
 
 	if (enable) {
-		/* continous mode */
+		/* continuous mode */
 		if (wm->mach_ops->acc_startup) {
 			ret = wm->mach_ops->acc_startup(wm);
 			if (ret < 0)
diff --git a/drivers/input/touchscreen/wm9713.c b/drivers/input/touchscreen/wm9713.c
index 238b513..73ec995 100644
--- a/drivers/input/touchscreen/wm9713.c
+++ b/drivers/input/touchscreen/wm9713.c
@@ -431,7 +431,7 @@ static int wm9713_acc_enable(struct wm97xx *wm, int enable)
 	dig3 = wm->dig[2];
 
 	if (enable) {
-		/* continous mode */
+		/* continuous mode */
 		if (wm->mach_ops->acc_startup &&
 			(ret = wm->mach_ops->acc_startup(wm)) < 0)
 			return ret;
diff --git a/drivers/input/touchscreen/wm97xx-core.c b/drivers/input/touchscreen/wm97xx-core.c
index 6b75c9f..5dbe73a 100644
--- a/drivers/input/touchscreen/wm97xx-core.c
+++ b/drivers/input/touchscreen/wm97xx-core.c
@@ -335,7 +335,7 @@ static void wm97xx_pen_irq_worker(struct work_struct *work)
 	 */
 	if (!wm->mach_ops->acc_enabled || wm->mach_ops->acc_pen_down) {
 		if (wm->pen_is_down && !pen_was_down) {
-			/* Data is not availiable immediately on pen down */
+			/* Data is not available immediately on pen down */
 			queue_delayed_work(wm->ts_workq, &wm->ts_reader, 1);
 		}
 
@@ -354,7 +354,7 @@ static void wm97xx_pen_irq_worker(struct work_struct *work)
  * Codec PENDOWN irq handler
  *
  * We have to disable the codec interrupt in the handler because it
- * can take upto 1ms to clear the interrupt source. We schedule a task
+ * can take up to 1ms to clear the interrupt source. We schedule a task
  * in a work queue to do the actual interaction with the chip.  The
  * interrupt is then enabled again in the slow handler when the source
  * has been cleared.
diff --git a/drivers/isdn/hardware/eicon/divacapi.h b/drivers/isdn/hardware/eicon/divacapi.h
index 9f5b680..e330da0 100644
--- a/drivers/isdn/hardware/eicon/divacapi.h
+++ b/drivers/isdn/hardware/eicon/divacapi.h
@@ -673,7 +673,7 @@ struct async_s {
 
 
 /*------------------------------------------------------------------*/
-/* auxilliary states for supplementary services                     */
+/* auxiliary states for supplementary services                     */
 /*------------------------------------------------------------------*/
 
 #define IDLE                0
diff --git a/drivers/isdn/hardware/eicon/io.h b/drivers/isdn/hardware/eicon/io.h
index 0c6c650..a6f1755 100644
--- a/drivers/isdn/hardware/eicon/io.h
+++ b/drivers/isdn/hardware/eicon/io.h
@@ -60,7 +60,7 @@ typedef struct _diva_xdi_capi_cfg {
   -------------------------------------------------------------------------- */
 struct _ISDN_ADAPTER {
  void             (* DIRequest)(PISDN_ADAPTER, ENTITY *) ;
- int                 State ; /* from NT4 1.srv, a good idea, but  a poor achievment */
+ int                 State ; /* from NT4 1.srv, a good idea, but  a poor achievement */
  int                 Initialized ;
  int         RegisteredWithDidd ;
  int                 Unavailable ;  /* callback function possible? */
diff --git a/drivers/isdn/hardware/eicon/message.c b/drivers/isdn/hardware/eicon/message.c
index 341ef17..8c5c563 100644
--- a/drivers/isdn/hardware/eicon/message.c
+++ b/drivers/isdn/hardware/eicon/message.c
@@ -2639,7 +2639,7 @@ static byte connect_b3_req(dword Id, word Number, DIVA_CAPI_ADAPTER *a,
     }
     else
     {
-      /* local reply if assign unsuccessfull
+      /* local reply if assign unsuccessful
          or B3 protocol allows only one layer 3 connection
            and already connected
              or B2 protocol not any LAPD
@@ -8189,7 +8189,7 @@ static word add_b23(PLCI *plci, API_PARSE *bp)
       dlc[ 0] = 15;
       if(b2_config->length >= 8) { /* PIAFS control abilities */
         dlc[ 7] = 10; 
-        dlc[16] = 2; /* Length of PIAFS extention */
+        dlc[16] = 2; /* Length of PIAFS extension */
         dlc[17] = PIAFS_UDATA_ABILITIES; /* control (UDATA) ability */
         dlc[18] = b2_config_parms[4].info[0]; /* value */
         dlc[ 0] = 18;
diff --git a/drivers/isdn/hardware/eicon/pc.h b/drivers/isdn/hardware/eicon/pc.h
index 1c69457..bf6b018 100644
--- a/drivers/isdn/hardware/eicon/pc.h
+++ b/drivers/isdn/hardware/eicon/pc.h
@@ -701,7 +701,7 @@ Byte | 8 7 6 5 4 3 2 1
 #define PROTCAP_FREE12    0x1000  /* not used                            */
 #define PROTCAP_FREE13    0x2000  /* not used                            */
 #define PROTCAP_FREE14    0x4000  /* not used                            */
-#define PROTCAP_EXTENSION 0x8000  /* used for future extentions          */
+#define PROTCAP_EXTENSION 0x8000  /* used for future extensions          */
 /* -----------------------------------------------------------* */
 /* Onhook data transmission ETS30065901 */
 /* Message Type */
diff --git a/drivers/isdn/hardware/eicon/um_idi.c b/drivers/isdn/hardware/eicon/um_idi.c
index 6563db9..ac0bdd1 100644
--- a/drivers/isdn/hardware/eicon/um_idi.c
+++ b/drivers/isdn/hardware/eicon/um_idi.c
@@ -363,7 +363,7 @@ int diva_um_idi_read(void *entity,
 
 		if ((ret = (*cp_fn) (os_handle, dst, data, length)) >= 0) {
 			/*
-			   Acknowledge only if read was successfull
+			   Acknowledge only if read was successful
 			 */
 			diva_data_q_ack_segment4read(q);
 		}
diff --git a/drivers/isdn/hardware/mISDN/hfcmulti.c b/drivers/isdn/hardware/mISDN/hfcmulti.c
index 4e3780d..f6f3c87 100644
--- a/drivers/isdn/hardware/mISDN/hfcmulti.c
+++ b/drivers/isdn/hardware/mISDN/hfcmulti.c
@@ -118,7 +118,7 @@
  *	-> See hfc_multi.h for HFC_IO_MODE_* values
  *	By default, the IO mode is pci memory IO (MEMIO).
  *	Some cards require specific IO mode, so it cannot be changed.
- *	It may be usefull to set IO mode to register io (REGIO) to solve
+ *	It may be useful to set IO mode to register io (REGIO) to solve
  *	PCI bridge problems.
  *	If unsure, don't give this parameter.
  *
@@ -903,7 +903,7 @@ vpm_echocan_off(struct hfc_multi *hc, int ch)
 /*
  * Speech Design resync feature
  * NOTE: This is called sometimes outside interrupt handler.
- * We must lock irqsave, so no other interrupt (other card) will occurr!
+ * We must lock irqsave, so no other interrupt (other card) will occur!
  * Also multiple interrupts may nest, so must lock each access (lists, card)!
  */
 static inline void
diff --git a/drivers/isdn/hardware/mISDN/hfcpci.c b/drivers/isdn/hardware/mISDN/hfcpci.c
index 15d323b..4343aba 100644
--- a/drivers/isdn/hardware/mISDN/hfcpci.c
+++ b/drivers/isdn/hardware/mISDN/hfcpci.c
@@ -272,7 +272,7 @@ reset_hfcpci(struct hfc_pci *hc)
 	 * D- and monitor/CI channel are not enabled
 	 * STIO1 is used as output for data, B1+B2 from ST->IOM+HFC
 	 * STIO2 is used as data input, B1+B2 from IOM->ST
-	 * ST B-channel send disabled -> continous 1s
+	 * ST B-channel send disabled -> continuous 1s
 	 * The IOM slots are always enabled
 	 */
 	if (test_bit(HFC_CFG_PCM, &hc->cfg)) {
diff --git a/drivers/isdn/hisax/hfc_pci.c b/drivers/isdn/hisax/hfc_pci.c
index 3147020..0cb0546 100644
--- a/drivers/isdn/hisax/hfc_pci.c
+++ b/drivers/isdn/hisax/hfc_pci.c
@@ -146,7 +146,7 @@ reset_hfcpci(struct IsdnCardState *cs)
 	/* D- and monitor/CI channel are not enabled */
 	/* STIO1 is used as output for data, B1+B2 from ST->IOM+HFC */
 	/* STIO2 is used as data input, B1+B2 from IOM->ST */
-	/* ST B-channel send disabled -> continous 1s */
+	/* ST B-channel send disabled -> continuous 1s */
 	/* The IOM slots are always enabled */
 	cs->hw.hfcpci.conn = 0x36;	/* set data flow directions */
 	Write_hfc(cs, HFCPCI_CONNECT, cs->hw.hfcpci.conn);
diff --git a/drivers/isdn/hisax/hfc_sx.c b/drivers/isdn/hisax/hfc_sx.c
index 1235b71..156d7c6 100644
--- a/drivers/isdn/hisax/hfc_sx.c
+++ b/drivers/isdn/hisax/hfc_sx.c
@@ -399,7 +399,7 @@ reset_hfcsx(struct IsdnCardState *cs)
 	/* D- and monitor/CI channel are not enabled */
 	/* STIO1 is used as output for data, B1+B2 from ST->IOM+HFC */
 	/* STIO2 is used as data input, B1+B2 from IOM->ST */
-	/* ST B-channel send disabled -> continous 1s */
+	/* ST B-channel send disabled -> continuous 1s */
 	/* The IOM slots are always enabled */
 	cs->hw.hfcsx.conn = 0x36;	/* set data flow directions */
 	Write_hfc(cs, HFCSX_CONNECT, cs->hw.hfcsx.conn);
diff --git a/drivers/isdn/hisax/hfc_usb.h b/drivers/isdn/hisax/hfc_usb.h
index e79f565..2f581c0 100644
--- a/drivers/isdn/hisax/hfc_usb.h
+++ b/drivers/isdn/hisax/hfc_usb.h
@@ -126,7 +126,7 @@ static struct hfcusb_symbolic_list urb_errlist[] = {
 
 
 /*
- * device dependant information to support different
+ * device dependent information to support different
  * ISDN Ta's using the HFC-S USB chip
  */
 
diff --git a/drivers/isdn/hisax/l3dss1.c b/drivers/isdn/hisax/l3dss1.c
index cc6ee2d..8e2fd02 100644
--- a/drivers/isdn/hisax/l3dss1.c
+++ b/drivers/isdn/hisax/l3dss1.c
@@ -1595,7 +1595,7 @@ l3dss1_setup(struct l3_process *pc, u_char pr, void *arg)
 	 * Bearer Capabilities
 	 */
 	p = skb->data;
-	/* only the first occurence 'll be detected ! */
+	/* only the first occurrence 'll be detected ! */
 	if ((p = findie(p, skb->len, 0x04, 0))) {
 		if ((p[1] < 2) || (p[1] > 11))
 			err = 1;
@@ -2161,7 +2161,7 @@ static void l3dss1_redir_req_early(struct l3_process *pc, u_char pr, void *arg)
 
 /***********************************************/
 /* handle special commands for this protocol.  */
-/* Examples are call independant services like */
+/* Examples are call independent services like */
 /* remote operations with dummy  callref.      */
 /***********************************************/
 static int l3dss1_cmd_global(struct PStack *st, isdn_ctrl *ic)
diff --git a/drivers/isdn/hisax/l3ni1.c b/drivers/isdn/hisax/l3ni1.c
index f958449..7b229c0 100644
--- a/drivers/isdn/hisax/l3ni1.c
+++ b/drivers/isdn/hisax/l3ni1.c
@@ -1449,7 +1449,7 @@ l3ni1_setup(struct l3_process *pc, u_char pr, void *arg)
 	 * Bearer Capabilities
 	 */
 	p = skb->data;
-	/* only the first occurence 'll be detected ! */
+	/* only the first occurrence 'll be detected ! */
 	if ((p = findie(p, skb->len, 0x04, 0))) {
 		if ((p[1] < 2) || (p[1] > 11))
 			err = 1;
@@ -2017,7 +2017,7 @@ static void l3ni1_redir_req_early(struct l3_process *pc, u_char pr, void *arg)
 
 /***********************************************/
 /* handle special commands for this protocol.  */
-/* Examples are call independant services like */
+/* Examples are call independent services like */
 /* remote operations with dummy  callref.      */
 /***********************************************/
 static int l3ni1_cmd_global(struct PStack *st, isdn_ctrl *ic)
diff --git a/drivers/isdn/hisax/nj_s.c b/drivers/isdn/hisax/nj_s.c
index 2344e7b..a1b8952 100644
--- a/drivers/isdn/hisax/nj_s.c
+++ b/drivers/isdn/hisax/nj_s.c
@@ -167,7 +167,7 @@ static int __devinit njs_pci_probe(struct pci_dev *dev_netjet,
 		return(0);
 	}
 	/* the TJ300 and TJ320 must be detected, the IRQ handling is different
-	 * unfortunatly the chips use the same device ID, but the TJ320 has
+	 * unfortunately the chips use the same device ID, but the TJ320 has
 	 * the bit20 in status PCI cfg register set
 	 */
 	pci_read_config_dword(dev_netjet, 0x04, &cfg);
diff --git a/drivers/isdn/hisax/st5481_b.c b/drivers/isdn/hisax/st5481_b.c
index e56e5af..ed4bc56 100644
--- a/drivers/isdn/hisax/st5481_b.c
+++ b/drivers/isdn/hisax/st5481_b.c
@@ -124,7 +124,7 @@ static void usb_b_out(struct st5481_bcs *bcs,int buf_nr)
 }
 
 /*
- * Start transfering (flags or data) on the B channel, since
+ * Start transferring (flags or data) on the B channel, since
  * FIFO counters has been set to a non-zero value.
  */
 static void st5481B_start_xfer(void *context)
diff --git a/drivers/isdn/hisax/st5481_usb.c b/drivers/isdn/hisax/st5481_usb.c
index 10d41c5..159e8fa 100644
--- a/drivers/isdn/hisax/st5481_usb.c
+++ b/drivers/isdn/hisax/st5481_usb.c
@@ -470,7 +470,7 @@ void st5481_release_isocpipes(struct urb* urb[2])
 
 /*
  * Decode frames received on the B/D channel.
- * Note that this function will be called continously
+ * Note that this function will be called continuously
  * with 64Kbit/s / 16Kbit/s of data and hence it will be 
  * called 50 times per second with 20 ISOC descriptors. 
  * Called at interrupt.
diff --git a/drivers/isdn/hisax/teles_cs.c b/drivers/isdn/hisax/teles_cs.c
index 282a446..aa25e18 100644
--- a/drivers/isdn/hisax/teles_cs.c
+++ b/drivers/isdn/hisax/teles_cs.c
@@ -9,7 +9,7 @@
     Also inspired by ELSA PCMCIA driver 
     by Klaus Lichtenwalder <Lichtenwalder@ACM.org>
     
-    Extentions to new hisax_pcmcia by Karsten Keil
+    Extensions to new hisax_pcmcia by Karsten Keil
 
     minor changes to be compatible with kernel 2.4.x
     by Jan.Schubert@GMX.li
diff --git a/drivers/isdn/hysdn/hysdn_sched.c b/drivers/isdn/hysdn/hysdn_sched.c
index 81db4a1..3674d30 100644
--- a/drivers/isdn/hysdn/hysdn_sched.c
+++ b/drivers/isdn/hysdn/hysdn_sched.c
@@ -143,7 +143,7 @@ hysdn_sched_tx(hysdn_card *card, unsigned char *buf,
 /* send one config line to the card and return 0 if successful, otherwise a */
 /* negative error code.                                                      */
 /* The function works with timeouts perhaps not giving the greatest speed    */
-/* sending the line, but this should be meaningless beacuse only some lines  */
+/* sending the line, but this should be meaningless because only some lines  */
 /* are to be sent and this happens very seldom.                              */
 /*****************************************************************************/
 int
diff --git a/drivers/isdn/i4l/isdn_net.c b/drivers/isdn/i4l/isdn_net.c
index afeede7..2a7d17c 100644
--- a/drivers/isdn/i4l/isdn_net.c
+++ b/drivers/isdn/i4l/isdn_net.c
@@ -1530,7 +1530,7 @@ isdn_net_ciscohdlck_slarp_send_keepalive(unsigned long data)
 		printk (KERN_WARNING
 				"UPDOWN: Line protocol on Interface %s,"
 				" changed state to down\n", lp->netdev->dev->name);
-		/* should stop routing higher-level data accross */
+		/* should stop routing higher-level data across */
 	} else if ((!lp->cisco_line_state) &&
 		(myseq_diff >= 0) && (myseq_diff <= 2)) {
 		/* line down -> up */
@@ -1538,7 +1538,7 @@ isdn_net_ciscohdlck_slarp_send_keepalive(unsigned long data)
 		printk (KERN_WARNING
 				"UPDOWN: Line protocol on Interface %s,"
 				" changed state to up\n", lp->netdev->dev->name);
-		/* restart routing higher-level data accross */
+		/* restart routing higher-level data across */
 	}
 
 	if (lp->cisco_debserint)
diff --git a/drivers/isdn/i4l/isdn_ppp.c b/drivers/isdn/i4l/isdn_ppp.c
index 9e8162c..1b002b0 100644
--- a/drivers/isdn/i4l/isdn_ppp.c
+++ b/drivers/isdn/i4l/isdn_ppp.c
@@ -1514,7 +1514,7 @@ int isdn_ppp_autodial_filter(struct sk_buff *skb, isdn_net_local *lp)
 #define MP_LONGSEQ_MAXBIT	((MP_LONGSEQ_MASK+1)>>1)
 #define MP_SHORTSEQ_MAXBIT	((MP_SHORTSEQ_MASK+1)>>1)
 
-/* sequence-wrap safe comparisions (for long sequence)*/ 
+/* sequence-wrap safe comparisons (for long sequence)*/
 #define MP_LT(a,b)	((a-b)&MP_LONGSEQ_MAXBIT)
 #define MP_LE(a,b) 	!((b-a)&MP_LONGSEQ_MAXBIT)
 #define MP_GT(a,b) 	((b-a)&MP_LONGSEQ_MAXBIT)
@@ -1746,7 +1746,7 @@ static void isdn_ppp_mp_receive(isdn_net_dev * net_dev, isdn_net_local * lp,
 		 * then next fragment should be the start of new reassembly
 		 * if sequence is contiguous, but we haven't reassembled yet,
 		 * keep going.
-		 * if sequence is not contiguous, either clear everyting
+		 * if sequence is not contiguous, either clear everything
 		 * below low watermark and set start to the next frag or
 		 * clear start ptr.
 		 */ 
diff --git a/drivers/isdn/i4l/isdn_tty.c b/drivers/isdn/i4l/isdn_tty.c
index 3d88f15..607d846 100644
--- a/drivers/isdn/i4l/isdn_tty.c
+++ b/drivers/isdn/i4l/isdn_tty.c
@@ -792,7 +792,7 @@ isdn_tty_suspend(char *id, modem_info * info, atemu * m)
 }
 
 /* isdn_tty_resume() tries to resume a suspended call
- * setup of the lower levels before that. unfortunatly here is no
+ * setup of the lower levels before that. unfortunately here is no
  * checking for compatibility of used protocols implemented by Q931
  * It does the same things like isdn_tty_dial, the last command
  * is different, may be we can merge it.
diff --git a/drivers/isdn/isdnloop/isdnloop.c b/drivers/isdn/isdnloop/isdnloop.c
index b8a1098..d497db0 100644
--- a/drivers/isdn/isdnloop/isdnloop.c
+++ b/drivers/isdn/isdnloop/isdnloop.c
@@ -954,7 +954,7 @@ isdnloop_parse_cmd(isdnloop_card * card)
 /*
  * Put command-strings into the of the 'card'. In reality, execute them
  * right in place by calling isdnloop_parse_cmd(). Also copy every
- * command to the read message ringbuffer, preceeding it with a '>'.
+ * command to the read message ringbuffer, preceding it with a '>'.
  * These mesagges can be read at /dev/isdnctrl.
  *
  * Parameter:
diff --git a/drivers/isdn/mISDN/dsp.h b/drivers/isdn/mISDN/dsp.h
index 18af868..8549431 100644
--- a/drivers/isdn/mISDN/dsp.h
+++ b/drivers/isdn/mISDN/dsp.h
@@ -21,7 +21,7 @@
 /* options may be:
  *
  * bit 0 = use ulaw instead of alaw
- * bit 1 = enable hfc hardware accelleration for all channels
+ * bit 1 = enable hfc hardware acceleration for all channels
  *
  */
 #define DSP_OPT_ULAW		(1<<0)
diff --git a/drivers/isdn/mISDN/dsp_cmx.c b/drivers/isdn/mISDN/dsp_cmx.c
index 309bacf..4d395de 100644
--- a/drivers/isdn/mISDN/dsp_cmx.c
+++ b/drivers/isdn/mISDN/dsp_cmx.c
@@ -1513,7 +1513,7 @@ dsp_cmx_send_member(struct dsp *dsp, int len, s32 *c, int members)
 	/* -> if echo is NOT enabled */
 	if (!dsp->echo.software) {
 		/*
-		 * -> substract rx-data from conf-data,
+		 * -> subtract rx-data from conf-data,
 		 * if tx-data is available, mix
 		 */
 		while (r != rr && t != tt) {
@@ -1572,7 +1572,7 @@ dsp_cmx_send_member(struct dsp *dsp, int len, s32 *c, int members)
 send_packet:
 	/*
 	 * send tx-data if enabled - don't filter,
-	 * becuase we want what we send, not what we filtered
+	 * because we want what we send, not what we filtered
 	 */
 	if (dsp->tx_data) {
 		if (tx_data_only) {
diff --git a/drivers/isdn/mISDN/dsp_core.c b/drivers/isdn/mISDN/dsp_core.c
index 6f5b548..2877291 100644
--- a/drivers/isdn/mISDN/dsp_core.c
+++ b/drivers/isdn/mISDN/dsp_core.c
@@ -115,7 +115,7 @@
  *
  * The CMX has special functions for conferences with one, two and more
  * members. It will allow different types of data flow. Receive and transmit
- * data to/form upper layer may be swithed on/off individually without loosing
+ * data to/form upper layer may be swithed on/off individually without losing
  * features of CMX, Tones and DTMF.
  *
  * Echo Cancellation: Sometimes we like to cancel echo from the interface.
@@ -127,9 +127,9 @@
  *
  * If all used features can be realized in hardware, and if transmit and/or
  * receive data ist disabled, the card may not send/receive any data at all.
- * Not receiving is usefull if only announcements are played. Not sending is
- * usefull if an answering machine records audio. Not sending and receiving is
- * usefull during most states of the call. If supported by hardware, tones
+ * Not receiving is useful if only announcements are played. Not sending is
+ * useful if an answering machine records audio. Not sending and receiving is
+ * useful during most states of the call. If supported by hardware, tones
  * will be played without cpu load. Small PBXs and NT-Mode applications will
  * not need expensive hardware when processing calls.
  *
diff --git a/drivers/isdn/mISDN/dsp_dtmf.c b/drivers/isdn/mISDN/dsp_dtmf.c
index 9ae2d33..5b484c3 100644
--- a/drivers/isdn/mISDN/dsp_dtmf.c
+++ b/drivers/isdn/mISDN/dsp_dtmf.c
@@ -106,7 +106,7 @@ void dsp_dtmf_hardware(struct dsp *dsp)
  * tested it allot. it even works with very short tones (40ms). the only
  * disadvantage is, that it doesn't work good with different volumes of both
  * tones. this will happen, if accoustically coupled dialers are used.
- * it sometimes detects tones during speach, which is normal for decoders.
+ * it sometimes detects tones during speech, which is normal for decoders.
  * use sequences to given commands during calls.
  *
  * dtmf - points to a structure of the current dtmf state
@@ -244,7 +244,7 @@ coefficients:
 		if (result[i] < tresh) {
 			lowgroup = -1;
 			highgroup = -1;
-			break;  /* noise inbetween */
+			break;  /* noise in between */
 		}
 		/* good level found. This is allowed only one time per group */
 		if (i < NCOEFF/2) {
diff --git a/drivers/isdn/mISDN/dsp_tones.c b/drivers/isdn/mISDN/dsp_tones.c
index 7dbe54e..4e4440e 100644
--- a/drivers/isdn/mISDN/dsp_tones.c
+++ b/drivers/isdn/mISDN/dsp_tones.c
@@ -394,7 +394,7 @@ void dsp_tone_copy(struct dsp *dsp, u8 *data, int len)
 	while (len) {
 		/* find sample to start with */
 		while (42) {
-			/* warp arround */
+			/* wrap around */
 			if (!pat->seq[index]) {
 				count = 0;
 				index = 0;
diff --git a/drivers/isdn/mISDN/l1oip_core.c b/drivers/isdn/mISDN/l1oip_core.c
index bd526f6..22f8ec8 100644
--- a/drivers/isdn/mISDN/l1oip_core.c
+++ b/drivers/isdn/mISDN/l1oip_core.c
@@ -179,7 +179,7 @@ NOTE: A value of 0 equals 256 bytes of data.
 - Time Base = Timestamp of first sample in frame
 The "Time Base" is used to rearange packets and to detect packet loss.
 The 16 bits are sent in network order (MSB first) and count 1/8000 th of a
-second. This causes a wrap arround each 8,192 seconds. There is no requirement
+second. This causes a wrap around each 8,192 seconds. There is no requirement
 for the initial "Time Base", but 0 should be used for the first packet.
 In case of HDLC data, this timestamp counts the packet or byte number.
 
@@ -205,7 +205,7 @@ On Demand:
 
 If the ondemand parameter is given, the remote IP is set to 0 on timeout.
 This will stop keepalive traffic to remote. If the remote is online again,
-traffic will continue to the remote address. This is usefull for road warriors.
+traffic will continue to the remote address. This is useful for road warriors.
 This feature only works with ID set, otherwhise it is highly unsecure.
 
 
@@ -590,7 +590,7 @@ multiframe:
 			return;
 		}
 	} else
-		mlen = len-2; /* single frame, substract timebase */
+		mlen = len-2; /* single frame, subtract timebase */
 
 	if (len < 2) {
 		printk(KERN_WARNING "%s: packet error - packet too short, time "
diff --git a/drivers/isdn/mISDN/layer2.c b/drivers/isdn/mISDN/layer2.c
index 4ae7505..d0aeb44 100644
--- a/drivers/isdn/mISDN/layer2.c
+++ b/drivers/isdn/mISDN/layer2.c
@@ -1864,7 +1864,7 @@ ph_data_indication(struct layer2 *l2, struct mISDNhead *hh, struct sk_buff *skb)
 		psapi >>= 2;
 		ptei >>= 1;
 		if (psapi != l2->sapi) {
-			/* not our bussiness */
+			/* not our business */
 			if (*debug & DEBUG_L2)
 				printk(KERN_DEBUG "%s: sapi %d/%d mismatch\n",
 					__func__, psapi, l2->sapi);
@@ -1872,7 +1872,7 @@ ph_data_indication(struct layer2 *l2, struct mISDNhead *hh, struct sk_buff *skb)
 			return 0;
 		}
 		if ((ptei != l2->tei) && (ptei != GROUP_TEI)) {
-			/* not our bussiness */
+			/* not our business */
 			if (*debug & DEBUG_L2)
 				printk(KERN_DEBUG "%s: tei %d/%d mismatch\n",
 					__func__, ptei, l2->tei);
diff --git a/drivers/leds/leds-pca9532.c b/drivers/leds/leds-pca9532.c
index afac338..5bf63af 100644
--- a/drivers/leds/leds-pca9532.c
+++ b/drivers/leds/leds-pca9532.c
@@ -58,7 +58,7 @@ static struct i2c_driver pca9532_driver = {
 	.id_table = pca9532_id,
 };
 
-/* We have two pwm/blinkers, but 16 possible leds to drive. Additionaly,
+/* We have two pwm/blinkers, but 16 possible leds to drive. Additionally,
  * the clever Thecus people are using one pwm to drive the beeper. So,
  * as a compromise we average one pwm to the values requested by all
  * leds that are not ON/OFF.
diff --git a/drivers/leds/leds-wm8350.c b/drivers/leds/leds-wm8350.c
index a045232..f14edd8 100644
--- a/drivers/leds/leds-wm8350.c
+++ b/drivers/leds/leds-wm8350.c
@@ -215,13 +215,13 @@ static int wm8350_led_probe(struct platform_device *pdev)
 
 	isink = regulator_get(&pdev->dev, "led_isink");
 	if (IS_ERR(isink)) {
-		printk(KERN_ERR "%s: cant get ISINK\n", __func__);
+		printk(KERN_ERR "%s: can't get ISINK\n", __func__);
 		return PTR_ERR(isink);
 	}
 
 	dcdc = regulator_get(&pdev->dev, "led_vcc");
 	if (IS_ERR(dcdc)) {
-		printk(KERN_ERR "%s: cant get DCDC\n", __func__);
+		printk(KERN_ERR "%s: can't get DCDC\n", __func__);
 		ret = PTR_ERR(dcdc);
 		goto err_isink;
 	}
diff --git a/drivers/lguest/lguest_user.c b/drivers/lguest/lguest_user.c
index 3c781cd..948c547 100644
--- a/drivers/lguest/lguest_user.c
+++ b/drivers/lguest/lguest_user.c
@@ -130,7 +130,7 @@ static int add_eventfd(struct lguest *lg, unsigned long addr, int fd)
 	rcu_assign_pointer(lg->eventfds, new);
 
 	/*
-	 * We're not in a big hurry.  Wait until noone's looking at old
+	 * We're not in a big hurry.  Wait until no one's looking at old
 	 * version, then free it.
 	 */
 	synchronize_rcu();
diff --git a/drivers/macintosh/adbhid.c b/drivers/macintosh/adbhid.c
index 5396c67..09d72bb 100644
--- a/drivers/macintosh/adbhid.c
+++ b/drivers/macintosh/adbhid.c
@@ -328,7 +328,7 @@ adbhid_input_keycode(int id, int scancode, int repeat)
 	switch (keycode) {
 	case ADB_KEY_CAPSLOCK:
 		if (!restore_capslock_events) {
-			/* Generate down/up events for CapsLock everytime. */
+			/* Generate down/up events for CapsLock every time. */
 			input_report_key(ahid->input, KEY_CAPSLOCK, 1);
 			input_sync(ahid->input);
 			input_report_key(ahid->input, KEY_CAPSLOCK, 0);
diff --git a/drivers/macintosh/macio-adb.c b/drivers/macintosh/macio-adb.c
index bd6da7a..b6ef8f5 100644
--- a/drivers/macintosh/macio-adb.c
+++ b/drivers/macintosh/macio-adb.c
@@ -147,7 +147,7 @@ static int macio_adb_reset_bus(void)
 
 	/* Hrm... we may want to not lock interrupts for so
 	 * long ... oh well, who uses that chip anyway ? :)
-	 * That function will be seldomly used during boot
+	 * That function will be seldom used during boot
 	 * on rare machines, so...
 	 */
 	spin_lock_irqsave(&macio_lock, flags);
diff --git a/drivers/macintosh/therm_adt746x.c b/drivers/macintosh/therm_adt746x.c
index 9e3e2c5..0236730 100644
--- a/drivers/macintosh/therm_adt746x.c
+++ b/drivers/macintosh/therm_adt746x.c
@@ -662,7 +662,7 @@ static void thermostat_create_files(void)
 		err |= device_create_file(&of_dev->dev, &dev_attr_sensor2_fan_speed);
 	if (err)
 		printk(KERN_WARNING
-			"Failed to create tempertaure attribute file(s).\n");
+			"Failed to create temperature attribute file(s).\n");
 }
 
 static void thermostat_remove_files(void)
diff --git a/drivers/macintosh/therm_pm72.c b/drivers/macintosh/therm_pm72.c
index c987033..bb8b722 100644
--- a/drivers/macintosh/therm_pm72.c
+++ b/drivers/macintosh/therm_pm72.c
@@ -91,7 +91,7 @@
  *
  *  Mar. 10, 2005 : 1.2
  *	- Add basic support for Xserve G5
- *	- Retreive pumps min/max from EEPROM image in device-tree (broken)
+ *	- Retrieve pumps min/max from EEPROM image in device-tree (broken)
  *	- Use min/max macros here or there
  *	- Latest darwin updated U3H min fan speed to 20% PWM
  *
@@ -375,7 +375,7 @@ static int read_smon_adc(struct cpu_pid_state *state, int chan)
 		rc = i2c_master_send(state->monitor, buf, 2);
 		if (rc <= 0)
 			goto error;
-		/* Wait for convertion */
+		/* Wait for conversion */
 		msleep(1);
 		/* Switch to data register */
 		buf[0] = 4;
@@ -1192,7 +1192,7 @@ static int init_processor_state(struct cpu_pid_state *state, int index)
 		err |= device_create_file(&of_dev->dev, &dev_attr_cpu1_intake_fan_rpm);
 	}
 	if (err)
-		printk(KERN_WARNING "Failed to create some of the atribute"
+		printk(KERN_WARNING "Failed to create some of the attribute"
 			"files for CPU %d\n", index);
 
 	return 0;
diff --git a/drivers/macintosh/therm_windtunnel.c b/drivers/macintosh/therm_windtunnel.c
index d37819f..46c4e95 100644
--- a/drivers/macintosh/therm_windtunnel.c
+++ b/drivers/macintosh/therm_windtunnel.c
@@ -45,7 +45,7 @@
 #include <asm/sections.h>
 #include <asm/macio.h>
 
-#define LOG_TEMP		0			/* continously log temperature */
+#define LOG_TEMP		0			/* continuously log temperature */
 
 static struct {
 	volatile int		running;
diff --git a/drivers/md/bitmap.h b/drivers/md/bitmap.h
index 931a7a7..d0aeaf4 100644
--- a/drivers/md/bitmap.h
+++ b/drivers/md/bitmap.h
@@ -45,7 +45,7 @@
  *
  * The counter counts pending write requests, plus the on-disk bit.
  * When the counter is '1' and the resync bits are clear, the on-disk
- * bit can be cleared aswell, thus setting the counter to 0.
+ * bit can be cleared as well, thus setting the counter to 0.
  * When we set a bit, or in the counter (to start a write), if the fields is
  * 0, we first set the disk bit and set the counter to 1.
  *
diff --git a/drivers/md/dm-region-hash.c b/drivers/md/dm-region-hash.c
index dad011a..7771ed2 100644
--- a/drivers/md/dm-region-hash.c
+++ b/drivers/md/dm-region-hash.c
@@ -419,7 +419,7 @@ void dm_rh_mark_nosync(struct dm_region_hash *rh, struct bio *bio)
 	/*
 	 * Possible cases:
 	 *   1) DM_RH_DIRTY
-	 *   2) DM_RH_NOSYNC: was dirty, other preceeding writes failed
+	 *   2) DM_RH_NOSYNC: was dirty, other preceding writes failed
 	 *   3) DM_RH_RECOVERING: flushing pending writes
 	 * Either case, the region should have not been connected to list.
 	 */
diff --git a/drivers/md/faulty.c b/drivers/md/faulty.c
index 339fdc6..23078da 100644
--- a/drivers/md/faulty.c
+++ b/drivers/md/faulty.c
@@ -30,7 +30,7 @@
  *
  * Different modes can be active at a time, but only
  * one can be set at array creation.  Others can be added later.
- * A mode can be one-shot or recurrent with the recurrance being
+ * A mode can be one-shot or recurrent with the recurrence being
  * once in every N requests.
  * The bottom 5 bits of the "layout" indicate the mode.  The
  * remainder indicate a period, or 0 for one-shot.
diff --git a/drivers/md/md.c b/drivers/md/md.c
index 8b66e04..b12b377 100644
--- a/drivers/md/md.c
+++ b/drivers/md/md.c
@@ -6266,7 +6266,7 @@ static void status_resync(struct seq_file *seq, mddev_t * mddev)
 	 * rt is a sector_t, so could be 32bit or 64bit.
 	 * So we divide before multiply in case it is 32bit and close
 	 * to the limit.
-	 * We scale the divisor (db) by 32 to avoid loosing precision
+	 * We scale the divisor (db) by 32 to avoid losing precision
 	 * near the end of resync when the number of remaining sectors
 	 * is close to 'db'.
 	 * We then divide rt by 32 after multiplying by db to compensate.
diff --git a/drivers/md/md.h b/drivers/md/md.h
index 12215d4..52b4073 100644
--- a/drivers/md/md.h
+++ b/drivers/md/md.h
@@ -94,7 +94,7 @@ struct mdk_rdev_s
 #define	In_sync		2		/* device is in_sync with rest of array */
 #define	WriteMostly	4		/* Avoid reading if at all possible */
 #define	AutoDetected	7		/* added by auto-detect */
-#define Blocked		8		/* An error occured on an externally
+#define Blocked		8		/* An error occurred on an externally
 					 * managed array, don't allow writes
 					 * until it is cleared */
 	wait_queue_head_t blocked_wait;
diff --git a/drivers/md/raid10.c b/drivers/md/raid10.c
index f7b6237..2da83d5 100644
--- a/drivers/md/raid10.c
+++ b/drivers/md/raid10.c
@@ -5,7 +5,7 @@
  *
  * RAID-10 support for md.
  *
- * Base on code in raid1.c.  See raid1.c for futher copyright information.
+ * Base on code in raid1.c.  See raid1.c for further copyright information.
  *
  *
  * This program is free software; you can redistribute it and/or modify
@@ -340,14 +340,14 @@ static void raid10_end_write_request(struct bio *bio, int error)
 
 /*
  * RAID10 layout manager
- * Aswell as the chunksize and raid_disks count, there are two
+ * As well as the chunksize and raid_disks count, there are two
  * parameters: near_copies and far_copies.
  * near_copies * far_copies must be <= raid_disks.
  * Normally one of these will be 1.
  * If both are 1, we get raid0.
  * If near_copies == raid_disks, we get raid1.
  *
- * Chunks are layed out in raid0 style with near_copies copies of the
+ * Chunks are laid out in raid0 style with near_copies copies of the
  * first chunk, followed by near_copies copies of the next chunk and
  * so on.
  * If far_copies > 1, then after 1/far_copies of the array has been assigned
diff --git a/drivers/md/raid10.h b/drivers/md/raid10.h
index 2316ac2..944b110 100644
--- a/drivers/md/raid10.h
+++ b/drivers/md/raid10.h
@@ -17,8 +17,8 @@ struct r10_private_data_s {
 	spinlock_t		device_lock;
 
 	/* geometry */
-	int			near_copies;  /* number of copies layed out raid0 style */
-	int 			far_copies;   /* number of copies layed out
+	int			near_copies;  /* number of copies laid out raid0 style */
+	int 			far_copies;   /* number of copies laid out
 					       * at large strides across drives
 					       */
 	int			far_offset;   /* far_copies are offset by 1 stripe
diff --git a/drivers/media/common/saa7146_i2c.c b/drivers/media/common/saa7146_i2c.c
index 74ee172..b2ba9dc 100644
--- a/drivers/media/common/saa7146_i2c.c
+++ b/drivers/media/common/saa7146_i2c.c
@@ -161,7 +161,7 @@ static int saa7146_i2c_reset(struct saa7146_dev *dev)
 		msleep(SAA7146_I2C_DELAY);
 	}
 
-	/* if any error is still present, a fatal error has occured ... */
+	/* if any error is still present, a fatal error has occurred ... */
 	status = saa7146_i2c_status(dev);
 	if ( dev->i2c_bitrate != status ) {
 		DEB_I2C(("fatal error. status:0x%08x\n",status));
@@ -326,9 +326,9 @@ static int saa7146_i2c_transfer(struct saa7146_dev *dev, const struct i2c_msg *m
 			if ( 0 != err) {
 				/* this one is unsatisfying: some i2c slaves on some
 				   dvb cards don't acknowledge correctly, so the saa7146
-				   thinks that an address error occured. in that case, the
+				   thinks that an address error occurred. in that case, the
 				   transaction should be retrying, even if an address error
-				   occured. analog saa7146 based cards extensively rely on
+				   occurred. analog saa7146 based cards extensively rely on
 				   i2c address probing, however, and address errors indicate that a
 				   device is really *not* there. retrying in that case
 				   increases the time the device needs to probe greatly, so
@@ -365,7 +365,7 @@ static int saa7146_i2c_transfer(struct saa7146_dev *dev, const struct i2c_msg *m
 	DEB_I2C(("transmission successful. (msg:%d).\n",err));
 out:
 	/* another bug in revision 0: the i2c-registers get uploaded randomly by other
-	   uploads, so we better clear them out before continueing */
+	   uploads, so we better clear them out before continuing */
 	if( 0 == dev->revision ) {
 		__le32 zero = 0;
 		saa7146_i2c_reset(dev);
diff --git a/drivers/media/common/tuners/mxl5005s.c b/drivers/media/common/tuners/mxl5005s.c
index 605e28b..0d6e094 100644
--- a/drivers/media/common/tuners/mxl5005s.c
+++ b/drivers/media/common/tuners/mxl5005s.c
@@ -106,7 +106,7 @@ enum {
 /* MXL5005 Tuner Register Struct */
 struct TunerReg {
 	u16 Reg_Num;	/* Tuner Register Address */
-	u16 Reg_Val;	/* Current sw programmed value waiting to be writen */
+	u16 Reg_Val;	/* Current sw programmed value waiting to be written */
 };
 
 enum {
diff --git a/drivers/media/common/tuners/tda18271.h b/drivers/media/common/tuners/tda18271.h
index 3abb221..50cfa8c 100644
--- a/drivers/media/common/tuners/tda18271.h
+++ b/drivers/media/common/tuners/tda18271.h
@@ -98,7 +98,7 @@ struct tda18271_config {
 	/* output options that can be disabled */
 	enum tda18271_output_options output_opt;
 
-	/* some i2c providers cant write all 39 registers at once */
+	/* some i2c providers can't write all 39 registers at once */
 	enum tda18271_small_i2c small_i2c;
 
 	/* force rf tracking filter calibration on startup */
diff --git a/drivers/media/dvb/b2c2/flexcop-pci.c b/drivers/media/dvb/b2c2/flexcop-pci.c
index 227c020..9552540 100644
--- a/drivers/media/dvb/b2c2/flexcop-pci.c
+++ b/drivers/media/dvb/b2c2/flexcop-pci.c
@@ -58,7 +58,7 @@ struct flexcop_pci {
 
 	int active_dma1_addr; /* 0 = addr0 of dma1; 1 = addr1 of dma1 */
 	u32 last_dma1_cur_pos;
-	/* position of the pointer last time the timer/packet irq occured */
+	/* position of the pointer last time the timer/packet irq occurred */
 	int count;
 	int count_prev;
 	int stream_problem;
diff --git a/drivers/media/dvb/bt8xx/dvb-bt8xx.c b/drivers/media/dvb/bt8xx/dvb-bt8xx.c
index 78fc469..1e1106d 100644
--- a/drivers/media/dvb/bt8xx/dvb-bt8xx.c
+++ b/drivers/media/dvb/bt8xx/dvb-bt8xx.c
@@ -427,10 +427,10 @@ static void or51211_reset(struct dvb_frontend * fe)
 	struct dvb_bt8xx_card *bt = fe->dvb->priv;
 
 	/* RESET DEVICE
-	 * reset is controled by GPIO-0
+	 * reset is controlled by GPIO-0
 	 * when set to 0 causes reset and when to 1 for normal op
 	 * must remain reset for 128 clock cycles on a 50Mhz clock
-	 * also PRM1 PRM2 & PRM4 are controled by GPIO-1,GPIO-2 & GPIO-4
+	 * also PRM1 PRM2 & PRM4 are controlled by GPIO-1,GPIO-2 & GPIO-4
 	 * We assume that the reset has be held low long enough or we
 	 * have been reset by a power on.  When the driver is unloaded
 	 * reset set to 0 so if reloaded we have been reset.
diff --git a/drivers/media/dvb/dvb-core/dvb_frontend.c b/drivers/media/dvb/dvb-core/dvb_frontend.c
index cad6634..31e2c0d 100644
--- a/drivers/media/dvb/dvb-core/dvb_frontend.c
+++ b/drivers/media/dvb/dvb-core/dvb_frontend.c
@@ -1638,7 +1638,7 @@ static int dvb_frontend_ioctl_legacy(struct file *file,
 	case FE_READ_STATUS: {
 		fe_status_t* status = parg;
 
-		/* if retune was requested but hasn't occured yet, prevent
+		/* if retune was requested but hasn't occurred yet, prevent
 		 * that user get signal state from previous tuning */
 		if (fepriv->state == FESTATE_RETUNE ||
 		    fepriv->state == FESTATE_ERROR) {
@@ -1729,7 +1729,7 @@ static int dvb_frontend_ioctl_legacy(struct file *file,
 			 * Dish network legacy switches (as used by Dish500)
 			 * are controlled by sending 9-bit command words
 			 * spaced 8msec apart.
-			 * the actual command word is switch/port dependant
+			 * the actual command word is switch/port dependent
 			 * so it is up to the userspace application to send
 			 * the right command.
 			 * The command must always start with a '0' after
diff --git a/drivers/media/dvb/dvb-usb/af9005-fe.c b/drivers/media/dvb/dvb-usb/af9005-fe.c
index 199ece0..6ad9474 100644
--- a/drivers/media/dvb/dvb-usb/af9005-fe.c
+++ b/drivers/media/dvb/dvb-usb/af9005-fe.c
@@ -580,7 +580,7 @@ static int af9005_fe_program_cfoe(struct dvb_usb_device *d, fe_bandwidth_t bw)
 		NS_coeff2_8k = 0x724925;
 		break;
 	default:
-		err("Invalid bandwith %d.", bw);
+		err("Invalid bandwidth %d.", bw);
 		return -EINVAL;
 	}
 
@@ -789,7 +789,7 @@ static int af9005_fe_select_bw(struct dvb_usb_device *d, fe_bandwidth_t bw)
 		temp = 2;
 		break;
 	default:
-		err("Invalid bandwith %d.", bw);
+		err("Invalid bandwidth %d.", bw);
 		return -EINVAL;
 	}
 	return af9005_write_register_bits(d, xd_g_reg_bw, reg_bw_pos,
@@ -930,7 +930,7 @@ static int af9005_fe_init(struct dvb_frontend *fe)
 	if (ret)
 		return ret;
 
-	/* init other parameters: program cfoe and select bandwith */
+	/* init other parameters: program cfoe and select bandwidth */
 	deb_info("program cfoe\n");
 	if ((ret = af9005_fe_program_cfoe(state->d, BANDWIDTH_6_MHZ)))
 		return ret;
@@ -1167,7 +1167,7 @@ static int af9005_fe_set_frontend(struct dvb_frontend *fe,
 	if (ret)
 		return ret;
 
-	/* select bandwith */
+	/* select bandwidth */
 	deb_info("select bandwidth");
 	ret = af9005_fe_select_bw(state->d, fep->u.ofdm.bandwidth);
 	if (ret)
diff --git a/drivers/media/dvb/dvb-usb/friio.h b/drivers/media/dvb/dvb-usb/friio.h
index af8d55e..0f461ca 100644
--- a/drivers/media/dvb/dvb-usb/friio.h
+++ b/drivers/media/dvb/dvb-usb/friio.h
@@ -20,7 +20,7 @@
  *         Frontend:                             comtech JDVBT-90502
  *             (tuner PLL:                       tua6034, I2C addr:(0xC0 >> 1))
  *             (OFDM demodulator:                TC90502, I2C addr:(0x30 >> 1))
- *         LED x3 (+LNB) controll:               PIC 16F676
+ *         LED x3 (+LNB) control:                PIC 16F676
  *         EEPROM:                               24C08
  *
  *        (USB smart card reader:                AU9522)
diff --git a/drivers/media/dvb/dvb-usb/lmedm04.c b/drivers/media/dvb/dvb-usb/lmedm04.c
index cd26e7c..f2db012 100644
--- a/drivers/media/dvb/dvb-usb/lmedm04.c
+++ b/drivers/media/dvb/dvb-usb/lmedm04.c
@@ -321,7 +321,7 @@ static int lme2510_int_read(struct dvb_usb_adapter *adap)
 	lme_int->lme_urb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
 
 	usb_submit_urb(lme_int->lme_urb, GFP_ATOMIC);
-	info("INT Interupt Service Started");
+	info("INT Interrupt Service Started");
 
 	return 0;
 }
@@ -482,7 +482,7 @@ static int lme2510_msg(struct dvb_usb_device *d,
 			break;
 		}
 
-		deb_info(4, "I2C From Interupt Message out(%02x) in(%02x)",
+		deb_info(4, "I2C From Interrupt Message out(%02x) in(%02x)",
 				wbuf[3], rbuf[1]);
 
 	}
@@ -632,11 +632,11 @@ static int lme2510_int_service(struct dvb_usb_adapter *adap)
 	}
 	d->rc_dev = rc;
 
-	/* Start the Interupt */
+	/* Start the Interrupt */
 	ret = lme2510_int_read(adap);
 	if (ret < 0) {
 		rc_unregister_device(rc);
-		info("INT Unable to start Interupt Service");
+		info("INT Unable to start Interrupt Service");
 		return -ENODEV;
 	}
 
@@ -1003,7 +1003,7 @@ static int dm04_lme2510_tuner(struct dvb_usb_adapter *adap)
 		return -ENODEV;
 	}
 
-	/* Start the Interupt & Remote*/
+	/* Start the Interrupt & Remote*/
 	ret = lme2510_int_service(adap);
 
 	return ret;
@@ -1171,7 +1171,7 @@ void *lme2510_exit_int(struct dvb_usb_device *d)
 		usb_kill_urb(st->lme_urb);
 		usb_free_coherent(d->udev, 5000, st->buffer,
 				  st->lme_urb->transfer_dma);
-		info("Interupt Service Stopped");
+		info("Interrupt Service Stopped");
 		rc_unregister_device(d->rc_dev);
 		info("Remote Stopped");
 	}
diff --git a/drivers/media/dvb/frontends/atbm8830.h b/drivers/media/dvb/frontends/atbm8830.h
index e8149f3..0242733 100644
--- a/drivers/media/dvb/frontends/atbm8830.h
+++ b/drivers/media/dvb/frontends/atbm8830.h
@@ -39,7 +39,7 @@ struct atbm8830_config {
 	/* parallel or serial transport stream */
 	u8 serial_ts;
 
-	/* transport stream clock output only when receving valid stream */
+	/* transport stream clock output only when receiving valid stream */
 	u8 ts_clk_gated;
 
 	/* Decoder sample TS data at rising edge of clock */
diff --git a/drivers/media/dvb/frontends/au8522_dig.c b/drivers/media/dvb/frontends/au8522_dig.c
index 65f6a36..1d57294 100644
--- a/drivers/media/dvb/frontends/au8522_dig.c
+++ b/drivers/media/dvb/frontends/au8522_dig.c
@@ -635,7 +635,7 @@ static int au8522_led_gpio_enable(struct au8522_state *state, int onoff)
 	struct au8522_led_config *led_config = state->config->led_cfg;
 	u8 val;
 
-	/* bail out if we cant control an LED */
+	/* bail out if we can't control an LED */
 	if (!led_config || !led_config->gpio_output ||
 	    !led_config->gpio_output_enable || !led_config->gpio_output_disable)
 		return 0;
@@ -665,7 +665,7 @@ static int au8522_led_ctrl(struct au8522_state *state, int led)
 	struct au8522_led_config *led_config = state->config->led_cfg;
 	int i, ret = 0;
 
-	/* bail out if we cant control an LED */
+	/* bail out if we can't control an LED */
 	if (!led_config || !led_config->gpio_leds ||
 	    !led_config->num_led_states || !led_config->led_states)
 		return 0;
@@ -803,7 +803,7 @@ static int au8522_led_status(struct au8522_state *state, const u16 *snr)
 	int led;
 	u16 strong;
 
-	/* bail out if we cant control an LED */
+	/* bail out if we can't control an LED */
 	if (!led_config)
 		return 0;
 
diff --git a/drivers/media/dvb/frontends/bcm3510.c b/drivers/media/dvb/frontends/bcm3510.c
index cf5e576..8aff586 100644
--- a/drivers/media/dvb/frontends/bcm3510.c
+++ b/drivers/media/dvb/frontends/bcm3510.c
@@ -155,7 +155,7 @@ static int bcm3510_hab_send_request(struct bcm3510_state *st, u8 *buf, int len)
 	unsigned long t;
 
 /* Check if any previous HAB request still needs to be serviced by the
- * Aquisition Processor before sending new request */
+ * Acquisition Processor before sending new request */
 	if ((ret = bcm3510_readB(st,0xa8,&v)) < 0)
 		return ret;
 	if (v.HABSTAT_a8.HABR) {
@@ -361,7 +361,7 @@ static int bcm3510_tuner_cmd(struct bcm3510_state* st,u8 bc, u16 n, u8 a)
 /* Set duration of the initial state of TUNCTL = 3.34 micro Sec */
 	c.TUNCTL_state = 0x40;
 
-/* PRESCALER DEVIDE RATIO | BC1_2_3_4; (band switch), 1stosc REFERENCE COUNTER REF_S12 and REF_S11 */
+/* PRESCALER DIVIDE RATIO | BC1_2_3_4; (band switch), 1stosc REFERENCE COUNTER REF_S12 and REF_S11 */
 	c.ctl_dat[0].ctrl.size = BITS_8;
 	c.ctl_dat[0].data      = 0x80 | bc;
 
@@ -397,7 +397,7 @@ static int bcm3510_tuner_cmd(struct bcm3510_state* st,u8 bc, u16 n, u8 a)
 	c.ctl_dat[7].ctrl.cs0  = 1;
 	c.ctl_dat[7].data      = 0x40;
 
-/* PRESCALER DEVIDE RATIO, 2ndosc REFERENCE COUNTER REF_S12 and REF_S11 */
+/* PRESCALER DIVIDE RATIO, 2ndosc REFERENCE COUNTER REF_S12 and REF_S11 */
 	c.ctl_dat[8].ctrl.size = BITS_8;
 	c.ctl_dat[8].data      = 0x80;
 
diff --git a/drivers/media/dvb/frontends/cx22700.c b/drivers/media/dvb/frontends/cx22700.c
index 5fbc0fc..0142214 100644
--- a/drivers/media/dvb/frontends/cx22700.c
+++ b/drivers/media/dvb/frontends/cx22700.c
@@ -179,7 +179,7 @@ static int cx22700_set_tps (struct cx22700_state *state, struct dvb_ofdm_paramet
 	cx22700_writereg (state, 0x06, val);
 
 	cx22700_writereg (state, 0x08, 0x04 | 0x02);  /* use user tps parameters */
-	cx22700_writereg (state, 0x08, 0x04);         /* restart aquisition */
+	cx22700_writereg (state, 0x08, 0x04);         /* restart acquisition */
 
 	return 0;
 }
diff --git a/drivers/media/dvb/frontends/cx22702.c b/drivers/media/dvb/frontends/cx22702.c
index ff6c498..3139558 100644
--- a/drivers/media/dvb/frontends/cx22702.c
+++ b/drivers/media/dvb/frontends/cx22702.c
@@ -55,7 +55,7 @@ MODULE_PARM_DESC(debug, "Enable verbose debug messages");
 
 /* Register values to initialise the demod */
 static const u8 init_tab[] = {
-	0x00, 0x00, /* Stop aquisition */
+	0x00, 0x00, /* Stop acquisition */
 	0x0B, 0x06,
 	0x09, 0x01,
 	0x0D, 0x41,
@@ -310,7 +310,7 @@ static int cx22702_set_tps(struct dvb_frontend *fe,
 			& 0xfc);
 		cx22702_writereg(state, 0x0C,
 			(cx22702_readreg(state, 0x0C) & 0xBF) | 0x40);
-		cx22702_writereg(state, 0x00, 0x01); /* Begin aquisition */
+		cx22702_writereg(state, 0x00, 0x01); /* Begin acquisition */
 		dprintk("%s: Autodetecting\n", __func__);
 		return 0;
 	}
@@ -424,7 +424,7 @@ static int cx22702_set_tps(struct dvb_frontend *fe,
 	cx22702_writereg(state, 0x0C,
 		(cx22702_readreg(state, 0x0C) & 0xBF) | 0x40);
 
-	/* Begin channel aquisition */
+	/* Begin channel acquisition */
 	cx22702_writereg(state, 0x00, 0x01);
 
 	return 0;
diff --git a/drivers/media/dvb/frontends/cx24110.c b/drivers/media/dvb/frontends/cx24110.c
index 7a1a5bc..bf9c999 100644
--- a/drivers/media/dvb/frontends/cx24110.c
+++ b/drivers/media/dvb/frontends/cx24110.c
@@ -544,7 +544,7 @@ static int cx24110_set_frontend(struct dvb_frontend* fe, struct dvb_frontend_par
 	cx24110_set_inversion (state, p->inversion);
 	cx24110_set_fec (state, p->u.qpsk.fec_inner);
 	cx24110_set_symbolrate (state, p->u.qpsk.symbol_rate);
-	cx24110_writereg(state,0x04,0x05); /* start aquisition */
+	cx24110_writereg(state,0x04,0x05); /* start acquisition */
 
 	return 0;
 }
diff --git a/drivers/media/dvb/frontends/cx24113.h b/drivers/media/dvb/frontends/cx24113.h
index 5de0f7f..01eb7b9 100644
--- a/drivers/media/dvb/frontends/cx24113.h
+++ b/drivers/media/dvb/frontends/cx24113.h
@@ -1,5 +1,5 @@
 /*
- *  Driver for Conexant CX24113/CX24128 Tuner (Satelite)
+ *  Driver for Conexant CX24113/CX24128 Tuner (Satellite)
  *
  *  Copyright (C) 2007-8 Patrick Boettcher <pb@linuxtv.org>
  *
diff --git a/drivers/media/dvb/frontends/cx24123.c b/drivers/media/dvb/frontends/cx24123.c
index fad6a99..b1dd8ac 100644
--- a/drivers/media/dvb/frontends/cx24123.c
+++ b/drivers/media/dvb/frontends/cx24123.c
@@ -949,7 +949,7 @@ static int cx24123_set_frontend(struct dvb_frontend *fe,
 	else
 		err("it seems I don't have a tuner...");
 
-	/* Enable automatic aquisition and reset cycle */
+	/* Enable automatic acquisition and reset cycle */
 	cx24123_writereg(state, 0x03, (cx24123_readreg(state, 0x03) | 0x07));
 	cx24123_writereg(state, 0x00, 0x10);
 	cx24123_writereg(state, 0x00, 0);
diff --git a/drivers/media/dvb/frontends/drx397xD.c b/drivers/media/dvb/frontends/drx397xD.c
index a05007c..536f02b 100644
--- a/drivers/media/dvb/frontends/drx397xD.c
+++ b/drivers/media/dvb/frontends/drx397xD.c
@@ -1097,7 +1097,7 @@ static int drx397x_init(struct dvb_frontend *fe)
 	s->config.ifagc.w0A = 0x3ff;
 	s->config.ifagc.w0C = 0x388;
 
-	/* for signal strenght calculations */
+	/* for signal strength calculations */
 	s->config.ss76 = 820;
 	s->config.ss78 = 2200;
 	s->config.ss7A = 150;
diff --git a/drivers/media/dvb/frontends/mb86a16.c b/drivers/media/dvb/frontends/mb86a16.c
index 33b6323..c283112 100644
--- a/drivers/media/dvb/frontends/mb86a16.c
+++ b/drivers/media/dvb/frontends/mb86a16.c
@@ -1630,7 +1630,7 @@ static enum dvbfe_search mb86a16_search(struct dvb_frontend *fe,
 	state->srate = p->u.qpsk.symbol_rate / 1000;
 
 	if (!mb86a16_set_fe(state)) {
-		dprintk(verbose, MB86A16_ERROR, 1, "Succesfully acquired LOCK");
+		dprintk(verbose, MB86A16_ERROR, 1, "Successfully acquired LOCK");
 		return DVBFE_ALGO_SEARCH_SUCCESS;
 	}
 
diff --git a/drivers/media/dvb/frontends/mb86a20s.c b/drivers/media/dvb/frontends/mb86a20s.c
index cc4acd2..0f867a5 100644
--- a/drivers/media/dvb/frontends/mb86a20s.c
+++ b/drivers/media/dvb/frontends/mb86a20s.c
@@ -406,7 +406,7 @@ err:
 		printk(KERN_INFO "mb86a20s: Init failed. Will try again later\n");
 	} else {
 		state->need_init = false;
-		dprintk("Initialization succeded.\n");
+		dprintk("Initialization succeeded.\n");
 	}
 	return rc;
 }
diff --git a/drivers/media/dvb/frontends/mt312.c b/drivers/media/dvb/frontends/mt312.c
index 472907d..83e6f1a 100644
--- a/drivers/media/dvb/frontends/mt312.c
+++ b/drivers/media/dvb/frontends/mt312.c
@@ -670,7 +670,7 @@ static int mt312_i2c_gate_ctrl(struct dvb_frontend *fe, int enable)
 		if (ret < 0)
 			goto error;
 
-		/* preserve this bit to not accidently shutdown ADC */
+		/* preserve this bit to not accidentally shutdown ADC */
 		val &= 0x80;
 		break;
 	}
diff --git a/drivers/media/dvb/frontends/s5h1420.c b/drivers/media/dvb/frontends/s5h1420.c
index e87b747..17f8cdf 100644
--- a/drivers/media/dvb/frontends/s5h1420.c
+++ b/drivers/media/dvb/frontends/s5h1420.c
@@ -225,7 +225,7 @@ static int s5h1420_recv_slave_reply (struct dvb_frontend* fe,
 	unsigned long timeout;
 	int result = 0;
 
-	/* setup for DISEQC recieve */
+	/* setup for DISEQC receive */
 	val = s5h1420_readreg(state, 0x3b);
 	s5h1420_writereg(state, 0x3b, 0x82); /* FIXME: guess - do we need to set DIS_RDY(0x08) in receive mode? */
 	msleep(15);
diff --git a/drivers/media/dvb/frontends/stb6100.c b/drivers/media/dvb/frontends/stb6100.c
index 64673b8..bc1a8af 100644
--- a/drivers/media/dvb/frontends/stb6100.c
+++ b/drivers/media/dvb/frontends/stb6100.c
@@ -360,7 +360,7 @@ static int stb6100_set_frequency(struct dvb_frontend *fe, u32 frequency)
 	else
 		odiv = 0;
 
-	/* VCO enabled, seach clock off as per LL3.7, 3.4.1 */
+	/* VCO enabled, search clock off as per LL3.7, 3.4.1 */
 	regs[STB6100_VCO] = 0xe0 | (odiv << STB6100_VCO_ODIV_SHIFT);
 
 	/* OSM	*/
diff --git a/drivers/media/dvb/frontends/stv0297.c b/drivers/media/dvb/frontends/stv0297.c
index 4fd7479..84d88f33 100644
--- a/drivers/media/dvb/frontends/stv0297.c
+++ b/drivers/media/dvb/frontends/stv0297.c
@@ -435,7 +435,7 @@ static int stv0297_set_frontend(struct dvb_frontend *fe, struct dvb_frontend_par
 		return -EINVAL;
 	}
 
-	// determine inversion dependant parameters
+	// determine inversion dependent parameters
 	inversion = p->inversion;
 	if (state->config->invert)
 		inversion = (inversion == INVERSION_ON) ? INVERSION_OFF : INVERSION_ON;
diff --git a/drivers/media/dvb/frontends/stv0367.c b/drivers/media/dvb/frontends/stv0367.c
index 4e0e6a8..e57ab53 100644
--- a/drivers/media/dvb/frontends/stv0367.c
+++ b/drivers/media/dvb/frontends/stv0367.c
@@ -1328,7 +1328,7 @@ stv0367_ter_signal_type stv0367ter_lock_algo(struct stv0367_state *state)
 
 	/*guard=stv0367_readbits(state,F367TER_SYR_GUARD); */
 
-	/*supress EPQ auto for SYR_GARD 1/16 or 1/32
+	/*suppress EPQ auto for SYR_GARD 1/16 or 1/32
 	and set channel predictor in automatic */
 #if 0
 	switch (guard) {
diff --git a/drivers/media/dvb/frontends/stv0900_priv.h b/drivers/media/dvb/frontends/stv0900_priv.h
index b62b0f0..e0ea74c 100644
--- a/drivers/media/dvb/frontends/stv0900_priv.h
+++ b/drivers/media/dvb/frontends/stv0900_priv.h
@@ -238,7 +238,7 @@ enum fe_stv0900_demod_mode {
 };
 
 struct stv0900_init_params{
-	u32	dmd_ref_clk;/* Refrence,Input clock for the demod in Hz */
+	u32	dmd_ref_clk;/* Reference,Input clock for the demod in Hz */
 
 	/* Demodulator Type (single demod or dual demod) */
 	enum fe_stv0900_demod_mode	demod_mode;
diff --git a/drivers/media/dvb/frontends/stv090x.c b/drivers/media/dvb/frontends/stv090x.c
index 41d0f0a..52d8712 100644
--- a/drivers/media/dvb/frontends/stv090x.c
+++ b/drivers/media/dvb/frontends/stv090x.c
@@ -1424,7 +1424,7 @@ static int stv090x_start_search(struct stv090x_state *state)
 			if (STV090x_WRITE_DEMOD(state, CFRLOW0, 0x00) < 0)
 				goto err;
 
-			/*enlarge the timing bandwith for Low SR*/
+			/*enlarge the timing bandwidth for Low SR*/
 			if (STV090x_WRITE_DEMOD(state, RTCS2, 0x68) < 0)
 				goto err;
 		} else {
@@ -1432,17 +1432,17 @@ static int stv090x_start_search(struct stv090x_state *state)
 			Set The carrier search up and low to auto mode */
 			if (STV090x_WRITE_DEMOD(state, CARCFG, 0xc4) < 0)
 				goto err;
-			/*reduce the timing bandwith for high SR*/
+			/*reduce the timing bandwidth for high SR*/
 			if (STV090x_WRITE_DEMOD(state, RTCS2, 0x44) < 0)
 				goto err;
 		}
 	} else {
 		/* >= Cut 3 */
 		if (state->srate <= 5000000) {
-			/* enlarge the timing bandwith for Low SR */
+			/* enlarge the timing bandwidth for Low SR */
 			STV090x_WRITE_DEMOD(state, RTCS2, 0x68);
 		} else {
-			/* reduce timing bandwith for high SR */
+			/* reduce timing bandwidth for high SR */
 			STV090x_WRITE_DEMOD(state, RTCS2, 0x44);
 		}
 
@@ -2482,7 +2482,7 @@ static int stv090x_sw_algo(struct stv090x_state *state)
 					dvbs2_fly_wheel = STV090x_GETFIELD_Px(reg, FLYWHEEL_CPT_FIELD);
 				}
 				if (dvbs2_fly_wheel < 0xd) {
-					/*FALSE lock, The demod is loosing lock */
+					/*FALSE lock, The demod is losing lock */
 					lock = 0;
 					if (trials < 2) {
 						if (state->internal->dev_ver >= 0x20) {
@@ -3202,7 +3202,7 @@ static enum stv090x_signal_state stv090x_algo(struct stv090x_state *state)
 			goto err;
 		if (STV090x_WRITE_DEMOD(state, CORRELMANT, 0x70) < 0)
 			goto err;
-		if (stv090x_set_srate(state, 1000000) < 0) /* inital srate = 1Msps */
+		if (stv090x_set_srate(state, 1000000) < 0) /* initial srate = 1Msps */
 			goto err;
 	} else {
 		/* known srate */
diff --git a/drivers/media/dvb/mantis/mantis_uart.c b/drivers/media/dvb/mantis/mantis_uart.c
index 97b889e..f807c8b 100644
--- a/drivers/media/dvb/mantis/mantis_uart.c
+++ b/drivers/media/dvb/mantis/mantis_uart.c
@@ -172,7 +172,7 @@ int mantis_uart_init(struct mantis_pci *mantis)
 	mmwrite(mmread(MANTIS_UART_CTL) | MANTIS_UART_RXINT, MANTIS_UART_CTL);
 
 	schedule_work(&mantis->uart_work);
-	dprintk(MANTIS_DEBUG, 1, "UART succesfully initialized");
+	dprintk(MANTIS_DEBUG, 1, "UART successfully initialized");
 
 	return 0;
 }
diff --git a/drivers/media/dvb/ngene/ngene-core.c b/drivers/media/dvb/ngene/ngene-core.c
index 175a0f6..ccc2d1a 100644
--- a/drivers/media/dvb/ngene/ngene-core.c
+++ b/drivers/media/dvb/ngene/ngene-core.c
@@ -122,7 +122,7 @@ static void demux_tasklet(unsigned long data)
 						Cur->ngeneBuffer.SR.Flags &=
 							~0x40;
 						break;
-						/* Stop proccessing stream */
+						/* Stop processing stream */
 					}
 				} else {
 					/* We got a valid buffer,
@@ -133,7 +133,7 @@ static void demux_tasklet(unsigned long data)
 				printk(KERN_ERR DEVICE_NAME ": OOPS\n");
 				if (chan->HWState == HWSTATE_RUN) {
 					Cur->ngeneBuffer.SR.Flags &= ~0x40;
-					break;	/* Stop proccessing stream */
+					break;	/* Stop processing stream */
 				}
 			}
 			if (chan->AudioDTOUpdated) {
diff --git a/drivers/media/dvb/pluto2/pluto2.c b/drivers/media/dvb/pluto2/pluto2.c
index 6ca6713..7cb79ec 100644
--- a/drivers/media/dvb/pluto2/pluto2.c
+++ b/drivers/media/dvb/pluto2/pluto2.c
@@ -294,13 +294,13 @@ static void pluto_dma_end(struct pluto *pluto, unsigned int nbpackets)
 
 	/* Workaround for broken hardware:
 	 * [1] On startup NBPACKETS seems to contain an uninitialized value,
-	 *     but no packets have been transfered.
+	 *     but no packets have been transferred.
 	 * [2] Sometimes (actually very often) NBPACKETS stays at zero
-	 *     although one packet has been transfered.
+	 *     although one packet has been transferred.
 	 * [3] Sometimes (actually rarely), the card gets into an erroneous
 	 *     mode where it continuously generates interrupts, claiming it
-	 *     has recieved nbpackets>TS_DMA_PACKETS packets, but no packet
-	 *     has been transfered. Only a reset seems to solve this
+	 *     has received nbpackets>TS_DMA_PACKETS packets, but no packet
+	 *     has been transferred. Only a reset seems to solve this
 	 */
 	if ((nbpackets == 0) || (nbpackets > TS_DMA_PACKETS)) {
 		unsigned int i = 0;
@@ -332,7 +332,7 @@ static irqreturn_t pluto_irq(int irq, void *dev_id)
 	struct pluto *pluto = dev_id;
 	u32 tscr;
 
-	/* check whether an interrupt occured on this device */
+	/* check whether an interrupt occurred on this device */
 	tscr = pluto_readreg(pluto, REG_TSCR);
 	if (!(tscr & (TSCR_DE | TSCR_OVR)))
 		return IRQ_NONE;
diff --git a/drivers/media/dvb/siano/smsdvb.c b/drivers/media/dvb/siano/smsdvb.c
index b80d09b..37c594f 100644
--- a/drivers/media/dvb/siano/smsdvb.c
+++ b/drivers/media/dvb/siano/smsdvb.c
@@ -650,7 +650,7 @@ static int smsdvb_dvbt_set_frontend(struct dvb_frontend *fe,
 		if (status & FE_HAS_LOCK)
 			return ret;
 
-		/* previous tune didnt lock - enable LNA and tune again */
+		/* previous tune didn't lock - enable LNA and tune again */
 		sms_board_lna_control(client->coredev, 1);
 	}
 
diff --git a/drivers/media/dvb/ttpci/av7110.c b/drivers/media/dvb/ttpci/av7110.c
index fc0a60f..3d20719 100644
--- a/drivers/media/dvb/ttpci/av7110.c
+++ b/drivers/media/dvb/ttpci/av7110.c
@@ -2332,7 +2332,7 @@ static int frontend_init(struct av7110 *av7110)
  * increment. That's how the 7146 is programmed to do event
  * counting in this budget-patch.c
  * I *think* HPS setting has something to do with the phase
- * of HS but I cant be 100% sure in that.
+ * of HS but I can't be 100% sure in that.
  *
  * hardware debug note: a working budget card (including budget patch)
  * with vpeirq() interrupt setup in mode "0x90" (every 64K) will
diff --git a/drivers/media/dvb/ttpci/budget-patch.c b/drivers/media/dvb/ttpci/budget-patch.c
index 5798355..3395d1a 100644
--- a/drivers/media/dvb/ttpci/budget-patch.c
+++ b/drivers/media/dvb/ttpci/budget-patch.c
@@ -539,7 +539,7 @@ static int budget_patch_attach (struct saa7146_dev* dev, struct saa7146_pci_exte
 **      increment. That's how the 7146 is programmed to do event
 **      counting in this budget-patch.c
 **      I *think* HPS setting has something to do with the phase
-**      of HS but I cant be 100% sure in that.
+**      of HS but I can't be 100% sure in that.
 
 **      hardware debug note: a working budget card (including budget patch)
 **      with vpeirq() interrupt setup in mode "0x90" (every 64K) will
diff --git a/drivers/media/dvb/ttusb-dec/ttusb_dec.c b/drivers/media/dvb/ttusb-dec/ttusb_dec.c
index fe1b803..f893bff 100644
--- a/drivers/media/dvb/ttusb-dec/ttusb_dec.c
+++ b/drivers/media/dvb/ttusb-dec/ttusb_dec.c
@@ -234,7 +234,7 @@ static void ttusb_dec_handle_irq( struct urb *urb)
 		 * (with buffer[3] == 0x40) in an intervall of ~100ms.
 		 * But to handle this correctly we had to imlemenent some
 		 * kind of timer which signals a 'key up' event if no
-		 * keyrepeat signal is recieved for lets say 200ms.
+		 * keyrepeat signal is received for lets say 200ms.
 		 * this should/could be added later ...
 		 * for now lets report each signal as a key down and up*/
 		dprintk("%s:rc signal:%d\n", __func__, buffer[4]);
diff --git a/drivers/media/radio/radio-mr800.c b/drivers/media/radio/radio-mr800.c
index e6b2d08..b3a635b 100644
--- a/drivers/media/radio/radio-mr800.c
+++ b/drivers/media/radio/radio-mr800.c
@@ -99,7 +99,7 @@ devices, that would be 76 and 91.  */
 
 /*
  * Commands that device should understand
- * List isnt full and will be updated with implementation of new functions
+ * List isn't full and will be updated with implementation of new functions
  */
 #define AMRADIO_SET_FREQ	0xa4
 #define AMRADIO_SET_MUTE	0xab
diff --git a/drivers/media/radio/si4713-i2c.c b/drivers/media/radio/si4713-i2c.c
index 0fab6f8..deca2e0 100644
--- a/drivers/media/radio/si4713-i2c.c
+++ b/drivers/media/radio/si4713-i2c.c
@@ -481,7 +481,7 @@ unlock:
 }
 
 /*
- * si4713_wait_stc - Waits STC interrupt and clears status bits. Usefull
+ * si4713_wait_stc - Waits STC interrupt and clears status bits. Useful
  *		     for TX_TUNE_POWER, TX_TUNE_FREQ and TX_TUNE_MEAS
  * @sdev: si4713_device structure for the device we are communicating
  * @usecs: timeout to wait for STC interrupt signal
diff --git a/drivers/media/radio/wl128x/fmdrv_common.c b/drivers/media/radio/wl128x/fmdrv_common.c
index ecfd9fb..5991ab6 100644
--- a/drivers/media/radio/wl128x/fmdrv_common.c
+++ b/drivers/media/radio/wl128x/fmdrv_common.c
@@ -352,7 +352,7 @@ static void send_tasklet(unsigned long arg)
 	if (!atomic_read(&fmdev->tx_cnt))
 		return;
 
-	/* Check, is there any timeout happenned to last transmitted packet */
+	/* Check, is there any timeout happened to last transmitted packet */
 	if ((jiffies - fmdev->last_tx_jiffies) > FM_DRV_TX_TIMEOUT) {
 		fmerr("TX timeout occurred\n");
 		atomic_set(&fmdev->tx_cnt, 1);
@@ -478,7 +478,7 @@ u32 fmc_send_cmd(struct fmdev *fmdev, u8 fm_op, u16 type, void *payload,
 		return -ETIMEDOUT;
 	}
 	if (!fmdev->resp_skb) {
-		fmerr("Reponse SKB is missing\n");
+		fmerr("Response SKB is missing\n");
 		return -EFAULT;
 	}
 	spin_lock_irqsave(&fmdev->resp_skb_lock, flags);
@@ -1598,7 +1598,7 @@ u32 fmc_release(struct fmdev *fmdev)
 		fmdbg("FM Core is already down\n");
 		return 0;
 	}
-	/* Sevice pending read */
+	/* Service pending read */
 	wake_up_interruptible(&fmdev->rx.rds.read_queue);
 
 	tasklet_kill(&fmdev->tx_task);
diff --git a/drivers/media/radio/wl128x/fmdrv_common.h b/drivers/media/radio/wl128x/fmdrv_common.h
index 427c416..aee243b 100644
--- a/drivers/media/radio/wl128x/fmdrv_common.h
+++ b/drivers/media/radio/wl128x/fmdrv_common.h
@@ -362,7 +362,7 @@ struct fm_event_msg_hdr {
 #define FM_TX_PREEMPH_50US		0
 #define FM_TX_PREEMPH_75US		2
 
-/* FM TX antenna impedence values */
+/* FM TX antenna impedance values */
 #define FM_TX_ANT_IMP_50		0
 #define FM_TX_ANT_IMP_200		1
 #define FM_TX_ANT_IMP_500		2
diff --git a/drivers/media/rc/ene_ir.c b/drivers/media/rc/ene_ir.c
index 1ac4913..a43ed6c 100644
--- a/drivers/media/rc/ene_ir.c
+++ b/drivers/media/rc/ene_ir.c
@@ -520,7 +520,7 @@ static void ene_rx_disable(struct ene_device *dev)
 	dev->rx_enabled = false;
 }
 
-/* This resets the receiver. Usefull to stop stream of spaces at end of
+/* This resets the receiver. Useful to stop stream of spaces at end of
  * transmission
  */
 static void ene_rx_reset(struct ene_device *dev)
@@ -1089,7 +1089,7 @@ static int ene_probe(struct pnp_dev *pnp_dev, const struct pnp_device_id *id)
 	if (error < 0)
 		goto error;
 
-	ene_notice("driver has been succesfully loaded");
+	ene_notice("driver has been successfully loaded");
 	return 0;
 error:
 	if (dev && dev->irq >= 0)
diff --git a/drivers/media/rc/imon.c b/drivers/media/rc/imon.c
index f714e1a..ebd68ed 100644
--- a/drivers/media/rc/imon.c
+++ b/drivers/media/rc/imon.c
@@ -1293,7 +1293,7 @@ static void imon_pad_to_keys(struct imon_context *ictx, unsigned char *buf)
 	 * contain a position coordinate (x,y), with each component ranging
 	 * from -14 to 14. We want to down-sample this to only 4 discrete values
 	 * for up/down/left/right arrow keys. Also, when you get too close to
-	 * diagonals, it has a tendancy to jump back and forth, so lets try to
+	 * diagonals, it has a tendency to jump back and forth, so lets try to
 	 * ignore when they get too close.
 	 */
 	if (ictx->product != 0xffdc) {
diff --git a/drivers/media/rc/ir-raw.c b/drivers/media/rc/ir-raw.c
index 01f258a..11c19d8 100644
--- a/drivers/media/rc/ir-raw.c
+++ b/drivers/media/rc/ir-raw.c
@@ -153,7 +153,7 @@ EXPORT_SYMBOL_GPL(ir_raw_event_store_edge);
  * @type:	the type of the event that has occurred
  *
  * This routine (which may be called from an interrupt context) works
- * in similiar manner to ir_raw_event_store_edge.
+ * in similar manner to ir_raw_event_store_edge.
  * This routine is intended for devices with limited internal buffer
  * It automerges samples of same type, and handles timeouts
  */
diff --git a/drivers/media/rc/keymaps/rc-lme2510.c b/drivers/media/rc/keymaps/rc-lme2510.c
index 3c19139..afae14f 100644
--- a/drivers/media/rc/keymaps/rc-lme2510.c
+++ b/drivers/media/rc/keymaps/rc-lme2510.c
@@ -55,7 +55,7 @@ static struct rc_map_table lme2510_rc[] = {
 	{ 0xff40fb04, KEY_MEDIA_REPEAT}, /* Recall */
 	{ 0xff40e51a, KEY_PAUSE }, /* Timeshift */
 	{ 0xff40fd02, KEY_VOLUMEUP }, /* 2 x -/+ Keys not marked */
-	{ 0xff40f906, KEY_VOLUMEDOWN }, /* Volumne defined as right hand*/
+	{ 0xff40f906, KEY_VOLUMEDOWN }, /* Volume defined as right hand*/
 	{ 0xff40fe01, KEY_CHANNELUP },
 	{ 0xff40fa05, KEY_CHANNELDOWN },
 	{ 0xff40eb14, KEY_ZOOM },
@@ -76,7 +76,7 @@ static struct rc_map_table lme2510_rc[] = {
 	{ 0xff00bb44, KEY_MEDIA_REPEAT}, /* Recall */
 	{ 0xff00b54a, KEY_PAUSE }, /* Timeshift */
 	{ 0xff00b847, KEY_VOLUMEUP }, /* 2 x -/+ Keys not marked */
-	{ 0xff00bc43, KEY_VOLUMEDOWN }, /* Volumne defined as right hand*/
+	{ 0xff00bc43, KEY_VOLUMEDOWN }, /* Volume defined as right hand*/
 	{ 0xff00b946, KEY_CHANNELUP },
 	{ 0xff00bf40, KEY_CHANNELDOWN },
 	{ 0xff00f708, KEY_ZOOM },
diff --git a/drivers/media/rc/keymaps/rc-msi-tvanywhere.c b/drivers/media/rc/keymaps/rc-msi-tvanywhere.c
index 18b37fa..fdd213f 100644
--- a/drivers/media/rc/keymaps/rc-msi-tvanywhere.c
+++ b/drivers/media/rc/keymaps/rc-msi-tvanywhere.c
@@ -29,7 +29,7 @@ static struct rc_map_table msi_tvanywhere[] = {
 
 	{ 0x0c, KEY_MUTE },
 	{ 0x0f, KEY_SCREEN },		/* Full Screen */
-	{ 0x10, KEY_FN },		/* Funtion */
+	{ 0x10, KEY_FN },		/* Function */
 	{ 0x11, KEY_TIME },		/* Time shift */
 	{ 0x12, KEY_POWER },
 	{ 0x13, KEY_MEDIA },		/* MTS */
diff --git a/drivers/media/rc/keymaps/rc-norwood.c b/drivers/media/rc/keymaps/rc-norwood.c
index f1c1281..f9f2fa2 100644
--- a/drivers/media/rc/keymaps/rc-norwood.c
+++ b/drivers/media/rc/keymaps/rc-norwood.c
@@ -49,7 +49,7 @@ static struct rc_map_table norwood[] = {
 	{ 0x37, KEY_PLAY },		/* Play                */
 	{ 0x36, KEY_PAUSE },		/* Pause               */
 	{ 0x2b, KEY_STOP },		/* Stop                */
-	{ 0x67, KEY_FASTFORWARD },	/* Foward              */
+	{ 0x67, KEY_FASTFORWARD },	/* Forward              */
 	{ 0x66, KEY_REWIND },		/* Rewind              */
 	{ 0x3e, KEY_SEARCH },		/* Auto Scan           */
 	{ 0x2e, KEY_CAMERA },		/* Capture Video       */
diff --git a/drivers/media/rc/rc-main.c b/drivers/media/rc/rc-main.c
index 5ac1baf..f53f9c6 100644
--- a/drivers/media/rc/rc-main.c
+++ b/drivers/media/rc/rc-main.c
@@ -255,7 +255,7 @@ static unsigned int ir_update_mapping(struct rc_dev *dev,
  * @rc_map:	scancode table to be searched
  * @scancode:	the desired scancode
  * @resize:	controls whether we allowed to resize the table to
- *		accomodate not yet present scancodes
+ *		accommodate not yet present scancodes
  * @return:	index of the mapping containing scancode in question
  *		or -1U in case of failure.
  *
@@ -1037,7 +1037,7 @@ int rc_register_device(struct rc_dev *dev)
 		goto out_table;
 
 	/*
-	 * Default delay of 250ms is too short for some protocols, expecially
+	 * Default delay of 250ms is too short for some protocols, especially
 	 * since the timeout is currently set to 250ms. Increase it to 500ms,
 	 * to avoid wrong repetition of the keycodes. Note that this must be
 	 * set after the call to input_register_device().
diff --git a/drivers/media/video/au0828/au0828-video.c b/drivers/media/video/au0828/au0828-video.c
index 6ad83a1..c03eb29 100644
--- a/drivers/media/video/au0828/au0828-video.c
+++ b/drivers/media/video/au0828/au0828-video.c
@@ -502,7 +502,7 @@ static inline void vbi_get_next_buf(struct au0828_dmaqueue *dma_q,
 
 	/* Get the next buffer */
 	*buf = list_entry(dma_q->active.next, struct au0828_buffer, vb.queue);
-	/* Cleans up buffer - Usefull for testing for frame/URB loss */
+	/* Cleans up buffer - Useful for testing for frame/URB loss */
 	outp = videobuf_to_vmalloc(&(*buf)->vb);
 	memset(outp, 0x00, (*buf)->vb.size);
 
diff --git a/drivers/media/video/bt8xx/bttv-cards.c b/drivers/media/video/bt8xx/bttv-cards.c
index 242f0d5..3c9e6c7 100644
--- a/drivers/media/video/bt8xx/bttv-cards.c
+++ b/drivers/media/video/bt8xx/bttv-cards.c
@@ -2244,8 +2244,8 @@ struct tvcard bttv_tvcards[] = {
 	},
 	[BTTV_BOARD_PICOLO_TETRA_CHIP] = {
 		/*Eric DEBIEF <debief@telemsa.com>*/
-		/*EURESYS Picolo Tetra : 4 Conexant Fusion 878A, no audio, video input set with analog multiplexers GPIO controled*/
-		/* adds picolo_tetra_muxsel(), picolo_tetra_init(), the folowing declaration strucure, and #define BTTV_BOARD_PICOLO_TETRA_CHIP*/
+		/*EURESYS Picolo Tetra : 4 Conexant Fusion 878A, no audio, video input set with analog multiplexers GPIO controlled*/
+		/* adds picolo_tetra_muxsel(), picolo_tetra_init(), the following declaration strucure, and #define BTTV_BOARD_PICOLO_TETRA_CHIP*/
 		/*0x79 in bttv.h*/
 		.name           = "Euresys Picolo Tetra",
 		.video_inputs   = 4,
@@ -4567,7 +4567,7 @@ static void picolo_tetra_muxsel (struct bttv* btv, unsigned int input)
  * at one input while the monitor is looking at another.
  *
  * Since I've couldn't be bothered figuring out how to add an
- * independant muxsel for the monitor bus, I've just set it to
+ * independent muxsel for the monitor bus, I've just set it to
  * whatever the card is looking at.
  *
  *  OUT0 of the TDA8540's is connected to MUX0         (0x03)
diff --git a/drivers/media/video/bt8xx/bttv-gpio.c b/drivers/media/video/bt8xx/bttv-gpio.c
index fd604d3..13ce72c 100644
--- a/drivers/media/video/bt8xx/bttv-gpio.c
+++ b/drivers/media/video/bt8xx/bttv-gpio.c
@@ -3,7 +3,7 @@
     bttv-gpio.c  --  gpio sub drivers
 
     sysfs-based sub driver interface for bttv
-    mainly intented for gpio access
+    mainly intended for gpio access
 
 
     Copyright (C) 1996,97,98 Ralph  Metzler (rjkm@thp.uni-koeln.de)
diff --git a/drivers/media/video/cafe_ccic.c b/drivers/media/video/cafe_ccic.c
index 55ffd60..6647033 100644
--- a/drivers/media/video/cafe_ccic.c
+++ b/drivers/media/video/cafe_ccic.c
@@ -383,7 +383,7 @@ static int cafe_smbus_write_data(struct cafe_camera *cam,
 	 * causes the device to die.
 	 * Use a busy-wait because we often send a large quantity of small
 	 * commands at-once; using msleep() would cause a lot of context
-	 * switches which take longer than 2ms, resulting in a noticable
+	 * switches which take longer than 2ms, resulting in a noticeable
 	 * boot-time and capture-start delays.
 	 */
 	mdelay(2);
diff --git a/drivers/media/video/cx18/cx18-av-core.h b/drivers/media/video/cx18/cx18-av-core.h
index 188c9c3..e9c69d9 100644
--- a/drivers/media/video/cx18/cx18-av-core.h
+++ b/drivers/media/video/cx18/cx18-av-core.h
@@ -109,7 +109,7 @@ struct cx18_av_state {
 	int is_initialized;
 
 	/*
-	 * The VBI slicer starts operating and counting lines, begining at
+	 * The VBI slicer starts operating and counting lines, beginning at
 	 * slicer line count of 1, at D lines after the deassertion of VRESET.
 	 * This staring field line, S, is 6 (& 319) or 10 (& 273) for 625 or 525
 	 * line systems respectively.  Sliced ancillary data captured on VBI
diff --git a/drivers/media/video/cx18/cx18-ioctl.c b/drivers/media/video/cx18/cx18-ioctl.c
index 86c30b9..4f041c0 100644
--- a/drivers/media/video/cx18/cx18-ioctl.c
+++ b/drivers/media/video/cx18/cx18-ioctl.c
@@ -312,7 +312,7 @@ static int cx18_s_fmt_vbi_cap(struct file *file, void *fh,
 
 	/*
 	 * Set the digitizer registers for raw active VBI.
-	 * Note cx18_av_vbi_wipes out alot of the passed in fmt under valid
+	 * Note cx18_av_vbi_wipes out a lot of the passed in fmt under valid
 	 * calling conditions
 	 */
 	ret = v4l2_subdev_call(cx->sd_av, vbi, s_raw_fmt, &fmt->fmt.vbi);
diff --git a/drivers/media/video/cx18/cx18-vbi.c b/drivers/media/video/cx18/cx18-vbi.c
index 5822275..6d3121f 100644
--- a/drivers/media/video/cx18/cx18-vbi.c
+++ b/drivers/media/video/cx18/cx18-vbi.c
@@ -29,7 +29,7 @@
 /*
  * Raster Reference/Protection (RP) bytes, used in Start/End Active
  * Video codes emitted from the digitzer in VIP 1.x mode, that flag the start
- * of VBI sample or VBI ancilliary data regions in the digitial ratser line.
+ * of VBI sample or VBI ancillary data regions in the digitial ratser line.
  *
  * Task FieldEven VerticalBlank HorizontalBlank 0 0 0 0
  */
diff --git a/drivers/media/video/cx231xx/cx231xx-avcore.c b/drivers/media/video/cx231xx/cx231xx-avcore.c
index 62843d3..280df43 100644
--- a/drivers/media/video/cx231xx/cx231xx-avcore.c
+++ b/drivers/media/video/cx231xx/cx231xx-avcore.c
@@ -2577,7 +2577,7 @@ int cx231xx_initialize_stream_xfer(struct cx231xx *dev, u32 media_type)
 			break;
 
 		case 6:	/* ts1 parallel mode */
-			cx231xx_info("%s: set ts1 parrallel mode registers\n",
+			cx231xx_info("%s: set ts1 parallel mode registers\n",
 				     __func__);
 			status = cx231xx_mode_register(dev, TS_MODE_REG, 0x100);
 			status = cx231xx_mode_register(dev, TS1_CFG_REG, 0x400);
diff --git a/drivers/media/video/cx231xx/cx231xx-vbi.c b/drivers/media/video/cx231xx/cx231xx-vbi.c
index 1d91448..1c7a4da 100644
--- a/drivers/media/video/cx231xx/cx231xx-vbi.c
+++ b/drivers/media/video/cx231xx/cx231xx-vbi.c
@@ -631,7 +631,7 @@ static inline void get_next_vbi_buf(struct cx231xx_dmaqueue *dma_q,
 	/* Get the next buffer */
 	*buf = list_entry(dma_q->active.next, struct cx231xx_buffer, vb.queue);
 
-	/* Cleans up buffer - Usefull for testing for frame/URB loss */
+	/* Cleans up buffer - Useful for testing for frame/URB loss */
 	outp = videobuf_to_vmalloc(&(*buf)->vb);
 	memset(outp, 0, (*buf)->vb.size);
 
diff --git a/drivers/media/video/cx231xx/cx231xx-video.c b/drivers/media/video/cx231xx/cx231xx-video.c
index ffd5af9..a69c24d 100644
--- a/drivers/media/video/cx231xx/cx231xx-video.c
+++ b/drivers/media/video/cx231xx/cx231xx-video.c
@@ -309,7 +309,7 @@ static inline void get_next_buf(struct cx231xx_dmaqueue *dma_q,
 	/* Get the next buffer */
 	*buf = list_entry(dma_q->active.next, struct cx231xx_buffer, vb.queue);
 
-	/* Cleans up buffer - Usefull for testing for frame/URB loss */
+	/* Cleans up buffer - Useful for testing for frame/URB loss */
 	outp = videobuf_to_vmalloc(&(*buf)->vb);
 	memset(outp, 0, (*buf)->vb.size);
 
diff --git a/drivers/media/video/cx23885/cimax2.c b/drivers/media/video/cx23885/cimax2.c
index 209b971..c9f15d6 100644
--- a/drivers/media/video/cx23885/cimax2.c
+++ b/drivers/media/video/cx23885/cimax2.c
@@ -449,7 +449,7 @@ int netup_ci_init(struct cx23885_tsport *port)
 		0x04, /* ack active low */
 		0x00, /* LOCK = 0 */
 		0x33, /* serial mode, rising in, rising out, MSB first*/
-		0x31, /* syncronization */
+		0x31, /* synchronization */
 	};
 	int ret;
 
diff --git a/drivers/media/video/cx23885/cx23885.h b/drivers/media/video/cx23885/cx23885.h
index 8db2797..c186473 100644
--- a/drivers/media/video/cx23885/cx23885.h
+++ b/drivers/media/video/cx23885/cx23885.h
@@ -214,7 +214,7 @@ struct cx23885_board {
 
 	/* Vendors can and do run the PCIe bridge at different
 	 * clock rates, driven physically by crystals on the PCBs.
-	 * The core has to accomodate this. This allows the user
+	 * The core has to accommodate this. This allows the user
 	 * to add new boards with new frequencys. The value is
 	 * expressed in Hz.
 	 *
diff --git a/drivers/media/video/cx25840/cx25840-core.c b/drivers/media/video/cx25840/cx25840-core.c
index 35796e0..b7ee2ae 100644
--- a/drivers/media/video/cx25840/cx25840-core.c
+++ b/drivers/media/video/cx25840/cx25840-core.c
@@ -2,7 +2,7 @@
  *
  * Copyright (C) 2004 Ulf Eklund
  *
- * Based on the saa7115 driver and on the first verison of Chris Kennedy's
+ * Based on the saa7115 driver and on the first version of Chris Kennedy's
  * cx25840 driver.
  *
  * Changes by Tyler Trafford <tatrafford@comcast.net>
@@ -445,7 +445,7 @@ static void cx25840_initialize(struct i2c_client *client)
 	cx25840_write(client, 0x918, 0xa0);
 	cx25840_write(client, 0x919, 0x01);
 
-	/* stereo prefered */
+	/* stereo preferred */
 	cx25840_write(client, 0x809, 0x04);
 	/* AC97 shift */
 	cx25840_write(client, 0x8cf, 0x0f);
@@ -546,7 +546,7 @@ static void cx23885_initialize(struct i2c_client *client)
 	 * Aux PLL
 	 * Initial setup for audio sample clock:
 	 * 48 ksps, 16 bits/sample, x160 multiplier = 122.88 MHz
-	 * Intial I2S output/master clock(?):
+	 * Initial I2S output/master clock(?):
 	 * 48 ksps, 16 bits/sample, x16 multiplier = 12.288 MHz
 	 */
 	switch (state->id) {
@@ -903,7 +903,7 @@ static void input_change(struct i2c_client *client)
 	} else if (std & V4L2_STD_PAL) {
 		/* Autodetect audio standard and audio system */
 		cx25840_write(client, 0x808, 0xff);
-		/* Since system PAL-L is pretty much non-existant and
+		/* Since system PAL-L is pretty much non-existent and
 		   not used by any public broadcast network, force
 		   6.5 MHz carrier to be interpreted as System DK,
 		   this avoids DK audio detection instability */
@@ -1851,7 +1851,7 @@ static u32 get_cx2388x_ident(struct i2c_client *client)
 			ret = V4L2_IDENT_CX23885_AV;
 		} else {
 			/* CX23887 has a broken DIF, but the registers
-			 * appear valid (but unsed), good enough to detect. */
+			 * appear valid (but unused), good enough to detect. */
 			ret = V4L2_IDENT_CX23887_AV;
 		}
 	} else if (cx25840_read4(client, 0x300) & 0x0fffffff) {
diff --git a/drivers/media/video/davinci/dm644x_ccdc.c b/drivers/media/video/davinci/dm644x_ccdc.c
index 490aafb..c8b32c1 100644
--- a/drivers/media/video/davinci/dm644x_ccdc.c
+++ b/drivers/media/video/davinci/dm644x_ccdc.c
@@ -258,7 +258,7 @@ static int ccdc_update_raw_params(struct ccdc_config_params_raw *raw_params)
 	/*
 	 * Allocate memory for FPC table if current
 	 * FPC table buffer is not big enough to
-	 * accomodate FPC Number requested
+	 * accommodate FPC Number requested
 	 */
 	if (raw_params->fault_pxl.fp_num != config_params->fault_pxl.fp_num) {
 		if (fpc_physaddr != NULL) {
@@ -436,7 +436,7 @@ void ccdc_config_ycbcr(void)
 
 	/*
 	 * configure the horizontal line offset. This should be a
-	 * on 32 byte bondary. So clear LSB 5 bits
+	 * on 32 byte boundary. So clear LSB 5 bits
 	 */
 	regw(((params->win.width * 2  + 31) & ~0x1f), CCDC_HSIZE_OFF);
 
diff --git a/drivers/media/video/davinci/vpfe_capture.c b/drivers/media/video/davinci/vpfe_capture.c
index 71e961e..5b38fc9 100644
--- a/drivers/media/video/davinci/vpfe_capture.c
+++ b/drivers/media/video/davinci/vpfe_capture.c
@@ -1691,7 +1691,7 @@ static int vpfe_s_crop(struct file *file, void *priv,
 		goto unlock_out;
 	}
 
-	/* adjust the width to 16 pixel boundry */
+	/* adjust the width to 16 pixel boundary */
 	crop->c.width = ((crop->c.width + 15) & ~0xf);
 
 	/* make sure parameters are valid */
diff --git a/drivers/media/video/em28xx/em28xx-video.c b/drivers/media/video/em28xx/em28xx-video.c
index a83131b..7b6461d 100644
--- a/drivers/media/video/em28xx/em28xx-video.c
+++ b/drivers/media/video/em28xx/em28xx-video.c
@@ -377,7 +377,7 @@ static inline void get_next_buf(struct em28xx_dmaqueue *dma_q,
 	/* Get the next buffer */
 	*buf = list_entry(dma_q->active.next, struct em28xx_buffer, vb.queue);
 
-	/* Cleans up buffer - Usefull for testing for frame/URB loss */
+	/* Cleans up buffer - Useful for testing for frame/URB loss */
 	outp = videobuf_to_vmalloc(&(*buf)->vb);
 	memset(outp, 0, (*buf)->vb.size);
 
@@ -404,7 +404,7 @@ static inline void vbi_get_next_buf(struct em28xx_dmaqueue *dma_q,
 
 	/* Get the next buffer */
 	*buf = list_entry(dma_q->active.next, struct em28xx_buffer, vb.queue);
-	/* Cleans up buffer - Usefull for testing for frame/URB loss */
+	/* Cleans up buffer - Useful for testing for frame/URB loss */
 	outp = videobuf_to_vmalloc(&(*buf)->vb);
 	memset(outp, 0x00, (*buf)->vb.size);
 
diff --git a/drivers/media/video/gspca/gl860/gl860-mi1320.c b/drivers/media/video/gspca/gl860/gl860-mi1320.c
index c276a7d..b57160e 100644
--- a/drivers/media/video/gspca/gl860/gl860-mi1320.c
+++ b/drivers/media/video/gspca/gl860/gl860-mi1320.c
@@ -201,7 +201,7 @@ void mi1320_init_settings(struct gspca_dev *gspca_dev)
 	sd->vmax.backlight  =  2;
 	sd->vmax.brightness =  8;
 	sd->vmax.sharpness  =  7;
-	sd->vmax.contrast   =  0; /* 10 but not working with tihs driver */
+	sd->vmax.contrast   =  0; /* 10 but not working with this driver */
 	sd->vmax.gamma      = 40;
 	sd->vmax.hue        =  5 + 1;
 	sd->vmax.saturation =  8;
diff --git a/drivers/media/video/gspca/gspca.c b/drivers/media/video/gspca/gspca.c
index 9c6a643..e526aa3 100644
--- a/drivers/media/video/gspca/gspca.c
+++ b/drivers/media/video/gspca/gspca.c
@@ -857,7 +857,7 @@ static int gspca_init_transfer(struct gspca_dev *gspca_dev)
 		}
 
 		/* the bandwidth is not wide enough
-		 * negociate or try a lower alternate setting */
+		 * negotiate or try a lower alternate setting */
 		PDEBUG(D_ERR|D_STREAM,
 			"bandwidth not wide enough - trying again");
 		msleep(20);	/* wait for kill complete */
@@ -2346,7 +2346,7 @@ void gspca_disconnect(struct usb_interface *intf)
 	usb_set_intfdata(intf, NULL);
 
 	/* release the device */
-	/* (this will call gspca_release() immediatly or on last close) */
+	/* (this will call gspca_release() immediately or on last close) */
 	video_unregister_device(&gspca_dev->vdev);
 
 /*	PDEBUG(D_PROBE, "disconnect complete"); */
diff --git a/drivers/media/video/gspca/mars.c b/drivers/media/video/gspca/mars.c
index cb4d0bf..0196209 100644
--- a/drivers/media/video/gspca/mars.c
+++ b/drivers/media/video/gspca/mars.c
@@ -361,7 +361,7 @@ static int sd_start(struct gspca_dev *gspca_dev)
 		mi_w(gspca_dev, i + 1, mi_data[i]);
 
 	data[0] = 0x00;
-	data[1] = 0x4d;		/* ISOC transfering enable... */
+	data[1] = 0x4d;		/* ISOC transferring enable... */
 	reg_w(gspca_dev, 2);
 
 	gspca_dev->ctrl_inac = 0; /* activate the illuminator controls */
diff --git a/drivers/media/video/gspca/mr97310a.c b/drivers/media/video/gspca/mr97310a.c
index 3884c9d..97e5079 100644
--- a/drivers/media/video/gspca/mr97310a.c
+++ b/drivers/media/video/gspca/mr97310a.c
@@ -469,7 +469,7 @@ static void lcd_stop(struct gspca_dev *gspca_dev)
 static int isoc_enable(struct gspca_dev *gspca_dev)
 {
 	gspca_dev->usb_buf[0] = 0x00;
-	gspca_dev->usb_buf[1] = 0x4d;  /* ISOC transfering enable... */
+	gspca_dev->usb_buf[1] = 0x4d;  /* ISOC transferring enable... */
 	return mr_write(gspca_dev, 2);
 }
 
diff --git a/drivers/media/video/gspca/ov519.c b/drivers/media/video/gspca/ov519.c
index fd1b608..36a46fc 100644
--- a/drivers/media/video/gspca/ov519.c
+++ b/drivers/media/video/gspca/ov519.c
@@ -381,7 +381,7 @@ static const struct v4l2_pix_format ov519_sif_mode[] = {
    larger then necessary, however they need to be this big as the ov511 /
    ov518 always fills the entire isoc frame, using 0 padding bytes when
    it doesn't have any data. So with low framerates the amount of data
-   transfered can become quite large (libv4l will remove all the 0 padding
+   transferred can become quite large (libv4l will remove all the 0 padding
    in userspace). */
 static const struct v4l2_pix_format ov518_vga_mode[] = {
 	{320, 240, V4L2_PIX_FMT_OV518, V4L2_FIELD_NONE,
@@ -4368,7 +4368,7 @@ static void ov511_pkt_scan(struct gspca_dev *gspca_dev,
 				gspca_dev->last_packet_type = DISCARD_PACKET;
 				return;
 			}
-			/* Add 11 byte footer to frame, might be usefull */
+			/* Add 11 byte footer to frame, might be useful */
 			gspca_frame_add(gspca_dev, LAST_PACKET, in, 11);
 			return;
 		} else {
diff --git a/drivers/media/video/gspca/sonixb.c b/drivers/media/video/gspca/sonixb.c
index 5a08738..146b459 100644
--- a/drivers/media/video/gspca/sonixb.c
+++ b/drivers/media/video/gspca/sonixb.c
@@ -827,7 +827,7 @@ static void setexposure(struct gspca_dev *gspca_dev)
 		   possible to use less exposure then what the fps maximum
 		   allows by setting register 10. register 10 configures the
 		   actual exposure as quotient of the full exposure, with 0
-		   being no exposure at all (not very usefull) and reg10_max
+		   being no exposure at all (not very useful) and reg10_max
 		   being max exposure possible at that framerate.
 
 		   The code maps our 0 - 510 ms exposure ctrl to these 2
diff --git a/drivers/media/video/gspca/spca500.c b/drivers/media/video/gspca/spca500.c
index 45552c3..3e76951 100644
--- a/drivers/media/video/gspca/spca500.c
+++ b/drivers/media/video/gspca/spca500.c
@@ -607,7 +607,7 @@ static void spca500_reinit(struct gspca_dev *gspca_dev)
 	reg_w(gspca_dev, 0x00, 0x8880, 2);
 	/* family cam Quicksmart stuff */
 	reg_w(gspca_dev, 0x00, 0x800a, 0x00);
-	/* Set agc transfer: synced inbetween frames */
+	/* Set agc transfer: synced between frames */
 	reg_w(gspca_dev, 0x00, 0x820f, 0x01);
 	/* Init SDRAM - needed for SDRAM access */
 	reg_w(gspca_dev, 0x00, 0x870a, 0x04);
@@ -831,7 +831,7 @@ static int sd_start(struct gspca_dev *gspca_dev)
 
 		/* familycam Quicksmart pocketDV stuff */
 		reg_w(gspca_dev, 0x00, 0x800a, 0x00);
-		/* Set agc transfer: synced inbetween frames */
+		/* Set agc transfer: synced between frames */
 		reg_w(gspca_dev, 0x00, 0x820f, 0x01);
 		/* Init SDRAM - needed for SDRAM access */
 		reg_w(gspca_dev, 0x00, 0x870a, 0x04);
diff --git a/drivers/media/video/gspca/spca508.c b/drivers/media/video/gspca/spca508.c
index 3483193..41dce49 100644
--- a/drivers/media/video/gspca/spca508.c
+++ b/drivers/media/video/gspca/spca508.c
@@ -592,7 +592,7 @@ static const u16 spca508_sightcam_init_data[][2] = {
 /* This line seems to setup the frame/canvas */
 	{0x000f, 0x8402},
 
-/* Theese 6 lines are needed to startup the webcam */
+/* These 6 lines are needed to startup the webcam */
 	{0x0090, 0x8110},
 	{0x0001, 0x8114},
 	{0x0001, 0x8114},
diff --git a/drivers/media/video/gspca/sq905.c b/drivers/media/video/gspca/sq905.c
index 2e9c061..5ba96af 100644
--- a/drivers/media/video/gspca/sq905.c
+++ b/drivers/media/video/gspca/sq905.c
@@ -22,7 +22,7 @@
  * History and Acknowledgments
  *
  * The original Linux driver for SQ905 based cameras was written by
- * Marcell Lengyel and furter developed by many other contributers
+ * Marcell Lengyel and furter developed by many other contributors
  * and is available from http://sourceforge.net/projects/sqcam/
  *
  * This driver takes advantage of the reverse engineering work done for
diff --git a/drivers/media/video/gspca/stv06xx/stv06xx_hdcs.c b/drivers/media/video/gspca/stv06xx/stv06xx_hdcs.c
index 17531b4..b815685 100644
--- a/drivers/media/video/gspca/stv06xx/stv06xx_hdcs.c
+++ b/drivers/media/video/gspca/stv06xx/stv06xx_hdcs.c
@@ -569,7 +569,7 @@ static int hdcs_init(struct sd *sd)
 	if (err < 0)
 		return err;
 
-	/* Enable continous frame capture, bit 2: stop when frame complete */
+	/* Enable continuous frame capture, bit 2: stop when frame complete */
 	err = stv06xx_write_sensor(sd, HDCS_REG_CONFIG(sd), BIT(3));
 	if (err < 0)
 		return err;
diff --git a/drivers/media/video/hexium_gemini.c b/drivers/media/video/hexium_gemini.c
index cdf8b19..cbc505a 100644
--- a/drivers/media/video/hexium_gemini.c
+++ b/drivers/media/video/hexium_gemini.c
@@ -261,7 +261,7 @@ static int vidioc_s_input(struct file *file, void *fh, unsigned int input)
 
 /* the saa7146 provides some controls (brightness, contrast, saturation)
    which gets registered *after* this function. because of this we have
-   to return with a value != 0 even if the function succeded.. */
+   to return with a value != 0 even if the function succeeded.. */
 static int vidioc_queryctrl(struct file *file, void *fh, struct v4l2_queryctrl *qc)
 {
 	struct saa7146_dev *dev = ((struct saa7146_fh *)fh)->dev;
diff --git a/drivers/media/video/ivtv/ivtv-firmware.c b/drivers/media/video/ivtv/ivtv-firmware.c
index 4df0194..14a1cea 100644
--- a/drivers/media/video/ivtv/ivtv-firmware.c
+++ b/drivers/media/video/ivtv/ivtv-firmware.c
@@ -179,7 +179,7 @@ static volatile struct ivtv_mailbox __iomem *ivtv_search_mailbox(const volatile
 {
 	int i;
 
-	/* mailbox is preceeded by a 16 byte 'magic cookie' starting at a 256-byte
+	/* mailbox is preceded by a 16 byte 'magic cookie' starting at a 256-byte
 	   address boundary */
 	for (i = 0; i < size; i += 0x100) {
 		if (readl(mem + i)      == 0x12345678 &&
@@ -377,7 +377,7 @@ int ivtv_firmware_check(struct ivtv *itv, char *where)
 			  "Reloading\n", where);
 		res = ivtv_firmware_restart(itv);
 		/*
-		 * Even if restarted ok, still signal a problem had occured.
+		 * Even if restarted ok, still signal a problem had occurred.
 		 * The caller can come through this function again to check
 		 * if things are really ok after the restart.
 		 */
diff --git a/drivers/media/video/ivtv/ivtvfb.c b/drivers/media/video/ivtv/ivtvfb.c
index f0316d0..1724745 100644
--- a/drivers/media/video/ivtv/ivtvfb.c
+++ b/drivers/media/video/ivtv/ivtvfb.c
@@ -1080,7 +1080,7 @@ static int ivtvfb_init_vidmode(struct ivtv *itv)
 		kmalloc(sizeof(u32) * 16, GFP_KERNEL|__GFP_NOWARN);
 
 	if (!oi->ivtvfb_info.pseudo_palette) {
-		IVTVFB_ERR("abort, unable to alloc pseudo pallete\n");
+		IVTVFB_ERR("abort, unable to alloc pseudo palette\n");
 		return -ENOMEM;
 	}
 
diff --git a/drivers/media/video/msp3400-driver.c b/drivers/media/video/msp3400-driver.c
index b1763ac..8126622 100644
--- a/drivers/media/video/msp3400-driver.c
+++ b/drivers/media/video/msp3400-driver.c
@@ -69,7 +69,7 @@ MODULE_LICENSE("GPL");
 /* module parameters */
 static int opmode   = OPMODE_AUTO;
 int msp_debug;		 /* msp_debug output */
-int msp_once;		 /* no continous stereo monitoring */
+int msp_once;		 /* no continuous stereo monitoring */
 int msp_amsound;	 /* hard-wire AM sound at 6.5 Hz (france),
 			    the autoscan seems work well only with FM... */
 int msp_standard = 1;    /* Override auto detect of audio msp_standard,
@@ -551,7 +551,7 @@ static int msp_log_status(struct v4l2_subdev *sd)
 	switch (state->mode) {
 		case MSP_MODE_AM_DETECT: p = "AM (for carrier detect)"; break;
 		case MSP_MODE_FM_RADIO: p = "FM Radio"; break;
-		case MSP_MODE_FM_TERRA: p = "Terrestial FM-mono/stereo"; break;
+		case MSP_MODE_FM_TERRA: p = "Terrestrial FM-mono/stereo"; break;
 		case MSP_MODE_FM_SAT: p = "Satellite FM-mono"; break;
 		case MSP_MODE_FM_NICAM1: p = "NICAM/FM (B/G, D/K)"; break;
 		case MSP_MODE_FM_NICAM2: p = "NICAM/FM (I)"; break;
diff --git a/drivers/media/video/msp3400-kthreads.c b/drivers/media/video/msp3400-kthreads.c
index b376fcd..80387e2 100644
--- a/drivers/media/video/msp3400-kthreads.c
+++ b/drivers/media/video/msp3400-kthreads.c
@@ -87,7 +87,7 @@ static struct msp3400c_init_data_dem {
 		{-8, -8, 4, 6, 78, 107},
 		MSP_CARRIER(10.7), MSP_CARRIER(10.7),
 		0x00d0, 0x0480, 0x0020, 0x3000
-	}, {	/* Terrestial FM-mono + FM-stereo */
+	}, {	/* Terrestrial FM-mono + FM-stereo */
 		{3, 18, 27, 48, 66, 72},
 		{3, 18, 27, 48, 66, 72},
 		MSP_CARRIER(5.5), MSP_CARRIER(5.5),
diff --git a/drivers/media/video/omap/omap_vout.c b/drivers/media/video/omap/omap_vout.c
index 029a4ba..d4fe7bc 100644
--- a/drivers/media/video/omap/omap_vout.c
+++ b/drivers/media/video/omap/omap_vout.c
@@ -473,7 +473,7 @@ static int omap_vout_vrfb_buffer_setup(struct omap_vout_device *vout,
 /*
  * Convert V4L2 rotation to DSS rotation
  *	V4L2 understand 0, 90, 180, 270.
- *	Convert to 0, 1, 2 and 3 repsectively for DSS
+ *	Convert to 0, 1, 2 and 3 respectively for DSS
  */
 static int v4l2_rot_to_dss_rot(int v4l2_rotation,
 			enum dss_rotation *rotation, bool mirror)
@@ -1142,7 +1142,7 @@ static int omap_vout_buffer_prepare(struct videobuf_queue *q,
 }
 
 /*
- * Buffer queue funtion will be called from the videobuf layer when _QBUF
+ * Buffer queue function will be called from the videobuf layer when _QBUF
  * ioctl is called. It is used to enqueue buffer, which is ready to be
  * displayed.
  */
diff --git a/drivers/media/video/omap/omap_voutlib.c b/drivers/media/video/omap/omap_voutlib.c
index b941c76..2aa6a76 100644
--- a/drivers/media/video/omap/omap_voutlib.c
+++ b/drivers/media/video/omap/omap_voutlib.c
@@ -53,7 +53,7 @@ EXPORT_SYMBOL_GPL(omap_vout_default_crop);
 /* Given a new render window in new_win, adjust the window to the
  * nearest supported configuration.  The adjusted window parameters are
  * returned in new_win.
- * Returns zero if succesful, or -EINVAL if the requested window is
+ * Returns zero if successful, or -EINVAL if the requested window is
  * impossible and cannot reasonably be adjusted.
  */
 int omap_vout_try_window(struct v4l2_framebuffer *fbuf,
@@ -101,7 +101,7 @@ EXPORT_SYMBOL_GPL(omap_vout_try_window);
  * will also be adjusted if necessary.  Preference is given to keeping the
  * the window as close to the requested configuration as possible.  If
  * successful, new_win, vout->win, and crop are updated.
- * Returns zero if succesful, or -EINVAL if the requested preview window is
+ * Returns zero if successful, or -EINVAL if the requested preview window is
  * impossible and cannot reasonably be adjusted.
  */
 int omap_vout_new_window(struct v4l2_rect *crop,
@@ -155,7 +155,7 @@ EXPORT_SYMBOL_GPL(omap_vout_new_window);
  * window would fall outside the display boundaries, the cropping rectangle
  * will also be adjusted to maintain the rescaling ratios.  If successful, crop
  * and win are updated.
- * Returns zero if succesful, or -EINVAL if the requested cropping rectangle is
+ * Returns zero if successful, or -EINVAL if the requested cropping rectangle is
  * impossible and cannot reasonably be adjusted.
  */
 int omap_vout_new_crop(struct v4l2_pix_format *pix,
diff --git a/drivers/media/video/omap1_camera.c b/drivers/media/video/omap1_camera.c
index eab31cb..5954b93 100644
--- a/drivers/media/video/omap1_camera.c
+++ b/drivers/media/video/omap1_camera.c
@@ -687,7 +687,7 @@ static void videobuf_done(struct omap1_cam_dev *pcdev,
 		 * In CONTIG mode, the current buffer parameters had already
 		 * been entered into the DMA programming register set while the
 		 * buffer was fetched with prepare_next_vb(), they may have also
-		 * been transfered into the runtime set and already active if
+		 * been transferred into the runtime set and already active if
 		 * the DMA still running.
 		 */
 	} else {
@@ -835,7 +835,7 @@ static irqreturn_t cam_isr(int irq, void *data)
 				/*
 				 * If exactly 2 sgbufs from the next sglist have
 				 * been programmed into the DMA engine (the
-				 * frist one already transfered into the DMA
+				 * first one already transferred into the DMA
 				 * runtime register set, the second one still
 				 * in the programming set), then we are in sync.
 				 */
diff --git a/drivers/media/video/omap3isp/isp.c b/drivers/media/video/omap3isp/isp.c
index 1a9963bd..503bd79 100644
--- a/drivers/media/video/omap3isp/isp.c
+++ b/drivers/media/video/omap3isp/isp.c
@@ -715,7 +715,7 @@ static int isp_pipeline_link_notify(struct media_pad *source,
  * Walk the entities chain starting at the pipeline output video node and start
  * all modules in the chain in the given mode.
  *
- * Return 0 if successfull, or the return value of the failed video::s_stream
+ * Return 0 if successful, or the return value of the failed video::s_stream
  * operation otherwise.
  */
 static int isp_pipeline_enable(struct isp_pipeline *pipe,
@@ -883,7 +883,7 @@ static int isp_pipeline_disable(struct isp_pipeline *pipe)
  * Set the pipeline to the given stream state. Pipelines can be started in
  * single-shot or continuous mode.
  *
- * Return 0 if successfull, or the return value of the failed video::s_stream
+ * Return 0 if successful, or the return value of the failed video::s_stream
  * operation otherwise.
  */
 int omap3isp_pipeline_set_stream(struct isp_pipeline *pipe,
@@ -1283,7 +1283,7 @@ static void __isp_subclk_update(struct isp_device *isp)
 		clk |= ISPCTRL_RSZ_CLK_EN;
 
 	/* NOTE: For CCDC & Preview submodules, we need to affect internal
-	 *       RAM aswell.
+	 *       RAM as well.
 	 */
 	if (isp->subclk_resources & OMAP3_ISP_SUBCLK_CCDC)
 		clk |= ISPCTRL_CCDC_CLK_EN | ISPCTRL_CCDC_RAM_EN;
@@ -1431,7 +1431,7 @@ static int isp_get_clocks(struct isp_device *isp)
  * Increment the reference count on the ISP. If the first reference is taken,
  * enable clocks and power-up all submodules.
  *
- * Return a pointer to the ISP device structure, or NULL if an error occured.
+ * Return a pointer to the ISP device structure, or NULL if an error occurred.
  */
 struct isp_device *omap3isp_get(struct isp_device *isp)
 {
diff --git a/drivers/media/video/omap3isp/ispccdc.h b/drivers/media/video/omap3isp/ispccdc.h
index d403af5..483a19c 100644
--- a/drivers/media/video/omap3isp/ispccdc.h
+++ b/drivers/media/video/omap3isp/ispccdc.h
@@ -150,7 +150,7 @@ struct ispccdc_lsc {
  * @input: Active input
  * @output: Active outputs
  * @video_out: Output video node
- * @error: A hardware error occured during capture
+ * @error: A hardware error occurred during capture
  * @alaw: A-law compression enabled (1) or disabled (0)
  * @lpf: Low pass filter enabled (1) or disabled (0)
  * @obclamp: Optical-black clamp enabled (1) or disabled (0)
@@ -163,7 +163,7 @@ struct ispccdc_lsc {
  * @shadow_update: Controls update in progress by userspace
  * @syncif: Interface synchronization configuration
  * @vpcfg: Video port configuration
- * @underrun: A buffer underrun occured and a new buffer has been queued
+ * @underrun: A buffer underrun occurred and a new buffer has been queued
  * @state: Streaming state
  * @lock: Serializes shadow_update with interrupt handler
  * @wait: Wait queue used to stop the module
diff --git a/drivers/media/video/omap3isp/ispccp2.c b/drivers/media/video/omap3isp/ispccp2.c
index 0efef2e..0e16cab 100644
--- a/drivers/media/video/omap3isp/ispccp2.c
+++ b/drivers/media/video/omap3isp/ispccp2.c
@@ -772,7 +772,7 @@ static int ccp2_enum_frame_size(struct v4l2_subdev *sd,
  * @sd    : pointer to v4l2 subdev structure
  * @fh    : V4L2 subdev file handle
  * @fmt   : pointer to v4l2 subdev format structure
- * return -EINVAL or zero on sucess
+ * return -EINVAL or zero on success
  */
 static int ccp2_get_format(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
 			      struct v4l2_subdev_format *fmt)
diff --git a/drivers/media/video/omap3isp/ispcsi2.c b/drivers/media/video/omap3isp/ispcsi2.c
index fb503f3..69161a6 100644
--- a/drivers/media/video/omap3isp/ispcsi2.c
+++ b/drivers/media/video/omap3isp/ispcsi2.c
@@ -969,7 +969,7 @@ static int csi2_enum_frame_size(struct v4l2_subdev *sd,
  * @sd : pointer to v4l2 subdev structure
  * @fh : V4L2 subdev file handle
  * @fmt: pointer to v4l2 subdev format structure
- * return -EINVAL or zero on sucess
+ * return -EINVAL or zero on success
  */
 static int csi2_get_format(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
 			   struct v4l2_subdev_format *fmt)
diff --git a/drivers/media/video/omap3isp/isppreview.c b/drivers/media/video/omap3isp/isppreview.c
index baf9374..2b16988 100644
--- a/drivers/media/video/omap3isp/isppreview.c
+++ b/drivers/media/video/omap3isp/isppreview.c
@@ -34,7 +34,7 @@
 #include "ispreg.h"
 #include "isppreview.h"
 
-/* Default values in Office Flourescent Light for RGBtoRGB Blending */
+/* Default values in Office Fluorescent Light for RGBtoRGB Blending */
 static struct omap3isp_prev_rgbtorgb flr_rgb2rgb = {
 	{	/* RGB-RGB Matrix */
 		{0x01E2, 0x0F30, 0x0FEE},
@@ -44,7 +44,7 @@ static struct omap3isp_prev_rgbtorgb flr_rgb2rgb = {
 	{0x0000, 0x0000, 0x0000}
 };
 
-/* Default values in Office Flourescent Light for RGB to YUV Conversion*/
+/* Default values in Office Fluorescent Light for RGB to YUV Conversion*/
 static struct omap3isp_prev_csc flr_prev_csc = {
 	{	/* CSC Coef Matrix */
 		{66, 129, 25},
@@ -54,22 +54,22 @@ static struct omap3isp_prev_csc flr_prev_csc = {
 	{0x0, 0x0, 0x0}
 };
 
-/* Default values in Office Flourescent Light for CFA Gradient*/
+/* Default values in Office Fluorescent Light for CFA Gradient*/
 #define FLR_CFA_GRADTHRS_HORZ	0x28
 #define FLR_CFA_GRADTHRS_VERT	0x28
 
-/* Default values in Office Flourescent Light for Chroma Suppression*/
+/* Default values in Office Fluorescent Light for Chroma Suppression*/
 #define FLR_CSUP_GAIN		0x0D
 #define FLR_CSUP_THRES		0xEB
 
-/* Default values in Office Flourescent Light for Noise Filter*/
+/* Default values in Office Fluorescent Light for Noise Filter*/
 #define FLR_NF_STRGTH		0x03
 
 /* Default values for White Balance */
 #define FLR_WBAL_DGAIN		0x100
 #define FLR_WBAL_COEF		0x20
 
-/* Default values in Office Flourescent Light for Black Adjustment*/
+/* Default values in Office Fluorescent Light for Black Adjustment*/
 #define FLR_BLKADJ_BLUE		0x0
 #define FLR_BLKADJ_GREEN	0x0
 #define FLR_BLKADJ_RED		0x0
@@ -137,7 +137,7 @@ preview_enable_invalaw(struct isp_prev_device *prev, u8 enable)
  * @enable: 1 - Enable, 0 - Disable
  *
  * NOTE: PRV_WSDR_ADDR and PRV_WADD_OFFSET must be set also
- * The proccess is applied for each captured frame.
+ * The process is applied for each captured frame.
  */
 static void
 preview_enable_drkframe_capture(struct isp_prev_device *prev, u8 enable)
@@ -157,7 +157,7 @@ preview_enable_drkframe_capture(struct isp_prev_device *prev, u8 enable)
  * @enable: 1 - Acquires memory bandwidth since the pixels in each frame is
  *          subtracted with the pixels in the current frame.
  *
- * The proccess is applied for each captured frame.
+ * The process is applied for each captured frame.
  */
 static void
 preview_enable_drkframe(struct isp_prev_device *prev, u8 enable)
@@ -1528,7 +1528,7 @@ static long preview_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
  * preview_set_stream - Enable/Disable streaming on preview subdev
  * @sd    : pointer to v4l2 subdev structure
  * @enable: 1 == Enable, 0 == Disable
- * return -EINVAL or zero on sucess
+ * return -EINVAL or zero on success
  */
 static int preview_set_stream(struct v4l2_subdev *sd, int enable)
 {
@@ -1780,7 +1780,7 @@ static int preview_enum_frame_size(struct v4l2_subdev *sd,
  * @sd : pointer to v4l2 subdev structure
  * @fh : V4L2 subdev file handle
  * @fmt: pointer to v4l2 subdev format structure
- * return -EINVAL or zero on sucess
+ * return -EINVAL or zero on success
  */
 static int preview_get_format(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
 			      struct v4l2_subdev_format *fmt)
diff --git a/drivers/media/video/omap3isp/isppreview.h b/drivers/media/video/omap3isp/isppreview.h
index f2d63ca..fa943bd 100644
--- a/drivers/media/video/omap3isp/isppreview.h
+++ b/drivers/media/video/omap3isp/isppreview.h
@@ -163,7 +163,7 @@ struct isptables_update {
  * @output: Bitmask of the active output
  * @video_in: Input video entity
  * @video_out: Output video entity
- * @error: A hardware error occured during capture
+ * @error: A hardware error occurred during capture
  * @params: Module configuration data
  * @shadow_update: If set, update the hardware configured in the next interrupt
  * @underrun: Whether the preview entity has queued buffers on the output
diff --git a/drivers/media/video/omap3isp/ispqueue.h b/drivers/media/video/omap3isp/ispqueue.h
index 251de3e..92c5a12 100644
--- a/drivers/media/video/omap3isp/ispqueue.h
+++ b/drivers/media/video/omap3isp/ispqueue.h
@@ -46,9 +46,9 @@ struct scatterlist;
  *	device yet.
  * @ISP_BUF_STATE_ACTIVE: The buffer is in use for an active video transfer.
  * @ISP_BUF_STATE_ERROR: The device is done with the buffer and an error
- *	occured. For capture device the buffer likely contains corrupted data or
+ *	occurred. For capture device the buffer likely contains corrupted data or
  *	no data at all.
- * @ISP_BUF_STATE_DONE: The device is done with the buffer and no error occured.
+ * @ISP_BUF_STATE_DONE: The device is done with the buffer and no error occurred.
  *	For capture devices the buffer contains valid data.
  */
 enum isp_video_buffer_state {
diff --git a/drivers/media/video/omap3isp/ispresizer.c b/drivers/media/video/omap3isp/ispresizer.c
index 75d39b1..653f88b 100644
--- a/drivers/media/video/omap3isp/ispresizer.c
+++ b/drivers/media/video/omap3isp/ispresizer.c
@@ -751,7 +751,7 @@ static void resizer_print_status(struct isp_res_device *res)
  * ratio will thus result in a resizing factor slightly larger than the
  * requested value.
  *
- * To accomodate that, and make sure the TRM equations are satisfied exactly, we
+ * To accommodate that, and make sure the TRM equations are satisfied exactly, we
  * compute the input crop rectangle as the last step.
  *
  * As if the situation wasn't complex enough, the maximum output width depends
@@ -1386,7 +1386,7 @@ static int resizer_enum_frame_size(struct v4l2_subdev *sd,
  * @sd    : pointer to v4l2 subdev structure
  * @fh    : V4L2 subdev file handle
  * @fmt   : pointer to v4l2 subdev format structure
- * return -EINVAL or zero on sucess
+ * return -EINVAL or zero on success
  */
 static int resizer_get_format(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
 			      struct v4l2_subdev_format *fmt)
diff --git a/drivers/media/video/omap3isp/ispvideo.c b/drivers/media/video/omap3isp/ispvideo.c
index a0bb5db..208a7ec 100644
--- a/drivers/media/video/omap3isp/ispvideo.c
+++ b/drivers/media/video/omap3isp/ispvideo.c
@@ -494,12 +494,12 @@ static const struct isp_video_queue_operations isp_video_queue_ops = {
 /*
  * omap3isp_video_buffer_next - Complete the current buffer and return the next
  * @video: ISP video object
- * @error: Whether an error occured during capture
+ * @error: Whether an error occurred during capture
  *
  * Remove the current video buffer from the DMA queue and fill its timestamp,
  * field count and state fields before waking up its completion handler.
  *
- * The buffer state is set to VIDEOBUF_DONE if no error occured (@error is 0)
+ * The buffer state is set to VIDEOBUF_DONE if no error occurred (@error is 0)
  * or VIDEOBUF_ERROR otherwise (@error is non-zero).
  *
  * The DMA queue is expected to contain at least one buffer.
@@ -578,7 +578,7 @@ struct isp_buffer *omap3isp_video_buffer_next(struct isp_video *video,
 /*
  * omap3isp_video_resume - Perform resume operation on the buffers
  * @video: ISP video object
- * @continuous: Pipeline is in single shot mode if 0 or continous mode otherwise
+ * @continuous: Pipeline is in single shot mode if 0 or continuous mode otherwise
  *
  * This function is intended to be used on suspend/resume scenario. It
  * requests video queue layer to discard buffers marked as DONE if it's in
diff --git a/drivers/media/video/ov6650.c b/drivers/media/video/ov6650.c
index fe8e3eb..456d9ad 100644
--- a/drivers/media/video/ov6650.c
+++ b/drivers/media/video/ov6650.c
@@ -1038,7 +1038,7 @@ static int ov6650_reset(struct i2c_client *client)
 	ret = ov6650_reg_rmw(client, REG_COMA, COMA_RESET, 0);
 	if (ret)
 		dev_err(&client->dev,
-			"An error occured while entering soft reset!\n");
+			"An error occurred while entering soft reset!\n");
 
 	return ret;
 }
diff --git a/drivers/media/video/ov9640.c b/drivers/media/video/ov9640.c
index 53d88a2..5173ac4 100644
--- a/drivers/media/video/ov9640.c
+++ b/drivers/media/video/ov9640.c
@@ -273,7 +273,7 @@ static int ov9640_reset(struct i2c_client *client)
 	ret = ov9640_reg_write(client, OV9640_COM7, OV9640_COM7_SCCB_RESET);
 	if (ret)
 		dev_err(&client->dev,
-			"An error occured while entering soft reset!\n");
+			"An error occurred while entering soft reset!\n");
 
 	return ret;
 }
diff --git a/drivers/media/video/pvrusb2/pvrusb2-eeprom.c b/drivers/media/video/pvrusb2/pvrusb2-eeprom.c
index aeed1c2..9515f3a 100644
--- a/drivers/media/video/pvrusb2/pvrusb2-eeprom.c
+++ b/drivers/media/video/pvrusb2/pvrusb2-eeprom.c
@@ -32,7 +32,7 @@
 
    Read and analyze data in the eeprom.  Use tveeprom to figure out
    the packet structure, since this is another Hauppauge device and
-   internally it has a family resemblence to ivtv-type devices
+   internally it has a family resemblance to ivtv-type devices
 
 */
 
diff --git a/drivers/media/video/pvrusb2/pvrusb2-hdw.h b/drivers/media/video/pvrusb2/pvrusb2-hdw.h
index 51d3009..d7753ae 100644
--- a/drivers/media/video/pvrusb2/pvrusb2-hdw.h
+++ b/drivers/media/video/pvrusb2/pvrusb2-hdw.h
@@ -75,7 +75,7 @@ enum pvr2_v4l_type {
  *  (but it might still on the bus).  In this state there's nothing we can
  *  do; it must be replugged in order to recover.
  *
- *  COLD - Device is in an unusuable state, needs microcontroller firmware.
+ *  COLD - Device is in an unusable state, needs microcontroller firmware.
  *
  *  WARM - We can communicate with the device and the proper
  *  microcontroller firmware is running, but other device initialization is
diff --git a/drivers/media/video/pxa_camera.c b/drivers/media/video/pxa_camera.c
index 0268677..c1ee09a 100644
--- a/drivers/media/video/pxa_camera.c
+++ b/drivers/media/video/pxa_camera.c
@@ -714,7 +714,7 @@ static void pxa_camera_wakeup(struct pxa_camera_dev *pcdev,
  *
  * The DMA chaining is done with DMA running. This means a tiny temporal window
  * remains, where a buffer is queued on the chain, while the chain is already
- * stopped. This means the tailed buffer would never be transfered by DMA.
+ * stopped. This means the tailed buffer would never be transferred by DMA.
  * This function restarts the capture for this corner case, where :
  *  - DADR() == DADDR_STOP
  *  - a videobuffer is queued on the pcdev->capture list
diff --git a/drivers/media/video/s5p-fimc/fimc-reg.c b/drivers/media/video/s5p-fimc/fimc-reg.c
index 4d929a3..4893b2d 100644
--- a/drivers/media/video/s5p-fimc/fimc-reg.c
+++ b/drivers/media/video/s5p-fimc/fimc-reg.c
@@ -356,7 +356,7 @@ void fimc_hw_en_capture(struct fimc_ctx *ctx)
 		/* one shot mode */
 		cfg |= S5P_CIIMGCPT_CPT_FREN_ENABLE | S5P_CIIMGCPT_IMGCPTEN;
 	} else {
-		/* Continous frame capture mode (freerun). */
+		/* Continuous frame capture mode (freerun). */
 		cfg &= ~(S5P_CIIMGCPT_CPT_FREN_ENABLE |
 			 S5P_CIIMGCPT_CPT_FRMOD_CNT);
 		cfg |= S5P_CIIMGCPT_IMGCPTEN;
diff --git a/drivers/media/video/saa7134/saa7134-cards.c b/drivers/media/video/saa7134/saa7134-cards.c
index 61c6007..50f1be0 100644
--- a/drivers/media/video/saa7134/saa7134-cards.c
+++ b/drivers/media/video/saa7134/saa7134-cards.c
@@ -7460,7 +7460,7 @@ int saa7134_board_init2(struct saa7134_dev *dev)
 				dev->tuner_type = TUNER_PHILIPS_FM1216ME_MK3;
 				break;
 			default:
-				printk(KERN_ERR "%s Cant determine tuner type %x from EEPROM\n", dev->name, tuner_t);
+				printk(KERN_ERR "%s Can't determine tuner type %x from EEPROM\n", dev->name, tuner_t);
 			}
 		} else if ((data[1] != 0) && (data[1] != 0xff)) {
 			/* new config structure */
@@ -7480,7 +7480,7 @@ int saa7134_board_init2(struct saa7134_dev *dev)
 					printk(KERN_INFO "%s Board has DVB-T\n", dev->name);
 				break;
 			default:
-				printk(KERN_ERR "%s Cant determine tuner type %x from EEPROM\n", dev->name, tuner_t);
+				printk(KERN_ERR "%s Can't determine tuner type %x from EEPROM\n", dev->name, tuner_t);
 			}
 		} else {
 			printk(KERN_ERR "%s unexpected config structure\n", dev->name);
diff --git a/drivers/media/video/saa7164/saa7164-cmd.c b/drivers/media/video/saa7164/saa7164-cmd.c
index 6a4c217..62fac7f 100644
--- a/drivers/media/video/saa7164/saa7164-cmd.c
+++ b/drivers/media/video/saa7164/saa7164-cmd.c
@@ -257,7 +257,7 @@ out:
 }
 
 /* Wait for a signal event, without holding a mutex. Either return TIMEOUT if
- * the event never occured, or SAA_OK if it was signaled during the wait.
+ * the event never occurred, or SAA_OK if it was signaled during the wait.
  */
 int saa7164_cmd_wait(struct saa7164_dev *dev, u8 seqno)
 {
diff --git a/drivers/media/video/saa7164/saa7164-fw.c b/drivers/media/video/saa7164/saa7164-fw.c
index b369300..a266bf0 100644
--- a/drivers/media/video/saa7164/saa7164-fw.c
+++ b/drivers/media/video/saa7164/saa7164-fw.c
@@ -444,7 +444,7 @@ int saa7164_downloadfirmware(struct saa7164_dev *dev)
 		printk(KERN_INFO " .Reserved = 0x%x\n", hdr->reserved);
 		printk(KERN_INFO " .Version = 0x%x\n", hdr->version);
 
-		/* Retreive bootloader if reqd */
+		/* Retrieve bootloader if reqd */
 		if ((hdr->firmwaresize == 0) && (hdr->bslsize == 0))
 			/* Second bootloader in the firmware file */
 			filesize = hdr->reserved * 16;
diff --git a/drivers/media/video/saa7164/saa7164-types.h b/drivers/media/video/saa7164/saa7164-types.h
index df1d299..1d2140a 100644
--- a/drivers/media/video/saa7164/saa7164-types.h
+++ b/drivers/media/video/saa7164/saa7164-types.h
@@ -412,7 +412,7 @@ struct tmComResVBIFormatDescrHeader {
 	u8	StartLine; /* NTSC Start = 10 */
 	u8	EndLine; /* NTSC = 21 */
 	u8	FieldRate; /* 60 for NTSC */
-	u8	bNumLines; /* Unsed - scheduled for removal */
+	u8	bNumLines; /* Unused - scheduled for removal */
 } __attribute__((packed));
 
 struct tmComResProbeCommit {
diff --git a/drivers/media/video/sn9c102/sn9c102_core.c b/drivers/media/video/sn9c102/sn9c102_core.c
index ce56a1c..0e07c49 100644
--- a/drivers/media/video/sn9c102/sn9c102_core.c
+++ b/drivers/media/video/sn9c102/sn9c102_core.c
@@ -1810,7 +1810,7 @@ static int sn9c102_open(struct file *filp)
 		/*
 		   We will not release the "open_mutex" lock, so that only one
 		   process can be in the wait queue below. This way the process
-		   will be sleeping while holding the lock, without loosing its
+		   will be sleeping while holding the lock, without losing its
 		   priority after any wake_up().
 		*/
 		err = wait_event_interruptible_exclusive(cam->wait_open,
diff --git a/drivers/media/video/sn9c102/sn9c102_sensor.h b/drivers/media/video/sn9c102/sn9c102_sensor.h
index 7f38549..3679970 100644
--- a/drivers/media/video/sn9c102/sn9c102_sensor.h
+++ b/drivers/media/video/sn9c102/sn9c102_sensor.h
@@ -180,7 +180,7 @@ struct sn9c102_sensor {
 	   It should be used to initialize the sensor only, but may also
 	   configure part of the SN9C1XX chip if necessary. You don't need to
 	   setup picture settings like brightness, contrast, etc.. here, if
-	   the corrisponding controls are implemented (see below), since
+	   the corresponding controls are implemented (see below), since
 	   they are adjusted in the core driver by calling the set_ctrl()
 	   method after init(), where the arguments are the default values
 	   specified in the v4l2_queryctrl list of supported controls;
diff --git a/drivers/media/video/tcm825x.c b/drivers/media/video/tcm825x.c
index 54681a5..b6ee1bd 100644
--- a/drivers/media/video/tcm825x.c
+++ b/drivers/media/video/tcm825x.c
@@ -493,7 +493,7 @@ static int ioctl_g_ctrl(struct v4l2_int_device *s,
 	int val, r;
 	struct vcontrol *lvc;
 
-	/* exposure time is special, spread accross 2 registers */
+	/* exposure time is special, spread across 2 registers */
 	if (vc->id == V4L2_CID_EXPOSURE) {
 		int val_lower, val_upper;
 
@@ -538,7 +538,7 @@ static int ioctl_s_ctrl(struct v4l2_int_device *s,
 	struct vcontrol *lvc;
 	int val = vc->value;
 
-	/* exposure time is special, spread accross 2 registers */
+	/* exposure time is special, spread across 2 registers */
 	if (vc->id == V4L2_CID_EXPOSURE) {
 		int val_lower, val_upper;
 		val_lower = val & TCM825X_MASK(TCM825X_ESRSPD_L);
diff --git a/drivers/media/video/tvaudio.c b/drivers/media/video/tvaudio.c
index a25e2b5..c46a3bb 100644
--- a/drivers/media/video/tvaudio.c
+++ b/drivers/media/video/tvaudio.c
@@ -1058,11 +1058,11 @@ static int tda9874a_initialize(struct CHIPSTATE *chip)
 #define TDA9875_MVR         0x1b  /* Main volume droite */
 #define TDA9875_MBA         0x1d  /* Main Basse */
 #define TDA9875_MTR         0x1e  /* Main treble */
-#define TDA9875_ACS         0x1f  /* Auxilary channel select (FM) 0b0000000*/
-#define TDA9875_AVL         0x20  /* Auxilary volume gauche */
-#define TDA9875_AVR         0x21  /* Auxilary volume droite */
-#define TDA9875_ABA         0x22  /* Auxilary Basse */
-#define TDA9875_ATR         0x23  /* Auxilary treble */
+#define TDA9875_ACS         0x1f  /* Auxiliary channel select (FM) 0b0000000*/
+#define TDA9875_AVL         0x20  /* Auxiliary volume gauche */
+#define TDA9875_AVR         0x21  /* Auxiliary volume droite */
+#define TDA9875_ABA         0x22  /* Auxiliary Basse */
+#define TDA9875_ATR         0x23  /* Auxiliary treble */
 
 #define TDA9875_MSR         0x02  /* Monitor select register */
 #define TDA9875_C1MSB       0x03  /* Carrier 1 (FM) frequency register MSB */
diff --git a/drivers/media/video/uvc/uvc_video.c b/drivers/media/video/uvc/uvc_video.c
index 545c029..fc766b9 100644
--- a/drivers/media/video/uvc/uvc_video.c
+++ b/drivers/media/video/uvc/uvc_video.c
@@ -394,11 +394,11 @@ int uvc_commit_video(struct uvc_streaming *stream,
  *
  * uvc_video_decode_end is called with header data at the end of a bulk or
  * isochronous payload. It performs any additional header data processing and
- * returns 0 or a negative error code if an error occured. As header data have
+ * returns 0 or a negative error code if an error occurred. As header data have
  * already been processed by uvc_video_decode_start, this functions isn't
  * required to perform sanity checks a second time.
  *
- * For isochronous transfers where a payload is always transfered in a single
+ * For isochronous transfers where a payload is always transferred in a single
  * URB, the three functions will be called in a row.
  *
  * To let the decoder process header data and update its internal state even
@@ -658,7 +658,7 @@ static void uvc_video_decode_bulk(struct urb *urb, struct uvc_streaming *stream,
 							    buf);
 		} while (ret == -EAGAIN);
 
-		/* If an error occured skip the rest of the payload. */
+		/* If an error occurred skip the rest of the payload. */
 		if (ret < 0 || buf == NULL) {
 			stream->bulk.skip_payload = 1;
 		} else {
@@ -821,7 +821,7 @@ static int uvc_alloc_urb_buffers(struct uvc_streaming *stream,
 		return stream->urb_size / psize;
 
 	/* Compute the number of packets. Bulk endpoints might transfer UVC
-	 * payloads accross multiple URBs.
+	 * payloads across multiple URBs.
 	 */
 	npackets = DIV_ROUND_UP(size, psize);
 	if (npackets > UVC_MAX_PACKETS)
diff --git a/drivers/media/video/v4l2-ioctl.c b/drivers/media/video/v4l2-ioctl.c
index a01ed39..506edcc 100644
--- a/drivers/media/video/v4l2-ioctl.c
+++ b/drivers/media/video/v4l2-ioctl.c
@@ -48,7 +48,7 @@
 			printk(KERN_CONT "%s: " fmt, vfd->name, ## arg);\
 		} while (0)
 
-/* Zero out the end of the struct pointed to by p.  Everthing after, but
+/* Zero out the end of the struct pointed to by p.  Everything after, but
  * not including, the specified field is cleared. */
 #define CLEAR_AFTER_FIELD(p, field) \
 	memset((u8 *)(p) + offsetof(typeof(*(p)), field) + sizeof((p)->field), \
diff --git a/drivers/media/video/vpx3220.c b/drivers/media/video/vpx3220.c
index 75301d1..ca372eb 100644
--- a/drivers/media/video/vpx3220.c
+++ b/drivers/media/video/vpx3220.c
@@ -354,7 +354,7 @@ static int vpx3220_s_std(struct v4l2_subdev *sd, v4l2_std_id std)
 
 	/* Here we back up the input selection because it gets
 	   overwritten when we fill the registers with the
-	   choosen video norm */
+	   chosen video norm */
 	temp_input = vpx3220_fp_read(sd, 0xf2);
 
 	v4l2_dbg(1, debug, sd, "s_std %llx\n", (unsigned long long)std);
diff --git a/drivers/media/video/zoran/videocodec.h b/drivers/media/video/zoran/videocodec.h
index b654bff..def5558 100644
--- a/drivers/media/video/zoran/videocodec.h
+++ b/drivers/media/video/zoran/videocodec.h
@@ -57,7 +57,7 @@
    therfor they may not be initialized.
 
    The other functions are just for convenience, as they are for sure used by
-   most/all of the codecs. The last ones may be ommited, too.
+   most/all of the codecs. The last ones may be omitted, too.
 
    See the structure declaration below for more information and which data has
    to be set up for the master and the slave.
diff --git a/drivers/media/video/zoran/zoran.h b/drivers/media/video/zoran/zoran.h
index 4bb368e..f3f6400 100644
--- a/drivers/media/video/zoran/zoran.h
+++ b/drivers/media/video/zoran/zoran.h
@@ -259,7 +259,7 @@ struct card_info {
 	struct vfe_polarity vfe_pol;
 	u8 gpio_pol[ZR_GPIO_MAX];
 
-	/* is the /GWS line conected? */
+	/* is the /GWS line connected? */
 	u8 gws_not_connected;
 
 	/* avs6eyes mux setting */
diff --git a/drivers/media/video/zoran/zoran_driver.c b/drivers/media/video/zoran/zoran_driver.c
index 7c3921d..2771d81 100644
--- a/drivers/media/video/zoran/zoran_driver.c
+++ b/drivers/media/video/zoran/zoran_driver.c
@@ -1254,7 +1254,7 @@ static int setup_overlay(struct zoran_fh *fh, int on)
 {
 	struct zoran *zr = fh->zr;
 
-	/* If there is nothing to do, return immediatly */
+	/* If there is nothing to do, return immediately */
 	if ((on && fh->overlay_active != ZORAN_FREE) ||
 	    (!on && fh->overlay_active == ZORAN_FREE))
 		return 0;
diff --git a/drivers/memstick/core/mspro_block.c b/drivers/memstick/core/mspro_block.c
index 57b42bf..4a1909a 100644
--- a/drivers/memstick/core/mspro_block.c
+++ b/drivers/memstick/core/mspro_block.c
@@ -973,7 +973,7 @@ try_again:
 }
 
 /* Memory allocated for attributes by this function should be freed by
- * mspro_block_data_clear, no matter if the initialization process succeded
+ * mspro_block_data_clear, no matter if the initialization process succeeded
  * or failed.
  */
 static int mspro_block_read_attributes(struct memstick_dev *card)
diff --git a/drivers/memstick/host/r592.c b/drivers/memstick/host/r592.c
index 700d420..668f5c6 100644
--- a/drivers/memstick/host/r592.c
+++ b/drivers/memstick/host/r592.c
@@ -796,7 +796,7 @@ static int r592_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 	if (memstick_add_host(host))
 		goto error7;
 
-	message("driver succesfully loaded");
+	message("driver successfully loaded");
 	return 0;
 error7:
 	free_irq(dev->irq, dev);
diff --git a/drivers/memstick/host/r592.h b/drivers/memstick/host/r592.h
index eee264e..c5726c1 100644
--- a/drivers/memstick/host/r592.h
+++ b/drivers/memstick/host/r592.h
@@ -43,12 +43,12 @@
 
 							/* Error detection via CRC */
 #define R592_STATUS_SEND_ERR		(1 << 24)	/* Send failed */
-#define R592_STATUS_RECV_ERR		(1 << 25)	/* Recieve failed */
+#define R592_STATUS_RECV_ERR		(1 << 25)	/* Receive failed */
 
 							/* Card state */
-#define R592_STATUS_RDY			(1 << 28)	/* RDY signal recieved */
+#define R592_STATUS_RDY			(1 << 28)	/* RDY signal received */
 #define R592_STATUS_CED			(1 << 29)	/* INT: Command done (serial mode)*/
-#define R592_STATUS_SFIFO_INPUT		(1 << 30)	/* Small fifo recieved data*/
+#define R592_STATUS_SFIFO_INPUT		(1 << 30)	/* Small fifo received data*/
 
 #define R592_SFIFO_SIZE			32		/* total size of small fifo is 32 bytes */
 #define R592_SFIFO_PACKET		8		/* packet size of small fifo */
diff --git a/drivers/message/fusion/lsi/mpi_log_fc.h b/drivers/message/fusion/lsi/mpi_log_fc.h
index face6e7..03be8b2 100644
--- a/drivers/message/fusion/lsi/mpi_log_fc.h
+++ b/drivers/message/fusion/lsi/mpi_log_fc.h
@@ -38,8 +38,8 @@ typedef enum _MpiIocLogInfoFc
 {
     MPI_IOCLOGINFO_FC_INIT_BASE                     = 0x20000000,
     MPI_IOCLOGINFO_FC_INIT_ERROR_OUT_OF_ORDER_FRAME = 0x20000001, /* received an out of order frame - unsupported */
-    MPI_IOCLOGINFO_FC_INIT_ERROR_BAD_START_OF_FRAME = 0x20000002, /* Bad Rx Frame, bad start of frame primative */
-    MPI_IOCLOGINFO_FC_INIT_ERROR_BAD_END_OF_FRAME   = 0x20000003, /* Bad Rx Frame, bad end of frame primative */
+    MPI_IOCLOGINFO_FC_INIT_ERROR_BAD_START_OF_FRAME = 0x20000002, /* Bad Rx Frame, bad start of frame primitive */
+    MPI_IOCLOGINFO_FC_INIT_ERROR_BAD_END_OF_FRAME   = 0x20000003, /* Bad Rx Frame, bad end of frame primitive */
     MPI_IOCLOGINFO_FC_INIT_ERROR_OVER_RUN           = 0x20000004, /* Bad Rx Frame, overrun */
     MPI_IOCLOGINFO_FC_INIT_ERROR_RX_OTHER           = 0x20000005, /* Other errors caught by IOC which require retries */
     MPI_IOCLOGINFO_FC_INIT_ERROR_SUBPROC_DEAD       = 0x20000006, /* Main processor could not initialize sub-processor */
diff --git a/drivers/message/fusion/lsi/mpi_log_sas.h b/drivers/message/fusion/lsi/mpi_log_sas.h
index 8b04810..f62960b 100644
--- a/drivers/message/fusion/lsi/mpi_log_sas.h
+++ b/drivers/message/fusion/lsi/mpi_log_sas.h
@@ -56,9 +56,9 @@
 #define IOP_LOGINFO_CODE_FWUPLOAD_NO_FLASH_AVAILABLE         (0x0003E000) /* Tried to upload from flash, but there is none */
 #define IOP_LOGINFO_CODE_FWUPLOAD_UNKNOWN_IMAGE_TYPE         (0x0003E001) /* ImageType field contents were invalid */
 #define IOP_LOGINFO_CODE_FWUPLOAD_WRONG_IMAGE_SIZE           (0x0003E002) /* ImageSize field in TCSGE was bad/offset in MfgPg 4 was wrong */
-#define IOP_LOGINFO_CODE_FWUPLOAD_ENTIRE_FLASH_UPLOAD_FAILED (0x0003E003) /* Error occured while attempting to upload the entire flash */
-#define IOP_LOGINFO_CODE_FWUPLOAD_REGION_UPLOAD_FAILED       (0x0003E004) /* Error occured while attempting to upload single flash region */
-#define IOP_LOGINFO_CODE_FWUPLOAD_DMA_FAILURE                (0x0003E005) /* Problem occured while DMAing FW to host memory */
+#define IOP_LOGINFO_CODE_FWUPLOAD_ENTIRE_FLASH_UPLOAD_FAILED (0x0003E003) /* Error occurred while attempting to upload the entire flash */
+#define IOP_LOGINFO_CODE_FWUPLOAD_REGION_UPLOAD_FAILED       (0x0003E004) /* Error occurred while attempting to upload single flash region */
+#define IOP_LOGINFO_CODE_FWUPLOAD_DMA_FAILURE                (0x0003E005) /* Problem occurred while DMAing FW to host memory */
 
 #define IOP_LOGINFO_CODE_DIAG_MSG_ERROR                      (0x00040000) /* Error handling diag msg - or'd with diag status */
 
@@ -187,8 +187,8 @@
 #define PL_LOGINFO_SUB_CODE_BREAK_ON_INCOMPLETE_BREAK_RCVD   (0x00005000)
 
 #define PL_LOGINFO_CODE_ENCL_MGMT_SMP_FRAME_FAILURE          (0x00200000) /* Can't get SMP Frame */
-#define PL_LOGINFO_CODE_ENCL_MGMT_SMP_READ_ERROR             (0x00200010) /* Error occured on SMP Read */
-#define PL_LOGINFO_CODE_ENCL_MGMT_SMP_WRITE_ERROR            (0x00200020) /* Error occured on SMP Write */
+#define PL_LOGINFO_CODE_ENCL_MGMT_SMP_READ_ERROR             (0x00200010) /* Error occurred on SMP Read */
+#define PL_LOGINFO_CODE_ENCL_MGMT_SMP_WRITE_ERROR            (0x00200020) /* Error occurred on SMP Write */
 #define PL_LOGINFO_CODE_ENCL_MGMT_NOT_SUPPORTED_ON_ENCL      (0x00200040) /* Encl Mgmt services not available for this WWID */
 #define PL_LOGINFO_CODE_ENCL_MGMT_ADDR_MODE_NOT_SUPPORTED    (0x00200050) /* Address Mode not suppored */
 #define PL_LOGINFO_CODE_ENCL_MGMT_BAD_SLOT_NUM               (0x00200060) /* Invalid Slot Number in SEP Msg */
@@ -207,8 +207,8 @@
 #define PL_LOGINFO_DA_SEP_RECEIVED_NACK_FROM_SLAVE           (0x00200103) /* SEP NACK'd, it is busy */
 #define PL_LOGINFO_DA_SEP_DID_NOT_RECEIVE_ACK                (0x00200104) /* SEP didn't rcv. ACK (Last Rcvd Bit = 1) */
 #define PL_LOGINFO_DA_SEP_BAD_STATUS_HDR_CHKSUM              (0x00200105) /* SEP stopped or sent bad chksum in Hdr */
-#define PL_LOGINFO_DA_SEP_STOP_ON_DATA                       (0x00200106) /* SEP stopped while transfering data */
-#define PL_LOGINFO_DA_SEP_STOP_ON_SENSE_DATA                 (0x00200107) /* SEP stopped while transfering sense data */
+#define PL_LOGINFO_DA_SEP_STOP_ON_DATA                       (0x00200106) /* SEP stopped while transferring data */
+#define PL_LOGINFO_DA_SEP_STOP_ON_SENSE_DATA                 (0x00200107) /* SEP stopped while transferring sense data */
 #define PL_LOGINFO_DA_SEP_UNSUPPORTED_SCSI_STATUS_1          (0x00200108) /* SEP returned unknown scsi status */
 #define PL_LOGINFO_DA_SEP_UNSUPPORTED_SCSI_STATUS_2          (0x00200109) /* SEP returned unknown scsi status */
 #define PL_LOGINFO_DA_SEP_CHKSUM_ERROR_AFTER_STOP            (0x0020010A) /* SEP returned bad chksum after STOP */
diff --git a/drivers/message/fusion/mptbase.c b/drivers/message/fusion/mptbase.c
index ec8080c..fa15e85 100644
--- a/drivers/message/fusion/mptbase.c
+++ b/drivers/message/fusion/mptbase.c
@@ -3435,7 +3435,7 @@ SendPortEnable(MPT_ADAPTER *ioc, int portnum, int sleepFlag)
  *	If memory has already been allocated, the same (cached) value
  *	is returned.
  *
- *	Return 0 if successfull, or non-zero for failure
+ *	Return 0 if successful, or non-zero for failure
  **/
 int
 mpt_alloc_fw_memory(MPT_ADAPTER *ioc, int size)
@@ -6932,7 +6932,7 @@ EXPORT_SYMBOL(mpt_halt_firmware);
  *	Message Unit Reset - instructs the IOC to reset the Reply Post and
  *	Free FIFO's. All the Message Frames on Reply Free FIFO are discarded.
  *	All posted buffers are freed, and event notification is turned off.
- *	IOC doesnt reply to any outstanding request. This will transfer IOC
+ *	IOC doesn't reply to any outstanding request. This will transfer IOC
  *	to READY state.
  **/
 int
@@ -7905,7 +7905,7 @@ mpt_spi_log_info(MPT_ADAPTER *ioc, u32 log_info)
 		    "Owner", 					/* 15h */
 		"Open Transmit DMA Abort",			/* 16h */
 		"IO Device Missing Delay Retry",		/* 17h */
-		"IO Cancelled Due to Recieve Error",		/* 18h */
+		"IO Cancelled Due to Receive Error",		/* 18h */
 		NULL,						/* 19h */
 		NULL,						/* 1Ah */
 		NULL,						/* 1Bh */
diff --git a/drivers/message/fusion/mptctl.c b/drivers/message/fusion/mptctl.c
index 878bda0..6e6e16a 100644
--- a/drivers/message/fusion/mptctl.c
+++ b/drivers/message/fusion/mptctl.c
@@ -985,7 +985,7 @@ retry_wait:
 	ReplyMsg = (pFWDownloadReply_t)iocp->ioctl_cmds.reply;
 	iocstat = le16_to_cpu(ReplyMsg->IOCStatus) & MPI_IOCSTATUS_MASK;
 	if (iocstat == MPI_IOCSTATUS_SUCCESS) {
-		printk(MYIOC_s_INFO_FMT "F/W update successfull!\n", iocp->name);
+		printk(MYIOC_s_INFO_FMT "F/W update successful!\n", iocp->name);
 		return 0;
 	} else if (iocstat == MPI_IOCSTATUS_INVALID_FUNCTION) {
 		printk(MYIOC_s_WARN_FMT "Hmmm...  F/W download not supported!?!\n",
@@ -2407,7 +2407,7 @@ done_free_mem:
 	}
 
 	/* mf is null if command issued successfully
-	 * otherwise, failure occured after mf acquired.
+	 * otherwise, failure occurred after mf acquired.
 	 */
 	if (mf)
 		mpt_free_msg_frame(ioc, mf);
diff --git a/drivers/message/fusion/mptsas.c b/drivers/message/fusion/mptsas.c
index f5a14af..66f9412 100644
--- a/drivers/message/fusion/mptsas.c
+++ b/drivers/message/fusion/mptsas.c
@@ -307,7 +307,7 @@ mptsas_requeue_fw_event(MPT_ADAPTER *ioc, struct fw_event_work *fw_event,
 	spin_unlock_irqrestore(&ioc->fw_event_lock, flags);
 }
 
-/* free memory assoicated to a sas firmware event */
+/* free memory associated to a sas firmware event */
 static void
 mptsas_free_fw_event(MPT_ADAPTER *ioc, struct fw_event_work *fw_event)
 {
@@ -1094,7 +1094,7 @@ mptsas_block_io_starget(struct scsi_target *starget)
 /**
  * mptsas_target_reset_queue
  *
- * Receive request for TARGET_RESET after recieving an firmware
+ * Receive request for TARGET_RESET after receiving an firmware
  * event NOT_RESPONDING_EVENT, then put command in link list
  * and queue if task_queue already in use.
  *
@@ -1403,7 +1403,7 @@ mptsas_sas_enclosure_pg0(MPT_ADAPTER *ioc, struct mptsas_enclosure *enclosure,
 /**
  *	mptsas_add_end_device - report a new end device to sas transport layer
  *	@ioc: Pointer to MPT_ADAPTER structure
- *	@phy_info: decribes attached device
+ *	@phy_info: describes attached device
  *
  *	return (0) success (1) failure
  *
@@ -1481,7 +1481,7 @@ mptsas_add_end_device(MPT_ADAPTER *ioc, struct mptsas_phyinfo *phy_info)
 /**
  *	mptsas_del_end_device - report a deleted end device to sas transport layer
  *	@ioc: Pointer to MPT_ADAPTER structure
- *	@phy_info: decribes attached device
+ *	@phy_info: describes attached device
  *
  **/
 static void
diff --git a/drivers/message/i2o/README b/drivers/message/i2o/README
index 911fc30..f072a8e 100644
--- a/drivers/message/i2o/README
+++ b/drivers/message/i2o/README
@@ -53,7 +53,7 @@ Symbios Logic (Now LSI)
 BoxHill Corporation
 	Loan of initial FibreChannel disk array used for development work.
 
-European Comission
+European Commission
 	Funding the work done by the University of Helsinki
 
 SysKonnect
diff --git a/drivers/message/i2o/device.c b/drivers/message/i2o/device.c
index 0ee4264..4547db9 100644
--- a/drivers/message/i2o/device.c
+++ b/drivers/message/i2o/device.c
@@ -65,7 +65,7 @@ int i2o_device_claim(struct i2o_device *dev)
 
 	rc = i2o_device_issue_claim(dev, I2O_CMD_UTIL_CLAIM, I2O_CLAIM_PRIMARY);
 	if (!rc)
-		pr_debug("i2o: claim of device %d succeded\n",
+		pr_debug("i2o: claim of device %d succeeded\n",
 			 dev->lct_data.tid);
 	else
 		pr_debug("i2o: claim of device %d failed %d\n",
@@ -110,7 +110,7 @@ int i2o_device_claim_release(struct i2o_device *dev)
 	}
 
 	if (!rc)
-		pr_debug("i2o: claim release of device %d succeded\n",
+		pr_debug("i2o: claim release of device %d succeeded\n",
 			 dev->lct_data.tid);
 	else
 		pr_debug("i2o: claim release of device %d failed %d\n",
@@ -248,7 +248,7 @@ static int i2o_device_add(struct i2o_controller *c, i2o_lct_entry *entry)
 			goto unreg_dev;
 	}
 
-	/* create user entries refering to this device */
+	/* create user entries referring to this device */
 	list_for_each_entry(tmp, &c->devices, list)
 	    if ((tmp->lct_data.user_tid == i2o_dev->lct_data.tid)
 		&& (tmp != i2o_dev)) {
@@ -267,7 +267,7 @@ static int i2o_device_add(struct i2o_controller *c, i2o_lct_entry *entry)
 			goto rmlink1;
 	}
 
-	/* create parent entries refering to this device */
+	/* create parent entries referring to this device */
 	list_for_each_entry(tmp, &c->devices, list)
 	    if ((tmp->lct_data.parent_tid == i2o_dev->lct_data.tid)
 		&& (tmp != i2o_dev)) {
diff --git a/drivers/message/i2o/i2o_block.c b/drivers/message/i2o/i2o_block.c
index 47ec5bc..643ad52 100644
--- a/drivers/message/i2o/i2o_block.c
+++ b/drivers/message/i2o/i2o_block.c
@@ -610,7 +610,7 @@ static int i2o_block_release(struct gendisk *disk, fmode_t mode)
 
 	/*
 	 * This is to deail with the case of an application
-	 * opening a device and then the device dissapears while
+	 * opening a device and then the device disappears while
 	 * it's in use, and then the application tries to release
 	 * it.  ex: Unmounting a deleted RAID volume at reboot.
 	 * If we send messages, it will just cause FAILs since
@@ -717,7 +717,7 @@ static unsigned int i2o_block_check_events(struct gendisk *disk,
 
 /**
  *	i2o_block_transfer - Transfer a request to/from the I2O controller
- *	@req: the request which should be transfered
+ *	@req: the request which should be transferred
  *
  *	This function converts the request into a I2O message. The necessary
  *	DMA buffers are allocated and after everything is setup post the message
diff --git a/drivers/message/i2o/i2o_block.h b/drivers/message/i2o/i2o_block.h
index 67f921b..cf8873c 100644
--- a/drivers/message/i2o/i2o_block.h
+++ b/drivers/message/i2o/i2o_block.h
@@ -73,7 +73,7 @@ struct i2o_block_device {
 	struct i2o_device *i2o_dev;	/* pointer to I2O device */
 	struct gendisk *gd;
 	spinlock_t lock;	/* queue lock */
-	struct list_head open_queue;	/* list of transfered, but unfinished
+	struct list_head open_queue;	/* list of transferred, but unfinished
 					   requests */
 	unsigned int open_queue_depth;	/* number of requests in the queue */
 
diff --git a/drivers/message/i2o/i2o_scsi.c b/drivers/message/i2o/i2o_scsi.c
index 97bdf82..f003957 100644
--- a/drivers/message/i2o/i2o_scsi.c
+++ b/drivers/message/i2o/i2o_scsi.c
@@ -204,7 +204,7 @@ static int i2o_scsi_remove(struct device *dev)
  *	i2o_scsi_probe - verify if dev is a I2O SCSI device and install it
  *	@dev: device to verify if it is a I2O SCSI device
  *
- *	Retrieve channel, id and lun for I2O device. If everthing goes well
+ *	Retrieve channel, id and lun for I2O device. If everything goes well
  *	register the I2O device as SCSI device on the I2O SCSI controller.
  *
  *	Returns 0 on success or negative error code on failure.
diff --git a/drivers/mfd/Kconfig b/drivers/mfd/Kconfig
index e2fea58..3ed3ff0 100644
--- a/drivers/mfd/Kconfig
+++ b/drivers/mfd/Kconfig
@@ -201,7 +201,7 @@ config TWL4030_POWER
 	  as clock request handshaking.
 
 	  This driver uses board-specific data to initialize the resources
-	  and load scripts controling which resources are switched off/on
+	  and load scripts controlling which resources are switched off/on
 	  or reset when a sleep, wakeup or warm reset event occurs.
 
 config TWL4030_CODEC
diff --git a/drivers/mfd/ab8500-gpadc.c b/drivers/mfd/ab8500-gpadc.c
index bc93b2e..6421ad1 100644
--- a/drivers/mfd/ab8500-gpadc.c
+++ b/drivers/mfd/ab8500-gpadc.c
@@ -314,7 +314,7 @@ int ab8500_gpadc_convert(struct ab8500_gpadc *gpadc, u8 input)
 	/* wait for completion of conversion */
 	if (!wait_for_completion_timeout(&gpadc->ab8500_gpadc_complete, 2*HZ)) {
 		dev_err(gpadc->dev,
-			"timeout: didnt recieve GPADC conversion interrupt\n");
+			"timeout: didn't receive GPADC conversion interrupt\n");
 		ret = -EINVAL;
 		goto out;
 	}
diff --git a/drivers/mfd/ezx-pcap.c b/drivers/mfd/ezx-pcap.c
index f2f4029..43a76c4 100644
--- a/drivers/mfd/ezx-pcap.c
+++ b/drivers/mfd/ezx-pcap.c
@@ -185,7 +185,7 @@ static void pcap_isr_work(struct work_struct *work)
 		ezx_pcap_read(pcap, PCAP_REG_MSR, &msr);
 		ezx_pcap_read(pcap, PCAP_REG_ISR, &isr);
 
-		/* We cant service/ack irqs that are assigned to port 2 */
+		/* We can't service/ack irqs that are assigned to port 2 */
 		if (!(pdata->config & PCAP_SECOND_PORT)) {
 			ezx_pcap_read(pcap, PCAP_REG_INT_SEL, &int_sel);
 			isr &= ~int_sel;
@@ -457,7 +457,7 @@ static int __devinit ezx_pcap_probe(struct spi_device *spi)
 	pcap->workqueue = create_singlethread_workqueue("pcapd");
 	if (!pcap->workqueue) {
 		ret = -ENOMEM;
-		dev_err(&spi->dev, "cant create pcap thread\n");
+		dev_err(&spi->dev, "can't create pcap thread\n");
 		goto free_pcap;
 	}
 
diff --git a/drivers/mfd/omap-usb-host.c b/drivers/mfd/omap-usb-host.c
index cb01209..53450f4 100644
--- a/drivers/mfd/omap-usb-host.c
+++ b/drivers/mfd/omap-usb-host.c
@@ -332,7 +332,7 @@ static int __devinit usbhs_omap_probe(struct platform_device *pdev)
 	int				i;
 
 	if (!pdata) {
-		dev_err(dev, "Missing platfrom data\n");
+		dev_err(dev, "Missing platform data\n");
 		ret = -ENOMEM;
 		goto end_probe;
 	}
diff --git a/drivers/mfd/pcf50633-core.c b/drivers/mfd/pcf50633-core.c
index c7687f6..57868416 100644
--- a/drivers/mfd/pcf50633-core.c
+++ b/drivers/mfd/pcf50633-core.c
@@ -51,7 +51,7 @@ static int __pcf50633_write(struct pcf50633 *pcf, u8 reg, int num, u8 *data)
 
 }
 
-/* Read a block of upto 32 regs  */
+/* Read a block of up to 32 regs  */
 int pcf50633_read_block(struct pcf50633 *pcf, u8 reg,
 					int nr_regs, u8 *data)
 {
@@ -65,7 +65,7 @@ int pcf50633_read_block(struct pcf50633 *pcf, u8 reg,
 }
 EXPORT_SYMBOL_GPL(pcf50633_read_block);
 
-/* Write a block of upto 32 regs  */
+/* Write a block of up to 32 regs  */
 int pcf50633_write_block(struct pcf50633 *pcf , u8 reg,
 					int nr_regs, u8 *data)
 {
diff --git a/drivers/mfd/twl6030-irq.c b/drivers/mfd/twl6030-irq.c
index fa93705..dfbae34 100644
--- a/drivers/mfd/twl6030-irq.c
+++ b/drivers/mfd/twl6030-irq.c
@@ -229,7 +229,7 @@ int twl6030_mmc_card_detect_config(void)
 	twl6030_interrupt_unmask(TWL6030_MMCDETECT_INT_MASK,
 						REG_INT_MSK_STS_B);
 	/*
-	 * Intially Configuring MMC_CTRL for receving interrupts &
+	 * Initially Configuring MMC_CTRL for receiving interrupts &
 	 * Card status on TWL6030 for MMC1
 	 */
 	ret = twl_i2c_read_u8(TWL6030_MODULE_ID0, &reg_val, TWL6030_MMCCTRL);
@@ -275,7 +275,7 @@ int twl6030_mmc_card_detect(struct device *dev, int slot)
 		/* TWL6030 provide's Card detect support for
 		 * only MMC1 controller.
 		 */
-		pr_err("Unkown MMC controller %d in %s\n", pdev->id, __func__);
+		pr_err("Unknown MMC controller %d in %s\n", pdev->id, __func__);
 		return ret;
 	}
 	/*
diff --git a/drivers/mfd/ucb1400_core.c b/drivers/mfd/ucb1400_core.c
index d73f84b..daf6952 100644
--- a/drivers/mfd/ucb1400_core.c
+++ b/drivers/mfd/ucb1400_core.c
@@ -8,7 +8,7 @@
  *  Copyright:	MontaVista Software, Inc.
  *
  * Spliting done by: Marek Vasut <marek.vasut@gmail.com>
- * If something doesnt work and it worked before spliting, e-mail me,
+ * If something doesn't work and it worked before spliting, e-mail me,
  * dont bother Nicolas please ;-)
  *
  * This program is free software; you can redistribute it and/or modify
diff --git a/drivers/misc/bmp085.c b/drivers/misc/bmp085.c
index ecd276a..5f898cb 100644
--- a/drivers/misc/bmp085.c
+++ b/drivers/misc/bmp085.c
@@ -2,7 +2,7 @@
 
     This driver supports the bmp085 digital barometric pressure
     and temperature sensor from Bosch Sensortec. The datasheet
-    is avaliable from their website:
+    is available from their website:
     http://www.bosch-sensortec.com/content/language1/downloads/BST-BMP085-DS000-05.pdf
 
     A pressure measurement is issued by reading from pressure0_input.
@@ -429,7 +429,7 @@ static int __devinit bmp085_probe(struct i2c_client *client,
 	if (err)
 		goto exit_free;
 
-	dev_info(&data->client->dev, "Succesfully initialized bmp085!\n");
+	dev_info(&data->client->dev, "Successfully initialized bmp085!\n");
 	goto exit;
 
 exit_free:
diff --git a/drivers/misc/c2port/c2port-duramar2150.c b/drivers/misc/c2port/c2port-duramar2150.c
index 338dcc1..778fc3f 100644
--- a/drivers/misc/c2port/c2port-duramar2150.c
+++ b/drivers/misc/c2port/c2port-duramar2150.c
@@ -41,7 +41,7 @@ static void duramar2150_c2port_access(struct c2port_device *dev, int status)
 		outb(v | (C2D | C2CK), DIR_PORT);
 	else
 		/* When access is "off" is important that both lines are set
-		 * as inputs or hi-impedence */
+		 * as inputs or hi-impedance */
 		outb(v & ~(C2D | C2CK), DIR_PORT);
 
 	mutex_unlock(&update_lock);
diff --git a/drivers/misc/ibmasm/remote.h b/drivers/misc/ibmasm/remote.h
index 72acf5a..00dbf1d 100644
--- a/drivers/misc/ibmasm/remote.h
+++ b/drivers/misc/ibmasm/remote.h
@@ -20,7 +20,7 @@
  *
  * Author: Max Asbck <amax@us.ibm.com>
  *
- * Orignally written by Pete Reynolds
+ * Originally written by Pete Reynolds
  */
 
 #ifndef _IBMASM_REMOTE_H_
diff --git a/drivers/misc/iwmc3200top/main.c b/drivers/misc/iwmc3200top/main.c
index 727af07..b1f4563 100644
--- a/drivers/misc/iwmc3200top/main.c
+++ b/drivers/misc/iwmc3200top/main.c
@@ -268,7 +268,7 @@ static void iwmct_irq_read_worker(struct work_struct *ws)
 		LOG_INFO(priv, IRQ, "ACK barker arrived "
 				"- starting FW download\n");
 	} else { /* REBOOT barker */
-		LOG_INFO(priv, IRQ, "Recieved reboot barker: %x\n", barker);
+		LOG_INFO(priv, IRQ, "Received reboot barker: %x\n", barker);
 		priv->barker = barker;
 
 		if (barker & BARKER_DNLOAD_SYNC_MSK) {
diff --git a/drivers/misc/kgdbts.c b/drivers/misc/kgdbts.c
index 27dc463..74f16f1 100644
--- a/drivers/misc/kgdbts.c
+++ b/drivers/misc/kgdbts.c
@@ -645,7 +645,7 @@ static int validate_simple_test(char *put_str)
 
 	while (*chk_str != '\0' && *put_str != '\0') {
 		/* If someone does a * to match the rest of the string, allow
-		 * it, or stop if the recieved string is complete.
+		 * it, or stop if the received string is complete.
 		 */
 		if (*put_str == '#' || *chk_str == '*')
 			return 0;
diff --git a/drivers/misc/sgi-gru/grukservices.c b/drivers/misc/sgi-gru/grukservices.c
index 34749ee..9e9bdda 100644
--- a/drivers/misc/sgi-gru/grukservices.c
+++ b/drivers/misc/sgi-gru/grukservices.c
@@ -229,7 +229,7 @@ again:
 	bid = blade_id < 0 ? uv_numa_blade_id() : blade_id;
 	bs = gru_base[bid];
 
-	/* Handle the case where migration occured while waiting for the sema */
+	/* Handle the case where migration occurred while waiting for the sema */
 	down_read(&bs->bs_kgts_sema);
 	if (blade_id < 0 && bid != uv_numa_blade_id()) {
 		up_read(&bs->bs_kgts_sema);
diff --git a/drivers/misc/sgi-gru/grutables.h b/drivers/misc/sgi-gru/grutables.h
index 7a8b906..5c3ce24 100644
--- a/drivers/misc/sgi-gru/grutables.h
+++ b/drivers/misc/sgi-gru/grutables.h
@@ -379,7 +379,7 @@ struct gru_thread_state {
 						   required for contest */
 	char			ts_cch_req_slice;/* CCH packet slice */
 	char			ts_blade;	/* If >= 0, migrate context if
-						   ref from diferent blade */
+						   ref from different blade */
 	char			ts_force_cch_reload;
 	char			ts_cbr_idx[GRU_CBR_AU];/* CBR numbers of each
 							  allocated CB */
diff --git a/drivers/misc/ti-st/st_kim.c b/drivers/misc/ti-st/st_kim.c
index 9ee4c78..b4488c8 100644
--- a/drivers/misc/ti-st/st_kim.c
+++ b/drivers/misc/ti-st/st_kim.c
@@ -649,7 +649,7 @@ static int kim_probe(struct platform_device *pdev)
 		/* multiple devices could exist */
 		st_kim_devices[pdev->id] = pdev;
 	} else {
-		/* platform's sure about existance of 1 device */
+		/* platform's sure about existence of 1 device */
 		st_kim_devices[0] = pdev;
 	}
 
diff --git a/drivers/mmc/card/mmc_test.c b/drivers/mmc/card/mmc_test.c
index f5cedec..abc1a63 100644
--- a/drivers/mmc/card/mmc_test.c
+++ b/drivers/mmc/card/mmc_test.c
@@ -292,7 +292,7 @@ static void mmc_test_free_mem(struct mmc_test_mem *mem)
 }
 
 /*
- * Allocate a lot of memory, preferrably max_sz but at least min_sz.  In case
+ * Allocate a lot of memory, preferably max_sz but at least min_sz.  In case
  * there isn't much memory do not exceed 1/16th total lowmem pages.  Also do
  * not exceed a maximum number of segments and try not to make segments much
  * bigger than maximum segment size.
diff --git a/drivers/mmc/core/mmc.c b/drivers/mmc/core/mmc.c
index 14e95f3..772d0d0 100644
--- a/drivers/mmc/core/mmc.c
+++ b/drivers/mmc/core/mmc.c
@@ -538,7 +538,7 @@ static int mmc_init_card(struct mmc_host *host, u32 ocr,
 
 	/*
 	 * If enhanced_area_en is TRUE, host needs to enable ERASE_GRP_DEF
-	 * bit.  This bit will be lost everytime after a reset or power off.
+	 * bit.  This bit will be lost every time after a reset or power off.
 	 */
 	if (card->ext_csd.enhanced_area_en) {
 		err = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
diff --git a/drivers/mmc/core/mmc_ops.c b/drivers/mmc/core/mmc_ops.c
index 60842f8..f3b22bf 100644
--- a/drivers/mmc/core/mmc_ops.c
+++ b/drivers/mmc/core/mmc_ops.c
@@ -105,7 +105,7 @@ int mmc_go_idle(struct mmc_host *host)
 	 * that in case of hardware that won't pull up DAT3/nCS otherwise.
 	 *
 	 * SPI hosts ignore ios.chip_select; it's managed according to
-	 * rules that must accomodate non-MMC slaves which this layer
+	 * rules that must accommodate non-MMC slaves which this layer
 	 * won't even know about.
 	 */
 	if (!mmc_host_is_spi(host)) {
diff --git a/drivers/mmc/core/sdio_irq.c b/drivers/mmc/core/sdio_irq.c
index bb192f9..b300161 100644
--- a/drivers/mmc/core/sdio_irq.c
+++ b/drivers/mmc/core/sdio_irq.c
@@ -45,7 +45,7 @@ static int process_sdio_pending_irqs(struct mmc_card *card)
 			struct sdio_func *func = card->sdio_func[i - 1];
 			if (!func) {
 				printk(KERN_WARNING "%s: pending IRQ for "
-					"non-existant function\n",
+					"non-existent function\n",
 					mmc_card_id(card));
 				ret = -EINVAL;
 			} else if (func->irq_handler) {
diff --git a/drivers/mmc/host/atmel-mci.c b/drivers/mmc/host/atmel-mci.c
index 80bc9a5..ea3888b 100644
--- a/drivers/mmc/host/atmel-mci.c
+++ b/drivers/mmc/host/atmel-mci.c
@@ -127,7 +127,7 @@ struct atmel_mci_dma {
  * EVENT_DATA_COMPLETE is set in @pending_events, all data-related
  * interrupts must be disabled and @data_status updated with a
  * snapshot of SR. Similarly, before EVENT_CMD_COMPLETE is set, the
- * CMDRDY interupt must be disabled and @cmd_status updated with a
+ * CMDRDY interrupt must be disabled and @cmd_status updated with a
  * snapshot of SR, and before EVENT_XFER_COMPLETE can be set, the
  * bytes_xfered field of @data must be written. This is ensured by
  * using barriers.
@@ -1082,7 +1082,7 @@ static void atmci_request_end(struct atmel_mci *host, struct mmc_request *mrq)
 	/*
 	 * Update the MMC clock rate if necessary. This may be
 	 * necessary if set_ios() is called when a different slot is
-	 * busy transfering data.
+	 * busy transferring data.
 	 */
 	if (host->need_clock_update) {
 		mci_writel(host, MR, host->mode_reg);
diff --git a/drivers/mmc/host/mmc_spi.c b/drivers/mmc/host/mmc_spi.c
index 2f7fc0c..7c1e16a 100644
--- a/drivers/mmc/host/mmc_spi.c
+++ b/drivers/mmc/host/mmc_spi.c
@@ -99,7 +99,7 @@
 #define r1b_timeout		(HZ * 3)
 
 /* One of the critical speed parameters is the amount of data which may
- * be transfered in one command. If this value is too low, the SD card
+ * be transferred in one command. If this value is too low, the SD card
  * controller has to do multiple partial block writes (argggh!). With
  * today (2008) SD cards there is little speed gain if we transfer more
  * than 64 KBytes at a time. So use this value until there is any indication
diff --git a/drivers/mmc/host/s3cmci.c b/drivers/mmc/host/s3cmci.c
index 1ccd4b2..a04f87d 100644
--- a/drivers/mmc/host/s3cmci.c
+++ b/drivers/mmc/host/s3cmci.c
@@ -874,7 +874,7 @@ static void finalize_request(struct s3cmci_host *host)
 	if (!mrq->data)
 		goto request_done;
 
-	/* Calulate the amout of bytes transfer if there was no error */
+	/* Calculate the amout of bytes transfer if there was no error */
 	if (mrq->data->error == 0) {
 		mrq->data->bytes_xfered =
 			(mrq->data->blocks * mrq->data->blksz);
@@ -882,7 +882,7 @@ static void finalize_request(struct s3cmci_host *host)
 		mrq->data->bytes_xfered = 0;
 	}
 
-	/* If we had an error while transfering data we flush the
+	/* If we had an error while transferring data we flush the
 	 * DMA channel and the fifo to clear out any garbage. */
 	if (mrq->data->error != 0) {
 		if (s3cmci_host_usedma(host))
@@ -980,7 +980,7 @@ static int s3cmci_setup_data(struct s3cmci_host *host, struct mmc_data *data)
 
 	if ((data->blksz & 3) != 0) {
 		/* We cannot deal with unaligned blocks with more than
-		 * one block being transfered. */
+		 * one block being transferred. */
 
 		if (data->blocks > 1) {
 			pr_warning("%s: can't do non-word sized block transfers (blksz %d)\n", __func__, data->blksz);
diff --git a/drivers/mmc/host/tmio_mmc_pio.c b/drivers/mmc/host/tmio_mmc_pio.c
index 6ae8d2f..62d37de 100644
--- a/drivers/mmc/host/tmio_mmc_pio.c
+++ b/drivers/mmc/host/tmio_mmc_pio.c
@@ -355,7 +355,7 @@ static int tmio_mmc_start_command(struct tmio_mmc_host *host, struct mmc_command
 /*
  * This chip always returns (at least?) as much data as you ask for.
  * I'm unsure what happens if you ask for less than a block. This should be
- * looked into to ensure that a funny length read doesnt hose the controller.
+ * looked into to ensure that a funny length read doesn't hose the controller.
  */
 static void tmio_mmc_pio_irq(struct tmio_mmc_host *host)
 {
diff --git a/drivers/mmc/host/wbsd.c b/drivers/mmc/host/wbsd.c
index 7fca0a3..62e5a4d 100644
--- a/drivers/mmc/host/wbsd.c
+++ b/drivers/mmc/host/wbsd.c
@@ -484,7 +484,7 @@ static void wbsd_fill_fifo(struct wbsd_host *host)
 
 	/*
 	 * Check that we aren't being called after the
-	 * entire buffer has been transfered.
+	 * entire buffer has been transferred.
 	 */
 	if (host->num_sg == 0)
 		return;
@@ -828,7 +828,7 @@ static void wbsd_request(struct mmc_host *mmc, struct mmc_request *mrq)
 	/*
 	 * If this is a data transfer the request
 	 * will be finished after the data has
-	 * transfered.
+	 * transferred.
 	 */
 	if (cmd->data && !cmd->error) {
 		/*
@@ -904,7 +904,7 @@ static void wbsd_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
 			setup &= ~WBSD_DAT3_H;
 
 			/*
-			 * We cannot resume card detection immediatly
+			 * We cannot resume card detection immediately
 			 * because of capacitance and delays in the chip.
 			 */
 			mod_timer(&host->ignore_timer, jiffies + HZ / 100);
diff --git a/drivers/mtd/chips/Kconfig b/drivers/mtd/chips/Kconfig
index 35c6a23..b1e3c26 100644
--- a/drivers/mtd/chips/Kconfig
+++ b/drivers/mtd/chips/Kconfig
@@ -19,7 +19,7 @@ config MTD_JEDECPROBE
 	help
 	  This option enables JEDEC-style probing of flash chips which are not
 	  compatible with the Common Flash Interface, but will use the common
-	  CFI-targetted flash drivers for any chips which are identified which
+	  CFI-targeted flash drivers for any chips which are identified which
 	  are in fact compatible in all but the probe method. This actually
 	  covers most AMD/Fujitsu-compatible chips and also non-CFI
 	  Intel chips.
diff --git a/drivers/mtd/chips/cfi_cmdset_0001.c b/drivers/mtd/chips/cfi_cmdset_0001.c
index 092aef1..09cb7c8 100644
--- a/drivers/mtd/chips/cfi_cmdset_0001.c
+++ b/drivers/mtd/chips/cfi_cmdset_0001.c
@@ -1247,12 +1247,12 @@ static int inval_cache_and_wait_for_operation(
 			break;
 
 		if (chip->erase_suspended && chip_state == FL_ERASING)  {
-			/* Erase suspend occured while sleep: reset timeout */
+			/* Erase suspend occurred while sleep: reset timeout */
 			timeo = reset_timeo;
 			chip->erase_suspended = 0;
 		}
 		if (chip->write_suspended && chip_state == FL_WRITING)  {
-			/* Write suspend occured while sleep: reset timeout */
+			/* Write suspend occurred while sleep: reset timeout */
 			timeo = reset_timeo;
 			chip->write_suspended = 0;
 		}
diff --git a/drivers/mtd/chips/cfi_cmdset_0002.c b/drivers/mtd/chips/cfi_cmdset_0002.c
index f9a5331..0b49266 100644
--- a/drivers/mtd/chips/cfi_cmdset_0002.c
+++ b/drivers/mtd/chips/cfi_cmdset_0002.c
@@ -263,7 +263,7 @@ static void fixup_old_sst_eraseregion(struct mtd_info *mtd)
 	struct cfi_private *cfi = map->fldrv_priv;
 
 	/*
-	 * These flashes report two seperate eraseblock regions based on the
+	 * These flashes report two separate eraseblock regions based on the
 	 * sector_erase-size and block_erase-size, although they both operate on the
 	 * same memory. This is not allowed according to CFI, so we just pick the
 	 * sector_erase-size.
@@ -611,8 +611,8 @@ static struct mtd_info *cfi_amdstd_setup(struct mtd_info *mtd)
  *
  * Note that anything more complicated than checking if no bits are toggling
  * (including checking DQ5 for an error status) is tricky to get working
- * correctly and is therefore not done	(particulary with interleaved chips
- * as each chip must be checked independantly of the others).
+ * correctly and is therefore not done	(particularly with interleaved chips
+ * as each chip must be checked independently of the others).
  */
 static int __xipram chip_ready(struct map_info *map, unsigned long addr)
 {
@@ -635,8 +635,8 @@ static int __xipram chip_ready(struct map_info *map, unsigned long addr)
  *
  * Note that anything more complicated than checking if no bits are toggling
  * (including checking DQ5 for an error status) is tricky to get working
- * correctly and is therefore not done	(particulary with interleaved chips
- * as each chip must be checked independantly of the others).
+ * correctly and is therefore not done	(particularly with interleaved chips
+ * as each chip must be checked independently of the others).
  *
  */
 static int __xipram chip_good(struct map_info *map, unsigned long addr, map_word expected)
diff --git a/drivers/mtd/chips/cfi_util.c b/drivers/mtd/chips/cfi_util.c
index 6ae3d11..8e46405 100644
--- a/drivers/mtd/chips/cfi_util.c
+++ b/drivers/mtd/chips/cfi_util.c
@@ -1,6 +1,6 @@
 /*
  * Common Flash Interface support:
- *   Generic utility functions not dependant on command set
+ *   Generic utility functions not dependent on command set
  *
  * Copyright (C) 2002 Red Hat
  * Copyright (C) 2003 STMicroelectronics Limited
diff --git a/drivers/mtd/chips/jedec_probe.c b/drivers/mtd/chips/jedec_probe.c
index 4e1be51..ea832ea 100644
--- a/drivers/mtd/chips/jedec_probe.c
+++ b/drivers/mtd/chips/jedec_probe.c
@@ -2075,7 +2075,7 @@ static inline int jedec_match( uint32_t base,
 	}
 
 	/*
-	 * Make sure the ID's dissappear when the device is taken out of
+	 * Make sure the ID's disappear when the device is taken out of
 	 * ID mode.  The only time this should fail when it should succeed
 	 * is when the ID's are written as data to the same
 	 * addresses.  For this rare and unfortunate case the chip
diff --git a/drivers/mtd/devices/block2mtd.c b/drivers/mtd/devices/block2mtd.c
index f29a6f9..97183c8 100644
--- a/drivers/mtd/devices/block2mtd.c
+++ b/drivers/mtd/devices/block2mtd.c
@@ -295,7 +295,7 @@ static struct block2mtd_dev *add_device(char *devname, int erase_size)
 	dev->mtd.owner = THIS_MODULE;
 
 	if (add_mtd_device(&dev->mtd)) {
-		/* Device didnt get added, so free the entry */
+		/* Device didn't get added, so free the entry */
 		goto devinit_err;
 	}
 	list_add(&dev->list, &blkmtd_device_list);
diff --git a/drivers/mtd/devices/doc2001plus.c b/drivers/mtd/devices/doc2001plus.c
index 719b291..8b36fa7 100644
--- a/drivers/mtd/devices/doc2001plus.c
+++ b/drivers/mtd/devices/doc2001plus.c
@@ -90,7 +90,7 @@ static inline int DoC_WaitReady(void __iomem * docptr)
 	return ret;
 }
 
-/* For some reason the Millennium Plus seems to occassionally put itself
+/* For some reason the Millennium Plus seems to occasionally put itself
  * into reset mode. For me this happens randomly, with no pattern that I
  * can detect. M-systems suggest always check this on any block level
  * operation and setting to normal mode if in reset mode.
diff --git a/drivers/mtd/devices/docecc.c b/drivers/mtd/devices/docecc.c
index a99838b..37ef29a 100644
--- a/drivers/mtd/devices/docecc.c
+++ b/drivers/mtd/devices/docecc.c
@@ -109,7 +109,7 @@ for(ci=(n)-1;ci >=0;ci--)\
    of the integer "alpha_to[i]" with a(0) being the LSB and a(m-1) the MSB. Thus for
    example the polynomial representation of @^5 would be given by the binary
    representation of the integer "alpha_to[5]".
-                   Similarily, index_of[] can be used as follows:
+                   Similarly, index_of[] can be used as follows:
         As above, let @ represent the primitive element of GF(2^m) that is
    the root of the primitive polynomial p(x). In order to find the power
    of @ (alpha) that has the polynomial representation
@@ -121,7 +121,7 @@ for(ci=(n)-1;ci >=0;ci--)\
    NOTE:
         The element alpha_to[2^m-1] = 0 always signifying that the
    representation of "@^infinity" = 0 is (0,0,0,...,0).
-        Similarily, the element index_of[0] = A0 always signifying
+        Similarly, the element index_of[0] = A0 always signifying
    that the power of alpha which has the polynomial representation
    (0,0,...,0) is "infinity".
 
diff --git a/drivers/mtd/devices/lart.c b/drivers/mtd/devices/lart.c
index caf6041..4b829f9 100644
--- a/drivers/mtd/devices/lart.c
+++ b/drivers/mtd/devices/lart.c
@@ -353,7 +353,7 @@ static inline int erase_block (__u32 offset)
    /* put the flash back into command mode */
    write32 (DATA_TO_FLASH (READ_ARRAY),offset);
 
-   /* was the erase successfull? */
+   /* was the erase successful? */
    if ((status & STATUS_ERASE_ERR))
 	 {
 		printk (KERN_WARNING "%s: erase error at address 0x%.8x.\n",module_name,offset);
@@ -508,7 +508,7 @@ static inline int write_dword (__u32 offset,__u32 x)
    /* put the flash back into command mode */
    write32 (DATA_TO_FLASH (READ_ARRAY),offset);
 
-   /* was the write successfull? */
+   /* was the write successful? */
    if ((status & STATUS_PGM_ERR) || read32 (offset) != x)
 	 {
 		printk (KERN_WARNING "%s: write error at address 0x%.8x.\n",module_name,offset);
diff --git a/drivers/mtd/devices/pmc551.c b/drivers/mtd/devices/pmc551.c
index ef0aba0..41b8cdc 100644
--- a/drivers/mtd/devices/pmc551.c
+++ b/drivers/mtd/devices/pmc551.c
@@ -351,7 +351,7 @@ static int pmc551_write(struct mtd_info *mtd, loff_t to, size_t len,
  * Fixup routines for the V370PDC
  * PCI device ID 0x020011b0
  *
- * This function basicly kick starts the DRAM oboard the card and gets it
+ * This function basically kick starts the DRAM oboard the card and gets it
  * ready to be used.  Before this is done the device reads VERY erratic, so
  * much that it can crash the Linux 2.2.x series kernels when a user cat's
  * /proc/pci .. though that is mainly a kernel bug in handling the PCI DEVSEL
@@ -540,7 +540,7 @@ static u32 fixup_pmc551(struct pci_dev *dev)
 
 	/*
 	 * Check to make certain the DEVSEL is set correctly, this device
-	 * has a tendancy to assert DEVSEL and TRDY when a write is performed
+	 * has a tendency to assert DEVSEL and TRDY when a write is performed
 	 * to the memory when memory is read-only
 	 */
 	if ((cmd & PCI_STATUS_DEVSEL_MASK) != 0x0) {
diff --git a/drivers/mtd/lpddr/lpddr_cmds.c b/drivers/mtd/lpddr/lpddr_cmds.c
index 04fdfcc..1267992 100644
--- a/drivers/mtd/lpddr/lpddr_cmds.c
+++ b/drivers/mtd/lpddr/lpddr_cmds.c
@@ -3,7 +3,7 @@
  * erase, lock/unlock support for LPDDR flash memories
  * (C) 2008 Korolev Alexey <akorolev@infradead.org>
  * (C) 2008 Vasiliy Leonenko <vasiliy.leonenko@gmail.com>
- * Many thanks to Roman Borisov for intial enabling
+ * Many thanks to Roman Borisov for initial enabling
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -171,7 +171,7 @@ static int wait_for_ready(struct map_info *map, struct flchip *chip,
 			mutex_lock(&chip->mutex);
 		}
 		if (chip->erase_suspended || chip->write_suspended)  {
-			/* Suspend has occured while sleep: reset timeout */
+			/* Suspend has occurred while sleep: reset timeout */
 			timeo = reset_timeo;
 			chip->erase_suspended = chip->write_suspended = 0;
 		}
diff --git a/drivers/mtd/maps/ceiva.c b/drivers/mtd/maps/ceiva.c
index e5f645b..23f551d 100644
--- a/drivers/mtd/maps/ceiva.c
+++ b/drivers/mtd/maps/ceiva.c
@@ -42,7 +42,7 @@
  *
  * Please note:
  *  1. The flash size given should be the largest flash size that can
- *     be accomodated.
+ *     be accommodated.
  *
  *  2. The bus width must defined in clps_setup_flash.
  *
@@ -58,7 +58,7 @@
 #define BOOT_PARTITION_SIZE_KiB       (16)
 #define PARAMS_PARTITION_SIZE_KiB     (8)
 #define KERNEL_PARTITION_SIZE_KiB     (4*128)
-/* Use both remaing portion of first flash, and all of second flash */
+/* Use both remaining portion of first flash, and all of second flash */
 #define ROOT_PARTITION_SIZE_KiB       (3*128) + (8*128)
 
 static struct mtd_partition ceiva_partitions[] = {
diff --git a/drivers/mtd/maps/cfi_flagadm.c b/drivers/mtd/maps/cfi_flagadm.c
index b4ed816..f71343c 100644
--- a/drivers/mtd/maps/cfi_flagadm.c
+++ b/drivers/mtd/maps/cfi_flagadm.c
@@ -33,7 +33,7 @@
 
 
 /* We split the flash chip up into four parts.
- * 1: bootloader firts 128k			(0x00000000 - 0x0001FFFF) size 0x020000
+ * 1: bootloader first 128k			(0x00000000 - 0x0001FFFF) size 0x020000
  * 2: kernel 640k					(0x00020000 - 0x000BFFFF) size 0x0A0000
  * 3: compressed 1536k root ramdisk	(0x000C0000 - 0x0023FFFF) size 0x180000
  * 4: writeable diskpartition (jffs)(0x00240000 - 0x003FFFFF) size 0x1C0000
diff --git a/drivers/mtd/maps/pcmciamtd.c b/drivers/mtd/maps/pcmciamtd.c
index 9170229..6799e75 100644
--- a/drivers/mtd/maps/pcmciamtd.c
+++ b/drivers/mtd/maps/pcmciamtd.c
@@ -497,7 +497,7 @@ static int pcmciamtd_config(struct pcmcia_device *link)
 		dev->pcmcia_map.set_vpp = pcmciamtd_set_vpp;
 
 	/* Request a memory window for PCMCIA. Some architeures can map windows
-	 * upto the maximum that PCMCIA can support (64MiB) - this is ideal and
+	 * up to the maximum that PCMCIA can support (64MiB) - this is ideal and
 	 * we aim for a window the size of the whole card - otherwise we try
 	 * smaller windows until we succeed
 	 */
diff --git a/drivers/mtd/maps/pmcmsp-flash.c b/drivers/mtd/maps/pmcmsp-flash.c
index acb13fa..64aea6a 100644
--- a/drivers/mtd/maps/pmcmsp-flash.c
+++ b/drivers/mtd/maps/pmcmsp-flash.c
@@ -3,7 +3,7 @@
  * Config with both CFI and JEDEC device support.
  *
  * Basically physmap.c with the addition of partitions and
- * an array of mapping info to accomodate more than one flash type per board.
+ * an array of mapping info to accommodate more than one flash type per board.
  *
  * Copyright 2005-2007 PMC-Sierra, Inc.
  *
diff --git a/drivers/mtd/maps/sc520cdp.c b/drivers/mtd/maps/sc520cdp.c
index 85c1e56..4d8aaaf 100644
--- a/drivers/mtd/maps/sc520cdp.c
+++ b/drivers/mtd/maps/sc520cdp.c
@@ -197,7 +197,7 @@ static void sc520cdp_setup_par(void)
 	}
 
 	/*
-	** Find the PARxx registers that are reponsible for activating
+	** Find the PARxx registers that are responsible for activating
 	** ROMCS0, ROMCS1 and BOOTCS. Reprogram each of these with a
 	** new value from the table.
 	*/
diff --git a/drivers/mtd/maps/tqm8xxl.c b/drivers/mtd/maps/tqm8xxl.c
index c08e140..0718dfb 100644
--- a/drivers/mtd/maps/tqm8xxl.c
+++ b/drivers/mtd/maps/tqm8xxl.c
@@ -63,7 +63,7 @@ static void __iomem *start_scan_addr;
  */
 
 #ifdef CONFIG_MTD_PARTITIONS
-/* Currently, TQM8xxL has upto 8MiB flash */
+/* Currently, TQM8xxL has up to 8MiB flash */
 static unsigned long tqm8xxl_max_flash_size = 0x00800000;
 
 /* partition definition for first flash bank
diff --git a/drivers/mtd/mtdblock.c b/drivers/mtd/mtdblock.c
index 1e74ad9..3326615 100644
--- a/drivers/mtd/mtdblock.c
+++ b/drivers/mtd/mtdblock.c
@@ -129,7 +129,7 @@ static int write_cached_data (struct mtdblk_dev *mtdblk)
 		return ret;
 
 	/*
-	 * Here we could argubly set the cache state to STATE_CLEAN.
+	 * Here we could arguably set the cache state to STATE_CLEAN.
 	 * However this could lead to inconsistency since we will not
 	 * be notified if this content is altered on the flash by other
 	 * means.  Let's declare it empty and leave buffering tasks to
diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 145b3d0d..4c36ef6 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -234,7 +234,7 @@ static ssize_t mtd_read(struct file *file, char __user *buf, size_t count,loff_t
 		 * the data. For our userspace tools it is important
 		 * to dump areas with ecc errors !
 		 * For kernel internal usage it also might return -EUCLEAN
-		 * to signal the caller that a bitflip has occured and has
+		 * to signal the caller that a bitflip has occurred and has
 		 * been corrected by the ECC algorithm.
 		 * Userspace software which accesses NAND this way
 		 * must be aware of the fact that it deals with NAND
diff --git a/drivers/mtd/nand/Kconfig b/drivers/mtd/nand/Kconfig
index a92054e..edec457 100644
--- a/drivers/mtd/nand/Kconfig
+++ b/drivers/mtd/nand/Kconfig
@@ -239,7 +239,7 @@ config MTD_NAND_BCM_UMI
 	help
 	  This enables the NAND flash controller on the BCM UMI block.
 
-	  No board specfic support is done by this driver, each board
+	  No board specific support is done by this driver, each board
 	  must advertise a platform_device for the driver to attach.
 
 config MTD_NAND_BCM_UMI_HWCS
diff --git a/drivers/mtd/nand/ams-delta.c b/drivers/mtd/nand/ams-delta.c
index a067d09..bc65bf7 100644
--- a/drivers/mtd/nand/ams-delta.c
+++ b/drivers/mtd/nand/ams-delta.c
@@ -228,7 +228,7 @@ static int __devinit ams_delta_init(struct platform_device *pdev)
 					  AMS_DELTA_LATCH2_NAND_NCE |
 					  AMS_DELTA_LATCH2_NAND_NWP);
 
-	/* Scan to find existance of the device */
+	/* Scan to find existence of the device */
 	if (nand_scan(ams_delta_mtd, 1)) {
 		err = -ENXIO;
 		goto out_mtd;
diff --git a/drivers/mtd/nand/autcpu12.c b/drivers/mtd/nand/autcpu12.c
index 7c95da1..0911cf0 100644
--- a/drivers/mtd/nand/autcpu12.c
+++ b/drivers/mtd/nand/autcpu12.c
@@ -176,7 +176,7 @@ static int __init autcpu12_init(void)
 	 */
 	this->options = NAND_USE_FLASH_BBT;
 
-	/* Scan to find existance of the device */
+	/* Scan to find existence of the device */
 	if (nand_scan(autcpu12_mtd, 1)) {
 		err = -ENXIO;
 		goto out_ior;
diff --git a/drivers/mtd/nand/cs553x_nand.c b/drivers/mtd/nand/cs553x_nand.c
index 9f1b451..71c35a0 100644
--- a/drivers/mtd/nand/cs553x_nand.c
+++ b/drivers/mtd/nand/cs553x_nand.c
@@ -241,7 +241,7 @@ static int __init cs553x_init_one(int cs, int mmio, unsigned long adr)
 	/* Enable the following for a flash based bad block table */
 	this->options = NAND_USE_FLASH_BBT | NAND_NO_AUTOINCR;
 
-	/* Scan to find existance of the device */
+	/* Scan to find existence of the device */
 	if (nand_scan(new_mtd, 1)) {
 		err = -ENXIO;
 		goto out_ior;
diff --git a/drivers/mtd/nand/denali.c b/drivers/mtd/nand/denali.c
index 8c8d3c8..4633f09 100644
--- a/drivers/mtd/nand/denali.c
+++ b/drivers/mtd/nand/denali.c
@@ -724,7 +724,7 @@ static uint32_t wait_for_irq(struct denali_nand_info *denali, uint32_t irq_mask)
 }
 
 /* This helper function setups the registers for ECC and whether or not
- * the spare area will be transfered. */
+ * the spare area will be transferred. */
 static void setup_ecc_for_xfer(struct denali_nand_info *denali, bool ecc_en,
 				bool transfer_spare)
 {
@@ -965,7 +965,7 @@ static bool handle_ecc(struct denali_nand_info *denali, uint8_t *buf,
 
 			if (ECC_ERROR_CORRECTABLE(err_correction_info)) {
 				/* If err_byte is larger than ECC_SECTOR_SIZE,
-				 * means error happend in OOB, so we ignore
+				 * means error happened in OOB, so we ignore
 				 * it. It's no need for us to correct it
 				 * err_device is represented the NAND error
 				 * bits are happened in if there are more
@@ -1109,7 +1109,7 @@ static void denali_write_page(struct mtd_info *mtd, struct nand_chip *chip,
 }
 
 /* This is the callback that the NAND core calls to write a page without ECC.
- * raw access is similiar to ECC page writes, so all the work is done in the
+ * raw access is similar to ECC page writes, so all the work is done in the
  * write_page() function above.
  */
 static void denali_write_page_raw(struct mtd_info *mtd, struct nand_chip *chip,
diff --git a/drivers/mtd/nand/diskonchip.c b/drivers/mtd/nand/diskonchip.c
index b7f8de7..96c0b34 100644
--- a/drivers/mtd/nand/diskonchip.c
+++ b/drivers/mtd/nand/diskonchip.c
@@ -137,7 +137,7 @@ static struct rs_control *rs_decoder;
  *
  * Fabrice Bellard figured this out in the old docecc code. I added
  * some comments, improved a minor bit and converted it to make use
- * of the generic Reed-Solomon libary. tglx
+ * of the generic Reed-Solomon library. tglx
  */
 static int doc_ecc_decode(struct rs_control *rs, uint8_t *data, uint8_t *ecc)
 {
@@ -400,7 +400,7 @@ static uint16_t __init doc200x_ident_chip(struct mtd_info *mtd, int nr)
 	doc200x_hwcontrol(mtd, 0, NAND_CTRL_ALE | NAND_CTRL_CHANGE);
 	doc200x_hwcontrol(mtd, NAND_CMD_NONE, NAND_NCE | NAND_CTRL_CHANGE);
 
-	/* We cant' use dev_ready here, but at least we wait for the
+	/* We can't' use dev_ready here, but at least we wait for the
 	 * command to complete
 	 */
 	udelay(50);
@@ -986,7 +986,7 @@ static int doc200x_correct_data(struct mtd_info *mtd, u_char *dat,
 		dummy = ReadDOC(docptr, ECCConf);
 	}
 
-	/* Error occured ? */
+	/* Error occurred ? */
 	if (dummy & 0x80) {
 		for (i = 0; i < 6; i++) {
 			if (DoC_is_MillenniumPlus(doc))
@@ -1160,7 +1160,7 @@ static inline int __init nftl_partscan(struct mtd_info *mtd, struct mtd_partitio
 	/* NOTE: The lines below modify internal variables of the NAND and MTD
 	   layers; variables with have already been configured by nand_scan.
 	   Unfortunately, we didn't know before this point what these values
-	   should be.  Thus, this code is somewhat dependant on the exact
+	   should be.  Thus, this code is somewhat dependent on the exact
 	   implementation of the NAND layer.  */
 	if (mh->UnitSizeFactor != 0xff) {
 		this->bbt_erase_shift += (0xff - mh->UnitSizeFactor);
diff --git a/drivers/mtd/nand/fsl_elbc_nand.c b/drivers/mtd/nand/fsl_elbc_nand.c
index 7a13d42..537e380 100644
--- a/drivers/mtd/nand/fsl_elbc_nand.c
+++ b/drivers/mtd/nand/fsl_elbc_nand.c
@@ -59,7 +59,7 @@ struct fsl_elbc_mtd {
 	unsigned int fmr;       /* FCM Flash Mode Register value     */
 };
 
-/* Freescale eLBC FCM controller infomation */
+/* Freescale eLBC FCM controller information */
 
 struct fsl_elbc_fcm_ctrl {
 	struct nand_hw_control controller;
diff --git a/drivers/mtd/nand/fsmc_nand.c b/drivers/mtd/nand/fsmc_nand.c
index 205b10b..0d45ef3 100644
--- a/drivers/mtd/nand/fsmc_nand.c
+++ b/drivers/mtd/nand/fsmc_nand.c
@@ -335,7 +335,7 @@ static void fsmc_enable_hwecc(struct mtd_info *mtd, int mode)
 
 /*
  * fsmc_read_hwecc_ecc4 - Hardware ECC calculator for ecc4 option supported by
- * FSMC. ECC is 13 bytes for 512 bytes of data (supports error correction upto
+ * FSMC. ECC is 13 bytes for 512 bytes of data (supports error correction up to
  * max of 8-bits)
  */
 static int fsmc_read_hwecc_ecc4(struct mtd_info *mtd, const uint8_t *data,
@@ -381,7 +381,7 @@ static int fsmc_read_hwecc_ecc4(struct mtd_info *mtd, const uint8_t *data,
 
 /*
  * fsmc_read_hwecc_ecc1 - Hardware ECC calculator for ecc1 option supported by
- * FSMC. ECC is 3 bytes for 512 bytes of data (supports error correction upto
+ * FSMC. ECC is 3 bytes for 512 bytes of data (supports error correction up to
  * max of 1-bit)
  */
 static int fsmc_read_hwecc_ecc1(struct mtd_info *mtd, const uint8_t *data,
@@ -408,10 +408,10 @@ static int fsmc_read_hwecc_ecc1(struct mtd_info *mtd, const uint8_t *data,
  * @buf:	buffer to store read data
  * @page:	page number to read
  *
- * This routine is needed for fsmc verison 8 as reading from NAND chip has to be
+ * This routine is needed for fsmc version 8 as reading from NAND chip has to be
  * performed in a strict sequence as follows:
  * data(512 byte) -> ecc(13 byte)
- * After this read, fsmc hardware generates and reports error data bits(upto a
+ * After this read, fsmc hardware generates and reports error data bits(up to a
  * max of 8 bits)
  */
 static int fsmc_read_page_hwecc(struct mtd_info *mtd, struct nand_chip *chip,
@@ -686,7 +686,7 @@ static int __init fsmc_nand_probe(struct platform_device *pdev)
 	}
 
 	/*
-	 * Scan to find existance of the device
+	 * Scan to find existence of the device
 	 */
 	if (nand_scan_ident(&host->mtd, 1, NULL)) {
 		ret = -ENXIO;
diff --git a/drivers/mtd/nand/nand_base.c b/drivers/mtd/nand/nand_base.c
index 85cfc06..c54a4cb 100644
--- a/drivers/mtd/nand/nand_base.c
+++ b/drivers/mtd/nand/nand_base.c
@@ -1582,7 +1582,7 @@ static int nand_do_read_ops(struct mtd_info *mtd, loff_t from,
 }
 
 /**
- * nand_read - [MTD Interface] MTD compability function for nand_do_read_ecc
+ * nand_read - [MTD Interface] MTD compatibility function for nand_do_read_ecc
  * @mtd:	MTD device structure
  * @from:	offset to read from
  * @len:	number of bytes to read
diff --git a/drivers/mtd/nand/nand_bbt.c b/drivers/mtd/nand/nand_bbt.c
index a1e8b30..af46428 100644
--- a/drivers/mtd/nand/nand_bbt.c
+++ b/drivers/mtd/nand/nand_bbt.c
@@ -945,7 +945,7 @@ static int check_create(struct mtd_info *mtd, uint8_t *buf, struct nand_bbt_desc
 		rd2 = NULL;
 		/* Per chip or per device ? */
 		chipsel = (td->options & NAND_BBT_PERCHIP) ? i : -1;
-		/* Mirrored table avilable ? */
+		/* Mirrored table available ? */
 		if (md) {
 			if (td->pages[i] == -1 && md->pages[i] == -1) {
 				writeops = 0x03;
diff --git a/drivers/mtd/nand/nandsim.c b/drivers/mtd/nand/nandsim.c
index 213181b..893d95b 100644
--- a/drivers/mtd/nand/nandsim.c
+++ b/drivers/mtd/nand/nandsim.c
@@ -162,7 +162,7 @@ MODULE_PARM_DESC(bitflips,       "Maximum number of random bit flips per page (z
 MODULE_PARM_DESC(gravepages,     "Pages that lose data [: maximum reads (defaults to 3)]"
 				 " separated by commas e.g. 1401:2 means page 1401"
 				 " can be read only twice before failing");
-MODULE_PARM_DESC(rptwear,        "Number of erases inbetween reporting wear, if not zero");
+MODULE_PARM_DESC(rptwear,        "Number of erases between reporting wear, if not zero");
 MODULE_PARM_DESC(overridesize,   "Specifies the NAND Flash size overriding the ID bytes. "
 				 "The size is specified in erase blocks and as the exponent of a power of two"
 				 " e.g. 5 means a size of 32 erase blocks");
diff --git a/drivers/mtd/nand/nomadik_nand.c b/drivers/mtd/nand/nomadik_nand.c
index 8c0b693..a045a4a 100644
--- a/drivers/mtd/nand/nomadik_nand.c
+++ b/drivers/mtd/nand/nomadik_nand.c
@@ -151,7 +151,7 @@ static int nomadik_nand_probe(struct platform_device *pdev)
 	nand->options = pdata->options;
 
 	/*
-	 * Scan to find existance of the device
+	 * Scan to find existence of the device
 	 */
 	if (nand_scan(&host->mtd, 1)) {
 		ret = -ENXIO;
diff --git a/drivers/mtd/nand/pasemi_nand.c b/drivers/mtd/nand/pasemi_nand.c
index 59efa82..20bfe5f 100644
--- a/drivers/mtd/nand/pasemi_nand.c
+++ b/drivers/mtd/nand/pasemi_nand.c
@@ -157,7 +157,7 @@ static int __devinit pasemi_nand_probe(struct platform_device *ofdev)
 	/* Enable the following for a flash based bad block table */
 	chip->options = NAND_USE_FLASH_BBT | NAND_NO_AUTOINCR;
 
-	/* Scan to find existance of the device */
+	/* Scan to find existence of the device */
 	if (nand_scan(pasemi_nand_mtd, 1)) {
 		err = -ENXIO;
 		goto out_lpc;
diff --git a/drivers/mtd/nand/plat_nand.c b/drivers/mtd/nand/plat_nand.c
index 317aff4..caf5a73 100644
--- a/drivers/mtd/nand/plat_nand.c
+++ b/drivers/mtd/nand/plat_nand.c
@@ -95,7 +95,7 @@ static int __devinit plat_nand_probe(struct platform_device *pdev)
 			goto out;
 	}
 
-	/* Scan to find existance of the device */
+	/* Scan to find existence of the device */
 	if (nand_scan(&data->mtd, pdata->chip.nr_chips)) {
 		err = -ENXIO;
 		goto out;
diff --git a/drivers/mtd/nand/pxa3xx_nand.c b/drivers/mtd/nand/pxa3xx_nand.c
index ab7f4c3..ff07012 100644
--- a/drivers/mtd/nand/pxa3xx_nand.c
+++ b/drivers/mtd/nand/pxa3xx_nand.c
@@ -184,7 +184,7 @@ struct pxa3xx_nand_info {
 
 static int use_dma = 1;
 module_param(use_dma, bool, 0444);
-MODULE_PARM_DESC(use_dma, "enable DMA for data transfering to/from NAND HW");
+MODULE_PARM_DESC(use_dma, "enable DMA for data transferring to/from NAND HW");
 
 /*
  * Default NAND flash controller configuration setup by the
diff --git a/drivers/mtd/nand/r852.c b/drivers/mtd/nand/r852.c
index 6322d1f..cae2e01 100644
--- a/drivers/mtd/nand/r852.c
+++ b/drivers/mtd/nand/r852.c
@@ -185,7 +185,7 @@ static void r852_do_dma(struct r852_device *dev, uint8_t *buf, int do_read)
 
 	dbg_verbose("doing dma %s ", do_read ? "read" : "write");
 
-	/* Set intial dma state: for reading first fill on board buffer,
+	/* Set initial dma state: for reading first fill on board buffer,
 	  from device, for writes first fill the buffer  from memory*/
 	dev->dma_state = do_read ? DMA_INTERNAL : DMA_MEMORY;
 
@@ -766,7 +766,7 @@ static irqreturn_t r852_irq(int irq, void *data)
 		ret = IRQ_HANDLED;
 		dev->card_detected = !!(card_status & R852_CARD_IRQ_INSERT);
 
-		/* we shouldn't recieve any interrupts if we wait for card
+		/* we shouldn't receive any interrupts if we wait for card
 			to settle */
 		WARN_ON(dev->card_unstable);
 
@@ -794,13 +794,13 @@ static irqreturn_t r852_irq(int irq, void *data)
 		ret = IRQ_HANDLED;
 
 		if (dma_status & R852_DMA_IRQ_ERROR) {
-			dbg("recieved dma error IRQ");
+			dbg("received dma error IRQ");
 			r852_dma_done(dev, -EIO);
 			complete(&dev->dma_done);
 			goto out;
 		}
 
-		/* recieved DMA interrupt out of nowhere? */
+		/* received DMA interrupt out of nowhere? */
 		WARN_ON_ONCE(dev->dma_stage == 0);
 
 		if (dev->dma_stage == 0)
@@ -960,7 +960,7 @@ int  r852_probe(struct pci_dev *pci_dev, const struct pci_device_id *id)
 		&dev->card_detect_work, 0);
 
 
-	printk(KERN_NOTICE DRV_NAME ": driver loaded succesfully\n");
+	printk(KERN_NOTICE DRV_NAME ": driver loaded successfully\n");
 	return 0;
 
 error10:
diff --git a/drivers/mtd/nand/sh_flctl.c b/drivers/mtd/nand/sh_flctl.c
index 546c2f0..81bbb5e 100644
--- a/drivers/mtd/nand/sh_flctl.c
+++ b/drivers/mtd/nand/sh_flctl.c
@@ -78,7 +78,7 @@ static void start_translation(struct sh_flctl *flctl)
 
 static void timeout_error(struct sh_flctl *flctl, const char *str)
 {
-	dev_err(&flctl->pdev->dev, "Timeout occured in %s\n", str);
+	dev_err(&flctl->pdev->dev, "Timeout occurred in %s\n", str);
 }
 
 static void wait_completion(struct sh_flctl *flctl)
diff --git a/drivers/mtd/nand/sm_common.c b/drivers/mtd/nand/sm_common.c
index 4a8f367..57cc80c 100644
--- a/drivers/mtd/nand/sm_common.c
+++ b/drivers/mtd/nand/sm_common.c
@@ -121,7 +121,7 @@ int sm_register_device(struct mtd_info *mtd, int smartmedia)
 	if (ret)
 		return ret;
 
-	/* Bad block marker postion */
+	/* Bad block marker position */
 	chip->badblockpos = 0x05;
 	chip->badblockbits = 7;
 	chip->block_markbad = sm_block_markbad;
diff --git a/drivers/mtd/nand/tmio_nand.c b/drivers/mtd/nand/tmio_nand.c
index 38fb167..14c5787 100644
--- a/drivers/mtd/nand/tmio_nand.c
+++ b/drivers/mtd/nand/tmio_nand.c
@@ -4,7 +4,7 @@
  * Slightly murky pre-git history of the driver:
  *
  * Copyright (c) Ian Molton 2004, 2005, 2008
- *    Original work, independant of sharps code. Included hardware ECC support.
+ *    Original work, independent of sharps code. Included hardware ECC support.
  *    Hard ECC did not work for writes in the early revisions.
  * Copyright (c) Dirk Opfer 2005.
  *    Modifications developed from sharps code but
diff --git a/drivers/mtd/onenand/omap2.c b/drivers/mtd/onenand/omap2.c
index f591f61..1fcb41a 100644
--- a/drivers/mtd/onenand/omap2.c
+++ b/drivers/mtd/onenand/omap2.c
@@ -608,7 +608,7 @@ static int omap2_onenand_enable(struct mtd_info *mtd)
 
 	ret = regulator_enable(c->regulator);
 	if (ret != 0)
-		dev_err(&c->pdev->dev, "cant enable regulator\n");
+		dev_err(&c->pdev->dev, "can't enable regulator\n");
 
 	return ret;
 }
@@ -620,7 +620,7 @@ static int omap2_onenand_disable(struct mtd_info *mtd)
 
 	ret = regulator_disable(c->regulator);
 	if (ret != 0)
-		dev_err(&c->pdev->dev, "cant disable regulator\n");
+		dev_err(&c->pdev->dev, "can't disable regulator\n");
 
 	return ret;
 }
diff --git a/drivers/mtd/onenand/onenand_sim.c b/drivers/mtd/onenand/onenand_sim.c
index 8b24606..5ef3bd5 100644
--- a/drivers/mtd/onenand/onenand_sim.c
+++ b/drivers/mtd/onenand/onenand_sim.c
@@ -321,7 +321,7 @@ static void onenand_data_handle(struct onenand_chip *this, int cmd,
 				continue;
 			if (memcmp(dest + off, ffchars, this->subpagesize) &&
 			    onenand_check_overwrite(dest + off, src + off, this->subpagesize))
-				printk(KERN_ERR "over-write happend at 0x%08x\n", offset);
+				printk(KERN_ERR "over-write happened at 0x%08x\n", offset);
 			memcpy(dest + off, src + off, this->subpagesize);
 		}
 		/* Fall through */
@@ -335,7 +335,7 @@ static void onenand_data_handle(struct onenand_chip *this, int cmd,
 		dest = ONENAND_CORE_SPARE(flash, this, offset);
 		if (memcmp(dest, ffchars, mtd->oobsize) &&
 		    onenand_check_overwrite(dest, src, mtd->oobsize))
-			printk(KERN_ERR "OOB: over-write happend at 0x%08x\n",
+			printk(KERN_ERR "OOB: over-write happened at 0x%08x\n",
 			       offset);
 		memcpy(dest, src, mtd->oobsize);
 		break;
diff --git a/drivers/mtd/sm_ftl.c b/drivers/mtd/sm_ftl.c
index 2b0daae..ed3d6cd 100644
--- a/drivers/mtd/sm_ftl.c
+++ b/drivers/mtd/sm_ftl.c
@@ -540,7 +540,7 @@ static int sm_check_block(struct sm_ftl *ftl, int zone, int block)
 			return -EIO;
 	}
 
-	/* If the block is sliced (partialy erased usually) erase it */
+	/* If the block is sliced (partially erased usually) erase it */
 	if (i == 2) {
 		sm_erase_block(ftl, zone, block, 1);
 		return 1;
@@ -878,7 +878,7 @@ static int sm_init_zone(struct sm_ftl *ftl, int zone_num)
 	return 0;
 }
 
-/* Get and automaticly initialize an FTL mapping for one zone */
+/* Get and automatically initialize an FTL mapping for one zone */
 struct ftl_zone *sm_get_zone(struct sm_ftl *ftl, int zone_num)
 {
 	struct ftl_zone *zone;
diff --git a/drivers/mtd/ubi/Kconfig b/drivers/mtd/ubi/Kconfig
index 6abeb4f..4dcc752 100644
--- a/drivers/mtd/ubi/Kconfig
+++ b/drivers/mtd/ubi/Kconfig
@@ -56,7 +56,7 @@ config MTD_UBI_DEBUG
 	bool "UBI debugging"
 	depends on SYSFS
 	select DEBUG_FS
-	select KALLSYMS_ALL if KALLSYMS && DEBUG_KERNEL
+	select KALLSYMS
 	help
 	  This option enables UBI debugging.
 
diff --git a/drivers/mtd/ubi/io.c b/drivers/mtd/ubi/io.c
index eededf9..e347cc4 100644
--- a/drivers/mtd/ubi/io.c
+++ b/drivers/mtd/ubi/io.c
@@ -344,6 +344,12 @@ static int do_sync_erase(struct ubi_device *ubi, int pnum)
 	wait_queue_head_t wq;
 
 	dbg_io("erase PEB %d", pnum);
+	ubi_assert(pnum >= 0 && pnum < ubi->peb_count);
+
+	if (ubi->ro_mode) {
+		ubi_err("read-only mode");
+		return -EROFS;
+	}
 
 retry:
 	init_waitqueue_head(&wq);
@@ -390,7 +396,7 @@ retry:
 	if (err)
 		return err;
 
-	if (ubi_dbg_is_erase_failure() && !err) {
+	if (ubi_dbg_is_erase_failure()) {
 		dbg_err("cannot erase PEB %d (emulated)", pnum);
 		return -EIO;
 	}
diff --git a/drivers/mtd/ubi/scan.c b/drivers/mtd/ubi/scan.c
index 11eb8ef..d2d12ab 100644
--- a/drivers/mtd/ubi/scan.c
+++ b/drivers/mtd/ubi/scan.c
@@ -968,7 +968,7 @@ static int process_eb(struct ubi_device *ubi, struct ubi_scan_info *si,
 			 * contains garbage because of a power cut during erase
 			 * operation. So we just schedule this PEB for erasure.
 			 *
-			 * Besides, in case of NOR flash, we deliberatly
+			 * Besides, in case of NOR flash, we deliberately
 			 * corrupt both headers because NOR flash erasure is
 			 * slow and can start from the end.
 			 */
diff --git a/drivers/mtd/ubi/vmt.c b/drivers/mtd/ubi/vmt.c
index b79e0de..366eb70 100644
--- a/drivers/mtd/ubi/vmt.c
+++ b/drivers/mtd/ubi/vmt.c
@@ -790,11 +790,6 @@ static int paranoid_check_volume(struct ubi_device *ubi, int vol_id)
 		goto fail;
 	}
 
-	if (!vol->name) {
-		ubi_err("NULL volume name");
-		goto fail;
-	}
-
 	n = strnlen(vol->name, vol->name_len + 1);
 	if (n != vol->name_len) {
 		ubi_err("bad name_len %lld", n);
diff --git a/drivers/net/3c501.c b/drivers/net/3c501.c
index 9e1c03e..5420f6d 100644
--- a/drivers/net/3c501.c
+++ b/drivers/net/3c501.c
@@ -399,7 +399,7 @@ static void el_timeout(struct net_device *dev)
  * as we may still be attempting to retrieve the last RX packet buffer.
  *
  * When a transmit times out we dump the card into control mode and just
- * start again. It happens enough that it isnt worth logging.
+ * start again. It happens enough that it isn't worth logging.
  *
  * We avoid holding the spin locks when doing the packet load to the board.
  * The device is very slow, and its DMA mode is even slower. If we held the
@@ -499,7 +499,7 @@ static netdev_tx_t el_start_xmit(struct sk_buff *skb, struct net_device *dev)
  *
  * Handle the ether interface interrupts. The 3c501 needs a lot more
  * hand holding than most cards. In particular we get a transmit interrupt
- * with a collision error because the board firmware isnt capable of rewinding
+ * with a collision error because the board firmware isn't capable of rewinding
  * its own transmit buffer pointers. It can however count to 16 for us.
  *
  * On the receive side the card is also very dumb. It has no buffering to
@@ -732,7 +732,7 @@ static void el_receive(struct net_device *dev)
  * el_reset: Reset a 3c501 card
  * @dev: The 3c501 card about to get zapped
  *
- * Even resetting a 3c501 isnt simple. When you activate reset it loses all
+ * Even resetting a 3c501 isn't simple. When you activate reset it loses all
  * its configuration. You must hold the lock when doing this. The function
  * cannot take the lock itself as it is callable from the irq handler.
  */
diff --git a/drivers/net/3c523.c b/drivers/net/3c523.c
index de579d0..bc0d1a1 100644
--- a/drivers/net/3c523.c
+++ b/drivers/net/3c523.c
@@ -44,7 +44,7 @@
    this for the 64K version would require a lot of heinous bank
    switching, which I'm sure not interested in doing.  If you try to
    implement a bank switching version, you'll basically have to remember
-   what bank is enabled and do a switch everytime you access a memory
+   what bank is enabled and do a switch every time you access a memory
    location that's not current.  You'll also have to remap pointers on
    the driver side, because it only knows about 16K of the memory.
    Anyone desperate or masochistic enough to try?
diff --git a/drivers/net/3c527.c b/drivers/net/3c527.c
index 8c094ba..d9d056d 100644
--- a/drivers/net/3c527.c
+++ b/drivers/net/3c527.c
@@ -51,7 +51,7 @@ DRV_NAME ".c:v" DRV_VERSION " " DRV_RELDATE " Richard Procter <rnp@paradise.net.
  *	circular buffer queues.
  *
  *	The mailboxes can be used for controlling how the card traverses
- *	its buffer rings, but are used only for inital setup in this
+ *	its buffer rings, but are used only for initial setup in this
  *	implementation.  The exec mailbox allows a variety of commands to
  *	be executed. Each command must complete before the next is
  *	executed. Primarily we use the exec mailbox for controlling the
@@ -813,7 +813,7 @@ static void mc32_flush_rx_ring(struct net_device *dev)
  *
  *	This sets up the host transmit data-structures.
  *
- *	First, we obtain from the card it's current postion in the tx
+ *	First, we obtain from the card it's current position in the tx
  *	ring, so that we will know where to begin transmitting
  *	packets.
  *
diff --git a/drivers/net/3c59x.c b/drivers/net/3c59x.c
index 0a92436f..8cc2256 100644
--- a/drivers/net/3c59x.c
+++ b/drivers/net/3c59x.c
@@ -984,7 +984,7 @@ static int __init vortex_eisa_init(void)
 		 * any device have been found when we exit from
 		 * eisa_driver_register (the bus root driver may not be
 		 * initialized yet). So we blindly assume something was
-		 * found, and let the sysfs magic happend...
+		 * found, and let the sysfs magic happened...
 		 */
 		eisa_found = 1;
 	}
diff --git a/drivers/net/acenic.c b/drivers/net/acenic.c
index 41d9911..ee648fe 100644
--- a/drivers/net/acenic.c
+++ b/drivers/net/acenic.c
@@ -1584,7 +1584,7 @@ static void ace_watchdog(struct net_device *data)
 	/*
 	 * We haven't received a stats update event for more than 2.5
 	 * seconds and there is data in the transmit queue, thus we
-	 * asume the card is stuck.
+	 * assume the card is stuck.
 	 */
 	if (*ap->tx_csm != ap->tx_ret_csm) {
 		printk(KERN_WARNING "%s: Transmitter is stuck, %08x\n",
@@ -2564,7 +2564,7 @@ restart:
 
 		/*
 		 * A TX-descriptor producer (an IRQ) might have gotten
-		 * inbetween, making the ring free again. Since xmit is
+		 * between, making the ring free again. Since xmit is
 		 * serialized, this is the only situation we have to
 		 * re-test.
 		 */
diff --git a/drivers/net/amd8111e.c b/drivers/net/amd8111e.c
index 2ca880b..88495c4 100644
--- a/drivers/net/amd8111e.c
+++ b/drivers/net/amd8111e.c
@@ -1398,7 +1398,7 @@ static void amd8111e_set_multicast_list(struct net_device *dev)
 		mc_filter[1] = mc_filter[0] = 0;
 		lp->options &= ~OPTION_MULTICAST_ENABLE;
 		amd8111e_writeq(*(u64*)mc_filter,lp->mmio + LADRF);
-		/* disable promiscous mode */
+		/* disable promiscuous mode */
 		writel(PROM, lp->mmio + CMD2);
 		return;
 	}
diff --git a/drivers/net/at1700.c b/drivers/net/at1700.c
index f4744fc..65a78f9 100644
--- a/drivers/net/at1700.c
+++ b/drivers/net/at1700.c
@@ -133,7 +133,7 @@ struct net_local {
 /* Run-time register bank 2 definitions. */
 #define DATAPORT		8		/* Word-wide DMA or programmed-I/O dataport. */
 #define TX_START		10
-#define COL16CNTL		11		/* Controll Reg for 16 collisions */
+#define COL16CNTL		11		/* Control Reg for 16 collisions */
 #define MODE13			13
 #define RX_CTRL			14
 /* Configuration registers only on the '865A/B chips. */
diff --git a/drivers/net/atl1e/atl1e_main.c b/drivers/net/atl1e/atl1e_main.c
index 1ff001a..b0a71e2 100644
--- a/drivers/net/atl1e/atl1e_main.c
+++ b/drivers/net/atl1e/atl1e_main.c
@@ -2509,7 +2509,7 @@ static struct pci_driver atl1e_driver = {
 	.id_table = atl1e_pci_tbl,
 	.probe    = atl1e_probe,
 	.remove   = __devexit_p(atl1e_remove),
-	/* Power Managment Hooks */
+	/* Power Management Hooks */
 #ifdef CONFIG_PM
 	.suspend  = atl1e_suspend,
 	.resume   = atl1e_resume,
diff --git a/drivers/net/atlx/atl2.c b/drivers/net/atlx/atl2.c
index 937ef1a..e3cbf45 100644
--- a/drivers/net/atlx/atl2.c
+++ b/drivers/net/atlx/atl2.c
@@ -1701,7 +1701,7 @@ static struct pci_driver atl2_driver = {
 	.id_table = atl2_pci_tbl,
 	.probe    = atl2_probe,
 	.remove   = __devexit_p(atl2_remove),
-	/* Power Managment Hooks */
+	/* Power Management Hooks */
 	.suspend  = atl2_suspend,
 #ifdef CONFIG_PM
 	.resume   = atl2_resume,
diff --git a/drivers/net/bcm63xx_enet.c b/drivers/net/bcm63xx_enet.c
index e94a966a..c48104b 100644
--- a/drivers/net/bcm63xx_enet.c
+++ b/drivers/net/bcm63xx_enet.c
@@ -597,7 +597,7 @@ static int bcm_enet_set_mac_address(struct net_device *dev, void *p)
 }
 
 /*
- * Change rx mode (promiscous/allmulti) and update multicast list
+ * Change rx mode (promiscuous/allmulti) and update multicast list
  */
 static void bcm_enet_set_multicast_list(struct net_device *dev)
 {
diff --git a/drivers/net/benet/be_cmds.c b/drivers/net/benet/be_cmds.c
index 5a4a87e..1e2d825 100644
--- a/drivers/net/benet/be_cmds.c
+++ b/drivers/net/benet/be_cmds.c
@@ -1331,7 +1331,7 @@ err:
 
 /*
  * Uses MCC for this command as it may be called in BH context
- * (mc == NULL) => multicast promiscous
+ * (mc == NULL) => multicast promiscuous
  */
 int be_cmd_multicast_set(struct be_adapter *adapter, u32 if_id,
 		struct net_device *netdev, struct be_dma_mem *mem)
diff --git a/drivers/net/benet/be_main.c b/drivers/net/benet/be_main.c
index a71163f..9a54c8b 100644
--- a/drivers/net/benet/be_main.c
+++ b/drivers/net/benet/be_main.c
@@ -708,7 +708,7 @@ static void be_set_multicast_list(struct net_device *netdev)
 		goto done;
 	}
 
-	/* BE was previously in promiscous mode; disable it */
+	/* BE was previously in promiscuous mode; disable it */
 	if (adapter->promiscuous) {
 		adapter->promiscuous = false;
 		be_cmd_promiscuous_config(adapter, adapter->port_num, 0);
diff --git a/drivers/net/bna/bna_hw.h b/drivers/net/bna/bna_hw.h
index 806b224..6cb8969 100644
--- a/drivers/net/bna/bna_hw.h
+++ b/drivers/net/bna/bna_hw.h
@@ -897,7 +897,7 @@ static struct bna_ritseg_pool_cfg name[BFI_RIT_SEG_TOTAL_POOLS] =	\
  * Catapult RSS Table Base Offset Address
  *
  * Exists in RAD memory space.
- * Each entry is 352 bits, but alligned on
+ * Each entry is 352 bits, but aligned on
  * 64 byte (512 bit) boundary. Accessed
  * 4 byte words, the whole entry can be
  * broken into 11 word accesses.
diff --git a/drivers/net/bnx2x/bnx2x.h b/drivers/net/bnx2x/bnx2x.h
index b7ff87b..e0fca70 100644
--- a/drivers/net/bnx2x/bnx2x.h
+++ b/drivers/net/bnx2x/bnx2x.h
@@ -1220,7 +1220,7 @@ struct bnx2x {
 	struct bnx2x_dcbx_port_params		dcbx_port_params;
 	int					dcb_version;
 
-	/* DCBX Negotation results */
+	/* DCBX Negotiation results */
 	struct dcbx_features			dcbx_local_feat;
 	u32					dcbx_error;
 	u32					pending_max;
diff --git a/drivers/net/bnx2x/bnx2x_hsi.h b/drivers/net/bnx2x/bnx2x_hsi.h
index be503cc..dac1bf9 100644
--- a/drivers/net/bnx2x/bnx2x_hsi.h
+++ b/drivers/net/bnx2x/bnx2x_hsi.h
@@ -3019,7 +3019,7 @@ struct tstorm_eth_mac_filter_config {
 
 
 /*
- * common flag to indicate existance of TPA.
+ * common flag to indicate existence of TPA.
  */
 struct tstorm_eth_tpa_exist {
 #if defined(__BIG_ENDIAN)
diff --git a/drivers/net/bnx2x/bnx2x_link.c b/drivers/net/bnx2x/bnx2x_link.c
index f2f367d..974ef2b 100644
--- a/drivers/net/bnx2x/bnx2x_link.c
+++ b/drivers/net/bnx2x/bnx2x_link.c
@@ -2823,7 +2823,7 @@ static u16 bnx2x_wait_reset_complete(struct bnx2x *bp,
 				     struct link_params *params)
 {
 	u16 cnt, ctrl;
-	/* Wait for soft reset to get cleared upto 1 sec */
+	/* Wait for soft reset to get cleared up to 1 sec */
 	for (cnt = 0; cnt < 1000; cnt++) {
 		bnx2x_cl45_read(bp, phy,
 				MDIO_PMA_DEVAD, MDIO_PMA_REG_CTRL, &ctrl);
@@ -4141,7 +4141,7 @@ static u8 bnx2x_8073_config_init(struct bnx2x_phy *phy,
 			val = (1<<5);
 			/*
 			 * Note that 2.5G works only when used with 1G
-			 * advertisment
+			 * advertisement
 			 */
 		} else
 			val = (1<<5);
@@ -4151,7 +4151,7 @@ static u8 bnx2x_8073_config_init(struct bnx2x_phy *phy,
 			PORT_HW_CFG_SPEED_CAPABILITY_D0_10G)
 			val |= (1<<7);
 
-		/* Note that 2.5G works only when used with 1G advertisment */
+		/* Note that 2.5G works only when used with 1G advertisement */
 		if (phy->speed_cap_mask &
 			(PORT_HW_CFG_SPEED_CAPABILITY_D0_1G |
 			 PORT_HW_CFG_SPEED_CAPABILITY_D0_2_5G))
@@ -5232,14 +5232,14 @@ static u8 bnx2x_8706_config_init(struct bnx2x_phy *phy,
 		bnx2x_cl45_write(bp, phy,
 				 MDIO_PMA_DEVAD, MDIO_PMA_REG_LASI_CTRL, 1);
 	} else {
-		/* Force 1Gbps using autoneg with 1G advertisment */
+		/* Force 1Gbps using autoneg with 1G advertisement */
 
 		/* Allow CL37 through CL73 */
 		DP(NETIF_MSG_LINK, "XGXS 8706 AutoNeg\n");
 		bnx2x_cl45_write(bp, phy,
 				 MDIO_AN_DEVAD, MDIO_AN_REG_CL37_CL73, 0x040c);
 
-		/* Enable Full-Duplex advertisment on CL37 */
+		/* Enable Full-Duplex advertisement on CL37 */
 		bnx2x_cl45_write(bp, phy,
 				 MDIO_AN_DEVAD, MDIO_AN_REG_CL37_FC_LP, 0x0020);
 		/* Enable CL37 AN */
@@ -6269,7 +6269,7 @@ static u8 bnx2x_848x3_config_init(struct bnx2x_phy *phy,
 
 	switch (actual_phy_selection) {
 	case PORT_HW_CFG_PHY_SELECTION_HARDWARE_DEFAULT:
-		/* Do nothing. Essentialy this is like the priority copper */
+		/* Do nothing. Essentially this is like the priority copper */
 		break;
 	case PORT_HW_CFG_PHY_SELECTION_FIRST_PHY_PRIORITY:
 		val |= MDIO_CTL_REG_84823_MEDIA_PRIORITY_COPPER;
@@ -7765,7 +7765,7 @@ u8 bnx2x_link_reset(struct link_params *params, struct link_vars *vars,
 	REG_WR(bp, NIG_REG_NIG_EMAC0_EN + port*4, 0);
 
 	msleep(10);
-	/* The PHY reset is controled by GPIO 1
+	/* The PHY reset is controlled by GPIO 1
 	 * Hold it as vars low
 	 */
 	 /* clear link led */
diff --git a/drivers/net/bnx2x/bnx2x_main.c b/drivers/net/bnx2x/bnx2x_main.c
index 32e64cc8..a97a4a1 100644
--- a/drivers/net/bnx2x/bnx2x_main.c
+++ b/drivers/net/bnx2x/bnx2x_main.c
@@ -3702,7 +3702,7 @@ static void bnx2x_eq_int(struct bnx2x *bp)
 	if ((hw_cons & EQ_DESC_MAX_PAGE) == EQ_DESC_MAX_PAGE)
 		hw_cons++;
 
-	/* This function may never run in parralel with itself for a
+	/* This function may never run in parallel with itself for a
 	 * specific bp, thus there is no need in "paired" read memory
 	 * barrier here.
 	 */
@@ -5089,7 +5089,7 @@ static int bnx2x_init_hw_common(struct bnx2x *bp, u32 load_code)
 		/* Step 1: set zeroes to all ilt page entries with valid bit on
 		 * Step 2: set the timers first/last ilt entry to point
 		 * to the entire range to prevent ILT range error for 3rd/4th
-		 * vnic	(this code assumes existance of the vnic)
+		 * vnic	(this code assumes existence of the vnic)
 		 *
 		 * both steps performed by call to bnx2x_ilt_client_init_op()
 		 * with dummy TM client
@@ -8685,7 +8685,7 @@ static int __devinit bnx2x_get_hwinfo(struct bnx2x *bp)
 				E1H_FUNC_MAX * sizeof(struct drv_func_mb);
 		/*
 		 * get mf configuration:
-		 * 1. existance of MF configuration
+		 * 1. existence of MF configuration
 		 * 2. MAC address must be legal (check only upper bytes)
 		 *    for  Switch-Independent mode;
 		 *    OVLAN must be legal for Switch-Dependent mode
@@ -8727,7 +8727,7 @@ static int __devinit bnx2x_get_hwinfo(struct bnx2x *bp)
 			default:
 				/* Unknown configuration: reset mf_config */
 				bp->mf_config[vn] = 0;
-				DP(NETIF_MSG_PROBE, "Unkown MF mode 0x%x\n",
+				DP(NETIF_MSG_PROBE, "Unknown MF mode 0x%x\n",
 				   val);
 			}
 		}
@@ -9777,7 +9777,7 @@ static int __devinit bnx2x_init_one(struct pci_dev *pdev,
 
 #endif
 
-	/* Configure interupt mode: try to enable MSI-X/MSI if
+	/* Configure interrupt mode: try to enable MSI-X/MSI if
 	 * needed, set bp->num_queues appropriately.
 	 */
 	bnx2x_set_int_mode(bp);
diff --git a/drivers/net/bnx2x/bnx2x_reg.h b/drivers/net/bnx2x/bnx2x_reg.h
index 1c89f19..1509a23 100644
--- a/drivers/net/bnx2x/bnx2x_reg.h
+++ b/drivers/net/bnx2x/bnx2x_reg.h
@@ -175,9 +175,9 @@
    the initial credit value; read returns the current value of the credit
    counter. Must be initialized to 1 at start-up. */
 #define CCM_REG_CFC_INIT_CRD					 0xd0204
-/* [RW 2] Auxillary counter flag Q number 1. */
+/* [RW 2] Auxiliary counter flag Q number 1. */
 #define CCM_REG_CNT_AUX1_Q					 0xd00c8
-/* [RW 2] Auxillary counter flag Q number 2. */
+/* [RW 2] Auxiliary counter flag Q number 2. */
 #define CCM_REG_CNT_AUX2_Q					 0xd00cc
 /* [RW 28] The CM header value for QM request (primary). */
 #define CCM_REG_CQM_CCM_HDR_P					 0xd008c
@@ -457,13 +457,13 @@
 #define CSDM_REG_AGG_INT_MODE_9 				 0xc21dc
 /* [RW 13] The start address in the internal RAM for the cfc_rsp lcid */
 #define CSDM_REG_CFC_RSP_START_ADDR				 0xc2008
-/* [RW 16] The maximum value of the competion counter #0 */
+/* [RW 16] The maximum value of the completion counter #0 */
 #define CSDM_REG_CMP_COUNTER_MAX0				 0xc201c
-/* [RW 16] The maximum value of the competion counter #1 */
+/* [RW 16] The maximum value of the completion counter #1 */
 #define CSDM_REG_CMP_COUNTER_MAX1				 0xc2020
-/* [RW 16] The maximum value of the competion counter #2 */
+/* [RW 16] The maximum value of the completion counter #2 */
 #define CSDM_REG_CMP_COUNTER_MAX2				 0xc2024
-/* [RW 16] The maximum value of the competion counter #3 */
+/* [RW 16] The maximum value of the completion counter #3 */
 #define CSDM_REG_CMP_COUNTER_MAX3				 0xc2028
 /* [RW 13] The start address in the internal RAM for the completion
    counters. */
@@ -851,7 +851,7 @@
 #define IGU_REG_ATTN_MSG_ADDR_L				 0x130120
 /* [R 4] Debug: [3] - attention write done message is pending (0-no pending;
  * 1-pending). [2:0] = PFID. Pending means attention message was sent; but
- * write done didnt receive. */
+ * write done didn't receive. */
 #define IGU_REG_ATTN_WRITE_DONE_PENDING			 0x130030
 #define IGU_REG_BLOCK_CONFIGURATION				 0x130000
 #define IGU_REG_COMMAND_REG_32LSB_DATA				 0x130124
@@ -862,7 +862,7 @@
 #define IGU_REG_CSTORM_TYPE_0_SB_CLEANUP			 0x130200
 /* [R 5] Debug: ctrl_fsm */
 #define IGU_REG_CTRL_FSM					 0x130064
-/* [R 1] data availble for error memory. If this bit is clear do not red
+/* [R 1] data available for error memory. If this bit is clear do not red
  * from error_handling_memory. */
 #define IGU_REG_ERROR_HANDLING_DATA_VALID			 0x130130
 /* [RW 11] Parity mask register #0 read/write */
@@ -3015,7 +3015,7 @@
    block. Should be used for close the gates. */
 #define PXP_REG_HST_DISCARD_DOORBELLS				 0x1030a4
 /* [R 1] debug only: '1' means this PSWHST is discarding doorbells. This bit
-   should update accoring to 'hst_discard_doorbells' register when the state
+   should update according to 'hst_discard_doorbells' register when the state
    machine is idle */
 #define PXP_REG_HST_DISCARD_DOORBELLS_STATUS			 0x1030a0
 /* [RW 1] When 1; new internal writes arriving to the block are discarded.
@@ -3023,7 +3023,7 @@
 #define PXP_REG_HST_DISCARD_INTERNAL_WRITES			 0x1030a8
 /* [R 6] debug only: A bit mask for all PSWHST internal write clients. '1'
    means this PSWHST is discarding inputs from this client. Each bit should
-   update accoring to 'hst_discard_internal_writes' register when the state
+   update according to 'hst_discard_internal_writes' register when the state
    machine is idle. */
 #define PXP_REG_HST_DISCARD_INTERNAL_WRITES_STATUS		 0x10309c
 /* [WB 160] Used for initialization of the inbound interrupts memory */
@@ -3822,13 +3822,13 @@
 #define TSDM_REG_AGG_INT_T_1					 0x420bc
 /* [RW 13] The start address in the internal RAM for the cfc_rsp lcid */
 #define TSDM_REG_CFC_RSP_START_ADDR				 0x42008
-/* [RW 16] The maximum value of the competion counter #0 */
+/* [RW 16] The maximum value of the completion counter #0 */
 #define TSDM_REG_CMP_COUNTER_MAX0				 0x4201c
-/* [RW 16] The maximum value of the competion counter #1 */
+/* [RW 16] The maximum value of the completion counter #1 */
 #define TSDM_REG_CMP_COUNTER_MAX1				 0x42020
-/* [RW 16] The maximum value of the competion counter #2 */
+/* [RW 16] The maximum value of the completion counter #2 */
 #define TSDM_REG_CMP_COUNTER_MAX2				 0x42024
-/* [RW 16] The maximum value of the competion counter #3 */
+/* [RW 16] The maximum value of the completion counter #3 */
 #define TSDM_REG_CMP_COUNTER_MAX3				 0x42028
 /* [RW 13] The start address in the internal RAM for the completion
    counters. */
@@ -4284,13 +4284,13 @@
 #define USDM_REG_AGG_INT_T_6					 0xc40d0
 /* [RW 13] The start address in the internal RAM for the cfc_rsp lcid */
 #define USDM_REG_CFC_RSP_START_ADDR				 0xc4008
-/* [RW 16] The maximum value of the competion counter #0 */
+/* [RW 16] The maximum value of the completion counter #0 */
 #define USDM_REG_CMP_COUNTER_MAX0				 0xc401c
-/* [RW 16] The maximum value of the competion counter #1 */
+/* [RW 16] The maximum value of the completion counter #1 */
 #define USDM_REG_CMP_COUNTER_MAX1				 0xc4020
-/* [RW 16] The maximum value of the competion counter #2 */
+/* [RW 16] The maximum value of the completion counter #2 */
 #define USDM_REG_CMP_COUNTER_MAX2				 0xc4024
-/* [RW 16] The maximum value of the competion counter #3 */
+/* [RW 16] The maximum value of the completion counter #3 */
 #define USDM_REG_CMP_COUNTER_MAX3				 0xc4028
 /* [RW 13] The start address in the internal RAM for the completion
    counters. */
@@ -4798,13 +4798,13 @@
 #define XSDM_REG_AGG_INT_MODE_1 				 0x1661bc
 /* [RW 13] The start address in the internal RAM for the cfc_rsp lcid */
 #define XSDM_REG_CFC_RSP_START_ADDR				 0x166008
-/* [RW 16] The maximum value of the competion counter #0 */
+/* [RW 16] The maximum value of the completion counter #0 */
 #define XSDM_REG_CMP_COUNTER_MAX0				 0x16601c
-/* [RW 16] The maximum value of the competion counter #1 */
+/* [RW 16] The maximum value of the completion counter #1 */
 #define XSDM_REG_CMP_COUNTER_MAX1				 0x166020
-/* [RW 16] The maximum value of the competion counter #2 */
+/* [RW 16] The maximum value of the completion counter #2 */
 #define XSDM_REG_CMP_COUNTER_MAX2				 0x166024
-/* [RW 16] The maximum value of the competion counter #3 */
+/* [RW 16] The maximum value of the completion counter #3 */
 #define XSDM_REG_CMP_COUNTER_MAX3				 0x166028
 /* [RW 13] The start address in the internal RAM for the completion
    counters. */
diff --git a/drivers/net/bonding/bond_alb.h b/drivers/net/bonding/bond_alb.h
index 4b3e358..86861f0 100644
--- a/drivers/net/bonding/bond_alb.h
+++ b/drivers/net/bonding/bond_alb.h
@@ -76,7 +76,7 @@ struct tlb_client_info {
 				 */
 	u32 tx_bytes;		/* Each Client accumulates the BytesTx that
 				 * were tranmitted to it, and after each
-				 * CallBack the LoadHistory is devided
+				 * CallBack the LoadHistory is divided
 				 * by the balance interval
 				 */
 	u32 load_history;	/* This field contains the amount of Bytes
diff --git a/drivers/net/caif/caif_shmcore.c b/drivers/net/caif/caif_shmcore.c
index 8051116..731aa11 100644
--- a/drivers/net/caif/caif_shmcore.c
+++ b/drivers/net/caif/caif_shmcore.c
@@ -591,7 +591,7 @@ int caif_shmcore_probe(struct shmdev_layer *pshm_dev)
 			(NR_TX_BUF * TX_BUF_SZ + NR_RX_BUF * RX_BUF_SZ)) {
 
 		pr_warn("ERROR, Amount of available"
-				" Phys. SHM cannot accomodate current SHM "
+				" Phys. SHM cannot accommodate current SHM "
 				"driver configuration, Bailing out ...\n");
 		free_netdev(pshm_dev->pshm_netdev);
 		return -ENOMEM;
diff --git a/drivers/net/caif/caif_spi.c b/drivers/net/caif/caif_spi.c
index 20da199..57e6393 100644
--- a/drivers/net/caif/caif_spi.c
+++ b/drivers/net/caif/caif_spi.c
@@ -397,7 +397,7 @@ int cfspi_xmitlen(struct cfspi *cfspi)
 	int pkts = 0;
 
 	/*
-	 * Decommit previously commited frames.
+	 * Decommit previously committed frames.
 	 * skb_queue_splice_tail(&cfspi->chead,&cfspi->qhead)
 	 */
 	while (skb_peek(&cfspi->chead)) {
diff --git a/drivers/net/caif/caif_spi_slave.c b/drivers/net/caif/caif_spi_slave.c
index 1b9943a..b009e03 100644
--- a/drivers/net/caif/caif_spi_slave.c
+++ b/drivers/net/caif/caif_spi_slave.c
@@ -98,7 +98,7 @@ void cfspi_xfer(struct work_struct *work)
 
 			cfspi_dbg_state(cfspi, CFSPI_STATE_FETCH_PKT);
 
-			/* Copy commited SPI frames after the SPI indication. */
+			/* Copy committed SPI frames after the SPI indication. */
 			ptr = (u8 *) cfspi->xfer.va_tx;
 			ptr += SPI_IND_SZ;
 			len = cfspi_xmitfrm(cfspi, ptr, cfspi->tx_cpck_len);
@@ -158,7 +158,7 @@ void cfspi_xfer(struct work_struct *work)
 
 		cfspi_dbg_state(cfspi, CFSPI_STATE_SIG_ACTIVE);
 
-		/* Signal that we are ready to recieve data. */
+		/* Signal that we are ready to receive data. */
 		cfspi->dev->sig_xfer(true, cfspi->dev);
 
 		cfspi_dbg_state(cfspi, CFSPI_STATE_WAIT_XFER_DONE);
diff --git a/drivers/net/can/at91_can.c b/drivers/net/can/at91_can.c
index 57d2ffb..74efb5a 100644
--- a/drivers/net/can/at91_can.c
+++ b/drivers/net/can/at91_can.c
@@ -416,7 +416,7 @@ static netdev_tx_t at91_start_xmit(struct sk_buff *skb, struct net_device *dev)
 
 	stats->tx_bytes += cf->can_dlc;
 
-	/* _NOTE_: substract AT91_MB_TX_FIRST offset from mb! */
+	/* _NOTE_: subtract AT91_MB_TX_FIRST offset from mb! */
 	can_put_echo_skb(skb, dev, mb - AT91_MB_TX_FIRST);
 
 	/*
@@ -782,7 +782,7 @@ static void at91_irq_tx(struct net_device *dev, u32 reg_sr)
 		reg_msr = at91_read(priv, AT91_MSR(mb));
 		if (likely(reg_msr & AT91_MSR_MRDY &&
 			   ~reg_msr & AT91_MSR_MABT)) {
-			/* _NOTE_: substract AT91_MB_TX_FIRST offset from mb! */
+			/* _NOTE_: subtract AT91_MB_TX_FIRST offset from mb! */
 			can_get_echo_skb(dev, mb - AT91_MB_TX_FIRST);
 			dev->stats.tx_packets++;
 		}
diff --git a/drivers/net/can/c_can/c_can.c b/drivers/net/can/c_can/c_can.c
index 3155295..7e5cc0b 100644
--- a/drivers/net/can/c_can/c_can.c
+++ b/drivers/net/can/c_can/c_can.c
@@ -813,7 +813,7 @@ static int c_can_handle_state_change(struct net_device *dev,
 	struct sk_buff *skb;
 	struct can_berr_counter bec;
 
-	/* propogate the error condition to the CAN stack */
+	/* propagate the error condition to the CAN stack */
 	skb = alloc_can_err_skb(dev, &cf);
 	if (unlikely(!skb))
 		return 0;
@@ -887,7 +887,7 @@ static int c_can_handle_bus_err(struct net_device *dev,
 	if (lec_type == LEC_UNUSED || lec_type == LEC_NO_ERROR)
 		return 0;
 
-	/* propogate the error condition to the CAN stack */
+	/* propagate the error condition to the CAN stack */
 	skb = alloc_can_err_skb(dev, &cf);
 	if (unlikely(!skb))
 		return 0;
diff --git a/drivers/net/can/janz-ican3.c b/drivers/net/can/janz-ican3.c
index 102b16c..587fba4 100644
--- a/drivers/net/can/janz-ican3.c
+++ b/drivers/net/can/janz-ican3.c
@@ -274,7 +274,7 @@ static inline void ican3_set_page(struct ican3_dev *mod, unsigned int page)
  */
 
 /*
- * Recieve a message from the ICAN3 "old-style" firmware interface
+ * Receive a message from the ICAN3 "old-style" firmware interface
  *
  * LOCKING: must hold mod->lock
  *
@@ -1050,7 +1050,7 @@ static void ican3_handle_inquiry(struct ican3_dev *mod, struct ican3_msg *msg)
 		complete(&mod->termination_comp);
 		break;
 	default:
-		dev_err(mod->dev, "recieved an unknown inquiry response\n");
+		dev_err(mod->dev, "received an unknown inquiry response\n");
 		break;
 	}
 }
@@ -1058,7 +1058,7 @@ static void ican3_handle_inquiry(struct ican3_dev *mod, struct ican3_msg *msg)
 static void ican3_handle_unknown_message(struct ican3_dev *mod,
 					struct ican3_msg *msg)
 {
-	dev_warn(mod->dev, "recieved unknown message: spec 0x%.2x length %d\n",
+	dev_warn(mod->dev, "received unknown message: spec 0x%.2x length %d\n",
 			   msg->spec, le16_to_cpu(msg->len));
 }
 
@@ -1113,7 +1113,7 @@ static bool ican3_txok(struct ican3_dev *mod)
 }
 
 /*
- * Recieve one CAN frame from the hardware
+ * Receive one CAN frame from the hardware
  *
  * CONTEXT: must be called from user context
  */
diff --git a/drivers/net/can/mscan/mscan.c b/drivers/net/can/mscan/mscan.c
index 74cd880..92feac6 100644
--- a/drivers/net/can/mscan/mscan.c
+++ b/drivers/net/can/mscan/mscan.c
@@ -246,7 +246,7 @@ static netdev_tx_t mscan_start_xmit(struct sk_buff *skb, struct net_device *dev)
 		out_be16(&regs->tx.idr3_2, can_id);
 
 		can_id >>= 16;
-		/* EFF_FLAGS are inbetween the IDs :( */
+		/* EFF_FLAGS are between the IDs :( */
 		can_id = (can_id & 0x7) | ((can_id << 2) & 0xffe0)
 			 | MSCAN_EFF_FLAGS;
 	} else {
diff --git a/drivers/net/can/sja1000/sja1000.c b/drivers/net/can/sja1000/sja1000.c
index 0a8de01..a358ea9 100644
--- a/drivers/net/can/sja1000/sja1000.c
+++ b/drivers/net/can/sja1000/sja1000.c
@@ -425,7 +425,7 @@ static int sja1000_err(struct net_device *dev, uint8_t isrc, uint8_t status)
 			cf->data[3] = ecc & ECC_SEG;
 			break;
 		}
-		/* Error occured during transmission? */
+		/* Error occurred during transmission? */
 		if ((ecc & ECC_DIR) == 0)
 			cf->data[2] |= CAN_ERR_PROT_TX;
 	}
diff --git a/drivers/net/can/softing/softing.h b/drivers/net/can/softing/softing.h
index 7ec9f4d..afd7d85 100644
--- a/drivers/net/can/softing/softing.h
+++ b/drivers/net/can/softing/softing.h
@@ -22,7 +22,7 @@ struct softing_priv {
 	struct softing *card;
 	struct {
 		int pending;
-		/* variables wich hold the circular buffer */
+		/* variables which hold the circular buffer */
 		int echo_put;
 		int echo_get;
 	} tx;
diff --git a/drivers/net/can/softing/softing_main.c b/drivers/net/can/softing/softing_main.c
index aeea9f9..7a70709 100644
--- a/drivers/net/can/softing/softing_main.c
+++ b/drivers/net/can/softing/softing_main.c
@@ -218,7 +218,7 @@ static int softing_handle_1(struct softing *card)
 	ptr = buf;
 	cmd = *ptr++;
 	if (cmd == 0xff)
-		/* not quite usefull, probably the card has got out */
+		/* not quite useful, probably the card has got out */
 		return 0;
 	netdev = card->net[0];
 	if (cmd & CMD_BUS2)
diff --git a/drivers/net/can/ti_hecc.c b/drivers/net/can/ti_hecc.c
index 4d07f1e..f7bbde9 100644
--- a/drivers/net/can/ti_hecc.c
+++ b/drivers/net/can/ti_hecc.c
@@ -663,7 +663,7 @@ static int ti_hecc_error(struct net_device *ndev, int int_status,
 	struct can_frame *cf;
 	struct sk_buff *skb;
 
-	/* propogate the error condition to the can stack */
+	/* propagate the error condition to the can stack */
 	skb = alloc_can_err_skb(ndev, &cf);
 	if (!skb) {
 		if (printk_ratelimit())
diff --git a/drivers/net/can/usb/ems_usb.c b/drivers/net/can/usb/ems_usb.c
index e75f1a8..a72c7bf 100644
--- a/drivers/net/can/usb/ems_usb.c
+++ b/drivers/net/can/usb/ems_usb.c
@@ -386,7 +386,7 @@ static void ems_usb_rx_err(struct ems_usb *dev, struct ems_cpc_msg *msg)
 			break;
 		}
 
-		/* Error occured during transmission? */
+		/* Error occurred during transmission? */
 		if ((ecc & SJA1000_ECC_DIR) == 0)
 			cf->data[2] |= CAN_ERR_PROT_TX;
 
diff --git a/drivers/net/can/usb/esd_usb2.c b/drivers/net/can/usb/esd_usb2.c
index dc53c83..eb8b0e6 100644
--- a/drivers/net/can/usb/esd_usb2.c
+++ b/drivers/net/can/usb/esd_usb2.c
@@ -284,7 +284,7 @@ static void esd_usb2_rx_event(struct esd_usb2_net_priv *priv,
 				break;
 			}
 
-			/* Error occured during transmission? */
+			/* Error occurred during transmission? */
 			if (!(ecc & SJA1000_ECC_DIR))
 				cf->data[2] |= CAN_ERR_PROT_TX;
 
diff --git a/drivers/net/cassini.c b/drivers/net/cassini.c
index 3437613..143a28c 100644
--- a/drivers/net/cassini.c
+++ b/drivers/net/cassini.c
@@ -51,7 +51,7 @@
  * TX has 4 queues. currently these queues are used in a round-robin
  * fashion for load balancing. They can also be used for QoS. for that
  * to work, however, QoS information needs to be exposed down to the driver
- * level so that subqueues get targetted to particular transmit rings.
+ * level so that subqueues get targeted to particular transmit rings.
  * alternatively, the queues can be configured via use of the all-purpose
  * ioctl.
  *
@@ -5165,7 +5165,7 @@ err_out_free_res:
 	pci_release_regions(pdev);
 
 err_write_cacheline:
-	/* Try to restore it in case the error occured after we
+	/* Try to restore it in case the error occurred after we
 	 * set it.
 	 */
 	pci_write_config_byte(pdev, PCI_CACHE_LINE_SIZE, orig_cacheline_size);
diff --git a/drivers/net/cassini.h b/drivers/net/cassini.h
index faf4746..b361424 100644
--- a/drivers/net/cassini.h
+++ b/drivers/net/cassini.h
@@ -772,7 +772,7 @@
 #define    RX_DEBUG_INTR_WRITE_PTR_MASK    0xC0000000 /* interrupt write pointer
 							 of the interrupt queue */
 
-/* flow control frames are emmitted using two PAUSE thresholds:
+/* flow control frames are emitted using two PAUSE thresholds:
  * XOFF PAUSE uses pause time value pre-programmed in the Send PAUSE MAC reg
  * XON PAUSE uses a pause time of 0. granularity of threshold is 64bytes.
  * PAUSE thresholds defined in terms of FIFO occupancy and may be translated
diff --git a/drivers/net/chelsio/mv88e1xxx.c b/drivers/net/chelsio/mv88e1xxx.c
index 809047a..71018a4 100644
--- a/drivers/net/chelsio/mv88e1xxx.c
+++ b/drivers/net/chelsio/mv88e1xxx.c
@@ -41,7 +41,7 @@ static void mdio_clear_bit(struct cphy *cphy, int reg, u32 bitval)
  *
  * PARAMS: cphy     - Pointer to PHY instance data.
  *
- * RETURN:  0 - Successfull reset.
+ * RETURN:  0 - Successful reset.
  *         -1 - Timeout.
  */
 static int mv88e1xxx_reset(struct cphy *cphy, int wait)
diff --git a/drivers/net/chelsio/pm3393.c b/drivers/net/chelsio/pm3393.c
index 7dbb16d..40c7b93 100644
--- a/drivers/net/chelsio/pm3393.c
+++ b/drivers/net/chelsio/pm3393.c
@@ -293,7 +293,7 @@ static int pm3393_enable_port(struct cmac *cmac, int which)
 	pm3393_enable(cmac, which);
 
 	/*
-	 * XXX This should be done by the PHY and preferrably not at all.
+	 * XXX This should be done by the PHY and preferably not at all.
 	 * The PHY doesn't give us link status indication on its own so have
 	 * the link management code query it instead.
 	 */
diff --git a/drivers/net/chelsio/sge.c b/drivers/net/chelsio/sge.c
index f778b15..8754d44 100644
--- a/drivers/net/chelsio/sge.c
+++ b/drivers/net/chelsio/sge.c
@@ -1662,7 +1662,7 @@ irqreturn_t t1_interrupt(int irq, void *data)
  * The code figures out how many entries the sk_buff will require in the
  * cmdQ and updates the cmdQ data structure with the state once the enqueue
  * has complete. Then, it doesn't access the global structure anymore, but
- * uses the corresponding fields on the stack. In conjuction with a spinlock
+ * uses the corresponding fields on the stack. In conjunction with a spinlock
  * around that code, we can make the function reentrant without holding the
  * lock when we actually enqueue (which might be expensive, especially on
  * architectures with IO MMUs).
diff --git a/drivers/net/chelsio/vsc7326.c b/drivers/net/chelsio/vsc7326.c
index 106a590..b0cb388 100644
--- a/drivers/net/chelsio/vsc7326.c
+++ b/drivers/net/chelsio/vsc7326.c
@@ -566,7 +566,7 @@ static int mac_disable(struct cmac *mac, int which)
 	for (i = 0; i <= 0x3a; ++i)
 		vsc_write(mac->adapter, CRA(4, port, i), 0);
 
-	/* Clear sofware counters */
+	/* Clear software counters */
 	memset(&mac->stats, 0, sizeof(struct cmac_statistics));
 
 	return 0;
diff --git a/drivers/net/cris/eth_v10.c b/drivers/net/cris/eth_v10.c
index 80c2fee..9d267d3 100644
--- a/drivers/net/cris/eth_v10.c
+++ b/drivers/net/cris/eth_v10.c
@@ -1383,7 +1383,7 @@ e100_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
 	spin_lock(&np->lock); /* Preempt protection */
 	switch (cmd) {
 		/* The ioctls below should be considered obsolete but are */
-		/* still present for compatability with old scripts/apps  */
+		/* still present for compatibility with old scripts/apps  */
 		case SET_ETH_SPEED_10:                  /* 10 Mbps */
 			e100_set_speed(dev, 10);
 			break;
diff --git a/drivers/net/cxgb3/sge.c b/drivers/net/cxgb3/sge.c
index f9f6645..bfa2d56 100644
--- a/drivers/net/cxgb3/sge.c
+++ b/drivers/net/cxgb3/sge.c
@@ -199,7 +199,7 @@ static inline void refill_rspq(struct adapter *adapter,
  *	need_skb_unmap - does the platform need unmapping of sk_buffs?
  *
  *	Returns true if the platform needs sk_buff unmapping.  The compiler
- *	optimizes away unecessary code if this returns true.
+ *	optimizes away unnecessary code if this returns true.
  */
 static inline int need_skb_unmap(void)
 {
diff --git a/drivers/net/cxgb3/t3_hw.c b/drivers/net/cxgb3/t3_hw.c
index d55db6b..c688421 100644
--- a/drivers/net/cxgb3/t3_hw.c
+++ b/drivers/net/cxgb3/t3_hw.c
@@ -1386,11 +1386,11 @@ struct intr_info {
  *	@reg: the interrupt status register to process
  *	@mask: a mask to apply to the interrupt status
  *	@acts: table of interrupt actions
- *	@stats: statistics counters tracking interrupt occurences
+ *	@stats: statistics counters tracking interrupt occurrences
  *
  *	A table driven interrupt handler that applies a set of masks to an
  *	interrupt status word and performs the corresponding actions if the
- *	interrupts described by the mask have occured.  The actions include
+ *	interrupts described by the mask have occurred.  The actions include
  *	optionally printing a warning or alert message, and optionally
  *	incrementing a stat counter.  The table is terminated by an entry
  *	specifying mask 0.  Returns the number of fatal interrupt conditions.
@@ -2783,7 +2783,7 @@ static void init_mtus(unsigned short mtus[])
 {
 	/*
 	 * See draft-mathis-plpmtud-00.txt for the values.  The min is 88 so
-	 * it can accomodate max size TCP/IP headers when SACK and timestamps
+	 * it can accommodate max size TCP/IP headers when SACK and timestamps
 	 * are enabled and still have at least 8 bytes of payload.
 	 */
 	mtus[0] = 88;
diff --git a/drivers/net/cxgb4/t4_hw.c b/drivers/net/cxgb4/t4_hw.c
index b9fd8a6..d1ec111 100644
--- a/drivers/net/cxgb4/t4_hw.c
+++ b/drivers/net/cxgb4/t4_hw.c
@@ -883,7 +883,7 @@ struct intr_info {
  *
  *	A table driven interrupt handler that applies a set of masks to an
  *	interrupt status word and performs the corresponding actions if the
- *	interrupts described by the mask have occured.  The actions include
+ *	interrupts described by the mask have occurred.  The actions include
  *	optionally emitting a warning or alert message.  The table is terminated
  *	by an entry specifying mask 0.  Returns the number of fatal interrupt
  *	conditions.
diff --git a/drivers/net/cxgb4vf/cxgb4vf_main.c b/drivers/net/cxgb4vf/cxgb4vf_main.c
index 6aad64d..4661cbb 100644
--- a/drivers/net/cxgb4vf/cxgb4vf_main.c
+++ b/drivers/net/cxgb4vf/cxgb4vf_main.c
@@ -2738,7 +2738,7 @@ static int __devinit cxgb4vf_pci_probe(struct pci_dev *pdev,
 	cfg_queues(adapter);
 
 	/*
-	 * Print a short notice on the existance and configuration of the new
+	 * Print a short notice on the existence and configuration of the new
 	 * VF network device ...
 	 */
 	for_each_port(adapter, pidx) {
diff --git a/drivers/net/cxgb4vf/sge.c b/drivers/net/cxgb4vf/sge.c
index e0b3d1b..bb65121 100644
--- a/drivers/net/cxgb4vf/sge.c
+++ b/drivers/net/cxgb4vf/sge.c
@@ -224,8 +224,8 @@ static inline bool is_buf_mapped(const struct rx_sw_desc *sdesc)
 /**
  *	need_skb_unmap - does the platform need unmapping of sk_buffs?
  *
- *	Returns true if the platfrom needs sk_buff unmapping.  The compiler
- *	optimizes away unecessary code if this returns true.
+ *	Returns true if the platform needs sk_buff unmapping.  The compiler
+ *	optimizes away unnecessary code if this returns true.
  */
 static inline int need_skb_unmap(void)
 {
@@ -267,7 +267,7 @@ static inline unsigned int fl_cap(const struct sge_fl *fl)
  *
  *	Tests specified Free List to see whether the number of buffers
  *	available to the hardware has falled below our "starvation"
- *	threshhold.
+ *	threshold.
  */
 static inline bool fl_starving(const struct sge_fl *fl)
 {
@@ -1149,7 +1149,7 @@ int t4vf_eth_xmit(struct sk_buff *skb, struct net_device *dev)
 	if (unlikely(credits < ETHTXQ_STOP_THRES)) {
 		/*
 		 * After we're done injecting the Work Request for this
-		 * packet, we'll be below our "stop threshhold" so stop the TX
+		 * packet, we'll be below our "stop threshold" so stop the TX
 		 * Queue now and schedule a request for an SGE Egress Queue
 		 * Update message.  The queue will get started later on when
 		 * the firmware processes this Work Request and sends us an
diff --git a/drivers/net/davinci_emac.c b/drivers/net/davinci_emac.c
index baca6bf..807b6bb 100644
--- a/drivers/net/davinci_emac.c
+++ b/drivers/net/davinci_emac.c
@@ -94,14 +94,14 @@ MODULE_VERSION(EMAC_MODULE_VERSION);
 static const char emac_version_string[] = "TI DaVinci EMAC Linux v6.1";
 
 /* Configuration items */
-#define EMAC_DEF_PASS_CRC		(0) /* Do not pass CRC upto frames */
+#define EMAC_DEF_PASS_CRC		(0) /* Do not pass CRC up to frames */
 #define EMAC_DEF_QOS_EN			(0) /* EMAC proprietary QoS disabled */
 #define EMAC_DEF_NO_BUFF_CHAIN		(0) /* No buffer chain */
 #define EMAC_DEF_MACCTRL_FRAME_EN	(0) /* Discard Maccontrol frames */
 #define EMAC_DEF_SHORT_FRAME_EN		(0) /* Discard short frames */
 #define EMAC_DEF_ERROR_FRAME_EN		(0) /* Discard error frames */
-#define EMAC_DEF_PROM_EN		(0) /* Promiscous disabled */
-#define EMAC_DEF_PROM_CH		(0) /* Promiscous channel is 0 */
+#define EMAC_DEF_PROM_EN		(0) /* Promiscuous disabled */
+#define EMAC_DEF_PROM_CH		(0) /* Promiscuous channel is 0 */
 #define EMAC_DEF_BCAST_EN		(1) /* Broadcast enabled */
 #define EMAC_DEF_BCAST_CH		(0) /* Broadcast channel is 0 */
 #define EMAC_DEF_MCAST_EN		(1) /* Multicast enabled */
@@ -1013,7 +1013,7 @@ static void emac_rx_handler(void *token, int len, int status)
 		return;
 	}
 
-	/* recycle on recieve error */
+	/* recycle on receive error */
 	if (status < 0) {
 		ndev->stats.rx_errors++;
 		goto recycle;
diff --git a/drivers/net/e1000/e1000_ethtool.c b/drivers/net/e1000/e1000_ethtool.c
index f4d0922..dd70738 100644
--- a/drivers/net/e1000/e1000_ethtool.c
+++ b/drivers/net/e1000/e1000_ethtool.c
@@ -160,7 +160,7 @@ static int e1000_get_settings(struct net_device *netdev,
 		                                   &adapter->link_duplex);
 		ecmd->speed = adapter->link_speed;
 
-		/* unfortunatly FULL_DUPLEX != DUPLEX_FULL
+		/* unfortunately FULL_DUPLEX != DUPLEX_FULL
 		 *          and HALF_DUPLEX != DUPLEX_HALF */
 
 		if (adapter->link_duplex == FULL_DUPLEX)
diff --git a/drivers/net/e1000/e1000_hw.h b/drivers/net/e1000/e1000_hw.h
index c70b23d..5c9a840 100644
--- a/drivers/net/e1000/e1000_hw.h
+++ b/drivers/net/e1000/e1000_hw.h
@@ -1026,7 +1026,7 @@ extern void __iomem *ce4100_gbe_mdio_base_virt;
 
 #define E1000_KUMCTRLSTA 0x00034	/* MAC-PHY interface - RW */
 #define E1000_MDPHYA     0x0003C	/* PHY address - RW */
-#define E1000_MANC2H     0x05860	/* Managment Control To Host - RW */
+#define E1000_MANC2H     0x05860	/* Management Control To Host - RW */
 #define E1000_SW_FW_SYNC 0x05B5C	/* Software-Firmware Synchronization - RW */
 
 #define E1000_GCR       0x05B00	/* PCI-Ex Control */
diff --git a/drivers/net/e1000/e1000_main.c b/drivers/net/e1000/e1000_main.c
index bfab140..477e066 100644
--- a/drivers/net/e1000/e1000_main.c
+++ b/drivers/net/e1000/e1000_main.c
@@ -205,7 +205,7 @@ static struct pci_driver e1000_driver = {
 	.probe    = e1000_probe,
 	.remove   = __devexit_p(e1000_remove),
 #ifdef CONFIG_PM
-	/* Power Managment Hooks */
+	/* Power Management Hooks */
 	.suspend  = e1000_suspend,
 	.resume   = e1000_resume,
 #endif
diff --git a/drivers/net/e1000e/netdev.c b/drivers/net/e1000e/netdev.c
index a39d4a4..506a0a0 100644
--- a/drivers/net/e1000e/netdev.c
+++ b/drivers/net/e1000e/netdev.c
@@ -4886,7 +4886,7 @@ static netdev_tx_t e1000_xmit_frame(struct sk_buff *skb,
 	if (skb->protocol == htons(ETH_P_IP))
 		tx_flags |= E1000_TX_FLAGS_IPV4;
 
-	/* if count is 0 then mapping error has occured */
+	/* if count is 0 then mapping error has occurred */
 	count = e1000_tx_map(adapter, skb, first, max_per_txd, nr_frags, mss);
 	if (count) {
 		e1000_tx_queue(adapter, tx_flags, count);
diff --git a/drivers/net/enc28j60_hw.h b/drivers/net/enc28j60_hw.h
index 1a0b209..25b41de 100644
--- a/drivers/net/enc28j60_hw.h
+++ b/drivers/net/enc28j60_hw.h
@@ -303,7 +303,7 @@
 /* maximum ethernet frame length */
 #define MAX_FRAMELEN		1518
 
-/* Prefered half duplex: LEDA: Link status LEDB: Rx/Tx activity */
+/* Preferred half duplex: LEDA: Link status LEDB: Rx/Tx activity */
 #define ENC28J60_LAMPS_MODE	0x3476
 
 #endif
diff --git a/drivers/net/eth16i.c b/drivers/net/eth16i.c
index fb717be..12d28e9 100644
--- a/drivers/net/eth16i.c
+++ b/drivers/net/eth16i.c
@@ -13,7 +13,7 @@
    This driver supports following cards :
 	- ICL EtherTeam 16i
 	- ICL EtherTeam 32 EISA
-	  (Uses true 32 bit transfers rather than 16i compability mode)
+	  (Uses true 32 bit transfers rather than 16i compatibility mode)
 
    Example Module usage:
         insmod eth16i.o io=0x2a0 mediatype=bnc
diff --git a/drivers/net/ethoc.c b/drivers/net/ethoc.c
index db0290f..a83dd31 100644
--- a/drivers/net/ethoc.c
+++ b/drivers/net/ethoc.c
@@ -542,7 +542,7 @@ static irqreturn_t ethoc_interrupt(int irq, void *dev_id)
 
 	/* Figure out what triggered the interrupt...
 	 * The tricky bit here is that the interrupt source bits get
-	 * set in INT_SOURCE for an event irregardless of whether that
+	 * set in INT_SOURCE for an event regardless of whether that
 	 * event is masked or not.  Thus, in order to figure out what
 	 * triggered the interrupt, we need to remove the sources
 	 * for all events that are currently masked.  This behaviour
diff --git a/drivers/net/fec.h b/drivers/net/fec.h
index ace318d..8b2c6d7 100644
--- a/drivers/net/fec.h
+++ b/drivers/net/fec.h
@@ -97,11 +97,11 @@ struct bufdesc {
  *	The following definitions courtesy of commproc.h, which where
  *	Copyright (c) 1997 Dan Malek (dmalek@jlc.net).
  */
-#define BD_SC_EMPTY     ((ushort)0x8000)        /* Recieve is empty */
+#define BD_SC_EMPTY     ((ushort)0x8000)        /* Receive is empty */
 #define BD_SC_READY     ((ushort)0x8000)        /* Transmit is ready */
 #define BD_SC_WRAP      ((ushort)0x2000)        /* Last buffer descriptor */
 #define BD_SC_INTRPT    ((ushort)0x1000)        /* Interrupt on change */
-#define BD_SC_CM        ((ushort)0x0200)        /* Continous mode */
+#define BD_SC_CM        ((ushort)0x0200)        /* Continuous mode */
 #define BD_SC_ID        ((ushort)0x0100)        /* Rec'd too many idles */
 #define BD_SC_P         ((ushort)0x0100)        /* xmt preamble */
 #define BD_SC_BR        ((ushort)0x0020)        /* Break received */
diff --git a/drivers/net/forcedeth.c b/drivers/net/forcedeth.c
index 7b92897..d5ab4da 100644
--- a/drivers/net/forcedeth.c
+++ b/drivers/net/forcedeth.c
@@ -440,7 +440,7 @@ union ring_type {
 #define NV_RX3_VLAN_TAG_PRESENT (1<<16)
 #define NV_RX3_VLAN_TAG_MASK	(0x0000FFFF)
 
-/* Miscelaneous hardware related defines: */
+/* Miscellaneous hardware related defines: */
 #define NV_PCI_REGSZ_VER1	0x270
 #define NV_PCI_REGSZ_VER2	0x2d4
 #define NV_PCI_REGSZ_VER3	0x604
@@ -1488,7 +1488,7 @@ static int phy_init(struct net_device *dev)
 		}
 	}
 
-	/* some phys clear out pause advertisment on reset, set it back */
+	/* some phys clear out pause advertisement on reset, set it back */
 	mii_rw(dev, np->phyaddr, MII_ADVERTISE, reg);
 
 	/* restart auto negotiation, power down phy */
@@ -2535,7 +2535,7 @@ static void nv_tx_timeout(struct net_device *dev)
 	else
 		nv_tx_done_optimized(dev, np->tx_ring_size);
 
-	/* save current HW postion */
+	/* save current HW position */
 	if (np->tx_change_owner)
 		put_tx.ex = np->tx_change_owner->first_tx_desc;
 	else
@@ -4053,7 +4053,7 @@ static int nv_set_settings(struct net_device *dev, struct ethtool_cmd *ecmd)
 
 	} else if (ecmd->autoneg == AUTONEG_DISABLE) {
 		/* Note: autonegotiation disable, speed 1000 intentionally
-		 * forbidden - noone should need that. */
+		 * forbidden - no one should need that. */
 
 		if (ecmd->speed != SPEED_10 && ecmd->speed != SPEED_100)
 			return -EINVAL;
@@ -4103,7 +4103,7 @@ static int nv_set_settings(struct net_device *dev, struct ethtool_cmd *ecmd)
 			adv |= ADVERTISE_100HALF;
 		if (ecmd->advertising & ADVERTISED_100baseT_Full)
 			adv |= ADVERTISE_100FULL;
-		if (np->pause_flags & NV_PAUSEFRAME_RX_REQ)  /* for rx we set both advertisments but disable tx pause */
+		if (np->pause_flags & NV_PAUSEFRAME_RX_REQ)  /* for rx we set both advertisements but disable tx pause */
 			adv |=  ADVERTISE_PAUSE_CAP | ADVERTISE_PAUSE_ASYM;
 		if (np->pause_flags & NV_PAUSEFRAME_TX_REQ)
 			adv |=  ADVERTISE_PAUSE_ASYM;
@@ -4148,7 +4148,7 @@ static int nv_set_settings(struct net_device *dev, struct ethtool_cmd *ecmd)
 		if (ecmd->speed == SPEED_100 && ecmd->duplex == DUPLEX_FULL)
 			adv |= ADVERTISE_100FULL;
 		np->pause_flags &= ~(NV_PAUSEFRAME_AUTONEG|NV_PAUSEFRAME_RX_ENABLE|NV_PAUSEFRAME_TX_ENABLE);
-		if (np->pause_flags & NV_PAUSEFRAME_RX_REQ) {/* for rx we set both advertisments but disable tx pause */
+		if (np->pause_flags & NV_PAUSEFRAME_RX_REQ) {/* for rx we set both advertisements but disable tx pause */
 			adv |=  ADVERTISE_PAUSE_CAP | ADVERTISE_PAUSE_ASYM;
 			np->pause_flags |= NV_PAUSEFRAME_RX_ENABLE;
 		}
@@ -4449,7 +4449,7 @@ static int nv_set_pauseparam(struct net_device *dev, struct ethtool_pauseparam*
 
 		adv = mii_rw(dev, np->phyaddr, MII_ADVERTISE, MII_READ);
 		adv &= ~(ADVERTISE_PAUSE_CAP | ADVERTISE_PAUSE_ASYM);
-		if (np->pause_flags & NV_PAUSEFRAME_RX_REQ) /* for rx we set both advertisments but disable tx pause */
+		if (np->pause_flags & NV_PAUSEFRAME_RX_REQ) /* for rx we set both advertisements but disable tx pause */
 			adv |=  ADVERTISE_PAUSE_CAP | ADVERTISE_PAUSE_ASYM;
 		if (np->pause_flags & NV_PAUSEFRAME_TX_REQ)
 			adv |=  ADVERTISE_PAUSE_ASYM;
diff --git a/drivers/net/gianfar.h b/drivers/net/gianfar.h
index ec5d595..b2fe7ed 100644
--- a/drivers/net/gianfar.h
+++ b/drivers/net/gianfar.h
@@ -1043,7 +1043,7 @@ enum gfar_errata {
 };
 
 /* Struct stolen almost completely (and shamelessly) from the FCC enet source
- * (Ok, that's not so true anymore, but there is a family resemblence)
+ * (Ok, that's not so true anymore, but there is a family resemblance)
  * The GFAR buffer descriptors track the ring buffers.  The rx_bd_base
  * and tx_bd_base always point to the currently available buffer.
  * The dirty_tx tracks the current buffer that is being sent by the
diff --git a/drivers/net/hamradio/Makefile b/drivers/net/hamradio/Makefile
index 9def867..1040960 100644
--- a/drivers/net/hamradio/Makefile
+++ b/drivers/net/hamradio/Makefile
@@ -3,7 +3,7 @@
 #
 #
 # 19971130 	Moved the amateur radio related network drivers from 
-#		drivers/net/ to drivers/hamradio for easier maintainance.
+#		drivers/net/ to drivers/hamradio for easier maintenance.
 #               Joerg Reuter DL1BKE <jreuter@yaina.de>
 #
 # 20000806	Rewritten to use lists instead of if-statements.
diff --git a/drivers/net/hamradio/yam.c b/drivers/net/hamradio/yam.c
index 7d9ced0..96a98d2 100644
--- a/drivers/net/hamradio/yam.c
+++ b/drivers/net/hamradio/yam.c
@@ -30,7 +30,7 @@
  *   0.1 F1OAT 07.06.98  Add timer polling routine for channel arbitration
  *   0.2 F6FBB 08.06.98  Added delay after FPGA programming
  *   0.3 F6FBB 29.07.98  Delayed PTT implementation for dupmode=2
- *   0.4 F6FBB 30.07.98  Added TxTail, Slottime and Persistance
+ *   0.4 F6FBB 30.07.98  Added TxTail, Slottime and Persistence
  *   0.5 F6FBB 01.08.98  Shared IRQs, /proc/net and network statistics
  *   0.6 F6FBB 25.08.98  Added 1200Bds format
  *   0.7 F6FBB 12.09.98  Added to the kernel configuration
diff --git a/drivers/net/hp100.c b/drivers/net/hp100.c
index 8e2c460..8e10d2f 100644
--- a/drivers/net/hp100.c
+++ b/drivers/net/hp100.c
@@ -180,8 +180,8 @@ struct hp100_private {
 
 	u_int *page_vaddr_algn;	/* Aligned virtual address of allocated page */
 	u_long whatever_offset;	/* Offset to bus/phys/dma address */
-	int rxrcommit;		/* # Rx PDLs commited to adapter */
-	int txrcommit;		/* # Tx PDLs commited to adapter */
+	int rxrcommit;		/* # Rx PDLs committed to adapter */
+	int txrcommit;		/* # Tx PDLs committed to adapter */
 };
 
 /*
@@ -716,7 +716,7 @@ static int __devinit hp100_probe1(struct net_device *dev, int ioaddr,
 	 * implemented/tested only with the lassen chip anyway... */
 	if (lp->mode == 1) {	/* busmaster */
 		dma_addr_t page_baddr;
-		/* Get physically continous memory for TX & RX PDLs    */
+		/* Get physically continuous memory for TX & RX PDLs    */
 		/* Conversion to new PCI API :
 		 * Pages are always aligned and zeroed, no need to it ourself.
 		 * Doc says should be OK for EISA bus as well - Jean II */
@@ -1596,7 +1596,7 @@ drop:
 
 /* clean_txring checks if packets have been sent by the card by reading
  * the TX_PDL register from the performance page and comparing it to the
- * number of commited packets. It then frees the skb's of the packets that
+ * number of committed packets. It then frees the skb's of the packets that
  * obviously have been sent to the network.
  *
  * Needs the PERFORMANCE page selected.
@@ -1617,7 +1617,7 @@ static void hp100_clean_txring(struct net_device *dev)
 
 #ifdef HP100_DEBUG
 	if (donecount > MAX_TX_PDL)
-		printk("hp100: %s: Warning: More PDLs transmitted than commited to card???\n", dev->name);
+		printk("hp100: %s: Warning: More PDLs transmitted than committed to card???\n", dev->name);
 #endif
 
 	for (; 0 != donecount; donecount--) {
@@ -1765,7 +1765,7 @@ drop:
  * Receive Function (Non-Busmaster mode)
  * Called when an "Receive Packet" interrupt occurs, i.e. the receive
  * packet counter is non-zero.
- * For non-busmaster, this function does the whole work of transfering
+ * For non-busmaster, this function does the whole work of transferring
  * the packet to the host memory and then up to higher layers via skb
  * and netif_rx.
  */
@@ -1892,7 +1892,7 @@ static void hp100_rx_bm(struct net_device *dev)
 		/* RX_PKT_CNT states how many PDLs are currently formatted and available to
 		 * the cards BM engine */
 	if ((hp100_inw(RX_PKT_CNT) & 0x00ff) >= lp->rxrcommit) {
-		printk("hp100: %s: More packets received than commited? RX_PKT_CNT=0x%x, commit=0x%x\n",
+		printk("hp100: %s: More packets received than committed? RX_PKT_CNT=0x%x, commit=0x%x\n",
 				     dev->name, hp100_inw(RX_PKT_CNT) & 0x00ff,
 				     lp->rxrcommit);
 		return;
@@ -2256,7 +2256,7 @@ static irqreturn_t hp100_interrupt(int irq, void *dev_id)
 		if (lp->mode != 1)	/* non busmaster */
 			hp100_rx(dev);
 		else if (!(val & HP100_RX_PDL_FILL_COMPL)) {
-			/* Shouldnt happen - maybe we missed a RX_PDL_FILL Interrupt?  */
+			/* Shouldn't happen - maybe we missed a RX_PDL_FILL Interrupt?  */
 			hp100_rx_bm(dev);
 		}
 	}
diff --git a/drivers/net/hp100.h b/drivers/net/hp100.h
index e6ca128..b60e96f 100644
--- a/drivers/net/hp100.h
+++ b/drivers/net/hp100.h
@@ -109,7 +109,7 @@
 #define HP100_REG_MAC_CFG_2	0x0d	/* RW: (8) Misc MAC functions        */
 #define HP100_REG_MAC_CFG_3     0x0e	/* RW: (8) Misc MAC functions */
 #define HP100_REG_MAC_CFG_4     0x0f	/* R:  (8) Misc MAC states */
-#define HP100_REG_DROPPED	0x10	/* R:  (16),11:0 Pkts cant fit in mem */
+#define HP100_REG_DROPPED	0x10	/* R:  (16),11:0 Pkts can't fit in mem */
 #define HP100_REG_CRC		0x12	/* R:  (8) Pkts with CRC             */
 #define HP100_REG_ABORT		0x13	/* R:  (8) Aborted Tx pkts           */
 #define HP100_REG_TRAIN_REQUEST 0x14	/* RW: (16) Endnode MAC register. */
diff --git a/drivers/net/ibm_newemac/tah.c b/drivers/net/ibm_newemac/tah.c
index 8ead6a9..5f51bf7 100644
--- a/drivers/net/ibm_newemac/tah.c
+++ b/drivers/net/ibm_newemac/tah.c
@@ -60,7 +60,7 @@ void tah_reset(struct platform_device *ofdev)
 		printk(KERN_ERR "%s: reset timeout\n",
 			ofdev->dev.of_node->full_name);
 
-	/* 10KB TAH TX FIFO accomodates the max MTU of 9000 */
+	/* 10KB TAH TX FIFO accommodates the max MTU of 9000 */
 	out_be32(&p->mr,
 		 TAH_MR_CVR | TAH_MR_ST_768 | TAH_MR_TFS_10KB | TAH_MR_DTFP |
 		 TAH_MR_DIG);
diff --git a/drivers/net/ibmlana.c b/drivers/net/ibmlana.c
index 94d9969..8ff68ae 100644
--- a/drivers/net/ibmlana.c
+++ b/drivers/net/ibmlana.c
@@ -53,7 +53,7 @@ History:
 	still work with 2.0.x....
   Jan 28th, 2000
 	in Linux 2.2.13, the version.h file mysteriously didn't get
-	included.  Added a workaround for this.  Futhermore, it now
+	included.  Added a workaround for this.  Furthermore, it now
 	not only compiles as a modules ;-)
   Jan 30th, 2000
 	newer kernels automatically probe more than one board, so the
@@ -481,7 +481,7 @@ static void InitBoard(struct net_device *dev)
 	if ((dev->flags & IFF_ALLMULTI) || netdev_mc_count(dev) > camcnt)
 		rcrval |= RCREG_AMC;
 
-	/* promiscous mode ? */
+	/* promiscuous mode ? */
 
 	if (dev->flags & IFF_PROMISC)
 		rcrval |= RCREG_PRO;
diff --git a/drivers/net/ibmlana.h b/drivers/net/ibmlana.h
index aa3ddbd..accd5ef 100644
--- a/drivers/net/ibmlana.h
+++ b/drivers/net/ibmlana.h
@@ -90,7 +90,7 @@ typedef struct {
 #define RCREG_ERR        0x8000	/* accept damaged and collided pkts */
 #define RCREG_RNT        0x4000	/* accept packets that are < 64     */
 #define RCREG_BRD        0x2000	/* accept broadcasts                */
-#define RCREG_PRO        0x1000	/* promiscous mode                  */
+#define RCREG_PRO        0x1000	/* promiscuous mode                  */
 #define RCREG_AMC        0x0800	/* accept all multicasts            */
 #define RCREG_LB_NONE    0x0000	/* no loopback                      */
 #define RCREG_LB_MAC     0x0200	/* MAC loopback                     */
diff --git a/drivers/net/igb/e1000_mac.c b/drivers/net/igb/e1000_mac.c
index 90c5e01..ce8255f 100644
--- a/drivers/net/igb/e1000_mac.c
+++ b/drivers/net/igb/e1000_mac.c
@@ -181,7 +181,7 @@ s32 igb_vfta_set(struct e1000_hw *hw, u32 vid, bool add)
  *  address and must override the actual permanent MAC address.  If an
  *  alternate MAC address is fopund it is saved in the hw struct and
  *  prgrammed into RAR0 and the cuntion returns success, otherwise the
- *  fucntion returns an error.
+ *  function returns an error.
  **/
 s32 igb_check_alt_mac_addr(struct e1000_hw *hw)
 {
@@ -982,7 +982,7 @@ out:
 }
 
 /**
- *  igb_get_speed_and_duplex_copper - Retreive current speed/duplex
+ *  igb_get_speed_and_duplex_copper - Retrieve current speed/duplex
  *  @hw: pointer to the HW structure
  *  @speed: stores the current speed
  *  @duplex: stores the current duplex
diff --git a/drivers/net/igb/e1000_phy.c b/drivers/net/igb/e1000_phy.c
index 6694bf3..d639706 100644
--- a/drivers/net/igb/e1000_phy.c
+++ b/drivers/net/igb/e1000_phy.c
@@ -1421,7 +1421,7 @@ out:
 }
 
 /**
- *  igb_check_downshift - Checks whether a downshift in speed occured
+ *  igb_check_downshift - Checks whether a downshift in speed occurred
  *  @hw: pointer to the HW structure
  *
  *  Success returns 0, Failure returns 1
diff --git a/drivers/net/igb/igb_main.c b/drivers/net/igb/igb_main.c
index 3d850af..0dfd1b9 100644
--- a/drivers/net/igb/igb_main.c
+++ b/drivers/net/igb/igb_main.c
@@ -200,7 +200,7 @@ static struct pci_driver igb_driver = {
 	.probe    = igb_probe,
 	.remove   = __devexit_p(igb_remove),
 #ifdef CONFIG_PM
-	/* Power Managment Hooks */
+	/* Power Management Hooks */
 	.suspend  = igb_suspend,
 	.resume   = igb_resume,
 #endif
@@ -2292,7 +2292,7 @@ static void igb_init_hw_timer(struct igb_adapter *adapter)
 		/**
 		 * Scale the NIC clock cycle by a large factor so that
 		 * relatively small clock corrections can be added or
-		 * substracted at each clock tick. The drawbacks of a large
+		 * subtracted at each clock tick. The drawbacks of a large
 		 * factor are a) that the clock register overflows more quickly
 		 * (not such a big deal) and b) that the increment per tick has
 		 * to fit into 24 bits.  As a result we need to use a shift of
@@ -3409,7 +3409,7 @@ static void igb_set_rx_mode(struct net_device *netdev)
 		} else {
 			/*
 			 * Write addresses to the MTA, if the attempt fails
-			 * then we should just turn on promiscous mode so
+			 * then we should just turn on promiscuous mode so
 			 * that we can at least receive multicast traffic
 			 */
 			count = igb_write_mc_addr_list(netdev);
@@ -3423,7 +3423,7 @@ static void igb_set_rx_mode(struct net_device *netdev)
 		/*
 		 * Write addresses to available RAR registers, if there is not
 		 * sufficient space to store all the addresses then enable
-		 * unicast promiscous mode
+		 * unicast promiscuous mode
 		 */
 		count = igb_write_uc_addr_list(netdev);
 		if (count < 0) {
@@ -4317,7 +4317,7 @@ netdev_tx_t igb_xmit_frame_ring_adv(struct sk_buff *skb,
 
 	/*
 	 * count reflects descriptors mapped, if 0 or less then mapping error
-	 * has occured and we need to rewind the descriptor queue
+	 * has occurred and we need to rewind the descriptor queue
 	 */
 	count = igb_tx_map_adv(tx_ring, skb, first);
 	if (!count) {
@@ -5352,8 +5352,8 @@ static void igb_msg_task(struct igb_adapter *adapter)
  *  The unicast table address is a register array of 32-bit registers.
  *  The table is meant to be used in a way similar to how the MTA is used
  *  however due to certain limitations in the hardware it is necessary to
- *  set all the hash bits to 1 and use the VMOLR ROPE bit as a promiscous
- *  enable bit to allow vlan tag stripping when promiscous mode is enabled
+ *  set all the hash bits to 1 and use the VMOLR ROPE bit as a promiscuous
+ *  enable bit to allow vlan tag stripping when promiscuous mode is enabled
  **/
 static void igb_set_uta(struct igb_adapter *adapter)
 {
diff --git a/drivers/net/igbvf/netdev.c b/drivers/net/igbvf/netdev.c
index 6ccc32f..1d04ca6 100644
--- a/drivers/net/igbvf/netdev.c
+++ b/drivers/net/igbvf/netdev.c
@@ -2227,7 +2227,7 @@ static netdev_tx_t igbvf_xmit_frame_ring_adv(struct sk_buff *skb,
 
 	/*
 	 * count reflects descriptors mapped, if 0 then mapping error
-	 * has occured and we need to rewind the descriptor queue
+	 * has occurred and we need to rewind the descriptor queue
 	 */
 	count = igbvf_tx_map_adv(adapter, tx_ring, skb, first);
 
diff --git a/drivers/net/ipg.c b/drivers/net/ipg.c
index a5b0f0e..58cd320 100644
--- a/drivers/net/ipg.c
+++ b/drivers/net/ipg.c
@@ -486,14 +486,14 @@ static int ipg_config_autoneg(struct net_device *dev)
 	phyctrl = ipg_r8(PHY_CTRL);
 	mac_ctrl_val = ipg_r32(MAC_CTRL);
 
-	/* Set flags for use in resolving auto-negotation, assuming
+	/* Set flags for use in resolving auto-negotiation, assuming
 	 * non-1000Mbps, half duplex, no flow control.
 	 */
 	fullduplex = 0;
 	txflowcontrol = 0;
 	rxflowcontrol = 0;
 
-	/* To accomodate a problem in 10Mbps operation,
+	/* To accommodate a problem in 10Mbps operation,
 	 * set a global flag if PHY running in 10Mbps mode.
 	 */
 	sp->tenmbpsmode = 0;
@@ -846,7 +846,7 @@ static void init_tfdlist(struct net_device *dev)
 }
 
 /*
- * Free all transmit buffers which have already been transfered
+ * Free all transmit buffers which have already been transferred
  * via DMA to the IPG.
  */
 static void ipg_nic_txfree(struct net_device *dev)
@@ -920,7 +920,7 @@ static void ipg_tx_timeout(struct net_device *dev)
 
 /*
  * For TxComplete interrupts, free all transmit
- * buffers which have already been transfered via DMA
+ * buffers which have already been transferred via DMA
  * to the IPG.
  */
 static void ipg_nic_txcleanup(struct net_device *dev)
@@ -1141,13 +1141,13 @@ static int ipg_nic_rx_check_error(struct net_device *dev)
 
 		/* Increment detailed receive error statistics. */
 		if (le64_to_cpu(rxfd->rfs) & IPG_RFS_RXFIFOOVERRUN) {
-			IPG_DEBUG_MSG("RX FIFO overrun occured.\n");
+			IPG_DEBUG_MSG("RX FIFO overrun occurred.\n");
 
 			sp->stats.rx_fifo_errors++;
 		}
 
 		if (le64_to_cpu(rxfd->rfs) & IPG_RFS_RXRUNTFRAME) {
-			IPG_DEBUG_MSG("RX runt occured.\n");
+			IPG_DEBUG_MSG("RX runt occurred.\n");
 			sp->stats.rx_length_errors++;
 		}
 
@@ -1156,7 +1156,7 @@ static int ipg_nic_rx_check_error(struct net_device *dev)
 		 */
 
 		if (le64_to_cpu(rxfd->rfs) & IPG_RFS_RXALIGNMENTERROR) {
-			IPG_DEBUG_MSG("RX alignment error occured.\n");
+			IPG_DEBUG_MSG("RX alignment error occurred.\n");
 			sp->stats.rx_frame_errors++;
 		}
 
@@ -1421,12 +1421,12 @@ static int ipg_nic_rx(struct net_device *dev)
 
 			/* Increment detailed receive error statistics. */
 			if (le64_to_cpu(rxfd->rfs) & IPG_RFS_RXFIFOOVERRUN) {
-				IPG_DEBUG_MSG("RX FIFO overrun occured.\n");
+				IPG_DEBUG_MSG("RX FIFO overrun occurred.\n");
 				sp->stats.rx_fifo_errors++;
 			}
 
 			if (le64_to_cpu(rxfd->rfs) & IPG_RFS_RXRUNTFRAME) {
-				IPG_DEBUG_MSG("RX runt occured.\n");
+				IPG_DEBUG_MSG("RX runt occurred.\n");
 				sp->stats.rx_length_errors++;
 			}
 
@@ -1436,7 +1436,7 @@ static int ipg_nic_rx(struct net_device *dev)
 			 */
 
 			if (le64_to_cpu(rxfd->rfs) & IPG_RFS_RXALIGNMENTERROR) {
-				IPG_DEBUG_MSG("RX alignment error occured.\n");
+				IPG_DEBUG_MSG("RX alignment error occurred.\n");
 				sp->stats.rx_frame_errors++;
 			}
 
@@ -1460,7 +1460,7 @@ static int ipg_nic_rx(struct net_device *dev)
 			}
 		} else {
 
-			/* Adjust the new buffer length to accomodate the size
+			/* Adjust the new buffer length to accommodate the size
 			 * of the received frame.
 			 */
 			skb_put(skb, framelen);
@@ -1488,7 +1488,7 @@ static int ipg_nic_rx(struct net_device *dev)
 	}
 
 	/*
-	 * If there are more RFDs to proces and the allocated amount of RFD
+	 * If there are more RFDs to process and the allocated amount of RFD
 	 * processing time has expired, assert Interrupt Requested to make
 	 * sure we come back to process the remaining RFDs.
 	 */
@@ -1886,7 +1886,7 @@ static netdev_tx_t ipg_nic_hard_start_xmit(struct sk_buff *skb,
 	/* Request TxComplete interrupts at an interval defined
 	 * by the constant IPG_FRAMESBETWEENTXCOMPLETES.
 	 * Request TxComplete interrupt for every frame
-	 * if in 10Mbps mode to accomodate problem with 10Mbps
+	 * if in 10Mbps mode to accommodate problem with 10Mbps
 	 * processing.
 	 */
 	if (sp->tenmbpsmode)
@@ -2098,7 +2098,7 @@ static int ipg_nic_change_mtu(struct net_device *dev, int new_mtu)
 	struct ipg_nic_private *sp = netdev_priv(dev);
 	int err;
 
-	/* Function to accomodate changes to Maximum Transfer Unit
+	/* Function to accommodate changes to Maximum Transfer Unit
 	 * (or MTU) of IPG NIC. Cannot use default function since
 	 * the default will not allow for MTU > 1500 bytes.
 	 */
diff --git a/drivers/net/irda/ali-ircc.c b/drivers/net/irda/ali-ircc.c
index 92631eb..872183f 100644
--- a/drivers/net/irda/ali-ircc.c
+++ b/drivers/net/irda/ali-ircc.c
@@ -76,7 +76,7 @@ static int  ali_ircc_probe_53(ali_chip_t *chip, chipio_t *info);
 static int  ali_ircc_init_43(ali_chip_t *chip, chipio_t *info);
 static int  ali_ircc_init_53(ali_chip_t *chip, chipio_t *info);
 
-/* These are the currently known ALi sourth-bridge chipsets, the only one difference
+/* These are the currently known ALi south-bridge chipsets, the only one difference
  * is that M1543C doesn't support HP HDSL-3600
  */
 static ali_chip_t chips[] =
@@ -1108,7 +1108,7 @@ static void ali_ircc_sir_change_speed(struct ali_ircc_cb *priv, __u32 speed)
 	outb(lcr,		  iobase+UART_LCR); /* Set 8N1	*/
 	outb(fcr,		  iobase+UART_FCR); /* Enable FIFO's */
 
-	/* without this, the conection will be broken after come back from FIR speed,
+	/* without this, the connection will be broken after come back from FIR speed,
 	   but with this, the SIR connection is harder to established */
 	outb((UART_MCR_DTR | UART_MCR_RTS | UART_MCR_OUT2), iobase+UART_MCR);
 	
diff --git a/drivers/net/irda/donauboe.c b/drivers/net/irda/donauboe.c
index f81d944..174cafa 100644
--- a/drivers/net/irda/donauboe.c
+++ b/drivers/net/irda/donauboe.c
@@ -56,7 +56,7 @@
 /* do_probe module parameter Enable this code */
 /* Probe code is very useful for understanding how the hardware works */
 /* Use it with various combinations of TT_LEN, RX_LEN */
-/* Strongly recomended, disable if the probe fails on your machine */
+/* Strongly recommended, disable if the probe fails on your machine */
 /* and send me <james@fishsoup.dhs.org> the output of dmesg */
 #define USE_PROBE 1
 #undef  USE_PROBE
diff --git a/drivers/net/irda/donauboe.h b/drivers/net/irda/donauboe.h
index 77fcf44..d92d54e 100644
--- a/drivers/net/irda/donauboe.h
+++ b/drivers/net/irda/donauboe.h
@@ -51,7 +51,7 @@
 
 /* The documentation for this chip is allegedly released         */
 /* However I have not seen it, not have I managed to contact     */
-/* anyone who has. HOWEVER the chip bears a striking resemblence */
+/* anyone who has. HOWEVER the chip bears a striking resemblance */
 /* to the IrDA controller in the Toshiba RISC TMPR3922 chip      */
 /* the documentation for this is freely available at             */
 /* http://www.madingley.org/james/resources/toshoboe/TMPR3922.pdf */
diff --git a/drivers/net/irda/girbil-sir.c b/drivers/net/irda/girbil-sir.c
index a31b8fa..96cdecf 100644
--- a/drivers/net/irda/girbil-sir.c
+++ b/drivers/net/irda/girbil-sir.c
@@ -38,7 +38,7 @@ static int girbil_change_speed(struct sir_dev *dev, unsigned speed);
 /* Control register 1 */
 #define GIRBIL_TXEN    0x01 /* Enable transmitter */
 #define GIRBIL_RXEN    0x02 /* Enable receiver */
-#define GIRBIL_ECAN    0x04 /* Cancel self emmited data */
+#define GIRBIL_ECAN    0x04 /* Cancel self emitted data */
 #define GIRBIL_ECHO    0x08 /* Echo control characters */
 
 /* LED Current Register (0x2) */
diff --git a/drivers/net/irda/irda-usb.c b/drivers/net/irda/irda-usb.c
index e4ea619..d9267cb 100644
--- a/drivers/net/irda/irda-usb.c
+++ b/drivers/net/irda/irda-usb.c
@@ -370,7 +370,7 @@ static void speed_bulk_callback(struct urb *urb)
 	/* urb is now available */
 	//urb->status = 0; -> tested above
 
-	/* New speed and xbof is now commited in hardware */
+	/* New speed and xbof is now committed in hardware */
 	self->new_speed = -1;
 	self->new_xbofs = -1;
 
@@ -602,7 +602,7 @@ static void write_bulk_callback(struct urb *urb)
 			IRDA_DEBUG(1, "%s(), Changing speed now...\n", __func__);
 			irda_usb_change_speed_xbofs(self);
 		} else {
-			/* New speed and xbof is now commited in hardware */
+			/* New speed and xbof is now committed in hardware */
 			self->new_speed = -1;
 			self->new_xbofs = -1;
 			/* Done, waiting for next packet */
diff --git a/drivers/net/irda/mcs7780.c b/drivers/net/irda/mcs7780.c
index cc821de..be52bfe 100644
--- a/drivers/net/irda/mcs7780.c
+++ b/drivers/net/irda/mcs7780.c
@@ -588,7 +588,7 @@ static int mcs_speed_change(struct mcs_cb *mcs)
 
 	mcs_get_reg(mcs, MCS_MODE_REG, &rval);
 
-	/* MINRXPW values recomended by MosChip */
+	/* MINRXPW values recommended by MosChip */
 	if (mcs->new_speed <= 115200) {
 		rval &= ~MCS_FIR;
 
@@ -799,7 +799,7 @@ static void mcs_receive_irq(struct urb *urb)
 	ret = usb_submit_urb(urb, GFP_ATOMIC);
 }
 
-/* Transmit callback funtion.  */
+/* Transmit callback function.  */
 static void mcs_send_irq(struct urb *urb)
 {
 	struct mcs_cb *mcs = urb->context;
@@ -811,7 +811,7 @@ static void mcs_send_irq(struct urb *urb)
 		netif_wake_queue(ndev);
 }
 
-/* Transmit callback funtion.  */
+/* Transmit callback function.  */
 static netdev_tx_t mcs_hard_xmit(struct sk_buff *skb,
 				       struct net_device *ndev)
 {
diff --git a/drivers/net/irda/nsc-ircc.c b/drivers/net/irda/nsc-ircc.c
index 559fe85..7a963d4 100644
--- a/drivers/net/irda/nsc-ircc.c
+++ b/drivers/net/irda/nsc-ircc.c
@@ -716,7 +716,7 @@ static int nsc_ircc_probe_338(nsc_chip_t *chip, chipio_t *info)
 	int reg, com = 0;
 	int pnp;
 
-	/* Read funtion enable register (FER) */
+	/* Read function enable register (FER) */
 	outb(CFG_338_FER, cfg_base);
 	reg = inb(cfg_base+1);
 
diff --git a/drivers/net/irda/nsc-ircc.h b/drivers/net/irda/nsc-ircc.h
index 7ba7738..32fa582 100644
--- a/drivers/net/irda/nsc-ircc.h
+++ b/drivers/net/irda/nsc-ircc.h
@@ -135,7 +135,7 @@
 #define LSR_TXRDY       0x20 /* Transmitter ready */
 #define LSR_TXEMP       0x40 /* Transmitter empty */
 
-#define ASCR            0x07 /* Auxillary Status and Control Register */
+#define ASCR            0x07 /* Auxiliary Status and Control Register */
 #define ASCR_RXF_TOUT   0x01 /* Rx FIFO timeout */
 #define ASCR_FEND_INF   0x02 /* Frame end bytes in rx FIFO */
 #define ASCR_S_EOT      0x04 /* Set end of transmission */
diff --git a/drivers/net/irda/pxaficp_ir.c b/drivers/net/irda/pxaficp_ir.c
index c192c31..001ed0a 100644
--- a/drivers/net/irda/pxaficp_ir.c
+++ b/drivers/net/irda/pxaficp_ir.c
@@ -40,7 +40,7 @@
 
 #define ICCR0_AME	(1 << 7)	/* Address match enable */
 #define ICCR0_TIE	(1 << 6)	/* Transmit FIFO interrupt enable */
-#define ICCR0_RIE	(1 << 5)	/* Recieve FIFO interrupt enable */
+#define ICCR0_RIE	(1 << 5)	/* Receive FIFO interrupt enable */
 #define ICCR0_RXE	(1 << 4)	/* Receive enable */
 #define ICCR0_TXE	(1 << 3)	/* Transmit enable */
 #define ICCR0_TUS	(1 << 2)	/* Transmit FIFO underrun select */
@@ -483,7 +483,7 @@ static irqreturn_t pxa_irda_fir_irq(int irq, void *dev_id)
 	}
 
 	if (icsr0 & ICSR0_EIF) {
-		/* An error in FIFO occured, or there is a end of frame */
+		/* An error in FIFO occurred, or there is a end of frame */
 		pxa_irda_fir_irq_eif(si, dev, icsr0);
 	}
 
diff --git a/drivers/net/irda/smsc-ircc2.c b/drivers/net/irda/smsc-ircc2.c
index 1c1677c..8800e1f 100644
--- a/drivers/net/irda/smsc-ircc2.c
+++ b/drivers/net/irda/smsc-ircc2.c
@@ -1582,7 +1582,7 @@ static irqreturn_t smsc_ircc_interrupt_sir(struct net_device *dev)
 	int iobase;
 	int iir, lsr;
 
-	/* Already locked comming here in smsc_ircc_interrupt() */
+	/* Already locked coming here in smsc_ircc_interrupt() */
 	/*spin_lock(&self->lock);*/
 
 	iobase = self->io.sir_base;
diff --git a/drivers/net/irda/via-ircc.c b/drivers/net/irda/via-ircc.c
index 186cd28..f504b26 100644
--- a/drivers/net/irda/via-ircc.c
+++ b/drivers/net/irda/via-ircc.c
@@ -29,7 +29,7 @@ F02 Oct/28/02: Add SB device ID for 3147 and 3177.
 
 2004-02-16: <sda@bdit.de>
 - Removed unneeded 'legacy' pci stuff.
-- Make sure SIR mode is set (hw_init()) before calling mode-dependant stuff.
+- Make sure SIR mode is set (hw_init()) before calling mode-dependent stuff.
 - On speed change from core, don't send SIR frame with new speed. 
   Use current speed and change speeds later.
 - Make module-param dongle_id actually work.
@@ -334,7 +334,7 @@ static __devinit int via_ircc_open(struct pci_dev *pdev, chipio_t * info,
 	self->io.dongle_id = dongle_id;
 
 	/* The only value we must override it the baudrate */
-	/* Maximum speeds and capabilities are dongle-dependant. */
+	/* Maximum speeds and capabilities are dongle-dependent. */
 	switch( self->io.dongle_id ){
 	case 0x0d:
 		self->qos.baud_rate.bits =
diff --git a/drivers/net/irda/vlsi_ir.h b/drivers/net/irda/vlsi_ir.h
index d66fab8..a076eb1 100644
--- a/drivers/net/irda/vlsi_ir.h
+++ b/drivers/net/irda/vlsi_ir.h
@@ -209,7 +209,7 @@ enum vlsi_pio_irintr {
 	IRINTR_ACTEN	= 0x80,	/* activity interrupt enable */
 	IRINTR_ACTIVITY	= 0x40,	/* activity monitor (traffic detected) */
 	IRINTR_RPKTEN	= 0x20,	/* receive packet interrupt enable*/
-	IRINTR_RPKTINT	= 0x10,	/* rx-packet transfered from fifo to memory finished */
+	IRINTR_RPKTINT	= 0x10,	/* rx-packet transferred from fifo to memory finished */
 	IRINTR_TPKTEN	= 0x08,	/* transmit packet interrupt enable */
 	IRINTR_TPKTINT	= 0x04,	/* last bit of tx-packet+crc shifted to ir-pulser */
 	IRINTR_OE_EN	= 0x02,	/* UART rx fifo overrun error interrupt enable */
@@ -739,7 +739,7 @@ typedef struct vlsi_irda_dev {
 /* the remapped error flags we use for returning from frame
  * post-processing in vlsi_process_tx/rx() after it was completed
  * by the hardware. These functions either return the >=0 number
- * of transfered bytes in case of success or the negative (-)
+ * of transferred bytes in case of success or the negative (-)
  * of the or'ed error flags.
  */
 
diff --git a/drivers/net/ixgbe/ixgbe_dcb.c b/drivers/net/ixgbe/ixgbe_dcb.c
index 41c529f..686a17a 100644
--- a/drivers/net/ixgbe/ixgbe_dcb.c
+++ b/drivers/net/ixgbe/ixgbe_dcb.c
@@ -36,7 +36,7 @@
 /**
  * ixgbe_ieee_credits - This calculates the ieee traffic class
  * credits from the configured bandwidth percentages. Credits
- * are the smallest unit programable into the underlying
+ * are the smallest unit programmable into the underlying
  * hardware. The IEEE 802.1Qaz specification do not use bandwidth
  * groups so this is much simplified from the CEE case.
  */
diff --git a/drivers/net/ixgbe/ixgbe_dcb_nl.c b/drivers/net/ixgbe/ixgbe_dcb_nl.c
index fec4c72..327c861 100644
--- a/drivers/net/ixgbe/ixgbe_dcb_nl.c
+++ b/drivers/net/ixgbe/ixgbe_dcb_nl.c
@@ -360,7 +360,7 @@ static u8 ixgbe_dcbnl_set_all(struct net_device *netdev)
 		return DCB_NO_HW_CHG;
 
 	/*
-	 * Only take down the adapter if an app change occured. FCoE
+	 * Only take down the adapter if an app change occurred. FCoE
 	 * may shuffle tx rings in this case and this can not be done
 	 * without a reset currently.
 	 */
@@ -599,7 +599,7 @@ static u8 ixgbe_dcbnl_setapp(struct net_device *netdev,
 				break;
 
 			/* The FCoE application priority may be changed multiple
-			 * times in quick sucession with switches that build up
+			 * times in quick succession with switches that build up
 			 * TLVs. To avoid creating uneeded device resets this
 			 * checks the actual HW configuration and clears
 			 * BIT_APP_UPCHG if a HW configuration change is not
diff --git a/drivers/net/ixgbe/ixgbe_main.c b/drivers/net/ixgbe/ixgbe_main.c
index f17e4a7..6f8adc7 100644
--- a/drivers/net/ixgbe/ixgbe_main.c
+++ b/drivers/net/ixgbe/ixgbe_main.c
@@ -644,7 +644,7 @@ void ixgbe_unmap_and_free_tx_resource(struct ixgbe_ring *tx_ring,
  * @adapter: driver private struct
  * @index: reg idx of queue to query (0-127)
  *
- * Helper function to determine the traffic index for a paticular
+ * Helper function to determine the traffic index for a particular
  * register index.
  *
  * Returns : a tc index for use in range 0-7, or 0-3
@@ -3556,7 +3556,7 @@ void ixgbe_set_rx_mode(struct net_device *netdev)
 		} else {
 			/*
 			 * Write addresses to the MTA, if the attempt fails
-			 * then we should just turn on promiscous mode so
+			 * then we should just turn on promiscuous mode so
 			 * that we can at least receive multicast traffic
 			 */
 			hw->mac.ops.update_mc_addr_list(hw, netdev);
@@ -3567,7 +3567,7 @@ void ixgbe_set_rx_mode(struct net_device *netdev)
 		/*
 		 * Write addresses to available RAR registers, if there is not
 		 * sufficient space to store all the addresses then enable
-		 * unicast promiscous mode
+		 * unicast promiscuous mode
 		 */
 		count = ixgbe_write_uc_addr_list(netdev);
 		if (count < 0) {
@@ -4443,7 +4443,7 @@ static inline bool ixgbe_set_sriov_queues(struct ixgbe_adapter *adapter)
 }
 
 /*
- * ixgbe_set_num_queues: Allocate queues for device, feature dependant
+ * ixgbe_set_num_queues: Allocate queues for device, feature dependent
  * @adapter: board private structure to initialize
  *
  * This is the top level queue allocation routine.  The order here is very
diff --git a/drivers/net/ixgbe/ixgbe_phy.c b/drivers/net/ixgbe/ixgbe_phy.c
index f72f705..df5b8aa 100644
--- a/drivers/net/ixgbe/ixgbe_phy.c
+++ b/drivers/net/ixgbe/ixgbe_phy.c
@@ -1694,7 +1694,7 @@ static void ixgbe_i2c_bus_clear(struct ixgbe_hw *hw)
 }
 
 /**
- *  ixgbe_tn_check_overtemp - Checks if an overtemp occured.
+ *  ixgbe_tn_check_overtemp - Checks if an overtemp occurred.
  *  @hw: pointer to hardware structure
  *
  *  Checks if the LASI temp alarm status was triggered due to overtemp
diff --git a/drivers/net/ixgbe/ixgbe_x540.c b/drivers/net/ixgbe/ixgbe_x540.c
index f47e93f..d9323c0 100644
--- a/drivers/net/ixgbe/ixgbe_x540.c
+++ b/drivers/net/ixgbe/ixgbe_x540.c
@@ -573,7 +573,7 @@ static s32 ixgbe_acquire_swfw_sync_X540(struct ixgbe_hw *hw, u16 mask)
  * @hw: pointer to hardware structure
  * @mask: Mask to specify which semaphore to release
  *
- * Releases the SWFW semaphore throught the SW_FW_SYNC register
+ * Releases the SWFW semaphore through the SW_FW_SYNC register
  * for the specified function (CSR, PHY0, PHY1, EVM, Flash)
  **/
 static void ixgbe_release_swfw_sync_X540(struct ixgbe_hw *hw, u16 mask)
diff --git a/drivers/net/ixgbevf/ixgbevf_main.c b/drivers/net/ixgbevf/ixgbevf_main.c
index 054ab05..05fa7c8 100644
--- a/drivers/net/ixgbevf/ixgbevf_main.c
+++ b/drivers/net/ixgbevf/ixgbevf_main.c
@@ -1925,7 +1925,7 @@ static void ixgbevf_acquire_msix_vectors(struct ixgbevf_adapter *adapter,
 }
 
 /*
- * ixgbevf_set_num_queues: Allocate queues for device, feature dependant
+ * ixgbevf_set_num_queues: Allocate queues for device, feature dependent
  * @adapter: board private structure to initialize
  *
  * This is the top level queue allocation routine.  The order here is very
diff --git a/drivers/net/ks8842.c b/drivers/net/ks8842.c
index efd44af..f0d8346 100644
--- a/drivers/net/ks8842.c
+++ b/drivers/net/ks8842.c
@@ -321,7 +321,7 @@ static void ks8842_reset_hw(struct ks8842_adapter *adapter)
 	/* RX 2 kb high watermark */
 	ks8842_write16(adapter, 0, 0x1000, REG_QRFCR);
 
-	/* aggresive back off in half duplex */
+	/* aggressive back off in half duplex */
 	ks8842_enable_bits(adapter, 32, 1 << 8, REG_SGCR1);
 
 	/* enable no excessive collison drop */
diff --git a/drivers/net/ks8851.c b/drivers/net/ks8851.c
index 0fa4a98..bcd9ba6 100644
--- a/drivers/net/ks8851.c
+++ b/drivers/net/ks8851.c
@@ -141,7 +141,7 @@ static int msg_enable;
  *
  * All these calls issue SPI transactions to access the chip's registers. They
  * all require that the necessary lock is held to prevent accesses when the
- * chip is busy transfering packet data (RX/TX FIFO accesses).
+ * chip is busy transferring packet data (RX/TX FIFO accesses).
  */
 
 /**
@@ -483,7 +483,7 @@ static void ks8851_rx_pkts(struct ks8851_net *ks)
 	 *
 	 * This form of operation would require us to hold the SPI bus'
 	 * chipselect low during the entie transaction to avoid any
-	 * reset to the data stream comming from the chip.
+	 * reset to the data stream coming from the chip.
 	 */
 
 	for (; rxfc != 0; rxfc--) {
@@ -634,7 +634,7 @@ static void ks8851_irq_work(struct work_struct *work)
 
 /**
  * calc_txlen - calculate size of message to send packet
- * @len: Lenght of data
+ * @len: Length of data
  *
  * Returns the size of the TXFIFO message needed to send
  * this packet.
@@ -1472,7 +1472,7 @@ static int ks8851_phy_reg(int reg)
  * @reg: The register to read.
  *
  * This call reads data from the PHY register specified in @reg. Since the
- * device does not support all the MII registers, the non-existant values
+ * device does not support all the MII registers, the non-existent values
  * are always returned as zero.
  *
  * We return zero for unsupported registers as the MII code does not check
diff --git a/drivers/net/ks8851_mll.c b/drivers/net/ks8851_mll.c
index 2e2c69b..61631ca 100644
--- a/drivers/net/ks8851_mll.c
+++ b/drivers/net/ks8851_mll.c
@@ -470,7 +470,7 @@ static int msg_enable;
  *
  * All these calls issue transactions to access the chip's registers. They
  * all require that the necessary lock is held to prevent accesses when the
- * chip is busy transfering packet data (RX/TX FIFO accesses).
+ * chip is busy transferring packet data (RX/TX FIFO accesses).
  */
 
 /**
@@ -1364,7 +1364,7 @@ static int ks_phy_reg(int reg)
  * @reg: The register to read.
  *
  * This call reads data from the PHY register specified in @reg. Since the
- * device does not support all the MII registers, the non-existant values
+ * device does not support all the MII registers, the non-existent values
  * are always returned as zero.
  *
  * We return zero for unsupported registers as the MII code does not check
diff --git a/drivers/net/lib8390.c b/drivers/net/lib8390.c
index da74db4..17b75e5 100644
--- a/drivers/net/lib8390.c
+++ b/drivers/net/lib8390.c
@@ -35,7 +35,7 @@
   Alexey Kuznetsov	: use the 8390's six bit hash multicast filter.
   Paul Gortmaker	: tweak ANK's above multicast changes a bit.
   Paul Gortmaker	: update packet statistics for v2.1.x
-  Alan Cox		: support arbitary stupid port mappings on the
+  Alan Cox		: support arbitrary stupid port mappings on the
   			  68K Macintosh. Support >16bit I/O spaces
   Paul Gortmaker	: add kmod support for auto-loading of the 8390
 			  module by all drivers that require it.
@@ -121,7 +121,7 @@ static void __NS8390_init(struct net_device *dev, int startp);
 /*
  *	SMP and the 8390 setup.
  *
- *	The 8390 isnt exactly designed to be multithreaded on RX/TX. There is
+ *	The 8390 isn't exactly designed to be multithreaded on RX/TX. There is
  *	a page register that controls bank and packet buffer access. We guard
  *	this with ei_local->page_lock. Nobody should assume or set the page other
  *	than zero when the lock is not held. Lock holders must restore page 0
diff --git a/drivers/net/lp486e.c b/drivers/net/lp486e.c
index 3698824..385a953 100644
--- a/drivers/net/lp486e.c
+++ b/drivers/net/lp486e.c
@@ -27,7 +27,7 @@
 
 	Credits:
 	Thanks to Murphy Software BV for letting me write this in their time.
-	Well, actually, I get payed doing this...
+	Well, actually, I get paid doing this...
 	(Also: see http://www.murphy.nl for murphy, and my homepage ~ard for
 	more information on the Professional Workstation)
 
diff --git a/drivers/net/meth.h b/drivers/net/meth.h
index a78dc1c..5b145c6 100644
--- a/drivers/net/meth.h
+++ b/drivers/net/meth.h
@@ -144,7 +144,7 @@ typedef struct rx_packet {
 				       /* Bits 22 through 28 are used to determine IPGR2 */
 
 #define METH_REV_SHIFT 29       /* Bits 29 through 31 are used to determine the revision */
-				       /* 000: Inital revision */
+				       /* 000: Initial revision */
 				       /* 001: First revision, Improved TX concatenation */
 
 
@@ -193,7 +193,7 @@ typedef struct rx_packet {
 					      	/* 1: A TX message had the INT request bit set, the packet has been sent. */
 #define METH_INT_TX_LINK_FAIL	BIT(2)	/* 0: No interrupt pending, 1: PHY has reported a link failure */
 #define METH_INT_MEM_ERROR	BIT(3)	/* 0: No interrupt pending */
-						/* 1: A memory error occurred durring DMA, DMA stopped, Fatal */
+						/* 1: A memory error occurred during DMA, DMA stopped, Fatal */
 #define METH_INT_TX_ABORT		BIT(4)	/* 0: No interrupt pending, 1: The TX aborted operation, DMA stopped, FATAL */
 #define METH_INT_RX_THRESHOLD	BIT(5)	/* 0: No interrupt pending, 1: Selected receive threshold condition Valid */
 #define METH_INT_RX_UNDERFLOW	BIT(6)	/* 0: No interrupt pending, 1: FIFO was empty, packet could not be queued */
diff --git a/drivers/net/mlx4/en_main.c b/drivers/net/mlx4/en_main.c
index 9317b61..9276b1b2 100644
--- a/drivers/net/mlx4/en_main.c
+++ b/drivers/net/mlx4/en_main.c
@@ -236,7 +236,7 @@ static void *mlx4_en_add(struct mlx4_dev *dev)
 		goto err_mr;
 	}
 
-	/* Configure wich ports to start according to module parameters */
+	/* Configure which ports to start according to module parameters */
 	mdev->port_cnt = 0;
 	mlx4_foreach_port(i, dev, MLX4_PORT_TYPE_ETH)
 		mdev->port_cnt++;
diff --git a/drivers/net/mlx4/en_netdev.c b/drivers/net/mlx4/en_netdev.c
index 4f158ba..77063f9 100644
--- a/drivers/net/mlx4/en_netdev.c
+++ b/drivers/net/mlx4/en_netdev.c
@@ -247,7 +247,7 @@ static void mlx4_en_do_set_multicast(struct work_struct *work)
 							       priv->port);
 			if (err)
 				en_err(priv, "Failed enabling "
-					     "promiscous mode\n");
+					     "promiscuous mode\n");
 
 			/* Disable port multicast filter (unconditionally) */
 			err = mlx4_SET_MCAST_FLTR(mdev->dev, priv->port, 0,
@@ -276,7 +276,7 @@ static void mlx4_en_do_set_multicast(struct work_struct *work)
 	}
 
 	/*
-	 * Not in promiscous mode
+	 * Not in promiscuous mode
 	 */
 
 	if (priv->flags & MLX4_EN_FLAG_PROMISC) {
@@ -292,14 +292,14 @@ static void mlx4_en_do_set_multicast(struct work_struct *work)
 			err = mlx4_unicast_promisc_remove(mdev->dev, priv->base_qpn,
 							  priv->port);
 		if (err)
-			en_err(priv, "Failed disabling promiscous mode\n");
+			en_err(priv, "Failed disabling promiscuous mode\n");
 
 		/* Disable Multicast promisc */
 		if (priv->flags & MLX4_EN_FLAG_MC_PROMISC) {
 			err = mlx4_multicast_promisc_remove(mdev->dev, priv->base_qpn,
 							    priv->port);
 			if (err)
-				en_err(priv, "Failed disabling multicast promiscous mode\n");
+				en_err(priv, "Failed disabling multicast promiscuous mode\n");
 			priv->flags &= ~MLX4_EN_FLAG_MC_PROMISC;
 		}
 
@@ -331,7 +331,7 @@ static void mlx4_en_do_set_multicast(struct work_struct *work)
 			err = mlx4_multicast_promisc_remove(mdev->dev, priv->base_qpn,
 							    priv->port);
 			if (err)
-				en_err(priv, "Failed disabling multicast promiscous mode\n");
+				en_err(priv, "Failed disabling multicast promiscuous mode\n");
 			priv->flags &= ~MLX4_EN_FLAG_MC_PROMISC;
 		}
 
diff --git a/drivers/net/mlx4/en_rx.c b/drivers/net/mlx4/en_rx.c
index 05998ee..cfd50bc 100644
--- a/drivers/net/mlx4/en_rx.c
+++ b/drivers/net/mlx4/en_rx.c
@@ -706,7 +706,7 @@ int mlx4_en_poll_rx_cq(struct napi_struct *napi, int budget)
 }
 
 
-/* Calculate the last offset position that accomodates a full fragment
+/* Calculate the last offset position that accommodates a full fragment
  * (assuming fagment size = stride-align) */
 static int mlx4_en_last_alloc_offset(struct mlx4_en_priv *priv, u16 stride, u16 align)
 {
diff --git a/drivers/net/mlx4/en_selftest.c b/drivers/net/mlx4/en_selftest.c
index 9c91a92..191a8dc 100644
--- a/drivers/net/mlx4/en_selftest.c
+++ b/drivers/net/mlx4/en_selftest.c
@@ -149,7 +149,7 @@ void mlx4_en_ex_selftest(struct net_device *dev, u32 *flags, u64 *buf)
 
 		netif_carrier_off(dev);
 retry_tx:
-		/* Wait untill all tx queues are empty.
+		/* Wait until all tx queues are empty.
 		 * there should not be any additional incoming traffic
 		 * since we turned the carrier off */
 		msleep(200);
diff --git a/drivers/net/mlx4/en_tx.c b/drivers/net/mlx4/en_tx.c
index 01feb8f..b229acf 100644
--- a/drivers/net/mlx4/en_tx.c
+++ b/drivers/net/mlx4/en_tx.c
@@ -636,7 +636,7 @@ netdev_tx_t mlx4_en_xmit(struct sk_buff *skb, struct net_device *dev)
 	if (unlikely(!real_size))
 		goto tx_drop;
 
-	/* Allign descriptor to TXBB size */
+	/* Align descriptor to TXBB size */
 	desc_size = ALIGN(real_size, TXBB_SIZE);
 	nr_txbb = desc_size / TXBB_SIZE;
 	if (unlikely(nr_txbb > MAX_DESC_TXBBS)) {
diff --git a/drivers/net/mlx4/mcg.c b/drivers/net/mlx4/mcg.c
index c6d336a..e63c37d 100644
--- a/drivers/net/mlx4/mcg.c
+++ b/drivers/net/mlx4/mcg.c
@@ -222,7 +222,7 @@ static int existing_steering_entry(struct mlx4_dev *dev, u8 vep_num, u8 port,
 
 	/* the given qpn is listed as a promisc qpn
 	 * we need to add it as a duplicate to this entry
-	 * for future refernce */
+	 * for future references */
 	list_for_each_entry(dqp, &entry->duplicates, list) {
 		if (qpn == dqp->qpn)
 			return 0; /* qp is already duplicated */
diff --git a/drivers/net/mlx4/port.c b/drivers/net/mlx4/port.c
index eca7d85..8856659 100644
--- a/drivers/net/mlx4/port.c
+++ b/drivers/net/mlx4/port.c
@@ -172,7 +172,7 @@ int mlx4_register_mac(struct mlx4_dev *dev, u8 port, u64 mac, int *qpn, u8 wrap)
 		}
 
 		if (mac == (MLX4_MAC_MASK & be64_to_cpu(table->entries[i]))) {
-			/* MAC already registered, increase refernce count */
+			/* MAC already registered, increase references count */
 			++table->refs[i];
 			goto out;
 		}
@@ -360,7 +360,7 @@ int mlx4_register_vlan(struct mlx4_dev *dev, u8 port, u16 vlan, int *index)
 		if (table->refs[i] &&
 		    (vlan == (MLX4_VLAN_MASK &
 			      be32_to_cpu(table->entries[i])))) {
-			/* Vlan already registered, increase refernce count */
+			/* Vlan already registered, increase references count */
 			*index = i;
 			++table->refs[i];
 			goto out;
diff --git a/drivers/net/myri10ge/myri10ge.c b/drivers/net/myri10ge/myri10ge.c
index 673dc60..1446de5 100644
--- a/drivers/net/myri10ge/myri10ge.c
+++ b/drivers/net/myri10ge/myri10ge.c
@@ -3702,7 +3702,7 @@ abort:
 
 /*
  * This function determines the number of slices supported.
- * The number slices is the minumum of the number of CPUS,
+ * The number slices is the minimum of the number of CPUS,
  * the number of MSI-X irqs supported, the number of slices
  * supported by the firmware
  */
diff --git a/drivers/net/myri_sbus.c b/drivers/net/myri_sbus.c
index a761076..53aeea4 100644
--- a/drivers/net/myri_sbus.c
+++ b/drivers/net/myri_sbus.c
@@ -1009,7 +1009,7 @@ static int __devinit myri_sbus_probe(struct platform_device *op)
 
 	/* Map in the MyriCOM register/localram set. */
 	if (mp->eeprom.cpuvers < CPUVERS_4_0) {
-		/* XXX Makes no sense, if control reg is non-existant this
+		/* XXX Makes no sense, if control reg is non-existent this
 		 * XXX driver cannot function at all... maybe pre-4.0 is
 		 * XXX only a valid version for PCI cards?  Ask feldy...
 		 */
diff --git a/drivers/net/natsemi.c b/drivers/net/natsemi.c
index 2fd3963..aa2813e 100644
--- a/drivers/net/natsemi.c
+++ b/drivers/net/natsemi.c
@@ -203,7 +203,7 @@ skbuff at an offset of "+2", 16-byte aligning the IP header.
 IIId. Synchronization
 
 Most operations are synchronized on the np->lock irq spinlock, except the
-recieve and transmit paths which are synchronised using a combination of
+receive and transmit paths which are synchronised using a combination of
 hardware descriptor ownership, disabling interrupts and NAPI poll scheduling.
 
 IVb. References
@@ -726,7 +726,7 @@ static void move_int_phy(struct net_device *dev, int addr)
 	 * There are two addresses we must avoid:
 	 * - the address on the external phy that is used for transmission.
 	 * - the address that we want to access. User space can access phys
-	 *   on the mii bus with SIOCGMIIREG/SIOCSMIIREG, independant from the
+	 *   on the mii bus with SIOCGMIIREG/SIOCSMIIREG, independent from the
 	 *   phy that is used for transmission.
 	 */
 
@@ -1982,7 +1982,7 @@ static void init_ring(struct net_device *dev)
 
 	np->rx_head_desc = &np->rx_ring[0];
 
-	/* Please be carefull before changing this loop - at least gcc-2.95.1
+	/* Please be careful before changing this loop - at least gcc-2.95.1
 	 * miscompiles it otherwise.
 	 */
 	/* Initialize all Rx descriptors. */
diff --git a/drivers/net/netxen/netxen_nic_hdr.h b/drivers/net/netxen/netxen_nic_hdr.h
index d8bd73d..dc1967c 100644
--- a/drivers/net/netxen/netxen_nic_hdr.h
+++ b/drivers/net/netxen/netxen_nic_hdr.h
@@ -780,7 +780,7 @@ enum {
 
 /*
  * capabilities register, can be used to selectively enable/disable features
- * for backward compability
+ * for backward compatibility
  */
 #define CRB_NIC_CAPABILITIES_HOST	NETXEN_NIC_REG(0x1a8)
 #define CRB_NIC_MSI_MODE_HOST		NETXEN_NIC_REG(0x270)
diff --git a/drivers/net/ns83820.c b/drivers/net/ns83820.c
index a41b2cf..6667e06 100644
--- a/drivers/net/ns83820.c
+++ b/drivers/net/ns83820.c
@@ -512,7 +512,7 @@ static void ns83820_vlan_rx_register(struct net_device *ndev, struct vlan_group
 /* Packet Receiver
  *
  * The hardware supports linked lists of receive descriptors for
- * which ownership is transfered back and forth by means of an
+ * which ownership is transferred back and forth by means of an
  * ownership bit.  While the hardware does support the use of a
  * ring for receive descriptors, we only make use of a chain in
  * an attempt to reduce bus traffic under heavy load scenarios.
@@ -1147,7 +1147,7 @@ again:
 #ifdef NS83820_VLAN_ACCEL_SUPPORT
 	if(vlan_tx_tag_present(skb)) {
 		/* fetch the vlan tag info out of the
-		 * ancilliary data if the vlan code
+		 * ancillary data if the vlan code
 		 * is using hw vlan acceleration
 		 */
 		short tag = vlan_tx_tag_get(skb);
diff --git a/drivers/net/pch_gbe/pch_gbe.h b/drivers/net/pch_gbe/pch_gbe.h
index e1e33c8..bf126e7 100644
--- a/drivers/net/pch_gbe/pch_gbe.h
+++ b/drivers/net/pch_gbe/pch_gbe.h
@@ -351,7 +351,7 @@ struct pch_gbe_functions {
 };
 
 /**
- * struct pch_gbe_mac_info - MAC infomation
+ * struct pch_gbe_mac_info - MAC information
  * @addr[6]:		Store the MAC address
  * @fc:			Mode of flow control
  * @fc_autoneg:		Auto negotiation enable for flow control setting
@@ -375,7 +375,7 @@ struct pch_gbe_mac_info {
 };
 
 /**
- * struct pch_gbe_phy_info - PHY infomation
+ * struct pch_gbe_phy_info - PHY information
  * @addr:		PHY address
  * @id:			PHY's identifier
  * @revision:		PHY's revision
@@ -393,7 +393,7 @@ struct pch_gbe_phy_info {
 /*!
  * @ingroup Gigabit Ether driver Layer
  * @struct  pch_gbe_bus_info
- * @brief   Bus infomation
+ * @brief   Bus information
  */
 struct pch_gbe_bus_info {
 	u8 type;
@@ -404,7 +404,7 @@ struct pch_gbe_bus_info {
 /*!
  * @ingroup Gigabit Ether driver Layer
  * @struct  pch_gbe_hw
- * @brief   Hardware infomation
+ * @brief   Hardware information
  */
 struct pch_gbe_hw {
 	void *back;
@@ -462,7 +462,7 @@ struct pch_gbe_tx_desc {
 
 
 /**
- * struct pch_gbe_buffer - Buffer infomation
+ * struct pch_gbe_buffer - Buffer information
  * @skb:	pointer to a socket buffer
  * @dma:	DMA address
  * @time_stamp:	time stamp
@@ -477,7 +477,7 @@ struct pch_gbe_buffer {
 };
 
 /**
- * struct pch_gbe_tx_ring - tx ring infomation
+ * struct pch_gbe_tx_ring - tx ring information
  * @tx_lock:	spinlock structs
  * @desc:	pointer to the descriptor ring memory
  * @dma:	physical address of the descriptor ring
@@ -499,7 +499,7 @@ struct pch_gbe_tx_ring {
 };
 
 /**
- * struct pch_gbe_rx_ring - rx ring infomation
+ * struct pch_gbe_rx_ring - rx ring information
  * @desc:	pointer to the descriptor ring memory
  * @dma:	physical address of the descriptor ring
  * @size:	length of descriptor ring in bytes
diff --git a/drivers/net/pch_gbe/pch_gbe_ethtool.c b/drivers/net/pch_gbe/pch_gbe_ethtool.c
index c8c873b..d2174a4 100644
--- a/drivers/net/pch_gbe/pch_gbe_ethtool.c
+++ b/drivers/net/pch_gbe/pch_gbe_ethtool.c
@@ -21,7 +21,7 @@
 #include "pch_gbe_api.h"
 
 /**
- * pch_gbe_stats - Stats item infomation
+ * pch_gbe_stats - Stats item information
  */
 struct pch_gbe_stats {
 	char string[ETH_GSTRING_LEN];
diff --git a/drivers/net/pch_gbe/pch_gbe_main.c b/drivers/net/pch_gbe/pch_gbe_main.c
index 5098684..2ef2f9c 100644
--- a/drivers/net/pch_gbe/pch_gbe_main.c
+++ b/drivers/net/pch_gbe/pch_gbe_main.c
@@ -1011,7 +1011,7 @@ static void pch_gbe_tx_queue(struct pch_gbe_adapter *adapter,
 	tmp_skb->len = skb->len;
 	memcpy(&tmp_skb->data[ETH_HLEN + 2], &skb->data[ETH_HLEN],
 	       (skb->len - ETH_HLEN));
-	/*-- Set Buffer infomation --*/
+	/*-- Set Buffer information --*/
 	buffer_info->length = tmp_skb->len;
 	buffer_info->dma = dma_map_single(&adapter->pdev->dev, tmp_skb->data,
 					  buffer_info->length,
@@ -1540,7 +1540,7 @@ int pch_gbe_setup_tx_resources(struct pch_gbe_adapter *adapter,
 	size = (int)sizeof(struct pch_gbe_buffer) * tx_ring->count;
 	tx_ring->buffer_info = vzalloc(size);
 	if (!tx_ring->buffer_info) {
-		pr_err("Unable to allocate memory for the buffer infomation\n");
+		pr_err("Unable to allocate memory for the buffer information\n");
 		return -ENOMEM;
 	}
 
diff --git a/drivers/net/pci-skeleton.c b/drivers/net/pci-skeleton.c
index 1766dc4..c0f2337 100644
--- a/drivers/net/pci-skeleton.c
+++ b/drivers/net/pci-skeleton.c
@@ -214,7 +214,7 @@ static struct {
 	{ "SMC1211TX EZCard 10/100 (RealTek RTL8139)" },
 /*	{ MPX5030, "Accton MPX5030 (RealTek RTL8139)" },*/
 	{ "Delta Electronics 8139 10/100BaseTX" },
-	{ "Addtron Technolgy 8139 10/100BaseTX" },
+	{ "Addtron Technology 8139 10/100BaseTX" },
 };
 
 
diff --git a/drivers/net/pcmcia/3c574_cs.c b/drivers/net/pcmcia/3c574_cs.c
index 321b12f..81ac330 100644
--- a/drivers/net/pcmcia/3c574_cs.c
+++ b/drivers/net/pcmcia/3c574_cs.c
@@ -950,7 +950,7 @@ static struct net_device_stats *el3_get_stats(struct net_device *dev)
 }
 
 /*  Update statistics.
-	Suprisingly this need not be run single-threaded, but it effectively is.
+	Surprisingly this need not be run single-threaded, but it effectively is.
 	The counters clear when read, so the adds must merely be atomic.
  */
 static void update_stats(struct net_device *dev)
diff --git a/drivers/net/pcmcia/axnet_cs.c b/drivers/net/pcmcia/axnet_cs.c
index d3cb772..3077d72 100644
--- a/drivers/net/pcmcia/axnet_cs.c
+++ b/drivers/net/pcmcia/axnet_cs.c
@@ -780,7 +780,7 @@ module_exit(exit_axnet_cs);
   Alexey Kuznetsov	: use the 8390's six bit hash multicast filter.
   Paul Gortmaker	: tweak ANK's above multicast changes a bit.
   Paul Gortmaker	: update packet statistics for v2.1.x
-  Alan Cox		: support arbitary stupid port mappings on the
+  Alan Cox		: support arbitrary stupid port mappings on the
   			  68K Macintosh. Support >16bit I/O spaces
   Paul Gortmaker	: add kmod support for auto-loading of the 8390
 			  module by all drivers that require it.
@@ -842,7 +842,7 @@ static void do_set_multicast_list(struct net_device *dev);
 /*
  *	SMP and the 8390 setup.
  *
- *	The 8390 isnt exactly designed to be multithreaded on RX/TX. There is
+ *	The 8390 isn't exactly designed to be multithreaded on RX/TX. There is
  *	a page register that controls bank and packet buffer access. We guard
  *	this with ei_local->page_lock. Nobody should assume or set the page other
  *	than zero when the lock is not held. Lock holders must restore page 0
diff --git a/drivers/net/pcmcia/smc91c92_cs.c b/drivers/net/pcmcia/smc91c92_cs.c
index 8a9ff53..1085917 100644
--- a/drivers/net/pcmcia/smc91c92_cs.c
+++ b/drivers/net/pcmcia/smc91c92_cs.c
@@ -1264,7 +1264,7 @@ static netdev_tx_t smc_start_xmit(struct sk_buff *skb,
 
 /*======================================================================
 
-    Handle a Tx anomolous event.  Entered while in Window 2.
+    Handle a Tx anomalous event.  Entered while in Window 2.
 
 ======================================================================*/
 
diff --git a/drivers/net/pcnet32.c b/drivers/net/pcnet32.c
index aee3bb0..7680376 100644
--- a/drivers/net/pcnet32.c
+++ b/drivers/net/pcnet32.c
@@ -1651,7 +1651,7 @@ pcnet32_probe1(unsigned long ioaddr, int shared, struct pci_dev *pdev)
 	/*
 	 *  On selected chips turn on the BCR18:NOUFLO bit. This stops transmit
 	 *  starting until the packet is loaded. Strike one for reliability, lose
-	 *  one for latency - although on PCI this isnt a big loss. Older chips
+	 *  one for latency - although on PCI this isn't a big loss. Older chips
 	 *  have FIFO's smaller than a packet, so you can't do this.
 	 *  Turn on BCR18:BurstRdEn and BCR18:BurstWrEn.
 	 */
diff --git a/drivers/net/phy/phy_device.c b/drivers/net/phy/phy_device.c
index e870c06..ff109fe 100644
--- a/drivers/net/phy/phy_device.c
+++ b/drivers/net/phy/phy_device.c
@@ -538,7 +538,7 @@ EXPORT_SYMBOL(phy_detach);
 /* Generic PHY support and helper functions */
 
 /**
- * genphy_config_advert - sanitize and advertise auto-negotation parameters
+ * genphy_config_advert - sanitize and advertise auto-negotiation parameters
  * @phydev: target phy_device struct
  *
  * Description: Writes MII_ADVERTISE with the appropriate values,
@@ -687,7 +687,7 @@ int genphy_config_aneg(struct phy_device *phydev)
 		return result;
 
 	if (result == 0) {
-		/* Advertisment hasn't changed, but maybe aneg was never on to
+		/* Advertisement hasn't changed, but maybe aneg was never on to
 		 * begin with?  Or maybe phy was isolated? */
 		int ctl = phy_read(phydev, MII_BMCR);
 
diff --git a/drivers/net/ppp_generic.c b/drivers/net/ppp_generic.c
index 9f6d670..4609bc0 100644
--- a/drivers/net/ppp_generic.c
+++ b/drivers/net/ppp_generic.c
@@ -1448,7 +1448,7 @@ static int ppp_mp_explode(struct ppp *ppp, struct sk_buff *skb)
 
 		/*
 		 *check if we are on the last channel or
-		 *we exceded the lenght of the data to
+		 *we exceded the length of the data to
 		 *fragment
 		 */
 		if ((nfree <= 0) || (flen > len))
diff --git a/drivers/net/ppp_synctty.c b/drivers/net/ppp_synctty.c
index 4e6b72f..2573f52 100644
--- a/drivers/net/ppp_synctty.c
+++ b/drivers/net/ppp_synctty.c
@@ -178,7 +178,7 @@ ppp_print_buffer (const char *name, const __u8 *buf, int count)
  * way to fix this is to use a rwlock in the tty struct, but for now
  * we use a single global rwlock for all ttys in ppp line discipline.
  *
- * FIXME: Fixed in tty_io nowdays.
+ * FIXME: Fixed in tty_io nowadays.
  */
 static DEFINE_RWLOCK(disc_data_lock);
 
diff --git a/drivers/net/pppoe.c b/drivers/net/pppoe.c
index 78c0e3c..693aaef 100644
--- a/drivers/net/pppoe.c
+++ b/drivers/net/pppoe.c
@@ -115,7 +115,7 @@ struct pppoe_net {
  * 2) Session stage (MAC and SID are known)
  *
  * Ethernet frames have a special tag for this but
- * we use simplier approach based on session id
+ * we use simpler approach based on session id
  */
 static inline bool stage_session(__be16 sid)
 {
diff --git a/drivers/net/ps3_gelic_net.c b/drivers/net/ps3_gelic_net.c
index 5ecfa4b..ffdf734 100644
--- a/drivers/net/ps3_gelic_net.c
+++ b/drivers/net/ps3_gelic_net.c
@@ -632,7 +632,7 @@ static inline void gelic_card_enable_rxdmac(struct gelic_card *card)
  * @card: card structure
  *
  * gelic_card_disable_rxdmac terminates processing on the DMA controller by
- * turing off DMA and issueing a force end
+ * turing off DMA and issuing a force end
  */
 static inline void gelic_card_disable_rxdmac(struct gelic_card *card)
 {
@@ -650,7 +650,7 @@ static inline void gelic_card_disable_rxdmac(struct gelic_card *card)
  * @card: card structure
  *
  * gelic_card_disable_txdmac terminates processing on the DMA controller by
- * turing off DMA and issueing a force end
+ * turing off DMA and issuing a force end
  */
 static inline void gelic_card_disable_txdmac(struct gelic_card *card)
 {
diff --git a/drivers/net/ps3_gelic_net.h b/drivers/net/ps3_gelic_net.h
index 32521ae..fadadf9 100644
--- a/drivers/net/ps3_gelic_net.h
+++ b/drivers/net/ps3_gelic_net.h
@@ -117,7 +117,7 @@ enum gelic_descr_rx_error {
 	GELIC_DESCR_RXDATAERR	= 0x00020000, /* IP packet format error */
 	GELIC_DESCR_RXCALERR	= 0x00010000, /* cariier extension length
 					      * error */
-	GELIC_DESCR_RXCREXERR	= 0x00008000, /* carrier extention error */
+	GELIC_DESCR_RXCREXERR	= 0x00008000, /* carrier extension error */
 	GELIC_DESCR_RXMLTCST	= 0x00004000, /* multicast address frame */
 	/* bit 13..0 reserved */
 };
diff --git a/drivers/net/ps3_gelic_wireless.c b/drivers/net/ps3_gelic_wireless.c
index 4a624a2..b5ae29d 100644
--- a/drivers/net/ps3_gelic_wireless.c
+++ b/drivers/net/ps3_gelic_wireless.c
@@ -814,7 +814,7 @@ static int gelic_wl_set_auth(struct net_device *netdev,
 			 * you will not decide suitable cipher from
 			 * its beacon.
 			 * You should have knowledge about the AP's
-			 * cipher infomation in other method prior to
+			 * cipher information in other method prior to
 			 * the association.
 			 */
 			if (!precise_ie())
diff --git a/drivers/net/pxa168_eth.c b/drivers/net/pxa168_eth.c
index 1b63c8a..89f7540 100644
--- a/drivers/net/pxa168_eth.c
+++ b/drivers/net/pxa168_eth.c
@@ -462,7 +462,7 @@ static u32 hash_function(unsigned char *mac_addr_orig)
  * pep - ETHERNET .
  * mac_addr - MAC address.
  * skip - if 1, skip this address.Used in case of deleting an entry which is a
- *	  part of chain in the hash table.We cant just delete the entry since
+ *	  part of chain in the hash table.We can't just delete the entry since
  *	  that will break the chain.We need to defragment the tables time to
  *	  time.
  * rd   - 0 Discard packet upon match.
diff --git a/drivers/net/qla3xxx.h b/drivers/net/qla3xxx.h
index 3362a66..73e2343 100644
--- a/drivers/net/qla3xxx.h
+++ b/drivers/net/qla3xxx.h
@@ -770,7 +770,7 @@ enum {
 	FM93C56A_WDS = 0x0,
 	FM93C56A_ERASE = 0x3,
 	FM93C56A_ERASE_ALL = 0x0,
-/* Command Extentions */
+/* Command Extensions */
 	FM93C56A_WEN_EXT = 0x3,
 	FM93C56A_WRITE_ALL_EXT = 0x1,
 	FM93C56A_WDS_EXT = 0x0,
diff --git a/drivers/net/qlge/qlge_main.c b/drivers/net/qlge/qlge_main.c
index 49bfa58..5bb3119 100644
--- a/drivers/net/qlge/qlge_main.c
+++ b/drivers/net/qlge/qlge_main.c
@@ -660,7 +660,7 @@ static void ql_disable_interrupts(struct ql_adapter *qdev)
 /* If we're running with multiple MSI-X vectors then we enable on the fly.
  * Otherwise, we may have multiple outstanding workers and don't want to
  * enable until the last one finishes. In this case, the irq_cnt gets
- * incremented everytime we queue a worker and decremented everytime
+ * incremented every time we queue a worker and decremented every time
  * a worker finishes.  Once it hits zero we enable the interrupt.
  */
 u32 ql_enable_completion_interrupt(struct ql_adapter *qdev, u32 intr)
@@ -3299,7 +3299,7 @@ msi:
  * will service it.  An example would be if there are
  * 2 vectors (so 2 RSS rings) and 8 TX completion rings.
  * This would mean that vector 0 would service RSS ring 0
- * and TX competion rings 0,1,2 and 3.  Vector 1 would
+ * and TX completion rings 0,1,2 and 3.  Vector 1 would
  * service RSS ring 1 and TX completion rings 4,5,6 and 7.
  */
 static void ql_set_tx_vect(struct ql_adapter *qdev)
@@ -4152,7 +4152,7 @@ static int ql_change_rx_buffers(struct ql_adapter *qdev)
 	int i, status;
 	u32 lbq_buf_len;
 
-	/* Wait for an oustanding reset to complete. */
+	/* Wait for an outstanding reset to complete. */
 	if (!test_bit(QL_ADAPTER_UP, &qdev->flags)) {
 		int i = 3;
 		while (i-- && !test_bit(QL_ADAPTER_UP, &qdev->flags)) {
@@ -4281,7 +4281,7 @@ static void qlge_set_multicast_list(struct net_device *ndev)
 			if (ql_set_routing_reg
 			    (qdev, RT_IDX_PROMISCUOUS_SLOT, RT_IDX_VALID, 1)) {
 				netif_err(qdev, hw, qdev->ndev,
-					  "Failed to set promiscous mode.\n");
+					  "Failed to set promiscuous mode.\n");
 			} else {
 				set_bit(QL_PROMISCUOUS, &qdev->flags);
 			}
@@ -4291,7 +4291,7 @@ static void qlge_set_multicast_list(struct net_device *ndev)
 			if (ql_set_routing_reg
 			    (qdev, RT_IDX_PROMISCUOUS_SLOT, RT_IDX_VALID, 0)) {
 				netif_err(qdev, hw, qdev->ndev,
-					  "Failed to clear promiscous mode.\n");
+					  "Failed to clear promiscuous mode.\n");
 			} else {
 				clear_bit(QL_PROMISCUOUS, &qdev->flags);
 			}
diff --git a/drivers/net/r6040.c b/drivers/net/r6040.c
index e3ebd90..200a363 100644
--- a/drivers/net/r6040.c
+++ b/drivers/net/r6040.c
@@ -535,7 +535,7 @@ static int r6040_rx(struct net_device *dev, int limit)
 			/* RX dribble */
 			if (err & DSC_RX_ERR_DRI)
 				dev->stats.rx_frame_errors++;
-			/* Buffer lenght exceeded */
+			/* Buffer length exceeded */
 			if (err & DSC_RX_ERR_BUF)
 				dev->stats.rx_length_errors++;
 			/* Packet too long */
diff --git a/drivers/net/s2io.c b/drivers/net/s2io.c
index 356e74d..337bdcd 100644
--- a/drivers/net/s2io.c
+++ b/drivers/net/s2io.c
@@ -2353,7 +2353,7 @@ static int start_nic(struct s2io_nic *nic)
 
 	if (s2io_link_fault_indication(nic) == MAC_RMAC_ERR_TIMER) {
 		/*
-		 * Dont see link state interrupts initally on some switches,
+		 * Dont see link state interrupts initially on some switches,
 		 * so directly scheduling the link state task here.
 		 */
 		schedule_work(&nic->set_link_task);
@@ -3563,7 +3563,7 @@ static void s2io_reset(struct s2io_nic *sp)
 	}
 
 	/*
-	 * Clear spurious ECC interrupts that would have occured on
+	 * Clear spurious ECC interrupts that would have occurred on
 	 * XFRAME II cards after reset.
 	 */
 	if (sp->device_type == XFRAME_II_DEVICE) {
@@ -4065,7 +4065,7 @@ static int s2io_close(struct net_device *dev)
  *  Description :
  *  This function is the Tx entry point of the driver. S2IO NIC supports
  *  certain protocol assist features on Tx side, namely  CSO, S/G, LSO.
- *  NOTE: when device cant queue the pkt,just the trans_start variable will
+ *  NOTE: when device can't queue the pkt,just the trans_start variable will
  *  not be upadted.
  *  Return value:
  *  0 on success & 1 on failure.
diff --git a/drivers/net/s2io.h b/drivers/net/s2io.h
index 7d16030..2d14497 100644
--- a/drivers/net/s2io.h
+++ b/drivers/net/s2io.h
@@ -376,7 +376,7 @@ static const u16 fifo_selector[MAX_TX_FIFOS] = {0, 1, 3, 3, 7, 7, 7, 7};
 /* Maintains Per FIFO related information. */
 struct tx_fifo_config {
 #define	MAX_AVAILABLE_TXDS	8192
-	u32 fifo_len;		/* specifies len of FIFO upto 8192, ie no of TxDLs */
+	u32 fifo_len;		/* specifies len of FIFO up to 8192, ie no of TxDLs */
 /* Priority definition */
 #define TX_FIFO_PRI_0               0	/*Highest */
 #define TX_FIFO_PRI_1               1
diff --git a/drivers/net/sfc/falcon.c b/drivers/net/sfc/falcon.c
index 734fcfb..d96b237 100644
--- a/drivers/net/sfc/falcon.c
+++ b/drivers/net/sfc/falcon.c
@@ -692,7 +692,7 @@ static int falcon_gmii_wait(struct efx_nic *efx)
 	efx_oword_t md_stat;
 	int count;
 
-	/* wait upto 50ms - taken max from datasheet */
+	/* wait up to 50ms - taken max from datasheet */
 	for (count = 0; count < 5000; count++) {
 		efx_reado(efx, &md_stat, FR_AB_MD_STAT);
 		if (EFX_OWORD_FIELD(md_stat, FRF_AB_MD_BSY) == 0) {
@@ -1221,7 +1221,7 @@ static int falcon_reset_sram(struct efx_nic *efx)
 
 			return 0;
 		}
-	} while (++count < 20);	/* wait upto 0.4 sec */
+	} while (++count < 20);	/* wait up to 0.4 sec */
 
 	netif_err(efx, hw, efx->net_dev, "timed out waiting for SRAM reset\n");
 	return -ETIMEDOUT;
diff --git a/drivers/net/sfc/mcdi.c b/drivers/net/sfc/mcdi.c
index 5e118f0..d984790 100644
--- a/drivers/net/sfc/mcdi.c
+++ b/drivers/net/sfc/mcdi.c
@@ -453,7 +453,7 @@ static void efx_mcdi_ev_death(struct efx_nic *efx, int rc)
 	 *
 	 * There's a race here with efx_mcdi_rpc(), because we might receive
 	 * a REBOOT event *before* the request has been copied out. In polled
-	 * mode (during startup) this is irrelevent, because efx_mcdi_complete()
+	 * mode (during startup) this is irrelevant, because efx_mcdi_complete()
 	 * is ignored. In event mode, this condition is just an edge-case of
 	 * receiving a REBOOT event after posting the MCDI request. Did the mc
 	 * reboot before or after the copyout? The best we can do always is
diff --git a/drivers/net/sfc/mcdi_pcol.h b/drivers/net/sfc/mcdi_pcol.h
index b86a15f..41fe06f 100644
--- a/drivers/net/sfc/mcdi_pcol.h
+++ b/drivers/net/sfc/mcdi_pcol.h
@@ -103,7 +103,7 @@
  *
  * If Code==CMDDONE, then the fields are further interpreted as:
  *
- *   - LEVEL==INFO    Command succeded
+ *   - LEVEL==INFO    Command succeeded
  *   - LEVEL==ERR     Command failed
  *
  *    0     8         16      24     32
@@ -572,7 +572,7 @@
   (4*(_numwords))
 
 /* MC_CMD_SET_RAND_SEED:
- * Set the 16byte seed for the MC psuedo-random generator
+ * Set the 16byte seed for the MC pseudo-random generator
  */
 #define MC_CMD_SET_RAND_SEED 0x1a
 #define MC_CMD_SET_RAND_SEED_IN_LEN 16
@@ -1162,7 +1162,7 @@
 #define MC_CMD_MAC_STATS_CMD_CLEAR_WIDTH 1
 #define MC_CMD_MAC_STATS_CMD_PERIODIC_CHANGE_LBN 2
 #define MC_CMD_MAC_STATS_CMD_PERIODIC_CHANGE_WIDTH 1
-/* Remaining PERIOD* fields only relevent when PERIODIC_CHANGE is set */
+/* Remaining PERIOD* fields only relevant when PERIODIC_CHANGE is set */
 #define MC_CMD_MAC_STATS_CMD_PERIODIC_ENABLE_LBN 3
 #define MC_CMD_MAC_STATS_CMD_PERIODIC_ENABLE_WIDTH 1
 #define MC_CMD_MAC_STATS_CMD_PERIODIC_CLEAR_LBN 4
diff --git a/drivers/net/sfc/mcdi_phy.c b/drivers/net/sfc/mcdi_phy.c
index ec3f740..7e3c65b 100644
--- a/drivers/net/sfc/mcdi_phy.c
+++ b/drivers/net/sfc/mcdi_phy.c
@@ -449,7 +449,7 @@ void efx_mcdi_phy_check_fcntl(struct efx_nic *efx, u32 lpa)
 	struct efx_mcdi_phy_data *phy_cfg = efx->phy_data;
 	u32 rmtadv;
 
-	/* The link partner capabilities are only relevent if the
+	/* The link partner capabilities are only relevant if the
 	 * link supports flow control autonegotiation */
 	if (~phy_cfg->supported_cap & (1 << MC_CMD_PHY_CAP_AN_LBN))
 		return;
diff --git a/drivers/net/sfc/net_driver.h b/drivers/net/sfc/net_driver.h
index 215d5c5..9ffa9a6 100644
--- a/drivers/net/sfc/net_driver.h
+++ b/drivers/net/sfc/net_driver.h
@@ -670,7 +670,7 @@ struct efx_filter_state;
  * @irq_zero_count: Number of legacy IRQs seen with queue flags == 0
  * @fatal_irq_level: IRQ level (bit number) used for serious errors
  * @mtd_list: List of MTDs attached to the NIC
- * @nic_data: Hardware dependant state
+ * @nic_data: Hardware dependent state
  * @mac_lock: MAC access lock. Protects @port_enabled, @phy_mode,
  *	@port_inhibited, efx_monitor() and efx_reconfigure_port()
  * @port_enabled: Port enabled indicator.
diff --git a/drivers/net/sgiseeq.c b/drivers/net/sgiseeq.c
index 3a0cc63..dd03bf6 100644
--- a/drivers/net/sgiseeq.c
+++ b/drivers/net/sgiseeq.c
@@ -33,7 +33,7 @@ static char *sgiseeqstr = "SGI Seeq8003";
  * with that in mind, I've decided to make this driver look completely like a
  * stupid Lance from a driver architecture perspective.  Only difference is that
  * here our "ring buffer" looks and acts like a real Lance one does but is
- * layed out like how the HPC DMA and the Seeq want it to.  You'd be surprised
+ * laid out like how the HPC DMA and the Seeq want it to.  You'd be surprised
  * how a stupid idea like this can pay off in performance, not to mention
  * making this driver 2,000 times easier to write. ;-)
  */
@@ -77,7 +77,7 @@ struct sgiseeq_tx_desc {
 };
 
 /*
- * Warning: This structure is layed out in a certain way because HPC dma
+ * Warning: This structure is laid out in a certain way because HPC dma
  *          descriptors must be 8-byte aligned.  So don't touch this without
  *          some care.
  */
diff --git a/drivers/net/sh_eth.c b/drivers/net/sh_eth.c
index e9e7a53..8a72a97 100644
--- a/drivers/net/sh_eth.c
+++ b/drivers/net/sh_eth.c
@@ -1875,7 +1875,7 @@ static int sh_eth_drv_probe(struct platform_device *pdev)
 	if (ret)
 		goto out_unregister;
 
-	/* print device infomation */
+	/* print device information */
 	pr_info("Base address at 0x%x, %pM, IRQ %d.\n",
 	       (u32)ndev->base_addr, ndev->dev_addr, ndev->irq);
 
diff --git a/drivers/net/sis190.c b/drivers/net/sis190.c
index 3406ed8..b436e00 100644
--- a/drivers/net/sis190.c
+++ b/drivers/net/sis190.c
@@ -93,7 +93,7 @@ enum sis190_registers {
 	IntrStatus		= 0x20,
 	IntrMask		= 0x24,
 	IntrControl		= 0x28,
-	IntrTimer		= 0x2c,	// unused (Interupt Timer)
+	IntrTimer		= 0x2c,	// unused (Interrupt Timer)
 	PMControl		= 0x30,	// unused (Power Mgmt Control/Status)
 	rsv2			= 0x34,	// reserved
 	ROMControl		= 0x38,
@@ -234,7 +234,7 @@ enum _DescStatusBit {
 	RxSizeMask	= 0x0000ffff
 	/*
 	 * The asic could apparently do vlan, TSO, jumbo (sis191 only) and
-	 * provide two (unused with Linux) Tx queues. No publically
+	 * provide two (unused with Linux) Tx queues. No publicly
 	 * available documentation alas.
 	 */
 };
diff --git a/drivers/net/sis900.c b/drivers/net/sis900.c
index 84d4167..cb317cd 100644
--- a/drivers/net/sis900.c
+++ b/drivers/net/sis900.c
@@ -1180,7 +1180,7 @@ sis900_init_rx_ring(struct net_device *net_dev)
  *
  *	630E equalizer workaround rule(Cyrus Huang 08/15)
  *	PHY register 14h(Test)
- *	Bit 14: 0 -- Automatically dectect (default)
+ *	Bit 14: 0 -- Automatically detect (default)
  *		1 -- Manually set Equalizer filter
  *	Bit 13: 0 -- (Default)
  *		1 -- Speed up convergence of equalizer setting
@@ -1192,7 +1192,7 @@ sis900_init_rx_ring(struct net_device *net_dev)
  *	Then set equalizer value, and set Bit 14 to 1, Bit 9 to 0
  *	Link Off:Set Bit 13 to 1, Bit 14 to 0
  *	Calculate Equalizer value:
- *	When Link is ON and Bit 14 is 0, SIS900PHY will auto-dectect proper equalizer value.
+ *	When Link is ON and Bit 14 is 0, SIS900PHY will auto-detect proper equalizer value.
  *	When the equalizer is stable, this value is not a fixed value. It will be within
  *	a small range(eg. 7~9). Then we get a minimum and a maximum value(eg. min=7, max=9)
  *	0 <= max <= 4  --> set equalizer to max
@@ -1723,7 +1723,7 @@ static int sis900_rx(struct net_device *net_dev)
 		rx_size = data_size - CRC_SIZE;
 
 #if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
-		/* ``TOOLONG'' flag means jumbo packet recived. */
+		/* ``TOOLONG'' flag means jumbo packet received. */
 		if ((rx_status & TOOLONG) && data_size <= MAX_FRAME_SIZE)
 			rx_status &= (~ ((unsigned int)TOOLONG));
 #endif
diff --git a/drivers/net/skfp/ess.c b/drivers/net/skfp/ess.c
index 8639a08..2fc5987 100644
--- a/drivers/net/skfp/ess.c
+++ b/drivers/net/skfp/ess.c
@@ -241,7 +241,7 @@ int ess_raf_received_pack(struct s_smc *smc, SMbuf *mb, struct smt_header *sm,
 			!= SMT_RDF_SUCCESS) ||
 			(sm->smt_tid != smc->ess.alloc_trans_id)) {
 
-			DB_ESS("ESS: Allocation Responce not accepted\n",0,0) ;
+			DB_ESS("ESS: Allocation Response not accepted\n",0,0) ;
 			return fs;
 		}
 
@@ -393,7 +393,7 @@ static int process_bw_alloc(struct s_smc *smc, long int payload, long int overhe
 	 *		      |	 T-NEG	|
 	 *		       -       -
  	 *
-	 * T-NEG is discribed by the equation:
+	 * T-NEG is described by the equation:
 	 *
 	 *		     (-) fddiMACT-NEG
 	 *	T-NEG =	    -------------------
@@ -479,7 +479,7 @@ static void ess_send_response(struct s_smc *smc, struct smt_header *sm,
 	void			*p ;
 
 	/*
-	 * get and initialize the responce frame
+	 * get and initialize the response frame
 	 */
 	if (sba_cmd == CHANGE_ALLOCATION) {
 		if (!(mb=smt_build_frame(smc,SMT_RAF,SMT_REPLY,
@@ -578,7 +578,7 @@ static void ess_send_alc_req(struct s_smc *smc)
 	}
 	
 	/*
-	 * get and initialize the responce frame
+	 * get and initialize the response frame
 	 */
 	if (!(mb=smt_build_frame(smc,SMT_RAF,SMT_REQUEST,
 			sizeof(struct smt_sba_alc_req))))
diff --git a/drivers/net/skfp/fplustm.c b/drivers/net/skfp/fplustm.c
index ca4e7bb..a20ed1a 100644
--- a/drivers/net/skfp/fplustm.c
+++ b/drivers/net/skfp/fplustm.c
@@ -340,7 +340,7 @@ static void mac_counter_init(struct s_smc *smc)
 	outpw(FM_A(FM_LCNTR),0) ;
 	outpw(FM_A(FM_ECNTR),0) ;
 	/*
-	 * clear internal error counter stucture
+	 * clear internal error counter structure
 	 */
 	ec = (u_long *)&smc->hw.fp.err_stats ;
 	for (i = (sizeof(struct err_st)/sizeof(long)) ; i ; i--)
@@ -1262,8 +1262,8 @@ Function	DOWNCALL/INTERN	(SMT, fplustm.c)
 
 Para	mode =	1	RX_ENABLE_ALLMULTI	enable all multicasts
 		2	RX_DISABLE_ALLMULTI	disable "enable all multicasts"
-		3	RX_ENABLE_PROMISC	enable promiscous
-		4	RX_DISABLE_PROMISC	disable promiscous
+		3	RX_ENABLE_PROMISC	enable promiscuous
+		4	RX_DISABLE_PROMISC	disable promiscuous
 		5	RX_ENABLE_NSA		enable reception of NSA frames
 		6	RX_DISABLE_NSA		disable reception of NSA frames
 
diff --git a/drivers/net/skfp/h/cmtdef.h b/drivers/net/skfp/h/cmtdef.h
index f2f771d..5a6c612 100644
--- a/drivers/net/skfp/h/cmtdef.h
+++ b/drivers/net/skfp/h/cmtdef.h
@@ -19,7 +19,7 @@
 
 /*
  * implementation specific constants
- * MODIIFY THE FOLLWOING THREE DEFINES
+ * MODIIFY THE FOLLOWING THREE DEFINES
  */
 #define AMDPLC			/* if Amd PLC chip used */
 #ifdef	CONC
@@ -456,7 +456,7 @@ struct s_plc {
 	u_long soft_err ;		/* error counter */
 	u_long parity_err ;		/* error counter */
 	u_long ebuf_err ;		/* error counter */
-	u_long ebuf_cont ;		/* continous error counter */
+	u_long ebuf_cont ;		/* continuous error counter */
 	u_long phyinv ;			/* error counter */
 	u_long vsym_ctr ;		/* error counter */
 	u_long mini_ctr ;		/* error counter */
diff --git a/drivers/net/skfp/h/fplustm.h b/drivers/net/skfp/h/fplustm.h
index 6d738e1..d43191e 100644
--- a/drivers/net/skfp/h/fplustm.h
+++ b/drivers/net/skfp/h/fplustm.h
@@ -237,8 +237,8 @@ struct s_smt_fp {
  */
 #define RX_ENABLE_ALLMULTI	1	/* enable all multicasts */
 #define RX_DISABLE_ALLMULTI	2	/* disable "enable all multicasts" */
-#define RX_ENABLE_PROMISC	3	/* enable promiscous */
-#define RX_DISABLE_PROMISC	4	/* disable promiscous */
+#define RX_ENABLE_PROMISC	3	/* enable promiscuous */
+#define RX_DISABLE_PROMISC	4	/* disable promiscuous */
 #define RX_ENABLE_NSA		5	/* enable reception of NSA frames */
 #define RX_DISABLE_NSA		6	/* disable reception of NSA frames */
 
diff --git a/drivers/net/skfp/h/smc.h b/drivers/net/skfp/h/smc.h
index 026a83b..c774a95 100644
--- a/drivers/net/skfp/h/smc.h
+++ b/drivers/net/skfp/h/smc.h
@@ -388,7 +388,7 @@ struct smt_config {
 	u_long	rmt_t_poll ;		/* RMT : claim/beacon poller */
 	u_long  rmt_dup_mac_behavior ;  /* Flag for the beavior of SMT if
 					 * a Duplicate MAC Address was detected.
-					 * FALSE: SMT will leave finaly the ring
+					 * FALSE: SMT will leave finally the ring
 					 * TRUE:  SMT will reinstert into the ring
 					 */
 	u_long	mac_d_max ;		/* MAC : D_Max timer value */
diff --git a/drivers/net/skfp/h/smt.h b/drivers/net/skfp/h/smt.h
index 2976757..2030f9c 100644
--- a/drivers/net/skfp/h/smt.h
+++ b/drivers/net/skfp/h/smt.h
@@ -793,7 +793,7 @@ struct smt_rdf {
 } ;
 
 /*
- * SBA Request Allocation Responce Frame
+ * SBA Request Allocation Response Frame
  */
 struct smt_sba_alc_res {
 	struct smt_header	smt ;		/* generic header */
diff --git a/drivers/net/skfp/h/supern_2.h b/drivers/net/skfp/h/supern_2.h
index 5ba0b83..0b73690 100644
--- a/drivers/net/skfp/h/supern_2.h
+++ b/drivers/net/skfp/h/supern_2.h
@@ -14,7 +14,7 @@
 
 /*
 	defines for AMD Supernet II chip set
-	the chips are refered to as
+	the chips are referred to as
 		FPLUS	Formac Plus
 		PLC	Physical Layer
 
@@ -386,7 +386,7 @@ struct tx_queue {
 #define	FM_MDISRCV	(4<<8)		/* disable receive function */
 #define	FM_MRES0	(5<<8)		/* reserve */
 #define	FM_MLIMPROM	(6<<8)		/* limited-promiscuous mode */
-#define FM_MPROMISCOUS	(7<<8)		/* address detection : promiscous */
+#define FM_MPROMISCOUS	(7<<8)		/* address detection : promiscuous */
 
 #define FM_SELSA	0x0800		/* select-short-address bit */
 
diff --git a/drivers/net/skfp/hwmtm.c b/drivers/net/skfp/hwmtm.c
index af5a755..e26398b 100644
--- a/drivers/net/skfp/hwmtm.c
+++ b/drivers/net/skfp/hwmtm.c
@@ -691,7 +691,7 @@ static u_long repair_rxd_ring(struct s_smc *smc, struct s_smt_rx_queue *queue)
  *		interrupt service routine, handles the interrupt requests
  *		generated by the FDDI adapter.
  *
- * NOTE:	The operating system dependent module must garantee that the
+ * NOTE:	The operating system dependent module must guarantee that the
  *		interrupts of the adapter are disabled when it calls fddi_isr.
  *
  *	About the USE_BREAK_ISR mechanismn:
diff --git a/drivers/net/skfp/pcmplc.c b/drivers/net/skfp/pcmplc.c
index 112d35b..88d02d0 100644
--- a/drivers/net/skfp/pcmplc.c
+++ b/drivers/net/skfp/pcmplc.c
@@ -1680,7 +1680,7 @@ void plc_irq(struct s_smc *smc, int np, unsigned int cmd)
 			 * Prevent counter from being wrapped after
 			 * hanging years in that interrupt.
 			 */
-			plc->ebuf_cont++ ;	/* Ebuf continous error */
+			plc->ebuf_cont++ ;	/* Ebuf continuous error */
 		}
 
 #ifdef	SUPERNET_3
@@ -1717,8 +1717,8 @@ void plc_irq(struct s_smc *smc, int np, unsigned int cmd)
 		}
 #endif	/* SUPERNET_3 */
 	} else {
-		/* Reset the continous error variable */
-		plc->ebuf_cont = 0 ;	/* reset Ebuf continous error */
+		/* Reset the continuous error variable */
+		plc->ebuf_cont = 0 ;	/* reset Ebuf continuous error */
 	}
 	if (cmd & PL_PHYINV) {		/* physical layer invalid signal */
 		plc->phyinv++ ;
diff --git a/drivers/net/skfp/smt.c b/drivers/net/skfp/smt.c
index 1e1bd0c..08d9432 100644
--- a/drivers/net/skfp/smt.c
+++ b/drivers/net/skfp/smt.c
@@ -219,7 +219,7 @@ void smt_emulate_token_ct(struct s_smc *smc, int mac_index)
 
 	/*
 	 * Only when ring is up we will have a token count. The
-	 * flag is unfortunatly a single instance value. This
+	 * flag is unfortunately a single instance value. This
 	 * doesn't matter now, because we currently have only
 	 * one MAC instance.
 	 */
diff --git a/drivers/net/skge.h b/drivers/net/skge.h
index 507addc..51c0214 100644
--- a/drivers/net/skge.h
+++ b/drivers/net/skge.h
@@ -1038,7 +1038,7 @@ enum {
 
 	PHY_ST_PRE_SUP	= 1<<6, /* Bit  6:	Preamble Suppression */
 	PHY_ST_AN_OVER	= 1<<5, /* Bit  5:	Auto-Negotiation Over */
-	PHY_ST_REM_FLT	= 1<<4, /* Bit  4:	Remote Fault Condition Occured */
+	PHY_ST_REM_FLT	= 1<<4, /* Bit  4:	Remote Fault Condition Occurred */
 	PHY_ST_AN_CAP	= 1<<3, /* Bit  3:	Auto-Negotiation Capability */
 	PHY_ST_LSYNC	= 1<<2, /* Bit  2:	Link Synchronized */
 	PHY_ST_JAB_DET	= 1<<1, /* Bit  1:	Jabber Detected */
@@ -1721,8 +1721,8 @@ enum {
 	GM_GPSR_LINK_UP		= 1<<12, /* Bit 12:	Link Up Status */
 	GM_GPSR_PAUSE		= 1<<11, /* Bit 11:	Pause State */
 	GM_GPSR_TX_ACTIVE	= 1<<10, /* Bit 10:	Tx in Progress */
-	GM_GPSR_EXC_COL		= 1<<9,	/* Bit  9:	Excessive Collisions Occured */
-	GM_GPSR_LAT_COL		= 1<<8,	/* Bit  8:	Late Collisions Occured */
+	GM_GPSR_EXC_COL		= 1<<9,	/* Bit  9:	Excessive Collisions Occurred */
+	GM_GPSR_LAT_COL		= 1<<8,	/* Bit  8:	Late Collisions Occurred */
 
 	GM_GPSR_PHY_ST_CH	= 1<<5,	/* Bit  5:	PHY Status Change */
 	GM_GPSR_GIG_SPEED	= 1<<4,	/* Bit  4:	Gigabit Speed (1 = 1000 Mbps) */
@@ -2227,7 +2227,7 @@ enum {
 	XM_ST_BC	= 1<<7,		/* Bit  7:	Broadcast packet */
 	XM_ST_MC	= 1<<6,		/* Bit  6:	Multicast packet */
 	XM_ST_UC	= 1<<5,		/* Bit  5:	Unicast packet */
-	XM_ST_TX_UR	= 1<<4,		/* Bit  4:	FIFO Underrun occured */
+	XM_ST_TX_UR	= 1<<4,		/* Bit  4:	FIFO Underrun occurred */
 	XM_ST_CS_ERR	= 1<<3,		/* Bit  3:	Carrier Sense Error */
 	XM_ST_LAT_COL	= 1<<2,		/* Bit  2:	Late Collision Error */
 	XM_ST_MUL_COL	= 1<<1,		/* Bit  1:	Multiple Collisions */
diff --git a/drivers/net/sky2.c b/drivers/net/sky2.c
index 2a91868..ff8d262 100644
--- a/drivers/net/sky2.c
+++ b/drivers/net/sky2.c
@@ -932,7 +932,7 @@ static void sky2_mac_init(struct sky2_hw *hw, unsigned port)
 	sky2_write8(hw, SK_REG(port, TX_GMF_CTRL_T), GMF_RST_CLR);
 	sky2_write16(hw, SK_REG(port, TX_GMF_CTRL_T), GMF_OPER_ON);
 
-	/* On chips without ram buffer, pause is controled by MAC level */
+	/* On chips without ram buffer, pause is controlled by MAC level */
 	if (!(hw->flags & SKY2_HW_RAM_BUFFER)) {
 		/* Pause threshold is scaled by 8 in bytes */
 		if (hw->chip_id == CHIP_ID_YUKON_FE_P &&
@@ -3255,7 +3255,7 @@ static void sky2_reset(struct sky2_hw *hw)
 
 /* Take device down (offline).
  * Equivalent to doing dev_stop() but this does not
- * inform upper layers of the transistion.
+ * inform upper layers of the transition.
  */
 static void sky2_detach(struct net_device *dev)
 {
diff --git a/drivers/net/sky2.h b/drivers/net/sky2.h
index 6861b0e..0c6d10c 100644
--- a/drivers/net/sky2.h
+++ b/drivers/net/sky2.h
@@ -1194,7 +1194,7 @@ enum {
 
 	PHY_ST_PRE_SUP	= 1<<6, /* Bit  6:	Preamble Suppression */
 	PHY_ST_AN_OVER	= 1<<5, /* Bit  5:	Auto-Negotiation Over */
-	PHY_ST_REM_FLT	= 1<<4, /* Bit  4:	Remote Fault Condition Occured */
+	PHY_ST_REM_FLT	= 1<<4, /* Bit  4:	Remote Fault Condition Occurred */
 	PHY_ST_AN_CAP	= 1<<3, /* Bit  3:	Auto-Negotiation Capability */
 	PHY_ST_LSYNC	= 1<<2, /* Bit  2:	Link Synchronized */
 	PHY_ST_JAB_DET	= 1<<1, /* Bit  1:	Jabber Detected */
@@ -1725,8 +1725,8 @@ enum {
 	GM_GPSR_LINK_UP		= 1<<12, /* Bit 12:	Link Up Status */
 	GM_GPSR_PAUSE		= 1<<11, /* Bit 11:	Pause State */
 	GM_GPSR_TX_ACTIVE	= 1<<10, /* Bit 10:	Tx in Progress */
-	GM_GPSR_EXC_COL		= 1<<9,	/* Bit  9:	Excessive Collisions Occured */
-	GM_GPSR_LAT_COL		= 1<<8,	/* Bit  8:	Late Collisions Occured */
+	GM_GPSR_EXC_COL		= 1<<9,	/* Bit  9:	Excessive Collisions Occurred */
+	GM_GPSR_LAT_COL		= 1<<8,	/* Bit  8:	Late Collisions Occurred */
 
 	GM_GPSR_PHY_ST_CH	= 1<<5,	/* Bit  5:	PHY Status Change */
 	GM_GPSR_GIG_SPEED	= 1<<4,	/* Bit  4:	Gigabit Speed (1 = 1000 Mbps) */
diff --git a/drivers/net/smc91x.h b/drivers/net/smc91x.h
index 68d48ab..5f53fbb 100644
--- a/drivers/net/smc91x.h
+++ b/drivers/net/smc91x.h
@@ -921,7 +921,7 @@ static const char * chip_ids[ 16 ] =  {
  * Hack Alert: Some setups just can't write 8 or 16 bits reliably when not
  * aligned to a 32 bit boundary.  I tell you that does exist!
  * Fortunately the affected register accesses can be easily worked around
- * since we can write zeroes to the preceeding 16 bits without adverse
+ * since we can write zeroes to the preceding 16 bits without adverse
  * effects and use a 32-bit access.
  *
  * Enforce it on any 32-bit capable setup for now.
diff --git a/drivers/net/smsc911x.c b/drivers/net/smsc911x.c
index 1566259..c498b72 100644
--- a/drivers/net/smsc911x.c
+++ b/drivers/net/smsc911x.c
@@ -1669,7 +1669,7 @@ static int smsc911x_eeprom_send_cmd(struct smsc911x_data *pdata, u32 op)
 	}
 
 	if (e2cmd & E2P_CMD_EPC_TIMEOUT_) {
-		SMSC_TRACE(DRV, "Error occured during eeprom operation");
+		SMSC_TRACE(DRV, "Error occurred during eeprom operation");
 		return -EINVAL;
 	}
 
diff --git a/drivers/net/smsc9420.c b/drivers/net/smsc9420.c
index b09ee1c..4c92ad8 100644
--- a/drivers/net/smsc9420.c
+++ b/drivers/net/smsc9420.c
@@ -364,7 +364,7 @@ static int smsc9420_eeprom_send_cmd(struct smsc9420_pdata *pd, u32 op)
 	}
 
 	if (e2cmd & E2P_CMD_EPC_TIMEOUT_) {
-		smsc_info(HW, "Error occured during eeprom operation");
+		smsc_info(HW, "Error occurred during eeprom operation");
 		return -EINVAL;
 	}
 
diff --git a/drivers/net/stmmac/norm_desc.c b/drivers/net/stmmac/norm_desc.c
index cd0cc76..029c2a2 100644
--- a/drivers/net/stmmac/norm_desc.c
+++ b/drivers/net/stmmac/norm_desc.c
@@ -67,7 +67,7 @@ static int ndesc_get_tx_len(struct dma_desc *p)
 
 /* This function verifies if each incoming frame has some errors
  * and, if required, updates the multicast statistics.
- * In case of success, it returns csum_none becasue the device
+ * In case of success, it returns csum_none because the device
  * is not able to compute the csum in HW. */
 static int ndesc_get_rx_status(void *data, struct stmmac_extra_stats *x,
 			       struct dma_desc *p)
diff --git a/drivers/net/sunbmac.h b/drivers/net/sunbmac.h
index 8db8894..4943e97 100644
--- a/drivers/net/sunbmac.h
+++ b/drivers/net/sunbmac.h
@@ -185,7 +185,7 @@
 #define BIGMAC_RXCFG_ENABLE    0x00000001 /* Enable the receiver                      */
 #define BIGMAC_RXCFG_FIFO      0x0000000e /* Default rx fthresh...                    */
 #define BIGMAC_RXCFG_PSTRIP    0x00000020 /* Pad byte strip enable                    */
-#define BIGMAC_RXCFG_PMISC     0x00000040 /* Enable promiscous mode                   */
+#define BIGMAC_RXCFG_PMISC     0x00000040 /* Enable promiscuous mode                   */
 #define BIGMAC_RXCFG_DERR      0x00000080 /* Disable error checking                   */
 #define BIGMAC_RXCFG_DCRCS     0x00000100 /* Disable CRC stripping                    */
 #define BIGMAC_RXCFG_ME        0x00000200 /* Receive packets addressed to me          */
diff --git a/drivers/net/sungem.c b/drivers/net/sungem.c
index c1a3448..d3be735 100644
--- a/drivers/net/sungem.c
+++ b/drivers/net/sungem.c
@@ -1150,7 +1150,7 @@ static void gem_pcs_reinit_adv(struct gem *gp)
 	val &= ~(PCS_CFG_ENABLE | PCS_CFG_TO);
 	writel(val, gp->regs + PCS_CFG);
 
-	/* Advertise all capabilities except assymetric
+	/* Advertise all capabilities except asymmetric
 	 * pause.
 	 */
 	val = readl(gp->regs + PCS_MIIADV);
diff --git a/drivers/net/sunhme.h b/drivers/net/sunhme.h
index 756b5bf..64f2783 100644
--- a/drivers/net/sunhme.h
+++ b/drivers/net/sunhme.h
@@ -223,7 +223,7 @@
 /* BigMac receive config register. */
 #define BIGMAC_RXCFG_ENABLE   0x00000001 /* Enable the receiver             */
 #define BIGMAC_RXCFG_PSTRIP   0x00000020 /* Pad byte strip enable           */
-#define BIGMAC_RXCFG_PMISC    0x00000040 /* Enable promiscous mode          */
+#define BIGMAC_RXCFG_PMISC    0x00000040 /* Enable promiscuous mode          */
 #define BIGMAC_RXCFG_DERR     0x00000080 /* Disable error checking          */
 #define BIGMAC_RXCFG_DCRCS    0x00000100 /* Disable CRC stripping           */
 #define BIGMAC_RXCFG_REJME    0x00000200 /* Reject packets addressed to me  */
diff --git a/drivers/net/tc35815.c b/drivers/net/tc35815.c
index b6eec8c..7ca51ce 100644
--- a/drivers/net/tc35815.c
+++ b/drivers/net/tc35815.c
@@ -119,13 +119,13 @@ struct tc35815_regs {
 /*
  * Bit assignments
  */
-/* DMA_Ctl bit asign ------------------------------------------------------- */
+/* DMA_Ctl bit assign ------------------------------------------------------- */
 #define DMA_RxAlign	       0x00c00000 /* 1:Reception Alignment	     */
 #define DMA_RxAlign_1	       0x00400000
 #define DMA_RxAlign_2	       0x00800000
 #define DMA_RxAlign_3	       0x00c00000
 #define DMA_M66EnStat	       0x00080000 /* 1:66MHz Enable State	     */
-#define DMA_IntMask	       0x00040000 /* 1:Interupt mask		     */
+#define DMA_IntMask	       0x00040000 /* 1:Interrupt mask		     */
 #define DMA_SWIntReq	       0x00020000 /* 1:Software Interrupt request    */
 #define DMA_TxWakeUp	       0x00010000 /* 1:Transmit Wake Up		     */
 #define DMA_RxBigE	       0x00008000 /* 1:Receive Big Endian	     */
@@ -134,11 +134,11 @@ struct tc35815_regs {
 #define DMA_PowrMgmnt	       0x00001000 /* 1:Power Management		     */
 #define DMA_DmBurst_Mask       0x000001fc /* DMA Burst size		     */
 
-/* RxFragSize bit asign ---------------------------------------------------- */
+/* RxFragSize bit assign ---------------------------------------------------- */
 #define RxFrag_EnPack	       0x00008000 /* 1:Enable Packing		     */
 #define RxFrag_MinFragMask     0x00000ffc /* Minimum Fragment		     */
 
-/* MAC_Ctl bit asign ------------------------------------------------------- */
+/* MAC_Ctl bit assign ------------------------------------------------------- */
 #define MAC_Link10	       0x00008000 /* 1:Link Status 10Mbits	     */
 #define MAC_EnMissRoll	       0x00002000 /* 1:Enable Missed Roll	     */
 #define MAC_MissRoll	       0x00000400 /* 1:Missed Roll		     */
@@ -152,7 +152,7 @@ struct tc35815_regs {
 #define MAC_HaltImm	       0x00000002 /* 1:Halt Immediate		     */
 #define MAC_HaltReq	       0x00000001 /* 1:Halt request		     */
 
-/* PROM_Ctl bit asign ------------------------------------------------------ */
+/* PROM_Ctl bit assign ------------------------------------------------------ */
 #define PROM_Busy	       0x00008000 /* 1:Busy (Start Operation)	     */
 #define PROM_Read	       0x00004000 /*10:Read operation		     */
 #define PROM_Write	       0x00002000 /*01:Write operation		     */
@@ -162,7 +162,7 @@ struct tc35815_regs {
 #define PROM_Addr_Ena	       0x00000030 /*11xxxx:PROM Write enable	     */
 					  /*00xxxx:	      disable	     */
 
-/* CAM_Ctl bit asign ------------------------------------------------------- */
+/* CAM_Ctl bit assign ------------------------------------------------------- */
 #define CAM_CompEn	       0x00000010 /* 1:CAM Compare Enable	     */
 #define CAM_NegCAM	       0x00000008 /* 1:Reject packets CAM recognizes,*/
 					  /*			accept other */
@@ -170,7 +170,7 @@ struct tc35815_regs {
 #define CAM_GroupAcc	       0x00000002 /* 1:Multicast assept		     */
 #define CAM_StationAcc	       0x00000001 /* 1:unicast accept		     */
 
-/* CAM_Ena bit asign ------------------------------------------------------- */
+/* CAM_Ena bit assign ------------------------------------------------------- */
 #define CAM_ENTRY_MAX		       21   /* CAM Data entry max count	     */
 #define CAM_Ena_Mask ((1<<CAM_ENTRY_MAX)-1) /* CAM Enable bits (Max 21bits)  */
 #define CAM_Ena_Bit(index)	(1 << (index))
@@ -178,7 +178,7 @@ struct tc35815_regs {
 #define CAM_ENTRY_SOURCE	1
 #define CAM_ENTRY_MACCTL	20
 
-/* Tx_Ctl bit asign -------------------------------------------------------- */
+/* Tx_Ctl bit assign -------------------------------------------------------- */
 #define Tx_En		       0x00000001 /* 1:Transmit enable		     */
 #define Tx_TxHalt	       0x00000002 /* 1:Transmit Halt Request	     */
 #define Tx_NoPad	       0x00000004 /* 1:Suppress Padding		     */
@@ -192,7 +192,7 @@ struct tc35815_regs {
 #define Tx_EnTxPar	       0x00002000 /* 1:Enable Transmit Parity	     */
 #define Tx_EnComp	       0x00004000 /* 1:Enable Completion	     */
 
-/* Tx_Stat bit asign ------------------------------------------------------- */
+/* Tx_Stat bit assign ------------------------------------------------------- */
 #define Tx_TxColl_MASK	       0x0000000F /* Tx Collision Count		     */
 #define Tx_ExColl	       0x00000010 /* Excessive Collision	     */
 #define Tx_TXDefer	       0x00000020 /* Transmit Defered		     */
@@ -208,7 +208,7 @@ struct tc35815_regs {
 #define Tx_Halted	       0x00008000 /* Tx Halted			     */
 #define Tx_SQErr	       0x00010000 /* Signal Quality Error(SQE)	     */
 
-/* Rx_Ctl bit asign -------------------------------------------------------- */
+/* Rx_Ctl bit assign -------------------------------------------------------- */
 #define Rx_EnGood	       0x00004000 /* 1:Enable Good		     */
 #define Rx_EnRxPar	       0x00002000 /* 1:Enable Receive Parity	     */
 #define Rx_EnLongErr	       0x00000800 /* 1:Enable Long Error	     */
@@ -222,7 +222,7 @@ struct tc35815_regs {
 #define Rx_RxHalt	       0x00000002 /* 1:Receive Halt Request	     */
 #define Rx_RxEn		       0x00000001 /* 1:Receive Intrrupt Enable	     */
 
-/* Rx_Stat bit asign ------------------------------------------------------- */
+/* Rx_Stat bit assign ------------------------------------------------------- */
 #define Rx_Halted	       0x00008000 /* Rx Halted			     */
 #define Rx_Good		       0x00004000 /* Rx Good			     */
 #define Rx_RxPar	       0x00002000 /* Rx Parity Error		     */
@@ -238,7 +238,7 @@ struct tc35815_regs {
 
 #define Rx_Stat_Mask	       0x0000FFF0 /* Rx All Status Mask		     */
 
-/* Int_En bit asign -------------------------------------------------------- */
+/* Int_En bit assign -------------------------------------------------------- */
 #define Int_NRAbtEn	       0x00000800 /* 1:Non-recoverable Abort Enable  */
 #define Int_TxCtlCmpEn	       0x00000400 /* 1:Transmit Ctl Complete Enable  */
 #define Int_DmParErrEn	       0x00000200 /* 1:DMA Parity Error Enable	     */
@@ -253,7 +253,7 @@ struct tc35815_regs {
 #define Int_FDAExEn	       0x00000001 /* 1:Free Descriptor Area	     */
 					  /*		   Exhausted Enable  */
 
-/* Int_Src bit asign ------------------------------------------------------- */
+/* Int_Src bit assign ------------------------------------------------------- */
 #define Int_NRabt	       0x00004000 /* 1:Non Recoverable error	     */
 #define Int_DmParErrStat       0x00002000 /* 1:DMA Parity Error & Clear	     */
 #define Int_BLEx	       0x00001000 /* 1:Buffer List Empty & Clear     */
@@ -270,8 +270,8 @@ struct tc35815_regs {
 #define Int_IntMacRx	       0x00000002 /* 1:Rx controller & Clear	     */
 #define Int_IntMacTx	       0x00000001 /* 1:Tx controller & Clear	     */
 
-/* MD_CA bit asign --------------------------------------------------------- */
-#define MD_CA_PreSup	       0x00001000 /* 1:Preamble Supress		     */
+/* MD_CA bit assign --------------------------------------------------------- */
+#define MD_CA_PreSup	       0x00001000 /* 1:Preamble Suppress		     */
 #define MD_CA_Busy	       0x00000800 /* 1:Busy (Start Operation)	     */
 #define MD_CA_Wr	       0x00000400 /* 1:Write 0:Read		     */
 
@@ -296,7 +296,7 @@ struct BDesc {
 
 #define FD_ALIGN	16
 
-/* Frame Descripter bit asign ---------------------------------------------- */
+/* Frame Descripter bit assign ---------------------------------------------- */
 #define FD_FDLength_MASK       0x0000FFFF /* Length MASK		     */
 #define FD_BDCnt_MASK	       0x001F0000 /* BD count MASK in FD	     */
 #define FD_FrmOpt_MASK	       0x7C000000 /* Frame option MASK		     */
@@ -309,8 +309,8 @@ struct BDesc {
 #define FD_Next_EOL	       0x00000001 /* FD EOL indicator		     */
 #define FD_BDCnt_SHIFT	       16
 
-/* Buffer Descripter bit asign --------------------------------------------- */
-#define BD_BuffLength_MASK     0x0000FFFF /* Recieve Data Size		     */
+/* Buffer Descripter bit assign --------------------------------------------- */
+#define BD_BuffLength_MASK     0x0000FFFF /* Receive Data Size		     */
 #define BD_RxBDID_MASK	       0x00FF0000 /* BD ID Number MASK		     */
 #define BD_RxBDSeqN_MASK       0x7F000000 /* Rx BD Sequence Number	     */
 #define BD_CownsBD	       0x80000000 /* BD Controller owner bit	     */
@@ -339,7 +339,7 @@ struct BDesc {
 #define TX_THRESHOLD	1024
 /* used threshold with packet max byte for low pci transfer ability.*/
 #define TX_THRESHOLD_MAX 1536
-/* setting threshold max value when overrun error occured this count. */
+/* setting threshold max value when overrun error occurred this count. */
 #define TX_THRESHOLD_KEEP_LIMIT 10
 
 /* 16 + RX_BUF_NUM * 8 + RX_FD_NUM * 16 + TX_FD_NUM * 32 <= PAGE_SIZE*FD_PAGE_NUM */
diff --git a/drivers/net/tehuti.c b/drivers/net/tehuti.c
index 3397618..8564ec5 100644
--- a/drivers/net/tehuti.c
+++ b/drivers/net/tehuti.c
@@ -645,7 +645,7 @@ static int bdx_ioctl_priv(struct net_device *ndev, struct ifreq *ifr, int cmd)
 	if (cmd != SIOCDEVPRIVATE) {
 		error = copy_from_user(data, ifr->ifr_data, sizeof(data));
 		if (error) {
-			pr_err("cant copy from user\n");
+			pr_err("can't copy from user\n");
 			RET(-EFAULT);
 		}
 		DBG("%d 0x%x 0x%x\n", data[0], data[1], data[2]);
@@ -999,7 +999,7 @@ static inline void bdx_rxdb_free_elem(struct rxdb *db, int n)
  *
  * RxD fifo is smaller than RxF fifo by design. Upon high load, RxD will be
  * filled and packets will be dropped by nic without getting into host or
- * cousing interrupt. Anyway, in that condition, host has no chance to proccess
+ * cousing interrupt. Anyway, in that condition, host has no chance to process
  * all packets, but dropping in nic is cheaper, since it takes 0 cpu cycles
  */
 
@@ -1200,8 +1200,8 @@ static void bdx_recycle_skb(struct bdx_priv *priv, struct rxd_desc *rxdd)
 	RET();
 }
 
-/* bdx_rx_receive - recieves full packets from RXD fifo and pass them to OS
- * NOTE: a special treatment is given to non-continous descriptors
+/* bdx_rx_receive - receives full packets from RXD fifo and pass them to OS
+ * NOTE: a special treatment is given to non-continuous descriptors
  * that start near the end, wraps around and continue at the beginning. a second
  * part is copied right after the first, and then descriptor is interpreted as
  * normal. fifo has an extra space to allow such operations
@@ -1584,9 +1584,9 @@ err_mem:
 }
 
 /*
- * bdx_tx_space - calculates avalable space in TX fifo
+ * bdx_tx_space - calculates available space in TX fifo
  * @priv - NIC private structure
- * Returns avaliable space in TX fifo in bytes
+ * Returns available space in TX fifo in bytes
  */
 static inline int bdx_tx_space(struct bdx_priv *priv)
 {
diff --git a/drivers/net/tehuti.h b/drivers/net/tehuti.h
index b6ba860..c5642fe 100644
--- a/drivers/net/tehuti.h
+++ b/drivers/net/tehuti.h
@@ -502,7 +502,7 @@ struct txd_desc {
 #define  GMAC_RX_FILTER_ACRC  0x0010	/* accept crc error */
 #define  GMAC_RX_FILTER_AM    0x0008	/* accept multicast */
 #define  GMAC_RX_FILTER_AB    0x0004	/* accept broadcast */
-#define  GMAC_RX_FILTER_PRM   0x0001	/* [0:1] promiscous mode */
+#define  GMAC_RX_FILTER_PRM   0x0001	/* [0:1] promiscuous mode */
 
 #define  MAX_FRAME_AB_VAL       0x3fff	/* 13:0 */
 
diff --git a/drivers/net/tg3.c b/drivers/net/tg3.c
index 73c942d..b8c5f35 100644
--- a/drivers/net/tg3.c
+++ b/drivers/net/tg3.c
@@ -9712,7 +9712,7 @@ static int tg3_get_eeprom(struct net_device *dev, struct ethtool_eeprom *eeprom,
 		eeprom->len += b_count;
 	}
 
-	/* read bytes upto the last 4 byte boundary */
+	/* read bytes up to the last 4 byte boundary */
 	pd = &data[eeprom->len];
 	for (i = 0; i < (len - (len & 3)); i += 4) {
 		ret = tg3_nvram_read_be32(tp, offset + i, &val);
diff --git a/drivers/net/tg3.h b/drivers/net/tg3.h
index 73884b6..5e96706 100644
--- a/drivers/net/tg3.h
+++ b/drivers/net/tg3.h
@@ -2130,7 +2130,7 @@
 #define MII_TG3_DSP_EXP96		0x0f96
 #define MII_TG3_DSP_EXP97		0x0f97
 
-#define MII_TG3_AUX_CTRL		0x18 /* auxilliary control register */
+#define MII_TG3_AUX_CTRL		0x18 /* auxiliary control register */
 
 #define MII_TG3_AUXCTL_PCTL_100TX_LPWR	0x0010
 #define MII_TG3_AUXCTL_PCTL_SPR_ISOLATE	0x0020
@@ -2146,7 +2146,7 @@
 #define MII_TG3_AUXCTL_ACTL_TX_6DB	0x0400
 #define MII_TG3_AUXCTL_SHDWSEL_AUXCTL	0x0000
 
-#define MII_TG3_AUX_STAT		0x19 /* auxilliary status register */
+#define MII_TG3_AUX_STAT		0x19 /* auxiliary status register */
 #define MII_TG3_AUX_STAT_LPASS		0x0004
 #define MII_TG3_AUX_STAT_SPDMASK	0x0700
 #define MII_TG3_AUX_STAT_10HALF		0x0100
diff --git a/drivers/net/tokenring/3c359.c b/drivers/net/tokenring/3c359.c
index 10800f1..8a3b191 100644
--- a/drivers/net/tokenring/3c359.c
+++ b/drivers/net/tokenring/3c359.c
@@ -208,7 +208,7 @@ static void print_rx_state(struct net_device *dev)
  *	passing/getting the next value from the nic. As with all requests
  *	on this nic it has to be done in two stages, a) tell the nic which
  *	memory address you want to access and b) pass/get the value from the nic.
- *	With the EEProm, you have to wait before and inbetween access a) and b).
+ *	With the EEProm, you have to wait before and between access a) and b).
  *	As this is only read at initialization time and the wait period is very 
  *	small we shouldn't have to worry about scheduling issues.
  */
diff --git a/drivers/net/tokenring/madgemc.c b/drivers/net/tokenring/madgemc.c
index 785ad1a..2bedc0a 100644
--- a/drivers/net/tokenring/madgemc.c
+++ b/drivers/net/tokenring/madgemc.c
@@ -73,7 +73,7 @@ static void madgemc_setint(struct net_device *dev, int val);
 static irqreturn_t madgemc_interrupt(int irq, void *dev_id);
 
 /*
- * These work around paging, however they don't guarentee you're on the
+ * These work around paging, however they don't guarantee you're on the
  * right page.
  */
 #define SIFREADB(reg) (inb(dev->base_addr + ((reg<0x8)?reg:reg-0x8)))
@@ -387,7 +387,7 @@ getout:
  * both with their own disadvantages...
  *
  * 1)  	Read in the SIFSTS register from the TMS controller.  This
- *	is guarenteed to be accurate, however, there's a fairly
+ *	is guaranteed to be accurate, however, there's a fairly
  *	large performance penalty for doing so: the Madge chips
  *	must request the register from the Eagle, the Eagle must
  *	read them from its internal bus, and then take the route
@@ -454,7 +454,7 @@ static irqreturn_t madgemc_interrupt(int irq, void *dev_id)
 }
 
 /*
- * Set the card to the prefered ring speed.
+ * Set the card to the preferred ring speed.
  *
  * Unlike newer cards, the MC16/32 have their speed selection
  * circuit connected to the Madge ASICs and not to the TMS380
diff --git a/drivers/net/tokenring/smctr.c b/drivers/net/tokenring/smctr.c
index 63db5a6..d9044ab 100644
--- a/drivers/net/tokenring/smctr.c
+++ b/drivers/net/tokenring/smctr.c
@@ -393,7 +393,7 @@ static int smctr_alloc_shared_memory(struct net_device *dev)
         tp->rx_bdb_end[NON_MAC_QUEUE] = (BDBlock *)smctr_malloc(dev, 0);
 
         /* Allocate MAC transmit buffers.
-         * MAC Tx Buffers doen't have to be on an ODD Boundry.
+         * MAC Tx Buffers doen't have to be on an ODD Boundary.
          */
         tp->tx_buff_head[MAC_QUEUE]
                 = (__u16 *)smctr_malloc(dev, tp->tx_buff_size[MAC_QUEUE]);
@@ -415,7 +415,7 @@ static int smctr_alloc_shared_memory(struct net_device *dev)
 
         /* Allocate Non-MAC transmit buffers.
          * ?? For maximum Netware performance, put Tx Buffers on
-         * ODD Boundry and then restore malloc to Even Boundrys.
+         * ODD Boundary and then restore malloc to Even Boundrys.
          */
         smctr_malloc(dev, 1L);
         tp->tx_buff_head[NON_MAC_QUEUE]
@@ -1311,7 +1311,7 @@ static unsigned int smctr_get_num_rx_bdbs(struct net_device *dev)
         mem_used += sizeof(BDBlock) * tp->num_rx_bdbs[MAC_QUEUE];
 
         /* Allocate MAC transmit buffers.
-         * MAC transmit buffers don't have to be on an ODD Boundry.
+         * MAC transmit buffers don't have to be on an ODD Boundary.
          */
         mem_used += tp->tx_buff_size[MAC_QUEUE];
 
@@ -1325,7 +1325,7 @@ static unsigned int smctr_get_num_rx_bdbs(struct net_device *dev)
 
         /* Allocate Non-MAC transmit buffers.
          * For maximum Netware performance, put Tx Buffers on
-         * ODD Boundry,and then restore malloc to Even Boundrys.
+         * ODD Boundary,and then restore malloc to Even Boundrys.
          */
         mem_used += 1L;
         mem_used += tp->tx_buff_size[NON_MAC_QUEUE];
@@ -3069,8 +3069,8 @@ static int smctr_load_node_addr(struct net_device *dev)
  * disabled.!?
  *
  * NOTE 2: If the monitor_state is MS_BEACON_TEST_STATE and the receive_mask
- * has any multi-cast or promiscous bits set, the receive_mask needs to
- * be changed to clear the multi-cast or promiscous mode bits, the lobe_test
+ * has any multi-cast or promiscuous bits set, the receive_mask needs to
+ * be changed to clear the multi-cast or promiscuous mode bits, the lobe_test
  * run, and then the receive mask set back to its original value if the test
  * is successful.
  */
diff --git a/drivers/net/tokenring/tms380tr.h b/drivers/net/tokenring/tms380tr.h
index 60b30ee..e5a617c 100644
--- a/drivers/net/tokenring/tms380tr.h
+++ b/drivers/net/tokenring/tms380tr.h
@@ -442,7 +442,7 @@ typedef struct {
 #define PASS_FIRST_BUF_ONLY	0x0100	/* Passes only first internal buffer
 					 * of each received frame; FrameSize
 					 * of RPLs must contain internal
-					 * BUFFER_SIZE bits for promiscous mode.
+					 * BUFFER_SIZE bits for promiscuous mode.
 					 */
 #define ENABLE_FULL_DUPLEX_SELECTION	0x2000 
  					/* Enable the use of full-duplex
diff --git a/drivers/net/tsi108_eth.h b/drivers/net/tsi108_eth.h
index 5a77ae6..5fee7d7 100644
--- a/drivers/net/tsi108_eth.h
+++ b/drivers/net/tsi108_eth.h
@@ -305,9 +305,9 @@
 #define TSI108_TX_CRC	(1 << 5)	/* Generate CRC for this packet */
 #define TSI108_TX_INT	(1 << 14)	/* Generate an IRQ after frag. processed */
 #define TSI108_TX_RETRY	(0xf << 16)	/* 4 bit field indicating num. of retries */
-#define TSI108_TX_COL	(1 << 20)	/* Set if a collision occured */
-#define TSI108_TX_LCOL	(1 << 24)	/* Set if a late collision occured */
-#define TSI108_TX_UNDER	(1 << 25)	/* Set if a FIFO underrun occured */
+#define TSI108_TX_COL	(1 << 20)	/* Set if a collision occurred */
+#define TSI108_TX_LCOL	(1 << 24)	/* Set if a late collision occurred */
+#define TSI108_TX_UNDER	(1 << 25)	/* Set if a FIFO underrun occurred */
 #define TSI108_TX_RLIM	(1 << 26)	/* Set if the retry limit was reached */
 #define TSI108_TX_OK	(1 << 30)	/* Set if the frame TX was successful */
 #define TSI108_TX_OWN	(1 << 31)	/* Set if the device owns the descriptor */
@@ -332,7 +332,7 @@ typedef struct {
 #define TSI108_RX_RUNT	(1 << 4)/* Packet is less than minimum size */
 #define TSI108_RX_HASH	(1 << 7)/* Hash table match */
 #define TSI108_RX_BAD	(1 << 8)	/* Bad frame */
-#define TSI108_RX_OVER	(1 << 9)	/* FIFO overrun occured */
+#define TSI108_RX_OVER	(1 << 9)	/* FIFO overrun occurred */
 #define TSI108_RX_TRUNC	(1 << 11)	/* Packet truncated due to excess length */
 #define TSI108_RX_CRC	(1 << 12)	/* Packet had a CRC error */
 #define TSI108_RX_INT	(1 << 13)	/* Generate an IRQ after frag. processed */
diff --git a/drivers/net/tulip/de4x5.c b/drivers/net/tulip/de4x5.c
index 4dbd493..efaa1d6 100644
--- a/drivers/net/tulip/de4x5.c
+++ b/drivers/net/tulip/de4x5.c
@@ -79,7 +79,7 @@
     every  usable DECchip board,  I  pinched Donald's 'next_module' field to
     link my modules together.
 
-    Upto 15 EISA cards can be supported under this driver, limited primarily
+    Up to 15 EISA cards can be supported under this driver, limited primarily
     by the available IRQ lines.  I have  checked different configurations of
     multiple depca, EtherWORKS 3 cards and de4x5 cards and  have not found a
     problem yet (provided you have at least depca.c v0.38) ...
@@ -517,7 +517,7 @@ struct mii_phy {
     u_int mci;              /* 21142 MII Connector Interrupt info        */
 };
 
-#define DE4X5_MAX_PHY 8     /* Allow upto 8 attached PHY devices per board */
+#define DE4X5_MAX_PHY 8     /* Allow up to 8 attached PHY devices per board */
 
 struct sia_phy {
     u_char mc;              /* Media Code                                */
@@ -1436,7 +1436,7 @@ de4x5_sw_reset(struct net_device *dev)
 
     /* Poll for setup frame completion (adapter interrupts are disabled now) */
 
-    for (j=0, i=0;(i<500) && (j==0);i++) {       /* Upto 500ms delay */
+    for (j=0, i=0;(i<500) && (j==0);i++) {       /* Up to 500ms delay */
 	mdelay(1);
 	if ((s32)le32_to_cpu(lp->tx_ring[lp->tx_new].status) >= 0) j=1;
     }
diff --git a/drivers/net/tulip/dmfe.c b/drivers/net/tulip/dmfe.c
index 7064e03..fb07f48 100644
--- a/drivers/net/tulip/dmfe.c
+++ b/drivers/net/tulip/dmfe.c
@@ -1224,7 +1224,7 @@ static void dmfe_timer(unsigned long data)
 
 
 	/* If chip reports that link is failed it could be because external
-		PHY link status pin is not conected correctly to chip
+		PHY link status pin is not connected correctly to chip
 		To be sure ask PHY too.
 	*/
 
diff --git a/drivers/net/tulip/eeprom.c b/drivers/net/tulip/eeprom.c
index 3031ed9..296486b 100644
--- a/drivers/net/tulip/eeprom.c
+++ b/drivers/net/tulip/eeprom.c
@@ -115,7 +115,7 @@ static void __devinit tulip_build_fake_mediatable(struct tulip_private *tp)
 			  0x02,       /* phy reset sequence length */
 			  0x01, 0x00, /* phy reset sequence */
 			  0x00, 0x78, /* media capabilities */
-			  0x00, 0xe0, /* nway advertisment */
+			  0x00, 0xe0, /* nway advertisement */
 			  0x00, 0x05, /* fdx bit map */
 			  0x00, 0x06  /* ttm bit map */
 			};
diff --git a/drivers/net/typhoon.c b/drivers/net/typhoon.c
index 7fa5ec2..82653cb 100644
--- a/drivers/net/typhoon.c
+++ b/drivers/net/typhoon.c
@@ -846,7 +846,7 @@ typhoon_start_tx(struct sk_buff *skb, struct net_device *dev)
 	if(typhoon_num_free_tx(txRing) < (numDesc + 2)) {
 		netif_stop_queue(dev);
 
-		/* A Tx complete IRQ could have gotten inbetween, making
+		/* A Tx complete IRQ could have gotten between, making
 		 * the ring free again. Only need to recheck here, since
 		 * Tx is serialized.
 		 */
diff --git a/drivers/net/ucc_geth.h b/drivers/net/ucc_geth.h
index 055b87a..d12fcad 100644
--- a/drivers/net/ucc_geth.h
+++ b/drivers/net/ucc_geth.h
@@ -80,7 +80,7 @@ struct ucc_geth {
 				   frames) received that were between 128
 				   (Including FCS length==4) and 255 octets */
 	u32 txok;		/* Total number of octets residing in frames
-				   that where involved in successfull
+				   that where involved in successful
 				   transmission */
 	u16 txcf;		/* Total number of PAUSE control frames
 				   transmitted by this MAC */
@@ -759,7 +759,7 @@ struct ucc_geth_hardware_statistics {
 				   frames) received that were between 128
 				   (Including FCS length==4) and 255 octets */
 	u32 txok;		/* Total number of octets residing in frames
-				   that where involved in successfull
+				   that where involved in successful
 				   transmission */
 	u16 txcf;		/* Total number of PAUSE control frames
 				   transmitted by this MAC */
diff --git a/drivers/net/usb/cdc_eem.c b/drivers/net/usb/cdc_eem.c
index 8f12854..882f53f 100644
--- a/drivers/net/usb/cdc_eem.c
+++ b/drivers/net/usb/cdc_eem.c
@@ -190,7 +190,7 @@ static int eem_rx_fixup(struct usbnet *dev, struct sk_buff *skb)
 
 		/*
 		 * EEM packet header format:
-		 * b0..14:	EEM type dependant (Data or Command)
+		 * b0..14:	EEM type dependent (Data or Command)
 		 * b15:		bmType
 		 */
 		header = get_unaligned_le16(skb->data);
diff --git a/drivers/net/usb/kaweth.c b/drivers/net/usb/kaweth.c
index 7dc8497..ad0298f 100644
--- a/drivers/net/usb/kaweth.c
+++ b/drivers/net/usb/kaweth.c
@@ -1221,7 +1221,7 @@ static void kaweth_disconnect(struct usb_interface *intf)
 
 	usb_set_intfdata(intf, NULL);
 	if (!kaweth) {
-		dev_warn(&intf->dev, "unregistering non-existant device\n");
+		dev_warn(&intf->dev, "unregistering non-existent device\n");
 		return;
 	}
 	netdev = kaweth->net;
diff --git a/drivers/net/via-rhine.c b/drivers/net/via-rhine.c
index 5e7f069..eb5d75d 100644
--- a/drivers/net/via-rhine.c
+++ b/drivers/net/via-rhine.c
@@ -1861,7 +1861,7 @@ static void rhine_restart_tx(struct net_device *dev) {
 	u32 intr_status;
 
 	/*
-	 * If new errors occured, we need to sort them out before doing Tx.
+	 * If new errors occurred, we need to sort them out before doing Tx.
 	 * In that case the ISR will be back here RSN anyway.
 	 */
 	intr_status = get_intr_status(dev);
@@ -1887,7 +1887,7 @@ static void rhine_restart_tx(struct net_device *dev) {
 		/* This should never happen */
 		if (debug > 1)
 			printk(KERN_WARNING "%s: rhine_restart_tx() "
-			       "Another error occured %8.8x.\n",
+			       "Another error occurred %8.8x.\n",
 			       dev->name, intr_status);
 	}
 
diff --git a/drivers/net/via-velocity.c b/drivers/net/via-velocity.c
index 0d6fec6..4fe0517 100644
--- a/drivers/net/via-velocity.c
+++ b/drivers/net/via-velocity.c
@@ -292,7 +292,7 @@ VELOCITY_PARAM(DMA_length, "DMA length");
 /* IP_byte_align[] is used for IP header DWORD byte aligned
    0: indicate the IP header won't be DWORD byte aligned.(Default) .
    1: indicate the IP header will be DWORD byte aligned.
-      In some enviroment, the IP header should be DWORD byte aligned,
+      In some environment, the IP header should be DWORD byte aligned,
       or the packet will be droped when we receive it. (eg: IPVS)
 */
 VELOCITY_PARAM(IP_byte_align, "Enable IP header dword aligned");
@@ -1994,7 +1994,7 @@ static inline void velocity_rx_csum(struct rx_desc *rd, struct sk_buff *skb)
  *	@dev: network device
  *
  *	Replace the current skb that is scheduled for Rx processing by a
- *	shorter, immediatly allocated skb, if the received packet is small
+ *	shorter, immediately allocated skb, if the received packet is small
  *	enough. This function returns a negative value if the received
  *	packet is too big or if memory is exhausted.
  */
diff --git a/drivers/net/vmxnet3/vmxnet3_drv.c b/drivers/net/vmxnet3/vmxnet3_drv.c
index cc14b4a..0d47c3a 100644
--- a/drivers/net/vmxnet3/vmxnet3_drv.c
+++ b/drivers/net/vmxnet3/vmxnet3_drv.c
@@ -892,7 +892,7 @@ vmxnet3_prepare_tso(struct sk_buff *skb,
  * Transmits a pkt thru a given tq
  * Returns:
  *    NETDEV_TX_OK:      descriptors are setup successfully
- *    NETDEV_TX_OK:      error occured, the pkt is dropped
+ *    NETDEV_TX_OK:      error occurred, the pkt is dropped
  *    NETDEV_TX_BUSY:    tx ring is full, queue is stopped
  *
  * Side-effects:
@@ -2685,7 +2685,7 @@ vmxnet3_read_mac_addr(struct vmxnet3_adapter *adapter, u8 *mac)
  * Enable MSIx vectors.
  * Returns :
  *	0 on successful enabling of required vectors,
- *	VMXNET3_LINUX_MIN_MSIX_VECT when only minumum number of vectors required
+ *	VMXNET3_LINUX_MIN_MSIX_VECT when only minimum number of vectors required
  *	 could be enabled.
  *	number of vectors which can be enabled otherwise (this number is smaller
  *	 than VMXNET3_LINUX_MIN_MSIX_VECT)
diff --git a/drivers/net/vxge/vxge-config.c b/drivers/net/vxge/vxge-config.c
index e74e4b4..401bebf 100644
--- a/drivers/net/vxge/vxge-config.c
+++ b/drivers/net/vxge/vxge-config.c
@@ -187,7 +187,7 @@ vxge_hw_vpath_fw_api(struct __vxge_hw_virtualpath *vpath, u32 action,
 					   VXGE_HW_DEF_DEVICE_POLL_MILLIS);
 
 	/* The __vxge_hw_device_register_poll can udelay for a significant
-	 * amount of time, blocking other proccess from the CPU.  If it delays
+	 * amount of time, blocking other process from the CPU.  If it delays
 	 * for ~5secs, a NMI error can occur.  A way around this is to give up
 	 * the processor via msleep, but this is not allowed is under lock.
 	 * So, only allow it to sleep for ~4secs if open.  Otherwise, delay for
diff --git a/drivers/net/vxge/vxge-main.c b/drivers/net/vxge/vxge-main.c
index 395423a..aff68c1 100644
--- a/drivers/net/vxge/vxge-main.c
+++ b/drivers/net/vxge/vxge-main.c
@@ -2282,7 +2282,7 @@ vxge_alarm_msix_handle(int irq, void *dev_id)
 		VXGE_HW_VPATH_MSIX_ACTIVE) + VXGE_ALARM_MSIX_ID;
 
 	for (i = 0; i < vdev->no_of_vpath; i++) {
-		/* Reduce the chance of loosing alarm interrupts by masking
+		/* Reduce the chance of losing alarm interrupts by masking
 		 * the vector. A pending bit will be set if an alarm is
 		 * generated and on unmask the interrupt will be fired.
 		 */
@@ -2788,7 +2788,7 @@ static int vxge_open(struct net_device *dev)
 	}
 
 	/* Enable vpath to sniff all unicast/multicast traffic that not
-	 * addressed to them. We allow promiscous mode for PF only
+	 * addressed to them. We allow promiscuous mode for PF only
 	 */
 
 	val64 = 0;
@@ -2890,7 +2890,7 @@ out0:
 	return ret;
 }
 
-/* Loop throught the mac address list and delete all the entries */
+/* Loop through the mac address list and delete all the entries */
 static void vxge_free_mac_add_list(struct vxge_vpath *vpath)
 {
 
@@ -2957,7 +2957,7 @@ static int do_vxge_close(struct net_device *dev, int do_io)
 					val64);
 		}
 
-		/* Remove the function 0 from promiscous mode */
+		/* Remove the function 0 from promiscuous mode */
 		vxge_hw_mgmt_reg_write(vdev->devh,
 			vxge_hw_mgmt_reg_type_mrpcim,
 			0,
diff --git a/drivers/net/vxge/vxge-traffic.c b/drivers/net/vxge/vxge-traffic.c
index 8674f33..2638b8d 100644
--- a/drivers/net/vxge/vxge-traffic.c
+++ b/drivers/net/vxge/vxge-traffic.c
@@ -1111,7 +1111,7 @@ void vxge_hw_channel_dtr_free(struct __vxge_hw_channel *channel, void *dtrh)
  * vxge_hw_channel_dtr_count
  * @channel: Channel handle. Obtained via vxge_hw_channel_open().
  *
- * Retreive number of DTRs available. This function can not be called
+ * Retrieve number of DTRs available. This function can not be called
  * from data path. ring_initial_replenishi() is the only user.
  */
 int vxge_hw_channel_dtr_count(struct __vxge_hw_channel *channel)
@@ -2060,7 +2060,7 @@ enum vxge_hw_status vxge_hw_vpath_promisc_enable(
 
 	vpath = vp->vpath;
 
-	/* Enable promiscous mode for function 0 only */
+	/* Enable promiscuous mode for function 0 only */
 	if (!(vpath->hldev->access_rights &
 		VXGE_HW_DEVICE_ACCESS_RIGHT_MRPCIM))
 		return VXGE_HW_OK;
diff --git a/drivers/net/vxge/vxge-traffic.h b/drivers/net/vxge/vxge-traffic.h
index 9d9dfda..6c2fc0b 100644
--- a/drivers/net/vxge/vxge-traffic.h
+++ b/drivers/net/vxge/vxge-traffic.h
@@ -681,7 +681,7 @@ struct vxge_hw_xmac_aggr_stats {
  * @rx_red_discard: Count of received frames that are discarded because of RED
  *            (Random Early Discard).
  * @rx_xgmii_ctrl_err_cnt: Maintains a count of unexpected or misplaced control
- *            characters occuring between times of normal data transmission
+ *            characters occurring between times of normal data transmission
  *            (i.e. not included in RX_XGMII_DATA_ERR_CNT). This counter is
  *            incremented when either -
  *            1) The Reconciliation Sublayer (RS) is expecting one control
diff --git a/drivers/net/wan/cosa.c b/drivers/net/wan/cosa.c
index 10bafd5..6fb6f8e 100644
--- a/drivers/net/wan/cosa.c
+++ b/drivers/net/wan/cosa.c
@@ -329,7 +329,7 @@ static int startmicrocode(struct cosa_data *cosa, int address);
 static int readmem(struct cosa_data *cosa, char __user *data, int addr, int len);
 static int cosa_reset_and_read_id(struct cosa_data *cosa, char *id);
 
-/* Auxilliary functions */
+/* Auxiliary functions */
 static int get_wait_data(struct cosa_data *cosa);
 static int put_wait_data(struct cosa_data *cosa, int data);
 static int puthexnumber(struct cosa_data *cosa, int number);
diff --git a/drivers/net/wan/dscc4.c b/drivers/net/wan/dscc4.c
index 4578e5b..acb9ea8 100644
--- a/drivers/net/wan/dscc4.c
+++ b/drivers/net/wan/dscc4.c
@@ -56,7 +56,7 @@
  * IV. Notes
  * The current error (XDU, RFO) recovery code is untested.
  * So far, RDO takes his RX channel down and the right sequence to enable it
- * again is still a mistery. If RDO happens, plan a reboot. More details
+ * again is still a mystery. If RDO happens, plan a reboot. More details
  * in the code (NB: as this happens, TX still works).
  * Don't mess the cables during operation, especially on DTE ports. I don't
  * suggest it for DCE either but at least one can get some messages instead
@@ -1065,7 +1065,7 @@ static int dscc4_open(struct net_device *dev)
 
 	/*
 	 * Due to various bugs, there is no way to reliably reset a
-	 * specific port (manufacturer's dependant special PCI #RST wiring
+	 * specific port (manufacturer's dependent special PCI #RST wiring
 	 * apart: it affects all ports). Thus the device goes in the best
 	 * silent mode possible at dscc4_close() time and simply claims to
 	 * be up if it's opened again. It still isn't possible to change
@@ -1230,9 +1230,9 @@ static inline int dscc4_check_clock_ability(int port)
  *   scaling. Of course some rounding may take place.
  * - no high speed mode (40Mb/s). May be trivial to do but I don't have an
  *   appropriate external clocking device for testing.
- * - no time-slot/clock mode 5: shameless lazyness.
+ * - no time-slot/clock mode 5: shameless laziness.
  *
- * The clock signals wiring can be (is ?) manufacturer dependant. Good luck.
+ * The clock signals wiring can be (is ?) manufacturer dependent. Good luck.
  *
  * BIG FAT WARNING: if the device isn't provided enough clocking signal, it
  * won't pass the init sequence. For example, straight back-to-back DTE without
diff --git a/drivers/net/wan/hostess_sv11.c b/drivers/net/wan/hostess_sv11.c
index 48edc5f..e817583 100644
--- a/drivers/net/wan/hostess_sv11.c
+++ b/drivers/net/wan/hostess_sv11.c
@@ -15,7 +15,7 @@
  *	The hardware does the bus handling to avoid the need for delays between
  *	touching control registers.
  *
- *	Port B isnt wired (why - beats me)
+ *	Port B isn't wired (why - beats me)
  *
  *	Generic HDLC port Copyright (C) 2008 Krzysztof Halasa <khc@pm.waw.pl>
  */
diff --git a/drivers/net/wan/ixp4xx_hss.c b/drivers/net/wan/ixp4xx_hss.c
index 6c571e1..f1e1643 100644
--- a/drivers/net/wan/ixp4xx_hss.c
+++ b/drivers/net/wan/ixp4xx_hss.c
@@ -178,7 +178,7 @@
  *
  * The resulting average clock frequency (assuming 33.333 MHz oscillator) is:
  * freq = 66.666 MHz / (A + (B + 1) / (C + 1))
- * minumum freq = 66.666 MHz / (A + 1)
+ * minimum freq = 66.666 MHz / (A + 1)
  * maximum freq = 66.666 MHz / A
  *
  * Example: A = 2, B = 2, C = 7, CLOCK_CR register = 2 << 22 | 2 << 12 | 7
@@ -230,7 +230,7 @@
 #define PKT_PIPE_MODE_WRITE		0x57
 
 /* HDLC packet status values - desc->status */
-#define ERR_SHUTDOWN		1 /* stop or shutdown occurrance */
+#define ERR_SHUTDOWN		1 /* stop or shutdown occurrence */
 #define ERR_HDLC_ALIGN		2 /* HDLC alignment error */
 #define ERR_HDLC_FCS		3 /* HDLC Frame Check Sum error */
 #define ERR_RXFREE_Q_EMPTY	4 /* RX-free queue became empty while receiving
diff --git a/drivers/net/wan/lmc/lmc_main.c b/drivers/net/wan/lmc/lmc_main.c
index 70feb84..b7f2358 100644
--- a/drivers/net/wan/lmc/lmc_main.c
+++ b/drivers/net/wan/lmc/lmc_main.c
@@ -24,7 +24,7 @@
   *
   * Linux driver notes:
   * Linux uses the device struct lmc_private to pass private information
-  * arround.
+  * around.
   *
   * The initialization portion of this driver (the lmc_reset() and the
   * lmc_dec_reset() functions, as well as the led controls and the
diff --git a/drivers/net/wan/lmc/lmc_var.h b/drivers/net/wan/lmc/lmc_var.h
index 65d0197..01ad452 100644
--- a/drivers/net/wan/lmc/lmc_var.h
+++ b/drivers/net/wan/lmc/lmc_var.h
@@ -180,7 +180,7 @@ struct lmc___ctl {
 
 
 /*
- * Carefull, look at the data sheet, there's more to this
+ * Careful, look at the data sheet, there's more to this
  * structure than meets the eye.  It should probably be:
  *
  * struct tulip_desc_t {
@@ -380,7 +380,7 @@ struct lmc___softc {
 /* CSR6 settings */
 #define OPERATION_MODE  0x00000200 /* Full Duplex      */
 #define PROMISC_MODE    0x00000040 /* Promiscuous Mode */
-#define RECIEVE_ALL     0x40000000 /* Recieve All      */
+#define RECIEVE_ALL     0x40000000 /* Receive All      */
 #define PASS_BAD_FRAMES 0x00000008 /* Pass Bad Frames  */
 
 /* Dec control registers  CSR6 as well */
@@ -398,7 +398,7 @@ struct lmc___softc {
 #define TULIP_CMD_RECEIVEALL    0x40000000L /* (RW)  Receivel all frames? */
 #define TULIP_CMD_MUSTBEONE     0x02000000L /* (RW)  Must Be One (21140) */
 #define TULIP_CMD_TXTHRSHLDCTL  0x00400000L /* (RW)  Transmit Threshold Mode (21140) */
-#define TULIP_CMD_STOREFWD      0x00200000L /* (RW)  Store and Foward (21140) */
+#define TULIP_CMD_STOREFWD      0x00200000L /* (RW)  Store and Forward (21140) */
 #define TULIP_CMD_NOHEARTBEAT   0x00080000L /* (RW)  No Heartbeat (21140) */
 #define TULIP_CMD_PORTSELECT    0x00040000L /* (RW)  Post Select (100Mb) (21140) */
 #define TULIP_CMD_FULLDUPLEX    0x00000200L /* (RW)  Full Duplex Mode */
diff --git a/drivers/net/wan/z85230.c b/drivers/net/wan/z85230.c
index 9395686..0806232 100644
--- a/drivers/net/wan/z85230.c
+++ b/drivers/net/wan/z85230.c
@@ -542,7 +542,7 @@ static void z8530_dma_tx(struct z8530_channel *chan)
 		z8530_tx(chan);
 		return;
 	}
-	/* This shouldnt occur in DMA mode */
+	/* This shouldn't occur in DMA mode */
 	printk(KERN_ERR "DMA tx - bogus event!\n");
 	z8530_tx(chan);
 }
@@ -1219,7 +1219,7 @@ static const char *z8530_type_name[]={
  *	@io: the port value in question
  *
  *	Describe a Z8530 in a standard format. We must pass the I/O as
- *	the port offset isnt predictable. The main reason for this function
+ *	the port offset isn't predictable. The main reason for this function
  *	is to try and get a common format of report.
  */
 
@@ -1588,7 +1588,7 @@ static void z8530_rx_done(struct z8530_channel *c)
 		unsigned long flags;
 		
 		/*
-		 *	Complete this DMA. Neccessary to find the length
+		 *	Complete this DMA. Necessary to find the length
 		 */		
 		 
 		flags=claim_dma_lock();
@@ -1657,7 +1657,7 @@ static void z8530_rx_done(struct z8530_channel *c)
 		 *	fifo length for this. Thus we want to flip to the new
 		 *	buffer and then mess around copying and allocating
 		 *	things. For the current case it doesn't matter but
-		 *	if you build a system where the sync irq isnt blocked
+		 *	if you build a system where the sync irq isn't blocked
 		 *	by the kernel IRQ disable then you need only block the
 		 *	sync IRQ for the RT_LOCK area.
 		 *
diff --git a/drivers/net/wimax/i2400m/control.c b/drivers/net/wimax/i2400m/control.c
index 12b84ed..727d728 100644
--- a/drivers/net/wimax/i2400m/control.c
+++ b/drivers/net/wimax/i2400m/control.c
@@ -378,7 +378,7 @@ void i2400m_report_tlv_system_state(struct i2400m *i2400m,
  * the device's state as sometimes we need to do a link-renew (the BS
  * wants us to renew a DHCP lease, for example).
  *
- * In fact, doc says that everytime we get a link-up, we should do a
+ * In fact, doc says that every time we get a link-up, we should do a
  * DHCP negotiation...
  */
 static
@@ -675,7 +675,7 @@ void i2400m_msg_to_dev_cancel_wait(struct i2400m *i2400m, int code)
  *  - the ack message wasn't formatted correctly
  *
  * The returned skb has been allocated with wimax_msg_to_user_alloc(),
- * it contains the reponse in a netlink attribute and is ready to be
+ * it contains the response in a netlink attribute and is ready to be
  * passed up to user space with wimax_msg_to_user_send(). To access
  * the payload and its length, use wimax_msg_{data,len}() on the skb.
  *
diff --git a/drivers/net/wimax/i2400m/driver.c b/drivers/net/wimax/i2400m/driver.c
index 65bc334..47cae71 100644
--- a/drivers/net/wimax/i2400m/driver.c
+++ b/drivers/net/wimax/i2400m/driver.c
@@ -654,7 +654,7 @@ void __i2400m_dev_reset_handle(struct work_struct *ws)
 	if (result == -EUCLEAN) {
 		/*
 		 * We come here because the reset during operational mode
-		 * wasn't successully done and need to proceed to a bus
+		 * wasn't successfully done and need to proceed to a bus
 		 * reset. For the dev_reset_handle() to be able to handle
 		 * the reset event later properly, we restore boot_mode back
 		 * to the state before previous reset. ie: just like we are
@@ -755,7 +755,7 @@ EXPORT_SYMBOL_GPL(i2400m_error_recovery);
  * Alloc the command and ack buffers for boot mode
  *
  * Get the buffers needed to deal with boot mode messages.  These
- * buffers need to be allocated before the sdio recieve irq is setup.
+ * buffers need to be allocated before the sdio receive irq is setup.
  */
 static
 int i2400m_bm_buf_alloc(struct i2400m *i2400m)
diff --git a/drivers/net/wimax/i2400m/fw.c b/drivers/net/wimax/i2400m/fw.c
index 8b55a5b..85dadd5 100644
--- a/drivers/net/wimax/i2400m/fw.c
+++ b/drivers/net/wimax/i2400m/fw.c
@@ -54,7 +54,7 @@
  * endpoint and read from it in the notification endpoint. In SDIO we
  * talk to it via the write address and read from the read address.
  *
- * Upon entrance to boot mode, the device sends (preceeded with a few
+ * Upon entrance to boot mode, the device sends (preceded with a few
  * zero length packets (ZLPs) on the notification endpoint in USB) a
  * reboot barker (4 le32 words with the same value). We ack it by
  * sending the same barker to the device. The device acks with a
@@ -1589,7 +1589,7 @@ int i2400m_dev_bootstrap(struct i2400m *i2400m, enum i2400m_bri flags)
 		i2400m->fw_name = fw_name;
 		ret = i2400m_fw_bootstrap(i2400m, fw, flags);
 		release_firmware(fw);
-		if (ret >= 0)	/* firmware loaded succesfully */
+		if (ret >= 0)	/* firmware loaded successfully */
 			break;
 		i2400m->fw_name = NULL;
 	}
diff --git a/drivers/net/wimax/i2400m/i2400m-usb.h b/drivers/net/wimax/i2400m/i2400m-usb.h
index eb80243..6650fde 100644
--- a/drivers/net/wimax/i2400m/i2400m-usb.h
+++ b/drivers/net/wimax/i2400m/i2400m-usb.h
@@ -105,14 +105,14 @@ static inline void edc_init(struct edc *edc)
  *
  * @edc: pointer to error density counter.
  * @max_err: maximum number of errors we can accept over the timeframe
- * @timeframe: lenght of the timeframe (in jiffies).
+ * @timeframe: length of the timeframe (in jiffies).
  *
  * Returns: !0 1 if maximum acceptable errors per timeframe has been
  *     exceeded. 0 otherwise.
  *
  * This is way to determine if the number of acceptable errors per time
  * period has been exceeded. It is not accurate as there are cases in which
- * this scheme will not work, for example if there are periodic occurences
+ * this scheme will not work, for example if there are periodic occurrences
  * of errors that straddle updates to the start time. This scheme is
  * sufficient for our usage.
  *
@@ -204,7 +204,7 @@ enum {
  *     usb_autopm_get/put_interface() barriers when executing
  *     commands. See doc in i2400mu_suspend() for more information.
  *
- * @rx_size_auto_shrink: if true, the rx_size is shrinked
+ * @rx_size_auto_shrink: if true, the rx_size is shrunk
  *     automatically based on the average size of the received
  *     transactions. This allows the receive code to allocate smaller
  *     chunks of memory and thus reduce pressure on the memory
diff --git a/drivers/net/wimax/i2400m/i2400m.h b/drivers/net/wimax/i2400m/i2400m.h
index 030cbfd..5eacc65 100644
--- a/drivers/net/wimax/i2400m/i2400m.h
+++ b/drivers/net/wimax/i2400m/i2400m.h
@@ -526,7 +526,7 @@ struct i2400m_barker_db;
  *
  * @barker: barker type that the device uses; this is initialized by
  *     i2400m_is_boot_barker() the first time it is called. Then it
- *     won't change during the life cycle of the device and everytime
+ *     won't change during the life cycle of the device and every time
  *     a boot barker is received, it is just verified for it being the
  *     same.
  *
@@ -928,7 +928,7 @@ extern void i2400m_report_tlv_rf_switches_status(
 	struct i2400m *, const struct i2400m_tlv_rf_switches_status *);
 
 /*
- * Helpers for firmware backwards compability
+ * Helpers for firmware backwards compatibility
  *
  * As we aim to support at least the firmware version that was
  * released with the previous kernel/driver release, some code will be
diff --git a/drivers/net/wimax/i2400m/netdev.c b/drivers/net/wimax/i2400m/netdev.c
index 94742e1..2edd8fe 100644
--- a/drivers/net/wimax/i2400m/netdev.c
+++ b/drivers/net/wimax/i2400m/netdev.c
@@ -166,7 +166,7 @@ void i2400m_wake_tx_work(struct work_struct *ws)
 	d_fnstart(3, dev, "(ws %p i2400m %p skb %p)\n", ws, i2400m, skb);
 	result = -EINVAL;
 	if (skb == NULL) {
-		dev_err(dev, "WAKE&TX: skb dissapeared!\n");
+		dev_err(dev, "WAKE&TX: skb disappeared!\n");
 		goto out_put;
 	}
 	/* If we have, somehow, lost the connection after this was
diff --git a/drivers/net/wimax/i2400m/op-rfkill.c b/drivers/net/wimax/i2400m/op-rfkill.c
index 9e02b90..b0dba35 100644
--- a/drivers/net/wimax/i2400m/op-rfkill.c
+++ b/drivers/net/wimax/i2400m/op-rfkill.c
@@ -27,7 +27,7 @@
  * - report changes in the HW RF Kill switch [with
  *   wimax_rfkill_{sw,hw}_report(), which happens when we detect those
  *   indications coming through hardware reports]. We also do it on
- *   initialization to let the stack know the intial HW state.
+ *   initialization to let the stack know the initial HW state.
  *
  * - implement indications from the stack to change the SW RF Kill
  *   switch (coming from sysfs, the wimax stack or user space).
@@ -73,7 +73,7 @@ int i2400m_radio_is(struct i2400m *i2400m, enum wimax_rf_state state)
  * Generic Netlink will call this function when a message is sent from
  * userspace to change the software RF-Kill switch status.
  *
- * This function will set the device's sofware RF-Kill switch state to
+ * This function will set the device's software RF-Kill switch state to
  * match what is requested.
  *
  * NOTE: the i2400m has a strict state machine; we can only set the
diff --git a/drivers/net/wimax/i2400m/rx.c b/drivers/net/wimax/i2400m/rx.c
index 844133b..2f94a87 100644
--- a/drivers/net/wimax/i2400m/rx.c
+++ b/drivers/net/wimax/i2400m/rx.c
@@ -349,7 +349,7 @@ error_no_waiter:
  *
  * For reports: We can't clone the original skb where the data is
  * because we need to send this up via netlink; netlink has to add
- * headers and we can't overwrite what's preceeding the payload...as
+ * headers and we can't overwrite what's preceding the payload...as
  * it is another message. So we just dup them.
  */
 static
@@ -425,7 +425,7 @@ error_check:
  *
  * As in i2400m_rx_ctl(), we can't clone the original skb where the
  * data is because we need to send this up via netlink; netlink has to
- * add headers and we can't overwrite what's preceeding the
+ * add headers and we can't overwrite what's preceding the
  * payload...as it is another message. So we just dup them.
  */
 static
diff --git a/drivers/net/wimax/i2400m/tx.c b/drivers/net/wimax/i2400m/tx.c
index 3f819ef..4b30ed1 100644
--- a/drivers/net/wimax/i2400m/tx.c
+++ b/drivers/net/wimax/i2400m/tx.c
@@ -149,7 +149,7 @@
  * (with a moved message header to make sure it is size-aligned to
  * 16), TAIL room that was unusable (and thus is marked with a message
  * header that says 'skip this') and at the head of the buffer, an
- * imcomplete message with a couple of payloads.
+ * incomplete message with a couple of payloads.
  *
  * N   ___________________________________________________
  *    |                                                   |
@@ -819,7 +819,7 @@ EXPORT_SYMBOL_GPL(i2400m_tx);
  * the FIF that is ready for transmission.
  *
  * It sets the state in @i2400m to indicate the bus-specific driver is
- * transfering that message (i2400m->tx_msg_size).
+ * transferring that message (i2400m->tx_msg_size).
  *
  * Once the transfer is completed, call i2400m_tx_msg_sent().
  *
diff --git a/drivers/net/wimax/i2400m/usb-fw.c b/drivers/net/wimax/i2400m/usb-fw.c
index b58ec56..1fda46c 100644
--- a/drivers/net/wimax/i2400m/usb-fw.c
+++ b/drivers/net/wimax/i2400m/usb-fw.c
@@ -169,7 +169,7 @@ retry:
  *
  * Command can be a raw command, which requires no preparation (and
  * which might not even be following the command format). Checks that
- * the right amount of data was transfered.
+ * the right amount of data was transferred.
  *
  * To satisfy USB requirements (no onstack, vmalloc or in data segment
  * buffers), we copy the command to i2400m->bm_cmd_buf and send it from
diff --git a/drivers/net/wimax/i2400m/usb-rx.c b/drivers/net/wimax/i2400m/usb-rx.c
index a26483a..e325768 100644
--- a/drivers/net/wimax/i2400m/usb-rx.c
+++ b/drivers/net/wimax/i2400m/usb-rx.c
@@ -58,7 +58,7 @@
  *    a zillion reads; by serializing, we are throttling.
  *
  *  - RX data processing can get heavy enough so that it is not
- *    appropiate for doing it in the USB callback; thus we run it in a
+ *    appropriate for doing it in the USB callback; thus we run it in a
  *    process context.
  *
  * We provide a read buffer of an arbitrary size (short of a page); if
diff --git a/drivers/net/wimax/i2400m/usb-tx.c b/drivers/net/wimax/i2400m/usb-tx.c
index c65b997..ac357ac 100644
--- a/drivers/net/wimax/i2400m/usb-tx.c
+++ b/drivers/net/wimax/i2400m/usb-tx.c
@@ -168,7 +168,7 @@ retry:
 /*
  * Get the next TX message in the TX FIFO and send it to the device
  *
- * Note we exit the loop if i2400mu_tx() fails; that funtion only
+ * Note we exit the loop if i2400mu_tx() fails; that function only
  * fails on hard error (failing to tx a buffer not being one of them,
  * see its doc).
  *
diff --git a/drivers/net/wireless/airo.c b/drivers/net/wireless/airo.c
index 57a79b0..4e5c7a1 100644
--- a/drivers/net/wireless/airo.c
+++ b/drivers/net/wireless/airo.c
@@ -1884,7 +1884,7 @@ static int airo_open(struct net_device *dev) {
 	/* Make sure the card is configured.
 	 * Wireless Extensions may postpone config changes until the card
 	 * is open (to pipeline changes and speed-up card setup). If
-	 * those changes are not yet commited, do it now - Jean II */
+	 * those changes are not yet committed, do it now - Jean II */
 	if (test_bit(FLAG_COMMIT, &ai->flags)) {
 		disable_MAC(ai, 1);
 		writeConfigRid(ai, 1);
@@ -1992,7 +1992,7 @@ static int mpi_send_packet (struct net_device *dev)
 /*
  * Magic, the cards firmware needs a length count (2 bytes) in the host buffer
  * right after  TXFID_HDR.The TXFID_HDR contains the status short so payloadlen
- * is immediatly after it. ------------------------------------------------
+ * is immediately after it. ------------------------------------------------
  *                         |TXFIDHDR+STATUS|PAYLOADLEN|802.3HDR|PACKETDATA|
  *                         ------------------------------------------------
  */
@@ -2006,7 +2006,7 @@ static int mpi_send_packet (struct net_device *dev)
 		sizeof(wifictlhdr8023) + 2 ;
 
 	/*
-	 * Firmware automaticly puts 802 header on so
+	 * Firmware automatically puts 802 header on so
 	 * we don't need to account for it in the length
 	 */
 	if (test_bit(FLAG_MIC_CAPABLE, &ai->flags) && ai->micstats.enabled &&
@@ -2531,7 +2531,7 @@ static int mpi_init_descriptors (struct airo_info *ai)
 /*
  * We are setting up three things here:
  * 1) Map AUX memory for descriptors: Rid, TxFid, or RxFid.
- * 2) Map PCI memory for issueing commands.
+ * 2) Map PCI memory for issuing commands.
  * 3) Allocate memory (shared) to send and receive ethernet frames.
  */
 static int mpi_map_card(struct airo_info *ai, struct pci_dev *pci)
@@ -3947,7 +3947,7 @@ static u16 issuecommand(struct airo_info *ai, Cmd *pCmd, Resp *pRsp) {
 
 	if ( max_tries == -1 ) {
 		airo_print_err(ai->dev->name,
-			"Max tries exceeded when issueing command");
+			"Max tries exceeded when issuing command");
 		if (IN4500(ai, COMMAND) & COMMAND_BUSY)
 			OUT4500(ai, EVACK, EV_CLEARCOMMANDBUSY);
 		return ERROR;
@@ -4173,7 +4173,7 @@ done:
 }
 
 /*  Note, that we are using BAP1 which is also used by transmit, so
- *  make sure this isnt called when a transmit is happening */
+ *  make sure this isn't called when a transmit is happening */
 static int PC4500_writerid(struct airo_info *ai, u16 rid,
 			   const void *pBuf, int len, int lock)
 {
@@ -4776,7 +4776,7 @@ static int proc_stats_rid_open( struct inode *inode,
 		if (!statsLabels[i]) continue;
 		if (j+strlen(statsLabels[i])+16>4096) {
 			airo_print_warn(apriv->dev->name,
-			       "Potentially disasterous buffer overflow averted!");
+			       "Potentially disastrous buffer overflow averted!");
 			break;
 		}
 		j+=sprintf(data->rbuffer+j, "%s: %u\n", statsLabels[i],
diff --git a/drivers/net/wireless/ath/ar9170/main.c b/drivers/net/wireless/ath/ar9170/main.c
index b761fec..ccc2eda 100644
--- a/drivers/net/wireless/ath/ar9170/main.c
+++ b/drivers/net/wireless/ath/ar9170/main.c
@@ -974,7 +974,7 @@ void ar9170_rx(struct ar9170 *ar, struct sk_buff *skb)
 			if (ar->rx_failover_missing <= 0) {
 				/*
 				 * nested ar9170_rx call!
-				 * termination is guranteed, even when the
+				 * termination is guaranteed, even when the
 				 * combined frame also have a element with
 				 * a bad tag.
 				 */
diff --git a/drivers/net/wireless/ath/ar9170/phy.c b/drivers/net/wireless/ath/ar9170/phy.c
index 0dbfcf7..aa8d06b 100644
--- a/drivers/net/wireless/ath/ar9170/phy.c
+++ b/drivers/net/wireless/ath/ar9170/phy.c
@@ -424,7 +424,7 @@ static u32 ar9170_get_default_phy_reg_val(u32 reg, bool is_2ghz, bool is_40mhz)
 
 /*
  * initialize some phy regs from eeprom values in modal_header[]
- * acc. to band and bandwith
+ * acc. to band and bandwidth
  */
 static int ar9170_init_phy_from_eeprom(struct ar9170 *ar,
 				bool is_2ghz, bool is_40mhz)
diff --git a/drivers/net/wireless/ath/ath5k/ani.h b/drivers/net/wireless/ath/ath5k/ani.h
index d0a6640..0340153 100644
--- a/drivers/net/wireless/ath/ath5k/ani.h
+++ b/drivers/net/wireless/ath/ath5k/ani.h
@@ -27,7 +27,7 @@
 #define ATH5K_ANI_RSSI_THR_HIGH		40
 #define ATH5K_ANI_RSSI_THR_LOW		7
 
-/* maximum availabe levels */
+/* maximum available levels */
 #define ATH5K_ANI_MAX_FIRSTEP_LVL	2
 #define ATH5K_ANI_MAX_NOISE_IMM_LVL	1
 
diff --git a/drivers/net/wireless/ath/ath5k/base.c b/drivers/net/wireless/ath/ath5k/base.c
index 4d7f21e..349a596 100644
--- a/drivers/net/wireless/ath/ath5k/base.c
+++ b/drivers/net/wireless/ath/ath5k/base.c
@@ -1953,7 +1953,7 @@ ath5k_beacon_update_timers(struct ath5k_softc *sc, u64 bc_tsf)
 
 #define FUDGE AR5K_TUNE_SW_BEACON_RESP + 3
 	/* We use FUDGE to make sure the next TBTT is ahead of the current TU.
-	 * Since we later substract AR5K_TUNE_SW_BEACON_RESP (10) in the timer
+	 * Since we later subtract AR5K_TUNE_SW_BEACON_RESP (10) in the timer
 	 * configuration we need to make sure it is bigger than that. */
 
 	if (bc_tsf == -1) {
@@ -1971,7 +1971,7 @@ ath5k_beacon_update_timers(struct ath5k_softc *sc, u64 bc_tsf)
 		intval |= AR5K_BEACON_RESET_TSF;
 	} else if (bc_tsf > hw_tsf) {
 		/*
-		 * beacon received, SW merge happend but HW TSF not yet updated.
+		 * beacon received, SW merge happened but HW TSF not yet updated.
 		 * not possible to reconfigure timers yet, but next time we
 		 * receive a beacon with the same BSSID, the hardware will
 		 * automatically update the TSF and then we need to reconfigure
@@ -2651,7 +2651,7 @@ ath5k_reset(struct ath5k_softc *sc, struct ieee80211_channel *chan,
 	synchronize_irq(sc->irq);
 	stop_tasklets(sc);
 
-	/* Save ani mode and disable ANI durring
+	/* Save ani mode and disable ANI during
 	 * reset. If we don't we might get false
 	 * PHY error interrupts. */
 	ani_mode = ah->ah_sc->ani_state.ani_mode;
diff --git a/drivers/net/wireless/ath/ath5k/desc.c b/drivers/net/wireless/ath/ath5k/desc.c
index 16b44ff..a8fcc94 100644
--- a/drivers/net/wireless/ath/ath5k/desc.c
+++ b/drivers/net/wireless/ath/ath5k/desc.c
@@ -51,7 +51,7 @@ ath5k_hw_setup_2word_tx_desc(struct ath5k_hw *ah, struct ath5k_desc *desc,
 	/*
 	 * Validate input
 	 * - Zero retries don't make sense.
-	 * - A zero rate will put the HW into a mode where it continously sends
+	 * - A zero rate will put the HW into a mode where it continuously sends
 	 *   noise on the channel, so it is important to avoid this.
 	 */
 	if (unlikely(tx_tries0 == 0)) {
@@ -190,7 +190,7 @@ static int ath5k_hw_setup_4word_tx_desc(struct ath5k_hw *ah,
 	/*
 	 * Validate input
 	 * - Zero retries don't make sense.
-	 * - A zero rate will put the HW into a mode where it continously sends
+	 * - A zero rate will put the HW into a mode where it continuously sends
 	 *   noise on the channel, so it is important to avoid this.
 	 */
 	if (unlikely(tx_tries0 == 0)) {
@@ -300,7 +300,7 @@ ath5k_hw_setup_mrr_tx_desc(struct ath5k_hw *ah, struct ath5k_desc *desc,
 	/*
 	 * Rates can be 0 as long as the retry count is 0 too.
 	 * A zero rate and nonzero retry count will put the HW into a mode where
-	 * it continously sends noise on the channel, so it is important to
+	 * it continuously sends noise on the channel, so it is important to
 	 * avoid this.
 	 */
 	if (unlikely((tx_rate1 == 0 && tx_tries1 != 0) ||
@@ -342,7 +342,7 @@ ath5k_hw_setup_mrr_tx_desc(struct ath5k_hw *ah, struct ath5k_desc *desc,
 \***********************/
 
 /*
- * Proccess the tx status descriptor on 5210/5211
+ * Process the tx status descriptor on 5210/5211
  */
 static int ath5k_hw_proc_2word_tx_status(struct ath5k_hw *ah,
 		struct ath5k_desc *desc, struct ath5k_tx_status *ts)
@@ -394,7 +394,7 @@ static int ath5k_hw_proc_2word_tx_status(struct ath5k_hw *ah,
 }
 
 /*
- * Proccess a tx status descriptor on 5212
+ * Process a tx status descriptor on 5212
  */
 static int ath5k_hw_proc_4word_tx_status(struct ath5k_hw *ah,
 		struct ath5k_desc *desc, struct ath5k_tx_status *ts)
@@ -519,7 +519,7 @@ int ath5k_hw_setup_rx_desc(struct ath5k_hw *ah, struct ath5k_desc *desc,
 }
 
 /*
- * Proccess the rx status descriptor on 5210/5211
+ * Process the rx status descriptor on 5210/5211
  */
 static int ath5k_hw_proc_5210_rx_status(struct ath5k_hw *ah,
 		struct ath5k_desc *desc, struct ath5k_rx_status *rs)
@@ -602,7 +602,7 @@ static int ath5k_hw_proc_5210_rx_status(struct ath5k_hw *ah,
 }
 
 /*
- * Proccess the rx status descriptor on 5212
+ * Process the rx status descriptor on 5212
  */
 static int ath5k_hw_proc_5212_rx_status(struct ath5k_hw *ah,
 					struct ath5k_desc *desc,
diff --git a/drivers/net/wireless/ath/ath5k/eeprom.c b/drivers/net/wireless/ath/ath5k/eeprom.c
index b6561f7..efb672c 100644
--- a/drivers/net/wireless/ath/ath5k/eeprom.c
+++ b/drivers/net/wireless/ath/ath5k/eeprom.c
@@ -1080,7 +1080,7 @@ ath5k_eeprom_read_pcal_info_5112(struct ath5k_hw *ah, int mode)
  *
  * To recreate the curves we read here the points and interpolate
  * later. Note that in most cases only 2 (higher and lower) curves are
- * used (like RF5112) but vendors have the oportunity to include all
+ * used (like RF5112) but vendors have the opportunity to include all
  * 4 curves on eeprom. The final curve (higher power) has an extra
  * point for better accuracy like RF5112.
  */
@@ -1302,7 +1302,7 @@ ath5k_eeprom_read_pcal_info_2413(struct ath5k_hw *ah, int mode)
 			/*
 			 * Pd gain 0 is not the last pd gain
 			 * so it only has 2 pd points.
-			 * Continue wih pd gain 1.
+			 * Continue with pd gain 1.
 			 */
 			pcinfo->pwr_i[1] = (val >> 10) & 0x1f;
 
diff --git a/drivers/net/wireless/ath/ath5k/pci.c b/drivers/net/wireless/ath/ath5k/pci.c
index 66598a0..3c44689 100644
--- a/drivers/net/wireless/ath/ath5k/pci.c
+++ b/drivers/net/wireless/ath/ath5k/pci.c
@@ -57,7 +57,7 @@ static void ath5k_pci_read_cachesize(struct ath_common *common, int *csz)
 	*csz = (int)u8tmp;
 
 	/*
-	 * This check was put in to avoid "unplesant" consequences if
+	 * This check was put in to avoid "unpleasant" consequences if
 	 * the bootrom has not fully initialized all PCI devices.
 	 * Sometimes the cache line size register is not set
 	 */
diff --git a/drivers/net/wireless/ath/ath5k/pcu.c b/drivers/net/wireless/ath/ath5k/pcu.c
index a702817..d9b3f82 100644
--- a/drivers/net/wireless/ath/ath5k/pcu.c
+++ b/drivers/net/wireless/ath/ath5k/pcu.c
@@ -472,7 +472,7 @@ void ath5k_hw_set_rx_filter(struct ath5k_hw *ah, u32 filter)
 	}
 
 	/*
-	 * The AR5210 uses promiscous mode to detect radar activity
+	 * The AR5210 uses promiscuous mode to detect radar activity
 	 */
 	if (ah->ah_version == AR5K_AR5210 &&
 			(filter & AR5K_RX_FILTER_RADARERR)) {
@@ -706,8 +706,8 @@ ath5k_check_timer_win(int a, int b, int window, int intval)
  * The need for this function arises from the fact that we have 4 separate
  * HW timer registers (TIMER0 - TIMER3), which are closely related to the
  * next beacon target time (NBTT), and that the HW updates these timers
- * seperately based on the current TSF value. The hardware increments each
- * timer by the beacon interval, when the local TSF coverted to TU is equal
+ * separately based on the current TSF value. The hardware increments each
+ * timer by the beacon interval, when the local TSF converted to TU is equal
  * to the value stored in the timer.
  *
  * The reception of a beacon with the same BSSID can update the local HW TSF
diff --git a/drivers/net/wireless/ath/ath5k/phy.c b/drivers/net/wireless/ath/ath5k/phy.c
index 62ce2f4..5544191 100644
--- a/drivers/net/wireless/ath/ath5k/phy.c
+++ b/drivers/net/wireless/ath/ath5k/phy.c
@@ -335,11 +335,11 @@ static void ath5k_hw_wait_for_synth(struct ath5k_hw *ah,
  * http://madwifi-project.org/ticket/1659
  * with various measurements and diagrams
  *
- * TODO: Deal with power drops due to probes by setting an apropriate
+ * TODO: Deal with power drops due to probes by setting an appropriate
  * tx power on the probe packets ! Make this part of the calibration process.
  */
 
-/* Initialize ah_gain durring attach */
+/* Initialize ah_gain during attach */
 int ath5k_hw_rfgain_opt_init(struct ath5k_hw *ah)
 {
 	/* Initialize the gain optimization values */
@@ -1049,7 +1049,7 @@ static int ath5k_hw_rfregs_init(struct ath5k_hw *ah,
 \**************************/
 
 /*
- * Convertion needed for RF5110
+ * Conversion needed for RF5110
  */
 static u32 ath5k_hw_rf5110_chan2athchan(struct ieee80211_channel *channel)
 {
@@ -1088,7 +1088,7 @@ static int ath5k_hw_rf5110_channel(struct ath5k_hw *ah,
 }
 
 /*
- * Convertion needed for 5111
+ * Conversion needed for 5111
  */
 static int ath5k_hw_rf5111_chan2athchan(unsigned int ieee,
 		struct ath5k_athchan_2ghz *athchan)
@@ -2201,7 +2201,7 @@ ath5k_create_power_curve(s16 pmin, s16 pmax,
 /*
  * Get the surrounding per-channel power calibration piers
  * for a given frequency so that we can interpolate between
- * them and come up with an apropriate dataset for our current
+ * them and come up with an appropriate dataset for our current
  * channel.
  */
 static void
@@ -2618,7 +2618,7 @@ ath5k_write_pcdac_table(struct ath5k_hw *ah)
 /*
  * Set the gain boundaries and create final Power to PDADC table
  *
- * We can have up to 4 pd curves, we need to do a simmilar process
+ * We can have up to 4 pd curves, we need to do a similar process
  * as we do for RF5112. This time we don't have an edge_flag but we
  * set the gain boundaries on a separate register.
  */
@@ -2826,13 +2826,13 @@ ath5k_setup_channel_powertable(struct ath5k_hw *ah,
 	u32 target = channel->center_freq;
 	int pdg, i;
 
-	/* Get surounding freq piers for this channel */
+	/* Get surrounding freq piers for this channel */
 	ath5k_get_chan_pcal_surrounding_piers(ah, channel,
 						&pcinfo_L,
 						&pcinfo_R);
 
 	/* Loop over pd gain curves on
-	 * surounding freq piers by index */
+	 * surrounding freq piers by index */
 	for (pdg = 0; pdg < ee->ee_pd_gains[ee_mode]; pdg++) {
 
 		/* Fill curves in reverse order
@@ -2923,7 +2923,7 @@ ath5k_setup_channel_powertable(struct ath5k_hw *ah,
 		}
 
 		/* Interpolate between curves
-		 * of surounding freq piers to
+		 * of surrounding freq piers to
 		 * get the final curve for this
 		 * pd gain. Re-use tmpL for interpolation
 		 * output */
@@ -2947,7 +2947,7 @@ ath5k_setup_channel_powertable(struct ath5k_hw *ah,
 
 	/* Fill min and max power levels for this
 	 * channel by interpolating the values on
-	 * surounding channels to complete the dataset */
+	 * surrounding channels to complete the dataset */
 	ah->ah_txpower.txp_min_pwr = ath5k_get_interpolated_value(target,
 					(s16) pcinfo_L->freq,
 					(s16) pcinfo_R->freq,
@@ -3179,7 +3179,7 @@ ath5k_hw_txpower(struct ath5k_hw *ah, struct ieee80211_channel *channel,
 
 	/* FIXME: TPC scale reduction */
 
-	/* Get surounding channels for per-rate power table
+	/* Get surrounding channels for per-rate power table
 	 * calibration */
 	ath5k_get_rate_pcal_data(ah, channel, &rate_info);
 
diff --git a/drivers/net/wireless/ath/ath5k/reg.h b/drivers/net/wireless/ath/ath5k/reg.h
index e1c9abd..d12b827 100644
--- a/drivers/net/wireless/ath/ath5k/reg.h
+++ b/drivers/net/wireless/ath/ath5k/reg.h
@@ -132,8 +132,8 @@
  * As i can see in ar5k_ar5210_tx_start Reyk uses some of the values of BCR
  * for this register, so i guess TQ1V,TQ1FV and BDMAE have the same meaning
  * here and SNP/SNAP means "snapshot" (so this register gets synced with BCR).
- * So SNAPPEDBCRVALID sould also stand for "snapped BCR -values- valid", so i
- * renamed it to SNAPSHOTSVALID to make more sense. I realy have no idea what
+ * So SNAPPEDBCRVALID should also stand for "snapped BCR -values- valid", so i
+ * renamed it to SNAPSHOTSVALID to make more sense. I really have no idea what
  * else can it be. I also renamed SNPBCMD to SNPADHOC to match BCR.
  */
 #define AR5K_BSR		0x002c			/* Register Address */
@@ -283,7 +283,7 @@
  */
 #define AR5K_ISR		0x001c			/* Register Address [5210] */
 #define AR5K_PISR		0x0080			/* Register Address [5211+] */
-#define AR5K_ISR_RXOK		0x00000001	/* Frame successfuly recieved */
+#define AR5K_ISR_RXOK		0x00000001	/* Frame successfuly received */
 #define AR5K_ISR_RXDESC		0x00000002	/* RX descriptor request */
 #define AR5K_ISR_RXERR		0x00000004	/* Receive error */
 #define AR5K_ISR_RXNOFRM	0x00000008	/* No frame received (receive timeout) */
@@ -372,12 +372,12 @@
 /*
  * Interrupt Mask Registers
  *
- * As whith ISRs 5210 has one IMR (AR5K_IMR) and 5211/5212 has one primary
+ * As with ISRs 5210 has one IMR (AR5K_IMR) and 5211/5212 has one primary
  * (AR5K_PIMR) and 4 secondary IMRs (AR5K_SIMRx). Note that ISR/IMR flags match.
  */
 #define	AR5K_IMR		0x0020			/* Register Address [5210] */
 #define AR5K_PIMR		0x00a0			/* Register Address [5211+] */
-#define AR5K_IMR_RXOK		0x00000001	/* Frame successfuly recieved*/
+#define AR5K_IMR_RXOK		0x00000001	/* Frame successfuly received*/
 #define AR5K_IMR_RXDESC		0x00000002	/* RX descriptor request*/
 #define AR5K_IMR_RXERR		0x00000004	/* Receive error*/
 #define AR5K_IMR_RXNOFRM	0x00000008	/* No frame received (receive timeout)*/
@@ -895,7 +895,7 @@
 #define AR5K_PCICFG_SL_INTEN		0x00000800	/* Enable interrupts when asleep */
 #define AR5K_PCICFG_LED_BCTL		0x00001000	/* Led blink (?) [5210] */
 #define AR5K_PCICFG_RETRY_FIX		0x00001000	/* Enable pci core retry fix */
-#define AR5K_PCICFG_SL_INPEN		0x00002000	/* Sleep even whith pending interrupts*/
+#define AR5K_PCICFG_SL_INPEN		0x00002000	/* Sleep even with pending interrupts*/
 #define AR5K_PCICFG_SPWR_DN		0x00010000	/* Mask for power status */
 #define AR5K_PCICFG_LEDMODE		0x000e0000	/* Ledmode [5211+] */
 #define AR5K_PCICFG_LEDMODE_PROP	0x00000000	/* Blink on standard traffic [5211+] */
diff --git a/drivers/net/wireless/ath/ath9k/ar5008_phy.c b/drivers/net/wireless/ath/ath9k/ar5008_phy.c
index ffcf44a..106c0b0 100644
--- a/drivers/net/wireless/ath/ath9k/ar5008_phy.c
+++ b/drivers/net/wireless/ath/ath9k/ar5008_phy.c
@@ -142,7 +142,7 @@ static void ar5008_hw_force_bias(struct ath_hw *ah, u16 synth_freq)
 
 /**
  * ar5008_hw_set_channel - tune to a channel on the external AR2133/AR5133 radios
- * @ah: atheros hardware stucture
+ * @ah: atheros hardware structure
  * @chan:
  *
  * For the external AR2133/AR5133 radios, takes the MHz channel value and set
diff --git a/drivers/net/wireless/ath/ath9k/ar9003_eeprom.c b/drivers/net/wireless/ath/ath9k/ar9003_eeprom.c
index 4a92718..6eadf97 100644
--- a/drivers/net/wireless/ath/ath9k/ar9003_eeprom.c
+++ b/drivers/net/wireless/ath/ath9k/ar9003_eeprom.c
@@ -3240,7 +3240,7 @@ static int ar9300_compress_decision(struct ath_hw *ah,
 			eep = ar9003_eeprom_struct_find_by_id(reference);
 			if (eep == NULL) {
 				ath_dbg(common, ATH_DBG_EEPROM,
-					"cant find reference eeprom struct %d\n",
+					"can't find reference eeprom struct %d\n",
 					reference);
 				return -1;
 			}
diff --git a/drivers/net/wireless/ath/ath9k/htc_hst.c b/drivers/net/wireless/ath/ath9k/htc_hst.c
index c41ab8c..62e139a 100644
--- a/drivers/net/wireless/ath/ath9k/htc_hst.c
+++ b/drivers/net/wireless/ath/ath9k/htc_hst.c
@@ -360,7 +360,7 @@ ret:
  * HTC Messages are handled directly here and the obtained SKB
  * is freed.
  *
- * Sevice messages (Data, WMI) passed to the corresponding
+ * Service messages (Data, WMI) passed to the corresponding
  * endpoint RX handlers, which have to free the SKB.
  */
 void ath9k_htc_rx_msg(struct htc_target *htc_handle,
diff --git a/drivers/net/wireless/ath/ath9k/pci.c b/drivers/net/wireless/ath/ath9k/pci.c
index e83128c..9c65459 100644
--- a/drivers/net/wireless/ath/ath9k/pci.c
+++ b/drivers/net/wireless/ath/ath9k/pci.c
@@ -44,7 +44,7 @@ static void ath_pci_read_cachesize(struct ath_common *common, int *csz)
 	*csz = (int)u8tmp;
 
 	/*
-	 * This check was put in to avoid "unplesant" consequences if
+	 * This check was put in to avoid "unpleasant" consequences if
 	 * the bootrom has not fully initialized all PCI devices.
 	 * Sometimes the cache line size register is not set
 	 */
diff --git a/drivers/net/wireless/ath/ath9k/rc.c b/drivers/net/wireless/ath/ath9k/rc.c
index a3241cd..4c0d36a 100644
--- a/drivers/net/wireless/ath/ath9k/rc.c
+++ b/drivers/net/wireless/ath/ath9k/rc.c
@@ -792,7 +792,7 @@ static void ath_get_rate(void *priv, struct ieee80211_sta *sta, void *priv_sta,
 
 		tx_info->flags |= IEEE80211_TX_CTL_RATE_CTRL_PROBE;
 	} else {
-		/* Set the choosen rate. No RTS for first series entry. */
+		/* Set the chosen rate. No RTS for first series entry. */
 		ath_rc_rate_set_series(rate_table, &rates[i++], txrc,
 				       try_per_rate, rix, 0);
 	}
diff --git a/drivers/net/wireless/ath/ath9k/xmit.c b/drivers/net/wireless/ath/ath9k/xmit.c
index 26734e5..88fa7fd 100644
--- a/drivers/net/wireless/ath/ath9k/xmit.c
+++ b/drivers/net/wireless/ath/ath9k/xmit.c
@@ -628,8 +628,8 @@ static u32 ath_lookup_rate(struct ath_softc *sc, struct ath_buf *bf,
 				 (u32)ATH_AMPDU_LIMIT_MAX);
 
 	/*
-	 * h/w can accept aggregates upto 16 bit lengths (65535).
-	 * The IE, however can hold upto 65536, which shows up here
+	 * h/w can accept aggregates up to 16 bit lengths (65535).
+	 * The IE, however can hold up to 65536, which shows up here
 	 * as zero. Ignore 65536 since we  are constrained by hw.
 	 */
 	if (tid->an->maxampdu)
diff --git a/drivers/net/wireless/ath/carl9170/carl9170.h b/drivers/net/wireless/ath/carl9170/carl9170.h
index 9cad061..3d4ed58 100644
--- a/drivers/net/wireless/ath/carl9170/carl9170.h
+++ b/drivers/net/wireless/ath/carl9170/carl9170.h
@@ -161,7 +161,7 @@ struct carl9170_sta_tid {
  * Naturally: The higher the limit, the faster the device CAN send.
  * However, even a slight over-commitment at the wrong time and the
  * hardware is doomed to send all already-queued frames at suboptimal
- * rates. This in turn leads to an enourmous amount of unsuccessful
+ * rates. This in turn leads to an enormous amount of unsuccessful
  * retries => Latency goes up, whereas the throughput goes down. CRASH!
  */
 #define CARL9170_NUM_TX_LIMIT_HARD	((AR9170_TXQ_DEPTH * 3) / 2)
diff --git a/drivers/net/wireless/ath/carl9170/phy.c b/drivers/net/wireless/ath/carl9170/phy.c
index b6b0de6..b6ae0e1 100644
--- a/drivers/net/wireless/ath/carl9170/phy.c
+++ b/drivers/net/wireless/ath/carl9170/phy.c
@@ -427,7 +427,7 @@ static u32 carl9170_def_val(u32 reg, bool is_2ghz, bool is_40mhz)
 
 /*
  * initialize some phy regs from eeprom values in modal_header[]
- * acc. to band and bandwith
+ * acc. to band and bandwidth
  */
 static int carl9170_init_phy_from_eeprom(struct ar9170 *ar,
 				bool is_2ghz, bool is_40mhz)
diff --git a/drivers/net/wireless/ath/carl9170/rx.c b/drivers/net/wireless/ath/carl9170/rx.c
index 84866a4..ec21ea9 100644
--- a/drivers/net/wireless/ath/carl9170/rx.c
+++ b/drivers/net/wireless/ath/carl9170/rx.c
@@ -849,7 +849,7 @@ static void carl9170_rx_stream(struct ar9170 *ar, void *buf, unsigned int len)
 				/*
 				 * nested carl9170_rx_stream call!
 				 *
-				 * termination is guranteed, even when the
+				 * termination is guaranteed, even when the
 				 * combined frame also have an element with
 				 * a bad tag.
 				 */
diff --git a/drivers/net/wireless/ath/carl9170/usb.c b/drivers/net/wireless/ath/carl9170/usb.c
index f82c400..2fb53d0 100644
--- a/drivers/net/wireless/ath/carl9170/usb.c
+++ b/drivers/net/wireless/ath/carl9170/usb.c
@@ -430,7 +430,7 @@ static void carl9170_usb_rx_complete(struct urb *urb)
 			 * The system is too slow to cope with
 			 * the enormous workload. We have simply
 			 * run out of active rx urbs and this
-			 * unfortunatly leads to an unpredictable
+			 * unfortunately leads to an unpredictable
 			 * device.
 			 */
 
diff --git a/drivers/net/wireless/ath/hw.c b/drivers/net/wireless/ath/hw.c
index 183c282..cc11d66 100644
--- a/drivers/net/wireless/ath/hw.c
+++ b/drivers/net/wireless/ath/hw.c
@@ -86,7 +86,7 @@
  * IFRAME-01:  0110
  *
  * An easy eye-inspeciton of this already should tell you that this frame
- * will not pass our check. This is beacuse the bssid_mask tells the
+ * will not pass our check. This is because the bssid_mask tells the
  * hardware to only look at the second least significant bit and the
  * common bit amongst the MAC and BSSIDs is 0, this frame has the 2nd LSB
  * as 1, which does not match 0.
diff --git a/drivers/net/wireless/ath/regd.c b/drivers/net/wireless/ath/regd.c
index f828f29..0e1b879 100644
--- a/drivers/net/wireless/ath/regd.c
+++ b/drivers/net/wireless/ath/regd.c
@@ -268,7 +268,7 @@ ath_reg_apply_active_scan_flags(struct wiphy *wiphy,
 	}
 
 	/*
-	 * If a country IE has been recieved check its rule for this
+	 * If a country IE has been received check its rule for this
 	 * channel first before enabling active scan. The passive scan
 	 * would have been enforced by the initial processing of our
 	 * custom regulatory domain.
@@ -476,7 +476,7 @@ ath_regd_init_wiphy(struct ath_regulatory *reg,
 		wiphy->flags |= WIPHY_FLAG_CUSTOM_REGULATORY;
 	} else {
 		/*
-		 * This gets applied in the case of the absense of CRDA,
+		 * This gets applied in the case of the absence of CRDA,
 		 * it's our own custom world regulatory domain, similar to
 		 * cfg80211's but we enable passive scanning.
 		 */
diff --git a/drivers/net/wireless/atmel.c b/drivers/net/wireless/atmel.c
index 46e382e..39a11e8 100644
--- a/drivers/net/wireless/atmel.c
+++ b/drivers/net/wireless/atmel.c
@@ -439,7 +439,7 @@ static u8 mac_reader[] = {
 };
 
 struct atmel_private {
-	void *card; /* Bus dependent stucture varies for PCcard */
+	void *card; /* Bus dependent structure varies for PCcard */
 	int (*present_callback)(void *); /* And callback which uses it */
 	char firmware_id[32];
 	AtmelFWType firmware_type;
@@ -3895,7 +3895,7 @@ static int reset_atmel_card(struct net_device *dev)
 
 	   This routine is also responsible for initialising some
 	   hardware-specific fields in the atmel_private structure,
-	   including a copy of the firmware's hostinfo stucture
+	   including a copy of the firmware's hostinfo structure
 	   which is the route into the rest of the firmware datastructures. */
 
 	struct atmel_private *priv = netdev_priv(dev);
diff --git a/drivers/net/wireless/atmel_cs.c b/drivers/net/wireless/atmel_cs.c
index c96e19d..0526351 100644
--- a/drivers/net/wireless/atmel_cs.c
+++ b/drivers/net/wireless/atmel_cs.c
@@ -99,7 +99,7 @@ static void atmel_detach(struct pcmcia_device *link)
 }
 
 /* Call-back function to interrogate PCMCIA-specific information
-   about the current existance of the card */
+   about the current existence of the card */
 static int card_present(void *arg)
 {
 	struct pcmcia_device *link = (struct pcmcia_device *)arg;
diff --git a/drivers/net/wireless/b43/b43.h b/drivers/net/wireless/b43/b43.h
index bd4cb75..229f438 100644
--- a/drivers/net/wireless/b43/b43.h
+++ b/drivers/net/wireless/b43/b43.h
@@ -648,7 +648,7 @@ struct b43_request_fw_context {
 	char errors[B43_NR_FWTYPES][128];
 	/* Temporary buffer for storing the firmware name. */
 	char fwname[64];
-	/* A fatal error occured while requesting. Firmware reqest
+	/* A fatal error occurred while requesting. Firmware reqest
 	 * can not continue, as any other reqest will also fail. */
 	int fatal_failure;
 };
diff --git a/drivers/net/wireless/b43/main.c b/drivers/net/wireless/b43/main.c
index 57eb5b6..d59b016 100644
--- a/drivers/net/wireless/b43/main.c
+++ b/drivers/net/wireless/b43/main.c
@@ -4010,7 +4010,7 @@ static int b43_wireless_core_start(struct b43_wldev *dev)
 	b43_mac_enable(dev);
 	b43_write32(dev, B43_MMIO_GEN_IRQ_MASK, dev->irq_mask);
 
-	/* Start maintainance work */
+	/* Start maintenance work */
 	b43_periodic_tasks_setup(dev);
 
 	b43_leds_init(dev);
diff --git a/drivers/net/wireless/b43/phy_g.h b/drivers/net/wireless/b43/phy_g.h
index 8569fdd..5413c90 100644
--- a/drivers/net/wireless/b43/phy_g.h
+++ b/drivers/net/wireless/b43/phy_g.h
@@ -164,7 +164,7 @@ struct b43_phy_g {
 	/* Current Interference Mitigation mode */
 	int interfmode;
 	/* Stack of saved values from the Interference Mitigation code.
-	 * Each value in the stack is layed out as follows:
+	 * Each value in the stack is laid out as follows:
 	 * bit 0-11:  offset
 	 * bit 12-15: register ID
 	 * bit 16-32: value
diff --git a/drivers/net/wireless/b43/phy_n.h b/drivers/net/wireless/b43/phy_n.h
index 001e841..e789a89 100644
--- a/drivers/net/wireless/b43/phy_n.h
+++ b/drivers/net/wireless/b43/phy_n.h
@@ -703,7 +703,7 @@
 #define B43_NPHY_CHAN_ESTHANG			B43_PHY_N(0x21D) /* Channel estimate hang */
 #define B43_NPHY_FINERX2_CGC			B43_PHY_N(0x221) /* Fine RX 2 clock gate control */
 #define  B43_NPHY_FINERX2_CGC_DECGC		0x0008 /* Decode gated clocks */
-#define B43_NPHY_TXPCTL_INIT			B43_PHY_N(0x222) /* TX power controll init */
+#define B43_NPHY_TXPCTL_INIT			B43_PHY_N(0x222) /* TX power control init */
 #define  B43_NPHY_TXPCTL_INIT_PIDXI1		0x00FF /* Power index init 1 */
 #define  B43_NPHY_TXPCTL_INIT_PIDXI1_SHIFT	0
 #define B43_NPHY_PAPD_EN0			B43_PHY_N(0x297) /* PAPD Enable0 TBD */
diff --git a/drivers/net/wireless/b43legacy/b43legacy.h b/drivers/net/wireless/b43legacy/b43legacy.h
index c81b2f5..23583be 100644
--- a/drivers/net/wireless/b43legacy/b43legacy.h
+++ b/drivers/net/wireless/b43legacy/b43legacy.h
@@ -488,7 +488,7 @@ struct b43legacy_phy {
 	/* Current Interference Mitigation mode */
 	int interfmode;
 	/* Stack of saved values from the Interference Mitigation code.
-	 * Each value in the stack is layed out as follows:
+	 * Each value in the stack is laid out as follows:
 	 * bit 0-11:  offset
 	 * bit 12-15: register ID
 	 * bit 16-32: value
diff --git a/drivers/net/wireless/hostap/hostap_ap.c b/drivers/net/wireless/hostap/hostap_ap.c
index 18d63f5..3d05dc1 100644
--- a/drivers/net/wireless/hostap/hostap_ap.c
+++ b/drivers/net/wireless/hostap/hostap_ap.c
@@ -2359,7 +2359,7 @@ int prism2_ap_get_sta_qual(local_info_t *local, struct sockaddr addr[],
 }
 
 
-/* Translate our list of Access Points & Stations to a card independant
+/* Translate our list of Access Points & Stations to a card independent
  * format that the Wireless Tools will understand - Jean II */
 int prism2_ap_translate_scan(struct net_device *dev,
 			     struct iw_request_info *info, char *buffer)
diff --git a/drivers/net/wireless/hostap/hostap_ap.h b/drivers/net/wireless/hostap/hostap_ap.h
index 655ceeb..334e2d0 100644
--- a/drivers/net/wireless/hostap/hostap_ap.h
+++ b/drivers/net/wireless/hostap/hostap_ap.h
@@ -114,7 +114,7 @@ struct sta_info {
  * has passed since last received frame from the station, a nullfunc data
  * frame is sent to the station. If this frame is not acknowledged and no other
  * frames have been received, the station will be disassociated after
- * AP_DISASSOC_DELAY. Similarily, a the station will be deauthenticated after
+ * AP_DISASSOC_DELAY. Similarly, a the station will be deauthenticated after
  * AP_DEAUTH_DELAY. AP_TIMEOUT_RESOLUTION is the resolution that is used with
  * max inactivity timer. */
 #define AP_MAX_INACTIVITY_SEC (5 * 60)
diff --git a/drivers/net/wireless/hostap/hostap_ioctl.c b/drivers/net/wireless/hostap/hostap_ioctl.c
index 6038633..12de464 100644
--- a/drivers/net/wireless/hostap/hostap_ioctl.c
+++ b/drivers/net/wireless/hostap/hostap_ioctl.c
@@ -1945,7 +1945,7 @@ static char * __prism2_translate_scan(local_info_t *local,
 }
 
 
-/* Translate scan data returned from the card to a card independant
+/* Translate scan data returned from the card to a card independent
  * format that the Wireless Tools will understand - Jean II */
 static inline int prism2_translate_scan(local_info_t *local,
 					struct iw_request_info *info,
@@ -2043,7 +2043,7 @@ static inline int prism2_ioctl_giwscan_sta(struct net_device *dev,
 		 * until results are ready for various reasons.
 		 * First, managing wait queues is complex and racy
 		 * (there may be multiple simultaneous callers).
-		 * Second, we grab some rtnetlink lock before comming
+		 * Second, we grab some rtnetlink lock before coming
 		 * here (in dev_ioctl()).
 		 * Third, the caller can wait on the Wireless Event
 		 * - Jean II */
diff --git a/drivers/net/wireless/hostap/hostap_wlan.h b/drivers/net/wireless/hostap/hostap_wlan.h
index 1c66b3c..88dc6a5 100644
--- a/drivers/net/wireless/hostap/hostap_wlan.h
+++ b/drivers/net/wireless/hostap/hostap_wlan.h
@@ -853,7 +853,7 @@ struct local_info {
 	struct work_struct comms_qual_update;
 
 	/* RSSI to dBm adjustment (for RX descriptor fields) */
-	int rssi_to_dBm; /* substract from RSSI to get approximate dBm value */
+	int rssi_to_dBm; /* subtract from RSSI to get approximate dBm value */
 
 	/* BSS list / protected by local->lock */
 	struct list_head bss_list;
diff --git a/drivers/net/wireless/ipw2x00/ipw2100.c b/drivers/net/wireless/ipw2x00/ipw2100.c
index 4b97f91..4430775 100644
--- a/drivers/net/wireless/ipw2x00/ipw2100.c
+++ b/drivers/net/wireless/ipw2x00/ipw2100.c
@@ -63,7 +63,7 @@ When data is sent to the firmware, the first TBD is used to indicate to the
 firmware if a Command or Data is being sent.  If it is Command, all of the
 command information is contained within the physical address referred to by the
 TBD.  If it is Data, the first TBD indicates the type of data packet, number
-of fragments, etc.  The next TBD then referrs to the actual packet location.
+of fragments, etc.  The next TBD then refers to the actual packet location.
 
 The Tx flow cycle is as follows:
 
diff --git a/drivers/net/wireless/ipw2x00/ipw2200.c b/drivers/net/wireless/ipw2x00/ipw2200.c
index 160881f..42c3fe3 100644
--- a/drivers/net/wireless/ipw2x00/ipw2200.c
+++ b/drivers/net/wireless/ipw2x00/ipw2200.c
@@ -1181,7 +1181,7 @@ static void ipw_led_shutdown(struct ipw_priv *priv)
 /*
  * The following adds a new attribute to the sysfs representation
  * of this device driver (i.e. a new file in /sys/bus/pci/drivers/ipw/)
- * used for controling the debug level.
+ * used for controlling the debug level.
  *
  * See the level definitions in ipw for details.
  */
@@ -3763,7 +3763,7 @@ static int ipw_queue_tx_init(struct ipw_priv *priv,
 
 	q->txb = kmalloc(sizeof(q->txb[0]) * count, GFP_KERNEL);
 	if (!q->txb) {
-		IPW_ERROR("vmalloc for auxilary BD structures failed\n");
+		IPW_ERROR("vmalloc for auxiliary BD structures failed\n");
 		return -ENOMEM;
 	}
 
@@ -5581,7 +5581,7 @@ static int ipw_find_adhoc_network(struct ipw_priv *priv,
 		return 0;
 	}
 
-	/* Verify privacy compatability */
+	/* Verify privacy compatibility */
 	if (((priv->capability & CAP_PRIVACY_ON) ? 1 : 0) !=
 	    ((network->capability & WLAN_CAPABILITY_PRIVACY) ? 1 : 0)) {
 		IPW_DEBUG_MERGE("Network '%s (%pM)' excluded "
@@ -5808,7 +5808,7 @@ static int ipw_best_network(struct ipw_priv *priv,
 		return 0;
 	}
 
-	/* Verify privacy compatability */
+	/* Verify privacy compatibility */
 	if (((priv->capability & CAP_PRIVACY_ON) ? 1 : 0) !=
 	    ((network->capability & WLAN_CAPABILITY_PRIVACY) ? 1 : 0)) {
 		IPW_DEBUG_ASSOC("Network '%s (%pM)' excluded "
@@ -8184,7 +8184,7 @@ static void ipw_handle_promiscuous_rx(struct ipw_priv *priv,
 static int is_network_packet(struct ipw_priv *priv,
 				    struct libipw_hdr_4addr *header)
 {
-	/* Filter incoming packets to determine if they are targetted toward
+	/* Filter incoming packets to determine if they are targeted toward
 	 * this network, discarding packets coming from ourselves */
 	switch (priv->ieee->iw_mode) {
 	case IW_MODE_ADHOC:	/* Header: Dest. | Source    | BSSID */
@@ -8340,9 +8340,9 @@ static void ipw_handle_mgmt_packet(struct ipw_priv *priv,
 }
 
 /*
- * Main entry function for recieving a packet with 80211 headers.  This
+ * Main entry function for receiving a packet with 80211 headers.  This
  * should be called when ever the FW has notified us that there is a new
- * skb in the recieve queue.
+ * skb in the receive queue.
  */
 static void ipw_rx(struct ipw_priv *priv)
 {
@@ -8683,7 +8683,7 @@ static int ipw_sw_reset(struct ipw_priv *priv, int option)
  * functions defined in ipw_main to provide the HW interaction.
  *
  * The exception to this is the use of the ipw_get_ordinal()
- * function used to poll the hardware vs. making unecessary calls.
+ * function used to poll the hardware vs. making unnecessary calls.
  *
  */
 
@@ -10419,7 +10419,7 @@ static void ipw_handle_promiscuous_tx(struct ipw_priv *priv,
 
 	memset(&dummystats, 0, sizeof(dummystats));
 
-	/* Filtering of fragment chains is done agains the first fragment */
+	/* Filtering of fragment chains is done against the first fragment */
 	hdr = (void *)txb->fragments[0]->data;
 	if (libipw_is_management(le16_to_cpu(hdr->frame_control))) {
 		if (filter & IPW_PROM_NO_MGMT)
diff --git a/drivers/net/wireless/ipw2x00/libipw_rx.c b/drivers/net/wireless/ipw2x00/libipw_rx.c
index 0de1b18..e5ad76c 100644
--- a/drivers/net/wireless/ipw2x00/libipw_rx.c
+++ b/drivers/net/wireless/ipw2x00/libipw_rx.c
@@ -925,7 +925,7 @@ drop_free:
 static u8 qos_oui[QOS_OUI_LEN] = { 0x00, 0x50, 0xF2 };
 
 /*
-* Make ther structure we read from the beacon packet has
+* Make the structure we read from the beacon packet to have
 * the right values
 */
 static int libipw_verify_qos_info(struct libipw_qos_information_element
diff --git a/drivers/net/wireless/iwlegacy/iwl-core.c b/drivers/net/wireless/iwlegacy/iwl-core.c
index a209a0e..7007d61 100644
--- a/drivers/net/wireless/iwlegacy/iwl-core.c
+++ b/drivers/net/wireless/iwlegacy/iwl-core.c
@@ -1030,7 +1030,7 @@ int iwl_legacy_apm_init(struct iwl_priv *priv)
 	/*
 	 * Enable HAP INTA (interrupt from management bus) to
 	 * wake device's PCI Express link L1a -> L0s
-	 * NOTE:  This is no-op for 3945 (non-existant bit)
+	 * NOTE:  This is no-op for 3945 (non-existent bit)
 	 */
 	iwl_legacy_set_bit(priv, CSR_HW_IF_CONFIG_REG,
 				    CSR_HW_IF_CONFIG_REG_BIT_HAP_WAKE_L1A);
diff --git a/drivers/net/wireless/iwlegacy/iwl-fh.h b/drivers/net/wireless/iwlegacy/iwl-fh.h
index 4e20c7e..6e60918 100644
--- a/drivers/net/wireless/iwlegacy/iwl-fh.h
+++ b/drivers/net/wireless/iwlegacy/iwl-fh.h
@@ -436,7 +436,7 @@
  * @finished_rb_num [0:11] - Indicates the index of the current RB
  * 	in which the last frame was written to
  * @finished_fr_num [0:11] - Indicates the index of the RX Frame
- * 	which was transfered
+ * 	which was transferred
  */
 struct iwl_rb_status {
 	__le16 closed_rb_num;
diff --git a/drivers/net/wireless/iwlegacy/iwl-scan.c b/drivers/net/wireless/iwlegacy/iwl-scan.c
index 60f597f..353234a 100644
--- a/drivers/net/wireless/iwlegacy/iwl-scan.c
+++ b/drivers/net/wireless/iwlegacy/iwl-scan.c
@@ -143,7 +143,7 @@ static void iwl_legacy_do_scan_abort(struct iwl_priv *priv)
 		IWL_DEBUG_SCAN(priv, "Send scan abort failed %d\n", ret);
 		iwl_legacy_force_scan_end(priv);
 	} else
-		IWL_DEBUG_SCAN(priv, "Sucessfully send scan abort\n");
+		IWL_DEBUG_SCAN(priv, "Successfully send scan abort\n");
 }
 
 /**
diff --git a/drivers/net/wireless/iwlegacy/iwl-sta.c b/drivers/net/wireless/iwlegacy/iwl-sta.c
index 47c9da3..66f0fb2 100644
--- a/drivers/net/wireless/iwlegacy/iwl-sta.c
+++ b/drivers/net/wireless/iwlegacy/iwl-sta.c
@@ -110,7 +110,7 @@ static int iwl_legacy_process_add_sta_resp(struct iwl_priv *priv,
 	/*
 	 * XXX: The MAC address in the command buffer is often changed from
 	 * the original sent to the device. That is, the MAC address
-	 * written to the command buffer often is not the same MAC adress
+	 * written to the command buffer often is not the same MAC address
 	 * read from the command buffer when the command returns. This
 	 * issue has not yet been resolved and this debugging is left to
 	 * observe the problem.
diff --git a/drivers/net/wireless/iwlwifi/iwl-agn-ict.c b/drivers/net/wireless/iwlwifi/iwl-agn-ict.c
index b5cb3be..ed0148d 100644
--- a/drivers/net/wireless/iwlwifi/iwl-agn-ict.c
+++ b/drivers/net/wireless/iwlwifi/iwl-agn-ict.c
@@ -69,7 +69,7 @@ int iwl_alloc_isr_ict(struct iwl_priv *priv)
 	if (!priv->_agn.ict_tbl_vir)
 		return -ENOMEM;
 
-	/* align table to PAGE_SIZE boundry */
+	/* align table to PAGE_SIZE boundary */
 	priv->_agn.aligned_ict_tbl_dma = ALIGN(priv->_agn.ict_tbl_dma, PAGE_SIZE);
 
 	IWL_DEBUG_ISR(priv, "ict dma addr %Lx dma aligned %Lx diff %d\n",
diff --git a/drivers/net/wireless/iwlwifi/iwl-core.c b/drivers/net/wireless/iwlwifi/iwl-core.c
index 6c30fa6..bafbe57 100644
--- a/drivers/net/wireless/iwlwifi/iwl-core.c
+++ b/drivers/net/wireless/iwlwifi/iwl-core.c
@@ -1040,7 +1040,7 @@ int iwl_apm_init(struct iwl_priv *priv)
 	/*
 	 * Enable HAP INTA (interrupt from management bus) to
 	 * wake device's PCI Express link L1a -> L0s
-	 * NOTE:  This is no-op for 3945 (non-existant bit)
+	 * NOTE:  This is no-op for 3945 (non-existent bit)
 	 */
 	iwl_set_bit(priv, CSR_HW_IF_CONFIG_REG,
 				    CSR_HW_IF_CONFIG_REG_BIT_HAP_WAKE_L1A);
diff --git a/drivers/net/wireless/iwlwifi/iwl-fh.h b/drivers/net/wireless/iwlwifi/iwl-fh.h
index 55b8370..474009a 100644
--- a/drivers/net/wireless/iwlwifi/iwl-fh.h
+++ b/drivers/net/wireless/iwlwifi/iwl-fh.h
@@ -436,7 +436,7 @@
  * @finished_rb_num [0:11] - Indicates the index of the current RB
  * 	in which the last frame was written to
  * @finished_fr_num [0:11] - Indicates the index of the RX Frame
- * 	which was transfered
+ * 	which was transferred
  */
 struct iwl_rb_status {
 	__le16 closed_rb_num;
diff --git a/drivers/net/wireless/iwlwifi/iwl-scan.c b/drivers/net/wireless/iwlwifi/iwl-scan.c
index 3a4d9e6..914c77e 100644
--- a/drivers/net/wireless/iwlwifi/iwl-scan.c
+++ b/drivers/net/wireless/iwlwifi/iwl-scan.c
@@ -143,7 +143,7 @@ static void iwl_do_scan_abort(struct iwl_priv *priv)
 		IWL_DEBUG_SCAN(priv, "Send scan abort failed %d\n", ret);
 		iwl_force_scan_end(priv);
 	} else
-		IWL_DEBUG_SCAN(priv, "Sucessfully send scan abort\n");
+		IWL_DEBUG_SCAN(priv, "Successfully send scan abort\n");
 }
 
 /**
diff --git a/drivers/net/wireless/iwmc3200wifi/hal.c b/drivers/net/wireless/iwmc3200wifi/hal.c
index 907ac89..1cabcb3 100644
--- a/drivers/net/wireless/iwmc3200wifi/hal.c
+++ b/drivers/net/wireless/iwmc3200wifi/hal.c
@@ -57,7 +57,7 @@
  *   This is due to the fact the host talks exclusively
  *   to the UMAC and so there needs to be a special UMAC
  *   command for talking to the LMAC.
- *   This is how a wifi command is layed out:
+ *   This is how a wifi command is laid out:
  *    ------------------------
  *   | iwm_udma_out_wifi_hdr  |
  *    ------------------------
@@ -72,7 +72,7 @@
  *   Those commands are handled by the device's bootrom,
  *   and are typically sent when the UMAC and the LMAC
  *   are not yet available.
- *    *   This is how a non-wifi command is layed out:
+ *    *   This is how a non-wifi command is laid out:
  *    ---------------------------
  *   | iwm_udma_out_nonwifi_hdr  |
  *    ---------------------------
diff --git a/drivers/net/wireless/iwmc3200wifi/tx.c b/drivers/net/wireless/iwmc3200wifi/tx.c
index 3216621..be98074 100644
--- a/drivers/net/wireless/iwmc3200wifi/tx.c
+++ b/drivers/net/wireless/iwmc3200wifi/tx.c
@@ -197,7 +197,7 @@ int iwm_tx_credit_alloc(struct iwm_priv *iwm, int id, int nb)
 	spin_lock(&iwm->tx_credit.lock);
 
 	if (!iwm_tx_credit_ok(iwm, id, nb)) {
-		IWM_DBG_TX(iwm, DBG, "No credit avaliable for pool[%d]\n", id);
+		IWM_DBG_TX(iwm, DBG, "No credit available for pool[%d]\n", id);
 		ret = -ENOSPC;
 		goto out;
 	}
diff --git a/drivers/net/wireless/libertas/README b/drivers/net/wireless/libertas/README
index 60fd1af..1453eec 100644
--- a/drivers/net/wireless/libertas/README
+++ b/drivers/net/wireless/libertas/README
@@ -70,7 +70,7 @@ rdrf
 	These commands are used to read the MAC, BBP and RF registers from the
 	card.  These commands take one parameter that specifies the offset
 	location that is to be read.  This parameter must be specified in
-	hexadecimal (its possible to preceed preceding the number with a "0x").
+	hexadecimal (its possible to precede preceding the number with a "0x").
 
 	Path: /sys/kernel/debug/libertas_wireless/ethX/registers/
 
@@ -84,7 +84,7 @@ wrrf
 	These commands are used to write the MAC, BBP and RF registers in the
 	card.  These commands take two parameters that specify the offset
 	location and the value that is to be written. This parameters must
-	be specified in hexadecimal (its possible to preceed the number
+	be specified in hexadecimal (its possible to precede the number
 	with a "0x").
 
 	Usage:
diff --git a/drivers/net/wireless/libertas/cfg.c b/drivers/net/wireless/libertas/cfg.c
index 30ef035..5caa2ac 100644
--- a/drivers/net/wireless/libertas/cfg.c
+++ b/drivers/net/wireless/libertas/cfg.c
@@ -1350,7 +1350,7 @@ static int lbs_cfg_connect(struct wiphy *wiphy, struct net_device *dev,
 		 * we remove all keys like in the WPA/WPA2 setup,
 		 * we just don't set RSN.
 		 *
-		 * Therefore: fall-throught
+		 * Therefore: fall-through
 		 */
 	case WLAN_CIPHER_SUITE_TKIP:
 	case WLAN_CIPHER_SUITE_CCMP:
diff --git a/drivers/net/wireless/libertas/if_cs.c b/drivers/net/wireless/libertas/if_cs.c
index fc81211..8712cb2 100644
--- a/drivers/net/wireless/libertas/if_cs.c
+++ b/drivers/net/wireless/libertas/if_cs.c
@@ -913,7 +913,7 @@ static int if_cs_probe(struct pcmcia_device *p_dev)
 		goto out3;
 	}
 
-	/* Clear any interrupt cause that happend while sending
+	/* Clear any interrupt cause that happened while sending
 	 * firmware/initializing card */
 	if_cs_write16(card, IF_CS_CARD_INT_CAUSE, IF_CS_BIT_MASK);
 	if_cs_enable_ints(card);
diff --git a/drivers/net/wireless/libertas/if_spi.h b/drivers/net/wireless/libertas/if_spi.h
index 8b1417d..d2ac1dc 100644
--- a/drivers/net/wireless/libertas/if_spi.h
+++ b/drivers/net/wireless/libertas/if_spi.h
@@ -66,7 +66,7 @@
 #define IF_SPI_HOST_INT_CTRL_REG 0x40	/* Host interrupt controller reg */
 
 #define IF_SPI_CARD_INT_CAUSE_REG 0x44	/* Card interrupt cause reg */
-#define IF_SPI_CARD_INT_STATUS_REG 0x48 /* Card interupt status reg */
+#define IF_SPI_CARD_INT_STATUS_REG 0x48 /* Card interrupt status reg */
 #define IF_SPI_CARD_INT_EVENT_MASK_REG 0x4C /* Card interrupt event mask */
 #define IF_SPI_CARD_INT_STATUS_MASK_REG	0x50 /* Card interrupt status mask */
 
diff --git a/drivers/net/wireless/mac80211_hwsim.c b/drivers/net/wireless/mac80211_hwsim.c
index 56f439d..f4f4257 100644
--- a/drivers/net/wireless/mac80211_hwsim.c
+++ b/drivers/net/wireless/mac80211_hwsim.c
@@ -62,7 +62,7 @@ MODULE_PARM_DESC(fake_hw_scan, "Install fake (no-op) hw-scan handler");
  * 	an intersection to occur but each device will still use their
  * 	respective regulatory requested domains. Subsequent radios will
  * 	use the resulting intersection.
- * @HWSIM_REGTEST_WORLD_ROAM: Used for testing the world roaming. We acomplish
+ * @HWSIM_REGTEST_WORLD_ROAM: Used for testing the world roaming. We accomplish
  *	this by using a custom beacon-capable regulatory domain for the first
  *	radio. All other device world roam.
  * @HWSIM_REGTEST_CUSTOM_WORLD: Used for testing the custom world regulatory
diff --git a/drivers/net/wireless/orinoco/hw.c b/drivers/net/wireless/orinoco/hw.c
index b4772c1..3c7877a 100644
--- a/drivers/net/wireless/orinoco/hw.c
+++ b/drivers/net/wireless/orinoco/hw.c
@@ -1031,7 +1031,7 @@ int __orinoco_hw_set_tkip_key(struct orinoco_private *priv, int key_idx,
 	else
 		buf.tsc[4] = 0x10;
 
-	/* Wait upto 100ms for tx queue to empty */
+	/* Wait up to 100ms for tx queue to empty */
 	for (k = 100; k > 0; k--) {
 		udelay(1000);
 		ret = hermes_read_wordrec(hw, USER_BAP, HERMES_RID_TXQUEUEEMPTY,
diff --git a/drivers/net/wireless/p54/main.c b/drivers/net/wireless/p54/main.c
index 356e6bb..a946991 100644
--- a/drivers/net/wireless/p54/main.c
+++ b/drivers/net/wireless/p54/main.c
@@ -465,7 +465,7 @@ static int p54_set_key(struct ieee80211_hw *dev, enum set_key_cmd cmd,
 
 		if (slot < 0) {
 			/*
-			 * The device supports the choosen algorithm, but the
+			 * The device supports the chosen algorithm, but the
 			 * firmware does not provide enough key slots to store
 			 * all of them.
 			 * But encryption offload for outgoing frames is always
diff --git a/drivers/net/wireless/p54/p54spi.c b/drivers/net/wireless/p54/p54spi.c
index 7ecc0bd..6d9204fe 100644
--- a/drivers/net/wireless/p54/p54spi.c
+++ b/drivers/net/wireless/p54/p54spi.c
@@ -287,7 +287,7 @@ static void p54spi_power_on(struct p54s_priv *priv)
 	enable_irq(gpio_to_irq(p54spi_gpio_irq));
 
 	/*
-	 * need to wait a while before device can be accessed, the lenght
+	 * need to wait a while before device can be accessed, the length
 	 * is just a guess
 	 */
 	msleep(10);
diff --git a/drivers/net/wireless/prism54/islpci_eth.c b/drivers/net/wireless/prism54/islpci_eth.c
index d44f8e2..266d45b 100644
--- a/drivers/net/wireless/prism54/islpci_eth.c
+++ b/drivers/net/wireless/prism54/islpci_eth.c
@@ -113,7 +113,7 @@ islpci_eth_transmit(struct sk_buff *skb, struct net_device *ndev)
 	 * be aligned on a 4-byte boundary. If WDS is enabled add another 6 bytes
 	 * and add WDS address information */
 	if (likely(((long) skb->data & 0x03) | init_wds)) {
-		/* get the number of bytes to add and re-allign */
+		/* get the number of bytes to add and re-align */
 		offset = (4 - (long) skb->data) & 0x03;
 		offset += init_wds ? 6 : 0;
 
@@ -342,7 +342,7 @@ islpci_eth_receive(islpci_private *priv)
 			 priv->pci_map_rx_address[index],
 			 MAX_FRAGMENT_SIZE_RX + 2, PCI_DMA_FROMDEVICE);
 
-	/* update the skb structure and allign the buffer */
+	/* update the skb structure and align the buffer */
 	skb_put(skb, size);
 	if (offset) {
 		/* shift the buffer allocation offset bytes to get the right frame */
diff --git a/drivers/net/wireless/rayctl.h b/drivers/net/wireless/rayctl.h
index 49d9b26..d7646f2 100644
--- a/drivers/net/wireless/rayctl.h
+++ b/drivers/net/wireless/rayctl.h
@@ -578,7 +578,7 @@ struct tx_msg {
     UCHAR  var[1];
 };
 
-/****** ECF Receive Control Stucture (RCS) Area at Shared RAM offset 0x0800  */
+/****** ECF Receive Control Structure (RCS) Area at Shared RAM offset 0x0800  */
 /* Structures for command specific parameters (rcs.var) */
 struct rx_packet_cmd {
     UCHAR rx_data_ptr[2];
diff --git a/drivers/net/wireless/rt2x00/rt2800.h b/drivers/net/wireless/rt2x00/rt2800.h
index 70b9abb..8fbc5fa 100644
--- a/drivers/net/wireless/rt2x00/rt2800.h
+++ b/drivers/net/wireless/rt2x00/rt2800.h
@@ -616,7 +616,7 @@
  * READ_CONTROL: 0 write BBP, 1 read BBP
  * BUSY: ASIC is busy executing BBP commands
  * BBP_PAR_DUR: 0 4 MAC clocks, 1 8 MAC clocks
- * BBP_RW_MODE: 0 serial, 1 paralell
+ * BBP_RW_MODE: 0 serial, 1 parallel
  */
 #define BBP_CSR_CFG			0x101c
 #define BBP_CSR_CFG_VALUE		FIELD32(0x000000ff)
diff --git a/drivers/net/wireless/rt2x00/rt2800lib.c b/drivers/net/wireless/rt2x00/rt2800lib.c
index 2ee6ceb..dbf74d0 100644
--- a/drivers/net/wireless/rt2x00/rt2800lib.c
+++ b/drivers/net/wireless/rt2x00/rt2800lib.c
@@ -1518,7 +1518,7 @@ static void rt2800_config_channel_rf2xxx(struct rt2x00_dev *rt2x00dev,
 	if (rf->channel > 14) {
 		/*
 		 * When TX power is below 0, we should increase it by 7 to
-		 * make it a positive value (Minumum value is -7).
+		 * make it a positive value (Minimum value is -7).
 		 * However this means that values between 0 and 7 have
 		 * double meaning, and we should set a 7DBm boost flag.
 		 */
diff --git a/drivers/net/wireless/rt2x00/rt2x00.h b/drivers/net/wireless/rt2x00/rt2x00.h
index a3940d7..7f10239 100644
--- a/drivers/net/wireless/rt2x00/rt2x00.h
+++ b/drivers/net/wireless/rt2x00/rt2x00.h
@@ -484,13 +484,13 @@ struct rt2x00intf_conf {
 	enum nl80211_iftype type;
 
 	/*
-	 * TSF sync value, this is dependant on the operation type.
+	 * TSF sync value, this is dependent on the operation type.
 	 */
 	enum tsf_sync sync;
 
 	/*
-	 * The MAC and BSSID addressess are simple array of bytes,
-	 * these arrays are little endian, so when sending the addressess
+	 * The MAC and BSSID addresses are simple array of bytes,
+	 * these arrays are little endian, so when sending the addresses
 	 * to the drivers, copy the it into a endian-signed variable.
 	 *
 	 * Note that all devices (except rt2500usb) have 32 bits
@@ -1131,7 +1131,7 @@ void rt2x00queue_stop_queue(struct data_queue *queue);
  * @drop: True to drop all pending frames.
  *
  * This function will flush the queue. After this call
- * the queue is guarenteed to be empty.
+ * the queue is guaranteed to be empty.
  */
 void rt2x00queue_flush_queue(struct data_queue *queue, bool drop);
 
diff --git a/drivers/net/wireless/rt2x00/rt2x00config.c b/drivers/net/wireless/rt2x00/rt2x00config.c
index e7f67d5..9416e36 100644
--- a/drivers/net/wireless/rt2x00/rt2x00config.c
+++ b/drivers/net/wireless/rt2x00/rt2x00config.c
@@ -60,7 +60,7 @@ void rt2x00lib_config_intf(struct rt2x00_dev *rt2x00dev,
 	 * Note that when NULL is passed as address we will send
 	 * 00:00:00:00:00 to the device to clear the address.
 	 * This will prevent the device being confused when it wants
-	 * to ACK frames or consideres itself associated.
+	 * to ACK frames or considers itself associated.
 	 */
 	memset(conf.mac, 0, sizeof(conf.mac));
 	if (mac)
diff --git a/drivers/net/wireless/rt2x00/rt2x00crypto.c b/drivers/net/wireless/rt2x00/rt2x00crypto.c
index 5e9074b..3f5688f 100644
--- a/drivers/net/wireless/rt2x00/rt2x00crypto.c
+++ b/drivers/net/wireless/rt2x00/rt2x00crypto.c
@@ -237,7 +237,7 @@ void rt2x00crypto_rx_insert_iv(struct sk_buff *skb,
 	}
 
 	/*
-	 * NOTE: Always count the payload as transfered,
+	 * NOTE: Always count the payload as transferred,
 	 * even when alignment was set to zero. This is required
 	 * for determining the correct offset for the ICV data.
 	 */
diff --git a/drivers/net/wireless/rt2x00/rt2x00dump.h b/drivers/net/wireless/rt2x00/rt2x00dump.h
index 5d6e0b8..063ebcc 100644
--- a/drivers/net/wireless/rt2x00/rt2x00dump.h
+++ b/drivers/net/wireless/rt2x00/rt2x00dump.h
@@ -51,7 +51,7 @@
  *   [rt2x00dump header][hardware descriptor][ieee802.11 frame]
  *
  * rt2x00dump header: The description of the dumped frame, as well as
- *	additional information usefull for debugging. See &rt2x00dump_hdr.
+ *	additional information useful for debugging. See &rt2x00dump_hdr.
  * hardware descriptor: Descriptor that was used to receive or transmit
  *	the frame.
  * ieee802.11 frame: The actual frame that was received or transmitted.
diff --git a/drivers/net/wireless/rt2x00/rt2x00link.c b/drivers/net/wireless/rt2x00/rt2x00link.c
index c975b0a..29abfde 100644
--- a/drivers/net/wireless/rt2x00/rt2x00link.c
+++ b/drivers/net/wireless/rt2x00/rt2x00link.c
@@ -283,7 +283,7 @@ void rt2x00link_start_tuner(struct rt2x00_dev *rt2x00dev)
 	/**
 	 * While scanning, link tuning is disabled. By default
 	 * the most sensitive settings will be used to make sure
-	 * that all beacons and probe responses will be recieved
+	 * that all beacons and probe responses will be received
 	 * during the scan.
 	 */
 	if (test_bit(DEVICE_STATE_SCANNING, &rt2x00dev->flags))
diff --git a/drivers/net/wireless/rt2x00/rt2x00queue.c b/drivers/net/wireless/rt2x00/rt2x00queue.c
index 4b3c70e..4358051 100644
--- a/drivers/net/wireless/rt2x00/rt2x00queue.c
+++ b/drivers/net/wireless/rt2x00/rt2x00queue.c
@@ -546,7 +546,7 @@ int rt2x00queue_write_tx_frame(struct data_queue *queue, struct sk_buff *skb,
 	}
 
 	/*
-	 * When DMA allocation is required we should guarentee to the
+	 * When DMA allocation is required we should guarantee to the
 	 * driver that the DMA is aligned to a 4-byte boundary.
 	 * However some drivers require L2 padding to pad the payload
 	 * rather then the header. This could be a requirement for
@@ -689,7 +689,7 @@ void rt2x00queue_for_each_entry(struct data_queue *queue,
 	spin_unlock_irqrestore(&queue->index_lock, irqflags);
 
 	/*
-	 * Start from the TX done pointer, this guarentees that we will
+	 * Start from the TX done pointer, this guarantees that we will
 	 * send out all frames in the correct order.
 	 */
 	if (index_start < index_end) {
@@ -883,7 +883,7 @@ void rt2x00queue_flush_queue(struct data_queue *queue, bool drop)
 	}
 
 	/*
-	 * Check if driver supports flushing, we can only guarentee
+	 * Check if driver supports flushing, we can only guarantee
 	 * full support for flushing if the driver is able
 	 * to cancel all pending frames (drop = true).
 	 */
diff --git a/drivers/net/wireless/rt2x00/rt2x00queue.h b/drivers/net/wireless/rt2x00/rt2x00queue.h
index 0c8b0c6..217861f 100644
--- a/drivers/net/wireless/rt2x00/rt2x00queue.h
+++ b/drivers/net/wireless/rt2x00/rt2x00queue.h
@@ -344,8 +344,8 @@ struct txentry_desc {
  *	only be touched after the device has signaled it is done with it.
  * @ENTRY_DATA_PENDING: This entry contains a valid frame and is waiting
  *	for the signal to start sending.
- * @ENTRY_DATA_IO_FAILED: Hardware indicated that an IO error occured
- *	while transfering the data to the hardware. No TX status report will
+ * @ENTRY_DATA_IO_FAILED: Hardware indicated that an IO error occurred
+ *	while transferring the data to the hardware. No TX status report will
  *	be expected from the hardware.
  * @ENTRY_DATA_STATUS_PENDING: The entry has been send to the device and
  *	returned. It is now waiting for the status reporting before the
@@ -365,7 +365,7 @@ enum queue_entry_flags {
  * @flags: Entry flags, see &enum queue_entry_flags.
  * @queue: The data queue (&struct data_queue) to which this entry belongs.
  * @skb: The buffer which is currently being transmitted (for TX queue),
- *	or used to directly recieve data in (for RX queue).
+ *	or used to directly receive data in (for RX queue).
  * @entry_idx: The entry index number.
  * @priv_data: Private data belonging to this queue entry. The pointer
  *	points to data specific to a particular driver and queue type.
@@ -388,7 +388,7 @@ struct queue_entry {
  * @Q_INDEX: Index pointer to the current entry in the queue, if this entry is
  *	owned by the hardware then the queue is considered to be full.
  * @Q_INDEX_DMA_DONE: Index pointer for the next entry which will have been
- *	transfered to the hardware.
+ *	transferred to the hardware.
  * @Q_INDEX_DONE: Index pointer to the next entry which will be completed by
  *	the hardware and for which we need to run the txdone handler. If this
  *	entry is not owned by the hardware the queue is considered to be empty.
@@ -627,7 +627,7 @@ static inline int rt2x00queue_threshold(struct data_queue *queue)
 }
 
 /**
- * rt2x00queue_status_timeout - Check if a timeout occured for STATUS reports
+ * rt2x00queue_status_timeout - Check if a timeout occurred for STATUS reports
  * @queue: Queue to check.
  */
 static inline int rt2x00queue_status_timeout(struct data_queue *queue)
@@ -637,7 +637,7 @@ static inline int rt2x00queue_status_timeout(struct data_queue *queue)
 }
 
 /**
- * rt2x00queue_timeout - Check if a timeout occured for DMA transfers
+ * rt2x00queue_timeout - Check if a timeout occurred for DMA transfers
  * @queue: Queue to check.
  */
 static inline int rt2x00queue_dma_timeout(struct data_queue *queue)
diff --git a/drivers/net/wireless/rt2x00/rt2x00usb.c b/drivers/net/wireless/rt2x00/rt2x00usb.c
index fbe735f..36f388f 100644
--- a/drivers/net/wireless/rt2x00/rt2x00usb.c
+++ b/drivers/net/wireless/rt2x00/rt2x00usb.c
@@ -173,7 +173,7 @@ static void rt2x00usb_work_txdone_entry(struct queue_entry *entry)
 	/*
 	 * If the transfer to hardware succeeded, it does not mean the
 	 * frame was send out correctly. It only means the frame
-	 * was succesfully pushed to the hardware, we have no
+	 * was successfully pushed to the hardware, we have no
 	 * way to determine the transmission status right now.
 	 * (Only indirectly by looking at the failed TX counters
 	 * in the register).
diff --git a/drivers/net/wireless/rt2x00/rt2x00usb.h b/drivers/net/wireless/rt2x00/rt2x00usb.h
index 6aaf51f..e11c759 100644
--- a/drivers/net/wireless/rt2x00/rt2x00usb.h
+++ b/drivers/net/wireless/rt2x00/rt2x00usb.h
@@ -400,7 +400,7 @@ void rt2x00usb_flush_queue(struct data_queue *queue);
  * @rt2x00dev: Pointer to &struct rt2x00_dev
  *
  * Check the health of the USB communication and determine
- * if timeouts have occured. If this is the case, this function
+ * if timeouts have occurred. If this is the case, this function
  * will reset all communication to restore functionality again.
  */
 void rt2x00usb_watchdog(struct rt2x00_dev *rt2x00dev);
diff --git a/drivers/net/wireless/rtlwifi/base.c b/drivers/net/wireless/rtlwifi/base.c
index bb0c781..0d7d93e 100644
--- a/drivers/net/wireless/rtlwifi/base.c
+++ b/drivers/net/wireless/rtlwifi/base.c
@@ -520,7 +520,7 @@ void rtl_get_tcb_desc(struct ieee80211_hw *hw,
 			 *because hw will nerver use hw_rate
 			 *when tcb_desc->use_driver_rate = false
 			 *so we never set highest N rate here,
-			 *and N rate will all be controled by FW
+			 *and N rate will all be controlled by FW
 			 *when tcb_desc->use_driver_rate = false
 			 */
 			if (rtlmac->ht_enable) {
diff --git a/drivers/net/wireless/rtlwifi/pci.c b/drivers/net/wireless/rtlwifi/pci.c
index 9cd7703..5938f6e 100644
--- a/drivers/net/wireless/rtlwifi/pci.c
+++ b/drivers/net/wireless/rtlwifi/pci.c
@@ -395,7 +395,7 @@ static void rtl_pci_init_aspm(struct ieee80211_hw *hw)
 	 * 0 - Disable ASPM,
 	 * 1 - Enable ASPM without Clock Req,
 	 * 2 - Enable ASPM with Clock Req,
-	 * 3 - Alwyas Enable ASPM with Clock Req,
+	 * 3 - Always Enable ASPM with Clock Req,
 	 * 4 - Always Enable ASPM without Clock Req.
 	 * set defult to RTL8192CE:3 RTL8192E:2
 	 * */
diff --git a/drivers/net/wireless/rtlwifi/regd.c b/drivers/net/wireless/rtlwifi/regd.c
index 3336ca9..d26f957 100644
--- a/drivers/net/wireless/rtlwifi/regd.c
+++ b/drivers/net/wireless/rtlwifi/regd.c
@@ -179,7 +179,7 @@ static void _rtl_reg_apply_active_scan_flags(struct wiphy *wiphy,
 	}
 
 	/*
-	 *If a country IE has been recieved check its rule for this
+	 *If a country IE has been received check its rule for this
 	 *channel first before enabling active scan. The passive scan
 	 *would have been enforced by the initial processing of our
 	 *custom regulatory domain.
diff --git a/drivers/net/wireless/rtlwifi/wifi.h b/drivers/net/wireless/rtlwifi/wifi.h
index 01226f8..07db95f 100644
--- a/drivers/net/wireless/rtlwifi/wifi.h
+++ b/drivers/net/wireless/rtlwifi/wifi.h
@@ -1555,7 +1555,7 @@ struct rtl_priv {
 
 
 /***************************************
-    Bluetooth Co-existance Related
+    Bluetooth Co-existence Related
 ****************************************/
 
 enum bt_ant_num {
diff --git a/drivers/net/wireless/wl1251/cmd.c b/drivers/net/wireless/wl1251/cmd.c
index 0ade4bd..81f164b 100644
--- a/drivers/net/wireless/wl1251/cmd.c
+++ b/drivers/net/wireless/wl1251/cmd.c
@@ -104,7 +104,7 @@ int wl1251_cmd_test(struct wl1251 *wl, void *buf, size_t buf_len, u8 answer)
  * @wl: wl struct
  * @id: acx id
  * @buf: buffer for the response, including all headers, must work with dma
- * @len: lenght of buf
+ * @len: length of buf
  */
 int wl1251_cmd_interrogate(struct wl1251 *wl, u16 id, void *buf, size_t len)
 {
diff --git a/drivers/net/wireless/wl1251/rx.c b/drivers/net/wireless/wl1251/rx.c
index c1b3b3f..6af3526 100644
--- a/drivers/net/wireless/wl1251/rx.c
+++ b/drivers/net/wireless/wl1251/rx.c
@@ -179,7 +179,7 @@ static void wl1251_rx_body(struct wl1251 *wl,
 	rx_buffer = skb_put(skb, length);
 	wl1251_mem_read(wl, rx_packet_ring_addr, rx_buffer, length);
 
-	/* The actual lenght doesn't include the target's alignment */
+	/* The actual length doesn't include the target's alignment */
 	skb->len = desc->length  - PLCP_HEADER_LENGTH;
 
 	fc = (u16 *)skb->data;
diff --git a/drivers/net/wireless/wl12xx/cmd.c b/drivers/net/wireless/wl12xx/cmd.c
index f0aa7ab..9632433 100644
--- a/drivers/net/wireless/wl12xx/cmd.c
+++ b/drivers/net/wireless/wl12xx/cmd.c
@@ -359,7 +359,7 @@ int wl1271_cmd_test(struct wl1271 *wl, void *buf, size_t buf_len, u8 answer)
  * @wl: wl struct
  * @id: acx id
  * @buf: buffer for the response, including all headers, must work with dma
- * @len: lenght of buf
+ * @len: length of buf
  */
 int wl1271_cmd_interrogate(struct wl1271 *wl, u16 id, void *buf, size_t len)
 {
diff --git a/drivers/net/wireless/wl12xx/conf.h b/drivers/net/wireless/wl12xx/conf.h
index 856a8a2..8a83238 100644
--- a/drivers/net/wireless/wl12xx/conf.h
+++ b/drivers/net/wireless/wl12xx/conf.h
@@ -497,7 +497,7 @@ struct conf_rx_settings {
 #define CONF_TX_RATE_RETRY_LIMIT       10
 
 /*
- * Rates supported for data packets when operating as AP. Note the absense
+ * Rates supported for data packets when operating as AP. Note the absence
  * of the 22Mbps rate. There is a FW limitation on 12 rates so we must drop
  * one. The rate dropped is not mandatory under any operating mode.
  */
@@ -572,7 +572,7 @@ enum conf_tx_ac {
 	CONF_TX_AC_BK = 1,         /* background */
 	CONF_TX_AC_VI = 2,         /* video */
 	CONF_TX_AC_VO = 3,         /* voice */
-	CONF_TX_AC_CTS2SELF = 4,   /* fictious AC, follows AC_VO */
+	CONF_TX_AC_CTS2SELF = 4,   /* fictitious AC, follows AC_VO */
 	CONF_TX_AC_ANY_TID = 0x1f
 };
 
@@ -1169,7 +1169,7 @@ struct conf_memory_settings {
 
 	/*
 	 * Minimum required free tx memory blocks in order to assure optimum
-	 * performence
+	 * performance
 	 *
 	 * Range: 0-120
 	 */
@@ -1177,7 +1177,7 @@ struct conf_memory_settings {
 
 	/*
 	 * Minimum required free rx memory blocks in order to assure optimum
-	 * performence
+	 * performance
 	 *
 	 * Range: 0-120
 	 */
diff --git a/drivers/net/wireless/wl12xx/io.h b/drivers/net/wireless/wl12xx/io.h
index c1aac82..00c771e 100644
--- a/drivers/net/wireless/wl12xx/io.h
+++ b/drivers/net/wireless/wl12xx/io.h
@@ -94,7 +94,7 @@ static inline int wl1271_translate_addr(struct wl1271 *wl, int addr)
 	 * translated region.
 	 *
 	 * The translated regions occur next to each other in physical device
-	 * memory, so just add the sizes of the preceeding address regions to
+	 * memory, so just add the sizes of the preceding address regions to
 	 * get the offset to the new region.
 	 *
 	 * Currently, only the two first regions are addressed, and the
diff --git a/drivers/net/wireless/wl3501_cs.c b/drivers/net/wireless/wl3501_cs.c
index 3e5befe..fc08f36 100644
--- a/drivers/net/wireless/wl3501_cs.c
+++ b/drivers/net/wireless/wl3501_cs.c
@@ -290,7 +290,7 @@ static void wl3501_get_from_wla(struct wl3501_card *this, u16 src, void *dest,
  *  \               \- IEEE 802.11 -/ \-------------- len --------------/
  *   \-struct wl3501_80211_tx_hdr--/   \-------- Ethernet Frame -------/
  *
- * Return = Postion in Card
+ * Return = Position in Card
  */
 static u16 wl3501_get_tx_buffer(struct wl3501_card *this, u16 len)
 {
@@ -1932,7 +1932,7 @@ static int wl3501_config(struct pcmcia_device *link)
 	this->base_addr = dev->base_addr;
 
 	if (!wl3501_get_flash_mac_addr(this)) {
-		printk(KERN_WARNING "%s: Cant read MAC addr in flash ROM?\n",
+		printk(KERN_WARNING "%s: Can't read MAC addr in flash ROM?\n",
 		       dev->name);
 		unregister_netdev(dev);
 		goto failed;
diff --git a/drivers/net/wireless/zd1211rw/zd_rf_rf2959.c b/drivers/net/wireless/zd1211rw/zd_rf_rf2959.c
index 0597d86..e361174 100644
--- a/drivers/net/wireless/zd1211rw/zd_rf_rf2959.c
+++ b/drivers/net/wireless/zd1211rw/zd_rf_rf2959.c
@@ -169,7 +169,7 @@ static int rf2959_init_hw(struct zd_rf *rf)
 		{ CR85,  0x00 }, { CR86,  0x10 }, { CR87,  0x2A },
 		{ CR88,  0x10 }, { CR89,  0x24 }, { CR90,  0x18 },
 		/* { CR91,  0x18 }, */
-		/* should solve continous CTS frame problems */
+		/* should solve continuous CTS frame problems */
 		{ CR91,  0x00 },
 		{ CR92,  0x0a }, { CR93,  0x00 }, { CR94,  0x01 },
 		{ CR95,  0x00 }, { CR96,  0x40 }, { CR97,  0x37 },
diff --git a/drivers/net/wireless/zd1211rw/zd_rf_uw2453.c b/drivers/net/wireless/zd1211rw/zd_rf_uw2453.c
index 9e74eb1..ba0a0cc 100644
--- a/drivers/net/wireless/zd1211rw/zd_rf_uw2453.c
+++ b/drivers/net/wireless/zd1211rw/zd_rf_uw2453.c
@@ -353,7 +353,7 @@ static int uw2453_init_hw(struct zd_rf *rf)
 	};
 
 	static const u32 rv[] = {
-		UW2453_REGWRITE(4, 0x2b),    /* configure reciever gain */
+		UW2453_REGWRITE(4, 0x2b),    /* configure receiver gain */
 		UW2453_REGWRITE(5, 0x19e4f), /* configure transmitter gain */
 		UW2453_REGWRITE(6, 0xf81ad), /* enable RX/TX filter tuning */
 		UW2453_REGWRITE(7, 0x3fffe), /* disable TX gain in test mode */
diff --git a/drivers/net/xilinx_emaclite.c b/drivers/net/xilinx_emaclite.c
index 2642af4..372572c 100644
--- a/drivers/net/xilinx_emaclite.c
+++ b/drivers/net/xilinx_emaclite.c
@@ -786,7 +786,7 @@ static int xemaclite_mdio_read(struct mii_bus *bus, int phy_id, int reg)
  * @reg:	register number to write to
  * @val:	value to write to the register number specified by reg
  *
- * This fucntion waits till the device is ready to accept a new MDIO
+ * This function waits till the device is ready to accept a new MDIO
  * request and then writes the val to the MDIO Write Data register.
  */
 static int xemaclite_mdio_write(struct mii_bus *bus, int phy_id, int reg,
diff --git a/drivers/net/znet.c b/drivers/net/znet.c
index ae07b3d..ec2800f 100644
--- a/drivers/net/znet.c
+++ b/drivers/net/znet.c
@@ -652,7 +652,7 @@ static irqreturn_t znet_interrupt(int irq, void *dev_id)
 					dev->stats.tx_errors++;
 
 				/* Transceiver may be stuck if cable
-				 * was removed while emiting a
+				 * was removed while emitting a
 				 * packet. Flip it off, then on to
 				 * reset it. This is very empirical,
 				 * but it seems to work. */
diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index c9db49c..8b63a69 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -676,7 +676,7 @@ int __init early_init_dt_scan_chosen(unsigned long node, const char *uname,
 
 	early_init_dt_check_for_initrd(node);
 
-	/* Retreive command line */
+	/* Retrieve command line */
 	p = of_get_flat_dt_prop(node, "bootargs", &l);
 	if (p != NULL && l > 0)
 		strlcpy(cmd_line, p, min((int)l, COMMAND_LINE_SIZE));
diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
index dcd7857..d35e300 100644
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@ -136,7 +136,7 @@ EXPORT_SYMBOL(of_phy_find_device);
  * @hndlr: Link state callback for the network device
  * @iface: PHY data interface type
  *
- * Returns a pointer to the phy_device if successfull.  NULL otherwise
+ * Returns a pointer to the phy_device if successful.  NULL otherwise
  */
 struct phy_device *of_phy_connect(struct net_device *dev,
 				  struct device_node *phy_np,
diff --git a/drivers/parisc/pdc_stable.c b/drivers/parisc/pdc_stable.c
index 1062b8f..246a92f 100644
--- a/drivers/parisc/pdc_stable.c
+++ b/drivers/parisc/pdc_stable.c
@@ -141,7 +141,7 @@ struct pdcspath_attribute paths_attr_##_name = { \
  * @entry: A pointer to an allocated pdcspath_entry.
  * 
  * The general idea is that you don't read from the Stable Storage every time
- * you access the files provided by the facilites. We store a copy of the
+ * you access the files provided by the facilities. We store a copy of the
  * content of the stable storage WRT various paths in these structs. We read
  * these structs when reading the files, and we will write to these structs when
  * writing to the files, and only then write them back to the Stable Storage.
@@ -213,7 +213,7 @@ pdcspath_store(struct pdcspath_entry *entry)
 
 	/* addr, devpath and count must be word aligned */
 	if (pdc_stable_write(entry->addr, devpath, sizeof(*devpath)) != PDC_OK) {
-		printk(KERN_ERR "%s: an error occured when writing to PDC.\n"
+		printk(KERN_ERR "%s: an error occurred when writing to PDC.\n"
 				"It is likely that the Stable Storage data has been corrupted.\n"
 				"Please check it carefully upon next reboot.\n", __func__);
 		WARN_ON(1);
diff --git a/drivers/parport/Kconfig b/drivers/parport/Kconfig
index 855f389..d92185a 100644
--- a/drivers/parport/Kconfig
+++ b/drivers/parport/Kconfig
@@ -142,7 +142,7 @@ config PARPORT_AX88796
 	  the AX88796 network controller chip. This code is also available
 	  as a module (say M), called parport_ax88796.
 
-	  The driver is not dependant on the AX88796 network driver, and
+	  The driver is not dependent on the AX88796 network driver, and
 	  should not interfere with the networking functions of the chip.
 
 config PARPORT_1284
diff --git a/drivers/parport/ieee1284.c b/drivers/parport/ieee1284.c
index 8901ecf..f9fd4b3 100644
--- a/drivers/parport/ieee1284.c
+++ b/drivers/parport/ieee1284.c
@@ -355,7 +355,7 @@ int parport_negotiate (struct parport *port, int mode)
 		return 0;
 	}
 
-	/* Go to compability forward idle mode */
+	/* Go to compatibility forward idle mode */
 	if (port->ieee1284.mode != IEEE1284_MODE_COMPAT)
 		parport_ieee1284_terminate (port);
 
diff --git a/drivers/parport/parport_pc.c b/drivers/parport/parport_pc.c
index 8d62fb7..a3755ff 100644
--- a/drivers/parport/parport_pc.c
+++ b/drivers/parport/parport_pc.c
@@ -1488,7 +1488,7 @@ static void __devinit winbond_check(int io, int key)
 
 	outb(key, io);
 	outb(key, io);     /* Write Magic Sequence to EFER, extended
-			      funtion enable register */
+			      function enable register */
 	outb(0x20, io);    /* Write EFIR, extended function index register */
 	devid = inb(io + 1);  /* Read EFDR, extended function data register */
 	outb(0x21, io);
@@ -1527,7 +1527,7 @@ static void __devinit winbond_check2(int io, int key)
 	x_oldid = inb(io + 2);
 
 	outb(key, io);     /* Write Magic Byte to EFER, extended
-			      funtion enable register */
+			      function enable register */
 	outb(0x20, io + 2);  /* Write EFIR, extended function index register */
 	devid = inb(io + 2);  /* Read EFDR, extended function data register */
 	outb(0x21, io + 1);
@@ -1569,7 +1569,7 @@ static void __devinit smsc_check(int io, int key)
 
 	outb(key, io);
 	outb(key, io);     /* Write Magic Sequence to EFER, extended
-			      funtion enable register */
+			      function enable register */
 	outb(0x0d, io);    /* Write EFIR, extended function index register */
 	oldid = inb(io + 1);  /* Read EFDR, extended function data register */
 	outb(0x0e, io);
diff --git a/drivers/pci/hotplug/acpi_pcihp.c b/drivers/pci/hotplug/acpi_pcihp.c
index 3bc72d1..8f3faf3 100644
--- a/drivers/pci/hotplug/acpi_pcihp.c
+++ b/drivers/pci/hotplug/acpi_pcihp.c
@@ -351,7 +351,7 @@ int acpi_get_hp_hw_control_from_firmware(struct pci_dev *pdev, u32 flags)
 	 * To handle different BIOS behavior, we look for _OSC on a root
 	 * bridge preferentially (according to PCI fw spec). Later for
 	 * OSHP within the scope of the hotplug controller and its parents,
-	 * upto the host bridge under which this controller exists.
+	 * up to the host bridge under which this controller exists.
 	 */
 	handle = acpi_find_root_bridge_handle(pdev);
 	if (handle) {
diff --git a/drivers/pci/hotplug/acpiphp_glue.c b/drivers/pci/hotplug/acpiphp_glue.c
index e610cfe..2f67e9b 100644
--- a/drivers/pci/hotplug/acpiphp_glue.c
+++ b/drivers/pci/hotplug/acpiphp_glue.c
@@ -585,7 +585,7 @@ static void remove_bridge(acpi_handle handle)
 
 	/*
 	 * On root bridges with hotplug slots directly underneath (ie,
-	 * no p2p bridge inbetween), we call cleanup_bridge(). 
+	 * no p2p bridge between), we call cleanup_bridge(). 
 	 *
 	 * The else clause cleans up root bridges that either had no
 	 * hotplug slots at all, or had a p2p bridge underneath.
diff --git a/drivers/pci/hotplug/rpaphp_core.c b/drivers/pci/hotplug/rpaphp_core.c
index ef7411c..758adb5 100644
--- a/drivers/pci/hotplug/rpaphp_core.c
+++ b/drivers/pci/hotplug/rpaphp_core.c
@@ -290,7 +290,7 @@ static int is_php_dn(struct device_node *dn, const int **indexes,
  * @dn: device node of slot
  *
  * This subroutine will register a hotplugable slot with the
- * PCI hotplug infrastructure. This routine is typicaly called
+ * PCI hotplug infrastructure. This routine is typically called
  * during boot time, if the hotplug slots are present at boot time,
  * or is called later, by the dlpar add code, if the slot is
  * being dynamically added during runtime.
diff --git a/drivers/pci/intel-iommu.c b/drivers/pci/intel-iommu.c
index 7da3bef..505c1c7 100644
--- a/drivers/pci/intel-iommu.c
+++ b/drivers/pci/intel-iommu.c
@@ -2265,7 +2265,7 @@ int __init init_dmars(void)
 		/*
 		 * TBD:
 		 * we could share the same root & context tables
-		 * amoung all IOMMU's. Need to Split it later.
+		 * among all IOMMU's. Need to Split it later.
 		 */
 		ret = iommu_alloc_root_entry(iommu);
 		if (ret) {
diff --git a/drivers/pci/intr_remapping.c b/drivers/pci/intr_remapping.c
index a22557b..3607faf 100644
--- a/drivers/pci/intr_remapping.c
+++ b/drivers/pci/intr_remapping.c
@@ -289,7 +289,7 @@ int free_irte(int irq)
  * source validation type
  */
 #define SVT_NO_VERIFY		0x0  /* no verification is required */
-#define SVT_VERIFY_SID_SQ	0x1  /* verify using SID and SQ fiels */
+#define SVT_VERIFY_SID_SQ	0x1  /* verify using SID and SQ fields */
 #define SVT_VERIFY_BUS		0x2  /* verify bus of request-id */
 
 /*
diff --git a/drivers/pci/iova.c b/drivers/pci/iova.c
index 7914951..9606e59 100644
--- a/drivers/pci/iova.c
+++ b/drivers/pci/iova.c
@@ -391,7 +391,7 @@ reserve_iova(struct iova_domain *iovad,
 				break;
 	}
 
-	/* We are here either becasue this is the first reserver node
+	/* We are here either because this is the first reserver node
 	 * or need to insert remaining non overlap addr range
 	 */
 	iova = __insert_new_range(iovad, pfn_lo, pfn_hi);
diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index a8a277a..f8deb3e 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -645,7 +645,7 @@ pci_adjust_legacy_attr(struct pci_bus *b, enum pci_mmap_state mmap_type)
  * a per-bus basis.  This routine creates the files and ties them into
  * their associated read, write and mmap files from pci-sysfs.c
  *
- * On error unwind, but don't propogate the error to the caller
+ * On error unwind, but don't propagate the error to the caller
  * as it is ok to set up the PCI bus without these files.
  */
 void pci_create_legacy_files(struct pci_bus *b)
diff --git a/drivers/pci/quirks.c b/drivers/pci/quirks.c
index bd80f63..5129ed6 100644
--- a/drivers/pci/quirks.c
+++ b/drivers/pci/quirks.c
@@ -263,7 +263,7 @@ static void quirk_vialatency(struct pci_dev *dev)
 	 *	This happens to include the IDE controllers....
 	 *
 	 *	VIA only apply this fix when an SB Live! is present but under
-	 *	both Linux and Windows this isnt enough, and we have seen
+	 *	both Linux and Windows this isn't enough, and we have seen
 	 *	corruption without SB Live! but with things like 3 UDMA IDE
 	 *	controllers. So we ignore that bit of the VIA recommendation..
 	 */
@@ -2680,7 +2680,7 @@ DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_HINT, 0x0020, quirk_hotplug_bridge);
  * This is a quirk for the Ricoh MMC controller found as a part of
  * some mulifunction chips.
 
- * This is very similiar and based on the ricoh_mmc driver written by
+ * This is very similar and based on the ricoh_mmc driver written by
  * Philip Langdale. Thank you for these magic sequences.
  *
  * These chips implement the four main memory card controllers (SD, MMC, MS, xD)
diff --git a/drivers/pcmcia/i82092.c b/drivers/pcmcia/i82092.c
index fc7906e..3e447d0 100644
--- a/drivers/pcmcia/i82092.c
+++ b/drivers/pcmcia/i82092.c
@@ -54,7 +54,7 @@ static struct pccard_operations i82092aa_operations = {
 	.set_mem_map		= i82092aa_set_mem_map,
 };
 
-/* The card can do upto 4 sockets, allocate a structure for each of them */
+/* The card can do up to 4 sockets, allocate a structure for each of them */
 
 struct socket_info {
 	int	number;
diff --git a/drivers/pcmcia/pcmcia_resource.c b/drivers/pcmcia/pcmcia_resource.c
index 42fbf1a..fe77e82 100644
--- a/drivers/pcmcia/pcmcia_resource.c
+++ b/drivers/pcmcia/pcmcia_resource.c
@@ -173,7 +173,7 @@ static int pcmcia_access_config(struct pcmcia_device *p_dev,
 	c = p_dev->function_config;
 
 	if (!(c->state & CONFIG_LOCKED)) {
-		dev_dbg(&p_dev->dev, "Configuration isnt't locked\n");
+		dev_dbg(&p_dev->dev, "Configuration isn't't locked\n");
 		mutex_unlock(&s->ops_mutex);
 		return -EACCES;
 	}
diff --git a/drivers/pcmcia/pxa2xx_lubbock.c b/drivers/pcmcia/pxa2xx_lubbock.c
index 25afe63..c21888e 100644
--- a/drivers/pcmcia/pxa2xx_lubbock.c
+++ b/drivers/pcmcia/pxa2xx_lubbock.c
@@ -187,7 +187,7 @@ lubbock_pcmcia_configure_socket(struct soc_pcmcia_socket *skt,
 			 * We need to hack around the const qualifier as
 			 * well to keep this ugly workaround localized and
 			 * not force it to the rest of the code. Barf bags
-			 * avaliable in the seat pocket in front of you!
+			 * available in the seat pocket in front of you!
 			 */
 			((socket_state_t *)state)->Vcc = 50;
 			((socket_state_t *)state)->Vpp = 50;
diff --git a/drivers/pcmcia/ti113x.h b/drivers/pcmcia/ti113x.h
index 9ffa97d..a717894 100644
--- a/drivers/pcmcia/ti113x.h
+++ b/drivers/pcmcia/ti113x.h
@@ -691,7 +691,7 @@ static int ti12xx_2nd_slot_empty(struct yenta_socket *socket)
 		/*
 		 * those are either single or dual slot CB with additional functions
 		 * like 1394, smartcard reader, etc. check the TIEALL flag for them
-		 * the TIEALL flag binds the IRQ of all functions toghether.
+		 * the TIEALL flag binds the IRQ of all functions together.
 		 * we catch the single slot variants later.
 		 */
 		sysctl = config_readl(socket, TI113X_SYSTEM_CONTROL);
diff --git a/drivers/platform/x86/intel_mid_thermal.c b/drivers/platform/x86/intel_mid_thermal.c
index 6c12db5..c2f4bd8 100644
--- a/drivers/platform/x86/intel_mid_thermal.c
+++ b/drivers/platform/x86/intel_mid_thermal.c
@@ -202,7 +202,7 @@ static int mid_read_temp(struct thermal_zone_device *tzd, unsigned long *temp)
        if (ret)
                return ret;
 
-       /* Shift bits to accomodate the lower two data bits */
+       /* Shift bits to accommodate the lower two data bits */
        adc_val = (data << 2);
        addr++;
 
diff --git a/drivers/pnp/card.c b/drivers/pnp/card.c
index 4a651f6..bc00693 100644
--- a/drivers/pnp/card.c
+++ b/drivers/pnp/card.c
@@ -320,7 +320,7 @@ void pnp_remove_card_device(struct pnp_dev *dev)
  * pnp_request_card_device - Searches for a PnP device under the specified card
  * @clink: pointer to the card link, cannot be NULL
  * @id: pointer to a PnP ID structure that explains the rules for finding the device
- * @from: Starting place to search from. If NULL it will start from the begining.
+ * @from: Starting place to search from. If NULL it will start from the beginning.
  */
 struct pnp_dev *pnp_request_card_device(struct pnp_card_link *clink,
 					const char *id, struct pnp_dev *from)
@@ -369,7 +369,7 @@ err_out:
 
 /**
  * pnp_release_card_device - call this when the driver no longer needs the device
- * @dev: pointer to the PnP device stucture
+ * @dev: pointer to the PnP device structure
  */
 void pnp_release_card_device(struct pnp_dev *dev)
 {
diff --git a/drivers/pnp/pnpbios/bioscalls.c b/drivers/pnp/pnpbios/bioscalls.c
index 8591f6a..b859d16 100644
--- a/drivers/pnp/pnpbios/bioscalls.c
+++ b/drivers/pnp/pnpbios/bioscalls.c
@@ -219,7 +219,7 @@ void pnpbios_print_status(const char *module, u16 status)
 		       module);
 		break;
 	case PNP_HARDWARE_ERROR:
-		printk(KERN_ERR "PnPBIOS: %s: a hardware failure has occured\n",
+		printk(KERN_ERR "PnPBIOS: %s: a hardware failure has occurred\n",
 		       module);
 		break;
 	default:
diff --git a/drivers/pps/Kconfig b/drivers/pps/Kconfig
index f0d3376..258ca59 100644
--- a/drivers/pps/Kconfig
+++ b/drivers/pps/Kconfig
@@ -35,7 +35,7 @@ config NTP_PPS
 	depends on PPS && !NO_HZ
 	help
 	  This option adds support for direct in-kernel time
-	  syncronization using an external PPS signal.
+	  synchronization using an external PPS signal.
 
 	  It doesn't work on tickless systems at the moment.
 
diff --git a/drivers/ps3/ps3-lpm.c b/drivers/ps3/ps3-lpm.c
index 8000985..643697f 100644
--- a/drivers/ps3/ps3-lpm.c
+++ b/drivers/ps3/ps3-lpm.c
@@ -919,7 +919,7 @@ EXPORT_SYMBOL_GPL(ps3_disable_pm);
  * @offset: Offset in bytes from the start of the trace buffer.
  * @buf: Copy destination.
  * @count: Maximum count of bytes to copy.
- * @bytes_copied: Pointer to a variable that will recieve the number of
+ * @bytes_copied: Pointer to a variable that will receive the number of
  *  bytes copied to @buf.
  *
  * On error @buf will contain any successfully copied trace buffer data
@@ -974,7 +974,7 @@ EXPORT_SYMBOL_GPL(ps3_lpm_copy_tb);
  * @offset: Offset in bytes from the start of the trace buffer.
  * @buf: A __user copy destination.
  * @count: Maximum count of bytes to copy.
- * @bytes_copied: Pointer to a variable that will recieve the number of
+ * @bytes_copied: Pointer to a variable that will receive the number of
  *  bytes copied to @buf.
  *
  * On error @buf will contain any successfully copied trace buffer data
@@ -1074,7 +1074,7 @@ EXPORT_SYMBOL_GPL(ps3_disable_pm_interrupts);
 
 /**
  * ps3_lpm_open - Open the logical performance monitor device.
- * @tb_type: Specifies the type of trace buffer lv1 sould use for this lpm
+ * @tb_type: Specifies the type of trace buffer lv1 should use for this lpm
  *  instance, specified by one of enum ps3_lpm_tb_type.
  * @tb_cache: Optional user supplied buffer to use as the trace buffer cache.
  *  If NULL, the driver will allocate and manage an internal buffer.
diff --git a/drivers/ps3/ps3-sys-manager.c b/drivers/ps3/ps3-sys-manager.c
index d37c445..1b98367 100644
--- a/drivers/ps3/ps3-sys-manager.c
+++ b/drivers/ps3/ps3-sys-manager.c
@@ -80,7 +80,7 @@ static void __maybe_unused _dump_sm_header(
  *
  * Currently all messages received from the system manager are either
  * (16 bytes header + 8 bytes payload = 24 bytes) or (16 bytes header
- * + 16 bytes payload = 32 bytes).  This knowlege is used to simplify
+ * + 16 bytes payload = 32 bytes).  This knowledge is used to simplify
  * the logic.
  */
 
diff --git a/drivers/rapidio/rio-scan.c b/drivers/rapidio/rio-scan.c
index 3a59d5f..ee89358 100644
--- a/drivers/rapidio/rio-scan.c
+++ b/drivers/rapidio/rio-scan.c
@@ -295,7 +295,7 @@ static int __devinit rio_add_device(struct rio_dev *rdev)
 }
 
 /**
- * rio_enable_rx_tx_port - enable input reciever and output transmitter of
+ * rio_enable_rx_tx_port - enable input receiver and output transmitter of
  * given port
  * @port: Master port associated with the RIO network
  * @local: local=1 select local port otherwise a far device is reached
diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 3ffc697..0fae51c 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1313,7 +1313,7 @@ static int _regulator_enable(struct regulator_dev *rdev)
 				return -EINVAL;
 
 			/* Query before enabling in case configuration
-			 * dependant.  */
+			 * dependent.  */
 			ret = _regulator_get_enable_time(rdev);
 			if (ret >= 0) {
 				delay = ret;
diff --git a/drivers/regulator/max8952.c b/drivers/regulator/max8952.c
index a8f4ecf..daff7fd 100644
--- a/drivers/regulator/max8952.c
+++ b/drivers/regulator/max8952.c
@@ -262,7 +262,7 @@ static int __devinit max8952_pmic_probe(struct i2c_client *client,
 
 	if (err) {
 		dev_warn(max8952->dev, "VID0/1 gpio invalid: "
-				"DVS not avilable.\n");
+				"DVS not available.\n");
 		max8952->vid0 = 0;
 		max8952->vid1 = 0;
 		/* Mark invalid */
diff --git a/drivers/rtc/interface.c b/drivers/rtc/interface.c
index 8ec6b06..23719f0 100644
--- a/drivers/rtc/interface.c
+++ b/drivers/rtc/interface.c
@@ -454,7 +454,7 @@ EXPORT_SYMBOL_GPL(rtc_update_irq_enable);
  * @rtc: pointer to the rtc device
  *
  * This function is called when an AIE, UIE or PIE mode interrupt
- * has occured (or been emulated).
+ * has occurred (or been emulated).
  *
  * Triggers the registered irq_task function callback.
  */
diff --git a/drivers/rtc/rtc-at91rm9200.c b/drivers/rtc/rtc-at91rm9200.c
index 518a76e..e39b77a 100644
--- a/drivers/rtc/rtc-at91rm9200.c
+++ b/drivers/rtc/rtc-at91rm9200.c
@@ -60,7 +60,7 @@ static void at91_rtc_decodetime(unsigned int timereg, unsigned int calreg,
 	/*
 	 * The Calendar Alarm register does not have a field for
 	 * the year - so these will return an invalid value.  When an
-	 * alarm is set, at91_alarm_year wille store the current year.
+	 * alarm is set, at91_alarm_year will store the current year.
 	 */
 	tm->tm_year  = bcd2bin(date & AT91_RTC_CENT) * 100;	/* century */
 	tm->tm_year += bcd2bin((date & AT91_RTC_YEAR) >> 8);	/* year */
diff --git a/drivers/rtc/rtc-bfin.c b/drivers/rtc/rtc-bfin.c
index ca9cff8..a0fc4cf 100644
--- a/drivers/rtc/rtc-bfin.c
+++ b/drivers/rtc/rtc-bfin.c
@@ -20,9 +20,9 @@
  * write would be discarded and things quickly fall apart.
  *
  * To keep this delay from significantly degrading performance (we, in theory,
- * would have to sleep for up to 1 second everytime we wanted to write a
+ * would have to sleep for up to 1 second every time we wanted to write a
  * register), we only check the write pending status before we start to issue
- * a new write.  We bank on the idea that it doesnt matter when the sync
+ * a new write.  We bank on the idea that it doesn't matter when the sync
  * happens so long as we don't attempt another write before it does.  The only
  * time userspace would take this penalty is when they try and do multiple
  * operations right after another ... but in this case, they need to take the
diff --git a/drivers/rtc/rtc-lpc32xx.c b/drivers/rtc/rtc-lpc32xx.c
index ec8701c..ae16250 100644
--- a/drivers/rtc/rtc-lpc32xx.c
+++ b/drivers/rtc/rtc-lpc32xx.c
@@ -240,7 +240,7 @@ static int __devinit lpc32xx_rtc_probe(struct platform_device *pdev)
 	spin_lock_init(&rtc->lock);
 
 	/*
-	 * The RTC is on a seperate power domain and can keep it's state
+	 * The RTC is on a separate power domain and can keep it's state
 	 * across a chip power cycle. If the RTC has never been previously
 	 * setup, then set it up now for the first time.
 	 */
diff --git a/drivers/rtc/rtc-mrst.c b/drivers/rtc/rtc-mrst.c
index 332a2c4..b2f0968 100644
--- a/drivers/rtc/rtc-mrst.c
+++ b/drivers/rtc/rtc-mrst.c
@@ -342,6 +342,8 @@ vrtc_mrst_do_probe(struct device *dev, struct resource *iomem, int rtc_irq)
 
 	mrst_rtc.irq = rtc_irq;
 	mrst_rtc.iomem = iomem;
+	mrst_rtc.dev = dev;
+	dev_set_drvdata(dev, &mrst_rtc);
 
 	mrst_rtc.rtc = rtc_device_register(driver_name, dev,
 				&mrst_rtc_ops, THIS_MODULE);
@@ -350,8 +352,6 @@ vrtc_mrst_do_probe(struct device *dev, struct resource *iomem, int rtc_irq)
 		goto cleanup0;
 	}
 
-	mrst_rtc.dev = dev;
-	dev_set_drvdata(dev, &mrst_rtc);
 	rename_region(iomem, dev_name(&mrst_rtc.rtc->dev));
 
 	spin_lock_irq(&rtc_lock);
@@ -376,9 +376,10 @@ vrtc_mrst_do_probe(struct device *dev, struct resource *iomem, int rtc_irq)
 	return 0;
 
 cleanup1:
-	mrst_rtc.dev = NULL;
 	rtc_device_unregister(mrst_rtc.rtc);
 cleanup0:
+	dev_set_drvdata(dev, NULL);
+	mrst_rtc.dev = NULL;
 	release_region(iomem->start, iomem->end + 1 - iomem->start);
 	dev_err(dev, "rtc-mrst: unable to initialise\n");
 	return retval;
diff --git a/drivers/rtc/rtc-x1205.c b/drivers/rtc/rtc-x1205.c
index 9aae491..b00aad2 100644
--- a/drivers/rtc/rtc-x1205.c
+++ b/drivers/rtc/rtc-x1205.c
@@ -573,7 +573,7 @@ static int x1205_probe(struct i2c_client *client,
 
 	i2c_set_clientdata(client, rtc);
 
-	/* Check for power failures and eventualy enable the osc */
+	/* Check for power failures and eventually enable the osc */
 	if ((err = x1205_get_status(client, &sr)) == 0) {
 		if (sr & X1205_SR_RTCF) {
 			dev_err(&client->dev,
diff --git a/drivers/s390/block/dasd_3990_erp.c b/drivers/s390/block/dasd_3990_erp.c
index 1654a24..87a0cf1 100644
--- a/drivers/s390/block/dasd_3990_erp.c
+++ b/drivers/s390/block/dasd_3990_erp.c
@@ -2207,7 +2207,7 @@ dasd_3990_erp_inspect_32(struct dasd_ccw_req * erp, char *sense)
  * DASD_3990_ERP_CONTROL_CHECK
  *
  * DESCRIPTION
- *   Does a generic inspection if a control check occured and sets up
+ *   Does a generic inspection if a control check occurred and sets up
  *   the related error recovery procedure
  *
  * PARAMETER
@@ -2250,7 +2250,7 @@ dasd_3990_erp_inspect(struct dasd_ccw_req *erp)
 	struct dasd_ccw_req *erp_new = NULL;
 	char *sense;
 
-	/* if this problem occured on an alias retry on base */
+	/* if this problem occurred on an alias retry on base */
 	erp_new = dasd_3990_erp_inspect_alias(erp);
 	if (erp_new)
 		return erp_new;
@@ -2282,7 +2282,7 @@ dasd_3990_erp_inspect(struct dasd_ccw_req *erp)
  * DASD_3990_ERP_ADD_ERP
  *
  * DESCRIPTION
- *   This funtion adds an additional request block (ERP) to the head of
+ *   This function adds an additional request block (ERP) to the head of
  *   the given cqr (or erp).
  *   For a command mode cqr the erp is initialized as an default erp
  *   (retry TIC).
diff --git a/drivers/s390/block/dasd_devmap.c b/drivers/s390/block/dasd_devmap.c
index cb6a67b..42e1bf3 100644
--- a/drivers/s390/block/dasd_devmap.c
+++ b/drivers/s390/block/dasd_devmap.c
@@ -302,7 +302,7 @@ dasd_parse_keyword( char *parsestring ) {
 /*
  * Try to interprete the first element on the comma separated parse string
  * as a device number or a range of devices. If the interpretation is
- * successfull, create the matching dasd_devmap entries and return a pointer
+ * successful, create the matching dasd_devmap entries and return a pointer
  * to the residual string.
  * If interpretation fails or in case of an error, return an error code.
  */
diff --git a/drivers/s390/block/dasd_eckd.c b/drivers/s390/block/dasd_eckd.c
index 459f2cb..db8005d 100644
--- a/drivers/s390/block/dasd_eckd.c
+++ b/drivers/s390/block/dasd_eckd.c
@@ -2858,7 +2858,7 @@ static struct dasd_ccw_req *dasd_raw_build_cp(struct dasd_device *startdev,
 	/*
 	 * struct PFX_eckd_data has up to 2 byte as extended parameter
 	 * this is needed for write full track and has to be mentioned
-	 * seperately
+	 * separately
 	 * add 8 instead of 2 to keep 8 byte boundary
 	 */
 	pfx_datasize = sizeof(struct PFX_eckd_data) + 8;
diff --git a/drivers/s390/char/raw3270.c b/drivers/s390/char/raw3270.c
index 4c02376..e21a5c3 100644
--- a/drivers/s390/char/raw3270.c
+++ b/drivers/s390/char/raw3270.c
@@ -604,7 +604,7 @@ __raw3270_size_device(struct raw3270 *rp)
 	/*
 	 * To determine the size of the 3270 device we need to do:
 	 * 1) send a 'read partition' data stream to the device
-	 * 2) wait for the attn interrupt that preceeds the query reply
+	 * 2) wait for the attn interrupt that precedes the query reply
 	 * 3) do a read modified to get the query reply
 	 * To make things worse we have to cope with intervention
 	 * required (3270 device switched to 'stand-by') and command
diff --git a/drivers/s390/char/tape_char.c b/drivers/s390/char/tape_char.c
index e090a30..87cd0ab 100644
--- a/drivers/s390/char/tape_char.c
+++ b/drivers/s390/char/tape_char.c
@@ -139,7 +139,7 @@ tapechar_read(struct file *filp, char __user *data, size_t count, loff_t *ppos)
 	/*
 	 * If the tape isn't terminated yet, do it now. And since we then
 	 * are at the end of the tape there wouldn't be anything to read
-	 * anyways. So we return immediatly.
+	 * anyways. So we return immediately.
 	 */
 	if(device->required_tapemarks) {
 		return tape_std_terminate_write(device);
diff --git a/drivers/s390/char/tty3270.c b/drivers/s390/char/tty3270.c
index d33554df..2db1482 100644
--- a/drivers/s390/char/tty3270.c
+++ b/drivers/s390/char/tty3270.c
@@ -328,7 +328,7 @@ tty3270_write_callback(struct raw3270_request *rq, void *data)
 
 	tp = (struct tty3270 *) rq->view;
 	if (rq->rc != 0) {
-		/* Write wasn't successfull. Refresh all. */
+		/* Write wasn't successful. Refresh all. */
 		tp->update_flags = TTY_UPDATE_ALL;
 		tty3270_set_timer(tp, 1);
 	}
diff --git a/drivers/s390/cio/device.c b/drivers/s390/cio/device.c
index df14c51..8e04c00 100644
--- a/drivers/s390/cio/device.c
+++ b/drivers/s390/cio/device.c
@@ -541,15 +541,24 @@ static ssize_t online_store (struct device *dev, struct device_attribute *attr,
 	int force, ret;
 	unsigned long i;
 
-	if (!dev_fsm_final_state(cdev) &&
-	    cdev->private->state != DEV_STATE_DISCONNECTED)
-		return -EAGAIN;
+	/* Prevent conflict between multiple on-/offline processing requests. */
 	if (atomic_cmpxchg(&cdev->private->onoff, 0, 1) != 0)
 		return -EAGAIN;
+	/* Prevent conflict between internal I/Os and on-/offline processing. */
+	if (!dev_fsm_final_state(cdev) &&
+	    cdev->private->state != DEV_STATE_DISCONNECTED) {
+		ret = -EAGAIN;
+		goto out_onoff;
+	}
+	/* Prevent conflict between pending work and on-/offline processing.*/
+	if (work_pending(&cdev->private->todo_work)) {
+		ret = -EAGAIN;
+		goto out_onoff;
+	}
 
 	if (cdev->drv && !try_module_get(cdev->drv->driver.owner)) {
-		atomic_set(&cdev->private->onoff, 0);
-		return -EINVAL;
+		ret = -EINVAL;
+		goto out_onoff;
 	}
 	if (!strncmp(buf, "force\n", count)) {
 		force = 1;
@@ -574,6 +583,7 @@ static ssize_t online_store (struct device *dev, struct device_attribute *attr,
 out:
 	if (cdev->drv)
 		module_put(cdev->drv->driver.owner);
+out_onoff:
 	atomic_set(&cdev->private->onoff, 0);
 	return (ret < 0) ? ret : count;
 }
@@ -1311,10 +1321,12 @@ static int purge_fn(struct device *dev, void *data)
 
 	spin_lock_irq(cdev->ccwlock);
 	if (is_blacklisted(id->ssid, id->devno) &&
-	    (cdev->private->state == DEV_STATE_OFFLINE)) {
+	    (cdev->private->state == DEV_STATE_OFFLINE) &&
+	    (atomic_cmpxchg(&cdev->private->onoff, 0, 1) == 0)) {
 		CIO_MSG_EVENT(3, "ccw: purging 0.%x.%04x\n", id->ssid,
 			      id->devno);
 		ccw_device_sched_todo(cdev, CDEV_TODO_UNREG);
+		atomic_set(&cdev->private->onoff, 0);
 	}
 	spin_unlock_irq(cdev->ccwlock);
 	/* Abort loop in case of pending signal. */
diff --git a/drivers/s390/cio/device_fsm.c b/drivers/s390/cio/device_fsm.c
index a845695..6084103 100644
--- a/drivers/s390/cio/device_fsm.c
+++ b/drivers/s390/cio/device_fsm.c
@@ -318,7 +318,7 @@ ccw_device_sense_id_done(struct ccw_device *cdev, int err)
 
 /**
   * ccw_device_notify() - inform the device's driver about an event
-  * @cdev: device for which an event occured
+  * @cdev: device for which an event occurred
   * @event: event that occurred
   *
   * Returns:
@@ -688,7 +688,7 @@ ccw_device_online_verify(struct ccw_device *cdev, enum dev_event dev_event)
 	    (scsw_stctl(&cdev->private->irb.scsw) & SCSW_STCTL_STATUS_PEND)) {
 		/*
 		 * No final status yet or final status not yet delivered
-		 * to the device driver. Can't do path verfication now,
+		 * to the device driver. Can't do path verification now,
 		 * delay until final status was delivered.
 		 */
 		cdev->private->flags.doverify = 1;
diff --git a/drivers/s390/cio/qdio_main.c b/drivers/s390/cio/qdio_main.c
index 479c665..c532ba9 100644
--- a/drivers/s390/cio/qdio_main.c
+++ b/drivers/s390/cio/qdio_main.c
@@ -1649,26 +1649,26 @@ static int __init init_QDIO(void)
 {
 	int rc;
 
-	rc = qdio_setup_init();
+	rc = qdio_debug_init();
 	if (rc)
 		return rc;
+	rc = qdio_setup_init();
+	if (rc)
+		goto out_debug;
 	rc = tiqdio_allocate_memory();
 	if (rc)
 		goto out_cache;
-	rc = qdio_debug_init();
-	if (rc)
-		goto out_ti;
 	rc = tiqdio_register_thinints();
 	if (rc)
-		goto out_debug;
+		goto out_ti;
 	return 0;
 
-out_debug:
-	qdio_debug_exit();
 out_ti:
 	tiqdio_free_memory();
 out_cache:
 	qdio_setup_exit();
+out_debug:
+	qdio_debug_exit();
 	return rc;
 }
 
@@ -1676,8 +1676,8 @@ static void __exit exit_QDIO(void)
 {
 	tiqdio_unregister_thinints();
 	tiqdio_free_memory();
-	qdio_debug_exit();
 	qdio_setup_exit();
+	qdio_debug_exit();
 }
 
 module_init(init_QDIO);
diff --git a/drivers/s390/crypto/zcrypt_api.h b/drivers/s390/crypto/zcrypt_api.h
index 88ebd11..9688f39 100644
--- a/drivers/s390/crypto/zcrypt_api.h
+++ b/drivers/s390/crypto/zcrypt_api.h
@@ -76,7 +76,7 @@ struct ica_z90_status {
 
 /**
  * Large random numbers are pulled in 4096 byte chunks from the crypto cards
- * and stored in a page. Be carefull when increasing this buffer due to size
+ * and stored in a page. Be careful when increasing this buffer due to size
  * limitations for AP requests.
  */
 #define ZCRYPT_RNG_BUFFER_SIZE	4096
diff --git a/drivers/s390/net/claw.c b/drivers/s390/net/claw.c
index 9feb62f..da8aa75 100644
--- a/drivers/s390/net/claw.c
+++ b/drivers/s390/net/claw.c
@@ -779,7 +779,7 @@ claw_irq_handler(struct ccw_device *cdev,
 	case CLAW_START_WRITE:
 		if (p_ch->irb->scsw.cmd.dstat & DEV_STAT_UNIT_CHECK) {
 			dev_info(&cdev->dev,
-				"%s: Unit Check Occured in "
+				"%s: Unit Check Occurred in "
 				"write channel\n", dev->name);
 			clear_bit(0, (void *)&p_ch->IO_active);
 			if (p_ch->irb->ecw[0] & 0x80) {
diff --git a/drivers/s390/net/ctcm_fsms.c b/drivers/s390/net/ctcm_fsms.c
index 8c921fc..2d60220 100644
--- a/drivers/s390/net/ctcm_fsms.c
+++ b/drivers/s390/net/ctcm_fsms.c
@@ -184,7 +184,7 @@ static void ctcmpc_chx_resend(fsm_instance *, int, void *);
 static void ctcmpc_chx_send_sweep(fsm_instance *fsm, int event, void *arg);
 
 /**
- * Check return code of a preceeding ccw_device call, halt_IO etc...
+ * Check return code of a preceding ccw_device call, halt_IO etc...
  *
  * ch	:	The channel, the error belongs to.
  * Returns the error code (!= 0) to inspect.
diff --git a/drivers/s390/net/lcs.c b/drivers/s390/net/lcs.c
index 7fbc4ad..49d1cfc 100644
--- a/drivers/s390/net/lcs.c
+++ b/drivers/s390/net/lcs.c
@@ -1123,7 +1123,7 @@ list_modified:
 	list_for_each_entry_safe(ipm, tmp, &card->ipm_list, list){
 		switch (ipm->ipm_state) {
 		case LCS_IPM_STATE_SET_REQUIRED:
-			/* del from ipm_list so noone else can tamper with
+			/* del from ipm_list so no one else can tamper with
 			 * this entry */
 			list_del_init(&ipm->list);
 			spin_unlock_irqrestore(&card->ipm_lock, flags);
diff --git a/drivers/s390/net/qeth_core_main.c b/drivers/s390/net/qeth_core_main.c
index 10a3a3b..85cc531 100644
--- a/drivers/s390/net/qeth_core_main.c
+++ b/drivers/s390/net/qeth_core_main.c
@@ -1107,7 +1107,7 @@ static int qeth_setup_card(struct qeth_card *card)
 	INIT_LIST_HEAD(card->ip_tbd_list);
 	INIT_LIST_HEAD(&card->cmd_waiter_list);
 	init_waitqueue_head(&card->wait_q);
-	/* intial options */
+	/* initial options */
 	qeth_set_intial_options(card);
 	/* IP address takeover */
 	INIT_LIST_HEAD(&card->ipato.entries);
diff --git a/drivers/s390/scsi/zfcp_fsf.c b/drivers/s390/scsi/zfcp_fsf.c
index a0e05ef..8512b5c 100644
--- a/drivers/s390/scsi/zfcp_fsf.c
+++ b/drivers/s390/scsi/zfcp_fsf.c
@@ -1083,7 +1083,7 @@ static void zfcp_fsf_send_els_handler(struct zfcp_fsf_req *req)
 		}
 		break;
 	case FSF_SBAL_MISMATCH:
-		/* should never occure, avoided in zfcp_fsf_send_els */
+		/* should never occur, avoided in zfcp_fsf_send_els */
 		/* fall through */
 	default:
 		req->status |= ZFCP_STATUS_FSFREQ_ERROR;
diff --git a/drivers/s390/scsi/zfcp_qdio.c b/drivers/s390/scsi/zfcp_qdio.c
index 8da5ed6..98e97d9 100644
--- a/drivers/s390/scsi/zfcp_qdio.c
+++ b/drivers/s390/scsi/zfcp_qdio.c
@@ -391,7 +391,7 @@ int zfcp_qdio_open(struct zfcp_qdio *qdio)
 	if (do_QDIO(cdev, QDIO_FLAG_SYNC_INPUT, 0, 0, QDIO_MAX_BUFFERS_PER_Q))
 		goto failed_qdio;
 
-	/* set index of first avalable SBALS / number of available SBALS */
+	/* set index of first available SBALS / number of available SBALS */
 	qdio->req_q_idx = 0;
 	atomic_set(&qdio->req_q_free, QDIO_MAX_BUFFERS_PER_Q);
 	atomic_set_mask(ZFCP_STATUS_ADAPTER_QDIOUP, &qdio->adapter->status);
diff --git a/drivers/sbus/char/jsflash.c b/drivers/sbus/char/jsflash.c
index e856622..6b4678a 100644
--- a/drivers/sbus/char/jsflash.c
+++ b/drivers/sbus/char/jsflash.c
@@ -13,7 +13,7 @@
  * TODO: Erase/program both banks of a 8MB SIMM.
  *
  * It is anticipated that programming an OS Flash will be a routine
- * procedure. In the same time it is exeedingly dangerous because
+ * procedure. In the same time it is exceedingly dangerous because
  * a user can program its OBP flash with OS image and effectively
  * kill the machine.
  *
diff --git a/drivers/sbus/char/max1617.h b/drivers/sbus/char/max1617.h
index 0bb09c2..cd30819 100644
--- a/drivers/sbus/char/max1617.h
+++ b/drivers/sbus/char/max1617.h
@@ -6,7 +6,7 @@
 #define MAX1617_CPU_TEMP	0x01 /* Processor die temp in C	*/
 #define MAX1617_STATUS		0x02 /* Chip status bits	*/
 
-/* Read-only versions of changable registers. */
+/* Read-only versions of changeable registers. */
 #define MAX1617_RD_CFG_BYTE	0x03 /* Config register		*/
 #define MAX1617_RD_CVRATE_BYTE	0x04 /* Temp conversion rate	*/
 #define MAX1617_RD_AMB_HIGHLIM	0x05 /* Ambient high limit	*/
diff --git a/drivers/scsi/3w-9xxx.h b/drivers/scsi/3w-9xxx.h
index 3343824..040f721 100644
--- a/drivers/scsi/3w-9xxx.h
+++ b/drivers/scsi/3w-9xxx.h
@@ -61,7 +61,7 @@ static twa_message_type twa_aen_table[] = {
 	{0x0000, "AEN queue empty"},
 	{0x0001, "Controller reset occurred"},
 	{0x0002, "Degraded unit detected"},
-	{0x0003, "Controller error occured"},
+	{0x0003, "Controller error occurred"},
 	{0x0004, "Background rebuild failed"},
 	{0x0005, "Background rebuild done"},
 	{0x0006, "Incomplete unit detected"},
diff --git a/drivers/scsi/3w-xxxx.h b/drivers/scsi/3w-xxxx.h
index 8b9f9d1..49dcf03 100644
--- a/drivers/scsi/3w-xxxx.h
+++ b/drivers/scsi/3w-xxxx.h
@@ -8,7 +8,7 @@
 
    Copyright (C) 1999-2010 3ware Inc.
 
-   Kernel compatiblity By:	Andre Hedrick <andre@suse.com>
+   Kernel compatibility By:	Andre Hedrick <andre@suse.com>
    Non-Copyright (C) 2000	Andre Hedrick <andre@suse.com>
 
    This program is free software; you can redistribute it and/or modify
diff --git a/drivers/scsi/53c700.scr b/drivers/scsi/53c700.scr
index a064a09..ec822e3 100644
--- a/drivers/scsi/53c700.scr
+++ b/drivers/scsi/53c700.scr
@@ -31,7 +31,7 @@ ABSOLUTE	StatusAddress = 0	; Addr to receive status return
 ABSOLUTE	ReceiveMsgAddress = 0	; Addr to receive msg
 ;
 ; This is the magic component for handling scatter-gather.  Each of the
-; SG components is preceeded by a script fragment which moves the
+; SG components is preceded by a script fragment which moves the
 ; necessary amount of data and jumps to the next SG segment.  The final
 ; SG segment jumps back to .  However, this address is the first SG script
 ; segment.
diff --git a/drivers/scsi/53c700_d.h_shipped b/drivers/scsi/53c700_d.h_shipped
index 0b42a51..aa623da 100644
--- a/drivers/scsi/53c700_d.h_shipped
+++ b/drivers/scsi/53c700_d.h_shipped
@@ -34,7 +34,7 @@ ABSOLUTE	StatusAddress = 0	; Addr to receive status return
 ABSOLUTE	ReceiveMsgAddress = 0	; Addr to receive msg
 ;
 ; This is the magic component for handling scatter-gather.  Each of the
-; SG components is preceeded by a script fragment which moves the
+; SG components is preceded by a script fragment which moves the
 ; necessary amount of data and jumps to the next SG segment.  The final
 ; SG segment jumps back to .  However, this address is the first SG script
 ; segment.
diff --git a/drivers/scsi/FlashPoint.c b/drivers/scsi/FlashPoint.c
index e40cdfb..dcd716d 100644
--- a/drivers/scsi/FlashPoint.c
+++ b/drivers/scsi/FlashPoint.c
@@ -2509,7 +2509,7 @@ static void FPT_ssel(unsigned long port, unsigned char p_card)
 				WR_HARPOON(port + hp_autostart_3,
 					   (SELECT + SELCHK_STRT));
 
-				/* Setup our STATE so we know what happend when
+				/* Setup our STATE so we know what happened when
 				   the wheels fall off. */
 				currSCCB->Sccb_scsistat = SELECT_ST;
 
@@ -2900,7 +2900,7 @@ static void FPT_SendMsg(unsigned long port, unsigned char message)
  *
  * Function: FPT_sdecm
  *
- * Description: Determine the proper responce to the message from the
+ * Description: Determine the proper response to the message from the
  *              target device.
  *
  *---------------------------------------------------------------------*/
diff --git a/drivers/scsi/NCR5380.c b/drivers/scsi/NCR5380.c
index e7cd2fc..165e4dd86 100644
--- a/drivers/scsi/NCR5380.c
+++ b/drivers/scsi/NCR5380.c
@@ -1198,12 +1198,12 @@ static irqreturn_t NCR5380_intr(int dummy, void *dev_id)
 				 */
 
 				if ((NCR5380_read(MODE_REG) & MR_DMA) && ((basr & BASR_END_DMA_TRANSFER) || !(basr & BASR_PHASE_MATCH))) {
-					int transfered;
+					int transferred;
 
 					if (!hostdata->connected)
 						panic("scsi%d : received end of DMA interrupt with no connected cmd\n", instance->hostno);
 
-					transfered = (hostdata->dmalen - NCR5380_dma_residual(instance));
+					transferred = (hostdata->dmalen - NCR5380_dma_residual(instance));
 					hostdata->connected->SCp.this_residual -= transferred;
 					hostdata->connected->SCp.ptr += transferred;
 					hostdata->dmalen = 0;
@@ -1563,7 +1563,7 @@ failed:
  *      bytes to transfer, **data - pointer to data pointer.
  * 
  * Returns : -1 when different phase is entered without transferring
- *      maximum number of bytes, 0 if all bytes or transfered or exit
+ *      maximum number of bytes, 0 if all bytes or transferred or exit
  *      is in same phase.
  *
  *      Also, *phase, *count, *data are modified in place.
@@ -1800,7 +1800,7 @@ static int do_abort(struct Scsi_Host *host) {
  *      bytes to transfer, **data - pointer to data pointer.
  * 
  * Returns : -1 when different phase is entered without transferring
- *      maximum number of bytes, 0 if all bytes or transfered or exit
+ *      maximum number of bytes, 0 if all bytes or transferred or exit
  *      is in same phase.
  *
  *      Also, *phase, *count, *data are modified in place.
diff --git a/drivers/scsi/aacraid/aachba.c b/drivers/scsi/aacraid/aachba.c
index 118ce83..0619957 100644
--- a/drivers/scsi/aacraid/aachba.c
+++ b/drivers/scsi/aacraid/aachba.c
@@ -747,8 +747,8 @@ char * get_container_type(unsigned tindex)
  * Arguments: [1] pointer to void [1] int
  *
  * Purpose: Sets SCSI inquiry data strings for vendor, product
- * and revision level. Allows strings to be set in platform dependant
- * files instead of in OS dependant driver source.
+ * and revision level. Allows strings to be set in platform dependent
+ * files instead of in OS dependent driver source.
  */
 
 static void setinqstr(struct aac_dev *dev, void *data, int tindex)
diff --git a/drivers/scsi/aacraid/aacraid.h b/drivers/scsi/aacraid/aacraid.h
index 29ab000..ffb5878 100644
--- a/drivers/scsi/aacraid/aacraid.h
+++ b/drivers/scsi/aacraid/aacraid.h
@@ -1259,7 +1259,7 @@ struct aac_dev
 #define CACHE_UNSTABLE		2
 
 /*
- *	Lets the client know at which level the data was commited on
+ *	Lets the client know at which level the data was committed on
  *	a write request
  */
 
diff --git a/drivers/scsi/aacraid/commsup.c b/drivers/scsi/aacraid/commsup.c
index dd7ad3b..e7d0d47 100644
--- a/drivers/scsi/aacraid/commsup.c
+++ b/drivers/scsi/aacraid/commsup.c
@@ -421,7 +421,7 @@ int aac_fib_send(u16 command, struct fib *fibptr, unsigned long size,
 	if (!(hw_fib->header.XferState & cpu_to_le32(HostOwned)))
 		return -EBUSY;
 	/*
-	 *	There are 5 cases with the wait and reponse requested flags.
+	 *	There are 5 cases with the wait and response requested flags.
 	 *	The only invalid cases are if the caller requests to wait and
 	 *	does not request a response and if the caller does not want a
 	 *	response and the Fib is not allocated from pool. If a response
diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index 081c6de..bfd618a 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -4544,7 +4544,7 @@ AscMemWordCopyPtrToLram(PortAddr iop_base, ushort s_addr,
  * Copy 4 bytes to LRAM.
  *
  * The source data is assumed to be in little-endian order in memory
- * and is maintained in little-endian order when writen to LRAM.
+ * and is maintained in little-endian order when written to LRAM.
  */
 static void
 AscMemDWordCopyPtrToLram(PortAddr iop_base,
diff --git a/drivers/scsi/aha1740.c b/drivers/scsi/aha1740.c
index d058f1a..1c10b79 100644
--- a/drivers/scsi/aha1740.c
+++ b/drivers/scsi/aha1740.c
@@ -461,7 +461,7 @@ static int aha1740_queuecommand_lck(Scsi_Cmnd * SCpnt, void (*done)(Scsi_Cmnd *)
 	/* The Adaptec Spec says the card is so fast that the loops
            will only be executed once in the code below. Even if this
            was true with the fastest processors when the spec was
-           written, it doesn't seem to be true with todays fast
+           written, it doesn't seem to be true with today's fast
            processors. We print a warning if the code is executed more
            often than LOOPCNT_WARN. If this happens, it should be
            investigated. If the count reaches LOOPCNT_MAX, we assume
diff --git a/drivers/scsi/aic7xxx/aic79xx.h b/drivers/scsi/aic7xxx/aic79xx.h
index 95ee503..9b05942 100644
--- a/drivers/scsi/aic7xxx/aic79xx.h
+++ b/drivers/scsi/aic7xxx/aic79xx.h
@@ -473,7 +473,7 @@ struct hardware_scb {
  *	o A residual has occurred if SG_FULL_RESID is set in sgptr,
  *	  or residual_sgptr does not have SG_LIST_NULL set.
  *
- *	o We are transfering the last segment if residual_datacnt has
+ *	o We are transferring the last segment if residual_datacnt has
  *	  the SG_LAST_SEG flag set.
  *
  * Host:
@@ -516,7 +516,7 @@ struct hardware_scb {
  */
 
 /*
- * Definition of a scatter/gather element as transfered to the controller.
+ * Definition of a scatter/gather element as transferred to the controller.
  * The aic7xxx chips only support a 24bit length.  We use the top byte of
  * the length to store additional address bits and a flag to indicate
  * that a given segment terminates the transfer.  This gives us an
diff --git a/drivers/scsi/aic7xxx/aic79xx.reg b/drivers/scsi/aic7xxx/aic79xx.reg
index 0666c22..7e12c31 100644
--- a/drivers/scsi/aic7xxx/aic79xx.reg
+++ b/drivers/scsi/aic7xxx/aic79xx.reg
@@ -305,7 +305,7 @@ register HS_MAILBOX {
 }
 
 /*
- * Sequencer Interupt Status
+ * Sequencer Interrupt Status
  */
 register SEQINTSTAT {
 	address			0x00C
@@ -685,7 +685,7 @@ register DCHRXMSG0 {
 }
 
 /*
- * CMC Recieve Message 0
+ * CMC Receive Message 0
  */
 register CMCRXMSG0 {
 	address			0x090
@@ -696,7 +696,7 @@ register CMCRXMSG0 {
 }
 
 /*
- * Overlay Recieve Message 0
+ * Overlay Receive Message 0
  */
 register OVLYRXMSG0 {
 	address			0x090
@@ -732,7 +732,7 @@ register DCHRXMSG1 {
 }
 
 /*
- * CMC Recieve Message 1
+ * CMC Receive Message 1
  */
 register CMCRXMSG1 {
 	address			0x091
@@ -742,7 +742,7 @@ register CMCRXMSG1 {
 }
 
 /*
- * Overlay Recieve Message 1
+ * Overlay Receive Message 1
  */
 register OVLYRXMSG1 {
 	address			0x091
@@ -777,7 +777,7 @@ register DCHRXMSG2 {
 }
 
 /*
- * CMC Recieve Message 2
+ * CMC Receive Message 2
  */
 register CMCRXMSG2 {
 	address			0x092
@@ -787,7 +787,7 @@ register CMCRXMSG2 {
 }
 
 /*
- * Overlay Recieve Message 2
+ * Overlay Receive Message 2
  */
 register OVLYRXMSG2 {
 	address			0x092
@@ -816,7 +816,7 @@ register DCHRXMSG3 {
 }
 
 /*
- * CMC Recieve Message 3
+ * CMC Receive Message 3
  */
 register CMCRXMSG3 {
 	address			0x093
@@ -826,7 +826,7 @@ register CMCRXMSG3 {
 }
 
 /*
- * Overlay Recieve Message 3
+ * Overlay Receive Message 3
  */
 register OVLYRXMSG3 {
 	address			0x093
@@ -1249,7 +1249,7 @@ register TARGPCISTAT {
 
 /*
  * LQ Packet In
- * The last LQ Packet recieved
+ * The last LQ Packet received
  */
 register LQIN {
 	address			0x020
@@ -2573,7 +2573,7 @@ register IOPDNCTL {
 }
 
 /*
- * Shaddow Host Address.
+ * Shadow Host Address.
  */
 register SHADDR {
 	address			0x060
@@ -3983,7 +3983,7 @@ scratch_ram {
 
 	/*
 	 * The maximum amount of time to wait, when interrupt coalescing
-	 * is enabled, before issueing a CMDCMPLT interrupt for a completed
+	 * is enabled, before issuing a CMDCMPLT interrupt for a completed
 	 * command.
 	 */
 	INT_COALESCING_TIMER {
diff --git a/drivers/scsi/aic7xxx/aic79xx.seq b/drivers/scsi/aic7xxx/aic79xx.seq
index 2fb78e3..3a36d93 100644
--- a/drivers/scsi/aic7xxx/aic79xx.seq
+++ b/drivers/scsi/aic7xxx/aic79xx.seq
@@ -567,7 +567,7 @@ BEGIN_CRITICAL;
 	shr	SELOID, 4, SCB_SCSIID;
 	/*
 	 * If we want to send a message to the device, ensure
-	 * we are selecting with atn irregardless of our packetized
+	 * we are selecting with atn regardless of our packetized
 	 * agreement.  Since SPI4 only allows target reset or PPR
 	 * messages if this is a packetized connection, the change
 	 * to our negotiation table entry for this selection will
@@ -960,7 +960,7 @@ p_status_okay:
  * This is done to allow the host to send messages outside of an identify
  * sequence while protecting the seqencer from testing the MK_MESSAGE bit
  * on an SCB that might not be for the current nexus. (For example, a
- * BDR message in responce to a bad reselection would leave us pointed to
+ * BDR message in response to a bad reselection would leave us pointed to
  * an SCB that doesn't have anything to do with the current target).
  *
  * Otherwise, treat MSG_OUT as a 1 byte message to send (abort, abort tag,
@@ -1507,7 +1507,7 @@ service_fifo:
 		 * If the other FIFO needs loading, then it
 		 * must not have claimed the S/G cache yet
 		 * (SG_CACHE_AVAIL would have been cleared in
-		 * the orginal FIFO mode and we test this above).
+		 * the original FIFO mode and we test this above).
 		 * Return to the idle loop so we can process the
 		 * FIFO not currently on the bus first.
 		 */
@@ -1521,7 +1521,7 @@ idle_sgfetch_okay:
 idle_sgfetch_start:
 	/*
 	 * We fetch a "cacheline aligned" and sized amount of data
-	 * so we don't end up referencing a non-existant page.
+	 * so we don't end up referencing a non-existent page.
 	 * Cacheline aligned is in quotes because the kernel will
 	 * set the prefetch amount to a reasonable level if the
 	 * cacheline size is unknown.
@@ -1551,7 +1551,7 @@ idle_sg_avail:
 	test	DFSTATUS, PRELOAD_AVAIL jz return;
 	/*
 	 * On the A, preloading a segment before HDMAENACK
-	 * comes true can clobber the shaddow address of the
+	 * comes true can clobber the shadow address of the
 	 * first segment in the S/G FIFO.  Wait until it is
 	 * safe to proceed.
 	 */
@@ -2004,10 +2004,10 @@ pkt_handle_xfer:
 	 * Defer handling of this NONPACKREQ until we
 	 * can be sure it pertains to this FIFO.  SAVEPTRS
 	 * will not be asserted if the NONPACKREQ is for us,
-	 * so we must simulate it if shaddow is valid.  If
-	 * shaddow is not valid, keep running this FIFO until we
+	 * so we must simulate it if shadow is valid.  If
+	 * shadow is not valid, keep running this FIFO until we
 	 * have satisfied the transfer by loading segments and
-	 * waiting for either shaddow valid or last_seg_done.
+	 * waiting for either shadow valid or last_seg_done.
 	 */
 	test	MDFFSTAT, SHVALID jnz pkt_saveptrs;
 pkt_service_fifo:
@@ -2171,7 +2171,7 @@ pkt_status_check_nonpackreq:
 	/*
 	 * The unexpected nonpkt phase handler assumes that any
 	 * data channel use will have a FIFO reference count.  It
-	 * turns out that the status handler doesn't need a refernce
+	 * turns out that the status handler doesn't need a references
 	 * count since the status received flag, and thus completion
 	 * processing, cannot be set until the handler is finished.
 	 * We increment the count here to make the nonpkt handler
diff --git a/drivers/scsi/aic7xxx/aic79xx_core.c b/drivers/scsi/aic7xxx/aic79xx_core.c
index 3233bf5..5f8617d 100644
--- a/drivers/scsi/aic7xxx/aic79xx_core.c
+++ b/drivers/scsi/aic7xxx/aic79xx_core.c
@@ -562,7 +562,7 @@ ahd_targetcmd_offset(struct ahd_softc *ahd, u_int index)
 }
 #endif
 
-/*********************** Miscelaneous Support Functions ***********************/
+/*********************** Miscellaneous Support Functions ***********************/
 /*
  * Return pointers to the transfer negotiation information
  * for the specified our_id/remote_id pair.
@@ -599,7 +599,7 @@ void
 ahd_outw(struct ahd_softc *ahd, u_int port, u_int value)
 {
 	/*
-	 * Write low byte first to accomodate registers
+	 * Write low byte first to accommodate registers
 	 * such as PRGMCNT where the order maters.
 	 */
 	ahd_outb(ahd, port, value & 0xFF);
@@ -2067,7 +2067,7 @@ ahd_handle_seqint(struct ahd_softc *ahd, u_int intstat)
 		 * that requires host assistance for completion.
 		 * While handling the message phase(s), we will be
 		 * notified by the sequencer after each byte is
-		 * transfered so we can track bus phase changes.
+		 * transferred so we can track bus phase changes.
 		 *
 		 * If this is the first time we've seen a HOST_MSG_LOOP
 		 * interrupt, initialize the state of the host message
@@ -2487,7 +2487,7 @@ ahd_handle_scsiint(struct ahd_softc *ahd, u_int intstat)
 		/*
 		 * Although the driver does not care about the
 		 * 'Selection in Progress' status bit, the busy
-		 * LED does.  SELINGO is only cleared by a successfull
+		 * LED does.  SELINGO is only cleared by a successful
 		 * selection, so we must manually clear it to insure
 		 * the LED turns off just incase no future successful
 		 * selections occur (e.g. no devices on the bus).
@@ -3548,7 +3548,7 @@ ahd_clear_critical_section(struct ahd_softc *ahd)
 		ahd_outb(ahd, SEQCTL0, ahd_inb(ahd, SEQCTL0) & ~STEP);
   		ahd_outb(ahd, SIMODE1, simode1);
 		/*
-		 * SCSIINT seems to glitch occassionally when
+		 * SCSIINT seems to glitch occasionally when
 		 * the interrupt masks are restored.  Clear SCSIINT
 		 * one more time so that only persistent errors
 		 * are seen as a real interrupt.
@@ -3838,7 +3838,7 @@ ahd_validate_width(struct ahd_softc *ahd, struct ahd_initiator_tinfo *tinfo,
 
 /*
  * Update the bitmask of targets for which the controller should
- * negotiate with at the next convenient oportunity.  This currently
+ * negotiate with at the next convenient opportunity.  This currently
  * means the next time we send the initial identify messages for
  * a new transaction.
  */
@@ -4200,7 +4200,7 @@ ahd_update_neg_table(struct ahd_softc *ahd, struct ahd_devinfo *devinfo,
 
 	/*
 	 * During packetized transfers, the target will
-	 * give us the oportunity to send command packets
+	 * give us the opportunity to send command packets
 	 * without us asserting attention.
 	 */
 	if ((tinfo->ppr_options & MSG_EXT_PPR_IU_REQ) == 0)
@@ -5651,7 +5651,7 @@ ahd_handle_msg_reject(struct ahd_softc *ahd, struct ahd_devinfo *devinfo)
 
 		/*
 		 * Requeue all tagged commands for this target
-		 * currently in our posession so they can be
+		 * currently in our possession so they can be
 		 * converted to untagged commands.
 		 */
 		ahd_search_qinfifo(ahd, SCB_GET_TARGET(ahd, scb),
@@ -6245,7 +6245,7 @@ ahd_shutdown(void *arg)
 /*
  * Reset the controller and record some information about it
  * that is only available just after a reset.  If "reinit" is
- * non-zero, this reset occured after initial configuration
+ * non-zero, this reset occurred after initial configuration
  * and the caller requests that the chip be fully reinitialized
  * to a runable state.  Chip interrupts are *not* enabled after
  * a reinitialization.  The caller must enable interrupts via
@@ -6495,7 +6495,7 @@ ahd_init_scbdata(struct ahd_softc *ahd)
 	}
 
 	/*
-	 * Note that we were successfull
+	 * Note that we were successful
 	 */
 	return (0); 
 
@@ -7079,7 +7079,7 @@ ahd_init(struct ahd_softc *ahd)
 		return (ENOMEM);
 
 	/*
-	 * Verify that the compiler hasn't over-agressively
+	 * Verify that the compiler hasn't over-aggressively
 	 * padded important structures.
 	 */
 	if (sizeof(struct hardware_scb) != 64)
@@ -10087,7 +10087,7 @@ ahd_write_seeprom(struct ahd_softc *ahd, uint16_t *buf,
 		return (error);
 
 	/*
-	 * Write the data.  If we don't get throught the loop at
+	 * Write the data.  If we don't get through the loop at
 	 * least once, the arguments were invalid.
 	 */
 	retval = EINVAL;
diff --git a/drivers/scsi/aic7xxx/aic79xx_osm.c b/drivers/scsi/aic7xxx/aic79xx_osm.c
index 25d0666..7d48700 100644
--- a/drivers/scsi/aic7xxx/aic79xx_osm.c
+++ b/drivers/scsi/aic7xxx/aic79xx_osm.c
@@ -1441,7 +1441,7 @@ ahd_platform_set_tags(struct ahd_softc *ahd, struct scsi_device *sdev,
 		usertags = ahd_linux_user_tagdepth(ahd, devinfo);
 		if (!was_queuing) {
 			/*
-			 * Start out agressively and allow our
+			 * Start out aggressively and allow our
 			 * dynamic queue depth algorithm to take
 			 * care of the rest.
 			 */
diff --git a/drivers/scsi/aic7xxx/aic7xxx.h b/drivers/scsi/aic7xxx/aic7xxx.h
index 17444bc..f695774 100644
--- a/drivers/scsi/aic7xxx/aic7xxx.h
+++ b/drivers/scsi/aic7xxx/aic7xxx.h
@@ -440,7 +440,7 @@ struct hardware_scb {
  *	o A residual has occurred if SG_FULL_RESID is set in sgptr,
  *	  or residual_sgptr does not have SG_LIST_NULL set.
  *
- *	o We are transfering the last segment if residual_datacnt has
+ *	o We are transferring the last segment if residual_datacnt has
  *	  the SG_LAST_SEG flag set.
  *
  * Host:
@@ -494,7 +494,7 @@ struct hardware_scb {
  */
 
 /*
- * Definition of a scatter/gather element as transfered to the controller.
+ * Definition of a scatter/gather element as transferred to the controller.
  * The aic7xxx chips only support a 24bit length.  We use the top byte of
  * the length to store additional address bits and a flag to indicate
  * that a given segment terminates the transfer.  This gives us an
diff --git a/drivers/scsi/aic7xxx/aic7xxx.reg b/drivers/scsi/aic7xxx/aic7xxx.reg
index 9a96e55..ba0b411 100644
--- a/drivers/scsi/aic7xxx/aic7xxx.reg
+++ b/drivers/scsi/aic7xxx/aic7xxx.reg
@@ -351,7 +351,7 @@ register SSTAT2 {
 	address			0x00d
 	access_mode RO
 	field	OVERRUN		0x80
-	field	SHVALID		0x40	/* Shaddow Layer non-zero */
+	field	SHVALID		0x40	/* Shadow Layer non-zero */
 	field	EXP_ACTIVE	0x10	/* SCSI Expander Active */
 	field	CRCVALERR	0x08	/* CRC doesn't match (U3 only) */
 	field	CRCENDERR	0x04	/* No terminal CRC packet (U3 only) */
diff --git a/drivers/scsi/aic7xxx/aic7xxx.seq b/drivers/scsi/aic7xxx/aic7xxx.seq
index 5a4cfc9..e60041e 100644
--- a/drivers/scsi/aic7xxx/aic7xxx.seq
+++ b/drivers/scsi/aic7xxx/aic7xxx.seq
@@ -57,10 +57,10 @@ PREFIX = "ahc_"
  * a later time.  This problem cannot be resolved by holding a single entry
  * in scratch ram since a reconnecting target can request sense and this will
  * create yet another SCB waiting for selection.  The solution used here is to 
- * use byte 27 of the SCB as a psuedo-next pointer and to thread a list
+ * use byte 27 of the SCB as a pseudo-next pointer and to thread a list
  * of SCBs that are awaiting selection.  Since 0-0xfe are valid SCB indexes, 
  * SCB_LIST_NULL is 0xff which is out of range.  An entry is also added to
- * this list everytime a request sense occurs or after completing a non-tagged
+ * this list every time a request sense occurs or after completing a non-tagged
  * command for which a second SCB has been queued.  The sequencer will
  * automatically consume the entries.
  */
@@ -752,7 +752,7 @@ idle_loop:
 
 	/*
 	 * We fetch a "cacheline aligned" and sized amount of data
-	 * so we don't end up referencing a non-existant page.
+	 * so we don't end up referencing a non-existent page.
 	 * Cacheline aligned is in quotes because the kernel will
 	 * set the prefetch amount to a reasonable level if the
 	 * cacheline size is unknown.
@@ -1485,7 +1485,7 @@ p_status_okay:
  * This is done to allow the host to send messages outside of an identify
  * sequence while protecting the seqencer from testing the MK_MESSAGE bit
  * on an SCB that might not be for the current nexus. (For example, a
- * BDR message in responce to a bad reselection would leave us pointed to
+ * BDR message in response to a bad reselection would leave us pointed to
  * an SCB that doesn't have anything to do with the current target).
  *
  * Otherwise, treat MSG_OUT as a 1 byte message to send (abort, abort tag,
@@ -1999,7 +1999,7 @@ if ((ahc->flags & AHC_TARGETROLE) != 0) {
  * from out to in, wait an additional data release delay before continuing.
  */
 change_phase:
-	/* Wait for preceeding I/O session to complete. */
+	/* Wait for preceding I/O session to complete. */
 	test	SCSISIGI, ACKI jnz .;
 
 	/* Change the phase */
diff --git a/drivers/scsi/aic7xxx/aic7xxx_core.c b/drivers/scsi/aic7xxx/aic7xxx_core.c
index e021b48..dc28b0a 100644
--- a/drivers/scsi/aic7xxx/aic7xxx_core.c
+++ b/drivers/scsi/aic7xxx/aic7xxx_core.c
@@ -427,7 +427,7 @@ ahc_targetcmd_offset(struct ahc_softc *ahc, u_int index)
 }
 #endif
 
-/*********************** Miscelaneous Support Functions ***********************/
+/*********************** Miscellaneous Support Functions ***********************/
 /*
  * Determine whether the sequencer reported a residual
  * for this SCB/transaction.
@@ -1243,7 +1243,7 @@ ahc_handle_seqint(struct ahc_softc *ahc, u_int intstat)
 		 * that requires host assistance for completion.
 		 * While handling the message phase(s), we will be
 		 * notified by the sequencer after each byte is
-		 * transfered so we can track bus phase changes.
+		 * transferred so we can track bus phase changes.
 		 *
 		 * If this is the first time we've seen a HOST_MSG_LOOP
 		 * interrupt, initialize the state of the host message
@@ -1487,7 +1487,7 @@ ahc_handle_seqint(struct ahc_softc *ahc, u_int intstat)
 		       scbptr, ahc_inb(ahc, ARG_1),
 		       ahc->scb_data->hscbs[scbptr].tag);
 		ahc_dump_card_state(ahc);
-		panic("for saftey");
+		panic("for safety");
 		break;
 	}
 	case OUT_OF_RANGE:
@@ -1733,7 +1733,7 @@ ahc_handle_scsiint(struct ahc_softc *ahc, u_int intstat)
 		/*
 		 * Although the driver does not care about the
 		 * 'Selection in Progress' status bit, the busy
-		 * LED does.  SELINGO is only cleared by a successfull
+		 * LED does.  SELINGO is only cleared by a successful
 		 * selection, so we must manually clear it to insure
 		 * the LED turns off just incase no future successful
 		 * selections occur (e.g. no devices on the bus).
@@ -1943,7 +1943,7 @@ ahc_handle_scsiint(struct ahc_softc *ahc, u_int intstat)
 			if (lastphase != P_BUSFREE) {
 				/*
 				 * Renegotiate with this device at the
-				 * next oportunity just in case this busfree
+				 * next opportunity just in case this busfree
 				 * is due to a negotiation mismatch with the
 				 * device.
 				 */
@@ -2442,7 +2442,7 @@ ahc_validate_width(struct ahc_softc *ahc, struct ahc_initiator_tinfo *tinfo,
 
 /*
  * Update the bitmask of targets for which the controller should
- * negotiate with at the next convenient oportunity.  This currently
+ * negotiate with at the next convenient opportunity.  This currently
  * means the next time we send the initial identify messages for
  * a new transaction.
  */
@@ -4131,7 +4131,7 @@ ahc_handle_msg_reject(struct ahc_softc *ahc, struct ahc_devinfo *devinfo)
 
 		/*
 		 * Requeue all tagged commands for this target
-		 * currently in our posession so they can be
+		 * currently in our possession so they can be
 		 * converted to untagged commands.
 		 */
 		ahc_search_qinfifo(ahc, SCB_GET_TARGET(ahc, scb),
@@ -4581,7 +4581,7 @@ ahc_shutdown(void *arg)
 /*
  * Reset the controller and record some information about it
  * that is only available just after a reset.  If "reinit" is
- * non-zero, this reset occured after initial configuration
+ * non-zero, this reset occurred after initial configuration
  * and the caller requests that the chip be fully reinitialized
  * to a runable state.  Chip interrupts are *not* enabled after
  * a reinitialization.  The caller must enable interrupts via
@@ -4899,7 +4899,7 @@ ahc_init_scbdata(struct ahc_softc *ahc)
 	ahc->next_queued_scb = ahc_get_scb(ahc);
 
 	/*
-	 * Note that we were successfull
+	 * Note that we were successful
 	 */
 	return (0); 
 
diff --git a/drivers/scsi/aic7xxx/aic7xxx_osm.c b/drivers/scsi/aic7xxx/aic7xxx_osm.c
index 4a359bb..c6251bb 100644
--- a/drivers/scsi/aic7xxx/aic7xxx_osm.c
+++ b/drivers/scsi/aic7xxx/aic7xxx_osm.c
@@ -294,7 +294,7 @@ static uint32_t aic7xxx_extended;
  * dubious at best.  To my knowledge, this option has never actually
  * solved a PCI parity problem, but on certain machines with broken PCI
  * chipset configurations where stray PCI transactions with bad parity are
- * the norm rather than the exception, the error messages can be overwelming.
+ * the norm rather than the exception, the error messages can be overwhelming.
  * It's included in the driver for completeness.
  *   0	   = Shut off PCI parity check
  *   non-0 = reverse polarity pci parity checking
@@ -1318,7 +1318,7 @@ ahc_platform_set_tags(struct ahc_softc *ahc, struct scsi_device *sdev,
 		usertags = ahc_linux_user_tagdepth(ahc, devinfo);
 		if (!was_queuing) {
 			/*
-			 * Start out agressively and allow our
+			 * Start out aggressively and allow our
 			 * dynamic queue depth algorithm to take
 			 * care of the rest.
 			 */
diff --git a/drivers/scsi/aic7xxx/aic7xxx_pci.c b/drivers/scsi/aic7xxx/aic7xxx_pci.c
index 2b11a42..6917b4f 100644
--- a/drivers/scsi/aic7xxx/aic7xxx_pci.c
+++ b/drivers/scsi/aic7xxx/aic7xxx_pci.c
@@ -789,7 +789,7 @@ ahc_pci_config(struct ahc_softc *ahc, const struct ahc_pci_identity *entry)
 	ahc->bus_intr = ahc_pci_intr;
 	ahc->bus_chip_init = ahc_pci_chip_init;
 
-	/* Remeber how the card was setup in case there is no SEEPROM */
+	/* Remember how the card was setup in case there is no SEEPROM */
 	if ((ahc_inb(ahc, HCNTRL) & POWRDN) == 0) {
 		ahc_pause(ahc);
 		if ((ahc->features & AHC_ULTRA2) != 0)
@@ -860,7 +860,7 @@ ahc_pci_config(struct ahc_softc *ahc, const struct ahc_pci_identity *entry)
 	}
 
 	/*
-	 * We cannot perform ULTRA speeds without the presense
+	 * We cannot perform ULTRA speeds without the presence
 	 * of the external precision resistor.
 	 */
 	if ((ahc->features & AHC_ULTRA) != 0) {
@@ -969,7 +969,7 @@ ahc_pci_config(struct ahc_softc *ahc, const struct ahc_pci_identity *entry)
 }
 
 /*
- * Test for the presense of external sram in an
+ * Test for the presence of external sram in an
  * "unshared" configuration.
  */
 static int
diff --git a/drivers/scsi/aic7xxx/aicasm/aicasm_gram.y b/drivers/scsi/aic7xxx/aicasm/aicasm_gram.y
index e406443..f1586a4 100644
--- a/drivers/scsi/aic7xxx/aicasm/aicasm_gram.y
+++ b/drivers/scsi/aic7xxx/aicasm/aicasm_gram.y
@@ -803,7 +803,7 @@ macro_arglist:
 |	macro_arglist ',' T_ARG
 	{
 		if ($1 == 0) {
-			stop("Comma without preceeding argument in arg list",
+			stop("Comma without preceding argument in arg list",
 			     EX_DATAERR);
 			/* NOTREACHED */
 		}
@@ -1319,8 +1319,8 @@ code:
 ;
 
 	/*
-	 * This grammer differs from the one in the aic7xxx
-	 * reference manual since the grammer listed there is
+	 * This grammar differs from the one in the aic7xxx
+	 * reference manual since the grammar listed there is
 	 * ambiguous and causes a shift/reduce conflict.
 	 * It also seems more logical as the "immediate"
 	 * argument is listed as the second arg like the
@@ -1799,7 +1799,7 @@ format_3_instr(int opcode, symbol_ref_t *src,
 	instr = seq_alloc();
 	f3_instr = &instr->format.format3;
 	if (address->symbol == NULL) {
-		/* 'dot' referrence.  Use the current instruction pointer */
+		/* 'dot' reference.  Use the current instruction pointer */
 		addr = instruction_ptr + address->offset;
 	} else if (address->symbol->type == UNINITIALIZED) {
 		/* forward reference */
diff --git a/drivers/scsi/aic7xxx/aicasm/aicasm_macro_gram.y b/drivers/scsi/aic7xxx/aicasm/aicasm_macro_gram.y
index ff46aa6..708326d 100644
--- a/drivers/scsi/aic7xxx/aicasm/aicasm_macro_gram.y
+++ b/drivers/scsi/aic7xxx/aicasm/aicasm_macro_gram.y
@@ -115,7 +115,7 @@ macro_arglist:
 |	macro_arglist ',' T_ARG
 	{
 		if ($1 == 0) {
-			stop("Comma without preceeding argument in arg list",
+			stop("Comma without preceding argument in arg list",
 			     EX_DATAERR);
 			/* NOTREACHED */
 		}
diff --git a/drivers/scsi/aic7xxx_old.c b/drivers/scsi/aic7xxx_old.c
index 4ff60a0..5b212f0 100644
--- a/drivers/scsi/aic7xxx_old.c
+++ b/drivers/scsi/aic7xxx_old.c
@@ -905,7 +905,7 @@ struct aic_dev_data {
  * problems with architectures I can't test on (because I don't have one,
  * such as the Alpha based systems) which happen to give faults for
  * non-aligned memory accesses, care was taken to align this structure
- * in a way that gauranteed all accesses larger than 8 bits were aligned
+ * in a way that guaranteed all accesses larger than 8 bits were aligned
  * on the appropriate boundary.  It's also organized to try and be more
  * cache line efficient.  Be careful when changing this lest you might hurt
  * overall performance and bring down the wrath of the masses.
@@ -1180,7 +1180,7 @@ static int aic7xxx_pci_parity = 0;
  * the card's registers in a hex dump format tailored to each model of
  * controller.
  * 
- * NOTE: THE CONTROLLER IS LEFT IN AN UNUSEABLE STATE BY THIS OPTION.
+ * NOTE: THE CONTROLLER IS LEFT IN AN UNUSABLE STATE BY THIS OPTION.
  *       YOU CANNOT BOOT UP WITH THIS OPTION, IT IS FOR DEBUGGING PURPOSES
  *       ONLY
  */
@@ -3467,7 +3467,7 @@ aic7xxx_reset_current_bus(struct aic7xxx_host *p)
   /* Turn off the bus' current operations, after all, we shouldn't have any
    * valid commands left to cause a RSELI and SELO once we've tossed the
    * bus away with this reset, so we might as well shut down the sequencer
-   * until the bus is restarted as oppossed to saving the current settings
+   * until the bus is restarted as opposed to saving the current settings
    * and restoring them (which makes no sense to me). */
 
   /* Turn on the bus reset. */
@@ -4070,7 +4070,7 @@ aic7xxx_handle_seqint(struct aic7xxx_host *p, unsigned char intstat)
             aic_dev->max_q_depth = aic_dev->temp_q_depth = 1;
             /*
              * We set this command up as a bus device reset.  However, we have
-             * to clear the tag type as it's causing us problems.  We shouldnt
+             * to clear the tag type as it's causing us problems.  We shouldn't
              * have to worry about any other commands being active, since if
              * the device is refusing tagged commands, this should be the
              * first tagged command sent to the device, however, we do have
@@ -9748,7 +9748,7 @@ skip_pci_controller:
     }
 
     /*
-     * We are commited now, everything has been checked and this card
+     * We are committed now, everything has been checked and this card
      * has been found, now we just set it up
      */
 
@@ -9906,7 +9906,7 @@ skip_pci_controller:
    *  2: All PCI controllers with BIOS_ENABLED next, according to BIOS
    *     address, going from lowest to highest.
    *  3: Remaining VLB/EISA controllers going in slot order.
-   *  4: Remaining PCI controllers, going in PCI device order (reversable)
+   *  4: Remaining PCI controllers, going in PCI device order (reversible)
    */
 
   {
diff --git a/drivers/scsi/aic7xxx_old/aic7xxx.seq b/drivers/scsi/aic7xxx_old/aic7xxx.seq
index 1565be9..823ff28 100644
--- a/drivers/scsi/aic7xxx_old/aic7xxx.seq
+++ b/drivers/scsi/aic7xxx_old/aic7xxx.seq
@@ -51,7 +51,7 @@
  * use byte 27 of the SCB as a pseudo-next pointer and to thread a list
  * of SCBs that are awaiting selection.  Since 0-0xfe are valid SCB indexes, 
  * SCB_LIST_NULL is 0xff which is out of range.  An entry is also added to
- * this list everytime a request sense occurs or after completing a non-tagged
+ * this list every time a request sense occurs or after completing a non-tagged
  * command for which a second SCB has been queued.  The sequencer will
  * automatically consume the entries.
  */
@@ -696,7 +696,7 @@ p_status:
  * This is done to allow the hsot to send messages outside of an identify
  * sequence while protecting the seqencer from testing the MK_MESSAGE bit
  * on an SCB that might not be for the current nexus. (For example, a
- * BDR message in responce to a bad reselection would leave us pointed to
+ * BDR message in response to a bad reselection would leave us pointed to
  * an SCB that doesn't have anything to do with the current target).
  * Otherwise, treat MSG_OUT as a 1 byte message to send (abort, abort tag,
  * bus device reset).
@@ -716,8 +716,8 @@ p_mesgout_identify:
 	} else {
 		and	SINDEX,0x7,SCB_TCL;	/* lun */
 	}
-	and	A,DISCENB,SCB_CONTROL;	/* mask off disconnect privledge */
-	or	SINDEX,A;		/* or in disconnect privledge */
+	and	A,DISCENB,SCB_CONTROL;	/* mask off disconnect privilege */
+	or	SINDEX,A;		/* or in disconnect privilege */
 	or	SINDEX,MSG_IDENTIFYFLAG;
 p_mesgout_mk_message:
 	test	SCB_CONTROL,MK_MESSAGE  jz p_mesgout_tag;
diff --git a/drivers/scsi/aic94xx/aic94xx_reg_def.h b/drivers/scsi/aic94xx/aic94xx_reg_def.h
index 40273a7..dd6cc80 100644
--- a/drivers/scsi/aic94xx/aic94xx_reg_def.h
+++ b/drivers/scsi/aic94xx/aic94xx_reg_def.h
@@ -2134,7 +2134,7 @@
 * The host accesses this scratch in a different manner from the
 * link sequencer. The sequencer has to use LSEQ registers
 * LmSCRPAGE and LmMnSCRPAGE to access the scratch memory. A flat
-* mapping of the scratch memory is avaliable for software
+* mapping of the scratch memory is available for software
 * convenience and to prevent corruption while the sequencer is
 * running. This memory is mapped onto addresses 800h - 9FFh.
 *
diff --git a/drivers/scsi/arm/acornscsi.c b/drivers/scsi/arm/acornscsi.c
index ec16672..c454e44 100644
--- a/drivers/scsi/arm/acornscsi.c
+++ b/drivers/scsi/arm/acornscsi.c
@@ -100,7 +100,7 @@
  */
 #define TIMEOUT_TIME 10
 /*
- * Define this if you want to have verbose explaination of SCSI
+ * Define this if you want to have verbose explanation of SCSI
  * status/messages.
  */
 #undef CONFIG_ACORNSCSI_CONSTANTS
@@ -1561,7 +1561,7 @@ void acornscsi_message(AS_Host *host)
 	/*
 	 * If we were negociating sync transfer, we don't yet know if
 	 * this REJECT is for the sync transfer or for the tagged queue/wide
-	 * transfer.  Re-initiate sync transfer negociation now, and if
+	 * transfer.  Re-initiate sync transfer negotiation now, and if
 	 * we got a REJECT in response to SDTR, then it'll be set to DONE.
 	 */
 	if (host->device[host->SCpnt->device->id].sync_state == SYNC_SENT_REQUEST)
diff --git a/drivers/scsi/arm/acornscsi.h b/drivers/scsi/arm/acornscsi.h
index 8d2172a..01bc715 100644
--- a/drivers/scsi/arm/acornscsi.h
+++ b/drivers/scsi/arm/acornscsi.h
@@ -223,8 +223,8 @@ typedef enum {
  * Synchronous transfer state
  */
 typedef enum {					/* Synchronous transfer state		*/
-    SYNC_ASYNCHRONOUS,				/* don't negociate synchronous transfers*/
-    SYNC_NEGOCIATE,				/* start negociation			*/
+    SYNC_ASYNCHRONOUS,				/* don't negotiate synchronous transfers*/
+    SYNC_NEGOCIATE,				/* start negotiation			*/
     SYNC_SENT_REQUEST,				/* sent SDTR message			*/
     SYNC_COMPLETED,				/* received SDTR reply			*/
 } syncxfer_t;
@@ -322,7 +322,7 @@ typedef struct acornscsi_hostdata {
     /* per-device info */
     struct {
 	unsigned char	sync_xfer;		/* synchronous transfer (SBIC value)	*/
-	syncxfer_t	sync_state;		/* sync xfer negociation state		*/
+	syncxfer_t	sync_state;		/* sync xfer negotiation state		*/
 	unsigned char	disconnect_ok:1;	/* device can disconnect		*/
     } device[8];
     unsigned long	busyluns[64 / sizeof(unsigned long)];/* array of bits indicating LUNs busy	*/
diff --git a/drivers/scsi/arm/arxescsi.c b/drivers/scsi/arm/arxescsi.c
index 2836fe2..a750aa7 100644
--- a/drivers/scsi/arm/arxescsi.c
+++ b/drivers/scsi/arm/arxescsi.c
@@ -228,7 +228,7 @@ static const char *arxescsi_info(struct Scsi_Host *host)
  * Params  : buffer - a buffer to write information to
  *	     start  - a pointer into this buffer set by this routine to the start
  *		      of the required information.
- *	     offset - offset into information that we have read upto.
+ *	     offset - offset into information that we have read up to.
  *	     length - length of buffer
  *	     host_no - host number to return information for
  *	     inout  - 0 for reading, 1 for writing.
diff --git a/drivers/scsi/arm/cumana_2.c b/drivers/scsi/arm/cumana_2.c
index c9902b5..547987b 100644
--- a/drivers/scsi/arm/cumana_2.c
+++ b/drivers/scsi/arm/cumana_2.c
@@ -344,7 +344,7 @@ cumanascsi_2_set_proc_info(struct Scsi_Host *host, char *buffer, int length)
  * Params   : buffer - a buffer to write information to
  *	      start  - a pointer into this buffer set by this routine to the start
  *		       of the required information.
- *	      offset - offset into information that we have read upto.
+ *	      offset - offset into information that we have read up to.
  *	      length - length of buffer
  *	      host_no - host number to return information for
  *	      inout  - 0 for reading, 1 for writing.
diff --git a/drivers/scsi/arm/eesox.c b/drivers/scsi/arm/eesox.c
index d843513..edfd12b 100644
--- a/drivers/scsi/arm/eesox.c
+++ b/drivers/scsi/arm/eesox.c
@@ -429,7 +429,7 @@ eesoxscsi_set_proc_info(struct Scsi_Host *host, char *buffer, int length)
  * Params   : buffer - a buffer to write information to
  *	      start  - a pointer into this buffer set by this routine to the start
  *		       of the required information.
- *	      offset - offset into information that we have read upto.
+ *	      offset - offset into information that we have read up to.
  *	      length - length of buffer
  *	      host_no - host number to return information for
  *	      inout  - 0 for reading, 1 for writing.
diff --git a/drivers/scsi/arm/fas216.c b/drivers/scsi/arm/fas216.c
index 2b2ce21..e85c40b 100644
--- a/drivers/scsi/arm/fas216.c
+++ b/drivers/scsi/arm/fas216.c
@@ -2119,7 +2119,7 @@ request_sense:
 	 * executed, unless a target connects to us.
 	 */
 	if (info->reqSCpnt)
-		printk(KERN_WARNING "scsi%d.%c: loosing request command\n",
+		printk(KERN_WARNING "scsi%d.%c: losing request command\n",
 			info->host->host_no, '0' + SCpnt->device->id);
 	info->reqSCpnt = SCpnt;
 }
@@ -2294,7 +2294,7 @@ static int fas216_noqueue_command_lck(struct scsi_cmnd *SCpnt,
 		 * If we don't have an IRQ, then we must poll the card for
 		 * it's interrupt, and use that to call this driver's
 		 * interrupt routine.  That way, we keep the command
-		 * progressing.  Maybe we can add some inteligence here
+		 * progressing.  Maybe we can add some intelligence here
 		 * and go to sleep if we know that the device is going
 		 * to be some time (eg, disconnected).
 		 */
diff --git a/drivers/scsi/arm/fas216.h b/drivers/scsi/arm/fas216.h
index f30f8d6..84b7127 100644
--- a/drivers/scsi/arm/fas216.h
+++ b/drivers/scsi/arm/fas216.h
@@ -203,11 +203,11 @@ typedef enum {
 } fasdmatype_t;
 
 typedef enum {
-	neg_wait,					/* Negociate with device		*/
-	neg_inprogress,					/* Negociation sent			*/
-	neg_complete,					/* Negociation complete			*/
-	neg_targcomplete,				/* Target completed negociation		*/
-	neg_invalid					/* Negociation not supported		*/
+	neg_wait,					/* Negotiate with device		*/
+	neg_inprogress,					/* Negotiation sent			*/
+	neg_complete,					/* Negotiation complete			*/
+	neg_targcomplete,				/* Target completed negotiation		*/
+	neg_invalid					/* Negotiation not supported		*/
 } neg_t;
 
 #define MAGIC	0x441296bdUL
diff --git a/drivers/scsi/arm/powertec.c b/drivers/scsi/arm/powertec.c
index e2297b4..9274c06 100644
--- a/drivers/scsi/arm/powertec.c
+++ b/drivers/scsi/arm/powertec.c
@@ -232,7 +232,7 @@ powertecscsi_set_proc_info(struct Scsi_Host *host, char *buffer, int length)
  * Params   : buffer  - a buffer to write information to
  *	      start   - a pointer into this buffer set by this routine to the start
  *		        of the required information.
- *	      offset  - offset into information that we have read upto.
+ *	      offset  - offset into information that we have read up to.
  *	      length  - length of buffer
  *	      inout   - 0 for reading, 1 for writing.
  * Returns  : length of data written to buffer.
diff --git a/drivers/scsi/atari_NCR5380.c b/drivers/scsi/atari_NCR5380.c
index 88b2928..ea439f9 100644
--- a/drivers/scsi/atari_NCR5380.c
+++ b/drivers/scsi/atari_NCR5380.c
@@ -464,7 +464,7 @@ static void free_all_tags(void)
  *
  * Parameters: Scsi_Cmnd *cmd
  *    The command to work on. The first scatter buffer's data are
- *    assumed to be already transfered into ptr/this_residual.
+ *    assumed to be already transferred into ptr/this_residual.
  */
 
 static void merge_contiguous_buffers(Scsi_Cmnd *cmd)
@@ -1720,7 +1720,7 @@ static int NCR5380_select(struct Scsi_Host *instance, Scsi_Cmnd *cmd, int tag)
  *	bytes to transfer, **data - pointer to data pointer.
  *
  * Returns : -1 when different phase is entered without transferring
- *	maximum number of bytes, 0 if all bytes are transfered or exit
+ *	maximum number of bytes, 0 if all bytes are transferred or exit
  *	is in same phase.
  *
  *	Also, *phase, *count, *data are modified in place.
@@ -1911,7 +1911,7 @@ static int do_abort(struct Scsi_Host *host)
  *	bytes to transfer, **data - pointer to data pointer.
  *
  * Returns : -1 when different phase is entered without transferring
- *	maximum number of bytes, 0 if all bytes or transfered or exit
+ *	maximum number of bytes, 0 if all bytes or transferred or exit
  *	is in same phase.
  *
  *	Also, *phase, *count, *data are modified in place.
diff --git a/drivers/scsi/atp870u.c b/drivers/scsi/atp870u.c
index 76029d5..7e6eca4 100644
--- a/drivers/scsi/atp870u.c
+++ b/drivers/scsi/atp870u.c
@@ -1228,7 +1228,7 @@ TCM_5:			/* isolation complete..  */
 	printk(" \n%x %x %x %s\n ",assignid_map,mbuf[0],mbuf[1],&mbuf[2]); */
 	i = 15;
 	j = mbuf[0];
-	if ((j & 0x20) != 0) {	/* bit5=1:ID upto 7      */
+	if ((j & 0x20) != 0) {	/* bit5=1:ID up to 7      */
 		i = 7;
 	}
 	if ((j & 0x06) == 0) {	/* IDvalid?             */
diff --git a/drivers/scsi/be2iscsi/be_cmds.h b/drivers/scsi/be2iscsi/be_cmds.h
index 5218de4..fbd1dc2 100644
--- a/drivers/scsi/be2iscsi/be_cmds.h
+++ b/drivers/scsi/be2iscsi/be_cmds.h
@@ -877,7 +877,7 @@ struct be_all_if_id {
 						 */
 #define CXN_KILLED_PDU_SIZE_EXCEEDS_DSL 3	/* Connection got invalidated
 						 * internally
-						 * due to a recieved PDU
+						 * due to a received PDU
 						 * size > DSL
 						 */
 #define CXN_KILLED_BURST_LEN_MISMATCH   4	/* Connection got invalidated
@@ -886,7 +886,7 @@ struct be_all_if_id {
 						 * FBL/MBL.
 						 */
 #define CXN_KILLED_AHS_RCVD		5	/* Connection got invalidated
-						 * internally due to a recieved
+						 * internally due to a received
 						 * PDU Hdr that has
 						 * AHS */
 #define CXN_KILLED_HDR_DIGEST_ERR	6	/* Connection got invalidated
@@ -899,12 +899,12 @@ struct be_all_if_id {
 						 * pdu hdr
 						 */
 #define CXN_KILLED_STALE_ITT_TTT_RCVD	8	/* Connection got invalidated
-						 * internally due to a recieved
+						 * internally due to a received
 						 * ITT/TTT that does not belong
 						 * to this Connection
 						 */
 #define CXN_KILLED_INVALID_ITT_TTT_RCVD 9	/* Connection got invalidated
-						 * internally due to recieved
+						 * internally due to received
 						 * ITT/TTT value > Max
 						 * Supported ITTs/TTTs
 						 */
@@ -936,21 +936,21 @@ struct be_all_if_id {
 						 * index.
 						 */
 #define CXN_KILLED_OVER_RUN_RESIDUAL	16	/* Command got invalidated
-						 * internally due to recived
+						 * internally due to received
 						 * command has residual
 						 * over run bytes.
 						 */
 #define CXN_KILLED_UNDER_RUN_RESIDUAL	17	/* Command got invalidated
-						 * internally due to recived
+						 * internally due to received
 						 * command has residual under
 						 * run bytes.
 						 */
 #define CMD_KILLED_INVALID_STATSN_RCVD	18	/* Command got invalidated
-						 * internally due to a recieved
+						 * internally due to a received
 						 * PDU has an invalid StatusSN
 						 */
 #define CMD_KILLED_INVALID_R2T_RCVD	19	/* Command got invalidated
-						 * internally due to a recieved
+						 * internally due to a received
 						 * an R2T with some invalid
 						 * fields in it
 						 */
@@ -973,7 +973,7 @@ struct be_all_if_id {
 						 */
 #define CMD_CXN_KILLED_INVALID_DATASN_RCVD 24	/* Command got invalidated
 						 * internally due to a
-						 * recieved PDU has an invalid
+						 * received PDU has an invalid
 						 * DataSN
 						 */
 #define CXN_INVALIDATE_NOTIFY		25	/* Connection invalidation
diff --git a/drivers/scsi/bfa/bfa_core.c b/drivers/scsi/bfa/bfa_core.c
index 1cd5c8b..91838c5 100644
--- a/drivers/scsi/bfa/bfa_core.c
+++ b/drivers/scsi/bfa/bfa_core.c
@@ -355,7 +355,7 @@ bfa_msix_lpu_err(struct bfa_s *bfa, int vec)
 			/*
 			 * ERR_PSS bit needs to be cleared as well in case
 			 * interrups are shared so driver's interrupt handler is
-			 * still called eventhough it is already masked out.
+			 * still called even though it is already masked out.
 			 */
 			curr_value = readl(
 					bfa->ioc.ioc_regs.pss_err_status_reg);
diff --git a/drivers/scsi/bfa/bfa_defs_svc.h b/drivers/scsi/bfa/bfa_defs_svc.h
index 648c841..207f598 100644
--- a/drivers/scsi/bfa/bfa_defs_svc.h
+++ b/drivers/scsi/bfa/bfa_defs_svc.h
@@ -145,7 +145,7 @@ struct bfa_fw_io_stats_s {
 	u32	ioh_data_oor_event;	/*  Data out of range */
 	u32	ioh_ro_ooo_event;	/*  Relative offset out of range */
 	u32	ioh_cpu_owned_event;	/*  IOH hit -iost owned by f/w */
-	u32	ioh_unexp_frame_event;	/*  unexpected frame recieved
+	u32	ioh_unexp_frame_event;	/*  unexpected frame received
 						 *   count */
 	u32	ioh_err_int;		/*  IOH error int during data-phase
 						 *   for scsi write
@@ -566,8 +566,8 @@ struct bfa_itnim_iostats_s {
 	u32	input_reqs;		/*  Data in-bound requests	*/
 	u32	output_reqs;		/*  Data out-bound requests	*/
 	u32	io_comps;		/*  Total IO Completions	*/
-	u32	wr_throughput;		/*  Write data transfered in bytes */
-	u32	rd_throughput;		/*  Read data transfered in bytes  */
+	u32	wr_throughput;		/*  Write data transferred in bytes */
+	u32	rd_throughput;		/*  Read data transferred in bytes  */
 
 	u32	iocomp_ok;		/*  Slowpath IO completions	*/
 	u32	iocomp_underrun;	/*  IO underrun		*/
diff --git a/drivers/scsi/bfa/bfa_fc.h b/drivers/scsi/bfa/bfa_fc.h
index 8e764fa..bf0067e 100644
--- a/drivers/scsi/bfa/bfa_fc.h
+++ b/drivers/scsi/bfa/bfa_fc.h
@@ -315,7 +315,7 @@ struct fc_plogi_csp_s {
 			query_dbc:1,
 			hg_supp:1;
 #endif
-	__be16		rxsz;		/* recieve data_field size */
+	__be16		rxsz;		/* receive data_field size */
 	__be16		conseq;
 	__be16		ro_bitmap;
 	__be32		e_d_tov;
diff --git a/drivers/scsi/bfa/bfa_fcs.c b/drivers/scsi/bfa/bfa_fcs.c
index f674f93..9b43ca4 100644
--- a/drivers/scsi/bfa/bfa_fcs.c
+++ b/drivers/scsi/bfa/bfa_fcs.c
@@ -1033,7 +1033,7 @@ bfa_fcs_fabric_delvport(struct bfa_fcs_fabric_s *fabric,
 
 
 /*
- * Lookup for a vport withing a fabric given its pwwn
+ * Lookup for a vport within a fabric given its pwwn
  */
 struct bfa_fcs_vport_s *
 bfa_fcs_fabric_vport_lookup(struct bfa_fcs_fabric_s *fabric, wwn_t pwwn)
diff --git a/drivers/scsi/bfa/bfa_fcs.h b/drivers/scsi/bfa/bfa_fcs.h
index 0fd6316..61cdce4 100644
--- a/drivers/scsi/bfa/bfa_fcs.h
+++ b/drivers/scsi/bfa/bfa_fcs.h
@@ -705,7 +705,7 @@ enum rport_event {
 	RPSM_EVENT_ADDRESS_CHANGE = 15, /*  Rport's PID has changed     */
 	RPSM_EVENT_ADDRESS_DISC = 16,   /*  Need to Discover rport's PID */
 	RPSM_EVENT_PRLO_RCVD   = 17,    /*  PRLO from remote device     */
-	RPSM_EVENT_PLOGI_RETRY = 18,    /*  Retry PLOGI continously */
+	RPSM_EVENT_PLOGI_RETRY = 18,    /*  Retry PLOGI continuously */
 };
 
 /*
diff --git a/drivers/scsi/bfa/bfa_fcs_lport.c b/drivers/scsi/bfa/bfa_fcs_lport.c
index 43fa986b..1d6be8c 100644
--- a/drivers/scsi/bfa/bfa_fcs_lport.c
+++ b/drivers/scsi/bfa/bfa_fcs_lport.c
@@ -1149,7 +1149,7 @@ bfa_fcs_lport_fdmi_sm_offline(struct bfa_fcs_lport_fdmi_s *fdmi,
 		} else {
 			/*
 			 * For a base port, we should first register the HBA
-			 * atribute. The HBA attribute also contains the base
+			 * attribute. The HBA attribute also contains the base
 			 *  port registration.
 			 */
 			bfa_sm_set_state(fdmi,
diff --git a/drivers/scsi/bfa/bfa_svc.c b/drivers/scsi/bfa/bfa_svc.c
index 1d34921..16d9a5f 100644
--- a/drivers/scsi/bfa/bfa_svc.c
+++ b/drivers/scsi/bfa/bfa_svc.c
@@ -1035,7 +1035,7 @@ bfa_fcxp_free(struct bfa_fcxp_s *fcxp)
  * @param[in]	rport	BFA rport pointer. Could be left NULL for WKA rports
  * @param[in]	vf_id	virtual Fabric ID
  * @param[in]	lp_tag	lport tag
- * @param[in]	cts	use Continous sequence
+ * @param[in]	cts	use Continuous sequence
  * @param[in]	cos	fc Class of Service
  * @param[in]	reqlen	request length, does not include FCHS length
  * @param[in]	fchs	fc Header Pointer. The header content will be copied
@@ -5022,7 +5022,7 @@ bfa_uf_start(struct bfa_s *bfa)
 }
 
 /*
- * Register handler for all unsolicted recieve frames.
+ * Register handler for all unsolicted receive frames.
  *
  * @param[in]	bfa		BFA instance
  * @param[in]	ufrecv	receive handler function
diff --git a/drivers/scsi/bfa/bfa_svc.h b/drivers/scsi/bfa/bfa_svc.h
index 331ad99..5902a45 100644
--- a/drivers/scsi/bfa/bfa_svc.h
+++ b/drivers/scsi/bfa/bfa_svc.h
@@ -127,7 +127,7 @@ struct bfa_fcxp_req_info_s {
 					 * rport nexus is established
 					 */
 	struct fchs_s	fchs;	/*  request FC header structure */
-	u8		cts;	/*  continous sequence */
+	u8		cts;	/*  continuous sequence */
 	u8		class;	/*  FC class for the request/response */
 	u16	max_frmsz;	/*  max send frame size */
 	u16	vf_id;	/*  vsan tag if applicable */
diff --git a/drivers/scsi/bfa/bfad.c b/drivers/scsi/bfa/bfad.c
index 44524cf..0fd510a 100644
--- a/drivers/scsi/bfa/bfad.c
+++ b/drivers/scsi/bfa/bfad.c
@@ -1278,7 +1278,7 @@ bfad_setup_intr(struct bfad_s *bfad)
 			 * interrupts into one vector, so even if we
 			 * can try to request less vectors, we don't
 			 * know how to associate interrupt events to
-			 *  vectors. Linux doesn't dupicate vectors
+			 *  vectors. Linux doesn't duplicate vectors
 			 * in the MSIX table for this case.
 			 */
 
diff --git a/drivers/scsi/bnx2fc/57xx_hsi_bnx2fc.h b/drivers/scsi/bnx2fc/57xx_hsi_bnx2fc.h
index 69d031d..97a61b4 100644
--- a/drivers/scsi/bnx2fc/57xx_hsi_bnx2fc.h
+++ b/drivers/scsi/bnx2fc/57xx_hsi_bnx2fc.h
@@ -898,7 +898,7 @@ struct fcoe_confqe {
 
 
 /*
- * FCoE conection data base
+ * FCoE connection data base
  */
 struct fcoe_conn_db {
 #if defined(__BIG_ENDIAN)
diff --git a/drivers/scsi/bnx2fc/bnx2fc_els.c b/drivers/scsi/bnx2fc/bnx2fc_els.c
index 7a11a25..52c3584 100644
--- a/drivers/scsi/bnx2fc/bnx2fc_els.c
+++ b/drivers/scsi/bnx2fc/bnx2fc_els.c
@@ -397,7 +397,7 @@ void bnx2fc_process_els_compl(struct bnx2fc_cmd *els_req,
 			     &els_req->req_flags)) {
 		BNX2FC_ELS_DBG("Timer context finished processing this "
 			   "els - 0x%x\n", els_req->xid);
-		/* This IO doesnt receive cleanup completion */
+		/* This IO doesn't receive cleanup completion */
 		kref_put(&els_req->refcount, bnx2fc_cmd_release);
 		return;
 	}
diff --git a/drivers/scsi/bnx2fc/bnx2fc_io.c b/drivers/scsi/bnx2fc/bnx2fc_io.c
index d3fc302..1decefb 100644
--- a/drivers/scsi/bnx2fc/bnx2fc_io.c
+++ b/drivers/scsi/bnx2fc/bnx2fc_io.c
@@ -1273,7 +1273,7 @@ static void bnx2fc_lun_reset_cmpl(struct bnx2fc_cmd *io_req)
 						 bnx2fc_cmd_release);
 							/* timer hold */
 				rc = bnx2fc_initiate_abts(cmd);
-				/* abts shouldnt fail in this context */
+				/* abts shouldn't fail in this context */
 				WARN_ON(rc != SUCCESS);
 			} else
 				printk(KERN_ERR PFX "lun_rst: abts already in"
@@ -1308,7 +1308,7 @@ static void bnx2fc_tgt_reset_cmpl(struct bnx2fc_cmd *io_req)
 				kref_put(&io_req->refcount,
 					 bnx2fc_cmd_release); /* timer hold */
 			rc = bnx2fc_initiate_abts(cmd);
-			/* abts shouldnt fail in this context */
+			/* abts shouldn't fail in this context */
 			WARN_ON(rc != SUCCESS);
 
 		} else
diff --git a/drivers/scsi/bnx2fc/bnx2fc_tgt.c b/drivers/scsi/bnx2fc/bnx2fc_tgt.c
index 7cc05e4..a2e3830 100644
--- a/drivers/scsi/bnx2fc/bnx2fc_tgt.c
+++ b/drivers/scsi/bnx2fc/bnx2fc_tgt.c
@@ -395,7 +395,7 @@ void bnx2fc_rport_event_handler(struct fc_lport *lport,
 		rp = rport->dd_data;
 		if (rport->port_id == FC_FID_DIR_SERV) {
 			/*
-			 * bnx2fc_rport structure doesnt exist for
+			 * bnx2fc_rport structure doesn't exist for
 			 * directory server.
 			 * We should not come here, as lport will
 			 * take care of fabric login
diff --git a/drivers/scsi/bnx2i/bnx2i_hwi.c b/drivers/scsi/bnx2i/bnx2i_hwi.c
index 1da34c0..f0b8951 100644
--- a/drivers/scsi/bnx2i/bnx2i_hwi.c
+++ b/drivers/scsi/bnx2i/bnx2i_hwi.c
@@ -173,7 +173,7 @@ void bnx2i_arm_cq_event_coalescing(struct bnx2i_endpoint *ep, u8 action)
 
 /**
  * bnx2i_get_rq_buf - copy RQ buffer contents to driver buffer
- * @conn:		iscsi connection on which RQ event occured
+ * @conn:		iscsi connection on which RQ event occurred
  * @ptr:		driver buffer to which RQ buffer contents is to
  *			be copied
  * @len:		length of valid data inside RQ buf
diff --git a/drivers/scsi/cxgbi/libcxgbi.h b/drivers/scsi/cxgbi/libcxgbi.h
index 0a20fd5..9267844 100644
--- a/drivers/scsi/cxgbi/libcxgbi.h
+++ b/drivers/scsi/cxgbi/libcxgbi.h
@@ -262,9 +262,9 @@ struct cxgbi_skb_tx_cb {
 enum cxgbi_skcb_flags {
 	SKCBF_TX_NEED_HDR,	/* packet needs a header */
 	SKCBF_RX_COALESCED,	/* received whole pdu */
-	SKCBF_RX_HDR,		/* recieved pdu header */
-	SKCBF_RX_DATA,		/* recieved pdu payload */
-	SKCBF_RX_STATUS,	/* recieved ddp status */
+	SKCBF_RX_HDR,		/* received pdu header */
+	SKCBF_RX_DATA,		/* received pdu payload */
+	SKCBF_RX_STATUS,	/* received ddp status */
 	SKCBF_RX_DATA_DDPD,	/* pdu payload ddp'd */
 	SKCBF_RX_HCRC_ERR,	/* header digest error */
 	SKCBF_RX_DCRC_ERR,	/* data digest error */
diff --git a/drivers/scsi/dc395x.c b/drivers/scsi/dc395x.c
index b0f8523..b10b384 100644
--- a/drivers/scsi/dc395x.c
+++ b/drivers/scsi/dc395x.c
@@ -235,7 +235,7 @@ struct ScsiReqBlk {
 
 	u8 sg_count;			/* No of HW sg entries for this request */
 	u8 sg_index;			/* Index of HW sg entry for this request */
-	size_t total_xfer_length;	/* Total number of bytes remaining to be transfered */
+	size_t total_xfer_length;	/* Total number of bytes remaining to be transferred */
 	size_t request_length;		/* Total number of bytes in this request */
 	/*
 	 * The sense buffer handling function, request_sense, uses
@@ -1774,7 +1774,7 @@ static void dc395x_handle_interrupt(struct AdapterCtlBlk *acb,
 		dc395x_statev(acb, srb, &scsi_status);
 
 		/* 
-		 * if there were any exception occured scsi_status
+		 * if there were any exception occurred scsi_status
 		 * will be modify to bus free phase new scsi_status
 		 * transfer out from ... previous dc395x_statev
 		 */
@@ -1954,11 +1954,11 @@ static void sg_verify_length(struct ScsiReqBlk *srb)
 static void sg_update_list(struct ScsiReqBlk *srb, u32 left)
 {
 	u8 idx;
-	u32 xferred = srb->total_xfer_length - left; /* bytes transfered */
+	u32 xferred = srb->total_xfer_length - left; /* bytes transferred */
 	struct SGentry *psge = srb->segment_x + srb->sg_index;
 
 	dprintkdbg(DBG_0,
-		"sg_update_list: Transfered %i of %i bytes, %i remain\n",
+		"sg_update_list: Transferred %i of %i bytes, %i remain\n",
 		xferred, srb->total_xfer_length, left);
 	if (xferred == 0) {
 		/* nothing to update since we did not transfer any data */
@@ -1990,7 +1990,7 @@ static void sg_update_list(struct ScsiReqBlk *srb, u32 left)
 
 
 /*
- * We have transfered a single byte (PIO mode?) and need to update
+ * We have transferred a single byte (PIO mode?) and need to update
  * the count of bytes remaining (total_xfer_length) and update the sg
  * entry to either point to next byte in the current sg entry, or of
  * already at the end to point to the start of the next sg entry
@@ -2029,7 +2029,7 @@ static void cleanup_after_transfer(struct AdapterCtlBlk *acb,
 
 
 /*
- * Those no of bytes will be transfered w/ PIO through the SCSI FIFO
+ * Those no of bytes will be transferred w/ PIO through the SCSI FIFO
  * Seems to be needed for unknown reasons; could be a hardware bug :-(
  */
 #define DC395x_LASTPIO 4
@@ -2256,7 +2256,7 @@ static void data_in_phase0(struct AdapterCtlBlk *acb, struct ScsiReqBlk *srb,
 			DC395x_read32(acb, TRM_S1040_DMA_CXCNT),
 			srb->total_xfer_length, d_left_counter);
 #if DC395x_LASTPIO
-		/* KG: Less than or equal to 4 bytes can not be transfered via DMA, it seems. */
+		/* KG: Less than or equal to 4 bytes can not be transferred via DMA, it seems. */
 		if (d_left_counter
 		    && srb->total_xfer_length <= DC395x_LASTPIO) {
 			size_t left_io = srb->total_xfer_length;
diff --git a/drivers/scsi/dc395x.h b/drivers/scsi/dc395x.h
index b38360e..fbf35e3 100644
--- a/drivers/scsi/dc395x.h
+++ b/drivers/scsi/dc395x.h
@@ -617,7 +617,7 @@ struct ScsiInqData
 #define NTC_DO_SEND_START		0x08	/* Send start command SPINUP		*/
 #define NTC_DO_DISCONNECT		0x04	/* Enable SCSI disconnect		*/
 #define NTC_DO_SYNC_NEGO		0x02	/* Sync negotiation			*/
-#define NTC_DO_PARITY_CHK		0x01	/* (it sould define at NAC)		*/
+#define NTC_DO_PARITY_CHK		0x01	/* (it should define at NAC)		*/
 						/* Parity check enable			*/
 
 /************************************************************************/
diff --git a/drivers/scsi/device_handler/scsi_dh_alua.c b/drivers/scsi/device_handler/scsi_dh_alua.c
index 7cae0bc..42fe529 100644
--- a/drivers/scsi/device_handler/scsi_dh_alua.c
+++ b/drivers/scsi/device_handler/scsi_dh_alua.c
@@ -541,7 +541,7 @@ static int alua_check_sense(struct scsi_device *sdev,
  *
  * Evaluate the Target Port Group State.
  * Returns SCSI_DH_DEV_OFFLINED if the path is
- * found to be unuseable.
+ * found to be unusable.
  */
 static int alua_rtpg(struct scsi_device *sdev, struct alua_dh_data *h)
 {
@@ -620,7 +620,7 @@ static int alua_rtpg(struct scsi_device *sdev, struct alua_dh_data *h)
 		break;
 	case TPGS_STATE_OFFLINE:
 	case TPGS_STATE_UNAVAILABLE:
-		/* Path unuseable for unavailable/offline */
+		/* Path unusable for unavailable/offline */
 		err = SCSI_DH_DEV_OFFLINED;
 		break;
 	default:
diff --git a/drivers/scsi/dpt/sys_info.h b/drivers/scsi/dpt/sys_info.h
index a90c4cb..a4aa1c3 100644
--- a/drivers/scsi/dpt/sys_info.h
+++ b/drivers/scsi/dpt/sys_info.h
@@ -79,9 +79,9 @@
    typedef struct  {
 #endif
 
-   uSHORT       cylinders;      /* Upto 1024 */
-   uCHAR        heads;          /* Upto 255 */
-   uCHAR        sectors;        /* Upto 63 */
+   uSHORT       cylinders;      /* Up to 1024 */
+   uCHAR        heads;          /* Up to 255 */
+   uCHAR        sectors;        /* Up to 63 */
 
 #ifdef  __cplusplus
 
diff --git a/drivers/scsi/eata.c b/drivers/scsi/eata.c
index 53925ac..0eb4fe6 100644
--- a/drivers/scsi/eata.c
+++ b/drivers/scsi/eata.c
@@ -63,7 +63,7 @@
  *          ep:[y|n]      eisa_probe=[1|0]  CONFIG_EISA defined
  *          pp:[y|n]      pci_probe=[1|0]   CONFIG_PCI  defined
  *
- *          The default action is to perform probing if the corrisponding
+ *          The default action is to perform probing if the corresponding
  *          bus is configured and to skip probing otherwise.
  *
  *        + If pci_probe is in effect and a list of I/O  ports is specified
diff --git a/drivers/scsi/fcoe/fcoe_ctlr.c b/drivers/scsi/fcoe/fcoe_ctlr.c
index c93f007..9d38be2 100644
--- a/drivers/scsi/fcoe/fcoe_ctlr.c
+++ b/drivers/scsi/fcoe/fcoe_ctlr.c
@@ -656,7 +656,7 @@ int fcoe_ctlr_els_send(struct fcoe_ctlr *fip, struct fc_lport *lport,
 		 * If non-FIP, we may have gotten an SID by accepting an FLOGI
 		 * from a point-to-point connection.  Switch to using
 		 * the source mac based on the SID.  The destination
-		 * MAC in this case would have been set by receving the
+		 * MAC in this case would have been set by receiving the
 		 * FLOGI.
 		 */
 		if (fip->state == FIP_ST_NON_FIP) {
@@ -1876,7 +1876,7 @@ static void fcoe_ctlr_vn_send(struct fcoe_ctlr *fip,
  * fcoe_ctlr_vn_rport_callback - Event handler for rport events.
  * @lport: The lport which is receiving the event
  * @rdata: remote port private data
- * @event: The event that occured
+ * @event: The event that occurred
  *
  * Locking Note:  The rport lock must not be held when calling this function.
  */
diff --git a/drivers/scsi/fdomain.c b/drivers/scsi/fdomain.c
index 69b7aa5..643f6d5 100644
--- a/drivers/scsi/fdomain.c
+++ b/drivers/scsi/fdomain.c
@@ -174,7 +174,7 @@
  Future Domain sold DOS BIOS source for $250 and the UN*X driver source was
  $750, but these required a non-disclosure agreement, so even if I could
  have afforded them, they would *not* have been useful for writing this
- publically distributable driver.  Future Domain technical support has
+ publicly distributable driver.  Future Domain technical support has
  provided some information on the phone and have sent a few useful FAXs.
  They have been much more helpful since they started to recognize that the
  word "Linux" refers to an operating system :-).
diff --git a/drivers/scsi/fnic/fnic_fcs.c b/drivers/scsi/fnic/fnic_fcs.c
index 2b48d79..3c53c34 100644
--- a/drivers/scsi/fnic/fnic_fcs.c
+++ b/drivers/scsi/fnic/fnic_fcs.c
@@ -411,7 +411,7 @@ int fnic_rq_cmpl_handler(struct fnic *fnic, int rq_work_to_do)
 			err = vnic_rq_fill(&fnic->rq[i], fnic_alloc_rq_frame);
 			if (err)
 				shost_printk(KERN_ERR, fnic->lport->host,
-					     "fnic_alloc_rq_frame cant alloc"
+					     "fnic_alloc_rq_frame can't alloc"
 					     " frame\n");
 		}
 		tot_rq_work_done += cur_work_done;
diff --git a/drivers/scsi/fnic/fnic_scsi.c b/drivers/scsi/fnic/fnic_scsi.c
index 22d0240..538b31c 100644
--- a/drivers/scsi/fnic/fnic_scsi.c
+++ b/drivers/scsi/fnic/fnic_scsi.c
@@ -1123,7 +1123,7 @@ void fnic_rport_exch_reset(struct fnic *fnic, u32 port_id)
 					    fc_lun.scsi_lun, io_req)) {
 			/*
 			 * Revert the cmd state back to old state, if
-			 * it hasnt changed in between. This cmd will get
+			 * it hasn't changed in between. This cmd will get
 			 * aborted later by scsi_eh, or cleaned up during
 			 * lun reset
 			 */
@@ -1208,7 +1208,7 @@ void fnic_terminate_rport_io(struct fc_rport *rport)
 					    fc_lun.scsi_lun, io_req)) {
 			/*
 			 * Revert the cmd state back to old state, if
-			 * it hasnt changed in between. This cmd will get
+			 * it hasn't changed in between. This cmd will get
 			 * aborted later by scsi_eh, or cleaned up during
 			 * lun reset
 			 */
diff --git a/drivers/scsi/g_NCR5380.c b/drivers/scsi/g_NCR5380.c
index 427a56d..81182ba 100644
--- a/drivers/scsi/g_NCR5380.c
+++ b/drivers/scsi/g_NCR5380.c
@@ -566,7 +566,7 @@ generic_NCR5380_biosparam(struct scsi_device *sdev, struct block_device *bdev,
  *	@dst: buffer to read into
  *	@len: buffer length
  *
- *	Perform a psuedo DMA mode read from an NCR53C400 or equivalent
+ *	Perform a pseudo DMA mode read from an NCR53C400 or equivalent
  *	controller
  */
  
@@ -650,7 +650,7 @@ static inline int NCR5380_pread(struct Scsi_Host *instance, unsigned char *dst,
  *	@dst: buffer to read into
  *	@len: buffer length
  *
- *	Perform a psuedo DMA mode read from an NCR53C400 or equivalent
+ *	Perform a pseudo DMA mode read from an NCR53C400 or equivalent
  *	controller
  */
 
diff --git a/drivers/scsi/gdth.h b/drivers/scsi/gdth.h
index 120a062..d969855 100644
--- a/drivers/scsi/gdth.h
+++ b/drivers/scsi/gdth.h
@@ -895,7 +895,7 @@ typedef struct {
         u8          ldr_no;                 /* log. drive no. */
         u8          rw_attribs;             /* r/w attributes */
         u8          cluster_type;           /* cluster properties */
-        u8          media_changed;          /* Flag:MOUNT/UNMOUNT occured */
+        u8          media_changed;          /* Flag:MOUNT/UNMOUNT occurred */
         u32         start_sec;              /* start sector */
     } hdr[MAX_LDRIVES];                         /* host drives */
     struct {
diff --git a/drivers/scsi/gvp11.c b/drivers/scsi/gvp11.c
index 2ce26eb..50bb541 100644
--- a/drivers/scsi/gvp11.c
+++ b/drivers/scsi/gvp11.c
@@ -300,7 +300,7 @@ static int __devinit gvp11_probe(struct zorro_dev *z,
 	/*
 	 * Rumors state that some GVP ram boards use the same product
 	 * code as the SCSI controllers. Therefore if the board-size
-	 * is not 64KB we asume it is a ram board and bail out.
+	 * is not 64KB we assume it is a ram board and bail out.
 	 */
 	if (zorro_resource_len(z) != 0x10000)
 		return -ENODEV;
diff --git a/drivers/scsi/imm.c b/drivers/scsi/imm.c
index 99aa0e5..26cd9d1 100644
--- a/drivers/scsi/imm.c
+++ b/drivers/scsi/imm.c
@@ -3,7 +3,7 @@
  * 
  * (The IMM is the embedded controller in the ZIP Plus drive.)
  * 
- * My unoffical company acronym list is 21 pages long:
+ * My unofficial company acronym list is 21 pages long:
  *      FLA:    Four letter acronym with built in facility for
  *              future expansion to five letters.
  */
diff --git a/drivers/scsi/initio.c b/drivers/scsi/initio.c
index 9627d06..dd741bc 100644
--- a/drivers/scsi/initio.c
+++ b/drivers/scsi/initio.c
@@ -242,7 +242,7 @@ static u8 i91udftNvRam[64] =
 
 static u8 initio_rate_tbl[8] =	/* fast 20      */
 {
-				/* nanosecond devide by 4 */
+				/* nanosecond divide by 4 */
 	12,			/* 50ns,  20M   */
 	18,			/* 75ns,  13.3M */
 	25,			/* 100ns, 10M   */
@@ -1917,7 +1917,7 @@ static int int_initio_scsi_rst(struct initio_host * host)
 }
 
 /**
- *	int_initio_scsi_resel	-	Reselection occured
+ *	int_initio_scsi_resel	-	Reselection occurred
  *	@host: InitIO host adapter
  *
  *	A SCSI reselection event has been signalled and the interrupt
diff --git a/drivers/scsi/initio.h b/drivers/scsi/initio.h
index e58af9e..219b901 100644
--- a/drivers/scsi/initio.h
+++ b/drivers/scsi/initio.h
@@ -116,7 +116,7 @@ typedef struct {
 #define TUL_SBusId      0x89	/* 09 R   SCSI BUS ID                   */
 #define TUL_STimeOut    0x8A	/* 0A W   Sel/Resel Time Out Register   */
 #define TUL_SIdent      0x8A	/* 0A R   Identify Message Register     */
-#define TUL_SAvail      0x8A	/* 0A R   Availiable Counter Register   */
+#define TUL_SAvail      0x8A	/* 0A R   Available Counter Register   */
 #define TUL_SData       0x8B	/* 0B R/W SCSI data in/out              */
 #define TUL_SFifo       0x8C	/* 0C R/W FIFO                          */
 #define TUL_SSignal     0x90	/* 10 R/W SCSI signal in/out            */
@@ -389,7 +389,7 @@ struct scsi_ctrl_blk {
 /* Bit Definition for status */
 #define SCB_RENT        0x01
 #define SCB_PEND        0x02
-#define SCB_CONTIG      0x04	/* Contigent Allegiance */
+#define SCB_CONTIG      0x04	/* Contingent Allegiance */
 #define SCB_SELECT      0x08
 #define SCB_BUSY        0x10
 #define SCB_DONE        0x20
diff --git a/drivers/scsi/ips.c b/drivers/scsi/ips.c
index b2511ac..218f71a 100644
--- a/drivers/scsi/ips.c
+++ b/drivers/scsi/ips.c
@@ -137,7 +137,7 @@
 /*          - Fix path/name for scsi_hosts.h include for 2.6 kernels         */
 /*          - Fix sort order of 7k                                           */
 /*          - Remove 3 unused "inline" functions                             */
-/* 7.12.xx  - Use STATIC functions whereever possible                        */
+/* 7.12.xx  - Use STATIC functions wherever possible                        */
 /*          - Clean up deprecated MODULE_PARM calls                          */
 /* 7.12.05  - Remove Version Matching per IBM request                        */
 /*****************************************************************************/
@@ -1665,7 +1665,7 @@ ips_flash_copperhead(ips_ha_t * ha, ips_passthru_t * pt, ips_scb_t * scb)
 	int datasize;
 
 	/* Trombone is the only copperhead that can do packet flash, but only
-	 * for firmware. No one said it had to make sence. */
+	 * for firmware. No one said it had to make sense. */
 	if (IPS_IS_TROMBONE(ha) && pt->CoppCP.cmd.flashfw.type == IPS_FW_IMAGE) {
 		if (ips_usrcmd(ha, pt, scb))
 			return IPS_SUCCESS;
diff --git a/drivers/scsi/ips.h b/drivers/scsi/ips.h
index 4e49fbc..f2df059 100644
--- a/drivers/scsi/ips.h
+++ b/drivers/scsi/ips.h
@@ -1193,7 +1193,7 @@ typedef struct {
 #define IPS_VER_SEBRING "7.12.02"
 #define IPS_VER_KEYWEST "7.12.02"
 
-/* Compatability IDs for various adapters */
+/* Compatibility IDs for various adapters */
 #define IPS_COMPAT_UNKNOWN ""
 #define IPS_COMPAT_CURRENT "KW710"
 #define IPS_COMPAT_SERVERAID1 "2.25.01"
diff --git a/drivers/scsi/iscsi_tcp.c b/drivers/scsi/iscsi_tcp.c
index a860452..3df9853 100644
--- a/drivers/scsi/iscsi_tcp.c
+++ b/drivers/scsi/iscsi_tcp.c
@@ -295,7 +295,7 @@ static int iscsi_sw_tcp_xmit(struct iscsi_conn *conn)
 		rc = iscsi_sw_tcp_xmit_segment(tcp_conn, segment);
 		/*
 		 * We may not have been able to send data because the conn
-		 * is getting stopped. libiscsi will know so propogate err
+		 * is getting stopped. libiscsi will know so propagate err
 		 * for it to do the right thing.
 		 */
 		if (rc == -EAGAIN)
diff --git a/drivers/scsi/libfc/fc_exch.c b/drivers/scsi/libfc/fc_exch.c
index 28231ba..77035a7 100644
--- a/drivers/scsi/libfc/fc_exch.c
+++ b/drivers/scsi/libfc/fc_exch.c
@@ -1042,7 +1042,7 @@ static void fc_exch_set_addr(struct fc_exch *ep,
 }
 
 /**
- * fc_seq_els_rsp_send() - Send an ELS response using infomation from
+ * fc_seq_els_rsp_send() - Send an ELS response using information from
  *			   the existing sequence/exchange.
  * @fp:	      The received frame
  * @els_cmd:  The ELS command to be sent
@@ -1153,7 +1153,7 @@ static void fc_seq_send_ack(struct fc_seq *sp, const struct fc_frame *rx_fp)
  * fc_exch_send_ba_rjt() - Send BLS Reject
  * @rx_fp:  The frame being rejected
  * @reason: The reason the frame is being rejected
- * @explan: The explaination for the rejection
+ * @explan: The explanation for the rejection
  *
  * This is for rejecting BA_ABTS only.
  */
diff --git a/drivers/scsi/libfc/fc_fcp.c b/drivers/scsi/libfc/fc_fcp.c
index b1b03af..5b799a3 100644
--- a/drivers/scsi/libfc/fc_fcp.c
+++ b/drivers/scsi/libfc/fc_fcp.c
@@ -870,7 +870,7 @@ static void fc_fcp_resp(struct fc_fcp_pkt *fsp, struct fc_frame *fp)
 				fsp->scsi_resid = ntohl(rp_ex->fr_resid);
 				/*
 				 * The cmnd->underflow is the minimum number of
-				 * bytes that must be transfered for this
+				 * bytes that must be transferred for this
 				 * command.  Provided a sense condition is not
 				 * present, make sure the actual amount
 				 * transferred is at least the underflow value
@@ -1306,7 +1306,7 @@ static int fc_lun_reset(struct fc_lport *lport, struct fc_fcp_pkt *fsp,
 }
 
 /**
- * fc_tm_done() - Task Managment response handler
+ * fc_tm_done() - Task Management response handler
  * @seq: The sequence that the response is on
  * @fp:	 The response frame
  * @arg: The FCP packet the response is for
diff --git a/drivers/scsi/libfc/fc_lport.c b/drivers/scsi/libfc/fc_lport.c
index 8c08b21..906bbca 100644
--- a/drivers/scsi/libfc/fc_lport.c
+++ b/drivers/scsi/libfc/fc_lport.c
@@ -52,7 +52,7 @@
  * while making the callback. To ensure that the rport is not free'd while
  * processing the callback the rport callbacks are serialized through a
  * single-threaded workqueue. An rport would never be free'd while in a
- * callback handler becuase no other rport work in this queue can be executed
+ * callback handler because no other rport work in this queue can be executed
  * at the same time.
  *
  * When discovery succeeds or fails a callback is made to the lport as
@@ -163,7 +163,7 @@ static int fc_frame_drop(struct fc_lport *lport, struct fc_frame *fp)
  * fc_lport_rport_callback() - Event handler for rport events
  * @lport: The lport which is receiving the event
  * @rdata: private remote port data
- * @event: The event that occured
+ * @event: The event that occurred
  *
  * Locking Note: The rport lock should not be held when calling
  *		 this function.
@@ -379,7 +379,7 @@ static void fc_lport_add_fc4_type(struct fc_lport *lport, enum fc_fh_type type)
 
 /**
  * fc_lport_recv_rlir_req() - Handle received Registered Link Incident Report.
- * @lport: Fibre Channel local port recieving the RLIR
+ * @lport: Fibre Channel local port receiving the RLIR
  * @fp:	   The RLIR request frame
  *
  * Locking Note: The lport lock is expected to be held before calling
@@ -396,7 +396,7 @@ static void fc_lport_recv_rlir_req(struct fc_lport *lport, struct fc_frame *fp)
 
 /**
  * fc_lport_recv_echo_req() - Handle received ECHO request
- * @lport: The local port recieving the ECHO
+ * @lport: The local port receiving the ECHO
  * @fp:	   ECHO request frame
  *
  * Locking Note: The lport lock is expected to be held before calling
@@ -432,7 +432,7 @@ static void fc_lport_recv_echo_req(struct fc_lport *lport,
 
 /**
  * fc_lport_recv_rnid_req() - Handle received Request Node ID data request
- * @lport: The local port recieving the RNID
+ * @lport: The local port receiving the RNID
  * @fp:	   The RNID request frame
  *
  * Locking Note: The lport lock is expected to be held before calling
@@ -491,7 +491,7 @@ static void fc_lport_recv_rnid_req(struct fc_lport *lport,
 
 /**
  * fc_lport_recv_logo_req() - Handle received fabric LOGO request
- * @lport: The local port recieving the LOGO
+ * @lport: The local port receiving the LOGO
  * @fp:	   The LOGO request frame
  *
  * Locking Note: The lport lock is exected to be held before calling
@@ -771,7 +771,7 @@ EXPORT_SYMBOL(fc_lport_set_local_id);
 
 /**
  * fc_lport_recv_flogi_req() - Receive a FLOGI request
- * @lport: The local port that recieved the request
+ * @lport: The local port that received the request
  * @rx_fp: The FLOGI frame
  *
  * A received FLOGI request indicates a point-to-point connection.
@@ -858,7 +858,7 @@ out:
  * if an rport should handle the request.
  *
  * Locking Note: This function should not be called with the lport
- *		 lock held becuase it will grab the lock.
+ *		 lock held because it will grab the lock.
  */
 static void fc_lport_recv_els_req(struct fc_lport *lport,
 				  struct fc_frame *fp)
@@ -925,7 +925,7 @@ struct fc4_prov fc_lport_els_prov = {
  * @fp: The frame the request is in
  *
  * Locking Note: This function should not be called with the lport
- *		 lock held becuase it may grab the lock.
+ *		 lock held because it may grab the lock.
  */
 static void fc_lport_recv_req(struct fc_lport *lport,
 			      struct fc_frame *fp)
diff --git a/drivers/scsi/libsas/sas_expander.c b/drivers/scsi/libsas/sas_expander.c
index f3f693b..874e29d 100644
--- a/drivers/scsi/libsas/sas_expander.c
+++ b/drivers/scsi/libsas/sas_expander.c
@@ -240,7 +240,7 @@ static int sas_ex_phy_discover_helper(struct domain_device *dev, u8 *disc_req,
 				       disc_resp, DISCOVER_RESP_SIZE);
 		if (res)
 			return res;
-		/* This is detecting a failure to transmit inital
+		/* This is detecting a failure to transmit initial
 		 * dev to host FIS as described in section G.5 of
 		 * sas-2 r 04b */
 		dr = &((struct smp_resp *)disc_resp)->disc;
diff --git a/drivers/scsi/lpfc/lpfc_attr.c b/drivers/scsi/lpfc/lpfc_attr.c
index 4e0faa0..17d7893 100644
--- a/drivers/scsi/lpfc/lpfc_attr.c
+++ b/drivers/scsi/lpfc/lpfc_attr.c
@@ -4515,7 +4515,7 @@ static FC_RPORT_ATTR(field, S_IRUGO, lpfc_show_rport_##field, NULL)
  * Description:
  * This function is called by the transport after the @fc_vport's symbolic name
  * has been changed. This function re-registers the symbolic name with the
- * switch to propogate the change into the fabric if the vport is active.
+ * switch to propagate the change into the fabric if the vport is active.
  **/
 static void
 lpfc_set_vport_symbolic_name(struct fc_vport *fc_vport)
diff --git a/drivers/scsi/lpfc/lpfc_bsg.c b/drivers/scsi/lpfc/lpfc_bsg.c
index 793b9f1..77b2871 100644
--- a/drivers/scsi/lpfc/lpfc_bsg.c
+++ b/drivers/scsi/lpfc/lpfc_bsg.c
@@ -1939,7 +1939,7 @@ out:
  * @rxxri: Receive exchange id
  * @len: Number of data bytes
  *
- * This function allocates and posts a data buffer of sufficient size to recieve
+ * This function allocates and posts a data buffer of sufficient size to receive
  * an unsolicted CT command.
  **/
 static int lpfcdiag_loop_post_rxbufs(struct lpfc_hba *phba, uint16_t rxxri,
diff --git a/drivers/scsi/lpfc/lpfc_debugfs.c b/drivers/scsi/lpfc/lpfc_debugfs.c
index a753581..3d96774 100644
--- a/drivers/scsi/lpfc/lpfc_debugfs.c
+++ b/drivers/scsi/lpfc/lpfc_debugfs.c
@@ -908,7 +908,7 @@ lpfc_debugfs_dumpData_open(struct inode *inode, struct file *file)
 	if (!debug)
 		goto out;
 
-	/* Round to page boundry */
+	/* Round to page boundary */
 	printk(KERN_ERR "9059 BLKGRD:  %s: _dump_buf_data=0x%p\n",
 			__func__, _dump_buf_data);
 	debug->buffer = _dump_buf_data;
@@ -938,7 +938,7 @@ lpfc_debugfs_dumpDif_open(struct inode *inode, struct file *file)
 	if (!debug)
 		goto out;
 
-	/* Round to page boundry */
+	/* Round to page boundary */
 	printk(KERN_ERR	"9060 BLKGRD: %s: _dump_buf_dif=0x%p file=%s\n",
 		__func__, _dump_buf_dif, file->f_dentry->d_name.name);
 	debug->buffer = _dump_buf_dif;
@@ -2158,7 +2158,7 @@ lpfc_debugfs_initialize(struct lpfc_vport *vport)
 			debugfs_create_dir(name, phba->hba_debugfs_root);
 		if (!vport->vport_debugfs_root) {
 			lpfc_printf_vlog(vport, KERN_ERR, LOG_INIT,
-					 "0417 Cant create debugfs\n");
+					 "0417 Can't create debugfs\n");
 			goto debug_failed;
 		}
 		atomic_inc(&phba->debugfs_vport_count);
@@ -2211,7 +2211,7 @@ lpfc_debugfs_initialize(struct lpfc_vport *vport)
 				 vport, &lpfc_debugfs_op_nodelist);
 	if (!vport->debug_nodelist) {
 		lpfc_printf_vlog(vport, KERN_ERR, LOG_INIT,
-				 "0409 Cant create debugfs nodelist\n");
+				 "0409 Can't create debugfs nodelist\n");
 		goto debug_failed;
 	}
 
diff --git a/drivers/scsi/lpfc/lpfc_els.c b/drivers/scsi/lpfc/lpfc_els.c
index 735028f..d34b69f 100644
--- a/drivers/scsi/lpfc/lpfc_els.c
+++ b/drivers/scsi/lpfc/lpfc_els.c
@@ -102,7 +102,7 @@ lpfc_els_chk_latt(struct lpfc_vport *vport)
 			 phba->pport->port_state);
 
 	/* CLEAR_LA should re-enable link attention events and
-	 * we should then imediately take a LATT event. The
+	 * we should then immediately take a LATT event. The
 	 * LATT processing should call lpfc_linkdown() which
 	 * will cleanup any left over in-progress discovery
 	 * events.
@@ -1599,7 +1599,7 @@ out:
  * This routine is the completion callback function for issuing the Port
  * Login (PLOGI) command. For PLOGI completion, there must be an active
  * ndlp on the vport node list that matches the remote node ID from the
- * PLOGI reponse IOCB. If such ndlp does not exist, the PLOGI is simply
+ * PLOGI response IOCB. If such ndlp does not exist, the PLOGI is simply
  * ignored and command IOCB released. The PLOGI response IOCB status is
  * checked for error conditons. If there is error status reported, PLOGI
  * retry shall be attempted by invoking the lpfc_els_retry() routine.
diff --git a/drivers/scsi/lpfc/lpfc_hbadisc.c b/drivers/scsi/lpfc/lpfc_hbadisc.c
index 154c715..3014983 100644
--- a/drivers/scsi/lpfc/lpfc_hbadisc.c
+++ b/drivers/scsi/lpfc/lpfc_hbadisc.c
@@ -739,7 +739,7 @@ lpfc_do_work(void *p)
 
 /*
  * This is only called to handle FC worker events. Since this a rare
- * occurance, we allocate a struct lpfc_work_evt structure here instead of
+ * occurrence, we allocate a struct lpfc_work_evt structure here instead of
  * embedding it in the IOCB.
  */
 int
@@ -1348,7 +1348,7 @@ lpfc_register_fcf(struct lpfc_hba *phba)
 	int rc;
 
 	spin_lock_irq(&phba->hbalock);
-	/* If the FCF is not availabe do nothing. */
+	/* If the FCF is not available do nothing. */
 	if (!(phba->fcf.fcf_flag & FCF_AVAILABLE)) {
 		phba->hba_flag &= ~(FCF_TS_INPROG | FCF_RR_INPROG);
 		spin_unlock_irq(&phba->hbalock);
@@ -1538,7 +1538,7 @@ lpfc_match_fcf_conn_list(struct lpfc_hba *phba,
 
 		/*
 		 * If user did not specify any addressing mode, or if the
-		 * prefered addressing mode specified by user is not supported
+		 * preferred addressing mode specified by user is not supported
 		 * by FCF, allow fabric to pick the addressing mode.
 		 */
 		*addr_mode = bf_get(lpfc_fcf_record_mac_addr_prov,
@@ -1553,7 +1553,7 @@ lpfc_match_fcf_conn_list(struct lpfc_hba *phba,
 				FCFCNCT_AM_SPMA) ?
 				LPFC_FCF_SPMA : LPFC_FCF_FPMA;
 		/*
-		 * If the user specified a prefered address mode, use the
+		 * If the user specified a preferred address mode, use the
 		 * addr mode only if FCF support the addr_mode.
 		 */
 		else if ((conn_entry->conn_rec.flags & FCFCNCT_AM_VALID) &&
@@ -3117,7 +3117,7 @@ lpfc_mbx_cmpl_reg_login(struct lpfc_hba *phba, LPFC_MBOXQ_t *pmb)
 		 * back at reg login state so this
 		 * mbox needs to be ignored becase
 		 * there is another reg login in
-		 * proccess.
+		 * process.
 		 */
 		spin_lock_irq(shost->host_lock);
 		ndlp->nlp_flag &= ~NLP_IGNR_REG_CMPL;
@@ -4477,7 +4477,7 @@ lpfc_setup_disc_node(struct lpfc_vport *vport, uint32_t did)
 	if ((vport->fc_flag & FC_RSCN_MODE) &&
 	    !(vport->fc_flag & FC_NDISC_ACTIVE)) {
 		if (lpfc_rscn_payload_check(vport, did)) {
-			/* If we've already recieved a PLOGI from this NPort
+			/* If we've already received a PLOGI from this NPort
 			 * we don't need to try to discover it again.
 			 */
 			if (ndlp->nlp_flag & NLP_RCV_PLOGI)
@@ -4493,7 +4493,7 @@ lpfc_setup_disc_node(struct lpfc_vport *vport, uint32_t did)
 		} else
 			ndlp = NULL;
 	} else {
-		/* If we've already recieved a PLOGI from this NPort,
+		/* If we've already received a PLOGI from this NPort,
 		 * or we are already in the process of discovery on it,
 		 * we don't need to try to discover it again.
 		 */
@@ -5756,7 +5756,7 @@ lpfc_read_fcoe_param(struct lpfc_hba *phba,
  * @size: Size of the data buffer.
  * @rec_type: Record type to be searched.
  *
- * This function searches config region data to find the begining
+ * This function searches config region data to find the beginning
  * of the record specified by record_type. If record found, this
  * function return pointer to the record else return NULL.
  */
diff --git a/drivers/scsi/lpfc/lpfc_init.c b/drivers/scsi/lpfc/lpfc_init.c
index e6ebe51..505f884 100644
--- a/drivers/scsi/lpfc/lpfc_init.c
+++ b/drivers/scsi/lpfc/lpfc_init.c
@@ -4466,7 +4466,7 @@ lpfc_sli4_driver_resource_unset(struct lpfc_hba *phba)
 }
 
 /**
- * lpfc_init_api_table_setup - Set up init api fucntion jump table
+ * lpfc_init_api_table_setup - Set up init api function jump table
  * @phba: The hba struct for which this call is being executed.
  * @dev_grp: The HBA PCI-Device group number.
  *
@@ -4850,7 +4850,7 @@ out_free_mem:
  *
  * Return codes
  * 	0 - successful
- * 	-ENOMEM - No availble memory
+ * 	-ENOMEM - No available memory
  *      -EIO - The mailbox failed to complete successfully.
  **/
 int
@@ -5730,7 +5730,7 @@ lpfc_destroy_bootstrap_mbox(struct lpfc_hba *phba)
  *
  * Return codes
  * 	0 - successful
- * 	-ENOMEM - No availble memory
+ * 	-ENOMEM - No available memory
  *      -EIO - The mailbox failed to complete successfully.
  **/
 static int
@@ -5835,7 +5835,7 @@ lpfc_sli4_read_config(struct lpfc_hba *phba)
  *
  * Return codes
  * 	0 - successful
- * 	-ENOMEM - No availble memory
+ * 	-ENOMEM - No available memory
  *      -EIO - The mailbox failed to complete successfully.
  **/
 static int
@@ -5894,7 +5894,7 @@ lpfc_setup_endian_order(struct lpfc_hba *phba)
  *
  * Return codes
  *      0 - successful
- *      -ENOMEM - No availble memory
+ *      -ENOMEM - No available memory
  *      -EIO - The mailbox failed to complete successfully.
  **/
 static int
@@ -6189,7 +6189,7 @@ out_error:
  *
  * Return codes
  *      0 - successful
- *      -ENOMEM - No availble memory
+ *      -ENOMEM - No available memory
  *      -EIO - The mailbox failed to complete successfully.
  **/
 static void
@@ -6253,7 +6253,7 @@ lpfc_sli4_queue_destroy(struct lpfc_hba *phba)
  *
  * Return codes
  *      0 - successful
- *      -ENOMEM - No availble memory
+ *      -ENOMEM - No available memory
  *      -EIO - The mailbox failed to complete successfully.
  **/
 int
@@ -6498,7 +6498,7 @@ out_error:
  *
  * Return codes
  *      0 - successful
- *      -ENOMEM - No availble memory
+ *      -ENOMEM - No available memory
  *      -EIO - The mailbox failed to complete successfully.
  **/
 void
@@ -6543,7 +6543,7 @@ lpfc_sli4_queue_unset(struct lpfc_hba *phba)
  *
  * Return codes
  *      0 - successful
- *      -ENOMEM - No availble memory
+ *      -ENOMEM - No available memory
  **/
 static int
 lpfc_sli4_cq_event_pool_create(struct lpfc_hba *phba)
@@ -6704,7 +6704,7 @@ lpfc_sli4_cq_event_release_all(struct lpfc_hba *phba)
  *
  * Return codes
  *      0 - successful
- *      -ENOMEM - No availble memory
+ *      -ENOMEM - No available memory
  *      -EIO - The mailbox failed to complete successfully.
  **/
 int
diff --git a/drivers/scsi/lpfc/lpfc_mbox.c b/drivers/scsi/lpfc/lpfc_mbox.c
index dba32df..fbab973 100644
--- a/drivers/scsi/lpfc/lpfc_mbox.c
+++ b/drivers/scsi/lpfc/lpfc_mbox.c
@@ -1834,7 +1834,7 @@ lpfc_sli4_mbox_opcode_get(struct lpfc_hba *phba, struct lpfcMboxq *mbox)
  * @fcf_index: index to fcf table.
  *
  * This routine routine allocates and constructs non-embedded mailbox command
- * for reading a FCF table entry refered by @fcf_index.
+ * for reading a FCF table entry referred by @fcf_index.
  *
  * Return: pointer to the mailbox command constructed if successful, otherwise
  * NULL.
diff --git a/drivers/scsi/lpfc/lpfc_nl.h b/drivers/scsi/lpfc/lpfc_nl.h
index f3cfbe2..f2b1bbc 100644
--- a/drivers/scsi/lpfc/lpfc_nl.h
+++ b/drivers/scsi/lpfc/lpfc_nl.h
@@ -50,7 +50,7 @@
  * and subcategory. The event type must come first.
  * The subcategory further defines the data that follows in the rest
  * of the payload. Each category will have its own unique header plus
- * any addtional data unique to the subcategory.
+ * any additional data unique to the subcategory.
  * The payload sent via the fc transport is one-way driver->application.
  */
 
diff --git a/drivers/scsi/lpfc/lpfc_nportdisc.c b/drivers/scsi/lpfc/lpfc_nportdisc.c
index 52b3515..0d92d42 100644
--- a/drivers/scsi/lpfc/lpfc_nportdisc.c
+++ b/drivers/scsi/lpfc/lpfc_nportdisc.c
@@ -658,7 +658,7 @@ lpfc_disc_set_adisc(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp)
 	return 0;
 }
 /**
- * lpfc_release_rpi - Release a RPI by issueing unreg_login mailbox cmd.
+ * lpfc_release_rpi - Release a RPI by issuing unreg_login mailbox cmd.
  * @phba : Pointer to lpfc_hba structure.
  * @vport: Pointer to lpfc_vport structure.
  * @rpi  : rpi to be release.
diff --git a/drivers/scsi/lpfc/lpfc_scsi.c b/drivers/scsi/lpfc/lpfc_scsi.c
index 2b962b0..fe7cc84 100644
--- a/drivers/scsi/lpfc/lpfc_scsi.c
+++ b/drivers/scsi/lpfc/lpfc_scsi.c
@@ -577,7 +577,7 @@ lpfc_new_scsi_buf_s3(struct lpfc_vport *vport, int num_to_alloc)
 			iocb->un.fcpi64.bdl.addrHigh = 0;
 			iocb->ulpBdeCount = 0;
 			iocb->ulpLe = 0;
-			/* fill in responce BDE */
+			/* fill in response BDE */
 			iocb->unsli3.fcp_ext.rbde.tus.f.bdeFlags =
 							BUFF_TYPE_BDE_64;
 			iocb->unsli3.fcp_ext.rbde.tus.f.bdeSize =
@@ -1217,10 +1217,10 @@ lpfc_scsi_prep_dma_buf_s3(struct lpfc_hba *phba, struct lpfc_scsi_buf *lpfc_cmd)
 				     (2 * sizeof(struct ulp_bde64)));
 			data_bde->addrHigh = putPaddrHigh(physaddr);
 			data_bde->addrLow = putPaddrLow(physaddr);
-			/* ebde count includes the responce bde and data bpl */
+			/* ebde count includes the response bde and data bpl */
 			iocb_cmd->unsli3.fcp_ext.ebde_count = 2;
 		} else {
-			/* ebde count includes the responce bde and data bdes */
+			/* ebde count includes the response bde and data bdes */
 			iocb_cmd->unsli3.fcp_ext.ebde_count = (num_bde + 1);
 		}
 	} else {
@@ -2380,7 +2380,7 @@ lpfc_handle_fcp_err(struct lpfc_vport *vport, struct lpfc_scsi_buf *lpfc_cmd,
 		}
 		/*
 		 * The cmnd->underflow is the minimum number of bytes that must
-		 * be transfered for this command.  Provided a sense condition
+		 * be transferred for this command.  Provided a sense condition
 		 * is not present, make sure the actual amount transferred is at
 		 * least the underflow value or fail.
 		 */
@@ -2873,7 +2873,7 @@ lpfc_scsi_prep_task_mgmt_cmd(struct lpfc_vport *vport,
 }
 
 /**
- * lpfc_scsi_api_table_setup - Set up scsi api fucntion jump table
+ * lpfc_scsi_api_table_setup - Set up scsi api function jump table
  * @phba: The hba struct for which this call is being executed.
  * @dev_grp: The HBA PCI-Device group number.
  *
diff --git a/drivers/scsi/lpfc/lpfc_scsi.h b/drivers/scsi/lpfc/lpfc_scsi.h
index 5932273..ce645b2 100644
--- a/drivers/scsi/lpfc/lpfc_scsi.h
+++ b/drivers/scsi/lpfc/lpfc_scsi.h
@@ -130,7 +130,7 @@ struct lpfc_scsi_buf {
 	dma_addr_t nonsg_phys;	/* Non scatter-gather physical address. */
 
 	/*
-	 * data and dma_handle are the kernel virutal and bus address of the
+	 * data and dma_handle are the kernel virtual and bus address of the
 	 * dma-able buffer containing the fcp_cmd, fcp_rsp and a scatter
 	 * gather bde list that supports the sg_tablesize value.
 	 */
diff --git a/drivers/scsi/lpfc/lpfc_sli.c b/drivers/scsi/lpfc/lpfc_sli.c
index 4746dcd..dacabbe 100644
--- a/drivers/scsi/lpfc/lpfc_sli.c
+++ b/drivers/scsi/lpfc/lpfc_sli.c
@@ -2817,7 +2817,7 @@ void lpfc_poll_eratt(unsigned long ptr)
  * This function is called from the interrupt context when there is a ring
  * event for the fcp ring. The caller does not hold any lock.
  * The function processes each response iocb in the response ring until it
- * finds an iocb with LE bit set and chains all the iocbs upto the iocb with
+ * finds an iocb with LE bit set and chains all the iocbs up to the iocb with
  * LE bit set. The function will call the completion handler of the command iocb
  * if the response iocb indicates a completion for a command iocb or it is
  * an abort completion. The function will call lpfc_sli_process_unsol_iocb
@@ -5117,7 +5117,7 @@ lpfc_mbox_timeout_handler(struct lpfc_hba *phba)
 
 	/* Setting state unknown so lpfc_sli_abort_iocb_ring
 	 * would get IOCB_ERROR from lpfc_sli_issue_iocb, allowing
-	 * it to fail all oustanding SCSI IO.
+	 * it to fail all outstanding SCSI IO.
 	 */
 	spin_lock_irq(&phba->pport->work_port_lock);
 	phba->pport->work_port_events &= ~WORKER_MBOX_TMO;
@@ -6031,7 +6031,7 @@ lpfc_sli_issue_mbox(struct lpfc_hba *phba, LPFC_MBOXQ_t *pmbox, uint32_t flag)
 }
 
 /**
- * lpfc_mbox_api_table_setup - Set up mbox api fucntion jump table
+ * lpfc_mbox_api_table_setup - Set up mbox api function jump table
  * @phba: The hba struct for which this call is being executed.
  * @dev_grp: The HBA PCI-Device group number.
  *
@@ -6847,7 +6847,7 @@ __lpfc_sli_issue_iocb(struct lpfc_hba *phba, uint32_t ring_number,
 }
 
 /**
- * lpfc_sli_api_table_setup - Set up sli api fucntion jump table
+ * lpfc_sli_api_table_setup - Set up sli api function jump table
  * @phba: The hba struct for which this call is being executed.
  * @dev_grp: The HBA PCI-Device group number.
  *
@@ -7521,7 +7521,7 @@ lpfc_sli_ring_taggedbuf_get(struct lpfc_hba *phba, struct lpfc_sli_ring *pring,
 	struct lpfc_dmabuf *mp, *next_mp;
 	struct list_head *slp = &pring->postbufq;
 
-	/* Search postbufq, from the begining, looking for a match on tag */
+	/* Search postbufq, from the beginning, looking for a match on tag */
 	spin_lock_irq(&phba->hbalock);
 	list_for_each_entry_safe(mp, next_mp, &pring->postbufq, list) {
 		if (mp->buffer_tag == tag) {
@@ -7565,7 +7565,7 @@ lpfc_sli_ringpostbuf_get(struct lpfc_hba *phba, struct lpfc_sli_ring *pring,
 	struct lpfc_dmabuf *mp, *next_mp;
 	struct list_head *slp = &pring->postbufq;
 
-	/* Search postbufq, from the begining, looking for a match on phys */
+	/* Search postbufq, from the beginning, looking for a match on phys */
 	spin_lock_irq(&phba->hbalock);
 	list_for_each_entry_safe(mp, next_mp, &pring->postbufq, list) {
 		if (mp->phys == phys) {
@@ -8438,7 +8438,7 @@ lpfc_sli_mbox_sys_shutdown(struct lpfc_hba *phba)
  * for possible error attention events. The caller must hold the hostlock
  * with spin_lock_irq().
  *
- * This fucntion returns 1 when there is Error Attention in the Host Attention
+ * This function returns 1 when there is Error Attention in the Host Attention
  * Register and returns 0 otherwise.
  **/
 static int
@@ -8491,7 +8491,7 @@ unplug_err:
  * for possible error attention events. The caller must hold the hostlock
  * with spin_lock_irq().
  *
- * This fucntion returns 1 when there is Error Attention in the Host Attention
+ * This function returns 1 when there is Error Attention in the Host Attention
  * Register and returns 0 otherwise.
  **/
 static int
@@ -8581,7 +8581,7 @@ lpfc_sli4_eratt_read(struct lpfc_hba *phba)
  * This function is called from timer soft interrupt context to check HBA's
  * error attention register bit for error attention events.
  *
- * This fucntion returns 1 when there is Error Attention in the Host Attention
+ * This function returns 1 when there is Error Attention in the Host Attention
  * Register and returns 0 otherwise.
  **/
 int
@@ -9684,7 +9684,7 @@ out:
  * @cq: Pointer to the completion queue.
  * @wcqe: Pointer to a completion queue entry.
  *
- * This routine process a slow-path work-queue or recieve queue completion queue
+ * This routine process a slow-path work-queue or receive queue completion queue
  * entry.
  *
  * Return: true if work posted to worker thread, otherwise false.
@@ -12971,7 +12971,7 @@ lpfc_sli4_build_dflt_fcf_record(struct lpfc_hba *phba,
  * record and processing it one at a time starting from the @fcf_index
  * for initial FCF discovery or fast FCF failover rediscovery.
  *
- * Return 0 if the mailbox command is submitted sucessfully, none 0
+ * Return 0 if the mailbox command is submitted successfully, none 0
  * otherwise.
  **/
 int
@@ -13032,7 +13032,7 @@ fail_fcf_scan:
  * This routine is invoked to read an FCF record indicated by @fcf_index
  * and to use it for FLOGI roundrobin FCF failover.
  *
- * Return 0 if the mailbox command is submitted sucessfully, none 0
+ * Return 0 if the mailbox command is submitted successfully, none 0
  * otherwise.
  **/
 int
@@ -13078,7 +13078,7 @@ fail_fcf_read:
  * This routine is invoked to read an FCF record indicated by @fcf_index to
  * determine whether it's eligible for FLOGI roundrobin failover list.
  *
- * Return 0 if the mailbox command is submitted sucessfully, none 0
+ * Return 0 if the mailbox command is submitted successfully, none 0
  * otherwise.
  **/
 int
diff --git a/drivers/scsi/megaraid.c b/drivers/scsi/megaraid.c
index c212694..f2684dd 100644
--- a/drivers/scsi/megaraid.c
+++ b/drivers/scsi/megaraid.c
@@ -284,7 +284,7 @@ mega_query_adapter(adapter_t *adapter)
 
 	adapter->host->max_id = 16;	/* max targets per channel */
 
-	adapter->host->max_lun = 7;	/* Upto 7 luns for non disk devices */
+	adapter->host->max_lun = 7;	/* Up to 7 luns for non disk devices */
 
 	adapter->host->cmd_per_lun = max_cmd_per_lun;
 
@@ -3734,7 +3734,7 @@ mega_m_to_n(void __user *arg, nitioctl_t *uioc)
 	 * check is the application conforms to NIT. We do not have to do much
 	 * in that case.
 	 * We exploit the fact that the signature is stored in the very
-	 * begining of the structure.
+	 * beginning of the structure.
 	 */
 
 	if( copy_from_user(signature, arg, 7) )
diff --git a/drivers/scsi/megaraid.h b/drivers/scsi/megaraid.h
index 8534119..9a7897f 100644
--- a/drivers/scsi/megaraid.h
+++ b/drivers/scsi/megaraid.h
@@ -532,9 +532,9 @@ struct uioctl_t {
 
 /*
  * struct mcontroller is used to pass information about the controllers in the
- * system. Its upto the application how to use the information. We are passing
+ * system. Its up to the application how to use the information. We are passing
  * as much info about the cards as possible and useful. Before issuing the
- * call to find information about the cards, the applicaiton needs to issue a
+ * call to find information about the cards, the application needs to issue a
  * ioctl first to find out the number of controllers in the system.
  */
 #define MAX_CONTROLLERS 32
@@ -804,7 +804,7 @@ typedef struct {
 	unsigned long		base;
 	void __iomem		*mmio_base;
 
-	/* mbox64 with mbox not aligned on 16-byte boundry */
+	/* mbox64 with mbox not aligned on 16-byte boundary */
 	mbox64_t	*una_mbox64;
 	dma_addr_t	una_mbox64_dma;
 
diff --git a/drivers/scsi/megaraid/mbox_defs.h b/drivers/scsi/megaraid/mbox_defs.h
index ce2487a..e01c6f7 100644
--- a/drivers/scsi/megaraid/mbox_defs.h
+++ b/drivers/scsi/megaraid/mbox_defs.h
@@ -660,7 +660,7 @@ typedef struct {
  * @lparam	: logical drives parameters
  * @span	: span
  *
- * 8-LD logical drive with upto 8 spans
+ * 8-LD logical drive with up to 8 spans
  */
 typedef struct {
 	logdrv_param_t	lparam;
@@ -673,7 +673,7 @@ typedef struct {
  * @lparam	: logical drives parameters
  * @span	: span
  *
- * 8-LD logical drive with upto 4 spans
+ * 8-LD logical drive with up to 4 spans
  */
 typedef struct {
 	logdrv_param_t	lparam;
@@ -720,7 +720,7 @@ typedef struct {
  * @ldrv	: logical drives information
  * @pdrv	: physical drives information
  *
- * Disk array for 8LD logical drives with upto 8 spans
+ * Disk array for 8LD logical drives with up to 8 spans
  */
 typedef struct {
 	uint8_t			numldrv;
@@ -737,7 +737,7 @@ typedef struct {
  * @ldrv	: logical drives information
  * @pdrv	: physical drives information
  *
- * Disk array for 8LD logical drives with upto 4 spans
+ * Disk array for 8LD logical drives with up to 4 spans
  */
 typedef struct {
 	uint8_t			numldrv;
diff --git a/drivers/scsi/megaraid/megaraid_mbox.c b/drivers/scsi/megaraid/megaraid_mbox.c
index 5708cb2..1dba328 100644
--- a/drivers/scsi/megaraid/megaraid_mbox.c
+++ b/drivers/scsi/megaraid/megaraid_mbox.c
@@ -2689,7 +2689,7 @@ megaraid_reset_handler(struct scsi_cmnd *scp)
 				(MBOX_RESET_WAIT + MBOX_RESET_EXT_WAIT) - i));
 		}
 
-		// bailout if no recovery happended in reset time
+		// bailout if no recovery happened in reset time
 		if (adapter->outstanding_cmds == 0) {
 			break;
 		}
@@ -3452,7 +3452,7 @@ megaraid_mbox_display_scb(adapter_t *adapter, scb_t *scb)
  * megaraid_mbox_setup_device_map - manage device ids
  * @adapter	: Driver's soft state
  *
- * Manange the device ids to have an appropraite mapping between the kernel
+ * Manange the device ids to have an appropriate mapping between the kernel
  * scsi addresses and megaraid scsi and logical drive addresses. We export
  * scsi devices on their actual addresses, whereas the logical drives are
  * exported on a virtual scsi channel.
@@ -3973,7 +3973,7 @@ megaraid_sysfs_get_ldmap_timeout(unsigned long data)
  * NOTE: The commands issuance functionality is not generalized and
  * implemented in context of "get ld map" command only. If required, the
  * command issuance logical can be trivially pulled out and implemented as a
- * standalone libary. For now, this should suffice since there is no other
+ * standalone library. For now, this should suffice since there is no other
  * user of this interface.
  *
  * Return 0 on success.
diff --git a/drivers/scsi/megaraid/megaraid_sas.h b/drivers/scsi/megaraid/megaraid_sas.h
index 635b228..046dcc6 100644
--- a/drivers/scsi/megaraid/megaraid_sas.h
+++ b/drivers/scsi/megaraid/megaraid_sas.h
@@ -1347,7 +1347,7 @@ struct megasas_instance {
 	struct timer_list io_completion_timer;
 	struct list_head internal_reset_pending_q;
 
-	/* Ptr to hba specfic information */
+	/* Ptr to hba specific information */
 	void *ctrl_context;
 	u8	msi_flag;
 	struct msix_entry msixentry;
diff --git a/drivers/scsi/megaraid/megaraid_sas_base.c b/drivers/scsi/megaraid/megaraid_sas_base.c
index bbd10c8..66d4cea 100644
--- a/drivers/scsi/megaraid/megaraid_sas_base.c
+++ b/drivers/scsi/megaraid/megaraid_sas_base.c
@@ -1698,7 +1698,7 @@ void megasas_do_ocr(struct megasas_instance *instance)
  * megasas_wait_for_outstanding -	Wait for all outstanding cmds
  * @instance:				Adapter soft state
  *
- * This function waits for upto MEGASAS_RESET_WAIT_TIME seconds for FW to
+ * This function waits for up to MEGASAS_RESET_WAIT_TIME seconds for FW to
  * complete all its outstanding commands. Returns error if one or more IOs
  * are pending after this time period. It also marks the controller dead.
  */
diff --git a/drivers/scsi/mpt2sas/mpi/mpi2_init.h b/drivers/scsi/mpt2sas/mpi/mpi2_init.h
index 20e6b88..165454d 100644
--- a/drivers/scsi/mpt2sas/mpi/mpi2_init.h
+++ b/drivers/scsi/mpt2sas/mpi/mpi2_init.h
@@ -21,7 +21,7 @@
  *  05-21-08  02.00.05  Fixed typo in name of Mpi2SepRequest_t.
  *  10-02-08  02.00.06  Removed Untagged and No Disconnect values from SCSI IO
  *                      Control field Task Attribute flags.
- *                      Moved LUN field defines to mpi2.h becasue they are
+ *                      Moved LUN field defines to mpi2.h because they are
  *                      common to many structures.
  *  05-06-09  02.00.07  Changed task management type of Query Unit Attention to
  *                      Query Asynchronous Event.
diff --git a/drivers/scsi/mpt2sas/mpt2sas_base.c b/drivers/scsi/mpt2sas/mpt2sas_base.c
index 5e001ff..3346357 100644
--- a/drivers/scsi/mpt2sas/mpt2sas_base.c
+++ b/drivers/scsi/mpt2sas/mpt2sas_base.c
@@ -925,7 +925,7 @@ _base_interrupt(int irq, void *bus_id)
 }
 
 /**
- * mpt2sas_base_release_callback_handler - clear interupt callback handler
+ * mpt2sas_base_release_callback_handler - clear interrupt callback handler
  * @cb_idx: callback index
  *
  * Return nothing.
@@ -1113,7 +1113,7 @@ _base_restore_msix_table(struct MPT2SAS_ADAPTER *ioc)
  * @ioc: per adapter object
  *
  * Check to see if card is capable of MSIX, and set number
- * of avaliable msix vectors
+ * of available msix vectors
  */
 static int
 _base_check_enable_msix(struct MPT2SAS_ADAPTER *ioc)
@@ -1595,7 +1595,7 @@ mpt2sas_base_put_smid_scsi_io(struct MPT2SAS_ADAPTER *ioc, u16 smid, u16 handle)
 
 
 /**
- * mpt2sas_base_put_smid_hi_priority - send Task Managment request to firmware
+ * mpt2sas_base_put_smid_hi_priority - send Task Management request to firmware
  * @ioc: per adapter object
  * @smid: system request message index
  *
@@ -2599,7 +2599,7 @@ _base_wait_for_doorbell_int(struct MPT2SAS_ADAPTER *ioc, int timeout,
 		int_status = readl(&ioc->chip->HostInterruptStatus);
 		if (int_status & MPI2_HIS_IOC2SYS_DB_STATUS) {
 			dhsprintk(ioc, printk(MPT2SAS_INFO_FMT "%s: "
-			    "successfull count(%d), timeout(%d)\n", ioc->name,
+			    "successful count(%d), timeout(%d)\n", ioc->name,
 			    __func__, count, timeout));
 			return 0;
 		}
@@ -2640,7 +2640,7 @@ _base_wait_for_doorbell_ack(struct MPT2SAS_ADAPTER *ioc, int timeout,
 		int_status = readl(&ioc->chip->HostInterruptStatus);
 		if (!(int_status & MPI2_HIS_SYS2IOC_DB_STATUS)) {
 			dhsprintk(ioc, printk(MPT2SAS_INFO_FMT "%s: "
-			    "successfull count(%d), timeout(%d)\n", ioc->name,
+			    "successful count(%d), timeout(%d)\n", ioc->name,
 			    __func__, count, timeout));
 			return 0;
 		} else if (int_status & MPI2_HIS_IOC2SYS_DB_STATUS) {
@@ -2688,7 +2688,7 @@ _base_wait_for_doorbell_not_used(struct MPT2SAS_ADAPTER *ioc, int timeout,
 		doorbell_reg = readl(&ioc->chip->Doorbell);
 		if (!(doorbell_reg & MPI2_DOORBELL_USED)) {
 			dhsprintk(ioc, printk(MPT2SAS_INFO_FMT "%s: "
-			    "successfull count(%d), timeout(%d)\n", ioc->name,
+			    "successful count(%d), timeout(%d)\n", ioc->name,
 			    __func__, count, timeout));
 			return 0;
 		}
diff --git a/drivers/scsi/mpt2sas/mpt2sas_config.c b/drivers/scsi/mpt2sas/mpt2sas_config.c
index 6afd67b..6861244 100644
--- a/drivers/scsi/mpt2sas/mpt2sas_config.c
+++ b/drivers/scsi/mpt2sas/mpt2sas_config.c
@@ -93,7 +93,7 @@ struct config_request{
  * @mpi_reply: reply message frame
  * Context: none.
  *
- * Function for displaying debug info helpfull when debugging issues
+ * Function for displaying debug info helpful when debugging issues
  * in this module.
  */
 static void
diff --git a/drivers/scsi/mpt2sas/mpt2sas_ctl.c b/drivers/scsi/mpt2sas/mpt2sas_ctl.c
index e92b77a..1c6d2b4 100644
--- a/drivers/scsi/mpt2sas/mpt2sas_ctl.c
+++ b/drivers/scsi/mpt2sas/mpt2sas_ctl.c
@@ -116,7 +116,7 @@ _ctl_sas_device_find_by_handle(struct MPT2SAS_ADAPTER *ioc, u16 handle)
  * @mpi_reply: reply message frame
  * Context: none.
  *
- * Function for displaying debug info helpfull when debugging issues
+ * Function for displaying debug info helpful when debugging issues
  * in this module.
  */
 static void
diff --git a/drivers/scsi/mpt2sas/mpt2sas_scsih.c b/drivers/scsi/mpt2sas/mpt2sas_scsih.c
index 6ceb775..d2064a0 100644
--- a/drivers/scsi/mpt2sas/mpt2sas_scsih.c
+++ b/drivers/scsi/mpt2sas/mpt2sas_scsih.c
@@ -397,7 +397,7 @@ _scsih_get_sas_address(struct MPT2SAS_ADAPTER *ioc, u16 handle,
  * @is_raid: [flag] 1 = raid object, 0 = sas object
  *
  * Determines whether this device should be first reported device to
- * to scsi-ml or sas transport, this purpose is for persistant boot device.
+ * to scsi-ml or sas transport, this purpose is for persistent boot device.
  * There are primary, alternate, and current entries in bios page 2. The order
  * priority is primary, alternate, then current.  This routine saves
  * the corresponding device object and is_raid flag in the ioc object.
@@ -2671,10 +2671,10 @@ _scsih_block_io_to_children_attached_directly(struct MPT2SAS_ADAPTER *ioc,
  * @handle: device handle
  * Context: interrupt time.
  *
- * This code is to initiate the device removal handshake protocal
+ * This code is to initiate the device removal handshake protocol
  * with controller firmware.  This function will issue target reset
  * using high priority request queue.  It will send a sas iounit
- * controll request (MPI2_SAS_OP_REMOVE_DEVICE) from this completion.
+ * control request (MPI2_SAS_OP_REMOVE_DEVICE) from this completion.
  *
  * This is designed to send muliple task management request at the same
  * time to the fifo. If the fifo is full, we will append the request,
@@ -2749,9 +2749,9 @@ _scsih_tm_tr_send(struct MPT2SAS_ADAPTER *ioc, u16 handle)
  * @reply: reply message frame(lower 32bit addr)
  * Context: interrupt time.
  *
- * This is the sas iounit controll completion routine.
+ * This is the sas iounit control completion routine.
  * This code is part of the code to initiate the device removal
- * handshake protocal with controller firmware.
+ * handshake protocol with controller firmware.
  *
  * Return 1 meaning mf should be freed from _base_interrupt
  *        0 means the mf is freed from this function.
@@ -2878,8 +2878,8 @@ _scsih_tm_volume_tr_complete(struct MPT2SAS_ADAPTER *ioc, u16 smid,
  *
  * This is the target reset completion routine.
  * This code is part of the code to initiate the device removal
- * handshake protocal with controller firmware.
- * It will send a sas iounit controll request (MPI2_SAS_OP_REMOVE_DEVICE)
+ * handshake protocol with controller firmware.
+ * It will send a sas iounit control request (MPI2_SAS_OP_REMOVE_DEVICE)
  *
  * Return 1 meaning mf should be freed from _base_interrupt
  *        0 means the mf is freed from this function.
@@ -2984,7 +2984,7 @@ _scsih_check_for_pending_tm(struct MPT2SAS_ADAPTER *ioc, u16 smid)
  *
  * This routine added to better handle cable breaker.
  *
- * This handles the case where driver recieves multiple expander
+ * This handles the case where driver receives multiple expander
  * add and delete events in a single shot.  When there is a delete event
  * the routine will void any pending add events waiting in the event queue.
  *
@@ -3511,7 +3511,7 @@ _scsih_normalize_sense(char *sense_buffer, struct sense_info *data)
 
 #ifdef CONFIG_SCSI_MPT2SAS_LOGGING
 /**
- * _scsih_scsi_ioc_info - translated non-successfull SCSI_IO request
+ * _scsih_scsi_ioc_info - translated non-successful SCSI_IO request
  * @ioc: per adapter object
  * @scmd: pointer to scsi command object
  * @mpi_reply: reply mf payload returned from firmware
@@ -5138,7 +5138,7 @@ _scsih_sas_broadcast_primative_event(struct MPT2SAS_ADAPTER *ioc,
 	unsigned long flags;
 	int r;
 
-	dewtprintk(ioc, printk(MPT2SAS_INFO_FMT "broadcast primative: "
+	dewtprintk(ioc, printk(MPT2SAS_INFO_FMT "broadcast primitive: "
 	    "phy number(%d), width(%d)\n", ioc->name, event_data->PhyNum,
 	    event_data->PortWidth));
 	dtmprintk(ioc, printk(MPT2SAS_INFO_FMT "%s: enter\n", ioc->name,
diff --git a/drivers/scsi/ncr53c8xx.c b/drivers/scsi/ncr53c8xx.c
index 46cc382..835d8d6 100644
--- a/drivers/scsi/ncr53c8xx.c
+++ b/drivers/scsi/ncr53c8xx.c
@@ -2679,7 +2679,7 @@ static	struct script script0 __initdata = {
 }/*-------------------------< RESEL_TAG >-------------------*/,{
 	/*
 	**	Read IDENTIFY + SIMPLE + TAG using a single MOVE.
-	**	Agressive optimization, is'nt it?
+	**	Aggressive optimization, is'nt it?
 	**	No need to test the SIMPLE TAG message, since the 
 	**	driver only supports conformant devices for tags. ;-)
 	*/
diff --git a/drivers/scsi/nsp32.c b/drivers/scsi/nsp32.c
index 6b8b021..f6a50c9 100644
--- a/drivers/scsi/nsp32.c
+++ b/drivers/scsi/nsp32.c
@@ -1288,7 +1288,7 @@ static irqreturn_t do_nsp32_isr(int irq, void *dev_id)
 			nsp32_dbg(NSP32_DEBUG_INTR, "SSACK=0x%lx", 
 				    nsp32_read4(base, SAVED_SACK_CNT));
 
-			scsi_set_resid(SCpnt, 0); /* all data transfered! */
+			scsi_set_resid(SCpnt, 0); /* all data transferred! */
 		}
 
 		/*
@@ -1630,7 +1630,7 @@ static int nsp32_busfree_occur(struct scsi_cmnd *SCpnt, unsigned short execph)
 
 			/*
 			 * If SAVEDSACKCNT == 0, it means SavedDataPointer is
-			 * come after data transfering.
+			 * come after data transferring.
 			 */
 			if (s_sacklen > 0) {
 				/*
@@ -1785,7 +1785,7 @@ static void nsp32_adjust_busfree(struct scsi_cmnd *SCpnt, unsigned int s_sacklen
 		   the head element of the sg. restlen is correctly calculated. */
 	}
 
-	/* calculate the rest length for transfering */
+	/* calculate the rest length for transferring */
 	restlen = sentlen - s_sacklen;
 
 	/* update adjusting current SG table entry */
diff --git a/drivers/scsi/nsp32.h b/drivers/scsi/nsp32.h
index 9565acf..c022182 100644
--- a/drivers/scsi/nsp32.h
+++ b/drivers/scsi/nsp32.h
@@ -507,7 +507,7 @@ typedef struct _nsp32_lunt {
 /*
  * SCSI TARGET/LUN definition
  */
-#define NSP32_HOST_SCSIID    7  /* SCSI initiator is everytime defined as 7 */
+#define NSP32_HOST_SCSIID    7  /* SCSI initiator is every time defined as 7 */
 #define MAX_TARGET	     8
 #define MAX_LUN		     8	/* XXX: In SPI3, max number of LUN is 64. */
 
diff --git a/drivers/scsi/osst.c b/drivers/scsi/osst.c
index 521e218..58f5be4 100644
--- a/drivers/scsi/osst.c
+++ b/drivers/scsi/osst.c
@@ -1366,7 +1366,7 @@ error:
 /* The values below are based on the OnStream frame payload size of 32K == 2**15,
  * that is, OSST_FRAME_SHIFT + OSST_SECTOR_SHIFT must be 15. With a minimum block
  * size of 512 bytes, we need to be able to resolve 32K/512 == 64 == 2**6 positions
- * inside each frame. Finaly, OSST_SECTOR_MASK == 2**OSST_FRAME_SHIFT - 1.
+ * inside each frame. Finally, OSST_SECTOR_MASK == 2**OSST_FRAME_SHIFT - 1.
  */
 #define OSST_FRAME_SHIFT  6
 #define OSST_SECTOR_SHIFT 9
@@ -3131,7 +3131,7 @@ static int osst_flush_write_buffer(struct osst_tape *STp, struct osst_request **
 		}
 #if DEBUG
 		if (debugging)
-			printk(OSST_DEB_MSG "%s:D: Flushing %d bytes, Transfering %d bytes in %d lblocks.\n",
+			printk(OSST_DEB_MSG "%s:D: Flushing %d bytes, Transferring %d bytes in %d lblocks.\n",
 			  			 name, offset, transfer, blks);
 #endif
 
@@ -3811,7 +3811,7 @@ static ssize_t osst_read(struct file * filp, char __user * buf, size_t count, lo
 
 			if (transfer == 0) {
 				printk(KERN_WARNING
-				  "%s:W: Nothing can be transfered, requested %Zd, tape block size (%d%c).\n",
+				  "%s:W: Nothing can be transferred, requested %Zd, tape block size (%d%c).\n",
 			   		name, count, STp->block_size < 1024?
 					STp->block_size:STp->block_size/1024,
 				       	STp->block_size<1024?'b':'k');
diff --git a/drivers/scsi/osst.h b/drivers/scsi/osst.h
index 11d26c5..b4fea98 100644
--- a/drivers/scsi/osst.h
+++ b/drivers/scsi/osst.h
@@ -413,7 +413,7 @@ typedef struct os_dat_s {
  * AUX
  */
 typedef struct os_aux_s {
-        __be32          format_id;              /* hardware compability AUX is based on */
+        __be32          format_id;              /* hardware compatibility AUX is based on */
         char            application_sig[4];     /* driver used to write this media */
         __be32          hdwr;                   /* reserved */
         __be32          update_frame_cntr;      /* for configuration frame */
diff --git a/drivers/scsi/pcmcia/nsp_cs.c b/drivers/scsi/pcmcia/nsp_cs.c
index be3f33d..54bdf6d 100644
--- a/drivers/scsi/pcmcia/nsp_cs.c
+++ b/drivers/scsi/pcmcia/nsp_cs.c
@@ -742,7 +742,7 @@ static void nsp_pio_read(struct scsi_cmnd *SCpnt)
 
 		res = nsp_fifo_count(SCpnt) - ocount;
 		//nsp_dbg(NSP_DEBUG_DATA_IO, "ptr=0x%p this=0x%x ocount=0x%x res=0x%x", SCpnt->SCp.ptr, SCpnt->SCp.this_residual, ocount, res);
-		if (res == 0) { /* if some data avilable ? */
+		if (res == 0) { /* if some data available ? */
 			if (stat == BUSPHASE_DATA_IN) { /* phase changed? */
 				//nsp_dbg(NSP_DEBUG_DATA_IO, " wait for data this=%d", SCpnt->SCp.this_residual);
 				continue;
diff --git a/drivers/scsi/pm8001/pm8001_hwi.c b/drivers/scsi/pm8001/pm8001_hwi.c
index 18b6c55..8b7db1e 100644
--- a/drivers/scsi/pm8001/pm8001_hwi.c
+++ b/drivers/scsi/pm8001/pm8001_hwi.c
@@ -339,7 +339,7 @@ update_outbnd_queue_table(struct pm8001_hba_info *pm8001_ha, int number)
 
 /**
  * bar4_shift - function is called to shift BAR base address
- * @pm8001_ha : our hba card infomation
+ * @pm8001_ha : our hba card information
  * @shiftValue : shifting value in memory bar.
  */
 static int bar4_shift(struct pm8001_hba_info *pm8001_ha, u32 shiftValue)
diff --git a/drivers/scsi/pm8001/pm8001_hwi.h b/drivers/scsi/pm8001/pm8001_hwi.h
index 833a520..9091320 100644
--- a/drivers/scsi/pm8001/pm8001_hwi.h
+++ b/drivers/scsi/pm8001/pm8001_hwi.h
@@ -209,7 +209,7 @@ struct  pio_setup_fis {
 
 /*
  * brief the data structure of SATA Completion Response
- * use to discribe the sata task response (64 bytes)
+ * use to describe the sata task response (64 bytes)
  */
 struct sata_completion_resp {
 	__le32	tag;
@@ -951,7 +951,7 @@ struct set_dev_state_resp {
 #define PCIE_EVENT_INTERRUPT		0x003044
 #define PCIE_ERROR_INTERRUPT_ENABLE	0x003048
 #define PCIE_ERROR_INTERRUPT		0x00304C
-/* signature defintion for host scratch pad0 register */
+/* signature definition for host scratch pad0 register */
 #define SPC_SOFT_RESET_SIGNATURE	0x252acbcd
 /* Signature for Soft Reset */
 
diff --git a/drivers/scsi/pm8001/pm8001_sas.h b/drivers/scsi/pm8001/pm8001_sas.h
index bdb6b27..aa05e66 100644
--- a/drivers/scsi/pm8001/pm8001_sas.h
+++ b/drivers/scsi/pm8001/pm8001_sas.h
@@ -445,7 +445,7 @@ struct fw_control_info {
 struct fw_control_ex {
 	struct fw_control_info *fw_control;
 	void			*buffer;/* keep buffer pointer to be
-	freed when the responce comes*/
+	freed when the response comes*/
 	void			*virtAddr;/* keep virtual address of the data */
 	void			*usrAddr;/* keep virtual address of the
 	user data */
diff --git a/drivers/scsi/pmcraid.c b/drivers/scsi/pmcraid.c
index bcf858e..96d5ad0 100644
--- a/drivers/scsi/pmcraid.c
+++ b/drivers/scsi/pmcraid.c
@@ -213,7 +213,7 @@ static int pmcraid_slave_alloc(struct scsi_device *scsi_dev)
  * pmcraid_slave_configure - Configures a SCSI device
  * @scsi_dev: scsi device struct
  *
- * This fucntion is executed by SCSI mid layer just after a device is first
+ * This function is executed by SCSI mid layer just after a device is first
  * scanned (i.e. it has responded to an INQUIRY). For VSET resources, the
  * timeout value (default 30s) will be over-written to a higher value (60s)
  * and max_sectors value will be over-written to 512. It also sets queue depth
@@ -2122,7 +2122,7 @@ static void pmcraid_fail_outstanding_cmds(struct pmcraid_instance *pinstance)
  *
  * This function executes most of the steps required for IOA reset. This gets
  * called by user threads (modprobe/insmod/rmmod) timer, tasklet and midlayer's
- * 'eh_' thread. Access to variables used for controling the reset sequence is
+ * 'eh_' thread. Access to variables used for controlling the reset sequence is
  * synchronized using host lock. Various functions called during reset process
  * would make use of a single command block, pointer to which is also stored in
  * adapter instance structure.
@@ -2994,7 +2994,7 @@ static int pmcraid_abort_complete(struct pmcraid_cmd *cancel_cmd)
 
 	/* If the abort task is not timed out we will get a Good completion
 	 * as sense_key, otherwise we may get one the following responses
-	 * due to subsquent bus reset or device reset. In case IOASC is
+	 * due to subsequent bus reset or device reset. In case IOASC is
 	 * NR_SYNC_REQUIRED, set sync_reqd flag for the corresponding resource
 	 */
 	if (ioasc == PMCRAID_IOASC_UA_BUS_WAS_RESET ||
@@ -3933,7 +3933,7 @@ static long pmcraid_ioctl_passthrough(
 
 			/* if abort task couldn't find the command i.e it got
 			 * completed prior to aborting, return good completion.
-			 * if command got aborted succesfully or there was IOA
+			 * if command got aborted successfully or there was IOA
 			 * reset due to abort task itself getting timedout then
 			 * return -ETIMEDOUT
 			 */
@@ -5932,7 +5932,7 @@ static int __devinit pmcraid_probe(
 	 * However, firmware supports 64-bit streaming DMA buffers, whereas
 	 * coherent buffers are to be 32-bit. Since pci_alloc_consistent always
 	 * returns memory within 4GB (if not, change this logic), coherent
-	 * buffers are within firmware acceptible address ranges.
+	 * buffers are within firmware acceptable address ranges.
 	 */
 	if ((sizeof(dma_addr_t) == 4) ||
 	    pci_set_dma_mask(pdev, DMA_BIT_MASK(64)))
diff --git a/drivers/scsi/pmcraid.h b/drivers/scsi/pmcraid.h
index 4db210d..34e4c91 100644
--- a/drivers/scsi/pmcraid.h
+++ b/drivers/scsi/pmcraid.h
@@ -1024,7 +1024,7 @@ static struct pmcraid_ioasc_error pmcraid_ioasc_error_table[] = {
 
 
 /*
- * pmcraid_ioctl_header - definition of header structure that preceeds all the
+ * pmcraid_ioctl_header - definition of header structure that precedes all the
  * buffers given as ioctl arguments.
  *
  * .signature           : always ASCII string, "PMCRAID"
diff --git a/drivers/scsi/qla1280.c b/drivers/scsi/qla1280.c
index 5dec684..8ba5744 100644
--- a/drivers/scsi/qla1280.c
+++ b/drivers/scsi/qla1280.c
@@ -78,7 +78,7 @@
 	- Clean up vchan handling
     Rev  3.23.33 July 3, 2003, Jes Sorensen
 	- Don't define register access macros before define determining MMIO.
-	  This just happend to work out on ia64 but not elsewhere.
+	  This just happened to work out on ia64 but not elsewhere.
 	- Don't try and read from the card while it is in reset as
 	  it won't respond and causes an MCA
     Rev  3.23.32 June 23, 2003, Jes Sorensen
diff --git a/drivers/scsi/qla2xxx/qla_def.h b/drivers/scsi/qla2xxx/qla_def.h
index 6c51c0a..ee20353 100644
--- a/drivers/scsi/qla2xxx/qla_def.h
+++ b/drivers/scsi/qla2xxx/qla_def.h
@@ -2086,7 +2086,7 @@ struct ct_sns_pkt {
 };
 
 /*
- * SNS command structures -- for 2200 compatability.
+ * SNS command structures -- for 2200 compatibility.
  */
 #define	RFT_ID_SNS_SCMD_LEN	22
 #define	RFT_ID_SNS_CMD_SIZE	60
diff --git a/drivers/scsi/qla2xxx/qla_fw.h b/drivers/scsi/qla2xxx/qla_fw.h
index 631fefc..f5ba09c 100644
--- a/drivers/scsi/qla2xxx/qla_fw.h
+++ b/drivers/scsi/qla2xxx/qla_fw.h
@@ -539,7 +539,7 @@ struct sts_entry_24xx {
 	 * If DIF Error is set in comp_status, these additional fields are
 	 * defined:
 	 * &data[10] : uint8_t report_runt_bg[2];	- computed guard
-	 * &data[12] : uint8_t actual_dif[8];		- DIF Data recieved
+	 * &data[12] : uint8_t actual_dif[8];		- DIF Data received
 	 * &data[20] : uint8_t expected_dif[8];		- DIF Data computed
 	*/
 };
diff --git a/drivers/scsi/qla2xxx/qla_isr.c b/drivers/scsi/qla2xxx/qla_isr.c
index d17ed9a..712518d 100644
--- a/drivers/scsi/qla2xxx/qla_isr.c
+++ b/drivers/scsi/qla2xxx/qla_isr.c
@@ -414,7 +414,7 @@ skip_rio:
 				    "marked OFFLINE!\n");
 				vha->flags.online = 0;
 			} else {
-				/* Check to see if MPI timeout occured */
+				/* Check to see if MPI timeout occurred */
 				if ((mbx & MBX_3) && (ha->flags.port0))
 					set_bit(MPI_RESET_NEEDED,
 					    &vha->dpc_flags);
diff --git a/drivers/scsi/qla2xxx/qla_mbx.c b/drivers/scsi/qla2xxx/qla_mbx.c
index 7a7c0ec..3489339 100644
--- a/drivers/scsi/qla2xxx/qla_mbx.c
+++ b/drivers/scsi/qla2xxx/qla_mbx.c
@@ -303,7 +303,7 @@ qla2x00_mailbox_command(scsi_qla_host_t *vha, mbx_cmd_t *mcp)
 			    !test_bit(ISP_ABORT_RETRY, &vha->dpc_flags)) {
 
 				qla_printk(KERN_WARNING, ha,
-				    "Mailbox command timeout occured. "
+				    "Mailbox command timeout occurred. "
 				    "Scheduling ISP " "abort. eeh_busy: 0x%x\n",
 				    ha->flags.eeh_busy);
 				set_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);
@@ -321,7 +321,7 @@ qla2x00_mailbox_command(scsi_qla_host_t *vha, mbx_cmd_t *mcp)
 			    !test_bit(ISP_ABORT_RETRY, &vha->dpc_flags)) {
 
 				qla_printk(KERN_WARNING, ha,
-				    "Mailbox command timeout occured. "
+				    "Mailbox command timeout occurred. "
 				    "Issuing ISP abort.\n");
 
 				set_bit(ABORT_ISP_ACTIVE, &vha->dpc_flags);
@@ -3789,7 +3789,7 @@ qla2x00_loopback_test(scsi_qla_host_t *vha, struct msg_echo_lb *mreq,
 	mcp->mb[20] = LSW(MSD(mreq->send_dma));
 	mcp->mb[21] = MSW(MSD(mreq->send_dma));
 
-	/* recieve data address */
+	/* receive data address */
 	mcp->mb[16] = LSW(mreq->rcv_dma);
 	mcp->mb[17] = MSW(mreq->rcv_dma);
 	mcp->mb[6] = LSW(MSD(mreq->rcv_dma));
diff --git a/drivers/scsi/qla2xxx/qla_nx.c b/drivers/scsi/qla2xxx/qla_nx.c
index 76ec876..455fe13 100644
--- a/drivers/scsi/qla2xxx/qla_nx.c
+++ b/drivers/scsi/qla2xxx/qla_nx.c
@@ -2598,7 +2598,7 @@ qla82xx_calc_dsd_lists(uint16_t dsds)
  * qla82xx_start_scsi() - Send a SCSI command to the ISP
  * @sp: command to send to the ISP
  *
- * Returns non-zero if a failure occured, else zero.
+ * Returns non-zero if a failure occurred, else zero.
  */
 int
 qla82xx_start_scsi(srb_t *sp)
diff --git a/drivers/scsi/qla2xxx/qla_os.c b/drivers/scsi/qla2xxx/qla_os.c
index 75a966c..aa77475 100644
--- a/drivers/scsi/qla2xxx/qla_os.c
+++ b/drivers/scsi/qla2xxx/qla_os.c
@@ -1046,7 +1046,7 @@ qla2xxx_eh_bus_reset(struct scsi_cmnd *cmd)
 
 eh_bus_reset_done:
 	qla_printk(KERN_INFO, vha->hw, "%s: reset %s\n", __func__,
-	    (ret == FAILED) ? "failed" : "succeded");
+	    (ret == FAILED) ? "failed" : "succeeded");
 
 	return ret;
 }
@@ -1136,7 +1136,7 @@ qla2xxx_eh_host_reset(struct scsi_cmnd *cmd)
 
 eh_host_reset_lock:
 	qla_printk(KERN_INFO, ha, "%s: reset %s\n", __func__,
-	    (ret == FAILED) ? "failed" : "succeded");
+	    (ret == FAILED) ? "failed" : "succeeded");
 
 	return ret;
 }
@@ -3902,7 +3902,7 @@ uint32_t qla82xx_error_recovery(scsi_qla_host_t *base_vha)
 			continue;
 		if (atomic_read(&other_pdev->enable_cnt)) {
 			DEBUG17(qla_printk(KERN_INFO, ha,
-			    "Found PCI func availabe and enabled at 0x%x\n",
+			    "Found PCI func available and enabled at 0x%x\n",
 			    fn));
 			pci_dev_put(other_pdev);
 			break;
diff --git a/drivers/scsi/qla4xxx/ql4_def.h b/drivers/scsi/qla4xxx/ql4_def.h
index c1f8d1b..4757878 100644
--- a/drivers/scsi/qla4xxx/ql4_def.h
+++ b/drivers/scsi/qla4xxx/ql4_def.h
@@ -182,7 +182,7 @@ struct srb {
 	uint16_t flags;		/* (1) Status flags. */
 
 #define SRB_DMA_VALID		BIT_3	/* DMA Buffer mapped. */
-#define SRB_GOT_SENSE		BIT_4	/* sense data recieved. */
+#define SRB_GOT_SENSE		BIT_4	/* sense data received. */
 	uint8_t state;		/* (1) Status flags. */
 
 #define SRB_NO_QUEUE_STATE	 0	/* Request is in between states */
diff --git a/drivers/scsi/qla4xxx/ql4_init.c b/drivers/scsi/qla4xxx/ql4_init.c
index bbb2e90..48e2241 100644
--- a/drivers/scsi/qla4xxx/ql4_init.c
+++ b/drivers/scsi/qla4xxx/ql4_init.c
@@ -1338,7 +1338,7 @@ exit_init_hba:
 	}
 
 	DEBUG2(printk("scsi%ld: initialize adapter: %s\n", ha->host_no,
-	    status == QLA_ERROR ? "FAILED" : "SUCCEDED"));
+	    status == QLA_ERROR ? "FAILED" : "SUCCEEDED"));
 	return status;
 }
 
diff --git a/drivers/scsi/qla4xxx/ql4_nvram.h b/drivers/scsi/qla4xxx/ql4_nvram.h
index b3831bd..945cc32 100644
--- a/drivers/scsi/qla4xxx/ql4_nvram.h
+++ b/drivers/scsi/qla4xxx/ql4_nvram.h
@@ -28,7 +28,7 @@
 #define	 FM93C56A_ERASE	      0x3
 #define	 FM93C56A_ERASE_ALL   0x0
 
-/* Command Extentions */
+/* Command Extensions */
 #define	 FM93C56A_WEN_EXT	 0x3
 #define	 FM93C56A_WRITE_ALL_EXT	 0x1
 #define	 FM93C56A_WDS_EXT	 0x0
diff --git a/drivers/scsi/qla4xxx/ql4_os.c b/drivers/scsi/qla4xxx/ql4_os.c
index a4acb0d..230ba09 100644
--- a/drivers/scsi/qla4xxx/ql4_os.c
+++ b/drivers/scsi/qla4xxx/ql4_os.c
@@ -1213,7 +1213,7 @@ recover_ha_init_adapter:
 
 	clear_bit(DPC_RESET_ACTIVE, &ha->dpc_flags);
 	DEBUG2(printk("scsi%ld: recover adapter: %s\n", ha->host_no,
-	    status == QLA_ERROR ? "FAILED" : "SUCCEDED"));
+	    status == QLA_ERROR ? "FAILED" : "SUCCEEDED"));
 
 	return status;
 }
@@ -2110,7 +2110,7 @@ static int qla4xxx_eh_abort(struct scsi_cmnd *cmd)
 
 	ql4_printk(KERN_INFO, ha,
 	    "scsi%ld:%d:%d: Abort command - %s\n",
-	    ha->host_no, id, lun, (ret == SUCCESS) ? "succeded" : "failed");
+	    ha->host_no, id, lun, (ret == SUCCESS) ? "succeeded" : "failed");
 
 	return ret;
 }
@@ -2278,7 +2278,7 @@ static int qla4xxx_eh_host_reset(struct scsi_cmnd *cmd)
 		return_status = SUCCESS;
 
 	ql4_printk(KERN_INFO, ha, "HOST RESET %s.\n",
-		   return_status == FAILED ? "FAILED" : "SUCCEDED");
+		   return_status == FAILED ? "FAILED" : "SUCCEEDED");
 
 	return return_status;
 }
@@ -2492,7 +2492,7 @@ qla4xxx_pci_slot_reset(struct pci_dev *pdev)
 	/* Initialize device or resume if in suspended state */
 	rc = pci_enable_device(pdev);
 	if (rc) {
-		ql4_printk(KERN_WARNING, ha, "scsi%ld: %s: Cant re-enable "
+		ql4_printk(KERN_WARNING, ha, "scsi%ld: %s: Can't re-enable "
 		    "device after reset\n", ha->host_no, __func__);
 		goto exit_slot_reset;
 	}
diff --git a/drivers/scsi/scsi_debug.c b/drivers/scsi/scsi_debug.c
index fa5758c..6888b2c 100644
--- a/drivers/scsi/scsi_debug.c
+++ b/drivers/scsi/scsi_debug.c
@@ -2454,7 +2454,7 @@ static void scsi_debug_slave_destroy(struct scsi_device *sdp)
 		printk(KERN_INFO "scsi_debug: slave_destroy <%u %u %u %u>\n",
 		       sdp->host->host_no, sdp->channel, sdp->id, sdp->lun);
 	if (devip) {
-		/* make this slot avaliable for re-use */
+		/* make this slot available for re-use */
 		devip->used = 0;
 		sdp->hostdata = NULL;
 	}
diff --git a/drivers/scsi/scsi_netlink.c b/drivers/scsi/scsi_netlink.c
index a2ed201..26a8a45 100644
--- a/drivers/scsi/scsi_netlink.c
+++ b/drivers/scsi/scsi_netlink.c
@@ -499,7 +499,7 @@ scsi_netlink_init(void)
 				SCSI_NL_GRP_CNT, scsi_nl_rcv_msg, NULL,
 				THIS_MODULE);
 	if (!scsi_nl_sock) {
-		printk(KERN_ERR "%s: register of recieve handler failed\n",
+		printk(KERN_ERR "%s: register of receive handler failed\n",
 				__func__);
 		netlink_unregister_notifier(&scsi_netlink_notifier);
 		return;
diff --git a/drivers/scsi/scsi_tgt_lib.c b/drivers/scsi/scsi_tgt_lib.c
index f672820..8bca8c2 100644
--- a/drivers/scsi/scsi_tgt_lib.c
+++ b/drivers/scsi/scsi_tgt_lib.c
@@ -93,7 +93,7 @@ struct scsi_cmnd *scsi_host_get_command(struct Scsi_Host *shost,
 
 	/*
 	 * The blk helpers are used to the READ/WRITE requests
-	 * transfering data from a initiator point of view. Since
+	 * transferring data from a initiator point of view. Since
 	 * we are in target mode we want the opposite.
 	 */
 	rq = blk_get_request(shost->uspace_req_q, !write, gfp_mask);
diff --git a/drivers/scsi/scsi_transport_fc.c b/drivers/scsi/scsi_transport_fc.c
index 2941d2d..fdf3fa6 100644
--- a/drivers/scsi/scsi_transport_fc.c
+++ b/drivers/scsi/scsi_transport_fc.c
@@ -2378,7 +2378,7 @@ fc_flush_devloss(struct Scsi_Host *shost)
  * fc_remove_host - called to terminate any fc_transport-related elements for a scsi host.
  * @shost:	Which &Scsi_Host
  *
- * This routine is expected to be called immediately preceeding the
+ * This routine is expected to be called immediately preceding the
  * a driver's call to scsi_remove_host().
  *
  * WARNING: A driver utilizing the fc_transport, which fails to call
@@ -2458,7 +2458,7 @@ static void fc_terminate_rport_io(struct fc_rport *rport)
 }
 
 /**
- * fc_starget_delete - called to delete the scsi decendents of an rport
+ * fc_starget_delete - called to delete the scsi descendants of an rport
  * @work:	remote port to be operated on.
  *
  * Deletes target and all sdevs.
diff --git a/drivers/scsi/sd.c b/drivers/scsi/sd.c
index b61ebec..bd0806e 100644
--- a/drivers/scsi/sd.c
+++ b/drivers/scsi/sd.c
@@ -1055,7 +1055,7 @@ static int sd_getgeo(struct block_device *bdev, struct hd_geometry *geo)
  *	@arg: this is third argument given to ioctl(2) system call.
  *	Often contains a pointer.
  *
- *	Returns 0 if successful (some ioctls return postive numbers on
+ *	Returns 0 if successful (some ioctls return positive numbers on
  *	success as well). Returns a negated errno value in case of error.
  *
  *	Note: most ioctls are forward onto the block subsystem or further
diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index aefadc6..95019c7 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -567,7 +567,7 @@ static const struct block_device_operations sr_bdops =
 	.revalidate_disk = sr_block_revalidate_disk,
 	/* 
 	 * No compat_ioctl for now because sr_block_ioctl never
-	 * seems to pass arbitary ioctls down to host drivers.
+	 * seems to pass arbitrary ioctls down to host drivers.
 	 */
 };
 
diff --git a/drivers/scsi/sun3_NCR5380.c b/drivers/scsi/sun3_NCR5380.c
index 4f0e548..07eaef1 100644
--- a/drivers/scsi/sun3_NCR5380.c
+++ b/drivers/scsi/sun3_NCR5380.c
@@ -467,7 +467,7 @@ static void free_all_tags( void )
  *
  * Parameters: struct scsi_cmnd *cmd
  *    The command to work on. The first scatter buffer's data are
- *    assumed to be already transfered into ptr/this_residual.
+ *    assumed to be already transferred into ptr/this_residual.
  */
 
 static void merge_contiguous_buffers(struct scsi_cmnd *cmd)
@@ -1717,7 +1717,7 @@ static int NCR5380_select(struct Scsi_Host *instance, struct scsi_cmnd *cmd,
  *	bytes to transfer, **data - pointer to data pointer.
  * 
  * Returns : -1 when different phase is entered without transferring
- *	maximum number of bytes, 0 if all bytes are transfered or exit
+ *	maximum number of bytes, 0 if all bytes are transferred or exit
  *	is in same phase.
  *
  * 	Also, *phase, *count, *data are modified in place.
@@ -1904,7 +1904,7 @@ static int do_abort (struct Scsi_Host *host)
  *	bytes to transfer, **data - pointer to data pointer.
  * 
  * Returns : -1 when different phase is entered without transferring
- *	maximum number of bytes, 0 if all bytes or transfered or exit
+ *	maximum number of bytes, 0 if all bytes or transferred or exit
  *	is in same phase.
  *
  * 	Also, *phase, *count, *data are modified in place.
diff --git a/drivers/scsi/sym53c416.c b/drivers/scsi/sym53c416.c
index 190107a..012c86e 100644
--- a/drivers/scsi/sym53c416.c
+++ b/drivers/scsi/sym53c416.c
@@ -774,7 +774,7 @@ static int sym53c416_host_reset(Scsi_Cmnd *SCpnt)
 
 	/* printk("sym53c416_reset\n"); */
 	base = SCpnt->device->host->io_port;
-	/* search scsi_id - fixme, we shouldnt need to iterate for this! */
+	/* search scsi_id - fixme, we shouldn't need to iterate for this! */
 	for(i = 0; i < host_index && scsi_id == -1; i++)
 		if(hosts[i].base == base)
 			scsi_id = hosts[i].scsi_id;
diff --git a/drivers/scsi/sym53c8xx_2/sym_fw1.h b/drivers/scsi/sym53c8xx_2/sym_fw1.h
index 7b08d6c..63952ee 100644
--- a/drivers/scsi/sym53c8xx_2/sym_fw1.h
+++ b/drivers/scsi/sym53c8xx_2/sym_fw1.h
@@ -1449,7 +1449,7 @@ static struct SYM_FWB_SCR SYM_FWB_SCR = {
 		PADDR_B (msg_weird_seen),
 	/*
 	 *  We donnot handle extended messages from SCRIPTS.
-	 *  Read the amount of data correponding to the 
+	 *  Read the amount of data corresponding to the 
 	 *  message length and call the C code.
 	 */
 	SCR_COPY (1),
diff --git a/drivers/scsi/sym53c8xx_2/sym_fw2.h b/drivers/scsi/sym53c8xx_2/sym_fw2.h
index ae1fb17..c87d724 100644
--- a/drivers/scsi/sym53c8xx_2/sym_fw2.h
+++ b/drivers/scsi/sym53c8xx_2/sym_fw2.h
@@ -1326,7 +1326,7 @@ static struct SYM_FWB_SCR SYM_FWB_SCR = {
 		PADDR_B (msg_weird_seen),
 	/*
 	 *  We donnot handle extended messages from SCRIPTS.
-	 *  Read the amount of data correponding to the 
+	 *  Read the amount of data corresponding to the 
 	 *  message length and call the C code.
 	 */
 	SCR_STORE_REL (scratcha, 1),
diff --git a/drivers/scsi/sym53c8xx_2/sym_hipd.c b/drivers/scsi/sym53c8xx_2/sym_hipd.c
index 2c3e89d..d92fe40 100644
--- a/drivers/scsi/sym53c8xx_2/sym_hipd.c
+++ b/drivers/scsi/sym53c8xx_2/sym_hipd.c
@@ -2457,7 +2457,7 @@ static void sym_int_ma (struct sym_hcb *np)
 		}
 
 		/*
-		 *  The data in the dma fifo has not been transfered to
+		 *  The data in the dma fifo has not been transferred to
 		 *  the target -> add the amount to the rest
 		 *  and clear the data.
 		 *  Check the sstat2 register in case of wide transfer.
@@ -5094,7 +5094,7 @@ fail:
 }
 
 /*
- *  Lun control block deallocation. Returns the number of valid remaing LCBs
+ *  Lun control block deallocation. Returns the number of valid remaining LCBs
  *  for the target.
  */
 int sym_free_lcb(struct sym_hcb *np, u_char tn, u_char ln)
diff --git a/drivers/scsi/sym53c8xx_2/sym_malloc.c b/drivers/scsi/sym53c8xx_2/sym_malloc.c
index 883cac1..6f9af0d 100644
--- a/drivers/scsi/sym53c8xx_2/sym_malloc.c
+++ b/drivers/scsi/sym53c8xx_2/sym_malloc.c
@@ -50,7 +50,7 @@
  *  from the SCRIPTS code. In addition, cache line alignment 
  *  is guaranteed for power of 2 cache line size.
  *
- *  This allocator has been developped for the Linux sym53c8xx  
+ *  This allocator has been developed for the Linux sym53c8xx  
  *  driver, since this O/S does not provide naturally aligned 
  *  allocations.
  *  It has the advantage of allowing the driver to use private 
diff --git a/drivers/scsi/wd33c93.c b/drivers/scsi/wd33c93.c
index 5f697e0..4468ae3 100644
--- a/drivers/scsi/wd33c93.c
+++ b/drivers/scsi/wd33c93.c
@@ -1843,7 +1843,7 @@ check_setup_args(char *key, int *flags, int *val, char *buf)
  *
  * The original driver used to rely on a fixed sx_table, containing periods
  * for (only) the lower limits of the respective input-clock-frequency ranges
- * (8-10/12-15/16-20 MHz). Although it seems, that no problems ocurred with
+ * (8-10/12-15/16-20 MHz). Although it seems, that no problems occurred with
  * this setting so far, it might be desirable to adjust the transfer periods
  * closer to the really attached, possibly 25% higher, input-clock, since
  * - the wd33c93 may really use a significant shorter period, than it has
diff --git a/drivers/scsi/wd7000.c b/drivers/scsi/wd7000.c
index db451ae..9ee0afe 100644
--- a/drivers/scsi/wd7000.c
+++ b/drivers/scsi/wd7000.c
@@ -837,7 +837,7 @@ static inline Scb *alloc_scbs(struct Scsi_Host *host, int needed)
 		}
 	}
 
-	/* Take the lock, then check we didnt get beaten, if so try again */
+	/* Take the lock, then check we didn't get beaten, if so try again */
 	spin_lock_irqsave(&scbpool_lock, flags);
 	if (freescbs < needed) {
 		spin_unlock_irqrestore(&scbpool_lock, flags);
diff --git a/drivers/sfi/sfi_core.c b/drivers/sfi/sfi_core.c
index 04113e5..1e824fb 100644
--- a/drivers/sfi/sfi_core.c
+++ b/drivers/sfi/sfi_core.c
@@ -515,7 +515,7 @@ void __init sfi_init_late(void)
 }
 
 /*
- * The reason we put it here becasue we need wait till the /sys/firmware
+ * The reason we put it here because we need wait till the /sys/firmware
  * is setup, then our interface can be registered in /sys/firmware/sfi
  */
 core_initcall(sfi_sysfs_init);
diff --git a/drivers/spi/amba-pl022.c b/drivers/spi/amba-pl022.c
index 5a4e0af..5825370 100644
--- a/drivers/spi/amba-pl022.c
+++ b/drivers/spi/amba-pl022.c
@@ -661,7 +661,7 @@ static void readwriter(struct pl022 *pl022)
 {
 
 	/*
-	 * The FIFO depth is different inbetween primecell variants.
+	 * The FIFO depth is different between primecell variants.
 	 * I believe filling in too much in the FIFO might cause
 	 * errons in 8bit wide transfers on ARM variants (just 8 words
 	 * FIFO, means only 8x8 = 64 bits in FIFO) at least.
@@ -722,7 +722,7 @@ static void readwriter(struct pl022 *pl022)
 		 * This inner reader takes care of things appearing in the RX
 		 * FIFO as we're transmitting. This will happen a lot since the
 		 * clock starts running when you put things into the TX FIFO,
-		 * and then things are continously clocked into the RX FIFO.
+		 * and then things are continuously clocked into the RX FIFO.
 		 */
 		while ((readw(SSP_SR(pl022->virtbase)) & SSP_SR_MASK_RNE)
 		       && (pl022->rx < pl022->rx_end)) {
@@ -842,7 +842,7 @@ static void dma_callback(void *data)
 
 	unmap_free_dma_scatter(pl022);
 
-	/* Update total bytes transfered */
+	/* Update total bytes transferred */
 	msg->actual_length += pl022->cur_transfer->len;
 	if (pl022->cur_transfer->cs_change)
 		pl022->cur_chip->
@@ -1224,7 +1224,7 @@ static irqreturn_t pl022_interrupt_handler(int irq, void *dev_id)
 				 "number of bytes on a 16bit bus?)\n",
 				 (u32) (pl022->rx - pl022->rx_end));
 		}
-		/* Update total bytes transfered */
+		/* Update total bytes transferred */
 		msg->actual_length += pl022->cur_transfer->len;
 		if (pl022->cur_transfer->cs_change)
 			pl022->cur_chip->
@@ -1415,11 +1415,11 @@ static void do_polling_transfer(struct pl022 *pl022)
 		       SSP_CR1(pl022->virtbase));
 
 		dev_dbg(&pl022->adev->dev, "polling transfer ongoing ...\n");
-		/* FIXME: insert a timeout so we don't hang here indefinately */
+		/* FIXME: insert a timeout so we don't hang here indefinitely */
 		while (pl022->tx < pl022->tx_end || pl022->rx < pl022->rx_end)
 			readwriter(pl022);
 
-		/* Update total byte transfered */
+		/* Update total byte transferred */
 		message->actual_length += pl022->cur_transfer->len;
 		if (pl022->cur_transfer->cs_change)
 			pl022->cur_chip->cs_control(SSP_CHIP_DESELECT);
@@ -2129,7 +2129,7 @@ pl022_probe(struct amba_device *adev, const struct amba_id *id)
 			"probe - problem registering spi master\n");
 		goto err_spi_register;
 	}
-	dev_dbg(dev, "probe succeded\n");
+	dev_dbg(dev, "probe succeeded\n");
 	/*
 	 * Disable the silicon block pclk and any voltage domain and just
 	 * power it up and clock it when it's needed
@@ -2184,7 +2184,7 @@ pl022_remove(struct amba_device *adev)
 	spi_unregister_master(pl022->master);
 	spi_master_put(pl022->master);
 	amba_set_drvdata(adev, NULL);
-	dev_dbg(&adev->dev, "remove succeded\n");
+	dev_dbg(&adev->dev, "remove succeeded\n");
 	return 0;
 }
 
diff --git a/drivers/spi/au1550_spi.c b/drivers/spi/au1550_spi.c
index 3c9ade6..b50563d 100644
--- a/drivers/spi/au1550_spi.c
+++ b/drivers/spi/au1550_spi.c
@@ -480,7 +480,7 @@ static irqreturn_t au1550_spi_dma_irq_callback(struct au1550_spi *hw)
 		au1xxx_dbdma_stop(hw->dma_rx_ch);
 		au1xxx_dbdma_stop(hw->dma_tx_ch);
 
-		/* get number of transfered bytes */
+		/* get number of transferred bytes */
 		hw->rx_count = hw->len - au1xxx_get_dma_residue(hw->dma_rx_ch);
 		hw->tx_count = hw->len - au1xxx_get_dma_residue(hw->dma_tx_ch);
 
diff --git a/drivers/spi/dw_spi.c b/drivers/spi/dw_spi.c
index 9a61964..b1a4b9f 100644
--- a/drivers/spi/dw_spi.c
+++ b/drivers/spi/dw_spi.c
@@ -345,7 +345,7 @@ static void int_error_stop(struct dw_spi *dws, const char *msg)
 
 void dw_spi_xfer_done(struct dw_spi *dws)
 {
-	/* Update total byte transfered return count actual bytes read */
+	/* Update total byte transferred return count actual bytes read */
 	dws->cur_msg->actual_length += dws->len;
 
 	/* Move to next transfer */
diff --git a/drivers/spi/dw_spi.h b/drivers/spi/dw_spi.h
index fb0bce5..b23e452 100644
--- a/drivers/spi/dw_spi.h
+++ b/drivers/spi/dw_spi.h
@@ -46,7 +46,7 @@
 #define SPI_INT_RXFI			(1 << 4)
 #define SPI_INT_MSTI			(1 << 5)
 
-/* TX RX interrupt level threshhold, max can be 256 */
+/* TX RX interrupt level threshold, max can be 256 */
 #define SPI_INT_THRESHOLD		32
 
 enum dw_ssi_type {
diff --git a/drivers/spi/ep93xx_spi.c b/drivers/spi/ep93xx_spi.c
index 0ba35df..d357007 100644
--- a/drivers/spi/ep93xx_spi.c
+++ b/drivers/spi/ep93xx_spi.c
@@ -512,7 +512,7 @@ static int ep93xx_spi_read_write(struct ep93xx_spi *espi)
  *
  * This function processes one SPI transfer given in @t. Function waits until
  * transfer is complete (may sleep) and updates @msg->status based on whether
- * transfer was succesfully processed or not.
+ * transfer was successfully processed or not.
  */
 static void ep93xx_spi_process_transfer(struct ep93xx_spi *espi,
 					struct spi_message *msg,
diff --git a/drivers/spi/pxa2xx_spi.c b/drivers/spi/pxa2xx_spi.c
index a429b01..9c74aad 100644
--- a/drivers/spi/pxa2xx_spi.c
+++ b/drivers/spi/pxa2xx_spi.c
@@ -700,7 +700,7 @@ static void int_transfer_complete(struct driver_data *drv_data)
 	if (!pxa25x_ssp_comp(drv_data))
 		write_SSTO(0, reg);
 
-	/* Update total byte transfered return count actual bytes read */
+	/* Update total byte transferred return count actual bytes read */
 	drv_data->cur_msg->actual_length += drv_data->len -
 				(drv_data->rx_end - drv_data->rx);
 
@@ -759,7 +759,7 @@ static irqreturn_t interrupt_transfer(struct driver_data *drv_data)
 
 		/*
 		 * PXA25x_SSP has no timeout, set up rx threshould for the
-		 * remaing RX bytes.
+		 * remaining RX bytes.
 		 */
 		if (pxa25x_ssp_comp(drv_data)) {
 
diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 34bb17f..82b9a42 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -957,7 +957,7 @@ EXPORT_SYMBOL_GPL(spi_sync);
  * drivers may DMA directly into and out of the message buffers.
  *
  * This call should be used by drivers that require exclusive access to the
- * SPI bus. It has to be preceeded by a spi_bus_lock call. The SPI bus must
+ * SPI bus. It has to be preceded by a spi_bus_lock call. The SPI bus must
  * be released by a spi_bus_unlock call when the exclusive access is over.
  *
  * It returns zero on success, else a negative error code.
diff --git a/drivers/spi/spi_bfin5xx.c b/drivers/spi/spi_bfin5xx.c
index a284624..bdb7289 100644
--- a/drivers/spi/spi_bfin5xx.c
+++ b/drivers/spi/spi_bfin5xx.c
@@ -905,7 +905,7 @@ static void bfin_spi_pump_transfers(unsigned long data)
 			"IO write error!\n");
 		message->state = ERROR_STATE;
 	} else {
-		/* Update total byte transfered */
+		/* Update total byte transferred */
 		message->actual_length += drv_data->len_in_bytes;
 		/* Move to next transfer of this msg */
 		message->state = bfin_spi_next_transfer(drv_data);
diff --git a/drivers/spi/spi_fsl_espi.c b/drivers/spi/spi_fsl_espi.c
index 900e921..496f895 100644
--- a/drivers/spi/spi_fsl_espi.c
+++ b/drivers/spi/spi_fsl_espi.c
@@ -474,7 +474,7 @@ static int fsl_espi_setup(struct spi_device *spi)
 	mpc8xxx_spi = spi_master_get_devdata(spi->master);
 	reg_base = mpc8xxx_spi->reg_base;
 
-	hw_mode = cs->hw_mode; /* Save orginal settings */
+	hw_mode = cs->hw_mode; /* Save original settings */
 	cs->hw_mode = mpc8xxx_spi_read_reg(
 			&reg_base->csmode[spi->chip_select]);
 	/* mask out bits we are going to set */
diff --git a/drivers/ssb/pci.c b/drivers/ssb/pci.c
index a467b20..6f34963 100644
--- a/drivers/ssb/pci.c
+++ b/drivers/ssb/pci.c
@@ -670,7 +670,7 @@ static int ssb_pci_sprom_get(struct ssb_bus *bus,
 		ssb_printk(KERN_ERR PFX "No SPROM available!\n");
 		return -ENODEV;
 	}
-	if (bus->chipco.dev) {	/* can be unavailible! */
+	if (bus->chipco.dev) {	/* can be unavailable! */
 		/*
 		 * get SPROM offset: SSB_SPROM_BASE1 except for
 		 * chipcommon rev >= 31 or chip ID is 0x4312 and
diff --git a/drivers/ssb/sprom.c b/drivers/ssb/sprom.c
index 4f7cc8d..5f34d7a 100644
--- a/drivers/ssb/sprom.c
+++ b/drivers/ssb/sprom.c
@@ -185,7 +185,7 @@ bool ssb_is_sprom_available(struct ssb_bus *bus)
 	/* this routine differs from specs as we do not access SPROM directly
 	   on PCMCIA */
 	if (bus->bustype == SSB_BUSTYPE_PCI &&
-	    bus->chipco.dev &&	/* can be unavailible! */
+	    bus->chipco.dev &&	/* can be unavailable! */
 	    bus->chipco.dev->id.revision >= 31)
 		return bus->chipco.capabilities & SSB_CHIPCO_CAP_SPROM;
 
diff --git a/drivers/staging/Kconfig b/drivers/staging/Kconfig
index 18b43fc..dca4a0b 100644
--- a/drivers/staging/Kconfig
+++ b/drivers/staging/Kconfig
@@ -117,8 +117,6 @@ source "drivers/staging/hv/Kconfig"
 
 source "drivers/staging/vme/Kconfig"
 
-source "drivers/staging/memrar/Kconfig"
-
 source "drivers/staging/sep/Kconfig"
 
 source "drivers/staging/iio/Kconfig"
diff --git a/drivers/staging/Makefile b/drivers/staging/Makefile
index cfd13cd..eb93012 100644
--- a/drivers/staging/Makefile
+++ b/drivers/staging/Makefile
@@ -40,7 +40,6 @@ obj-$(CONFIG_VT6655)		+= vt6655/
 obj-$(CONFIG_VT6656)		+= vt6656/
 obj-$(CONFIG_HYPERV)		+= hv/
 obj-$(CONFIG_VME_BUS)		+= vme/
-obj-$(CONFIG_MRST_RAR_HANDLER)	+= memrar/
 obj-$(CONFIG_DX_SEP)            += sep/
 obj-$(CONFIG_IIO)		+= iio/
 obj-$(CONFIG_CS5535_GPIO)	+= cs5535_gpio/
diff --git a/drivers/staging/ath6kl/htc2/AR6000/ar6k_gmbox_hciuart.c b/drivers/staging/ath6kl/htc2/AR6000/ar6k_gmbox_hciuart.c
index c6488e0..41223f9 100644
--- a/drivers/staging/ath6kl/htc2/AR6000/ar6k_gmbox_hciuart.c
+++ b/drivers/staging/ath6kl/htc2/AR6000/ar6k_gmbox_hciuart.c
@@ -237,7 +237,7 @@ static int CreditsAvailableCallback(void *pContext, int Credits, bool CreditIRQE
                          pProt->CreditsCurrentSeek));
         
         if (pProt->CreditsAvailable >= pProt->CreditsCurrentSeek) {
-                /* we have enough credits to fullfill at least 1 packet waiting in the queue */
+                /* we have enough credits to fulfill at least 1 packet waiting in the queue */
             pProt->CreditsCurrentSeek = 0;
             pProt->SendStateFlags &= ~HCI_SEND_WAIT_CREDITS;  
             doPendingSends = true;
@@ -285,7 +285,7 @@ static void FailureCallback(void *pContext, int Status)
 {
     struct gmbox_proto_hci_uart  *pProt = (struct gmbox_proto_hci_uart *)pContext; 
     
-        /* target assertion occured */           
+        /* target assertion occurred */           
     NotifyTransportFailure(pProt, Status);  
 }
 
@@ -507,7 +507,7 @@ static int HCIUartMessagePending(void *pContext, u8 LookAheadBytes[], int ValidB
         
     } while (false);
         
-        /* check if we need to disable the reciever */
+        /* check if we need to disable the receiver */
     if (status || blockRecv) {
         DevGMboxIRQAction(pProt->pDev, GMBOX_RECV_IRQ_DISABLE, PROC_IO_SYNC); 
     }
diff --git a/drivers/staging/ath6kl/include/aggr_recv_api.h b/drivers/staging/ath6kl/include/aggr_recv_api.h
index 67a0584..5ead58d 100644
--- a/drivers/staging/ath6kl/include/aggr_recv_api.h
+++ b/drivers/staging/ath6kl/include/aggr_recv_api.h
@@ -72,7 +72,7 @@ aggr_process_bar(void *cntxt, u8 tid, u16 seq_no);
  * This event is to initiate/modify the receive side window.
  * Target will send WMI_ADDBA_REQ_EVENTID event to host - to setup 
  * recv re-ordering queues. Target will negotiate ADDBA with peer, 
- * and indicate via this event after succesfully completing the 
+ * and indicate via this event after successfully completing the 
  * negotiation. This happens in two situations:
  *  1. Initial setup of aggregation
  *  2. Renegotiation of current recv window.
diff --git a/drivers/staging/ath6kl/include/common/a_hci.h b/drivers/staging/ath6kl/include/common/a_hci.h
index 08cb013..379d652 100644
--- a/drivers/staging/ath6kl/include/common/a_hci.h
+++ b/drivers/staging/ath6kl/include/common/a_hci.h
@@ -124,7 +124,7 @@
 #define PAL_NUM_COMPL_DATA_BLOCK_EVENT              0x48
 #define PAL_SHORT_RANGE_MODE_CHANGE_COMPL_EVENT     0x4C
 #define PAL_AMP_STATUS_CHANGE_EVENT                 0x4D
-/*======== End of PAL events definiton =================*/
+/*======== End of PAL events definition =================*/
 
 
 /*======== Timeouts (not part of HCI cmd, but input to PAL engine) =========*/
@@ -430,7 +430,7 @@ typedef struct  hci_event_hw_err_t {
     u8 hw_err_code;
 } POSTPACK HCI_EVENT_HW_ERR;
 
-/* Flush occured event */
+/* Flush occurred event */
 /* Qos Violation event */
 typedef struct  hci_event_handle_t {
     u8 event_code;
diff --git a/drivers/staging/ath6kl/include/common/dbglog.h b/drivers/staging/ath6kl/include/common/dbglog.h
index 3a3d00d..b7a1230 100644
--- a/drivers/staging/ath6kl/include/common/dbglog.h
+++ b/drivers/staging/ath6kl/include/common/dbglog.h
@@ -44,7 +44,7 @@ extern "C" {
 #define DBGLOG_MODULEID_NUM_MAX          16 /* Upper limit is width of mask */
 
 /*
- * Please ensure that the definition of any new module intrduced is captured
+ * Please ensure that the definition of any new module introduced is captured
  * between the DBGLOG_MODULEID_START and DBGLOG_MODULEID_END defines. The 
  * structure is required for the parser to correctly pick up the values for
  * different modules.
diff --git a/drivers/staging/ath6kl/include/common/epping_test.h b/drivers/staging/ath6kl/include/common/epping_test.h
index 5c40d8a..7027fac 100644
--- a/drivers/staging/ath6kl/include/common/epping_test.h
+++ b/drivers/staging/ath6kl/include/common/epping_test.h
@@ -92,7 +92,7 @@ typedef PREPACK struct {
 #define EPPING_CMD_RESET_RECV_CNT       2   /* reset recv count */
 #define EPPING_CMD_CAPTURE_RECV_CNT     3   /* fetch recv count, 4-byte count returned in CmdBuffer_t */
 #define EPPING_CMD_NO_ECHO              4   /* non-echo packet test (tx-only) */
-#define EPPING_CMD_CONT_RX_START        5   /* continous RX packets, parameters are in CmdBuffer_h */
+#define EPPING_CMD_CONT_RX_START        5   /* continuous RX packets, parameters are in CmdBuffer_h */
 #define EPPING_CMD_CONT_RX_STOP         6   /* stop continuous RX packet transmission */
 
     /* test command parameters may be no more than 8 bytes */
diff --git a/drivers/staging/ath6kl/include/common/ini_dset.h b/drivers/staging/ath6kl/include/common/ini_dset.h
index 8bfc759..a9e05fa 100644
--- a/drivers/staging/ath6kl/include/common/ini_dset.h
+++ b/drivers/staging/ath6kl/include/common/ini_dset.h
@@ -31,7 +31,7 @@
  */
 typedef enum {
 #if defined(AR6002_REV4) || defined(AR6003)
-/* Add these definitions for compatability  */
+/* Add these definitions for compatibility  */
 #define WHAL_INI_DATA_ID_BB_RFGAIN_LNA1 WHAL_INI_DATA_ID_BB_RFGAIN
 #define WHAL_INI_DATA_ID_BB_RFGAIN_LNA2 WHAL_INI_DATA_ID_BB_RFGAIN
     WHAL_INI_DATA_ID_NULL               =0,
diff --git a/drivers/staging/ath6kl/include/common/testcmd.h b/drivers/staging/ath6kl/include/common/testcmd.h
index 9ca1f2a..7d94aee 100644
--- a/drivers/staging/ath6kl/include/common/testcmd.h
+++ b/drivers/staging/ath6kl/include/common/testcmd.h
@@ -43,8 +43,8 @@ typedef enum {
     PN15_PATTERN
 }TX_DATA_PATTERN;
 
-/* Continous tx
-   mode : TCMD_CONT_TX_OFF - Disabling continous tx
+/* Continuous tx
+   mode : TCMD_CONT_TX_OFF - Disabling continuous tx
           TCMD_CONT_TX_SINE - Enable continuous unmodulated tx
           TCMD_CONT_TX_FRAME- Enable continuous modulated tx
    freq : Channel freq in Mhz. (e.g 2412 for channel 1 in 11 g)
diff --git a/drivers/staging/ath6kl/include/common/wmi.h b/drivers/staging/ath6kl/include/common/wmi.h
index c645af3..4e63434 100644
--- a/drivers/staging/ath6kl/include/common/wmi.h
+++ b/drivers/staging/ath6kl/include/common/wmi.h
@@ -1568,8 +1568,8 @@ typedef PREPACK struct {
                                    switch to ps-poll mode
                                   default = 3 */
 
-	u32 scoContStompMax;   /* max number of continous stomp allowed in opt mode.
-                                   if excedded switch to pspoll mode
+	u32 scoContStompMax;   /* max number of continuous stomp allowed in opt mode.
+                                   if exceeded switch to pspoll mode
                                     default = 3 */
 
 	u32 scoMinlowRateMbps; /* Low rate threshold */
@@ -2084,7 +2084,7 @@ typedef PREPACK struct {
 /*
  * BSS INFO HDR version 2.0
  * With 6 bytes HTC header and 6 bytes of WMI header
- * WMI_BSS_INFO_HDR cannot be accomodated in the removed 802.11 management
+ * WMI_BSS_INFO_HDR cannot be accommodated in the removed 802.11 management
  * header space.
  * - Reduce the ieMask to 2 bytes as only two bit flags are used
  * - Remove rssi and compute it on the host. rssi = snr - 95
@@ -2911,7 +2911,7 @@ typedef PREPACK struct {
     u8 pktID; /* packet ID to identify parent packet */
     u8 rateIdx; /* rate index on successful transmission */
     u8 ackFailures; /* number of ACK failures in tx attempt */
-#if 0 /* optional params currently ommitted. */
+#if 0 /* optional params currently omitted. */
     u32 queueDelay; // usec delay measured Tx Start time - host delivery time
     u32 mediaDelay; // usec delay measured ACK rx time - host delivery time
 #endif
diff --git a/drivers/staging/ath6kl/include/common/wmix.h b/drivers/staging/ath6kl/include/common/wmix.h
index 5ebb828..36acba6 100644
--- a/drivers/staging/ath6kl/include/common/wmix.h
+++ b/drivers/staging/ath6kl/include/common/wmix.h
@@ -191,7 +191,7 @@ typedef PREPACK struct {
 } POSTPACK WMIX_GPIO_INTR_ACK_CMD;
 
 /*
- * Target informs Host of GPIO interrupts that have ocurred since the
+ * Target informs Host of GPIO interrupts that have occurred since the
  * last WMIX_GIPO_INTR_ACK_CMD was received.  Additional information --
  * the current GPIO input values is provided -- in order to support
  * use of a GPIO interrupt as a Data Valid signal for other GPIO pins.
diff --git a/drivers/staging/ath6kl/include/htc_api.h b/drivers/staging/ath6kl/include/htc_api.h
index 1bc2488..4fb7675 100644
--- a/drivers/staging/ath6kl/include/htc_api.h
+++ b/drivers/staging/ath6kl/include/htc_api.h
@@ -209,7 +209,7 @@ struct htc_endpoint_credit_dist {
 typedef enum _HTC_CREDIT_DIST_REASON {
     HTC_CREDIT_DIST_SEND_COMPLETE = 0,     /* credits available as a result of completed
                                               send operations (MANDATORY) resulting in credit reports */
-    HTC_CREDIT_DIST_ACTIVITY_CHANGE = 1,   /* a change in endpoint activity occured (OPTIONAL) */
+    HTC_CREDIT_DIST_ACTIVITY_CHANGE = 1,   /* a change in endpoint activity occurred (OPTIONAL) */
     HTC_CREDIT_DIST_SEEK_CREDITS,          /* an endpoint needs to "seek" credits (OPTIONAL) */
     HTC_DUMP_CREDIT_STATE                  /* for debugging, dump any state information that is kept by
                                               the distribution function */
@@ -253,7 +253,7 @@ struct htc_endpoint_stats {
     u32 RxPacketsBundled;       /* count of recv packets received in a bundle */
     u32 RxBundleLookAheads;     /* count of number of bundled lookaheads */
     u32 RxBundleIndFromHdr;     /* count of the number of bundle indications from the HTC header */
-    u32 RxAllocThreshHit;       /* count of the number of times the recv allocation threshhold was hit */
+    u32 RxAllocThreshHit;       /* count of the number of times the recv allocation threshold was hit */
     u32 RxAllocThreshBytes;     /* total number of bytes */
 };
 
@@ -391,7 +391,7 @@ int    HTCSendPkt(HTC_HANDLE HTCHandle, struct htc_packet *pPacket);
 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
 void        HTCStop(HTC_HANDLE HTCHandle);
 /*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-  @desc: Destory HTC service
+  @desc: Destroy HTC service
   @function name: HTCDestroy
   @input: HTCHandle 
   @output:
diff --git a/drivers/staging/ath6kl/miscdrv/credit_dist.c b/drivers/staging/ath6kl/miscdrv/credit_dist.c
index ae54e1f..33fa020 100644
--- a/drivers/staging/ath6kl/miscdrv/credit_dist.c
+++ b/drivers/staging/ath6kl/miscdrv/credit_dist.c
@@ -341,7 +341,7 @@ static void SeekCredits(struct common_credit_state_info *pCredInfo,
         credits = min(pCredInfo->CurrentFreeCredits,pEPDist->TxCreditsSeek);
 
         if (credits >= pEPDist->TxCreditsSeek) {
-                /* we found some to fullfill the seek request */
+                /* we found some to fulfill the seek request */
             break;
         }
 
@@ -364,8 +364,8 @@ static void SeekCredits(struct common_credit_state_info *pCredInfo,
 
             if ((pCurEpDist->TxCreditsAssigned - need) >= pCurEpDist->TxCreditsMin) {
                     /* the current one has been allocated more than it's minimum and it
-                     * has enough credits assigned above it's minimum to fullfill our need
-                     * try to take away just enough to fullfill our need */
+                     * has enough credits assigned above it's minimum to fulfill our need
+                     * try to take away just enough to fulfill our need */
                 ReduceCredits(pCredInfo,
                               pCurEpDist,
                               pCurEpDist->TxCreditsAssigned - need);
diff --git a/drivers/staging/ath6kl/os/linux/ar6000_android.c b/drivers/staging/ath6kl/os/linux/ar6000_android.c
index c96f6e9..4aa75ee 100644
--- a/drivers/staging/ath6kl/os/linux/ar6000_android.c
+++ b/drivers/staging/ath6kl/os/linux/ar6000_android.c
@@ -372,7 +372,7 @@ void android_ar6k_check_wow_status(struct ar6_softc *ar, struct sk_buff *skb, bo
             }
         }
         if (needWake) {
-            /* keep host wake up if there is any event and packate comming in*/
+            /* keep host wake up if there is any event and packate coming in*/
             if (wowledon) {
                 char buf[32];
                 int len = sprintf(buf, "on");
diff --git a/drivers/staging/ath6kl/os/linux/ar6000_drv.c b/drivers/staging/ath6kl/os/linux/ar6000_drv.c
index 27cb02d..97d6ce6 100644
--- a/drivers/staging/ath6kl/os/linux/ar6000_drv.c
+++ b/drivers/staging/ath6kl/os/linux/ar6000_drv.c
@@ -520,7 +520,7 @@ dbglog_parse_debug_logs(s8 *datap, u32 len)
 int
 ar6000_dbglog_get_debug_logs(struct ar6_softc *ar)
 {
-    u32 data[8]; /* Should be able to accomodate struct dbglog_buf_s */
+    u32 data[8]; /* Should be able to accommodate struct dbglog_buf_s */
     u32 address;
     u32 length;
     u32 dropped;
@@ -2063,7 +2063,7 @@ ar6000_stop_endpoint(struct net_device *dev, bool keepprofile, bool getdbglogs)
  * - In case of surprise removal, the hcd already frees up the pending
  *   for the device and hence there is no need to unregister the function
  *   driver inorder to get these requests. For planned removal, the function
- *   driver has to explictly unregister itself to have the hcd return all the
+ *   driver has to explicitly unregister itself to have the hcd return all the
  *   pending requests before the data structures for the devices are freed up.
  *   Note that as per the current implementation, the function driver will
  *   end up releasing all the devices since there is no API to selectively
@@ -2982,7 +2982,7 @@ ar6000_data_tx(struct sk_buff *skb, struct net_device *dev)
     /* If target is not associated */
     if( (!ar->arConnected && !bypasswmi)
 #ifdef CONFIG_HOST_TCMD_SUPPORT
-     /* TCMD doesnt support any data, free the buf and return */
+     /* TCMD doesn't support any data, free the buf and return */
     || (ar->arTargetMode == AR6000_TCMD_MODE)
 #endif
                                             ) {
@@ -6393,7 +6393,7 @@ static void DoHTCSendPktsTest(struct ar6_softc *ar, int MapNo, HTC_ENDPOINT_ID e
 /*
  * Add support for adding and removing a virtual adapter for soft AP.
  * Some OS requires different adapters names for station and soft AP mode.
- * To support these requirement, create and destory a netdevice  instance
+ * To support these requirement, create and destroy a netdevice  instance
  * when the AP mode is operational. A full fledged support for virual device
  * is not implemented. Rather a virtual interface is created and is linked
  * with the existing physical device instance during the operation of the 
diff --git a/drivers/staging/ath6kl/wmi/wmi.c b/drivers/staging/ath6kl/wmi/wmi.c
index 0ddaee2..a00bf0a 100644
--- a/drivers/staging/ath6kl/wmi/wmi.c
+++ b/drivers/staging/ath6kl/wmi/wmi.c
@@ -4867,7 +4867,7 @@ wmi_set_country(struct wmi_t *wmip, u8 *countryCode)
 #ifdef CONFIG_HOST_TCMD_SUPPORT
 /* WMI  layer doesn't need to know the data type of the test cmd.
    This would be beneficial for customers like Qualcomm, who might
-   have different test command requirements from differnt manufacturers
+   have different test command requirements from different manufacturers
  */
 int
 wmi_test_cmd(struct wmi_t *wmip, u8 *buf, u32 len)
diff --git a/drivers/staging/bcm/Adapter.h b/drivers/staging/bcm/Adapter.h
index 32909e2..20cca24 100644
--- a/drivers/staging/bcm/Adapter.h
+++ b/drivers/staging/bcm/Adapter.h
@@ -412,7 +412,7 @@ struct _MINI_ADAPTER
 
 	// this to keep track of the Tx and Rx MailBox Registers.
 	atomic_t		    CurrNumFreeTxDesc;
-	// to keep track the no of byte recieved
+	// to keep track the no of byte received
 	USHORT				PrevNumRecvDescs;
 	USHORT				CurrNumRecvDescs;
 	UINT				u32TotalDSD;
@@ -527,7 +527,7 @@ struct _MINI_ADAPTER
 	BOOLEAN			bStatusWrite;
 	UINT			uiNVMDSDSize;
 	UINT			uiVendorExtnFlag;
-	 //it will always represent choosed DSD at any point of time.
+	 //it will always represent chosen DSD at any point of time.
 	 // Generally it is Active DSD but in case of NVM RD/WR it might be different.
 	UINT			ulFlashCalStart;
 	ULONG                   ulFlashControlSectionStart;
@@ -546,10 +546,10 @@ struct _MINI_ADAPTER
 	PFLASH_CS_INFO psFlashCSInfo ;
 	PFLASH2X_VENDORSPECIFIC_INFO psFlash2xVendorInfo;
 	UINT uiFlashBaseAdd; //Flash start address
-	UINT uiActiveISOOffset; //Active ISO offset choosen before f/w download
+	UINT uiActiveISOOffset; //Active ISO offset chosen before f/w download
 	FLASH2X_SECTION_VAL eActiveISO; //Active ISO section val
-	FLASH2X_SECTION_VAL eActiveDSD;	//Active DSD val choosen before f/w download
-	UINT uiActiveDSDOffsetAtFwDld;  //For accessing Active DSD choosen before f/w download
+	FLASH2X_SECTION_VAL eActiveDSD;	//Active DSD val chosen before f/w download
+	UINT uiActiveDSDOffsetAtFwDld;  //For accessing Active DSD chosen before f/w download
 	UINT uiFlashLayoutMajorVersion ;
 	UINT uiFlashLayoutMinorVersion;
 	BOOLEAN bAllDSDWriteAllow ;
diff --git a/drivers/staging/bcm/CmHost.c b/drivers/staging/bcm/CmHost.c
index 9be184f..c0ee95a 100644
--- a/drivers/staging/bcm/CmHost.c
+++ b/drivers/staging/bcm/CmHost.c
@@ -384,7 +384,7 @@ static inline VOID CopyClassifierRuleToSF(PMINI_ADAPTER Adapter,stConvergenceSLT
 		}
 		if(psfCSType->cCPacketClassificationRule.u8Protocol == 0)
 		{
-			//we didnt get protocol field filled in by the BS
+			//we didn't get protocol field filled in by the BS
 			pstClassifierEntry->ucProtocolLength=0;
 		}
 		else
@@ -879,7 +879,7 @@ static VOID CopyToAdapter( register PMINI_ADAPTER Adapter,		/**<Pointer to the A
 
 						/*
 							Passing the argument u8PHSI instead of clsid. Because for DL with no classifier rule,
-							clsid will be zero hence we cant have multiple PHS rules for the same SF.
+							clsid will be zero hence we can't have multiple PHS rules for the same SF.
 							To support multiple PHS rule, passing u8PHSI.
 						*/
 
@@ -1103,7 +1103,7 @@ static VOID DumpCmControlPacket(PVOID pvBuffer)
 	BCM_DEBUG_PRINT( Adapter,DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL,  "u8TrafficIndicationPreference	: 0x%X",
 		pstAddIndication->sfAuthorizedSet.u8TrafficIndicationPreference);
 
-	BCM_DEBUG_PRINT( Adapter,DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL,  " Total Classifiers Recieved		: 0x%X",pstAddIndication->sfAuthorizedSet.u8TotalClassifiers);
+	BCM_DEBUG_PRINT( Adapter,DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL,  " Total Classifiers Received		: 0x%X",pstAddIndication->sfAuthorizedSet.u8TotalClassifiers);
 
 	nCurClassifierCnt = pstAddIndication->sfAuthorizedSet.u8TotalClassifiers;
 
@@ -1305,7 +1305,7 @@ static VOID DumpCmControlPacket(PVOID pvBuffer)
 	BCM_DEBUG_PRINT( Adapter,DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL,  "u8TrafficIndicationPreference	: 0x%02X",
 		pstAddIndication->sfAdmittedSet.u8TrafficIndicationPreference);
 
-	BCM_DEBUG_PRINT( Adapter,DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL,  " Total Classifiers Recieved		: 0x%X",pstAddIndication->sfAdmittedSet.u8TotalClassifiers);
+	BCM_DEBUG_PRINT( Adapter,DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL,  " Total Classifiers Received		: 0x%X",pstAddIndication->sfAdmittedSet.u8TotalClassifiers);
 
 	nCurClassifierCnt = pstAddIndication->sfAdmittedSet.u8TotalClassifiers;
 
@@ -1502,7 +1502,7 @@ static VOID DumpCmControlPacket(PVOID pvBuffer)
 	BCM_DEBUG_PRINT( Adapter,DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL,  " u8TrafficIndicationPreference	: 0x%X",
 		pstAddIndication->sfActiveSet.u8TrafficIndicationPreference);
 
-	BCM_DEBUG_PRINT( Adapter,DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL,  " Total Classifiers Recieved		: 0x%X",pstAddIndication->sfActiveSet.u8TotalClassifiers);
+	BCM_DEBUG_PRINT( Adapter,DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL,  " Total Classifiers Received		: 0x%X",pstAddIndication->sfActiveSet.u8TotalClassifiers);
 
 	nCurClassifierCnt = pstAddIndication->sfActiveSet.u8TotalClassifiers;
 
@@ -1696,7 +1696,7 @@ ULONG StoreCmControlResponseMessage(PMINI_ADAPTER Adapter,PVOID pvBuffer,UINT *p
 		//No Special handling send the message as it is
 		return 1;
 	}
-	// For DSA_REQ, only upto "psfAuthorizedSet" parameter should be accessed by driver!
+	// For DSA_REQ, only up to "psfAuthorizedSet" parameter should be accessed by driver!
 
 	pstAddIndication=kmalloc(sizeof(*pstAddIndication), GFP_KERNEL);
 	if(NULL==pstAddIndication)
@@ -1788,7 +1788,7 @@ static inline stLocalSFAddIndicationAlt
 	BCM_DEBUG_PRINT( Adapter,DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL, "Inside RestoreCmControlResponseMessage ");
 	/*
 	//Need to Allocate memory to contain the SUPER Large structures
-	//Our driver cant create these structures on Stack :(
+	//Our driver can't create these structures on Stack :(
 	*/
 	pstAddIndicationDest=kmalloc(sizeof(stLocalSFAddIndicationAlt), GFP_KERNEL);
 
@@ -1957,7 +1957,7 @@ INT AllocAdapterDsxBuffer(PMINI_ADAPTER Adapter)
 {
 	/*
 	//Need to Allocate memory to contain the SUPER Large structures
-	//Our driver cant create these structures on Stack
+	//Our driver can't create these structures on Stack
 	*/
 	Adapter->caDsxReqResp=kmalloc(sizeof(stLocalSFAddIndicationAlt)+LEADER_SIZE, GFP_KERNEL);
 	if(!Adapter->caDsxReqResp)
diff --git a/drivers/staging/bcm/HostMIBSInterface.h b/drivers/staging/bcm/HostMIBSInterface.h
index f17a4f1..e34531b 100644
--- a/drivers/staging/bcm/HostMIBSInterface.h
+++ b/drivers/staging/bcm/HostMIBSInterface.h
@@ -62,7 +62,7 @@ typedef struct _S_MIBS_HOST_INFO
 	ULONG			NumDesUsed;
 	ULONG			CurrNumFreeDesc;
 	ULONG			PrevNumFreeDesc;
-	// to keep track the no of byte recieved
+	// to keep track the no of byte received
 	ULONG			PrevNumRcevBytes;
 	ULONG			CurrNumRcevBytes;
 
diff --git a/drivers/staging/bcm/IPv6Protocol.c b/drivers/staging/bcm/IPv6Protocol.c
index 91b6fbe..5b4fd37 100644
--- a/drivers/staging/bcm/IPv6Protocol.c
+++ b/drivers/staging/bcm/IPv6Protocol.c
@@ -287,7 +287,7 @@ static BOOLEAN MatchSrcIpv6Address(S_CLASSIFIER_RULE *pstClassifierRule,IPV6Head
 
 	for(uiLoopIndex=0;uiLoopIndex<uiCountIPSrcAddresses;uiLoopIndex+=uiIpv6AddrNoLongWords)
 	{
-		BCM_DEBUG_PRINT( Adapter,DBG_TYPE_TX, IPV6_DBG, DBG_LVL_ALL, "\n Src Ipv6 Address In Recieved Packet : \n ");
+		BCM_DEBUG_PRINT( Adapter,DBG_TYPE_TX, IPV6_DBG, DBG_LVL_ALL, "\n Src Ipv6 Address In Received Packet : \n ");
 		DumpIpv6Address(aulSrcIP);
 		BCM_DEBUG_PRINT( Adapter,DBG_TYPE_TX, IPV6_DBG, DBG_LVL_ALL, "\n Src Ipv6 Mask In Classifier Rule: \n");
 		DumpIpv6Address(&pstClassifierRule->stSrcIpAddress.ulIpv6Mask[uiLoopIndex]);
@@ -340,7 +340,7 @@ static BOOLEAN MatchDestIpv6Address(S_CLASSIFIER_RULE *pstClassifierRule,IPV6Hea
 
 	for(uiLoopIndex=0;uiLoopIndex<uiCountIPDestinationAddresses;uiLoopIndex+=uiIpv6AddrNoLongWords)
 	{
-		BCM_DEBUG_PRINT( Adapter,DBG_TYPE_TX, IPV6_DBG, DBG_LVL_ALL, "\n Destination Ipv6 Address In Recieved Packet : \n ");
+		BCM_DEBUG_PRINT( Adapter,DBG_TYPE_TX, IPV6_DBG, DBG_LVL_ALL, "\n Destination Ipv6 Address In Received Packet : \n ");
 		DumpIpv6Address(aulDestIP);
 		BCM_DEBUG_PRINT( Adapter,DBG_TYPE_TX, IPV6_DBG, DBG_LVL_ALL, "\n Destination Ipv6 Mask In Classifier Rule: \n");
 		DumpIpv6Address(&pstClassifierRule->stDestIpAddress.ulIpv6Mask[uiLoopIndex]);
diff --git a/drivers/staging/bcm/InterfaceIdleMode.c b/drivers/staging/bcm/InterfaceIdleMode.c
index bf5c0ad..96fa4ea 100644
--- a/drivers/staging/bcm/InterfaceIdleMode.c
+++ b/drivers/staging/bcm/InterfaceIdleMode.c
@@ -11,7 +11,7 @@ Input parameters:		IN PMINI_ADAPTER Adapter   - Miniport Adapter Context
 
 
 Return:				BCM_STATUS_SUCCESS - If Wakeup of the HW Interface was successful.
-						Other           - If an error occured.
+						Other           - If an error occurred.
 */
 
 
@@ -26,7 +26,7 @@ Input parameters:		IN PMINI_ADAPTER Adapter   - Miniport Adapter Context
 
 
 Return:				BCM_STATUS_SUCCESS - If Idle mode response related HW configuration was successful.
-						Other           - If an error occured.
+						Other           - If an error occurred.
 */
 
 /*
diff --git a/drivers/staging/bcm/InterfaceIsr.c b/drivers/staging/bcm/InterfaceIsr.c
index 220ff92..67719d5 100644
--- a/drivers/staging/bcm/InterfaceIsr.c
+++ b/drivers/staging/bcm/InterfaceIsr.c
@@ -80,8 +80,8 @@ static void read_int_callback(struct urb *urb/*, struct pt_regs *regs*/)
 		}
 		case -EINPROGRESS:
 		{
-			//This situation may happend when URBunlink is used. for detail check usb_unlink_urb documentation.
-			BCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, INTF_INIT, DBG_LVL_ALL,"Impossibe condition has occured... something very bad is going on");
+			//This situation may happened when URBunlink is used. for detail check usb_unlink_urb documentation.
+			BCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, INTF_INIT, DBG_LVL_ALL,"Impossibe condition has occurred... something very bad is going on");
 			break ;
 			//return;
 		}
diff --git a/drivers/staging/bcm/InterfaceRx.c b/drivers/staging/bcm/InterfaceRx.c
index 533f8eb..806ef5d 100644
--- a/drivers/staging/bcm/InterfaceRx.c
+++ b/drivers/staging/bcm/InterfaceRx.c
@@ -34,7 +34,7 @@ GetBulkInRcb(PS_INTERFACE_ADAPTER psIntfAdapter)
 	return pRcb;
 }
 
-/*this is receive call back - when pkt avilable for receive (BULK IN- end point)*/
+/*this is receive call back - when pkt available for receive (BULK IN- end point)*/
 static void read_bulk_callback(struct urb *urb)
 {
 	struct sk_buff *skb = NULL;
@@ -123,7 +123,7 @@ static void read_bulk_callback(struct urb *urb)
 	if((ntohs(pLeader->Vcid) == VCID_CONTROL_PACKET) ||
 	    (!(pLeader->Status >= 0x20  &&  pLeader->Status <= 0x3F)))
 	{
-	    BCM_DEBUG_PRINT(psIntfAdapter->psAdapter,DBG_TYPE_RX, RX_CTRL, DBG_LVL_ALL, "Recived control pkt...");
+	    BCM_DEBUG_PRINT(psIntfAdapter->psAdapter,DBG_TYPE_RX, RX_CTRL, DBG_LVL_ALL, "Received control pkt...");
 		*(PUSHORT)skb->data = pLeader->Status;
        	memcpy(skb->data+sizeof(USHORT), urb->transfer_buffer +
 			(sizeof(LEADER)), pLeader->PLength);
@@ -142,7 +142,7 @@ static void read_bulk_callback(struct urb *urb)
 		  * Data Packet, Format a proper Ethernet Header
         	  * and give it to the stack
 		  */
-        BCM_DEBUG_PRINT(psIntfAdapter->psAdapter,DBG_TYPE_RX, RX_DATA, DBG_LVL_ALL, "Recived Data pkt...");
+        BCM_DEBUG_PRINT(psIntfAdapter->psAdapter,DBG_TYPE_RX, RX_DATA, DBG_LVL_ALL, "Received Data pkt...");
 		skb_reserve(skb, 2 + SKB_RESERVE_PHS_BYTES);
 		memcpy(skb->data+ETH_HLEN, (PUCHAR)urb->transfer_buffer + sizeof(LEADER), pLeader->PLength);
 		skb->dev = Adapter->dev;
@@ -151,7 +151,7 @@ static void read_bulk_callback(struct urb *urb)
 		skb_put (skb, pLeader->PLength + ETH_HLEN);
 		Adapter->PackInfo[QueueIndex].uiTotalRxBytes+=pLeader->PLength;
 		Adapter->PackInfo[QueueIndex].uiThisPeriodRxBytes+= pLeader->PLength;
-        BCM_DEBUG_PRINT(psIntfAdapter->psAdapter,DBG_TYPE_RX, RX_DATA, DBG_LVL_ALL, "Recived Data pkt of len :0x%X", pLeader->PLength);
+        BCM_DEBUG_PRINT(psIntfAdapter->psAdapter,DBG_TYPE_RX, RX_DATA, DBG_LVL_ALL, "Received Data pkt of len :0x%X", pLeader->PLength);
 
 		if(netif_running(Adapter->dev))
 		{
@@ -237,7 +237,7 @@ Input parameters:		IN PMINI_ADAPTER Adapter   - Miniport Adapter Context
 
 
 Return:				TRUE  - If Rx was successful.
-					Other - If an error occured.
+					Other - If an error occurred.
 */
 
 BOOLEAN InterfaceRx (PS_INTERFACE_ADAPTER psIntfAdapter)
diff --git a/drivers/staging/bcm/Ioctl.h b/drivers/staging/bcm/Ioctl.h
index e4f8eb7..f859cf1 100644
--- a/drivers/staging/bcm/Ioctl.h
+++ b/drivers/staging/bcm/Ioctl.h
@@ -241,7 +241,7 @@ typedef struct bulkwrmbuffer
 
 typedef enum _FLASH2X_SECTION_VAL
 {
-	NO_SECTION_VAL = 0, //no section is choosen when absolute offset is given for RD/WR
+	NO_SECTION_VAL = 0, //no section is chosen when absolute offset is given for RD/WR
 	ISO_IMAGE1,
 	ISO_IMAGE2,
 	DSD0,
diff --git a/drivers/staging/bcm/LeakyBucket.c b/drivers/staging/bcm/LeakyBucket.c
index f4cf41c..a55d422 100644
--- a/drivers/staging/bcm/LeakyBucket.c
+++ b/drivers/staging/bcm/LeakyBucket.c
@@ -213,7 +213,7 @@ static VOID CheckAndSendPacketFromIndex(PMINI_ADAPTER Adapter, PacketInfo *psSF)
 				BCM_DEBUG_PRINT(Adapter,DBG_TYPE_TX, TX_PACKETS, DBG_LVL_ALL, "For Queue: %zd\n", psSF-Adapter->PackInfo);
 				BCM_DEBUG_PRINT(Adapter,DBG_TYPE_TX, TX_PACKETS, DBG_LVL_ALL, "\nAvailable Tokens = %d required = %d\n",
 					psSF->uiCurrentTokenCount, iPacketLen);
-				//this part indicates that becuase of non-availability of the tokens
+				//this part indicates that because of non-availability of the tokens
 				//pkt has not been send out hence setting the pending flag indicating the host to send it out
 				//first next iteration  .
 				psSF->uiPendedLast = TRUE;
diff --git a/drivers/staging/bcm/Misc.c b/drivers/staging/bcm/Misc.c
index d624f35..c5003b6 100644
--- a/drivers/staging/bcm/Misc.c
+++ b/drivers/staging/bcm/Misc.c
@@ -602,7 +602,7 @@ VOID LinkControlResponseMessage(PMINI_ADAPTER Adapter,PUCHAR pucBuffer)
 				Adapter->LinkStatus=LINKUP_DONE;
 				Adapter->bPHSEnabled = *(pucBuffer+3);
                	Adapter->bETHCSEnabled = *(pucBuffer+4) & ETH_CS_MASK;
-				BCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0, "PHS Support Status Recieved In LinkUp Ack : %x \n",Adapter->bPHSEnabled);
+				BCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0, "PHS Support Status Received In LinkUp Ack : %x \n",Adapter->bPHSEnabled);
 				if((FALSE == Adapter->bShutStatus)&&
 					(FALSE == Adapter->IdleMode))
 				{
@@ -1153,7 +1153,7 @@ int InitCardAndDownloadFirmware(PMINI_ADAPTER ps_adapter)
 
 	/*
      * 1. If the LED Settings fails, do not stop and do the Firmware download.
-     * 2. This init would happend only if the cfg file is present, else
+     * 2. This init would happened only if the cfg file is present, else
      *    call from the ioctl context.
      */
 
@@ -1185,7 +1185,7 @@ int InitCardAndDownloadFirmware(PMINI_ADAPTER ps_adapter)
 		status = PropagateCalParamsFromFlashToMemory(ps_adapter);
 		if(status)
 		{
-			BCM_DEBUG_PRINT(ps_adapter,DBG_TYPE_INITEXIT, MP_INIT, DBG_LVL_ALL," Propogation of Cal param failed .." );
+			BCM_DEBUG_PRINT(ps_adapter,DBG_TYPE_INITEXIT, MP_INIT, DBG_LVL_ALL," Propagation of Cal param failed .." );
 			goto OUT;
 		}
 	}
diff --git a/drivers/staging/bcm/Qos.c b/drivers/staging/bcm/Qos.c
index feade94..c97020f 100644
--- a/drivers/staging/bcm/Qos.c
+++ b/drivers/staging/bcm/Qos.c
@@ -727,7 +727,7 @@ static BOOLEAN EthCSMatchVLANRules(S_CLASSIFIER_RULE *pstClassifierRule,struct s
 
 	BCM_DEBUG_PRINT(Adapter, DBG_TYPE_TX, IPV4_DBG, DBG_LVL_ALL,  "%s  CLS UserPrio:%x CLS VLANID:%x\n",__FUNCTION__,ntohs(*((USHORT *)pstClassifierRule->usUserPriority)),pstClassifierRule->usVLANID);
 
-	/* In case FW didn't recieve the TLV, the priority field should be ignored */
+	/* In case FW didn't receive the TLV, the priority field should be ignored */
 	if(pstClassifierRule->usValidityBitMap & (1<<PKT_CLASSIFICATION_USER_PRIORITY_VALID))
 	{
 		if(pstEthCsPktInfo->eNwpktEthFrameType!=eEth802QVLANFrame)
diff --git a/drivers/staging/bcm/cntrl_SignalingInterface.h b/drivers/staging/bcm/cntrl_SignalingInterface.h
index 8907784..ab13180 100644
--- a/drivers/staging/bcm/cntrl_SignalingInterface.h
+++ b/drivers/staging/bcm/cntrl_SignalingInterface.h
@@ -21,7 +21,7 @@
 #define VENDOR_PHS_PARAM_LENGTH 10
 #define MAX_NUM_ACTIVE_BS 10
 #define AUTH_TOKEN_LENGTH	10
-#define NUM_HARQ_CHANNELS	16	//Changed from 10 to 16 to accomodate all HARQ channels
+#define NUM_HARQ_CHANNELS	16	//Changed from 10 to 16 to accommodate all HARQ channels
 #define VENDOR_CLASSIFIER_PARAM_LENGTH 1 //Changed the size to 1 byte since we dnt use it
 #define  VENDOR_SPECIF_QOS_PARAM 1
 #define VENDOR_PHS_PARAM_LENGTH	10
@@ -109,13 +109,13 @@ typedef struct _stPhsRuleSI {
     B_UINT8                         u8PHSI;
 	/**  PHSF Length Of The Service Flow*/
     B_UINT8                         u8PHSFLength;
-    /** String of bytes containing header information to be supressed by the sending CS and reconstructed by the receiving CS*/
+    /** String of bytes containing header information to be suppressed by the sending CS and reconstructed by the receiving CS*/
     B_UINT8                         u8PHSF[MAX_PHS_LENGTHS];
 	/**  PHSM Length Of The Service Flow*/
     B_UINT8                         u8PHSMLength;
 	/**  PHS Mask for the SF*/
     B_UINT8                         u8PHSM[MAX_PHS_LENGTHS];
-	/**  8bit Total number of bytes to be supressed for the Service Flow*/
+	/**  8bit Total number of bytes to be suppressed for the Service Flow*/
     B_UINT8                         u8PHSS;
 	/**  8bit Indicates whether or not Packet Header contents need to be verified prior to supression */
     B_UINT8                         u8PHSV;
diff --git a/drivers/staging/bcm/nvm.c b/drivers/staging/bcm/nvm.c
index c729237..4da5b7b 100644
--- a/drivers/staging/bcm/nvm.c
+++ b/drivers/staging/bcm/nvm.c
@@ -313,7 +313,7 @@ INT ReadMacAddressFromNVM(PMINI_ADAPTER Adapter)
 //		uiNumBytes - Number of bytes to be read from the EEPROM.
 //
 // Returns:
-//		OSAL_STATUS_SUCCESS - if EEPROM read is successfull.
+//		OSAL_STATUS_SUCCESS - if EEPROM read is successful.
 //		<FAILURE>			- if failed.
 //-----------------------------------------------------------------------------
 
@@ -431,7 +431,7 @@ INT BeceemEEPROMBulkRead(
 //		uiNumBytes - Number of bytes to be read from the FLASH.
 //
 // Returns:
-//		OSAL_STATUS_SUCCESS - if FLASH read is successfull.
+//		OSAL_STATUS_SUCCESS - if FLASH read is successful.
 //		<FAILURE>			- if failed.
 //-----------------------------------------------------------------------------
 
@@ -1174,7 +1174,7 @@ static INT BeceemFlashBulkWrite(
 	if(NULL == pTempBuff)
 		goto BeceemFlashBulkWrite_EXIT;
 //
-// check if the data to be written is overlapped accross sectors
+// check if the data to be written is overlapped across sectors
 //
 	if(uiOffset+uiNumBytes < uiSectBoundary)
 	{
@@ -1390,7 +1390,7 @@ static INT BeceemFlashBulkWriteStatus(
 		goto BeceemFlashBulkWriteStatus_EXIT;
 
 //
-// check if the data to be written is overlapped accross sectors
+// check if the data to be written is overlapped across sectors
 //
 	if(uiOffset+uiNumBytes < uiSectBoundary)
 	{
@@ -2020,7 +2020,7 @@ INT BeceemEEPROMBulkWrite(
 //		uiNumBytes - Number of bytes to be read from the NVM.
 //
 // Returns:
-//		OSAL_STATUS_SUCCESS - if NVM read is successfull.
+//		OSAL_STATUS_SUCCESS - if NVM read is successful.
 //		<FAILURE>			- if failed.
 //-----------------------------------------------------------------------------
 
@@ -2083,7 +2083,7 @@ INT BeceemNVMRead(
 //		uiNumBytes - Number of bytes to be written..
 //
 // Returns:
-//		OSAL_STATUS_SUCCESS - if NVM write is successfull.
+//		OSAL_STATUS_SUCCESS - if NVM write is successful.
 //		<FAILURE>			- if failed.
 //-----------------------------------------------------------------------------
 
@@ -2218,7 +2218,7 @@ INT BeceemNVMWrite(
 //          uiSectorSize - sector size
 //
 // Returns:
-//		OSAL_STATUS_SUCCESS - if NVM write is successfull.
+//		OSAL_STATUS_SUCCESS - if NVM write is successful.
 //		<FAILURE>			- if failed.
 //-----------------------------------------------------------------------------
 
@@ -2430,7 +2430,7 @@ INT BcmInitNVM(PMINI_ADAPTER ps_adapter)
 *Input Parameter:
 *		Adapter data structure
 *Return Value :
-*		0. means sucess;
+*		0. means success;
 */
 /***************************************************************************/
 
@@ -2998,7 +2998,7 @@ INT BcmGetSectionValStartOffset(PMINI_ADAPTER Adapter, FLASH2X_SECTION_VAL eFlas
 	/*
 	*	Considering all the section for which end offset can be calculated or directly given
 	*	in CS Structure. if matching case does not exist, return STATUS_FAILURE indicating section
-	*	endoffset can't be calculated or given in CS Stucture.
+	*	endoffset can't be calculated or given in CS Structure.
 	*/
 
 	INT SectStartOffset = 0 ;
@@ -3173,7 +3173,7 @@ INT BcmGetSectionValEndOffset(PMINI_ADAPTER Adapter, FLASH2X_SECTION_VAL eFlash2
 *	@uiNumBytes : Number of Bytes for Read
 *
 *	Return value:-
-*		return true on sucess and STATUS_FAILURE on fail.
+*		return true on success and STATUS_FAILURE on fail.
 */
 
 INT BcmFlash2xBulkRead(
@@ -3241,7 +3241,7 @@ INT BcmFlash2xBulkRead(
 *	@uiNumBytes : Number of Bytes for Write
 *
 *	Return value:-
-*		return true on sucess and STATUS_FAILURE on fail.
+*		return true on success and STATUS_FAILURE on fail.
 *
 */
 
@@ -3308,7 +3308,7 @@ INT BcmFlash2xBulkWrite(
 *	@Adapter :-Drivers private Data Structure
 *
 *	Return Value:-
-*		Return STATUS_SUCESS if get sucess in setting the right DSD else negaive error code
+*		Return STATUS_SUCESS if get success in setting the right DSD else negaive error code
 *
 **/
 static INT BcmGetActiveDSD(PMINI_ADAPTER Adapter)
@@ -3384,7 +3384,7 @@ static INT BcmGetActiveISO(PMINI_ADAPTER Adapter)
 *	@uiOffset : Offset provided in the Flash
 *
 *	Return Value:-
-*	Sucess:-TRUE ,  offset is writable
+*	Success:-TRUE ,  offset is writable
 *	Failure:-FALSE, offset is RO
 *
 **/
@@ -3441,7 +3441,7 @@ static INT BcmDumpFlash2xSectionBitMap(PFLASH2X_BITMAP psFlash2xBitMap)
 	@Adapter:-Driver private Data Structure
 *
 *	Return value:-
-*	Sucess:- STATUS_SUCESS
+*	Success:- STATUS_SUCESS
 *	Failure:- negative error code
 **/
 
@@ -3783,7 +3783,7 @@ INT BcmSetActiveSection(PMINI_ADAPTER Adapter, FLASH2X_SECTION_VAL eFlash2xSectV
 					// This is a SPECIAL Case which will only happen if the current highest priority ISO has priority value = 0x7FFFFFFF.
 					// We will write 1 to the current Highest priority ISO And then shall increase the priority of the requested ISO
 					// by user
-					BCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, NVM_RW, DBG_LVL_ALL, "SectImagePriority wraparound happend, eFlash2xSectVal: 0x%x\n",eFlash2xSectVal);
+					BCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, NVM_RW, DBG_LVL_ALL, "SectImagePriority wraparound happened, eFlash2xSectVal: 0x%x\n",eFlash2xSectVal);
 					SectImagePriority = htonl(0x1);
 					Status = BcmFlash2xBulkWrite(Adapter,
 								&SectImagePriority,
@@ -3853,7 +3853,7 @@ INT BcmSetActiveSection(PMINI_ADAPTER Adapter, FLASH2X_SECTION_VAL eFlash2xSectV
 					// This is a SPECIAL Case which will only happen if the current highest priority DSD has priority value = 0x7FFFFFFF.
 					// We will write 1 to the current Highest priority DSD And then shall increase the priority of the requested DSD
 					// by user
-					BCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, NVM_RW, DBG_LVL_ALL, "SectImagePriority wraparound happend, eFlash2xSectVal: 0x%x\n",eFlash2xSectVal);
+					BCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, NVM_RW, DBG_LVL_ALL, "SectImagePriority wraparound happened, eFlash2xSectVal: 0x%x\n",eFlash2xSectVal);
 					SectImagePriority = htonl(0x1);
 
 					Status = BcmFlash2xBulkWrite(Adapter,
@@ -4119,7 +4119,7 @@ INT BcmCopyISO(PMINI_ADAPTER Adapter, FLASH2X_COPY_SECTION sCopySectStrut)
 												MAX_RW_SIZE);
 				IsThisHeaderSector = FALSE ;
 			}
-			//substracting the written Data
+			//subtracting the written Data
 			uiTotalDataToCopy = uiTotalDataToCopy - Adapter->uiSectorSize ;
 		}
 
@@ -4250,7 +4250,7 @@ INT BcmCopyISO(PMINI_ADAPTER Adapter, FLASH2X_COPY_SECTION sCopySectStrut)
 				IsThisHeaderSector = FALSE ;
 			}
 
-			//substracting the written Data
+			//subtracting the written Data
 			uiTotalDataToCopy = uiTotalDataToCopy - Adapter->uiSectorSize ;
 		}
 
@@ -4268,7 +4268,7 @@ BcmFlash2xCorruptSig : this API is used to corrupt the written sig in Bcm Header
 @eFlash2xSectionVal :- Flash section val which has header
 
 Return Value :-
-	Sucess :- If Section is present and writable, corrupt the sig and return STATUS_SUCCESS
+	Success :- If Section is present and writable, corrupt the sig and return STATUS_SUCCESS
 	Failure :-Return negative error code
 
 
@@ -4301,7 +4301,7 @@ BcmFlash2xWriteSig :-this API is used to Write the sig if requested Section has
 @eFlashSectionVal :- Flash section val which has header
 
 Return Value :-
-	Sucess :- If Section is present and writable write the sig and return STATUS_SUCCESS
+	Success :- If Section is present and writable write the sig and return STATUS_SUCCESS
 	Failure :-Return negative error code
 
 **/
@@ -4504,7 +4504,7 @@ BcmCopySection :- This API is used to copy the One section in another. Both sect
 			     in case of numofBytes  equal zero complete section will be copied.
 
 Return Values-
-	Sucess : Return STATUS_SUCCESS
+	Success : Return STATUS_SUCCESS
 	Faillure :- return negative error code
 
 **/
@@ -4621,7 +4621,7 @@ SaveHeaderIfPresent :- This API is use to Protect the Header in case of Header S
 @uiOffset :- Flash offset that has to be written.
 
 Return value :-
-	Sucess :- On sucess return STATUS_SUCCESS
+	Success :- On success return STATUS_SUCCESS
 	Faillure :- Return negative error code
 
 **/
@@ -4634,7 +4634,7 @@ INT SaveHeaderIfPresent(PMINI_ADAPTER Adapter, PUCHAR pBuff, UINT uiOffset)
 	UINT uiSectAlignAddr = 0;
 	UINT sig = 0;
 
-	//making the offset sector alligned
+	//making the offset sector aligned
 	uiSectAlignAddr = uiOffset & ~(Adapter->uiSectorSize - 1);
 
 
@@ -4643,7 +4643,7 @@ INT SaveHeaderIfPresent(PMINI_ADAPTER Adapter, PUCHAR pBuff, UINT uiOffset)
 	(uiSectAlignAddr == BcmGetSectionValEndOffset(Adapter,DSD0)- Adapter->uiSectorSize))
 	{
 
-		//offset from the sector boundry having the header map
+		//offset from the sector boundary having the header map
 		offsetToProtect = Adapter->psFlash2xCSInfo->OffsetFromDSDStartForDSDHeader % Adapter->uiSectorSize;
 		HeaderSizeToProtect = sizeof(DSD_HEADER);
 		bHasHeader = TRUE ;
@@ -4697,7 +4697,7 @@ BcmDoChipSelect : This will selcet the appropriate chip for writing.
 @Adapater :- Bcm Driver Private Data Structure
 
 OutPut:-
-	Select the Appropriate chip and retrn status Sucess
+	Select the Appropriate chip and retrn status Success
 **/
 static INT BcmDoChipSelect(PMINI_ADAPTER Adapter, UINT offset)
 {
@@ -5086,7 +5086,7 @@ static INT CorruptDSDSig(PMINI_ADAPTER Adapter, FLASH2X_SECTION_VAL eFlash2xSect
 	{
 		if(IsSectionWritable(Adapter,eFlash2xSectionVal) != TRUE)
 		{
-			BCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,"Section is not Writable...Hence cant Corrupt signature");
+			BCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,"Section is not Writable...Hence can't Corrupt signature");
 			return SECTOR_IS_NOT_WRITABLE;
 		}
 	}
@@ -5155,7 +5155,7 @@ static INT CorruptISOSig(PMINI_ADAPTER Adapter, FLASH2X_SECTION_VAL eFlash2xSect
 
 	if(IsSectionWritable(Adapter,eFlash2xSectionVal) != TRUE)
 	{
-		BCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,"Section is not Writable...Hence cant Corrupt signature");
+		BCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,"Section is not Writable...Hence can't Corrupt signature");
 		return SECTOR_IS_NOT_WRITABLE;
 	}
 
diff --git a/drivers/staging/brcm80211/README b/drivers/staging/brcm80211/README
index 99e6766..f8facb0 100644
--- a/drivers/staging/brcm80211/README
+++ b/drivers/staging/brcm80211/README
@@ -71,7 +71,7 @@ the driver. The devices use a single worldwide regulatory domain, with channels
 passive operation. Transmission on those channels is suppressed until
 appropriate other traffic is observed on those channels.
 
-Within the driver, we use the ficticious country code "X2" to represent this
+Within the driver, we use the fictitious country code "X2" to represent this
 worldwide regulatory domain. There is currently no interface to configure a
 different domain.
 
diff --git a/drivers/staging/brcm80211/brcmfmac/bcmsdh_sdmmc.c b/drivers/staging/brcm80211/brcmfmac/bcmsdh_sdmmc.c
index 65313fa..71c3571 100644
--- a/drivers/staging/brcm80211/brcmfmac/bcmsdh_sdmmc.c
+++ b/drivers/staging/brcm80211/brcmfmac/bcmsdh_sdmmc.c
@@ -264,7 +264,7 @@ extern SDIOH_API_RC sdioh_disable_func_intr(void)
 }
 #endif				/* defined(OOB_INTR_ONLY) && defined(HW_OOB) */
 
-/* Configure callback to client when we recieve client interrupt */
+/* Configure callback to client when we receive client interrupt */
 extern SDIOH_API_RC
 sdioh_interrupt_register(sdioh_info_t *sd, sdioh_cb_fn_t fn, void *argh)
 {
diff --git a/drivers/staging/brcm80211/brcmfmac/dhd_custom_gpio.c b/drivers/staging/brcm80211/brcmfmac/dhd_custom_gpio.c
index cbfa1c1..1cf6c5d 100644
--- a/drivers/staging/brcm80211/brcmfmac/dhd_custom_gpio.c
+++ b/drivers/staging/brcm80211/brcmfmac/dhd_custom_gpio.c
@@ -46,7 +46,7 @@ extern int sdioh_mmc_irq(int irq);
 #include <mach/gpio.h>
 #endif
 
-/* Customer specific Host GPIO defintion  */
+/* Customer specific Host GPIO definition  */
 static int dhd_oob_gpio_num = -1;	/* GG 19 */
 
 module_param(dhd_oob_gpio_num, int, 0644);
diff --git a/drivers/staging/brcm80211/brcmfmac/dhd_linux.c b/drivers/staging/brcm80211/brcmfmac/dhd_linux.c
index 02c6d44..dd03757 100644
--- a/drivers/staging/brcm80211/brcmfmac/dhd_linux.c
+++ b/drivers/staging/brcm80211/brcmfmac/dhd_linux.c
@@ -478,7 +478,7 @@ static int dhd_set_suspend(int value, dhd_pub_t *dhd)
 			dhd_set_packet_filter(1, dhd);
 
 			/* if dtim skip setup as default force it
-			 * to wake each thrid dtim
+			 * to wake each third dtim
 			 * for better power saving.
 			 * Note that side effect is chance to miss BC/MC
 			 * packet
diff --git a/drivers/staging/brcm80211/brcmfmac/dhd_sdio.c b/drivers/staging/brcm80211/brcmfmac/dhd_sdio.c
index 1066270..464f52a 100644
--- a/drivers/staging/brcm80211/brcmfmac/dhd_sdio.c
+++ b/drivers/staging/brcm80211/brcmfmac/dhd_sdio.c
@@ -3659,7 +3659,7 @@ static uint dhdsdio_readframes(dhd_bus_t *bus, uint maxframes, bool *finished)
 			 * control pkt receives.
 			 * Later we use buffer-poll for data as well
 			 * as control packets.
-			 * This is required becuase dhd receives full
+			 * This is required because dhd receives full
 			 * frame in gSPI unlike SDIO.
 			 * After the frame is received we have to
 			 * distinguish whether it is data
@@ -3744,7 +3744,7 @@ static uint dhdsdio_readframes(dhd_bus_t *bus, uint maxframes, bool *finished)
 					bus->dhd->rx_errors++;
 					dhd_os_sdunlock_rxq(bus->dhd);
 					/* Force retry w/normal header read.
-					 * Don't attemp NAK for
+					 * Don't attempt NAK for
 					 * gSPI
 					 */
 					dhdsdio_rxfail(bus, true,
diff --git a/drivers/staging/brcm80211/brcmsmac/wl_mac80211.c b/drivers/staging/brcm80211/brcmsmac/wl_mac80211.c
index 774b4e9..c1b07ae 100644
--- a/drivers/staging/brcm80211/brcmsmac/wl_mac80211.c
+++ b/drivers/staging/brcm80211/brcmsmac/wl_mac80211.c
@@ -1079,7 +1079,7 @@ static int ieee_hw_init(struct ieee80211_hw *hw)
 	 */
 	hw->max_rates = 2;	/* Primary rate and 1 fallback rate */
 
-	hw->channel_change_time = 7 * 1000;	/* channel change time is dependant on chip and band  */
+	hw->channel_change_time = 7 * 1000;	/* channel change time is dependent on chip and band  */
 	hw->wiphy->interface_modes = BIT(NL80211_IFTYPE_STATION);
 
 	hw->rate_control_algorithm = "minstrel_ht";
diff --git a/drivers/staging/brcm80211/brcmsmac/wlc_ampdu.c b/drivers/staging/brcm80211/brcmsmac/wlc_ampdu.c
index c6cdcd9..f008659 100644
--- a/drivers/staging/brcm80211/brcmsmac/wlc_ampdu.c
+++ b/drivers/staging/brcm80211/brcmsmac/wlc_ampdu.c
@@ -89,7 +89,7 @@ u32 wl_ampdu_dbg =
 /* structure to hold tx fifo information and pre-loading state
  * counters specific to tx underflows of ampdus
  * some counters might be redundant with the ones in wlc or ampdu structures.
- * This allows to maintain a specific state independantly of
+ * This allows to maintain a specific state independently of
  * how often and/or when the wlc counters are updated.
  */
 typedef struct wlc_fifo_info {
@@ -265,7 +265,7 @@ static void scb_ampdu_update_config(struct ampdu_info *ampdu, struct scb *scb)
 
 	scb_ampdu->max_pdu = (u8) ampdu->wlc->pub->tunables->ampdunummpdu;
 
-	/* go back to legacy size if some preloading is occuring */
+	/* go back to legacy size if some preloading is occurring */
 	for (i = 0; i < NUM_FFPLD_FIFO; i++) {
 		if (ampdu->fifo_tb[i].ampdu_pld_size > FFPLD_PLD_INCR)
 			scb_ampdu->max_pdu = AMPDU_NUM_MPDU_LEGACY;
@@ -406,7 +406,7 @@ static int wlc_ffpld_check_txfunfl(struct wlc_info *wlc, int fid)
 		/*
 		   compute a new dma xfer rate for max_mpdu @ max mcs.
 		   This is the minimum dma rate that
-		   can acheive no unferflow condition for the current mpdu size.
+		   can achieve no unferflow condition for the current mpdu size.
 		 */
 		/* note : we divide/multiply by 100 to avoid integer overflows */
 		fifo->dmaxferrate =
diff --git a/drivers/staging/brcm80211/brcmsmac/wlc_bmac.c b/drivers/staging/brcm80211/brcmsmac/wlc_bmac.c
index 5a96dc3..4b6e181 100644
--- a/drivers/staging/brcm80211/brcmsmac/wlc_bmac.c
+++ b/drivers/staging/brcm80211/brcmsmac/wlc_bmac.c
@@ -1915,7 +1915,7 @@ void wlc_bmac_phy_reset(struct wlc_hw_info *wlc_hw)
 
 	phy_bw_clkbits = wlc_phy_clk_bwbits(wlc_hw->band->pi);
 
-	/* Specfic reset sequence required for NPHY rev 3 and 4 */
+	/* Specific reset sequence required for NPHY rev 3 and 4 */
 	if (WLCISNPHY(wlc_hw->band) && NREV_GE(wlc_hw->band->phyrev, 3) &&
 	    NREV_LE(wlc_hw->band->phyrev, 4)) {
 		/* Set the PHY bandwidth */
diff --git a/drivers/staging/brcm80211/brcmsmac/wlc_main.c b/drivers/staging/brcm80211/brcmsmac/wlc_main.c
index 639b5d7..ab7ab85 100644
--- a/drivers/staging/brcm80211/brcmsmac/wlc_main.c
+++ b/drivers/staging/brcm80211/brcmsmac/wlc_main.c
@@ -6283,7 +6283,7 @@ wlc_d11hdrs_mac80211(struct wlc_info *wlc, struct ieee80211_hw *hw,
 	       ((preamble_type[1] == WLC_MM_PREAMBLE) ==
 		(txh->MModeFbrLen != 0)));
 
-	ac = wme_fifo2ac[queue];
+	ac = skb_get_queue_mapping(p);
 	if (SCB_WME(scb) && qos && wlc->edcf_txop[ac]) {
 		uint frag_dur, dur, dur_fallback;
 
@@ -6919,8 +6919,7 @@ prep_mac80211_status(struct wlc_info *wlc, d11rxhdr_t *rxh, struct sk_buff *p,
 		preamble = 0;
 		if (IS_CCK(rspec)) {
 			if (rxh->PhyRxStatus_0 & PRXS0_SHORTH)
-				WL_ERROR("Short CCK\n");
-			rx_status->flag |= RX_FLAG_SHORTPRE;
+				rx_status->flag |= RX_FLAG_SHORTPRE;
 		} else if (IS_OFDM(rspec)) {
 			rx_status->flag |= RX_FLAG_SHORTPRE;
 		} else {
@@ -7079,10 +7078,8 @@ void BCMFASTPATH wlc_recv(struct wlc_info *wlc, struct sk_buff *p)
 	if (ieee80211_is_probe_req(h->frame_control))
 		goto toss;
 
-	if (is_amsdu) {
-		WL_ERROR("%s: is_amsdu causing toss\n", __func__);
+	if (is_amsdu)
 		goto toss;
-	}
 
 	wlc_recvctl(wlc, rxh, p);
 	return;
@@ -8295,7 +8292,7 @@ wlc_txflowcontrol_prio_isset(struct wlc_info *wlc, struct wlc_txq_info *q,
 	return (q->stopped & prio_mask) == prio_mask;
 }
 
-/* propogate the flow control to all interfaces using the given tx queue */
+/* propagate the flow control to all interfaces using the given tx queue */
 void wlc_txflowcontrol(struct wlc_info *wlc, struct wlc_txq_info *qi,
 		       bool on, int prio)
 {
@@ -8462,7 +8459,7 @@ static void wlc_txq_free(struct wlc_info *wlc, struct wlc_txq_info *qi)
 }
 
 /*
- * Flag 'scan in progress' to withold dynamic phy calibration
+ * Flag 'scan in progress' to withhold dynamic phy calibration
  */
 void wlc_scan_start(struct wlc_info *wlc)
 {
diff --git a/drivers/staging/brcm80211/brcmsmac/wlc_rate.c b/drivers/staging/brcm80211/brcmsmac/wlc_rate.c
index 0cfa360..d284f1a 100644
--- a/drivers/staging/brcm80211/brcmsmac/wlc_rate.c
+++ b/drivers/staging/brcm80211/brcmsmac/wlc_rate.c
@@ -332,7 +332,7 @@ wlc_rate_hwrs_filter_sort_validate(wlc_rateset_t *rs,
 		return false;
 }
 
-/* caluclate the rate of a rx'd frame and return it as a ratespec */
+/* calculate the rate of a rx'd frame and return it as a ratespec */
 ratespec_t BCMFASTPATH wlc_compute_rspec(d11rxhdr_t *rxh, u8 *plcp)
 {
 	int phy_type;
diff --git a/drivers/staging/brcm80211/include/bcmsrom_fmt.h b/drivers/staging/brcm80211/include/bcmsrom_fmt.h
index ae2bff8..4768968 100644
--- a/drivers/staging/brcm80211/include/bcmsrom_fmt.h
+++ b/drivers/staging/brcm80211/include/bcmsrom_fmt.h
@@ -103,7 +103,7 @@
 
 #define	SROM_CRCREV		63
 
-/* SROM Rev 4: Reallocate the software part of the srom to accomodate
+/* SROM Rev 4: Reallocate the software part of the srom to accommodate
  * MIMO features. It assumes up to two PCIE functions and 440 bytes
  * of useable srom i.e. the useable storage in chips with OTP that
  * implements hardware redundancy.
diff --git a/drivers/staging/brcm80211/include/hndsoc.h b/drivers/staging/brcm80211/include/hndsoc.h
index 9747cc4..6435686 100644
--- a/drivers/staging/brcm80211/include/hndsoc.h
+++ b/drivers/staging/brcm80211/include/hndsoc.h
@@ -181,7 +181,7 @@
  * conventions for the use the flash space:
  */
 
-/* Minumum amount of flash we support */
+/* Minimum amount of flash we support */
 #define FLASH_MIN		0x00020000	/* Minimum flash size */
 
 /* A boot/binary may have an embedded block that describes its size  */
diff --git a/drivers/staging/brcm80211/util/bcmotp.c b/drivers/staging/brcm80211/util/bcmotp.c
index ba71c10..1799121 100644
--- a/drivers/staging/brcm80211/util/bcmotp.c
+++ b/drivers/staging/brcm80211/util/bcmotp.c
@@ -213,7 +213,7 @@ static u16 ipxotp_read_bit(void *oh, chipcregs_t *cc, uint off)
 	return (int)st;
 }
 
-/* Calculate max HW/SW region byte size by substracting fuse region and checksum size,
+/* Calculate max HW/SW region byte size by subtracting fuse region and checksum size,
  * osizew is oi->wsize (OTP size - GU size) in words
  */
 static int ipxotp_max_rgnsz(si_t *sih, int osizew)
@@ -229,7 +229,7 @@ static int ipxotp_max_rgnsz(si_t *sih, int osizew)
 		ret = osizew * 2 - OTP_SZ_FU_72 - OTP_SZ_CHECKSUM;
 		break;
 	default:
-		ASSERT(0);	/* Don't konw about this chip */
+		ASSERT(0);	/* Don't know about this chip */
 	}
 
 	return ret;
diff --git a/drivers/staging/brcm80211/util/bcmsrom.c b/drivers/staging/brcm80211/util/bcmsrom.c
index eca35b9..850bfa6 100644
--- a/drivers/staging/brcm80211/util/bcmsrom.c
+++ b/drivers/staging/brcm80211/util/bcmsrom.c
@@ -1859,7 +1859,7 @@ static int initvars_srom_pci(si_t *sih, void *curmap, char **vars, uint *count)
 
 	/*
 	 * Apply CRC over SROM content regardless SROM is present or not,
-	 * and use variable <devpath>sromrev's existance in flash to decide
+	 * and use variable <devpath>sromrev's existence in flash to decide
 	 * if we should return an error when CRC fails or read SROM variables
 	 * from flash.
 	 */
diff --git a/drivers/staging/brcm80211/util/hnddma.c b/drivers/staging/brcm80211/util/hnddma.c
index 8a81eb9..be339fe 100644
--- a/drivers/staging/brcm80211/util/hnddma.c
+++ b/drivers/staging/brcm80211/util/hnddma.c
@@ -1179,7 +1179,7 @@ static void BCMFASTPATH dma64_txreclaim(dma_info_t *di, txd_range_t range)
 		   (range == HNDDMA_RANGE_ALL) ? "all" :
 		   ((range ==
 		     HNDDMA_RANGE_TRANSMITTED) ? "transmitted" :
-		    "transfered")));
+		    "transferred")));
 
 	if (di->txin == di->txout)
 		return;
@@ -1549,7 +1549,7 @@ static int BCMFASTPATH dma64_txfast(dma_info_t *di, struct sk_buff *p0,
  * If range is HNDDMA_RANGE_TRANSMITTED, reclaim descriptors that have be
  * transmitted as noted by the hardware "CurrDescr" pointer.
  * If range is HNDDMA_RANGE_TRANSFERED, reclaim descriptors that have be
- * transfered by the DMA as noted by the hardware "ActiveDescr" pointer.
+ * transferred by the DMA as noted by the hardware "ActiveDescr" pointer.
  * If range is HNDDMA_RANGE_ALL, reclaim all txd(s) posted to the ring and
  * return associated packet regardless of the value of hardware pointers.
  */
@@ -1563,7 +1563,7 @@ static void *BCMFASTPATH dma64_getnexttxp(dma_info_t *di, txd_range_t range)
 		   (range == HNDDMA_RANGE_ALL) ? "all" :
 		   ((range ==
 		     HNDDMA_RANGE_TRANSMITTED) ? "transmitted" :
-		    "transfered")));
+		    "transferred")));
 
 	if (di->ntxd == 0)
 		return NULL;
diff --git a/drivers/staging/brcm80211/util/sbpcmcia.h b/drivers/staging/brcm80211/util/sbpcmcia.h
index 6b9923f5..d4c1565 100644
--- a/drivers/staging/brcm80211/util/sbpcmcia.h
+++ b/drivers/staging/brcm80211/util/sbpcmcia.h
@@ -109,7 +109,7 @@
 #define	CISTPL_CFTABLE		0x1b	/* Config table entry */
 #define	CISTPL_END		0xff	/* End of the CIS tuple chain */
 
-/* Function identifier provides context for the function extentions tuple */
+/* Function identifier provides context for the function extensions tuple */
 #define CISTPL_FID_SDIO		0x0c	/* Extensions defined by SDIO spec */
 
 /* Function extensions for LANs (assumed for extensions other than SDIO) */
diff --git a/drivers/staging/brcm80211/util/siutils.c b/drivers/staging/brcm80211/util/siutils.c
index ed168ce..6ebd7f5 100644
--- a/drivers/staging/brcm80211/util/siutils.c
+++ b/drivers/staging/brcm80211/util/siutils.c
@@ -1319,7 +1319,7 @@ int si_clkctl_xtal(si_t *sih, uint what, bool on)
 }
 
 /*
- *  clock control policy function throught chipcommon
+ *  clock control policy function through chipcommon
  *
  *    set dynamic clk control mode (forceslow, forcefast, dynamic)
  *    returns true if we are forcing fast clock
diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index a4ceb29..e7e72b8 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -2064,7 +2064,7 @@ void comedi_event(struct comedi_device *dev, struct comedi_subdevice *s)
 			     COMEDI_CB_OVERFLOW)) {
 		runflags_mask |= SRF_RUNNING;
 	}
-	/* remember if an error event has occured, so an error
+	/* remember if an error event has occurred, so an error
 	 * can be returned the next time the user does a read() */
 	if (s->async->events & (COMEDI_CB_ERROR | COMEDI_CB_OVERFLOW)) {
 		runflags_mask |= SRF_ERROR;
diff --git a/drivers/staging/comedi/drivers/addi-data/APCI1710_Chrono.c b/drivers/staging/comedi/drivers/addi-data/APCI1710_Chrono.c
index 644bda4..482a412 100644
--- a/drivers/staging/comedi/drivers/addi-data/APCI1710_Chrono.c
+++ b/drivers/staging/comedi/drivers/addi-data/APCI1710_Chrono.c
@@ -124,9 +124,9 @@ You should also find the complete GPL in the COPYING file accompanying this sour
 |                     -5: The selected PCI input clock is wrong              |
 |                     -6: Timing unity selection is wrong                    |
 |                     -7: Base timing selection is wrong                     |
-|                     -8: You can not used the 40MHz clock selection wich    |
+|                     -8: You can not used the 40MHz clock selection with    |
 |                         this board                                         |
-|                     -9: You can not used the 40MHz clock selection wich    |
+|                     -9: You can not used the 40MHz clock selection with    |
 |                         this CHRONOS version                               |
 +----------------------------------------------------------------------------+
 */
@@ -721,10 +721,10 @@ int i_APCI1710_InsnConfigInitChrono(struct comedi_device *dev, struct comedi_sub
 								}
 							} else {
 			     /**************************************************************/
-								/* You can not used the 40MHz clock selection wich this board */
+								/* You can not use the 40MHz clock selection with this board */
 			     /**************************************************************/
 
-								DPRINTK("You can not used the 40MHz clock selection wich this board\n");
+								DPRINTK("You can not used the 40MHz clock selection with this board\n");
 								i_ReturnValue =
 									-8;
 							}
diff --git a/drivers/staging/comedi/drivers/addi-data/addi_amcc_S5920.c b/drivers/staging/comedi/drivers/addi-data/addi_amcc_S5920.c
index 90e71e1..b973095 100644
--- a/drivers/staging/comedi/drivers/addi-data/addi_amcc_S5920.c
+++ b/drivers/staging/comedi/drivers/addi-data/addi_amcc_S5920.c
@@ -59,7 +59,7 @@ You should also find the complete GPL in the COPYING file accompanying this sour
 /*+----------------------------------------------------------------------------+*/
 /*| Input Parameters  : int    i_NbOfWordsToRead : Nbr. of word to read        |*/
 /*|                     unsigned int dw_PCIBoardEepromAddress : Address of the eeprom |*/
-/*|                     unsigned short   w_EepromStartAddress : Eeprom strat address     |*/
+/*|                     unsigned short   w_EepromStartAddress : Eeprom start address     |*/
 /*+----------------------------------------------------------------------------+*/
 /*| Output Parameters : unsigned short * pw_DataRead : Read data                          |*/
 /*+----------------------------------------------------------------------------+*/
diff --git a/drivers/staging/comedi/drivers/addi-data/hwdrv_apci2032.c b/drivers/staging/comedi/drivers/addi-data/hwdrv_apci2032.c
index 9dd857d..002297d 100644
--- a/drivers/staging/comedi/drivers/addi-data/hwdrv_apci2032.c
+++ b/drivers/staging/comedi/drivers/addi-data/hwdrv_apci2032.c
@@ -498,7 +498,7 @@ void v_APCI2032_Interrupt(int irq, void *d)
 	struct comedi_device *dev = d;
 	unsigned int ui_DO;
 
-	ui_DO = inl(devpriv->iobase + APCI2032_DIGITAL_OP_IRQ) & 0x1;	/* Check if VCC OR CC interrupt has occured. */
+	ui_DO = inl(devpriv->iobase + APCI2032_DIGITAL_OP_IRQ) & 0x1;	/* Check if VCC OR CC interrupt has occurred. */
 
 	if (ui_DO == 0) {
 		printk("\nInterrupt from unKnown source\n");
diff --git a/drivers/staging/comedi/drivers/addi-data/hwdrv_apci3120.c b/drivers/staging/comedi/drivers/addi-data/hwdrv_apci3120.c
index a813fdb..fc61214 100644
--- a/drivers/staging/comedi/drivers/addi-data/hwdrv_apci3120.c
+++ b/drivers/staging/comedi/drivers/addi-data/hwdrv_apci3120.c
@@ -148,7 +148,7 @@ int i_APCI3120_InsnReadAnalogInput(struct comedi_device *dev, struct comedi_subd
 	unsigned short us_ConvertTiming, us_TmpValue, i;
 	unsigned char b_Tmp;
 
-	/*  fix convertion time to 10 us */
+	/*  fix conversion time to 10 us */
 	if (!devpriv->ui_EocEosConversionTime) {
 		printk("No timer0 Value using 10 us\n");
 		us_ConvertTiming = 10;
@@ -251,7 +251,7 @@ int i_APCI3120_InsnReadAnalogInput(struct comedi_device *dev, struct comedi_subd
 				APCI3120_SELECT_TIMER_0_WORD;
 			outb(b_Tmp, devpriv->iobase + APCI3120_TIMER_CRT0);
 
-			/* Set the convertion time */
+			/* Set the conversion time */
 			outw(us_ConvertTiming,
 				devpriv->iobase + APCI3120_TIMER_VALUE);
 
@@ -311,7 +311,7 @@ int i_APCI3120_InsnReadAnalogInput(struct comedi_device *dev, struct comedi_subd
 				APCI3120_SELECT_TIMER_0_WORD;
 			outb(b_Tmp, devpriv->iobase + APCI3120_TIMER_CRT0);
 
-			/* Set the convertion time */
+			/* Set the conversion time */
 			outw(us_ConvertTiming,
 				devpriv->iobase + APCI3120_TIMER_VALUE);
 
@@ -354,9 +354,9 @@ int i_APCI3120_InsnReadAnalogInput(struct comedi_device *dev, struct comedi_subd
 			/* Start conversion */
 			outw(0, devpriv->iobase + APCI3120_START_CONVERSION);
 
-			/* Waiting of end of convertion if interrupt is not installed */
+			/* Waiting of end of conversion if interrupt is not installed */
 			if (devpriv->b_EocEosInterrupt == APCI3120_DISABLE) {
-				/* Waiting the end of convertion */
+				/* Waiting the end of conversion */
 				do {
 					us_TmpValue =
 						inw(devpriv->iobase +
@@ -854,7 +854,7 @@ int i_APCI3120_CyclicAnalogInput(int mode, struct comedi_device *dev,
 				b_DigitalOutputRegister) & 0xF0) |
 			APCI3120_SELECT_TIMER_0_WORD;
 		outb(b_Tmp, dev->iobase + APCI3120_TIMER_CRT0);
-		/* Set the convertion time */
+		/* Set the conversion time */
 		outw(((unsigned short) ui_TimerValue0),
 			dev->iobase + APCI3120_TIMER_VALUE);
 		break;
@@ -872,7 +872,7 @@ int i_APCI3120_CyclicAnalogInput(int mode, struct comedi_device *dev,
 				b_DigitalOutputRegister) & 0xF0) |
 			APCI3120_SELECT_TIMER_1_WORD;
 		outb(b_Tmp, dev->iobase + APCI3120_TIMER_CRT0);
-		/* Set the convertion time */
+		/* Set the conversion time */
 		outw(((unsigned short) ui_TimerValue1),
 			dev->iobase + APCI3120_TIMER_VALUE);
 
@@ -889,7 +889,7 @@ int i_APCI3120_CyclicAnalogInput(int mode, struct comedi_device *dev,
 			APCI3120_SELECT_TIMER_0_WORD;
 		outb(b_Tmp, dev->iobase + APCI3120_TIMER_CRT0);
 
-		/* Set the convertion time */
+		/* Set the conversion time */
 		outw(((unsigned short) ui_TimerValue0),
 			dev->iobase + APCI3120_TIMER_VALUE);
 		break;
@@ -1104,7 +1104,7 @@ int i_APCI3120_CyclicAnalogInput(int mode, struct comedi_device *dev,
 
 /*
  * 4
- * amount of bytes to be transfered set transfer count used ADDON
+ * amount of bytes to be transferred set transfer count used ADDON
  * MWTC register commented testing
  * outl(devpriv->ui_DmaBufferUsesize[0],
  * devpriv->i_IobaseAddon+AMCC_OP_REG_AMWTC);
diff --git a/drivers/staging/comedi/drivers/addi-data/hwdrv_apci3120.h b/drivers/staging/comedi/drivers/addi-data/hwdrv_apci3120.h
index b3c8197..50eb0a0 100644
--- a/drivers/staging/comedi/drivers/addi-data/hwdrv_apci3120.h
+++ b/drivers/staging/comedi/drivers/addi-data/hwdrv_apci3120.h
@@ -169,7 +169,7 @@ struct str_AnalogReadInformation {
 
 	unsigned char b_Type;		/* EOC or EOS */
 	unsigned char b_InterruptFlag;	/* Interrupt use or not                    */
-	unsigned int ui_ConvertTiming;	/* Selection of the convertion time        */
+	unsigned int ui_ConvertTiming;	/* Selection of the conversion time        */
 	unsigned char b_NbrOfChannel;	/* Number of channel to read               */
 	unsigned int ui_ChannelList[MAX_ANALOGINPUT_CHANNELS];	/* Number of the channel to be read        */
 	unsigned int ui_RangeList[MAX_ANALOGINPUT_CHANNELS];	/* Gain of each channel                    */
diff --git a/drivers/staging/comedi/drivers/addi-data/hwdrv_apci3200.c b/drivers/staging/comedi/drivers/addi-data/hwdrv_apci3200.c
index a93e234..c75a1a1 100644
--- a/drivers/staging/comedi/drivers/addi-data/hwdrv_apci3200.c
+++ b/drivers/staging/comedi/drivers/addi-data/hwdrv_apci3200.c
@@ -103,7 +103,7 @@ struct str_BoardInfos s_BoardInfos[100];	/*  100 will be the max number of board
 /*+----------------------------------------------------------------------------+*/
 /*| Input Parameters  : int    i_NbOfWordsToRead : Nbr. of word to read        |*/
 /*|                     unsigned int dw_PCIBoardEepromAddress : Address of the eeprom |*/
-/*|                     unsigned short   w_EepromStartAddress : Eeprom strat address     |*/
+/*|                     unsigned short   w_EepromStartAddress : Eeprom start address     |*/
 /*+----------------------------------------------------------------------------+*/
 /*| Output Parameters : unsigned short * pw_DataRead : Read data                          |*/
 /*+----------------------------------------------------------------------------+*/
@@ -849,7 +849,7 @@ int i_APCI3200_ReadDigitalOutput(struct comedi_device *dev, struct comedi_subdev
   |                                             0:Single Read
   |                                             1:Read more channel
   2:Single scan
-  |                                             3:Continous Scan
+  |                                             3:Continuous Scan
   data[13]          :Number of channels to read
   |                          data[14]          :RTD connection type
   :0:RTD not used
diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 766103c..632d5d0 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -23,7 +23,7 @@ For AI:
 - If cmd->scan_begin_src=TRIG_EXT then trigger input is TGIN (pin 46).
 - If cmd->convert_src=TRIG_EXT then trigger input is EXTTRG (pin 44).
 - If cmd->start_src/stop_src=TRIG_EXT then trigger input is TGIN (pin 46).
-- It is not neccessary to have cmd.scan_end_arg=cmd.chanlist_len but
+- It is not necessary to have cmd.scan_end_arg=cmd.chanlist_len but
   cmd.scan_end_arg modulo cmd.chanlist_len must by 0.
 - If return value of cmdtest is 5 then you've bad channel list
   (it isn't possible mixture S.E. and DIFF inputs or bipolar and unipolar
@@ -823,7 +823,7 @@ static void interrupt_pci9118_ai_dma(struct comedi_device *dev,
 		move_block_from_dma(dev, s,
 				    devpriv->dmabuf_virt[devpriv->dma_actbuf],
 				    samplesinbuf);
-		m = m - sampls;		/* m= how many samples was transfered */
+		m = m - sampls;		/* m= how many samples was transferred */
 	}
 /* DPRINTK("YYY\n"); */
 
@@ -1297,7 +1297,7 @@ static int Compute_and_setup_dma(struct comedi_device *dev)
 	DPRINTK("3 dmalen0=%d dmalen1=%d\n", dmalen0, dmalen1);
 	/* transfer without TRIG_WAKE_EOS */
 	if (!(devpriv->ai_flags & TRIG_WAKE_EOS)) {
-		/* if it's possible then allign DMA buffers to length of scan */
+		/* if it's possible then align DMA buffers to length of scan */
 		i = dmalen0;
 		dmalen0 =
 		    (dmalen0 / (devpriv->ai_n_realscanlen << 1)) *
diff --git a/drivers/staging/comedi/drivers/adq12b.c b/drivers/staging/comedi/drivers/adq12b.c
index 4b47000..5361f31 100644
--- a/drivers/staging/comedi/drivers/adq12b.c
+++ b/drivers/staging/comedi/drivers/adq12b.c
@@ -65,7 +65,7 @@ If you do not specify any options, they will default to
    written by jeremy theler <thelerg@ib.cnea.gov.ar>
 
    instituto balseiro
-   comision nacional de energia atomica
+   commission nacional de energia atomica
    universidad nacional de cuyo
    argentina
 
@@ -342,7 +342,7 @@ static int adq12b_ai_rinsn(struct comedi_device *dev,
 	/* convert n samples */
 	for (n = 0; n < insn->n; n++) {
 
-		/* wait for end of convertion */
+		/* wait for end of conversion */
 		i = 0;
 		do {
 			/* udelay(1); */
diff --git a/drivers/staging/comedi/drivers/adv_pci1710.c b/drivers/staging/comedi/drivers/adv_pci1710.c
index 466e69f..da2b75b 100644
--- a/drivers/staging/comedi/drivers/adv_pci1710.c
+++ b/drivers/staging/comedi/drivers/adv_pci1710.c
@@ -98,7 +98,7 @@ Configuration options:
 #define	Status_FE	0x0100	/* 1=FIFO is empty */
 #define Status_FH	0x0200	/* 1=FIFO is half full */
 #define Status_FF	0x0400	/* 1=FIFO is full, fatal error */
-#define Status_IRQ	0x0800	/* 1=IRQ occured */
+#define Status_IRQ	0x0800	/* 1=IRQ occurred */
 /* bits from control register (PCI171x_CONTROL) */
 #define Control_CNT0	0x0040	/* 1=CNT0 have external source,
 				 * 0=have internal 100kHz source */
@@ -1161,7 +1161,7 @@ static int check_channel_list(struct comedi_device *dev,
 	}
 
 	if (n_chan > 1) {
-		chansegment[0] = chanlist[0];	/*  first channel is everytime ok */
+		chansegment[0] = chanlist[0];	/*  first channel is every time ok */
 		for (i = 1, seglen = 1; i < n_chan; i++, seglen++) {	/*  build part of chanlist */
 			/*  printk("%d. %d %d\n",i,CR_CHAN(chanlist[i]),CR_RANGE(chanlist[i])); */
 			if (chanlist[0] == chanlist[i])
@@ -1176,9 +1176,9 @@ static int check_channel_list(struct comedi_device *dev,
 			    (CR_CHAN(chansegment[i - 1]) + 1) % s->n_chan;
 			if (CR_AREF(chansegment[i - 1]) == AREF_DIFF)
 				nowmustbechan = (nowmustbechan + 1) % s->n_chan;
-			if (nowmustbechan != CR_CHAN(chanlist[i])) {	/*  channel list isn't continous :-( */
+			if (nowmustbechan != CR_CHAN(chanlist[i])) {	/*  channel list isn't continuous :-( */
 				printk
-				    ("channel list must be continous! chanlist[%i]=%d but must be %d or %d!\n",
+				    ("channel list must be continuous! chanlist[%i]=%d but must be %d or %d!\n",
 				     i, CR_CHAN(chanlist[i]), nowmustbechan,
 				     CR_CHAN(chanlist[0]));
 				return 0;
diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index 0941643..61968a5 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -115,7 +115,7 @@ analog triggering on 1602 series
 #define   INT_MASK 0x3		/*  mask of interrupt select bits */
 #define   INTE 0x4		/*  interrupt enable */
 #define   DAHFIE 0x8		/*  dac half full interrupt enable */
-#define   EOAIE	0x10		/*  end of aquisition interrupt enable */
+#define   EOAIE	0x10		/*  end of acquisition interrupt enable */
 #define   DAHFI	0x20		/*  dac half full read status / write interrupt clear */
 #define   EOAI 0x40		/*  read end of acq. interrupt status / write clear */
 #define   INT 0x80		/*  read interrupt status / write clear */
@@ -440,7 +440,7 @@ struct cb_pcidas_private {
 	unsigned int divisor1;
 	unsigned int divisor2;
 	volatile unsigned int count;	/*  number of analog input samples remaining */
-	volatile unsigned int adc_fifo_bits;	/*  bits to write to interupt/adcfifo register */
+	volatile unsigned int adc_fifo_bits;	/*  bits to write to interrupt/adcfifo register */
 	volatile unsigned int s5933_intcsr_bits;	/*  bits to write to amcc s5933 interrupt control/status register */
 	volatile unsigned int ao_control_bits;	/*  bits to write to ao control and status register */
 	short ai_buffer[AI_BUFFER_SIZE];
@@ -1653,7 +1653,7 @@ static irqreturn_t cb_pcidas_interrupt(int irq, void *d)
 		spin_unlock_irqrestore(&dev->spinlock, flags);
 	} else if (status & EOAI) {
 		comedi_error(dev,
-			     "bug! encountered end of aquisition interrupt?");
+			     "bug! encountered end of acquisition interrupt?");
 		/*  clear EOA interrupt latch */
 		spin_lock_irqsave(&dev->spinlock, flags);
 		outw(devpriv->adc_fifo_bits | EOAI,
diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 2583e16..1e32419 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -104,7 +104,7 @@ TODO:
 #endif
 
 #define TIMER_BASE 25		/*  40MHz master clock */
-#define PRESCALED_TIMER_BASE	10000	/*  100kHz 'prescaled' clock for slow aquisition, maybe I'll support this someday */
+#define PRESCALED_TIMER_BASE	10000	/*  100kHz 'prescaled' clock for slow acquisition, maybe I'll support this someday */
 #define DMA_BUFFER_SIZE 0x1000
 
 #define PCI_VENDOR_ID_COMPUTERBOARDS	0x1307
@@ -136,7 +136,7 @@ enum write_only_registers {
 	ADC_DELAY_INTERVAL_UPPER_REG = 0x1c,	/*  upper 8 bits of delay interval counter */
 	ADC_COUNT_LOWER_REG = 0x1e,	/*  lower 16 bits of hardware conversion/scan counter */
 	ADC_COUNT_UPPER_REG = 0x20,	/*  upper 8 bits of hardware conversion/scan counter */
-	ADC_START_REG = 0x22,	/*  software trigger to start aquisition */
+	ADC_START_REG = 0x22,	/*  software trigger to start acquisition */
 	ADC_CONVERT_REG = 0x24,	/*  initiates single conversion */
 	ADC_QUEUE_CLEAR_REG = 0x26,	/*  clears adc queue */
 	ADC_QUEUE_LOAD_REG = 0x28,	/*  loads adc queue */
@@ -199,7 +199,7 @@ enum intr_enable_contents {
 	ADC_INTR_EOSCAN_BITS = 0x2,	/*  interrupt end of scan */
 	ADC_INTR_EOSEQ_BITS = 0x3,	/*  interrupt end of sequence (probably wont use this it's pretty fancy) */
 	EN_ADC_INTR_SRC_BIT = 0x4,	/*  enable adc interrupt source */
-	EN_ADC_DONE_INTR_BIT = 0x8,	/*  enable adc aquisition done interrupt */
+	EN_ADC_DONE_INTR_BIT = 0x8,	/*  enable adc acquisition done interrupt */
 	DAC_INTR_SRC_MASK = 0x30,
 	DAC_INTR_QEMPTY_BITS = 0x0,
 	DAC_INTR_HIGH_CHAN_BITS = 0x10,
@@ -2867,7 +2867,7 @@ static int ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
-	/*  start aquisition */
+	/*  start acquisition */
 	if (cmd->start_src == TRIG_NOW) {
 		writew(0, priv(dev)->main_iobase + ADC_START_REG);
 		DEBUG_PRINT("soft trig\n");
@@ -2942,7 +2942,7 @@ static void pio_drain_ai_fifo_16(struct comedi_device *dev)
 /* Read from 32 bit wide ai fifo of 4020 - deal with insane grey coding of pointers.
  * The pci-4020 hardware only supports
  * dma transfers (it only supports the use of pio for draining the last remaining
- * points from the fifo when a data aquisition operation has completed).
+ * points from the fifo when a data acquisition operation has completed).
  */
 static void pio_drain_ai_fifo_32(struct comedi_device *dev)
 {
@@ -3046,7 +3046,7 @@ static void handle_ai_interrupt(struct comedi_device *dev,
 		comedi_error(dev, "fifo overrun");
 		async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
 	}
-	/*  spin lock makes sure noone else changes plx dma control reg */
+	/*  spin lock makes sure no one else changes plx dma control reg */
 	spin_lock_irqsave(&dev->spinlock, flags);
 	dma1_status = readb(priv(dev)->plx9080_iobase + PLX_DMA1_CS_REG);
 	if (plx_status & ICS_DMA1_A) {	/*  dma chan 1 interrupt */
@@ -3170,7 +3170,7 @@ static void handle_ao_interrupt(struct comedi_device *dev,
 	async = s->async;
 	cmd = &async->cmd;
 
-	/*  spin lock makes sure noone else changes plx dma control reg */
+	/*  spin lock makes sure no one else changes plx dma control reg */
 	spin_lock_irqsave(&dev->spinlock, flags);
 	dma0_status = readb(priv(dev)->plx9080_iobase + PLX_DMA0_CS_REG);
 	if (plx_status & ICS_DMA0_A) {	/*  dma chan 0 interrupt */
diff --git a/drivers/staging/comedi/drivers/comedi_test.c b/drivers/staging/comedi/drivers/comedi_test.c
index b220b30..a804742 100644
--- a/drivers/staging/comedi/drivers/comedi_test.c
+++ b/drivers/staging/comedi/drivers/comedi_test.c
@@ -81,7 +81,7 @@ static const struct waveform_board waveform_boards[] = {
 /* Data unique to this driver */
 struct waveform_private {
 	struct timer_list timer;
-	struct timeval last;	/* time at which last timer interrupt occured */
+	struct timeval last;	/* time at which last timer interrupt occurred */
 	unsigned int uvolt_amplitude;	/* waveform amplitude in microvolts */
 	unsigned long usec_period;	/* waveform period in microseconds */
 	unsigned long usec_current;	/* current time (modulo waveform period) */
diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index 6ea93f9..60c2b12 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -1087,7 +1087,7 @@ static void das1800_flush_dma_channel(struct comedi_device *dev,
 	return;
 }
 
-/* flushes remaining data from board when external trigger has stopped aquisition
+/* flushes remaining data from board when external trigger has stopped acquisition
  * and we are using dma transfers */
 static void das1800_flush_dma(struct comedi_device *dev,
 			      struct comedi_subdevice *s)
diff --git a/drivers/staging/comedi/drivers/das800.c b/drivers/staging/comedi/drivers/das800.c
index aecaedc..96d41ad 100644
--- a/drivers/staging/comedi/drivers/das800.c
+++ b/drivers/staging/comedi/drivers/das800.c
@@ -391,7 +391,7 @@ static irqreturn_t das800_interrupt(int irq, void *d)
 	spin_lock_irqsave(&dev->spinlock, irq_flags);
 	outb(CONTROL1, dev->iobase + DAS800_GAIN);	/* select base address + 7 to be STATUS2 register */
 	status = inb(dev->iobase + DAS800_STATUS2) & STATUS2_HCEN;
-	/* don't release spinlock yet since we want to make sure noone else disables hardware conversions */
+	/* don't release spinlock yet since we want to make sure no one else disables hardware conversions */
 	if (status == 0) {
 		spin_unlock_irqrestore(&dev->spinlock, irq_flags);
 		return IRQ_HANDLED;
diff --git a/drivers/staging/comedi/drivers/dmm32at.c b/drivers/staging/comedi/drivers/dmm32at.c
index 693728e..2b4e6e6 100644
--- a/drivers/staging/comedi/drivers/dmm32at.c
+++ b/drivers/staging/comedi/drivers/dmm32at.c
@@ -532,7 +532,7 @@ static int dmm32at_ai_rinsn(struct comedi_device *dev,
 		msb = dmm_inb(dev, DMM32AT_AIMSB);
 
 		/* invert sign bit to make range unsigned, this is an
-		   idiosyncracy of the diamond board, it return
+		   idiosyncrasy of the diamond board, it return
 		   conversions as a signed value, i.e. -32768 to
 		   32767, flipping the bit and interpreting it as
 		   signed gives you a range of 0 to 65535 which is
diff --git a/drivers/staging/comedi/drivers/dt2811.c b/drivers/staging/comedi/drivers/dt2811.c
index a1664ca..0131d52 100644
--- a/drivers/staging/comedi/drivers/dt2811.c
+++ b/drivers/staging/comedi/drivers/dt2811.c
@@ -560,7 +560,7 @@ int dt2811_adtrig(kdev_t minor, comedi_adtrig *adtrig)
 	switch (dev->i_admode) {
 	case COMEDI_MDEMAND:
 		dev->ntrig = adtrig->n - 1;
-		/* not neccessary */
+		/* not necessary */
 		/*printk("dt2811: AD soft trigger\n"); */
 		/*outb(DT2811_CLRERROR|DT2811_INTENB,
 			dev->iobase+DT2811_ADCSR); */
diff --git a/drivers/staging/comedi/drivers/dt9812.c b/drivers/staging/comedi/drivers/dt9812.c
index 0605985..32d9c42 100644
--- a/drivers/staging/comedi/drivers/dt9812.c
+++ b/drivers/staging/comedi/drivers/dt9812.c
@@ -773,7 +773,7 @@ static int dt9812_probe(struct usb_interface *interface,
 			retval = dt9812_read_info(dev, 1, &fw, sizeof(fw));
 			if (retval == 0) {
 				dev_info(&interface->dev,
-					 "usb_reset_configuration succeded "
+					 "usb_reset_configuration succeeded "
 					 "after %d iterations\n", i);
 				break;
 			}
diff --git a/drivers/staging/comedi/drivers/gsc_hpdi.c b/drivers/staging/comedi/drivers/gsc_hpdi.c
index 1661b57..bc020de 100644
--- a/drivers/staging/comedi/drivers/gsc_hpdi.c
+++ b/drivers/staging/comedi/drivers/gsc_hpdi.c
@@ -1031,7 +1031,7 @@ static irqreturn_t handle_interrupt(int irq, void *d)
 		writel(hpdi_intr_status,
 		       priv(dev)->hpdi_iobase + INTERRUPT_STATUS_REG);
 	}
-	/*  spin lock makes sure noone else changes plx dma control reg */
+	/*  spin lock makes sure no one else changes plx dma control reg */
 	spin_lock_irqsave(&dev->spinlock, flags);
 	dma0_status = readb(priv(dev)->plx9080_iobase + PLX_DMA0_CS_REG);
 	if (plx_status & ICS_DMA0_A) {	/*  dma chan 0 interrupt */
@@ -1045,7 +1045,7 @@ static irqreturn_t handle_interrupt(int irq, void *d)
 	}
 	spin_unlock_irqrestore(&dev->spinlock, flags);
 
-	/*  spin lock makes sure noone else changes plx dma control reg */
+	/*  spin lock makes sure no one else changes plx dma control reg */
 	spin_lock_irqsave(&dev->spinlock, flags);
 	dma1_status = readb(priv(dev)->plx9080_iobase + PLX_DMA1_CS_REG);
 	if (plx_status & ICS_DMA1_A) {	/*  XXX *//*  dma chan 1 interrupt */
diff --git a/drivers/staging/comedi/drivers/icp_multi.c b/drivers/staging/comedi/drivers/icp_multi.c
index 0bab39b..126550f 100644
--- a/drivers/staging/comedi/drivers/icp_multi.c
+++ b/drivers/staging/comedi/drivers/icp_multi.c
@@ -715,7 +715,7 @@ Description:
 	is built correctly
 
 Parameters:
-	struct comedi_device *dev	Pointer to current sevice structure
+	struct comedi_device *dev	Pointer to current service structure
 	struct comedi_subdevice *s	Pointer to current subdevice structure
 	unsigned int *chanlist	Pointer to packed channel list
 	unsigned int n_chan	Number of channels to scan
@@ -772,7 +772,7 @@ Description:
 	Status register.
 
 Parameters:
-	struct comedi_device *dev	Pointer to current sevice structure
+	struct comedi_device *dev	Pointer to current service structure
 	struct comedi_subdevice *s	Pointer to current subdevice structure
 	unsigned int *chanlist	Pointer to packed channel list
 	unsigned int n_chan	Number of channels to scan
@@ -848,7 +848,7 @@ Description:
 	This function resets the icp multi device to a 'safe' state
 
 Parameters:
-	struct comedi_device *dev	Pointer to current sevice structure
+	struct comedi_device *dev	Pointer to current service structure
 
 Returns:int	0 = success
 
diff --git a/drivers/staging/comedi/drivers/me4000.c b/drivers/staging/comedi/drivers/me4000.c
index 75511ba..b692fea 100644
--- a/drivers/staging/comedi/drivers/me4000.c
+++ b/drivers/staging/comedi/drivers/me4000.c
@@ -1810,7 +1810,7 @@ static irqreturn_t me4000_ai_isr(int irq, void *dev_id)
 		       ai_context->irq_status_reg) &
 	    ME4000_IRQ_STATUS_BIT_AI_HF) {
 		ISR_PDEBUG
-		    ("me4000_ai_isr(): Fifo half full interrupt occured\n");
+		    ("me4000_ai_isr(): Fifo half full interrupt occurred\n");
 
 		/* Read status register to find out what happened */
 		tmp = me4000_inl(dev, ai_context->ctrl_reg);
@@ -1903,7 +1903,7 @@ static irqreturn_t me4000_ai_isr(int irq, void *dev_id)
 	if (me4000_inl(dev,
 		       ai_context->irq_status_reg) & ME4000_IRQ_STATUS_BIT_SC) {
 		ISR_PDEBUG
-		    ("me4000_ai_isr(): Sample counter interrupt occured\n");
+		    ("me4000_ai_isr(): Sample counter interrupt occurred\n");
 
 		s->async->events |= COMEDI_CB_BLOCK | COMEDI_CB_EOA;
 
diff --git a/drivers/staging/comedi/drivers/mpc624.c b/drivers/staging/comedi/drivers/mpc624.c
index a89eebd..dd09a6d 100644
--- a/drivers/staging/comedi/drivers/mpc624.c
+++ b/drivers/staging/comedi/drivers/mpc624.c
@@ -39,8 +39,8 @@ Status: working
 
 Configuration Options:
   [0] - I/O base address
-  [1] - convertion rate
-	Convertion rate  RMS noise  Effective Number Of Bits
+  [1] - conversion rate
+	Conversion rate  RMS noise  Effective Number Of Bits
 	0      3.52kHz        23uV                17
 	1      1.76kHz       3.5uV                20
 	2       880Hz         2uV                21.3
@@ -93,8 +93,8 @@ Configuration Options:
 #define MPC624_DMY_BIT          (1<<30)
 #define MPC624_SGN_BIT          (1<<29)
 
-/* Convertion speeds */
-/* OSR4 OSR3 OSR2 OSR1 OSR0  Convertion rate  RMS noise  ENOB^
+/* Conversion speeds */
+/* OSR4 OSR3 OSR2 OSR1 OSR0  Conversion rate  RMS noise  ENOB^
  *  X    0    0    0    1        3.52kHz        23uV      17
  *  X    0    0    1    0        1.76kHz       3.5uV      20
  *  X    0    0    1    1         880Hz         2uV      21.3
@@ -227,7 +227,7 @@ static int mpc624_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		break;
 	default:
 		printk
-		    (KERN_ERR "illegal convertion rate setting!"
+		    (KERN_ERR "illegal conversion rate setting!"
 			" Valid numbers are 0..9. Using 9 => 6.875 Hz, ");
 		devpriv->ulConvertionRate = MPC624_SPEED_3_52_kHz;
 	}
@@ -296,7 +296,7 @@ static int mpc624_ai_rinsn(struct comedi_device *dev,
 	}
 
 	for (n = 0; n < insn->n; n++) {
-		/*  Trigger the convertion */
+		/*  Trigger the conversion */
 		outb(MPC624_ADSCK, dev->iobase + MPC624_ADC);
 		udelay(1);
 		outb(MPC624_ADCS | MPC624_ADSCK, dev->iobase + MPC624_ADC);
@@ -304,7 +304,7 @@ static int mpc624_ai_rinsn(struct comedi_device *dev,
 		outb(0, dev->iobase + MPC624_ADC);
 		udelay(1);
 
-		/*  Wait for the convertion to end */
+		/*  Wait for the conversion to end */
 		for (i = 0; i < TIMEOUT; i++) {
 			ucPort = inb(dev->iobase + MPC624_ADC);
 			if (ucPort & MPC624_ADBUSY)
diff --git a/drivers/staging/comedi/drivers/ni_at_a2150.c b/drivers/staging/comedi/drivers/ni_at_a2150.c
index 4d0053e..c192b71 100644
--- a/drivers/staging/comedi/drivers/ni_at_a2150.c
+++ b/drivers/staging/comedi/drivers/ni_at_a2150.c
@@ -104,10 +104,10 @@ TRIG_WAKE_EOS
 #define STATUS_REG		0x12	/*  read only */
 #define   FNE_BIT		0x1	/*  fifo not empty */
 #define   OVFL_BIT		0x8	/*  fifo overflow */
-#define   EDAQ_BIT		0x10	/*  end of aquisition interrupt */
+#define   EDAQ_BIT		0x10	/*  end of acquisition interrupt */
 #define   DCAL_BIT		0x20	/*  offset calibration in progress */
-#define   INTR_BIT		0x40	/*  interrupt has occured */
-#define   DMA_TC_BIT		0x80	/*  dma terminal count interrupt has occured */
+#define   INTR_BIT		0x40	/*  interrupt has occurred */
+#define   DMA_TC_BIT		0x80	/*  dma terminal count interrupt has occurred */
 #define   ID_BITS(x)	(((x) >> 8) & 0x3)
 #define IRQ_DMA_CNTRL_REG		0x12	/*  write only */
 #define   DMA_CHAN_BITS(x)		((x) & 0x7)	/*  sets dma channel */
@@ -434,7 +434,7 @@ static int a2150_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	s->cancel = a2150_cancel;
 
 	/* need to do this for software counting of completed conversions, to
-	 * prevent hardware count from stopping aquisition */
+	 * prevent hardware count from stopping acquisition */
 	outw(HW_COUNT_DISABLE, dev->iobase + I8253_MODE_REG);
 
 	/*  set card's irq and dma levels */
@@ -729,7 +729,7 @@ static int a2150_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	/*  send trigger config bits */
 	outw(trigger_bits, dev->iobase + TRIGGER_REG);
 
-	/*  start aquisition for soft trigger */
+	/*  start acquisition for soft trigger */
 	if (cmd->start_src == TRIG_NOW) {
 		outw(0, dev->iobase + FIFO_START_REG);
 	}
@@ -768,7 +768,7 @@ static int a2150_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 	/*  setup start triggering */
 	outw(0, dev->iobase + TRIGGER_REG);
 
-	/*  start aquisition for soft trigger */
+	/*  start acquisition for soft trigger */
 	outw(0, dev->iobase + FIFO_START_REG);
 
 	/* there is a 35.6 sample delay for data to get through the antialias filter */
diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 241fe52..ab8f370 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -183,11 +183,11 @@ NI manuals:
 #define   OVERRUN_BIT	0x2
 /* fifo overflow */
 #define   OVERFLOW_BIT	0x4
-/* timer interrupt has occured */
+/* timer interrupt has occurred */
 #define   TIMER_BIT	0x8
-/* dma terminal count has occured */
+/* dma terminal count has occurred */
 #define   DMATC_BIT	0x10
-/* external trigger has occured */
+/* external trigger has occurred */
 #define   EXT_TRIG_BIT	0x40
 /* 1200 boards only */
 #define STATUS2_REG	0x1d
@@ -1149,7 +1149,7 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	range = CR_RANGE(cmd->chanlist[0]);
 	aref = CR_AREF(cmd->chanlist[0]);
 
-	/* make sure board is disabled before setting up aquisition */
+	/* make sure board is disabled before setting up acquisition */
 	spin_lock_irqsave(&dev->spinlock, flags);
 	devpriv->command2_bits &= ~SWTRIG_BIT & ~HWTRIG_BIT & ~PRETRIG_BIT;
 	devpriv->write_byte(devpriv->command2_bits, dev->iobase + COMMAND2_REG);
@@ -1349,7 +1349,7 @@ static int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		devpriv->command3_bits &= ~ADC_FNE_INTR_EN_BIT;
 	devpriv->write_byte(devpriv->command3_bits, dev->iobase + COMMAND3_REG);
 
-	/*  startup aquisition */
+	/*  startup acquisition */
 
 	/*  command2 reg */
 	/*  use 2 cascaded counters for pacing */
@@ -1571,8 +1571,8 @@ static void handle_isa_dma(struct comedi_device *dev)
 	devpriv->write_byte(0x1, dev->iobase + DMATC_CLEAR_REG);
 }
 
-/* makes sure all data acquired by board is transfered to comedi (used
- * when aquisition is terminated by stop_src == TRIG_EXT). */
+/* makes sure all data acquired by board is transferred to comedi (used
+ * when acquisition is terminated by stop_src == TRIG_EXT). */
 static void labpc_drain_dregs(struct comedi_device *dev)
 {
 	if (devpriv->current_transfer == isa_dma_transfer)
diff --git a/drivers/staging/comedi/drivers/ni_pcidio.c b/drivers/staging/comedi/drivers/ni_pcidio.c
index 005d2fe..8dd3a01 100644
--- a/drivers/staging/comedi/drivers/ni_pcidio.c
+++ b/drivers/staging/comedi/drivers/ni_pcidio.c
@@ -821,7 +821,7 @@ static int ni_pcidio_cmdtest(struct comedi_device *dev,
 			cmd->scan_begin_arg = MAX_SPEED;
 			err++;
 		}
-		/* no minumum speed */
+		/* no minimum speed */
 	} else {
 		/* TRIG_EXT */
 		/* should be level/edge, hi/lo specification here */
diff --git a/drivers/staging/comedi/drivers/pcl812.c b/drivers/staging/comedi/drivers/pcl812.c
index c6dce4a..09ff472 100644
--- a/drivers/staging/comedi/drivers/pcl812.c
+++ b/drivers/staging/comedi/drivers/pcl812.c
@@ -34,7 +34,7 @@
  *	       and I cann't test all features.)
  *
  * This driver supports insn and cmd interfaces. Some boards support only insn
- * becouse their hardware don't allow more (PCL-813/B, ACL-8113, ISO-813).
+ * because their hardware don't allow more (PCL-813/B, ACL-8113, ISO-813).
  * Data transfer over DMA is supported only when you measure only one
  * channel, this is too hardware limitation of these boards.
  *
diff --git a/drivers/staging/comedi/drivers/pcl816.c b/drivers/staging/comedi/drivers/pcl816.c
index ef3cc4f..8f3fc6e 100644
--- a/drivers/staging/comedi/drivers/pcl816.c
+++ b/drivers/staging/comedi/drivers/pcl816.c
@@ -954,7 +954,7 @@ check_channel_list(struct comedi_device *dev,
 	}
 
 	if (chanlen > 1) {
-		/*  first channel is everytime ok */
+		/*  first channel is every time ok */
 		chansegment[0] = chanlist[0];
 		for (i = 1, seglen = 1; i < chanlen; i++, seglen++) {
 			/*  build part of chanlist */
@@ -968,10 +968,10 @@ check_channel_list(struct comedi_device *dev,
 			nowmustbechan =
 			    (CR_CHAN(chansegment[i - 1]) + 1) % chanlen;
 			if (nowmustbechan != CR_CHAN(chanlist[i])) {
-				/*  channel list isn't continous :-( */
+				/*  channel list isn't continuous :-( */
 				printk(KERN_WARNING
 				       "comedi%d: pcl816: channel list must "
-				       "be continous! chanlist[%i]=%d but "
+				       "be continuous! chanlist[%i]=%d but "
 				       "must be %d or %d!\n", dev->minor,
 				       i, CR_CHAN(chanlist[i]), nowmustbechan,
 				       CR_CHAN(chanlist[0]));
diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index f58d75b..e3eea09 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -1231,7 +1231,7 @@ static int check_channel_list(struct comedi_device *dev,
 	}
 
 	if (n_chan > 1) {
-		/*  first channel is everytime ok */
+		/*  first channel is every time ok */
 		chansegment[0] = chanlist[0];
 		/*  build part of chanlist */
 		for (i = 1, seglen = 1; i < n_chan; i++, seglen++) {
@@ -1245,9 +1245,9 @@ static int check_channel_list(struct comedi_device *dev,
 				break;
 			nowmustbechan =
 			    (CR_CHAN(chansegment[i - 1]) + 1) % s->n_chan;
-			if (nowmustbechan != CR_CHAN(chanlist[i])) {	/*  channel list isn't continous :-( */
+			if (nowmustbechan != CR_CHAN(chanlist[i])) {	/*  channel list isn't continuous :-( */
 				printk
-				    ("comedi%d: pcl818: channel list must be continous! chanlist[%i]=%d but must be %d or %d!\n",
+				    ("comedi%d: pcl818: channel list must be continuous! chanlist[%i]=%d but must be %d or %d!\n",
 				     dev->minor, i, CR_CHAN(chanlist[i]),
 				     nowmustbechan, CR_CHAN(chanlist[0]));
 				return 0;
diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index 5c832d7..f2e88e5 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -733,7 +733,7 @@ static int pcmmio_dio_insn_config(struct comedi_device *dev,
 		break;
 
 	case INSN_CONFIG_DIO_QUERY:
-		/* retreive from shadow register */
+		/* retrieve from shadow register */
 		data[1] =
 		    (s->io_bits & (1 << chan)) ? COMEDI_OUTPUT : COMEDI_INPUT;
 		return insn->n;
@@ -1279,7 +1279,7 @@ static int wait_dac_ready(unsigned long iobase)
 	   "no busy waiting" policy. The fact is that the hardware is
 	   normally so fast that we usually only need one time through the loop
 	   anyway. The longer timeout is for rare occasions and for detecting
-	   non-existant hardware.  */
+	   non-existent hardware.  */
 
 	while (retry--) {
 		if (inb(iobase + 3) & 0x80)
diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index 7a92874..b2c2c89 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -605,7 +605,7 @@ static int pcmuio_dio_insn_config(struct comedi_device *dev,
 		break;
 
 	case INSN_CONFIG_DIO_QUERY:
-		/* retreive from shadow register */
+		/* retrieve from shadow register */
 		data[1] =
 		    (s->io_bits & (1 << chan)) ? COMEDI_OUTPUT : COMEDI_INPUT;
 		return insn->n;
diff --git a/drivers/staging/comedi/drivers/quatech_daqp_cs.c b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
index ebba9bb..82942e5 100644
--- a/drivers/staging/comedi/drivers/quatech_daqp_cs.c
+++ b/drivers/staging/comedi/drivers/quatech_daqp_cs.c
@@ -390,7 +390,7 @@ static int daqp_ai_insn_read(struct comedi_device *dev,
 
 	outb(v, dev->iobase + DAQP_CONTROL);
 
-	/* Reset any pending interrupts (my card has a tendancy to require
+	/* Reset any pending interrupts (my card has a tendency to require
 	 * require multiple reads on the status register to achieve this)
 	 */
 
@@ -752,7 +752,7 @@ static int daqp_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 
 	outb(v, dev->iobase + DAQP_CONTROL);
 
-	/* Reset any pending interrupts (my card has a tendancy to require
+	/* Reset any pending interrupts (my card has a tendency to require
 	 * require multiple reads on the status register to achieve this)
 	 */
 	counter = 100;
diff --git a/drivers/staging/comedi/drivers/rtd520.c b/drivers/staging/comedi/drivers/rtd520.c
index 357858d..7f09ed7 100644
--- a/drivers/staging/comedi/drivers/rtd520.c
+++ b/drivers/staging/comedi/drivers/rtd520.c
@@ -75,7 +75,7 @@ Configuration options:
     das1800, since they have the best documented code.  Driver
     cb_pcidas64.c uses the same DMA controller.
 
-    As far as I can tell, the About interrupt doesnt work if Sample is
+    As far as I can tell, the About interrupt doesn't work if Sample is
     also enabled.  It turns out that About really isn't needed, since
     we always count down samples read.
 
@@ -370,7 +370,7 @@ struct rtdPrivate {
 	/* timer gate (when enabled) */
 	u8 utcGate[4];		/* 1 extra allows simple range check */
 
-	/* shadow registers affect other registers, but cant be read back */
+	/* shadow registers affect other registers, but can't be read back */
 	/* The macros below update these on writes */
 	u16 intMask;		/* interrupt mask */
 	u16 intClearMask;	/* interrupt clear mask */
@@ -485,7 +485,7 @@ struct rtdPrivate {
 #define RtdAdcFifoGet(dev) \
 	readw(devpriv->las1+LAS1_ADC_FIFO)
 
-/* Read two ADC data values (DOESNT WORK) */
+/* Read two ADC data values (DOESN'T WORK) */
 #define RtdAdcFifoGet2(dev) \
 	readl(devpriv->las1+LAS1_ADC_FIFO)
 
@@ -857,7 +857,7 @@ static int rtd_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 			DPRINTK("rtd520: PCI latency = %d\n", pci_latency);
 		}
 
-		/* Undocumented EPLD version (doesnt match RTD driver results) */
+		/* Undocumented EPLD version (doesn't match RTD driver results) */
 		/*DPRINTK ("rtd520: Reading epld from %p\n",
 		   devpriv->las0+0);
 		   epld_version = readl (devpriv->las0+0);
@@ -1291,7 +1291,7 @@ static int rtd520_probe_fifo_depth(struct comedi_device *dev)
 /*
   "instructions" read/write data in "one-shot" or "software-triggered"
   mode (simplest case).
-  This doesnt use interrupts.
+  This doesn't use interrupts.
 
   Note, we don't do any settling delays.  Use a instruction list to
   select, delay, then read.
@@ -2120,7 +2120,7 @@ static int rtd_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 }
 
 /*
-  Stop a running data aquisition.
+  Stop a running data acquisition.
 */
 static int rtd_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s)
 {
diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index d5ba3ab..23fc64b 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -139,7 +139,7 @@ struct s626_private {
 	int got_regions;
 	short allocatedBuf;
 	uint8_t ai_cmd_running;	/*  ai_cmd is running */
-	uint8_t ai_continous;	/*  continous aquisition */
+	uint8_t ai_continous;	/*  continous acquisition */
 	int ai_sample_count;	/*  number of samples to acquire */
 	unsigned int ai_sample_timer;
 	/*  time between samples in  units of the timer */
@@ -1048,7 +1048,7 @@ static irqreturn_t s626_irq_handler(int irq, void *d)
 	uint8_t group;
 	uint16_t irqbit;
 
-	DEBUG("s626_irq_handler: interrupt request recieved!!!\n");
+	DEBUG("s626_irq_handler: interrupt request received!!!\n");
 
 	if (dev->attached == 0)
 		return IRQ_NONE;
@@ -1165,14 +1165,14 @@ static irqreturn_t s626_irq_handler(int irq, void *d)
 							(16 * group)))
 					    == 1 && cmd->start_src == TRIG_EXT) {
 						DEBUG
-						    ("s626_irq_handler: Edge capture interrupt recieved from channel %d\n",
+						    ("s626_irq_handler: Edge capture interrupt received from channel %d\n",
 						     cmd->start_arg);
 
 						/*  Start executing the RPS program. */
 						MC_ENABLE(P_MC1, MC1_ERPS1);
 
 						DEBUG
-						    ("s626_irq_handler: aquisition start triggered!!!\n");
+						    ("s626_irq_handler: acquisition start triggered!!!\n");
 
 						if (cmd->scan_begin_src ==
 						    TRIG_EXT) {
@@ -1194,7 +1194,7 @@ static irqreturn_t s626_irq_handler(int irq, void *d)
 					    && cmd->scan_begin_src ==
 					    TRIG_EXT) {
 						DEBUG
-						    ("s626_irq_handler: Edge capture interrupt recieved from channel %d\n",
+						    ("s626_irq_handler: Edge capture interrupt received from channel %d\n",
 						     cmd->scan_begin_arg);
 
 						/*  Trigger ADC scan loop start by setting RPS Signal 0. */
@@ -1236,7 +1236,7 @@ static irqreturn_t s626_irq_handler(int irq, void *d)
 					    == 1
 					    && cmd->convert_src == TRIG_EXT) {
 						DEBUG
-						    ("s626_irq_handler: Edge capture interrupt recieved from channel %d\n",
+						    ("s626_irq_handler: Edge capture interrupt received from channel %d\n",
 						     cmd->convert_arg);
 
 						/*  Trigger ADC scan loop start by setting RPS Signal 0. */
@@ -1805,7 +1805,7 @@ static int s626_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		DEBUG("s626_ai_cmd: NULL command\n");
 		return -EINVAL;
 	} else {
-		DEBUG("s626_ai_cmd: command recieved!!!\n");
+		DEBUG("s626_ai_cmd: command received!!!\n");
 	}
 
 	if (dev->irq == 0) {
@@ -1880,7 +1880,7 @@ static int s626_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		devpriv->ai_continous = 0;
 		break;
 	case TRIG_NONE:
-		/*  continous aquisition */
+		/*  continous acquisition */
 		devpriv->ai_continous = 1;
 		devpriv->ai_sample_count = 0;
 		break;
@@ -2570,7 +2570,7 @@ static uint32_t I2Chandshake(struct comedi_device *dev, uint32_t val)
 	while ((RR7146(P_I2CCTRL) & (I2C_BUSY | I2C_ERR)) == I2C_BUSY)
 		;
 
-	/*  Return non-zero if I2C error occured. */
+	/*  Return non-zero if I2C error occurred. */
 	return RR7146(P_I2CCTRL) & I2C_ERR;
 
 }
diff --git a/drivers/staging/comedi/drivers/usbdux.c b/drivers/staging/comedi/drivers/usbdux.c
index be93c30..e543e6c 100644
--- a/drivers/staging/comedi/drivers/usbdux.c
+++ b/drivers/staging/comedi/drivers/usbdux.c
@@ -285,7 +285,7 @@ struct usbduxsub {
 	short int ao_cmd_running;
 	/* pwm is running */
 	short int pwm_cmd_running;
-	/* continous aquisition */
+	/* continous acquisition */
 	short int ai_continous;
 	short int ao_continous;
 	/* number of samples to acquire */
@@ -500,7 +500,7 @@ static void usbduxsub_ai_IsocIrq(struct urb *urb)
 
 	/* test, if we transmit only a fixed number of samples */
 	if (!(this_usbduxsub->ai_continous)) {
-		/* not continous, fixed number of samples */
+		/* not continuous, fixed number of samples */
 		this_usbduxsub->ai_sample_count--;
 		/* all samples received? */
 		if (this_usbduxsub->ai_sample_count < 0) {
@@ -653,7 +653,7 @@ static void usbduxsub_ao_IsocIrq(struct urb *urb)
 		/* timer zero */
 		this_usbduxsub->ao_counter = this_usbduxsub->ao_timer;
 
-		/* handle non continous aquisition */
+		/* handle non continous acquisition */
 		if (!(this_usbduxsub->ao_continous)) {
 			/* fixed number of samples */
 			this_usbduxsub->ao_sample_count--;
@@ -957,7 +957,7 @@ static int usbdux_ai_cmdtest(struct comedi_device *dev,
 	if (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)
 		err++;
 
-	/* scanning is continous */
+	/* scanning is continuous */
 	tmp = cmd->convert_src;
 	cmd->convert_src &= TRIG_NOW;
 	if (!cmd->convert_src || tmp != cmd->convert_src)
@@ -1222,7 +1222,7 @@ static int usbdux_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		up(&this_usbduxsub->sem);
 		return -EBUSY;
 	}
-	/* set current channel of the running aquisition to zero */
+	/* set current channel of the running acquisition to zero */
 	s->async->cur_chan = 0;
 
 	this_usbduxsub->dux_commands[1] = cmd->chanlist_len;
@@ -1284,7 +1284,7 @@ static int usbdux_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		this_usbduxsub->ai_sample_count = cmd->stop_arg;
 		this_usbduxsub->ai_continous = 0;
 	} else {
-		/* continous aquisition */
+		/* continous acquisition */
 		this_usbduxsub->ai_continous = 1;
 		this_usbduxsub->ai_sample_count = 0;
 	}
@@ -1515,7 +1515,7 @@ static int usbdux_ao_cmdtest(struct comedi_device *dev,
 	/* just now we scan also in the high speed mode every frame */
 	/* this is due to ehci driver limitations */
 	if (0) {		/* (this_usbduxsub->high_speed) */
-		/* start immidiately a new scan */
+		/* start immediately a new scan */
 		/* the sampling rate is set by the coversion rate */
 		cmd->scan_begin_src &= TRIG_FOLLOW;
 	} else {
@@ -1525,7 +1525,7 @@ static int usbdux_ao_cmdtest(struct comedi_device *dev,
 	if (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)
 		err++;
 
-	/* scanning is continous */
+	/* scanning is continuous */
 	tmp = cmd->convert_src;
 	/* we always output at 1kHz just now all channels at once */
 	if (0) {		/* (this_usbduxsub->high_speed) */
@@ -1645,7 +1645,7 @@ static int usbdux_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	dev_dbg(&this_usbduxsub->interface->dev,
 		"comedi%d: %s\n", dev->minor, __func__);
 
-	/* set current channel of the running aquisition to zero */
+	/* set current channel of the running acquisition to zero */
 	s->async->cur_chan = 0;
 	for (i = 0; i < cmd->chanlist_len; ++i) {
 		chan = CR_CHAN(cmd->chanlist[i]);
@@ -1694,7 +1694,7 @@ static int usbdux_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	this_usbduxsub->ao_counter = this_usbduxsub->ao_timer;
 
 	if (cmd->stop_src == TRIG_COUNT) {
-		/* not continous */
+		/* not continuous */
 		/* counter */
 		/* high speed also scans everything at once */
 		if (0) {	/* (this_usbduxsub->high_speed) */
@@ -1708,7 +1708,7 @@ static int usbdux_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 		}
 		this_usbduxsub->ao_continous = 0;
 	} else {
-		/* continous aquisition */
+		/* continous acquisition */
 		this_usbduxsub->ao_continous = 1;
 		this_usbduxsub->ao_sample_count = 0;
 	}
diff --git a/drivers/staging/comedi/drivers/usbduxfast.c b/drivers/staging/comedi/drivers/usbduxfast.c
index 5b15e6d..2a8e725 100644
--- a/drivers/staging/comedi/drivers/usbduxfast.c
+++ b/drivers/staging/comedi/drivers/usbduxfast.c
@@ -180,7 +180,7 @@ struct usbduxfastsub_s {
 	/* comedi device for the interrupt context */
 	struct comedi_device *comedidev;
 	short int ai_cmd_running;	/* asynchronous command is running */
-	short int ai_continous;	/* continous aquisition */
+	short int ai_continous;	/* continous acquisition */
 	long int ai_sample_count;	/* number of samples to acquire */
 	uint8_t *dux_commands;	/* commands */
 	int ignore;		/* counter which ignores the first
@@ -392,7 +392,7 @@ static void usbduxfastsub_ai_Irq(struct urb *urb)
 	p = urb->transfer_buffer;
 	if (!udfs->ignore) {
 		if (!udfs->ai_continous) {
-			/* not continous, fixed number of samples */
+			/* not continuous, fixed number of samples */
 			n = urb->actual_length / sizeof(uint16_t);
 			if (unlikely(udfs->ai_sample_count < n)) {
 				/*
@@ -775,7 +775,7 @@ static int usbduxfast_ai_cmd(struct comedi_device *dev,
 		up(&udfs->sem);
 		return -EBUSY;
 	}
-	/* set current channel of the running aquisition to zero */
+	/* set current channel of the running acquisition to zero */
 	s->async->cur_chan = 0;
 
 	/*
@@ -1182,7 +1182,7 @@ static int usbduxfast_ai_cmd(struct comedi_device *dev,
 		}
 		udfs->ai_continous = 0;
 	} else {
-		/* continous aquisition */
+		/* continous acquisition */
 		udfs->ai_continous = 1;
 		udfs->ai_sample_count = 0;
 	}
diff --git a/drivers/staging/cptm1217/clearpad_tm1217.c b/drivers/staging/cptm1217/clearpad_tm1217.c
index 76e4b78..0fe713e 100644
--- a/drivers/staging/cptm1217/clearpad_tm1217.c
+++ b/drivers/staging/cptm1217/clearpad_tm1217.c
@@ -52,7 +52,7 @@
 #define TMA1217_DEV_STATUS		0x13	/* Device Status */
 #define TMA1217_INT_STATUS		0x14	/* Interrupt Status */
 
-/* Controller can detect upto 2 possible finger touches.
+/* Controller can detect up to 2 possible finger touches.
  * Each finger touch provides  12 bit X Y co-ordinates, the values are split
  * across 2 registers, and an 8 bit  Z value */
 #define TMA1217_FINGER_STATE		0x18 /* Finger State */
diff --git a/drivers/staging/crystalhd/crystalhd_cmds.c b/drivers/staging/crystalhd/crystalhd_cmds.c
index 14296085..3735ed3 100644
--- a/drivers/staging/crystalhd/crystalhd_cmds.c
+++ b/drivers/staging/crystalhd/crystalhd_cmds.c
@@ -914,7 +914,7 @@ enum BC_STATUS crystalhd_user_open(struct crystalhd_cmd *ctx,
  * Return:
  *	status
  *
- * Closer aplication handle and release app specific
+ * Closer application handle and release app specific
  * resources.
  */
 enum BC_STATUS crystalhd_user_close(struct crystalhd_cmd *ctx, struct crystalhd_user *uc)
diff --git a/drivers/staging/crystalhd/crystalhd_hw.c b/drivers/staging/crystalhd/crystalhd_hw.c
index 13a514d..5acf39e 100644
--- a/drivers/staging/crystalhd/crystalhd_hw.c
+++ b/drivers/staging/crystalhd/crystalhd_hw.c
@@ -302,7 +302,7 @@ static bool crystalhd_start_device(struct crystalhd_adp *adp)
 	crystalhd_enable_interrupts(adp);
 
 	/* Enable the option for getting the total no. of DWORDS
-	 * that have been transfered by the RXDMA engine
+	 * that have been transferred by the RXDMA engine
 	 */
 	dbg_options = crystalhd_reg_rd(adp, MISC1_DMA_DEBUG_OPTIONS_REG);
 	dbg_options |= 0x10;
@@ -1776,7 +1776,7 @@ enum BC_STATUS crystalhd_do_fw_cmd(struct crystalhd_hw *hw,
 		return sts;
 	}
 
-	/*Get the Responce Address*/
+	/*Get the Response Address*/
 	cmd_res_addr = bc_dec_reg_rd(hw->adp, Cpu2HstMbx1);
 
 	/*Read the Response*/
@@ -2367,7 +2367,7 @@ enum BC_STATUS crystalhd_hw_set_core_clock(struct crystalhd_hw *hw)
 	BCMLOG(BCMLOG_INFO, "clock is moving to %d with n %d with vco_mg %d\n",
 	       hw->core_clock_mhz, n, vco_mg);
 
-	/* Change the DRAM refresh rate to accomodate the new frequency */
+	/* Change the DRAM refresh rate to accommodate the new frequency */
 	/* refresh reg = ((refresh_rate * clock_rate)/16) - 1; rounding up*/
 	refresh_reg = (7 * hw->core_clock_mhz / 16);
 	bc_dec_reg_wr(hw->adp, SDRAM_REF_PARAM, ((1 << 12) | refresh_reg));
diff --git a/drivers/staging/cxt1e1/musycc.c b/drivers/staging/cxt1e1/musycc.c
index f274c77..5cc3423 100644
--- a/drivers/staging/cxt1e1/musycc.c
+++ b/drivers/staging/cxt1e1/musycc.c
@@ -1455,7 +1455,7 @@ musycc_intr_bh_tasklet (ci_t * ci)
             /*
              * If the descriptor has not recovered, then leaving the EMPTY
              * entry set will not signal to the MUSYCC that this descriptor
-             * has been serviced. The Interrupt Queue can then start loosing
+             * has been serviced. The Interrupt Queue can then start losing
              * available descriptors and MUSYCC eventually encounters and
              * reports the INTFULL condition.  Per manual, changing any bit
              * marks descriptor as available, thus the use of different
diff --git a/drivers/staging/cxt1e1/musycc.h b/drivers/staging/cxt1e1/musycc.h
index d2c91ef..68f3660 100644
--- a/drivers/staging/cxt1e1/musycc.h
+++ b/drivers/staging/cxt1e1/musycc.h
@@ -74,7 +74,7 @@ extern      "C"
 
 #define INT_QUEUE_SIZE    MUSYCC_NIQD
 
-/* RAM image of MUSYCC registers layed out as a C structure */
+/* RAM image of MUSYCC registers laid out as a C structure */
     struct musycc_groupr
     {
         VINT32      thp[32];    /* Transmit Head Pointer [5-29]           */
@@ -96,7 +96,7 @@ extern      "C"
         VINT32      pcd;        /* Port Configuration Descriptor [5-19]   */
     };
 
-/* hardware MUSYCC registers layed out as a C structure */
+/* hardware MUSYCC registers laid out as a C structure */
     struct musycc_globalr
     {
         VINT32      gbp;        /* Group Base Pointer                     */
diff --git a/drivers/staging/cxt1e1/pmcc4_defs.h b/drivers/staging/cxt1e1/pmcc4_defs.h
index 186347b..a39505f 100644
--- a/drivers/staging/cxt1e1/pmcc4_defs.h
+++ b/drivers/staging/cxt1e1/pmcc4_defs.h
@@ -54,8 +54,8 @@
 #define MUSYCC_MTU          2048  /* default */
 #define MUSYCC_TXDESC_MIN   10    /* HDLC mode default */
 #define MUSYCC_RXDESC_MIN   18    /* HDLC mode default */
-#define MUSYCC_TXDESC_TRANS 4     /* Transparent mode minumum # of TX descriptors */
-#define MUSYCC_RXDESC_TRANS 12    /* Transparent mode minumum # of RX descriptors */
+#define MUSYCC_TXDESC_TRANS 4     /* Transparent mode minimum # of TX descriptors */
+#define MUSYCC_RXDESC_TRANS 12    /* Transparent mode minimum # of RX descriptors */
 
 #define MAX_DEFAULT_IFQLEN  32    /* network qlen */
 
diff --git a/drivers/staging/cxt1e1/sbecrc.c b/drivers/staging/cxt1e1/sbecrc.c
index 5123294..3f3cd60 100644
--- a/drivers/staging/cxt1e1/sbecrc.c
+++ b/drivers/staging/cxt1e1/sbecrc.c
@@ -95,7 +95,7 @@ sbeCrc (u_int8_t *buffer,          /* data buffer to crc */
 
     /*
      * if table not yet created, do so. Don't care about "extra" time
-     * checking this everytime sbeCrc() is called, since CRC calculations are
+     * checking this every time sbeCrc() is called, since CRC calculations are
      * already time consuming
      */
     if (!crcTableInit)
diff --git a/drivers/staging/cxt1e1/sbeproc.c b/drivers/staging/cxt1e1/sbeproc.c
index 70b9b33..f42531c 100644
--- a/drivers/staging/cxt1e1/sbeproc.c
+++ b/drivers/staging/cxt1e1/sbeproc.c
@@ -239,7 +239,7 @@ sbecom_proc_get_sbe_info (char *buffer, char **start, off_t offset,
      */
 
 #if 1
-    /* #4 - intepretation of above = set EOF, return len */
+    /* #4 - interpretation of above = set EOF, return len */
     *eof = 1;
 #endif
 
diff --git a/drivers/staging/et131x/et1310_address_map.h b/drivers/staging/et131x/et1310_address_map.h
index e6c8cb3..425e927 100644
--- a/drivers/staging/et131x/et1310_address_map.h
+++ b/drivers/staging/et131x/et1310_address_map.h
@@ -856,7 +856,7 @@ typedef union _RXMAC_UNI_PF_ADDR3_t {
  */
 
 /*
- * structure for space availiable reg in rxmac address map.
+ * structure for space available reg in rxmac address map.
  * located at address 0x4094
  *
  * 31-17: reserved
@@ -1031,7 +1031,7 @@ typedef struct _RXMAC_t {				/* Location: */
  * 31: reset MII mgmt
  * 30-6: unused
  * 5: scan auto increment
- * 4: preamble supress
+ * 4: preamble suppress
  * 3: undefined
  * 2-0: mgmt clock reset
  */
diff --git a/drivers/staging/et131x/et1310_phy.h b/drivers/staging/et131x/et1310_phy.h
index 78349ad..946c0c5 100644
--- a/drivers/staging/et131x/et1310_phy.h
+++ b/drivers/staging/et131x/et1310_phy.h
@@ -468,7 +468,7 @@ typedef union _MI_ANAR_t {
 #define TRUEPHY_ANEG_COMPLETE           1
 #define TRUEPHY_ANEG_DISABLED           2
 
-/* Define duplex advertisment flags */
+/* Define duplex advertisement flags */
 #define TRUEPHY_ADV_DUPLEX_NONE         0x00
 #define TRUEPHY_ADV_DUPLEX_FULL         0x01
 #define TRUEPHY_ADV_DUPLEX_HALF         0x02
diff --git a/drivers/staging/et131x/et1310_rx.c b/drivers/staging/et131x/et1310_rx.c
index 339136f..fc6bd43 100644
--- a/drivers/staging/et131x/et1310_rx.c
+++ b/drivers/staging/et131x/et1310_rx.c
@@ -122,7 +122,7 @@ int et131x_rx_dma_memory_alloc(struct et131x_adapter *adapter)
 	 * number of entries in FBR1.
 	 *
 	 * FBR1 holds "large" frames, FBR0 holds "small" frames.  If FBR1
-	 * entries are huge in order to accomodate a "jumbo" frame, then it
+	 * entries are huge in order to accommodate a "jumbo" frame, then it
 	 * will have less entries.  Conversely, FBR1 will now be relied upon
 	 * to carry more "normal" frames, thus it's entry size also increases
 	 * and the number of entries goes up too (since it now carries
diff --git a/drivers/staging/et131x/et131x_isr.c b/drivers/staging/et131x/et131x_isr.c
index ce4d930..f716e40 100644
--- a/drivers/staging/et131x/et131x_isr.c
+++ b/drivers/staging/et131x/et131x_isr.c
@@ -466,7 +466,7 @@ void et131x_isr_handler(struct work_struct *work)
 		/* Handle SLV Timeout Interrupt */
 		if (status & ET_INTR_SLV_TIMEOUT) {
 			/*
-			 * This means a timeout has occured on a read or
+			 * This means a timeout has occurred on a read or
 			 * write request to one of the JAGCore registers. The
 			 * Global Resources block has terminated the request
 			 * and on a read request, returned a "fake" value.
diff --git a/drivers/staging/et131x/et131x_netdev.c b/drivers/staging/et131x/et131x_netdev.c
index 0c298ca..b25bae2 100644
--- a/drivers/staging/et131x/et131x_netdev.c
+++ b/drivers/staging/et131x/et131x_netdev.c
@@ -415,7 +415,7 @@ void et131x_multicast(struct net_device *netdev)
 	 */
 	PacketFilter = adapter->PacketFilter;
 
-	/* Clear the 'multicast' flag locally; becuase we only have a single
+	/* Clear the 'multicast' flag locally; because we only have a single
 	 * flag to check multicast, and multiple multicast addresses can be
 	 * set, this is the easiest way to determine if more than one
 	 * multicast address is being set.
diff --git a/drivers/staging/ft1000/ft1000-pcmcia/ft1000_dev.h b/drivers/staging/ft1000/ft1000-pcmcia/ft1000_dev.h
index 4a89bd1..0b63f05 100644
--- a/drivers/staging/ft1000/ft1000-pcmcia/ft1000_dev.h
+++ b/drivers/staging/ft1000/ft1000-pcmcia/ft1000_dev.h
@@ -30,7 +30,7 @@
 //---------------------------------------------------------------------------
 //
 // Function:   ft1000_read_reg
-// Descripton: This function will read the value of a given ASIC register.
+// Description: This function will read the value of a given ASIC register.
 // Input:
 //     dev    - device structure
 //     offset - ASIC register offset
@@ -49,7 +49,7 @@ static inline u16 ft1000_read_reg (struct net_device *dev, u16 offset) {
 //---------------------------------------------------------------------------
 //
 // Function:   ft1000_write_reg
-// Descripton: This function will set the value for a given ASIC register.
+// Description: This function will set the value for a given ASIC register.
 // Input:
 //     dev    - device structure
 //     offset - ASIC register offset
diff --git a/drivers/staging/ft1000/ft1000-pcmcia/ft1000_dnld.c b/drivers/staging/ft1000/ft1000-pcmcia/ft1000_dnld.c
index b0729fc..fb375ea 100644
--- a/drivers/staging/ft1000/ft1000-pcmcia/ft1000_dnld.c
+++ b/drivers/staging/ft1000/ft1000-pcmcia/ft1000_dnld.c
@@ -95,47 +95,47 @@ void put_request_value(struct net_device *dev, long lvalue);
 USHORT hdr_checksum(PPSEUDO_HDR pHdr);
 
 typedef struct _DSP_FILE_HDR {
-	long build_date;
-	long dsp_coff_date;
-	long loader_code_address;
-	long loader_code_size;
-	long loader_code_end;
-	long dsp_code_address;
-	long dsp_code_size;
-	long dsp_code_end;
-	long reserved[8];
+	u32  build_date;
+	u32  dsp_coff_date;
+	u32  loader_code_address;
+	u32  loader_code_size;
+	u32  loader_code_end;
+	u32  dsp_code_address;
+	u32  dsp_code_size;
+	u32  dsp_code_end;
+	u32  reserved[8];
 } __attribute__ ((packed)) DSP_FILE_HDR, *PDSP_FILE_HDR;
 
 typedef struct _DSP_FILE_HDR_5 {
-	long version_id;	// Version ID of this image format.
-	long package_id;	// Package ID of code release.
-	long build_date;	// Date/time stamp when file was built.
-	long commands_offset;	// Offset to attached commands in Pseudo Hdr format.
-	long loader_offset;	// Offset to bootloader code.
-	long loader_code_address;	// Start address of bootloader.
-	long loader_code_end;	// Where bootloader code ends.
-	long loader_code_size;
-	long version_data_offset;	// Offset were scrambled version data begins.
-	long version_data_size;	// Size, in words, of scrambled version data.
-	long nDspImages;	// Number of DSP images in file.
+	u32  version_id;	// Version ID of this image format.
+	u32  package_id;	// Package ID of code release.
+	u32  build_date;	// Date/time stamp when file was built.
+	u32  commands_offset;	// Offset to attached commands in Pseudo Hdr format.
+	u32  loader_offset;	// Offset to bootloader code.
+	u32  loader_code_address;	// Start address of bootloader.
+	u32  loader_code_end;	// Where bootloader code ends.
+	u32  loader_code_size;
+	u32  version_data_offset;	// Offset were scrambled version data begins.
+	u32  version_data_size;	// Size, in words, of scrambled version data.
+	u32  nDspImages;	// Number of DSP images in file.
 } __attribute__ ((packed)) DSP_FILE_HDR_5, *PDSP_FILE_HDR_5;
 
 typedef struct _DSP_IMAGE_INFO {
-	long coff_date;		// Date/time when DSP Coff image was built.
-	long begin_offset;	// Offset in file where image begins.
-	long end_offset;	// Offset in file where image begins.
-	long run_address;	// On chip Start address of DSP code.
-	long image_size;	// Size of image.
-	long version;		// Embedded version # of DSP code.
+	u32  coff_date;		// Date/time when DSP Coff image was built.
+	u32  begin_offset;	// Offset in file where image begins.
+	u32  end_offset;	// Offset in file where image begins.
+	u32  run_address;	// On chip Start address of DSP code.
+	u32  image_size;	// Size of image.
+	u32  version;		// Embedded version # of DSP code.
 } __attribute__ ((packed)) DSP_IMAGE_INFO, *PDSP_IMAGE_INFO;
 
 typedef struct _DSP_IMAGE_INFO_V6 {
-	long coff_date;		// Date/time when DSP Coff image was built.
-	long begin_offset;	// Offset in file where image begins.
-	long end_offset;	// Offset in file where image begins.
-	long run_address;	// On chip Start address of DSP code.
-	long image_size;	// Size of image.
-	long version;		// Embedded version # of DSP code.
+	u32  coff_date;		// Date/time when DSP Coff image was built.
+	u32  begin_offset;	// Offset in file where image begins.
+	u32  end_offset;	// Offset in file where image begins.
+	u32  run_address;	// On chip Start address of DSP code.
+	u32  image_size;	// Size of image.
+	u32  version;		// Embedded version # of DSP code.
 	unsigned short checksum;	// Dsp File checksum
 	unsigned short pad1;
 } __attribute__ ((packed)) DSP_IMAGE_INFO_V6, *PDSP_IMAGE_INFO_V6;
@@ -846,8 +846,8 @@ int card_download(struct net_device *dev, const u8 *pFileStart, UINT FileLength)
 			break;
 
 		case STATE_DONE_DWNLD:
-			if (((UINT) (pUcFile) - (UINT) pFileStart) >=
-				(UINT) FileLength) {
+			if (((unsigned long) (pUcFile) - (unsigned long) pFileStart) >=
+				(unsigned long) FileLength) {
 				uiState = STATE_DONE_FILE;
 				break;
 			}
@@ -901,11 +901,11 @@ int card_download(struct net_device *dev, const u8 *pFileStart, UINT FileLength)
 								  &info->prov_list);
 						// Move to next entry if available
 						pUcFile =
-							(UCHAR *) ((UINT) pUcFile +
-								   (UINT) ((usHdrLength + 1) & 0xFFFFFFFE) + sizeof(PSEUDO_HDR));
-						if ((UINT) (pUcFile) -
-							(UINT) (pFileStart) >=
-							(UINT) FileLength) {
+							(UCHAR *) ((unsigned long) pUcFile +
+								   (unsigned long) ((usHdrLength + 1) & 0xFFFFFFFE) + sizeof(PSEUDO_HDR));
+						if ((unsigned long) (pUcFile) -
+							(unsigned long) (pFileStart) >=
+							(unsigned long) FileLength) {
 							uiState =
 								STATE_DONE_FILE;
 						}
diff --git a/drivers/staging/ft1000/ft1000-pcmcia/ft1000_hw.c b/drivers/staging/ft1000/ft1000-pcmcia/ft1000_hw.c
index ff691d9..eeb7dd4 100644
--- a/drivers/staging/ft1000/ft1000-pcmcia/ft1000_hw.c
+++ b/drivers/staging/ft1000/ft1000-pcmcia/ft1000_hw.c
@@ -90,7 +90,7 @@ MODULE_SUPPORTED_DEVICE("FT1000");
 //---------------------------------------------------------------------------
 //
 // Function:   ft1000_asic_read
-// Descripton: This function will retrieve the value of a specific ASIC
+// Description: This function will retrieve the value of a specific ASIC
 //             register.
 // Input:
 //    dev - network device structure
@@ -107,7 +107,7 @@ inline u16 ft1000_asic_read(struct net_device *dev, u16 offset)
 //---------------------------------------------------------------------------
 //
 // Function:   ft1000_asic_write
-// Descripton: This function will set the value of a specific ASIC
+// Description: This function will set the value of a specific ASIC
 //             register.
 // Input:
 //    dev - network device structure
@@ -124,7 +124,7 @@ inline void ft1000_asic_write(struct net_device *dev, u16 offset, u16 value)
 //---------------------------------------------------------------------------
 //
 // Function:   ft1000_read_fifo_len
-// Descripton: This function will read the ASIC Uplink FIFO status register
+// Description: This function will read the ASIC Uplink FIFO status register
 //             which will return the number of bytes remaining in the Uplink FIFO.
 //             Sixteen bytes are subtracted to make sure that the ASIC does not
 //             reach its threshold.
@@ -148,7 +148,7 @@ static inline u16 ft1000_read_fifo_len(struct net_device *dev)
 //---------------------------------------------------------------------------
 //
 // Function:   ft1000_read_dpram
-// Descripton: This function will read the specific area of dpram
+// Description: This function will read the specific area of dpram
 //             (Electrabuzz ASIC only)
 // Input:
 //     dev    - device structure
@@ -175,7 +175,7 @@ u16 ft1000_read_dpram(struct net_device * dev, int offset)
 //---------------------------------------------------------------------------
 //
 // Function:   ft1000_write_dpram
-// Descripton: This function will write to a specific area of dpram
+// Description: This function will write to a specific area of dpram
 //             (Electrabuzz ASIC only)
 // Input:
 //     dev    - device structure
@@ -201,7 +201,7 @@ static inline void ft1000_write_dpram(struct net_device *dev,
 //---------------------------------------------------------------------------
 //
 // Function:   ft1000_read_dpram_mag_16
-// Descripton: This function will read the specific area of dpram
+// Description: This function will read the specific area of dpram
 //             (Magnemite ASIC only)
 // Input:
 //     dev    - device structure
@@ -233,7 +233,7 @@ u16 ft1000_read_dpram_mag_16(struct net_device *dev, int offset, int Index)
 //---------------------------------------------------------------------------
 //
 // Function:   ft1000_write_dpram_mag_16
-// Descripton: This function will write to a specific area of dpram
+// Description: This function will write to a specific area of dpram
 //             (Magnemite ASIC only)
 // Input:
 //     dev    - device structure
@@ -263,7 +263,7 @@ static inline void ft1000_write_dpram_mag_16(struct net_device *dev,
 //---------------------------------------------------------------------------
 //
 // Function:   ft1000_read_dpram_mag_32
-// Descripton: This function will read the specific area of dpram
+// Description: This function will read the specific area of dpram
 //             (Magnemite ASIC only)
 // Input:
 //     dev    - device structure
@@ -290,7 +290,7 @@ u32 ft1000_read_dpram_mag_32(struct net_device *dev, int offset)
 //---------------------------------------------------------------------------
 //
 // Function:   ft1000_write_dpram_mag_32
-// Descripton: This function will write to a specific area of dpram
+// Description: This function will write to a specific area of dpram
 //             (Magnemite ASIC only)
 // Input:
 //     dev    - device structure
@@ -315,7 +315,7 @@ void ft1000_write_dpram_mag_32(struct net_device *dev, int offset, u32 value)
 //---------------------------------------------------------------------------
 //
 // Function:   ft1000_enable_interrupts
-// Descripton: This function will enable interrupts base on the current interrupt mask.
+// Description: This function will enable interrupts base on the current interrupt mask.
 // Input:
 //     dev    - device structure
 // Output:
@@ -340,7 +340,7 @@ static void ft1000_enable_interrupts(struct net_device *dev)
 //---------------------------------------------------------------------------
 //
 // Function:   ft1000_disable_interrupts
-// Descripton: This function will disable all interrupts.
+// Description: This function will disable all interrupts.
 // Input:
 //     dev    - device structure
 // Output:
@@ -364,7 +364,7 @@ static void ft1000_disable_interrupts(struct net_device *dev)
 //---------------------------------------------------------------------------
 //
 // Function:   ft1000_reset_asic
-// Descripton: This function will call the Card Service function to reset the
+// Description: This function will call the Card Service function to reset the
 //             ASIC.
 // Input:
 //     dev    - device structure
@@ -408,7 +408,7 @@ static void ft1000_reset_asic(struct net_device *dev)
 //---------------------------------------------------------------------------
 //
 // Function:   ft1000_reset_card
-// Descripton: This function will reset the card
+// Description: This function will reset the card
 // Input:
 //     dev    - device structure
 // Output:
@@ -571,7 +571,7 @@ static int ft1000_reset_card(struct net_device *dev)
 //---------------------------------------------------------------------------
 //
 // Function:   ft1000_chkcard
-// Descripton: This function will check if the device is presently available on
+// Description: This function will check if the device is presently available on
 //             the system.
 // Input:
 //     dev    - device structure
@@ -607,7 +607,7 @@ static int ft1000_chkcard(struct net_device *dev)
 //---------------------------------------------------------------------------
 //
 // Function:   ft1000_hbchk
-// Descripton: This function will perform the heart beat check of the DSP as
+// Description: This function will perform the heart beat check of the DSP as
 //             well as the ASIC.
 // Input:
 //     dev    - device structure
@@ -828,7 +828,7 @@ static void ft1000_hbchk(u_long data)
 //---------------------------------------------------------------------------
 //
 // Function:   ft1000_send_cmd
-// Descripton:
+// Description:
 // Input:
 // Output:
 //
@@ -908,7 +908,7 @@ void ft1000_send_cmd (struct net_device *dev, u16 *ptempbuffer, int size, u16 qt
 //---------------------------------------------------------------------------
 //
 // Function:   ft1000_receive_cmd
-// Descripton: This function will read a message from the dpram area.
+// Description: This function will read a message from the dpram area.
 // Input:
 //    dev - network device structure
 //    pbuffer - caller supply address to buffer
@@ -1003,7 +1003,7 @@ BOOLEAN ft1000_receive_cmd(struct net_device *dev, u16 * pbuffer, int maxsz, u16
 //---------------------------------------------------------------------------
 //
 // Function:   ft1000_proc_drvmsg
-// Descripton: This function will process the various driver messages.
+// Description: This function will process the various driver messages.
 // Input:
 //     dev    - device structure
 //     pnxtph - pointer to next pseudo header
@@ -1285,7 +1285,7 @@ void ft1000_proc_drvmsg(struct net_device *dev)
 //---------------------------------------------------------------------------
 //
 // Function:   ft1000_parse_dpram_msg
-// Descripton: This function will parse the message received from the DSP
+// Description: This function will parse the message received from the DSP
 //             via the DPRAM interface.
 // Input:
 //     dev    - device structure
@@ -1442,7 +1442,7 @@ int ft1000_parse_dpram_msg(struct net_device *dev)
 //---------------------------------------------------------------------------
 //
 // Function:   ft1000_flush_fifo
-// Descripton: This function will flush one packet from the downlink
+// Description: This function will flush one packet from the downlink
 //             FIFO.
 // Input:
 //     dev      - device structure
@@ -1587,7 +1587,7 @@ static void ft1000_flush_fifo(struct net_device *dev, u16 DrvErrNum)
 //---------------------------------------------------------------------------
 //
 // Function:   ft1000_copy_up_pkt
-// Descripton: This function will pull Flarion packets out of the Downlink
+// Description: This function will pull Flarion packets out of the Downlink
 //             FIFO and convert it to an ethernet packet.  The ethernet packet will
 //             then be deliver to the TCP/IP stack.
 // Input:
@@ -1773,7 +1773,7 @@ int ft1000_copy_up_pkt(struct net_device *dev)
 //---------------------------------------------------------------------------
 //
 // Function:   ft1000_copy_down_pkt
-// Descripton: This function will take an ethernet packet and convert it to
+// Description: This function will take an ethernet packet and convert it to
 //             a Flarion packet prior to sending it to the ASIC Downlink
 //             FIFO.
 // Input:
diff --git a/drivers/staging/ft1000/ft1000-usb/ft1000_download.c b/drivers/staging/ft1000/ft1000-usb/ft1000_download.c
index 8e62242..1972b72 100644
--- a/drivers/staging/ft1000/ft1000-usb/ft1000_download.c
+++ b/drivers/staging/ft1000/ft1000-usb/ft1000_download.c
@@ -488,7 +488,7 @@ static int check_buffers(u16 *buff_w, u16 *buff_r, int len, int offset)
 // Parameters:  struct ft1000_device  - device structure
 //              u16 **pUsFile - DSP image file pointer in u16
 //              u8  **pUcFile - DSP image file pointer in u8
-//              long   word_length - lenght of the buffer to be written
+//              long   word_length - length of the buffer to be written
 //                                   to DPRAM
 //
 // Returns:     STATUS_SUCCESS - success
@@ -628,7 +628,7 @@ static void usb_dnld_complete (struct urb *urb)
 // Parameters:  struct ft1000_device  - device structure
 //              u16 **pUsFile - DSP image file pointer in u16
 //              u8  **pUcFile - DSP image file pointer in u8
-//              long   word_length - lenght of the buffer to be written
+//              long   word_length - length of the buffer to be written
 //                                   to DPRAM
 //
 // Returns:     STATUS_SUCCESS - success
@@ -817,7 +817,7 @@ u16 scram_dnldr(struct ft1000_device *ft1000dev, void *pFileStart,
 						 * Error, beyond boot code range.
 						 */
 						DEBUG
-						    ("FT1000:download:Download error: Requested len=%d exceeds BOOT code boundry.\n",
+						    ("FT1000:download:Download error: Requested len=%d exceeds BOOT code boundary.\n",
 						     (int)word_length);
 						status = STATUS_FAILURE;
 						break;
@@ -950,7 +950,7 @@ u16 scram_dnldr(struct ft1000_device *ft1000dev, void *pFileStart,
 						 * Error, beyond boot code range.
 						 */
 						DEBUG
-						    ("FT1000:download:Download error: Requested len=%d exceeds DSP code boundry.\n",
+						    ("FT1000:download:Download error: Requested len=%d exceeds DSP code boundary.\n",
 						     (int)word_length);
 						status = STATUS_FAILURE;
 						break;
diff --git a/drivers/staging/ft1000/ft1000-usb/ft1000_hw.c b/drivers/staging/ft1000/ft1000-usb/ft1000_hw.c
index 78dcd49..684e69e 100644
--- a/drivers/staging/ft1000/ft1000-usb/ft1000_hw.c
+++ b/drivers/staging/ft1000/ft1000-usb/ft1000_hw.c
@@ -585,7 +585,7 @@ int dsp_reload(struct ft1000_device *ft1000dev)
 //---------------------------------------------------------------------------
 //
 // Function:   ft1000_reset_asic
-// Descripton: This function will call the Card Service function to reset the
+// Description: This function will call the Card Service function to reset the
 //             ASIC.
 // Input:
 //     dev    - device structure
@@ -626,7 +626,7 @@ static void ft1000_reset_asic(struct net_device *dev)
 //---------------------------------------------------------------------------
 //
 // Function:   ft1000_reset_card
-// Descripton: This function will reset the card
+// Description: This function will reset the card
 // Input:
 //     dev    - device structure
 // Output:
@@ -917,7 +917,7 @@ static void ft1000_usb_transmit_complete(struct urb *urb)
 //---------------------------------------------------------------------------
 //
 // Function:   ft1000_copy_down_pkt
-// Descripton: This function will take an ethernet packet and convert it to
+// Description: This function will take an ethernet packet and convert it to
 //             a Flarion packet prior to sending it to the ASIC Downlink
 //             FIFO.
 // Input:
@@ -1075,10 +1075,10 @@ err:
 //---------------------------------------------------------------------------
 //
 // Function:   ft1000_copy_up_pkt
-// Descripton: This function will take a packet from the FIFO up link and
+// Description: This function will take a packet from the FIFO up link and
 //             convert it into an ethernet packet and deliver it to the IP stack
 // Input:
-//     urb - the receving usb urb
+//     urb - the receiving usb urb
 //
 // Output:
 //     status - FAILURE
@@ -1182,7 +1182,7 @@ static int ft1000_copy_up_pkt(struct urb *urb)
 //---------------------------------------------------------------------------
 //
 // Function:   ft1000_submit_rx_urb
-// Descripton: the receiving function of the network driver
+// Description: the receiving function of the network driver
 //
 // Input:
 //     info - a private structure contains the device information
@@ -1316,7 +1316,7 @@ Jim
 //---------------------------------------------------------------------------
 //
 // Function:   ft1000_chkcard
-// Descripton: This function will check if the device is presently available on
+// Description: This function will check if the device is presently available on
 //             the system.
 // Input:
 //     dev    - device structure
@@ -1363,7 +1363,7 @@ static int ft1000_chkcard(struct ft1000_device *dev)
 //---------------------------------------------------------------------------
 //
 // Function:   ft1000_receive_cmd
-// Descripton: This function will read a message from the dpram area.
+// Description: This function will read a message from the dpram area.
 // Input:
 //    dev - network device structure
 //    pbuffer - caller supply address to buffer
diff --git a/drivers/staging/ft1000/ft1000-usb/ft1000_ioctl.h b/drivers/staging/ft1000/ft1000-usb/ft1000_ioctl.h
index 3f72d5b..6a8a196 100644
--- a/drivers/staging/ft1000/ft1000-usb/ft1000_ioctl.h
+++ b/drivers/staging/ft1000/ft1000-usb/ft1000_ioctl.h
@@ -55,7 +55,7 @@ struct pseudo_hdr {
    unsigned char     seq_num;          //sequence number
    unsigned char     rsvd2;            //reserved
    unsigned short    qos_class;        //Quality of Service class (Not applicable on Mobile)
-   unsigned short    checksum;         //Psuedo header checksum
+   unsigned short    checksum;         //Pseudo header checksum
 } __attribute__ ((packed));
 
 typedef struct _IOCTL_GET_VER
diff --git a/drivers/staging/ft1000/ft1000-usb/ft1000_usb.h b/drivers/staging/ft1000/ft1000-usb/ft1000_usb.h
index e047c03..f2ecb3e 100644
--- a/drivers/staging/ft1000/ft1000-usb/ft1000_usb.h
+++ b/drivers/staging/ft1000/ft1000-usb/ft1000_usb.h
@@ -364,7 +364,7 @@ struct prov_record {
 
 #define ISR_EMPTY			(u8)0x00 	 // no bits set in ISR
 
-#define ISR_DOORBELL_ACK	(u8)0x01		 //  the doorbell i sent has been recieved.
+#define ISR_DOORBELL_ACK	(u8)0x01		 //  the doorbell i sent has been received.
 
 #define ISR_DOORBELL_PEND	(u8)0x02 	 //  doorbell for me
 
diff --git a/drivers/staging/generic_serial/generic_serial.c b/drivers/staging/generic_serial/generic_serial.c
index 466988d..f29dda4 100644
--- a/drivers/staging/generic_serial/generic_serial.c
+++ b/drivers/staging/generic_serial/generic_serial.c
@@ -113,7 +113,7 @@ int gs_write(struct tty_struct * tty,
 
 		c = count;
  
-		/* This is safe because we "OWN" the "head". Noone else can 
+		/* This is safe because we "OWN" the "head". No one else can 
 		   change the "head": we own the port_write_mutex. */
 		/* Don't overrun the end of the buffer */
 		t = SERIAL_XMIT_SIZE - port->xmit_head;
diff --git a/drivers/staging/generic_serial/rio/map.h b/drivers/staging/generic_serial/rio/map.h
index 8366978..28a6612 100644
--- a/drivers/staging/generic_serial/rio/map.h
+++ b/drivers/staging/generic_serial/rio/map.h
@@ -87,7 +87,7 @@ struct Map {
 ** The Topology array contains the ID of the unit connected to each of the
 ** four links on this unit. The entry will be 0xFFFF if NOTHING is connected
 ** to the link, or will be 0xFF00 if an UNKNOWN unit is connected to the link.
-** The Name field is a null-terminated string, upto 31 characters, containing
+** The Name field is a null-terminated string, up to 31 characters, containing
 ** the 'cute' name that the sysadmin/users know the RTA by. It is permissible
 ** for this string to contain any character in the range \040 to \176 inclusive.
 ** In particular, ctrl sequences and DEL (0x7F, \177) are not allowed. The
diff --git a/drivers/staging/generic_serial/rio/rioboot.c b/drivers/staging/generic_serial/rio/rioboot.c
index d956dd3..ffa01c5 100644
--- a/drivers/staging/generic_serial/rio/rioboot.c
+++ b/drivers/staging/generic_serial/rio/rioboot.c
@@ -109,7 +109,7 @@ int RIOBootCodeRTA(struct rio_info *p, struct DownLoad * rbp)
 	rio_dprintk(RIO_DEBUG_BOOT, "Data at user address %p\n", rbp->DataP);
 
 	/*
-	 ** Check that we have set asside enough memory for this
+	 ** Check that we have set aside enough memory for this
 	 */
 	if (rbp->Count > SIXTY_FOUR_K) {
 		rio_dprintk(RIO_DEBUG_BOOT, "RTA Boot Code Too Large!\n");
@@ -293,7 +293,7 @@ int RIOBootCodeHOST(struct rio_info *p, struct DownLoad *rbp)
 		/*
 		 **                     S T O P !
 		 **
-		 ** Upto this point the code has been fairly rational, and possibly
+		 ** Up to this point the code has been fairly rational, and possibly
 		 ** even straight forward. What follows is a pile of crud that will
 		 ** magically turn into six bytes of transputer assembler. Normally
 		 ** you would expect an array or something, but, being me, I have
@@ -419,7 +419,7 @@ int RIOBootCodeHOST(struct rio_info *p, struct DownLoad *rbp)
 		rio_dprintk(RIO_DEBUG_BOOT, "Set control port\n");
 
 		/*
-		 ** Now, wait for upto five seconds for the Tp to setup the parmmap
+		 ** Now, wait for up to five seconds for the Tp to setup the parmmap
 		 ** pointer:
 		 */
 		for (wait_count = 0; (wait_count < p->RIOConf.StartupTime) && (readw(&HostP->__ParmMapR) == OldParmMap); wait_count++) {
@@ -475,7 +475,7 @@ int RIOBootCodeHOST(struct rio_info *p, struct DownLoad *rbp)
 
 		/*
 		 ** now wait for the card to set all the parmmap->XXX stuff
-		 ** this is a wait of upto two seconds....
+		 ** this is a wait of up to two seconds....
 		 */
 		rio_dprintk(RIO_DEBUG_BOOT, "Looking for init_done - %d ticks\n", p->RIOConf.StartupTime);
 		HostP->timeout_id = 0;
diff --git a/drivers/staging/generic_serial/rio/riocmd.c b/drivers/staging/generic_serial/rio/riocmd.c
index f121357..61efd53 100644
--- a/drivers/staging/generic_serial/rio/riocmd.c
+++ b/drivers/staging/generic_serial/rio/riocmd.c
@@ -863,7 +863,7 @@ int RIOUnUse(unsigned long iPortP, struct CmdBlk *CmdBlkP)
 	 ** being transferred from the write queue into the transmit packets
 	 ** (add_transmit) and no furthur transmit interrupt will be sent for that
 	 ** data. The next interrupt will occur up to 500ms later (RIOIntr is called
-	 ** twice a second as a saftey measure). This was the case when kermit was
+	 ** twice a second as a safety measure). This was the case when kermit was
 	 ** used to send data into a RIO port. After each packet was sent, TCFLSH
 	 ** was called to flush the read queue preemptively. PortP->InUse was
 	 ** incremented, thereby blocking the 6 byte acknowledgement packet
diff --git a/drivers/staging/generic_serial/rio/rioroute.c b/drivers/staging/generic_serial/rio/rioroute.c
index f9b936a..8757378 100644
--- a/drivers/staging/generic_serial/rio/rioroute.c
+++ b/drivers/staging/generic_serial/rio/rioroute.c
@@ -450,7 +450,7 @@ int RIORouteRup(struct rio_info *p, unsigned int Rup, struct Host *HostP, struct
 		 ** we reset the unit, because we didn't boot it.
 		 ** However, if the table is full, it could be that we did boot
 		 ** this unit, and so we won't reboot it, because it isn't really
-		 ** all that disasterous to keep the old bins in most cases. This
+		 ** all that disastrous to keep the old bins in most cases. This
 		 ** is a rather tacky feature, but we are on the edge of reallity
 		 ** here, because the implication is that someone has connected
 		 ** 16+MAX_EXTRA_UNITS onto one host.
@@ -678,7 +678,7 @@ static int RIOCheck(struct Host *HostP, unsigned int UnitId)
 
 	HostP->Mapping[UnitId].Flags &= ~BEEN_HERE;
 
-	/* rio_dprint(RIO_DEBUG_ROUTE, ("Unit %d DOESNT KNOW THE HOST!\n", UnitId)); */
+	/* rio_dprint(RIO_DEBUG_ROUTE, ("Unit %d DOESN'T KNOW THE HOST!\n", UnitId)); */
 
 	return 0;
 }
diff --git a/drivers/staging/generic_serial/rio/riotty.c b/drivers/staging/generic_serial/rio/riotty.c
index 8a90393..e7e9911 100644
--- a/drivers/staging/generic_serial/rio/riotty.c
+++ b/drivers/staging/generic_serial/rio/riotty.c
@@ -124,7 +124,7 @@ int riotopen(struct tty_struct *tty, struct file *filp)
 	}
 
 	/*
-	 ** Grab pointer to the port stucture
+	 ** Grab pointer to the port structure
 	 */
 	PortP = p->RIOPortp[SysPort];	/* Get control struc */
 	rio_dprintk(RIO_DEBUG_TTY, "PortP: %p\n", PortP);
@@ -161,7 +161,7 @@ int riotopen(struct tty_struct *tty, struct file *filp)
 	}
 
 	/*
-	 ** If the RTA has not booted yet and the user has choosen to block
+	 ** If the RTA has not booted yet and the user has chosen to block
 	 ** until the RTA is present then we must spin here waiting for
 	 ** the RTA to boot.
 	 */
diff --git a/drivers/staging/generic_serial/sx.c b/drivers/staging/generic_serial/sx.c
index 1291462..4f94aaf 100644
--- a/drivers/staging/generic_serial/sx.c
+++ b/drivers/staging/generic_serial/sx.c
@@ -158,13 +158,13 @@
  * Readying for release on 2.0.x (sorry David, 1.01 becomes 1.1 for RCS). 
  *
  * Revision 0.12  1999/03/28 09:20:10  wolff
- * Fixed problem in 0.11, continueing cleanup.
+ * Fixed problem in 0.11, continuing cleanup.
  *
  * Revision 0.11  1999/03/28 08:46:44  wolff
  * cleanup. Not good.
  *
  * Revision 0.10  1999/03/28 08:09:43  wolff
- * Fixed loosing characters on close.
+ * Fixed losing characters on close.
  *
  * Revision 0.9  1999/03/21 22:52:01  wolff
  * Ported back to 2.2.... (minor things)
@@ -1588,7 +1588,7 @@ static void sx_close(void *ptr)
 #define R0		if (read_sx_byte(board, i) != 0x55) return 1
 #define R1		if (read_sx_byte(board, i) != 0xaa) return 1
 
-/* This memtest takes a human-noticable time. You normally only do it
+/* This memtest takes a human-noticeable time. You normally only do it
    once a boot, so I guess that it is worth it. */
 static int do_memtest(struct sx_board *board, int min, int max)
 {
@@ -1645,7 +1645,7 @@ static int do_memtest(struct sx_board *board, int min, int max)
 #define R1		if (read_sx_word(board, i) != 0xaa55) return 1
 
 #if 0
-/* This memtest takes a human-noticable time. You normally only do it
+/* This memtest takes a human-noticeable time. You normally only do it
    once a boot, so I guess that it is worth it. */
 static int do_memtest_w(struct sx_board *board, int min, int max)
 {
diff --git a/drivers/staging/gma500/psb_drm.h b/drivers/staging/gma500/psb_drm.h
index fb9b424..a339406 100644
--- a/drivers/staging/gma500/psb_drm.h
+++ b/drivers/staging/gma500/psb_drm.h
@@ -131,7 +131,7 @@ struct drm_psb_reloc {
 	u32 pre_add;	/* Destination format: */
 	u32 background;	/* Destination add */
 	u32 dst_buffer;	/* Destination buffer. Index into buffer_list */
-	u32 arg0;		/* Reloc-op dependant */
+	u32 arg0;		/* Reloc-op dependent */
 	u32 arg1;
 };
 
diff --git a/drivers/staging/gma500/psb_drv.c b/drivers/staging/gma500/psb_drv.c
index 44cd095..d01d45e 100644
--- a/drivers/staging/gma500/psb_drv.c
+++ b/drivers/staging/gma500/psb_drv.c
@@ -561,7 +561,7 @@ static int psb_driver_unload(struct drm_device *dev)
 		kfree(dev_priv);
 		dev->dev_private = NULL;
 
-		/*destory VBT data*/
+		/*destroy VBT data*/
 		psb_intel_destroy_bios(dev);
 	}
 
diff --git a/drivers/staging/gma500/psb_intel_bios.c b/drivers/staging/gma500/psb_intel_bios.c
index f5bcd11..48ac8ba 100644
--- a/drivers/staging/gma500/psb_intel_bios.c
+++ b/drivers/staging/gma500/psb_intel_bios.c
@@ -271,7 +271,7 @@ bool psb_intel_init_bios(struct drm_device *dev)
 }
 
 /**
- * Destory and free VBT data
+ * Destroy and free VBT data
  */
 void psb_intel_destroy_bios(struct drm_device *dev)
 {
diff --git a/drivers/staging/gma500/psb_intel_sdvo.c b/drivers/staging/gma500/psb_intel_sdvo.c
index 731a5a2..1d2bb02 100644
--- a/drivers/staging/gma500/psb_intel_sdvo.c
+++ b/drivers/staging/gma500/psb_intel_sdvo.c
@@ -573,7 +573,7 @@ static bool psb_sdvo_set_current_inoutmap(struct psb_intel_output *output,
 	/* Make all fields of the  args/ret to zero */
 	memset(byArgs, 0, sizeof(byArgs));
 
-	/* Fill up the arguement values; */
+	/* Fill up the argument values; */
 	byArgs[0] = (u8) (in0outputmask & 0xFF);
 	byArgs[1] = (u8) ((in0outputmask >> 8) & 0xFF);
 	byArgs[2] = (u8) (in1outputmask & 0xFF);
diff --git a/drivers/staging/gma500/psb_intel_sdvo_regs.h b/drivers/staging/gma500/psb_intel_sdvo_regs.h
index a1d1475..c7107a3 100644
--- a/drivers/staging/gma500/psb_intel_sdvo_regs.h
+++ b/drivers/staging/gma500/psb_intel_sdvo_regs.h
@@ -217,7 +217,7 @@ struct psb_intel_sdvo_set_target_input_args {
 } __attribute__ ((packed));
 
 /**
- * Takes a struct psb_intel_sdvo_output_flags of which outputs are targetted by
+ * Takes a struct psb_intel_sdvo_output_flags of which outputs are targeted by
  * future output commands.
  *
  * Affected commands inclue SET_OUTPUT_TIMINGS_PART[12],
diff --git a/drivers/staging/gma500/psb_ttm_fence_user.h b/drivers/staging/gma500/psb_ttm_fence_user.h
index fc13f89..762a057 100644
--- a/drivers/staging/gma500/psb_ttm_fence_user.h
+++ b/drivers/staging/gma500/psb_ttm_fence_user.h
@@ -130,7 +130,7 @@ struct ttm_fence_unref_arg {
 };
 
 /*
- * Ioctl offsets frome extenstion start.
+ * Ioctl offsets from extenstion start.
  */
 
 #define TTM_FENCE_SIGNALED 0x01
diff --git a/drivers/staging/go7007/go7007.txt b/drivers/staging/go7007/go7007.txt
index 06a76da..9db1f39 100644
--- a/drivers/staging/go7007/go7007.txt
+++ b/drivers/staging/go7007/go7007.txt
@@ -2,7 +2,7 @@ This is a driver for the WIS GO7007SB multi-format video encoder.
 
 Pete Eberlein <pete@sensoray.com>
 
-The driver was orignally released under the GPL and is currently hosted at:
+The driver was originally released under the GPL and is currently hosted at:
 http://nikosapi.org/wiki/index.php/WIS_Go7007_Linux_driver
 The go7007 firmware can be acquired from the package on the site above.
 
diff --git a/drivers/staging/hv/blkvsc_drv.c b/drivers/staging/hv/blkvsc_drv.c
index af78993..68ad17d 100644
--- a/drivers/staging/hv/blkvsc_drv.c
+++ b/drivers/staging/hv/blkvsc_drv.c
@@ -894,7 +894,7 @@ static int blkvsc_submit_request(struct blkvsc_request *blkvsc_req,
 
 /*
  * We break the request into 1 or more blkvsc_requests and submit
- * them.  If we cant submit them all, we put them on the
+ * them.  If we can't submit them all, we put them on the
  * pending_list. The blkvsc_request() will work on the pending_list.
  */
 static int blkvsc_do_request(struct block_device_context *blkdev,
diff --git a/drivers/staging/hv/channel.c b/drivers/staging/hv/channel.c
index 775a52a..f7ce7d2 100644
--- a/drivers/staging/hv/channel.c
+++ b/drivers/staging/hv/channel.c
@@ -81,14 +81,14 @@ static void vmbus_setevent(struct vmbus_channel *channel)
 
 	if (channel->offermsg.monitor_allocated) {
 		/* Each u32 represents 32 channels */
-		set_bit(channel->offermsg.child_relid & 31,
+		sync_set_bit(channel->offermsg.child_relid & 31,
 			(unsigned long *) vmbus_connection.send_int_page +
 			(channel->offermsg.child_relid >> 5));
 
 		monitorpage = vmbus_connection.monitor_pages;
 		monitorpage++; /* Get the child to parent monitor page */
 
-		set_bit(channel->monitor_bit,
+		sync_set_bit(channel->monitor_bit,
 			(unsigned long *)&monitorpage->trigger_group
 					[channel->monitor_grp].pending);
 
@@ -104,7 +104,7 @@ static void VmbusChannelClearEvent(struct vmbus_channel *channel)
 
 	if (Channel->offermsg.monitor_allocated) {
 		/* Each u32 represents 32 channels */
-		clear_bit(Channel->offermsg.child_relid & 31,
+		sync_clear_bit(Channel->offermsg.child_relid & 31,
 			  (unsigned long *)vmbus_connection.send_int_page +
 			  (Channel->offermsg.child_relid >> 5));
 
@@ -112,7 +112,7 @@ static void VmbusChannelClearEvent(struct vmbus_channel *channel)
 			vmbus_connection.monitor_pages;
 		monitorPage++; /* Get the child to parent monitor page */
 
-		clear_bit(Channel->monitor_bit,
+		sync_clear_bit(Channel->monitor_bit,
 			  (unsigned long *)&monitorPage->trigger_group
 					[Channel->monitor_grp].Pending);
 	}
diff --git a/drivers/staging/hv/channel_mgmt.c b/drivers/staging/hv/channel_mgmt.c
index bc0393a..06b5732 100644
--- a/drivers/staging/hv/channel_mgmt.c
+++ b/drivers/staging/hv/channel_mgmt.c
@@ -166,7 +166,7 @@ EXPORT_SYMBOL(prep_negotiate_resp);
  * from Hyper-V. This stub responds to the default negotiate messages
  * that come in for every non IDE/SCSI/Network request.
  * This behavior is normally overwritten in the hv_utils driver. That
- * driver handles requests like gracefull shutdown, heartbeats etc.
+ * driver handles requests like graceful shutdown, heartbeats etc.
  *
  * Mainly used by Hyper-V drivers.
  */
diff --git a/drivers/staging/hv/connection.c b/drivers/staging/hv/connection.c
index 44b203b..afc8116 100644
--- a/drivers/staging/hv/connection.c
+++ b/drivers/staging/hv/connection.c
@@ -296,7 +296,7 @@ void vmbus_on_event(unsigned long data)
 		for (dword = 0; dword < maxdword; dword++) {
 			if (recv_int_page[dword]) {
 				for (bit = 0; bit < 32; bit++) {
-					if (test_and_clear_bit(bit,
+					if (sync_test_and_clear_bit(bit,
 						(unsigned long *)
 						&recv_int_page[dword])) {
 						relid = (dword << 5) + bit;
@@ -338,7 +338,7 @@ int vmbus_post_msg(void *buffer, size_t buflen)
 int vmbus_set_event(u32 child_relid)
 {
 	/* Each u32 represents 32 channels */
-	set_bit(child_relid & 31,
+	sync_set_bit(child_relid & 31,
 		(unsigned long *)vmbus_connection.send_int_page +
 		(child_relid >> 5));
 
diff --git a/drivers/staging/hv/hv.c b/drivers/staging/hv/hv.c
index 2d492ad..0b06f4f 100644
--- a/drivers/staging/hv/hv.c
+++ b/drivers/staging/hv/hv.c
@@ -37,7 +37,7 @@ struct hv_context hv_context = {
 
 /*
  * query_hypervisor_presence
- * - Query the cpuid for presense of windows hypervisor
+ * - Query the cpuid for presence of windows hypervisor
  */
 static int query_hypervisor_presence(void)
 {
diff --git a/drivers/staging/hv/hv_api.h b/drivers/staging/hv/hv_api.h
index 7114fce..43a7228 100644
--- a/drivers/staging/hv/hv_api.h
+++ b/drivers/staging/hv/hv_api.h
@@ -53,14 +53,14 @@ struct hv_guid {
 
 /*
  * HV_STATUS_INVALID_ALIGNMENT
- * The hypervisor could not perform the operation beacuse a parameter has an
+ * The hypervisor could not perform the operation because a parameter has an
  * invalid alignment.
  */
 #define HV_STATUS_INVALID_ALIGNMENT			((u16)0x0004)
 
 /*
  * HV_STATUS_INVALID_PARAMETER
- * The hypervisor could not perform the operation beacuse an invalid parameter
+ * The hypervisor could not perform the operation because an invalid parameter
  * was specified.
  */
 #define HV_STATUS_INVALID_PARAMETER			((u16)0x0005)
diff --git a/drivers/staging/hv/hv_kvp.h b/drivers/staging/hv/hv_kvp.h
index e069f59..8c402f3 100644
--- a/drivers/staging/hv/hv_kvp.h
+++ b/drivers/staging/hv/hv_kvp.h
@@ -36,7 +36,7 @@
  * registry.
  *
  * Note:  This value is used in defining the KVP exchange message - this value
- * cannot be modified without affecting the message size and compatability.
+ * cannot be modified without affecting the message size and compatibility.
  */
 
 /*
diff --git a/drivers/staging/hv/hv_mouse.c b/drivers/staging/hv/hv_mouse.c
index 50147f8..118c7be 100644
--- a/drivers/staging/hv/hv_mouse.c
+++ b/drivers/staging/hv/hv_mouse.c
@@ -14,6 +14,7 @@
  */
 #include <linux/init.h>
 #include <linux/module.h>
+#include <linux/delay.h>
 #include <linux/device.h>
 #include <linux/workqueue.h>
 #include <linux/sched.h>
@@ -23,6 +24,7 @@
 #include <linux/hiddev.h>
 #include <linux/pci.h>
 #include <linux/dmi.h>
+#include <linux/delay.h>
 
 #include "hv_api.h"
 #include "logging.h"
@@ -374,7 +376,7 @@ static void MousevscOnReceiveDeviceInfo(struct mousevsc_dev *InputDevice, struct
 	       desc->desc[0].wDescriptorLength);
 
 	/* Send the ack */
-	memset(&ack, sizeof(struct mousevsc_prt_msg), 0);
+	memset(&ack, 0, sizeof(struct mousevsc_prt_msg));
 
 	ack.type = PipeMessageData;
 	ack.size = sizeof(struct synthhid_device_info_ack);
@@ -595,7 +597,7 @@ static int MousevscConnectToVsp(struct hv_device *Device)
 	/*
 	 * Now, initiate the vsc/vsp initialization protocol on the open channel
 	 */
-	memset(request, sizeof(struct mousevsc_prt_msg), 0);
+	memset(request, 0, sizeof(struct mousevsc_prt_msg));
 
 	request->type = PipeMessageData;
 	request->size = sizeof(struct synthhid_protocol_request);
diff --git a/drivers/staging/hv/hv_util.c b/drivers/staging/hv/hv_util.c
index 4792f2c..2df1568 100644
--- a/drivers/staging/hv/hv_util.c
+++ b/drivers/staging/hv/hv_util.c
@@ -80,7 +80,7 @@ static void shutdown_onchannelcallback(void *context)
 				execute_shutdown = true;
 
 				DPRINT_INFO(VMBUS, "Shutdown request received -"
-					    " gracefull shutdown initiated");
+					    " graceful shutdown initiated");
 				break;
 			default:
 				icmsghdrp->status = HV_E_FAIL;
diff --git a/drivers/staging/hv/netvsc_drv.c b/drivers/staging/hv/netvsc_drv.c
index 2d40f5f..3397356 100644
--- a/drivers/staging/hv/netvsc_drv.c
+++ b/drivers/staging/hv/netvsc_drv.c
@@ -46,6 +46,7 @@ struct net_device_context {
 	/* point back to our device context */
 	struct hv_device *device_ctx;
 	unsigned long avail;
+	struct work_struct work;
 };
 
 
@@ -219,6 +220,7 @@ static void netvsc_linkstatus_callback(struct hv_device *device_obj,
 				       unsigned int status)
 {
 	struct net_device *net = dev_get_drvdata(&device_obj->device);
+	struct net_device_context *ndev_ctx;
 
 	if (!net) {
 		DPRINT_ERR(NETVSC_DRV, "got link status but net device "
@@ -230,6 +232,8 @@ static void netvsc_linkstatus_callback(struct hv_device *device_obj,
 		netif_carrier_on(net);
 		netif_wake_queue(net);
 		netif_notify_peers(net);
+		ndev_ctx = netdev_priv(net);
+		schedule_work(&ndev_ctx->work);
 	} else {
 		netif_carrier_off(net);
 		netif_stop_queue(net);
@@ -328,6 +332,25 @@ static const struct net_device_ops device_ops = {
 	.ndo_set_mac_address =		eth_mac_addr,
 };
 
+/*
+ * Send GARP packet to network peers after migrations.
+ * After Quick Migration, the network is not immediately operational in the
+ * current context when receiving RNDIS_STATUS_MEDIA_CONNECT event. So, add
+ * another netif_notify_peers() into a scheduled work, otherwise GARP packet
+ * will not be sent after quick migration, and cause network disconnection.
+ */
+static void netvsc_send_garp(struct work_struct *w)
+{
+	struct net_device_context *ndev_ctx;
+	struct net_device *net;
+
+	msleep(20);
+	ndev_ctx = container_of(w, struct net_device_context, work);
+	net = dev_get_drvdata(&ndev_ctx->device_ctx->device);
+	netif_notify_peers(net);
+}
+
+
 static int netvsc_probe(struct device *device)
 {
 	struct hv_driver *drv =
@@ -353,6 +376,7 @@ static int netvsc_probe(struct device *device)
 	net_device_ctx->device_ctx = device_obj;
 	net_device_ctx->avail = ring_size;
 	dev_set_drvdata(device, net);
+	INIT_WORK(&net_device_ctx->work, netvsc_send_garp);
 
 	/* Notify the netvsc driver of the new device */
 	ret = net_drv_obj->base.dev_add(device_obj, &device_info);
diff --git a/drivers/staging/hv/rndis_filter.c b/drivers/staging/hv/rndis_filter.c
index e7189cd..048376b 100644
--- a/drivers/staging/hv/rndis_filter.c
+++ b/drivers/staging/hv/rndis_filter.c
@@ -585,7 +585,7 @@ static int rndis_filter_set_packet_filter(struct rndis_device *dev,
 		ret = -1;
 		DPRINT_ERR(NETVSC, "timeout before we got a set response...");
 		/*
-		 * We cant deallocate the request since we may still receive a
+		 * We can't deallocate the request since we may still receive a
 		 * send completion for it.
 		 */
 		goto Exit;
diff --git a/drivers/staging/hv/tools/hv_kvp_daemon.c b/drivers/staging/hv/tools/hv_kvp_daemon.c
index f5a2dd6..33f0f1c 100644
--- a/drivers/staging/hv/tools/hv_kvp_daemon.c
+++ b/drivers/staging/hv/tools/hv_kvp_daemon.c
@@ -102,22 +102,22 @@ static char kvp_send_buffer[4096];
 static char kvp_recv_buffer[4096];
 static struct sockaddr_nl addr;
 
-static char os_name[100];
-static char os_major[50];
-static char os_minor[50];
-static char processor_arch[50];
-static char os_build[100];
+static char *os_name = "";
+static char *os_major = "";
+static char *os_minor = "";
+static char *processor_arch;
+static char *os_build;
 static char *lic_version;
+static struct utsname uts_buf;
 
 void kvp_get_os_info(void)
 {
 	FILE	*file;
-	char	*eol;
-	struct utsname buf;
+	char	*p, buf[512];
 
-	uname(&buf);
-	strcpy(os_build, buf.release);
-	strcpy(processor_arch, buf.machine);
+	uname(&uts_buf);
+	os_build = uts_buf.release;
+	processor_arch= uts_buf.machine;
 
 	file = fopen("/etc/SuSE-release", "r");
 	if (file != NULL)
@@ -132,21 +132,46 @@ void kvp_get_os_info(void)
 	/*
 	 * We don't have information about the os.
 	 */
-	strcpy(os_name, "Linux");
-	strcpy(os_major, "0");
-	strcpy(os_minor, "0");
+	os_name = uts_buf.sysname;
 	return;
 
 kvp_osinfo_found:
-	fgets(os_name, 99, file);
-	eol = index(os_name, '\n');
-	*eol = '\0';
-	fgets(os_major, 49, file);
-	eol = index(os_major, '\n');
-	*eol = '\0';
-	fgets(os_minor, 49, file);
-	eol = index(os_minor, '\n');
-	*eol = '\0';
+	/* up to three lines */
+	p = fgets(buf, sizeof(buf), file);
+	if (p) {
+		p = strchr(buf, '\n');
+		if (p)
+			*p = '\0';
+		p = strdup(buf);
+		if (!p)
+			goto done;
+		os_name = p;
+
+		/* second line */
+		p = fgets(buf, sizeof(buf), file);
+		if (p) {
+			p = strchr(buf, '\n');
+			if (p)
+				*p = '\0';
+			p = strdup(buf);
+			if (!p)
+				goto done;
+			os_major = p;
+
+			/* third line */
+			p = fgets(buf, sizeof(buf), file);
+			if (p)  {
+				p = strchr(buf, '\n');
+				if (p)
+					*p = '\0';
+				p = strdup(buf);
+				if (p)
+					os_minor = p;
+			}
+		}
+	}
+
+done:
 	fclose(file);
 	return;
 }
@@ -202,7 +227,7 @@ kvp_get_ip_address(int family, char *buffer, int length)
 
 			/*
 			 * We only support AF_INET and AF_INET6
-			 * and the list of addresses is seperated by a ";".
+			 * and the list of addresses is separated by a ";".
 			 */
 				struct sockaddr_in6 *addr =
 				(struct sockaddr_in6 *) curp->ifa_addr;
@@ -293,7 +318,7 @@ netlink_send(int fd, struct cn_msg *msg)
 	return sendmsg(fd, &message, 0);
 }
 
-main(void)
+int main(void)
 {
 	int fd, len, sock_opt;
 	int error;
@@ -301,9 +326,10 @@ main(void)
 	struct pollfd pfd;
 	struct nlmsghdr *incoming_msg;
 	struct cn_msg	*incoming_cn_msg;
+	struct hv_ku_msg *hv_msg;
+	char	*p;
 	char	*key_value;
 	char	*key_name;
-	int	 key_index;
 
 	daemon(1, 0);
 	openlog("KVP", 0, LOG_USER);
@@ -373,9 +399,10 @@ main(void)
 			 * Driver is registering with us; stash away the version
 			 * information.
 			 */
-			lic_version = malloc(strlen(incoming_cn_msg->data) + 1);
+			p = (char *)incoming_cn_msg->data;
+			lic_version = malloc(strlen(p) + 1);
 			if (lic_version) {
-				strcpy(lic_version, incoming_cn_msg->data);
+				strcpy(lic_version, p);
 				syslog(LOG_INFO, "KVP LIC Version: %s",
 					lic_version);
 			} else {
@@ -389,14 +416,11 @@ main(void)
 			continue;
 		}
 
-		key_index =
-		((struct hv_ku_msg *)incoming_cn_msg->data)->kvp_index;
-		key_name =
-		((struct hv_ku_msg *)incoming_cn_msg->data)->kvp_key;
-		key_value =
-		((struct hv_ku_msg *)incoming_cn_msg->data)->kvp_value;
+		hv_msg = (struct hv_ku_msg *)incoming_cn_msg->data;
+		key_name = (char *)hv_msg->kvp_key;
+		key_value = (char *)hv_msg->kvp_value;
 
-		switch (key_index) {
+		switch (hv_msg->kvp_index) {
 		case FullyQualifiedDomainName:
 			kvp_get_domain_name(key_value,
 					HV_KVP_EXCHANGE_MAX_VALUE_SIZE);
diff --git a/drivers/staging/hv/vmbus_drv.c b/drivers/staging/hv/vmbus_drv.c
index b473f46..79089f8 100644
--- a/drivers/staging/hv/vmbus_drv.c
+++ b/drivers/staging/hv/vmbus_drv.c
@@ -254,7 +254,7 @@ static int vmbus_on_isr(void)
 	event = (union hv_synic_event_flags *)page_addr + VMBUS_MESSAGE_SINT;
 
 	/* Since we are a child, we only need to check bit 0 */
-	if (test_and_clear_bit(0, (unsigned long *) &event->flags32[0])) {
+	if (sync_test_and_clear_bit(0, (unsigned long *) &event->flags32[0])) {
 		DPRINT_DBG(VMBUS, "received event %d", event->flags32[0]);
 		ret |= 0x2;
 	}
diff --git a/drivers/staging/hv/vmbus_private.h b/drivers/staging/hv/vmbus_private.h
index ca050a4..6f0d8df 100644
--- a/drivers/staging/hv/vmbus_private.h
+++ b/drivers/staging/hv/vmbus_private.h
@@ -31,6 +31,7 @@
 #include "channel_mgmt.h"
 #include "ring_buffer.h"
 #include <linux/list.h>
+#include <asm/sync_bitops.h>
 
 
 /*
diff --git a/drivers/staging/iio/Documentation/iio_utils.h b/drivers/staging/iio/Documentation/iio_utils.h
index 8095727..fd78e4f 100644
--- a/drivers/staging/iio/Documentation/iio_utils.h
+++ b/drivers/staging/iio/Documentation/iio_utils.h
@@ -556,7 +556,7 @@ int _write_sysfs_string(char *filename, char *basedir, char *val, int verify)
 		if (strcmp(temp, val) != 0) {
 			printf("Possible failure in string write of %s "
 				"Should be %s "
-				"writen to %s\%s\n",
+				"written to %s\%s\n",
 				temp,
 				val,
 				basedir,
diff --git a/drivers/staging/iio/accel/adis16201.h b/drivers/staging/iio/accel/adis16201.h
index c9bf22c..23fe54d 100644
--- a/drivers/staging/iio/accel/adis16201.h
+++ b/drivers/staging/iio/accel/adis16201.h
@@ -70,7 +70,7 @@
  * @indio_dev:		industrial I/O device structure
  * @trig:		data ready trigger registered with iio
  * @tx:			transmit buffer
- * @rx:			recieve buffer
+ * @rx:			receive buffer
  * @buf_lock:		mutex to protect tx and rx
  **/
 struct adis16201_state {
diff --git a/drivers/staging/iio/accel/adis16203.h b/drivers/staging/iio/accel/adis16203.h
index b39323e..b886881 100644
--- a/drivers/staging/iio/accel/adis16203.h
+++ b/drivers/staging/iio/accel/adis16203.h
@@ -65,7 +65,7 @@
  * @indio_dev:		industrial I/O device structure
  * @trig:		data ready trigger registered with iio
  * @tx:			transmit buffer
- * @rx:			recieve buffer
+ * @rx:			receive buffer
  * @buf_lock:		mutex to protect tx and rx
  **/
 struct adis16203_state {
diff --git a/drivers/staging/iio/accel/adis16204.h b/drivers/staging/iio/accel/adis16204.h
index e9ed7cb..e618446 100644
--- a/drivers/staging/iio/accel/adis16204.h
+++ b/drivers/staging/iio/accel/adis16204.h
@@ -73,7 +73,7 @@
  * @indio_dev:		industrial I/O device structure
  * @trig:		data ready trigger registered with iio
  * @tx:			transmit buffer
- * @rx:			recieve buffer
+ * @rx:			receive buffer
  * @buf_lock:		mutex to protect tx and rx
  **/
 struct adis16204_state {
diff --git a/drivers/staging/iio/accel/adis16209.h b/drivers/staging/iio/accel/adis16209.h
index 4e97596..8b0da13 100644
--- a/drivers/staging/iio/accel/adis16209.h
+++ b/drivers/staging/iio/accel/adis16209.h
@@ -109,7 +109,7 @@
  * @indio_dev:		industrial I/O device structure
  * @trig:		data ready trigger registered with iio
  * @tx:			transmit buffer
- * @rx:			recieve buffer
+ * @rx:			receive buffer
  * @buf_lock:		mutex to protect tx and rx
  **/
 struct adis16209_state {
diff --git a/drivers/staging/iio/accel/adis16220.h b/drivers/staging/iio/accel/adis16220.h
index 7013314..4d5758c 100644
--- a/drivers/staging/iio/accel/adis16220.h
+++ b/drivers/staging/iio/accel/adis16220.h
@@ -132,7 +132,7 @@
  * @indio_dev:		industrial I/O device structure
  * @trig:		data ready trigger registered with iio
  * @tx:			transmit buffer
- * @rx:			recieve buffer
+ * @rx:			receive buffer
  * @buf_lock:		mutex to protect tx and rx
  **/
 struct adis16220_state {
diff --git a/drivers/staging/iio/accel/adis16240.h b/drivers/staging/iio/accel/adis16240.h
index 51a807d..76a4579 100644
--- a/drivers/staging/iio/accel/adis16240.h
+++ b/drivers/staging/iio/accel/adis16240.h
@@ -132,7 +132,7 @@
  * @indio_dev:		industrial I/O device structure
  * @trig:		data ready trigger registered with iio
  * @tx:			transmit buffer
- * @rx:			recieve buffer
+ * @rx:			receive buffer
  * @buf_lock:		mutex to protect tx and rx
  **/
 struct adis16240_state {
diff --git a/drivers/staging/iio/accel/lis3l02dq.h b/drivers/staging/iio/accel/lis3l02dq.h
index 579b3a2..1140218 100644
--- a/drivers/staging/iio/accel/lis3l02dq.h
+++ b/drivers/staging/iio/accel/lis3l02dq.h
@@ -57,7 +57,7 @@
 /* Reboot memory content */
 #define LIS3L02DQ_REG_CTRL_2_REBOOT_MEMORY	0x10
 
-/* Interupt Enable - applies data ready to the RDY pad */
+/* Interrupt Enable - applies data ready to the RDY pad */
 #define LIS3L02DQ_REG_CTRL_2_ENABLE_INTERRUPT	0x08
 
 /* Enable Data Ready Generation - relationship with previous unclear in docs */
@@ -70,34 +70,34 @@
  * - option for 16 bit left justified */
 #define LIS3L02DQ_REG_CTRL_2_DATA_ALIGNMENT_16_BIT_LEFT_JUSTIFIED	0x01
 
-/* Interupt related stuff */
+/* Interrupt related stuff */
 #define LIS3L02DQ_REG_WAKE_UP_CFG_ADDR			0x23
 
 /* Switch from or combination fo conditions to and */
 #define LIS3L02DQ_REG_WAKE_UP_CFG_BOOLEAN_AND		0x80
 
-/* Latch interupt request,
+/* Latch interrupt request,
  * if on ack must be given by reading the ack register */
 #define LIS3L02DQ_REG_WAKE_UP_CFG_LATCH_SRC		0x40
 
-/* Z Interupt on High (above threshold)*/
+/* Z Interrupt on High (above threshold)*/
 #define LIS3L02DQ_REG_WAKE_UP_CFG_INTERRUPT_Z_HIGH	0x20
-/* Z Interupt on Low */
+/* Z Interrupt on Low */
 #define LIS3L02DQ_REG_WAKE_UP_CFG_INTERRUPT_Z_LOW	0x10
-/* Y Interupt on High */
+/* Y Interrupt on High */
 #define LIS3L02DQ_REG_WAKE_UP_CFG_INTERRUPT_Y_HIGH	0x08
-/* Y Interupt on Low */
+/* Y Interrupt on Low */
 #define LIS3L02DQ_REG_WAKE_UP_CFG_INTERRUPT_Y_LOW	0x04
-/* X Interupt on High */
+/* X Interrupt on High */
 #define LIS3L02DQ_REG_WAKE_UP_CFG_INTERRUPT_X_HIGH	0x02
-/* X Interupt on Low */
+/* X Interrupt on Low */
 #define LIS3L02DQ_REG_WAKE_UP_CFG_INTERRUPT_X_LOW 0x01
 
-/* Register that gives description of what caused interupt
+/* Register that gives description of what caused interrupt
  * - latched if set in CFG_ADDRES */
 #define LIS3L02DQ_REG_WAKE_UP_SRC_ADDR			0x24
 /* top bit ignored */
-/* Interupt Active */
+/* Interrupt Active */
 #define LIS3L02DQ_REG_WAKE_UP_SRC_INTERRUPT_ACTIVATED	0x40
 /* Interupts that have been triggered */
 #define LIS3L02DQ_REG_WAKE_UP_SRC_INTERRUPT_Z_HIGH	0x20
@@ -123,7 +123,7 @@
 #define LIS3L02DQ_REG_STATUS_X_NEW_DATA			0x01
 
 /* The accelerometer readings - low and high bytes.
-Form of high byte dependant on justification set in ctrl reg */
+Form of high byte dependent on justification set in ctrl reg */
 #define LIS3L02DQ_REG_OUT_X_L_ADDR			0x28
 #define LIS3L02DQ_REG_OUT_X_H_ADDR			0x29
 #define LIS3L02DQ_REG_OUT_Y_L_ADDR			0x2A
@@ -155,7 +155,7 @@ Form of high byte dependant on justification set in ctrl reg */
  * @inter:		used to check if new interrupt has been triggered
  * @trig:		data ready trigger registered with iio
  * @tx:			transmit buffer
- * @rx:			recieve buffer
+ * @rx:			receive buffer
  * @buf_lock:		mutex to protect tx and rx
  **/
 struct lis3l02dq_state {
diff --git a/drivers/staging/iio/accel/lis3l02dq_core.c b/drivers/staging/iio/accel/lis3l02dq_core.c
index c4b4ab7..3067f96 100644
--- a/drivers/staging/iio/accel/lis3l02dq_core.c
+++ b/drivers/staging/iio/accel/lis3l02dq_core.c
@@ -77,7 +77,7 @@ int lis3l02dq_spi_read_reg_8(struct device *dev, u8 reg_address, u8 *val)
 /**
  * lis3l02dq_spi_write_reg_8() - write single byte to a register
  * @dev: device associated with child of actual device (iio_dev or iio_trig)
- * @reg_address: the address of the register to be writen
+ * @reg_address: the address of the register to be written
  * @val: the value to write
  **/
 int lis3l02dq_spi_write_reg_8(struct device *dev,
diff --git a/drivers/staging/iio/accel/lis3l02dq_ring.c b/drivers/staging/iio/accel/lis3l02dq_ring.c
index 2c461a3..529a3cc 100644
--- a/drivers/staging/iio/accel/lis3l02dq_ring.c
+++ b/drivers/staging/iio/accel/lis3l02dq_ring.c
@@ -217,7 +217,7 @@ static const u8 read_all_tx_array[] = {
 /**
  * lis3l02dq_read_all() Reads all channels currently selected
  * @st:		device specific state
- * @rx_array:	(dma capable) recieve array, must be at least
+ * @rx_array:	(dma capable) receive array, must be at least
  *		4*number of channels
  **/
 static int lis3l02dq_read_all(struct lis3l02dq_state *st, u8 *rx_array)
@@ -409,7 +409,7 @@ static const struct attribute_group lis3l02dq_trigger_attr_group = {
  *
  * As the trigger may occur on any data element being updated it is
  * really rather likely to occur during the read from the previous
- * trigger event.  The only way to discover if this has occured on
+ * trigger event.  The only way to discover if this has occurred on
  * boards not supporting level interrupts is to take a look at the line.
  * If it is indicating another interrupt and we don't seem to have a
  * handler looking at it, then we need to notify the core that we need
diff --git a/drivers/staging/iio/accel/sca3000.h b/drivers/staging/iio/accel/sca3000.h
index 2389284..db71033 100644
--- a/drivers/staging/iio/accel/sca3000.h
+++ b/drivers/staging/iio/accel/sca3000.h
@@ -185,7 +185,7 @@ struct sca3000_state {
 };
 
 /**
- * struct sca3000_chip_info - model dependant parameters
+ * struct sca3000_chip_info - model dependent parameters
  * @name: 			model identification
  * @scale:			string containing floating point scale factor
  * @temp_output:		some devices have temperature sensors.
@@ -213,7 +213,7 @@ struct sca3000_chip_info {
  * sca3000_read_data() read a series of values from the device
  * @dev:		device
  * @reg_address_high:	start address (decremented read)
- * @rx:			pointer where recieved data is placed. Callee
+ * @rx:			pointer where received data is placed. Callee
  *			responsible for freeing this.
  * @len:		number of bytes to read
  *
diff --git a/drivers/staging/iio/accel/sca3000_ring.c b/drivers/staging/iio/accel/sca3000_ring.c
index c872fdd..a730a76 100644
--- a/drivers/staging/iio/accel/sca3000_ring.c
+++ b/drivers/staging/iio/accel/sca3000_ring.c
@@ -43,7 +43,7 @@
  *			leading byte used in bus comms.
  *
  * Currently does not provide timestamps.  As the hardware doesn't add them they
- * can only be inferred aproximately from ring buffer events such as 50% full
+ * can only be inferred approximately from ring buffer events such as 50% full
  * and knowledge of when buffer was last emptied.  This is left to userspace.
  **/
 static int sca3000_rip_hw_rb(struct iio_ring_buffer *r,
diff --git a/drivers/staging/iio/adc/ad7298_ring.c b/drivers/staging/iio/adc/ad7298_ring.c
index 19d1ace..9068d7f 100644
--- a/drivers/staging/iio/adc/ad7298_ring.c
+++ b/drivers/staging/iio/adc/ad7298_ring.c
@@ -157,7 +157,7 @@ static int ad7298_ring_preenable(struct iio_dev *indio_dev)
 /**
  * ad7298_poll_func_th() th of trigger launched polling to ring buffer
  *
- * As sampling only occurs on spi comms occuring, leave timestamping until
+ * As sampling only occurs on spi comms occurring, leave timestamping until
  * then.  Some triggers will generate their own time stamp.  Currently
  * there is no way of notifying them when no one cares.
  **/
diff --git a/drivers/staging/iio/adc/ad7476_ring.c b/drivers/staging/iio/adc/ad7476_ring.c
index 1d654c8..92d9378 100644
--- a/drivers/staging/iio/adc/ad7476_ring.c
+++ b/drivers/staging/iio/adc/ad7476_ring.c
@@ -112,7 +112,7 @@ static int ad7476_ring_preenable(struct iio_dev *indio_dev)
 /**
  * ad7476_poll_func_th() th of trigger launched polling to ring buffer
  *
- * As sampling only occurs on i2c comms occuring, leave timestamping until
+ * As sampling only occurs on i2c comms occurring, leave timestamping until
  * then.  Some triggers will generate their own time stamp.  Currently
  * there is no way of notifying them when no one cares.
  **/
diff --git a/drivers/staging/iio/adc/ad7887_ring.c b/drivers/staging/iio/adc/ad7887_ring.c
index 2d7fe65..da77f26 100644
--- a/drivers/staging/iio/adc/ad7887_ring.c
+++ b/drivers/staging/iio/adc/ad7887_ring.c
@@ -165,7 +165,7 @@ static int ad7887_ring_postdisable(struct iio_dev *indio_dev)
 /**
  * ad7887_poll_func_th() th of trigger launched polling to ring buffer
  *
- * As sampling only occurs on spi comms occuring, leave timestamping until
+ * As sampling only occurs on spi comms occurring, leave timestamping until
  * then.  Some triggers will generate their own time stamp.  Currently
  * there is no way of notifying them when no one cares.
  **/
diff --git a/drivers/staging/iio/adc/ad799x_core.c b/drivers/staging/iio/adc/ad799x_core.c
index e50841b..f04e642 100644
--- a/drivers/staging/iio/adc/ad799x_core.c
+++ b/drivers/staging/iio/adc/ad799x_core.c
@@ -184,7 +184,7 @@ static ssize_t ad799x_read_single_channel(struct device *dev,
 
 	mutex_lock(&dev_info->mlock);
 	mask = 1 << this_attr->address;
-	/* If ring buffer capture is occuring, query the buffer */
+	/* If ring buffer capture is occurring, query the buffer */
 	if (iio_ring_enabled(dev_info)) {
 		data = ret = ad799x_single_channel_from_ring(st, mask);
 		if (ret < 0)
diff --git a/drivers/staging/iio/adc/ad799x_ring.c b/drivers/staging/iio/adc/ad799x_ring.c
index 56abc39..0875a7e 100644
--- a/drivers/staging/iio/adc/ad799x_ring.c
+++ b/drivers/staging/iio/adc/ad799x_ring.c
@@ -101,7 +101,7 @@ static int ad799x_ring_preenable(struct iio_dev *indio_dev)
 /**
  * ad799x_poll_func_th() th of trigger launched polling to ring buffer
  *
- * As sampling only occurs on i2c comms occuring, leave timestamping until
+ * As sampling only occurs on i2c comms occurring, leave timestamping until
  * then.  Some triggers will generate their own time stamp.  Currently
  * there is no way of notifying them when no one cares.
  **/
diff --git a/drivers/staging/iio/adc/max1363_core.c b/drivers/staging/iio/adc/max1363_core.c
index dde097a..de83c3b 100644
--- a/drivers/staging/iio/adc/max1363_core.c
+++ b/drivers/staging/iio/adc/max1363_core.c
@@ -255,7 +255,7 @@ static ssize_t max1363_read_single_channel(struct device *dev,
 		goto error_ret;
 	}
 
-	/* If ring buffer capture is occuring, query the buffer */
+	/* If ring buffer capture is occurring, query the buffer */
 	if (iio_ring_enabled(dev_info)) {
 		mask = max1363_mode_table[this_attr->address].modemask;
 		data = max1363_single_channel_from_ring(mask, st);
@@ -1425,7 +1425,7 @@ error_ret:
 }
 
 /*
- * To keep this managable we always use one of 3 scan modes.
+ * To keep this manageable we always use one of 3 scan modes.
  * Scan 0...3, 0-1,2-3 and 1-0,3-2
  */
 static inline int __max1363_check_event_mask(int thismask, int checkmask)
diff --git a/drivers/staging/iio/adc/max1363_ring.c b/drivers/staging/iio/adc/max1363_ring.c
index 5532f3e..d36fcc6 100644
--- a/drivers/staging/iio/adc/max1363_ring.c
+++ b/drivers/staging/iio/adc/max1363_ring.c
@@ -108,7 +108,7 @@ static int max1363_ring_preenable(struct iio_dev *indio_dev)
 /**
  * max1363_poll_func_th() - th of trigger launched polling to ring buffer
  *
- * As sampling only occurs on i2c comms occuring, leave timestamping until
+ * As sampling only occurs on i2c comms occurring, leave timestamping until
  * then.  Some triggers will generate their own time stamp.  Currently
  * there is no way of notifying them when no one cares.
  **/
diff --git a/drivers/staging/iio/chrdev.h b/drivers/staging/iio/chrdev.h
index 98d1a2c..4fcb99c 100644
--- a/drivers/staging/iio/chrdev.h
+++ b/drivers/staging/iio/chrdev.h
@@ -33,7 +33,7 @@ struct iio_handler {
 /**
  * struct iio_event_data - The actual event being pushed to userspace
  * @id:		event identifier
- * @timestamp:	best estimate of time of event occurance (often from
+ * @timestamp:	best estimate of time of event occurrence (often from
  *		the interrupt handler)
  */
 struct iio_event_data {
@@ -42,7 +42,7 @@ struct iio_event_data {
 };
 
 /**
- * struct iio_detected_event_list - list element for events that have occured
+ * struct iio_detected_event_list - list element for events that have occurred
  * @list:		linked list header
  * @ev:			the event itself
  * @shared_pointer:	used when the event is shared - i.e. can be escallated
@@ -98,7 +98,7 @@ struct iio_event_interface {
  * @list:		list header
  * @refcount:		as the handler may be shared between multiple device
  *			side events, reference counting ensures clean removal
- * @exist_lock:		prevents race conditions related to refcount useage.
+ * @exist_lock:		prevents race conditions related to refcount usage.
  * @handler:		event handler function - called on event if this
  *			event_handler is enabled.
  *
diff --git a/drivers/staging/iio/gyro/adis16060_core.c b/drivers/staging/iio/gyro/adis16060_core.c
index 700eb39..ae53e71 100644
--- a/drivers/staging/iio/gyro/adis16060_core.c
+++ b/drivers/staging/iio/gyro/adis16060_core.c
@@ -30,7 +30,7 @@
  * @us_w:		actual spi_device to write config
  * @us_r:		actual spi_device to read back data
  * @indio_dev:		industrial I/O device structure
- * @buf:		transmit or recieve buffer
+ * @buf:		transmit or receive buffer
  * @buf_lock:		mutex to protect tx and rx
  **/
 struct adis16060_state {
diff --git a/drivers/staging/iio/gyro/adis16080_core.c b/drivers/staging/iio/gyro/adis16080_core.c
index fb4336c..ef9e304 100644
--- a/drivers/staging/iio/gyro/adis16080_core.c
+++ b/drivers/staging/iio/gyro/adis16080_core.c
@@ -35,7 +35,7 @@
  * struct adis16080_state - device instance specific data
  * @us:			actual spi_device to write data
  * @indio_dev:		industrial I/O device structure
- * @buf:		transmit or recieve buffer
+ * @buf:		transmit or receive buffer
  * @buf_lock:		mutex to protect tx and rx
  **/
 struct adis16080_state {
diff --git a/drivers/staging/iio/gyro/adis16260.h b/drivers/staging/iio/gyro/adis16260.h
index c1fd4364..1369501 100644
--- a/drivers/staging/iio/gyro/adis16260.h
+++ b/drivers/staging/iio/gyro/adis16260.h
@@ -91,7 +91,7 @@
  * @indio_dev:		industrial I/O device structure
  * @trig:		data ready trigger registered with iio
  * @tx:			transmit buffer
- * @rx:			recieve buffer
+ * @rx:			receive buffer
  * @buf_lock:		mutex to protect tx and rx
  * @negate:		negate the scale parameter
  **/
diff --git a/drivers/staging/iio/iio.h b/drivers/staging/iio/iio.h
index 248bdd2..7127f26 100644
--- a/drivers/staging/iio/iio.h
+++ b/drivers/staging/iio/iio.h
@@ -92,7 +92,7 @@ void iio_remove_event_from_list(struct iio_event_handler_list *el,
  *			changes
  * @available_scan_masks: [DRIVER] optional array of allowed bitmasks
  * @trig:		[INTERN] current device trigger (ring buffer modes)
- * @pollfunc:		[DRIVER] function run on trigger being recieved
+ * @pollfunc:		[DRIVER] function run on trigger being received
  **/
 struct iio_dev {
 	int				id;
diff --git a/drivers/staging/iio/imu/adis16300.h b/drivers/staging/iio/imu/adis16300.h
index 1f25d68..c095759 100644
--- a/drivers/staging/iio/imu/adis16300.h
+++ b/drivers/staging/iio/imu/adis16300.h
@@ -99,7 +99,7 @@
  * @indio_dev:		industrial I/O device structure
  * @trig:		data ready trigger registered with iio
  * @tx:			transmit buffer
- * @rx:			recieve buffer
+ * @rx:			receive buffer
  * @buf_lock:		mutex to protect tx and rx
  **/
 struct adis16300_state {
diff --git a/drivers/staging/iio/imu/adis16350.h b/drivers/staging/iio/imu/adis16350.h
index b00001e..b1ad486 100644
--- a/drivers/staging/iio/imu/adis16350.h
+++ b/drivers/staging/iio/imu/adis16350.h
@@ -105,7 +105,7 @@
  * @indio_dev:		industrial I/O device structure
  * @trig:		data ready trigger registered with iio
  * @tx:			transmit buffer
- * @rx:			recieve buffer
+ * @rx:			receive buffer
  * @buf_lock:		mutex to protect tx and rx
  **/
 struct adis16350_state {
diff --git a/drivers/staging/iio/imu/adis16400.h b/drivers/staging/iio/imu/adis16400.h
index 6ff33e1..e328bcc 100644
--- a/drivers/staging/iio/imu/adis16400.h
+++ b/drivers/staging/iio/imu/adis16400.h
@@ -17,7 +17,8 @@
 #ifndef SPI_ADIS16400_H_
 #define SPI_ADIS16400_H_
 
-#define ADIS16400_STARTUP_DELAY	220 /* ms */
+#define ADIS16400_STARTUP_DELAY	290 /* ms */
+#define ADIS16400_MTEST_DELAY 90 /* ms */
 
 #define ADIS16400_READ_REG(a)    a
 #define ADIS16400_WRITE_REG(a) ((a) | 0x80)
@@ -131,7 +132,7 @@
  * @indio_dev:		industrial I/O device structure
  * @trig:		data ready trigger registered with iio
  * @tx:			transmit buffer
- * @rx:			recieve buffer
+ * @rx:			receive buffer
  * @buf_lock:		mutex to protect tx and rx
  **/
 struct adis16400_state {
diff --git a/drivers/staging/iio/imu/adis16400_core.c b/drivers/staging/iio/imu/adis16400_core.c
index cfb108a..540bde6 100644
--- a/drivers/staging/iio/imu/adis16400_core.c
+++ b/drivers/staging/iio/imu/adis16400_core.c
@@ -6,6 +6,7 @@
  *
  * Copyright (c) 2009 Manuel Stahl <manuel.stahl@iis.fraunhofer.de>
  * Copyright (c) 2007 Jonathan Cameron <jic23@cam.ac.uk>
+ * Copyright (c) 2011 Analog Devices Inc.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -93,7 +94,6 @@ static int adis16400_spi_write_reg_16(struct device *dev,
 			.tx_buf = st->tx + 2,
 			.bits_per_word = 8,
 			.len = 2,
-			.cs_change = 1,
 		},
 	};
 
@@ -137,7 +137,6 @@ static int adis16400_spi_read_reg_16(struct device *dev,
 			.rx_buf = st->rx,
 			.bits_per_word = 8,
 			.len = 2,
-			.cs_change = 1,
 		},
 	};
 
@@ -375,7 +374,7 @@ static int adis16400_self_test(struct device *dev)
 		dev_err(dev, "problem starting self test");
 		goto err_ret;
 	}
-
+	msleep(ADIS16400_MTEST_DELAY);
 	adis16400_check_status(dev);
 
 err_ret:
@@ -471,10 +470,11 @@ static int adis16400_initial_setup(struct adis16400_state *st)
 	if (ret)
 		goto err_ret;
 
-	if (prod_id != ADIS16400_PRODUCT_ID_DEFAULT)
+	if ((prod_id & 0xF000) != ADIS16400_PRODUCT_ID_DEFAULT)
 		dev_warn(dev, "unknown product id");
 
-	printk(KERN_INFO DRIVER_NAME ": prod_id 0x%04x at CS%d (irq %d)\n",
+
+	dev_info(dev, ": prod_id 0x%04x at CS%d (irq %d)\n",
 			prod_id, st->us->chip_select, st->us->irq);
 
 	/* use high spi speed if possible */
@@ -497,12 +497,12 @@ err_ret:
 			_reg)
 
 static ADIS16400_DEV_ATTR_CALIBBIAS(GYRO_X, ADIS16400_XGYRO_OFF);
-static ADIS16400_DEV_ATTR_CALIBBIAS(GYRO_Y, ADIS16400_XGYRO_OFF);
-static ADIS16400_DEV_ATTR_CALIBBIAS(GYRO_Z, ADIS16400_XGYRO_OFF);
+static ADIS16400_DEV_ATTR_CALIBBIAS(GYRO_Y, ADIS16400_YGYRO_OFF);
+static ADIS16400_DEV_ATTR_CALIBBIAS(GYRO_Z, ADIS16400_ZGYRO_OFF);
 
 static ADIS16400_DEV_ATTR_CALIBBIAS(ACCEL_X, ADIS16400_XACCL_OFF);
-static ADIS16400_DEV_ATTR_CALIBBIAS(ACCEL_Y, ADIS16400_XACCL_OFF);
-static ADIS16400_DEV_ATTR_CALIBBIAS(ACCEL_Z, ADIS16400_XACCL_OFF);
+static ADIS16400_DEV_ATTR_CALIBBIAS(ACCEL_Y, ADIS16400_YACCL_OFF);
+static ADIS16400_DEV_ATTR_CALIBBIAS(ACCEL_Z, ADIS16400_ZACCL_OFF);
 
 
 static IIO_DEV_ATTR_IN_NAMED_RAW(0, supply, adis16400_read_14bit_signed,
@@ -647,7 +647,7 @@ static int __devinit adis16400_probe(struct spi_device *spi)
 
 	ret = iio_ring_buffer_register(st->indio_dev->ring, 0);
 	if (ret) {
-		printk(KERN_ERR "failed to initialize the ring\n");
+		dev_err(&spi->dev, "failed to initialize the ring\n");
 		goto error_unreg_ring_funcs;
 	}
 
diff --git a/drivers/staging/iio/imu/adis16400_ring.c b/drivers/staging/iio/imu/adis16400_ring.c
index 33293fb..da28cb4 100644
--- a/drivers/staging/iio/imu/adis16400_ring.c
+++ b/drivers/staging/iio/imu/adis16400_ring.c
@@ -122,12 +122,10 @@ static int adis16400_spi_read_burst(struct device *dev, u8 *rx)
 			.tx_buf = st->tx,
 			.bits_per_word = 8,
 			.len = 2,
-			.cs_change = 0,
 		}, {
 			.rx_buf = rx,
 			.bits_per_word = 8,
 			.len = 24,
-			.cs_change = 1,
 		},
 	};
 
@@ -162,9 +160,10 @@ static void adis16400_trigger_bh_to_ring(struct work_struct *work_s)
 			       work_trigger_to_ring);
 	struct iio_ring_buffer *ring = st->indio_dev->ring;
 
-	int i = 0;
+	int i = 0, j;
 	s16 *data;
 	size_t datasize = ring->access.get_bytes_per_datum(ring);
+	unsigned long mask = ring->scan_mask;
 
 	data = kmalloc(datasize , GFP_KERNEL);
 	if (data == NULL) {
@@ -174,9 +173,12 @@ static void adis16400_trigger_bh_to_ring(struct work_struct *work_s)
 
 	if (ring->scan_count)
 		if (adis16400_spi_read_burst(&st->indio_dev->dev, st->rx) >= 0)
-			for (; i < ring->scan_count; i++)
+			for (; i < ring->scan_count; i++) {
+				j = __ffs(mask);
+				mask &= ~(1 << j);
 				data[i]	= be16_to_cpup(
-					(__be16 *)&(st->rx[i*2]));
+					(__be16 *)&(st->rx[j*2]));
+			}
 
 	/* Guaranteed to be aligned with 8 byte boundary */
 	if (ring->scan_timestamp)
diff --git a/drivers/staging/iio/industrialio-core.c b/drivers/staging/iio/industrialio-core.c
index f3bf111..1795ee1 100644
--- a/drivers/staging/iio/industrialio-core.c
+++ b/drivers/staging/iio/industrialio-core.c
@@ -258,7 +258,7 @@ static ssize_t iio_event_chrdev_read(struct file *filep,
 							   ->det_events.list));
 		if (ret)
 			goto error_ret;
-		/* Single access device so noone else can get the data */
+		/* Single access device so no one else can get the data */
 		mutex_lock(&ev_int->event_list_lock);
 	}
 
diff --git a/drivers/staging/iio/meter/ade7753.h b/drivers/staging/iio/meter/ade7753.h
index 70dabae..3b9c7f6 100644
--- a/drivers/staging/iio/meter/ade7753.h
+++ b/drivers/staging/iio/meter/ade7753.h
@@ -62,7 +62,7 @@
  * @us:			actual spi_device
  * @indio_dev:		industrial I/O device structure
  * @tx:			transmit buffer
- * @rx:			recieve buffer
+ * @rx:			receive buffer
  * @buf_lock:		mutex to protect tx and rx
  **/
 struct ade7753_state {
diff --git a/drivers/staging/iio/meter/ade7754.h b/drivers/staging/iio/meter/ade7754.h
index 8faa9b3..0aa0522 100644
--- a/drivers/staging/iio/meter/ade7754.h
+++ b/drivers/staging/iio/meter/ade7754.h
@@ -80,7 +80,7 @@
  * @us:			actual spi_device
  * @indio_dev:		industrial I/O device structure
  * @tx:			transmit buffer
- * @rx:			recieve buffer
+ * @rx:			receive buffer
  * @buf_lock:		mutex to protect tx and rx
  **/
 struct ade7754_state {
diff --git a/drivers/staging/iio/meter/ade7758.h b/drivers/staging/iio/meter/ade7758.h
index df5bb7b..c6fd94f 100644
--- a/drivers/staging/iio/meter/ade7758.h
+++ b/drivers/staging/iio/meter/ade7758.h
@@ -98,7 +98,7 @@
  * @indio_dev:		industrial I/O device structure
  * @trig:		data ready trigger registered with iio
  * @tx:			transmit buffer
- * @rx:			recieve buffer
+ * @rx:			receive buffer
  * @buf_lock:		mutex to protect tx and rx
  **/
 struct ade7758_state {
diff --git a/drivers/staging/iio/meter/ade7759.h b/drivers/staging/iio/meter/ade7759.h
index e9d1c43..cc76c2c 100644
--- a/drivers/staging/iio/meter/ade7759.h
+++ b/drivers/staging/iio/meter/ade7759.h
@@ -43,7 +43,7 @@
  * @us:			actual spi_device
  * @indio_dev:		industrial I/O device structure
  * @tx:			transmit buffer
- * @rx:			recieve buffer
+ * @rx:			receive buffer
  * @buf_lock:		mutex to protect tx and rx
  **/
 struct ade7759_state {
diff --git a/drivers/staging/iio/meter/ade7854.h b/drivers/staging/iio/meter/ade7854.h
index 4ad84a3..79a2110 100644
--- a/drivers/staging/iio/meter/ade7854.h
+++ b/drivers/staging/iio/meter/ade7854.h
@@ -149,7 +149,7 @@
  * @spi:			actual spi_device
  * @indio_dev:		industrial I/O device structure
  * @tx:			transmit buffer
- * @rx:			recieve buffer
+ * @rx:			receive buffer
  * @buf_lock:		mutex to protect tx and rx
  **/
 struct ade7854_state {
diff --git a/drivers/staging/iio/ring_generic.h b/drivers/staging/iio/ring_generic.h
index f21ac09..32948e5 100644
--- a/drivers/staging/iio/ring_generic.h
+++ b/drivers/staging/iio/ring_generic.h
@@ -30,7 +30,7 @@ int iio_push_ring_event(struct iio_ring_buffer *ring_buf,
  * @event_code:		event indentification code
  * @timestamp:		time of event
  *
- * Typical usecase is to escalate a 50% ring full to 75% full if noone has yet
+ * Typical usecase is to escalate a 50% ring full to 75% full if no one has yet
  * read the first event. Clearly the 50% full is no longer of interest in
  * typical use case.
  **/
diff --git a/drivers/staging/intel_sst/TODO b/drivers/staging/intel_sst/TODO
index a24e5ed..c733d70 100644
--- a/drivers/staging/intel_sst/TODO
+++ b/drivers/staging/intel_sst/TODO
@@ -1,7 +1,7 @@
 TODO
 ----
 
-Get the memrar driver cleaned up and upstream (dependancy blocking SST)
+Get the memrar driver cleaned up and upstream (dependency blocking SST)
 Replace long/short press with two virtual buttons
 Review the printks and kill off any left over ST_ERR: messages
 Review the misc device ioctls for 32/64bit safety and sanity
diff --git a/drivers/staging/intel_sst/intel_sst.c b/drivers/staging/intel_sst/intel_sst.c
index ce4a9f7..81c24d1 100644
--- a/drivers/staging/intel_sst/intel_sst.c
+++ b/drivers/staging/intel_sst/intel_sst.c
@@ -263,7 +263,7 @@ static int __devinit intel_sst_probe(struct pci_dev *pci,
 	/* Init the device */
 	ret = pci_enable_device(pci);
 	if (ret) {
-		pr_err("device cant be enabled\n");
+		pr_err("device can't be enabled\n");
 		goto do_free_mem;
 	}
 	sst_drv_ctx->pci = pci_dev_get(pci);
@@ -453,7 +453,7 @@ int intel_sst_resume(struct pci_dev *pci)
 	pci_restore_state(pci);
 	ret = pci_enable_device(pci);
 	if (ret)
-		pr_err("device cant be enabled\n");
+		pr_err("device can't be enabled\n");
 
 	mutex_lock(&sst_drv_ctx->sst_lock);
 	sst_drv_ctx->sst_state = SST_UN_INIT;
diff --git a/drivers/staging/intel_sst/intel_sst_app_interface.c b/drivers/staging/intel_sst/intel_sst_app_interface.c
index a367991..1d06212 100644
--- a/drivers/staging/intel_sst/intel_sst_app_interface.c
+++ b/drivers/staging/intel_sst/intel_sst_app_interface.c
@@ -236,7 +236,7 @@ int intel_sst_mmap(struct file *file_ptr, struct vm_area_struct *vma)
 	if (!sst_drv_ctx->mmap_mem)
 		return -EIO;
 
-	/* round it up to the page bondary  */
+	/* round it up to the page boundary  */
 	/*mem_area = (void *)((((unsigned long)sst_drv_ctx->mmap_mem)
 				+ PAGE_SIZE - 1) & PAGE_MASK);*/
 	mem_area = (void *) PAGE_ALIGN((unsigned int) sst_drv_ctx->mmap_mem);
@@ -871,7 +871,7 @@ int sst_send_algo_ipc(struct ipc_post **msg)
 }
 
 /**
- * intel_sst_ioctl_dsp - recieves the device ioctl's
+ * intel_sst_ioctl_dsp - receives the device ioctl's
  *
  * @cmd:Ioctl cmd
  * @arg:data
@@ -1067,7 +1067,7 @@ long intel_sst_ioctl(struct file *file_ptr, unsigned int cmd, unsigned long arg)
 			retval = -EFAULT;
 			break;
 		}
-		pr_debug("SET_VOLUME recieved for %d!\n",
+		pr_debug("SET_VOLUME received for %d!\n",
 				set_vol.stream_id);
 		if (minor == STREAM_MODULE && set_vol.stream_id == 0) {
 			pr_debug("invalid operation!\n");
@@ -1085,7 +1085,7 @@ long intel_sst_ioctl(struct file *file_ptr, unsigned int cmd, unsigned long arg)
 			retval = -EFAULT;
 			break;
 		}
-		pr_debug("IOCTL_GET_VOLUME recieved for stream = %d!\n",
+		pr_debug("IOCTL_GET_VOLUME received for stream = %d!\n",
 				get_vol.stream_id);
 		if (minor == STREAM_MODULE && get_vol.stream_id == 0) {
 			pr_debug("invalid operation!\n");
@@ -1117,7 +1117,7 @@ long intel_sst_ioctl(struct file *file_ptr, unsigned int cmd, unsigned long arg)
 			retval = -EFAULT;
 			break;
 		}
-		pr_debug("SNDRV_SST_SET_VOLUME recieved for %d!\n",
+		pr_debug("SNDRV_SST_SET_VOLUME received for %d!\n",
 			set_mute.stream_id);
 		if (minor == STREAM_MODULE && set_mute.stream_id == 0) {
 			retval = -EPERM;
@@ -1153,7 +1153,7 @@ long intel_sst_ioctl(struct file *file_ptr, unsigned int cmd, unsigned long arg)
 	case _IOC_NR(SNDRV_SST_MMAP_CAPTURE): {
 		struct snd_sst_mmap_buffs mmap_buf;
 
-		pr_debug("SNDRV_SST_MMAP_PLAY/CAPTURE recieved!\n");
+		pr_debug("SNDRV_SST_MMAP_PLAY/CAPTURE received!\n");
 		if (minor != STREAM_MODULE) {
 			retval = -EBADRQC;
 			break;
@@ -1239,7 +1239,7 @@ long intel_sst_ioctl(struct file *file_ptr, unsigned int cmd, unsigned long arg)
 	case _IOC_NR(SNDRV_SST_SET_TARGET_DEVICE): {
 		struct snd_sst_target_device target_device;
 
-		pr_debug("SET_TARGET_DEVICE recieved!\n");
+		pr_debug("SET_TARGET_DEVICE received!\n");
 		if (copy_from_user(&target_device, (void __user *)arg,
 				sizeof(target_device))) {
 			retval = -EFAULT;
@@ -1256,7 +1256,7 @@ long intel_sst_ioctl(struct file *file_ptr, unsigned int cmd, unsigned long arg)
 	case _IOC_NR(SNDRV_SST_DRIVER_INFO): {
 		struct snd_sst_driver_info info;
 
-		pr_debug("SNDRV_SST_DRIVER_INFO recived\n");
+		pr_debug("SNDRV_SST_DRIVER_INFO received\n");
 		info.version = SST_VERSION_NUM;
 		/* hard coding, shud get sumhow later */
 		info.active_pcm_streams = sst_drv_ctx->stream_cnt -
diff --git a/drivers/staging/intel_sst/intel_sst_drv_interface.c b/drivers/staging/intel_sst/intel_sst_drv_interface.c
index ea8e251..e9c1821 100644
--- a/drivers/staging/intel_sst/intel_sst_drv_interface.c
+++ b/drivers/staging/intel_sst/intel_sst_drv_interface.c
@@ -315,7 +315,7 @@ int sst_open_pcm_stream(struct snd_sst_params *str_param)
 	pm_runtime_get_sync(&sst_drv_ctx->pci->dev);
 
 	if (sst_drv_ctx->sst_state == SST_SUSPENDED) {
-		/* LPE is suspended, resume it before proceding*/
+		/* LPE is suspended, resume it before proceeding*/
 		pr_debug("Resuming from Suspended state\n");
 		retval = intel_sst_resume(sst_drv_ctx->pci);
 		if (retval) {
diff --git a/drivers/staging/intel_sst/intel_sst_dsp.c b/drivers/staging/intel_sst/intel_sst_dsp.c
index 6e5c915..bffe4c6 100644
--- a/drivers/staging/intel_sst/intel_sst_dsp.c
+++ b/drivers/staging/intel_sst/intel_sst_dsp.c
@@ -350,7 +350,7 @@ static int sst_download_library(const struct firmware *fw_lib,
 
 }
 
-/* This function is called befoer downloading the codec/postprocessing
+/* This function is called before downloading the codec/postprocessing
 library is set for download to SST DSP*/
 static int sst_validate_library(const struct firmware *fw_lib,
 		struct lib_slot_info *slot,
@@ -405,7 +405,7 @@ exit:
 
 }
 
-/* This function is called when FW requests for a particular libary download
+/* This function is called when FW requests for a particular library download
 This function prepares the library to download*/
 int sst_load_library(struct snd_sst_lib_download *lib, u8 ops)
 {
diff --git a/drivers/staging/intel_sst/intel_sst_fw_ipc.h b/drivers/staging/intel_sst/intel_sst_fw_ipc.h
index 8df313d..0f0c5bb 100644
--- a/drivers/staging/intel_sst/intel_sst_fw_ipc.h
+++ b/drivers/staging/intel_sst/intel_sst_fw_ipc.h
@@ -111,7 +111,7 @@
 #define IPC_SST_PERIOD_ELAPSED 0x97 /* period elapsed */
 #define IPC_IA_TARGET_DEV_CHNGD 0x98 /* error in processing a stream */
 
-#define IPC_SST_ERROR_EVENT 0x99 /* Buffer over run occured */
+#define IPC_SST_ERROR_EVENT 0x99 /* Buffer over run occurred */
 /* L2S messages */
 #define IPC_SC_DDR_LINK_UP 0xC0
 #define IPC_SC_DDR_LINK_DOWN 0xC1
diff --git a/drivers/staging/intel_sst/intel_sst_stream.c b/drivers/staging/intel_sst/intel_sst_stream.c
index 795e42a..dd58be5 100644
--- a/drivers/staging/intel_sst/intel_sst_stream.c
+++ b/drivers/staging/intel_sst/intel_sst_stream.c
@@ -98,7 +98,7 @@ static unsigned int get_mrst_stream_id(void)
 		if (sst_drv_ctx->streams[i].status == STREAM_UN_INIT)
 			return i;
 	}
-	pr_debug("Didnt find empty stream for mrst\n");
+	pr_debug("Didn't find empty stream for mrst\n");
 	return -EBUSY;
 }
 
diff --git a/drivers/staging/intel_sst/intel_sst_stream_encoded.c b/drivers/staging/intel_sst/intel_sst_stream_encoded.c
index 29753c7..d5f07b8 100644
--- a/drivers/staging/intel_sst/intel_sst_stream_encoded.c
+++ b/drivers/staging/intel_sst/intel_sst_stream_encoded.c
@@ -914,7 +914,7 @@ static int sst_prepare_input_buffers_rar(struct stream_info *str_info,
 		(void *) ((unsigned long) rar_buffers.bus_address);
 		pr_debug("RAR buf addr in DnR (input buffer function)0x%lu",
 				 (unsigned long) str_info->decode_ibuf);
-		pr_debug("rar in DnR decode funtion/output b_add rar =0x%lu",
+		pr_debug("rar in DnR decode function/output b_add rar =0x%lu",
 				(unsigned long) rar_buffers.bus_address);
 		*input_index = i + 1;
 		str_info->decode_isize = dbufs->ibufs->buff_entry[i].size;
diff --git a/drivers/staging/intel_sst/intelmid.c b/drivers/staging/intel_sst/intelmid.c
index fb22921..d207636 100644
--- a/drivers/staging/intel_sst/intelmid.c
+++ b/drivers/staging/intel_sst/intelmid.c
@@ -773,7 +773,7 @@ static int __devinit snd_intelmad_sst_register(
 		if (ret_val)
 			return ret_val;
 		sst_card_vendor_id = (vendor_addr.value & (MASK2|MASK1|MASK0));
-		pr_debug("orginal n extrated vendor id = 0x%x %d\n",
+		pr_debug("original n extrated vendor id = 0x%x %d\n",
 				vendor_addr.value, sst_card_vendor_id);
 		if (sst_card_vendor_id < 0 || sst_card_vendor_id > 2) {
 			pr_err("vendor card not supported!!\n");
diff --git a/drivers/staging/intel_sst/intelmid.h b/drivers/staging/intel_sst/intelmid.h
index ca881b7..e77da87 100644
--- a/drivers/staging/intel_sst/intelmid.h
+++ b/drivers/staging/intel_sst/intelmid.h
@@ -90,7 +90,7 @@ struct mad_jack_msg_wq {
  * @card_index: sound card index
  * @card_id: sound card id detected
  * @sstdrv_ops: ptr to sst driver ops
- * @pdev: ptr to platfrom device
+ * @pdev: ptr to platform device
  * @irq: interrupt number detected
  * @pmic_status: Device status of sound card
  * @int_base: ptr to MMIO interrupt region
diff --git a/drivers/staging/keucr/init.c b/drivers/staging/keucr/init.c
index 5c01f28..8af7c84 100644
--- a/drivers/staging/keucr/init.c
+++ b/drivers/staging/keucr/init.c
@@ -90,7 +90,7 @@ int ENE_MSInit(struct us_data *us)
 
 	result = ENE_SendScsiCmd(us, FDIR_READ, &buf, 0);
 	if (result != USB_STOR_XFER_GOOD) {
-		printk(KERN_ERR "Exection MS Init Code Fail !!\n");
+		printk(KERN_ERR "Execution MS Init Code Fail !!\n");
 		return USB_STOR_TRANSPORT_ERROR;
 	}
 
@@ -145,7 +145,7 @@ int ENE_SMInit(struct us_data *us)
 	result = ENE_SendScsiCmd(us, FDIR_READ, &buf, 0);
 	if (result != USB_STOR_XFER_GOOD) {
 		printk(KERN_ERR
-		       "Exection SM Init Code Fail !! result = %x\n", result);
+		       "Execution SM Init Code Fail !! result = %x\n", result);
 		return USB_STOR_TRANSPORT_ERROR;
 	}
 
diff --git a/drivers/staging/keucr/smilmain.c b/drivers/staging/keucr/smilmain.c
index 2cbe9f8..95c688a 100644
--- a/drivers/staging/keucr/smilmain.c
+++ b/drivers/staging/keucr/smilmain.c
@@ -64,7 +64,7 @@ extern struct SSFDCTYPE  Ssfdc;
 extern struct ADDRESS    Media;
 extern struct CIS_AREA   CisArea;
 
-//BIT Controll Macro
+//BIT Control Macro
 BYTE BitData[] = { 0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80 } ;
 #define Set_D_Bit(a,b)    (a[(BYTE)((b)/8)]|= BitData[(b)%8])
 #define Clr_D_Bit(a,b)    (a[(BYTE)((b)/8)]&=~BitData[(b)%8])
@@ -76,7 +76,7 @@ extern BYTE     IsXDCompliance;
 
 
 //
-////Power Controll & Media Exist Check Function
+////Power Control & Media Exist Check Function
 ////----- Init_D_SmartMedia() --------------------------------------------
 //int Init_D_SmartMedia(void)
 //{
@@ -575,7 +575,7 @@ int Media_D_OneSectWriteFlush(PFDO_DEVICE_EXTENSION fdoExt)
 //    return(SUCCESS);
 //}
 //
-////Power Controll & Media Exist Check Subroutine
+////Power Control & Media Exist Check Subroutine
 ////----- Initialize_D_Media() -------------------------------------------
 //void Initialize_D_Media(void)
 //{
@@ -738,7 +738,7 @@ int Check_D_MediaFmt(struct us_data *us)
 //    return(SUCCESS);
 //}
 */
-//SmartMedia Physical Address Controll Subroutine
+//SmartMedia Physical Address Control Subroutine
 //----- Conv_D_MediaAddr() ---------------------------------------------
 int Conv_D_MediaAddr(struct us_data *us, DWORD addr)
 {
diff --git a/drivers/staging/keucr/smilsub.c b/drivers/staging/keucr/smilsub.c
index 80da61c..4fe4742 100644
--- a/drivers/staging/keucr/smilsub.c
+++ b/drivers/staging/keucr/smilsub.c
@@ -57,7 +57,7 @@ extern WORD  WriteBlock;
 #define ODD                     1             // Odd Page for 256byte/page
 
 
-//SmartMedia Redundant buffer data Controll Subroutine
+//SmartMedia Redundant buffer data Control Subroutine
 //----- Check_D_DataBlank() --------------------------------------------
 int Check_D_DataBlank(BYTE *redundant)
 {
@@ -1367,7 +1367,7 @@ BYTE _Check_D_DevCode(BYTE dcode)
     }
 }
 /*
-////SmartMedia Power Controll Subroutine
+////SmartMedia Power Control Subroutine
 ////----- Cnt_D_Reset() ----------------------------------------------
 //void Cnt_D_Reset(void)
 //{
@@ -1478,7 +1478,7 @@ BYTE _Check_D_DevCode(BYTE dcode)
 //}
 //
 */
-//SmartMedia ECC Controll Subroutine
+//SmartMedia ECC Control Subroutine
 //----- Check_D_ReadError() ----------------------------------------------
 int Check_D_ReadError(BYTE *redundant)
 {
diff --git a/drivers/staging/lirc/lirc_ene0100.h b/drivers/staging/lirc/lirc_ene0100.h
index 776b693..06bebd6 100644
--- a/drivers/staging/lirc/lirc_ene0100.h
+++ b/drivers/staging/lirc/lirc_ene0100.h
@@ -81,7 +81,7 @@
 
 /* CIR block settings */
 #define ENE_CIR_CONF1		0xFEC0
-#define ENE_CIR_CONF1_ADC_ON	0x7	 /* reciever on gpio40 enabled */
+#define ENE_CIR_CONF1_ADC_ON	0x7	 /* receiver on gpio40 enabled */
 #define ENE_CIR_CONF1_LEARN1	(1 << 3) /* enabled on learning mode */
 #define ENE_CIR_CONF1_TX_ON	0x30	 /* enabled on transmit */
 #define ENE_CIR_CONF1_TX_CARR	(1 << 7) /* send TX carrier or not */
@@ -96,7 +96,7 @@
 
 /* transmitter - not implemented yet */
 /* KB3926C and higher */
-/* transmission is very similiar to recieving, a byte is written to */
+/* transmission is very similar to receiving, a byte is written to */
 /* ENE_TX_INPUT, in same manner as it is read from sample buffer */
 /* sample period is fixed*/
 
diff --git a/drivers/staging/memrar/Kconfig b/drivers/staging/memrar/Kconfig
deleted file mode 100644
index cbeebc5..0000000
--- a/drivers/staging/memrar/Kconfig
+++ /dev/null
@@ -1,15 +0,0 @@
-config MRST_RAR_HANDLER
-	tristate "RAR handler driver for Intel Moorestown platform"
-	depends on RAR_REGISTER
-	---help---
-	  This driver provides a memory management interface to
-	  restricted access regions (RAR) available on the Intel
-	  Moorestown platform.
-
-	  Once locked down, restricted access regions are only
-	  accessible by specific hardware on the platform.  The x86
-	  CPU is typically not one of those platforms.  As such this
-	  driver does not access RAR, and only provides a buffer
-	  allocation/bookkeeping mechanism.
-
-	  If unsure, say N.
diff --git a/drivers/staging/memrar/Makefile b/drivers/staging/memrar/Makefile
deleted file mode 100644
index a3336c0..0000000
--- a/drivers/staging/memrar/Makefile
+++ /dev/null
@@ -1,2 +0,0 @@
-obj-$(CONFIG_MRST_RAR_HANDLER)	+= memrar.o
-memrar-y			:= memrar_allocator.o memrar_handler.o
diff --git a/drivers/staging/memrar/TODO b/drivers/staging/memrar/TODO
deleted file mode 100644
index 435e09b..0000000
--- a/drivers/staging/memrar/TODO
+++ /dev/null
@@ -1,43 +0,0 @@
-RAR Handler (memrar) Driver TODO Items
-======================================
-
-Maintainer: Eugene Epshteyn <eugene.epshteyn@intel.com>
-
-memrar.h
---------
-1. This header exposes the driver's user space and kernel space
-   interfaces.  It should be moved to <linux/rar/memrar.h>, or
-   something along those lines, when this memrar driver is moved out
-   of `staging'.
-     a. It would be ideal if staging/rar_register/rar_register.h was
-        moved to the same directory.
-
-memrar_allocator.[ch]
----------------------
-1. Address potential fragmentation issues with the memrar_allocator.
-
-2. Hide struct memrar_allocator details/fields.  They need not be
-   exposed to the user.
-     a. Forward declare struct memrar_allocator.
-     b. Move all three struct definitions to `memrar_allocator.c'
-        source file.
-     c. Add a memrar_allocator_largest_free_area() function, or
-        something like that to get access to the value of the struct
-        memrar_allocator "largest_free_area" field.  This allows the
-        struct memrar_allocator fields to be completely hidden from
-        the user.  The memrar_handler code really only needs this for
-        statistic gathering on-demand.
-     d. Do the same for the "capacity" field as the
-        "largest_free_area" field.
-
-3. Move memrar_allocator.* to kernel `lib' directory since it is HW
-   neutral.
-     a. Alternatively, use lib/genalloc.c instead.
-     b. A kernel port of Doug Lea's malloc() implementation may also
-        be an option.
-
-memrar_handler.c
-----------------
-1. Split user space interface (ioctl code) from core/kernel code,
-   e.g.:
-     memrar_handler.c -> memrar_core.c, memrar_user.c
diff --git a/drivers/staging/memrar/memrar-abi b/drivers/staging/memrar/memrar-abi
deleted file mode 100644
index c23fc99..0000000
--- a/drivers/staging/memrar/memrar-abi
+++ /dev/null
@@ -1,89 +0,0 @@
-What:		/dev/memrar
-Date:		March 2010
-KernelVersion:	2.6.34
-Contact:	Eugene Epshteyn <eugene.epshteyn@intel.com>
-Description:	The Intel Moorestown Restricted Access Region (RAR)
-		Handler driver exposes an ioctl() based interface that
-		allows a user to reserve and release blocks of RAR
-		memory.
-
-		Note:  A sysfs based one was not appropriate for the
-		RAR handler's usage model.
-
-		=========================================================
-				ioctl() Requests
-		=========================================================
-		RAR_HANDLER_RESERVE
-		-------------------
-		Description:	Reserve RAR block.
-		Type:		struct RAR_block_info
-		Direction:	in/out
-		Errors:		EINVAL (invalid RAR type or size)
-				ENOMEM (not enough RAR memory)
-
-		RAR_HANDLER_STAT
-		----------------
-		Description:	Get RAR statistics.
-		Type:		struct RAR_stat
-		Direction:	in/out
-		Errors:		EINVAL (invalid RAR type)
-
-		RAR_HANDLER_RELEASE
-		-------------------
-		Description:	Release previously reserved RAR block.
-		Type:		32 bit unsigned integer
-				(e.g. uint32_t), i.e the RAR "handle".
-		Direction:	in
-		Errors:		EINVAL (invalid RAR handle)
-
-
-		=========================================================
-			ioctl() Request Parameter Types
-		=========================================================
-		The structures referred to above are defined as
-		follows:
-
-		/**
-		 * struct RAR_block_info - user space struct that
-		 *			   describes RAR buffer
-		 * @type:	Type of RAR memory (e.g.,
-		 *		RAR_TYPE_VIDEO or RAR_TYPE_AUDIO) [in]
-		 * @size:	Requested size of a block in bytes to
-		 *		be reserved in RAR. [in]
-		 * @handle:	Handle that can be used to refer to
-		 *		reserved block. [out]
-		 *
-		 * This is the basic structure exposed to the user
-		 * space that describes a given RAR buffer.  It used
-		 * as the parameter for the RAR_HANDLER_RESERVE ioctl.
-		 * The buffer's underlying bus address is not exposed
-		 * to the user.  User space code refers to the buffer
-		 * entirely by "handle".
-		 */
-		struct RAR_block_info {
-			__u32 type;
-			__u32 size;
-			__u32 handle;
-		};
-
-		/**
-		 * struct RAR_stat - RAR statistics structure
-		 * @type:		Type of RAR memory (e.g.,
-		 *			RAR_TYPE_VIDEO or
-		 *			RAR_TYPE_AUDIO) [in]
-		 * @capacity:		Total size of RAR memory
-		 *			region. [out]
-		 * @largest_block_size:	Size of the largest reservable
-		 *			block. [out]
-		 *
-		 * This structure is used for RAR_HANDLER_STAT ioctl.
-		 */
-		struct RAR_stat {
-			__u32 type;
-			__u32 capacity;
-			__u32 largest_block_size;
-		};
-
-		Lastly, the RAR_HANDLER_RELEASE ioctl expects a
-		"handle" to the RAR block of memory.  It is a 32 bit
-		unsigned integer.
diff --git a/drivers/staging/memrar/memrar.h b/drivers/staging/memrar/memrar.h
deleted file mode 100644
index 0feb73b..0000000
--- a/drivers/staging/memrar/memrar.h
+++ /dev/null
@@ -1,174 +0,0 @@
-/*
- *      RAR Handler (/dev/memrar) internal driver API.
- *      Copyright (C) 2010 Intel Corporation. All rights reserved.
- *
- *      This program is free software; you can redistribute it and/or
- *      modify it under the terms of version 2 of the GNU General
- *      Public License as published by the Free Software Foundation.
- *
- *      This program is distributed in the hope that it will be
- *      useful, but WITHOUT ANY WARRANTY; without even the implied
- *      warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
- *      PURPOSE.  See the GNU General Public License for more details.
- *      You should have received a copy of the GNU General Public
- *      License along with this program; if not, write to the Free
- *      Software Foundation, Inc., 59 Temple Place - Suite 330,
- *      Boston, MA  02111-1307, USA.
- *      The full GNU General Public License is included in this
- *      distribution in the file called COPYING.
- */
-
-
-#ifndef _MEMRAR_H
-#define _MEMRAR_H
-
-#include <linux/ioctl.h>
-#include <linux/types.h>
-
-
-/**
- * struct RAR_stat - RAR statistics structure
- * @type:		Type of RAR memory (e.g., audio vs. video)
- * @capacity:		Total size of RAR memory region.
- * @largest_block_size:	Size of the largest reservable block.
- *
- * This structure is used for RAR_HANDLER_STAT ioctl and for the
- * RAR_get_stat() user space wrapper function.
- */
-struct RAR_stat {
-	__u32 type;
-	__u32 capacity;
-	__u32 largest_block_size;
-};
-
-
-/**
- * struct RAR_block_info - user space struct that describes RAR buffer
- * @type:	Type of RAR memory (e.g., audio vs. video)
- * @size:	Requested size of a block to be reserved in RAR.
- * @handle:	Handle that can be used to refer to reserved block.
- *
- * This is the basic structure exposed to the user space that
- * describes a given RAR buffer.  The buffer's underlying bus address
- * is not exposed to the user.  User space code refers to the buffer
- * entirely by "handle".
- */
-struct RAR_block_info {
-	__u32 type;
-	__u32 size;
-	__u32 handle;
-};
-
-
-#define RAR_IOCTL_BASE 0xE0
-
-/* Reserve RAR block. */
-#define RAR_HANDLER_RESERVE _IOWR(RAR_IOCTL_BASE, 0x00, struct RAR_block_info)
-
-/* Release previously reserved RAR block. */
-#define RAR_HANDLER_RELEASE _IOW(RAR_IOCTL_BASE, 0x01, __u32)
-
-/* Get RAR stats. */
-#define RAR_HANDLER_STAT    _IOWR(RAR_IOCTL_BASE, 0x02, struct RAR_stat)
-
-
-#ifdef __KERNEL__
-
-/* -------------------------------------------------------------- */
-/*               Kernel Side RAR Handler Interface                */
-/* -------------------------------------------------------------- */
-
-/**
- * struct RAR_buffer - kernel space struct that describes RAR buffer
- * @info:		structure containing base RAR buffer information
- * @bus_address:	buffer bus address
- *
- * Structure that contains all information related to a given block of
- * memory in RAR.  It is generally only used when retrieving RAR
- * related bus addresses.
- *
- * Note: This structure is used only by RAR-enabled drivers, and is
- *       not intended to be exposed to the user space.
- */
-struct RAR_buffer {
-	struct RAR_block_info info;
-	dma_addr_t bus_address;
-};
-
-#if defined(CONFIG_MRST_RAR_HANDLER)
-/**
- * rar_reserve() - reserve RAR buffers
- * @buffers:	array of RAR_buffers where type and size of buffers to
- *		reserve are passed in, handle and bus address are
- *		passed out
- * @count:	number of RAR_buffers in the "buffers" array
- *
- * This function will reserve buffers in the restricted access regions
- * of given types.
- *
- * It returns the number of successfully reserved buffers.  Successful
- * buffer reservations will have the corresponding bus_address field
- * set to a non-zero value in the given buffers vector.
- */
-extern size_t rar_reserve(struct RAR_buffer *buffers,
-			  size_t count);
-
-/**
- * rar_release() - release RAR buffers
- * @buffers:	array of RAR_buffers where handles to buffers to be
- *		released are passed in
- * @count:	number of RAR_buffers in the "buffers" array
- *
- * This function will release RAR buffers that were retrieved through
- * a call to rar_reserve() or rar_handle_to_bus() by decrementing the
- * reference count.  The RAR buffer will be reclaimed when the
- * reference count drops to zero.
- *
- * It returns the number of successfully released buffers.  Successful
- * releases will have their handle field set to zero in the given
- * buffers vector.
- */
-extern size_t rar_release(struct RAR_buffer *buffers,
-			  size_t count);
-
-/**
- * rar_handle_to_bus() - convert a vector of RAR handles to bus addresses
- * @buffers:	array of RAR_buffers containing handles to be
- *		converted to bus_addresses
- * @count:	number of RAR_buffers in the "buffers" array
-
- * This function will retrieve the RAR buffer bus addresses, type and
- * size corresponding to the RAR handles provided in the buffers
- * vector.
- *
- * It returns the number of successfully converted buffers.  The bus
- * address will be set to 0 for unrecognized handles.
- *
- * The reference count for each corresponding buffer in RAR will be
- * incremented.  Call rar_release() when done with the buffers.
- */
-extern size_t rar_handle_to_bus(struct RAR_buffer *buffers,
-				size_t count);
-
-#else
-
-extern inline size_t rar_reserve(struct RAR_buffer *buffers, size_t count)
-{
-	return 0;
-}
-
-extern inline size_t rar_release(struct RAR_buffer *buffers, size_t count)
-{
-	return 0;
-}
-
-extern inline size_t rar_handle_to_bus(struct RAR_buffer *buffers,
-				size_t count)
-{
-	return 0;
-}
-
-#endif  /* MRST_RAR_HANDLER */
-#endif  /* __KERNEL__ */
-
-#endif  /* _MEMRAR_H */
diff --git a/drivers/staging/memrar/memrar_allocator.c b/drivers/staging/memrar/memrar_allocator.c
deleted file mode 100644
index a4f8c58..0000000
--- a/drivers/staging/memrar/memrar_allocator.c
+++ /dev/null
@@ -1,432 +0,0 @@
-/*
- *      memrar_allocator 1.0:  An allocator for Intel RAR.
- *
- *      Copyright (C) 2010 Intel Corporation. All rights reserved.
- *
- *      This program is free software; you can redistribute it and/or
- *      modify it under the terms of version 2 of the GNU General
- *      Public License as published by the Free Software Foundation.
- *
- *      This program is distributed in the hope that it will be
- *      useful, but WITHOUT ANY WARRANTY; without even the implied
- *      warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
- *      PURPOSE.  See the GNU General Public License for more details.
- *      You should have received a copy of the GNU General Public
- *      License along with this program; if not, write to the Free
- *      Software Foundation, Inc., 59 Temple Place - Suite 330,
- *      Boston, MA  02111-1307, USA.
- *      The full GNU General Public License is included in this
- *      distribution in the file called COPYING.
- *
- *
- *  ------------------------------------------------------------------
- *
- *      This simple allocator implementation provides a
- *      malloc()/free()-like interface for reserving space within a
- *      previously reserved block of memory.  It is not specific to
- *      any hardware, nor is it coupled with the lower level paging
- *      mechanism.
- *
- *      The primary goal of this implementation is to provide a means
- *      to partition an arbitrary block of memory without actually
- *      accessing the memory or incurring any hardware side-effects
- *      (e.g. paging).  It is, in effect, a bookkeeping mechanism for
- *      buffers.
- */
-
-
-#include "memrar_allocator.h"
-#include <linux/slab.h>
-#include <linux/bug.h>
-#include <linux/kernel.h>
-
-
-struct memrar_allocator *memrar_create_allocator(unsigned long base,
-						 size_t capacity,
-						 size_t block_size)
-{
-	struct memrar_allocator *allocator  = NULL;
-	struct memrar_address_ranges *first_node = NULL;
-
-	/*
-	 * Make sure the base address is aligned on a block_size
-	 * boundary.
-	 *
-	 * @todo Is this necessary?
-	 */
-	/* base = ALIGN(base, block_size); */
-
-	/* Validate parameters.
-	 *
-	 * Make sure we can allocate the entire memory space.  Zero
-	 * capacity or block size are obviously invalid.
-	 */
-	if (base == 0
-	    || capacity == 0
-	    || block_size == 0
-	    || ULONG_MAX - capacity < base
-	    || capacity < block_size)
-		return allocator;
-
-	/*
-	 * There isn't much point in creating a memory allocator that
-	 * is only capable of holding one block but we'll allow it,
-	 * and issue a diagnostic.
-	 */
-	WARN(capacity < block_size * 2,
-	     "memrar: Only one block available to allocator.\n");
-
-	allocator = kmalloc(sizeof(*allocator), GFP_KERNEL);
-
-	if (allocator == NULL)
-		return allocator;
-
-	mutex_init(&allocator->lock);
-	allocator->base = base;
-
-	/* Round the capacity down to a multiple of block_size. */
-	allocator->capacity = (capacity / block_size) * block_size;
-
-	allocator->block_size = block_size;
-
-	allocator->largest_free_area = allocator->capacity;
-
-	/* Initialize the handle and free lists. */
-	INIT_LIST_HEAD(&allocator->allocated_list.list);
-	INIT_LIST_HEAD(&allocator->free_list.list);
-
-	first_node = kmalloc(sizeof(*first_node), GFP_KERNEL);
-	if (first_node == NULL)	{
-		kfree(allocator);
-		allocator = NULL;
-	} else {
-		/* Full range of blocks is available. */
-		first_node->range.begin = base;
-		first_node->range.end   = base + allocator->capacity;
-		list_add(&first_node->list,
-			 &allocator->free_list.list);
-	}
-
-	return allocator;
-}
-
-void memrar_destroy_allocator(struct memrar_allocator *allocator)
-{
-	/*
-	 * Assume that the memory allocator lock isn't held at this
-	 * point in time.  Caller must ensure that.
-	 */
-
-	struct memrar_address_ranges *pos = NULL;
-	struct memrar_address_ranges *n   = NULL;
-
-	if (allocator == NULL)
-		return;
-
-	mutex_lock(&allocator->lock);
-
-	/* Reclaim free list resources. */
-	list_for_each_entry_safe(pos,
-				 n,
-				 &allocator->free_list.list,
-				 list) {
-		list_del(&pos->list);
-		kfree(pos);
-	}
-
-	mutex_unlock(&allocator->lock);
-
-	kfree(allocator);
-}
-
-unsigned long memrar_allocator_alloc(struct memrar_allocator *allocator,
-				     size_t size)
-{
-	struct memrar_address_ranges *pos = NULL;
-
-	size_t num_blocks;
-	unsigned long reserved_bytes;
-
-	/*
-	 * Address of allocated buffer.  We assume that zero is not a
-	 * valid address.
-	 */
-	unsigned long addr = 0;
-
-	if (allocator == NULL || size == 0)
-		return addr;
-
-	/* Reserve enough blocks to hold the amount of bytes requested. */
-	num_blocks = DIV_ROUND_UP(size, allocator->block_size);
-
-	reserved_bytes = num_blocks * allocator->block_size;
-
-	mutex_lock(&allocator->lock);
-
-	if (reserved_bytes > allocator->largest_free_area) {
-		mutex_unlock(&allocator->lock);
-		return addr;
-	}
-
-	/*
-	 * Iterate through the free list to find a suitably sized
-	 * range of free contiguous memory blocks.
-	 *
-	 * We also take the opportunity to reset the size of the
-	 * largest free area size statistic.
-	 */
-	list_for_each_entry(pos, &allocator->free_list.list, list) {
-		struct memrar_address_range * const fr = &pos->range;
-		size_t const curr_size = fr->end - fr->begin;
-
-		if (curr_size >= reserved_bytes && addr == 0) {
-			struct memrar_address_range *range = NULL;
-			struct memrar_address_ranges * const new_node =
-				kmalloc(sizeof(*new_node), GFP_KERNEL);
-
-			if (new_node == NULL)
-				break;
-
-			list_add(&new_node->list,
-				 &allocator->allocated_list.list);
-
-			/*
-			 * Carve out area of memory from end of free
-			 * range.
-			 */
-			range        = &new_node->range;
-			range->end   = fr->end;
-			fr->end     -= reserved_bytes;
-			range->begin = fr->end;
-			addr         = range->begin;
-
-			/*
-			 * Check if largest area has decreased in
-			 * size.  We'll need to continue scanning for
-			 * the next largest area if it has.
-			 */
-			if (curr_size == allocator->largest_free_area)
-				allocator->largest_free_area -=
-					reserved_bytes;
-			else
-				break;
-		}
-
-		/*
-		 * Reset largest free area size statistic as needed,
-		 * but only if we've actually allocated memory.
-		 */
-		if (addr != 0
-		    && curr_size > allocator->largest_free_area) {
-			allocator->largest_free_area = curr_size;
-			break;
-		}
-	}
-
-	mutex_unlock(&allocator->lock);
-
-	return addr;
-}
-
-long memrar_allocator_free(struct memrar_allocator *allocator,
-			   unsigned long addr)
-{
-	struct list_head *pos = NULL;
-	struct list_head *tmp = NULL;
-	struct list_head *dst = NULL;
-
-	struct memrar_address_ranges      *allocated = NULL;
-	struct memrar_address_range const *handle    = NULL;
-
-	unsigned long old_end        = 0;
-	unsigned long new_chunk_size = 0;
-
-	if (allocator == NULL)
-		return -EINVAL;
-
-	if (addr == 0)
-		return 0;  /* Ignore "free(0)". */
-
-	mutex_lock(&allocator->lock);
-
-	/* Find the corresponding handle. */
-	list_for_each_entry(allocated,
-			    &allocator->allocated_list.list,
-			    list) {
-		if (allocated->range.begin == addr) {
-			handle = &allocated->range;
-			break;
-		}
-	}
-
-	/* No such buffer created by this allocator. */
-	if (handle == NULL) {
-		mutex_unlock(&allocator->lock);
-		return -EFAULT;
-	}
-
-	/*
-	 * Coalesce adjacent chunks of memory if possible.
-	 *
-	 * @note This isn't full blown coalescing since we're only
-	 *       coalescing at most three chunks of memory.
-	 */
-	list_for_each_safe(pos, tmp, &allocator->free_list.list) {
-		/* @todo O(n) performance.  Optimize. */
-
-		struct memrar_address_range * const chunk =
-			&list_entry(pos,
-				    struct memrar_address_ranges,
-				    list)->range;
-
-		/* Extend size of existing free adjacent chunk. */
-		if (chunk->end == handle->begin) {
-			/*
-			 * Chunk "less than" than the one we're
-			 * freeing is adjacent.
-			 *
-			 * Before:
-			 *
-			 *   +-----+------+
-			 *   |chunk|handle|
-			 *   +-----+------+
-			 *
-			 * After:
-			 *
-			 *   +------------+
-			 *   |   chunk    |
-			 *   +------------+
-			 */
-
-			struct memrar_address_ranges const * const next =
-				list_entry(pos->next,
-					   struct memrar_address_ranges,
-					   list);
-
-			chunk->end = handle->end;
-
-			/*
-			 * Now check if next free chunk is adjacent to
-			 * the current extended free chunk.
-			 *
-			 * Before:
-			 *
-			 *   +------------+----+
-			 *   |   chunk    |next|
-			 *   +------------+----+
-			 *
-			 * After:
-			 *
-			 *   +-----------------+
-			 *   |      chunk      |
-			 *   +-----------------+
-			 */
-			if (!list_is_singular(pos)
-			    && chunk->end == next->range.begin) {
-				chunk->end = next->range.end;
-				list_del(pos->next);
-				kfree(next);
-			}
-
-			list_del(&allocated->list);
-
-			new_chunk_size = chunk->end - chunk->begin;
-
-			goto exit_memrar_free;
-
-		} else if (handle->end == chunk->begin) {
-			/*
-			 * Chunk "greater than" than the one we're
-			 * freeing is adjacent.
-			 *
-			 *   +------+-----+
-			 *   |handle|chunk|
-			 *   +------+-----+
-			 *
-			 * After:
-			 *
-			 *   +------------+
-			 *   |   chunk    |
-			 *   +------------+
-			 */
-
-			struct memrar_address_ranges const * const prev =
-				list_entry(pos->prev,
-					   struct memrar_address_ranges,
-					   list);
-
-			chunk->begin = handle->begin;
-
-			/*
-			 * Now check if previous free chunk is
-			 * adjacent to the current extended free
-			 * chunk.
-			 *
-			 *
-			 * Before:
-			 *
-			 *   +----+------------+
-			 *   |prev|   chunk    |
-			 *   +----+------------+
-			 *
-			 * After:
-			 *
-			 *   +-----------------+
-			 *   |      chunk      |
-			 *   +-----------------+
-			 */
-			if (!list_is_singular(pos)
-			    && prev->range.end == chunk->begin) {
-				chunk->begin = prev->range.begin;
-				list_del(pos->prev);
-				kfree(prev);
-			}
-
-			list_del(&allocated->list);
-
-			new_chunk_size = chunk->end - chunk->begin;
-
-			goto exit_memrar_free;
-
-		} else if (chunk->end < handle->begin
-			   && chunk->end > old_end) {
-			/* Keep track of where the entry could be
-			 * potentially moved from the "allocated" list
-			 * to the "free" list if coalescing doesn't
-			 * occur, making sure the "free" list remains
-			 * sorted.
-			 */
-			old_end = chunk->end;
-			dst = pos;
-		}
-	}
-
-	/*
-	 * Nothing to coalesce.
-	 *
-	 * Move the entry from the "allocated" list to the "free"
-	 * list.
-	 */
-	list_move(&allocated->list, dst);
-	new_chunk_size = handle->end - handle->begin;
-	allocated = NULL;
-
-exit_memrar_free:
-
-	if (new_chunk_size > allocator->largest_free_area)
-		allocator->largest_free_area = new_chunk_size;
-
-	mutex_unlock(&allocator->lock);
-
-	kfree(allocated);
-
-	return 0;
-}
-
-
-
-/*
-  Local Variables:
-    c-file-style: "linux"
-  End:
-*/
diff --git a/drivers/staging/memrar/memrar_allocator.h b/drivers/staging/memrar/memrar_allocator.h
deleted file mode 100644
index 0b80dea..0000000
--- a/drivers/staging/memrar/memrar_allocator.h
+++ /dev/null
@@ -1,149 +0,0 @@
-/*
- *      Copyright (C) 2010 Intel Corporation. All rights reserved.
- *
- *      This program is free software; you can redistribute it and/or
- *      modify it under the terms of version 2 of the GNU General
- *      Public License as published by the Free Software Foundation.
- *
- *      This program is distributed in the hope that it will be
- *      useful, but WITHOUT ANY WARRANTY; without even the implied
- *      warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
- *      PURPOSE.  See the GNU General Public License for more details.
- *      You should have received a copy of the GNU General Public
- *      License along with this program; if not, write to the Free
- *      Software Foundation, Inc., 59 Temple Place - Suite 330,
- *      Boston, MA  02111-1307, USA.
- *      The full GNU General Public License is included in this
- *      distribution in the file called COPYING.
- */
-
-#ifndef MEMRAR_ALLOCATOR_H
-#define MEMRAR_ALLOCATOR_H
-
-
-#include <linux/mutex.h>
-#include <linux/list.h>
-#include <linux/types.h>
-#include <linux/kernel.h>
-
-
-/**
- * struct memrar_address_range - struct that describes a memory range
- * @begin:	Beginning of available address range.
- * @end:	End of available address range, one past the end,
- *		i.e. [begin, end).
- */
-struct memrar_address_range {
-/* private: internal use only */
-	unsigned long begin;
-	unsigned long end;
-};
-
-/**
- * struct memrar_address_ranges - list of areas of memory.
- * @list:	Linked list of address ranges.
- * @range:	Memory address range corresponding to given list node.
- */
-struct memrar_address_ranges {
-/* private: internal use only */
-	struct list_head list;
-	struct memrar_address_range range;
-};
-
-/**
- * struct memrar_allocator - encapsulation of the memory allocator state
- * @lock:		Lock used to synchronize access to the memory
- *			allocator state.
- * @base:		Base (start) address of the allocator memory
- *			space.
- * @capacity:		Size of the allocator memory space in bytes.
- * @block_size:		The size in bytes of individual blocks within
- *			the allocator memory space.
- * @largest_free_area:	Largest free area of memory in the allocator
- *			in bytes.
- * @allocated_list:	List of allocated memory block address
- *			ranges.
- * @free_list:		List of free address ranges.
- *
- * This structure contains all memory allocator state, including the
- * base address, capacity, free list, lock, etc.
- */
-struct memrar_allocator {
-/* private: internal use only */
-	struct mutex lock;
-	unsigned long base;
-	size_t capacity;
-	size_t block_size;
-	size_t largest_free_area;
-	struct memrar_address_ranges allocated_list;
-	struct memrar_address_ranges free_list;
-};
-
-/**
- * memrar_create_allocator() - create a memory allocator
- * @base:	Address at which the memory allocator begins.
- * @capacity:	Desired size of the memory allocator.  This value must
- *		be larger than the block_size, ideally more than twice
- *		as large since there wouldn't be much point in using a
- *		memory allocator otherwise.
- * @block_size:	The size of individual blocks within the memory
- *		allocator.  This value must smaller than the
- *		capacity.
- *
- * Create a memory allocator with the given capacity and block size.
- * The capacity will be reduced to be a multiple of the block size, if
- * necessary.
- *
- * Returns an instance of the memory allocator, if creation succeeds,
- * otherwise zero if creation fails.  Failure may occur if not enough
- * kernel memory exists to create the memrar_allocator instance
- * itself, or if the capacity and block_size arguments are not
- * compatible or make sense.
- */
-struct memrar_allocator *memrar_create_allocator(unsigned long base,
-						 size_t capacity,
-						 size_t block_size);
-
-/**
- * memrar_destroy_allocator() - destroy allocator
- * @allocator:	The allocator being destroyed.
- *
- * Reclaim resources held by the memory allocator.  The caller must
- * explicitly free all memory reserved by memrar_allocator_alloc()
- * prior to calling this function.  Otherwise leaks will occur.
- */
-void memrar_destroy_allocator(struct memrar_allocator *allocator);
-
-/**
- * memrar_allocator_alloc() - reserve an area of memory of given size
- * @allocator:	The allocator instance being used to reserve buffer.
- * @size:	The size in bytes of the buffer to allocate.
- *
- * This functions reserves an area of memory managed by the given
- * allocator.  It returns zero if allocation was not possible.
- * Failure may occur if the allocator no longer has space available.
- */
-unsigned long memrar_allocator_alloc(struct memrar_allocator *allocator,
-				     size_t size);
-
-/**
- * memrar_allocator_free() - release buffer starting at given address
- * @allocator:	The allocator instance being used to release the buffer.
- * @address:	The address of the buffer being released.
- *
- * Release an area of memory starting at the given address.  Failure
- * could occur if the given address is not in the address space
- * managed by the allocator.  Returns zero on success or an errno
- * (negative value) on failure.
- */
-long memrar_allocator_free(struct memrar_allocator *allocator,
-			   unsigned long address);
-
-#endif  /* MEMRAR_ALLOCATOR_H */
-
-
-/*
-  Local Variables:
-    c-file-style: "linux"
-  End:
-*/
diff --git a/drivers/staging/memrar/memrar_handler.c b/drivers/staging/memrar/memrar_handler.c
deleted file mode 100644
index cfcaa8e..0000000
--- a/drivers/staging/memrar/memrar_handler.c
+++ /dev/null
@@ -1,1007 +0,0 @@
-/*
- *      memrar_handler 1.0:  An Intel restricted access region handler device
- *
- *      Copyright (C) 2010 Intel Corporation. All rights reserved.
- *
- *      This program is free software; you can redistribute it and/or
- *      modify it under the terms of version 2 of the GNU General
- *      Public License as published by the Free Software Foundation.
- *
- *      This program is distributed in the hope that it will be
- *      useful, but WITHOUT ANY WARRANTY; without even the implied
- *      warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
- *      PURPOSE.  See the GNU General Public License for more details.
- *      You should have received a copy of the GNU General Public
- *      License along with this program; if not, write to the Free
- *      Software Foundation, Inc., 59 Temple Place - Suite 330,
- *      Boston, MA  02111-1307, USA.
- *      The full GNU General Public License is included in this
- *      distribution in the file called COPYING.
- *
- * -------------------------------------------------------------------
- *
- *      Moorestown restricted access regions (RAR) provide isolated
- *      areas of main memory that are only acceessible by authorized
- *      devices.
- *
- *      The Intel Moorestown RAR handler module exposes a kernel space
- *      RAR memory management mechanism.  It is essentially a
- *      RAR-specific allocator.
- *
- *      Besides providing RAR buffer management, the RAR handler also
- *      behaves in many ways like an OS virtual memory manager.  For
- *      example, the RAR "handles" created by the RAR handler are
- *      analogous to user space virtual addresses.
- *
- *      RAR memory itself is never accessed directly by the RAR
- *      handler.
- */
-
-#include <linux/miscdevice.h>
-#include <linux/fs.h>
-#include <linux/slab.h>
-#include <linux/kref.h>
-#include <linux/mutex.h>
-#include <linux/kernel.h>
-#include <linux/uaccess.h>
-#include <linux/mm.h>
-#include <linux/ioport.h>
-#include <linux/io.h>
-#include <linux/rar_register.h>
-
-#include "memrar.h"
-#include "memrar_allocator.h"
-
-
-#define MEMRAR_VER "1.0"
-
-/*
- * Moorestown supports three restricted access regions.
- *
- * We only care about the first two, video and audio.  The third,
- * reserved for Chaabi and the P-unit, will be handled by their
- * respective drivers.
- */
-#define MRST_NUM_RAR 2
-
-/* ---------------- -------------------- ------------------- */
-
-/**
- * struct memrar_buffer_info - struct that keeps track of all RAR buffers
- * @list:	Linked list of memrar_buffer_info objects.
- * @buffer:	Core RAR buffer information.
- * @refcount:	Reference count.
- * @owner:	File handle corresponding to process that reserved the
- *		block of memory in RAR.  This will be zero for buffers
- *		allocated by other drivers instead of by a user space
- *		process.
- *
- * This structure encapsulates a link list of RAR buffers, as well as
- * other characteristics specific to a given list node, such as the
- * reference count on the corresponding RAR buffer.
- */
-struct memrar_buffer_info {
-	struct list_head list;
-	struct RAR_buffer buffer;
-	struct kref refcount;
-	struct file *owner;
-};
-
-/**
- * struct memrar_rar_info - characteristics of a given RAR
- * @base:	Base bus address of the RAR.
- * @length:	Length of the RAR.
- * @iobase:	Virtual address of RAR mapped into kernel.
- * @allocator:	Allocator associated with the RAR.  Note the allocator
- *		"capacity" may be smaller than the RAR length if the
- *		length is not a multiple of the configured allocator
- *		block size.
- * @buffers:	Table that keeps track of all reserved RAR buffers.
- * @lock:	Lock used to synchronize access to RAR-specific data
- *		structures.
- *
- * Each RAR has an associated memrar_rar_info structure that describes
- * where in memory the RAR is located, how large it is, and a list of
- * reserved RAR buffers inside that RAR.  Each RAR also has a mutex
- * associated with it to reduce lock contention when operations on
- * multiple RARs are performed in parallel.
- */
-struct memrar_rar_info {
-	dma_addr_t base;
-	unsigned long length;
-	void __iomem *iobase;
-	struct memrar_allocator *allocator;
-	struct memrar_buffer_info buffers;
-	struct mutex lock;
-	int allocated;	/* True if we own this RAR */
-};
-
-/*
- * Array of RAR characteristics.
- */
-static struct memrar_rar_info memrars[MRST_NUM_RAR];
-
-/* ---------------- -------------------- ------------------- */
-
-/* Validate RAR type. */
-static inline int memrar_is_valid_rar_type(u32 type)
-{
-	return type == RAR_TYPE_VIDEO || type == RAR_TYPE_AUDIO;
-}
-
-/* Check if an address/handle falls with the given RAR memory range. */
-static inline int memrar_handle_in_range(struct memrar_rar_info *rar,
-					 u32 vaddr)
-{
-	unsigned long const iobase = (unsigned long) (rar->iobase);
-	return (vaddr >= iobase && vaddr < iobase + rar->length);
-}
-
-/* Retrieve RAR information associated with the given handle. */
-static struct memrar_rar_info *memrar_get_rar_info(u32 vaddr)
-{
-	int i;
-	for (i = 0; i < MRST_NUM_RAR; ++i) {
-		struct memrar_rar_info * const rar = &memrars[i];
-		if (memrar_handle_in_range(rar, vaddr))
-			return rar;
-	}
-
-	return NULL;
-}
-
-/**
- *	memrar_get_bus address		-	handle to bus address
- *
- *	Retrieve bus address from given handle.
- *
- *	Returns address corresponding to given handle.  Zero if handle is
- *	invalid.
- */
-static dma_addr_t memrar_get_bus_address(
-	struct memrar_rar_info *rar,
-	u32 vaddr)
-{
-	unsigned long const iobase = (unsigned long) (rar->iobase);
-
-	if (!memrar_handle_in_range(rar, vaddr))
-		return 0;
-
-	/*
-	 * An assumption is made that the virtual address offset is
-	 * the same as the bus address offset, at least based on the
-	 * way this driver is implemented.  For example, vaddr + 2 ==
-	 * baddr + 2.
-	 *
-	 * @todo Is that a valid assumption?
-	 */
-	return rar->base + (vaddr - iobase);
-}
-
-/**
- *	memrar_get_physical_address	-	handle to physical address
- *
- *	Retrieve physical address from given handle.
- *
- *	Returns address corresponding to given handle.  Zero if handle is
- *	invalid.
- */
-static dma_addr_t memrar_get_physical_address(
-	struct memrar_rar_info *rar,
-	u32 vaddr)
-{
-	/*
-	 * @todo This assumes that the bus address and physical
-	 *       address are the same.  That is true for Moorestown
-	 *       but not necessarily on other platforms.  This
-	 *       deficiency should be addressed at some point.
-	 */
-	return memrar_get_bus_address(rar, vaddr);
-}
-
-/**
- *	memrar_release_block	-	release a block to the pool
- *	@kref: kref of block
- *
- *	Core block release code. A node has hit zero references so can
- *	be released and the lists must be updated.
- *
- *	Note: This code removes the node from a list.  Make sure any list
- *	iteration is performed using list_for_each_safe().
- */
-static void memrar_release_block_i(struct kref *ref)
-{
-	/*
-	 * Last reference is being released.  Remove from the table,
-	 * and reclaim resources.
-	 */
-
-	struct memrar_buffer_info * const node =
-		container_of(ref, struct memrar_buffer_info, refcount);
-
-	struct RAR_block_info * const user_info =
-		&node->buffer.info;
-
-	struct memrar_allocator * const allocator =
-		memrars[user_info->type].allocator;
-
-	list_del(&node->list);
-
-	memrar_allocator_free(allocator, user_info->handle);
-
-	kfree(node);
-}
-
-/**
- *	memrar_init_rar_resources	-	configure a RAR
- *	@rarnum: rar that has been allocated
- *	@devname: name of our device
- *
- *	Initialize RAR parameters, such as bus addresses, etc and make
- *	the resource accessible.
- */
-static int memrar_init_rar_resources(int rarnum, char const *devname)
-{
-	/* ---- Sanity Checks ----
-	 * 1. RAR bus addresses in both Lincroft and Langwell RAR
-	 *    registers should be the same.
-	 *    a. There's no way we can do this through IA.
-	 *
-	 * 2. Secure device ID in Langwell RAR registers should be set
-	 *    appropriately, e.g. only LPE DMA for the audio RAR, and
-	 *    security for the other Langwell based RAR registers.
-	 *    a. There's no way we can do this through IA.
-	 *
-	 * 3. Audio and video RAR registers and RAR access should be
-	 *    locked down.  If not, enable RAR access control.  Except
-	 *    for debugging purposes, there is no reason for them to
-	 *    be unlocked.
-	 *    a.  We can only do this for the Lincroft (IA) side.
-	 *
-	 * @todo Should the RAR handler driver even be aware of audio
-	 *       and video RAR settings?
-	 */
-
-	/*
-	 * RAR buffer block size.
-	 *
-	 * We choose it to be the size of a page to simplify the
-	 * /dev/memrar mmap() implementation and usage.  Otherwise
-	 * paging is not involved once an RAR is locked down.
-	 */
-	static size_t const RAR_BLOCK_SIZE = PAGE_SIZE;
-
-	dma_addr_t low, high;
-	struct memrar_rar_info * const rar = &memrars[rarnum];
-
-	BUG_ON(MRST_NUM_RAR != ARRAY_SIZE(memrars));
-	BUG_ON(!memrar_is_valid_rar_type(rarnum));
-	BUG_ON(rar->allocated);
-
-	if (rar_get_address(rarnum, &low, &high) != 0)
-		/* No RAR is available. */
-		return -ENODEV;
-
-	if (low == 0 || high == 0) {
-		rar->base      = 0;
-		rar->length    = 0;
-		rar->iobase    = NULL;
-		rar->allocator = NULL;
-		return -ENOSPC;
-	}
-
-	/*
-	 * @todo Verify that LNC and LNW RAR register contents
-	 *       addresses, security, etc are compatible and
-	 *       consistent).
-	 */
-
-	rar->length = high - low + 1;
-
-	/* Claim RAR memory as our own. */
-	if (request_mem_region(low, rar->length, devname) == NULL) {
-		rar->length = 0;
-		pr_err("%s: Unable to claim RAR[%d] memory.\n",
-		       devname, rarnum);
-		pr_err("%s: RAR[%d] disabled.\n", devname, rarnum);
-		return -EBUSY;
-	}
-
-	rar->base = low;
-
-	/*
-	 * Now map it into the kernel address space.
-	 *
-	 * Note that the RAR memory may only be accessed by IA
-	 * when debugging.  Otherwise attempts to access the
-	 * RAR memory when it is locked down will result in
-	 * behavior similar to writing to /dev/null and
-	 * reading from /dev/zero.  This behavior is enforced
-	 * by the hardware.  Even if we don't access the
-	 * memory, mapping it into the kernel provides us with
-	 * a convenient RAR handle to bus address mapping.
-	 */
-	rar->iobase = ioremap_nocache(rar->base, rar->length);
-	if (rar->iobase == NULL) {
-		pr_err("%s: Unable to map RAR memory.\n", devname);
-		release_mem_region(low, rar->length);
-		return -ENOMEM;
-	}
-
-	/* Initialize corresponding memory allocator. */
-	rar->allocator = memrar_create_allocator((unsigned long) rar->iobase,
-						rar->length, RAR_BLOCK_SIZE);
-	if (rar->allocator == NULL) {
-		iounmap(rar->iobase);
-		release_mem_region(low, rar->length);
-		return -ENOMEM;
-	}
-
-	pr_info("%s: BRAR[%d] bus address range = [0x%lx, 0x%lx]\n",
-		devname, rarnum, (unsigned long) low, (unsigned long) high);
-
-	pr_info("%s: BRAR[%d] size = %zu KiB\n",
-			devname, rarnum, rar->allocator->capacity / 1024);
-
-	rar->allocated = 1;
-	return 0;
-}
-
-/**
- *	memrar_fini_rar_resources	-	free up RAR resources
- *
- *	Finalize RAR resources. Free up the resource tables, hand the memory
- *	back to the kernel, unmap the device and release the address space.
- */
-static void memrar_fini_rar_resources(void)
-{
-	int z;
-	struct memrar_buffer_info *pos;
-	struct memrar_buffer_info *tmp;
-
-	/*
-	 * @todo Do we need to hold a lock at this point in time?
-	 *       (module initialization failure or exit?)
-	 */
-
-	for (z = MRST_NUM_RAR; z-- != 0; ) {
-		struct memrar_rar_info * const rar = &memrars[z];
-
-		if (!rar->allocated)
-			continue;
-
-		/* Clean up remaining resources. */
-
-		list_for_each_entry_safe(pos,
-					 tmp,
-					 &rar->buffers.list,
-					 list) {
-			kref_put(&pos->refcount, memrar_release_block_i);
-		}
-
-		memrar_destroy_allocator(rar->allocator);
-		rar->allocator = NULL;
-
-		iounmap(rar->iobase);
-		release_mem_region(rar->base, rar->length);
-
-		rar->iobase = NULL;
-		rar->base = 0;
-		rar->length = 0;
-
-		unregister_rar(z);
-	}
-}
-
-/**
- *	memrar_reserve_block	-	handle an allocation request
- *	@request: block being requested
- *	@filp: owner it is tied to
- *
- *	Allocate a block of the requested RAR. If successful return the
- *	request object filled in and zero, if not report an error code
- */
-
-static long memrar_reserve_block(struct RAR_buffer *request,
-				 struct file *filp)
-{
-	struct RAR_block_info * const rinfo = &request->info;
-	struct RAR_buffer *buffer;
-	struct memrar_buffer_info *buffer_info;
-	u32 handle;
-	struct memrar_rar_info *rar = NULL;
-
-	/* Prevent array overflow. */
-	if (!memrar_is_valid_rar_type(rinfo->type))
-		return -EINVAL;
-
-	rar = &memrars[rinfo->type];
-	if (!rar->allocated)
-		return -ENODEV;
-
-	/* Reserve memory in RAR. */
-	handle = memrar_allocator_alloc(rar->allocator, rinfo->size);
-	if (handle == 0)
-		return -ENOMEM;
-
-	buffer_info = kmalloc(sizeof(*buffer_info), GFP_KERNEL);
-
-	if (buffer_info == NULL) {
-		memrar_allocator_free(rar->allocator, handle);
-		return -ENOMEM;
-	}
-
-	buffer = &buffer_info->buffer;
-	buffer->info.type = rinfo->type;
-	buffer->info.size = rinfo->size;
-
-	/* Memory handle corresponding to the bus address. */
-	buffer->info.handle = handle;
-	buffer->bus_address = memrar_get_bus_address(rar, handle);
-
-	/*
-	 * Keep track of owner so that we can later cleanup if
-	 * necessary.
-	 */
-	buffer_info->owner = filp;
-
-	kref_init(&buffer_info->refcount);
-
-	mutex_lock(&rar->lock);
-	list_add(&buffer_info->list, &rar->buffers.list);
-	mutex_unlock(&rar->lock);
-
-	rinfo->handle = buffer->info.handle;
-	request->bus_address = buffer->bus_address;
-
-	return 0;
-}
-
-/**
- *	memrar_release_block		-	release a RAR block
- *	@addr: address in RAR space
- *
- *	Release a previously allocated block. Releases act on complete
- *	blocks, partially freeing a block is not supported
- */
-
-static long memrar_release_block(u32 addr)
-{
-	struct memrar_buffer_info *pos;
-	struct memrar_buffer_info *tmp;
-	struct memrar_rar_info * const rar = memrar_get_rar_info(addr);
-	long result = -EINVAL;
-
-	if (rar == NULL)
-		return -ENOENT;
-
-	mutex_lock(&rar->lock);
-
-	/*
-	 * Iterate through the buffer list to find the corresponding
-	 * buffer to be released.
-	 */
-	list_for_each_entry_safe(pos,
-				 tmp,
-				 &rar->buffers.list,
-				 list) {
-		struct RAR_block_info * const info =
-			&pos->buffer.info;
-
-		/*
-		 * Take into account handle offsets that may have been
-		 * added to the base handle, such as in the following
-		 * scenario:
-		 *
-		 *     u32 handle = base + offset;
-		 *     rar_handle_to_bus(handle);
-		 *     rar_release(handle);
-		 */
-		if (addr >= info->handle
-		    && addr < (info->handle + info->size)
-		    && memrar_is_valid_rar_type(info->type)) {
-			kref_put(&pos->refcount, memrar_release_block_i);
-			result = 0;
-			break;
-		}
-	}
-
-	mutex_unlock(&rar->lock);
-
-	return result;
-}
-
-/**
- *	memrar_get_stats	-	read statistics for a RAR
- *	@r: statistics to be filled in
- *
- *	Returns the statistics data for the RAR, or an error code if
- *	the request cannot be completed
- */
-static long memrar_get_stat(struct RAR_stat *r)
-{
-	struct memrar_allocator *allocator;
-
-	if (!memrar_is_valid_rar_type(r->type))
-		return -EINVAL;
-
-	if (!memrars[r->type].allocated)
-		return -ENODEV;
-
-	allocator = memrars[r->type].allocator;
-
-	BUG_ON(allocator == NULL);
-
-	/*
-	 * Allocator capacity doesn't change over time.  No
-	 * need to synchronize.
-	 */
-	r->capacity = allocator->capacity;
-
-	mutex_lock(&allocator->lock);
-	r->largest_block_size = allocator->largest_free_area;
-	mutex_unlock(&allocator->lock);
-	return 0;
-}
-
-/**
- *	memrar_ioctl		-	ioctl callback
- *	@filp: file issuing the request
- *	@cmd: command
- *	@arg: pointer to control information
- *
- *	Perform one of the ioctls supported by the memrar device
- */
-
-static long memrar_ioctl(struct file *filp,
-			 unsigned int cmd,
-			 unsigned long arg)
-{
-	void __user *argp = (void __user *)arg;
-	long result = 0;
-
-	struct RAR_buffer buffer;
-	struct RAR_block_info * const request = &buffer.info;
-	struct RAR_stat rar_info;
-	u32 rar_handle;
-
-	switch (cmd) {
-	case RAR_HANDLER_RESERVE:
-		if (copy_from_user(request,
-				   argp,
-				   sizeof(*request)))
-			return -EFAULT;
-
-		result = memrar_reserve_block(&buffer, filp);
-		if (result != 0)
-			return result;
-
-		return copy_to_user(argp, request, sizeof(*request));
-
-	case RAR_HANDLER_RELEASE:
-		if (copy_from_user(&rar_handle,
-				   argp,
-				   sizeof(rar_handle)))
-			return -EFAULT;
-
-		return memrar_release_block(rar_handle);
-
-	case RAR_HANDLER_STAT:
-		if (copy_from_user(&rar_info,
-				   argp,
-				   sizeof(rar_info)))
-			return -EFAULT;
-
-		/*
-		 * Populate the RAR_stat structure based on the RAR
-		 * type given by the user
-		 */
-		if (memrar_get_stat(&rar_info) != 0)
-			return -EINVAL;
-
-		/*
-		 * @todo Do we need to verify destination pointer
-		 *       "argp" is non-zero?  Is that already done by
-		 *       copy_to_user()?
-		 */
-		return copy_to_user(argp,
-				    &rar_info,
-				    sizeof(rar_info)) ? -EFAULT : 0;
-
-	default:
-		return -ENOTTY;
-	}
-
-	return 0;
-}
-
-/**
- *	memrar_mmap		-	mmap helper for deubgging
- *	@filp: handle doing the mapping
- *	@vma: memory area
- *
- *	Support the mmap operation on the RAR space for debugging systems
- *	when the memory is not locked down.
- */
-
-static int memrar_mmap(struct file *filp, struct vm_area_struct *vma)
-{
-	/*
-	 * This mmap() implementation is predominantly useful for
-	 * debugging since the CPU will be prevented from accessing
-	 * RAR memory by the hardware when RAR is properly locked
-	 * down.
-	 *
-	 * In order for this implementation to be useful RAR memory
-	 * must be not be locked down.  However, we only want to do
-	 * that when debugging.  DO NOT leave RAR memory unlocked in a
-	 * deployed device that utilizes RAR.
-	 */
-
-	size_t const size = vma->vm_end - vma->vm_start;
-
-	/* Users pass the RAR handle as the mmap() offset parameter. */
-	unsigned long const handle = vma->vm_pgoff << PAGE_SHIFT;
-
-	struct memrar_rar_info * const rar = memrar_get_rar_info(handle);
-	unsigned long pfn;
-
-	/* Only allow priviledged apps to go poking around this way */
-	if (!capable(CAP_SYS_RAWIO))
-		return -EPERM;
-
-	/* Invalid RAR handle or size passed to mmap(). */
-	if (rar == NULL
-	    || handle == 0
-	    || size > (handle - (unsigned long) rar->iobase))
-		return -EINVAL;
-
-	/*
-	 * Retrieve physical address corresponding to the RAR handle,
-	 * and convert it to a page frame.
-	 */
-	pfn = memrar_get_physical_address(rar, handle) >> PAGE_SHIFT;
-
-
-	pr_debug("memrar: mapping RAR range [0x%lx, 0x%lx) into user space.\n",
-		 handle,
-		 handle + size);
-
-	/*
-	 * Map RAR memory into user space.  This is really only useful
-	 * for debugging purposes since the memory won't be
-	 * accessible, i.e. reads return zero and writes are ignored,
-	 * when RAR access control is enabled.
-	 */
-	if (remap_pfn_range(vma,
-			    vma->vm_start,
-			    pfn,
-			    size,
-			    vma->vm_page_prot))
-		return -EAGAIN;
-
-	/* vma->vm_ops = &memrar_mem_ops; */
-
-	return 0;
-}
-
-/**
- *	memrar_open		-	device open method
- *	@inode: inode to open
- *	@filp: file handle
- *
- *	As we support multiple arbitary opens there is no work to be done
- *	really.
- */
-
-static int memrar_open(struct inode *inode, struct file *filp)
-{
-	nonseekable_open(inode, filp);
-	return 0;
-}
-
-/**
- *	memrar_release		-	close method for miscev
- *	@inode: inode of device
- *	@filp: handle that is going away
- *
- *	Free up all the regions that belong to this file handle. We use
- *	the handle as a natural Linux style 'lifetime' indicator and to
- *	ensure resources are not leaked when their owner explodes in an
- *	unplanned fashion.
- */
-
-static int memrar_release(struct inode *inode, struct file *filp)
-{
-	/* Free all regions associated with the given file handle. */
-
-	struct memrar_buffer_info *pos;
-	struct memrar_buffer_info *tmp;
-	int z;
-
-	for (z = 0; z != MRST_NUM_RAR; ++z) {
-		struct memrar_rar_info * const rar = &memrars[z];
-
-		mutex_lock(&rar->lock);
-
-		list_for_each_entry_safe(pos,
-					 tmp,
-					 &rar->buffers.list,
-					 list) {
-			if (filp == pos->owner)
-				kref_put(&pos->refcount,
-					 memrar_release_block_i);
-		}
-
-		mutex_unlock(&rar->lock);
-	}
-
-	return 0;
-}
-
-/**
- *	rar_reserve		-	reserve RAR memory
- *	@buffers: buffers to reserve
- *	@count: number wanted
- *
- *	Reserve a series of buffers in the RAR space. Returns the number of
- *	buffers successfully allocated
- */
-
-size_t rar_reserve(struct RAR_buffer *buffers, size_t count)
-{
-	struct RAR_buffer * const end =
-		(buffers == NULL ? buffers : buffers + count);
-	struct RAR_buffer *i;
-
-	size_t reserve_count = 0;
-
-	for (i = buffers; i != end; ++i) {
-		if (memrar_reserve_block(i, NULL) == 0)
-			++reserve_count;
-		else
-			i->bus_address = 0;
-	}
-
-	return reserve_count;
-}
-EXPORT_SYMBOL(rar_reserve);
-
-/**
- *	rar_release		-	return RAR buffers
- *	@buffers: buffers to release
- *	@size: size of released block
- *
- *	Return a set of buffers to the RAR pool
- */
-
-size_t rar_release(struct RAR_buffer *buffers, size_t count)
-{
-	struct RAR_buffer * const end =
-		(buffers == NULL ? buffers : buffers + count);
-	struct RAR_buffer *i;
-
-	size_t release_count = 0;
-
-	for (i = buffers; i != end; ++i) {
-		u32 * const handle = &i->info.handle;
-		if (memrar_release_block(*handle) == 0) {
-			/*
-			 * @todo We assume we should do this each time
-			 *       the ref count is decremented.  Should
-			 *       we instead only do this when the ref
-			 *       count has dropped to zero, and the
-			 *       buffer has been completely
-			 *       released/unmapped?
-			 */
-			*handle = 0;
-			++release_count;
-		}
-	}
-
-	return release_count;
-}
-EXPORT_SYMBOL(rar_release);
-
-/**
- *	rar_handle_to_bus	-	RAR to bus address
- *	@buffers: RAR buffer structure
- *	@count: number of buffers to convert
- *
- *	Turn a list of RAR handle mappings into actual bus addresses. Note
- *	that when the device is locked down the bus addresses in question
- *	are not CPU accessible.
- */
-
-size_t rar_handle_to_bus(struct RAR_buffer *buffers, size_t count)
-{
-	struct RAR_buffer * const end =
-		(buffers == NULL ? buffers : buffers + count);
-	struct RAR_buffer *i;
-	struct memrar_buffer_info *pos;
-
-	size_t conversion_count = 0;
-
-	/*
-	 * Find all bus addresses corresponding to the given handles.
-	 *
-	 * @todo Not liking this nested loop.  Optimize.
-	 */
-	for (i = buffers; i != end; ++i) {
-		struct memrar_rar_info * const rar =
-			memrar_get_rar_info(i->info.handle);
-
-		/*
-		 * Check if we have a bogus handle, and then continue
-		 * with remaining buffers.
-		 */
-		if (rar == NULL) {
-			i->bus_address = 0;
-			continue;
-		}
-
-		mutex_lock(&rar->lock);
-
-		list_for_each_entry(pos, &rar->buffers.list, list) {
-			struct RAR_block_info * const user_info =
-				&pos->buffer.info;
-
-			/*
-			 * Take into account handle offsets that may
-			 * have been added to the base handle, such as
-			 * in the following scenario:
-			 *
-			 *     u32 handle = base + offset;
-			 *     rar_handle_to_bus(handle);
-			 */
-
-			if (i->info.handle >= user_info->handle
-			    && i->info.handle < (user_info->handle
-						 + user_info->size)) {
-				u32 const offset =
-					i->info.handle - user_info->handle;
-
-				i->info.type = user_info->type;
-				i->info.size = user_info->size - offset;
-				i->bus_address =
-					pos->buffer.bus_address
-					+ offset;
-
-				/* Increment the reference count. */
-				kref_get(&pos->refcount);
-
-				++conversion_count;
-				break;
-			} else {
-				i->bus_address = 0;
-			}
-		}
-
-		mutex_unlock(&rar->lock);
-	}
-
-	return conversion_count;
-}
-EXPORT_SYMBOL(rar_handle_to_bus);
-
-static const struct file_operations memrar_fops = {
-	.owner = THIS_MODULE,
-	.unlocked_ioctl = memrar_ioctl,
-	.mmap           = memrar_mmap,
-	.open           = memrar_open,
-	.release        = memrar_release,
-	.llseek		= no_llseek,
-};
-
-static struct miscdevice memrar_miscdev = {
-	.minor = MISC_DYNAMIC_MINOR,    /* dynamic allocation */
-	.name = "memrar",               /* /dev/memrar */
-	.fops = &memrar_fops
-};
-
-static char const banner[] __initdata =
-	KERN_INFO
-	"Intel RAR Handler: " MEMRAR_VER " initialized.\n";
-
-/**
- *	memrar_registration_callback	-	RAR obtained
- *	@rar: RAR number
- *
- *	We have been granted ownership of the RAR. Add it to our memory
- *	management tables
- */
-
-static int memrar_registration_callback(unsigned long rar)
-{
-	/*
-	 * We initialize the RAR parameters early on so that we can
-	 * discontinue memrar device initialization and registration
-	 * if suitably configured RARs are not available.
-	 */
-	return memrar_init_rar_resources(rar, memrar_miscdev.name);
-}
-
-/**
- *	memrar_init	-	initialise RAR support
- *
- *	Initialise support for RAR handlers. This may get loaded before
- *	the RAR support is activated, but the callbacks on the registration
- *	will handle that situation for us anyway.
- */
-
-static int __init memrar_init(void)
-{
-	int err;
-	int i;
-
-	printk(banner);
-
-	/*
-	 * Some delayed initialization is performed in this driver.
-	 * Make sure resources that are used during driver clean-up
-	 * (e.g. during driver's release() function) are fully
-	 * initialized before first use.  This is particularly
-	 * important for the case when the delayed initialization
-	 * isn't completed, leaving behind a partially initialized
-	 * driver.
-	 *
-	 * Such a scenario can occur when RAR is not available on the
-	 * platform, and the driver is release()d.
-	 */
-	for (i = 0; i != ARRAY_SIZE(memrars); ++i) {
-		struct memrar_rar_info * const rar = &memrars[i];
-		mutex_init(&rar->lock);
-		INIT_LIST_HEAD(&rar->buffers.list);
-	}
-
-	err = misc_register(&memrar_miscdev);
-	if (err)
-		return err;
-
-	/* Now claim the two RARs we want */
-	err = register_rar(0, memrar_registration_callback, 0);
-	if (err)
-		goto fail;
-
-	err = register_rar(1, memrar_registration_callback, 1);
-	if (err == 0)
-		return 0;
-
-	/* It is possible rar 0 registered and allocated resources then rar 1
-	   failed so do a full resource free */
-	memrar_fini_rar_resources();
-fail:
-	misc_deregister(&memrar_miscdev);
-	return err;
-}
-
-/**
- *	memrar_exit	-	unregister and unload
- *
- *	Unregister the device and then unload any mappings and release
- *	the RAR resources
- */
-
-static void __exit memrar_exit(void)
-{
-	misc_deregister(&memrar_miscdev);
-	memrar_fini_rar_resources();
-}
-
-
-module_init(memrar_init);
-module_exit(memrar_exit);
-
-
-MODULE_AUTHOR("Ossama Othman <ossama.othman@intel.com>");
-MODULE_DESCRIPTION("Intel Restricted Access Region Handler");
-MODULE_LICENSE("GPL");
-MODULE_VERSION(MEMRAR_VER);
-
-
-
-/*
-  Local Variables:
-    c-file-style: "linux"
-  End:
-*/
diff --git a/drivers/staging/msm/mdp4_overlay.c b/drivers/staging/msm/mdp4_overlay.c
index de284c2..b9acf52 100644
--- a/drivers/staging/msm/mdp4_overlay.c
+++ b/drivers/staging/msm/mdp4_overlay.c
@@ -696,7 +696,7 @@ void mdp4_mixer_stage_down(struct mdp4_overlay_pipe *pipe)
 	stage = pipe->mixer_stage;
 	mixer = pipe->mixer_num;
 
-	if (pipe != ctrl->stage[mixer][stage])	/* not runing */
+	if (pipe != ctrl->stage[mixer][stage])	/* not running */
 		return;
 
 	/* MDP_LAYERMIXER_IN_CFG, shard by both mixer 0 and 1  */
diff --git a/drivers/staging/msm/mdp_ppp_dq.c b/drivers/staging/msm/mdp_ppp_dq.c
index 3dc1c0c..3a687c7 100644
--- a/drivers/staging/msm/mdp_ppp_dq.c
+++ b/drivers/staging/msm/mdp_ppp_dq.c
@@ -200,7 +200,7 @@ static void mdp_ppp_flush_dirty_djobs(void *cond)
 		msm_fb_ensure_mem_coherency_after_dma(job->info, &job->req, 1);
 
 		/* Schedule jobs for cleanup
-		 * A seperate worker thread does this */
+		 * A separate worker thread does this */
 		queue_delayed_work(mdp_ppp_djob_clnr, &job->cleaner,
 			mdp_timer_duration);
 	}
diff --git a/drivers/staging/msm/msm_fb.c b/drivers/staging/msm/msm_fb.c
index a2f29d4..e7ef836 100644
--- a/drivers/staging/msm/msm_fb.c
+++ b/drivers/staging/msm/msm_fb.c
@@ -859,7 +859,7 @@ static int msm_fb_register(struct msm_fb_data_type *mfd)
 		break;
 
 	default:
-		MSM_FB_ERR("msm_fb_init: fb %d unkown image type!\n",
+		MSM_FB_ERR("msm_fb_init: fb %d unknown image type!\n",
 			   mfd->index);
 		return ret;
 	}
@@ -1793,9 +1793,9 @@ static int msmfb_async_blit(struct fb_info *info, void __user *p)
 /*
  * NOTE: The userspace issues blit operations in a sequence, the sequence
  * start with a operation marked START and ends in an operation marked
- * END. It is guranteed by the userspace that all the blit operations
+ * END. It is guaranteed by the userspace that all the blit operations
  * between START and END are only within the regions of areas designated
- * by the START and END operations and that the userspace doesnt modify
+ * by the START and END operations and that the userspace doesn't modify
  * those areas. Hence it would be enough to perform barrier/cache operations
  * only on the START and END operations.
  */
diff --git a/drivers/staging/octeon/cvmx-cmd-queue.h b/drivers/staging/octeon/cvmx-cmd-queue.h
index 59d2214..614653b 100644
--- a/drivers/staging/octeon/cvmx-cmd-queue.h
+++ b/drivers/staging/octeon/cvmx-cmd-queue.h
@@ -214,7 +214,7 @@ static inline int __cvmx_cmd_queue_get_index(cvmx_cmd_queue_id_t queue_id)
 	/*
 	 * Warning: This code currently only works with devices that
 	 * have 256 queues or less. Devices with more than 16 queues
-	 * are layed out in memory to allow cores quick access to
+	 * are laid out in memory to allow cores quick access to
 	 * every 16th queue. This reduces cache thrashing when you are
 	 * running 16 queues per port to support lockless operation.
 	 */
diff --git a/drivers/staging/octeon/cvmx-fpa.h b/drivers/staging/octeon/cvmx-fpa.h
index 50a8c91..1f04f96 100644
--- a/drivers/staging/octeon/cvmx-fpa.h
+++ b/drivers/staging/octeon/cvmx-fpa.h
@@ -195,7 +195,7 @@ static inline void cvmx_fpa_async_alloc(uint64_t scr_addr, uint64_t pool)
 	cvmx_fpa_iobdma_data_t data;
 
 	/*
-	 * Hardware only uses 64 bit alligned locations, so convert
+	 * Hardware only uses 64 bit aligned locations, so convert
 	 * from byte address to 64-bit index
 	 */
 	data.s.scraddr = scr_addr >> 3;
diff --git a/drivers/staging/octeon/cvmx-helper-board.h b/drivers/staging/octeon/cvmx-helper-board.h
index 611a8e0..b465bec 100644
--- a/drivers/staging/octeon/cvmx-helper-board.h
+++ b/drivers/staging/octeon/cvmx-helper-board.h
@@ -81,7 +81,7 @@ extern int cvmx_helper_board_get_mii_address(int ipd_port);
  * @phy_addr:  The address of the PHY to program
  * @link_flags:
  *                  Flags to control autonegotiation.  Bit 0 is autonegotiation
- *                  enable/disable to maintain backware compatability.
+ *                  enable/disable to maintain backware compatibility.
  * @link_info: Link speed to program. If the speed is zero and autonegotiation
  *                  is enabled, all possible negotiation speeds are advertised.
  *
diff --git a/drivers/staging/octeon/cvmx-helper-util.c b/drivers/staging/octeon/cvmx-helper-util.c
index 41ef8a4..131182b 100644
--- a/drivers/staging/octeon/cvmx-helper-util.c
+++ b/drivers/staging/octeon/cvmx-helper-util.c
@@ -362,7 +362,7 @@ int __cvmx_helper_setup_gmx(int interface, int num_ports)
 }
 
 /**
- * Returns the IPD/PKO port number for a port on teh given
+ * Returns the IPD/PKO port number for a port on the given
  * interface.
  *
  * @interface: Interface to use
diff --git a/drivers/staging/octeon/cvmx-helper.c b/drivers/staging/octeon/cvmx-helper.c
index 5915066..e9c5c83 100644
--- a/drivers/staging/octeon/cvmx-helper.c
+++ b/drivers/staging/octeon/cvmx-helper.c
@@ -691,7 +691,7 @@ int __cvmx_helper_errata_fix_ipd_ptr_alignment(void)
 
 		if (!retry_cnt)
 			cvmx_dprintf("WARNING: FIX_IPD_PTR_ALIGNMENT "
-				     "get_work() timeout occured.\n");
+				     "get_work() timeout occurred.\n");
 
 		/* Free packet */
 		if (work)
diff --git a/drivers/staging/octeon/cvmx-mdio.h b/drivers/staging/octeon/cvmx-mdio.h
index f45dc49..d88ab8d 100644
--- a/drivers/staging/octeon/cvmx-mdio.h
+++ b/drivers/staging/octeon/cvmx-mdio.h
@@ -254,7 +254,7 @@ typedef union {
 #define MDIO_CLAUSE_45_READ_INC 2
 #define MDIO_CLAUSE_45_READ     3
 
-/* MMD identifiers, mostly for accessing devices withing XENPAK modules. */
+/* MMD identifiers, mostly for accessing devices within XENPAK modules. */
 #define CVMX_MMD_DEVICE_PMA_PMD      1
 #define CVMX_MMD_DEVICE_WIS          2
 #define CVMX_MMD_DEVICE_PCS          3
diff --git a/drivers/staging/octeon/cvmx-pko.h b/drivers/staging/octeon/cvmx-pko.h
index f068c19..de3412a 100644
--- a/drivers/staging/octeon/cvmx-pko.h
+++ b/drivers/staging/octeon/cvmx-pko.h
@@ -98,7 +98,7 @@ typedef enum {
 	/*
 	 * PKO doesn't do any locking. It is the responsibility of the
 	 * application to make sure that no other core is accessing
-	 * the same queue at the smae time
+	 * the same queue at the same time
 	 */
 	CVMX_PKO_LOCK_NONE = 0,
 	/*
@@ -324,7 +324,7 @@ static inline void cvmx_pko_doorbell(uint64_t port, uint64_t queue,
  * - CVMX_PKO_LOCK_NONE
  *      - PKO doesn't do any locking. It is the responsibility
  *          of the application to make sure that no other core
- *          is accessing the same queue at the smae time.
+ *          is accessing the same queue at the same time.
  * - CVMX_PKO_LOCK_ATOMIC_TAG
  *      - PKO performs an atomic tagswitch to insure exclusive
  *          access to the output queue. This will maintain
diff --git a/drivers/staging/octeon/cvmx-pow.h b/drivers/staging/octeon/cvmx-pow.h
index bf9e069..999aefe 100644
--- a/drivers/staging/octeon/cvmx-pow.h
+++ b/drivers/staging/octeon/cvmx-pow.h
@@ -1492,8 +1492,8 @@ static inline void cvmx_pow_tag_sw_full(cvmx_wqe_t *wqp, uint32_t tag,
 /**
  * Switch to a NULL tag, which ends any ordering or
  * synchronization provided by the POW for the current
- * work queue entry.  This operation completes immediatly,
- * so completetion should not be waited for.
+ * work queue entry.  This operation completes immediately,
+ * so completion should not be waited for.
  * This function does NOT wait for previous tag switches to complete,
  * so the caller must ensure that any previous tag switches have completed.
  */
@@ -1532,8 +1532,8 @@ static inline void cvmx_pow_tag_sw_null_nocheck(void)
 /**
  * Switch to a NULL tag, which ends any ordering or
  * synchronization provided by the POW for the current
- * work queue entry.  This operation completes immediatly,
- * so completetion should not be waited for.
+ * work queue entry.  This operation completes immediately,
+ * so completion should not be waited for.
  * This function waits for any pending tag switches to complete
  * before requesting the switch to NULL.
  */
@@ -1672,7 +1672,7 @@ static inline void cvmx_pow_set_priority(uint64_t core_num,
 
 /**
  * Performs a tag switch and then an immediate deschedule. This completes
- * immediatly, so completion must not be waited for.  This function does NOT
+ * immediately, so completion must not be waited for.  This function does NOT
  * update the wqe in DRAM to match arguments.
  *
  * This function does NOT wait for any prior tag switches to complete, so the
@@ -1758,7 +1758,7 @@ static inline void cvmx_pow_tag_sw_desched_nocheck(
 
 /**
  * Performs a tag switch and then an immediate deschedule. This completes
- * immediatly, so completion must not be waited for.  This function does NOT
+ * immediately, so completion must not be waited for.  This function does NOT
  * update the wqe in DRAM to match arguments.
  *
  * This function waits for any prior tag switches to complete, so the
diff --git a/drivers/staging/octeon/ethernet-util.h b/drivers/staging/octeon/ethernet-util.h
index 2346756..c745a72 100644
--- a/drivers/staging/octeon/ethernet-util.h
+++ b/drivers/staging/octeon/ethernet-util.h
@@ -55,7 +55,7 @@ static inline int INTERFACE(int ipd_port)
 		return 2;
 	else if (ipd_port < 40)	/* Interface 3 for loopback */
 		return 3;
-	else if (ipd_port == 40)	/* Non existant interface for POW0 */
+	else if (ipd_port == 40)	/* Non existent interface for POW0 */
 		return 4;
 	else
 		panic("Illegal ipd_port %d passed to INTERFACE\n", ipd_port);
diff --git a/drivers/staging/olpc_dcon/Kconfig b/drivers/staging/olpc_dcon/Kconfig
index f1082f5..b053067 100644
--- a/drivers/staging/olpc_dcon/Kconfig
+++ b/drivers/staging/olpc_dcon/Kconfig
@@ -9,7 +9,7 @@ config FB_OLPC_DCON
 
 config FB_OLPC_DCON_1
 	bool "OLPC XO-1 DCON support"
-	depends on FB_OLPC_DCON
+	depends on FB_OLPC_DCON && GPIO_CS5535
 	default y
 	---help---
 	  Enable support for the DCON in XO-1 model laptops.  The kernel
diff --git a/drivers/staging/olpc_dcon/olpc_dcon_xo_1.c b/drivers/staging/olpc_dcon/olpc_dcon_xo_1.c
index b154be7..b5d21f6 100644
--- a/drivers/staging/olpc_dcon/olpc_dcon_xo_1.c
+++ b/drivers/staging/olpc_dcon/olpc_dcon_xo_1.c
@@ -80,7 +80,7 @@ static int dcon_init_xo_1(struct dcon_priv *dcon)
 	lob &= ~(1 << DCON_IRQ);
 	outb(lob, 0x4d0);
 
-	/* Register the interupt handler */
+	/* Register the interrupt handler */
 	if (request_irq(DCON_IRQ, &dcon_interrupt, 0, "DCON", dcon)) {
 		printk(KERN_ERR "olpc-dcon: failed to request DCON's irq\n");
 		goto err_req_irq;
diff --git a/drivers/staging/olpc_dcon/olpc_dcon_xo_1_5.c b/drivers/staging/olpc_dcon/olpc_dcon_xo_1_5.c
index e213b63..7aa9b1a 100644
--- a/drivers/staging/olpc_dcon/olpc_dcon_xo_1_5.c
+++ b/drivers/staging/olpc_dcon/olpc_dcon_xo_1_5.c
@@ -7,6 +7,7 @@
  */
 
 #include <linux/acpi.h>
+#include <linux/delay.h>
 #include <linux/pci.h>
 #include <linux/gpio.h>
 #include <asm/olpc.h>
diff --git a/drivers/staging/pohmelfs/crypto.c b/drivers/staging/pohmelfs/crypto.c
index 6540864..5cca24f 100644
--- a/drivers/staging/pohmelfs/crypto.c
+++ b/drivers/staging/pohmelfs/crypto.c
@@ -745,7 +745,7 @@ static int pohmelfs_crypto_init_handshake(struct pohmelfs_sb *psb)
 
 	/*
 	 * At this point NETFS_CAPABILITIES response command
-	 * should setup superblock in a way, which is acceptible
+	 * should setup superblock in a way, which is acceptable
 	 * for both client and server, so if server refuses connection,
 	 * it will send error in transaction response.
 	 */
diff --git a/drivers/staging/quatech_usb2/quatech_usb2.c b/drivers/staging/quatech_usb2/quatech_usb2.c
index c45b09e..ca098ca 100644
--- a/drivers/staging/quatech_usb2/quatech_usb2.c
+++ b/drivers/staging/quatech_usb2/quatech_usb2.c
@@ -148,7 +148,7 @@ static struct usb_driver quausb2_usb_driver = {
  * value of the line status flags from the port
  * @shadowMSR: Last received state of the modem status register, holds
  * the value of the modem status received from the port
- * @rcv_flush: Flag indicating that a receive flush has occured on
+ * @rcv_flush: Flag indicating that a receive flush has occurred on
  * the hardware.
  * @xmit_flush: Flag indicating that a transmit flush has been processed by
  * the hardware.
@@ -156,7 +156,7 @@ static struct usb_driver quausb2_usb_driver = {
  * includes the size (excluding header) of URBs that have been submitted but
  * have not yet been sent to to the device, and bytes that have been sent out
  * of the port but not yet reported sent by the "xmit_empty" messages (which
- * indicate the number of bytes sent each time they are recieved, despite the
+ * indicate the number of bytes sent each time they are received, despite the
  * misleading name).
  * - Starts at zero when port is initialised.
  * - is incremented by the size of the data to be written (no headers)
@@ -649,7 +649,7 @@ static void qt2_close(struct usb_serial_port *port)
 	/* although the USB side is now empty, the UART itself may
 	 * still be pushing characters out over the line, so we have to
 	 * wait testing the actual line status until the lines change
-	 * indicating that the data is done transfering. */
+	 * indicating that the data is done transferring. */
 	/* FIXME: slow this polling down so it doesn't run the USB bus flat out
 	 * if it actually has to spend any time in this loop (which it normally
 	 * doesn't because the buffer is nearly empty) */
@@ -726,7 +726,7 @@ static int qt2_write(struct tty_struct *tty, struct usb_serial_port *port,
 		return 0;
 	} else if (port_extra->tx_pending_bytes >= QT2_FIFO_DEPTH) {
 		/* buffer is full (==). > should not occur, but would indicate
-		 * that an overflow had occured */
+		 * that an overflow had occurred */
 		dbg("%s(): port transmit buffer is full!", __func__);
 		/* schedule_work(&port->work); commented in vendor driver */
 		return 0;
@@ -823,7 +823,7 @@ static int qt2_write_room(struct tty_struct *tty)
 	 * reduce the free space count by the size of the dispatched write.
 	 * When a "transmit empty" message comes back up the USB read stream,
 	 * we decrement the count by the number of bytes reported sent, thus
-	 * keeping track of the difference between sent and recieved bytes.
+	 * keeping track of the difference between sent and received bytes.
 	 */
 
 	room = (QT2_FIFO_DEPTH - port_extra->tx_pending_bytes);
@@ -1795,7 +1795,7 @@ static void qt2_process_rx_char(struct usb_serial_port *port,
 	}
 }
 
-/** @brief Retreive the value of a register from the device
+/** @brief Retrieve the value of a register from the device
  *
  * Issues a GET_REGISTER vendor-spcific request over the USB control
  * pipe to obtain a value back from a specific register on a specific
diff --git a/drivers/staging/rt2860/chip/rtmp_phy.h b/drivers/staging/rt2860/chip/rtmp_phy.h
index 98454df..a52221f 100644
--- a/drivers/staging/rt2860/chip/rtmp_phy.h
+++ b/drivers/staging/rt2860/chip/rtmp_phy.h
@@ -467,7 +467,7 @@
 			DBGPRINT_ERR("BBP write R%d=0x%x fail. BusyCnt= %d.bPCIclkOff = %d. \n", _I, BbpCsr.word, BusyCnt, (_A)->bPCIclkOff);	\
 		}																	\
 	} else {							\
-		DBGPRINT_ERR("****** BBP_Write_Latch Buffer exceeds max boundry ****** \n");	\
+		DBGPRINT_ERR("****** BBP_Write_Latch Buffer exceeds max boundary ****** \n");	\
 	}																		\
 }
 #endif /* RTMP_MAC_PCI // */
diff --git a/drivers/staging/rt2860/common/ba_action.c b/drivers/staging/rt2860/common/ba_action.c
index 62f6f6b..133bc1b 100644
--- a/drivers/staging/rt2860/common/ba_action.c
+++ b/drivers/staging/rt2860/common/ba_action.c
@@ -28,7 +28,7 @@
 #include "../rt_config.h"
 #include <linux/kernel.h>
 
-#define BA_ORI_INIT_SEQ		(pEntry->TxSeq[TID])	/*1                        // inital sequence number of BA session */
+#define BA_ORI_INIT_SEQ		(pEntry->TxSeq[TID])	/*1                        // initial sequence number of BA session */
 
 #define ORI_SESSION_MAX_RETRY	8
 #define ORI_BA_SESSION_TIMEOUT	(2000)	/* ms */
@@ -1487,7 +1487,7 @@ static void ba_enqueue_reordering_packet(struct rt_rtmp_adapter *pAd,
 
 		/*
 		 * flush all pending reordering mpdus
-		 * and receving mpdu to upper layer
+		 * and receiving mpdu to upper layer
 		 * make tcp/ip to take care reordering mechanism
 		 */
 		/*ba_refresh_reordering_mpdus(pAd, pBAEntry); */
diff --git a/drivers/staging/rt2860/common/cmm_aes.c b/drivers/staging/rt2860/common/cmm_aes.c
index a99879b..d70d229 100644
--- a/drivers/staging/rt2860/common/cmm_aes.c
+++ b/drivers/staging/rt2860/common/cmm_aes.c
@@ -858,7 +858,7 @@ static uint32 KT1[256];
 static uint32 KT2[256];
 static uint32 KT3[256];
 
-/* platform-independant	32-bit integer manipulation	macros */
+/* platform-independent	32-bit integer manipulation	macros */
 
 #define	GET_UINT32(n,b,i)						\
 {												\
diff --git a/drivers/staging/rt2860/common/cmm_cfg.c b/drivers/staging/rt2860/common/cmm_cfg.c
index 24f4393..727f799 100644
--- a/drivers/staging/rt2860/common/cmm_cfg.c
+++ b/drivers/staging/rt2860/common/cmm_cfg.c
@@ -223,7 +223,7 @@ int RT_CfgSetWepKey(struct rt_rtmp_adapter *pAd,
         pAdapter	Pointer to our adapter
         keyString	WPA pre-shared key string
         pHashStr	String used for password hash function
-        hashStrLen	Lenght of the hash string
+        hashStrLen	Length of the hash string
         pPMKBuf		Output buffer of WPAPSK key
 
     Return:
diff --git a/drivers/staging/rt2860/common/cmm_data.c b/drivers/staging/rt2860/common/cmm_data.c
index f6c193c..33799e1 100644
--- a/drivers/staging/rt2860/common/cmm_data.c
+++ b/drivers/staging/rt2860/common/cmm_data.c
@@ -337,7 +337,7 @@ int MlmeHardTransmitMgmtRing(struct rt_rtmp_adapter *pAd,
 
 	/* */
 	/* In WMM-UAPSD, mlme frame should be set psm as power saving but probe request frame */
-	/* Data-Null packets alse pass through MMRequest in RT2860, however, we hope control the psm bit to pass APSD */
+	/* Data-Null packets also pass through MMRequest in RT2860, however, we hope control the psm bit to pass APSD */
 /*      if ((pHeader_802_11->FC.Type != BTYPE_DATA) && (pHeader_802_11->FC.Type != BTYPE_CNTL)) */
 	{
 		if ((pHeader_802_11->FC.SubType == SUBTYPE_ACTION) ||
@@ -1933,7 +1933,7 @@ BOOLEAN RTMPCheckEtherType(struct rt_rtmp_adapter *pAd, void *pPacket)
 
 	if (TypeLen <= 1500) {	/* 802.3, 802.3 LLC */
 		/*
-		   DestMAC(6) + SrcMAC(6) + Lenght(2) +
+		   DestMAC(6) + SrcMAC(6) + Length(2) +
 		   DSAP(1) + SSAP(1) + Control(1) +
 		   if the DSAP = 0xAA, SSAP=0xAA, Contorl = 0x03, it has a 5-bytes SNAP header.
 		   => + SNAP (5, OriginationID(3) + etherType(2))
diff --git a/drivers/staging/rt2860/common/cmm_data_pci.c b/drivers/staging/rt2860/common/cmm_data_pci.c
index 7af59ff..bef0bbd 100644
--- a/drivers/staging/rt2860/common/cmm_data_pci.c
+++ b/drivers/staging/rt2860/common/cmm_data_pci.c
@@ -438,13 +438,13 @@ int RTMPCheckRxError(struct rt_rtmp_adapter *pAd,
 	/* Add Rx size to channel load counter, we should ignore error counts */
 	pAd->StaCfg.CLBusyBytes += (pRxD->SDL0 + 14);
 
-	/* Drop ToDs promiscous frame, it is opened due to CCX 2 channel load statistics */
+	/* Drop ToDs promiscuous frame, it is opened due to CCX 2 channel load statistics */
 	if (pHeader != NULL) {
 		if (pHeader->FC.ToDs) {
 			return (NDIS_STATUS_FAILURE);
 		}
 	}
-	/* Drop not U2M frames, cant's drop here because we will drop beacon in this case */
+	/* Drop not U2M frames, can't's drop here because we will drop beacon in this case */
 	/* I am kind of doubting the U2M bit operation */
 	/* if (pRxD->U2M == 0) */
 	/*      return(NDIS_STATUS_FAILURE); */
@@ -939,7 +939,7 @@ int MlmeHardTransmitTxRing(struct rt_rtmp_adapter *pAd,
 	/* */
 	/* */
 	/* In WMM-UAPSD, mlme frame should be set psm as power saving but probe request frame */
-	/* Data-Null packets alse pass through MMRequest in RT2860, however, we hope control the psm bit to pass APSD */
+	/* Data-Null packets also pass through MMRequest in RT2860, however, we hope control the psm bit to pass APSD */
 	if (pHeader_802_11->FC.Type != BTYPE_DATA) {
 		if ((pHeader_802_11->FC.SubType == SUBTYPE_PROBE_REQ)
 		    || !(pAd->CommonCfg.bAPSDCapable
diff --git a/drivers/staging/rt2860/common/cmm_data_usb.c b/drivers/staging/rt2860/common/cmm_data_usb.c
index 7c56c2f..5637857 100644
--- a/drivers/staging/rt2860/common/cmm_data_usb.c
+++ b/drivers/staging/rt2860/common/cmm_data_usb.c
@@ -702,7 +702,7 @@ Arguments:
 	*pRxPending			pending received packet flag
 
 Return Value:
-    the recieved packet
+    the received packet
 
 Note:
 ========================================================================
@@ -850,7 +850,7 @@ int RTMPCheckRxError(struct rt_rtmp_adapter *pAd,
 	/* Add Rx size to channel load counter, we should ignore error counts */
 	pAd->StaCfg.CLBusyBytes += (pRxWI->MPDUtotalByteCount + 14);
 
-	/* Drop ToDs promiscous frame, it is opened due to CCX 2 channel load statistics */
+	/* Drop ToDs promiscuous frame, it is opened due to CCX 2 channel load statistics */
 	if (pHeader->FC.ToDs) {
 		DBGPRINT_RAW(RT_DEBUG_ERROR, ("Err;FC.ToDs\n"));
 		return NDIS_STATUS_FAILURE;
@@ -860,7 +860,7 @@ int RTMPCheckRxError(struct rt_rtmp_adapter *pAd,
 		DBGPRINT_RAW(RT_DEBUG_ERROR, ("received packet too long\n"));
 		return NDIS_STATUS_FAILURE;
 	}
-	/* Drop not U2M frames, cant's drop here because we will drop beacon in this case */
+	/* Drop not U2M frames, can't's drop here because we will drop beacon in this case */
 	/* I am kind of doubting the U2M bit operation */
 	/* if (pRxD->U2M == 0) */
 	/*      return(NDIS_STATUS_FAILURE); */
diff --git a/drivers/staging/rt2860/common/cmm_mac_pci.c b/drivers/staging/rt2860/common/cmm_mac_pci.c
index 21eed25..d06f0a6 100644
--- a/drivers/staging/rt2860/common/cmm_mac_pci.c
+++ b/drivers/staging/rt2860/common/cmm_mac_pci.c
@@ -1446,7 +1446,7 @@ BOOLEAN RT28xxPciAsicRadioOff(struct rt_rtmp_adapter *pAd,
 	   pAd->CheckDmaBusyCount = 0;
 	   }
 	 */
-/*KH Debug:My original codes have the follwoing codes, but currecnt codes do not have it. */
+/*KH Debug:My original codes have the following codes, but currecnt codes do not have it. */
 /* Disable for stability. If PCIE Link Control is modified for advance power save, re-covery this code segment. */
 	RTMP_IO_WRITE32(pAd, PBF_SYS_CTRL, 0x1280);
 /*OPSTATUS_SET_FLAG(pAd, fOP_STATUS_CLKSELECT_40MHZ); */
diff --git a/drivers/staging/rt2860/common/cmm_sanity.c b/drivers/staging/rt2860/common/cmm_sanity.c
index 6b003c9..3bfb4ad 100644
--- a/drivers/staging/rt2860/common/cmm_sanity.c
+++ b/drivers/staging/rt2860/common/cmm_sanity.c
@@ -67,7 +67,7 @@ BOOLEAN MlmeAddBAReqSanity(struct rt_rtmp_adapter *pAd,
 
 	if ((MsgLen != sizeof(struct rt_mlme_addba_req))) {
 		DBGPRINT(RT_DEBUG_TRACE,
-			 ("MlmeAddBAReqSanity fail - message lenght not correct.\n"));
+			 ("MlmeAddBAReqSanity fail - message length not correct.\n"));
 		return FALSE;
 	}
 
@@ -104,7 +104,7 @@ BOOLEAN MlmeDelBAReqSanity(struct rt_rtmp_adapter *pAd, void * Msg, unsigned lon
 
 	if ((MsgLen != sizeof(struct rt_mlme_delba_req))) {
 		DBGPRINT(RT_DEBUG_ERROR,
-			 ("MlmeDelBAReqSanity fail - message lenght not correct.\n"));
+			 ("MlmeDelBAReqSanity fail - message length not correct.\n"));
 		return FALSE;
 	}
 
diff --git a/drivers/staging/rt2860/common/cmm_sync.c b/drivers/staging/rt2860/common/cmm_sync.c
index f84194d..aefe1b7 100644
--- a/drivers/staging/rt2860/common/cmm_sync.c
+++ b/drivers/staging/rt2860/common/cmm_sync.c
@@ -694,7 +694,7 @@ void ScanNextChannel(struct rt_rtmp_adapter *pAd)
 			MiniportMMRequest(pAd, 0, pOutBuffer, FrameLen);
 			MlmeFreeMemory(pAd, pOutBuffer);
 		}
-		/* For SCAN_CISCO_PASSIVE, do nothing and silently wait for beacon or other probe reponse */
+		/* For SCAN_CISCO_PASSIVE, do nothing and silently wait for beacon or other probe response */
 
 		pAd->Mlme.SyncMachine.CurrState = SCAN_LISTEN;
 	}
diff --git a/drivers/staging/rt2860/common/cmm_wpa.c b/drivers/staging/rt2860/common/cmm_wpa.c
index 0040f45..616ebec 100644
--- a/drivers/staging/rt2860/common/cmm_wpa.c
+++ b/drivers/staging/rt2860/common/cmm_wpa.c
@@ -1222,7 +1222,7 @@ void PeerGroupMsg2Action(struct rt_rtmp_adapter *pAd,
 
 	Note:
 		All these constants are defined in wpa.h
-		For supplicant, there is only EAPOL Key message avaliable
+		For supplicant, there is only EAPOL Key message available
 
 	========================================================================
 */
@@ -1267,7 +1267,7 @@ BOOLEAN WpaMsgTypeSubst(u8 EAPType, int * MsgType)
 		int		prefix_len	-	the length of the label
 		u8	*data		-	a specific data with variable length
 		int		data_len	-	the length of a specific data
-		int		len			-	the output lenght
+		int		len			-	the output length
 
 	Return Value:
 		u8	*output		-	the calculated result
diff --git a/drivers/staging/rt2860/common/mlme.c b/drivers/staging/rt2860/common/mlme.c
index d9c3fd5..e48eac0 100644
--- a/drivers/staging/rt2860/common/mlme.c
+++ b/drivers/staging/rt2860/common/mlme.c
@@ -632,7 +632,7 @@ void MlmeHalt(struct rt_rtmp_adapter *pAd)
 			pChipOps->AsicHaltAction(pAd);
 	}
 
-	RTMPusecDelay(5000);	/*  5 msec to gurantee Ant Diversity timer canceled */
+	RTMPusecDelay(5000);	/*  5 msec to guarantee Ant Diversity timer canceled */
 
 	MlmeQueueDestroy(&pAd->Mlme.Queue);
 	NdisFreeSpinLock(&pAd->Mlme.TaskLock);
@@ -1107,14 +1107,14 @@ void MlmeSelectTxRateTable(struct rt_rtmp_adapter *pAd,
 					*pInitTxRateIdx =
 					    RateSwitchTable11N1S[1];
 					DBGPRINT_RAW(RT_DEBUG_ERROR,
-						     ("DRS: unkown mode,default use 11N 1S AP \n"));
+						     ("DRS: unknown mode,default use 11N 1S AP \n"));
 				} else {
 					*ppTable = RateSwitchTable11N2S;
 					*pTableSize = RateSwitchTable11N2S[0];
 					*pInitTxRateIdx =
 					    RateSwitchTable11N2S[1];
 					DBGPRINT_RAW(RT_DEBUG_ERROR,
-						     ("DRS: unkown mode,default use 11N 2S AP \n"));
+						     ("DRS: unknown mode,default use 11N 2S AP \n"));
 				}
 			} else {
 				if (pAd->CommonCfg.TxStream == 1) {
@@ -1123,7 +1123,7 @@ void MlmeSelectTxRateTable(struct rt_rtmp_adapter *pAd,
 					*pInitTxRateIdx =
 					    RateSwitchTable11N1S[1];
 					DBGPRINT_RAW(RT_DEBUG_ERROR,
-						     ("DRS: unkown mode,default use 11N 1S AP \n"));
+						     ("DRS: unknown mode,default use 11N 1S AP \n"));
 				} else {
 					*ppTable = RateSwitchTable11N2SForABand;
 					*pTableSize =
@@ -1131,11 +1131,11 @@ void MlmeSelectTxRateTable(struct rt_rtmp_adapter *pAd,
 					*pInitTxRateIdx =
 					    RateSwitchTable11N2SForABand[1];
 					DBGPRINT_RAW(RT_DEBUG_ERROR,
-						     ("DRS: unkown mode,default use 11N 2S AP \n"));
+						     ("DRS: unknown mode,default use 11N 2S AP \n"));
 				}
 			}
 			DBGPRINT_RAW(RT_DEBUG_ERROR,
-				     ("DRS: unkown mode (SupRateLen=%d, ExtRateLen=%d, MCSSet[0]=0x%x, MCSSet[1]=0x%x)\n",
+				     ("DRS: unknown mode (SupRateLen=%d, ExtRateLen=%d, MCSSet[0]=0x%x, MCSSet[1]=0x%x)\n",
 				      pAd->StaActive.SupRateLen,
 				      pAd->StaActive.ExtRateLen,
 				      pAd->StaActive.SupportedPhyInfo.MCSSet[0],
@@ -1368,7 +1368,7 @@ void STAMlmePeriodicExec(struct rt_rtmp_adapter *pAd)
 					if ((pAd->StaCfg.LastScanTime +
 					     10 * OS_HZ) < pAd->Mlme.Now32) {
 						DBGPRINT(RT_DEBUG_TRACE,
-							 ("MMCHK - Roaming, No eligable entry, try new scan!\n"));
+							 ("MMCHK - Roaming, No eligible entry, try new scan!\n"));
 						pAd->StaCfg.ScanCnt = 2;
 						pAd->StaCfg.LastScanTime =
 						    pAd->Mlme.Now32;
@@ -2828,7 +2828,7 @@ void UpdateBasicRateBitmap(struct rt_rtmp_adapter *pAdapter)
 
 /* IRQL = PASSIVE_LEVEL */
 /* IRQL = DISPATCH_LEVEL */
-/* bLinkUp is to identify the inital link speed. */
+/* bLinkUp is to identify the initial link speed. */
 /* TRUE indicates the rate update at linkup, we should not try to set the rate at 54Mbps. */
 void MlmeUpdateTxRates(struct rt_rtmp_adapter *pAd, IN BOOLEAN bLinkUp, u8 apidx)
 {
diff --git a/drivers/staging/rt2860/common/rtmp_init.c b/drivers/staging/rt2860/common/rtmp_init.c
index d359a14..5fa193e 100644
--- a/drivers/staging/rt2860/common/rtmp_init.c
+++ b/drivers/staging/rt2860/common/rtmp_init.c
@@ -2037,7 +2037,7 @@ void NICUpdateFifoStaCounters(struct rt_rtmp_adapter *pAd)
 
 			pEntry->FIFOCount = 0;
 			pEntry->OneSecTxNoRetryOkCount++;
-			/* update NoDataIdleCount when sucessful send packet to STA. */
+			/* update NoDataIdleCount when successful send packet to STA. */
 			pEntry->NoDataIdleCount = 0;
 			pEntry->ContinueTxFailCnt = 0;
 		}
@@ -2516,7 +2516,7 @@ void UserCfgInit(struct rt_rtmp_adapter *pAd)
 	/*pAd->TurnAggrBulkInCount = 0; */
 	pAd->bUsbTxBulkAggre = 0;
 
-	/* init as unsed value to ensure driver will set to MCU once. */
+	/* init as unused value to ensure driver will set to MCU once. */
 	pAd->LedIndicatorStrength = 0xFF;
 
 	pAd->CommonCfg.MaxPktOneTxBulk = 2;
@@ -3076,11 +3076,11 @@ void RTMPSetLED(struct rt_rtmp_adapter *pAd, u8 Status)
 	========================================================================
 
 	Routine Description:
-		Set LED Signal Stregth
+		Set LED Signal Strength
 
 	Arguments:
 		pAd						Pointer to our adapter
-		Dbm						Signal Stregth
+		Dbm						Signal Strength
 
 	Return Value:
 		None
@@ -3090,7 +3090,7 @@ void RTMPSetLED(struct rt_rtmp_adapter *pAd, u8 Status)
 	Note:
 		Can be run on any IRQL level.
 
-		According to Microsoft Zero Config Wireless Signal Stregth definition as belows.
+		According to Microsoft Zero Config Wireless Signal Strength definition as belows.
 		<= -90  No Signal
 		<= -81  Very Low
 		<= -71  Low
@@ -3118,7 +3118,7 @@ void RTMPSetSignalLED(struct rt_rtmp_adapter *pAd, IN NDIS_802_11_RSSI Dbm)
 			nLed = 31;
 
 		/* */
-		/* Update Signal Stregth to firmware if changed. */
+		/* Update Signal Strength to firmware if changed. */
 		/* */
 		if (pAd->LedIndicatorStrength != nLed) {
 			AsicSendCommandToMcu(pAd, 0x51, 0xff, nLed,
@@ -3166,7 +3166,7 @@ void RTMPEnableRxTx(struct rt_rtmp_adapter *pAd)
 		if (pAd->CommonCfg.PSPXlink)
 			rx_filter_flag = PSPXLINK;
 		else
-			rx_filter_flag = STANORMAL;	/* Staion not drop control frame will fail WiFi Certification. */
+			rx_filter_flag = STANORMAL;	/* Station not drop control frame will fail WiFi Certification. */
 		RTMP_IO_WRITE32(pAd, RX_FILTR_CFG, rx_filter_flag);
 	}
 
diff --git a/drivers/staging/rt2860/common/spectrum.c b/drivers/staging/rt2860/common/spectrum.c
index c0d2f42..ceb622d 100644
--- a/drivers/staging/rt2860/common/spectrum.c
+++ b/drivers/staging/rt2860/common/spectrum.c
@@ -1058,8 +1058,8 @@ static void InsertMeasureReqIE(struct rt_rtmp_adapter *pAd,
 		3. Measure Token.
 		4. Measure Request Mode.
 		5. Measure Request Type.
-		6. Length of Report Infomation
-		7. Pointer of Report Infomation Buffer.
+		6. Length of Report Information
+		7. Pointer of Report Information Buffer.
 
 	Return	: None.
 	==========================================================================
@@ -1400,7 +1400,7 @@ static void StartDFSProcedure(struct rt_rtmp_adapter *pAd,
 	Parametrs:
 		1. MLME message containing the received frame
 		2. message length.
-		3. Channel switch announcement infomation buffer.
+		3. Channel switch announcement information buffer.
 
 	Return	: None.
 	==========================================================================
@@ -1465,7 +1465,7 @@ static BOOLEAN PeerChSwAnnSanity(struct rt_rtmp_adapter *pAd,
 	Parametrs:
 		1. MLME message containing the received frame
 		2. message length.
-		3. Measurement request infomation buffer.
+		3. Measurement request information buffer.
 
 	Return	: None.
 	==========================================================================
@@ -1538,8 +1538,8 @@ static BOOLEAN PeerMeasureReqSanity(struct rt_rtmp_adapter *pAd,
 	Parametrs:
 		1. MLME message containing the received frame
 		2. message length.
-		3. Measurement report infomation buffer.
-		4. basic report infomation buffer.
+		3. Measurement report information buffer.
+		4. basic report information buffer.
 
 	Return	: None.
 	==========================================================================
diff --git a/drivers/staging/rt2860/mlme.h b/drivers/staging/rt2860/mlme.h
index cd1ee3d..a285851 100644
--- a/drivers/staging/rt2860/mlme.h
+++ b/drivers/staging/rt2860/mlme.h
@@ -374,7 +374,7 @@ struct PACKED rt_sec_cha_offset_ie {
 struct rt_ht_phy_info {
 	BOOLEAN bHtEnable;	/* If we should use ht rate. */
 	BOOLEAN bPreNHt;	/* If we should use ht rate. */
-	/*Substract from HT Capability IE */
+	/*Subtract from HT Capability IE */
 	u8 MCSSet[16];
 };
 
@@ -392,7 +392,7 @@ struct rt_ht_capability {
 	u16 AmsduSize:1;	/* Max receiving A-MSDU size */
 	u16 rsv:5;
 
-	/*Substract from Addiont HT INFO IE */
+	/*Subtract from Addiont HT INFO IE */
 	u8 MaxRAmpduFactor:2;
 	u8 MpduDensity:3;
 	u8 ExtChanOffset:2;	/* Please note the difference with following     u8   NewExtChannelOffset; from 802.11n */
@@ -410,7 +410,7 @@ struct rt_ht_capability {
 	u8 BSSCoexist2040;
 };
 
-/*   field in Addtional HT Information IE . */
+/*   field in Additional HT Information IE . */
 struct PACKED rt_add_htinfo {
 	u8 ExtChanOffset:2;
 	u8 RecomWidth:1;
@@ -857,7 +857,7 @@ struct rt_state_machine {
 };
 
 /* MLME AUX data structure that holds temporarliy settings during a connection attempt. */
-/* Once this attemp succeeds, all settings will be copy to pAd->StaActive. */
+/* Once this attempt succeeds, all settings will be copy to pAd->StaActive. */
 /* A connection attempt (user set OID, roaming, CCX fast roaming,..) consists of */
 /* several steps (JOIN, AUTH, ASSOC or REASSOC) and may fail at any step. We purposely */
 /* separate this under-trial settings away from pAd->StaActive so that once */
diff --git a/drivers/staging/rt2860/rt_linux.c b/drivers/staging/rt2860/rt_linux.c
index e5b0427..1583347 100644
--- a/drivers/staging/rt2860/rt_linux.c
+++ b/drivers/staging/rt2860/rt_linux.c
@@ -283,7 +283,7 @@ BOOLEAN OS_Need_Clone_Packet(void)
 	Arguments:
 		pAd 	Pointer to our adapter
 		pInsAMSDUHdr	EWC A-MSDU format has extra 14-bytes header. if TRUE, insert this 14-byte hdr in front of MSDU.
-		*pSrcTotalLen			return total packet length. This lenght is calculated with 802.3 format packet.
+		*pSrcTotalLen			return total packet length. This length is calculated with 802.3 format packet.
 
 	Return Value:
 		NDIS_STATUS_SUCCESS
diff --git a/drivers/staging/rt2860/rt_pci_rbus.c b/drivers/staging/rt2860/rt_pci_rbus.c
index e5fb67c..f80ab4e 100644
--- a/drivers/staging/rt2860/rt_pci_rbus.c
+++ b/drivers/staging/rt2860/rt_pci_rbus.c
@@ -619,7 +619,7 @@ IRQ_HANDLE_TYPE rt2860_interrupt(int irq, void *dev_instance)
 	   Or kernel will panic after ifconfig ra0 down sometimes */
 
 	/* */
-	/* Inital the Interrupt source. */
+	/* Initial the Interrupt source. */
 	/* */
 	IntSource.word = 0x00000000L;
 /*      McuIntSource.word = 0x00000000L; */
diff --git a/drivers/staging/rt2860/rtmp.h b/drivers/staging/rt2860/rtmp.h
index d16b06a..3c31340 100644
--- a/drivers/staging/rt2860/rtmp.h
+++ b/drivers/staging/rt2860/rtmp.h
@@ -756,7 +756,7 @@ struct rt_tkip_key_info {
 /* */
 struct rt_private {
 	u32 SystemResetCnt;	/* System reset counter */
-	u32 TxRingFullCnt;	/* Tx ring full occurrance number */
+	u32 TxRingFullCnt;	/* Tx ring full occurrence number */
 	u32 PhyRxErrCnt;	/* PHY Rx error count, for debug purpose, might move to global counter */
 	/* Variables for WEP encryption / decryption in rtmp_wep.c */
 	u32 FCSCRC32;
@@ -925,7 +925,7 @@ struct rt_mlme {
   **************************************************************************/
 struct reordering_mpdu {
 	struct reordering_mpdu *next;
-	void *pPacket;	/* coverted to 802.3 frame */
+	void *pPacket;	/* converted to 802.3 frame */
 	int Sequence;		/* sequence number of MPDU */
 	BOOLEAN bAMSDU;
 };
diff --git a/drivers/staging/rt2860/sta_ioctl.c b/drivers/staging/rt2860/sta_ioctl.c
index 5717e12..49b1013 100644
--- a/drivers/staging/rt2860/sta_ioctl.c
+++ b/drivers/staging/rt2860/sta_ioctl.c
@@ -2460,7 +2460,7 @@ int rt28xx_sta_ioctl(IN struct net_device *net_dev,
 		}
 	}
 
-	{			/* determine this ioctl command is comming from which interface. */
+	{			/* determine this ioctl command is coming from which interface. */
 		pObj->ioctl_if_type = INT_MAIN;
 		pObj->ioctl_if = MAIN_MBSSID;
 	}
diff --git a/drivers/staging/rt2870/common/rtusb_bulk.c b/drivers/staging/rt2870/common/rtusb_bulk.c
index d2746f8..679b802 100644
--- a/drivers/staging/rt2870/common/rtusb_bulk.c
+++ b/drivers/staging/rt2870/common/rtusb_bulk.c
@@ -298,7 +298,7 @@ void RTUSBBulkOutDataPacket(struct rt_rtmp_adapter *pAd,
 				/*|| ( (ThisBulkSize != 0)  && (pTxWI->AMPDU == 0)) */
 				) {
 				/* For USB 1.1 or peer which didn't support AMPDU, limit the BulkOut size. */
-				/* For performence in b/g mode, now just check for USB 1.1 and didn't care about the APMDU or not! 2008/06/04. */
+				/* For performance in b/g mode, now just check for USB 1.1 and didn't care about the APMDU or not! 2008/06/04. */
 				pHTTXContext->ENextBulkOutPosition =
 				    TmpBulkEndPos;
 				break;
@@ -311,7 +311,7 @@ void RTUSBBulkOutDataPacket(struct rt_rtmp_adapter *pAd,
 				    TmpBulkEndPos;
 				break;
 			} else if (((pAd->BulkOutMaxPacketSize < 512) && ((ThisBulkSize & 0xfffff800) != 0)) /*|| ( (ThisBulkSize != 0)  && (pTxWI->AMPDU == 0)) */) {	/* For USB 1.1 or peer which didn't support AMPDU, limit the BulkOut size. */
-				/* For performence in b/g mode, now just check for USB 1.1 and didn't care about the APMDU or not! 2008/06/04. */
+				/* For performance in b/g mode, now just check for USB 1.1 and didn't care about the APMDU or not! 2008/06/04. */
 				pHTTXContext->ENextBulkOutPosition =
 				    TmpBulkEndPos;
 				break;
@@ -1016,7 +1016,7 @@ void RTUSBKickBulkOut(struct rt_rtmp_adapter *pAd)
 				RTUSBBulkOutNullFrame(pAd);
 			}
 		}
-		/* 8. No data avaliable */
+		/* 8. No data available */
 		else
 			;
 	}
diff --git a/drivers/staging/rt2870/common/rtusb_data.c b/drivers/staging/rt2870/common/rtusb_data.c
index 6936886..5b72bcd 100644
--- a/drivers/staging/rt2870/common/rtusb_data.c
+++ b/drivers/staging/rt2870/common/rtusb_data.c
@@ -71,7 +71,7 @@ void REPORT_AMSDU_FRAMES_TO_LLC(struct rt_rtmp_adapter *pAd,
 
 	Routine	Description:
 		This subroutine will scan through releative ring descriptor to find
-		out avaliable free ring descriptor and compare with request size.
+		out available free ring descriptor and compare with request size.
 
 	Arguments:
 		pAd	Pointer	to our adapter
diff --git a/drivers/staging/rtl8187se/Kconfig b/drivers/staging/rtl8187se/Kconfig
index 1b3103f..3162aab 100644
--- a/drivers/staging/rtl8187se/Kconfig
+++ b/drivers/staging/rtl8187se/Kconfig
@@ -1,6 +1,7 @@
 config R8187SE
 	tristate "RealTek RTL8187SE Wireless LAN NIC driver"
 	depends on PCI && WLAN
+	depends on m
 	select WIRELESS_EXT
 	select WEXT_PRIV
 	select EEPROM_93CX6
diff --git a/drivers/staging/rtl8187se/ieee80211/ieee80211.h b/drivers/staging/rtl8187se/ieee80211/ieee80211.h
index dc608c7..16aa6a8 100644
--- a/drivers/staging/rtl8187se/ieee80211/ieee80211.h
+++ b/drivers/staging/rtl8187se/ieee80211/ieee80211.h
@@ -1099,7 +1099,7 @@ struct ieee80211_device {
 	 * not set. As some cards may have different HW queues that
 	 * one might want to use for data and management frames
 	 * the option to have two callbacks might be useful.
-	 * This fucntion can't sleep.
+	 * This function can't sleep.
 	 */
 	int (*softmac_hard_start_xmit)(struct sk_buff *skb,
 			       struct net_device *dev);
@@ -1138,9 +1138,9 @@ struct ieee80211_device {
 	 * it is called in a work_queue when swithcing to ad-hoc mode
 	 * or in behalf of iwlist scan when the card is associated
 	 * and root user ask for a scan.
-	 * the fucntion stop_scan should stop both the syncro and
+	 * the function stop_scan should stop both the syncro and
 	 * background scanning and can sleep.
-	 * The fucntion start_scan should initiate the background
+	 * The function start_scan should initiate the background
 	 * scanning and can't sleep.
 	 */
 	void (*scan_syncro)(struct net_device *dev);
diff --git a/drivers/staging/rtl8187se/ieee80211/ieee80211_softmac.c b/drivers/staging/rtl8187se/ieee80211/ieee80211_softmac.c
index 771e019..736a140 100644
--- a/drivers/staging/rtl8187se/ieee80211/ieee80211_softmac.c
+++ b/drivers/staging/rtl8187se/ieee80211/ieee80211_softmac.c
@@ -1954,7 +1954,7 @@ associate_complete:
 
 
 
-/* following are for a simplier TX queue management.
+/* following are for a simpler TX queue management.
  * Instead of using netif_[stop/wake]_queue the driver
  * will uses these two function (plus a reset one), that
  * will internally uses the kernel netif_* and takes
diff --git a/drivers/staging/rtl8187se/r8180_core.c b/drivers/staging/rtl8187se/r8180_core.c
index 70ab008..2155a77 100644
--- a/drivers/staging/rtl8187se/r8180_core.c
+++ b/drivers/staging/rtl8187se/r8180_core.c
@@ -1591,7 +1591,7 @@ void rtl8180_rx(struct net_device *dev)
 		priv->RSSI = RSSI;
 		/* SQ translation formula is provided by SD3 DZ. 2006.06.27 */
 		if (quality >= 127)
-			quality = 1; /*0; */ /* 0 will cause epc to show signal zero , walk aroud now; */
+			quality = 1; /*0; */ /* 0 will cause epc to show signal zero , walk around now; */
 		else if (quality < 27)
 			quality = 100;
 		else
@@ -3883,7 +3883,7 @@ void rtl8180_tx_isr(struct net_device *dev, int pri, short error)
 	 * If the packet previous of the nic pointer has been
 	 * processed this doesn't matter: it will be checked
 	 * here at the next round. Anyway if no more packet are
-	 * TXed no memory leak occour at all.
+	 * TXed no memory leak occur at all.
 	 */
 
 	switch (pri) {
diff --git a/drivers/staging/rtl8187se/r8180_dm.c b/drivers/staging/rtl8187se/r8180_dm.c
index fc49078..261085d 100644
--- a/drivers/staging/rtl8187se/r8180_dm.c
+++ b/drivers/staging/rtl8187se/r8180_dm.c
@@ -123,7 +123,7 @@ DoTxHighPower(
 //
 //	Description:
 //		Callback function of UpdateTxPowerWorkItem.
-//		Because of some event happend, e.g. CCX TPC, High Power Mechanism,
+//		Because of some event happened, e.g. CCX TPC, High Power Mechanism,
 //		We update Tx power of current channel again.
 //
 void rtl8180_tx_pw_wq (struct work_struct *work)
@@ -984,7 +984,7 @@ StaRateAdaptive87SE(
 		{
 			priv->TryupingCount = 0;
 			//
-			// When transfering from CCK to OFDM, DIG is an important issue.
+			// When transferring from CCK to OFDM, DIG is an important issue.
 			//
 			if(priv->CurrentOperaRate == 22)
 				bUpdateInitialGain = true;
diff --git a/drivers/staging/rtl8187se/r8180_rtl8225z2.c b/drivers/staging/rtl8187se/r8180_rtl8225z2.c
index 2a2afd5..3f09f76 100644
--- a/drivers/staging/rtl8187se/r8180_rtl8225z2.c
+++ b/drivers/staging/rtl8187se/r8180_rtl8225z2.c
@@ -378,7 +378,7 @@ static u32 read_rtl8225(struct net_device *dev, u8 adr)
 	mask = (low2high) ? 0x01 : (((u32)0x01) << (12-1));
 
 	/*
-	 * We must set data pin to HW controled, otherwise RF can't driver it
+	 * We must set data pin to HW controlled, otherwise RF can't driver it
 	 * and value RF register won't be able to read back properly.
 	 */
 	write_nic_word(dev, RFPinsEnable, (oval2 & (~0x01)));
diff --git a/drivers/staging/rtl8187se/r8185b_init.c b/drivers/staging/rtl8187se/r8185b_init.c
index 3bdf9b3..4b0b830 100644
--- a/drivers/staging/rtl8187se/r8185b_init.c
+++ b/drivers/staging/rtl8187se/r8185b_init.c
@@ -1273,7 +1273,7 @@ MgntDisconnectIBSS(
 	/*
 		Stop Beacon.
 
-		Vista add a Adhoc profile, HW radio off untill OID_DOT11_RESET_REQUEST
+		Vista add a Adhoc profile, HW radio off until OID_DOT11_RESET_REQUEST
 		Driver would set MSR=NO_LINK, then HW Radio ON, MgntQueue Stuck.
 		Because Bcn DMA isn't complete, mgnt queue would stuck until Bcn packet send.
 
diff --git a/drivers/staging/rtl8192e/Kconfig b/drivers/staging/rtl8192e/Kconfig
index 2e64b23..750c347 100644
--- a/drivers/staging/rtl8192e/Kconfig
+++ b/drivers/staging/rtl8192e/Kconfig
@@ -1,6 +1,7 @@
 config RTL8192E
 	tristate "RealTek RTL8192E Wireless LAN NIC driver"
 	depends on PCI && WLAN
+	depends on m
 	select WIRELESS_EXT
 	select WEXT_PRIV
 	select CRYPTO
diff --git a/drivers/staging/rtl8192e/ieee80211/ieee80211.h b/drivers/staging/rtl8192e/ieee80211/ieee80211.h
index 3ca3881..dbe21ab 100644
--- a/drivers/staging/rtl8192e/ieee80211/ieee80211.h
+++ b/drivers/staging/rtl8192e/ieee80211/ieee80211.h
@@ -1967,7 +1967,7 @@ struct ieee80211_device {
         u16 prev_seq_ctl;       /* used to drop duplicate frames */
 
 	/* map of allowed channels. 0 is dummy */
-	// FIXME: remeber to default to a basic channel plan depending of the PHY type
+	// FIXME: remember to default to a basic channel plan depending of the PHY type
 #ifdef ENABLE_DOT11D
 	void* pDot11dInfo;
 	bool bGlobalDomain;
@@ -2121,7 +2121,7 @@ struct ieee80211_device {
 	 * not set. As some cards may have different HW queues that
 	 * one might want to use for data and management frames
 	 * the option to have two callbacks might be useful.
-	 * This fucntion can't sleep.
+	 * This function can't sleep.
 	 */
 	int (*softmac_hard_start_xmit)(struct sk_buff *skb,
 			       struct ieee80211_device *ieee80211);
@@ -2160,9 +2160,9 @@ struct ieee80211_device {
 	 * it is called in a work_queue when swithcing to ad-hoc mode
 	 * or in behalf of iwlist scan when the card is associated
 	 * and root user ask for a scan.
-	 * the fucntion stop_scan should stop both the syncro and
+	 * the function stop_scan should stop both the syncro and
 	 * background scanning and can sleep.
-	 * The fucntion start_scan should initiate the background
+	 * The function start_scan should initiate the background
 	 * scanning and can't sleep.
 	 */
 	void (*scan_syncro)(struct ieee80211_device *ieee80211);
diff --git a/drivers/staging/rtl8192e/ieee80211/ieee80211_rx.c b/drivers/staging/rtl8192e/ieee80211/ieee80211_rx.c
index add015e..ed5a380 100644
--- a/drivers/staging/rtl8192e/ieee80211/ieee80211_rx.c
+++ b/drivers/staging/rtl8192e/ieee80211/ieee80211_rx.c
@@ -1426,7 +1426,7 @@ int ieee80211_rtl_rx(struct ieee80211_device *ieee, struct sk_buff *skb,
 static u8 qos_oui[QOS_OUI_LEN] = { 0x00, 0x50, 0xF2 };
 
 /*
-* Make ther structure we read from the beacon packet has
+* Make the structure we read from the beacon packet to have
 * the right values
 */
 static int ieee80211_verify_qos_info(struct ieee80211_qos_information_element
diff --git a/drivers/staging/rtl8192e/ieee80211/ieee80211_softmac.c b/drivers/staging/rtl8192e/ieee80211/ieee80211_softmac.c
index f6922d4..7d4cba3 100644
--- a/drivers/staging/rtl8192e/ieee80211/ieee80211_softmac.c
+++ b/drivers/staging/rtl8192e/ieee80211/ieee80211_softmac.c
@@ -2023,7 +2023,7 @@ ieee80211_rx_frame_softmac(struct ieee80211_device *ieee, struct sk_buff *skb,
 							return 1;
 						}
 						else
-						{	//filling the PeerHTCap. //maybe not neccesary as we can get its info from current_network.
+						{	//filling the PeerHTCap. //maybe not necessary as we can get its info from current_network.
 							memcpy(ieee->pHTInfo->PeerHTCapBuf, network->bssht.bdHTCapBuf, network->bssht.bdHTCapLen);
 							memcpy(ieee->pHTInfo->PeerHTInfoBuf, network->bssht.bdHTInfoBuf, network->bssht.bdHTInfoLen);
 						}
@@ -2163,7 +2163,7 @@ ieee80211_rx_frame_softmac(struct ieee80211_device *ieee, struct sk_buff *skb,
 	return 0;
 }
 
-/* following are for a simplier TX queue management.
+/* following are for a simpler TX queue management.
  * Instead of using netif_[stop/wake]_queue the driver
  * will uses these two function (plus a reset one), that
  * will internally uses the kernel netif_* and takes
diff --git a/drivers/staging/rtl8192e/ieee80211/rtl819x_HT.h b/drivers/staging/rtl8192e/ieee80211/rtl819x_HT.h
index f968817..56a120c 100644
--- a/drivers/staging/rtl8192e/ieee80211/rtl819x_HT.h
+++ b/drivers/staging/rtl8192e/ieee80211/rtl819x_HT.h
@@ -64,7 +64,7 @@ typedef enum _HT_CHANNEL_WIDTH{
 }HT_CHANNEL_WIDTH, *PHT_CHANNEL_WIDTH;
 
 //
-// Represent Extention Channel Offset in HT Capabilities
+// Represent Extension Channel Offset in HT Capabilities
 // This is available only in 40Mhz mode.
 //
 typedef enum _HT_EXTCHNL_OFFSET{
diff --git a/drivers/staging/rtl8192e/ieee80211/rtl819x_HTProc.c b/drivers/staging/rtl8192e/ieee80211/rtl819x_HTProc.c
index a2a4fe9..f7a9da3 100644
--- a/drivers/staging/rtl8192e/ieee80211/rtl819x_HTProc.c
+++ b/drivers/staging/rtl8192e/ieee80211/rtl819x_HTProc.c
@@ -459,7 +459,7 @@ u8 HTIOTActIsForcedCTS2Self(struct ieee80211_device *ieee, struct ieee80211_netw
 /**
 * Function:	HTIOTActIsDisableMCS15
 *
-* Overview:	Check whether driver should declare capability of receving MCS15
+* Overview:	Check whether driver should declare capability of receiving MCS15
 *
 * Input:
 *			PADAPTER		Adapter,
@@ -496,7 +496,7 @@ bool HTIOTActIsDisableMCS15(struct ieee80211_device* ieee)
 /**
 * Function:	HTIOTActIsDisableMCSTwoSpatialStream
 *
-* Overview:	Check whether driver should declare capability of receving All 2 ss packets
+* Overview:	Check whether driver should declare capability of receiving All 2 ss packets
 *
 * Input:
 *			PADAPTER		Adapter,
@@ -1681,7 +1681,7 @@ void HTSetConnectBwMode(struct ieee80211_device* ieee, HT_CHANNEL_WIDTH	Bandwidt
 	//if in half N mode, set to 20M bandwidth please 09.08.2008 WB.
 	if (Bandwidth==HT_CHANNEL_WIDTH_20_40 && (!ieee->GetHalfNmodeSupportByAPsHandler(ieee)))
 	 {
-	 		// Handle Illegal extention channel offset!!
+	 		// Handle Illegal extension channel offset!!
 		if(ieee->current_network.channel<2 && Offset==HT_EXTCHNL_OFFSET_LOWER)
 			Offset = HT_EXTCHNL_OFFSET_NO_EXT;
 		if(Offset==HT_EXTCHNL_OFFSET_UPPER || Offset==HT_EXTCHNL_OFFSET_LOWER) {
@@ -1698,7 +1698,7 @@ void HTSetConnectBwMode(struct ieee80211_device* ieee, HT_CHANNEL_WIDTH	Bandwidt
 
 	pHTInfo->bSwBwInProgress = true;
 
-	// TODO: 2007.7.13 by Emily Wait 2000ms  in order to garantee that switching
+	// TODO: 2007.7.13 by Emily Wait 2000ms  in order to guarantee that switching
 	//   bandwidth is executed after scan is finished. It is a temporal solution
 	//   because software should ganrantee the last operation of switching bandwidth
 	//   is executed properlly.
diff --git a/drivers/staging/rtl8192e/ieee80211/rtl819x_TS.h b/drivers/staging/rtl8192e/ieee80211/rtl819x_TS.h
index baaac21..e7e26fd 100644
--- a/drivers/staging/rtl8192e/ieee80211/rtl819x_TS.h
+++ b/drivers/staging/rtl8192e/ieee80211/rtl819x_TS.h
@@ -44,7 +44,7 @@ typedef struct _RX_TS_RECORD {
 	u16				RxTimeoutIndicateSeq;
 	struct list_head		RxPendingPktList;
 	struct timer_list		RxPktPendingTimer;
-	BA_RECORD			RxAdmittedBARecord;	 // For BA Recepient
+	BA_RECORD			RxAdmittedBARecord;	 // For BA Recipient
 	u16				RxLastSeqNum;
 	u8				RxLastFragNum;
 	u8				num;
diff --git a/drivers/staging/rtl8192e/ieee80211/rtl819x_TSProc.c b/drivers/staging/rtl8192e/ieee80211/rtl819x_TSProc.c
index 29eecf0..ad6872d 100644
--- a/drivers/staging/rtl8192e/ieee80211/rtl819x_TSProc.c
+++ b/drivers/staging/rtl8192e/ieee80211/rtl819x_TSProc.c
@@ -135,7 +135,7 @@ void ResetRxTsEntry(PRX_TS_RECORD pTS)
 	ResetTsCommonInfo(&pTS->TsCommonInfo);
 	pTS->RxIndicateSeq = 0xffff; // This indicate the RxIndicateSeq is not used now!!
 	pTS->RxTimeoutIndicateSeq = 0xffff; // This indicate the RxTimeoutIndicateSeq is not used now!!
-	ResetBaEntry(&pTS->RxAdmittedBARecord);	  // For BA Recepient
+	ResetBaEntry(&pTS->RxAdmittedBARecord);	  // For BA Recipient
 }
 
 void TSInitialize(struct ieee80211_device *ieee)
diff --git a/drivers/staging/rtl8192e/r819xE_phy.c b/drivers/staging/rtl8192e/r819xE_phy.c
index dfa4e11..9e7828e 100644
--- a/drivers/staging/rtl8192e/r819xE_phy.c
+++ b/drivers/staging/rtl8192e/r819xE_phy.c
@@ -2032,13 +2032,13 @@ void rtl8192_SetBWModeWorkItem(struct r8192_priv *priv)
 	{
 		case HT_CHANNEL_WIDTH_20:
 			regBwOpMode |= BW_OPMODE_20MHZ;
-		       // 2007/02/07 Mark by Emily becasue we have not verify whether this register works
+		       // 2007/02/07 Mark by Emily because we have not verify whether this register works
 			write_nic_byte(priv, BW_OPMODE, regBwOpMode);
 			break;
 
 		case HT_CHANNEL_WIDTH_20_40:
 			regBwOpMode &= ~BW_OPMODE_20MHZ;
-        		// 2007/02/07 Mark by Emily becasue we have not verify whether this register works
+        		// 2007/02/07 Mark by Emily because we have not verify whether this register works
 			write_nic_byte(priv, BW_OPMODE, regBwOpMode);
 			break;
 
@@ -2116,7 +2116,7 @@ void rtl8192_SetBWModeWorkItem(struct r8192_priv *priv)
 }
 
 /******************************************************************************
- *function:  This function schedules bandwith switch work.
+ *function:  This function schedules bandwidth switch work.
  *   input:  struct net_device *dev
  *   	     HT_CHANNEL_WIDTH	Bandwidth  //20M or 40M
  *   	     HT_EXTCHNL_OFFSET Offset 	   //Upper, Lower, or Don't care
diff --git a/drivers/staging/rtl8192u/Kconfig b/drivers/staging/rtl8192u/Kconfig
index 2896919..3f05509 100644
--- a/drivers/staging/rtl8192u/Kconfig
+++ b/drivers/staging/rtl8192u/Kconfig
@@ -1,6 +1,7 @@
 config RTL8192U
 	tristate "RealTek RTL8192U Wireless LAN NIC driver"
 	depends on PCI && WLAN && USB
+	depends on m
 	select WIRELESS_EXT
 	select WEXT_PRIV
 	select CRYPTO
diff --git a/drivers/staging/rtl8192u/ieee80211/ieee80211.h b/drivers/staging/rtl8192u/ieee80211/ieee80211.h
index c0b844d..e716f7b 100644
--- a/drivers/staging/rtl8192u/ieee80211/ieee80211.h
+++ b/drivers/staging/rtl8192u/ieee80211/ieee80211.h
@@ -1965,7 +1965,7 @@ struct ieee80211_device {
 	u16 prev_seq_ctl;       /* used to drop duplicate frames */
 
 	/* map of allowed channels. 0 is dummy */
-	// FIXME: remeber to default to a basic channel plan depending of the PHY type
+	// FIXME: remember to default to a basic channel plan depending of the PHY type
 	void* pDot11dInfo;
 	bool bGlobalDomain;
 	int rate;       /* current rate */
@@ -2119,7 +2119,7 @@ struct ieee80211_device {
 	 * not set. As some cards may have different HW queues that
 	 * one might want to use for data and management frames
 	 * the option to have two callbacks might be useful.
-	 * This fucntion can't sleep.
+	 * This function can't sleep.
 	 */
 	int (*softmac_hard_start_xmit)(struct sk_buff *skb,
 			       struct net_device *dev);
@@ -2158,9 +2158,9 @@ struct ieee80211_device {
 	 * it is called in a work_queue when swithcing to ad-hoc mode
 	 * or in behalf of iwlist scan when the card is associated
 	 * and root user ask for a scan.
-	 * the fucntion stop_scan should stop both the syncro and
+	 * the function stop_scan should stop both the syncro and
 	 * background scanning and can sleep.
-	 * The fucntion start_scan should initiate the background
+	 * The function start_scan should initiate the background
 	 * scanning and can't sleep.
 	 */
 	void (*scan_syncro)(struct net_device *dev);
diff --git a/drivers/staging/rtl8192u/ieee80211/ieee80211_rx.c b/drivers/staging/rtl8192u/ieee80211/ieee80211_rx.c
index 498b520..a414303 100644
--- a/drivers/staging/rtl8192u/ieee80211/ieee80211_rx.c
+++ b/drivers/staging/rtl8192u/ieee80211/ieee80211_rx.c
@@ -1399,7 +1399,7 @@ int ieee80211_rx(struct ieee80211_device *ieee, struct sk_buff *skb,
 static u8 qos_oui[QOS_OUI_LEN] = { 0x00, 0x50, 0xF2 };
 
 /*
-* Make ther structure we read from the beacon packet has
+* Make the structure we read from the beacon packet to have
 * the right values
 */
 static int ieee80211_verify_qos_info(struct ieee80211_qos_information_element
diff --git a/drivers/staging/rtl8192u/ieee80211/ieee80211_softmac.c b/drivers/staging/rtl8192u/ieee80211/ieee80211_softmac.c
index 4992d63..4ec0a65 100644
--- a/drivers/staging/rtl8192u/ieee80211/ieee80211_softmac.c
+++ b/drivers/staging/rtl8192u/ieee80211/ieee80211_softmac.c
@@ -1973,7 +1973,7 @@ ieee80211_rx_frame_softmac(struct ieee80211_device *ieee, struct sk_buff *skb,
 							return 1;
 						}
 						else
-						{	//filling the PeerHTCap. //maybe not neccesary as we can get its info from current_network.
+						{	//filling the PeerHTCap. //maybe not necessary as we can get its info from current_network.
 							memcpy(ieee->pHTInfo->PeerHTCapBuf, network->bssht.bdHTCapBuf, network->bssht.bdHTCapLen);
 							memcpy(ieee->pHTInfo->PeerHTInfoBuf, network->bssht.bdHTInfoBuf, network->bssht.bdHTInfoLen);
 						}
@@ -2113,7 +2113,7 @@ ieee80211_rx_frame_softmac(struct ieee80211_device *ieee, struct sk_buff *skb,
 	return 0;
 }
 
-/* following are for a simplier TX queue management.
+/* following are for a simpler TX queue management.
  * Instead of using netif_[stop/wake]_queue the driver
  * will uses these two function (plus a reset one), that
  * will internally uses the kernel netif_* and takes
diff --git a/drivers/staging/rtl8192u/ieee80211/rtl819x_HT.h b/drivers/staging/rtl8192u/ieee80211/rtl819x_HT.h
index cde603f..0b1a1fc 100644
--- a/drivers/staging/rtl8192u/ieee80211/rtl819x_HT.h
+++ b/drivers/staging/rtl8192u/ieee80211/rtl819x_HT.h
@@ -64,7 +64,7 @@ typedef enum _HT_CHANNEL_WIDTH{
 }HT_CHANNEL_WIDTH, *PHT_CHANNEL_WIDTH;
 
 //
-// Represent Extention Channel Offset in HT Capabilities
+// Represent Extension Channel Offset in HT Capabilities
 // This is available only in 40Mhz mode.
 //
 typedef enum _HT_EXTCHNL_OFFSET{
diff --git a/drivers/staging/rtl8192u/ieee80211/rtl819x_HTProc.c b/drivers/staging/rtl8192u/ieee80211/rtl819x_HTProc.c
index 50f4f59..e88a839 100644
--- a/drivers/staging/rtl8192u/ieee80211/rtl819x_HTProc.c
+++ b/drivers/staging/rtl8192u/ieee80211/rtl819x_HTProc.c
@@ -423,7 +423,7 @@ u8 HTIOTActIsDisableMCS14(struct ieee80211_device* ieee, u8* PeerMacAddr)
 /**
 * Function:	HTIOTActIsDisableMCS15
 *
-* Overview:	Check whether driver should declare capability of receving MCS15
+* Overview:	Check whether driver should declare capability of receiving MCS15
 *
 * Input:
 *			PADAPTER		Adapter,
@@ -460,7 +460,7 @@ bool HTIOTActIsDisableMCS15(struct ieee80211_device* ieee)
 /**
 * Function:	HTIOTActIsDisableMCSTwoSpatialStream
 *
-* Overview:	Check whether driver should declare capability of receving All 2 ss packets
+* Overview:	Check whether driver should declare capability of receiving All 2 ss packets
 *
 * Input:
 *			PADAPTER		Adapter,
@@ -1409,7 +1409,7 @@ void HTSetConnectBwMode(struct ieee80211_device* ieee, HT_CHANNEL_WIDTH	Bandwidt
 	//if in half N mode, set to 20M bandwidth please 09.08.2008 WB.
 	if(Bandwidth==HT_CHANNEL_WIDTH_20_40 && (!ieee->GetHalfNmodeSupportByAPsHandler(ieee->dev)))
 	 {
-			// Handle Illegal extention channel offset!!
+			// Handle Illegal extension channel offset!!
 		if(ieee->current_network.channel<2 && Offset==HT_EXTCHNL_OFFSET_LOWER)
 			Offset = HT_EXTCHNL_OFFSET_NO_EXT;
 		if(Offset==HT_EXTCHNL_OFFSET_UPPER || Offset==HT_EXTCHNL_OFFSET_LOWER) {
@@ -1426,7 +1426,7 @@ void HTSetConnectBwMode(struct ieee80211_device* ieee, HT_CHANNEL_WIDTH	Bandwidt
 
 	pHTInfo->bSwBwInProgress = true;
 
-	// TODO: 2007.7.13 by Emily Wait 2000ms  in order to garantee that switching
+	// TODO: 2007.7.13 by Emily Wait 2000ms  in order to guarantee that switching
 	//   bandwidth is executed after scan is finished. It is a temporal solution
 	//   because software should ganrantee the last operation of switching bandwidth
 	//   is executed properlly.
diff --git a/drivers/staging/rtl8192u/ieee80211/rtl819x_TS.h b/drivers/staging/rtl8192u/ieee80211/rtl819x_TS.h
index baaac21..e7e26fd 100644
--- a/drivers/staging/rtl8192u/ieee80211/rtl819x_TS.h
+++ b/drivers/staging/rtl8192u/ieee80211/rtl819x_TS.h
@@ -44,7 +44,7 @@ typedef struct _RX_TS_RECORD {
 	u16				RxTimeoutIndicateSeq;
 	struct list_head		RxPendingPktList;
 	struct timer_list		RxPktPendingTimer;
-	BA_RECORD			RxAdmittedBARecord;	 // For BA Recepient
+	BA_RECORD			RxAdmittedBARecord;	 // For BA Recipient
 	u16				RxLastSeqNum;
 	u8				RxLastFragNum;
 	u8				num;
diff --git a/drivers/staging/rtl8192u/ieee80211/rtl819x_TSProc.c b/drivers/staging/rtl8192u/ieee80211/rtl819x_TSProc.c
index c3fcaae..957ce4e 100644
--- a/drivers/staging/rtl8192u/ieee80211/rtl819x_TSProc.c
+++ b/drivers/staging/rtl8192u/ieee80211/rtl819x_TSProc.c
@@ -135,7 +135,7 @@ void ResetRxTsEntry(PRX_TS_RECORD pTS)
 	ResetTsCommonInfo(&pTS->TsCommonInfo);
 	pTS->RxIndicateSeq = 0xffff; // This indicate the RxIndicateSeq is not used now!!
 	pTS->RxTimeoutIndicateSeq = 0xffff; // This indicate the RxTimeoutIndicateSeq is not used now!!
-	ResetBaEntry(&pTS->RxAdmittedBARecord);	  // For BA Recepient
+	ResetBaEntry(&pTS->RxAdmittedBARecord);	  // For BA Recipient
 }
 
 void TSInitialize(struct ieee80211_device *ieee)
diff --git a/drivers/staging/rtl8192u/ieee80211/scatterwalk.c b/drivers/staging/rtl8192u/ieee80211/scatterwalk.c
index 49f401f..3543a61 100644
--- a/drivers/staging/rtl8192u/ieee80211/scatterwalk.c
+++ b/drivers/staging/rtl8192u/ieee80211/scatterwalk.c
@@ -71,7 +71,7 @@ static void scatterwalk_pagedone(struct scatter_walk *walk, int out,
 				 unsigned int more)
 {
 	/* walk->data may be pointing the first byte of the next page;
-	   however, we know we transfered at least one byte.  So,
+	   however, we know we transferred at least one byte.  So,
 	   walk->data - 1 will be a virtual address in the mapped page. */
 
 	if (out)
diff --git a/drivers/staging/rtl8192u/r8192U_core.c b/drivers/staging/rtl8192u/r8192U_core.c
index da612e6..e81b8ab 100644
--- a/drivers/staging/rtl8192u/r8192U_core.c
+++ b/drivers/staging/rtl8192u/r8192U_core.c
@@ -460,7 +460,7 @@ u32 read_nic_dword(struct net_device *dev, int indx)
 /* u8 read_phy_cck(struct net_device *dev, u8 adr); */
 /* u8 read_phy_ofdm(struct net_device *dev, u8 adr); */
 /* this might still called in what was the PHY rtl8185/rtl8192 common code
- * plans are to possibilty turn it again in one common code...
+ * plans are to possibility turn it again in one common code...
  */
 inline void force_pci_posting(struct net_device *dev)
 {
@@ -1378,7 +1378,7 @@ struct sk_buff *DrvAggr_Aggregation(struct net_device *dev, struct ieee80211_drv
 		//tx_agg_desc->LINIP = 0;
 		//tx_agg_desc->CmdInit = 1;
 		tx_agg_desc->Offset =  sizeof(tx_fwinfo_819x_usb) + 8;
-		/* already raw data, need not to substract header length */
+		/* already raw data, need not to subtract header length */
 		tx_agg_desc->PktSize = skb->len & 0xffff;
 
 		/*DWORD 1*/
@@ -2888,7 +2888,7 @@ static void rtl8192_get_eeprom_size(struct net_device* dev)
 	RT_TRACE(COMP_EPROM, "<===========%s(), epromtype:%d\n", __FUNCTION__, priv->epromtype);
 }
 
-//used to swap endian. as ntohl & htonl are not neccessary to swap endian, so use this instead.
+//used to swap endian. as ntohl & htonl are not necessary to swap endian, so use this instead.
 static inline u16 endian_swap(u16* data)
 {
 	u16 tmp = *data;
diff --git a/drivers/staging/rtl8192u/r819xU_HTType.h b/drivers/staging/rtl8192u/r819xU_HTType.h
index 01f58b9..2ac4216 100644
--- a/drivers/staging/rtl8192u/r819xU_HTType.h
+++ b/drivers/staging/rtl8192u/r819xU_HTType.h
@@ -65,7 +65,7 @@ typedef enum _HT_CHANNEL_WIDTH{
 }HT_CHANNEL_WIDTH, *PHT_CHANNEL_WIDTH;
 
 //
-// Represent Extention Channel Offset in HT Capabilities
+// Represent Extension Channel Offset in HT Capabilities
 // This is available only in 40Mhz mode.
 //
 typedef enum _HT_EXTCHNL_OFFSET{
diff --git a/drivers/staging/rtl8192u/r819xU_phy.c b/drivers/staging/rtl8192u/r819xU_phy.c
index 41684e8..c4586b0 100644
--- a/drivers/staging/rtl8192u/r819xU_phy.c
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -1531,13 +1531,13 @@ void rtl8192_SetBWModeWorkItem(struct net_device *dev)
 	{
 		case HT_CHANNEL_WIDTH_20:
 			regBwOpMode |= BW_OPMODE_20MHZ;
-		       // 2007/02/07 Mark by Emily becasue we have not verify whether this register works
+		       // 2007/02/07 Mark by Emily because we have not verify whether this register works
 			write_nic_byte(dev, BW_OPMODE, regBwOpMode);
 			break;
 
 		case HT_CHANNEL_WIDTH_20_40:
 			regBwOpMode &= ~BW_OPMODE_20MHZ;
-			// 2007/02/07 Mark by Emily becasue we have not verify whether this register works
+			// 2007/02/07 Mark by Emily because we have not verify whether this register works
 			write_nic_byte(dev, BW_OPMODE, regBwOpMode);
 			break;
 
@@ -1647,7 +1647,7 @@ void rtl8192_SetBWModeWorkItem(struct net_device *dev)
 }
 
 /******************************************************************************
- *function:  This function schedules bandwith switch work.
+ *function:  This function schedules bandwidth switch work.
  *   input:  struct net_device *dev
  *   	     HT_CHANNEL_WIDTH	Bandwidth  //20M or 40M
  *   	     HT_EXTCHNL_OFFSET Offset 	   //Upper, Lower, or Don't care
diff --git a/drivers/staging/rtl8712/rtl871x_cmd.h b/drivers/staging/rtl8712/rtl871x_cmd.h
index 3a945b5..2dc7847 100644
--- a/drivers/staging/rtl8712/rtl871x_cmd.h
+++ b/drivers/staging/rtl8712/rtl871x_cmd.h
@@ -656,7 +656,7 @@ struct PT_param {
 /*
  * Result:
  * 0x00: success
- * 0x01: sucess, and check Response.
+ * 0x01: success, and check Response.
  * 0x02: cmd ignored due to duplicated sequcne number
  * 0x03: cmd dropped due to invalid cmd code
  * 0x04: reserved.
diff --git a/drivers/staging/rtl8712/rtl871x_led.h b/drivers/staging/rtl8712/rtl871x_led.h
index 994ef82..8085e5e 100644
--- a/drivers/staging/rtl8712/rtl871x_led.h
+++ b/drivers/staging/rtl8712/rtl871x_led.h
@@ -78,14 +78,14 @@ struct LED_871x {
 };
 
 struct led_priv {
-	/* add for led controll */
+	/* add for led control */
 	struct LED_871x		SwLed0;
 	struct LED_871x		SwLed1;
 	enum LED_STRATEGY_871x	LedStrategy;
 	u8			bRegUseLed;
 	void (*LedControlHandler)(struct _adapter *padapter,
 				  enum LED_CTL_MODE LedAction);
-	/* add for led controll */
+	/* add for led control */
 };
 
 /*===========================================================================
diff --git a/drivers/staging/rtl8712/rtl871x_mlme.c b/drivers/staging/rtl8712/rtl871x_mlme.c
index 98ba760..866554d 100644
--- a/drivers/staging/rtl8712/rtl871x_mlme.c
+++ b/drivers/staging/rtl8712/rtl871x_mlme.c
@@ -1663,7 +1663,7 @@ void r8712_update_registrypriv_dev_network(struct _adapter *adapter)
 			      (struct ndis_wlan_bssid_ex *)pdev_network);
 }
 
-/*the fucntion is at passive_level*/
+/*the function is at passive_level*/
 void r8712_joinbss_reset(struct _adapter *padapter)
 {
 	int i;
@@ -1726,7 +1726,7 @@ unsigned int r8712_restructure_ht_ie(struct _adapter *padapter, u8 *in_ie,
 	return phtpriv->ht_option;
 }
 
-/* the fucntion is > passive_level (in critical_section) */
+/* the function is > passive_level (in critical_section) */
 static void update_ht_cap(struct _adapter *padapter, u8 *pie, uint ie_len)
 {
 	u8 *p, max_ampdu_sz;
@@ -1803,7 +1803,7 @@ void r8712_issue_addbareq_cmd(struct _adapter *padapter, int priority)
 	}
 }
 
-/*the fucntion is >= passive_level*/
+/*the function is >= passive_level*/
 unsigned int r8712_add_ht_addt_info(struct _adapter *padapter,
 			      u8 *in_ie, u8 *out_ie,
 			      uint in_len, uint *pout_len)
diff --git a/drivers/staging/rtl8712/rtl871x_mlme.h b/drivers/staging/rtl8712/rtl871x_mlme.h
index 2b35b74..2794804 100644
--- a/drivers/staging/rtl8712/rtl871x_mlme.h
+++ b/drivers/staging/rtl8712/rtl871x_mlme.h
@@ -29,7 +29,7 @@
 						 *  single-tone*/
 #define	WIFI_MP_CTX_BACKGROUND_PENDING	0x00080000 /* pending in cont, tx
 					* background due to out of skb*/
-#define	WIFI_MP_CTX_CCK_HW	0x00100000	/* in continous tx*/
+#define	WIFI_MP_CTX_CCK_HW	0x00100000	/* in continuous tx*/
 #define	WIFI_MP_CTX_CCK_CS	0x00200000	/* in cont, tx with carrier
 						 * suppression*/
 #define   WIFI_MP_LPBK_STATE	0x00400000
diff --git a/drivers/staging/rtl8712/rtl871x_mp_phy_regdef.h b/drivers/staging/rtl8712/rtl871x_mp_phy_regdef.h
index e386fb0..23532a7 100644
--- a/drivers/staging/rtl8712/rtl871x_mp_phy_regdef.h
+++ b/drivers/staging/rtl8712/rtl871x_mp_phy_regdef.h
@@ -38,7 +38,7 @@
  * 2. 0x800/0x900/0xA00/0xC00/0xD00/0xE00
  * 3. RF register 0x00-2E
  * 4. Bit Mask for BB/RF register
- * 5. Other defintion for BB/RF R/W
+ * 5. Other definition for BB/RF R/W
  *
  * 1. PMAC duplicate register due to connection: RF_Mode, TRxRN, NumOf L-STF
  * 1. Page1(0x100)
diff --git a/drivers/staging/rtl8712/usb_halinit.c b/drivers/staging/rtl8712/usb_halinit.c
index 0e9483b..46287c1 100644
--- a/drivers/staging/rtl8712/usb_halinit.c
+++ b/drivers/staging/rtl8712/usb_halinit.c
@@ -112,7 +112,7 @@ u8 r8712_usb_hal_bus_init(struct _adapter *padapter)
 		/* Initialization for power on sequence, */
 		r8712_write8(padapter, SPS0_CTRL + 1, 0x53);
 		r8712_write8(padapter, SPS0_CTRL, 0x57);
-		/* Enable AFE Macro Block's Bandgap adn Enable AFE Macro
+		/* Enable AFE Macro Block's Bandgap and Enable AFE Macro
 		 * Block's Mbias
 		 */
 		val8 = r8712_read8(padapter, AFE_MISC);
diff --git a/drivers/staging/rts_pstor/rtsx.c b/drivers/staging/rts_pstor/rtsx.c
index 4514419..02525d5 100644
--- a/drivers/staging/rts_pstor/rtsx.c
+++ b/drivers/staging/rts_pstor/rtsx.c
@@ -824,13 +824,13 @@ static void rtsx_init_options(struct rtsx_chip *chip)
 	chip->fpga_ms_hg_clk = CLK_80;
 	chip->fpga_ms_4bit_clk = CLK_80;
 	chip->fpga_ms_1bit_clk = CLK_40;
-	chip->asic_sd_sdr104_clk = 207;
-	chip->asic_sd_sdr50_clk = 99;
-	chip->asic_sd_ddr50_clk = 99;
-	chip->asic_sd_hs_clk = 99;
-	chip->asic_mmc_52m_clk = 99;
-	chip->asic_ms_hg_clk = 119;
-	chip->asic_ms_4bit_clk = 79;
+	chip->asic_sd_sdr104_clk = 203;
+	chip->asic_sd_sdr50_clk = 98;
+	chip->asic_sd_ddr50_clk = 98;
+	chip->asic_sd_hs_clk = 98;
+	chip->asic_mmc_52m_clk = 98;
+	chip->asic_ms_hg_clk = 117;
+	chip->asic_ms_4bit_clk = 78;
 	chip->asic_ms_1bit_clk = 39;
 	chip->ssc_depth_sd_sdr104 = SSC_DEPTH_2M;
 	chip->ssc_depth_sd_sdr50 = SSC_DEPTH_2M;
diff --git a/drivers/staging/rts_pstor/rtsx_chip.c b/drivers/staging/rts_pstor/rtsx_chip.c
index f443d97..d2f1c71 100644
--- a/drivers/staging/rts_pstor/rtsx_chip.c
+++ b/drivers/staging/rts_pstor/rtsx_chip.c
@@ -684,6 +684,11 @@ static int rts5209_init(struct rtsx_chip *chip)
 	RTSX_DEBUGP("dw in 0x724: 0x%x\n", lval);
 	val = (u8)lval;
 	if (!(val & 0x80)) {
+		if (val & 0x08)
+			chip->lun_mode = DEFAULT_SINGLE;
+		else
+			chip->lun_mode = SD_MS_2LUN;
+
 		if (val & 0x04) {
 			SET_SDIO_EXIST(chip);
 		} else {
@@ -705,12 +710,6 @@ static int rts5209_init(struct rtsx_chip *chip)
 
 		chip->aspm_l0s_l1_en = (val >> 5) & 0x03;
 
-		if (val & 0x08) {
-			chip->lun_mode = DEFAULT_SINGLE;
-		} else {
-			chip->lun_mode = SD_MS_2LUN;
-		}
-
 		val = (u8)(lval >> 8);
 
 		clk = (val >> 5) & 0x07;
diff --git a/drivers/staging/rts_pstor/rtsx_chip.h b/drivers/staging/rts_pstor/rtsx_chip.h
index 713c5ea..9f7cd82a 100644
--- a/drivers/staging/rts_pstor/rtsx_chip.h
+++ b/drivers/staging/rts_pstor/rtsx_chip.h
@@ -180,8 +180,8 @@
 #define CUR_ERR                 0x70    /* current error                    */
 #define DEF_ERR                 0x71    /* specific command error           */
 
-/*---- sense key Infomation ----*/
-#define SNSKEYINFO_LEN          3       /* length of sense key infomation   */
+/*---- sense key Information ----*/
+#define SNSKEYINFO_LEN          3       /* length of sense key information   */
 
 #define SKSV                    0x80
 #define CDB_ILLEGAL             0x40
@@ -235,13 +235,13 @@ struct sense_data_t {
     unsigned char   seg_no;		/* segment No.                      */
     unsigned char   sense_key;		/* byte5 : ILI                      */
 						/* bit3-0 : sense key              */
-    unsigned char   info[4];		/* infomation                       */
+    unsigned char   info[4];		/* information                       */
     unsigned char   ad_sense_len;	/* additional sense data length     */
-    unsigned char   cmd_info[4];	/* command specific infomation      */
+    unsigned char   cmd_info[4];	/* command specific information      */
     unsigned char   asc;		/* ASC                              */
     unsigned char   ascq;		/* ASCQ                             */
     unsigned char   rfu;		/* FRU                              */
-    unsigned char   sns_key_info[3];	/* sense key specific infomation    */
+    unsigned char   sns_key_info[3];	/* sense key specific information    */
 };
 
 /* PCI Operation Register Address */
diff --git a/drivers/staging/rts_pstor/rtsx_scsi.h b/drivers/staging/rts_pstor/rtsx_scsi.h
index fac122c..64b8499 100644
--- a/drivers/staging/rts_pstor/rtsx_scsi.h
+++ b/drivers/staging/rts_pstor/rtsx_scsi.h
@@ -85,7 +85,7 @@
 #define CHIP_NORMALMODE		0x00
 #define CHIP_DEBUGMODE		0x01
 
-/* SD Pass Through Command Extention */
+/* SD Pass Through Command Extension */
 #define SD_PASS_THRU_MODE	0xD0
 #define SD_EXECUTE_NO_DATA	0xD1
 #define SD_EXECUTE_READ		0xD2
diff --git a/drivers/staging/rts_pstor/sd.c b/drivers/staging/rts_pstor/sd.c
index 21bfa57..8d066bd 100644
--- a/drivers/staging/rts_pstor/sd.c
+++ b/drivers/staging/rts_pstor/sd.c
@@ -1719,7 +1719,7 @@ static u8 sd_search_final_phase(struct rtsx_chip *chip, u32 phase_map, u8 tune_d
 	}
 
 Search_Finish:
-	RTSX_DEBUGP("Final choosen phase: %d\n", final_phase);
+	RTSX_DEBUGP("Final chosen phase: %d\n", final_phase);
 	return final_phase;
 }
 
diff --git a/drivers/staging/sep/sep_driver.c b/drivers/staging/sep/sep_driver.c
index 71a5fbc..890eede 100644
--- a/drivers/staging/sep/sep_driver.c
+++ b/drivers/staging/sep/sep_driver.c
@@ -55,8 +55,6 @@
 #include <linux/jiffies.h>
 #include <linux/rar_register.h>
 
-#include "../memrar/memrar.h"
-
 #include "sep_driver_hw_defs.h"
 #include "sep_driver_config.h"
 #include "sep_driver_api.h"
@@ -586,7 +584,7 @@ static unsigned int sep_poll(struct file *filp, poll_table *wait)
 	dev_dbg(&sep->pdev->dev, "poll: send_ct is %lx reply ct is %lx\n",
 		sep->send_ct, sep->reply_ct);
 
-	/* Check if error occured during poll */
+	/* Check if error occurred during poll */
 	retval2 = sep_read_reg(sep, HW_HOST_SEP_HOST_GPR3_REG_ADDR);
 	if (retval2 != 0x0) {
 		dev_warn(&sep->pdev->dev, "poll; poll error %x\n", retval2);
@@ -1106,7 +1104,7 @@ static int sep_lock_user_pages(struct sep_device *sep,
 			lli_array[count].block_size);
 	}
 
-	/* Set output params acording to the in_out flag */
+	/* Set output params according to the in_out flag */
 	if (in_out_flag == SEP_DRIVER_IN_FLAG) {
 		*lli_array_ptr = lli_array;
 		sep->dma_res_arr[sep->nr_dcb_creat].in_num_pages = num_pages;
@@ -1577,7 +1575,7 @@ static int sep_prepare_input_dma_table(struct sep_device *sep,
 
 		/*
 		 * If this is not the last table -
-		 * then allign it to the block size
+		 * then align it to the block size
 		 */
 		if (!last_table_flag)
 			table_data_size =
@@ -1974,7 +1972,7 @@ static int sep_prepare_input_output_dma_table(struct sep_device *sep,
 	dev_dbg(&sep->pdev->dev, "SEP_DRIVER_ENTRIES_PER_TABLE_IN_SEP is %x\n",
 		SEP_DRIVER_ENTRIES_PER_TABLE_IN_SEP);
 
-	/* Call the fucntion that creates table from the lli arrays */
+	/* Call the function that creates table from the lli arrays */
 	error = sep_construct_dma_tables_from_lli(sep, lli_in_array,
 		sep->dma_res_arr[sep->nr_dcb_creat].in_num_pages,
 		lli_out_array,
@@ -2372,7 +2370,6 @@ static int sep_rar_prepare_output_msg_handler(struct sep_device *sep,
 	int error = 0;
 	/* Command args */
 	struct rar_hndl_to_bus_struct command_args;
-	struct RAR_buffer rar_buf;
 	/* Bus address */
 	dma_addr_t  rar_bus = 0;
 	/* Holds the RAR address in the system memory offset */
@@ -2386,16 +2383,8 @@ static int sep_rar_prepare_output_msg_handler(struct sep_device *sep,
 	}
 
 	/* Call to translation function only if user handle is not NULL */
-	if (command_args.rar_handle) {
-		memset(&rar_buf, 0, sizeof(rar_buf));
-		rar_buf.info.handle = (u32)command_args.rar_handle;
-
-		if (rar_handle_to_bus(&rar_buf, 1) != 1) {
-			error = -EFAULT;
-			goto end_function;
-		}
-		rar_bus = rar_buf.bus_address;
-	}
+	if (command_args.rar_handle)
+		return -EOPNOTSUPP;
 	dev_dbg(&sep->pdev->dev, "rar msg; rar_addr_bus = %x\n", (u32)rar_bus);
 
 	/* Set value in the SYSTEM MEMORY offset */
@@ -2416,7 +2405,7 @@ end_function:
  *	@cmd: command
  *	@arg: pointer to argument structure
  *
- *	Implement the ioctl methods availble on the SEP device.
+ *	Implement the ioctl methods available on the SEP device.
  */
 static long sep_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 {
diff --git a/drivers/staging/sep/sep_driver_config.h b/drivers/staging/sep/sep_driver_config.h
index d3b9220..1033425 100644
--- a/drivers/staging/sep/sep_driver_config.h
+++ b/drivers/staging/sep/sep_driver_config.h
@@ -65,11 +65,11 @@
 #define SEP_DRIVER_MIN_DATA_SIZE_PER_TABLE		16
 
 /* flag that signifies tah the lock is
-currently held by the proccess (struct file) */
+currently held by the process (struct file) */
 #define SEP_DRIVER_OWN_LOCK_FLAG                        1
 
 /* flag that signifies tah the lock is currently NOT
-held by the proccess (struct file) */
+held by the process (struct file) */
 #define SEP_DRIVER_DISOWN_LOCK_FLAG                     0
 
 /* indicates whether driver has mapped/unmapped shared area */
diff --git a/drivers/staging/slicoss/README b/drivers/staging/slicoss/README
index 70f4909..b83bba1 100644
--- a/drivers/staging/slicoss/README
+++ b/drivers/staging/slicoss/README
@@ -33,7 +33,7 @@ TODO:
 	- NAPI?
 	- wasted overhead of extra stats
 	- state variables for things that are
-	  easily availble and shouldn't be kept in card structure, cardnum, ...
+	  easily available and shouldn't be kept in card structure, cardnum, ...
 	  slotnumber, events, ...
 	- get rid of slic_spinlock wrapper
 	- volatile == bad design => bad code
diff --git a/drivers/staging/sm7xx/smtcfb.c b/drivers/staging/sm7xx/smtcfb.c
index d007e4a..3e2230f 100644
--- a/drivers/staging/sm7xx/smtcfb.c
+++ b/drivers/staging/sm7xx/smtcfb.c
@@ -26,10 +26,6 @@
  *	Boyod.yang <boyod.yang@siliconmotion.com.cn>
  */
 
-#ifndef __KERNEL__
-#define __KERNEL__
-#endif
-
 #include <linux/io.h>
 #include <linux/fb.h>
 #include <linux/pci.h>
@@ -965,7 +961,7 @@ static int __devinit smtcfb_pci_probe(struct pci_dev *pdev,
 		goto failed;
 
 	smtcfb_setmode(sfb);
-	/* Primary display starting from 0 postion */
+	/* Primary display starting from 0 position */
 	hw.BaseAddressInVRAM = 0;
 	sfb->fb.par = &hw;
 
@@ -1019,6 +1015,7 @@ static void __devexit smtcfb_pci_remove(struct pci_dev *pdev)
 	smtc_free_fb_info(sfb);
 }
 
+#ifdef CONFIG_PM
 /* Jason (08/14/2009)
  * suspend function, called when the suspend event is triggered
  */
@@ -1055,7 +1052,7 @@ static int __maybe_unused smtcfb_suspend(struct pci_dev *pdev, pm_message_t msg)
 
 	pdev->dev.power.power_state = msg;
 
-	/* additionaly turn off all function blocks including internal PLLs */
+	/* additionally turn off all function blocks including internal PLLs */
 	smtc_seqw(0x21, 0xff);
 
 	return 0;
@@ -1111,6 +1108,7 @@ static int __maybe_unused smtcfb_resume(struct pci_dev *pdev)
 
 	return 0;
 }
+#endif
 
 /* Jason (08/13/2009)
  * pci_driver struct used to wrap the original driver
diff --git a/drivers/staging/speakup/keyhelp.c b/drivers/staging/speakup/keyhelp.c
index 23cf7f4..170f388 100644
--- a/drivers/staging/speakup/keyhelp.c
+++ b/drivers/staging/speakup/keyhelp.c
@@ -69,7 +69,7 @@ static void build_key_data(void)
 	memset(key_offsets, 0, sizeof(key_offsets));
 	kp = state_tbl + nstates + 1;
 	while (*kp++) {
-		/* count occurrances of each function */
+		/* count occurrences of each function */
 		for (i = 0; i < nstates; i++, kp++) {
 			if (!*kp)
 				continue;
diff --git a/drivers/staging/speakup/spkguide.txt b/drivers/staging/speakup/spkguide.txt
index 24362eb..f321057 100644
--- a/drivers/staging/speakup/spkguide.txt
+++ b/drivers/staging/speakup/spkguide.txt
@@ -1091,7 +1091,7 @@ screen that is constantly changing, such as a clock or status line.
 
 There is no way to save these window settings, and you can only have one
 window defined for each virtual console.  There is also no way to have
-windows automaticly defined for specific applications.
+windows automatically defined for specific applications.
 
 In order to define a window, use the review keys to move your reading
 cursor to the beginning of the area you want to define.  Then press
diff --git a/drivers/staging/spectra/ffsport.c b/drivers/staging/spectra/ffsport.c
index 007b24b..20dae73 100644
--- a/drivers/staging/spectra/ffsport.c
+++ b/drivers/staging/spectra/ffsport.c
@@ -38,7 +38,7 @@
 * Outputs:      Number of Used Bits
 *               0, if the argument is 0
 * Description:  Calculate the number of bits used by a given power of 2 number
-*               Number can be upto 32 bit
+*               Number can be up to 32 bit
 *&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
 int GLOB_Calc_Used_Bits(u32 n)
 {
@@ -653,7 +653,7 @@ static int SBD_setup_device(struct spectra_nand_dev *dev, int which)
 	}
 	dev->queue->queuedata = dev;
 
-	/* As Linux block layer doens't support >4KB hardware sector,  */
+	/* As Linux block layer does't support >4KB hardware sector,  */
 	/* Here we force report 512 byte hardware sector size to Kernel */
 	blk_queue_logical_block_size(dev->queue, 512);
 
diff --git a/drivers/staging/spectra/flash.c b/drivers/staging/spectra/flash.c
index a2f8200..aead358 100644
--- a/drivers/staging/spectra/flash.c
+++ b/drivers/staging/spectra/flash.c
@@ -965,7 +965,7 @@ static void process_cmd_fail_abort(int *first_failed_cmd,
 	if (0 == *first_failed_cmd)
 		*first_failed_cmd = PendingCMD[idx].SBDCmdIndex;
 
-	nand_dbg_print(NAND_DBG_DEBUG, "Uncorrectable error has occured "
+	nand_dbg_print(NAND_DBG_DEBUG, "Uncorrectable error has occurred "
 		"while executing %u Command %u accesing Block %u\n",
 		(unsigned int)p_BTableChangesDelta->ftl_cmd_cnt,
 		PendingCMD[idx].CMD,
@@ -1879,7 +1879,7 @@ static int write_back_to_l2_cache(u8 *buf, u64 logical_addr)
 }
 
 /*
- * Seach in the Level2 Cache table to find the cache item.
+ * Search in the Level2 Cache table to find the cache item.
  * If find, read the data from the NAND page of L2 Cache,
  * Otherwise, return FAIL.
  */
@@ -3989,7 +3989,7 @@ int GLOB_FTL_Block_Erase(u64 blk_addr)
 * Inputs:       index to block that was just incremented and is at the max
 * Outputs:      PASS=0 / FAIL=1
 * Description:  If any erase counts at MAX, adjusts erase count of every
-*               block by substracting least worn
+*               block by subtracting least worn
 *               counter from counter value of every entry in wear table
 *&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&*/
 static int FTL_Adjust_Relative_Erase_Count(u32 Index_of_MAX)
diff --git a/drivers/staging/ste_rmi4/synaptics_i2c_rmi4.c b/drivers/staging/ste_rmi4/synaptics_i2c_rmi4.c
index d55a8e4..3e68d58 100644
--- a/drivers/staging/ste_rmi4/synaptics_i2c_rmi4.c
+++ b/drivers/staging/ste_rmi4/synaptics_i2c_rmi4.c
@@ -71,7 +71,7 @@
 #define SYNAPTICS_RMI4_DEVICE_CONTROL_FUNC_NUM	(0x01)
 
 /**
- * struct synaptics_rmi4_fn_desc - contains the funtion descriptor information
+ * struct synaptics_rmi4_fn_desc - contains the function descriptor information
  * @query_base_addr: base address for query
  * @cmd_base_addr: base address for command
  * @ctrl_base_addr: base address for control
@@ -92,7 +92,7 @@ struct synaptics_rmi4_fn_desc {
 };
 
 /**
- * struct synaptics_rmi4_fn - contains the funtion information
+ * struct synaptics_rmi4_fn - contains the function information
  * @fn_number: function number
  * @num_of_data_sources: number of data sources
  * @num_of_data_points: number of fingers touched
@@ -151,7 +151,7 @@ struct synaptics_rmi4_device_info {
  * @input_dev: pointer for input device
  * @i2c_client: pointer for i2c client
  * @board: constant pointer for touch platform data
- * @fn_list_mutex: mutex for funtion list
+ * @fn_list_mutex: mutex for function list
  * @rmi4_page_mutex: mutex for rmi4 page
  * @current_page: variable for integer
  * @number_of_interrupt_register: interrupt registers count
@@ -278,7 +278,7 @@ static int synaptics_rmi4_i2c_byte_write(struct synaptics_rmi4_data *pdata,
 	txbuf[0]	= address & MASK_8BIT;
 	txbuf[1]	= data;
 	retval		= i2c_master_send(pdata->i2c_client, txbuf, 2);
-	/* Add in retry on writes only in certian error return values */
+	/* Add in retry on writes only in certain error return values */
 	if (retval != 2) {
 		dev_err(&i2c->dev, "%s:failed:%d\n", __func__, retval);
 		retval = -EIO;
@@ -561,7 +561,7 @@ static int synpatics_rmi4_touchpad_detect(struct synaptics_rmi4_data *pdata,
 	}
 	/*
 	 * 2D data sources have only 3 bits for the number of fingers
-	 * supported - so the encoding is a bit wierd.
+	 * supported - so the encoding is a bit weird.
 	 */
 	if ((queries[1] & MASK_3BIT) <= 4)
 		/* add 1 since zero based */
@@ -1027,7 +1027,7 @@ err_input:
  * synaptics_rmi4_remove() - Removes the i2c-client touchscreen driver
  * @client: i2c client structure pointer
  *
- * This funtion uses to remove the i2c-client
+ * This function uses to remove the i2c-client
  * touchscreen driver and returns integer.
  */
 static int __devexit synaptics_rmi4_remove(struct i2c_client *client)
@@ -1053,7 +1053,7 @@ static int __devexit synaptics_rmi4_remove(struct i2c_client *client)
  * synaptics_rmi4_suspend() - suspend the touch screen controller
  * @dev: pointer to device structure
  *
- * This funtion is used to suspend the
+ * This function is used to suspend the
  * touch panel controller and returns integer
  */
 static int synaptics_rmi4_suspend(struct device *dev)
@@ -1089,7 +1089,7 @@ static int synaptics_rmi4_suspend(struct device *dev)
  * synaptics_rmi4_resume() - resume the touch screen controller
  * @dev: pointer to device structure
  *
- * This funtion is used to resume the touch panel
+ * This function is used to resume the touch panel
  * controller and returns integer.
  */
 static int synaptics_rmi4_resume(struct device *dev)
@@ -1148,7 +1148,7 @@ static struct i2c_driver synaptics_rmi4_driver = {
 /**
  * synaptics_rmi4_init() - Initialize the touchscreen driver
  *
- * This funtion uses to initializes the synaptics
+ * This function uses to initializes the synaptics
  * touchscreen driver and returns integer.
  */
 static int __init synaptics_rmi4_init(void)
@@ -1158,7 +1158,7 @@ static int __init synaptics_rmi4_init(void)
 /**
  * synaptics_rmi4_exit() - De-initialize the touchscreen driver
  *
- * This funtion uses to de-initialize the synaptics
+ * This function uses to de-initialize the synaptics
  * touchscreen driver and returns none.
  */
 static void __exit synaptics_rmi4_exit(void)
diff --git a/drivers/staging/tidspbridge/core/_tiomap.h b/drivers/staging/tidspbridge/core/_tiomap.h
index 1e0273e..7cb5871 100644
--- a/drivers/staging/tidspbridge/core/_tiomap.h
+++ b/drivers/staging/tidspbridge/core/_tiomap.h
@@ -366,7 +366,7 @@ extern s32 dsp_debug;
  *  ======== sm_interrupt_dsp ========
  *  Purpose:
  *      Set interrupt value & send an interrupt to the DSP processor(s).
- *      This is typicaly used when mailbox interrupt mechanisms allow data
+ *      This is typically used when mailbox interrupt mechanisms allow data
  *      to be associated with interrupt such as for OMAP's CMD/DATA regs.
  *  Parameters:
  *      dev_context:    Handle to Bridge driver defined device info.
diff --git a/drivers/staging/tidspbridge/core/chnl_sm.c b/drivers/staging/tidspbridge/core/chnl_sm.c
index 8381130..6d66e7d 100644
--- a/drivers/staging/tidspbridge/core/chnl_sm.c
+++ b/drivers/staging/tidspbridge/core/chnl_sm.c
@@ -578,7 +578,7 @@ int bridge_chnl_get_ioc(struct chnl_object *chnl_obj, u32 timeout,
 		} else if (stat_sync == -EPERM) {
 			/* This can occur when the user mode thread is
 			 * aborted (^C), or when _VWIN32_WaitSingleObject()
-			 * fails due to unkown causes. */
+			 * fails due to unknown causes. */
 			/* Even though Wait failed, there may be something in
 			 * the Q: */
 			if (list_empty(&pchnl->io_completions)) {
diff --git a/drivers/staging/tidspbridge/dynload/cload.c b/drivers/staging/tidspbridge/dynload/cload.c
index 3900409..5cecd23 100644
--- a/drivers/staging/tidspbridge/dynload/cload.c
+++ b/drivers/staging/tidspbridge/dynload/cload.c
@@ -718,7 +718,7 @@ static void dload_symbols(struct dload_state *dlthis)
 	 * as a temporary for .dllview record construction.
 	 * Allocate storage for the whole table.  Add 1 to the section count
 	 * in case a trampoline section is auto-generated as well as the
-	 * size of the trampoline section name so DLLView doens't get lost.
+	 * size of the trampoline section name so DLLView does't get lost.
 	 */
 
 	siz = sym_count * sizeof(struct local_symbol);
diff --git a/drivers/staging/tidspbridge/hw/hw_mmu.c b/drivers/staging/tidspbridge/hw/hw_mmu.c
index 014f5d5..c214df9 100644
--- a/drivers/staging/tidspbridge/hw/hw_mmu.c
+++ b/drivers/staging/tidspbridge/hw/hw_mmu.c
@@ -59,7 +59,7 @@ enum hw_mmu_page_size_t {
  * RETURNS:
  *
  *       Type		: hw_status
- *       Description     : 0		 -- No errors occured
+ *       Description     : 0		 -- No errors occurred
  *			 RET_BAD_NULL_PARAM     -- A Pointer
  *						Paramater was set to NULL
  *
@@ -102,7 +102,7 @@ static hw_status mmu_flush_entry(const void __iomem *base_address);
  * RETURNS:
  *
  *       Type	    	: hw_status
- *       Description     : 0		 -- No errors occured
+ *       Description     : 0		 -- No errors occurred
  *			 RET_BAD_NULL_PARAM     -- A Pointer Paramater
  *						   was set to NULL
  *			 RET_PARAM_OUT_OF_RANGE -- Input Parameter out
@@ -147,7 +147,7 @@ static hw_status mmu_set_cam_entry(const void __iomem *base_address,
  * RETURNS:
  *
  *       Type	    	: hw_status
- *       Description     : 0		 -- No errors occured
+ *       Description     : 0		 -- No errors occurred
  *			 RET_BAD_NULL_PARAM     -- A Pointer Paramater
  *							was set to NULL
  *			 RET_PARAM_OUT_OF_RANGE -- Input Parameter
diff --git a/drivers/staging/tidspbridge/include/dspbridge/_chnl_sm.h b/drivers/staging/tidspbridge/include/dspbridge/_chnl_sm.h
index d60e252..6e7ab4f 100644
--- a/drivers/staging/tidspbridge/include/dspbridge/_chnl_sm.h
+++ b/drivers/staging/tidspbridge/include/dspbridge/_chnl_sm.h
@@ -144,7 +144,7 @@ struct chnl_object {
 	s8 chnl_mode;		/* Chnl mode and attributes */
 	/* Chnl I/O completion event (user mode) */
 	void *user_event;
-	/* Abstract syncronization object */
+	/* Abstract synchronization object */
 	struct sync_object *sync_event;
 	u32 process;		/* Process which created this channel */
 	u32 cb_arg;		/* Argument to use with callback */
@@ -156,7 +156,7 @@ struct chnl_object {
 	struct list_head io_completions;
 	struct list_head free_packets_list;	/* List of free Irps */
 	struct ntfy_object *ntfy_obj;
-	u32 bytes_moved;	/* Total number of bytes transfered */
+	u32 bytes_moved;	/* Total number of bytes transferred */
 
 	/* For DSP-DMA */
 
diff --git a/drivers/staging/tidspbridge/include/dspbridge/clk.h b/drivers/staging/tidspbridge/include/dspbridge/clk.h
index b239503..685341c 100644
--- a/drivers/staging/tidspbridge/include/dspbridge/clk.h
+++ b/drivers/staging/tidspbridge/include/dspbridge/clk.h
@@ -55,7 +55,7 @@ extern void dsp_clk_exit(void);
  *      Initializes private state of CLK module.
  *  Parameters:
  *  Returns:
- *      TRUE if initialized; FALSE if error occured.
+ *      TRUE if initialized; FALSE if error occurred.
  *  Requires:
  *  Ensures:
  *      CLK initialized.
@@ -71,7 +71,7 @@ void dsp_gpt_wait_overflow(short int clk_id, unsigned int load);
  *  Parameters:
  *  Returns:
  *      0:	Success.
- *	-EPERM:	Error occured while enabling the clock.
+ *	-EPERM:	Error occurred while enabling the clock.
  *  Requires:
  *  Ensures:
  */
@@ -86,7 +86,7 @@ u32 dsp_clock_enable_all(u32 dsp_per_clocks);
  *  Parameters:
  *  Returns:
  *      0:        Success.
- *      -EPERM:      Error occured while disabling the clock.
+ *      -EPERM:      Error occurred while disabling the clock.
  *  Requires:
  *  Ensures:
  */
diff --git a/drivers/staging/tidspbridge/include/dspbridge/cmm.h b/drivers/staging/tidspbridge/include/dspbridge/cmm.h
index 27a21b5..aff2205 100644
--- a/drivers/staging/tidspbridge/include/dspbridge/cmm.h
+++ b/drivers/staging/tidspbridge/include/dspbridge/cmm.h
@@ -190,7 +190,7 @@ extern int cmm_get_info(struct cmm_object *hcmm_mgr,
  *      Initializes private state of CMM module.
  *  Parameters:
  *  Returns:
- *      TRUE if initialized; FALSE if error occured.
+ *      TRUE if initialized; FALSE if error occurred.
  *  Requires:
  *  Ensures:
  *      CMM initialized.
diff --git a/drivers/staging/tidspbridge/include/dspbridge/cod.h b/drivers/staging/tidspbridge/include/dspbridge/cod.h
index 53bd4bb..cb684c1 100644
--- a/drivers/staging/tidspbridge/include/dspbridge/cod.h
+++ b/drivers/staging/tidspbridge/include/dspbridge/cod.h
@@ -249,7 +249,7 @@ extern int cod_get_sym_value(struct cod_manager *cod_mgr_obj,
  *  Parameters:
  *      None.
  *  Returns:
- *      TRUE if initialized; FALSE if error occured.
+ *      TRUE if initialized; FALSE if error occurred.
  *  Requires:
  *  Ensures:
  *      A requirement for each of the other public COD functions.
diff --git a/drivers/staging/tidspbridge/include/dspbridge/dev.h b/drivers/staging/tidspbridge/include/dspbridge/dev.h
index f41e478..f92b4be 100644
--- a/drivers/staging/tidspbridge/include/dspbridge/dev.h
+++ b/drivers/staging/tidspbridge/include/dspbridge/dev.h
@@ -497,7 +497,7 @@ extern void dev_exit(void);
  *      Initialize DEV's private state, keeping a reference count on each call.
  *  Parameters:
  *  Returns:
- *      TRUE if initialized; FALSE if error occured.
+ *      TRUE if initialized; FALSE if error occurred.
  *  Requires:
  *  Ensures:
  *      TRUE: A requirement for the other public DEV functions.
diff --git a/drivers/staging/tidspbridge/include/dspbridge/drv.h b/drivers/staging/tidspbridge/include/dspbridge/drv.h
index 25ef1a2..9cdbd95 100644
--- a/drivers/staging/tidspbridge/include/dspbridge/drv.h
+++ b/drivers/staging/tidspbridge/include/dspbridge/drv.h
@@ -154,7 +154,7 @@ struct process_context {
  *  Parameters:
  *      drv_obj:        Location to store created DRV Object handle.
  *  Returns:
- *      0:        Sucess
+ *      0:        Success
  *      -ENOMEM:    Failed in Memory allocation
  *      -EPERM:      General Failure
  *  Requires:
@@ -170,7 +170,7 @@ struct process_context {
  *      There is one Driver Object for the Driver representing
  *      the driver itself. It contains the list of device
  *      Objects and the list of Device Extensions in the system.
- *      Also it can hold other neccessary
+ *      Also it can hold other necessary
  *      information in its storage area.
  */
 extern int drv_create(struct drv_object **drv_obj);
@@ -180,7 +180,7 @@ extern int drv_create(struct drv_object **drv_obj);
  *  Purpose:
  *      destroys the Dev Object list, DrvExt list
  *      and destroy the DRV object
- *      Called upon driver unLoading.or unsuccesful loading of the driver.
+ *      Called upon driver unLoading.or unsuccessful loading of the driver.
  *  Parameters:
  *      driver_obj:     Handle to Driver object .
  *  Returns:
diff --git a/drivers/staging/tidspbridge/include/dspbridge/dspdefs.h b/drivers/staging/tidspbridge/include/dspbridge/dspdefs.h
index c2ba26c..ed32bf3 100644
--- a/drivers/staging/tidspbridge/include/dspbridge/dspdefs.h
+++ b/drivers/staging/tidspbridge/include/dspbridge/dspdefs.h
@@ -52,7 +52,7 @@ struct bridge_dev_context;
  *      dev_ctxt:    Handle to Bridge driver defined device context.
  *  Returns:
  *      0:        Success.
- *      -ETIMEDOUT:  Timeout occured waiting for a response from hardware.
+ *      -ETIMEDOUT:  Timeout occurred waiting for a response from hardware.
  *      -EPERM:      Other, unspecified error.
  *  Requires:
  *      dev_ctxt != NULL
@@ -91,7 +91,7 @@ typedef int(*fxn_brd_setstate) (struct bridge_dev_context
  *      dsp_addr:       DSP address at which to start execution.
  *  Returns:
  *      0:        Success.
- *      -ETIMEDOUT:  Timeout occured waiting for a response from hardware.
+ *      -ETIMEDOUT:  Timeout occurred waiting for a response from hardware.
  *      -EPERM:      Other, unspecified error.
  *  Requires:
  *      dev_ctxt != NULL
@@ -142,7 +142,7 @@ typedef int(*fxn_brd_memcopy) (struct bridge_dev_context
  *      mem_type:       Memory space on DSP to which to transfer.
  *  Returns:
  *      0:        Success.
- *      -ETIMEDOUT:  Timeout occured waiting for a response from hardware.
+ *      -ETIMEDOUT:  Timeout occurred waiting for a response from hardware.
  *      -EPERM:      Other, unspecified error.
  *  Requires:
  *      dev_ctxt != NULL;
@@ -205,7 +205,7 @@ typedef int(*fxn_brd_memunmap) (struct bridge_dev_context
  *      dev_ctxt:    Handle to Bridge driver defined device context.
  *  Returns:
  *      0:        Success.
- *      -ETIMEDOUT:  Timeout occured waiting for a response from hardware.
+ *      -ETIMEDOUT:  Timeout occurred waiting for a response from hardware.
  *      -EPERM:      Other, unspecified error.
  *  Requires:
  *      dev_ctxt != NULL
@@ -248,7 +248,7 @@ typedef int(*fxn_brd_status) (struct bridge_dev_context *dev_ctxt,
  *      mem_type:       Memory space on DSP from which to transfer.
  *  Returns:
  *      0:        Success.
- *      -ETIMEDOUT:  Timeout occured waiting for a response from hardware.
+ *      -ETIMEDOUT:  Timeout occurred waiting for a response from hardware.
  *      -EPERM:      Other, unspecified error.
  *  Requires:
  *      dev_ctxt != NULL;
@@ -274,7 +274,7 @@ typedef int(*fxn_brd_read) (struct bridge_dev_context *dev_ctxt,
  *      mem_type:       Memory space on DSP to which to transfer.
  *  Returns:
  *      0:        Success.
- *      -ETIMEDOUT:  Timeout occured waiting for a response from hardware.
+ *      -ETIMEDOUT:  Timeout occurred waiting for a response from hardware.
  *      -EPERM:      Other, unspecified error.
  *  Requires:
  *      dev_ctxt != NULL;
@@ -601,7 +601,7 @@ typedef int(*fxn_chnl_getmgrinfo) (struct chnl_mgr
  *  Returns:
  *      0:            Success;
  *      -EFAULT:        Invalid chnl_obj.
- *      -ETIMEDOUT: Timeout occured before channel could be idled.
+ *      -ETIMEDOUT: Timeout occurred before channel could be idled.
  *  Requires:
  *  Ensures:
  */
diff --git a/drivers/staging/tidspbridge/include/dspbridge/mgr.h b/drivers/staging/tidspbridge/include/dspbridge/mgr.h
index e506c4d..47b0318 100644
--- a/drivers/staging/tidspbridge/include/dspbridge/mgr.h
+++ b/drivers/staging/tidspbridge/include/dspbridge/mgr.h
@@ -176,7 +176,7 @@ extern void mgr_exit(void);
  *      mgr_handle:     Handle to the Manager Object
  *      dcd_handle:     Ptr to receive the DCD Handle.
  *  Returns:
- *      0:        Sucess
+ *      0:        Success
  *      -EPERM:      Failure to get the Handle
  *  Requires:
  *      MGR is initialized.
@@ -195,7 +195,7 @@ extern int mgr_get_dcd_handle(struct mgr_object
  *      call. Initializes the DCD.
  *  Parameters:
  *  Returns:
- *      TRUE if initialized; FALSE if error occured.
+ *      TRUE if initialized; FALSE if error occurred.
  *  Requires:
  *  Ensures:
  *      TRUE: A requirement for the other public MGR functions.
diff --git a/drivers/staging/tidspbridge/include/dspbridge/node.h b/drivers/staging/tidspbridge/include/dspbridge/node.h
index 53da0ef..16371d8 100644
--- a/drivers/staging/tidspbridge/include/dspbridge/node.h
+++ b/drivers/staging/tidspbridge/include/dspbridge/node.h
@@ -44,7 +44,7 @@
  *      -ESPIPE:        iAlg functions not found for a DAIS node.
  *      -EDOM:         attr_in != NULL and attr_in->prio out of
  *                          range.
- *      -EPERM:          A failure occured, unable to allocate node.
+ *      -EPERM:          A failure occurred, unable to allocate node.
  *      -EBADR:    Proccessor is not in the running state.
  *  Requires:
  *      node_init(void) called.
diff --git a/drivers/staging/tidspbridge/include/dspbridge/proc.h b/drivers/staging/tidspbridge/include/dspbridge/proc.h
index 5e09fd1..f00dffd 100644
--- a/drivers/staging/tidspbridge/include/dspbridge/proc.h
+++ b/drivers/staging/tidspbridge/include/dspbridge/proc.h
@@ -89,7 +89,7 @@ extern int proc_auto_start(struct cfg_devnode *dev_node_obj,
  *  Returns:
  *      0     :       SUCCESS
  *      -EFAULT :       Invalid processor handle.
- *      -ETIME:       A Timeout Occured before the Control information
+ *      -ETIME:       A Timeout Occurred before the Control information
  *			  could be sent.
  *      -EPERM   :       General Failure.
  *  Requires:
@@ -169,7 +169,7 @@ extern int proc_enum_nodes(void *hprocessor,
  *      0     :       Success.
  *      -EFAULT :       Invalid processor handle.
  *      -EBADR:    The processor is not in the PROC_RUNNING state.
- *      -ETIME:       A timeout occured before the DSP responded to the
+ *      -ETIME:       A timeout occurred before the DSP responded to the
  *			  querry.
  *      -EPERM   :       Unable to get Resource Information
  *  Requires:
@@ -229,7 +229,7 @@ extern int proc_get_dev_object(void *hprocessor,
  *      call.
  *  Parameters:
  *  Returns:
- *      TRUE if initialized; FALSE if error occured.
+ *      TRUE if initialized; FALSE if error occurred.
  *  Requires:
  *  Ensures:
  *      TRUE: A requirement for the other public PROC functions.
diff --git a/drivers/staging/tidspbridge/include/dspbridge/pwr.h b/drivers/staging/tidspbridge/include/dspbridge/pwr.h
index 5e3ab21..0fb0664 100644
--- a/drivers/staging/tidspbridge/include/dspbridge/pwr.h
+++ b/drivers/staging/tidspbridge/include/dspbridge/pwr.h
@@ -46,7 +46,7 @@
  *      0:            Success.
  *      0: Success, but the DSP was already asleep.
  *      -EINVAL:    The specified sleep_code is not supported.
- *      -ETIME:       A timeout occured while waiting for DSP sleep
+ *      -ETIME:       A timeout occurred while waiting for DSP sleep
  *                          confirmation.
  *      -EPERM:          General failure, unable to send sleep command to
  *                          the DSP.
@@ -67,7 +67,7 @@ extern int pwr_sleep_dsp(const u32 sleep_code, const u32 timeout);
  *  Returns:
  *      0:            Success.
  *      0:  Success, but the DSP was already awake.
- *      -ETIME:       A timeout occured while waiting for wake
+ *      -ETIME:       A timeout occurred while waiting for wake
  *                          confirmation.
  *      -EPERM:          General failure, unable to send wake command to
  *                          the DSP.
@@ -85,7 +85,7 @@ extern int pwr_wake_dsp(const u32 timeout);
  *  Returns:
  *      0:            Success.
  *      0:  Success, but the DSP was already awake.
- *      -ETIME:       A timeout occured while waiting for wake
+ *      -ETIME:       A timeout occurred while waiting for wake
  *                          confirmation.
  *      -EPERM:          General failure, unable to send wake command to
  *                          the DSP.
@@ -103,7 +103,7 @@ extern int pwr_pm_pre_scale(u16 voltage_domain, u32 level);
  *  Returns:
  *      0:            Success.
  *      0:  Success, but the DSP was already awake.
- *      -ETIME:       A timeout occured while waiting for wake
+ *      -ETIME:       A timeout occurred while waiting for wake
  *                          confirmation.
  *      -EPERM:          General failure, unable to send wake command to
  *                          the DSP.
diff --git a/drivers/staging/tidspbridge/pmgr/dev.c b/drivers/staging/tidspbridge/pmgr/dev.c
index 9a38d86..522810b 100644
--- a/drivers/staging/tidspbridge/pmgr/dev.c
+++ b/drivers/staging/tidspbridge/pmgr/dev.c
@@ -787,7 +787,7 @@ int dev_notify_clients(struct dev_object *dev_obj, u32 ret)
 
 	/*
 	 * FIXME: this code needs struct proc_object to have a list_head
-	 * at the begining. If not, this can go horribly wrong.
+	 * at the beginning. If not, this can go horribly wrong.
 	 */
 	list_for_each(curr, &dev_obj->proc_list)
 		proc_notify_clients((void *)curr, ret);
@@ -810,7 +810,7 @@ int dev_remove_device(struct cfg_devnode *dev_node_obj)
 	if (!dev_node_obj)
 		status = -EFAULT;
 
-	/* Retrieve the device object handle originaly stored with
+	/* Retrieve the device object handle originally stored with
 	 * the dev_node: */
 	if (!status) {
 		/* check the device string and then store dev object */
@@ -986,7 +986,7 @@ int dev_insert_proc_object(struct dev_object *hdev_obj,
 	/* Add DevObject to tail. */
 	/*
 	 * FIXME: this code needs struct proc_object to have a list_head
-	 * at the begining. If not, this can go horribly wrong.
+	 * at the beginning. If not, this can go horribly wrong.
 	 */
 	list_add_tail((struct list_head *)proc_obj, &dev_obj->proc_list);
 
diff --git a/drivers/staging/tidspbridge/rmgr/drv.c b/drivers/staging/tidspbridge/rmgr/drv.c
index 8c88583..db8215f 100644
--- a/drivers/staging/tidspbridge/rmgr/drv.c
+++ b/drivers/staging/tidspbridge/rmgr/drv.c
@@ -609,7 +609,7 @@ int drv_request_resources(u32 dw_context, u32 *dev_node_strg)
 	DBC_REQUIRE(dev_node_strg != NULL);
 
 	/*
-	 *  Allocate memory to hold the string. This will live untill
+	 *  Allocate memory to hold the string. This will live until
 	 *  it is freed in the Release resources. Update the driver object
 	 *  list.
 	 */
diff --git a/drivers/staging/tidspbridge/rmgr/nldr.c b/drivers/staging/tidspbridge/rmgr/nldr.c
index fb5c2ba..0e70cba 100644
--- a/drivers/staging/tidspbridge/rmgr/nldr.c
+++ b/drivers/staging/tidspbridge/rmgr/nldr.c
@@ -57,9 +57,9 @@
  *   uuuuuuuu|fueeeeee|fudddddd|fucccccc|
  *  where
  *      u = unused
- *      cccccc = prefered/required dynamic mem segid for create phase data/code
- *      dddddd = prefered/required dynamic mem segid for delete phase data/code
- *      eeeeee = prefered/req. dynamic mem segid for execute phase data/code
+ *      cccccc = preferred/required dynamic mem segid for create phase data/code
+ *      dddddd = preferred/required dynamic mem segid for delete phase data/code
+ *      eeeeee = preferred/req. dynamic mem segid for execute phase data/code
  *      f = flag indicating if memory is preferred or required:
  *	  f = 1 if required, f = 0 if preferred.
  *
diff --git a/drivers/staging/tidspbridge/rmgr/proc.c b/drivers/staging/tidspbridge/rmgr/proc.c
index c4e5c4e..242dd13 100644
--- a/drivers/staging/tidspbridge/rmgr/proc.c
+++ b/drivers/staging/tidspbridge/rmgr/proc.c
@@ -1670,7 +1670,7 @@ int proc_stop(void *hprocessor)
 	if (!status) {
 		dev_dbg(bridge, "%s: processor in standby mode\n", __func__);
 		p_proc_object->proc_state = PROC_STOPPED;
-		/* Destory the Node Manager, msg_ctrl Manager */
+		/* Destroy the Node Manager, msg_ctrl Manager */
 		if (!(dev_destroy2(p_proc_object->dev_obj))) {
 			/* Destroy the msg_ctrl by calling msg_delete */
 			dev_get_msg_mgr(p_proc_object->dev_obj, &hmsg_mgr);
@@ -1827,7 +1827,7 @@ static int proc_monitor(struct proc_object *proc_obj)
 
 	/* This is needed only when Device is loaded when it is
 	 * already 'ACTIVE' */
-	/* Destory the Node Manager, msg_ctrl Manager */
+	/* Destroy the Node Manager, msg_ctrl Manager */
 	if (!dev_destroy2(proc_obj->dev_obj)) {
 		/* Destroy the msg_ctrl by calling msg_delete */
 		dev_get_msg_mgr(proc_obj->dev_obj, &hmsg_mgr);
diff --git a/drivers/staging/tm6000/tm6000-video.c b/drivers/staging/tm6000/tm6000-video.c
index c80a316..17db668 100644
--- a/drivers/staging/tm6000/tm6000-video.c
+++ b/drivers/staging/tm6000/tm6000-video.c
@@ -182,7 +182,7 @@ static inline void get_next_buf(struct tm6000_dmaqueue *dma_q,
 	if (!buf)
 		return;
 
-	/* Cleans up buffer - Usefull for testing for frame/URB loss */
+	/* Cleans up buffer - Useful for testing for frame/URB loss */
 	outp = videobuf_to_vmalloc(&(*buf)->vb);
 
 	return;
diff --git a/drivers/staging/tty/cd1865.h b/drivers/staging/tty/cd1865.h
index 9940966..8c2ad65 100644
--- a/drivers/staging/tty/cd1865.h
+++ b/drivers/staging/tty/cd1865.h
@@ -9,7 +9,7 @@
  *      Please DO contact io8-linux@specialix.co.uk if you require
  *      support.
  *
- *      This driver was developped in the BitWizard linux device
+ *      This driver was developed in the BitWizard linux device
  *      driver service. If you require a linux device driver for your
  *      product, please contact devices@BitWizard.nl for a quote.
  *
diff --git a/drivers/staging/tty/epca.c b/drivers/staging/tty/epca.c
index 7ad3638..7f1369e 100644
--- a/drivers/staging/tty/epca.c
+++ b/drivers/staging/tty/epca.c
@@ -7,7 +7,7 @@
 	** This driver is no longer supported by Digi **
 
 	Much of this design and code came from epca.c which was
-	copyright (C) 1994, 1995 Troy De Jongh, and subsquently
+	copyright (C) 1994, 1995 Troy De Jongh, and subsequently
 	modified by David Nugent, Christoph Lameter, Mike McLagan.
 
 	This program is free software; you can redistribute it and/or modify
@@ -471,7 +471,7 @@ static void shutdown(struct channel *ch, struct tty_struct *tty)
 	memoff(ch);
 
 	/*
-	 * The channel has officialy been closed. The next time it is opened it
+	 * The channel has officially been closed. The next time it is opened it
 	 * will have to reinitialized. Set a flag to indicate this.
 	 */
 	/* Prevent future Digi programmed interrupts from coming active */
@@ -975,7 +975,7 @@ static int __init pc_init(void)
 
 	/*
 	 * Note : If lilo was used to configure the driver and the ignore
-	 * epcaconfig option was choosen (digiepca=2) then nbdevs and num_cards
+	 * epcaconfig option was chosen (digiepca=2) then nbdevs and num_cards
 	 * will equal 0 at this point. This is okay; PCI cards will still be
 	 * picked up if detected.
 	 */
@@ -1230,14 +1230,14 @@ static void post_fep_init(unsigned int crd)
 	memaddr = bd->re_map_membase;
 
 	/*
-	 * The below assignment will set bc to point at the BEGINING of the
+	 * The below assignment will set bc to point at the BEGINNING of the
 	 * cards channel structures. For 1 card there will be between 8 and 64
 	 * of these structures.
 	 */
 	bc = memaddr + CHANSTRUCT;
 
 	/*
-	 * The below assignment will set gd to point at the BEGINING of global
+	 * The below assignment will set gd to point at the BEGINNING of global
 	 * memory address 0xc00. The first data in that global memory actually
 	 * starts at address 0xc1a. The command in pointer begins at 0xd10.
 	 */
@@ -1492,7 +1492,7 @@ static void doevent(int crd)
 		/*
 		 * The two assignments below get the current modem status
 		 * (mstat) and the previous modem status (lstat). These are
-		 * useful becuase an event could signal a change in modem
+		 * useful because an event could signal a change in modem
 		 * signals itself.
 		 */
 		mstat = readb(eventbuf + 2);
@@ -1897,7 +1897,7 @@ static void receive_data(struct channel *ch, struct tty_struct *tty)
 		/*
 		 * Even if head has wrapped around only report the amount of
 		 * data to be equal to the size - tail. Remember memcpy can't
-		 * automaticly wrap around the receive buffer.
+		 * automatically wrap around the receive buffer.
 		 */
 		dataToRead = (wrapgap < bytesAvailable) ? wrapgap
 							: bytesAvailable;
@@ -2543,7 +2543,7 @@ static void __init epca_setup(char *str, int *ints)
 					break;
 			/*
 			 * If the index incremented above refers to a
-			 * legitamate board type set it here.
+			 * legitimate board type set it here.
 			 */
 			if (index < EPCA_NUM_TYPES)
 				board.type = loop;
diff --git a/drivers/staging/tty/ip2/i2hw.h b/drivers/staging/tty/ip2/i2hw.h
index c0ba6c0..8df2f48 100644
--- a/drivers/staging/tty/ip2/i2hw.h
+++ b/drivers/staging/tty/ip2/i2hw.h
@@ -335,7 +335,7 @@ be off by a factor of five. The important point is that the first command reset
 in fact generates a reset pulse on the board. This pulse is guaranteed to last
 less than 10 milliseconds. The additional delay ensures the 1400 has had the
 chance to respond sufficiently to the first reset. Why not a longer delay? Much
-more than 50 milliseconds gets to be noticable, but the board would still work.
+more than 50 milliseconds gets to be noticeable, but the board would still work.
 
 Once all 16 bytes of the Power-on Reset Message have been read, the bootstrap
 firmware is ready to receive loadware.
@@ -399,7 +399,7 @@ typedef union _porStr		// "por" stands for Power On Reset
 		// expandable products must report a MAP of available channels. Since 
 		// each UART supports four ports, we represent each UART found by a
 		// single bit. Using two bytes to supply the mapping information we
-		// report the presense or absense of up to 16 UARTS, or 64 ports in
+		// report the presence or absence of up to 16 UARTS, or 64 ports in
 		// steps of 4 ports. For -IIEX products, the ports are numbered
 		// starting at the box closest to the controller in the "chain".
 
diff --git a/drivers/staging/tty/ip2/i2lib.c b/drivers/staging/tty/ip2/i2lib.c
index 0d10b89..13a3cab 100644
--- a/drivers/staging/tty/ip2/i2lib.c
+++ b/drivers/staging/tty/ip2/i2lib.c
@@ -821,7 +821,7 @@ i2GetStatus(i2ChanStrPtr pCh, int resetBits)
 //
 // Description:
 // Strips data from the input buffer and writes it to pDest. If there is a
-// collosal blunder, (invalid structure pointers or the like), returns -1.
+// colossal blunder, (invalid structure pointers or the like), returns -1.
 // Otherwise, returns the number of bytes read.
 //******************************************************************************
 static int
@@ -909,7 +909,7 @@ i2Input_exit:
 // Returns:    Number of bytes stripped, or -1 for error
 //
 // Description:
-// Strips any data from the input buffer. If there is a collosal blunder,
+// Strips any data from the input buffer. If there is a colossal blunder,
 // (invalid structure pointers or the like), returns -1. Otherwise, returns the
 // number of bytes stripped.
 //******************************************************************************
@@ -963,7 +963,7 @@ i2InputFlush(i2ChanStrPtr pCh)
 // Returns:    Number of bytes available, or -1 for error
 //
 // Description:
-// If there is a collosal blunder, (invalid structure pointers or the like),
+// If there is a colossal blunder, (invalid structure pointers or the like),
 // returns -1. Otherwise, returns the number of bytes stripped. Otherwise,
 // returns the number of bytes available in the buffer.
 //******************************************************************************
@@ -1001,7 +1001,7 @@ i2InputAvailable(i2ChanStrPtr pCh)
 //
 // Description:
 // Queues the data at pSource to be sent as data packets to the board. If there
-// is a collosal blunder, (invalid structure pointers or the like), returns -1.
+// is a colossal blunder, (invalid structure pointers or the like), returns -1.
 // Otherwise, returns the number of bytes written. What if there is not enough
 // room for all the data? If pCh->channelOptions & CO_NBLOCK_WRITE is set, then
 // we transfer as many characters as we can now, then return. If this bit is
diff --git a/drivers/staging/tty/ip2/ip2main.c b/drivers/staging/tty/ip2/ip2main.c
index ea7a8fb..ba074fb 100644
--- a/drivers/staging/tty/ip2/ip2main.c
+++ b/drivers/staging/tty/ip2/ip2main.c
@@ -1824,7 +1824,7 @@ ip2_flush_chars( PTTY tty )
 //		ip2trace (CHANN, ITRC_PUTC, 10, 1, strip );
 
 		//
-		// We may need to restart i2Output if it does not fullfill this request
+		// We may need to restart i2Output if it does not fulfill this request
 		//
 		strip = i2Output( pCh, pCh->Pbuf, pCh->Pbuf_stuff);
 		if ( strip != pCh->Pbuf_stuff ) {
diff --git a/drivers/staging/tty/specialix.c b/drivers/staging/tty/specialix.c
index 17a1be5..cb24c6d 100644
--- a/drivers/staging/tty/specialix.c
+++ b/drivers/staging/tty/specialix.c
@@ -9,7 +9,7 @@
  *      support. But please read the documentation (specialix.txt)
  *      first.
  *
- *      This driver was developped in the BitWizard linux device
+ *      This driver was developed in the BitWizard linux device
  *      driver service. If you require a linux device driver for your
  *      product, please contact devices@BitWizard.nl for a quote.
  *
@@ -978,7 +978,7 @@ static void sx_change_speed(struct specialix_board *bp,
 	spin_lock_irqsave(&bp->lock, flags);
 	sx_out(bp, CD186x_CAR, port_No(port));
 
-	/* The Specialix board doens't implement the RTS lines.
+	/* The Specialix board does't implement the RTS lines.
 	   They are used to set the IRQ level. Don't touch them. */
 	if (sx_crtscts(tty))
 		port->MSVR = MSVR_DTR | (sx_in(bp, CD186x_MSVR) & MSVR_RTS);
diff --git a/drivers/staging/tty/specialix_io8.h b/drivers/staging/tty/specialix_io8.h
index c630052..1215d7e 100644
--- a/drivers/staging/tty/specialix_io8.h
+++ b/drivers/staging/tty/specialix_io8.h
@@ -10,7 +10,7 @@
  *      Please DO contact io8-linux@specialix.co.uk if you require
  *      support.
  *
- *      This driver was developped in the BitWizard linux device
+ *      This driver was developed in the BitWizard linux device
  *      driver service. If you require a linux device driver for your
  *      product, please contact devices@BitWizard.nl for a quote.
  *
@@ -79,7 +79,7 @@ more than a few  PCI versions of the card. */
 
 #define SPECIALIX_MAGIC		0x0907
 
-#define SX_CCR_TIMEOUT 10000   /* CCR timeout. You may need to wait upto
+#define SX_CCR_TIMEOUT 10000   /* CCR timeout. You may need to wait up to
                                   10 milliseconds before the internal
                                   processor is available again after
                                   you give it a command */
diff --git a/drivers/staging/usbip/stub_dev.c b/drivers/staging/usbip/stub_dev.c
index 8214c35..bce7d03 100644
--- a/drivers/staging/usbip/stub_dev.c
+++ b/drivers/staging/usbip/stub_dev.c
@@ -220,8 +220,10 @@ static void stub_shutdown_connection(struct usbip_device *ud)
 	}
 
 	/* 1. stop threads */
-	kthread_stop(ud->tcp_rx);
-	kthread_stop(ud->tcp_tx);
+	if (ud->tcp_rx && !task_is_dead(ud->tcp_rx))
+		kthread_stop(ud->tcp_rx);
+	if (ud->tcp_tx && !task_is_dead(ud->tcp_tx))
+		kthread_stop(ud->tcp_tx);
 
 	/* 2. close the socket */
 	/*
diff --git a/drivers/staging/usbip/stub_rx.c b/drivers/staging/usbip/stub_rx.c
index 6445f12..51fbd09 100644
--- a/drivers/staging/usbip/stub_rx.c
+++ b/drivers/staging/usbip/stub_rx.c
@@ -171,33 +171,23 @@ static int tweak_set_configuration_cmd(struct urb *urb)
 
 static int tweak_reset_device_cmd(struct urb *urb)
 {
-	struct usb_ctrlrequest *req;
-	__u16 value;
-	__u16 index;
-	int ret;
-
-	req = (struct usb_ctrlrequest *) urb->setup_packet;
-	value = le16_to_cpu(req->wValue);
-	index = le16_to_cpu(req->wIndex);
-
-	usbip_uinfo("reset_device (port %d) to %s\n", index,
-						dev_name(&urb->dev->dev));
+	struct stub_priv *priv = (struct stub_priv *) urb->context;
+	struct stub_device *sdev = priv->sdev;
 
-	/* all interfaces should be owned by usbip driver, so just reset it.  */
-	ret = usb_lock_device_for_reset(urb->dev, NULL);
-	if (ret < 0) {
-		dev_err(&urb->dev->dev, "lock for reset\n");
-		return ret;
-	}
-
-	/* try to reset the device */
-	ret = usb_reset_device(urb->dev);
-	if (ret < 0)
-		dev_err(&urb->dev->dev, "device reset\n");
+	usbip_uinfo("reset_device %s\n", dev_name(&urb->dev->dev));
 
-	usb_unlock_device(urb->dev);
-
-	return ret;
+	/*
+	 * usb_lock_device_for_reset caused a deadlock: it causes the driver
+	 * to unbind. In the shutdown the rx thread is signalled to shut down
+	 * but this thread is pending in the usb_lock_device_for_reset.
+	 *
+	 * Instead queue the reset.
+	 *
+	 * Unfortunatly an existing usbip connection will be dropped due to
+	 * driver unbinding.
+	 */
+	usb_queue_reset_device(sdev->interface);
+	return 0;
 }
 
 /*
diff --git a/drivers/staging/usbip/stub_tx.c b/drivers/staging/usbip/stub_tx.c
index 5523f25..64a52b2 100644
--- a/drivers/staging/usbip/stub_tx.c
+++ b/drivers/staging/usbip/stub_tx.c
@@ -170,7 +170,6 @@ static int stub_send_ret_submit(struct stub_device *sdev)
 	struct stub_priv *priv, *tmp;
 
 	struct msghdr msg;
-	struct kvec iov[3];
 	size_t txsize;
 
 	size_t total_size = 0;
@@ -180,28 +179,73 @@ static int stub_send_ret_submit(struct stub_device *sdev)
 		struct urb *urb = priv->urb;
 		struct usbip_header pdu_header;
 		void *iso_buffer = NULL;
+		struct kvec *iov = NULL;
+		int iovnum = 0;
 
 		txsize = 0;
 		memset(&pdu_header, 0, sizeof(pdu_header));
 		memset(&msg, 0, sizeof(msg));
-		memset(&iov, 0, sizeof(iov));
 
-		usbip_dbg_stub_tx("setup txdata urb %p\n", urb);
+		if (usb_pipetype(urb->pipe) == PIPE_ISOCHRONOUS)
+			iovnum = 2 + urb->number_of_packets;
+		else
+			iovnum = 2;
+
+		iov = kzalloc(iovnum * sizeof(struct kvec), GFP_KERNEL);
 
+		if (!iov) {
+			usbip_event_add(&sdev->ud, SDEV_EVENT_ERROR_MALLOC);
+			return -1;
+		}
+
+		iovnum = 0;
 
 		/* 1. setup usbip_header */
 		setup_ret_submit_pdu(&pdu_header, urb);
+		usbip_dbg_stub_tx("setup txdata seqnum: %d urb: %p\n",
+						pdu_header.base.seqnum, urb);
+		/*usbip_dump_header(pdu_header);*/
 		usbip_header_correct_endian(&pdu_header, 1);
 
-		iov[0].iov_base = &pdu_header;
-		iov[0].iov_len  = sizeof(pdu_header);
+		iov[iovnum].iov_base = &pdu_header;
+		iov[iovnum].iov_len  = sizeof(pdu_header);
+		iovnum++;
 		txsize += sizeof(pdu_header);
 
 		/* 2. setup transfer buffer */
-		if (usb_pipein(urb->pipe) && urb->actual_length > 0) {
-			iov[1].iov_base = urb->transfer_buffer;
-			iov[1].iov_len  = urb->actual_length;
+		if (usb_pipein(urb->pipe) &&
+				usb_pipetype(urb->pipe) != PIPE_ISOCHRONOUS &&
+					urb->actual_length > 0) {
+			iov[iovnum].iov_base = urb->transfer_buffer;
+			iov[iovnum].iov_len  = urb->actual_length;
+			iovnum++;
 			txsize += urb->actual_length;
+		} else if (usb_pipein(urb->pipe) &&
+				usb_pipetype(urb->pipe) == PIPE_ISOCHRONOUS) {
+			/*
+			 * For isochronous packets: actual length is the sum of
+			 * the actual length of the individual, packets, but as
+			 * the packet offsets are not changed there will be
+			 * padding between the packets. To optimally use the
+			 * bandwidth the padding is not transmitted.
+			 */
+
+			int i;
+			for (i = 0; i < urb->number_of_packets; i++) {
+				iov[iovnum].iov_base = urb->transfer_buffer + urb->iso_frame_desc[i].offset;
+				iov[iovnum].iov_len = urb->iso_frame_desc[i].actual_length;
+				iovnum++;
+				txsize += urb->iso_frame_desc[i].actual_length;
+			}
+
+			if (txsize != sizeof(pdu_header) + urb->actual_length) {
+				dev_err(&sdev->interface->dev,
+					"actual length of urb (%d) does not match iso packet sizes (%d)\n",
+					urb->actual_length, txsize-sizeof(pdu_header));
+				kfree(iov);
+				usbip_event_add(&sdev->ud, SDEV_EVENT_ERROR_TCP);
+			   return -1;
+			}
 		}
 
 		/* 3. setup iso_packet_descriptor */
@@ -212,32 +256,34 @@ static int stub_send_ret_submit(struct stub_device *sdev)
 			if (!iso_buffer) {
 				usbip_event_add(&sdev->ud,
 						SDEV_EVENT_ERROR_MALLOC);
+				kfree(iov);
 				return -1;
 			}
 
-			iov[2].iov_base = iso_buffer;
-			iov[2].iov_len  = len;
+			iov[iovnum].iov_base = iso_buffer;
+			iov[iovnum].iov_len  = len;
 			txsize += len;
+			iovnum++;
 		}
 
-		ret = kernel_sendmsg(sdev->ud.tcp_socket, &msg, iov,
-				     3, txsize);
+		ret = kernel_sendmsg(sdev->ud.tcp_socket, &msg,
+						iov,  iovnum, txsize);
 		if (ret != txsize) {
 			dev_err(&sdev->interface->dev,
 				"sendmsg failed!, retval %d for %zd\n",
 				ret, txsize);
+			kfree(iov);
 			kfree(iso_buffer);
 			usbip_event_add(&sdev->ud, SDEV_EVENT_ERROR_TCP);
 			return -1;
 		}
 
+		kfree(iov);
 		kfree(iso_buffer);
-		usbip_dbg_stub_tx("send txdata\n");
 
 		total_size += txsize;
 	}
 
-
 	spin_lock_irqsave(&sdev->priv_lock, flags);
 
 	list_for_each_entry_safe(priv, tmp, &sdev->priv_free, list) {
diff --git a/drivers/staging/usbip/usbip_common.c b/drivers/staging/usbip/usbip_common.c
index 337abc4..7b1fe45 100644
--- a/drivers/staging/usbip/usbip_common.c
+++ b/drivers/staging/usbip/usbip_common.c
@@ -333,10 +333,11 @@ void usbip_dump_header(struct usbip_header *pdu)
 		usbip_udbg("CMD_UNLINK: seq %u\n", pdu->u.cmd_unlink.seqnum);
 		break;
 	case USBIP_RET_SUBMIT:
-		usbip_udbg("RET_SUBMIT: st %d al %u sf %d ec %d\n",
+		usbip_udbg("RET_SUBMIT: st %d al %u sf %d #p %d ec %d\n",
 				pdu->u.ret_submit.status,
 				pdu->u.ret_submit.actual_length,
 				pdu->u.ret_submit.start_frame,
+				pdu->u.ret_submit.number_of_packets,
 				pdu->u.ret_submit.error_count);
 	case USBIP_RET_UNLINK:
 		usbip_udbg("RET_UNLINK: status %d\n", pdu->u.ret_unlink.status);
@@ -520,6 +521,7 @@ static void usbip_pack_ret_submit(struct usbip_header *pdu, struct urb *urb,
 		rpdu->status		= urb->status;
 		rpdu->actual_length	= urb->actual_length;
 		rpdu->start_frame	= urb->start_frame;
+		rpdu->number_of_packets = urb->number_of_packets;
 		rpdu->error_count	= urb->error_count;
 	} else {
 		/* vhci_rx.c */
@@ -527,6 +529,7 @@ static void usbip_pack_ret_submit(struct usbip_header *pdu, struct urb *urb,
 		urb->status		= rpdu->status;
 		urb->actual_length	= rpdu->actual_length;
 		urb->start_frame	= rpdu->start_frame;
+		urb->number_of_packets = rpdu->number_of_packets;
 		urb->error_count	= rpdu->error_count;
 	}
 }
@@ -595,11 +598,13 @@ static void correct_endian_ret_submit(struct usbip_header_ret_submit *pdu,
 		cpu_to_be32s(&pdu->status);
 		cpu_to_be32s(&pdu->actual_length);
 		cpu_to_be32s(&pdu->start_frame);
+		cpu_to_be32s(&pdu->number_of_packets);
 		cpu_to_be32s(&pdu->error_count);
 	} else {
 		be32_to_cpus(&pdu->status);
 		be32_to_cpus(&pdu->actual_length);
 		be32_to_cpus(&pdu->start_frame);
+		cpu_to_be32s(&pdu->number_of_packets);
 		be32_to_cpus(&pdu->error_count);
 	}
 }
@@ -725,6 +730,7 @@ int usbip_recv_iso(struct usbip_device *ud, struct urb *urb)
 	int size = np * sizeof(*iso);
 	int i;
 	int ret;
+	int total_length = 0;
 
 	if (!usb_pipeisoc(urb->pipe))
 		return 0;
@@ -754,19 +760,75 @@ int usbip_recv_iso(struct usbip_device *ud, struct urb *urb)
 		return -EPIPE;
 	}
 
+
 	for (i = 0; i < np; i++) {
 		iso = buff + (i * sizeof(*iso));
 
 		usbip_iso_pakcet_correct_endian(iso, 0);
 		usbip_pack_iso(iso, &urb->iso_frame_desc[i], 0);
+		total_length += urb->iso_frame_desc[i].actual_length;
 	}
 
 	kfree(buff);
 
+	if (total_length != urb->actual_length) {
+		dev_err(&urb->dev->dev,
+		  "total length of iso packets (%d) not equal to actual length of buffer (%d)\n",
+		  total_length, urb->actual_length);
+
+		if (ud->side == USBIP_STUB)
+			usbip_event_add(ud, SDEV_EVENT_ERROR_TCP);
+		else
+			usbip_event_add(ud, VDEV_EVENT_ERROR_TCP);
+
+		return -EPIPE;
+	}
+
 	return ret;
 }
 EXPORT_SYMBOL_GPL(usbip_recv_iso);
 
+/*
+ * This functions restores the padding which was removed for optimizing
+ * the bandwidth during transfer over tcp/ip
+ *
+ * buffer and iso packets need to be stored and be in propeper endian in urb
+ * before calling this function
+ */
+int usbip_pad_iso(struct usbip_device *ud, struct urb *urb)
+{
+	int np = urb->number_of_packets;
+	int i;
+	int ret;
+	int actualoffset = urb->actual_length;
+
+	if (!usb_pipeisoc(urb->pipe))
+		return 0;
+
+	/* if no packets or length of data is 0, then nothing to unpack */
+	if (np == 0 || urb->actual_length == 0)
+		return 0;
+
+	/*
+	 * if actual_length is transfer_buffer_length then no padding is
+	 * present.
+	*/
+	if (urb->actual_length == urb->transfer_buffer_length)
+		return 0;
+
+	/*
+	 * loop over all packets from last to first (to prevent overwritting
+	 * memory when padding) and move them into the proper place
+	 */
+	for (i = np-1; i > 0; i--) {
+		actualoffset -= urb->iso_frame_desc[i].actual_length;
+		memmove(urb->transfer_buffer + urb->iso_frame_desc[i].offset,
+				  urb->transfer_buffer + actualoffset,
+				  urb->iso_frame_desc[i].actual_length);
+	}
+	return ret;
+}
+EXPORT_SYMBOL_GPL(usbip_pad_iso);
 
 /* some members of urb must be substituted before. */
 int usbip_recv_xbuff(struct usbip_device *ud, struct urb *urb)
diff --git a/drivers/staging/usbip/usbip_common.h b/drivers/staging/usbip/usbip_common.h
index 9f809c3..c767f52 100644
--- a/drivers/staging/usbip/usbip_common.h
+++ b/drivers/staging/usbip/usbip_common.h
@@ -379,6 +379,8 @@ void usbip_header_correct_endian(struct usbip_header *pdu, int send);
 int usbip_recv_xbuff(struct usbip_device *ud, struct urb *urb);
 /* some members of urb must be substituted before. */
 int usbip_recv_iso(struct usbip_device *ud, struct urb *urb);
+/* some members of urb must be substituted before. */
+int usbip_pad_iso(struct usbip_device *ud, struct urb *urb);
 void *usbip_alloc_iso_desc_pdu(struct urb *urb, ssize_t *bufflen);
 
 
diff --git a/drivers/staging/usbip/vhci_hcd.c b/drivers/staging/usbip/vhci_hcd.c
index e234849..0f02a4b 100644
--- a/drivers/staging/usbip/vhci_hcd.c
+++ b/drivers/staging/usbip/vhci_hcd.c
@@ -194,7 +194,7 @@ void rh_port_disconnect(int rhport)
  *
  * So, the maximum number of ports is 31 ( port 0 to port 30) ?
  *
- * The return value is the actual transfered length in byte. If nothing has
+ * The return value is the actual transferred length in byte. If nothing has
  * been changed, return 0. In the case that the number of ports is less than or
  * equal to 6 (VHCI_NPORTS==7), return 1.
  *
diff --git a/drivers/staging/usbip/vhci_rx.c b/drivers/staging/usbip/vhci_rx.c
index 09bf235..2ffc96a 100644
--- a/drivers/staging/usbip/vhci_rx.c
+++ b/drivers/staging/usbip/vhci_rx.c
@@ -100,6 +100,9 @@ static void vhci_recv_ret_submit(struct vhci_device *vdev,
 	if (usbip_recv_iso(ud, urb) < 0)
 		return;
 
+	/* restore the padding in iso packets */
+	if (usbip_pad_iso(ud, urb) < 0)
+		return;
 
 	if (usbip_dbg_flag_vhci_rx)
 		usbip_dump_urb(urb);
diff --git a/drivers/staging/vme/bridges/vme_ca91cx42.c b/drivers/staging/vme/bridges/vme_ca91cx42.c
index d4a48c4..a400728 100644
--- a/drivers/staging/vme/bridges/vme_ca91cx42.c
+++ b/drivers/staging/vme/bridges/vme_ca91cx42.c
@@ -621,7 +621,7 @@ static int ca91cx42_master_set(struct vme_master_resource *image, int enabled,
 
 	/*
 	 * Let's allocate the resource here rather than further up the stack as
-	 * it avoids pushing loads of bus dependant stuff up the stack
+	 * it avoids pushing loads of bus dependent stuff up the stack
 	 */
 	retval = ca91cx42_alloc_resource(image, size);
 	if (retval) {
@@ -1052,7 +1052,7 @@ static int ca91cx42_dma_list_add(struct vme_dma_list *list,
 		pci_attr = dest->private;
 	}
 
-	/* Check we can do fullfill required attributes */
+	/* Check we can do fulfill required attributes */
 	if ((vme_attr->aspace & ~(VME_A16 | VME_A24 | VME_A32 | VME_USER1 |
 		VME_USER2)) != 0) {
 
@@ -1069,7 +1069,7 @@ static int ca91cx42_dma_list_add(struct vme_dma_list *list,
 		goto err_cycle;
 	}
 
-	/* Check to see if we can fullfill source and destination */
+	/* Check to see if we can fulfill source and destination */
 	if (!(((src->type == VME_DMA_PCI) && (dest->type == VME_DMA_VME)) ||
 		((src->type == VME_DMA_VME) && (dest->type == VME_DMA_PCI)))) {
 
diff --git a/drivers/staging/vme/bridges/vme_tsi148.c b/drivers/staging/vme/bridges/vme_tsi148.c
index b00a53e..106aa9d 100644
--- a/drivers/staging/vme/bridges/vme_tsi148.c
+++ b/drivers/staging/vme/bridges/vme_tsi148.c
@@ -928,7 +928,7 @@ static int tsi148_master_set(struct vme_master_resource *image, int enabled,
 	spin_lock(&image->lock);
 
 	/* Let's allocate the resource here rather than further up the stack as
-	 * it avoids pushing loads of bus dependant stuff up the stack. If size
+	 * it avoids pushing loads of bus dependent stuff up the stack. If size
 	 * is zero, any existing resource will be freed.
 	 */
 	retval = tsi148_alloc_resource(image, size);
@@ -1320,7 +1320,7 @@ static ssize_t tsi148_master_write(struct vme_master_resource *image, void *buf,
 
 	/*
 	 * Writes are posted. We need to do a read on the VME bus to flush out
-	 * all of the writes before we check for errors. We can't guarentee
+	 * all of the writes before we check for errors. We can't guarantee
 	 * that reading the data we have just written is safe. It is believed
 	 * that there isn't any read, write re-ordering, so we can read any
 	 * location in VME space, so lets read the Device ID from the tsi148's
diff --git a/drivers/staging/vme/bridges/vme_tsi148.h b/drivers/staging/vme/bridges/vme_tsi148.h
index 9f97fa8..a3ac2fe 100644
--- a/drivers/staging/vme/bridges/vme_tsi148.h
+++ b/drivers/staging/vme/bridges/vme_tsi148.h
@@ -212,7 +212,7 @@ static const int TSI148_LCSR_OT[8] = { TSI148_LCSR_OT0, TSI148_LCSR_OT1,
 #define TSI148_LCSR_OFFSET_OTAT		0x1C
 
 /*
- * VMEbus interupt ack
+ * VMEbus interrupt ack
  * offset  200
  */
 #define TSI148_LCSR_VIACK1	0x204
@@ -613,7 +613,7 @@ static const int TSI148_GCSR_MBOX[4] = { TSI148_GCSR_MBOX0,
 /*
  *  PCI-X Status Register (CRG +$054)
  */
-#define TSI148_PCFS_PCIXSTAT_RSCEM     (1<<29)	/* Recieved Split Comp Error */
+#define TSI148_PCFS_PCIXSTAT_RSCEM     (1<<29)	/* Received Split Comp Error */
 #define TSI148_PCFS_PCIXSTAT_DMCRS_M   (7<<26)	/* max Cumulative Read Size */
 #define TSI148_PCFS_PCIXSTAT_DMOST_M   (7<<23)	/* max outstanding Split Trans
 						 */
@@ -982,8 +982,8 @@ static const int TSI148_GCSR_MBOX[4] = { TSI148_GCSR_MBOX0,
 #define TSI148_LCSR_VICR_CNTS_IRQ1     (2<<22)	/* IRQ1 to Cntr */
 #define TSI148_LCSR_VICR_CNTS_IRQ2     (3<<22)	/* IRQ2 to Cntr */
 
-#define TSI148_LCSR_VICR_EDGIS_M       (3<<20)	/* Edge interupt MASK */
-#define TSI148_LCSR_VICR_EDGIS_DIS     (1<<20)	/* Edge interupt Disable */
+#define TSI148_LCSR_VICR_EDGIS_M       (3<<20)	/* Edge interrupt MASK */
+#define TSI148_LCSR_VICR_EDGIS_DIS     (1<<20)	/* Edge interrupt Disable */
 #define TSI148_LCSR_VICR_EDGIS_IRQ1    (2<<20)	/* IRQ1 to Edge */
 #define TSI148_LCSR_VICR_EDGIS_IRQ2    (3<<20)	/* IRQ2 to Edge */
 
diff --git a/drivers/staging/vme/vme_api.txt b/drivers/staging/vme/vme_api.txt
index a910a0c..4910e92 100644
--- a/drivers/staging/vme/vme_api.txt
+++ b/drivers/staging/vme/vme_api.txt
@@ -6,7 +6,7 @@ Driver registration
 
 As with other subsystems within the Linux kernel, VME device drivers register
 with the VME subsystem, typically called from the devices init routine.  This is
-achieved via a call to the follwoing function:
+achieved via a call to the following function:
 
 	int vme_register_driver (struct vme_driver *driver);
 
@@ -108,7 +108,7 @@ Master windows
 ==============
 
 Master windows provide access from the local processor[s] out onto the VME bus.
-The number of windows available and the available access modes is dependant on
+The number of windows available and the available access modes is dependent on
 the underlying chipset. A window must be configured before it can be used.
 
 
@@ -163,7 +163,7 @@ Slave windows
 
 Slave windows provide devices on the VME bus access into mapped portions of the
 local memory. The number of windows available and the access modes that can be
-used is dependant on the underlying chipset. A window must be configured before
+used is dependent on the underlying chipset. A window must be configured before
 it can be used.
 
 
diff --git a/drivers/staging/vt6655/Kconfig b/drivers/staging/vt6655/Kconfig
index 061e730..c3ba693 100644
--- a/drivers/staging/vt6655/Kconfig
+++ b/drivers/staging/vt6655/Kconfig
@@ -1,6 +1,6 @@
 config VT6655
    tristate "VIA Technologies VT6655 support"
-   depends on PCI && WLAN
+   depends on PCI && WLAN && m
    select WIRELESS_EXT
    select WEXT_PRIV
    ---help---
diff --git a/drivers/staging/vt6655/card.c b/drivers/staging/vt6655/card.c
index 951a3a8..2721e07 100644
--- a/drivers/staging/vt6655/card.c
+++ b/drivers/staging/vt6655/card.c
@@ -1186,7 +1186,7 @@ CARDbStartMeasure (
             wDuration += 1; // 1 TU for channel switching
 
             if ((LODWORD(qwStartTSF) == 0) && (HIDWORD(qwStartTSF) == 0)) {
-                // start imediately by setting start TSF == current TSF + 2 TU
+                // start immediately by setting start TSF == current TSF + 2 TU
                 LODWORD(qwStartTSF) = LODWORD(qwCurrTSF) + 2048;
                 HIDWORD(qwStartTSF) = HIDWORD(qwCurrTSF);
                 if (LODWORD(qwCurrTSF) > LODWORD(qwStartTSF)) {
diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index efaf19b..ad39c87 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -137,7 +137,7 @@ DEVICE_PARAM(TxDescriptors1,"Number of transmit descriptors1");
 /* IP_byte_align[] is used for IP header unsigned long byte aligned
    0: indicate the IP header won't be unsigned long byte aligned.(Default) .
    1: indicate the IP header will be unsigned long byte aligned.
-      In some enviroment, the IP header should be unsigned long byte aligned,
+      In some environment, the IP header should be unsigned long byte aligned,
       or the packet will be droped when we receive it. (eg: IPVS)
 */
 DEVICE_PARAM(IP_byte_align,"Enable IP header dword aligned");
diff --git a/drivers/staging/vt6655/wcmd.c b/drivers/staging/vt6655/wcmd.c
index abd6745..c30170a 100644
--- a/drivers/staging/vt6655/wcmd.c
+++ b/drivers/staging/vt6655/wcmd.c
@@ -587,7 +587,7 @@ printk("chester-abyDesireSSID=%s\n",((PWLAN_IE_SSID)pMgmt->abyDesireSSID)->abySS
             if ((pMgmt->eCurrMode == WMAC_MODE_ESS_STA) && (pMgmt->eCurrState == WMAC_STATE_JOINTED)) {
 
 		// Call mgr to begin the deauthentication
-                // reason = (3) beacuse sta has left ESS
+                // reason = (3) because sta has left ESS
                 if (pMgmt->eCurrState>= WMAC_STATE_AUTH) {
                     vMgrDeAuthenBeginSta((void *)pDevice, pMgmt, pMgmt->abyCurrBSSID, (3), &Status);
                 }
diff --git a/drivers/staging/vt6655/wmgr.h b/drivers/staging/vt6655/wmgr.h
index 141e80b..e3ae562 100644
--- a/drivers/staging/vt6655/wmgr.h
+++ b/drivers/staging/vt6655/wmgr.h
@@ -220,7 +220,7 @@ typedef enum tagWMAC_POWER_MODE {
 */
 
 
-// Tx Managment Packet descriptor
+// Tx Management Packet descriptor
 typedef struct tagSTxMgmtPacket {
 
     PUWLAN_80211HDR     p80211Header;
@@ -230,7 +230,7 @@ typedef struct tagSTxMgmtPacket {
 } STxMgmtPacket, *PSTxMgmtPacket;
 
 
-// Rx Managment Packet descriptor
+// Rx Management Packet descriptor
 typedef struct tagSRxMgmtPacket {
 
     PUWLAN_80211HDR     p80211Header;
diff --git a/drivers/staging/vt6656/Kconfig b/drivers/staging/vt6656/Kconfig
index a441ba5..f89ab20 100644
--- a/drivers/staging/vt6656/Kconfig
+++ b/drivers/staging/vt6656/Kconfig
@@ -1,6 +1,6 @@
 config VT6656
 	tristate "VIA Technologies VT6656 support"
-	depends on USB && WLAN
+	depends on USB && WLAN && m
 	select WIRELESS_EXT
 	select WEXT_PRIV
 	select FW_LOADER
diff --git a/drivers/staging/vt6656/rxtx.c b/drivers/staging/vt6656/rxtx.c
index 8f18578..5185d61 100644
--- a/drivers/staging/vt6656/rxtx.c
+++ b/drivers/staging/vt6656/rxtx.c
@@ -1938,7 +1938,7 @@ s_vGenerateMACHeader (
  *  Out:
  *      none
  *
- * Return Value: CMD_STATUS_PENDING if MAC Tx resource avaliable; otherwise FALSE
+ * Return Value: CMD_STATUS_PENDING if MAC Tx resource available; otherwise FALSE
  *
 -*/
 
diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index b83b660..019fb52 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -421,7 +421,7 @@ void vRunCommand(void *hDeviceContext)
                     pMgmt->eScanState = WMAC_IS_SCANNING;
                     pDevice->byScanBBType = pDevice->byBBType;  //lucas
                     pDevice->bStopDataPkt = TRUE;
-                    // Turn off RCR_BSSID filter everytime
+                    // Turn off RCR_BSSID filter every time
                     MACvRegBitsOff(pDevice, MAC_REG_RCR, RCR_BSSID);
                     pDevice->byRxMode &= ~RCR_BSSID;
 
@@ -604,7 +604,7 @@ void vRunCommand(void *hDeviceContext)
             // if Infra mode
             if ((pMgmt->eCurrMode == WMAC_MODE_ESS_STA) && (pMgmt->eCurrState == WMAC_STATE_JOINTED)) {
                 // Call mgr to begin the deauthentication
-                // reason = (3) beacuse sta has left ESS
+                // reason = (3) because sta has left ESS
 	      if (pMgmt->eCurrState >= WMAC_STATE_AUTH) {
 		vMgrDeAuthenBeginSta((void *)pDevice,
 				     pMgmt,
diff --git a/drivers/staging/vt6656/wmgr.h b/drivers/staging/vt6656/wmgr.h
index 594f3a8..13dfb3b 100644
--- a/drivers/staging/vt6656/wmgr.h
+++ b/drivers/staging/vt6656/wmgr.h
@@ -218,7 +218,7 @@ typedef enum tagWMAC_POWER_MODE {
 
 
 
-// Tx Managment Packet descriptor
+// Tx Management Packet descriptor
 typedef struct tagSTxMgmtPacket {
 
     PUWLAN_80211HDR     p80211Header;
@@ -228,7 +228,7 @@ typedef struct tagSTxMgmtPacket {
 } STxMgmtPacket, *PSTxMgmtPacket;
 
 
-// Rx Managment Packet descriptor
+// Rx Management Packet descriptor
 typedef struct tagSRxMgmtPacket {
 
     PUWLAN_80211HDR     p80211Header;
diff --git a/drivers/staging/westbridge/astoria/api/src/cyasdma.c b/drivers/staging/westbridge/astoria/api/src/cyasdma.c
index 16b8ec1..c461d4f 100644
--- a/drivers/staging/westbridge/astoria/api/src/cyasdma.c
+++ b/drivers/staging/westbridge/astoria/api/src/cyasdma.c
@@ -1082,7 +1082,7 @@ cy_as_dma_received_data(cy_as_device *dev_p,
 	/*
 	 * if the data received exceeds the size of the DMA buffer,
 	 * clip the data to the size of the buffer.  this can lead
-	 * to loosing some data, but is not different than doing
+	 * to losing some data, but is not different than doing
 	 * non-packet reads on the other endpoints.
 	 */
 	if (dsize > dma_p->size - dma_p->offset)
diff --git a/drivers/staging/westbridge/astoria/api/src/cyaslep2pep.c b/drivers/staging/westbridge/astoria/api/src/cyaslep2pep.c
index 60b6f35..76821e5 100644
--- a/drivers/staging/westbridge/astoria/api/src/cyaslep2pep.c
+++ b/drivers/staging/westbridge/astoria/api/src/cyaslep2pep.c
@@ -126,7 +126,7 @@ find_endpoint_directions(cy_as_device *dev_p,
 	cy_as_physical_endpoint_state desired;
 
 	/*
-	 * note, there is no error checking here becuase
+	 * note, there is no error checking here because
 	 * ISO error checking happens when the API is called.
 	 */
 	for (i = 0; i < 10; i++) {
diff --git a/drivers/staging/westbridge/astoria/api/src/cyaslowlevel.c b/drivers/staging/westbridge/astoria/api/src/cyaslowlevel.c
index d43dd85..96a86d0 100644
--- a/drivers/staging/westbridge/astoria/api/src/cyaslowlevel.c
+++ b/drivers/staging/westbridge/astoria/api/src/cyaslowlevel.c
@@ -432,7 +432,7 @@ cy_as_mail_box_queued_data_handler(cy_as_device *dev_p)
 * is received.  When a complete request is received, the callback
 * associated with requests on that context is called.  When a complete
 * response is recevied, the callback associated with the request that
-* generated the reponse is called.
+* generated the response is called.
 */
 void
 cy_as_mail_box_interrupt_handler(cy_as_device *dev_p)
diff --git a/drivers/staging/westbridge/astoria/api/src/cyasmisc.c b/drivers/staging/westbridge/astoria/api/src/cyasmisc.c
index 7852410..4564fc1 100644
--- a/drivers/staging/westbridge/astoria/api/src/cyasmisc.c
+++ b/drivers/staging/westbridge/astoria/api/src/cyasmisc.c
@@ -428,7 +428,7 @@ my_misc_callback(cy_as_device *dev_p, uint8_t context,
 				if (v & CY_AS_MEM_P0_VM_SET_CFGMODE)
 					cy_as_hal_print_message(
 					"initialization message "
-					"recieved, but config bit "
+					"received, but config bit "
 					"still set\n");
 
 				v = cy_as_hal_read_register(dev_p->tag,
@@ -436,7 +436,7 @@ my_misc_callback(cy_as_device *dev_p, uint8_t context,
 				if ((v & CY_AS_MEM_RST_RSTCMPT) == 0)
 					cy_as_hal_print_message(
 					"initialization message "
-					"recieved, but reset complete "
+					"received, but reset complete "
 					"bit still not set\n");
 			}
 			break;
@@ -2381,7 +2381,7 @@ try_wakeup_again:
 	/*
 	 * release the west bridge micro-_controller from reset,
 	 * so that firmware initialization can complete. the attempt
-	 * to release antioch reset is made upto 8 times.
+	 * to release antioch reset is made up to 8 times.
 	 */
 	v = 0x03;
 	count = 0x08;
diff --git a/drivers/staging/westbridge/astoria/api/src/cyasmtp.c b/drivers/staging/westbridge/astoria/api/src/cyasmtp.c
index 3689846..8598364 100644
--- a/drivers/staging/westbridge/astoria/api/src/cyasmtp.c
+++ b/drivers/staging/westbridge/astoria/api/src/cyasmtp.c
@@ -346,7 +346,7 @@ cy_as_mtp_start(cy_as_device_handle handle,
 
 		dev_p->mtp_event_cb = event_c_b;
 		/*
-		* we register here becuase the start request may cause
+		* we register here because the start request may cause
 		* events to occur before the response to the start request.
 		*/
 		cy_as_ll_register_request_callback(dev_p,
@@ -424,7 +424,7 @@ my_handle_response_mtp_stop(cy_as_device *dev_p,
 		goto destroy;
 
 	/*
-	* we sucessfully shutdown the stack, so decrement
+	* we successfully shutdown the stack, so decrement
 	* to make the count zero.
 	*/
 	dev_p->mtp_count--;
diff --git a/drivers/staging/westbridge/astoria/api/src/cyasstorage.c b/drivers/staging/westbridge/astoria/api/src/cyasstorage.c
index 2451404..7abd6a3 100644
--- a/drivers/staging/westbridge/astoria/api/src/cyasstorage.c
+++ b/drivers/staging/westbridge/astoria/api/src/cyasstorage.c
@@ -1773,7 +1773,7 @@ cy_as_storage_async_oper(cy_as_device *dev_p, cy_as_end_point_number_t ep,
 	if (unit > 255)
 		return CY_AS_ERROR_NO_SUCH_UNIT;
 
-	/* We are supposed to return sucess if the number of
+	/* We are supposed to return success if the number of
 	* blocks is zero
 	*/
 	if (num_blocks == 0) {
@@ -1969,7 +1969,7 @@ cy_as_storage_sync_oper(cy_as_device *dev_p,
 	if (cy_as_device_is_usb_async_pending(dev_p, 6))
 		return CY_AS_ERROR_ASYNC_PENDING;
 
-	/* We are supposed to return sucess if the number of
+	/* We are supposed to return success if the number of
 	* blocks is zero
 	*/
 	if (num_blocks == 0)
@@ -3285,7 +3285,7 @@ cy_as_sdio_extended_i_o_async(
 	if (callback == 0)
 		return CY_AS_ERROR_NULL_CALLBACK;
 
-	/* We are supposed to return sucess if the number of
+	/* We are supposed to return success if the number of
 	 * blocks is zero
 	 */
 	if (((misc_buf&CY_SDIO_BLOCKMODE) != 0) && (argument == 0)) {
diff --git a/drivers/staging/westbridge/astoria/api/src/cyasusb.c b/drivers/staging/westbridge/astoria/api/src/cyasusb.c
index 92ea425..1b55e61 100644
--- a/drivers/staging/westbridge/astoria/api/src/cyasusb.c
+++ b/drivers/staging/westbridge/astoria/api/src/cyasusb.c
@@ -739,7 +739,7 @@ cy_as_usb_start(cy_as_device_handle handle,
 		cy_as_usb_reset_e_p0_state(dev_p);
 
 		/*
-		* we register here becuase the start request may cause
+		* we register here because the start request may cause
 		* events to occur before the response to the start request.
 		*/
 		cy_as_ll_register_request_callback(dev_p,
@@ -867,7 +867,7 @@ my_handle_response_usb_stop(cy_as_device *dev_p,
 		goto destroy;
 
 	/*
-	 * we sucessfully shutdown the stack, so
+	 * we successfully shutdown the stack, so
 	 * decrement to make the count zero.
 	 */
 	cy_as_usb_cleanup(dev_p);
diff --git a/drivers/staging/westbridge/astoria/arch/arm/mach-omap2/cyashalomap_kernel.c b/drivers/staging/westbridge/astoria/arch/arm/mach-omap2/cyashalomap_kernel.c
index 21cdb06..3bcedce 100644
--- a/drivers/staging/westbridge/astoria/arch/arm/mach-omap2/cyashalomap_kernel.c
+++ b/drivers/staging/westbridge/astoria/arch/arm/mach-omap2/cyashalomap_kernel.c
@@ -87,7 +87,7 @@
 
 
 /*
- * For performance reasons, we handle storage endpoint transfers upto 4 KB
+ * For performance reasons, we handle storage endpoint transfers up to 4 KB
  * within the HAL itself.
  */
  #define CYASSTORAGE_WRITE_EP_NUM	(4)
@@ -108,12 +108,12 @@
 				((ep) == 6) || ((ep) == 8))
 
 /*
- * persistant, stores current GPMC interface cfg mode
+ * persistent, stores current GPMC interface cfg mode
  */
 static uint8_t pnand_16bit;
 
 /*
- * keep processing new WB DRQ in ISR untill all handled (performance feature)
+ * keep processing new WB DRQ in ISR until all handled (performance feature)
  */
 #define PROCESS_MULTIPLE_DRQ_IN_ISR (1)
 
@@ -157,7 +157,7 @@ typedef struct cy_as_hal_endpoint_dma {
 	 * dma_xfer_sz - size of the next dma xfer on P port
 	 * seg_xfer_cnt -  counts xfered bytes for in current sg_list
 	 *		memory segment
-	 * req_xfer_cnt - total number of bytes transfered so far in
+	 * req_xfer_cnt - total number of bytes transferred so far in
 	 *		current request
 	 * req_length - total request length
 	 */
@@ -2160,7 +2160,7 @@ void cy_as_hal_mem_set(void *ptr, uint8_t value, uint32_t cnt)
 /*
  * This function is expected to create a sleep channel.
  * The data structure that represents the sleep channel object
- * sleep channel (which is Linux "wait_queue_head_t wq" for this paticular HAL)
+ * sleep channel (which is Linux "wait_queue_head_t wq" for this particular HAL)
  * passed as a pointer, and allpocated by the caller
  * (typically as a local var on the stack) "Create" word should read as
  * "SleepOn", this func doesn't actually create anything
@@ -2364,7 +2364,7 @@ int start_o_m_a_p_kernel(const char *pgm,
 	 */
 	cy_as_hal_gpmc_enable_16bit_bus(cy_true);
 #else
-   /* Astoria and GPMC are already in 8 bit mode, jsut initialize PNAND_CFG */
+   /* Astoria and GPMC are already in 8 bit mode, just initialize PNAND_CFG */
 	ast_p_nand_casdi_write(CY_AS_MEM_PNAND_CFG, 0x0000);
 #endif
 
diff --git a/drivers/staging/westbridge/astoria/arch/arm/plat-omap/include/mach/westbridge/westbridge-omap3-pnand-hal/cyashalomap_kernel.h b/drivers/staging/westbridge/astoria/arch/arm/plat-omap/include/mach/westbridge/westbridge-omap3-pnand-hal/cyashalomap_kernel.h
index 80dd530..6426ea6 100644
--- a/drivers/staging/westbridge/astoria/arch/arm/plat-omap/include/mach/westbridge/westbridge-omap3-pnand-hal/cyashalomap_kernel.h
+++ b/drivers/staging/westbridge/astoria/arch/arm/plat-omap/include/mach/westbridge/westbridge-omap3-pnand-hal/cyashalomap_kernel.h
@@ -20,7 +20,7 @@
 */
 
 /*
- * This file contains the defintion of the hardware abstraction
+ * This file contains the definition of the hardware abstraction
  * layer on OMAP3430 talking to the West Bridge Astoria device
  */
 
diff --git a/drivers/staging/westbridge/astoria/arch/arm/plat-omap/include/mach/westbridge/westbridge-omap3-pnand-hal/cyasmemmap.h b/drivers/staging/westbridge/astoria/arch/arm/plat-omap/include/mach/westbridge/westbridge-omap3-pnand-hal/cyasmemmap.h
index 3eee192..46f06ee 100644
--- a/drivers/staging/westbridge/astoria/arch/arm/plat-omap/include/mach/westbridge/westbridge-omap3-pnand-hal/cyasmemmap.h
+++ b/drivers/staging/westbridge/astoria/arch/arm/plat-omap/include/mach/westbridge/westbridge-omap3-pnand-hal/cyasmemmap.h
@@ -51,7 +51,7 @@
  * 							GPMC_ADDR
  *							[A8:A1]->upD[7:0]
  * INT#	-GPMC_nWP_GPIO_62
- * DACK	-N/C				 not conected
+ * DACK	-N/C				 not connected
  * WAKEUP-GPIO_167
  * RESET-GPIO_126
  * R/B	-GPMC_WAIT2_GPIO_64
@@ -108,7 +108,7 @@
 	 *					will be monitored
 	 * PF_EN_ENGINE - 1- ENABLES ENGINE, but it needs to be started after
 	 *					that C ctrl reg bit 0
-	 * PF_FIFO_THRESHOLD - FIFO threshhold in number of BUS(8 or 16) words
+	 * PF_FIFO_THRESHOLD - FIFO threshold in number of BUS(8 or 16) words
 	 * PF_WEIGHTED_PRIO  - NUM of cycles granted to PFE if RND_ROBIN
 	 *					prioritization is enabled
 	 * PF_ROUND_ROBIN  - if enabled, gives priority to other CS, but
diff --git a/drivers/staging/westbridge/astoria/block/cyasblkdev_queue.c b/drivers/staging/westbridge/astoria/block/cyasblkdev_queue.c
index 0bbb8a3..d1996a2 100644
--- a/drivers/staging/westbridge/astoria/block/cyasblkdev_queue.c
+++ b/drivers/staging/westbridge/astoria/block/cyasblkdev_queue.c
@@ -222,7 +222,7 @@ static int cyasblkdev_queue_thread(void *d)
 			continue;
 		}
 
-		/* new req recieved, issue it to the driver  */
+		/* new req received, issue it to the driver  */
 		set_current_state(TASK_RUNNING);
 
 		#ifndef WESTBRIDGE_NDEBUG
diff --git a/drivers/staging/westbridge/astoria/gadget/cyasgadget.c b/drivers/staging/westbridge/astoria/gadget/cyasgadget.c
index defa05c..be851ca 100644
--- a/drivers/staging/westbridge/astoria/gadget/cyasgadget.c
+++ b/drivers/staging/westbridge/astoria/gadget/cyasgadget.c
@@ -587,6 +587,7 @@ static int cyasgadget_enable(
 			"cy_as_usb_end_point_config EP %s mismatch "
 			"on enabled\n", an_ep->usb_ep_inst.name);
 		#endif
+		spin_unlock_irqrestore(&an_dev->lock, flags);
 		return -EINVAL;
 	}
 
diff --git a/drivers/staging/westbridge/astoria/include/linux/westbridge/cyasdevice.h b/drivers/staging/westbridge/astoria/include/linux/westbridge/cyasdevice.h
index 0c0726b..6452a90 100644
--- a/drivers/staging/westbridge/astoria/include/linux/westbridge/cyasdevice.h
+++ b/drivers/staging/westbridge/astoria/include/linux/westbridge/cyasdevice.h
@@ -119,7 +119,7 @@
 #define CY_AS_REQUEST_LIST_STATE_QUEUED (0x00)
 /* The request is sent, waiting for response */
 #define CY_AS_REQUEST_LIST_STATE_WAITING (0x01)
-/* The response has been received, processing reponse */
+/* The response has been received, processing response */
 #define CY_AS_REQUEST_LIST_STATE_RECEIVED (0x02)
 /* The request/response is being canceled */
 #define CY_AS_REQUEST_LIST_STATE_CANCELING (0x03)
@@ -517,7 +517,7 @@ typedef struct cy_as_context {
 	cy_as_ll_request_list_node *request_queue_p;
 	/* The list node in the request queue */
 	cy_as_ll_request_list_node *last_node_p;
-	/* Index upto which data is stored. */
+	/* Index up to which data is stored. */
 	uint16_t queue_index;
 	/* Index to the next request in the queue. */
 	uint16_t rqt_index;
@@ -768,7 +768,7 @@ struct cy_as_device {
 	uint32_t mtp_count;
 	/* The MTP event callback supplied by the client */
 	cy_as_mtp_event_callback mtp_event_cb;
-	/* The current block table to be transfered */
+	/* The current block table to be transferred */
 	cy_as_mtp_block_table *tp_blk_tbl;
 
 	cy_as_c_b_queue *func_cbs_mtp;
diff --git a/drivers/staging/westbridge/astoria/include/linux/westbridge/cyasdma.h b/drivers/staging/westbridge/astoria/include/linux/westbridge/cyasdma.h
index 8dab5e9..16dc9f9 100644
--- a/drivers/staging/westbridge/astoria/include/linux/westbridge/cyasdma.h
+++ b/drivers/staging/westbridge/astoria/include/linux/westbridge/cyasdma.h
@@ -108,7 +108,7 @@ typedef enum cy_as_dma_direction {
    completes a requested DMA operation.
 
    Returns
-   CY_AS_ERROR_SUCCESS - the module initialized sucessfully
+   CY_AS_ERROR_SUCCESS - the module initialized successfully
    CY_AS_ERROR_OUT_OF_MEMORY - memory allocation failed during
 		initialization
    CY_AS_ERROR_ALREADY_RUNNING - the DMA module was already running
@@ -131,7 +131,7 @@ cy_as_dma_start(
    then freeing the resources associated with each DMA endpoint.
 
    Returns
-   CY_AS_ERROR_SUCCESS - the module shutdown sucessfully
+   CY_AS_ERROR_SUCCESS - the module shutdown successfully
    CY_AS_ERROR_NOT_RUNNING - the DMA module was not running
 
    See Also
@@ -161,7 +161,7 @@ cy_as_dma_stop(
 
    Returns
    CY_AS_ERROR_SUCCESS - the traffic on the endpoint is canceled
-	sucessfully
+	successfully
 
    See Also
 */
@@ -266,7 +266,7 @@ cy_as_dma_queue_request(
    will have to maintain a list of sleep channels to wake.
 
    Returns
-   * CY_AS_ERROR_SUCCESS - the queue has drained sucessfully
+   * CY_AS_ERROR_SUCCESS - the queue has drained successfully
    * CY_AS_ERROR_INVALID_ENDPOINT - the endpoint given is not valid
    * CY_AS_ERROR_NESTED_SLEEP - CyAsDmaQueueRequest() was requested
    *	on an endpoint where CyAsDmaQueueRequest was already called
@@ -295,7 +295,7 @@ cy_as_dma_drain_queue(
    CyAsHalDmaSetupRead() functoins.
 
    Returns
-   * CY_AS_ERROR_SUCCESS - the value was set sucessfully
+   * CY_AS_ERROR_SUCCESS - the value was set successfully
    * CY_AS_ERROR_INVALID_SIZE - the size value was not valid
 */
 extern cy_as_return_status_t
diff --git a/drivers/staging/westbridge/astoria/include/linux/westbridge/cyaserr.h b/drivers/staging/westbridge/astoria/include/linux/westbridge/cyaserr.h
index f78d602..2cd0af1 100644
--- a/drivers/staging/westbridge/astoria/include/linux/westbridge/cyaserr.h
+++ b/drivers/staging/westbridge/astoria/include/linux/westbridge/cyaserr.h
@@ -29,7 +29,7 @@
 */
 
 /* Summary
-   The function completed sucessfully
+   The function completed successfully
 */
 #define CY_AS_ERROR_SUCCESS	 (0)
 
@@ -796,7 +796,7 @@
    Description
    This error is returned when an operation is attempted that cannot be
    completed while the USB stack is connected to a USB host.  In order
-   to sucessfully complete the desired operation, CyAsUsbDisconnect()
+   to successfully complete the desired operation, CyAsUsbDisconnect()
    must be called to disconnect from the host.
 */
 #define CY_AS_ERROR_USB_CONNECTED (53)
diff --git a/drivers/staging/westbridge/astoria/include/linux/westbridge/cyashaldoc.h b/drivers/staging/westbridge/astoria/include/linux/westbridge/cyashaldoc.h
index 28136ad..5bcbe9b 100644
--- a/drivers/staging/westbridge/astoria/include/linux/westbridge/cyashaldoc.h
+++ b/drivers/staging/westbridge/astoria/include/linux/westbridge/cyashaldoc.h
@@ -597,7 +597,7 @@ cy_as_mem_set(
    CyAsHalSleepChannel.
 
    Returns
-   CyTrue is the initialization was sucessful, and CyFalse otherwise
+   CyTrue is the initialization was successful, and CyFalse otherwise
 
    See Also
    * CyAsHalSleepChannel
diff --git a/drivers/staging/westbridge/astoria/include/linux/westbridge/cyasintr.h b/drivers/staging/westbridge/astoria/include/linux/westbridge/cyasintr.h
index 3d7063e..60a6fff 100644
--- a/drivers/staging/westbridge/astoria/include/linux/westbridge/cyasintr.h
+++ b/drivers/staging/westbridge/astoria/include/linux/westbridge/cyasintr.h
@@ -69,7 +69,7 @@ cy_as_intr_start(
 
    Returns
    * CY_AS_ERROR_SUCCESS - the interrupt module was stopped
-   *	sucessfully
+   *	successfully
    * CY_AS_ERROR_NOT_RUNNING - the interrupt module was not
    *	running
 
diff --git a/drivers/staging/westbridge/astoria/include/linux/westbridge/cyasmisc.h b/drivers/staging/westbridge/astoria/include/linux/westbridge/cyasmisc.h
index 2f07018..df7c2b6 100644
--- a/drivers/staging/westbridge/astoria/include/linux/westbridge/cyasmisc.h
+++ b/drivers/staging/westbridge/astoria/include/linux/westbridge/cyasmisc.h
@@ -620,7 +620,7 @@ cy_as_misc_in_standby(
    * Nestable: YES
 
    Returns
-   * CY_AS_ERROR_SUCCESS - the firmware was sucessfully downloaded
+   * CY_AS_ERROR_SUCCESS - the firmware was successfully downloaded
    * CY_AS_ERROR_INVALID_HANDLE
    * CY_AS_ERROR_NOT_CONFIGURED - the West Bridge device
    *	was not configured
@@ -836,7 +836,7 @@ cy_as_misc_reset(
    ownership.
 
    Returns
-   * CY_AS_ERROR_SUCCESS - the p port sucessfully acquired the
+   * CY_AS_ERROR_SUCCESS - the p port successfully acquired the
    * 	resource of interest
    * CY_AS_ERROR_INVALID_HANDLE
    * CY_AS_ERROR_NOT_CONFIGURED
@@ -879,7 +879,7 @@ cy_as_misc_acquire_resource(
    * Valid In Asynchronous Callback: NO
 
    Returns
-   * CY_AS_ERROR_SUCCESS - the p port sucessfully released
+   * CY_AS_ERROR_SUCCESS - the p port successfully released
    *	the resource of interest
    * CY_AS_ERROR_INVALID_HANDLE
    * CY_AS_ERROR_NOT_CONFIGURED
@@ -929,7 +929,7 @@ cy_as_misc_release_resource(
 
    Returns
    * CY_AS_ERROR_SUCCESS - the trace configuration has been
-   *	sucessfully changed
+   *	successfully changed
    * CY_AS_ERROR_NO_SUCH_BUS - the bus specified does not exist
    * CY_AS_ERROR_NO_SUCH_DEVICE - the specified media/device
    *	pair does not exist
diff --git a/drivers/staging/westbridge/astoria/include/linux/westbridge/cyasprotocol.h b/drivers/staging/westbridge/astoria/include/linux/westbridge/cyasprotocol.h
index 317805f..773b645 100644
--- a/drivers/staging/westbridge/astoria/include/linux/westbridge/cyasprotocol.h
+++ b/drivers/staging/westbridge/astoria/include/linux/westbridge/cyasprotocol.h
@@ -756,7 +756,7 @@
 	 * 1 : Debug mode
 
    Description
-   This reponse is sent to return the firmware version
+   This response is sent to return the firmware version
    number to the requestor.
  */
 #define CY_RESP_FIRMWARE_VERSION (16)
@@ -3655,7 +3655,7 @@
    This request is sent to the West Bridge when the P port
    needs to send data to the Host in a Turbo Endpoint.
    Upon receiving this event, Firmware will make the end point
-   avilable for the P port. If the length is zero, then
+   available for the P port. If the length is zero, then
    firmware will send a zero length packet.
 
    Direction
diff --git a/drivers/staging/westbridge/astoria/include/linux/westbridge/cyasstorage.h b/drivers/staging/westbridge/astoria/include/linux/westbridge/cyasstorage.h
index 64f078c..52b93c3 100644
--- a/drivers/staging/westbridge/astoria/include/linux/westbridge/cyasstorage.h
+++ b/drivers/staging/westbridge/astoria/include/linux/westbridge/cyasstorage.h
@@ -832,7 +832,7 @@ typedef struct cy_as_sdio_func {
    * CY_AS_ERROR_NO_FIRMWARE - the firmware has not been
    *	loaded into West Bridge
    * CY_AS_ERROR_INVALID_HANDLE - an invalid handle was passed in
-   * CY_AS_ERROR_SUCCESS - the module started sucessfully
+   * CY_AS_ERROR_SUCCESS - the module started successfully
    * CY_AS_ERROR_TIMEOUT - a timeout occurred communicating
    *	with the West Bridge device
    * CY_AS_ERROR_OUT_OF_MEMORY
@@ -882,7 +882,7 @@ cy_as_storage_start(
    * CY_AS_ERROR_INVALID_HANDLE - an invalid handle was
    *	passed in
    * CY_AS_ERROR_SUCCESS - this module was shut
-   *	down sucessfully
+   *	down successfully
    * CY_AS_ERROR_TIMEOUT - a timeout occurred
    *	communicating with the West Bridge device
    * CY_AS_ERROR_NOT_RUNNING
@@ -934,7 +934,7 @@ cy_as_storage_stop(
    * CY_AS_ERROR_INVALID_HANDLE - an invalid handle
    *	was passed in
    * CY_AS_ERROR_SUCCESS - the function was registered
-   *	sucessfully
+   *	successfully
    * CY_AS_ERROR_NOT_RUNNING - the stack is not running
 
    See Also
@@ -981,7 +981,7 @@ cy_as_storage_register_callback(
    *	been started
    * CY_AS_ERROR_INVALID_HANDLE - an invalid handle was
    *	passed in
-   * CY_AS_ERROR_SUCCESS - this request was sucessfully
+   * CY_AS_ERROR_SUCCESS - this request was successfully
    *	transmitted to the West Bridge device
    * CY_AS_ERROR_TIMEOUT - a timeout occurred communicating
    *	with the West Bridge device
@@ -1034,7 +1034,7 @@ cy_as_storage_claim(
    *	been started
    * CY_AS_ERROR_INVALID_HANDLE - an invalid handle
    *	was passed in
-   * CY_AS_ERROR_SUCCESS - the media was sucessfully
+   * CY_AS_ERROR_SUCCESS - the media was successfully
    *	released
    * CY_AS_ERROR_MEDIA_NOT_CLAIMED - the media was not
    *	claimed by the P port
@@ -1905,7 +1905,7 @@ cy_as_storage_get_transfer_amount(
    differ between SD cards.
 
    A large erase can take a while to complete depending on the SD
-   card. In such a case it is reccomended that an async call is made.
+   card. In such a case it is recommended that an async call is made.
 
    Returns
    * CY_AS_ERROR_SUCCESS - API call completed successfully
@@ -1926,7 +1926,7 @@ cy_as_storage_get_transfer_amount(
    *	required before erase is allowed
    * CY_AS_ERROR_NO_SUCH_BUS
    * CY_AS_ERROR_NO_SUCH_DEVICE
-   * CY_AS_ERROR_NOT_SUPPORTED - Erase is currenly only supported
+   * CY_AS_ERROR_NOT_SUPPORTED - Erase is currently only supported
    *	on SD and using SD only firmware
    * CY_AS_ERROR_OUT_OF_MEMORY
 
@@ -1985,7 +1985,7 @@ cy_as_storage_erase(
    *	type was made
    * CY_AS_ERROR_OUT_OF_MEMORY - insufficient memory available
    * CY_AS_ERROR_INVALID_RESPONSE - an error message was
-   *	recieved from the firmware
+   *	received from the firmware
    * CY_AS_ERROR_MEDIA_ACCESS_FAILURE - there was error in
    *	reading from the media
    * CY_AS_ERROR_INVALID_FUNCTION - An IO attempt was made to
@@ -2047,7 +2047,7 @@ cy_as_sdio_get_c_i_s_info(
    *	pair does not exist
    * CY_AS_ERROR_OUT_OF_MEMORY - insufficient memory available
    * CY_AS_ERROR_INVALID_RESPONSE - an error message was
-   *	recieved from the firmware
+   *	received from the firmware
 
 */
 cy_as_return_status_t
@@ -2095,7 +2095,7 @@ cy_as_sdio_query_card(
    *	pair does not exist
    * CY_AS_ERROR_OUT_OF_MEMORY - insufficient memory available
    * CY_AS_ERROR_INVALID_RESPONSE - an error message was
-   *	recieved from the firmware
+   *	received from the firmware
    */
 cy_as_return_status_t
 cy_as_sdio_reset_card(
@@ -2139,7 +2139,7 @@ cy_as_sdio_reset_card(
    * CY_AS_ERROR_NO_SUCH_DEVICE - the specified media/device pair
    *	does not exist
    * CY_AS_ERROR_OUT_OF_MEMORY - insufficient memory available
-   * CY_AS_ERROR_INVALID_RESPONSE - an error message was recieved
+   * CY_AS_ERROR_INVALID_RESPONSE - an error message was received
    *	from the firmware
    * CY_AS_ERROR_MEDIA_ACCESS_FAILURE - there was error in reading
    *	from the media
@@ -2198,7 +2198,7 @@ cy_as_sdio_direct_read(
    * CY_AS_ERROR_NO_SUCH_DEVICE - the specified media/device
    * pair does not exist
    * CY_AS_ERROR_OUT_OF_MEMORY - insufficient memory available
-   * CY_AS_ERROR_INVALID_RESPONSE - an error message was recieved
+   * CY_AS_ERROR_INVALID_RESPONSE - an error message was received
    * from the firmware
    * CY_AS_ERROR_MEDIA_ACCESS_FAILURE - there was error in
    * reading from the media
@@ -2262,7 +2262,7 @@ cy_as_sdio_direct_write(
    * CY_AS_ERROR_OUT_OF_MEMORY - insufficient memory
    *	available
    * CY_AS_ERROR_INVALID_RESPONSE - an error message was
-   *	recieved from the firmware
+   *	received from the firmware
    * CY_AS_ERROR_MEDIA_ACCESS_FAILURE - there was error in
    *	reading from the media
    * CY_AS_ERROR_INVALID_FUNCTION - An IO attempt was made
@@ -2319,7 +2319,7 @@ cy_as_sdio_set_blocksize(
    *	pair does not exist
    * CY_AS_ERROR_ASYNC_PENDING - an async operation is pending
    * CY_AS_ERROR_OUT_OF_MEMORY - insufficient memory available
-   * CY_AS_ERROR_INVALID_RESPONSE - an error message was recieved
+   * CY_AS_ERROR_INVALID_RESPONSE - an error message was received
    *	from the firmware
    * CY_AS_ERROR_MEDIA_ACCESS_FAILURE - there was error in
    *	reading from the media
@@ -2396,7 +2396,7 @@ cy_as_sdio_extended_read(
    * CY_AS_ERROR_ASYNC_PENDING - an async operation is pending
    * CY_AS_ERROR_OUT_OF_MEMORY - insufficient memory available
    * CY_AS_ERROR_INVALID_RESPONSE - an error message was
-   *	recieved from the firmware
+   *	received from the firmware
    * CY_AS_ERROR_MEDIA_ACCESS_FAILURE - there was error in
    *	reading from the media
    * CY_AS_ERROR_INVALID_FUNCTION - An IO attempt was made
@@ -2471,7 +2471,7 @@ cy_as_sdio_extended_write(
    * pair does not exist
    * CY_AS_ERROR_OUT_OF_MEMORY - insufficient memory available
    * CY_AS_ERROR_INVALID_RESPONSE - an error message was
-   *	recieved from the firmware
+   *	received from the firmware
    * CY_AS_ERROR_MEDIA_ACCESS_FAILURE - there was error in
    *	reading from the media
    * CY_AS_ERROR_INVALID_FUNCTION - An IO attempt was made
@@ -2714,7 +2714,7 @@ cy_as_sdio_suspend(
    * CY_AS_ERROR_OUT_OF_MEMORY - insufficient memory
    *	available
    * CY_AS_ERROR_INVALID_RESPONSE - an error message was
-   *	recieved from the firmware
+   *	received from the firmware
    * CY_AS_ERROR_MEDIA_ACCESS_FAILURE - there was error
    *	in reading from the media
    * CY_AS_ERROR_INVALID_FUNCTION - An IO attempt was
diff --git a/drivers/staging/westbridge/astoria/include/linux/westbridge/cyasusb.h b/drivers/staging/westbridge/astoria/include/linux/westbridge/cyasusb.h
index 4a549e1..e3ba9ca 100644
--- a/drivers/staging/westbridge/astoria/include/linux/westbridge/cyasusb.h
+++ b/drivers/staging/westbridge/astoria/include/linux/westbridge/cyasusb.h
@@ -464,7 +464,7 @@ typedef struct cy_as_usb_end_point_config {
    be selected on a partitioned storage device.
 
    Description
-   West Bridge firmware supports creating upto two
+   West Bridge firmware supports creating up to two
    partitions on mass storage devices connected to
    West Bridge.  When there are two partitions on a device,
    the user can choose which of these partitions should be
@@ -698,7 +698,7 @@ cy_as_usb_start(
    *	been configured
    * CY_AS_ERROR_NO_FIRMWARE - the firmware has not been loaded
    *	into West Bridge
-   * CY_AS_ERROR_SUCCESS - this module was shut down sucessfully
+   * CY_AS_ERROR_SUCCESS - this module was shut down successfully
    * CY_AS_ERROR_TIMEOUT - a timeout occurred communicating with
    *	the West Bridge device
 
@@ -752,7 +752,7 @@ cy_as_usb_register_callback(
    * Nestable: YES
 
    Returns
-   * CY_AS_ERROR_SUCCESS - this module was shut down sucessfully
+   * CY_AS_ERROR_SUCCESS - this module was shut down successfully
    * CY_AS_ERROR_NOT_CONFIGURED - the West Bridge device has not
    *	been configured
    * CY_AS_ERROR_NO_FIRMWARE - the firmware has not been loaded
@@ -791,7 +791,7 @@ cy_as_usb_connect(
    * Nestable: YES
 
    Returns
-   * CY_AS_ERROR_SUCCESS - this module was shut down sucessfully
+   * CY_AS_ERROR_SUCCESS - this module was shut down successfully
    * CY_AS_ERROR_NOT_CONFIGURED - the West Bridge device has not
    *	been configured
    * CY_AS_ERROR_NO_FIRMWARE - the firmware has not been loaded
@@ -825,7 +825,7 @@ cy_as_usb_disconnect(
    * Valid In Asynchronous Callback: Yes (if cb supplied)
 
    Returns
-   * CY_AS_ERROR_SUCCESS - this module was shut down sucessfully
+   * CY_AS_ERROR_SUCCESS - this module was shut down successfully
    * CY_AS_ERROR_NOT_CONFIGURED - the West Bridge device has not
    *	been configured
    * CY_AS_ERROR_NO_FIRMWARE - the firmware has not been loaded
@@ -855,13 +855,13 @@ cy_as_usb_set_enum_config(
    the USB stack
 
    Description
-   This function sends a request to West Bridge to retreive
+   This function sends a request to West Bridge to retrieve
    the current configuration
 
    * Valid In Asynchronous Callback: Yes (if cb supplied)
 
    Returns
-   * CY_AS_ERROR_SUCCESS - this module was shut down sucessfully
+   * CY_AS_ERROR_SUCCESS - this module was shut down successfully
    * CY_AS_ERROR_NOT_CONFIGURED - the West Bridge device has not
    *	been configured
    * CY_AS_ERROR_NO_FIRMWARE - the firmware has not been loaded
@@ -906,7 +906,7 @@ cy_as_usb_get_enum_config(
    Chapter 9.
 
    Returns
-   * CY_AS_ERROR_SUCCESS - this module was shut down sucessfully
+   * CY_AS_ERROR_SUCCESS - this module was shut down successfully
    * CY_AS_ERROR_NOT_CONFIGURED - the West Bridge device has not
    *	been configured
    * CY_AS_ERROR_NO_FIRMWARE - the firmware has not been loaded
@@ -993,7 +993,7 @@ cy_as_usb_clear_descriptors(
    Description
    This data structure the buffer to hold the descriptor
    data, and an in/out parameter ti indicate the
-   lenght of the buffer and descriptor data in bytes.
+   length of the buffer and descriptor data in bytes.
 
    See Also
    * CyAsUsbGetDescriptor
@@ -1027,7 +1027,7 @@ typedef struct cy_as_get_descriptor_data {
    Chapter 9.
 
    Returns
-   * CY_AS_ERROR_SUCCESS - this module was shut down sucessfully
+   * CY_AS_ERROR_SUCCESS - this module was shut down successfully
    * CY_AS_ERROR_NOT_CONFIGURED - the West Bridge device has not
    *	been configured
    * CY_AS_ERROR_NO_FIRMWARE - the firmware has not been loaded
@@ -1106,7 +1106,7 @@ cy_as_usb_get_descriptor(
    * Valid In Asynchronous Callback: NO
 
    Returns
-   * CY_AS_ERROR_SUCCESS - this module was shut down sucessfully
+   * CY_AS_ERROR_SUCCESS - this module was shut down successfully
    * CY_AS_ERROR_NOT_CONFIGURED - the West Bridge device has not
    *	been configured
    * CY_AS_ERROR_NO_FIRMWARE - the firmware has not been loaded
@@ -1140,7 +1140,7 @@ cy_as_usb_set_physical_configuration(
    Add documentation about endpoint configuration limitations
 
    Returns
-   * CY_AS_ERROR_SUCCESS - this module was shut down sucessfully
+   * CY_AS_ERROR_SUCCESS - this module was shut down successfully
    * CY_AS_ERROR_NOT_CONFIGURED - the West Bridge device has not
    *	been configured
    * CY_AS_ERROR_NO_FIRMWARE - the firmware has not been loaded
@@ -1181,7 +1181,7 @@ cy_as_usb_set_end_point_config(
    * Valid In Asynchronous Callback: NO
 
    Returns
-   * CY_AS_ERROR_SUCCESS - this module was shut down sucessfully
+   * CY_AS_ERROR_SUCCESS - this module was shut down successfully
    * CY_AS_ERROR_NOT_CONFIGURED - the West Bridge device has not
    *	been configured
    * CY_AS_ERROR_NO_FIRMWARE - the firmware has not been loaded
@@ -1219,7 +1219,7 @@ cy_as_usb_get_end_point_config(
    functions store away the configuration information and this
    CyAsUsbCommitConfig() actually finds the
    best hardware configuration based on the requested endpoint
-   configuration and sends thsi optimal
+   configuration and sends this optimal
    confiuration down to the West Bridge device.
 
    * Valid In Asynchronous Callback: YES (if cb supplied)
@@ -1268,7 +1268,7 @@ cy_as_usb_commit_config(
    * Valid In Asynchronous Callback: NO
 
    Returns
-   * CY_AS_ERROR_SUCCESS - this module was shut down sucessfully
+   * CY_AS_ERROR_SUCCESS - this module was shut down successfully
    * CY_AS_ERROR_TIMEOUT - a timeout occurred communicating with
    *	the West Bridge device
    * CY_AS_ERROR_NOT_RUNNING - the USB stack is not running
@@ -1311,7 +1311,7 @@ cy_as_usb_read_data(
    * Valid In Asynchronous Callback: YES
 
    Returns
-   * CY_AS_ERROR_SUCCESS - this module was shut down sucessfully
+   * CY_AS_ERROR_SUCCESS - this module was shut down successfully
    * CY_AS_ERROR_TIMEOUT - a timeout occurred communicating with
    *	the West Bridge device
    * CY_AS_ERROR_NOT_RUNNING - the USB stack is not running
@@ -1355,7 +1355,7 @@ cy_as_usb_read_data_async(
    a zero length packet transmitted to the USB host.
 
    Returns
-   * CY_AS_ERROR_SUCCESS - this module was shut down sucessfully
+   * CY_AS_ERROR_SUCCESS - this module was shut down successfully
    * CY_AS_ERROR_TIMEOUT - a timeout occurred communicating with
    *	the West Bridge device
    * CY_AS_ERROR_NOT_RUNNING - the USB stack is not running
@@ -1395,7 +1395,7 @@ cy_as_usb_write_data(
    in a zero length packet transmitted to the USB host.
 
    Returns
-   * CY_AS_ERROR_SUCCESS - this module was shut down sucessfully
+   * CY_AS_ERROR_SUCCESS - this module was shut down successfully
    * CY_AS_ERROR_TIMEOUT - a timeout occurred communicating with
    *	the West Bridge device
    * CY_AS_ERROR_NOT_RUNNING - the USB stack is not running
@@ -1435,7 +1435,7 @@ cy_as_usb_write_data_async(
 
    Returns
    * CY_AS_ERROR_SUCCESS - this module was shut down
-   *	sucessfully
+   *	successfully
    * CY_AS_ERROR_NOT_RUNNING - the USB stack is not
    *	running
    * CY_AS_ERROR_ASYNC_NOT_PENDING - no asynchronous USB
@@ -1791,7 +1791,7 @@ cy_as_usb_set_m_s_report_threshold(
    device should be made visible to USB.
 
    Description
-   West Bridge firmware supports the creation of upto two
+   West Bridge firmware supports the creation of up to two
    partitions on mass storage devices connected to the West Bridge
    device.  When there are two partitions on a device, the user can
    choose which of these partitions should be made visible to the
diff --git a/drivers/staging/winbond/mds.c b/drivers/staging/winbond/mds.c
index 9cfea94..c9f0e8f 100644
--- a/drivers/staging/winbond/mds.c
+++ b/drivers/staging/winbond/mds.c
@@ -492,7 +492,7 @@ Mds_Tx(struct wbsoft_priv *adapter)
 
 			TxDesIndex = pMds->TxDesIndex; /* Get the current ID */
 			pTxDes->Descriptor_ID = TxDesIndex;
-			pMds->TxDesFrom[TxDesIndex] = 2; /* Storing the information of source comming from */
+			pMds->TxDesFrom[TxDesIndex] = 2; /* Storing the information of source coming from */
 			pMds->TxDesIndex++;
 			pMds->TxDesIndex %= MAX_USB_TX_DESCRIPTOR;
 
diff --git a/drivers/staging/wlags49_h2/README.ubuntu b/drivers/staging/wlags49_h2/README.ubuntu
index 47beaec..edee8b9 100644
--- a/drivers/staging/wlags49_h2/README.ubuntu
+++ b/drivers/staging/wlags49_h2/README.ubuntu
@@ -116,7 +116,7 @@ LICENSE
 
 The Agere Systems license applies. This is why I include the original
 README.wlags49. The instructions in that file are bogus now. I also
-include the man page. Eventhough setting parameters on the module
+include the man page. Even though setting parameters on the module
 does not work anymore but it provides some information about all the
 settings.
 
diff --git a/drivers/staging/wlags49_h2/TODO b/drivers/staging/wlags49_h2/TODO
index 14aa415..94032b6 100644
--- a/drivers/staging/wlags49_h2/TODO
+++ b/drivers/staging/wlags49_h2/TODO
@@ -1,7 +1,7 @@
 First of all, the best thing would be that this driver becomes obsolte by
 adding support for Hermes II and Hermes II.5 cards to the existing orinoco
 driver. The orinoco driver currently only supports Hermes I based cards.
-Since this will not happen by magic and has not happend until now this
+Since this will not happen by magic and has not happened until now this
 driver provides a stop-gap solution for these type of cards.
 
 Having said that, the following wishlist comes to mind to make the driver
@@ -18,7 +18,7 @@ TODO:
 	- the driver is split into a Hermes II and a Hermes II.5 part, it
 	  would be nice to handle both with one module instead of two
 	- review by the wireless developer community
-	- verify the code against the coding standards for a propper linux
+	- verify the code against the coding standards for a proper linux
 	  driver
 	- resolve license issues (?)
 
diff --git a/drivers/staging/wlags49_h2/hcf.c b/drivers/staging/wlags49_h2/hcf.c
index d4bdd3e..a73317e 100644
--- a/drivers/staging/wlags49_h2/hcf.c
+++ b/drivers/staging/wlags49_h2/hcf.c
@@ -540,7 +540,7 @@ HCF_STATIC hcf_16* BASED xxxx[ ] = {
 *
 *.CONDITIONS
 * Except for hcf_action with HCF_ACT_INT_FORCE_ON or HCF_ACT_INT_OFF as parameter or hcf_connect with an I/O
-* address (i.e. not HCF_DISCONNECT), all hcf-function calls MUST be preceeded by a call of hcf_action with
+* address (i.e. not HCF_DISCONNECT), all hcf-function calls MUST be preceded by a call of hcf_action with
 * HCF_ACT_INT_OFF as parameter.
 * Note that hcf_connect defaults to NIC interrupt disabled mode, i.e. as if hcf_action( HCF_ACT_INT_OFF )
 * was called.
@@ -843,7 +843,7 @@ hcf_16	i;
 *.MODULE		int hcf_cntl( IFBP ifbp, hcf_16 cmd )
 *.PURPOSE		Connect or disconnect a specific port to a specific network.
 *!!  ;???????????????? continue needs more explanation
-*				recovers by means of "continue" when the connect proces in CCX mode fails
+*				recovers by means of "continue" when the connect process in CCX mode fails
 *				Enables or disables data transmission and reception for the NIC.
 *				Activates static NIC configuration for a specific port at connect.
 *				Activates static configuration for all ports at enable.
@@ -1170,12 +1170,12 @@ LTV_STRCT	x;
 		io_addr = io_base;
 	}
 
-#if 0 //;? if a subsequent hcf_connect is preceeded by an hcf_disconnect the wakeup is not needed !!
+#if 0 //;? if a subsequent hcf_connect is preceded by an hcf_disconnect the wakeup is not needed !!
 #if HCF_SLEEP
     OUT_PORT_WORD( .....+HREG_IO, HREG_IO_WAKEUP_ASYNC ); 	    //OPW not yet useable
 	MSF_WAIT(800);								// MSF-defined function to wait n microseconds.
 	note that MSF_WAIT uses not yet defined!!!! IFB_IOBase and IFB_TickIni (via PROT_CNT_INI)
-	so be carefull if this code is restored
+	so be careful if this code is restored
 #endif // HCF_SLEEP
 #endif // 0
 
@@ -1563,7 +1563,7 @@ DESC_STRCT *p = descp->next_desc_addr;	//pointer to 2nd descriptor of frame
 * This function is called by the MSF to supply the HCF with new/more buffers for receive purposes.
 * The HCF can be used in 2 fashions: with and without encapsulation for data transfer.
 * This is controlled at compile time by the HCF_ENC bit of the HCF_ENCAP system constant.
-* As a consequence, some additional constaints apply to the number of descriptor and the buffers associated
+* As a consequence, some additional constraints apply to the number of descriptor and the buffers associated
 * with the first 2 descriptors. Independent of the encapsulation feature, the COUNT fields are ignored.
 * A special case is the supplying of the DELWA descriptor, which must be supplied as the first descriptor.
 *
@@ -1735,7 +1735,7 @@ DESC_STRCT *descp;	// pointer to start of FrameList
 * - in case encapsulation by the HCF is selected:
 *	  -	The FrameList does not consists of at least 2 Descriptors.
 *	  -	The first databuffer does not contain exactly the (space for) the 802.11 header (== 28 words)
-*	  -	The first databuffer does not have a size to additionally accomodate the 802.3 header and the
+*	  -	The first databuffer does not have a size to additionally accommodate the 802.3 header and the
 *		SNAP header of the frame after encapsulation (== 39 words).
 *	  -	The second databuffer does not contain at least DA, SA and 'type/length' (==14 bytes or 7 words)
 *!! The 2nd part of the list of asserts should be kept in sync with put_frame_lst, in order to get
@@ -1762,14 +1762,14 @@ DESC_STRCT *descp;	// pointer to start of FrameList
 *	- Copy DA/SA fields from the 2nd buffer
 *   - Calculate total length of the message (snap-header + type-field + the length of all buffer fragments
 *     associated with the 802.3 frame (i.e all descriptors except the first), but not the DestinationAddress,
-*     SourceAddress and lenght-field)
+*     SourceAddress and length-field)
 *     Assert the message length
 *	  Write length. Note that the message is in BE format, hence on LE platforms the length must be converted
 *	  ;? THIS IS NOT WHAT CURRENTLY IS IMPLEMENTED
 *	- Write snap header. Note that the last byte of the snap header is NOT copied, that byte is already in
 *	  place as result of the call to hcf_encap.
 *	Note that there are many ways to skin a cat. To express the offsets in the 1st buffer while writing
-*	the snap header, HFS_TYPE is choosen as a reference point to make it easier to grasp that the snap header
+*	the snap header, HFS_TYPE is chosen as a reference point to make it easier to grasp that the snap header
 *	and encapsualtion type are at least relative in the right.
 *8:	modify 1st descriptor to reflect moved part of the 802.3 header + Snap-header
 *	modify 2nd descriptor to skip the moved part of the 802.3 header (DA/SA
@@ -1933,7 +1933,7 @@ hcf_16	t = (hcf_16)(*type<<8) + *(type+1);																/* 2 */
 *	HCF_SUCCESS			Success
 *!!	via cmd_exe ( type >= CFG_RID_FW_MIN )
 *	HCF_ERR_NO_NIC		NIC removed during retrieval
-*	HCF_ERR_TIME_OUT	Expected Hermes event did not occure in expected time
+*	HCF_ERR_TIME_OUT	Expected Hermes event did not occur in expected time
 *!!	via cmd_exe and setup_bap (type >= CFG_RID_FW_MIN )
 *	HCF_ERR_DEFUNCT_...	HCF is in defunct mode (bits 0x7F reflect cause)
 *
@@ -2958,7 +2958,7 @@ or
 *	hcf_service_nic is also skipped in those cases.
 *	To prevent that hcf_service_nic reports bogus information to the MSF with all - possibly difficult to
 *	debug - undesirable side effects, it is paramount to check the NIC presence. In former days the presence
-*	test was based on the Hermes register HREG_SW_0. Since in HCF_ACT_INT_OFF is choosen for strategy based on
+*	test was based on the Hermes register HREG_SW_0. Since in HCF_ACT_INT_OFF is chosen for strategy based on
 *	HREG_EV_STAT, this is now also used in hcf_service_nic. The motivation to change strategy is partly
 *	due to inconsistent F/W implementations with respect to HREG_SW_0 manipulation around reset and download.
 *	Note that in polled environments Card Removal is not detected by INT_OFF which makes the check in
@@ -4048,7 +4048,7 @@ hcf_32 FAR	*p4; //prevent side effects from macro
 	HCFASSERT( word_len == 0 || word_len == 2 || word_len == 4, word_len )
 	HCFASSERT( word_len == 0 || ((hcf_32)bufp & 1 ) == 0, (hcf_32)bufp )
 	HCFASSERT( word_len <= len, MERGE2( word_len, len ) )
-	//see put_frag for an alternative implementation, but be carefull about what are int's and what are
+	//see put_frag for an alternative implementation, but be careful about what are int's and what are
 	//hcf_16's
 	if ( word_len ) {								//.  if there is anything to convert
 hcf_8 c;
@@ -4712,7 +4712,7 @@ int rc = HCF_SUCCESS;
 *	Note that len is unsigned, so even MSF I/F violation works out O.K.
 *	The '2' in the expression "len+2" is used because 1 word is needed for L itself and 1 word is needed
 *	for the zero-sentinel
-*8:	update MailBox Info length report to MSF with "oldest" MB Info Block size. Be carefull here, if you get
+*8:	update MailBox Info length report to MSF with "oldest" MB Info Block size. Be careful here, if you get
 *	here before the MailBox is registered, you can't read from the buffer addressed by IFB_MBp (it is the
 *	Null buffer) so don't move this code till the end of this routine but keep it where there is garuanteed
 *	a buffer.
diff --git a/drivers/staging/wlags49_h2/hcfdef.h b/drivers/staging/wlags49_h2/hcfdef.h
index 4e20171..cb1966d 100644
--- a/drivers/staging/wlags49_h2/hcfdef.h
+++ b/drivers/staging/wlags49_h2/hcfdef.h
@@ -315,7 +315,7 @@ err: these values should match;
 
 #if HCF_DMA
 //************************* DMA (bus mastering)
-	// Be carefull to use these registers only at a genuine 32 bits NIC
+	// Be careful to use these registers only at a genuine 32 bits NIC
 	// On 16 bits NICs, these addresses are mapped into the range 0x00 through 0x3F with all consequences
 	// thereof, e.g.  HREG_DMA_CTRL register maps to HREG_CMD.
 #define HREG_DMA_CTRL						0x0040
diff --git a/drivers/staging/wlags49_h2/wl_wext.c b/drivers/staging/wlags49_h2/wl_wext.c
index 9e5da08..522a310 100644
--- a/drivers/staging/wlags49_h2/wl_wext.c
+++ b/drivers/staging/wlags49_h2/wl_wext.c
@@ -2575,7 +2575,7 @@ static int wireless_set_scan(struct net_device *dev, struct iw_request_info *inf
          * This looks like a nice place to test if the HCF is still
          * communicating with the card. It seems that sometimes BAP_1
          * gets corrupted. By looking at the comments in HCF the
-         * cause is still a mistery. Okay, the communication to the
+         * cause is still a mystery. Okay, the communication to the
          * card is dead, reset the card to revive.
          */
 	if((lp->hcfCtx.IFB_CardStat & CARD_STAT_DEFUNCT) != 0)
@@ -3924,7 +3924,7 @@ void wl_wext_event_mic_failed( struct net_device *dev )
 	memset( msg, 0, sizeof( msg ));
 
 
-	/* Becuase MIC failures are not part of the Wireless Extensions yet, they
+	/* Because MIC failures are not part of the Wireless Extensions yet, they
 	   must be passed as a string using an IWEVCUSTOM event. In order for the
 	   event to be effective, the string format must be known by both the
 	   driver and the supplicant. The following is the string format used by the
@@ -3999,7 +3999,7 @@ void wl_wext_event_assoc_ie( struct net_device *dev )
 		memcpy( &data.rawData, &( lp->ltvRecord.u.u8[1] ), 88 );
 		wpa_ie = wl_parse_wpa_ie( &data, &length );
 
-		/* Becuase this event (Association WPA-IE) is not part of the Wireless
+		/* Because this event (Association WPA-IE) is not part of the Wireless
 		Extensions yet, it must be passed as a string using an IWEVCUSTOM event.
 		In order for the event to be effective, the string format must be known
 		by both the driver and the supplicant. The following is the string format
diff --git a/drivers/staging/wlags49_h25/TODO b/drivers/staging/wlags49_h25/TODO
index 14aa415..94032b6 100644
--- a/drivers/staging/wlags49_h25/TODO
+++ b/drivers/staging/wlags49_h25/TODO
@@ -1,7 +1,7 @@
 First of all, the best thing would be that this driver becomes obsolte by
 adding support for Hermes II and Hermes II.5 cards to the existing orinoco
 driver. The orinoco driver currently only supports Hermes I based cards.
-Since this will not happen by magic and has not happend until now this
+Since this will not happen by magic and has not happened until now this
 driver provides a stop-gap solution for these type of cards.
 
 Having said that, the following wishlist comes to mind to make the driver
@@ -18,7 +18,7 @@ TODO:
 	- the driver is split into a Hermes II and a Hermes II.5 part, it
 	  would be nice to handle both with one module instead of two
 	- review by the wireless developer community
-	- verify the code against the coding standards for a propper linux
+	- verify the code against the coding standards for a proper linux
 	  driver
 	- resolve license issues (?)
 
diff --git a/drivers/staging/wlan-ng/prism2sta.c b/drivers/staging/wlan-ng/prism2sta.c
index ed751f4..21f25a2 100644
--- a/drivers/staging/wlan-ng/prism2sta.c
+++ b/drivers/staging/wlan-ng/prism2sta.c
@@ -1976,7 +1976,7 @@ static wlandevice_t *create_wlan(void)
 
 	wlandev->nsdcaps = P80211_NSDCAP_HWFRAGMENT | P80211_NSDCAP_AUTOJOIN;
 
-	/* Initialize the device private data stucture. */
+	/* Initialize the device private data structure. */
 	hw->dot11_desired_bss_type = 1;
 
 	return wlandev;
diff --git a/drivers/staging/xgifb/vb_setmode.c b/drivers/staging/xgifb/vb_setmode.c
index 8762a53..9669c22 100644
--- a/drivers/staging/xgifb/vb_setmode.c
+++ b/drivers/staging/xgifb/vb_setmode.c
@@ -7834,7 +7834,7 @@ unsigned short XGI_GetRatePtrCRT2(struct xgi_hw_device_info *pXGIHWDE,
 						== 600)) {
 			index++;
 		}
-		/* Alan 10/19/2007; do the similiar adjustment like XGISearchCRT1Rate() */
+		/* Alan 10/19/2007; do the similar adjustment like XGISearchCRT1Rate() */
 		if ((pVBInfo->RefIndex[RefreshRateTableIndex].XRes == 1024)
 				&& (pVBInfo->RefIndex[RefreshRateTableIndex].YRes
 						== 768)) {
diff --git a/drivers/staging/xgifb/vgatypes.h b/drivers/staging/xgifb/vgatypes.h
index 4b87951..d613e84 100644
--- a/drivers/staging/xgifb/vgatypes.h
+++ b/drivers/staging/xgifb/vgatypes.h
@@ -85,7 +85,7 @@ struct xgi_hw_device_info
 					    unsigned long *);
 };
 
-/* Addtional IOCTL for communication xgifb <> X driver        */
+/* Additional IOCTL for communication xgifb <> X driver        */
 /* If changing this, xgifb.h must also be changed (for xgifb) */
 
 
diff --git a/drivers/target/target_core_alua.c b/drivers/target/target_core_alua.c
index 2c5fcfe..30cbb74 100644
--- a/drivers/target/target_core_alua.c
+++ b/drivers/target/target_core_alua.c
@@ -496,8 +496,8 @@ static int core_alua_state_check(
 	nonop_delay_msecs = tg_pt_gp->tg_pt_gp_nonop_delay_msecs;
 	spin_unlock(&tg_pt_gp_mem->tg_pt_gp_mem_lock);
 	/*
-	 * Process ALUA_ACCESS_STATE_ACTIVE_OPTMIZED in a seperate conditional
-	 * statement so the complier knows explictly to check this case first.
+	 * Process ALUA_ACCESS_STATE_ACTIVE_OPTMIZED in a separate conditional
+	 * statement so the compiler knows explicitly to check this case first.
 	 * For the Optimized ALUA access state case, we want to process the
 	 * incoming fabric cmd ASAP..
 	 */
@@ -1157,7 +1157,7 @@ void core_alua_free_lu_gp(struct t10_alua_lu_gp *lu_gp)
 		spin_unlock(&lu_gp->lu_gp_lock);
 		/*
 		 *
-		 * lu_gp_mem is assoicated with a single
+		 * lu_gp_mem is associated with a single
 		 * struct se_device->dev_alua_lu_gp_mem, and is released when
 		 * struct se_device is released via core_alua_free_lu_gp_mem().
 		 *
@@ -1429,7 +1429,7 @@ void core_alua_free_tg_pt_gp(
 		}
 		spin_unlock(&tg_pt_gp->tg_pt_gp_lock);
 		/*
-		 * tg_pt_gp_mem is assoicated with a single
+		 * tg_pt_gp_mem is associated with a single
 		 * se_port->sep_alua_tg_pt_gp_mem, and is released via
 		 * core_alua_free_tg_pt_gp_mem().
 		 *
@@ -1963,7 +1963,7 @@ int core_setup_alua(struct se_device *dev, int force_pt)
 		printk(KERN_INFO "%s: Enabling ALUA Emulation for SPC-3"
 			" device\n", TRANSPORT(dev)->name);
 		/*
-		 * Assoicate this struct se_device with the default ALUA
+		 * Associate this struct se_device with the default ALUA
 		 * LUN Group.
 		 */
 		lu_gp_mem = core_alua_allocate_lu_gp_mem(dev);
diff --git a/drivers/target/target_core_device.c b/drivers/target/target_core_device.c
index 3fb8e32..d25e208 100644
--- a/drivers/target/target_core_device.c
+++ b/drivers/target/target_core_device.c
@@ -371,7 +371,7 @@ int core_update_device_list_for_node(
 	if (!(enable)) {
 		/*
 		 * deve->se_lun_acl will be NULL for demo-mode created LUNs
-		 * that have not been explictly concerted to MappedLUNs ->
+		 * that have not been explicitly concerted to MappedLUNs ->
 		 * struct se_lun_acl, but we remove deve->alua_port_list from
 		 * port->sep_alua_list. This also means that active UAs and
 		 * NodeACL context specific PR metadata for demo-mode
diff --git a/drivers/target/target_core_fabric_lib.c b/drivers/target/target_core_fabric_lib.c
index d57ad67..1e193f3 100644
--- a/drivers/target/target_core_fabric_lib.c
+++ b/drivers/target/target_core_fabric_lib.c
@@ -433,7 +433,7 @@ char *iscsi_parse_pr_out_transport_id(
 		/*
 		 * Go ahead and do the lower case conversion of the received
 		 * 12 ASCII characters representing the ISID in the TransportID
-		 * for comparision against the running iSCSI session's ISID from
+		 * for comparison against the running iSCSI session's ISID from
 		 * iscsi_target.c:lio_sess_get_initiator_sid()
 		 */
 		for (i = 0; i < 12; i++) {
diff --git a/drivers/target/target_core_file.c b/drivers/target/target_core_file.c
index 02f553a..150c430 100644
--- a/drivers/target/target_core_file.c
+++ b/drivers/target/target_core_file.c
@@ -159,7 +159,7 @@ static struct se_device *fd_create_virtdevice(
 #endif
 /*	flags |= O_DIRECT; */
 	/*
-	 * If fd_buffered_io=1 has not been set explictly (the default),
+	 * If fd_buffered_io=1 has not been set explicitly (the default),
 	 * use O_SYNC to force FILEIO writes to disk.
 	 */
 	if (!(fd_dev->fbd_flags & FDBD_USE_BUFFERED_IO))
diff --git a/drivers/target/target_core_pr.c b/drivers/target/target_core_pr.c
index 2521f75..a79f518 100644
--- a/drivers/target/target_core_pr.c
+++ b/drivers/target/target_core_pr.c
@@ -478,7 +478,7 @@ static int core_scsi3_pr_seq_non_holder(
 		break;
 	}
 	/*
-	 * Case where the CDB is explictly allowed in the above switch
+	 * Case where the CDB is explicitly allowed in the above switch
 	 * statement.
 	 */
 	if (!(ret) && !(other_cdb)) {
@@ -3735,7 +3735,7 @@ static int core_scsi3_emulate_pr_out(struct se_cmd *cmd, unsigned char *cdb)
 		return PYX_TRANSPORT_LU_COMM_FAILURE;
 
 	if (cmd->data_length < 24) {
-		printk(KERN_WARNING "SPC-PR: Recieved PR OUT parameter list"
+		printk(KERN_WARNING "SPC-PR: Received PR OUT parameter list"
 			" length too small: %u\n", cmd->data_length);
 		return PYX_TRANSPORT_INVALID_PARAMETER_LIST;
 	}
@@ -3778,7 +3778,7 @@ static int core_scsi3_emulate_pr_out(struct se_cmd *cmd, unsigned char *cdb)
 	 */
 	if (!(spec_i_pt) && ((cdb[1] & 0x1f) != PRO_REGISTER_AND_MOVE) &&
 	    (cmd->data_length != 24)) {
-		printk(KERN_WARNING "SPC-PR: Recieved PR OUT illegal parameter"
+		printk(KERN_WARNING "SPC-PR: Received PR OUT illegal parameter"
 			" list length: %u\n", cmd->data_length);
 		return PYX_TRANSPORT_INVALID_PARAMETER_LIST;
 	}
diff --git a/drivers/target/target_core_transport.c b/drivers/target/target_core_transport.c
index bf6aa8a..9583b23 100644
--- a/drivers/target/target_core_transport.c
+++ b/drivers/target/target_core_transport.c
@@ -719,7 +719,7 @@ static int transport_cmd_check_stop(
 			cmd->se_lun = NULL;
 			/*
 			 * Some fabric modules like tcm_loop can release
-			 * their internally allocated I/O refrence now and
+			 * their internally allocated I/O reference now and
 			 * struct se_cmd now.
 			 */
 			if (CMD_TFO(cmd)->check_stop_free != NULL) {
@@ -2029,7 +2029,7 @@ int transport_generic_handle_data(
 	 * If the received CDB has aleady been ABORTED by the generic
 	 * target engine, we now call transport_check_aborted_status()
 	 * to queue any delated TASK_ABORTED status for the received CDB to the
-	 * fabric module as we are expecting no futher incoming DATA OUT
+	 * fabric module as we are expecting no further incoming DATA OUT
 	 * sequences at this point.
 	 */
 	if (transport_check_aborted_status(cmd, 1) != 0)
@@ -2501,7 +2501,7 @@ static inline int transport_execute_task_attr(struct se_cmd *cmd)
 	if (SE_DEV(cmd)->dev_task_attr_type != SAM_TASK_ATTR_EMULATED)
 		return 1;
 	/*
-	 * Check for the existance of HEAD_OF_QUEUE, and if true return 1
+	 * Check for the existence of HEAD_OF_QUEUE, and if true return 1
 	 * to allow the passed struct se_cmd list of tasks to the front of the list.
 	 */
 	 if (cmd->sam_task_attr == TASK_ATTR_HOQ) {
@@ -2547,7 +2547,7 @@ static inline int transport_execute_task_attr(struct se_cmd *cmd)
 	if (atomic_read(&SE_DEV(cmd)->dev_ordered_sync) != 0) {
 		/*
 		 * Otherwise, add cmd w/ tasks to delayed cmd queue that
-		 * will be drained upon competion of HEAD_OF_QUEUE task.
+		 * will be drained upon completion of HEAD_OF_QUEUE task.
 		 */
 		spin_lock(&SE_DEV(cmd)->delayed_cmd_lock);
 		cmd->se_cmd_flags |= SCF_DELAYED_CMD_FROM_SAM_ATTR;
@@ -2589,7 +2589,7 @@ static int transport_execute_tasks(struct se_cmd *cmd)
 	}
 	/*
 	 * Call transport_cmd_check_stop() to see if a fabric exception
-	 * has occured that prevents execution.
+	 * has occurred that prevents execution.
 	 */
 	if (!(transport_cmd_check_stop(cmd, 0, TRANSPORT_PROCESSING))) {
 		/*
@@ -3109,7 +3109,7 @@ static int transport_generic_cmd_sequencer(
 	if (ret != 0) {
 		cmd->transport_wait_for_tasks = &transport_nop_wait_for_tasks;
 		/*
-		 * Set SCSI additional sense code (ASC) to 'LUN Not Accessable';
+		 * Set SCSI additional sense code (ASC) to 'LUN Not Accessible';
 		 * The ALUA additional sense code qualifier (ASCQ) is determined
 		 * by the ALUA primary or secondary access state..
 		 */
@@ -3867,7 +3867,7 @@ static void transport_generic_complete_ok(struct se_cmd *cmd)
 		}
 	}
 	/*
-	 * Check for a callback, used by amoungst other things
+	 * Check for a callback, used by amongst other things
 	 * XDWRITE_READ_10 emulation.
 	 */
 	if (cmd->transport_complete_callback)
diff --git a/drivers/target/target_core_ua.c b/drivers/target/target_core_ua.c
index a2ef346..df35517 100644
--- a/drivers/target/target_core_ua.c
+++ b/drivers/target/target_core_ua.c
@@ -247,7 +247,7 @@ void core_scsi3_ua_for_check_condition(
 		}
 		/*
 		 * Otherwise for the default 00b, release the UNIT ATTENTION
-		 * condition.  Return the ASC/ASCQ of the higest priority UA
+		 * condition.  Return the ASC/ASCQ of the highest priority UA
 		 * (head of the list) in the outgoing CHECK_CONDITION + sense.
 		 */
 		if (head) {
@@ -304,7 +304,7 @@ int core_scsi3_ua_clear_for_request_sense(
 	 * matching struct se_lun.
 	 *
 	 * Once the returning ASC/ASCQ values are set, we go ahead and
-	 * release all of the Unit Attention conditions for the assoicated
+	 * release all of the Unit Attention conditions for the associated
 	 * struct se_lun.
 	 */
 	spin_lock(&deve->ua_lock);
diff --git a/drivers/telephony/ixj.c b/drivers/telephony/ixj.c
index b001019..d5f923b 100644
--- a/drivers/telephony/ixj.c
+++ b/drivers/telephony/ixj.c
@@ -169,7 +169,7 @@
  * Added support for Linux 2.4.x kernels.
  *
  * Revision 3.77  2001/01/09 04:00:52  eokerson
- * Linetest will now test the line, even if it has previously succeded.
+ * Linetest will now test the line, even if it has previously succeeded.
  *
  * Revision 3.76  2001/01/08 19:27:00  eokerson
  * Fixed problem with standard cable on Internet PhoneCARD.
@@ -352,7 +352,7 @@ static void ixj_fsk_alloc(IXJ *j)
 		} else {
 			j->fsksize = 8000;
 			if(ixjdebug & 0x0200) {
-				printk("IXJ phone%d - allocate succeded\n", j->board);
+				printk("IXJ phone%d - allocate succeeded\n", j->board);
 			}
 		}
 	}
@@ -487,7 +487,7 @@ DSPbase +
 8-9		Hardware Status Register			Read Only
 A-B		Hardware Control Register			Read Write
 C-D Host Transmit (Write) Data Buffer Access Port (buffer input)Write Only
-E-F Host Recieve (Read) Data Buffer Access Port (buffer input)	Read Only
+E-F Host Receive (Read) Data Buffer Access Port (buffer input)	Read Only
 ************************************************************************/
 
 static inline void ixj_read_HSR(IXJ *j)
@@ -4195,7 +4195,7 @@ static void ixj_aec_start(IXJ *j, int level)
 			ixj_WriteDSPCommand(0xE338, j);	/* Set Echo Suppresser Attenuation to 0dB */
 
 			/* Now we can set the AGC initial parameters and turn it on */
-			ixj_WriteDSPCommand(0xCF90, j);	/* Set AGC Minumum gain */
+			ixj_WriteDSPCommand(0xCF90, j);	/* Set AGC Minimum gain */
 			ixj_WriteDSPCommand(0x0020, j);	/* to 0.125 (-18dB) */
 	
 			ixj_WriteDSPCommand(0xCF91, j);	/* Set AGC Maximum gain */
diff --git a/drivers/telephony/ixj.h b/drivers/telephony/ixj.h
index 4c32a43..2c84113 100644
--- a/drivers/telephony/ixj.h
+++ b/drivers/telephony/ixj.h
@@ -1149,7 +1149,7 @@ typedef struct {
 	unsigned int firstring:1; /* First ring cadence is complete */
 	unsigned int pstncheck:1;	/* Currently checking the PSTN Line */
 	unsigned int pstn_rmr:1;
-	unsigned int x:3;	/* unsed bits */
+	unsigned int x:3;	/* unused bits */
 
 } IXJ_FLAGS;
 
diff --git a/drivers/tty/hvc/hvc_iucv.c b/drivers/tty/hvc/hvc_iucv.c
index c3425bb..b6f7d52 100644
--- a/drivers/tty/hvc/hvc_iucv.c
+++ b/drivers/tty/hvc/hvc_iucv.c
@@ -255,7 +255,7 @@ static int hvc_iucv_write(struct hvc_iucv_private *priv,
 		default:
 			written = -EIO;
 		}
-		/* remove buffer if an error has occured or received data
+		/* remove buffer if an error has occurred or received data
 		 * is not correct */
 		if (rc || (rb->mbuf->version != MSG_VERSION) ||
 			  (rb->msg.length    != MSG_SIZE(rb->mbuf->datalen)))
@@ -620,7 +620,7 @@ static void hvc_iucv_hangup(struct hvc_iucv_private *priv)
  *		the index of an struct hvc_iucv_private instance.
  *
  * This routine notifies the HVC back-end that a tty hangup (carrier loss,
- * virtual or otherwise) has occured.
+ * virtual or otherwise) has occurred.
  * The z/VM IUCV HVC device driver ignores virtual hangups (vhangup())
  * to keep an existing IUCV communication path established.
  * (Background: vhangup() is called from user space (by getty or login) to
diff --git a/drivers/tty/hvc/hvc_vio.c b/drivers/tty/hvc/hvc_vio.c
index 5e2f52b..e6eea14 100644
--- a/drivers/tty/hvc/hvc_vio.c
+++ b/drivers/tty/hvc/hvc_vio.c
@@ -1,7 +1,7 @@
 /*
  * vio driver interface to hvc_console.c
  *
- * This code was moved here to allow the remaing code to be reused as a
+ * This code was moved here to allow the remaining code to be reused as a
  * generic polling mode with semi-reliable transport driver core to the
  * console and tty subsystems.
  *
diff --git a/drivers/tty/hvc/hvcs.c b/drivers/tty/hvc/hvcs.c
index bef238f..4c8b665 100644
--- a/drivers/tty/hvc/hvcs.c
+++ b/drivers/tty/hvc/hvcs.c
@@ -118,7 +118,7 @@
  * arch/powerepc/include/asm/hvcserver.h
  *
  * 1.3.2 -> 1.3.3 Replaced yield() in hvcs_close() with tty_wait_until_sent() to
- * prevent possible lockup with realtime scheduling as similarily pointed out by
+ * prevent possible lockup with realtime scheduling as similarly pointed out by
  * akpm in hvc_console.  Changed resulted in the removal of hvcs_final_close()
  * to reorder cleanup operations and prevent discarding of pending data during
  * an hvcs_close().  Removed spinlock protection of hvcs_struct data members in
@@ -581,7 +581,7 @@ static void hvcs_try_write(struct hvcs_struct *hvcsd)
 			/*
 			 * We are still obligated to deliver the data to the
 			 * hypervisor even if the tty has been closed because
-			 * we commited to delivering it.  But don't try to wake
+			 * we committed to delivering it.  But don't try to wake
 			 * a non-existent tty.
 			 */
 			if (tty) {
@@ -1349,7 +1349,7 @@ static int hvcs_write(struct tty_struct *tty,
 	spin_lock_irqsave(&hvcsd->lock, flags);
 
 	/*
-	 * Somehow an open succedded but the device was removed or the
+	 * Somehow an open succeeded but the device was removed or the
 	 * connection terminated between the vty-server and partner vty during
 	 * the middle of a write operation?  This is a crummy place to do this
 	 * but we want to keep it all in the spinlock.
@@ -1420,7 +1420,7 @@ static int hvcs_write(struct tty_struct *tty,
 }
 
 /*
- * This is really asking how much can we guarentee that we can send or that we
+ * This is really asking how much can we guarantee that we can send or that we
  * absolutely WILL BUFFER if we can't send it.  This driver MUST honor the
  * return value, hence the reason for hvcs_struct buffering.
  */
diff --git a/drivers/tty/mxser.h b/drivers/tty/mxser.h
index 41878a6..0bf7943 100644
--- a/drivers/tty/mxser.h
+++ b/drivers/tty/mxser.h
@@ -113,7 +113,7 @@
 #define MOXA_MUST_IIR_RTO		0x0C
 #define MOXA_MUST_IIR_LSR		0x06
 
-/* recieved Xon/Xoff or specical interrupt pending */
+/* received Xon/Xoff or specical interrupt pending */
 #define MOXA_MUST_IIR_XSC		0x10
 
 /* RTS/CTS change state interrupt pending */
diff --git a/drivers/tty/n_gsm.c b/drivers/tty/n_gsm.c
index 176f632..47f8cdb 100644
--- a/drivers/tty/n_gsm.c
+++ b/drivers/tty/n_gsm.c
@@ -74,7 +74,7 @@ module_param(debug, int, 0600);
 #endif
 
 /*
- * Semi-arbitary buffer size limits. 0710 is normally run with 32-64 byte
+ * Semi-arbitrary buffer size limits. 0710 is normally run with 32-64 byte
  * limits so this is plenty
  */
 #define MAX_MRU 512
@@ -82,7 +82,7 @@ module_param(debug, int, 0600);
 
 /*
  *	Each block of data we have queued to go out is in the form of
- *	a gsm_msg which holds everything we need in a link layer independant
+ *	a gsm_msg which holds everything we need in a link layer independent
  *	format
  */
 
@@ -1193,8 +1193,8 @@ static void gsm_control_message(struct gsm_mux *gsm, unsigned int command,
 		break;
 		/* Optional unsupported commands */
 	case CMD_PN:	/* Parameter negotiation */
-	case CMD_RPN:	/* Remote port negotation */
-	case CMD_SNC:	/* Service negotation command */
+	case CMD_RPN:	/* Remote port negotiation */
+	case CMD_SNC:	/* Service negotiation command */
 	default:
 		/* Reply to bad commands with an NSC */
 		buf[0] = command;
@@ -2026,7 +2026,7 @@ EXPORT_SYMBOL_GPL(gsm_activate_mux);
  *	@mux: mux to free
  *
  *	Dispose of allocated resources for a dead mux. No refcounting
- *	at present so the mux must be truely dead.
+ *	at present so the mux must be truly dead.
  */
 void gsm_free_mux(struct gsm_mux *gsm)
 {
diff --git a/drivers/tty/nozomi.c b/drivers/tty/nozomi.c
index f4f1116..fd0a9852 100644
--- a/drivers/tty/nozomi.c
+++ b/drivers/tty/nozomi.c
@@ -1673,7 +1673,7 @@ static void ntty_hangup(struct tty_struct *tty)
 
 /*
  * called when the userspace process writes to the tty (/dev/noz*).
- * Data is inserted into a fifo, which is then read and transfered to the modem.
+ * Data is inserted into a fifo, which is then read and transferred to the modem.
  */
 static int ntty_write(struct tty_struct *tty, const unsigned char *buffer,
 		      int count)
diff --git a/drivers/tty/rocket.c b/drivers/tty/rocket.c
index 3780da8..036feeb 100644
--- a/drivers/tty/rocket.c
+++ b/drivers/tty/rocket.c
@@ -2060,7 +2060,7 @@ static __init int register_PCI(int i, struct pci_dev *dev)
 			sClockPrescale = 0x19;
 			rp_baud_base[i] = 230400;
 		} else {
-			/* mod 4 (devide by 5) prescale */
+			/* mod 4 (divide by 5) prescale */
 			sClockPrescale = 0x14;
 			rp_baud_base[i] = 460800;
 		}
@@ -2183,7 +2183,7 @@ static int __init init_ISA(int i)
 		sClockPrescale = 0x19;	/* mod 9 (divide by 10) prescale */
 		rp_baud_base[i] = 230400;
 	} else {
-		sClockPrescale = 0x14;	/* mod 4 (devide by 5) prescale */
+		sClockPrescale = 0x14;	/* mod 4 (divide by 5) prescale */
 		rp_baud_base[i] = 460800;
 	}
 
diff --git a/drivers/tty/serial/8250.c b/drivers/tty/serial/8250.c
index b3b881b..6611535 100644
--- a/drivers/tty/serial/8250.c
+++ b/drivers/tty/serial/8250.c
@@ -1629,7 +1629,7 @@ static irqreturn_t serial8250_interrupt(int irq, void *dev_id)
 			    up->port.iotype == UPIO_DWAPB32) &&
 			  (iir & UART_IIR_BUSY) == UART_IIR_BUSY) {
 			/* The DesignWare APB UART has an Busy Detect (0x07)
-			 * interrupt meaning an LCR write attempt occured while the
+			 * interrupt meaning an LCR write attempt occurred while the
 			 * UART was busy. The interrupt must be cleared by reading
 			 * the UART status register (USR) and the LCR re-written. */
 			unsigned int status;
diff --git a/drivers/tty/serial/8250_pci.c b/drivers/tty/serial/8250_pci.c
index 8b8930f..738cec9 100644
--- a/drivers/tty/serial/8250_pci.c
+++ b/drivers/tty/serial/8250_pci.c
@@ -433,7 +433,7 @@ static void __devexit sbs_exit(struct pci_dev *dev)
 /*
  * SIIG serial cards have an PCI interface chip which also controls
  * the UART clocking frequency. Each UART can be clocked independently
- * (except cards equiped with 4 UARTs) and initial clocking settings
+ * (except cards equipped with 4 UARTs) and initial clocking settings
  * are stored in the EEPROM chip. It can cause problems because this
  * version of serial driver doesn't support differently clocked UART's
  * on single PCI card. To prevent this, initialization functions set
diff --git a/drivers/tty/serial/amba-pl011.c b/drivers/tty/serial/amba-pl011.c
index 57731e8..6deee4e 100644
--- a/drivers/tty/serial/amba-pl011.c
+++ b/drivers/tty/serial/amba-pl011.c
@@ -520,7 +520,7 @@ static bool pl011_dma_tx_irq(struct uart_amba_port *uap)
 
 	/*
 	 * We don't have a TX buffer queued, so try to queue one.
-	 * If we succesfully queued a buffer, mask the TX IRQ.
+	 * If we successfully queued a buffer, mask the TX IRQ.
 	 */
 	if (pl011_dma_tx_refill(uap) > 0) {
 		uap->im &= ~UART011_TXIM;
diff --git a/drivers/tty/serial/icom.c b/drivers/tty/serial/icom.c
index 53a4682..8a869e5 100644
--- a/drivers/tty/serial/icom.c
+++ b/drivers/tty/serial/icom.c
@@ -1248,7 +1248,7 @@ static void icom_set_termios(struct uart_port *port,
 		}
 	}
 
-	/* Enable Transmitter and Reciever */
+	/* Enable Transmitter and Receiver */
 	offset =
 	    (unsigned long) &ICOM_PORT->statStg->rcv[0] -
 	    (unsigned long) ICOM_PORT->statStg;
diff --git a/drivers/tty/serial/imx.c b/drivers/tty/serial/imx.c
index dfcf4b1..cb36b0d 100644
--- a/drivers/tty/serial/imx.c
+++ b/drivers/tty/serial/imx.c
@@ -78,7 +78,7 @@
 #define  URXD_FRMERR     (1<<12)
 #define  URXD_BRK        (1<<11)
 #define  URXD_PRERR      (1<<10)
-#define  UCR1_ADEN       (1<<15) /* Auto dectect interrupt */
+#define  UCR1_ADEN       (1<<15) /* Auto detect interrupt */
 #define  UCR1_ADBR       (1<<14) /* Auto detect baud rate */
 #define  UCR1_TRDYEN     (1<<13) /* Transmitter ready interrupt enable */
 #define  UCR1_IDEN       (1<<12) /* Idle condition interrupt */
diff --git a/drivers/tty/serial/ip22zilog.c b/drivers/tty/serial/ip22zilog.c
index ebff4a1..7b1cda5 100644
--- a/drivers/tty/serial/ip22zilog.c
+++ b/drivers/tty/serial/ip22zilog.c
@@ -375,7 +375,7 @@ static void ip22zilog_transmit_chars(struct uart_ip22zilog_port *up,
 		 * be nice to transmit console writes just like we normally would for
 		 * a TTY line. (ie. buffered and TX interrupt driven).  That is not
 		 * easy because console writes cannot sleep.  One solution might be
-		 * to poll on enough port->xmit space becomming free.  -DaveM
+		 * to poll on enough port->xmit space becoming free.  -DaveM
 		 */
 		if (!(status & Tx_BUF_EMP))
 			return;
diff --git a/drivers/tty/serial/jsm/jsm.h b/drivers/tty/serial/jsm/jsm.h
index 38a509c..b704c8c 100644
--- a/drivers/tty/serial/jsm/jsm.h
+++ b/drivers/tty/serial/jsm/jsm.h
@@ -273,7 +273,7 @@ struct neo_uart_struct {
 	 u8 fctr;		/* WR	FCTR - Feature Control Reg */
 	 u8 efr;		/* WR	EFR - Enhanced Function Reg */
 	 u8 tfifo;		/* WR	TXCNT/TXTRG - Transmit FIFO Reg */
-	 u8 rfifo;		/* WR	RXCNT/RXTRG - Recieve FIFO Reg */
+	 u8 rfifo;		/* WR	RXCNT/RXTRG - Receive FIFO Reg */
 	 u8 xoffchar1;	/* WR	XOFF 1 - XOff Character 1 Reg */
 	 u8 xoffchar2;	/* WR	XOFF 2 - XOff Character 2 Reg */
 	 u8 xonchar1;	/* WR	XON 1 - Xon Character 1 Reg */
diff --git a/drivers/tty/serial/jsm/jsm_neo.c b/drivers/tty/serial/jsm/jsm_neo.c
index 7960d96..4538c3e 100644
--- a/drivers/tty/serial/jsm/jsm_neo.c
+++ b/drivers/tty/serial/jsm/jsm_neo.c
@@ -381,7 +381,7 @@ static void neo_copy_data_from_uart_to_queue(struct jsm_channel *ch)
 		/* Copy data from uart to the queue */
 		memcpy_fromio(ch->ch_rqueue + head, &ch->ch_neo_uart->txrxburst, n);
 		/*
-		 * Since RX_FIFO_DATA_ERROR was 0, we are guarenteed
+		 * Since RX_FIFO_DATA_ERROR was 0, we are guaranteed
 		 * that all the data currently in the FIFO is free of
 		 * breaks and parity/frame/orun errors.
 		 */
@@ -1210,7 +1210,7 @@ static irqreturn_t neo_intr(int irq, void *voidbrd)
 			 * Why would I check EVERY possibility of type of
 			 * interrupt, when we know its TXRDY???
 			 * Becuz for some reason, even tho we got triggered for TXRDY,
-			 * it seems to be occassionally wrong. Instead of TX, which
+			 * it seems to be occasionally wrong. Instead of TX, which
 			 * it should be, I was getting things like RXDY too. Weird.
 			 */
 			neo_parse_isr(brd, port);
diff --git a/drivers/tty/serial/max3107.h b/drivers/tty/serial/max3107.h
index 7ab63239..8415fc7 100644
--- a/drivers/tty/serial/max3107.h
+++ b/drivers/tty/serial/max3107.h
@@ -369,7 +369,7 @@ struct max3107_port {
 	struct spi_device *spi;
 
 #if defined(CONFIG_GPIOLIB)
-	/* GPIO chip stucture */
+	/* GPIO chip structure */
 	struct gpio_chip chip;
 #endif
 
diff --git a/drivers/tty/serial/mrst_max3110.c b/drivers/tty/serial/mrst_max3110.c
index 37e13c3..2f548af 100644
--- a/drivers/tty/serial/mrst_max3110.c
+++ b/drivers/tty/serial/mrst_max3110.c
@@ -23,7 +23,7 @@
  *    1 word. If SPI master controller doesn't support sclk frequency change,
  *    then the char need be sent out one by one with some delay
  *
- * 2. Currently only RX availabe interrrupt is used, no need for waiting TXE
+ * 2. Currently only RX available interrrupt is used, no need for waiting TXE
  *    interrupt for a low speed UART device
  */
 
diff --git a/drivers/tty/serial/mrst_max3110.h b/drivers/tty/serial/mrst_max3110.h
index d1ef43a..c37ea48 100644
--- a/drivers/tty/serial/mrst_max3110.h
+++ b/drivers/tty/serial/mrst_max3110.h
@@ -21,7 +21,7 @@
 
 #define WC_IRQ_MASK		(0xF << 8)
 #define WC_TXE_IRQ_ENABLE	(1 << 11)	/* TX empty irq */
-#define WC_RXA_IRQ_ENABLE	(1 << 10)	/* RX availabe irq */
+#define WC_RXA_IRQ_ENABLE	(1 << 10)	/* RX available irq */
 #define WC_PAR_HIGH_IRQ_ENABLE	(1 << 9)
 #define WC_REC_ACT_IRQ_ENABLE	(1 << 8)
 
diff --git a/drivers/tty/serial/msm_serial_hs.c b/drivers/tty/serial/msm_serial_hs.c
index b906f11..624701f 100644
--- a/drivers/tty/serial/msm_serial_hs.c
+++ b/drivers/tty/serial/msm_serial_hs.c
@@ -495,7 +495,7 @@ static void msm_hs_pm(struct uart_port *uport, unsigned int state,
  *
  * Interrupts should be disabled before we are called, as
  * we modify Set Baud rate
- * Set receive stale interrupt level, dependant on Bit Rate
+ * Set receive stale interrupt level, dependent on Bit Rate
  * Goal is to have around 8 ms before indicate stale.
  * roundup (((Bit Rate * .008) / 10) + 1
  */
@@ -1350,7 +1350,7 @@ static irqreturn_t msm_hs_rx_wakeup_isr(int irq, void *dev)
 
 	spin_lock_irqsave(&uport->lock, flags);
 	if (msm_uport->clk_state == MSM_HS_CLK_OFF) {
-		/* ignore the first irq - it is a pending irq that occured
+		/* ignore the first irq - it is a pending irq that occurred
 		 * before enable_irq() */
 		if (msm_uport->rx_wakeup.ignore)
 			msm_uport->rx_wakeup.ignore = 0;
diff --git a/drivers/tty/serial/omap-serial.c b/drivers/tty/serial/omap-serial.c
index 7635379..47cadf4 100644
--- a/drivers/tty/serial/omap-serial.c
+++ b/drivers/tty/serial/omap-serial.c
@@ -13,7 +13,7 @@
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
  *
- * Note: This driver is made seperate from 8250 driver as we cannot
+ * Note: This driver is made separate from 8250 driver as we cannot
  * over load 8250 driver with omap platform specific configuration for
  * features like DMA, it makes easier to implement features like DMA and
  * hardware flow control and software flow control configuration with
diff --git a/drivers/tty/serial/pmac_zilog.c b/drivers/tty/serial/pmac_zilog.c
index 5b9cde7..e1c8d4f 100644
--- a/drivers/tty/serial/pmac_zilog.c
+++ b/drivers/tty/serial/pmac_zilog.c
@@ -330,7 +330,7 @@ static struct tty_struct *pmz_receive_chars(struct uart_pmac_port *uap)
 		 * When that happens, I disable the receive side of the driver.
 		 * Note that what I've been experiencing is a real irq loop where
 		 * I'm getting flooded regardless of the actual port speed.
-		 * Something stange is going on with the HW
+		 * Something strange is going on with the HW
 		 */
 		if ((++loops) > 1000)
 			goto flood;
@@ -396,7 +396,7 @@ static void pmz_transmit_chars(struct uart_pmac_port *uap)
 		 * be nice to transmit console writes just like we normally would for
 		 * a TTY line. (ie. buffered and TX interrupt driven).  That is not
 		 * easy because console writes cannot sleep.  One solution might be
-		 * to poll on enough port->xmit space becomming free.  -DaveM
+		 * to poll on enough port->xmit space becoming free.  -DaveM
 		 */
 		if (!(status & Tx_BUF_EMP))
 			return;
@@ -809,7 +809,7 @@ static int pmz_set_scc_power(struct uart_pmac_port *uap, int state)
 #endif /* !CONFIG_PPC_PMAC */
 
 /*
- * FixZeroBug....Works around a bug in the SCC receving channel.
+ * FixZeroBug....Works around a bug in the SCC receiving channel.
  * Inspired from Darwin code, 15 Sept. 2000  -DanM
  *
  * The following sequence prevents a problem that is seen with O'Hare ASICs
diff --git a/drivers/tty/serial/samsung.c b/drivers/tty/serial/samsung.c
index 2335eda..9e2fa8d 100644
--- a/drivers/tty/serial/samsung.c
+++ b/drivers/tty/serial/samsung.c
@@ -64,7 +64,7 @@
 #define tx_enabled(port) ((port)->unused[0])
 #define rx_enabled(port) ((port)->unused[1])
 
-/* flag to ignore all characters comming in */
+/* flag to ignore all characters coming in */
 #define RXSTAT_DUMMY_READ (0x10000000)
 
 static inline struct s3c24xx_uart_port *to_ourport(struct uart_port *port)
@@ -291,7 +291,7 @@ static irqreturn_t s3c24xx_serial_tx_chars(int irq, void *id)
 		goto out;
 	}
 
-	/* if there isnt anything more to transmit, or the uart is now
+	/* if there isn't anything more to transmit, or the uart is now
 	 * stopped, disable the uart and exit
 	*/
 
diff --git a/drivers/tty/serial/sh-sci.c b/drivers/tty/serial/sh-sci.c
index eb7958c..920a6f9 100644
--- a/drivers/tty/serial/sh-sci.c
+++ b/drivers/tty/serial/sh-sci.c
@@ -812,7 +812,7 @@ static irqreturn_t sci_mpxed_interrupt(int irq, void *ptr)
 }
 
 /*
- * Here we define a transistion notifier so that we can update all of our
+ * Here we define a transition notifier so that we can update all of our
  * ports' baud rate when the peripheral clock changes.
  */
 static int sci_notifier(struct notifier_block *self,
@@ -1836,6 +1836,12 @@ static int __devinit serial_console_setup(struct console *co, char *options)
 	sci_port = &sci_ports[co->index];
 	port = &sci_port->port;
 
+	/*
+	 * Refuse to handle uninitialized ports.
+	 */
+	if (!port->ops)
+		return -ENODEV;
+
 	ret = sci_remap_port(port);
 	if (unlikely(ret != 0))
 		return ret;
@@ -1866,13 +1872,6 @@ static struct console serial_console = {
 	.data		= &sci_uart_driver,
 };
 
-static int __init sci_console_init(void)
-{
-	register_console(&serial_console);
-	return 0;
-}
-console_initcall(sci_console_init);
-
 static struct console early_serial_console = {
 	.name           = "early_ttySC",
 	.write          = serial_console_write,
@@ -1901,18 +1900,18 @@ static int __devinit sci_probe_earlyprintk(struct platform_device *pdev)
 	register_console(&early_serial_console);
 	return 0;
 }
+
+#define SCI_CONSOLE	(&serial_console)
+
 #else
 static inline int __devinit sci_probe_earlyprintk(struct platform_device *pdev)
 {
 	return -EINVAL;
 }
-#endif /* CONFIG_SERIAL_SH_SCI_CONSOLE */
 
-#if defined(CONFIG_SERIAL_SH_SCI_CONSOLE)
-#define SCI_CONSOLE	(&serial_console)
-#else
-#define SCI_CONSOLE	0
-#endif
+#define SCI_CONSOLE	NULL
+
+#endif /* CONFIG_SERIAL_SH_SCI_CONSOLE */
 
 static char banner[] __initdata =
 	KERN_INFO "SuperH SCI(F) driver initialized\n";
diff --git a/drivers/tty/serial/sn_console.c b/drivers/tty/serial/sn_console.c
index cff9a30..377ae74 100644
--- a/drivers/tty/serial/sn_console.c
+++ b/drivers/tty/serial/sn_console.c
@@ -146,7 +146,7 @@ static struct sn_sal_ops intr_ops = {
 };
 
 /* the console does output in two distinctly different ways:
- * synchronous (raw) and asynchronous (buffered).  initally, early_printk
+ * synchronous (raw) and asynchronous (buffered).  initially, early_printk
  * does synchronous output.  any data written goes directly to the SAL
  * to be output (incidentally, it is internally buffered by the SAL)
  * after interrupts and timers are initialized and available for use,
@@ -481,7 +481,7 @@ sn_receive_chars(struct sn_cons_port *port, unsigned long flags)
 	while (port->sc_ops->sal_input_pending()) {
 		ch = port->sc_ops->sal_getc();
 		if (ch < 0) {
-			printk(KERN_ERR "sn_console: An error occured while "
+			printk(KERN_ERR "sn_console: An error occurred while "
 			       "obtaining data from the console (0x%0x)\n", ch);
 			break;
 		}
diff --git a/drivers/tty/serial/sunzilog.c b/drivers/tty/serial/sunzilog.c
index 99ff9ab..8e916e7 100644
--- a/drivers/tty/serial/sunzilog.c
+++ b/drivers/tty/serial/sunzilog.c
@@ -474,7 +474,7 @@ static void sunzilog_transmit_chars(struct uart_sunzilog_port *up,
 		 * be nice to transmit console writes just like we normally would for
 		 * a TTY line. (ie. buffered and TX interrupt driven).  That is not
 		 * easy because console writes cannot sleep.  One solution might be
-		 * to poll on enough port->xmit space becomming free.  -DaveM
+		 * to poll on enough port->xmit space becoming free.  -DaveM
 		 */
 		if (!(status & Tx_BUF_EMP))
 			return;
diff --git a/drivers/tty/synclink.c b/drivers/tty/synclink.c
index 18888d0..27da23d 100644
--- a/drivers/tty/synclink.c
+++ b/drivers/tty/synclink.c
@@ -4072,7 +4072,7 @@ static int mgsl_claim_resources(struct mgsl_struct *info)
 	
 	if ( request_irq(info->irq_level,mgsl_interrupt,info->irq_flags,
 		info->device_name, info ) < 0 ) {
-		printk( "%s(%d):Cant request interrupt on device %s IRQ=%d\n",
+		printk( "%s(%d):Can't request interrupt on device %s IRQ=%d\n",
 			__FILE__,__LINE__,info->device_name, info->irq_level );
 		goto errout;
 	}
@@ -4095,7 +4095,7 @@ static int mgsl_claim_resources(struct mgsl_struct *info)
 		info->memory_base = ioremap_nocache(info->phys_memory_base,
 								0x40000);
 		if (!info->memory_base) {
-			printk( "%s(%d):Cant map shared memory on device %s MemAddr=%08X\n",
+			printk( "%s(%d):Can't map shared memory on device %s MemAddr=%08X\n",
 				__FILE__,__LINE__,info->device_name, info->phys_memory_base );
 			goto errout;
 		}
@@ -4109,7 +4109,7 @@ static int mgsl_claim_resources(struct mgsl_struct *info)
 		info->lcr_base = ioremap_nocache(info->phys_lcr_base,
 								PAGE_SIZE);
 		if (!info->lcr_base) {
-			printk( "%s(%d):Cant map LCR memory on device %s MemAddr=%08X\n",
+			printk( "%s(%d):Can't map LCR memory on device %s MemAddr=%08X\n",
 				__FILE__,__LINE__,info->device_name, info->phys_lcr_base );
 			goto errout;
 		}
@@ -4119,7 +4119,7 @@ static int mgsl_claim_resources(struct mgsl_struct *info)
 		/* claim DMA channel */
 		
 		if (request_dma(info->dma_level,info->device_name) < 0){
-			printk( "%s(%d):Cant request DMA channel on device %s DMA=%d\n",
+			printk( "%s(%d):Can't request DMA channel on device %s DMA=%d\n",
 				__FILE__,__LINE__,info->device_name, info->dma_level );
 			mgsl_release_resources( info );
 			return -ENODEV;
@@ -4132,7 +4132,7 @@ static int mgsl_claim_resources(struct mgsl_struct *info)
 	}
 	
 	if ( mgsl_allocate_dma_buffers(info) < 0 ) {
-		printk( "%s(%d):Cant allocate DMA buffers on device %s DMA=%d\n",
+		printk( "%s(%d):Can't allocate DMA buffers on device %s DMA=%d\n",
 			__FILE__,__LINE__,info->device_name, info->dma_level );
 		goto errout;
 	}	
diff --git a/drivers/tty/synclink_gt.c b/drivers/tty/synclink_gt.c
index a35dd54..18b48cd 100644
--- a/drivers/tty/synclink_gt.c
+++ b/drivers/tty/synclink_gt.c
@@ -3491,7 +3491,7 @@ static int claim_resources(struct slgt_info *info)
 
 	info->reg_addr = ioremap_nocache(info->phys_reg_addr, SLGT_REG_SIZE);
 	if (!info->reg_addr) {
-		DBGERR(("%s cant map device registers, addr=%08X\n",
+		DBGERR(("%s can't map device registers, addr=%08X\n",
 			info->device_name, info->phys_reg_addr));
 		info->init_error = DiagStatus_CantAssignPciResources;
 		goto errout;
diff --git a/drivers/tty/synclinkmp.c b/drivers/tty/synclinkmp.c
index 3273436..c77831c 100644
--- a/drivers/tty/synclinkmp.c
+++ b/drivers/tty/synclinkmp.c
@@ -3595,7 +3595,7 @@ static int claim_resources(SLMP_INFO *info)
 	info->memory_base = ioremap_nocache(info->phys_memory_base,
 								SCA_MEM_SIZE);
 	if (!info->memory_base) {
-		printk( "%s(%d):%s Cant map shared memory, MemAddr=%08X\n",
+		printk( "%s(%d):%s Can't map shared memory, MemAddr=%08X\n",
 			__FILE__,__LINE__,info->device_name, info->phys_memory_base );
 		info->init_error = DiagStatus_CantAssignPciResources;
 		goto errout;
@@ -3603,7 +3603,7 @@ static int claim_resources(SLMP_INFO *info)
 
 	info->lcr_base = ioremap_nocache(info->phys_lcr_base, PAGE_SIZE);
 	if (!info->lcr_base) {
-		printk( "%s(%d):%s Cant map LCR memory, MemAddr=%08X\n",
+		printk( "%s(%d):%s Can't map LCR memory, MemAddr=%08X\n",
 			__FILE__,__LINE__,info->device_name, info->phys_lcr_base );
 		info->init_error = DiagStatus_CantAssignPciResources;
 		goto errout;
@@ -3612,7 +3612,7 @@ static int claim_resources(SLMP_INFO *info)
 
 	info->sca_base = ioremap_nocache(info->phys_sca_base, PAGE_SIZE);
 	if (!info->sca_base) {
-		printk( "%s(%d):%s Cant map SCA memory, MemAddr=%08X\n",
+		printk( "%s(%d):%s Can't map SCA memory, MemAddr=%08X\n",
 			__FILE__,__LINE__,info->device_name, info->phys_sca_base );
 		info->init_error = DiagStatus_CantAssignPciResources;
 		goto errout;
@@ -3622,7 +3622,7 @@ static int claim_resources(SLMP_INFO *info)
 	info->statctrl_base = ioremap_nocache(info->phys_statctrl_base,
 								PAGE_SIZE);
 	if (!info->statctrl_base) {
-		printk( "%s(%d):%s Cant map SCA Status/Control memory, MemAddr=%08X\n",
+		printk( "%s(%d):%s Can't map SCA Status/Control memory, MemAddr=%08X\n",
 			__FILE__,__LINE__,info->device_name, info->phys_statctrl_base );
 		info->init_error = DiagStatus_CantAssignPciResources;
 		goto errout;
@@ -3869,7 +3869,7 @@ static void device_init(int adapter_num, struct pci_dev *pdev)
 					port_array[0]->irq_flags,
 					port_array[0]->device_name,
 					port_array[0]) < 0 ) {
-			printk( "%s(%d):%s Cant request interrupt, IRQ=%d\n",
+			printk( "%s(%d):%s Can't request interrupt, IRQ=%d\n",
 				__FILE__,__LINE__,
 				port_array[0]->device_name,
 				port_array[0]->irq_level );
diff --git a/drivers/tty/tty_io.c b/drivers/tty/tty_io.c
index 936a4ea..d7d50b4 100644
--- a/drivers/tty/tty_io.c
+++ b/drivers/tty/tty_io.c
@@ -2134,7 +2134,7 @@ done:
  *	actually has driver level meaning and triggers a VC resize.
  *
  *	Locking:
- *		Driver dependant. The default do_resize method takes the
+ *		Driver dependent. The default do_resize method takes the
  *	tty termios mutex and ctrl_lock. The console takes its own lock
  *	then calls into the default method.
  */
@@ -2155,7 +2155,7 @@ static int tiocswinsz(struct tty_struct *tty, struct winsize __user *arg)
  *	tioccons	-	allow admin to move logical console
  *	@file: the file to become console
  *
- *	Allow the adminstrator to move the redirected console device
+ *	Allow the administrator to move the redirected console device
  *
  *	Locking: uses redirect_lock to guard the redirect information
  */
@@ -2290,7 +2290,7 @@ EXPORT_SYMBOL_GPL(tty_get_pgrp);
 /**
  *	tiocgpgrp		-	get process group
  *	@tty: tty passed by user
- *	@real_tty: tty side of the tty pased by the user if a pty else the tty
+ *	@real_tty: tty side of the tty passed by the user if a pty else the tty
  *	@p: returned pid
  *
  *	Obtain the process group of the tty. If there is no process group
@@ -2367,7 +2367,7 @@ out_unlock:
 /**
  *	tiocgsid		-	get session id
  *	@tty: tty passed by user
- *	@real_tty: tty side of the tty pased by the user if a pty else the tty
+ *	@real_tty: tty side of the tty passed by the user if a pty else the tty
  *	@p: pointer to returned session id
  *
  *	Obtain the session id of the tty. If there is no session
diff --git a/drivers/tty/tty_ioctl.c b/drivers/tty/tty_ioctl.c
index 1a1135d..21574cb 100644
--- a/drivers/tty/tty_ioctl.c
+++ b/drivers/tty/tty_ioctl.c
@@ -247,7 +247,7 @@ speed_t tty_termios_baud_rate(struct ktermios *termios)
 	cbaud = termios->c_cflag & CBAUD;
 
 #ifdef BOTHER
-	/* Magic token for arbitary speed via c_ispeed/c_ospeed */
+	/* Magic token for arbitrary speed via c_ispeed/c_ospeed */
 	if (cbaud == BOTHER)
 		return termios->c_ospeed;
 #endif
@@ -283,7 +283,7 @@ speed_t tty_termios_input_baud_rate(struct ktermios *termios)
 	if (cbaud == B0)
 		return tty_termios_baud_rate(termios);
 
-	/* Magic token for arbitary speed via c_ispeed*/
+	/* Magic token for arbitrary speed via c_ispeed*/
 	if (cbaud == BOTHER)
 		return termios->c_ispeed;
 
@@ -449,7 +449,7 @@ EXPORT_SYMBOL(tty_get_baud_rate);
  *	@new: New termios
  *	@old: Old termios
  *
- *	Propogate the hardware specific terminal setting bits from
+ *	Propagate the hardware specific terminal setting bits from
  *	the old termios structure to the new one. This is used in cases
  *	where the hardware does not support reconfiguration or as a helper
  *	in some cases where only minimal reconfiguration is supported
diff --git a/drivers/tty/vt/vt.c b/drivers/tty/vt/vt.c
index c83cdfb..4bea1ef 100644
--- a/drivers/tty/vt/vt.c
+++ b/drivers/tty/vt/vt.c
@@ -3963,7 +3963,7 @@ void reset_palette(struct vc_data *vc)
  *  of 32 pixels. Userspace fontdata is stored with 32 bytes (shorts/ints, 
  *  depending on width) reserved for each character which is kinda wasty, but 
  *  this is done in order to maintain compatibility with the EGA/VGA fonts. It 
- *  is upto the actual low-level console-driver convert data into its favorite
+ *  is up to the actual low-level console-driver convert data into its favorite
  *  format (maybe we should add a `fontoffset' field to the `display'
  *  structure so we won't have to convert the fontdata all the time.
  *  /Jes
diff --git a/drivers/uio/uio_pruss.c b/drivers/uio/uio_pruss.c
index daf6e77..e67b566 100644
--- a/drivers/uio/uio_pruss.c
+++ b/drivers/uio/uio_pruss.c
@@ -39,7 +39,7 @@ module_param(extram_pool_sz, int, 0);
 MODULE_PARM_DESC(extram_pool_sz, "external ram pool size to allocate");
 
 /*
- * Host event IRQ numbers from PRUSS - PRUSS can generate upto 8 interrupt
+ * Host event IRQ numbers from PRUSS - PRUSS can generate up to 8 interrupt
  * events to AINTC of ARM host processor - which can be used for IPC b/w PRUSS
  * firmware and user space application, async notification from PRU firmware
  * to user space application
diff --git a/drivers/usb/atm/ueagle-atm.c b/drivers/usb/atm/ueagle-atm.c
index b268e9f..e71521c 100644
--- a/drivers/usb/atm/ueagle-atm.c
+++ b/drivers/usb/atm/ueagle-atm.c
@@ -1283,7 +1283,7 @@ static void uea_set_bulk_timeout(struct uea_softc *sc, u32 dsrate)
 
 	/* in bulk mode the modem have problem with high rate
 	 * changing internal timing could improve things, but the
-	 * value is misterious.
+	 * value is mysterious.
 	 * ADI930 don't support it (-EPIPE error).
 	 */
 
@@ -1743,7 +1743,7 @@ static int uea_send_cmvs_e1(struct uea_softc *sc)
 				goto out;
 		}
 	} else {
-		/* This realy should not happen */
+		/* This really should not happen */
 		uea_err(INS_TO_USBDEV(sc), "bad cmvs version %d\n", ver);
 		goto out;
 	}
@@ -1798,7 +1798,7 @@ static int uea_send_cmvs_e4(struct uea_softc *sc)
 				goto out;
 		}
 	} else {
-		/* This realy should not happen */
+		/* This really should not happen */
 		uea_err(INS_TO_USBDEV(sc), "bad cmvs version %d\n", ver);
 		goto out;
 	}
@@ -1829,7 +1829,7 @@ static int uea_start_reset(struct uea_softc *sc)
 
 	/* mask interrupt */
 	sc->booting = 1;
-	/* We need to set this here because, a ack timeout could have occured,
+	/* We need to set this here because, a ack timeout could have occurred,
 	 * but before we start the reboot, the ack occurs and set this to 1.
 	 * So we will failed to wait Ready CMV.
 	 */
diff --git a/drivers/usb/c67x00/c67x00-drv.c b/drivers/usb/c67x00/c67x00-drv.c
index b6d4923..62050f7 100644
--- a/drivers/usb/c67x00/c67x00-drv.c
+++ b/drivers/usb/c67x00/c67x00-drv.c
@@ -27,7 +27,7 @@
  * the link between the common hardware parts and the subdrivers (e.g.
  * interrupt handling).
  *
- * The c67x00 has 2 SIE's (serial interface engine) wich can be configured
+ * The c67x00 has 2 SIE's (serial interface engine) which can be configured
  * to be host, device or OTG (with some limitations, E.G. only SIE1 can be OTG).
  *
  * Depending on the platform configuration, the SIE's are created and
diff --git a/drivers/usb/c67x00/c67x00-hcd.h b/drivers/usb/c67x00/c67x00-hcd.h
index 74e4462..e3d493d 100644
--- a/drivers/usb/c67x00/c67x00-hcd.h
+++ b/drivers/usb/c67x00/c67x00-hcd.h
@@ -34,7 +34,7 @@
 /*
  * The following parameters depend on the CPU speed, bus speed, ...
  * These can be tuned for specific use cases, e.g. if isochronous transfers
- * are very important, bandwith can be sacrificed to guarantee that the
+ * are very important, bandwidth can be sacrificed to guarantee that the
  * 1ms deadline will be met.
  * If bulk transfers are important, the MAX_FRAME_BW can be increased,
  * but some (or many) isochronous deadlines might not be met.
diff --git a/drivers/usb/c67x00/c67x00-sched.c b/drivers/usb/c67x00/c67x00-sched.c
index f6b3c25..a03fbc1 100644
--- a/drivers/usb/c67x00/c67x00-sched.c
+++ b/drivers/usb/c67x00/c67x00-sched.c
@@ -907,7 +907,7 @@ static inline int c67x00_end_of_data(struct c67x00_td *td)
 
 /* Remove all td's from the list which come
  * after last_td and are meant for the same pipe.
- * This is used when a short packet has occured */
+ * This is used when a short packet has occurred */
 static inline void c67x00_clear_pipe(struct c67x00_hcd *c67x00,
 				     struct c67x00_td *last_td)
 {
diff --git a/drivers/usb/class/cdc-acm.h b/drivers/usb/class/cdc-acm.h
index 5eeb570..b4ea54d 100644
--- a/drivers/usb/class/cdc-acm.h
+++ b/drivers/usb/class/cdc-acm.h
@@ -52,7 +52,7 @@
  */
 
 /*
- * The only reason to have several buffers is to accomodate assumptions
+ * The only reason to have several buffers is to accommodate assumptions
  * in line disciplines. They ask for empty space amount, receive our URB size,
  * and proceed to issue several 1-character writes, assuming they will fit.
  * The very first write takes a complete URB. Fortunately, this only happens
diff --git a/drivers/usb/class/usbtmc.c b/drivers/usb/class/usbtmc.c
index 6a54634..385acb8 100644
--- a/drivers/usb/class/usbtmc.c
+++ b/drivers/usb/class/usbtmc.c
@@ -483,7 +483,7 @@ static ssize_t usbtmc_read(struct file *filp, char __user *buf,
 		}
 
 		done += n_characters;
-		/* Terminate if end-of-message bit recieved from device */
+		/* Terminate if end-of-message bit received from device */
 		if ((buffer[8] &  0x01) && (actual >= n_characters + 12))
 			remaining = 0;
 		else
diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index 02b4dbf..8eed05d 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -700,7 +700,7 @@ void usb_hcd_poll_rh_status(struct usb_hcd *hcd)
 	/* The USB 2.0 spec says 256 ms.  This is close enough and won't
 	 * exceed that limit if HZ is 100. The math is more clunky than
 	 * maybe expected, this is to make sure that all timers for USB devices
-	 * fire at the same time to give the CPU a break inbetween */
+	 * fire at the same time to give the CPU a break in between */
 	if (hcd->uses_new_polling ? HCD_POLL_RH(hcd) :
 			(length == 0 && hcd->status_urb != NULL))
 		mod_timer (&hcd->rh_timer, (jiffies/(HZ/4) + 1) * (HZ/4));
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 564eaa5..8fb7549 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -1649,7 +1649,7 @@ void usb_disconnect(struct usb_device **pdev)
 
 	/* mark the device as inactive, so any further urb submissions for
 	 * this device (and any of its children) will fail immediately.
-	 * this quiesces everyting except pending urbs.
+	 * this quiesces everything except pending urbs.
 	 */
 	usb_set_device_state(udev, USB_STATE_NOTATTACHED);
 	dev_info(&udev->dev, "USB disconnect, device number %d\n",
diff --git a/drivers/usb/early/ehci-dbgp.c b/drivers/usb/early/ehci-dbgp.c
index 0bc06e2..a6a350f 100644
--- a/drivers/usb/early/ehci-dbgp.c
+++ b/drivers/usb/early/ehci-dbgp.c
@@ -648,7 +648,7 @@ static int ehci_reset_port(int port)
 		if (!(portsc & PORT_CONNECT))
 			return -ENOTCONN;
 
-		/* bomb out completely if something weird happend */
+		/* bomb out completely if something weird happened */
 		if ((portsc & PORT_CSC))
 			return -EINVAL;
 
diff --git a/drivers/usb/gadget/amd5536udc.c b/drivers/usb/gadget/amd5536udc.c
index f8dd726..6e42aab 100644
--- a/drivers/usb/gadget/amd5536udc.c
+++ b/drivers/usb/gadget/amd5536udc.c
@@ -278,7 +278,7 @@ static int udc_enable_dev_setup_interrupts(struct udc *dev)
 	return 0;
 }
 
-/* Calculates fifo start of endpoint based on preceeding endpoints */
+/* Calculates fifo start of endpoint based on preceding endpoints */
 static int udc_set_txfifo_addr(struct udc_ep *ep)
 {
 	struct udc	*dev;
@@ -2137,7 +2137,7 @@ static irqreturn_t udc_data_out_isr(struct udc *dev, int ep_ix)
 	if (use_dma) {
 		/* BNA event ? */
 		if (tmp & AMD_BIT(UDC_EPSTS_BNA)) {
-			DBG(dev, "BNA ep%dout occured - DESPTR = %x \n",
+			DBG(dev, "BNA ep%dout occurred - DESPTR = %x \n",
 					ep->num, readl(&ep->regs->desptr));
 			/* clear BNA */
 			writel(tmp | AMD_BIT(UDC_EPSTS_BNA), &ep->regs->sts);
@@ -2151,7 +2151,7 @@ static irqreturn_t udc_data_out_isr(struct udc *dev, int ep_ix)
 	}
 	/* HE event ? */
 	if (tmp & AMD_BIT(UDC_EPSTS_HE)) {
-		dev_err(&dev->pdev->dev, "HE ep%dout occured\n", ep->num);
+		dev_err(&dev->pdev->dev, "HE ep%dout occurred\n", ep->num);
 
 		/* clear HE */
 		writel(tmp | AMD_BIT(UDC_EPSTS_HE), &ep->regs->sts);
@@ -2354,7 +2354,7 @@ static irqreturn_t udc_data_in_isr(struct udc *dev, int ep_ix)
 		/* BNA ? */
 		if (epsts & AMD_BIT(UDC_EPSTS_BNA)) {
 			dev_err(&dev->pdev->dev,
-				"BNA ep%din occured - DESPTR = %08lx \n",
+				"BNA ep%din occurred - DESPTR = %08lx \n",
 				ep->num,
 				(unsigned long) readl(&ep->regs->desptr));
 
@@ -2367,7 +2367,7 @@ static irqreturn_t udc_data_in_isr(struct udc *dev, int ep_ix)
 	/* HE event ? */
 	if (epsts & AMD_BIT(UDC_EPSTS_HE)) {
 		dev_err(&dev->pdev->dev,
-			"HE ep%dn occured - DESPTR = %08lx \n",
+			"HE ep%dn occurred - DESPTR = %08lx \n",
 			ep->num, (unsigned long) readl(&ep->regs->desptr));
 
 		/* clear HE */
@@ -2384,7 +2384,7 @@ static irqreturn_t udc_data_in_isr(struct udc *dev, int ep_ix)
 			req = list_entry(ep->queue.next,
 					struct udc_request, queue);
 			/*
-			 * length bytes transfered
+			 * length bytes transferred
 			 * check dma done of last desc. in PPBDU mode
 			 */
 			if (use_dma_ppb_du) {
@@ -2784,7 +2784,7 @@ static irqreturn_t udc_control_in_isr(struct udc *dev)
 					/* write fifo */
 					udc_txfifo_write(ep, &req->req);
 
-					/* lengh bytes transfered */
+					/* lengh bytes transferred */
 					len = req->req.length - req->req.actual;
 					if (len > ep->ep.maxpacket)
 						len = ep->ep.maxpacket;
diff --git a/drivers/usb/gadget/amd5536udc.h b/drivers/usb/gadget/amd5536udc.h
index 4bbabbb..1d1c754 100644
--- a/drivers/usb/gadget/amd5536udc.h
+++ b/drivers/usb/gadget/amd5536udc.h
@@ -584,7 +584,7 @@ union udc_setup_data {
  * SET and GET bitfields in u32 values
  * via constants for mask/offset:
  * <bit_field_stub_name> is the text between
- * UDC_ and _MASK|_OFS of appropiate
+ * UDC_ and _MASK|_OFS of appropriate
  * constant
  *
  * set bitfield value in u32 u32Val
diff --git a/drivers/usb/gadget/at91_udc.c b/drivers/usb/gadget/at91_udc.c
index bb8ddf0..9b7cdb1 100644
--- a/drivers/usb/gadget/at91_udc.c
+++ b/drivers/usb/gadget/at91_udc.c
@@ -826,7 +826,7 @@ done:
 	return status;
 }
 
-/* reinit == restore inital software state */
+/* reinit == restore initial software state */
 static void udc_reinit(struct at91_udc *udc)
 {
 	u32 i;
diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index c2251c4..82314ed 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -42,7 +42,7 @@
 static struct usb_composite_driver *composite;
 static int (*composite_gadget_bind)(struct usb_composite_dev *cdev);
 
-/* Some systems will need runtime overrides for the  product identifers
+/* Some systems will need runtime overrides for the  product identifiers
  * published in the device descriptor, either numbers or strings or both.
  * String parameters are in UTF-8 (superset of ASCII's 7 bit characters).
  */
@@ -205,14 +205,14 @@ int usb_function_activate(struct usb_function *function)
  * usb_interface_id() is called from usb_function.bind() callbacks to
  * allocate new interface IDs.  The function driver will then store that
  * ID in interface, association, CDC union, and other descriptors.  It
- * will also handle any control requests targetted at that interface,
+ * will also handle any control requests targeted at that interface,
  * particularly changing its altsetting via set_alt().  There may
  * also be class-specific or vendor-specific requests to handle.
  *
  * All interface identifier should be allocated using this routine, to
  * ensure that for example different functions don't wrongly assign
  * different meanings to the same identifier.  Note that since interface
- * identifers are configuration-specific, functions used in more than
+ * identifiers are configuration-specific, functions used in more than
  * one configuration (or more than once in a given configuration) need
  * multiple versions of the relevant descriptors.
  *
diff --git a/drivers/usb/gadget/f_audio.c b/drivers/usb/gadget/f_audio.c
index 00975ed..9abecfd 100644
--- a/drivers/usb/gadget/f_audio.c
+++ b/drivers/usb/gadget/f_audio.c
@@ -742,7 +742,7 @@ int __init control_selector_init(struct f_audio *audio)
 }
 
 /**
- * audio_bind_config - add USB audio fucntion to a configuration
+ * audio_bind_config - add USB audio function to a configuration
  * @c: the configuration to supcard the USB audio function
  * Context: single threaded during gadget setup
  *
diff --git a/drivers/usb/gadget/f_ncm.c b/drivers/usb/gadget/f_ncm.c
index 130eee6..86902a6 100644
--- a/drivers/usb/gadget/f_ncm.c
+++ b/drivers/usb/gadget/f_ncm.c
@@ -111,7 +111,7 @@ static inline unsigned ncm_bitrate(struct usb_gadget *g)
 #define NTB_OUT_SIZE		16384
 
 /*
- * skbs of size less than that will not be alligned
+ * skbs of size less than that will not be aligned
  * to NCM's dwNtbInMaxSize to save bus bandwidth
  */
 
diff --git a/drivers/usb/gadget/fsl_qe_udc.h b/drivers/usb/gadget/fsl_qe_udc.h
index bea5b82..e35e24f 100644
--- a/drivers/usb/gadget/fsl_qe_udc.h
+++ b/drivers/usb/gadget/fsl_qe_udc.h
@@ -208,14 +208,14 @@ struct qe_frame{
 /* Frame status field */
 /* Receive side */
 #define FRAME_OK               0x00000000 /* Frame tranmitted or received OK */
-#define FRAME_ERROR            0x80000000 /* Error occured on frame */
+#define FRAME_ERROR            0x80000000 /* Error occurred on frame */
 #define START_FRAME_LOST       0x40000000 /* START_FRAME_LOST */
 #define END_FRAME_LOST         0x20000000 /* END_FRAME_LOST */
 #define RX_ER_NONOCT           0x10000000 /* Rx Non Octet Aligned Packet */
 #define RX_ER_BITSTUFF         0x08000000 /* Frame Aborted --Received packet
 					     with bit stuff error */
 #define RX_ER_CRC              0x04000000 /* Received packet with CRC error */
-#define RX_ER_OVERUN           0x02000000 /* Over-run occured on reception */
+#define RX_ER_OVERUN           0x02000000 /* Over-run occurred on reception */
 #define RX_ER_PID              0x01000000 /* Wrong PID received */
 /* Tranmit side */
 #define TX_ER_NAK              0x00800000 /* Received NAK handshake */
@@ -379,7 +379,7 @@ struct qe_udc {
 #define T_LSP         0x01000000         /* Low-speed transaction */
 #define T_PID         0x00c00000         /* packet id */
 #define T_NAK         0x00100000         /* No ack. */
-#define T_STAL        0x00080000         /* Stall recieved */
+#define T_STAL        0x00080000         /* Stall received */
 #define T_TO          0x00040000         /* time out */
 #define T_UN          0x00020000         /* underrun */
 
diff --git a/drivers/usb/gadget/fsl_udc_core.c b/drivers/usb/gadget/fsl_udc_core.c
index 912cb8e..07499c1 100644
--- a/drivers/usb/gadget/fsl_udc_core.c
+++ b/drivers/usb/gadget/fsl_udc_core.c
@@ -464,7 +464,7 @@ static int fsl_ep_enable(struct usb_ep *_ep,
 
 	max = le16_to_cpu(desc->wMaxPacketSize);
 
-	/* Disable automatic zlp generation.  Driver is reponsible to indicate
+	/* Disable automatic zlp generation.  Driver is responsible to indicate
 	 * explicitly through req->req.zero.  This is needed to enable multi-td
 	 * request. */
 	zlt = 1;
@@ -648,7 +648,7 @@ static void fsl_queue_td(struct fsl_ep *ep, struct fsl_req *req)
 			| EP_QUEUE_HEAD_STATUS_HALT));
 	dQH->size_ioc_int_sts &= temp;
 
-	/* Ensure that updates to the QH will occure before priming. */
+	/* Ensure that updates to the QH will occur before priming. */
 	wmb();
 
 	/* Prime endpoint by writing 1 to ENDPTPRIME */
@@ -1459,7 +1459,7 @@ static int process_ep_req(struct fsl_udc *udc, int pipe,
 				status = -EILSEQ;
 				break;
 			} else
-				ERR("Unknown error has occured (0x%x)!\n",
+				ERR("Unknown error has occurred (0x%x)!\n",
 					errors);
 
 		} else if (le32_to_cpu(curr_td->size_ioc_sts)
diff --git a/drivers/usb/gadget/fsl_usb2_udc.h b/drivers/usb/gadget/fsl_usb2_udc.h
index 20aecee..e88cce5 100644
--- a/drivers/usb/gadget/fsl_usb2_udc.h
+++ b/drivers/usb/gadget/fsl_usb2_udc.h
@@ -15,7 +15,7 @@ struct usb_dr_device {
 	u8 res1[256];
 	u16 caplength;		/* Capability Register Length */
 	u16 hciversion;		/* Host Controller Interface Version */
-	u32 hcsparams;		/* Host Controller Structual Parameters */
+	u32 hcsparams;		/* Host Controller Structural Parameters */
 	u32 hccparams;		/* Host Controller Capability Parameters */
 	u8 res2[20];
 	u32 dciversion;		/* Device Controller Interface Version */
@@ -52,7 +52,7 @@ struct usb_dr_host {
 	u8 res1[256];
 	u16 caplength;		/* Capability Register Length */
 	u16 hciversion;		/* Host Controller Interface Version */
-	u32 hcsparams;		/* Host Controller Structual Parameters */
+	u32 hcsparams;		/* Host Controller Structural Parameters */
 	u32 hccparams;		/* Host Controller Capability Parameters */
 	u8 res2[20];
 	u32 dciversion;		/* Device Controller Interface Version */
diff --git a/drivers/usb/gadget/gmidi.c b/drivers/usb/gadget/gmidi.c
index 0ab7e14..47b86b9 100644
--- a/drivers/usb/gadget/gmidi.c
+++ b/drivers/usb/gadget/gmidi.c
@@ -67,7 +67,7 @@ MODULE_PARM_DESC(index, "Index value for the USB MIDI Gadget adapter.");
 module_param(id, charp, 0444);
 MODULE_PARM_DESC(id, "ID string for the USB MIDI Gadget adapter.");
 
-/* Some systems will want different product identifers published in the
+/* Some systems will want different product identifiers published in the
  * device descriptor, either numbers or strings or both.  These string
  * parameters are in UTF-8 (superset of ASCII's 7 bit characters).
  */
diff --git a/drivers/usb/gadget/langwell_udc.c b/drivers/usb/gadget/langwell_udc.c
index 1eca8b4..9cee88a 100644
--- a/drivers/usb/gadget/langwell_udc.c
+++ b/drivers/usb/gadget/langwell_udc.c
@@ -642,7 +642,7 @@ static int queue_dtd(struct langwell_ep *ep, struct langwell_request *req)
 	dqh->dtd_status &= dtd_status;
 	dev_vdbg(&dev->pdev->dev, "dqh->dtd_status = 0x%x\n", dqh->dtd_status);
 
-	/* ensure that updates to the dQH will occure before priming */
+	/* ensure that updates to the dQH will occur before priming */
 	wmb();
 
 	/* write 1 to endptprime register to PRIME endpoint */
diff --git a/drivers/usb/gadget/mv_udc_core.c b/drivers/usb/gadget/mv_udc_core.c
index d5468a7..b62b264 100644
--- a/drivers/usb/gadget/mv_udc_core.c
+++ b/drivers/usb/gadget/mv_udc_core.c
@@ -325,7 +325,7 @@ static int queue_dtd(struct mv_ep *ep, struct mv_req *req)
 
 			/*
 			 * Ensure that updates to the QH will
-			 * occure before priming.
+			 * occur before priming.
 			 */
 			wmb();
 
@@ -338,7 +338,7 @@ static int queue_dtd(struct mv_ep *ep, struct mv_req *req)
 			& EP_QUEUE_HEAD_NEXT_POINTER_MASK;;
 		dqh->size_ioc_int_sts = 0;
 
-		/* Ensure that updates to the QH will occure before priming. */
+		/* Ensure that updates to the QH will occur before priming. */
 		wmb();
 
 		/* Prime the Endpoint */
@@ -1845,7 +1845,7 @@ static irqreturn_t mv_udc_irq(int irq, void *dev)
 		return IRQ_NONE;
 	}
 
-	/* Clear all the interrupts occured */
+	/* Clear all the interrupts occurred */
 	writel(status, &udc->op_regs->usbsts);
 
 	if (status & USBSTS_ERR)
diff --git a/drivers/usb/gadget/net2280.c b/drivers/usb/gadget/net2280.c
index d09155b..24696f7 100644
--- a/drivers/usb/gadget/net2280.c
+++ b/drivers/usb/gadget/net2280.c
@@ -117,7 +117,7 @@ module_param (fifo_mode, ushort, 0644);
 
 /* enable_suspend -- When enabled, the driver will respond to
  * USB suspend requests by powering down the NET2280.  Otherwise,
- * USB suspend requests will be ignored.  This is acceptible for
+ * USB suspend requests will be ignored.  This is acceptable for
  * self-powered devices
  */
 static int enable_suspend = 0;
diff --git a/drivers/usb/gadget/nokia.c b/drivers/usb/gadget/nokia.c
index b5364f9d..55ca63a 100644
--- a/drivers/usb/gadget/nokia.c
+++ b/drivers/usb/gadget/nokia.c
@@ -203,7 +203,7 @@ static int __init nokia_bind(struct usb_composite_dev *cdev)
 		goto err_usb;
 	}
 
-	/* finaly register the configuration */
+	/* finally register the configuration */
 	status = usb_add_config(cdev, &nokia_config_500ma_driver,
 			nokia_bind_config);
 	if (status < 0)
diff --git a/drivers/usb/gadget/printer.c b/drivers/usb/gadget/printer.c
index 12ff6cf..c3f2bd4 100644
--- a/drivers/usb/gadget/printer.c
+++ b/drivers/usb/gadget/printer.c
@@ -126,7 +126,7 @@ static struct printer_dev usb_printer_gadget;
 #define PRINTER_VENDOR_NUM	0x0525		/* NetChip */
 #define PRINTER_PRODUCT_NUM	0xa4a8		/* Linux-USB Printer Gadget */
 
-/* Some systems will want different product identifers published in the
+/* Some systems will want different product identifiers published in the
  * device descriptor, either numbers or strings or both.  These string
  * parameters are in UTF-8 (superset of ASCII's 7 bit characters).
  */
diff --git a/drivers/usb/gadget/pxa27x_udc.c b/drivers/usb/gadget/pxa27x_udc.c
index 2efd673..78a39a4 100644
--- a/drivers/usb/gadget/pxa27x_udc.c
+++ b/drivers/usb/gadget/pxa27x_udc.c
@@ -602,7 +602,7 @@ static void inc_ep_stats_reqs(struct pxa_ep *ep, int is_in)
 /**
  * inc_ep_stats_bytes - Update ep stats counts
  * @ep: physical endpoint
- * @count: bytes transfered on endpoint
+ * @count: bytes transferred on endpoint
  * @is_in: ep direction (USB_DIR_IN or 0)
  */
 static void inc_ep_stats_bytes(struct pxa_ep *ep, int count, int is_in)
@@ -877,7 +877,7 @@ static void nuke(struct pxa_ep *ep, int status)
  * If there is less space in request than bytes received in OUT endpoint,
  * bytes are left in the OUT endpoint.
  *
- * Returns how many bytes were actually transfered
+ * Returns how many bytes were actually transferred
  */
 static int read_packet(struct pxa_ep *ep, struct pxa27x_request *req)
 {
@@ -914,7 +914,7 @@ static int read_packet(struct pxa_ep *ep, struct pxa27x_request *req)
  * endpoint. If there are no bytes to transfer, doesn't write anything
  * to physical endpoint.
  *
- * Returns how many bytes were actually transfered.
+ * Returns how many bytes were actually transferred.
  */
 static int write_packet(struct pxa_ep *ep, struct pxa27x_request *req,
 			unsigned int max)
@@ -991,7 +991,7 @@ static int read_fifo(struct pxa_ep *ep, struct pxa27x_request *req)
  * caller guarantees at least one packet buffer is ready (or a zlp).
  * Doesn't complete the request, that's the caller's job
  *
- * Returns 1 if request fully transfered, 0 if partial transfer
+ * Returns 1 if request fully transferred, 0 if partial transfer
  */
 static int write_fifo(struct pxa_ep *ep, struct pxa27x_request *req)
 {
@@ -1094,7 +1094,7 @@ static int read_ep0_fifo(struct pxa_ep *ep, struct pxa27x_request *req)
  * Sends a request (or a part of the request) to the control endpoint (ep0 in).
  * If the request doesn't fit, the remaining part will be sent from irq.
  * The request is considered fully written only if either :
- *   - last write transfered all remaining bytes, but fifo was not fully filled
+ *   - last write transferred all remaining bytes, but fifo was not fully filled
  *   - last write was a 0 length write
  *
  * Returns 1 if request fully written, 0 if request only partially sent
@@ -1548,7 +1548,7 @@ static int pxa_udc_get_frame(struct usb_gadget *_gadget)
  * pxa_udc_wakeup - Force udc device out of suspend
  * @_gadget: usb gadget
  *
- * Returns 0 if successfull, error code otherwise
+ * Returns 0 if successful, error code otherwise
  */
 static int pxa_udc_wakeup(struct usb_gadget *_gadget)
 {
diff --git a/drivers/usb/gadget/s3c-hsotg.c b/drivers/usb/gadget/s3c-hsotg.c
index ef825c3..0912679 100644
--- a/drivers/usb/gadget/s3c-hsotg.c
+++ b/drivers/usb/gadget/s3c-hsotg.c
@@ -41,8 +41,8 @@
 /* EP0_MPS_LIMIT
  *
  * Unfortunately there seems to be a limit of the amount of data that can
- * be transfered by IN transactions on EP0. This is either 127 bytes or 3
- * packets (which practially means 1 packet and 63 bytes of data) when the
+ * be transferred by IN transactions on EP0. This is either 127 bytes or 3
+ * packets (which practically means 1 packet and 63 bytes of data) when the
  * MPS is set to 64.
  *
  * This means if we are wanting to move >127 bytes of data, we need to
@@ -783,7 +783,7 @@ static void s3c_hsotg_start_req(struct s3c_hsotg *hsotg,
 		       hsotg->regs + S3C_DIEPINT(index));
 
 	/* Note, trying to clear the NAK here causes problems with transmit
-	 * on the S3C6400 ending up with the TXFIFO becomming full. */
+	 * on the S3C6400 ending up with the TXFIFO becoming full. */
 
 	/* check ep is enabled */
 	if (!(readl(hsotg->regs + epctrl_reg) & S3C_DxEPCTL_EPEna))
@@ -1176,10 +1176,10 @@ static void s3c_hsotg_process_control(struct s3c_hsotg *hsotg,
 		writel(ctrl, hsotg->regs + reg);
 
 		dev_dbg(hsotg->dev,
-			"writen DxEPCTL=0x%08x to %08x (DxEPCTL=0x%08x)\n",
+			"written DxEPCTL=0x%08x to %08x (DxEPCTL=0x%08x)\n",
 			ctrl, reg, readl(hsotg->regs + reg));
 
-		/* don't belive we need to anything more to get the EP
+		/* don't believe we need to anything more to get the EP
 		 * to reply with a STALL packet */
 	}
 }
@@ -1416,7 +1416,7 @@ static void s3c_hsotg_rx_data(struct s3c_hsotg *hsotg, int ep_idx, int size)
  * transaction.
  *
  * Note, since we don't write any data to the TxFIFO, then it is
- * currently belived that we do not need to wait for any space in
+ * currently believed that we do not need to wait for any space in
  * the TxFIFO.
  */
 static void s3c_hsotg_send_zlp(struct s3c_hsotg *hsotg,
@@ -1540,7 +1540,7 @@ static u32 s3c_hsotg_read_frameno(struct s3c_hsotg *hsotg)
  * that requires processing, so find out what is in there and do the
  * appropriate read.
  *
- * The RXFIFO is a true FIFO, the packets comming out are still in packet
+ * The RXFIFO is a true FIFO, the packets coming out are still in packet
  * chunks, so if you have x packets received on an endpoint you'll get x
  * FIFO events delivered, each with a packet's worth of data in it.
  *
@@ -2188,7 +2188,7 @@ irq_retry:
 
 	/* these next two seem to crop-up occasionally causing the core
 	 * to shutdown the USB transfer, so try clearing them and logging
-	 * the occurence. */
+	 * the occurrence. */
 
 	if (gintsts & S3C_GINTSTS_GOUTNakEff) {
 		dev_info(hsotg->dev, "GOUTNakEff triggered\n");
@@ -2469,7 +2469,7 @@ static struct usb_ep_ops s3c_hsotg_ep_ops = {
 	.queue		= s3c_hsotg_ep_queue,
 	.dequeue	= s3c_hsotg_ep_dequeue,
 	.set_halt	= s3c_hsotg_ep_sethalt,
-	/* note, don't belive we have any call for the fifo routines */
+	/* note, don't believe we have any call for the fifo routines */
 };
 
 /**
diff --git a/drivers/usb/host/Kconfig b/drivers/usb/host/Kconfig
index 9483acd..e0e0787 100644
--- a/drivers/usb/host/Kconfig
+++ b/drivers/usb/host/Kconfig
@@ -402,7 +402,7 @@ config FHCI_DEBUG
 	depends on USB_FHCI_HCD && DEBUG_FS
 	help
 	  Say "y" to see some FHCI debug information and statistics
-	  throught debugfs.
+	  through debugfs.
 
 config USB_U132_HCD
 	tristate "Elan U132 Adapter Host Controller"
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index f86d3fa..333ddc1 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -644,7 +644,7 @@ static inline void ehci_writel(const struct ehci_hcd *ehci,
 /*
  * On certain ppc-44x SoC there is a HW issue, that could only worked around with
  * explicit suspend/operate of OHCI. This function hereby makes sense only on that arch.
- * Other common bits are dependant on has_amcc_usb23 quirk flag.
+ * Other common bits are dependent on has_amcc_usb23 quirk flag.
  */
 #ifdef CONFIG_44x
 static inline void set_ohci_hcfs(struct ehci_hcd *ehci, int operational)
diff --git a/drivers/usb/host/fhci-hcd.c b/drivers/usb/host/fhci-hcd.c
index b84ff7e..19223c7 100644
--- a/drivers/usb/host/fhci-hcd.c
+++ b/drivers/usb/host/fhci-hcd.c
@@ -401,7 +401,7 @@ static int fhci_urb_enqueue(struct usb_hcd *hcd, struct urb *urb,
 		/* 1 td fro setup,1 for ack */
 		size = 2;
 	case PIPE_BULK:
-		/* one td for every 4096 bytes(can be upto 8k) */
+		/* one td for every 4096 bytes(can be up to 8k) */
 		size += urb->transfer_buffer_length / 4096;
 		/* ...add for any remaining bytes... */
 		if ((urb->transfer_buffer_length % 4096) != 0)
diff --git a/drivers/usb/host/fhci-tds.c b/drivers/usb/host/fhci-tds.c
index 38fe058..0ea577b 100644
--- a/drivers/usb/host/fhci-tds.c
+++ b/drivers/usb/host/fhci-tds.c
@@ -40,7 +40,7 @@
 #define TD_RXER		0x0020 /* Rx error or not */
 
 #define TD_NAK		0x0010 /* No ack. */
-#define TD_STAL		0x0008 /* Stall recieved */
+#define TD_STAL		0x0008 /* Stall received */
 #define TD_TO		0x0004 /* time out */
 #define TD_UN		0x0002 /* underrun */
 #define TD_NO		0x0010 /* Rx Non Octet Aligned Packet */
@@ -274,7 +274,7 @@ void fhci_init_ep_registers(struct fhci_usb *usb, struct endpoint *ep,
  * It is also preparing the TDs for new frames. If the Tx interrupts
  * are disabled, the application should call that routine to get
  * confirmation about the submitted frames. Otherwise, the routine is
- * called frome the interrupt service routine during the Tx interrupt.
+ * called from the interrupt service routine during the Tx interrupt.
  * In that case the application is informed by calling the application
  * specific 'fhci_transaction_confirm' routine
  */
@@ -337,7 +337,7 @@ static void fhci_td_transaction_confirm(struct fhci_usb *usb)
 					pkt->status = USB_TD_RX_ER_NONOCT;
 				else
 					fhci_err(usb->fhci, "illegal error "
-						 "occured\n");
+						 "occurred\n");
 			} else if (td_status & TD_NAK)
 				pkt->status = USB_TD_TX_ER_NAK;
 			else if (td_status & TD_TO)
@@ -347,7 +347,7 @@ static void fhci_td_transaction_confirm(struct fhci_usb *usb)
 			else if (td_status & TD_STAL)
 				pkt->status = USB_TD_TX_ER_STALL;
 			else
-				fhci_err(usb->fhci, "illegal error occured\n");
+				fhci_err(usb->fhci, "illegal error occurred\n");
 		} else if ((extra_data & TD_TOK_IN) &&
 				pkt->len > td_length - CRC_SIZE) {
 			pkt->status = USB_TD_RX_DATA_UNDERUN;
diff --git a/drivers/usb/host/fhci.h b/drivers/usb/host/fhci.h
index 71c3caa..dc6939a 100644
--- a/drivers/usb/host/fhci.h
+++ b/drivers/usb/host/fhci.h
@@ -82,7 +82,7 @@
 #define USB_TD_RX_ER_NONOCT	0x40000000 /* Tx Non Octet Aligned Packet */
 #define USB_TD_RX_ER_BITSTUFF	0x20000000 /* Frame Aborted-Received pkt */
 #define USB_TD_RX_ER_CRC	0x10000000 /* CRC error */
-#define USB_TD_RX_ER_OVERUN	0x08000000 /* Over - run occured */
+#define USB_TD_RX_ER_OVERUN	0x08000000 /* Over - run occurred */
 #define USB_TD_RX_ER_PID	0x04000000 /* wrong PID received */
 #define USB_TD_RX_DATA_UNDERUN	0x02000000 /* shorter than expected */
 #define USB_TD_RX_DATA_OVERUN	0x01000000 /* longer than expected */
@@ -363,7 +363,7 @@ struct ed {
 struct td {
 	void *data;		 /* a pointer to the data buffer */
 	unsigned int len;	 /* length of the data to be submitted */
-	unsigned int actual_len; /* actual bytes transfered on this td */
+	unsigned int actual_len; /* actual bytes transferred on this td */
 	enum fhci_ta_type type;	 /* transaction type */
 	u8 toggle;		 /* toggle for next trans. within this TD */
 	u16 iso_index;		 /* ISO transaction index */
diff --git a/drivers/usb/host/imx21-hcd.c b/drivers/usb/host/imx21-hcd.c
index 2562e92..af05718 100644
--- a/drivers/usb/host/imx21-hcd.c
+++ b/drivers/usb/host/imx21-hcd.c
@@ -1323,7 +1323,7 @@ static void process_etds(struct usb_hcd *hcd, struct imx21 *imx21, int sof)
  * (and hence no interrupt occurs).
  * This causes the transfer in question to hang.
  * The kludge below checks for this condition at each SOF and processes any
- * blocked ETDs (after an arbitary 10 frame wait)
+ * blocked ETDs (after an arbitrary 10 frame wait)
  *
  * With a single active transfer the usbtest test suite will run for days
  * without the kludge.
diff --git a/drivers/usb/host/isp116x.h b/drivers/usb/host/isp116x.h
index 12db961..9a2c400 100644
--- a/drivers/usb/host/isp116x.h
+++ b/drivers/usb/host/isp116x.h
@@ -13,7 +13,7 @@
 
 /* Full speed: max # of bytes to transfer for a single urb
    at a time must be < 1024 && must be multiple of 64.
-   832 allows transfering 4kiB within 5 frames. */
+   832 allows transferring 4kiB within 5 frames. */
 #define MAX_TRANSFER_SIZE_FULLSPEED	832
 
 /* Low speed: there is no reason to schedule in very big
diff --git a/drivers/usb/host/isp1362-hcd.c b/drivers/usb/host/isp1362-hcd.c
index 662cd00..f97570a 100644
--- a/drivers/usb/host/isp1362-hcd.c
+++ b/drivers/usb/host/isp1362-hcd.c
@@ -546,7 +546,7 @@ static void postproc_ep(struct isp1362_hcd *isp1362_hcd, struct isp1362_ep *ep)
 			if (usb_pipecontrol(urb->pipe)) {
 				ep->nextpid = USB_PID_ACK;
 				/* save the data underrun error code for later and
-				 * procede with the status stage
+				 * proceed with the status stage
 				 */
 				urb->actual_length += PTD_GET_COUNT(ptd);
 				BUG_ON(urb->actual_length > urb->transfer_buffer_length);
diff --git a/drivers/usb/host/ohci-hcd.c b/drivers/usb/host/ohci-hcd.c
index e728863..d557235 100644
--- a/drivers/usb/host/ohci-hcd.c
+++ b/drivers/usb/host/ohci-hcd.c
@@ -162,7 +162,7 @@ static int ohci_urb_enqueue (
 		// case PIPE_INTERRUPT:
 		// case PIPE_BULK:
 		default:
-			/* one TD for every 4096 Bytes (can be upto 8K) */
+			/* one TD for every 4096 Bytes (can be up to 8K) */
 			size += urb->transfer_buffer_length / 4096;
 			/* ... and for any remaining bytes ... */
 			if ((urb->transfer_buffer_length % 4096) != 0)
diff --git a/drivers/usb/host/oxu210hp-hcd.c b/drivers/usb/host/oxu210hp-hcd.c
index 44e4deb..4a771f6 100644
--- a/drivers/usb/host/oxu210hp-hcd.c
+++ b/drivers/usb/host/oxu210hp-hcd.c
@@ -2879,7 +2879,7 @@ static int oxu_urb_enqueue(struct usb_hcd *hcd, struct urb *urb,
 	/* Ok, we have more job to do! :) */
 
 	for (i = 0; i < num - 1; i++) {
-		/* Get free micro URB poll till a free urb is recieved */
+		/* Get free micro URB poll till a free urb is received */
 
 		do {
 			murb = (struct urb *) oxu_murb_alloc(oxu);
@@ -2911,7 +2911,7 @@ static int oxu_urb_enqueue(struct usb_hcd *hcd, struct urb *urb,
 
 	/* Last urb requires special handling  */
 
-	/* Get free micro URB poll till a free urb is recieved */
+	/* Get free micro URB poll till a free urb is received */
 	do {
 		murb = (struct urb *) oxu_murb_alloc(oxu);
 		if (!murb)
diff --git a/drivers/usb/host/whci/qset.c b/drivers/usb/host/whci/qset.c
index dc0ab83..d6e1754 100644
--- a/drivers/usb/host/whci/qset.c
+++ b/drivers/usb/host/whci/qset.c
@@ -739,7 +739,7 @@ static int get_urb_status_from_qtd(struct urb *urb, u32 status)
  * process_inactive_qtd - process an inactive (but not halted) qTD.
  *
  * Update the urb with the transfer bytes from the qTD, if the urb is
- * completely transfered or (in the case of an IN only) the LPF is
+ * completely transferred or (in the case of an IN only) the LPF is
  * set, then the transfer is complete and the urb should be returned
  * to the system.
  */
diff --git a/drivers/usb/host/xhci.c b/drivers/usb/host/xhci.c
index 9a3645f..196e018 100644
--- a/drivers/usb/host/xhci.c
+++ b/drivers/usb/host/xhci.c
@@ -741,7 +741,7 @@ int xhci_resume(struct xhci_hcd *xhci, bool hibernated)
 	int			retval;
 
 	/* Wait a bit if either of the roothubs need to settle from the
-	 * transistion into bus suspend.
+	 * transition into bus suspend.
 	 */
 	if (time_before(jiffies, xhci->bus_state[0].next_statechange) ||
 			time_before(jiffies,
@@ -2072,7 +2072,7 @@ int xhci_alloc_streams(struct usb_hcd *hcd, struct usb_device *udev,
 		return -EINVAL;
 	}
 	vdev = xhci->devs[udev->slot_id];
-	/* Mark each endpoint as being in transistion, so
+	/* Mark each endpoint as being in transition, so
 	 * xhci_urb_enqueue() will reject all URBs.
 	 */
 	for (i = 0; i < num_eps; i++) {
diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 711de25..07e2630 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -873,7 +873,7 @@ struct xhci_transfer_event {
 #define COMP_CMD_ABORT	25
 /* Stopped - transfer was terminated by a stop endpoint command */
 #define COMP_STOP	26
-/* Same as COMP_EP_STOPPED, but the transfered length in the event is invalid */
+/* Same as COMP_EP_STOPPED, but the transferred length in the event is invalid */
 #define COMP_STOP_INVAL	27
 /* Control Abort Error - Debug Capability - control pipe aborted */
 #define COMP_DBG_ABORT	28
diff --git a/drivers/usb/image/microtek.c b/drivers/usb/image/microtek.c
index c90c89d..a003796 100644
--- a/drivers/usb/image/microtek.c
+++ b/drivers/usb/image/microtek.c
@@ -69,7 +69,7 @@
  *	20000513 added IDs for all products supported by Windows driver (john)
  *	20000514 Rewrote mts_scsi_queuecommand to use URBs (john)
  *	20000514 Version 0.0.8j
- *      20000514 Fix reporting of non-existant devices to SCSI layer (john)
+ *      20000514 Fix reporting of non-existent devices to SCSI layer (john)
  *	20000514 Added MTS_DEBUG_INT (john)
  *	20000514 Changed "usb-microtek" to "microtek" for consistency (john)
  *	20000514 Stupid bug fixes (john)
@@ -557,14 +557,14 @@ mts_build_transfer_context(struct scsi_cmnd *srb, struct mts_desc* desc)
 
 	if ( !memcmp( srb->cmnd, mts_read_image_sig, mts_read_image_sig_len )
 ) { 		pipe = usb_rcvbulkpipe(desc->usb_dev,desc->ep_image);
-		MTS_DEBUG( "transfering from desc->ep_image == %d\n",
+		MTS_DEBUG( "transferring from desc->ep_image == %d\n",
 			   (int)desc->ep_image );
 	} else if ( MTS_DIRECTION_IS_IN(srb->cmnd[0]) ) {
 			pipe = usb_rcvbulkpipe(desc->usb_dev,desc->ep_response);
-			MTS_DEBUG( "transfering from desc->ep_response == %d\n",
+			MTS_DEBUG( "transferring from desc->ep_response == %d\n",
 				   (int)desc->ep_response);
 	} else {
-		MTS_DEBUG("transfering to desc->ep_out == %d\n",
+		MTS_DEBUG("transferring to desc->ep_out == %d\n",
 			  (int)desc->ep_out);
 		pipe = usb_sndbulkpipe(desc->usb_dev,desc->ep_out);
 	}
diff --git a/drivers/usb/misc/iowarrior.c b/drivers/usb/misc/iowarrior.c
index e573e47..a2190b9 100644
--- a/drivers/usb/misc/iowarrior.c
+++ b/drivers/usb/misc/iowarrior.c
@@ -40,7 +40,7 @@
 #ifdef CONFIG_USB_DYNAMIC_MINORS
 #define IOWARRIOR_MINOR_BASE	0
 #else
-#define IOWARRIOR_MINOR_BASE	208	// SKELETON_MINOR_BASE 192 + 16, not offical yet
+#define IOWARRIOR_MINOR_BASE	208	// SKELETON_MINOR_BASE 192 + 16, not official yet
 #endif
 
 /* interrupt input queue size */
diff --git a/drivers/usb/otg/isp1301_omap.c b/drivers/usb/otg/isp1301_omap.c
index 8c6fdef..e25700f 100644
--- a/drivers/usb/otg/isp1301_omap.c
+++ b/drivers/usb/otg/isp1301_omap.c
@@ -1531,7 +1531,7 @@ isp1301_probe(struct i2c_client *i2c, const struct i2c_device_id *id)
 	i2c_set_clientdata(i2c, isp);
 	isp->client = i2c;
 
-	/* verify the chip (shouldn't be necesary) */
+	/* verify the chip (shouldn't be necessary) */
 	status = isp1301_get_u16(isp, ISP1301_VENDOR_ID);
 	if (status != I2C_VENDOR_ID_PHILIPS) {
 		dev_dbg(&i2c->dev, "not philips id: %d\n", status);
diff --git a/drivers/usb/otg/langwell_otg.c b/drivers/usb/otg/langwell_otg.c
index 7f9b8cd..e973ff1 100644
--- a/drivers/usb/otg/langwell_otg.c
+++ b/drivers/usb/otg/langwell_otg.c
@@ -580,7 +580,7 @@ static void langwell_otg_add_ktimer(enum langwell_otg_timer_type timers)
 		time = TB_BUS_SUSPEND;
 		break;
 	default:
-		dev_dbg(lnw->dev, "unkown timer, cannot enable it\n");
+		dev_dbg(lnw->dev, "unknown timer, cannot enable it\n");
 		return;
 	}
 
@@ -1381,7 +1381,7 @@ static void langwell_otg_work(struct work_struct *work)
 			} else if (!iotg->hsm.a_bus_req && iotg->otg.host &&
 					iotg->otg.host->b_hnp_enable) {
 				/* It is not safe enough to do a fast
-				 * transistion from A_WAIT_BCON to
+				 * transition from A_WAIT_BCON to
 				 * A_SUSPEND */
 				msleep(10000);
 				if (iotg->hsm.a_bus_req)
diff --git a/drivers/usb/serial/aircable.c b/drivers/usb/serial/aircable.c
index 0db6ace..aba201c 100644
--- a/drivers/usb/serial/aircable.c
+++ b/drivers/usb/serial/aircable.c
@@ -16,7 +16,7 @@
  * When reading the process is almost equal except that the header starts with
  * 0x00 0x20.
  *
- * The device simply need some stuff to understand data comming from the usb
+ * The device simply need some stuff to understand data coming from the usb
  * buffer: The First and Second byte is used for a Header, the Third and Fourth
  * tells the  device the amount of information the package holds.
  * Packages are 60 bytes long Header Stuff.
@@ -30,7 +30,7 @@
  * one.
  *
  * The driver registers himself with the USB-serial core and the USB Core. I had
- * to implement a probe function agains USB-serial, because other way, the
+ * to implement a probe function against USB-serial, because other way, the
  * driver was attaching himself to both interfaces. I have tryed with different
  * configurations of usb_serial_driver with out exit, only the probe function
  * could handle this correctly.
diff --git a/drivers/usb/serial/cp210x.c b/drivers/usb/serial/cp210x.c
index 4df3e0c..0f11afd 100644
--- a/drivers/usb/serial/cp210x.c
+++ b/drivers/usb/serial/cp210x.c
@@ -101,7 +101,7 @@ static const struct usb_device_id id_table[] = {
 	{ USB_DEVICE(0x10C4, 0x81F2) }, /* C1007 HF band RFID controller */
 	{ USB_DEVICE(0x10C4, 0x8218) }, /* Lipowsky Industrie Elektronik GmbH, HARP-1 */
 	{ USB_DEVICE(0x10C4, 0x822B) }, /* Modem EDGE(GSM) Comander 2 */
-	{ USB_DEVICE(0x10C4, 0x826B) }, /* Cygnal Integrated Products, Inc., Fasttrax GPS demostration module */
+	{ USB_DEVICE(0x10C4, 0x826B) }, /* Cygnal Integrated Products, Inc., Fasttrax GPS demonstration module */
 	{ USB_DEVICE(0x10C4, 0x8293) }, /* Telegesys ETRX2USB */
 	{ USB_DEVICE(0x10C4, 0x82F9) }, /* Procyon AVS */
 	{ USB_DEVICE(0x10C4, 0x8341) }, /* Siemens MC35PU GPRS Modem */
diff --git a/drivers/usb/serial/cypress_m8.c b/drivers/usb/serial/cypress_m8.c
index 987e9bf..d9906eb 100644
--- a/drivers/usb/serial/cypress_m8.c
+++ b/drivers/usb/serial/cypress_m8.c
@@ -35,7 +35,7 @@
  *
  *  Lonnie Mendez <dignome@gmail.com>
  *  04-10-2004
- *	Driver modified to support dynamic line settings.  Various improvments
+ *	Driver modified to support dynamic line settings.  Various improvements
  *      and features.
  *
  *  Neil Whelchel
diff --git a/drivers/usb/serial/ftdi_sio.c b/drivers/usb/serial/ftdi_sio.c
index 65967b3..a973c7a 100644
--- a/drivers/usb/serial/ftdi_sio.c
+++ b/drivers/usb/serial/ftdi_sio.c
@@ -17,7 +17,7 @@
  * See Documentation/usb/usb-serial.txt for more information on using this
  * driver
  *
- * See http://ftdi-usb-sio.sourceforge.net for upto date testing info
+ * See http://ftdi-usb-sio.sourceforge.net for up to date testing info
  *	and extra documentation
  *
  * Change entries from 2004 and earlier can be found in versions of this
diff --git a/drivers/usb/serial/io_edgeport.c b/drivers/usb/serial/io_edgeport.c
index f1aedfa..abf095b 100644
--- a/drivers/usb/serial/io_edgeport.c
+++ b/drivers/usb/serial/io_edgeport.c
@@ -1981,7 +1981,7 @@ static void process_rcvd_status(struct edgeport_serial *edge_serial,
 	if (code == IOSP_STATUS_OPEN_RSP) {
 		edge_port->txCredits = GET_TX_BUFFER_SIZE(byte3);
 		edge_port->maxTxCredits = edge_port->txCredits;
-		dbg("%s - Port %u Open Response Inital MSR = %02x TxBufferSize = %d", __func__, edge_serial->rxPort, byte2, edge_port->txCredits);
+		dbg("%s - Port %u Open Response Initial MSR = %02x TxBufferSize = %d", __func__, edge_serial->rxPort, byte2, edge_port->txCredits);
 		handle_new_msr(edge_port, byte2);
 
 		/* send the current line settings to the port so we are
diff --git a/drivers/usb/serial/io_edgeport.h b/drivers/usb/serial/io_edgeport.h
index dced7ec..ad9c1d4 100644
--- a/drivers/usb/serial/io_edgeport.h
+++ b/drivers/usb/serial/io_edgeport.h
@@ -68,7 +68,7 @@ struct comMapper {
 #define PROC_SET_COM_ENTRY		2
 
 
-/* The following sturcture is passed to the write */
+/* The following structure is passed to the write */
 struct procWrite {
 	int	Command;
 	union {
diff --git a/drivers/usb/serial/io_ti.c b/drivers/usb/serial/io_ti.c
index d843491..0aac00a 100644
--- a/drivers/usb/serial/io_ti.c
+++ b/drivers/usb/serial/io_ti.c
@@ -433,7 +433,7 @@ static int write_i2c_mem(struct edgeport_serial *serial,
 
 	/* We can only send a maximum of 1 aligned byte page at a time */
 
-	/* calulate the number of bytes left in the first page */
+	/* calculate the number of bytes left in the first page */
 	write_length = EPROM_PAGE_SIZE -
 				(start_address & (EPROM_PAGE_SIZE - 1));
 
diff --git a/drivers/usb/serial/opticon.c b/drivers/usb/serial/opticon.c
index a1dd4d4..1b5633f 100644
--- a/drivers/usb/serial/opticon.c
+++ b/drivers/usb/serial/opticon.c
@@ -116,7 +116,7 @@ static void opticon_read_bulk_callback(struct urb *urb)
 		} else {
 			if ((data[0] == 0x00) && (data[1] == 0x01)) {
 				spin_lock_irqsave(&priv->lock, flags);
-				/* CTS status infomation package */
+				/* CTS status information package */
 				if (data[2] == 0x00)
 					priv->cts = false;
 				else
diff --git a/drivers/usb/storage/ene_ub6250.c b/drivers/usb/storage/ene_ub6250.c
index 08e0374..0e5aafd 100644
--- a/drivers/usb/storage/ene_ub6250.c
+++ b/drivers/usb/storage/ene_ub6250.c
@@ -562,7 +562,7 @@ static int ene_sd_init(struct us_data *us)
 
 	result = ene_send_scsi_cmd(us, FDIR_READ, NULL, 0);
 	if (result != USB_STOR_XFER_GOOD) {
-		US_DEBUGP("Exection SD Init Code Fail !!\n");
+		US_DEBUGP("Execution SD Init Code Fail !!\n");
 		return USB_STOR_TRANSPORT_ERROR;
 	}
 
@@ -581,7 +581,7 @@ static int ene_sd_init(struct us_data *us)
 
 	result = ene_send_scsi_cmd(us, FDIR_READ, &buf, 0);
 	if (result != USB_STOR_XFER_GOOD) {
-		US_DEBUGP("Exection SD Init Code Fail !!\n");
+		US_DEBUGP("Execution SD Init Code Fail !!\n");
 		return USB_STOR_TRANSPORT_ERROR;
 	}
 
diff --git a/drivers/usb/storage/isd200.c b/drivers/usb/storage/isd200.c
index 6b9982c..09e52ba 100644
--- a/drivers/usb/storage/isd200.c
+++ b/drivers/usb/storage/isd200.c
@@ -1510,7 +1510,7 @@ static int isd200_Initialization(struct us_data *us)
  * Protocol and Transport for the ISD200 ASIC
  *
  * This protocol and transport are for ATA devices connected to an ISD200
- * ASIC.  An ATAPI device that is conected as a slave device will be
+ * ASIC.  An ATAPI device that is connected as a slave device will be
  * detected in the driver initialization function and the protocol will
  * be changed to an ATAPI protocol (Transparent SCSI).
  *
diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index 689ee1f..13b8bcd 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -123,7 +123,7 @@ static int slave_configure(struct scsi_device *sdev)
 {
 	struct us_data *us = host_to_us(sdev->host);
 
-	/* Many devices have trouble transfering more than 32KB at a time,
+	/* Many devices have trouble transferring more than 32KB at a time,
 	 * while others have trouble with more than 64K. At this time we
 	 * are limiting both to 32K (64 sectores).
 	 */
diff --git a/drivers/usb/storage/shuttle_usbat.c b/drivers/usb/storage/shuttle_usbat.c
index bd3f415..0b00091 100644
--- a/drivers/usb/storage/shuttle_usbat.c
+++ b/drivers/usb/storage/shuttle_usbat.c
@@ -340,7 +340,7 @@ static int usbat_check_status(struct us_data *us)
 }
 
 /*
- * Stores critical information in internal registers in prepartion for the execution
+ * Stores critical information in internal registers in preparation for the execution
  * of a conditional usbat_read_blocks or usbat_write_blocks call.
  */
 static int usbat_set_shuttle_features(struct us_data *us,
diff --git a/drivers/usb/wusbcore/crypto.c b/drivers/usb/wusbcore/crypto.c
index 827c87f..7e4bf95 100644
--- a/drivers/usb/wusbcore/crypto.c
+++ b/drivers/usb/wusbcore/crypto.c
@@ -180,7 +180,7 @@ static void bytewise_xor(void *_bo, const void *_bi1, const void *_bi2,
  *     using the 14 bytes of @a to fill up
  *     b1.{mac_header,e0,security_reserved,padding}.
  *
- * NOTE: The definiton of l(a) in WUSB1.0[6.5] vs the definition of
+ * NOTE: The definition of l(a) in WUSB1.0[6.5] vs the definition of
  *       l(m) is orthogonal, they bear no relationship, so it is not
  *       in conflict with the parameter's relation that
  *       WUSB1.0[6.4.2]) defines.
@@ -272,7 +272,7 @@ static int wusb_ccm_mac(struct crypto_blkcipher *tfm_cbc,
 
 	/* Now we crypt the MIC Tag (*iv) with Ax -- values per WUSB1.0[6.5]
 	 * The procedure is to AES crypt the A0 block and XOR the MIC
-	 * Tag agains it; we only do the first 8 bytes and place it
+	 * Tag against it; we only do the first 8 bytes and place it
 	 * directly in the destination buffer.
 	 *
 	 * POS Crypto API: size is assumed to be AES's block size.
diff --git a/drivers/usb/wusbcore/reservation.c b/drivers/usb/wusbcore/reservation.c
index 4ed9736..6f4fafd 100644
--- a/drivers/usb/wusbcore/reservation.c
+++ b/drivers/usb/wusbcore/reservation.c
@@ -71,7 +71,7 @@ static void wusbhc_rsv_complete_cb(struct uwb_rsv *rsv)
 
 /**
  * wusbhc_rsv_establish - establish a reservation for the cluster
- * @wusbhc: the WUSB HC requesting a bandwith reservation
+ * @wusbhc: the WUSB HC requesting a bandwidth reservation
  */
 int wusbhc_rsv_establish(struct wusbhc *wusbhc)
 {
diff --git a/drivers/usb/wusbcore/rh.c b/drivers/usb/wusbcore/rh.c
index c175b73..39de390 100644
--- a/drivers/usb/wusbcore/rh.c
+++ b/drivers/usb/wusbcore/rh.c
@@ -133,7 +133,7 @@ static int wusbhc_rh_port_reset(struct wusbhc *wusbhc, u8 port_idx)
  *           big of a problem [and we can't make it an spinlock
  *           because other parts need to take it and sleep] .
  *
- *           @usb_hcd is refcounted, so it won't dissapear under us
+ *           @usb_hcd is refcounted, so it won't disappear under us
  *           and before killing a host, the polling of the root hub
  *           would be stopped anyway.
  */
diff --git a/drivers/usb/wusbcore/wa-rpipe.c b/drivers/usb/wusbcore/wa-rpipe.c
index 8cb9d80..ca80171 100644
--- a/drivers/usb/wusbcore/wa-rpipe.c
+++ b/drivers/usb/wusbcore/wa-rpipe.c
@@ -24,7 +24,7 @@
  *
  * RPIPE
  *
- *   Targetted at different downstream endpoints
+ *   Targeted at different downstream endpoints
  *
  *   Descriptor: use to config the remote pipe.
  *
diff --git a/drivers/usb/wusbcore/wa-xfer.c b/drivers/usb/wusbcore/wa-xfer.c
index 84b744c..6ccd93a 100644
--- a/drivers/usb/wusbcore/wa-xfer.c
+++ b/drivers/usb/wusbcore/wa-xfer.c
@@ -61,7 +61,7 @@
  *
  *     Two methods it could be done:
  *
- *     (a) set up a timer everytime an rpipe's use count drops to 1
+ *     (a) set up a timer every time an rpipe's use count drops to 1
  *         (which means unused) or when a transfer ends. Reset the
  *         timer when a xfer is queued. If the timer expires, release
  *         the rpipe [see rpipe_ep_disable()].
@@ -140,7 +140,7 @@ struct wa_xfer {
 
 	struct wahc *wa;		/* Wire adapter we are plugged to */
 	struct usb_host_endpoint *ep;
-	struct urb *urb;		/* URB we are transfering for */
+	struct urb *urb;		/* URB we are transferring for */
 	struct wa_seg **seg;		/* transfer segments */
 	u8 segs, segs_submitted, segs_done;
 	unsigned is_inbound:1;
@@ -161,7 +161,7 @@ static inline void wa_xfer_init(struct wa_xfer *xfer)
 }
 
 /*
- * Destory a transfer structure
+ * Destroy a transfer structure
  *
  * Note that the xfer->seg[index] thingies follow the URB life cycle,
  * so we need to put them, not free them.
@@ -494,7 +494,7 @@ static void __wa_xfer_setup_hdr0(struct wa_xfer *xfer,
  * function does almost the same thing and they work closely
  * together.
  *
- * If the seg request has failed but this DTO phase has suceeded,
+ * If the seg request has failed but this DTO phase has succeeded,
  * wa_seg_cb() has already failed the segment and moved the
  * status to WA_SEG_ERROR, so this will go through 'case 0' and
  * effectively do nothing.
diff --git a/drivers/usb/wusbcore/wusbhc.h b/drivers/usb/wusbcore/wusbhc.h
index 6bd426b..3a2d091 100644
--- a/drivers/usb/wusbcore/wusbhc.h
+++ b/drivers/usb/wusbcore/wusbhc.h
@@ -231,7 +231,7 @@ struct wusb_port {
  *
  *    Most of the times when you need to use it, it will be non-NULL,
  *    so there is no real need to check for it (wusb_dev will
- *    dissapear before usb_dev).
+ *    disappear before usb_dev).
  *
  *  - The following fields need to be filled out before calling
  *    wusbhc_create(): ports_max, mmcies_max, mmcie_{add,rm}.
diff --git a/drivers/uwb/driver.c b/drivers/uwb/driver.c
index 08bd6db..3e5454a 100644
--- a/drivers/uwb/driver.c
+++ b/drivers/uwb/driver.c
@@ -61,7 +61,7 @@
 
 
 /**
- * If a beacon dissapears for longer than this, then we consider the
+ * If a beacon disappears for longer than this, then we consider the
  * device who was represented by that beacon to be gone.
  *
  * ECMA-368[17.2.3, last para] establishes that a device must not
diff --git a/drivers/uwb/drp.c b/drivers/uwb/drp.c
index a8d83e2..3fbcf78 100644
--- a/drivers/uwb/drp.c
+++ b/drivers/uwb/drp.c
@@ -27,7 +27,7 @@
 
 /* DRP Conflict Actions ([ECMA-368 2nd Edition] 17.4.6) */
 enum uwb_drp_conflict_action {
-	/* Reservation is mantained, no action needed */
+	/* Reservation is maintained, no action needed */
 	UWB_DRP_CONFLICT_MANTAIN = 0,
 	
 	/* the device shall not transmit frames in conflicting MASs in
@@ -741,12 +741,12 @@ void uwb_drp_process_all(struct uwb_rc *rc, struct uwb_rc_evt_drp *drp_evt,
  * DRP notifications can occur for three different reasons:
  *
  * - UWB_DRP_NOTIF_DRP_IE_RECVD: one or more DRP IEs with the RC as
- *   the target or source have been recieved.
+ *   the target or source have been received.
  *
  *   These DRP IEs could be new or for an existing reservation.
  *
  *   If the DRP IE for an existing reservation ceases to be to
- *   recieved for at least mMaxLostBeacons, the reservation should be
+ *   received for at least mMaxLostBeacons, the reservation should be
  *   considered to be terminated.  Note that the TERMINATE reason (see
  *   below) may not always be signalled (e.g., the remote device has
  *   two or more reservations established with the RC).
diff --git a/drivers/uwb/lc-rc.c b/drivers/uwb/lc-rc.c
index b0091c7..b4395f4 100644
--- a/drivers/uwb/lc-rc.c
+++ b/drivers/uwb/lc-rc.c
@@ -168,7 +168,7 @@ int uwb_rc_mac_addr_setup(struct uwb_rc *rc)
 	}
 
 	if (uwb_mac_addr_unset(&addr) || uwb_mac_addr_bcast(&addr)) {
-		addr.data[0] = 0x02; /* locally adminstered and unicast */
+		addr.data[0] = 0x02; /* locally administered and unicast */
 		get_random_bytes(&addr.data[1], sizeof(addr.data)-1);
 
 		result = uwb_rc_mac_addr_set(rc, &addr);
diff --git a/drivers/uwb/reset.c b/drivers/uwb/reset.c
index 2784929..3de630b 100644
--- a/drivers/uwb/reset.c
+++ b/drivers/uwb/reset.c
@@ -52,7 +52,7 @@ const char *__strerror[] = {
 	"cancelled",
 	"invalid state",
 	"invalid size",
-	"ack not recieved",
+	"ack not received",
 	"no more asie notification",
 };
 
diff --git a/drivers/uwb/umc-dev.c b/drivers/uwb/umc-dev.c
index ccd2184..b2948ec 100644
--- a/drivers/uwb/umc-dev.c
+++ b/drivers/uwb/umc-dev.c
@@ -78,7 +78,7 @@ EXPORT_SYMBOL_GPL(umc_device_register);
  * First we unregister the device, make sure the driver can do it's
  * resource release thing and then we try to release any left over
  * resources. We take a ref to the device, to make sure it doesn't
- * dissapear under our feet.
+ * disappear under our feet.
  */
 void umc_device_unregister(struct umc_dev *umc)
 {
diff --git a/drivers/video/atmel_lcdfb.c b/drivers/video/atmel_lcdfb.c
index ccecf99..4484c72 100644
--- a/drivers/video/atmel_lcdfb.c
+++ b/drivers/video/atmel_lcdfb.c
@@ -637,7 +637,7 @@ static inline unsigned int chan_to_field(unsigned int chan, const struct fb_bitf
  *  	magnitude which needs to be scaled in this function for the hardware.
  *	Things to take into consideration are how many color registers, if
  *	any, are supported with the current color visual. With truecolor mode
- *	no color palettes are supported. Here a psuedo palette is created
+ *	no color palettes are supported. Here a pseudo palette is created
  *	which we store the value in pseudo_palette in struct fb_info. For
  *	pseudocolor mode we have a limited color palette. To deal with this
  *	we can program what color is displayed for a particular pixel value.
diff --git a/drivers/video/aty/atyfb_base.c b/drivers/video/aty/atyfb_base.c
index d437b3d..ebb893c 100644
--- a/drivers/video/aty/atyfb_base.c
+++ b/drivers/video/aty/atyfb_base.c
@@ -3124,12 +3124,12 @@ static int __devinit atyfb_setup_sparc(struct pci_dev *pdev,
 		M = pll_regs[2];
 
 		/*
-		 * PLL Feedback Divider N (Dependant on CLOCK_CNTL):
+		 * PLL Feedback Divider N (Dependent on CLOCK_CNTL):
 		 */
 		N = pll_regs[7 + (clock_cntl & 3)];
 
 		/*
-		 * PLL Post Divider P (Dependant on CLOCK_CNTL):
+		 * PLL Post Divider P (Dependent on CLOCK_CNTL):
 		 */
 		P = 1 << (pll_regs[6] >> ((clock_cntl & 3) << 1));
 
diff --git a/drivers/video/aty/mach64_cursor.c b/drivers/video/aty/mach64_cursor.c
index 2ba8b3c..46f72ed 100644
--- a/drivers/video/aty/mach64_cursor.c
+++ b/drivers/video/aty/mach64_cursor.c
@@ -51,7 +51,7 @@
  * to a larger number and saturate CUR_HORZ_POSN to zero.
  *
  * if Y becomes negative, CUR_VERT_OFFSET must be adjusted to a larger number,
- * CUR_OFFSET must be adjusted to a point to the appropraite line in the cursor
+ * CUR_OFFSET must be adjusted to a point to the appropriate line in the cursor
  * definitation and CUR_VERT_POSN must be saturated to zero.
  */
 
diff --git a/drivers/video/au1200fb.c b/drivers/video/au1200fb.c
index 4ea187d..5dff32a 100644
--- a/drivers/video/au1200fb.c
+++ b/drivers/video/au1200fb.c
@@ -1572,7 +1572,7 @@ static int au1200fb_init_fbinfo(struct au1200fb_device *fbdev)
 	/* Copy monitor specs from panel data */
 	/* fixme: we're setting up LCD controller windows, so these dont give a
 	damn as to what the monitor specs are (the panel itself does, but that
-	isnt done here...so maybe need a generic catchall monitor setting??? */
+	isn't done here...so maybe need a generic catchall monitor setting??? */
 	memcpy(&fbi->monspecs, &panel->monspecs, sizeof(struct fb_monspecs));
 
 	/* We first try the user mode passed in argument. If that failed,
diff --git a/drivers/video/backlight/corgi_lcd.c b/drivers/video/backlight/corgi_lcd.c
index af60983..c6533ba 100644
--- a/drivers/video/backlight/corgi_lcd.c
+++ b/drivers/video/backlight/corgi_lcd.c
@@ -109,7 +109,7 @@ static unsigned long corgibl_flags;
 #define CORGIBL_BATTLOW       0x02
 
 /*
- * This is only a psuedo I2C interface. We can't use the standard kernel
+ * This is only a pseudo I2C interface. We can't use the standard kernel
  * routines as the interface is write only. We just assume the data is acked...
  */
 static void lcdtg_ssp_i2c_send(struct corgi_lcd *lcd, uint8_t data)
diff --git a/drivers/video/backlight/locomolcd.c b/drivers/video/backlight/locomolcd.c
index bbca312..be20b5c 100644
--- a/drivers/video/backlight/locomolcd.c
+++ b/drivers/video/backlight/locomolcd.c
@@ -6,7 +6,7 @@
  * GPL v2
  *
  * This driver assumes single CPU. That's okay, because collie is
- * slightly old hardware, and noone is going to retrofit second CPU to
+ * slightly old hardware, and no one is going to retrofit second CPU to
  * old PDA.
  */
 
diff --git a/drivers/video/bfin-lq035q1-fb.c b/drivers/video/bfin-lq035q1-fb.c
index c8e1f04..23b6c4b 100644
--- a/drivers/video/bfin-lq035q1-fb.c
+++ b/drivers/video/bfin-lq035q1-fb.c
@@ -154,8 +154,10 @@ static int __devinit lq035q1_spidev_probe(struct spi_device *spi)
 
 	ret = lq035q1_control(spi, LQ035_SHUT_CTL, LQ035_ON);
 	ret |= lq035q1_control(spi, LQ035_DRIVER_OUTPUT_CTL, ctl->mode);
-	if (ret)
+	if (ret) {
+		kfree(ctl);
 		return ret;
+	}
 
 	spi_set_drvdata(spi, ctl);
 
diff --git a/drivers/video/bfin_adv7393fb.h b/drivers/video/bfin_adv7393fb.h
index 8c7f9e4..cd591b5 100644
--- a/drivers/video/bfin_adv7393fb.h
+++ b/drivers/video/bfin_adv7393fb.h
@@ -87,12 +87,12 @@ static const u8 init_NTSC_TESTPATTERN[] = {
 
 static const u8 init_NTSC[] = {
 	0x00, 0x1E,	/* Power up all DACs and PLL */
-	0xC3, 0x26,	/* Program RGB->YCrCb Color Space convertion matrix */
-	0xC5, 0x12,	/* Program RGB->YCrCb Color Space convertion matrix */
-	0xC2, 0x4A,	/* Program RGB->YCrCb Color Space convertion matrix */
-	0xC6, 0x5E,	/* Program RGB->YCrCb Color Space convertion matrix */
-	0xBD, 0x19,	/* Program RGB->YCrCb Color Space convertion matrix */
-	0xBF, 0x42,	/* Program RGB->YCrCb Color Space convertion matrix */
+	0xC3, 0x26,	/* Program RGB->YCrCb Color Space conversion matrix */
+	0xC5, 0x12,	/* Program RGB->YCrCb Color Space conversion matrix */
+	0xC2, 0x4A,	/* Program RGB->YCrCb Color Space conversion matrix */
+	0xC6, 0x5E,	/* Program RGB->YCrCb Color Space conversion matrix */
+	0xBD, 0x19,	/* Program RGB->YCrCb Color Space conversion matrix */
+	0xBF, 0x42,	/* Program RGB->YCrCb Color Space conversion matrix */
 	0x8C, 0x1F,	/* NTSC Subcarrier Frequency */
 	0x8D, 0x7C,	/* NTSC Subcarrier Frequency */
 	0x8E, 0xF0,	/* NTSC Subcarrier Frequency */
@@ -109,12 +109,12 @@ static const u8 init_NTSC[] = {
 
 static const u8 init_PAL[] = {
 	0x00, 0x1E,	/* Power up all DACs and PLL */
-	0xC3, 0x26,	/* Program RGB->YCrCb Color Space convertion matrix */
-	0xC5, 0x12,	/* Program RGB->YCrCb Color Space convertion matrix */
-	0xC2, 0x4A,	/* Program RGB->YCrCb Color Space convertion matrix */
-	0xC6, 0x5E,	/* Program RGB->YCrCb Color Space convertion matrix */
-	0xBD, 0x19,	/* Program RGB->YCrCb Color Space convertion matrix */
-	0xBF, 0x42,	/* Program RGB->YCrCb Color Space convertion matrix */
+	0xC3, 0x26,	/* Program RGB->YCrCb Color Space conversion matrix */
+	0xC5, 0x12,	/* Program RGB->YCrCb Color Space conversion matrix */
+	0xC2, 0x4A,	/* Program RGB->YCrCb Color Space conversion matrix */
+	0xC6, 0x5E,	/* Program RGB->YCrCb Color Space conversion matrix */
+	0xBD, 0x19,	/* Program RGB->YCrCb Color Space conversion matrix */
+	0xBF, 0x42,	/* Program RGB->YCrCb Color Space conversion matrix */
 	0x8C, 0xCB,	/* PAL Subcarrier Frequency */
 	0x8D, 0x8A,	/* PAL Subcarrier Frequency */
 	0x8E, 0x09,	/* PAL Subcarrier Frequency */
diff --git a/drivers/video/console/fbcon.c b/drivers/video/console/fbcon.c
index c583934..8745637 100644
--- a/drivers/video/console/fbcon.c
+++ b/drivers/video/console/fbcon.c
@@ -370,7 +370,6 @@ static void fb_flashcursor(struct work_struct *work)
 {
 	struct fb_info *info = container_of(work, struct fb_info, queue);
 	struct fbcon_ops *ops = info->fbcon_par;
-	struct display *p;
 	struct vc_data *vc = NULL;
 	int c;
 	int mode;
@@ -386,7 +385,6 @@ static void fb_flashcursor(struct work_struct *work)
 		return;
 	}
 
-	p = &fb_display[vc->vc_num];
 	c = scr_readw((u16 *) vc->vc_pos);
 	mode = (!ops->cursor_flash || ops->cursor_state.enable) ?
 		CM_ERASE : CM_DRAW;
diff --git a/drivers/video/console/font_mini_4x6.c b/drivers/video/console/font_mini_4x6.c
index a19a7f3..fa6e698 100644
--- a/drivers/video/console/font_mini_4x6.c
+++ b/drivers/video/console/font_mini_4x6.c
@@ -1,5 +1,5 @@
 
-/* Hand composed "Miniscule" 4x6 font, with binary data generated using
+/* Hand composed "Minuscule" 4x6 font, with binary data generated using
  * Perl stub.
  *
  * Use 'perl -x mini_4x6.c < mini_4x6.c > new_version.c' to regenerate
diff --git a/drivers/video/da8xx-fb.c b/drivers/video/da8xx-fb.c
index 8d61ef9..8b7d473 100644
--- a/drivers/video/da8xx-fb.c
+++ b/drivers/video/da8xx-fb.c
@@ -763,7 +763,7 @@ static int fb_wait_for_vsync(struct fb_info *info)
 
 	/*
 	 * Set flag to 0 and wait for isr to set to 1. It would seem there is a
-	 * race condition here where the ISR could have occured just before or
+	 * race condition here where the ISR could have occurred just before or
 	 * just after this set. But since we are just coarsely waiting for
 	 * a frame to complete then that's OK. i.e. if the frame completed
 	 * just before this code executed then we have to wait another full
diff --git a/drivers/video/display/display-sysfs.c b/drivers/video/display/display-sysfs.c
index f6a09ab..0c647d7 100644
--- a/drivers/video/display/display-sysfs.c
+++ b/drivers/video/display/display-sysfs.c
@@ -182,7 +182,7 @@ void display_device_unregister(struct display_device *ddev)
 	mutex_lock(&ddev->lock);
 	device_unregister(ddev->dev);
 	mutex_unlock(&ddev->lock);
-	// Mark device index as avaliable
+	// Mark device index as available
 	mutex_lock(&allocated_dsp_lock);
 	idr_remove(&allocated_dsp, ddev->idx);
 	mutex_unlock(&allocated_dsp_lock);
diff --git a/drivers/video/efifb.c b/drivers/video/efifb.c
index 70477c2..4eb38db 100644
--- a/drivers/video/efifb.c
+++ b/drivers/video/efifb.c
@@ -53,6 +53,7 @@ enum {
 	M_MB_7_1,	/* MacBook, 7th rev. */
 	M_MB_SR,	/* MacBook, 2nd gen, (Santa Rosa) */
 	M_MBA,		/* MacBook Air */
+	M_MBA_3,	/* Macbook Air, 3rd rev */
 	M_MBP,		/* MacBook Pro */
 	M_MBP_2,	/* MacBook Pro 2nd gen */
 	M_MBP_2_2,	/* MacBook Pro 2,2nd gen */
@@ -64,43 +65,54 @@ enum {
 	M_MBP_6_1,	/* MacBook Pro, 6,1th gen */
 	M_MBP_6_2,	/* MacBook Pro, 6,2th gen */
 	M_MBP_7_1,	/* MacBook Pro, 7,1th gen */
+	M_MBP_8_2,	/* MacBook Pro, 8,2nd gen */
 	M_UNKNOWN	/* placeholder */
 };
 
+#define OVERRIDE_NONE	0x0
+#define OVERRIDE_BASE	0x1
+#define OVERRIDE_STRIDE	0x2
+#define OVERRIDE_HEIGHT	0x4
+#define OVERRIDE_WIDTH	0x8
+
 static struct efifb_dmi_info {
 	char *optname;
 	unsigned long base;
 	int stride;
 	int width;
 	int height;
+	int flags;
 } dmi_list[] __initdata = {
-	[M_I17] = { "i17", 0x80010000, 1472 * 4, 1440, 900 },
-	[M_I20] = { "i20", 0x80010000, 1728 * 4, 1680, 1050 }, /* guess */
-	[M_I20_SR] = { "imac7", 0x40010000, 1728 * 4, 1680, 1050 },
-	[M_I24] = { "i24", 0x80010000, 2048 * 4, 1920, 1200 }, /* guess */
-	[M_I24_8_1] = { "imac8", 0xc0060000, 2048 * 4, 1920, 1200 },
-	[M_I24_10_1] = { "imac10", 0xc0010000, 2048 * 4, 1920, 1080 },
-	[M_I27_11_1] = { "imac11", 0xc0010000, 2560 * 4, 2560, 1440 },
-	[M_MINI]= { "mini", 0x80000000, 2048 * 4, 1024, 768 },
-	[M_MINI_3_1] = { "mini31", 0x40010000, 1024 * 4, 1024, 768 },
-	[M_MINI_4_1] = { "mini41", 0xc0010000, 2048 * 4, 1920, 1200 },
-	[M_MB] = { "macbook", 0x80000000, 2048 * 4, 1280, 800 },
-	[M_MB_5_1] = { "macbook51", 0x80010000, 2048 * 4, 1280, 800 },
-	[M_MB_6_1] = { "macbook61", 0x80010000, 2048 * 4, 1280, 800 },
-	[M_MB_7_1] = { "macbook71", 0x80010000, 2048 * 4, 1280, 800 },
-	[M_MBA] = { "mba", 0x80000000, 2048 * 4, 1280, 800 },
-	[M_MBP] = { "mbp", 0x80010000, 1472 * 4, 1440, 900 },
-	[M_MBP_2] = { "mbp2", 0, 0, 0, 0 }, /* placeholder */
-	[M_MBP_2_2] = { "mbp22", 0x80010000, 1472 * 4, 1440, 900 },
-	[M_MBP_SR] = { "mbp3", 0x80030000, 2048 * 4, 1440, 900 },
-	[M_MBP_4] = { "mbp4", 0xc0060000, 2048 * 4, 1920, 1200 },
-	[M_MBP_5_1] = { "mbp51", 0xc0010000, 2048 * 4, 1440, 900 },
-	[M_MBP_5_2] = { "mbp52", 0xc0010000, 2048 * 4, 1920, 1200 },
-	[M_MBP_5_3] = { "mbp53", 0xd0010000, 2048 * 4, 1440, 900 },
-	[M_MBP_6_1] = { "mbp61", 0x90030000, 2048 * 4, 1920, 1200 },
-	[M_MBP_6_2] = { "mbp62", 0x90030000, 2048 * 4, 1680, 1050 },
-	[M_MBP_7_1] = { "mbp71", 0xc0010000, 2048 * 4, 1280, 800 },
-	[M_UNKNOWN] = { NULL, 0, 0, 0, 0 }
+	[M_I17] = { "i17", 0x80010000, 1472 * 4, 1440, 900, OVERRIDE_NONE },
+	[M_I20] = { "i20", 0x80010000, 1728 * 4, 1680, 1050, OVERRIDE_NONE }, /* guess */
+	[M_I20_SR] = { "imac7", 0x40010000, 1728 * 4, 1680, 1050, OVERRIDE_NONE },
+	[M_I24] = { "i24", 0x80010000, 2048 * 4, 1920, 1200, OVERRIDE_NONE }, /* guess */
+	[M_I24_8_1] = { "imac8", 0xc0060000, 2048 * 4, 1920, 1200, OVERRIDE_NONE },
+	[M_I24_10_1] = { "imac10", 0xc0010000, 2048 * 4, 1920, 1080, OVERRIDE_NONE },
+	[M_I27_11_1] = { "imac11", 0xc0010000, 2560 * 4, 2560, 1440, OVERRIDE_NONE },
+	[M_MINI]= { "mini", 0x80000000, 2048 * 4, 1024, 768, OVERRIDE_NONE },
+	[M_MINI_3_1] = { "mini31", 0x40010000, 1024 * 4, 1024, 768, OVERRIDE_NONE },
+	[M_MINI_4_1] = { "mini41", 0xc0010000, 2048 * 4, 1920, 1200, OVERRIDE_NONE },
+	[M_MB] = { "macbook", 0x80000000, 2048 * 4, 1280, 800, OVERRIDE_NONE },
+	[M_MB_5_1] = { "macbook51", 0x80010000, 2048 * 4, 1280, 800, OVERRIDE_NONE },
+	[M_MB_6_1] = { "macbook61", 0x80010000, 2048 * 4, 1280, 800, OVERRIDE_NONE },
+	[M_MB_7_1] = { "macbook71", 0x80010000, 2048 * 4, 1280, 800, OVERRIDE_NONE },
+	[M_MBA] = { "mba", 0x80000000, 2048 * 4, 1280, 800, OVERRIDE_NONE },
+	/* 11" Macbook Air 3,1 passes the wrong stride */
+	[M_MBA_3] = { "mba3", 0, 2048 * 4, 0, 0, OVERRIDE_STRIDE },
+	[M_MBP] = { "mbp", 0x80010000, 1472 * 4, 1440, 900, OVERRIDE_NONE },
+	[M_MBP_2] = { "mbp2", 0, 0, 0, 0, OVERRIDE_NONE }, /* placeholder */
+	[M_MBP_2_2] = { "mbp22", 0x80010000, 1472 * 4, 1440, 900, OVERRIDE_NONE },
+	[M_MBP_SR] = { "mbp3", 0x80030000, 2048 * 4, 1440, 900, OVERRIDE_NONE },
+	[M_MBP_4] = { "mbp4", 0xc0060000, 2048 * 4, 1920, 1200, OVERRIDE_NONE },
+	[M_MBP_5_1] = { "mbp51", 0xc0010000, 2048 * 4, 1440, 900, OVERRIDE_NONE },
+	[M_MBP_5_2] = { "mbp52", 0xc0010000, 2048 * 4, 1920, 1200, OVERRIDE_NONE },
+	[M_MBP_5_3] = { "mbp53", 0xd0010000, 2048 * 4, 1440, 900, OVERRIDE_NONE },
+	[M_MBP_6_1] = { "mbp61", 0x90030000, 2048 * 4, 1920, 1200, OVERRIDE_NONE },
+	[M_MBP_6_2] = { "mbp62", 0x90030000, 2048 * 4, 1680, 1050, OVERRIDE_NONE },
+	[M_MBP_7_1] = { "mbp71", 0xc0010000, 2048 * 4, 1280, 800, OVERRIDE_NONE },
+	[M_MBP_8_2] = { "mbp82", 0x90010000, 1472 * 4, 1440, 900, OVERRIDE_NONE },
+	[M_UNKNOWN] = { NULL, 0, 0, 0, 0, OVERRIDE_NONE }
 };
 
 static int set_system(const struct dmi_system_id *id);
@@ -138,6 +150,7 @@ static const struct dmi_system_id dmi_system_table[] __initconst = {
 	EFIFB_DMI_SYSTEM_ID("Apple Inc.", "MacBook6,1", M_MB_6_1),
 	EFIFB_DMI_SYSTEM_ID("Apple Inc.", "MacBook7,1", M_MB_7_1),
 	EFIFB_DMI_SYSTEM_ID("Apple Inc.", "MacBookAir1,1", M_MBA),
+	EFIFB_DMI_SYSTEM_ID("Apple Inc.", "MacBookAir3,1", M_MBA_3),
 	EFIFB_DMI_SYSTEM_ID("Apple Computer, Inc.", "MacBookPro1,1", M_MBP),
 	EFIFB_DMI_SYSTEM_ID("Apple Computer, Inc.", "MacBookPro2,1", M_MBP_2),
 	EFIFB_DMI_SYSTEM_ID("Apple Computer, Inc.", "MacBookPro2,2", M_MBP_2_2),
@@ -151,19 +164,26 @@ static const struct dmi_system_id dmi_system_table[] __initconst = {
 	EFIFB_DMI_SYSTEM_ID("Apple Inc.", "MacBookPro6,1", M_MBP_6_1),
 	EFIFB_DMI_SYSTEM_ID("Apple Inc.", "MacBookPro6,2", M_MBP_6_2),
 	EFIFB_DMI_SYSTEM_ID("Apple Inc.", "MacBookPro7,1", M_MBP_7_1),
+	EFIFB_DMI_SYSTEM_ID("Apple Inc.", "MacBookPro8,2", M_MBP_8_2),
 	{},
 };
 
+#define choose_value(dmivalue, fwvalue, field, flags) ({	\
+		typeof(fwvalue) _ret_ = fwvalue;		\
+		if ((flags) & (field))				\
+			_ret_ = dmivalue;			\
+		else if ((fwvalue) == 0)			\
+			_ret_ = dmivalue;			\
+		_ret_;						\
+	})
+
 static int set_system(const struct dmi_system_id *id)
 {
 	struct efifb_dmi_info *info = id->driver_data;
-	if (info->base == 0)
-		return 0;
 
-	printk(KERN_INFO "efifb: dmi detected %s - framebuffer at %p "
-			 "(%dx%d, stride %d)\n", id->ident,
-			 (void *)info->base, info->width, info->height,
-			 info->stride);
+	if (info->base == 0 && info->height == 0 && info->width == 0
+			&& info->stride == 0)
+		return 0;
 
 	/* Trust the bootloader over the DMI tables */
 	if (screen_info.lfb_base == 0) {
@@ -171,40 +191,47 @@ static int set_system(const struct dmi_system_id *id)
 		struct pci_dev *dev = NULL;
 		int found_bar = 0;
 #endif
-		screen_info.lfb_base = info->base;
+		if (info->base) {
+			screen_info.lfb_base = choose_value(info->base,
+				screen_info.lfb_base, OVERRIDE_BASE,
+				info->flags);
 
 #if defined(CONFIG_PCI)
-		/* make sure that the address in the table is actually on a
-		 * VGA device's PCI BAR */
-
-		for_each_pci_dev(dev) {
-			int i;
-			if ((dev->class >> 8) != PCI_CLASS_DISPLAY_VGA)
-				continue;
-			for (i = 0; i < DEVICE_COUNT_RESOURCE; i++) {
-				resource_size_t start, end;
-
-				start = pci_resource_start(dev, i);
-				if (start == 0)
-					break;
-				end = pci_resource_end(dev, i);
-				if (screen_info.lfb_base >= start &&
-						screen_info.lfb_base < end) {
-					found_bar = 1;
+			/* make sure that the address in the table is actually
+			 * on a VGA device's PCI BAR */
+
+			for_each_pci_dev(dev) {
+				int i;
+				if ((dev->class >> 8) != PCI_CLASS_DISPLAY_VGA)
+					continue;
+				for (i = 0; i < DEVICE_COUNT_RESOURCE; i++) {
+					resource_size_t start, end;
+
+					start = pci_resource_start(dev, i);
+					if (start == 0)
+						break;
+					end = pci_resource_end(dev, i);
+					if (screen_info.lfb_base >= start &&
+					    screen_info.lfb_base < end) {
+						found_bar = 1;
+					}
 				}
 			}
-		}
-		if (!found_bar)
-			screen_info.lfb_base = 0;
+			if (!found_bar)
+				screen_info.lfb_base = 0;
 #endif
+		}
 	}
 	if (screen_info.lfb_base) {
-		if (screen_info.lfb_linelength == 0)
-			screen_info.lfb_linelength = info->stride;
-		if (screen_info.lfb_width == 0)
-			screen_info.lfb_width = info->width;
-		if (screen_info.lfb_height == 0)
-			screen_info.lfb_height = info->height;
+		screen_info.lfb_linelength = choose_value(info->stride,
+			screen_info.lfb_linelength, OVERRIDE_STRIDE,
+			info->flags);
+		screen_info.lfb_width = choose_value(info->width,
+			screen_info.lfb_width, OVERRIDE_WIDTH,
+			info->flags);
+		screen_info.lfb_height = choose_value(info->height,
+			screen_info.lfb_height, OVERRIDE_HEIGHT,
+			info->flags);
 		if (screen_info.orig_video_isVGA == 0)
 			screen_info.orig_video_isVGA = VIDEO_TYPE_EFI;
 	} else {
@@ -214,6 +241,13 @@ static int set_system(const struct dmi_system_id *id)
 		screen_info.orig_video_isVGA = 0;
 		return 0;
 	}
+
+	printk(KERN_INFO "efifb: dmi detected %s - framebuffer at %p "
+			 "(%dx%d, stride %d)\n", id->ident,
+			 (void *)screen_info.lfb_base, screen_info.lfb_width,
+			 screen_info.lfb_height, screen_info.lfb_linelength);
+
+
 	return 1;
 }
 
diff --git a/drivers/video/ep93xx-fb.c b/drivers/video/ep93xx-fb.c
index b358d04..cbdb1bd 100644
--- a/drivers/video/ep93xx-fb.c
+++ b/drivers/video/ep93xx-fb.c
@@ -456,7 +456,7 @@ static int __init ep93xxfb_alloc_videomem(struct fb_info *info)
 	 * There is a bug in the ep93xx framebuffer which causes problems
 	 * if bit 27 of the physical address is set.
 	 * See: http://marc.info/?l=linux-arm-kernel&m=110061245502000&w=2
-	 * There does not seem to be any offical errata for this, but I
+	 * There does not seem to be any official errata for this, but I
 	 * have confirmed the problem exists on my hardware (ep9315) at
 	 * least.
 	 */
diff --git a/drivers/video/fbmem.c b/drivers/video/fbmem.c
index e2bf953..e0c2284 100644
--- a/drivers/video/fbmem.c
+++ b/drivers/video/fbmem.c
@@ -1507,7 +1507,7 @@ void remove_conflicting_framebuffers(struct apertures_struct *a,
 			(primary && gen_aper && gen_aper->count &&
 			 gen_aper->ranges[0].base == VGA_FB_PHYS)) {
 
-			printk(KERN_ERR "fb: conflicting fb hw usage "
+			printk(KERN_INFO "fb: conflicting fb hw usage "
 			       "%s vs %s - removing generic driver\n",
 			       name, registered_fb[i]->fix.id);
 			unregister_framebuffer(registered_fb[i]);
diff --git a/drivers/video/fbsysfs.c b/drivers/video/fbsysfs.c
index f4a3277..04251ce 100644
--- a/drivers/video/fbsysfs.c
+++ b/drivers/video/fbsysfs.c
@@ -33,7 +33,7 @@
  * for driver private data (info->par). info->par (if any) will be
  * aligned to sizeof(long).
  *
- * Returns the new structure, or NULL if an error occured.
+ * Returns the new structure, or NULL if an error occurred.
  *
  */
 struct fb_info *framebuffer_alloc(size_t size, struct device *dev)
diff --git a/drivers/video/fm2fb.c b/drivers/video/fm2fb.c
index 1b0feb8..d0533b7 100644
--- a/drivers/video/fm2fb.c
+++ b/drivers/video/fm2fb.c
@@ -45,7 +45,7 @@
  *	buffer needs an amount of memory of 1.769.472 bytes which
  *	is near to 2 MByte (the allocated address space of Zorro2).
  *	The memory is channel interleaved. That means every channel
- *	owns four VRAMs. Unfortunatly most FrameMasters II are
+ *	owns four VRAMs. Unfortunately most FrameMasters II are
  *	not assembled with memory for the alpha channel. In this
  *	case it could be possible to add the frame buffer into the
  *	normal memory pool.
diff --git a/drivers/video/fsl-diu-fb.c b/drivers/video/fsl-diu-fb.c
index 9048f87..bedf5be 100644
--- a/drivers/video/fsl-diu-fb.c
+++ b/drivers/video/fsl-diu-fb.c
@@ -882,7 +882,7 @@ static inline __u32 CNVT_TOHW(__u32 val, __u32 width)
  * which needs to be scaled in this function for the hardware. Things to take
  * into consideration are how many color registers, if any, are supported with
  * the current color visual. With truecolor mode no color palettes are
- * supported. Here a psuedo palette is created which we store the value in
+ * supported. Here a pseudo palette is created which we store the value in
  * pseudo_palette in struct fb_info. For pseudocolor mode we have a limited
  * color palette.
  */
diff --git a/drivers/video/gbefb.c b/drivers/video/gbefb.c
index 933899d..7e7b7a9 100644
--- a/drivers/video/gbefb.c
+++ b/drivers/video/gbefb.c
@@ -721,7 +721,7 @@ static int gbefb_set_par(struct fb_info *info)
 
 	   Tiles have the advantage that they can be allocated individually in
 	   memory. However, this mapping is not linear at all, which is not
-	   really convienient. In order to support linear addressing, the GBE
+	   really convenient. In order to support linear addressing, the GBE
 	   DMA hardware is fooled into thinking the screen is only one tile
 	   large and but has a greater height, so that the DMA transfer covers
 	   the same region.
diff --git a/drivers/video/geode/lxfb.h b/drivers/video/geode/lxfb.h
index be8ccb4..cfcd809 100644
--- a/drivers/video/geode/lxfb.h
+++ b/drivers/video/geode/lxfb.h
@@ -117,7 +117,7 @@ enum gp_registers {
 };
 
 #define GP_BLT_STATUS_CE		(1 << 4)	/* cmd buf empty */
-#define GP_BLT_STATUS_PB		(1 << 0)	/* primative busy */
+#define GP_BLT_STATUS_PB		(1 << 0)	/* primitive busy */
 
 
 /* Display Controller registers (table 6-47 from the data book) */
diff --git a/drivers/video/i810/i810_accel.c b/drivers/video/i810/i810_accel.c
index f5bedee..7672d2e 100644
--- a/drivers/video/i810/i810_accel.c
+++ b/drivers/video/i810/i810_accel.c
@@ -112,7 +112,7 @@ static inline int wait_for_engine_idle(struct fb_info *info)
  * @par: pointer to i810fb_par structure
  *
  * DESCRIPTION:
- * Checks/waits for sufficent space in ringbuffer of size
+ * Checks/waits for sufficient space in ringbuffer of size
  * space.  Returns the tail of the buffer
  */ 
 static inline u32 begin_iring(struct fb_info *info, u32 space)
diff --git a/drivers/video/kyro/STG4000OverlayDevice.c b/drivers/video/kyro/STG4000OverlayDevice.c
index a8c9713..0aeeaa1 100644
--- a/drivers/video/kyro/STG4000OverlayDevice.c
+++ b/drivers/video/kyro/STG4000OverlayDevice.c
@@ -417,7 +417,7 @@ int SetOverlayViewPort(volatile STG4000REG __iomem *pSTGReg,
 	/***************** Horizontal decimation/scaling ***************************/
 
 	/*
-	 * Now we handle the horizontal case, this is a simplified verison of
+	 * Now we handle the horizontal case, this is a simplified version of
 	 * the vertical case in that we decimate by factors of 2.  as we are
 	 * working in words we should always be able to decimate by these
 	 * factors.  as we always have to have a buffer which is aligned to a
diff --git a/drivers/video/kyro/STG4000Reg.h b/drivers/video/kyro/STG4000Reg.h
index 244549e..5d62698 100644
--- a/drivers/video/kyro/STG4000Reg.h
+++ b/drivers/video/kyro/STG4000Reg.h
@@ -16,7 +16,7 @@
 
 /*
  * Macros that access memory mapped card registers in PCI space
- * Add an appropraite section for your OS or processor architecture.
+ * Add an appropriate section for your OS or processor architecture.
  */
 #if defined(__KERNEL__)
 #include <asm/page.h>
diff --git a/drivers/video/matrox/matroxfb_DAC1064.h b/drivers/video/matrox/matroxfb_DAC1064.h
index c6ed780..1e6e45b 100644
--- a/drivers/video/matrox/matroxfb_DAC1064.h
+++ b/drivers/video/matrox/matroxfb_DAC1064.h
@@ -46,7 +46,7 @@ void DAC1064_global_restore(struct matrox_fb_info *minfo);
 #define      M1064_XDVICLKCTRL_DVILOOPCTL       0x30
 	/* CRTC2 pixel clock allowed to(0)/blocked from(1) driving CRTC2 */
 #define      M1064_XDVICLKCTRL_C2DVICLKEN       0x40
-	/* P1PLL loop filter bandwith selection */
+	/* P1PLL loop filter bandwidth selection */
 #define      M1064_XDVICLKCTRL_P1LOOPBWDTCTL    0x80
 #define M1064_XCURCOL0RED	0x08
 #define M1064_XCURCOL0GREEN	0x09
diff --git a/drivers/video/matrox/matroxfb_Ti3026.c b/drivers/video/matrox/matroxfb_Ti3026.c
index 835aaaa..9a44cec 100644
--- a/drivers/video/matrox/matroxfb_Ti3026.c
+++ b/drivers/video/matrox/matroxfb_Ti3026.c
@@ -387,7 +387,7 @@ static int Ti3026_init(struct matrox_fb_info *minfo, struct my_timming *m)
 			hw->DACreg[POS3026_XMISCCTRL] = TVP3026_XMISCCTRL_DAC_PUP | TVP3026_XMISCCTRL_DAC_8BIT | TVP3026_XMISCCTRL_PSEL_DIS | TVP3026_XMISCCTRL_PSEL_LOW;
 			break;
 		case 16:
-			/* XLATCHCTRL should be _4_1 / _2_1... Why is not? (_2_1 is used everytime) */
+			/* XLATCHCTRL should be _4_1 / _2_1... Why is not? (_2_1 is used every time) */
 			hw->DACreg[POS3026_XTRUECOLORCTRL] = (minfo->fbcon.var.green.length == 5) ? (TVP3026_XTRUECOLORCTRL_DIRECTCOLOR | TVP3026_XTRUECOLORCTRL_ORGB_1555) : (TVP3026_XTRUECOLORCTRL_DIRECTCOLOR | TVP3026_XTRUECOLORCTRL_RGB_565);
 			hw->DACreg[POS3026_XMUXCTRL] = muxctrl | TVP3026_XMUXCTRL_PIXEL_16BIT;
 			hw->DACreg[POS3026_XCLKCTRL] = TVP3026_XCLKCTRL_SRC_PLL | TVP3026_XCLKCTRL_DIV2;
@@ -399,7 +399,7 @@ static int Ti3026_init(struct matrox_fb_info *minfo, struct my_timming *m)
 			hw->DACreg[POS3026_XCLKCTRL] = TVP3026_XCLKCTRL_SRC_PLL | TVP3026_XCLKCTRL_DIV4;
 			break;
 		case 32:
-			/* XLATCHCTRL should be _2_1 / _1_1... Why is not? (_2_1 is used everytime) */
+			/* XLATCHCTRL should be _2_1 / _1_1... Why is not? (_2_1 is used every time) */
 			hw->DACreg[POS3026_XMUXCTRL] = muxctrl | TVP3026_XMUXCTRL_PIXEL_32BIT;
 			break;
 		default:
diff --git a/drivers/video/matrox/matroxfb_base.c b/drivers/video/matrox/matroxfb_base.c
index 5ce6fa6..44bf8d4 100644
--- a/drivers/video/matrox/matroxfb_base.c
+++ b/drivers/video/matrox/matroxfb_base.c
@@ -621,7 +621,7 @@ static int matroxfb_decode_var(const struct matrox_fb_info *minfo,
 		var->yoffset = var->yres_virtual - var->yres;
 
 	if (bpp == 16 && var->green.length == 5) {
-		bpp--; /* an artifical value - 15 */
+		bpp--; /* an artificial value - 15 */
 	}
 
 	for (rgbt = table; rgbt->bpp < bpp; rgbt++);
diff --git a/drivers/video/matrox/matroxfb_base.h b/drivers/video/matrox/matroxfb_base.h
index f96a471..11ed57b 100644
--- a/drivers/video/matrox/matroxfb_base.h
+++ b/drivers/video/matrox/matroxfb_base.h
@@ -12,7 +12,7 @@
 #undef MATROXFB_DEBUG
 
 /* heavy debugging: */
-/* -- logs putc[s], so everytime a char is displayed, it's logged */
+/* -- logs putc[s], so every time a char is displayed, it's logged */
 #undef MATROXFB_DEBUG_HEAVY
 
 /* This one _could_ cause infinite loops */
diff --git a/drivers/video/nuc900fb.h b/drivers/video/nuc900fb.h
index 6c23aa3..bc7c930 100644
--- a/drivers/video/nuc900fb.h
+++ b/drivers/video/nuc900fb.h
@@ -8,7 +8,7 @@
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
  *
- *   Auther:
+ *   Author:
  *        Wang Qiang(rurality.linux@gmail.com)  2009/12/16
  */
 
diff --git a/drivers/video/omap/Kconfig b/drivers/video/omap/Kconfig
index 15e7f19..196fa2e 100644
--- a/drivers/video/omap/Kconfig
+++ b/drivers/video/omap/Kconfig
@@ -64,7 +64,7 @@ config FB_OMAP_MANUAL_UPDATE
 	depends on FB_OMAP && FB_OMAP_LCDC_EXTERNAL
 	help
 	  Say Y here, if your user-space applications are capable of
-	  notifying the frame buffer driver when a change has occured in
+	  notifying the frame buffer driver when a change has occurred in
 	  the frame buffer content and thus a reload of the image data to
 	  the external frame buffer is required. If unsure, say N.
 
diff --git a/drivers/video/omap2/dss/hdmi.c b/drivers/video/omap2/dss/hdmi.c
index 0d44f07..a981def 100644
--- a/drivers/video/omap2/dss/hdmi.c
+++ b/drivers/video/omap2/dss/hdmi.c
@@ -587,7 +587,7 @@ static void get_edid_timing_data(u8 *edid)
 	struct hdmi_cm cm;
 	struct omap_video_timings edid_timings;
 
-	/* seach block 0, there are 4 DTDs arranged in priority order */
+	/* search block 0, there are 4 DTDs arranged in priority order */
 	for (count = 0; count < EDID_SIZE_BLOCK0_TIMING_DESCRIPTOR; count++) {
 		current_descriptor_addrs =
 			EDID_DESCRIPTOR_BLOCK0_ADDRESS +
diff --git a/drivers/video/pxa3xx-gcu.c b/drivers/video/pxa3xx-gcu.c
index cf4beb9..0283c70 100644
--- a/drivers/video/pxa3xx-gcu.c
+++ b/drivers/video/pxa3xx-gcu.c
@@ -25,7 +25,7 @@
 
 /*
  * WARNING: This controller is attached to System Bus 2 of the PXA which
- * needs its arbiter to be enabled explictly (CKENB & 1<<9).
+ * needs its arbiter to be enabled explicitly (CKENB & 1<<9).
  * There is currently no way to do this from Linux, so you need to teach
  * your bootloader for now.
  */
diff --git a/drivers/video/s3c-fb.c b/drivers/video/s3c-fb.c
index 6817d18..3b6cdca 100644
--- a/drivers/video/s3c-fb.c
+++ b/drivers/video/s3c-fb.c
@@ -48,7 +48,7 @@
 #undef writel
 #define writel(v, r) do { \
 	printk(KERN_DEBUG "%s: %08x => %p\n", __func__, (unsigned int)v, r); \
-	__raw_writel(v, r); } while(0)
+	__raw_writel(v, r); } while (0)
 #endif /* FB_S3C_DEBUG_REGWRITE */
 
 /* irq_flags bits */
@@ -518,7 +518,7 @@ static int s3c_fb_set_par(struct fb_info *info)
 
 		data = VIDTCON2_LINEVAL(var->yres - 1) |
 		       VIDTCON2_HOZVAL(var->xres - 1);
-		writel(data, regs +sfb->variant.vidtcon + 8 );
+		writel(data, regs + sfb->variant.vidtcon + 8);
 	}
 
 	/* write the buffer address */
@@ -1304,6 +1304,7 @@ static void s3c_fb_clear_win(struct s3c_fb *sfb, int win)
 
 static int __devinit s3c_fb_probe(struct platform_device *pdev)
 {
+	const struct platform_device_id *platid;
 	struct s3c_fb_driverdata *fbdrv;
 	struct device *dev = &pdev->dev;
 	struct s3c_fb_platdata *pd;
@@ -1312,7 +1313,8 @@ static int __devinit s3c_fb_probe(struct platform_device *pdev)
 	int win;
 	int ret = 0;
 
-	fbdrv = (struct s3c_fb_driverdata *)platform_get_device_id(pdev)->driver_data;
+	platid = platform_get_device_id(pdev);
+	fbdrv = (struct s3c_fb_driverdata *)platid->driver_data;
 
 	if (fbdrv->variant.nr_windows > S3C_FB_MAX_WIN) {
 		dev_err(dev, "too many windows, cannot attach\n");
diff --git a/drivers/video/s3fb.c b/drivers/video/s3fb.c
index ddedad9..c4482f2 100644
--- a/drivers/video/s3fb.c
+++ b/drivers/video/s3fb.c
@@ -71,9 +71,9 @@ static const int s3_memsizes[] = {4096, 0, 3072, 8192, 2048, 6144, 1024, 512};
 
 static const char * const s3_names[] = {"S3 Unknown", "S3 Trio32", "S3 Trio64", "S3 Trio64V+",
 			"S3 Trio64UV+", "S3 Trio64V2/DX", "S3 Trio64V2/GX",
-			"S3 Plato/PX", "S3 Aurora64VP", "S3 Virge",
+			"S3 Plato/PX", "S3 Aurora64V+", "S3 Virge",
 			"S3 Virge/VX", "S3 Virge/DX", "S3 Virge/GX",
-			"S3 Virge/GX2", "S3 Virge/GX2P", "S3 Virge/GX2P",
+			"S3 Virge/GX2", "S3 Virge/GX2+", "",
 			"S3 Trio3D/1X", "S3 Trio3D/2X", "S3 Trio3D/2X",
 			"S3 Trio3D"};
 
@@ -90,9 +90,8 @@ static const char * const s3_names[] = {"S3 Unknown", "S3 Trio32", "S3 Trio64",
 #define CHIP_988_VIRGE_VX	0x0A
 #define CHIP_375_VIRGE_DX	0x0B
 #define CHIP_385_VIRGE_GX	0x0C
-#define CHIP_356_VIRGE_GX2	0x0D
-#define CHIP_357_VIRGE_GX2P	0x0E
-#define CHIP_359_VIRGE_GX2P	0x0F
+#define CHIP_357_VIRGE_GX2	0x0D
+#define CHIP_359_VIRGE_GX2P	0x0E
 #define CHIP_360_TRIO3D_1X	0x10
 #define CHIP_362_TRIO3D_2X	0x11
 #define CHIP_368_TRIO3D_2X	0x12
@@ -359,7 +358,9 @@ static void s3_set_pixclock(struct fb_info *info, u32 pixclock)
 	vga_w(par->state.vgabase, VGA_MIS_W, regval | VGA_MIS_ENB_PLL_LOAD);
 
 	/* Set S3 clock registers */
-	if (par->chip == CHIP_360_TRIO3D_1X ||
+	if (par->chip == CHIP_357_VIRGE_GX2 ||
+	    par->chip == CHIP_359_VIRGE_GX2P ||
+	    par->chip == CHIP_360_TRIO3D_1X ||
 	    par->chip == CHIP_362_TRIO3D_2X ||
 	    par->chip == CHIP_368_TRIO3D_2X) {
 		vga_wseq(par->state.vgabase, 0x12, (n - 2) | ((r & 3) << 6));	/* n and two bits of r */
@@ -560,7 +561,9 @@ static int s3fb_set_par(struct fb_info *info)
 	pr_debug("fb%d: offset register       : %d\n", info->node, offset_value);
 	svga_wcrt_multi(par->state.vgabase, s3_offset_regs, offset_value);
 
-	if (par->chip != CHIP_360_TRIO3D_1X &&
+	if (par->chip != CHIP_357_VIRGE_GX2 &&
+	    par->chip != CHIP_359_VIRGE_GX2P &&
+	    par->chip != CHIP_360_TRIO3D_1X &&
 	    par->chip != CHIP_362_TRIO3D_2X &&
 	    par->chip != CHIP_368_TRIO3D_2X) {
 		vga_wcrt(par->state.vgabase, 0x54, 0x18); /* M parameter */
@@ -604,7 +607,9 @@ static int s3fb_set_par(struct fb_info *info)
 		vga_wcrt(par->state.vgabase, 0x66, 0x90);
 	}
 
-	if (par->chip == CHIP_360_TRIO3D_1X ||
+	if (par->chip == CHIP_357_VIRGE_GX2 ||
+	    par->chip == CHIP_359_VIRGE_GX2P ||
+	    par->chip == CHIP_360_TRIO3D_1X ||
 	    par->chip == CHIP_362_TRIO3D_2X ||
 	    par->chip == CHIP_368_TRIO3D_2X ||
 	    par->chip == CHIP_365_TRIO3D    ||
@@ -617,8 +622,7 @@ static int s3fb_set_par(struct fb_info *info)
 		vga_wcrt(par->state.vgabase, 0x66, 0x81);
 	}
 
-	if (par->chip == CHIP_356_VIRGE_GX2  ||
-	    par->chip == CHIP_357_VIRGE_GX2P ||
+	if (par->chip == CHIP_357_VIRGE_GX2  ||
 	    par->chip == CHIP_359_VIRGE_GX2P ||
 	    par->chip == CHIP_360_TRIO3D_1X ||
 	    par->chip == CHIP_362_TRIO3D_2X ||
@@ -674,6 +678,8 @@ static int s3fb_set_par(struct fb_info *info)
 		pr_debug("fb%d: 8 bit pseudocolor\n", info->node);
 		svga_wcrt_mask(par->state.vgabase, 0x50, 0x00, 0x30);
 		if (info->var.pixclock > 20000 ||
+		    par->chip == CHIP_357_VIRGE_GX2 ||
+		    par->chip == CHIP_359_VIRGE_GX2P ||
 		    par->chip == CHIP_360_TRIO3D_1X ||
 		    par->chip == CHIP_362_TRIO3D_2X ||
 		    par->chip == CHIP_368_TRIO3D_2X)
@@ -702,7 +708,9 @@ static int s3fb_set_par(struct fb_info *info)
 		} else {
 			svga_wcrt_mask(par->state.vgabase, 0x50, 0x10, 0x30);
 			svga_wcrt_mask(par->state.vgabase, 0x67, 0x30, 0xF0);
-			if (par->chip != CHIP_360_TRIO3D_1X &&
+			if (par->chip != CHIP_357_VIRGE_GX2 &&
+			    par->chip != CHIP_359_VIRGE_GX2P &&
+			    par->chip != CHIP_360_TRIO3D_1X &&
 			    par->chip != CHIP_362_TRIO3D_2X &&
 			    par->chip != CHIP_368_TRIO3D_2X)
 				hmul = 2;
@@ -727,7 +735,9 @@ static int s3fb_set_par(struct fb_info *info)
 		} else {
 			svga_wcrt_mask(par->state.vgabase, 0x50, 0x10, 0x30);
 			svga_wcrt_mask(par->state.vgabase, 0x67, 0x50, 0xF0);
-			if (par->chip != CHIP_360_TRIO3D_1X &&
+			if (par->chip != CHIP_357_VIRGE_GX2 &&
+			    par->chip != CHIP_359_VIRGE_GX2P &&
+			    par->chip != CHIP_360_TRIO3D_1X &&
 			    par->chip != CHIP_362_TRIO3D_2X &&
 			    par->chip != CHIP_368_TRIO3D_2X)
 				hmul = 2;
@@ -1069,6 +1079,16 @@ static int __devinit s3_pci_probe(struct pci_dev *dev, const struct pci_device_i
 			info->screen_size = 2 << 20;
 			break;
 		}
+	} else if (par->chip == CHIP_357_VIRGE_GX2 ||
+		   par->chip == CHIP_359_VIRGE_GX2P) {
+		switch ((regval & 0xC0) >> 6) {
+		case 1: /* 4MB */
+			info->screen_size = 4 << 20;
+			break;
+		case 3: /* 2MB */
+			info->screen_size = 2 << 20;
+			break;
+		}
 	} else
 		info->screen_size = s3_memsizes[regval >> 5] << 10;
 	info->fix.smem_len = info->screen_size;
@@ -1268,8 +1288,8 @@ static struct pci_device_id s3_devices[] __devinitdata = {
 	{PCI_DEVICE(PCI_VENDOR_ID_S3, 0x5631), .driver_data = CHIP_325_VIRGE},
 	{PCI_DEVICE(PCI_VENDOR_ID_S3, 0x883D), .driver_data = CHIP_988_VIRGE_VX},
 	{PCI_DEVICE(PCI_VENDOR_ID_S3, 0x8A01), .driver_data = CHIP_XXX_VIRGE_DXGX},
-	{PCI_DEVICE(PCI_VENDOR_ID_S3, 0x8A10), .driver_data = CHIP_356_VIRGE_GX2},
-	{PCI_DEVICE(PCI_VENDOR_ID_S3, 0x8A11), .driver_data = CHIP_357_VIRGE_GX2P},
+	{PCI_DEVICE(PCI_VENDOR_ID_S3, 0x8A10), .driver_data = CHIP_357_VIRGE_GX2},
+	{PCI_DEVICE(PCI_VENDOR_ID_S3, 0x8A11), .driver_data = CHIP_359_VIRGE_GX2P},
 	{PCI_DEVICE(PCI_VENDOR_ID_S3, 0x8A12), .driver_data = CHIP_359_VIRGE_GX2P},
 	{PCI_DEVICE(PCI_VENDOR_ID_S3, 0x8A13), .driver_data = CHIP_36X_TRIO3D_1X_2X},
 	{PCI_DEVICE(PCI_VENDOR_ID_S3, 0x8904), .driver_data = CHIP_365_TRIO3D},
diff --git a/drivers/video/savage/savagefb-i2c.c b/drivers/video/savage/savagefb-i2c.c
index b16e613..bb71fea 100644
--- a/drivers/video/savage/savagefb-i2c.c
+++ b/drivers/video/savage/savagefb-i2c.c
@@ -159,8 +159,7 @@ static int savage_setup_i2c_bus(struct savagefb_i2c_chan *chan,
 		else
 			dev_warn(&chan->par->pcidev->dev,
 				 "Failed to register I2C bus %s.\n", name);
-	} else
-		chan->par = NULL;
+	}
 
 	return rc;
 }
@@ -170,9 +169,8 @@ void savagefb_create_i2c_busses(struct fb_info *info)
 	struct savagefb_par *par = info->par;
 	par->chan.par	= par;
 
-	switch(info->fix.accel) {
-	case FB_ACCEL_PROSAVAGE_DDRK:
-	case FB_ACCEL_PROSAVAGE_PM:
+	switch (par->chip) {
+	case S3_PROSAVAGE:
 		par->chan.reg         = CR_SERIAL2;
 		par->chan.ioaddr      = par->mmio.vbase;
 		par->chan.algo.setsda = prosavage_gpio_setsda;
@@ -180,7 +178,7 @@ void savagefb_create_i2c_busses(struct fb_info *info)
 		par->chan.algo.getsda = prosavage_gpio_getsda;
 		par->chan.algo.getscl = prosavage_gpio_getscl;
 		break;
-	case FB_ACCEL_SAVAGE4:
+	case S3_SAVAGE4:
 		par->chan.reg = CR_SERIAL1;
 		if (par->pcidev->revision > 1 && !(VGArCR(0xa6, par) & 0x40))
 			par->chan.reg = CR_SERIAL2;
@@ -190,8 +188,8 @@ void savagefb_create_i2c_busses(struct fb_info *info)
 		par->chan.algo.getsda = prosavage_gpio_getsda;
 		par->chan.algo.getscl = prosavage_gpio_getscl;
 		break;
-	case FB_ACCEL_SAVAGE2000:
-		par->chan.reg         = 0xff20;
+	case S3_SAVAGE2000:
+		par->chan.reg         = MM_SERIAL1;
 		par->chan.ioaddr      = par->mmio.vbase;
 		par->chan.algo.setsda = savage4_gpio_setsda;
 		par->chan.algo.setscl = savage4_gpio_setscl;
diff --git a/drivers/video/savage/savagefb.h b/drivers/video/savage/savagefb.h
index e4c3f21..4e9490c 100644
--- a/drivers/video/savage/savagefb.h
+++ b/drivers/video/savage/savagefb.h
@@ -153,7 +153,7 @@ struct savage_reg {
 	unsigned char CRTC[25];       /* Crtc Controller */
 	unsigned char Sequencer[5];   /* Video Sequencer */
 	unsigned char Graphics[9];    /* Video Graphics */
-	unsigned char Attribute[21];  /* Video Atribute */
+	unsigned char Attribute[21];  /* Video Attribute */
 
 	unsigned int mode, refresh;
 	unsigned char SR08, SR0E, SR0F;
diff --git a/drivers/video/savage/savagefb_driver.c b/drivers/video/savage/savagefb_driver.c
index 487911e..a2dc1a7 100644
--- a/drivers/video/savage/savagefb_driver.c
+++ b/drivers/video/savage/savagefb_driver.c
@@ -385,7 +385,7 @@ SavageSetup2DEngine(struct savagefb_par  *par)
 	BCI_SEND(GlobalBitmapDescriptor);
 
 	/*
-	 * I don't know why, sending this twice fixes the intial black screen,
+	 * I don't know why, sending this twice fixes the initial black screen,
 	 * prevents X from crashing at least in Toshiba laptops with SavageIX.
 	 * --Tony
 	 */
@@ -2211,7 +2211,7 @@ static int __devinit savagefb_probe(struct pci_dev* dev,
 		goto failed_mmio;
 
 	video_len = savage_init_hw(par);
-	/* FIXME: cant be negative */
+	/* FIXME: can't be negative */
 	if (video_len < 0) {
 		err = video_len;
 		goto failed_mmio;
diff --git a/drivers/video/sh_mobile_lcdcfb.c b/drivers/video/sh_mobile_lcdcfb.c
index 757665b..9bcc61b 100644
--- a/drivers/video/sh_mobile_lcdcfb.c
+++ b/drivers/video/sh_mobile_lcdcfb.c
@@ -643,7 +643,7 @@ static int sh_mobile_lcdc_start(struct sh_mobile_lcdc_priv *priv)
 			continue;
 
 		board_cfg = &ch->cfg.board_cfg;
-		if (try_module_get(board_cfg->owner) && board_cfg->display_on) {
+		if (board_cfg->display_on && try_module_get(board_cfg->owner)) {
 			board_cfg->display_on(board_cfg->board_data, ch->info);
 			module_put(board_cfg->owner);
 		}
@@ -688,7 +688,7 @@ static void sh_mobile_lcdc_stop(struct sh_mobile_lcdc_priv *priv)
 		}
 
 		board_cfg = &ch->cfg.board_cfg;
-		if (try_module_get(board_cfg->owner) && board_cfg->display_off) {
+		if (board_cfg->display_off && try_module_get(board_cfg->owner)) {
 			board_cfg->display_off(board_cfg->board_data);
 			module_put(board_cfg->owner);
 		}
@@ -1032,6 +1032,49 @@ static int sh_mobile_check_var(struct fb_var_screeninfo *var, struct fb_info *in
 	return 0;
 }
 
+/*
+ * Screen blanking. Behavior is as follows:
+ * FB_BLANK_UNBLANK: screen unblanked, clocks enabled
+ * FB_BLANK_NORMAL: screen blanked, clocks enabled
+ * FB_BLANK_VSYNC,
+ * FB_BLANK_HSYNC,
+ * FB_BLANK_POWEROFF: screen blanked, clocks disabled
+ */
+static int sh_mobile_lcdc_blank(int blank, struct fb_info *info)
+{
+	struct sh_mobile_lcdc_chan *ch = info->par;
+	struct sh_mobile_lcdc_priv *p = ch->lcdc;
+
+	/* blank the screen? */
+	if (blank > FB_BLANK_UNBLANK && ch->blank_status == FB_BLANK_UNBLANK) {
+		struct fb_fillrect rect = {
+			.width = info->var.xres,
+			.height = info->var.yres,
+		};
+		sh_mobile_lcdc_fillrect(info, &rect);
+	}
+	/* turn clocks on? */
+	if (blank <= FB_BLANK_NORMAL && ch->blank_status > FB_BLANK_NORMAL) {
+		sh_mobile_lcdc_clk_on(p);
+	}
+	/* turn clocks off? */
+	if (blank > FB_BLANK_NORMAL && ch->blank_status <= FB_BLANK_NORMAL) {
+		/* make sure the screen is updated with the black fill before
+		 * switching the clocks off. one vsync is not enough since
+		 * blanking may occur in the middle of a refresh. deferred io
+		 * mode will reenable the clocks and update the screen in time,
+		 * so it does not need this. */
+		if (!info->fbdefio) {
+			sh_mobile_wait_for_vsync(info);
+			sh_mobile_wait_for_vsync(info);
+		}
+		sh_mobile_lcdc_clk_off(p);
+	}
+
+	ch->blank_status = blank;
+	return 0;
+}
+
 static struct fb_ops sh_mobile_lcdc_ops = {
 	.owner          = THIS_MODULE,
 	.fb_setcolreg	= sh_mobile_lcdc_setcolreg,
@@ -1040,6 +1083,7 @@ static struct fb_ops sh_mobile_lcdc_ops = {
 	.fb_fillrect	= sh_mobile_lcdc_fillrect,
 	.fb_copyarea	= sh_mobile_lcdc_copyarea,
 	.fb_imageblit	= sh_mobile_lcdc_imageblit,
+	.fb_blank	= sh_mobile_lcdc_blank,
 	.fb_pan_display = sh_mobile_fb_pan_display,
 	.fb_ioctl       = sh_mobile_ioctl,
 	.fb_open	= sh_mobile_open,
@@ -1254,7 +1298,7 @@ static int sh_mobile_lcdc_notify(struct notifier_block *nb,
 
 	switch(action) {
 	case FB_EVENT_SUSPEND:
-		if (try_module_get(board_cfg->owner) && board_cfg->display_off) {
+		if (board_cfg->display_off && try_module_get(board_cfg->owner)) {
 			board_cfg->display_off(board_cfg->board_data);
 			module_put(board_cfg->owner);
 		}
@@ -1267,7 +1311,7 @@ static int sh_mobile_lcdc_notify(struct notifier_block *nb,
 		mutex_unlock(&ch->open_lock);
 
 		/* HDMI must be enabled before LCDC configuration */
-		if (try_module_get(board_cfg->owner) && board_cfg->display_on) {
+		if (board_cfg->display_on && try_module_get(board_cfg->owner)) {
 			board_cfg->display_on(board_cfg->board_data, info);
 			module_put(board_cfg->owner);
 		}
diff --git a/drivers/video/sh_mobile_lcdcfb.h b/drivers/video/sh_mobile_lcdcfb.h
index 4635eed..f16cb56 100644
--- a/drivers/video/sh_mobile_lcdcfb.h
+++ b/drivers/video/sh_mobile_lcdcfb.h
@@ -37,6 +37,7 @@ struct sh_mobile_lcdc_chan {
 	struct completion vsync_completion;
 	struct fb_var_screeninfo display_var;
 	int use_count;
+	int blank_status;
 	struct mutex open_lock;		/* protects the use counter */
 };
 
diff --git a/drivers/video/sm501fb.c b/drivers/video/sm501fb.c
index 46d1a64..56ef6b3 100644
--- a/drivers/video/sm501fb.c
+++ b/drivers/video/sm501fb.c
@@ -265,7 +265,7 @@ static unsigned long sm501fb_ps_to_hz(unsigned long psvalue)
 	return (unsigned long)numerator;
 }
 
-/* sm501fb_hz_to_ps is identical to the oposite transform */
+/* sm501fb_hz_to_ps is identical to the opposite transform */
 
 #define sm501fb_hz_to_ps(x) sm501fb_ps_to_hz(x)
 
@@ -1719,7 +1719,7 @@ static int sm501fb_init_fb(struct fb_info *fb,
 	       (head == HEAD_CRT) ? &sm501fb_ops_crt : &sm501fb_ops_pnl,
 	       sizeof(struct fb_ops));
 
-	/* update ops dependant on what we've been passed */
+	/* update ops dependent on what we've been passed */
 
 	if ((pd->flags & SM501FB_FLAG_USE_HWCURSOR) == 0)
 		par->ops.fb_cursor = NULL;
diff --git a/drivers/video/sstfb.c b/drivers/video/sstfb.c
index 2ab7041..2301c27 100644
--- a/drivers/video/sstfb.c
+++ b/drivers/video/sstfb.c
@@ -221,7 +221,7 @@ static int __sst_wait_idle(u8 __iomem *vbase)
 	while(1) {
 		if (__sst_read(vbase, STATUS) & STATUS_FBI_BUSY) {
 			f_dddprintk("status: busy\n");
-/* FIXME basicaly, this is a busy wait. maybe not that good. oh well;
+/* FIXME basically, this is a busy wait. maybe not that good. oh well;
  * this is a small loop after all.
  * Or maybe we should use mdelay() or udelay() here instead ? */
 			count = 0;
@@ -501,7 +501,7 @@ static int sstfb_set_par(struct fb_info *info)
 	}
 
 	if (IS_VOODOO2(par)) {
-		/* voodoo2 has 32 pixel wide tiles , BUT stange things
+		/* voodoo2 has 32 pixel wide tiles , BUT strange things
 		   happen with odd number of tiles */
 		par->tiles_in_X = (info->var.xres + 63 ) / 64 * 2;
 	} else {
@@ -920,11 +920,11 @@ static int __devinit sst_detect_ti(struct fb_info *info)
  * we get the 1st byte (M value) of preset f1,f7 and fB
  * why those 3 ? mmmh... for now, i'll do it the glide way...
  * and ask questions later. anyway, it seems that all the freq registers are
- * realy at their default state (cf specs) so i ask again, why those 3 regs ?
+ * really at their default state (cf specs) so i ask again, why those 3 regs ?
  * mmmmh.. it seems that's much more ugly than i thought. we use f0 and fA for
  * pll programming, so in fact, we *hope* that the f1, f7 & fB won't be
  * touched...
- * is it realy safe ? how can i reset this ramdac ? geee...
+ * is it really safe ? how can i reset this ramdac ? geee...
  */
 static int __devinit sst_detect_ics(struct fb_info *info)
 {
diff --git a/drivers/video/sticore.h b/drivers/video/sticore.h
index 7fe5be4..addf7b6 100644
--- a/drivers/video/sticore.h
+++ b/drivers/video/sticore.h
@@ -79,7 +79,7 @@ struct sti_glob_cfg_ext {
 	 u8 curr_mon;			/* current monitor configured */
 	 u8 friendly_boot;		/* in friendly boot mode */
 	s16 power;			/* power calculation (in Watts) */
-	s32 freq_ref;			/* frequency refrence */
+	s32 freq_ref;			/* frequency reference */
 	u32 sti_mem_addr;		/* pointer to global sti memory (size=sti_mem_request) */
 	u32 future_ptr; 		/* pointer to future data */
 };
diff --git a/drivers/video/tdfxfb.c b/drivers/video/tdfxfb.c
index 3ee5e63..a99b994 100644
--- a/drivers/video/tdfxfb.c
+++ b/drivers/video/tdfxfb.c
@@ -877,12 +877,12 @@ static void tdfxfb_fillrect(struct fb_info *info,
 	else
 		tdfx_rop = TDFX_ROP_XOR;
 
-	/* asume always rect->height < 4096 */
+	/* assume always rect->height < 4096 */
 	if (dy + rect->height > 4095) {
 		dstbase = stride * dy;
 		dy = 0;
 	}
-	/* asume always rect->width < 4096 */
+	/* assume always rect->width < 4096 */
 	if (dx + rect->width > 4095) {
 		dstbase += dx * bpp >> 3;
 		dx = 0;
@@ -915,22 +915,22 @@ static void tdfxfb_copyarea(struct fb_info *info,
 	u32 dstbase = 0;
 	u32 srcbase = 0;
 
-	/* asume always area->height < 4096 */
+	/* assume always area->height < 4096 */
 	if (sy + area->height > 4095) {
 		srcbase = stride * sy;
 		sy = 0;
 	}
-	/* asume always area->width < 4096 */
+	/* assume always area->width < 4096 */
 	if (sx + area->width > 4095) {
 		srcbase += sx * bpp >> 3;
 		sx = 0;
 	}
-	/* asume always area->height < 4096 */
+	/* assume always area->height < 4096 */
 	if (dy + area->height > 4095) {
 		dstbase = stride * dy;
 		dy = 0;
 	}
-	/* asume always area->width < 4096 */
+	/* assume always area->width < 4096 */
 	if (dx + area->width > 4095) {
 		dstbase += dx * bpp >> 3;
 		dx = 0;
@@ -1003,12 +1003,12 @@ static void tdfxfb_imageblit(struct fb_info *info, const struct fb_image *image)
 #else
 	srcfmt = 0x400000;
 #endif
-	/* asume always image->height < 4096 */
+	/* assume always image->height < 4096 */
 	if (dy + image->height > 4095) {
 		dstbase = stride * dy;
 		dy = 0;
 	}
-	/* asume always image->width < 4096 */
+	/* assume always image->width < 4096 */
 	if (dx + image->width > 4095) {
 		dstbase += dx * bpp >> 3;
 		dx = 0;
@@ -1124,7 +1124,7 @@ static int tdfxfb_cursor(struct fb_info *info, struct fb_cursor *cursor)
 		 * lower half (least significant 64 bits) of a 128 bit word
 		 * and pattern 1 the upper half. If you examine the data of
 		 * the cursor image the graphics card uses then from the
-		 * begining you see line one of pattern 0, line one of
+		 * beginning you see line one of pattern 0, line one of
 		 * pattern 1, line two of pattern 0, line two of pattern 1,
 		 * etc etc. The linear stride for the cursor is always 16 bytes
 		 * (128 bits) which is the maximum cursor width times two for
diff --git a/drivers/video/tmiofb.c b/drivers/video/tmiofb.c
index 9710bf8..0c341d7 100644
--- a/drivers/video/tmiofb.c
+++ b/drivers/video/tmiofb.c
@@ -359,7 +359,7 @@ tmiofb_acc_wait(struct fb_info *info, unsigned int ccs)
 {
 	struct tmiofb_par *par = info->par;
 	/*
-	 * This code can be called whith interrupts disabled.
+	 * This code can be called with interrupts disabled.
 	 * So instead of relaying on irq to trigger the event,
 	 * poll the state till the necessary command is executed.
 	 */
diff --git a/drivers/video/udlfb.c b/drivers/video/udlfb.c
index 2c8364e..68041d9 100644
--- a/drivers/video/udlfb.c
+++ b/drivers/video/udlfb.c
@@ -769,7 +769,7 @@ static int dlfb_ops_ioctl(struct fb_info *info, unsigned int cmd,
 
 		/*
 		 * If we have a damage-aware client, turn fb_defio "off"
-		 * To avoid perf imact of unecessary page fault handling.
+		 * To avoid perf imact of unnecessary page fault handling.
 		 * Done by resetting the delay for this fb_info to a very
 		 * long period. Pages will become writable and stay that way.
 		 * Reset to normal value when all clients have closed this fb.
diff --git a/drivers/video/vga16fb.c b/drivers/video/vga16fb.c
index 28ccab4..53b2c5a 100644
--- a/drivers/video/vga16fb.c
+++ b/drivers/video/vga16fb.c
@@ -152,7 +152,7 @@ static inline int setop(int op)
 }
 
 /* Set the Enable Set/Reset Register and return its old value.  
-   The code here always uses value 0xf for thsi register. */
+   The code here always uses value 0xf for this register. */
 static inline int setsr(int sr)
 {
 	int oldsr;
diff --git a/drivers/video/via/chip.h b/drivers/video/via/chip.h
index 781f3aa..29d7024 100644
--- a/drivers/video/via/chip.h
+++ b/drivers/video/via/chip.h
@@ -139,7 +139,6 @@ struct chip_information {
 
 struct crt_setting_information {
 	int iga_path;
-	int refresh_rate;
 };
 
 struct tmds_setting_information {
diff --git a/drivers/video/via/hw.c b/drivers/video/via/hw.c
index 5728fd7..dc4c778 100644
--- a/drivers/video/via/hw.c
+++ b/drivers/video/via/hw.c
@@ -2002,13 +2002,15 @@ void viafb_fill_crtc_timing(struct crt_mode_table *crt_table,
 	int i;
 	int index = 0;
 	int h_addr, v_addr;
-	u32 pll_D_N, clock;
+	u32 pll_D_N, clock, refresh = viafb_refresh;
+
+	if (viafb_SAMM_ON && set_iga == IGA2)
+		refresh = viafb_refresh1;
 
 	for (i = 0; i < video_mode->mode_array; i++) {
 		index = i;
 
-		if (crt_table[i].refresh_rate == viaparinfo->
-			crt_setting_info->refresh_rate)
+		if (crt_table[i].refresh_rate == refresh)
 			break;
 	}
 
@@ -2019,7 +2021,7 @@ void viafb_fill_crtc_timing(struct crt_mode_table *crt_table,
 	if ((viafb_LCD_ON | viafb_DVI_ON)
 	    && video_mode->crtc[0].crtc.hor_addr == 640
 	    && video_mode->crtc[0].crtc.ver_addr == 480
-	    && viaparinfo->crt_setting_info->refresh_rate == 60) {
+	    && refresh == 60) {
 		/* The border is 8 pixels. */
 		crt_reg.hor_blank_start = crt_reg.hor_blank_start - 8;
 
@@ -2070,7 +2072,6 @@ void __devinit viafb_init_chip_info(int chip_type)
 	init_lvds_chip_info();
 
 	viaparinfo->crt_setting_info->iga_path = IGA1;
-	viaparinfo->crt_setting_info->refresh_rate = viafb_refresh;
 
 	/*Set IGA path for each device */
 	viafb_set_iga_path();
@@ -2083,13 +2084,9 @@ void __devinit viafb_init_chip_info(int chip_type)
 		viaparinfo->lvds_setting_info->lcd_mode;
 }
 
-void viafb_update_device_setting(int hres, int vres,
-	int bpp, int vmode_refresh, int flag)
+void viafb_update_device_setting(int hres, int vres, int bpp, int flag)
 {
 	if (flag == 0) {
-		viaparinfo->crt_setting_info->refresh_rate =
-			vmode_refresh;
-
 		viaparinfo->tmds_setting_info->h_active = hres;
 		viaparinfo->tmds_setting_info->v_active = vres;
 
diff --git a/drivers/video/via/hw.h b/drivers/video/via/hw.h
index 7295263..8858593 100644
--- a/drivers/video/via/hw.h
+++ b/drivers/video/via/hw.h
@@ -949,8 +949,7 @@ void __devinit viafb_init_chip_info(int chip_type);
 void __devinit viafb_init_dac(int set_iga);
 int viafb_get_pixclock(int hres, int vres, int vmode_refresh);
 int viafb_get_refresh(int hres, int vres, u32 float_refresh);
-void viafb_update_device_setting(int hres, int vres, int bpp,
-			   int vmode_refresh, int flag);
+void viafb_update_device_setting(int hres, int vres, int bpp, int flag);
 
 void viafb_set_iga_path(void);
 void viafb_set_primary_color_register(u8 index, u8 red, u8 green, u8 blue);
diff --git a/drivers/video/via/via_utility.c b/drivers/video/via/via_utility.c
index d05ccb6..35458a5 100644
--- a/drivers/video/via/via_utility.c
+++ b/drivers/video/via/via_utility.c
@@ -174,7 +174,7 @@ void viafb_set_gamma_table(int bpp, unsigned int *gamma_table)
 	}
 
 	/* If adjust Gamma value in SAMM, fill IGA1,
-	   IGA2 Gamma table simultanous. */
+	   IGA2 Gamma table simultaneous. */
 	/* Switch to IGA2 Gamma Table */
 	if ((active_device_amount > 1) &&
 		!((viaparinfo->chip_info->gfx_chip_name ==
diff --git a/drivers/video/via/via_utility.h b/drivers/video/via/via_utility.h
index 1670ba8..f23be17 100644
--- a/drivers/video/via/via_utility.h
+++ b/drivers/video/via/via_utility.h
@@ -21,7 +21,7 @@
 #ifndef __VIAUTILITY_H__
 #define __VIAUTILITY_H__
 
-/* These functions are used to get infomation about device's state */
+/* These functions are used to get information about device's state */
 void viafb_get_device_support_state(u32 *support_state);
 void viafb_get_device_connect_state(u32 *connect_state);
 bool viafb_lcd_get_support_expand_state(u32 xres, u32 yres);
diff --git a/drivers/video/via/viafbdev.c b/drivers/video/via/viafbdev.c
index f555b89..a542bed 100644
--- a/drivers/video/via/viafbdev.c
+++ b/drivers/video/via/viafbdev.c
@@ -182,13 +182,24 @@ static int viafb_release(struct fb_info *info, int user)
 	return 0;
 }
 
+static inline int get_var_refresh(struct fb_var_screeninfo *var)
+{
+	u32 htotal, vtotal;
+
+	htotal = var->left_margin + var->xres + var->right_margin
+		+ var->hsync_len;
+	vtotal = var->upper_margin + var->yres + var->lower_margin
+		+ var->vsync_len;
+	return PICOS2KHZ(var->pixclock) * 1000 / (htotal * vtotal);
+}
+
 static int viafb_check_var(struct fb_var_screeninfo *var,
 	struct fb_info *info)
 {
-	int htotal, vtotal, depth;
+	int depth, refresh;
 	struct VideoModeTable *vmode_entry;
 	struct viafb_par *ppar = info->par;
-	u32 long_refresh, line;
+	u32 line;
 
 	DEBUG_MSG(KERN_INFO "viafb_check_var!\n");
 	/* Sanity check */
@@ -231,17 +242,11 @@ static int viafb_check_var(struct fb_var_screeninfo *var,
 	/* Based on var passed in to calculate the refresh,
 	 * because our driver use some modes special.
 	 */
-	htotal = var->xres + var->left_margin +
-	var->right_margin + var->hsync_len;
-	vtotal = var->yres + var->upper_margin +
-		var->lower_margin + var->vsync_len;
-	long_refresh = 1000000000UL / var->pixclock * 1000;
-	long_refresh /= (htotal * vtotal);
-
-	viafb_refresh = viafb_get_refresh(var->xres, var->yres, long_refresh);
+	refresh = viafb_get_refresh(var->xres, var->yres,
+		get_var_refresh(var));
 
 	/* Adjust var according to our driver's own table */
-	viafb_fill_var_timing_info(var, viafb_refresh, vmode_entry);
+	viafb_fill_var_timing_info(var, refresh, vmode_entry);
 	if (var->accel_flags & FB_ACCELF_TEXT &&
 		!ppar->shared->vdev->engine_mmio)
 		var->accel_flags = 0;
@@ -253,12 +258,13 @@ static int viafb_set_par(struct fb_info *info)
 {
 	struct viafb_par *viapar = info->par;
 	struct VideoModeTable *vmode_entry, *vmode_entry1 = NULL;
+	int refresh;
 	DEBUG_MSG(KERN_INFO "viafb_set_par!\n");
 
 	viafb_update_fix(info);
 	viapar->depth = fb_get_color_depth(&info->var, &info->fix);
 	viafb_update_device_setting(viafbinfo->var.xres, viafbinfo->var.yres,
-		viafbinfo->var.bits_per_pixel, viafb_refresh, 0);
+		viafbinfo->var.bits_per_pixel, 0);
 
 	vmode_entry = viafb_get_mode(viafbinfo->var.xres, viafbinfo->var.yres);
 	if (viafb_dual_fb) {
@@ -266,7 +272,7 @@ static int viafb_set_par(struct fb_info *info)
 			viafbinfo1->var.yres);
 		viafb_update_device_setting(viafbinfo1->var.xres,
 			viafbinfo1->var.yres, viafbinfo1->var.bits_per_pixel,
-			viafb_refresh1, 1);
+			1);
 	} else if (viafb_SAMM_ON == 1) {
 		DEBUG_MSG(KERN_INFO
 		"viafb_second_xres = %d, viafb_second_yres = %d, bpp = %d\n",
@@ -275,14 +281,19 @@ static int viafb_set_par(struct fb_info *info)
 			viafb_second_yres);
 
 		viafb_update_device_setting(viafb_second_xres,
-			viafb_second_yres, viafb_bpp1, viafb_refresh1, 1);
+			viafb_second_yres, viafb_bpp1, 1);
 	}
 
+	refresh = viafb_get_refresh(info->var.xres, info->var.yres,
+		get_var_refresh(&info->var));
 	if (vmode_entry) {
-		if (viafb_dual_fb && viapar->iga_path == IGA2)
+		if (viafb_dual_fb && viapar->iga_path == IGA2) {
 			viafb_bpp1 = info->var.bits_per_pixel;
-		else
+			viafb_refresh1 = refresh;
+		} else {
 			viafb_bpp = info->var.bits_per_pixel;
+			viafb_refresh = refresh;
+		}
 
 		if (info->var.accel_flags & FB_ACCELF_TEXT)
 			info->flags &= ~FBINFO_HWACCEL_DISABLED;
@@ -1795,14 +1806,9 @@ int __devinit via_fb_pci_probe(struct viafb_dev *vdev)
 	default_var.xres_virtual = default_xres;
 	default_var.yres_virtual = default_yres;
 	default_var.bits_per_pixel = viafb_bpp;
-	default_var.pixclock =
-	    viafb_get_pixclock(default_xres, default_yres, viafb_refresh);
-	default_var.left_margin = (default_xres >> 3) & 0xf8;
-	default_var.right_margin = 32;
-	default_var.upper_margin = 16;
-	default_var.lower_margin = 4;
-	default_var.hsync_len = default_var.left_margin;
-	default_var.vsync_len = 4;
+	viafb_fill_var_timing_info(&default_var, viafb_get_refresh(
+		default_var.xres, default_var.yres, viafb_refresh),
+		viafb_get_mode(default_var.xres, default_var.yres));
 	viafb_setup_fixinfo(&viafbinfo->fix, viaparinfo);
 	viafbinfo->var = default_var;
 
@@ -1841,15 +1847,9 @@ int __devinit via_fb_pci_probe(struct viafb_dev *vdev)
 		default_var.xres_virtual = viafb_second_virtual_xres;
 		default_var.yres_virtual = viafb_second_virtual_yres;
 		default_var.bits_per_pixel = viafb_bpp1;
-		default_var.pixclock =
-		    viafb_get_pixclock(viafb_second_xres, viafb_second_yres,
-		    viafb_refresh);
-		default_var.left_margin = (viafb_second_xres >> 3) & 0xf8;
-		default_var.right_margin = 32;
-		default_var.upper_margin = 16;
-		default_var.lower_margin = 4;
-		default_var.hsync_len = default_var.left_margin;
-		default_var.vsync_len = 4;
+		viafb_fill_var_timing_info(&default_var, viafb_get_refresh(
+			default_var.xres, default_var.yres, viafb_refresh1),
+			viafb_get_mode(default_var.xres, default_var.yres));
 
 		viafb_setup_fixinfo(&viafbinfo1->fix, viaparinfo1);
 		viafb_check_var(&default_var, viafbinfo1);
@@ -2004,22 +2004,24 @@ static int __init viafb_setup(char *options)
  */
 int __init viafb_init(void)
 {
-	u32 dummy;
+	u32 dummy_x, dummy_y;
 #ifndef MODULE
 	char *option = NULL;
 	if (fb_get_options("viafb", &option))
 		return -ENODEV;
 	viafb_setup(option);
 #endif
-	if (parse_mode(viafb_mode, &dummy, &dummy)
-		|| parse_mode(viafb_mode1, &dummy, &dummy)
+	if (parse_mode(viafb_mode, &dummy_x, &dummy_y)
+		|| !viafb_get_mode(dummy_x, dummy_y)
+		|| parse_mode(viafb_mode1, &dummy_x, &dummy_y)
+		|| !viafb_get_mode(dummy_x, dummy_y)
 		|| viafb_bpp < 0 || viafb_bpp > 32
 		|| viafb_bpp1 < 0 || viafb_bpp1 > 32
 		|| parse_active_dev())
 		return -EINVAL;
 
 	printk(KERN_INFO
-       "VIA Graphics Intergration Chipset framebuffer %d.%d initializing\n",
+       "VIA Graphics Integration Chipset framebuffer %d.%d initializing\n",
 	       VERSION_MAJOR, VERSION_MINOR);
 	return 0;
 }
diff --git a/drivers/video/w100fb.c b/drivers/video/w100fb.c
index d8b12c3..c8be8af 100644
--- a/drivers/video/w100fb.c
+++ b/drivers/video/w100fb.c
@@ -1306,7 +1306,7 @@ static void w100_init_lcd(struct w100fb_par *par)
 	union graphic_v_disp_u graphic_v_disp;
 	union crtc_total_u crtc_total;
 
-	/* w3200 doesnt like undefined bits being set so zero register values first */
+	/* w3200 doesn't like undefined bits being set so zero register values first */
 
 	active_h_disp.val = 0;
 	active_h_disp.f.active_h_start=mode->left_margin;
diff --git a/drivers/w1/masters/omap_hdq.c b/drivers/w1/masters/omap_hdq.c
index 38e96ab..5ef385b 100644
--- a/drivers/w1/masters/omap_hdq.c
+++ b/drivers/w1/masters/omap_hdq.c
@@ -545,7 +545,7 @@ static void omap_w1_write_byte(void *_hdq, u8 byte)
 		return;
 	}
 
-	/* Second write, data transfered. Release the module */
+	/* Second write, data transferred. Release the module */
 	if (hdq_data->init_trans > 1) {
 		omap_hdq_put(hdq_data);
 		ret = mutex_lock_interruptible(&hdq_data->hdq_mutex);
diff --git a/drivers/watchdog/Kconfig b/drivers/watchdog/Kconfig
index b69d714..1b0f98b 100644
--- a/drivers/watchdog/Kconfig
+++ b/drivers/watchdog/Kconfig
@@ -933,7 +933,7 @@ config PNX833X_WDT
 	depends on SOC_PNX8335
 	help
 	  Hardware driver for the PNX833x's watchdog. This is a
-	  watchdog timer that will reboot the machine after a programable
+	  watchdog timer that will reboot the machine after a programmable
 	  timer has expired and no process has written to /dev/watchdog during
 	  that time.
 
diff --git a/drivers/watchdog/Makefile b/drivers/watchdog/Makefile
index d520bf9..3f8608b 100644
--- a/drivers/watchdog/Makefile
+++ b/drivers/watchdog/Makefile
@@ -4,7 +4,7 @@
 
 # Only one watchdog can succeed. We probe the ISA/PCI/USB based
 # watchdog-cards first, then the architecture specific watchdog
-# drivers and then the architecture independant "softdog" driver.
+# drivers and then the architecture independent "softdog" driver.
 # This means that if your ISA/PCI/USB card isn't detected that
 # you can fall back to an architecture specific driver and if
 # that also fails then you can fall back to the software watchdog
@@ -153,7 +153,7 @@ obj-$(CONFIG_WATCHDOG_CP1XXX)		+= cpwd.o
 # Xen
 obj-$(CONFIG_XEN_WDT) += xen_wdt.o
 
-# Architecture Independant
+# Architecture Independent
 obj-$(CONFIG_WM831X_WATCHDOG) += wm831x_wdt.o
 obj-$(CONFIG_WM8350_WATCHDOG) += wm8350_wdt.o
 obj-$(CONFIG_MAX63XX_WATCHDOG) += max63xx_wdt.o
diff --git a/drivers/watchdog/acquirewdt.c b/drivers/watchdog/acquirewdt.c
index 2ffce4d..b6a2b58 100644
--- a/drivers/watchdog/acquirewdt.c
+++ b/drivers/watchdog/acquirewdt.c
@@ -26,7 +26,7 @@
  *	Theory of Operation:
  *		The Watch-Dog Timer is provided to ensure that standalone
  *		Systems can always recover from catastrophic conditions that
- *		caused the CPU to crash. This condition may have occured by
+ *		caused the CPU to crash. This condition may have occurred by
  *		external EMI or a software bug. When the CPU stops working
  *		correctly, hardware on the board will either perform a hardware
  *		reset (cold boot) or a non-maskable interrupt (NMI) to bring the
diff --git a/drivers/watchdog/mpc8xxx_wdt.c b/drivers/watchdog/mpc8xxx_wdt.c
index 6709d72..528bceb 100644
--- a/drivers/watchdog/mpc8xxx_wdt.c
+++ b/drivers/watchdog/mpc8xxx_wdt.c
@@ -195,7 +195,7 @@ static int __devinit mpc8xxx_wdt_probe(struct platform_device *ofdev)
 
 	if (!ofdev->dev.of_match)
 		return -EINVAL;
-	wdt_type = match->data;
+	wdt_type = ofdev->dev.of_match->data;
 
 	if (!freq || freq == -1)
 		return -EINVAL;
diff --git a/drivers/watchdog/pc87413_wdt.c b/drivers/watchdog/pc87413_wdt.c
index 139d773..b7c1390 100644
--- a/drivers/watchdog/pc87413_wdt.c
+++ b/drivers/watchdog/pc87413_wdt.c
@@ -49,7 +49,7 @@
 #define WDT_DATA_IO_PORT    (WDT_INDEX_IO_PORT+1)
 #define SWC_LDN             0x04
 #define SIOCFG2             0x22	/* Serial IO register */
-#define WDCTL               0x10	/* Watchdog-Timer-Controll-Register */
+#define WDCTL               0x10	/* Watchdog-Timer-Control-Register */
 #define WDTO                0x11	/* Watchdog timeout register */
 #define WDCFG               0x12	/* Watchdog config register */
 
diff --git a/drivers/watchdog/sbc7240_wdt.c b/drivers/watchdog/sbc7240_wdt.c
index 67ddeb1..ff11504 100644
--- a/drivers/watchdog/sbc7240_wdt.c
+++ b/drivers/watchdog/sbc7240_wdt.c
@@ -273,7 +273,7 @@ static int __init sbc7240_wdt_init(void)
 
 	/* The IO port 0x043 used to disable the watchdog
 	 * is already claimed by the system timer, so we
-	 * cant request_region() it ...*/
+	 * can't request_region() it ...*/
 
 	if (timeout < 1 || timeout > SBC7240_MAX_TIMEOUT) {
 		timeout = SBC7240_TIMEOUT;
diff --git a/drivers/watchdog/sch311x_wdt.c b/drivers/watchdog/sch311x_wdt.c
index b61ab1c..c7cf4b0 100644
--- a/drivers/watchdog/sch311x_wdt.c
+++ b/drivers/watchdog/sch311x_wdt.c
@@ -201,7 +201,7 @@ static void sch311x_wdt_get_status(int *status)
 	spin_lock(&sch311x_wdt_data.io_lock);
 
 	/* -- Watchdog timer control --
-	 * Bit 0   Status Bit: 0 = Timer counting, 1 = Timeout occured
+	 * Bit 0   Status Bit: 0 = Timer counting, 1 = Timeout occurred
 	 * Bit 1   Reserved
 	 * Bit 2   Force Timeout: 1 = Forces WD timeout event (self-cleaning)
 	 * Bit 3   P20 Force Timeout enabled:
diff --git a/drivers/watchdog/shwdt.c b/drivers/watchdog/shwdt.c
index 4e3e7eb..db84f23 100644
--- a/drivers/watchdog/shwdt.c
+++ b/drivers/watchdog/shwdt.c
@@ -50,7 +50,7 @@
  * necssary.
  *
  * As a result of this timing problem, the only modes that are particularly
- * feasible are the 4096 and the 2048 divisors, which yeild 5.25 and 2.62ms
+ * feasible are the 4096 and the 2048 divisors, which yield 5.25 and 2.62ms
  * overflow periods respectively.
  *
  * Also, since we can't really expect userspace to be responsive enough
diff --git a/drivers/watchdog/smsc37b787_wdt.c b/drivers/watchdog/smsc37b787_wdt.c
index df88cfa..e97b049 100644
--- a/drivers/watchdog/smsc37b787_wdt.c
+++ b/drivers/watchdog/smsc37b787_wdt.c
@@ -191,7 +191,7 @@ static inline void wdt_timer_conf(unsigned char conf)
 static inline void wdt_timer_ctrl(unsigned char reg)
 {
 	/* -- Watchdog timer control --
-	 * Bit 0   Status Bit: 0 = Timer counting, 1 = Timeout occured
+	 * Bit 0   Status Bit: 0 = Timer counting, 1 = Timeout occurred
 	 * Bit 1   Power LED Toggle: 0 = Disable Toggle, 1 = Toggle at 1 Hz
 	 * Bit 2   Force Timeout: 1 = Forces WD timeout event (self-cleaning)
 	 * Bit 3   P20 Force Timeout enabled:
diff --git a/drivers/watchdog/sp805_wdt.c b/drivers/watchdog/sp805_wdt.c
index 0a0efe7..0d80e08 100644
--- a/drivers/watchdog/sp805_wdt.c
+++ b/drivers/watchdog/sp805_wdt.c
@@ -90,7 +90,7 @@ static void wdt_setload(unsigned int timeout)
 	/*
 	 * sp805 runs counter with given value twice, after the end of first
 	 * counter it gives an interrupt and then starts counter again. If
-	 * interrupt already occured then it resets the system. This is why
+	 * interrupt already occurred then it resets the system. This is why
 	 * load is half of what should be required.
 	 */
 	load = div_u64(rate, 2) * timeout - 1;
diff --git a/drivers/xen/events.c b/drivers/xen/events.c
index 036343b..42d6c93 100644
--- a/drivers/xen/events.c
+++ b/drivers/xen/events.c
@@ -5,7 +5,7 @@
  * domain gets 1024 event channels, but NR_IRQ is not that large, we
  * must dynamically map irqs<->event channels.  The event channels
  * interface with the rest of the kernel by defining a xen interrupt
- * chip.  When an event is recieved, it is mapped to an irq and sent
+ * chip.  When an event is received, it is mapped to an irq and sent
  * through the normal interrupt processing path.
  *
  * There are four kinds of events which can be mapped to an event
@@ -416,7 +416,7 @@ static int __must_check xen_allocate_irq_dynamic(void)
 #ifdef CONFIG_X86_IO_APIC
 	/*
 	 * For an HVM guest or domain 0 which see "real" (emulated or
-	 * actual repectively) GSIs we allocate dynamic IRQs
+	 * actual respectively) GSIs we allocate dynamic IRQs
 	 * e.g. those corresponding to event channels or MSIs
 	 * etc. from the range above those "real" GSIs to avoid
 	 * collisions.
diff --git a/fs/adfs/map.c b/fs/adfs/map.c
index d1a5932..6935f05 100644
--- a/fs/adfs/map.c
+++ b/fs/adfs/map.c
@@ -51,7 +51,7 @@ static DEFINE_RWLOCK(adfs_map_lock);
 
 /*
  * This is fun.  We need to load up to 19 bits from the map at an
- * arbitary bit alignment.  (We're limited to 19 bits by F+ version 2).
+ * arbitrary bit alignment.  (We're limited to 19 bits by F+ version 2).
  */
 #define GET_FRAG_ID(_map,_start,_idmask)				\
 	({								\
diff --git a/fs/afs/cache.c b/fs/afs/cache.c
index 0fb315d..577763c 100644
--- a/fs/afs/cache.c
+++ b/fs/afs/cache.c
@@ -98,7 +98,7 @@ static uint16_t afs_cell_cache_get_key(const void *cookie_netfs_data,
 }
 
 /*
- * provide new auxilliary cache data
+ * provide new auxiliary cache data
  */
 static uint16_t afs_cell_cache_get_aux(const void *cookie_netfs_data,
 				       void *buffer, uint16_t bufmax)
@@ -117,7 +117,7 @@ static uint16_t afs_cell_cache_get_aux(const void *cookie_netfs_data,
 }
 
 /*
- * check that the auxilliary data indicates that the entry is still valid
+ * check that the auxiliary data indicates that the entry is still valid
  */
 static enum fscache_checkaux afs_cell_cache_check_aux(void *cookie_netfs_data,
 						      const void *buffer,
@@ -150,7 +150,7 @@ static uint16_t afs_vlocation_cache_get_key(const void *cookie_netfs_data,
 }
 
 /*
- * provide new auxilliary cache data
+ * provide new auxiliary cache data
  */
 static uint16_t afs_vlocation_cache_get_aux(const void *cookie_netfs_data,
 					    void *buffer, uint16_t bufmax)
@@ -172,7 +172,7 @@ static uint16_t afs_vlocation_cache_get_aux(const void *cookie_netfs_data,
 }
 
 /*
- * check that the auxilliary data indicates that the entry is still valid
+ * check that the auxiliary data indicates that the entry is still valid
  */
 static
 enum fscache_checkaux afs_vlocation_cache_check_aux(void *cookie_netfs_data,
@@ -283,7 +283,7 @@ static void afs_vnode_cache_get_attr(const void *cookie_netfs_data,
 }
 
 /*
- * provide new auxilliary cache data
+ * provide new auxiliary cache data
  */
 static uint16_t afs_vnode_cache_get_aux(const void *cookie_netfs_data,
 					void *buffer, uint16_t bufmax)
@@ -309,7 +309,7 @@ static uint16_t afs_vnode_cache_get_aux(const void *cookie_netfs_data,
 }
 
 /*
- * check that the auxilliary data indicates that the entry is still valid
+ * check that the auxiliary data indicates that the entry is still valid
  */
 static enum fscache_checkaux afs_vnode_cache_check_aux(void *cookie_netfs_data,
 						       const void *buffer,
diff --git a/fs/afs/cell.c b/fs/afs/cell.c
index 0d5eead..3c090b7 100644
--- a/fs/afs/cell.c
+++ b/fs/afs/cell.c
@@ -293,7 +293,7 @@ struct afs_cell *afs_cell_lookup(const char *name, unsigned namesz,
 		if (!cell) {
 			/* this should not happen unless user tries to mount
 			 * when root cell is not set. Return an impossibly
-			 * bizzare errno to alert the user. Things like
+			 * bizarre errno to alert the user. Things like
 			 * ENOENT might be "more appropriate" but they happen
 			 * for other reasons.
 			 */
diff --git a/fs/attr.c b/fs/attr.c
index 1007ed6..91dbe2a 100644
--- a/fs/attr.c
+++ b/fs/attr.c
@@ -128,7 +128,7 @@ EXPORT_SYMBOL(inode_newsize_ok);
  * setattr_copy must be called with i_mutex held.
  *
  * setattr_copy updates the inode's metadata with that specified
- * in attr. Noticably missing is inode size update, which is more complex
+ * in attr. Noticeably missing is inode size update, which is more complex
  * as it requires pagecache updates.
  *
  * The inode is not marked as dirty after this operation. The rationale is
diff --git a/fs/autofs4/root.c b/fs/autofs4/root.c
index 96804a1..f55ae23 100644
--- a/fs/autofs4/root.c
+++ b/fs/autofs4/root.c
@@ -612,7 +612,7 @@ static int autofs4_dir_unlink(struct inode *dir, struct dentry *dentry)
  * set the DMANAGED_AUTOMOUNT and DMANAGED_TRANSIT flags on the leaves
  * of the directory tree. There is no need to clear the automount flag
  * following a mount or restore it after an expire because these mounts
- * are always covered. However, it is neccessary to ensure that these
+ * are always covered. However, it is necessary to ensure that these
  * flags are clear on non-empty directories to avoid unnecessary calls
  * during path walks.
  */
diff --git a/fs/befs/ChangeLog b/fs/befs/ChangeLog
index ce8c787..75a461c 100644
--- a/fs/befs/ChangeLog
+++ b/fs/befs/ChangeLog
@@ -24,7 +24,7 @@ Version 0.9 (2002-03-14)
 
 Version 0.64 (2002-02-07)
 ==========
-* Did the string comparision really right this time (btree.c) [WD]
+* Did the string comparison really right this time (btree.c) [WD]
 
 * Fixed up some places where I assumed that a long int could hold
 	a pointer value. (btree.c) [WD]
@@ -114,7 +114,7 @@ Version 0.6 (2001-12-15)
 	More flexible. Will soon be controllable at mount time 
 	(see TODO). [WD]
 
-* Rewrote datastream positon lookups.
+* Rewrote datastream position lookups.
 	(datastream.c) [WD]
 
 * Moved the TODO list to its own file.
@@ -150,7 +150,7 @@ Version 0.50 (2001-11-13)
 * Anton also told me that the blocksize is not allowed to be larger than 
 	the page size in linux, which is 4k i386. Oops. Added a test for 
 	(blocksize > PAGE_SIZE), and refuse to mount in that case. What this 
-	practicaly means is that 8k blocksize volumes won't work without a major
+	practically means is that 8k blocksize volumes won't work without a major
 	restructuring of the driver (or an alpha or other 64bit hardware). [WD]
 
 * Cleaned up the befs_count_blocks() function. Much smarter now. 
@@ -183,7 +183,7 @@ Version 0.45 (2001-10-29)
 	structures into the generic pointer fields of the public structures 
 	with kmalloc(). put_super and put_inode free them. This allows us not 
 	to have to touch the definitions of the public structures in 
-	include/linux/fs.h. Also, befs_inode_info is huge (becuase of the 
+	include/linux/fs.h. Also, befs_inode_info is huge (because of the 
 	symlink string). (super.c, inode.c, befs_fs.h) [WD]
 
 * Fixed a thinko that was corrupting file reads after the first block_run 
@@ -404,7 +404,7 @@ Version 0.4 (2001-10-28)
 
 * Fixed compile errors on 2.4.1 kernel (WD)
 	Resolve rejected patches
-	Accomodate changed NLS interface (util.h)
+	Accommodate changed NLS interface (util.h)
 	Needed to include <linux/slab.h> in most files
 	Makefile changes
 	fs/Config.in changes
diff --git a/fs/befs/befs_fs_types.h b/fs/befs/befs_fs_types.h
index 7893eaa..eb557d9 100644
--- a/fs/befs/befs_fs_types.h
+++ b/fs/befs/befs_fs_types.h
@@ -234,7 +234,7 @@ typedef struct {
 } PACKED befs_btree_super;
 
 /*
- * Header stucture of each btree node
+ * Header structure of each btree node
  */
 typedef struct {
 	fs64 left;
diff --git a/fs/befs/btree.c b/fs/befs/btree.c
index 4202db7..a66c9b1 100644
--- a/fs/befs/btree.c
+++ b/fs/befs/btree.c
@@ -5,7 +5,7 @@
  *
  * Licensed under the GNU GPL. See the file COPYING for details.
  *
- * 2002-02-05: Sergey S. Kostyliov added binary search withing
+ * 2002-02-05: Sergey S. Kostyliov added binary search within
  * 		btree nodes.
  *
  * Many thanks to:
diff --git a/fs/befs/linuxvfs.c b/fs/befs/linuxvfs.c
index 06457ed..54b8c28 100644
--- a/fs/befs/linuxvfs.c
+++ b/fs/befs/linuxvfs.c
@@ -734,7 +734,7 @@ parse_options(char *options, befs_mount_options * opts)
 
 /* This function has the responsibiltiy of getting the
  * filesystem ready for unmounting. 
- * Basicly, we free everything that we allocated in
+ * Basically, we free everything that we allocated in
  * befs_read_inode
  */
 static void
diff --git a/fs/binfmt_flat.c b/fs/binfmt_flat.c
index 811384b..397d305 100644
--- a/fs/binfmt_flat.c
+++ b/fs/binfmt_flat.c
@@ -717,7 +717,7 @@ static int load_flat_file(struct linux_binprm * bprm,
 	 * help simplify all this mumbo jumbo
 	 *
 	 * We've got two different sections of relocation entries.
-	 * The first is the GOT which resides at the begining of the data segment
+	 * The first is the GOT which resides at the beginning of the data segment
 	 * and is terminated with a -1.  This one can be relocated in place.
 	 * The second is the extra relocation entries tacked after the image's
 	 * data segment. These require a little more processing as the entry is
diff --git a/fs/bio.c b/fs/bio.c
index 4d6d4b6..840a0d7 100644
--- a/fs/bio.c
+++ b/fs/bio.c
@@ -1436,7 +1436,7 @@ EXPORT_SYMBOL(bio_flush_dcache_pages);
  *   preferred way to end I/O on a bio, it takes care of clearing
  *   BIO_UPTODATE on error. @error is 0 on success, and and one of the
  *   established -Exxxx (-EIO, for instance) error values in case
- *   something went wrong. Noone should call bi_end_io() directly on a
+ *   something went wrong. No one should call bi_end_io() directly on a
  *   bio unless they own it and thus know that it has an end_io
  *   function.
  **/
diff --git a/fs/block_dev.c b/fs/block_dev.c
index c1511c6..5147bdd 100644
--- a/fs/block_dev.c
+++ b/fs/block_dev.c
@@ -653,7 +653,7 @@ void bd_forget(struct inode *inode)
  * @whole: whole block device containing @bdev, may equal @bdev
  * @holder: holder trying to claim @bdev
  *
- * Test whther @bdev can be claimed by @holder.
+ * Test whether @bdev can be claimed by @holder.
  *
  * CONTEXT:
  * spin_lock(&bdev_lock).
diff --git a/fs/btrfs/extent_map.c b/fs/btrfs/extent_map.c
index 2b6c12e..a24a3f2 100644
--- a/fs/btrfs/extent_map.c
+++ b/fs/btrfs/extent_map.c
@@ -243,7 +243,7 @@ out:
  * Insert @em into @tree or perform a simple forward/backward merge with
  * existing mappings.  The extent_map struct passed in will be inserted
  * into the tree directly, with an additional reference taken, or a
- * reference dropped if the merge attempt was successfull.
+ * reference dropped if the merge attempt was successful.
  */
 int add_extent_mapping(struct extent_map_tree *tree,
 		       struct extent_map *em)
diff --git a/fs/btrfs/inode.c b/fs/btrfs/inode.c
index 6541339..5cc64ab 100644
--- a/fs/btrfs/inode.c
+++ b/fs/btrfs/inode.c
@@ -2321,7 +2321,7 @@ int btrfs_orphan_cleanup(struct btrfs_root *root)
 
 		/*
 		 * if ret == 0 means we found what we were searching for, which
-		 * is weird, but possible, so only screw with path if we didnt
+		 * is weird, but possible, so only screw with path if we didn't
 		 * find the key and see if we have stuff that matches
 		 */
 		if (ret > 0) {
diff --git a/fs/btrfs/relocation.c b/fs/btrfs/relocation.c
index 58250e0..199a801 100644
--- a/fs/btrfs/relocation.c
+++ b/fs/btrfs/relocation.c
@@ -2346,7 +2346,7 @@ struct btrfs_root *select_one_root(struct btrfs_trans_handle *trans,
 		root = next->root;
 		BUG_ON(!root);
 
-		/* no other choice for non-refernce counted tree */
+		/* no other choice for non-references counted tree */
 		if (!root->ref_cows)
 			return root;
 
diff --git a/fs/cachefiles/interface.c b/fs/cachefiles/interface.c
index 37fe101..1064805 100644
--- a/fs/cachefiles/interface.c
+++ b/fs/cachefiles/interface.c
@@ -197,7 +197,7 @@ struct fscache_object *cachefiles_grab_object(struct fscache_object *_object)
 }
 
 /*
- * update the auxilliary data for an object object on disk
+ * update the auxiliary data for an object object on disk
  */
 static void cachefiles_update_object(struct fscache_object *_object)
 {
diff --git a/fs/ceph/addr.c b/fs/ceph/addr.c
index 37368ba..e159c52 100644
--- a/fs/ceph/addr.c
+++ b/fs/ceph/addr.c
@@ -24,7 +24,7 @@
  * context needs to be associated with the osd write during writeback.
  *
  * Similarly, struct ceph_inode_info maintains a set of counters to
- * count dirty pages on the inode.  In the absense of snapshots,
+ * count dirty pages on the inode.  In the absence of snapshots,
  * i_wrbuffer_ref == i_wrbuffer_ref_head == the dirty page count.
  *
  * When a snapshot is taken (that is, when the client receives
diff --git a/fs/ceph/caps.c b/fs/ceph/caps.c
index 6b61ded..5323c33 100644
--- a/fs/ceph/caps.c
+++ b/fs/ceph/caps.c
@@ -765,7 +765,7 @@ int __ceph_caps_issued_mask(struct ceph_inode_info *ci, int mask, int touch)
 			if (touch) {
 				struct rb_node *q;
 
-				/* touch this + preceeding caps */
+				/* touch this + preceding caps */
 				__touch_cap(cap);
 				for (q = rb_first(&ci->i_caps); q != p;
 				     q = rb_next(q)) {
diff --git a/fs/ceph/snap.c b/fs/ceph/snap.c
index 0aee66b..e86ec11 100644
--- a/fs/ceph/snap.c
+++ b/fs/ceph/snap.c
@@ -342,7 +342,7 @@ static int build_snap_context(struct ceph_snap_realm *realm)
 	num = 0;
 	snapc->seq = realm->seq;
 	if (parent) {
-		/* include any of parent's snaps occuring _after_ my
+		/* include any of parent's snaps occurring _after_ my
 		   parent became my parent */
 		for (i = 0; i < parent->cached_context->num_snaps; i++)
 			if (parent->cached_context->snaps[i] >=
diff --git a/fs/cifs/AUTHORS b/fs/cifs/AUTHORS
index 7f7fa3c..ea940b1 100644
--- a/fs/cifs/AUTHORS
+++ b/fs/cifs/AUTHORS
@@ -35,7 +35,7 @@ Adrian Bunk (kcalloc cleanups)
 Miklos Szeredi 
 Kazeon team for various fixes especially for 2.4 version.
 Asser Ferno (Change Notify support)
-Shaggy (Dave Kleikamp) for inumerable small fs suggestions and some good cleanup
+Shaggy (Dave Kleikamp) for innumerable small fs suggestions and some good cleanup
 Gunter Kukkukk (testing and suggestions for support of old servers)
 Igor Mammedov (DFS support)
 Jeff Layton (many, many fixes, as well as great work on the cifs Kerberos code)
diff --git a/fs/cifs/cifs_dfs_ref.c b/fs/cifs/cifs_dfs_ref.c
index 0a265ad..2b68ac5 100644
--- a/fs/cifs/cifs_dfs_ref.c
+++ b/fs/cifs/cifs_dfs_ref.c
@@ -53,7 +53,7 @@ void cifs_dfs_release_automount_timer(void)
  *
  * Extracts sharename form full UNC.
  * i.e. strips from UNC trailing path that is not part of share
- * name and fixup missing '\' in the begining of DFS node refferal
+ * name and fixup missing '\' in the beginning of DFS node refferal
  * if necessary.
  * Returns pointer to share name on success or ERR_PTR on error.
  * Caller is responsible for freeing returned string.
diff --git a/fs/cifs/cifssmb.c b/fs/cifs/cifssmb.c
index 904aa47..2644a5d 100644
--- a/fs/cifs/cifssmb.c
+++ b/fs/cifs/cifssmb.c
@@ -5247,7 +5247,7 @@ cifs_fill_unix_set_info(FILE_UNIX_BASIC_INFO *data_offset,
 	 * Samba server ignores set of file size to zero due to bugs in some
 	 * older clients, but we should be precise - we use SetFileSize to
 	 * set file size and do not want to truncate file size to zero
-	 * accidently as happened on one Samba server beta by putting
+	 * accidentally as happened on one Samba server beta by putting
 	 * zero instead of -1 here
 	 */
 	data_offset->EndOfFile = cpu_to_le64(NO_CHANGE_64);
diff --git a/fs/cifs/connect.c b/fs/cifs/connect.c
index 8d6c17a..6e2b2ad 100644
--- a/fs/cifs/connect.c
+++ b/fs/cifs/connect.c
@@ -1572,7 +1572,7 @@ match_security(struct TCP_Server_Info *server, struct smb_vol *vol)
 		return false;
 	}
 
-	/* now check if signing mode is acceptible */
+	/* now check if signing mode is acceptable */
 	if ((secFlags & CIFSSEC_MAY_SIGN) == 0 &&
 	    (server->secMode & SECMODE_SIGN_REQUIRED))
 			return false;
@@ -2933,7 +2933,7 @@ mount_fail_check:
 		if (mount_data != mount_data_global)
 			kfree(mount_data);
 		/* If find_unc succeeded then rc == 0 so we can not end */
-		/* up accidently freeing someone elses tcon struct */
+		/* up accidentally freeing someone elses tcon struct */
 		if (tcon)
 			cifs_put_tcon(tcon);
 		else if (pSesInfo)
diff --git a/fs/cifs/dir.c b/fs/cifs/dir.c
index dd5f229..9ea65cf 100644
--- a/fs/cifs/dir.c
+++ b/fs/cifs/dir.c
@@ -189,7 +189,7 @@ cifs_create(struct inode *inode, struct dentry *direntry, int mode,
 			inode->i_sb, mode, oflags, &oplock, &fileHandle, xid);
 		/* EIO could indicate that (posix open) operation is not
 		   supported, despite what server claimed in capability
-		   negotation.  EREMOTE indicates DFS junction, which is not
+		   negotiation.  EREMOTE indicates DFS junction, which is not
 		   handled in posix open */
 
 		if (rc == 0) {
diff --git a/fs/configfs/dir.c b/fs/configfs/dir.c
index 90ff3cb..3313dd1 100644
--- a/fs/configfs/dir.c
+++ b/fs/configfs/dir.c
@@ -990,7 +990,7 @@ static int configfs_dump(struct configfs_dirent *sd, int level)
  * This describes these functions and their helpers.
  *
  * Allow another kernel system to depend on a config_item.  If this
- * happens, the item cannot go away until the dependant can live without
+ * happens, the item cannot go away until the dependent can live without
  * it.  The idea is to give client modules as simple an interface as
  * possible.  When a system asks them to depend on an item, they just
  * call configfs_depend_item().  If the item is live and the client
diff --git a/fs/dlm/lock.c b/fs/dlm/lock.c
index 04b8c44..56d6bfc 100644
--- a/fs/dlm/lock.c
+++ b/fs/dlm/lock.c
@@ -519,7 +519,7 @@ static void toss_rsb(struct kref *kref)
 	}
 }
 
-/* When all references to the rsb are gone it's transfered to
+/* When all references to the rsb are gone it's transferred to
    the tossed list for later disposal. */
 
 static void put_rsb(struct dlm_rsb *r)
diff --git a/fs/dlm/lowcomms.c b/fs/dlm/lowcomms.c
index bffa1e7..5e2c71f 100644
--- a/fs/dlm/lowcomms.c
+++ b/fs/dlm/lowcomms.c
@@ -810,7 +810,7 @@ static int tcp_accept_from_sock(struct connection *con)
 
 	/*
 	 * Add it to the active queue in case we got data
-	 * beween processing the accept adding the socket
+	 * between processing the accept adding the socket
 	 * to the read_sockets list
 	 */
 	if (!test_and_set_bit(CF_READ_PENDING, &addcon->flags))
diff --git a/fs/dlm/recover.c b/fs/dlm/recover.c
index eda43f3..1463823 100644
--- a/fs/dlm/recover.c
+++ b/fs/dlm/recover.c
@@ -304,7 +304,7 @@ static void set_master_lkbs(struct dlm_rsb *r)
 }
 
 /*
- * Propogate the new master nodeid to locks
+ * Propagate the new master nodeid to locks
  * The NEW_MASTER flag tells dlm_recover_locks() which rsb's to consider.
  * The NEW_MASTER2 flag tells recover_lvb() and set_locks_purged() which
  * rsb's to consider.
diff --git a/fs/ecryptfs/main.c b/fs/ecryptfs/main.c
index c27c0ec..fdb2eb0 100644
--- a/fs/ecryptfs/main.c
+++ b/fs/ecryptfs/main.c
@@ -276,7 +276,7 @@ static void ecryptfs_init_mount_crypt_stat(
 /**
  * ecryptfs_parse_options
  * @sb: The ecryptfs super block
- * @options: The options pased to the kernel
+ * @options: The options passed to the kernel
  *
  * Parse mount options:
  * debug=N 	   - ecryptfs_verbosity level for debug output
@@ -840,7 +840,7 @@ static int __init ecryptfs_init(void)
 	}
 	rc = ecryptfs_init_messaging();
 	if (rc) {
-		printk(KERN_ERR "Failure occured while attempting to "
+		printk(KERN_ERR "Failure occurred while attempting to "
 				"initialize the communications channel to "
 				"ecryptfsd\n");
 		goto out_destroy_kthread;
diff --git a/fs/eventpoll.c b/fs/eventpoll.c
index ed38801..f9cfd16 100644
--- a/fs/eventpoll.c
+++ b/fs/eventpoll.c
@@ -181,7 +181,7 @@ struct eventpoll {
 
 	/*
 	 * This is a single linked list that chains all the "struct epitem" that
-	 * happened while transfering ready events to userspace w/out
+	 * happened while transferring ready events to userspace w/out
 	 * holding ->lock.
 	 */
 	struct epitem *ovflist;
@@ -606,7 +606,7 @@ static void ep_free(struct eventpoll *ep)
 	 * We do not need to hold "ep->mtx" here because the epoll file
 	 * is on the way to be removed and no one has references to it
 	 * anymore. The only hit might come from eventpoll_release_file() but
-	 * holding "epmutex" is sufficent here.
+	 * holding "epmutex" is sufficient here.
 	 */
 	mutex_lock(&epmutex);
 
@@ -720,7 +720,7 @@ void eventpoll_release_file(struct file *file)
 	/*
 	 * We don't want to get "file->f_lock" because it is not
 	 * necessary. It is not necessary because we're in the "struct file"
-	 * cleanup path, and this means that noone is using this file anymore.
+	 * cleanup path, and this means that no one is using this file anymore.
 	 * So, for example, epoll_ctl() cannot hit here since if we reach this
 	 * point, the file counter already went to zero and fget() would fail.
 	 * The only hit might come from ep_free() but by holding the mutex
@@ -1112,7 +1112,7 @@ static int ep_send_events_proc(struct eventpoll *ep, struct list_head *head,
 				 * Trigger mode, we need to insert back inside
 				 * the ready list, so that the next call to
 				 * epoll_wait() will check again the events
-				 * availability. At this point, noone can insert
+				 * availability. At this point, no one can insert
 				 * into ep->rdllist besides us. The epoll_ctl()
 				 * callers are locked out by
 				 * ep_scan_ready_list() holding "mtx" and the
diff --git a/fs/exofs/common.h b/fs/exofs/common.h
index 5e74ad3..3bbd469 100644
--- a/fs/exofs/common.h
+++ b/fs/exofs/common.h
@@ -115,7 +115,7 @@ struct exofs_sb_stats {
  * Describes the raid used in the FS. It is part of the device table.
  * This here is taken from the pNFS-objects definition. In exofs we
  * use one raid policy through-out the filesystem. (NOTE: the funny
- * alignment at begining. We take care of it at exofs_device_table.
+ * alignment at beginning. We take care of it at exofs_device_table.
  */
 struct exofs_dt_data_map {
 	__le32	cb_num_comps;
@@ -136,7 +136,7 @@ struct exofs_dt_device_info {
 	u8	systemid[OSD_SYSTEMID_LEN];
 	__le64	long_name_offset;	/* If !0 then offset-in-file */
 	__le32	osdname_len;		/* */
-	u8	osdname[44];		/* Embbeded, Ususally an asci uuid */
+	u8	osdname[44];		/* Embbeded, Usually an asci uuid */
 } __packed;
 
 /*
diff --git a/fs/ext2/balloc.c b/fs/ext2/balloc.c
index 0d06f4e..8f44cef 100644
--- a/fs/ext2/balloc.c
+++ b/fs/ext2/balloc.c
@@ -850,7 +850,7 @@ static int find_next_reservable_window(
 		rsv_window_remove(sb, my_rsv);
 
 	/*
-	 * Let's book the whole avaliable window for now.  We will check the
+	 * Let's book the whole available window for now.  We will check the
 	 * disk bitmap later and then, if there are free blocks then we adjust
 	 * the window size if it's larger than requested.
 	 * Otherwise, we will remove this node from the tree next time
@@ -1357,9 +1357,9 @@ retry_alloc:
 			goto allocated;
 	}
 	/*
-	 * We may end up a bogus ealier ENOSPC error due to
+	 * We may end up a bogus earlier ENOSPC error due to
 	 * filesystem is "full" of reservations, but
-	 * there maybe indeed free blocks avaliable on disk
+	 * there maybe indeed free blocks available on disk
 	 * In this case, we just forget about the reservations
 	 * just do block allocation as without reservations.
 	 */
diff --git a/fs/ext2/inode.c b/fs/ext2/inode.c
index c47f706..788e09a 100644
--- a/fs/ext2/inode.c
+++ b/fs/ext2/inode.c
@@ -305,7 +305,7 @@ static ext2_fsblk_t ext2_find_near(struct inode *inode, Indirect *ind)
 		return ind->bh->b_blocknr;
 
 	/*
-	 * It is going to be refered from inode itself? OK, just put it into
+	 * It is going to be referred from inode itself? OK, just put it into
 	 * the same cylinder group then.
 	 */
 	bg_start = ext2_group_first_block_no(inode->i_sb, ei->i_block_group);
@@ -913,7 +913,7 @@ static inline int all_zeroes(__le32 *p, __le32 *q)
  *
  *	When we do truncate() we may have to clean the ends of several indirect
  *	blocks but leave the blocks themselves alive. Block is partially
- *	truncated if some data below the new i_size is refered from it (and
+ *	truncated if some data below the new i_size is referred from it (and
  *	it is on the path to the first completely truncated data block, indeed).
  *	We have to free the top of that path along with everything to the right
  *	of the path. Since no allocation past the truncation point is possible
@@ -990,7 +990,7 @@ no_top:
  *	@p:	array of block numbers
  *	@q:	points immediately past the end of array
  *
- *	We are freeing all blocks refered from that array (numbers are
+ *	We are freeing all blocks referred from that array (numbers are
  *	stored as little-endian 32-bit) and updating @inode->i_blocks
  *	appropriately.
  */
@@ -1030,7 +1030,7 @@ static inline void ext2_free_data(struct inode *inode, __le32 *p, __le32 *q)
  *	@q:	pointer immediately past the end of array
  *	@depth:	depth of the branches to free
  *
- *	We are freeing all blocks refered from these branches (numbers are
+ *	We are freeing all blocks referred from these branches (numbers are
  *	stored as little-endian 32-bit) and updating @inode->i_blocks
  *	appropriately.
  */
diff --git a/fs/ext2/super.c b/fs/ext2/super.c
index 7731695..0a78dae 100644
--- a/fs/ext2/super.c
+++ b/fs/ext2/super.c
@@ -1382,7 +1382,7 @@ static struct dentry *ext2_mount(struct file_system_type *fs_type,
 
 /* Read data from quotafile - avoid pagecache and such because we cannot afford
  * acquiring the locks... As quota files are never truncated and quota code
- * itself serializes the operations (and noone else should touch the files)
+ * itself serializes the operations (and no one else should touch the files)
  * we don't have to be afraid of races */
 static ssize_t ext2_quota_read(struct super_block *sb, int type, char *data,
 			       size_t len, loff_t off)
diff --git a/fs/ext2/xattr.c b/fs/ext2/xattr.c
index c2e4dce..5299706 100644
--- a/fs/ext2/xattr.c
+++ b/fs/ext2/xattr.c
@@ -35,7 +35,7 @@
  *   +------------------+
  *
  * The block header is followed by multiple entry descriptors. These entry
- * descriptors are variable in size, and alligned to EXT2_XATTR_PAD
+ * descriptors are variable in size, and aligned to EXT2_XATTR_PAD
  * byte boundaries. The entry descriptors are sorted by attribute name,
  * so that two extended attribute blocks can be compared efficiently.
  *
diff --git a/fs/ext3/balloc.c b/fs/ext3/balloc.c
index 1532421..fe52297 100644
--- a/fs/ext3/balloc.c
+++ b/fs/ext3/balloc.c
@@ -590,7 +590,7 @@ do_more:
 				BUFFER_TRACE(debug_bh, "Deleted!");
 				if (!bh2jh(bitmap_bh)->b_committed_data)
 					BUFFER_TRACE(debug_bh,
-						"No commited data in bitmap");
+						"No committed data in bitmap");
 				BUFFER_TRACE2(debug_bh, bitmap_bh, "bitmap");
 				__brelse(debug_bh);
 			}
@@ -1063,7 +1063,7 @@ static int find_next_reservable_window(
 		rsv_window_remove(sb, my_rsv);
 
 	/*
-	 * Let's book the whole avaliable window for now.  We will check the
+	 * Let's book the whole available window for now.  We will check the
 	 * disk bitmap later and then, if there are free blocks then we adjust
 	 * the window size if it's larger than requested.
 	 * Otherwise, we will remove this node from the tree next time
@@ -1456,7 +1456,7 @@ static int ext3_has_free_blocks(struct ext3_sb_info *sbi)
  *
  * ext3_should_retry_alloc() is called when ENOSPC is returned, and if
  * it is profitable to retry the operation, this function will wait
- * for the current or commiting transaction to complete, and then
+ * for the current or committing transaction to complete, and then
  * return TRUE.
  *
  * if the total number of retries exceed three times, return FALSE.
@@ -1632,9 +1632,9 @@ retry_alloc:
 			goto allocated;
 	}
 	/*
-	 * We may end up a bogus ealier ENOSPC error due to
+	 * We may end up a bogus earlier ENOSPC error due to
 	 * filesystem is "full" of reservations, but
-	 * there maybe indeed free blocks avaliable on disk
+	 * there maybe indeed free blocks available on disk
 	 * In this case, we just forget about the reservations
 	 * just do block allocation as without reservations.
 	 */
diff --git a/fs/ext3/inode.c b/fs/ext3/inode.c
index fe2541d..68b2e43 100644
--- a/fs/ext3/inode.c
+++ b/fs/ext3/inode.c
@@ -2055,7 +2055,7 @@ static inline int all_zeroes(__le32 *p, __le32 *q)
  *
  *	When we do truncate() we may have to clean the ends of several
  *	indirect blocks but leave the blocks themselves alive. Block is
- *	partially truncated if some data below the new i_size is refered
+ *	partially truncated if some data below the new i_size is referred
  *	from it (and it is on the path to the first completely truncated
  *	data block, indeed).  We have to free the top of that path along
  *	with everything to the right of the path. Since no allocation
@@ -2184,7 +2184,7 @@ static void ext3_clear_blocks(handle_t *handle, struct inode *inode,
  * @first:	array of block numbers
  * @last:	points immediately past the end of array
  *
- * We are freeing all blocks refered from that array (numbers are stored as
+ * We are freeing all blocks referred from that array (numbers are stored as
  * little-endian 32-bit) and updating @inode->i_blocks appropriately.
  *
  * We accumulate contiguous runs of blocks to free.  Conveniently, if these
@@ -2272,7 +2272,7 @@ static void ext3_free_data(handle_t *handle, struct inode *inode,
  *	@last:	pointer immediately past the end of array
  *	@depth:	depth of the branches to free
  *
- *	We are freeing all blocks refered from these branches (numbers are
+ *	We are freeing all blocks referred from these branches (numbers are
  *	stored as little-endian 32-bit) and updating @inode->i_blocks
  *	appropriately.
  */
@@ -3291,7 +3291,7 @@ static int ext3_writepage_trans_blocks(struct inode *inode)
 	if (ext3_should_journal_data(inode))
 		ret = 3 * (bpp + indirects) + 2;
 	else
-		ret = 2 * (bpp + indirects) + 2;
+		ret = 2 * (bpp + indirects) + indirects + 2;
 
 #ifdef CONFIG_QUOTA
 	/* We know that structure was already allocated during dquot_initialize so
diff --git a/fs/ext3/resize.c b/fs/ext3/resize.c
index 108b142..7916e4c 100644
--- a/fs/ext3/resize.c
+++ b/fs/ext3/resize.c
@@ -1009,7 +1009,7 @@ int ext3_group_extend(struct super_block *sb, struct ext3_super_block *es,
 
 	if (test_opt(sb, DEBUG))
 		printk(KERN_DEBUG "EXT3-fs: extending last group from "E3FSBLK
-		       " upto "E3FSBLK" blocks\n",
+		       " up to "E3FSBLK" blocks\n",
 		       o_blocks_count, n_blocks_count);
 
 	if (n_blocks_count == 0 || n_blocks_count == o_blocks_count)
diff --git a/fs/ext3/super.c b/fs/ext3/super.c
index 071689f..3c6a9e0 100644
--- a/fs/ext3/super.c
+++ b/fs/ext3/super.c
@@ -2925,7 +2925,7 @@ static int ext3_quota_on(struct super_block *sb, int type, int format_id,
 
 /* Read data from quotafile - avoid pagecache and such because we cannot afford
  * acquiring the locks... As quota files are never truncated and quota code
- * itself serializes the operations (and noone else should touch the files)
+ * itself serializes the operations (and no one else should touch the files)
  * we don't have to be afraid of races */
 static ssize_t ext3_quota_read(struct super_block *sb, int type, char *data,
 			       size_t len, loff_t off)
diff --git a/fs/ext4/balloc.c b/fs/ext4/balloc.c
index 97b970e..1c67139 100644
--- a/fs/ext4/balloc.c
+++ b/fs/ext4/balloc.c
@@ -547,7 +547,7 @@ int ext4_claim_free_blocks(struct ext4_sb_info *sbi,
  *
  * ext4_should_retry_alloc() is called when ENOSPC is returned, and if
  * it is profitable to retry the operation, this function will wait
- * for the current or commiting transaction to complete, and then
+ * for the current or committing transaction to complete, and then
  * return TRUE.
  *
  * if the total number of retries exceed three times, return FALSE.
diff --git a/fs/ext4/extents.c b/fs/ext4/extents.c
index dd2cb50..4890d6f 100644
--- a/fs/ext4/extents.c
+++ b/fs/ext4/extents.c
@@ -1729,7 +1729,7 @@ repeat:
 		BUG_ON(npath->p_depth != path->p_depth);
 		eh = npath[depth].p_hdr;
 		if (le16_to_cpu(eh->eh_entries) < le16_to_cpu(eh->eh_max)) {
-			ext_debug("next leaf isnt full(%d)\n",
+			ext_debug("next leaf isn't full(%d)\n",
 				  le16_to_cpu(eh->eh_entries));
 			path = npath;
 			goto repeat;
@@ -2533,7 +2533,7 @@ static int ext4_ext_zeroout(struct inode *inode, struct ext4_extent *ex)
 /*
  * This function is called by ext4_ext_map_blocks() if someone tries to write
  * to an uninitialized extent. It may result in splitting the uninitialized
- * extent into multiple extents (upto three - one initialized and two
+ * extent into multiple extents (up to three - one initialized and two
  * uninitialized).
  * There are three possibilities:
  *   a> There is no split required: Entire extent should be initialized
@@ -3174,7 +3174,7 @@ ext4_ext_handle_uninitialized_extents(handle_t *handle, struct inode *inode,
 						   path, flags);
 		/*
 		 * Flag the inode(non aio case) or end_io struct (aio case)
-		 * that this IO needs to convertion to written when IO is
+		 * that this IO needs to conversion to written when IO is
 		 * completed
 		 */
 		if (io && !(io->flag & EXT4_IO_END_UNWRITTEN)) {
@@ -3460,10 +3460,10 @@ int ext4_ext_map_blocks(handle_t *handle, struct inode *inode,
 		ext4_ext_mark_uninitialized(&newex);
 		/*
 		 * io_end structure was created for every IO write to an
-		 * uninitialized extent. To avoid unecessary conversion,
+		 * uninitialized extent. To avoid unnecessary conversion,
 		 * here we flag the IO that really needs the conversion.
 		 * For non asycn direct IO case, flag the inode state
-		 * that we need to perform convertion when IO is done.
+		 * that we need to perform conversion when IO is done.
 		 */
 		if ((flags & EXT4_GET_BLOCKS_PRE_IO)) {
 			if (io && !(io->flag & EXT4_IO_END_UNWRITTEN)) {
diff --git a/fs/ext4/fsync.c b/fs/ext4/fsync.c
index 7f74019..4673bc0 100644
--- a/fs/ext4/fsync.c
+++ b/fs/ext4/fsync.c
@@ -101,7 +101,7 @@ extern int ext4_flush_completed_IO(struct inode *inode)
 		 * to the work-to-be schedule is freed.
 		 *
 		 * Thus we need to keep the io structure still valid here after
-		 * convertion finished. The io structure has a flag to
+		 * conversion finished. The io structure has a flag to
 		 * avoid double converting from both fsync and background work
 		 * queue work.
 		 */
diff --git a/fs/ext4/inode.c b/fs/ext4/inode.c
index 1a86282..ad8e303 100644
--- a/fs/ext4/inode.c
+++ b/fs/ext4/inode.c
@@ -2588,7 +2588,7 @@ static void ext4_end_io_buffer_write(struct buffer_head *bh, int uptodate);
  * because we should have holes filled from ext4_page_mkwrite(). We even don't
  * need to file the inode to the transaction's list in ordered mode because if
  * we are writing back data added by write(), the inode is already there and if
- * we are writing back data modified via mmap(), noone guarantees in which
+ * we are writing back data modified via mmap(), no one guarantees in which
  * transaction the data will hit the disk. In case we are journaling data, we
  * cannot start transaction directly because transaction start ranks above page
  * lock so we have to do some magic.
@@ -2690,7 +2690,7 @@ static int ext4_writepage(struct page *page,
 
 /*
  * This is called via ext4_da_writepages() to
- * calulate the total number of credits to reserve to fit
+ * calculate the total number of credits to reserve to fit
  * a single extent allocation into a single transaction,
  * ext4_da_writpeages() will loop calling this before
  * the block allocation.
@@ -3304,7 +3304,7 @@ int ext4_alloc_da_blocks(struct inode *inode)
 	 * the pages by calling redirty_page_for_writepage() but that
 	 * would be ugly in the extreme.  So instead we would need to
 	 * replicate parts of the code in the above functions,
-	 * simplifying them becuase we wouldn't actually intend to
+	 * simplifying them because we wouldn't actually intend to
 	 * write out the pages, but rather only collect contiguous
 	 * logical block extents, call the multi-block allocator, and
 	 * then update the buffer heads with the block allocations.
@@ -3694,7 +3694,7 @@ retry:
  *
  * The unwrritten extents will be converted to written when DIO is completed.
  * For async direct IO, since the IO may still pending when return, we
- * set up an end_io call back function, which will do the convertion
+ * set up an end_io call back function, which will do the conversion
  * when async direct IO completed.
  *
  * If the O_DIRECT write will extend the file then add this inode to the
@@ -3717,7 +3717,7 @@ static ssize_t ext4_ext_direct_IO(int rw, struct kiocb *iocb,
  		 * We could direct write to holes and fallocate.
 		 *
  		 * Allocated blocks to fill the hole are marked as uninitialized
- 		 * to prevent paralel buffered read to expose the stale data
+ 		 * to prevent parallel buffered read to expose the stale data
  		 * before DIO complete the data IO.
 		 *
  		 * As to previously fallocated extents, ext4 get_block
@@ -3778,7 +3778,7 @@ static ssize_t ext4_ext_direct_IO(int rw, struct kiocb *iocb,
 			int err;
 			/*
 			 * for non AIO case, since the IO is already
-			 * completed, we could do the convertion right here
+			 * completed, we could do the conversion right here
 			 */
 			err = ext4_convert_unwritten_extents(inode,
 							     offset, ret);
@@ -4025,7 +4025,7 @@ static inline int all_zeroes(__le32 *p, __le32 *q)
  *
  *	When we do truncate() we may have to clean the ends of several
  *	indirect blocks but leave the blocks themselves alive. Block is
- *	partially truncated if some data below the new i_size is refered
+ *	partially truncated if some data below the new i_size is referred
  *	from it (and it is on the path to the first completely truncated
  *	data block, indeed).  We have to free the top of that path along
  *	with everything to the right of the path. Since no allocation
@@ -4169,7 +4169,7 @@ out_err:
  * @first:	array of block numbers
  * @last:	points immediately past the end of array
  *
- * We are freeing all blocks refered from that array (numbers are stored as
+ * We are freeing all blocks referred from that array (numbers are stored as
  * little-endian 32-bit) and updating @inode->i_blocks appropriately.
  *
  * We accumulate contiguous runs of blocks to free.  Conveniently, if these
@@ -4261,7 +4261,7 @@ static void ext4_free_data(handle_t *handle, struct inode *inode,
  *	@last:	pointer immediately past the end of array
  *	@depth:	depth of the branches to free
  *
- *	We are freeing all blocks refered from these branches (numbers are
+ *	We are freeing all blocks referred from these branches (numbers are
  *	stored as little-endian 32-bit) and updating @inode->i_blocks
  *	appropriately.
  */
@@ -5478,7 +5478,7 @@ static int ext4_meta_trans_blocks(struct inode *inode, int nrblocks, int chunk)
 }
 
 /*
- * Calulate the total number of credits to reserve to fit
+ * Calculate the total number of credits to reserve to fit
  * the modification of a single pages into a single transaction,
  * which may include multiple chunks of block allocations.
  *
diff --git a/fs/ext4/mballoc.c b/fs/ext4/mballoc.c
index a5837a8..d8a16ee 100644
--- a/fs/ext4/mballoc.c
+++ b/fs/ext4/mballoc.c
@@ -92,7 +92,7 @@
  * between CPUs. It is possible to get scheduled at this point.
  *
  * The locality group prealloc space is used looking at whether we have
- * enough free space (pa_free) withing the prealloc space.
+ * enough free space (pa_free) within the prealloc space.
  *
  * If we can't allocate blocks via inode prealloc or/and locality group
  * prealloc then we look at the buddy cache. The buddy cache is represented
diff --git a/fs/ext4/migrate.c b/fs/ext4/migrate.c
index d1bafa5..92816b4 100644
--- a/fs/ext4/migrate.c
+++ b/fs/ext4/migrate.c
@@ -517,7 +517,7 @@ int ext4_ext_migrate(struct inode *inode)
 	 * start with one credit accounted for
 	 * superblock modification.
 	 *
-	 * For the tmp_inode we already have commited the
+	 * For the tmp_inode we already have committed the
 	 * trascation that created the inode. Later as and
 	 * when we add extents we extent the journal
 	 */
diff --git a/fs/ext4/super.c b/fs/ext4/super.c
index 22546ad..056474b 100644
--- a/fs/ext4/super.c
+++ b/fs/ext4/super.c
@@ -617,7 +617,7 @@ __acquires(bitlock)
 	 * filesystem will have already been marked read/only and the
 	 * journal has been aborted.  We return 1 as a hint to callers
 	 * who might what to use the return value from
-	 * ext4_grp_locked_error() to distinguish beween the
+	 * ext4_grp_locked_error() to distinguish between the
 	 * ERRORS_CONT and ERRORS_RO case, and perhaps return more
 	 * aggressively from the ext4 function in question, with a
 	 * more appropriate error code.
@@ -4624,7 +4624,7 @@ static int ext4_quota_off(struct super_block *sb, int type)
 
 /* Read data from quotafile - avoid pagecache and such because we cannot afford
  * acquiring the locks... As quota files are never truncated and quota code
- * itself serializes the operations (and noone else should touch the files)
+ * itself serializes the operations (and no one else should touch the files)
  * we don't have to be afraid of races */
 static ssize_t ext4_quota_read(struct super_block *sb, int type, char *data,
 			       size_t len, loff_t off)
diff --git a/fs/freevxfs/vxfs_fshead.c b/fs/freevxfs/vxfs_fshead.c
index 78948b4..c9a6a94 100644
--- a/fs/freevxfs/vxfs_fshead.c
+++ b/fs/freevxfs/vxfs_fshead.c
@@ -164,7 +164,7 @@ vxfs_read_fshead(struct super_block *sbp)
 		goto out_free_pfp;
 	}
 	if (!VXFS_ISILT(VXFS_INO(infp->vsi_stilist))) {
-		printk(KERN_ERR "vxfs: structual list inode is of wrong type (%x)\n",
+		printk(KERN_ERR "vxfs: structural list inode is of wrong type (%x)\n",
 				VXFS_INO(infp->vsi_stilist)->vii_mode & VXFS_TYPE_MASK); 
 		goto out_iput_stilist;
 	}
diff --git a/fs/freevxfs/vxfs_lookup.c b/fs/freevxfs/vxfs_lookup.c
index 6c5131d..3360f1e 100644
--- a/fs/freevxfs/vxfs_lookup.c
+++ b/fs/freevxfs/vxfs_lookup.c
@@ -162,7 +162,7 @@ vxfs_find_entry(struct inode *ip, struct dentry *dp, struct page **ppp)
 /**
  * vxfs_inode_by_name - find inode number for dentry
  * @dip:	directory to search in
- * @dp:		dentry we seach for
+ * @dp:		dentry we search for
  *
  * Description:
  *   vxfs_inode_by_name finds out the inode number of
diff --git a/fs/freevxfs/vxfs_olt.h b/fs/freevxfs/vxfs_olt.h
index d832429..b7b3af5 100644
--- a/fs/freevxfs/vxfs_olt.h
+++ b/fs/freevxfs/vxfs_olt.h
@@ -60,7 +60,7 @@ enum {
  *
  * The Object Location Table header is placed at the beginning of each
  * OLT extent.  It is used to fing certain filesystem-wide metadata, e.g.
- * the inital inode list, the fileset header or the device configuration.
+ * the initial inode list, the fileset header or the device configuration.
  */
 struct vxfs_olt {
 	u_int32_t	olt_magic;	/* magic number			*/
diff --git a/fs/fs-writeback.c b/fs/fs-writeback.c
index b5ed541..34591ee 100644
--- a/fs/fs-writeback.c
+++ b/fs/fs-writeback.c
@@ -144,7 +144,7 @@ __bdi_start_writeback(struct backing_dev_info *bdi, long nr_pages,
  *
  * Description:
  *   This does WB_SYNC_NONE opportunistic writeback. The IO is only
- *   started when this function returns, we make no guarentees on
+ *   started when this function returns, we make no guarantees on
  *   completion. Caller need not hold sb s_umount semaphore.
  *
  */
diff --git a/fs/fuse/file.c b/fs/fuse/file.c
index 6ea0073..82a6646 100644
--- a/fs/fuse/file.c
+++ b/fs/fuse/file.c
@@ -523,7 +523,7 @@ static int fuse_readpage(struct file *file, struct page *page)
 		goto out;
 
 	/*
-	 * Page writeback can extend beyond the liftime of the
+	 * Page writeback can extend beyond the lifetime of the
 	 * page-cache page, so make sure we read a properly synced
 	 * page.
 	 */
diff --git a/fs/gfs2/bmap.c b/fs/gfs2/bmap.c
index ef3dc4b..74add2d 100644
--- a/fs/gfs2/bmap.c
+++ b/fs/gfs2/bmap.c
@@ -1136,7 +1136,7 @@ void gfs2_trim_blocks(struct inode *inode)
  * earlier versions of GFS2 have a bug in the stuffed file reading
  * code which will result in a buffer overrun if the size is larger
  * than the max stuffed file size. In order to prevent this from
- * occuring, such files are unstuffed, but in other cases we can
+ * occurring, such files are unstuffed, but in other cases we can
  * just update the inode size directly.
  *
  * Returns: 0 on success, or -ve on error
diff --git a/fs/gfs2/glock.c b/fs/gfs2/glock.c
index e243131..f07643e 100644
--- a/fs/gfs2/glock.c
+++ b/fs/gfs2/glock.c
@@ -1123,7 +1123,7 @@ void gfs2_glock_dq_uninit(struct gfs2_holder *gh)
  * @number: the lock number
  * @glops: the glock operations for the type of glock
  * @state: the state to acquire the glock in
- * @flags: modifier flags for the aquisition
+ * @flags: modifier flags for the acquisition
  * @gh: the struct gfs2_holder
  *
  * Returns: errno
diff --git a/fs/gfs2/super.c b/fs/gfs2/super.c
index ec73ed7..a4e23d6 100644
--- a/fs/gfs2/super.c
+++ b/fs/gfs2/super.c
@@ -657,7 +657,7 @@ out:
  * @sdp: the file system
  *
  * This function flushes data and meta data for all machines by
- * aquiring the transaction log exclusively.  All journals are
+ * acquiring the transaction log exclusively.  All journals are
  * ensured to be in a clean state as well.
  *
  * Returns: errno
diff --git a/fs/jbd/commit.c b/fs/jbd/commit.c
index da871ee..69b1804 100644
--- a/fs/jbd/commit.c
+++ b/fs/jbd/commit.c
@@ -362,7 +362,7 @@ void journal_commit_transaction(journal_t *journal)
 	 * we do not require it to remember exactly which old buffers it
 	 * has reserved.  This is consistent with the existing behaviour
 	 * that multiple journal_get_write_access() calls to the same
-	 * buffer are perfectly permissable.
+	 * buffer are perfectly permissible.
 	 */
 	while (commit_transaction->t_reserved_list) {
 		jh = commit_transaction->t_reserved_list;
diff --git a/fs/jbd/journal.c b/fs/jbd/journal.c
index eb11601..b3713af 100644
--- a/fs/jbd/journal.c
+++ b/fs/jbd/journal.c
@@ -770,7 +770,7 @@ journal_t * journal_init_dev(struct block_device *bdev,
 	journal->j_wbufsize = n;
 	journal->j_wbuf = kmalloc(n * sizeof(struct buffer_head*), GFP_KERNEL);
 	if (!journal->j_wbuf) {
-		printk(KERN_ERR "%s: Cant allocate bhs for commit thread\n",
+		printk(KERN_ERR "%s: Can't allocate bhs for commit thread\n",
 			__func__);
 		goto out_err;
 	}
@@ -831,7 +831,7 @@ journal_t * journal_init_inode (struct inode *inode)
 	journal->j_wbufsize = n;
 	journal->j_wbuf = kmalloc(n * sizeof(struct buffer_head*), GFP_KERNEL);
 	if (!journal->j_wbuf) {
-		printk(KERN_ERR "%s: Cant allocate bhs for commit thread\n",
+		printk(KERN_ERR "%s: Can't allocate bhs for commit thread\n",
 			__func__);
 		goto out_err;
 	}
diff --git a/fs/jbd/revoke.c b/fs/jbd/revoke.c
index d290183..305a907 100644
--- a/fs/jbd/revoke.c
+++ b/fs/jbd/revoke.c
@@ -71,7 +71,7 @@
  * switching hash tables under them. For operations on the lists of entries in
  * the hash table j_revoke_lock is used.
  *
- * Finally, also replay code uses the hash tables but at this moment noone else
+ * Finally, also replay code uses the hash tables but at this moment no one else
  * can touch them (filesystem isn't mounted yet) and hence no locking is
  * needed.
  */
diff --git a/fs/jbd/transaction.c b/fs/jbd/transaction.c
index 5b2e4c3..60d2319 100644
--- a/fs/jbd/transaction.c
+++ b/fs/jbd/transaction.c
@@ -1392,7 +1392,7 @@ int journal_stop(handle_t *handle)
 	 * by 30x or more...
 	 *
 	 * We try and optimize the sleep time against what the underlying disk
-	 * can do, instead of having a static sleep time.  This is usefull for
+	 * can do, instead of having a static sleep time.  This is useful for
 	 * the case where our storage is so fast that it is more optimal to go
 	 * ahead and force a flush and wait for the transaction to be committed
 	 * than it is to wait for an arbitrary amount of time for new writers to
diff --git a/fs/jbd2/commit.c b/fs/jbd2/commit.c
index fa36d76..20af62f 100644
--- a/fs/jbd2/commit.c
+++ b/fs/jbd2/commit.c
@@ -403,7 +403,7 @@ void jbd2_journal_commit_transaction(journal_t *journal)
 	 * we do not require it to remember exactly which old buffers it
 	 * has reserved.  This is consistent with the existing behaviour
 	 * that multiple jbd2_journal_get_write_access() calls to the same
-	 * buffer are perfectly permissable.
+	 * buffer are perfectly permissible.
 	 */
 	while (commit_transaction->t_reserved_list) {
 		jh = commit_transaction->t_reserved_list;
diff --git a/fs/jbd2/journal.c b/fs/jbd2/journal.c
index 90407b8..aba8eba 100644
--- a/fs/jbd2/journal.c
+++ b/fs/jbd2/journal.c
@@ -917,7 +917,7 @@ journal_t * jbd2_journal_init_dev(struct block_device *bdev,
 	journal->j_wbufsize = n;
 	journal->j_wbuf = kmalloc(n * sizeof(struct buffer_head*), GFP_KERNEL);
 	if (!journal->j_wbuf) {
-		printk(KERN_ERR "%s: Cant allocate bhs for commit thread\n",
+		printk(KERN_ERR "%s: Can't allocate bhs for commit thread\n",
 			__func__);
 		goto out_err;
 	}
@@ -983,7 +983,7 @@ journal_t * jbd2_journal_init_inode (struct inode *inode)
 	journal->j_wbufsize = n;
 	journal->j_wbuf = kmalloc(n * sizeof(struct buffer_head*), GFP_KERNEL);
 	if (!journal->j_wbuf) {
-		printk(KERN_ERR "%s: Cant allocate bhs for commit thread\n",
+		printk(KERN_ERR "%s: Can't allocate bhs for commit thread\n",
 			__func__);
 		goto out_err;
 	}
diff --git a/fs/jbd2/revoke.c b/fs/jbd2/revoke.c
index 9ad321f..69fd935 100644
--- a/fs/jbd2/revoke.c
+++ b/fs/jbd2/revoke.c
@@ -71,7 +71,7 @@
  * switching hash tables under them. For operations on the lists of entries in
  * the hash table j_revoke_lock is used.
  *
- * Finally, also replay code uses the hash tables but at this moment noone else
+ * Finally, also replay code uses the hash tables but at this moment no one else
  * can touch them (filesystem isn't mounted yet) and hence no locking is
  * needed.
  */
diff --git a/fs/jbd2/transaction.c b/fs/jbd2/transaction.c
index 1d11910..05fa77a 100644
--- a/fs/jbd2/transaction.c
+++ b/fs/jbd2/transaction.c
@@ -1403,7 +1403,7 @@ int jbd2_journal_stop(handle_t *handle)
 
 	/*
 	 * Once we drop t_updates, if it goes to zero the transaction
-	 * could start commiting on us and eventually disappear.  So
+	 * could start committing on us and eventually disappear.  So
 	 * once we do this, we must not dereference transaction
 	 * pointer again.
 	 */
diff --git a/fs/jffs2/TODO b/fs/jffs2/TODO
index 5d3ea40..ca28964 100644
--- a/fs/jffs2/TODO
+++ b/fs/jffs2/TODO
@@ -11,7 +11,7 @@
  - checkpointing (do we need this? scan is quite fast)
  - make the scan code populate real inodes so read_inode just after 
 	mount doesn't have to read the flash twice for large files.
-	Make this a per-inode option, changable with chattr, so you can
+	Make this a per-inode option, changeable with chattr, so you can
 	decide which inodes should be in-core immediately after mount.
  - test, test, test
 
diff --git a/fs/jffs2/readinode.c b/fs/jffs2/readinode.c
index d32ee94..2ab1a0d 100644
--- a/fs/jffs2/readinode.c
+++ b/fs/jffs2/readinode.c
@@ -24,7 +24,7 @@
  *
  * Returns: 0 if the data CRC is correct;
  * 	    1 - if incorrect;
- *	    error code if an error occured.
+ *	    error code if an error occurred.
  */
 static int check_node_data(struct jffs2_sb_info *c, struct jffs2_tmp_dnode_info *tn)
 {
diff --git a/fs/jffs2/summary.c b/fs/jffs2/summary.c
index 800171d..e537fb0 100644
--- a/fs/jffs2/summary.c
+++ b/fs/jffs2/summary.c
@@ -121,7 +121,7 @@ int jffs2_sum_add_inode_mem(struct jffs2_summary *s, struct jffs2_raw_inode *ri,
 	temp->nodetype = ri->nodetype;
 	temp->inode = ri->ino;
 	temp->version = ri->version;
-	temp->offset = cpu_to_je32(ofs); /* relative offset from the begining of the jeb */
+	temp->offset = cpu_to_je32(ofs); /* relative offset from the beginning of the jeb */
 	temp->totlen = ri->totlen;
 	temp->next = NULL;
 
@@ -139,7 +139,7 @@ int jffs2_sum_add_dirent_mem(struct jffs2_summary *s, struct jffs2_raw_dirent *r
 
 	temp->nodetype = rd->nodetype;
 	temp->totlen = rd->totlen;
-	temp->offset = cpu_to_je32(ofs);	/* relative from the begining of the jeb */
+	temp->offset = cpu_to_je32(ofs);	/* relative from the beginning of the jeb */
 	temp->pino = rd->pino;
 	temp->version = rd->version;
 	temp->ino = rd->ino;
diff --git a/fs/jffs2/wbuf.c b/fs/jffs2/wbuf.c
index 07ee154..4515bea 100644
--- a/fs/jffs2/wbuf.c
+++ b/fs/jffs2/wbuf.c
@@ -1116,7 +1116,7 @@ int jffs2_write_nand_cleanmarker(struct jffs2_sb_info *c,
 
 /*
  * On NAND we try to mark this block bad. If the block was erased more
- * than MAX_ERASE_FAILURES we mark it finaly bad.
+ * than MAX_ERASE_FAILURES we mark it finally bad.
  * Don't care about failures. This block remains on the erase-pending
  * or badblock list as long as nobody manipulates the flash with
  * a bootloader or something like that.
diff --git a/fs/jfs/jfs_dmap.c b/fs/jfs/jfs_dmap.c
index c92ea3b..4496872 100644
--- a/fs/jfs/jfs_dmap.c
+++ b/fs/jfs/jfs_dmap.c
@@ -1649,7 +1649,7 @@ static int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno)
 		}
 
 		/* search the tree within the dmap control page for
-		 * sufficent free space.  if sufficient free space is found,
+		 * sufficient free space.  if sufficient free space is found,
 		 * dbFindLeaf() returns the index of the leaf at which
 		 * free space was found.
 		 */
@@ -2744,7 +2744,7 @@ static int dbJoin(dmtree_t * tp, int leafno, int newval)
 			/* check which (leafno or buddy) is the left buddy.
 			 * the left buddy gets to claim the blocks resulting
 			 * from the join while the right gets to claim none.
-			 * the left buddy is also eligable to participate in
+			 * the left buddy is also eligible to participate in
 			 * a join at the next higher level while the right
 			 * is not.
 			 *
diff --git a/fs/jfs/jfs_extent.c b/fs/jfs/jfs_extent.c
index 5d3bbd1..e5fe850 100644
--- a/fs/jfs/jfs_extent.c
+++ b/fs/jfs/jfs_extent.c
@@ -126,7 +126,7 @@ extAlloc(struct inode *ip, s64 xlen, s64 pno, xad_t * xp, bool abnr)
 
 	/* allocate the disk blocks for the extent.  initially, extBalloc()
 	 * will try to allocate disk blocks for the requested size (xlen).
-	 * if this fails (xlen contiguous free blocks not avaliable), it'll
+	 * if this fails (xlen contiguous free blocks not available), it'll
 	 * try to allocate a smaller number of blocks (producing a smaller
 	 * extent), with this smaller number of blocks consisting of the
 	 * requested number of blocks rounded down to the next smaller
@@ -481,7 +481,7 @@ int extFill(struct inode *ip, xad_t * xp)
  *
  *		initially, we will try to allocate disk blocks for the
  *		requested size (nblocks).  if this fails (nblocks
- *		contiguous free blocks not avaliable), we'll try to allocate
+ *		contiguous free blocks not available), we'll try to allocate
  *		a smaller number of blocks (producing a smaller extent), with
  *		this smaller number of blocks consisting of the requested
  *		number of blocks rounded down to the next smaller power of 2
@@ -575,7 +575,7 @@ extBalloc(struct inode *ip, s64 hint, s64 * nblocks, s64 * blkno)
  *		to a new set of blocks.  If moving the extent, we initially
  *		will try to allocate disk blocks for the requested size
  *		(newnblks).  if this fails (new contiguous free blocks not
- *		avaliable), we'll try to allocate a smaller number of
+ *		available), we'll try to allocate a smaller number of
  *		blocks (producing a smaller extent), with this smaller
  *		number of blocks consisting of the requested number of
  *		blocks rounded down to the next smaller power of 2
diff --git a/fs/jfs/jfs_imap.c b/fs/jfs/jfs_imap.c
index 3a09423..ed53a47 100644
--- a/fs/jfs/jfs_imap.c
+++ b/fs/jfs/jfs_imap.c
@@ -1069,7 +1069,7 @@ int diFree(struct inode *ip)
 		 */
 		if (iagp->nfreeexts == cpu_to_le32(EXTSPERIAG - 1)) {
 			/* in preparation for removing the iag from the
-			 * ag extent free list, read the iags preceeding
+			 * ag extent free list, read the iags preceding
 			 * and following the iag on the ag extent free
 			 * list.
 			 */
@@ -1095,7 +1095,7 @@ int diFree(struct inode *ip)
 		int inofreefwd = le32_to_cpu(iagp->inofreefwd);
 
 		/* in preparation for removing the iag from the
-		 * ag inode free list, read the iags preceeding
+		 * ag inode free list, read the iags preceding
 		 * and following the iag on the ag inode free
 		 * list.  before reading these iags, we must make
 		 * sure that we already don't have them in hand
@@ -1681,7 +1681,7 @@ diAllocAG(struct inomap * imap, int agno, bool dir, struct inode *ip)
 	 * try to allocate a new extent of free inodes.
 	 */
 	if (addext) {
-		/* if free space is not avaliable for this new extent, try
+		/* if free space is not available for this new extent, try
 		 * below to allocate a free and existing (already backed)
 		 * inode from the ag.
 		 */
@@ -2036,7 +2036,7 @@ static int diAllocBit(struct inomap * imap, struct iag * iagp, int ino)
 
 	/* check if this is the last free inode within the iag.
 	 * if so, it will have to be removed from the ag free
-	 * inode list, so get the iags preceeding and following
+	 * inode list, so get the iags preceding and following
 	 * it on the list.
 	 */
 	if (iagp->nfreeinos == cpu_to_le32(1)) {
@@ -2208,7 +2208,7 @@ static int diNewExt(struct inomap * imap, struct iag * iagp, int extno)
 
 	/* check if this is the last free extent within the
 	 * iag.  if so, the iag must be removed from the ag
-	 * free extent list, so get the iags preceeding and
+	 * free extent list, so get the iags preceding and
 	 * following the iag on this list.
 	 */
 	if (iagp->nfreeexts == cpu_to_le32(1)) {
@@ -2504,7 +2504,7 @@ diNewIAG(struct inomap * imap, int *iagnop, int agno, struct metapage ** mpp)
 		}
 
 
-		/* get the next avaliable iag number */
+		/* get the next available iag number */
 		iagno = imap->im_nextiag;
 
 		/* make sure that we have not exceeded the maximum inode
@@ -2615,7 +2615,7 @@ diNewIAG(struct inomap * imap, int *iagnop, int agno, struct metapage ** mpp)
 
 		duplicateIXtree(sb, blkno, xlen, &xaddr);
 
-		/* update the next avaliable iag number */
+		/* update the next available iag number */
 		imap->im_nextiag += 1;
 
 		/* Add the iag to the iag free list so we don't lose the iag
diff --git a/fs/jfs/jfs_logmgr.h b/fs/jfs/jfs_logmgr.h
index 9236bc4..e38c215 100644
--- a/fs/jfs/jfs_logmgr.h
+++ b/fs/jfs/jfs_logmgr.h
@@ -288,7 +288,7 @@ struct lrd {
 		/*
 		 *	SYNCPT: log sync point
 		 *
-		 * replay log upto syncpt address specified;
+		 * replay log up to syncpt address specified;
 		 */
 		struct {
 			__le32 sync;	/* 4: syncpt address (0 = here) */
diff --git a/fs/jfs/jfs_metapage.h b/fs/jfs/jfs_metapage.h
index d94f8d9..a78beda 100644
--- a/fs/jfs/jfs_metapage.h
+++ b/fs/jfs/jfs_metapage.h
@@ -75,7 +75,7 @@ extern void grab_metapage(struct metapage *);
 extern void force_metapage(struct metapage *);
 
 /*
- * hold_metapage and put_metapage are used in conjuction.  The page lock
+ * hold_metapage and put_metapage are used in conjunction.  The page lock
  * is not dropped between the two, so no other threads can get or release
  * the metapage
  */
diff --git a/fs/jfs/jfs_txnmgr.c b/fs/jfs/jfs_txnmgr.c
index 9466957..f6cc0c0 100644
--- a/fs/jfs/jfs_txnmgr.c
+++ b/fs/jfs/jfs_txnmgr.c
@@ -636,7 +636,7 @@ struct tlock *txLock(tid_t tid, struct inode *ip, struct metapage * mp,
 	 * the inode of the page and available to all anonymous
 	 * transactions until txCommit() time at which point
 	 * they are transferred to the transaction tlock list of
-	 * the commiting transaction of the inode)
+	 * the committing transaction of the inode)
 	 */
 	if (xtid == 0) {
 		tlck->tid = tid;
diff --git a/fs/jfs/resize.c b/fs/jfs/resize.c
index 1aba003..8ea5efb 100644
--- a/fs/jfs/resize.c
+++ b/fs/jfs/resize.c
@@ -57,7 +57,7 @@
  * 2. compute new FSCKSize from new LVSize;
  * 3. set new FSSize as MIN(FSSize, LVSize-(LogSize+FSCKSize)) where
  *    assert(new FSSize >= old FSSize),
- *    i.e., file system must not be shrinked;
+ *    i.e., file system must not be shrunk;
  */
 int jfs_extendfs(struct super_block *sb, s64 newLVSize, int newLogSize)
 {
@@ -182,7 +182,7 @@ int jfs_extendfs(struct super_block *sb, s64 newLVSize, int newLogSize)
 	 */
 	newFSSize = newLVSize - newLogSize - newFSCKSize;
 
-	/* file system cannot be shrinked */
+	/* file system cannot be shrunk */
 	if (newFSSize < bmp->db_mapsize) {
 		rc = -EINVAL;
 		goto out;
diff --git a/fs/jfs/super.c b/fs/jfs/super.c
index eeca48a..06c8a67 100644
--- a/fs/jfs/super.c
+++ b/fs/jfs/super.c
@@ -644,7 +644,7 @@ static int jfs_show_options(struct seq_file *seq, struct vfsmount *vfs)
 
 /* Read data from quotafile - avoid pagecache and such because we cannot afford
  * acquiring the locks... As quota files are never truncated and quota code
- * itself serializes the operations (and noone else should touch the files)
+ * itself serializes the operations (and no one else should touch the files)
  * we don't have to be afraid of races */
 static ssize_t jfs_quota_read(struct super_block *sb, int type, char *data,
 			      size_t len, loff_t off)
diff --git a/fs/logfs/dev_mtd.c b/fs/logfs/dev_mtd.c
index 7466e9d..339e17e 100644
--- a/fs/logfs/dev_mtd.c
+++ b/fs/logfs/dev_mtd.c
@@ -60,7 +60,7 @@ static int mtd_write(struct super_block *sb, loff_t ofs, size_t len, void *buf)
  * asynchronous properties.  So just to prevent the first implementor of such
  * a thing from breaking logfs in 2350, we do the usual pointless dance to
  * declare a completion variable and wait for completion before returning
- * from mtd_erase().  What an excercise in futility!
+ * from mtd_erase().  What an exercise in futility!
  */
 static void logfs_erase_callback(struct erase_info *ei)
 {
diff --git a/fs/logfs/dir.c b/fs/logfs/dir.c
index f9ddf0c..9ed89d1 100644
--- a/fs/logfs/dir.c
+++ b/fs/logfs/dir.c
@@ -92,7 +92,7 @@ static int beyond_eof(struct inode *inode, loff_t bix)
  * so short names (len <= 9) don't even occupy the complete 32bit name
  * space.  A prime >256 ensures short names quickly spread the 32bit
  * name space.  Add about 26 for the estimated amount of information
- * of each character and pick a prime nearby, preferrably a bit-sparse
+ * of each character and pick a prime nearby, preferably a bit-sparse
  * one.
  */
 static u32 hash_32(const char *s, int len, u32 seed)
diff --git a/fs/logfs/readwrite.c b/fs/logfs/readwrite.c
index ee99a9f..9e22085 100644
--- a/fs/logfs/readwrite.c
+++ b/fs/logfs/readwrite.c
@@ -1616,7 +1616,7 @@ int logfs_rewrite_block(struct inode *inode, u64 bix, u64 ofs,
 		err = logfs_write_buf(inode, page, flags);
 		if (!err && shrink_level(gc_level) == 0) {
 			/* Rewrite cannot mark the inode dirty but has to
-			 * write it immediatly.
+			 * write it immediately.
 			 * Q: Can't we just create an alias for the inode
 			 * instead?  And if not, why not?
 			 */
diff --git a/fs/mbcache.c b/fs/mbcache.c
index a25444ab..2f174be 100644
--- a/fs/mbcache.c
+++ b/fs/mbcache.c
@@ -542,7 +542,7 @@ __mb_cache_entry_find(struct list_head *l, struct list_head *head,
  * mb_cache_entry_find_first()
  *
  * Find the first cache entry on a given device with a certain key in
- * an additional index. Additonal matches can be found with
+ * an additional index. Additional matches can be found with
  * mb_cache_entry_find_next(). Returns NULL if no match was found. The
  * returned cache entry is locked for shared access ("multiple readers").
  *
diff --git a/fs/namei.c b/fs/namei.c
index 3cb616d..e6cd611 100644
--- a/fs/namei.c
+++ b/fs/namei.c
@@ -70,7 +70,7 @@
  * name indicated by the symlink. The old code always complained that the
  * name already exists, due to not following the symlink even if its target
  * is nonexistent.  The new semantics affects also mknod() and link() when
- * the name is a symlink pointing to a non-existant name.
+ * the name is a symlink pointing to a non-existent name.
  *
  * I don't know which semantics is the right one, since I have no access
  * to standards. But I found by trial that HP-UX 9.0 has the full "new"
diff --git a/fs/ncpfs/inode.c b/fs/ncpfs/inode.c
index 00a1d1c..0250e4c 100644
--- a/fs/ncpfs/inode.c
+++ b/fs/ncpfs/inode.c
@@ -596,7 +596,7 @@ static int ncp_fill_super(struct super_block *sb, void *raw_data, int silent)
 /*	server->priv.data = NULL;		*/
 
 	server->m = data;
-	/* Althought anything producing this is buggy, it happens
+	/* Although anything producing this is buggy, it happens
 	   now because of PATH_MAX changes.. */
 	if (server->m.time_out < 1) {
 		server->m.time_out = 10;
diff --git a/fs/nfs/callback_xdr.c b/fs/nfs/callback_xdr.c
index 14e0f93..00ecf62 100644
--- a/fs/nfs/callback_xdr.c
+++ b/fs/nfs/callback_xdr.c
@@ -241,7 +241,7 @@ static __be32 decode_layoutrecall_args(struct svc_rqst *rqstp,
 
 	args->cbl_layout_type = ntohl(*p++);
 	/* Depite the spec's xdr, iomode really belongs in the FILE switch,
-	 * as it is unuseable and ignored with the other types.
+	 * as it is unusable and ignored with the other types.
 	 */
 	iomode = ntohl(*p++);
 	args->cbl_layoutchanged = ntohl(*p++);
diff --git a/fs/nfs/file.c b/fs/nfs/file.c
index 3ac5bd6..2f093ed 100644
--- a/fs/nfs/file.c
+++ b/fs/nfs/file.c
@@ -301,7 +301,7 @@ nfs_file_mmap(struct file * file, struct vm_area_struct * vma)
  * disk, but it retrieves and clears ctx->error after synching, despite
  * the two being set at the same time in nfs_context_set_write_error().
  * This is because the former is used to notify the _next_ call to
- * nfs_file_write() that a write error occured, and hence cause it to
+ * nfs_file_write() that a write error occurred, and hence cause it to
  * fall back to doing a synchronous write.
  */
 static int
diff --git a/fs/nfs/namespace.c b/fs/nfs/namespace.c
index 9166fcb..89fc160 100644
--- a/fs/nfs/namespace.c
+++ b/fs/nfs/namespace.c
@@ -148,67 +148,64 @@ static rpc_authflavor_t nfs_find_best_sec(struct nfs4_secinfo_flavors *flavors,
 	return pseudoflavor;
 }
 
-static rpc_authflavor_t nfs_negotiate_security(const struct dentry *parent, const struct dentry *dentry)
+static int nfs_negotiate_security(const struct dentry *parent,
+				  const struct dentry *dentry,
+				  rpc_authflavor_t *flavor)
 {
-	int status = 0;
 	struct page *page;
 	struct nfs4_secinfo_flavors *flavors;
 	int (*secinfo)(struct inode *, const struct qstr *, struct nfs4_secinfo_flavors *);
-	rpc_authflavor_t flavor = RPC_AUTH_UNIX;
+	int ret = -EPERM;
 
 	secinfo = NFS_PROTO(parent->d_inode)->secinfo;
 	if (secinfo != NULL) {
 		page = alloc_page(GFP_KERNEL);
 		if (!page) {
-			status = -ENOMEM;
+			ret = -ENOMEM;
 			goto out;
 		}
 		flavors = page_address(page);
-		status = secinfo(parent->d_inode, &dentry->d_name, flavors);
-		flavor = nfs_find_best_sec(flavors, dentry->d_inode);
+		ret = secinfo(parent->d_inode, &dentry->d_name, flavors);
+		*flavor = nfs_find_best_sec(flavors, dentry->d_inode);
 		put_page(page);
 	}
 
-	return flavor;
-
 out:
-	status = -ENOMEM;
-	return status;
+	return ret;
 }
 
-static rpc_authflavor_t nfs_lookup_with_sec(struct nfs_server *server, struct dentry *parent,
-				     struct dentry *dentry, struct path *path,
-				     struct nfs_fh *fh, struct nfs_fattr *fattr)
+static int nfs_lookup_with_sec(struct nfs_server *server, struct dentry *parent,
+			       struct dentry *dentry, struct path *path,
+			       struct nfs_fh *fh, struct nfs_fattr *fattr,
+			       rpc_authflavor_t *flavor)
 {
-	rpc_authflavor_t flavor;
 	struct rpc_clnt *clone;
 	struct rpc_auth *auth;
 	int err;
 
-	flavor = nfs_negotiate_security(parent, path->dentry);
-	if (flavor < 0)
+	err = nfs_negotiate_security(parent, path->dentry, flavor);
+	if (err < 0)
 		goto out;
 	clone  = rpc_clone_client(server->client);
-	auth   = rpcauth_create(flavor, clone);
+	auth   = rpcauth_create(*flavor, clone);
 	if (!auth) {
-		flavor = -EIO;
+		err = -EIO;
 		goto out_shutdown;
 	}
 	err = server->nfs_client->rpc_ops->lookup(clone, parent->d_inode,
 						  &path->dentry->d_name,
 						  fh, fattr);
-	if (err < 0)
-		flavor = err;
 out_shutdown:
 	rpc_shutdown_client(clone);
 out:
-	return flavor;
+	return err;
 }
 #else /* CONFIG_NFS_V4 */
-static inline rpc_authflavor_t nfs_lookup_with_sec(struct nfs_server *server,
-				     struct dentry *parent, struct dentry *dentry,
-				     struct path *path, struct nfs_fh *fh,
-				     struct nfs_fattr *fattr)
+static inline int nfs_lookup_with_sec(struct nfs_server *server,
+				      struct dentry *parent, struct dentry *dentry,
+				      struct path *path, struct nfs_fh *fh,
+				      struct nfs_fattr *fattr,
+				      rpc_authflavor_t *flavor)
 {
 	return -EPERM;
 }
@@ -234,7 +231,7 @@ struct vfsmount *nfs_d_automount(struct path *path)
 	struct nfs_fh *fh = NULL;
 	struct nfs_fattr *fattr = NULL;
 	int err;
-	rpc_authflavor_t flavor = 1;
+	rpc_authflavor_t flavor = RPC_AUTH_UNIX;
 
 	dprintk("--> nfs_d_automount()\n");
 
@@ -255,13 +252,8 @@ struct vfsmount *nfs_d_automount(struct path *path)
 	err = server->nfs_client->rpc_ops->lookup(server->client, parent->d_inode,
 						  &path->dentry->d_name,
 						  fh, fattr);
-	if (err == -EPERM) {
-		flavor = nfs_lookup_with_sec(server, parent, path->dentry, path, fh, fattr);
-		if (flavor < 0)
-			err = flavor;
-		else
-			err = 0;
-	}
+	if (err == -EPERM && NFS_PROTO(parent->d_inode)->secinfo != NULL)
+		err = nfs_lookup_with_sec(server, parent, path->dentry, path, fh, fattr, &flavor);
 	dput(parent);
 	if (err != 0) {
 		mnt = ERR_PTR(err);
diff --git a/fs/nfs/nfs4filelayout.h b/fs/nfs/nfs4filelayout.h
index 085a354..7c44579 100644
--- a/fs/nfs/nfs4filelayout.h
+++ b/fs/nfs/nfs4filelayout.h
@@ -33,7 +33,7 @@
 #include "pnfs.h"
 
 /*
- * Field testing shows we need to support upto 4096 stripe indices.
+ * Field testing shows we need to support up to 4096 stripe indices.
  * We store each index as a u8 (u32 on the wire) to keep the memory footprint
  * reasonable. This in turn means we support a maximum of 256
  * RFC 5661 multipath_list4 structures.
diff --git a/fs/nfs/nfs4proc.c b/fs/nfs/nfs4proc.c
index dfd1e6d..9bf41ea 100644
--- a/fs/nfs/nfs4proc.c
+++ b/fs/nfs/nfs4proc.c
@@ -2204,8 +2204,6 @@ static int nfs4_lookup_root_sec(struct nfs_server *server, struct nfs_fh *fhandl
 		goto out;
 	}
 	ret = nfs4_lookup_root(server, fhandle, info);
-	if (ret < 0)
-		ret = -EAGAIN;
 out:
 	return ret;
 }
@@ -2226,7 +2224,7 @@ static int nfs4_proc_get_root(struct nfs_server *server, struct nfs_fh *fhandle,
 
 	for (i = 0; i < len; i++) {
 		status = nfs4_lookup_root_sec(server, fhandle, info, flav_array[i]);
-		if (status == 0)
+		if (status != -EPERM)
 			break;
 	}
 	if (status == 0)
diff --git a/fs/nfs_common/nfsacl.c b/fs/nfs_common/nfsacl.c
index ec0f277..6940439 100644
--- a/fs/nfs_common/nfsacl.c
+++ b/fs/nfs_common/nfsacl.c
@@ -173,7 +173,7 @@ xdr_nfsace_decode(struct xdr_array2_desc *desc, void *elem)
 				return -EINVAL;
 			break;
 		case ACL_MASK:
-			/* Solaris sometimes sets additonal bits in the mask */
+			/* Solaris sometimes sets additional bits in the mask */
 			entry->e_perm &= S_IRWXO;
 			break;
 		default:
diff --git a/fs/nfsd/nfs3xdr.c b/fs/nfsd/nfs3xdr.c
index 7e84a85..ad48fac 100644
--- a/fs/nfsd/nfs3xdr.c
+++ b/fs/nfsd/nfs3xdr.c
@@ -702,7 +702,7 @@ nfs3svc_encode_readres(struct svc_rqst *rqstp, __be32 *p,
 		*p++ = htonl(resp->eof);
 		*p++ = htonl(resp->count);	/* xdr opaque count */
 		xdr_ressize_check(rqstp, p);
-		/* now update rqstp->rq_res to reflect data aswell */
+		/* now update rqstp->rq_res to reflect data as well */
 		rqstp->rq_res.page_len = resp->count;
 		if (resp->count & 3) {
 			/* need to pad the tail */
diff --git a/fs/nfsd/nfs4state.c b/fs/nfsd/nfs4state.c
index fbde6f7..4b36ec3 100644
--- a/fs/nfsd/nfs4state.c
+++ b/fs/nfsd/nfs4state.c
@@ -3055,7 +3055,7 @@ check_special_stateids(svc_fh *current_fh, stateid_t *stateid, int flags)
 	if (ONE_STATEID(stateid) && (flags & RD_STATE))
 		return nfs_ok;
 	else if (locks_in_grace()) {
-		/* Answer in remaining cases depends on existance of
+		/* Answer in remaining cases depends on existence of
 		 * conflicting state; so we must wait out the grace period. */
 		return nfserr_grace;
 	} else if (flags & WR_STATE)
@@ -3675,7 +3675,7 @@ find_lockstateowner_str(struct inode *inode, clientid_t *clid,
 /*
  * Alloc a lock owner structure.
  * Called in nfsd4_lock - therefore, OPEN and OPEN_CONFIRM (if needed) has 
- * occured. 
+ * occurred. 
  *
  * strhashval = lock_ownerstr_hashval 
  */
diff --git a/fs/nfsd/nfsxdr.c b/fs/nfsd/nfsxdr.c
index 4ce005d..65ec595 100644
--- a/fs/nfsd/nfsxdr.c
+++ b/fs/nfsd/nfsxdr.c
@@ -451,7 +451,7 @@ nfssvc_encode_readres(struct svc_rqst *rqstp, __be32 *p,
 	*p++ = htonl(resp->count);
 	xdr_ressize_check(rqstp, p);
 
-	/* now update rqstp->rq_res to reflect data aswell */
+	/* now update rqstp->rq_res to reflect data as well */
 	rqstp->rq_res.page_len = resp->count;
 	if (resp->count & 3) {
 		/* need to pad the tail */
diff --git a/fs/notify/fanotify/fanotify_user.c b/fs/notify/fanotify/fanotify_user.c
index 6b1305d..9fde1c0 100644
--- a/fs/notify/fanotify/fanotify_user.c
+++ b/fs/notify/fanotify/fanotify_user.c
@@ -164,7 +164,7 @@ static int process_access_response(struct fsnotify_group *group,
 		 fd, response);
 	/*
 	 * make sure the response is valid, if invalid we do nothing and either
-	 * userspace can send a valid responce or we will clean it up after the
+	 * userspace can send a valid response or we will clean it up after the
 	 * timeout
 	 */
 	switch (response) {
diff --git a/fs/notify/inotify/inotify_fsnotify.c b/fs/notify/inotify/inotify_fsnotify.c
index 0348d0c..e3cbd74 100644
--- a/fs/notify/inotify/inotify_fsnotify.c
+++ b/fs/notify/inotify/inotify_fsnotify.c
@@ -194,7 +194,7 @@ static int idr_callback(int id, void *p, void *data)
 
 static void inotify_free_group_priv(struct fsnotify_group *group)
 {
-	/* ideally the idr is empty and we won't hit the BUG in teh callback */
+	/* ideally the idr is empty and we won't hit the BUG in the callback */
 	idr_for_each(&group->inotify_data.idr, idr_callback, group);
 	idr_remove_all(&group->inotify_data.idr);
 	idr_destroy(&group->inotify_data.idr);
diff --git a/fs/notify/mark.c b/fs/notify/mark.c
index 50c0085..252ab1f 100644
--- a/fs/notify/mark.c
+++ b/fs/notify/mark.c
@@ -24,7 +24,7 @@
  * referencing this object.  The object typically will live inside the kernel
  * with a refcnt of 2, one for each list it is on (i_list, g_list).  Any task
  * which can find this object holding the appropriete locks, can take a reference
- * and the object itself is guarenteed to survive until the reference is dropped.
+ * and the object itself is guaranteed to survive until the reference is dropped.
  *
  * LOCKING:
  * There are 3 spinlocks involved with fsnotify inode marks and they MUST
diff --git a/fs/ntfs/attrib.c b/fs/ntfs/attrib.c
index f5094ee..f14fde2 100644
--- a/fs/ntfs/attrib.c
+++ b/fs/ntfs/attrib.c
@@ -197,7 +197,7 @@ err_out:
 	} else if (ctx_needs_reset) {
 		/*
 		 * If there is no attribute list, restoring the search context
-		 * is acomplished simply by copying the saved context back over
+		 * is accomplished simply by copying the saved context back over
 		 * the caller supplied context.  If there is an attribute list,
 		 * things are more complicated as we need to deal with mapping
 		 * of mft records and resulting potential changes in pointers.
@@ -1181,7 +1181,7 @@ not_found:
  * for, i.e. if one wants to add the attribute to the mft record this is the
  * correct place to insert its attribute list entry into.
  *
- * When -errno != -ENOENT, an error occured during the lookup.  @ctx->attr is
+ * When -errno != -ENOENT, an error occurred during the lookup.  @ctx->attr is
  * then undefined and in particular you should not rely on it not changing.
  */
 int ntfs_attr_lookup(const ATTR_TYPE type, const ntfschar *name,
diff --git a/fs/ntfs/compress.c b/fs/ntfs/compress.c
index ef9ed85..ee4144c 100644
--- a/fs/ntfs/compress.c
+++ b/fs/ntfs/compress.c
@@ -501,7 +501,7 @@ int ntfs_read_compressed_block(struct page *page)
 	VCN start_vcn = (((s64)index << PAGE_CACHE_SHIFT) & ~cb_size_mask) >>
 			vol->cluster_size_bits;
 	/*
-	 * The first vcn after the last wanted vcn (minumum alignment is again
+	 * The first vcn after the last wanted vcn (minimum alignment is again
 	 * PAGE_CACHE_SIZE.
 	 */
 	VCN end_vcn = ((((s64)(index + 1UL) << PAGE_CACHE_SHIFT) + cb_size - 1)
diff --git a/fs/ntfs/inode.c b/fs/ntfs/inode.c
index 0b56c6b..c05d6dc 100644
--- a/fs/ntfs/inode.c
+++ b/fs/ntfs/inode.c
@@ -622,7 +622,7 @@ static int ntfs_read_locked_inode(struct inode *vi)
 	 */
 	/* Everyone gets all permissions. */
 	vi->i_mode |= S_IRWXUGO;
-	/* If read-only, noone gets write permissions. */
+	/* If read-only, no one gets write permissions. */
 	if (IS_RDONLY(vi))
 		vi->i_mode &= ~S_IWUGO;
 	if (m->flags & MFT_RECORD_IS_DIRECTORY) {
@@ -2529,7 +2529,7 @@ retry_truncate:
 		 * specifies that the behaviour is unspecified thus we do not
 		 * have to do anything.  This means that in our implementation
 		 * in the rare case that the file is mmap()ped and a write
-		 * occured into the mmap()ped region just beyond the file size
+		 * occurred into the mmap()ped region just beyond the file size
 		 * and writepage has not yet been called to write out the page
 		 * (which would clear the area beyond the file size) and we now
 		 * extend the file size to incorporate this dirty region
diff --git a/fs/ntfs/layout.h b/fs/ntfs/layout.h
index 8b2549f..faece71 100644
--- a/fs/ntfs/layout.h
+++ b/fs/ntfs/layout.h
@@ -286,7 +286,7 @@ typedef le16 MFT_RECORD_FLAGS;
  * fragmented. Volume free space includes the empty part of the mft zone and
  * when the volume's free 88% are used up, the mft zone is shrunk by a factor
  * of 2, thus making more space available for more files/data. This process is
- * repeated everytime there is no more free space except for the mft zone until
+ * repeated every time there is no more free space except for the mft zone until
  * there really is no more free space.
  */
 
@@ -1657,13 +1657,13 @@ typedef enum {
  *	pointed to by the Owner field was provided by a defaulting mechanism
  *	rather than explicitly provided by the original provider of the
  *	security descriptor.  This may affect the treatment of the SID with
- *	respect to inheritence of an owner.
+ *	respect to inheritance of an owner.
  *
  * SE_GROUP_DEFAULTED - This boolean flag, when set, indicates that the SID in
  *	the Group field was provided by a defaulting mechanism rather than
  *	explicitly provided by the original provider of the security
  *	descriptor.  This may affect the treatment of the SID with respect to
- *	inheritence of a primary group.
+ *	inheritance of a primary group.
  *
  * SE_DACL_PRESENT - This boolean flag, when set, indicates that the security
  *	descriptor contains a discretionary ACL.  If this flag is set and the
@@ -1674,7 +1674,7 @@ typedef enum {
  *	pointed to by the Dacl field was provided by a defaulting mechanism
  *	rather than explicitly provided by the original provider of the
  *	security descriptor.  This may affect the treatment of the ACL with
- *	respect to inheritence of an ACL.  This flag is ignored if the
+ *	respect to inheritance of an ACL.  This flag is ignored if the
  *	DaclPresent flag is not set.
  *
  * SE_SACL_PRESENT - This boolean flag, when set,  indicates that the security
@@ -1686,7 +1686,7 @@ typedef enum {
  *	pointed to by the Sacl field was provided by a defaulting mechanism
  *	rather than explicitly provided by the original provider of the
  *	security descriptor.  This may affect the treatment of the ACL with
- *	respect to inheritence of an ACL.  This flag is ignored if the
+ *	respect to inheritance of an ACL.  This flag is ignored if the
  *	SaclPresent flag is not set.
  *
  * SE_SELF_RELATIVE - This boolean flag, when set, indicates that the security
@@ -2283,7 +2283,7 @@ typedef struct {
 	//		   the key_length is zero, then the vcn immediately
 	//		   follows the INDEX_ENTRY_HEADER. Regardless of
 	//		   key_length, the address of the 8-byte boundary
-	//		   alligned vcn of INDEX_ENTRY{_HEADER} *ie is given by
+	//		   aligned vcn of INDEX_ENTRY{_HEADER} *ie is given by
 	//		   (char*)ie + le16_to_cpu(ie*)->length) - sizeof(VCN),
 	//		   where sizeof(VCN) can be hardcoded as 8 if wanted. */
 } __attribute__ ((__packed__)) INDEX_ENTRY;
diff --git a/fs/ntfs/logfile.c b/fs/ntfs/logfile.c
index 4dadcdf..c71de29 100644
--- a/fs/ntfs/logfile.c
+++ b/fs/ntfs/logfile.c
@@ -669,7 +669,7 @@ err_out:
  * of cases where we think that a volume is dirty when in fact it is clean.
  * This should only affect volumes that have not been shutdown cleanly but did
  * not have any pending, non-check-pointed i/o, i.e. they were completely idle
- * at least for the five seconds preceeding the unclean shutdown.
+ * at least for the five seconds preceding the unclean shutdown.
  *
  * This function assumes that the $LogFile journal has already been consistency
  * checked by a call to ntfs_check_logfile() and in particular if the $LogFile
diff --git a/fs/ntfs/logfile.h b/fs/ntfs/logfile.h
index b5a6f08..aa2b6ac 100644
--- a/fs/ntfs/logfile.h
+++ b/fs/ntfs/logfile.h
@@ -222,7 +222,7 @@ typedef struct {
 /* 24*/	sle64 file_size;	/* Usable byte size of the log file.  If the
 				   restart_area_offset + the offset of the
 				   file_size are > 510 then corruption has
-				   occured.  This is the very first check when
+				   occurred.  This is the very first check when
 				   starting with the restart_area as if it
 				   fails it means that some of the above values
 				   will be corrupted by the multi sector
diff --git a/fs/ntfs/mft.c b/fs/ntfs/mft.c
index 326e747..382857f 100644
--- a/fs/ntfs/mft.c
+++ b/fs/ntfs/mft.c
@@ -73,7 +73,7 @@ static inline MFT_RECORD *map_mft_record_page(ntfs_inode *ni)
 		if (index > end_index || (i_size & ~PAGE_CACHE_MASK) < ofs +
 				vol->mft_record_size) {
 			page = ERR_PTR(-ENOENT);
-			ntfs_error(vol->sb, "Attemt to read mft record 0x%lx, "
+			ntfs_error(vol->sb, "Attempt to read mft record 0x%lx, "
 					"which is beyond the end of the mft.  "
 					"This is probably a bug in the ntfs "
 					"driver.", ni->mft_no);
@@ -1442,7 +1442,7 @@ static int ntfs_mft_bitmap_extend_allocation_nolock(ntfs_volume *vol)
 		// Note: It will need to be a special mft record and if none of
 		// those are available it gets rather complicated...
 		ntfs_error(vol->sb, "Not enough space in this mft record to "
-				"accomodate extended mft bitmap attribute "
+				"accommodate extended mft bitmap attribute "
 				"extent.  Cannot handle this yet.");
 		ret = -EOPNOTSUPP;
 		goto undo_alloc;
@@ -1879,7 +1879,7 @@ static int ntfs_mft_data_extend_allocation_nolock(ntfs_volume *vol)
 		// and we would then need to update all references to this mft
 		// record appropriately.  This is rather complicated...
 		ntfs_error(vol->sb, "Not enough space in this mft record to "
-				"accomodate extended mft data attribute "
+				"accommodate extended mft data attribute "
 				"extent.  Cannot handle this yet.");
 		ret = -EOPNOTSUPP;
 		goto undo_alloc;
@@ -2357,7 +2357,7 @@ ntfs_inode *ntfs_mft_record_alloc(ntfs_volume *vol, const int mode,
 	}
 #ifdef DEBUG
 	read_lock_irqsave(&mftbmp_ni->size_lock, flags);
-	ntfs_debug("Status of mftbmp after initialized extention: "
+	ntfs_debug("Status of mftbmp after initialized extension: "
 			"allocated_size 0x%llx, data_size 0x%llx, "
 			"initialized_size 0x%llx.",
 			(long long)mftbmp_ni->allocated_size,
diff --git a/fs/ntfs/runlist.c b/fs/ntfs/runlist.c
index 56a9a6d..eac7d67 100644
--- a/fs/ntfs/runlist.c
+++ b/fs/ntfs/runlist.c
@@ -1243,7 +1243,7 @@ err_out:
  * write.
  *
  * This is used when building the mapping pairs array of a runlist to compress
- * a given logical cluster number (lcn) or a specific run length to the minumum
+ * a given logical cluster number (lcn) or a specific run length to the minimum
  * size possible.
  *
  * Return the number of bytes written on success.  On error, i.e. the
diff --git a/fs/ntfs/super.c b/fs/ntfs/super.c
index 29099a0..b52706d 100644
--- a/fs/ntfs/super.c
+++ b/fs/ntfs/super.c
@@ -458,7 +458,7 @@ static int ntfs_remount(struct super_block *sb, int *flags, char *opt)
 	 * the volume on boot and updates them.
 	 *
 	 * When remounting read-only, mark the volume clean if no volume errors
-	 * have occured.
+	 * have occurred.
 	 */
 	if ((sb->s_flags & MS_RDONLY) && !(*flags & MS_RDONLY)) {
 		static const char *es = ".  Cannot remount read-write.";
@@ -1269,7 +1269,7 @@ static int check_windows_hibernation_status(ntfs_volume *vol)
 					"hibernated on the volume.");
 			return 0;
 		}
-		/* A real error occured. */
+		/* A real error occurred. */
 		ntfs_error(vol->sb, "Failed to find inode number for "
 				"hiberfil.sys.");
 		return ret;
@@ -1370,7 +1370,7 @@ static bool load_and_init_quota(ntfs_volume *vol)
 			NVolSetQuotaOutOfDate(vol);
 			return true;
 		}
-		/* A real error occured. */
+		/* A real error occurred. */
 		ntfs_error(vol->sb, "Failed to find inode number for $Quota.");
 		return false;
 	}
@@ -1454,7 +1454,7 @@ not_enabled:
 			NVolSetUsnJrnlStamped(vol);
 			return true;
 		}
-		/* A real error occured. */
+		/* A real error occurred. */
 		ntfs_error(vol->sb, "Failed to find inode number for "
 				"$UsnJrnl.");
 		return false;
@@ -2292,7 +2292,7 @@ static void ntfs_put_super(struct super_block *sb)
 	ntfs_commit_inode(vol->mft_ino);
 
 	/*
-	 * If a read-write mount and no volume errors have occured, mark the
+	 * If a read-write mount and no volume errors have occurred, mark the
 	 * volume clean.  Also, re-commit all affected inodes.
 	 */
 	if (!(sb->s_flags & MS_RDONLY)) {
@@ -2496,7 +2496,7 @@ static s64 get_nr_free_clusters(ntfs_volume *vol)
 	if (vol->nr_clusters & 63)
 		nr_free += 64 - (vol->nr_clusters & 63);
 	up_read(&vol->lcnbmp_lock);
-	/* If errors occured we may well have gone below zero, fix this. */
+	/* If errors occurred we may well have gone below zero, fix this. */
 	if (nr_free < 0)
 		nr_free = 0;
 	ntfs_debug("Exiting.");
@@ -2561,7 +2561,7 @@ static unsigned long __get_nr_free_mft_records(ntfs_volume *vol,
 	}
 	ntfs_debug("Finished reading $MFT/$BITMAP, last index = 0x%lx.",
 			index - 1);
-	/* If errors occured we may well have gone below zero, fix this. */
+	/* If errors occurred we may well have gone below zero, fix this. */
 	if (nr_free < 0)
 		nr_free = 0;
 	ntfs_debug("Exiting.");
diff --git a/fs/ocfs2/alloc.c b/fs/ocfs2/alloc.c
index b27a0d8..48aa9c7 100644
--- a/fs/ocfs2/alloc.c
+++ b/fs/ocfs2/alloc.c
@@ -4519,7 +4519,7 @@ set_tail_append:
 }
 
 /*
- * Helper function called at the begining of an insert.
+ * Helper function called at the beginning of an insert.
  *
  * This computes a few things that are commonly used in the process of
  * inserting into the btree:
diff --git a/fs/ocfs2/aops.h b/fs/ocfs2/aops.h
index eceb456..75cf3ad 100644
--- a/fs/ocfs2/aops.h
+++ b/fs/ocfs2/aops.h
@@ -71,7 +71,7 @@ static inline void ocfs2_iocb_set_rw_locked(struct kiocb *iocb, int level)
 
 /*
  * Using a named enum representing lock types in terms of #N bit stored in
- * iocb->private, which is going to be used for communication bewteen
+ * iocb->private, which is going to be used for communication between
  * ocfs2_dio_end_io() and ocfs2_file_aio_write/read().
  */
 enum ocfs2_iocb_lock_bits {
diff --git a/fs/ocfs2/cluster/heartbeat.c b/fs/ocfs2/cluster/heartbeat.c
index 2461eb3..6437202 100644
--- a/fs/ocfs2/cluster/heartbeat.c
+++ b/fs/ocfs2/cluster/heartbeat.c
@@ -2275,7 +2275,7 @@ void o2hb_free_hb_set(struct config_group *group)
 	kfree(hs);
 }
 
-/* hb callback registration and issueing */
+/* hb callback registration and issuing */
 
 static struct o2hb_callback *hbcall_from_type(enum o2hb_callback_type type)
 {
diff --git a/fs/ocfs2/cluster/quorum.c b/fs/ocfs2/cluster/quorum.c
index a873667..8f9cea1 100644
--- a/fs/ocfs2/cluster/quorum.c
+++ b/fs/ocfs2/cluster/quorum.c
@@ -89,7 +89,7 @@ static void o2quo_fence_self(void)
 	};
 }
 
-/* Indicate that a timeout occured on a hearbeat region write. The
+/* Indicate that a timeout occurred on a hearbeat region write. The
  * other nodes in the cluster may consider us dead at that time so we
  * want to "fence" ourselves so that we don't scribble on the disk
  * after they think they've recovered us. This can't solve all
@@ -261,7 +261,7 @@ void o2quo_hb_still_up(u8 node)
 	spin_unlock(&qs->qs_lock);
 }
 
-/* This is analagous to hb_up.  as a node's connection comes up we delay the
+/* This is analogous to hb_up.  as a node's connection comes up we delay the
  * quorum decision until we see it heartbeating.  the hold will be droped in
  * hb_up or hb_down.  it might be perpetuated by con_err until hb_down.  if
  * it's already heartbeating we we might be dropping a hold that conn_up got.
diff --git a/fs/ocfs2/cluster/tcp.c b/fs/ocfs2/cluster/tcp.c
index ee04ff5..db5ee4b 100644
--- a/fs/ocfs2/cluster/tcp.c
+++ b/fs/ocfs2/cluster/tcp.c
@@ -565,7 +565,7 @@ static void o2net_set_nn_state(struct o2net_node *nn,
 	 * the work queue actually being up. */
 	if (!valid && o2net_wq) {
 		unsigned long delay;
-		/* delay if we're withing a RECONNECT_DELAY of the
+		/* delay if we're within a RECONNECT_DELAY of the
 		 * last attempt */
 		delay = (nn->nn_last_connect_attempt +
 			 msecs_to_jiffies(o2net_reconnect_delay()))
diff --git a/fs/ocfs2/dlm/dlmmaster.c b/fs/ocfs2/dlm/dlmmaster.c
index 9d67610..fede57e 100644
--- a/fs/ocfs2/dlm/dlmmaster.c
+++ b/fs/ocfs2/dlm/dlmmaster.c
@@ -808,7 +808,7 @@ lookup:
 				dlm_mle_detach_hb_events(dlm, mle);
 			dlm_put_mle(mle);
 			mle = NULL;
-			/* this is lame, but we cant wait on either
+			/* this is lame, but we can't wait on either
 			 * the mle or lockres waitqueue here */
 			if (mig)
 				msleep(100);
@@ -843,7 +843,7 @@ lookup:
 
 	/* finally add the lockres to its hash bucket */
 	__dlm_insert_lockres(dlm, res);
-	/* since this lockres is new it doesnt not require the spinlock */
+	/* since this lockres is new it doesn't not require the spinlock */
 	dlm_lockres_grab_inflight_ref_new(dlm, res);
 
 	/* if this node does not become the master make sure to drop
diff --git a/fs/ocfs2/inode.c b/fs/ocfs2/inode.c
index 177d3a6..b4c8bb6 100644
--- a/fs/ocfs2/inode.c
+++ b/fs/ocfs2/inode.c
@@ -835,7 +835,7 @@ static int ocfs2_inode_is_valid_to_delete(struct inode *inode)
 
 	/* If we have allowd wipe of this inode for another node, it
 	 * will be marked here so we can safely skip it. Recovery will
-	 * cleanup any inodes we might inadvertantly skip here. */
+	 * cleanup any inodes we might inadvertently skip here. */
 	if (oi->ip_flags & OCFS2_INODE_SKIP_DELETE)
 		goto bail_unlock;
 
@@ -917,7 +917,7 @@ static int ocfs2_query_inode_wipe(struct inode *inode,
 	 * the inode open lock in ocfs2_read_locked_inode(). When we
 	 * get to ->delete_inode(), each node tries to convert it's
 	 * lock to an exclusive. Trylocks are serialized by the inode
-	 * meta data lock. If the upconvert suceeds, we know the inode
+	 * meta data lock. If the upconvert succeeds, we know the inode
 	 * is no longer live and can be deleted.
 	 *
 	 * Though we call this with the meta data lock held, the
diff --git a/fs/ocfs2/journal.c b/fs/ocfs2/journal.c
index dcc2d93..b141a44 100644
--- a/fs/ocfs2/journal.c
+++ b/fs/ocfs2/journal.c
@@ -1368,7 +1368,7 @@ skip_recovery:
 		mlog_errno(status);
 
 	/* Now it is right time to recover quotas... We have to do this under
-	 * superblock lock so that noone can start using the slot (and crash)
+	 * superblock lock so that no one can start using the slot (and crash)
 	 * before we recover it */
 	for (i = 0; i < rm_quota_used; i++) {
 		qrec = ocfs2_begin_quota_recovery(osb, rm_quota[i]);
diff --git a/fs/ocfs2/journal.h b/fs/ocfs2/journal.h
index 6180da1..68cf2f6 100644
--- a/fs/ocfs2/journal.h
+++ b/fs/ocfs2/journal.h
@@ -215,7 +215,7 @@ static inline void ocfs2_checkpoint_inode(struct inode *inode)
 		/* WARNING: This only kicks off a single
 		 * checkpoint. If someone races you and adds more
 		 * metadata to the journal, you won't know, and will
-		 * wind up waiting *alot* longer than necessary. Right
+		 * wind up waiting *a lot* longer than necessary. Right
 		 * now we only use this in clear_inode so that's
 		 * OK. */
 		ocfs2_start_checkpoint(osb);
diff --git a/fs/ocfs2/namei.c b/fs/ocfs2/namei.c
index 28f2cc1..e5d738c 100644
--- a/fs/ocfs2/namei.c
+++ b/fs/ocfs2/namei.c
@@ -2128,7 +2128,7 @@ leave:
 }
 
 /**
- * ocfs2_prep_new_orphaned_file() - Prepare the orphan dir to recieve a newly
+ * ocfs2_prep_new_orphaned_file() - Prepare the orphan dir to receive a newly
  * allocated file. This is different from the typical 'add to orphan dir'
  * operation in that the inode does not yet exist. This is a problem because
  * the orphan dir stringifies the inode block number to come up with it's
diff --git a/fs/ocfs2/ocfs2_fs.h b/fs/ocfs2/ocfs2_fs.h
index bf2e776..b68f87a 100644
--- a/fs/ocfs2/ocfs2_fs.h
+++ b/fs/ocfs2/ocfs2_fs.h
@@ -441,7 +441,7 @@ static unsigned char ocfs2_type_by_mode[S_IFMT >> S_SHIFT] = {
 struct ocfs2_block_check {
 /*00*/	__le32 bc_crc32e;	/* 802.3 Ethernet II CRC32 */
 	__le16 bc_ecc;		/* Single-error-correction parity vector.
-				   This is a simple Hamming code dependant
+				   This is a simple Hamming code dependent
 				   on the blocksize.  OCFS2's maximum
 				   blocksize, 4K, requires 16 parity bits,
 				   so we fit in __le16. */
@@ -750,7 +750,7 @@ struct ocfs2_dinode {
 							  after an unclean
 							  shutdown */
 		} journal1;
-	} id1;				/* Inode type dependant 1 */
+	} id1;				/* Inode type dependent 1 */
 /*C0*/	union {
 		struct ocfs2_super_block	i_super;
 		struct ocfs2_local_alloc	i_lab;
diff --git a/fs/ocfs2/quota_global.c b/fs/ocfs2/quota_global.c
index 279aef6..92fcd57 100644
--- a/fs/ocfs2/quota_global.c
+++ b/fs/ocfs2/quota_global.c
@@ -556,7 +556,7 @@ int __ocfs2_sync_dquot(struct dquot *dquot, int freeing)
 	spin_unlock(&dq_data_lock);
 	err = ocfs2_qinfo_lock(info, freeing);
 	if (err < 0) {
-		mlog(ML_ERROR, "Failed to lock quota info, loosing quota write"
+		mlog(ML_ERROR, "Failed to lock quota info, losing quota write"
 			       " (type=%d, id=%u)\n", dquot->dq_type,
 			       (unsigned)dquot->dq_id);
 		goto out;
diff --git a/fs/ocfs2/reservations.h b/fs/ocfs2/reservations.h
index 1e49cc2..42c2b80 100644
--- a/fs/ocfs2/reservations.h
+++ b/fs/ocfs2/reservations.h
@@ -29,7 +29,7 @@
 struct ocfs2_alloc_reservation {
 	struct rb_node	r_node;
 
-	unsigned int	r_start;	/* Begining of current window */
+	unsigned int	r_start;	/* Beginning of current window */
 	unsigned int	r_len;		/* Length of the window */
 
 	unsigned int	r_last_len;	/* Length of most recent alloc */
diff --git a/fs/ocfs2/stackglue.h b/fs/ocfs2/stackglue.h
index 8ce7398..1ec56fd 100644
--- a/fs/ocfs2/stackglue.h
+++ b/fs/ocfs2/stackglue.h
@@ -126,7 +126,7 @@ struct ocfs2_stack_operations {
 	 *
 	 * ->connect() must not return until it is guaranteed that
 	 *
-	 *  - Node down notifications for the filesystem will be recieved
+	 *  - Node down notifications for the filesystem will be received
 	 *    and passed to conn->cc_recovery_handler().
 	 *  - Locking requests for the filesystem will be processed.
 	 */
diff --git a/fs/ocfs2/suballoc.c b/fs/ocfs2/suballoc.c
index ab6e206..ba5d97e 100644
--- a/fs/ocfs2/suballoc.c
+++ b/fs/ocfs2/suballoc.c
@@ -1511,7 +1511,7 @@ static int ocfs2_cluster_group_search(struct inode *inode,
 		max_bits = le16_to_cpu(gd->bg_bits);
 
 		/* Tail groups in cluster bitmaps which aren't cpg
-		 * aligned are prone to partial extention by a failed
+		 * aligned are prone to partial extension by a failed
 		 * fs resize. If the file system resize never got to
 		 * update the dinode cluster count, then we don't want
 		 * to trust any clusters past it, regardless of what
@@ -2459,7 +2459,7 @@ static int _ocfs2_free_suballoc_bits(handle_t *handle,
 	/* The alloc_bh comes from ocfs2_free_dinode() or
 	 * ocfs2_free_clusters().  The callers have all locked the
 	 * allocator and gotten alloc_bh from the lock call.  This
-	 * validates the dinode buffer.  Any corruption that has happended
+	 * validates the dinode buffer.  Any corruption that has happened
 	 * is a code bug. */
 	BUG_ON(!OCFS2_IS_VALID_DINODE(fe));
 	BUG_ON((count + start_bit) > ocfs2_bits_per_group(cl));
diff --git a/fs/ocfs2/super.c b/fs/ocfs2/super.c
index 69fa11b..5a521c7 100644
--- a/fs/ocfs2/super.c
+++ b/fs/ocfs2/super.c
@@ -78,7 +78,7 @@ static struct kmem_cache *ocfs2_inode_cachep = NULL;
 struct kmem_cache *ocfs2_dquot_cachep;
 struct kmem_cache *ocfs2_qf_chunk_cachep;
 
-/* OCFS2 needs to schedule several differnt types of work which
+/* OCFS2 needs to schedule several different types of work which
  * require cluster locking, disk I/O, recovery waits, etc. Since these
  * types of work tend to be heavy we avoid using the kernel events
  * workqueue and schedule on our own. */
diff --git a/fs/ocfs2/xattr.c b/fs/ocfs2/xattr.c
index 57a215d..81ecf9c 100644
--- a/fs/ocfs2/xattr.c
+++ b/fs/ocfs2/xattr.c
@@ -3554,7 +3554,7 @@ int ocfs2_xattr_set(struct inode *inode,
 	down_write(&OCFS2_I(inode)->ip_xattr_sem);
 	/*
 	 * Scan inode and external block to find the same name
-	 * extended attribute and collect search infomation.
+	 * extended attribute and collect search information.
 	 */
 	ret = ocfs2_xattr_ibody_find(inode, name_index, name, &xis);
 	if (ret)
@@ -3578,7 +3578,7 @@ int ocfs2_xattr_set(struct inode *inode,
 			goto cleanup;
 	}
 
-	/* Check whether the value is refcounted and do some prepartion. */
+	/* Check whether the value is refcounted and do some preparation. */
 	if (OCFS2_I(inode)->ip_dyn_features & OCFS2_HAS_REFCOUNT_FL &&
 	    (!xis.not_found || !xbs.not_found)) {
 		ret = ocfs2_prepare_refcount_xattr(inode, di, &xi,
diff --git a/fs/partitions/check.c b/fs/partitions/check.c
index ac54697..d545e97 100644
--- a/fs/partitions/check.c
+++ b/fs/partitions/check.c
@@ -500,7 +500,7 @@ struct hd_struct *add_partition(struct gendisk *disk, int partno,
 	/* everything is up and running, commence */
 	rcu_assign_pointer(ptbl->part[partno], p);
 
-	/* suppress uevent if the disk supresses it */
+	/* suppress uevent if the disk suppresses it */
 	if (!dev_get_uevent_suppress(ddev))
 		kobject_uevent(&pdev->kobj, KOBJ_ADD);
 
@@ -585,7 +585,7 @@ rescan:
 	/*
 	 * If any partition code tried to read beyond EOD, try
 	 * unlocking native capacity even if partition table is
-	 * sucessfully read as we could be missing some partitions.
+	 * successfully read as we could be missing some partitions.
 	 */
 	if (state->access_beyond_eod) {
 		printk(KERN_WARNING
diff --git a/fs/proc/base.c b/fs/proc/base.c
index 5a670c1..dd6628d 100644
--- a/fs/proc/base.c
+++ b/fs/proc/base.c
@@ -220,7 +220,7 @@ static struct mm_struct *__check_mem_permission(struct task_struct *task)
 	}
 
 	/*
-	 * Noone else is allowed.
+	 * No one else is allowed.
 	 */
 	mmput(mm);
 	return ERR_PTR(-EPERM);
diff --git a/fs/pstore/Kconfig b/fs/pstore/Kconfig
index 867d0ac..8007ae7 100644
--- a/fs/pstore/Kconfig
+++ b/fs/pstore/Kconfig
@@ -1,5 +1,5 @@
 config PSTORE
-	bool "Persistant store support"
+	bool "Persistent store support"
 	default n
 	help
 	   This option enables generic access to platform level
diff --git a/fs/quota/dquot.c b/fs/quota/dquot.c
index fcc8ae7..d3c032f 100644
--- a/fs/quota/dquot.c
+++ b/fs/quota/dquot.c
@@ -442,7 +442,7 @@ EXPORT_SYMBOL(dquot_acquire);
  */
 int dquot_commit(struct dquot *dquot)
 {
-	int ret = 0, ret2 = 0;
+	int ret = 0;
 	struct quota_info *dqopt = sb_dqopt(dquot->dq_sb);
 
 	mutex_lock(&dqopt->dqio_mutex);
@@ -454,15 +454,10 @@ int dquot_commit(struct dquot *dquot)
 	spin_unlock(&dq_list_lock);
 	/* Inactive dquot can be only if there was error during read/init
 	 * => we have better not writing it */
-	if (test_bit(DQ_ACTIVE_B, &dquot->dq_flags)) {
+	if (test_bit(DQ_ACTIVE_B, &dquot->dq_flags))
 		ret = dqopt->ops[dquot->dq_type]->commit_dqblk(dquot);
-		if (info_dirty(&dqopt->info[dquot->dq_type])) {
-			ret2 = dqopt->ops[dquot->dq_type]->write_file_info(
-						dquot->dq_sb, dquot->dq_type);
-		}
-		if (ret >= 0)
-			ret = ret2;
-	}
+	else
+		ret = -EIO;
 out_sem:
 	mutex_unlock(&dqopt->dqio_mutex);
 	return ret;
@@ -956,7 +951,7 @@ static inline int dqput_blocks(struct dquot *dquot)
 
 /*
  * Remove references to dquots from inode and add dquot to list for freeing
- * if we have the last referece to dquot
+ * if we have the last reference to dquot
  * We can't race with anybody because we hold dqptr_sem for writing...
  */
 static int remove_inode_dquot_ref(struct inode *inode, int type,
diff --git a/fs/reiserfs/journal.c b/fs/reiserfs/journal.c
index c77514b..c5e82ec 100644
--- a/fs/reiserfs/journal.c
+++ b/fs/reiserfs/journal.c
@@ -1,7 +1,7 @@
 /*
 ** Write ahead logging implementation copyright Chris Mason 2000
 **
-** The background commits make this code very interelated, and
+** The background commits make this code very interrelated, and
 ** overly complex.  I need to rethink things a bit....The major players:
 **
 ** journal_begin -- call with the number of blocks you expect to log.
@@ -2725,7 +2725,7 @@ int journal_init(struct super_block *sb, const char *j_dev_name,
 						 REISERFS_DISK_OFFSET_IN_BYTES /
 						 sb->s_blocksize + 2);
 
-	/* Sanity check to see is the standard journal fitting withing first bitmap
+	/* Sanity check to see is the standard journal fitting within first bitmap
 	   (actual for small blocksizes) */
 	if (!SB_ONDISK_JOURNAL_DEVICE(sb) &&
 	    (SB_JOURNAL_1st_RESERVED_BLOCK(sb) +
diff --git a/fs/reiserfs/lock.c b/fs/reiserfs/lock.c
index b87aa2c..7df1ce4 100644
--- a/fs/reiserfs/lock.c
+++ b/fs/reiserfs/lock.c
@@ -15,7 +15,7 @@
  * for this mutex, no need for a system wide mutex facility.
  *
  * Also this lock is often released before a call that could block because
- * reiserfs performances were partialy based on the release while schedule()
+ * reiserfs performances were partially based on the release while schedule()
  * property of the Bkl.
  */
 void reiserfs_write_lock(struct super_block *s)
diff --git a/fs/reiserfs/super.c b/fs/reiserfs/super.c
index 0aab04f..b216ff6 100644
--- a/fs/reiserfs/super.c
+++ b/fs/reiserfs/super.c
@@ -393,7 +393,7 @@ void add_save_link(struct reiserfs_transaction_handle *th,
 	/* body of "save" link */
 	link = INODE_PKEY(inode)->k_dir_id;
 
-	/* put "save" link inot tree, don't charge quota to anyone */
+	/* put "save" link into tree, don't charge quota to anyone */
 	retval =
 	    reiserfs_insert_item(th, &path, &key, &ih, NULL, (char *)&link);
 	if (retval) {
@@ -2104,7 +2104,7 @@ out:
 
 /* Read data from quotafile - avoid pagecache and such because we cannot afford
  * acquiring the locks... As quota files are never truncated and quota code
- * itself serializes the operations (and noone else should touch the files)
+ * itself serializes the operations (and no one else should touch the files)
  * we don't have to be afraid of races */
 static ssize_t reiserfs_quota_read(struct super_block *sb, int type, char *data,
 				   size_t len, loff_t off)
diff --git a/fs/reiserfs/xattr.c b/fs/reiserfs/xattr.c
index 5c11ca8..47d2a44 100644
--- a/fs/reiserfs/xattr.c
+++ b/fs/reiserfs/xattr.c
@@ -396,7 +396,7 @@ static struct page *reiserfs_get_page(struct inode *dir, size_t n)
 	struct address_space *mapping = dir->i_mapping;
 	struct page *page;
 	/* We can deadlock if we try to free dentries,
-	   and an unlink/rmdir has just occured - GFP_NOFS avoids this */
+	   and an unlink/rmdir has just occurred - GFP_NOFS avoids this */
 	mapping_set_gfp_mask(mapping, GFP_NOFS);
 	page = read_mapping_page(mapping, n >> PAGE_CACHE_SHIFT, NULL);
 	if (!IS_ERR(page)) {
diff --git a/fs/squashfs/cache.c b/fs/squashfs/cache.c
index 26b15ae..c37b520 100644
--- a/fs/squashfs/cache.c
+++ b/fs/squashfs/cache.c
@@ -104,7 +104,7 @@ struct squashfs_cache_entry *squashfs_cache_get(struct super_block *sb,
 			entry = &cache->entry[i];
 
 			/*
-			 * Initialise choosen cache entry, and fill it in from
+			 * Initialise chosen cache entry, and fill it in from
 			 * disk.
 			 */
 			cache->unused--;
@@ -286,7 +286,7 @@ cleanup:
 
 
 /*
- * Copy upto length bytes from cache entry to buffer starting at offset bytes
+ * Copy up to length bytes from cache entry to buffer starting at offset bytes
  * into the cache entry.  If there's not length bytes then copy the number of
  * bytes available.  In all cases return the number of bytes copied.
  */
diff --git a/fs/ubifs/Kconfig b/fs/ubifs/Kconfig
index d744090..f8b0160 100644
--- a/fs/ubifs/Kconfig
+++ b/fs/ubifs/Kconfig
@@ -47,7 +47,7 @@ config UBIFS_FS_DEBUG
 	bool "Enable debugging support"
 	depends on UBIFS_FS
 	select DEBUG_FS
-	select KALLSYMS_ALL
+	select KALLSYMS
 	help
 	  This option enables UBIFS debugging support. It makes sure various
 	  assertions, self-checks, debugging messages and test modes are compiled
diff --git a/fs/ubifs/budget.c b/fs/ubifs/budget.c
index c8ff0d1..8b3a7da 100644
--- a/fs/ubifs/budget.c
+++ b/fs/ubifs/budget.c
@@ -147,7 +147,7 @@ static int make_free_space(struct ubifs_info *c)
 		if (liab2 < liab1)
 			return -EAGAIN;
 
-		dbg_budg("new liability %lld (not shrinked)", liab2);
+		dbg_budg("new liability %lld (not shrunk)", liab2);
 
 		/* Liability did not shrink again, try GC */
 		dbg_budg("Run GC");
diff --git a/fs/ubifs/commit.c b/fs/ubifs/commit.c
index b148fbc..1bd01de 100644
--- a/fs/ubifs/commit.c
+++ b/fs/ubifs/commit.c
@@ -577,7 +577,7 @@ int dbg_check_old_index(struct ubifs_info *c, struct ubifs_zbranch *zroot)
 	size_t sz;
 
 	if (!(ubifs_chk_flags & UBIFS_CHK_OLD_IDX))
-		goto out;
+		return 0;
 
 	INIT_LIST_HEAD(&list);
 
diff --git a/fs/ubifs/debug.c b/fs/ubifs/debug.c
index f25a733..004d374 100644
--- a/fs/ubifs/debug.c
+++ b/fs/ubifs/debug.c
@@ -972,11 +972,39 @@ void dbg_dump_index(struct ubifs_info *c)
 void dbg_save_space_info(struct ubifs_info *c)
 {
 	struct ubifs_debug_info *d = c->dbg;
-
-	ubifs_get_lp_stats(c, &d->saved_lst);
+	int freeable_cnt;
 
 	spin_lock(&c->space_lock);
+	memcpy(&d->saved_lst, &c->lst, sizeof(struct ubifs_lp_stats));
+
+	/*
+	 * We use a dirty hack here and zero out @c->freeable_cnt, because it
+	 * affects the free space calculations, and UBIFS might not know about
+	 * all freeable eraseblocks. Indeed, we know about freeable eraseblocks
+	 * only when we read their lprops, and we do this only lazily, upon the
+	 * need. So at any given point of time @c->freeable_cnt might be not
+	 * exactly accurate.
+	 *
+	 * Just one example about the issue we hit when we did not zero
+	 * @c->freeable_cnt.
+	 * 1. The file-system is mounted R/O, c->freeable_cnt is %0. We save the
+	 *    amount of free space in @d->saved_free
+	 * 2. We re-mount R/W, which makes UBIFS to read the "lsave"
+	 *    information from flash, where we cache LEBs from various
+	 *    categories ('ubifs_remount_fs()' -> 'ubifs_lpt_init()'
+	 *    -> 'lpt_init_wr()' -> 'read_lsave()' -> 'ubifs_lpt_lookup()'
+	 *    -> 'ubifs_get_pnode()' -> 'update_cats()'
+	 *    -> 'ubifs_add_to_cat()').
+	 * 3. Lsave contains a freeable eraseblock, and @c->freeable_cnt
+	 *    becomes %1.
+	 * 4. We calculate the amount of free space when the re-mount is
+	 *    finished in 'dbg_check_space_info()' and it does not match
+	 *    @d->saved_free.
+	 */
+	freeable_cnt = c->freeable_cnt;
+	c->freeable_cnt = 0;
 	d->saved_free = ubifs_get_free_space_nolock(c);
+	c->freeable_cnt = freeable_cnt;
 	spin_unlock(&c->space_lock);
 }
 
@@ -993,12 +1021,15 @@ int dbg_check_space_info(struct ubifs_info *c)
 {
 	struct ubifs_debug_info *d = c->dbg;
 	struct ubifs_lp_stats lst;
-	long long avail, free;
+	long long free;
+	int freeable_cnt;
 
 	spin_lock(&c->space_lock);
-	avail = ubifs_calc_available(c, c->min_idx_lebs);
+	freeable_cnt = c->freeable_cnt;
+	c->freeable_cnt = 0;
+	free = ubifs_get_free_space_nolock(c);
+	c->freeable_cnt = freeable_cnt;
 	spin_unlock(&c->space_lock);
-	free = ubifs_get_free_space(c);
 
 	if (free != d->saved_free) {
 		ubifs_err("free space changed from %lld to %lld",
@@ -2806,40 +2837,38 @@ int dbg_debugfs_init_fs(struct ubifs_info *c)
 	struct ubifs_debug_info *d = c->dbg;
 
 	sprintf(d->dfs_dir_name, "ubi%d_%d", c->vi.ubi_num, c->vi.vol_id);
-	d->dfs_dir = debugfs_create_dir(d->dfs_dir_name, dfs_rootdir);
-	if (IS_ERR(d->dfs_dir)) {
-		err = PTR_ERR(d->dfs_dir);
-		ubifs_err("cannot create \"%s\" debugfs directory, error %d\n",
-			  d->dfs_dir_name, err);
+	fname = d->dfs_dir_name;
+	dent = debugfs_create_dir(fname, dfs_rootdir);
+	if (IS_ERR_OR_NULL(dent))
 		goto out;
-	}
+	d->dfs_dir = dent;
 
 	fname = "dump_lprops";
 	dent = debugfs_create_file(fname, S_IWUSR, d->dfs_dir, c, &dfs_fops);
-	if (IS_ERR(dent))
+	if (IS_ERR_OR_NULL(dent))
 		goto out_remove;
 	d->dfs_dump_lprops = dent;
 
 	fname = "dump_budg";
 	dent = debugfs_create_file(fname, S_IWUSR, d->dfs_dir, c, &dfs_fops);
-	if (IS_ERR(dent))
+	if (IS_ERR_OR_NULL(dent))
 		goto out_remove;
 	d->dfs_dump_budg = dent;
 
 	fname = "dump_tnc";
 	dent = debugfs_create_file(fname, S_IWUSR, d->dfs_dir, c, &dfs_fops);
-	if (IS_ERR(dent))
+	if (IS_ERR_OR_NULL(dent))
 		goto out_remove;
 	d->dfs_dump_tnc = dent;
 
 	return 0;
 
 out_remove:
-	err = PTR_ERR(dent);
-	ubifs_err("cannot create \"%s\" debugfs directory, error %d\n",
-		  fname, err);
 	debugfs_remove_recursive(d->dfs_dir);
 out:
+	err = dent ? PTR_ERR(dent) : -ENODEV;
+	ubifs_err("cannot create \"%s\" debugfs directory, error %d\n",
+		  fname, err);
 	return err;
 }
 
diff --git a/fs/ubifs/lpt.c b/fs/ubifs/lpt.c
index 72775d3..ef5155e 100644
--- a/fs/ubifs/lpt.c
+++ b/fs/ubifs/lpt.c
@@ -1270,10 +1270,9 @@ static int read_pnode(struct ubifs_info *c, struct ubifs_nnode *parent, int iip)
 	lnum = branch->lnum;
 	offs = branch->offs;
 	pnode = kzalloc(sizeof(struct ubifs_pnode), GFP_NOFS);
-	if (!pnode) {
-		err = -ENOMEM;
-		goto out;
-	}
+	if (!pnode)
+		return -ENOMEM;
+
 	if (lnum == 0) {
 		/*
 		 * This pnode was not written which just means that the LEB
diff --git a/fs/ubifs/super.c b/fs/ubifs/super.c
index 6ddd997..c75f613 100644
--- a/fs/ubifs/super.c
+++ b/fs/ubifs/super.c
@@ -1568,6 +1568,7 @@ static int ubifs_remount_rw(struct ubifs_info *c)
 	mutex_lock(&c->umount_mutex);
 	dbg_save_space_info(c);
 	c->remounting_rw = 1;
+	c->ro_mount = 0;
 
 	err = check_free_space(c);
 	if (err)
@@ -1676,13 +1677,13 @@ static int ubifs_remount_rw(struct ubifs_info *c)
 	}
 
 	dbg_gen("re-mounted read-write");
-	c->ro_mount = 0;
 	c->remounting_rw = 0;
 	err = dbg_check_space_info(c);
 	mutex_unlock(&c->umount_mutex);
 	return err;
 
 out:
+	c->ro_mount = 1;
 	vfree(c->orph_buf);
 	c->orph_buf = NULL;
 	if (c->bgt) {
diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index 27a4bab..e765743 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -78,7 +78,7 @@ static int ufs_block_to_path(struct inode *inode, sector_t i_block, sector_t off
 
 /*
  * Returns the location of the fragment from
- * the begining of the filesystem.
+ * the beginning of the filesystem.
  */
 
 static u64 ufs_frag_map(struct inode *inode, sector_t frag, bool needs_lock)
diff --git a/fs/ufs/super.c b/fs/ufs/super.c
index 7693d62..3915ade 100644
--- a/fs/ufs/super.c
+++ b/fs/ufs/super.c
@@ -483,9 +483,9 @@ static int ufs_parse_options (char * options, unsigned * mount_options)
 }
 
 /*
- * Diffrent types of UFS hold fs_cstotal in different
- * places, and use diffrent data structure for it.
- * To make things simplier we just copy fs_cstotal to ufs_sb_private_info
+ * Different types of UFS hold fs_cstotal in different
+ * places, and use different data structure for it.
+ * To make things simpler we just copy fs_cstotal to ufs_sb_private_info
  */
 static void ufs_setup_cstotal(struct super_block *sb)
 {
diff --git a/fs/xfs/linux-2.6/xfs_aops.c b/fs/xfs/linux-2.6/xfs_aops.c
index 52dbd14..79ce38b 100644
--- a/fs/xfs/linux-2.6/xfs_aops.c
+++ b/fs/xfs/linux-2.6/xfs_aops.c
@@ -1295,7 +1295,7 @@ xfs_get_blocks_direct(
  * If the private argument is non-NULL __xfs_get_blocks signals us that we
  * need to issue a transaction to convert the range from unwritten to written
  * extents.  In case this is regular synchronous I/O we just call xfs_end_io
- * to do this and we are done.  But in case this was a successfull AIO
+ * to do this and we are done.  But in case this was a successful AIO
  * request this handler is called from interrupt context, from which we
  * can't start transactions.  In that case offload the I/O completion to
  * the workqueues we also use for buffered I/O completion.
diff --git a/fs/xfs/linux-2.6/xfs_buf.c b/fs/xfs/linux-2.6/xfs_buf.c
index 596bb2c..5ea4020 100644
--- a/fs/xfs/linux-2.6/xfs_buf.c
+++ b/fs/xfs/linux-2.6/xfs_buf.c
@@ -120,7 +120,7 @@ xfs_buf_lru_add(
  * The unlocked check is safe here because it only occurs when there are not
  * b_lru_ref counts left on the inode under the pag->pag_buf_lock. it is there
  * to optimise the shrinker removing the buffer from the LRU and calling
- * xfs_buf_free(). i.e. it removes an unneccessary round trip on the
+ * xfs_buf_free(). i.e. it removes an unnecessary round trip on the
  * bt_lru_lock.
  */
 STATIC void
@@ -380,7 +380,7 @@ out_free_pages:
 }
 
 /*
- *	Map buffer into kernel address-space if nessecary.
+ *	Map buffer into kernel address-space if necessary.
  */
 STATIC int
 _xfs_buf_map_pages(
diff --git a/fs/xfs/linux-2.6/xfs_file.c b/fs/xfs/linux-2.6/xfs_file.c
index 52aadfb..f4213ba 100644
--- a/fs/xfs/linux-2.6/xfs_file.c
+++ b/fs/xfs/linux-2.6/xfs_file.c
@@ -381,7 +381,7 @@ xfs_aio_write_isize_update(
 
 /*
  * If this was a direct or synchronous I/O that failed (such as ENOSPC) then
- * part of the I/O may have been written to disk before the error occured.  In
+ * part of the I/O may have been written to disk before the error occurred.  In
  * this case the on-disk file size may have been adjusted beyond the in-memory
  * file size and now needs to be truncated back.
  */
diff --git a/fs/xfs/linux-2.6/xfs_iops.c b/fs/xfs/linux-2.6/xfs_iops.c
index 9ff7fc6..dd21784 100644
--- a/fs/xfs/linux-2.6/xfs_iops.c
+++ b/fs/xfs/linux-2.6/xfs_iops.c
@@ -70,7 +70,7 @@ xfs_synchronize_times(
 
 /*
  * If the linux inode is valid, mark it dirty.
- * Used when commiting a dirty inode into a transaction so that
+ * Used when committing a dirty inode into a transaction so that
  * the inode will get written back by the linux code
  */
 void
diff --git a/fs/xfs/linux-2.6/xfs_sync.c b/fs/xfs/linux-2.6/xfs_sync.c
index 594cd82..9cf35a6 100644
--- a/fs/xfs/linux-2.6/xfs_sync.c
+++ b/fs/xfs/linux-2.6/xfs_sync.c
@@ -401,7 +401,7 @@ xfs_quiesce_fs(
 /*
  * Second stage of a quiesce. The data is already synced, now we have to take
  * care of the metadata. New transactions are already blocked, so we need to
- * wait for any remaining transactions to drain out before proceding.
+ * wait for any remaining transactions to drain out before proceeding.
  */
 void
 xfs_quiesce_attr(
diff --git a/fs/xfs/quota/xfs_dquot.c b/fs/xfs/quota/xfs_dquot.c
index 7e24164..6fa2146 100644
--- a/fs/xfs/quota/xfs_dquot.c
+++ b/fs/xfs/quota/xfs_dquot.c
@@ -600,7 +600,7 @@ xfs_qm_dqread(
 
 	/*
 	 * Reservation counters are defined as reservation plus current usage
-	 * to avoid having to add everytime.
+	 * to avoid having to add every time.
 	 */
 	dqp->q_res_bcount = be64_to_cpu(ddqp->d_bcount);
 	dqp->q_res_icount = be64_to_cpu(ddqp->d_icount);
diff --git a/fs/xfs/quota/xfs_qm_bhv.c b/fs/xfs/quota/xfs_qm_bhv.c
index 774d7ec..a0a829a 100644
--- a/fs/xfs/quota/xfs_qm_bhv.c
+++ b/fs/xfs/quota/xfs_qm_bhv.c
@@ -134,7 +134,7 @@ xfs_qm_newmount(
 		 */
 		if (quotaondisk && !XFS_QM_NEED_QUOTACHECK(mp)) {
 			/*
-			 * If an error occured, qm_mount_quotas code
+			 * If an error occurred, qm_mount_quotas code
 			 * has already disabled quotas. So, just finish
 			 * mounting, and get on with the boring life
 			 * without disk quotas.
diff --git a/fs/xfs/quota/xfs_qm_syscalls.c b/fs/xfs/quota/xfs_qm_syscalls.c
index c82f067..0d62a07 100644
--- a/fs/xfs/quota/xfs_qm_syscalls.c
+++ b/fs/xfs/quota/xfs_qm_syscalls.c
@@ -172,7 +172,7 @@ xfs_qm_scall_quotaoff(
 	/*
 	 * Next we make the changes in the quota flag in the mount struct.
 	 * This isn't protected by a particular lock directly, because we
-	 * don't want to take a mrlock everytime we depend on quotas being on.
+	 * don't want to take a mrlock every time we depend on quotas being on.
 	 */
 	mp->m_qflags &= ~(flags);
 
@@ -354,7 +354,7 @@ xfs_qm_scall_quotaon(
 		return XFS_ERROR(EINVAL);
 	}
 	/*
-	 * If everything's upto-date incore, then don't waste time.
+	 * If everything's up to-date incore, then don't waste time.
 	 */
 	if ((mp->m_qflags & flags) == flags)
 		return XFS_ERROR(EEXIST);
diff --git a/fs/xfs/xfs_buf_item.c b/fs/xfs/xfs_buf_item.c
index e5413d9..7b7e005 100644
--- a/fs/xfs/xfs_buf_item.c
+++ b/fs/xfs/xfs_buf_item.c
@@ -992,7 +992,7 @@ xfs_buf_iodone_callbacks(
 	lasttarg = XFS_BUF_TARGET(bp);
 
 	/*
-	 * If the write was asynchronous then noone will be looking for the
+	 * If the write was asynchronous then no one will be looking for the
 	 * error.  Clear the error state and write the buffer out again.
 	 *
 	 * During sync or umount we'll write all pending buffers again
diff --git a/fs/xfs/xfs_inode.c b/fs/xfs/xfs_inode.c
index 742c833..a37480a 100644
--- a/fs/xfs/xfs_inode.c
+++ b/fs/xfs/xfs_inode.c
@@ -2789,7 +2789,7 @@ xfs_iflush(
 
 	/*
 	 * We can't flush the inode until it is unpinned, so wait for it if we
-	 * are allowed to block.  We know noone new can pin it, because we are
+	 * are allowed to block.  We know no one new can pin it, because we are
 	 * holding the inode lock shared and you need to hold it exclusively to
 	 * pin the inode.
 	 *
diff --git a/fs/xfs/xfs_inode.h b/fs/xfs/xfs_inode.h
index f753200..ff4e2a3 100644
--- a/fs/xfs/xfs_inode.h
+++ b/fs/xfs/xfs_inode.h
@@ -111,7 +111,7 @@ struct xfs_imap {
  * Generally, we do not want to hold the i_rlock while holding the
  * i_ilock. Hierarchy is i_iolock followed by i_rlock.
  *
- * xfs_iptr_t contains all the inode fields upto and including the
+ * xfs_iptr_t contains all the inode fields up to and including the
  * i_mnext and i_mprev fields, it is used as a marker in the inode
  * chain off the mount structure by xfs_sync calls.
  */
@@ -336,7 +336,7 @@ xfs_iflags_test_and_clear(xfs_inode_t *ip, unsigned short flags)
 
 /*
  * Project quota id helpers (previously projid was 16bit only
- * and using two 16bit values to hold new 32bit projid was choosen
+ * and using two 16bit values to hold new 32bit projid was chosen
  * to retain compatibility with "old" filesystems).
  */
 static inline prid_t
diff --git a/fs/xfs/xfs_log_priv.h b/fs/xfs/xfs_log_priv.h
index 15dbf1f..ffae692 100644
--- a/fs/xfs/xfs_log_priv.h
+++ b/fs/xfs/xfs_log_priv.h
@@ -570,7 +570,7 @@ int	xlog_write(struct log *log, struct xfs_log_vec *log_vector,
  * When we crack an atomic LSN, we sample it first so that the value will not
  * change while we are cracking it into the component values. This means we
  * will always get consistent component values to work from. This should always
- * be used to smaple and crack LSNs taht are stored and updated in atomic
+ * be used to sample and crack LSNs that are stored and updated in atomic
  * variables.
  */
 static inline void
diff --git a/fs/xfs/xfs_log_recover.c b/fs/xfs/xfs_log_recover.c
index 0c4a561..5cc464a 100644
--- a/fs/xfs/xfs_log_recover.c
+++ b/fs/xfs/xfs_log_recover.c
@@ -101,7 +101,7 @@ xlog_get_bp(
 	/*
 	 * We do log I/O in units of log sectors (a power-of-2
 	 * multiple of the basic block size), so we round up the
-	 * requested size to acommodate the basic blocks required
+	 * requested size to accommodate the basic blocks required
 	 * for complete log sectors.
 	 *
 	 * In addition, the buffer may be used for a non-sector-
@@ -112,7 +112,7 @@ xlog_get_bp(
 	 * an issue.  Nor will this be a problem if the log I/O is
 	 * done in basic blocks (sector size 1).  But otherwise we
 	 * extend the buffer by one extra log sector to ensure
-	 * there's space to accomodate this possiblility.
+	 * there's space to accommodate this possibility.
 	 */
 	if (nbblks > 1 && log->l_sectBBsize > 1)
 		nbblks += log->l_sectBBsize;
diff --git a/fs/xfs/xfs_trans_inode.c b/fs/xfs/xfs_trans_inode.c
index 16084d8..048b0c6 100644
--- a/fs/xfs/xfs_trans_inode.c
+++ b/fs/xfs/xfs_trans_inode.c
@@ -81,7 +81,7 @@ xfs_trans_ijoin(
  *
  *
  * Grabs a reference to the inode which will be dropped when the transaction
- * is commited.  The inode will also be unlocked at that point.  The inode
+ * is committed.  The inode will also be unlocked at that point.  The inode
  * must be locked, and it cannot be associated with any transaction.
  */
 void
diff --git a/fs/xfs/xfs_vnodeops.c b/fs/xfs/xfs_vnodeops.c
index c48b421..b7a5fe7 100644
--- a/fs/xfs/xfs_vnodeops.c
+++ b/fs/xfs/xfs_vnodeops.c
@@ -953,7 +953,7 @@ xfs_release(
 		 * If we previously truncated this file and removed old data
 		 * in the process, we want to initiate "early" writeout on
 		 * the last close.  This is an attempt to combat the notorious
-		 * NULL files problem which is particularly noticable from a
+		 * NULL files problem which is particularly noticeable from a
 		 * truncate down, buffered (re-)write (delalloc), followed by
 		 * a crash.  What we are effectively doing here is
 		 * significantly reducing the time window where we'd otherwise
@@ -982,7 +982,7 @@ xfs_release(
 		 *
 		 * Further, check if the inode is being opened, written and
 		 * closed frequently and we have delayed allocation blocks
-		 * oustanding (e.g. streaming writes from the NFS server),
+		 * outstanding (e.g. streaming writes from the NFS server),
 		 * truncating the blocks past EOF will cause fragmentation to
 		 * occur.
 		 *
diff --git a/include/acpi/actbl.h b/include/acpi/actbl.h
index d41c948..f138028 100644
--- a/include/acpi/actbl.h
+++ b/include/acpi/actbl.h
@@ -290,7 +290,7 @@ struct acpi_table_fadt {
 #define ACPI_FADT_APIC_CLUSTER      (1<<18)	/* 18: [V4] All local APICs must use cluster model (ACPI 3.0) */
 #define ACPI_FADT_APIC_PHYSICAL     (1<<19)	/* 19: [V4] All local x_aPICs must use physical dest mode (ACPI 3.0) */
 
-/* Values for preferred_profile (Prefered Power Management Profiles) */
+/* Values for preferred_profile (Preferred Power Management Profiles) */
 
 enum acpi_prefered_pm_profiles {
 	PM_UNSPECIFIED = 0,
diff --git a/include/asm-generic/siginfo.h b/include/asm-generic/siginfo.h
index 942d30b..0dd4e87 100644
--- a/include/asm-generic/siginfo.h
+++ b/include/asm-generic/siginfo.h
@@ -192,7 +192,7 @@ typedef struct siginfo {
  * SIGBUS si_codes
  */
 #define BUS_ADRALN	(__SI_FAULT|1)	/* invalid address alignment */
-#define BUS_ADRERR	(__SI_FAULT|2)	/* non-existant physical address */
+#define BUS_ADRERR	(__SI_FAULT|2)	/* non-existent physical address */
 #define BUS_OBJERR	(__SI_FAULT|3)	/* object specific hardware error */
 /* hardware memory error consumed on a machine check: action required */
 #define BUS_MCEERR_AR	(__SI_FAULT|4)
diff --git a/include/asm-generic/vmlinux.lds.h b/include/asm-generic/vmlinux.lds.h
index 32c45e5..bd297a2 100644
--- a/include/asm-generic/vmlinux.lds.h
+++ b/include/asm-generic/vmlinux.lds.h
@@ -773,7 +773,7 @@
  * the sections that has this restriction (or similar)
  * is located before the ones requiring PAGE_SIZE alignment.
  * NOSAVE_DATA starts and ends with a PAGE_SIZE alignment which
- * matches the requirment of PAGE_ALIGNED_DATA.
+ * matches the requirement of PAGE_ALIGNED_DATA.
  *
  * use 0 as page_align if page_aligned data is not used */
 #define RW_DATA_SECTION(cacheline, pagealigned, inittask)		\
diff --git a/include/drm/drmP.h b/include/drm/drmP.h
index ad5770f..202424d 100644
--- a/include/drm/drmP.h
+++ b/include/drm/drmP.h
@@ -95,7 +95,7 @@ struct drm_device;
  * drm_core, drm_driver, drm_kms
  * drm_core level can be used in the generic drm code. For example:
  * 	drm_ioctl, drm_mm, drm_memory
- * The macro definiton of DRM_DEBUG is used.
+ * The macro definition of DRM_DEBUG is used.
  * 	DRM_DEBUG(fmt, args...)
  * 	The debug info by using the DRM_DEBUG can be obtained by adding
  * 	the boot option of "drm.debug=1".
@@ -808,7 +808,7 @@ struct drm_driver {
 	 *
 	 * \return Flags, or'ed together as follows:
 	 *
-	 * DRM_SCANOUTPOS_VALID = Query successfull.
+	 * DRM_SCANOUTPOS_VALID = Query successful.
 	 * DRM_SCANOUTPOS_INVBL = Inside vblank.
 	 * DRM_SCANOUTPOS_ACCURATE = Returned position is accurate. A lack of
 	 * this flag means that returned position may be offset by a constant
diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index aaec097..d94684b 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -65,7 +65,7 @@ enum drm_mode_status {
     MODE_H_ILLEGAL,	/* mode has illegal horizontal timings */
     MODE_V_ILLEGAL,	/* mode has illegal horizontal timings */
     MODE_BAD_WIDTH,	/* requires an unsupported linepitch */
-    MODE_NOMODE,	/* no mode with a maching name */
+    MODE_NOMODE,	/* no mode with a matching name */
     MODE_NO_INTERLACE,	/* interlaced mode not supported */
     MODE_NO_DBLESCAN,	/* doublescan mode not supported */
     MODE_NO_VSCAN,	/* multiscan mode not supported */
@@ -321,7 +321,7 @@ struct drm_crtc_funcs {
 
 	/*
 	 * Flip to the given framebuffer.  This implements the page
-	 * flip ioctl descibed in drm_mode.h, specifically, the
+	 * flip ioctl described in drm_mode.h, specifically, the
 	 * implementation must return immediately and block all
 	 * rendering to the current fb until the flip has completed.
 	 * If userspace set the event flag in the ioctl, the event
diff --git a/include/drm/drm_mm.h b/include/drm/drm_mm.h
index b1e7809..c2f93a8 100644
--- a/include/drm/drm_mm.h
+++ b/include/drm/drm_mm.h
@@ -56,7 +56,7 @@ struct drm_mm_node {
 };
 
 struct drm_mm {
-	/* List of all memory nodes that immediatly preceed a free hole. */
+	/* List of all memory nodes that immediately precede a free hole. */
 	struct list_head hole_stack;
 	/* head_node.node_list is the list of all memory nodes, ordered
 	 * according to the (increasing) start address of the memory node. */
diff --git a/include/drm/drm_mode.h b/include/drm/drm_mode.h
index ae6b7a3..c4961ea 100644
--- a/include/drm/drm_mode.h
+++ b/include/drm/drm_mode.h
@@ -277,7 +277,7 @@ struct drm_mode_mode_cmd {
 #define DRM_MODE_CURSOR_MOVE	(1<<1)
 
 /*
- * depending on the value in flags diffrent members are used.
+ * depending on the value in flags different members are used.
  *
  * CURSOR_BO uses
  *    crtc
diff --git a/include/drm/mga_drm.h b/include/drm/mga_drm.h
index c16097f..fca8170 100644
--- a/include/drm/mga_drm.h
+++ b/include/drm/mga_drm.h
@@ -107,7 +107,7 @@
  */
 #define MGA_NR_SAREA_CLIPRECTS	8
 
-/* 2 heaps (1 for card, 1 for agp), each divided into upto 128
+/* 2 heaps (1 for card, 1 for agp), each divided into up to 128
  * regions, subject to a minimum region size of (1<<16) == 64k.
  *
  * Clients may subdivide regions internally, but when sharing between
diff --git a/include/drm/radeon_drm.h b/include/drm/radeon_drm.h
index 3dec41c..3bce1a4 100644
--- a/include/drm/radeon_drm.h
+++ b/include/drm/radeon_drm.h
@@ -641,7 +641,7 @@ typedef struct drm_radeon_vertex2 {
 } drm_radeon_vertex2_t;
 
 /* v1.3 - obsoletes drm_radeon_vertex2
- *      - allows arbitarily large cliprect list
+ *      - allows arbitrarily large cliprect list
  *      - allows updating of tcl packet, vector and scalar state
  *      - allows memory-efficient description of state updates
  *      - allows state to be emitted without a primitive
diff --git a/include/drm/savage_drm.h b/include/drm/savage_drm.h
index 4863cf6..818d49b 100644
--- a/include/drm/savage_drm.h
+++ b/include/drm/savage_drm.h
@@ -29,7 +29,7 @@
 #ifndef __SAVAGE_SAREA_DEFINES__
 #define __SAVAGE_SAREA_DEFINES__
 
-/* 2 heaps (1 for card, 1 for agp), each divided into upto 128
+/* 2 heaps (1 for card, 1 for agp), each divided into up to 128
  * regions, subject to a minimum region size of (1<<16) == 64k.
  *
  * Clients may subdivide regions internally, but when sharing between
diff --git a/include/drm/ttm/ttm_bo_api.h b/include/drm/ttm/ttm_bo_api.h
index a6bd117..62a0e4c 100644
--- a/include/drm/ttm/ttm_bo_api.h
+++ b/include/drm/ttm/ttm_bo_api.h
@@ -50,10 +50,10 @@ struct drm_mm_node;
  *
  * @fpfn:		first valid page frame number to put the object
  * @lpfn:		last valid page frame number to put the object
- * @num_placement:	number of prefered placements
- * @placement:		prefered placements
- * @num_busy_placement:	number of prefered placements when need to evict buffer
- * @busy_placement:	prefered placements when need to evict buffer
+ * @num_placement:	number of preferred placements
+ * @placement:		preferred placements
+ * @num_busy_placement:	number of preferred placements when need to evict buffer
+ * @busy_placement:	preferred placements when need to evict buffer
  *
  * Structure indicating the placement you request for an object.
  */
diff --git a/include/drm/ttm/ttm_bo_driver.h b/include/drm/ttm/ttm_bo_driver.h
index 960b521..09af2d7 100644
--- a/include/drm/ttm/ttm_bo_driver.h
+++ b/include/drm/ttm/ttm_bo_driver.h
@@ -223,9 +223,9 @@ struct ttm_mem_type_manager_func {
 	 * @mem::mm_node should be set to a non-null value, and
 	 * @mem::start should be set to a value identifying the beginning
 	 * of the range allocated, and the function should return zero.
-	 * If the memory region accomodate the buffer object, @mem::mm_node
+	 * If the memory region accommodate the buffer object, @mem::mm_node
 	 * should be set to NULL, and the function should return 0.
-	 * If a system error occured, preventing the request to be fulfilled,
+	 * If a system error occurred, preventing the request to be fulfilled,
 	 * the function should return a negative error code.
 	 *
 	 * Note that @mem::mm_node will only be dereferenced by
@@ -841,7 +841,7 @@ extern void ttm_mem_io_unlock(struct ttm_mem_type_manager *man);
  * different order, either by will or as a result of a buffer being evicted
  * to make room for a buffer already reserved. (Buffers are reserved before
  * they are evicted). The following algorithm prevents such deadlocks from
- * occuring:
+ * occurring:
  * 1) Buffers are reserved with the lru spinlock held. Upon successful
  * reservation they are removed from the lru list. This stops a reserved buffer
  * from being evicted. However the lru spinlock is released between the time
diff --git a/include/drm/vmwgfx_drm.h b/include/drm/vmwgfx_drm.h
index 650e6bf..5c36432 100644
--- a/include/drm/vmwgfx_drm.h
+++ b/include/drm/vmwgfx_drm.h
@@ -592,7 +592,7 @@ struct drm_vmw_stream_arg {
 /**
  * DRM_VMW_UPDATE_LAYOUT - Update layout
  *
- * Updates the prefered modes and connection status for connectors. The
+ * Updates the preferred modes and connection status for connectors. The
  * command conisits of one drm_vmw_update_layout_arg pointing out a array
  * of num_outputs drm_vmw_rect's.
  */
diff --git a/include/linux/amba/clcd.h b/include/linux/amba/clcd.h
index 24d26ef..e82e3ee 100644
--- a/include/linux/amba/clcd.h
+++ b/include/linux/amba/clcd.h
@@ -136,7 +136,7 @@ struct clcd_board {
 	int	(*check)(struct clcd_fb *fb, struct fb_var_screeninfo *var);
 
 	/*
-	 * Compulsary.  Decode fb->fb.var into regs->*.  In the case of
+	 * Compulsory.  Decode fb->fb.var into regs->*.  In the case of
 	 * fixed timing, set regs->* to the register values required.
 	 */
 	void	(*decode)(struct clcd_fb *fb, struct clcd_regs *regs);
diff --git a/include/linux/amba/mmci.h b/include/linux/amba/mmci.h
index f602270..2111481 100644
--- a/include/linux/amba/mmci.h
+++ b/include/linux/amba/mmci.h
@@ -30,15 +30,15 @@ struct dma_chan;
  * @cd_invert: true if the gpio_cd pin value is active low
  * @capabilities: the capabilities of the block as implemented in
  * this platform, signify anything MMC_CAP_* from mmc/host.h
- * @dma_filter: function used to select an apropriate RX and TX
+ * @dma_filter: function used to select an appropriate RX and TX
  * DMA channel to be used for DMA, if and only if you're deploying the
  * generic DMA engine
  * @dma_rx_param: parameter passed to the DMA allocation
- * filter in order to select an apropriate RX channel. If
+ * filter in order to select an appropriate RX channel. If
  * there is a bidirectional RX+TX channel, then just specify
  * this and leave dma_tx_param set to NULL
  * @dma_tx_param: parameter passed to the DMA allocation
- * filter in order to select an apropriate TX channel. If this
+ * filter in order to select an appropriate TX channel. If this
  * is NULL the driver will attempt to use the RX channel as a
  * bidirectional channel
  */
diff --git a/include/linux/can/error.h b/include/linux/can/error.h
index d4127fd..5958074 100644
--- a/include/linux/can/error.h
+++ b/include/linux/can/error.h
@@ -51,7 +51,7 @@
 #define CAN_ERR_PROT_BIT1        0x10 /* unable to send recessive bit */
 #define CAN_ERR_PROT_OVERLOAD    0x20 /* bus overload */
 #define CAN_ERR_PROT_ACTIVE      0x40 /* active error announcement */
-#define CAN_ERR_PROT_TX          0x80 /* error occured on transmission */
+#define CAN_ERR_PROT_TX          0x80 /* error occurred on transmission */
 
 /* error in CAN protocol (location) / data[3] */
 #define CAN_ERR_PROT_LOC_UNSPEC  0x00 /* unspecified */
diff --git a/include/linux/can/netlink.h b/include/linux/can/netlink.h
index 3250de9..34542d3 100644
--- a/include/linux/can/netlink.h
+++ b/include/linux/can/netlink.h
@@ -17,7 +17,7 @@
 /*
  * CAN bit-timing parameters
  *
- * For futher information, please read chapter "8 BIT TIMING
+ * For further information, please read chapter "8 BIT TIMING
  * REQUIREMENTS" of the "Bosch CAN Specification version 2.0"
  * at http://www.semiconductors.bosch.de/pdf/can2spec.pdf.
  */
diff --git a/include/linux/cdk.h b/include/linux/cdk.h
index 0908daf..80093a8 100644
--- a/include/linux/cdk.h
+++ b/include/linux/cdk.h
@@ -149,7 +149,7 @@ typedef struct cdkhdr {
 /*
  *	Define the memory mapping structure. This structure is pointed to by
  *	the memp field in the stlcdkhdr struct. As many as these structures
- *	as required are layed out in shared memory to define how the rest of
+ *	as required are laid out in shared memory to define how the rest of
  *	shared memory is divided up. There will be one for each port.
  */
 typedef struct cdkmem {
diff --git a/include/linux/cfag12864b.h b/include/linux/cfag12864b.h
index 6f9f19d..b454dfc 100644
--- a/include/linux/cfag12864b.h
+++ b/include/linux/cfag12864b.h
@@ -44,7 +44,7 @@ extern unsigned char * cfag12864b_buffer;
 /*
  * Get the refresh rate of the LCD
  *
- * Returns the refresh rate (hertzs).
+ * Returns the refresh rate (hertz).
  */
 extern unsigned int cfag12864b_getrate(void);
 
diff --git a/include/linux/cgroup.h b/include/linux/cgroup.h
index e654fa2..5ac7ebc 100644
--- a/include/linux/cgroup.h
+++ b/include/linux/cgroup.h
@@ -240,7 +240,7 @@ struct cgroup {
 	/* For RCU-protected deletion */
 	struct rcu_head rcu_head;
 
-	/* List of events which userspace want to recieve */
+	/* List of events which userspace want to receive */
 	struct list_head event_list;
 	spinlock_t event_list_lock;
 };
diff --git a/include/linux/cm4000_cs.h b/include/linux/cm4000_cs.h
index 72bfefd..3c4aac4 100644
--- a/include/linux/cm4000_cs.h
+++ b/include/linux/cm4000_cs.h
@@ -20,7 +20,7 @@ typedef struct atreq {
 } atreq_t;
 
 
-/* what is particularly stupid in the original driver is the arch-dependant
+/* what is particularly stupid in the original driver is the arch-dependent
  * member sizes. This leads to CONFIG_COMPAT breakage, since 32bit userspace
  * will lay out the structure members differently than the 64bit kernel.
  *
diff --git a/include/linux/configfs.h b/include/linux/configfs.h
index ddb7a97..645778a 100644
--- a/include/linux/configfs.h
+++ b/include/linux/configfs.h
@@ -218,7 +218,7 @@ static ssize_t _item##_attr_store(struct config_item *item,		\
  * group children.  default_groups may coexist alongsize make_group() or
  * make_item(), but if the group wishes to have only default_groups
  * children (disallowing mkdir(2)), it need not provide either function.
- * If the group has commit(), it supports pending and commited (active)
+ * If the group has commit(), it supports pending and committed (active)
  * items.
  */
 struct configfs_item_operations {
diff --git a/include/linux/cper.h b/include/linux/cper.h
index 372a258..c230494 100644
--- a/include/linux/cper.h
+++ b/include/linux/cper.h
@@ -310,7 +310,7 @@ struct cper_sec_proc_ia {
 	__u8	cpuid[48];
 };
 
-/* IA32/X64 Processor Error Infomation Structure */
+/* IA32/X64 Processor Error Information Structure */
 struct cper_ia_err_info {
 	uuid_le	err_type;
 	__u64	validation_bits;
diff --git a/include/linux/decompress/mm.h b/include/linux/decompress/mm.h
index 4cb72b9..7925bf0 100644
--- a/include/linux/decompress/mm.h
+++ b/include/linux/decompress/mm.h
@@ -16,7 +16,7 @@
 
 /*
  * Some architectures want to ensure there is no local data in their
- * pre-boot environment, so that data can arbitarily relocated (via
+ * pre-boot environment, so that data can arbitrarily relocated (via
  * GOT references).  This is achieved by defining STATIC_RW_DATA to
  * be null.
  */
diff --git a/include/linux/dmaengine.h b/include/linux/dmaengine.h
index 9bebd7f..eee7add 100644
--- a/include/linux/dmaengine.h
+++ b/include/linux/dmaengine.h
@@ -434,7 +434,7 @@ struct dma_tx_state {
  *	zero or error code
  * @device_tx_status: poll for transaction completion, the optional
  *	txstate parameter can be supplied with a pointer to get a
- *	struct with auxilary transfer status information, otherwise the call
+ *	struct with auxiliary transfer status information, otherwise the call
  *	will just return a simple status code
  * @device_issue_pending: push pending transactions to hardware
  */
diff --git a/include/linux/drbd.h b/include/linux/drbd.h
index d18d673..cec467f 100644
--- a/include/linux/drbd.h
+++ b/include/linux/drbd.h
@@ -36,7 +36,7 @@
 #include <sys/wait.h>
 #include <limits.h>
 
-/* Altough the Linux source code makes a difference between
+/* Although the Linux source code makes a difference between
    generic endianness and the bitfields' endianness, there is no
    architecture as of Linux-2.6.24-rc4 where the bitfileds' endianness
    does not match the generic endianness. */
@@ -184,7 +184,7 @@ enum drbd_conns {
 	/* These temporal states are all used on the way
 	 * from >= C_CONNECTED to Unconnected.
 	 * The 'disconnect reason' states
-	 * I do not allow to change beween them. */
+	 * I do not allow to change between them. */
 	C_TIMEOUT,
 	C_BROKEN_PIPE,
 	C_NETWORK_FAILURE,
diff --git a/include/linux/drbd_limits.h b/include/linux/drbd_limits.h
index bb264a5..246f576 100644
--- a/include/linux/drbd_limits.h
+++ b/include/linux/drbd_limits.h
@@ -43,7 +43,7 @@
 
 /* net { */
   /* timeout, unit centi seconds
-   * more than one minute timeout is not usefull */
+   * more than one minute timeout is not useful */
 #define DRBD_TIMEOUT_MIN 1
 #define DRBD_TIMEOUT_MAX 600
 #define DRBD_TIMEOUT_DEF 60       /* 6 seconds */
@@ -68,7 +68,7 @@
 #define DRBD_MAX_EPOCH_SIZE_MAX 20000
 #define DRBD_MAX_EPOCH_SIZE_DEF 2048
 
-  /* I don't think that a tcp send buffer of more than 10M is usefull */
+  /* I don't think that a tcp send buffer of more than 10M is useful */
 #define DRBD_SNDBUF_SIZE_MIN  0
 #define DRBD_SNDBUF_SIZE_MAX  (10<<20)
 #define DRBD_SNDBUF_SIZE_DEF  0
@@ -101,7 +101,7 @@
 #define DRBD_RATE_MAX (4 << 20)
 #define DRBD_RATE_DEF 250  /* kb/second */
 
-  /* less than 7 would hit performance unneccessarily.
+  /* less than 7 would hit performance unnecessarily.
    * 3833 is the largest prime that still does fit
    * into 64 sectors of activity log */
 #define DRBD_AL_EXTENTS_MIN  7
diff --git a/include/linux/ethtool.h b/include/linux/ethtool.h
index c8fcbdd..dc80d82 100644
--- a/include/linux/ethtool.h
+++ b/include/linux/ethtool.h
@@ -614,7 +614,7 @@ struct ethtool_sfeatures {
  * values of corresponding bits in features[].requested. Bits in .requested
  * not set in .valid or not changeable are ignored.
  *
- * Returns %EINVAL when .valid contains undefined or never-changable bits
+ * Returns %EINVAL when .valid contains undefined or never-changeable bits
  * or size is not equal to required number of features words (32-bit blocks).
  * Returns >= 0 if request was completed; bits set in the value mean:
  *   %ETHTOOL_F_UNSUPPORTED - there were bits set in .valid that are not
diff --git a/include/linux/eventpoll.h b/include/linux/eventpoll.h
index f6856a5..f362733 100644
--- a/include/linux/eventpoll.h
+++ b/include/linux/eventpoll.h
@@ -1,5 +1,5 @@
 /*
- *  include/linux/eventpoll.h ( Efficent event polling implementation )
+ *  include/linux/eventpoll.h ( Efficient event polling implementation )
  *  Copyright (C) 2001,...,2006	 Davide Libenzi
  *
  *  This program is free software; you can redistribute it and/or modify
diff --git a/include/linux/exportfs.h b/include/linux/exportfs.h
index 33a42f2..3a4cef5 100644
--- a/include/linux/exportfs.h
+++ b/include/linux/exportfs.h
@@ -120,7 +120,7 @@ struct fid {
  * encode_fh:
  *    @encode_fh should store in the file handle fragment @fh (using at most
  *    @max_len bytes) information that can be used by @decode_fh to recover the
- *    file refered to by the &struct dentry @de.  If the @connectable flag is
+ *    file referred to by the &struct dentry @de.  If the @connectable flag is
  *    set, the encode_fh() should store sufficient information so that a good
  *    attempt can be made to find not only the file but also it's place in the
  *    filesystem.   This typically means storing a reference to de->d_parent in
diff --git a/include/linux/fb.h b/include/linux/fb.h
index b2a3639..df728c1 100644
--- a/include/linux/fb.h
+++ b/include/linux/fb.h
@@ -534,14 +534,14 @@ struct fb_cursor_user {
 #define FB_EVENT_GET_CONSOLE_MAP        0x07
 /*      CONSOLE-SPECIFIC: set console to framebuffer mapping */
 #define FB_EVENT_SET_CONSOLE_MAP        0x08
-/*      A hardware display blank change occured */
+/*      A hardware display blank change occurred */
 #define FB_EVENT_BLANK                  0x09
 /*      Private modelist is to be replaced */
 #define FB_EVENT_NEW_MODELIST           0x0A
 /*	The resolution of the passed in fb_info about to change and
         all vc's should be changed         */
 #define FB_EVENT_MODE_CHANGE_ALL	0x0B
-/*	A software display blank change occured */
+/*	A software display blank change occurred */
 #define FB_EVENT_CONBLANK               0x0C
 /*      Get drawing requirements        */
 #define FB_EVENT_GET_REQ                0x0D
@@ -805,7 +805,7 @@ struct fb_tile_ops {
 /* A driver may set this flag to indicate that it does want a set_par to be
  * called every time when fbcon_switch is executed. The advantage is that with
  * this flag set you can really be sure that set_par is always called before
- * any of the functions dependant on the correct hardware state or altering
+ * any of the functions dependent on the correct hardware state or altering
  * that state, even if you are using some broken X releases. The disadvantage
  * is that it introduces unwanted delays to every console switch if set_par
  * is slow. It is a good idea to try this flag in the drivers initialization
@@ -877,7 +877,7 @@ struct fb_info {
 	void *fbcon_par;                /* fbcon use-only private area */
 	/* From here on everything is device dependent */
 	void *par;
-	/* we need the PCI or similiar aperture base/size not
+	/* we need the PCI or similar aperture base/size not
 	   smem_start/size as smem_start may just be an object
 	   allocated inside the aperture so may not actually overlap */
 	struct apertures_struct {
diff --git a/include/linux/firewire-cdev.h b/include/linux/firewire-cdev.h
index 59ea406..4ff0988 100644
--- a/include/linux/firewire-cdev.h
+++ b/include/linux/firewire-cdev.h
@@ -900,7 +900,7 @@ struct fw_cdev_get_cycle_timer2 {
 
 /**
  * struct fw_cdev_allocate_iso_resource - (De)allocate a channel or bandwidth
- * @closure:	Passed back to userspace in correponding iso resource events
+ * @closure:	Passed back to userspace in corresponding iso resource events
  * @channels:	Isochronous channels of which one is to be (de)allocated
  * @bandwidth:	Isochronous bandwidth units to be (de)allocated
  * @handle:	Handle to the allocation, written by the kernel (only valid in
diff --git a/include/linux/fs.h b/include/linux/fs.h
index 1b95af3..dbd860a 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -465,7 +465,7 @@ struct iattr {
 	struct timespec	ia_ctime;
 
 	/*
-	 * Not an attribute, but an auxilary info for filesystems wanting to
+	 * Not an attribute, but an auxiliary info for filesystems wanting to
 	 * implement an ftruncate() like method.  NOTE: filesystem should
 	 * check for (ia_valid & ATTR_FILE), and not for (ia_file != NULL).
 	 */
@@ -649,7 +649,7 @@ struct address_space {
 } __attribute__((aligned(sizeof(long))));
 	/*
 	 * On most architectures that alignment is already the case; but
-	 * must be enforced here for CRIS, to let the least signficant bit
+	 * must be enforced here for CRIS, to let the least significant bit
 	 * of struct page's "mapping" pointer be used for PAGE_MAPPING_ANON.
 	 */
 
diff --git a/include/linux/fscache-cache.h b/include/linux/fscache-cache.h
index b8581c0..76427e6 100644
--- a/include/linux/fscache-cache.h
+++ b/include/linux/fscache-cache.h
@@ -236,7 +236,7 @@ struct fscache_cache_ops {
 	/* unpin an object in the cache */
 	void (*unpin_object)(struct fscache_object *object);
 
-	/* store the updated auxilliary data on an object */
+	/* store the updated auxiliary data on an object */
 	void (*update_object)(struct fscache_object *object);
 
 	/* discard the resources pinned by an object and effect retirement if
diff --git a/include/linux/fscache.h b/include/linux/fscache.h
index ec0dad5..7c4d72f 100644
--- a/include/linux/fscache.h
+++ b/include/linux/fscache.h
@@ -102,9 +102,9 @@ struct fscache_cookie_def {
 	 */
 	void (*get_attr)(const void *cookie_netfs_data, uint64_t *size);
 
-	/* get the auxilliary data from netfs data
+	/* get the auxiliary data from netfs data
 	 * - this function can be absent if the index carries no state data
-	 * - should store the auxilliary data in the buffer
+	 * - should store the auxiliary data in the buffer
 	 * - should return the amount of amount stored
 	 * - not permitted to return an error
 	 * - the netfs data from the cookie being used as the source is
@@ -117,7 +117,7 @@ struct fscache_cookie_def {
 	/* consult the netfs about the state of an object
 	 * - this function can be absent if the index carries no state data
 	 * - the netfs data from the cookie being used as the target is
-	 *   presented, as is the auxilliary data
+	 *   presented, as is the auxiliary data
 	 */
 	enum fscache_checkaux (*check_aux)(void *cookie_netfs_data,
 					   const void *data,
diff --git a/include/linux/hid.h b/include/linux/hid.h
index bb29bb1..42f7e2f 100644
--- a/include/linux/hid.h
+++ b/include/linux/hid.h
@@ -799,7 +799,7 @@ static inline int __must_check hid_parse(struct hid_device *hdev)
  *
  * Call this in probe function *after* hid_parse. This will setup HW buffers
  * and start the device (if not deffered to device open). hid_hw_stop must be
- * called if this was successfull.
+ * called if this was successful.
  */
 static inline int __must_check hid_hw_start(struct hid_device *hdev,
 		unsigned int connect_mask)
diff --git a/include/linux/hp_sdc.h b/include/linux/hp_sdc.h
index 9db3d45..d392975 100644
--- a/include/linux/hp_sdc.h
+++ b/include/linux/hp_sdc.h
@@ -101,7 +101,7 @@ int hp_sdc_dequeue_transaction(hp_sdc_transaction *this);
 #define HP_SDC_STATUS_REG	0x40	/* Data from an i8042 register */
 #define HP_SDC_STATUS_HILCMD    0x50	/* Command from HIL MLC */
 #define HP_SDC_STATUS_HILDATA   0x60	/* Data from HIL MLC */
-#define HP_SDC_STATUS_PUP	0x70	/* Sucessful power-up self test */
+#define HP_SDC_STATUS_PUP	0x70	/* Successful power-up self test */
 #define HP_SDC_STATUS_KCOOKED	0x80	/* Key from cooked kbd */
 #define HP_SDC_STATUS_KRPG	0xc0	/* Key from Repeat Gen */
 #define HP_SDC_STATUS_KMOD_SUP	0x10	/* Shift key is up */
diff --git a/include/linux/i2o.h b/include/linux/i2o.h
index 9e7a12d..a6deef4 100644
--- a/include/linux/i2o.h
+++ b/include/linux/i2o.h
@@ -826,7 +826,7 @@ static inline struct i2o_message __iomem *i2o_msg_in_to_virt(struct
  *	@c: I2O controller
  *
  *	This function tries to get a message frame. If no message frame is
- *	available do not wait until one is availabe (see also i2o_msg_get_wait).
+ *	available do not wait until one is available (see also i2o_msg_get_wait).
  *	The returned pointer to the message frame is not in I/O memory, it is
  *	allocated from a mempool. But because a MFA is allocated from the
  *	controller too it is guaranteed that i2o_msg_post() will never fail.
diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 943c9b5..bea0ac7 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -98,7 +98,7 @@ typedef irqreturn_t (*irq_handler_t)(int, void *);
  * @next:	pointer to the next irqaction for shared interrupts
  * @irq:	interrupt number
  * @dir:	pointer to the proc/irq/NN/name entry
- * @thread_fn:	interupt handler function for threaded interrupts
+ * @thread_fn:	interrupt handler function for threaded interrupts
  * @thread:	thread pointer for threaded interrupts
  * @thread_flags:	flags related to @thread
  * @thread_mask:	bitmask for keeping track of @thread activity
@@ -484,7 +484,7 @@ extern void __send_remote_softirq(struct call_single_data *cp, int cpu,
    Properties:
    * If tasklet_schedule() is called, then tasklet is guaranteed
      to be executed on some cpu at least once after this.
-   * If the tasklet is already scheduled, but its excecution is still not
+   * If the tasklet is already scheduled, but its execution is still not
      started, it will be executed only once.
    * If this tasklet is already running on another CPU (or schedule is called
      from tasklet itself), it is rescheduled for later.
diff --git a/include/linux/ipmi.h b/include/linux/ipmi.h
index 045f2f2..ca85cf8 100644
--- a/include/linux/ipmi.h
+++ b/include/linux/ipmi.h
@@ -111,7 +111,7 @@ struct ipmi_ipmb_addr {
  * A LAN Address.  This is an address to/from a LAN interface bridged
  * by the BMC, not an address actually out on the LAN.
  *
- * A concious decision was made here to deviate slightly from the IPMI
+ * A conscious decision was made here to deviate slightly from the IPMI
  * spec.  We do not use rqSWID and rsSWID like it shows in the
  * message.  Instead, we use remote_SWID and local_SWID.  This means
  * that any message (a request or response) from another device will
@@ -259,7 +259,7 @@ struct ipmi_recv_msg {
 	void (*done)(struct ipmi_recv_msg *msg);
 
 	/* Place-holder for the data, don't make any assumptions about
-	   the size or existance of this, since it may change. */
+	   the size or existence of this, since it may change. */
 	unsigned char   msg_data[IPMI_MAX_MSG_LENGTH];
 };
 
diff --git a/include/linux/isdn/hdlc.h b/include/linux/isdn/hdlc.h
index 4b3ecc4..9652137 100644
--- a/include/linux/isdn/hdlc.h
+++ b/include/linux/isdn/hdlc.h
@@ -2,7 +2,7 @@
  * hdlc.h  --  General purpose ISDN HDLC decoder.
  *
  * Implementation of a HDLC decoder/encoder in software.
- * Neccessary because some ISDN devices don't have HDLC
+ * Necessary because some ISDN devices don't have HDLC
  * controllers.
  *
  * Copyright (C)
diff --git a/include/linux/ixjuser.h b/include/linux/ixjuser.h
index 88b4589..94ab5e9 100644
--- a/include/linux/ixjuser.h
+++ b/include/linux/ixjuser.h
@@ -50,7 +50,7 @@
 * IOCTL's used for the Quicknet Telephony Cards
 *
 * If you use the IXJCTL_TESTRAM command, the card must be power cycled to
-* reset the SRAM values before futher use.
+* reset the SRAM values before further use.
 *
 ******************************************************************************/
 
diff --git a/include/linux/jiffies.h b/include/linux/jiffies.h
index 922aa31..f97672a 100644
--- a/include/linux/jiffies.h
+++ b/include/linux/jiffies.h
@@ -42,7 +42,7 @@
 /* LATCH is used in the interval timer and ftape setup. */
 #define LATCH  ((CLOCK_TICK_RATE + HZ/2) / HZ)	/* For divider */
 
-/* Suppose we want to devide two numbers NOM and DEN: NOM/DEN, then we can
+/* Suppose we want to divide two numbers NOM and DEN: NOM/DEN, then we can
  * improve accuracy by shifting LSH bits, hence calculating:
  *     (NOM << LSH) / DEN
  * This however means trouble for large NOM, because (NOM << LSH) may no
diff --git a/include/linux/ktime.h b/include/linux/ktime.h
index e1ceaa9..603bec2 100644
--- a/include/linux/ktime.h
+++ b/include/linux/ktime.h
@@ -35,7 +35,7 @@
  *
  * On 32-bit CPUs an optimized representation of the timespec structure
  * is used to avoid expensive conversions from and to timespecs. The
- * endian-aware order of the tv struct members is choosen to allow
+ * endian-aware order of the tv struct members is chosen to allow
  * mathematical operations on the tv64 member of the union too, which
  * for certain operations produces better code.
  *
@@ -158,7 +158,7 @@ static inline ktime_t ktime_set(const long secs, const unsigned long nsecs)
  * @lhs:	minuend
  * @rhs:	subtrahend
  *
- * Returns the remainder of the substraction
+ * Returns the remainder of the subtraction
  */
 static inline ktime_t ktime_sub(const ktime_t lhs, const ktime_t rhs)
 {
diff --git a/include/linux/led-lm3530.h b/include/linux/led-lm3530.h
index bb69d20..58592fa 100644
--- a/include/linux/led-lm3530.h
+++ b/include/linux/led-lm3530.h
@@ -41,7 +41,7 @@
 #define LM3530_RAMP_TIME_8s		(7)
 
 /* ALS Resistor Select */
-#define LM3530_ALS_IMPD_Z		(0x00) /* ALS Impedence */
+#define LM3530_ALS_IMPD_Z		(0x00) /* ALS Impedance */
 #define LM3530_ALS_IMPD_13_53kOhm	(0x01)
 #define LM3530_ALS_IMPD_9_01kOhm	(0x02)
 #define LM3530_ALS_IMPD_5_41kOhm	(0x03)
diff --git a/include/linux/libata.h b/include/linux/libata.h
index c71f469..7f675aa 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -364,7 +364,7 @@ enum {
 	ATA_EH_CMD_TIMEOUT_TABLE_SIZE = 6,
 
 	/* Horkage types. May be set by libata or controller on drives
-	   (some horkage may be drive/controller pair dependant */
+	   (some horkage may be drive/controller pair dependent */
 
 	ATA_HORKAGE_DIAGNOSTIC	= (1 << 0),	/* Failed boot diag */
 	ATA_HORKAGE_NODMA	= (1 << 1),	/* DMA problems */
diff --git a/include/linux/lru_cache.h b/include/linux/lru_cache.h
index 78fbf24..6a4fab7 100644
--- a/include/linux/lru_cache.h
+++ b/include/linux/lru_cache.h
@@ -148,7 +148,7 @@ write intent log information, three of which are mentioned here.
  *
  * DRBD currently (May 2009) only uses 61 elements on the resync lru_cache
  * (total memory usage 2 pages), and up to 3833 elements on the act_log
- * lru_cache, totalling ~215 kB for 64bit architechture, ~53 pages.
+ * lru_cache, totalling ~215 kB for 64bit architecture, ~53 pages.
  *
  * We usually do not actually free these objects again, but only "recycle"
  * them, as the change "index: -old_label, +LC_FREE" would need a transaction
diff --git a/include/linux/mfd/wm8350/pmic.h b/include/linux/mfd/wm8350/pmic.h
index e786fe9..579b50c 100644
--- a/include/linux/mfd/wm8350/pmic.h
+++ b/include/linux/mfd/wm8350/pmic.h
@@ -1,5 +1,5 @@
 /*
- * pmic.h  --  Power Managment Driver for Wolfson WM8350 PMIC
+ * pmic.h  --  Power Management Driver for Wolfson WM8350 PMIC
  *
  * Copyright 2007 Wolfson Microelectronics PLC
  *
diff --git a/include/linux/mm.h b/include/linux/mm.h
index 7606d7d..692dbae 100644
--- a/include/linux/mm.h
+++ b/include/linux/mm.h
@@ -608,7 +608,7 @@ static inline pte_t maybe_mkwrite(pte_t pte, struct vm_area_struct *vma)
 #endif
 
 /*
- * Define the bit shifts to access each section.  For non-existant
+ * Define the bit shifts to access each section.  For non-existent
  * sections we define the shift as 0; that plus a 0 mask ensures
  * the compiler will optimise away reference to them.
  */
diff --git a/include/linux/mmc/dw_mmc.h b/include/linux/mmc/dw_mmc.h
index c0207a7..bdd7cee 100644
--- a/include/linux/mmc/dw_mmc.h
+++ b/include/linux/mmc/dw_mmc.h
@@ -98,7 +98,7 @@ struct mmc_data;
  * EVENT_DATA_COMPLETE is set in @pending_events, all data-related
  * interrupts must be disabled and @data_status updated with a
  * snapshot of SR. Similarly, before EVENT_CMD_COMPLETE is set, the
- * CMDRDY interupt must be disabled and @cmd_status updated with a
+ * CMDRDY interrupt must be disabled and @cmd_status updated with a
  * snapshot of SR, and before EVENT_XFER_COMPLETE can be set, the
  * bytes_xfered field of @data must be written. This is ensured by
  * using barriers.
@@ -172,7 +172,7 @@ struct dw_mci_dma_ops {
 #define DW_MCI_QUIRK_IDMAC_DTO			BIT(0)
 /* delay needed between retries on some 2.11a implementations */
 #define DW_MCI_QUIRK_RETRY_DELAY		BIT(1)
-/* High Speed Capable - Supports HS cards (upto 50MHz) */
+/* High Speed Capable - Supports HS cards (up to 50MHz) */
 #define DW_MCI_QUIRK_HIGHSPEED			BIT(2)
 /* Unreliable card detection */
 #define DW_MCI_QUIRK_BROKEN_CARD_DETECTION	BIT(3)
diff --git a/include/linux/mroute6.h b/include/linux/mroute6.h
index 9d2deb2..a3759cb 100644
--- a/include/linux/mroute6.h
+++ b/include/linux/mroute6.h
@@ -249,7 +249,7 @@ static inline int ip6mr_sk_done(struct sock *sk)
  * Structure used to communicate from kernel to multicast router.
  * We'll overlay the structure onto an MLD header (not an IPv6 heder like igmpmsg{}
  * used for IPv4 implementation). This is because this structure will be passed via an
- * IPv6 raw socket, on wich an application will only receiver the payload i.e the data after
+ * IPv6 raw socket, on which an application will only receiver the payload i.e the data after
  * the IPv6 header and all the extension headers. (See section 3 of RFC 3542)
  */
 
diff --git a/include/linux/mtd/cfi.h b/include/linux/mtd/cfi.h
index 0d823f2..d249254 100644
--- a/include/linux/mtd/cfi.h
+++ b/include/linux/mtd/cfi.h
@@ -308,7 +308,7 @@ static inline uint32_t cfi_build_cmd_addr(uint32_t cmd_ofs,
 	
 	addr = (cmd_ofs * type) * interleave;
 
-	/* Modify the unlock address if we are in compatiblity mode.
+	/* Modify the unlock address if we are in compatibility mode.
 	 * For 16bit devices on 8 bit busses
 	 * and 32bit devices on 16 bit busses
 	 * set the low bit of the alternating bit sequence of the address.
diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index ae67ef5..d441927 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -416,9 +416,9 @@ struct nand_buffers {
  * @select_chip:	[REPLACEABLE] select chip nr
  * @block_bad:		[REPLACEABLE] check, if the block is bad
  * @block_markbad:	[REPLACEABLE] mark the block bad
- * @cmd_ctrl:		[BOARDSPECIFIC] hardwarespecific funtion for controlling
+ * @cmd_ctrl:		[BOARDSPECIFIC] hardwarespecific function for controlling
  *			ALE/CLE/nCE. Also used to write command and address
- * @init_size:		[BOARDSPECIFIC] hardwarespecific funtion for setting
+ * @init_size:		[BOARDSPECIFIC] hardwarespecific function for setting
  *			mtd->oobsize, mtd->writesize and so on.
  *			@id_data contains the 8 bytes values of NAND_CMD_READID.
  *			Return with the bus width.
@@ -437,7 +437,7 @@ struct nand_buffers {
  * @erase_cmd:		[INTERN] erase command write function, selectable due
  *			to AND support.
  * @scan_bbt:		[REPLACEABLE] function to scan bad block table
- * @chip_delay:		[BOARDSPECIFIC] chip dependent delay for transfering
+ * @chip_delay:		[BOARDSPECIFIC] chip dependent delay for transferring
  *			data from array to read regs (tR).
  * @state:		[INTERN] the current state of the NAND device
  * @oob_poi:		poison value buffer
diff --git a/include/linux/mtd/xip.h b/include/linux/mtd/xip.h
index 36efcba..abed4de 100644
--- a/include/linux/mtd/xip.h
+++ b/include/linux/mtd/xip.h
@@ -51,7 +51,7 @@
  * 	return in usecs the elapsed timebetween now and the reference x as
  * 	returned by xip_currtime().
  *
- * 	note 1: convertion to usec can be approximated, as long as the
+ * 	note 1: conversion to usec can be approximated, as long as the
  * 		returned value is <= the real elapsed time.
  * 	note 2: this should be able to cope with a few seconds without
  * 		overflowing.
diff --git a/include/linux/netfilter/nf_conntrack_proto_gre.h b/include/linux/netfilter/nf_conntrack_proto_gre.h
index 2a10efd..6a0664c 100644
--- a/include/linux/netfilter/nf_conntrack_proto_gre.h
+++ b/include/linux/netfilter/nf_conntrack_proto_gre.h
@@ -60,7 +60,7 @@ struct gre_hdr_pptp {
 	__be16 payload_len;	/* size of ppp payload, not inc. gre header */
 	__be16 call_id;		/* peer's call_id for this session */
 	__be32 seq;		/* sequence number.  Present if S==1 */
-	__be32 ack;		/* seq number of highest packet recieved by */
+	__be32 ack;		/* seq number of highest packet received by */
 				/*  sender in this session */
 };
 
diff --git a/include/linux/netfilter_bridge/ebtables.h b/include/linux/netfilter_bridge/ebtables.h
index 1c6f0c5..8797ed1 100644
--- a/include/linux/netfilter_bridge/ebtables.h
+++ b/include/linux/netfilter_bridge/ebtables.h
@@ -92,7 +92,7 @@ struct ebt_entries {
 
 /* This is a hack to make a difference between an ebt_entry struct and an
  * ebt_entries struct when traversing the entries from start to end.
- * Using this simplifies the code alot, while still being able to use
+ * Using this simplifies the code a lot, while still being able to use
  * ebt_entries.
  * Contrary, iptables doesn't use something like ebt_entries and therefore uses
  * different techniques for naming the policy and such. So, iptables doesn't
diff --git a/include/linux/nfs4.h b/include/linux/nfs4.h
index b528f6d..178fafe 100644
--- a/include/linux/nfs4.h
+++ b/include/linux/nfs4.h
@@ -359,7 +359,7 @@ enum nfsstat4 {
 						/* Error 10073 is unused. */
 	NFS4ERR_CLIENTID_BUSY	= 10074,	/* clientid has state */
 	NFS4ERR_PNFS_IO_HOLE	= 10075,	/* IO to _SPARSE file hole */
-	NFS4ERR_SEQ_FALSE_RETRY	= 10076,	/* retry not origional */
+	NFS4ERR_SEQ_FALSE_RETRY	= 10076,	/* retry not original */
 	NFS4ERR_BAD_HIGH_SLOT	= 10077,	/* sequence arg bad */
 	NFS4ERR_DEADSESSION	= 10078,	/* persistent session dead */
 	NFS4ERR_ENCR_ALG_UNSUPP = 10079,	/* SSV alg mismatch */
diff --git a/include/linux/nfsd/export.h b/include/linux/nfsd/export.h
index bd31615..84058ec 100644
--- a/include/linux/nfsd/export.h
+++ b/include/linux/nfsd/export.h
@@ -80,7 +80,7 @@ struct nfsd4_fs_locations {
 
 /*
  * We keep an array of pseudoflavors with the export, in order from most
- * to least preferred.  For the forseeable future, we don't expect more
+ * to least preferred.  For the foreseeable future, we don't expect more
  * than the eight pseudoflavors null, unix, krb5, krb5i, krb5p, skpm3,
  * spkm3i, and spkm3p (and using all 8 at once should be rare).
  */
diff --git a/include/linux/nfsd/nfsfh.h b/include/linux/nfsd/nfsfh.h
index 80d55bb..f76d80c 100644
--- a/include/linux/nfsd/nfsfh.h
+++ b/include/linux/nfsd/nfsfh.h
@@ -49,7 +49,7 @@ struct nfs_fhbase_old {
  *
  * The auth_type field specifies how the filehandle can be authenticated
  * This might allow a file to be confirmed to be in a writable part of a
- * filetree without checking the path from it upto the root.
+ * filetree without checking the path from it up to the root.
  * Current values:
  *     0  - No authentication.  fb_auth is 0 bytes long
  * Possible future values:
diff --git a/include/linux/nl80211.h b/include/linux/nl80211.h
index 3002218..bbfa109 100644
--- a/include/linux/nl80211.h
+++ b/include/linux/nl80211.h
@@ -414,7 +414,7 @@
  * @__NL80211_CMD_AFTER_LAST: internal use
  */
 enum nl80211_commands {
-/* don't change the order or add anything inbetween, this is ABI! */
+/* don't change the order or add anything between, this is ABI! */
 	NL80211_CMD_UNSPEC,
 
 	NL80211_CMD_GET_WIPHY,		/* can dump */
@@ -860,7 +860,7 @@ enum nl80211_commands {
  *	This can be used to mask out antennas which are not attached or should
  *	not be used for receiving. If an antenna is not selected in this bitmap
  *	the hardware should not be configured to receive on this antenna.
- *	For a more detailed descripton see @NL80211_ATTR_WIPHY_ANTENNA_TX.
+ *	For a more detailed description see @NL80211_ATTR_WIPHY_ANTENNA_TX.
  *
  * @NL80211_ATTR_WIPHY_ANTENNA_AVAIL_TX: Bitmap of antennas which are available
  *	for configuration as TX antennas via the above parameters.
@@ -891,7 +891,7 @@ enum nl80211_commands {
  * @__NL80211_ATTR_AFTER_LAST: internal use
  */
 enum nl80211_attrs {
-/* don't change the order or add anything inbetween, this is ABI! */
+/* don't change the order or add anything between, this is ABI! */
 	NL80211_ATTR_UNSPEC,
 
 	NL80211_ATTR_WIPHY,
@@ -1419,7 +1419,7 @@ enum nl80211_bitrate_attr {
  * 	802.11 country information element with regulatory information it
  * 	thinks we should consider. cfg80211 only processes the country
  *	code from the IE, and relies on the regulatory domain information
- *	structure pased by userspace (CRDA) from our wireless-regdb.
+ *	structure passed by userspace (CRDA) from our wireless-regdb.
  *	If a channel is enabled but the country code indicates it should
  *	be disabled we disable the channel and re-enable it upon disassociation.
  */
@@ -1598,7 +1598,7 @@ enum nl80211_mntr_flags {
  * @NL80211_MESHCONF_RETRY_TIMEOUT: specifies the initial retry timeout in
  * millisecond units, used by the Peer Link Open message
  *
- * @NL80211_MESHCONF_CONFIRM_TIMEOUT: specifies the inital confirm timeout, in
+ * @NL80211_MESHCONF_CONFIRM_TIMEOUT: specifies the initial confirm timeout, in
  * millisecond units, used by the peer link management to close a peer link
  *
  * @NL80211_MESHCONF_HOLDING_TIMEOUT: specifies the holding timeout, in
diff --git a/include/linux/notifier.h b/include/linux/notifier.h
index 2026f9e..621dfa1 100644
--- a/include/linux/notifier.h
+++ b/include/linux/notifier.h
@@ -237,7 +237,7 @@ static inline int notifier_to_errno(int ret)
 					* enabling interrupts. Must not sleep,
 					* must not fail */
 
-/* Used for CPU hotplug events occuring while tasks are frozen due to a suspend
+/* Used for CPU hotplug events occurring while tasks are frozen due to a suspend
  * operation in progress
  */
 #define CPU_TASKS_FROZEN	0x0010
diff --git a/include/linux/omap3isp.h b/include/linux/omap3isp.h
index 150822b..b6111f8 100644
--- a/include/linux/omap3isp.h
+++ b/include/linux/omap3isp.h
@@ -250,7 +250,7 @@ enum omap3isp_h3a_af_rgbpos {
 /* Contains the information regarding the Horizontal Median Filter */
 struct omap3isp_h3a_af_hmf {
 	__u8 enable;	/* Status of Horizontal Median Filter */
-	__u8 threshold;	/* Threshhold Value for Horizontal Median Filter */
+	__u8 threshold;	/* Threshold Value for Horizontal Median Filter */
 };
 
 /* Contains the information regarding the IIR Filters */
diff --git a/include/linux/page_cgroup.h b/include/linux/page_cgroup.h
index f5de21d..961ecc7 100644
--- a/include/linux/page_cgroup.h
+++ b/include/linux/page_cgroup.h
@@ -138,7 +138,7 @@ static inline void move_unlock_page_cgroup(struct page_cgroup *pc,
 
 #define PCG_ARRAYID_OFFSET	(BITS_PER_LONG - PCG_ARRAYID_WIDTH)
 /*
- * Zero the shift count for non-existant fields, to prevent compiler
+ * Zero the shift count for non-existent fields, to prevent compiler
  * warnings and ensure references are optimized away.
  */
 #define PCG_ARRAYID_SHIFT	(PCG_ARRAYID_OFFSET * (PCG_ARRAYID_WIDTH != 0))
diff --git a/include/linux/pci_regs.h b/include/linux/pci_regs.h
index 5b7e6b1..be01380 100644
--- a/include/linux/pci_regs.h
+++ b/include/linux/pci_regs.h
@@ -223,7 +223,7 @@
 #define  PCI_PM_CAP_PME_CLOCK	0x0008	/* PME clock required */
 #define  PCI_PM_CAP_RESERVED    0x0010  /* Reserved field */
 #define  PCI_PM_CAP_DSI		0x0020	/* Device specific initialization */
-#define  PCI_PM_CAP_AUX_POWER	0x01C0	/* Auxilliary power support mask */
+#define  PCI_PM_CAP_AUX_POWER	0x01C0	/* Auxiliary power support mask */
 #define  PCI_PM_CAP_D1		0x0200	/* D1 power state support */
 #define  PCI_PM_CAP_D2		0x0400	/* D2 power state support */
 #define  PCI_PM_CAP_PME		0x0800	/* PME pin supported */
@@ -435,7 +435,7 @@
 #define  PCI_EXP_LNKCAP_L0SEL	0x00007000 /* L0s Exit Latency */
 #define  PCI_EXP_LNKCAP_L1EL	0x00038000 /* L1 Exit Latency */
 #define  PCI_EXP_LNKCAP_CLKPM	0x00040000 /* L1 Clock Power Management */
-#define  PCI_EXP_LNKCAP_SDERC	0x00080000 /* Suprise Down Error Reporting Capable */
+#define  PCI_EXP_LNKCAP_SDERC	0x00080000 /* Surprise Down Error Reporting Capable */
 #define  PCI_EXP_LNKCAP_DLLLARC	0x00100000 /* Data Link Layer Link Active Reporting Capable */
 #define  PCI_EXP_LNKCAP_LBNC	0x00200000 /* Link Bandwidth Notification Capability */
 #define  PCI_EXP_LNKCAP_PN	0xff000000 /* Port Number */
diff --git a/include/linux/perf_event.h b/include/linux/perf_event.h
index 04d75a8..ee9f1e7 100644
--- a/include/linux/perf_event.h
+++ b/include/linux/perf_event.h
@@ -662,7 +662,7 @@ struct pmu {
 	int  (*commit_txn)	(struct pmu *pmu); /* optional */
 	/*
 	 * Will cancel the transaction, assumes ->del() is called
-	 * for each successfull ->add() during the transaction.
+	 * for each successful ->add() during the transaction.
 	 */
 	void (*cancel_txn)	(struct pmu *pmu); /* optional */
 };
diff --git a/include/linux/pid.h b/include/linux/pid.h
index efceda0..31afb7e 100644
--- a/include/linux/pid.h
+++ b/include/linux/pid.h
@@ -21,7 +21,7 @@ enum pid_type
  * quickly from the numeric pid value.  The attached processes may be
  * quickly accessed by following pointers from struct pid.
  *
- * Storing pid_t values in the kernel and refering to them later has a
+ * Storing pid_t values in the kernel and referring to them later has a
  * problem.  The process originally with that pid may have exited and the
  * pid allocator wrapped, and another process could have come along
  * and been assigned that pid.
diff --git a/include/linux/pkt_sched.h b/include/linux/pkt_sched.h
index b1032a3..3a02e02 100644
--- a/include/linux/pkt_sched.h
+++ b/include/linux/pkt_sched.h
@@ -223,7 +223,7 @@ struct tc_gred_qopt {
 	__u32		limit;        /* HARD maximal queue length (bytes)    */
 	__u32		qth_min;      /* Min average length threshold (bytes) */
 	__u32		qth_max;      /* Max average length threshold (bytes) */
-	__u32		DP;           /* upto 2^32 DPs */
+	__u32		DP;           /* up to 2^32 DPs */
 	__u32		backlog;
 	__u32		qave;
 	__u32		forced;
diff --git a/include/linux/poll.h b/include/linux/poll.h
index 1a2ccd6..cf40010 100644
--- a/include/linux/poll.h
+++ b/include/linux/poll.h
@@ -82,7 +82,7 @@ static inline int poll_schedule(struct poll_wqueues *pwq, int state)
 }
 
 /*
- * Scaleable version of the fd_set.
+ * Scalable version of the fd_set.
  */
 
 typedef struct {
diff --git a/include/linux/prefetch.h b/include/linux/prefetch.h
index af7c36a..a3bfbdf 100644
--- a/include/linux/prefetch.h
+++ b/include/linux/prefetch.h
@@ -29,7 +29,7 @@
 	prefetchw(x)	- prefetches the cacheline at "x" for write
 	spin_lock_prefetch(x) - prefetches the spinlock *x for taking
 	
-	there is also PREFETCH_STRIDE which is the architecure-prefered 
+	there is also PREFETCH_STRIDE which is the architecure-preferred 
 	"lookahead" size for prefetching streamed operations.
 	
 */
diff --git a/include/linux/pxa2xx_ssp.h b/include/linux/pxa2xx_ssp.h
index 2f691e4..44835fb 100644
--- a/include/linux/pxa2xx_ssp.h
+++ b/include/linux/pxa2xx_ssp.h
@@ -122,7 +122,7 @@
 #define SSCR1_TSRE		(1 << 21)	/* Transmit Service Request Enable */
 #define SSCR1_RSRE		(1 << 20)	/* Receive Service Request Enable */
 #define SSCR1_TINTE		(1 << 19)	/* Receiver Time-out Interrupt enable */
-#define SSCR1_PINTE		(1 << 18)	/* Peripheral Trailing Byte Interupt Enable */
+#define SSCR1_PINTE		(1 << 18)	/* Peripheral Trailing Byte Interrupt Enable */
 #define SSCR1_IFS		(1 << 16)	/* Invert Frame Signal */
 #define SSCR1_STRF		(1 << 15)	/* Select FIFO or EFWR */
 #define SSCR1_EFWR		(1 << 14)	/* Enable FIFO Write/Read */
diff --git a/include/linux/raid/md_p.h b/include/linux/raid/md_p.h
index ffa2efb..75cbf4f 100644
--- a/include/linux/raid/md_p.h
+++ b/include/linux/raid/md_p.h
@@ -251,7 +251,7 @@ struct mdp_superblock_1 {
 	__le64	utime;		/* 40 bits second, 24 btes microseconds */
 	__le64	events;		/* incremented when superblock updated */
 	__le64	resync_offset;	/* data before this offset (from data_offset) known to be in sync */
-	__le32	sb_csum;	/* checksum upto devs[max_dev] */
+	__le32	sb_csum;	/* checksum up to devs[max_dev] */
 	__le32	max_dev;	/* size of devs[] array to consider */
 	__u8	pad3[64-32];	/* set to 0 when writing */
 
diff --git a/include/linux/reiserfs_fs.h b/include/linux/reiserfs_fs.h
index 0a3842a..eca75df 100644
--- a/include/linux/reiserfs_fs.h
+++ b/include/linux/reiserfs_fs.h
@@ -1557,7 +1557,7 @@ struct tree_balance {
 /* When inserting an item. */
 #define M_INSERT	'i'
 /* When inserting into (directories only) or appending onto an already
-   existant item. */
+   existent item. */
 #define M_PASTE		'p'
 /* When deleting an item. */
 #define M_DELETE	'd'
diff --git a/include/linux/sched.h b/include/linux/sched.h
index 83bd2e2..4ec2c02 100644
--- a/include/linux/sched.h
+++ b/include/linux/sched.h
@@ -854,7 +854,7 @@ extern int __weak arch_sd_sibiling_asym_packing(void);
 
 /*
  * Optimise SD flags for power savings:
- * SD_BALANCE_NEWIDLE helps agressive task consolidation and power savings.
+ * SD_BALANCE_NEWIDLE helps aggressive task consolidation and power savings.
  * Keep default SD flags if sched_{smt,mc}_power_saving=0
  */
 
diff --git a/include/linux/skbuff.h b/include/linux/skbuff.h
index d9e52fa..d0ae90a 100644
--- a/include/linux/skbuff.h
+++ b/include/linux/skbuff.h
@@ -474,7 +474,7 @@ static inline void skb_dst_set(struct sk_buff *skb, struct dst_entry *dst)
 extern void skb_dst_set_noref(struct sk_buff *skb, struct dst_entry *dst);
 
 /**
- * skb_dst_is_noref - Test if skb dst isnt refcounted
+ * skb_dst_is_noref - Test if skb dst isn't refcounted
  * @skb: buffer
  */
 static inline bool skb_dst_is_noref(const struct sk_buff *skb)
diff --git a/include/linux/smc91x.h b/include/linux/smc91x.h
index bc21db5..76199b7 100644
--- a/include/linux/smc91x.h
+++ b/include/linux/smc91x.h
@@ -21,7 +21,7 @@
 #define RPC_LED_10	(0x02)	/* LED = 10Mbps link detect */
 #define RPC_LED_FD	(0x03)	/* LED = Full Duplex Mode */
 #define RPC_LED_TX_RX	(0x04)	/* LED = TX or RX packet occurred */
-#define RPC_LED_100	(0x05)	/* LED = 100Mbps link dectect */
+#define RPC_LED_100	(0x05)	/* LED = 100Mbps link detect */
 #define RPC_LED_TX	(0x06)	/* LED = TX packet occurred */
 #define RPC_LED_RX	(0x07)	/* LED = RX packet occurred */
 
diff --git a/include/linux/socket.h b/include/linux/socket.h
index edbb1d0..d2b5e98 100644
--- a/include/linux/socket.h
+++ b/include/linux/socket.h
@@ -88,7 +88,7 @@ struct cmsghdr {
 };
 
 /*
- *	Ancilliary data object information MACROS
+ *	Ancillary data object information MACROS
  *	Table 5-14 of POSIX 1003.1g
  */
 
diff --git a/include/linux/soundcard.h b/include/linux/soundcard.h
index 1904afe..fe204fe 100644
--- a/include/linux/soundcard.h
+++ b/include/linux/soundcard.h
@@ -1231,7 +1231,7 @@ void seqbuf_dump(void);	/* This function must be provided by programs */
 #define SEQ_PANNING(dev, voice, pos) SEQ_CONTROL(dev, voice, CTL_PAN, (pos+128) / 2)
 
 /*
- * Timing and syncronization macros
+ * Timing and synchronization macros
  */
 
 #define _TIMER_EVENT(ev, parm)		{_SEQ_NEEDBUF(8);\
diff --git a/include/linux/spi/spidev.h b/include/linux/spi/spidev.h
index bf0570a..52d9ed0 100644
--- a/include/linux/spi/spidev.h
+++ b/include/linux/spi/spidev.h
@@ -66,7 +66,7 @@
  * are in a different address space (and may be of different sizes in some
  * cases, such as 32-bit i386 userspace over a 64-bit x86_64 kernel).
  * Zero-initialize the structure, including currently unused fields, to
- * accomodate potential future updates.
+ * accommodate potential future updates.
  *
  * SPI_IOC_MESSAGE gives userspace the equivalent of kernel spi_sync().
  * Pass it an array of related transfers, they'll execute together.
diff --git a/include/linux/spinlock.h b/include/linux/spinlock.h
index 80e5358..0b22d51 100644
--- a/include/linux/spinlock.h
+++ b/include/linux/spinlock.h
@@ -81,7 +81,7 @@
 #include <linux/spinlock_types.h>
 
 /*
- * Pull the arch_spin*() functions/declarations (UP-nondebug doesnt need them):
+ * Pull the arch_spin*() functions/declarations (UP-nondebug doesn't need them):
  */
 #ifdef CONFIG_SMP
 # include <asm/spinlock.h>
diff --git a/include/linux/stmmac.h b/include/linux/stmmac.h
index e103529..f29197a 100644
--- a/include/linux/stmmac.h
+++ b/include/linux/stmmac.h
@@ -26,7 +26,7 @@
 #ifndef __STMMAC_PLATFORM_DATA
 #define __STMMAC_PLATFORM_DATA
 
-/* platfrom data for platfrom device structure's platfrom_data field */
+/* platform data for platform device structure's platform_data field */
 
 /* Private data for the STM on-board ethernet driver */
 struct plat_stmmacenet_data {
diff --git a/include/linux/stop_machine.h b/include/linux/stop_machine.h
index 1808960..092dc9b 100644
--- a/include/linux/stop_machine.h
+++ b/include/linux/stop_machine.h
@@ -105,7 +105,7 @@ static inline int try_stop_cpus(const struct cpumask *cpumask,
  * @cpus: the cpus to run the @fn() on (NULL = any online cpu)
  *
  * Description: This causes a thread to be scheduled on every cpu,
- * each of which disables interrupts.  The result is that noone is
+ * each of which disables interrupts.  The result is that no one is
  * holding a spinlock or inside any other preempt-disabled region when
  * @fn() runs.
  *
diff --git a/include/linux/sunrpc/cache.h b/include/linux/sunrpc/cache.h
index 7898ea1..8d2eef1 100644
--- a/include/linux/sunrpc/cache.h
+++ b/include/linux/sunrpc/cache.h
@@ -35,10 +35,10 @@
  * Each cache must be registered so that it can be cleaned regularly.
  * When the cache is unregistered, it is flushed completely.
  *
- * Entries have a ref count and a 'hashed' flag which counts the existance
+ * Entries have a ref count and a 'hashed' flag which counts the existence
  * in the hash table.
  * We only expire entries when refcount is zero.
- * Existance in the cache is counted  the refcount.
+ * Existence in the cache is counted  the refcount.
  */
 
 /* Every cache item has a common header that is used
diff --git a/include/linux/sunrpc/svcauth_gss.h b/include/linux/sunrpc/svcauth_gss.h
index ca7d725..83bbee3 100644
--- a/include/linux/sunrpc/svcauth_gss.h
+++ b/include/linux/sunrpc/svcauth_gss.h
@@ -2,7 +2,7 @@
  * linux/include/linux/sunrpc/svcauth_gss.h
  *
  * Bruce Fields <bfields@umich.edu>
- * Copyright (c) 2002 The Regents of the Unviersity of Michigan
+ * Copyright (c) 2002 The Regents of the University of Michigan
  */
 
 #ifndef _LINUX_SUNRPC_SVCAUTH_GSS_H
diff --git a/include/linux/sysdev.h b/include/linux/sysdev.h
index 8a75da5..dfb078d 100644
--- a/include/linux/sysdev.h
+++ b/include/linux/sysdev.h
@@ -7,13 +7,13 @@
  * We still have a notion of a driver for a system device, because we still
  * want to perform basic operations on these devices. 
  *
- * We also support auxillary drivers binding to devices of a certain class.
+ * We also support auxiliary drivers binding to devices of a certain class.
  * 
  * This allows configurable drivers to register themselves for devices of
  * a certain type. And, it allows class definitions to reside in generic
  * code while arch-specific code can register specific drivers.
  *
- * Auxillary drivers registered with a NULL cls are registered as drivers
+ * Auxiliary drivers registered with a NULL cls are registered as drivers
  * for all system devices, and get notification calls for each device. 
  */
 
@@ -70,7 +70,7 @@ extern int sysdev_class_create_file(struct sysdev_class *,
 extern void sysdev_class_remove_file(struct sysdev_class *,
 	struct sysdev_class_attribute *);
 /**
- * Auxillary system device drivers.
+ * Auxiliary system device drivers.
  */
 
 struct sysdev_driver {
diff --git a/include/linux/timerqueue.h b/include/linux/timerqueue.h
index d24aaba..a520fd7 100644
--- a/include/linux/timerqueue.h
+++ b/include/linux/timerqueue.h
@@ -24,7 +24,7 @@ extern struct timerqueue_node *timerqueue_iterate_next(
 						struct timerqueue_node *node);
 
 /**
- * timerqueue_getnext - Returns the timer with the earlies expiration time
+ * timerqueue_getnext - Returns the timer with the earliest expiration time
  *
  * @head: head of timerqueue
  *
diff --git a/include/linux/tracehook.h b/include/linux/tracehook.h
index 3a2e66d..ebcfa4e 100644
--- a/include/linux/tracehook.h
+++ b/include/linux/tracehook.h
@@ -169,7 +169,7 @@ static inline int tracehook_unsafe_exec(struct task_struct *task)
  * tracehook_tracer_task - return the task that is tracing the given task
  * @tsk:		task to consider
  *
- * Returns NULL if noone is tracing @task, or the &struct task_struct
+ * Returns NULL if no one is tracing @task, or the &struct task_struct
  * pointer to its tracer.
  *
  * Must called under rcu_read_lock().  The pointer returned might be kept
@@ -448,7 +448,7 @@ static inline int tracehook_force_sigpending(void)
  *
  * Return zero to check for a real pending signal normally.
  * Return -1 after releasing the siglock to repeat the check.
- * Return a signal number to induce an artifical signal delivery,
+ * Return a signal number to induce an artificial signal delivery,
  * setting *@info and *@return_ka to specify its details and behavior.
  *
  * The @return_ka->sa_handler value controls the disposition of the
diff --git a/include/linux/ucb1400.h b/include/linux/ucb1400.h
index 1b47909..5c75153 100644
--- a/include/linux/ucb1400.h
+++ b/include/linux/ucb1400.h
@@ -8,7 +8,7 @@
  *  Copyright:	MontaVista Software, Inc.
  *
  * Spliting done by: Marek Vasut <marek.vasut@gmail.com>
- * If something doesnt work and it worked before spliting, e-mail me,
+ * If something doesn't work and it worked before spliting, e-mail me,
  * dont bother Nicolas please ;-)
  *
  * This program is free software; you can redistribute it and/or modify
diff --git a/include/linux/usb.h b/include/linux/usb.h
index e63efeb..65f78ca 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -623,7 +623,7 @@ extern struct usb_host_interface *usb_find_alt_setting(
  * USB hubs.  That makes it stay the same until systems are physically
  * reconfigured, by re-cabling a tree of USB devices or by moving USB host
  * controllers.  Adding and removing devices, including virtual root hubs
- * in host controller driver modules, does not change these path identifers;
+ * in host controller driver modules, does not change these path identifiers;
  * neither does rebooting or re-enumerating.  These are more useful identifiers
  * than changeable ("unstable") ones like bus numbers or device addresses.
  *
@@ -793,7 +793,7 @@ struct usbdrv_wrap {
  *	usb_set_intfdata() to associate driver-specific data with the
  *	interface.  It may also use usb_set_interface() to specify the
  *	appropriate altsetting.  If unwilling to manage the interface,
- *	return -ENODEV, if genuine IO errors occured, an appropriate
+ *	return -ENODEV, if genuine IO errors occurred, an appropriate
  *	negative errno value.
  * @disconnect: Called when the interface is no longer accessible, usually
  *	because its device has been (or is being) disconnected or the
diff --git a/include/linux/usb/composite.h b/include/linux/usb/composite.h
index 3d29a7d..882a084 100644
--- a/include/linux/usb/composite.h
+++ b/include/linux/usb/composite.h
@@ -188,7 +188,7 @@ ep_choose(struct usb_gadget *g, struct usb_endpoint_descriptor *hs,
  * @bind() method is then used to initialize all the functions and then
  * call @usb_add_function() for them.
  *
- * Those functions would normally be independant of each other, but that's
+ * Those functions would normally be independent of each other, but that's
  * not mandatory.  CDC WMC devices are an example where functions often
  * depend on other functions, with some functions subsidiary to others.
  * Such interdependency may be managed in any way, so long as all of the
diff --git a/include/linux/usb/ehci_def.h b/include/linux/usb/ehci_def.h
index 6563802..e49dfd4 100644
--- a/include/linux/usb/ehci_def.h
+++ b/include/linux/usb/ehci_def.h
@@ -159,7 +159,7 @@ struct ehci_regs {
 #define USBMODE_CM_IDLE	(0<<0)		/* idle state */
 
 /* Moorestown has some non-standard registers, partially due to the fact that
- * its EHCI controller has both TT and LPM support. HOSTPCx are extentions to
+ * its EHCI controller has both TT and LPM support. HOSTPCx are extensions to
  * PORTSCx
  */
 #define HOSTPC0		0x84		/* HOSTPC extension */
diff --git a/include/linux/usb/functionfs.h b/include/linux/usb/functionfs.h
index 6f649c1..7587ef9 100644
--- a/include/linux/usb/functionfs.h
+++ b/include/linux/usb/functionfs.h
@@ -45,7 +45,7 @@ struct usb_functionfs_descs_head {
  * | off | name      | type         | description                          |
  * |-----+-----------+--------------+--------------------------------------|
  * |   0 | magic     | LE32         | FUNCTIONFS_{FS,HS}_DESCRIPTORS_MAGIC |
- * |   4 | lenght    | LE32         | length of the whole data chunk       |
+ * |   4 | length    | LE32         | length of the whole data chunk       |
  * |   8 | fs_count  | LE32         | number of full-speed descriptors     |
  * |  12 | hs_count  | LE32         | number of high-speed descriptors     |
  * |  16 | fs_descrs | Descriptor[] | list of full-speed descriptors       |
@@ -86,7 +86,7 @@ struct usb_functionfs_strings_head {
  * |   0 | lang    | LE16              | language code                      |
  * |   2 | strings | String[str_count] | array of strings in given language |
  *
- * For each string ther is one strings entry (ie. there are str_count
+ * For each string there is one strings entry (ie. there are str_count
  * string entries).  Each String is a NUL terminated string encoded in
  * UTF-8.
  */
diff --git a/include/linux/usb/gadget.h b/include/linux/usb/gadget.h
index 006412c..e538172 100644
--- a/include/linux/usb/gadget.h
+++ b/include/linux/usb/gadget.h
@@ -72,7 +72,7 @@ struct usb_ep;
  * Bulk endpoints can use any size buffers, and can also be used for interrupt
  * transfers. interrupt-only endpoints can be much less functional.
  *
- * NOTE:  this is analagous to 'struct urb' on the host side, except that
+ * NOTE:  this is analogous to 'struct urb' on the host side, except that
  * it's thinner and promotes more pre-allocation.
  */
 
@@ -269,7 +269,7 @@ static inline void usb_ep_free_request(struct usb_ep *ep,
  *
  * Control endpoints ... after getting a setup() callback, the driver queues
  * one response (even if it would be zero length).  That enables the
- * status ack, after transfering data as specified in the response.  Setup
+ * status ack, after transferring data as specified in the response.  Setup
  * functions may return negative error codes to generate protocol stalls.
  * (Note that some USB device controllers disallow protocol stall responses
  * in some cases.)  When control responses are deferred (the response is
diff --git a/include/linux/usb/midi.h b/include/linux/usb/midi.h
index 1d10408..c8c52e3 100644
--- a/include/linux/usb/midi.h
+++ b/include/linux/usb/midi.h
@@ -70,7 +70,7 @@ struct usb_midi_out_jack_descriptor {
 	__u8  bJackID;
 	__u8  bNrInputPins;		/* p */
 	struct usb_midi_source_pin pins[]; /* [p] */
-	/*__u8  iJack;  -- ommitted due to variable-sized pins[] */
+	/*__u8  iJack;  -- omitted due to variable-sized pins[] */
 } __attribute__ ((packed));
 
 #define USB_DT_MIDI_OUT_SIZE(p)	(7 + 2 * (p))
diff --git a/include/linux/usb/wusb.h b/include/linux/usb/wusb.h
index 63ebdcc..0c4d4ca 100644
--- a/include/linux/usb/wusb.h
+++ b/include/linux/usb/wusb.h
@@ -126,7 +126,7 @@ enum {
 /**
  * WUSB IE: Channel Stop (WUSB1.0[7.5.8])
  *
- * Tells devices the host is going to stop sending MMCs and will dissapear.
+ * Tells devices the host is going to stop sending MMCs and will disappear.
  */
 struct wuie_channel_stop {
 	struct wuie_hdr hdr;
diff --git a/include/linux/uwb.h b/include/linux/uwb.h
index 7fc9746..b0c564e 100644
--- a/include/linux/uwb.h
+++ b/include/linux/uwb.h
@@ -274,7 +274,7 @@ static inline void uwb_mas_bm_copy_le(void *dst, const struct uwb_mas_bm *mas)
 
 /**
  * struct uwb_drp_avail - a radio controller's view of MAS usage
- * @global:   MAS unused by neighbors (excluding reservations targetted
+ * @global:   MAS unused by neighbors (excluding reservations targeted
  *            or owned by the local radio controller) or the beaon period
  * @local:    MAS unused by local established reservations
  * @pending:  MAS unused by local pending reservations
@@ -702,10 +702,10 @@ void edc_init(struct edc *edc)
 	edc->timestart = jiffies;
 }
 
-/* Called when an error occured.
+/* Called when an error occurred.
  * This is way to determine if the number of acceptable errors per time
  * period has been exceeded. It is not accurate as there are cases in which
- * this scheme will not work, for example if there are periodic occurences
+ * this scheme will not work, for example if there are periodic occurrences
  * of errors that straddle updates to the start time. This scheme is
  * sufficient for our usage.
  *
diff --git a/include/linux/uwb/umc.h b/include/linux/uwb/umc.h
index 4b4fc0f..7b48420 100644
--- a/include/linux/uwb/umc.h
+++ b/include/linux/uwb/umc.h
@@ -132,7 +132,7 @@ int umc_match_pci_id(struct umc_driver *umc_drv, struct umc_dev *umc);
  *
  * FIXME: This is as dirty as it gets, but we need some way to check
  * the correct type of umc_dev->parent (so that for example, we can
- * cast to pci_dev). Casting to pci_dev is necesary because at some
+ * cast to pci_dev). Casting to pci_dev is necessary because at some
  * point we need to request resources from the device. Mapping is
  * easily over come (ioremap and stuff are bus agnostic), but hooking
  * up to some error handlers (such as pci error handlers) might need
diff --git a/include/linux/vgaarb.h b/include/linux/vgaarb.h
index e9e1524..9c3120d 100644
--- a/include/linux/vgaarb.h
+++ b/include/linux/vgaarb.h
@@ -78,7 +78,7 @@ extern void vga_set_legacy_decoding(struct pci_dev *pdev,
  *     wether the card is doing legacy decoding for that type of resource. If
  *     yes, the lock is "converted" into a legacy resource lock.
  *     The arbiter will first look for all VGA cards that might conflict
- *     and disable their IOs and/or Memory access, inlcuding VGA forwarding
+ *     and disable their IOs and/or Memory access, including VGA forwarding
  *     on P2P bridges if necessary, so that the requested resources can
  *     be used. Then, the card is marked as locking these resources and
  *     the IO and/or Memory accesse are enabled on the card (including
@@ -187,7 +187,7 @@ extern struct pci_dev *vga_default_device(void);
  *     vga_conflicts
  *
  *     Architectures should define this if they have several
- *     independant PCI domains that can afford concurrent VGA
+ *     independent PCI domains that can afford concurrent VGA
  *     decoding
  */
 
diff --git a/include/linux/wimax.h b/include/linux/wimax.h
index 4fdcc56..9f6b77a 100644
--- a/include/linux/wimax.h
+++ b/include/linux/wimax.h
@@ -114,7 +114,7 @@ enum {
 	WIMAX_GNL_RESET_IFIDX = 1,
 };
 
-/* Atributes for wimax_state_get() */
+/* Attributes for wimax_state_get() */
 enum {
 	WIMAX_GNL_STGET_IFIDX = 1,
 };
diff --git a/include/linux/xilinxfb.h b/include/linux/xilinxfb.h
index f2463f5..5a155a9 100644
--- a/include/linux/xilinxfb.h
+++ b/include/linux/xilinxfb.h
@@ -16,7 +16,7 @@
 /* ML300/403 reference design framebuffer driver platform data struct */
 struct xilinxfb_platform_data {
 	u32 rotate_screen;	/* Flag to rotate display 180 degrees */
-	u32 screen_height_mm;	/* Physical dimentions of screen in mm */
+	u32 screen_height_mm;	/* Physical dimensions of screen in mm */
 	u32 screen_width_mm;
 	u32 xres, yres;		/* resolution of screen in pixels */
 	u32 xvirt, yvirt;	/* resolution of memory buffer */
diff --git a/include/media/davinci/dm355_ccdc.h b/include/media/davinci/dm355_ccdc.h
index df8a7b1..adf2fe4 100644
--- a/include/media/davinci/dm355_ccdc.h
+++ b/include/media/davinci/dm355_ccdc.h
@@ -193,7 +193,7 @@ struct ccdc_dft_corr_mem_ctl {
 #define CCDC_DFT_TABLE_SIZE	16
 /*
  * Main Structure for vertical defect correction. Vertical defect
- * correction can correct upto 16 defects if defects less than 16
+ * correction can correct up to 16 defects if defects less than 16
  * then pad the rest with 0
  */
 struct ccdc_vertical_dft {
diff --git a/include/media/davinci/isif.h b/include/media/davinci/isif.h
index b0b74ad..7f3d76a4 100644
--- a/include/media/davinci/isif.h
+++ b/include/media/davinci/isif.h
@@ -199,7 +199,7 @@ struct isif_black_clamp {
 };
 
 /*************************************************************************
-** Color Space Convertion (CSC)
+** Color Space Conversion (CSC)
 *************************************************************************/
 #define ISIF_CSC_NUM_COEFF	16
 struct isif_color_space_conv {
diff --git a/include/media/lirc.h b/include/media/lirc.h
index 6678a169..4b3ab29 100644
--- a/include/media/lirc.h
+++ b/include/media/lirc.h
@@ -137,7 +137,7 @@
  */
 #define LIRC_SET_REC_FILTER_SPACE      _IOW('i', 0x0000001b, __u32)
 /*
- * if filter cannot be set independantly for pulse/space, this should
+ * if filter cannot be set independently for pulse/space, this should
  * be used
  */
 #define LIRC_SET_REC_FILTER            _IOW('i', 0x0000001c, __u32)
diff --git a/include/net/9p/9p.h b/include/net/9p/9p.h
index 6b75a69..cdf2e8a 100644
--- a/include/net/9p/9p.h
+++ b/include/net/9p/9p.h
@@ -119,7 +119,7 @@ do { \
  * @P9_TREAD: request to transfer data from a file or directory
  * @P9_RREAD: response with data requested
  * @P9_TWRITE: reuqest to transfer data to a file
- * @P9_RWRITE: response with out much data was transfered to file
+ * @P9_RWRITE: response with out much data was transferred to file
  * @P9_TCLUNK: forget about a handle to an entity within the file system
  * @P9_RCLUNK: response when server has forgotten about the handle
  * @P9_TREMOVE: request to remove an entity from the hierarchy
@@ -294,7 +294,7 @@ enum p9_perm_t {
  *
  * QID types are a subset of permissions - they are primarily
  * used to differentiate semantics for a file system entity via
- * a jump-table.  Their value is also the most signifigant 16 bits
+ * a jump-table.  Their value is also the most significant 16 bits
  * of the permission_t
  *
  * See Also: http://plan9.bell-labs.com/magic/man2html/2/stat
@@ -366,8 +366,8 @@ struct p9_qid {
 /**
  * struct p9_stat - file system metadata information
  * @size: length prefix for this stat structure instance
- * @type: the type of the server (equivilent to a major number)
- * @dev: the sub-type of the server (equivilent to a minor number)
+ * @type: the type of the server (equivalent to a major number)
+ * @dev: the sub-type of the server (equivalent to a minor number)
  * @qid: unique id from the server of type &p9_qid
  * @mode: Plan 9 format permissions of type &p9_perm_t
  * @atime: Last access/read time
diff --git a/include/net/9p/client.h b/include/net/9p/client.h
index 0a30977..85c1413 100644
--- a/include/net/9p/client.h
+++ b/include/net/9p/client.h
@@ -101,7 +101,7 @@ enum p9_req_status_t {
  * Transport use an array to track outstanding requests
  * instead of a list.  While this may incurr overhead during initial
  * allocation or expansion, it makes request lookup much easier as the
- * tag id is a index into an array.  (We use tag+1 so that we can accomodate
+ * tag id is a index into an array.  (We use tag+1 so that we can accommodate
  * the -1 tag for the T_VERSION request).
  * This also has the nice effect of only having to allocate wait_queues
  * once, instead of constantly allocating and freeing them.  Its possible
diff --git a/include/net/9p/transport.h b/include/net/9p/transport.h
index 82868f1..8f08c73 100644
--- a/include/net/9p/transport.h
+++ b/include/net/9p/transport.h
@@ -30,7 +30,7 @@
 
 /* Default. Add Payload to PDU before sending it down to transport layer */
 #define P9_TRANS_PREF_PAYLOAD_DEF  0x0
-/* Send pay load seperately to transport layer along with PDU.*/
+/* Send pay load separately to transport layer along with PDU.*/
 #define P9_TRANS_PREF_PAYLOAD_SEP  0x1
 
 /**
diff --git a/include/net/caif/cfcnfg.h b/include/net/caif/cfcnfg.h
index f688478..f33d363 100644
--- a/include/net/caif/cfcnfg.h
+++ b/include/net/caif/cfcnfg.h
@@ -69,7 +69,7 @@ void cfcnfg_remove(struct cfcnfg *cfg);
  *		cfcnfg_add_adapt_layer to specify PHY for the link.
  * @pref:	The phy (link layer) preference.
  * @fcs:	Specify if checksum is used in CAIF Framing Layer.
- * @stx:	Specify if Start Of Frame eXtention is used.
+ * @stx:	Specify if Start Of Frame extension is used.
  */
 
 void
diff --git a/include/net/gen_stats.h b/include/net/gen_stats.h
index fa15771..a79b6cf 100644
--- a/include/net/gen_stats.h
+++ b/include/net/gen_stats.h
@@ -11,7 +11,7 @@ struct gnet_dump {
 	struct sk_buff *  skb;
 	struct nlattr *   tail;
 
-	/* Backward compatability */
+	/* Backward compatibility */
 	int               compat_tc_stats;
 	int               compat_xstats;
 	void *            xstats;
diff --git a/include/net/ip_vs.h b/include/net/ip_vs.h
index 30b49ed..814b434 100644
--- a/include/net/ip_vs.h
+++ b/include/net/ip_vs.h
@@ -92,7 +92,7 @@ static inline struct net *skb_sknet(const struct sk_buff *skb)
 }
 /*
  * This one needed for single_open_net since net is stored directly in
- * private not as a struct i.e. seq_file_net cant be used.
+ * private not as a struct i.e. seq_file_net can't be used.
  */
 static inline struct net *seq_file_single_net(struct seq_file *seq)
 {
diff --git a/include/net/irda/irlap.h b/include/net/irda/irlap.h
index 17fcd96..fb4b76d 100644
--- a/include/net/irda/irlap.h
+++ b/include/net/irda/irlap.h
@@ -204,7 +204,7 @@ struct irlap_cb {
 
 	notify_t notify; /* Callbacks to IrLMP */
 
-	int    mtt_required;  /* Minumum turnaround time required */
+	int    mtt_required;  /* Minimum turnaround time required */
 	int    xbofs_delay;   /* Nr of XBOF's used to MTT */
 	int    bofs_count;    /* Negotiated extra BOFs */
 	int    next_bofs;     /* Negotiated extra BOFs after next frame */
diff --git a/include/net/irda/wrapper.h b/include/net/irda/wrapper.h
index 2942ad6..eef53eb 100644
--- a/include/net/irda/wrapper.h
+++ b/include/net/irda/wrapper.h
@@ -42,7 +42,7 @@
 
 #define IRDA_TRANS 0x20    /* Asynchronous transparency modifier */       
 
-/* States for receving a frame in async mode */
+/* States for receiving a frame in async mode */
 enum {
 	OUTSIDE_FRAME, 
 	BEGIN_FRAME, 
diff --git a/include/net/iucv/iucv.h b/include/net/iucv/iucv.h
index 205a336..1121baa 100644
--- a/include/net/iucv/iucv.h
+++ b/include/net/iucv/iucv.h
@@ -173,7 +173,7 @@ struct iucv_handler {
 	/*
 	 * The message_pending function is called after an icuv interrupt
 	 * type 0x06 or type 0x07 has been received. A new message is
-	 * availabe and can be received with iucv_message_receive.
+	 * available and can be received with iucv_message_receive.
 	 */
 	void (*message_pending)(struct iucv_path *, struct iucv_message *);
 	/*
diff --git a/include/net/iw_handler.h b/include/net/iw_handler.h
index 3afdb21..5d5a6a4 100644
--- a/include/net/iw_handler.h
+++ b/include/net/iw_handler.h
@@ -91,7 +91,7 @@
  * --------------------
  * The implementation goals were as follow :
  *	o Obvious : you should not need a PhD to understand what's happening,
- *		the benefit is easier maintainance.
+ *		the benefit is easier maintenance.
  *	o Flexible : it should accommodate a wide variety of driver
  *		implementations and be as flexible as the old API.
  *	o Lean : it should be efficient memory wise to minimise the impact
@@ -129,7 +129,7 @@
  *
  * Functions prototype uses union iwreq_data
  * -----------------------------------------
- * Some would have prefered functions defined this way :
+ * Some would have preferred functions defined this way :
  *	static int mydriver_ioctl_setrate(struct net_device *dev, 
  *					  long rate, int auto)
  * 1) The kernel code doesn't "validate" the content of iwreq_data, and
diff --git a/include/net/mac80211.h b/include/net/mac80211.h
index cefe1b3..cb13239 100644
--- a/include/net/mac80211.h
+++ b/include/net/mac80211.h
@@ -1294,7 +1294,7 @@ ieee80211_get_alt_retry_rate(const struct ieee80211_hw *hw,
  * acceleration (i.e. iwlwifi). Those drivers should provide update_tkip_key
  * handler.
  * The update_tkip_key() call updates the driver with the new phase 1 key.
- * This happens everytime the iv16 wraps around (every 65536 packets). The
+ * This happens every time the iv16 wraps around (every 65536 packets). The
  * set_key() call will happen only once for each key (unless the AP did
  * rekeying), it will not include a valid phase 1 key. The valid phase 1 key is
  * provided by update_tkip_key only. The trigger that makes mac80211 call this
diff --git a/include/net/pkt_sched.h b/include/net/pkt_sched.h
index d9549af..65afc49 100644
--- a/include/net/pkt_sched.h
+++ b/include/net/pkt_sched.h
@@ -32,7 +32,7 @@ static inline void *qdisc_priv(struct Qdisc *q)
    
    The result: [34]86 is not good choice for QoS router :-(
 
-   The things are not so bad, because we may use artifical
+   The things are not so bad, because we may use artificial
    clock evaluated by integration of network data flow
    in the most critical places.
  */
diff --git a/include/net/sock.h b/include/net/sock.h
index da0534d..01810a3 100644
--- a/include/net/sock.h
+++ b/include/net/sock.h
@@ -1749,7 +1749,7 @@ void sock_net_set(struct sock *sk, struct net *net)
 
 /*
  * Kernel sockets, f.e. rtnl or icmp_socket, are a part of a namespace.
- * They should not hold a referrence to a namespace in order to allow
+ * They should not hold a reference to a namespace in order to allow
  * to stop it.
  * Sockets after sk_change_net should be released using sk_release_kernel
  */
diff --git a/include/net/transp_v6.h b/include/net/transp_v6.h
index eeb077d..a8122dc 100644
--- a/include/net/transp_v6.h
+++ b/include/net/transp_v6.h
@@ -16,7 +16,7 @@ extern struct proto tcpv6_prot;
 
 struct flowi6;
 
-/* extention headers */
+/* extension headers */
 extern int				ipv6_exthdrs_init(void);
 extern void				ipv6_exthdrs_exit(void);
 extern int				ipv6_frag_init(void);
diff --git a/include/net/wimax.h b/include/net/wimax.h
index 3461aa1..c799ba7 100644
--- a/include/net/wimax.h
+++ b/include/net/wimax.h
@@ -286,7 +286,7 @@ struct wimax_dev;
  *     does not disconnect the device from the bus and return 0.
  *     If that fails, it should resort to some sort of cold or bus
  *     reset (even if it implies a bus disconnection and device
- *     dissapearance). In that case, -ENODEV should be returned to
+ *     disappearance). In that case, -ENODEV should be returned to
  *     indicate the device is gone.
  *     This operation has to be synchronous, and return only when the
  *     reset is complete. In case of having had to resort to bus/cold
diff --git a/include/net/wpan-phy.h b/include/net/wpan-phy.h
index 8592623..d86fffd 100644
--- a/include/net/wpan-phy.h
+++ b/include/net/wpan-phy.h
@@ -28,7 +28,7 @@ struct wpan_phy {
 	struct mutex pib_lock;
 
 	/*
-	 * This is a PIB acording to 802.15.4-2006.
+	 * This is a PIB according to 802.15.4-2006.
 	 * We do not provide timing-related variables, as they
 	 * aren't used outside of driver
 	 */
diff --git a/include/rxrpc/packet.h b/include/rxrpc/packet.h
index 9b2c308..f2902ef 100644
--- a/include/rxrpc/packet.h
+++ b/include/rxrpc/packet.h
@@ -148,7 +148,7 @@ struct rxkad_challenge {
  * Kerberos security type-2 response packet
  */
 struct rxkad_response {
-	__be32		version;	/* version of this reponse type */
+	__be32		version;	/* version of this response type */
 	__be32		__pad;
 
 	/* encrypted bit of the response */
diff --git a/include/scsi/fc/fc_fcp.h b/include/scsi/fc/fc_fcp.h
index 8a143ca..652dec2 100644
--- a/include/scsi/fc/fc_fcp.h
+++ b/include/scsi/fc/fc_fcp.h
@@ -75,7 +75,7 @@ struct fcp_cmnd32 {
 #define	FCP_PTA_SIMPLE	    0	/* simple task attribute */
 #define	FCP_PTA_HEADQ	    1	/* head of queue task attribute */
 #define	FCP_PTA_ORDERED     2	/* ordered task attribute */
-#define	FCP_PTA_ACA	    4	/* auto. contigent allegiance */
+#define	FCP_PTA_ACA	    4	/* auto. contingent allegiance */
 #define	FCP_PTA_MASK	    7	/* mask for task attribute field */
 #define	FCP_PRI_SHIFT	    3	/* priority field starts in bit 3 */
 #define	FCP_PRI_RESVD_MASK  0x80	/* reserved bits in priority field */
diff --git a/include/scsi/iscsi_if.h b/include/scsi/iscsi_if.h
index c3e1cbc..ddb0456 100644
--- a/include/scsi/iscsi_if.h
+++ b/include/scsi/iscsi_if.h
@@ -292,7 +292,7 @@ enum iscsi_param {
 	ISCSI_PARAM_PERSISTENT_PORT,
 	ISCSI_PARAM_SESS_RECOVERY_TMO,
 
-	/* pased in through bind conn using transport_fd */
+	/* passed in through bind conn using transport_fd */
 	ISCSI_PARAM_CONN_PORT,
 	ISCSI_PARAM_CONN_ADDRESS,
 
diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index 24193c1..a3cbda4 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -260,7 +260,7 @@ struct fcoe_dev_stats {
 /**
  * struct fc_seq_els_data - ELS data used for passing ELS specific responses
  * @reason: The reason for rejection
- * @explan: The explaination of the rejection
+ * @explan: The explanation of the rejection
  *
  * Mainly used by the exchange manager layer.
  */
@@ -525,7 +525,7 @@ struct libfc_function_template {
 			struct fc_frame *);
 
 	/*
-	 * Send an ELS response using infomation from the received frame.
+	 * Send an ELS response using information from the received frame.
 	 *
 	 * STATUS: OPTIONAL
 	 */
@@ -663,7 +663,7 @@ struct libfc_function_template {
 	int (*rport_logoff)(struct fc_rport_priv *);
 
 	/*
-	 * Recieve a request from a remote port.
+	 * Receive a request from a remote port.
 	 *
 	 * STATUS: OPTIONAL
 	 */
@@ -704,7 +704,7 @@ struct libfc_function_template {
 					 void *));
 
 	/*
-	 * Cleanup the FCP layer, used durring link down and reset
+	 * Cleanup the FCP layer, used during link down and reset
 	 *
 	 * STATUS: OPTIONAL
 	 */
diff --git a/include/scsi/libiscsi_tcp.h b/include/scsi/libiscsi_tcp.h
index e6b9fd2..ac0cc1d 100644
--- a/include/scsi/libiscsi_tcp.h
+++ b/include/scsi/libiscsi_tcp.h
@@ -52,7 +52,7 @@ struct iscsi_segment {
 	iscsi_segment_done_fn_t	*done;
 };
 
-/* Socket connection recieve helper */
+/* Socket connection receive helper */
 struct iscsi_tcp_recv {
 	struct iscsi_hdr	*hdr;
 	struct iscsi_segment	segment;
diff --git a/include/scsi/osd_initiator.h b/include/scsi/osd_initiator.h
index 53a9e88..0a50799 100644
--- a/include/scsi/osd_initiator.h
+++ b/include/scsi/osd_initiator.h
@@ -265,7 +265,7 @@ int osd_execute_request_async(struct osd_request *or,
  * @osi           - Recievs a more detailed error report information (optional).
  * @silent        - Do not print to dmsg (Even if enabled)
  * @bad_obj_list  - Some commands act on multiple objects. Failed objects will
- *                  be recieved here (optional)
+ *                  be received here (optional)
  * @max_obj       - Size of @bad_obj_list.
  * @bad_attr_list - List of failing attributes (optional)
  * @max_attr      - Size of @bad_attr_list.
diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index e7e3858..f1f2644 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -46,7 +46,7 @@ struct blk_queue_tags;
 enum {
 	SCSI_QDEPTH_DEFAULT,	/* default requested change, e.g. from sysfs */
 	SCSI_QDEPTH_QFULL,	/* scsi-ml requested due to queue full */
-	SCSI_QDEPTH_RAMP_UP,	/* scsi-ml requested due to threshhold event */
+	SCSI_QDEPTH_RAMP_UP,	/* scsi-ml requested due to threshold event */
 };
 
 struct scsi_host_template {
diff --git a/include/scsi/scsi_transport_fc.h b/include/scsi/scsi_transport_fc.h
index 59816fe..2a65167 100644
--- a/include/scsi/scsi_transport_fc.h
+++ b/include/scsi/scsi_transport_fc.h
@@ -192,9 +192,9 @@ struct fc_vport_identifiers {
  *
  * This structure exists for each FC port is a virtual FC port. Virtual
  * ports share the physical link with the Physical port. Each virtual
- * ports has a unique presense on the SAN, and may be instantiated via
+ * ports has a unique presence on the SAN, and may be instantiated via
  * NPIV, Virtual Fabrics, or via additional ALPAs. As the vport is a
- * unique presense, each vport has it's own view of the fabric,
+ * unique presence, each vport has it's own view of the fabric,
  * authentication privilege, and priorities.
  *
  * A virtual port may support 1 or more FC4 roles. Typically it is a
@@ -370,7 +370,7 @@ struct fc_rport {	/* aka fc_starget_attrs */
 /*
  * FC SCSI Target Attributes
  *
- * The SCSI Target is considered an extention of a remote port (as
+ * The SCSI Target is considered an extension of a remote port (as
  * a remote port can be more than a SCSI Target). Within the scsi
  * subsystem, we leave the Target as a separate entity. Doing so
  * provides backward compatibility with prior FC transport api's,
diff --git a/include/sound/ac97_codec.h b/include/sound/ac97_codec.h
index f1dcefe4..02cbb50 100644
--- a/include/sound/ac97_codec.h
+++ b/include/sound/ac97_codec.h
@@ -385,7 +385,7 @@
 #define AC97_SCAP_DETECT_BY_VENDOR (1<<8) /* use vendor registers for read tests */
 #define AC97_SCAP_NO_SPDIF	(1<<9)	/* don't build SPDIF controls */
 #define AC97_SCAP_EAPD_LED	(1<<10)	/* EAPD as mute LED */
-#define AC97_SCAP_POWER_SAVE	(1<<11)	/* capable for aggresive power-saving */
+#define AC97_SCAP_POWER_SAVE	(1<<11)	/* capable for aggressive power-saving */
 
 /* ac97->flags */
 #define AC97_HAS_PC_BEEP	(1<<0)	/* force PC Speaker usage */
diff --git a/include/sound/control.h b/include/sound/control.h
index e67db28..404acb8 100644
--- a/include/sound/control.h
+++ b/include/sound/control.h
@@ -191,7 +191,7 @@ int _snd_ctl_add_slave(struct snd_kcontrol *master, struct snd_kcontrol *slave,
  * Returns zero if successful or a negative error code.
  *
  * All slaves must be the same type (returning the same information
- * via info callback).  The fucntion doesn't check it, so it's your
+ * via info callback).  The function doesn't check it, so it's your
  * responsibility.
  *
  * Also, some additional limitations:
diff --git a/include/sound/cs46xx_dsp_spos.h b/include/sound/cs46xx_dsp_spos.h
index 49b03c9..8008c59 100644
--- a/include/sound/cs46xx_dsp_spos.h
+++ b/include/sound/cs46xx_dsp_spos.h
@@ -147,7 +147,7 @@ struct dsp_pcm_channel_descriptor {
 };
 
 struct dsp_spos_instance {
-	struct dsp_symbol_desc symbol_table; /* currently availble loaded symbols in SP */
+	struct dsp_symbol_desc symbol_table; /* currently available loaded symbols in SP */
 
 	int nmodules;
 	struct dsp_module_desc * modules; /* modules loaded into SP */
diff --git a/include/sound/hdspm.h b/include/sound/hdspm.h
index 1774ff5..1f59ea2 100644
--- a/include/sound/hdspm.h
+++ b/include/sound/hdspm.h
@@ -193,7 +193,7 @@ struct hdspm_version {
  * 32768 Bytes
  */
 
-/* organisation is 64 channelfader in a continous memory block */
+/* organisation is 64 channelfader in a continuous memory block */
 /* equivalent to hardware definition, maybe for future feature of mmap of
  * them
  */
diff --git a/include/sound/soc-dapm.h b/include/sound/soc-dapm.h
index ddc2b3d..f72c103 100644
--- a/include/sound/soc-dapm.h
+++ b/include/sound/soc-dapm.h
@@ -23,7 +23,7 @@
 /*
  * SoC dynamic audio power management
  *
- * We can have upto 4 power domains
+ * We can have up to 4 power domains
  * 	1. Codec domain - VREF, VMID
  *     Usually controlled at codec probe/remove, although can be set
  *     at stream time if power is not needed for sidetone, etc.
diff --git a/include/target/target_core_base.h b/include/target/target_core_base.h
index c15ed50..1d3b5b2 100644
--- a/include/target/target_core_base.h
+++ b/include/target/target_core_base.h
@@ -22,7 +22,7 @@
  * Note that both include/scsi/scsi_cmnd.h:MAX_COMMAND_SIZE and
  * include/linux/blkdev.h:BLOCK_MAX_CDB as of v2.6.36-rc4 still use
  * 16-byte CDBs by default and require an extra allocation for
- * 32-byte CDBs to becasue of legacy issues.
+ * 32-byte CDBs to because of legacy issues.
  *
  * Within TCM Core there are no such legacy limitiations, so we go ahead
  * use 32-byte CDBs by default and use include/scsi/scsi.h:scsi_command_size()
@@ -302,7 +302,7 @@ struct t10_wwn {
 
 
 /*
- * Used by TCM Core internally to signal if >= SPC-3 peristent reservations
+ * Used by TCM Core internally to signal if >= SPC-3 persistent reservations
  * emulation is enabled or disabled, or running in with TCM/pSCSI passthrough
  * mode
  */
@@ -934,7 +934,7 @@ struct se_portal_group {
 	struct list_head	acl_node_list;
 	struct se_lun		*tpg_lun_list;
 	struct se_lun		tpg_virt_lun0;
-	/* List of TCM sessions assoicated wth this TPG */
+	/* List of TCM sessions associated wth this TPG */
 	struct list_head	tpg_sess_list;
 	/* Pointer to $FABRIC_MOD dependent code */
 	struct target_core_fabric_ops *se_tpg_tfo;
diff --git a/include/target/target_core_fabric_ops.h b/include/target/target_core_fabric_ops.h
index 5eb8b1a..dc78f77 100644
--- a/include/target/target_core_fabric_ops.h
+++ b/include/target/target_core_fabric_ops.h
@@ -35,7 +35,7 @@ struct target_core_fabric_ops {
 	/*
 	 * Optional function pointer for TCM to perform command map
 	 * from TCM processing thread context, for those struct se_cmd
-	 * initally allocated in interrupt context.
+	 * initially allocated in interrupt context.
 	 */
 	int (*new_cmd_map)(struct se_cmd *);
 	/*
diff --git a/include/video/kyro.h b/include/video/kyro.h
index dba7de2..c563968 100644
--- a/include/video/kyro.h
+++ b/include/video/kyro.h
@@ -32,7 +32,7 @@ struct kyrofb_info {
 	u32 PIXCLK;	/* Pixel Clock       */
 	u32 HCLK;	/* Hor Clock         */
 
-	/* Usefull to hold depth here for Linux */
+	/* Useful to hold depth here for Linux */
 	u8 PIXDEPTH;
 
 #ifdef CONFIG_MTRR
diff --git a/include/video/neomagic.h b/include/video/neomagic.h
index 08b6637..bc5013e 100644
--- a/include/video/neomagic.h
+++ b/include/video/neomagic.h
@@ -129,7 +129,7 @@ struct neofb_par {
 	unsigned char CRTC[25];		/* Crtc Controller */
 	unsigned char Sequencer[5];	/* Video Sequencer */
 	unsigned char Graphics[9];	/* Video Graphics */
-	unsigned char Attribute[21];	/* Video Atribute */
+	unsigned char Attribute[21];	/* Video Attribute */
 
 	unsigned char GeneralLockReg;
 	unsigned char ExtCRTDispAddr;
diff --git a/include/video/newport.h b/include/video/newport.h
index 001b935..3d7c4b4 100644
--- a/include/video/newport.h
+++ b/include/video/newport.h
@@ -5,7 +5,7 @@
  *
  * Copyright (C) 1996 David S. Miller (dm@engr.sgi.com)
  * 
- * Ulf Carlsson - Compability with the IRIX structures added
+ * Ulf Carlsson - Compatibility with the IRIX structures added
  */
 
 #ifndef _SGI_NEWPORT_H
diff --git a/include/video/sisfb.h b/include/video/sisfb.h
index fdd74f1..6dc5df9 100644
--- a/include/video/sisfb.h
+++ b/include/video/sisfb.h
@@ -151,7 +151,7 @@ struct sisfb_cmd {
 	__u32  sisfb_result[4];
 };
 
-/* Addtional IOCTLs for communication sisfb <> X driver                */
+/* Additional IOCTLs for communication sisfb <> X driver                */
 /* If changing this, vgatypes.h must also be changed (for X driver)    */
 
 /* ioctl for identifying and giving some info (esp. memory heap start) */
diff --git a/include/video/sstfb.h b/include/video/sstfb.h
index b52f073..c449eac 100644
--- a/include/video/sstfb.h
+++ b/include/video/sstfb.h
@@ -156,7 +156,7 @@
 #define DAC_READ		FBIINIT2	/* in remap mode */
 #define FBIINIT3		0x021c		/* fbi controls */
 #  define DISABLE_TEXTURE	  BIT(6)
-#  define Y_SWAP_ORIGIN_SHIFT	  22		/* Y swap substraction value */
+#  define Y_SWAP_ORIGIN_SHIFT	  22		/* Y swap subtraction value */
 #define HSYNC			0x0220
 #define VSYNC			0x0224
 #define DAC_DATA		0x022c
@@ -212,9 +212,9 @@
 #  define DACREG_CR0_24BPP	  0x50		/* mode 5 */
 #define	DACREG_CR1_I		0x05
 #define DACREG_CC_I		0x06
-#  define DACREG_CC_CLKA	  BIT(7)	/* clk A controled by regs */
+#  define DACREG_CC_CLKA	  BIT(7)	/* clk A controlled by regs */
 #  define DACREG_CC_CLKA_C	  (2<<4)	/* clk A uses reg C */
-#  define DACREG_CC_CLKB	  BIT(3)	/* clk B controled by regs */
+#  define DACREG_CC_CLKB	  BIT(3)	/* clk B controlled by regs */
 #  define DACREG_CC_CLKB_D	  3		/* clkB uses reg D */
 #define DACREG_AC0_I		0x48		/* clock A reg C */
 #define DACREG_AC1_I		0x49
diff --git a/include/xen/interface/elfnote.h b/include/xen/interface/elfnote.h
index 7a8262c..0360b15 100644
--- a/include/xen/interface/elfnote.h
+++ b/include/xen/interface/elfnote.h
@@ -51,7 +51,7 @@
 
 /*
  * The offset of the ELF paddr field from the acutal required
- * psuedo-physical address (numeric).
+ * pseudo-physical address (numeric).
  *
  * This is used to maintain backwards compatibility with older kernels
  * which wrote __PAGE_OFFSET into that field. This field defaults to 0
diff --git a/init/do_mounts.c b/init/do_mounts.c
index 3e01121..c0851a8 100644
--- a/init/do_mounts.c
+++ b/init/do_mounts.c
@@ -186,7 +186,7 @@ dev_t name_to_dev_t(char *name)
 		goto done;
 
 	/*
-	 * try non-existant, but valid partition, which may only exist
+	 * try non-existent, but valid partition, which may only exist
 	 * after revalidating the disk, like partitioned md devices
 	 */
 	while (p > s && isdigit(p[-1]))
diff --git a/ipc/msg.c b/ipc/msg.c
index 0e732e9..7385de2 100644
--- a/ipc/msg.c
+++ b/ipc/msg.c
@@ -704,7 +704,7 @@ long do_msgsnd(int msqid, long mtype, void __user *mtext,
 	msq->q_stime = get_seconds();
 
 	if (!pipelined_send(msq, msg)) {
-		/* noone is waiting for this message, enqueue it */
+		/* no one is waiting for this message, enqueue it */
 		list_add_tail(&msg->m_list, &msq->q_messages);
 		msq->q_cbytes += msgsz;
 		msq->q_qnum++;
@@ -842,7 +842,7 @@ long do_msgrcv(int msqid, long *pmtype, void __user *mtext,
 		 * Disable preemption.  We don't hold a reference to the queue
 		 * and getting a reference would defeat the idea of a lockless
 		 * operation, thus the code relies on rcu to guarantee the
-		 * existance of msq:
+		 * existence of msq:
 		 * Prior to destruction, expunge_all(-EIRDM) changes r_msg.
 		 * Thus if r_msg is -EAGAIN, then the queue not yet destroyed.
 		 * rcu_read_lock() prevents preemption between reading r_msg
diff --git a/ipc/sem.c b/ipc/sem.c
index ae040a0..34193ed 100644
--- a/ipc/sem.c
+++ b/ipc/sem.c
@@ -1362,7 +1362,7 @@ SYSCALL_DEFINE4(semtimedop, int, semid, struct sembuf __user *, tsops,
 	 * semid identifiers are not unique - find_alloc_undo may have
 	 * allocated an undo structure, it was invalidated by an RMID
 	 * and now a new array with received the same id. Check and fail.
-	 * This case can be detected checking un->semid. The existance of
+	 * This case can be detected checking un->semid. The existence of
 	 * "un" itself is guaranteed by rcu.
 	 */
 	error = -EIDRM;
diff --git a/ipc/shm.c b/ipc/shm.c
index 8644452..729acb7 100644
--- a/ipc/shm.c
+++ b/ipc/shm.c
@@ -1056,7 +1056,7 @@ SYSCALL_DEFINE1(shmdt, char __user *, shmaddr)
 	/*
 	 * We need look no further than the maximum address a fragment
 	 * could possibly have landed at. Also cast things to loff_t to
-	 * prevent overflows and make comparisions vs. equal-width types.
+	 * prevent overflows and make comparisons vs. equal-width types.
 	 */
 	size = PAGE_ALIGN(size);
 	while (vma && (loff_t)(vma->vm_end - addr) <= size) {
diff --git a/kernel/audit_tree.c b/kernel/audit_tree.c
index 37b2bea..e99dda0 100644
--- a/kernel/audit_tree.c
+++ b/kernel/audit_tree.c
@@ -607,7 +607,7 @@ void audit_trim_trees(void)
 		spin_lock(&hash_lock);
 		list_for_each_entry(node, &tree->chunks, list) {
 			struct audit_chunk *chunk = find_chunk(node);
-			/* this could be NULL if the watch is dieing else where... */
+			/* this could be NULL if the watch is dying else where... */
 			struct inode *inode = chunk->mark.i.inode;
 			node->index |= 1U<<31;
 			if (iterate_mounts(compare_root, inode, root_mnt))
diff --git a/kernel/auditsc.c b/kernel/auditsc.c
index f49a031..b33513a 100644
--- a/kernel/auditsc.c
+++ b/kernel/auditsc.c
@@ -1011,7 +1011,7 @@ static int audit_log_pid_context(struct audit_context *context, pid_t pid,
 /*
  * to_send and len_sent accounting are very loose estimates.  We aren't
  * really worried about a hard cap to MAX_EXECVE_AUDIT_LEN so much as being
- * within about 500 bytes (next page boundry)
+ * within about 500 bytes (next page boundary)
  *
  * why snprintf?  an int is up to 12 digits long.  if we just assumed when
  * logging that a[%d]= was going to be 16 characters long we would be wasting
diff --git a/kernel/cgroup.c b/kernel/cgroup.c
index e31b220..25c7eb5 100644
--- a/kernel/cgroup.c
+++ b/kernel/cgroup.c
@@ -157,7 +157,7 @@ struct css_id {
 };
 
 /*
- * cgroup_event represents events which userspace want to recieve.
+ * cgroup_event represents events which userspace want to receive.
  */
 struct cgroup_event {
 	/*
diff --git a/kernel/cpu.c b/kernel/cpu.c
index c95fc4d..12b7458 100644
--- a/kernel/cpu.c
+++ b/kernel/cpu.c
@@ -126,7 +126,7 @@ static void cpu_hotplug_done(void)
 #else /* #if CONFIG_HOTPLUG_CPU */
 static void cpu_hotplug_begin(void) {}
 static void cpu_hotplug_done(void) {}
-#endif	/* #esle #if CONFIG_HOTPLUG_CPU */
+#endif	/* #else #if CONFIG_HOTPLUG_CPU */
 
 /* Need to know about CPUs going up/down? */
 int __ref register_cpu_notifier(struct notifier_block *nb)
diff --git a/kernel/debug/debug_core.c b/kernel/debug/debug_core.c
index cefd4a1..bad6786 100644
--- a/kernel/debug/debug_core.c
+++ b/kernel/debug/debug_core.c
@@ -538,7 +538,7 @@ return_normal:
 
 	/*
 	 * For single stepping, try to only enter on the processor
-	 * that was single stepping.  To gaurd against a deadlock, the
+	 * that was single stepping.  To guard against a deadlock, the
 	 * kernel will only try for the value of sstep_tries before
 	 * giving up and continuing on.
 	 */
diff --git a/kernel/debug/kdb/kdb_main.c b/kernel/debug/kdb/kdb_main.c
index 6bc6e3b..be14779 100644
--- a/kernel/debug/kdb/kdb_main.c
+++ b/kernel/debug/kdb/kdb_main.c
@@ -441,9 +441,9 @@ static int kdb_check_regs(void)
  *	symbol name, and offset to the caller.
  *
  *	The argument may consist of a numeric value (decimal or
- *	hexidecimal), a symbol name, a register name (preceeded by the
+ *	hexidecimal), a symbol name, a register name (preceded by the
  *	percent sign), an environment variable with a numeric value
- *	(preceeded by a dollar sign) or a simple arithmetic expression
+ *	(preceded by a dollar sign) or a simple arithmetic expression
  *	consisting of a symbol name, +/-, and a numeric constant value
  *	(offset).
  * Parameters:
@@ -1335,7 +1335,7 @@ void kdb_print_state(const char *text, int value)
  *	error		The hardware-defined error code
  *	reason2		kdb's current reason code.
  *			Initially error but can change
- *			acording to kdb state.
+ *			according to kdb state.
  *	db_result	Result code from break or debug point.
  *	regs		The exception frame at time of fault/breakpoint.
  *			should always be valid.
diff --git a/kernel/debug/kdb/kdb_support.c b/kernel/debug/kdb/kdb_support.c
index 6b2485d..5532dd3 100644
--- a/kernel/debug/kdb/kdb_support.c
+++ b/kernel/debug/kdb/kdb_support.c
@@ -545,7 +545,7 @@ int kdb_putword(unsigned long addr, unsigned long word, size_t size)
  *	Mask for process state.
  * Notes:
  *	The mask folds data from several sources into a single long value, so
- *	be carefull not to overlap the bits.  TASK_* bits are in the LSB,
+ *	be careful not to overlap the bits.  TASK_* bits are in the LSB,
  *	special cases like UNRUNNABLE are in the MSB.  As of 2.6.10-rc1 there
  *	is no overlap between TASK_* and EXIT_* but that may not always be
  *	true, so EXIT_* bits are shifted left 16 bits before being stored in
diff --git a/kernel/exit.c b/kernel/exit.c
index 6a488ad..f5d2f63 100644
--- a/kernel/exit.c
+++ b/kernel/exit.c
@@ -841,7 +841,7 @@ static void exit_notify(struct task_struct *tsk, int group_dead)
 	/* Let father know we died
 	 *
 	 * Thread signals are configurable, but you aren't going to use
-	 * that to send signals to arbitary processes.
+	 * that to send signals to arbitrary processes.
 	 * That stops right now.
 	 *
 	 * If the parent exec id doesn't match the exec id we saved
diff --git a/kernel/irq/chip.c b/kernel/irq/chip.c
index 1dafc86..4af1e2b 100644
--- a/kernel/irq/chip.c
+++ b/kernel/irq/chip.c
@@ -415,7 +415,7 @@ out:
  *	@desc:	the interrupt description structure for this irq
  *
  *	Interrupt occures on the falling and/or rising edge of a hardware
- *	signal. The occurence is latched into the irq controller hardware
+ *	signal. The occurrence is latched into the irq controller hardware
  *	and must be acked in order to be reenabled. After the ack another
  *	interrupt can happen on the same source even before the first one
  *	is handled by the associated event handler. If this happens it
diff --git a/kernel/irq/manage.c b/kernel/irq/manage.c
index 12a80fd..07c1611 100644
--- a/kernel/irq/manage.c
+++ b/kernel/irq/manage.c
@@ -1051,6 +1051,7 @@ __setup_irq(unsigned int irq, struct irq_desc *desc, struct irqaction *new)
 	register_irq_proc(irq, desc);
 	new->dir = NULL;
 	register_handler_proc(irq, new);
+	free_cpumask_var(mask);
 
 	return 0;
 
diff --git a/kernel/irq/migration.c b/kernel/irq/migration.c
index bc61946..4742090 100644
--- a/kernel/irq/migration.c
+++ b/kernel/irq/migration.c
@@ -35,7 +35,7 @@ void irq_move_masked_irq(struct irq_data *idata)
 	 * do the disable, re-program, enable sequence.
 	 * This is *not* particularly important for level triggered
 	 * but in a edge trigger case, we might be setting rte
-	 * when an active trigger is comming in. This could
+	 * when an active trigger is coming in. This could
 	 * cause some ioapics to mal-function.
 	 * Being paranoid i guess!
 	 *
diff --git a/kernel/kexec.c b/kernel/kexec.c
index 4e240a3..55936f9 100644
--- a/kernel/kexec.c
+++ b/kernel/kexec.c
@@ -144,7 +144,7 @@ static int do_kimage_alloc(struct kimage **rimage, unsigned long entry,
 	/* Initialize the list of destination pages */
 	INIT_LIST_HEAD(&image->dest_pages);
 
-	/* Initialize the list of unuseable pages */
+	/* Initialize the list of unusable pages */
 	INIT_LIST_HEAD(&image->unuseable_pages);
 
 	/* Read in the segments */
@@ -454,7 +454,7 @@ static struct page *kimage_alloc_normal_control_pages(struct kimage *image,
 	/* Deal with the destination pages I have inadvertently allocated.
 	 *
 	 * Ideally I would convert multi-page allocations into single
-	 * page allocations, and add everyting to image->dest_pages.
+	 * page allocations, and add everything to image->dest_pages.
 	 *
 	 * For now it is simpler to just free the pages.
 	 */
@@ -602,7 +602,7 @@ static void kimage_free_extra_pages(struct kimage *image)
 	/* Walk through and free any extra destination pages I may have */
 	kimage_free_page_list(&image->dest_pages);
 
-	/* Walk through and free any unuseable pages I have cached */
+	/* Walk through and free any unusable pages I have cached */
 	kimage_free_page_list(&image->unuseable_pages);
 
 }
diff --git a/kernel/kthread.c b/kernel/kthread.c
index 684ab3f..3b34d27 100644
--- a/kernel/kthread.c
+++ b/kernel/kthread.c
@@ -139,7 +139,7 @@ static void create_kthread(struct kthread_create_info *create)
  * in @node, to get NUMA affinity for kthread stack, or else give -1.
  * When woken, the thread will run @threadfn() with @data as its
  * argument. @threadfn() can either call do_exit() directly if it is a
- * standalone thread for which noone will call kthread_stop(), or
+ * standalone thread for which no one will call kthread_stop(), or
  * return when 'kthread_should_stop()' is true (which means
  * kthread_stop() has been called).  The return value should be zero
  * or a negative error number; it will be passed to kthread_stop().
diff --git a/kernel/latencytop.c b/kernel/latencytop.c
index ee74b35..376066e 100644
--- a/kernel/latencytop.c
+++ b/kernel/latencytop.c
@@ -153,7 +153,7 @@ static inline void store_stacktrace(struct task_struct *tsk,
 }
 
 /**
- * __account_scheduler_latency - record an occured latency
+ * __account_scheduler_latency - record an occurred latency
  * @tsk - the task struct of the task hitting the latency
  * @usecs - the duration of the latency in microseconds
  * @inter - 1 if the sleep was interruptible, 0 if uninterruptible
diff --git a/kernel/lockdep.c b/kernel/lockdep.c
index 0d2058d..53a6895 100644
--- a/kernel/lockdep.c
+++ b/kernel/lockdep.c
@@ -2309,7 +2309,7 @@ void trace_hardirqs_on_caller(unsigned long ip)
 	if (unlikely(curr->hardirqs_enabled)) {
 		/*
 		 * Neither irq nor preemption are disabled here
-		 * so this is racy by nature but loosing one hit
+		 * so this is racy by nature but losing one hit
 		 * in a stat is not a big deal.
 		 */
 		__debug_atomic_inc(redundant_hardirqs_on);
@@ -2620,7 +2620,7 @@ static int mark_lock(struct task_struct *curr, struct held_lock *this,
 	if (!graph_lock())
 		return 0;
 	/*
-	 * Make sure we didnt race:
+	 * Make sure we didn't race:
 	 */
 	if (unlikely(hlock_class(this)->usage_mask & new_mask)) {
 		graph_unlock();
diff --git a/kernel/module.c b/kernel/module.c
index 1f9f7bc..d5938a5 100644
--- a/kernel/module.c
+++ b/kernel/module.c
@@ -809,7 +809,7 @@ SYSCALL_DEFINE2(delete_module, const char __user *, name_user,
 		wait_for_zero_refcount(mod);
 
 	mutex_unlock(&module_mutex);
-	/* Final destruction now noone is using it. */
+	/* Final destruction now no one is using it. */
 	if (mod->exit != NULL)
 		mod->exit();
 	blocking_notifier_call_chain(&module_notify_list,
@@ -2777,7 +2777,7 @@ static struct module *load_module(void __user *umod,
 	mod->state = MODULE_STATE_COMING;
 
 	/* Now sew it into the lists so we can get lockdep and oops
-	 * info during argument parsing.  Noone should access us, since
+	 * info during argument parsing.  No one should access us, since
 	 * strong_try_module_get() will fail.
 	 * lockdep/oops can run asynchronous, so use the RCU list insertion
 	 * function to insert in a way safe to concurrent readers.
@@ -2971,7 +2971,7 @@ static const char *get_ksymbol(struct module *mod,
 	else
 		nextval = (unsigned long)mod->module_core+mod->core_text_size;
 
-	/* Scan for closest preceeding symbol, and next symbol. (ELF
+	/* Scan for closest preceding symbol, and next symbol. (ELF
 	   starts real symbols at 1). */
 	for (i = 1; i < mod->num_symtab; i++) {
 		if (mod->symtab[i].st_shndx == SHN_UNDEF)
diff --git a/kernel/mutex.c b/kernel/mutex.c
index a5889fb..c4195fa 100644
--- a/kernel/mutex.c
+++ b/kernel/mutex.c
@@ -245,7 +245,7 @@ __mutex_lock_common(struct mutex *lock, long state, unsigned int subclass,
 		}
 		__set_task_state(task, state);
 
-		/* didnt get the lock, go to sleep: */
+		/* didn't get the lock, go to sleep: */
 		spin_unlock_mutex(&lock->wait_lock, flags);
 		preempt_enable_no_resched();
 		schedule();
diff --git a/kernel/padata.c b/kernel/padata.c
index 7510194..b91941d 100644
--- a/kernel/padata.c
+++ b/kernel/padata.c
@@ -262,7 +262,7 @@ static void padata_reorder(struct parallel_data *pd)
 		/*
 		 * This cpu has to do the parallel processing of the next
 		 * object. It's waiting in the cpu's parallelization queue,
-		 * so exit imediately.
+		 * so exit immediately.
 		 */
 		if (PTR_ERR(padata) == -ENODATA) {
 			del_timer(&pd->timer);
@@ -284,7 +284,7 @@ static void padata_reorder(struct parallel_data *pd)
 	/*
 	 * The next object that needs serialization might have arrived to
 	 * the reorder queues in the meantime, we will be called again
-	 * from the timer function if noone else cares for it.
+	 * from the timer function if no one else cares for it.
 	 */
 	if (atomic_read(&pd->reorder_objects)
 			&& !(pinst->flags & PADATA_RESET))
@@ -515,7 +515,7 @@ static void __padata_stop(struct padata_instance *pinst)
 	put_online_cpus();
 }
 
-/* Replace the internal control stucture with a new one. */
+/* Replace the internal control structure with a new one. */
 static void padata_replace(struct padata_instance *pinst,
 			   struct parallel_data *pd_new)
 {
@@ -768,7 +768,7 @@ static int __padata_remove_cpu(struct padata_instance *pinst, int cpu)
 }
 
  /**
- * padata_remove_cpu - remove a cpu from the one or both(serial and paralell)
+ * padata_remove_cpu - remove a cpu from the one or both(serial and parallel)
  *                     padata cpumasks.
  *
  * @pinst: padata instance
diff --git a/kernel/params.c b/kernel/params.c
index 0da1411..7ab388a 100644
--- a/kernel/params.c
+++ b/kernel/params.c
@@ -95,7 +95,7 @@ static int parse_one(char *param,
 	/* Find parameter */
 	for (i = 0; i < num_params; i++) {
 		if (parameq(param, params[i].name)) {
-			/* Noone handled NULL, so do it here. */
+			/* No one handled NULL, so do it here. */
 			if (!val && params[i].ops->set != param_set_bool)
 				return -EINVAL;
 			DEBUGP("They are equal!  Calling %p\n",
diff --git a/kernel/posix-cpu-timers.c b/kernel/posix-cpu-timers.c
index 67fea9d..0791b13 100644
--- a/kernel/posix-cpu-timers.c
+++ b/kernel/posix-cpu-timers.c
@@ -1347,7 +1347,7 @@ void run_posix_cpu_timers(struct task_struct *tsk)
 
 	/*
 	 * Now that all the timers on our list have the firing flag,
-	 * noone will touch their list entries but us.  We'll take
+	 * no one will touch their list entries but us.  We'll take
 	 * each timer's lock before clearing its firing flag, so no
 	 * timer call will interfere.
 	 */
diff --git a/kernel/posix-timers.c b/kernel/posix-timers.c
index 4c01249..e5498d7 100644
--- a/kernel/posix-timers.c
+++ b/kernel/posix-timers.c
@@ -313,7 +313,7 @@ static void schedule_next_timer(struct k_itimer *timr)
  * restarted (i.e. we have flagged this in the sys_private entry of the
  * info block).
  *
- * To protect aginst the timer going away while the interrupt is queued,
+ * To protect against the timer going away while the interrupt is queued,
  * we require that the it_requeue_pending flag be set.
  */
 void do_schedule_next_timer(struct siginfo *info)
diff --git a/kernel/power/main.c b/kernel/power/main.c
index 8eaba5f..de9aef8 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -224,7 +224,7 @@ power_attr(state);
  * writing to 'state'.  It first should read from 'wakeup_count' and store
  * the read value.  Then, after carrying out its own preparations for the system
  * transition to a sleep state, it should write the stored value to
- * 'wakeup_count'.  If that fails, at least one wakeup event has occured since
+ * 'wakeup_count'.  If that fails, at least one wakeup event has occurred since
  * 'wakeup_count' was read and 'state' should not be written to.  Otherwise, it
  * is allowed to write to 'state', but the transition will be aborted if there
  * are any wakeup events detected after 'wakeup_count' was written to.
diff --git a/kernel/sched.c b/kernel/sched.c
index a884551..4801363 100644
--- a/kernel/sched.c
+++ b/kernel/sched.c
@@ -2309,7 +2309,7 @@ unsigned long wait_task_inactive(struct task_struct *p, long match_state)
  * Cause a process which is running on another CPU to enter
  * kernel-mode, without any delay. (to get signals handled.)
  *
- * NOTE: this function doesnt have to take the runqueue lock,
+ * NOTE: this function doesn't have to take the runqueue lock,
  * because all it wants to ensure is that the remote task enters
  * the kernel. If the IPI races and the task has been migrated
  * to another CPU then no harm is done and the purpose has been
@@ -4997,7 +4997,7 @@ recheck:
 	 */
 	raw_spin_lock_irqsave(&p->pi_lock, flags);
 	/*
-	 * To be able to change p->policy safely, the apropriate
+	 * To be able to change p->policy safely, the appropriate
 	 * runqueue lock must be held.
 	 */
 	rq = __task_rq_lock(p);
@@ -5716,7 +5716,7 @@ void show_state_filter(unsigned long state_filter)
 	do_each_thread(g, p) {
 		/*
 		 * reset the NMI-timeout, listing all files on a slow
-		 * console might take alot of time:
+		 * console might take a lot of time:
 		 */
 		touch_nmi_watchdog();
 		if (!state_filter || (p->state & state_filter))
@@ -6331,6 +6331,9 @@ migration_call(struct notifier_block *nfb, unsigned long action, void *hcpu)
 		break;
 #endif
 	}
+
+	update_max_interval();
+
 	return NOTIFY_OK;
 }
 
diff --git a/kernel/sched_autogroup.c b/kernel/sched_autogroup.c
index 5946ac5..429242f 100644
--- a/kernel/sched_autogroup.c
+++ b/kernel/sched_autogroup.c
@@ -179,7 +179,7 @@ void sched_autogroup_create_attach(struct task_struct *p)
 	struct autogroup *ag = autogroup_create();
 
 	autogroup_move_group(p, ag);
-	/* drop extra refrence added by autogroup_create() */
+	/* drop extra reference added by autogroup_create() */
 	autogroup_kref_put(ag);
 }
 EXPORT_SYMBOL(sched_autogroup_create_attach);
diff --git a/kernel/sched_fair.c b/kernel/sched_fair.c
index c7ec5c8..7f00772 100644
--- a/kernel/sched_fair.c
+++ b/kernel/sched_fair.c
@@ -3062,7 +3062,7 @@ static inline void calculate_imbalance(struct sd_lb_stats *sds, int this_cpu,
 
 	/*
 	 * if *imbalance is less than the average load per runnable task
-	 * there is no gaurantee that any tasks will be moved so we'll have
+	 * there is no guarantee that any tasks will be moved so we'll have
 	 * a think about bumping its value to force at least one task to be
 	 * moved
 	 */
@@ -3820,6 +3820,17 @@ void select_nohz_load_balancer(int stop_tick)
 
 static DEFINE_SPINLOCK(balancing);
 
+static unsigned long __read_mostly max_load_balance_interval = HZ/10;
+
+/*
+ * Scale the max load_balance interval with the number of CPUs in the system.
+ * This trades load-balance latency on larger machines for less cross talk.
+ */
+static void update_max_interval(void)
+{
+	max_load_balance_interval = HZ*num_online_cpus()/10;
+}
+
 /*
  * It checks each scheduling domain to see if it is due to be balanced,
  * and initiates a balancing operation if so.
@@ -3849,10 +3860,7 @@ static void rebalance_domains(int cpu, enum cpu_idle_type idle)
 
 		/* scale ms to jiffies */
 		interval = msecs_to_jiffies(interval);
-		if (unlikely(!interval))
-			interval = 1;
-		if (interval > HZ*num_online_cpus()/10)
-			interval = HZ*num_online_cpus()/10;
+		interval = clamp(interval, 1UL, max_load_balance_interval);
 
 		need_serialize = sd->flags & SD_SERIALIZE;
 
diff --git a/kernel/sched_rt.c b/kernel/sched_rt.c
index db308cb..e7cebdc 100644
--- a/kernel/sched_rt.c
+++ b/kernel/sched_rt.c
@@ -1378,7 +1378,7 @@ retry:
 		task = pick_next_pushable_task(rq);
 		if (task_cpu(next_task) == rq->cpu && task == next_task) {
 			/*
-			 * If we get here, the task hasnt moved at all, but
+			 * If we get here, the task hasn't moved at all, but
 			 * it has failed to push.  We will not try again,
 			 * since the other cpus will pull from us when they
 			 * are ready.
@@ -1488,7 +1488,7 @@ static int pull_rt_task(struct rq *this_rq)
 			/*
 			 * We continue with the search, just in
 			 * case there's an even higher prio task
-			 * in another runqueue. (low likelyhood
+			 * in another runqueue. (low likelihood
 			 * but possible)
 			 */
 		}
diff --git a/kernel/signal.c b/kernel/signal.c
index dc17929..7165af5 100644
--- a/kernel/signal.c
+++ b/kernel/signal.c
@@ -1887,7 +1887,7 @@ relock:
 	for (;;) {
 		struct k_sigaction *ka;
 		/*
-		 * Tracing can induce an artifical signal and choose sigaction.
+		 * Tracing can induce an artificial signal and choose sigaction.
 		 * The return value in @signr determines the default action,
 		 * but @info->si_signo is the signal number we will report.
 		 */
@@ -2711,8 +2711,8 @@ out:
 /**
  *  sys_rt_sigaction - alter an action taken by a process
  *  @sig: signal to be sent
- *  @act: the thread group ID of the thread
- *  @oact: the PID of the thread
+ *  @act: new sigaction
+ *  @oact: used to save the previous sigaction
  *  @sigsetsize: size of sigset_t type
  */
 SYSCALL_DEFINE4(rt_sigaction, int, sig,
diff --git a/kernel/softirq.c b/kernel/softirq.c
index 735d870..174f976 100644
--- a/kernel/softirq.c
+++ b/kernel/softirq.c
@@ -567,7 +567,7 @@ static void __tasklet_hrtimer_trampoline(unsigned long data)
 /**
  * tasklet_hrtimer_init - Init a tasklet/hrtimer combo for softirq callbacks
  * @ttimer:	 tasklet_hrtimer which is initialized
- * @function:	 hrtimer callback funtion which gets called from softirq context
+ * @function:	 hrtimer callback function which gets called from softirq context
  * @which_clock: clock id (CLOCK_MONOTONIC/CLOCK_REALTIME)
  * @mode:	 hrtimer mode (HRTIMER_MODE_ABS/HRTIMER_MODE_REL)
  */
diff --git a/kernel/time/jiffies.c b/kernel/time/jiffies.c
index b2fa506..a470154 100644
--- a/kernel/time/jiffies.c
+++ b/kernel/time/jiffies.c
@@ -34,7 +34,7 @@
  * inaccuracies caused by missed or lost timer
  * interrupts and the inability for the timer
  * interrupt hardware to accuratly tick at the
- * requested HZ value. It is also not reccomended
+ * requested HZ value. It is also not recommended
  * for "tick-less" systems.
  */
 #define NSEC_PER_JIFFY	((u32)((((u64)NSEC_PER_SEC)<<8)/ACTHZ))
diff --git a/kernel/time/timer_stats.c b/kernel/time/timer_stats.c
index 2f3b585..a5d0a3a 100644
--- a/kernel/time/timer_stats.c
+++ b/kernel/time/timer_stats.c
@@ -236,7 +236,7 @@ void timer_stats_update_stats(void *timer, pid_t pid, void *startf,
 			      unsigned int timer_flag)
 {
 	/*
-	 * It doesnt matter which lock we take:
+	 * It doesn't matter which lock we take:
 	 */
 	raw_spinlock_t *lock;
 	struct entry *entry, input;
diff --git a/kernel/trace/ftrace.c b/kernel/trace/ftrace.c
index c075f4e..ee24fa1 100644
--- a/kernel/trace/ftrace.c
+++ b/kernel/trace/ftrace.c
@@ -1268,7 +1268,7 @@ static int ftrace_update_code(struct module *mod)
 		p->flags = 0L;
 
 		/*
-		 * Do the initial record convertion from mcount jump
+		 * Do the initial record conversion from mcount jump
 		 * to the NOP instructions.
 		 */
 		if (!ftrace_code_disable(mod, p)) {
@@ -3425,7 +3425,7 @@ graph_init_task(struct task_struct *t, struct ftrace_ret_stack *ret_stack)
 	atomic_set(&t->tracing_graph_pause, 0);
 	atomic_set(&t->trace_overrun, 0);
 	t->ftrace_timestamp = 0;
-	/* make curr_ret_stack visable before we add the ret_stack */
+	/* make curr_ret_stack visible before we add the ret_stack */
 	smp_wmb();
 	t->ret_stack = ret_stack;
 }
diff --git a/kernel/trace/ring_buffer.c b/kernel/trace/ring_buffer.c
index d9c8bca..0ef7b4b 100644
--- a/kernel/trace/ring_buffer.c
+++ b/kernel/trace/ring_buffer.c
@@ -1478,7 +1478,7 @@ static inline unsigned long rb_page_entries(struct buffer_page *bpage)
 	return local_read(&bpage->entries) & RB_WRITE_MASK;
 }
 
-/* Size is determined by what has been commited */
+/* Size is determined by what has been committed */
 static inline unsigned rb_page_size(struct buffer_page *bpage)
 {
 	return rb_page_commit(bpage);
@@ -2932,7 +2932,7 @@ rb_get_reader_page(struct ring_buffer_per_cpu *cpu_buffer)
 	/*
 	 * cpu_buffer->pages just needs to point to the buffer, it
 	 *  has no specific buffer page to point to. Lets move it out
-	 *  of our way so we don't accidently swap it.
+	 *  of our way so we don't accidentally swap it.
 	 */
 	cpu_buffer->pages = reader->list.prev;
 
diff --git a/kernel/trace/trace.c b/kernel/trace/trace.c
index 9541c27..d38c16a 100644
--- a/kernel/trace/trace.c
+++ b/kernel/trace/trace.c
@@ -3239,7 +3239,7 @@ waitagain:
 		trace_seq_init(&iter->seq);
 
 	/*
-	 * If there was nothing to send to user, inspite of consuming trace
+	 * If there was nothing to send to user, in spite of consuming trace
 	 * entries, go back to wait for more entries.
 	 */
 	if (sret == -EBUSY)
diff --git a/kernel/trace/trace_clock.c b/kernel/trace/trace_clock.c
index 685a67d..6302747 100644
--- a/kernel/trace/trace_clock.c
+++ b/kernel/trace/trace_clock.c
@@ -46,7 +46,7 @@ u64 notrace trace_clock_local(void)
 }
 
 /*
- * trace_clock(): 'inbetween' trace clock. Not completely serialized,
+ * trace_clock(): 'between' trace clock. Not completely serialized,
  * but not completely incorrect when crossing CPUs either.
  *
  * This is based on cpu_clock(), which will allow at most ~1 jiffy of
diff --git a/kernel/trace/trace_entries.h b/kernel/trace/trace_entries.h
index 1516cb3..e32744c 100644
--- a/kernel/trace/trace_entries.h
+++ b/kernel/trace/trace_entries.h
@@ -27,7 +27,7 @@
  *	  in the structure.
  *
  *   * for structures within structures, the format of the internal
- *	structure is layed out. This allows the internal structure
+ *	structure is laid out. This allows the internal structure
  *	to be deciphered for the format file. Although these macros
  *	may become out of sync with the internal structure, they
  *	will create a compile error if it happens. Since the
diff --git a/kernel/trace/trace_functions_graph.c b/kernel/trace/trace_functions_graph.c
index 76b0598..962cdb2 100644
--- a/kernel/trace/trace_functions_graph.c
+++ b/kernel/trace/trace_functions_graph.c
@@ -905,7 +905,7 @@ print_graph_prologue(struct trace_iterator *iter, struct trace_seq *s,
  *
  * returns 1 if
  *  - we are inside irq code
- *  - we just extered irq code
+ *  - we just entered irq code
  *
  * retunns 0 if
  *  - funcgraph-interrupts option is set
diff --git a/kernel/trace/trace_irqsoff.c b/kernel/trace/trace_irqsoff.c
index 92b6e1e..a4969b4 100644
--- a/kernel/trace/trace_irqsoff.c
+++ b/kernel/trace/trace_irqsoff.c
@@ -80,7 +80,7 @@ static struct tracer_flags tracer_flags = {
  * skip the latency if the sequence has changed - some other section
  * did a maximum and could disturb our measurement with serial console
  * printouts, etc. Truly coinciding maximum latencies should be rare
- * and what happens together happens separately as well, so this doesnt
+ * and what happens together happens separately as well, so this doesn't
  * decrease the validity of the maximum found:
  */
 static __cacheline_aligned_in_smp	unsigned long max_sequence;
diff --git a/kernel/trace/trace_kprobe.c b/kernel/trace/trace_kprobe.c
index 8435b43..35d55a3 100644
--- a/kernel/trace/trace_kprobe.c
+++ b/kernel/trace/trace_kprobe.c
@@ -1839,7 +1839,7 @@ static void unregister_probe_event(struct trace_probe *tp)
 	kfree(tp->call.print_fmt);
 }
 
-/* Make a debugfs interface for controling probe points */
+/* Make a debugfs interface for controlling probe points */
 static __init int init_kprobe_trace(void)
 {
 	struct dentry *d_tracer;
diff --git a/kernel/user-return-notifier.c b/kernel/user-return-notifier.c
index eb27fd3..92cb706 100644
--- a/kernel/user-return-notifier.c
+++ b/kernel/user-return-notifier.c
@@ -20,7 +20,7 @@ EXPORT_SYMBOL_GPL(user_return_notifier_register);
 
 /*
  * Removes a registered user return notifier.  Must be called from atomic
- * context, and from the same cpu registration occured in.
+ * context, and from the same cpu registration occurred in.
  */
 void user_return_notifier_unregister(struct user_return_notifier *urn)
 {
diff --git a/kernel/wait.c b/kernel/wait.c
index b0310eb..f45ea8d 100644
--- a/kernel/wait.c
+++ b/kernel/wait.c
@@ -142,7 +142,7 @@ EXPORT_SYMBOL(finish_wait);
  * woken up through the queue.
  *
  * This prevents waiter starvation where an exclusive waiter
- * aborts and is woken up concurrently and noone wakes up
+ * aborts and is woken up concurrently and no one wakes up
  * the next waiter.
  */
 void abort_exclusive_wait(wait_queue_head_t *q, wait_queue_t *wait,
diff --git a/kernel/workqueue.c b/kernel/workqueue.c
index 04ef830..8859a41 100644
--- a/kernel/workqueue.c
+++ b/kernel/workqueue.c
@@ -1291,7 +1291,7 @@ __acquires(&gcwq->lock)
 			return true;
 		spin_unlock_irq(&gcwq->lock);
 
-		/* CPU has come up inbetween, retry migration */
+		/* CPU has come up in between, retry migration */
 		cpu_relax();
 	}
 }
diff --git a/lib/bitmap.c b/lib/bitmap.c
index 741fae9..91e0ccf 100644
--- a/lib/bitmap.c
+++ b/lib/bitmap.c
@@ -830,7 +830,7 @@ EXPORT_SYMBOL(bitmap_bitremap);
  *  @orig (i.e. bits 3, 5, 7 and 9) were also set.
  *
  *  When bit 11 is set in @orig, it means turn on the bit in
- *  @dst corresponding to whatever is the twelth bit that is
+ *  @dst corresponding to whatever is the twelfth bit that is
  *  turned on in @relmap.  In the above example, there were
  *  only ten bits turned on in @relmap (30..39), so that bit
  *  11 was set in @orig had no affect on @dst.
diff --git a/lib/btree.c b/lib/btree.c
index c9c6f03..2a34392 100644
--- a/lib/btree.c
+++ b/lib/btree.c
@@ -11,7 +11,7 @@
  * see http://programming.kicks-ass.net/kernel-patches/vma_lookup/btree.patch
  *
  * A relatively simple B+Tree implementation.  I have written it as a learning
- * excercise to understand how B+Trees work.  Turned out to be useful as well.
+ * exercise to understand how B+Trees work.  Turned out to be useful as well.
  *
  * B+Trees can be used similar to Linux radix trees (which don't have anything
  * in common with textbook radix trees, beware).  Prerequisite for them working
@@ -541,7 +541,7 @@ static void rebalance(struct btree_head *head, struct btree_geo *geo,
 	int i, no_left, no_right;
 
 	if (fill == 0) {
-		/* Because we don't steal entries from a neigbour, this case
+		/* Because we don't steal entries from a neighbour, this case
 		 * can happen.  Parent node contains a single child, this
 		 * node, so merging with a sibling never happens.
 		 */
diff --git a/lib/decompress_unxz.c b/lib/decompress_unxz.c
index cecd23d..9f34eb5 100644
--- a/lib/decompress_unxz.c
+++ b/lib/decompress_unxz.c
@@ -83,7 +83,7 @@
  *    safety_margin = 128 + uncompressed_size * 8 / 32768 + 65536
  *                  = 128 + (uncompressed_size >> 12) + 65536
  *
- * For comparision, according to arch/x86/boot/compressed/misc.c, the
+ * For comparison, according to arch/x86/boot/compressed/misc.c, the
  * equivalent formula for Deflate is this:
  *
  *    safety_margin = 18 + (uncompressed_size >> 12) + 32768
diff --git a/lib/parser.c b/lib/parser.c
index 6e89eca..dcbaaef 100644
--- a/lib/parser.c
+++ b/lib/parser.c
@@ -13,7 +13,7 @@
 
 /**
  * match_one: - Determines if a string matches a simple pattern
- * @s: the string to examine for presense of the pattern
+ * @s: the string to examine for presence of the pattern
  * @p: the string containing the pattern
  * @args: array of %MAX_OPT_ARGS &substring_t elements. Used to return match
  * locations.
diff --git a/lib/timerqueue.c b/lib/timerqueue.c
index e3a1050..191176a 100644
--- a/lib/timerqueue.c
+++ b/lib/timerqueue.c
@@ -5,7 +5,7 @@
  *  Uses rbtrees for quick list adds and expiration.
  *
  *  NOTE: All of the following functions need to be serialized
- *  to avoid races. No locking is done by this libary code.
+ *  to avoid races. No locking is done by this library code.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
diff --git a/mm/backing-dev.c b/mm/backing-dev.c
index 0d9a036..befc875 100644
--- a/mm/backing-dev.c
+++ b/mm/backing-dev.c
@@ -787,7 +787,7 @@ EXPORT_SYMBOL(congestion_wait);
  * jiffies for either a BDI to exit congestion of the given @sync queue
  * or a write to complete.
  *
- * In the absense of zone congestion, cond_resched() is called to yield
+ * In the absence of zone congestion, cond_resched() is called to yield
  * the processor if necessary but otherwise does not sleep.
  *
  * The return value is 0 if the sleep is for the full timeout. Otherwise,
diff --git a/mm/hugetlb.c b/mm/hugetlb.c
index 06de5aa..8ee3bd8 100644
--- a/mm/hugetlb.c
+++ b/mm/hugetlb.c
@@ -146,7 +146,7 @@ static long region_chg(struct list_head *head, long f, long t)
 		if (rg->from > t)
 			return chg;
 
-		/* We overlap with this area, if it extends futher than
+		/* We overlap with this area, if it extends further than
 		 * us then we must extend ourselves.  Account for its
 		 * existing reservation. */
 		if (rg->to > t) {
@@ -842,7 +842,7 @@ struct page *alloc_huge_page_node(struct hstate *h, int nid)
 }
 
 /*
- * Increase the hugetlb pool such that it can accomodate a reservation
+ * Increase the hugetlb pool such that it can accommodate a reservation
  * of size 'delta'.
  */
 static int gather_surplus_pages(struct hstate *h, int delta)
@@ -890,7 +890,7 @@ retry:
 
 	/*
 	 * The surplus_list now contains _at_least_ the number of extra pages
-	 * needed to accomodate the reservation.  Add the appropriate number
+	 * needed to accommodate the reservation.  Add the appropriate number
 	 * of pages to the hugetlb pool and free the extras back to the buddy
 	 * allocator.  Commit the entire reservation here to prevent another
 	 * process from stealing the pages as they are added to the pool but
@@ -2043,7 +2043,7 @@ static void hugetlb_vm_op_open(struct vm_area_struct *vma)
 	 * This new VMA should share its siblings reservation map if present.
 	 * The VMA will only ever have a valid reservation map pointer where
 	 * it is being copied for another still existing VMA.  As that VMA
-	 * has a reference to the reservation map it cannot dissappear until
+	 * has a reference to the reservation map it cannot disappear until
 	 * after this open call completes.  It is therefore safe to take a
 	 * new reference here without additional locking.
 	 */
@@ -2490,7 +2490,7 @@ static int hugetlb_no_page(struct mm_struct *mm, struct vm_area_struct *vma,
 	/*
 	 * Currently, we are forced to kill the process in the event the
 	 * original mapper has unmapped pages from the child due to a failed
-	 * COW. Warn that such a situation has occured as it may not be obvious
+	 * COW. Warn that such a situation has occurred as it may not be obvious
 	 */
 	if (is_vma_resv_set(vma, HPAGE_RESV_UNMAPPED)) {
 		printk(KERN_WARNING
diff --git a/mm/hwpoison-inject.c b/mm/hwpoison-inject.c
index 0948f10..c7fc7fd 100644
--- a/mm/hwpoison-inject.c
+++ b/mm/hwpoison-inject.c
@@ -1,4 +1,4 @@
-/* Inject a hwpoison memory failure on a arbitary pfn */
+/* Inject a hwpoison memory failure on a arbitrary pfn */
 #include <linux/module.h>
 #include <linux/debugfs.h>
 #include <linux/kernel.h>
diff --git a/mm/internal.h b/mm/internal.h
index 3438dd4..9d0ced8 100644
--- a/mm/internal.h
+++ b/mm/internal.h
@@ -162,7 +162,7 @@ static inline struct page *mem_map_offset(struct page *base, int offset)
 }
 
 /*
- * Iterator over all subpages withing the maximally aligned gigantic
+ * Iterator over all subpages within the maximally aligned gigantic
  * page 'base'.  Handle any discontiguity in the mem_map.
  */
 static inline struct page *mem_map_next(struct page *iter,
diff --git a/mm/kmemleak.c b/mm/kmemleak.c
index 84225f3..c1d5867 100644
--- a/mm/kmemleak.c
+++ b/mm/kmemleak.c
@@ -265,7 +265,7 @@ static void kmemleak_disable(void);
 } while (0)
 
 /*
- * Macro invoked when a serious kmemleak condition occured and cannot be
+ * Macro invoked when a serious kmemleak condition occurred and cannot be
  * recovered from. Kmemleak will be disabled and further allocation/freeing
  * tracing no longer available.
  */
@@ -1006,7 +1006,7 @@ static bool update_checksum(struct kmemleak_object *object)
 
 /*
  * Memory scanning is a long process and it needs to be interruptable. This
- * function checks whether such interrupt condition occured.
+ * function checks whether such interrupt condition occurred.
  */
 static int scan_should_stop(void)
 {
@@ -1733,7 +1733,7 @@ static int __init kmemleak_late_init(void)
 
 	if (atomic_read(&kmemleak_error)) {
 		/*
-		 * Some error occured and kmemleak was disabled. There is a
+		 * Some error occurred and kmemleak was disabled. There is a
 		 * small chance that kmemleak_disable() was called immediately
 		 * after setting kmemleak_initialized and we may end up with
 		 * two clean-up threads but serialized by scan_mutex.
diff --git a/mm/ksm.c b/mm/ksm.c
index 1bbe785..942dfc7 100644
--- a/mm/ksm.c
+++ b/mm/ksm.c
@@ -720,7 +720,7 @@ static int write_protect_page(struct vm_area_struct *vma, struct page *page,
 		swapped = PageSwapCache(page);
 		flush_cache_page(vma, addr, page_to_pfn(page));
 		/*
-		 * Ok this is tricky, when get_user_pages_fast() run it doesnt
+		 * Ok this is tricky, when get_user_pages_fast() run it doesn't
 		 * take any lock, therefore the check that we are going to make
 		 * with the pagecount against the mapcount is racey and
 		 * O_DIRECT can happen right after the check.
diff --git a/mm/memcontrol.c b/mm/memcontrol.c
index 1f0b460..010f916 100644
--- a/mm/memcontrol.c
+++ b/mm/memcontrol.c
@@ -1466,7 +1466,7 @@ static int mem_cgroup_hierarchical_reclaim(struct mem_cgroup *root_mem,
 					break;
 				}
 				/*
-				 * We want to do more targetted reclaim.
+				 * We want to do more targeted reclaim.
 				 * excess >> 2 is not to excessive so as to
 				 * reclaim too much, nor too less that we keep
 				 * coming back to reclaim from this cgroup
@@ -2265,7 +2265,7 @@ void mem_cgroup_split_huge_fixup(struct page *head, struct page *tail)
  * - compound_lock is held when nr_pages > 1
  *
  * This function doesn't do "charge" nor css_get to new cgroup. It should be
- * done by a caller(__mem_cgroup_try_charge would be usefull). If @uncharge is
+ * done by a caller(__mem_cgroup_try_charge would be useful). If @uncharge is
  * true, this function does "uncharge" from old cgroup, but it doesn't if
  * @uncharge is false, so a caller should do "uncharge".
  */
@@ -2318,7 +2318,7 @@ static int mem_cgroup_move_account(struct page *page,
 	 * We charges against "to" which may not have any tasks. Then, "to"
 	 * can be under rmdir(). But in current implementation, caller of
 	 * this function is just force_empty() and move charge, so it's
-	 * garanteed that "to" is never removed. So, we don't check rmdir
+	 * guaranteed that "to" is never removed. So, we don't check rmdir
 	 * status here.
 	 */
 	move_unlock_page_cgroup(pc, &flags);
@@ -2648,7 +2648,7 @@ static void mem_cgroup_do_uncharge(struct mem_cgroup *mem,
 		batch->memcg = mem;
 	/*
 	 * do_batch > 0 when unmapping pages or inode invalidate/truncate.
-	 * In those cases, all pages freed continously can be expected to be in
+	 * In those cases, all pages freed continuously can be expected to be in
 	 * the same cgroup and we have chance to coalesce uncharges.
 	 * But we do uncharge one by one if this is killed by OOM(TIF_MEMDIE)
 	 * because we want to do uncharge as soon as possible.
diff --git a/mm/memory-failure.c b/mm/memory-failure.c
index 37feb9f..2b9a5ee 100644
--- a/mm/memory-failure.c
+++ b/mm/memory-failure.c
@@ -208,7 +208,7 @@ static int kill_proc_ao(struct task_struct *t, unsigned long addr, int trapno,
 	 * Don't use force here, it's convenient if the signal
 	 * can be temporarily blocked.
 	 * This could cause a loop when the user sets SIGBUS
-	 * to SIG_IGN, but hopefully noone will do that?
+	 * to SIG_IGN, but hopefully no one will do that?
 	 */
 	ret = send_sig_info(SIGBUS, &si, t);  /* synchronous? */
 	if (ret < 0)
@@ -634,7 +634,7 @@ static int me_pagecache_dirty(struct page *p, unsigned long pfn)
 		 * when the page is reread or dropped.  If an
 		 * application assumes it will always get error on
 		 * fsync, but does other operations on the fd before
-		 * and the page is dropped inbetween then the error
+		 * and the page is dropped between then the error
 		 * will not be properly reported.
 		 *
 		 * This can already happen even without hwpoisoned
@@ -728,7 +728,7 @@ static int me_huge_page(struct page *p, unsigned long pfn)
  * The table matches them in order and calls the right handler.
  *
  * This is quite tricky because we can access page at any time
- * in its live cycle, so all accesses have to be extremly careful.
+ * in its live cycle, so all accesses have to be extremely careful.
  *
  * This is not complete. More states could be added.
  * For any missing state don't attempt recovery.
diff --git a/mm/memory_hotplug.c b/mm/memory_hotplug.c
index 321fc74..a2acaf8 100644
--- a/mm/memory_hotplug.c
+++ b/mm/memory_hotplug.c
@@ -724,7 +724,7 @@ do_migrate_range(unsigned long start_pfn, unsigned long end_pfn)
 			       pfn);
 			dump_page(page);
 #endif
-			/* Becasue we don't have big zone->lock. we should
+			/* Because we don't have big zone->lock. we should
 			   check this again here. */
 			if (page_count(page)) {
 				not_managed++;
diff --git a/mm/migrate.c b/mm/migrate.c
index b0406d7..34132f8 100644
--- a/mm/migrate.c
+++ b/mm/migrate.c
@@ -375,7 +375,7 @@ void migrate_page_copy(struct page *newpage, struct page *page)
 		 * redo the accounting that clear_page_dirty_for_io undid,
 		 * but we can't use set_page_dirty because that function
 		 * is actually a signal that all of the page has become dirty.
-		 * Wheras only part of our page may be dirty.
+		 * Whereas only part of our page may be dirty.
 		 */
 		__set_page_dirty_nobuffers(newpage);
  	}
diff --git a/mm/mremap.c b/mm/mremap.c
index 1de98d4..a7c1f9f 100644
--- a/mm/mremap.c
+++ b/mm/mremap.c
@@ -277,9 +277,16 @@ static struct vm_area_struct *vma_to_resize(unsigned long addr,
 	if (old_len > vma->vm_end - addr)
 		goto Efault;
 
-	if (vma->vm_flags & (VM_DONTEXPAND | VM_PFNMAP)) {
-		if (new_len > old_len)
+	/* Need to be careful about a growing mapping */
+	if (new_len > old_len) {
+		unsigned long pgoff;
+
+		if (vma->vm_flags & (VM_DONTEXPAND | VM_PFNMAP))
 			goto Efault;
+		pgoff = (addr - vma->vm_start) >> PAGE_SHIFT;
+		pgoff += vma->vm_pgoff;
+		if (pgoff + (new_len >> PAGE_SHIFT) < pgoff)
+			goto Einval;
 	}
 
 	if (vma->vm_flags & VM_LOCKED) {
diff --git a/mm/nobootmem.c b/mm/nobootmem.c
index e99f6cd..9109049 100644
--- a/mm/nobootmem.c
+++ b/mm/nobootmem.c
@@ -150,7 +150,7 @@ unsigned long __init free_all_bootmem(void)
 {
 	/*
 	 * We need to use MAX_NUMNODES instead of NODE_DATA(0)->node_id
-	 *  because in some case like Node0 doesnt have RAM installed
+	 *  because in some case like Node0 doesn't have RAM installed
 	 *  low ram will be on Node1
 	 * Use MAX_NUMNODES will make sure all ranges in early_node_map[]
 	 *  will be used instead of only Node0 related
diff --git a/mm/page_alloc.c b/mm/page_alloc.c
index d6e7ba7..2747f5e 100644
--- a/mm/page_alloc.c
+++ b/mm/page_alloc.c
@@ -942,7 +942,7 @@ __rmqueue_fallback(struct zone *zone, int order, int start_migratetype)
 			 * If breaking a large block of pages, move all free
 			 * pages to the preferred allocation list. If falling
 			 * back for a reclaimable kernel allocation, be more
-			 * agressive about taking ownership of free pages
+			 * aggressive about taking ownership of free pages
 			 */
 			if (unlikely(current_order >= (pageblock_order >> 1)) ||
 					start_migratetype == MIGRATE_RECLAIMABLE ||
@@ -3926,7 +3926,7 @@ static void __init find_usable_zone_for_movable(void)
 
 /*
  * The zone ranges provided by the architecture do not include ZONE_MOVABLE
- * because it is sized independant of architecture. Unlike the other zones,
+ * because it is sized independent of architecture. Unlike the other zones,
  * the starting point for ZONE_MOVABLE is not fixed. It may be different
  * in each node depending on the size of each node and how evenly kernelcore
  * is distributed. This helper function adjusts the zone ranges
diff --git a/mm/page_cgroup.c b/mm/page_cgroup.c
index a12cc3f..9905501 100644
--- a/mm/page_cgroup.c
+++ b/mm/page_cgroup.c
@@ -377,7 +377,7 @@ not_enough_page:
  * @new: new id
  *
  * Returns old id at success, 0 at failure.
- * (There is no mem_cgroup useing 0 as its id)
+ * (There is no mem_cgroup using 0 as its id)
  */
 unsigned short swap_cgroup_cmpxchg(swp_entry_t ent,
 					unsigned short old, unsigned short new)
diff --git a/mm/percpu.c b/mm/percpu.c
index 55d4d11..a160db3 100644
--- a/mm/percpu.c
+++ b/mm/percpu.c
@@ -342,7 +342,7 @@ static void pcpu_chunk_relocate(struct pcpu_chunk *chunk, int oslot)
  * @chunk: chunk of interest
  *
  * Determine whether area map of @chunk needs to be extended to
- * accomodate a new allocation.
+ * accommodate a new allocation.
  *
  * CONTEXT:
  * pcpu_lock.
@@ -431,7 +431,7 @@ out_unlock:
  * depending on @head, is reduced by @tail bytes and @tail byte block
  * is inserted after the target block.
  *
- * @chunk->map must have enough free slots to accomodate the split.
+ * @chunk->map must have enough free slots to accommodate the split.
  *
  * CONTEXT:
  * pcpu_lock.
@@ -1435,7 +1435,7 @@ static struct pcpu_alloc_info * __init pcpu_build_alloc_info(
 	/*
 	 * Determine min_unit_size, alloc_size and max_upa such that
 	 * alloc_size is multiple of atom_size and is the smallest
-	 * which can accomodate 4k aligned segments which are equal to
+	 * which can accommodate 4k aligned segments which are equal to
 	 * or larger than min_unit_size.
 	 */
 	min_unit_size = max_t(size_t, size_sum, PCPU_MIN_UNIT_SIZE);
@@ -1550,7 +1550,7 @@ static struct pcpu_alloc_info * __init pcpu_build_alloc_info(
  * @atom_size: allocation atom size
  * @cpu_distance_fn: callback to determine distance between cpus, optional
  * @alloc_fn: function to allocate percpu page
- * @free_fn: funtion to free percpu page
+ * @free_fn: function to free percpu page
  *
  * This is a helper to ease setting up embedded first percpu chunk and
  * can be called where pcpu_setup_first_chunk() is expected.
@@ -1678,7 +1678,7 @@ out_free:
  * pcpu_page_first_chunk - map the first chunk using PAGE_SIZE pages
  * @reserved_size: the size of reserved percpu area in bytes
  * @alloc_fn: function to allocate percpu page, always called with PAGE_SIZE
- * @free_fn: funtion to free percpu page, always called with PAGE_SIZE
+ * @free_fn: function to free percpu page, always called with PAGE_SIZE
  * @populate_pte_fn: function to populate pte
  *
  * This is a helper to ease setting up page-remapped first percpu
diff --git a/mm/slab.c b/mm/slab.c
index 568803f..46a9c16 100644
--- a/mm/slab.c
+++ b/mm/slab.c
@@ -878,7 +878,7 @@ static struct array_cache *alloc_arraycache(int node, int entries,
 	nc = kmalloc_node(memsize, gfp, node);
 	/*
 	 * The array_cache structures contain pointers to free object.
-	 * However, when such objects are allocated or transfered to another
+	 * However, when such objects are allocated or transferred to another
 	 * cache the pointers are not cleared and they could be counted as
 	 * valid references during a kmemleak scan. Therefore, kmemleak must
 	 * not scan such objects.
@@ -2606,7 +2606,7 @@ EXPORT_SYMBOL(kmem_cache_shrink);
  *
  * The cache must be empty before calling this function.
  *
- * The caller must guarantee that noone will allocate memory from the cache
+ * The caller must guarantee that no one will allocate memory from the cache
  * during the kmem_cache_destroy().
  */
 void kmem_cache_destroy(struct kmem_cache *cachep)
diff --git a/mm/slub.c b/mm/slub.c
index f881874..94d2a33 100644
--- a/mm/slub.c
+++ b/mm/slub.c
@@ -64,7 +64,7 @@
  *   we must stay away from it for a while since we may cause a bouncing
  *   cacheline if we try to acquire the lock. So go onto the next slab.
  *   If all pages are busy then we may allocate a new slab instead of reusing
- *   a partial slab. A new slab has noone operating on it and thus there is
+ *   a partial slab. A new slab has no one operating on it and thus there is
  *   no danger of cacheline contention.
  *
  *   Interrupts are disabled during allocation and deallocation in order to
@@ -1929,7 +1929,7 @@ redo:
 	else {
 #ifdef CONFIG_CMPXCHG_LOCAL
 		/*
-		 * The cmpxchg will only match if there was no additonal
+		 * The cmpxchg will only match if there was no additional
 		 * operation and if we are on the right processor.
 		 *
 		 * The cmpxchg does the following atomically (without lock semantics!)
@@ -3547,7 +3547,7 @@ void *__kmalloc_track_caller(size_t size, gfp_t gfpflags, unsigned long caller)
 
 	ret = slab_alloc(s, gfpflags, NUMA_NO_NODE, caller);
 
-	/* Honor the call site pointer we recieved. */
+	/* Honor the call site pointer we received. */
 	trace_kmalloc(caller, ret, size, s->size, gfpflags);
 
 	return ret;
@@ -3577,7 +3577,7 @@ void *__kmalloc_node_track_caller(size_t size, gfp_t gfpflags,
 
 	ret = slab_alloc(s, gfpflags, node, caller);
 
-	/* Honor the call site pointer we recieved. */
+	/* Honor the call site pointer we received. */
 	trace_kmalloc_node(caller, ret, size, s->size, gfpflags, node);
 
 	return ret;
diff --git a/mm/sparse.c b/mm/sparse.c
index 9325020..aa64b12 100644
--- a/mm/sparse.c
+++ b/mm/sparse.c
@@ -500,7 +500,7 @@ void __init sparse_init(void)
 	 * so alloc 2M (with 2M align) and 24 bytes in turn will
 	 * make next 2M slip to one more 2M later.
 	 * then in big system, the memory will have a lot of holes...
-	 * here try to allocate 2M pages continously.
+	 * here try to allocate 2M pages continuously.
 	 *
 	 * powerpc need to call sparse_init_one_section right after each
 	 * sparse_early_mem_map_alloc, so allocate usemap_map at first.
diff --git a/mm/util.c b/mm/util.c
index f126975..e7b103a 100644
--- a/mm/util.c
+++ b/mm/util.c
@@ -227,7 +227,7 @@ void arch_pick_mmap_layout(struct mm_struct *mm)
 /*
  * Like get_user_pages_fast() except its IRQ-safe in that it won't fall
  * back to the regular GUP.
- * If the architecture not support this fucntion, simply return with no
+ * If the architecture not support this function, simply return with no
  * page pinned
  */
 int __attribute__((weak)) __get_user_pages_fast(unsigned long start,
diff --git a/mm/vmscan.c b/mm/vmscan.c
index f73b865..c7f5a6d 100644
--- a/mm/vmscan.c
+++ b/mm/vmscan.c
@@ -1065,7 +1065,7 @@ static unsigned long isolate_lru_pages(unsigned long nr_to_scan,
 		 * surrounding the tag page.  Only take those pages of
 		 * the same active state as that tag page.  We may safely
 		 * round the target page pfn down to the requested order
-		 * as the mem_map is guarenteed valid out to MAX_ORDER,
+		 * as the mem_map is guaranteed valid out to MAX_ORDER,
 		 * where that page is in a different zone we will detect
 		 * it from its zone id and abort this block scan.
 		 */
@@ -2224,7 +2224,7 @@ unsigned long try_to_free_mem_cgroup_pages(struct mem_cgroup *mem_cont,
  *   o a 16M DMA zone that is balanced will not balance a zone on any
  *     reasonable sized machine
  *   o On all other machines, the top zone must be at least a reasonable
- *     precentage of the middle zones. For example, on 32-bit x86, highmem
+ *     percentage of the middle zones. For example, on 32-bit x86, highmem
  *     would need to be at least 256M for it to be balance a whole node.
  *     Similarly, on x86-64 the Normal zone would need to be at least 1G
  *     to balance a node on its own. These seemed like reasonable ratios.
diff --git a/net/8021q/vlanproc.c b/net/8021q/vlanproc.c
index d1314cf..d940c49 100644
--- a/net/8021q/vlanproc.c
+++ b/net/8021q/vlanproc.c
@@ -54,7 +54,7 @@ static const char name_conf[]	 = "config";
 
 /*
  *	Structures for interfacing with the /proc filesystem.
- *	VLAN creates its own directory /proc/net/vlan with the folowing
+ *	VLAN creates its own directory /proc/net/vlan with the following
  *	entries:
  *	config		device status/configuration
  *	<device>	entry for each  device
diff --git a/net/9p/client.c b/net/9p/client.c
index 2ccbf04..48b8e08 100644
--- a/net/9p/client.c
+++ b/net/9p/client.c
@@ -178,7 +178,7 @@ free_and_return:
  * @tag: numeric id for transaction
  *
  * this is a simple array lookup, but will grow the
- * request_slots as necessary to accomodate transaction
+ * request_slots as necessary to accommodate transaction
  * ids which did not previously have a slot.
  *
  * this code relies on the client spinlock to manage locks, its
diff --git a/net/9p/trans_common.c b/net/9p/trans_common.c
index 9172ab7..d47880e 100644
--- a/net/9p/trans_common.c
+++ b/net/9p/trans_common.c
@@ -36,7 +36,7 @@ p9_release_req_pages(struct trans_rpage_info *rpinfo)
 EXPORT_SYMBOL(p9_release_req_pages);
 
 /**
- * p9_nr_pages - Return number of pages needed to accomodate the payload.
+ * p9_nr_pages - Return number of pages needed to accommodate the payload.
  */
 int
 p9_nr_pages(struct p9_req_t *req)
@@ -55,7 +55,7 @@ EXPORT_SYMBOL(p9_nr_pages);
  * @req: Request to be sent to server.
  * @pdata_off: data offset into the first page after translation (gup).
  * @pdata_len: Total length of the IO. gup may not return requested # of pages.
- * @nr_pages: number of pages to accomodate the payload
+ * @nr_pages: number of pages to accommodate the payload
  * @rw: Indicates if the pages are for read or write.
  */
 int
diff --git a/net/9p/util.c b/net/9p/util.c
index b84619b..da6af81 100644
--- a/net/9p/util.c
+++ b/net/9p/util.c
@@ -67,7 +67,7 @@ EXPORT_SYMBOL(p9_idpool_create);
 
 /**
  * p9_idpool_destroy - create a new per-connection id pool
- * @p: idpool to destory
+ * @p: idpool to destroy
  */
 
 void p9_idpool_destroy(struct p9_idpool *p)
diff --git a/net/atm/br2684.c b/net/atm/br2684.c
index fce2eae..2252c20 100644
--- a/net/atm/br2684.c
+++ b/net/atm/br2684.c
@@ -509,7 +509,7 @@ static int br2684_regvcc(struct atm_vcc *atmvcc, void __user * arg)
 	write_lock_irq(&devs_lock);
 	net_dev = br2684_find_dev(&be.ifspec);
 	if (net_dev == NULL) {
-		pr_err("tried to attach to non-existant device\n");
+		pr_err("tried to attach to non-existent device\n");
 		err = -ENXIO;
 		goto error;
 	}
diff --git a/net/atm/lec.h b/net/atm/lec.h
index 9d14d19..dfc0719 100644
--- a/net/atm/lec.h
+++ b/net/atm/lec.h
@@ -35,7 +35,7 @@ struct lecdatahdr_8025 {
  * Operations that LANE2 capable device can do. Two first functions
  * are used to make the device do things. See spec 3.1.3 and 3.1.4.
  *
- * The third function is intented for the MPOA component sitting on
+ * The third function is intended for the MPOA component sitting on
  * top of the LANE device. The MPOA component assigns it's own function
  * to (*associate_indicator)() and the LANE device will use that
  * function to tell about TLVs it sees floating through.
diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 9ed2614..824e1f6 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -474,7 +474,7 @@ void interface_rx(struct net_device *soft_iface,
 		goto dropped;
 	skb->protocol = eth_type_trans(skb, soft_iface);
 
-	/* should not be neccesary anymore as we use skb_pull_rcsum()
+	/* should not be necessary anymore as we use skb_pull_rcsum()
 	 * TODO: please verify this and remove this TODO
 	 * -- Dec 21st 2009, Simon Wunderlich */
 
diff --git a/net/bluetooth/hci_core.c b/net/bluetooth/hci_core.c
index 2216620..c83f618 100644
--- a/net/bluetooth/hci_core.c
+++ b/net/bluetooth/hci_core.c
@@ -1883,7 +1883,7 @@ static void hci_tx_task(unsigned long arg)
 	read_unlock(&hci_task_lock);
 }
 
-/* ----- HCI RX task (incoming data proccessing) ----- */
+/* ----- HCI RX task (incoming data processing) ----- */
 
 /* ACL data packet */
 static inline void hci_acldata_packet(struct hci_dev *hdev, struct sk_buff *skb)
diff --git a/net/bluetooth/l2cap_sock.c b/net/bluetooth/l2cap_sock.c
index f77308e..299fe56 100644
--- a/net/bluetooth/l2cap_sock.c
+++ b/net/bluetooth/l2cap_sock.c
@@ -679,7 +679,7 @@ static int l2cap_sock_setsockopt(struct socket *sock, int level, int optname, ch
 
 		if (opt == BT_FLUSHABLE_OFF) {
 			struct l2cap_conn *conn = l2cap_pi(sk)->conn;
-			/* proceed futher only when we have l2cap_conn and
+			/* proceed further only when we have l2cap_conn and
 			   No Flush support in the LM */
 			if (!conn || !lmp_no_flush_capable(conn->hcon->hdev)) {
 				err = -EINVAL;
diff --git a/net/bridge/br_fdb.c b/net/bridge/br_fdb.c
index 88485cc..cc4d3c5 100644
--- a/net/bridge/br_fdb.c
+++ b/net/bridge/br_fdb.c
@@ -169,7 +169,7 @@ void br_fdb_flush(struct net_bridge *br)
 	spin_unlock_bh(&br->hash_lock);
 }
 
-/* Flush all entries refering to a specific port.
+/* Flush all entries referring to a specific port.
  * if do_all is set also flush static entries
  */
 void br_fdb_delete_by_port(struct net_bridge *br,
diff --git a/net/bridge/br_ioctl.c b/net/bridge/br_ioctl.c
index cb43312..3d9fca0 100644
--- a/net/bridge/br_ioctl.c
+++ b/net/bridge/br_ioctl.c
@@ -106,7 +106,7 @@ static int add_del_if(struct net_bridge *br, int ifindex, int isadd)
 /*
  * Legacy ioctl's through SIOCDEVPRIVATE
  * This interface is deprecated because it was too difficult to
- * to do the translation for 32/64bit ioctl compatability.
+ * to do the translation for 32/64bit ioctl compatibility.
  */
 static int old_dev_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
 {
diff --git a/net/caif/caif_socket.c b/net/caif/caif_socket.c
index 8184c03..37a4034 100644
--- a/net/caif/caif_socket.c
+++ b/net/caif/caif_socket.c
@@ -852,7 +852,7 @@ static int caif_connect(struct socket *sock, struct sockaddr *uaddr,
 	sock->state = SS_CONNECTING;
 	sk->sk_state = CAIF_CONNECTING;
 
-	/* Check priority value comming from socket */
+	/* Check priority value coming from socket */
 	/* if priority value is out of range it will be ajusted */
 	if (cf_sk->sk.sk_priority > CAIF_PRIO_MAX)
 		cf_sk->conn_req.priority = CAIF_PRIO_MAX;
diff --git a/net/can/bcm.c b/net/can/bcm.c
index 871a0ad..57b1aed 100644
--- a/net/can/bcm.c
+++ b/net/can/bcm.c
@@ -387,7 +387,7 @@ static void bcm_tx_timeout_tsklet(unsigned long data)
 }
 
 /*
- * bcm_tx_timeout_handler - performes cyclic CAN frame transmissions
+ * bcm_tx_timeout_handler - performs cyclic CAN frame transmissions
  */
 static enum hrtimer_restart bcm_tx_timeout_handler(struct hrtimer *hrtimer)
 {
diff --git a/net/ceph/osd_client.c b/net/ceph/osd_client.c
index 3b91d65..50af027 100644
--- a/net/ceph/osd_client.c
+++ b/net/ceph/osd_client.c
@@ -917,7 +917,7 @@ EXPORT_SYMBOL(ceph_osdc_set_request_linger);
 /*
  * Pick an osd (the first 'up' osd in the pg), allocate the osd struct
  * (as needed), and set the request r_osd appropriately.  If there is
- * no up osd, set r_osd to NULL.  Move the request to the appropiate list
+ * no up osd, set r_osd to NULL.  Move the request to the appropriate list
  * (unsent, homeless) or leave on in-flight lru.
  *
  * Return 0 if unchanged, 1 if changed, or negative on error.
diff --git a/net/core/dev.c b/net/core/dev.c
index 3da9fb0..956d3b0 100644
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@ -2091,7 +2091,7 @@ int dev_hard_start_xmit(struct sk_buff *skb, struct net_device *dev,
 		u32 features;
 
 		/*
-		 * If device doesnt need skb->dst, release it right now while
+		 * If device doesn't need skb->dst, release it right now while
 		 * its hot in this cpu cache
 		 */
 		if (dev->priv_flags & IFF_XMIT_DST_RELEASE)
@@ -2151,7 +2151,7 @@ gso:
 		nskb->next = NULL;
 
 		/*
-		 * If device doesnt need nskb->dst, release it right now while
+		 * If device doesn't need nskb->dst, release it right now while
 		 * its hot in this cpu cache
 		 */
 		if (dev->priv_flags & IFF_XMIT_DST_RELEASE)
@@ -2970,8 +2970,8 @@ EXPORT_SYMBOL_GPL(br_fdb_test_addr_hook);
  * when CONFIG_NET_CLS_ACT is? otherwise some useless instructions
  * a compare and 2 stores extra right now if we dont have it on
  * but have CONFIG_NET_CLS_ACT
- * NOTE: This doesnt stop any functionality; if you dont have
- * the ingress scheduler, you just cant add policies on ingress.
+ * NOTE: This doesn't stop any functionality; if you dont have
+ * the ingress scheduler, you just can't add policies on ingress.
  *
  */
 static int ing_filter(struct sk_buff *skb, struct netdev_queue *rxq)
@@ -3800,7 +3800,7 @@ static void net_rx_action(struct softirq_action *h)
 		 * with netpoll's poll_napi().  Only the entity which
 		 * obtains the lock and sees NAPI_STATE_SCHED set will
 		 * actually make the ->poll() call.  Therefore we avoid
-		 * accidently calling ->poll() when NAPI is not scheduled.
+		 * accidentally calling ->poll() when NAPI is not scheduled.
 		 */
 		work = 0;
 		if (test_bit(NAPI_STATE_SCHED, &n->state)) {
@@ -6336,7 +6336,7 @@ static void __net_exit default_device_exit(struct net *net)
 		if (dev->rtnl_link_ops)
 			continue;
 
-		/* Push remaing network devices to init_net */
+		/* Push remaining network devices to init_net */
 		snprintf(fb_name, IFNAMSIZ, "dev%d", dev->ifindex);
 		err = dev_change_net_namespace(dev, &init_net, fb_name);
 		if (err) {
diff --git a/net/core/filter.c b/net/core/filter.c
index 232b187..afb8afb 100644
--- a/net/core/filter.c
+++ b/net/core/filter.c
@@ -425,7 +425,7 @@ EXPORT_SYMBOL(sk_run_filter);
  * As we dont want to clear mem[] array for each packet going through
  * sk_run_filter(), we check that filter loaded by user never try to read
  * a cell if not previously written, and we check all branches to be sure
- * a malicious user doesnt try to abuse us.
+ * a malicious user doesn't try to abuse us.
  */
 static int check_load_and_stores(struct sock_filter *filter, int flen)
 {
diff --git a/net/core/link_watch.c b/net/core/link_watch.c
index 01a1101..a7b3421 100644
--- a/net/core/link_watch.c
+++ b/net/core/link_watch.c
@@ -129,7 +129,7 @@ static void linkwatch_schedule_work(int urgent)
 	if (!cancel_delayed_work(&linkwatch_work))
 		return;
 
-	/* Otherwise we reschedule it again for immediate exection. */
+	/* Otherwise we reschedule it again for immediate execution. */
 	schedule_delayed_work(&linkwatch_work, 0);
 }
 
diff --git a/net/core/rtnetlink.c b/net/core/rtnetlink.c
index 49f7ea5..d7c4bb4 100644
--- a/net/core/rtnetlink.c
+++ b/net/core/rtnetlink.c
@@ -196,7 +196,7 @@ EXPORT_SYMBOL_GPL(__rtnl_register);
  * as failure of this function is very unlikely, it can only happen due
  * to lack of memory when allocating the chain to store all message
  * handlers for a protocol. Meant for use in init functions where lack
- * of memory implies no sense in continueing.
+ * of memory implies no sense in continuing.
  */
 void rtnl_register(int protocol, int msgtype,
 		   rtnl_doit_func doit, rtnl_dumpit_func dumpit)
@@ -1440,7 +1440,7 @@ static int do_setlink(struct net_device *dev, struct ifinfomsg *ifm,
 errout:
 	if (err < 0 && modified && net_ratelimit())
 		printk(KERN_WARNING "A link change request failed with "
-		       "some changes comitted already. Interface %s may "
+		       "some changes committed already. Interface %s may "
 		       "have been left with an inconsistent configuration, "
 		       "please check.\n", dev->name);
 
diff --git a/net/core/skbuff.c b/net/core/skbuff.c
index 801dd08..7ebeed0 100644
--- a/net/core/skbuff.c
+++ b/net/core/skbuff.c
@@ -2267,7 +2267,7 @@ EXPORT_SYMBOL(skb_prepare_seq_read);
  * of bytes already consumed and the next call to
  * skb_seq_read() will return the remaining part of the block.
  *
- * Note 1: The size of each block of data returned can be arbitary,
+ * Note 1: The size of each block of data returned can be arbitrary,
  *       this limitation is the cost for zerocopy seqeuental
  *       reads of potentially non linear data.
  *
diff --git a/net/core/sock.c b/net/core/sock.c
index 7dfed79..6e81978 100644
--- a/net/core/sock.c
+++ b/net/core/sock.c
@@ -215,7 +215,7 @@ __u32 sysctl_rmem_max __read_mostly = SK_RMEM_MAX;
 __u32 sysctl_wmem_default __read_mostly = SK_WMEM_MAX;
 __u32 sysctl_rmem_default __read_mostly = SK_RMEM_MAX;
 
-/* Maximal space eaten by iovec or ancilliary data plus some space */
+/* Maximal space eaten by iovec or ancillary data plus some space */
 int sysctl_optmem_max __read_mostly = sizeof(unsigned long)*(2*UIO_MAXIOV+512);
 EXPORT_SYMBOL(sysctl_optmem_max);
 
@@ -1175,7 +1175,7 @@ static void __sk_free(struct sock *sk)
 void sk_free(struct sock *sk)
 {
 	/*
-	 * We substract one from sk_wmem_alloc and can know if
+	 * We subtract one from sk_wmem_alloc and can know if
 	 * some packets are still in some tx queue.
 	 * If not null, sock_wfree() will call __sk_free(sk) later
 	 */
@@ -1185,10 +1185,10 @@ void sk_free(struct sock *sk)
 EXPORT_SYMBOL(sk_free);
 
 /*
- * Last sock_put should drop referrence to sk->sk_net. It has already
- * been dropped in sk_change_net. Taking referrence to stopping namespace
+ * Last sock_put should drop reference to sk->sk_net. It has already
+ * been dropped in sk_change_net. Taking reference to stopping namespace
  * is not an option.
- * Take referrence to a socket to remove it from hash _alive_ and after that
+ * Take reference to a socket to remove it from hash _alive_ and after that
  * destroy it in the context of init_net.
  */
 void sk_release_kernel(struct sock *sk)
diff --git a/net/dccp/output.c b/net/dccp/output.c
index 784d3021..136d41c 100644
--- a/net/dccp/output.c
+++ b/net/dccp/output.c
@@ -143,7 +143,7 @@ static int dccp_transmit_skb(struct sock *sk, struct sk_buff *skb)
 }
 
 /**
- * dccp_determine_ccmps  -  Find out about CCID-specfic packet-size limits
+ * dccp_determine_ccmps  -  Find out about CCID-specific packet-size limits
  * We only consider the HC-sender CCID for setting the CCMPS (RFC 4340, 14.),
  * since the RX CCID is restricted to feedback packets (Acks), which are small
  * in comparison with the data traffic. A value of 0 means "no current CCMPS".
diff --git a/net/dsa/mv88e6131.c b/net/dsa/mv88e6131.c
index bb2b41b..d951f93 100644
--- a/net/dsa/mv88e6131.c
+++ b/net/dsa/mv88e6131.c
@@ -124,7 +124,7 @@ static int mv88e6131_setup_global(struct dsa_switch *ds)
 	 * Ignore removed tag data on doubly tagged packets, disable
 	 * flow control messages, force flow control priority to the
 	 * highest, and send all special multicast frames to the CPU
-	 * port at the higest priority.
+	 * port at the highest priority.
 	 */
 	REG_WRITE(REG_GLOBAL2, 0x05, 0x00ff);
 
diff --git a/net/ipv4/cipso_ipv4.c b/net/ipv4/cipso_ipv4.c
index 094e150..a0af7ea 100644
--- a/net/ipv4/cipso_ipv4.c
+++ b/net/ipv4/cipso_ipv4.c
@@ -112,7 +112,7 @@ int cipso_v4_rbm_strictvalid = 1;
 /* The maximum number of category ranges permitted in the ranged category tag
  * (tag #5).  You may note that the IETF draft states that the maximum number
  * of category ranges is 7, but if the low end of the last category range is
- * zero then it is possibile to fit 8 category ranges because the zero should
+ * zero then it is possible to fit 8 category ranges because the zero should
  * be omitted. */
 #define CIPSO_V4_TAG_RNG_CAT_MAX      8
 
@@ -438,7 +438,7 @@ cache_add_failure:
  *
  * Description:
  * Search the DOI definition list for a DOI definition with a DOI value that
- * matches @doi.  The caller is responsibile for calling rcu_read_[un]lock().
+ * matches @doi.  The caller is responsible for calling rcu_read_[un]lock().
  * Returns a pointer to the DOI definition on success and NULL on failure.
  */
 static struct cipso_v4_doi *cipso_v4_doi_search(u32 doi)
@@ -1293,7 +1293,7 @@ static int cipso_v4_gentag_rbm(const struct cipso_v4_doi *doi_def,
 			return ret_val;
 
 		/* This will send packets using the "optimized" format when
-		 * possibile as specified in  section 3.4.2.6 of the
+		 * possible as specified in  section 3.4.2.6 of the
 		 * CIPSO draft. */
 		if (cipso_v4_rbm_optfmt && ret_val > 0 && ret_val <= 10)
 			tag_len = 14;
@@ -1752,7 +1752,7 @@ validate_return:
 }
 
 /**
- * cipso_v4_error - Send the correct reponse for a bad packet
+ * cipso_v4_error - Send the correct response for a bad packet
  * @skb: the packet
  * @error: the error code
  * @gateway: CIPSO gateway flag
diff --git a/net/ipv4/fib_trie.c b/net/ipv4/fib_trie.c
index b92c86f..e9013d6 100644
--- a/net/ipv4/fib_trie.c
+++ b/net/ipv4/fib_trie.c
@@ -12,7 +12,7 @@
  *
  *   Hans Liss <hans.liss@its.uu.se>  Uppsala Universitet
  *
- * This work is based on the LPC-trie which is originally descibed in:
+ * This work is based on the LPC-trie which is originally described in:
  *
  * An experimental study of compression methods for dynamic tries
  * Stefan Nilsson and Matti Tikkanen. Algorithmica, 33(1):19-33, 2002.
diff --git a/net/ipv4/icmp.c b/net/ipv4/icmp.c
index a91dc16..e5f8a71 100644
--- a/net/ipv4/icmp.c
+++ b/net/ipv4/icmp.c
@@ -704,7 +704,7 @@ static void icmp_unreach(struct sk_buff *skb)
 	 */
 
 	/*
-	 *	Check the other end isnt violating RFC 1122. Some routers send
+	 *	Check the other end isn't violating RFC 1122. Some routers send
 	 *	bogus responses to broadcast frames. If you see this message
 	 *	first check your netmask matches at both ends, if it does then
 	 *	get the other vendor to fix their kit.
diff --git a/net/ipv4/ip_output.c b/net/ipv4/ip_output.c
index 67f241b..459c011 100644
--- a/net/ipv4/ip_output.c
+++ b/net/ipv4/ip_output.c
@@ -603,7 +603,7 @@ slow_path:
 		/* IF: it doesn't fit, use 'mtu' - the data space left */
 		if (len > mtu)
 			len = mtu;
-		/* IF: we are not sending upto and including the packet end
+		/* IF: we are not sending up to and including the packet end
 		   then align the next start on an eight byte boundary */
 		if (len < left)	{
 			len &= ~7;
diff --git a/net/ipv4/ipconfig.c b/net/ipv4/ipconfig.c
index 2b09775..cbff2ec 100644
--- a/net/ipv4/ipconfig.c
+++ b/net/ipv4/ipconfig.c
@@ -1444,7 +1444,7 @@ static int __init ip_auto_config(void)
 		root_server_addr = addr;
 
 	/*
-	 * Use defaults whereever applicable.
+	 * Use defaults wherever applicable.
 	 */
 	if (ic_defaults() < 0)
 		return -1;
diff --git a/net/ipv4/netfilter/arp_tables.c b/net/ipv4/netfilter/arp_tables.c
index 4b5d457..89bc7e6 100644
--- a/net/ipv4/netfilter/arp_tables.c
+++ b/net/ipv4/netfilter/arp_tables.c
@@ -76,7 +76,7 @@ static inline int arp_devaddr_compare(const struct arpt_devaddr_info *ap,
 }
 
 /*
- * Unfortunatly, _b and _mask are not aligned to an int (or long int)
+ * Unfortunately, _b and _mask are not aligned to an int (or long int)
  * Some arches dont care, unrolling the loop is a win on them.
  * For other arches, we only have a 16bit alignement.
  */
@@ -1874,7 +1874,7 @@ static int __init arp_tables_init(void)
 	if (ret < 0)
 		goto err1;
 
-	/* Noone else will be downing sem now, so we won't sleep */
+	/* No one else will be downing sem now, so we won't sleep */
 	ret = xt_register_targets(arpt_builtin_tg, ARRAY_SIZE(arpt_builtin_tg));
 	if (ret < 0)
 		goto err2;
diff --git a/net/ipv4/netfilter/ip_tables.c b/net/ipv4/netfilter/ip_tables.c
index ffcea0d..7049150 100644
--- a/net/ipv4/netfilter/ip_tables.c
+++ b/net/ipv4/netfilter/ip_tables.c
@@ -2233,7 +2233,7 @@ static int __init ip_tables_init(void)
 	if (ret < 0)
 		goto err1;
 
-	/* Noone else will be downing sem now, so we won't sleep */
+	/* No one else will be downing sem now, so we won't sleep */
 	ret = xt_register_targets(ipt_builtin_tg, ARRAY_SIZE(ipt_builtin_tg));
 	if (ret < 0)
 		goto err2;
diff --git a/net/ipv4/netfilter/nf_nat_core.c b/net/ipv4/netfilter/nf_nat_core.c
index 21bcf47..9c71b27 100644
--- a/net/ipv4/netfilter/nf_nat_core.c
+++ b/net/ipv4/netfilter/nf_nat_core.c
@@ -521,7 +521,7 @@ int nf_nat_protocol_register(const struct nf_nat_protocol *proto)
 }
 EXPORT_SYMBOL(nf_nat_protocol_register);
 
-/* Noone stores the protocol anywhere; simply delete it. */
+/* No one stores the protocol anywhere; simply delete it. */
 void nf_nat_protocol_unregister(const struct nf_nat_protocol *proto)
 {
 	spin_lock_bh(&nf_nat_lock);
@@ -532,7 +532,7 @@ void nf_nat_protocol_unregister(const struct nf_nat_protocol *proto)
 }
 EXPORT_SYMBOL(nf_nat_protocol_unregister);
 
-/* Noone using conntrack by the time this called. */
+/* No one using conntrack by the time this called. */
 static void nf_nat_cleanup_conntrack(struct nf_conn *ct)
 {
 	struct nf_conn_nat *nat = nf_ct_ext_find(ct, NF_CT_EXT_NAT);
diff --git a/net/ipv4/raw.c b/net/ipv4/raw.c
index 2d3c72e..bceaec4 100644
--- a/net/ipv4/raw.c
+++ b/net/ipv4/raw.c
@@ -622,7 +622,7 @@ do_confirm:
 static void raw_close(struct sock *sk, long timeout)
 {
 	/*
-	 * Raw sockets may have direct kernel refereneces. Kill them.
+	 * Raw sockets may have direct kernel references. Kill them.
 	 */
 	ip_ra_control(sk, 0, NULL);
 
diff --git a/net/ipv4/route.c b/net/ipv4/route.c
index 4b0c811..ea10751 100644
--- a/net/ipv4/route.c
+++ b/net/ipv4/route.c
@@ -821,7 +821,7 @@ static int has_noalias(const struct rtable *head, const struct rtable *rth)
 }
 
 /*
- * Pertubation of rt_genid by a small quantity [1..256]
+ * Perturbation of rt_genid by a small quantity [1..256]
  * Using 8 bits of shuffling ensure we can call rt_cache_invalidate()
  * many times (2^24) without giving recent rt_genid.
  * Jenkins hash is strong enough that litle changes of rt_genid are OK.
@@ -1191,7 +1191,7 @@ restart:
 #endif
 	/*
 	 * Since lookup is lockfree, we must make sure
-	 * previous writes to rt are comitted to memory
+	 * previous writes to rt are committed to memory
 	 * before making rt visible to other CPUS.
 	 */
 	rcu_assign_pointer(rt_hash_table[hash].chain, rt);
diff --git a/net/ipv4/tcp_lp.c b/net/ipv4/tcp_lp.c
index 656d431..72f7218 100644
--- a/net/ipv4/tcp_lp.c
+++ b/net/ipv4/tcp_lp.c
@@ -12,7 +12,7 @@
  *     within cong_avoid.
  *   o Error correcting in remote HZ, therefore remote HZ will be keeped
  *     on checking and updating.
- *   o Handling calculation of One-Way-Delay (OWD) within rtt_sample, sicne
+ *   o Handling calculation of One-Way-Delay (OWD) within rtt_sample, since
  *     OWD have a similar meaning as RTT. Also correct the buggy formular.
  *   o Handle reaction for Early Congestion Indication (ECI) within
  *     pkts_acked, as mentioned within pseudo code.
diff --git a/net/ipv4/tcp_output.c b/net/ipv4/tcp_output.c
index 8b0d016..17388c7 100644
--- a/net/ipv4/tcp_output.c
+++ b/net/ipv4/tcp_output.c
@@ -73,7 +73,7 @@ static void tcp_event_new_data_sent(struct sock *sk, struct sk_buff *skb)
 	tcp_advance_send_head(sk, skb);
 	tp->snd_nxt = TCP_SKB_CB(skb)->end_seq;
 
-	/* Don't override Nagle indefinately with F-RTO */
+	/* Don't override Nagle indefinitely with F-RTO */
 	if (tp->frto_counter == 2)
 		tp->frto_counter = 3;
 
diff --git a/net/ipv4/tcp_yeah.c b/net/ipv4/tcp_yeah.c
index dc7f431..05c3b6f 100644
--- a/net/ipv4/tcp_yeah.c
+++ b/net/ipv4/tcp_yeah.c
@@ -20,7 +20,7 @@
 #define TCP_YEAH_DELTA        3 //log minimum fraction of cwnd to be removed on loss
 #define TCP_YEAH_EPSILON      1 //log maximum fraction to be removed on early decongestion
 #define TCP_YEAH_PHY          8 //lin maximum delta from base
-#define TCP_YEAH_RHO         16 //lin minumum number of consecutive rtt to consider competition on loss
+#define TCP_YEAH_RHO         16 //lin minimum number of consecutive rtt to consider competition on loss
 #define TCP_YEAH_ZETA        50 //lin minimum number of state switchs to reset reno_count
 
 #define TCP_SCALABLE_AI_CNT	 100U
diff --git a/net/ipv4/udp.c b/net/ipv4/udp.c
index 588f47a..f87a8eb 100644
--- a/net/ipv4/udp.c
+++ b/net/ipv4/udp.c
@@ -189,7 +189,7 @@ static int udp_lib_lport_inuse2(struct net *net, __u16 num,
  *  @sk:          socket struct in question
  *  @snum:        port number to look up
  *  @saddr_comp:  AF-dependent comparison of bound local IP addresses
- *  @hash2_nulladdr: AF-dependant hash value in secondary hash chains,
+ *  @hash2_nulladdr: AF-dependent hash value in secondary hash chains,
  *                   with NULL address
  */
 int udp_lib_get_port(struct sock *sk, unsigned short snum,
diff --git a/net/ipv6/addrconf.c b/net/ipv6/addrconf.c
index 3daaf3c..1493534 100644
--- a/net/ipv6/addrconf.c
+++ b/net/ipv6/addrconf.c
@@ -1084,7 +1084,7 @@ static int ipv6_get_saddr_eval(struct net *net,
 	case IPV6_SADDR_RULE_PRIVACY:
 	    {
 		/* Rule 7: Prefer public address
-		 * Note: prefer temprary address if use_tempaddr >= 2
+		 * Note: prefer temporary address if use_tempaddr >= 2
 		 */
 		int preftmp = dst->prefs & (IPV6_PREFER_SRC_PUBLIC|IPV6_PREFER_SRC_TMP) ?
 				!!(dst->prefs & IPV6_PREFER_SRC_TMP) :
@@ -1968,7 +1968,7 @@ ok:
 					 *  to the stored lifetime since we'll
 					 *  be updating the timestamp below,
 					 *  else we'll set it back to the
-					 *  minumum.
+					 *  minimum.
 					 */
 					if (prefered_lft != ifp->prefered_lft) {
 						valid_lft = stored_lft;
diff --git a/net/ipv6/af_inet6.c b/net/ipv6/af_inet6.c
index 4b13d5d..afcc709 100644
--- a/net/ipv6/af_inet6.c
+++ b/net/ipv6/af_inet6.c
@@ -1113,7 +1113,7 @@ static int __init inet6_init(void)
 	/*
 	 *	ipngwg API draft makes clear that the correct semantics
 	 *	for TCP and UDP is to consider one TCP and UDP instance
-	 *	in a host availiable by both INET and INET6 APIs and
+	 *	in a host available by both INET and INET6 APIs and
 	 *	able to communicate via both network protocols.
 	 */
 
diff --git a/net/ipv6/ip6_output.c b/net/ipv6/ip6_output.c
index 1820887..46cf7be 100644
--- a/net/ipv6/ip6_output.c
+++ b/net/ipv6/ip6_output.c
@@ -779,7 +779,7 @@ slow_path:
 		/* IF: it doesn't fit, use 'mtu' - the data space left */
 		if (len > mtu)
 			len = mtu;
-		/* IF: we are not sending upto and including the packet end
+		/* IF: we are not sending up to and including the packet end
 		   then align the next start on an eight byte boundary */
 		if (len < left)	{
 			len &= ~7;
diff --git a/net/ipv6/netfilter/ip6_tables.c b/net/ipv6/netfilter/ip6_tables.c
index 0b2af9b..5a1c6f2 100644
--- a/net/ipv6/netfilter/ip6_tables.c
+++ b/net/ipv6/netfilter/ip6_tables.c
@@ -2248,7 +2248,7 @@ static int __init ip6_tables_init(void)
 	if (ret < 0)
 		goto err1;
 
-	/* Noone else will be downing sem now, so we won't sleep */
+	/* No one else will be downing sem now, so we won't sleep */
 	ret = xt_register_targets(ip6t_builtin_tg, ARRAY_SIZE(ip6t_builtin_tg));
 	if (ret < 0)
 		goto err2;
diff --git a/net/ipv6/netfilter/nf_defrag_ipv6_hooks.c b/net/ipv6/netfilter/nf_defrag_ipv6_hooks.c
index 97c5b21..cdd6d04 100644
--- a/net/ipv6/netfilter/nf_defrag_ipv6_hooks.c
+++ b/net/ipv6/netfilter/nf_defrag_ipv6_hooks.c
@@ -71,7 +71,7 @@ static unsigned int ipv6_defrag(unsigned int hooknum,
 	if (reasm == NULL)
 		return NF_STOLEN;
 
-	/* error occured or not fragmented */
+	/* error occurred or not fragmented */
 	if (reasm == skb)
 		return NF_ACCEPT;
 
diff --git a/net/irda/irlap.c b/net/irda/irlap.c
index 783c5f3..005b424 100644
--- a/net/irda/irlap.c
+++ b/net/irda/irlap.c
@@ -165,7 +165,7 @@ struct irlap_cb *irlap_open(struct net_device *dev, struct qos_info *qos,
 
 	irlap_apply_default_connection_parameters(self);
 
-	self->N3 = 3; /* # connections attemts to try before giving up */
+	self->N3 = 3; /* # connections attempts to try before giving up */
 
 	self->state = LAP_NDM;
 
diff --git a/net/irda/irlap_event.c b/net/irda/irlap_event.c
index d434c88..bb47021 100644
--- a/net/irda/irlap_event.c
+++ b/net/irda/irlap_event.c
@@ -708,7 +708,7 @@ static int irlap_state_reply(struct irlap_cb *self, IRLAP_EVENT event,
 
 				self->frame_sent = TRUE;
 			}
-			/* Readjust our timer to accomodate devices
+			/* Readjust our timer to accommodate devices
 			 * doing faster or slower discovery than us...
 			 * Jean II */
 			irlap_start_query_timer(self, info->S, info->s);
@@ -931,7 +931,7 @@ static int irlap_state_setup(struct irlap_cb *self, IRLAP_EVENT event,
 		irlap_send_rr_frame(self, CMD_FRAME);
 
 		/* The timer is set to half the normal timer to quickly
-		 * detect a failure to negociate the new connection
+		 * detect a failure to negotiate the new connection
 		 * parameters. IrLAP 6.11.3.2, note 3.
 		 * Note that currently we don't process this failure
 		 * properly, as we should do a quick disconnect.
@@ -1052,7 +1052,7 @@ static int irlap_state_xmit_p(struct irlap_cb *self, IRLAP_EVENT event,
 				return -EPROTO;
 			}
 
-			/* Substract space used by this skb */
+			/* Subtract space used by this skb */
 			self->bytes_left -= skb->len;
 #else	/* CONFIG_IRDA_DYNAMIC_WINDOW */
 			/* Window has been adjusted for the max packet
@@ -1808,7 +1808,7 @@ static int irlap_state_xmit_s(struct irlap_cb *self, IRLAP_EVENT event,
 
 				return -EPROTO; /* Try again later */
 			}
-			/* Substract space used by this skb */
+			/* Subtract space used by this skb */
 			self->bytes_left -= skb->len;
 #else	/* CONFIG_IRDA_DYNAMIC_WINDOW */
 			/* Window has been adjusted for the max packet
diff --git a/net/irda/irlap_frame.c b/net/irda/irlap_frame.c
index 688222c..8c00416 100644
--- a/net/irda/irlap_frame.c
+++ b/net/irda/irlap_frame.c
@@ -848,7 +848,7 @@ void irlap_send_data_primary_poll(struct irlap_cb *self, struct sk_buff *skb)
 	 * though IrLAP is currently sending the *last* frame of the
 	 * tx-window, the driver most likely has only just started
 	 * sending the *first* frame of the same tx-window.
-	 * I.e. we are always at the very begining of or Tx window.
+	 * I.e. we are always at the very beginning of or Tx window.
 	 * Now, we are supposed to set the final timer from the end
 	 * of our tx-window to let the other peer reply. So, we need
 	 * to add extra time to compensate for the fact that we
diff --git a/net/irda/irlmp_event.c b/net/irda/irlmp_event.c
index c1fb5db..9505a7d 100644
--- a/net/irda/irlmp_event.c
+++ b/net/irda/irlmp_event.c
@@ -498,7 +498,7 @@ static int irlmp_state_disconnected(struct lsap_cb *self, IRLMP_EVENT event,
 	switch (event) {
 #ifdef CONFIG_IRDA_ULTRA
 	case LM_UDATA_INDICATION:
-		/* This is most bizzare. Those packets are  aka unreliable
+		/* This is most bizarre. Those packets are  aka unreliable
 		 * connected, aka IrLPT or SOCK_DGRAM/IRDAPROTO_UNITDATA.
 		 * Why do we pass them as Ultra ??? Jean II */
 		irlmp_connless_data_indication(self, skb);
diff --git a/net/irda/irnet/irnet.h b/net/irda/irnet/irnet.h
index 0d82ff5..979ecb2 100644
--- a/net/irda/irnet/irnet.h
+++ b/net/irda/irnet/irnet.h
@@ -73,7 +73,7 @@
  * Infinite thanks to those brave souls for providing the infrastructure
  * upon which IrNET is built.
  *
- * Thanks to all my collegues in HP for helping me. In particular,
+ * Thanks to all my colleagues in HP for helping me. In particular,
  * thanks to Salil Pradhan and Bill Serra for W2k testing...
  * Thanks to Luiz Magalhaes for irnetd and much testing...
  *
diff --git a/net/irda/irqueue.c b/net/irda/irqueue.c
index 849aaf0..9715e6e 100644
--- a/net/irda/irqueue.c
+++ b/net/irda/irqueue.c
@@ -40,7 +40,7 @@
  *	o the hash function for ints is pathetic (but could be changed)
  *	o locking is sometime suspicious (especially during enumeration)
  *	o most users have only a few elements (== overhead)
- *	o most users never use seach, so don't benefit from hashing
+ *	o most users never use search, so don't benefit from hashing
  * Problem already fixed :
  *	o not 64 bit compliant (most users do hashv = (int) self)
  *	o hashbin_remove() is broken => use hashbin_remove_this()
diff --git a/net/irda/irttp.c b/net/irda/irttp.c
index f6054f9..9d9af46 100644
--- a/net/irda/irttp.c
+++ b/net/irda/irttp.c
@@ -1193,7 +1193,7 @@ EXPORT_SYMBOL(irttp_connect_request);
 /*
  * Function irttp_connect_confirm (handle, qos, skb)
  *
- *    Sevice user confirms TSAP connection with peer.
+ *    Service user confirms TSAP connection with peer.
  *
  */
 static void irttp_connect_confirm(void *instance, void *sap,
diff --git a/net/irda/qos.c b/net/irda/qos.c
index 2b00974..1b51bcf 100644
--- a/net/irda/qos.c
+++ b/net/irda/qos.c
@@ -39,16 +39,16 @@
 #include <net/irda/irlap_frame.h>
 
 /*
- * Maximum values of the baud rate we negociate with the other end.
+ * Maximum values of the baud rate we negotiate with the other end.
  * Most often, you don't have to change that, because Linux-IrDA will
  * use the maximum offered by the link layer, which usually works fine.
  * In some very rare cases, you may want to limit it to lower speeds...
  */
 int sysctl_max_baud_rate = 16000000;
 /*
- * Maximum value of the lap disconnect timer we negociate with the other end.
+ * Maximum value of the lap disconnect timer we negotiate with the other end.
  * Most often, the value below represent the best compromise, but some user
- * may want to keep the LAP alive longuer or shorter in case of link failure.
+ * may want to keep the LAP alive longer or shorter in case of link failure.
  * Remember that the threshold time (early warning) is fixed to 3s...
  */
 int sysctl_max_noreply_time = 12;
@@ -411,7 +411,7 @@ static void irlap_adjust_qos_settings(struct qos_info *qos)
 	 * Fix tx data size according to user limits - Jean II
 	 */
 	if (qos->data_size.value > sysctl_max_tx_data_size)
-		/* Allow non discrete adjustement to avoid loosing capacity */
+		/* Allow non discrete adjustement to avoid losing capacity */
 		qos->data_size.value = sysctl_max_tx_data_size;
 	/*
 	 * Override Tx window if user request it. - Jean II
diff --git a/net/irda/timer.c b/net/irda/timer.c
index 0335ba0..f418cb2 100644
--- a/net/irda/timer.c
+++ b/net/irda/timer.c
@@ -59,7 +59,7 @@ void irlap_start_query_timer(struct irlap_cb *self, int S, int s)
 	 * slot time, plus add some extra time to properly receive the last
 	 * discovery packet (which is longer due to extra discovery info),
 	 * to avoid messing with for incomming connections requests and
-	 * to accomodate devices that perform discovery slower than us.
+	 * to accommodate devices that perform discovery slower than us.
 	 * Jean II */
 	timeout = ((sysctl_slot_timeout * HZ / 1000) * (S - s)
 		   + XIDEXTRA_TIMEOUT + SMALLBUSY_TIMEOUT);
diff --git a/net/iucv/af_iucv.c b/net/iucv/af_iucv.c
index 9637e45..986b2a5 100644
--- a/net/iucv/af_iucv.c
+++ b/net/iucv/af_iucv.c
@@ -250,7 +250,7 @@ static struct device *af_iucv_dev;
  *	PRMDATA[0..6]	socket data (max 7 bytes);
  *	PRMDATA[7]	socket data length value (len is 0xff - PRMDATA[7])
  *
- * The socket data length is computed by substracting the socket data length
+ * The socket data length is computed by subtracting the socket data length
  * value from 0xFF.
  * If the socket data len is greater 7, then PRMDATA can be used for special
  * notifications (see iucv_sock_shutdown); and further,
diff --git a/net/iucv/iucv.c b/net/iucv/iucv.c
index 1ee5dab..8f156bd 100644
--- a/net/iucv/iucv.c
+++ b/net/iucv/iucv.c
@@ -735,7 +735,7 @@ static void iucv_cleanup_queue(void)
 	struct iucv_irq_list *p, *n;
 
 	/*
-	 * When a path is severed, the pathid can be reused immediatly
+	 * When a path is severed, the pathid can be reused immediately
 	 * on a iucv connect or a connection pending interrupt. Remove
 	 * all entries from the task queue that refer to a stale pathid
 	 * (iucv_path_table[ix] == NULL). Only then do the iucv connect
@@ -807,7 +807,7 @@ void iucv_unregister(struct iucv_handler *handler, int smp)
 	spin_lock_bh(&iucv_table_lock);
 	/* Remove handler from the iucv_handler_list. */
 	list_del_init(&handler->list);
-	/* Sever all pathids still refering to the handler. */
+	/* Sever all pathids still referring to the handler. */
 	list_for_each_entry_safe(p, n, &handler->paths, list) {
 		iucv_sever_pathid(p->pathid, NULL);
 		iucv_path_table[p->pathid] = NULL;
diff --git a/net/mac80211/ieee80211_i.h b/net/mac80211/ieee80211_i.h
index a404017..c18396c 100644
--- a/net/mac80211/ieee80211_i.h
+++ b/net/mac80211/ieee80211_i.h
@@ -97,7 +97,7 @@ struct ieee80211_bss {
 	size_t supp_rates_len;
 
 	/*
-	 * During assocation, we save an ERP value from a probe response so
+	 * During association, we save an ERP value from a probe response so
 	 * that we can feed ERP info to the driver when handling the
 	 * association completes. these fields probably won't be up-to-date
 	 * otherwise, you probably don't want to use them.
diff --git a/net/mac80211/mesh_pathtbl.c b/net/mac80211/mesh_pathtbl.c
index 8d65b47..336ca9d 100644
--- a/net/mac80211/mesh_pathtbl.c
+++ b/net/mac80211/mesh_pathtbl.c
@@ -628,7 +628,7 @@ void mesh_path_discard_frame(struct sk_buff *skb,
  *
  * @mpath: mesh path whose queue has to be freed
  *
- * Locking: the function must me called withing a rcu_read_lock region
+ * Locking: the function must me called within a rcu_read_lock region
  */
 void mesh_path_flush_pending(struct mesh_path *mpath)
 {
diff --git a/net/mac80211/rc80211_minstrel_ht.c b/net/mac80211/rc80211_minstrel_ht.c
index dbdebed..c06aa3a 100644
--- a/net/mac80211/rc80211_minstrel_ht.c
+++ b/net/mac80211/rc80211_minstrel_ht.c
@@ -259,7 +259,7 @@ minstrel_ht_update_stats(struct minstrel_priv *mp, struct minstrel_ht_sta *mi)
 		}
 	}
 
-	/* try to sample up to half of the availble rates during each interval */
+	/* try to sample up to half of the available rates during each interval */
 	mi->sample_count *= 4;
 
 	cur_prob = 0;
diff --git a/net/mac80211/rc80211_pid.h b/net/mac80211/rc80211_pid.h
index 6510f8e..19111c7 100644
--- a/net/mac80211/rc80211_pid.h
+++ b/net/mac80211/rc80211_pid.h
@@ -77,7 +77,7 @@ union rc_pid_event_data {
 };
 
 struct rc_pid_event {
-	/* The time when the event occured */
+	/* The time when the event occurred */
 	unsigned long timestamp;
 
 	/* Event ID number */
diff --git a/net/mac80211/rx.c b/net/mac80211/rx.c
index aa5cc37..9d192d6 100644
--- a/net/mac80211/rx.c
+++ b/net/mac80211/rx.c
@@ -381,7 +381,7 @@ static void ieee80211_parse_qos(struct ieee80211_rx_data *rx)
  * specs were sane enough this time around to require padding each A-MSDU
  * subframe to a length that is a multiple of four.
  *
- * Padding like Atheros hardware adds which is inbetween the 802.11 header and
+ * Padding like Atheros hardware adds which is between the 802.11 header and
  * the payload is not supported, the driver is required to move the 802.11
  * header to be directly in front of the payload in that case.
  */
diff --git a/net/mac80211/sta_info.c b/net/mac80211/sta_info.c
index d0311a3..13e8c30 100644
--- a/net/mac80211/sta_info.c
+++ b/net/mac80211/sta_info.c
@@ -47,9 +47,9 @@
  * Station entries are added by mac80211 when you establish a link with a
  * peer. This means different things for the different type of interfaces
  * we support. For a regular station this mean we add the AP sta when we
- * receive an assocation response from the AP. For IBSS this occurs when
+ * receive an association response from the AP. For IBSS this occurs when
  * get to know about a peer on the same IBSS. For WDS we add the sta for
- * the peer imediately upon device open. When using AP mode we add stations
+ * the peer immediately upon device open. When using AP mode we add stations
  * for each respective station upon request from userspace through nl80211.
  *
  * In order to remove a STA info structure, various sta_info_destroy_*()
diff --git a/net/mac80211/sta_info.h b/net/mac80211/sta_info.h
index 5768114..b2f9596 100644
--- a/net/mac80211/sta_info.h
+++ b/net/mac80211/sta_info.h
@@ -173,7 +173,7 @@ struct sta_ampdu_mlme {
 /**
  * enum plink_state - state of a mesh peer link finite state machine
  *
- * @PLINK_LISTEN: initial state, considered the implicit state of non existant
+ * @PLINK_LISTEN: initial state, considered the implicit state of non existent
  * 	mesh peer links
  * @PLINK_OPN_SNT: mesh plink open frame has been sent to this mesh peer
  * @PLINK_OPN_RCVD: mesh plink open frame has been received from this mesh peer
diff --git a/net/netfilter/ipset/ip_set_core.c b/net/netfilter/ipset/ip_set_core.c
index d6b4823..253326e 100644
--- a/net/netfilter/ipset/ip_set_core.c
+++ b/net/netfilter/ipset/ip_set_core.c
@@ -893,7 +893,7 @@ ip_set_swap(struct sock *ctnl, struct sk_buff *skb,
 	to = ip_set_list[to_id];
 
 	/* Features must not change.
-	 * Not an artifical restriction anymore, as we must prevent
+	 * Not an artificial restriction anymore, as we must prevent
 	 * possible loops created by swapping in setlist type of sets. */
 	if (!(from->type->features == to->type->features &&
 	      from->type->family == to->type->family))
diff --git a/net/netfilter/ipvs/ip_vs_conn.c b/net/netfilter/ipvs/ip_vs_conn.c
index f289306..c97bd45 100644
--- a/net/netfilter/ipvs/ip_vs_conn.c
+++ b/net/netfilter/ipvs/ip_vs_conn.c
@@ -595,7 +595,7 @@ ip_vs_bind_dest(struct ip_vs_conn *cp, struct ip_vs_dest *dest)
 			atomic_inc(&dest->inactconns);
 	} else {
 		/* It is a persistent connection/template, so increase
-		   the peristent connection counter */
+		   the persistent connection counter */
 		atomic_inc(&dest->persistconns);
 	}
 
@@ -657,7 +657,7 @@ static inline void ip_vs_unbind_dest(struct ip_vs_conn *cp)
 		}
 	} else {
 		/* It is a persistent connection/template, so decrease
-		   the peristent connection counter */
+		   the persistent connection counter */
 		atomic_dec(&dest->persistconns);
 	}
 
diff --git a/net/netfilter/ipvs/ip_vs_lblc.c b/net/netfilter/ipvs/ip_vs_lblc.c
index f276df9..87e40ea 100644
--- a/net/netfilter/ipvs/ip_vs_lblc.c
+++ b/net/netfilter/ipvs/ip_vs_lblc.c
@@ -131,7 +131,7 @@ static inline void ip_vs_lblc_free(struct ip_vs_lblc_entry *en)
 {
 	list_del(&en->list);
 	/*
-	 * We don't kfree dest because it is refered either by its service
+	 * We don't kfree dest because it is referred either by its service
 	 * or the trash dest list.
 	 */
 	atomic_dec(&en->dest->refcnt);
diff --git a/net/netfilter/ipvs/ip_vs_lblcr.c b/net/netfilter/ipvs/ip_vs_lblcr.c
index cb1c991..90f618a 100644
--- a/net/netfilter/ipvs/ip_vs_lblcr.c
+++ b/net/netfilter/ipvs/ip_vs_lblcr.c
@@ -152,7 +152,7 @@ static void ip_vs_dest_set_eraseall(struct ip_vs_dest_set *set)
 	write_lock(&set->lock);
 	list_for_each_entry_safe(e, ep, &set->list, list) {
 		/*
-		 * We don't kfree dest because it is refered either
+		 * We don't kfree dest because it is referred either
 		 * by its service or by the trash dest list.
 		 */
 		atomic_dec(&e->dest->refcnt);
diff --git a/net/netfilter/ipvs/ip_vs_proto_sctp.c b/net/netfilter/ipvs/ip_vs_proto_sctp.c
index b027ccc..d12ed53 100644
--- a/net/netfilter/ipvs/ip_vs_proto_sctp.c
+++ b/net/netfilter/ipvs/ip_vs_proto_sctp.c
@@ -566,7 +566,7 @@ static struct ipvs_sctp_nextstate
 	 * SHUTDOWN sent from the client, waitinf for SHUT ACK from the server
 	 */
 	/*
-	 * We recieved the data chuck, keep the state unchanged. I assume
+	 * We received the data chuck, keep the state unchanged. I assume
 	 * that still data chuncks  can be received by both the peers in
 	 * SHUDOWN state
 	 */
@@ -633,7 +633,7 @@ static struct ipvs_sctp_nextstate
 	 * SHUTDOWN sent from the server, waitinf for SHUTDOWN ACK from client
 	 */
 	/*
-	 * We recieved the data chuck, keep the state unchanged. I assume
+	 * We received the data chuck, keep the state unchanged. I assume
 	 * that still data chuncks  can be received by both the peers in
 	 * SHUDOWN state
 	 */
@@ -701,7 +701,7 @@ static struct ipvs_sctp_nextstate
 	 * SHUTDOWN ACK from the client, awaiting for SHUTDOWN COM from server
 	 */
 	/*
-	 * We recieved the data chuck, keep the state unchanged. I assume
+	 * We received the data chuck, keep the state unchanged. I assume
 	 * that still data chuncks  can be received by both the peers in
 	 * SHUDOWN state
 	 */
@@ -771,7 +771,7 @@ static struct ipvs_sctp_nextstate
 	 * SHUTDOWN ACK from the server, awaiting for SHUTDOWN COM from client
 	 */
 	/*
-	 * We recieved the data chuck, keep the state unchanged. I assume
+	 * We received the data chuck, keep the state unchanged. I assume
 	 * that still data chuncks  can be received by both the peers in
 	 * SHUDOWN state
 	 */
diff --git a/net/netfilter/nf_conntrack_core.c b/net/netfilter/nf_conntrack_core.c
index 941286c..2e1c11f 100644
--- a/net/netfilter/nf_conntrack_core.c
+++ b/net/netfilter/nf_conntrack_core.c
@@ -453,7 +453,7 @@ __nf_conntrack_confirm(struct sk_buff *skb)
 	   REJECT will give spurious warnings here. */
 	/* NF_CT_ASSERT(atomic_read(&ct->ct_general.use) == 1); */
 
-	/* No external references means noone else could have
+	/* No external references means no one else could have
 	   confirmed us. */
 	NF_CT_ASSERT(!nf_ct_is_confirmed(ct));
 	pr_debug("Confirming conntrack %p\n", ct);
@@ -901,7 +901,7 @@ nf_conntrack_in(struct net *net, u_int8_t pf, unsigned int hooknum,
 	ret = l3proto->get_l4proto(skb, skb_network_offset(skb),
 				   &dataoff, &protonum);
 	if (ret <= 0) {
-		pr_debug("not prepared to track yet or error occured\n");
+		pr_debug("not prepared to track yet or error occurred\n");
 		NF_CT_STAT_INC_ATOMIC(net, error);
 		NF_CT_STAT_INC_ATOMIC(net, invalid);
 		ret = -ret;
diff --git a/net/netfilter/nf_conntrack_proto_dccp.c b/net/netfilter/nf_conntrack_proto_dccp.c
index 9ae57c5..2e664a6 100644
--- a/net/netfilter/nf_conntrack_proto_dccp.c
+++ b/net/netfilter/nf_conntrack_proto_dccp.c
@@ -98,7 +98,7 @@ static const char * const dccp_state_names[] = {
 #define sIV	CT_DCCP_INVALID
 
 /*
- * DCCP state transistion table
+ * DCCP state transition table
  *
  * The assumption is the same as for TCP tracking:
  *
diff --git a/net/netfilter/nf_conntrack_proto_sctp.c b/net/netfilter/nf_conntrack_proto_sctp.c
index 6f4ee70..6772b11 100644
--- a/net/netfilter/nf_conntrack_proto_sctp.c
+++ b/net/netfilter/nf_conntrack_proto_sctp.c
@@ -107,9 +107,9 @@ static const u8 sctp_conntracks[2][9][SCTP_CONNTRACK_MAX] = {
 /* abort        */ {sCL, sCL, sCL, sCL, sCL, sCL, sCL, sCL},
 /* shutdown     */ {sCL, sCL, sCW, sCE, sSS, sSS, sSR, sSA},
 /* shutdown_ack */ {sSA, sCL, sCW, sCE, sES, sSA, sSA, sSA},
-/* error        */ {sCL, sCL, sCW, sCE, sES, sSS, sSR, sSA},/* Cant have Stale cookie*/
+/* error        */ {sCL, sCL, sCW, sCE, sES, sSS, sSR, sSA},/* Can't have Stale cookie*/
 /* cookie_echo  */ {sCL, sCL, sCE, sCE, sES, sSS, sSR, sSA},/* 5.2.4 - Big TODO */
-/* cookie_ack   */ {sCL, sCL, sCW, sCE, sES, sSS, sSR, sSA},/* Cant come in orig dir */
+/* cookie_ack   */ {sCL, sCL, sCW, sCE, sES, sSS, sSR, sSA},/* Can't come in orig dir */
 /* shutdown_comp*/ {sCL, sCL, sCW, sCE, sES, sSS, sSR, sCL}
 	},
 	{
@@ -121,7 +121,7 @@ static const u8 sctp_conntracks[2][9][SCTP_CONNTRACK_MAX] = {
 /* shutdown     */ {sIV, sCL, sCW, sCE, sSR, sSS, sSR, sSA},
 /* shutdown_ack */ {sIV, sCL, sCW, sCE, sES, sSA, sSA, sSA},
 /* error        */ {sIV, sCL, sCW, sCL, sES, sSS, sSR, sSA},
-/* cookie_echo  */ {sIV, sCL, sCW, sCE, sES, sSS, sSR, sSA},/* Cant come in reply dir */
+/* cookie_echo  */ {sIV, sCL, sCW, sCE, sES, sSS, sSR, sSA},/* Can't come in reply dir */
 /* cookie_ack   */ {sIV, sCL, sCW, sES, sES, sSS, sSR, sSA},
 /* shutdown_comp*/ {sIV, sCL, sCW, sCE, sES, sSS, sSR, sCL}
 	}
diff --git a/net/netfilter/nf_conntrack_sip.c b/net/netfilter/nf_conntrack_sip.c
index bcf47eb..237cc19 100644
--- a/net/netfilter/nf_conntrack_sip.c
+++ b/net/netfilter/nf_conntrack_sip.c
@@ -707,7 +707,7 @@ static const char *ct_sdp_header_search(const char *dptr, const char *limit,
 }
 
 /* Locate a SDP header (optionally a substring within the header value),
- * optionally stopping at the first occurence of the term header, parse
+ * optionally stopping at the first occurrence of the term header, parse
  * it and return the offset and length of the data we're interested in.
  */
 int ct_sip_get_sdp_header(const struct nf_conn *ct, const char *dptr,
diff --git a/net/netfilter/nf_queue.c b/net/netfilter/nf_queue.c
index 5ab22e2..5b466cd 100644
--- a/net/netfilter/nf_queue.c
+++ b/net/netfilter/nf_queue.c
@@ -134,7 +134,7 @@ static int __nf_queue(struct sk_buff *skb,
 	const struct nf_afinfo *afinfo;
 	const struct nf_queue_handler *qh;
 
-	/* QUEUE == DROP if noone is waiting, to be safe. */
+	/* QUEUE == DROP if no one is waiting, to be safe. */
 	rcu_read_lock();
 
 	qh = rcu_dereference(queue_handler[pf]);
diff --git a/net/netlabel/netlabel_domainhash.c b/net/netlabel/netlabel_domainhash.c
index d37b7f8..de0d8e4 100644
--- a/net/netlabel/netlabel_domainhash.c
+++ b/net/netlabel/netlabel_domainhash.c
@@ -109,7 +109,7 @@ static void netlbl_domhsh_free_entry(struct rcu_head *entry)
  *
  * Description:
  * This is the hashing function for the domain hash table, it returns the
- * correct bucket number for the domain.  The caller is responsibile for
+ * correct bucket number for the domain.  The caller is responsible for
  * ensuring that the hash table is protected with either a RCU read lock or the
  * hash table lock.
  *
@@ -134,7 +134,7 @@ static u32 netlbl_domhsh_hash(const char *key)
  *
  * Description:
  * Searches the domain hash table and returns a pointer to the hash table
- * entry if found, otherwise NULL is returned.  The caller is responsibile for
+ * entry if found, otherwise NULL is returned.  The caller is responsible for
  * ensuring that the hash table is protected with either a RCU read lock or the
  * hash table lock.
  *
@@ -165,7 +165,7 @@ static struct netlbl_dom_map *netlbl_domhsh_search(const char *domain)
  * Searches the domain hash table and returns a pointer to the hash table
  * entry if an exact match is found, if an exact match is not present in the
  * hash table then the default entry is returned if valid otherwise NULL is
- * returned.  The caller is responsibile ensuring that the hash table is
+ * returned.  The caller is responsible ensuring that the hash table is
  * protected with either a RCU read lock or the hash table lock.
  *
  */
@@ -193,7 +193,7 @@ static struct netlbl_dom_map *netlbl_domhsh_search_def(const char *domain)
  *
  * Description:
  * Generate an audit record for adding a new NetLabel/LSM mapping entry with
- * the given information.  Caller is responsibile for holding the necessary
+ * the given information.  Caller is responsible for holding the necessary
  * locks.
  *
  */
@@ -605,7 +605,7 @@ int netlbl_domhsh_remove_default(struct netlbl_audit *audit_info)
  *
  * Description:
  * Look through the domain hash table searching for an entry to match @domain,
- * return a pointer to a copy of the entry or NULL.  The caller is responsibile
+ * return a pointer to a copy of the entry or NULL.  The caller is responsible
  * for ensuring that rcu_read_[un]lock() is called.
  *
  */
diff --git a/net/netlabel/netlabel_mgmt.c b/net/netlabel/netlabel_mgmt.c
index 998e85e..4f251b1 100644
--- a/net/netlabel/netlabel_mgmt.c
+++ b/net/netlabel/netlabel_mgmt.c
@@ -259,7 +259,7 @@ add_failure:
  *
  * Description:
  * This function is a helper function used by the LISTALL and LISTDEF command
- * handlers.  The caller is responsibile for ensuring that the RCU read lock
+ * handlers.  The caller is responsible for ensuring that the RCU read lock
  * is held.  Returns zero on success, negative values on failure.
  *
  */
diff --git a/net/rds/ib_send.c b/net/rds/ib_send.c
index c47a511..7c4dce8 100644
--- a/net/rds/ib_send.c
+++ b/net/rds/ib_send.c
@@ -355,7 +355,7 @@ void rds_ib_send_cq_comp_handler(struct ib_cq *cq, void *context)
  *
  * Conceptually, we have two counters:
  *  -	send credits: this tells us how many WRs we're allowed
- *	to submit without overruning the reciever's queue. For
+ *	to submit without overruning the receiver's queue. For
  *	each SEND WR we post, we decrement this by one.
  *
  *  -	posted credits: this tells us how many WRs we recently
diff --git a/net/rds/iw_cm.c b/net/rds/iw_cm.c
index 712cf2d..3a60a15 100644
--- a/net/rds/iw_cm.c
+++ b/net/rds/iw_cm.c
@@ -181,7 +181,7 @@ static int rds_iw_init_qp_attrs(struct ib_qp_init_attr *attr,
 	unsigned int send_size, recv_size;
 	int ret;
 
-	/* The offset of 1 is to accomodate the additional ACK WR. */
+	/* The offset of 1 is to accommodate the additional ACK WR. */
 	send_size = min_t(unsigned int, rds_iwdev->max_wrs, rds_iw_sysctl_max_send_wr + 1);
 	recv_size = min_t(unsigned int, rds_iwdev->max_wrs, rds_iw_sysctl_max_recv_wr + 1);
 	rds_iw_ring_resize(send_ring, send_size - 1);
diff --git a/net/rds/iw_rdma.c b/net/rds/iw_rdma.c
index 59509e9..6deaa77 100644
--- a/net/rds/iw_rdma.c
+++ b/net/rds/iw_rdma.c
@@ -122,7 +122,7 @@ static int rds_iw_get_device(struct rds_sock *rs, struct rds_iw_device **rds_iwd
 #else
 			/* FIXME - needs to compare the local and remote
 			 * ipaddr/port tuple, but the ipaddr is the only
-			 * available infomation in the rds_sock (as the rest are
+			 * available information in the rds_sock (as the rest are
 			 * zero'ed.  It doesn't appear to be properly populated
 			 * during connection setup...
 			 */
diff --git a/net/rds/iw_send.c b/net/rds/iw_send.c
index 6280ea0..545d8ee 100644
--- a/net/rds/iw_send.c
+++ b/net/rds/iw_send.c
@@ -307,7 +307,7 @@ void rds_iw_send_cq_comp_handler(struct ib_cq *cq, void *context)
  *
  * Conceptually, we have two counters:
  *  -	send credits: this tells us how many WRs we're allowed
- *	to submit without overruning the reciever's queue. For
+ *	to submit without overruning the receiver's queue. For
  *	each SEND WR we post, we decrement this by one.
  *
  *  -	posted credits: this tells us how many WRs we recently
diff --git a/net/rds/send.c b/net/rds/send.c
index 35b9c2e..d58ae5f 100644
--- a/net/rds/send.c
+++ b/net/rds/send.c
@@ -116,7 +116,7 @@ static void release_in_xmit(struct rds_connection *conn)
 }
 
 /*
- * We're making the concious trade-off here to only send one message
+ * We're making the conscious trade-off here to only send one message
  * down the connection at a time.
  *   Pro:
  *      - tx queueing is a simple fifo list
diff --git a/net/rose/rose_route.c b/net/rose/rose_route.c
index 08dcd2f..479cae5 100644
--- a/net/rose/rose_route.c
+++ b/net/rose/rose_route.c
@@ -587,7 +587,7 @@ static int rose_clear_routes(void)
 
 /*
  *	Check that the device given is a valid AX.25 interface that is "up".
- * 	called whith RTNL
+ * 	called with RTNL
  */
 static struct net_device *rose_ax25_dev_find(char *devname)
 {
diff --git a/net/sched/act_api.c b/net/sched/act_api.c
index 15873e1..14b42f4 100644
--- a/net/sched/act_api.c
+++ b/net/sched/act_api.c
@@ -999,7 +999,7 @@ static int tc_ctl_action(struct sk_buff *skb, struct nlmsghdr *n, void *arg)
 	switch (n->nlmsg_type) {
 	case RTM_NEWACTION:
 		/* we are going to assume all other flags
-		 * imply create only if it doesnt exist
+		 * imply create only if it doesn't exist
 		 * Note that CREATE | EXCL implies that
 		 * but since we want avoid ambiguity (eg when flags
 		 * is zero) then just set this
diff --git a/net/sched/act_pedit.c b/net/sched/act_pedit.c
index 50c7c06..7affe9a 100644
--- a/net/sched/act_pedit.c
+++ b/net/sched/act_pedit.c
@@ -161,7 +161,7 @@ static int tcf_pedit(struct sk_buff *skb, struct tc_action *a,
 			}
 			if (offset > 0 && offset > skb->len) {
 				pr_info("tc filter pedit"
-					" offset %d cant exceed pkt length %d\n",
+					" offset %d can't exceed pkt length %d\n",
 				       offset, skb->len);
 				goto bad;
 			}
diff --git a/net/sched/em_meta.c b/net/sched/em_meta.c
index a4de67e..49130e8 100644
--- a/net/sched/em_meta.c
+++ b/net/sched/em_meta.c
@@ -47,7 +47,7 @@
  * 	on the meta type. Obviously, the length of the data must also
  * 	be provided for non-numeric types.
  *
- * 	Additionaly, type dependant modifiers such as shift operators
+ * 	Additionally, type dependent modifiers such as shift operators
  * 	or mask may be applied to extend the functionaliy. As of now,
  * 	the variable length type supports shifting the byte string to
  * 	the right, eating up any number of octets and thus supporting
diff --git a/net/sched/sch_htb.c b/net/sched/sch_htb.c
index e1429a8..29b942c 100644
--- a/net/sched/sch_htb.c
+++ b/net/sched/sch_htb.c
@@ -183,7 +183,7 @@ static inline struct htb_class *htb_find(u32 handle, struct Qdisc *sch)
  * filters in qdisc and in inner nodes (if higher filter points to the inner
  * node). If we end up with classid MAJOR:0 we enqueue the skb into special
  * internal fifo (direct). These packets then go directly thru. If we still
- * have no valid leaf we try to use MAJOR:default leaf. It still unsuccessfull
+ * have no valid leaf we try to use MAJOR:default leaf. It still unsuccessful
  * then finish and return direct queue.
  */
 #define HTB_DIRECT ((struct htb_class *)-1L)
diff --git a/net/sched/sch_netem.c b/net/sched/sch_netem.c
index edbbf7a..69c35f6 100644
--- a/net/sched/sch_netem.c
+++ b/net/sched/sch_netem.c
@@ -160,7 +160,7 @@ static bool loss_4state(struct netem_sched_data *q)
 	u32 rnd = net_random();
 
 	/*
-	 * Makes a comparision between rnd and the transition
+	 * Makes a comparison between rnd and the transition
 	 * probabilities outgoing from the current state, then decides the
 	 * next state and if the next packet has to be transmitted or lost.
 	 * The four states correspond to:
@@ -212,9 +212,9 @@ static bool loss_4state(struct netem_sched_data *q)
  * Generates losses according to the Gilbert-Elliot loss model or
  * its special cases  (Gilbert or Simple Gilbert)
  *
- * Makes a comparision between random number and the transition
+ * Makes a comparison between random number and the transition
  * probabilities outgoing from the current state, then decides the
- * next state. A second random number is extracted and the comparision
+ * next state. A second random number is extracted and the comparison
  * with the loss probability of the current state decides if the next
  * packet will be transmitted or lost.
  */
diff --git a/net/sctp/associola.c b/net/sctp/associola.c
index 6b04287..0698cad 100644
--- a/net/sctp/associola.c
+++ b/net/sctp/associola.c
@@ -1593,7 +1593,7 @@ void sctp_assoc_clean_asconf_ack_cache(const struct sctp_association *asoc)
 	struct sctp_chunk *ack;
 	struct sctp_chunk *tmp;
 
-	/* We can remove all the entries from the queue upto
+	/* We can remove all the entries from the queue up to
 	 * the "Peer-Sequence-Number".
 	 */
 	list_for_each_entry_safe(ack, tmp, &asoc->asconf_ack_list,
diff --git a/net/sctp/auth.c b/net/sctp/auth.c
index ddbbf7c..865e68f 100644
--- a/net/sctp/auth.c
+++ b/net/sctp/auth.c
@@ -113,7 +113,7 @@ struct sctp_shared_key *sctp_auth_shkey_create(__u16 key_id, gfp_t gfp)
 	return new;
 }
 
-/* Free the shared key stucture */
+/* Free the shared key structure */
 static void sctp_auth_shkey_free(struct sctp_shared_key *sh_key)
 {
 	BUG_ON(!list_empty(&sh_key->key_list));
@@ -122,7 +122,7 @@ static void sctp_auth_shkey_free(struct sctp_shared_key *sh_key)
 	kfree(sh_key);
 }
 
-/* Destory the entire key list.  This is done during the
+/* Destroy the entire key list.  This is done during the
  * associon and endpoint free process.
  */
 void sctp_auth_destroy_keys(struct list_head *keys)
@@ -324,7 +324,7 @@ static struct sctp_auth_bytes *sctp_auth_asoc_create_secret(
 	if (!peer_key_vector || !local_key_vector)
 		goto out;
 
-	/* Figure out the order in wich the key_vectors will be
+	/* Figure out the order in which the key_vectors will be
 	 * added to the endpoint shared key.
 	 * SCTP-AUTH, Section 6.1:
 	 *   This is performed by selecting the numerically smaller key
diff --git a/net/sctp/input.c b/net/sctp/input.c
index 826661b..5436c69 100644
--- a/net/sctp/input.c
+++ b/net/sctp/input.c
@@ -1034,7 +1034,7 @@ static struct sctp_association *__sctp_rcv_asconf_lookup(
 *    association.
 *
 * This means that any chunks that can help us identify the association need
-* to be looked at to find this assocation.
+* to be looked at to find this association.
 */
 static struct sctp_association *__sctp_rcv_walk_lookup(struct sk_buff *skb,
 				      const union sctp_addr *laddr,
diff --git a/net/sctp/output.c b/net/sctp/output.c
index 60600d3..b4f3cf0 100644
--- a/net/sctp/output.c
+++ b/net/sctp/output.c
@@ -510,7 +510,7 @@ int sctp_packet_transmit(struct sctp_packet *packet)
 		sh->checksum = sctp_end_cksum(crc32);
 	} else {
 		if (dst->dev->features & NETIF_F_SCTP_CSUM) {
-			/* no need to seed psuedo checksum for SCTP */
+			/* no need to seed pseudo checksum for SCTP */
 			nskb->ip_summed = CHECKSUM_PARTIAL;
 			nskb->csum_start = (skb_transport_header(nskb) -
 			                    nskb->head);
diff --git a/net/sctp/outqueue.c b/net/sctp/outqueue.c
index 26dc005..bf92a5b 100644
--- a/net/sctp/outqueue.c
+++ b/net/sctp/outqueue.c
@@ -177,13 +177,13 @@ static inline int sctp_cacc_skip_3_2(struct sctp_transport *primary, __u32 tsn)
  * 3) If the missing report count for TSN t is to be
  * incremented according to [RFC2960] and
  * [SCTP_STEWART-2002], and CHANGEOVER_ACTIVE is set,
- * then the sender MUST futher execute steps 3.1 and
+ * then the sender MUST further execute steps 3.1 and
  * 3.2 to determine if the missing report count for
  * TSN t SHOULD NOT be incremented.
  *
  * 3.3) If 3.1 and 3.2 do not dictate that the missing
  * report count for t should not be incremented, then
- * the sender SOULD increment missing report count for
+ * the sender SHOULD increment missing report count for
  * t (according to [RFC2960] and [SCTP_STEWART_2002]).
  */
 static inline int sctp_cacc_skip(struct sctp_transport *primary,
@@ -843,7 +843,7 @@ static int sctp_outq_flush(struct sctp_outq *q, int rtx_timeout)
 		case SCTP_CID_ECN_CWR:
 		case SCTP_CID_ASCONF_ACK:
 			one_packet = 1;
-			/* Fall throught */
+			/* Fall through */
 
 		case SCTP_CID_SACK:
 		case SCTP_CID_HEARTBEAT:
diff --git a/net/sctp/sm_sideeffect.c b/net/sctp/sm_sideeffect.c
index b21b218..5f86ee4 100644
--- a/net/sctp/sm_sideeffect.c
+++ b/net/sctp/sm_sideeffect.c
@@ -482,7 +482,7 @@ static void sctp_do_8_2_transport_strike(struct sctp_association *asoc,
 	 * If the timer was a heartbeat, we only increment error counts
 	 * when we already have an outstanding HEARTBEAT that has not
 	 * been acknowledged.
-	 * Additionaly, some tranport states inhibit error increments.
+	 * Additionally, some tranport states inhibit error increments.
 	 */
 	if (!is_hb) {
 		asoc->overall_error_count++;
diff --git a/net/sctp/sm_statefuns.c b/net/sctp/sm_statefuns.c
index 4b4eb7c..7679208 100644
--- a/net/sctp/sm_statefuns.c
+++ b/net/sctp/sm_statefuns.c
@@ -551,7 +551,7 @@ sctp_disposition_t sctp_sf_do_5_1C_ack(const struct sctp_endpoint *ep,
 		 *
 		 * This means that if we only want to abort associations
 		 * in an authenticated way (i.e AUTH+ABORT), then we
-		 * can't destroy this association just becuase the packet
+		 * can't destroy this association just because the packet
 		 * was malformed.
 		 */
 		if (sctp_auth_recv_cid(SCTP_CID_ABORT, asoc))
@@ -1546,7 +1546,7 @@ cleanup:
 }
 
 /*
- * Handle simultanous INIT.
+ * Handle simultaneous INIT.
  * This means we started an INIT and then we got an INIT request from
  * our peer.
  *
@@ -2079,7 +2079,7 @@ sctp_disposition_t sctp_sf_shutdown_pending_abort(
 	 * RFC 2960, Section 3.3.7
 	 *    If an endpoint receives an ABORT with a format error or for an
 	 *    association that doesn't exist, it MUST silently discard it.
-	 * Becasue the length is "invalid", we can't really discard just
+	 * Because the length is "invalid", we can't really discard just
 	 * as we do not know its true length.  So, to be safe, discard the
 	 * packet.
 	 */
@@ -2120,7 +2120,7 @@ sctp_disposition_t sctp_sf_shutdown_sent_abort(const struct sctp_endpoint *ep,
 	 * RFC 2960, Section 3.3.7
 	 *    If an endpoint receives an ABORT with a format error or for an
 	 *    association that doesn't exist, it MUST silently discard it.
-	 * Becasue the length is "invalid", we can't really discard just
+	 * Because the length is "invalid", we can't really discard just
 	 * as we do not know its true length.  So, to be safe, discard the
 	 * packet.
 	 */
@@ -2381,7 +2381,7 @@ sctp_disposition_t sctp_sf_do_9_1_abort(const struct sctp_endpoint *ep,
 	 * RFC 2960, Section 3.3.7
 	 *    If an endpoint receives an ABORT with a format error or for an
 	 *    association that doesn't exist, it MUST silently discard it.
-	 * Becasue the length is "invalid", we can't really discard just
+	 * Because the length is "invalid", we can't really discard just
 	 * as we do not know its true length.  So, to be safe, discard the
 	 * packet.
 	 */
@@ -2448,7 +2448,7 @@ sctp_disposition_t sctp_sf_cookie_wait_abort(const struct sctp_endpoint *ep,
 	 * RFC 2960, Section 3.3.7
 	 *    If an endpoint receives an ABORT with a format error or for an
 	 *    association that doesn't exist, it MUST silently discard it.
-	 * Becasue the length is "invalid", we can't really discard just
+	 * Because the length is "invalid", we can't really discard just
 	 * as we do not know its true length.  So, to be safe, discard the
 	 * packet.
 	 */
@@ -3855,7 +3855,7 @@ gen_shutdown:
 }
 
 /*
- * SCTP-AUTH Section 6.3 Receving authenticated chukns
+ * SCTP-AUTH Section 6.3 Receiving authenticated chukns
  *
  *    The receiver MUST use the HMAC algorithm indicated in the HMAC
  *    Identifier field.  If this algorithm was not specified by the
@@ -4231,7 +4231,7 @@ static sctp_disposition_t sctp_sf_abort_violation(
 	 *
 	 * This means that if we only want to abort associations
 	 * in an authenticated way (i.e AUTH+ABORT), then we
-	 * can't destroy this association just becuase the packet
+	 * can't destroy this association just because the packet
 	 * was malformed.
 	 */
 	if (sctp_auth_recv_cid(SCTP_CID_ABORT, asoc))
@@ -4402,9 +4402,9 @@ static sctp_disposition_t sctp_sf_violation_ctsn(
 }
 
 /* Handle protocol violation of an invalid chunk bundling.  For example,
- * when we have an association and we recieve bundled INIT-ACK, or
+ * when we have an association and we receive bundled INIT-ACK, or
  * SHUDOWN-COMPLETE, our peer is clearly violationg the "MUST NOT bundle"
- * statement from the specs.  Additinally, there might be an attacker
+ * statement from the specs.  Additionally, there might be an attacker
  * on the path and we may not want to continue this communication.
  */
 static sctp_disposition_t sctp_sf_violation_chunk(
diff --git a/net/sctp/socket.c b/net/sctp/socket.c
index 3951a10..deb82e3 100644
--- a/net/sctp/socket.c
+++ b/net/sctp/socket.c
@@ -1193,7 +1193,7 @@ out_free:
  * an endpoint that is multi-homed.  Much like sctp_bindx() this call
  * allows a caller to specify multiple addresses at which a peer can be
  * reached.  The way the SCTP stack uses the list of addresses to set up
- * the association is implementation dependant.  This function only
+ * the association is implementation dependent.  This function only
  * specifies that the stack will try to make use of all the addresses in
  * the list when needed.
  *
diff --git a/net/sctp/ulpevent.c b/net/sctp/ulpevent.c
index aa72e89..dff27d5 100644
--- a/net/sctp/ulpevent.c
+++ b/net/sctp/ulpevent.c
@@ -554,7 +554,7 @@ struct sctp_ulpevent *sctp_ulpevent_make_send_failed(
 	memcpy(&ssf->ssf_info, &chunk->sinfo, sizeof(struct sctp_sndrcvinfo));
 
 	/* Per TSVWG discussion with Randy. Allow the application to
-	 * ressemble a fragmented message.
+	 * resemble a fragmented message.
 	 */
 	ssf->ssf_info.sinfo_flags = chunk->chunk_hdr->flags;
 
diff --git a/net/sctp/ulpqueue.c b/net/sctp/ulpqueue.c
index 1767818..f2d1de7 100644
--- a/net/sctp/ulpqueue.c
+++ b/net/sctp/ulpqueue.c
@@ -240,7 +240,7 @@ int sctp_ulpq_tail_event(struct sctp_ulpq *ulpq, struct sctp_ulpevent *event)
 		} else {
 			/*
 			 * If fragment interleave is enabled, we
-			 * can queue this to the recieve queue instead
+			 * can queue this to the receive queue instead
 			 * of the lobby.
 			 */
 			if (sctp_sk(sk)->frag_interleave)
diff --git a/net/socket.c b/net/socket.c
index 5212447..310d16b 100644
--- a/net/socket.c
+++ b/net/socket.c
@@ -2986,7 +2986,7 @@ out:
 
 /* Since old style bridge ioctl's endup using SIOCDEVPRIVATE
  * for some operations; this forces use of the newer bridge-utils that
- * use compatiable ioctls
+ * use compatible ioctls
  */
 static int old_bridge_ioctl(compat_ulong_t __user *argp)
 {
diff --git a/net/sunrpc/auth_gss/gss_krb5_mech.c b/net/sunrpc/auth_gss/gss_krb5_mech.c
index 9022f0a..0a9a2ec 100644
--- a/net/sunrpc/auth_gss/gss_krb5_mech.c
+++ b/net/sunrpc/auth_gss/gss_krb5_mech.c
@@ -427,7 +427,7 @@ static int
 context_derive_keys_rc4(struct krb5_ctx *ctx)
 {
 	struct crypto_hash *hmac;
-	static const char sigkeyconstant[] = "signaturekey";
+	char sigkeyconstant[] = "signaturekey";
 	int slen = strlen(sigkeyconstant) + 1;	/* include null terminator */
 	struct hash_desc desc;
 	struct scatterlist sg[1];
diff --git a/net/sunrpc/auth_gss/svcauth_gss.c b/net/sunrpc/auth_gss/svcauth_gss.c
index bcdae78..8d0f7d3 100644
--- a/net/sunrpc/auth_gss/svcauth_gss.c
+++ b/net/sunrpc/auth_gss/svcauth_gss.c
@@ -1101,7 +1101,7 @@ svcauth_gss_accept(struct svc_rqst *rqstp, __be32 *authp)
 
 	/* credential is:
 	 *   version(==1), proc(0,1,2,3), seq, service (1,2,3), handle
-	 * at least 5 u32s, and is preceeded by length, so that makes 6.
+	 * at least 5 u32s, and is preceded by length, so that makes 6.
 	 */
 
 	if (argv->iov_len < 5 * 4)
diff --git a/net/sunrpc/xprtsock.c b/net/sunrpc/xprtsock.c
index 1e336a0..bf005d3 100644
--- a/net/sunrpc/xprtsock.c
+++ b/net/sunrpc/xprtsock.c
@@ -504,7 +504,7 @@ static int xs_nospace(struct rpc_task *task)
  *   EAGAIN:	The socket was blocked, please call again later to
  *		complete the request
  * ENOTCONN:	Caller needs to invoke connect logic then call again
- *    other:	Some other error occured, the request was not sent
+ *    other:	Some other error occurred, the request was not sent
  */
 static int xs_udp_send_request(struct rpc_task *task)
 {
@@ -590,7 +590,7 @@ static inline void xs_encode_tcp_record_marker(struct xdr_buf *buf)
  *   EAGAIN:	The socket was blocked, please call again later to
  *		complete the request
  * ENOTCONN:	Caller needs to invoke connect logic then call again
- *    other:	Some other error occured, the request was not sent
+ *    other:	Some other error occurred, the request was not sent
  *
  * XXX: In the case of soft timeouts, should we eventually give up
  *	if sendmsg is not able to make progress?
diff --git a/net/tipc/link.c b/net/tipc/link.c
index 43639ff..ebf338f 100644
--- a/net/tipc/link.c
+++ b/net/tipc/link.c
@@ -2471,7 +2471,7 @@ exit:
  * A pending message being re-assembled must store certain values
  * to handle subsequent fragments correctly. The following functions
  * help storing these values in unused, available fields in the
- * pending message. This makes dynamic memory allocation unecessary.
+ * pending message. This makes dynamic memory allocation unnecessary.
  */
 
 static void set_long_msg_seqno(struct sk_buff *buf, u32 seqno)
diff --git a/net/tipc/name_distr.c b/net/tipc/name_distr.c
index c9fa6df..80025a1 100644
--- a/net/tipc/name_distr.c
+++ b/net/tipc/name_distr.c
@@ -160,7 +160,7 @@ void tipc_named_withdraw(struct publication *publ)
 
 	buf = named_prepare_buf(WITHDRAWAL, ITEM_SIZE, 0);
 	if (!buf) {
-		warn("Withdrawl distribution failure\n");
+		warn("Withdrawal distribution failure\n");
 		return;
 	}
 
diff --git a/net/unix/af_unix.c b/net/unix/af_unix.c
index 1663e1a..3a43a83 100644
--- a/net/unix/af_unix.c
+++ b/net/unix/af_unix.c
@@ -207,7 +207,7 @@ static int unix_mkname(struct sockaddr_un *sunaddr, int len, unsigned *hashp)
 		/*
 		 * This may look like an off by one error but it is a bit more
 		 * subtle. 108 is the longest valid AF_UNIX path for a binding.
-		 * sun_path[108] doesnt as such exist.  However in kernel space
+		 * sun_path[108] doesn't as such exist.  However in kernel space
 		 * we are guaranteed that it is a valid memory location in our
 		 * kernel address buffer.
 		 */
diff --git a/net/wanrouter/wanproc.c b/net/wanrouter/wanproc.c
index 11f25c7..f346395 100644
--- a/net/wanrouter/wanproc.c
+++ b/net/wanrouter/wanproc.c
@@ -51,7 +51,7 @@
 
 /*
  *	Structures for interfacing with the /proc filesystem.
- *	Router creates its own directory /proc/net/router with the folowing
+ *	Router creates its own directory /proc/net/router with the following
  *	entries:
  *	config		device configuration
  *	status		global device statistics
diff --git a/net/wireless/reg.c b/net/wireless/reg.c
index 3332d5b..ab801a1 100644
--- a/net/wireless/reg.c
+++ b/net/wireless/reg.c
@@ -809,7 +809,7 @@ static void handle_channel(struct wiphy *wiphy,
 	if (r) {
 		/*
 		 * We will disable all channels that do not match our
-		 * recieved regulatory rule unless the hint is coming
+		 * received regulatory rule unless the hint is coming
 		 * from a Country IE and the Country IE had no information
 		 * about a band. The IEEE 802.11 spec allows for an AP
 		 * to send only a subset of the regulatory rules allowed,
@@ -838,7 +838,7 @@ static void handle_channel(struct wiphy *wiphy,
 	    request_wiphy && request_wiphy == wiphy &&
 	    request_wiphy->flags & WIPHY_FLAG_STRICT_REGULATORY) {
 		/*
-		 * This gaurantees the driver's requested regulatory domain
+		 * This guarantees the driver's requested regulatory domain
 		 * will always be used as a base for further regulatory
 		 * settings
 		 */
diff --git a/net/x25/x25_facilities.c b/net/x25/x25_facilities.c
index 4062075..f77e4e7 100644
--- a/net/x25/x25_facilities.c
+++ b/net/x25/x25_facilities.c
@@ -31,7 +31,7 @@
  * x25_parse_facilities - Parse facilities from skb into the facilities structs
  *
  * @skb: sk_buff to parse
- * @facilities: Regular facilites, updated as facilities are found
+ * @facilities: Regular facilities, updated as facilities are found
  * @dte_facs: ITU DTE facilities, updated as DTE facilities are found
  * @vc_fac_mask: mask is updated with all facilities found
  *
diff --git a/net/x25/x25_forward.c b/net/x25/x25_forward.c
index 25a8107..c541b62 100644
--- a/net/x25/x25_forward.c
+++ b/net/x25/x25_forward.c
@@ -31,7 +31,7 @@ int x25_forward_call(struct x25_address *dest_addr, struct x25_neigh *from,
 		goto out_no_route;
 
 	if ((neigh_new = x25_get_neigh(rt->dev)) == NULL) {
-		/* This shouldnt happen, if it occurs somehow
+		/* This shouldn't happen, if it occurs somehow
 		 * do something sensible
 		 */
 		goto out_put_route;
@@ -45,7 +45,7 @@ int x25_forward_call(struct x25_address *dest_addr, struct x25_neigh *from,
 	}
 
 	/* Remote end sending a call request on an already
-	 * established LCI? It shouldnt happen, just in case..
+	 * established LCI? It shouldn't happen, just in case..
 	 */
 	read_lock_bh(&x25_forward_list_lock);
 	list_for_each(entry, &x25_forward_list) {
diff --git a/net/xfrm/xfrm_user.c b/net/xfrm/xfrm_user.c
index 3d15d3e..5d1d60d 100644
--- a/net/xfrm/xfrm_user.c
+++ b/net/xfrm/xfrm_user.c
@@ -894,7 +894,7 @@ static int build_spdinfo(struct sk_buff *skb, struct net *net,
 	u32 *f;
 
 	nlh = nlmsg_put(skb, pid, seq, XFRM_MSG_NEWSPDINFO, sizeof(u32), 0);
-	if (nlh == NULL) /* shouldnt really happen ... */
+	if (nlh == NULL) /* shouldn't really happen ... */
 		return -EMSGSIZE;
 
 	f = nlmsg_data(nlh);
@@ -954,7 +954,7 @@ static int build_sadinfo(struct sk_buff *skb, struct net *net,
 	u32 *f;
 
 	nlh = nlmsg_put(skb, pid, seq, XFRM_MSG_NEWSADINFO, sizeof(u32), 0);
-	if (nlh == NULL) /* shouldnt really happen ... */
+	if (nlh == NULL) /* shouldn't really happen ... */
 		return -EMSGSIZE;
 
 	f = nlmsg_data(nlh);
@@ -1361,7 +1361,7 @@ static int xfrm_add_policy(struct sk_buff *skb, struct nlmsghdr *nlh,
 	if (!xp)
 		return err;
 
-	/* shouldnt excl be based on nlh flags??
+	/* shouldn't excl be based on nlh flags??
 	 * Aha! this is anti-netlink really i.e  more pfkey derived
 	 * in netlink excl is a flag and you wouldnt need
 	 * a type XFRM_MSG_UPDPOLICY - JHS */
diff --git a/samples/Kconfig b/samples/Kconfig
index e03cf0e..41063e7 100644
--- a/samples/Kconfig
+++ b/samples/Kconfig
@@ -55,7 +55,7 @@ config SAMPLE_KFIFO
 	  If in doubt, say "N" here.
 
 config SAMPLE_KDB
-	tristate "Build kdb command exmaple -- loadable modules only"
+	tristate "Build kdb command example -- loadable modules only"
 	depends on KGDB_KDB && m
 	help
 	  Build an example of how to dynamically add the hello
diff --git a/samples/hw_breakpoint/data_breakpoint.c b/samples/hw_breakpoint/data_breakpoint.c
index bd0f337..0636539 100644
--- a/samples/hw_breakpoint/data_breakpoint.c
+++ b/samples/hw_breakpoint/data_breakpoint.c
@@ -19,7 +19,7 @@
  *
  * This file is a kernel module that places a breakpoint over ksym_name kernel
  * variable using Hardware Breakpoint register. The corresponding handler which
- * prints a backtrace is invoked everytime a write operation is performed on
+ * prints a backtrace is invoked every time a write operation is performed on
  * that variable.
  *
  * Copyright (C) IBM Corporation, 2009
diff --git a/scripts/Makefile.modpost b/scripts/Makefile.modpost
index 7d22056..56dfafc 100644
--- a/scripts/Makefile.modpost
+++ b/scripts/Makefile.modpost
@@ -35,14 +35,14 @@
 # KBUILD_MODPOST_WARN can be set to avoid error out in case of undefined
 # symbols in the final module linking stage
 # KBUILD_MODPOST_NOFINAL can be set to skip the final link of modules.
-# This is solely usefull to speed up test compiles
+# This is solely useful to speed up test compiles
 PHONY := _modpost
 _modpost: __modpost
 
 include include/config/auto.conf
 include scripts/Kbuild.include
 
-# When building external modules load the Kbuild file to retreive EXTRA_SYMBOLS info
+# When building external modules load the Kbuild file to retrieve EXTRA_SYMBOLS info
 ifneq ($(KBUILD_EXTMOD),)
 
 # set src + obj - they may be used when building the .mod.c file
diff --git a/scripts/checkpatch.pl b/scripts/checkpatch.pl
index 8f9e394..d867081 100755
--- a/scripts/checkpatch.pl
+++ b/scripts/checkpatch.pl
@@ -1946,13 +1946,13 @@ sub process {
 # printk should use KERN_* levels.  Note that follow on printk's on the
 # same line do not need a level, so we use the current block context
 # to try and find and validate the current printk.  In summary the current
-# printk includes all preceeding printk's which have no newline on the end.
+# printk includes all preceding printk's which have no newline on the end.
 # we assume the first bad printk is the one to report.
 		if ($line =~ /\bprintk\((?!KERN_)\s*"/) {
 			my $ok = 0;
 			for (my $ln = $linenr - 1; $ln >= $first_line; $ln--) {
 				#print "CHECK<$lines[$ln - 1]\n";
-				# we have a preceeding printk if it ends
+				# we have a preceding printk if it ends
 				# with "\n" ignore it, else it is to blame
 				if ($lines[$ln - 1] =~ m{\bprintk\(}) {
 					if ($rawlines[$ln - 1] !~ m{\\n"}) {
@@ -2044,7 +2044,7 @@ sub process {
 			for (my $n = 0; $n < $#elements; $n += 2) {
 				$off += length($elements[$n]);
 
-				# Pick up the preceeding and succeeding characters.
+				# Pick up the preceding and succeeding characters.
 				my $ca = substr($opline, 0, $off);
 				my $cc = '';
 				if (length($opline) >= ($off + length($elements[$n + 1]))) {
diff --git a/scripts/dtc/libfdt/libfdt.h b/scripts/dtc/libfdt/libfdt.h
index ce80e4f..ff6246f 100644
--- a/scripts/dtc/libfdt/libfdt.h
+++ b/scripts/dtc/libfdt/libfdt.h
@@ -61,7 +61,7 @@
 #define FDT_ERR_NOTFOUND	1
 	/* FDT_ERR_NOTFOUND: The requested node or property does not exist */
 #define FDT_ERR_EXISTS		2
-	/* FDT_ERR_EXISTS: Attemped to create a node or property which
+	/* FDT_ERR_EXISTS: Attempted to create a node or property which
 	 * already exists */
 #define FDT_ERR_NOSPACE		3
 	/* FDT_ERR_NOSPACE: Operation needed to expand the device
diff --git a/scripts/dtc/livetree.c b/scripts/dtc/livetree.c
index c9209d5..26d0e1e 100644
--- a/scripts/dtc/livetree.c
+++ b/scripts/dtc/livetree.c
@@ -155,7 +155,7 @@ struct node *merge_nodes(struct node *old_node, struct node *new_node)
 			}
 		}
 
-		/* if no collision occured, add child to the old node. */
+		/* if no collision occurred, add child to the old node. */
 		if (new_child)
 			add_child(old_node, new_child);
 	}
diff --git a/scripts/gen_initramfs_list.sh b/scripts/gen_initramfs_list.sh
index 55caecd..e12b1a7 100644
--- a/scripts/gen_initramfs_list.sh
+++ b/scripts/gen_initramfs_list.sh
@@ -284,7 +284,7 @@ while [ $# -gt 0 ]; do
 done
 
 # If output_file is set we will generate cpio archive and compress it
-# we are carefull to delete tmp files
+# we are careful to delete tmp files
 if [ ! -z ${output_file} ]; then
 	if [ -z ${cpio_file} ]; then
 		cpio_tfile="$(mktemp ${TMPDIR:-/tmp}/cpiofile.XXXXXX)"
diff --git a/scripts/kernel-doc b/scripts/kernel-doc
index 9f85012..d793001 100755
--- a/scripts/kernel-doc
+++ b/scripts/kernel-doc
@@ -1705,7 +1705,7 @@ sub push_parameter($$$) {
 
 	$param = xml_escape($param);
 
-	# strip spaces from $param so that it is one continous string
+	# strip spaces from $param so that it is one continuous string
 	# on @parameterlist;
 	# this fixes a problem where check_sections() cannot find
 	# a parameter like "addr[6 + 2]" because it actually appears
diff --git a/scripts/package/buildtar b/scripts/package/buildtar
index 83c9c04..8a7b155 100644
--- a/scripts/package/buildtar
+++ b/scripts/package/buildtar
@@ -92,7 +92,7 @@ case "${ARCH}" in
 		echo "" >&2
 		echo '** ** **  WARNING  ** ** **' >&2
 		echo "" >&2
-		echo "Your architecture did not define any architecture-dependant files" >&2
+		echo "Your architecture did not define any architecture-dependent files" >&2
 		echo "to be placed into the tarball. Please add those to ${0} ..." >&2
 		echo "" >&2
 		sleep 5
diff --git a/scripts/rt-tester/rt-tester.py b/scripts/rt-tester/rt-tester.py
index 8c81d76..34186ca 100644
--- a/scripts/rt-tester/rt-tester.py
+++ b/scripts/rt-tester/rt-tester.py
@@ -180,7 +180,7 @@ while 1:
                 for s in stat:
 		    s = s.strip()
                     if s.startswith(testop[0]):
-                        # Seperate status value
+                        # Separate status value
                         val = s[2:].strip()
                         query = analyse(val, testop, dat)
                         break
diff --git a/security/apparmor/match.c b/security/apparmor/match.c
index 5cb4dc1..06d764c 100644
--- a/security/apparmor/match.c
+++ b/security/apparmor/match.c
@@ -195,7 +195,7 @@ void aa_dfa_free_kref(struct kref *kref)
  *
  * Unpack a dfa that has been serialized.  To find information on the dfa
  * format look in Documentation/apparmor.txt
- * Assumes the dfa @blob stream has been aligned on a 8 byte boundry
+ * Assumes the dfa @blob stream has been aligned on a 8 byte boundary
  *
  * Returns: an unpacked dfa ready for matching or ERR_PTR on failure
  */
diff --git a/security/apparmor/policy_unpack.c b/security/apparmor/policy_unpack.c
index eb3700e..e33aaf7 100644
--- a/security/apparmor/policy_unpack.c
+++ b/security/apparmor/policy_unpack.c
@@ -359,7 +359,7 @@ fail:
  * @e: serialized data extent information  (NOT NULL)
  * @profile: profile to add the accept table to (NOT NULL)
  *
- * Returns: 1 if table succesfully unpacked
+ * Returns: 1 if table successfully unpacked
  */
 static bool unpack_trans_table(struct aa_ext *e, struct aa_profile *profile)
 {
diff --git a/security/selinux/netlabel.c b/security/selinux/netlabel.c
index 1c2fc46..c3bf3ed 100644
--- a/security/selinux/netlabel.c
+++ b/security/selinux/netlabel.c
@@ -151,7 +151,7 @@ void selinux_netlbl_sk_security_free(struct sk_security_struct *sksec)
  *
  * Description:
  * Called when the NetLabel state of a sk_security_struct needs to be reset.
- * The caller is responsibile for all the NetLabel sk_security_struct locking.
+ * The caller is responsible for all the NetLabel sk_security_struct locking.
  *
  */
 void selinux_netlbl_sk_security_reset(struct sk_security_struct *sksec)
diff --git a/security/selinux/ss/services.c b/security/selinux/ss/services.c
index ea7c01f..6ef4af4 100644
--- a/security/selinux/ss/services.c
+++ b/security/selinux/ss/services.c
@@ -2806,7 +2806,7 @@ int selinux_audit_rule_init(u32 field, u32 op, char *rulestr, void **vrule)
 	case AUDIT_SUBJ_CLR:
 	case AUDIT_OBJ_LEV_LOW:
 	case AUDIT_OBJ_LEV_HIGH:
-		/* we do not allow a range, indicated by the presense of '-' */
+		/* we do not allow a range, indicated by the presence of '-' */
 		if (strchr(rulestr, '-'))
 			return -EINVAL;
 		break;
@@ -3075,7 +3075,7 @@ static void security_netlbl_cache_add(struct netlbl_lsm_secattr *secattr,
  * Description:
  * Convert the given NetLabel security attributes in @secattr into a
  * SELinux SID.  If the @secattr field does not contain a full SELinux
- * SID/context then use SECINITSID_NETMSG as the foundation.  If possibile the
+ * SID/context then use SECINITSID_NETMSG as the foundation.  If possible the
  * 'cache' field of @secattr is set and the CACHE flag is set; this is to
  * allow the @secattr to be used by NetLabel to cache the secattr to SID
  * conversion for future lookups.  Returns zero on success, negative values on
diff --git a/security/smack/smack_access.c b/security/smack/smack_access.c
index 86453db..9637e10 100644
--- a/security/smack/smack_access.c
+++ b/security/smack/smack_access.c
@@ -431,7 +431,7 @@ char *smk_import(const char *string, int len)
  * smack_from_secid - find the Smack label associated with a secid
  * @secid: an integer that might be associated with a Smack label
  *
- * Returns a pointer to the appropraite Smack label if there is one,
+ * Returns a pointer to the appropriate Smack label if there is one,
  * otherwise a pointer to the invalid Smack label.
  */
 char *smack_from_secid(const u32 secid)
diff --git a/security/smack/smack_lsm.c b/security/smack/smack_lsm.c
index 23c7a6d..c6f8fca 100644
--- a/security/smack/smack_lsm.c
+++ b/security/smack/smack_lsm.c
@@ -1794,7 +1794,7 @@ static void smack_set_catset(char *catset, struct netlbl_lsm_secattr *sap)
  * Casey says that CIPSO is good enough for now.
  * It can be used to effect.
  * It can also be abused to effect when necessary.
- * Appologies to the TSIG group in general and GW in particular.
+ * Apologies to the TSIG group in general and GW in particular.
  */
 static void smack_to_secattr(char *smack, struct netlbl_lsm_secattr *nlsp)
 {
@@ -2530,7 +2530,7 @@ static void smack_d_instantiate(struct dentry *opt_dentry, struct inode *inode)
 	switch (sbp->s_magic) {
 	case SMACK_MAGIC:
 		/*
-		 * Casey says that it's a little embarassing
+		 * Casey says that it's a little embarrassing
 		 * that the smack file system doesn't do
 		 * extended attributes.
 		 */
@@ -3084,7 +3084,7 @@ static int smack_inet_conn_request(struct sock *sk, struct sk_buff *skb,
 	/*
 	 * We need to decide if we want to label the incoming connection here
 	 * if we do we only need to label the request_sock and the stack will
-	 * propogate the wire-label to the sock when it is created.
+	 * propagate the wire-label to the sock when it is created.
 	 */
 	hdr = ip_hdr(skb);
 	addr.sin_addr.s_addr = hdr->saddr;
diff --git a/security/smack/smackfs.c b/security/smack/smackfs.c
index 90d1bba..f934601 100644
--- a/security/smack/smackfs.c
+++ b/security/smack/smackfs.c
@@ -208,7 +208,7 @@ static ssize_t smk_write_load_list(struct file *file, const char __user *buf,
 	if (*ppos != 0)
 		return -EINVAL;
 	/*
-	 * Minor hack for backward compatability
+	 * Minor hack for backward compatibility
 	 */
 	if (count < (SMK_OLOADLEN) || count > SMK_LOADLEN)
 		return -EINVAL;
@@ -223,7 +223,7 @@ static ssize_t smk_write_load_list(struct file *file, const char __user *buf,
 	}
 
 	/*
-	 * More on the minor hack for backward compatability
+	 * More on the minor hack for backward compatibility
 	 */
 	if (count == (SMK_OLOADLEN))
 		data[SMK_OLOADLEN] = '-';
@@ -927,7 +927,7 @@ static ssize_t smk_write_netlbladdr(struct file *file, const char __user *buf,
 		}
 	} else {
 		/* we delete the unlabeled entry, only if the previous label
-		 * wasnt the special CIPSO option */
+		 * wasn't the special CIPSO option */
 		if (skp->smk_label != smack_cipso_option)
 			rc = netlbl_cfg_unlbl_static_del(&init_net, NULL,
 					&skp->smk_host.sin_addr, &skp->smk_mask,
diff --git a/security/tomoyo/load_policy.c b/security/tomoyo/load_policy.c
index bbada7c..3312e56 100644
--- a/security/tomoyo/load_policy.c
+++ b/security/tomoyo/load_policy.c
@@ -23,7 +23,7 @@ static bool tomoyo_policy_loader_exists(void)
 	 * If the initrd includes /sbin/init but real-root-dev has not
 	 * mounted on / yet, activating MAC will block the system since
 	 * policies are not loaded yet.
-	 * Thus, let do_execve() call this function everytime.
+	 * Thus, let do_execve() call this function every time.
 	 */
 	struct path path;
 
diff --git a/sound/aoa/codecs/tas.c b/sound/aoa/codecs/tas.c
index fd2188c..58804c7 100644
--- a/sound/aoa/codecs/tas.c
+++ b/sound/aoa/codecs/tas.c
@@ -170,7 +170,7 @@ static void tas_set_volume(struct tas *tas)
 	/* analysing the volume and mixer tables shows
 	 * that they are similar enough when we shift
 	 * the mixer table down by 4 bits. The error
-	 * is miniscule, in just one item the error
+	 * is minuscule, in just one item the error
 	 * is 1, at a value of 0x07f17b (mixer table
 	 * value is 0x07f17a) */
 	tmp = tas_gaintable[left];
diff --git a/sound/core/pcm_memory.c b/sound/core/pcm_memory.c
index 917e405..150cb7e 100644
--- a/sound/core/pcm_memory.c
+++ b/sound/core/pcm_memory.c
@@ -253,7 +253,7 @@ static int snd_pcm_lib_preallocate_pages1(struct snd_pcm_substream *substream,
  * snd_pcm_lib_preallocate_pages - pre-allocation for the given DMA type
  * @substream: the pcm substream instance
  * @type: DMA type (SNDRV_DMA_TYPE_*)
- * @data: DMA type dependant data
+ * @data: DMA type dependent data
  * @size: the requested pre-allocation size in bytes
  * @max: the max. allowed pre-allocation size
  *
@@ -278,10 +278,10 @@ int snd_pcm_lib_preallocate_pages(struct snd_pcm_substream *substream,
 EXPORT_SYMBOL(snd_pcm_lib_preallocate_pages);
 
 /**
- * snd_pcm_lib_preallocate_pages_for_all - pre-allocation for continous memory type (all substreams)
+ * snd_pcm_lib_preallocate_pages_for_all - pre-allocation for continuous memory type (all substreams)
  * @pcm: the pcm instance
  * @type: DMA type (SNDRV_DMA_TYPE_*)
- * @data: DMA type dependant data
+ * @data: DMA type dependent data
  * @size: the requested pre-allocation size in bytes
  * @max: the max. allowed pre-allocation size
  *
diff --git a/sound/core/pcm_native.c b/sound/core/pcm_native.c
index fe5c803..1a07750 100644
--- a/sound/core/pcm_native.c
+++ b/sound/core/pcm_native.c
@@ -460,7 +460,7 @@ static int snd_pcm_hw_params(struct snd_pcm_substream *substream,
 				   PM_QOS_CPU_DMA_LATENCY, usecs);
 	return 0;
  _error:
-	/* hardware might be unuseable from this time,
+	/* hardware might be unusable from this time,
 	   so we force application to retry to set
 	   the correct hardware parameter settings */
 	runtime->status->state = SNDRV_PCM_STATE_OPEN;
diff --git a/sound/core/seq/seq_dummy.c b/sound/core/seq/seq_dummy.c
index f3bdc54..1d7d90c 100644
--- a/sound/core/seq/seq_dummy.c
+++ b/sound/core/seq/seq_dummy.c
@@ -50,7 +50,7 @@
 
 	option snd-seq-dummy ports=4
 
-  The modle option "duplex=1" enables duplex operation to the port.
+  The model option "duplex=1" enables duplex operation to the port.
   In duplex mode, a pair of ports are created instead of single port,
   and events are tunneled between pair-ports.  For example, input to
   port A is sent to output port of another port B and vice versa.
diff --git a/sound/core/vmaster.c b/sound/core/vmaster.c
index a89948a..a39d3d8 100644
--- a/sound/core/vmaster.c
+++ b/sound/core/vmaster.c
@@ -233,7 +233,7 @@ static void slave_free(struct snd_kcontrol *kcontrol)
  * Add a slave control to the group with the given master control
  *
  * All slaves must be the same type (returning the same information
- * via info callback).  The fucntion doesn't check it, so it's your
+ * via info callback).  The function doesn't check it, so it's your
  * responsibility.
  *
  * Also, some additional limitations:
diff --git a/sound/drivers/pcm-indirect2.c b/sound/drivers/pcm-indirect2.c
index 3c93c23..e73fafd 100644
--- a/sound/drivers/pcm-indirect2.c
+++ b/sound/drivers/pcm-indirect2.c
@@ -264,7 +264,7 @@ snd_pcm_indirect2_playback_transfer(struct snd_pcm_substream *substream,
 		if (diff < -(snd_pcm_sframes_t) (runtime->boundary / 2))
 			diff += runtime->boundary;
 		/* number of bytes "added" by ALSA increases the number of
-		 * bytes which are ready to "be transfered to HW"/"played"
+		 * bytes which are ready to "be transferred to HW"/"played"
 		 * Then, set rec->appl_ptr to not count bytes twice next time.
 		 */
 		rec->sw_ready += (int)frames_to_bytes(runtime, diff);
@@ -330,7 +330,7 @@ snd_pcm_indirect2_playback_transfer(struct snd_pcm_substream *substream,
 		/* copy bytes from intermediate buffer position sw_data to the
 		 * HW and return number of bytes actually written
 		 * Furthermore, set hw_ready to 0, if the fifo isn't empty
-		 * now => more could be transfered to fifo
+		 * now => more could be transferred to fifo
 		 */
 		bytes = copy(substream, rec, bytes);
 		rec->bytes2hw += bytes;
diff --git a/sound/drivers/vx/vx_pcm.c b/sound/drivers/vx/vx_pcm.c
index 35a2f71..5e897b2 100644
--- a/sound/drivers/vx/vx_pcm.c
+++ b/sound/drivers/vx/vx_pcm.c
@@ -1189,7 +1189,7 @@ void vx_pcm_update_intr(struct vx_core *chip, unsigned int events)
 
 
 /*
- * vx_init_audio_io - check the availabe audio i/o and allocate pipe arrays
+ * vx_init_audio_io - check the available audio i/o and allocate pipe arrays
  */
 static int vx_init_audio_io(struct vx_core *chip)
 {
diff --git a/sound/isa/sb/emu8000.c b/sound/isa/sb/emu8000.c
index 0c40951..5d61f5a 100644
--- a/sound/isa/sb/emu8000.c
+++ b/sound/isa/sb/emu8000.c
@@ -370,7 +370,7 @@ init_arrays(struct snd_emu8000 *emu)
 
 /*
  * Size the onboard memory.
- * This is written so as not to need arbitary delays after the write. It
+ * This is written so as not to need arbitrary delays after the write. It
  * seems that the only way to do this is to use the one channel and keep
  * reallocating between read and write.
  */
diff --git a/sound/isa/wavefront/wavefront_midi.c b/sound/isa/wavefront/wavefront_midi.c
index f14a7c0..65329f3 100644
--- a/sound/isa/wavefront/wavefront_midi.c
+++ b/sound/isa/wavefront/wavefront_midi.c
@@ -537,7 +537,7 @@ snd_wavefront_midi_start (snd_wavefront_card_t *card)
 	}
 
 	/* Turn on Virtual MIDI, but first *always* turn it off,
-	   since otherwise consectutive reloads of the driver will
+	   since otherwise consecutive reloads of the driver will
 	   never cause the hardware to generate the initial "internal" or 
 	   "external" source bytes in the MIDI data stream. This
 	   is pretty important, since the internal hardware generally will
diff --git a/sound/isa/wss/wss_lib.c b/sound/isa/wss/wss_lib.c
index 9191b32..2a42cc3 100644
--- a/sound/isa/wss/wss_lib.c
+++ b/sound/isa/wss/wss_lib.c
@@ -424,7 +424,7 @@ void snd_wss_mce_down(struct snd_wss *chip)
 
 	/*
 	 * Wait for (possible -- during init auto-calibration may not be set)
-	 * calibration process to start. Needs upto 5 sample periods on AD1848
+	 * calibration process to start. Needs up to 5 sample periods on AD1848
 	 * which at the slowest possible rate of 5.5125 kHz means 907 us.
 	 */
 	msleep(1);
diff --git a/sound/oss/ac97_codec.c b/sound/oss/ac97_codec.c
index 854c303..0cd23d9 100644
--- a/sound/oss/ac97_codec.c
+++ b/sound/oss/ac97_codec.c
@@ -28,7 +28,7 @@
  *
  * History
  * May 02, 2003 Liam Girdwood <lrg@slimlogic.co.uk>
- *	Removed non existant WM9700
+ *	Removed non existent WM9700
  *	Added support for WM9705, WM9708, WM9709, WM9710, WM9711
  *	WM9712 and WM9717
  * Mar 28, 2002 Randolph Bentson <bentson@holmsjoen.com>
@@ -441,7 +441,7 @@ static void ac97_set_mixer(struct ac97_codec *codec, unsigned int oss_mixer, uns
 }
 
 /* read or write the recmask, the ac97 can really have left and right recording
-   inputs independantly set, but OSS doesn't seem to want us to express that to
+   inputs independently set, but OSS doesn't seem to want us to express that to
    the user. the caller guarantees that we have a supported bit set, and they
    must be holding the card's spinlock */
 static int ac97_recmask_io(struct ac97_codec *codec, int rw, int mask) 
@@ -754,7 +754,7 @@ int ac97_probe_codec(struct ac97_codec *codec)
 	if((codec->codec_ops == &null_ops) && (f & 4))
 		codec->codec_ops = &default_digital_ops;
 	
-	/* A device which thinks its a modem but isnt */
+	/* A device which thinks its a modem but isn't */
 	if(codec->flags & AC97_DELUDED_MODEM)
 		codec->modem = 0;
 		
diff --git a/sound/oss/audio.c b/sound/oss/audio.c
index 7df48a2..4b958b1 100644
--- a/sound/oss/audio.c
+++ b/sound/oss/audio.c
@@ -514,7 +514,7 @@ int audio_ioctl(int dev, struct file *file, unsigned int cmd, void __user *arg)
 				count += dmap->bytes_in_use;	/* Pointer wrap not handled yet */
 			count += dmap->byte_counter;
 		
-			/* Substract current count from the number of bytes written by app */
+			/* Subtract current count from the number of bytes written by app */
 			count = dmap->user_counter - count;
 			if (count < 0)
 				count = 0;
@@ -931,7 +931,7 @@ static int dma_ioctl(int dev, unsigned int cmd, void __user *arg)
 			if (count < dmap_out->fragment_size && dmap_out->qhead != 0)
 				count += dmap_out->bytes_in_use;	/* Pointer wrap not handled yet */
 			count += dmap_out->byte_counter;
-			/* Substract current count from the number of bytes written by app */
+			/* Subtract current count from the number of bytes written by app */
 			count = dmap_out->user_counter - count;
 			if (count < 0)
 				count = 0;
diff --git a/sound/oss/dmasound/dmasound_core.c b/sound/oss/dmasound/dmasound_core.c
index 87e2c72..c918313 100644
--- a/sound/oss/dmasound/dmasound_core.c
+++ b/sound/oss/dmasound/dmasound_core.c
@@ -1021,7 +1021,7 @@ static int sq_ioctl(struct file *file, u_int cmd, u_long arg)
 	case SNDCTL_DSP_SYNC:
 		/* This call, effectively, has the same behaviour as SNDCTL_DSP_RESET
 		   except that it waits for output to finish before resetting
-		   everything - read, however, is killed imediately.
+		   everything - read, however, is killed immediately.
 		*/
 		result = 0 ;
 		if (file->f_mode & FMODE_WRITE) {
diff --git a/sound/oss/midibuf.c b/sound/oss/midibuf.c
index ceedb1e..8cdb2cf 100644
--- a/sound/oss/midibuf.c
+++ b/sound/oss/midibuf.c
@@ -295,7 +295,7 @@ int MIDIbuf_write(int dev, struct file *file, const char __user *buf, int count)
 
 		for (i = 0; i < n; i++)
 		{
-			/* BROKE BROKE BROKE - CANT DO THIS WITH CLI !! */
+			/* BROKE BROKE BROKE - CAN'T DO THIS WITH CLI !! */
 			/* yes, think the same, so I removed the cli() brackets 
 				QUEUE_BYTE is protected against interrupts */
 			if (copy_from_user((char *) &tmp_data, &(buf)[c], 1)) {
diff --git a/sound/oss/sb_card.c b/sound/oss/sb_card.c
index 84ef4d0..fb5d725 100644
--- a/sound/oss/sb_card.c
+++ b/sound/oss/sb_card.c
@@ -1,7 +1,7 @@
 /*
  * sound/oss/sb_card.c
  *
- * Detection routine for the ISA Sound Blaster and compatable sound
+ * Detection routine for the ISA Sound Blaster and compatible sound
  * cards.
  *
  * This file is distributed under the GNU GENERAL PUBLIC LICENSE (GPL)
diff --git a/sound/oss/sb_ess.c b/sound/oss/sb_ess.c
index 9890cf2..5c773df 100644
--- a/sound/oss/sb_ess.c
+++ b/sound/oss/sb_ess.c
@@ -168,7 +168,7 @@
  * corresponding playback levels, unless recmask says they aren't recorded. In
  * the latter case the recording volumes are 0.
  * Now recording levels of inputs can be controlled, by changing the playback
- * levels. Futhermore several devices can be recorded together (which is not
+ * levels. Furthermore several devices can be recorded together (which is not
  * possible with the ES1688).
  * Besides the separate recording level control for each input, the common
  * recording level can also be controlled by RECLEV as described above.
diff --git a/sound/oss/swarm_cs4297a.c b/sound/oss/swarm_cs4297a.c
index 44357d8..09d4648 100644
--- a/sound/oss/swarm_cs4297a.c
+++ b/sound/oss/swarm_cs4297a.c
@@ -875,7 +875,7 @@ static void start_adc(struct cs4297a_state *s)
 		if (s->prop_adc.fmt & AFMT_S8 || s->prop_adc.fmt & AFMT_U8) {
 			// 
 			// now only use 16 bit capture, due to truncation issue
-			// in the chip, noticable distortion occurs.
+			// in the chip, noticeable distortion occurs.
 			// allocate buffer and then convert from 16 bit to 
 			// 8 bit for the user buffer.
 			//
diff --git a/sound/oss/vidc.c b/sound/oss/vidc.c
index f0e0caa..12ba28e 100644
--- a/sound/oss/vidc.c
+++ b/sound/oss/vidc.c
@@ -227,7 +227,7 @@ static int vidc_audio_set_speed(int dev, int rate)
 		} else {
 			/*printk("VIDC: internal %d %d %d\n", rate, rate_int, hwrate);*/
 			hwctrl=0x00000003;
-			/* Allow rougly 0.4% tolerance */
+			/* Allow roughly 0.4% tolerance */
 			if (diff_int > (rate/256))
 				rate=rate_int;
 		}
diff --git a/sound/pci/ad1889.c b/sound/pci/ad1889.c
index 4382d0f..d8f6fd6 100644
--- a/sound/pci/ad1889.c
+++ b/sound/pci/ad1889.c
@@ -29,7 +29,7 @@
  *	PM support
  *	MIDI support
  *	Game Port support
- *	SG DMA support (this will need *alot* of work)
+ *	SG DMA support (this will need *a lot* of work)
  */
 
 #include <linux/init.h>
diff --git a/sound/pci/asihpi/asihpi.c b/sound/pci/asihpi/asihpi.c
index f53a31e..f8ccc96 100644
--- a/sound/pci/asihpi/asihpi.c
+++ b/sound/pci/asihpi/asihpi.c
@@ -963,7 +963,7 @@ static int snd_card_asihpi_playback_open(struct snd_pcm_substream *substream)
 
 	/*? also check ASI5000 samplerate source
 	    If external, only support external rate.
-	    If internal and other stream playing, cant switch
+	    If internal and other stream playing, can't switch
 	*/
 
 	init_timer(&dpcm->timer);
diff --git a/sound/pci/asihpi/hpi.h b/sound/pci/asihpi/hpi.h
index 6fc025c..255429c 100644
--- a/sound/pci/asihpi/hpi.h
+++ b/sound/pci/asihpi/hpi.h
@@ -725,7 +725,7 @@ enum HPI_AESEBU_ERRORS {
 #define HPI_PAD_TITLE_LEN               64
 /** The text string containing the comment. */
 #define HPI_PAD_COMMENT_LEN             256
-/** The PTY when the tuner has not recieved any PTY. */
+/** The PTY when the tuner has not received any PTY. */
 #define HPI_PAD_PROGRAM_TYPE_INVALID    0xffff
 /** \} */
 
diff --git a/sound/pci/asihpi/hpi6000.c b/sound/pci/asihpi/hpi6000.c
index 3e3c2ef..8c8aac4 100644
--- a/sound/pci/asihpi/hpi6000.c
+++ b/sound/pci/asihpi/hpi6000.c
@@ -423,7 +423,7 @@ static void subsys_create_adapter(struct hpi_message *phm,
 
 	ao.priv = kzalloc(sizeof(struct hpi_hw_obj), GFP_KERNEL);
 	if (!ao.priv) {
-		HPI_DEBUG_LOG(ERROR, "cant get mem for adapter object\n");
+		HPI_DEBUG_LOG(ERROR, "can't get mem for adapter object\n");
 		phr->error = HPI_ERROR_MEMORY_ALLOC;
 		return;
 	}
diff --git a/sound/pci/asihpi/hpi6205.c b/sound/pci/asihpi/hpi6205.c
index 620525b..22e9f08 100644
--- a/sound/pci/asihpi/hpi6205.c
+++ b/sound/pci/asihpi/hpi6205.c
@@ -466,7 +466,7 @@ static void subsys_create_adapter(struct hpi_message *phm,
 
 	ao.priv = kzalloc(sizeof(struct hpi_hw_obj), GFP_KERNEL);
 	if (!ao.priv) {
-		HPI_DEBUG_LOG(ERROR, "cant get mem for adapter object\n");
+		HPI_DEBUG_LOG(ERROR, "can't get mem for adapter object\n");
 		phr->error = HPI_ERROR_MEMORY_ALLOC;
 		return;
 	}
diff --git a/sound/pci/asihpi/hpi_internal.h b/sound/pci/asihpi/hpi_internal.h
index af678be..3b9fd11 100644
--- a/sound/pci/asihpi/hpi_internal.h
+++ b/sound/pci/asihpi/hpi_internal.h
@@ -607,7 +607,7 @@ struct hpi_data_compat32 {
 #endif
 
 struct hpi_buffer {
-  /** placehoder for backward compatability (see dwBufferSize) */
+  /** placehoder for backward compatibility (see dwBufferSize) */
 	struct hpi_msg_format reserved;
 	u32 command; /**< HPI_BUFFER_CMD_xxx*/
 	u32 pci_address; /**< PCI physical address of buffer for DSP DMA */
diff --git a/sound/pci/asihpi/hpimsgx.c b/sound/pci/asihpi/hpimsgx.c
index bcbdf30..360028b 100644
--- a/sound/pci/asihpi/hpimsgx.c
+++ b/sound/pci/asihpi/hpimsgx.c
@@ -722,7 +722,7 @@ static u16 HPIMSGX__init(struct hpi_message *phm,
 		return phr->error;
 	}
 	if (hr.error == 0) {
-		/* the adapter was created succesfully
+		/* the adapter was created successfully
 		   save the mapping for future use */
 		hpi_entry_points[hr.u.s.adapter_index] = entry_point_func;
 		/* prepare adapter (pre-open streams etc.) */
diff --git a/sound/pci/au88x0/au88x0.h b/sound/pci/au88x0/au88x0.h
index ecb8f4d..02f6e08 100644
--- a/sound/pci/au88x0/au88x0.h
+++ b/sound/pci/au88x0/au88x0.h
@@ -104,7 +104,7 @@
 #define MIX_PLAYB(x) (vortex->mixplayb[x])
 #define MIX_SPDIF(x) (vortex->mixspdif[x])
 
-#define NR_WTPB 0x20		/* WT channels per eahc bank. */
+#define NR_WTPB 0x20		/* WT channels per each bank. */
 
 /* Structs */
 typedef struct {
diff --git a/sound/pci/au88x0/au88x0_a3d.c b/sound/pci/au88x0/au88x0_a3d.c
index f4aa8ff..9ae8b3b 100644
--- a/sound/pci/au88x0/au88x0_a3d.c
+++ b/sound/pci/au88x0/au88x0_a3d.c
@@ -53,7 +53,7 @@ a3dsrc_GetTimeConsts(a3dsrc_t * a, short *HrtfTrack, short *ItdTrack,
 }
 
 #endif
-/* Atmospheric absorbtion. */
+/* Atmospheric absorption. */
 
 static void
 a3dsrc_SetAtmosTarget(a3dsrc_t * a, short aa, short b, short c, short d,
@@ -835,7 +835,7 @@ snd_vortex_a3d_filter_put(struct snd_kcontrol *kcontrol,
 		params[i] = ucontrol->value.integer.value[i];
 	/* Translate generic filter params to a3d filter params. */
 	vortex_a3d_translate_filter(a->filter, params);
-	/* Atmospheric absorbtion and filtering. */
+	/* Atmospheric absorption and filtering. */
 	a3dsrc_SetAtmosTarget(a, a->filter[0],
 			      a->filter[1], a->filter[2],
 			      a->filter[3], a->filter[4]);
diff --git a/sound/pci/au88x0/au88x0_pcm.c b/sound/pci/au88x0/au88x0_pcm.c
index 5439d66..33f0ba5 100644
--- a/sound/pci/au88x0/au88x0_pcm.c
+++ b/sound/pci/au88x0/au88x0_pcm.c
@@ -515,7 +515,7 @@ static int __devinit snd_vortex_new_pcm(vortex_t *chip, int idx, int nr)
 		return -ENODEV;
 
 	/* idx indicates which kind of PCM device. ADB, SPDIF, I2S and A3D share the 
-	 * same dma engine. WT uses it own separate dma engine whcih cant capture. */
+	 * same dma engine. WT uses it own separate dma engine which can't capture. */
 	if (idx == VORTEX_PCM_ADB)
 		nr_capt = nr;
 	else
diff --git a/sound/pci/azt3328.c b/sound/pci/azt3328.c
index 5715c4d0..9b7a634 100644
--- a/sound/pci/azt3328.c
+++ b/sound/pci/azt3328.c
@@ -140,7 +140,7 @@
  *  Possible remedies:
  *  - use speaker (amplifier) output instead of headphone output
  *    (in case crackling is due to overloaded output clipping)
- *  - plug card into a different PCI slot, preferrably one that isn't shared
+ *  - plug card into a different PCI slot, preferably one that isn't shared
  *    too much (this helps a lot, but not completely!)
  *  - get rid of PCI VGA card, use AGP instead
  *  - upgrade or downgrade BIOS
diff --git a/sound/pci/ca0106/ca0106.h b/sound/pci/ca0106/ca0106.h
index fc53b9b..e8e8ccc 100644
--- a/sound/pci/ca0106/ca0106.h
+++ b/sound/pci/ca0106/ca0106.h
@@ -51,7 +51,7 @@
  *    Add support for mute control on SB Live 24bit (cards w/ SPI DAC)
  *
  *
- *  This code was initally based on code from ALSA's emu10k1x.c which is:
+ *  This code was initially based on code from ALSA's emu10k1x.c which is:
  *  Copyright (c) by Francisco Moraes <fmoraes@nc.rr.com>
  *
  *   This program is free software; you can redistribute it and/or modify
@@ -175,7 +175,7 @@
 /* CA0106 pointer-offset register set, accessed through the PTR and DATA registers                     */
 /********************************************************************************************************/
                                                                                                                            
-/* Initally all registers from 0x00 to 0x3f have zero contents. */
+/* Initially all registers from 0x00 to 0x3f have zero contents. */
 #define PLAYBACK_LIST_ADDR	0x00		/* Base DMA address of a list of pointers to each period/size */
 						/* One list entry: 4 bytes for DMA address, 
 						 * 4 bytes for period_size << 16.
@@ -223,7 +223,7 @@
  * The jack has 4 poles. I will call 1 - Tip, 2 - Next to 1, 3 - Next to 2, 4 - Next to 3
  * For Analogue: 1 -> Center Speaker, 2 -> Sub Woofer, 3 -> Ground, 4 -> Ground
  * For Digital: 1 -> Front SPDIF, 2 -> Rear SPDIF, 3 -> Center/Subwoofer SPDIF, 4 -> Ground.
- * Standard 4 pole Video A/V cable with RCA outputs: 1 -> White, 2 -> Yellow, 3 -> Sheild on all three, 4 -> Red.
+ * Standard 4 pole Video A/V cable with RCA outputs: 1 -> White, 2 -> Yellow, 3 -> Shield on all three, 4 -> Red.
  * So, from this you can see that you cannot use a Standard 4 pole Video A/V cable with the SB Audigy LS card.
  */
 /* The Front SPDIF PCM gets mixed with samples from the AC97 codec, so can only work for Stereo PCM and not AC3/DTS
diff --git a/sound/pci/ca0106/ca0106_main.c b/sound/pci/ca0106/ca0106_main.c
index 01b4938..4377592 100644
--- a/sound/pci/ca0106/ca0106_main.c
+++ b/sound/pci/ca0106/ca0106_main.c
@@ -117,7 +117,7 @@
  *    DAC: Unknown
  *    Trying to handle it like the SB0410.
  *
- *  This code was initally based on code from ALSA's emu10k1x.c which is:
+ *  This code was initially based on code from ALSA's emu10k1x.c which is:
  *  Copyright (c) by Francisco Moraes <fmoraes@nc.rr.com>
  *
  *   This program is free software; you can redistribute it and/or modify
diff --git a/sound/pci/ca0106/ca0106_mixer.c b/sound/pci/ca0106/ca0106_mixer.c
index 630aa49..84f3f92 100644
--- a/sound/pci/ca0106/ca0106_mixer.c
+++ b/sound/pci/ca0106/ca0106_mixer.c
@@ -42,7 +42,7 @@
  *  0.0.18
  *    Add support for mute control on SB Live 24bit (cards w/ SPI DAC)
  *
- *  This code was initally based on code from ALSA's emu10k1x.c which is:
+ *  This code was initially based on code from ALSA's emu10k1x.c which is:
  *  Copyright (c) by Francisco Moraes <fmoraes@nc.rr.com>
  *
  *   This program is free software; you can redistribute it and/or modify
diff --git a/sound/pci/ca0106/ca0106_proc.c b/sound/pci/ca0106/ca0106_proc.c
index ba96428..c694464 100644
--- a/sound/pci/ca0106/ca0106_proc.c
+++ b/sound/pci/ca0106/ca0106_proc.c
@@ -42,7 +42,7 @@
  *  0.0.18
  *    Implement support for Line-in capture on SB Live 24bit.
  *
- *  This code was initally based on code from ALSA's emu10k1x.c which is:
+ *  This code was initially based on code from ALSA's emu10k1x.c which is:
  *  Copyright (c) by Francisco Moraes <fmoraes@nc.rr.com>
  *
  *   This program is free software; you can redistribute it and/or modify
diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index b5bb036..f4e5735 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -73,7 +73,7 @@ MODULE_PARM_DESC(mpu_port, "MPU-401 port.");
 module_param_array(fm_port, long, NULL, 0444);
 MODULE_PARM_DESC(fm_port, "FM port.");
 module_param_array(soft_ac3, bool, NULL, 0444);
-MODULE_PARM_DESC(soft_ac3, "Sofware-conversion of raw SPDIF packets (model 033 only).");
+MODULE_PARM_DESC(soft_ac3, "Software-conversion of raw SPDIF packets (model 033 only).");
 #ifdef SUPPORT_JOYSTICK
 module_param_array(joystick_port, int, NULL, 0444);
 MODULE_PARM_DESC(joystick_port, "Joystick port address.");
@@ -656,8 +656,8 @@ out:
 }
 
 /*
- * Program pll register bits, I assume that the 8 registers 0xf8 upto 0xff
- * are mapped onto the 8 ADC/DAC sampling frequency which can be choosen
+ * Program pll register bits, I assume that the 8 registers 0xf8 up to 0xff
+ * are mapped onto the 8 ADC/DAC sampling frequency which can be chosen
  * at the register CM_REG_FUNCTRL1 (0x04).
  * Problem: other ways are also possible (any information about that?)
  */
@@ -666,7 +666,7 @@ static void snd_cmipci_set_pll(struct cmipci *cm, unsigned int rate, unsigned in
 	unsigned int reg = CM_REG_PLL + slot;
 	/*
 	 * Guess that this programs at reg. 0x04 the pos 15:13/12:10
-	 * for DSFC/ASFC (000 upto 111).
+	 * for DSFC/ASFC (000 up to 111).
 	 */
 
 	/* FIXME: Init (Do we've to set an other register first before programming?) */
diff --git a/sound/pci/ctxfi/ctatc.c b/sound/pci/ctxfi/ctatc.c
index b932154..13f33c0 100644
--- a/sound/pci/ctxfi/ctatc.c
+++ b/sound/pci/ctxfi/ctatc.c
@@ -1627,7 +1627,7 @@ static struct ct_atc atc_preset __devinitdata = {
  *  Creates and initializes a hardware manager.
  *
  *  Creates kmallocated ct_atc structure. Initializes hardware.
- *  Returns 0 if suceeds, or negative error code if fails.
+ *  Returns 0 if succeeds, or negative error code if fails.
  */
 
 int __devinit ct_atc_create(struct snd_card *card, struct pci_dev *pci,
diff --git a/sound/pci/ctxfi/cthw20k1.c b/sound/pci/ctxfi/cthw20k1.c
index 0cf400f..a5c957d 100644
--- a/sound/pci/ctxfi/cthw20k1.c
+++ b/sound/pci/ctxfi/cthw20k1.c
@@ -1285,7 +1285,7 @@ static int hw_trn_init(struct hw *hw, const struct trn_conf *info)
 	hw_write_20kx(hw, PTPALX, ptp_phys_low);
 	hw_write_20kx(hw, PTPAHX, ptp_phys_high);
 	hw_write_20kx(hw, TRNCTL, trnctl);
-	hw_write_20kx(hw, TRNIS, 0x200c01); /* realy needed? */
+	hw_write_20kx(hw, TRNIS, 0x200c01); /* really needed? */
 
 	return 0;
 }
diff --git a/sound/pci/emu10k1/memory.c b/sound/pci/emu10k1/memory.c
index 957a311..c250614 100644
--- a/sound/pci/emu10k1/memory.c
+++ b/sound/pci/emu10k1/memory.c
@@ -248,7 +248,7 @@ static int is_valid_page(struct snd_emu10k1 *emu, dma_addr_t addr)
 /*
  * map the given memory block on PTB.
  * if the block is already mapped, update the link order.
- * if no empty pages are found, tries to release unsed memory blocks
+ * if no empty pages are found, tries to release unused memory blocks
  * and retry the mapping.
  */
 int snd_emu10k1_memblk_map(struct snd_emu10k1 *emu, struct snd_emu10k1_memblk *blk)
diff --git a/sound/pci/emu10k1/p16v.c b/sound/pci/emu10k1/p16v.c
index 61b8ab3..a81dc44 100644
--- a/sound/pci/emu10k1/p16v.c
+++ b/sound/pci/emu10k1/p16v.c
@@ -69,7 +69,7 @@
  *    ADC: Philips 1361T (Stereo 24bit)
  *    DAC: CS4382-K (8-channel, 24bit, 192Khz)
  *
- *  This code was initally based on code from ALSA's emu10k1x.c which is:
+ *  This code was initially based on code from ALSA's emu10k1x.c which is:
  *  Copyright (c) by Francisco Moraes <fmoraes@nc.rr.com>
  *
  *   This program is free software; you can redistribute it and/or modify
diff --git a/sound/pci/emu10k1/p16v.h b/sound/pci/emu10k1/p16v.h
index 00f4817..4e0ee1a 100644
--- a/sound/pci/emu10k1/p16v.h
+++ b/sound/pci/emu10k1/p16v.h
@@ -59,7 +59,7 @@
  *    ADC: Philips 1361T (Stereo 24bit)
  *    DAC: CS4382-K (8-channel, 24bit, 192Khz)
  *
- *  This code was initally based on code from ALSA's emu10k1x.c which is:
+ *  This code was initially based on code from ALSA's emu10k1x.c which is:
  *  Copyright (c) by Francisco Moraes <fmoraes@nc.rr.com>
  *
  *   This program is free software; you can redistribute it and/or modify
@@ -86,7 +86,7 @@
  * The sample rate is also controlled by the same registers that control the rate of the EMU10K2 sample rate converters.
  */
 
-/* Initally all registers from 0x00 to 0x3f have zero contents. */
+/* Initially all registers from 0x00 to 0x3f have zero contents. */
 #define PLAYBACK_LIST_ADDR	0x00		/* Base DMA address of a list of pointers to each period/size */
 						/* One list entry: 4 bytes for DMA address, 
 						 * 4 bytes for period_size << 16.
diff --git a/sound/pci/hda/hda_codec.c b/sound/pci/hda/hda_codec.c
index 2c79e96..430f41d 100644
--- a/sound/pci/hda/hda_codec.c
+++ b/sound/pci/hda/hda_codec.c
@@ -3661,7 +3661,7 @@ int snd_hda_codec_build_pcms(struct hda_codec *codec)
  * with the proper parameters for set up.
  * ops.cleanup should be called in hw_free for clean up of streams.
  *
- * This function returns 0 if successfull, or a negative error code.
+ * This function returns 0 if successful, or a negative error code.
  */
 int __devinit snd_hda_build_pcms(struct hda_bus *bus)
 {
@@ -4851,7 +4851,7 @@ EXPORT_SYMBOL_HDA(snd_hda_suspend);
  *
  * Returns 0 if successful.
  *
- * This fucntion is defined only when POWER_SAVE isn't set.
+ * This function is defined only when POWER_SAVE isn't set.
  * In the power-save mode, the codec is resumed dynamically.
  */
 int snd_hda_resume(struct hda_bus *bus)
diff --git a/sound/pci/hda/patch_realtek.c b/sound/pci/hda/patch_realtek.c
index 12c6f45..7e28a64 100644
--- a/sound/pci/hda/patch_realtek.c
+++ b/sound/pci/hda/patch_realtek.c
@@ -549,7 +549,7 @@ static int alc_ch_mode_put(struct snd_kcontrol *kcontrol,
 
 /*
  * Control the mode of pin widget settings via the mixer.  "pc" is used
- * instead of "%" to avoid consequences of accidently treating the % as
+ * instead of "%" to avoid consequences of accidentally treating the % as
  * being part of a format specifier.  Maximum allowed length of a value is
  * 63 characters plus NULL terminator.
  *
@@ -9836,7 +9836,7 @@ static struct snd_pci_quirk alc882_cfg_tbl[] = {
 
 	SND_PCI_QUIRK(0x1028, 0x020d, "Dell Inspiron 530", ALC888_6ST_DELL),
 
-	SND_PCI_QUIRK(0x103c, 0x2a3d, "HP Pavillion", ALC883_6ST_DIG),
+	SND_PCI_QUIRK(0x103c, 0x2a3d, "HP Pavilion", ALC883_6ST_DIG),
 	SND_PCI_QUIRK(0x103c, 0x2a4f, "HP Samba", ALC888_3ST_HP),
 	SND_PCI_QUIRK(0x103c, 0x2a60, "HP Lucknow", ALC888_3ST_HP),
 	SND_PCI_QUIRK(0x103c, 0x2a61, "HP Nettle", ALC883_6ST_DIG),
diff --git a/sound/pci/hda/patch_sigmatel.c b/sound/pci/hda/patch_sigmatel.c
index 05fcd60..1395991 100644
--- a/sound/pci/hda/patch_sigmatel.c
+++ b/sound/pci/hda/patch_sigmatel.c
@@ -2475,7 +2475,7 @@ static int stac92xx_hp_switch_put(struct snd_kcontrol *kcontrol,
  
 	spec->hp_switch = ucontrol->value.integer.value[0] ? nid : 0;
 
-	/* check to be sure that the ports are upto date with
+	/* check to be sure that the ports are up to date with
 	 * switch changes
 	 */
 	stac_issue_unsol_event(codec, nid);
diff --git a/sound/pci/ice1712/aureon.c b/sound/pci/ice1712/aureon.c
index 2f62522..3e4f8c1 100644
--- a/sound/pci/ice1712/aureon.c
+++ b/sound/pci/ice1712/aureon.c
@@ -148,7 +148,7 @@ static void aureon_pca9554_write(struct snd_ice1712 *ice, unsigned char reg,
 	udelay(100);
 	/*
 	 * send device address, command and value,
-	 * skipping ack cycles inbetween
+	 * skipping ack cycles in between
 	 */
 	for (j = 0; j < 3; j++) {
 		switch (j) {
@@ -2143,7 +2143,7 @@ static int __devinit aureon_init(struct snd_ice1712 *ice)
 		ice->num_total_adcs = 2;
 	}
 
-	/* to remeber the register values of CS8415 */
+	/* to remember the register values of CS8415 */
 	ice->akm = kzalloc(sizeof(struct snd_akm4xxx), GFP_KERNEL);
 	if (!ice->akm)
 		return -ENOMEM;
diff --git a/sound/pci/ice1712/ice1712.c b/sound/pci/ice1712/ice1712.c
index 4fc6d8b..f4594d7 100644
--- a/sound/pci/ice1712/ice1712.c
+++ b/sound/pci/ice1712/ice1712.c
@@ -2755,7 +2755,7 @@ static int __devinit snd_ice1712_probe(struct pci_dev *pci,
 			return err;
 		}
 		if (c->mpu401_1_name)
-			/*  Prefered name available in card_info */
+			/*  Preferred name available in card_info */
 			snprintf(ice->rmidi[0]->name,
 				 sizeof(ice->rmidi[0]->name),
 				 "%s %d", c->mpu401_1_name, card->number);
@@ -2772,7 +2772,7 @@ static int __devinit snd_ice1712_probe(struct pci_dev *pci,
 				return err;
 			}
 			if (c->mpu401_2_name)
-				/*  Prefered name available in card_info */
+				/*  Preferred name available in card_info */
 				snprintf(ice->rmidi[1]->name,
 					 sizeof(ice->rmidi[1]->name),
 					 "%s %d", c->mpu401_2_name,
diff --git a/sound/pci/ice1712/pontis.c b/sound/pci/ice1712/pontis.c
index cdb873f..92c1160 100644
--- a/sound/pci/ice1712/pontis.c
+++ b/sound/pci/ice1712/pontis.c
@@ -768,7 +768,7 @@ static int __devinit pontis_init(struct snd_ice1712 *ice)
 	ice->num_total_dacs = 2;
 	ice->num_total_adcs = 2;
 
-	/* to remeber the register values */
+	/* to remember the register values */
 	ice->akm = kzalloc(sizeof(struct snd_akm4xxx), GFP_KERNEL);
 	if (! ice->akm)
 		return -ENOMEM;
diff --git a/sound/pci/ice1712/prodigy_hifi.c b/sound/pci/ice1712/prodigy_hifi.c
index 6a9fee3..764cc93 100644
--- a/sound/pci/ice1712/prodigy_hifi.c
+++ b/sound/pci/ice1712/prodigy_hifi.c
@@ -1046,7 +1046,7 @@ static int __devinit prodigy_hifi_init(struct snd_ice1712 *ice)
 	* don't call snd_ice1712_gpio_get/put(), otherwise it's overwritten
 	*/
 	ice->gpio.saved[0] = 0;
-	/* to remeber the register values */
+	/* to remember the register values */
 
 	ice->akm = kzalloc(sizeof(struct snd_akm4xxx), GFP_KERNEL);
 	if (! ice->akm)
@@ -1128,7 +1128,7 @@ static int __devinit prodigy_hd2_init(struct snd_ice1712 *ice)
 	* don't call snd_ice1712_gpio_get/put(), otherwise it's overwritten
 	*/
 	ice->gpio.saved[0] = 0;
-	/* to remeber the register values */
+	/* to remember the register values */
 
 	ice->akm = kzalloc(sizeof(struct snd_akm4xxx), GFP_KERNEL);
 	if (! ice->akm)
diff --git a/sound/pci/intel8x0.c b/sound/pci/intel8x0.c
index 629a549..6c896db 100644
--- a/sound/pci/intel8x0.c
+++ b/sound/pci/intel8x0.c
@@ -534,7 +534,7 @@ static int snd_intel8x0_codec_semaphore(struct intel8x0 *chip, unsigned int code
 		udelay(10);
 	} while (time--);
 
-	/* access to some forbidden (non existant) ac97 registers will not
+	/* access to some forbidden (non existent) ac97 registers will not
 	 * reset the semaphore. So even if you don't get the semaphore, still
 	 * continue the access. We don't need the semaphore anyway. */
 	snd_printk(KERN_ERR "codec_semaphore: semaphore is not ready [0x%x][0x%x]\n",
diff --git a/sound/pci/intel8x0m.c b/sound/pci/intel8x0m.c
index 2ae8d29..27709f0 100644
--- a/sound/pci/intel8x0m.c
+++ b/sound/pci/intel8x0m.c
@@ -331,7 +331,7 @@ static int snd_intel8x0m_codec_semaphore(struct intel8x0m *chip, unsigned int co
 		udelay(10);
 	} while (time--);
 
-	/* access to some forbidden (non existant) ac97 registers will not
+	/* access to some forbidden (non existent) ac97 registers will not
 	 * reset the semaphore. So even if you don't get the semaphore, still
 	 * continue the access. We don't need the semaphore anyway. */
 	snd_printk(KERN_ERR "codec_semaphore: semaphore is not ready [0x%x][0x%x]\n",
diff --git a/sound/pci/mixart/mixart_core.c b/sound/pci/mixart/mixart_core.c
index d3350f3..3df0f53 100644
--- a/sound/pci/mixart/mixart_core.c
+++ b/sound/pci/mixart/mixart_core.c
@@ -265,7 +265,7 @@ int snd_mixart_send_msg(struct mixart_mgr *mgr, struct mixart_msg *request, int
 	if (! timeout) {
 		/* error - no ack */
 		mutex_unlock(&mgr->msg_mutex);
-		snd_printk(KERN_ERR "error: no reponse on msg %x\n", msg_frame);
+		snd_printk(KERN_ERR "error: no response on msg %x\n", msg_frame);
 		return -EIO;
 	}
 
@@ -278,7 +278,7 @@ int snd_mixart_send_msg(struct mixart_mgr *mgr, struct mixart_msg *request, int
 	err = get_msg(mgr, &resp, msg_frame);
 
 	if( request->message_id != resp.message_id )
-		snd_printk(KERN_ERR "REPONSE ERROR!\n");
+		snd_printk(KERN_ERR "RESPONSE ERROR!\n");
 
 	mutex_unlock(&mgr->msg_mutex);
 	return err;
diff --git a/sound/pci/pcxhr/pcxhr_core.c b/sound/pci/pcxhr/pcxhr_core.c
index 833e718..304411c 100644
--- a/sound/pci/pcxhr/pcxhr_core.c
+++ b/sound/pci/pcxhr/pcxhr_core.c
@@ -1042,11 +1042,11 @@ void pcxhr_msg_tasklet(unsigned long arg)
 	int i, j;
 
 	if (mgr->src_it_dsp & PCXHR_IRQ_FREQ_CHANGE)
-		snd_printdd("TASKLET : PCXHR_IRQ_FREQ_CHANGE event occured\n");
+		snd_printdd("TASKLET : PCXHR_IRQ_FREQ_CHANGE event occurred\n");
 	if (mgr->src_it_dsp & PCXHR_IRQ_TIME_CODE)
-		snd_printdd("TASKLET : PCXHR_IRQ_TIME_CODE event occured\n");
+		snd_printdd("TASKLET : PCXHR_IRQ_TIME_CODE event occurred\n");
 	if (mgr->src_it_dsp & PCXHR_IRQ_NOTIFY)
-		snd_printdd("TASKLET : PCXHR_IRQ_NOTIFY event occured\n");
+		snd_printdd("TASKLET : PCXHR_IRQ_NOTIFY event occurred\n");
 	if (mgr->src_it_dsp & (PCXHR_IRQ_FREQ_CHANGE | PCXHR_IRQ_TIME_CODE)) {
 		/* clear events FREQ_CHANGE and TIME_CODE */
 		pcxhr_init_rmh(prmh, CMD_TEST_IT);
@@ -1055,7 +1055,7 @@ void pcxhr_msg_tasklet(unsigned long arg)
 			    err, prmh->stat[0]);
 	}
 	if (mgr->src_it_dsp & PCXHR_IRQ_ASYNC) {
-		snd_printdd("TASKLET : PCXHR_IRQ_ASYNC event occured\n");
+		snd_printdd("TASKLET : PCXHR_IRQ_ASYNC event occurred\n");
 
 		pcxhr_init_rmh(prmh, CMD_ASYNC);
 		prmh->cmd[0] |= 1;	/* add SEL_ASYNC_EVENTS */
@@ -1233,7 +1233,7 @@ irqreturn_t pcxhr_interrupt(int irq, void *dev_id)
 	reg = PCXHR_INPL(mgr, PCXHR_PLX_L2PCIDB);
 	PCXHR_OUTPL(mgr, PCXHR_PLX_L2PCIDB, reg);
 
-	/* timer irq occured */
+	/* timer irq occurred */
 	if (reg & PCXHR_IRQ_TIMER) {
 		int timer_toggle = reg & PCXHR_IRQ_TIMER;
 		/* is a 24 bit counter */
@@ -1288,7 +1288,7 @@ irqreturn_t pcxhr_interrupt(int irq, void *dev_id)
 	if (reg & PCXHR_IRQ_MASK) {
 		if (reg & PCXHR_IRQ_ASYNC) {
 			/* as we didn't request any async notifications,
-			 * some kind of xrun error will probably occured
+			 * some kind of xrun error will probably occurred
 			 */
 			/* better resynchronize all streams next interrupt : */
 			mgr->dsp_time_last = PCXHR_DSP_TIME_INVALID;
diff --git a/sound/pci/rme96.c b/sound/pci/rme96.c
index d5f5b44..9ff247f 100644
--- a/sound/pci/rme96.c
+++ b/sound/pci/rme96.c
@@ -150,7 +150,7 @@ MODULE_PARM_DESC(enable, "Enable RME Digi96 soundcard.");
 #define RME96_RCR_BITPOS_F1 28
 #define RME96_RCR_BITPOS_F2 29
 
-/* Additonal register bits */
+/* Additional register bits */
 #define RME96_AR_WSEL       (1 << 0)
 #define RME96_AR_ANALOG     (1 << 1)
 #define RME96_AR_FREQPAD_0  (1 << 2)
diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index a323eaf..949691a 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -391,7 +391,7 @@ MODULE_SUPPORTED_DEVICE("{{RME HDSPM-MADI}}");
 
 /* Status2 Register bits */ /* MADI ONLY */
 
-#define HDSPM_version0 (1<<0)	/* not realy defined but I guess */
+#define HDSPM_version0 (1<<0)	/* not really defined but I guess */
 #define HDSPM_version1 (1<<1)	/* in former cards it was ??? */
 #define HDSPM_version2 (1<<2)
 
@@ -936,7 +936,7 @@ struct hdspm {
 	struct snd_kcontrol *playback_mixer_ctls[HDSPM_MAX_CHANNELS];
 	/* but input to much, so not used */
 	struct snd_kcontrol *input_mixer_ctls[HDSPM_MAX_CHANNELS];
-	/* full mixer accessable over mixer ioctl or hwdep-device */
+	/* full mixer accessible over mixer ioctl or hwdep-device */
 	struct hdspm_mixer *mixer;
 
 	struct hdspm_tco *tco;  /* NULL if no TCO detected */
diff --git a/sound/pci/sis7019.c b/sound/pci/sis7019.c
index 1b8f674..2b5c7a95 100644
--- a/sound/pci/sis7019.c
+++ b/sound/pci/sis7019.c
@@ -308,7 +308,7 @@ static irqreturn_t sis_interrupt(int irq, void *dev)
 	u32 intr, status;
 
 	/* We only use the DMA interrupts, and we don't enable any other
-	 * source of interrupts. But, it is possible to see an interupt
+	 * source of interrupts. But, it is possible to see an interrupt
 	 * status that didn't actually interrupt us, so eliminate anything
 	 * we're not expecting to avoid falsely claiming an IRQ, and an
 	 * ensuing endless loop.
@@ -773,7 +773,7 @@ static void sis_prepare_timing_voice(struct voice *voice,
 		vperiod = 0;
 	}
 
-	/* The interrupt handler implements the timing syncronization, so
+	/* The interrupt handler implements the timing synchronization, so
 	 * setup its state.
 	 */
 	timing->flags |= VOICE_SYNC_TIMING;
@@ -1139,7 +1139,7 @@ static int sis_chip_init(struct sis7019 *sis)
 	 */
 	outl(SIS_DMA_CSR_PCI_SETTINGS, io + SIS_DMA_CSR);
 
-	/* Reset the syncronization groups for all of the channels
+	/* Reset the synchronization groups for all of the channels
 	 * to be asyncronous. If we start doing SPDIF or 5.1 sound, etc.
 	 * we'll need to change how we handle these. Until then, we just
 	 * assign sub-mixer 0 to all playback channels, and avoid any
diff --git a/sound/ppc/snd_ps3.c b/sound/ppc/snd_ps3.c
index edce8a2..bc823a5 100644
--- a/sound/ppc/snd_ps3.c
+++ b/sound/ppc/snd_ps3.c
@@ -358,7 +358,7 @@ static irqreturn_t snd_ps3_interrupt(int irq, void *dev_id)
 		 * filling dummy data, serial automatically start to
 		 * consume them and then will generate normal buffer
 		 * empty interrupts.
-		 * If both buffer underflow and buffer empty are occured,
+		 * If both buffer underflow and buffer empty are occurred,
 		 * it is better to do nomal data transfer than empty one
 		 */
 		snd_ps3_program_dma(card,
diff --git a/sound/ppc/snd_ps3_reg.h b/sound/ppc/snd_ps3_reg.h
index 03fdee4..2e63020 100644
--- a/sound/ppc/snd_ps3_reg.h
+++ b/sound/ppc/snd_ps3_reg.h
@@ -125,7 +125,7 @@
    transfers.  Any interrupts associated with the canceled transfers
    will occur as if the transfer had finished.
    Since this bit is designed to recover from DMA related issues
-   which are caused by unpredictable situations, it is prefered to wait
+   which are caused by unpredictable situations, it is preferred to wait
    for normal DMA transfer end without using this bit.
 */
 #define PS3_AUDIO_CONFIG_CLEAR          (1 << 8)  /* RWIVF */
@@ -316,13 +316,13 @@ DISABLED=Interrupt generation disabled.
 
 /*
 Audio Port Interrupt Status Register
-Indicates Interrupt status, which interrupt has occured, and can clear
+Indicates Interrupt status, which interrupt has occurred, and can clear
 each interrupt in this register.
 Writing 1b to a field containing 1b clears field and de-asserts interrupt.
 Writing 0b to a field has no effect.
 Field vaules are the following:
-0 - Interrupt hasn't occured.
-1 - Interrupt has occured.
+0 - Interrupt hasn't occurred.
+1 - Interrupt has occurred.
 
 
  31            24 23           16 15            8 7             0
@@ -473,7 +473,7 @@ Channel N is out of action by setting 0 to asoen.
 /*
 Sampling Rate
 Specifies the divide ratio of the bit clock (clock output
-from bclko) used by the 3-wire Audio Output Clock, whcih
+from bclko) used by the 3-wire Audio Output Clock, which
 is applied to the master clock selected by mcksel.
 Data output is synchronized with this clock.
 */
@@ -756,7 +756,7 @@ The STATUS field can be used to monitor the progress of a DMA request.
 DONE indicates the previous request has completed.
 EVENT indicates that the DMA engine is waiting for the EVENT to occur.
 PENDING indicates that the DMA engine has not started processing this
-request, but the EVENT has occured.
+request, but the EVENT has occurred.
 DMA indicates that the data transfer is in progress.
 NOTIFY indicates that the notifier signalling end of transfer is being written.
 CLEAR indicated that the previous transfer was cleared.
@@ -824,7 +824,7 @@ AUDIOFIFO = Audio WriteData FIFO,
 
 /*
 PS3_AUDIO_DMASIZE specifies the number of 128-byte blocks + 1 to transfer.
-So a value of 0 means 128-bytes will get transfered.
+So a value of 0 means 128-bytes will get transferred.
 
 
  31            24 23           16 15            8 7             0
diff --git a/sound/soc/atmel/atmel_ssc_dai.c b/sound/soc/atmel/atmel_ssc_dai.c
index 5d230ce..7fbfa05 100644
--- a/sound/soc/atmel/atmel_ssc_dai.c
+++ b/sound/soc/atmel/atmel_ssc_dai.c
@@ -672,7 +672,7 @@ static int atmel_ssc_resume(struct snd_soc_dai *cpu_dai)
 	/* re-enable interrupts */
 	ssc_writel(ssc_p->ssc->regs, IER, ssc_p->ssc_state.ssc_imr);
 
-	/* Re-enable recieve and transmit as appropriate */
+	/* Re-enable receive and transmit as appropriate */
 	cr = 0;
 	cr |=
 	    (ssc_p->ssc_state.ssc_sr & SSC_BIT(SR_RXEN)) ? SSC_BIT(CR_RXEN) : 0;
diff --git a/sound/soc/codecs/alc5623.c b/sound/soc/codecs/alc5623.c
index 4f377c9..eecffb5 100644
--- a/sound/soc/codecs/alc5623.c
+++ b/sound/soc/codecs/alc5623.c
@@ -481,7 +481,7 @@ struct _pll_div {
 };
 
 /* Note : pll code from original alc5623 driver. Not sure of how good it is */
-/* usefull only for master mode */
+/* useful only for master mode */
 static const struct _pll_div codec_master_pll_div[] = {
 
 	{  2048000,  8192000,	0x0ea0},
diff --git a/sound/soc/codecs/lm4857.c b/sound/soc/codecs/lm4857.c
index 72de47e..2c2a681 100644
--- a/sound/soc/codecs/lm4857.c
+++ b/sound/soc/codecs/lm4857.c
@@ -161,7 +161,7 @@ static const struct snd_kcontrol_new lm4857_controls[] = {
 		lm4857_get_mode, lm4857_set_mode),
 };
 
-/* There is a demux inbetween the the input signal and the output signals.
+/* There is a demux between the input signal and the output signals.
  * Currently there is no easy way to model it in ASoC and since it does not make
  * much of a difference in practice simply connect the input direclty to the
  * outputs. */
diff --git a/sound/soc/codecs/tlv320aic26.h b/sound/soc/codecs/tlv320aic26.h
index 62b1f22..67f19c3 100644
--- a/sound/soc/codecs/tlv320aic26.h
+++ b/sound/soc/codecs/tlv320aic26.h
@@ -14,14 +14,14 @@
 #define AIC26_PAGE_ADDR(page, offset)	((page << 6) | offset)
 #define AIC26_NUM_REGS			AIC26_PAGE_ADDR(3, 0)
 
-/* Page 0: Auxillary data registers */
+/* Page 0: Auxiliary data registers */
 #define AIC26_REG_BAT1			AIC26_PAGE_ADDR(0, 0x05)
 #define AIC26_REG_BAT2			AIC26_PAGE_ADDR(0, 0x06)
 #define AIC26_REG_AUX			AIC26_PAGE_ADDR(0, 0x07)
 #define AIC26_REG_TEMP1			AIC26_PAGE_ADDR(0, 0x09)
 #define AIC26_REG_TEMP2			AIC26_PAGE_ADDR(0, 0x0A)
 
-/* Page 1: Auxillary control registers */
+/* Page 1: Auxiliary control registers */
 #define AIC26_REG_AUX_ADC		AIC26_PAGE_ADDR(1, 0x00)
 #define AIC26_REG_STATUS		AIC26_PAGE_ADDR(1, 0x01)
 #define AIC26_REG_REFERENCE		AIC26_PAGE_ADDR(1, 0x03)
diff --git a/sound/soc/codecs/tlv320aic3x.c b/sound/soc/codecs/tlv320aic3x.c
index 3bedab2..6c43c13 100644
--- a/sound/soc/codecs/tlv320aic3x.c
+++ b/sound/soc/codecs/tlv320aic3x.c
@@ -884,7 +884,7 @@ static int aic3x_hw_params(struct snd_pcm_substream *substream,
 	if (bypass_pll)
 		return 0;
 
-	/* Use PLL, compute apropriate setup for j, d, r and p, the closest
+	/* Use PLL, compute appropriate setup for j, d, r and p, the closest
 	 * one wins the game. Try with d==0 first, next with d!=0.
 	 * Constraints for j are according to the datasheet.
 	 * The sysclk is divided by 1000 to prevent integer overflows.
diff --git a/sound/soc/codecs/tlv320dac33.c b/sound/soc/codecs/tlv320dac33.c
index eb1a0b4..082e9d5 100644
--- a/sound/soc/codecs/tlv320dac33.c
+++ b/sound/soc/codecs/tlv320dac33.c
@@ -1027,7 +1027,7 @@ static int dac33_prepare_chip(struct snd_pcm_substream *substream)
 		/*
 		 * For FIFO bypass mode:
 		 * Enable the FIFO bypass (Disable the FIFO use)
-		 * Set the BCLK as continous
+		 * Set the BCLK as continuous
 		 */
 		fifoctrl_a |= DAC33_FBYPAS;
 		aictrl_b |= DAC33_BCLKON;
diff --git a/sound/soc/codecs/twl4030.c b/sound/soc/codecs/twl4030.c
index 8512800..575238d 100644
--- a/sound/soc/codecs/twl4030.c
+++ b/sound/soc/codecs/twl4030.c
@@ -281,7 +281,7 @@ static inline void twl4030_check_defaults(struct snd_soc_codec *codec)
 				 i, val, twl4030_reg[i]);
 		}
 	}
-	dev_dbg(codec->dev, "Found %d non maching registers. %s\n",
+	dev_dbg(codec->dev, "Found %d non-matching registers. %s\n",
 		 difference, difference ? "Not OK" : "OK");
 }
 
@@ -2018,7 +2018,7 @@ static int twl4030_voice_startup(struct snd_pcm_substream *substream,
 	u8 mode;
 
 	/* If the system master clock is not 26MHz, the voice PCM interface is
-	 * not avilable.
+	 * not available.
 	 */
 	if (twl4030->sysclk != 26000) {
 		dev_err(codec->dev, "The board is configured for %u Hz, while"
@@ -2028,7 +2028,7 @@ static int twl4030_voice_startup(struct snd_pcm_substream *substream,
 	}
 
 	/* If the codec mode is not option2, the voice PCM interface is not
-	 * avilable.
+	 * available.
 	 */
 	mode = twl4030_read_reg_cache(codec, TWL4030_REG_CODEC_MODE)
 		& TWL4030_OPT_MODE;
diff --git a/sound/soc/codecs/wm8580.c b/sound/soc/codecs/wm8580.c
index 8f6b5ee..4bbc0a7 100644
--- a/sound/soc/codecs/wm8580.c
+++ b/sound/soc/codecs/wm8580.c
@@ -772,7 +772,7 @@ static int wm8580_set_bias_level(struct snd_soc_codec *codec,
 			reg &= ~(WM8580_PWRDN1_PWDN | WM8580_PWRDN1_ALLDACPD);
 			snd_soc_write(codec, WM8580_PWRDN1, reg);
 
-			/* Make VMID high impedence */
+			/* Make VMID high impedance */
 			reg = snd_soc_read(codec,  WM8580_ADC_CONTROL1);
 			reg &= ~0x100;
 			snd_soc_write(codec, WM8580_ADC_CONTROL1, reg);
diff --git a/sound/soc/codecs/wm8753.c b/sound/soc/codecs/wm8753.c
index 3f09dee..ffa2ffe 100644
--- a/sound/soc/codecs/wm8753.c
+++ b/sound/soc/codecs/wm8753.c
@@ -1312,7 +1312,7 @@ static int wm8753_set_bias_level(struct snd_soc_codec *codec,
 	SNDRV_PCM_FMTBIT_S24_LE)
 
 /*
- * The WM8753 supports upto 4 different and mutually exclusive DAI
+ * The WM8753 supports up to 4 different and mutually exclusive DAI
  * configurations. This gives 2 PCM's available for use, hifi and voice.
  * NOTE: The Voice PCM cannot play or capture audio to the CPU as it's DAI
  * is connected between the wm8753 and a BT codec or GSM modem.
diff --git a/sound/soc/codecs/wm8904.c b/sound/soc/codecs/wm8904.c
index 443ae58..9b3bba4 100644
--- a/sound/soc/codecs/wm8904.c
+++ b/sound/soc/codecs/wm8904.c
@@ -1895,7 +1895,7 @@ static int fll_factors(struct _fll_div *fll_div, unsigned int Fref,
 
 	pr_debug("Fvco=%dHz\n", target);
 
-	/* Find an appropraite FLL_FRATIO and factor it out of the target */
+	/* Find an appropriate FLL_FRATIO and factor it out of the target */
 	for (i = 0; i < ARRAY_SIZE(fll_fratios); i++) {
 		if (fll_fratios[i].min <= Fref && Fref <= fll_fratios[i].max) {
 			fll_div->fll_fratio = fll_fratios[i].fll_fratio;
diff --git a/sound/soc/codecs/wm8955.c b/sound/soc/codecs/wm8955.c
index 5e0214d..3c71987 100644
--- a/sound/soc/codecs/wm8955.c
+++ b/sound/soc/codecs/wm8955.c
@@ -176,7 +176,7 @@ static int wm8995_pll_factors(struct device *dev,
 	return 0;
 }
 
-/* Lookup table specifiying SRATE (table 25 in datasheet); some of the
+/* Lookup table specifying SRATE (table 25 in datasheet); some of the
  * output frequencies have been rounded to the standard frequencies
  * they are intended to match where the error is slight. */
 static struct {
diff --git a/sound/soc/codecs/wm8962.c b/sound/soc/codecs/wm8962.c
index 3b71dd6..500011e 100644
--- a/sound/soc/codecs/wm8962.c
+++ b/sound/soc/codecs/wm8962.c
@@ -3137,7 +3137,7 @@ static int fll_factors(struct _fll_div *fll_div, unsigned int Fref,
 
 	pr_debug("FLL Fvco=%dHz\n", target);
 
-	/* Find an appropraite FLL_FRATIO and factor it out of the target */
+	/* Find an appropriate FLL_FRATIO and factor it out of the target */
 	for (i = 0; i < ARRAY_SIZE(fll_fratios); i++) {
 		if (fll_fratios[i].min <= Fref && Fref <= fll_fratios[i].max) {
 			fll_div->fll_fratio = fll_fratios[i].fll_fratio;
diff --git a/sound/soc/codecs/wm8991.c b/sound/soc/codecs/wm8991.c
index 28fdfd6..3c2ee1b 100644
--- a/sound/soc/codecs/wm8991.c
+++ b/sound/soc/codecs/wm8991.c
@@ -981,7 +981,7 @@ static int wm8991_set_dai_pll(struct snd_soc_dai *codec_dai,
 		reg = snd_soc_read(codec, WM8991_CLOCKING_2);
 		snd_soc_write(codec, WM8991_CLOCKING_2, reg | WM8991_SYSCLK_SRC);
 
-		/* set up N , fractional mode and pre-divisor if neccessary */
+		/* set up N , fractional mode and pre-divisor if necessary */
 		snd_soc_write(codec, WM8991_PLL1, pll_div.n | WM8991_SDM |
 			      (pll_div.div2 ? WM8991_PRESCALE : 0));
 		snd_soc_write(codec, WM8991_PLL2, (u8)(pll_div.k>>8));
diff --git a/sound/soc/codecs/wm8993.c b/sound/soc/codecs/wm8993.c
index 379fa22..056aef9 100644
--- a/sound/soc/codecs/wm8993.c
+++ b/sound/soc/codecs/wm8993.c
@@ -324,7 +324,7 @@ static int fll_factors(struct _fll_div *fll_div, unsigned int Fref,
 
 	pr_debug("Fvco=%dHz\n", target);
 
-	/* Find an appropraite FLL_FRATIO and factor it out of the target */
+	/* Find an appropriate FLL_FRATIO and factor it out of the target */
 	for (i = 0; i < ARRAY_SIZE(fll_fratios); i++) {
 		if (fll_fratios[i].min <= Fref && Fref <= fll_fratios[i].max) {
 			fll_div->fll_fratio = fll_fratios[i].fll_fratio;
diff --git a/sound/soc/codecs/wm8994.c b/sound/soc/codecs/wm8994.c
index 3dc64c8..3290333 100644
--- a/sound/soc/codecs/wm8994.c
+++ b/sound/soc/codecs/wm8994.c
@@ -82,18 +82,18 @@ struct wm8994_priv {
 
 	int mbc_ena[3];
 
-	/* Platform dependant DRC configuration */
+	/* Platform dependent DRC configuration */
 	const char **drc_texts;
 	int drc_cfg[WM8994_NUM_DRC];
 	struct soc_enum drc_enum;
 
-	/* Platform dependant ReTune mobile configuration */
+	/* Platform dependent ReTune mobile configuration */
 	int num_retune_mobile_texts;
 	const char **retune_mobile_texts;
 	int retune_mobile_cfg[WM8994_NUM_EQ];
 	struct soc_enum retune_mobile_enum;
 
-	/* Platform dependant MBC configuration */
+	/* Platform dependent MBC configuration */
 	int mbc_cfg;
 	const char **mbc_texts;
 	struct soc_enum mbc_enum;
diff --git a/sound/soc/codecs/wm9081.c b/sound/soc/codecs/wm9081.c
index 55cdf29..91c6b39 100644
--- a/sound/soc/codecs/wm9081.c
+++ b/sound/soc/codecs/wm9081.c
@@ -305,7 +305,7 @@ static int speaker_mode_get(struct snd_kcontrol *kcontrol,
 /*
  * Stop any attempts to change speaker mode while the speaker is enabled.
  *
- * We also have some special anti-pop controls dependant on speaker
+ * We also have some special anti-pop controls dependent on speaker
  * mode which must be changed along with the mode.
  */
 static int speaker_mode_put(struct snd_kcontrol *kcontrol,
@@ -456,7 +456,7 @@ static int fll_factors(struct _fll_div *fll_div, unsigned int Fref,
 
 	pr_debug("Fvco=%dHz\n", target);
 
-	/* Find an appropraite FLL_FRATIO and factor it out of the target */
+	/* Find an appropriate FLL_FRATIO and factor it out of the target */
 	for (i = 0; i < ARRAY_SIZE(fll_fratios); i++) {
 		if (fll_fratios[i].min <= Fref && Fref <= fll_fratios[i].max) {
 			fll_div->fll_fratio = fll_fratios[i].fll_fratio;
diff --git a/sound/soc/imx/imx-ssi.c b/sound/soc/imx/imx-ssi.c
index bc92ec6..ac2ded9 100644
--- a/sound/soc/imx/imx-ssi.c
+++ b/sound/soc/imx/imx-ssi.c
@@ -16,7 +16,7 @@
  * sane processor vendors have a FIFO per AC97 slot, the i.MX has only
  * one FIFO which combines all valid receive slots. We cannot even select
  * which slots we want to receive. The WM9712 with which this driver
- * was developped with always sends GPIO status data in slot 12 which
+ * was developed with always sends GPIO status data in slot 12 which
  * we receive in our (PCM-) data stream. The only chance we have is to
  * manually skip this data in the FIQ handler. With sampling rates different
  * from 48000Hz not every frame has valid receive data, so the ratio
diff --git a/sound/soc/kirkwood/kirkwood-dma.c b/sound/soc/kirkwood/kirkwood-dma.c
index 0fd6a63..e13c6ce 100644
--- a/sound/soc/kirkwood/kirkwood-dma.c
+++ b/sound/soc/kirkwood/kirkwood-dma.c
@@ -132,7 +132,7 @@ static int kirkwood_dma_open(struct snd_pcm_substream *substream)
 	priv = snd_soc_dai_get_dma_data(cpu_dai, substream);
 	snd_soc_set_runtime_hwparams(substream, &kirkwood_dma_snd_hw);
 
-	/* Ensure that all constraints linked to dma burst are fullfilled */
+	/* Ensure that all constraints linked to dma burst are fulfilled */
 	err = snd_pcm_hw_constraint_minmax(runtime,
 			SNDRV_PCM_HW_PARAM_BUFFER_BYTES,
 			priv->burst * 2,
@@ -170,7 +170,7 @@ static int kirkwood_dma_open(struct snd_pcm_substream *substream)
 
 		/*
 		 * Enable Error interrupts. We're only ack'ing them but
-		 * it's usefull for diagnostics
+		 * it's useful for diagnostics
 		 */
 		writel((unsigned long)-1, priv->io + KIRKWOOD_ERR_MASK);
 	}
diff --git a/sound/soc/mid-x86/sst_platform.c b/sound/soc/mid-x86/sst_platform.c
index ee2c224..b2e9198 100644
--- a/sound/soc/mid-x86/sst_platform.c
+++ b/sound/soc/mid-x86/sst_platform.c
@@ -440,7 +440,7 @@ static int sst_platform_remove(struct platform_device *pdev)
 
 	snd_soc_unregister_dais(&pdev->dev, ARRAY_SIZE(sst_platform_dai));
 	snd_soc_unregister_platform(&pdev->dev);
-	pr_debug("sst_platform_remove sucess\n");
+	pr_debug("sst_platform_remove success\n");
 	return 0;
 }
 
@@ -463,7 +463,7 @@ module_init(sst_soc_platform_init);
 static void __exit sst_soc_platform_exit(void)
 {
 	platform_driver_unregister(&sst_platform_driver);
-	pr_debug("sst_soc_platform_exit sucess\n");
+	pr_debug("sst_soc_platform_exit success\n");
 }
 module_exit(sst_soc_platform_exit);
 
diff --git a/sound/soc/omap/ams-delta.c b/sound/soc/omap/ams-delta.c
index 3167be6..462cbcb 100644
--- a/sound/soc/omap/ams-delta.c
+++ b/sound/soc/omap/ams-delta.c
@@ -248,7 +248,7 @@ static struct snd_soc_jack_pin ams_delta_hook_switch_pins[] = {
  */
 
 /* To actually apply any modem controlled configuration changes to the codec,
- * we must connect codec DAI pins to the modem for a moment.  Be carefull not
+ * we must connect codec DAI pins to the modem for a moment.  Be careful not
  * to interfere with our digital mute function that shares the same hardware. */
 static struct timer_list cx81801_timer;
 static bool cx81801_cmd_pending;
@@ -402,9 +402,9 @@ static struct tty_ldisc_ops cx81801_ops = {
 
 
 /*
- * Even if not very usefull, the sound card can still work without any of the
+ * Even if not very useful, the sound card can still work without any of the
  * above functonality activated.  You can still control its audio input/output
- * constellation and speakerphone gain from userspace by issueing AT commands
+ * constellation and speakerphone gain from userspace by issuing AT commands
  * over the modem port.
  */
 
diff --git a/sound/soc/samsung/neo1973_wm8753.c b/sound/soc/samsung/neo1973_wm8753.c
index 78bfdb3..4522309 100644
--- a/sound/soc/samsung/neo1973_wm8753.c
+++ b/sound/soc/samsung/neo1973_wm8753.c
@@ -228,7 +228,7 @@ static const struct snd_kcontrol_new neo1973_wm8753_controls[] = {
 	SOC_DAPM_PIN_SWITCH("Handset Mic"),
 };
 
-/* GTA02 specific routes and controlls */
+/* GTA02 specific routes and controls */
 
 #ifdef CONFIG_MACH_NEO1973_GTA02
 
@@ -372,7 +372,7 @@ static int neo1973_wm8753_init(struct snd_soc_pcm_runtime *rtd)
 	return 0;
 }
 
-/* GTA01 specific controlls */
+/* GTA01 specific controls */
 
 #ifdef CONFIG_MACH_NEO1973_GTA01
 
diff --git a/sound/usb/6fire/firmware.c b/sound/usb/6fire/firmware.c
index 9081a54..86c1a31 100644
--- a/sound/usb/6fire/firmware.c
+++ b/sound/usb/6fire/firmware.c
@@ -76,7 +76,7 @@ struct ihex_record {
 	u16 address;
 	u8 len;
 	u8 data[256];
-	char error; /* true if an error occured parsing this record */
+	char error; /* true if an error occurred parsing this record */
 
 	u8 max_len; /* maximum record length in whole ihex */
 
@@ -107,7 +107,7 @@ static u8 usb6fire_fw_ihex_hex(const u8 *data, u8 *crc)
 
 /*
  * returns true if record is available, false otherwise.
- * iff an error occured, false will be returned and record->error will be true.
+ * iff an error occurred, false will be returned and record->error will be true.
  */
 static bool usb6fire_fw_ihex_next_record(struct ihex_record *record)
 {
diff --git a/sound/usb/mixer.c b/sound/usb/mixer.c
index 5e47757..6ec33b6 100644
--- a/sound/usb/mixer.c
+++ b/sound/usb/mixer.c
@@ -1182,7 +1182,7 @@ static void build_feature_ctl(struct mixer_build *state, void *raw_desc,
 /*
  * parse a feature unit
  *
- * most of controlls are defined here.
+ * most of controls are defined here.
  */
 static int parse_audio_feature_unit(struct mixer_build *state, int unitid, void *_ftr)
 {
diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 355759b..ec07e62 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -266,7 +266,7 @@ static int create_uaxx_quirk(struct snd_usb_audio *chip,
  * audio-interface quirks
  *
  * returns zero if no standard audio/MIDI parsing is needed.
- * returns a postive value if standard audio/midi interfaces are parsed
+ * returns a positive value if standard audio/midi interfaces are parsed
  * after this.
  * returns a negative value at error.
  */
diff --git a/sound/usb/usx2y/usx2yhwdeppcm.c b/sound/usb/usx2y/usx2yhwdeppcm.c
index 287ef73..a51340f 100644
--- a/sound/usb/usx2y/usx2yhwdeppcm.c
+++ b/sound/usb/usx2y/usx2yhwdeppcm.c
@@ -20,7 +20,7 @@
  at standard samplerates,
  what led to this part of the usx2y module: 
  It provides the alsa kernel half of the usx2y-alsa-jack driver pair.
- The pair uses a hardware dependant alsa-device for mmaped pcm transport.
+ The pair uses a hardware dependent alsa-device for mmaped pcm transport.
  Advantage achieved:
          The usb_hc moves pcm data from/into memory via DMA.
          That memory is mmaped by jack's usx2y driver.
@@ -38,7 +38,7 @@
          2periods works but is useless cause of crackling).
 
  This is a first "proof of concept" implementation.
- Later, functionalities should migrate to more apropriate places:
+ Later, functionalities should migrate to more appropriate places:
  Userland:
  - The jackd could mmap its float-pcm buffers directly from alsa-lib.
  - alsa-lib could provide power of 2 period sized shaping combined with int/float
diff --git a/tools/perf/util/probe-event.c b/tools/perf/util/probe-event.c
index 5ddee66..f022316 100644
--- a/tools/perf/util/probe-event.c
+++ b/tools/perf/util/probe-event.c
@@ -234,7 +234,6 @@ static int try_to_find_probe_trace_events(struct perf_probe_event *pev,
 
 	/* Searching trace events corresponding to probe event */
 	ntevs = find_probe_trace_events(fd, pev, tevs, max_tevs);
-	close(fd);
 
 	if (ntevs > 0) {	/* Succeeded to find trace events */
 		pr_debug("find %d probe_trace_events.\n", ntevs);
@@ -388,7 +387,6 @@ int show_line_range(struct line_range *lr, const char *module)
 	}
 
 	ret = find_line_range(fd, lr);
-	close(fd);
 	if (ret == 0) {
 		pr_warning("Specified source line is not found.\n");
 		return -ENOENT;
@@ -512,19 +510,18 @@ int show_available_vars(struct perf_probe_event *pevs, int npevs,
 	if (ret < 0)
 		return ret;
 
-	fd = open_vmlinux(module);
-	if (fd < 0) {
-		pr_warning("Failed to open debug information file.\n");
-		return fd;
-	}
-
 	setup_pager();
 
-	for (i = 0; i < npevs && ret >= 0; i++)
+	for (i = 0; i < npevs && ret >= 0; i++) {
+		fd = open_vmlinux(module);
+		if (fd < 0) {
+			pr_warning("Failed to open debug information file.\n");
+			ret = fd;
+			break;
+		}
 		ret = show_available_vars_at(fd, &pevs[i], max_vls, _filter,
 					     externs);
-
-	close(fd);
+	}
 	return ret;
 }
 
diff --git a/tools/perf/util/probe-finder.c b/tools/perf/util/probe-finder.c
index 194f9e2..b7c85ce 100644
--- a/tools/perf/util/probe-finder.c
+++ b/tools/perf/util/probe-finder.c
@@ -273,6 +273,25 @@ static const char *cu_get_comp_dir(Dwarf_Die *cu_die)
 	return dwarf_formstring(&attr);
 }
 
+/* Get a line number and file name for given address */
+static int cu_find_lineinfo(Dwarf_Die *cudie, unsigned long addr,
+			    const char **fname, int *lineno)
+{
+	Dwarf_Line *line;
+	Dwarf_Addr laddr;
+
+	line = dwarf_getsrc_die(cudie, (Dwarf_Addr)addr);
+	if (line && dwarf_lineaddr(line, &laddr) == 0 &&
+	    addr == (unsigned long)laddr && dwarf_lineno(line, lineno) == 0) {
+		*fname = dwarf_linesrc(line, NULL, NULL);
+		if (!*fname)
+			/* line number is useless without filename */
+			*lineno = 0;
+	}
+
+	return *lineno ?: -ENOENT;
+}
+
 /* Compare diename and tname */
 static bool die_compare_name(Dwarf_Die *dw_die, const char *tname)
 {
@@ -497,7 +516,20 @@ static int __die_find_inline_cb(Dwarf_Die *die_mem, void *data)
 static Dwarf_Die *die_find_inlinefunc(Dwarf_Die *sp_die, Dwarf_Addr addr,
 				      Dwarf_Die *die_mem)
 {
-	return die_find_child(sp_die, __die_find_inline_cb, &addr, die_mem);
+	Dwarf_Die tmp_die;
+
+	sp_die = die_find_child(sp_die, __die_find_inline_cb, &addr, &tmp_die);
+	if (!sp_die)
+		return NULL;
+
+	/* Inlined function could be recursive. Trace it until fail */
+	while (sp_die) {
+		memcpy(die_mem, sp_die, sizeof(Dwarf_Die));
+		sp_die = die_find_child(sp_die, __die_find_inline_cb, &addr,
+					&tmp_die);
+	}
+
+	return die_mem;
 }
 
 /* Walker on lines (Note: line number will not be sorted) */
@@ -1395,6 +1427,10 @@ static int probe_point_search_cb(Dwarf_Die *sp_die, void *data)
 	    !die_compare_name(sp_die, pp->function))
 		return DWARF_CB_OK;
 
+	/* Check declared file */
+	if (pp->file && strtailcmp(pp->file, dwarf_decl_file(sp_die)))
+		return DWARF_CB_OK;
+
 	pf->fname = dwarf_decl_file(sp_die);
 	if (pp->line) { /* Function relative line */
 		dwarf_decl_line(sp_die, &pf->lno);
@@ -1451,6 +1487,7 @@ static int find_probes(int fd, struct probe_finder *pf)
 	if (!dbg) {
 		pr_warning("No debug information found in the vmlinux - "
 			"please rebuild with CONFIG_DEBUG_INFO=y.\n");
+		close(fd);	/* Without dwfl_end(), fd isn't closed. */
 		return -EBADF;
 	}
 
@@ -1686,11 +1723,9 @@ int find_perf_probe_point(unsigned long addr, struct perf_probe_point *ppt)
 	Dwarf_Die cudie, spdie, indie;
 	Dwarf *dbg = NULL;
 	Dwfl *dwfl = NULL;
-	Dwarf_Line *line;
-	Dwarf_Addr laddr, eaddr, bias = 0;
-	const char *tmp;
-	int lineno, ret = 0;
-	bool found = false;
+	Dwarf_Addr _addr, baseaddr, bias = 0;
+	const char *fname = NULL, *func = NULL, *tmp;
+	int baseline = 0, lineno = 0, ret = 0;
 
 	/* Open the live linux kernel */
 	dbg = dwfl_init_live_kernel_dwarf(addr, &dwfl, &bias);
@@ -1711,68 +1746,79 @@ int find_perf_probe_point(unsigned long addr, struct perf_probe_point *ppt)
 		goto end;
 	}
 
-	/* Find a corresponding line */
-	line = dwarf_getsrc_die(&cudie, (Dwarf_Addr)addr);
-	if (line) {
-		if (dwarf_lineaddr(line, &laddr) == 0 &&
-		    (Dwarf_Addr)addr == laddr &&
-		    dwarf_lineno(line, &lineno) == 0) {
-			tmp = dwarf_linesrc(line, NULL, NULL);
-			if (tmp) {
-				ppt->line = lineno;
-				ppt->file = strdup(tmp);
-				if (ppt->file == NULL) {
-					ret = -ENOMEM;
-					goto end;
-				}
-				found = true;
-			}
-		}
-	}
+	/* Find a corresponding line (filename and lineno) */
+	cu_find_lineinfo(&cudie, addr, &fname, &lineno);
+	/* Don't care whether it failed or not */
 
-	/* Find a corresponding function */
+	/* Find a corresponding function (name, baseline and baseaddr) */
 	if (die_find_real_subprogram(&cudie, (Dwarf_Addr)addr, &spdie)) {
+		/* Get function entry information */
 		tmp = dwarf_diename(&spdie);
-		if (!tmp || dwarf_entrypc(&spdie, &eaddr) != 0)
-			goto end;
-
-		if (ppt->line) {
-			if (die_find_inlinefunc(&spdie, (Dwarf_Addr)addr,
-						&indie)) {
-				/* addr in an inline function */
+		if (!tmp ||
+		    dwarf_entrypc(&spdie, &baseaddr) != 0 ||
+		    dwarf_decl_line(&spdie, &baseline) != 0)
+			goto post;
+		func = tmp;
+
+		if (addr == (unsigned long)baseaddr)
+			/* Function entry - Relative line number is 0 */
+			lineno = baseline;
+		else if (die_find_inlinefunc(&spdie, (Dwarf_Addr)addr,
+					     &indie)) {
+			if (dwarf_entrypc(&indie, &_addr) == 0 &&
+			    _addr == addr)
+				/*
+				 * addr is at an inline function entry.
+				 * In this case, lineno should be the call-site
+				 * line number.
+				 */
+				lineno = die_get_call_lineno(&indie);
+			else {
+				/*
+				 * addr is in an inline function body.
+				 * Since lineno points one of the lines
+				 * of the inline function, baseline should
+				 * be the entry line of the inline function.
+				 */
 				tmp = dwarf_diename(&indie);
-				if (!tmp)
-					goto end;
-				ret = dwarf_decl_line(&indie, &lineno);
-			} else {
-				if (eaddr == addr) {	/* Function entry */
-					lineno = ppt->line;
-					ret = 0;
-				} else
-					ret = dwarf_decl_line(&spdie, &lineno);
-			}
-			if (ret == 0) {
-				/* Make a relative line number */
-				ppt->line -= lineno;
-				goto found;
+				if (tmp &&
+				    dwarf_decl_line(&spdie, &baseline) == 0)
+					func = tmp;
 			}
 		}
-		/* We don't have a line number, let's use offset */
-		ppt->offset = addr - (unsigned long)eaddr;
-found:
-		ppt->function = strdup(tmp);
+	}
+
+post:
+	/* Make a relative line number or an offset */
+	if (lineno)
+		ppt->line = lineno - baseline;
+	else if (func)
+		ppt->offset = addr - (unsigned long)baseaddr;
+
+	/* Duplicate strings */
+	if (func) {
+		ppt->function = strdup(func);
 		if (ppt->function == NULL) {
 			ret = -ENOMEM;
 			goto end;
 		}
-		found = true;
 	}
-
+	if (fname) {
+		ppt->file = strdup(fname);
+		if (ppt->file == NULL) {
+			if (ppt->function) {
+				free(ppt->function);
+				ppt->function = NULL;
+			}
+			ret = -ENOMEM;
+			goto end;
+		}
+	}
 end:
 	if (dwfl)
 		dwfl_end(dwfl);
-	if (ret >= 0)
-		ret = found ? 1 : 0;
+	if (ret == 0 && (fname || func))
+		ret = 1;	/* Found a point */
 	return ret;
 }
 
@@ -1840,6 +1886,10 @@ static int line_range_search_cb(Dwarf_Die *sp_die, void *data)
 	struct line_finder *lf = param->data;
 	struct line_range *lr = lf->lr;
 
+	/* Check declared file */
+	if (lr->file && strtailcmp(lr->file, dwarf_decl_file(sp_die)))
+		return DWARF_CB_OK;
+
 	if (dwarf_tag(sp_die) == DW_TAG_subprogram &&
 	    die_compare_name(sp_die, lr->function)) {
 		lf->fname = dwarf_decl_file(sp_die);
@@ -1892,6 +1942,7 @@ int find_line_range(int fd, struct line_range *lr)
 	if (!dbg) {
 		pr_warning("No debug information found in the vmlinux - "
 			"please rebuild with CONFIG_DEBUG_INFO=y.\n");
+		close(fd);	/* Without dwfl_end(), fd isn't closed. */
 		return -EBADF;
 	}
 
diff --git a/tools/perf/util/string.c b/tools/perf/util/string.c
index 8fc0bd3..b9a985d 100644
--- a/tools/perf/util/string.c
+++ b/tools/perf/util/string.c
@@ -85,7 +85,7 @@ out:
 
 /*
  * Helper function for splitting a string into an argv-like array.
- * originaly copied from lib/argv_split.c
+ * originally copied from lib/argv_split.c
  */
 static const char *skip_sep(const char *cp)
 {
diff --git a/tools/power/x86/x86_energy_perf_policy/x86_energy_perf_policy.c b/tools/power/x86/x86_energy_perf_policy/x86_energy_perf_policy.c
index d9678a3..2618ef2 100644
--- a/tools/power/x86/x86_energy_perf_policy/x86_energy_perf_policy.c
+++ b/tools/power/x86/x86_energy_perf_policy/x86_energy_perf_policy.c
@@ -46,7 +46,7 @@ int cpu = -1;
  *
  *  performance
  *	Performance is paramount.
- *	Unwilling to sacrafice any performance
+ *	Unwilling to sacrifice any performance
  *	for the sake of energy saving. (hardware default)
  *
  *  normal
diff --git a/virt/kvm/eventfd.c b/virt/kvm/eventfd.c
index 3656849..73358d2 100644
--- a/virt/kvm/eventfd.c
+++ b/virt/kvm/eventfd.c
@@ -90,7 +90,7 @@ irqfd_shutdown(struct work_struct *work)
 	 * We know no new events will be scheduled at this point, so block
 	 * until all previously outstanding events have completed
 	 */
-	flush_work(&irqfd->inject);
+	flush_work_sync(&irqfd->inject);
 
 	/*
 	 * It is now safe to release the object's resources
@@ -578,7 +578,7 @@ kvm_assign_ioeventfd(struct kvm *kvm, struct kvm_ioeventfd *args)
 
 	mutex_lock(&kvm->slots_lock);
 
-	/* Verify that there isnt a match already */
+	/* Verify that there isn't a match already */
 	if (ioeventfd_check_collision(kvm, p)) {
 		ret = -EEXIST;
 		goto unlock_fail;
diff --git a/virt/kvm/kvm_main.c b/virt/kvm/kvm_main.c
index 556e3ef..6330653 100644
--- a/virt/kvm/kvm_main.c
+++ b/virt/kvm/kvm_main.c
@@ -1037,6 +1037,17 @@ static pfn_t get_fault_pfn(void)
 	return fault_pfn;
 }
 
+int get_user_page_nowait(struct task_struct *tsk, struct mm_struct *mm,
+	unsigned long start, int write, struct page **page)
+{
+	int flags = FOLL_TOUCH | FOLL_NOWAIT | FOLL_HWPOISON | FOLL_GET;
+
+	if (write)
+		flags |= FOLL_WRITE;
+
+	return __get_user_pages(tsk, mm, start, 1, flags, page, NULL, NULL);
+}
+
 static inline int check_user_page_hwpoison(unsigned long addr)
 {
 	int rc, flags = FOLL_TOUCH | FOLL_HWPOISON | FOLL_WRITE;
@@ -1070,7 +1081,14 @@ static pfn_t hva_to_pfn(struct kvm *kvm, unsigned long addr, bool atomic,
 		if (writable)
 			*writable = write_fault;
 
-		npages = get_user_pages_fast(addr, 1, write_fault, page);
+		if (async) {
+			down_read(&current->mm->mmap_sem);
+			npages = get_user_page_nowait(current, current->mm,
+						     addr, write_fault, page);
+			up_read(&current->mm->mmap_sem);
+		} else
+			npages = get_user_pages_fast(addr, 1, write_fault,
+						     page);
 
 		/* map read fault as writable if possible */
 		if (unlikely(!write_fault) && npages == 1) {
@@ -1093,7 +1111,8 @@ static pfn_t hva_to_pfn(struct kvm *kvm, unsigned long addr, bool atomic,
 			return get_fault_pfn();
 
 		down_read(&current->mm->mmap_sem);
-		if (check_user_page_hwpoison(addr)) {
+		if (npages == -EHWPOISON ||
+			(!async && check_user_page_hwpoison(addr))) {
 			up_read(&current->mm->mmap_sem);
 			get_page(hwpoison_page);
 			return page_to_pfn(hwpoison_page);
