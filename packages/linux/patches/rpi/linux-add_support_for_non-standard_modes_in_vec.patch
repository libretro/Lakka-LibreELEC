From c9840e0bc29991a06cbf0fe4817e9af73fd3d4c6 Mon Sep 17 00:00:00 2001
From: Mateusz Kwiatkowski <kfyatek+publicgit@gmail.com>
Date: Thu, 15 Jul 2021 01:08:21 +0200
Subject: [PATCH] drm/vc4: Make the VEC clock adjustable

Add support for pixel clocks other than the standard 13.5 MHz. Make the
color subcarrier frequencies calculated relative to the actual clock so
that they stay within spec.

Signed-off-by: Mateusz Kwiatkowski <kfyatek+publicgit@gmail.com>
---
 drivers/gpu/drm/vc4/vc4_vec.c | 57 ++++++++++++++++++++---------------
 1 file changed, 33 insertions(+), 24 deletions(-)

diff --git a/drivers/gpu/drm/vc4/vc4_vec.c b/drivers/gpu/drm/vc4/vc4_vec.c
index 1764f0b43ea92..ab2203f611b2a 100644
--- a/drivers/gpu/drm/vc4/vc4_vec.c
+++ b/drivers/gpu/drm/vc4/vc4_vec.c
@@ -254,8 +254,7 @@ struct vc4_vec_tv_mode {
 	const struct drm_display_mode *interlaced_mode;
 	const struct drm_display_mode *progressive_mode;
 	u32 config0;
-	u32 config1;
-	u32 custom_freq;
+	u64 chroma_freq_millihz;
 };
 
 static const struct debugfs_reg32 vec_regs[] = {
@@ -316,54 +315,51 @@ static const struct vc4_vec_tv_mode vc4_vec_tv_modes[] = {
 		.interlaced_mode = &drm_mode_480i,
 		.progressive_mode = &drm_mode_240p,
 		.config0 = VEC_CONFIG0_NTSC_STD | VEC_CONFIG0_PDEN,
-		.config1 = VEC_CONFIG1_C_CVBS_CVBS,
+		.chroma_freq_millihz = 3579545455ull,
 	},
 	[VC4_VEC_TV_MODE_NTSC_J] = {
 		.interlaced_mode = &drm_mode_480i,
 		.progressive_mode = &drm_mode_240p,
 		.config0 = VEC_CONFIG0_NTSC_STD,
-		.config1 = VEC_CONFIG1_C_CVBS_CVBS,
+		.chroma_freq_millihz = 3579545455ull,
 	},
 	[VC4_VEC_TV_MODE_NTSC_443] = {
 		/* NTSC with PAL chroma frequency */
 		.interlaced_mode = &drm_mode_480i,
 		.progressive_mode = &drm_mode_240p,
 		.config0 = VEC_CONFIG0_NTSC_STD,
-		.config1 = VEC_CONFIG1_C_CVBS_CVBS | VEC_CONFIG1_CUSTOM_FREQ,
-		.custom_freq = 0x2a098acb,
+		.chroma_freq_millihz = 4433618750ull,
 	},
 	[VC4_VEC_TV_MODE_PAL] = {
 		.interlaced_mode = &drm_mode_576i,
 		.progressive_mode = &drm_mode_288p,
 		.config0 = VEC_CONFIG0_PAL_BDGHI_STD,
-		.config1 = VEC_CONFIG1_C_CVBS_CVBS,
+		.chroma_freq_millihz = 4433618750ull,
 	},
 	[VC4_VEC_TV_MODE_PAL_M] = {
 		.interlaced_mode = &drm_mode_480i,
 		.progressive_mode = &drm_mode_240p,
 		.config0 = VEC_CONFIG0_PAL_M_STD,
-		.config1 = VEC_CONFIG1_C_CVBS_CVBS,
+		.chroma_freq_millihz = 3575611888ull,
 	},
 	[VC4_VEC_TV_MODE_PAL_N] = {
 		.interlaced_mode = &drm_mode_576i,
 		.progressive_mode = &drm_mode_288p,
 		.config0 = VEC_CONFIG0_PAL_N_STD,
-		.config1 = VEC_CONFIG1_C_CVBS_CVBS,
+		.chroma_freq_millihz = 3582056250ull,
 	},
 	[VC4_VEC_TV_MODE_PAL60] = {
 		/* PAL-M with chroma frequency of regular PAL */
 		.interlaced_mode = &drm_mode_480i,
 		.progressive_mode = &drm_mode_240p,
 		.config0 = VEC_CONFIG0_PAL_M_STD,
-		.config1 = VEC_CONFIG1_C_CVBS_CVBS | VEC_CONFIG1_CUSTOM_FREQ,
-		.custom_freq = 0x2a098acb,
+		.chroma_freq_millihz = 4433618750ull,
 	},
 	[VC4_VEC_TV_MODE_SECAM] = {
 		.interlaced_mode = &drm_mode_576i,
 		.progressive_mode = &drm_mode_288p,
 		.config0 = VEC_CONFIG0_SECAM_STD,
-		.config1 = VEC_CONFIG1_C_CVBS_CVBS,
-		.custom_freq = 0x29c71c72,
+		.chroma_freq_millihz = 4406250000ull,
 	},
 };
 
@@ -617,8 +613,12 @@ static void vc4_vec_encoder_enable(struct drm_encoder *encoder)
 {
 	struct vc4_vec_encoder *vc4_vec_encoder = to_vc4_vec_encoder(encoder);
 	struct vc4_vec *vec = vc4_vec_encoder->vec;
+	struct drm_display_mode *adjusted_mode =
+		&encoder->crtc->state->adjusted_mode;
 	unsigned int tv_mode = vec->connector->state->tv.mode;
 	int ret;
+	long eff_clk_rate;
+	u64 chroma_freq;
 
 	ret = pm_runtime_get_sync(&vec->pdev->dev);
 	if (ret < 0) {
@@ -633,7 +633,7 @@ static void vc4_vec_encoder_enable(struct drm_encoder *encoder)
 	 * The good news is, these 2 encoders cannot be enabled at the same
 	 * time, thus preventing incompatible rate requests.
 	 */
-	ret = clk_set_rate(vec->clock, 108000000);
+	ret = clk_set_rate(vec->clock, 8000 * adjusted_mode->clock);
 	if (ret) {
 		DRM_ERROR("Failed to set clock rate: %d\n", ret);
 		return;
@@ -645,6 +645,9 @@ static void vc4_vec_encoder_enable(struct drm_encoder *encoder)
 		return;
 	}
 
+	eff_clk_rate = clk_get_rate(vec->clock);
+	DRM_DEBUG_DRIVER("Effective clock rate: %ld\n", eff_clk_rate);
+
 	/* Reset the different blocks */
 	VEC_WRITE(VEC_WSE_RESET, 1);
 	VEC_WRITE(VEC_SOFT_RESET, 1);
@@ -668,8 +671,8 @@ static void vc4_vec_encoder_enable(struct drm_encoder *encoder)
 	VEC_WRITE(VEC_CONFIG2,
 		  VEC_CONFIG2_UV_DIG_DIS |
 		  VEC_CONFIG2_RGB_DIG_DIS |
-		  ((encoder->crtc->state->adjusted_mode.flags &
-		    DRM_MODE_FLAG_INTERLACE) ? 0 : VEC_CONFIG2_PROG_SCAN));
+		  ((adjusted_mode->flags & DRM_MODE_FLAG_INTERLACE)
+			? 0 : VEC_CONFIG2_PROG_SCAN));
 	VEC_WRITE(VEC_CONFIG3, VEC_CONFIG3_HORIZ_LEN_STD);
 	VEC_WRITE(VEC_DAC_CONFIG, vec->variant->dac_config);
 
@@ -677,14 +680,20 @@ static void vc4_vec_encoder_enable(struct drm_encoder *encoder)
 	VEC_WRITE(VEC_MASK0, 0);
 
 	VEC_WRITE(VEC_CONFIG0, vc4_vec_tv_modes[tv_mode].config0);
-	VEC_WRITE(VEC_CONFIG1, vc4_vec_tv_modes[tv_mode].config1);
-	if (vc4_vec_tv_modes[tv_mode].custom_freq != 0) {
-		VEC_WRITE(VEC_FREQ3_2,
-			  (vc4_vec_tv_modes[tv_mode].custom_freq >> 16) &
-			  0xffff);
-		VEC_WRITE(VEC_FREQ1_0,
-			  vc4_vec_tv_modes[tv_mode].custom_freq & 0xffff);
-	}
+	VEC_WRITE(VEC_CONFIG1,
+		  VEC_CONFIG1_C_CVBS_CVBS | VEC_CONFIG1_CUSTOM_FREQ);
+
+	chroma_freq = vc4_vec_tv_modes[tv_mode].chroma_freq_millihz << 31;
+	chroma_freq += (125ull * (u64)eff_clk_rate) >> 1; /* proper rounding */
+	do_div(chroma_freq, eff_clk_rate);
+	do_div(chroma_freq, 125);
+	VEC_WRITE(VEC_FREQ3_2, (chroma_freq >> 16) & 0xffff);
+	VEC_WRITE(VEC_FREQ1_0, chroma_freq & 0xffff);
+
+	/* SECAM Db frequency */
+	chroma_freq = ((4250000000ull / 125) << 31) + eff_clk_rate / 2;
+	do_div(chroma_freq, eff_clk_rate);
+	VEC_WRITE(VEC_FCW_SECAM_B, chroma_freq);
 
 	VEC_WRITE(VEC_DAC_MISC,
 		  VEC_DAC_MISC_VID_ACT | VEC_DAC_MISC_DAC_RST_N);
From cbeafed71ec5c71132075c9e79dc91b20aa77ba4 Mon Sep 17 00:00:00 2001
From: Mateusz Kwiatkowski <kfyatek+publicgit@gmail.com>
Date: Mon, 11 Oct 2021 23:34:25 +0200
Subject: [PATCH] drm/vc4: Add vertically scaled progressive modes for VEC

The Raspberry Pi firmware, when configured to output progressive
composite video, scales 720x480/720x576 framebuffer into a
720x240/720x288 physical video mode.

This commit adds support for replicating such behavior, as this provides
square-ish virtual pixels, and some userland software rely on this.

Signed-off-by: Mateusz Kwiatkowski <kfyatek+publicgit@gmail.com>
---
 drivers/gpu/drm/vc4/vc4_plane.c |  40 ++++++
 drivers/gpu/drm/vc4/vc4_vec.c   | 220 ++++++++++++++++++++------------
 2 files changed, 176 insertions(+), 84 deletions(-)

diff --git a/drivers/gpu/drm/vc4/vc4_plane.c b/drivers/gpu/drm/vc4/vc4_plane.c
index 7947cf47b6e13..96b60fb245982 100644
--- a/drivers/gpu/drm/vc4/vc4_plane.c
+++ b/drivers/gpu/drm/vc4/vc4_plane.c
@@ -334,6 +334,42 @@ static int vc4_plane_margins_adj(struct drm_plane_state *pstate)
 	return 0;
 }
 
+static int vc4_plane_scaling_adj(struct drm_plane_state *pstate)
+{
+	struct vc4_plane_state *vc4_pstate = to_vc4_plane_state(pstate);
+	struct drm_crtc_state *crtc_state;
+
+	crtc_state = drm_atomic_get_new_crtc_state(pstate->state,
+						   pstate->crtc);
+
+	if (crtc_state->mode.hdisplay != crtc_state->adjusted_mode.hdisplay) {
+		vc4_pstate->crtc_x =
+			DIV_ROUND_CLOSEST(vc4_pstate->crtc_x *
+					  crtc_state->adjusted_mode.hdisplay,
+					  crtc_state->mode.hdisplay);
+		vc4_pstate->crtc_w =
+			DIV_ROUND_CLOSEST(vc4_pstate->crtc_w *
+					  crtc_state->adjusted_mode.hdisplay,
+					  crtc_state->mode.hdisplay);
+	}
+
+	if (crtc_state->mode.vdisplay != crtc_state->adjusted_mode.vdisplay) {
+		vc4_pstate->crtc_y =
+			DIV_ROUND_CLOSEST(vc4_pstate->crtc_y *
+					  crtc_state->adjusted_mode.vdisplay,
+					  crtc_state->mode.vdisplay);
+		vc4_pstate->crtc_h =
+			DIV_ROUND_CLOSEST(vc4_pstate->crtc_h *
+					  crtc_state->adjusted_mode.vdisplay,
+					  crtc_state->mode.vdisplay);
+	}
+
+	if (!vc4_pstate->crtc_w || !vc4_pstate->crtc_h)
+		return -EINVAL;
+
+	return 0;
+}
+
 static int vc4_plane_setup_clipping_and_scaling(struct drm_plane_state *state)
 {
 	struct vc4_plane_state *vc4_state = to_vc4_plane_state(state);
@@ -378,6 +414,10 @@ static int vc4_plane_setup_clipping_and_scaling(struct drm_plane_state *state)
 	if (ret)
 		return ret;
 
+	ret = vc4_plane_scaling_adj(state);
+	if (ret)
+		return ret;
+
 	vc4_state->x_scaling[0] = vc4_get_scaling_mode(vc4_state->src_w[0],
 						       vc4_state->crtc_w);
 	vc4_state->y_scaling[0] = vc4_get_scaling_mode(vc4_state->src_h[0],
diff --git a/drivers/gpu/drm/vc4/vc4_vec.c b/drivers/gpu/drm/vc4/vc4_vec.c
index ab2203f611b2a..2685ee37e47e8 100644
--- a/drivers/gpu/drm/vc4/vc4_vec.c
+++ b/drivers/gpu/drm/vc4/vc4_vec.c
@@ -253,6 +253,7 @@ enum vc4_vec_tv_mode_id {
 struct vc4_vec_tv_mode {
 	const struct drm_display_mode *interlaced_mode;
 	const struct drm_display_mode *progressive_mode;
+	const struct drm_display_mode *scaled_progressive_mode;
 	u32 config0;
 	u64 chroma_freq_millihz;
 };
@@ -297,6 +298,12 @@ static const struct drm_display_mode drm_mode_240p = {
 		 240, 240 + 3, 240 + 3 + 3, 262, 0, 0)
 };
 
+static const struct drm_display_mode drm_mode_scaled_480p = {
+	DRM_MODE("720x480 (scaled)", DRM_MODE_TYPE_DRIVER, 2 * 13500,
+		 720, 720 + 14, 720 + 14 + 64, 720 + 14 + 64 + 60, 0,
+		 2 * 240, 2 * (240 + 3), 2 * (240 + 3 + 3), 2 * 262, 0, 0)
+};
+
 static const struct drm_display_mode drm_mode_576i = {
 	DRM_MODE("720x576i", DRM_MODE_TYPE_DRIVER, 13500,
 		 720, 720 + 20, 720 + 20 + 64, 720 + 20 + 64 + 60, 0,
@@ -310,16 +317,24 @@ static const struct drm_display_mode drm_mode_288p = {
 		 288, 288 + 2, 288 + 2 + 3, 312, 0, 0)
 };
 
+static const struct drm_display_mode drm_mode_scaled_576p = {
+	DRM_MODE("720x576 (scaled)", DRM_MODE_TYPE_DRIVER, 2 * 13500,
+		 720, 720 + 20, 720 + 20 + 64, 720 + 20 + 64 + 60, 0,
+		 2 * 288, 2 * (288 + 2), 2 * (288 + 2 + 3), 2 * 312, 0, 0)
+};
+
 static const struct vc4_vec_tv_mode vc4_vec_tv_modes[] = {
 	[VC4_VEC_TV_MODE_NTSC] = {
 		.interlaced_mode = &drm_mode_480i,
 		.progressive_mode = &drm_mode_240p,
+		.scaled_progressive_mode = &drm_mode_scaled_480p,
 		.config0 = VEC_CONFIG0_NTSC_STD | VEC_CONFIG0_PDEN,
 		.chroma_freq_millihz = 3579545455ull,
 	},
 	[VC4_VEC_TV_MODE_NTSC_J] = {
 		.interlaced_mode = &drm_mode_480i,
 		.progressive_mode = &drm_mode_240p,
+		.scaled_progressive_mode = &drm_mode_scaled_480p,
 		.config0 = VEC_CONFIG0_NTSC_STD,
 		.chroma_freq_millihz = 3579545455ull,
 	},
@@ -327,24 +342,28 @@ static const struct vc4_vec_tv_mode vc4_vec_tv_modes[] = {
 		/* NTSC with PAL chroma frequency */
 		.interlaced_mode = &drm_mode_480i,
 		.progressive_mode = &drm_mode_240p,
+		.scaled_progressive_mode = &drm_mode_scaled_480p,
 		.config0 = VEC_CONFIG0_NTSC_STD,
 		.chroma_freq_millihz = 4433618750ull,
 	},
 	[VC4_VEC_TV_MODE_PAL] = {
 		.interlaced_mode = &drm_mode_576i,
 		.progressive_mode = &drm_mode_288p,
+		.scaled_progressive_mode = &drm_mode_scaled_576p,
 		.config0 = VEC_CONFIG0_PAL_BDGHI_STD,
 		.chroma_freq_millihz = 4433618750ull,
 	},
 	[VC4_VEC_TV_MODE_PAL_M] = {
 		.interlaced_mode = &drm_mode_480i,
 		.progressive_mode = &drm_mode_240p,
+		.scaled_progressive_mode = &drm_mode_scaled_480p,
 		.config0 = VEC_CONFIG0_PAL_M_STD,
 		.chroma_freq_millihz = 3575611888ull,
 	},
 	[VC4_VEC_TV_MODE_PAL_N] = {
 		.interlaced_mode = &drm_mode_576i,
 		.progressive_mode = &drm_mode_288p,
+		.scaled_progressive_mode = &drm_mode_scaled_576p,
 		.config0 = VEC_CONFIG0_PAL_N_STD,
 		.chroma_freq_millihz = 3582056250ull,
 	},
@@ -352,12 +371,14 @@ static const struct vc4_vec_tv_mode vc4_vec_tv_modes[] = {
 		/* PAL-M with chroma frequency of regular PAL */
 		.interlaced_mode = &drm_mode_480i,
 		.progressive_mode = &drm_mode_240p,
+		.scaled_progressive_mode = &drm_mode_scaled_480p,
 		.config0 = VEC_CONFIG0_PAL_M_STD,
 		.chroma_freq_millihz = 4433618750ull,
 	},
 	[VC4_VEC_TV_MODE_SECAM] = {
 		.interlaced_mode = &drm_mode_576i,
 		.progressive_mode = &drm_mode_288p,
+		.scaled_progressive_mode = &drm_mode_scaled_576p,
 		.config0 = VEC_CONFIG0_SECAM_STD,
 		.chroma_freq_millihz = 4406250000ull,
 	},
@@ -416,7 +437,9 @@ static void vc4_vec_connector_destroy(struct drm_connector *connector)
 static int vc4_vec_connector_get_modes(struct drm_connector *connector)
 {
 	struct drm_connector_state *state = connector->state;
-	struct drm_display_mode *interlaced_mode, *progressive_mode;
+	struct drm_display_mode *interlaced_mode;
+	struct drm_display_mode *progressive_mode;
+	struct drm_display_mode *scaled_progressive_mode;
 
 	interlaced_mode =
 		drm_mode_duplicate(connector->dev,
@@ -424,24 +447,33 @@ static int vc4_vec_connector_get_modes(struct drm_connector *connector)
 	progressive_mode =
 		drm_mode_duplicate(connector->dev,
 				   vc4_vec_tv_modes[state->tv.mode].progressive_mode);
-	if (!interlaced_mode || !progressive_mode) {
+	scaled_progressive_mode =
+		drm_mode_duplicate(connector->dev,
+				   vc4_vec_tv_modes[state->tv.mode].scaled_progressive_mode);
+	if (!interlaced_mode || !progressive_mode || !scaled_progressive_mode) {
 		DRM_ERROR("Failed to create a new display mode\n");
 		drm_mode_destroy(connector->dev, interlaced_mode);
 		drm_mode_destroy(connector->dev, progressive_mode);
+		drm_mode_destroy(connector->dev, scaled_progressive_mode);
 		return -ENOMEM;
 	}
 
 	if (connector->cmdline_mode.specified &&
 	    connector->cmdline_mode.refresh_specified &&
-	    !connector->cmdline_mode.interlace)
+	    !connector->cmdline_mode.interlace) {
 		/* progressive mode set at boot, let's make it preferred */
-		progressive_mode->type |= DRM_MODE_TYPE_PREFERRED;
-	else
+		if (connector->cmdline_mode.yres > 300)
+			scaled_progressive_mode->type |= DRM_MODE_TYPE_PREFERRED;
+		else
+			progressive_mode->type |= DRM_MODE_TYPE_PREFERRED;
+	} else {
 		/* otherwise, interlaced mode is preferred */
 		interlaced_mode->type |= DRM_MODE_TYPE_PREFERRED;
+	}
 
 	drm_mode_probed_add(connector, interlaced_mode);
 	drm_mode_probed_add(connector, progressive_mode);
+	drm_mode_probed_add(connector, scaled_progressive_mode);
 
 	return 1;
 }
