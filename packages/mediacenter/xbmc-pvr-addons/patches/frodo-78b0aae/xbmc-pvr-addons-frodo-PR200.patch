From 628a7239b70c157c86eecff15a25243dda7ab0ba Mon Sep 17 00:00:00 2001
From: Anton Fedchin <afedchin@ruswizards.com>
Date: Sat, 8 Jun 2013 16:45:02 +0400
Subject: [PATCH] [iptvsimple] new pvr.iptvsimple addon.

---
 README                                             |    2 +
 addons/Makefile.am                                 |    8 +-
 addons/pvr.iptvsimple/Makefile.am                  |   19 +
 addons/pvr.iptvsimple/addon/addon.xml.in           |   27 +
 addons/pvr.iptvsimple/addon/icon.png               |  Bin 0 -> 63858 bytes
 addons/pvr.iptvsimple/addon/iptv.m3u               |    0
 .../addon/resources/language/English/strings.po    |   72 +
 .../addon/resources/language/French/strings.po     |   71 +
 .../addon/resources/language/Russian/strings.po    |   70 +
 addons/pvr.iptvsimple/addon/resources/settings.xml |   18 +
 .../project/VS2010Express/pvr.iptvsimple.vcxproj   |  100 +
 .../VS2010Express/pvr.iptvsimple.vcxproj.filters   |   33 +
 addons/pvr.iptvsimple/src/PVRIptvData.cpp          |  977 ++++++++
 addons/pvr.iptvsimple/src/PVRIptvData.h            |  122 +
 addons/pvr.iptvsimple/src/client.cpp               |  438 ++++
 addons/pvr.iptvsimple/src/client.h                 |   54 +
 configure.ac                                       |   13 +-
 lib/rapidxml/license.txt                           |   52 +
 lib/rapidxml/manual.html                           |  406 +++
 lib/rapidxml/rapidxml.hpp                          | 2596 ++++++++++++++++++++
 lib/rapidxml/rapidxml_iterators.hpp                |  175 ++
 lib/rapidxml/rapidxml_print.hpp                    |  421 ++++
 lib/rapidxml/rapidxml_utils.hpp                    |  122 +
 project/BuildDependencies/scripts/zlib_d.bat       |   13 +
 project/BuildDependencies/scripts/zlib_d.txt       |    2 +
 project/VS2010Express/xbmc-pvr-addons.sln          |    6 +
 26 files changed, 5814 insertions(+), 3 deletions(-)
 create mode 100644 addons/pvr.iptvsimple/Makefile.am
 create mode 100644 addons/pvr.iptvsimple/addon/addon.xml.in
 create mode 100644 addons/pvr.iptvsimple/addon/icon.png
 create mode 100644 addons/pvr.iptvsimple/addon/iptv.m3u
 create mode 100644 addons/pvr.iptvsimple/addon/resources/language/English/strings.po
 create mode 100644 addons/pvr.iptvsimple/addon/resources/language/French/strings.po
 create mode 100644 addons/pvr.iptvsimple/addon/resources/language/Russian/strings.po
 create mode 100644 addons/pvr.iptvsimple/addon/resources/settings.xml
 create mode 100644 addons/pvr.iptvsimple/project/VS2010Express/pvr.iptvsimple.vcxproj
 create mode 100644 addons/pvr.iptvsimple/project/VS2010Express/pvr.iptvsimple.vcxproj.filters
 create mode 100644 addons/pvr.iptvsimple/src/PVRIptvData.cpp
 create mode 100644 addons/pvr.iptvsimple/src/PVRIptvData.h
 create mode 100644 addons/pvr.iptvsimple/src/client.cpp
 create mode 100644 addons/pvr.iptvsimple/src/client.h
 create mode 100644 lib/rapidxml/license.txt
 create mode 100644 lib/rapidxml/manual.html
 create mode 100644 lib/rapidxml/rapidxml.hpp
 create mode 100644 lib/rapidxml/rapidxml_iterators.hpp
 create mode 100644 lib/rapidxml/rapidxml_print.hpp
 create mode 100644 lib/rapidxml/rapidxml_utils.hpp
 create mode 100644 project/BuildDependencies/scripts/zlib_d.bat
 create mode 100644 project/BuildDependencies/scripts/zlib_d.txt

diff --git a/README b/README
index 7694add..e530e28 100644
--- a/README
+++ b/README
@@ -30,6 +30,8 @@ List of addons with dependencies:
 - MythTV addon:
     Build dependencies:   libmysqlclient, boost (headers)
     Runtime dependencies: libmysqlclient
+- IPTV Simple addon:
+    Build dependencies:   zlib
 
 =============================
            Windows
diff --git a/addons/Makefile.am b/addons/Makefile.am
index 00987b4..c677998 100644
--- a/addons/Makefile.am
+++ b/addons/Makefile.am
@@ -1,5 +1,8 @@
 if ADDON_MYTHTV
-          ADDITIONAL_SUBDIRS = pvr.mythtv.cmyth
+          ADDON_MYTHTV_SUBDIRS = pvr.mythtv.cmyth
+endif
+if ADDON_IPTVSIMPLE
+          ADDON_IPTVSIMPLE_SUBDIRS = pvr.iptvsimple
 endif
 
 SUBDIRS = pvr.demo \
@@ -11,7 +14,8 @@ SUBDIRS = pvr.demo \
           pvr.njoy \
           pvr.vuplus \
           pvr.argustv \
-          $(ADDITIONAL_SUBDIRS)
+          $(ADDON_MYTHTV_SUBDIRS) \
+          $(ADDON_IPTVSIMPLE_SUBDIRS)
 
 clean:
 	-rm -f *.zip
diff --git a/addons/pvr.iptvsimple/Makefile.am b/addons/pvr.iptvsimple/Makefile.am
new file mode 100644
index 0000000..a82a2f4
--- /dev/null
+++ b/addons/pvr.iptvsimple/Makefile.am
@@ -0,0 +1,19 @@
+#
+# Makefile for the PVR IPTV Simple add-on for XBMC PVR
+#
+# See the README for copyright information and
+# how to reach the author.
+#
+
+ADDONBINNAME    = XBMC_IPTV_Simple
+ADDONNAME       = pvr.iptvsimple
+LIBNAME         = libpvriptvsimple-addon
+lib_LTLIBRARIES = libpvriptvsimple-addon.la
+
+include ../Makefile.include.am
+
+libpvriptvsimple_addon_la_SOURCES = src/client.cpp \
+                                    src/PVRIptvData.cpp
+libpvriptvsimple_addon_la_LDFLAGS = $(ZLIB_LIBS) @TARGET_LDFLAGS@
+
+
diff --git a/addons/pvr.iptvsimple/addon/addon.xml.in b/addons/pvr.iptvsimple/addon/addon.xml.in
new file mode 100644
index 0000000..185c3ab
--- /dev/null
+++ b/addons/pvr.iptvsimple/addon/addon.xml.in
@@ -0,0 +1,27 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<addon
+  id="pvr.iptvsimple"
+  version="1.6.0"
+  name="PVR IPTV Simple Client"
+  provider-name="nightik">
+  <requires>
+    <c-pluff version="0.1"/>
+    <import addon="xbmc.pvr" version="1.6.0"/>
+  </requires>
+  <extension
+    point="xbmc.pvrclient"
+    library_linux="XBMC_IPTV_Simple.pvr"
+    library_osx="XBMC_IPTV_Simple.pvr"
+    library_wingl="XBMC_IPTV_Simple_win32.dll"
+    library_windx="XBMC_IPTV_Simple_win32.dll"
+    library_android="libXBMC_IPTV_Simple.so" />
+  <extension point="xbmc.addon.metadata">
+    <summary lang="en">XBMC PVR addon for IPTV support. https://github.com/afedchin/xbmc-addon-iptvsimple/wiki/IPTV-Simple-Home</summary>
+    <summary lang="ru">XBMC PVR аддон для поддержки IPTV.  https://github.com/afedchin/xbmc-addon-iptvsimple/wiki/IPTV-Simple-Home</summary>
+    <description lang="en">IPTV Simple PVR Client support m3u playlists, streaming of Live TV for multicast/unicast sources, listening to Radio channels and EPG.</description>
+    <description lang="ru">Интерфейс для IPTV. Поддерживает просмотр потокового ТВ для юникаст/мультикаст источников, прослушивание радиоканалов и работу с электронным телегидом.</description>
+    <disclaimer lang="en">This is unstable software! The authors are in no way responsible for failed playings, incorrect EPG times, wasted hours, or any other undesirable effects.</disclaimer>
+    <disclaimer lang="ru">Это нестабильная программа! Авторы не несут ответственности за неудачные воспроизведение, неверные время EPG, потраченное время и прочие нежелательные эффекты.</disclaimer>
+    <platform>@OS@</platform>
+  </extension>
+</addon>
diff --git a/addons/pvr.iptvsimple/addon/icon.png b/addons/pvr.iptvsimple/addon/icon.png
new file mode 100644
index 0000000000000000000000000000000000000000..c3a8e4924133562db5eb32ab4ca94b677af6a27c
GIT binary patch
literal 63858
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

literal 0
HcmV?d00001

diff --git a/addons/pvr.iptvsimple/addon/iptv.m3u b/addons/pvr.iptvsimple/addon/iptv.m3u
new file mode 100644
index 0000000..e69de29
diff --git a/addons/pvr.iptvsimple/addon/resources/language/English/strings.po b/addons/pvr.iptvsimple/addon/resources/language/English/strings.po
new file mode 100644
index 0000000..d676f4d
--- /dev/null
+++ b/addons/pvr.iptvsimple/addon/resources/language/English/strings.po
@@ -0,0 +1,72 @@
+# XBMC Media Center language file
+# Addon Name: PVR IP-TV Simple Client
+# Addon id: pvr.iptvsimple
+# Addon version: 0.1.0
+# Addon Provider: nightik
+msgid ""
+msgstr ""
+"Project-Id-Version: XBMC Main Translation Project (Frodo)\n"
+"Report-Msgid-Bugs-To: http://trac.xbmc.org/\n"
+"POT-Creation-Date: YEAR-MO-DA HO:MI+ZONE\n"
+"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
+"Last-Translator: XBMC Translation Team\n"
+"Language-Team: English (http://www.transifex.com/projects/p/XBMC-Main-Frodo/language/en/)\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=UTF-8\n"
+"Content-Transfer-Encoding: 8bit\n"
+"Language: en\n"
+"Plural-Forms: nplurals=2; plural=(n != 1);\n"
+
+#settings labels
+
+msgctxt "#30000"
+msgid "File Location"
+msgstr ""
+
+msgctxt "#30001"
+msgid "Local Path (include Local Network)"
+msgstr ""
+
+msgctxt "#30002"
+msgid "Remote Path (Internet address)"
+msgstr ""
+
+msgctxt "#30010"
+msgid "Play List Settings"
+msgstr ""
+
+msgctxt "#30011"
+msgid "M3U Play List Path"
+msgstr ""
+
+msgctxt "#30012"
+msgid "M3U Play List URL"
+msgstr ""
+
+msgctxt "#30020"
+msgid "EPG Settings"
+msgstr ""
+
+msgctxt "#30021"
+msgid "XMLTV Path"
+msgstr ""
+
+msgctxt "#30022"
+msgid "XMLTV URL"
+msgstr ""
+
+msgctxt "#30023"
+msgid "Apply Time Shift To All Channels"
+msgstr ""
+
+msgctxt "#30024"
+msgid "EPG Time Shift (hours)"
+msgstr ""
+
+msgctxt "#30030"
+msgid "Channels Logos"
+msgstr ""
+
+msgctxt "#30031"
+msgid "Channels Logos Folder"
+msgstr ""
diff --git a/addons/pvr.iptvsimple/addon/resources/language/French/strings.po b/addons/pvr.iptvsimple/addon/resources/language/French/strings.po
new file mode 100644
index 0000000..73663c6
--- /dev/null
+++ b/addons/pvr.iptvsimple/addon/resources/language/French/strings.po
@@ -0,0 +1,71 @@
+# XBMC Media Center language file
+# Addon Name: PVR IP-TV Simple Client
+# Addon id: pvr.iptvsimple
+# Addon version: 0.1.2
+# Addon Provider: nightik
+# Translators:
+msgid ""
+msgstr ""
+"Project-Id-Version: PVR-IPTV Simple\n"
+"Report-Msgid-Bugs-To: http://trac.xbmc.org/\n"
+"POT-Creation-Date: YEAR-MO-DA HO:MI+ZONE\n"
+"PO-Revision-Date: 2013-02-27 06:56+0000\n"
+"Last-Translator: numa001 <manu.robinet@free.fr>\n"
+"Language-Team: English (http://www.transifex.com/projects/p/XBMC-Main-Frodo/language/en/)\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=UTF-8\n"
+"Content-Transfer-Encoding: 8bit\n"
+"Language: fr\n"
+"Plural-Forms: nplurals=2; plural=(n > 1);\n"
+
+msgctxt "#30000"
+msgid "File Location"
+msgstr "Emplacement du fichier"
+
+msgctxt "#30001"
+msgid "Local Path (include Local Network)"
+msgstr "Chemin local (inclue le réseau local)"
+
+msgctxt "#30002"
+msgid "Remote Path (Internet address)"
+msgstr "Chemin d'accès (adresse internet)"
+
+msgctxt "#30010"
+msgid "Play List Settings"
+msgstr "Paramètres de la Playlist"
+
+msgctxt "#30011"
+msgid "M3U Play List Path"
+msgstr "Chemin de la Playlist M3U"
+
+msgctxt "#30012"
+msgid "M3U Play List URL"
+msgstr "URL de la playlist M3U"
+
+msgctxt "#30020"
+msgid "EPG Settings"
+msgstr "Paramètres EPG"
+
+msgctxt "#30021"
+msgid "XMLTV Path"
+msgstr "Chemin du fichier XMLTV"
+
+msgctxt "#30022"
+msgid "XMLTV URL"
+msgstr "URL du fichier XMLTV"
+
+msgctxt "#30023"
+msgid "Apply Time Shift To All Channels"
+msgstr "Appliquer un décalage horaire sur toutes les chaînes"
+
+msgctxt "#30024"
+msgid "EPG Time Shift (hours)"
+msgstr "Décalage horaire de l'EPG (heures)"
+
+msgctxt "#30030"
+msgid "Channels Logos"
+msgstr "Logos des chaînes"
+
+msgctxt "#30031"
+msgid "Channels Logos Folder"
+msgstr "Répertoire des Logos de chaînes"
diff --git a/addons/pvr.iptvsimple/addon/resources/language/Russian/strings.po b/addons/pvr.iptvsimple/addon/resources/language/Russian/strings.po
new file mode 100644
index 0000000..a7f577f
--- /dev/null
+++ b/addons/pvr.iptvsimple/addon/resources/language/Russian/strings.po
@@ -0,0 +1,70 @@
+# XBMC Media Center language file
+# Addon Name: PVR IP-TV Simple Client
+# Addon id: pvr.iptvsimple
+# Addon version: 0.1.0
+# Addon Provider: nightik
+msgid ""
+msgstr ""
+"Project-Id-Version: XBMC Main Translation Project (Frodo)\n"
+"Report-Msgid-Bugs-To: http://trac.xbmc.org/\n"
+"POT-Creation-Date: YEAR-MO-DA HO:MI+ZONE\n"
+"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
+"Last-Translator: XBMC Translation Team\n"
+"Language-Team: Russian (http://www.transifex.com/projects/p/XBMC-Main-Frodo/language/ru/)\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=UTF-8\n"
+"Content-Transfer-Encoding: 8bit\n"
+"Language: ru\n"
+"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
+
+msgctxt "#30000"
+msgid "File Location"
+msgstr "Расположение файла"
+
+msgctxt "#30001"
+msgid "Local Path (include Local Network)"
+msgstr "Локальный путь (в т.ч. Локальная Сеть)"
+
+msgctxt "#30002"
+msgid "Remote Path (Internet address)"
+msgstr "Удалённый путь (сеть Интернет)"
+
+msgctxt "#30010"
+msgid "Play List Settings"
+msgstr "Установки плейлиста"
+
+msgctxt "#30011"
+msgid "M3U Play List Path"
+msgstr "Путь к M3U"
+
+msgctxt "#30012"
+msgid "M3U Play List URL"
+msgstr "Ссылка на M3U"
+
+msgctxt "#30020"
+msgid "EPG Settings"
+msgstr "Установки EPG"
+
+msgctxt "#30021"
+msgid "XMLTV Path"
+msgstr "Путь к XMLTV"
+
+msgctxt "#30022"
+msgid "XMLTV URL"
+msgstr "Ссылка на XMLTV"
+
+msgctxt "#30023"
+msgid "Apply Time Shift To All Channels"
+msgstr "Применять сдвиг по времени для всех каналов"
+
+msgctxt "#30024"
+msgid "EPG Time Shift (hours)"
+msgstr "Сдвиг по времени для EPG (часов)"
+
+msgctxt "#30030"
+msgid "Channels Logos"
+msgstr "Логотипы каналов"
+
+msgctxt "#30031"
+msgid "Channels Logos Folder"
+msgstr "Папка с логотипами каналов"
diff --git a/addons/pvr.iptvsimple/addon/resources/settings.xml b/addons/pvr.iptvsimple/addon/resources/settings.xml
new file mode 100644
index 0000000..63d42a6
--- /dev/null
+++ b/addons/pvr.iptvsimple/addon/resources/settings.xml
@@ -0,0 +1,18 @@
+<?xml version="1.0" encoding="utf-8" standalone="yes"?>
+<settings>
+	<setting id="sep1" label="30010" type="lsep"/> 
+	<setting id="m3uPathType" type="enum" label="30000" lvalues="30001|30002" default="1" />
+	<setting id="m3uPath" type="file" label="30011" default="" visible="eq(-1,0)"/>
+	<setting id="m3uUrl" type="text" label="30012" default="" visible="eq(-2,1)"/>
+
+	<setting id="sep2" label="30020" type="lsep"/>
+	<setting id="epgPathType" type="enum" label="30000" lvalues="30001|30002" default="1" />
+	<setting id="epgPath" type="file" label="30021" default="" visible="eq(-1,0)"/>
+	<setting id="epgUrl" type="text" label="30022" default="" visible="eq(-2,1)"/>
+<!--	<setting id="epgTimeShift" type="slider" label="30024" default="0" range="-12,.5,12" option="float"/>-->
+	<setting id="epgTimeShift_" type="enum" label="30024" default="12" values="-12|-11|-10|-9|-8|-7|-6|-5|-4|-3|-2|-1|0|+1|+2|+3|+4|+5|+6|+7|+8|+9|+10|+11|+12"/>-->
+	<setting id="epgTSOverride" type="bool" label="30023" default="false"/>
+
+	<setting id="sep3" label="30030" type="lsep"/>
+	<setting id="logoPath" type="folder" label="30031" default="" />
+</settings>
diff --git a/addons/pvr.iptvsimple/project/VS2010Express/pvr.iptvsimple.vcxproj b/addons/pvr.iptvsimple/project/VS2010Express/pvr.iptvsimple.vcxproj
new file mode 100644
index 0000000..f9c3f89
--- /dev/null
+++ b/addons/pvr.iptvsimple/project/VS2010Express/pvr.iptvsimple.vcxproj
@@ -0,0 +1,100 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|Win32">
+      <Configuration>Debug</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|Win32">
+      <Configuration>Release</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{6C67B057-CE98-4732-AABF-0E374C718815}</ProjectGuid>
+    <RootNamespace>pvr_iptvsimple</RootNamespace>
+    <ProjectName>pvr.iptvsimple</ProjectName>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
+    <ConfigurationType>DynamicLibrary</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
+    <ConfigurationType>DynamicLibrary</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <OutDir>..\..\addon\</OutDir>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <TargetName>XBMC_IPTV_Simple_win32</TargetName>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <OutDir>..\..\addon\</OutDir>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <TargetName>XBMC_IPTV_Simple_win32</TargetName>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <ClCompile>
+      <WarningLevel>Level3</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <AdditionalIncludeDirectories>..\..\..\..\project\BuildDependencies\include;..\..\..\..\xbmc;..\..\..\..\lib;..\..\..\..\lib\platform\windows</AdditionalIncludeDirectories>
+      <PreprocessorDefinitions>_WINDLL;TARGET_WINDOWS;_CRT_SECURE_NO_WARNINGS;_USE_32BIT_TIME_T;_WINSOCKAPI_;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalDependencies>kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;ws2_32.lib;zlib.lib;%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalLibraryDirectories>..\..\..\..\project\BuildDependencies\lib</AdditionalLibraryDirectories>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <ClCompile>
+      <WarningLevel>Level3</WarningLevel>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <AdditionalIncludeDirectories>..\..\..\..\project\BuildDependencies\include;..\..\..\..\xbmc;..\..\..\..\lib;..\..\..\..\lib\platform\windows</AdditionalIncludeDirectories>
+      <PreprocessorDefinitions>_WINDLL;TARGET_WINDOWS;_CRT_SECURE_NO_WARNINGS;_USE_32BIT_TIME_T;_WINSOCKAPI_;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalDependencies>kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;ws2_32.lib;zlib.lib;%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalLibraryDirectories>..\..\..\..\project\BuildDependencies\lib</AdditionalLibraryDirectories>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <ClCompile Include="..\..\src\client.cpp" />
+    <ClCompile Include="..\..\src\PVRIptvData.cpp" />
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="..\..\src\client.h" />
+    <ClInclude Include="..\..\src\PVRIptvData.h" />
+  </ItemGroup>
+  <ItemGroup>
+    <ProjectReference Include="..\..\..\..\project\VS2010Express\platform\platform.vcxproj">
+      <Project>{fe4573f6-a794-4ad3-b37f-49e51f1140e6}</Project>
+    </ProjectReference>
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/addons/pvr.iptvsimple/project/VS2010Express/pvr.iptvsimple.vcxproj.filters b/addons/pvr.iptvsimple/project/VS2010Express/pvr.iptvsimple.vcxproj.filters
new file mode 100644
index 0000000..b5146e6
--- /dev/null
+++ b/addons/pvr.iptvsimple/project/VS2010Express/pvr.iptvsimple.vcxproj.filters
@@ -0,0 +1,33 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="..\..\src\client.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\src\PVRIptvData.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="..\..\src\client.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\src\PVRIptvData.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/addons/pvr.iptvsimple/src/PVRIptvData.cpp b/addons/pvr.iptvsimple/src/PVRIptvData.cpp
new file mode 100644
index 0000000..4ca5265
--- /dev/null
+++ b/addons/pvr.iptvsimple/src/PVRIptvData.cpp
@@ -0,0 +1,977 @@
+/*
+ *      Copyright (C) 2013 Anton Fedchin
+ *      http://github.com/afedchin/xbmc-addon-iptvsimple/
+ *
+ *      Copyright (C) 2011 Pulse-Eight
+ *      http://www.pulse-eight.com/
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include <sstream>
+#include <string>
+#include <fstream>
+#include <map>
+#include "zlib.h"
+#include "rapidxml/rapidxml.hpp"
+#include "PVRIptvData.h"
+
+#define M3U_START_MARKER        "#EXTM3U"
+#define M3U_INFO_MARKER         "#EXTINF"
+#define TVG_INFO_ID_MARKER      "tvg-id="
+#define TVG_INFO_NAME_MARKER    "tvg-name="
+#define TVG_INFO_LOGO_MARKER    "tvg-logo="
+#define TVG_INFO_SHIFT_MARKER   "tvg-shift="
+#define GROUP_NAME_MARKER       "group-title="
+#define RADIO_MARKER            "radio="
+#define CHANNEL_LOGO_EXTENSION  ".png"
+#define SECONDS_IN_DAY          86400
+
+using namespace std;
+using namespace ADDON;
+using namespace rapidxml;
+
+template<class Ch>
+inline bool GetNodeValue(const xml_node<Ch> * pRootNode, const char* strTag, CStdString& strStringValue)
+{
+  xml_node<Ch> *pChildNode = pRootNode->first_node(strTag);
+  if (pChildNode == NULL)
+  {
+    return false;
+  }
+  strStringValue = pChildNode->value();
+  return true;
+}
+
+template<class Ch>
+inline bool GetAttributeValue(const xml_node<Ch> * pNode, const char* strAttributeName, CStdString& strStringValue)
+{
+  xml_attribute<Ch> *pAttribute = pNode->first_attribute(strAttributeName);
+  if (pAttribute == NULL)
+  {
+    return false;
+  }
+  strStringValue = pAttribute->value();
+  return true;
+}
+
+PVRIptvData::PVRIptvData(void)
+{
+  m_strXMLTVUrl   = g_strTvgPath;
+  m_strM3uUrl     = g_strM3UPath;
+  m_strLogoPath   = g_strLogoPath;
+  m_iEPGTimeShift = g_iEPGTimeShift;
+  m_bTSOverride   = g_bTSOverride;
+  m_iLastStart    = 0;
+  m_iLastEnd      = 0;
+
+  m_bEGPLoaded = false;
+
+  if (LoadPlayList())
+  {
+    XBMC->QueueNotification(QUEUE_INFO, "%d channels loaded.", m_channels.size());
+  }
+}
+
+void *PVRIptvData::Process(void)
+{
+  return NULL;
+}
+
+PVRIptvData::~PVRIptvData(void)
+{
+  m_channels.clear();
+  m_groups.clear();
+  m_epg.clear();
+}
+
+bool PVRIptvData::LoadEPG(time_t iStart, time_t iEnd) 
+{
+  if (m_strXMLTVUrl.IsEmpty())
+  {
+    XBMC->Log(LOG_NOTICE, "EPG file path is not configured. EPG not loaded.");
+    m_bEGPLoaded = true;
+    return false;
+  }
+
+  std::string data;
+  std::string decompressed;
+  int iReaded = 0;
+
+  int iCount = 0;
+  while(iCount < 3) // max 3 tries
+  {
+    if ((iReaded = GetCachedFileContents(TVG_FILE_NAME, m_strXMLTVUrl, data)) != 0) 
+    {
+      break;
+    }
+    XBMC->Log(LOG_ERROR, "Unable to load EPG file '%s':  file is missing or empty. :%dth try.", m_strXMLTVUrl.c_str(), ++iCount);
+    if (iCount < 3)
+    {
+      usleep(5 * 1000 * 1000); // sleep 5 sec before next try.
+    }
+  }
+  
+  if (iReaded == 0)
+  {
+    XBMC->Log(LOG_ERROR, "Unable to load EPG file '%s':  file is missing or empty. After %d tries.", m_strXMLTVUrl.c_str(), iCount);
+    m_bEGPLoaded = true;
+    return false;
+  }
+
+  char * buffer;
+
+  // gzip packed
+  if (data[0] == '\x1F' && data[1] == '\x8B' && data[2] == '\x08') 
+  {
+    if (!GzipInflate(data, decompressed))
+    {
+      XBMC->Log(LOG_ERROR, "Invalid EPG file '%s': unable to decompress file.", m_strXMLTVUrl.c_str());
+      m_bEGPLoaded = true;
+      return false;
+    }
+    buffer = &(decompressed[0]);
+  }
+  else
+  {
+    buffer = &(data[0]);
+  }
+
+  // xml should starts with '<?xml'
+  if (buffer[0] != '\x3C' || buffer[1] != '\x3F' || buffer[2] != '\x78' ||
+      buffer[3] != '\x6D' || buffer[4] != '\x6C')
+  {
+    // check for tar archive
+    if (strcmp(buffer + 0x101, "ustar") || strcmp(buffer + 0x101, "GNUtar"))
+    {
+      buffer += 0x200; // RECORDSIZE = 512
+    }
+    else
+    {
+      XBMC->Log(LOG_ERROR, "Invalid EPG file '%s': unable to decompress file.", m_strXMLTVUrl.c_str());
+      m_bEGPLoaded = true;
+      return false;
+    }
+  }
+
+  xml_document<> xmlDoc;
+  try 
+  {
+    xmlDoc.parse<0>(buffer);
+  } 
+  catch(parse_error p) 
+  {
+    XBMC->Log(LOG_ERROR, "Unable parse EPG XML: %s", p.what());
+    m_bEGPLoaded = true;
+    return false;
+  }
+
+  xml_node<> *pRootElement = xmlDoc.first_node("tv");
+  if (!pRootElement)
+  {
+    XBMC->Log(LOG_ERROR, "Invalid EPG XML: no <tv> tag found");
+    m_bEGPLoaded = true;
+    return false;
+  }
+
+  // clear previously loaded epg
+  if (m_epg.size() > 0) 
+  {
+    m_epg.clear();
+  }
+
+  int iBroadCastId = 0;
+  xml_node<> *pChannelNode = NULL;
+  for(pChannelNode = pRootElement->first_node("channel"); pChannelNode; pChannelNode = pChannelNode->next_sibling("channel"))
+  {
+    CStdString strName;
+    CStdString strId;
+    if(!GetAttributeValue(pChannelNode, "id", strId))
+    {
+      continue;
+    }
+    GetNodeValue(pChannelNode, "display-name", strName);
+
+    if (FindChannel(strId, strName) == NULL)
+    {
+      continue;
+    }
+
+    PVRIptvEpgChannel epgChannel;
+    epgChannel.strId = strId;
+    epgChannel.strName = strName;
+
+    m_epg.push_back(epgChannel);
+  }
+
+  if (m_epg.size() == 0) 
+  {
+    XBMC->Log(LOG_ERROR, "EPG channels not found.");
+    return false;
+  }
+  
+  int iMinShiftTime = m_iEPGTimeShift;
+  int iMaxShiftTime = m_iEPGTimeShift;
+  if (!m_bTSOverride)
+  {
+    iMinShiftTime = SECONDS_IN_DAY;
+    iMaxShiftTime = -SECONDS_IN_DAY;
+
+    vector<PVRIptvChannel>::iterator it;
+    for (it = m_channels.begin(); it < m_channels.end(); it++)
+    {
+      if (it->iTvgShift + m_iEPGTimeShift < iMinShiftTime)
+        iMinShiftTime = it->iTvgShift + m_iEPGTimeShift;
+      if (it->iTvgShift + m_iEPGTimeShift > iMaxShiftTime)
+        iMaxShiftTime = it->iTvgShift + m_iEPGTimeShift;
+    }
+  }
+
+  CStdString strEmpty = "";
+  PVRIptvEpgChannel *epg = NULL;
+  for(pChannelNode = pRootElement->first_node("programme"); pChannelNode; pChannelNode = pChannelNode->next_sibling("programme"))
+  {
+    CStdString strId;
+    if (!GetAttributeValue(pChannelNode, "channel", strId))
+      continue;
+
+    if (epg == NULL || epg->strId != strId) 
+    {
+      if ((epg = FindEpg(strId)) == NULL) 
+        continue;
+    }
+
+    CStdString strStart;
+    CStdString strStop;
+
+    if (!GetAttributeValue(pChannelNode, "start", strStart) || !GetAttributeValue(pChannelNode, "stop", strStop)) 
+    {
+      continue;
+    }
+
+    int iTmpStart = ParseDateTime(strStart);
+    int iTmpEnd = ParseDateTime(strStop);
+
+    if ((iTmpEnd + iMaxShiftTime < iStart) || (iTmpStart + iMinShiftTime > iEnd))
+    {
+      continue;
+    }
+
+    CStdString strTitle;
+    CStdString strCategory;
+    CStdString strDesc;
+
+    GetNodeValue(pChannelNode, "title", strTitle);
+    GetNodeValue(pChannelNode, "category", strCategory);
+    GetNodeValue(pChannelNode, "desc", strDesc);
+
+    PVRIptvEpgEntry entry;
+    entry.iBroadcastId    = ++iBroadCastId;
+    entry.iGenreType      = 0;
+    entry.iGenreSubType   = 0;
+    entry.strTitle        = strTitle;
+    entry.strPlot         = strDesc;
+    entry.strPlotOutline  = "";
+    entry.startTime       = iTmpStart;
+    entry.endTime         = iTmpEnd;
+    entry.strGenreString  = strCategory;
+
+    epg->epg.push_back(entry);
+  }
+
+  xmlDoc.clear();
+  m_bEGPLoaded = true;
+
+  XBMC->Log(LOG_NOTICE, "EPG Loaded.");
+
+  return true;
+}
+
+bool PVRIptvData::LoadPlayList(void) 
+{
+  if (m_strM3uUrl.IsEmpty())
+  {
+    XBMC->Log(LOG_NOTICE, "Playlist file path is not configured. Channels not loaded.");
+    return false;
+  }
+
+  CStdString strPlaylistContent;
+  if (!GetCachedFileContents(M3U_FILE_NAME, m_strM3uUrl, strPlaylistContent))
+  {
+    XBMC->Log(LOG_ERROR, "Unable to load playlist file '%s':  file is missing or empty.", m_strM3uUrl.c_str());
+    return false;
+  }
+
+  std::stringstream stream(strPlaylistContent);
+
+  /* load channels */
+  bool bFirst = true;
+
+  int iUniqueChannelId  = 0;
+  int iUniqueGroupId    = 0;
+  int iCurrentGroupId   = 0;
+  int iChannelNum       = 0;
+  int iEPGTimeShift     = 0;
+
+  PVRIptvChannel tmpChannel;
+  tmpChannel.strTvgId       = "";
+  tmpChannel.strChannelName = "";
+  tmpChannel.strTvgName     = "";
+  tmpChannel.strTvgLogo     = "";
+  tmpChannel.iTvgShift      = 0;
+
+  char szLine[1024];
+  while(stream.getline(szLine, 1024)) 
+  {
+  
+    CStdString strLine = "";
+    strLine.append(szLine);
+    strLine.TrimRight(" \t\r\n");
+    strLine.TrimLeft(" \t");
+
+    if (strLine.IsEmpty())
+    {
+      continue;
+    }
+
+    if (bFirst) 
+    {
+      bFirst = false;
+      if (strLine.Left(3) == "\xEF\xBB\xBF")
+      {
+        strLine.Delete(0, 3);
+      }
+      if (strLine.Left((int)strlen(M3U_START_MARKER)) == M3U_START_MARKER) 
+      {
+        double fTvgShift = atof(ReadMarkerValue(strLine, TVG_INFO_SHIFT_MARKER));
+        iEPGTimeShift = (int) (fTvgShift * 3600.0);
+        continue;
+      }
+      else
+      {
+        break;
+      }
+    }
+
+    if (strLine.Left((int)strlen(M3U_INFO_MARKER)) == M3U_INFO_MARKER) 
+    {
+      bool        bRadio       = false;
+      double      fTvgShift    = 0;
+      CStdString  strChnlName  = "";
+      CStdString  strTvgId     = "";
+      CStdString  strTvgName   = "";
+      CStdString  strTvgLogo   = "";
+      CStdString  strGroupName = "";
+      CStdString  strRadio     = "";
+
+      // parse line
+      int iColon = (int)strLine.Find(':');
+      int iComma = (int)strLine.ReverseFind(',');
+      if (iColon >= 0 && iComma >= 0 && iComma > iColon) 
+      {
+        // parse name
+        iComma++;
+        strChnlName = strLine.Right((int)strLine.size() - iComma).Trim();
+        tmpChannel.strChannelName = XBMC->UnknownToUTF8(strChnlName);
+
+        // parse info
+        CStdString strInfoLine = strLine.Mid(++iColon, --iComma - iColon);
+
+        strTvgId      = ReadMarkerValue(strInfoLine, TVG_INFO_ID_MARKER);
+        strTvgName    = ReadMarkerValue(strInfoLine, TVG_INFO_NAME_MARKER);
+        strTvgLogo    = ReadMarkerValue(strInfoLine, TVG_INFO_LOGO_MARKER);
+        strGroupName  = ReadMarkerValue(strInfoLine, GROUP_NAME_MARKER);
+        strRadio      = ReadMarkerValue(strInfoLine, RADIO_MARKER);
+        fTvgShift     = atof(ReadMarkerValue(strInfoLine, TVG_INFO_SHIFT_MARKER));
+
+        if (strTvgId.IsEmpty())
+        {
+          char buff[255];
+          sprintf(buff, "%d", atoi(strInfoLine));
+          strTvgId.append(buff);
+        }
+        if (strTvgLogo.IsEmpty())
+        {
+          strTvgLogo = strChnlName;
+        }
+
+        bRadio                = !strRadio.CompareNoCase("true");
+        tmpChannel.strTvgId   = strTvgId;
+        tmpChannel.strTvgName = XBMC->UnknownToUTF8(strTvgName);
+        tmpChannel.strTvgLogo = XBMC->UnknownToUTF8(strTvgLogo);
+        tmpChannel.iTvgShift  = (int)(fTvgShift * 3600.0);
+        tmpChannel.bRadio     = bRadio;
+
+        if (tmpChannel.iTvgShift == 0 && iEPGTimeShift != 0)
+        {
+          tmpChannel.iTvgShift = iEPGTimeShift;
+        }
+
+        if (!strGroupName.IsEmpty())
+        {
+          strGroupName = XBMC->UnknownToUTF8(strGroupName);
+
+          PVRIptvChannelGroup * pGroup;
+          if ((pGroup = FindGroup(strGroupName)) == NULL)
+          {
+            PVRIptvChannelGroup group;
+            group.strGroupName = strGroupName;
+            group.iGroupId = ++iUniqueGroupId;
+            group.bRadio = bRadio;
+
+            m_groups.push_back(group);
+            iCurrentGroupId = iUniqueGroupId;
+          }
+          else
+          {
+            iCurrentGroupId = pGroup->iGroupId;
+          }
+        }
+      }
+    } 
+    else if (strLine[0] != '#')
+    {
+      PVRIptvChannel channel;
+      channel.iUniqueId         = ++iUniqueChannelId;
+      channel.iChannelNumber    = ++iChannelNum;
+      channel.strTvgId          = tmpChannel.strTvgId;
+      channel.strChannelName    = tmpChannel.strChannelName;
+      channel.strTvgName        = tmpChannel.strTvgName;
+      channel.strTvgLogo        = tmpChannel.strTvgLogo;
+      channel.iTvgShift         = tmpChannel.iTvgShift;
+      channel.bRadio            = tmpChannel.bRadio;
+      channel.strStreamURL      = strLine;
+      channel.iEncryptionSystem = 0;
+
+      if (iCurrentGroupId > 0) 
+      {
+        channel.bRadio = m_groups.at(iCurrentGroupId - 1).bRadio;
+        m_groups.at(iCurrentGroupId - 1).members.push_back(channel.iChannelNumber);
+      }
+
+      m_channels.push_back(channel);
+
+      tmpChannel.strTvgId       = "";
+      tmpChannel.strChannelName = "";
+      tmpChannel.strTvgName     = "";
+      tmpChannel.strTvgLogo     = "";
+      tmpChannel.iTvgShift      = 0;
+      tmpChannel.bRadio         = false;
+    }
+  }
+  
+  stream.clear();
+
+  if (m_channels.size() == 0)
+  {
+    XBMC->Log(LOG_ERROR, "Unable to load channels from file '%s':  file is corrupted.", m_strM3uUrl.c_str());
+    return false;
+  }
+
+  ApplyChannelsLogos();
+
+  XBMC->Log(LOG_NOTICE, "Loaded %d channels.", m_channels.size());
+  return true;
+}
+
+int PVRIptvData::GetChannelsAmount(void)
+{
+  return m_channels.size();
+}
+
+PVR_ERROR PVRIptvData::GetChannels(ADDON_HANDLE handle, bool bRadio)
+{
+  for (unsigned int iChannelPtr = 0; iChannelPtr < m_channels.size(); iChannelPtr++)
+  {
+    PVRIptvChannel &channel = m_channels.at(iChannelPtr);
+    if (channel.bRadio == bRadio)
+    {
+      PVR_CHANNEL xbmcChannel;
+      memset(&xbmcChannel, 0, sizeof(PVR_CHANNEL));
+
+      xbmcChannel.iUniqueId         = channel.iUniqueId;
+      xbmcChannel.bIsRadio          = channel.bRadio;
+      xbmcChannel.iChannelNumber    = channel.iChannelNumber;
+      strncpy(xbmcChannel.strChannelName, channel.strChannelName.c_str(), sizeof(xbmcChannel.strChannelName) - 1);
+      strncpy(xbmcChannel.strStreamURL, channel.strStreamURL.c_str(), sizeof(xbmcChannel.strStreamURL) - 1);
+      xbmcChannel.iEncryptionSystem = channel.iEncryptionSystem;
+      strncpy(xbmcChannel.strIconPath, channel.strLogoPath.c_str(), sizeof(xbmcChannel.strIconPath) - 1);
+      xbmcChannel.bIsHidden         = false;
+
+      PVR->TransferChannelEntry(handle, &xbmcChannel);
+    }
+  }
+
+  return PVR_ERROR_NO_ERROR;
+}
+
+bool PVRIptvData::GetChannel(const PVR_CHANNEL &channel, PVRIptvChannel &myChannel)
+{
+  for (unsigned int iChannelPtr = 0; iChannelPtr < m_channels.size(); iChannelPtr++)
+  {
+    PVRIptvChannel &thisChannel = m_channels.at(iChannelPtr);
+    if (thisChannel.iUniqueId == (int) channel.iUniqueId)
+    {
+      myChannel.iUniqueId         = thisChannel.iUniqueId;
+      myChannel.bRadio            = thisChannel.bRadio;
+      myChannel.iChannelNumber    = thisChannel.iChannelNumber;
+      myChannel.iEncryptionSystem = thisChannel.iEncryptionSystem;
+      myChannel.strChannelName    = thisChannel.strChannelName;
+      myChannel.strLogoPath       = thisChannel.strLogoPath;
+      myChannel.strStreamURL      = thisChannel.strStreamURL;
+
+      return true;
+    }
+  }
+
+  return false;
+}
+
+int PVRIptvData::GetChannelGroupsAmount(void)
+{
+  return m_groups.size();
+}
+
+PVR_ERROR PVRIptvData::GetChannelGroups(ADDON_HANDLE handle, bool bRadio)
+{
+  for (unsigned int iGroupPtr = 0; iGroupPtr < m_groups.size(); iGroupPtr++)
+  {
+    PVRIptvChannelGroup &group = m_groups.at(iGroupPtr);
+    if (group.bRadio == bRadio)
+    {
+      PVR_CHANNEL_GROUP xbmcGroup;
+      memset(&xbmcGroup, 0, sizeof(PVR_CHANNEL_GROUP));
+
+      xbmcGroup.bIsRadio = bRadio;
+      strncpy(xbmcGroup.strGroupName, group.strGroupName.c_str(), sizeof(xbmcGroup.strGroupName) - 1);
+
+      PVR->TransferChannelGroup(handle, &xbmcGroup);
+    }
+  }
+
+  return PVR_ERROR_NO_ERROR;
+}
+
+PVR_ERROR PVRIptvData::GetChannelGroupMembers(ADDON_HANDLE handle, const PVR_CHANNEL_GROUP &group)
+{
+  for (unsigned int iGroupPtr = 0; iGroupPtr < m_groups.size(); iGroupPtr++)
+  {
+    PVRIptvChannelGroup &myGroup = m_groups.at(iGroupPtr);
+    if (!strcmp(myGroup.strGroupName.c_str(),group.strGroupName))
+    {
+      for (unsigned int iChannelPtr = 0; iChannelPtr < myGroup.members.size(); iChannelPtr++)
+      {
+        int iId = myGroup.members.at(iChannelPtr) - 1;
+        if (iId < 0 || iId > (int)m_channels.size() - 1)
+          continue;
+        PVRIptvChannel &channel = m_channels.at(iId);
+        PVR_CHANNEL_GROUP_MEMBER xbmcGroupMember;
+        memset(&xbmcGroupMember, 0, sizeof(PVR_CHANNEL_GROUP_MEMBER));
+
+        strncpy(xbmcGroupMember.strGroupName, group.strGroupName, sizeof(xbmcGroupMember.strGroupName) - 1);
+        xbmcGroupMember.iChannelUniqueId = channel.iUniqueId;
+        xbmcGroupMember.iChannelNumber   = channel.iChannelNumber;
+
+        PVR->TransferChannelGroupMember(handle, &xbmcGroupMember);
+      }
+    }
+  }
+
+  return PVR_ERROR_NO_ERROR;
+}
+
+PVR_ERROR PVRIptvData::GetEPGForChannel(ADDON_HANDLE handle, const PVR_CHANNEL &channel, time_t iStart, time_t iEnd)
+{
+  vector<PVRIptvChannel>::iterator myChannel;
+  for (myChannel = m_channels.begin(); myChannel < m_channels.end(); myChannel++)
+  {
+    if (myChannel->iUniqueId != (int) channel.iUniqueId)
+    {
+      continue;
+    }
+
+    if (!m_bEGPLoaded || 
+      iStart > m_iLastStart || iEnd > m_iLastEnd) 
+    {
+      if (LoadEPG(iStart, iEnd))
+      {
+        m_iLastStart = iStart;
+        m_iLastEnd = iEnd;
+      }
+    }
+
+    PVRIptvEpgChannel *epg;
+    if ((epg = FindEpgForChannel(*myChannel)) == NULL
+      || epg->epg.size() == 0)
+    {
+      return PVR_ERROR_NO_ERROR;
+    }
+
+    int iShift = m_bTSOverride ? m_iEPGTimeShift : myChannel->iTvgShift + m_iEPGTimeShift;
+
+    vector<PVRIptvEpgEntry>::iterator myTag;
+    for (myTag = epg->epg.begin(); myTag < epg->epg.end(); myTag++)
+    {
+      if ((myTag->endTime + iShift) < iStart) 
+        continue;
+
+      EPG_TAG tag;
+      memset(&tag, 0, sizeof(EPG_TAG));
+
+      tag.iUniqueBroadcastId  = myTag->iBroadcastId;
+      tag.strTitle            = myTag->strTitle.c_str();
+      tag.iChannelNumber      = myTag->iChannelId;
+      tag.startTime           = myTag->startTime + iShift;
+      tag.endTime             = myTag->endTime + iShift;
+      tag.strPlotOutline      = myTag->strPlotOutline.c_str();
+      tag.strPlot             = myTag->strPlot.c_str();
+      tag.strIconPath         = myTag->strIconPath.c_str();
+      tag.iGenreType          = EPG_GENRE_USE_STRING;        //myTag.iGenreType;
+      tag.iGenreSubType       = 0;                           //myTag.iGenreSubType;
+      tag.strGenreDescription = myTag->strGenreString.c_str();
+
+      PVR->TransferEpgEntry(handle, &tag);
+
+      if ((myTag->startTime + iShift) > iEnd)
+        break;
+    }
+
+    return PVR_ERROR_NO_ERROR;
+  }
+
+  return PVR_ERROR_NO_ERROR;
+}
+
+int PVRIptvData::GetFileContents(CStdString& url, std::string &strContent)
+{
+  strContent.clear();
+  void* fileHandle = XBMC->OpenFile(url.c_str(), 0);
+  if (fileHandle)
+  {
+    char buffer[1024];
+    while (int bytesRead = XBMC->ReadFile(fileHandle, buffer, 1024))
+      strContent.append(buffer, bytesRead);
+    XBMC->CloseFile(fileHandle);
+  }
+
+  return strContent.length();
+}
+
+int PVRIptvData::ParseDateTime(CStdString strDate, bool iDateFormat)
+{
+  struct tm timeinfo;
+  memset(&timeinfo, 0, sizeof(tm));
+
+  if (iDateFormat)
+  {
+    sscanf(strDate, "%04d%02d%02d%02d%02d%02d", &timeinfo.tm_year, &timeinfo.tm_mon, &timeinfo.tm_mday, &timeinfo.tm_hour, &timeinfo.tm_min, &timeinfo.tm_sec);
+  }
+  else
+  {
+    sscanf(strDate, "%02d.%02d.%04d%02d:%02d:%02d", &timeinfo.tm_mday, &timeinfo.tm_mon, &timeinfo.tm_year, &timeinfo.tm_hour, &timeinfo.tm_min, &timeinfo.tm_sec);
+  }
+
+  timeinfo.tm_mon  -= 1;
+  timeinfo.tm_year -= 1900;
+  timeinfo.tm_isdst = -1;
+
+  return mktime(&timeinfo);
+}
+
+PVRIptvChannel * PVRIptvData::FindChannel(const std::string &strId, const std::string &strName)
+{
+  CStdString strTvgName = strName;
+  strTvgName.Replace(' ', '_');
+
+  vector<PVRIptvChannel>::iterator it;
+  for(it = m_channels.begin(); it < m_channels.end(); it++)
+  {
+    if (it->strTvgId == strId)
+    {
+      return &*it;
+    }
+    if (strTvgName == "") 
+    {
+      continue;
+    }
+    if (it->strTvgName == strTvgName)
+    {
+      return &*it;
+    }
+    if (it->strChannelName == strName)
+    {
+      return &*it;
+    }
+  }
+
+  return NULL;
+}
+
+PVRIptvChannelGroup * PVRIptvData::FindGroup(const std::string &strName)
+{
+  vector<PVRIptvChannelGroup>::iterator it;
+  for(it = m_groups.begin(); it < m_groups.end(); it++)
+  {
+    if (it->strGroupName == strName)
+    {
+      return &*it;
+    }
+  }
+
+  return NULL;
+}
+
+PVRIptvEpgChannel * PVRIptvData::FindEpg(const std::string &strId)
+{
+  vector<PVRIptvEpgChannel>::iterator it;
+  for(it = m_epg.begin(); it < m_epg.end(); it++)
+  {
+    if (it->strId == strId)
+    {
+      return &*it;
+    }
+  }
+
+  return NULL;
+}
+
+PVRIptvEpgChannel * PVRIptvData::FindEpgForChannel(PVRIptvChannel &channel)
+{
+  vector<PVRIptvEpgChannel>::iterator it;
+  for(it = m_epg.begin(); it < m_epg.end(); it++)
+  {
+    if (it->strId == channel.strTvgId)
+    {
+      return &*it;
+    }
+    CStdString strName = it->strName;
+    strName.Replace(' ', '_');
+    if (strName == channel.strTvgName
+      || it->strName == channel.strTvgName)
+    {
+      return &*it;
+    }
+    if (it->strName == channel.strChannelName)
+    {
+      return &*it;
+    }
+  }
+
+  return NULL;
+}
+
+/*
+ * This method uses zlib to decompress a gzipped file in memory.
+ * Author: Andrew Lim Chong Liang
+ * http://windrealm.org
+ */
+bool PVRIptvData::GzipInflate( const std::string& compressedBytes, std::string& uncompressedBytes ) {  
+
+#define HANDLE_CALL_ZLIB(status) {  \
+  if(status != Z_OK) {              \
+    free(uncomp);                   \
+    return false;                   \
+  }                                 \
+}
+
+  if ( compressedBytes.size() == 0 ) 
+  {  
+    uncompressedBytes = compressedBytes ;  
+    return true ;  
+  }  
+  
+  uncompressedBytes.clear() ;  
+  
+  unsigned full_length = compressedBytes.size() ;  
+  unsigned half_length = compressedBytes.size() / 2;  
+  
+  unsigned uncompLength = full_length ;  
+  char* uncomp = (char*) calloc( sizeof(char), uncompLength );  
+  
+  z_stream strm;  
+  strm.next_in = (Bytef *) compressedBytes.c_str();  
+  strm.avail_in = compressedBytes.size() ;  
+  strm.total_out = 0;  
+  strm.zalloc = Z_NULL;  
+  strm.zfree = Z_NULL;  
+  
+  bool done = false ;  
+  
+  HANDLE_CALL_ZLIB(inflateInit2(&strm, (16+MAX_WBITS)));
+  
+  while (!done) 
+  {  
+    // If our output buffer is too small  
+    if (strm.total_out >= uncompLength ) 
+    {
+      // Increase size of output buffer  
+      uncomp = (char *) realloc(uncomp, uncompLength + half_length);
+      if (uncomp == NULL)
+        return false;
+      uncompLength += half_length ;  
+    }  
+  
+    strm.next_out = (Bytef *) (uncomp + strm.total_out);  
+    strm.avail_out = uncompLength - strm.total_out;  
+  
+    // Inflate another chunk.  
+    int err = inflate (&strm, Z_SYNC_FLUSH);  
+    if (err == Z_STREAM_END) 
+      done = true;  
+    else if (err != Z_OK)  
+    {  
+      break;  
+    }  
+  }  
+  
+  HANDLE_CALL_ZLIB(inflateEnd (&strm));
+  
+  for ( size_t i=0; i<strm.total_out; ++i ) 
+  {  
+    uncompressedBytes += uncomp[ i ];  
+  }  
+
+  free(uncomp);  
+  return true;  
+}  
+
+int PVRIptvData::GetCachedFileContents(const std::string &strCachedName, const std::string &filePath, std::string &strContents)
+{
+  bool bNeedReload = false;
+  CStdString strCachedPath = GetUserFilePath(strCachedName);
+  CStdString strFilePath = filePath;
+
+  if (XBMC->FileExists(strCachedPath, false)) 
+  {
+    struct __stat64 statCached;
+    struct __stat64 statOrig;
+
+    XBMC->StatFile(strCachedPath, &statCached);
+    XBMC->StatFile(strFilePath, &statOrig);
+
+    bNeedReload = statCached.st_mtime < statOrig.st_mtime;
+  } 
+  else 
+  {
+    bNeedReload = true;
+  }
+
+  if (bNeedReload) 
+  {
+    GetFileContents(strFilePath, strContents);
+    if (strContents.length() > 0) 
+    {
+      void* fileHandle = XBMC->OpenFileForWrite(strCachedPath, true);
+      if (fileHandle)
+      {
+        XBMC->WriteFile(fileHandle, strContents.c_str(), strContents.length());
+        XBMC->CloseFile(fileHandle);
+      }
+    }
+    return strContents.length();
+  } 
+
+  return GetFileContents(strCachedPath, strContents);
+}
+
+void PVRIptvData::ApplyChannelsLogos()
+{
+  if (m_strLogoPath.IsEmpty())
+  {
+    return;
+  }
+
+  vector<PVRIptvChannel>::iterator channel;
+  for(channel = m_channels.begin(); channel < m_channels.end(); channel++)
+  {
+    channel->strLogoPath = PathCombine(m_strLogoPath, channel->strTvgLogo);
+    channel->strLogoPath.append(CHANNEL_LOGO_EXTENSION);
+  }
+}
+
+void PVRIptvData::ReaplyChannelsLogos(const char * strNewPath)
+{
+  if (strlen(strNewPath) > 0)
+  {
+    m_strLogoPath = strNewPath;
+    ApplyChannelsLogos();
+
+    PVR->TriggerChannelUpdate();
+    PVR->TriggerChannelGroupsUpdate();
+  }
+}
+
+void PVRIptvData::ReloadEPG(const char * strNewPath)
+{
+  if (strNewPath != m_strXMLTVUrl)
+  {
+    m_strXMLTVUrl = strNewPath;
+    m_bEGPLoaded = false;
+    // TODO clear epg for all channels
+
+    if (LoadEPG(m_iLastStart, m_iLastEnd))
+    {
+      for(unsigned int iChannelPtr = 0, max = m_channels.size(); iChannelPtr < max; iChannelPtr++)
+      {
+        PVRIptvChannel &myChannel = m_channels.at(iChannelPtr);
+        PVR->TriggerEpgUpdate(myChannel.iUniqueId);
+      }
+    }
+  }
+}
+
+void PVRIptvData::ReloadPlayList(const char * strNewPath)
+{
+  if (strNewPath != m_strM3uUrl)
+  {
+    m_strM3uUrl = strNewPath;
+    m_channels.clear();
+
+    if (LoadPlayList())
+    {
+      PVR->TriggerChannelUpdate();
+      PVR->TriggerChannelGroupsUpdate();
+    }
+  }
+}
+
+CStdString PVRIptvData::ReadMarkerValue(std::string &strLine, const char* strMarkerName)
+{
+  int iMarkerStart = (int) strLine.find(strMarkerName);
+  if (iMarkerStart >= 0)
+  {
+    std::string strMarker = strMarkerName;
+    iMarkerStart += strMarker.length();
+    if (iMarkerStart < (int)strLine.length())
+    {
+      char cFind = ' ';
+      if (strLine[iMarkerStart] == '"')
+      {
+        cFind = '"';
+        iMarkerStart++;
+      }
+      int iMarkerEnd = (int)strLine.find(cFind, iMarkerStart);
+      if (iMarkerEnd < 0)
+      {
+        iMarkerEnd = strLine.length();
+      }
+      return strLine.substr(iMarkerStart, iMarkerEnd - iMarkerStart);
+    }
+  }
+
+  return std::string("");
+}
diff --git a/addons/pvr.iptvsimple/src/PVRIptvData.h b/addons/pvr.iptvsimple/src/PVRIptvData.h
new file mode 100644
index 0000000..944a734
--- /dev/null
+++ b/addons/pvr.iptvsimple/src/PVRIptvData.h
@@ -0,0 +1,122 @@
+#pragma once
+/*
+ *      Copyright (C) 2013 Anton Fedchin
+ *      http://github.com/afedchin/xbmc-addon-iptvsimple/
+ *
+ *      Copyright (C) 2011 Pulse-Eight
+ *      http://www.pulse-eight.com/
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include <vector>
+#include "platform/util/StdString.h"
+#include "client.h"
+#include "platform/threads/threads.h"
+
+struct PVRIptvEpgEntry
+{
+  int         iBroadcastId;
+  int         iChannelId;
+  int         iGenreType;
+  int         iGenreSubType;
+  time_t      startTime;
+  time_t      endTime;
+  std::string strTitle;
+  std::string strPlotOutline;
+  std::string strPlot;
+  std::string strIconPath;
+  std::string strGenreString;
+};
+
+struct PVRIptvEpgChannel
+{
+  std::string                  strId;
+  std::string                  strName;
+  std::vector<PVRIptvEpgEntry> epg;
+};
+
+struct PVRIptvChannel
+{
+  bool        bRadio;
+  int         iUniqueId;
+  int         iChannelNumber;
+  int         iEncryptionSystem;
+  int         iTvgShift;
+  std::string strChannelName;
+  std::string strLogoPath;
+  std::string strStreamURL;
+  std::string strTvgId;
+  std::string strTvgName;
+  std::string strTvgLogo;
+};
+
+struct PVRIptvChannelGroup
+{
+  bool              bRadio;
+  int               iGroupId;
+  std::string       strGroupName;
+  std::vector<int>  members;
+};
+
+class PVRIptvData : public PLATFORM::CThread
+{
+public:
+  PVRIptvData(void);
+  virtual ~PVRIptvData(void);
+
+  virtual int       GetChannelsAmount(void);
+  virtual PVR_ERROR GetChannels(ADDON_HANDLE handle, bool bRadio);
+  virtual bool      GetChannel(const PVR_CHANNEL &channel, PVRIptvChannel &myChannel);
+  virtual int       GetChannelGroupsAmount(void);
+  virtual PVR_ERROR GetChannelGroups(ADDON_HANDLE handle, bool bRadio);
+  virtual PVR_ERROR GetChannelGroupMembers(ADDON_HANDLE handle, const PVR_CHANNEL_GROUP &group);
+  virtual PVR_ERROR GetEPGForChannel(ADDON_HANDLE handle, const PVR_CHANNEL &channel, time_t iStart, time_t iEnd);
+  virtual void      ReaplyChannelsLogos(const char * strNewPath);
+  virtual void      ReloadPlayList(const char * strNewPath);
+  virtual void      ReloadEPG(const char * strNewPath);
+
+protected:
+  virtual bool                 LoadPlayList(void);
+  virtual bool                 LoadEPG(time_t iStart, time_t iEnd);
+  virtual int                  GetFileContents(CStdString& url, std::string &strContent);
+  virtual PVRIptvChannel      *FindChannel(const std::string &strId, const std::string &strName);
+  virtual PVRIptvChannelGroup *FindGroup(const std::string &strName);
+  virtual PVRIptvEpgChannel   *FindEpg(const std::string &strId);
+  virtual PVRIptvEpgChannel   *FindEpgForChannel(PVRIptvChannel &channel);
+  virtual int                  ParseDateTime(CStdString strDate, bool iDateFormat = true);
+  virtual bool                 GzipInflate( const std::string &compressedBytes, std::string &uncompressedBytes);
+  virtual int                  GetCachedFileContents(const std::string &strCachedName, const std::string &strFilePath, std::string &strContent);
+  virtual void                 ApplyChannelsLogos();
+  virtual CStdString           ReadMarkerValue(std::string &strLine, const char * strMarkerName);
+
+protected:
+  virtual void *Process(void);
+
+private:
+  bool                              m_bTSOverride;
+  bool                              m_bEGPLoaded;
+  int                               m_iEPGTimeShift;
+  int                               m_iLastStart;
+  int                               m_iLastEnd;
+  CStdString                        m_strXMLTVUrl;
+  CStdString                        m_strM3uUrl;
+  CStdString                        m_strLogoPath;
+  std::vector<PVRIptvChannelGroup>  m_groups;
+  std::vector<PVRIptvChannel>       m_channels;
+  std::vector<PVRIptvEpgChannel>    m_epg;
+};
diff --git a/addons/pvr.iptvsimple/src/client.cpp b/addons/pvr.iptvsimple/src/client.cpp
new file mode 100644
index 0000000..b80f483
--- /dev/null
+++ b/addons/pvr.iptvsimple/src/client.cpp
@@ -0,0 +1,438 @@
+/*
+ *      Copyright (C) 2013 Anton Fedchin
+ *      http://github.com/afedchin/xbmc-addon-iptvsimple/
+ *
+ *      Copyright (C) 2011 Pulse-Eight
+ *      http://www.pulse-eight.com/
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include "client.h"
+#include "xbmc_pvr_dll.h"
+#include "PVRIptvData.h"
+#include "platform/util/util.h"
+
+using namespace std;
+using namespace ADDON;
+
+#ifdef TARGET_WINDOWS
+#define snprintf _snprintf
+#endif
+
+bool           m_bCreated       = false;
+ADDON_STATUS   m_CurStatus      = ADDON_STATUS_UNKNOWN;
+PVRIptvData   *m_data           = NULL;
+bool           m_bIsPlaying     = false;
+PVRIptvChannel m_currentChannel;
+
+/* User adjustable settings are saved here.
+ * Default values are defined inside client.h
+ * and exported to the other source files.
+ */
+std::string g_strUserPath   = "";
+std::string g_strClientPath = "";
+
+CHelper_libXBMC_addon *XBMC = NULL;
+CHelper_libXBMC_pvr   *PVR  = NULL;
+
+std::string g_strTvgPath    = "";
+std::string g_strM3UPath    = "";
+std::string g_strLogoPath   = "";
+int         g_iEPGTimeShift = 0;
+bool        g_bTSOverride   = true;
+
+extern std::string PathCombine(const std::string &strPath, const std::string &strFileName)
+{
+  std::string strResult = strPath;
+  if (strResult.at(strResult.size() - 1) == '\\' ||
+      strResult.at(strResult.size() - 1) == '/') 
+  {
+    strResult.append(strFileName);
+  }
+  else 
+  {
+    strResult.append("/");
+    strResult.append(strFileName);
+  }
+
+  return strResult;
+}
+
+extern std::string GetClientFilePath(const std::string &strFileName)
+{
+  return PathCombine(g_strClientPath, strFileName);
+}
+
+extern std::string GetUserFilePath(const std::string &strFileName)
+{
+  return PathCombine(g_strUserPath, strFileName);
+}
+
+extern "C" {
+
+void ADDON_ReadSettings(void)
+{
+  char buffer[1024];
+  int iPathType = 0;
+  if (!XBMC->GetSetting("m3uPathType", &iPathType)) 
+  {
+    iPathType = 1;
+  }
+  CStdString strSettingName = iPathType ? "m3uUrl" : "m3uPath";
+  if (XBMC->GetSetting(strSettingName, &buffer)) 
+  {
+    g_strM3UPath = buffer;
+  }
+  if (g_strM3UPath == "") 
+  {
+    g_strM3UPath = GetClientFilePath(M3U_FILE_NAME);
+  }
+
+  if (!XBMC->GetSetting("epgPathType", &iPathType)) 
+  {
+    iPathType = 1;
+  }
+  strSettingName = iPathType ? "epgUrl" : "epgPath";
+  if (XBMC->GetSetting(strSettingName, &buffer)) 
+  {
+    g_strTvgPath = buffer;
+  }
+  // BUG! xbmc does not return slider value 
+  //float dTimeShift;
+  //if (XBMC->GetSetting("epgTimeShift", &dTimeShift))
+  //{
+  //  g_iEPGTimeShift = (int)(dTimeShift * 3600.0); // hours to seconds
+  //}
+  int itmpShift;
+  if (XBMC->GetSetting("epgTimeShift_", &itmpShift))
+  {
+    itmpShift -= 12;
+    g_iEPGTimeShift = (int)(itmpShift * 3600.0); // hours to seconds
+  }
+  if (!XBMC->GetSetting("epgTSOverride", &g_bTSOverride))
+  {
+    g_bTSOverride = true;
+  }
+    
+  if (XBMC->GetSetting("logoPath", &buffer))
+  {
+    g_strLogoPath = buffer;
+  }
+  if (g_strLogoPath == "")
+  {
+    g_strLogoPath = GetClientFilePath("icons/");
+  }
+}
+
+ADDON_STATUS ADDON_Create(void* hdl, void* props)
+{
+  if (!hdl || !props)
+  {
+    return ADDON_STATUS_UNKNOWN;
+  }
+
+  PVR_PROPERTIES* pvrprops = (PVR_PROPERTIES*)props;
+
+  XBMC = new CHelper_libXBMC_addon;
+  if (!XBMC->RegisterMe(hdl))
+  {
+    SAFE_DELETE(XBMC);
+    return ADDON_STATUS_PERMANENT_FAILURE;
+  }
+
+  PVR = new CHelper_libXBMC_pvr;
+  if (!PVR->RegisterMe(hdl))
+  {
+    SAFE_DELETE(PVR);
+    SAFE_DELETE(XBMC);
+    return ADDON_STATUS_PERMANENT_FAILURE;
+  }
+
+  XBMC->Log(LOG_DEBUG, "%s - Creating the PVR IPTV Simple add-on", __FUNCTION__);
+
+  m_CurStatus     = ADDON_STATUS_UNKNOWN;
+  g_strUserPath   = pvrprops->strUserPath;
+  g_strClientPath = pvrprops->strClientPath;
+
+  if (!XBMC->DirectoryExists(g_strUserPath.c_str()))
+  {
+#ifdef TARGET_WINDOWS
+    CreateDirectory(g_strUserPath.c_str(), NULL);
+#else
+    XBMC->CreateDirectory(g_strUserPath.c_str());
+#endif
+  }
+
+  ADDON_ReadSettings();
+
+  m_data = new PVRIptvData;
+  m_CurStatus = ADDON_STATUS_OK;
+  m_bCreated = true;
+
+  return m_CurStatus;
+}
+
+ADDON_STATUS ADDON_GetStatus()
+{
+  return m_CurStatus;
+}
+
+void ADDON_Destroy()
+{
+  delete m_data;
+  m_bCreated = false;
+  m_CurStatus = ADDON_STATUS_UNKNOWN;
+}
+
+bool ADDON_HasSettings()
+{
+  return true;
+}
+
+unsigned int ADDON_GetSettings(ADDON_StructSetting ***sSet)
+{
+  return 0;
+}
+
+ADDON_STATUS ADDON_SetSetting(const char *settingName, const void *settingValue)
+{
+  // reset cache and restart addon 
+
+  string strFile = GetUserFilePath(M3U_FILE_NAME);
+  if (XBMC->FileExists(strFile.c_str(), false))
+  {
+#ifdef TARGET_WINDOWS
+    DeleteFile(strFile.c_str());
+#else
+    XBMC->DeleteFile(strFile.c_str());
+#endif
+  }
+
+  strFile = GetUserFilePath(TVG_FILE_NAME);
+  if (XBMC->FileExists(strFile.c_str(), false))
+  {
+#ifdef TARGET_WINDOWS
+    DeleteFile(strFile.c_str());
+#else
+    XBMC->DeleteFile(strFile.c_str());
+#endif
+  }
+
+  return ADDON_STATUS_NEED_RESTART;
+}
+
+void ADDON_Stop()
+{
+}
+
+void ADDON_FreeSettings()
+{
+}
+
+void ADDON_Announce(const char *flag, const char *sender, const char *message, const void *data)
+{
+}
+
+/***********************************************************
+ * PVR Client AddOn specific public library functions
+ ***********************************************************/
+
+const char* GetPVRAPIVersion(void)
+{
+  static const char *strApiVersion = XBMC_PVR_API_VERSION;
+  return strApiVersion;
+}
+
+const char* GetMininumPVRAPIVersion(void)
+{
+  static const char *strMinApiVersion = XBMC_PVR_MIN_API_VERSION;
+  return strMinApiVersion;
+}
+
+PVR_ERROR GetAddonCapabilities(PVR_ADDON_CAPABILITIES* pCapabilities)
+{
+  pCapabilities->bSupportsEPG             = true;
+  pCapabilities->bSupportsTV              = true;
+  pCapabilities->bSupportsRadio           = true;
+  pCapabilities->bSupportsChannelGroups   = true;
+  pCapabilities->bSupportsRecordings      = false;
+
+  return PVR_ERROR_NO_ERROR;
+}
+
+const char *GetBackendName(void)
+{
+  static const char *strBackendName = "IPTV Simple PVR Add-on";
+  return strBackendName;
+}
+
+const char *GetBackendVersion(void)
+{
+  static CStdString strBackendVersion = PVR_CLIENT_VERSION;
+  return strBackendVersion.c_str();
+}
+
+const char *GetConnectionString(void)
+{
+  static CStdString strConnectionString = "connected";
+  return strConnectionString.c_str();
+}
+
+PVR_ERROR GetDriveSpace(long long *iTotal, long long *iUsed)
+{
+  *iTotal = 0;
+  *iUsed  = 0;
+  return PVR_ERROR_NO_ERROR;
+}
+
+PVR_ERROR GetEPGForChannel(ADDON_HANDLE handle, const PVR_CHANNEL &channel, time_t iStart, time_t iEnd)
+{
+  if (m_data)
+    return m_data->GetEPGForChannel(handle, channel, iStart, iEnd);
+
+  return PVR_ERROR_SERVER_ERROR;
+}
+
+int GetChannelsAmount(void)
+{
+  if (m_data)
+    return m_data->GetChannelsAmount();
+
+  return -1;
+}
+
+PVR_ERROR GetChannels(ADDON_HANDLE handle, bool bRadio)
+{
+  if (m_data)
+    return m_data->GetChannels(handle, bRadio);
+
+  return PVR_ERROR_SERVER_ERROR;
+}
+
+bool OpenLiveStream(const PVR_CHANNEL &channel)
+{
+  if (m_data)
+  {
+    CloseLiveStream();
+
+    if (m_data->GetChannel(channel, m_currentChannel))
+    {
+      m_bIsPlaying = true;
+      return true;
+    }
+  }
+
+  return false;
+}
+
+void CloseLiveStream(void)
+{
+  m_bIsPlaying = false;
+}
+
+int GetCurrentClientChannel(void)
+{
+  return m_currentChannel.iUniqueId;
+}
+
+bool SwitchChannel(const PVR_CHANNEL &channel)
+{
+  CloseLiveStream();
+
+  return OpenLiveStream(channel);
+}
+
+PVR_ERROR GetStreamProperties(PVR_STREAM_PROPERTIES* pProperties)
+{
+  return PVR_ERROR_NOT_IMPLEMENTED;
+}
+
+int GetChannelGroupsAmount(void)
+{
+  if (m_data)
+    return m_data->GetChannelGroupsAmount();
+
+  return -1;
+}
+
+PVR_ERROR GetChannelGroups(ADDON_HANDLE handle, bool bRadio)
+{
+  if (m_data)
+    return m_data->GetChannelGroups(handle, bRadio);
+
+  return PVR_ERROR_SERVER_ERROR;
+}
+
+PVR_ERROR GetChannelGroupMembers(ADDON_HANDLE handle, const PVR_CHANNEL_GROUP &group)
+{
+  if (m_data)
+    return m_data->GetChannelGroupMembers(handle, group);
+
+  return PVR_ERROR_SERVER_ERROR;
+}
+
+PVR_ERROR SignalStatus(PVR_SIGNAL_STATUS &signalStatus)
+{
+  snprintf(signalStatus.strAdapterName, sizeof(signalStatus.strAdapterName), "IPTV Simple Adapter 1");
+  snprintf(signalStatus.strAdapterStatus, sizeof(signalStatus.strAdapterStatus), "OK");
+
+  return PVR_ERROR_NO_ERROR;
+}
+
+/** UNUSED API FUNCTIONS */
+const char * GetLiveStreamURL(const PVR_CHANNEL &channel)  { return ""; }
+bool CanPauseStream(void) { return false; }
+int GetRecordingsAmount(void) { return -1; }
+PVR_ERROR GetRecordings(ADDON_HANDLE handle) { return PVR_ERROR_NOT_IMPLEMENTED; }
+PVR_ERROR DialogChannelScan(void) { return PVR_ERROR_NOT_IMPLEMENTED; }
+PVR_ERROR CallMenuHook(const PVR_MENUHOOK &menuhook) { return PVR_ERROR_NOT_IMPLEMENTED; }
+PVR_ERROR DeleteChannel(const PVR_CHANNEL &channel) { return PVR_ERROR_NOT_IMPLEMENTED; }
+PVR_ERROR RenameChannel(const PVR_CHANNEL &channel) { return PVR_ERROR_NOT_IMPLEMENTED; }
+PVR_ERROR MoveChannel(const PVR_CHANNEL &channel) { return PVR_ERROR_NOT_IMPLEMENTED; }
+PVR_ERROR DialogChannelSettings(const PVR_CHANNEL &channel) { return PVR_ERROR_NOT_IMPLEMENTED; }
+PVR_ERROR DialogAddChannel(const PVR_CHANNEL &channel) { return PVR_ERROR_NOT_IMPLEMENTED; }
+bool OpenRecordedStream(const PVR_RECORDING &recording) { return false; }
+void CloseRecordedStream(void) {}
+int ReadRecordedStream(unsigned char *pBuffer, unsigned int iBufferSize) { return 0; }
+long long SeekRecordedStream(long long iPosition, int iWhence /* = SEEK_SET */) { return 0; }
+long long PositionRecordedStream(void) { return -1; }
+long long LengthRecordedStream(void) { return 0; }
+void DemuxReset(void) {}
+void DemuxFlush(void) {}
+int ReadLiveStream(unsigned char *pBuffer, unsigned int iBufferSize) { return 0; }
+long long SeekLiveStream(long long iPosition, int iWhence /* = SEEK_SET */) { return -1; }
+long long PositionLiveStream(void) { return -1; }
+long long LengthLiveStream(void) { return -1; }
+PVR_ERROR DeleteRecording(const PVR_RECORDING &recording) { return PVR_ERROR_NOT_IMPLEMENTED; }
+PVR_ERROR RenameRecording(const PVR_RECORDING &recording) { return PVR_ERROR_NOT_IMPLEMENTED; }
+PVR_ERROR SetRecordingPlayCount(const PVR_RECORDING &recording, int count) { return PVR_ERROR_NOT_IMPLEMENTED; }
+PVR_ERROR SetRecordingLastPlayedPosition(const PVR_RECORDING &recording, int lastplayedposition) { return PVR_ERROR_NOT_IMPLEMENTED; }
+int GetRecordingLastPlayedPosition(const PVR_RECORDING &recording) { return -1; }
+int GetTimersAmount(void) { return -1; }
+PVR_ERROR GetTimers(ADDON_HANDLE handle) { return PVR_ERROR_NOT_IMPLEMENTED; }
+PVR_ERROR AddTimer(const PVR_TIMER &timer) { return PVR_ERROR_NOT_IMPLEMENTED; }
+PVR_ERROR DeleteTimer(const PVR_TIMER &timer, bool bForceDelete) { return PVR_ERROR_NOT_IMPLEMENTED; }
+PVR_ERROR UpdateTimer(const PVR_TIMER &timer) { return PVR_ERROR_NOT_IMPLEMENTED; }
+void DemuxAbort(void) {}
+DemuxPacket* DemuxRead(void) { return NULL; }
+unsigned int GetChannelSwitchDelay(void) { return 0; }
+void PauseStream(bool bPaused) {}
+bool CanSeekStream(void) { return false; }
+bool SeekTime(int,bool,double*) { return false; }
+void SetSpeed(int) {};
+}
diff --git a/addons/pvr.iptvsimple/src/client.h b/addons/pvr.iptvsimple/src/client.h
new file mode 100644
index 0000000..bc81eeb
--- /dev/null
+++ b/addons/pvr.iptvsimple/src/client.h
@@ -0,0 +1,54 @@
+#pragma once
+/*
+ *      Copyright (C) 2013 Anton Fedchin
+ *      http://github.com/afedchin/xbmc-addon-iptvsimple/
+ *
+ *      Copyright (C) 2011 Pulse-Eight
+ *      http://www.pulse-eight.com/
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include "libXBMC_addon.h"
+#include "libXBMC_pvr.h"
+#include "libXBMC_gui.h"
+
+#define PVR_CLIENT_VERSION     "0.1.3"
+#define M3U_FILE_NAME          "iptv.m3u.cache"
+#define TVG_FILE_NAME          "xmltv.xml.cache"
+
+/*!
+ * @brief PVR macros for string exchange
+ */
+#define PVR_STRCPY(dest, source) do { strncpy(dest, source, sizeof(dest)-1); dest[sizeof(dest)-1] = '\0'; } while(0)
+#define PVR_STRCLR(dest) memset(dest, 0, sizeof(dest))
+
+extern bool                          m_bCreated;
+extern std::string                   g_strUserPath;
+extern std::string                   g_strClientPath;
+extern ADDON::CHelper_libXBMC_addon *XBMC;
+extern CHelper_libXBMC_pvr          *PVR;
+
+extern std::string g_strM3UPath;
+extern std::string g_strTvgPath;
+extern std::string g_strLogoPath;
+extern int         g_iEPGTimeShift;
+extern bool        g_bTSOverride;
+
+extern std::string PathCombine(const std::string &strPath, const std::string &strFileName);
+extern std::string GetClientFilePath(const std::string &strFileName);
+extern std::string GetUserFilePath(const std::string &strFileName);
diff --git a/configure.ac b/configure.ac
index 8ced892..b0de4a6 100644
--- a/configure.ac
+++ b/configure.ac
@@ -167,10 +167,19 @@ if test "$build_addons_with_dependencies" = "yes"; then
     AC_DEFINE([HAVE_BOOST],[1],["Define to 1 if we have the `boost' headers"])
   fi
   echo "Boost: $use_boost"
+
+  AC_CHECK_LIB([z],[inflate], use_zlib=yes, use_zlib=no)
+  if test "$use_zlib" = "yes"; then
+    AC_DEFINE([HAVE_ZLIB],[1],["Define to 1 if we have the zlib library"])
+    ZLIB_LIBS='-lz'
+    AC_SUBST(ZLIB_LIBS)
+  fi
+  echo "Zlib: $use_zlib"
 fi
 
 ### Addons with dependencies
 AM_CONDITIONAL([ADDON_MYTHTV], [test "$build_addons_with_dependencies" = "yes" -a "$use_mysql" = "yes" -a "$use_boost" = "yes"])
+AM_CONDITIONAL([ADDON_IPTVSIMPLE], [test "$build_addons_with_dependencies" = "yes" -a "$use_zlib" = "yes"])
 
 ### Check for Intree building
 if test "x${cross_compiling}" = "xyes" || test "x${cross_compiling}" = "xmaybe"; then
@@ -272,6 +281,7 @@ AC_CONFIG_FILES([Makefile \
                  addons/pvr.vuplus/Makefile \
                  addons/pvr.vdr.vnsi/Makefile \
                  addons/pvr.mythtv.cmyth/Makefile \
+                 addons/pvr.iptvsimple/Makefile \
                  addons/pvr.argustv/addon/addon.xml
                  addons/pvr.demo/addon/addon.xml
                  addons/pvr.dvbviewer/addon/addon.xml
@@ -281,6 +291,7 @@ AC_CONFIG_FILES([Makefile \
                  addons/pvr.nextpvr/addon/addon.xml
                  addons/pvr.njoy/addon/addon.xml
                  addons/pvr.vdr.vnsi/addon/addon.xml
-                 addons/pvr.vuplus/addon/addon.xml])
+                 addons/pvr.vuplus/addon/addon.xml
+                 addons/pvr.iptvsimple/addon/addon.xml])
 
 AC_OUTPUT
diff --git a/lib/rapidxml/license.txt b/lib/rapidxml/license.txt
new file mode 100644
index 0000000..1409831
--- /dev/null
+++ b/lib/rapidxml/license.txt
@@ -0,0 +1,52 @@
+Use of this software is granted under one of the following two licenses,
+to be chosen freely by the user.
+
+1. Boost Software License - Version 1.0 - August 17th, 2003
+===============================================================================
+
+Copyright (c) 2006, 2007 Marcin Kalicinski
+
+Permission is hereby granted, free of charge, to any person or organization
+obtaining a copy of the software and accompanying documentation covered by
+this license (the "Software") to use, reproduce, display, distribute,
+execute, and transmit the Software, and to prepare derivative works of the
+Software, and to permit third-parties to whom the Software is furnished to
+do so, all subject to the following:
+
+The copyright notices in the Software and this entire statement, including
+the above license grant, this restriction and the following disclaimer,
+must be included in all copies of the Software, in whole or in part, and
+all derivative works of the Software, unless such copies or derivative
+works are solely in the form of machine-executable object code generated by
+a source language processor.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
+SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
+FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
+ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+DEALINGS IN THE SOFTWARE.
+
+2. The MIT License
+===============================================================================
+
+Copyright (c) 2006, 2007 Marcin Kalicinski
+
+Permission is hereby granted, free of charge, to any person obtaining a copy 
+of this software and associated documentation files (the "Software"), to deal 
+in the Software without restriction, including without limitation the rights 
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies 
+of the Software, and to permit persons to whom the Software is furnished to do so, 
+subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all 
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL 
+THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, 
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
+IN THE SOFTWARE.
diff --git a/lib/rapidxml/manual.html b/lib/rapidxml/manual.html
new file mode 100644
index 0000000..2c42270
--- /dev/null
+++ b/lib/rapidxml/manual.html
@@ -0,0 +1,406 @@
+<html><head><style type="text/css">
+
+          body
+          {
+          font-family: sans-serif;
+          font-size: 90%;
+          margin: 8pt 8pt 8pt 8pt;
+          text-align: justify;
+          background-color: White;
+          }
+
+          h1 { font-weight: bold; text-align: left;  }
+          h2 { font: 140% sans-serif; font-weight: bold; text-align: left;  }
+          h3 { font: 120% sans-serif; font-weight: bold; text-align: left;  }
+          h4 { font: bold 100% sans-serif; font-weight: bold; text-align: left;  }
+          h5 { font: italic 100% sans-serif; font-weight: bold; text-align: left;  }
+          h6 { font: small-caps 100% sans-serif; font-weight: bold; text-align: left;  }
+
+          code
+          {
+          font-family: &quot;Courier New&quot;, Courier, mono;
+          }
+
+          pre
+          {
+          border-top: gray 0.5pt solid;
+          border-right: gray 0.5pt solid;
+          border-left: gray 0.5pt solid;
+          border-bottom: gray 0.5pt solid;
+          padding-top: 2pt;
+          padding-right: 2pt;
+          padding-left: 2pt;
+          padding-bottom: 2pt;
+          display: block;
+          font-family: &quot;courier new&quot;, courier, mono;
+          background-color: #eeeeee;
+          }
+
+          a
+          {
+          color: #000080;
+          text-decoration: none;
+          }
+
+          a:hover
+          {
+          text-decoration: underline;
+          }
+
+          .reference-header
+          {
+          border-top: gray 0.5pt solid;
+          border-right: gray 0.5pt solid;
+          border-left: gray 0.5pt solid;
+          border-bottom: gray 0.5pt solid;
+          padding-top: 2pt;
+          padding-right: 2pt;
+          padding-left: 2pt;
+          padding-bottom: 2pt;
+          background-color: #dedede;
+          }
+
+          .parameter-name
+          {
+          font-style: italic;
+          }
+
+          .indented
+          {
+          margin-left: 0.5cm;
+          }
+
+          a.toc1
+          {
+          margin-left: 0.0cm;
+          }
+
+          a.toc2
+          {
+          margin-left: 0.75cm;
+          }
+
+          a.toc3
+          {
+          margin-left: 1.5cm;
+          }
+
+        </style></head><body><h1>RAPIDXML Manual</h1><h3>Version 1.13</h3><detaileddescription xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><para><i>Copyright (C) 2006, 2009 Marcin Kalicinski</i><br/><i>See accompanying file <a href="license.txt">license.txt</a> for license information.</i><hr/><h2 level="2">Table of Contents</h2></para><para><toc><toc-contents><a href="#namespacerapidxml_1what_is_rapidxml" class="toc1">1. What is RapidXml?</a><br/><a href="#namespacerapidxml_1dependencies_and_compatibility" class="toc2">1.1 Dependencies And Compatibility</a><br/><a href="#namespacerapidxml_1character_types_and_encodings" class="toc2">1.2 Character Types And Encodings</a><br/><a href="#namespacerapidxml_1error_handling" class="toc2">1.3 Error Handling</a><br/><a href="#namespacerapidxml_1memory_allocation" class="toc2">1.4 Memory Allocation</a><br/><a href="#namespacerapidxml_1w3c_compliance" class="toc2">1.5 W3C Compliance</a><br/><a href="#namespacerapidxml_1api_design" class="toc2">1.6 API Design</a><br/><a href="#namespacerapidxml_1reliability" class="toc2">1.7 Reliability</a><br/><a href="#namespacerapidxml_1acknowledgements" class="toc2">1.8 Acknowledgements</a><br/><a href="#namespacerapidxml_1two_minute_tutorial" class="toc1">2. Two Minute Tutorial</a><br/><a href="#namespacerapidxml_1parsing" class="toc2">2.1 Parsing</a><br/><a href="#namespacerapidxml_1accessing_dom_tree" class="toc2">2.2 Accessing The DOM Tree</a><br/><a href="#namespacerapidxml_1modifying_dom_tree" class="toc2">2.3 Modifying The DOM Tree</a><br/><a href="#namespacerapidxml_1printing" class="toc2">2.4 Printing XML</a><br/><a href="#namespacerapidxml_1differences" class="toc1">3. Differences From Regular XML Parsers</a><br/><a href="#namespacerapidxml_1lifetime_of_source_text" class="toc2">3.1 Lifetime Of Source Text</a><br/><a href="#namespacerapidxml_1ownership_of_strings" class="toc2">3.2 Ownership Of Strings</a><br/><a href="#namespacerapidxml_1destructive_non_destructive" class="toc2">3.3 Destructive Vs Non-Destructive Mode</a><br/><a href="#namespacerapidxml_1performance" class="toc1">4. Performance</a><br/><a href="#namespacerapidxml_1performance_charts" class="toc2">4.1 Comparison With Other Parsers</a><br/><a href="#namespacerapidxml_1reference" class="toc1">5. Reference</a><br/></toc-contents></toc><br/></para><sect1><h2 id="namespacerapidxml_1what_is_rapidxml">1. What is RapidXml?</h2><para><a href="http://rapidxml.sourceforge.net">RapidXml</a> is an attempt to create the fastest XML DOM parser possible, while retaining useability, portability and reasonable W3C compatibility. It is an in-situ parser written in C++, with parsing speed approaching that of <code>strlen()</code> function executed on the same data. <br/><br/>
+ Entire parser is contained in a single header file, so no building or linking is neccesary. To use it you just need to copy <code>rapidxml.hpp</code> file to a convenient place (such as your project directory), and include it where needed. You may also want to use printing functions contained in header <code>rapidxml_print.hpp</code>.</para><sect2><h3 id="namespacerapidxml_1dependencies_and_compatibility">1.1 Dependencies And Compatibility</h3><para>RapidXml has <i>no dependencies</i> other than a very small subset of standard C++ library (<code>&lt;cassert&gt;</code>, <code>&lt;cstdlib&gt;</code>, <code>&lt;new&gt;</code> and <code>&lt;exception&gt;</code>, unless exceptions are disabled). It should compile on any reasonably conformant compiler, and was tested on Visual C++ 2003, Visual C++ 2005, Visual C++ 2008, gcc 3, gcc 4, and Comeau 4.3.3. Care was taken that no warnings are produced on these compilers, even with highest warning levels enabled.</para></sect2><sect2><h3 id="namespacerapidxml_1character_types_and_encodings">1.2 Character Types And Encodings</h3><para>RapidXml is character type agnostic, and can work both with narrow and wide characters. Current version does not fully support UTF-16 or UTF-32, so use of wide characters is somewhat incapacitated. However, it should succesfully parse <code>wchar_t</code> strings containing UTF-16 or UTF-32 if endianness of the data matches that of the machine. UTF-8 is fully supported, including all numeric character references, which are expanded into appropriate UTF-8 byte sequences (unless you enable parse_no_utf8 flag). <br/><br/>
+ Note that RapidXml performs no decoding - strings returned by name() and value() functions will contain text encoded using the same encoding as source file. Rapidxml understands and expands the following character references: <code>&amp;apos; &amp;amp; &amp;quot; &amp;lt; &amp;gt; &amp;#...;</code> Other character references are not expanded.</para></sect2><sect2><h3 id="namespacerapidxml_1error_handling">1.3 Error Handling</h3><para>By default, RapidXml uses C++ exceptions to report errors. If this behaviour is undesirable, RAPIDXML_NO_EXCEPTIONS can be defined to suppress exception code. See <a href="#classrapidxml_1_1parse__error" kindref="compound">parse_error</a> class and <a href="#namespacerapidxml_ff5d67f74437199d316d2b2660653ae1_1ff5d67f74437199d316d2b2660653ae1" kindref="member">parse_error_handler()</a> function for more information.</para></sect2><sect2><h3 id="namespacerapidxml_1memory_allocation">1.4 Memory Allocation</h3><para>RapidXml uses a special memory pool object to allocate nodes and attributes, because direct allocation using <code>new</code> operator would be far too slow. Underlying memory allocations performed by the pool can be customized by use of <a href="#classrapidxml_1_1memory__pool_c0a55a6ef0837dca67572e357100d78a_1c0a55a6ef0837dca67572e357100d78a" kindref="member">memory_pool::set_allocator()</a> function. See class <a href="#classrapidxml_1_1memory__pool" kindref="compound">memory_pool</a> for more information.</para></sect2><sect2><h3 id="namespacerapidxml_1w3c_compliance">1.5 W3C Compliance</h3><para>RapidXml is not a W3C compliant parser, primarily because it ignores DOCTYPE declarations. There is a number of other, minor incompatibilities as well. Still, it can successfully parse and produce complete trees of all valid XML files in W3C conformance suite (over 1000 files specially designed to find flaws in XML processors). In destructive mode it performs whitespace normalization and character entity substitution for a small set of built-in entities.</para></sect2><sect2><h3 id="namespacerapidxml_1api_design">1.6 API Design</h3><para>RapidXml API is minimalistic, to reduce code size as much as possible, and facilitate use in embedded environments. Additional convenience functions are provided in separate headers: <code>rapidxml_utils.hpp</code> and <code><a href="#rapidxml__print_8hpp" kindref="compound">rapidxml_print.hpp</a></code>. Contents of these headers is not an essential part of the library, and is currently not documented (otherwise than with comments in code).</para></sect2><sect2><h3 id="namespacerapidxml_1reliability">1.7 Reliability</h3><para>RapidXml is very robust and comes with a large harness of unit tests. Special care has been taken to ensure stability of the parser no matter what source text is thrown at it. One of the unit tests produces 100,000 randomly corrupted variants of XML document, which (when uncorrupted) contains all constructs recognized by RapidXml. RapidXml passes this test when it correctly recognizes that errors have been introduced, and does not crash or loop indefinitely. <br/><br/>
+ Another unit test puts RapidXml head-to-head with another, well estabilished XML parser, and verifies that their outputs match across a wide variety of small and large documents. <br/><br/>
+ Yet another test feeds RapidXml with over 1000 test files from W3C compliance suite, and verifies that correct results are obtained. There are also additional tests that verify each API function separately, and test that various parsing modes work as expected.</para></sect2><sect2><h3 id="namespacerapidxml_1acknowledgements">1.8 Acknowledgements</h3><para>I would like to thank Arseny Kapoulkine for his work on <a href="http://code.google.com/p/pugixml">pugixml</a>, which was an inspiration for this project. Additional thanks go to Kristen Wegner for creating <a href="http://www.codeproject.com/soap/pugxml.asp">pugxml</a>, from which pugixml was derived. Janusz Wohlfeil kindly ran RapidXml speed tests on hardware that I did not have access to, allowing me to expand performance comparison table.</para></sect2></sect1><sect1><h2 id="namespacerapidxml_1two_minute_tutorial">2. Two Minute Tutorial</h2><sect2><h3 id="namespacerapidxml_1parsing">2.1 Parsing</h3><para>The following code causes RapidXml to parse a zero-terminated string named <code>text</code>: <pre>using namespace rapidxml;
+xml_document&lt;&gt; doc;    // character type defaults to char
+doc.parse&lt;0&gt;(text);    // 0 means default parse flags
+</pre><code>doc</code> object is now a root of DOM tree containing representation of the parsed XML. Because all RapidXml interface is contained inside namespace <code>rapidxml</code>, users must either bring contents of this namespace into scope, or fully qualify all the names. Class <a href="#classrapidxml_1_1xml__document" kindref="compound">xml_document</a> represents a root of the DOM hierarchy. By means of public inheritance, it is also an <a href="#classrapidxml_1_1xml__node" kindref="compound">xml_node</a> and a <a href="#classrapidxml_1_1memory__pool" kindref="compound">memory_pool</a>. Template parameter of <a href="#classrapidxml_1_1xml__document_8338ce6042e7b04d5a42144fb446b69c_18338ce6042e7b04d5a42144fb446b69c" kindref="member">xml_document::parse()</a> function is used to specify parsing flags, with which you can fine-tune behaviour of the parser. Note that flags must be a compile-time constant.</para></sect2><sect2><h3 id="namespacerapidxml_1accessing_dom_tree">2.2 Accessing The DOM Tree</h3><para>To access the DOM tree, use methods of <a href="#classrapidxml_1_1xml__node" kindref="compound">xml_node</a> and <a href="#classrapidxml_1_1xml__attribute" kindref="compound">xml_attribute</a> classes: <pre>cout &lt;&lt; &quot;Name of my first node is: &quot; &lt;&lt; doc.first_node()-&gt;name() &lt;&lt; &quot;\n&quot;;
+xml_node&lt;&gt; *node = doc.first_node(&quot;foobar&quot;);
+cout &lt;&lt; &quot;Node foobar has value &quot; &lt;&lt; node-&gt;value() &lt;&lt; &quot;\n&quot;;
+for (xml_attribute&lt;&gt; *attr = node-&gt;first_attribute();
+     attr; attr = attr-&gt;next_attribute())
+{
+    cout &lt;&lt; &quot;Node foobar has attribute &quot; &lt;&lt; attr-&gt;name() &lt;&lt; &quot; &quot;;
+    cout &lt;&lt; &quot;with value &quot; &lt;&lt; attr-&gt;value() &lt;&lt; &quot;\n&quot;;
+}
+</pre></para></sect2><sect2><h3 id="namespacerapidxml_1modifying_dom_tree">2.3 Modifying The DOM Tree</h3><para>DOM tree produced by the parser is fully modifiable. Nodes and attributes can be added/removed, and their contents changed. The below example creates a HTML document, whose sole contents is a link to google.com website: <pre>xml_document&lt;&gt; doc;
+xml_node&lt;&gt; *node = doc.allocate_node(node_element, &quot;a&quot;, &quot;Google&quot;);
+doc.append_node(node);
+xml_attribute&lt;&gt; *attr = doc.allocate_attribute(&quot;href&quot;, &quot;google.com&quot;);
+node-&gt;append_attribute(attr);
+</pre> One quirk is that nodes and attributes <i>do not own</i> the text of their names and values. This is because normally they only store pointers to the source text. So, when assigning a new name or value to the node, care must be taken to ensure proper lifetime of the string. The easiest way to achieve it is to allocate the string from the <a href="#classrapidxml_1_1xml__document" kindref="compound">xml_document</a> memory pool. In the above example this is not necessary, because we are only assigning character constants. But the code below uses <a href="#classrapidxml_1_1memory__pool_69729185bc59b0875192d667c47b8859_169729185bc59b0875192d667c47b8859" kindref="member">memory_pool::allocate_string()</a> function to allocate node name (which will have the same lifetime as the document), and assigns it to a new node: <pre>xml_document&lt;&gt; doc;
+char *node_name = doc.allocate_string(name);        // Allocate string and copy name into it
+xml_node&lt;&gt; *node = doc.allocate_node(node_element, node_name);  // Set node name to node_name
+</pre> Check <a href="#namespacerapidxml_1reference" kindref="member">Reference</a>  section for description of the entire interface.</para></sect2><sect2><h3 id="namespacerapidxml_1printing">2.4 Printing XML</h3><para>You can print <code><a href="#classrapidxml_1_1xml__document" kindref="compound">xml_document</a></code> and <code><a href="#classrapidxml_1_1xml__node" kindref="compound">xml_node</a></code> objects into an XML string. Use <a href="#namespacerapidxml_b94d570fc4c4ab2423813cd0243326b1_1b94d570fc4c4ab2423813cd0243326b1" kindref="member">print()</a> function or operator &lt;&lt;, which are defined in <code><a href="#rapidxml__print_8hpp" kindref="compound">rapidxml_print.hpp</a></code> header. <pre>using namespace rapidxml;
+xml_document&lt;&gt; doc;    // character type defaults to char
+// ... some code to fill the document
+
+// Print to stream using operator &lt;&lt;
+std::cout &lt;&lt; doc;   
+
+// Print to stream using print function, specifying printing flags
+print(std::cout, doc, 0);   // 0 means default printing flags
+
+// Print to string using output iterator
+std::string s;
+print(std::back_inserter(s), doc, 0);
+
+// Print to memory buffer using output iterator
+char buffer[4096];                      // You are responsible for making the buffer large enough!
+char *end = print(buffer, doc, 0);      // end contains pointer to character after last printed character
+*end = 0;                               // Add string terminator after XML
+</pre></para></sect2></sect1><sect1><h2 id="namespacerapidxml_1differences">3. Differences From Regular XML Parsers</h2><para>RapidXml is an <i>in-situ parser</i>, which allows it to achieve very high parsing speed. In-situ means that parser does not make copies of strings. Instead, it places pointers to the <i>source text</i> in the DOM hierarchy.</para><sect2><h3 id="namespacerapidxml_1lifetime_of_source_text">3.1 Lifetime Of Source Text</h3><para>In-situ parsing requires that source text lives at least as long as the document object. If source text is destroyed, names and values of nodes in DOM tree will become destroyed as well. Additionally, whitespace processing, character entity translation, and zero-termination of strings require that source text be modified during parsing (but see non-destructive mode). This makes the text useless for further processing once it was parsed by RapidXml. <br/><br/>
+ In many cases however, these are not serious issues.</para></sect2><sect2><h3 id="namespacerapidxml_1ownership_of_strings">3.2 Ownership Of Strings</h3><para>Nodes and attributes produced by RapidXml do not own their name and value strings. They merely hold the pointers to them. This means you have to be careful when setting these values manually, by using <a href="#classrapidxml_1_1xml__base_e099c291e104a0d277307fe71f5e0f9e_1e099c291e104a0d277307fe71f5e0f9e" kindref="member">xml_base::name(const Ch *)</a> or <a href="#classrapidxml_1_1xml__base_18c7469acdca771de9b4f3054053029c_118c7469acdca771de9b4f3054053029c" kindref="member">xml_base::value(const Ch *)</a> functions. Care must be taken to ensure that lifetime of the string passed is at least as long as lifetime of the node/attribute. The easiest way to achieve it is to allocate the string from <a href="#classrapidxml_1_1memory__pool" kindref="compound">memory_pool</a> owned by the document. Use <a href="#classrapidxml_1_1memory__pool_69729185bc59b0875192d667c47b8859_169729185bc59b0875192d667c47b8859" kindref="member">memory_pool::allocate_string()</a> function for this purpose.</para></sect2><sect2><h3 id="namespacerapidxml_1destructive_non_destructive">3.3 Destructive Vs Non-Destructive Mode</h3><para>By default, the parser modifies source text during the parsing process. This is required to achieve character entity translation, whitespace normalization, and zero-termination of strings. <br/><br/>
+ In some cases this behaviour may be undesirable, for example if source text resides in read only memory, or is mapped to memory directly from file. By using appropriate parser flags (parse_non_destructive), source text modifications can be disabled. However, because RapidXml does in-situ parsing, it obviously has the following side-effects:<ul><li><para>no whitespace normalization is done</para></li><li><para>no entity reference translation is done</para></li><li><para>names and values are not zero-terminated, you must use <a href="#classrapidxml_1_1xml__base_0dae694c8f7e4d89f1003e2f3a15a43c_10dae694c8f7e4d89f1003e2f3a15a43c" kindref="member">xml_base::name_size()</a> and <a href="#classrapidxml_1_1xml__base_aed5ae791b7164c1ee5e649198cbb3db_1aed5ae791b7164c1ee5e649198cbb3db" kindref="member">xml_base::value_size()</a> functions to tell where they end</para></li></ul></para></sect2></sect1><sect1><h2 id="namespacerapidxml_1performance">4. Performance</h2><para>RapidXml achieves its speed through use of several techniques:<ul><li><para>In-situ parsing. When building DOM tree, RapidXml does not make copies of string data, such as node names and values. Instead, it stores pointers to interior of the source text.</para></li><li><para>Use of template metaprogramming techniques. This allows it to move much of the work to compile time. Through magic of the templates, C++ compiler generates a separate copy of parsing code for any combination of parser flags you use. In each copy, all possible decisions are made at compile time and all unused code is omitted.</para></li><li><para>Extensive use of lookup tables for parsing.</para></li><li><para>Hand-tuned C++ with profiling done on several most popular CPUs.</para></li></ul></para><para>This results in a very small and fast code: a parser which is custom tailored to exact needs with each invocation.</para><sect2><h3 id="namespacerapidxml_1performance_charts">4.1 Comparison With Other Parsers</h3><para>The table below compares speed of RapidXml to some other parsers, and to <code>strlen()</code> function executed on the same data. On a modern CPU (as of 2007), you can expect parsing throughput to be close to 1 GB/s. As a rule of thumb, parsing speed is about 50-100x faster than Xerces DOM, 30-60x faster than TinyXml, 3-12x faster than pugxml, and about 5% - 30% faster than pugixml, the fastest XML parser I know of.</para><para><ul><li><para>The test file is a real-world, 50kB large, moderately dense XML file. </para></li><li><para>All timing is done by using RDTSC instruction present in Pentium-compatible CPUs. </para></li><li><para>No profile-guided optimizations are used. </para></li><li><para>All parsers are running in their fastest modes. </para></li><li><para>The results are given in CPU cycles per character, so frequency of CPUs is irrelevant. </para></li><li><para>The results are minimum values from a large number of runs, to minimize effects of operating system activity, task switching, interrupt handling etc. </para></li><li><para>A single parse of the test file takes about 1/10th of a millisecond, so with large number of runs there is a good chance of hitting at least one no-interrupt streak, and obtaining undisturbed results. </para></li></ul><table rows="9" cols="7" border="1" cellpadding="3pt"><tr><th thead="yes"><para><center>Platform</center></para></th><th thead="yes"><para><center>Compiler</center></para></th><th thead="yes"><para>strlen() </para></th><th thead="yes"><para>RapidXml </para></th><th thead="yes"><para>pugixml 0.3 </para></th><th thead="yes"><para>pugxml </para></th><th thead="yes"><para>TinyXml  </para></th></tr><tr><td thead="no"><para><center>Pentium 4</center></para></td><td thead="no"><para><center>MSVC 8.0</center></para></td><td thead="no"><para><center>2.5</center></para></td><td thead="no"><para><center>5.4</center></para></td><td thead="no"><para><center>7.0</center></para></td><td thead="no"><para><center>61.7</center></para></td><td thead="no"><para><center>298.8</center></para></td></tr><tr><td thead="no"><para><center>Pentium 4</center></para></td><td thead="no"><para><center>gcc 4.1.1</center></para></td><td thead="no"><para><center>0.8</center></para></td><td thead="no"><para><center>6.1</center></para></td><td thead="no"><para><center>9.5</center></para></td><td thead="no"><para><center>67.0</center></para></td><td thead="no"><para><center>413.2</center></para></td></tr><tr><td thead="no"><para><center>Core 2</center></para></td><td thead="no"><para><center>MSVC 8.0</center></para></td><td thead="no"><para><center>1.0</center></para></td><td thead="no"><para><center>4.5</center></para></td><td thead="no"><para><center>5.0</center></para></td><td thead="no"><para><center>24.6</center></para></td><td thead="no"><para><center>154.8</center></para></td></tr><tr><td thead="no"><para><center>Core 2</center></para></td><td thead="no"><para><center>gcc 4.1.1</center></para></td><td thead="no"><para><center>0.6</center></para></td><td thead="no"><para><center>4.6</center></para></td><td thead="no"><para><center>5.4</center></para></td><td thead="no"><para><center>28.3</center></para></td><td thead="no"><para><center>229.3</center></para></td></tr><tr><td thead="no"><para><center>Athlon XP</center></para></td><td thead="no"><para><center>MSVC 8.0</center></para></td><td thead="no"><para><center>3.1</center></para></td><td thead="no"><para><center>7.7</center></para></td><td thead="no"><para><center>8.0</center></para></td><td thead="no"><para><center>25.5</center></para></td><td thead="no"><para><center>182.6</center></para></td></tr><tr><td thead="no"><para><center>Athlon XP</center></para></td><td thead="no"><para><center>gcc 4.1.1</center></para></td><td thead="no"><para><center>0.9</center></para></td><td thead="no"><para><center>8.2</center></para></td><td thead="no"><para><center>9.2</center></para></td><td thead="no"><para><center>33.7</center></para></td><td thead="no"><para><center>265.2</center></para></td></tr><tr><td thead="no"><para><center>Pentium 3</center></para></td><td thead="no"><para><center>MSVC 8.0</center></para></td><td thead="no"><para><center>2.0</center></para></td><td thead="no"><para><center>6.3</center></para></td><td thead="no"><para><center>7.0</center></para></td><td thead="no"><para><center>30.9</center></para></td><td thead="no"><para><center>211.9</center></para></td></tr><tr><td thead="no"><para><center>Pentium 3</center></para></td><td thead="no"><para><center>gcc 4.1.1</center></para></td><td thead="no"><para><center>1.0</center></para></td><td thead="no"><para><center>6.7</center></para></td><td thead="no"><para><center>8.9</center></para></td><td thead="no"><para><center>35.3</center></para></td><td thead="no"><para><center>316.0</center></para></td></tr></table><i>(*) All results are in CPU cycles per character of source text</i></para></sect2></sect1><sect1><h2 id="namespacerapidxml_1reference">5. Reference</h2><para>This section lists all classes, functions, constants etc. and describes them in detail. </para></sect1></detaileddescription><dl><dt>class
+								  template
+							   <a href="#classrapidxml_1_1memory__pool">rapidxml::memory_pool</a></dt><dt class="indented">
+				constructor
+			 <a href="#classrapidxml_1_1memory__pool_f8fb3c8f1a564f8045c40bcd07a89866_1f8fb3c8f1a564f8045c40bcd07a89866">memory_pool()</a></dt><dt class="indented">
+				destructor
+			 <a href="#classrapidxml_1_1memory__pool_6f8c7990d9ec1ed2acf6558b238570eb_16f8c7990d9ec1ed2acf6558b238570eb">~memory_pool()</a></dt><dt class="indented">function <a href="#classrapidxml_1_1memory__pool_750ba3c610b129ac057d817509d08f41_1750ba3c610b129ac057d817509d08f41">allocate_node(node_type type, const Ch *name=0, const Ch *value=0, std::size_t name_size=0, std::size_t value_size=0)</a></dt><dt class="indented">function <a href="#classrapidxml_1_1memory__pool_462de142669e0ff649e8e615b82bf457_1462de142669e0ff649e8e615b82bf457">allocate_attribute(const Ch *name=0, const Ch *value=0, std::size_t name_size=0, std::size_t value_size=0)</a></dt><dt class="indented">function <a href="#classrapidxml_1_1memory__pool_69729185bc59b0875192d667c47b8859_169729185bc59b0875192d667c47b8859">allocate_string(const Ch *source=0, std::size_t size=0)</a></dt><dt class="indented">function <a href="#classrapidxml_1_1memory__pool_95c49fcb056e9103ec906a59e3e01d76_195c49fcb056e9103ec906a59e3e01d76">clone_node(const xml_node&lt; Ch &gt; *source, xml_node&lt; Ch &gt; *result=0)</a></dt><dt class="indented">function <a href="#classrapidxml_1_1memory__pool_c8bb3912a3ce86b15842e79d0b421204_1c8bb3912a3ce86b15842e79d0b421204">clear()</a></dt><dt class="indented">function <a href="#classrapidxml_1_1memory__pool_c0a55a6ef0837dca67572e357100d78a_1c0a55a6ef0837dca67572e357100d78a">set_allocator(alloc_func *af, free_func *ff)</a></dt><dt class="indented"/><dt class="indented"/><dt class="indented"/><dt class="indented"/><dt class="indented"/><dt class="indented"/><dt class="indented"/><dt class="indented"/><dt class="indented"/><dt class="indented"/><p/><p/><dt>class <a href="#classrapidxml_1_1parse__error">rapidxml::parse_error</a></dt><dt class="indented">
+				constructor
+			 <a href="#classrapidxml_1_1parse__error_4dd8d1bdbd9221df4dcb90cafaee3332_14dd8d1bdbd9221df4dcb90cafaee3332">parse_error(const char *what, void *where)</a></dt><dt class="indented">function <a href="#classrapidxml_1_1parse__error_ff06f49065b54a8a86e02e9a2441a8ba_1ff06f49065b54a8a86e02e9a2441a8ba">what() const </a></dt><dt class="indented">function <a href="#classrapidxml_1_1parse__error_377be7d201d95221c318682c35377aca_1377be7d201d95221c318682c35377aca">where() const </a></dt><dt class="indented"/><dt class="indented"/><p/><dt>class
+								  template
+							   <a href="#classrapidxml_1_1xml__attribute">rapidxml::xml_attribute</a></dt><dt class="indented">
+				constructor
+			 <a href="#classrapidxml_1_1xml__attribute_d5464aadf08269a886b730993525db34_1d5464aadf08269a886b730993525db34">xml_attribute()</a></dt><dt class="indented">function <a href="#classrapidxml_1_1xml__attribute_77aea7d8d996ba4f6bd61cc478a4e72d_177aea7d8d996ba4f6bd61cc478a4e72d">document() const </a></dt><dt class="indented">function <a href="#classrapidxml_1_1xml__attribute_5c4a98d2b75f9b41b12c110108fd55ab_15c4a98d2b75f9b41b12c110108fd55ab">previous_attribute(const Ch *name=0, std::size_t name_size=0, bool case_sensitive=true) const </a></dt><dt class="indented">function <a href="#classrapidxml_1_1xml__attribute_1b8a814d0d3a7165396b08433eee8a91_11b8a814d0d3a7165396b08433eee8a91">next_attribute(const Ch *name=0, std::size_t name_size=0, bool case_sensitive=true) const </a></dt><dt class="indented"/><dt class="indented"/><dt class="indented"/><p/><dt>class
+								  template
+							   <a href="#classrapidxml_1_1xml__base">rapidxml::xml_base</a></dt><dt class="indented">
+				constructor
+			 <a href="#classrapidxml_1_1xml__base_23630d2c130a9e0e3f3afa7584a9b218_123630d2c130a9e0e3f3afa7584a9b218">xml_base()</a></dt><dt class="indented">function <a href="#classrapidxml_1_1xml__base_622eade29fdf7806d3ef93ac4d90e707_1622eade29fdf7806d3ef93ac4d90e707">name() const </a></dt><dt class="indented">function <a href="#classrapidxml_1_1xml__base_0dae694c8f7e4d89f1003e2f3a15a43c_10dae694c8f7e4d89f1003e2f3a15a43c">name_size() const </a></dt><dt class="indented">function <a href="#classrapidxml_1_1xml__base_c54fa4987fb503916a7b541eb15c9c7f_1c54fa4987fb503916a7b541eb15c9c7f">value() const </a></dt><dt class="indented">function <a href="#classrapidxml_1_1xml__base_aed5ae791b7164c1ee5e649198cbb3db_1aed5ae791b7164c1ee5e649198cbb3db">value_size() const </a></dt><dt class="indented">function <a href="#classrapidxml_1_1xml__base_4e7e23d06d48126c65b1f6266acfba5c_14e7e23d06d48126c65b1f6266acfba5c">name(const Ch *name, std::size_t size)</a></dt><dt class="indented">function <a href="#classrapidxml_1_1xml__base_e099c291e104a0d277307fe71f5e0f9e_1e099c291e104a0d277307fe71f5e0f9e">name(const Ch *name)</a></dt><dt class="indented">function <a href="#classrapidxml_1_1xml__base_d9640aa3f5374673cb72a5289b6c91eb_1d9640aa3f5374673cb72a5289b6c91eb">value(const Ch *value, std::size_t size)</a></dt><dt class="indented">function <a href="#classrapidxml_1_1xml__base_18c7469acdca771de9b4f3054053029c_118c7469acdca771de9b4f3054053029c">value(const Ch *value)</a></dt><dt class="indented">function <a href="#classrapidxml_1_1xml__base_798e8df7ea53ade4d9f0701017dce80e_1798e8df7ea53ade4d9f0701017dce80e">parent() const </a></dt><dt class="indented"/><dt class="indented"/><dt class="indented"/><dt class="indented"/><dt class="indented"/><dt class="indented"/><p/><dt>class
+								  template
+							   <a href="#classrapidxml_1_1xml__document">rapidxml::xml_document</a></dt><dt class="indented">
+				constructor
+			 <a href="#classrapidxml_1_1xml__document_6ce266cc52d549c42abe3a3d5e8af9ba_16ce266cc52d549c42abe3a3d5e8af9ba">xml_document()</a></dt><dt class="indented">function <a href="#classrapidxml_1_1xml__document_8338ce6042e7b04d5a42144fb446b69c_18338ce6042e7b04d5a42144fb446b69c">parse(Ch *text)</a></dt><dt class="indented">function <a href="#classrapidxml_1_1xml__document_c8bb3912a3ce86b15842e79d0b421204_1c8bb3912a3ce86b15842e79d0b421204">clear()</a></dt><dt class="indented"/><dt class="indented"/><dt class="indented"/><dt class="indented"/><dt class="indented"/><dt class="indented"/><dt class="indented"/><dt class="indented"/><dt class="indented"/><dt class="indented"/><dt class="indented"/><dt class="indented"/><dt class="indented"/><dt class="indented"/><p/><p/><p/><p/><p/><p/><p/><p/><p/><dt>class
+								  template
+							   <a href="#classrapidxml_1_1xml__node">rapidxml::xml_node</a></dt><dt class="indented">
+				constructor
+			 <a href="#classrapidxml_1_1xml__node_34c55af3504549a475e5b9dfcaa6adf5_134c55af3504549a475e5b9dfcaa6adf5">xml_node(node_type type)</a></dt><dt class="indented">function <a href="#classrapidxml_1_1xml__node_975e86937621ae4afe6a423219de30d0_1975e86937621ae4afe6a423219de30d0">type() const </a></dt><dt class="indented">function <a href="#classrapidxml_1_1xml__node_77aea7d8d996ba4f6bd61cc478a4e72d_177aea7d8d996ba4f6bd61cc478a4e72d">document() const </a></dt><dt class="indented">function <a href="#classrapidxml_1_1xml__node_7823e36687669e59c2afdf66334ef35a_17823e36687669e59c2afdf66334ef35a">first_node(const Ch *name=0, std::size_t name_size=0, bool case_sensitive=true) const </a></dt><dt class="indented">function <a href="#classrapidxml_1_1xml__node_fcb6e2209b591a36d2dadba20d2bc7cc_1fcb6e2209b591a36d2dadba20d2bc7cc">last_node(const Ch *name=0, std::size_t name_size=0, bool case_sensitive=true) const </a></dt><dt class="indented">function <a href="#classrapidxml_1_1xml__node_ac2f6886c0107e9d5f156e9542546df6_1ac2f6886c0107e9d5f156e9542546df6">previous_sibling(const Ch *name=0, std::size_t name_size=0, bool case_sensitive=true) const </a></dt><dt class="indented">function <a href="#classrapidxml_1_1xml__node_b3ead2cefecc03a813836203e3f6f38f_1b3ead2cefecc03a813836203e3f6f38f">next_sibling(const Ch *name=0, std::size_t name_size=0, bool case_sensitive=true) const </a></dt><dt class="indented">function <a href="#classrapidxml_1_1xml__node_5810a09f82f8d53efbe9456286dcec83_15810a09f82f8d53efbe9456286dcec83">first_attribute(const Ch *name=0, std::size_t name_size=0, bool case_sensitive=true) const </a></dt><dt class="indented">function <a href="#classrapidxml_1_1xml__node_16953d66751b5b949ee4ee2d9c0bc63a_116953d66751b5b949ee4ee2d9c0bc63a">last_attribute(const Ch *name=0, std::size_t name_size=0, bool case_sensitive=true) const </a></dt><dt class="indented">function <a href="#classrapidxml_1_1xml__node_a78759bfa429fa2ab6bc5fe617cfa3cf_1a78759bfa429fa2ab6bc5fe617cfa3cf">type(node_type type)</a></dt><dt class="indented">function <a href="#classrapidxml_1_1xml__node_0c39df6617e709eb2fba11300dea63f2_10c39df6617e709eb2fba11300dea63f2">prepend_node(xml_node&lt; Ch &gt; *child)</a></dt><dt class="indented">function <a href="#classrapidxml_1_1xml__node_86de2e22276826089b7baed2599f8dee_186de2e22276826089b7baed2599f8dee">append_node(xml_node&lt; Ch &gt; *child)</a></dt><dt class="indented">function <a href="#classrapidxml_1_1xml__node_780972a57fc447250ab47cc8f421b65e_1780972a57fc447250ab47cc8f421b65e">insert_node(xml_node&lt; Ch &gt; *where, xml_node&lt; Ch &gt; *child)</a></dt><dt class="indented">function <a href="#classrapidxml_1_1xml__node_9a31d861e1bddc710839c551a5d2b3a4_19a31d861e1bddc710839c551a5d2b3a4">remove_first_node()</a></dt><dt class="indented">function <a href="#classrapidxml_1_1xml__node_87addf2bc127ee31aa4b5295d3c9b530_187addf2bc127ee31aa4b5295d3c9b530">remove_last_node()</a></dt><dt class="indented">function <a href="#classrapidxml_1_1xml__node_9316463a2201631e7e2062b17729f9cd_19316463a2201631e7e2062b17729f9cd">remove_node(xml_node&lt; Ch &gt; *where)</a></dt><dt class="indented">function <a href="#classrapidxml_1_1xml__node_0218147d13e41d5fa60ced4e7a7e9726_10218147d13e41d5fa60ced4e7a7e9726">remove_all_nodes()</a></dt><dt class="indented">function <a href="#classrapidxml_1_1xml__node_f6dffa513da74cc0be71a7ba84f8265e_1f6dffa513da74cc0be71a7ba84f8265e">prepend_attribute(xml_attribute&lt; Ch &gt; *attribute)</a></dt><dt class="indented">function <a href="#classrapidxml_1_1xml__node_8fbd4f5ef7169d493da9f8d87ac04b77_18fbd4f5ef7169d493da9f8d87ac04b77">append_attribute(xml_attribute&lt; Ch &gt; *attribute)</a></dt><dt class="indented">function <a href="#classrapidxml_1_1xml__node_070d5888b0557fe06a5b24961de1b988_1070d5888b0557fe06a5b24961de1b988">insert_attribute(xml_attribute&lt; Ch &gt; *where, xml_attribute&lt; Ch &gt; *attribute)</a></dt><dt class="indented">function <a href="#classrapidxml_1_1xml__node_4eea4a7f6cb484ca9944f7eafe6e1843_14eea4a7f6cb484ca9944f7eafe6e1843">remove_first_attribute()</a></dt><dt class="indented">function <a href="#classrapidxml_1_1xml__node_37d87c4d5d89fa0cf05b72ee8d4cba3b_137d87c4d5d89fa0cf05b72ee8d4cba3b">remove_last_attribute()</a></dt><dt class="indented">function <a href="#classrapidxml_1_1xml__node_c75154db2e768c0e5b541fc8cd0775ab_1c75154db2e768c0e5b541fc8cd0775ab">remove_attribute(xml_attribute&lt; Ch &gt; *where)</a></dt><dt class="indented">function <a href="#classrapidxml_1_1xml__node_59e6ad4cfd5e8096c052e71d79561eda_159e6ad4cfd5e8096c052e71d79561eda">remove_all_attributes()</a></dt><dt class="indented"/><dt class="indented"/><dt class="indented"/><dt class="indented"/><dt class="indented"/><dt class="indented"/><dt class="indented"/><dt class="indented"/><dt class="indented"/><p/><dt>namespace <a href="#namespacerapidxml">rapidxml</a></dt><dt class="indented">enum <a href="#namespacerapidxml_6a276b85e2da28c5f9c3dbce61c55682_16a276b85e2da28c5f9c3dbce61c55682">node_type</a></dt><dt class="indented"/><dt class="indented"/><dt class="indented"/><dt class="indented"/><dt class="indented"/><dt class="indented"/><dt class="indented"/><dt class="indented"/><dt class="indented">function <a href="#namespacerapidxml_ff5d67f74437199d316d2b2660653ae1_1ff5d67f74437199d316d2b2660653ae1">parse_error_handler(const char *what, void *where)</a></dt><dt class="indented">function <a href="#namespacerapidxml_b94d570fc4c4ab2423813cd0243326b1_1b94d570fc4c4ab2423813cd0243326b1">print(OutIt out, const xml_node&lt; Ch &gt; &amp;node, int flags=0)</a></dt><dt class="indented">function <a href="#namespacerapidxml_13bc37d6d1047acb0efdbc1689221a5e_113bc37d6d1047acb0efdbc1689221a5e">print(std::basic_ostream&lt; Ch &gt; &amp;out, const xml_node&lt; Ch &gt; &amp;node, int flags=0)</a></dt><dt class="indented">function <a href="#namespacerapidxml_5619b38000d967fb223b2b0a8c17463a_15619b38000d967fb223b2b0a8c17463a">operator&lt;&lt;(std::basic_ostream&lt; Ch &gt; &amp;out, const xml_node&lt; Ch &gt; &amp;node)</a></dt><dt class="indented">
+				constant
+			 <a href="#namespacerapidxml_87e8bbab53702cf3b438bd553c10b6b9_187e8bbab53702cf3b438bd553c10b6b9">parse_no_data_nodes</a></dt><dt class="indented">
+				constant
+			 <a href="#namespacerapidxml_97e2c4fdc04fae17126f9971a4fc993e_197e2c4fdc04fae17126f9971a4fc993e">parse_no_element_values</a></dt><dt class="indented">
+				constant
+			 <a href="#namespacerapidxml_9cae3801e70437cbc410c24bf6be691c_19cae3801e70437cbc410c24bf6be691c">parse_no_string_terminators</a></dt><dt class="indented">
+				constant
+			 <a href="#namespacerapidxml_7223b7815c4fb8b42e6e4e77e1ea6b97_17223b7815c4fb8b42e6e4e77e1ea6b97">parse_no_entity_translation</a></dt><dt class="indented">
+				constant
+			 <a href="#namespacerapidxml_ccde57f6054857ee4042a1b4d98c83b9_1ccde57f6054857ee4042a1b4d98c83b9">parse_no_utf8</a></dt><dt class="indented">
+				constant
+			 <a href="#namespacerapidxml_52e2c934ad9c845a5f4cc49570470556_152e2c934ad9c845a5f4cc49570470556">parse_declaration_node</a></dt><dt class="indented">
+				constant
+			 <a href="#namespacerapidxml_0f7479dacbc868456d07897a8c072784_10f7479dacbc868456d07897a8c072784">parse_comment_nodes</a></dt><dt class="indented">
+				constant
+			 <a href="#namespacerapidxml_8e187746ba1ca04f107951ad32df962e_18e187746ba1ca04f107951ad32df962e">parse_doctype_node</a></dt><dt class="indented">
+				constant
+			 <a href="#namespacerapidxml_1c20b2b2b75711cd76423e119c49f830_11c20b2b2b75711cd76423e119c49f830">parse_pi_nodes</a></dt><dt class="indented">
+				constant
+			 <a href="#namespacerapidxml_a5daff9d61c7d4eaf98e4d42efe628ee_1a5daff9d61c7d4eaf98e4d42efe628ee">parse_validate_closing_tags</a></dt><dt class="indented">
+				constant
+			 <a href="#namespacerapidxml_ac1f06b1afd47b812732fb521b146fd9_1ac1f06b1afd47b812732fb521b146fd9">parse_trim_whitespace</a></dt><dt class="indented">
+				constant
+			 <a href="#namespacerapidxml_88f95d4e275ba01408fefde83078651b_188f95d4e275ba01408fefde83078651b">parse_normalize_whitespace</a></dt><dt class="indented">
+				constant
+			 <a href="#namespacerapidxml_45751cf2f38fd6915f35b3122b46d5b6_145751cf2f38fd6915f35b3122b46d5b6">parse_default</a></dt><dt class="indented">
+				constant
+			 <a href="#namespacerapidxml_a97ba1a0a79a6d66f4eef3612508d943_1a97ba1a0a79a6d66f4eef3612508d943">parse_non_destructive</a></dt><dt class="indented">
+				constant
+			 <a href="#namespacerapidxml_398c5476e76102f8bd76c10bb0abbe10_1398c5476e76102f8bd76c10bb0abbe10">parse_fastest</a></dt><dt class="indented">
+				constant
+			 <a href="#namespacerapidxml_b4f2515265facb42291570307924bd57_1b4f2515265facb42291570307924bd57">parse_full</a></dt><dt class="indented">
+				constant
+			 <a href="#namespacerapidxml_b08b8d4293c203b69ed6c5ae77ac1907_1b08b8d4293c203b69ed6c5ae77ac1907">print_no_indenting</a></dt><p/><p/><p/><p/></dl><hr/><h3 class="reference-header" id="classrapidxml_1_1memory__pool">class
+									  template
+								   rapidxml::memory_pool</h3>
+
+							  Defined in <a href="rapidxml.hpp">rapidxml.hpp</a><br/>
+								  Base class for
+								  <a href="#classrapidxml_1_1xml__document">xml_document</a> <h4>Description</h4><para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">This class is used by the parser to create new nodes and attributes, without overheads of dynamic memory allocation. In most cases, you will not need to use this class directly. However, if you need to create nodes manually or modify names/values of nodes, you are encouraged to use <a href="#classrapidxml_1_1memory__pool" kindref="compound">memory_pool</a> of relevant <a href="#classrapidxml_1_1xml__document" kindref="compound">xml_document</a> to allocate the memory. Not only is this faster than allocating them by using <code>new</code> operator, but also their lifetime will be tied to the lifetime of document, possibly simplyfing memory management. <br/><br/>
+ Call <a href="#classrapidxml_1_1memory__pool_750ba3c610b129ac057d817509d08f41_1750ba3c610b129ac057d817509d08f41" kindref="member">allocate_node()</a> or <a href="#classrapidxml_1_1memory__pool_462de142669e0ff649e8e615b82bf457_1462de142669e0ff649e8e615b82bf457" kindref="member">allocate_attribute()</a> functions to obtain new nodes or attributes from the pool. You can also call <a href="#classrapidxml_1_1memory__pool_69729185bc59b0875192d667c47b8859_169729185bc59b0875192d667c47b8859" kindref="member">allocate_string()</a> function to allocate strings. Such strings can then be used as names or values of nodes without worrying about their lifetime. Note that there is no <code>free()</code> function -- all allocations are freed at once when <a href="#classrapidxml_1_1memory__pool_c8bb3912a3ce86b15842e79d0b421204_1c8bb3912a3ce86b15842e79d0b421204" kindref="member">clear()</a> function is called, or when the pool is destroyed. <br/><br/>
+ It is also possible to create a standalone <a href="#classrapidxml_1_1memory__pool" kindref="compound">memory_pool</a>, and use it to allocate nodes, whose lifetime will not be tied to any document. <br/><br/>
+ Pool maintains <code>RAPIDXML_STATIC_POOL_SIZE</code> bytes of statically allocated memory. Until static memory is exhausted, no dynamic memory allocations are done. When static memory is exhausted, pool allocates additional blocks of memory of size <code>RAPIDXML_DYNAMIC_POOL_SIZE</code> each, by using global <code>new[]</code> and <code>delete[]</code> operators. This behaviour can be changed by setting custom allocation routines. Use <a href="#classrapidxml_1_1memory__pool_c0a55a6ef0837dca67572e357100d78a_1c0a55a6ef0837dca67572e357100d78a" kindref="member">set_allocator()</a> function to set them. <br/><br/>
+ Allocations for nodes, attributes and strings are aligned at <code>RAPIDXML_ALIGNMENT</code> bytes. This value defaults to the size of pointer on target architecture. <br/><br/>
+ To obtain absolutely top performance from the parser, it is important that all nodes are allocated from a single, contiguous block of memory. Otherwise, cache misses when jumping between two (or more) disjoint blocks of memory can slow down parsing quite considerably. If required, you can tweak <code>RAPIDXML_STATIC_POOL_SIZE</code>, <code>RAPIDXML_DYNAMIC_POOL_SIZE</code> and <code>RAPIDXML_ALIGNMENT</code> to obtain best wasted memory to performance compromise. To do it, define their values before <a href="#rapidxml_8hpp" kindref="compound">rapidxml.hpp</a> file is included. </para><h4>Parameters</h4><dl><dt class="parameter-name">Ch</dt><dd>Character type of created nodes. </dd></dl><p/><h3 class="reference-header" id="classrapidxml_1_1memory__pool_f8fb3c8f1a564f8045c40bcd07a89866_1f8fb3c8f1a564f8045c40bcd07a89866">
+				constructor
+			 memory_pool::memory_pool</h3><h4>Synopsis</h4><code class="synopsis">memory_pool();
+									  </code><h4>Description</h4><para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Constructs empty pool with default allocator functions. </para><p/><h3 class="reference-header" id="classrapidxml_1_1memory__pool_6f8c7990d9ec1ed2acf6558b238570eb_16f8c7990d9ec1ed2acf6558b238570eb">
+				destructor
+			 memory_pool::~memory_pool</h3><h4>Synopsis</h4><code class="synopsis">~memory_pool();
+									  </code><h4>Description</h4><para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Destroys pool and frees all the memory. This causes memory occupied by nodes allocated by the pool to be freed. Nodes allocated from the pool are no longer valid. </para><p/><h3 class="reference-header" id="classrapidxml_1_1memory__pool_750ba3c610b129ac057d817509d08f41_1750ba3c610b129ac057d817509d08f41">function memory_pool::allocate_node</h3><h4>Synopsis</h4><code class="synopsis">xml_node&lt;Ch&gt;* allocate_node(node_type type, const Ch *name=0, const Ch *value=0, std::size_t name_size=0, std::size_t value_size=0);
+									  </code><h4>Description</h4><para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Allocates a new node from the pool, and optionally assigns name and value to it. If the allocation request cannot be accomodated, this function will throw <code>std::bad_alloc</code>. If exceptions are disabled by defining RAPIDXML_NO_EXCEPTIONS, this function will call <a href="#namespacerapidxml_ff5d67f74437199d316d2b2660653ae1_1ff5d67f74437199d316d2b2660653ae1" kindref="member">rapidxml::parse_error_handler()</a> function. </para><h4>Parameters</h4><dl><dt class="parameter-name">type</dt><dd class="parameter-def">Type of node to create. </dd></dl><dl><dt class="parameter-name">name</dt><dd class="parameter-def">Name to assign to the node, or 0 to assign no name. </dd></dl><dl><dt class="parameter-name">value</dt><dd class="parameter-def">Value to assign to the node, or 0 to assign no value. </dd></dl><dl><dt class="parameter-name">name_size</dt><dd class="parameter-def">Size of name to assign, or 0 to automatically calculate size from name string. </dd></dl><dl><dt class="parameter-name">value_size</dt><dd class="parameter-def">Size of value to assign, or 0 to automatically calculate size from value string. </dd></dl><h4>Returns</h4>Pointer to allocated node. This pointer will never be NULL. <p/><h3 class="reference-header" id="classrapidxml_1_1memory__pool_462de142669e0ff649e8e615b82bf457_1462de142669e0ff649e8e615b82bf457">function memory_pool::allocate_attribute</h3><h4>Synopsis</h4><code class="synopsis">xml_attribute&lt;Ch&gt;* allocate_attribute(const Ch *name=0, const Ch *value=0, std::size_t name_size=0, std::size_t value_size=0);
+									  </code><h4>Description</h4><para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Allocates a new attribute from the pool, and optionally assigns name and value to it. If the allocation request cannot be accomodated, this function will throw <code>std::bad_alloc</code>. If exceptions are disabled by defining RAPIDXML_NO_EXCEPTIONS, this function will call <a href="#namespacerapidxml_ff5d67f74437199d316d2b2660653ae1_1ff5d67f74437199d316d2b2660653ae1" kindref="member">rapidxml::parse_error_handler()</a> function. </para><h4>Parameters</h4><dl><dt class="parameter-name">name</dt><dd class="parameter-def">Name to assign to the attribute, or 0 to assign no name. </dd></dl><dl><dt class="parameter-name">value</dt><dd class="parameter-def">Value to assign to the attribute, or 0 to assign no value. </dd></dl><dl><dt class="parameter-name">name_size</dt><dd class="parameter-def">Size of name to assign, or 0 to automatically calculate size from name string. </dd></dl><dl><dt class="parameter-name">value_size</dt><dd class="parameter-def">Size of value to assign, or 0 to automatically calculate size from value string. </dd></dl><h4>Returns</h4>Pointer to allocated attribute. This pointer will never be NULL. <p/><h3 class="reference-header" id="classrapidxml_1_1memory__pool_69729185bc59b0875192d667c47b8859_169729185bc59b0875192d667c47b8859">function memory_pool::allocate_string</h3><h4>Synopsis</h4><code class="synopsis">Ch* allocate_string(const Ch *source=0, std::size_t size=0);
+									  </code><h4>Description</h4><para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Allocates a char array of given size from the pool, and optionally copies a given string to it. If the allocation request cannot be accomodated, this function will throw <code>std::bad_alloc</code>. If exceptions are disabled by defining RAPIDXML_NO_EXCEPTIONS, this function will call <a href="#namespacerapidxml_ff5d67f74437199d316d2b2660653ae1_1ff5d67f74437199d316d2b2660653ae1" kindref="member">rapidxml::parse_error_handler()</a> function. </para><h4>Parameters</h4><dl><dt class="parameter-name">source</dt><dd class="parameter-def">String to initialize the allocated memory with, or 0 to not initialize it. </dd></dl><dl><dt class="parameter-name">size</dt><dd class="parameter-def">Number of characters to allocate, or zero to calculate it automatically from source string length; if size is 0, source string must be specified and null terminated. </dd></dl><h4>Returns</h4>Pointer to allocated char array. This pointer will never be NULL. <p/><h3 class="reference-header" id="classrapidxml_1_1memory__pool_95c49fcb056e9103ec906a59e3e01d76_195c49fcb056e9103ec906a59e3e01d76">function memory_pool::clone_node</h3><h4>Synopsis</h4><code class="synopsis">xml_node&lt;Ch&gt;* clone_node(const xml_node&lt; Ch &gt; *source, xml_node&lt; Ch &gt; *result=0);
+									  </code><h4>Description</h4><para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Clones an <a href="#classrapidxml_1_1xml__node" kindref="compound">xml_node</a> and its hierarchy of child nodes and attributes. Nodes and attributes are allocated from this memory pool. Names and values are not cloned, they are shared between the clone and the source. Result node can be optionally specified as a second parameter, in which case its contents will be replaced with cloned source node. This is useful when you want to clone entire document. </para><h4>Parameters</h4><dl><dt class="parameter-name">source</dt><dd class="parameter-def">Node to clone. </dd></dl><dl><dt class="parameter-name">result</dt><dd class="parameter-def">Node to put results in, or 0 to automatically allocate result node </dd></dl><h4>Returns</h4>Pointer to cloned node. This pointer will never be NULL. <p/><h3 class="reference-header" id="classrapidxml_1_1memory__pool_c8bb3912a3ce86b15842e79d0b421204_1c8bb3912a3ce86b15842e79d0b421204">function memory_pool::clear</h3><h4>Synopsis</h4><code class="synopsis">void clear();
+									  </code><h4>Description</h4><para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Clears the pool. This causes memory occupied by nodes allocated by the pool to be freed. Any nodes or strings allocated from the pool will no longer be valid. </para><p/><h3 class="reference-header" id="classrapidxml_1_1memory__pool_c0a55a6ef0837dca67572e357100d78a_1c0a55a6ef0837dca67572e357100d78a">function memory_pool::set_allocator</h3><h4>Synopsis</h4><code class="synopsis">void set_allocator(alloc_func *af, free_func *ff);
+									  </code><h4>Description</h4><para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Sets or resets the user-defined memory allocation functions for the pool. This can only be called when no memory is allocated from the pool yet, otherwise results are undefined. Allocation function must not return invalid pointer on failure. It should either throw, stop the program, or use <code>longjmp()</code> function to pass control to other place of program. If it returns invalid pointer, results are undefined. <br/><br/>
+ User defined allocation functions must have the following forms: <br/><code><br/>
+void *allocate(std::size_t size); <br/>
+void free(void *pointer); </code><br/></para><h4>Parameters</h4><dl><dt class="parameter-name">af</dt><dd class="parameter-def">Allocation function, or 0 to restore default function </dd></dl><dl><dt class="parameter-name">ff</dt><dd class="parameter-def">Free function, or 0 to restore default function </dd></dl><p/><h3 class="reference-header" id="classrapidxml_1_1parse__error">class rapidxml::parse_error</h3>
+
+							  Defined in <a href="rapidxml.hpp">rapidxml.hpp</a><br/><h4>Description</h4><para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Parse error exception. This exception is thrown by the parser when an error occurs. Use <a href="#classrapidxml_1_1parse__error_ff06f49065b54a8a86e02e9a2441a8ba_1ff06f49065b54a8a86e02e9a2441a8ba" kindref="member">what()</a> function to get human-readable error message. Use <a href="#classrapidxml_1_1parse__error_377be7d201d95221c318682c35377aca_1377be7d201d95221c318682c35377aca" kindref="member">where()</a> function to get a pointer to position within source text where error was detected. <br/><br/>
+ If throwing exceptions by the parser is undesirable, it can be disabled by defining RAPIDXML_NO_EXCEPTIONS macro before <a href="#rapidxml_8hpp" kindref="compound">rapidxml.hpp</a> is included. This will cause the parser to call <a href="#namespacerapidxml_ff5d67f74437199d316d2b2660653ae1_1ff5d67f74437199d316d2b2660653ae1" kindref="member">rapidxml::parse_error_handler()</a> function instead of throwing an exception. This function must be defined by the user. <br/><br/>
+ This class derives from <code>std::exception</code> class. </para><p/><h3 class="reference-header" id="classrapidxml_1_1parse__error_4dd8d1bdbd9221df4dcb90cafaee3332_14dd8d1bdbd9221df4dcb90cafaee3332">
+				constructor
+			 parse_error::parse_error</h3><h4>Synopsis</h4><code class="synopsis">parse_error(const char *what, void *where);
+									  </code><h4>Description</h4><para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Constructs parse error. </para><p/><h3 class="reference-header" id="classrapidxml_1_1parse__error_ff06f49065b54a8a86e02e9a2441a8ba_1ff06f49065b54a8a86e02e9a2441a8ba">function parse_error::what</h3><h4>Synopsis</h4><code class="synopsis">virtual const char* what() const;
+									  </code><h4>Description</h4><para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Gets human readable description of error. </para><h4>Returns</h4>Pointer to null terminated description of the error. <p/><h3 class="reference-header" id="classrapidxml_1_1parse__error_377be7d201d95221c318682c35377aca_1377be7d201d95221c318682c35377aca">function parse_error::where</h3><h4>Synopsis</h4><code class="synopsis">Ch* where() const;
+									  </code><h4>Description</h4><para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Gets pointer to character data where error happened. Ch should be the same as char type of <a href="#classrapidxml_1_1xml__document" kindref="compound">xml_document</a> that produced the error. </para><h4>Returns</h4>Pointer to location within the parsed string where error occured. <p/><h3 class="reference-header" id="classrapidxml_1_1xml__attribute">class
+									  template
+								   rapidxml::xml_attribute</h3>
+
+							  Defined in <a href="rapidxml.hpp">rapidxml.hpp</a><br/>
+								  Inherits from
+								  <a href="#classrapidxml_1_1xml__base">xml_base</a> <br/><h4>Description</h4><para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Class representing attribute node of XML document. Each attribute has name and value strings, which are available through <a href="#classrapidxml_1_1xml__base_622eade29fdf7806d3ef93ac4d90e707_1622eade29fdf7806d3ef93ac4d90e707" kindref="member">name()</a> and <a href="#classrapidxml_1_1xml__base_c54fa4987fb503916a7b541eb15c9c7f_1c54fa4987fb503916a7b541eb15c9c7f" kindref="member">value()</a> functions (inherited from <a href="#classrapidxml_1_1xml__base" kindref="compound">xml_base</a>). Note that after parse, both name and value of attribute will point to interior of source text used for parsing. Thus, this text must persist in memory for the lifetime of attribute. </para><h4>Parameters</h4><dl><dt class="parameter-name">Ch</dt><dd>Character type to use. </dd></dl><p/><h3 class="reference-header" id="classrapidxml_1_1xml__attribute_d5464aadf08269a886b730993525db34_1d5464aadf08269a886b730993525db34">
+				constructor
+			 xml_attribute::xml_attribute</h3><h4>Synopsis</h4><code class="synopsis">xml_attribute();
+									  </code><h4>Description</h4><para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Constructs an empty attribute with the specified type. Consider using <a href="#classrapidxml_1_1memory__pool" kindref="compound">memory_pool</a> of appropriate <a href="#classrapidxml_1_1xml__document" kindref="compound">xml_document</a> if allocating attributes manually. </para><p/><h3 class="reference-header" id="classrapidxml_1_1xml__attribute_77aea7d8d996ba4f6bd61cc478a4e72d_177aea7d8d996ba4f6bd61cc478a4e72d">function xml_attribute::document</h3><h4>Synopsis</h4><code class="synopsis">xml_document&lt;Ch&gt;* document() const;
+									  </code><h4>Description</h4><para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Gets document of which attribute is a child. </para><h4>Returns</h4>Pointer to document that contains this attribute, or 0 if there is no parent document. <p/><h3 class="reference-header" id="classrapidxml_1_1xml__attribute_5c4a98d2b75f9b41b12c110108fd55ab_15c4a98d2b75f9b41b12c110108fd55ab">function xml_attribute::previous_attribute</h3><h4>Synopsis</h4><code class="synopsis">xml_attribute&lt;Ch&gt;* previous_attribute(const Ch *name=0, std::size_t name_size=0, bool case_sensitive=true) const;
+									  </code><h4>Description</h4><para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Gets previous attribute, optionally matching attribute name. </para><h4>Parameters</h4><dl><dt class="parameter-name">name</dt><dd class="parameter-def">Name of attribute to find, or 0 to return previous attribute regardless of its name; this string doesn&apos;t have to be zero-terminated if name_size is non-zero </dd></dl><dl><dt class="parameter-name">name_size</dt><dd class="parameter-def">Size of name, in characters, or 0 to have size calculated automatically from string </dd></dl><dl><dt class="parameter-name">case_sensitive</dt><dd class="parameter-def">Should name comparison be case-sensitive; non case-sensitive comparison works properly only for ASCII characters </dd></dl><h4>Returns</h4>Pointer to found attribute, or 0 if not found. <p/><h3 class="reference-header" id="classrapidxml_1_1xml__attribute_1b8a814d0d3a7165396b08433eee8a91_11b8a814d0d3a7165396b08433eee8a91">function xml_attribute::next_attribute</h3><h4>Synopsis</h4><code class="synopsis">xml_attribute&lt;Ch&gt;* next_attribute(const Ch *name=0, std::size_t name_size=0, bool case_sensitive=true) const;
+									  </code><h4>Description</h4><para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Gets next attribute, optionally matching attribute name. </para><h4>Parameters</h4><dl><dt class="parameter-name">name</dt><dd class="parameter-def">Name of attribute to find, or 0 to return next attribute regardless of its name; this string doesn&apos;t have to be zero-terminated if name_size is non-zero </dd></dl><dl><dt class="parameter-name">name_size</dt><dd class="parameter-def">Size of name, in characters, or 0 to have size calculated automatically from string </dd></dl><dl><dt class="parameter-name">case_sensitive</dt><dd class="parameter-def">Should name comparison be case-sensitive; non case-sensitive comparison works properly only for ASCII characters </dd></dl><h4>Returns</h4>Pointer to found attribute, or 0 if not found. <p/><h3 class="reference-header" id="classrapidxml_1_1xml__base">class
+									  template
+								   rapidxml::xml_base</h3>
+
+							  Defined in <a href="rapidxml.hpp">rapidxml.hpp</a><br/>
+								  Base class for
+								  <a href="#classrapidxml_1_1xml__attribute">xml_attribute</a> <a href="#classrapidxml_1_1xml__node">xml_node</a> <h4>Description</h4><para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Base class for <a href="#classrapidxml_1_1xml__node" kindref="compound">xml_node</a> and <a href="#classrapidxml_1_1xml__attribute" kindref="compound">xml_attribute</a> implementing common functions: <a href="#classrapidxml_1_1xml__base_622eade29fdf7806d3ef93ac4d90e707_1622eade29fdf7806d3ef93ac4d90e707" kindref="member">name()</a>, <a href="#classrapidxml_1_1xml__base_0dae694c8f7e4d89f1003e2f3a15a43c_10dae694c8f7e4d89f1003e2f3a15a43c" kindref="member">name_size()</a>, <a href="#classrapidxml_1_1xml__base_c54fa4987fb503916a7b541eb15c9c7f_1c54fa4987fb503916a7b541eb15c9c7f" kindref="member">value()</a>, <a href="#classrapidxml_1_1xml__base_aed5ae791b7164c1ee5e649198cbb3db_1aed5ae791b7164c1ee5e649198cbb3db" kindref="member">value_size()</a> and <a href="#classrapidxml_1_1xml__base_798e8df7ea53ade4d9f0701017dce80e_1798e8df7ea53ade4d9f0701017dce80e" kindref="member">parent()</a>. </para><h4>Parameters</h4><dl><dt class="parameter-name">Ch</dt><dd>Character type to use </dd></dl><p/><h3 class="reference-header" id="classrapidxml_1_1xml__base_23630d2c130a9e0e3f3afa7584a9b218_123630d2c130a9e0e3f3afa7584a9b218">
+				constructor
+			 xml_base::xml_base</h3><h4>Synopsis</h4><code class="synopsis">xml_base();
+									  </code><p/><h3 class="reference-header" id="classrapidxml_1_1xml__base_622eade29fdf7806d3ef93ac4d90e707_1622eade29fdf7806d3ef93ac4d90e707">function xml_base::name</h3><h4>Synopsis</h4><code class="synopsis">Ch* name() const;
+									  </code><h4>Description</h4><para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Gets name of the node. Interpretation of name depends on type of node. Note that name will not be zero-terminated if <a href="#namespacerapidxml_9cae3801e70437cbc410c24bf6be691c_19cae3801e70437cbc410c24bf6be691c" kindref="member">rapidxml::parse_no_string_terminators</a> option was selected during parse. <br/><br/>
+ Use <a href="#classrapidxml_1_1xml__base_0dae694c8f7e4d89f1003e2f3a15a43c_10dae694c8f7e4d89f1003e2f3a15a43c" kindref="member">name_size()</a> function to determine length of the name. </para><h4>Returns</h4>Name of node, or empty string if node has no name. <p/><h3 class="reference-header" id="classrapidxml_1_1xml__base_0dae694c8f7e4d89f1003e2f3a15a43c_10dae694c8f7e4d89f1003e2f3a15a43c">function xml_base::name_size</h3><h4>Synopsis</h4><code class="synopsis">std::size_t name_size() const;
+									  </code><h4>Description</h4><para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Gets size of node name, not including terminator character. This function works correctly irrespective of whether name is or is not zero terminated. </para><h4>Returns</h4>Size of node name, in characters. <p/><h3 class="reference-header" id="classrapidxml_1_1xml__base_c54fa4987fb503916a7b541eb15c9c7f_1c54fa4987fb503916a7b541eb15c9c7f">function xml_base::value</h3><h4>Synopsis</h4><code class="synopsis">Ch* value() const;
+									  </code><h4>Description</h4><para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Gets value of node. Interpretation of value depends on type of node. Note that value will not be zero-terminated if <a href="#namespacerapidxml_9cae3801e70437cbc410c24bf6be691c_19cae3801e70437cbc410c24bf6be691c" kindref="member">rapidxml::parse_no_string_terminators</a> option was selected during parse. <br/><br/>
+ Use <a href="#classrapidxml_1_1xml__base_aed5ae791b7164c1ee5e649198cbb3db_1aed5ae791b7164c1ee5e649198cbb3db" kindref="member">value_size()</a> function to determine length of the value. </para><h4>Returns</h4>Value of node, or empty string if node has no value. <p/><h3 class="reference-header" id="classrapidxml_1_1xml__base_aed5ae791b7164c1ee5e649198cbb3db_1aed5ae791b7164c1ee5e649198cbb3db">function xml_base::value_size</h3><h4>Synopsis</h4><code class="synopsis">std::size_t value_size() const;
+									  </code><h4>Description</h4><para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Gets size of node value, not including terminator character. This function works correctly irrespective of whether value is or is not zero terminated. </para><h4>Returns</h4>Size of node value, in characters. <p/><h3 class="reference-header" id="classrapidxml_1_1xml__base_4e7e23d06d48126c65b1f6266acfba5c_14e7e23d06d48126c65b1f6266acfba5c">function xml_base::name</h3><h4>Synopsis</h4><code class="synopsis">void name(const Ch *name, std::size_t size);
+									  </code><h4>Description</h4><para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Sets name of node to a non zero-terminated string. See <a href="#namespacerapidxml_1ownership_of_strings" kindref="member">Ownership Of Strings</a> . <br/><br/>
+ Note that node does not own its name or value, it only stores a pointer to it. It will not delete or otherwise free the pointer on destruction. It is reponsibility of the user to properly manage lifetime of the string. The easiest way to achieve it is to use <a href="#classrapidxml_1_1memory__pool" kindref="compound">memory_pool</a> of the document to allocate the string - on destruction of the document the string will be automatically freed. <br/><br/>
+ Size of name must be specified separately, because name does not have to be zero terminated. Use <a href="#classrapidxml_1_1xml__base_e099c291e104a0d277307fe71f5e0f9e_1e099c291e104a0d277307fe71f5e0f9e" kindref="member">name(const Ch *)</a> function to have the length automatically calculated (string must be zero terminated). </para><h4>Parameters</h4><dl><dt class="parameter-name">name</dt><dd class="parameter-def">Name of node to set. Does not have to be zero terminated. </dd></dl><dl><dt class="parameter-name">size</dt><dd class="parameter-def">Size of name, in characters. This does not include zero terminator, if one is present. </dd></dl><p/><h3 class="reference-header" id="classrapidxml_1_1xml__base_e099c291e104a0d277307fe71f5e0f9e_1e099c291e104a0d277307fe71f5e0f9e">function xml_base::name</h3><h4>Synopsis</h4><code class="synopsis">void name(const Ch *name);
+									  </code><h4>Description</h4><para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Sets name of node to a zero-terminated string. See also <a href="#namespacerapidxml_1ownership_of_strings" kindref="member">Ownership Of Strings</a>  and <a href="#classrapidxml_1_1xml__base_4e7e23d06d48126c65b1f6266acfba5c_14e7e23d06d48126c65b1f6266acfba5c" kindref="member">xml_node::name(const Ch *, std::size_t)</a>. </para><h4>Parameters</h4><dl><dt class="parameter-name">name</dt><dd class="parameter-def">Name of node to set. Must be zero terminated. </dd></dl><p/><h3 class="reference-header" id="classrapidxml_1_1xml__base_d9640aa3f5374673cb72a5289b6c91eb_1d9640aa3f5374673cb72a5289b6c91eb">function xml_base::value</h3><h4>Synopsis</h4><code class="synopsis">void value(const Ch *value, std::size_t size);
+									  </code><h4>Description</h4><para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Sets value of node to a non zero-terminated string. See <a href="#namespacerapidxml_1ownership_of_strings" kindref="member">Ownership Of Strings</a> . <br/><br/>
+ Note that node does not own its name or value, it only stores a pointer to it. It will not delete or otherwise free the pointer on destruction. It is reponsibility of the user to properly manage lifetime of the string. The easiest way to achieve it is to use <a href="#classrapidxml_1_1memory__pool" kindref="compound">memory_pool</a> of the document to allocate the string - on destruction of the document the string will be automatically freed. <br/><br/>
+ Size of value must be specified separately, because it does not have to be zero terminated. Use <a href="#classrapidxml_1_1xml__base_18c7469acdca771de9b4f3054053029c_118c7469acdca771de9b4f3054053029c" kindref="member">value(const Ch *)</a> function to have the length automatically calculated (string must be zero terminated). <br/><br/>
+ If an element has a child node of type node_data, it will take precedence over element value when printing. If you want to manipulate data of elements using values, use parser flag <a href="#namespacerapidxml_87e8bbab53702cf3b438bd553c10b6b9_187e8bbab53702cf3b438bd553c10b6b9" kindref="member">rapidxml::parse_no_data_nodes</a> to prevent creation of data nodes by the parser. </para><h4>Parameters</h4><dl><dt class="parameter-name">value</dt><dd class="parameter-def">value of node to set. Does not have to be zero terminated. </dd></dl><dl><dt class="parameter-name">size</dt><dd class="parameter-def">Size of value, in characters. This does not include zero terminator, if one is present. </dd></dl><p/><h3 class="reference-header" id="classrapidxml_1_1xml__base_18c7469acdca771de9b4f3054053029c_118c7469acdca771de9b4f3054053029c">function xml_base::value</h3><h4>Synopsis</h4><code class="synopsis">void value(const Ch *value);
+									  </code><h4>Description</h4><para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Sets value of node to a zero-terminated string. See also <a href="#namespacerapidxml_1ownership_of_strings" kindref="member">Ownership Of Strings</a>  and <a href="#classrapidxml_1_1xml__base_d9640aa3f5374673cb72a5289b6c91eb_1d9640aa3f5374673cb72a5289b6c91eb" kindref="member">xml_node::value(const Ch *, std::size_t)</a>. </para><h4>Parameters</h4><dl><dt class="parameter-name">value</dt><dd class="parameter-def">Vame of node to set. Must be zero terminated. </dd></dl><p/><h3 class="reference-header" id="classrapidxml_1_1xml__base_798e8df7ea53ade4d9f0701017dce80e_1798e8df7ea53ade4d9f0701017dce80e">function xml_base::parent</h3><h4>Synopsis</h4><code class="synopsis">xml_node&lt;Ch&gt;* parent() const;
+									  </code><h4>Description</h4><para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Gets node parent. </para><h4>Returns</h4>Pointer to parent node, or 0 if there is no parent. <p/><h3 class="reference-header" id="classrapidxml_1_1xml__document">class
+									  template
+								   rapidxml::xml_document</h3>
+
+							  Defined in <a href="rapidxml.hpp">rapidxml.hpp</a><br/>
+								  Inherits from
+								  <a href="#classrapidxml_1_1xml__node">xml_node</a> <a href="#classrapidxml_1_1memory__pool">memory_pool</a> <br/><h4>Description</h4><para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">This class represents root of the DOM hierarchy. It is also an <a href="#classrapidxml_1_1xml__node" kindref="compound">xml_node</a> and a <a href="#classrapidxml_1_1memory__pool" kindref="compound">memory_pool</a> through public inheritance. Use <a href="#classrapidxml_1_1xml__document_8338ce6042e7b04d5a42144fb446b69c_18338ce6042e7b04d5a42144fb446b69c" kindref="member">parse()</a> function to build a DOM tree from a zero-terminated XML text string. <a href="#classrapidxml_1_1xml__document_8338ce6042e7b04d5a42144fb446b69c_18338ce6042e7b04d5a42144fb446b69c" kindref="member">parse()</a> function allocates memory for nodes and attributes by using functions of <a href="#classrapidxml_1_1xml__document" kindref="compound">xml_document</a>, which are inherited from <a href="#classrapidxml_1_1memory__pool" kindref="compound">memory_pool</a>. To access root node of the document, use the document itself, as if it was an <a href="#classrapidxml_1_1xml__node" kindref="compound">xml_node</a>. </para><h4>Parameters</h4><dl><dt class="parameter-name">Ch</dt><dd>Character type to use. </dd></dl><p/><h3 class="reference-header" id="classrapidxml_1_1xml__document_6ce266cc52d549c42abe3a3d5e8af9ba_16ce266cc52d549c42abe3a3d5e8af9ba">
+				constructor
+			 xml_document::xml_document</h3><h4>Synopsis</h4><code class="synopsis">xml_document();
+									  </code><h4>Description</h4><para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Constructs empty XML document. </para><p/><h3 class="reference-header" id="classrapidxml_1_1xml__document_8338ce6042e7b04d5a42144fb446b69c_18338ce6042e7b04d5a42144fb446b69c">function xml_document::parse</h3><h4>Synopsis</h4><code class="synopsis">void parse(Ch *text);
+									  </code><h4>Description</h4><para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Parses zero-terminated XML string according to given flags. Passed string will be modified by the parser, unless <a href="#namespacerapidxml_a97ba1a0a79a6d66f4eef3612508d943_1a97ba1a0a79a6d66f4eef3612508d943" kindref="member">rapidxml::parse_non_destructive</a> flag is used. The string must persist for the lifetime of the document. In case of error, <a href="#classrapidxml_1_1parse__error" kindref="compound">rapidxml::parse_error</a> exception will be thrown. <br/><br/>
+ If you want to parse contents of a file, you must first load the file into the memory, and pass pointer to its beginning. Make sure that data is zero-terminated. <br/><br/>
+ Document can be parsed into multiple times. Each new call to parse removes previous nodes and attributes (if any), but does not clear memory pool. </para><h4>Parameters</h4><dl><dt class="parameter-name">text</dt><dd class="parameter-def">XML data to parse; pointer is non-const to denote fact that this data may be modified by the parser. </dd></dl><p/><h3 class="reference-header" id="classrapidxml_1_1xml__document_c8bb3912a3ce86b15842e79d0b421204_1c8bb3912a3ce86b15842e79d0b421204">function xml_document::clear</h3><h4>Synopsis</h4><code class="synopsis">void clear();
+									  </code><h4>Description</h4><para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Clears the document by deleting all nodes and clearing the memory pool. All nodes owned by document pool are destroyed. </para><p/><h3 class="reference-header" id="classrapidxml_1_1xml__node">class
+									  template
+								   rapidxml::xml_node</h3>
+
+							  Defined in <a href="rapidxml.hpp">rapidxml.hpp</a><br/>
+								  Inherits from
+								  <a href="#classrapidxml_1_1xml__base">xml_base</a> <br/>
+								  Base class for
+								  <a href="#classrapidxml_1_1xml__document">xml_document</a> <h4>Description</h4><para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Class representing a node of XML document. Each node may have associated name and value strings, which are available through <a href="#classrapidxml_1_1xml__base_622eade29fdf7806d3ef93ac4d90e707_1622eade29fdf7806d3ef93ac4d90e707" kindref="member">name()</a> and <a href="#classrapidxml_1_1xml__base_c54fa4987fb503916a7b541eb15c9c7f_1c54fa4987fb503916a7b541eb15c9c7f" kindref="member">value()</a> functions. Interpretation of name and value depends on type of the node. Type of node can be determined by using <a href="#classrapidxml_1_1xml__node_975e86937621ae4afe6a423219de30d0_1975e86937621ae4afe6a423219de30d0" kindref="member">type()</a> function. <br/><br/>
+ Note that after parse, both name and value of node, if any, will point interior of source text used for parsing. Thus, this text must persist in the memory for the lifetime of node. </para><h4>Parameters</h4><dl><dt class="parameter-name">Ch</dt><dd>Character type to use. </dd></dl><p/><h3 class="reference-header" id="classrapidxml_1_1xml__node_34c55af3504549a475e5b9dfcaa6adf5_134c55af3504549a475e5b9dfcaa6adf5">
+				constructor
+			 xml_node::xml_node</h3><h4>Synopsis</h4><code class="synopsis">xml_node(node_type type);
+									  </code><h4>Description</h4><para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Constructs an empty node with the specified type. Consider using <a href="#classrapidxml_1_1memory__pool" kindref="compound">memory_pool</a> of appropriate document to allocate nodes manually. </para><h4>Parameters</h4><dl><dt class="parameter-name">type</dt><dd class="parameter-def">Type of node to construct. </dd></dl><p/><h3 class="reference-header" id="classrapidxml_1_1xml__node_975e86937621ae4afe6a423219de30d0_1975e86937621ae4afe6a423219de30d0">function xml_node::type</h3><h4>Synopsis</h4><code class="synopsis">node_type type() const;
+									  </code><h4>Description</h4><para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Gets type of node. </para><h4>Returns</h4>Type of node. <p/><h3 class="reference-header" id="classrapidxml_1_1xml__node_77aea7d8d996ba4f6bd61cc478a4e72d_177aea7d8d996ba4f6bd61cc478a4e72d">function xml_node::document</h3><h4>Synopsis</h4><code class="synopsis">xml_document&lt;Ch&gt;* document() const;
+									  </code><h4>Description</h4><para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Gets document of which node is a child. </para><h4>Returns</h4>Pointer to document that contains this node, or 0 if there is no parent document. <p/><h3 class="reference-header" id="classrapidxml_1_1xml__node_7823e36687669e59c2afdf66334ef35a_17823e36687669e59c2afdf66334ef35a">function xml_node::first_node</h3><h4>Synopsis</h4><code class="synopsis">xml_node&lt;Ch&gt;* first_node(const Ch *name=0, std::size_t name_size=0, bool case_sensitive=true) const;
+									  </code><h4>Description</h4><para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Gets first child node, optionally matching node name. </para><h4>Parameters</h4><dl><dt class="parameter-name">name</dt><dd class="parameter-def">Name of child to find, or 0 to return first child regardless of its name; this string doesn&apos;t have to be zero-terminated if name_size is non-zero </dd></dl><dl><dt class="parameter-name">name_size</dt><dd class="parameter-def">Size of name, in characters, or 0 to have size calculated automatically from string </dd></dl><dl><dt class="parameter-name">case_sensitive</dt><dd class="parameter-def">Should name comparison be case-sensitive; non case-sensitive comparison works properly only for ASCII characters </dd></dl><h4>Returns</h4>Pointer to found child, or 0 if not found. <p/><h3 class="reference-header" id="classrapidxml_1_1xml__node_fcb6e2209b591a36d2dadba20d2bc7cc_1fcb6e2209b591a36d2dadba20d2bc7cc">function xml_node::last_node</h3><h4>Synopsis</h4><code class="synopsis">xml_node&lt;Ch&gt;* last_node(const Ch *name=0, std::size_t name_size=0, bool case_sensitive=true) const;
+									  </code><h4>Description</h4><para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Gets last child node, optionally matching node name. Behaviour is undefined if node has no children. Use <a href="#classrapidxml_1_1xml__node_7823e36687669e59c2afdf66334ef35a_17823e36687669e59c2afdf66334ef35a" kindref="member">first_node()</a> to test if node has children. </para><h4>Parameters</h4><dl><dt class="parameter-name">name</dt><dd class="parameter-def">Name of child to find, or 0 to return last child regardless of its name; this string doesn&apos;t have to be zero-terminated if name_size is non-zero </dd></dl><dl><dt class="parameter-name">name_size</dt><dd class="parameter-def">Size of name, in characters, or 0 to have size calculated automatically from string </dd></dl><dl><dt class="parameter-name">case_sensitive</dt><dd class="parameter-def">Should name comparison be case-sensitive; non case-sensitive comparison works properly only for ASCII characters </dd></dl><h4>Returns</h4>Pointer to found child, or 0 if not found. <p/><h3 class="reference-header" id="classrapidxml_1_1xml__node_ac2f6886c0107e9d5f156e9542546df6_1ac2f6886c0107e9d5f156e9542546df6">function xml_node::previous_sibling</h3><h4>Synopsis</h4><code class="synopsis">xml_node&lt;Ch&gt;* previous_sibling(const Ch *name=0, std::size_t name_size=0, bool case_sensitive=true) const;
+									  </code><h4>Description</h4><para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Gets previous sibling node, optionally matching node name. Behaviour is undefined if node has no parent. Use <a href="#classrapidxml_1_1xml__base_798e8df7ea53ade4d9f0701017dce80e_1798e8df7ea53ade4d9f0701017dce80e" kindref="member">parent()</a> to test if node has a parent. </para><h4>Parameters</h4><dl><dt class="parameter-name">name</dt><dd class="parameter-def">Name of sibling to find, or 0 to return previous sibling regardless of its name; this string doesn&apos;t have to be zero-terminated if name_size is non-zero </dd></dl><dl><dt class="parameter-name">name_size</dt><dd class="parameter-def">Size of name, in characters, or 0 to have size calculated automatically from string </dd></dl><dl><dt class="parameter-name">case_sensitive</dt><dd class="parameter-def">Should name comparison be case-sensitive; non case-sensitive comparison works properly only for ASCII characters </dd></dl><h4>Returns</h4>Pointer to found sibling, or 0 if not found. <p/><h3 class="reference-header" id="classrapidxml_1_1xml__node_b3ead2cefecc03a813836203e3f6f38f_1b3ead2cefecc03a813836203e3f6f38f">function xml_node::next_sibling</h3><h4>Synopsis</h4><code class="synopsis">xml_node&lt;Ch&gt;* next_sibling(const Ch *name=0, std::size_t name_size=0, bool case_sensitive=true) const;
+									  </code><h4>Description</h4><para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Gets next sibling node, optionally matching node name. Behaviour is undefined if node has no parent. Use <a href="#classrapidxml_1_1xml__base_798e8df7ea53ade4d9f0701017dce80e_1798e8df7ea53ade4d9f0701017dce80e" kindref="member">parent()</a> to test if node has a parent. </para><h4>Parameters</h4><dl><dt class="parameter-name">name</dt><dd class="parameter-def">Name of sibling to find, or 0 to return next sibling regardless of its name; this string doesn&apos;t have to be zero-terminated if name_size is non-zero </dd></dl><dl><dt class="parameter-name">name_size</dt><dd class="parameter-def">Size of name, in characters, or 0 to have size calculated automatically from string </dd></dl><dl><dt class="parameter-name">case_sensitive</dt><dd class="parameter-def">Should name comparison be case-sensitive; non case-sensitive comparison works properly only for ASCII characters </dd></dl><h4>Returns</h4>Pointer to found sibling, or 0 if not found. <p/><h3 class="reference-header" id="classrapidxml_1_1xml__node_5810a09f82f8d53efbe9456286dcec83_15810a09f82f8d53efbe9456286dcec83">function xml_node::first_attribute</h3><h4>Synopsis</h4><code class="synopsis">xml_attribute&lt;Ch&gt;* first_attribute(const Ch *name=0, std::size_t name_size=0, bool case_sensitive=true) const;
+									  </code><h4>Description</h4><para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Gets first attribute of node, optionally matching attribute name. </para><h4>Parameters</h4><dl><dt class="parameter-name">name</dt><dd class="parameter-def">Name of attribute to find, or 0 to return first attribute regardless of its name; this string doesn&apos;t have to be zero-terminated if name_size is non-zero </dd></dl><dl><dt class="parameter-name">name_size</dt><dd class="parameter-def">Size of name, in characters, or 0 to have size calculated automatically from string </dd></dl><dl><dt class="parameter-name">case_sensitive</dt><dd class="parameter-def">Should name comparison be case-sensitive; non case-sensitive comparison works properly only for ASCII characters </dd></dl><h4>Returns</h4>Pointer to found attribute, or 0 if not found. <p/><h3 class="reference-header" id="classrapidxml_1_1xml__node_16953d66751b5b949ee4ee2d9c0bc63a_116953d66751b5b949ee4ee2d9c0bc63a">function xml_node::last_attribute</h3><h4>Synopsis</h4><code class="synopsis">xml_attribute&lt;Ch&gt;* last_attribute(const Ch *name=0, std::size_t name_size=0, bool case_sensitive=true) const;
+									  </code><h4>Description</h4><para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Gets last attribute of node, optionally matching attribute name. </para><h4>Parameters</h4><dl><dt class="parameter-name">name</dt><dd class="parameter-def">Name of attribute to find, or 0 to return last attribute regardless of its name; this string doesn&apos;t have to be zero-terminated if name_size is non-zero </dd></dl><dl><dt class="parameter-name">name_size</dt><dd class="parameter-def">Size of name, in characters, or 0 to have size calculated automatically from string </dd></dl><dl><dt class="parameter-name">case_sensitive</dt><dd class="parameter-def">Should name comparison be case-sensitive; non case-sensitive comparison works properly only for ASCII characters </dd></dl><h4>Returns</h4>Pointer to found attribute, or 0 if not found. <p/><h3 class="reference-header" id="classrapidxml_1_1xml__node_a78759bfa429fa2ab6bc5fe617cfa3cf_1a78759bfa429fa2ab6bc5fe617cfa3cf">function xml_node::type</h3><h4>Synopsis</h4><code class="synopsis">void type(node_type type);
+									  </code><h4>Description</h4><para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Sets type of node. </para><h4>Parameters</h4><dl><dt class="parameter-name">type</dt><dd class="parameter-def">Type of node to set. </dd></dl><p/><h3 class="reference-header" id="classrapidxml_1_1xml__node_0c39df6617e709eb2fba11300dea63f2_10c39df6617e709eb2fba11300dea63f2">function xml_node::prepend_node</h3><h4>Synopsis</h4><code class="synopsis">void prepend_node(xml_node&lt; Ch &gt; *child);
+									  </code><h4>Description</h4><para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Prepends a new child node. The prepended child becomes the first child, and all existing children are moved one position back. </para><h4>Parameters</h4><dl><dt class="parameter-name">child</dt><dd class="parameter-def">Node to prepend. </dd></dl><p/><h3 class="reference-header" id="classrapidxml_1_1xml__node_86de2e22276826089b7baed2599f8dee_186de2e22276826089b7baed2599f8dee">function xml_node::append_node</h3><h4>Synopsis</h4><code class="synopsis">void append_node(xml_node&lt; Ch &gt; *child);
+									  </code><h4>Description</h4><para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Appends a new child node. The appended child becomes the last child. </para><h4>Parameters</h4><dl><dt class="parameter-name">child</dt><dd class="parameter-def">Node to append. </dd></dl><p/><h3 class="reference-header" id="classrapidxml_1_1xml__node_780972a57fc447250ab47cc8f421b65e_1780972a57fc447250ab47cc8f421b65e">function xml_node::insert_node</h3><h4>Synopsis</h4><code class="synopsis">void insert_node(xml_node&lt; Ch &gt; *where, xml_node&lt; Ch &gt; *child);
+									  </code><h4>Description</h4><para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Inserts a new child node at specified place inside the node. All children after and including the specified node are moved one position back. </para><h4>Parameters</h4><dl><dt class="parameter-name">where</dt><dd class="parameter-def">Place where to insert the child, or 0 to insert at the back. </dd></dl><dl><dt class="parameter-name">child</dt><dd class="parameter-def">Node to insert. </dd></dl><p/><h3 class="reference-header" id="classrapidxml_1_1xml__node_9a31d861e1bddc710839c551a5d2b3a4_19a31d861e1bddc710839c551a5d2b3a4">function xml_node::remove_first_node</h3><h4>Synopsis</h4><code class="synopsis">void remove_first_node();
+									  </code><h4>Description</h4><para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Removes first child node. If node has no children, behaviour is undefined. Use <a href="#classrapidxml_1_1xml__node_7823e36687669e59c2afdf66334ef35a_17823e36687669e59c2afdf66334ef35a" kindref="member">first_node()</a> to test if node has children. </para><p/><h3 class="reference-header" id="classrapidxml_1_1xml__node_87addf2bc127ee31aa4b5295d3c9b530_187addf2bc127ee31aa4b5295d3c9b530">function xml_node::remove_last_node</h3><h4>Synopsis</h4><code class="synopsis">void remove_last_node();
+									  </code><h4>Description</h4><para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Removes last child of the node. If node has no children, behaviour is undefined. Use <a href="#classrapidxml_1_1xml__node_7823e36687669e59c2afdf66334ef35a_17823e36687669e59c2afdf66334ef35a" kindref="member">first_node()</a> to test if node has children. </para><p/><h3 class="reference-header" id="classrapidxml_1_1xml__node_9316463a2201631e7e2062b17729f9cd_19316463a2201631e7e2062b17729f9cd">function xml_node::remove_node</h3><h4>Synopsis</h4><code class="synopsis">void remove_node(xml_node&lt; Ch &gt; *where);
+									  </code><h4>Description</h4><para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Removes specified child from the node. </para><p/><h3 class="reference-header" id="classrapidxml_1_1xml__node_0218147d13e41d5fa60ced4e7a7e9726_10218147d13e41d5fa60ced4e7a7e9726">function xml_node::remove_all_nodes</h3><h4>Synopsis</h4><code class="synopsis">void remove_all_nodes();
+									  </code><h4>Description</h4><para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Removes all child nodes (but not attributes). </para><p/><h3 class="reference-header" id="classrapidxml_1_1xml__node_f6dffa513da74cc0be71a7ba84f8265e_1f6dffa513da74cc0be71a7ba84f8265e">function xml_node::prepend_attribute</h3><h4>Synopsis</h4><code class="synopsis">void prepend_attribute(xml_attribute&lt; Ch &gt; *attribute);
+									  </code><h4>Description</h4><para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Prepends a new attribute to the node. </para><h4>Parameters</h4><dl><dt class="parameter-name">attribute</dt><dd class="parameter-def">Attribute to prepend. </dd></dl><p/><h3 class="reference-header" id="classrapidxml_1_1xml__node_8fbd4f5ef7169d493da9f8d87ac04b77_18fbd4f5ef7169d493da9f8d87ac04b77">function xml_node::append_attribute</h3><h4>Synopsis</h4><code class="synopsis">void append_attribute(xml_attribute&lt; Ch &gt; *attribute);
+									  </code><h4>Description</h4><para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Appends a new attribute to the node. </para><h4>Parameters</h4><dl><dt class="parameter-name">attribute</dt><dd class="parameter-def">Attribute to append. </dd></dl><p/><h3 class="reference-header" id="classrapidxml_1_1xml__node_070d5888b0557fe06a5b24961de1b988_1070d5888b0557fe06a5b24961de1b988">function xml_node::insert_attribute</h3><h4>Synopsis</h4><code class="synopsis">void insert_attribute(xml_attribute&lt; Ch &gt; *where, xml_attribute&lt; Ch &gt; *attribute);
+									  </code><h4>Description</h4><para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Inserts a new attribute at specified place inside the node. All attributes after and including the specified attribute are moved one position back. </para><h4>Parameters</h4><dl><dt class="parameter-name">where</dt><dd class="parameter-def">Place where to insert the attribute, or 0 to insert at the back. </dd></dl><dl><dt class="parameter-name">attribute</dt><dd class="parameter-def">Attribute to insert. </dd></dl><p/><h3 class="reference-header" id="classrapidxml_1_1xml__node_4eea4a7f6cb484ca9944f7eafe6e1843_14eea4a7f6cb484ca9944f7eafe6e1843">function xml_node::remove_first_attribute</h3><h4>Synopsis</h4><code class="synopsis">void remove_first_attribute();
+									  </code><h4>Description</h4><para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Removes first attribute of the node. If node has no attributes, behaviour is undefined. Use <a href="#classrapidxml_1_1xml__node_5810a09f82f8d53efbe9456286dcec83_15810a09f82f8d53efbe9456286dcec83" kindref="member">first_attribute()</a> to test if node has attributes. </para><p/><h3 class="reference-header" id="classrapidxml_1_1xml__node_37d87c4d5d89fa0cf05b72ee8d4cba3b_137d87c4d5d89fa0cf05b72ee8d4cba3b">function xml_node::remove_last_attribute</h3><h4>Synopsis</h4><code class="synopsis">void remove_last_attribute();
+									  </code><h4>Description</h4><para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Removes last attribute of the node. If node has no attributes, behaviour is undefined. Use <a href="#classrapidxml_1_1xml__node_5810a09f82f8d53efbe9456286dcec83_15810a09f82f8d53efbe9456286dcec83" kindref="member">first_attribute()</a> to test if node has attributes. </para><p/><h3 class="reference-header" id="classrapidxml_1_1xml__node_c75154db2e768c0e5b541fc8cd0775ab_1c75154db2e768c0e5b541fc8cd0775ab">function xml_node::remove_attribute</h3><h4>Synopsis</h4><code class="synopsis">void remove_attribute(xml_attribute&lt; Ch &gt; *where);
+									  </code><h4>Description</h4><para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Removes specified attribute from node. </para><h4>Parameters</h4><dl><dt class="parameter-name">where</dt><dd class="parameter-def">Pointer to attribute to be removed. </dd></dl><p/><h3 class="reference-header" id="classrapidxml_1_1xml__node_59e6ad4cfd5e8096c052e71d79561eda_159e6ad4cfd5e8096c052e71d79561eda">function xml_node::remove_all_attributes</h3><h4>Synopsis</h4><code class="synopsis">void remove_all_attributes();
+									  </code><h4>Description</h4><para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Removes all attributes of node. </para><p/><h3 class="reference-header" id="namespacerapidxml_6a276b85e2da28c5f9c3dbce61c55682_16a276b85e2da28c5f9c3dbce61c55682">enum node_type</h3><h4>Description</h4><para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Enumeration listing all node types produced by the parser. Use <a href="#classrapidxml_1_1xml__node_975e86937621ae4afe6a423219de30d0_1975e86937621ae4afe6a423219de30d0" kindref="member">xml_node::type()</a> function to query node type. </para><h4>Values</h4><dl><dt class="parameter-name">node_document</dt><dd class="parameter-def">A document node. Name and value are empty. </dd></dl><dl><dt class="parameter-name">node_element</dt><dd class="parameter-def">An element node. Name contains element name. Value contains text of first data node. </dd></dl><dl><dt class="parameter-name">node_data</dt><dd class="parameter-def">A data node. Name is empty. Value contains data text. </dd></dl><dl><dt class="parameter-name">node_cdata</dt><dd class="parameter-def">A CDATA node. Name is empty. Value contains data text. </dd></dl><dl><dt class="parameter-name">node_comment</dt><dd class="parameter-def">A comment node. Name is empty. Value contains comment text. </dd></dl><dl><dt class="parameter-name">node_declaration</dt><dd class="parameter-def">A declaration node. Name and value are empty. Declaration parameters (version, encoding and standalone) are in node attributes. </dd></dl><dl><dt class="parameter-name">node_doctype</dt><dd class="parameter-def">A DOCTYPE node. Name is empty. Value contains DOCTYPE text. </dd></dl><dl><dt class="parameter-name">node_pi</dt><dd class="parameter-def">A PI node. Name contains target. Value contains instructions. </dd></dl><p/><h3 class="reference-header" id="namespacerapidxml_ff5d67f74437199d316d2b2660653ae1_1ff5d67f74437199d316d2b2660653ae1">function parse_error_handler</h3><h4>Synopsis</h4><code class="synopsis">void rapidxml::parse_error_handler(const char *what, void *where);
+									  </code><h4>Description</h4><para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">When exceptions are disabled by defining RAPIDXML_NO_EXCEPTIONS, this function is called to notify user about the error. It must be defined by the user. <br/><br/>
+ This function cannot return. If it does, the results are undefined. <br/><br/>
+ A very simple definition might look like that: <preformatted>
+        void rapidxml::parse_error_handler(const char *what, void *where)
+        {
+            std::cout &lt;&lt; &quot;Parse error: &quot; &lt;&lt; what &lt;&lt; &quot;\n&quot;;
+            std::abort();
+        }
+        </preformatted></para><h4>Parameters</h4><dl><dt class="parameter-name">what</dt><dd class="parameter-def">Human readable description of the error. </dd></dl><dl><dt class="parameter-name">where</dt><dd class="parameter-def">Pointer to character data where error was detected. </dd></dl><p/><h3 class="reference-header" id="namespacerapidxml_b94d570fc4c4ab2423813cd0243326b1_1b94d570fc4c4ab2423813cd0243326b1">function print</h3><h4>Synopsis</h4><code class="synopsis">OutIt rapidxml::print(OutIt out, const xml_node&lt; Ch &gt; &amp;node, int flags=0);
+									  </code><h4>Description</h4><para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Prints XML to given output iterator. </para><h4>Parameters</h4><dl><dt class="parameter-name">out</dt><dd class="parameter-def">Output iterator to print to. </dd></dl><dl><dt class="parameter-name">node</dt><dd class="parameter-def">Node to be printed. Pass xml_document to print entire document. </dd></dl><dl><dt class="parameter-name">flags</dt><dd class="parameter-def">Flags controlling how XML is printed. </dd></dl><h4>Returns</h4>Output iterator pointing to position immediately after last character of printed text. <p/><h3 class="reference-header" id="namespacerapidxml_13bc37d6d1047acb0efdbc1689221a5e_113bc37d6d1047acb0efdbc1689221a5e">function print</h3><h4>Synopsis</h4><code class="synopsis">std::basic_ostream&lt;Ch&gt;&amp; rapidxml::print(std::basic_ostream&lt; Ch &gt; &amp;out, const xml_node&lt; Ch &gt; &amp;node, int flags=0);
+									  </code><h4>Description</h4><para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Prints XML to given output stream. </para><h4>Parameters</h4><dl><dt class="parameter-name">out</dt><dd class="parameter-def">Output stream to print to. </dd></dl><dl><dt class="parameter-name">node</dt><dd class="parameter-def">Node to be printed. Pass xml_document to print entire document. </dd></dl><dl><dt class="parameter-name">flags</dt><dd class="parameter-def">Flags controlling how XML is printed. </dd></dl><h4>Returns</h4>Output stream. <p/><h3 class="reference-header" id="namespacerapidxml_5619b38000d967fb223b2b0a8c17463a_15619b38000d967fb223b2b0a8c17463a">function operator&lt;&lt;</h3><h4>Synopsis</h4><code class="synopsis">std::basic_ostream&lt;Ch&gt;&amp; rapidxml::operator&lt;&lt;(std::basic_ostream&lt; Ch &gt; &amp;out, const xml_node&lt; Ch &gt; &amp;node);
+									  </code><h4>Description</h4><para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Prints formatted XML to given output stream. Uses default printing flags. Use <a href="#namespacerapidxml_b94d570fc4c4ab2423813cd0243326b1_1b94d570fc4c4ab2423813cd0243326b1" kindref="member">print()</a> function to customize printing process. </para><h4>Parameters</h4><dl><dt class="parameter-name">out</dt><dd class="parameter-def">Output stream to print to. </dd></dl><dl><dt class="parameter-name">node</dt><dd class="parameter-def">Node to be printed. </dd></dl><h4>Returns</h4>Output stream. <p/><h3 class="reference-header" id="namespacerapidxml_87e8bbab53702cf3b438bd553c10b6b9_187e8bbab53702cf3b438bd553c10b6b9">
+				constant
+			 parse_no_data_nodes</h3><h4>Synopsis</h4><code class="synopsis">const int parse_no_data_nodes
+											  = 0x1;
+									  </code><h4>Description</h4><para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Parse flag instructing the parser to not create data nodes. Text of first data node will still be placed in value of parent element, unless <a href="#namespacerapidxml_97e2c4fdc04fae17126f9971a4fc993e_197e2c4fdc04fae17126f9971a4fc993e" kindref="member">rapidxml::parse_no_element_values</a> flag is also specified. Can be combined with other flags by use of | operator. <br/><br/>
+ See <a href="#classrapidxml_1_1xml__document_8338ce6042e7b04d5a42144fb446b69c_18338ce6042e7b04d5a42144fb446b69c" kindref="member">xml_document::parse()</a> function. </para><p/><h3 class="reference-header" id="namespacerapidxml_97e2c4fdc04fae17126f9971a4fc993e_197e2c4fdc04fae17126f9971a4fc993e">
+				constant
+			 parse_no_element_values</h3><h4>Synopsis</h4><code class="synopsis">const int parse_no_element_values
+											  = 0x2;
+									  </code><h4>Description</h4><para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Parse flag instructing the parser to not use text of first data node as a value of parent element. Can be combined with other flags by use of | operator. Note that child data nodes of element node take precendence over its value when printing. That is, if element has one or more child data nodes <i>and</i> a value, the value will be ignored. Use <a href="#namespacerapidxml_87e8bbab53702cf3b438bd553c10b6b9_187e8bbab53702cf3b438bd553c10b6b9" kindref="member">rapidxml::parse_no_data_nodes</a> flag to prevent creation of data nodes if you want to manipulate data using values of elements. <br/><br/>
+ See <a href="#classrapidxml_1_1xml__document_8338ce6042e7b04d5a42144fb446b69c_18338ce6042e7b04d5a42144fb446b69c" kindref="member">xml_document::parse()</a> function. </para><p/><h3 class="reference-header" id="namespacerapidxml_9cae3801e70437cbc410c24bf6be691c_19cae3801e70437cbc410c24bf6be691c">
+				constant
+			 parse_no_string_terminators</h3><h4>Synopsis</h4><code class="synopsis">const int parse_no_string_terminators
+											  = 0x4;
+									  </code><h4>Description</h4><para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Parse flag instructing the parser to not place zero terminators after strings in the source text. By default zero terminators are placed, modifying source text. Can be combined with other flags by use of | operator. <br/><br/>
+ See <a href="#classrapidxml_1_1xml__document_8338ce6042e7b04d5a42144fb446b69c_18338ce6042e7b04d5a42144fb446b69c" kindref="member">xml_document::parse()</a> function. </para><p/><h3 class="reference-header" id="namespacerapidxml_7223b7815c4fb8b42e6e4e77e1ea6b97_17223b7815c4fb8b42e6e4e77e1ea6b97">
+				constant
+			 parse_no_entity_translation</h3><h4>Synopsis</h4><code class="synopsis">const int parse_no_entity_translation
+											  = 0x8;
+									  </code><h4>Description</h4><para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Parse flag instructing the parser to not translate entities in the source text. By default entities are translated, modifying source text. Can be combined with other flags by use of | operator. <br/><br/>
+ See <a href="#classrapidxml_1_1xml__document_8338ce6042e7b04d5a42144fb446b69c_18338ce6042e7b04d5a42144fb446b69c" kindref="member">xml_document::parse()</a> function. </para><p/><h3 class="reference-header" id="namespacerapidxml_ccde57f6054857ee4042a1b4d98c83b9_1ccde57f6054857ee4042a1b4d98c83b9">
+				constant
+			 parse_no_utf8</h3><h4>Synopsis</h4><code class="synopsis">const int parse_no_utf8
+											  = 0x10;
+									  </code><h4>Description</h4><para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Parse flag instructing the parser to disable UTF-8 handling and assume plain 8 bit characters. By default, UTF-8 handling is enabled. Can be combined with other flags by use of | operator. <br/><br/>
+ See <a href="#classrapidxml_1_1xml__document_8338ce6042e7b04d5a42144fb446b69c_18338ce6042e7b04d5a42144fb446b69c" kindref="member">xml_document::parse()</a> function. </para><p/><h3 class="reference-header" id="namespacerapidxml_52e2c934ad9c845a5f4cc49570470556_152e2c934ad9c845a5f4cc49570470556">
+				constant
+			 parse_declaration_node</h3><h4>Synopsis</h4><code class="synopsis">const int parse_declaration_node
+											  = 0x20;
+									  </code><h4>Description</h4><para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Parse flag instructing the parser to create XML declaration node. By default, declaration node is not created. Can be combined with other flags by use of | operator. <br/><br/>
+ See <a href="#classrapidxml_1_1xml__document_8338ce6042e7b04d5a42144fb446b69c_18338ce6042e7b04d5a42144fb446b69c" kindref="member">xml_document::parse()</a> function. </para><p/><h3 class="reference-header" id="namespacerapidxml_0f7479dacbc868456d07897a8c072784_10f7479dacbc868456d07897a8c072784">
+				constant
+			 parse_comment_nodes</h3><h4>Synopsis</h4><code class="synopsis">const int parse_comment_nodes
+											  = 0x40;
+									  </code><h4>Description</h4><para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Parse flag instructing the parser to create comments nodes. By default, comment nodes are not created. Can be combined with other flags by use of | operator. <br/><br/>
+ See <a href="#classrapidxml_1_1xml__document_8338ce6042e7b04d5a42144fb446b69c_18338ce6042e7b04d5a42144fb446b69c" kindref="member">xml_document::parse()</a> function. </para><p/><h3 class="reference-header" id="namespacerapidxml_8e187746ba1ca04f107951ad32df962e_18e187746ba1ca04f107951ad32df962e">
+				constant
+			 parse_doctype_node</h3><h4>Synopsis</h4><code class="synopsis">const int parse_doctype_node
+											  = 0x80;
+									  </code><h4>Description</h4><para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Parse flag instructing the parser to create DOCTYPE node. By default, doctype node is not created. Although W3C specification allows at most one DOCTYPE node, RapidXml will silently accept documents with more than one. Can be combined with other flags by use of | operator. <br/><br/>
+ See <a href="#classrapidxml_1_1xml__document_8338ce6042e7b04d5a42144fb446b69c_18338ce6042e7b04d5a42144fb446b69c" kindref="member">xml_document::parse()</a> function. </para><p/><h3 class="reference-header" id="namespacerapidxml_1c20b2b2b75711cd76423e119c49f830_11c20b2b2b75711cd76423e119c49f830">
+				constant
+			 parse_pi_nodes</h3><h4>Synopsis</h4><code class="synopsis">const int parse_pi_nodes
+											  = 0x100;
+									  </code><h4>Description</h4><para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Parse flag instructing the parser to create PI nodes. By default, PI nodes are not created. Can be combined with other flags by use of | operator. <br/><br/>
+ See <a href="#classrapidxml_1_1xml__document_8338ce6042e7b04d5a42144fb446b69c_18338ce6042e7b04d5a42144fb446b69c" kindref="member">xml_document::parse()</a> function. </para><p/><h3 class="reference-header" id="namespacerapidxml_a5daff9d61c7d4eaf98e4d42efe628ee_1a5daff9d61c7d4eaf98e4d42efe628ee">
+				constant
+			 parse_validate_closing_tags</h3><h4>Synopsis</h4><code class="synopsis">const int parse_validate_closing_tags
+											  = 0x200;
+									  </code><h4>Description</h4><para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Parse flag instructing the parser to validate closing tag names. If not set, name inside closing tag is irrelevant to the parser. By default, closing tags are not validated. Can be combined with other flags by use of | operator. <br/><br/>
+ See <a href="#classrapidxml_1_1xml__document_8338ce6042e7b04d5a42144fb446b69c_18338ce6042e7b04d5a42144fb446b69c" kindref="member">xml_document::parse()</a> function. </para><p/><h3 class="reference-header" id="namespacerapidxml_ac1f06b1afd47b812732fb521b146fd9_1ac1f06b1afd47b812732fb521b146fd9">
+				constant
+			 parse_trim_whitespace</h3><h4>Synopsis</h4><code class="synopsis">const int parse_trim_whitespace
+											  = 0x400;
+									  </code><h4>Description</h4><para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Parse flag instructing the parser to trim all leading and trailing whitespace of data nodes. By default, whitespace is not trimmed. This flag does not cause the parser to modify source text. Can be combined with other flags by use of | operator. <br/><br/>
+ See <a href="#classrapidxml_1_1xml__document_8338ce6042e7b04d5a42144fb446b69c_18338ce6042e7b04d5a42144fb446b69c" kindref="member">xml_document::parse()</a> function. </para><p/><h3 class="reference-header" id="namespacerapidxml_88f95d4e275ba01408fefde83078651b_188f95d4e275ba01408fefde83078651b">
+				constant
+			 parse_normalize_whitespace</h3><h4>Synopsis</h4><code class="synopsis">const int parse_normalize_whitespace
+											  = 0x800;
+									  </code><h4>Description</h4><para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Parse flag instructing the parser to condense all whitespace runs of data nodes to a single space character. Trimming of leading and trailing whitespace of data is controlled by <a href="#namespacerapidxml_ac1f06b1afd47b812732fb521b146fd9_1ac1f06b1afd47b812732fb521b146fd9" kindref="member">rapidxml::parse_trim_whitespace</a> flag. By default, whitespace is not normalized. If this flag is specified, source text will be modified. Can be combined with other flags by use of | operator. <br/><br/>
+ See <a href="#classrapidxml_1_1xml__document_8338ce6042e7b04d5a42144fb446b69c_18338ce6042e7b04d5a42144fb446b69c" kindref="member">xml_document::parse()</a> function. </para><p/><h3 class="reference-header" id="namespacerapidxml_45751cf2f38fd6915f35b3122b46d5b6_145751cf2f38fd6915f35b3122b46d5b6">
+				constant
+			 parse_default</h3><h4>Synopsis</h4><code class="synopsis">const int parse_default
+											  = 0;
+									  </code><h4>Description</h4><para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Parse flags which represent default behaviour of the parser. This is always equal to 0, so that all other flags can be simply ored together. Normally there is no need to inconveniently disable flags by anding with their negated (~) values. This also means that meaning of each flag is a <i>negation</i> of the default setting. For example, if flag name is <a href="#namespacerapidxml_ccde57f6054857ee4042a1b4d98c83b9_1ccde57f6054857ee4042a1b4d98c83b9" kindref="member">rapidxml::parse_no_utf8</a>, it means that utf-8 is <i>enabled</i> by default, and using the flag will disable it. <br/><br/>
+ See <a href="#classrapidxml_1_1xml__document_8338ce6042e7b04d5a42144fb446b69c_18338ce6042e7b04d5a42144fb446b69c" kindref="member">xml_document::parse()</a> function. </para><p/><h3 class="reference-header" id="namespacerapidxml_a97ba1a0a79a6d66f4eef3612508d943_1a97ba1a0a79a6d66f4eef3612508d943">
+				constant
+			 parse_non_destructive</h3><h4>Synopsis</h4><code class="synopsis">const int parse_non_destructive
+											  = parse_no_string_terminators | parse_no_entity_translation;
+									  </code><h4>Description</h4><para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">A combination of parse flags that forbids any modifications of the source text. This also results in faster parsing. However, note that the following will occur: <ul><li><para>names and values of nodes will not be zero terminated, you have to use <a href="#classrapidxml_1_1xml__base_0dae694c8f7e4d89f1003e2f3a15a43c_10dae694c8f7e4d89f1003e2f3a15a43c" kindref="member">xml_base::name_size()</a> and <a href="#classrapidxml_1_1xml__base_aed5ae791b7164c1ee5e649198cbb3db_1aed5ae791b7164c1ee5e649198cbb3db" kindref="member">xml_base::value_size()</a> functions to determine where name and value ends </para></li><li><para>entities will not be translated </para></li><li><para>whitespace will not be normalized </para></li></ul>
+See <a href="#classrapidxml_1_1xml__document_8338ce6042e7b04d5a42144fb446b69c_18338ce6042e7b04d5a42144fb446b69c" kindref="member">xml_document::parse()</a> function. </para><p/><h3 class="reference-header" id="namespacerapidxml_398c5476e76102f8bd76c10bb0abbe10_1398c5476e76102f8bd76c10bb0abbe10">
+				constant
+			 parse_fastest</h3><h4>Synopsis</h4><code class="synopsis">const int parse_fastest
+											  = parse_non_destructive | parse_no_data_nodes;
+									  </code><h4>Description</h4><para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">A combination of parse flags resulting in fastest possible parsing, without sacrificing important data. <br/><br/>
+ See <a href="#classrapidxml_1_1xml__document_8338ce6042e7b04d5a42144fb446b69c_18338ce6042e7b04d5a42144fb446b69c" kindref="member">xml_document::parse()</a> function. </para><p/><h3 class="reference-header" id="namespacerapidxml_b4f2515265facb42291570307924bd57_1b4f2515265facb42291570307924bd57">
+				constant
+			 parse_full</h3><h4>Synopsis</h4><code class="synopsis">const int parse_full
+											  = parse_declaration_node | parse_comment_nodes | parse_doctype_node | parse_pi_nodes | parse_validate_closing_tags;
+									  </code><h4>Description</h4><para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">A combination of parse flags resulting in largest amount of data being extracted. This usually results in slowest parsing. <br/><br/>
+ See <a href="#classrapidxml_1_1xml__document_8338ce6042e7b04d5a42144fb446b69c_18338ce6042e7b04d5a42144fb446b69c" kindref="member">xml_document::parse()</a> function. </para><p/><h3 class="reference-header" id="namespacerapidxml_b08b8d4293c203b69ed6c5ae77ac1907_1b08b8d4293c203b69ed6c5ae77ac1907">
+				constant
+			 print_no_indenting</h3><h4>Synopsis</h4><code class="synopsis">const int print_no_indenting
+											  = 0x1;
+									  </code><h4>Description</h4><para xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Printer flag instructing the printer to suppress indenting of XML. See <a href="#namespacerapidxml_b94d570fc4c4ab2423813cd0243326b1_1b94d570fc4c4ab2423813cd0243326b1" kindref="member">print()</a> function. </para><p/></body></html>
\ No newline at end of file
diff --git a/lib/rapidxml/rapidxml.hpp b/lib/rapidxml/rapidxml.hpp
new file mode 100644
index 0000000..fb24a63
--- /dev/null
+++ b/lib/rapidxml/rapidxml.hpp
@@ -0,0 +1,2596 @@
+#ifndef RAPIDXML_HPP_INCLUDED
+#define RAPIDXML_HPP_INCLUDED
+
+// Copyright (C) 2006, 2009 Marcin Kalicinski
+// Version 1.13
+// Revision $DateTime: 2009/05/13 01:46:17 $
+//! \file rapidxml.hpp This file contains rapidxml parser and DOM implementation
+
+// If standard library is disabled, user must provide implementations of required functions and typedefs
+//#if !defined(RAPIDXML_NO_STDLIB)
+    #include <cstdlib>      // For std::size_t
+    #include <cassert>      // For assert
+    #include <new>          // For placement new
+//#endif
+
+// On MSVC, disable "conditional expression is constant" warning (level 4). 
+// This warning is almost impossible to avoid with certain types of templated code
+#ifdef _MSC_VER
+    #pragma warning(push)
+    #pragma warning(disable:4127)   // Conditional expression is constant
+#endif
+
+///////////////////////////////////////////////////////////////////////////
+// RAPIDXML_PARSE_ERROR
+    
+#if defined(RAPIDXML_NO_EXCEPTIONS)
+
+#define RAPIDXML_PARSE_ERROR(what, where) { parse_error_handler(what, where); assert(0); }
+
+namespace rapidxml
+{
+    //! When exceptions are disabled by defining RAPIDXML_NO_EXCEPTIONS, 
+    //! this function is called to notify user about the error.
+    //! It must be defined by the user.
+    //! <br><br>
+    //! This function cannot return. If it does, the results are undefined.
+    //! <br><br>
+    //! A very simple definition might look like that:
+    //! <pre>
+    //! void %rapidxml::%parse_error_handler(const char *what, void *where)
+    //! {
+    //!     std::cout << "Parse error: " << what << "\n";
+    //!     std::abort();
+    //! }
+    //! </pre>
+    //! \param what Human readable description of the error.
+    //! \param where Pointer to character data where error was detected.
+    void parse_error_handler(const char *what, void *where);
+}
+
+#else
+    
+#include <exception>    // For std::exception
+
+#define RAPIDXML_PARSE_ERROR(what, where) throw parse_error(what, where)
+
+namespace rapidxml
+{
+
+    //! Parse error exception. 
+    //! This exception is thrown by the parser when an error occurs. 
+    //! Use what() function to get human-readable error message. 
+    //! Use where() function to get a pointer to position within source text where error was detected.
+    //! <br><br>
+    //! If throwing exceptions by the parser is undesirable, 
+    //! it can be disabled by defining RAPIDXML_NO_EXCEPTIONS macro before rapidxml.hpp is included.
+    //! This will cause the parser to call rapidxml::parse_error_handler() function instead of throwing an exception.
+    //! This function must be defined by the user.
+    //! <br><br>
+    //! This class derives from <code>std::exception</code> class.
+    class parse_error: public std::exception
+    {
+    
+    public:
+    
+        //! Constructs parse error
+        parse_error(const char *what, void *where)
+            : m_what(what)
+            , m_where(where)
+        {
+        }
+
+        //! Gets human readable description of error.
+        //! \return Pointer to null terminated description of the error.
+        virtual const char *what() const throw()
+        {
+            return m_what;
+        }
+
+        //! Gets pointer to character data where error happened.
+        //! Ch should be the same as char type of xml_document that produced the error.
+        //! \return Pointer to location within the parsed string where error occured.
+        template<class Ch>
+        Ch *where() const
+        {
+            return reinterpret_cast<Ch *>(m_where);
+        }
+
+    private:  
+
+        const char *m_what;
+        void *m_where;
+
+    };
+}
+
+#endif
+
+///////////////////////////////////////////////////////////////////////////
+// Pool sizes
+
+#ifndef RAPIDXML_STATIC_POOL_SIZE
+    // Size of static memory block of memory_pool.
+    // Define RAPIDXML_STATIC_POOL_SIZE before including rapidxml.hpp if you want to override the default value.
+    // No dynamic memory allocations are performed by memory_pool until static memory is exhausted.
+    #define RAPIDXML_STATIC_POOL_SIZE (64 * 1024)
+#endif
+
+#ifndef RAPIDXML_DYNAMIC_POOL_SIZE
+    // Size of dynamic memory block of memory_pool.
+    // Define RAPIDXML_DYNAMIC_POOL_SIZE before including rapidxml.hpp if you want to override the default value.
+    // After the static block is exhausted, dynamic blocks with approximately this size are allocated by memory_pool.
+    #define RAPIDXML_DYNAMIC_POOL_SIZE (64 * 1024)
+#endif
+
+#ifndef RAPIDXML_ALIGNMENT
+    // Memory allocation alignment.
+    // Define RAPIDXML_ALIGNMENT before including rapidxml.hpp if you want to override the default value, which is the size of pointer.
+    // All memory allocations for nodes, attributes and strings will be aligned to this value.
+    // This must be a power of 2 and at least 1, otherwise memory_pool will not work.
+    #define RAPIDXML_ALIGNMENT sizeof(void *)
+#endif
+
+namespace rapidxml
+{
+    // Forward declarations
+    template<class Ch> class xml_node;
+    template<class Ch> class xml_attribute;
+    template<class Ch> class xml_document;
+    
+    //! Enumeration listing all node types produced by the parser.
+    //! Use xml_node::type() function to query node type.
+    enum node_type
+    {
+        node_document,      //!< A document node. Name and value are empty.
+        node_element,       //!< An element node. Name contains element name. Value contains text of first data node.
+        node_data,          //!< A data node. Name is empty. Value contains data text.
+        node_cdata,         //!< A CDATA node. Name is empty. Value contains data text.
+        node_comment,       //!< A comment node. Name is empty. Value contains comment text.
+        node_declaration,   //!< A declaration node. Name and value are empty. Declaration parameters (version, encoding and standalone) are in node attributes.
+        node_doctype,       //!< A DOCTYPE node. Name is empty. Value contains DOCTYPE text.
+        node_pi             //!< A PI node. Name contains target. Value contains instructions.
+    };
+
+    ///////////////////////////////////////////////////////////////////////
+    // Parsing flags
+
+    //! Parse flag instructing the parser to not create data nodes. 
+    //! Text of first data node will still be placed in value of parent element, unless rapidxml::parse_no_element_values flag is also specified.
+    //! Can be combined with other flags by use of | operator.
+    //! <br><br>
+    //! See xml_document::parse() function.
+    const int parse_no_data_nodes = 0x1;            
+
+    //! Parse flag instructing the parser to not use text of first data node as a value of parent element.
+    //! Can be combined with other flags by use of | operator.
+    //! Note that child data nodes of element node take precendence over its value when printing. 
+    //! That is, if element has one or more child data nodes <em>and</em> a value, the value will be ignored.
+    //! Use rapidxml::parse_no_data_nodes flag to prevent creation of data nodes if you want to manipulate data using values of elements.
+    //! <br><br>
+    //! See xml_document::parse() function.
+    const int parse_no_element_values = 0x2;
+    
+    //! Parse flag instructing the parser to not place zero terminators after strings in the source text.
+    //! By default zero terminators are placed, modifying source text.
+    //! Can be combined with other flags by use of | operator.
+    //! <br><br>
+    //! See xml_document::parse() function.
+    const int parse_no_string_terminators = 0x4;
+    
+    //! Parse flag instructing the parser to not translate entities in the source text.
+    //! By default entities are translated, modifying source text.
+    //! Can be combined with other flags by use of | operator.
+    //! <br><br>
+    //! See xml_document::parse() function.
+    const int parse_no_entity_translation = 0x8;
+    
+    //! Parse flag instructing the parser to disable UTF-8 handling and assume plain 8 bit characters.
+    //! By default, UTF-8 handling is enabled.
+    //! Can be combined with other flags by use of | operator.
+    //! <br><br>
+    //! See xml_document::parse() function.
+    const int parse_no_utf8 = 0x10;
+    
+    //! Parse flag instructing the parser to create XML declaration node.
+    //! By default, declaration node is not created.
+    //! Can be combined with other flags by use of | operator.
+    //! <br><br>
+    //! See xml_document::parse() function.
+    const int parse_declaration_node = 0x20;
+    
+    //! Parse flag instructing the parser to create comments nodes.
+    //! By default, comment nodes are not created.
+    //! Can be combined with other flags by use of | operator.
+    //! <br><br>
+    //! See xml_document::parse() function.
+    const int parse_comment_nodes = 0x40;
+    
+    //! Parse flag instructing the parser to create DOCTYPE node.
+    //! By default, doctype node is not created.
+    //! Although W3C specification allows at most one DOCTYPE node, RapidXml will silently accept documents with more than one.
+    //! Can be combined with other flags by use of | operator.
+    //! <br><br>
+    //! See xml_document::parse() function.
+    const int parse_doctype_node = 0x80;
+    
+    //! Parse flag instructing the parser to create PI nodes.
+    //! By default, PI nodes are not created.
+    //! Can be combined with other flags by use of | operator.
+    //! <br><br>
+    //! See xml_document::parse() function.
+    const int parse_pi_nodes = 0x100;
+    
+    //! Parse flag instructing the parser to validate closing tag names. 
+    //! If not set, name inside closing tag is irrelevant to the parser.
+    //! By default, closing tags are not validated.
+    //! Can be combined with other flags by use of | operator.
+    //! <br><br>
+    //! See xml_document::parse() function.
+    const int parse_validate_closing_tags = 0x200;
+    
+    //! Parse flag instructing the parser to trim all leading and trailing whitespace of data nodes.
+    //! By default, whitespace is not trimmed. 
+    //! This flag does not cause the parser to modify source text.
+    //! Can be combined with other flags by use of | operator.
+    //! <br><br>
+    //! See xml_document::parse() function.
+    const int parse_trim_whitespace = 0x400;
+
+    //! Parse flag instructing the parser to condense all whitespace runs of data nodes to a single space character.
+    //! Trimming of leading and trailing whitespace of data is controlled by rapidxml::parse_trim_whitespace flag.
+    //! By default, whitespace is not normalized. 
+    //! If this flag is specified, source text will be modified.
+    //! Can be combined with other flags by use of | operator.
+    //! <br><br>
+    //! See xml_document::parse() function.
+    const int parse_normalize_whitespace = 0x800;
+
+    // Compound flags
+    
+    //! Parse flags which represent default behaviour of the parser. 
+    //! This is always equal to 0, so that all other flags can be simply ored together.
+    //! Normally there is no need to inconveniently disable flags by anding with their negated (~) values.
+    //! This also means that meaning of each flag is a <i>negation</i> of the default setting. 
+    //! For example, if flag name is rapidxml::parse_no_utf8, it means that utf-8 is <i>enabled</i> by default,
+    //! and using the flag will disable it.
+    //! <br><br>
+    //! See xml_document::parse() function.
+    const int parse_default = 0;
+    
+    //! A combination of parse flags that forbids any modifications of the source text. 
+    //! This also results in faster parsing. However, note that the following will occur:
+    //! <ul>
+    //! <li>names and values of nodes will not be zero terminated, you have to use xml_base::name_size() and xml_base::value_size() functions to determine where name and value ends</li>
+    //! <li>entities will not be translated</li>
+    //! <li>whitespace will not be normalized</li>
+    //! </ul>
+    //! See xml_document::parse() function.
+    const int parse_non_destructive = parse_no_string_terminators | parse_no_entity_translation;
+    
+    //! A combination of parse flags resulting in fastest possible parsing, without sacrificing important data.
+    //! <br><br>
+    //! See xml_document::parse() function.
+    const int parse_fastest = parse_non_destructive | parse_no_data_nodes;
+    
+    //! A combination of parse flags resulting in largest amount of data being extracted. 
+    //! This usually results in slowest parsing.
+    //! <br><br>
+    //! See xml_document::parse() function.
+    const int parse_full = parse_declaration_node | parse_comment_nodes | parse_doctype_node | parse_pi_nodes | parse_validate_closing_tags;
+
+    ///////////////////////////////////////////////////////////////////////
+    // Internals
+
+    //! \cond internal
+    namespace internal
+    {
+
+        // Struct that contains lookup tables for the parser
+        // It must be a template to allow correct linking (because it has static data members, which are defined in a header file).
+        template<int Dummy>
+        struct lookup_tables
+        {
+            static const unsigned char lookup_whitespace[256];              // Whitespace table
+            static const unsigned char lookup_node_name[256];               // Node name table
+            static const unsigned char lookup_text[256];                    // Text table
+            static const unsigned char lookup_text_pure_no_ws[256];         // Text table
+            static const unsigned char lookup_text_pure_with_ws[256];       // Text table
+            static const unsigned char lookup_attribute_name[256];          // Attribute name table
+            static const unsigned char lookup_attribute_data_1[256];        // Attribute data table with single quote
+            static const unsigned char lookup_attribute_data_1_pure[256];   // Attribute data table with single quote
+            static const unsigned char lookup_attribute_data_2[256];        // Attribute data table with double quotes
+            static const unsigned char lookup_attribute_data_2_pure[256];   // Attribute data table with double quotes
+            static const unsigned char lookup_digits[256];                  // Digits
+            static const unsigned char lookup_upcase[256];                  // To uppercase conversion table for ASCII characters
+        };
+
+        // Find length of the string
+        template<class Ch>
+        inline std::size_t measure(const Ch *p)
+        {
+            const Ch *tmp = p;
+            while (*tmp) 
+                ++tmp;
+            return tmp - p;
+        }
+
+        // Compare strings for equality
+        template<class Ch>
+        inline bool compare(const Ch *p1, std::size_t size1, const Ch *p2, std::size_t size2, bool case_sensitive)
+        {
+            if (size1 != size2)
+                return false;
+            if (case_sensitive)
+            {
+                for (const Ch *end = p1 + size1; p1 < end; ++p1, ++p2)
+                    if (*p1 != *p2)
+                        return false;
+            }
+            else
+            {
+                for (const Ch *end = p1 + size1; p1 < end; ++p1, ++p2)
+                    if (lookup_tables<0>::lookup_upcase[static_cast<unsigned char>(*p1)] != lookup_tables<0>::lookup_upcase[static_cast<unsigned char>(*p2)])
+                        return false;
+            }
+            return true;
+        }
+    }
+    //! \endcond
+
+    ///////////////////////////////////////////////////////////////////////
+    // Memory pool
+    
+    //! This class is used by the parser to create new nodes and attributes, without overheads of dynamic memory allocation.
+    //! In most cases, you will not need to use this class directly. 
+    //! However, if you need to create nodes manually or modify names/values of nodes, 
+    //! you are encouraged to use memory_pool of relevant xml_document to allocate the memory. 
+    //! Not only is this faster than allocating them by using <code>new</code> operator, 
+    //! but also their lifetime will be tied to the lifetime of document, 
+    //! possibly simplyfing memory management. 
+    //! <br><br>
+    //! Call allocate_node() or allocate_attribute() functions to obtain new nodes or attributes from the pool. 
+    //! You can also call allocate_string() function to allocate strings.
+    //! Such strings can then be used as names or values of nodes without worrying about their lifetime.
+    //! Note that there is no <code>free()</code> function -- all allocations are freed at once when clear() function is called, 
+    //! or when the pool is destroyed.
+    //! <br><br>
+    //! It is also possible to create a standalone memory_pool, and use it 
+    //! to allocate nodes, whose lifetime will not be tied to any document.
+    //! <br><br>
+    //! Pool maintains <code>RAPIDXML_STATIC_POOL_SIZE</code> bytes of statically allocated memory. 
+    //! Until static memory is exhausted, no dynamic memory allocations are done.
+    //! When static memory is exhausted, pool allocates additional blocks of memory of size <code>RAPIDXML_DYNAMIC_POOL_SIZE</code> each,
+    //! by using global <code>new[]</code> and <code>delete[]</code> operators. 
+    //! This behaviour can be changed by setting custom allocation routines. 
+    //! Use set_allocator() function to set them.
+    //! <br><br>
+    //! Allocations for nodes, attributes and strings are aligned at <code>RAPIDXML_ALIGNMENT</code> bytes.
+    //! This value defaults to the size of pointer on target architecture.
+    //! <br><br>
+    //! To obtain absolutely top performance from the parser,
+    //! it is important that all nodes are allocated from a single, contiguous block of memory.
+    //! Otherwise, cache misses when jumping between two (or more) disjoint blocks of memory can slow down parsing quite considerably.
+    //! If required, you can tweak <code>RAPIDXML_STATIC_POOL_SIZE</code>, <code>RAPIDXML_DYNAMIC_POOL_SIZE</code> and <code>RAPIDXML_ALIGNMENT</code> 
+    //! to obtain best wasted memory to performance compromise.
+    //! To do it, define their values before rapidxml.hpp file is included.
+    //! \param Ch Character type of created nodes. 
+    template<class Ch = char>
+    class memory_pool
+    {
+        
+    public:
+
+        //! \cond internal
+        typedef void *(alloc_func1)(std::size_t);       // Type of user-defined function used to allocate memory
+        typedef void (free_func)(void *);              // Type of user-defined function used to free memory
+        //! \endcond
+        
+        //! Constructs empty pool with default allocator functions.
+        memory_pool()
+            : m_alloc_func(0)
+            , m_free_func(0)
+        {
+            init();
+        }
+
+        //! Destroys pool and frees all the memory. 
+        //! This causes memory occupied by nodes allocated by the pool to be freed.
+        //! Nodes allocated from the pool are no longer valid.
+        ~memory_pool()
+        {
+            clear();
+        }
+
+        //! Allocates a new node from the pool, and optionally assigns name and value to it. 
+        //! If the allocation request cannot be accomodated, this function will throw <code>std::bad_alloc</code>.
+        //! If exceptions are disabled by defining RAPIDXML_NO_EXCEPTIONS, this function
+        //! will call rapidxml::parse_error_handler() function.
+        //! \param type Type of node to create.
+        //! \param name Name to assign to the node, or 0 to assign no name.
+        //! \param value Value to assign to the node, or 0 to assign no value.
+        //! \param name_size Size of name to assign, or 0 to automatically calculate size from name string.
+        //! \param value_size Size of value to assign, or 0 to automatically calculate size from value string.
+        //! \return Pointer to allocated node. This pointer will never be NULL.
+        xml_node<Ch> *allocate_node(node_type type, 
+                                    const Ch *name = 0, const Ch *value = 0, 
+                                    std::size_t name_size = 0, std::size_t value_size = 0)
+        {
+            void *memory = allocate_aligned(sizeof(xml_node<Ch>));
+            xml_node<Ch> *node = new(memory) xml_node<Ch>(type);
+            if (name)
+            {
+                if (name_size > 0)
+                    node->name(name, name_size);
+                else
+                    node->name(name);
+            }
+            if (value)
+            {
+                if (value_size > 0)
+                    node->value(value, value_size);
+                else
+                    node->value(value);
+            }
+            return node;
+        }
+
+        //! Allocates a new attribute from the pool, and optionally assigns name and value to it.
+        //! If the allocation request cannot be accomodated, this function will throw <code>std::bad_alloc</code>.
+        //! If exceptions are disabled by defining RAPIDXML_NO_EXCEPTIONS, this function
+        //! will call rapidxml::parse_error_handler() function.
+        //! \param name Name to assign to the attribute, or 0 to assign no name.
+        //! \param value Value to assign to the attribute, or 0 to assign no value.
+        //! \param name_size Size of name to assign, or 0 to automatically calculate size from name string.
+        //! \param value_size Size of value to assign, or 0 to automatically calculate size from value string.
+        //! \return Pointer to allocated attribute. This pointer will never be NULL.
+        xml_attribute<Ch> *allocate_attribute(const Ch *name = 0, const Ch *value = 0, 
+                                              std::size_t name_size = 0, std::size_t value_size = 0)
+        {
+            void *memory = allocate_aligned(sizeof(xml_attribute<Ch>));
+            xml_attribute<Ch> *attribute = new(memory) xml_attribute<Ch>;
+            if (name)
+            {
+                if (name_size > 0)
+                    attribute->name(name, name_size);
+                else
+                    attribute->name(name);
+            }
+            if (value)
+            {
+                if (value_size > 0)
+                    attribute->value(value, value_size);
+                else
+                    attribute->value(value);
+            }
+            return attribute;
+        }
+
+        //! Allocates a char array of given size from the pool, and optionally copies a given string to it.
+        //! If the allocation request cannot be accomodated, this function will throw <code>std::bad_alloc</code>.
+        //! If exceptions are disabled by defining RAPIDXML_NO_EXCEPTIONS, this function
+        //! will call rapidxml::parse_error_handler() function.
+        //! \param source String to initialize the allocated memory with, or 0 to not initialize it.
+        //! \param size Number of characters to allocate, or zero to calculate it automatically from source string length; if size is 0, source string must be specified and null terminated.
+        //! \return Pointer to allocated char array. This pointer will never be NULL.
+        Ch *allocate_string(const Ch *source = 0, std::size_t size = 0)
+        {
+            assert(source || size);     // Either source or size (or both) must be specified
+            if (size == 0)
+                size = internal::measure(source) + 1;
+            Ch *result = static_cast<Ch *>(allocate_aligned(size * sizeof(Ch)));
+            if (source)
+                for (std::size_t i = 0; i < size; ++i)
+                    result[i] = source[i];
+            return result;
+        }
+
+        //! Clones an xml_node and its hierarchy of child nodes and attributes.
+        //! Nodes and attributes are allocated from this memory pool.
+        //! Names and values are not cloned, they are shared between the clone and the source.
+        //! Result node can be optionally specified as a second parameter, 
+        //! in which case its contents will be replaced with cloned source node.
+        //! This is useful when you want to clone entire document.
+        //! \param source Node to clone.
+        //! \param result Node to put results in, or 0 to automatically allocate result node
+        //! \return Pointer to cloned node. This pointer will never be NULL.
+        xml_node<Ch> *clone_node(const xml_node<Ch> *source, xml_node<Ch> *result = 0)
+        {
+            // Prepare result node
+            if (result)
+            {
+                result->remove_all_attributes();
+                result->remove_all_nodes();
+                result->type(source->type());
+            }
+            else
+                result = allocate_node(source->type());
+
+            // Clone name and value
+            result->name(source->name(), source->name_size());
+            result->value(source->value(), source->value_size());
+
+            // Clone child nodes and attributes
+            for (xml_node<Ch> *child = source->first_node(); child; child = child->next_sibling())
+                result->append_node(clone_node(child));
+            for (xml_attribute<Ch> *attr = source->first_attribute(); attr; attr = attr->next_attribute())
+                result->append_attribute(allocate_attribute(attr->name(), attr->value(), attr->name_size(), attr->value_size()));
+
+            return result;
+        }
+
+        //! Clears the pool. 
+        //! This causes memory occupied by nodes allocated by the pool to be freed.
+        //! Any nodes or strings allocated from the pool will no longer be valid.
+        void clear()
+        {
+            while (m_begin != m_static_memory)
+            {
+                char *previous_begin = reinterpret_cast<header *>(align(m_begin))->previous_begin;
+                if (m_free_func)
+                    m_free_func(m_begin);
+                else
+                    delete[] m_begin;
+                m_begin = previous_begin;
+            }
+            init();
+        }
+
+        //! Sets or resets the user-defined memory allocation functions for the pool.
+        //! This can only be called when no memory is allocated from the pool yet, otherwise results are undefined.
+        //! Allocation function must not return invalid pointer on failure. It should either throw,
+        //! stop the program, or use <code>longjmp()</code> function to pass control to other place of program. 
+        //! If it returns invalid pointer, results are undefined.
+        //! <br><br>
+        //! User defined allocation functions must have the following forms:
+        //! <br><code>
+        //! <br>void *allocate(std::size_t size);
+        //! <br>void free(void *pointer);
+        //! </code><br>
+        //! \param af Allocation function, or 0 to restore default function
+        //! \param ff Free function, or 0 to restore default function
+        void set_allocator(alloc_func1 *af, free_func *ff)
+        {
+            assert(m_begin == m_static_memory && m_ptr == align(m_begin));    // Verify that no memory is allocated yet
+            m_alloc_func = af;
+            m_free_func = ff;
+        }
+
+    private:
+
+        struct header
+        {
+            char *previous_begin;
+        };
+
+        void init()
+        {
+            m_begin = m_static_memory;
+            m_ptr = align(m_begin);
+            m_end = m_static_memory + sizeof(m_static_memory);
+        }
+        
+        char *align(char *ptr)
+        {
+            std::size_t alignment = ((RAPIDXML_ALIGNMENT - (std::size_t(ptr) & (RAPIDXML_ALIGNMENT - 1))) & (RAPIDXML_ALIGNMENT - 1));
+            return ptr + alignment;
+        }
+        
+        char *allocate_raw(std::size_t size)
+        {
+            // Allocate
+            void *memory;   
+            if (m_alloc_func)   // Allocate memory using either user-specified allocation function or global operator new[]
+            {
+                memory = m_alloc_func(size);
+                assert(memory); // Allocator is not allowed to return 0, on failure it must either throw, stop the program or use longjmp
+            }
+            else
+            {
+                memory = new char[size];
+#ifdef RAPIDXML_NO_EXCEPTIONS
+                if (!memory)            // If exceptions are disabled, verify memory allocation, because new will not be able to throw bad_alloc
+                    RAPIDXML_PARSE_ERROR("out of memory", 0);
+#endif
+            }
+            return static_cast<char *>(memory);
+        }
+        
+        void *allocate_aligned(std::size_t size)
+        {
+            // Calculate aligned pointer
+            char *result = align(m_ptr);
+
+            // If not enough memory left in current pool, allocate a new pool
+            if (result + size > m_end)
+            {
+                // Calculate required pool size (may be bigger than RAPIDXML_DYNAMIC_POOL_SIZE)
+                std::size_t pool_size = RAPIDXML_DYNAMIC_POOL_SIZE;
+                if (pool_size < size)
+                    pool_size = size;
+                
+                // Allocate
+                std::size_t alloc_size = sizeof(header) + (2 * RAPIDXML_ALIGNMENT - 2) + pool_size;     // 2 alignments required in worst case: one for header, one for actual allocation
+                char *raw_memory = allocate_raw(alloc_size);
+                    
+                // Setup new pool in allocated memory
+                char *pool = align(raw_memory);
+                header *new_header = reinterpret_cast<header *>(pool);
+                new_header->previous_begin = m_begin;
+                m_begin = raw_memory;
+                m_ptr = pool + sizeof(header);
+                m_end = raw_memory + alloc_size;
+
+                // Calculate aligned pointer again using new pool
+                result = align(m_ptr);
+            }
+
+            // Update pool and return aligned pointer
+            m_ptr = result + size;
+            return result;
+        }
+
+        char *m_begin;                                      // Start of raw memory making up current pool
+        char *m_ptr;                                        // First free byte in current pool
+        char *m_end;                                        // One past last available byte in current pool
+        char m_static_memory[RAPIDXML_STATIC_POOL_SIZE];    // Static raw memory
+        alloc_func1 *m_alloc_func;                           // Allocator function, or 0 if default is to be used
+        free_func *m_free_func;                             // Free function, or 0 if default is to be used
+    };
+
+    ///////////////////////////////////////////////////////////////////////////
+    // XML base
+
+    //! Base class for xml_node and xml_attribute implementing common functions: 
+    //! name(), name_size(), value(), value_size() and parent().
+    //! \param Ch Character type to use
+    template<class Ch = char>
+    class xml_base
+    {
+
+    public:
+        
+        ///////////////////////////////////////////////////////////////////////////
+        // Construction & destruction
+    
+        // Construct a base with empty name, value and parent
+        xml_base()
+            : m_name(0)
+            , m_value(0)
+            , m_parent(0)
+        {
+        }
+
+        ///////////////////////////////////////////////////////////////////////////
+        // Node data access
+    
+        //! Gets name of the node. 
+        //! Interpretation of name depends on type of node.
+        //! Note that name will not be zero-terminated if rapidxml::parse_no_string_terminators option was selected during parse.
+        //! <br><br>
+        //! Use name_size() function to determine length of the name.
+        //! \return Name of node, or empty string if node has no name.
+        Ch *name() const
+        {
+            return m_name ? m_name : nullstr();
+        }
+
+        //! Gets size of node name, not including terminator character.
+        //! This function works correctly irrespective of whether name is or is not zero terminated.
+        //! \return Size of node name, in characters.
+        std::size_t name_size() const
+        {
+            return m_name ? m_name_size : 0;
+        }
+
+        //! Gets value of node. 
+        //! Interpretation of value depends on type of node.
+        //! Note that value will not be zero-terminated if rapidxml::parse_no_string_terminators option was selected during parse.
+        //! <br><br>
+        //! Use value_size() function to determine length of the value.
+        //! \return Value of node, or empty string if node has no value.
+        Ch *value() const
+        {
+            return m_value ? m_value : nullstr();
+        }
+
+        //! Gets size of node value, not including terminator character.
+        //! This function works correctly irrespective of whether value is or is not zero terminated.
+        //! \return Size of node value, in characters.
+        std::size_t value_size() const
+        {
+            return m_value ? m_value_size : 0;
+        }
+
+        ///////////////////////////////////////////////////////////////////////////
+        // Node modification
+    
+        //! Sets name of node to a non zero-terminated string.
+        //! See \ref ownership_of_strings.
+        //! <br><br>
+        //! Note that node does not own its name or value, it only stores a pointer to it. 
+        //! It will not delete or otherwise free the pointer on destruction.
+        //! It is reponsibility of the user to properly manage lifetime of the string.
+        //! The easiest way to achieve it is to use memory_pool of the document to allocate the string -
+        //! on destruction of the document the string will be automatically freed.
+        //! <br><br>
+        //! Size of name must be specified separately, because name does not have to be zero terminated.
+        //! Use name(const Ch *) function to have the length automatically calculated (string must be zero terminated).
+        //! \param name Name of node to set. Does not have to be zero terminated.
+        //! \param size Size of name, in characters. This does not include zero terminator, if one is present.
+        void name(const Ch *name, std::size_t size)
+        {
+            m_name = const_cast<Ch *>(name);
+            m_name_size = size;
+        }
+
+        //! Sets name of node to a zero-terminated string.
+        //! See also \ref ownership_of_strings and xml_node::name(const Ch *, std::size_t).
+        //! \param name Name of node to set. Must be zero terminated.
+        void name(const Ch *name)
+        {
+            this->name(name, internal::measure(name));
+        }
+
+        //! Sets value of node to a non zero-terminated string.
+        //! See \ref ownership_of_strings.
+        //! <br><br>
+        //! Note that node does not own its name or value, it only stores a pointer to it. 
+        //! It will not delete or otherwise free the pointer on destruction.
+        //! It is reponsibility of the user to properly manage lifetime of the string.
+        //! The easiest way to achieve it is to use memory_pool of the document to allocate the string -
+        //! on destruction of the document the string will be automatically freed.
+        //! <br><br>
+        //! Size of value must be specified separately, because it does not have to be zero terminated.
+        //! Use value(const Ch *) function to have the length automatically calculated (string must be zero terminated).
+        //! <br><br>
+        //! If an element has a child node of type node_data, it will take precedence over element value when printing.
+        //! If you want to manipulate data of elements using values, use parser flag rapidxml::parse_no_data_nodes to prevent creation of data nodes by the parser.
+        //! \param value value of node to set. Does not have to be zero terminated.
+        //! \param size Size of value, in characters. This does not include zero terminator, if one is present.
+        void value(const Ch *value, std::size_t size)
+        {
+            m_value = const_cast<Ch *>(value);
+            m_value_size = size;
+        }
+
+        //! Sets value of node to a zero-terminated string.
+        //! See also \ref ownership_of_strings and xml_node::value(const Ch *, std::size_t).
+        //! \param value Vame of node to set. Must be zero terminated.
+        void value(const Ch *value)
+        {
+            this->value(value, internal::measure(value));
+        }
+
+        ///////////////////////////////////////////////////////////////////////////
+        // Related nodes access
+    
+        //! Gets node parent.
+        //! \return Pointer to parent node, or 0 if there is no parent.
+        xml_node<Ch> *parent() const
+        {
+            return m_parent;
+        }
+
+    protected:
+
+        // Return empty string
+        static Ch *nullstr()
+        {
+            static Ch zero = Ch('\0');
+            return &zero;
+        }
+
+        Ch *m_name;                         // Name of node, or 0 if no name
+        Ch *m_value;                        // Value of node, or 0 if no value
+        std::size_t m_name_size;            // Length of node name, or undefined of no name
+        std::size_t m_value_size;           // Length of node value, or undefined if no value
+        xml_node<Ch> *m_parent;             // Pointer to parent node, or 0 if none
+
+    };
+
+    //! Class representing attribute node of XML document. 
+    //! Each attribute has name and value strings, which are available through name() and value() functions (inherited from xml_base).
+    //! Note that after parse, both name and value of attribute will point to interior of source text used for parsing. 
+    //! Thus, this text must persist in memory for the lifetime of attribute.
+    //! \param Ch Character type to use.
+    template<class Ch = char>
+    class xml_attribute: public xml_base<Ch>
+    {
+
+        friend class xml_node<Ch>;
+    
+    public:
+
+        ///////////////////////////////////////////////////////////////////////////
+        // Construction & destruction
+    
+        //! Constructs an empty attribute with the specified type. 
+        //! Consider using memory_pool of appropriate xml_document if allocating attributes manually.
+        xml_attribute()
+        {
+        }
+
+        ///////////////////////////////////////////////////////////////////////////
+        // Related nodes access
+    
+        //! Gets document of which attribute is a child.
+        //! \return Pointer to document that contains this attribute, or 0 if there is no parent document.
+        xml_document<Ch> *document() const
+        {
+            if (xml_node<Ch> *node = this->parent())
+            {
+                while (node->parent())
+                    node = node->parent();
+                return node->type() == node_document ? static_cast<xml_document<Ch> *>(node) : 0;
+            }
+            else
+                return 0;
+        }
+
+        //! Gets previous attribute, optionally matching attribute name. 
+        //! \param name Name of attribute to find, or 0 to return previous attribute regardless of its name; this string doesn't have to be zero-terminated if name_size is non-zero
+        //! \param name_size Size of name, in characters, or 0 to have size calculated automatically from string
+        //! \param case_sensitive Should name comparison be case-sensitive; non case-sensitive comparison works properly only for ASCII characters
+        //! \return Pointer to found attribute, or 0 if not found.
+        xml_attribute<Ch> *previous_attribute(const Ch *name = 0, std::size_t name_size = 0, bool case_sensitive = true) const
+        {
+            if (name)
+            {
+                if (name_size == 0)
+                    name_size = internal::measure(name);
+                for (xml_attribute<Ch> *attribute = m_prev_attribute; attribute; attribute = attribute->m_prev_attribute)
+                    if (internal::compare(attribute->name(), attribute->name_size(), name, name_size, case_sensitive))
+                        return attribute;
+                return 0;
+            }
+            else
+                return this->m_parent ? m_prev_attribute : 0;
+        }
+
+        //! Gets next attribute, optionally matching attribute name. 
+        //! \param name Name of attribute to find, or 0 to return next attribute regardless of its name; this string doesn't have to be zero-terminated if name_size is non-zero
+        //! \param name_size Size of name, in characters, or 0 to have size calculated automatically from string
+        //! \param case_sensitive Should name comparison be case-sensitive; non case-sensitive comparison works properly only for ASCII characters
+        //! \return Pointer to found attribute, or 0 if not found.
+        xml_attribute<Ch> *next_attribute(const Ch *name = 0, std::size_t name_size = 0, bool case_sensitive = true) const
+        {
+            if (name)
+            {
+                if (name_size == 0)
+                    name_size = internal::measure(name);
+                for (xml_attribute<Ch> *attribute = m_next_attribute; attribute; attribute = attribute->m_next_attribute)
+                    if (internal::compare(attribute->name(), attribute->name_size(), name, name_size, case_sensitive))
+                        return attribute;
+                return 0;
+            }
+            else
+                return this->m_parent ? m_next_attribute : 0;
+        }
+
+    private:
+
+        xml_attribute<Ch> *m_prev_attribute;        // Pointer to previous sibling of attribute, or 0 if none; only valid if parent is non-zero
+        xml_attribute<Ch> *m_next_attribute;        // Pointer to next sibling of attribute, or 0 if none; only valid if parent is non-zero
+    
+    };
+
+    ///////////////////////////////////////////////////////////////////////////
+    // XML node
+
+    //! Class representing a node of XML document. 
+    //! Each node may have associated name and value strings, which are available through name() and value() functions. 
+    //! Interpretation of name and value depends on type of the node.
+    //! Type of node can be determined by using type() function.
+    //! <br><br>
+    //! Note that after parse, both name and value of node, if any, will point interior of source text used for parsing. 
+    //! Thus, this text must persist in the memory for the lifetime of node.
+    //! \param Ch Character type to use.
+    template<class Ch = char>
+    class xml_node: public xml_base<Ch>
+    {
+
+    public:
+
+        ///////////////////////////////////////////////////////////////////////////
+        // Construction & destruction
+    
+        //! Constructs an empty node with the specified type. 
+        //! Consider using memory_pool of appropriate document to allocate nodes manually.
+        //! \param type Type of node to construct.
+        xml_node(node_type type)
+            : m_type(type)
+            , m_first_node(0)
+            , m_first_attribute(0)
+        {
+        }
+
+        ///////////////////////////////////////////////////////////////////////////
+        // Node data access
+    
+        //! Gets type of node.
+        //! \return Type of node.
+        node_type type() const
+        {
+            return m_type;
+        }
+
+        ///////////////////////////////////////////////////////////////////////////
+        // Related nodes access
+    
+        //! Gets document of which node is a child.
+        //! \return Pointer to document that contains this node, or 0 if there is no parent document.
+        xml_document<Ch> *document() const
+        {
+            xml_node<Ch> *node = const_cast<xml_node<Ch> *>(this);
+            while (node->parent())
+                node = node->parent();
+            return node->type() == node_document ? static_cast<xml_document<Ch> *>(node) : 0;
+        }
+
+        //! Gets first child node, optionally matching node name.
+        //! \param name Name of child to find, or 0 to return first child regardless of its name; this string doesn't have to be zero-terminated if name_size is non-zero
+        //! \param name_size Size of name, in characters, or 0 to have size calculated automatically from string
+        //! \param case_sensitive Should name comparison be case-sensitive; non case-sensitive comparison works properly only for ASCII characters
+        //! \return Pointer to found child, or 0 if not found.
+        xml_node<Ch> *first_node(const Ch *name = 0, std::size_t name_size = 0, bool case_sensitive = true) const
+        {
+            if (name)
+            {
+                if (name_size == 0)
+                    name_size = internal::measure(name);
+                for (xml_node<Ch> *child = m_first_node; child; child = child->next_sibling())
+                    if (internal::compare(child->name(), child->name_size(), name, name_size, case_sensitive))
+                        return child;
+                return 0;
+            }
+            else
+                return m_first_node;
+        }
+
+        //! Gets last child node, optionally matching node name. 
+        //! Behaviour is undefined if node has no children.
+        //! Use first_node() to test if node has children.
+        //! \param name Name of child to find, or 0 to return last child regardless of its name; this string doesn't have to be zero-terminated if name_size is non-zero
+        //! \param name_size Size of name, in characters, or 0 to have size calculated automatically from string
+        //! \param case_sensitive Should name comparison be case-sensitive; non case-sensitive comparison works properly only for ASCII characters
+        //! \return Pointer to found child, or 0 if not found.
+        xml_node<Ch> *last_node(const Ch *name = 0, std::size_t name_size = 0, bool case_sensitive = true) const
+        {
+            assert(m_first_node);  // Cannot query for last child if node has no children
+            if (name)
+            {
+                if (name_size == 0)
+                    name_size = internal::measure(name);
+                for (xml_node<Ch> *child = m_last_node; child; child = child->previous_sibling())
+                    if (internal::compare(child->name(), child->name_size(), name, name_size, case_sensitive))
+                        return child;
+                return 0;
+            }
+            else
+                return m_last_node;
+        }
+
+        //! Gets previous sibling node, optionally matching node name. 
+        //! Behaviour is undefined if node has no parent.
+        //! Use parent() to test if node has a parent.
+        //! \param name Name of sibling to find, or 0 to return previous sibling regardless of its name; this string doesn't have to be zero-terminated if name_size is non-zero
+        //! \param name_size Size of name, in characters, or 0 to have size calculated automatically from string
+        //! \param case_sensitive Should name comparison be case-sensitive; non case-sensitive comparison works properly only for ASCII characters
+        //! \return Pointer to found sibling, or 0 if not found.
+        xml_node<Ch> *previous_sibling(const Ch *name = 0, std::size_t name_size = 0, bool case_sensitive = true) const
+        {
+            assert(this->m_parent);     // Cannot query for siblings if node has no parent
+            if (name)
+            {
+                if (name_size == 0)
+                    name_size = internal::measure(name);
+                for (xml_node<Ch> *sibling = m_prev_sibling; sibling; sibling = sibling->m_prev_sibling)
+                    if (internal::compare(sibling->name(), sibling->name_size(), name, name_size, case_sensitive))
+                        return sibling;
+                return 0;
+            }
+            else
+                return m_prev_sibling;
+        }
+
+        //! Gets next sibling node, optionally matching node name. 
+        //! Behaviour is undefined if node has no parent.
+        //! Use parent() to test if node has a parent.
+        //! \param name Name of sibling to find, or 0 to return next sibling regardless of its name; this string doesn't have to be zero-terminated if name_size is non-zero
+        //! \param name_size Size of name, in characters, or 0 to have size calculated automatically from string
+        //! \param case_sensitive Should name comparison be case-sensitive; non case-sensitive comparison works properly only for ASCII characters
+        //! \return Pointer to found sibling, or 0 if not found.
+        xml_node<Ch> *next_sibling(const Ch *name = 0, std::size_t name_size = 0, bool case_sensitive = true) const
+        {
+            assert(this->m_parent);     // Cannot query for siblings if node has no parent
+            if (name)
+            {
+                if (name_size == 0)
+                    name_size = internal::measure(name);
+                for (xml_node<Ch> *sibling = m_next_sibling; sibling; sibling = sibling->m_next_sibling)
+                    if (internal::compare(sibling->name(), sibling->name_size(), name, name_size, case_sensitive))
+                        return sibling;
+                return 0;
+            }
+            else
+                return m_next_sibling;
+        }
+
+        //! Gets first attribute of node, optionally matching attribute name.
+        //! \param name Name of attribute to find, or 0 to return first attribute regardless of its name; this string doesn't have to be zero-terminated if name_size is non-zero
+        //! \param name_size Size of name, in characters, or 0 to have size calculated automatically from string
+        //! \param case_sensitive Should name comparison be case-sensitive; non case-sensitive comparison works properly only for ASCII characters
+        //! \return Pointer to found attribute, or 0 if not found.
+        xml_attribute<Ch> *first_attribute(const Ch *name = 0, std::size_t name_size = 0, bool case_sensitive = true) const
+        {
+            if (name)
+            {
+                if (name_size == 0)
+                    name_size = internal::measure(name);
+                for (xml_attribute<Ch> *attribute = m_first_attribute; attribute; attribute = attribute->m_next_attribute)
+                    if (internal::compare(attribute->name(), attribute->name_size(), name, name_size, case_sensitive))
+                        return attribute;
+                return 0;
+            }
+            else
+                return m_first_attribute;
+        }
+
+        //! Gets last attribute of node, optionally matching attribute name.
+        //! \param name Name of attribute to find, or 0 to return last attribute regardless of its name; this string doesn't have to be zero-terminated if name_size is non-zero
+        //! \param name_size Size of name, in characters, or 0 to have size calculated automatically from string
+        //! \param case_sensitive Should name comparison be case-sensitive; non case-sensitive comparison works properly only for ASCII characters
+        //! \return Pointer to found attribute, or 0 if not found.
+        xml_attribute<Ch> *last_attribute(const Ch *name = 0, std::size_t name_size = 0, bool case_sensitive = true) const
+        {
+            if (name)
+            {
+                if (name_size == 0)
+                    name_size = internal::measure(name);
+                for (xml_attribute<Ch> *attribute = m_last_attribute; attribute; attribute = attribute->m_prev_attribute)
+                    if (internal::compare(attribute->name(), attribute->name_size(), name, name_size, case_sensitive))
+                        return attribute;
+                return 0;
+            }
+            else
+                return m_first_attribute ? m_last_attribute : 0;
+        }
+
+        ///////////////////////////////////////////////////////////////////////////
+        // Node modification
+    
+        //! Sets type of node.
+        //! \param type Type of node to set.
+        void type(node_type type)
+        {
+            m_type = type;
+        }
+
+        ///////////////////////////////////////////////////////////////////////////
+        // Node manipulation
+
+        //! Prepends a new child node.
+        //! The prepended child becomes the first child, and all existing children are moved one position back.
+        //! \param child Node to prepend.
+        void prepend_node(xml_node<Ch> *child)
+        {
+            assert(child && !child->parent() && child->type() != node_document);
+            if (first_node())
+            {
+                child->m_next_sibling = m_first_node;
+                m_first_node->m_prev_sibling = child;
+            }
+            else
+            {
+                child->m_next_sibling = 0;
+                m_last_node = child;
+            }
+            m_first_node = child;
+            child->m_parent = this;
+            child->m_prev_sibling = 0;
+        }
+
+        //! Appends a new child node. 
+        //! The appended child becomes the last child.
+        //! \param child Node to append.
+        void append_node(xml_node<Ch> *child)
+        {
+            assert(child && !child->parent() && child->type() != node_document);
+            if (first_node())
+            {
+                child->m_prev_sibling = m_last_node;
+                m_last_node->m_next_sibling = child;
+            }
+            else
+            {
+                child->m_prev_sibling = 0;
+                m_first_node = child;
+            }
+            m_last_node = child;
+            child->m_parent = this;
+            child->m_next_sibling = 0;
+        }
+
+        //! Inserts a new child node at specified place inside the node. 
+        //! All children after and including the specified node are moved one position back.
+        //! \param where Place where to insert the child, or 0 to insert at the back.
+        //! \param child Node to insert.
+        void insert_node(xml_node<Ch> *where, xml_node<Ch> *child)
+        {
+            assert(!where || where->parent() == this);
+            assert(child && !child->parent() && child->type() != node_document);
+            if (where == m_first_node)
+                prepend_node(child);
+            else if (where == 0)
+                append_node(child);
+            else
+            {
+                child->m_prev_sibling = where->m_prev_sibling;
+                child->m_next_sibling = where;
+                where->m_prev_sibling->m_next_sibling = child;
+                where->m_prev_sibling = child;
+                child->m_parent = this;
+            }
+        }
+
+        //! Removes first child node. 
+        //! If node has no children, behaviour is undefined.
+        //! Use first_node() to test if node has children.
+        void remove_first_node()
+        {
+            assert(first_node());
+            xml_node<Ch> *child = m_first_node;
+            m_first_node = child->m_next_sibling;
+            if (child->m_next_sibling)
+                child->m_next_sibling->m_prev_sibling = 0;
+            else
+                m_last_node = 0;
+            child->m_parent = 0;
+        }
+
+        //! Removes last child of the node. 
+        //! If node has no children, behaviour is undefined.
+        //! Use first_node() to test if node has children.
+        void remove_last_node()
+        {
+            assert(first_node());
+            xml_node<Ch> *child = m_last_node;
+            if (child->m_prev_sibling)
+            {
+                m_last_node = child->m_prev_sibling;
+                child->m_prev_sibling->m_next_sibling = 0;
+            }
+            else
+                m_first_node = 0;
+            child->m_parent = 0;
+        }
+
+        //! Removes specified child from the node
+        // \param where Pointer to child to be removed.
+        void remove_node(xml_node<Ch> *where)
+        {
+            assert(where && where->parent() == this);
+            assert(first_node());
+            if (where == m_first_node)
+                remove_first_node();
+            else if (where == m_last_node)
+                remove_last_node();
+            else
+            {
+                where->m_prev_sibling->m_next_sibling = where->m_next_sibling;
+                where->m_next_sibling->m_prev_sibling = where->m_prev_sibling;
+                where->m_parent = 0;
+            }
+        }
+
+        //! Removes all child nodes (but not attributes).
+        void remove_all_nodes()
+        {
+            for (xml_node<Ch> *node = first_node(); node; node = node->m_next_sibling)
+                node->m_parent = 0;
+            m_first_node = 0;
+        }
+
+        //! Prepends a new attribute to the node.
+        //! \param attribute Attribute to prepend.
+        void prepend_attribute(xml_attribute<Ch> *attribute)
+        {
+            assert(attribute && !attribute->parent());
+            if (first_attribute())
+            {
+                attribute->m_next_attribute = m_first_attribute;
+                m_first_attribute->m_prev_attribute = attribute;
+            }
+            else
+            {
+                attribute->m_next_attribute = 0;
+                m_last_attribute = attribute;
+            }
+            m_first_attribute = attribute;
+            attribute->m_parent = this;
+            attribute->m_prev_attribute = 0;
+        }
+
+        //! Appends a new attribute to the node.
+        //! \param attribute Attribute to append.
+        void append_attribute(xml_attribute<Ch> *attribute)
+        {
+            assert(attribute && !attribute->parent());
+            if (first_attribute())
+            {
+                attribute->m_prev_attribute = m_last_attribute;
+                m_last_attribute->m_next_attribute = attribute;
+            }
+            else
+            {
+                attribute->m_prev_attribute = 0;
+                m_first_attribute = attribute;
+            }
+            m_last_attribute = attribute;
+            attribute->m_parent = this;
+            attribute->m_next_attribute = 0;
+        }
+
+        //! Inserts a new attribute at specified place inside the node. 
+        //! All attributes after and including the specified attribute are moved one position back.
+        //! \param where Place where to insert the attribute, or 0 to insert at the back.
+        //! \param attribute Attribute to insert.
+        void insert_attribute(xml_attribute<Ch> *where, xml_attribute<Ch> *attribute)
+        {
+            assert(!where || where->parent() == this);
+            assert(attribute && !attribute->parent());
+            if (where == m_first_attribute)
+                prepend_attribute(attribute);
+            else if (where == 0)
+                append_attribute(attribute);
+            else
+            {
+                attribute->m_prev_attribute = where->m_prev_attribute;
+                attribute->m_next_attribute = where;
+                where->m_prev_attribute->m_next_attribute = attribute;
+                where->m_prev_attribute = attribute;
+                attribute->m_parent = this;
+            }
+        }
+
+        //! Removes first attribute of the node. 
+        //! If node has no attributes, behaviour is undefined.
+        //! Use first_attribute() to test if node has attributes.
+        void remove_first_attribute()
+        {
+            assert(first_attribute());
+            xml_attribute<Ch> *attribute = m_first_attribute;
+            if (attribute->m_next_attribute)
+            {
+                attribute->m_next_attribute->m_prev_attribute = 0;
+            }
+            else
+                m_last_attribute = 0;
+            attribute->m_parent = 0;
+            m_first_attribute = attribute->m_next_attribute;
+        }
+
+        //! Removes last attribute of the node. 
+        //! If node has no attributes, behaviour is undefined.
+        //! Use first_attribute() to test if node has attributes.
+        void remove_last_attribute()
+        {
+            assert(first_attribute());
+            xml_attribute<Ch> *attribute = m_last_attribute;
+            if (attribute->m_prev_attribute)
+            {
+                attribute->m_prev_attribute->m_next_attribute = 0;
+                m_last_attribute = attribute->m_prev_attribute;
+            }
+            else
+                m_first_attribute = 0;
+            attribute->m_parent = 0;
+        }
+
+        //! Removes specified attribute from node.
+        //! \param where Pointer to attribute to be removed.
+        void remove_attribute(xml_attribute<Ch> *where)
+        {
+            assert(first_attribute() && where->parent() == this);
+            if (where == m_first_attribute)
+                remove_first_attribute();
+            else if (where == m_last_attribute)
+                remove_last_attribute();
+            else
+            {
+                where->m_prev_attribute->m_next_attribute = where->m_next_attribute;
+                where->m_next_attribute->m_prev_attribute = where->m_prev_attribute;
+                where->m_parent = 0;
+            }
+        }
+
+        //! Removes all attributes of node.
+        void remove_all_attributes()
+        {
+            for (xml_attribute<Ch> *attribute = first_attribute(); attribute; attribute = attribute->m_next_attribute)
+                attribute->m_parent = 0;
+            m_first_attribute = 0;
+        }
+        
+    private:
+
+        ///////////////////////////////////////////////////////////////////////////
+        // Restrictions
+
+        // No copying
+        xml_node(const xml_node &);
+        void operator =(const xml_node &);
+    
+        ///////////////////////////////////////////////////////////////////////////
+        // Data members
+    
+        // Note that some of the pointers below have UNDEFINED values if certain other pointers are 0.
+        // This is required for maximum performance, as it allows the parser to omit initialization of 
+        // unneded/redundant values.
+        //
+        // The rules are as follows:
+        // 1. first_node and first_attribute contain valid pointers, or 0 if node has no children/attributes respectively
+        // 2. last_node and last_attribute are valid only if node has at least one child/attribute respectively, otherwise they contain garbage
+        // 3. prev_sibling and next_sibling are valid only if node has a parent, otherwise they contain garbage
+
+        node_type m_type;                       // Type of node; always valid
+        xml_node<Ch> *m_first_node;             // Pointer to first child node, or 0 if none; always valid
+        xml_node<Ch> *m_last_node;              // Pointer to last child node, or 0 if none; this value is only valid if m_first_node is non-zero
+        xml_attribute<Ch> *m_first_attribute;   // Pointer to first attribute of node, or 0 if none; always valid
+        xml_attribute<Ch> *m_last_attribute;    // Pointer to last attribute of node, or 0 if none; this value is only valid if m_first_attribute is non-zero
+        xml_node<Ch> *m_prev_sibling;           // Pointer to previous sibling of node, or 0 if none; this value is only valid if m_parent is non-zero
+        xml_node<Ch> *m_next_sibling;           // Pointer to next sibling of node, or 0 if none; this value is only valid if m_parent is non-zero
+
+    };
+
+    ///////////////////////////////////////////////////////////////////////////
+    // XML document
+    
+    //! This class represents root of the DOM hierarchy. 
+    //! It is also an xml_node and a memory_pool through public inheritance.
+    //! Use parse() function to build a DOM tree from a zero-terminated XML text string.
+    //! parse() function allocates memory for nodes and attributes by using functions of xml_document, 
+    //! which are inherited from memory_pool.
+    //! To access root node of the document, use the document itself, as if it was an xml_node.
+    //! \param Ch Character type to use.
+    template<class Ch = char>
+    class xml_document: public xml_node<Ch>, public memory_pool<Ch>
+    {
+    
+    public:
+
+        //! Constructs empty XML document
+        xml_document()
+            : xml_node<Ch>(node_document)
+        {
+        }
+
+        //! Parses zero-terminated XML string according to given flags.
+        //! Passed string will be modified by the parser, unless rapidxml::parse_non_destructive flag is used.
+        //! The string must persist for the lifetime of the document.
+        //! In case of error, rapidxml::parse_error exception will be thrown.
+        //! <br><br>
+        //! If you want to parse contents of a file, you must first load the file into the memory, and pass pointer to its beginning.
+        //! Make sure that data is zero-terminated.
+        //! <br><br>
+        //! Document can be parsed into multiple times. 
+        //! Each new call to parse removes previous nodes and attributes (if any), but does not clear memory pool.
+        //! \param text XML data to parse; pointer is non-const to denote fact that this data may be modified by the parser.
+        template<int Flags>
+        void parse(Ch *text)
+        {
+            assert(text);
+            
+            // Remove current contents
+            this->remove_all_nodes();
+            this->remove_all_attributes();
+            
+            // Parse BOM, if any
+            parse_bom<Flags>(text);
+            
+            // Parse children
+            while (1)
+            {
+                // Skip whitespace before node
+                skip<whitespace_pred, Flags>(text);
+                if (*text == 0)
+                    break;
+
+                // Parse and append new child
+                if (*text == Ch('<'))
+                {
+                    ++text;     // Skip '<'
+                    if (xml_node<Ch> *node = parse_node<Flags>(text))
+                        this->append_node(node);
+                }
+                else
+                    RAPIDXML_PARSE_ERROR("expected <", text);
+            }
+
+        }
+
+        //! Clears the document by deleting all nodes and clearing the memory pool.
+        //! All nodes owned by document pool are destroyed.
+        void clear()
+        {
+            this->remove_all_nodes();
+            this->remove_all_attributes();
+            memory_pool<Ch>::clear();
+        }
+        
+    private:
+
+        ///////////////////////////////////////////////////////////////////////
+        // Internal character utility functions
+        
+        // Detect whitespace character
+        struct whitespace_pred
+        {
+            static unsigned char test(Ch ch)
+            {
+                return internal::lookup_tables<0>::lookup_whitespace[static_cast<unsigned char>(ch)];
+            }
+        };
+
+        // Detect node name character
+        struct node_name_pred
+        {
+            static unsigned char test(Ch ch)
+            {
+                return internal::lookup_tables<0>::lookup_node_name[static_cast<unsigned char>(ch)];
+            }
+        };
+
+        // Detect attribute name character
+        struct attribute_name_pred
+        {
+            static unsigned char test(Ch ch)
+            {
+                return internal::lookup_tables<0>::lookup_attribute_name[static_cast<unsigned char>(ch)];
+            }
+        };
+
+        // Detect text character (PCDATA)
+        struct text_pred
+        {
+            static unsigned char test(Ch ch)
+            {
+                return internal::lookup_tables<0>::lookup_text[static_cast<unsigned char>(ch)];
+            }
+        };
+
+        // Detect text character (PCDATA) that does not require processing
+        struct text_pure_no_ws_pred
+        {
+            static unsigned char test(Ch ch)
+            {
+                return internal::lookup_tables<0>::lookup_text_pure_no_ws[static_cast<unsigned char>(ch)];
+            }
+        };
+
+        // Detect text character (PCDATA) that does not require processing
+        struct text_pure_with_ws_pred
+        {
+            static unsigned char test(Ch ch)
+            {
+                return internal::lookup_tables<0>::lookup_text_pure_with_ws[static_cast<unsigned char>(ch)];
+            }
+        };
+
+        // Detect attribute value character
+        template<Ch Quote>
+        struct attribute_value_pred
+        {
+            static unsigned char test(Ch ch)
+            {
+                if (Quote == Ch('\''))
+                    return internal::lookup_tables<0>::lookup_attribute_data_1[static_cast<unsigned char>(ch)];
+                if (Quote == Ch('\"'))
+                    return internal::lookup_tables<0>::lookup_attribute_data_2[static_cast<unsigned char>(ch)];
+                return 0;       // Should never be executed, to avoid warnings on Comeau
+            }
+        };
+
+        // Detect attribute value character
+        template<Ch Quote>
+        struct attribute_value_pure_pred
+        {
+            static unsigned char test(Ch ch)
+            {
+                if (Quote == Ch('\''))
+                    return internal::lookup_tables<0>::lookup_attribute_data_1_pure[static_cast<unsigned char>(ch)];
+                if (Quote == Ch('\"'))
+                    return internal::lookup_tables<0>::lookup_attribute_data_2_pure[static_cast<unsigned char>(ch)];
+                return 0;       // Should never be executed, to avoid warnings on Comeau
+            }
+        };
+
+        // Insert coded character, using UTF8 or 8-bit ASCII
+        template<int Flags>
+        static void insert_coded_character(Ch *&text, unsigned long code)
+        {
+            if (Flags & parse_no_utf8)
+            {
+                // Insert 8-bit ASCII character
+                // Todo: possibly verify that code is less than 256 and use replacement char otherwise?
+                text[0] = static_cast<unsigned char>(code);
+                text += 1;
+            }
+            else
+            {
+                // Insert UTF8 sequence
+                if (code < 0x80)    // 1 byte sequence
+                {
+	                text[0] = static_cast<unsigned char>(code);
+                    text += 1;
+                }
+                else if (code < 0x800)  // 2 byte sequence
+                {
+	                text[1] = static_cast<unsigned char>((code | 0x80) & 0xBF); code >>= 6;
+	                text[0] = static_cast<unsigned char>(code | 0xC0);
+                    text += 2;
+                }
+	            else if (code < 0x10000)    // 3 byte sequence
+                {
+	                text[2] = static_cast<unsigned char>((code | 0x80) & 0xBF); code >>= 6;
+	                text[1] = static_cast<unsigned char>((code | 0x80) & 0xBF); code >>= 6;
+	                text[0] = static_cast<unsigned char>(code | 0xE0);
+                    text += 3;
+                }
+	            else if (code < 0x110000)   // 4 byte sequence
+                {
+	                text[3] = static_cast<unsigned char>((code | 0x80) & 0xBF); code >>= 6;
+	                text[2] = static_cast<unsigned char>((code | 0x80) & 0xBF); code >>= 6;
+	                text[1] = static_cast<unsigned char>((code | 0x80) & 0xBF); code >>= 6;
+	                text[0] = static_cast<unsigned char>(code | 0xF0);
+                    text += 4;
+                }
+                else    // Invalid, only codes up to 0x10FFFF are allowed in Unicode
+                {
+                    RAPIDXML_PARSE_ERROR("invalid numeric character entity", text);
+                }
+            }
+        }
+
+        // Skip characters until predicate evaluates to true
+        template<class StopPred, int Flags>
+        static void skip(Ch *&text)
+        {
+            Ch *tmp = text;
+            while (StopPred::test(*tmp))
+                ++tmp;
+            text = tmp;
+        }
+
+        // Skip characters until predicate evaluates to true while doing the following:
+        // - replacing XML character entity references with proper characters (&apos; &amp; &quot; &lt; &gt; &#...;)
+        // - condensing whitespace sequences to single space character
+        template<class StopPred, class StopPredPure, int Flags>
+        static Ch *skip_and_expand_character_refs(Ch *&text)
+        {
+            // If entity translation, whitespace condense and whitespace trimming is disabled, use plain skip
+            if (Flags & parse_no_entity_translation && 
+                !(Flags & parse_normalize_whitespace) &&
+                !(Flags & parse_trim_whitespace))
+            {
+                skip<StopPred, Flags>(text);
+                return text;
+            }
+            
+            // Use simple skip until first modification is detected
+            skip<StopPredPure, Flags>(text);
+
+            // Use translation skip
+            Ch *src = text;
+            Ch *dest = src;
+            while (StopPred::test(*src))
+            {
+                // If entity translation is enabled    
+                if (!(Flags & parse_no_entity_translation))
+                {
+                    // Test if replacement is needed
+                    if (src[0] == Ch('&'))
+                    {
+                        switch (src[1])
+                        {
+
+                        // &amp; &apos;
+                        case Ch('a'): 
+                            if (src[2] == Ch('m') && src[3] == Ch('p') && src[4] == Ch(';'))
+                            {
+                                *dest = Ch('&');
+                                ++dest;
+                                src += 5;
+                                continue;
+                            }
+                            if (src[2] == Ch('p') && src[3] == Ch('o') && src[4] == Ch('s') && src[5] == Ch(';'))
+                            {
+                                *dest = Ch('\'');
+                                ++dest;
+                                src += 6;
+                                continue;
+                            }
+                            break;
+
+                        // &quot;
+                        case Ch('q'): 
+                            if (src[2] == Ch('u') && src[3] == Ch('o') && src[4] == Ch('t') && src[5] == Ch(';'))
+                            {
+                                *dest = Ch('"');
+                                ++dest;
+                                src += 6;
+                                continue;
+                            }
+                            break;
+
+                        // &gt;
+                        case Ch('g'): 
+                            if (src[2] == Ch('t') && src[3] == Ch(';'))
+                            {
+                                *dest = Ch('>');
+                                ++dest;
+                                src += 4;
+                                continue;
+                            }
+                            break;
+
+                        // &lt;
+                        case Ch('l'): 
+                            if (src[2] == Ch('t') && src[3] == Ch(';'))
+                            {
+                                *dest = Ch('<');
+                                ++dest;
+                                src += 4;
+                                continue;
+                            }
+                            break;
+
+                        // &#...; - assumes ASCII
+                        case Ch('#'): 
+                            if (src[2] == Ch('x'))
+                            {
+                                unsigned long code = 0;
+                                src += 3;   // Skip &#x
+                                while (1)
+                                {
+                                    unsigned char digit = internal::lookup_tables<0>::lookup_digits[static_cast<unsigned char>(*src)];
+                                    if (digit == 0xFF)
+                                        break;
+                                    code = code * 16 + digit;
+                                    ++src;
+                                }
+                                insert_coded_character<Flags>(dest, code);    // Put character in output
+                            }
+                            else
+                            {
+                                unsigned long code = 0;
+                                src += 2;   // Skip &#
+                                while (1)
+                                {
+                                    unsigned char digit = internal::lookup_tables<0>::lookup_digits[static_cast<unsigned char>(*src)];
+                                    if (digit == 0xFF)
+                                        break;
+                                    code = code * 10 + digit;
+                                    ++src;
+                                }
+                                insert_coded_character<Flags>(dest, code);    // Put character in output
+                            }
+                            if (*src == Ch(';'))
+                                ++src;
+                            else
+                                RAPIDXML_PARSE_ERROR("expected ;", src);
+                            continue;
+
+                        // Something else
+                        default:
+                            // Ignore, just copy '&' verbatim
+                            break;
+
+                        }
+                    }
+                }
+                
+                // If whitespace condensing is enabled
+                if (Flags & parse_normalize_whitespace)
+                {
+                    // Test if condensing is needed                 
+                    if (whitespace_pred::test(*src))
+                    {
+                        *dest = Ch(' '); ++dest;    // Put single space in dest
+                        ++src;                      // Skip first whitespace char
+                        // Skip remaining whitespace chars
+                        while (whitespace_pred::test(*src))
+                            ++src;
+                        continue;
+                    }
+                }
+
+                // No replacement, only copy character
+                *dest++ = *src++;
+
+            }
+
+            // Return new end
+            text = src;
+            return dest;
+
+        }
+
+        ///////////////////////////////////////////////////////////////////////
+        // Internal parsing functions
+        
+        // Parse BOM, if any
+        template<int Flags>
+        void parse_bom(Ch *&text)
+        {
+            // UTF-8?
+            if (static_cast<unsigned char>(text[0]) == 0xEF && 
+                static_cast<unsigned char>(text[1]) == 0xBB && 
+                static_cast<unsigned char>(text[2]) == 0xBF)
+            {
+                text += 3;      // Skup utf-8 bom
+            }
+        }
+
+        // Parse XML declaration (<?xml...)
+        template<int Flags>
+        xml_node<Ch> *parse_xml_declaration(Ch *&text)
+        {
+            // If parsing of declaration is disabled
+            if (!(Flags & parse_declaration_node))
+            {
+                // Skip until end of declaration
+                while (text[0] != Ch('?') || text[1] != Ch('>'))
+                {
+                    if (!text[0])
+                        RAPIDXML_PARSE_ERROR("unexpected end of data", text);
+                    ++text;
+                }
+                text += 2;    // Skip '?>'
+                return 0;
+            }
+
+            // Create declaration
+            xml_node<Ch> *declaration = this->allocate_node(node_declaration);
+
+            // Skip whitespace before attributes or ?>
+            skip<whitespace_pred, Flags>(text);
+
+            // Parse declaration attributes
+            parse_node_attributes<Flags>(text, declaration);
+            
+            // Skip ?>
+            if (text[0] != Ch('?') || text[1] != Ch('>'))
+                RAPIDXML_PARSE_ERROR("expected ?>", text);
+            text += 2;
+            
+            return declaration;
+        }
+
+        // Parse XML comment (<!--...)
+        template<int Flags>
+        xml_node<Ch> *parse_comment(Ch *&text)
+        {
+            // If parsing of comments is disabled
+            if (!(Flags & parse_comment_nodes))
+            {
+                // Skip until end of comment
+                while (text[0] != Ch('-') || text[1] != Ch('-') || text[2] != Ch('>'))
+                {
+                    if (!text[0])
+                        RAPIDXML_PARSE_ERROR("unexpected end of data", text);
+                    ++text;
+                }
+                text += 3;     // Skip '-->'
+                return 0;      // Do not produce comment node
+            }
+
+            // Remember value start
+            Ch *value = text;
+
+            // Skip until end of comment
+            while (text[0] != Ch('-') || text[1] != Ch('-') || text[2] != Ch('>'))
+            {
+                if (!text[0])
+                    RAPIDXML_PARSE_ERROR("unexpected end of data", text);
+                ++text;
+            }
+
+            // Create comment node
+            xml_node<Ch> *comment = this->allocate_node(node_comment);
+            comment->value(value, text - value);
+            
+            // Place zero terminator after comment value
+            if (!(Flags & parse_no_string_terminators))
+                *text = Ch('\0');
+            
+            text += 3;     // Skip '-->'
+            return comment;
+        }
+
+        // Parse DOCTYPE
+        template<int Flags>
+        xml_node<Ch> *parse_doctype(Ch *&text)
+        {
+            // Remember value start
+            Ch *value = text;
+
+            // Skip to >
+            while (*text != Ch('>'))
+            {
+                // Determine character type
+                switch (*text)
+                {
+                
+                // If '[' encountered, scan for matching ending ']' using naive algorithm with depth
+                // This works for all W3C test files except for 2 most wicked
+                case Ch('['):
+                {
+                    ++text;     // Skip '['
+                    int depth = 1;
+                    while (depth > 0)
+                    {
+                        switch (*text)
+                        {
+                            case Ch('['): ++depth; break;
+                            case Ch(']'): --depth; break;
+                            case 0: RAPIDXML_PARSE_ERROR("unexpected end of data", text);
+                        }
+                        ++text;
+                    }
+                    break;
+                }
+                
+                // Error on end of text
+                case Ch('\0'):
+                    RAPIDXML_PARSE_ERROR("unexpected end of data", text);
+                
+                // Other character, skip it
+                default:
+                    ++text;
+
+                }
+            }
+            
+            // If DOCTYPE nodes enabled
+            if (Flags & parse_doctype_node)
+            {
+                // Create a new doctype node
+                xml_node<Ch> *doctype = this->allocate_node(node_doctype);
+                doctype->value(value, text - value);
+                
+                // Place zero terminator after value
+                if (!(Flags & parse_no_string_terminators))
+                    *text = Ch('\0');
+
+                text += 1;      // skip '>'
+                return doctype;
+            }
+            else
+            {
+                text += 1;      // skip '>'
+                return 0;
+            }
+
+        }
+
+        // Parse PI
+        template<int Flags>
+        xml_node<Ch> *parse_pi(Ch *&text)
+        {
+            // If creation of PI nodes is enabled
+            if (Flags & parse_pi_nodes)
+            {
+                // Create pi node
+                xml_node<Ch> *pi = this->allocate_node(node_pi);
+
+                // Extract PI target name
+                Ch *name = text;
+                skip<node_name_pred, Flags>(text);
+                if (text == name)
+                    RAPIDXML_PARSE_ERROR("expected PI target", text);
+                pi->name(name, text - name);
+                
+                // Skip whitespace between pi target and pi
+                skip<whitespace_pred, Flags>(text);
+
+                // Remember start of pi
+                Ch *value = text;
+                
+                // Skip to '?>'
+                while (text[0] != Ch('?') || text[1] != Ch('>'))
+                {
+                    if (*text == Ch('\0'))
+                        RAPIDXML_PARSE_ERROR("unexpected end of data", text);
+                    ++text;
+                }
+
+                // Set pi value (verbatim, no entity expansion or whitespace normalization)
+                pi->value(value, text - value);     
+                
+                // Place zero terminator after name and value
+                if (!(Flags & parse_no_string_terminators))
+                {
+                    pi->name()[pi->name_size()] = Ch('\0');
+                    pi->value()[pi->value_size()] = Ch('\0');
+                }
+                
+                text += 2;                          // Skip '?>'
+                return pi;
+            }
+            else
+            {
+                // Skip to '?>'
+                while (text[0] != Ch('?') || text[1] != Ch('>'))
+                {
+                    if (*text == Ch('\0'))
+                        RAPIDXML_PARSE_ERROR("unexpected end of data", text);
+                    ++text;
+                }
+                text += 2;    // Skip '?>'
+                return 0;
+            }
+        }
+
+        // Parse and append data
+        // Return character that ends data.
+        // This is necessary because this character might have been overwritten by a terminating 0
+        template<int Flags>
+        Ch parse_and_append_data(xml_node<Ch> *node, Ch *&text, Ch *contents_start)
+        {
+            // Backup to contents start if whitespace trimming is disabled
+            if (!(Flags & parse_trim_whitespace))
+                text = contents_start;     
+            
+            // Skip until end of data
+            Ch *value = text, *end;
+            if (Flags & parse_normalize_whitespace)
+                end = skip_and_expand_character_refs<text_pred, text_pure_with_ws_pred, Flags>(text);   
+            else
+                end = skip_and_expand_character_refs<text_pred, text_pure_no_ws_pred, Flags>(text);
+
+            // Trim trailing whitespace if flag is set; leading was already trimmed by whitespace skip after >
+            if (Flags & parse_trim_whitespace)
+            {
+                if (Flags & parse_normalize_whitespace)
+                {
+                    // Whitespace is already condensed to single space characters by skipping function, so just trim 1 char off the end
+                    if (*(end - 1) == Ch(' '))
+                        --end;
+                }
+                else
+                {
+                    // Backup until non-whitespace character is found
+                    while (whitespace_pred::test(*(end - 1)))
+                        --end;
+                }
+            }
+            
+            // If characters are still left between end and value (this test is only necessary if normalization is enabled)
+            // Create new data node
+            if (!(Flags & parse_no_data_nodes))
+            {
+                xml_node<Ch> *data = this->allocate_node(node_data);
+                data->value(value, end - value);
+                node->append_node(data);
+            }
+
+            // Add data to parent node if no data exists yet
+            if (!(Flags & parse_no_element_values)) 
+                if (*node->value() == Ch('\0'))
+                    node->value(value, end - value);
+
+            // Place zero terminator after value
+            if (!(Flags & parse_no_string_terminators))
+            {
+                Ch ch = *text;
+                *end = Ch('\0');
+                return ch;      // Return character that ends data; this is required because zero terminator overwritten it
+            }
+
+            // Return character that ends data
+            return *text;
+        }
+
+        // Parse CDATA
+        template<int Flags>
+        xml_node<Ch> *parse_cdata(Ch *&text)
+        {
+            // If CDATA is disabled
+            if (Flags & parse_no_data_nodes)
+            {
+                // Skip until end of cdata
+                while (text[0] != Ch(']') || text[1] != Ch(']') || text[2] != Ch('>'))
+                {
+                    if (!text[0])
+                        RAPIDXML_PARSE_ERROR("unexpected end of data", text);
+                    ++text;
+                }
+                text += 3;      // Skip ]]>
+                return 0;       // Do not produce CDATA node
+            }
+
+            // Skip until end of cdata
+            Ch *value = text;
+            while (text[0] != Ch(']') || text[1] != Ch(']') || text[2] != Ch('>'))
+            {
+                if (!text[0])
+                    RAPIDXML_PARSE_ERROR("unexpected end of data", text);
+                ++text;
+            }
+
+            // Create new cdata node
+            xml_node<Ch> *cdata = this->allocate_node(node_cdata);
+            cdata->value(value, text - value);
+
+            // Place zero terminator after value
+            if (!(Flags & parse_no_string_terminators))
+                *text = Ch('\0');
+
+            text += 3;      // Skip ]]>
+            return cdata;
+        }
+        
+        // Parse element node
+        template<int Flags>
+        xml_node<Ch> *parse_element(Ch *&text)
+        {
+            // Create element node
+            xml_node<Ch> *element = this->allocate_node(node_element);
+
+            // Extract element name
+            Ch *name = text;
+            skip<node_name_pred, Flags>(text);
+            if (text == name)
+                RAPIDXML_PARSE_ERROR("expected element name", text);
+            element->name(name, text - name);
+            
+            // Skip whitespace between element name and attributes or >
+            skip<whitespace_pred, Flags>(text);
+
+            // Parse attributes, if any
+            parse_node_attributes<Flags>(text, element);
+
+            // Determine ending type
+            if (*text == Ch('>'))
+            {
+                ++text;
+                parse_node_contents<Flags>(text, element);
+            }
+            else if (*text == Ch('/'))
+            {
+                ++text;
+                if (*text != Ch('>'))
+                    RAPIDXML_PARSE_ERROR("expected >", text);
+                ++text;
+            }
+            else
+                RAPIDXML_PARSE_ERROR("expected >", text);
+
+            // Place zero terminator after name
+            if (!(Flags & parse_no_string_terminators))
+                element->name()[element->name_size()] = Ch('\0');
+
+            // Return parsed element
+            return element;
+        }
+
+        // Determine node type, and parse it
+        template<int Flags>
+        xml_node<Ch> *parse_node(Ch *&text)
+        {
+            // Parse proper node type
+            switch (text[0])
+            {
+
+            // <...
+            default: 
+                // Parse and append element node
+                return parse_element<Flags>(text);
+
+            // <?...
+            case Ch('?'): 
+                ++text;     // Skip ?
+                if ((text[0] == Ch('x') || text[0] == Ch('X')) &&
+                    (text[1] == Ch('m') || text[1] == Ch('M')) && 
+                    (text[2] == Ch('l') || text[2] == Ch('L')) &&
+                    whitespace_pred::test(text[3]))
+                {
+                    // '<?xml ' - xml declaration
+                    text += 4;      // Skip 'xml '
+                    return parse_xml_declaration<Flags>(text);
+                }
+                else
+                {
+                    // Parse PI
+                    return parse_pi<Flags>(text);
+                }
+            
+            // <!...
+            case Ch('!'): 
+
+                // Parse proper subset of <! node
+                switch (text[1])    
+                {
+                
+                // <!-
+                case Ch('-'):
+                    if (text[2] == Ch('-'))
+                    {
+                        // '<!--' - xml comment
+                        text += 3;     // Skip '!--'
+                        return parse_comment<Flags>(text);
+                    }
+                    break;
+
+                // <![
+                case Ch('['):
+                    if (text[2] == Ch('C') && text[3] == Ch('D') && text[4] == Ch('A') && 
+                        text[5] == Ch('T') && text[6] == Ch('A') && text[7] == Ch('['))
+                    {
+                        // '<![CDATA[' - cdata
+                        text += 8;     // Skip '![CDATA['
+                        return parse_cdata<Flags>(text);
+                    }
+                    break;
+
+                // <!D
+                case Ch('D'):
+                    if (text[2] == Ch('O') && text[3] == Ch('C') && text[4] == Ch('T') && 
+                        text[5] == Ch('Y') && text[6] == Ch('P') && text[7] == Ch('E') && 
+                        whitespace_pred::test(text[8]))
+                    {
+                        // '<!DOCTYPE ' - doctype
+                        text += 9;      // skip '!DOCTYPE '
+                        return parse_doctype<Flags>(text);
+                    }
+
+                }   // switch
+
+                // Attempt to skip other, unrecognized node types starting with <!
+                ++text;     // Skip !
+                while (*text != Ch('>'))
+                {
+                    if (*text == 0)
+                        RAPIDXML_PARSE_ERROR("unexpected end of data", text);
+                    ++text;
+                }
+                ++text;     // Skip '>'
+                return 0;   // No node recognized
+
+            }
+        }
+
+        // Parse contents of the node - children, data etc.
+        template<int Flags>
+        void parse_node_contents(Ch *&text, xml_node<Ch> *node)
+        {
+            // For all children and text
+            while (1)
+            {
+                // Skip whitespace between > and node contents
+                Ch *contents_start = text;      // Store start of node contents before whitespace is skipped
+                skip<whitespace_pred, Flags>(text);
+                Ch next_char = *text;
+
+            // After data nodes, instead of continuing the loop, control jumps here.
+            // This is because zero termination inside parse_and_append_data() function
+            // would wreak havoc with the above code.
+            // Also, skipping whitespace after data nodes is unnecessary.
+            after_data_node:    
+                
+                // Determine what comes next: node closing, child node, data node, or 0?
+                switch (next_char)
+                {
+                
+                // Node closing or child node
+                case Ch('<'):
+                    if (text[1] == Ch('/'))
+                    {
+                        // Node closing
+                        text += 2;      // Skip '</'
+                        if (Flags & parse_validate_closing_tags)
+                        {
+                            // Skip and validate closing tag name
+                            Ch *closing_name = text;
+                            skip<node_name_pred, Flags>(text);
+                            if (!internal::compare(node->name(), node->name_size(), closing_name, text - closing_name, true))
+                                RAPIDXML_PARSE_ERROR("invalid closing tag name", text);
+                        }
+                        else
+                        {
+                            // No validation, just skip name
+                            skip<node_name_pred, Flags>(text);
+                        }
+                        // Skip remaining whitespace after node name
+                        skip<whitespace_pred, Flags>(text);
+                        if (*text != Ch('>'))
+                            RAPIDXML_PARSE_ERROR("expected >", text);
+                        ++text;     // Skip '>'
+                        return;     // Node closed, finished parsing contents
+                    }
+                    else
+                    {
+                        // Child node
+                        ++text;     // Skip '<'
+                        if (xml_node<Ch> *child = parse_node<Flags>(text))
+                            node->append_node(child);
+                    }
+                    break;
+
+                // End of data - error
+                case Ch('\0'):
+                    RAPIDXML_PARSE_ERROR("unexpected end of data", text);
+
+                // Data node
+                default:
+                    next_char = parse_and_append_data<Flags>(node, text, contents_start);
+                    goto after_data_node;   // Bypass regular processing after data nodes
+
+                }
+            }
+        }
+        
+        // Parse XML attributes of the node
+        template<int Flags>
+        void parse_node_attributes(Ch *&text, xml_node<Ch> *node)
+        {
+            // For all attributes 
+            while (attribute_name_pred::test(*text))
+            {
+                // Extract attribute name
+                Ch *name = text;
+                ++text;     // Skip first character of attribute name
+                skip<attribute_name_pred, Flags>(text);
+                if (text == name)
+                    RAPIDXML_PARSE_ERROR("expected attribute name", name);
+
+                // Create new attribute
+                xml_attribute<Ch> *attribute = this->allocate_attribute();
+                attribute->name(name, text - name);
+                node->append_attribute(attribute);
+
+                // Skip whitespace after attribute name
+                skip<whitespace_pred, Flags>(text);
+
+                // Skip =
+                if (*text != Ch('='))
+                    RAPIDXML_PARSE_ERROR("expected =", text);
+                ++text;
+
+                // Add terminating zero after name
+                if (!(Flags & parse_no_string_terminators))
+                    attribute->name()[attribute->name_size()] = 0;
+
+                // Skip whitespace after =
+                skip<whitespace_pred, Flags>(text);
+
+                // Skip quote and remember if it was ' or "
+                Ch quote = *text;
+                if (quote != Ch('\'') && quote != Ch('"'))
+                    RAPIDXML_PARSE_ERROR("expected ' or \"", text);
+                ++text;
+
+                // Extract attribute value and expand char refs in it
+                Ch *value = text, *end;
+                const int AttFlags = Flags & ~parse_normalize_whitespace;   // No whitespace normalization in attributes
+                if (quote == Ch('\''))
+                    end = skip_and_expand_character_refs<attribute_value_pred<Ch('\'')>, attribute_value_pure_pred<Ch('\'')>, AttFlags>(text);
+                else
+                    end = skip_and_expand_character_refs<attribute_value_pred<Ch('"')>, attribute_value_pure_pred<Ch('"')>, AttFlags>(text);
+                
+                // Set attribute value
+                attribute->value(value, end - value);
+                
+                // Make sure that end quote is present
+                if (*text != quote)
+                    RAPIDXML_PARSE_ERROR("expected ' or \"", text);
+                ++text;     // Skip quote
+
+                // Add terminating zero after value
+                if (!(Flags & parse_no_string_terminators))
+                    attribute->value()[attribute->value_size()] = 0;
+
+                // Skip whitespace after attribute value
+                skip<whitespace_pred, Flags>(text);
+            }
+        }
+
+    };
+
+    //! \cond internal
+    namespace internal
+    {
+
+        // Whitespace (space \n \r \t)
+        template<int Dummy>
+        const unsigned char lookup_tables<Dummy>::lookup_whitespace[256] = 
+        {
+          // 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
+             0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  0,  0,  1,  0,  0,  // 0
+             0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  // 1
+             1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  // 2
+             0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  // 3
+             0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  // 4
+             0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  // 5
+             0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  // 6
+             0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  // 7
+             0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  // 8
+             0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  // 9
+             0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  // A
+             0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  // B
+             0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  // C
+             0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  // D
+             0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  // E
+             0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0   // F
+        };
+
+        // Node name (anything but space \n \r \t / > ? \0)
+        template<int Dummy>
+        const unsigned char lookup_tables<Dummy>::lookup_node_name[256] = 
+        {
+          // 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
+             0,  1,  1,  1,  1,  1,  1,  1,  1,  0,  0,  1,  1,  0,  1,  1,  // 0
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 1
+             0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  // 2
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  0,  // 3
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 4
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 5
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 6
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 7
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 8
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 9
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // A
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // B
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // C
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // D
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // E
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1   // F
+        };
+
+        // Text (i.e. PCDATA) (anything but < \0)
+        template<int Dummy>
+        const unsigned char lookup_tables<Dummy>::lookup_text[256] = 
+        {
+          // 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
+             0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 0
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 1
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 2
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  1,  1,  1,  // 3
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 4
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 5
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 6
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 7
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 8
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 9
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // A
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // B
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // C
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // D
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // E
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1   // F
+        };
+
+        // Text (i.e. PCDATA) that does not require processing when ws normalization is disabled 
+        // (anything but < \0 &)
+        template<int Dummy>
+        const unsigned char lookup_tables<Dummy>::lookup_text_pure_no_ws[256] = 
+        {
+          // 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
+             0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 0
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 1
+             1,  1,  1,  1,  1,  1,  0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 2
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  1,  1,  1,  // 3
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 4
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 5
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 6
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 7
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 8
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 9
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // A
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // B
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // C
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // D
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // E
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1   // F
+        };
+
+        // Text (i.e. PCDATA) that does not require processing when ws normalizationis is enabled
+        // (anything but < \0 & space \n \r \t)
+        template<int Dummy>
+        const unsigned char lookup_tables<Dummy>::lookup_text_pure_with_ws[256] = 
+        {
+          // 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
+             0,  1,  1,  1,  1,  1,  1,  1,  1,  0,  0,  1,  1,  0,  1,  1,  // 0
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 1
+             0,  1,  1,  1,  1,  1,  0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 2
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  1,  1,  1,  // 3
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 4
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 5
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 6
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 7
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 8
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 9
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // A
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // B
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // C
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // D
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // E
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1   // F
+        };
+
+        // Attribute name (anything but space \n \r \t / < > = ? ! \0)
+        template<int Dummy>
+        const unsigned char lookup_tables<Dummy>::lookup_attribute_name[256] = 
+        {
+          // 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
+             0,  1,  1,  1,  1,  1,  1,  1,  1,  0,  0,  1,  1,  0,  1,  1,  // 0
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 1
+             0,  0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  // 2
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  0,  0,  0,  // 3
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 4
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 5
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 6
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 7
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 8
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 9
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // A
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // B
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // C
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // D
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // E
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1   // F
+        };
+
+        // Attribute data with single quote (anything but ' \0)
+        template<int Dummy>
+        const unsigned char lookup_tables<Dummy>::lookup_attribute_data_1[256] = 
+        {
+          // 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
+             0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 0
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 1
+             1,  1,  1,  1,  1,  1,  1,  0,  1,  1,  1,  1,  1,  1,  1,  1,  // 2
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 3
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 4
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 5
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 6
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 7
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 8
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 9
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // A
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // B
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // C
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // D
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // E
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1   // F
+        };
+
+        // Attribute data with single quote that does not require processing (anything but ' \0 &)
+        template<int Dummy>
+        const unsigned char lookup_tables<Dummy>::lookup_attribute_data_1_pure[256] = 
+        {
+          // 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
+             0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 0
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 1
+             1,  1,  1,  1,  1,  1,  0,  0,  1,  1,  1,  1,  1,  1,  1,  1,  // 2
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 3
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 4
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 5
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 6
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 7
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 8
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 9
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // A
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // B
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // C
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // D
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // E
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1   // F
+        };
+
+        // Attribute data with double quote (anything but " \0)
+        template<int Dummy>
+        const unsigned char lookup_tables<Dummy>::lookup_attribute_data_2[256] = 
+        {
+          // 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
+             0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 0
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 1
+             1,  1,  0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 2
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 3
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 4
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 5
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 6
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 7
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 8
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 9
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // A
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // B
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // C
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // D
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // E
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1   // F
+        };
+
+        // Attribute data with double quote that does not require processing (anything but " \0 &)
+        template<int Dummy>
+        const unsigned char lookup_tables<Dummy>::lookup_attribute_data_2_pure[256] = 
+        {
+          // 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
+             0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 0
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 1
+             1,  1,  0,  1,  1,  1,  0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 2
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 3
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 4
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 5
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 6
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 7
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 8
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 9
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // A
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // B
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // C
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // D
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // E
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1   // F
+        };
+
+        // Digits (dec and hex, 255 denotes end of numeric character reference)
+        template<int Dummy>
+        const unsigned char lookup_tables<Dummy>::lookup_digits[256] = 
+        {
+          // 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
+           255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  // 0
+           255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  // 1
+           255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  // 2
+             0,  1,  2,  3,  4,  5,  6,  7,  8,  9,255,255,255,255,255,255,  // 3
+           255, 10, 11, 12, 13, 14, 15,255,255,255,255,255,255,255,255,255,  // 4
+           255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  // 5
+           255, 10, 11, 12, 13, 14, 15,255,255,255,255,255,255,255,255,255,  // 6
+           255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  // 7
+           255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  // 8
+           255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  // 9
+           255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  // A
+           255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  // B
+           255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  // C
+           255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  // D
+           255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  // E
+           255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255   // F
+        };
+    
+        // Upper case conversion
+        template<int Dummy>
+        const unsigned char lookup_tables<Dummy>::lookup_upcase[256] = 
+        {
+          // 0,  1,  2,  3,  4,  5,  6,  7,  8,  9,  A   B   C   D   E   F
+           0,  1,  2,  3,  4,  5,  6,  7,  8,  9,  10, 11, 12, 13, 14, 15,   // 0
+           16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,   // 1
+           32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,   // 2
+           48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,   // 3
+           64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,   // 4
+           80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,   // 5
+           96, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,   // 6
+           80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 123,124,125,126,127,  // 7
+           128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,  // 8
+           144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,  // 9
+           160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,  // A
+           176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,  // B
+           192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,  // C
+           208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,  // D
+           224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,  // E
+           240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255   // F
+        };
+    }
+    //! \endcond
+
+}
+
+// Undefine internal macros
+#undef RAPIDXML_PARSE_ERROR
+
+// On MSVC, restore warnings state
+#ifdef _MSC_VER
+    #pragma warning(pop)
+#endif
+
+#endif
diff --git a/lib/rapidxml/rapidxml_iterators.hpp b/lib/rapidxml/rapidxml_iterators.hpp
new file mode 100644
index 0000000..a827e93
--- /dev/null
+++ b/lib/rapidxml/rapidxml_iterators.hpp
@@ -0,0 +1,175 @@
+#ifndef RAPIDXML_ITERATORS_HPP_INCLUDED
+#define RAPIDXML_ITERATORS_HPP_INCLUDED
+
+// Copyright (C) 2006, 2009 Marcin Kalicinski
+// Version 1.13
+// Revision $DateTime: 2009/05/13 01:46:17 $
+//! \file rapidxml_iterators.hpp This file contains rapidxml iterators
+
+#include <iterator>
+#include "rapidxml.hpp"
+
+namespace rapidxml
+{
+
+    //! Iterator of child nodes of xml_node
+    template<class Ch>
+    class node_iterator
+    {
+    
+    public:
+
+        typedef typename xml_node<Ch> value_type;
+        typedef typename xml_node<Ch> &reference;
+        typedef typename xml_node<Ch> *pointer;
+        typedef std::ptrdiff_t difference_type;
+        typedef std::bidirectional_iterator_tag iterator_category;
+        
+        node_iterator()
+            : m_node(0)
+        {
+        }
+
+        node_iterator(xml_node<Ch> *node)
+            : m_node(node->first_node())
+        {
+        }
+        
+        reference operator *() const
+        {
+            assert(m_node);
+            return *m_node;
+        }
+
+        pointer operator->() const
+        {
+            assert(m_node);
+            return m_node;
+        }
+
+        node_iterator& operator++()
+        {
+            assert(m_node);
+            m_node = m_node->next_sibling();
+            return *this;
+        }
+
+        node_iterator operator++(int)
+        {
+            node_iterator tmp = *this;
+            ++this;
+            return tmp;
+        }
+
+        node_iterator& operator--()
+        {
+            assert(m_node && m_node->previous_sibling());
+            m_node = m_node->previous_sibling();
+            return *this;
+        }
+
+        node_iterator operator--(int)
+        {
+            node_iterator tmp = *this;
+            ++this;
+            return tmp;
+        }
+
+        bool operator ==(const node_iterator<Ch> &rhs)
+        {
+            return m_node == rhs.m_node;
+        }
+
+        bool operator !=(const node_iterator<Ch> &rhs)
+        {
+            return m_node != rhs.m_node;
+        }
+
+    private:
+
+        xml_node<Ch> *m_node;
+
+    };
+
+    //! Iterator of child attributes of xml_node
+    template<class Ch>
+    class attribute_iterator
+    {
+    
+    public:
+
+        typedef typename xml_attribute<Ch> value_type;
+        typedef typename xml_attribute<Ch> &reference;
+        typedef typename xml_attribute<Ch> *pointer;
+        typedef std::ptrdiff_t difference_type;
+        typedef std::bidirectional_iterator_tag iterator_category;
+        
+        attribute_iterator()
+            : m_attribute(0)
+        {
+        }
+
+        attribute_iterator(xml_node<Ch> *node)
+            : m_attribute(node->first_attribute())
+        {
+        }
+        
+        reference operator *() const
+        {
+            assert(m_attribute);
+            return *m_attribute;
+        }
+
+        pointer operator->() const
+        {
+            assert(m_attribute);
+            return m_attribute;
+        }
+
+        attribute_iterator& operator++()
+        {
+            assert(m_attribute);
+            m_attribute = m_attribute->next_attribute();
+            return *this;
+        }
+
+        attribute_iterator operator++(int)
+        {
+            attribute_iterator tmp = *this;
+            ++this;
+            return tmp;
+        }
+
+        attribute_iterator& operator--()
+        {
+            assert(m_attribute && m_attribute->previous_attribute());
+            m_attribute = m_attribute->previous_attribute();
+            return *this;
+        }
+
+        attribute_iterator operator--(int)
+        {
+            attribute_iterator tmp = *this;
+            ++this;
+            return tmp;
+        }
+
+        bool operator ==(const attribute_iterator<Ch> &rhs)
+        {
+            return m_attribute == rhs.m_attribute;
+        }
+
+        bool operator !=(const attribute_iterator<Ch> &rhs)
+        {
+            return m_attribute != rhs.m_attribute;
+        }
+
+    private:
+
+        xml_attribute<Ch> *m_attribute;
+
+    };
+
+}
+
+#endif
diff --git a/lib/rapidxml/rapidxml_print.hpp b/lib/rapidxml/rapidxml_print.hpp
new file mode 100644
index 0000000..0ae2b14
--- /dev/null
+++ b/lib/rapidxml/rapidxml_print.hpp
@@ -0,0 +1,421 @@
+#ifndef RAPIDXML_PRINT_HPP_INCLUDED
+#define RAPIDXML_PRINT_HPP_INCLUDED
+
+// Copyright (C) 2006, 2009 Marcin Kalicinski
+// Version 1.13
+// Revision $DateTime: 2009/05/13 01:46:17 $
+//! \file rapidxml_print.hpp This file contains rapidxml printer implementation
+
+#include "rapidxml.hpp"
+
+// Only include streams if not disabled
+#ifndef RAPIDXML_NO_STREAMS
+    #include <ostream>
+    #include <iterator>
+#endif
+
+namespace rapidxml
+{
+
+    ///////////////////////////////////////////////////////////////////////
+    // Printing flags
+
+    const int print_no_indenting = 0x1;   //!< Printer flag instructing the printer to suppress indenting of XML. See print() function.
+
+    ///////////////////////////////////////////////////////////////////////
+    // Internal
+
+    //! \cond internal
+    namespace internal
+    {
+        
+        ///////////////////////////////////////////////////////////////////////////
+        // Internal character operations
+    
+        // Copy characters from given range to given output iterator
+        template<class OutIt, class Ch>
+        inline OutIt copy_chars(const Ch *begin, const Ch *end, OutIt out)
+        {
+            while (begin != end)
+                *out++ = *begin++;
+            return out;
+        }
+        
+        // Copy characters from given range to given output iterator and expand
+        // characters into references (&lt; &gt; &apos; &quot; &amp;)
+        template<class OutIt, class Ch>
+        inline OutIt copy_and_expand_chars(const Ch *begin, const Ch *end, Ch noexpand, OutIt out)
+        {
+            while (begin != end)
+            {
+                if (*begin == noexpand)
+                {
+                    *out++ = *begin;    // No expansion, copy character
+                }
+                else
+                {
+                    switch (*begin)
+                    {
+                    case Ch('<'):
+                        *out++ = Ch('&'); *out++ = Ch('l'); *out++ = Ch('t'); *out++ = Ch(';');
+                        break;
+                    case Ch('>'): 
+                        *out++ = Ch('&'); *out++ = Ch('g'); *out++ = Ch('t'); *out++ = Ch(';');
+                        break;
+                    case Ch('\''): 
+                        *out++ = Ch('&'); *out++ = Ch('a'); *out++ = Ch('p'); *out++ = Ch('o'); *out++ = Ch('s'); *out++ = Ch(';');
+                        break;
+                    case Ch('"'): 
+                        *out++ = Ch('&'); *out++ = Ch('q'); *out++ = Ch('u'); *out++ = Ch('o'); *out++ = Ch('t'); *out++ = Ch(';');
+                        break;
+                    case Ch('&'): 
+                        *out++ = Ch('&'); *out++ = Ch('a'); *out++ = Ch('m'); *out++ = Ch('p'); *out++ = Ch(';'); 
+                        break;
+                    default:
+                        *out++ = *begin;    // No expansion, copy character
+                    }
+                }
+                ++begin;    // Step to next character
+            }
+            return out;
+        }
+
+        // Fill given output iterator with repetitions of the same character
+        template<class OutIt, class Ch>
+        inline OutIt fill_chars(OutIt out, int n, Ch ch)
+        {
+            for (int i = 0; i < n; ++i)
+                *out++ = ch;
+            return out;
+        }
+
+        // Find character
+        template<class Ch, Ch ch>
+        inline bool find_char(const Ch *begin, const Ch *end)
+        {
+            while (begin != end)
+                if (*begin++ == ch)
+                    return true;
+            return false;
+        }
+
+        ///////////////////////////////////////////////////////////////////////////
+        // Internal printing operations
+    
+        // Print node
+        template<class OutIt, class Ch>
+        inline OutIt print_node(OutIt out, const xml_node<Ch> *node, int flags, int indent)
+        {
+            // Print proper node type
+            switch (node->type())
+            {
+
+            // Document
+            case node_document:
+                out = print_children(out, node, flags, indent);
+                break;
+
+            // Element
+            case node_element:
+                out = print_element_node(out, node, flags, indent);
+                break;
+            
+            // Data
+            case node_data:
+                out = print_data_node(out, node, flags, indent);
+                break;
+            
+            // CDATA
+            case node_cdata:
+                out = print_cdata_node(out, node, flags, indent);
+                break;
+
+            // Declaration
+            case node_declaration:
+                out = print_declaration_node(out, node, flags, indent);
+                break;
+
+            // Comment
+            case node_comment:
+                out = print_comment_node(out, node, flags, indent);
+                break;
+            
+            // Doctype
+            case node_doctype:
+                out = print_doctype_node(out, node, flags, indent);
+                break;
+
+            // Pi
+            case node_pi:
+                out = print_pi_node(out, node, flags, indent);
+                break;
+
+                // Unknown
+            default:
+                assert(0);
+                break;
+            }
+            
+            // If indenting not disabled, add line break after node
+            if (!(flags & print_no_indenting))
+                *out = Ch('\n'), ++out;
+
+            // Return modified iterator
+            return out;
+        }
+        
+        // Print children of the node                               
+        template<class OutIt, class Ch>
+        inline OutIt print_children(OutIt out, const xml_node<Ch> *node, int flags, int indent)
+        {
+            for (xml_node<Ch> *child = node->first_node(); child; child = child->next_sibling())
+                out = print_node(out, child, flags, indent);
+            return out;
+        }
+
+        // Print attributes of the node
+        template<class OutIt, class Ch>
+        inline OutIt print_attributes(OutIt out, const xml_node<Ch> *node, int flags)
+        {
+            for (xml_attribute<Ch> *attribute = node->first_attribute(); attribute; attribute = attribute->next_attribute())
+            {
+                if (attribute->name() && attribute->value())
+                {
+                    // Print attribute name
+                    *out = Ch(' '), ++out;
+                    out = copy_chars(attribute->name(), attribute->name() + attribute->name_size(), out);
+                    *out = Ch('='), ++out;
+                    // Print attribute value using appropriate quote type
+                    if (find_char<Ch, Ch('"')>(attribute->value(), attribute->value() + attribute->value_size()))
+                    {
+                        *out = Ch('\''), ++out;
+                        out = copy_and_expand_chars(attribute->value(), attribute->value() + attribute->value_size(), Ch('"'), out);
+                        *out = Ch('\''), ++out;
+                    }
+                    else
+                    {
+                        *out = Ch('"'), ++out;
+                        out = copy_and_expand_chars(attribute->value(), attribute->value() + attribute->value_size(), Ch('\''), out);
+                        *out = Ch('"'), ++out;
+                    }
+                }
+            }
+            return out;
+        }
+
+        // Print data node
+        template<class OutIt, class Ch>
+        inline OutIt print_data_node(OutIt out, const xml_node<Ch> *node, int flags, int indent)
+        {
+            assert(node->type() == node_data);
+            if (!(flags & print_no_indenting))
+                out = fill_chars(out, indent, Ch('\t'));
+            out = copy_and_expand_chars(node->value(), node->value() + node->value_size(), Ch(0), out);
+            return out;
+        }
+
+        // Print data node
+        template<class OutIt, class Ch>
+        inline OutIt print_cdata_node(OutIt out, const xml_node<Ch> *node, int flags, int indent)
+        {
+            assert(node->type() == node_cdata);
+            if (!(flags & print_no_indenting))
+                out = fill_chars(out, indent, Ch('\t'));
+            *out = Ch('<'); ++out;
+            *out = Ch('!'); ++out;
+            *out = Ch('['); ++out;
+            *out = Ch('C'); ++out;
+            *out = Ch('D'); ++out;
+            *out = Ch('A'); ++out;
+            *out = Ch('T'); ++out;
+            *out = Ch('A'); ++out;
+            *out = Ch('['); ++out;
+            out = copy_chars(node->value(), node->value() + node->value_size(), out);
+            *out = Ch(']'); ++out;
+            *out = Ch(']'); ++out;
+            *out = Ch('>'); ++out;
+            return out;
+        }
+
+        // Print element node
+        template<class OutIt, class Ch>
+        inline OutIt print_element_node(OutIt out, const xml_node<Ch> *node, int flags, int indent)
+        {
+            assert(node->type() == node_element);
+
+            // Print element name and attributes, if any
+            if (!(flags & print_no_indenting))
+                out = fill_chars(out, indent, Ch('\t'));
+            *out = Ch('<'), ++out;
+            out = copy_chars(node->name(), node->name() + node->name_size(), out);
+            out = print_attributes(out, node, flags);
+            
+            // If node is childless
+            if (node->value_size() == 0 && !node->first_node())
+            {
+                // Print childless node tag ending
+                *out = Ch('/'), ++out;
+                *out = Ch('>'), ++out;
+            }
+            else
+            {
+                // Print normal node tag ending
+                *out = Ch('>'), ++out;
+
+                // Test if node contains a single data node only (and no other nodes)
+                xml_node<Ch> *child = node->first_node();
+                if (!child)
+                {
+                    // If node has no children, only print its value without indenting
+                    out = copy_and_expand_chars(node->value(), node->value() + node->value_size(), Ch(0), out);
+                }
+                else if (child->next_sibling() == 0 && child->type() == node_data)
+                {
+                    // If node has a sole data child, only print its value without indenting
+                    out = copy_and_expand_chars(child->value(), child->value() + child->value_size(), Ch(0), out);
+                }
+                else
+                {
+                    // Print all children with full indenting
+                    if (!(flags & print_no_indenting))
+                        *out = Ch('\n'), ++out;
+                    out = print_children(out, node, flags, indent + 1);
+                    if (!(flags & print_no_indenting))
+                        out = fill_chars(out, indent, Ch('\t'));
+                }
+
+                // Print node end
+                *out = Ch('<'), ++out;
+                *out = Ch('/'), ++out;
+                out = copy_chars(node->name(), node->name() + node->name_size(), out);
+                *out = Ch('>'), ++out;
+            }
+            return out;
+        }
+
+        // Print declaration node
+        template<class OutIt, class Ch>
+        inline OutIt print_declaration_node(OutIt out, const xml_node<Ch> *node, int flags, int indent)
+        {
+            // Print declaration start
+            if (!(flags & print_no_indenting))
+                out = fill_chars(out, indent, Ch('\t'));
+            *out = Ch('<'), ++out;
+            *out = Ch('?'), ++out;
+            *out = Ch('x'), ++out;
+            *out = Ch('m'), ++out;
+            *out = Ch('l'), ++out;
+
+            // Print attributes
+            out = print_attributes(out, node, flags);
+            
+            // Print declaration end
+            *out = Ch('?'), ++out;
+            *out = Ch('>'), ++out;
+            
+            return out;
+        }
+
+        // Print comment node
+        template<class OutIt, class Ch>
+        inline OutIt print_comment_node(OutIt out, const xml_node<Ch> *node, int flags, int indent)
+        {
+            assert(node->type() == node_comment);
+            if (!(flags & print_no_indenting))
+                out = fill_chars(out, indent, Ch('\t'));
+            *out = Ch('<'), ++out;
+            *out = Ch('!'), ++out;
+            *out = Ch('-'), ++out;
+            *out = Ch('-'), ++out;
+            out = copy_chars(node->value(), node->value() + node->value_size(), out);
+            *out = Ch('-'), ++out;
+            *out = Ch('-'), ++out;
+            *out = Ch('>'), ++out;
+            return out;
+        }
+
+        // Print doctype node
+        template<class OutIt, class Ch>
+        inline OutIt print_doctype_node(OutIt out, const xml_node<Ch> *node, int flags, int indent)
+        {
+            assert(node->type() == node_doctype);
+            if (!(flags & print_no_indenting))
+                out = fill_chars(out, indent, Ch('\t'));
+            *out = Ch('<'), ++out;
+            *out = Ch('!'), ++out;
+            *out = Ch('D'), ++out;
+            *out = Ch('O'), ++out;
+            *out = Ch('C'), ++out;
+            *out = Ch('T'), ++out;
+            *out = Ch('Y'), ++out;
+            *out = Ch('P'), ++out;
+            *out = Ch('E'), ++out;
+            *out = Ch(' '), ++out;
+            out = copy_chars(node->value(), node->value() + node->value_size(), out);
+            *out = Ch('>'), ++out;
+            return out;
+        }
+
+        // Print pi node
+        template<class OutIt, class Ch>
+        inline OutIt print_pi_node(OutIt out, const xml_node<Ch> *node, int flags, int indent)
+        {
+            assert(node->type() == node_pi);
+            if (!(flags & print_no_indenting))
+                out = fill_chars(out, indent, Ch('\t'));
+            *out = Ch('<'), ++out;
+            *out = Ch('?'), ++out;
+            out = copy_chars(node->name(), node->name() + node->name_size(), out);
+            *out = Ch(' '), ++out;
+            out = copy_chars(node->value(), node->value() + node->value_size(), out);
+            *out = Ch('?'), ++out;
+            *out = Ch('>'), ++out;
+            return out;
+        }
+
+    }
+    //! \endcond
+
+    ///////////////////////////////////////////////////////////////////////////
+    // Printing
+
+    //! Prints XML to given output iterator.
+    //! \param out Output iterator to print to.
+    //! \param node Node to be printed. Pass xml_document to print entire document.
+    //! \param flags Flags controlling how XML is printed.
+    //! \return Output iterator pointing to position immediately after last character of printed text.
+    template<class OutIt, class Ch> 
+    inline OutIt print(OutIt out, const xml_node<Ch> &node, int flags = 0)
+    {
+        return internal::print_node(out, &node, flags, 0);
+    }
+
+#ifndef RAPIDXML_NO_STREAMS
+
+    //! Prints XML to given output stream.
+    //! \param out Output stream to print to.
+    //! \param node Node to be printed. Pass xml_document to print entire document.
+    //! \param flags Flags controlling how XML is printed.
+    //! \return Output stream.
+    template<class Ch> 
+    inline std::basic_ostream<Ch> &print(std::basic_ostream<Ch> &out, const xml_node<Ch> &node, int flags = 0)
+    {
+        print(std::ostream_iterator<Ch>(out), node, flags);
+        return out;
+    }
+
+    //! Prints formatted XML to given output stream. Uses default printing flags. Use print() function to customize printing process.
+    //! \param out Output stream to print to.
+    //! \param node Node to be printed.
+    //! \return Output stream.
+    template<class Ch> 
+    inline std::basic_ostream<Ch> &operator <<(std::basic_ostream<Ch> &out, const xml_node<Ch> &node)
+    {
+        return print(out, node);
+    }
+
+#endif
+
+}
+
+#endif
diff --git a/lib/rapidxml/rapidxml_utils.hpp b/lib/rapidxml/rapidxml_utils.hpp
new file mode 100644
index 0000000..37c2953
--- /dev/null
+++ b/lib/rapidxml/rapidxml_utils.hpp
@@ -0,0 +1,122 @@
+#ifndef RAPIDXML_UTILS_HPP_INCLUDED
+#define RAPIDXML_UTILS_HPP_INCLUDED
+
+// Copyright (C) 2006, 2009 Marcin Kalicinski
+// Version 1.13
+// Revision $DateTime: 2009/05/13 01:46:17 $
+//! \file rapidxml_utils.hpp This file contains high-level rapidxml utilities that can be useful
+//! in certain simple scenarios. They should probably not be used if maximizing performance is the main objective.
+
+#include "rapidxml.hpp"
+#include <vector>
+#include <string>
+#include <fstream>
+#include <stdexcept>
+
+namespace rapidxml
+{
+
+    //! Represents data loaded from a file
+    template<class Ch = char>
+    class file
+    {
+        
+    public:
+        
+        //! Loads file into the memory. Data will be automatically destroyed by the destructor.
+        //! \param filename Filename to load.
+        file(const char *filename)
+        {
+            using namespace std;
+
+            // Open stream
+            basic_ifstream<Ch> stream(filename, ios::binary);
+            if (!stream)
+                throw runtime_error(string("cannot open file ") + filename);
+            stream.unsetf(ios::skipws);
+            
+            // Determine stream size
+            stream.seekg(0, ios::end);
+            size_t size = stream.tellg();
+            stream.seekg(0);   
+            
+            // Load data and add terminating 0
+            m_data.resize(size + 1);
+            stream.read(&m_data.front(), static_cast<streamsize>(size));
+            m_data[size] = 0;
+        }
+
+        //! Loads file into the memory. Data will be automatically destroyed by the destructor
+        //! \param stream Stream to load from
+        file(std::basic_istream<Ch> &stream)
+        {
+            using namespace std;
+
+            // Load data and add terminating 0
+            stream.unsetf(ios::skipws);
+            m_data.assign(istreambuf_iterator<Ch>(stream), istreambuf_iterator<Ch>());
+            if (stream.fail() || stream.bad())
+                throw runtime_error("error reading stream");
+            m_data.push_back(0);
+        }
+        
+        //! Gets file data.
+        //! \return Pointer to data of file.
+        Ch *data()
+        {
+            return &m_data.front();
+        }
+
+        //! Gets file data.
+        //! \return Pointer to data of file.
+        const Ch *data() const
+        {
+            return &m_data.front();
+        }
+
+        //! Gets file data size.
+        //! \return Size of file data, in characters.
+        std::size_t size() const
+        {
+            return m_data.size();
+        }
+
+    private:
+
+        std::vector<Ch> m_data;   // File data
+
+    };
+
+    //! Counts children of node. Time complexity is O(n).
+    //! \return Number of children of node
+    template<class Ch>
+    inline std::size_t count_children(xml_node<Ch> *node)
+    {
+        xml_node<Ch> *child = node->first_node();
+        std::size_t count = 0;
+        while (child)
+        {
+            ++count;
+            child = child->next_sibling();
+        }
+        return count;
+    }
+
+    //! Counts attributes of node. Time complexity is O(n).
+    //! \return Number of attributes of node
+    template<class Ch>
+    inline std::size_t count_attributes(xml_node<Ch> *node)
+    {
+        xml_attribute<Ch> *attr = node->first_attribute();
+        std::size_t count = 0;
+        while (attr)
+        {
+            ++count;
+            attr = attr->next_attribute();
+        }
+        return count;
+    }
+
+}
+
+#endif
diff --git a/project/BuildDependencies/scripts/zlib_d.bat b/project/BuildDependencies/scripts/zlib_d.bat
new file mode 100644
index 0000000..669c921
--- /dev/null
+++ b/project/BuildDependencies/scripts/zlib_d.bat
@@ -0,0 +1,13 @@
+@ECHO OFF
+
+SET LOC_PATH=%CD%
+SET FILES=%LOC_PATH%\zlib_d.txt
+
+CALL dlextract.bat zlib %FILES%
+
+cd %TMP_PATH%
+
+xcopy include\* "%CUR_PATH%\include\" /E /Q /I /Y
+copy lib\zlib.lib "%CUR_PATH%\lib\" /Y
+
+cd %LOC_PATH%
diff --git a/project/BuildDependencies/scripts/zlib_d.txt b/project/BuildDependencies/scripts/zlib_d.txt
new file mode 100644
index 0000000..ac57737
--- /dev/null
+++ b/project/BuildDependencies/scripts/zlib_d.txt
@@ -0,0 +1,2 @@
+; filename                       mirror
+zlib-vc100-1.2.5-lib.tar.bz2     http://mirrors.xbmc.org/build-deps/win32/
diff --git a/project/VS2010Express/xbmc-pvr-addons.sln b/project/VS2010Express/xbmc-pvr-addons.sln
index 3b487ed..eb3a16e 100644
--- a/project/VS2010Express/xbmc-pvr-addons.sln
+++ b/project/VS2010Express/xbmc-pvr-addons.sln
@@ -41,6 +41,8 @@ Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "pvr.dvbviewer", "..\..\addo
 EndProject
 Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "pvr.argustv", "..\..\addons\pvr.argustv\project\VS2010Express\pvr.argustv.vcxproj", "{8D24D95E-3C4E-4DC5-ABEF-C35C938C2EBB}"
 EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "pvr.iptvsimple", "..\..\addons\pvr.iptvsimple\project\VS2010Express\pvr.iptvsimple.vcxproj", "{6C67B057-CE98-4732-AABF-0E374C718815}"
+EndProject
 Global
 	GlobalSection(SolutionConfigurationPlatforms) = preSolution
 		Debug|Win32 = Debug|Win32
@@ -107,6 +109,10 @@ Global
 		{8D24D95E-3C4E-4DC5-ABEF-C35C938C2EBB}.Debug|Win32.Build.0 = Debug|Win32
 		{8D24D95E-3C4E-4DC5-ABEF-C35C938C2EBB}.Release|Win32.ActiveCfg = Release|Win32
 		{8D24D95E-3C4E-4DC5-ABEF-C35C938C2EBB}.Release|Win32.Build.0 = Release|Win32
+		{6C67B057-CE98-4732-AABF-0E374C718815}.Debug|Win32.ActiveCfg = Debug|Win32
+		{6C67B057-CE98-4732-AABF-0E374C718815}.Debug|Win32.Build.0 = Debug|Win32
+		{6C67B057-CE98-4732-AABF-0E374C718815}.Release|Win32.ActiveCfg = Release|Win32
+		{6C67B057-CE98-4732-AABF-0E374C718815}.Release|Win32.Build.0 = Release|Win32
 	EndGlobalSection
 	GlobalSection(SolutionProperties) = preSolution
 		HideSolutionNode = FALSE
-- 
1.8.1.6

