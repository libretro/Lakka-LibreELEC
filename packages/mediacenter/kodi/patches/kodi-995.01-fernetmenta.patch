From 5acb9e7a7c70dc38ca18799d4908b96f242551dc Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Mon, 28 May 2012 10:49:05 +0200
Subject: [PATCH 04/24] dvdplayer: allow rewinding at end of stream, do a seek
 after rewind

---
 xbmc/cores/dvdplayer/DVDPlayer.cpp | 8 +++++++-
 1 file changed, 7 insertions(+), 1 deletion(-)

diff --git a/xbmc/cores/dvdplayer/DVDPlayer.cpp b/xbmc/cores/dvdplayer/DVDPlayer.cpp
index 63cbe66..f5f697e 100644
--- a/xbmc/cores/dvdplayer/DVDPlayer.cpp
+++ b/xbmc/cores/dvdplayer/DVDPlayer.cpp
@@ -1793,7 +1793,7 @@ void CDVDPlayer::HandlePlaySpeed()
 
     }
     else if (m_CurrentVideo.id >= 0
-          &&  m_CurrentVideo.inited == true
+          &&  (m_CurrentVideo.inited == true || GetPlaySpeed() < 0) // allow rewind at end of file
           &&  m_SpeedState.lastpts  != m_dvdPlayerVideo->GetCurrentPts()
           &&  m_SpeedState.lasttime != GetTime())
     {
@@ -2440,6 +2440,12 @@ void CDVDPlayer::HandleMessages()
           pvrinputstream->Pause( speed == 0 );
         }
 
+        // do a seek after rewind, clock is not in sync with current pts
+        if (m_playSpeed < 0 && speed >= 0)
+        {
+          m_messenger.Put(new CDVDMsgPlayerSeek(GetTime(), true, true, true));
+        }
+
         // if playspeed is different then DVD_PLAYSPEED_NORMAL or DVD_PLAYSPEED_PAUSE
         // audioplayer, stops outputing audio to audiorendere, but still tries to
         // sleep an correct amount for each packet

From 35a6e814939d4e4f900595f2b1efd5a2aa131ab0 Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Mon, 20 Aug 2012 16:06:39 +0200
Subject: [PATCH 05/24] dvdplayer: observe pts counter overflow

---
 .../cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.cpp | 197 ++++++++++++++++++++-
 xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.h  |   3 +
 2 files changed, 199 insertions(+), 1 deletion(-)

diff --git a/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.cpp b/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.cpp
index a9a8f0a..368de0e 100644
--- a/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.cpp
+++ b/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.cpp
@@ -18,7 +18,6 @@
  *
  */
 
-#include "system.h"
 #ifndef __STDC_CONSTANT_MACROS
 #define __STDC_CONSTANT_MACROS
 #endif
@@ -26,6 +25,7 @@
 #define __STDC_LIMIT_MACROS
 #endif
 #ifdef TARGET_POSIX
+#include "system.h"
 #include "stdint.h"
 #endif
 #include "DVDDemuxFFmpeg.h"
@@ -477,6 +477,9 @@ bool CDVDDemuxFFmpeg::Open(CDVDInputStream* pInput, bool streaminfo, bool filein
   if (skipCreateStreams && GetNrOfStreams() == 0)
     m_program = 0;
 
+  m_bPtsWrapChecked = false;
+  m_bPtsWrap = false;
+
   return true;
 }
 
@@ -617,6 +620,12 @@ double CDVDDemuxFFmpeg::ConvertTimestamp(int64_t pts, int den, int num)
   if (pts == (int64_t)AV_NOPTS_VALUE)
     return DVD_NOPTS_VALUE;
 
+  if (m_bPtsWrap)
+  {
+    if (pts < m_iStartTime && pts < m_iEndTime)
+      pts += m_iMaxTime;
+  }
+
   // do calculations in floats as they can easily overflow otherwise
   // we don't care for having a completly exact timestamp anyway
   double timestamp = (double)pts * num  / den;
@@ -763,6 +772,24 @@ DemuxPacket* CDVDDemuxFFmpeg::Read()
           m_pkt.pkt.pts = AV_NOPTS_VALUE;
         }
 
+        if (!m_bPtsWrapChecked && m_pFormatContext->iformat->flags & AVFMT_TS_DISCONT)
+        {
+          int defaultStream = av_find_default_stream_index(m_pFormatContext);
+          int64_t duration = m_pFormatContext->streams[defaultStream]->duration * 1.5;
+          m_iMaxTime = 1LL<<m_pFormatContext->streams[defaultStream]->pts_wrap_bits;
+          m_iStartTime = m_pFormatContext->streams[defaultStream]->start_time;
+          if (m_iStartTime != DVD_NOPTS_VALUE)
+          {
+            m_iEndTime = (m_iStartTime + duration) & ~m_iMaxTime;
+            if (m_iEndTime < m_iStartTime)
+            {
+              CLog::Log(LOGNOTICE,"CDVDDemuxFFmpeg::Read - file contains pts overflow");
+              m_bPtsWrap = true;
+            }
+          }
+          m_bPtsWrapChecked = true;
+        }
+
         // copy contents into our own packet
         pPacket->iSize = m_pkt.pkt.size;
 
@@ -896,7 +923,16 @@ bool CDVDDemuxFFmpeg::SeekTime(int time, bool backwords, double *startpts)
     ret = av_seek_frame(m_pFormatContext, -1, seek_pts, backwords ? AVSEEK_FLAG_BACKWARD : 0);
 
     if(ret >= 0)
+    {
       UpdateCurrentPTS();
+
+      // seek may fail silently on streams which allow discontinuity
+      // if current timestamp is way off asume a pts overflow and try bisect seek
+      if (m_bPtsWrap && fabs(time - m_iCurrentPts/1000) > 10000)
+      {
+        ret = SeekTimeDiscont(seek_pts, backwords) ? 1 : -1;
+      }
+    }
   }
 
   if(m_currentPts == DVD_NOPTS_VALUE)
@@ -915,6 +951,165 @@ bool CDVDDemuxFFmpeg::SeekTime(int time, bool backwords, double *startpts)
   return (ret >= 0);
 }
 
+bool CDVDDemuxFFmpeg::SeekTimeDiscont(int64_t pts, bool backwards)
+{
+  // this code is taken from ffmpeg function ff_gen_search
+  // it is modified to assume a pts overflow if timestamp < start_time
+  if (!m_pFormatContext->iformat->read_timestamp)
+    return false;
+
+  int defaultStream = av_find_default_stream_index(m_pFormatContext);
+
+  if (defaultStream < 0)
+  {
+    return false;
+  }
+
+  // timestamp for default must be expressed in AV_TIME_BASE units
+  pts = av_rescale_rnd(pts, m_pFormatContext->streams[defaultStream]->time_base.den,
+                      AV_TIME_BASE * (int64_t)m_pFormatContext->streams[defaultStream]->time_base.num,
+                      AV_ROUND_NEAR_INF);
+
+  int64_t pos, pos_min, pos_max, pos_limit, ts, ts_min, ts_max;
+  int64_t start_pos, filesize;
+  int no_change;
+
+  pos_min = m_pFormatContext->data_offset;
+  ts_min = m_pFormatContext->iformat->read_timestamp(m_pFormatContext, defaultStream,
+                                                     &pos_min, INT64_MAX);
+  if (ts_min == AV_NOPTS_VALUE)
+    return false;
+
+  if(ts_min >= pts)
+  {
+    pos = pos_min;
+    return true;
+  }
+
+  int step= 1024;
+  filesize = m_pInput->GetLength();
+  pos_max = filesize - 1;
+  do
+  {
+    pos_max -= step;
+    ts_max = m_pFormatContext->iformat->read_timestamp(m_pFormatContext, defaultStream,
+                                                       &pos_max, pos_max + step);
+    step += step;
+  }while (ts_max == AV_NOPTS_VALUE && pos_max >= step);
+
+  if (ts_max == AV_NOPTS_VALUE)
+    return false;
+
+  if (ts_max < m_iStartTime && ts_max < m_iEndTime)
+    ts_max += m_iMaxTime;
+
+  for(;;)
+  {
+    int64_t tmp_pos = pos_max + 1;
+    int64_t tmp_ts = m_pFormatContext->iformat->read_timestamp(m_pFormatContext, defaultStream,
+                                                               &tmp_pos, INT64_MAX);
+    if(tmp_ts == AV_NOPTS_VALUE)
+      break;
+
+    if (tmp_ts < m_iStartTime && tmp_ts < m_iEndTime)
+      tmp_ts += m_iMaxTime;
+
+    ts_max = tmp_ts;
+    pos_max = tmp_pos;
+    if (tmp_pos >= filesize)
+      break;
+  }
+  pos_limit = pos_max;
+
+  if(ts_max <= pts)
+  {
+    bool ret = SeekByte(pos_max);
+    if (ret)
+    {
+      m_iCurrentPts = ConvertTimestamp(ts_max, m_pFormatContext->streams[defaultStream]->time_base.den,
+                                       m_pFormatContext->streams[defaultStream]->time_base.num);
+    }
+    return ret;
+  }
+
+  if(ts_min > ts_max)
+  {
+    return false;
+  }
+  else if (ts_min == ts_max)
+  {
+    pos_limit = pos_min;
+  }
+
+  no_change=0;
+  while (pos_min < pos_limit)
+  {
+    if (no_change == 0)
+    {
+      int64_t approximate_keyframe_distance= pos_max - pos_limit;
+      // interpolate position (better than dichotomy)
+      pos = av_rescale_rnd(pts - ts_min, pos_max - pos_min,
+                                       ts_max - ts_min, AV_ROUND_NEAR_INF)
+          + pos_min - approximate_keyframe_distance;
+    }
+    else if (no_change == 1)
+    {
+      // bisection, if interpolation failed to change min or max pos last time
+      pos = (pos_min + pos_limit) >> 1;
+    }
+    else
+    {
+      /* linear search if bisection failed, can only happen if there
+         are very few or no keyframes between min/max */
+      pos = pos_min;
+    }
+    if (pos <= pos_min)
+      pos= pos_min + 1;
+    else if (pos > pos_limit)
+      pos= pos_limit;
+    start_pos = pos;
+
+    ts = m_pFormatContext->iformat->read_timestamp(m_pFormatContext, defaultStream,
+                                                   &pos, INT64_MAX);
+    if (pos == pos_max)
+      no_change++;
+    else
+      no_change=0;
+
+    if (ts == AV_NOPTS_VALUE)
+    {
+      return false;
+    }
+
+    if (ts < m_iStartTime && ts < m_iEndTime)
+      ts += m_iMaxTime;
+
+    if (pts <= ts)
+    {
+      pos_limit = start_pos - 1;
+      pos_max = pos;
+      ts_max = ts;
+    }
+    if (pts >= ts)
+    {
+      pos_min = pos;
+      ts_min = ts;
+    }
+  }
+
+  pos = (backwards) ? pos_min : pos_max;
+  ts  = (backwards) ?  ts_min :  ts_max;
+
+  bool ret = SeekByte(pos);
+  if (ret)
+  {
+    m_iCurrentPts = ConvertTimestamp(ts, m_pFormatContext->streams[defaultStream]->time_base.den,
+                                     m_pFormatContext->streams[defaultStream]->time_base.num);
+  }
+
+  return ret;
+}
+
 bool CDVDDemuxFFmpeg::SeekByte(int64_t pos)
 {
   CSingleLock lock(m_critSection);
diff --git a/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.h b/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.h
index c2f607d..b7daa34 100644
--- a/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.h
+++ b/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.h
@@ -102,6 +102,7 @@ class CDVDDemuxFFmpeg : public CDVDDemux
   DemuxPacket* Read();
 
   bool SeekTime(int time, bool backwords = false, double* startpts = NULL);
+  bool SeekTimeDiscont(int64_t pts, bool backwards);
   bool SeekByte(int64_t pos);
   int GetStreamLength();
   CDemuxStream* GetStream(int iStreamId);
@@ -165,5 +166,7 @@ class CDVDDemuxFFmpeg : public CDVDDemux
 
   bool m_streaminfo;
   bool m_checkvideo;
+  bool m_bPtsWrap, m_bPtsWrapChecked;
+  int64_t m_iStartTime, m_iMaxTime, m_iEndTime;
 };
 

From eb6c9ab05b9e11f9fba0ec2187102dbf50b48e47 Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Tue, 2 Oct 2012 13:02:10 +0200
Subject: [PATCH 06/24] dvdplayer: avoid short screen flicker caused by
 unnecessary reconfigure of renderer

---
 xbmc/cores/dvdplayer/DVDPlayerVideo.cpp | 5 ++++-
 1 file changed, 4 insertions(+), 1 deletion(-)

diff --git a/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp b/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
index 4f35e3a..4c0551d 100644
--- a/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
+++ b/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
@@ -1052,13 +1052,16 @@ int CDVDPlayerVideo::OutputPicture(const DVDVideoPicture* src, double pts)
 
 #ifdef HAS_VIDEO_PLAYBACK
   double config_framerate = m_bFpsInvalid ? 0.0 : m_fFrameRate;
+  double render_framerate = g_graphicsContext.GetFPS();
+  if (CSettings::Get().GetInt("videoplayer.adjustrefreshrate") == ADJUST_REFRESHRATE_OFF)
+    render_framerate = config_framerate;
   /* check so that our format or aspect has changed. if it has, reconfigure renderer */
   if (!g_renderManager.IsConfigured()
    || ( m_output.width           != pPicture->iWidth )
    || ( m_output.height          != pPicture->iHeight )
    || ( m_output.dwidth          != pPicture->iDisplayWidth )
    || ( m_output.dheight         != pPicture->iDisplayHeight )
-   || ( m_output.framerate       != config_framerate )
+   || (!m_bFpsInvalid && fmod(m_output.framerate, config_framerate) != 0.0 && render_framerate != config_framerate)
    || ( m_output.color_format    != (unsigned int)pPicture->format )
    || ( m_output.extended_format != pPicture->extended_format )
    || ( m_output.color_matrix    != pPicture->color_matrix    && pPicture->color_matrix    != 0 ) // don't reconfigure on unspecified

From 8a105d14b71c550128a2bb45a2e620992161ea28 Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Thu, 11 Oct 2012 12:05:50 +0200
Subject: [PATCH 07/24] vdpau: advanced settings for auto deinterlacing

---
 xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp | 8 ++++----
 xbmc/settings/AdvancedSettings.cpp             | 4 ++++
 xbmc/settings/AdvancedSettings.h               | 2 ++
 3 files changed, 10 insertions(+), 4 deletions(-)

diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
index e5e7970..8c353af 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
@@ -1958,10 +1958,10 @@ EINTERLACEMETHOD CMixer::GetDeinterlacingMethod(bool log /* = false */)
   if (method == VS_INTERLACEMETHOD_AUTO)
   {
     int deint = -1;
-//    if (m_config.outHeight >= 720)
-//      deint = g_advancedSettings.m_videoVDPAUdeintHD;
-//    else
-//      deint = g_advancedSettings.m_videoVDPAUdeintSD;
+    if (m_config.outHeight >= 720)
+      deint = g_advancedSettings.m_videoVDPAUdeintHD;
+    else
+      deint = g_advancedSettings.m_videoVDPAUdeintSD;
 
     if (deint != -1)
     {
diff --git a/xbmc/settings/AdvancedSettings.cpp b/xbmc/settings/AdvancedSettings.cpp
index 7d04872..89069a9 100644
--- a/xbmc/settings/AdvancedSettings.cpp
+++ b/xbmc/settings/AdvancedSettings.cpp
@@ -157,6 +157,8 @@ void CAdvancedSettings::Initialize()
   m_videoAutoScaleMaxFps = 30.0f;
   m_videoDisableBackgroundDeinterlace = false;
   m_videoCaptureUseOcclusionQuery = -1; //-1 is auto detect
+  m_videoVDPAUdeintHD = -1;
+  m_videoVDPAUdeintSD = -1;
   m_videoVDPAUtelecine = false;
   m_videoVDPAUdeintSkipChromaHD = false;
   m_DXVACheckCompatibility = false;
@@ -588,6 +590,8 @@ void CAdvancedSettings::ParseSettingsFile(const CStdString &file)
     XMLUtils::GetFloat(pElement,"autoscalemaxfps",m_videoAutoScaleMaxFps, 0.0f, 1000.0f);
     XMLUtils::GetBoolean(pElement, "disablebackgrounddeinterlace", m_videoDisableBackgroundDeinterlace);
     XMLUtils::GetInt(pElement, "useocclusionquery", m_videoCaptureUseOcclusionQuery, -1, 1);
+    XMLUtils::GetInt(pElement,"vdpauHDdeint",m_videoVDPAUdeintHD);
+    XMLUtils::GetInt(pElement,"vdpauSDdeint",m_videoVDPAUdeintSD);
     XMLUtils::GetBoolean(pElement,"vdpauInvTelecine",m_videoVDPAUtelecine);
     XMLUtils::GetBoolean(pElement,"vdpauHDdeintSkipChroma",m_videoVDPAUdeintSkipChromaHD);
 
diff --git a/xbmc/settings/AdvancedSettings.h b/xbmc/settings/AdvancedSettings.h
index 7df586e..eccd25c 100644
--- a/xbmc/settings/AdvancedSettings.h
+++ b/xbmc/settings/AdvancedSettings.h
@@ -162,6 +162,8 @@ class CAdvancedSettings : public ISettingCallback, public ISettingsHandler
     int m_videoPercentSeekBackwardBig;
     CStdString m_videoPPFFmpegDeint;
     CStdString m_videoPPFFmpegPostProc;
+    int m_videoVDPAUdeintHD;
+    int m_videoVDPAUdeintSD;
     bool m_videoVDPAUtelecine;
     bool m_videoVDPAUdeintSkipChromaHD;
     bool m_musicUseTimeSeeking;

From 399576b60dda39f175c8e06b7f53be5a61e6417f Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Fri, 2 Nov 2012 13:20:03 +0100
Subject: [PATCH 08/24] player: fix rewind

---
 xbmc/cores/dvdplayer/DVDMessage.h       |  5 +++-
 xbmc/cores/dvdplayer/DVDPlayer.cpp      | 41 ++++++++++++++++++++++-----------
 xbmc/cores/dvdplayer/DVDPlayer.h        |  8 ++++---
 xbmc/cores/dvdplayer/DVDPlayerVideo.cpp | 18 ++++++++++++++-
 xbmc/cores/dvdplayer/DVDPlayerVideo.h   |  1 +
 5 files changed, 55 insertions(+), 18 deletions(-)

diff --git a/xbmc/cores/dvdplayer/DVDMessage.h b/xbmc/cores/dvdplayer/DVDMessage.h
index a365821..07366df 100644
--- a/xbmc/cores/dvdplayer/DVDMessage.h
+++ b/xbmc/cores/dvdplayer/DVDMessage.h
@@ -212,7 +212,7 @@ class CDVDMsgPlayerSetState : public CDVDMsg
 class CDVDMsgPlayerSeek : public CDVDMsg
 {
 public:
-  CDVDMsgPlayerSeek(int time, bool backward, bool flush = true, bool accurate = true, bool restore = true, bool trickplay = false)
+  CDVDMsgPlayerSeek(int time, bool backward, bool flush = true, bool accurate = true, bool restore = true, bool trickplay = false, bool sync = true)
     : CDVDMsg(PLAYER_SEEK)
     , m_time(time)
     , m_backward(backward)
@@ -220,6 +220,7 @@ class CDVDMsgPlayerSeek : public CDVDMsg
     , m_accurate(accurate)
     , m_restore(restore)
     , m_trickplay(trickplay)
+    , m_sync(sync)
   {}
   int  GetTime()              { return m_time; }
   bool GetBackward()          { return m_backward; }
@@ -227,6 +228,7 @@ class CDVDMsgPlayerSeek : public CDVDMsg
   bool GetAccurate()          { return m_accurate; }
   bool GetRestore()           { return m_restore; }
   bool GetTrickPlay()         { return m_trickplay; }
+  bool GetSync()              { return m_sync; }
 private:
   int  m_time;
   bool m_backward;
@@ -234,6 +236,7 @@ class CDVDMsgPlayerSeek : public CDVDMsg
   bool m_accurate;
   bool m_restore; // whether to restore any EDL cut time
   bool m_trickplay;
+  bool m_sync;
 };
 
 class CDVDMsgPlayerSeekChapter : public CDVDMsg
diff --git a/xbmc/cores/dvdplayer/DVDPlayer.cpp b/xbmc/cores/dvdplayer/DVDPlayer.cpp
index f5f697e..60dab1f 100644
--- a/xbmc/cores/dvdplayer/DVDPlayer.cpp
+++ b/xbmc/cores/dvdplayer/DVDPlayer.cpp
@@ -590,6 +590,7 @@ bool CDVDPlayer::OpenFile(const CFileItem& file, const CPlayerOptions &options)
     SetPlaySpeed(DVD_PLAYSPEED_NORMAL);
 
     m_State.Clear();
+    memset(&m_SpeedState, 0, sizeof(m_SpeedState));
     m_UpdateApplication = 0;
     m_offset_pts = 0;
     m_CurrentAudio.originaldts = DVD_NOPTS_VALUE;
@@ -1794,11 +1795,13 @@ void CDVDPlayer::HandlePlaySpeed()
     }
     else if (m_CurrentVideo.id >= 0
           &&  (m_CurrentVideo.inited == true || GetPlaySpeed() < 0) // allow rewind at end of file
-          &&  m_SpeedState.lastpts  != m_dvdPlayerVideo->GetCurrentPts()
+          &&  (m_SpeedState.lastpts  != m_dvdPlayerVideo->GetCurrentPts() || fabs(m_SpeedState.lastabstime - CDVDClock::GetAbsoluteClock()) > DVD_MSEC_TO_TIME(200))
+          &&  (m_dvdPlayerVideo->GetCurrentPts() != DVD_NOPTS_VALUE)
           &&  m_SpeedState.lasttime != GetTime())
     {
       m_SpeedState.lastpts  = m_dvdPlayerVideo->GetCurrentPts();
       m_SpeedState.lasttime = (double) GetTime();
+      m_SpeedState.lastabstime = CDVDClock::GetAbsoluteClock();
       // check how much off clock video is when ff/rw:ing
       // a problem here is that seeking isn't very accurate
       // and since the clock will be resynced after seek
@@ -1815,9 +1818,15 @@ void CDVDPlayer::HandlePlaySpeed()
 
       if(error > DVD_MSEC_TO_TIME(1000))
       {
-        CLog::Log(LOGDEBUG, "CDVDPlayer::Process - Seeking to catch up");
-        int64_t iTime = (int64_t)DVD_TIME_TO_MSEC(m_clock.GetClock() + m_State.time_offset + 500000.0 * m_playSpeed / DVD_PLAYSPEED_NORMAL);
-        m_messenger.Put(new CDVDMsgPlayerSeek((int) iTime, (GetPlaySpeed() < 0), true, false, false, true));
+        error  = (int)DVD_TIME_TO_MSEC(m_clock.GetClock()) - m_SpeedState.lastseekpts;
+
+        if(abs(error) > 1000)
+        {
+          CLog::Log(LOGDEBUG, "CDVDPlayer::Process - Seeking to catch up");
+          m_SpeedState.lastseekpts = (int)DVD_TIME_TO_MSEC(m_clock.GetClock());
+          int iTime = DVD_TIME_TO_MSEC(m_clock.GetClock() + m_State.time_offset + 500000.0 * m_playSpeed / DVD_PLAYSPEED_NORMAL);
+          m_messenger.Put(new CDVDMsgPlayerSeek(iTime, (GetPlaySpeed() < 0), true, false, false, true, false));
+        }
       }
     }
   }
@@ -2289,7 +2298,7 @@ void CDVDPlayer::HandleMessages()
           else
             m_StateInput.dts = start;
 
-          FlushBuffers(!msg.GetFlush(), start, msg.GetAccurate());
+          FlushBuffers(!msg.GetFlush(), start, msg.GetAccurate(), msg.GetSync());
         }
         else
           CLog::Log(LOGWARNING, "error while seeking");
@@ -2425,9 +2434,10 @@ void CDVDPlayer::HandleMessages()
           double offset;
           offset  = CDVDClock::GetAbsoluteClock() - m_State.timestamp;
           offset *= m_playSpeed / DVD_PLAYSPEED_NORMAL;
+          offset  = DVD_TIME_TO_MSEC(offset);
           if(offset >  1000) offset =  1000;
           if(offset < -1000) offset = -1000;
-          m_State.time     += DVD_TIME_TO_MSEC(offset);
+          m_State.time     += offset;
           m_State.timestamp =  CDVDClock::GetAbsoluteClock();
         }
 
@@ -2443,7 +2453,8 @@ void CDVDPlayer::HandleMessages()
         // do a seek after rewind, clock is not in sync with current pts
         if (m_playSpeed < 0 && speed >= 0)
         {
-          m_messenger.Put(new CDVDMsgPlayerSeek(GetTime(), true, true, true));
+          int64_t iTime = (int64_t)DVD_TIME_TO_MSEC(m_clock.GetClock() + m_State.time_offset);
+          m_messenger.Put(new CDVDMsgPlayerSeek(iTime, true, true, false, false, true));
         }
 
         // if playspeed is different then DVD_PLAYSPEED_NORMAL or DVD_PLAYSPEED_PAUSE
@@ -3414,7 +3425,7 @@ void CDVDPlayer::UpdateClockMaster()
   }
 }
 
-void CDVDPlayer::FlushBuffers(bool queued, double pts, bool accurate)
+void CDVDPlayer::FlushBuffers(bool queued, double pts, bool accurate, bool sync)
 {
   double startpts;
   if(accurate && !m_omxplayer_mode)
@@ -3426,19 +3437,23 @@ void CDVDPlayer::FlushBuffers(bool queued, double pts, bool accurate)
   if(startpts != DVD_NOPTS_VALUE)
     startpts -= m_offset_pts;
 
-  m_CurrentAudio.inited      = false;
+  if (sync)
+  {
+    m_CurrentAudio.inited      = false;
+    m_CurrentVideo.inited      = false;
+    m_CurrentSubtitle.inited   = false;
+    m_CurrentTeletext.inited   = false;
+  }
+
   m_CurrentAudio.dts         = DVD_NOPTS_VALUE;
   m_CurrentAudio.startpts    = startpts;
 
-  m_CurrentVideo.inited      = false;
   m_CurrentVideo.dts         = DVD_NOPTS_VALUE;
   m_CurrentVideo.startpts    = startpts;
 
-  m_CurrentSubtitle.inited   = false;
   m_CurrentSubtitle.dts      = DVD_NOPTS_VALUE;
   m_CurrentSubtitle.startpts = startpts;
 
-  m_CurrentTeletext.inited   = false;
   m_CurrentTeletext.dts      = DVD_NOPTS_VALUE;
   m_CurrentTeletext.startpts = startpts;
 
@@ -3482,7 +3497,7 @@ void CDVDPlayer::FlushBuffers(bool queued, double pts, bool accurate)
       m_CurrentTeletext.started = false;
     }
 
-    if(pts != DVD_NOPTS_VALUE)
+    if(pts != DVD_NOPTS_VALUE && sync)
       m_clock.Discontinuity(pts);
     UpdatePlayState(0);
 
diff --git a/xbmc/cores/dvdplayer/DVDPlayer.h b/xbmc/cores/dvdplayer/DVDPlayer.h
index dac00e9..dbce0a0 100644
--- a/xbmc/cores/dvdplayer/DVDPlayer.h
+++ b/xbmc/cores/dvdplayer/DVDPlayer.h
@@ -339,7 +339,7 @@ class CDVDPlayer : public IPlayer, public CThread, public IDVDPlayer
   bool GetCachingTimes(double& play_left, double& cache_left, double& file_offset);
 
 
-  void FlushBuffers(bool queued, double pts = DVD_NOPTS_VALUE, bool accurate = true);
+  void FlushBuffers(bool queued, double pts = DVD_NOPTS_VALUE, bool accurate = true, bool sync = true);
 
   void HandleMessages();
   void HandlePlaySpeed();
@@ -393,8 +393,10 @@ class CDVDPlayer : public IPlayer, public CThread, public IDVDPlayer
   int m_playSpeed;
   struct SSpeedState
   {
-    double lastpts;  // holds last display pts during ff/rw operations
-    double lasttime;
+    double  lastpts;  // holds last display pts during ff/rw operations
+    int64_t lasttime;
+    int lastseekpts;
+    double  lastabstime;
   } m_SpeedState;
 
   int m_errorCount;
diff --git a/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp b/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
index 4c0551d..0a4de2c 100644
--- a/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
+++ b/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
@@ -1160,6 +1160,20 @@ int CDVDPlayerVideo::OutputPicture(const DVDVideoPicture* src, double pts)
     pts += m_iVideoDelay - DVD_SEC_TO_TIME(g_renderManager.GetDisplayLatency());
   }
 
+  if (m_speed < 0)
+  {
+    double inputPts = m_droppingStats.m_lastPts;
+    double renderPts = m_droppingStats.m_lastRenderPts;
+    if (pts > renderPts)
+    {
+      if (inputPts >= renderPts)
+      {
+        Sleep(50);
+      }
+      return result | EOS_DROPPED;
+    }
+  }
+
   // calculate the time we need to delay this picture before displaying
   double iSleepTime, iClockSleep, iFrameSleep, iPlayingClock, iCurrentClock;
 
@@ -1466,7 +1480,7 @@ double CDVDPlayerVideo::GetCurrentPts()
 
   if( m_stalled )
     iRenderPts = DVD_NOPTS_VALUE;
-  else
+  else if ( m_speed == DVD_PLAYSPEED_NORMAL)
     iRenderPts = iRenderPts - max(0.0, iSleepTime);
 
   return iRenderPts;
@@ -1567,6 +1581,8 @@ int CDVDPlayerVideo::CalcDropRequirement(double pts)
   int    iDroppedPics = -1;
   int    iBufferLevel;
 
+  m_droppingStats.m_lastPts = pts;
+
   // get decoder stats
   if (!m_pVideoCodec->GetCodecStats(iDecoderPts, iDroppedPics))
     iDecoderPts = pts;
diff --git a/xbmc/cores/dvdplayer/DVDPlayerVideo.h b/xbmc/cores/dvdplayer/DVDPlayerVideo.h
index a38a9c3..4e1b3d6 100644
--- a/xbmc/cores/dvdplayer/DVDPlayerVideo.h
+++ b/xbmc/cores/dvdplayer/DVDPlayerVideo.h
@@ -51,6 +51,7 @@ class CDroppingStats
   double m_totalGain;
   double m_lastDecoderPts;
   double m_lastRenderPts;
+  double m_lastPts;
   unsigned int m_lateFrames;
   unsigned int m_dropRequests;
 };

From 48438ffa62caf266c82ef33dcd10d58d914de8ae Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Thu, 28 Mar 2013 20:50:59 +0100
Subject: [PATCH 09/24] fix incorrect display of fps when dr kicks in

---
 xbmc/Application.cpp | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/xbmc/Application.cpp b/xbmc/Application.cpp
index ee59549..338039e 100644
--- a/xbmc/Application.cpp
+++ b/xbmc/Application.cpp
@@ -2326,10 +2326,11 @@ void CApplication::Render()
     if (frameTime < singleFrameTime)
       Sleep(singleFrameTime - frameTime);
   }
-  m_lastFrameTime = XbmcThreads::SystemClockMillis();
 
   if (flip)
     g_graphicsContext.Flip(dirtyRegions);
+
+  m_lastFrameTime = XbmcThreads::SystemClockMillis();
   CTimeUtils::UpdateFrameTime(flip);
 
   g_renderManager.UpdateResolution();

From 47eea9d903f1bc98d4fb81365f40dcce508a3ae5 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Thu, 25 Jul 2013 17:18:13 +0200
Subject: [PATCH 10/24] ActiveAE: slightly reduce buffer size

---
 xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp
index 0e4d8da..99538dc 100644
--- a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp
+++ b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp
@@ -33,8 +33,8 @@ using namespace ActiveAE;
 
 #include "utils/TimeUtils.h"
 
-#define MAX_CACHE_LEVEL 0.5   // total cache time of stream in seconds
-#define MAX_WATER_LEVEL 0.25  // buffered time after stream stages in seconds
+#define MAX_CACHE_LEVEL 0.4   // total cache time of stream in seconds
+#define MAX_WATER_LEVEL 0.2   // buffered time after stream stages in seconds
 #define MAX_BUFFER_TIME 0.1   // max time of a buffer in seconds
 
 void CEngineStats::Reset(unsigned int sampleRate)

From 55ccc433a49843001e8c2120aca2bc5ae245f521 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Sun, 4 Aug 2013 10:11:16 +0200
Subject: [PATCH 11/24] Revert "vdpau: comment some features that will be added
 later"

This reverts commit e00b4f65864d623ab4d2e9e5c06db138e661f1cf.
---
 xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp | 12 ++++--------
 1 file changed, 4 insertions(+), 8 deletions(-)

diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
index 8c353af..33ec1f4 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
@@ -1085,8 +1085,7 @@ int CDecoder::Decode(AVCodecContext *avctx, AVFrame *pFrame)
     m_bufferStats.IncDecoded();
     m_vdpauOutput.m_dataPort.SendOutMessage(COutputDataProtocol::NEWFRAME, &pic, sizeof(pic));
 
-    //TODO
-    // m_codecControl = pic.DVDPic.iFlags & (DVP_FLAG_DRAIN | DVP_FLAG_NO_POSTPROC);
+    m_codecControl = pic.DVDPic.iFlags & (DVP_FLAG_DRAIN | DVP_FLAG_NO_POSTPROC);
   }
 
   int retval = 0;
@@ -2282,8 +2281,7 @@ void CMixer::InitCycle()
   int flags;
   uint64_t latency;
   m_config.stats->GetParams(latency, flags);
-  // TODO
-  if (0) //flags & DVP_FLAG_NO_POSTPROC)
+  if (flags & DVP_FLAG_NO_POSTPROC)
     SetPostProcFeatures(false);
   else
     SetPostProcFeatures(true);
@@ -2295,8 +2293,7 @@ void CMixer::InitCycle()
   bool interlaced = m_mixerInput[1].DVDPic.iFlags & DVP_FLAG_INTERLACED;
   m_SeenInterlaceFlag |= interlaced;
 
-  // TODO
-  if (//!(flags & DVP_FLAG_NO_POSTPROC) &&
+  if (!(flags & DVP_FLAG_NO_POSTPROC) &&
       (mode == VS_DEINTERLACEMODE_FORCE ||
       (mode == VS_DEINTERLACEMODE_AUTO && interlaced)))
   {
@@ -2318,8 +2315,7 @@ void CMixer::InitCycle()
         m_config.stats->SetCanSkipDeint(true);
       }
 
-      // TODO
-      if (0) //m_mixerInput[1].DVDPic.iFlags & DVP_FLAG_DROPDEINT)
+      if (m_mixerInput[1].DVDPic.iFlags & DVP_FLAG_DROPDEINT)
       {
         m_mixersteps = 1;
       }

From e41a871e824620d5b2d7f59cec4bcabba66d75ec Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Tue, 28 Jan 2014 10:05:26 +0100
Subject: [PATCH 12/24] xbmc pr 3080

---
 xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp | 8 ++++++++
 1 file changed, 8 insertions(+)

diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp
index 84b1eff..67f0e80 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp
@@ -475,6 +475,14 @@ int CDVDVideoCodecFFmpeg::Decode(uint8_t* pData, int iSize, double dts, double p
   av_init_packet(&avpkt);
   avpkt.data = pData;
   avpkt.size = iSize;
+#define SET_PKT_TS(ts) \
+  if(ts != DVD_NOPTS_VALUE)\
+    avpkt.ts = (ts / DVD_TIME_BASE) * AV_TIME_BASE;\
+  else\
+    avpkt.ts = AV_NOPTS_VALUE
+  SET_PKT_TS(pts);
+  SET_PKT_TS(dts);
+#undef SET_PKT_TS
   /* We lie, but this flag is only used by pngdec.c.
    * Setting it correctly would allow CorePNG decoding. */
   avpkt.flags = AV_PKT_FLAG_KEY;

From 2c55fb28f8287d6fdc6dbca4b2f9dd2aea9fabe2 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Tue, 11 Feb 2014 18:15:06 +0100
Subject: [PATCH 13/24] ActiveAE: add some debug logging

---
 xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEStream.cpp | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEStream.cpp b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEStream.cpp
index 96bce12..7bd9c9b 100644
--- a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEStream.cpp
+++ b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEStream.cpp
@@ -265,7 +265,13 @@ unsigned int CActiveAEStream::AddData(uint8_t* const *data, unsigned int offset,
       }
     }
     if (!m_inMsgEvent.WaitMSec(200))
+    {
+      double cachetime = GetCacheTime();
+      CSingleLock lock(m_streamLock);
+      CLog::Log(LOGWARNING, "CActiveAEStream::AddData - timeout waiting for buffer, paused: %d, cache time: %f, free buffers: %d",
+                             m_paused, cachetime, m_streamFreeBuffers);
       break;
+    }
   }
   return copied;
 }

From 6c08bfc1b52f13e5a28aab3cf59bc780470c9fb8 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Sat, 23 Aug 2014 11:42:31 +0200
Subject: [PATCH 14/24] dvdplayer: rename codec ctrl flags

---
 xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
index 33ec1f4..300b901 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
@@ -1085,7 +1085,7 @@ int CDecoder::Decode(AVCodecContext *avctx, AVFrame *pFrame)
     m_bufferStats.IncDecoded();
     m_vdpauOutput.m_dataPort.SendOutMessage(COutputDataProtocol::NEWFRAME, &pic, sizeof(pic));
 
-    m_codecControl = pic.DVDPic.iFlags & (DVP_FLAG_DRAIN | DVP_FLAG_NO_POSTPROC);
+    m_codecControl = pic.DVDPic.iFlags & (DVD_CODEC_CTRL_DRAIN | DVD_CODEC_CTRL_NO_POSTPROC);
   }
 
   int retval = 0;
@@ -2281,7 +2281,7 @@ void CMixer::InitCycle()
   int flags;
   uint64_t latency;
   m_config.stats->GetParams(latency, flags);
-  if (flags & DVP_FLAG_NO_POSTPROC)
+  if (flags & DVD_CODEC_CTRL_NO_POSTPROC)
     SetPostProcFeatures(false);
   else
     SetPostProcFeatures(true);
@@ -2293,7 +2293,7 @@ void CMixer::InitCycle()
   bool interlaced = m_mixerInput[1].DVDPic.iFlags & DVP_FLAG_INTERLACED;
   m_SeenInterlaceFlag |= interlaced;
 
-  if (!(flags & DVP_FLAG_NO_POSTPROC) &&
+  if (!(flags & DVD_CODEC_CTRL_NO_POSTPROC) &&
       (mode == VS_DEINTERLACEMODE_FORCE ||
       (mode == VS_DEINTERLACEMODE_AUTO && interlaced)))
   {
@@ -2315,7 +2315,7 @@ void CMixer::InitCycle()
         m_config.stats->SetCanSkipDeint(true);
       }
 
-      if (m_mixerInput[1].DVDPic.iFlags & DVP_FLAG_DROPDEINT)
+      if (m_mixerInput[1].DVDPic.iFlags & DVD_CODEC_CTRL_SKIPDEINT)
       {
         m_mixersteps = 1;
       }

From dcf0b4a0d5a8786f31eac6ee0693ab83d9f27cbc Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Fri, 13 Jun 2014 14:37:16 +0200
Subject: [PATCH 15/24] VAAPI: implement codec control flags

---
 .../DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp         | 21 ++++++++++++++++++---
 xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.cpp      | 17 ++++++++++++++---
 2 files changed, 32 insertions(+), 6 deletions(-)

diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp
index 67f0e80..2984847 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp
@@ -628,6 +628,7 @@ bool CDVDVideoCodecFFmpeg::GetPictureCommon(DVDVideoPicture* pDvdVideoPicture)
   pDvdVideoPicture->chroma_position = m_pCodecContext->chroma_sample_location;
   pDvdVideoPicture->color_primaries = m_pCodecContext->color_primaries;
   pDvdVideoPicture->color_transfer = m_pCodecContext->color_trc;
+  pDvdVideoPicture->color_matrix = m_pCodecContext->colorspace;
   if(m_pCodecContext->color_range == AVCOL_RANGE_JPEG
   || m_pCodecContext->pix_fmt     == PIX_FMT_YUVJ420P)
     pDvdVideoPicture->color_range = 1;
@@ -651,10 +652,24 @@ bool CDVDVideoCodecFFmpeg::GetPictureCommon(DVDVideoPicture* pDvdVideoPicture)
     pDvdVideoPicture->qscale_type = DVP_QSCALE_UNKNOWN;
   }
 
-  pDvdVideoPicture->dts = m_dts;
+  if (pDvdVideoPicture->iRepeatPicture)
+    pDvdVideoPicture->dts = DVD_NOPTS_VALUE;
+  else
+    pDvdVideoPicture->dts = m_dts;
+
   m_dts = DVD_NOPTS_VALUE;
-  if (m_pFrame->reordered_opaque)
-    pDvdVideoPicture->pts = pts_itod(m_pFrame->reordered_opaque);
+
+  int64_t bpts = av_frame_get_best_effort_timestamp(m_pFrame);
+  if(bpts != AV_NOPTS_VALUE)
+  {
+    pDvdVideoPicture->pts = (double)bpts * DVD_TIME_BASE / AV_TIME_BASE;
+    if (pDvdVideoPicture->pts == m_decoderPts)
+    {
+      pDvdVideoPicture->iRepeatPicture = -0.5;
+      pDvdVideoPicture->pts = DVD_NOPTS_VALUE;
+      pDvdVideoPicture->dts = DVD_NOPTS_VALUE;
+    }
+  }
   else
     pDvdVideoPicture->pts = DVD_NOPTS_VALUE;
 
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.cpp
index 707d609..e0709226 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.cpp
@@ -739,6 +739,8 @@ int CDecoder::Decode(AVCodecContext* avctx, AVFrame* pFrame)
     pic.DVDPic.color_matrix = avctx->colorspace;
     m_bufferStats.IncDecoded();
     m_vaapiOutput.m_dataPort.SendOutMessage(COutputDataProtocol::NEWFRAME, &pic, sizeof(pic));
+
+    m_codecControl = pic.DVDPic.iFlags & (DVD_CODEC_CTRL_DRAIN | DVD_CODEC_CTRL_NO_POSTPROC);
   }
 
   int retval = 0;
@@ -1799,8 +1801,8 @@ bool COutput::PreferPP()
 void COutput::InitCycle()
 {
   uint64_t latency;
-  int speed;
-  m_config.stats->GetParams(latency, speed);
+  int flags;
+  m_config.stats->GetParams(latency, flags);
 
   m_config.stats->SetCanSkipDeint(false);
 
@@ -1808,7 +1810,8 @@ void COutput::InitCycle()
   EINTERLACEMETHOD method = CMediaSettings::Get().GetCurrentVideoSettings().m_InterlaceMethod;
   bool interlaced = m_currentPicture.DVDPic.iFlags & DVP_FLAG_INTERLACED;
 
-  if ((mode == VS_DEINTERLACEMODE_FORCE ||
+  if (!(flags & DVD_CODEC_CTRL_NO_POSTPROC) &&
+      (mode == VS_DEINTERLACEMODE_FORCE ||
       (mode == VS_DEINTERLACEMODE_AUTO && interlaced)))
   {
     if((method == VS_INTERLACEMETHOD_AUTO && interlaced)
@@ -2626,6 +2629,7 @@ bool CVppPostproc::AddPicture(CVaapiDecodedPicture &pic)
   m_decodedPics.push_front(pic);
   m_frameCount++;
   m_step = 0;
+  m_config.stats->SetCanSkipDeint(true);
   return true;
 }
 
@@ -2670,6 +2674,13 @@ bool CVppPostproc::Filter(CVaapiProcessedPicture &outPic)
   }
   outPic.DVDPic = it->DVDPic;
 
+  // skip deinterlacing cycle if requested
+  if (m_step == 1 && (outPic.DVDPic.iFlags & DVD_CODEC_CTRL_SKIPDEINT))
+  {
+    Advance();
+    return false;
+  }
+
   // vpp deinterlacing
   VAProcFilterParameterBufferDeinterlacing *filterParams;
   VABufferID pipelineBuf;


From 0d3311557fe32505770ed28bcb8fbcde7c751399 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Sat, 4 Oct 2014 21:25:31 +0200
Subject: [PATCH 17/24] vaapi: lock gfx context on pre-cleanup

---
 xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.cpp | 1 +
 1 file changed, 1 insertion(+)

diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.cpp
index e0709226..a086d13 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.cpp
@@ -618,6 +618,7 @@ long CDecoder::Release()
     CSingleLock lock(m_DecoderSection);
     CLog::Log(LOGDEBUG,"VAAPI::Release pre-cleanup");
 
+    CSingleLock lock1(g_graphicsContext);
     Message *reply;
     if (m_vaapiOutput.m_controlPort.SendOutMessageSync(COutputControlProtocol::PRECLEANUP,
                                                    &reply,

From 42bff6329800ba57459d135f54d0ca7d8eef1b79 Mon Sep 17 00:00:00 2001
From: Anssi Hannula <anssi@xbmc.org>
Date: Sun, 19 Oct 2014 21:34:47 +0300
Subject: [PATCH 18/24] [linux] Add FDEventMonitor for monitoring file
 descriptors

Add FDEventMonitor helper thread for monitoring file descriptors for
events (ready for read, ready for write) without the need for spawning
a separate thread with a tight loop around poll()/select().

FDEventMonitor uses an eventfd for signaling poll() instead of a
timeout, therefore it can sleep for long times in case of no events but
still immediately respond to e.g. shutdown.
---
 xbmc/linux/FDEventMonitor.cpp | 248 ++++++++++++++++++++++++++++++++++++++++++
 xbmc/linux/FDEventMonitor.h   |  89 +++++++++++++++
 xbmc/linux/Makefile.in        |   1 +
 3 files changed, 338 insertions(+)
 create mode 100644 xbmc/linux/FDEventMonitor.cpp
 create mode 100644 xbmc/linux/FDEventMonitor.h

diff --git a/xbmc/linux/FDEventMonitor.cpp b/xbmc/linux/FDEventMonitor.cpp
new file mode 100644
index 0000000..4a41477
--- /dev/null
+++ b/xbmc/linux/FDEventMonitor.cpp
@@ -0,0 +1,248 @@
+/*
+ *      Copyright (C) 2014 Team Kodi
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with Kodi; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+#include "system.h"
+#ifdef HAS_ALSA
+
+#include <poll.h>
+#include <sys/eventfd.h>
+#include <errno.h>
+
+#include "utils/log.h"
+
+#include "FDEventMonitor.h"
+
+CFDEventMonitor::CFDEventMonitor() :
+  CThread("FDEventMonitor"),
+  m_nextID(0),
+  m_wakeupfd(-1)
+{
+}
+
+CFDEventMonitor::~CFDEventMonitor()
+{
+  CSingleLock lock(m_mutex);
+  InterruptPoll();
+
+  if (m_wakeupfd >= 0)
+  {
+    /* sets m_bStop */
+    StopThread(false);
+
+    /* wake up the poll() call */
+    eventfd_write(m_wakeupfd, 1);
+
+    /* Wait for the thread to stop */
+    {
+      CSingleExit exit(m_mutex);
+      StopThread(true);
+    }
+
+    close(m_wakeupfd);
+  }
+}
+
+void CFDEventMonitor::AddFD(const MonitoredFD& monitoredFD, int& id)
+{
+  CSingleLock lock(m_mutex);
+  InterruptPoll();
+
+  AddFDLocked(monitoredFD, id);
+
+  StartMonitoring();
+}
+
+void CFDEventMonitor::AddFDs(const std::vector<MonitoredFD>& monitoredFDs,
+                             std::vector<int>& ids)
+{
+  CSingleLock lock(m_mutex);
+  InterruptPoll();
+
+  for (unsigned int i = 0; i < monitoredFDs.size(); ++i)
+  {
+    int id;
+    AddFDLocked(monitoredFDs[i], id);
+    ids.push_back(id);
+  }
+
+  StartMonitoring();
+}
+
+void CFDEventMonitor::RemoveFD(int id)
+{
+  CSingleLock lock(m_mutex);
+  InterruptPoll();
+
+  if (m_monitoredFDs.erase(id) != 1)
+  {
+    CLog::Log(LOGERROR, "CFDEventMonitor::RemoveFD - Tried to remove non-existing monitoredFD %d", id);
+  }
+
+  UpdatePollDescs();
+}
+
+void CFDEventMonitor::RemoveFDs(const std::vector<int>& ids)
+{
+  CSingleLock lock(m_mutex);
+  InterruptPoll();
+
+  for (unsigned int i = 0; i < ids.size(); ++i)
+  {
+    if (m_monitoredFDs.erase(ids[i]) != 1)
+    {
+      CLog::Log(LOGERROR, "CFDEventMonitor::RemoveFDs - Tried to remove non-existing monitoredFD %d while removing %u FDs", ids[i], (unsigned)ids.size());
+    }
+  }
+
+  UpdatePollDescs();
+}
+
+void CFDEventMonitor::Process()
+{
+  eventfd_t dummy;
+
+  while (!m_bStop)
+  {
+    CSingleLock lock(m_mutex);
+    CSingleLock pollLock(m_pollMutex);
+
+    /*
+     * Leave the main mutex here to allow another thread to
+     * lock it while we are in poll().
+     * By then calling InterruptPoll() the other thread can
+     * wake up poll and wait for the processing to pause at
+     * the above lock(m_mutex).
+     */
+    lock.Leave();
+
+    int err = poll(&m_pollDescs[0], m_pollDescs.size(), -1);
+
+    if (err < 0 && errno != EINTR)
+    {
+      CLog::Log(LOGERROR, "CFDEventMonitor::Process - poll() failed, error %d, stopping monitoring", errno);
+      StopThread(false);
+    }
+
+    // Something woke us up - either there is data available or we are being
+    // paused/stopped via m_wakeupfd.
+
+    for (unsigned int i = 0; i < m_pollDescs.size(); ++i)
+    {
+      struct pollfd& pollDesc = m_pollDescs[i];
+      int id = m_monitoredFDbyPollDescs[i];
+      const MonitoredFD& monitoredFD = m_monitoredFDs[id];
+
+      if (pollDesc.revents)
+      {
+        if (monitoredFD.callback)
+        {
+          monitoredFD.callback(id, pollDesc.fd, pollDesc.revents,
+                               monitoredFD.callbackData);
+        }
+
+        if (pollDesc.revents & (POLLERR | POLLHUP | POLLNVAL))
+        {
+          CLog::Log(LOGERROR, "CFDEventMonitor::Process - polled fd %d got revents 0x%x, removing it", pollDesc.fd, pollDesc.revents);
+
+          /* Probably would be nice to inform our caller that their FD was
+           * dropped, but oh well... */
+          m_monitoredFDs.erase(id);
+          UpdatePollDescs();
+        }
+
+        pollDesc.revents = 0;
+      }
+    }
+
+    /* flush wakeup fd */
+    eventfd_read(m_wakeupfd, &dummy);
+
+  }
+}
+
+void CFDEventMonitor::AddFDLocked(const MonitoredFD& monitoredFD, int& id)
+{
+  id = m_nextID;
+
+  while (m_monitoredFDs.count(id))
+  {
+    ++id;
+  }
+  m_nextID = id + 1;
+
+  m_monitoredFDs[id] = monitoredFD;
+
+  AddPollDesc(id, monitoredFD.fd, monitoredFD.events);
+}
+
+void CFDEventMonitor::AddPollDesc(int id, int fd, short events)
+{
+  struct pollfd newPollFD;
+  newPollFD.fd = fd;
+  newPollFD.events = events;
+  newPollFD.revents = 0;
+
+  m_pollDescs.push_back(newPollFD);
+  m_monitoredFDbyPollDescs.push_back(id);
+}
+
+void CFDEventMonitor::UpdatePollDescs()
+{
+  m_monitoredFDbyPollDescs.clear();
+  m_pollDescs.clear();
+
+  for (std::map<int, MonitoredFD>::iterator it = m_monitoredFDs.begin();
+       it != m_monitoredFDs.end(); ++it)
+  {
+    AddPollDesc(it->first, it->second.fd, it->second.events);
+  }
+}
+
+void CFDEventMonitor::StartMonitoring()
+{
+  if (!IsRunning())
+  {
+    /* Start the monitoring thread */
+
+    m_wakeupfd = eventfd(0, EFD_CLOEXEC | EFD_NONBLOCK);
+    if (m_wakeupfd < 0)
+    {
+      CLog::Log(LOGERROR, "CFDEventMonitor::StartMonitoring - Failed to create eventfd, error %d", errno);
+      return;
+    }
+
+    /* Add wakeup fd to the fd list */
+    int id;
+    AddFDLocked(MonitoredFD(m_wakeupfd, POLLIN, NULL, NULL), id);
+
+    Create(false);
+  }
+}
+
+void CFDEventMonitor::InterruptPoll()
+{
+  if (m_wakeupfd >= 0)
+  {
+    eventfd_write(m_wakeupfd, 1);
+    /* wait for the poll() result handling (if any) to end */
+    CSingleLock pollLock(m_pollMutex);
+  }
+}
+
+#endif
diff --git a/xbmc/linux/FDEventMonitor.h b/xbmc/linux/FDEventMonitor.h
new file mode 100644
index 0000000..4602d12
--- /dev/null
+++ b/xbmc/linux/FDEventMonitor.h
@@ -0,0 +1,89 @@
+#pragma once
+/*
+ *      Copyright (C) 2014 Team Kodi
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with Kodi; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "system.h"
+
+#include <vector>
+#include <map>
+
+#include "threads/CriticalSection.h"
+#include "threads/Thread.h"
+
+#include "utils/GlobalsHandling.h"
+
+/**
+ * Monitor a file descriptor with callback on poll() events.
+ */
+class CFDEventMonitor : private CThread
+{
+public:
+
+  typedef void (*EventCallback)(int id, int fd, short revents, void *data);
+
+  struct MonitoredFD
+  {
+    int fd; /**< File descriptor to be monitored */
+    short events; /**< Events to be monitored (see poll(2)) */
+
+    EventCallback callback; /** Callback to be called on events */
+    void *callbackData; /** data parameter for EventCallback */
+
+    MonitoredFD(int fd_, short events_, EventCallback callback_, void *callbackData_) :
+      fd(fd_), events(events_), callback(callback_), callbackData(callbackData_) {}
+    MonitoredFD() : fd(-1), events(0), callback(NULL), callbackData(NULL) {}
+  };
+
+  CFDEventMonitor();
+  ~CFDEventMonitor();
+
+  void AddFD(const MonitoredFD& monitoredFD, int& id);
+  void AddFDs(const std::vector<MonitoredFD>& monitoredFDs, std::vector<int>& ids);
+
+  void RemoveFD(int id);
+  void RemoveFDs(const std::vector<int>& ids);
+
+protected:
+  virtual void Process();
+
+private:
+  void AddFDLocked(const MonitoredFD& monitoredFD, int& id);
+
+  void AddPollDesc(int id, int fd, short events);
+  void UpdatePollDescs();
+
+  void StartMonitoring();
+  void InterruptPoll();
+
+  std::map<int, MonitoredFD> m_monitoredFDs;
+
+  /* these are kept synchronized */
+  std::vector<int> m_monitoredFDbyPollDescs;
+  std::vector<struct pollfd> m_pollDescs;
+
+  int m_nextID;
+  int m_wakeupfd;
+
+  CCriticalSection m_mutex;
+  CCriticalSection m_pollMutex;
+};
+
+XBMC_GLOBAL_REF(CFDEventMonitor, g_fdEventMonitor);
+#define g_fdEventMonitor XBMC_GLOBAL_USE(CFDEventMonitor)
diff --git a/xbmc/linux/Makefile.in b/xbmc/linux/Makefile.in
index c147d8f..744fd06 100644
--- a/xbmc/linux/Makefile.in
+++ b/xbmc/linux/Makefile.in
@@ -4,6 +4,7 @@ SRCS  = ConvUtils.cpp
 SRCS += DBusUtil.cpp
 SRCS += DBusMessage.cpp
 SRCS += DBusReserve.cpp
+SRCS += FDEventMonitor.cpp
 SRCS += LinuxResourceCounter.cpp
 SRCS += LinuxTimezone.cpp
 SRCS += PosixMountProvider.cpp

From a7369e2f95722730f22ebd72e1d22bbf3d0fabe5 Mon Sep 17 00:00:00 2001
From: Anssi Hannula <anssi@xbmc.org>
Date: Sun, 19 Oct 2014 21:36:44 +0300
Subject: [PATCH 19/24] [AE] ALSA: Add ALSADeviceMonitor for monitoring card
 removals/additions

---
 xbmc/cores/AudioEngine/Makefile.in                 |   1 +
 xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp        |   8 ++
 xbmc/cores/AudioEngine/Sinks/AESinkALSA.h          |   9 ++
 .../AudioEngine/Sinks/alsa/ALSADeviceMonitor.cpp   | 131 +++++++++++++++++++++
 .../AudioEngine/Sinks/alsa/ALSADeviceMonitor.h     |  49 ++++++++
 5 files changed, 198 insertions(+)
 create mode 100644 xbmc/cores/AudioEngine/Sinks/alsa/ALSADeviceMonitor.cpp
 create mode 100644 xbmc/cores/AudioEngine/Sinks/alsa/ALSADeviceMonitor.h

diff --git a/xbmc/cores/AudioEngine/Makefile.in b/xbmc/cores/AudioEngine/Makefile.in
index efb44cc..614ede2 100644
--- a/xbmc/cores/AudioEngine/Makefile.in
+++ b/xbmc/cores/AudioEngine/Makefile.in
@@ -50,6 +50,7 @@ SRCS += Sinks/osx/CoreAudioHelpers.cpp
 SRCS += Sinks/osx/CoreAudioStream.cpp
 else
 SRCS += Sinks/AESinkALSA.cpp
+SRCS += Sinks/alsa/ALSADeviceMonitor.cpp
 SRCS += Sinks/AESinkOSS.cpp
 ifeq (@USE_PULSE@,1)
 SRCS += Sinks/AESinkPULSE.cpp
diff --git a/xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp b/xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp
index a464b4b..c2d5758 100644
--- a/xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp
+++ b/xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp
@@ -1066,6 +1066,10 @@ bool CAESinkALSA::OpenPCMDevice(const std::string &name, const std::string &para
 
 void CAESinkALSA::EnumerateDevicesEx(AEDeviceInfoList &list, bool force)
 {
+#if HAVE_LIBUDEV
+  m_deviceMonitor.Start();
+#endif
+
   /* ensure that ALSA has been initialized */
   snd_lib_error_set_handler(sndLibErrorHandler);
   if(!snd_config || force)
@@ -1577,4 +1581,8 @@ void CAESinkALSA::sndLibErrorHandler(const char *file, int line, const char *fun
   va_end(arg);
 }
 
+#if HAVE_LIBUDEV
+CALSADeviceMonitor CAESinkALSA::m_deviceMonitor; // ARGH
+#endif
+
 #endif
diff --git a/xbmc/cores/AudioEngine/Sinks/AESinkALSA.h b/xbmc/cores/AudioEngine/Sinks/AESinkALSA.h
index 7e05ce6..1177f41 100644
--- a/xbmc/cores/AudioEngine/Sinks/AESinkALSA.h
+++ b/xbmc/cores/AudioEngine/Sinks/AESinkALSA.h
@@ -24,6 +24,7 @@
 
 #include "cores/AudioEngine/Interfaces/AESink.h"
 #include "cores/AudioEngine/Utils/AEDeviceInfo.h"
+#include "cores/AudioEngine/Sinks/alsa/ALSADeviceMonitor.h"
 #include <stdint.h>
 
 #define ALSA_PCM_NEW_HW_PARAMS_API
@@ -31,6 +32,10 @@
 
 #include "threads/CriticalSection.h"
 
+// ARGH... this is apparently needed to avoid FDEventMonitor
+// being destructed before CALSA*Monitor below.
+#include "linux/FDEventMonitor.h"
+
 class CAESinkALSA : public IAESink
 {
 public:
@@ -82,6 +87,9 @@ class CAESinkALSA : public IAESink
   // support fragmentation, e.g. looping in the sink to get a certain amount of data onto the device
   bool              m_fragmented;
   unsigned int      m_originalPeriodSize;
+#if HAVE_LIBUDEV
+  static CALSADeviceMonitor m_deviceMonitor;
+#endif
   struct ALSAConfig
   {
     unsigned int sampleRate;
diff --git a/xbmc/cores/AudioEngine/Sinks/alsa/ALSADeviceMonitor.cpp b/xbmc/cores/AudioEngine/Sinks/alsa/ALSADeviceMonitor.cpp
new file mode 100644
index 0000000..e3269ad
--- /dev/null
+++ b/xbmc/cores/AudioEngine/Sinks/alsa/ALSADeviceMonitor.cpp
@@ -0,0 +1,131 @@
+/*
+ *      Copyright (C) 2014 Team Kodi
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with Kodi; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+#include "system.h"
+#if defined(HAS_ALSA) && defined(HAVE_LIBUDEV)
+
+#include <libudev.h>
+
+#include "ALSADeviceMonitor.h"
+#include "AEFactory.h"
+#include "linux/FDEventMonitor.h"
+#include "utils/log.h"
+
+CALSADeviceMonitor::CALSADeviceMonitor() :
+  m_fdMonitorId(0),
+  m_udev(NULL),
+  m_udevMonitor(NULL)
+{
+}
+
+CALSADeviceMonitor::~CALSADeviceMonitor()
+{
+  Stop();
+}
+
+void CALSADeviceMonitor::Start()
+{
+  int err;
+
+  if (!m_udev)
+  {
+    m_udev = udev_new();
+    if (!m_udev)
+    {
+      CLog::Log(LOGWARNING, "CALSADeviceMonitor::Start - Unable to open udev handle");
+      return;
+    }
+
+    m_udevMonitor = udev_monitor_new_from_netlink(m_udev, "udev");
+    if (!m_udevMonitor)
+    {
+      CLog::Log(LOGERROR, "CALSADeviceMonitor::Start - udev_monitor_new_from_netlink() failed");
+      goto err_unref_udev;
+    }
+
+    err = udev_monitor_filter_add_match_subsystem_devtype(m_udevMonitor, "sound", NULL);
+    if (err)
+    {
+      CLog::Log(LOGERROR, "CALSADeviceMonitor::Start - udev_monitor_filter_add_match_subsystem_devtype() failed");
+      goto err_unref_monitor;
+    }
+
+    err = udev_monitor_enable_receiving(m_udevMonitor);
+    if (err)
+    {
+      CLog::Log(LOGERROR, "CALSADeviceMonitor::Start - udev_monitor_enable_receiving() failed");
+      goto err_unref_monitor;
+    }
+
+    g_fdEventMonitor.AddFD(
+        CFDEventMonitor::MonitoredFD(udev_monitor_get_fd(m_udevMonitor),
+                                     POLLIN, FDEventCallback, m_udevMonitor),
+        m_fdMonitorId);
+  }
+
+  return;
+
+err_unref_monitor:
+  udev_monitor_unref(m_udevMonitor);
+  m_udevMonitor = NULL;
+err_unref_udev:
+  udev_unref(m_udev);
+  m_udev = NULL;
+}
+
+void CALSADeviceMonitor::Stop()
+{
+  if (m_udev)
+  {
+    g_fdEventMonitor.RemoveFD(m_fdMonitorId);
+
+    udev_monitor_unref(m_udevMonitor);
+    m_udevMonitor = NULL;
+    udev_unref(m_udev);
+    m_udev = NULL;
+  }
+}
+
+void CALSADeviceMonitor::FDEventCallback(int id, int fd, short revents, void *data)
+{
+  struct udev_monitor *udevMonitor = (struct udev_monitor *)data;
+  bool audioDevicesChanged = false;
+  struct udev_device *device;
+
+  while ((device = udev_monitor_receive_device(udevMonitor)) != NULL)
+  {
+    const char* action = udev_device_get_action(device);
+    const char* soundInitialized = udev_device_get_property_value(device, "SOUND_INITIALIZED");
+
+    /* cardX devices emit a "change" event when ready (i.e. all subdevices added) */
+    if (action && soundInitialized &&
+        (strcmp(action, "change") == 0 || strcmp(action, "remove") == 0))
+    {
+      audioDevicesChanged = true;
+    }
+    udev_device_unref(device);
+  }
+
+  if (audioDevicesChanged)
+  {
+    CAEFactory::DeviceChange();
+  }
+}
+
+#endif
diff --git a/xbmc/cores/AudioEngine/Sinks/alsa/ALSADeviceMonitor.h b/xbmc/cores/AudioEngine/Sinks/alsa/ALSADeviceMonitor.h
new file mode 100644
index 0000000..f9e2f26
--- /dev/null
+++ b/xbmc/cores/AudioEngine/Sinks/alsa/ALSADeviceMonitor.h
@@ -0,0 +1,49 @@
+#pragma once
+/*
+ *      Copyright (C) 2014 Team Kodi
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with Kodi; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "system.h"
+#if defined(HAS_ALSA) && defined(HAVE_LIBUDEV)
+
+#include <string>
+#include <vector>
+
+#include <alsa/asoundlib.h>
+
+class CALSADeviceMonitor
+{
+public:
+  CALSADeviceMonitor();
+  ~CALSADeviceMonitor();
+
+  void Start();
+  void Stop();
+
+private:
+  static void FDEventCallback(int id, int fd, short revents, void *data);
+
+  int m_fdMonitorId;
+
+  struct udev *m_udev;
+  struct udev_monitor* m_udevMonitor;
+};
+
+#endif
+

From 51947c5716e52af108d701b6fb573e8ca145f132 Mon Sep 17 00:00:00 2001
From: Anssi Hannula <anssi@xbmc.org>
Date: Sun, 19 Oct 2014 21:37:49 +0300
Subject: [PATCH 20/24] [AE] ALSA: Add ALSADeviceMonitor for monitoring ELD
 changes

ELD changes can happen e.g. when the connected HDMI sink is changed.
---
 xbmc/cores/AudioEngine/Makefile.in                 |   1 +
 xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp        |   9 ++
 xbmc/cores/AudioEngine/Sinks/AESinkALSA.h          |   2 +
 .../AudioEngine/Sinks/alsa/ALSAHControlMonitor.cpp | 173 +++++++++++++++++++++
 .../AudioEngine/Sinks/alsa/ALSAHControlMonitor.h   |  69 ++++++++
 5 files changed, 254 insertions(+)
 create mode 100644 xbmc/cores/AudioEngine/Sinks/alsa/ALSAHControlMonitor.cpp
 create mode 100644 xbmc/cores/AudioEngine/Sinks/alsa/ALSAHControlMonitor.h

diff --git a/xbmc/cores/AudioEngine/Makefile.in b/xbmc/cores/AudioEngine/Makefile.in
index 614ede2..8f13088 100644
--- a/xbmc/cores/AudioEngine/Makefile.in
+++ b/xbmc/cores/AudioEngine/Makefile.in
@@ -51,6 +51,7 @@ SRCS += Sinks/osx/CoreAudioStream.cpp
 else
 SRCS += Sinks/AESinkALSA.cpp
 SRCS += Sinks/alsa/ALSADeviceMonitor.cpp
+SRCS += Sinks/alsa/ALSAHControlMonitor.cpp
 SRCS += Sinks/AESinkOSS.cpp
 ifeq (@USE_PULSE@,1)
 SRCS += Sinks/AESinkPULSE.cpp
diff --git a/xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp b/xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp
index c2d5758..f92f488 100644
--- a/xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp
+++ b/xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp
@@ -1083,6 +1083,8 @@ void CAESinkALSA::EnumerateDevicesEx(AEDeviceInfoList &list, bool force)
   snd_config_t *config;
   snd_config_copy(&config, snd_config);
 
+  m_controlMonitor.Clear();
+
   /* Always enumerate the default device.
    * Note: If "default" is a stereo device, EnumerateDevice()
    * will automatically add "@" instead to enable surroundXX mangling.
@@ -1160,6 +1162,8 @@ void CAESinkALSA::EnumerateDevicesEx(AEDeviceInfoList &list, bool force)
   }
   snd_device_name_free_hint(hints);
 
+  m_controlMonitor.Start();
+
   /* set the displayname for default device */
   if (!list.empty() && list[0].m_deviceName == "default")
   {
@@ -1340,6 +1344,10 @@ void CAESinkALSA::EnumerateDevice(AEDeviceInfoList &list, const std::string &dev
           {
             snd_hctl_load(hctl);
             bool badHDMI = false;
+
+            /* add ELD to monitoring */
+            m_controlMonitor.Add(strHwName, SND_CTL_ELEM_IFACE_PCM, dev, "ELD");
+
             if (!GetELD(hctl, dev, info, badHDMI))
               CLog::Log(LOGDEBUG, "CAESinkALSA - Unable to obtain ELD information for device \"%s\" (not supported by device, or kernel older than 3.2)",
                         device.c_str());
@@ -1584,5 +1592,6 @@ void CAESinkALSA::sndLibErrorHandler(const char *file, int line, const char *fun
 #if HAVE_LIBUDEV
 CALSADeviceMonitor CAESinkALSA::m_deviceMonitor; // ARGH
 #endif
+CALSAHControlMonitor CAESinkALSA::m_controlMonitor; // ARGH
 
 #endif
diff --git a/xbmc/cores/AudioEngine/Sinks/AESinkALSA.h b/xbmc/cores/AudioEngine/Sinks/AESinkALSA.h
index 1177f41..8be8709 100644
--- a/xbmc/cores/AudioEngine/Sinks/AESinkALSA.h
+++ b/xbmc/cores/AudioEngine/Sinks/AESinkALSA.h
@@ -25,6 +25,7 @@
 #include "cores/AudioEngine/Interfaces/AESink.h"
 #include "cores/AudioEngine/Utils/AEDeviceInfo.h"
 #include "cores/AudioEngine/Sinks/alsa/ALSADeviceMonitor.h"
+#include "cores/AudioEngine/Sinks/alsa/ALSAHControlMonitor.h"
 #include <stdint.h>
 
 #define ALSA_PCM_NEW_HW_PARAMS_API
@@ -87,6 +88,7 @@ class CAESinkALSA : public IAESink
 #if HAVE_LIBUDEV
   static CALSADeviceMonitor m_deviceMonitor;
 #endif
+  static CALSAHControlMonitor m_controlMonitor;
 
   struct ALSAConfig
   {
diff --git a/xbmc/cores/AudioEngine/Sinks/alsa/ALSAHControlMonitor.cpp b/xbmc/cores/AudioEngine/Sinks/alsa/ALSAHControlMonitor.cpp
new file mode 100644
index 0000000..9b595ee
--- /dev/null
+++ b/xbmc/cores/AudioEngine/Sinks/alsa/ALSAHControlMonitor.cpp
@@ -0,0 +1,173 @@
+/*
+ *      Copyright (C) 2014 Team Kodi
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with Kodi; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+#include "system.h"
+#ifdef HAS_ALSA
+
+#include "ALSAHControlMonitor.h"
+
+#include "AEFactory.h"
+#include "linux/FDEventMonitor.h"
+#include "utils/log.h"
+
+CALSAHControlMonitor::CALSAHControlMonitor()
+{
+}
+
+CALSAHControlMonitor::~CALSAHControlMonitor()
+{
+  Clear();
+}
+
+bool CALSAHControlMonitor::Add(const std::string& ctlHandleName,
+                               snd_ctl_elem_iface_t interface,
+                               unsigned int device,
+                               const std::string& name)
+{
+  snd_hctl_t *hctl = GetHandle(ctlHandleName);
+
+  if (!hctl)
+  {
+    return false;
+  }
+
+  snd_ctl_elem_id_t *id;
+
+  snd_ctl_elem_id_alloca(&id);
+
+  snd_ctl_elem_id_set_interface(id, interface);
+  snd_ctl_elem_id_set_name     (id, name.c_str());
+  snd_ctl_elem_id_set_device   (id, device);
+
+  snd_hctl_elem_t *elem = snd_hctl_find_elem(hctl, id);
+
+  if (!elem)
+  {
+    PutHandle(ctlHandleName);
+    return false;
+  }
+
+  snd_hctl_elem_set_callback(elem, HCTLCallback);
+
+  return true;
+}
+
+void CALSAHControlMonitor::Clear()
+{
+  Stop();
+
+  for (std::map<std::string, CTLHandle>::iterator it = m_ctlHandles.begin();
+       it != m_ctlHandles.end(); ++it)
+  {
+    snd_hctl_close(it->second.handle);
+  }
+  m_ctlHandles.clear();
+}
+
+void CALSAHControlMonitor::Start()
+{
+  assert(m_fdMonitorIds.size() == 0);
+
+  std::vector<struct pollfd> pollfds;
+  std::vector<CFDEventMonitor::MonitoredFD> monitoredFDs;
+
+  for (std::map<std::string, CTLHandle>::iterator it = m_ctlHandles.begin();
+       it != m_ctlHandles.end(); ++it)
+  {
+    pollfds.resize(snd_hctl_poll_descriptors_count(it->second.handle));
+    int fdcount = snd_hctl_poll_descriptors(it->second.handle, &pollfds[0], pollfds.size());
+
+    for (int j = 0; j < fdcount; ++j)
+    {
+      monitoredFDs.push_back(CFDEventMonitor::MonitoredFD(pollfds[j].fd,
+                                                          pollfds[j].events,
+                                                          FDEventCallback,
+                                                          it->second.handle));
+    }
+  }
+
+  g_fdEventMonitor.AddFDs(monitoredFDs, m_fdMonitorIds);
+}
+
+
+void CALSAHControlMonitor::Stop()
+{
+  g_fdEventMonitor.RemoveFDs(m_fdMonitorIds);
+  m_fdMonitorIds.clear();
+}
+
+int CALSAHControlMonitor::HCTLCallback(snd_hctl_elem_t *elem, unsigned int mask)
+{
+  /*
+   * Currently we just re-enumerate on any change.
+   * Custom callbacks for handling other control monitoring may be implemented when needed.
+   */
+  if (mask & SND_CTL_EVENT_MASK_VALUE)
+  {
+    CAEFactory::DeviceChange();
+  }
+
+  return 0;
+}
+
+void CALSAHControlMonitor::FDEventCallback(int id, int fd, short revents, void *data)
+{
+  /* Run ALSA event handling when the FD has events */
+  snd_hctl_t *hctl = (snd_hctl_t *)data;
+  snd_hctl_handle_events(hctl);
+}
+
+snd_hctl_t* CALSAHControlMonitor::GetHandle(const std::string& ctlHandleName)
+{
+  if (!m_ctlHandles.count(ctlHandleName))
+  {
+    snd_hctl_t *hctl;
+
+    if (snd_hctl_open(&hctl, ctlHandleName.c_str(), 0) != 0)
+    {
+        CLog::Log(LOGWARNING, "CALSAHControlMonitor::GetHandle - snd_hctl_open() failed for \"%s\"", ctlHandleName.c_str());
+        return NULL;
+    }
+    if (snd_hctl_load(hctl) != 0)
+    {
+      CLog::Log(LOGERROR, "CALSAHControlMonitor::GetHandle - snd_hctl_load() failed for \"%s\"", ctlHandleName.c_str());
+      snd_hctl_close(hctl);
+      return NULL;
+    }
+
+    snd_hctl_nonblock(hctl, 1);
+
+    m_ctlHandles[ctlHandleName] = CTLHandle(hctl);
+  }
+
+  m_ctlHandles[ctlHandleName].useCount++;
+  return m_ctlHandles[ctlHandleName].handle;
+}
+
+void CALSAHControlMonitor::PutHandle(const std::string& ctlHandleName)
+{
+  if (--m_ctlHandles[ctlHandleName].useCount == 0)
+  {
+    snd_hctl_close(m_ctlHandles[ctlHandleName].handle);
+    m_ctlHandles.erase(ctlHandleName);
+  }
+}
+
+
+#endif
diff --git a/xbmc/cores/AudioEngine/Sinks/alsa/ALSAHControlMonitor.h b/xbmc/cores/AudioEngine/Sinks/alsa/ALSAHControlMonitor.h
new file mode 100644
index 0000000..56dfd50
--- /dev/null
+++ b/xbmc/cores/AudioEngine/Sinks/alsa/ALSAHControlMonitor.h
@@ -0,0 +1,69 @@
+#pragma once
+/*
+ *      Copyright (C) 2014 Team Kodi
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with Kodi; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "system.h"
+#ifdef HAS_ALSA
+
+#include <string>
+#include <map>
+#include <vector>
+
+#include <alsa/asoundlib.h>
+
+class CALSAHControlMonitor
+{
+public:
+  CALSAHControlMonitor();
+  ~CALSAHControlMonitor();
+
+  bool Add(const std::string& ctlHandleName,
+           snd_ctl_elem_iface_t interface,
+           unsigned int device,
+           const std::string& name);
+
+  void Clear();
+
+  void Start();
+  void Stop();
+
+private:
+  static int HCTLCallback(snd_hctl_elem_t *elem, unsigned int mask);
+  static void FDEventCallback(int id, int fd, short revents, void *data);
+
+  snd_hctl_t* GetHandle(const std::string& ctlHandleName);
+  void PutHandle(const std::string& ctlHandleName);
+
+  struct CTLHandle
+  {
+    snd_hctl_t *handle;
+    int useCount;
+
+    CTLHandle(snd_hctl_t *handle_) : handle(handle_), useCount(0) {}
+    CTLHandle() : handle(NULL), useCount(0) {}
+  };
+
+  std::map<std::string, CTLHandle> m_ctlHandles;
+
+  std::vector<int> m_fdMonitorIds;
+};
+
+#endif
+

From 1800cdd76ee8224dce93b7cea3e96d2c3df9ee49 Mon Sep 17 00:00:00 2001
From: Anssi Hannula <anssi@xbmc.org>
Date: Sun, 2 Nov 2014 21:10:51 +0200
Subject: [PATCH 21/24] [AE] ALSA: Add more logging to device change triggers

---
 xbmc/cores/AudioEngine/Sinks/alsa/ALSADeviceMonitor.cpp   | 13 +++++++++++--
 xbmc/cores/AudioEngine/Sinks/alsa/ALSAHControlMonitor.cpp |  2 ++
 2 files changed, 13 insertions(+), 2 deletions(-)

diff --git a/xbmc/cores/AudioEngine/Sinks/alsa/ALSADeviceMonitor.cpp b/xbmc/cores/AudioEngine/Sinks/alsa/ALSADeviceMonitor.cpp
index e3269ad..b0243b9 100644
--- a/xbmc/cores/AudioEngine/Sinks/alsa/ALSADeviceMonitor.cpp
+++ b/xbmc/cores/AudioEngine/Sinks/alsa/ALSADeviceMonitor.cpp
@@ -113,12 +113,21 @@ void CALSADeviceMonitor::FDEventCallback(int id, int fd, short revents, void *da
     const char* action = udev_device_get_action(device);
     const char* soundInitialized = udev_device_get_property_value(device, "SOUND_INITIALIZED");
 
+    if (!action || !soundInitialized)
+      continue;
+
     /* cardX devices emit a "change" event when ready (i.e. all subdevices added) */
-    if (action && soundInitialized &&
-        (strcmp(action, "change") == 0 || strcmp(action, "remove") == 0))
+    if (strcmp(action, "change") == 0)
     {
+      CLog::Log(LOGDEBUG, "CALSADeviceMonitor - ALSA card added (\"%s\", \"%s\")", udev_device_get_syspath(device), udev_device_get_devpath(device));
       audioDevicesChanged = true;
     }
+    else if (strcmp(action, "remove") == 0)
+    {
+      CLog::Log(LOGDEBUG, "CALSADeviceMonitor - ALSA card removed");
+      audioDevicesChanged = true;
+    }
+
     udev_device_unref(device);
   }
 
diff --git a/xbmc/cores/AudioEngine/Sinks/alsa/ALSAHControlMonitor.cpp b/xbmc/cores/AudioEngine/Sinks/alsa/ALSAHControlMonitor.cpp
index 9b595ee..f9ca9ae 100644
--- a/xbmc/cores/AudioEngine/Sinks/alsa/ALSAHControlMonitor.cpp
+++ b/xbmc/cores/AudioEngine/Sinks/alsa/ALSAHControlMonitor.cpp
@@ -120,6 +120,8 @@ int CALSAHControlMonitor::HCTLCallback(snd_hctl_elem_t *elem, unsigned int mask)
    */
   if (mask & SND_CTL_EVENT_MASK_VALUE)
   {
+    CLog::Log(LOGDEBUG, "CALSAHControlMonitor - Monitored ALSA hctl value changed");
+
     CAEFactory::DeviceChange();
   }
 

From f8baf30230b7db45865e13260298830313481263 Mon Sep 17 00:00:00 2001
From: Anssi Hannula <anssi@xbmc.org>
Date: Tue, 4 Nov 2014 19:22:03 +0200
Subject: [PATCH 22/24] [AE] ALSA: Fix DeviceChange event triggered by
 enumeration

All hctl elements get an SND_CTL_EVENT_MASK_REMOVE event when the ctl
file descriptor is closed, which is done e.g. when re-enumerating
devices.

(SND_CTL_EVENT_MASK_REMOVE & SND_CTL_EVENT_MASK_VALUE) is true, and
therefore we re-triggered enumeration (depending a bit on timing).

Fix that by checking for the special _REMOVE value first and ignoring
those events.
---
 .../cores/AudioEngine/Sinks/alsa/ALSAHControlMonitor.cpp | 16 ++++++++++++----
 1 file changed, 12 insertions(+), 4 deletions(-)

diff --git a/xbmc/cores/AudioEngine/Sinks/alsa/ALSAHControlMonitor.cpp b/xbmc/cores/AudioEngine/Sinks/alsa/ALSAHControlMonitor.cpp
index f9ca9ae..89a7585 100644
--- a/xbmc/cores/AudioEngine/Sinks/alsa/ALSAHControlMonitor.cpp
+++ b/xbmc/cores/AudioEngine/Sinks/alsa/ALSAHControlMonitor.cpp
@@ -114,14 +114,22 @@ void CALSAHControlMonitor::Stop()
 
 int CALSAHControlMonitor::HCTLCallback(snd_hctl_elem_t *elem, unsigned int mask)
 {
-  /*
-   * Currently we just re-enumerate on any change.
-   * Custom callbacks for handling other control monitoring may be implemented when needed.
-   */
+  /* _REMOVE is a special value instead of a bit and must be checked first */
+  if (mask == SND_CTL_EVENT_MASK_REMOVE)
+  {
+    /* Either the device was removed (which is handled in ALSADeviceMonitor instead)
+     * or snd_hctl_close() got called. */
+    return 0;
+  }
+
   if (mask & SND_CTL_EVENT_MASK_VALUE)
   {
     CLog::Log(LOGDEBUG, "CALSAHControlMonitor - Monitored ALSA hctl value changed");
 
+    /*
+     * Currently we just re-enumerate on any change.
+     * Custom callbacks for handling other control monitoring may be implemented when needed.
+     */
     CAEFactory::DeviceChange();
   }
 

From 8d85a4aec9e17f8ddb7e26e01df83f50b7c53eb2 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Sat, 1 Nov 2014 07:47:16 +0100
Subject: [PATCH 23/24] videorefclock: use videosync DRM on AMD systems

---
 xbmc/video/VideoReferenceClock.cpp | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/xbmc/video/VideoReferenceClock.cpp b/xbmc/video/VideoReferenceClock.cpp
index be6be5f..2b506ad 100644
--- a/xbmc/video/VideoReferenceClock.cpp
+++ b/xbmc/video/VideoReferenceClock.cpp
@@ -99,7 +99,8 @@ void CVideoReferenceClock::Process()
 #if defined(HAVE_X11)
   std::string gpuvendor = g_Windowing.GetRenderVendor();
   std::transform(gpuvendor.begin(), gpuvendor.end(), gpuvendor.begin(), ::tolower);
-  if (gpuvendor.compare(0, 5, "intel") == 0)
+  if ((gpuvendor.compare(0, 5, "intel") == 0 ||
+       gpuvendor.compare(0, 5, "x.org") == 0)) // AMD
     m_pVideoSync = new CVideoSyncDRM();
 #if defined(HAS_GLX)
   else

From f5211d149c7af1b3f9273ed64c08a4af76fbc066 Mon Sep 17 00:00:00 2001
From: fritsch <Peter.Fruehberger@gmail.com>
Date: Fri, 7 Nov 2014 14:56:49 +0100
Subject: [PATCH 24/24] DVDVideoCodecFFmpeg: Squash me to: 2551ee3a

---
 xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.cpp | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.cpp b/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.cpp
index 368de0e..e9edd0c 100644
--- a/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.cpp
+++ b/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.cpp
@@ -928,7 +928,7 @@ bool CDVDDemuxFFmpeg::SeekTime(int time, bool backwords, double *startpts)
 
       // seek may fail silently on streams which allow discontinuity
       // if current timestamp is way off asume a pts overflow and try bisect seek
-      if (m_bPtsWrap && fabs(time - m_iCurrentPts/1000) > 10000)
+      if (m_bPtsWrap && fabs(time - m_currentPts/1000) > 10000)
       {
         ret = SeekTimeDiscont(seek_pts, backwords) ? 1 : -1;
       }
@@ -1026,7 +1026,7 @@ bool CDVDDemuxFFmpeg::SeekTimeDiscont(int64_t pts, bool backwards)
     bool ret = SeekByte(pos_max);
     if (ret)
     {
-      m_iCurrentPts = ConvertTimestamp(ts_max, m_pFormatContext->streams[defaultStream]->time_base.den,
+      m_currentPts = ConvertTimestamp(ts_max, m_pFormatContext->streams[defaultStream]->time_base.den,
                                        m_pFormatContext->streams[defaultStream]->time_base.num);
     }
     return ret;
@@ -1103,7 +1103,7 @@ bool CDVDDemuxFFmpeg::SeekTimeDiscont(int64_t pts, bool backwards)
   bool ret = SeekByte(pos);
   if (ret)
   {
-    m_iCurrentPts = ConvertTimestamp(ts, m_pFormatContext->streams[defaultStream]->time_base.den,
+    m_currentPts = ConvertTimestamp(ts, m_pFormatContext->streams[defaultStream]->time_base.den,
                                      m_pFormatContext->streams[defaultStream]->time_base.num);
   }
 
