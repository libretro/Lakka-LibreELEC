diff --git a/drivers/amlogic/dvb_tv/Kconfig b/drivers/amlogic/dvb_tv/Kconfig
index 10c45ffc17f2..7b591548a507 100644
--- a/drivers/amlogic/dvb_tv/Kconfig
+++ b/drivers/amlogic/dvb_tv/Kconfig
@@ -1,289 +1,14 @@
 #
-# DVB driver configuration
+# WetekPlay driver configuration
 #
 
-menu "Amlogic DVB driver"
+menu "WetekPlay driver"
 
 config AM_DVB
-	tristate "AMLOGIC DVB driver"
+	tristate "WetekPlay driver"
 	default n
 	select DVB_CORE
 	help
-		Select to enable AMLogic DVB driver.
-		Y: enable
-		N: disable
-		M: build as module
-
-config AM_ATVDEMOD
-	tristate "Amlogic ATVDEMOD device driver"
-	default n
-	help
-	  ATVDEMOD device driver.
-		Y: enable
-		N: disable
-		M: build as module
-
-config AM_DTVDEMOD
-	tristate "Amlogic DTVDEMOD device driver"
-	default n
-	depends on AM_DVB
-	help
-		DTVDEMOD device driver.
-		Y: enable
-		N: disable
-		M: build as module
-menu "AMLOGIC CI Driver"
-
-config AM_CI
-	tristate "Amlogic Common Interface driver"
-	default n
-	depends on AM_DVB
-	select AM_PCMCIA
-	select AM_IOBUS
-	help
-		Select to enable Amlogic CI driver.
-		Y: enable
-		N: disable
-		M: build as module
-config AM_PCMCIA
-	tristate "Amlogic PCMCIA driver"
-	default n
-	help
-		Select to enable Amlogic PCMCIA driver.
-		Y: enable
-		N: disable
-		M: build as module
-config AM_IOBUS
-	tristate "Amlogic IOBUS driver"
-	default n
-	help
-		Select to enable Amlogic IOBUS driver.
-		Y: enable
-		N: disable
-		M: build as module
-endmenu
-
-if !OF
-
-config AMLOGIC_TS0
-	bool "Enable TS0"
-	default n
-	depends on AM_DVB
-	help
-		Enable TS0.
-		Y: enable
-		N: disable
-		M: build as module
-config AMLOGIC_S_TS0
-	bool "Serial TS0"
-	default n
-	depends on AMLOGIC_TS0
-	help
-		TS0 in serial mode.
-		Y: enable
-		N: disable
-		M: build as module
-config AMLOGIC_TS0_INVERT_S2P1_FEC_ERROR
-	bool "Invert FEC_ERROR TS0"
-	default n
-	depends on AMLOGIC_S_TS0
-	help
-		TS0 FEC_ERROR invert
-		Y: enable
-		N: disable
-		M: build as module
-config AMLOGIC_TS0_INVERT_S2P1_FEC_DATA
-	bool "Invert FEC_DATA TS0"
-	default n
-	depends on AMLOGIC_S_TS0
-	help
-		TS0 FEC_DATA invert
-		Y: enable
-		N: disable
-		M: build as module
-config AMLOGIC_TS0_INVERT_S2P1_FEC_SYNC
-	bool "Invert FEC_SYNC TS0"
-	default n
-	depends on AMLOGIC_S_TS0
-	help
-		TS0 FEC_SYNC invert
-		Y: enable
-		N: disable
-		M: build as module
-config AMLOGIC_TS0_INVERT_S2P1_FEC_VALID
-	bool "Invert FEC_VALID TS0"
-	default n
-	depends on AMLOGIC_S_TS0
-	help
-		TS0 FEC_VALID invert
-		Y: enable
-		N: disable
-		M: build as module
-config AMLOGIC_TS0_INVERT_S2P1_FEC_CLK
-	bool "Invert FEC_CLK TS0"
-	default n
-	depends on AMLOGIC_S_TS0
-	help
-		TS0 FEC_CLK invert
-		Y: enable
-		N: disable
-		M: build as module
-config AMLOGIC_TS1
-	bool "Enable TS1"
-	default n
-	depends on AM_DVB
-	help
-		Enable TS1.
-		Y: enable
-		N: disable
-		M: build as module
-config AMLOGIC_S_TS1
-	bool "Serial TS1"
-	default n
-	depends on AMLOGIC_TS1
-	help
-		TS1 in serial mode.
-		Y: enable
-		N: disable
-		M: build as module
-config AMLOGIC_TS1_INVERT_S2P1_FEC_ERROR
-	bool "Invert FEC_ERROR TS1"
-	default n
-	depends on AMLOGIC_S_TS1
-	help
-		TS1 FEC_ERROR invert
-		Y: enable
-		N: disable
-		M: build as module
-config AMLOGIC_TS1_INVERT_S2P1_FEC_DATA
-	bool "Invert FEC_DATA TS1"
-	default n
-	depends on AMLOGIC_S_TS1
-	help
-		TS1 FEC_DATA invert
-		Y: enable
-		N: disable
-		M: build as module
-config AMLOGIC_TS1_INVERT_S2P1_FEC_SYNC
-	bool "Invert FEC_SYNC TS1"
-	default n
-	depends on AMLOGIC_S_TS1
-	help
-		TS1 FEC_SYNC invert
-		Y: enable
-		N: disable
-		M: build as module
-config AMLOGIC_TS1_INVERT_S2P1_FEC_VALID
-	bool "Invert FEC_VALID TS1"
-	default n
-	depends on AMLOGIC_S_TS1
-	help
-		TS1 FEC_VALID invert
-		Y: enable
-		N: disable
-		M: build as module
-config AMLOGIC_TS1_INVERT_S2P1_FEC_CLK
-	bool "Invert FEC_CLK TS1"
-	default n
-	depends on AMLOGIC_S_TS1
-	help
-		TS1 FEC_CLK invert
-		Y: enable
-		N: disable
-		M: build as module
-config AMLOGIC_TS2
-	bool "Enable TS2"
-	default n
-	depends on AM_DVB
-	help
-		Enable TS2.
-		Y: enable
-		N: disable
-		M: build as module
-config AMLOGIC_S_TS2
-	bool "Serial TS2"
-	default n
-	depends on AMLOGIC_TS2
-	help
-		TS2 in serial mode.
-		Y: enable
-		N: disable
-		M: build as module
-config AMLOGIC_TS2_INVERT_S2P1_FEC_ERROR
-	bool "Invert FEC_ERROR TS2"
-	default n
-	depends on AMLOGIC_S_TS2
-	help
-		TS2 FEC_ERROR invert
-		Y: enable
-		N: disable
-		M: build as module
-config AMLOGIC_TS2_INVERT_S2P1_FEC_DATA
-	bool "Invert FEC_DATA TS2"
-	default n
-	depends on AMLOGIC_S_TS2
-	help
-		TS2 FEC_DATA invert
-		Y: enable
-		N: disable
-		M: build as module
-config AMLOGIC_TS2_INVERT_S2P1_FEC_SYNC
-	bool "Invert FEC_SYNC TS2"
-	default n
-	depends on AMLOGIC_S_TS2
-	help
-		TS2 FEC_SYNC invert
-		Y: enable
-		N: disable
-		M: build as module
-config AMLOGIC_TS2_INVERT_S2P1_FEC_VALID
-	bool "Invert FEC_VALID TS2"
-	default n
-	depends on AMLOGIC_S_TS2
-	help
-		TS2 FEC_VALID invert
-		Y: enable
-		N: disable
-		M: build as module
-config AMLOGIC_TS2_INVERT_S2P1_FEC_CLK
-	bool "Invert FEC_CLK TS2"
-	default n
-	depends on AMLOGIC_S_TS2
-	help
-		TS2 FEC_CLK invert
-		Y: enable
-		N: disable
-		M: build as module
-endif
-source "drivers/amlogic/dvb_tv/smartcard/Kconfig"
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
+		Select to enable WetekPlay driver.
 endmenu
 
diff --git a/drivers/amlogic/dvb_tv/Makefile b/drivers/amlogic/dvb_tv/Makefile
index 14f0e74d1177..cf5a0afc1736 100644
--- a/drivers/amlogic/dvb_tv/Makefile
+++ b/drivers/amlogic/dvb_tv/Makefile
@@ -1,62 +1,10 @@
 #
-# Makefile for the DVB driver.
+# Makefile for the WetekPlay driver.
 #
 
-obj-$(CONFIG_AM_DVB) += aml.o
+obj-$(CONFIG_AM_DVB) += wetekplay.o
 
-aml-objs=aml_dvb.o aml_dmx.o
+wetekplay-objs = nimdetect.o mxl603.o avl6211.o mn88436.o cxd2841er.o ascot3.o
 
-obj-$(CONFIG_AM_DVB) += aml_fe.o
-
-#obj-$(CONFIG_AM_CI) += amlci/
-
-obj-$(CONFIG_AM_DTVDEMOD) += amldemod/
-
-obj-$(CONFIG_AM_ATVDEMOD) += amlatvdemod/
-
-obj-$(CONFIG_AML_SMARTCARD) += smartcard/
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-ccflags-y += -I.
+EXTRA_CFLAGS += -Idrivers/media/dvb-core -Idrivers/media/tuners
+EXTRA_CFLAGS += -I.
diff --git a/drivers/amlogic/dvb_tv/aml_dmx.c b/drivers/amlogic/dvb_tv/aml_dmx.c
deleted file mode 100644
index c6ee5d0c2efe..000000000000
--- a/drivers/amlogic/dvb_tv/aml_dmx.c
+++ /dev/null
@@ -1,4573 +0,0 @@
-/*
- * AMLOGIC demux driver.
- */
-
-#include <linux/version.h>
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/mutex.h>
-#include <linux/wait.h>
-#include <linux/string.h>
-#include <linux/interrupt.h>
-#include <linux/fs.h>
-#include <linux/cdev.h>
-#include <linux/device.h>
-#include <linux/spinlock.h>
-#include <linux/fcntl.h>
-#include <asm/irq.h>
-#include <linux/uaccess.h>
-#include <linux/poll.h>
-#include <linux/delay.h>
-#include <linux/platform_device.h>
-#include <linux/delay.h>
-#include <asm/cacheflush.h>
-#include <linux/dma-mapping.h>
-#ifdef ARC_700
-#include <asm/arch/am_regs.h>
-#else
-#include "c_stb_define.h"
-#include "c_stb_regs_define.h"
-#endif
-
-#include <linux/pinctrl/pinmux.h>
-
-#include "../amports/streambuf.h"
-#include "aml_dvb.h"
-#include "aml_dvb_reg.h"
-
-
-#include <linux/vmalloc.h>
-
-#define ENABLE_SEC_BUFF_WATCHDOG
-#define USE_AHB_MODE
-
-#define pr_dbg_flag(_f, _args...)\
-	do {\
-		if (debug_dmx&(_f))\
-			printk(_args);\
-	} while (0)
-#define pr_dbg_irq_flag(_f, _args...)\
-	do {\
-		if (debug_irq&(_f))\
-			printk(_args);\
-	} while (0)
-#define pr_dbg(args...)	pr_dbg_flag(0x1, args)
-#define pr_dbg_irq(args...)pr_dbg_irq_flag(0x1, args)
-#define pr_dbg_irq_dvr(args...)pr_dbg_irq_flag(0x2, args)
-#define pr_dbg_sf(args...) pr_dbg_flag(0x4, args)
-#define pr_dbg_irq_sf(args...) pr_dbg_irq_flag(0x4, args)
-#define pr_dbg_ss(args...) pr_dbg_flag(0x8, args)
-#define pr_dbg_irq_ss(args...) pr_dbg_irq_flag(0x8, args)
-
-#define pr_error(fmt, args...) printk("DVB: " fmt, ## args)
-#define pr_inf(fmt, args...)  printk("DVB: " fmt, ## args)
-
-#define dump(b, l) \
-	do { \
-		int i; \
-		printk("dump: "); \
-		for (i = 0; i < (l); i++) {\
-			if (!(i&0xf)) \
-				printk("\n\t"); \
-			printk("%02x ", *(((unsigned char *)(b))+i)); \
-		} \
-		printk("\n"); \
-	} while (0)
-
-MODULE_PARM_DESC(debug_dmx, "\n\t\t Enable demux debug information");
-static int debug_dmx;
-module_param(debug_dmx, int, 0644);
-
-MODULE_PARM_DESC(debug_irq, "\n\t\t Enable demux IRQ debug information");
-static int debug_irq;
-module_param(debug_irq, int, 0644);
-
-static int npids = CHANNEL_COUNT;
-#define MOD_PARAM_DECLARE_CHANPIDS(_dmx) \
-MODULE_PARM_DESC(debug_dmx##_dmx##_chanpids, "\n\t\t pids of dmx channels"); \
-static short debug_dmx##_dmx##_chanpids[CHANNEL_COUNT] = \
-					{[0 ... (CHANNEL_COUNT - 1)] = -1}; \
-module_param_array(debug_dmx##_dmx##_chanpids, short, &npids, 0444)
-
-MOD_PARAM_DECLARE_CHANPIDS(0);
-MOD_PARAM_DECLARE_CHANPIDS(1);
-MOD_PARAM_DECLARE_CHANPIDS(2);
-
-#define set_debug_dmx_chanpids(_dmx, _idx, _pid)\
-	do { \
-		if ((_dmx) == 0) \
-			debug_dmx0_chanpids[(_idx)] = (_pid); \
-		else if ((_dmx) == 1) \
-			debug_dmx1_chanpids[(_idx)] = (_pid); \
-		else if ((_dmx) == 2) \
-			debug_dmx2_chanpids[(_idx)] = (_pid); \
-	} while (0)
-
-MODULE_PARM_DESC(debug_sf_user, "\n\t\t only for sf mode check");
-static int debug_sf_user;
-module_param(debug_sf_user, int, 0444);
-
-MODULE_PARM_DESC(force_sec_sf, "\n\t\t force sf mode for sec filter");
-static int force_sec_sf;
-module_param(force_sec_sf, int, 0644);
-
-MODULE_PARM_DESC(force_pes_sf, "\n\t\t force sf mode for pes filter");
-static int force_pes_sf;
-module_param(force_pes_sf, int, 0644);
-
-#define DMX_READ_REG(i, r)\
-	((i)?((i == 1)?READ_MPEG_REG(r##_2) :\
-	READ_MPEG_REG(r##_3)) : READ_MPEG_REG(r))
-
-#define DMX_WRITE_REG(i, r, d)\
-	do {\
-		if (i == 1) {\
-			WRITE_MPEG_REG(r##_2, d);\
-		} else if (i == 2) {\
-			WRITE_MPEG_REG(r##_3, d);\
-		} \
-		else {\
-			WRITE_MPEG_REG(r, d);\
-		} \
-	} while (0)
-
-#define READ_PERI_REG			READ_CBUS_REG
-#define WRITE_PERI_REG			WRITE_CBUS_REG
-
-#define READ_ASYNC_FIFO_REG(i, r)\
-	((i) ? READ_PERI_REG(ASYNC_FIFO2_##r) : READ_PERI_REG(ASYNC_FIFO_##r))
-
-#define WRITE_ASYNC_FIFO_REG(i, r, d)\
-	do {\
-		if (i == 1) {\
-			WRITE_PERI_REG(ASYNC_FIFO2_##r, d);\
-		} else {\
-			WRITE_PERI_REG(ASYNC_FIFO_##r, d);\
-		} \
-	} while (0)
-
-#define CLEAR_ASYNC_FIFO_REG_MASK(i, reg, mask) \
-	WRITE_ASYNC_FIFO_REG(i, reg, \
-	(READ_ASYNC_FIFO_REG(i, reg)&(~(mask))))
-
-#define DVR_FEED(f) \
-	((f) && ((f)->type == DMX_TYPE_TS) &&	\
-	(((f)->ts_type & (TS_PACKET | TS_DEMUX)) == TS_PACKET))
-
-#define MOD_PARAM_DECLARE_CHANREC(_dmx) \
-MODULE_PARM_DESC(dmx##_dmx##_chanrec_enable, \
-	       "\n\t\t record by channel, one time use in the beginning"); \
-static int dmx##_dmx##_chanrec_enable; \
-module_param(dmx##_dmx##_chanrec_enable, int, 0644); \
-MODULE_PARM_DESC(dmx##_dmx##_chanrec, "\n\t\t record channels bits"); \
-static int dmx##_dmx##_chanrec; \
-module_param(dmx##_dmx##_chanrec, int, 0644)
-
-MOD_PARAM_DECLARE_CHANREC(0);
-MOD_PARAM_DECLARE_CHANREC(1);
-MOD_PARAM_DECLARE_CHANREC(2);
-
-#define MOD_PARAM_DECLARE_CHANPROC(_dmx) \
-MODULE_PARM_DESC(dmx##_dmx##_chanproc_enable, "channel further processing"); \
-static int dmx##_dmx##_chanproc_enable; \
-module_param(dmx##_dmx##_chanproc_enable, int, 0644); \
-MODULE_PARM_DESC(dmx##_dmx##_chanproc, "further process channels bits"); \
-static int dmx##_dmx##_chanproc; \
-module_param(dmx##_dmx##_chanproc, int, 0644)
-
-MOD_PARAM_DECLARE_CHANPROC(0);
-MOD_PARAM_DECLARE_CHANPROC(1);
-MOD_PARAM_DECLARE_CHANPROC(2);
-
-#define DMX_CH_OP_CHANREC  0
-#define DMX_CH_OP_CHANPROC 1
-
-static inline int _setbit(int v, int b) { return v|(1<<b); }
-static inline int _clrbit(int v, int b) { return v&~(1<<b); }
-static inline int _set(int v, int b) { return b; }
-static void dmxn_op_chan(int dmx, int ch, int(*op)(int, int), int ch_op)
-{
-	int enable_0, enable_1, enable_2;
-	int *set_0, *set_1, *set_2;
-	int reg;
-
-	if (ch_op == DMX_CH_OP_CHANREC) {
-		enable_0 = dmx0_chanrec_enable;
-		enable_1 = dmx1_chanrec_enable;
-		enable_2 = dmx2_chanrec_enable;
-		set_0 = &dmx0_chanrec;
-		set_1 = &dmx1_chanrec;
-		set_2 = &dmx2_chanrec;
-		reg = DEMUX_CHAN_RECORD_EN;
-	} else if (ch_op == DMX_CH_OP_CHANPROC) {
-		enable_0 = dmx0_chanproc_enable;
-		enable_1 = dmx1_chanproc_enable;
-		enable_2 = dmx2_chanproc_enable;
-		set_0 = &dmx0_chanproc;
-		set_1 = &dmx1_chanproc;
-		set_2 = &dmx2_chanproc;
-		reg = DEMUX_CHAN_PROCESS_EN;
-	} else {
-		return;
-	}
-	if (dmx == 0) {
-		if (enable_0) {
-			*set_0 = op(*set_0, ch);
-			WRITE_MPEG_REG(reg+DEMUX_1_OFFSET, *set_0);
-		}
-	} else if (dmx == 1) {
-		if (enable_1) {
-			*set_1 = op(*set_1, ch);
-			WRITE_MPEG_REG(reg+DEMUX_2_OFFSET, *set_1);
-		}
-	} else if (dmx == 2) {
-		if (enable_2) {
-			*set_2 = op(*set_2, ch);
-			WRITE_MPEG_REG(reg+DEMUX_3_OFFSET, *set_2);
-		}
-	}
-}
-#define dmx_add_recchan(_dmx, _chid) \
-	do { \
-		pr_dbg("dmx[%d]_add_recchan[%d]\n", _dmx, _chid); \
-		dmxn_op_chan(_dmx, _chid, _setbit, DMX_CH_OP_CHANREC); \
-	} while (0)
-#define dmx_rm_recchan(_dmx, _chid) \
-	do { \
-		pr_dbg("dmx[%d]_rm_recchan[%ld]\n", _dmx, _chid); \
-		dmxn_op_chan(_dmx, _chid, _clrbit, DMX_CH_OP_CHANREC); \
-	} while (0)
-#define dmx_set_recchan(_dmx, _chs) \
-	do { \
-		pr_dbg("dmx[%d]_set_recchan[%d]\n", _dmx, _chs); \
-		dmxn_op_chan(_dmx, _chs, _set, DMX_CH_OP_CHANREC); \
-	} while (0)
-
-#define dmx_add_procchan(_dmx, _chid) \
-	do { \
-		pr_dbg("dmx[%d]_add_procchan[%d]\n", _dmx, _chid); \
-		dmxn_op_chan(_dmx, _chid, _setbit, DMX_CH_OP_CHANPROC); \
-	} while (0)
-#define dmx_rm_procchan(_dmx, _chid) \
-	do { \
-		pr_dbg("dmx[%d]_rm_procchan[%ld]\n", _dmx, _chid); \
-		dmxn_op_chan(_dmx, _chid, _clrbit, DMX_CH_OP_CHANPROC); \
-	} while (0)
-#define dmx_set_procchan(_dmx, _chs) \
-	do { \
-		pr_dbg("dmx[%d]_set_procchan[%d]\n", _dmx, _chs); \
-		dmxn_op_chan(_dmx, _chs, _set, DMX_CH_OP_CHANPROC); \
-	} while (0)
-
-#define NO_SUB
-
-#define SYS_CHAN_COUNT    (4)
-#define SEC_GRP_LEN_0     (0xc)
-#define SEC_GRP_LEN_1     (0xc)
-#define SEC_GRP_LEN_2     (0xc)
-#define SEC_GRP_LEN_3     (0xc)
-#define LARGE_SEC_BUFF_MASK  0xFFFFFFFF
-#define LARGE_SEC_BUFF_COUNT 32
-#define WATCHDOG_TIMER    250
-#define ASYNCFIFO_BUFFER_SIZE_DEFAULT (512*1024)
-
-#define DEMUX_INT_MASK\
-			((0<<(AUDIO_SPLICING_POINT))    |\
-			(0<<(VIDEO_SPLICING_POINT))     |\
-			(0<<(OTHER_PES_READY))          |\
-			(1<<(SUB_PES_READY))            |\
-			(1<<(SECTION_BUFFER_READY))     |\
-			(0<<(OM_CMD_READ_PENDING))      |\
-			(1<<(TS_ERROR_PIN))             |\
-			(1<<(NEW_PDTS_READY))           |\
-			(0<<(DUPLICATED_PACKET))        |\
-			(0<<(DIS_CONTINUITY_PACKET)))
-
-#define TS_SRC_MAX 3
-
-/*Reset the demux device*/
-#define RESET_DEMUX2      (1<<15)
-#define RESET_DEMUX1      (1<<14)
-#define RESET_DEMUX0      (1<<13)
-#define RESET_S2P1        (1<<12)
-#define RESET_S2P0        (1<<11)
-#define RESET_DES         (1<<10)
-#define RESET_TOP         (1<<9)
-
-static int dmx_remove_feed(struct aml_dmx *dmx, struct dvb_demux_feed *feed);
-static void reset_async_fifos(struct aml_dvb *dvb);
-static int dmx_add_feed(struct aml_dmx *dmx, struct dvb_demux_feed *feed);
-static int dmx_smallsec_set(struct aml_smallsec *ss, int enable, int bufsize,
-				int force);
-static int dmx_timeout_set(struct aml_dmxtimeout *dto, int enable,
-				int timeout, int ch_dis, int nomatch,
-				int force);
-
-/*Audio & Video PTS value*/
-static u32 video_pts;
-static u32 audio_pts;
-static u32 first_video_pts;
-static u32 first_audio_pts;
-static int demux_skipbyte;
-static int tsfile_clkdiv = 4;
-
-#define SF_DMX_ID 2
-#define SF_AFIFO_ID 1
-
-#define sf_dmx_sf(_dmx) \
-	(((_dmx)->id == SF_DMX_ID) \
-	&& ((struct aml_dvb *)(_dmx)->demux.priv)->swfilter.user)
-#define sf_afifo_sf(_afifo) \
-	(((_afifo)->id == SF_AFIFO_ID) && (_afifo)->dvb->swfilter.user)
-#define dmx_get_dev(dmx) (((struct aml_dvb *)((dmx)->demux.priv))->dev)
-#define asyncfifo_get_dev(afifo) ((afifo)->dvb->dev)
-
-
-/*Section buffer watchdog*/
-static void section_buffer_watchdog_func(unsigned long arg)
-{
-	struct aml_dvb *dvb = (struct aml_dvb *)arg;
-	struct aml_dmx *dmx;
-	u32 section_busy32 = 0, om_cmd_status32 = 0,
-	    demux_channel_activity32 = 0;
-	u16 demux_int_status1 = 0;
-	u32 device_no = 0;
-	u32 filter_number = 0;
-	u32 i = 0;
-	unsigned long flags;
-
-	spin_lock_irqsave(&dvb->slock, flags);
-
-	for (device_no = 0; device_no < DMX_DEV_COUNT; device_no++) {
-
-		dmx = &dvb->dmx[device_no];
-
-		if (dvb->dmx_watchdog_disable[device_no])
-			continue;
-
-		if (!dmx->init)
-			continue;
-
-		om_cmd_status32 =
-		    DMX_READ_REG(device_no, OM_CMD_STATUS);
-		demux_channel_activity32 =
-		    DMX_READ_REG(device_no, DEMUX_CHANNEL_ACTIVITY);
-		section_busy32 =
-			DMX_READ_REG(device_no, SEC_BUFF_BUSY);
-#if 1
-		if (om_cmd_status32 & 0x8fc2) {
-			/* bit 15:12 -- om_cmd_count */
-			/* bit  11:9 -- overflow_count */
-			/* bit   8:6 -- om_overwrite_count */
-			/* bit     1 -- om_cmd_overflow */
-			/*BUG: If the recoder is running, return */
-			if (dmx->record)
-				goto end;
-			/*Reset the demux */
-			pr_dbg("reset the demux\n"
-			"%04x\t%03x\t%03x\t%03x\t%01x\t%01x\t"
-			"%x\t%x\tdmx%d:status:0x%x\n",
-			(om_cmd_status32 >> 12) & 0xf,
-			(om_cmd_status32 >> 9) & 0x7,
-			(om_cmd_status32 >> 6) & 0x7,
-			(om_cmd_status32 >> 3) & 0x7,
-			(om_cmd_status32 >> 2) & 0x1,
-			(om_cmd_status32 >> 1) & 0x1,
-			demux_channel_activity32, section_busy32,
-			dmx->id, om_cmd_status32);
-
-			dmx_reset_dmx_hw_ex_unlock(dvb, dmx, 0);
-			goto end;
-		}
-#else
-		/* bit 15:12 -- om_cmd_count (read only) */
-		/* bit  11:9 -- overflow_count //
-		   bit  11:9 -- om_cmd_wr_ptr (read only) */
-		/* bit   8:6 -- om_overwrite_count //
-		   bit   8:6 -- om_cmd_rd_ptr (read only) */
-		/* bit   5:3 -- type_stb_om_w_rd (read only) */
-		/* bit     2 -- unit_start_stb_om_w_rd (read only) */
-		/* bit     1 -- om_cmd_overflow (read only) */
-		/* bit     0 -- om_cmd_pending (read) */
-		/* bit     0 -- om_cmd_read_finished (write) */
-		if (om_cmd_status32 & 0x0002) {
-			pr_error("reset the demux\n");
-			dmx_reset_hw_ex(dvb, 0);
-			goto end;
-		}
-#endif
-		section_busy32 =
-			DMX_READ_REG(device_no, SEC_BUFF_BUSY);
-		if (LARGE_SEC_BUFF_MASK ==
-				(section_busy32 & LARGE_SEC_BUFF_MASK)) {
-			/*All the largest section buffers occupied,
-			 * clear buffers */
-			DMX_WRITE_REG(device_no,
-					SEC_BUFF_READY, section_busy32);
-		} else {
-			for (i = 0; i < SEC_BUF_COUNT; i++) {
-				if (!(section_busy32 & (1 << i)))
-					continue;
-				DMX_WRITE_REG(device_no, SEC_BUFF_NUMBER, i);
-				filter_number =	DMX_READ_REG(device_no,
-							SEC_BUFF_NUMBER);
-				filter_number >>= 8;
-				if ((filter_number >= FILTER_COUNT)
-					/* >=31, do not handle this case */
-					|| ((filter_number < FILTER_COUNT)
-					&& dmx->filter[filter_number].used))
-					section_busy32 &= ~(1 << i);
-			}
-			if (section_busy32 & (dmx->smallsec.enable ?
-						0x7FFFFFFF :
-						LARGE_SEC_BUFF_MASK)) {
-				/*Clear invalid buffers */
-				DMX_WRITE_REG(device_no,
-						SEC_BUFF_READY,
-						section_busy32);
-				pr_error("clear invalid buffer 0x%x\n",
-						section_busy32);
-			}
-#if 0
-			section_busy32 = 0x7fffffff;
-			for (i = 0; i < SEC_BUF_BUSY_SIZE; i++) {
-				dmx->section_busy[i] = (
-					(i == SEC_BUF_BUSY_SIZE - 1) ?
-					DMX_READ_REG(device_no, SEC_BUFF_BUSY) :
-					dmx->section_busy[i + 1]);
-				section_busy32 &= dmx->section_busy[i];
-			}
-
-			/*count the number of '1' bits */
-			i = section_busy32;
-			i = (i & 0x55555555) + ((i & 0xaaaaaaaa) >> 1);
-			i = (i & 0x33333333) + ((i & 0xcccccccc) >> 2);
-			i = (i & 0x0f0f0f0f) + ((i & 0xf0f0f0f0) >> 4);
-			i = (i & 0x00ff00ff) + ((i & 0xff00ff00) >> 8);
-			i = (i & 0x0000ffff) + ((i & 0xffff0000) >> 16);
-			if (i > LARGE_SEC_BUFF_COUNT) {
-				/*too long some of the section
-				 buffers are being processed */
-				DMX_WRITE_REG(device_no, SEC_BUFF_READY,
-					      section_busy32);
-			}
-#endif
-		}
-		demux_int_status1 =
-			DMX_READ_REG(device_no, STB_INT_STATUS) & 0xfff7;
-		if (demux_int_status1 & (1 << TS_ERROR_PIN)) {
-			DMX_WRITE_REG(device_no,
-				STB_INT_STATUS,
-				(1 << TS_ERROR_PIN));
-		}
-	}
-
-end:
-	spin_unlock_irqrestore(&dvb->slock, flags);
-#ifdef ENABLE_SEC_BUFF_WATCHDOG
-	mod_timer(&dvb->watchdog_timer,
-		  jiffies + msecs_to_jiffies(WATCHDOG_TIMER));
-#endif
-	return;
-}
-
-static inline int sec_filter_match(struct aml_dmx *dmx, struct aml_filter *f,
-				   u8 *p)
-{
-	int b;
-	u8 neq = 0;
-
-	if (!f->used || !dmx->channel[f->chan_id].used)
-		return 0;
-
-	for (b = 0; b < FILTER_LEN; b++) {
-		u8 xor = p[b] ^ f->value[b];
-
-		if (xor & f->maskandmode[b])
-			return 0;
-
-		if (xor & f->maskandnotmode[b])
-			neq = 1;
-	}
-
-	if (f->neq && !neq)
-		return 0;
-
-	return 1;
-}
-
-static int section_crc(struct aml_dmx *dmx, struct aml_filter *f, u8 *p)
-{
-	int sec_len = (((p[1] & 0xF) << 8) | p[2]) + 3;
-	struct dvb_demux_feed *feed = dmx->channel[f->chan_id].feed;
-
-	if (feed->feed.sec.check_crc) {
-		struct dvb_demux *demux = feed->demux;
-		struct dmx_section_feed *sec = &feed->feed.sec;
-		int section_syntax_indicator;
-
-		section_syntax_indicator = ((p[1] & 0x80) != 0);
-		sec->seclen = sec_len;
-		sec->crc_val = ~0;
-		if (demux->check_crc32(feed, p, sec_len)) {
-			pr_error("section CRC check failed!\n");
-
-#if 0
-			int i;
-
-			for (i = 0; i < sec_len; i++) {
-				pr_dbg("%02x ", p[i]);
-				if (!((i + 1) % 16))
-					pr_dbg("\n");
-			}
-			pr_dbg("\nerror section data\n");
-#endif
-			return 0;
-		}
-#if 0
-		int i;
-
-		for (i = 0; i < sec_len; i++) {
-			pr_dbg("%02x ", p[i]);
-			if (!((i + 1) % 16))
-				pr_dbg("\n");
-		}
-		pr_dbg("\nsection data\n");
-#endif
-	}
-
-	return 1;
-}
-
-static void section_notify(struct aml_dmx *dmx, struct aml_filter *f, u8 *p)
-{
-	int sec_len = (((p[1] & 0xF) << 8) | p[2]) + 3;
-	struct dvb_demux_feed *feed = dmx->channel[f->chan_id].feed;
-
-	if (feed && feed->cb.sec)
-		feed->cb.sec(p, sec_len, NULL, 0, f->filter, DMX_OK);
-}
-
-static void hardware_match_section(struct aml_dmx *dmx,
-						u16 sec_num, u16 buf_num)
-{
-	u8 *p = (u8 *) dmx->sec_buf[buf_num].addr;
-	struct aml_filter *f;
-	int chid, i;
-	int need_crc = 1;
-
-	if (sec_num >= FILTER_COUNT) {
-		pr_dbg("sec_num invalid: %d\n", sec_num);
-		return;
-	}
-
-	dma_sync_single_for_cpu(dmx_get_dev(dmx),
-				dmx->sec_pages_map + (buf_num << 0x0c),
-				(1 << 0x0c), DMA_FROM_DEVICE);
-
-	f = &dmx->filter[sec_num];
-	chid = f->chan_id;
-
-	for (i = 0; i < FILTER_COUNT; i++) {
-		f = &dmx->filter[i];
-		if (f->chan_id != chid)
-			continue;
-		if (sec_filter_match(dmx, f, p)) {
-			if (need_crc) {
-				if (!section_crc(dmx, f, p))
-					return;
-				need_crc = 0;
-			}
-
-			section_notify(dmx, f, p);
-		}
-	}
-}
-
-static void software_match_section(struct aml_dmx *dmx, u16 buf_num)
-{
-	u8 *p = (u8 *) dmx->sec_buf[buf_num].addr;
-	struct aml_filter *f, *fmatch = NULL;
-	int i, fid = -1;
-
-	dma_sync_single_for_cpu(dmx_get_dev(dmx),
-				dmx->sec_pages_map + (buf_num << 0x0c),
-				(1 << 0x0c), DMA_FROM_DEVICE);
-
-	for (i = 0; i < FILTER_COUNT; i++) {
-		f = &dmx->filter[i];
-
-		if (sec_filter_match(dmx, f, p)) {
-			pr_dbg("[software match]filter %d match, pid %d\n",
-			       i, dmx->channel[f->chan_id].pid);
-			if (!fmatch) {
-				fmatch = f;
-				fid = i;
-			} else {
-				pr_dbg("software match]Muli-filter match this\n"
-					"section, will skip this section\n");
-				return;
-			}
-		}
-	}
-
-	if (fmatch) {
-		pr_dbg("[software match]dispatch\n"
-			"section to filter %d pid %d\n",
-			fid, dmx->channel[fmatch->chan_id].pid);
-		if (section_crc(dmx, fmatch, p))
-			section_notify(dmx, fmatch, p);
-	} else {
-		pr_dbg("[software match]this section do not\n"
-			"match any filter!!!\n");
-	}
-}
-
-
-static int _rbuf_write(struct dvb_ringbuffer *buf, const u8 *src, size_t len)
-{
-	ssize_t free;
-
-	if (!len)
-		return 0;
-	if (!buf->data)
-		return 0;
-
-	free = dvb_ringbuffer_free(buf);
-	if (len > free) {
-		pr_error("sf: buffer overflow\n");
-		return -EOVERFLOW;
-	}
-
-	return dvb_ringbuffer_write(buf, src, len);
-}
-
-static int _rbuf_filter_pkts(struct dvb_ringbuffer *rb,
-			u8 *wrapbuf,
-			void (*swfilter_packets)(struct dvb_demux *demux,
-						const u8 *buf,
-						size_t count),
-			struct dvb_demux *demux)
-{
-	ssize_t len1 = 0;
-	ssize_t len2 = 0;
-	size_t off;
-	size_t count;
-	size_t size;
-
-	if (debug_irq & 0x4)
-		dump(&rb->data[rb->pread], (debug_irq & 0xFFF00) >> 8);
-
-	/*
-	   rb|====--------===[0x47]====|
-	   ^             ^
-	   wr            rd
-	 */
-
-	len1 = rb->pwrite - rb->pread;
-	if (len1 < 0) {
-		len1 = rb->size - rb->pread;
-		len2 = rb->pwrite;
-	}
-
-	for (off = 0; off < len1; off++) {
-		if (rb->data[rb->pread + off] == 0x47)
-			break;
-	}
-
-	if (off)
-		pr_dbg_irq_sf("off ->|%zd\n", off);
-
-	len1 -= off;
-	rb->pread = (rb->pread + off) % rb->size;
-
-	count = len1 / 188;
-	if (count) {
-		pr_dbg_irq_sf("pkt >> 1[%zd<->%zd]\n", rb->pread, rb->pwrite);
-		swfilter_packets(demux, rb->data + rb->pread, count);
-
-		size = count * 188;
-		len1 -= size;
-		rb->pread += size;
-	}
-
-	if (len2 && len1 && ((len1 + len2) > 188)) {
-		pr_dbg_irq_sf("pkt >> 2[%zd<->%zd]\n", rb->pread, rb->pwrite);
-		size = 188 - len1;
-		memcpy(wrapbuf, rb->data + rb->pread, len1);
-		memcpy(wrapbuf + len1, rb->data, size);
-		swfilter_packets(demux, wrapbuf, 1);
-		rb->pread = size;
-		len2 -= size;
-	}
-
-	if (len2) {
-		pr_dbg_irq_sf("pkt >> 3[%zd<->%zd]\n", rb->pread, rb->pwrite);
-		count = len2 / 188;
-		if (count) {
-			swfilter_packets(demux, rb->data + rb->pread, count);
-			rb->pread += count * 188;
-		}
-	}
-	return 0;
-}
-
-static void smallsection_match_section(struct aml_dmx *dmx, u8 *p, u16 sec_num)
-{
-	struct aml_filter *f;
-	int chid, i;
-	int need_crc = 1;
-
-	if (sec_num >= FILTER_COUNT) {
-		pr_dbg("sec_num invalid: %d\n", sec_num);
-		return;
-	}
-
-	f = &dmx->filter[sec_num];
-	chid = f->chan_id;
-
-	for (i = 0; i < FILTER_COUNT; i++) {
-		f = &dmx->filter[i];
-		if (f->chan_id != chid)
-			continue;
-		if (sec_filter_match(dmx, f, p)) {
-			if (need_crc) {
-				if (!section_crc(dmx, f, p))
-					return;
-				need_crc = 0;
-			}
-
-			section_notify(dmx, f, p);
-		}
-	}
-
-}
-static void process_smallsection(struct aml_dmx *dmx)
-{
-
-	u32 v, wr, rd;
-	u32 data32;
-	struct aml_smallsec *ss = &dmx->smallsec;
-
-	v = DMX_READ_REG(dmx->id, DEMUX_SMALL_SEC_CTL);
-	wr = (v >> 8) & 0xff;
-	rd = (v >> 16) & 0xff;
-
-	if (rd != wr) {
-		int n1 = wr - rd,
-		    n2 = 0,
-		    max = (ss->bufsize>>8);
-		int i;
-		u8 *p;
-		int sec_len;
-
-		pr_dbg_irq_ss("secbuf[31] ctrl:0x%x\n", v);
-
-		if (n1 < 0) {
-			n1 = max - rd;
-			n2 = wr;
-		}
-		if (n1) {
-			pr_dbg_irq_ss("n1:%d\n", n1);
-			dma_sync_single_for_cpu(dmx_get_dev(dmx),
-						ss->buf_map+(rd<<8),
-						n1<<8,
-						DMA_FROM_DEVICE);
-			for (i = 0; i < n1; i++) {
-				p = (u8 *)ss->buf+((rd+i)<<8);
-				sec_len = (((p[1] & 0xF) << 8) | p[2]) + 3;
-				smallsection_match_section(dmx, p,
-							*(p+sec_len+1));
-			}
-		}
-		if (n2) {
-			pr_dbg_irq_ss("n2:%d\n", n2);
-			dma_sync_single_for_cpu(dmx_get_dev(dmx),
-						ss->buf_map,
-						n2<<8,
-						DMA_FROM_DEVICE);
-			for (i = 0; i < n2; i++) {
-				p = (u8 *)ss->buf+(i<<8);
-				sec_len = (((p[1] & 0xF) << 8) | p[2]) + 3;
-				smallsection_match_section(dmx, p,
-							*(p+sec_len+1));
-			}
-		}
-
-		rd = wr;
-		data32 = (DMX_READ_REG(dmx->id,	DEMUX_SMALL_SEC_CTL)
-				& 0xff00ffff)
-				| (rd << 16);
-		DMX_WRITE_REG(dmx->id, DEMUX_SMALL_SEC_CTL, data32);
-	}
-}
-
-
-static void process_section(struct aml_dmx *dmx)
-{
-	u32 ready, i, sec_busy;
-	u16 sec_num;
-
-	/*pr_dbg("section\n"); */
-	ready = DMX_READ_REG(dmx->id, SEC_BUFF_READY);
-	if (ready) {
-#ifdef USE_AHB_MODE
-		/*      WRITE_ISA_REG(AHB_BRIDGE_CTRL1,
-		   READ_ISA_REG (AHB_BRIDGE_CTRL1) | (1 << 31)); */
-		/*      WRITE_ISA_REG(AHB_BRIDGE_CTRL1,
-		   READ_ISA_REG (AHB_BRIDGE_CTRL1) & (~ (1 << 31))); */
-#endif
-
-		if ((ready & (1<<31)) && dmx->smallsec.enable) {
-			u32 v, wr, rd;
-			v = DMX_READ_REG(dmx->id, DEMUX_SMALL_SEC_CTL);
-			wr = (v >> 8) & 0xff;
-			rd = (v >> 16) & 0xff;
-			if ((wr < rd) && (5 > (rd - wr)))
-				pr_error("warning: small ss buf [w%dr%d]\n",
-					wr, rd);
-			pr_dbg_irq_ss("ss>%x\n",
-				DMX_READ_REG(dmx->id, DEMUX_SMALL_SEC_CTL));
-			process_smallsection(dmx);
-			/*tasklet_hi_schedule(&dmx->dmx_tasklet);*/
-			/*tasklet_schedule(&dmx->dmx_tasklet);*/
-			DMX_WRITE_REG(dmx->id, SEC_BUFF_READY, (1<<31));
-			return;
-		}
-
-		for (i = 0; i < SEC_BUF_COUNT; i++) {
-
-			if (!(ready & (1 << i)))
-				continue;
-
-			/* get section busy */
-			sec_busy = DMX_READ_REG(dmx->id, SEC_BUFF_BUSY);
-			/* get filter number */
-			DMX_WRITE_REG(dmx->id, SEC_BUFF_NUMBER, i);
-			sec_num = (DMX_READ_REG(dmx->id, SEC_BUFF_NUMBER) >> 8);
-
-			/*
-			 * sec_buf_watchdog_count dispatch:
-			 * byte0 -- always busy=0 's watchdog count
-			 * byte1 -- always busy=1 & filter_num=31 's
-			 * watchdog count
-			 */
-
-			/* sec_busy is not set, check busy=0 watchdog count */
-			if (!(sec_busy & (1 << i))) {
-				/* clear other wd count	of this buffer */
-				dmx->sec_buf_watchdog_count[i] &= 0x000000ff;
-				dmx->sec_buf_watchdog_count[i] += 0x1;
-				pr_dbg("bit%d ready=1, busy=0,\n"
-					"sec_num=%d for %d times\n",
-					i, sec_num,
-					dmx->sec_buf_watchdog_count[i]);
-				if (dmx->sec_buf_watchdog_count[i] >= 5) {
-					pr_dbg("busy=0 reach the max count,\n"
-						"try software match.\n");
-					software_match_section(dmx, i);
-					dmx->sec_buf_watchdog_count[i] = 0;
-					DMX_WRITE_REG(dmx->id, SEC_BUFF_READY,
-							(1 << i));
-				}
-				continue;
-			}
-
-			/* filter_num == 31 && busy == 1,check watchdog count */
-			if (sec_num >= FILTER_COUNT) {
-				/* clear other wd count	of this buffer */
-				dmx->sec_buf_watchdog_count[i] &= 0x0000ff00;
-				dmx->sec_buf_watchdog_count[i] += 0x100;
-				pr_dbg("bit%d ready=1,busy=1,\n"
-					"sec_num=%d for %d times\n",
-					i, sec_num,
-					dmx->sec_buf_watchdog_count[i] >> 8);
-				if (dmx->sec_buf_watchdog_count[i] >= 0x500) {
-					pr_dbg("busy=1&filter_num=31\n"
-					" reach the max count, clear\n"
-					" the buf ready & busy!\n");
-					software_match_section(dmx, i);
-					dmx->sec_buf_watchdog_count[i] = 0;
-					DMX_WRITE_REG(dmx->id,
-						      SEC_BUFF_READY,
-						      (1 << i));
-					DMX_WRITE_REG(dmx->id,
-						      SEC_BUFF_BUSY,
-						      (1 << i));
-				}
-				continue;
-			}
-
-			/* now, ready & busy are both set and
-			 filter number is valid */
-			if (dmx->sec_buf_watchdog_count[i] != 0)
-				dmx->sec_buf_watchdog_count[i] = 0;
-
-			/* process this section */
-			hardware_match_section(dmx, sec_num, i);
-
-			/* clear the ready & busy bit */
-			DMX_WRITE_REG(dmx->id, SEC_BUFF_READY, (1 << i));
-			DMX_WRITE_REG(dmx->id, SEC_BUFF_BUSY, (1 << i));
-		}
-	}
-}
-
-#ifdef NO_SUB
-static void process_sub(struct aml_dmx *dmx)
-{
-
-	u32 rd_ptr = 0;
-
-	u32 wr_ptr = READ_MPEG_REG(PARSER_SUB_WP);
-	u32 start_ptr = READ_MPEG_REG(PARSER_SUB_START_PTR);
-	u32 end_ptr = READ_MPEG_REG(PARSER_SUB_END_PTR);
-
-	u32 buffer1 = 0, buffer2 = 0;
-	unsigned char *buffer1_virt = 0, *buffer2_virt = 0;
-	u32 len1 = 0, len2 = 0;
-
-	rd_ptr = READ_MPEG_REG(PARSER_SUB_RP);
-	if (!rd_ptr)
-		return;
-	if (rd_ptr > wr_ptr) {
-		len1 = end_ptr - rd_ptr + 8;
-		buffer1 = rd_ptr;
-
-		len2 = wr_ptr - start_ptr;
-		buffer2 = start_ptr;
-
-		rd_ptr = start_ptr + len2;
-	} else if (rd_ptr < wr_ptr) {
-		len1 = wr_ptr - rd_ptr;
-		buffer1 = rd_ptr;
-		rd_ptr += len1;
-		len2 = 0;
-	} else if (rd_ptr == wr_ptr) {
-		pr_dbg("no data\n");
-	}
-
-	if (buffer1)
-		buffer1_virt = phys_to_virt(buffer1);
-	if (buffer2)
-		buffer2_virt = phys_to_virt(buffer2);
-
-	if (len1)
-		dma_sync_single_for_cpu(dmx_get_dev(dmx),
-					(dma_addr_t) buffer1, len1,
-					DMA_FROM_DEVICE);
-	if (len2)
-		dma_sync_single_for_cpu(dmx_get_dev(dmx),
-					(dma_addr_t) buffer2, len2,
-					DMA_FROM_DEVICE);
-
-	if (dmx->channel[2].used) {
-		if (dmx->channel[2].feed && dmx->channel[2].feed->cb.ts) {
-			dmx->channel[2].feed->cb.ts(buffer1_virt, len1,
-						buffer2_virt, len2,
-						&dmx->channel[2].feed->feed.ts,
-						DMX_OK);
-		}
-	}
-	WRITE_MPEG_REG(PARSER_SUB_RP, rd_ptr);
-}
-#endif
-
-static void process_pes(struct aml_dmx *dmx)
-{
-}
-
-static void process_om_read(struct aml_dmx *dmx)
-{
-	unsigned i;
-	unsigned short om_cmd_status_data_0 = 0;
-	unsigned short om_cmd_status_data_1 = 0;
-/*      unsigned short om_cmd_status_data_2 = 0;*/
-	unsigned short om_cmd_data_out = 0;
-
-	om_cmd_status_data_0 = DMX_READ_REG(dmx->id, OM_CMD_STATUS);
-	om_cmd_status_data_1 = DMX_READ_REG(dmx->id, OM_CMD_DATA);
-/*      om_cmd_status_data_2 = DMX_READ_REG(dmx->id, OM_CMD_DATA2);*/
-
-	if (om_cmd_status_data_0 & 1) {
-		DMX_WRITE_REG(dmx->id, OM_DATA_RD_ADDR,
-			(1 << 15) | ((om_cmd_status_data_1 & 0xff) << 2));
-		for (i = 0; i < (((om_cmd_status_data_1 >> 7) & 0x1fc) >> 1);
-		     i++) {
-			om_cmd_data_out = DMX_READ_REG(dmx->id, OM_DATA_RD);
-		}
-
-		om_cmd_data_out = DMX_READ_REG(dmx->id, OM_DATA_RD_ADDR);
-		DMX_WRITE_REG(dmx->id, OM_DATA_RD_ADDR, 0);
-		DMX_WRITE_REG(dmx->id, OM_CMD_STATUS, 1);
-	}
-}
-
-static void dmx_irq_bh_handler(unsigned long arg)
-{
-	struct aml_dmx *dmx = (struct aml_dmx *)arg;
-#if 0
-	u32 status;
-
-	status = DMX_READ_REG(dmx->id, STB_INT_STATUS);
-
-	if (status)
-		DMX_WRITE_REG(dmx->id, STB_INT_STATUS, status);
-#endif
-	process_smallsection(dmx);
-	return;
-}
-
-static irqreturn_t dmx_irq_handler(int irq_number, void *para)
-{
-	struct aml_dmx *dmx = (struct aml_dmx *)para;
-	struct aml_dvb *dvb = aml_get_dvb_device();
-	u32 status;
-	unsigned long flags;
-
-	spin_lock_irqsave(&dvb->slock, flags);
-	status = DMX_READ_REG(dmx->id, STB_INT_STATUS);
-	if (!status)
-		goto irq_handled;
-
-	pr_dbg_irq("demux %d irq status: 0x08%x\n", dmx->id, status);
-
-	if (status & (1 << SECTION_BUFFER_READY))
-		process_section(dmx);
-#ifdef NO_SUB
-	if (status & (1 << SUB_PES_READY)) {
-		/*If the subtitle is set by tsdemux,
-		do not parser in demux driver. */
-		if (dmx->sub_chan == -1)
-			process_sub(dmx);
-	}
-#endif
-	if (status & (1 << OTHER_PES_READY))
-		process_pes(dmx);
-	if (status & (1 << OM_CMD_READ_PENDING))
-		process_om_read(dmx);
-	/*
-	if (status & (1 << DUPLICATED_PACKET)) {
-	}
-	if (status & (1 << DIS_CONTINUITY_PACKET)) {
-	}
-	if (status & (1 << VIDEO_SPLICING_POINT)) {
-	}
-	if (status & (1 << AUDIO_SPLICING_POINT)) {
-	}
-	if (status & (1 << TS_ERROR_PIN)) {
-		pr_error("TS_ERROR_PIN\n");
-	}*/
-
-	if (status & (1 << NEW_PDTS_READY)) {
-		u32 pdts_status = DMX_READ_REG(dmx->id, STB_PTS_DTS_STATUS);
-
-		if (pdts_status & (1 << VIDEO_PTS_READY)) {
-			video_pts = DMX_READ_REG(dmx->id, VIDEO_PTS_DEMUX);
-			if (!first_video_pts
-			    || 0 > (int)(video_pts - first_video_pts))
-				first_video_pts = video_pts;
-		}
-
-		if (pdts_status & (1 << AUDIO_PTS_READY)) {
-			audio_pts = DMX_READ_REG(dmx->id, AUDIO_PTS_DEMUX);
-			if (!first_audio_pts
-			    || 0 > (int)(audio_pts - first_audio_pts))
-				first_audio_pts = audio_pts;
-		}
-	}
-
-	if (dmx->irq_handler)
-		dmx->irq_handler(dmx->dmx_irq, (void *)(long)dmx->id);
-
-	DMX_WRITE_REG(dmx->id, STB_INT_STATUS, status);
-
-	/*tasklet_schedule(&dmx->dmx_tasklet);*/
-
-	{
-		if (!dmx->int_check_time) {
-			dmx->int_check_time = jiffies;
-			dmx->int_check_count = 0;
-		}
-
-		if (jiffies_to_msecs(jiffies - dmx->int_check_time) >= 100
-		    || dmx->int_check_count > 1000) {
-			if (dmx->int_check_count > 1000) {
-				struct aml_dvb *dvb =
-				    (struct aml_dvb *)dmx->demux.priv;
-				pr_error("Too many interrupts "
-					"(%d interrupts in %d ms)!\n",
-					dmx->int_check_count,
-					jiffies_to_msecs(jiffies -
-						      dmx->int_check_time));
-				if (dmx->fe && !dmx->in_tune) {
-					DMX_WRITE_REG(dmx->id, STB_INT_MASK, 0);
-					dvb_frontend_retune(dmx->fe);
-				}
-				dmx_reset_hw_ex(dvb, 0);
-			}
-			dmx->int_check_time = 0;
-		}
-
-		dmx->int_check_count++;
-
-		if (dmx->in_tune) {
-			dmx->error_check++;
-			if (dmx->error_check > 200)
-				DMX_WRITE_REG(dmx->id, STB_INT_MASK, 0);
-		}
-	}
-
-irq_handled:
-	spin_unlock_irqrestore(&dvb->slock, flags);
-	return IRQ_HANDLED;
-}
-
-static inline int dmx_get_order(unsigned long size)
-{
-	int order;
-
-	order = -1;
-	do {
-		size >>= 1;
-		order++;
-	} while (size);
-
-	return order;
-}
-
-static void dvr_process_channel(struct aml_asyncfifo *afifo,
-				struct aml_channel *channel,
-				u32 total, u32 size,
-				struct aml_swfilter *sf)
-{
-	int cnt;
-	int ret = 0;
-
-	if (afifo->buf_read > afifo->buf_toggle) {
-		cnt = total - afifo->buf_read;
-		dma_sync_single_for_cpu(asyncfifo_get_dev(afifo),
-				afifo->pages_map+afifo->buf_read*size,
-				cnt*size,
-				DMA_FROM_DEVICE);
-		if (sf)
-			ret = _rbuf_write(&sf->rbuf,
-					(u8 *)afifo->pages+afifo->buf_read*size,
-					cnt*size);
-		else
-			channel->dvr_feed->cb.ts(
-					(u8 *)afifo->pages+afifo->buf_read*size,
-					cnt*size, NULL, 0,
-					&channel->dvr_feed->feed.ts, DMX_OK);
-		afifo->buf_read = 0;
-	}
-
-	if (afifo->buf_toggle > afifo->buf_read) {
-		cnt = afifo->buf_toggle - afifo->buf_read;
-		dma_sync_single_for_cpu(asyncfifo_get_dev(afifo),
-				afifo->pages_map+afifo->buf_read*size,
-				cnt*size,
-				DMA_FROM_DEVICE);
-		if (sf) {
-			if (ret >= 0)
-				ret = _rbuf_write(&sf->rbuf,
-					(u8 *)afifo->pages+afifo->buf_read*size,
-					cnt*size);
-		} else
-			channel->dvr_feed->cb.ts(
-					(u8 *)afifo->pages+afifo->buf_read*size,
-					cnt*size, NULL, 0,
-					&channel->dvr_feed->feed.ts, DMX_OK);
-		afifo->buf_read = afifo->buf_toggle;
-	}
-
-	if (sf && ret > 0) {
-		_rbuf_filter_pkts(&sf->rbuf, sf->wrapbuf,
-				dvb_dmx_swfilter_packets,
-				channel->dvr_feed->demux);
-	} else if (sf && ret <= 0)
-		pr_error("sf rbuf write error[%d]\n", ret);
-	else
-		pr_dbg_irq_dvr("write data to dvr\n");
-}
-
-static void dvr_irq_bh_handler(unsigned long arg)
-{
-	struct aml_asyncfifo *afifo = (struct aml_asyncfifo *)arg;
-	struct aml_dvb *dvb = afifo->dvb;
-	struct aml_dmx *dmx;
-	u32 size, total;
-	int i, factor;
-	unsigned long flags;
-
-	pr_dbg_irq_dvr("async fifo %d irq\n", afifo->id);
-
-	spin_lock_irqsave(&dvb->slock, flags);
-
-	if (dvb && afifo->source >= AM_DMX_0 && afifo->source < AM_DMX_MAX) {
-		dmx = &dvb->dmx[afifo->source];
-		if (dmx->init && dmx->record) {
-			struct aml_swfilter *sf = &dvb->swfilter;
-			int issf = 0;
-
-			total = afifo->buf_len / afifo->flush_size;
-			factor = dmx_get_order(total);
-			size = afifo->buf_len >> factor;
-
-			if (sf->user && (sf->afifo == afifo))
-				issf = 1;
-
-			for (i = 0; i < CHANNEL_COUNT; i++) {
-				if (dmx->channel[i].used
-						&& dmx->channel[i].dvr_feed) {
-					dvr_process_channel(afifo,
-							&dmx->channel[i],
-							total,
-							size,
-							issf?sf:NULL);
-				    break;
-				}
-			}
-
-		}
-	}
-	spin_unlock_irqrestore(&dvb->slock, flags);
-	return;
-}
-
-static irqreturn_t dvr_irq_handler(int irq_number, void *para)
-{
-	struct aml_asyncfifo *afifo = (struct aml_asyncfifo *)para;
-	int factor = dmx_get_order(afifo->buf_len / afifo->flush_size);
-
-	afifo->buf_toggle++;
-	afifo->buf_toggle %= (1 << factor);
-	tasklet_schedule(&afifo->asyncfifo_tasklet);
-	return IRQ_HANDLED;
-}
-
-/*Enable the STB*/
-static void stb_enable(struct aml_dvb *dvb)
-{
-	int out_src, des_in, en_des, fec_clk, hiu, dec_clk_en;
-	int src, tso_src, i;
-	u32 fec_s0, fec_s1;
-	u32 invert0, invert1;
-
-	switch (dvb->stb_source) {
-	case AM_TS_SRC_DMX0:
-		src = dvb->dmx[0].source;
-		break;
-	case AM_TS_SRC_DMX1:
-		src = dvb->dmx[1].source;
-		break;
-	case AM_TS_SRC_DMX2:
-		src = dvb->dmx[2].source;
-		break;
-	default:
-		src = dvb->stb_source;
-		break;
-	}
-
-	switch (src) {
-	case AM_TS_SRC_TS0:
-		fec_clk = tsfile_clkdiv;
-		hiu = 0;
-		break;
-	case AM_TS_SRC_TS1:
-		fec_clk = tsfile_clkdiv;
-		hiu = 0;
-		break;
-	case AM_TS_SRC_TS2:
-		fec_clk = tsfile_clkdiv;
-		hiu = 0;
-		break;
-	case AM_TS_SRC_S_TS0:
-		fec_clk = tsfile_clkdiv;
-		hiu = 0;
-		break;
-	case AM_TS_SRC_S_TS1:
-		fec_clk = tsfile_clkdiv;
-		hiu = 0;
-		break;
-	case AM_TS_SRC_S_TS2:
-		fec_clk = tsfile_clkdiv;
-		hiu = 0;
-		break;
-	case AM_TS_SRC_HIU:
-		fec_clk = tsfile_clkdiv;
-		hiu = 1;
-		break;
-	default:
-		fec_clk = 0;
-		hiu = 0;
-		break;
-	}
-
-	switch (dvb->dsc[0].source) {
-	case AM_TS_SRC_DMX0:
-		des_in = 0;
-		en_des = 1;
-		dec_clk_en = 1;
-		break;
-	case AM_TS_SRC_DMX1:
-		des_in = 1;
-		en_des = 1;
-		dec_clk_en = 1;
-		break;
-	case AM_TS_SRC_DMX2:
-		des_in = 2;
-		en_des = 1;
-		dec_clk_en = 1;
-		break;
-	default:
-		des_in = 0;
-		en_des = 0;
-		dec_clk_en = 0;
-		break;
-	}
-
-	switch (dvb->tso_source) {
-	case AM_TS_SRC_DMX0:
-		tso_src = dvb->dmx[0].source;
-		break;
-	case AM_TS_SRC_DMX1:
-		tso_src = dvb->dmx[1].source;
-		break;
-	case AM_TS_SRC_DMX2:
-		tso_src = dvb->dmx[2].source;
-		break;
-	default:
-		tso_src = dvb->tso_source;
-		break;
-	}
-
-	switch (tso_src) {
-	case AM_TS_SRC_TS0:
-		out_src = 0;
-		break;
-	case AM_TS_SRC_TS1:
-		out_src = 1;
-		break;
-	case AM_TS_SRC_TS2:
-		out_src = 2;
-		break;
-	case AM_TS_SRC_S_TS0:
-	case AM_TS_SRC_S_TS1:
-	case AM_TS_SRC_S_TS2:
-		out_src = 6;
-		break;
-	case AM_TS_SRC_HIU:
-		out_src = 7;
-		break;
-	default:
-		out_src = 0;
-		break;
-	}
-
-	pr_dbg("[stb]src: %d, dsc1in: %d, tso: %d\n", src, des_in, out_src);
-
-	fec_s0 = 0;
-	fec_s1 = 0;
-	invert0 = 0;
-	invert1 = 0;
-
-	for (i = 0; i < TS_IN_COUNT; i++) {
-		if (dvb->ts[i].s2p_id == 0)
-			fec_s0 = i;
-		else if (dvb->ts[i].s2p_id == 1)
-			fec_s1 = i;
-	}
-
-	invert0 = dvb->s2p[0].invert;
-	invert1 = dvb->s2p[1].invert;
-
-	WRITE_MPEG_REG(STB_TOP_CONFIG,
-		       (invert1 << INVERT_S2P1_FEC_CLK) |
-		       (fec_s1 << S2P1_FEC_SERIAL_SEL) |
-		       (out_src << TS_OUTPUT_SOURCE) |
-		       (des_in << DES_INPUT_SEL) |
-		       (en_des << ENABLE_DES_PL) |
-		       (dec_clk_en << ENABLE_DES_PL_CLK) |
-		       (invert0 << INVERT_S2P0_FEC_CLK) |
-		       (fec_s0 << S2P0_FEC_SERIAL_SEL));
-
-	if (dvb->reset_flag)
-		hiu = 0;
-
-	WRITE_MPEG_REG(TS_FILE_CONFIG,
-		       (demux_skipbyte << 16) |
-		       (6 << DES_OUT_DLY) |
-		       (3 << TRANSPORT_SCRAMBLING_CONTROL_ODD) |
-		       (3 << TRANSPORT_SCRAMBLING_CONTROL_ODD_2) |
-		       (hiu << TS_HIU_ENABLE) | (fec_clk << FEC_FILE_CLK_DIV));
-}
-
-int dsc_set_pid(struct aml_dsc_channel *ch, int pid)
-{
-	struct aml_dsc *dsc = ch->dsc;
-	int is_dsc2 = (dsc->id == 1) ? 1 : 0;
-	u32 data;
-
-	WRITE_MPEG_REG(TS_PL_PID_INDEX,
-			((ch->id & 0x0f) >> 1)+(is_dsc2 ? 4 : 0));
-	data = READ_MPEG_REG(TS_PL_PID_DATA);
-	if (ch->id & 1) {
-		data &= 0xFFFF0000;
-		data |= pid & 0x1fff;
-		if (!ch->used)
-			data |= 1 << PID_MATCH_DISABLE_LOW;
-	} else {
-		data &= 0xFFFF;
-		data |= (pid & 0x1fff) << 16;
-		if (!ch->used)
-			data |= 1 << PID_MATCH_DISABLE_HIGH;
-	}
-	WRITE_MPEG_REG(TS_PL_PID_INDEX,
-			((ch->id & 0x0f) >> 1)+(is_dsc2 ? 4 : 0));
-	WRITE_MPEG_REG(TS_PL_PID_DATA, data);
-	WRITE_MPEG_REG(TS_PL_PID_INDEX, 0);
-
-	if (ch->used)
-		pr_dbg("set DSC %d ch %d PID %d\n", dsc->id, ch->id, pid);
-	else
-		pr_dbg("disable DSC %d ch %d\n", dsc->id, ch->id);
-	return 0;
-}
-
-int dsc_set_key(struct aml_dsc_channel *ch, int type, u8 *key)
-{
-	struct aml_dsc *dsc = ch->dsc;
-	int is_dsc2 = (dsc->id == 1) ? 1 : 0;
-	u16 k0, k1, k2, k3;
-	u32 key0, key1;
-
-	k0 = (key[0] << 8) | key[1];
-	k1 = (key[2] << 8) | key[3];
-	k2 = (key[4] << 8) | key[5];
-	k3 = (key[6] << 8) | key[7];
-
-	key0 = (k0 << 16) | k1;
-	key1 = (k2 << 16) | k3;
-	WRITE_MPEG_REG(COMM_DESC_KEY0, key0);
-	WRITE_MPEG_REG(COMM_DESC_KEY1, key1);
-	WRITE_MPEG_REG(COMM_DESC_KEY_RW,
-			(ch->id + type * DSC_COUNT)+(is_dsc2 ? 16 : 0));
-
-	pr_dbg("set DSC %d ch %d type %d key %04x %04x %04x %04x\n",
-		dsc->id, ch->id, type, k0, k1, k2, k3);
-	return 0;
-}
-
-int dsc_enable(struct aml_dsc *dsc, int enable)
-{
-	if (dsc->id == 0) {
-		WRITE_MPEG_REG(STB_TOP_CONFIG,
-			READ_MPEG_REG(STB_TOP_CONFIG) &
-				~((0x11 << DES_INPUT_SEL)|
-				(1 << ENABLE_DES_PL)|
-				(1 << ENABLE_DES_PL_CLK)));
-	} else if (dsc->id == 1) {
-		WRITE_MPEG_REG(COMM_DESC_2_CTL,	0);
-	}
-	return 0;
-}
-
-/*Set section buffer*/
-static int dmx_alloc_sec_buffer(struct aml_dmx *dmx)
-{
-	unsigned long base;
-	unsigned long grp_addr[SEC_BUF_GRP_COUNT];
-	int grp_len[SEC_BUF_GRP_COUNT];
-	int i;
-
-	if (dmx->sec_pages)
-		return 0;
-
-	grp_len[0] = (1 << SEC_GRP_LEN_0) * 8;
-	grp_len[1] = (1 << SEC_GRP_LEN_1) * 8;
-	grp_len[2] = (1 << SEC_GRP_LEN_2) * 8;
-	grp_len[3] = (1 << SEC_GRP_LEN_3) * 8;
-
-	dmx->sec_total_len = grp_len[0] + grp_len[1] + grp_len[2] + grp_len[3];
-	dmx->sec_pages =
-	    __get_free_pages(GFP_KERNEL, get_order(dmx->sec_total_len));
-	if (!dmx->sec_pages) {
-		pr_error("cannot allocate section buffer %d bytes %d order\n",
-			 dmx->sec_total_len, get_order(dmx->sec_total_len));
-		return -1;
-	}
-	dmx->sec_pages_map =
-	    dma_map_single(dmx_get_dev(dmx), (void *)dmx->sec_pages,
-					 dmx->sec_total_len, DMA_FROM_DEVICE);
-
-	grp_addr[0] = dmx->sec_pages_map;
-
-	grp_addr[1] = grp_addr[0] + grp_len[0];
-	grp_addr[2] = grp_addr[1] + grp_len[1];
-	grp_addr[3] = grp_addr[2] + grp_len[2];
-
-	dmx->sec_buf[0].addr = dmx->sec_pages;
-	dmx->sec_buf[0].len = grp_len[0] / 8;
-
-	for (i = 1; i < SEC_BUF_COUNT; i++) {
-		dmx->sec_buf[i].addr =
-		    dmx->sec_buf[i - 1].addr + dmx->sec_buf[i - 1].len;
-		dmx->sec_buf[i].len = grp_len[i / 8] / 8;
-	}
-
-	base = grp_addr[0] & 0xFFFF0000;
-	DMX_WRITE_REG(dmx->id, SEC_BUFF_BASE, base >> 16);
-	DMX_WRITE_REG(dmx->id, SEC_BUFF_01_START,
-		      (((grp_addr[0] - base) >> 8) << 16) |
-		       ((grp_addr[1] - base) >> 8));
-	DMX_WRITE_REG(dmx->id, SEC_BUFF_23_START,
-		      (((grp_addr[2] - base) >> 8) << 16) |
-		       ((grp_addr[3] - base) >> 8));
-	DMX_WRITE_REG(dmx->id, SEC_BUFF_SIZE,
-			SEC_GRP_LEN_0 |
-			(SEC_GRP_LEN_1 << 4) |
-			(SEC_GRP_LEN_2 << 8) |
-			(SEC_GRP_LEN_3 << 12));
-
-	return 0;
-}
-
-#ifdef NO_SUB
-/*Set subtitle buffer*/
-static int dmx_alloc_sub_buffer(struct aml_dmx *dmx)
-{
-	unsigned long addr;
-
-	if (dmx->sub_pages)
-		return 0;
-
-	dmx->sub_buf_len = 64 * 1024;
-	dmx->sub_pages =
-	    __get_free_pages(GFP_KERNEL, get_order(dmx->sub_buf_len));
-	if (!dmx->sub_pages) {
-		pr_error("cannot allocate subtitle buffer\n");
-		return -1;
-	}
-	dmx->sub_pages_map =
-	    dma_map_single(dmx_get_dev(dmx), (void *)dmx->sub_pages,
-					dmx->sub_buf_len, DMA_FROM_DEVICE);
-
-	addr = virt_to_phys((void *)dmx->sub_pages);
-	DMX_WRITE_REG(dmx->id, SB_START, addr >> 12);
-	DMX_WRITE_REG(dmx->id, SB_LAST_ADDR, (dmx->sub_buf_len >> 3) - 1);
-	return 0;
-}
-#endif /*NO_SUB */
-
-/*Set PES buffer*/
-static int dmx_alloc_pes_buffer(struct aml_dmx *dmx)
-{
-	unsigned long addr;
-
-	if (dmx->pes_pages)
-		return 0;
-
-	dmx->pes_buf_len = 64 * 1024;
-	dmx->pes_pages =
-	    __get_free_pages(GFP_KERNEL, get_order(dmx->pes_buf_len));
-	if (!dmx->pes_pages) {
-		pr_error("cannot allocate pes buffer\n");
-		return -1;
-	}
-	dmx->pes_pages_map =
-	    dma_map_single(dmx_get_dev(dmx), (void *)dmx->pes_pages,
-					dmx->pes_buf_len, DMA_FROM_DEVICE);
-
-	addr = virt_to_phys((void *)dmx->pes_pages);
-	DMX_WRITE_REG(dmx->id, OB_START, addr >> 12);
-	DMX_WRITE_REG(dmx->id, OB_LAST_ADDR, (dmx->pes_buf_len >> 3) - 1);
-	return 0;
-}
-
-/*Allocate ASYNC FIFO Buffer*/
-static unsigned long asyncfifo_alloc_buffer(int len)
-{
-	unsigned long pages = __get_free_pages(GFP_KERNEL, get_order(len));
-	if (!pages) {
-		pr_error("cannot allocate async fifo buffer\n");
-		return 0;
-	}
-	return pages;
-}
-static void asyncfifo_free_buffer(unsigned long buf, int len)
-{
-	free_pages(buf, get_order(len));
-}
-
-static int asyncfifo_set_buffer(struct aml_asyncfifo *afifo,
-					int len, unsigned long buf)
-{
-	if (afifo->pages)
-		return -1;
-
-	afifo->buf_toggle = 0;
-	afifo->buf_read   = 0;
-	afifo->buf_len = len;
-	pr_error("async fifo %d buf size %d, flush size %d\n",
-			afifo->id, afifo->buf_len, afifo->flush_size);
-
-	if (afifo->flush_size <= 0)
-		afifo->flush_size = afifo->buf_len>>1;
-
-	afifo->pages = buf;
-	if (!afifo->pages)
-		return -1;
-
-	afifo->pages_map = dma_map_single(asyncfifo_get_dev(afifo),
-			(void *)afifo->pages, afifo->buf_len, DMA_FROM_DEVICE);
-
-	return 0;
-}
-static void asyncfifo_put_buffer(struct aml_asyncfifo *afifo)
-{
-	if (afifo->pages) {
-		dma_unmap_single(asyncfifo_get_dev(afifo),
-			afifo->pages_map, afifo->buf_len, DMA_FROM_DEVICE);
-		asyncfifo_free_buffer(afifo->pages, afifo->buf_len);
-		afifo->pages_map = 0;
-		afifo->pages = 0;
-	}
-}
-
-int async_fifo_init(struct aml_asyncfifo *afifo, int initirq,
-			int buf_len, unsigned long buf)
-{
-	int ret = 0;
-	int irq;
-
-	if (afifo->init)
-		return -1;
-
-	afifo->source  = AM_DMX_MAX;
-	afifo->pages = 0;
-	afifo->buf_toggle = 0;
-	afifo->buf_read = 0;
-	afifo->buf_len = 0;
-
-	if (afifo->asyncfifo_irq == -1) {
-		pr_error("no irq for ASYNC_FIFO%d\n", afifo->id);
-		/*Do not return error*/
-		return -1;
-	}
-
-	tasklet_init(&afifo->asyncfifo_tasklet,
-			dvr_irq_bh_handler, (unsigned long)afifo);
-	if (initirq)
-		irq = request_irq(afifo->asyncfifo_irq,	dvr_irq_handler,
-				IRQF_SHARED|IRQF_TRIGGER_RISING,
-				"dvr irq", afifo);
-	else
-		enable_irq(afifo->asyncfifo_irq);
-
-	/*alloc buffer*/
-	ret = asyncfifo_set_buffer(afifo, buf_len, buf);
-
-	afifo->init = 1;
-
-	return ret;
-}
-
-int async_fifo_deinit(struct aml_asyncfifo *afifo, int freeirq)
-{
-	if (!afifo->init)
-		return 0;
-
-	CLEAR_ASYNC_FIFO_REG_MASK(afifo->id, REG1, 1 << ASYNC_FIFO_FLUSH_EN);
-	CLEAR_ASYNC_FIFO_REG_MASK(afifo->id, REG2, 1 << ASYNC_FIFO_FILL_EN);
-
-	asyncfifo_put_buffer(afifo);
-
-	afifo->source  = AM_DMX_MAX;
-	afifo->buf_toggle = 0;
-	afifo->buf_read = 0;
-	afifo->buf_len = 0;
-
-	if (afifo->asyncfifo_irq != -1) {
-		if (freeirq)
-			free_irq(afifo->asyncfifo_irq, afifo);
-		else
-			disable_irq(afifo->asyncfifo_irq);
-	}
-	tasklet_kill(&afifo->asyncfifo_tasklet);
-
-	afifo->init = 0;
-
-	return 0;
-}
-
-static int _dmx_smallsec_enable(struct aml_smallsec *ss, int bufsize)
-{
-	if (!ss->buf) {
-
-		ss->buf = __get_free_pages(GFP_KERNEL,
-					get_order(bufsize));
-		if (!ss->buf) {
-			pr_error("cannot allocate smallsec buffer\n"
-				"%d bytes %d order\n",
-				 bufsize, get_order(bufsize));
-			return -1;
-		}
-		ss->buf_map = dma_map_single(dmx_get_dev(ss->dmx),
-						(void *)ss->buf,
-						 bufsize, DMA_FROM_DEVICE);
-	}
-
-	DMX_WRITE_REG(ss->dmx->id, DEMUX_SMALL_SEC_ADDR,
-				ss->buf_map);
-	DMX_WRITE_REG(ss->dmx->id, DEMUX_SMALL_SEC_CTL,
-				((((bufsize>>8)-1)&0xff)<<24) |
-				(1<<1) |/*enable reset the wr ptr*/
-				(1<<0));
-
-	ss->bufsize = bufsize;
-	ss->enable = 1;
-
-	pr_inf("demux%d smallsec buf start: %lx, size: %d\n",
-		ss->dmx->id, ss->buf, ss->bufsize);
-	return 0;
-}
-
-static int _dmx_smallsec_disable(struct aml_smallsec *ss)
-{
-	DMX_WRITE_REG(ss->dmx->id, DEMUX_SMALL_SEC_CTL, 0);
-	if (ss->buf) {
-		dma_unmap_single(dmx_get_dev(ss->dmx), ss->buf_map,
-				ss->bufsize, DMA_FROM_DEVICE);
-		free_pages(ss->buf, get_order(ss->bufsize));
-		ss->buf = 0;
-		ss->buf_map = 0;
-	}
-	ss->enable = 0;
-	pr_inf("demux%d smallsec buf disable\n", ss->dmx->id);
-	return 0;
-}
-
-static int dmx_smallsec_set(struct aml_smallsec *ss, int enable, int bufsize,
-				int force)
-{
-	if (!enable) {/*disable*/
-
-		if (ss->enable || force)
-			_dmx_smallsec_disable(ss);
-
-	} else {/*enable*/
-
-		if (bufsize < 0)
-			bufsize = SS_BUFSIZE_DEF;
-		else if (!bufsize)
-			bufsize = ss->bufsize;
-		else {
-			/*unit:FF max:FF00*/
-			bufsize &= ~0xFF;
-			bufsize &= 0x1FF00;
-		}
-
-		if ((ss->enable && (bufsize != ss->bufsize)) || force)
-			_dmx_smallsec_disable(ss);
-
-		if (!ss->enable)
-			_dmx_smallsec_enable(ss, bufsize);
-	}
-
-	return 0;
-}
-
-static int _dmx_timeout_enable(struct aml_dmxtimeout *dto, int timeout,
-						int ch_dis, int match)
-{
-
-	DMX_WRITE_REG(dto->dmx->id, DEMUX_INPUT_TIMEOUT_C, ch_dis);
-	DMX_WRITE_REG(dto->dmx->id, DEMUX_INPUT_TIMEOUT,
-				((!!match)<<31) |
-				(timeout&0x7fffffff));
-
-	dto->ch_disable = ch_dis;
-	dto->match = match;
-	dto->timeout = timeout;
-	dto->trigger = 0;
-	dto->enable = 1;
-
-	pr_inf("demux%d timeout enable:timeout(%d),ch(0x%x),match(%d)\n",
-		dto->dmx->id, dto->timeout, dto->ch_disable, dto->match);
-
-	return 0;
-}
-static int _dmx_timeout_disable(struct aml_dmxtimeout *dto)
-{
-
-	DMX_WRITE_REG(dto->dmx->id, DEMUX_INPUT_TIMEOUT, 0);
-	dto->enable = 0;
-	dto->trigger = 0;
-	pr_inf("demux%d timeout disable\n", dto->dmx->id);
-
-	return 0;
-}
-
-static int dmx_timeout_set(struct aml_dmxtimeout *dto, int enable,
-				int timeout, int ch_dis, int match,
-				int force)
-{
-
-	if (!enable) {/*disable*/
-
-		if (dto->enable || force)
-			_dmx_timeout_disable(dto);
-
-	} else {/*enable*/
-
-		if (timeout < 0) {
-			timeout = DTO_TIMEOUT_DEF;
-			ch_dis = DTO_CHDIS_VAS;
-			match = dto->match;
-		} else if (!timeout) {
-			timeout = dto->timeout;
-			ch_dis = dto->ch_disable;
-			match = dto->match;
-		}
-
-		if ((dto->enable && (timeout != dto->timeout))
-			|| force)
-			_dmx_timeout_disable(dto);
-
-		if (!dto->enable)
-			_dmx_timeout_enable(dto, timeout, ch_dis, match);
-	}
-
-	return 0;
-}
-
-/*Initalize the registers*/
-static int dmx_init(struct aml_dmx *dmx)
-{
-	struct aml_dvb *dvb = (struct aml_dvb *)dmx->demux.priv;
-	int irq;
-
-	if (dmx->init)
-		return 0;
-
-	pr_inf("demux init\n");
-
-	/*Register irq handlers */
-	if (dmx->dmx_irq != -1) {
-		pr_dbg("request irq\n");
-		tasklet_init(&dmx->dmx_tasklet,
-				dmx_irq_bh_handler,
-				(unsigned long)dmx);
-		irq = request_irq(dmx->dmx_irq,	dmx_irq_handler,
-				IRQF_SHARED|IRQF_TRIGGER_RISING,
-				"dmx irq", dmx);
-	}
-
-	/*Allocate buffer */
-	if (dmx_alloc_sec_buffer(dmx) < 0)
-		return -1;
-#ifdef NO_SUB
-	if (dmx_alloc_sub_buffer(dmx) < 0)
-		return -1;
-#endif
-	if (dmx_alloc_pes_buffer(dmx) < 0)
-		return -1;
-
-	/*Reset the hardware */
-	if (!dvb->dmx_init) {
-		init_timer(&dvb->watchdog_timer);
-		dvb->watchdog_timer.function = section_buffer_watchdog_func;
-		dvb->watchdog_timer.expires =
-		    jiffies + msecs_to_jiffies(WATCHDOG_TIMER);
-		dvb->watchdog_timer.data = (unsigned long)dvb;
-#ifdef ENABLE_SEC_BUFF_WATCHDOG
-		add_timer(&dvb->watchdog_timer);
-#endif
-		dmx_reset_hw(dvb);
-	}
-
-	dvb->dmx_init++;
-
-	memset(dmx->sec_buf_watchdog_count, 0,
-	       sizeof(dmx->sec_buf_watchdog_count));
-
-	dmx->init = 1;
-
-	return 0;
-}
-
-/*Release the resource*/
-static int dmx_deinit(struct aml_dmx *dmx)
-{
-	struct aml_dvb *dvb = (struct aml_dvb *)dmx->demux.priv;
-
-	if (!dmx->init)
-		return 0;
-
-	DMX_WRITE_REG(dmx->id, DEMUX_CONTROL, 0);
-
-	dvb->dmx_init--;
-
-	/*Reset the hardware */
-	if (!dvb->dmx_init) {
-		dmx_reset_hw(dvb);
-#ifdef ENABLE_SEC_BUFF_WATCHDOG
-		del_timer_sync(&dvb->watchdog_timer);
-#endif
-	}
-
-	if (dmx->sec_pages) {
-		dma_unmap_single(dmx_get_dev(dmx), dmx->sec_pages_map,
-				dmx->sec_total_len, DMA_FROM_DEVICE);
-		free_pages(dmx->sec_pages, get_order(dmx->sec_total_len));
-		dmx->sec_pages = 0;
-		dmx->sec_pages_map = 0;
-	}
-#ifdef NO_SUB
-	if (dmx->sub_pages) {
-		dma_unmap_single(dmx_get_dev(dmx), dmx->sub_pages_map,
-				dmx->sub_buf_len, DMA_FROM_DEVICE);
-		free_pages(dmx->sub_pages, get_order(dmx->sub_buf_len));
-		dmx->sub_pages = 0;
-	}
-#endif
-	if (dmx->pes_pages) {
-		dma_unmap_single(dmx_get_dev(dmx), dmx->pes_pages_map,
-				dmx->pes_buf_len, DMA_FROM_DEVICE);
-		free_pages(dmx->pes_pages, get_order(dmx->pes_buf_len));
-		dmx->pes_pages = 0;
-	}
-
-	if (dmx->dmx_irq != -1) {
-		free_irq(dmx->dmx_irq, dmx);
-		tasklet_kill(&dmx->dmx_tasklet);
-	}
-
-	dmx->init = 0;
-
-	return 0;
-}
-
-/*Check the record flag*/
-static int dmx_get_record_flag(struct aml_dmx *dmx)
-{
-	int i, linked = 0, record_flag = 0;
-	struct aml_dvb *dvb = (struct aml_dvb *)dmx->demux.priv;
-
-	/*Check whether a async fifo connected to this dmx */
-	for (i = 0; i < ASYNCFIFO_COUNT; i++) {
-		if (!dvb->asyncfifo[i].init)
-			continue;
-		if ((dvb->asyncfifo[i].source == dmx->id)
-		    /*&& !(dvb->swfilter.user && (i==SF_AFIFO_ID)) */
-		    /*sf mode reserved */
-		    ) {
-			linked = 1;
-			break;
-		}
-	}
-
-	for (i = 0; i < CHANNEL_COUNT; i++) {
-		if (dmx->channel[i].used && dmx->channel[i].dvr_feed) {
-			if (!dmx->record) {
-				dmx->record = 1;
-
-				if (linked) {
-					/*A new record will start,
-					   must reset the async fifos for
-					 linking the right demux */
-					reset_async_fifos(dvb);
-				}
-			}
-			if (linked)
-				record_flag = 1;
-			goto find_done;
-		}
-	}
-
-	if (dmx->record) {
-		dmx->record = 0;
-		if (linked) {
-			/*A record will stop, reset the async fifos
-			for linking the right demux */
-			reset_async_fifos(dvb);
-		}
-	}
-
-find_done:
-	return record_flag;
-}
-
-/*Enable the demux device*/
-static int dmx_enable(struct aml_dmx *dmx)
-{
-	struct aml_dvb *dvb = (struct aml_dvb *)dmx->demux.priv;
-	int fec_sel, hi_bsf, fec_ctrl, record;
-	int fec_core_sel = 0;
-	int set_stb = 0, fec_s = 0;
-	int s2p_id;
-	u32 invert0 = 0, invert1 = 0, fec_s0 = 0, fec_s1 = 0;
-
-	record = dmx_get_record_flag(dmx);
-
-	switch (dmx->source) {
-	case AM_TS_SRC_TS0:
-		fec_sel = 0;
-		fec_ctrl = dvb->ts[0].control;
-		record = record ? 1 : 0;
-		break;
-	case AM_TS_SRC_TS1:
-		fec_sel = 1;
-		fec_ctrl = dvb->ts[1].control;
-		record = record ? 1 : 0;
-		break;
-	case AM_TS_SRC_TS2:
-		fec_sel = 2;
-		fec_ctrl = dvb->ts[2].control;
-		record = record ? 1 : 0;
-		break;
-	case AM_TS_SRC_S_TS0:
-	case AM_TS_SRC_S_TS1:
-	case AM_TS_SRC_S_TS2:
-		s2p_id = 0;
-		fec_ctrl = 0;
-		if (dmx->source == AM_TS_SRC_S_TS0) {
-			s2p_id = dvb->ts[0].s2p_id;
-			fec_ctrl = dvb->ts[0].control;
-		} else if (dmx->source == AM_TS_SRC_S_TS1) {
-			s2p_id = dvb->ts[1].s2p_id;
-			fec_ctrl = dvb->ts[1].control;
-		} else if (dmx->source == AM_TS_SRC_S_TS2) {
-			s2p_id = dvb->ts[2].s2p_id;
-			fec_ctrl = dvb->ts[2].control;
-		}
-		fec_sel = (s2p_id == 1) ? 5 : 6;
-		record = record ? 1 : 0;
-		set_stb = 1;
-		fec_s = dmx->source - AM_TS_SRC_S_TS0;
-		break;
-	case AM_TS_SRC_HIU:
-		fec_sel = 7;
-		fec_ctrl = 0;
-		record = 0;
-		break;
-	default:
-		fec_sel = 0;
-		fec_ctrl = 0;
-		record = 0;
-		break;
-	}
-
-	if (dmx->channel[0].used || dmx->channel[1].used)
-		hi_bsf = 1;
-	else
-		hi_bsf = 0;
-
-	if ((dvb->dsc[0].dst != -1)
-	    && ((dvb->dsc[0].dst - AM_TS_SRC_DMX0) == dmx->id))
-		fec_core_sel = 1;
-
-	if ((dvb->dsc[1].dst != -1)
-	    && ((dvb->dsc[1].dst - AM_TS_SRC_DMX0) == dmx->id))	{
-		int des_in, des_out, en_des = 0;
-		switch (dvb->dsc[1].source) {
-		case AM_TS_SRC_DMX0:
-			des_in = 0;
-			en_des = 1;
-			break;
-		case AM_TS_SRC_DMX1:
-			des_in = 1;
-			en_des = 1;
-			break;
-		case AM_TS_SRC_DMX2:
-			des_in = 2;
-			en_des = 1;
-			break;
-		default:
-			des_in = 0;
-			en_des = 0;
-			break;
-		}
-
-		switch (dvb->dsc[1].dst) {
-		case AM_TS_SRC_DMX0:
-			des_out = 1;
-			break;
-		case AM_TS_SRC_DMX1:
-			des_out = 2;
-			break;
-		case AM_TS_SRC_DMX2:
-			des_out = 4;
-			break;
-		default:
-			des_out = 0;
-			break;
-		}
-
-		if (!des_out)
-			en_des = 0;
-
-		WRITE_MPEG_REG(COMM_DESC_2_CTL,
-				(6 << 8) |/*des_out_dly_2*/
-				((!!en_des) << 6) |/* des_pl_clk_2*/
-				((!!en_des) << 5) |/* des_pl_2*/
-				(des_out << 2) |/*use_des_2*/
-				(des_in)/*des_i_sel_2*/
-				);
-		fec_core_sel = 1;
-		pr_dbg("dsc2 ctrl: 0x%x\n", READ_MPEG_REG(COMM_DESC_2_CTL));
-	}
-
-	pr_dbg("[dmx-%d]src: %d, rec: %d, hi_bsf: %d, dsc: %d\n",
-	       dmx->id, dmx->source, record, hi_bsf, fec_core_sel);
-
-	if (dmx->chan_count) {
-		if (set_stb) {
-			u32 v = READ_MPEG_REG(STB_TOP_CONFIG);
-			int i;
-
-			for (i = 0; i < TS_IN_COUNT; i++) {
-				if (dvb->ts[i].s2p_id == 0)
-					fec_s0 = i;
-				else if (dvb->ts[i].s2p_id == 1)
-					fec_s1 = i;
-			}
-
-			invert0 = dvb->s2p[0].invert;
-			invert1 = dvb->s2p[1].invert;
-
-			v &= ~((0x3 << S2P0_FEC_SERIAL_SEL) |
-			       (0x1f << INVERT_S2P0_FEC_CLK) |
-			       (0x3 << S2P1_FEC_SERIAL_SEL) |
-			       (0x1f << INVERT_S2P1_FEC_CLK));
-
-			v |= (fec_s0 << S2P0_FEC_SERIAL_SEL) |
-			    (invert0 << INVERT_S2P0_FEC_CLK) |
-			    (fec_s1 << S2P1_FEC_SERIAL_SEL) |
-			    (invert1 << INVERT_S2P1_FEC_CLK);
-			WRITE_MPEG_REG(STB_TOP_CONFIG, v);
-		}
-
-		/*Initialize the registers */
-		DMX_WRITE_REG(dmx->id, STB_INT_MASK, DEMUX_INT_MASK);
-		DMX_WRITE_REG(dmx->id, DEMUX_MEM_REQ_EN,
-#ifdef USE_AHB_MODE
-			      (1 << SECTION_AHB_DMA_EN) |
-			      (0 << SUB_AHB_DMA_EN) |
-			      (1 << OTHER_PES_AHB_DMA_EN) |
-#endif
-			      (1 << SECTION_PACKET) |
-			      (1 << VIDEO_PACKET) |
-			      (1 << AUDIO_PACKET) |
-			      (1 << SUB_PACKET) |
-			      (1 << SCR_ONLY_PACKET) |
-				(1 << OTHER_PES_PACKET));
-		DMX_WRITE_REG(dmx->id, PES_STRONG_SYNC, 0x1234);
-		DMX_WRITE_REG(dmx->id, DEMUX_ENDIAN,
-			      (7 << OTHER_ENDIAN) |
-			      (7 << BYPASS_ENDIAN) | (0 << SECTION_ENDIAN));
-		DMX_WRITE_REG(dmx->id, TS_HIU_CTL,
-			      (0 << LAST_BURST_THRESHOLD) |
-			      (hi_bsf << USE_HI_BSF_INTERFACE));
-
-		DMX_WRITE_REG(dmx->id, FEC_INPUT_CONTROL,
-			      (fec_core_sel << FEC_CORE_SEL) |
-			      (fec_sel << FEC_SEL) | (fec_ctrl << 0));
-		DMX_WRITE_REG(dmx->id, STB_OM_CTL,
-			      (0x40 << MAX_OM_DMA_COUNT) |
-			      (0x7f << LAST_OM_ADDR));
-		DMX_WRITE_REG(dmx->id, DEMUX_CONTROL,
-			      (0 << BYPASS_USE_RECODER_PATH) |
-			      (0 << INSERT_AUDIO_PES_STRONG_SYNC) |
-			      (0 << INSERT_VIDEO_PES_STRONG_SYNC) |
-			      (0 << OTHER_INT_AT_PES_BEGINING) |
-			      (0 << DISCARD_AV_PACKAGE) |
-			      ((!!dmx->dump_ts_select) << TS_RECORDER_SELECT) |
-			      (record << TS_RECORDER_ENABLE) |
-			      (1 << KEEP_DUPLICATE_PACKAGE) |
-			      (1 << SECTION_END_WITH_TABLE_ID) |
-			      (1 << ENABLE_FREE_CLK_FEC_DATA_VALID) |
-			      (1 << ENABLE_FREE_CLK_STB_REG) |
-			      (1 << STB_DEMUX_ENABLE) |
-			      (1 << NOT_USE_OF_SOP_INPUT));
-	} else {
-		DMX_WRITE_REG(dmx->id, STB_INT_MASK, 0);
-		DMX_WRITE_REG(dmx->id, FEC_INPUT_CONTROL, 0);
-		DMX_WRITE_REG(dmx->id, DEMUX_CONTROL, 0);
-	}
-
-	return 0;
-}
-
-static int dmx_set_misc(struct aml_dmx *dmx, int hi_bsf, int en_dsc)
-{
-	if (hi_bsf >= 0) {
-		DMX_WRITE_REG(dmx->id, TS_HIU_CTL,
-					hi_bsf ?
-					(DMX_READ_REG(dmx->id, TS_HIU_CTL) |
-					(1 << USE_HI_BSF_INTERFACE))
-					:
-					(DMX_READ_REG(dmx->id, TS_HIU_CTL) &
-					(~(1 << USE_HI_BSF_INTERFACE))));
-	}
-
-	if (en_dsc >= 0) {
-		DMX_WRITE_REG(dmx->id, FEC_INPUT_CONTROL,
-				en_dsc ?
-				(DMX_READ_REG(dmx->id, FEC_INPUT_CONTROL) |
-				(1 << FEC_CORE_SEL))
-				:
-				(DMX_READ_REG(dmx->id, FEC_INPUT_CONTROL) &
-				(~(1 << FEC_CORE_SEL))));
-	}
-
-	return 0;
-}
-
-static int dmx_set_misc_id(struct aml_dvb *dvb, int id, int hi_bsf, int en_dsc)
-{
-	return dmx_set_misc(&dvb->dmx[id], hi_bsf, en_dsc);
-}
-
-/*Get the channel's ID by its PID*/
-static int dmx_get_chan(struct aml_dmx *dmx, int pid)
-{
-	int id;
-
-	for (id = 0; id < CHANNEL_COUNT; id++) {
-		if (dmx->channel[id].used && dmx->channel[id].pid == pid)
-			return id;
-	}
-
-	return -1;
-}
-
-/*Get the channel's target*/
-static u32 dmx_get_chan_target(struct aml_dmx *dmx, int cid)
-{
-	u32 type;
-
-	if (!dmx->channel[cid].used)
-		return 0xFFFF;
-
-	if (dmx->channel[cid].type == DMX_TYPE_SEC) {
-		type = SECTION_PACKET;
-	} else {
-		switch (dmx->channel[cid].pes_type) {
-		case DMX_PES_AUDIO:
-			type = AUDIO_PACKET;
-			break;
-		case DMX_PES_VIDEO:
-			type = VIDEO_PACKET;
-			break;
-		case DMX_PES_SUBTITLE:
-		case DMX_PES_TELETEXT:
-			type = SUB_PACKET;
-			break;
-		case DMX_PES_PCR:
-			type = SCR_ONLY_PACKET;
-			break;
-		default:
-			type = OTHER_PES_PACKET;
-			break;
-		}
-	}
-
-	pr_dbg("chan target: %x %x\n", type, dmx->channel[cid].pid);
-	return (type << PID_TYPE) | dmx->channel[cid].pid;
-}
-
-/*Get the advance value of the channel*/
-static inline u32 dmx_get_chan_advance(struct aml_dmx *dmx, int cid)
-{
-	return 0;
-}
-
-/*Set the channel registers*/
-static int dmx_set_chan_regs(struct aml_dmx *dmx, int cid)
-{
-	u32 data, addr, advance, max;
-
-	pr_dbg("set channel (id:%d PID:0x%x) registers\n", cid,
-	       dmx->channel[cid].pid);
-
-	while (DMX_READ_REG(dmx->id, FM_WR_ADDR) & 0x8000)
-		udelay(1);
-
-	if (cid & 1) {
-		data =
-		    (dmx_get_chan_target(dmx, cid - 1) << 16) |
-		    dmx_get_chan_target(dmx, cid);
-		advance =
-		    (dmx_get_chan_advance(dmx, cid) << 8) |
-		    dmx_get_chan_advance(dmx, cid - 1);
-	} else {
-		data =
-		    (dmx_get_chan_target(dmx, cid) << 16) |
-		    dmx_get_chan_target(dmx, cid + 1);
-		advance =
-		    (dmx_get_chan_advance(dmx, cid + 1) << 8) |
-		    dmx_get_chan_advance(dmx, cid);
-	}
-	addr = cid >> 1;
-	DMX_WRITE_REG(dmx->id, FM_WR_DATA, data);
-	DMX_WRITE_REG(dmx->id, FM_WR_ADDR, (advance << 16) | 0x8000 | addr);
-
-	pr_dbg("write fm %x:%x\n", (advance << 16) | 0x8000 | addr, data);
-
-	for (max = CHANNEL_COUNT - 1; max > 0; max--) {
-		if (dmx->channel[max].used)
-			break;
-	}
-
-	data = DMX_READ_REG(dmx->id, MAX_FM_COMP_ADDR) & 0xF0;
-	DMX_WRITE_REG(dmx->id, MAX_FM_COMP_ADDR, data | (max >> 1));
-
-	pr_dbg("write fm comp %x\n", data | (max >> 1));
-
-	if (DMX_READ_REG(dmx->id, OM_CMD_STATUS) & 0x8e00) {
-		pr_error("error send cmd %x\n",
-			 DMX_READ_REG(dmx->id, OM_CMD_STATUS));
-	}
-
-	if (cid == 0)
-		first_video_pts = 0;
-	else if (cid == 1)
-		first_audio_pts = 0;
-
-	return 0;
-}
-
-/*Get the filter target*/
-static int dmx_get_filter_target(struct aml_dmx *dmx, int fid, u32 *target,
-				 u8 *advance)
-{
-	struct dmx_section_filter *filter;
-	struct aml_filter *f;
-	int i, cid, neq_bytes;
-
-	fid = fid & 0xFFFF;
-	f = &dmx->filter[fid];
-
-	if (!f->used) {
-		target[0] = 0x1fff;
-		advance[0] = 0;
-		for (i = 1; i < FILTER_LEN; i++) {
-			target[i] = 0x9fff;
-			advance[i] = 0;
-		}
-		return 0;
-	}
-
-	cid = f->chan_id;
-	filter = f->filter;
-
-	neq_bytes = 0;
-	if (filter->filter_mode[0] != 0xFF) {
-		neq_bytes = 2;
-	} else {
-		for (i = 3; i < FILTER_LEN; i++) {
-			if (filter->filter_mode[i] != 0xFF)
-				neq_bytes++;
-		}
-	}
-
-	f->neq = 0;
-
-	for (i = 0; i < FILTER_LEN; i++) {
-		u8 value = filter->filter_value[i];
-		u8 mask = filter->filter_mask[i];
-		u8 mode = filter->filter_mode[i];
-		u8 mb, mb1, nb, v, t, adv = 0;
-
-		if (!i) {
-			mb = 1;
-			mb1 = 1;
-			v = 0;
-			if ((mode == 0xFF) && mask) {
-				t = mask & 0xF0;
-				if (t) {
-					mb1 = 0;
-					adv |= t^0xF0;
-				}
-				v |= (value & 0xF0) | adv;
-
-				t = mask & 0x0F;
-				if (t) {
-					mb  = 0;
-					adv |= t^0x0F;
-				}
-				v |= (value & 0x0F) | adv;
-			}
-
-			target[i] = (mb << SECTION_FIRSTBYTE_MASKLOW) |
-			    (mb1 << SECTION_FIRSTBYTE_MASKHIGH) |
-			    (0 << SECTION_FIRSTBYTE_DISABLE_PID_CHECK) |
-			    (cid << SECTION_FIRSTBYTE_PID_INDEX) | v;
-			advance[i] = adv;
-		} else {
-			if (i < 3) {
-				value = 0;
-				mask = 0;
-				mode = 0xff;
-			}
-			mb = 1;
-			nb = 0;
-			v = 0;
-
-			if ((i >= 3) && mask) {
-				if (mode == 0xFF) {
-					mb = 0;
-					nb = 0;
-					adv = mask ^ 0xFF;
-					v = value | adv;
-				} else {
-					if (neq_bytes == 1) {
-						mb = 0;
-						nb = 1;
-						adv = mask ^ 0xFF;
-						v = value & ~adv;
-					}
-				}
-			}
-			target[i] = (mb << SECTION_RESTBYTE_MASK) |
-			    (nb << SECTION_RESTBYTE_MASK_EQ) |
-			    (0 << SECTION_RESTBYTE_DISABLE_PID_CHECK) |
-			    (cid << SECTION_RESTBYTE_PID_INDEX) | v;
-			advance[i] = adv;
-		}
-
-		f->value[i] = value;
-		f->maskandmode[i] = mask & mode;
-		f->maskandnotmode[i] = mask & ~mode;
-
-		if (f->maskandnotmode[i])
-			f->neq = 1;
-	}
-
-	return 0;
-}
-
-/*Set the filter registers*/
-static int dmx_set_filter_regs(struct aml_dmx *dmx, int fid)
-{
-	u32 t1[FILTER_LEN], t2[FILTER_LEN];
-	u8 advance1[FILTER_LEN], advance2[FILTER_LEN];
-	u32 addr, data, max, adv;
-	int i;
-
-	pr_dbg("set filter (id:%d) registers\n", fid);
-
-	if (fid & 1) {
-		dmx_get_filter_target(dmx, fid - 1, t1, advance1);
-		dmx_get_filter_target(dmx, fid, t2, advance2);
-	} else {
-		dmx_get_filter_target(dmx, fid, t1, advance1);
-		dmx_get_filter_target(dmx, fid + 1, t2, advance2);
-	}
-
-	for (i = 0; i < FILTER_LEN; i++) {
-		while (DMX_READ_REG(dmx->id, FM_WR_ADDR) & 0x8000)
-			udelay(1);
-
-		data = (t1[i] << 16) | t2[i];
-		addr = (fid >> 1) | ((i + 1) << 4);
-		adv = (advance1[i] << 8) | advance2[i];
-
-		DMX_WRITE_REG(dmx->id, FM_WR_DATA, data);
-		DMX_WRITE_REG(dmx->id, FM_WR_ADDR, (adv << 16) | 0x8000 | addr);
-
-		pr_dbg("write fm %x:%x\n", (adv << 16) | 0x8000 | addr, data);
-	}
-
-	for (max = FILTER_COUNT - 1; max > 0; max--) {
-		if (dmx->filter[max].used)
-			break;
-	}
-
-	data = DMX_READ_REG(dmx->id, MAX_FM_COMP_ADDR) & 0xF;
-	DMX_WRITE_REG(dmx->id, MAX_FM_COMP_ADDR, data | ((max >> 1) << 4));
-
-	pr_dbg("write fm comp %x\n", data | ((max >> 1) << 4));
-
-	if (DMX_READ_REG(dmx->id, OM_CMD_STATUS) & 0x8e00) {
-		pr_error("error send cmd %x\n",
-			 DMX_READ_REG(dmx->id, OM_CMD_STATUS));
-	}
-
-	return 0;
-}
-
-/*Clear the filter's buffer*/
-static void dmx_clear_filter_buffer(struct aml_dmx *dmx, int fid)
-{
-	u32 section_busy32 = DMX_READ_REG(dmx->id, SEC_BUFF_READY);
-	u32 filter_number;
-	int i;
-
-	if (!section_busy32)
-		return;
-
-	for (i = 0; i < SEC_BUF_COUNT; i++) {
-		if (section_busy32 & (1 << i)) {
-			DMX_WRITE_REG(dmx->id, SEC_BUFF_NUMBER, i);
-			filter_number =
-			    (DMX_READ_REG(dmx->id, SEC_BUFF_NUMBER) >> 8);
-			if (filter_number != fid)
-				section_busy32 &= ~(1 << i);
-		}
-	}
-
-	if (section_busy32)
-		DMX_WRITE_REG(dmx->id, SEC_BUFF_READY, section_busy32);
-}
-
-static void async_fifo_set_regs(struct aml_asyncfifo *afifo, int source_val)
-{
-	u32 start_addr = virt_to_phys((void *)afifo->pages);
-	u32 size = afifo->buf_len;
-	u32 flush_size = afifo->flush_size;
-	int factor = dmx_get_order(size / flush_size);
-
-	pr_dbg("ASYNC FIFO id=%d, link to DMX%d, start_addr %x, buf_size %d,"
-		"source value 0x%x, factor %d\n",
-		afifo->id, afifo->source, start_addr, size, source_val, factor);
-	/* Destination address */
-	WRITE_ASYNC_FIFO_REG(afifo->id, REG0, start_addr);
-
-	/* Setup flush parameters */
-	WRITE_ASYNC_FIFO_REG(afifo->id, REG1,
-			(0 << ASYNC_FIFO_TO_HIU) |
-			(0 << ASYNC_FIFO_FLUSH) |
-			/* don't flush the path */
-			(1 << ASYNC_FIFO_RESET) |
-			/* reset the path */
-			(1 << ASYNC_FIFO_WRAP_EN) |
-			/* wrap enable */
-			(0 << ASYNC_FIFO_FLUSH_EN) |
-			/* disable the flush path */
-			/*(0x3 << ASYNC_FIFO_FLUSH_CNT_LSB);
-			// flush 3 x 32  32-bit words */
-			/*(0x7fff << ASYNC_FIFO_FLUSH_CNT_LSB);
-			// flush 4MBytes of data */
-			(((size >> 7) & 0x7fff) << ASYNC_FIFO_FLUSH_CNT_LSB));
-			/* number of 128-byte blocks to flush */
-
-	/* clear the reset signal */
-	WRITE_ASYNC_FIFO_REG(afifo->id, REG1,
-		     READ_ASYNC_FIFO_REG(afifo->id,
-					REG1) & ~(1 << ASYNC_FIFO_RESET));
-	/* Enable flush */
-	WRITE_ASYNC_FIFO_REG(afifo->id, REG1,
-		     READ_ASYNC_FIFO_REG(afifo->id,
-				REG1) | (1 << ASYNC_FIFO_FLUSH_EN));
-
-	/*Setup Fill parameters */
-	WRITE_ASYNC_FIFO_REG(afifo->id, REG2,
-			     (1 << ASYNC_FIFO_ENDIAN_LSB) |
-			     (0 << ASYNC_FIFO_FILL_EN) |
-			     /* disable fill path to reset fill path */
-			     /*(96 << ASYNC_FIFO_FILL_CNT_LSB);
-				// 3 x 32  32-bit words */
-			     (0 << ASYNC_FIFO_FILL_CNT_LSB));
-				/* forever FILL; */
-	WRITE_ASYNC_FIFO_REG(afifo->id, REG2,
-			READ_ASYNC_FIFO_REG(afifo->id, REG2) |
-				(1 << ASYNC_FIFO_FILL_EN));/*Enable fill path*/
-
-	/* generate flush interrupt */
-	WRITE_ASYNC_FIFO_REG(afifo->id, REG3,
-			(READ_ASYNC_FIFO_REG(afifo->id, REG3) & 0xffff0000) |
-				((((size >> (factor + 7)) - 1) & 0x7fff) <<
-					ASYNC_FLUSH_SIZE_IRQ_LSB));
-
-	/* Connect the STB DEMUX to ASYNC_FIFO */
-	WRITE_ASYNC_FIFO_REG(afifo->id, REG2,
-			READ_ASYNC_FIFO_REG(afifo->id, REG2) |
-			(source_val << ASYNC_FIFO_SOURCE_LSB));
-}
-
-/*Reset the ASYNC FIFOS when a ASYNC FIFO connect to a different DMX*/
-static void reset_async_fifos(struct aml_dvb *dvb)
-{
-	struct aml_asyncfifo *low_dmx_fifo = NULL;
-	struct aml_asyncfifo *high_dmx_fifo = NULL;
-	int i, j;
-	int record_enable;
-
-	pr_dbg("reset ASYNC FIFOs\n");
-	for (i = 0; i < ASYNCFIFO_COUNT; i++) {
-		if (!dvb->asyncfifo[i].init)
-			continue;
-		pr_dbg("Disable ASYNC FIFO id=%d\n", dvb->asyncfifo[i].id);
-		CLEAR_ASYNC_FIFO_REG_MASK(dvb->asyncfifo[i].id, REG1,
-					  1 << ASYNC_FIFO_FLUSH_EN);
-		CLEAR_ASYNC_FIFO_REG_MASK(dvb->asyncfifo[i].id, REG2,
-					  1 << ASYNC_FIFO_FILL_EN);
-		if (READ_ASYNC_FIFO_REG(dvb->asyncfifo[i].id, REG2) &
-				(1 << ASYNC_FIFO_FILL_EN) ||
-			READ_ASYNC_FIFO_REG(dvb->asyncfifo[i].id, REG1) &
-				(1 << ASYNC_FIFO_FLUSH_EN)) {
-			pr_dbg("Set reg failed\n");
-		} else
-			pr_dbg("Set reg ok\n");
-		dvb->asyncfifo[i].buf_toggle = 0;
-		dvb->asyncfifo[i].buf_read = 0;
-	}
-
-	for (j = 0; j < DMX_DEV_COUNT; j++) {
-		if (!dvb->dmx[j].init)
-			continue;
-		record_enable = 0;
-		for (i = 0; i < ASYNCFIFO_COUNT; i++) {
-			if (!dvb->asyncfifo[i].init)
-				continue;
-
-			if (dvb->dmx[j].record
-			    && dvb->dmx[j].id == dvb->asyncfifo[i].source) {
-				/*This dmx is linked to the async fifo,
-				Enable the TS_RECORDER_ENABLE */
-				record_enable = 1;
-				if (!low_dmx_fifo) {
-					low_dmx_fifo = &dvb->asyncfifo[i];
-				} else if (low_dmx_fifo->source >
-					   dvb->asyncfifo[i].source) {
-					high_dmx_fifo = low_dmx_fifo;
-					low_dmx_fifo = &dvb->asyncfifo[i];
-				} else if (low_dmx_fifo->source <
-					   dvb->asyncfifo[i].source) {
-					high_dmx_fifo = &dvb->asyncfifo[i];
-				}
-
-				break;
-			}
-		}
-		pr_dbg("Set DMX%d TS_RECORDER_ENABLE to %d\n", dvb->dmx[j].id,
-		       record_enable ? 1 : 0);
-		if (record_enable) {
-			/*DMX_SET_REG_MASK(dvb->dmx[j].id,
-			DEMUX_CONTROL, 1<<TS_RECORDER_ENABLE); */
-			DMX_WRITE_REG(dvb->dmx[j].id, DEMUX_CONTROL,
-				DMX_READ_REG(dvb->dmx[j].id, DEMUX_CONTROL) |
-				(1 << TS_RECORDER_ENABLE));
-		} else {
-			/*DMX_CLEAR_REG_MASK(dvb->dmx[j].id,
-			DEMUX_CONTROL, 1<<TS_ECORDER_ENABLE); */
-			DMX_WRITE_REG(dvb->dmx[j].id, DEMUX_CONTROL,
-				DMX_READ_REG(dvb->dmx[j].id, DEMUX_CONTROL) &
-				(~(1 <<	TS_RECORDER_ENABLE)));
-		}
-	}
-
-	/*Set the async fifo regs */
-	if (low_dmx_fifo) {
-		async_fifo_set_regs(low_dmx_fifo, 0x3);
-
-		if (high_dmx_fifo)
-			async_fifo_set_regs(high_dmx_fifo, 0x2);
-	}
-}
-
-/*Reset the demux device*/
-void dmx_reset_hw(struct aml_dvb *dvb)
-{
-	dmx_reset_hw_ex(dvb, 1);
-}
-
-/*Reset the demux device*/
-void dmx_reset_hw_ex(struct aml_dvb *dvb, int reset_irq)
-{
-	int id, times;
-
-	pr_dbg("demux reset begin\n");
-
-	for (id = 0; id < DMX_DEV_COUNT; id++) {
-		if (!dvb->dmx[id].init)
-			continue;
-		if (reset_irq) {
-			if (dvb->dmx[id].dmx_irq != -1)
-				disable_irq(dvb->dmx[id].dmx_irq);
-			if (dvb->dmx[id].dvr_irq != -1)
-				disable_irq(dvb->dmx[id].dvr_irq);
-		}
-	}
-#ifdef ENABLE_SEC_BUFF_WATCHDOG
-	if (reset_irq)
-		del_timer_sync(&dvb->watchdog_timer);
-#endif
-
-	WRITE_MPEG_REG(RESET1_REGISTER, RESET_DEMUXSTB);
-
-	for (id = 0; id < DMX_DEV_COUNT; id++) {
-		times = 0;
-		while (times++ < 1000000) {
-			if (!(DMX_READ_REG(id, OM_CMD_STATUS) & 0x01))
-				break;
-		}
-	}
-
-	WRITE_MPEG_REG(STB_TOP_CONFIG, 0);
-
-	for (id = 0; id < DMX_DEV_COUNT; id++) {
-		u32 version, data;
-
-		if (!dvb->dmx[id].init)
-			continue;
-
-		if (reset_irq) {
-			if (dvb->dmx[id].dmx_irq != -1)
-				enable_irq(dvb->dmx[id].dmx_irq);
-			if (dvb->dmx[id].dvr_irq != -1)
-				enable_irq(dvb->dmx[id].dvr_irq);
-		}
-		DMX_WRITE_REG(id, DEMUX_CONTROL, 0x0000);
-		version = DMX_READ_REG(id, STB_VERSION);
-		DMX_WRITE_REG(id, STB_TEST_REG, version);
-		pr_dbg("STB %d hardware version : %d\n", id, version);
-		DMX_WRITE_REG(id, STB_TEST_REG, 0x5550);
-		data = DMX_READ_REG(id, STB_TEST_REG);
-		if (data != 0x5550)
-			pr_error("STB %d register access failed\n", id);
-		DMX_WRITE_REG(id, STB_TEST_REG, 0xaaa0);
-		data = DMX_READ_REG(id, STB_TEST_REG);
-		if (data != 0xaaa0)
-			pr_error("STB %d register access failed\n", id);
-		DMX_WRITE_REG(id, MAX_FM_COMP_ADDR, 0x0000);
-		DMX_WRITE_REG(id, STB_INT_MASK, 0);
-		DMX_WRITE_REG(id, STB_INT_STATUS, 0xffff);
-		DMX_WRITE_REG(id, FEC_INPUT_CONTROL, 0);
-	}
-
-	stb_enable(dvb);
-
-	for (id = 0; id < DMX_DEV_COUNT; id++) {
-		struct aml_dmx *dmx = &dvb->dmx[id];
-		int n;
-		unsigned long addr;
-		unsigned long base;
-		unsigned long grp_addr[SEC_BUF_GRP_COUNT];
-		int grp_len[SEC_BUF_GRP_COUNT];
-		if (!dvb->dmx[id].init)
-			continue;
-
-		if (dmx->sec_pages) {
-			grp_len[0] = (1 << SEC_GRP_LEN_0) * 8;
-			grp_len[1] = (1 << SEC_GRP_LEN_1) * 8;
-			grp_len[2] = (1 << SEC_GRP_LEN_2) * 8;
-			grp_len[3] = (1 << SEC_GRP_LEN_3) * 8;
-
-			grp_addr[0] = virt_to_phys((void *)dmx->sec_pages);
-			grp_addr[1] = grp_addr[0] + grp_len[0];
-			grp_addr[2] = grp_addr[1] + grp_len[1];
-			grp_addr[3] = grp_addr[2] + grp_len[2];
-
-			base = grp_addr[0] & 0xFFFF0000;
-			DMX_WRITE_REG(dmx->id, SEC_BUFF_BASE, base >> 16);
-			DMX_WRITE_REG(dmx->id, SEC_BUFF_01_START,
-					(((grp_addr[0] - base) >> 8) << 16) |
-					 ((grp_addr[1] - base) >> 8));
-			DMX_WRITE_REG(dmx->id, SEC_BUFF_23_START,
-					(((grp_addr[2] - base) >> 8) << 16) |
-					 ((grp_addr[3] - base) >> 8));
-			DMX_WRITE_REG(dmx->id, SEC_BUFF_SIZE,
-					SEC_GRP_LEN_0 |
-					(SEC_GRP_LEN_1 << 4) |
-					(SEC_GRP_LEN_2 << 8) |
-					(SEC_GRP_LEN_3 << 12));
-		}
-
-		if (dmx->sub_pages) {
-			addr = virt_to_phys((void *)dmx->sub_pages);
-			DMX_WRITE_REG(dmx->id, SB_START, addr >> 12);
-			DMX_WRITE_REG(dmx->id, SB_LAST_ADDR,
-				      (dmx->sub_buf_len >> 3) - 1);
-		}
-
-		if (dmx->pes_pages) {
-			addr = virt_to_phys((void *)dmx->pes_pages);
-			DMX_WRITE_REG(dmx->id, OB_START, addr >> 12);
-			DMX_WRITE_REG(dmx->id, OB_LAST_ADDR,
-				      (dmx->pes_buf_len >> 3) - 1);
-		}
-
-		for (n = 0; n < CHANNEL_COUNT; n++) {
-			/*struct aml_channel *chan = &dmx->channel[n];*/
-
-			/*if (chan->used)*/
-			{
-				dmx_set_chan_regs(dmx, n);
-			}
-		}
-
-		for (n = 0; n < FILTER_COUNT; n++) {
-			struct aml_filter *filter = &dmx->filter[n];
-
-			if (filter->used)
-				dmx_set_filter_regs(dmx, n);
-		}
-
-		dmx_enable(&dvb->dmx[id]);
-
-		dmx_smallsec_set(&dmx->smallsec,
-				dmx->smallsec.enable,
-				dmx->smallsec.bufsize,
-				1);
-
-		dmx_timeout_set(&dmx->timeout,
-				dmx->timeout.enable,
-				dmx->timeout.timeout,
-				dmx->timeout.ch_disable,
-				dmx->timeout.match,
-				1);
-	}
-
-	for (id = 0; id < DSC_DEV_COUNT; id++) {
-		struct aml_dsc *dsc = &dvb->dsc[id];
-		int n;
-
-		for (n = 0; n < DSC_COUNT; n++) {
-			struct aml_dsc_channel *ch = &dsc->channel[n];
-			/*if(ch->used) */
-			{
-				ch->id = n;
-				dsc_set_pid(ch, ch->pid);
-
-				if (ch->set & 1)
-					dsc_set_key(ch, 0, ch->even);
-				if (ch->set & 2)
-					dsc_set_key(ch, 1, ch->odd);
-			}
-		}
-	}
-#ifdef ENABLE_SEC_BUFF_WATCHDOG
-	if (reset_irq) {
-		mod_timer(&dvb->watchdog_timer,
-			  jiffies + msecs_to_jiffies(WATCHDOG_TIMER));
-	}
-#endif
-
-	pr_dbg("demux reset end\n");
-}
-
-/*Reset the individual demux*/
-void dmx_reset_dmx_hw_ex_unlock(struct aml_dvb *dvb, struct aml_dmx *dmx,
-				int reset_irq)
-{
-	{
-		if (!dmx->init)
-			return;
-		if (reset_irq) {
-			if (dmx->dmx_irq != -1)
-				disable_irq(dmx->dmx_irq);
-			if (dmx->dvr_irq != -1)
-				disable_irq(dmx->dvr_irq);
-		}
-	}
-#ifdef ENABLE_SEC_BUFF_WATCHDOG
-	if (reset_irq) {
-		/*del_timer_sync(&dvb->watchdog_timer); */
-		dvb->dmx_watchdog_disable[dmx->id] = 1;
-	}
-#endif
-
-	WRITE_MPEG_REG(RESET3_REGISTER,
-		       (dmx->id) ? ((dmx->id ==
-				     1) ? RESET_DEMUX1 : RESET_DEMUX2) :
-		       RESET_DEMUX0);
-	WRITE_MPEG_REG(RESET3_REGISTER, RESET_DES);
-
-	{
-		int times;
-
-		times = 0;
-		while (times++ < 1000000) {
-			if (!(DMX_READ_REG(dmx->id, OM_CMD_STATUS) & 0x01))
-				break;
-		}
-	}
-
-	/*WRITE_MPEG_REG(STB_TOP_CONFIG, 0); */
-
-	{
-		u32 version, data;
-
-		if (!dmx->init)
-			return;
-
-		if (reset_irq) {
-			if (dmx->dmx_irq != -1)
-				enable_irq(dmx->dmx_irq);
-			if (dmx->dvr_irq != -1)
-				enable_irq(dmx->dvr_irq);
-		}
-		DMX_WRITE_REG(dmx->id, DEMUX_CONTROL, 0x0000);
-		version = DMX_READ_REG(dmx->id, STB_VERSION);
-		DMX_WRITE_REG(dmx->id, STB_TEST_REG, version);
-		pr_dbg("STB %d hardware version : %d\n", dmx->id, version);
-		DMX_WRITE_REG(dmx->id, STB_TEST_REG, 0x5550);
-		data = DMX_READ_REG(dmx->id, STB_TEST_REG);
-		if (data != 0x5550)
-			pr_error("STB %d register access failed\n", dmx->id);
-		DMX_WRITE_REG(dmx->id, STB_TEST_REG, 0xaaa0);
-		data = DMX_READ_REG(dmx->id, STB_TEST_REG);
-		if (data != 0xaaa0)
-			pr_error("STB %d register access failed\n", dmx->id);
-		DMX_WRITE_REG(dmx->id, MAX_FM_COMP_ADDR, 0x0000);
-		DMX_WRITE_REG(dmx->id, STB_INT_MASK, 0);
-		DMX_WRITE_REG(dmx->id, STB_INT_STATUS, 0xffff);
-		DMX_WRITE_REG(dmx->id, FEC_INPUT_CONTROL, 0);
-	}
-
-	stb_enable(dvb);
-
-	{
-		int n;
-		unsigned long addr;
-		unsigned long base;
-		unsigned long grp_addr[SEC_BUF_GRP_COUNT];
-		int grp_len[SEC_BUF_GRP_COUNT];
-
-		if (!dmx->init)
-			return;
-
-		if (dmx->sec_pages) {
-			grp_len[0] = (1 << SEC_GRP_LEN_0) * 8;
-			grp_len[1] = (1 << SEC_GRP_LEN_1) * 8;
-			grp_len[2] = (1 << SEC_GRP_LEN_2) * 8;
-			grp_len[3] = (1 << SEC_GRP_LEN_3) * 8;
-
-			grp_addr[0] = virt_to_phys((void *)dmx->sec_pages);
-			grp_addr[1] = grp_addr[0] + grp_len[0];
-			grp_addr[2] = grp_addr[1] + grp_len[1];
-			grp_addr[3] = grp_addr[2] + grp_len[2];
-
-			base = grp_addr[0] & 0xFFFF0000;
-			DMX_WRITE_REG(dmx->id, SEC_BUFF_BASE, base >> 16);
-			DMX_WRITE_REG(dmx->id, SEC_BUFF_01_START,
-					(((grp_addr[0] - base) >> 8) << 16) |
-					 ((grp_addr[1] - base) >> 8));
-			DMX_WRITE_REG(dmx->id, SEC_BUFF_23_START,
-					(((grp_addr[2] - base) >> 8) << 16) |
-					 ((grp_addr[3] - base) >> 8));
-			DMX_WRITE_REG(dmx->id, SEC_BUFF_SIZE,
-					SEC_GRP_LEN_0 |
-					(SEC_GRP_LEN_1 << 4) |
-					(SEC_GRP_LEN_2 << 8) |
-					(SEC_GRP_LEN_3 << 12));
-		}
-
-		if (dmx->sub_pages) {
-			addr = virt_to_phys((void *)dmx->sub_pages);
-			DMX_WRITE_REG(dmx->id, SB_START, addr >> 12);
-			DMX_WRITE_REG(dmx->id, SB_LAST_ADDR,
-				      (dmx->sub_buf_len >> 3) - 1);
-		}
-
-		if (dmx->pes_pages) {
-			addr = virt_to_phys((void *)dmx->pes_pages);
-			DMX_WRITE_REG(dmx->id, OB_START, addr >> 12);
-			DMX_WRITE_REG(dmx->id, OB_LAST_ADDR,
-				      (dmx->pes_buf_len >> 3) - 1);
-		}
-
-		for (n = 0; n < CHANNEL_COUNT; n++) {
-			/*struct aml_channel *chan = &dmx->channel[n];*/
-
-			/*if (chan->used)*/
-			{
-				dmx_set_chan_regs(dmx, n);
-			}
-		}
-
-		for (n = 0; n < FILTER_COUNT; n++) {
-			struct aml_filter *filter = &dmx->filter[n];
-
-			if (filter->used)
-				dmx_set_filter_regs(dmx, n);
-		}
-
-		dmx_enable(dmx);
-
-		dmx_smallsec_set(&dmx->smallsec,
-				dmx->smallsec.enable,
-				dmx->smallsec.bufsize,
-				1);
-
-		dmx_timeout_set(&dmx->timeout,
-				dmx->timeout.enable,
-				dmx->timeout.timeout,
-				dmx->timeout.ch_disable,
-				dmx->timeout.match,
-				1);
-	}
-
-	{
-		int id;
-		for (id = 0; id < DSC_DEV_COUNT; id++) {
-			struct aml_dsc *dsc = &dvb->dsc[id];
-			int n;
-
-			for (n = 0; n < DSC_COUNT; n++) {
-				struct aml_dsc_channel *ch = &dsc->channel[n];
-				/*if(ch->used) */
-				{
-					dsc_set_pid(ch, ch->pid);
-
-					if (ch->set & 1)
-						dsc_set_key(ch, 0, ch->even);
-					if (ch->set & 2)
-						dsc_set_key(ch, 1, ch->odd);
-				}
-			}
-		}
-	}
-#ifdef ENABLE_SEC_BUFF_WATCHDOG
-	if (reset_irq) {
-		/*mod_timer(&dvb->watchdog_timer,
-		jiffies+msecs_to_jiffies(WATCHDOG_TIMER)); */
-		dvb->dmx_watchdog_disable[dmx->id] = 0;
-	}
-#endif
-}
-
-void dmx_reset_dmx_id_hw_ex_unlock(struct aml_dvb *dvb, int id, int reset_irq)
-{
-	dmx_reset_dmx_hw_ex_unlock(dvb, &dvb->dmx[id], reset_irq);
-}
-
-void dmx_reset_dmx_hw_ex(struct aml_dvb *dvb, struct aml_dmx *dmx,
-			 int reset_irq)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&dvb->slock, flags);
-	dmx_reset_dmx_hw_ex_unlock(dvb, dmx, reset_irq);
-	spin_unlock_irqrestore(&dvb->slock, flags);
-}
-
-void dmx_reset_dmx_id_hw_ex(struct aml_dvb *dvb, int id, int reset_irq)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&dvb->slock, flags);
-	dmx_reset_dmx_id_hw_ex_unlock(dvb, id, reset_irq);
-	spin_unlock_irqrestore(&dvb->slock, flags);
-}
-
-void dmx_reset_dmx_hw(struct aml_dvb *dvb, int id)
-{
-	dmx_reset_dmx_id_hw_ex(dvb, id, 1);
-}
-
-/*Allocate subtitle pes buffer*/
-static int alloc_subtitle_pes_buffer(struct aml_dmx *dmx)
-{
-	int start_ptr = 0;
-	struct stream_buf_s *sbuff = 0;
-	u32 phy_addr;
-	start_ptr = READ_MPEG_REG(PARSER_SUB_START_PTR);
-	if (start_ptr) {
-		WRITE_MPEG_REG(PARSER_SUB_RP, start_ptr);
-		goto exit;
-	}
-	sbuff = get_stream_buffer(BUF_TYPE_SUBTITLE);
-	if (sbuff) {
-		if (sbuff->flag & BUF_FLAG_IOMEM)
-			phy_addr = sbuff->buf_start;
-		else
-			phy_addr = virt_to_phys((void *)sbuff->buf_start);
-
-		WRITE_MPEG_REG(PARSER_SUB_RP, phy_addr);
-		WRITE_MPEG_REG(PARSER_SUB_START_PTR, phy_addr);
-		WRITE_MPEG_REG(PARSER_SUB_END_PTR,
-			       phy_addr + sbuff->buf_size - 8);
-
-		pr_dbg("pes buff=:%x %x\n", phy_addr, sbuff->buf_size);
-	} else
-		pr_dbg("Error stream buffer\n");
-exit:
-	return 0;
-}
-
-/*Allocate a new channel*/
-int dmx_alloc_chan(struct aml_dmx *dmx, int type, int pes_type, int pid)
-{
-	int id = -1;
-	int ret;
-
-	if (type == DMX_TYPE_TS) {
-		switch (pes_type) {
-		case DMX_PES_VIDEO:
-			if (!dmx->channel[0].used)
-				id = 0;
-			break;
-		case DMX_PES_AUDIO:
-			if (!dmx->channel[1].used)
-				id = 1;
-			break;
-		case DMX_PES_SUBTITLE:
-		case DMX_PES_TELETEXT:
-			if (!dmx->channel[2].used)
-				id = 2;
-			alloc_subtitle_pes_buffer(dmx);
-			break;
-		case DMX_PES_PCR:
-			if (!dmx->channel[3].used)
-				id = 3;
-			break;
-		case DMX_PES_OTHER:
-			{
-				int i;
-				for (i = SYS_CHAN_COUNT;
-						i < CHANNEL_COUNT; i++) {
-					if (!dmx->channel[i].used) {
-						id = i;
-						break;
-					}
-				}
-			}
-			break;
-		default:
-			break;
-		}
-	} else {
-		int i;
-		for (i = SYS_CHAN_COUNT; i < CHANNEL_COUNT; i++) {
-			if (!dmx->channel[i].used) {
-				id = i;
-				break;
-			}
-		}
-	}
-
-	if (id == -1) {
-		pr_error("too many channels\n");
-		return -1;
-	}
-
-	pr_dbg("allocate channel(id:%d PID:0x%x)\n", id, pid);
-
-	if (id <= 3) {
-		ret = dmx_get_chan(dmx, pid);
-		if (ret >= 0 && DVR_FEED(dmx->channel[ret].feed)) {
-			dmx_remove_feed(dmx, dmx->channel[ret].feed);
-			dmx->channel[id].dvr_feed = dmx->channel[ret].feed;
-			dmx->channel[id].dvr_feed->priv = (void *)(long)id;
-		} else {
-			dmx->channel[id].dvr_feed = NULL;
-		}
-	}
-
-	dmx->channel[id].type = type;
-	dmx->channel[id].pes_type = pes_type;
-	dmx->channel[id].pid = pid;
-	dmx->channel[id].used = 1;
-	dmx->channel[id].filter_count = 0;
-
-	dmx_set_chan_regs(dmx, id);
-
-	set_debug_dmx_chanpids(dmx->id, id, pid);
-
-	dmx->chan_count++;
-
-	dmx_enable(dmx);
-
-	return id;
-}
-
-/*Free a channel*/
-void dmx_free_chan(struct aml_dmx *dmx, int cid)
-{
-	pr_dbg("free channel(id:%d PID:0x%x)\n", cid, dmx->channel[cid].pid);
-
-	dmx->channel[cid].used = 0;
-	dmx_set_chan_regs(dmx, cid);
-
-	if (cid == 2) {
-		u32 parser_sub_start_ptr;
-
-		parser_sub_start_ptr = READ_MPEG_REG(PARSER_SUB_START_PTR);
-		WRITE_MPEG_REG(PARSER_SUB_RP, parser_sub_start_ptr);
-		WRITE_MPEG_REG(PARSER_SUB_WP, parser_sub_start_ptr);
-	}
-
-	set_debug_dmx_chanpids(dmx->id, cid, -1);
-	dmx->chan_count--;
-
-	dmx_enable(dmx);
-
-	/*Special pes type channel, check its dvr feed */
-	if (cid <= 3 && dmx->channel[cid].dvr_feed) {
-		/*start the dvr feed */
-		dmx_add_feed(dmx, dmx->channel[cid].dvr_feed);
-	}
-}
-
-/*Add a section*/
-static int dmx_chan_add_filter(struct aml_dmx *dmx, int cid,
-			       struct dvb_demux_filter *filter)
-{
-	int id = -1;
-	int i;
-
-	for (i = 0; i < FILTER_COUNT; i++) {
-		if (!dmx->filter[i].used) {
-			id = i;
-			break;
-		}
-	}
-
-	if (id == -1) {
-		pr_error("too many filters\n");
-		return -1;
-	}
-
-	pr_dbg("channel(id:%d PID:0x%x) add filter(id:%d)\n", cid,
-	       filter->feed->pid, id);
-
-	dmx->filter[id].chan_id = cid;
-	dmx->filter[id].used = 1;
-	dmx->filter[id].filter = (struct dmx_section_filter *)filter;
-	dmx->channel[cid].filter_count++;
-
-	dmx_set_filter_regs(dmx, id);
-
-	return id;
-}
-
-static void dmx_remove_filter(struct aml_dmx *dmx, int cid, int fid)
-{
-	pr_dbg("channel(id:%d PID:0x%x) remove filter(id:%d)\n", cid,
-	       dmx->channel[cid].pid, fid);
-
-	dmx->filter[fid].used = 0;
-	dmx->channel[cid].filter_count--;
-
-	dmx_set_filter_regs(dmx, fid);
-	dmx_clear_filter_buffer(dmx, fid);
-}
-
-static int sf_add_feed(struct aml_dmx *src_dmx, struct dvb_demux_feed *feed)
-{
-	int ret;
-
-	struct aml_dvb *dvb = (struct aml_dvb *)src_dmx->demux.priv;
-	struct aml_swfilter *sf = &dvb->swfilter;
-
-	pr_dbg_sf("sf add pid[%d]\n", feed->pid);
-
-	/*init sf */
-	if (!sf->user) {
-		void *mem;
-		mem = vmalloc(SF_BUFFER_SIZE);
-		if (!mem)
-			return -ENOMEM;
-		dvb_ringbuffer_init(&sf->rbuf, mem, SF_BUFFER_SIZE);
-
-		sf->dmx = &dvb->dmx[SF_DMX_ID];
-		sf->afifo = &dvb->asyncfifo[SF_AFIFO_ID];
-
-		sf->dmx->source = src_dmx->source;
-		sf->afifo->source = sf->dmx->id;
-		sf->track_dmx = src_dmx->id;
-		/*sf->afifo->flush_size = 188*10; */
-
-		pr_dbg_sf("init sf mode.\n");
-
-	} else if (sf->dmx->source != src_dmx->source) {
-		pr_error(" pid=%d[src:%d] already used with sfdmx%d[src:%d]\n",
-			 feed->pid, src_dmx->source, sf->dmx->id,
-			 sf->dmx->source);
-		return -EBUSY;
-	}
-
-	/*setup feed */
-	ret = dmx_get_chan(sf->dmx, feed->pid);
-	if (ret >= 0) {
-		pr_error(" pid=%d[dmx:%d] already used [dmx:%d].\n",
-			 feed->pid, src_dmx->id,
-			 ((struct aml_dmx *)sf->dmx->channel[ret].feed->
-			 demux)->id);
-		return -EBUSY;
-	}
-	ret =
-	     dmx_alloc_chan(sf->dmx, DMX_TYPE_TS, DMX_PES_OTHER,
-			    feed->pid);
-	if (ret < 0) {
-		pr_error(" %s: alloc chan error, ret=%d\n", __func__, ret);
-		return ret;
-	}
-	sf->dmx->channel[ret].feed = feed;
-	feed->priv = (void *)(long)ret;
-
-	sf->dmx->channel[ret].dvr_feed = feed;
-
-	sf->user++;
-	debug_sf_user = sf->user;
-
-	dmx_enable(sf->dmx);
-
-	return 0;
-}
-
-static int sf_remove_feed(struct aml_dmx *src_dmx, struct dvb_demux_feed *feed)
-{
-	int ret;
-
-	struct aml_dvb *dvb = (struct aml_dvb *)src_dmx->demux.priv;
-	struct aml_swfilter *sf = &dvb->swfilter;
-
-	if (!sf->user || (sf->dmx->source != src_dmx->source))
-		return 0;
-
-	ret = dmx_get_chan(sf->dmx, feed->pid);
-	if (ret < 0)
-		return 0;
-
-	pr_dbg_sf("sf remove pid[%d]\n", feed->pid);
-
-	dmx_free_chan(sf->dmx, (long)feed->priv);
-
-	sf->dmx->channel[ret].feed = NULL;
-	sf->dmx->channel[ret].dvr_feed = NULL;
-
-	sf->user--;
-	debug_sf_user = sf->user;
-
-	if (!sf->user) {
-		sf->dmx->source = -1;
-		sf->afifo->source = AM_DMX_MAX;
-		sf->track_dmx = -1;
-		/*sf->afifo->flush_size = sf->afifo->buf_len>>1; */
-
-		if (sf->rbuf.data) {
-			void *mem = sf->rbuf.data;
-			sf->rbuf.data = NULL;
-			vfree(mem);
-		}
-		pr_dbg_sf("exit sf mode.\n");
-	}
-
-	return 0;
-}
-
-static int sf_feed_sf(struct aml_dmx *dmx, struct dvb_demux_feed *feed,
-		      int add_not_remove)
-{
-	int sf = 0;
-
-	if (sf_dmx_sf(dmx)) {
-		pr_error("%s: demux %d is in sf mode\n", __func__, dmx->id);
-		return -EINVAL;
-	}
-
-	switch (feed->type) {
-	case DMX_TYPE_TS:{
-			struct dmxdev_filter *dmxdevfilter =
-							 feed->feed.ts.priv;
-			if (!DVR_FEED(feed)) {
-				if (dmxdevfilter->params.pes.
-				    flags & DMX_USE_SWFILTER)
-					sf = 1;
-				if (force_pes_sf)
-					sf = 1;
-			}
-		}
-		break;
-
-	case DMX_TYPE_SEC:{
-			struct dvb_demux_filter *filter;
-			for (filter = feed->filter; filter;
-			     filter = filter->next) {
-				struct dmxdev_filter *dmxdevfilter =
-				    filter->filter.priv;
-				if (dmxdevfilter->params.sec.
-				    flags & DMX_USE_SWFILTER)
-					sf = 1;
-				if (add_not_remove)
-					filter->hw_handle = (u16)-1;
-			}
-			if (force_sec_sf)
-				sf = 1;
-		}
-		break;
-	}
-
-	return sf ? 0 : 1;
-}
-
-static int sf_check_feed(struct aml_dmx *dmx, struct dvb_demux_feed *feed,
-			 int add_not_remove)
-{
-	int ret = 0;
-
-	ret = sf_feed_sf(dmx, feed, add_not_remove);
-	if (ret)
-		return ret;
-
-	pr_dbg_sf("%s [pid:%d] %s\n",
-		  (feed->type == DMX_TYPE_TS) ? "DMX_TYPE_TS" : "DMX_TYPE_SEC",
-		  feed->pid, add_not_remove ? "-> sf mode" : "sf mode ->");
-
-	if (add_not_remove)
-		ret = sf_add_feed(dmx, feed);
-	else
-		ret = sf_remove_feed(dmx, feed);
-
-	if (ret < 0) {
-		pr_error("sf %s feed fail[%d]\n",
-			 add_not_remove ? "add" : "remove", ret);
-	}
-	return ret;
-}
-
-static int dmx_add_feed(struct aml_dmx *dmx, struct dvb_demux_feed *feed)
-{
-	int id, ret = 0;
-	struct dvb_demux_filter *filter;
-	struct dvb_demux_feed *dfeed = NULL;
-	int sf_ret = 0;		/*<0:error, =0:sf_on, >0:sf_off */
-
-	sf_ret = sf_check_feed(dmx, feed, 1/*SF_FEED_OP_ADD */);
-	if (sf_ret < 0)
-		return sf_ret;
-
-	switch (feed->type) {
-	case DMX_TYPE_TS:
-		pr_dbg("%s: DMX_TYPE_TS\n", __func__);
-		ret = dmx_get_chan(dmx, feed->pid);
-		if (ret >= 0) {
-			if (DVR_FEED(dmx->channel[ret].feed)) {
-				if (DVR_FEED(feed)) {
-					/*dvr feed already work */
-					pr_error("PID %d already used(DVR)\n",
-						 feed->pid);
-					return -EBUSY;
-				}
-				if (sf_ret) {
-					/*if sf_on, we do not reset the
-					previous dvr feed, just load the pes
-					feed on the sf, a diffrent data path.*/
-					dfeed = dmx->channel[ret].feed;
-					dmx_remove_feed(dmx, dfeed);
-				}
-			} else {
-				if (DVR_FEED(feed)
-				    && (!dmx->channel[ret].dvr_feed)) {
-					/*just store the dvr_feed */
-					dmx->channel[ret].dvr_feed = feed;
-					feed->priv = (void *)(long)ret;
-					if (!dmx->record)
-						dmx_enable(dmx);
-					dmx_add_recchan(dmx->id, ret);
-					return 0;
-				} else {
-					pr_error("PID %d already used\n",
-						 feed->pid);
-					return -EBUSY;
-				}
-			}
-		}
-
-		if (sf_ret) {	/*not sf feed. */
-			ret =
-			     dmx_alloc_chan(dmx, feed->type,
-						feed->pes_type, feed->pid);
-			if (ret < 0) {
-				pr_dbg("%s: alloc chan error, ret=%d\n",
-				       __func__, ret);
-				return ret;
-			}
-			dmx->channel[ret].feed = feed;
-			feed->priv = (void *)(long)ret;
-			dmx->channel[ret].dvr_feed = NULL;
-		}
-		/*dvr */
-		if (DVR_FEED(feed)) {
-			dmx->channel[ret].dvr_feed = feed;
-			feed->priv = (void *)(long)ret;
-			if (!dmx->record)
-				dmx_enable(dmx);
-			dmx_add_recchan(dmx->id, ret);
-		} else if (dfeed && sf_ret) {
-			dmx->channel[ret].dvr_feed = dfeed;
-			dfeed->priv = (void *)(long)ret;
-			if (!dmx->record)
-				dmx_enable(dmx);
-			dmx_add_recchan(dmx->id, ret);
-		}
-
-		break;
-	case DMX_TYPE_SEC:
-		pr_dbg("%s: DMX_TYPE_SEC\n", __func__);
-		ret = dmx_get_chan(dmx, feed->pid);
-		if (ret >= 0) {
-			if (DVR_FEED(dmx->channel[ret].feed)) {
-				if (sf_ret) {
-					/*if sf_on, we do not reset the
-					previous dvr feed, just load the pes
-					feed on the sf,a diffrent data path.*/
-					dfeed = dmx->channel[ret].feed;
-					dmx_remove_feed(dmx, dfeed);
-				}
-			} else {
-				pr_error("PID %d already used\n", feed->pid);
-				return -EBUSY;
-			}
-		}
-		if (sf_ret) {	/*not sf feed. */
-			id = dmx_alloc_chan(dmx, feed->type,
-				feed->pes_type, feed->pid);
-			if (id < 0)
-				return id;
-			for (filter = feed->filter; filter;
-				filter = filter->next) {
-				ret = dmx_chan_add_filter(dmx, id, filter);
-				if (ret >= 0)
-					filter->hw_handle = ret;
-				else
-					filter->hw_handle = (u16)-1;
-			}
-			dmx->channel[id].feed = feed;
-			feed->priv = (void *)(long)id;
-			dmx->channel[id].dvr_feed = NULL;
-
-			if (dfeed) {
-				dmx->channel[id].dvr_feed = dfeed;
-				dfeed->priv = (void *)(long)id;
-				if (!dmx->record)
-					dmx_enable(dmx);
-				dmx_add_recchan(dmx->id, id);
-			}
-		}
-		break;
-	default:
-		return -EINVAL;
-		break;
-	}
-
-	dmx->feed_count++;
-
-	return 0;
-}
-
-static int dmx_remove_feed(struct aml_dmx *dmx, struct dvb_demux_feed *feed)
-{
-	struct dvb_demux_filter *filter;
-	struct dvb_demux_feed *dfeed = NULL;
-
-	int sf_ret = 0;		/*<0:error, =0:sf_on, >0:sf_off */
-
-	sf_ret = sf_check_feed(dmx, feed, 0/*SF_FEED_OP_RM */);
-	if (sf_ret <= 0)
-		return sf_ret;
-
-	switch (feed->type) {
-	case DMX_TYPE_TS:
-		if (dmx->channel[(long)feed->priv].feed ==
-		    dmx->channel[(long)feed->priv].dvr_feed) {
-			dmx_rm_recchan(dmx->id, (long)feed->priv);
-			dmx_free_chan(dmx, (long)feed->priv);
-		} else {
-			if (feed == dmx->channel[(long)feed->priv].feed) {
-				dfeed = dmx->channel[(long)feed->priv].dvr_feed;
-				dmx_rm_recchan(dmx->id, (long)feed->priv);
-				dmx_free_chan(dmx, (long)feed->priv);
-				if (dfeed) {
-					/*start the dvr feed */
-					dmx_add_feed(dmx, dfeed);
-				}
-			} else if (feed ==
-				   dmx->channel[(long)feed->priv].dvr_feed) {
-				/*just remove the dvr_feed */
-				dmx->channel[(long)feed->priv].dvr_feed = NULL;
-				dmx_rm_recchan(dmx->id,	(long)feed->priv);
-				if (dmx->record) {
-					dmx_enable(dmx);
-				}
-			} else {
-				/*This must never happen */
-				pr_error("%s: unknown feed\n", __func__);
-				return -EINVAL;
-			}
-		}
-
-		break;
-	case DMX_TYPE_SEC:
-		for (filter = feed->filter; filter; filter = filter->next) {
-			if (filter->hw_handle != (u16)-1)
-				dmx_remove_filter(dmx, (long)feed->priv,
-						  (int)filter->hw_handle);
-		}
-
-		dfeed = dmx->channel[(long)feed->priv].dvr_feed;
-		dmx_rm_recchan(dmx->id, (long)feed->priv);
-		dmx_free_chan(dmx, (long)feed->priv);
-		if (dfeed) {
-			/*start the dvr feed */
-			dmx_add_feed(dmx, dfeed);
-		}
-		break;
-	default:
-		return -EINVAL;
-		break;
-	}
-
-	dmx->feed_count--;
-	return 0;
-}
-
-int aml_dmx_hw_init(struct aml_dmx *dmx)
-{
-	/*
-	struct aml_dvb *dvb = (struct aml_dvb *)dmx->demux.priv;
-	unsigned long flags;
-	*/
-	int ret;
-
-	/*Demux initialize */
-	/*spin_lock_irqsave(&dvb->slock, flags);*/
-	ret = dmx_init(dmx);
-	/*spin_unlock_irqrestore(&dvb->slock, flags);*/
-
-	return ret;
-}
-
-int aml_dmx_hw_deinit(struct aml_dmx *dmx)
-{
-	struct aml_dvb *dvb = (struct aml_dvb *)dmx->demux.priv;
-	unsigned long flags;
-	int ret;
-	spin_lock_irqsave(&dvb->slock, flags);
-	ret = dmx_deinit(dmx);
-	spin_unlock_irqrestore(&dvb->slock, flags);
-
-	return ret;
-}
-
-/*extern void afifo_reset(int v);*/
-
-int aml_asyncfifo_hw_init(struct aml_asyncfifo *afifo)
-{
-
-/*
-	struct aml_dvb *dvb = afifo->dvb;
-	unsigned long flags;
-*/
-	int ret;
-
-	int len = ASYNCFIFO_BUFFER_SIZE_DEFAULT;
-	unsigned long buf = asyncfifo_alloc_buffer(len);
-	if (!buf)
-		return -1;
-
-	/*Async FIFO initialize*/
-/*
-	spin_lock_irqsave(&dvb->slock, flags);
-*/
-/*
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
-	CLK_GATE_ON(ASYNC_FIFO);
-#endif
-*/
-	/*afifo_reset(0);*/
-
-	WRITE_MPEG_REG(RESET6_REGISTER, (1<<11)|(1<<12));
-
-	ret = async_fifo_init(afifo, 1, len, buf);
-/*
-	spin_unlock_irqrestore(&dvb->slock, flags);
-*/
-	if (ret < 0)
-		asyncfifo_free_buffer(buf, len);
-
-	return ret;
-}
-
-int aml_asyncfifo_hw_deinit(struct aml_asyncfifo *afifo)
-{
-	struct aml_dvb *dvb = afifo->dvb;
-	unsigned long flags;
-	int ret;
-
-	spin_lock_irqsave(&dvb->slock, flags);
-	ret = async_fifo_deinit(afifo, 1);
-/*
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
-	CLK_GATE_OFF(ASYNC_FIFO);
-#endif
-*/
-	/*afifo_reset(1);*/
-
-	spin_unlock_irqrestore(&dvb->slock, flags);
-
-	return ret;
-}
-
-int aml_asyncfifo_hw_reset(struct aml_asyncfifo *afifo)
-{
-	struct aml_dvb *dvb = afifo->dvb;
-	unsigned long flags;
-	int ret, src = -1;
-
-	int len = ASYNCFIFO_BUFFER_SIZE_DEFAULT;
-	unsigned long buf = asyncfifo_alloc_buffer(len);
-	if (!buf)
-		return -1;
-
-	spin_lock_irqsave(&dvb->slock, flags);
-	if (afifo->init) {
-		src = afifo->source;
-		async_fifo_deinit(afifo, 0);
-	}
-	ret = async_fifo_init(afifo, 0, len, buf);
-	/* restore the source */
-	if (src != -1)
-		afifo->source = src;
-
-	if ((ret == 0) && afifo->dvb)
-		reset_async_fifos(afifo->dvb);
-
-	spin_unlock_irqrestore(&dvb->slock, flags);
-
-	if (ret < 0)
-		asyncfifo_free_buffer(buf, len);
-
-	return ret;
-}
-
-int aml_dmx_hw_start_feed(struct dvb_demux_feed *dvbdmxfeed)
-{
-	struct aml_dmx *dmx = (struct aml_dmx *)dvbdmxfeed->demux;
-	struct aml_dvb *dvb = (struct aml_dvb *)dmx->demux.priv;
-	unsigned long flags;
-	int ret = 0;
-
-	spin_lock_irqsave(&dvb->slock, flags);
-	ret = dmx_add_feed(dmx, dvbdmxfeed);
-	spin_unlock_irqrestore(&dvb->slock, flags);
-
-	return ret;
-}
-
-int aml_dmx_hw_stop_feed(struct dvb_demux_feed *dvbdmxfeed)
-{
-	struct aml_dmx *dmx = (struct aml_dmx *)dvbdmxfeed->demux;
-	struct aml_dvb *dvb = (struct aml_dvb *)dmx->demux.priv;
-	unsigned long flags;
-
-	spin_lock_irqsave(&dvb->slock, flags);
-	dmx_remove_feed(dmx, dvbdmxfeed);
-	spin_unlock_irqrestore(&dvb->slock, flags);
-
-	return 0;
-}
-
-int sf_dmx_track_source(struct aml_dmx *dmx)
-{
-	struct aml_dvb *dvb = (struct aml_dvb *)dmx->demux.priv;
-	struct aml_swfilter *sf = &dvb->swfilter;
-	if (sf->user && (dmx->id == sf->track_dmx)) {
-		pr_dbg_sf("tracking dmx src [%d -> %d]\n",
-			  sf->dmx->source, dmx->source);
-		sf->dmx->source = dmx->source;
-		dmx_reset_dmx_hw_ex_unlock(dvb, sf->dmx, 0);
-	}
-	return 0;
-}
-
-int aml_dmx_hw_set_source(struct dmx_demux *demux, enum dmx_source_t src)
-{
-	struct aml_dmx *dmx = (struct aml_dmx *)demux;
-	struct aml_dvb *dvb = (struct aml_dvb *)dmx->demux.priv;
-	int ret = 0;
-	int hw_src;
-	unsigned long flags;
-
-	if (sf_dmx_sf(dmx)) {
-		pr_error("%s: demux %d is in sf mode\n", __func__, dmx->id);
-		return -EINVAL;
-	}
-
-	spin_lock_irqsave(&dvb->slock, flags);
-
-	hw_src = dmx->source;
-
-	switch (src) {
-	case DMX_SOURCE_FRONT0:
-		hw_src =
-		    (dvb->ts[0].mode ==
-		     AM_TS_SERIAL) ? AM_TS_SRC_S_TS0 : AM_TS_SRC_TS0;
-		break;
-	case DMX_SOURCE_FRONT1:
-		hw_src =
-		    (dvb->ts[1].mode ==
-		     AM_TS_SERIAL) ? AM_TS_SRC_S_TS1 : AM_TS_SRC_TS1;
-		break;
-	case DMX_SOURCE_FRONT2:
-		hw_src =
-		    (dvb->ts[2].mode ==
-		     AM_TS_SERIAL) ? AM_TS_SRC_S_TS2 : AM_TS_SRC_TS2;
-		break;
-	case DMX_SOURCE_DVR0:
-		hw_src = AM_TS_SRC_HIU;
-		break;
-	default:
-		pr_error("illegal demux source %d\n", src);
-		ret = -EINVAL;
-		break;
-	}
-
-	if (hw_src != dmx->source) {
-		dmx->source = hw_src;
-		dmx_reset_dmx_hw_ex_unlock(dvb, dmx, 0);
-		sf_dmx_track_source(dmx);
-	}
-
-	spin_unlock_irqrestore(&dvb->slock, flags);
-
-	return ret;
-}
-
-#define IS_SRC_DMX(_src) ((_src) >= AM_TS_SRC_DMX0 && (_src) <= AM_TS_SRC_DMX2)
-
-int aml_stb_hw_set_source(struct aml_dvb *dvb, enum dmx_source_t src)
-{
-	unsigned long flags;
-	int hw_src;
-	int ret;
-	ret = 0;
-	spin_lock_irqsave(&dvb->slock, flags);
-
-	hw_src = dvb->stb_source;
-
-	switch (src) {
-	case DMX_SOURCE_FRONT0:
-		hw_src =
-		    (dvb->ts[0].mode ==
-		     AM_TS_SERIAL) ? AM_TS_SRC_S_TS0 : AM_TS_SRC_TS0;
-		break;
-	case DMX_SOURCE_FRONT1:
-		hw_src =
-		    (dvb->ts[1].mode ==
-		     AM_TS_SERIAL) ? AM_TS_SRC_S_TS1 : AM_TS_SRC_TS1;
-		break;
-	case DMX_SOURCE_FRONT2:
-		hw_src =
-		    (dvb->ts[2].mode ==
-		     AM_TS_SERIAL) ? AM_TS_SRC_S_TS2 : AM_TS_SRC_TS2;
-		break;
-	case DMX_SOURCE_DVR0:
-		hw_src = AM_TS_SRC_HIU;
-		break;
-	case DMX_SOURCE_FRONT0_OFFSET:
-		hw_src = AM_TS_SRC_DMX0;
-		break;
-	case DMX_SOURCE_FRONT1_OFFSET:
-		hw_src = AM_TS_SRC_DMX1;
-		break;
-	case DMX_SOURCE_FRONT2_OFFSET:
-		hw_src = AM_TS_SRC_DMX2;
-		break;
-	default:
-		pr_error("illegal demux source %d\n", src);
-		ret = -EINVAL;
-		break;
-	}
-
-	if (dvb->stb_source != hw_src) {
-		int old_source = dvb->stb_source;
-		dvb->stb_source = hw_src;
-
-		if (IS_SRC_DMX(old_source)) {
-			dmx_set_misc_id(dvb,
-				(old_source - AM_TS_SRC_DMX0), 0, -1);
-		} else {
-			/*which dmx for av-play is unknown,
-			can't avoid reset-all */
-			dmx_reset_hw_ex(dvb, 0);
-		}
-
-		if (IS_SRC_DMX(dvb->stb_source)) {
-			dmx_set_misc_id(dvb,
-				(dvb->stb_source - AM_TS_SRC_DMX0), 1, -1);
-			/*dmx_reset_dmx_id_hw_ex_unlock
-			   (dvb, (dvb->stb_source-AM_TS_SRC_DMX0), 0); */
-		} else {
-			/*which dmx for av-play is unknown,
-			can't avoid reset-all */
-			dmx_reset_hw_ex(dvb, 0);
-		}
-	}
-
-	spin_unlock_irqrestore(&dvb->slock, flags);
-
-	return ret;
-}
-
-int aml_dsc_hw_set_source(struct aml_dsc *dsc,
-			enum dmx_source_t src, enum dmx_source_t dst)
-{
-	struct aml_dvb *dvb = dsc->dvb;
-	int ret = 0;
-	unsigned long flags;
-	int hw_src = -1, hw_dst = -1, org_src = -1, org_dst = -1;
-	int src_reset = 0, dst_reset = 0;
-
-	spin_lock_irqsave(&dvb->slock, flags);
-
-	hw_src = dsc->source;
-	hw_dst = dsc->dst;
-
-	switch (src) {
-	case DMX_SOURCE_FRONT0_OFFSET:
-		hw_src = AM_TS_SRC_DMX0;
-		break;
-	case DMX_SOURCE_FRONT1_OFFSET:
-		hw_src = AM_TS_SRC_DMX1;
-		break;
-	case DMX_SOURCE_FRONT2_OFFSET:
-		hw_src = AM_TS_SRC_DMX2;
-		break;
-	default:
-		hw_src = -1;
-		break;
-	}
-	switch (dst) {
-	case DMX_SOURCE_FRONT0_OFFSET:
-		hw_dst = AM_TS_SRC_DMX0;
-		break;
-	case DMX_SOURCE_FRONT1_OFFSET:
-		hw_dst = AM_TS_SRC_DMX1;
-		break;
-	case DMX_SOURCE_FRONT2_OFFSET:
-		hw_dst = AM_TS_SRC_DMX2;
-		break;
-	default:
-		hw_dst = -1;
-		break;
-	}
-
-	if (hw_src != dsc->source) {
-		org_src = dsc->source;
-		dsc->source = hw_src;
-		src_reset = 1;
-	}
-	if (hw_dst != dsc->dst) {
-		org_dst = dsc->dst;
-		dsc->dst = hw_dst;
-		dst_reset = 1;
-	}
-
-	if (src_reset) {
-		pr_dbg("dsc%d source changed: %d -> %d\n",
-			dsc->id, org_src, hw_src);
-		if (org_src != -1) {
-			pr_dbg("reset dmx%d\n", (org_src - AM_TS_SRC_DMX0));
-			dmx_reset_dmx_id_hw_ex_unlock(dvb,
-					(org_src - AM_TS_SRC_DMX0), 0);
-		}
-		if (hw_src != -1) {
-			pr_dbg("reset dmx%d\n", (hw_src - AM_TS_SRC_DMX0));
-			dmx_reset_dmx_id_hw_ex_unlock(dvb,
-					(hw_src - AM_TS_SRC_DMX0), 0);
-		} else
-			dsc_enable(dsc, 0);
-	}
-	if (dst_reset) {
-		pr_dbg("dsc%d dest changed: %d -> %d\n",
-			dsc->id, org_dst, hw_dst);
-		if (((!src_reset) && (org_dst != -1)) ||
-			(src_reset && (org_dst != -1) &&
-			(org_dst != org_src) && (org_dst != hw_src))) {
-			pr_dbg("reset dmx%d\n", (org_dst - AM_TS_SRC_DMX0));
-			dmx_reset_dmx_id_hw_ex_unlock(dvb,
-					(org_dst - AM_TS_SRC_DMX0), 0);
-		}
-		if (((!src_reset) && (hw_dst != -1)) ||
-			(src_reset && (hw_dst != -1)
-			&& (hw_dst != org_src) && (hw_dst != hw_src))) {
-			pr_dbg("reset dmx%d\n", (hw_dst - AM_TS_SRC_DMX0));
-			dmx_reset_dmx_id_hw_ex_unlock(dvb,
-					(hw_dst - AM_TS_SRC_DMX0), 0);
-		}
-		if (hw_dst == -1)
-			dsc_enable(dsc, 0);
-	}
-
-	spin_unlock_irqrestore(&dvb->slock, flags);
-
-	return ret;
-}
-
-int aml_tso_hw_set_source(struct aml_dvb *dvb, enum dmx_source_t src)
-{
-	int ret = 0;
-	unsigned long flags;
-	int hw_src;
-
-	spin_lock_irqsave(&dvb->slock, flags);
-
-	hw_src = dvb->tso_source;
-
-	switch (src) {
-	case DMX_SOURCE_FRONT0:
-		hw_src = (dvb->ts[0].mode == AM_TS_SERIAL)
-		    ? AM_TS_SRC_S_TS0 : AM_TS_SRC_TS0;
-		break;
-	case DMX_SOURCE_FRONT1:
-		hw_src = (dvb->ts[1].mode == AM_TS_SERIAL)
-		    ? AM_TS_SRC_S_TS1 : AM_TS_SRC_TS1;
-		break;
-	case DMX_SOURCE_FRONT2:
-		hw_src = (dvb->ts[2].mode == AM_TS_SERIAL)
-		    ? AM_TS_SRC_S_TS2 : AM_TS_SRC_TS2;
-		break;
-	case DMX_SOURCE_DVR0:
-		hw_src = AM_TS_SRC_HIU;
-		break;
-	case DMX_SOURCE_FRONT0 + 100:
-		hw_src = AM_TS_SRC_DMX0;
-		break;
-	case DMX_SOURCE_FRONT1 + 100:
-		hw_src = AM_TS_SRC_DMX1;
-		break;
-	case DMX_SOURCE_FRONT2 + 100:
-		hw_src = AM_TS_SRC_DMX2;
-		break;
-	default:
-		hw_src = -1;
-		ret = -EINVAL;
-		break;
-	}
-
-	if (hw_src != dvb->tso_source) {
-		dvb->tso_source = hw_src;
-		stb_enable(dvb);
-	}
-
-	spin_unlock_irqrestore(&dvb->slock, flags);
-
-	return ret;
-}
-
-int aml_asyncfifo_hw_set_source(struct aml_asyncfifo *afifo,
-				enum aml_dmx_id_t src)
-{
-	struct aml_dvb *dvb = afifo->dvb;
-	int ret = -1;
-	unsigned long flags;
-
-	if (sf_afifo_sf(afifo)) {
-		pr_error("%s: afifo %d is in sf mode\n", __func__, afifo->id);
-		return -EINVAL;
-	}
-
-	spin_lock_irqsave(&dvb->slock, flags);
-
-	pr_dbg("asyncfifo %d set source %d->%d",
-						afifo->id, afifo->source, src);
-	switch (src) {
-	case AM_DMX_0:
-	case AM_DMX_1:
-	case AM_DMX_2:
-		if (afifo->source != src) {
-			afifo->source = src;
-			ret = 0;
-		}
-		break;
-	default:
-		pr_error("illegal async fifo source %d\n", src);
-		ret = -EINVAL;
-		break;
-	}
-
-	if (ret == 0 && afifo->dvb)
-		reset_async_fifos(afifo->dvb);
-
-	spin_unlock_irqrestore(&dvb->slock, flags);
-
-	return ret;
-}
-
-int aml_dmx_hw_set_dump_ts_select(struct dmx_demux *demux, int dump_ts_select)
-{
-	struct aml_dmx *dmx = (struct aml_dmx *)demux;
-	struct aml_dvb *dvb = (struct aml_dvb *)dmx->demux.priv;
-	int ret = 0;
-	unsigned long flags;
-
-	spin_lock_irqsave(&dvb->slock, flags);
-	dump_ts_select = !!dump_ts_select;
-	if (dmx->dump_ts_select != dump_ts_select) {
-		dmx->dump_ts_select = dump_ts_select;
-		dmx_reset_dmx_hw_ex_unlock(dvb, dmx, 0);
-	}
-	spin_unlock_irqrestore(&dvb->slock, flags);
-
-	return ret;
-}
-
-u32 aml_dmx_get_video_pts(struct aml_dvb *dvb)
-{
-	unsigned long flags;
-	u32 pts;
-
-	spin_lock_irqsave(&dvb->slock, flags);
-	pts = video_pts;
-	spin_unlock_irqrestore(&dvb->slock, flags);
-
-	return pts;
-}
-
-u32 aml_dmx_get_audio_pts(struct aml_dvb *dvb)
-{
-	unsigned long flags;
-	u32 pts;
-
-	spin_lock_irqsave(&dvb->slock, flags);
-	pts = audio_pts;
-	spin_unlock_irqrestore(&dvb->slock, flags);
-
-	return pts;
-}
-
-u32 aml_dmx_get_first_video_pts(struct aml_dvb *dvb)
-{
-	unsigned long flags;
-	u32 pts;
-
-	spin_lock_irqsave(&dvb->slock, flags);
-	pts = first_video_pts;
-	spin_unlock_irqrestore(&dvb->slock, flags);
-
-	return pts;
-}
-
-u32 aml_dmx_get_first_audio_pts(struct aml_dvb *dvb)
-{
-	unsigned long flags;
-	u32 pts;
-
-	spin_lock_irqsave(&dvb->slock, flags);
-	pts = first_audio_pts;
-	spin_unlock_irqrestore(&dvb->slock, flags);
-
-	return pts;
-}
-
-int aml_dmx_set_skipbyte(struct aml_dvb *dvb, int skipbyte)
-{
-	if (demux_skipbyte != skipbyte) {
-		pr_dbg("set skip byte %d\n", skipbyte);
-		demux_skipbyte = skipbyte;
-		dmx_reset_hw_ex(dvb, 0);
-	}
-
-	return 0;
-}
-
-int aml_dmx_set_demux(struct aml_dvb *dvb, int id)
-{
-	aml_stb_hw_set_source(dvb, DMX_SOURCE_DVR0);
-	if (id < DMX_DEV_COUNT) {
-		struct aml_dmx *dmx = &dvb->dmx[id];
-		aml_dmx_hw_set_source((struct dmx_demux *)dmx,
-							DMX_SOURCE_DVR0);
-	}
-
-	return 0;
-}
-
-int _set_tsfile_clkdiv(struct aml_dvb *dvb, int clkdiv)
-{
-	if (tsfile_clkdiv != clkdiv) {
-		pr_dbg("set ts file clock div %d\n", clkdiv);
-		tsfile_clkdiv = clkdiv;
-		dmx_reset_hw(dvb);
-	}
-
-	return 0;
-}
-
-static ssize_t stb_set_tsfile_clkdiv(struct class *class,
-				     struct class_attribute *attr,
-				     const char *buf, size_t size)
-{
-	/*int div = (int)simple_strtol(buf, NULL, 10);*/
-	long div;
-	if (kstrtol(buf, 0, &div) == 0)
-		_set_tsfile_clkdiv(aml_get_dvb_device(), (int)div);
-	return size;
-}
-
-static ssize_t stb_get_tsfile_clkdiv(struct class *class,
-				     struct class_attribute *attr, char *buf)
-{
-	ssize_t ret;
-	ret = sprintf(buf, "%d\n", tsfile_clkdiv);
-	return ret;
-}
-
-
-static int dmx_id;
-
-static ssize_t dmx_smallsec_show(struct class *class,
-				     struct class_attribute *attr, char *buf)
-{
-	ssize_t ret;
-	struct aml_dvb *dvb = aml_get_dvb_device();
-	ret = sprintf(buf, "%d:%d\n", dvb->dmx[dmx_id].smallsec.enable,
-					dvb->dmx[dmx_id].smallsec.bufsize);
-	return ret;
-}
-static ssize_t dmx_smallsec_store(struct class *class,
-				     struct class_attribute *attr,
-				     const char *buf, size_t size)
-{
-	int i, e, s = 0, f = 0;
-	struct aml_dvb *dvb = aml_get_dvb_device();
-
-	i = sscanf(buf, "%d:%i:%d", &e, &s, &f);
-	if (i <= 0)
-		return size;
-
-	dmx_smallsec_set(&dvb->dmx[dmx_id].smallsec, e, s, f);
-	return size;
-}
-
-static ssize_t dmx_timeout_show(struct class *class,
-				     struct class_attribute *attr, char *buf)
-{
-	ssize_t ret;
-	struct aml_dvb *dvb = aml_get_dvb_device();
-	ret = sprintf(buf, "%d:%d:0x%x:%d:%d\n",
-				dvb->dmx[dmx_id].timeout.enable,
-				dvb->dmx[dmx_id].timeout.timeout,
-				dvb->dmx[dmx_id].timeout.ch_disable,
-				dvb->dmx[dmx_id].timeout.match,
-		(DMX_READ_REG(dmx_id, STB_INT_STATUS)&(1<<INPUT_TIME_OUT)) ?
-			1 : 0);
-	DMX_WRITE_REG(dmx_id, STB_INT_STATUS, (1<<INPUT_TIME_OUT));
-	return ret;
-}
-static ssize_t dmx_timeout_store(struct class *class,
-				     struct class_attribute *attr,
-				     const char *buf, size_t size)
-{
-	int i, e, t = 0, c = 0, m = 0, f = 0;
-	struct aml_dvb *dvb = aml_get_dvb_device();
-
-	i = sscanf(buf, "%d:%i:%i:%d:%d", &e, &t, &c, &m, &f);
-	if (i <= 0)
-		return size;
-
-	dmx_timeout_set(&dvb->dmx[dmx_id].timeout, e, t, c, m, f);
-	return size;
-}
-
-
-#define DEMUX_SCAMBLE_FUNC_DECL(i)  \
-static ssize_t dmx_reg_value_show_demux##i##_scramble(struct class *class,  \
-struct class_attribute *attr, char *buf)\
-{\
-	int data = 0;\
-	int aflag = 0;\
-	int vflag = 0;\
-	ssize_t ret = 0;\
-	data = DMX_READ_REG(i, DEMUX_SCRAMBLING_STATE);\
-	if ((data & 0x01) == 0x01) \
-		vflag = 1;\
-	if ((data & 0x02) == 0x02) \
-		aflag = 1;\
-	ret = sprintf(buf, "%d %d\n", vflag, aflag);\
-	return ret;\
-}
-
-#if DMX_DEV_COUNT > 0
-DEMUX_SCAMBLE_FUNC_DECL(0)
-#endif
-#if DMX_DEV_COUNT > 1
-DEMUX_SCAMBLE_FUNC_DECL(1)
-#endif
-#if DMX_DEV_COUNT > 2
-DEMUX_SCAMBLE_FUNC_DECL(2)
-#endif
-
-static ssize_t dmx_reg_addr_show_source(struct class *class,
-					struct class_attribute *attr,
-					char *buf);
-static ssize_t dmx_reg_addr_store_source(struct class *class,
-					 struct class_attribute *attr,
-					 const char *buf, size_t size);
-static ssize_t dmx_id_show_source(struct class *class,
-				  struct class_attribute *attr, char *buf);
-static ssize_t dmx_id_store_source(struct class *class,
-				   struct class_attribute *attr,
-				   const char *buf, size_t size);
-static ssize_t dmx_reg_value_show_source(struct class *class,
-					 struct class_attribute *attr,
-					 char *buf);
-static ssize_t dmx_reg_value_store_source(struct class *class,
-					  struct class_attribute *attr,
-					  const char *buf, size_t size);
-
-static int reg_addr;
-
-static struct class_attribute aml_dmx_class_attrs[] = {
-	__ATTR(dmx_id, S_IRUGO | S_IWUSR, dmx_id_show_source,
-	       dmx_id_store_source),
-	__ATTR(register_addr, S_IRUGO | S_IWUSR, dmx_reg_addr_show_source,
-	       dmx_reg_addr_store_source),
-	__ATTR(register_value, S_IRUGO | S_IWUSR, dmx_reg_value_show_source,
-	       dmx_reg_value_store_source),
-	__ATTR(tsfile_clkdiv, S_IRUGO | S_IWUSR, stb_get_tsfile_clkdiv,
-	       stb_set_tsfile_clkdiv),
-
-#define DEMUX_SCAMBLE_ATTR_DECL(i)\
-		__ATTR(demux##i##_scramble,  S_IRUGO | S_IWUSR, \
-		dmx_reg_value_show_demux##i##_scramble, NULL)
-#if DMX_DEV_COUNT > 0
-	DEMUX_SCAMBLE_ATTR_DECL(0),
-#endif
-#if DMX_DEV_COUNT > 1
-	DEMUX_SCAMBLE_ATTR_DECL(1),
-#endif
-#if DMX_DEV_COUNT > 2
-	DEMUX_SCAMBLE_ATTR_DECL(2),
-#endif
-
-	__ATTR(dmx_smallsec,  S_IRUGO | S_IWUSR,
-			dmx_smallsec_show,
-			dmx_smallsec_store),
-	__ATTR(dmx_timeout,  S_IRUGO | S_IWUSR,
-			dmx_timeout_show,
-			dmx_timeout_store),
-
-	__ATTR_NULL
-};
-
-static struct class aml_dmx_class = {
-	.name = "dmx",
-	.class_attrs = aml_dmx_class_attrs,
-};
-
-static ssize_t dmx_id_show_source(struct class *class,
-				  struct class_attribute *attr, char *buf)
-{
-	int ret;
-	ret = sprintf(buf, "%d\n", dmx_id);
-	return ret;
-}
-
-static ssize_t dmx_id_store_source(struct class *class,
-				   struct class_attribute *attr,
-				   const char *buf, size_t size)
-{
-	int id = 0;
-	long value = 0;
-	if (kstrtol(buf, 0, &value) == 0)
-		id = (int)value;
-	/*id = simple_strtol(buf, 0, 16);*/
-
-	if (id < 0 || id > 2)
-		pr_dbg("dmx id must 0 ~2\n");
-	else
-		dmx_id = id;
-
-	return size;
-}
-
-static ssize_t dmx_reg_addr_show_source(struct class *class,
-					struct class_attribute *attr,
-					 char *buf)
-{
-	int ret;
-	ret = sprintf(buf, "%x\n", reg_addr);
-	return ret;
-}
-
-static ssize_t dmx_reg_addr_store_source(struct class *class,
-					 struct class_attribute *attr,
-					 const char *buf, size_t size)
-{
-	int addr = 0;
-	/*addr = simple_strtol(buf, 0, 16);*/
-	long value = 0;
-	if (kstrtol(buf, 0, &value) == 0)
-		addr = (int)value;
-	reg_addr = addr;
-	return size;
-}
-
-static ssize_t dmx_reg_value_show_source(struct class *class,
-					 struct class_attribute *attr,
-					 char *buf)
-{
-	int ret, value;
-	value = READ_MPEG_REG(reg_addr);
-	ret = sprintf(buf, "%x\n", value);
-	return ret;
-}
-
-static ssize_t dmx_reg_value_store_source(struct class *class,
-					  struct class_attribute *attr,
-					  const char *buf, size_t size)
-{
-	int value = 0;
-	/*value = simple_strtol(buf, 0, 16);*/
-	long val = 0;
-	if (kstrtol(buf, 0, &val) == 0)
-		value = (int)val;
-	WRITE_MPEG_REG(reg_addr, value);
-	return size;
-}
-
-int aml_regist_dmx_class(void)
-{
-
-	if (class_register(&aml_dmx_class) < 0)
-		pr_error("register class error\n");
-
-	return 0;
-}
-
-int aml_unregist_dmx_class(void)
-{
-
-	class_unregister(&aml_dmx_class);
-	return 0;
-}
-
-static struct aml_dmx *get_dmx_from_src(enum aml_ts_source_t src)
-{
-	int i;
-	struct aml_dvb *dvb = aml_get_dvb_device();
-	struct aml_dmx *dmx = NULL;
-	if (dvb) {
-		switch (src) {
-		case AM_TS_SRC_TS0:
-		case AM_TS_SRC_TS1:
-		case AM_TS_SRC_TS2:
-		case AM_TS_SRC_S_TS0:
-		case AM_TS_SRC_S_TS1:
-		case AM_TS_SRC_S_TS2:
-			for (i = 0; i < 3; i++) {
-				if (dvb->dmx[i].source == src) {
-					dmx = &dvb->dmx[i];
-					break;
-				}
-				break;
-		case AM_TS_SRC_DMX0:
-				/*if (0 > DMX_DEV_COUNT) */
-				/*dmx = &dvb->dmx[0]; */
-				break;
-		case AM_TS_SRC_DMX1:
-				/*if (1 > DMX_DEV_COUNT) */
-				/*dmx = &dvb->dmx[1]; */
-				break;
-		case AM_TS_SRC_DMX2:
-				/*if (2 > DMX_DEV_COUNT) */
-				/*dmx = &dvb->dmx[2]; */
-				break;
-		default:
-				break;
-			}
-		}
-	}
-	return dmx;
-
-}
-
-void aml_dmx_register_frontend(enum aml_ts_source_t src,
-			       struct dvb_frontend *fe)
-{
-	unsigned long flags;
-	struct aml_dvb *dvb = aml_get_dvb_device();
-	struct aml_dmx *dmx = get_dmx_from_src(src);
-
-	spin_lock_irqsave(&dvb->slock, flags);
-
-	if (dmx)
-		dmx->fe = fe;
-
-	spin_unlock_irqrestore(&dvb->slock, flags);
-}
-
-void aml_dmx_before_retune(enum aml_ts_source_t src, struct dvb_frontend *fe)
-{
-	unsigned long flags;
-	struct aml_dvb *dvb = aml_get_dvb_device();
-	struct aml_dmx *dmx = get_dmx_from_src(src);
-
-	spin_lock_irqsave(&dvb->slock, flags);
-
-	if (dmx) {
-		dmx->fe = fe;
-		dmx->in_tune = 1;
-		DMX_WRITE_REG(dmx->id, STB_INT_MASK, 0);
-	}
-
-	spin_unlock_irqrestore(&dvb->slock, flags);
-}
-
-void aml_dmx_after_retune(enum aml_ts_source_t src, struct dvb_frontend *fe)
-{
-	unsigned long flags;
-	struct aml_dvb *dvb = aml_get_dvb_device();
-	struct aml_dmx *dmx = get_dmx_from_src(src);
-
-	spin_lock_irqsave(&dvb->slock, flags);
-
-	if (dmx) {
-		dmx->fe = fe;
-		dmx->in_tune = 0;
-		DMX_WRITE_REG(dmx->id, STB_INT_MASK, DEMUX_INT_MASK);
-	}
-
-	spin_unlock_irqrestore(&dvb->slock, flags);
-}
-EXPORT_SYMBOL(aml_dmx_after_retune);
-
-void aml_dmx_start_error_check(enum aml_ts_source_t src,
-			       struct dvb_frontend *fe)
-{
-	unsigned long flags;
-	struct aml_dvb *dvb = aml_get_dvb_device();
-	struct aml_dmx *dmx = get_dmx_from_src(src);
-
-	spin_lock_irqsave(&dvb->slock, flags);
-
-	if (dmx) {
-		dmx->fe = fe;
-		dmx->error_check = 0;
-		dmx->int_check_time = 0;
-		DMX_WRITE_REG(dmx->id, STB_INT_MASK, DEMUX_INT_MASK);
-	}
-
-	spin_unlock_irqrestore(&dvb->slock, flags);
-}
-EXPORT_SYMBOL(aml_dmx_start_error_check);
-
-int aml_dmx_stop_error_check(enum aml_ts_source_t src, struct dvb_frontend *fe)
-{
-	unsigned long flags;
-	int ret = 0;
-
-	struct aml_dvb *dvb = aml_get_dvb_device();
-	struct aml_dmx *dmx = get_dmx_from_src(src);
-
-	spin_lock_irqsave(&dvb->slock, flags);
-
-	if (dmx) {
-		dmx->fe = fe;
-		ret = dmx->error_check;
-		DMX_WRITE_REG(dmx->id, STB_INT_MASK, DEMUX_INT_MASK);
-	}
-
-	spin_unlock_irqrestore(&dvb->slock, flags);
-
-	return ret;
-}
-EXPORT_SYMBOL(aml_dmx_stop_error_check);
diff --git a/drivers/amlogic/dvb_tv/aml_dvb.c b/drivers/amlogic/dvb_tv/aml_dvb.c
deleted file mode 100644
index 0c21f6d27547..000000000000
--- a/drivers/amlogic/dvb_tv/aml_dvb.c
+++ /dev/null
@@ -1,1857 +0,0 @@
- /*
-  * AMLOGIC DVB driver.
-  */
-
-#define ENABLE_DEMUX_DRIVER
-
-#include <linux/version.h>
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/mutex.h>
-#include <linux/wait.h>
-#include <linux/string.h>
-#include <linux/interrupt.h>
-#include <linux/fs.h>
-#include <linux/cdev.h>
-#include <linux/device.h>
-#include <linux/spinlock.h>
-#include <linux/fcntl.h>
-#include <asm/irq.h>
-#include <linux/uaccess.h>
-#include <linux/poll.h>
-#include <linux/delay.h>
-#include <linux/platform_device.h>
-#include <linux/amlogic/amports/amstream.h>
-#ifdef ARC_700
-#include <asm/arch/am_regs.h>
-#else
-#include "c_stb_define.h"
-#include "c_stb_regs_define.h"
-#endif
-
-/*#include <mach/mod_gate.h>*/
-#include <linux/gpio.h>
-#include <linux/spinlock.h>
-#include <linux/amlogic/amdsc.h>
-#include <linux/string.h>
-#include <linux/pinctrl/consumer.h>
-
-#include <linux/reset.h>
-
-#include "linux/amlogic/cpu_version.h"
-
-#include "aml_dvb.h"
-#include "aml_dvb_reg.h"
-
-#define pr_dbg(args...)\
-	do {\
-		if (debug_dvb)\
-			printk(args);\
-	} while (0)
-#define pr_error(fmt, args...) printk("DVB: " fmt, ## args)
-#define pr_inf(fmt, args...)   printk("DVB: " fmt, ## args)
-
-MODULE_PARM_DESC(debug_dvb, "\n\t\t Enable dvb debug information");
-static int debug_dvb = 1;
-module_param(debug_dvb, int, 0644);
-
-#define CARD_NAME "amlogic-dvb"
-
-DVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);
-
-MODULE_PARM_DESC(dsc_max, "max number of dsc");
-static int dsc_max = DSC_DEV_COUNT;
-module_param(dsc_max, int, 0644);
-
-static struct aml_dvb aml_dvb_device;
-static struct class aml_stb_class;
-static struct reset_control *aml_dvb_demux_reset_ctl;
-static struct reset_control *aml_dvb_afifo_reset_ctl;
-static struct reset_control *aml_dvb_ahbarb0_reset_ctl;
-static struct reset_control *aml_dvb_uparsertop_reset_ctl;
-
-
-static int aml_tsdemux_reset(void);
-static int aml_tsdemux_set_reset_flag(void);
-static int aml_tsdemux_request_irq(irq_handler_t handler, void *data);
-static int aml_tsdemux_free_irq(void);
-static int aml_tsdemux_set_vid(int vpid);
-static int aml_tsdemux_set_aid(int apid);
-static int aml_tsdemux_set_sid(int spid);
-static int aml_tsdemux_set_pcrid(int pcrpid);
-static int aml_tsdemux_set_skipbyte(int skipbyte);
-static int aml_tsdemux_set_demux(int id);
-
-static struct tsdemux_ops aml_tsdemux_ops = {
-	.reset = aml_tsdemux_reset,
-	.set_reset_flag = aml_tsdemux_set_reset_flag,
-	.request_irq = aml_tsdemux_request_irq,
-	.free_irq = aml_tsdemux_free_irq,
-	.set_vid = aml_tsdemux_set_vid,
-	.set_aid = aml_tsdemux_set_aid,
-	.set_sid = aml_tsdemux_set_sid,
-	.set_pcrid = aml_tsdemux_set_pcrid,
-	.set_skipbyte = aml_tsdemux_set_skipbyte,
-	.set_demux = aml_tsdemux_set_demux
-};
-
-static int control_ts_on_csi_port(int tsin, int enable)
-{
-/*#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8*/
-	if (is_meson_m8_cpu() || is_meson_m8b_cpu() || is_meson_m8m2_cpu()) {
-		unsigned int temp_data;
-		if (tsin == 2 && enable) {
-			/*TS2 is on CSI port. */
-			/*power on mipi csi phy */
-			pr_error("power on mipi csi phy for TSIN2\n");
-			WRITE_CBUS_REG(HHI_CSI_PHY_CNTL0, 0xfdc1ff81);
-			WRITE_CBUS_REG(HHI_CSI_PHY_CNTL1, 0x3fffff);
-			temp_data = READ_CBUS_REG(HHI_CSI_PHY_CNTL2);
-			temp_data &= 0x7ff00000;
-			temp_data |= 0x80000fc0;
-			WRITE_CBUS_REG(HHI_CSI_PHY_CNTL2, temp_data);
-		}
-	}
-/*#endif*/
-	return 0;
-}
-
-static void aml_dvb_dmx_release(struct aml_dvb *advb, struct aml_dmx *dmx)
-{
-	int i;
-
-	dvb_net_release(&dmx->dvb_net);
-	aml_dmx_hw_deinit(dmx);
-	dmx->demux.dmx.close(&dmx->demux.dmx);
-	dmx->demux.dmx.remove_frontend(&dmx->demux.dmx, &dmx->mem_fe);
-
-	for (i = 0; i < DMX_DEV_COUNT; i++)
-		dmx->demux.dmx.remove_frontend(&dmx->demux.dmx, &dmx->hw_fe[i]);
-
-	dvb_dmxdev_release(&dmx->dmxdev);
-	dvb_dmx_release(&dmx->demux);
-}
-
-static int aml_dvb_dmx_init(struct aml_dvb *advb, struct aml_dmx *dmx, int id)
-{
-	int i, ret;
-#ifndef CONFIG_OF
-	struct resource *res;
-	char buf[32];
-#endif
-	switch (id) {
-	case 0:
-		dmx->dmx_irq = INT_DEMUX;
-		break;
-	case 1:
-		dmx->dmx_irq = INT_DEMUX_1;
-		break;
-	case 2:
-		dmx->dmx_irq = INT_DEMUX_2;
-		break;
-	}
-
-#ifndef CONFIG_OF
-	snprintf(buf, sizeof(buf), "demux%d_irq", id);
-	res = platform_get_resource_byname(advb->pdev, IORESOURCE_IRQ, buf);
-	if (res)
-		dmx->dmx_irq = res->start;
-#endif
-
-	dmx->source = -1;
-	dmx->dump_ts_select = 0;
-	dmx->dvr_irq = -1;
-
-	dmx->demux.dmx.capabilities =
-	    (DMX_TS_FILTERING | DMX_SECTION_FILTERING | DMX_PES_FILTERING |
-	     DMX_MEMORY_BASED_FILTERING | DMX_TS_DESCRAMBLING);
-	dmx->demux.filternum = dmx->demux.feednum = FILTER_COUNT;
-	dmx->demux.priv = advb;
-	dmx->demux.start_feed = aml_dmx_hw_start_feed;
-	dmx->demux.stop_feed = aml_dmx_hw_stop_feed;
-	dmx->demux.write_to_decoder = NULL;
-	ret = dvb_dmx_init(&dmx->demux);
-	if (ret < 0) {
-		pr_error("dvb_dmx failed: error %d\n", ret);
-		goto error_dmx_init;
-	}
-
-	dmx->dmxdev.filternum = dmx->demux.feednum;
-	dmx->dmxdev.demux = &dmx->demux.dmx;
-	dmx->dmxdev.capabilities = 0;
-	ret = dvb_dmxdev_init(&dmx->dmxdev, &advb->dvb_adapter);
-	if (ret < 0) {
-		pr_error("dvb_dmxdev_init failed: error %d\n", ret);
-		goto error_dmxdev_init;
-	}
-
-	for (i = 0; i < DMX_DEV_COUNT; i++) {
-		int source = i + DMX_FRONTEND_0;
-		dmx->hw_fe[i].source = source;
-		ret =
-		    dmx->demux.dmx.add_frontend(&dmx->demux.dmx,
-						&dmx->hw_fe[i]);
-		if (ret < 0) {
-			pr_error("adding hw_frontend to dmx failed: error %d",
-				 ret);
-			dmx->hw_fe[i].source = 0;
-			goto error_add_hw_fe;
-		}
-	}
-
-	dmx->mem_fe.source = DMX_MEMORY_FE;
-	ret = dmx->demux.dmx.add_frontend(&dmx->demux.dmx, &dmx->mem_fe);
-	if (ret < 0) {
-		pr_error("adding mem_frontend to dmx failed: error %d", ret);
-		goto error_add_mem_fe;
-	}
-	ret = dmx->demux.dmx.connect_frontend(&dmx->demux.dmx, &dmx->hw_fe[1]);
-	if (ret < 0) {
-		pr_error("connect frontend failed: error %d", ret);
-		goto error_connect_fe;
-	}
-
-	dmx->id = id;
-	dmx->aud_chan = -1;
-	dmx->vid_chan = -1;
-	dmx->sub_chan = -1;
-	dmx->pcr_chan = -1;
-
-	/*smallsec*/
-	dmx->smallsec.enable = 0;
-	dmx->smallsec.bufsize = SS_BUFSIZE_DEF;
-	dmx->smallsec.dmx = dmx;
-
-	/*input timeout*/
-	dmx->timeout.enable = 1;
-	dmx->timeout.timeout = DTO_TIMEOUT_DEF;
-	dmx->timeout.ch_disable = DTO_CHDIS_VAS;
-	dmx->timeout.match = 1;
-	dmx->timeout.trigger = 0;
-	dmx->timeout.dmx = dmx;
-
-	ret = aml_dmx_hw_init(dmx);
-	if (ret < 0) {
-		pr_error("demux hw init error %d", ret);
-		dmx->id = -1;
-		goto error_dmx_hw_init;
-	}
-
-	dvb_net_init(&advb->dvb_adapter, &dmx->dvb_net, &dmx->demux.dmx);
-
-	return 0;
-error_dmx_hw_init:
-error_connect_fe:
-	dmx->demux.dmx.remove_frontend(&dmx->demux.dmx, &dmx->mem_fe);
-error_add_mem_fe:
-error_add_hw_fe:
-	for (i = 0; i < DMX_DEV_COUNT; i++) {
-		if (dmx->hw_fe[i].source)
-			dmx->demux.dmx.remove_frontend(&dmx->demux.dmx,
-						       &dmx->hw_fe[i]);
-	}
-	dvb_dmxdev_release(&dmx->dmxdev);
-error_dmxdev_init:
-	dvb_dmx_release(&dmx->demux);
-error_dmx_init:
-	return ret;
-}
-
-struct aml_dvb *aml_get_dvb_device(void)
-{
-	return &aml_dvb_device;
-}
-EXPORT_SYMBOL(aml_get_dvb_device);
-
-static int dvb_dsc_open(struct inode *inode, struct file *file)
-{
-	struct dvb_device *dvbdev = file->private_data;
-	struct aml_dsc *dsc = dvbdev->priv;
-	struct aml_dvb *dvb = dsc->dvb;
-	struct aml_dsc_channel *ch = NULL;
-	int id;
-	unsigned long flags;
-
-	spin_lock_irqsave(&dvb->slock, flags);
-
-	for (id = 0; id < DSC_COUNT; id++) {
-		ch = &dsc->channel[id];
-		if (!ch->used) {
-			ch->used = 1;
-			dsc->dev->users++;
-			break;
-		}
-	}
-
-	spin_unlock_irqrestore(&dvb->slock, flags);
-
-	if (!ch || (id >= DSC_COUNT)) {
-		pr_error("too many descrambler channels\n");
-		return -EBUSY;
-	}
-
-	ch->id = id;
-	ch->pid = 0x1fff;
-	ch->set = 0;
-	ch->dsc = dsc;
-
-	file->private_data = ch;
-	return 0;
-}
-
-static long dvb_dsc_ioctl(struct file *file, unsigned int cmd,
-			  unsigned long arg)
-{
-	struct aml_dsc_channel *ch = file->private_data;
-	struct aml_dvb *dvb = ch->dsc->dvb;
-	struct am_dsc_key key;
-	int ret = 0;
-	unsigned long flags;
-
-	spin_lock_irqsave(&dvb->slock, flags);
-
-	switch (cmd) {
-	case AMDSC_IOC_SET_PID:
-		if (ch->used && (ch->pid == arg))
-			ret = -EBUSY;
-		ch->pid = arg;
-		dsc_set_pid(ch, ch->pid);
-		break;
-	case AMDSC_IOC_SET_KEY:
-		if (copy_from_user
-		    (&key, (void __user *)arg, sizeof(struct am_dsc_key))) {
-			ret = -EFAULT;
-		} else {
-			if (key.type)
-				memcpy(ch->odd, key.key, 8);
-			else
-				memcpy(ch->even, key.key, 8);
-			ch->set |= 1 << (key.type);
-			dsc_set_key(ch, key.type, key.key);
-		}
-		break;
-	default:
-		ret = -EINVAL;
-		break;
-	}
-
-	spin_unlock_irqrestore(&dvb->slock, flags);
-
-	return ret;
-}
-
-static int dvb_dsc_release(struct inode *inode, struct file *file)
-{
-	struct aml_dsc_channel *ch = file->private_data;
-	struct aml_dvb *dvb = ch->dsc->dvb;
-	unsigned long flags;
-
-	/*dvb_generic_release(inode, file); */
-
-	spin_lock_irqsave(&dvb->slock, flags);
-
-	ch->used = 0;
-	dsc_set_pid(ch, 0x1fff);
-
-	ch->pid = 0x1fff;
-	ch->set = 0;
-	ch->dsc->dev->users--;
-
-	spin_unlock_irqrestore(&dvb->slock, flags);
-
-	return 0;
-}
-
-#ifdef CONFIG_COMPAT
-static long dvb_dsc_compat_ioctl(struct file *filp,
-			unsigned int cmd, unsigned long args)
-{
-	unsigned long ret;
-
-	args = (unsigned long)compat_ptr(args);
-	ret = dvb_dsc_ioctl(filp, cmd, args);
-	return ret;
-}
-#endif
-
-
-static const struct file_operations dvb_dsc_fops = {
-	.owner = THIS_MODULE,
-	.read = NULL,
-	.write = NULL,
-	.unlocked_ioctl = dvb_dsc_ioctl,
-	.open = dvb_dsc_open,
-	.release = dvb_dsc_release,
-	.poll = NULL,
-#ifdef CONFIG_COMPAT
-	.compat_ioctl	= dvb_dsc_compat_ioctl,
-#endif
-};
-
-static struct dvb_device dvbdev_dsc = {
-	.priv = NULL,
-	.users = DSC_COUNT,
-	.writers = DSC_COUNT,
-	.fops = &dvb_dsc_fops,
-};
-
-static int aml_dvb_asyncfifo_init(struct aml_dvb *advb,
-				  struct aml_asyncfifo *asyncfifo, int id)
-{
-#ifndef CONFIG_OF
-	struct resource *res;
-	char buf[32];
-#endif
-
-	if (id == 0)
-		asyncfifo->asyncfifo_irq = INT_ASYNC_FIFO_FLUSH;
-	else
-		asyncfifo->asyncfifo_irq = INT_ASYNC_FIFO2_FLUSH;
-
-#ifndef CONFIG_OF
-	snprintf(buf, sizeof(buf), "dvr%d_irq", id);
-	res = platform_get_resource_byname(advb->pdev, IORESOURCE_IRQ, buf);
-	if (res)
-		asyncfifo->asyncfifo_irq = res->start;
-#endif
-
-	asyncfifo->dvb = advb;
-	asyncfifo->id = id;
-	asyncfifo->init = 0;
-	asyncfifo->flush_size = 256 * 1024;
-
-	return aml_asyncfifo_hw_init(asyncfifo);
-}
-
-static void aml_dvb_asyncfifo_release(struct aml_dvb *advb,
-				      struct aml_asyncfifo *asyncfifo)
-{
-	aml_asyncfifo_hw_deinit(asyncfifo);
-}
-
-static int aml_dvb_dsc_init(struct aml_dvb *advb,
-				  struct aml_dsc *dsc, int id)
-{
-	int i;
-
-	for (i = 0; i < DSC_COUNT; i++) {
-		dsc->channel[i].id = i;
-		dsc->channel[i].used = 0;
-		dsc->channel[i].set = 0;
-		dsc->channel[i].pid = 0x1fff;
-		dsc->channel[i].dsc = dsc;
-	}
-	dsc->dvb = advb;
-	dsc->id = id;
-	dsc->source = -1;
-	dsc->dst = -1;
-
-	/*Register descrambler device */
-	return dvb_register_device(&advb->dvb_adapter, &dsc->dev,
-				  &dvbdev_dsc, dsc, DVB_DEVICE_DSC);
-}
-static void aml_dvb_dsc_release(struct aml_dvb *advb,
-				      struct aml_dsc *dsc)
-{
-	if (dsc->dev)
-		dvb_unregister_device(dsc->dev);
-	dsc->dev = NULL;
-}
-
-
-/*Show the STB input source*/
-static ssize_t stb_show_source(struct class *class,
-			       struct class_attribute *attr, char *buf)
-{
-	struct aml_dvb *dvb = &aml_dvb_device;
-	ssize_t ret = 0;
-	char *src;
-
-	switch (dvb->stb_source) {
-	case AM_TS_SRC_TS0:
-	case AM_TS_SRC_S_TS0:
-		src = "ts0";
-		break;
-	case AM_TS_SRC_TS1:
-	case AM_TS_SRC_S_TS1:
-		src = "ts1";
-		break;
-	case AM_TS_SRC_TS2:
-	case AM_TS_SRC_S_TS2:
-		src = "ts2";
-		break;
-	case AM_TS_SRC_HIU:
-		src = "hiu";
-		break;
-	case AM_TS_SRC_DMX0:
-		src = "dmx0";
-		break;
-	case AM_TS_SRC_DMX1:
-		src = "dmx1";
-		break;
-	case AM_TS_SRC_DMX2:
-		src = "dmx2";
-		break;
-	default:
-		src = "disable";
-		break;
-	}
-
-	ret = sprintf(buf, "%s\n", src);
-	return ret;
-}
-
-/*Set the STB input source*/
-static ssize_t stb_store_source(struct class *class,
-				struct class_attribute *attr, const char *buf,
-				size_t size)
-{
-	enum dmx_source_t src = -1;
-
-	if (!strncmp("ts0", buf, 3))
-		src = DMX_SOURCE_FRONT0;
-	else if (!strncmp("ts1", buf, 3))
-		src = DMX_SOURCE_FRONT1;
-	else if (!strncmp("ts2", buf, 3))
-		src = DMX_SOURCE_FRONT2;
-	else if (!strncmp("hiu", buf, 3))
-		src = DMX_SOURCE_DVR0;
-	else if (!strncmp("dmx0", buf, 4))
-		src = DMX_SOURCE_FRONT0 + 100;
-	else if (!strncmp("dmx1", buf, 4))
-		src = DMX_SOURCE_FRONT1 + 100;
-	else if (!strncmp("dmx2", buf, 4))
-		src = DMX_SOURCE_FRONT2 + 100;
-	if (src != -1)
-		aml_stb_hw_set_source(&aml_dvb_device, src);
-
-	return size;
-}
-
-#define CASE_PREFIX
-
-/*Show the descrambler's input source*/
-#define DSC_SOURCE_FUNC_DECL(i)  \
-static ssize_t dsc##i##_show_source(struct class *class,  \
-				struct class_attribute *attr, char *buf)\
-{\
-	struct aml_dvb *dvb = &aml_dvb_device;\
-	struct aml_dsc *dsc = &dvb->dsc[i];\
-	ssize_t ret = 0;\
-	char *src, *dst;\
-	switch (dsc->source) {\
-	CASE_PREFIX case AM_TS_SRC_DMX0:\
-		src = "dmx0";\
-	break;\
-	CASE_PREFIX case AM_TS_SRC_DMX1:\
-		src = "dmx1";\
-	break;\
-	CASE_PREFIX case AM_TS_SRC_DMX2:\
-		src = "dmx2";\
-	break;\
-	CASE_PREFIX default :\
-		src = "bypass";\
-	break;\
-	} \
-	switch (dsc->dst) {\
-	CASE_PREFIX case AM_TS_SRC_DMX0:\
-		dst = "dmx0";\
-	break;\
-	CASE_PREFIX case AM_TS_SRC_DMX1:\
-		dst = "dmx1";\
-	break;\
-	CASE_PREFIX case AM_TS_SRC_DMX2:\
-		dst = "dmx2";\
-	break;\
-	CASE_PREFIX default :\
-		dst = "bypass";\
-	break;\
-	} \
-	ret = sprintf(buf, "%s-%s\n", src, dst);\
-	return ret;\
-} \
-static ssize_t dsc##i##_store_source(struct class *class,  \
-		struct class_attribute *attr, const char *buf, size_t size)\
-{\
-	enum dmx_source_t src = -1, dst = -1;\
-	\
-	if (!strncmp("dmx0", buf, 4)) {\
-		src = DMX_SOURCE_FRONT0 + 100;\
-	} else if (!strncmp("dmx1", buf, 4)) {\
-		src = DMX_SOURCE_FRONT1 + 100;\
-	} else if (!strncmp("dmx2", buf, 4)) {\
-		src = DMX_SOURCE_FRONT2 + 100;\
-	} \
-	if (buf[4] == '-') {\
-		if (!strncmp("dmx0", buf+5, 4)) {\
-			dst = DMX_SOURCE_FRONT0 + 100;\
-		} else if (!strncmp("dmx1", buf+5, 4)) {\
-			dst = DMX_SOURCE_FRONT1 + 100;\
-		} else if (!strncmp("dmx2", buf+5, 4)) {\
-			dst = DMX_SOURCE_FRONT2 + 100;\
-		} \
-	} \
-	else \
-		dst = src; \
-	aml_dsc_hw_set_source(&aml_dvb_device.dsc[i], src, dst);\
-	return size;\
-}
-
-/*Show free descramblers count*/
-#define DSC_FREE_FUNC_DECL(i)  \
-static ssize_t dsc##i##_show_free_dscs(struct class *class, \
-				  struct class_attribute *attr, char *buf) \
-{ \
-	struct aml_dvb *dvb = &aml_dvb_device; \
-	int fid, count; \
-	ssize_t ret = 0; \
-	unsigned long flags;\
-\
-	spin_lock_irqsave(&dvb->slock, flags); \
-	count = 0; \
-	for (fid = 0; fid < DSC_COUNT; fid++) { \
-		if (!dvb->dsc[i].channel[fid].used) \
-			count++; \
-	} \
-	spin_unlock_irqrestore(&dvb->slock, flags); \
-\
-	ret = sprintf(buf, "%d\n", count); \
-	return ret; \
-}
-
-#if DSC_DEV_COUNT > 0
-	DSC_SOURCE_FUNC_DECL(0)
-	DSC_FREE_FUNC_DECL(0)
-#endif
-#if DSC_DEV_COUNT > 1
-	DSC_SOURCE_FUNC_DECL(1)
-	DSC_FREE_FUNC_DECL(1)
-#endif
-
-/*Show the TS output source*/
-static ssize_t tso_show_source(struct class *class,
-			       struct class_attribute *attr, char *buf)
-{
-	struct aml_dvb *dvb = &aml_dvb_device;
-	ssize_t ret = 0;
-	char *src;
-
-	switch (dvb->tso_source) {
-	case AM_TS_SRC_TS0:
-	case AM_TS_SRC_S_TS0:
-		src = "ts0";
-		break;
-	case AM_TS_SRC_TS1:
-	case AM_TS_SRC_S_TS1:
-		src = "ts1";
-		break;
-	case AM_TS_SRC_TS2:
-	case AM_TS_SRC_S_TS2:
-		src = "ts2";
-		break;
-	case AM_TS_SRC_HIU:
-		src = "hiu";
-		break;
-	case AM_TS_SRC_DMX0:
-		src = "dmx0";
-		break;
-	case AM_TS_SRC_DMX1:
-		src = "dmx1";
-		break;
-	case AM_TS_SRC_DMX2:
-		src = "dmx2";
-		break;
-	default:
-		src = "default";
-		break;
-	}
-
-	ret = sprintf(buf, "%s\n", src);
-	return ret;
-}
-
-/*Set the TS output source*/
-static ssize_t tso_store_source(struct class *class,
-				struct class_attribute *attr, const char *buf,
-				size_t size)
-{
-	enum dmx_source_t src = -1;
-
-	if (!strncmp("ts0", buf, 3))
-		src = DMX_SOURCE_FRONT0;
-	else if (!strncmp("ts1", buf, 3))
-		src = DMX_SOURCE_FRONT1;
-	else if (!strncmp("ts2", buf, 3))
-		src = DMX_SOURCE_FRONT2;
-	else if (!strncmp("hiu", buf, 3))
-		src = DMX_SOURCE_DVR0;
-	else if (!strncmp("dmx0", buf, 4))
-		src = DMX_SOURCE_FRONT0 + 100;
-	else if (!strncmp("dmx1", buf, 4))
-		src = DMX_SOURCE_FRONT1 + 100;
-	else if (!strncmp("dmx2", buf, 4))
-		src = DMX_SOURCE_FRONT2 + 100;
-
-	aml_tso_hw_set_source(&aml_dvb_device, src);
-
-	return size;
-}
-
-/*Show PCR*/
-#define DEMUX_PCR_FUNC_DECL(i)  \
-static ssize_t demux##i##_show_pcr(struct class *class,  \
-				struct class_attribute *attr, char *buf)\
-{\
-	int f = 0;\
-	if (i == 0)\
-		f = READ_MPEG_REG(PCR_DEMUX);\
-	else if (i == 1)\
-		f = READ_MPEG_REG(PCR_DEMUX_2);\
-	else if (i == 2)\
-		f = READ_MPEG_REG(PCR_DEMUX_3);\
-	return sprintf(buf, "%08x\n", f);\
-}
-
-/*Show the STB input source*/
-#define DEMUX_SOURCE_FUNC_DECL(i)  \
-static ssize_t demux##i##_show_source(struct class *class,  \
-				struct class_attribute *attr, char *buf)\
-{\
-	struct aml_dvb *dvb = &aml_dvb_device;\
-	struct aml_dmx *dmx = &dvb->dmx[i];\
-	ssize_t ret = 0;\
-	char *src;\
-	switch (dmx->source) {\
-	CASE_PREFIX case AM_TS_SRC_TS0:\
-	CASE_PREFIX case AM_TS_SRC_S_TS0:\
-		src = "ts0";\
-	break;\
-	CASE_PREFIX case AM_TS_SRC_TS1:\
-	CASE_PREFIX case AM_TS_SRC_S_TS1:\
-		src = "ts1";\
-	break;\
-	CASE_PREFIX case AM_TS_SRC_TS2:\
-	CASE_PREFIX case AM_TS_SRC_S_TS2:\
-		src = "ts2";\
-	break;\
-	CASE_PREFIX case AM_TS_SRC_HIU:\
-		src = "hiu";\
-	break;\
-	CASE_PREFIX default :\
-		src = "";\
-	break;\
-	} \
-	ret = sprintf(buf, "%s\n", src);\
-	return ret;\
-} \
-static ssize_t demux##i##_store_source(struct class *class,  \
-		struct class_attribute *attr, const char *buf, size_t size)\
-{\
-	enum dmx_source_t src = -1;\
-	\
-	if (!strncmp("ts0", buf, 3)) {\
-		src = DMX_SOURCE_FRONT0;\
-	} else if (!strncmp("ts1", buf, 3)) {\
-		src = DMX_SOURCE_FRONT1;\
-	} else if (!strncmp("ts2", buf, 3)) {\
-		src = DMX_SOURCE_FRONT2;\
-	} else if (!strncmp("hiu", buf, 3)) {\
-		src = DMX_SOURCE_DVR0;\
-	} \
-	if (src != -1) {\
-		aml_dmx_hw_set_source(aml_dvb_device.dmx[i].dmxdev.demux, src);\
-	} \
-	return size;\
-}
-
-/*Show free filters count*/
-#define DEMUX_FREE_FILTERS_FUNC_DECL(i)  \
-static ssize_t demux##i##_show_free_filters(struct class *class,  \
-				struct class_attribute *attr, char *buf)\
-{\
-	struct aml_dvb *dvb = &aml_dvb_device;\
-	struct dvb_demux *dmx = &dvb->dmx[i].demux;\
-	int fid, count;\
-	ssize_t ret = 0;\
-	if (mutex_lock_interruptible(&dmx->mutex)) \
-		return -ERESTARTSYS; \
-	count = 0;\
-	for (fid = 0; fid < dmx->filternum; fid++) {\
-		if (!dmx->filter[fid].state != DMX_STATE_FREE)\
-			count++;\
-	} \
-	mutex_unlock(&dmx->mutex);\
-	ret = sprintf(buf, "%d\n", count);\
-	return ret;\
-}
-
-/*Show filter users count*/
-#define DEMUX_FILTER_USERS_FUNC_DECL(i)  \
-static ssize_t demux##i##_show_filter_users(struct class *class,  \
-				struct class_attribute *attr, char *buf)\
-{\
-	struct aml_dvb *dvb = &aml_dvb_device;\
-	struct aml_dmx *dmx = &dvb->dmx[i];\
-	int dmxdevfid, count;\
-	ssize_t ret = 0;\
-	unsigned long flags;\
-	spin_lock_irqsave(&dvb->slock, flags);\
-	count = 0;\
-	for (dmxdevfid = 0; dmxdevfid < dmx->dmxdev.filternum; dmxdevfid++) {\
-		if (dmx->dmxdev.filter[dmxdevfid].state >= \
-			DMXDEV_STATE_ALLOCATED)\
-			count++;\
-	} \
-	if (count > dmx->demux_filter_user) {\
-		count = dmx->demux_filter_user;\
-	} else{\
-		dmx->demux_filter_user = count;\
-	} \
-	spin_unlock_irqrestore(&dvb->slock, flags);\
-	ret = sprintf(buf, "%d\n", count);\
-	return ret;\
-} \
-static ssize_t demux##i##_store_filter_used(struct class *class,  \
-		struct class_attribute *attr, const char *buf, size_t size)\
-{\
-	struct aml_dvb *dvb = &aml_dvb_device;\
-	struct aml_dmx *dmx = &dvb->dmx[i];\
-	unsigned long filter_used;\
-	unsigned long flags;/*char *endp;*/\
-	/*filter_used = simple_strtol(buf, &endp, 0);*/\
-	int ret = kstrtol(buf, 0, &filter_used);\
-	spin_lock_irqsave(&dvb->slock, flags);\
-	if (ret == 0 && filter_used) {\
-		if (dmx->demux_filter_user < FILTER_COUNT)\
-			dmx->demux_filter_user++;\
-	} else {\
-		if (dmx->demux_filter_user > 0)\
-			dmx->demux_filter_user--;\
-	} \
-	spin_unlock_irqrestore(&dvb->slock, flags);\
-	return size;\
-}
-
-/*Show ts header*/
-#define DEMUX_TS_HEADER_FUNC_DECL(i)  \
-static ssize_t demux##i##_show_ts_header(struct class *class,  \
-				struct class_attribute *attr, char *buf)\
-{\
-	int hdr = 0;\
-	if (i == 0)\
-		hdr = READ_MPEG_REG(TS_HEAD_1);\
-	else if (i == 1)\
-		hdr = READ_MPEG_REG(TS_HEAD_1_2);\
-	else if (i == 2)\
-		hdr = READ_MPEG_REG(TS_HEAD_1_3);\
-	return sprintf(buf, "%08x\n", hdr);\
-}
-
-/*Show channel activity*/
-#define DEMUX_CHANNEL_ACTIVITY_FUNC_DECL(i)  \
-static ssize_t demux##i##_show_channel_activity(struct class *class,  \
-				struct class_attribute *attr, char *buf)\
-{\
-	int f = 0;\
-	if (i == 0)\
-		f = READ_MPEG_REG(DEMUX_CHANNEL_ACTIVITY);\
-	else if (i == 1)\
-		f = READ_MPEG_REG(DEMUX_CHANNEL_ACTIVITY_2);\
-	else if (i == 2)\
-		f = READ_MPEG_REG(DEMUX_CHANNEL_ACTIVITY_3);\
-	return sprintf(buf, "%08x\n", f);\
-}
-
-#define DEMUX_RESET_FUNC_DECL(i)  \
-static ssize_t demux##i##_reset_store(struct class *class,  \
-				struct class_attribute *attr, \
-				const char *buf, size_t size)\
-{\
-	if (!strncmp("1", buf, 1)) { \
-		struct aml_dvb *dvb = &aml_dvb_device; \
-		pr_info("Reset demux["#i"], call dmx_reset_dmx_hw\n"); \
-		dmx_reset_dmx_id_hw_ex(dvb, i, 0); \
-	} \
-	return size; \
-}
-
-/*DVR record mode*/
-#define DVR_MODE_FUNC_DECL(i)  \
-static ssize_t dvr##i##_show_mode(struct class *class,  \
-				struct class_attribute *attr, char *buf)\
-{\
-	struct aml_dvb *dvb = &aml_dvb_device;\
-	struct aml_dmx *dmx = &dvb->dmx[i];\
-	ssize_t ret = 0;\
-	char *mode;\
-	if (dmx->dump_ts_select) {\
-		mode = "ts";\
-	} else {\
-		mode = "pid";\
-	} \
-	ret = sprintf(buf, "%s\n", mode);\
-	return ret;\
-} \
-static ssize_t dvr##i##_store_mode(struct class *class,  \
-		struct class_attribute *attr, const char *buf, size_t size)\
-{\
-	struct aml_dvb *dvb = &aml_dvb_device;\
-	struct aml_dmx *dmx = &dvb->dmx[i];\
-	int dump_ts_select = -1;\
-	\
-	if (!strncmp("pid", buf, 3) && dmx->dump_ts_select) {\
-		dump_ts_select = 0;\
-	} else if (!strncmp("ts", buf, 2) && !dmx->dump_ts_select) {\
-		dump_ts_select = 1;\
-	} \
-	if (dump_ts_select != -1) {\
-		aml_dmx_hw_set_dump_ts_select(\
-			aml_dvb_device.dmx[i].dmxdev.demux, dump_ts_select);\
-	} \
-	return size;\
-}
-
-#if DMX_DEV_COUNT > 0
-	DEMUX_PCR_FUNC_DECL(0)
-	DEMUX_SOURCE_FUNC_DECL(0)
-	DEMUX_FREE_FILTERS_FUNC_DECL(0)
-	DEMUX_FILTER_USERS_FUNC_DECL(0)
-	DVR_MODE_FUNC_DECL(0)
-	DEMUX_TS_HEADER_FUNC_DECL(0)
-	DEMUX_CHANNEL_ACTIVITY_FUNC_DECL(0)
-	DEMUX_RESET_FUNC_DECL(0)
-#endif
-#if DMX_DEV_COUNT > 1
-	DEMUX_PCR_FUNC_DECL(1)
-	DEMUX_SOURCE_FUNC_DECL(1)
-	DEMUX_FREE_FILTERS_FUNC_DECL(1)
-	DEMUX_FILTER_USERS_FUNC_DECL(1)
-	DVR_MODE_FUNC_DECL(1)
-	DEMUX_TS_HEADER_FUNC_DECL(1)
-	DEMUX_CHANNEL_ACTIVITY_FUNC_DECL(1)
-	DEMUX_RESET_FUNC_DECL(1)
-#endif
-#if DMX_DEV_COUNT > 2
-	DEMUX_PCR_FUNC_DECL(2)
-	DEMUX_SOURCE_FUNC_DECL(2)
-	DEMUX_FREE_FILTERS_FUNC_DECL(2)
-	DEMUX_FILTER_USERS_FUNC_DECL(2)
-	DVR_MODE_FUNC_DECL(2)
-	DEMUX_TS_HEADER_FUNC_DECL(2)
-	DEMUX_CHANNEL_ACTIVITY_FUNC_DECL(2)
-	DEMUX_RESET_FUNC_DECL(2)
-#endif
-
-/*Show the async fifo source*/
-#define ASYNCFIFO_SOURCE_FUNC_DECL(i)  \
-static ssize_t asyncfifo##i##_show_source(struct class *class,  \
-				struct class_attribute *attr, char *buf)\
-{\
-	struct aml_dvb *dvb = &aml_dvb_device;\
-	struct aml_asyncfifo *afifo = &dvb->asyncfifo[i];\
-	ssize_t ret = 0;\
-	char *src;\
-	switch (afifo->source) {\
-	CASE_PREFIX case AM_DMX_0:\
-		src = "dmx0";\
-		break;\
-	CASE_PREFIX case AM_DMX_1:\
-		src = "dmx1";\
-		break;   \
-	CASE_PREFIX case AM_DMX_2:\
-		src = "dmx2";\
-		break;\
-	CASE_PREFIX default :\
-		src = "";\
-		break;\
-	} \
-	ret = sprintf(buf, "%s\n", src);\
-	return ret;\
-} \
-static ssize_t asyncfifo##i##_store_source(struct class *class,  \
-		struct class_attribute *attr, const char *buf, size_t size)\
-{\
-	enum aml_dmx_id_t src = -1;\
-	\
-	if (!strncmp("dmx0", buf, 4)) {\
-		src = AM_DMX_0;\
-	} else if (!strncmp("dmx1", buf, 4)) {\
-		src = AM_DMX_1;\
-	} else if (!strncmp("dmx2", buf, 4)) {\
-		src = AM_DMX_2;\
-	} \
-	if (src != -1) {\
-		aml_asyncfifo_hw_set_source(&aml_dvb_device.asyncfifo[i], src);\
-	} \
-	return size;\
-}
-
-#if ASYNCFIFO_COUNT > 0
-ASYNCFIFO_SOURCE_FUNC_DECL(0)
-#endif
-#if ASYNCFIFO_COUNT > 1
-	ASYNCFIFO_SOURCE_FUNC_DECL(1)
-#endif
-/*Show the async fifo flush size*/
-#define ASYNCFIFO_FLUSHSIZE_FUNC_DECL(i)  \
-static ssize_t asyncfifo##i##_show_flush_size(struct class *class,  \
-				struct class_attribute *attr, char *buf)\
-{\
-	struct aml_dvb *dvb = &aml_dvb_device;\
-	struct aml_asyncfifo *afifo = &dvb->asyncfifo[i];\
-	ssize_t ret = 0;\
-	ret = sprintf(buf, "%d\n", afifo->flush_size);\
-	return ret;\
-} \
-static ssize_t asyncfifo##i##_store_flush_size(struct class *class,  \
-					struct class_attribute *attr, \
-					const char *buf, size_t size)\
-{\
-	struct aml_dvb *dvb = &aml_dvb_device;\
-	struct aml_asyncfifo *afifo = &dvb->asyncfifo[i];\
-	/*int fsize = simple_strtol(buf, NULL, 10);*/\
-	int fsize = 0;\
-	long value;\
-	int ret = kstrtol(buf, 0, &value);\
-	if (ret == 0)\
-		fsize = value;\
-	if (fsize != afifo->flush_size) {\
-		afifo->flush_size = fsize;\
-	aml_asyncfifo_hw_reset(&aml_dvb_device.asyncfifo[i]);\
-	} \
-	return size;\
-}
-
-#if ASYNCFIFO_COUNT > 0
-ASYNCFIFO_FLUSHSIZE_FUNC_DECL(0)
-#endif
-
-#if ASYNCFIFO_COUNT > 1
-	ASYNCFIFO_FLUSHSIZE_FUNC_DECL(1)
-#endif
-/*Reset the Demux*/
-static ssize_t demux_do_reset(struct class *class,
-				struct class_attribute *attr,
-				const char *buf, size_t size)
-{
-	if (!strncmp("1", buf, 1)) {
-		struct aml_dvb *dvb = &aml_dvb_device;
-		unsigned long flags;
-
-		spin_lock_irqsave(&dvb->slock, flags);
-		pr_dbg("Reset demux, call dmx_reset_hw\n");
-		dmx_reset_hw_ex(dvb, 0);
-		spin_unlock_irqrestore(&dvb->slock, flags);
-	}
-
-	return size;
-}
-
-/*Show the Video PTS value*/
-static ssize_t demux_show_video_pts(struct class *class,
-				    struct class_attribute *attr, char *buf)
-{
-	struct aml_dvb *dvb = &aml_dvb_device;
-	ssize_t ret = 0;
-
-	ret = sprintf(buf, "%u\n", aml_dmx_get_video_pts(dvb));
-
-	return ret;
-}
-
-/*Show the Audio PTS value*/
-static ssize_t demux_show_audio_pts(struct class *class,
-				    struct class_attribute *attr, char *buf)
-{
-	struct aml_dvb *dvb = &aml_dvb_device;
-	ssize_t ret = 0;
-
-	ret = sprintf(buf, "%u\n", aml_dmx_get_audio_pts(dvb));
-
-	return ret;
-}
-
-/*Show the First Video PTS value*/
-static ssize_t demux_show_first_video_pts(struct class *class,
-					  struct class_attribute *attr,
-					  char *buf)
-{
-	struct aml_dvb *dvb = &aml_dvb_device;
-	ssize_t ret = 0;
-
-	ret = sprintf(buf, "%u\n", aml_dmx_get_first_video_pts(dvb));
-
-	return ret;
-}
-
-/*Show the First Audio PTS value*/
-static ssize_t demux_show_first_audio_pts(struct class *class,
-					  struct class_attribute *attr,
-					  char *buf)
-{
-	struct aml_dvb *dvb = &aml_dvb_device;
-	ssize_t ret = 0;
-
-	ret = sprintf(buf, "%u\n", aml_dmx_get_first_audio_pts(dvb));
-
-	return ret;
-}
-
-static ssize_t stb_show_hw_setting(struct class *class,
-				   struct class_attribute *attr, char *buf)
-{
-	int r, total = 0;
-	int i;
-	struct aml_dvb *dvb = &aml_dvb_device;
-	int invert, ctrl;
-
-	for (i = 0; i < TS_IN_COUNT; i++) {
-		struct aml_ts_input *ts = &dvb->ts[i];
-
-		if (ts->s2p_id != -1)
-			invert = dvb->s2p[ts->s2p_id].invert;
-		else
-			invert = 0;
-
-		ctrl = ts->control;
-
-		r = sprintf(buf, "ts%d %s control: 0x%x invert: 0x%x\n", i,
-			    ts->mode == AM_TS_DISABLE ? "disable" :
-				(ts->mode == AM_TS_SERIAL ? "serial" :
-				"parallel"), ctrl, invert);
-		buf += r;
-		total += r;
-	}
-
-	return total;
-}
-
-static ssize_t stb_store_hw_setting(struct class *class,
-				    struct class_attribute *attr,
-				    const char *buf, size_t count)
-{
-	int id, ctrl, invert, r, mode;
-	char mname[32];
-	char pname[32];
-	unsigned long flags;
-	struct aml_ts_input *ts;
-	struct aml_dvb *dvb = &aml_dvb_device;
-
-	r = sscanf(buf, "%d %s %x %x", &id, mname, &ctrl, &invert);
-	if (r != 4)
-		return -EINVAL;
-
-	if (id < 0 || id >= TS_IN_COUNT)
-		return -EINVAL;
-
-	if ((mname[0] == 's') || (mname[0] == 'S')) {
-		sprintf(pname, "s_ts%d", id);
-		mode = AM_TS_SERIAL;
-	} else if ((mname[0] == 'p') || (mname[0] == 'P')) {
-		sprintf(pname, "p_ts%d", id);
-		mode = AM_TS_PARALLEL;
-	} else
-		mode = AM_TS_DISABLE;
-
-	spin_lock_irqsave(&dvb->slock, flags);
-
-	ts = &dvb->ts[id];
-
-	if ((mode == AM_TS_SERIAL) && (ts->mode != AM_TS_SERIAL)) {
-		int i;
-		int scnt = 0;
-
-		for (i = 0; i < TS_IN_COUNT; i++) {
-			if (dvb->ts[i].s2p_id != -1)
-				scnt++;
-		}
-
-		if (scnt >= S2P_COUNT)
-			pr_error("no free s2p\n");
-		else
-			ts->s2p_id = scnt;
-	}
-
-	if ((mode != AM_TS_SERIAL) || (ts->s2p_id != -1)) {
-		if (ts->pinctrl) {
-			devm_pinctrl_put(ts->pinctrl);
-			ts->pinctrl = NULL;
-		}
-
-		ts->pinctrl = devm_pinctrl_get_select(&dvb->pdev->dev, pname);
-/*              if(IS_ERR_VALUE(ts->pinctrl))*/
-/*                      ts->pinctrl = NULL;*/
-		ts->mode = mode;
-		ts->control = ctrl;
-
-		if (mode == AM_TS_SERIAL)
-			dvb->s2p[ts->s2p_id].invert = invert;
-		else
-			ts->s2p_id = -1;
-	}
-
-	spin_unlock_irqrestore(&dvb->slock, flags);
-
-	return count;
-}
-
-static struct class_attribute aml_stb_class_attrs[] = {
-	__ATTR(hw_setting, S_IRUGO | S_IWUSR | S_IWGRP, stb_show_hw_setting,
-	       stb_store_hw_setting),
-	__ATTR(source, S_IRUGO | S_IWUSR | S_IWGRP, stb_show_source,
-	       stb_store_source),
-	__ATTR(tso_source, S_IRUGO | S_IWUSR, tso_show_source,
-	       tso_store_source),
-#define DEMUX_SOURCE_ATTR_PCR(i)\
-	__ATTR(demux##i##_pcr,  S_IRUGO | S_IWUSR, demux##i##_show_pcr, NULL)
-#define DEMUX_SOURCE_ATTR_DECL(i)\
-	__ATTR(demux##i##_source,  S_IRUGO | S_IWUSR | S_IWGRP,\
-	demux##i##_show_source, demux##i##_store_source)
-#define DEMUX_FREE_FILTERS_ATTR_DECL(i)\
-	__ATTR(demux##i##_free_filters,  S_IRUGO | S_IWUSR, \
-	demux##i##_show_free_filters, NULL)
-#define DEMUX_FILTER_USERS_ATTR_DECL(i)\
-	__ATTR(demux##i##_filter_users,  S_IRUGO | S_IWUSR, \
-	demux##i##_show_filter_users, demux##i##_store_filter_used)
-#define DVR_MODE_ATTR_DECL(i)\
-	__ATTR(dvr##i##_mode,  S_IRUGO | S_IWUSR, dvr##i##_show_mode, \
-	dvr##i##_store_mode)
-#define DEMUX_TS_HEADER_ATTR_DECL(i)\
-	__ATTR(demux##i##_ts_header,  S_IRUGO | S_IWUSR, \
-	demux##i##_show_ts_header, NULL)
-#define DEMUX_CHANNEL_ACTIVITY_ATTR_DECL(i)\
-	__ATTR(demux##i##_channel_activity,  S_IRUGO | S_IWUSR, \
-	demux##i##_show_channel_activity, NULL)
-#define DMX_RESET_ATTR_DECL(i)\
-	__ATTR(demux##i##_reset,  S_IRUGO | S_IWUSR, NULL, \
-	demux##i##_reset_store)
-
-#if DMX_DEV_COUNT > 0
-	DEMUX_SOURCE_ATTR_PCR(0),
-	DEMUX_SOURCE_ATTR_DECL(0),
-	DEMUX_FREE_FILTERS_ATTR_DECL(0),
-	DEMUX_FILTER_USERS_ATTR_DECL(0),
-	DVR_MODE_ATTR_DECL(0),
-	DEMUX_TS_HEADER_ATTR_DECL(0),
-	DEMUX_CHANNEL_ACTIVITY_ATTR_DECL(0),
-	DMX_RESET_ATTR_DECL(0),
-#endif
-#if DMX_DEV_COUNT > 1
-	DEMUX_SOURCE_ATTR_PCR(1),
-	DEMUX_SOURCE_ATTR_DECL(1),
-	DEMUX_FREE_FILTERS_ATTR_DECL(1),
-	DEMUX_FILTER_USERS_ATTR_DECL(1),
-	DVR_MODE_ATTR_DECL(1),
-	DEMUX_TS_HEADER_ATTR_DECL(1),
-	DEMUX_CHANNEL_ACTIVITY_ATTR_DECL(1),
-	DMX_RESET_ATTR_DECL(1),
-#endif
-#if DMX_DEV_COUNT > 2
-	DEMUX_SOURCE_ATTR_PCR(2),
-	DEMUX_SOURCE_ATTR_DECL(2),
-	DEMUX_FREE_FILTERS_ATTR_DECL(2),
-	DEMUX_FILTER_USERS_ATTR_DECL(2),
-	DVR_MODE_ATTR_DECL(2),
-	DEMUX_TS_HEADER_ATTR_DECL(2),
-	DEMUX_CHANNEL_ACTIVITY_ATTR_DECL(2),
-	DMX_RESET_ATTR_DECL(2),
-#endif
-
-#define ASYNCFIFO_SOURCE_ATTR_DECL(i)\
-	__ATTR(asyncfifo##i##_source,  S_IRUGO | S_IWUSR | S_IWGRP, \
-	asyncfifo##i##_show_source, asyncfifo##i##_store_source)
-#define ASYNCFIFO_FLUSHSIZE_ATTR_DECL(i)\
-	__ATTR(asyncfifo##i##_flush_size, S_IRUGO | S_IWUSR | S_IWGRP,\
-	asyncfifo##i##_show_flush_size, \
-	asyncfifo##i##_store_flush_size)
-#if ASYNCFIFO_COUNT > 0
-	ASYNCFIFO_SOURCE_ATTR_DECL(0),
-	ASYNCFIFO_FLUSHSIZE_ATTR_DECL(0),
-#endif
-#if ASYNCFIFO_COUNT > 1
-	ASYNCFIFO_SOURCE_ATTR_DECL(1),
-	ASYNCFIFO_FLUSHSIZE_ATTR_DECL(1),
-#endif
-
-	__ATTR(demux_reset, S_IRUGO | S_IWUSR, NULL, demux_do_reset),
-	__ATTR(video_pts, S_IRUGO | S_IWUSR | S_IWGRP, demux_show_video_pts,
-	       NULL),
-	__ATTR(audio_pts, S_IRUGO | S_IWUSR | S_IWGRP, demux_show_audio_pts,
-	       NULL),
-	__ATTR(first_video_pts, S_IRUGO | S_IWUSR, demux_show_first_video_pts,
-	       NULL),
-	__ATTR(first_audio_pts, S_IRUGO | S_IWUSR, demux_show_first_audio_pts,
-	       NULL),
-
-#define DSC_SOURCE_ATTR_DECL(i)\
-	__ATTR(dsc##i##_source,  S_IRUGO | S_IWUSR | S_IWGRP,\
-	dsc##i##_show_source, dsc##i##_store_source)
-#define DSC_FREE_ATTR_DECL(i) \
-	__ATTR(dsc##i##_free_dscs, S_IRUGO | S_IWUSR, \
-	dsc##i##_show_free_dscs, NULL)
-
-#if DSC_DEV_COUNT > 0
-	DSC_SOURCE_ATTR_DECL(0),
-	DSC_FREE_ATTR_DECL(0),
-#endif
-#if DSC_DEV_COUNT > 1
-	DSC_SOURCE_ATTR_DECL(1),
-	DSC_FREE_ATTR_DECL(1),
-#endif
-
-	__ATTR_NULL
-};
-
-static struct class aml_stb_class = {
-	.name = "stb",
-	.class_attrs = aml_stb_class_attrs,
-};
-
-/*
-extern int aml_regist_dmx_class(void);
-extern int aml_unregist_dmx_class(void);
-*/
-/*
-void afifo_reset(int v)
-{
-	if (v)
-		reset_control_assert(aml_dvb_afifo_reset_ctl);
-	else
-		reset_control_deassert(aml_dvb_afifo_reset_ctl);
-}
-*/
-
-static int aml_dvb_probe(struct platform_device *pdev)
-{
-	struct aml_dvb *advb;
-	int i, ret = 0;
-	struct devio_aml_platform_data *pd_dvb;
-
-	pr_inf("probe amlogic dvb driver\n");
-
-	/*switch_mod_gate_by_name("demux", 1); */
-	aml_dvb_demux_reset_ctl =
-		devm_reset_control_get(&pdev->dev, "demux");
-	pr_inf("dmx rst ctl = %p\n", aml_dvb_demux_reset_ctl);
-	reset_control_deassert(aml_dvb_demux_reset_ctl);
-
-	aml_dvb_afifo_reset_ctl =
-		devm_reset_control_get(&pdev->dev, "asyncfifo");
-	pr_inf("asyncfifo rst ctl = %p\n", aml_dvb_afifo_reset_ctl);
-	reset_control_deassert(aml_dvb_afifo_reset_ctl);
-
-	aml_dvb_ahbarb0_reset_ctl =
-		devm_reset_control_get(&pdev->dev, "ahbarb0");
-	pr_inf("ahbarb0 rst ctl = %p\n", aml_dvb_ahbarb0_reset_ctl);
-	reset_control_deassert(aml_dvb_ahbarb0_reset_ctl);
-
-	aml_dvb_uparsertop_reset_ctl =
-		devm_reset_control_get(&pdev->dev, "uparsertop");
-	pr_inf("uparsertop rst ctl = %p\n", aml_dvb_uparsertop_reset_ctl);
-	reset_control_deassert(aml_dvb_uparsertop_reset_ctl);
-
-	advb = &aml_dvb_device;
-	memset(advb, 0, sizeof(aml_dvb_device));
-
-	spin_lock_init(&advb->slock);
-
-	advb->dev = &pdev->dev;
-	advb->pdev = pdev;
-	advb->stb_source = -1;
-	advb->tso_source = -1;
-
-	for (i = 0; i < DMX_DEV_COUNT; i++) {
-		advb->dmx[i].dmx_irq = -1;
-		advb->dmx[i].dvr_irq = -1;
-	}
-
-#ifdef CONFIG_OF
-	if (pdev->dev.of_node) {
-		int s2p_id = 0;
-
-		for (i = 0; i < TS_IN_COUNT; i++) {
-			char buf[32];
-			const char *str;
-			u32 value;
-
-			advb->ts[i].mode = AM_TS_DISABLE;
-			advb->ts[i].s2p_id = -1;
-
-			snprintf(buf, sizeof(buf), "ts%d", i);
-			ret =
-			    of_property_read_string(pdev->dev.of_node, buf,
-						    &str);
-			if (!ret) {
-				if (!strcmp(str, "serial")) {
-					pr_inf("%s: serial\n", buf);
-
-					if (s2p_id >= S2P_COUNT)
-						pr_error("no free s2p\n");
-					else {
-						snprintf(buf, sizeof(buf),
-							 "s_ts%d", i);
-						advb->ts[i].mode = AM_TS_SERIAL;
-						advb->ts[i].pinctrl =
-						    devm_pinctrl_get_select
-						    (&pdev->dev, buf);
-						advb->ts[i].s2p_id = s2p_id;
-
-						s2p_id++;
-					}
-				} else if (!strcmp(str, "parallel")) {
-					pr_inf("%s: parallel\n", buf);
-					snprintf(buf, sizeof(buf), "p_ts%d", i);
-					advb->ts[i].mode = AM_TS_PARALLEL;
-					advb->ts[i].pinctrl =
-					    devm_pinctrl_get_select(&pdev->dev,
-								    buf);
-				} else {
-					advb->ts[i].mode = AM_TS_DISABLE;
-					advb->ts[i].pinctrl = NULL;
-				}
-
-				/* if(IS_ERR_VALUE(advb->ts[i].pinctrl)) */
-				/* advb->ts[i].pinctrl = NULL; */
-
-				control_ts_on_csi_port(i,
-						       (advb->ts[i].mode ==
-							AM_TS_DISABLE) ? 0 : 1);
-			}
-
-			snprintf(buf, sizeof(buf), "ts%d_control", i);
-			ret =
-			    of_property_read_u32(pdev->dev.of_node, buf,
-						 &value);
-			if (!ret) {
-				pr_inf("%s: 0x%x\n", buf, value);
-				advb->ts[i].control = value;
-			}
-
-			if (advb->ts[i].s2p_id != -1) {
-				snprintf(buf, sizeof(buf), "ts%d_invert", i);
-				ret =
-				    of_property_read_u32(pdev->dev.of_node, buf,
-							 &value);
-				if (!ret) {
-					pr_inf("%s: 0x%x\n", buf, value);
-					advb->s2p[advb->ts[i].s2p_id].invert =
-					    value;
-				}
-			}
-		}
-	}
-#endif
-
-	pd_dvb = (struct devio_aml_platform_data *)advb->dev->platform_data;
-
-	ret =
-	    dvb_register_adapter(&advb->dvb_adapter, CARD_NAME, THIS_MODULE,
-				 advb->dev, adapter_nr);
-	if (ret < 0)
-		return ret;
-
-	for (i = 0; i < DMX_DEV_COUNT; i++)
-		advb->dmx[i].id = -1;
-
-	advb->dvb_adapter.priv = advb;
-	dev_set_drvdata(advb->dev, advb);
-
-	for (i = 0; i < DSC_DEV_COUNT; i++) {
-		ret = aml_dvb_dsc_init(advb, &advb->dsc[i], i);
-		if (ret < 0)
-			goto error;
-	}
-
-	for (i = 0; i < DMX_DEV_COUNT; i++) {
-		ret = aml_dvb_dmx_init(advb, &advb->dmx[i], i);
-		if (ret < 0)
-			goto error;
-	}
-
-	/*Init the async fifos */
-	for (i = 0; i < ASYNCFIFO_COUNT; i++) {
-		ret = aml_dvb_asyncfifo_init(advb, &advb->asyncfifo[i], i);
-		if (ret < 0)
-			goto error;
-	}
-
-	aml_regist_dmx_class();
-
-	if (class_register(&aml_stb_class) < 0) {
-		pr_error("register class error\n");
-		goto error;
-	}
-
-	tsdemux_set_ops(&aml_tsdemux_ops);
-
-	return ret;
-error:
-	for (i = 0; i < ASYNCFIFO_COUNT; i++) {
-		if (advb->asyncfifo[i].id != -1)
-			aml_dvb_asyncfifo_release(advb, &advb->asyncfifo[i]);
-	}
-
-	for (i = 0; i < DMX_DEV_COUNT; i++) {
-		if (advb->dmx[i].id != -1)
-			aml_dvb_dmx_release(advb, &advb->dmx[i]);
-	}
-
-	for (i = 0; i < DSC_DEV_COUNT; i++) {
-		if (advb->dsc[i].id != -1)
-			aml_dvb_dsc_release(advb, &advb->dsc[i]);
-	}
-
-	dvb_unregister_adapter(&advb->dvb_adapter);
-
-	return ret;
-}
-
-static int aml_dvb_remove(struct platform_device *pdev)
-{
-	struct aml_dvb *advb = (struct aml_dvb *)dev_get_drvdata(&pdev->dev);
-	int i;
-
-	tsdemux_set_ops(NULL);
-
-	aml_unregist_dmx_class();
-	class_unregister(&aml_stb_class);
-
-	for (i = 0; i < DSC_DEV_COUNT; i++)
-		aml_dvb_dsc_release(advb, &advb->dsc[i]);
-
-	for (i = 0; i < DMX_DEV_COUNT; i++)
-		aml_dvb_dmx_release(advb, &advb->dmx[i]);
-
-	dvb_unregister_adapter(&advb->dvb_adapter);
-
-	for (i = 0; i < TS_IN_COUNT; i++) {
-		if (advb->ts[i].pinctrl)
-			devm_pinctrl_put(advb->ts[i].pinctrl);
-	}
-
-	/*switch_mod_gate_by_name("demux", 0); */
-	reset_control_assert(aml_dvb_uparsertop_reset_ctl);
-	reset_control_assert(aml_dvb_ahbarb0_reset_ctl);
-	reset_control_assert(aml_dvb_afifo_reset_ctl);
-	reset_control_assert(aml_dvb_demux_reset_ctl);
-
-	return 0;
-}
-
-#ifdef CONFIG_OF
-static const struct of_device_id aml_dvb_dt_match[] = {
-	{
-	 .compatible = "amlogic, dvb",
-	 },
-	{},
-};
-#endif /*CONFIG_OF */
-
-static struct platform_driver aml_dvb_driver = {
-	.probe = aml_dvb_probe,
-	.remove = aml_dvb_remove,
-	.driver = {
-		   .name = "amlogic-dvb",
-		   .owner = THIS_MODULE,
-#ifdef CONFIG_OF
-		   .of_match_table = aml_dvb_dt_match,
-#endif
-		   }
-};
-
-static int __init aml_dvb_init(void)
-{
-	pr_dbg("aml dvb init\n");
-	return platform_driver_register(&aml_dvb_driver);
-}
-
-static void __exit aml_dvb_exit(void)
-{
-	pr_dbg("aml dvb exit\n");
-	platform_driver_unregister(&aml_dvb_driver);
-}
-
-/*Get the STB source demux*/
-static struct aml_dmx *get_stb_dmx(void)
-{
-	struct aml_dvb *dvb = &aml_dvb_device;
-	struct aml_dmx *dmx = NULL;
-	int i;
-
-	switch (dvb->stb_source) {
-	case AM_TS_SRC_DMX0:
-		dmx = &dvb->dmx[0];
-		break;
-	case AM_TS_SRC_DMX1:
-		dmx = &dvb->dmx[1];
-		break;
-	case AM_TS_SRC_DMX2:
-		dmx = &dvb->dmx[2];
-		break;
-	default:
-		for (i = 0; i < DMX_DEV_COUNT; i++) {
-			dmx = &dvb->dmx[i];
-			if (dmx->source == dvb->stb_source)
-				return dmx;
-		}
-		break;
-	}
-
-	return dmx;
-}
-
-static int aml_tsdemux_reset(void)
-{
-	struct aml_dvb *dvb = &aml_dvb_device;
-	unsigned long flags;
-
-	spin_lock_irqsave(&dvb->slock, flags);
-	if (dvb->reset_flag) {
-		struct aml_dmx *dmx = get_stb_dmx();
-		dvb->reset_flag = 0;
-		if (dmx)
-			dmx_reset_dmx_hw_ex_unlock(dvb, dmx, 0);
-	}
-	spin_unlock_irqrestore(&dvb->slock, flags);
-
-	return 0;
-}
-
-static int aml_tsdemux_set_reset_flag(void)
-{
-	struct aml_dvb *dvb = &aml_dvb_device;
-	unsigned long flags;
-
-	spin_lock_irqsave(&dvb->slock, flags);
-	dvb->reset_flag = 1;
-	spin_unlock_irqrestore(&dvb->slock, flags);
-
-	return 0;
-
-}
-
-/*Add the amstream irq handler*/
-static int aml_tsdemux_request_irq(irq_handler_t handler, void *data)
-{
-	struct aml_dvb *dvb = &aml_dvb_device;
-	struct aml_dmx *dmx;
-	unsigned long flags;
-
-	spin_lock_irqsave(&dvb->slock, flags);
-
-	dmx = get_stb_dmx();
-	if (dmx) {
-		dmx->irq_handler = handler;
-		dmx->irq_data = data;
-	}
-
-	spin_unlock_irqrestore(&dvb->slock, flags);
-
-	return 0;
-}
-
-/*Free the amstream irq handler*/
-static int aml_tsdemux_free_irq(void)
-{
-	struct aml_dvb *dvb = &aml_dvb_device;
-	struct aml_dmx *dmx;
-	unsigned long flags;
-
-	spin_lock_irqsave(&dvb->slock, flags);
-
-	dmx = get_stb_dmx();
-	if (dmx) {
-		dmx->irq_handler = NULL;
-		dmx->irq_data = NULL;
-	}
-
-	spin_unlock_irqrestore(&dvb->slock, flags);
-
-	return 0;
-}
-
-/*Reset the video PID*/
-static int aml_tsdemux_set_vid(int vpid)
-{
-	struct aml_dvb *dvb = &aml_dvb_device;
-	struct aml_dmx *dmx;
-	unsigned long flags;
-	int ret = 0;
-
-	spin_lock_irqsave(&dvb->slock, flags);
-
-	dmx = get_stb_dmx();
-
-	spin_unlock_irqrestore(&dvb->slock, flags);
-
-	if (dmx) {
-		mutex_lock(&dmx->dmxdev.mutex);
-
-		spin_lock_irqsave(&dvb->slock, flags);
-
-		if (dmx->vid_chan != -1) {
-			dmx_free_chan(dmx, dmx->vid_chan);
-			dmx->vid_chan = -1;
-		}
-
-		if ((vpid >= 0) && (vpid < 0x1FFF)) {
-			dmx->vid_chan =
-			    dmx_alloc_chan(dmx, DMX_TYPE_TS,
-						DMX_PES_VIDEO, vpid);
-			if (dmx->vid_chan == -1)
-				ret = -1;
-		}
-
-		spin_unlock_irqrestore(&dvb->slock, flags);
-
-		mutex_unlock(&dmx->dmxdev.mutex);
-	}
-
-	return ret;
-}
-
-/*Reset the audio PID*/
-static int aml_tsdemux_set_aid(int apid)
-{
-	struct aml_dvb *dvb = &aml_dvb_device;
-	struct aml_dmx *dmx;
-	unsigned long flags;
-	int ret = 0;
-
-	spin_lock_irqsave(&dvb->slock, flags);
-
-	dmx = get_stb_dmx();
-
-	spin_unlock_irqrestore(&dvb->slock, flags);
-
-	if (dmx) {
-		mutex_lock(&dmx->dmxdev.mutex);
-
-		spin_lock_irqsave(&dvb->slock, flags);
-
-		if (dmx->aud_chan != -1) {
-			dmx_free_chan(dmx, dmx->aud_chan);
-			dmx->aud_chan = -1;
-		}
-
-		if ((apid >= 0) && (apid < 0x1FFF)) {
-			dmx->aud_chan =
-			    dmx_alloc_chan(dmx, DMX_TYPE_TS,
-						DMX_PES_AUDIO, apid);
-			if (dmx->aud_chan == -1)
-				ret = -1;
-		}
-
-		spin_unlock_irqrestore(&dvb->slock, flags);
-
-		mutex_unlock(&dmx->dmxdev.mutex);
-	}
-
-	return ret;
-}
-
-/*Reset the subtitle PID*/
-static int aml_tsdemux_set_sid(int spid)
-{
-	struct aml_dvb *dvb = &aml_dvb_device;
-	struct aml_dmx *dmx;
-	unsigned long flags;
-	int ret = 0;
-
-	spin_lock_irqsave(&dvb->slock, flags);
-
-	dmx = get_stb_dmx();
-
-	spin_unlock_irqrestore(&dvb->slock, flags);
-
-	if (dmx) {
-		mutex_lock(&dmx->dmxdev.mutex);
-
-		spin_lock_irqsave(&dvb->slock, flags);
-
-		if (dmx->sub_chan != -1) {
-			dmx_free_chan(dmx, dmx->sub_chan);
-			dmx->sub_chan = -1;
-		}
-
-		if ((spid >= 0) && (spid < 0x1FFF)) {
-			dmx->sub_chan =
-			    dmx_alloc_chan(dmx, DMX_TYPE_TS,
-						DMX_PES_SUBTITLE, spid);
-			if (dmx->sub_chan == -1)
-				ret = -1;
-		}
-
-		spin_unlock_irqrestore(&dvb->slock, flags);
-
-		mutex_unlock(&dmx->dmxdev.mutex);
-	}
-
-	return ret;
-}
-
-static int aml_tsdemux_set_pcrid(int pcrpid)
-{
-	struct aml_dvb *dvb = &aml_dvb_device;
-	struct aml_dmx *dmx;
-	unsigned long flags;
-	int ret = 0;
-
-	spin_lock_irqsave(&dvb->slock, flags);
-
-	dmx = get_stb_dmx();
-
-	spin_unlock_irqrestore(&dvb->slock, flags);
-
-	if (dmx) {
-		mutex_lock(&dmx->dmxdev.mutex);
-
-		spin_lock_irqsave(&dvb->slock, flags);
-
-		if (dmx->pcr_chan != -1) {
-			dmx_free_chan(dmx, dmx->pcr_chan);
-			dmx->pcr_chan = -1;
-		}
-
-		if ((pcrpid >= 0) && (pcrpid < 0x1FFF)) {
-			dmx->pcr_chan =
-			    dmx_alloc_chan(dmx, DMX_TYPE_TS,
-						DMX_PES_PCR, pcrpid);
-			if (dmx->pcr_chan == -1)
-				ret = -1;
-		}
-
-		spin_unlock_irqrestore(&dvb->slock, flags);
-
-		mutex_unlock(&dmx->dmxdev.mutex);
-	}
-
-	return ret;
-}
-
-static int aml_tsdemux_set_skipbyte(int skipbyte)
-{
-	struct aml_dvb *dvb = &aml_dvb_device;
-	unsigned long flags;
-
-	spin_lock_irqsave(&dvb->slock, flags);
-	aml_dmx_set_skipbyte(dvb, skipbyte);
-	spin_unlock_irqrestore(&dvb->slock, flags);
-
-	return 0;
-}
-
-static int aml_tsdemux_set_demux(int id)
-{
-	struct aml_dvb *dvb = &aml_dvb_device;
-
-	aml_dmx_set_demux(dvb, id);
-	return 0;
-}
-
-module_init(aml_dvb_init);
-module_exit(aml_dvb_exit);
-
-MODULE_DESCRIPTION("driver for the AMLogic DVB card");
-MODULE_AUTHOR("AMLOGIC");
-MODULE_LICENSE("GPL");
diff --git a/drivers/amlogic/dvb_tv/aml_dvb.h b/drivers/amlogic/dvb_tv/aml_dvb.h
deleted file mode 100644
index ef7b4e0a28c9..000000000000
--- a/drivers/amlogic/dvb_tv/aml_dvb.h
+++ /dev/null
@@ -1,339 +0,0 @@
-#ifndef _AML_DVB_H_
-#define _AML_DVB_H_
-
-#include <linux/interrupt.h>
-#include <linux/socket.h>
-#include <linux/netdevice.h>
-#include <linux/i2c.h>
-
-#include <linux/dvb/video.h>
-#include <linux/dvb/audio.h>
-#include <linux/dvb/dmx.h>
-#include <linux/dvb/ca.h>
-#include <linux/dvb/osd.h>
-#include <linux/dvb/net.h>
-#include <linux/dvb/frontend.h>
-
-#include <linux/mutex.h>
-#include <linux/spinlock.h>
-#include <linux/interrupt.h>
-
-#ifdef CONFIG_HAS_EARLYSUSPEND
-#include <linux/earlysuspend.h>
-#endif
-
-
-#include "drivers/media/dvb-core/dvbdev.h"
-#include "drivers/media/dvb-core/demux.h"
-#include "drivers/media/dvb-core/dvb_demux.h"
-#include "drivers/media/dvb-core/dmxdev.h"
-#include "drivers/media/dvb-core/dvb_filter.h"
-#include "drivers/media/dvb-core/dvb_net.h"
-#include "drivers/media/dvb-core/dvb_ringbuffer.h"
-#include "drivers/media/dvb-core/dvb_frontend.h"
-
-#include <linux/of.h>
-#include <linux/pinctrl/consumer.h>
-
-#define TS_IN_COUNT       3
-#define S2P_COUNT         2
-
-#define DMX_DEV_COUNT     3
-#define FE_DEV_COUNT      2
-#define CHANNEL_COUNT     31
-#define FILTER_COUNT      31
-#define FILTER_LEN        15
-#define DSC_DEV_COUNT     2
-#define DSC_COUNT         8
-#define SEC_BUF_GRP_COUNT 4
-#define SEC_BUF_BUSY_SIZE 4
-#define SEC_BUF_COUNT     (SEC_BUF_GRP_COUNT*8)
-#define ASYNCFIFO_COUNT 2
-
-enum aml_dmx_id_t {
-	AM_DMX_0 = 0,
-	AM_DMX_1,
-	AM_DMX_2,
-	AM_DMX_MAX,
-};
-
-enum aml_ts_source_t {
-	AM_TS_SRC_TS0,
-	AM_TS_SRC_TS1,
-	AM_TS_SRC_TS2,
-	AM_TS_SRC_S_TS0,
-	AM_TS_SRC_S_TS1,
-	AM_TS_SRC_S_TS2,
-	AM_TS_SRC_HIU,
-	AM_TS_SRC_DMX0,
-	AM_TS_SRC_DMX1,
-	AM_TS_SRC_DMX2
-};
-
-struct aml_sec_buf {
-	unsigned long        addr;
-	int                  len;
-};
-
-struct aml_channel {
-	int                  type;
-	enum dmx_ts_pes	pes_type;
-	int                  pid;
-	int                  used;
-	int                  filter_count;
-	struct dvb_demux_feed     *feed;
-	struct dvb_demux_feed     *dvr_feed;
-};
-
-struct aml_filter {
-	int                  chan_id;
-	int                  used;
-	struct dmx_section_filter *filter;
-	u8                   value[FILTER_LEN];
-	u8                   maskandmode[FILTER_LEN];
-	u8                   maskandnotmode[FILTER_LEN];
-	u8                   neq;
-};
-
-struct aml_dsc_channel {
-	int                  pid;
-	u8                   even[8];
-	u8                   odd[8];
-	int                  used;
-	int                  set;
-	int                  id;
-	struct aml_dsc      *dsc;
-};
-
-struct aml_dsc {
-	struct dvb_device   *dev;
-	struct aml_dsc_channel channel[DSC_COUNT];
-	enum aml_ts_source_t   source;
-	enum aml_ts_source_t   dst;
-	struct aml_dvb      *dvb;
-	int                 id;
-};
-
-struct aml_smallsec {
-	struct aml_dmx *dmx;
-
-	int	enable;
-	int	bufsize;
-#define SS_BUFSIZE_DEF (16*4*256) /*16KB*/
-	long	buf;
-	long	buf_map;
-};
-
-struct aml_dmxtimeout {
-	struct aml_dmx *dmx;
-
-	int	enable;
-
-	int	timeout;
-#define DTO_TIMEOUT_DEF (9000)       /*0.5s*/
-	u32	ch_disable;
-#define DTO_CHDIS_VAS   (0xfffffff8) /*v/a/s only*/
-	int	match;
-
-	int     trigger;
-};
-
-struct aml_dmx {
-	struct dvb_demux     demux;
-	struct dmxdev        dmxdev;
-	int                  id;
-	int                  feed_count;
-	int                  chan_count;
-	enum aml_ts_source_t      source;
-	int                  init;
-	int                  record;
-	struct dmx_frontend  hw_fe[DMX_DEV_COUNT];
-	struct dmx_frontend  mem_fe;
-	struct dvb_net       dvb_net;
-	int                  dmx_irq;
-	int                  dvr_irq;
-	struct tasklet_struct     dmx_tasklet;
-	struct tasklet_struct     dvr_tasklet;
-	unsigned long        sec_pages;
-	unsigned long        sec_pages_map;
-	int                  sec_total_len;
-	struct aml_sec_buf   sec_buf[SEC_BUF_COUNT];
-	unsigned long        pes_pages;
-	unsigned long        pes_pages_map;
-	int                  pes_buf_len;
-	unsigned long        sub_pages;
-	unsigned long        sub_pages_map;
-	int                  sub_buf_len;
-	struct aml_channel   channel[CHANNEL_COUNT+1];
-	struct aml_filter    filter[FILTER_COUNT+1];
-	irq_handler_t        irq_handler;
-	void                *irq_data;
-	int                  aud_chan;
-	int                  vid_chan;
-	int                  sub_chan;
-	int                  pcr_chan;
-	u32                  section_busy[SEC_BUF_BUSY_SIZE];
-	struct dvb_frontend *fe;
-	int                  int_check_count;
-	u32                  int_check_time;
-	int                  in_tune;
-	int                  error_check;
-	int                  dump_ts_select;
-	int                  sec_buf_watchdog_count[SEC_BUF_COUNT];
-
-	struct aml_smallsec  smallsec;
-	struct aml_dmxtimeout timeout;
-
-	int                  demux_filter_user;
-};
-
-struct aml_asyncfifo {
-	int	id;
-	int	init;
-	int	asyncfifo_irq;
-	enum aml_dmx_id_t	source;
-	unsigned long	pages;
-	unsigned long   pages_map;
-	int	buf_len;
-	int	buf_toggle;
-	int buf_read;
-	int flush_size;
-	struct tasklet_struct     asyncfifo_tasklet;
-	struct aml_dvb *dvb;
-};
-
-enum{
-	AM_TS_DISABLE,
-	AM_TS_PARALLEL,
-	AM_TS_SERIAL
-};
-
-struct aml_ts_input {
-	int                  mode;
-	struct pinctrl      *pinctrl;
-	int                  control;
-	int                  s2p_id;
-};
-
-struct aml_s2p {
-	int    invert;
-};
-
-struct aml_swfilter {
-	int    user;
-	struct aml_dmx *dmx;
-	struct aml_asyncfifo *afifo;
-
-	struct dvb_ringbuffer rbuf;
-#define SF_BUFFER_SIZE (10*188*1024)
-
-	u8     wrapbuf[188];
-	int    track_dmx;
-};
-
-struct aml_dvb {
-	struct dvb_device    dvb_dev;
-
-	struct dvb_frontend *fe;
-	struct work_struct aml_fe_wq;
-
-	struct aml_ts_input  ts[TS_IN_COUNT];
-	struct aml_s2p       s2p[S2P_COUNT];
-	struct aml_dmx       dmx[DMX_DEV_COUNT];
-	struct aml_dsc       dsc[DSC_DEV_COUNT];
-	struct aml_asyncfifo asyncfifo[ASYNCFIFO_COUNT];
-	struct dvb_adapter   dvb_adapter;
-	struct device       *dev;
-	struct platform_device *pdev;
-	enum aml_ts_source_t      stb_source;
-	enum aml_ts_source_t      tso_source;
-	int                  dmx_init;
-	int                  reset_flag;
-	spinlock_t           slock;
-	struct timer_list    watchdog_timer;
-	int                  dmx_watchdog_disable[DMX_DEV_COUNT];
-	struct aml_swfilter  swfilter;
-};
-
-
-/*AMLogic demux interface*/
-extern int aml_dmx_hw_init(struct aml_dmx *dmx);
-extern int aml_dmx_hw_deinit(struct aml_dmx *dmx);
-extern int aml_dmx_hw_start_feed(struct dvb_demux_feed *dvbdmxfeed);
-extern int aml_dmx_hw_stop_feed(struct dvb_demux_feed *dvbdmxfeed);
-extern int aml_dmx_hw_set_source(struct dmx_demux *demux,
-					enum dmx_source_t src);
-extern int aml_stb_hw_set_source(struct aml_dvb *dvb, enum dmx_source_t src);
-extern int aml_dsc_hw_set_source(struct aml_dsc *dsc,
-				enum dmx_source_t src, enum dmx_source_t dst);
-extern int aml_tso_hw_set_source(struct aml_dvb *dvb, enum dmx_source_t src);
-extern int aml_dmx_set_skipbyte(struct aml_dvb *dvb, int skipbyte);
-extern int aml_dmx_set_demux(struct aml_dvb *dvb, int id);
-extern int aml_dmx_hw_set_dump_ts_select
-		(struct dmx_demux *demux, int dump_ts_select);
-
-extern int  dmx_alloc_chan(struct aml_dmx *dmx, int type,
-				int pes_type, int pid);
-extern void dmx_free_chan(struct aml_dmx *dmx, int cid);
-
-extern int dmx_get_ts_serial(enum aml_ts_source_t src);
-
-/*AMLogic dsc interface*/
-extern int dsc_set_pid(struct aml_dsc_channel *ch, int pid);
-extern int dsc_set_key(struct aml_dsc_channel *ch, int type, u8 *key);
-
-/*AMLogic ASYNC FIFO interface*/
-extern int aml_asyncfifo_hw_init(struct aml_asyncfifo *afifo);
-extern int aml_asyncfifo_hw_deinit(struct aml_asyncfifo *afifo);
-extern int aml_asyncfifo_hw_set_source(struct aml_asyncfifo *afifo,
-					enum aml_dmx_id_t src);
-extern int aml_asyncfifo_hw_reset(struct aml_asyncfifo *afifo);
-
-/*Get the Audio & Video PTS*/
-extern u32 aml_dmx_get_video_pts(struct aml_dvb *dvb);
-extern u32 aml_dmx_get_audio_pts(struct aml_dvb *dvb);
-extern u32 aml_dmx_get_first_video_pts(struct aml_dvb *dvb);
-extern u32 aml_dmx_get_first_audio_pts(struct aml_dvb *dvb);
-
-/*Get the DVB device*/
-extern struct aml_dvb *aml_get_dvb_device(void);
-
-/*Demod interface*/
-extern void aml_dmx_register_frontend(enum aml_ts_source_t src,
-					struct dvb_frontend *fe);
-extern void aml_dmx_before_retune(enum aml_ts_source_t src,
-					struct dvb_frontend *fe);
-extern void aml_dmx_after_retune(enum aml_ts_source_t src,
-					struct dvb_frontend *fe);
-extern void aml_dmx_start_error_check(enum aml_ts_source_t src,
-					struct dvb_frontend *fe);
-extern int  aml_dmx_stop_error_check(enum aml_ts_source_t src,
-					struct dvb_frontend *fe);
-extern int aml_regist_dmx_class(void);
-extern int aml_unregist_dmx_class(void);
-extern void dvb_frontend_retune(struct dvb_frontend *fe);
-
-struct devio_aml_platform_data {
-	int (*io_setup)(void *);
-	int (*io_cleanup)(void *);
-	int (*io_power)(void *, int enable);
-	int (*io_reset)(void *, int enable);
-};
-
-/*Reset the demux device*/
-void dmx_reset_hw(struct aml_dvb *dvb);
-void dmx_reset_hw_ex(struct aml_dvb *dvb, int reset_irq);
-
-/*Reset the individual demux*/
-void dmx_reset_dmx_hw(struct aml_dvb *dvb, int id);
-void dmx_reset_dmx_id_hw_ex(struct aml_dvb *dvb, int id, int reset_irq);
-void dmx_reset_dmx_id_hw_ex_unlock(struct aml_dvb *dvb, int id, int reset_irq);
-void dmx_reset_dmx_hw_ex(struct aml_dvb *dvb,
-				struct aml_dmx *dmx,
-				int reset_irq);
-void dmx_reset_dmx_hw_ex_unlock(struct aml_dvb *dvb,
-				struct aml_dmx *dmx,
-				int reset_irq);
-
-#endif
-
diff --git a/drivers/amlogic/dvb_tv/aml_dvb_reg.h b/drivers/amlogic/dvb_tv/aml_dvb_reg.h
deleted file mode 100644
index fdeffd326bc7..000000000000
--- a/drivers/amlogic/dvb_tv/aml_dvb_reg.h
+++ /dev/null
@@ -1,46 +0,0 @@
-/*
- * drivers/amlogic/dvb_tv/dvb_reg.h
- *
- * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
-*/
-
-#ifndef _DVB_REG_H_
-#define _DVB_REG_H_
-
-#include <linux/amlogic/iomap.h>
-
-#include "c_stb_define.h"
-#include "c_stb_regs_define.h"
-
-#define WRITE_MPEG_REG(_r, _v)   aml_write_cbus(_r, _v)
-#define READ_MPEG_REG(_r)        aml_read_cbus(_r)
-
-#define WRITE_CBUS_REG(_r, _v)   aml_write_cbus(_r, _v)
-#define READ_CBUS_REG(_r)        aml_read_cbus(_r)
-
-#define WRITE_VCBUS_REG(_r, _v)  aml_write_vcbus(_r, _v)
-#define READ_VCBUS_REG(_r)       aml_read_vcbus(_r)
-
-#define BASE_IRQ 32
-#define AM_IRQ(reg)             (reg + BASE_IRQ)
-#define INT_DEMUX               AM_IRQ(23)
-#define INT_DEMUX_1             AM_IRQ(5)
-#define INT_DEMUX_2             AM_IRQ(53)
-#define INT_ASYNC_FIFO_FILL     AM_IRQ(18)
-#define INT_ASYNC_FIFO_FLUSH    AM_IRQ(19)
-#define INT_ASYNC_FIFO2_FILL    AM_IRQ(24)
-#define INT_ASYNC_FIFO2_FLUSH   AM_IRQ(25)
-
-#endif
-
diff --git a/drivers/amlogic/dvb_tv/aml_fe.c b/drivers/amlogic/dvb_tv/aml_fe.c
deleted file mode 100644
index 6a31fb537fec..000000000000
--- a/drivers/amlogic/dvb_tv/aml_fe.c
+++ /dev/null
@@ -1,2860 +0,0 @@
-/*
- * AMLOGIC DVB frontend driver.
- */
-
-#include <linux/version.h>
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/mutex.h>
-#include <linux/wait.h>
-#include <linux/string.h>
-#include <linux/interrupt.h>
-#include <linux/fs.h>
-#include <linux/cdev.h>
-#include <linux/device.h>
-#include <linux/spinlock.h>
-#include <linux/fcntl.h>
-#include <asm/irq.h>
-#include <linux/uaccess.h>
-#include <linux/poll.h>
-#include <linux/delay.h>
-#include <linux/platform_device.h>
-#include <linux/gpio/consumer.h>
-#include <linux/gpio.h>
-#include "aml_fe.h"
-#include "amlatvdemod/atvdemod_func.h"
-
-
-#ifdef pr_dbg
-#undef pr_dbg
-#define pr_dbg(fmt, args ...) \
-	do { \
-		if (debug_fe) \
-			pr_info("FE: " fmt, ## args); \
-	} while (0)
-#endif
-#define pr_error(fmt, args ...) pr_err("FE: " fmt, ## args)
-#define pr_inf(fmt, args ...) pr_info("FE: " fmt, ## args)
-
-#define AFC_BEST_LOCK      50
-#define ATV_AFC_500KHZ   500000
-#define ATV_AFC_1_0MHZ   1000000
-#define ATV_AFC_2_0MHZ   2000000
-
-#define AML_FE_MAX_RES          50
-
-MODULE_PARM_DESC(debug_fe, "\n\t\t Enable frontend debug information");
-static int debug_fe;
-module_param(debug_fe, int, 0644);
-
-static int slow_mode;
-module_param(slow_mode, int, 0644);
-MODULE_DESCRIPTION("search the channel by slow_mode,by add +1MHz\n");
-
-static int video_mode_manul;
-module_param(video_mode_manul, int, 0644);
-MODULE_DESCRIPTION("search the video manully by get_frontend api\n");
-
-static int audio_mode_manul;
-module_param(audio_mode_manul, int, 0644);
-MODULE_DESCRIPTION("search the audio manully by get_froutend api\n");
-
-static int tuner_status_cnt = 16;	/*4-->16 test on sky mxl661 */
-module_param(tuner_status_cnt, int, 0644);
-MODULE_DESCRIPTION("after write a freq, max cnt value of read tuner status\n");
-
-static int delay_cnt = 10;	/*10-->20ms test on sky mxl661 */
-module_param(delay_cnt, int, 0644);
-MODULE_DESCRIPTION("delay_cnt value of read cvd format\n");
-
-static int delay_afc = 40;	/*ms new add on sky mxl661 */
-module_param(delay_afc, int, 0644);
-MODULE_DESCRIPTION("search the channel delay_afc,by add +1ms\n");
-
-static struct aml_fe_drv *tuner_drv_list;
-static struct aml_fe_drv *atv_demod_drv_list;
-static struct aml_fe_drv *dtv_demod_drv_list;
-static struct aml_fe_man fe_man;
-static long aml_fe_suspended;
-static int memstart = 0x1ef00000;
-
-static int afc_offset;
-module_param(afc_offset, uint, 0644);
-MODULE_PARM_DESC(afc_offset, "\n afc_offset\n");
-static int no_sig_cnt;
-struct timer_list aml_timer;
-#define AML_INTERVAL		(HZ/100)   /* 10ms, #define HZ 100 */
-static unsigned int timer_init_state;
-static unsigned int aft_thread_enable;
-static unsigned int aml_timer_en = 1;
-module_param(aml_timer_en, uint, 0644);
-MODULE_PARM_DESC(aml_timer_en, "\n aml_timer_en\n");
-
-static DEFINE_SPINLOCK(lock);
-static int aml_fe_afc_closer(struct dvb_frontend *fe, int minafcfreq,
-			     int maxafcfreq, int isAutoSearch);
-
-typedef int (*hook_func_t) (void);
-hook_func_t aml_fe_hook_atv_status = NULL;
-hook_func_t aml_fe_hook_hv_lock = NULL;
-hook_func_t aml_fe_hook_get_fmt = NULL;
-void aml_fe_hook_cvd(hook_func_t atv_mode, hook_func_t cvd_hv_lock,
-	hook_func_t get_fmt)
-{
-	aml_fe_hook_atv_status = atv_mode;
-	aml_fe_hook_hv_lock = cvd_hv_lock;
-	aml_fe_hook_get_fmt = get_fmt;
-	pr_dbg("[aml_fe]%s\n", __func__);
-}
-EXPORT_SYMBOL(aml_fe_hook_cvd);
-
-int amlogic_gpio_direction_output(unsigned int pin, int value,
-				  const char *owner)
-{
-	gpio_direction_output(pin, value);
-	return 0;
-}
-
-int amlogic_gpio_request(unsigned int pin, const char *label)
-{
-	return 0;
-}
-
-static v4l2_std_id trans_tvin_fmt_to_v4l2_std(int fmt)
-{
-	v4l2_std_id std = 0;
-	switch (fmt) {
-	case  TVIN_SIG_FMT_CVBS_NTSC_M:
-	case  TVIN_SIG_FMT_CVBS_NTSC_443:
-		std = V4L2_COLOR_STD_NTSC;
-		break;
-	case  TVIN_SIG_FMT_CVBS_PAL_I:
-	case  TVIN_SIG_FMT_CVBS_PAL_M:
-	case  TVIN_SIG_FMT_CVBS_PAL_60:
-	case  TVIN_SIG_FMT_CVBS_PAL_CN:
-		std = V4L2_COLOR_STD_PAL;
-		break;
-
-	case  TVIN_SIG_FMT_CVBS_SECAM:
-		std = V4L2_COLOR_STD_SECAM;
-		break;
-	default:
-		pr_err("%s err fmt: 0x%x\n", __func__, fmt);
-		break;
-	}
-	return std;
-}
-
-static v4l2_std_id demod_fmt_2_v4l2_std(int fmt)
-{
-	v4l2_std_id std = 0;
-	switch (fmt) {
-	case AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_DK:
-		std = V4L2_STD_PAL_DK;
-		break;
-	case AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_I:
-		std = V4L2_STD_PAL_I;
-		break;
-	case AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_BG:
-		std = V4L2_STD_PAL_BG;
-		break;
-	case AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_M:
-		std = V4L2_STD_PAL_M;
-		break;
-	case AML_ATV_DEMOD_VIDEO_MODE_PROP_NTSC_DK:
-	case AML_ATV_DEMOD_VIDEO_MODE_PROP_NTSC_I:
-	case AML_ATV_DEMOD_VIDEO_MODE_PROP_NTSC_BG:
-	case AML_ATV_DEMOD_VIDEO_MODE_PROP_NTSC:
-	case AML_ATV_DEMOD_VIDEO_MODE_PROP_NTSC_M:
-		std = V4L2_STD_NTSC_M;
-		break;
-	case AML_ATV_DEMOD_VIDEO_MODE_PROP_SECAM_L:
-		std = V4L2_STD_SECAM_L;
-		break;
-	case AML_ATV_DEMOD_VIDEO_MODE_PROP_SECAM_DK2:
-	case AML_ATV_DEMOD_VIDEO_MODE_PROP_SECAM_DK3:
-		std = V4L2_STD_SECAM_DK;
-		break;
-	default:
-		pr_err("%s unsupport fmt:0x%0x !!!\n", __func__, fmt);
-	}
-	return std;
-}
-
-static struct aml_fe_drv **aml_get_fe_drv_list(enum aml_fe_dev_type_t type)
-{
-	switch (type) {
-	case AM_DEV_TUNER:
-		return &tuner_drv_list;
-	case AM_DEV_ATV_DEMOD:
-		return &atv_demod_drv_list;
-	case AM_DEV_DTV_DEMOD:
-		return &dtv_demod_drv_list;
-	default:
-		return NULL;
-	}
-}
-
-int aml_register_fe_drv(enum aml_fe_dev_type_t type, struct aml_fe_drv *drv)
-{
-	if (drv) {
-		struct aml_fe_drv **list = aml_get_fe_drv_list(type);
-		unsigned long flags;
-
-		spin_lock_irqsave(&lock, flags);
-
-		drv->next = *list;
-		*list = drv;
-
-		drv->ref = 0;
-
-		spin_unlock_irqrestore(&lock, flags);
-	}
-
-	return 0;
-}
-EXPORT_SYMBOL(aml_register_fe_drv);
-
-int aml_unregister_fe_drv(enum aml_fe_dev_type_t type, struct aml_fe_drv *drv)
-{
-	int ret = 0;
-
-	if (drv) {
-		struct aml_fe_drv *pdrv, *pprev;
-		struct aml_fe_drv **list = aml_get_fe_drv_list(type);
-		unsigned long flags;
-
-		spin_lock_irqsave(&lock, flags);
-
-		if (!drv->ref) {
-			for (pprev = NULL, pdrv = *list;
-			     pdrv; pprev = pdrv, pdrv = pdrv->next) {
-				if (pdrv == drv) {
-					if (pprev)
-						pprev->next = pdrv->next;
-					else
-						*list = pdrv->next;
-					break;
-				}
-			}
-		} else {
-			pr_error("fe driver %d is inused\n", drv->id);
-			ret = -1;
-		}
-
-		spin_unlock_irqrestore(&lock, flags);
-	}
-
-	return ret;
-}
-EXPORT_SYMBOL(aml_unregister_fe_drv);
-
-struct dvb_frontend *get_si2177_tuner(void)
-{
-	int i;
-	struct aml_fe_dev *dev;
-
-	for (i = 0; i < FE_DEV_COUNT; i++) {
-		dev = &fe_man.tuner[i];
-		if (dev == NULL || dev->drv == NULL || dev->fe == NULL)
-			continue;
-#if (defined CONFIG_AM_SI2177)
-		if (!strcmp(dev->drv->name, "si2177_tuner"))
-			return dev->fe->fe;
-#elif (defined CONFIG_AM_MXL661)
-		if (!strcmp(dev->drv->name, "mxl661_tuner"))
-			return dev->fe->fe;
-#elif (defined CONFIG_AM_R840)
-		if (!strcmp(dev->drv->name, "r840_tuner"))
-			return dev->fe->fe;
-#else
-#endif
-		if (!strcmp(dev->drv->name, "r842_tuner"))
-			return dev->fe->fe;
-		return dev->fe->fe;
-	}
-	pr_error("can not find out tuner drv\n");
-	return NULL;
-}
-EXPORT_SYMBOL(get_si2177_tuner);
-
-void set_aft_thread_enable(int enable)
-{
-	aft_thread_enable = enable;
-}
-
-static void aml_fe_do_work(struct work_struct *work)
-{
-	struct aml_dvb *dvb = aml_get_dvb_device();
-	struct dvb_frontend *fe = dvb->fe;
-	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
-	int afc = 100;
-	static int afc_wave_cnt;
-	struct aml_fe *fee;
-	fee = fe->demodulator_priv;
-	retrieve_frequency_offset(&afc);
-	afc = afc*488/1000;
-	if (abs(afc) < AFC_BEST_LOCK) {
-		afc_wave_cnt = 0;
-		return;
-	} else {
-		afc_wave_cnt++;
-	}
-	if (afc_wave_cnt < 10) {
-		if (debug_fe & 0x1)
-			pr_err("%s,afc is wave,ignore\n", __func__);
-		return;
-	}
-	if (abs(afc_offset) >= 2000) {
-		no_sig_cnt++;
-		if (no_sig_cnt == 20) {
-			c->frequency -= afc_offset*1000;
-			if (fe->ops.tuner_ops.set_params)
-				fe->ops.tuner_ops.set_params(fe);
-			afc_offset = 0;
-		}
-		return;
-	}
-	no_sig_cnt = 0;
-	c->frequency += afc*1000;
-	afc_offset += afc;
-	if (fe->ops.tuner_ops.set_params)
-		fe->ops.tuner_ops.set_params(fe);
-}
-
-void aml_timer_hander(unsigned long arg)
-{
-	struct dvb_frontend *fe = (struct dvb_frontend *)arg;
-	struct aml_dvb *dvb = aml_get_dvb_device();
-	aml_timer.expires = jiffies + AML_INTERVAL*10;/* 100ms timer */
-	add_timer(&aml_timer);
-	if (!aft_thread_enable) {
-		pr_info("%s, stop aft thread\n", __func__);
-		return;
-	}
-	if ((aml_timer_en == 0) || (FE_ANALOG != fe->ops.info.type))
-		return;
-
-	dvb->fe = (struct dvb_frontend *)arg;
-	schedule_work(&dvb->aml_fe_wq);
-}
-
-int aml_fe_analog_set_frontend(struct dvb_frontend *fe)
-{
-	struct aml_fe *afe = fe->demodulator_priv;
-	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
-	struct analog_parameters p;
-	fe_status_t tuner_state = FE_TIMEDOUT;
-	int ret = -1;
-	struct aml_fe *fee;
-	fee = fe->demodulator_priv;
-
-	if (fe->ops.tuner_ops.set_params)
-		ret = fe->ops.tuner_ops.set_params(fe);
-	if (fe->ops.tuner_ops.get_status)
-		fe->ops.tuner_ops.get_status(fe, &tuner_state);
-
-	if (fee->tuner->drv->id == AM_TUNER_R840)
-		p.tuner_id = AM_TUNER_R840;
-	else if (fee->tuner->drv->id == AM_TUNER_SI2151)
-		p.tuner_id = AM_TUNER_SI2151;
-	else if (fee->tuner->drv->id == AM_TUNER_MXL661)
-		p.tuner_id = AM_TUNER_MXL661;
-	p.if_freq = fee->demod_param.if_freq;
-	p.if_inv = fee->demod_param.if_inv;
-
-	p.frequency  = c->frequency;
-	p.soundsys   = c->analog.soundsys;
-	p.audmode    = c->analog.audmode;
-	p.std        = c->analog.std;
-	p.reserved   = c->analog.reserved;
-
-	/*set tuner&ademod such as philipse tuner */
-	if (fe->ops.analog_ops.set_params) {
-		fe->ops.analog_ops.set_params(fe, &p);
-		ret = 0;
-	}
-
-	if (ret == 0) {
-		afe->params.frequency = c->frequency;
-		afe->params.inversion = c->inversion;
-		afe->params.analog = c->analog;
-	}
-	/* afc tune */
-	if (get_cpu_type() >= MESON_CPU_MAJOR_ID_MG9TV) {
-		if (aml_timer_en == 1) {
-			if (timer_init_state == 1) {
-				del_timer_sync(&aml_timer);
-				timer_init_state = 0;
-			}
-		}
-
-		if (aml_timer_en == 1 && aft_thread_enable) {
-			init_timer(&aml_timer);
-			aml_timer.function = aml_timer_hander;
-			aml_timer.data = (ulong) fe;
-			/* after 5s enable demod auto detect */
-			aml_timer.expires = jiffies + AML_INTERVAL*500;
-			afc_offset = 0;
-			no_sig_cnt = 0;
-			add_timer(&aml_timer);
-			timer_init_state = 1;
-		}
-	}
-
-	return ret;
-}
-EXPORT_SYMBOL(aml_fe_analog_set_frontend);
-
-static int aml_fe_analog_get_frontend(struct dvb_frontend *fe)
-{
-	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
-	struct aml_fe *afe = fe->demodulator_priv;
-	int audio = 0;
-	v4l2_std_id std_bk = 0;
-	int varify_cnt = 0, i = 0;
-	fe_status_t tuner_state = FE_TIMEDOUT;
-	fe_status_t ade_state = FE_TIMEDOUT;
-
-	p->frequency = afe->params.frequency;
-
-
-	if (video_mode_manul) {
-		fe->ops.tuner_ops.get_pll_status(fe, &tuner_state);
-		fe->ops.analog_ops.get_pll_status(fe, &ade_state);
-		if ((FE_HAS_LOCK == ade_state) ||
-				(FE_HAS_LOCK == tuner_state)) {
-			for (i = 0; i < 100; i++) {
-				if (aml_fe_hook_get_fmt == NULL)
-					break;
-				std_bk = aml_fe_hook_get_fmt();
-				if (std_bk)
-					varify_cnt++;
-				if (varify_cnt > 3)
-					break;
-				msleep(20);
-			}
-			if (std_bk == 0) {
-				pr_err("%s, failed to get v fmt\n",
-						__func__);
-				p->analog.std &= 0x00ffffff;
-				p->analog.std |= V4L2_COLOR_STD_PAL;
-			} else {
-				p->analog.std &= 0x00ffffff;
-				p->analog.std |=
-					trans_tvin_fmt_to_v4l2_std(std_bk);
-				pr_err("%s,frequency:%d,std_bk:0x%x,std:0x%x\n",
-					__func__, p->frequency,
-					(unsigned int)std_bk,
-					(unsigned int)p->analog.std);
-			}
-		}
-	}
-	if (audio_mode_manul) {
-		std_bk = p->analog.std & 0xff000000;
-		if (std_bk == V4L2_COLOR_STD_NTSC) {
-			audio = V4L2_STD_NTSC_M;
-		} else if (std_bk == V4L2_COLOR_STD_SECAM) {
-			audio = V4L2_STD_SECAM_L;
-		} else {
-			amlatvdemod_set_std(
-				AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_DK);
-			audio = aml_audiomode_autodet(fe);
-			amlatvdemod_set_std(audio);
-			audio = demod_fmt_2_v4l2_std(audio);
-		}
-		p->analog.audmode = audio;
-		p->analog.std &= 0xff000000;
-		p->analog.std |= audio;
-		pr_err("[%s] params.frequency:%d, audio:0x%0x, vfmt:0x%x\n",
-			__func__, p->frequency, (unsigned int)p->analog.audmode,
-			(unsigned int)p->analog.std);
-	}
-	return 0;
-}
-
-static int aml_fe_analog_sync_frontend(struct dvb_frontend *fe)
-{
-	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
-	struct aml_fe *afe = fe->demodulator_priv;
-
-	afe->params.frequency = p->frequency;
-	afe->params.inversion = p->inversion;
-	afe->params.analog = p->analog;
-
-	return 0;
-}
-
-static int aml_fe_analog_read_status(struct dvb_frontend *fe,
-				     fe_status_t *status)
-{
-	int ret = 0;
-
-	if (!status)
-		return -1;
-	/*atv only demod locked is vaild */
-	if (fe->ops.analog_ops.get_status)
-		fe->ops.analog_ops.get_status(fe, status);
-	else if (fe->ops.tuner_ops.get_status)
-		ret = fe->ops.tuner_ops.get_status(fe, status);
-
-	return ret;
-}
-
-static int aml_fe_analog_read_signal_strength(struct dvb_frontend *fe,
-					      u16 *strength)
-{
-	int ret = -1;
-	u16 s;
-
-	s = 0;
-	if (fe->ops.analog_ops.has_signal) {
-		fe->ops.analog_ops.has_signal(fe, &s);
-		*strength = s;
-		ret = 0;
-	} else if (fe->ops.tuner_ops.get_rf_strength) {
-		ret = fe->ops.tuner_ops.get_rf_strength(fe, strength);
-	}
-
-	return ret;
-}
-
-static int aml_fe_analog_read_signal_snr(struct dvb_frontend *fe, u16 *snr)
-{
-	if (!snr) {
-		pr_error("[aml_fe..]%s null pointer error.\n", __func__);
-		return -1;
-	}
-	if (fe->ops.analog_ops.get_snr)
-		*snr = (unsigned short)fe->ops.analog_ops.get_snr(fe);
-	return 0;
-}
-
-static enum dvbfe_algo aml_fe_get_analog_algo(struct dvb_frontend *dev)
-{
-	return DVBFE_ALGO_CUSTOM;
-}
-
-
-
-/*this func set two ways to search the channel*/
-/*if the afc_range>1Mhz,set the freq  more than once*/
-/*if the afc_range<=1MHz,set the freq only once ,on the mid freq*/
-static enum dvbfe_search aml_fe_analog_search(struct dvb_frontend *fe)
-{
-	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
-	fe_status_t tuner_state = FE_TIMEDOUT;
-	fe_status_t ade_state = FE_TIMEDOUT;
-	struct atv_status_s atv_status;
-	__u32 set_freq = 0;
-	__u32 minafcfreq, maxafcfreq;
-	__u32 frist_step;
-	__u32 afc_step;
-	int tuner_status_cnt_local = tuner_status_cnt;
-	int atv_cvd_format, hv_lock_status, snr_vale;
-	v4l2_std_id std_bk = 0;
-	struct aml_fe *fee;
-	int audio = 0;
-	int try_ntsc = 0, get_vfmt_maxcnt = 50;
-	int varify_cnt = 0, i = 0;
-
-#ifdef DEBUG_TIME_CUS
-	unsigned int time_start, time_end, time_delta;
-	time_start = jiffies_to_msecs(jiffies);
-#endif
-	fee = fe->demodulator_priv;
-	if ((fe == NULL) || (p == NULL) || (fee == NULL))
-		return DVBFE_ALGO_SEARCH_FAILED;
-	atv_cvd_format = 0;
-	hv_lock_status = 0;
-	snr_vale = 0;
-	pr_dbg("[%s],afc_range=%d,flag=0x%x[1->auto,11->mannul], freq=[%d]\n",
-	     __func__, p->analog.afc_range, p->analog.flag, p->frequency);
-	pr_dbg("the tuner type is [%d]\n", fee->tuner->drv->id);
-	/* backup the freq by api */
-	set_freq = p->frequency;
-
-	if (p->analog.std == 0) {
-		p->analog.std = (V4L2_COLOR_STD_NTSC | V4L2_STD_NTSC_M);
-		pr_dbg("%s, user analog.std is 0, so set it to NTSC | M\n",
-			__func__);
-	}
-	if (p->analog.afc_range == 0) {
-		pr_dbg("[%s]:afc_range==0,skip the search\n", __func__);
-		return DVBFE_ALGO_SEARCH_FAILED;
-	}
-/*set the frist_step*/
-	if (p->analog.afc_range > ATV_AFC_1_0MHZ)
-		frist_step = ATV_AFC_1_0MHZ;
-	else
-		frist_step = p->analog.afc_range;
-/*set the afc_range and start freq*/
-	minafcfreq = p->frequency - p->analog.afc_range;
-	maxafcfreq = p->frequency + p->analog.afc_range;
-/*from the min freq start,and set the afc_step*/
-	/*if step is 2Mhz,r840 will miss program*/
-	if (slow_mode || (fee->tuner->drv->id == AM_TUNER_R840)) {
-		pr_dbg("[%s]this is slow mode to search the channel\n",
-		       __func__);
-		p->frequency = minafcfreq;
-		afc_step = ATV_AFC_1_0MHZ;
-	} else if (!slow_mode) {
-		p->frequency = minafcfreq;
-		afc_step = ATV_AFC_2_0MHZ;
-	} else {
-		pr_dbg("[%s]unknown tuner type, slow_mode search the channel\n",
-			__func__);
-		p->frequency = minafcfreq;
-		afc_step = ATV_AFC_1_0MHZ;
-	}
-
-	/**enter manual search mode**/
-	if (p->analog.flag == ANALOG_FLAG_MANUL_SCAN) {
-		/*manul search force to ntsc_m */
-		std_bk = p->analog.std;
-		pr_dbg("%s Manully user analog.std:0x%08x\n",
-			__func__, (uint32_t)std_bk);
-		if (get_cpu_type() < MESON_CPU_MAJOR_ID_MG9TV)
-			p->analog.std = (V4L2_COLOR_STD_NTSC | V4L2_STD_NTSC_M);
-
-		if (fe->ops.set_frontend(fe)) {
-			pr_error("[%s]the func of set_param err.\n", __func__);
-			p->analog.std = std_bk;
-			fe->ops.set_frontend(fe);
-			std_bk = 0;
-			return DVBFE_ALGO_SEARCH_FAILED;
-		}
-
-		/*delete it will be not get program*/
-		if (fee->tuner->drv->id == AM_TUNER_MXL661)
-			usleep_range((delay_cnt+20)*1000,
-				(delay_cnt+20)*1000+100);
-		else
-			usleep_range(delay_cnt*1000, delay_cnt*1000+100);
-
-		if (get_cpu_type() >= MESON_CPU_MAJOR_ID_MG9TV) {
-			if ((fe->ops.tuner_ops.get_pll_status == NULL) ||
-			    (fe->ops.analog_ops.get_pll_status == NULL)) {
-				pr_info("[%s]error:the func of get_pll_status is NULL.\n",
-					__func__);
-				return DVBFE_ALGO_SEARCH_FAILED;
-			}
-			fe->ops.tuner_ops.get_pll_status(fe, &tuner_state);
-			fe->ops.analog_ops.get_pll_status(fe, &ade_state);
-		} else {
-			if ((fe->ops.tuner_ops.get_status == NULL) ||
-			    (fe->ops.analog_ops.get_status == NULL)) {
-				pr_info("[%s]error:the func of get_status is NULL.\n",
-					__func__);
-				return DVBFE_ALGO_SEARCH_FAILED;
-			}
-			fe->ops.tuner_ops.get_status(fe, &tuner_state);
-			fe->ops.analog_ops.get_status(fe, &ade_state);
-		}
-		if (((FE_HAS_LOCK == ade_state ||
-		      FE_HAS_LOCK == tuner_state) &&
-		     (fee->tuner->drv->id != AM_TUNER_R840)) ||
-		    ((FE_HAS_LOCK == ade_state &&
-		      FE_HAS_LOCK == tuner_state) &&
-		     (fee->tuner->drv->id == AM_TUNER_R840))) {
-			if (debug_fe & 0x1)
-				pr_err("[%s][%d]freq:%d pll lock success\n",
-					__func__, __LINE__, p->frequency);
-			if (fee->tuner->drv->id == AM_TUNER_MXL661) {
-				fe->ops.analog_ops.get_atv_status(fe,
-					&atv_status);
-				if (atv_status.atv_lock)
-					usleep_range(20*1000, 20*1000+100);
-			}
-			if (fee->tuner->drv->id == AM_TUNER_MXL661)
-				usleep_range(40*1000, 40*1000+100);
-
-			if (aml_fe_afc_closer(fe, p->frequency,
-					      p->frequency + ATV_AFC_500KHZ, 1)
-				== 0) {
-				try_ntsc = 0;
-				get_vfmt_maxcnt = 200;
-				p->analog.std =
-					(V4L2_COLOR_STD_PAL | V4L2_STD_PAL_I);
-				p->frequency += 1;
-				fe->ops.set_frontend(fe);
-				usleep_range(10*1000, 10*1000+100);
-
-			while (1) {
-				for (i = 0; i < get_vfmt_maxcnt; i++) {
-					if (aml_fe_hook_get_fmt == NULL)
-						break;
-					std_bk = aml_fe_hook_get_fmt();
-					if (std_bk)
-						varify_cnt++;
-					if (varify_cnt > 3)
-						break;
-					if (i == (get_vfmt_maxcnt/3) ||
-						(i == (get_vfmt_maxcnt/3)*2)) {
-						p->analog.std =
-							(V4L2_COLOR_STD_NTSC
-							| V4L2_STD_NTSC_M);
-						p->frequency += 1;
-						fe->ops.set_frontend(fe);
-					}
-					usleep_range(20*1000, 20*1000+100);
-				}
-				if (std_bk == 0) {
-					pr_err("%s, failed to get v fmt !!\n",
-						__func__);
-					if (try_ntsc > 0) {
-						pr_err("%s,vfmt assume PAL!!\n",
-							__func__);
-						std_bk =
-							TVIN_SIG_FMT_CVBS_PAL_I;
-						break;
-					} else {
-						p->analog.std =
-							(V4L2_COLOR_STD_NTSC
-							| V4L2_STD_NTSC_M);
-						p->frequency += 1;
-						fe->ops.set_frontend(fe);
-						usleep_range(10*1000,
-							10*1000+100);
-						try_ntsc++;
-						continue;
-					}
-				}
-				break;
-			}
-			if (try_ntsc) {
-				p->analog.std =
-					(V4L2_COLOR_STD_PAL | V4L2_STD_PAL_DK);
-				p->frequency += 1;
-				fe->ops.set_frontend(fe);
-				usleep_range(10*1000, 10*1000+100);
-			}
-			std_bk = trans_tvin_fmt_to_v4l2_std(std_bk);
-			if (std_bk == V4L2_COLOR_STD_NTSC) {
-				amlatvdemod_set_std(
-					AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_DK);
-				audio = aml_audiomode_autodet(fe);
-				audio = demod_fmt_2_v4l2_std(audio);
-				if (audio == V4L2_STD_PAL_M)
-					audio = V4L2_STD_NTSC_M;
-				else
-					std_bk = V4L2_COLOR_STD_PAL;
-			} else if (std_bk == V4L2_COLOR_STD_SECAM) {
-				audio = V4L2_STD_SECAM_L;
-			} else {
-				amlatvdemod_set_std(
-					AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_DK);
-				audio = aml_audiomode_autodet(fe);
-				audio = demod_fmt_2_v4l2_std(audio);
-				if (audio == V4L2_STD_PAL_M) {
-					audio = demod_fmt_2_v4l2_std(
-						broad_std_except_pal_m);
-					pr_err("select best audio mode 0x%x\n",
-						audio);
-				}
-			}
-			pr_err("%s,Manual freq:%d: std_bk:0x%x ,audmode:0x%x\n",
-				__func__, p->frequency,
-				(unsigned int)std_bk, audio);
-			if (std_bk != 0) {
-				p->analog.audmode = audio;
-				p->analog.std = std_bk | audio;
-				/*avoid std unenable */
-				p->frequency -= 1;
-				std_bk = 0;
-			}
-#ifdef DEBUG_TIME_CUS
-			time_end = jiffies_to_msecs(jiffies);
-			time_delta = time_end - time_start;
-			pr_dbg("[ATV_SEARCH_SUCCESS]%s: time_delta:%d ms\n",
-				__func__, time_delta);
-#endif
-			/*sync param */
-			aml_fe_analog_sync_frontend(fe);
-			return DVBFE_ALGO_SEARCH_SUCCESS;
-
-			}
-		}
-		usleep_range(10*1000, 10*1000+100);
-		p->frequency += afc_step;
-		return DVBFE_ALGO_SEARCH_FAILED;
-	}
-	/**enter auto search mode**/
-	pr_dbg("%s Autosearch user analog.std:0x%08x\n",
-		__func__, (uint32_t)p->analog.std);
-	if (fe->ops.set_frontend(fe)) {
-		pr_error("[%s]the func of set_param err.\n", __func__);
-		return DVBFE_ALGO_SEARCH_FAILED;
-	}
-#ifdef DEBUG_TIME_CUS
-	time_end = jiffies_to_msecs(jiffies);
-	time_delta = time_end - time_start;
-	pr_dbg
-	    ("[ATV_SEARCH_SET_FRONTEND]%s: time_delta_001:%d ms,afc_step:%d\n",
-	     __func__, time_delta, afc_step);
-#endif
-/* atuo bettween afc range */
-	if (unlikely(!fe->ops.tuner_ops.get_status ||
-		     !fe->ops.analog_ops.get_status || !fe->ops.set_frontend)) {
-		pr_error("[%s]error: NULL func.\n", __func__);
-		return DVBFE_ALGO_SEARCH_FAILED;
-	}
-	while (p->frequency <= maxafcfreq) {
-		if (debug_fe & 0x3)
-			pr_err("[%s] p->frequency=[%d] is processing,maxafcfreq:[%d]\n",
-				__func__, p->frequency, maxafcfreq);
-		if (fee->tuner->drv->id != AM_TUNER_R840 &&
-		fee->tuner->drv->id != AM_TUNER_MXL661 &&
-		fee->tuner->drv->id != AM_TUNER_SI2151) {
-			do {
-				if (get_cpu_type() != MESON_CPU_MAJOR_ID_GXTVBB)
-					usleep_range(delay_cnt*1000,
-						delay_cnt*1000+100);
-				if ((fe->ops.tuner_ops.get_pll_status == NULL)
-				    ||
-				    (fe->ops.analog_ops.get_pll_status ==
-				     NULL)) {
-					pr_info("[%s]error:the func of get_pll_status is NULL.\n",
-						__func__);
-					return DVBFE_ALGO_SEARCH_FAILED;
-				}
-				fe->ops.tuner_ops.get_pll_status(fe,
-								 &tuner_state);
-				fe->ops.analog_ops.get_pll_status(fe,
-								  &ade_state);
-				tuner_status_cnt_local--;
-				if (FE_HAS_LOCK == ade_state ||
-				    FE_HAS_LOCK == tuner_state ||
-				    tuner_status_cnt_local == 0)
-					break;
-			} while (1);
-			tuner_status_cnt_local = tuner_status_cnt;
-			if (FE_HAS_LOCK == ade_state ||
-			    FE_HAS_LOCK == tuner_state) {
-				pr_dbg("[%s] pll lock success\n", __func__);
-				do {
-					tuner_status_cnt_local--;
-					/*tvafe_cvd2_get_atv_format(); */
-					if (aml_fe_hook_atv_status != NULL)
-						atv_cvd_format =
-					    aml_fe_hook_atv_status();
-					/*tvafe_cvd2_get_hv_lock(); */
-					if (aml_fe_hook_hv_lock != NULL)
-						hv_lock_status =
-						aml_fe_hook_hv_lock();
-					if (fe->ops.analog_ops.get_snr != NULL)
-						snr_vale =
-					    fe->ops.analog_ops.get_snr(fe);
-
-					pr_dbg("[%s] atv_cvd_format:0x%x;"
-						"hv_lock_status:0x%x;"
-						"snr_vale:%d, v fmt:0x%x\n",
-						__func__, atv_cvd_format,
-						hv_lock_status, snr_vale,
-						(unsigned int)std_bk);
-					if (((atv_cvd_format & 0x4) == 0)
-					    || ((hv_lock_status == 0x4)
-						&& (snr_vale < 10))) {
-						std_bk = p->analog.std
-							 & 0xff000000;
-						audio =
-						aml_audiomode_autodet(fe);
-						p->analog.std = std_bk |
-						demod_fmt_2_v4l2_std(audio);
-						p->analog.audmode =
-						demod_fmt_2_v4l2_std(audio);
-						/*avoid std unenable */
-						p->frequency += 1;
-						pr_dbg("[%s] maybe ntsc m\n",
-						       __func__);
-						break;
-					}
-					if (tuner_status_cnt_local == 0)
-						break;
-				if (get_cpu_type() != MESON_CPU_MAJOR_ID_GXTVBB)
-					usleep_range(delay_cnt*1000,
-						delay_cnt*1000+100);
-				} while (1);
-			}
-			if (tuner_status_cnt_local != 0) {
-				if (fe->ops.set_frontend(fe)) {
-					pr_info("[%s] the func of set_frontend err.\n",
-						__func__);
-					return DVBFE_ALGO_SEARCH_FAILED;
-				}
-			}
-		}
-		tuner_status_cnt_local = tuner_status_cnt;
-		do {
-			if (fee->tuner->drv->id == AM_TUNER_MXL661)
-				usleep_range((delay_cnt+15)*1000,
-					(delay_cnt+15)*1000+100);
-/*			if (fee->tuner->drv->id == AM_TUNER_R840)
-				usleep_range(delay_cnt*1000,
-					 delay_cnt*1000+100);
-*/
-			if (get_cpu_type() >= MESON_CPU_MAJOR_ID_MG9TV) {
-				if ((fe->ops.tuner_ops.get_pll_status == NULL)
-				    ||
-				    (fe->ops.analog_ops.get_pll_status ==
-				     NULL)) {
-					pr_info("[%s]error:the func of get_pll_status is NULL.\n",
-						__func__);
-					return DVBFE_ALGO_SEARCH_FAILED;
-				}
-				fe->ops.tuner_ops.get_pll_status(fe,
-								 &tuner_state);
-				fe->ops.analog_ops.get_pll_status(fe,
-								  &ade_state);
-			} else {
-				if ((fe->ops.tuner_ops.get_status == NULL)
-				    ||
-				    (fe->ops.analog_ops.get_status ==
-				     NULL)) {
-					pr_info("[%s]error:the func of get_status is NULL.\n",
-						__func__);
-					return DVBFE_ALGO_SEARCH_FAILED;
-				}
-				fe->ops.tuner_ops.get_status(fe, &tuner_state);
-				fe->ops.analog_ops.get_status(fe, &ade_state);
-			}
-			tuner_status_cnt_local--;
-			if (((FE_HAS_LOCK == ade_state ||
-			      FE_HAS_LOCK == tuner_state) &&
-			     (fee->tuner->drv->id != AM_TUNER_R840)) ||
-			    ((FE_HAS_LOCK == ade_state &&
-			      FE_HAS_LOCK == tuner_state) &&
-			     (fee->tuner->drv->id == AM_TUNER_R840)) ||
-			    (tuner_status_cnt_local == 0))
-				break;
-		} while (1);
-		tuner_status_cnt_local = tuner_status_cnt;
-		if (((FE_HAS_LOCK == ade_state ||
-		      FE_HAS_LOCK == tuner_state) &&
-		     (fee->tuner->drv->id != AM_TUNER_R840)) ||
-		    ((FE_HAS_LOCK == ade_state &&
-		      FE_HAS_LOCK == tuner_state) &&
-		     (fee->tuner->drv->id == AM_TUNER_R840))) {
-			if (debug_fe & 0x1)
-				pr_err("[%s][%d]freq:%d pll lock success\n",
-			       __func__, __LINE__, p->frequency);
-			if (fee->tuner->drv->id == AM_TUNER_MXL661) {
-				fe->ops.analog_ops.get_atv_status(fe,
-					&atv_status);
-				if (atv_status.atv_lock)
-					usleep_range(20*1000, 20*1000+100);
-			}
-			if (aml_fe_afc_closer(fe, minafcfreq,
-				maxafcfreq + ATV_AFC_500KHZ, 1) == 0) {
-				try_ntsc = 0;
-				get_vfmt_maxcnt = 200;
-			while (1) {
-				for (i = 0; i < get_vfmt_maxcnt; i++) {
-					if (aml_fe_hook_get_fmt == NULL)
-						break;
-					std_bk = aml_fe_hook_get_fmt();
-					if (std_bk)
-						varify_cnt++;
-				if (fee->tuner->drv->id == AM_TUNER_R840) {
-					if (varify_cnt > 0)
-						break;
-				}
-					if (varify_cnt > 3)
-						break;
-					if (i == (get_vfmt_maxcnt/3) ||
-						(i == (get_vfmt_maxcnt/3)*2)) {
-						p->analog.std =
-							(V4L2_COLOR_STD_NTSC
-							| V4L2_STD_NTSC_M);
-						p->frequency += 1;
-						fe->ops.set_frontend(fe);
-					}
-					usleep_range(20*1000, 20*1000+100);
-				}
-				if (debug_fe & 0x2)
-					pr_err("get std_bk cnt:%d\n", i);
-
-				if (std_bk == 0) {
-					pr_err("%s, failed to get v fmt !!\n",
-						__func__);
-					if (try_ntsc > 0) {
-						pr_err("%s,vfmt assume PAL!!\n",
-							__func__);
-						std_bk =
-							TVIN_SIG_FMT_CVBS_PAL_I;
-						break;
-					} else {
-						p->analog.std =
-							(V4L2_COLOR_STD_NTSC
-							| V4L2_STD_NTSC_M);
-						p->frequency += 1;
-						fe->ops.set_frontend(fe);
-						usleep_range(10*1000,
-							10*1000+100);
-						try_ntsc++;
-						continue;
-					}
-				}
-				break;
-			}
-			if (try_ntsc) {
-				p->analog.std = (V4L2_COLOR_STD_PAL
-					| V4L2_STD_PAL_DK);
-				p->frequency += 1;
-				fe->ops.set_frontend(fe);
-				usleep_range(10*1000, 10*1000+100);
-			}
-			std_bk = trans_tvin_fmt_to_v4l2_std(std_bk);
-
-			if (std_bk == V4L2_COLOR_STD_NTSC) {
-				amlatvdemod_set_std(
-					AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_DK);
-				audio = aml_audiomode_autodet(fe);
-				audio = demod_fmt_2_v4l2_std(audio);
-				if (audio == V4L2_STD_PAL_M)
-					audio = V4L2_STD_NTSC_M;
-				else
-					std_bk = V4L2_COLOR_STD_PAL;
-			} else if (std_bk == V4L2_COLOR_STD_SECAM) {
-				audio = V4L2_STD_SECAM_L;
-			} else {
-				amlatvdemod_set_std(
-					AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_DK);
-				audio = aml_audiomode_autodet(fe);
-				audio = demod_fmt_2_v4l2_std(audio);
-				if (audio == V4L2_STD_PAL_M) {
-					audio = demod_fmt_2_v4l2_std(
-						broad_std_except_pal_m);
-					pr_err("select the audio mode 0x%x\n",
-						audio);
-				}
-			}
-			pr_err("%s,Auto search freq:%d: std_bk:0x%x ,audmode:0x%x\n",
-					__func__, p->frequency,
-					(unsigned int)std_bk, audio);
-				if (std_bk != 0) {
-					p->analog.audmode = audio;
-					p->analog.std = std_bk | audio;
-					/*avoid std unenable */
-					p->frequency -= 1;
-					std_bk = 0;
-				}
-#ifdef DEBUG_TIME_CUS
-				time_end = jiffies_to_msecs(jiffies);
-				time_delta = time_end - time_start;
-				pr_dbg("[ATV_SEARCH_SUCCESS]%s: time_delta:%d ms\n",
-					__func__, time_delta);
-#endif
-				/*sync param */
-				aml_fe_analog_sync_frontend(fe);
-				return DVBFE_ALGO_SEARCH_SUCCESS;
-			}
-		}
-		/*avoid sound format is not match after search over */
-		if (std_bk != 0) {
-			p->analog.std = std_bk;
-			fe->ops.set_frontend(fe);
-			std_bk = 0;
-		}
-		pr_dbg("[%s] freq[analog.std:0x%08x] is[%d] unlock\n",
-			__func__, (uint32_t)p->analog.std, p->frequency);
-		p->frequency += afc_step;
-		if (p->frequency > maxafcfreq) {
-			pr_dbg("[%s] p->frequency=[%d] over maxafcfreq=[%d].search failed.\n",
-				__func__, p->frequency, maxafcfreq);
-			/*back  original freq  to api */
-			p->frequency = set_freq;
-			fe->ops.set_frontend(fe);
-#ifdef DEBUG_TIME_CUS
-			time_end = jiffies_to_msecs(jiffies);
-			time_delta = time_end - time_start;
-			pr_dbg("[ATV_SEARCH_FAILED]%s: time_delta:%d ms\n",
-			       __func__, time_delta);
-#endif
-			return DVBFE_ALGO_SEARCH_FAILED;
-		}
-		fe->ops.set_frontend(fe);
-	}
-#ifdef DEBUG_TIME_CUS
-	time_end = jiffies_to_msecs(jiffies);
-	time_delta = time_end - time_start;
-	pr_dbg("[ATV_SEARCH_FAILED]%s: time_delta:%d ms\n",
-	       __func__, time_delta);
-#endif
-	return DVBFE_ALGO_SEARCH_FAILED;
-}
-
-static int aml_fe_afc_closer(struct dvb_frontend *fe, int minafcfreq,
-			     int maxafcfreq, int isAutoSearch)
-{
-	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
-	int afc = 100;
-	__u32 set_freq;
-	int count = 25;
-	int lock_cnt = 0;
-	struct aml_fe *fee;
-	static int freq_success;
-	static int temp_freq, temp_afc;
-	struct timespec time_now;
-	static struct timespec success_time;
-	fee = fe->demodulator_priv;
-	if (debug_fe & 0x2)
-		pr_err("%s: freq_success:%d,freq:%d,minfreq:%d,maxfreq:%d\n",
-			__func__, freq_success, c->frequency,
-			minafcfreq, maxafcfreq);
-
-	/* avoid more search the same program */
-	if (abs(c->frequency - freq_success) < 3000000) {
-		ktime_get_ts(&time_now);
-		if (debug_fe & 0x2)
-			pr_err("%s: tv_sec now:%ld,tv_sec success:%ld\n",
-				__func__, time_now.tv_sec, success_time.tv_sec);
-		/* beyond 10s search same frequency is ok */
-		if ((time_now.tv_sec - success_time.tv_sec) < 10)
-			return -1;
-	}
-	/*do the auto afc make sure the afc<50k or the range from api */
-	if ((fe->ops.analog_ops.get_afc || fe->ops.tuner_ops.get_afc) &&
-	    fe->ops.set_frontend) {
-		/*
-			delete it will miss program
-			when c->frequency equal program frequency
-		*/
-		c->frequency++;
-		if (fe->ops.tuner_ops.set_params)
-			fe->ops.tuner_ops.set_params(fe);
-		if (fee->tuner->drv->id == AM_TUNER_SI2151
-				|| fee->tuner->drv->id == AM_TUNER_R840)
-			usleep_range(10*1000, 10*1000+100);
-		else if (fee->tuner->drv->id == AM_TUNER_MXL661)
-			usleep_range(20*1000, 20*1000+100);
-		/*****************************/
-		set_freq = c->frequency;
-		while (abs(afc) > AFC_BEST_LOCK) {
-			if ((fe->ops.analog_ops.get_afc) &&
-			    ((fee->tuner->drv->id == AM_TUNER_R840) ||
-			     (fee->tuner->drv->id == AM_TUNER_SI2151) ||
-			     (fee->tuner->drv->id == AM_TUNER_MXL661)))
-				fe->ops.analog_ops.get_afc(fe, &afc);
-			else if (fe->ops.tuner_ops.get_afc)
-				fe->ops.tuner_ops.get_afc(fe, &afc);
-
-			if (afc == 0xffff) {
-				/*last lock, but this unlock,so try get afc*/
-				if (lock_cnt > 0) {
-					c->frequency =
-						temp_freq + temp_afc*1000;
-					if (debug_fe & 0x2)
-						pr_err("%s,force lock,f:%d\n",
-							__func__, c->frequency);
-					freq_success = c->frequency;
-					ktime_get_ts(&success_time);
-					return 0;
-				} else
-					afc = 500;
-			} else {
-				lock_cnt++;
-				temp_freq = c->frequency;
-				if (afc > 50)
-					temp_afc = 500;
-				else if (afc < -50)
-					temp_afc = -500;
-				else
-					temp_afc = afc;
-			}
-
-			if (((abs(afc) > (500 - AFC_BEST_LOCK))
-				&& (abs(afc) < (500 + AFC_BEST_LOCK))
-				&& (abs(afc) != 500))
-				|| ((abs(afc) == 500) && (lock_cnt > 0))) {
-				c->frequency += afc * 1000;
-				break;
-			}
-
-			if (afc >= (500 + AFC_BEST_LOCK))
-				afc = 500;
-
-			c->frequency += afc * 1000;
-
-			if (unlikely(c->frequency > maxafcfreq)) {
-				if (debug_fe & 0x2)
-					pr_err("[%s]:[%d] is exceed maxafcfreq[%d]\n",
-						__func__, c->frequency,
-						maxafcfreq);
-				c->frequency = set_freq;
-				return -1;
-			}
-			#if 0 /*if enable ,it would miss program*/
-			if (unlikely(c->frequency < minafcfreq)) {
-				pr_dbg("[%s]:[%d ] is exceed minafcfreq[%d]\n",
-				       __func__, c->frequency, minafcfreq);
-				c->frequency = set_freq;
-				return -1;
-			}
-			#endif
-			if (likely(!(count--))) {
-				if (debug_fe & 0x2)
-					pr_err("[%s]:exceed the afc count\n",
-						__func__);
-				c->frequency = set_freq;
-				return -1;
-			}
-
-			/* afc tune */
-			if (get_cpu_type() >= MESON_CPU_MAJOR_ID_MG9TV) {
-				if (aml_timer_en == 1) {
-					if (timer_init_state == 1) {
-						del_timer_sync(&aml_timer);
-						timer_init_state = 0;
-					}
-				}
-
-				if (aml_timer_en == 1 && aft_thread_enable) {
-					init_timer(&aml_timer);
-					aml_timer.function = aml_timer_hander;
-					aml_timer.data = (ulong) fe;
-					/* after 5s enable demod auto detect*/
-					aml_timer.expires =
-						jiffies + AML_INTERVAL*500;
-					afc_offset = 0;
-					no_sig_cnt = 0;
-					add_timer(&aml_timer);
-					timer_init_state = 1;
-				}
-			}
-			c->frequency++;
-			if (fe->ops.tuner_ops.set_params)
-				fe->ops.tuner_ops.set_params(fe);
-
-			/*delete it will miss program*/
-			if (fee->tuner->drv->id == AM_TUNER_MXL661)
-				usleep_range(20*1000, 20*1000+100);
-			else
-				usleep_range(10*1000, 10*1000+100);
-
-			if (debug_fe & 0x2)
-				pr_err("[aml_fe..]%s get afc %d khz, freq %u.\n",
-					__func__, afc, c->frequency);
-		}
-		freq_success = c->frequency;
-		ktime_get_ts(&success_time);
-		if (debug_fe & 0x2)
-			pr_err("[aml_fe..]%s get afc %d khz done, freq %u.\n",
-				__func__, afc, c->frequency);
-	}
-	return 0;
-}
-
-static int aml_fe_set_mode(struct dvb_frontend *dev, fe_type_t type)
-{
-	struct aml_fe *fe;
-	enum aml_fe_mode_t mode;
-	unsigned long flags;
-	int ret = 0;
-
-	fe = dev->demodulator_priv;
-	/*type=FE_ATSC; */
-	switch (type) {
-	case FE_QPSK:
-		mode = AM_FE_QPSK;
-		pr_dbg("set mode -> QPSK\n");
-		break;
-	case FE_QAM:
-		pr_dbg("set mode -> QAM\n");
-		mode = AM_FE_QAM;
-		break;
-	case FE_OFDM:
-		pr_dbg("set mode -> OFDM\n");
-		mode = AM_FE_OFDM;
-		break;
-	case FE_ATSC:
-		pr_dbg("set mode -> ATSC\n");
-		mode = AM_FE_ATSC;
-		break;
-	case FE_ISDBT:
-		pr_dbg("set mode -> ISDBT\n");
-		mode = AM_FE_ISDBT;
-		break;
-	case FE_DTMB:
-		pr_dbg("set mode -> DTMB\n");
-		mode = AM_FE_DTMB;
-		break;
-	case FE_ANALOG:
-		pr_dbg("set mode -> ANALOG\n");
-		mode = AM_FE_ANALOG;
-		break;
-	default:
-		pr_error("illegal fe type %d\n", type);
-		return -1;
-	}
-
-	if (fe->mode == mode) {
-		pr_dbg("[%s]:the mode is not change!!!!\n", __func__);
-		return 0;
-	}
-
-	if (fe->mode != AM_FE_UNKNOWN) {
-		pr_dbg("leave mode %d\n", fe->mode);
-
-		if (fe->dtv_demod && (fe->dtv_demod->drv->capability & fe->mode)
-		    && fe->dtv_demod->drv->leave_mode)
-			fe->dtv_demod->drv->leave_mode(fe, fe->mode);
-		if (fe->atv_demod && (fe->atv_demod->drv->capability & fe->mode)
-		    && fe->atv_demod->drv->leave_mode)
-			fe->atv_demod->drv->leave_mode(fe, fe->mode);
-		if (fe->tuner && (fe->tuner->drv->capability & fe->mode)
-		    && fe->tuner->drv->leave_mode)
-			fe->tuner->drv->leave_mode(fe, fe->mode);
-
-		if (fe->mode & AM_FE_DTV_MASK)
-			aml_dmx_register_frontend(fe->ts, NULL);
-
-		fe->mode = AM_FE_UNKNOWN;
-	}
-
-	if (!(mode & fe->capability)) {
-		int i;
-
-		spin_lock_irqsave(&lock, flags);
-		for (i = 0; i < FE_DEV_COUNT; i++) {
-			if ((mode & fe_man.fe[i].capability)
-			    && (fe_man.fe[i].dev_id == fe->dev_id))
-				break;
-		}
-		spin_unlock_irqrestore(&lock, flags);
-
-		if (i >= FE_DEV_COUNT) {
-			pr_error
-			    ("frend %p don't support mode %x, capability %x\n",
-			     fe, mode, fe->capability);
-			return -1;
-		}
-
-		fe = &fe_man.fe[i];
-		dev->demodulator_priv = fe;
-	}
-
-	if (fe->mode & AM_FE_DTV_MASK) {
-		aml_dmx_register_frontend(fe->ts, NULL);
-		fe->mode = 0;
-	}
-
-	spin_lock_irqsave(&fe->slock, flags);
-
-	memset(&fe->fe->ops.tuner_ops, 0, sizeof(fe->fe->ops.tuner_ops));
-	memset(&fe->fe->ops.analog_ops, 0, sizeof(fe->fe->ops.analog_ops));
-	memset(&fe->fe->ops.info, 0, sizeof(fe->fe->ops.info));
-	fe->fe->ops.release = NULL;
-	fe->fe->ops.release_sec = NULL;
-	fe->fe->ops.init = NULL;
-	fe->fe->ops.sleep = NULL;
-	fe->fe->ops.write = NULL;
-	fe->fe->ops.tune = NULL;
-	fe->fe->ops.get_frontend_algo = NULL;
-	fe->fe->ops.set_frontend = NULL;
-	fe->fe->ops.get_tune_settings = NULL;
-	fe->fe->ops.get_frontend = NULL;
-	fe->fe->ops.read_status = NULL;
-	fe->fe->ops.read_ber = NULL;
-	fe->fe->ops.read_signal_strength = NULL;
-	fe->fe->ops.read_snr = NULL;
-	fe->fe->ops.read_ucblocks = NULL;
-	fe->fe->ops.set_qam_mode = NULL;
-	fe->fe->ops.diseqc_reset_overload = NULL;
-	fe->fe->ops.diseqc_send_master_cmd = NULL;
-	fe->fe->ops.diseqc_recv_slave_reply = NULL;
-	fe->fe->ops.diseqc_send_burst = NULL;
-	fe->fe->ops.set_tone = NULL;
-	fe->fe->ops.set_voltage = NULL;
-	fe->fe->ops.enable_high_lnb_voltage = NULL;
-	fe->fe->ops.dishnetwork_send_legacy_command = NULL;
-	fe->fe->ops.i2c_gate_ctrl = NULL;
-	fe->fe->ops.ts_bus_ctrl = NULL;
-	fe->fe->ops.search = NULL;
-	fe->fe->ops.track = NULL;
-	fe->fe->ops.set_property = NULL;
-	fe->fe->ops.get_property = NULL;
-	memset(&fe->fe->ops.blindscan_ops, 0,
-	       sizeof(fe->fe->ops.blindscan_ops));
-	fe->fe->ops.asyncinfo.set_frontend_asyncenable = 0;
-	if (fe->tuner && fe->tuner->drv && (mode & fe->tuner->drv->capability)
-	    && fe->tuner->drv->get_ops)
-		fe->tuner->drv->get_ops(fe->tuner, mode,
-					&fe->fe->ops.tuner_ops);
-
-	if (fe->atv_demod && fe->atv_demod->drv
-	    && (mode & fe->atv_demod->drv->capability)
-	    && fe->atv_demod->drv->get_ops) {
-		fe->atv_demod->drv->get_ops(fe->atv_demod, mode,
-					    &fe->fe->ops.analog_ops);
-		fe->fe->ops.set_frontend = aml_fe_analog_set_frontend;
-		fe->fe->ops.get_frontend = aml_fe_analog_get_frontend;
-		fe->fe->ops.read_status = aml_fe_analog_read_status;
-		fe->fe->ops.read_signal_strength =
-		    aml_fe_analog_read_signal_strength;
-		fe->fe->ops.read_snr = aml_fe_analog_read_signal_snr;
-		fe->fe->ops.get_frontend_algo = aml_fe_get_analog_algo;
-		fe->fe->ops.search = aml_fe_analog_search;
-	}
-
-	if (fe->dtv_demod && fe->dtv_demod->drv
-	    && (mode & fe->dtv_demod->drv->capability)
-	    && fe->dtv_demod->drv->get_ops)
-		fe->dtv_demod->drv->get_ops(fe->dtv_demod, mode, &fe->fe->ops);
-
-	spin_unlock_irqrestore(&fe->slock, flags);
-
-	pr_dbg("enter mode %d\n", mode);
-
-	if (fe->dtv_demod && (fe->dtv_demod->drv->capability & mode)
-	    && fe->dtv_demod->drv->enter_mode)
-		ret = fe->dtv_demod->drv->enter_mode(fe, mode);
-	if (fe->atv_demod && (fe->atv_demod->drv->capability & mode)
-	    && fe->atv_demod->drv->enter_mode)
-		ret = fe->atv_demod->drv->enter_mode(fe, mode);
-	if (fe->tuner && (fe->tuner->drv->capability & mode)
-	    && fe->tuner->drv->enter_mode)
-		ret = fe->tuner->drv->enter_mode(fe, mode);
-	if (ret != 0) {
-		pr_error("enter mode %d fail, ret %d\n", mode, ret);
-		return ret;
-	}
-
-	pr_dbg("register demux frontend\n");
-	if (mode & AM_FE_DTV_MASK)
-		aml_dmx_register_frontend(fe->ts, fe->fe);
-	strcpy(fe->fe->ops.info.name, "amlogic dvb frontend");
-
-	fe->fe->ops.info.type = type;
-	fe->mode = mode;
-
-	pr_dbg("set mode ok\n");
-
-	return 0;
-}
-
-static int aml_fe_read_ts(struct dvb_frontend *dev, int *ts)
-{
-	struct aml_fe *fe;
-
-	fe = dev->demodulator_priv;
-
-	*ts = fe->ts;
-	return 0;
-}
-
-#ifndef CONFIG_OF
-struct resource *aml_fe_platform_get_resource_byname(const char *name)
-{
-	int i;
-
-	for (i = 0; i < aml_fe_num_resources; i++) {
-		struct resource *r = &aml_fe_resource[i];
-
-		if (!strcmp(r->name, name))
-			return r;
-	}
-	return NULL;
-}
-#endif				/*CONFIG_OF */
-#if (defined CONFIG_AM_DTVDEMOD)
-static int rmem_demod_device_init(struct reserved_mem *rmem, struct device *dev)
-{
-	unsigned int demod_mem_start;
-	unsigned int demod_mem_size;
-
-	demod_mem_start = rmem->base;
-	demod_mem_size = rmem->size;
-	memstart = demod_mem_start;
-	pr_info("demod reveser memory 0x%x, size %dMB.\n",
-		demod_mem_start, (demod_mem_size >> 20));
-	return 1;
-}
-
-static void rmem_demod_device_release(struct reserved_mem *rmem,
-				      struct device *dev)
-{
-}
-
-static const struct reserved_mem_ops rmem_demod_ops = {
-	.device_init = rmem_demod_device_init,
-	.device_release = rmem_demod_device_release,
-};
-
-static int __init rmem_demod_setup(struct reserved_mem *rmem)
-{
-	/*
-	 * struct cma *cma;
-	 * int err;
-	 * pr_info("%s setup.\n",__func__);
-	 * err = cma_init_reserved_mem(rmem->base, rmem->size, 0, &cma);
-	 * if (err) {
-	 *      pr_err("Reserved memory: unable to setup CMA region\n");
-	 *      return err;
-	 * }
-	 */
-	rmem->ops = &rmem_demod_ops;
-	/* rmem->priv = cma; */
-
-	pr_info
-	    ("DTV demod reserved memory: %pa, size %ld MiB\n",
-	     &rmem->base, (unsigned long)rmem->size / SZ_1M);
-
-	return 0;
-}
-
-RESERVEDMEM_OF_DECLARE(demod, "amlogic, demod-mem", rmem_demod_setup);
-#endif
-static int aml_fe_dev_init(struct aml_dvb *dvb, struct platform_device *pdev,
-			   enum aml_fe_dev_type_t type, struct aml_fe_dev *dev,
-			   int id)
-{
-#ifndef CONFIG_OF
-	struct resource *res;
-#endif
-	char *name = NULL;
-	char buf[32];
-	int ret;
-	u32 value;
-	const char *str;
-
-	switch (type) {
-	case AM_DEV_TUNER:
-		name = "tuner";
-		break;
-	case AM_DEV_ATV_DEMOD:
-		name = "atv_demod";
-		break;
-	case AM_DEV_DTV_DEMOD:
-		name = "dtv_demod";
-		break;
-	default:
-		break;
-	}
-
-	pr_dbg("init %s %d pdev: %p\n", name, id, pdev);
-
-	snprintf(buf, sizeof(buf), "%s%d", name, id);
-#ifdef CONFIG_OF
-	ret = of_property_read_string(pdev->dev.of_node, buf, &str);
-	if (ret) {
-		pr_error("cannot find resource \"%s\"\n", buf);
-		return 0;
-	} else {
-		struct aml_fe_drv **list = aml_get_fe_drv_list(type);
-		struct aml_fe_drv *drv;
-		unsigned long flags;
-
-		spin_lock_irqsave(&lock, flags);
-
-		for (drv = *list; drv; drv = drv->next)
-			if (!strcmp(drv->name, str))
-				break;
-
-		if (dev->drv != drv) {
-			if (dev->drv) {
-				dev->drv->ref--;
-				if (dev->drv->owner)
-					module_put(dev->drv->owner);
-			}
-			if (drv) {
-				drv->ref++;
-				if (drv->owner)
-					try_module_get(drv->owner);
-			}
-			dev->drv = drv;
-		}
-
-		spin_unlock_irqrestore(&lock, flags);
-
-		if (drv) {
-			pr_inf("found %s%d driver: %s\n", name, id, str);
-		} else {
-			pr_err("cannot find %s%d driver: %s\n", name, id, str);
-			return -1;
-		}
-	}
-
-#else				/*CONFIG_OF */
-	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, buf);
-	if (res) {
-		struct aml_fe_drv **list = aml_get_fe_drv_list(type);
-		struct aml_fe_drv *drv;
-		int type = res->start;
-		unsigned long flags;
-
-		spin_lock_irqsave(&lock, flags);
-
-		for (drv = *list; drv; drv = drv->next) {
-			if (drv->id == type) {
-				drv->ref++;
-				if (drv->owner)
-					try_module_get(drv->owner);
-				break;
-			}
-		}
-
-		spin_unlock_irqrestore(&lock, flags);
-
-		if (drv) {
-			dev->drv = drv;
-		} else {
-			pr_error("cannot find %s%d driver: %d\n", name, id,
-				 type);
-			return -1;
-		}
-	} else {
-		pr_dbg("cannot find resource \"%s\"\n", buf);
-		return 0;
-	}
-#endif				/*CONFIG_OF */
-
-	snprintf(buf, sizeof(buf), "%s%d_i2c_adap_id", name, id);
-#ifdef CONFIG_OF
-	ret = of_property_read_u32(pdev->dev.of_node, buf, &value);
-	if (!ret) {
-		dev->i2c_adap_id = value;
-		dev->i2c_adap = i2c_get_adapter(value);
-		pr_inf("%s: %d[%p]\n", buf, dev->i2c_adap_id, dev->i2c_adap);
-	} else {
-		dev->i2c_adap_id = -1;
-		pr_error("cannot find resource \"%s\"\n", buf);
-	}
-#else				/*CONFIG_OF */
-	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, buf);
-	if (res) {
-		int adap = res->start;
-
-		dev->i2c_adap_id = adap;
-		dev->i2c_adap = i2c_get_adapter(adap);
-	} else {
-		dev->i2c_adap_id = -1;
-		pr_error("cannot find resource \"%s\"\n", buf);
-	}
-#endif				/*CONFIG_OF */
-
-	snprintf(buf, sizeof(buf), "%s%d_i2c_addr", name, id);
-#ifdef CONFIG_OF
-	ret = of_property_read_u32(pdev->dev.of_node, buf, &value);
-	if (!ret) {
-		dev->i2c_addr = value;
-		pr_inf("%s: %d\n", buf, dev->i2c_addr);
-	} else {
-		dev->i2c_addr = -1;
-		pr_error("cannot find resource \"%s\"\n", buf);
-	}
-#else				/*CONFIG_OF */
-	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, buf);
-	if (res) {
-		int addr = res->start;
-
-		dev->i2c_addr = addr;
-		pr_inf("%s: %d\n", buf, dev->i2c_addr);
-	} else {
-		dev->i2c_addr = -1;
-		pr_error("cannot find resource \"%s\"\n", buf);
-	}
-#endif
-
-	snprintf(buf, sizeof(buf), "%s%d_reset_gpio", name, id);
-#ifdef CONFIG_OF
-	ret = of_property_read_string(pdev->dev.of_node, buf, &str);
-	if (!ret) {
-		dev->reset_gpio =
-		    desc_to_gpio(of_get_named_gpiod_flags(pdev->dev.of_node,
-							  buf, 0, NULL));
-		pr_inf("%s: %s\n", buf, str);
-	} else {
-		dev->reset_gpio = -1;
-		pr_error("cannot find resource \"%s\"\n", buf);
-	}
-#else				/*CONFIG_OF */
-	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, buf);
-	if (res) {
-		int gpio = res->start;
-
-		dev->reset_gpio = gpio;
-		pr_inf("%s: %x\n", buf, gpio);
-	} else {
-		dev->reset_gpio = -1;
-		pr_error("cannot find resource \"%s\"\n", buf);
-	}
-#endif				/*CONFIG_OF */
-
-	snprintf(buf, sizeof(buf), "%s%d_reset_value", name, id);
-#ifdef CONFIG_OF
-	ret = of_property_read_u32(pdev->dev.of_node, buf, &value);
-	if (!ret) {
-		dev->reset_value = value;
-		pr_inf("%s: %d\n", buf, dev->reset_value);
-	} else {
-		dev->reset_value = -1;
-	}
-#else				/*CONFIG_OF */
-	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, buf);
-	if (res) {
-		int v = res->start;
-
-		dev->reset_value = v;
-		pr_inf("%s: %d\n", buf, dev->reset_value);
-	} else {
-		dev->reset_value = 0;
-		pr_error("cannot find resource \"%s\"\n", buf);
-	}
-#endif				/*CONFIG_OF */
-
-	snprintf(buf, sizeof(buf), "%s%d_tunerpower", name, id);
-#ifdef CONFIG_OF
-	ret = of_property_read_string(pdev->dev.of_node, buf, &str);
-	if (!ret) {
-		dev->tuner_power_gpio =
-		    desc_to_gpio(of_get_named_gpiod_flags(pdev->dev.of_node,
-							  buf, 0, NULL));
-		pr_inf("%s: %s\n", buf, str);
-	} else {
-		dev->tuner_power_gpio = -1;
-	}
-#else				/*CONFIG_OF */
-	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, buf);
-	if (res) {
-		int gpio = res->start;
-
-		dev->tuner_power_gpio = gpio;
-	} else {
-		dev->tuner_power_gpio = -1;
-	}
-#endif				/*CONFIG_OF */
-
-	snprintf(buf, sizeof(buf), "%s%d_lnbpower", name, id);
-#ifdef CONFIG_OF
-	ret = of_property_read_string(pdev->dev.of_node, buf, &str);
-	if (!ret) {
-		dev->lnb_power_gpio =
-		    desc_to_gpio(of_get_named_gpiod_flags(pdev->dev.of_node,
-							  buf, 0, NULL));
-		pr_inf("%s: %s\n", buf, str);
-	} else {
-		dev->lnb_power_gpio = -1;
-	}
-#else				/*CONFIG_OF */
-	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, buf);
-	if (res) {
-		int gpio = res->start;
-
-		dev->lnb_power_gpio = gpio;
-	} else {
-		dev->lnb_power_gpio = -1;
-	}
-#endif
-
-	snprintf(buf, sizeof(buf), "%s%d_antoverload", name, id);
-#ifdef CONFIG_OF
-	ret = of_property_read_string(pdev->dev.of_node, buf, &str);
-	if (!ret) {
-		dev->antoverload_gpio =
-		    desc_to_gpio(of_get_named_gpiod_flags(pdev->dev.of_node,
-							  buf, 0, NULL));
-		pr_inf("%s: %s\n", buf, str);
-	} else {
-		dev->antoverload_gpio = -1;
-	}
-#else				/*CONFIG_OF */
-	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, buf);
-	if (res) {
-		int gpio = res->start;
-
-		dev->antoverload_gpio = gpio;
-	} else {
-		dev->antoverload_gpio = -1;
-	}
-#endif				/*CONFIG_OF */
-
-	snprintf(buf, sizeof(buf), "%s%d_spectrum", name, id);
-#ifdef CONFIG_OF
-	ret = of_property_read_u32(pdev->dev.of_node, buf, &value);
-	if (!ret) {
-		dev->spectrum = value;
-		pr_inf("%s: %d\n", buf, value);
-	} else {
-		dev->spectrum = 2;
-	}
-#else				/*CONFIG_OF */
-	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, buf);
-	if (res) {
-		int spectrum = res->start;
-
-		dev->spectrum = spectrum;
-	} else {
-		dev->spectrum = 0;
-	}
-#endif
-
-
-#ifdef CONFIG_OF
-	dev->mem_start = memstart;
-#endif
-
-	if (dev->drv->init) {
-		ret = dev->drv->init(dev);
-		if (ret != 0) {
-			dev->drv = NULL;
-			pr_error("[aml_fe..]%s error.\n", __func__);
-			return ret;
-		}
-	}
-
-	return 0;
-}
-
-static int aml_fe_dev_release(struct aml_dvb *dvb, enum aml_fe_dev_type_t type,
-			      struct aml_fe_dev *dev)
-{
-	if (dev->drv) {
-		if (dev->drv->owner)
-			module_put(dev->drv->owner);
-		dev->drv->ref--;
-		if (dev->drv->release)
-			dev->drv->release(dev);
-	}
-
-	dev->drv = NULL;
-	return 0;
-}
-
-static void aml_fe_man_run(struct aml_dvb *dvb, struct aml_fe *fe)
-{
-	int tuner_cap = 0xFFFFFFFF;
-	int demod_cap = 0;
-
-	if (fe->init)
-		return;
-
-	if (fe->tuner && fe->tuner->drv) {
-		tuner_cap = fe->tuner->drv->capability;
-		fe->init = 1;
-	}
-
-	if (fe->atv_demod && fe->atv_demod->drv) {
-		demod_cap |= fe->atv_demod->drv->capability;
-		fe->init = 1;
-	}
-
-	if (fe->dtv_demod && fe->dtv_demod->drv) {
-		demod_cap |= fe->dtv_demod->drv->capability;
-		fe->init = 1;
-	}
-
-	if (fe->init) {
-		int reg = 1;
-		int ret;
-		int id;
-
-		spin_lock_init(&fe->slock);
-		fe->mode = AM_FE_UNKNOWN;
-		fe->capability = (tuner_cap & demod_cap);
-		pr_dbg("fe: %p cap: %x tuner: %x demod: %x\n", fe,
-		       fe->capability, tuner_cap, demod_cap);
-
-		for (id = 0; id < FE_DEV_COUNT; id++) {
-			struct aml_fe *prev_fe = &fe_man.fe[id];
-
-			if (prev_fe == fe)
-				continue;
-			if (prev_fe->init && (prev_fe->dev_id == fe->dev_id)) {
-				reg = 0;
-				break;
-			}
-		}
-		fe->fe = &fe_man.dev[fe->dev_id];
-		if (reg) {
-			fe->fe->demodulator_priv = fe;
-			fe->fe->ops.set_mode = aml_fe_set_mode;
-			fe->fe->ops.read_ts = aml_fe_read_ts;
-
-			ret = dvb_register_frontend(&dvb->dvb_adapter, fe->fe);
-			if (ret) {
-				pr_error("register fe%d failed\n", fe->dev_id);
-				return;
-			}
-		}
-
-		if (fe->tuner)
-			fe->tuner->fe = fe;
-		if (fe->atv_demod)
-			fe->atv_demod->fe = fe;
-		if (fe->dtv_demod)
-			fe->dtv_demod->fe = fe;
-	}
-}
-
-static int aml_fe_man_init(struct aml_dvb *dvb, struct platform_device *pdev,
-			   struct aml_fe *fe, int id)
-{
-#ifndef CONFIG_OF
-	struct resource *res;
-#endif
-	char buf[32];
-	u32 value;
-	int ret;
-
-	snprintf(buf, sizeof(buf), "fe%d_tuner", id);
-
-#ifdef CONFIG_OF
-	ret = of_property_read_u32(pdev->dev.of_node, buf, &value);
-	if (!ret) {
-		int id = value;
-		if ((id < 0) || (id >= FE_DEV_COUNT) || !fe_man.tuner[id].drv) {
-			pr_error("invalid tuner device id %d\n", id);
-			return -1;
-		}
-
-		fe->tuner = &fe_man.tuner[id];
-
-		pr_dbg("%s: %d\n", buf, id);
-	}
-#else				/*CONFIG_OF */
-	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, buf);
-	if (res) {
-		int id = res->start;
-		if ((id < 0) || (id >= FE_DEV_COUNT) || !fe_man.tuner[id].drv) {
-			pr_error("invalid tuner device id %d\n", id);
-			return -1;
-		}
-
-		fe->tuner = &fe_man.tuner[id];
-	}
-#endif				/*CONFIG_OF */
-
-	snprintf(buf, sizeof(buf), "fe%d_atv_demod", id);
-#ifdef CONFIG_OF
-	ret = of_property_read_u32(pdev->dev.of_node, buf, &value);
-	if (!ret) {
-		int id = value;
-		if ((id < 0) || (id >= FE_DEV_COUNT)
-		    || !fe_man.atv_demod[id].drv) {
-			pr_error("invalid ATV demod device id %d\n", id);
-			return -1;
-		}
-
-		fe->atv_demod = &fe_man.atv_demod[id];
-		pr_dbg("%s: %d\n", buf, id);
-	}
-#else				/*CONFIG_OF */
-	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, buf);
-	if (res) {
-		int id = res->start;
-		if ((id < 0) || (id >= FE_DEV_COUNT)
-		    || !fe_man.atv_demod[id].drv) {
-			pr_error("invalid ATV demod device id %d\n", id);
-			return -1;
-		}
-
-		fe->atv_demod = &fe_man.atv_demod[id];
-	}
-#endif				/*CONFIG_OF */
-
-	snprintf(buf, sizeof(buf), "fe%d_dtv_demod", id);
-#ifdef CONFIG_OF
-	ret = of_property_read_u32(pdev->dev.of_node, buf, &value);
-	if (!ret) {
-		int id = value;
-		if ((id < 0) || (id >= FE_DEV_COUNT)
-		    || !fe_man.dtv_demod[id].drv) {
-			pr_error("invalid DTV demod device id %d\n", id);
-			return -1;
-		}
-
-		fe->dtv_demod = &fe_man.dtv_demod[id];
-		pr_dbg("%s: %d\n", buf, id);
-	}
-#else				/*CONFIG_OF */
-	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, buf);
-	if (res) {
-		int id = res->start;
-
-		pr_dbg("[dvb] res->start is %d\n", res->start);
-		if ((id < 0) || (id >= FE_DEV_COUNT)
-		    || !fe_man.dtv_demod[id].drv) {
-			pr_error("invalid DTV demod device id %d\n", id);
-			return -1;
-		}
-
-		fe->dtv_demod = &fe_man.dtv_demod[id];
-	}
-#endif				/*CONFIG_OF */
-
-	snprintf(buf, sizeof(buf), "fe%d_ts", id);
-#ifdef CONFIG_OF
-	ret = of_property_read_u32(pdev->dev.of_node, buf, &value);
-	if (!ret) {
-		int id = value;
-		enum aml_ts_source_t ts = AM_TS_SRC_TS0;
-
-		switch (id) {
-		case 0:
-			ts = AM_TS_SRC_TS0;
-			break;
-		case 1:
-			ts = AM_TS_SRC_TS1;
-			break;
-		case 2:
-			ts = AM_TS_SRC_TS2;
-			break;
-		default:
-			break;
-		}
-
-		fe->ts = ts;
-		pr_dbg("%s: %d\n", buf, id);
-	}
-#else				/*CONFIG_OF */
-	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, buf);
-	if (res) {
-		int id = res->start;
-		enum aml_ts_source_t ts = AM_TS_SRC_TS0;
-
-		switch (id) {
-		case 0:
-			ts = AM_TS_SRC_TS0;
-			break;
-		case 1:
-			ts = AM_TS_SRC_TS1;
-			break;
-		case 2:
-			ts = AM_TS_SRC_TS2;
-			break;
-		default:
-			break;
-		}
-
-		fe->ts = ts;
-	}
-#endif				/*CONFIG_OF */
-
-	snprintf(buf, sizeof(buf), "fe%d_dev", id);
-#ifdef CONFIG_OF
-	ret = of_property_read_u32(pdev->dev.of_node, buf, &value);
-	if (!ret) {
-		int id = value;
-
-		if ((id >= 0) && (id < FE_DEV_COUNT))
-			fe->dev_id = id;
-		else
-			fe->dev_id = 0;
-		pr_dbg("%s: %d\n", buf, fe->dev_id);
-	} else {
-		fe->dev_id = 0;
-		pr_dbg("cannot get resource \"%s\"\n", buf);
-	}
-#else				/*CONFIG_OF */
-	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, buf);
-	if (res) {
-		int id = res->start;
-
-		if ((id >= 0) && (id < FE_DEV_COUNT))
-			fe->dev_id = id;
-		else
-			fe->dev_id = 0;
-		pr_dbg("%s: %d\n", buf, fe->dev_id);
-	} else {
-		fe->dev_id = 0;
-		pr_dbg("cannot get resource \"%s\"\n", buf);
-	}
-#endif				/*CONFIG_OF */
-
-	aml_fe_man_run(dvb, fe);
-
-	return 0;
-}
-
-static int aml_fe_man_release(struct aml_dvb *dvb, struct aml_fe *fe)
-{
-	if (fe->init) {
-		aml_dmx_register_frontend(fe->ts, NULL);
-		dvb_unregister_frontend(fe->fe);
-		dvb_frontend_detach(fe->fe);
-
-		fe->tuner = NULL;
-		fe->atv_demod = NULL;
-		fe->dtv_demod = NULL;
-		fe->init = 0;
-	}
-
-	return 0;
-}
-
-static ssize_t tuner_name_show(struct class *cls, struct class_attribute *attr,
-			       char *buf)
-{
-	size_t len = 0;
-	struct aml_fe_drv *drv;
-	unsigned long flags;
-
-	struct aml_fe_drv **list = aml_get_fe_drv_list(AM_DEV_TUNER);
-
-	spin_lock_irqsave(&lock, flags);
-	for (drv = *list; drv; drv = drv->next)
-		len += sprintf(buf + len, "%s\n", drv->name);
-	spin_unlock_irqrestore(&lock, flags);
-	return len;
-}
-
-static ssize_t atv_demod_name_show(struct class *cls,
-				   struct class_attribute *attr, char *buf)
-{
-	size_t len = 0;
-	struct aml_fe_drv *drv;
-	unsigned long flags;
-
-	struct aml_fe_drv **list = aml_get_fe_drv_list(AM_DEV_ATV_DEMOD);
-
-	spin_lock_irqsave(&lock, flags);
-	for (drv = *list; drv; drv = drv->next)
-		len += sprintf(buf + len, "%s\n", drv->name);
-	spin_unlock_irqrestore(&lock, flags);
-	return len;
-}
-
-static ssize_t dtv_demod_name_show(struct class *cls,
-				   struct class_attribute *attr, char *buf)
-{
-	size_t len = 0;
-	struct aml_fe_drv *drv;
-	unsigned long flags;
-
-	struct aml_fe_drv **list = aml_get_fe_drv_list(AM_DEV_DTV_DEMOD);
-
-	spin_lock_irqsave(&lock, flags);
-	for (drv = *list; drv; drv = drv->next)
-		len += sprintf(buf + len, "%s\n", drv->name);
-	spin_unlock_irqrestore(&lock, flags);
-	return len;
-}
-
-static ssize_t setting_show(struct class *cls, struct class_attribute *attr,
-			    char *buf)
-{
-	int r, total = 0;
-	int i;
-	struct aml_fe_man *fm = &fe_man;
-
-	r = sprintf(buf, "tuner:\n");
-	buf += r;
-	total += r;
-	for (i = 0; i < FE_DEV_COUNT; i++) {
-		struct aml_fe_dev *dev = &fm->tuner[i];
-		if (dev->drv) {
-			r = sprintf(buf,
-				    "\t%d: %s i2s_id: %d i2c_addr: 0x%x reset_gpio: 0x%x reset_level: %d\n",
-				    i, dev->drv->name, dev->i2c_adap_id,
-				    dev->i2c_addr, dev->reset_gpio,
-				    dev->reset_value);
-			buf += r;
-			total += r;
-		}
-	}
-
-	r = sprintf(buf, "atv_demod:\n");
-	buf += r;
-	total += r;
-	for (i = 0; i < FE_DEV_COUNT; i++) {
-		struct aml_fe_dev *dev = &fm->atv_demod[i];
-		if (dev->drv) {
-			r = sprintf(buf,
-				    "\t%d: %s i2s_id: %d i2c_addr: 0x%x reset_gpio: 0x%x reset_level: %d\n",
-				    i, dev->drv->name, dev->i2c_adap_id,
-				    dev->i2c_addr, dev->reset_gpio,
-				    dev->reset_value);
-			buf += r;
-			total += r;
-		}
-	}
-
-	r = sprintf(buf, "dtv_demod:\n");
-	buf += r;
-	total += r;
-	for (i = 0; i < FE_DEV_COUNT; i++) {
-		struct aml_fe_dev *dev = &fm->dtv_demod[i];
-		if (dev->drv) {
-			r = sprintf(buf,
-				    "\t%d: %s i2s_id: %d i2c_addr: 0x%x reset_gpio: 0x%x reset_level: %d\n",
-				    i, dev->drv->name, dev->i2c_adap_id,
-				    dev->i2c_addr, dev->reset_gpio,
-				    dev->reset_value);
-			buf += r;
-			total += r;
-		}
-	}
-
-	r = sprintf(buf, "frontend:\n");
-	buf += r;
-	total += r;
-	for (i = 0; i < FE_DEV_COUNT; i++) {
-		struct aml_fe *fe = &fm->fe[i];
-
-		r = sprintf(buf,
-			    "\t%d: %s device: %d ts: %d tuner: %s atv_demod: %s dtv_demod: %s\n",
-			    i, fe->init ? "enabled" : "disabled", fe->dev_id,
-			    fe->ts, fe->tuner ? fe->tuner->drv->name : "none",
-			    fe->atv_demod ? fe->atv_demod->drv->name : "none",
-			    fe->dtv_demod ? fe->dtv_demod->drv->name : "none");
-		buf += r;
-		total += r;
-	}
-
-	return total;
-}
-
-static void reset_drv(int id, enum aml_fe_dev_type_t type, const char *name)
-{
-	struct aml_fe_man *fm = &fe_man;
-	struct aml_fe_drv **list;
-	struct aml_fe_drv **pdrv;
-	struct aml_fe_drv *drv;
-	struct aml_fe_drv *old;
-
-	if ((id < 0) || (id >= FE_DEV_COUNT))
-		return;
-
-	if (fm->fe[id].init) {
-		pr_error("cannot reset driver when the device is inused\n");
-		return;
-	}
-
-	list = aml_get_fe_drv_list(type);
-	for (drv = *list; drv; drv = drv->next)
-		if (!strcmp(drv->name, name))
-			break;
-
-	switch (type) {
-	case AM_DEV_TUNER:
-		pdrv = &fm->tuner[id].drv;
-		break;
-	case AM_DEV_ATV_DEMOD:
-		pdrv = &fm->atv_demod[id].drv;
-		break;
-	case AM_DEV_DTV_DEMOD:
-		pdrv = &fm->dtv_demod[id].drv;
-		break;
-	default:
-		return;
-	}
-
-	old = *pdrv;
-	if (old == drv)
-		return;
-
-	if (old) {
-		old->ref--;
-		if (old->owner)
-			module_put(old->owner);
-	}
-
-	if (drv) {
-		drv->ref++;
-		if (drv->owner)
-			try_module_get(drv->owner);
-	}
-
-	*pdrv = drv;
-}
-
-static ssize_t setting_store(struct class *class, struct class_attribute *attr,
-			     const char *buf, size_t size)
-{
-	struct aml_dvb *dvb = aml_get_dvb_device();
-	struct aml_fe_man *fm = &fe_man;
-	int id, val;
-	char dev_name[32];
-	char gpio_name[32];
-	unsigned long flags;
-
-	spin_lock_irqsave(&lock, flags);
-
-	if (sscanf(buf, "tuner %i driver %s", &id, dev_name) == 2) {
-		reset_drv(id, AM_DEV_TUNER, dev_name);
-	} else if (sscanf(buf, "tuner %i i2c_id %i", &id, &val) == 2) {
-		if ((id >= 0) && (id < FE_DEV_COUNT)) {
-			fm->tuner[id].i2c_adap_id = val;
-			fm->tuner[id].i2c_adap = i2c_get_adapter(val);
-		}
-	} else if (sscanf(buf, "tuner %i i2c_addr %i", &id, &val) == 2) {
-		if ((id >= 0) && (id < FE_DEV_COUNT))
-			fm->tuner[id].i2c_addr = val;
-#ifdef CONFIG_OF
-	} else if (sscanf(buf, "tuner %i reset_gpio %s", &id, gpio_name) == 2) {
-		val =
-		    desc_to_gpio(of_get_named_gpiod_flags
-				 (dvb->pdev->dev.of_node, gpio_name, 0, NULL));
-#else
-	} else if (sscanf(buf, "tuner %i reset_gpio %i", &id, &val) == 2) {
-#endif
-		if ((id >= 0) && (id < FE_DEV_COUNT))
-			fm->tuner[id].reset_gpio = val;
-	} else if (sscanf(buf, "tuner %i reset_level %i", &id, &val) == 2) {
-		if ((id >= 0) && (id < FE_DEV_COUNT))
-			fm->tuner[id].reset_value = val;
-	} else if (sscanf(buf, "atv_demod %i driver %s", &id, dev_name) == 2) {
-		reset_drv(id, AM_DEV_ATV_DEMOD, dev_name);
-	} else if (sscanf(buf, "atv_demod %i i2c_id %i", &id, &val) == 2) {
-		if ((id >= 0) && (id < FE_DEV_COUNT)) {
-			fm->atv_demod[id].i2c_adap_id = val;
-			fm->dtv_demod[id].i2c_adap = i2c_get_adapter(val);
-		}
-	} else if (sscanf(buf, "atv_demod %i i2c_addr %i", &id, &val) == 2) {
-		if ((id >= 0) && (id < FE_DEV_COUNT))
-			fm->atv_demod[id].i2c_addr = val;
-#ifdef CONFIG_OF
-	} else if (sscanf(buf, "atv_demod %i reset_gpio %s", &id, gpio_name) ==
-		   2) {
-		val =
-		    desc_to_gpio(of_get_named_gpiod_flags
-				 (dvb->pdev->dev.of_node, gpio_name, 0, NULL));
-#else
-	} else if (sscanf(buf, "atv_demod %i reset_gpio %i", &id, &val) == 2) {
-#endif
-		if ((id >= 0) && (id < FE_DEV_COUNT))
-			fm->atv_demod[id].reset_gpio = val;
-	} else if (sscanf(buf, "atv_demod %i reset_level %i", &id, &val) == 2) {
-		if ((id >= 0) && (id < FE_DEV_COUNT))
-			fm->atv_demod[id].reset_value = val;
-	} else if (sscanf(buf, "dtv_demod %i driver %s", &id, dev_name) == 2) {
-		reset_drv(id, AM_DEV_DTV_DEMOD, dev_name);
-	} else if (sscanf(buf, "dtv_demod %i i2c_id %i", &id, &val) == 2) {
-		if ((id >= 0) && (id < FE_DEV_COUNT)) {
-			fm->dtv_demod[id].i2c_adap_id = val;
-			fm->dtv_demod[id].i2c_adap = i2c_get_adapter(val);
-		}
-	} else if (sscanf(buf, "dtv_demod %i i2c_addr %i", &id, &val) == 2) {
-		if ((id >= 0) && (id < FE_DEV_COUNT))
-			fm->dtv_demod[id].i2c_addr = val;
-#ifdef CONFIG_OF
-	} else if (sscanf(buf, "dtv_demod %i reset_gpio %s", &id, gpio_name) ==
-		   2) {
-		val =
-		    desc_to_gpio(of_get_named_gpiod_flags
-				 (dvb->pdev->dev.of_node, gpio_name, 0, NULL));
-#else
-	} else if (sscanf(buf, "dtv_demod %i reset_gpio %i", &id, &val) == 2) {
-#endif
-		if ((id >= 0) && (id < FE_DEV_COUNT))
-			fm->dtv_demod[id].reset_gpio = val;
-	} else if (sscanf(buf, "dtv_demod %i reset_level %i", &id, &val) == 2) {
-		if ((id >= 0) && (id < FE_DEV_COUNT))
-			fm->dtv_demod[id].reset_value = val;
-	} else if (sscanf(buf, "frontend %i device %i", &id, &val) == 2) {
-		if ((id >= 0) && (id < FE_DEV_COUNT))
-			fm->fe[id].dev_id = val;
-	} else if (sscanf(buf, "frontend %i ts %i", &id, &val) == 2) {
-		if ((id >= 0) && (id < FE_DEV_COUNT))
-			fm->fe[id].ts = val;
-	} else if (sscanf(buf, "frontend %i tuner %i", &id, &val) == 2) {
-		if ((id >= 0) && (id < FE_DEV_COUNT) && (val >= 0)
-		    && (val < FE_DEV_COUNT) && fm->tuner[val].drv)
-			fm->fe[id].tuner = &fm->tuner[val];
-	} else if (sscanf(buf, "frontend %i atv_demod %i", &id, &val) == 2) {
-		if ((id >= 0) && (id < FE_DEV_COUNT) && (val >= 0)
-		    && (val < FE_DEV_COUNT) && fm->atv_demod[val].drv)
-			fm->fe[id].atv_demod = &fm->atv_demod[val];
-	} else if (sscanf(buf, "frontend %i dtv_demod %i", &id, &val) == 2) {
-		if ((id >= 0) && (id < FE_DEV_COUNT) && (val >= 0)
-		    && (val < FE_DEV_COUNT) && fm->dtv_demod[val].drv)
-			fm->fe[id].dtv_demod = &fm->dtv_demod[val];
-	}
-
-	spin_unlock_irqrestore(&lock, flags);
-
-	if (sscanf(buf, "enable %i", &id) == 1) {
-		if ((id >= 0) && (id < FE_DEV_COUNT))
-			aml_fe_man_run(dvb, &fm->fe[id]);
-	} else if (sscanf(buf, "disable %i", &id) == 1) {
-		if ((id >= 0) && (id < FE_DEV_COUNT))
-			aml_fe_man_release(dvb, &fm->fe[id]);
-	} else if (strstr(buf, "autoload")) {
-		for (id = 0; id < FE_DEV_COUNT; id++) {
-			aml_fe_dev_init(dvb, fm->pdev, AM_DEV_TUNER,
-					&fm->tuner[id], id);
-			aml_fe_dev_init(dvb, fm->pdev, AM_DEV_ATV_DEMOD,
-					&fm->atv_demod[id], id);
-			aml_fe_dev_init(dvb, fm->pdev, AM_DEV_DTV_DEMOD,
-					&fm->dtv_demod[id], id);
-		}
-
-		for (id = 0; id < FE_DEV_COUNT; id++)
-			aml_fe_man_init(dvb, fm->pdev, &fm->fe[id], id);
-	} else if (strstr(buf, "disableall")) {
-		for (id = 0; id < FE_DEV_COUNT; id++)
-			aml_fe_man_release(dvb, &fm->fe[id]);
-
-		for (id = 0; id < FE_DEV_COUNT; id++) {
-			aml_fe_dev_release(dvb, AM_DEV_DTV_DEMOD,
-					   &fm->dtv_demod[id]);
-			aml_fe_dev_release(dvb, AM_DEV_ATV_DEMOD,
-					   &fm->atv_demod[id]);
-			aml_fe_dev_release(dvb, AM_DEV_TUNER, &fm->tuner[id]);
-		}
-	}
-
-	return size;
-}
-
-static ssize_t aml_fe_show_suspended_flag(struct class *class,
-					  struct class_attribute *attr,
-					  char *buf)
-{
-	ssize_t ret = 0;
-
-	ret = sprintf(buf, "%ld\n", aml_fe_suspended);
-
-	return ret;
-}
-
-static ssize_t aml_fe_store_suspended_flag(struct class *class,
-					   struct class_attribute *attr,
-					   const char *buf, size_t size)
-{
-	/*aml_fe_suspended = simple_strtol(buf, 0, 0); */
-	int ret = kstrtol(buf, 0, &aml_fe_suspended);
-
-	if (ret)
-		return ret;
-	return size;
-}
-
-static struct class_attribute aml_fe_cls_attrs[] = {
-	__ATTR(tuner_name,
-	       S_IRUGO | S_IWUSR,
-	       tuner_name_show, NULL),
-	__ATTR(atv_demod_name,
-	       S_IRUGO | S_IWUSR,
-	       atv_demod_name_show, NULL),
-	__ATTR(dtv_demod_name,
-	       S_IRUGO | S_IWUSR,
-	       dtv_demod_name_show, NULL),
-	__ATTR(setting,
-	       S_IRUGO | S_IWUSR,
-	       setting_show, setting_store),
-	__ATTR(aml_fe_suspended_flag,
-	       S_IRUGO | S_IWUSR,
-	       aml_fe_show_suspended_flag,
-	       aml_fe_store_suspended_flag),
-	__ATTR_NULL
-};
-
-static struct class aml_fe_class = {
-	.name = "amlfe",
-	.class_attrs = aml_fe_cls_attrs,
-};
-
-static int aml_fe_probe(struct platform_device *pdev)
-{
-	struct aml_dvb *dvb = aml_get_dvb_device();
-	int i;
-
-	of_reserved_mem_device_init(&pdev->dev);
-	for (i = 0; i < FE_DEV_COUNT; i++) {
-		if (aml_fe_dev_init
-		    (dvb, pdev, AM_DEV_TUNER, &fe_man.tuner[i], i) < 0)
-			goto probe_end;
-		if (aml_fe_dev_init
-		    (dvb, pdev, AM_DEV_ATV_DEMOD, &fe_man.atv_demod[i], i) < 0)
-			goto probe_end;
-		if (aml_fe_dev_init
-		    (dvb, pdev, AM_DEV_DTV_DEMOD, &fe_man.dtv_demod[i], i) < 0)
-			goto probe_end;
-	}
-
-	for (i = 0; i < FE_DEV_COUNT; i++)
-		if (aml_fe_man_init(dvb, pdev, &fe_man.fe[i], i) < 0)
-			goto probe_end;
-
- probe_end:
-
-	if (get_cpu_type() >= MESON_CPU_MAJOR_ID_MG9TV)
-		INIT_WORK(&dvb->aml_fe_wq,
-			(void (*)(struct work_struct *))aml_fe_do_work);
-
-
-#ifdef CONFIG_OF
-	fe_man.pinctrl = devm_pinctrl_get_select_default(&pdev->dev);
-#endif
-
-	platform_set_drvdata(pdev, &fe_man);
-
-	if (class_register(&aml_fe_class) < 0)
-		pr_error("[aml_fe..] register class error\n");
-
-	fe_man.pdev = pdev;
-
-	pr_dbg("[aml_fe..] probe ok.\n");
-
-	return 0;
-}
-
-static int aml_fe_remove(struct platform_device *pdev)
-{
-	struct aml_fe_man *fe_man = platform_get_drvdata(pdev);
-	struct aml_dvb *dvb = aml_get_dvb_device();
-	int i;
-
-	if (fe_man) {
-		platform_set_drvdata(pdev, NULL);
-		for (i = 0; i < FE_DEV_COUNT; i++)
-			aml_fe_man_release(dvb, &fe_man->fe[i]);
-		for (i = 0; i < FE_DEV_COUNT; i++) {
-			aml_fe_dev_release(dvb, AM_DEV_DTV_DEMOD,
-					   &fe_man->dtv_demod[i]);
-			aml_fe_dev_release(dvb, AM_DEV_ATV_DEMOD,
-					   &fe_man->atv_demod[i]);
-			aml_fe_dev_release(dvb, AM_DEV_TUNER,
-					   &fe_man->tuner[i]);
-		}
-
-		if (fe_man->pinctrl)
-			devm_pinctrl_put(fe_man->pinctrl);
-	}
-
-	if (get_cpu_type() >= MESON_CPU_MAJOR_ID_MG9TV)
-		cancel_work_sync(&dvb->aml_fe_wq);
-
-	class_unregister(&aml_fe_class);
-
-	return 0;
-}
-
-static int aml_fe_suspend(struct platform_device *dev, pm_message_t state)
-{
-	int i;
-
-	for (i = 0; i < FE_DEV_COUNT; i++) {
-		struct aml_fe *fe = &fe_man.fe[i];
-
-		if (fe->tuner && fe->tuner->drv && fe->tuner->drv->suspend)
-			fe->tuner->drv->suspend(fe->tuner);
-
-		if (fe->atv_demod && fe->atv_demod->drv
-		    && fe->atv_demod->drv->suspend)
-			fe->atv_demod->drv->suspend(fe->atv_demod);
-
-		if (fe->dtv_demod && fe->dtv_demod->drv
-		    && fe->dtv_demod->drv->suspend)
-			fe->dtv_demod->drv->suspend(fe->dtv_demod);
-	}
-
-	aml_fe_suspended = 1;
-
-	return 0;
-}
-
-static int aml_fe_resume(struct platform_device *dev)
-{
-	int i;
-
-	for (i = 0; i < FE_DEV_COUNT; i++) {
-		struct aml_fe *fe = &fe_man.fe[i];
-
-		if (fe->tuner && fe->tuner->drv && fe->tuner->drv->resume)
-			fe->tuner->drv->resume(fe->tuner);
-		if (fe->atv_demod && fe->atv_demod->drv
-		    && fe->atv_demod->drv->resume)
-			fe->atv_demod->drv->resume(fe->atv_demod);
-
-		if (fe->dtv_demod && fe->dtv_demod->drv
-		    && fe->dtv_demod->drv->resume)
-			fe->dtv_demod->drv->resume(fe->dtv_demod);
-	}
-
-	return 0;
-}
-
-#ifdef CONFIG_OF
-static const struct of_device_id aml_fe_dt_match[] = {
-	{
-	 .compatible = "amlogic, dvbfe",
-	 },
-	{},
-};
-#endif				/*CONFIG_OF */
-
-static struct platform_driver aml_fe_driver = {
-	.probe = aml_fe_probe,
-	.remove = aml_fe_remove,
-	.suspend = aml_fe_suspend,
-	.resume = aml_fe_resume,
-	.driver = {
-		   .name = "amlogic-dvb-fe",
-		   .owner = THIS_MODULE,
-#ifdef CONFIG_OF
-		   .of_match_table = aml_fe_dt_match,
-#endif
-		   }
-};
-
-const char *audmode_to_str(unsigned short audmode)
-{
-	/*  switch(audmode)
-	 * {
-	 * case V4L2_TUNER_AUDMODE_NULL:
-	 * return "V4L2_TUNER_AUDMODE_NULL";
-	 * break;
-	 * case V4L2_TUNER_MODE_MONO:
-	 * return "V4L2_TUNER_MODE_MONO";
-	 * break;
-	 * case V4L2_TUNER_MODE_STEREO:
-	 * return "V4L2_TUNER_MODE_STEREO";
-	 * break;
-	 * case V4L2_TUNER_MODE_LANG2:
-	 * return "V4L2_TUNER_MODE_LANG2";
-	 * break;
-	 * case V4L2_TUNER_MODE_SAP:
-	 * return "V4L2_TUNER_MODE_SAP";
-	 * break;
-	 * case V4L2_TUNER_SUB_LANG1:
-	 * return "V4L2_TUNER_SUB_LANG1";
-	 * break;
-	 * case V4L2_TUNER_MODE_LANG1_LANG2:
-	 * return "V4L2_TUNER_MODE_LANG1_LANG2";
-	 * break;
-	 * default:
-	 * return "NO AUDMODE";
-	 * break;
-	 * } */
-	return 0;
-}
-EXPORT_SYMBOL(audmode_to_str);
-
-const char *soundsys_to_str(unsigned short sys)
-{
-	/*switch(sys){
-	 * case V4L2_TUNER_SYS_NULL:
-	 * return "V4L2_TUNER_SYS_NULL";
-	 * break;
-	 * case V4L2_TUNER_SYS_A2_BG:
-	 * return "V4L2_TUNER_SYS_A2_BG";
-	 * break;
-	 * case V4L2_TUNER_SYS_A2_DK1:
-	 * return "V4L2_TUNER_SYS_A2_DK1";
-	 * break;
-	 * case V4L2_TUNER_SYS_A2_DK2:
-	 * return "V4L2_TUNER_SYS_A2_DK2";
-	 * break;
-	 * case V4L2_TUNER_SYS_A2_DK3:
-	 * return "V4L2_TUNER_SYS_A2_DK3";
-	 * break;
-	 * case V4L2_TUNER_SYS_A2_M:
-	 * return "V4L2_TUNER_SYS_A2_M";
-	 * break;
-	 * case V4L2_TUNER_SYS_NICAM_BG:
-	 * return "V4L2_TUNER_SYS_NICAM_BG";
-	 * break;
-	 * case V4L2_TUNER_SYS_NICAM_I:
-	 * return "V4L2_TUNER_SYS_NICAM_I";
-	 * break;
-	 * case V4L2_TUNER_SYS_NICAM_DK:
-	 * return "V4L2_TUNER_SYS_NICAM_DK";
-	 * break;
-	 * case V4L2_TUNER_SYS_NICAM_L:
-	 * return "V4L2_TUNER_SYS_NICAM_L";
-	 * break;
-	 * case V4L2_TUNER_SYS_EIAJ:
-	 * return "V4L2_TUNER_SYS_EIAJ";
-	 * break;
-	 * case V4L2_TUNER_SYS_BTSC:
-	 * return "V4L2_TUNER_SYS_BTSC";
-	 * break;
-	 * case V4L2_TUNER_SYS_FM_RADIO:
-	 * return "V4L2_TUNER_SYS_FM_RADIO";
-	 * break;
-	 * default:
-	 * return "NO SOUND SYS";
-	 * break;
-	 * } */
-	return 0;
-}
-EXPORT_SYMBOL(soundsys_to_str);
-
-const char *v4l2_std_to_str(v4l2_std_id std)
-{
-	switch (std) {
-	case V4L2_STD_PAL_B:
-		return "V4L2_STD_PAL_B";
-		break;
-	case V4L2_STD_PAL_B1:
-		return "V4L2_STD_PAL_B1";
-		break;
-	case V4L2_STD_PAL_G:
-		return "V4L2_STD_PAL_G";
-		break;
-	case V4L2_STD_PAL_H:
-		return "V4L2_STD_PAL_H";
-		break;
-	case V4L2_STD_PAL_I:
-		return "V4L2_STD_PAL_I";
-		break;
-	case V4L2_STD_PAL_D:
-		return "V4L2_STD_PAL_D";
-		break;
-	case V4L2_STD_PAL_D1:
-		return "V4L2_STD_PAL_D1";
-		break;
-	case V4L2_STD_PAL_K:
-		return "V4L2_STD_PAL_K";
-		break;
-	case V4L2_STD_PAL_M:
-		return "V4L2_STD_PAL_M";
-		break;
-	case V4L2_STD_PAL_N:
-		return "V4L2_STD_PAL_N";
-		break;
-	case V4L2_STD_PAL_Nc:
-		return "V4L2_STD_PAL_Nc";
-		break;
-	case V4L2_STD_PAL_60:
-		return "V4L2_STD_PAL_60";
-		break;
-	case V4L2_STD_NTSC_M:
-		return "V4L2_STD_NTSC_M";
-		break;
-	case V4L2_STD_NTSC_M_JP:
-		return "V4L2_STD_NTSC_M_JP";
-		break;
-	case V4L2_STD_NTSC_443:
-		return "V4L2_STD_NTSC_443";
-		break;
-	case V4L2_STD_NTSC_M_KR:
-		return "V4L2_STD_NTSC_M_KR";
-		break;
-	case V4L2_STD_SECAM_B:
-		return "V4L2_STD_SECAM_B";
-		break;
-	case V4L2_STD_SECAM_D:
-		return "V4L2_STD_SECAM_D";
-		break;
-	case V4L2_STD_SECAM_G:
-		return "V4L2_STD_SECAM_G";
-		break;
-	case V4L2_STD_SECAM_H:
-		return "V4L2_STD_SECAM_H";
-		break;
-	case V4L2_STD_SECAM_K:
-		return "V4L2_STD_SECAM_K";
-		break;
-	case V4L2_STD_SECAM_K1:
-		return "V4L2_STD_SECAM_K1";
-		break;
-	case V4L2_STD_SECAM_L:
-		return "V4L2_STD_SECAM_L";
-		break;
-	case V4L2_STD_SECAM_LC:
-		return "V4L2_STD_SECAM_LC";
-		break;
-	case V4L2_STD_ATSC_8_VSB:
-		return "V4L2_STD_ATSC_8_VSB";
-		break;
-	case V4L2_STD_ATSC_16_VSB:
-		return "V4L2_STD_ATSC_16_VSB";
-		break;
-	case V4L2_COLOR_STD_PAL:
-		return "V4L2_COLOR_STD_PAL";
-		break;
-	case V4L2_COLOR_STD_NTSC:
-		return "V4L2_COLOR_STD_NTSC";
-		break;
-	case V4L2_COLOR_STD_SECAM:
-		return "V4L2_COLOR_STD_SECAM";
-		break;
-	case V4L2_STD_MN:
-		return "V4L2_STD_MN";
-		break;
-	case V4L2_STD_B:
-		return "V4L2_STD_B";
-		break;
-	case V4L2_STD_GH:
-		return "V4L2_STD_GH";
-		break;
-	case V4L2_STD_DK:
-		return "V4L2_STD_DK";
-		break;
-	case V4L2_STD_PAL_BG:
-		return "V4L2_STD_PAL_BG";
-		break;
-	case V4L2_STD_PAL_DK:
-		return "V4L2_STD_PAL_DK";
-		break;
-	case V4L2_STD_PAL:
-		return "V4L2_STD_PAL";
-		break;
-	case V4L2_STD_NTSC:
-		return "V4L2_STD_NTSC";
-		break;
-	case V4L2_STD_SECAM_DK:
-		return "V4L2_STD_SECAM_DK";
-		break;
-	case V4L2_STD_SECAM:
-		return "V4L2_STD_SECAM";
-		break;
-	case V4L2_STD_525_60:
-		return "V4L2_STD_525_60";
-		break;
-	case V4L2_STD_625_50:
-		return "V4L2_STD_625_50";
-		break;
-	case V4L2_STD_ATSC:
-		return "V4L2_STD_ATSC";
-		break;
-	case V4L2_STD_ALL:
-		return "V4L2_STD_ALL";
-		break;
-	default:
-		return "V4L2_STD_UNKNOWN";
-		break;
-	}
-}
-EXPORT_SYMBOL(v4l2_std_to_str);
-
-const char *fe_type_to_str(fe_type_t type)
-{
-	switch (type) {
-	case FE_QPSK:
-		return "FE_QPSK";
-		break;
-	case FE_QAM:
-		return "FE_QAM";
-		break;
-	case FE_OFDM:
-		return "FE_OFDM";
-		break;
-	case FE_ATSC:
-		return "FE_ATSC";
-		break;
-	case FE_ANALOG:
-		return "FE_ANALOG";
-		break;
-	case FE_ISDBT:
-		return "FE_ISDBT";
-		break;
-	case FE_DTMB:
-		return "FE_DTMB";
-		break;
-	default:
-		return "UNKONW TYPE";
-		break;
-	}
-}
-EXPORT_SYMBOL(fe_type_to_str);
-
-static int __init aml_fe_init(void)
-{
-	return platform_driver_register(&aml_fe_driver);
-}
-
-static void __exit aml_fe_exit(void)
-{
-	platform_driver_unregister(&aml_fe_driver);
-}
-
-module_init(aml_fe_init);
-module_exit(aml_fe_exit);
-
-MODULE_DESCRIPTION("amlogic frontend driver");
-MODULE_AUTHOR("L+#= +0=1");
diff --git a/drivers/amlogic/dvb_tv/aml_fe.h b/drivers/amlogic/dvb_tv/aml_fe.h
deleted file mode 100644
index 62a06cd8aedc..000000000000
--- a/drivers/amlogic/dvb_tv/aml_fe.h
+++ /dev/null
@@ -1,206 +0,0 @@
-#ifndef _AML_FE_H_
-#define _AML_FE_H_
-
-
-#include <linux/interrupt.h>
-#include <linux/socket.h>
-#include <linux/netdevice.h>
-#include <linux/i2c.h>
-
-#include <linux/dvb/video.h>
-#include <linux/dvb/audio.h>
-#include <linux/dvb/dmx.h>
-#include <linux/dvb/ca.h>
-#include <linux/dvb/osd.h>
-#include <linux/dvb/net.h>
-#include <linux/mutex.h>
-#include <linux/spinlock.h>
-#include <linux/interrupt.h>
-
-#ifdef CONFIG_HAS_EARLYSUSPEND
-#include <linux/earlysuspend.h>
-#endif
-
-#include "drivers/media/dvb-core/dvbdev.h"
-#include "drivers/media/dvb-core/demux.h"
-#include "drivers/media/dvb-core/dvb_demux.h"
-#include "drivers/media/dvb-core/dmxdev.h"
-#include "drivers/media/dvb-core/dvb_filter.h"
-#include "drivers/media/dvb-core/dvb_net.h"
-#include "drivers/media/dvb-core/dvb_ringbuffer.h"
-#include "drivers/media/dvb-core/dvb_frontend.h"
-#include "aml_dvb.h"
-#include "linux/videodev2.h"
-
-#include <linux/amlogic/aml_gpio_consumer.h>
-
-#include <linux/of.h>
-#include <linux/of_fdt.h>
-#include <linux/pinctrl/consumer.h>
-#include <linux/amlogic/cpu_version.h>
-#include <linux/of_reserved_mem.h>
-
-enum aml_fe_mode_t {
-	AM_FE_UNKNOWN = 0,
-	AM_FE_QPSK = 1,
-	AM_FE_QAM = 2,
-	AM_FE_OFDM = 4,
-	AM_FE_ATSC = 8,
-	AM_FE_ANALOG = 16,
-	AM_FE_DTMB = 32,
-	AM_FE_ISDBT = 64
-};
-
-#define AM_FE_DTV_MASK (AM_FE_QPSK | AM_FE_QAM | AM_FE_OFDM | \
-			AM_FE_ATSC | AM_FE_DTMB | AM_FE_ISDBT)
-
-enum aml_tuner_type_t {
-	AM_TUNER_SI2176 = 1,
-	AM_TUNER_SI2196 = 2,
-	AM_TUNER_FQ1216 = 3,
-	AM_TUNER_HTM = 4,
-	AM_TUNER_CTC703 = 5,
-	AM_TUNER_SI2177 = 6,
-	AM_TUNER_R840 = 7,
-	AM_TUNER_SI2157 = 8,
-	AM_TUNER_SI2151 = 9,
-	AM_TUNER_MXL661 = 10
-};
-
-enum aml_atv_demod_type_t {
-	AM_ATV_DEMOD_SI2176 = 1,
-	AM_ATV_DEMOD_SI2196 = 2,
-	AM_ATV_DEMOD_FQ1216 = 3,
-	AM_ATV_DEMOD_HTM = 4,
-	AM_ATV_DEMOD_CTC703 = 5,
-	AM_ATV_DEMOD_SI2177 = 6,
-	AM_ATV_DEMOD_AML = 7,
-	AM_ATV_DEMOD_R840 = 8
-};
-
-enum aml_dtv_demod_type_t {
-	AM_DTV_DEMOD_M1 = 0,
-	AM_DTV_DEMOD_SI2176 = 1,
-	AM_DTV_DEMOD_MXL101 = 2,
-	AM_DTV_DEMOD_SI2196 = 3,
-	AM_DTV_DEMOD_AVL6211 = 4,
-	AM_DTV_DEMOD_SI2168 = 5,
-	AM_DTV_DEMOD_ITE9133 = 6,
-	AM_DTV_DEMOD_ITE9173 = 7,
-	AM_DTV_DEMOD_DIB8096 = 8,
-	AM_DTV_DEMOD_ATBM8869 = 9,
-	AM_DTV_DEMOD_MXL241 = 10,
-	AM_DTV_DEMOD_AVL68xx = 11,
-	AM_DTV_DEMOD_MXL683 = 12
-};
-
-enum aml_fe_dev_type_t {
-	AM_DEV_TUNER,
-	AM_DEV_ATV_DEMOD,
-	AM_DEV_DTV_DEMOD
-};
-
-struct aml_fe_dev;
-struct aml_fe;
-struct aml_fe_drv {
-	struct module *owner;
-	struct aml_fe_drv *next;
-	enum aml_tuner_type_t	id;
-	char *name;
-	int			capability;
-	int (*init)(struct aml_fe_dev *dev);
-	int (*release)(struct aml_fe_dev *dev);
-	int (*resume)(struct aml_fe_dev *dev);
-	int (*suspend)(struct aml_fe_dev *dev);
-	int (*get_ops)(struct aml_fe_dev *dev, int mode,
-					   void *ops);
-	int (*enter_mode)(struct aml_fe *fe, int mode);
-	int (*leave_mode)(struct aml_fe *fe, int mode);
-	int			ref;
-};
-
-struct aml_fe_dev {
-	/*point to parent aml_fe */
-	struct aml_fe *fe;
-	int			i2c_adap_id;
-	int			i2c_addr;
-	struct i2c_adapter *i2c_adap;
-	int			reset_gpio;
-	int			reset_value;
-	struct aml_fe_drv *drv;
-	wait_queue_head_t	lock_wq;
-	void *priv_data;
-
-	/*for tuner power control */
-	int			tuner_power_gpio;
-	/*for dtv dvbsx lnb power control */
-	int			lnb_power_gpio;
-	/*for ant overload control, */
-	/*it possible in dtv dvbsx and depond on fe hw */
-	int			antoverload_gpio;
-
-	/*for mem reserved*/
-	int			mem_start;
-	int			mem_end;
-
-	/*for dtv spectrum*/
-	int			spectrum;
-};
-struct aml_demod_param {
-	/*for tuner video if to amlatvdemod*/
-	unsigned int	if_freq;  /*HZ*/
-	/*for tuner output*/
-	unsigned int	if_inv;
-};
-
-struct aml_fe {
-	struct dvb_frontend *fe;
-#ifdef CONFIG_HAS_EARLYSUSPEND
-	struct early_suspend		es;
-#endif                          /*CONFIG_HAS_EARLYSUSPEND */
-	spinlock_t			slock;
-	int				init;
-	int				mode;
-	int				dev_id;
-	int				capability;
-	enum aml_ts_source_t		ts;
-	struct aml_demod_param		demod_param;
-	struct aml_fe_dev *tuner;
-	struct aml_fe_dev *atv_demod;
-	struct aml_fe_dev *dtv_demod;
-	/*struct dvb_frontend_parameters params;*/
-	struct dtv_frontend_properties	params;
-};
-
-struct aml_fe_man {
-	struct aml_fe		fe[FE_DEV_COUNT];
-	struct aml_fe_dev	tuner[FE_DEV_COUNT];
-	struct aml_fe_dev	atv_demod[FE_DEV_COUNT];
-	struct aml_fe_dev	dtv_demod[FE_DEV_COUNT];
-	struct dvb_frontend	dev[FE_DEV_COUNT];
-	struct pinctrl *pinctrl;
-	struct platform_device *pdev;
-};
-
-extern int aml_register_fe_drv(enum aml_fe_dev_type_t	type,
-			       struct aml_fe_drv *drv);
-extern int aml_unregister_fe_drv(enum aml_fe_dev_type_t type,
-				 struct aml_fe_drv *drv);
-
-extern struct dvb_frontend *get_si2177_tuner(void);
-extern const char *soundsys_to_str(unsigned short soundsys);
-extern const char *audmode_to_str(unsigned short soundsys);
-extern const char *v4l2_std_to_str(v4l2_std_id std);
-extern const char *fe_type_to_str(enum fe_type type);
-
-extern int amlogic_gpio_name_map_num(const char *name);
-extern int amlogic_gpio_direction_output(unsigned int pin, int value,
-					 const char *owner);
-extern int amlogic_gpio_request(unsigned int pin, const char *label);
-
-/* vdac ctrl,adc/dac ref signal,cvbs out signal
- * module index: atv demod:0x01; dtv demod:0x02; tvafe:0x4; dac:0x8
-*/
-extern void vdac_enable(bool on, unsigned int module_sel);
-extern void set_aft_thread_enable(int enable);
-#endif /*_AML_FE_H_*/
diff --git a/drivers/amlogic/dvb_tv/amlatvdemod/Makefile b/drivers/amlogic/dvb_tv/amlatvdemod/Makefile
deleted file mode 100644
index 8a773c951705..000000000000
--- a/drivers/amlogic/dvb_tv/amlatvdemod/Makefile
+++ /dev/null
@@ -1,7 +0,0 @@
-obj-$(CONFIG_AM_ATVDEMOD) += atvdemod_fe.o
-
-atvdemod_fe-objs =atvdemod_func.o atvdemod_frontend.o
-
-ccflags-y += -I.
-ccflags-y += -Idrivers/media/dvb-core
-
diff --git a/drivers/amlogic/dvb_tv/amlatvdemod/atvdemod_frontend.c b/drivers/amlogic/dvb_tv/amlatvdemod/atvdemod_frontend.c
deleted file mode 100644
index dd06e240e660..000000000000
--- a/drivers/amlogic/dvb_tv/amlatvdemod/atvdemod_frontend.c
+++ /dev/null
@@ -1,760 +0,0 @@
-/*
- * Silicon labs atvdemod Device Driver
- *
- * Author: dezhi.kong <dezhi.kong@amlogic.com>
- *
- *
- * Copyright (C) 2014 Amlogic Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
-
-/* Standard Liniux Headers */
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/i2c.h>
-#include <linux/delay.h>
-#include <linux/slab.h>
-#include <linux/err.h>
-#include <linux/delay.h>
-#include <linux/jiffies.h>
-#include <linux/platform_device.h>
-#include <linux/io.h>
-
-/* Amlogic Headers */
-
-/* Local Headers */
-#include "atvdemod_func.h"
-#include "../aml_fe.h"
-#include <uapi/linux/dvb/frontend.h>
-#include <linux/amlogic/tvin/tvin.h>
-
-#define ATVDEMOD_DEVICE_NAME                "amlatvdemod"
-#define ATVDEMOD_DRIVER_NAME	"amlatvdemod"
-#define ATVDEMOD_MODULE_NAME	"amlatvdemod"
-#define ATVDEMOD_CLASS_NAME	"amlatvdemod"
-
-struct amlatvdemod_device_s *amlatvdemod_devp;
-#define AMLATVDEMOD_VER "Ref.2015/09/01a"
-
-static int afc_wave_cnt;
-static int last_frq, last_std;
-
-unsigned int reg_23cf = 0x88188832; /*IIR filter*/
-module_param(reg_23cf, uint, 0664);
-MODULE_PARM_DESC(reg_23cf, "\n reg_23cf\n");
-
-unsigned int atvdemod_scan_mode = 0; /*IIR filter*/
-module_param(atvdemod_scan_mode, uint, 0664);
-MODULE_PARM_DESC(atvdemod_scan_mode, "\n atvdemod_scan_mode\n");
-
-int is_atvdemod_scan_mode(void)
-{
-	return atvdemod_scan_mode;
-}
-EXPORT_SYMBOL(is_atvdemod_scan_mode);
-
-static int aml_atvdemod_enter_mode(struct aml_fe *fe, int mode);
-/*static void sound_store(const char *buff, v4l2_std_id *std);*/
-static ssize_t aml_atvdemod_store(struct class *cls,
-				  struct class_attribute *attr, const char *buf,
-				  size_t count)
-{
-	int n = 0;
-	unsigned int ret = 0;
-	char *buf_orig, *ps, *token;
-	char *parm[4];
-	unsigned int data_snr[128];
-	unsigned int data_snr_avg;
-	int data_afc, block_addr, block_reg, block_val = 0;
-	int i, val = 0;
-	unsigned long tmp = 0;
-	struct aml_fe *atvdemod_fe = NULL;
-	buf_orig = kstrdup(buf, GFP_KERNEL);
-	ps = buf_orig;
-	block_addr = 0;
-	block_reg = 0;
-	while (1) {
-		token = strsep(&ps, "\n");
-		if (token == NULL)
-			break;
-		if (*token == '\0')
-			continue;
-		parm[n++] = token;
-	}
-	if (!strncmp(parm[0], "init", strlen("init"))) {
-		ret = aml_atvdemod_enter_mode(atvdemod_fe, 0);
-		if (ret)
-			pr_info("[tuner..] atv_restart error.\n");
-	} else if (!strcmp(parm[0], "tune")) {
-		/* val  = simple_strtol(parm[1], NULL, 10);*/
-	} else if (!strcmp(parm[0], "set")) {
-		if (!strncmp(parm[1], "avout_gain", strlen("avout_gain"))) {
-			if (kstrtoul(buf+strlen("avout_offset")+1, 10,
-				&tmp) == 0)
-				val  = tmp;
-			atv_dmd_wr_byte(0x0c, 0x01, val&0xff);
-		} else if (!strncmp(parm[1], "avout_offset",
-			strlen("avout_offset"))) {
-			if (kstrtoul(buf+strlen("avout_offset")+1, 10,
-				&tmp) == 0)
-				val  = tmp;
-			atv_dmd_wr_byte(0x0c, 0x04, val&0xff);
-		} else if (!strncmp(parm[1], "atv_gain", strlen("atv_gain"))) {
-			if (kstrtoul(buf+strlen("atv_gain")+1, 10, &tmp) == 0)
-				val  = tmp;
-			atv_dmd_wr_byte(0x19, 0x01, val&0xff);
-		} else if (!strncmp(parm[1], "atv_offset",
-			strlen("atv_offset"))) {
-			if (kstrtoul(buf+strlen("atv_offset")+1, 10,
-				&tmp) == 0)
-				val  = tmp;
-			atv_dmd_wr_byte(0x19, 0x04, val&0xff);
-		}
-	} else if (!strcmp(parm[0], "get")) {
-		if (!strncmp(parm[1], "avout_gain", strlen("avout_gain"))) {
-			val = atv_dmd_rd_byte(0x0c, 0x01);
-			pr_dbg("avout_gain:0x%x\n", val);
-		} else if (!strncmp(parm[1], "avout_offset",
-			strlen("avout_offset"))) {
-			val = atv_dmd_rd_byte(0x0c, 0x04);
-			pr_dbg("avout_offset:0x%x\n", val);
-		} else if (!strncmp(parm[1], "atv_gain", strlen("atv_gain"))) {
-			val = atv_dmd_rd_byte(0x19, 0x01);
-			pr_dbg("atv_gain:0x%x\n", val);
-		} else if (!strncmp(parm[1], "atv_offset",
-			strlen("atv_offset"))) {
-			val = atv_dmd_rd_byte(0x19, 0x04);
-			pr_dbg("atv_offset:0x%x\n", val);
-		}
-	} else if (!strncmp(parm[0], "snr_hist", strlen("snr_hist"))) {
-		data_snr_avg = 0;
-		for (i = 0; i < 128; i++) {
-			data_snr[i] =
-			    (atv_dmd_rd_long(APB_BLOCK_ADDR_VDAGC, 0x50) >> 8);
-			usleep_range(50*1000, 50*1000+100);
-			data_snr_avg += data_snr[i];
-		}
-		data_snr_avg = data_snr_avg / 128;
-		pr_dbg("**********snr_hist_128avg:0x%x(%d)*********\n",
-		       data_snr_avg, data_snr_avg);
-	} else if (!strncmp(parm[0], "afc_info", strlen("afc_info"))) {
-		data_afc = retrieve_vpll_carrier_afc();
-		pr_dbg("[amlatvdemod..]afc %d Khz.\n", data_afc);
-	} else if (!strncmp(parm[0], "ver_info", strlen("ver_info"))) {
-		pr_dbg("[amlatvdemod..]aml_atvdemod_ver %s.\n",
-			AMLATVDEMOD_VER);
-	} else if (!strncmp(parm[0], "audio_autodet",
-		strlen("audio_autodet"))) {
-		aml_audiomode_autodet(NULL);
-	} else if (!strncmp(parm[0], "overmodule_det",
-			strlen("overmodule_det"))) {
-		/* unsigned long over_threshold, */
-		/* int det_mode = auto_det_mode; */
-		aml_atvdemod_overmodule_det();
-	} else if (!strncmp(parm[0], "audio_gain_set",
-			strlen("audio_gain_set"))) {
-		if (kstrtoul(buf+strlen("audio_gain_set")+1, 16, &tmp) == 0)
-			val = tmp;
-		aml_audio_valume_gain_set(val);
-		pr_dbg("audio_gain_set : %d\n", val);
-	} else if (!strncmp(parm[0], "audio_gain_get",
-			strlen("audio_gain_get"))) {
-		val = aml_audio_valume_gain_get();
-		pr_dbg("audio_gain_get : %d\n", val);
-	} else if (!strncmp(parm[0], "fix_pwm_adj", strlen("fix_pwm_adj"))) {
-		if (kstrtoul(parm[1], 10, &tmp) == 0) {
-			val = tmp;
-			aml_fix_PWM_adjust(val);
-		}
-	} else if (!strncmp(parm[0], "rs", strlen("rs"))) {
-		if (kstrtoul(parm[1], 16, &tmp) == 0)
-				block_addr  = tmp;
-		if (kstrtoul(parm[2], 16, &tmp) == 0)
-				block_reg  = tmp;
-		if (block_addr < APB_BLOCK_ADDR_TOP)
-			block_val = atv_dmd_rd_long(block_addr, block_reg);
-		pr_info("rs block_addr:0x%x,block_reg:0x%x,block_val:0x%x\n",
-			block_addr, block_reg, block_val);
-	} else if (!strncmp(parm[0], "ws", strlen("ws"))) {
-		if (kstrtoul(parm[1], 16, &tmp) == 0)
-			block_addr  = tmp;
-		if (kstrtoul(parm[2], 16, &tmp) == 0)
-			block_reg  = tmp;
-		if (kstrtoul(parm[3], 16, &tmp) == 0)
-			block_val  = tmp;
-		if (block_addr < APB_BLOCK_ADDR_TOP)
-			atv_dmd_wr_long(block_addr, block_reg, block_val);
-		pr_info("ws block_addr:0x%x,block_reg:0x%x,block_val:0x%x\n",
-			block_addr, block_reg, block_val);
-		block_val = atv_dmd_rd_long(block_addr, block_reg);
-		pr_info("readback_val:0x%x\n", block_val);
-	} else if (!strncmp(parm[0], "pin_mux", strlen("pin_mux"))) {
-		amlatvdemod_devp->pin =
-			devm_pinctrl_get_select(amlatvdemod_devp->dev,
-				amlatvdemod_devp->pin_name);
-		pr_dbg("atvdemod agc pinmux name:%s\n",
-				amlatvdemod_devp->pin_name);
-	} else if (!strncmp(parm[0], "snr_cur", strlen("snr_cur"))) {
-		data_snr_avg = aml_atvdemod_get_snr_ex();
-		pr_dbg("**********snr_cur:%d*********\n", data_snr_avg);
-	} else
-		pr_dbg("invalid command\n");
-	kfree(buf_orig);
-	return count;
-}
-
-static ssize_t aml_atvdemod_show(struct class *cls,
-	struct class_attribute *attr, char *buff)
-{
-	pr_dbg("\n usage:\n");
-	pr_dbg("[get soft version] echo ver_info > /sys/class/amlatvdemod/atvdemod_debug\n");
-	pr_dbg("[get afc value] echo afc_info > /sys/class/amlatvdemod/atvdemod_debug\n");
-	pr_dbg("[reinit atvdemod] echo init > /sys/class/amlatvdemod/atvdemod_debug\n");
-	pr_dbg("[get av-out-gain/av-out-offset/atv-gain/atv-offset]:\n"
-		"echo get av_gain/av_offset/atv_gain/atv_offset > /sys/class/amlatvdemod/atvdemod_debug\n");
-	pr_dbg("[set av-out-gain/av-out-offset/atv-gain/atv-offset]:\n"
-		"echo set av_gain/av_offset/atv_gain/atv_offset val(0~255) > /sys/class/amlatvdemod/atvdemod_debug\n");
-	return 0;
-}
-static CLASS_ATTR(atvdemod_debug, 0644, aml_atvdemod_show, aml_atvdemod_store);
-
-void aml_atvdemod_set_frequency(unsigned int freq)
-{
-}
-
-/*static void aml_atvdemod_set_std(void);*/
-
-/*try audmode B,CH,I,DK,return the sound level*/
-/*static unsigned char set_video_audio_mode(unsigned char color,
-unsigned char audmode);*/
-/*static void aml_atvdemod_get_status(struct dvb_frontend *fe,
-void *stat);*/
-/*static void aaaml_atvdemod_get_pll_status(struct dvb_frontend *fe,
-void *stat);*/
-
-static int aml_atvdemod_fe_init(struct aml_fe_dev *dev)
-{
-
-	int error_code = 0;
-	if (!dev) {
-		pr_dbg("[amlatvdemod..]%s: null pointer error.\n", __func__);
-		return -1;
-	}
-	return error_code;
-}
-
-static int aml_atvdemod_enter_mode(struct aml_fe *fe, int mode)
-{
-	int err_code;
-	if (amlatvdemod_devp->pin_name != NULL)
-		amlatvdemod_devp->pin =
-			devm_pinctrl_get_select(amlatvdemod_devp->dev,
-				amlatvdemod_devp->pin_name);
-	/* printk("\n%s: set atvdemod pll...\n",__func__); */
-	adc_set_pll_cntl(1, 0x1);
-	atvdemod_clk_init();
-	err_code = atvdemod_init();
-	if (err_code) {
-		pr_dbg("[amlatvdemod..]%s init atvdemod error.\n", __func__);
-		return err_code;
-	}
-
-	set_aft_thread_enable(1);
-	return 0;
-}
-
-static int aml_atvdemod_leave_mode(struct aml_fe *fe, int mode)
-{
-	set_aft_thread_enable(0);
-	atvdemod_uninit();
-	if (amlatvdemod_devp->pin != NULL) {
-		devm_pinctrl_put(amlatvdemod_devp->pin);
-		amlatvdemod_devp->pin = NULL;
-	}
-	/* reset adc pll flag */
-	/* printk("\n%s: init atvdemod flag...\n",__func__); */
-	adc_set_pll_cntl(0, 0x1);
-
-	return 0;
-}
-
-static int aml_atvdemod_suspend(struct aml_fe_dev *dev)
-{
-	return 0;
-}
-
-static int aml_atvdemod_resume(struct aml_fe_dev *dev)
-{
-	return 0;
-}
-
-/*
-static int aml_atvdemod_get_afc(struct dvb_frontend *fe,int *afc)
-{
-	return 0;
-}*/
-
-/*ret:5~100;the val is bigger,the signal is better*/
-int aml_atvdemod_get_snr(struct dvb_frontend *fe)
-{
-#if 1
-	return get_atvdemod_snr_val();
-#else
-	unsigned int snr_val;
-	int ret;
-	snr_val = atv_dmd_rd_long(APB_BLOCK_ADDR_VDAGC, 0x50) >> 8;
-	/* snr_val:900000~0xffffff,ret:5~15 */
-	if (snr_val > 900000)
-		ret = 15 - (snr_val - 900000)*10/(0xffffff - 900000);
-	/* snr_val:158000~900000,ret:15~30 */
-	else if (snr_val > 158000)
-		ret = 30 - (snr_val - 158000)*15/(900000 - 158000);
-	/* snr_val:31600~158000,ret:30~50 */
-	else if (snr_val > 31600)
-		ret = 50 - (snr_val - 31600)*20/(158000 - 31600);
-	/* snr_val:316~31600,ret:50~80 */
-	else if (snr_val > 316)
-		ret = 80 - (snr_val - 316)*30/(31600 - 316);
-	/* snr_val:0~316,ret:80~100 */
-	else
-		ret = 100 - (316 - snr_val)*20/316;
-	return ret;
-#endif
-}
-EXPORT_SYMBOL(aml_atvdemod_get_snr);
-
-int aml_atvdemod_get_snr_ex(void)
-{
-#if 1
-	return get_atvdemod_snr_val();
-#else
-	unsigned int snr_val;
-	int ret;
-	snr_val = atv_dmd_rd_long(APB_BLOCK_ADDR_VDAGC, 0x50) >> 8;
-	/* snr_val:900000~0xffffff,ret:5~15 */
-	if (snr_val > 900000)
-		ret = 15 - (snr_val - 900000)*10/(0xffffff - 900000);
-	/* snr_val:158000~900000,ret:15~30 */
-	else if (snr_val > 158000)
-		ret = 30 - (snr_val - 158000)*15/(900000 - 158000);
-	/* snr_val:31600~158000,ret:30~50 */
-	else if (snr_val > 31600)
-		ret = 50 - (snr_val - 31600)*20/(158000 - 31600);
-	/* snr_val:316~31600,ret:50~80 */
-	else if (snr_val > 316)
-		ret = 80 - (snr_val - 316)*30/(31600 - 316);
-	/* snr_val:0~316,ret:80~100 */
-	else
-		ret = 100 - (316 - snr_val)*20/316;
-	return ret;
-#endif
-}
-EXPORT_SYMBOL(aml_atvdemod_get_snr_ex);
-
-/*tuner lock status & demod lock status should be same in silicon tuner*/
-static int aml_atvdemod_get_status(struct dvb_frontend *fe, void *stat)
-{
-	int video_lock;
-	fe_status_t *status = (fe_status_t *) stat;
-	retrieve_video_lock(&video_lock);
-	if ((video_lock & 0x1) == 0) {
-		/*  *status = FE_HAS_LOCK;*/
-		*status = FE_TIMEDOUT;
-		pr_info("video lock:locked\n");
-	} else {
-		pr_info("video lock:unlocked\n");
-		*status = FE_TIMEDOUT;
-		/*  *status = FE_HAS_LOCK;*/
-	}
-	return 0;
-}
-
-/*tuner lock status & demod lock status should be same in silicon tuner*/
-/* force return lock, for atvdemo status not sure */
-static void aml_atvdemod_get_pll_status(struct dvb_frontend *fe, void *stat)
-{
-	int vpll_lock;
-	fe_status_t *status = (fe_status_t *) stat;
-	retrieve_vpll_carrier_lock(&vpll_lock);
-	if ((vpll_lock&0x1) == 0) {
-		*status = FE_HAS_LOCK;
-		pr_info("visual carrier lock:locked\n");
-	} else {
-		pr_info("visual carrier lock:unlocked\n");
-		*status = FE_TIMEDOUT;
-		/*  *status = FE_HAS_LOCK;*/
-	}
-	return;
-}
-
-static int aml_atvdemod_get_atv_status(struct dvb_frontend *fe,
-		struct atv_status_s *atv_status)
-{
-	int vpll_lock, line_lock;
-	int try_std = 1;
-	int loop_cnt = 5;
-	int cnt = 10;
-	int try_std_cnt = 0;
-	static int last_report_freq;
-	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
-
-	while (fe && atv_status && loop_cnt--) {
-		atv_status->afc = retrieve_vpll_carrier_afc();
-		retrieve_vpll_carrier_lock(&vpll_lock);
-		line_lock = atv_dmd_rd_byte(APB_BLOCK_ADDR_VDAGC, 0x4f)&0x10;
-		if ((vpll_lock&0x1) == 0 || line_lock == 0) {
-			atv_status->atv_lock = 1;
-			try_std_cnt = 2;
-			while (try_std_cnt--) {
-				atv_status->afc = retrieve_vpll_carrier_afc();
-				if (atv_status->afc > 1500
-					&& atvdemod_scan_mode) {
-					if ((c->analog.std & 0xff000000)
-						!= V4L2_COLOR_STD_PAL) {
-						c->analog.std =
-							V4L2_COLOR_STD_PAL
-							| V4L2_STD_PAL_BG;
-						c->frequency += 1;
-						fe->ops.set_frontend(fe);
-						msleep(20);
-					} else {
-						c->analog.std =
-							V4L2_COLOR_STD_NTSC
-							| V4L2_STD_NTSC_M;
-						c->frequency += 1;
-						fe->ops.set_frontend(fe);
-						msleep(20);
-					}
-					atv_status->afc =
-						retrieve_vpll_carrier_afc();
-
-					cnt = 4;
-				while (cnt--) {
-					if (atv_status->afc < 1500)
-						break;
-					atv_status->afc =
-						retrieve_vpll_carrier_afc();
-					usleep_range(5*1000, 5*1000+100);
-				}
-					if (atv_status->afc < 1500)
-						break;
-				}
-			}
-
-			if (atv_status->afc > 4000 && !atvdemod_scan_mode)
-				atv_status->atv_lock = 0;
-
-			if (last_report_freq != c->frequency)
-				last_report_freq = c->frequency;
-
-			if (atvdemod_scan_mode)
-				pr_err("%s,freq:%d, afc:%d\n", __func__,
-					c->frequency, atv_status->afc);
-			break;
-
-		} else if (try_std%3 == 0 && atvdemod_scan_mode) {
-			if ((c->analog.std & 0xff000000)
-				!= V4L2_COLOR_STD_PAL) {
-				c->analog.std =
-					V4L2_COLOR_STD_PAL | V4L2_STD_PAL_DK;
-			}
-			if (1000000 < abs(c->frequency - last_report_freq)) {
-				c->frequency -= 500000;
-				pr_err("@@@ %s freq:%d unlock,try back 0.25M\n",
-					__func__, c->frequency);
-			} else
-				c->frequency += 1;
-			fe->ops.set_frontend(fe);
-			usleep_range(10*1000, 10*1000+100);
-		}
-		if (atvdemod_scan_mode)
-			pr_err("@@@ %s freq:%d unlock, read lock again\n",
-				__func__, c->frequency);
-		else
-			break;
-		atv_status->atv_lock = 0;
-		try_std++;
-	}
-	if (0 == atvdemod_scan_mode) {
-		if (20 > abs(atv_status->afc))
-			afc_wave_cnt = 0;
-		if (500*1000 > abs(last_frq - c->frequency)
-				&& 20 < abs(atv_status->afc)
-				&& 200 > abs(atv_status->afc)) {
-			afc_wave_cnt++;
-			pr_err("%s play mode,afc_wave_cnt:%d\n",
-				__func__, afc_wave_cnt);
-			if (afc_wave_cnt < 20) {
-				atv_status->afc = 0;
-				pr_err("%s, afc is wave,ignore\n", __func__);
-			}
-		}
-	}
-	return 0;
-}
-
-void aml_atvdemod_set_params(struct dvb_frontend *fe,
-				struct analog_parameters *p)
-{
-	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
-	if (FE_ANALOG == fe->ops.info.type) {
-		if ((p->std != amlatvdemod_devp->parm.std) ||
-			(p->tuner_id == AM_TUNER_R840) ||
-			(p->tuner_id == AM_TUNER_SI2151) ||
-			(p->tuner_id == AM_TUNER_MXL661)) {
-			amlatvdemod_devp->parm.std  = p->std;
-			amlatvdemod_devp->parm.if_freq = p->if_freq;
-			amlatvdemod_devp->parm.if_inv = p->if_inv;
-			amlatvdemod_devp->parm.tuner_id = p->tuner_id;
-			/* open AGC if needed */
-			if (amlatvdemod_devp->pin != NULL)
-				devm_pinctrl_put(amlatvdemod_devp->pin);
-			if (amlatvdemod_devp->pin_name)
-				amlatvdemod_devp->pin =
-				devm_pinctrl_get_select(amlatvdemod_devp->dev,
-						amlatvdemod_devp->pin_name);
-			atv_dmd_set_std();
-			last_frq = c->frequency;
-			last_std = c->analog.std;
-			pr_info("[amlatvdemod..]%s set std color %s, audio type %s.\n",
-				__func__,
-			v4l2_std_to_str(0xff000000&amlatvdemod_devp->parm.std),
-			v4l2_std_to_str(0xffffff&amlatvdemod_devp->parm.std));
-			pr_info("[amlatvdemod..]%s set if_freq 0x%x, if_inv 0x%x.\n",
-				__func__, amlatvdemod_devp->parm.if_freq,
-				amlatvdemod_devp->parm.if_inv);
-		}
-	}
-	return;
-}
-static int aml_atvdemod_get_afc(struct dvb_frontend *fe, s32 *afc)
-{
-	*afc = retrieve_vpll_carrier_afc();
-	pr_info("[amlatvdemod..]%s afc %d.\n", __func__, *afc);
-	return 0;
-}
-
-static int aml_atvdemod_get_ops(struct aml_fe_dev *dev, int mode, void *ops)
-{
-	struct analog_demod_ops *aml_analog_ops =
-	    (struct analog_demod_ops *)ops;
-	if (!ops) {
-		pr_dbg("[amlatvdemod..]%s null pointer error.\n", __func__);
-		return -1;
-	}
-	aml_analog_ops->get_afc = aml_atvdemod_get_afc;
-	aml_analog_ops->get_snr = aml_atvdemod_get_snr;
-	aml_analog_ops->get_status = aml_atvdemod_get_status;
-	aml_analog_ops->set_params = aml_atvdemod_set_params;
-	aml_analog_ops->get_pll_status = aml_atvdemod_get_pll_status;
-	aml_analog_ops->get_atv_status = aml_atvdemod_get_atv_status;
-	return 0;
-}
-
-static struct aml_fe_drv aml_atvdemod_drv = {
-	.name = "aml_atv_demod",
-	.capability = AM_FE_ANALOG,
-	.id = AM_ATV_DEMOD_AML,
-	.get_ops = aml_atvdemod_get_ops,
-	.init = aml_atvdemod_fe_init,
-	.enter_mode = aml_atvdemod_enter_mode,
-	.leave_mode = aml_atvdemod_leave_mode,
-	.suspend = aml_atvdemod_suspend,
-	.resume = aml_atvdemod_resume,
-};
-
-struct class *aml_atvdemod_clsp;
-
-static void aml_atvdemod_dt_parse(struct platform_device *pdev)
-{
-	struct device_node *node;
-	unsigned int val;
-	int ret;
-	node = pdev->dev.of_node;
-	/* get interger value */
-	if (node) {
-		ret = of_property_read_u32(node, "reg_23cf", &val);
-		if (ret)
-			pr_dbg("Can't find  reg_23cf.\n");
-		else
-			reg_23cf = val;
-		ret = of_property_read_u32(node, "audio_gain_val", &val);
-		if (ret)
-			pr_dbg("Can't find  audio_gain_val.\n");
-		else
-			set_audio_gain_val(val);
-		ret = of_property_read_u32(node, "video_gain_val", &val);
-		if (ret)
-			pr_dbg("Can't find  video_gain_val.\n");
-		else
-			set_video_gain_val(val);
-		/* agc pin mux */
-		ret = of_property_read_string(node, "pinctrl-names",
-			&amlatvdemod_devp->pin_name);
-		if (!ret) {
-			/* amlatvdemod_devp->pin = */
-			/* devm_pinctrl_get_select(&pdev->dev, */
-			/* amlatvdemod_devp->pin_name); */
-			pr_dbg("atvdemod agc pinmux name:%s\n",
-				amlatvdemod_devp->pin_name);
-		}
-	}
-}
-static struct resource amlatvdemod_memobj;
-void __iomem *amlatvdemod_reg_base;
-void __iomem *amlatvdemod_hiu_reg_base;
-void __iomem *amlatvdemod_periphs_reg_base;
-int amlatvdemod_reg_read(unsigned int reg, unsigned int *val)
-{
-	*val = readl(amlatvdemod_reg_base + reg);
-	return 0;
-}
-
-int amlatvdemod_reg_write(unsigned int reg, unsigned int val)
-{
-	writel(val, (amlatvdemod_reg_base + reg));
-	return 0;
-}
-
-int amlatvdemod_hiu_reg_read(unsigned int reg, unsigned int *val)
-{
-	*val = readl(amlatvdemod_hiu_reg_base + ((reg - 0x1000)<<2));
-	return 0;
-}
-
-int amlatvdemod_hiu_reg_write(unsigned int reg, unsigned int val)
-{
-	writel(val, (amlatvdemod_hiu_reg_base + ((reg - 0x1000)<<2)));
-	return 0;
-}
-int amlatvdemod_periphs_reg_read(unsigned int reg, unsigned int *val)
-{
-	*val = readl(amlatvdemod_periphs_reg_base + ((reg - 0x1000)<<2));
-	return 0;
-}
-
-int amlatvdemod_periphs_reg_write(unsigned int reg, unsigned int val)
-{
-	writel(val, (amlatvdemod_periphs_reg_base + ((reg - 0x1000)<<2)));
-	return 0;
-}
-
-static int aml_atvdemod_probe(struct platform_device *pdev)
-{
-	int ret = 0;
-	struct resource *res;
-	int size_io_reg;
-	res = &amlatvdemod_memobj;
-	amlatvdemod_devp = kmalloc(sizeof(struct amlatvdemod_device_s),
-		GFP_KERNEL);
-	if (!amlatvdemod_devp)
-		goto fail_alloc_region;
-	memset(amlatvdemod_devp, 0, sizeof(struct amlatvdemod_device_s));
-	amlatvdemod_devp->clsp = class_create(THIS_MODULE,
-		ATVDEMOD_DEVICE_NAME);
-	if (!amlatvdemod_devp->clsp)
-		goto fail_create_class;
-	ret = class_create_file(amlatvdemod_devp->clsp,
-		&class_attr_atvdemod_debug);
-	if (ret)
-		goto fail_class_create_file;
-	amlatvdemod_devp->dev = &pdev->dev;
-
-	/*reg mem*/
-	pr_info("%s:amlatvdemod start get  ioremap .\n", __func__);
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	if (!res) {
-		dev_err(&pdev->dev, "missing memory resource\n");
-		return -ENODEV;
-	}
-	size_io_reg = resource_size(res);
-	pr_info("amlatvdemod_probe reg=%p,size=%x\n",
-			(void *)res->start, size_io_reg);
-	amlatvdemod_reg_base =
-		devm_ioremap_nocache(&pdev->dev, res->start, size_io_reg);
-	if (!amlatvdemod_reg_base) {
-		dev_err(&pdev->dev, "amlatvdemod ioremap failed\n");
-		return -ENOMEM;
-	}
-	pr_info("%s: amlatvdemod maped reg_base =%p, size=%x\n",
-			__func__, amlatvdemod_reg_base, size_io_reg);
-	/*remap hiu mem*/
-	amlatvdemod_hiu_reg_base = ioremap(0xc883c000, 0x2000);
-	/*remap periphs mem*/
-	amlatvdemod_periphs_reg_base = ioremap(0xc8834000, 0x2000);
-
-	/*initialize the tuner common struct and register*/
-	aml_register_fe_drv(AM_DEV_ATV_DEMOD, &aml_atvdemod_drv);
-
-	aml_atvdemod_dt_parse(pdev);
-	pr_dbg("[amlatvdemod.] : probe ok.\n");
-	return 0;
-
-fail_class_create_file:
-	pr_dbg("[amlatvdemod.] : atvdemod class file create error.\n");
-	class_destroy(amlatvdemod_devp->clsp);
-fail_create_class:
-	pr_dbg("[amlatvdemod.] : atvdemod class create error.\n");
-	kfree(amlatvdemod_devp);
-fail_alloc_region:
-	pr_dbg("[amlatvdemod.] : atvdemod alloc error.\n");
-	pr_dbg("[amlatvdemod.] : atvdemod_init fail.\n");
-	return ret;
-}
-
-static int __exit aml_atvdemod_remove(struct platform_device *pdev)
-{
-	if (amlatvdemod_devp == NULL)
-		return -1;
-	class_destroy(amlatvdemod_devp->clsp);
-	aml_unregister_fe_drv(AM_DEV_ATV_DEMOD, &aml_atvdemod_drv);
-	kfree(amlatvdemod_devp);
-	pr_dbg("[amlatvdemod.] : amvecm_remove.\n");
-	return 0;
-}
-
-
-static const struct of_device_id aml_atvdemod_dt_match[] = {
-	{
-		.compatible = "amlogic, aml_atv_demod",
-	},
-	{},
-};
-
-static struct platform_driver aml_atvdemod_driver = {
-	.driver = {
-		.name = "aml_atv_demod",
-		.owner = THIS_MODULE,
-		.of_match_table = aml_atvdemod_dt_match,
-	},
-	.probe = aml_atvdemod_probe,
-	.remove = __exit_p(aml_atvdemod_remove),
-};
-
-
-static int __init aml_atvdemod_init(void)
-{
-	if (platform_driver_register(&aml_atvdemod_driver)) {
-		pr_err("failed to register amlatvdemod driver module\n");
-		return -ENODEV;
-	}
-	pr_dbg("[amlatvdemod..]%s.\n", __func__);
-	return 0;
-}
-
-static void __exit aml_atvdemod_exit(void)
-{
-	platform_driver_unregister(&aml_atvdemod_driver);
-	pr_dbg("[amlatvdemod..]%s: driver removed ok.\n", __func__);
-}
-
-MODULE_AUTHOR("dezhi.kong <dezhi.kong@amlogic.com>");
-MODULE_DESCRIPTION("aml atv demod device driver");
-MODULE_LICENSE("GPL");
-
-fs_initcall(aml_atvdemod_init);
-module_exit(aml_atvdemod_exit);
diff --git a/drivers/amlogic/dvb_tv/amlatvdemod/atvdemod_func.c b/drivers/amlogic/dvb_tv/amlatvdemod/atvdemod_func.c
deleted file mode 100644
index a19d1cd894fb..000000000000
--- a/drivers/amlogic/dvb_tv/amlatvdemod/atvdemod_func.c
+++ /dev/null
@@ -1,2073 +0,0 @@
-/*
- * Silicon labs amlogic Atvdemod Device Driver
- *
- * Author: dezhi kong <dezhi.kong@amlogic.com>
- *
- *
- * Copyright (C) 2014 Amlogic Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
-
-/* Standard Liniux Headers */
-#include <linux/module.h>
-#include <linux/i2c.h>
-#include <linux/delay.h>
-#include <linux/timer.h>
-#include <linux/mutex.h>
-#include <linux/interrupt.h>
-#include <linux/time.h>
-
-#include "atvdemod_func.h"
-#include "../aml_dvb_reg.h"
-
-static int broad_std = AML_ATV_DEMOD_VIDEO_MODE_PROP_NTSC;
-module_param(broad_std, int, 0644);
-MODULE_PARM_DESC(broad_std, "\n broad_std\n");
-
-static unsigned long over_threshold = 0xffff;
-module_param(over_threshold, ulong, 0644);
-MODULE_PARM_DESC(over_threshold, "\n over_threshold\n");
-
-static unsigned long input_amplitude = 0xffff;
-module_param(input_amplitude, ulong, 0644);
-MODULE_PARM_DESC(input_amplitude, "\n input_amplitude\n");
-
-static bool audio_det_en;
-module_param(audio_det_en, bool, 0644);
-MODULE_PARM_DESC(audio_det_en, "\n audio_det_en\n");
-
-static bool non_std_en;
-module_param(non_std_en, bool, 0644);
-MODULE_PARM_DESC(non_std__en, "\n non_std_en\n");
-
-static int atv_video_gain;
-module_param(atv_video_gain, int, 0644);
-MODULE_PARM_DESC(atv_video_gain, "\n atv_video_gain\n");
-
-static int audio_det_mode = AUDIO_AUTO_DETECT;
-module_param(audio_det_mode, int, 0644);
-MODULE_PARM_DESC(audio_det_mode, "\n audio_det_mode\n");
-
-static int aud_dmd_jilinTV;
-module_param(aud_dmd_jilinTV, int, 0644);
-MODULE_PARM_DESC(aud_dmd_jilinTV, "\naud dmodulation setting for jilin TV\n");
-
-static unsigned int if_freq = 4250000;	/*PAL-DK:3250000;NTSC-M:4250000*/
-module_param(if_freq, uint, 0644);
-MODULE_PARM_DESC(if_freq, "\n if_freq\n");
-
-static int if_inv;
-module_param(if_inv, int, 0644);
-MODULE_PARM_DESC(if_inv, "\n if_inv\n");
-
-static int afc_default = CARR_AFC_DEFAULT_VAL;
-module_param(afc_default, int, 0644);
-MODULE_PARM_DESC(afc_default, "\n afc_default\n");
-
-/*GDE_Curve
-			0: CURVE-M
-			1: CURVE-A
-			2: CURVE-B
-			3: CURVE-CHINA
-			4: BYPASS
-BG --> CURVE-B(BYPASS)
-DK --> CURVE-CHINA
-NM --> CURVE-M
-I --> BYPASS
-SECAM --> BYPASS*/
-static int gde_curve;
-module_param(gde_curve, int, 0644);
-MODULE_PARM_DESC(gde_curve, "\n gde_curve\n");
-
-static int sound_format;
-module_param(sound_format, int, 0644);
-MODULE_PARM_DESC(sound_format, "\n sound_format\n");
-
-static unsigned int freq_hz_cvrt = AML_ATV_DEMOD_FREQ_60HZ_VERT;
-module_param(freq_hz_cvrt, int, 0644);
-MODULE_PARM_DESC(freq_hz_cvrt, "\n freq_hz\n");
-
-int atvdemod_debug_en = 0;
-module_param(atvdemod_debug_en, int, 0644);
-MODULE_PARM_DESC(atvdemod_debug_en, "\n atvdemod_debug_en\n");
-
-/*1:gpio mode output low;2:pwm mode*/
-static unsigned int atvdemod_agc_pinmux = 2;
-module_param(atvdemod_agc_pinmux, int, 0644);
-MODULE_PARM_DESC(atvdemod_agc_pinmux, "\n atvdemod_agc_pinmux\n");
-
-static unsigned int atvdemod_afc_range = 5;
-module_param(atvdemod_afc_range, uint, 0644);
-MODULE_PARM_DESC(atvdemod_afc_range, "\n atvdemod_afc_range\n");
-
-static unsigned int atvdemod_afc_offset = 500;
-module_param(atvdemod_afc_offset, uint, 0644);
-MODULE_PARM_DESC(atvdemod_afc_offset, "\n atvdemod_afc_offset\n");
-
-static unsigned int atvdemod_timer_en = 1;
-module_param(atvdemod_timer_en, uint, 0644);
-MODULE_PARM_DESC(atvdemod_timer_en, "\n atvdemod_timer_en\n");
-
-static unsigned int atvdemod_afc_en;
-module_param(atvdemod_afc_en, uint, 0644);
-MODULE_PARM_DESC(atvdemod_afc_en, "\n atvdemod_afc_en\n");
-
-static unsigned int atvdemod_monitor_en;
-module_param(atvdemod_monitor_en, uint, 0644);
-MODULE_PARM_DESC(atvdemod_monitor_en, "\n atvdemod_monitor_en\n");
-
-static unsigned int atvdemod_det_snr_en = 1;
-module_param(atvdemod_det_snr_en, uint, 0644);
-MODULE_PARM_DESC(atvdemod_det_snr_en, "\n atvdemod_det_snr_en\n");
-
-static unsigned int pwm_kp = 0x19;
-module_param(pwm_kp, uint, 0644);
-MODULE_PARM_DESC(pwm_kp, "\n pwm_kp\n");
-
-static unsigned int reg_dbg_en;
-module_param(reg_dbg_en, uint, 0644);
-MODULE_PARM_DESC(reg_dbg_en, "\n reg_dbg_en\n");
-
-static unsigned int audio_gain_val = 512;
-module_param(audio_gain_val, uint, 0644);
-MODULE_PARM_DESC(audio_gain_val, "\n audio_gain_val\n");
-
-enum AUDIO_SCAN_ID {
-	ID_PAL_I = 0,
-	ID_PAL_M,
-	ID_PAL_DK,
-	ID_PAL_BG,
-	ID_MAX,
-};
-
-static unsigned int mix1_freq;
-static unsigned int timer_init_flag;
-struct timer_list atvdemod_timer;
-static int snr_val;
-int broad_std_except_pal_m = 0;
-
-int get_atvdemod_snr_val(void)
-{
-	return snr_val;
-}
-EXPORT_SYMBOL(get_atvdemod_snr_val);
-
-void amlatvdemod_set_std(int val)
-{
-	broad_std = val;
-}
-EXPORT_SYMBOL(amlatvdemod_set_std);
-
-void atv_dmd_wr_reg(unsigned char block, unsigned char reg, unsigned long data)
-{
-	/* unsigned long data_tmp; */
-	unsigned long reg_addr = (block<<8) + reg * 4;
-	amlatvdemod_reg_write(reg_addr, data);
-}
-
-unsigned long atv_dmd_rd_reg(unsigned char block, unsigned char reg)
-{
-	unsigned long data = 0;
-	unsigned long reg_addr = (block<<8) + reg * 4;
-	amlatvdemod_reg_read(reg_addr, (unsigned int *)&data);
-	return data;
-}
-
-unsigned long atv_dmd_rd_byte(unsigned long block_addr, unsigned long reg_addr)
-{
-	unsigned long data;
-	data = atv_dmd_rd_long(block_addr, reg_addr);
-	/*R_APB_REG((((block_addr & 0xff) <<6) + ((reg_addr & 0xff) >>2)) << 2);
-	*((volatile unsigned long *) (ATV_DMD_APB_BASE_ADDR+
-	((((block_addr & 0xff) <<6) + ((reg_addr & 0xff) >>2)) << 2)));*/
-	if ((reg_addr & 0x3) == 0)
-		data = data >> 24;
-	else if ((reg_addr & 0x3) == 1)
-		data = (data >> 16 & 0xff);
-	else if ((reg_addr & 0x3) == 2)
-		data = (data >> 8 & 0xff);
-	else if ((reg_addr & 0x3) == 3)
-		data = (data >> 0 & 0xff);
-	return data;
-}
-
-unsigned long atv_dmd_rd_word(unsigned long block_addr, unsigned long reg_addr)
-{
-	unsigned long data;
-	data = atv_dmd_rd_long(block_addr, reg_addr);
-	/*R_APB_REG((((block_addr & 0xff) <<6) + ((reg_addr & 0xff) >>2)) << 2);
-	*((volatile unsigned long *) (ATV_DMD_APB_BASE_ADDR+
-	((((block_addr & 0xff) <<6) + ((reg_addr & 0xff) >>2)) << 2)));*/
-	if ((reg_addr & 0x3) == 0)
-		data = data >> 16;
-	else if ((reg_addr & 0x3) == 1)
-		data = (data >> 8 & 0xffff);
-	else if ((reg_addr & 0x3) == 2)
-		data = (data >> 0 & 0xffff);
-	else if ((reg_addr & 0x3) == 3)
-		data = (((data & 0xff) << 8) | ((data >> 24) & 0xff));
-	return data;
-}
-
-unsigned long atv_dmd_rd_long(unsigned long block_addr, unsigned long reg_addr)
-{
-	unsigned long data;
-	/*data = *((volatile unsigned long *) (ATV_DMD_APB_BASE_ADDR+
-	((((block_addr & 0xff) <<6) + ((reg_addr & 0xff) >>2)) << 2)));*/
-	data =
-	    R_ATVDEMOD_REG((((block_addr & 0xff) << 6) +
-	    ((reg_addr & 0xff) >> 2)) << 2);
-
-	return data;
-}
-EXPORT_SYMBOL(atv_dmd_rd_long);
-
-void atv_dmd_wr_long(unsigned long block_addr, unsigned long reg_addr,
-		     unsigned long data)
-{
-	W_ATVDEMOD_REG((((block_addr & 0xff) << 6) +
-		((reg_addr & 0xff) >> 2)) << 2, data);
-	if (reg_dbg_en)
-		pr_dbg("block_addr:0x%x,reg_addr:0x%x;data:0x%x\n",
-		(unsigned int)block_addr, (unsigned int)reg_addr,
-		(unsigned int)data);
-	/**((volatile unsigned long *)
-		(ATV_DMD_APB_BASE_ADDR+((((block_addr & 0xff) << 6) +
-		((reg_addr & 0xff) >> 2)) << 2))) = data;*/
-
-}
-EXPORT_SYMBOL(atv_dmd_wr_long);
-
-void atv_dmd_wr_word(unsigned long block_addr, unsigned long reg_addr,
-		     unsigned long data)
-{
-	unsigned long data_tmp;
-	data_tmp = atv_dmd_rd_long(block_addr, reg_addr);
-	data = data & 0xffff;
-	if ((reg_addr & 0x3) == 0)
-		data = (data << 16 | (data_tmp & 0xffff));
-	else if ((reg_addr & 0x3) == 1)
-		data =
-		    ((data_tmp & 0xff000000) | (data << 8) | (data_tmp & 0xff));
-	else if ((reg_addr & 0x3) == 2)
-		data = (data | (data_tmp & 0xffff0000));
-	else if ((reg_addr & 0x3) == 3)
-		data =
-		    (((data & 0xff) << 24) | ((data_tmp & 0xffff0000) >> 8) |
-		     ((data & 0xff00) >> 8));
-
-	/**((volatile unsigned long *) (ATV_DMD_APB_BASE_ADDR+
-	((((block_addr & 0xff) <<6) + ((reg_addr & 0xff) >>2)) << 2))) = data;*/
-	atv_dmd_wr_long(block_addr, reg_addr, data);
-	/*W_ATVDEMOD_REG(((((block_addr & 0xff) <<6) +
-	((reg_addr & 0xff) >>2)) << 2), data);*/
-
-}
-
-void atv_dmd_wr_byte(unsigned long block_addr, unsigned long reg_addr,
-		     unsigned long data)
-{
-	unsigned long data_tmp;
-	data_tmp = atv_dmd_rd_long(block_addr, reg_addr);
-
-	/*pr_info("atv demod wr byte, read block addr %lx\n",block_addr);*/
-	/*pr_info("atv demod wr byte, read reg addr %lx\n", reg_addr);*/
-	/*pr_info("atv demod wr byte, wr data %lx\n",data);*/
-	/*pr_info("atv demod wr byte, read data out %lx\n",data_tmp);*/
-
-	data = data & 0xff;
-	/*pr_info("atv demod wr byte, data & 0xff %lx\n",data);*/
-	if ((reg_addr & 0x3) == 0) {
-		data = (data << 24 | (data_tmp & 0xffffff));
-		/*pr_info("atv demod wr byte, reg_addr & 0x3 == 0,
-		wr data %lx\n",data);*/
-	} else if ((reg_addr & 0x3) == 1)
-		data =
-		    ((data_tmp & 0xff000000) | (data << 16) |
-		     (data_tmp & 0xffff));
-	else if ((reg_addr & 0x3) == 2)
-		data =
-		    ((data_tmp & 0xffff0000) | (data << 8) | (data_tmp & 0xff));
-	else if ((reg_addr & 0x3) == 3)
-		data = ((data_tmp & 0xffffff00) | (data & 0xff));
-
-	/*pr_info("atv demod wr byte, wr data %lx\n",data);*/
-
-	/**((volatile unsigned long *) (ATV_DMD_APB_BASE_ADDR+
-	((((block_addr & 0xff) <<6) + ((reg_addr & 0xff) >>2)) << 2))) = data;*/
-	atv_dmd_wr_long(block_addr, reg_addr, data);
-	/*W_ATVDEMOD_REG(((((block_addr & 0xff) <<6) +
-	((reg_addr & 0xff) >>2)) << 2), data);*/
-}
-
-void set_audio_gain_val(int val)
-{
-	audio_gain_val = val;
-}
-
-void set_video_gain_val(int val)
-{
-	atv_video_gain = val;
-}
-
-void atv_dmd_soft_reset(void)
-{
-	atv_dmd_wr_byte(APB_BLOCK_ADDR_SYSTEM_MGT, 0x0, 0x0);
-	atv_dmd_wr_byte(APB_BLOCK_ADDR_SYSTEM_MGT, 0x0, 0x1);
-}
-
-void atv_dmd_input_clk_32m(void)
-{
-	atv_dmd_wr_byte(APB_BLOCK_ADDR_ADC_MGR, 0x2, 0x1);
-}
-
-void read_version_register(void)
-{
-	unsigned long data, Byte1, Byte2, Word;
-
-	pr_info("ATV-DMD read version register\n");
-	Byte1 = atv_dmd_rd_byte(APB_BLOCK_ADDR_VERS_REGISTER, 0x0);
-	Byte2 = atv_dmd_rd_byte(APB_BLOCK_ADDR_VERS_REGISTER, 0x1);
-	Word = atv_dmd_rd_word(APB_BLOCK_ADDR_VERS_REGISTER, 0x2);
-	data = atv_dmd_rd_long(APB_BLOCK_ADDR_VERS_REGISTER, 0x0);
-
-	pr_info("atv demod read version register data out %lx\n", data);
-
-	if ((data != 0x516EAB13)
-	    || (((Byte1 << 24) | (Byte2 << 16) | Word) != 0x516EAB13))
-		pr_info("atv demod read version reg failed\n");
-}
-
-void check_communication_interface(void)
-{
-	unsigned long data_tmp;
-
-	pr_info("ATV-DMD check communication intf\n");
-	atv_dmd_wr_long(APB_BLOCK_ADDR_VERS_REGISTER, 0x0, 0xA1B2C3D4);
-	atv_dmd_wr_byte(APB_BLOCK_ADDR_VERS_REGISTER, 0x1, 0x34);
-	atv_dmd_wr_word(APB_BLOCK_ADDR_VERS_REGISTER, 0x2, 0xBCDE);
-	data_tmp = atv_dmd_rd_long(APB_BLOCK_ADDR_VERS_REGISTER, 0x0);
-	pr_info("atv demod check communication intf data out %lx\n", data_tmp);
-
-	if (data_tmp != 0xa134bcde)
-		pr_info("atv demod check communication intf failed\n");
-	atv_dmd_wr_long(APB_BLOCK_ADDR_VERS_REGISTER, 0x0, 0x516EAB13);
-}
-
-void power_on_receiver(void)
-{
-	atv_dmd_wr_byte(APB_BLOCK_ADDR_ADC_MGR, 0x2, 0x11);
-}
-
-void atv_dmd_misc(void)
-{
-	atv_dmd_wr_byte(APB_BLOCK_ADDR_AGC_PWM, 0x08, 0x38);	/*zhuangwei*/
-	/*cpu.write_byte(8'h1A,8'h0E,8'h06);//zhuangwei*/
-	/*cpu.write_byte(8'h19,8'h01,8'h7f);//zhuangwei*/
-	atv_dmd_wr_byte(0x0f, 0x45, 0x90);	/*zhuangwei*/
-
-	atv_dmd_wr_long(0x0f, 0x44, 0x5c8808c1);/*zhuangwei*/
-	if (amlatvdemod_devp->parm.tuner_id == AM_TUNER_R840) {
-		atv_dmd_wr_long(0x0f, 0x3c, reg_23cf);/*zhuangwei*/
-		/*guanzhong@20150804a*/
-		atv_dmd_wr_byte(APB_BLOCK_ADDR_SIF_STG_2, 0x00, 0x1);
-		atv_dmd_wr_long(APB_BLOCK_ADDR_AGC_PWM, 0x08, 0x60180200);
-		/*dezhi@20150610a 0x1a maybe better?!*/
-		/* atv_dmd_wr_byte(APB_BLOCK_ADDR_AGC_PWM, 0x09, 0x19); */
-	} else {
-		atv_dmd_wr_long(0x0f, 0x3c, 0x88188832);/*zhuangwei*/
-		atv_dmd_wr_long(APB_BLOCK_ADDR_AGC_PWM, 0x08, 0x46170200);
-	}
-
-	if (amlatvdemod_devp->parm.tuner_id == AM_TUNER_MXL661) {
-		atv_dmd_wr_long(0x0c, 0x04, 0xbffa0000) ;/*test in sky*/
-		atv_dmd_wr_long(0x0c, 0x00, 0x5a4000);/*test in sky*/
-		/*guanzhong@20151013 fix nonstd def is:0x0c010301;0x0c020601*/
-		atv_dmd_wr_long(APB_BLOCK_ADDR_CARR_RCVY, 0x24, 0x0c030901);
-	} else {
-		/*zhuangwei 0xdafa0000*/
-		atv_dmd_wr_long(0x0c, 0x04, 0xc8fa0000);
-		atv_dmd_wr_long(0x0c, 0x00, 0x554000);/*zhuangwei*/
-	}
-	atv_dmd_wr_long(0x19, 0x04, 0xdafa0000);/*zhuangwei*/
-	atv_dmd_wr_long(0x19, 0x00, 0x4a4000);/*zhuangwei*/
-	/*atv_dmd_wr_byte(0x0c,0x01,0x28);//pwd-out gain*/
-	/*atv_dmd_wr_byte(0x0c,0x04,0xc0);//pwd-out offset*/
-	if (is_meson_gxtvbb_cpu()) {
-		aml_audio_valume_gain_set(audio_gain_val);
-		/* 20160121 fix audio demodulation over */
-		atv_dmd_wr_long(0x09, 0x00, 0x1030501);
-		atv_dmd_wr_long(0x09, 0x04, 0x1900000);
-		if (aud_dmd_jilinTV)
-			atv_dmd_wr_long(0x09, 0x00, 0x2030503);
-		if (non_std_en == 1) {
-			atv_dmd_wr_long(0x09, 0x00, 0x2030503);
-			atv_dmd_wr_long(0x0f, 0x44, 0x7c8808c1);
-			atv_dmd_wr_long(0x06, 0x24, 0x0c010801);
-		} else {
-			atv_dmd_wr_long(0x09, 0x00, 0x1030501);
-			if (atv_video_gain)
-				atv_dmd_wr_long(0x0f, 0x44, atv_video_gain);
-			else
-				atv_dmd_wr_long(0x0f, 0x44, 0xfc0808c1);
-			atv_dmd_wr_long(0x06, 0x24, 0xc030901);
-		}
-
-	}
-}
-
-/*Broadcast_Standard*/
-/*                      0: NTSC*/
-/*                      1: NTSC-J*/
-/*                      2: PAL-M,*/
-/*                      3: PAL-BG*/
-/*                      4: DTV*/
-/*                      5: SECAM- DK2*/
-/*                      6: SECAM -DK3*/
-/*                      7: PAL-BG, NICAM*/
-/*                      8: PAL-DK-CHINA*/
-/*                      9: SECAM-L / SECAM-DK3*/
-/*                      10: PAL-I*/
-/*                      11: PAL-DK1*/
-/*GDE_Curve*/
-/*                      0: CURVE-M*/
-/*                      1: CURVE-A*/
-/*                      2: CURVE-B*/
-/*                      3: CURVE-CHINA*/
-/*                      4: BYPASS*/
-/*sound format 0: MONO;1:NICAM*/
-void configure_receiver(int Broadcast_Standard, unsigned int Tuner_IF_Frequency,
-			int Tuner_Input_IF_inverted, int GDE_Curve,
-			int sound_format)
-{
-	int tmp_int;
-	int mixer1 = 0;
-	int mixer3 = 0;
-	int mixer3_bypass = 0;
-	int cv = 0;
-	/*int if_freq = 0;*/
-
-	int i = 0;
-	int super_coef0 = 0;
-	int super_coef1 = 0;
-	int super_coef2 = 0;
-	int gp_coeff_1[37];
-	int gp_coeff_2[37];
-	int gp_cv_g1 = 0;
-	int gp_cv_g2 = 0;
-	int crvy_reg_1 = 0;
-	int crvy_reg_2 = 0;
-	int sif_co_mx = 0;
-	int sif_fi_mx = 0;
-	int sif_ic_bw = 0;
-	int sif_bb_bw = 0;
-	int sif_deemp = 0;
-	int sif_cfg_demod = 0;
-	int sif_fm_gain = 0;
-	int gd_coeff[6];
-	int gd_bypass;
-
-	pr_info("ATV-DMD configure receiver register\n");
-
-	if ((Broadcast_Standard == AML_ATV_DEMOD_VIDEO_MODE_PROP_NTSC) ||
-		(Broadcast_Standard == AML_ATV_DEMOD_VIDEO_MODE_PROP_NTSC_J) ||
-		(Broadcast_Standard == AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_M) ||
-		(Broadcast_Standard == AML_ATV_DEMOD_VIDEO_MODE_PROP_NTSC_DK) ||
-		(Broadcast_Standard == AML_ATV_DEMOD_VIDEO_MODE_PROP_NTSC_BG) ||
-		(Broadcast_Standard == AML_ATV_DEMOD_VIDEO_MODE_PROP_NTSC_I)) {
-		gp_coeff_1[0] = 0x57777;
-		gp_coeff_1[1] = 0xdd777;
-		gp_coeff_1[2] = 0x7d777;
-		gp_coeff_1[3] = 0x75777;
-		gp_coeff_1[4] = 0x75777;
-		gp_coeff_1[5] = 0x7c777;
-		gp_coeff_1[6] = 0x5c777;
-		gp_coeff_1[7] = 0x44777;
-		gp_coeff_1[8] = 0x54777;
-		gp_coeff_1[9] = 0x47d77;
-		gp_coeff_1[10] = 0x55d77;
-		gp_coeff_1[11] = 0x55577;
-		gp_coeff_1[12] = 0x77577;
-		gp_coeff_1[13] = 0xc4c77;
-		gp_coeff_1[14] = 0xd7d77;
-		gp_coeff_1[15] = 0x75477;
-		gp_coeff_1[16] = 0xcc477;
-		gp_coeff_1[17] = 0x575d7;
-		gp_coeff_1[18] = 0xc4c77;
-		gp_coeff_1[19] = 0xdd757;
-		gp_coeff_1[20] = 0xdd477;
-		gp_coeff_1[21] = 0x77dd7;
-		gp_coeff_1[22] = 0x5dc77;
-		gp_coeff_1[23] = 0x47c47;
-		gp_coeff_1[24] = 0x57477;
-		gp_coeff_1[25] = 0x5c7c7;
-		gp_coeff_1[26] = 0xccc77;
-		gp_coeff_1[27] = 0x5ddd5;
-		gp_coeff_1[28] = 0x54477;
-		gp_coeff_1[29] = 0x7757d;
-		gp_coeff_1[30] = 0x755d7;
-		gp_coeff_1[31] = 0x47cc4;
-		gp_coeff_1[32] = 0x57d57;
-		gp_coeff_1[33] = 0x554cc;
-		gp_coeff_1[34] = 0x755d7;
-		gp_coeff_1[35] = 0x7d3b2;
-		gp_coeff_1[36] = 0x73a91;
-		gp_coeff_2[0] = 0xd5777;
-		gp_coeff_2[1] = 0x77777;
-		gp_coeff_2[2] = 0x7c777;
-		gp_coeff_2[3] = 0xcc777;
-		gp_coeff_2[4] = 0xc7777;
-		gp_coeff_2[5] = 0xdd777;
-		gp_coeff_2[6] = 0x44c77;
-		gp_coeff_2[7] = 0x54c77;
-		gp_coeff_2[8] = 0xdd777;
-		gp_coeff_2[9] = 0x7c777;
-		gp_coeff_2[10] = 0xc7c77;
-		gp_coeff_2[11] = 0x75c77;
-		gp_coeff_2[12] = 0xdd577;
-		gp_coeff_2[13] = 0x44777;
-		gp_coeff_2[14] = 0xd5c77;
-		gp_coeff_2[15] = 0xdc777;
-		gp_coeff_2[16] = 0xd7757;
-		gp_coeff_2[17] = 0x4c757;
-		gp_coeff_2[18] = 0x7d777;
-		gp_coeff_2[19] = 0x75477;
-		gp_coeff_2[20] = 0x57547;
-		gp_coeff_2[21] = 0xdc747;
-		gp_coeff_2[22] = 0x74777;
-		gp_coeff_2[23] = 0x75757;
-		gp_coeff_2[24] = 0x4cc75;
-		gp_coeff_2[25] = 0xd4747;
-		gp_coeff_2[26] = 0x7d7d7;
-		gp_coeff_2[27] = 0xd5577;
-		gp_coeff_2[28] = 0xc4c75;
-		gp_coeff_2[29] = 0xcc477;
-		gp_coeff_2[30] = 0xdd54c;
-		gp_coeff_2[31] = 0x7547d;
-		gp_coeff_2[32] = 0x55547;
-		gp_coeff_2[33] = 0x5575c;
-		gp_coeff_2[34] = 0xd543a;
-		gp_coeff_2[35] = 0x57b3a;
-		gp_coeff_2[36] = 0x77777;
-		gp_cv_g1 = 0x2b062d;
-		gp_cv_g2 = 0x40fa2d;
-	} else if ((Broadcast_Standard ==
-	AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_BG) ||
-	(Broadcast_Standard == AML_ATV_DEMOD_VIDEO_MODE_PROP_SECAM_DK2) ||
-	(Broadcast_Standard == AML_ATV_DEMOD_VIDEO_MODE_PROP_SECAM_DK3) ||
-	(Broadcast_Standard == AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_BG_NICAM)) {
-		gp_coeff_1[0] = 0x75777;
-		gp_coeff_1[1] = 0x57777;
-		gp_coeff_1[2] = 0x7d777;
-		gp_coeff_1[3] = 0x75777;
-		gp_coeff_1[4] = 0x75777;
-		gp_coeff_1[5] = 0x7c777;
-		gp_coeff_1[6] = 0x47777;
-		gp_coeff_1[7] = 0x74777;
-		gp_coeff_1[8] = 0xd5d77;
-		gp_coeff_1[9] = 0xc7777;
-		gp_coeff_1[10] = 0x77577;
-		gp_coeff_1[11] = 0xd7d77;
-		gp_coeff_1[12] = 0x75d77;
-		gp_coeff_1[13] = 0xdd477;
-		gp_coeff_1[14] = 0x77d77;
-		gp_coeff_1[15] = 0x75c77;
-		gp_coeff_1[16] = 0xc4477;
-		gp_coeff_1[17] = 0x4c777;
-		gp_coeff_1[18] = 0x5d5d7;
-		gp_coeff_1[19] = 0xd7d57;
-		gp_coeff_1[20] = 0x47577;
-		gp_coeff_1[21] = 0xd7dd7;
-		gp_coeff_1[22] = 0xd7d57;
-		gp_coeff_1[23] = 0xdd757;
-		gp_coeff_1[24] = 0xc75c7;
-		gp_coeff_1[25] = 0x7d477;
-		gp_coeff_1[26] = 0x5d747;
-		gp_coeff_1[27] = 0x7ddc7;
-		gp_coeff_1[28] = 0xc4c77;
-		gp_coeff_1[29] = 0xd4c75;
-		gp_coeff_1[30] = 0xc755d;
-		gp_coeff_1[31] = 0x47cc7;
-		gp_coeff_1[32] = 0xdd7d4;
-		gp_coeff_1[33] = 0x4c75d;
-		gp_coeff_1[34] = 0xc7dcc;
-		gp_coeff_1[35] = 0xd52a2;
-		gp_coeff_1[36] = 0x555a1;
-		gp_coeff_2[0] = 0x5d777;
-		gp_coeff_2[1] = 0x47777;
-		gp_coeff_2[2] = 0x7d777;
-		gp_coeff_2[3] = 0xcc777;
-		gp_coeff_2[4] = 0xd7777;
-		gp_coeff_2[5] = 0x7c777;
-		gp_coeff_2[6] = 0x7dd77;
-		gp_coeff_2[7] = 0xdd777;
-		gp_coeff_2[8] = 0x7c777;
-		gp_coeff_2[9] = 0x57c77;
-		gp_coeff_2[10] = 0x7c777;
-		gp_coeff_2[11] = 0xd5777;
-		gp_coeff_2[12] = 0xd7c77;
-		gp_coeff_2[13] = 0xdd777;
-		gp_coeff_2[14] = 0x77477;
-		gp_coeff_2[15] = 0xc7d77;
-		gp_coeff_2[16] = 0xc4777;
-		gp_coeff_2[17] = 0x57557;
-		gp_coeff_2[18] = 0xd5577;
-		gp_coeff_2[19] = 0xd5577;
-		gp_coeff_2[20] = 0x7d547;
-		gp_coeff_2[21] = 0x74757;
-		gp_coeff_2[22] = 0xc7577;
-		gp_coeff_2[23] = 0xcc7d5;
-		gp_coeff_2[24] = 0x4c747;
-		gp_coeff_2[25] = 0xddc77;
-		gp_coeff_2[26] = 0x54447;
-		gp_coeff_2[27] = 0xcc447;
-		gp_coeff_2[28] = 0x5755d;
-		gp_coeff_2[29] = 0x5dd57;
-		gp_coeff_2[30] = 0x54747;
-		gp_coeff_2[31] = 0x5747c;
-		gp_coeff_2[32] = 0xc77dd;
-		gp_coeff_2[33] = 0x47557;
-		gp_coeff_2[34] = 0x7a22a;
-		gp_coeff_2[35] = 0xc73aa;
-		gp_coeff_2[36] = 0x77777;
-		gp_cv_g1 = 0x2b2834;
-		gp_cv_g2 = 0x3f6c2e;
-	} else if ((Broadcast_Standard ==
-	AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_DK) ||
-	(Broadcast_Standard == AML_ATV_DEMOD_VIDEO_MODE_PROP_SECAM_DK3)) {
-		gp_coeff_1[0] = 0x47777;
-		gp_coeff_1[1] = 0x77777;
-		gp_coeff_1[2] = 0x5d777;
-		gp_coeff_1[3] = 0x47777;
-		gp_coeff_1[4] = 0x75777;
-		gp_coeff_1[5] = 0x5c777;
-		gp_coeff_1[6] = 0x57777;
-		gp_coeff_1[7] = 0x44777;
-		gp_coeff_1[8] = 0x55d77;
-		gp_coeff_1[9] = 0x7d777;
-		gp_coeff_1[10] = 0x55577;
-		gp_coeff_1[11] = 0xd5d77;
-		gp_coeff_1[12] = 0xd7d77;
-		gp_coeff_1[13] = 0x47477;
-		gp_coeff_1[14] = 0xdc777;
-		gp_coeff_1[15] = 0x4cc77;
-		gp_coeff_1[16] = 0x77d57;
-		gp_coeff_1[17] = 0xc4777;
-		gp_coeff_1[18] = 0xdd7d7;
-		gp_coeff_1[19] = 0x7c757;
-		gp_coeff_1[20] = 0xd4477;
-		gp_coeff_1[21] = 0x755c7;
-		gp_coeff_1[22] = 0x47d57;
-		gp_coeff_1[23] = 0xd7c47;
-		gp_coeff_1[24] = 0xd4cc7;
-		gp_coeff_1[25] = 0x47577;
-		gp_coeff_1[26] = 0x5c7d5;
-		gp_coeff_1[27] = 0x4c75d;
-		gp_coeff_1[28] = 0xd57d7;
-		gp_coeff_1[29] = 0x44755;
-		gp_coeff_1[30] = 0x7557d;
-		gp_coeff_1[31] = 0xc477d;
-		gp_coeff_1[32] = 0xd5d44;
-		gp_coeff_1[33] = 0xdd77d;
-		gp_coeff_1[34] = 0x5d75b;
-		gp_coeff_1[35] = 0x74332;
-		gp_coeff_1[36] = 0xd4311;
-		gp_coeff_2[0] = 0xd7777;
-		gp_coeff_2[1] = 0x77777;
-		gp_coeff_2[2] = 0xdd777;
-		gp_coeff_2[3] = 0xdc777;
-		gp_coeff_2[4] = 0xc7777;
-		gp_coeff_2[5] = 0xdd777;
-		gp_coeff_2[6] = 0x77d77;
-		gp_coeff_2[7] = 0x77777;
-		gp_coeff_2[8] = 0x55777;
-		gp_coeff_2[9] = 0xc7d77;
-		gp_coeff_2[10] = 0xd4777;
-		gp_coeff_2[11] = 0xc7477;
-		gp_coeff_2[12] = 0x7c777;
-		gp_coeff_2[13] = 0xd5577;
-		gp_coeff_2[14] = 0xdd557;
-		gp_coeff_2[15] = 0x47577;
-		gp_coeff_2[16] = 0xd7477;
-		gp_coeff_2[17] = 0x55747;
-		gp_coeff_2[18] = 0xdd757;
-		gp_coeff_2[19] = 0xd7477;
-		gp_coeff_2[20] = 0x7d7d5;
-		gp_coeff_2[21] = 0xddd47;
-		gp_coeff_2[22] = 0xdd777;
-		gp_coeff_2[23] = 0x575d5;
-		gp_coeff_2[24] = 0x47547;
-		gp_coeff_2[25] = 0x555c7;
-		gp_coeff_2[26] = 0x7d447;
-		gp_coeff_2[27] = 0xd7447;
-		gp_coeff_2[28] = 0x757dd;
-		gp_coeff_2[29] = 0x7dc77;
-		gp_coeff_2[30] = 0x54747;
-		gp_coeff_2[31] = 0xc743b;
-		gp_coeff_2[32] = 0xd7c7c;
-		gp_coeff_2[33] = 0xd7557;
-		gp_coeff_2[34] = 0x55c7a;
-		gp_coeff_2[35] = 0x4cc29;
-		gp_coeff_2[36] = 0x77777;
-		gp_cv_g1 = 0x20682b;
-		gp_cv_g2 = 0x29322f;
-	} else if (Broadcast_Standard == AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_I) {
-		gp_coeff_1[0] = 0x77777;
-		gp_coeff_1[1] = 0x75777;
-		gp_coeff_1[2] = 0x7d777;
-		gp_coeff_1[3] = 0xd7777;
-		gp_coeff_1[4] = 0x74777;
-		gp_coeff_1[5] = 0xcc777;
-		gp_coeff_1[6] = 0x57777;
-		gp_coeff_1[7] = 0x5d577;
-		gp_coeff_1[8] = 0x5dd77;
-		gp_coeff_1[9] = 0x74777;
-		gp_coeff_1[10] = 0x77577;
-		gp_coeff_1[11] = 0x77c77;
-		gp_coeff_1[12] = 0xdc477;
-		gp_coeff_1[13] = 0x5d577;
-		gp_coeff_1[14] = 0x575d7;
-		gp_coeff_1[15] = 0xc7d57;
-		gp_coeff_1[16] = 0x77777;
-		gp_coeff_1[17] = 0x557d7;
-		gp_coeff_1[18] = 0xc7557;
-		gp_coeff_1[19] = 0x75c77;
-		gp_coeff_1[20] = 0x477d7;
-		gp_coeff_1[21] = 0xcc747;
-		gp_coeff_1[22] = 0x47dd7;
-		gp_coeff_1[23] = 0x775d7;
-		gp_coeff_1[24] = 0x47447;
-		gp_coeff_1[25] = 0x75cc7;
-		gp_coeff_1[26] = 0xc7777;
-		gp_coeff_1[27] = 0xc75d5;
-		gp_coeff_1[28] = 0x44c7d;
-		gp_coeff_1[29] = 0x74c47;
-		gp_coeff_1[30] = 0x47d75;
-		gp_coeff_1[31] = 0x7d57c;
-		gp_coeff_1[32] = 0xd5dc4;
-		gp_coeff_1[33] = 0xdd575;
-		gp_coeff_1[34] = 0xdb3bb;
-		gp_coeff_1[35] = 0x5c752;
-		gp_coeff_1[36] = 0x90880;
-		gp_coeff_2[0] = 0x5d777;
-		gp_coeff_2[1] = 0xd7777;
-		gp_coeff_2[2] = 0x77777;
-		gp_coeff_2[3] = 0xd5d77;
-		gp_coeff_2[4] = 0xc7777;
-		gp_coeff_2[5] = 0xd7777;
-		gp_coeff_2[6] = 0xddd77;
-		gp_coeff_2[7] = 0x55777;
-		gp_coeff_2[8] = 0x57777;
-		gp_coeff_2[9] = 0x54c77;
-		gp_coeff_2[10] = 0x4c477;
-		gp_coeff_2[11] = 0x74777;
-		gp_coeff_2[12] = 0xd5d77;
-		gp_coeff_2[13] = 0x47757;
-		gp_coeff_2[14] = 0x75577;
-		gp_coeff_2[15] = 0xc7577;
-		gp_coeff_2[16] = 0x4c747;
-		gp_coeff_2[17] = 0x7d477;
-		gp_coeff_2[18] = 0x7c757;
-		gp_coeff_2[19] = 0x55dd5;
-		gp_coeff_2[20] = 0x57577;
-		gp_coeff_2[21] = 0x44c47;
-		gp_coeff_2[22] = 0x5cc75;
-		gp_coeff_2[23] = 0x4cc77;
-		gp_coeff_2[24] = 0x47547;
-		gp_coeff_2[25] = 0x777d5;
-		gp_coeff_2[26] = 0xcccc7;
-		gp_coeff_2[27] = 0x57447;
-		gp_coeff_2[28] = 0xdc757;
-		gp_coeff_2[29] = 0x5755c;
-		gp_coeff_2[30] = 0x44747;
-		gp_coeff_2[31] = 0x5d5dd;
-		gp_coeff_2[32] = 0x5747b;
-		gp_coeff_2[33] = 0x77557;
-		gp_coeff_2[34] = 0xdcb2a;
-		gp_coeff_2[35] = 0xd5779;
-		gp_coeff_2[36] = 0x77777;
-		gp_cv_g1 = 0x72242f;
-		gp_cv_g2 = 0x28822a;
-	}
-
-	if ((Broadcast_Standard == AML_ATV_DEMOD_VIDEO_MODE_PROP_NTSC)  ||
-		(Broadcast_Standard == AML_ATV_DEMOD_VIDEO_MODE_PROP_NTSC_J)) {
-		sif_co_mx = 0xb8;
-		sif_fi_mx = 0x0;
-		sif_ic_bw = 0x1;
-		sif_bb_bw = 0x1;
-		sif_deemp = 0x1;
-		sif_cfg_demod = (sound_format == 0) ? 0x0:0x2;
-		sif_fm_gain = 0x4;
-	} else if ((Broadcast_Standard == AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_BG)
-	|| (Broadcast_Standard == AML_ATV_DEMOD_VIDEO_MODE_PROP_NTSC_BG)) {
-		sif_co_mx = 0xa6;
-		sif_fi_mx = 0x10;
-		sif_ic_bw = 0x2;
-		sif_bb_bw = 0x0;
-		sif_deemp = 0x2;
-		sif_cfg_demod = (sound_format == 0) ? 0x0:0x2;
-		sif_fm_gain = 0x3;
-	} else if (Broadcast_Standard ==
-		AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_DK1) {
-		sif_co_mx = 154;
-		sif_fi_mx = 240;
-		sif_ic_bw = 2;
-		sif_bb_bw = 0;
-		sif_deemp = 2;
-		sif_cfg_demod = (sound_format == 0) ? 0:2;
-		sif_fm_gain = 3;
-	} else if (Broadcast_Standard ==
-		AML_ATV_DEMOD_VIDEO_MODE_PROP_SECAM_DK2) {
-		sif_co_mx = 150;
-		sif_fi_mx = 16;
-		sif_ic_bw = 2;
-		sif_bb_bw = 0;
-		sif_deemp = 2;
-		sif_cfg_demod = (sound_format == 0) ? 0:2;
-		sif_fm_gain = 3;
-	} else if (Broadcast_Standard ==
-		AML_ATV_DEMOD_VIDEO_MODE_PROP_SECAM_DK3) {
-		sif_co_mx = 158;
-		sif_fi_mx = 208;
-		sif_ic_bw = 3;
-		sif_bb_bw = 0;
-		sif_deemp = 2;
-		sif_cfg_demod = (sound_format == 0) ? 0:2;
-		sif_fm_gain = 3;
-	} else if ((Broadcast_Standard == AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_I)
-	|| (Broadcast_Standard == AML_ATV_DEMOD_VIDEO_MODE_PROP_NTSC_I)) {
-		sif_co_mx = 153;
-		sif_fi_mx = 56;
-		sif_ic_bw = 3;
-		sif_bb_bw = 0;
-		sif_deemp = 2;
-		sif_cfg_demod = (sound_format == 0) ? 0:2;
-		sif_fm_gain = 3;
-	} else if (Broadcast_Standard ==
-		AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_BG_NICAM) {
-		sif_co_mx = 163;
-		sif_fi_mx = 40;
-		sif_ic_bw = 0;
-		sif_bb_bw = 0;
-		sif_deemp = 2;
-		sif_cfg_demod = (sound_format == 0) ? 0:2;
-		sif_fm_gain = 3;
-	} else if (Broadcast_Standard ==
-		AML_ATV_DEMOD_VIDEO_MODE_PROP_SECAM_L) {
-		sif_co_mx = 159;
-		sif_fi_mx = 200;
-		sif_ic_bw = 3;
-		sif_bb_bw = 0;
-		sif_deemp = 0;
-		sif_cfg_demod = (sound_format == 0) ? 1:2;
-		sif_fm_gain = 5;
-	} else if ((Broadcast_Standard == AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_DK)
-	|| (Broadcast_Standard == AML_ATV_DEMOD_VIDEO_MODE_PROP_NTSC_DK)) {
-		sif_co_mx = 159;
-		sif_fi_mx = 200;
-		sif_ic_bw = 3;
-		sif_bb_bw = 0;
-		sif_deemp = 2;
-		sif_cfg_demod = (sound_format == 0) ? 0:2;
-		sif_fm_gain = 3;
-	} else if (Broadcast_Standard == AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_M) {
-		sif_co_mx = 182;
-		sif_fi_mx = 16;
-		sif_ic_bw = 1;
-		sif_bb_bw = 0;
-		sif_deemp = 1;
-		sif_cfg_demod = (sound_format == 0) ? 0:2;
-		sif_fm_gain = 3;
-	}
-	sif_fm_gain -= 2;	/*avoid sound overflow@guanzhong*/
-	/*FE PATH*/
-	pr_info("ATV-DMD configure mixer\n");
-	if (Broadcast_Standard == AML_ATV_DEMOD_VIDEO_MODE_PROP_DTV) {
-		tmp_int = (Tuner_IF_Frequency/125000);
-		if (Tuner_Input_IF_inverted == 0x0)
-			mixer1 = -tmp_int;
-		else
-			mixer1 = tmp_int;
-
-		mixer3 = 0;
-		mixer3_bypass = 0;
-	} else {
-		tmp_int = (Tuner_IF_Frequency/125000);
-		pr_info("ATV-DMD configure mixer 1\n");
-
-		if (Tuner_Input_IF_inverted == 0x0)
-			mixer1 = 0xe8 - tmp_int;
-		else
-			mixer1 = tmp_int - 0x18;
-
-		pr_info("ATV-DMD configure mixer 2\n");
-		mixer3 = 0x30;
-		mixer3_bypass = 0x1;
-	}
-
-	pr_info("ATV-DMD configure mixer 3\n");
-	atv_dmd_wr_byte(APB_BLOCK_ADDR_MIXER_1, 0x0, mixer1);
-	atv_dmd_wr_word(APB_BLOCK_ADDR_MIXER_3, 0x0,
-			(((mixer3 & 0xff) << 8) | (mixer3_bypass & 0xff)));
-
-	if (Broadcast_Standard == AML_ATV_DEMOD_VIDEO_MODE_PROP_SECAM_L)
-		atv_dmd_wr_long(APB_BLOCK_ADDR_ADC_SE, 0x0, 0x03180e0f);
-	else
-		atv_dmd_wr_long(APB_BLOCK_ADDR_ADC_SE, 0x0, 0x03150e0f);
-	if (amlatvdemod_devp->parm.tuner_id == AM_TUNER_R840) {
-		/*config pwm for tuner r840*/
-		atv_dmd_wr_byte(APB_BLOCK_ADDR_ADC_SE, 1, 0xf);
-	}
-
-	/*GP Filter*/
-	pr_info("ATV-DMD configure GP_filter\n");
-	if (Broadcast_Standard == AML_ATV_DEMOD_VIDEO_MODE_PROP_DTV) {
-		cv = gp_cv_g1;
-		atv_dmd_wr_long(APB_BLOCK_ADDR_GP_VD_FLT, 0x0,
-				(0x08000000 | (cv & 0x7fffff)));
-		atv_dmd_wr_byte(APB_BLOCK_ADDR_GP_VD_FLT, 0x4, 0x04);
-		for (i = 0; i < 9; i = i + 1) {
-			/*super_coef = {gp_coeff_1[i*4],gp_coeff_1[i*4+1],
-			gp_coeff_1[i*4+2],gp_coeff_1[i*4+3]};*/
-			super_coef0 =
-			    (((gp_coeff_1[i * 4 + 2] & 0xfff) << 20) |
-			     (gp_coeff_1[i * 4 + 3] & 0xfffff));
-			super_coef1 =
-			    (((gp_coeff_1[i * 4] & 0xf) << 28) |
-			     ((gp_coeff_1[i * 4 + 1] & 0xfffff) << 8) |
-			     ((gp_coeff_1[i * 4 + 2] >> 12) & 0xff));
-			super_coef2 = ((gp_coeff_1[i * 4] >> 4) & 0xffff);
-
-			/*atv_dmd_wr_long(APB_BLOCK_ADDR_GP_VD_FLT,
-			0x8,super_coef[79:48]);*/
-			/*atv_dmd_wr_long(APB_BLOCK_ADDR_GP_VD_FLT,
-			0xC,super_coef[47:16]);*/
-			/*atv_dmd_wr_word(APB_BLOCK_ADDR_GP_VD_FLT,
-			0x10,super_coef[15:0]);*/
-			atv_dmd_wr_long(APB_BLOCK_ADDR_GP_VD_FLT, 0x8,
-					(((super_coef2 & 0xffff) << 16) |
-					 ((super_coef1 & 0xffff0000) >> 16)));
-			atv_dmd_wr_long(APB_BLOCK_ADDR_GP_VD_FLT, 0xC,
-					(((super_coef1 & 0xffff) << 16) |
-					 ((super_coef0 & 0xffff0000) >> 16)));
-			atv_dmd_wr_word(APB_BLOCK_ADDR_GP_VD_FLT, 0x10,
-					(super_coef0 & 0xffff));
-			atv_dmd_wr_byte(APB_BLOCK_ADDR_GP_VD_FLT, 0x05, i);
-		}
-		/*atv_dmd_wr_long
-		(APB_BLOCK_ADDR_GP_VD_FLT,0x8,{gp_coeff_1[36],12'd0});*/
-		atv_dmd_wr_long(APB_BLOCK_ADDR_GP_VD_FLT, 0x8,
-				((gp_coeff_1[36] & 0xfffff) << 12));
-		atv_dmd_wr_byte(APB_BLOCK_ADDR_GP_VD_FLT, 0x05, 0x09);
-
-	} else {
-		cv = gp_cv_g1 - gp_cv_g2;
-		atv_dmd_wr_long(APB_BLOCK_ADDR_GP_VD_FLT, 0x0, cv & 0x7fffff);
-		atv_dmd_wr_byte(APB_BLOCK_ADDR_GP_VD_FLT, 0x4, 0x00);
-		for (i = 0; i < 9; i = i + 1) {
-			/*super_coef = {gp_coeff_1[i*4],gp_coeff_1[i*4+1],
-			gp_coeff_1[i*4+2],gp_coeff_1[i*4+3]};*/
-			super_coef0 =
-			    (((gp_coeff_1[i * 4 + 2] & 0xfff) << 20) |
-			     (gp_coeff_1[i * 4 + 3] & 0xfffff));
-			super_coef1 =
-			    (((gp_coeff_1[i * 4] & 0xf) << 28) |
-			     ((gp_coeff_1[i * 4 + 1] & 0xfffff) << 8) |
-			     ((gp_coeff_1[i * 4 + 2] >> 12) & 0xff));
-			super_coef2 = ((gp_coeff_1[i * 4] >> 4) & 0xffff);
-
-			/*atv_dmd_wr_long(APB_BLOCK_ADDR_GP_VD_FLT,
-			0x8,super_coef[79:48]);*/
-			/*atv_dmd_wr_long(APB_BLOCK_ADDR_GP_VD_FLT,
-			0xC,super_coef[47:16]);*/
-			/*atv_dmd_wr_word(APB_BLOCK_ADDR_GP_VD_FLT,
-			0x10,super_coef[15:0]);*/
-			atv_dmd_wr_long(APB_BLOCK_ADDR_GP_VD_FLT, 0x8,
-					(((super_coef2 & 0xffff) << 16) |
-					 ((super_coef1 & 0xffff0000) >> 16)));
-			atv_dmd_wr_long(APB_BLOCK_ADDR_GP_VD_FLT, 0xC,
-					(((super_coef1 & 0xffff) << 16) |
-					 ((super_coef0 & 0xffff0000) >> 16)));
-			atv_dmd_wr_word(APB_BLOCK_ADDR_GP_VD_FLT, 0x10,
-					(super_coef0 & 0xffff));
-			atv_dmd_wr_byte(APB_BLOCK_ADDR_GP_VD_FLT, 0x05, i);
-
-			/*atv_dmd_wr_long(APB_BLOCK_ADDR_GP_VD_FLT,
-			0x8,{gp_coeff_1[36],12'd0});*/
-		}
-		atv_dmd_wr_long(APB_BLOCK_ADDR_GP_VD_FLT, 0x8,
-				((gp_coeff_1[36] & 0xfffff) << 12));
-		atv_dmd_wr_byte(APB_BLOCK_ADDR_GP_VD_FLT, 0x05, 9);
-		atv_dmd_wr_byte(APB_BLOCK_ADDR_GP_VD_FLT, 0x4, 0x01);
-
-		for (i = 0; i < 9; i = i + 1) {
-			/*super_coef = {gp_coeff_2[i*4],gp_coeff_2[i*4+1],
-			gp_coeff_2[i*4+2],gp_coeff_2[i*4+3]};*/
-			super_coef0 =
-			    (((gp_coeff_2[i * 4 + 2] & 0xfff) << 20) |
-			     (gp_coeff_2[i * 4 + 3] & 0xfffff));
-			super_coef1 =
-			    (((gp_coeff_2[i * 4] & 0xf) << 28) |
-			     ((gp_coeff_2[i * 4 + 1] & 0xfffff) << 8) |
-			     ((gp_coeff_2[i * 4 + 2] >> 12) & 0xff));
-			super_coef2 = ((gp_coeff_2[i * 4] >> 4) & 0xffff);
-
-			atv_dmd_wr_long(APB_BLOCK_ADDR_GP_VD_FLT, 0x8,
-					(((super_coef2 & 0xffff) << 16) |
-					 ((super_coef1 & 0xffff0000) >> 16)));
-			atv_dmd_wr_long(APB_BLOCK_ADDR_GP_VD_FLT, 0xC,
-					(((super_coef1 & 0xffff) << 16) |
-					 ((super_coef0 & 0xffff0000) >> 16)));
-			atv_dmd_wr_word(APB_BLOCK_ADDR_GP_VD_FLT, 0x10,
-					(super_coef0 & 0xffff));
-			atv_dmd_wr_byte(APB_BLOCK_ADDR_GP_VD_FLT, 0x05, i);
-		}
-
-		atv_dmd_wr_long(APB_BLOCK_ADDR_GP_VD_FLT, 0x8,
-				((gp_coeff_2[36] & 0xfffff) << 12));
-		atv_dmd_wr_byte(APB_BLOCK_ADDR_GP_VD_FLT, 0x05, 0x09);
-	}
-
-	/*CRVY*/
-	pr_info("ATV-DMD configure CRVY\n");
-	if (Broadcast_Standard == AML_ATV_DEMOD_VIDEO_MODE_PROP_DTV) {
-		crvy_reg_1 = 0xFF;
-		crvy_reg_2 = 0x00;
-	} else {
-		crvy_reg_1 = 0x04;
-		crvy_reg_2 = 0x01;
-	}
-
-	atv_dmd_wr_byte(APB_BLOCK_ADDR_CARR_RCVY, 0x29, crvy_reg_1);
-	pr_info("ATV-DMD configure rcvy 2\n");
-	pr_info("ATV-DMD configure rcvy, crvy_reg_2 = %x\n", crvy_reg_2);
-	atv_dmd_wr_byte(APB_BLOCK_ADDR_CARR_RCVY, 0x20, crvy_reg_2);
-
-	/*SOUND SUPPRESS*/
-	pr_info("ATV-DMD configure sound suppress\n");
-
-	if ((Broadcast_Standard == AML_ATV_DEMOD_VIDEO_MODE_PROP_DTV) ||
-		(sound_format == 0))
-		atv_dmd_wr_byte(APB_BLOCK_ADDR_SIF_VD_IF, 0x02, 0x01);
-	else
-		atv_dmd_wr_byte(APB_BLOCK_ADDR_SIF_VD_IF, 0x02, 0x00);
-
-	/*SIF*/
-	pr_info("ATV-DMD configure sif\n");
-	if (!(Broadcast_Standard == AML_ATV_DEMOD_VIDEO_MODE_PROP_DTV)) {
-		atv_dmd_wr_byte(APB_BLOCK_ADDR_SIF_IC_STD, 0x03, sif_ic_bw);
-		atv_dmd_wr_byte(APB_BLOCK_ADDR_SIF_IC_STD, 0x01, sif_fi_mx);
-		atv_dmd_wr_byte(APB_BLOCK_ADDR_SIF_IC_STD, 0x02, sif_co_mx);
-
-		atv_dmd_wr_long(APB_BLOCK_ADDR_SIF_STG_2, 0x00,
-				(((sif_bb_bw & 0xff) << 24) |
-				 ((sif_deemp & 0xff) << 16) | 0x0500 |
-				 sif_fm_gain));
-		atv_dmd_wr_byte(APB_BLOCK_ADDR_SIF_STG_2, 0x06, sif_cfg_demod);
-	}
-
-	if (Broadcast_Standard != AML_ATV_DEMOD_VIDEO_MODE_PROP_DTV) {
-		if (sound_format == 0) {
-			tmp_int = 0;
-			atv_dmd_wr_long(APB_BLOCK_ADDR_SIF_STG_3, 0x00,
-					(0x01000000 | (tmp_int & 0xffffff)));
-		} else {
-			tmp_int = (256 - sif_co_mx) << 13;
-			atv_dmd_wr_long(APB_BLOCK_ADDR_SIF_STG_3, 0x00,
-					(tmp_int & 0xffffff));
-		}
-	}
-
-	if (Broadcast_Standard == AML_ATV_DEMOD_VIDEO_MODE_PROP_DTV) {
-		atv_dmd_wr_long(APB_BLOCK_ADDR_IC_AGC, 0x00, 0x02040E0A);
-		atv_dmd_wr_word(APB_BLOCK_ADDR_IC_AGC, 0x04, 0x0F0D);
-	} else if (sound_format == 0)
-		atv_dmd_wr_byte(APB_BLOCK_ADDR_IC_AGC, 0x00, 0x04);
-	else if (Broadcast_Standard ==
-		AML_ATV_DEMOD_VIDEO_MODE_PROP_SECAM_L) {
-		atv_dmd_wr_long(APB_BLOCK_ADDR_IC_AGC, 0x00, 0x0003140A);
-		atv_dmd_wr_word(APB_BLOCK_ADDR_IC_AGC, 0x04, 0x1244);
-	} else {
-		atv_dmd_wr_long(APB_BLOCK_ADDR_IC_AGC, 0x00, 0x00040E0A);
-		atv_dmd_wr_word(APB_BLOCK_ADDR_IC_AGC, 0x04, 0x0D68);
-	}
-
-	/*VAGC*/
-	pr_info("ATV-DMD configure vagc\n");
-	atv_dmd_wr_long(APB_BLOCK_ADDR_VDAGC, 0x48, 0x9B6F2C00);
-	/*bw select mode*/
-	atv_dmd_wr_byte(APB_BLOCK_ADDR_VDAGC, 0x37, 0x1C);
-	/*disable prefilter*/
-
-	if (Broadcast_Standard == AML_ATV_DEMOD_VIDEO_MODE_PROP_SECAM_L) {
-		atv_dmd_wr_word(APB_BLOCK_ADDR_VDAGC, 0x44, 0x4450);
-		atv_dmd_wr_byte(APB_BLOCK_ADDR_VDAGC, 0x46, 0x44);
-		atv_dmd_wr_long(APB_BLOCK_ADDR_VDAGC, 0x4, 0x3E04FC);
-		atv_dmd_wr_word(APB_BLOCK_ADDR_VDAGC, 0x3C, 0x4848);
-		atv_dmd_wr_byte(APB_BLOCK_ADDR_VDAGC, 0x3E, 0x48);
-	} else {
-		atv_dmd_wr_word(APB_BLOCK_ADDR_VDAGC, 0x44, 0xB800);
-		atv_dmd_wr_byte(APB_BLOCK_ADDR_VDAGC, 0x46, 0x08);
-		atv_dmd_wr_long(APB_BLOCK_ADDR_VDAGC, 0x4, 0x3C04FC);
-		atv_dmd_wr_word(APB_BLOCK_ADDR_VDAGC, 0x3C, 0x1818);
-		atv_dmd_wr_byte(APB_BLOCK_ADDR_VDAGC, 0x3E, 0x10);
-	}
-
-	/*tmp_real = $itor(Hz_Freq)/0.23841858; //TODO*/
-	/*tmp_int = $rtoi(tmp_real); //TODO*/
-	/*tmp_int = Hz_Freq/0.23841858; //TODO*/
-	/*tmp_int_2 = ((unsigned long)15625)*10000/23841858;*/
-	/*tmp_int_2 = ((unsigned long)Hz_Freq)*10000/23841858;*/
-	atv_dmd_wr_word(APB_BLOCK_ADDR_VDAGC, 0x10,
-			(freq_hz_cvrt >> 8) & 0xffff);
-	atv_dmd_wr_byte(APB_BLOCK_ADDR_VDAGC, 0x12, (freq_hz_cvrt & 0xff));
-
-	/*OUTPUT STAGE*/
-	pr_info("ATV-DMD configure output stage\n");
-	if (Broadcast_Standard != AML_ATV_DEMOD_VIDEO_MODE_PROP_DTV) {
-		atv_dmd_wr_byte(APB_BLOCK_ADDR_DAC_UPS, 0x0, 0x00);
-		atv_dmd_wr_byte(APB_BLOCK_ADDR_DAC_UPS, 0x1, 0x40);
-		atv_dmd_wr_byte(APB_BLOCK_ADDR_DAC_UPS, 0x2, 0x40);
-		atv_dmd_wr_byte(APB_BLOCK_ADDR_DAC_UPS, 0x4, 0xFA);
-		atv_dmd_wr_byte(APB_BLOCK_ADDR_DAC_UPS, 0x5, 0xFA);
-	}
-
-	/*GDE FILTER*/
-	pr_info("ATV-DMD configure gde filter\n");
-	if (GDE_Curve == 0) {
-		gd_coeff[0] = 0x020;	/*12'sd32;*/
-		gd_coeff[1] = 0xf5f;	/*-12'sd161;*/
-		gd_coeff[2] = 0x1fe;	/*12'sd510;*/
-		gd_coeff[3] = 0xc0b;	/*-12'sd1013;*/
-		gd_coeff[4] = 0x536;	/*12'sd1334;*/
-		gd_coeff[5] = 0xb34;	/*-12'sd1228;*/
-		gd_bypass = 0x1;
-	} else if (GDE_Curve == 1) {
-		gd_coeff[0] = 0x8;	/*12'sd8;*/
-		gd_coeff[1] = 0xfd5;	/*-12'sd43;*/
-		gd_coeff[2] = 0x8d;	/*12'sd141;*/
-		gd_coeff[3] = 0xe69;	/*-12'sd407;*/
-		gd_coeff[4] = 0x1f1;	/*12'sd497;*/
-		gd_coeff[5] = 0xe7e;	/*-12'sd386;*/
-		gd_bypass = 0x1;
-	} else if (GDE_Curve == 2) {
-		gd_coeff[0] = 0x35;	/*12'sd53;*/
-		gd_coeff[1] = 0xf41;	/*-12'sd191;*/
-		gd_coeff[2] = 0x68;	/*12'sd104;*/
-		gd_coeff[3] = 0xea5;	/*-12'sd347;*/
-		gd_coeff[4] = 0x322;	/*12'sd802;*/
-		gd_coeff[5] = 0x1bb;	/*12'sd443;*/
-		gd_bypass = 0x1;
-	} else if (GDE_Curve == 3) {
-		gd_coeff[0] = 0xf;	/*12'sd15;*/
-		gd_coeff[1] = 0xfb5;	/*-12'sd75;*/
-		gd_coeff[2] = 0xcc;	/*12'sd204;*/
-		gd_coeff[3] = 0xe51;
-		gd_coeff[4] = 0x226;	/*12'sd550;*/
-		gd_coeff[5] = 0xd02;
-		gd_bypass = 0x1;
-	} else
-		gd_bypass = 0x0;
-
-	if (gd_bypass == 0x0)
-		atv_dmd_wr_byte(APB_BLOCK_ADDR_GDE_EQUAL, 0x0D, gd_bypass);
-	else {
-		for (i = 0; i < 6; i = i + 1)
-			atv_dmd_wr_word(APB_BLOCK_ADDR_GDE_EQUAL, i << 1,
-					gd_coeff[i]);
-		atv_dmd_wr_byte(APB_BLOCK_ADDR_GDE_EQUAL, 0x0C, 0x01);
-		atv_dmd_wr_byte(APB_BLOCK_ADDR_GDE_EQUAL, 0x0D, gd_bypass);
-	}
-
-	/*PWM*/
-	pr_info("ATV-DMD configure pwm\n");
-	atv_dmd_wr_long(APB_BLOCK_ADDR_AGC_PWM, 0x00, 0x1f40);	/*4KHz*/
-	atv_dmd_wr_long(APB_BLOCK_ADDR_AGC_PWM, 0x04, 0xc8);
-	/*26 dB dynamic range*/
-	atv_dmd_wr_byte(APB_BLOCK_ADDR_AGC_PWM, 0x09, 0xa);
-	if (amlatvdemod_devp->parm.tuner_id == AM_TUNER_R840) {
-		/*config pwm for tuner r840*/
-		atv_dmd_wr_long(APB_BLOCK_ADDR_AGC_PWM, 0, 0xc80);
-		/* guanzhong for Tuner AGC shock */
-		atv_dmd_wr_long(APB_BLOCK_ADDR_AGC_PWM, 0x08, 0x46180200);
-		/* atv_dmd_wr_byte(APB_BLOCK_ADDR_ADC_SE,1,0xf);//Kd = 0xf */
-	}
-}
-
-void retrieve_adc_power(int *adc_level)
-{
-	*adc_level = atv_dmd_rd_long(APB_BLOCK_ADDR_ADC_SE, 0x0c);
-	/*adc_level = adc_level/32768*100;*/
-	*adc_level = (*adc_level) * 100 / 32768;
-}
-
-void retrieve_vpll_carrier_lock(int *lock)
-{
-	unsigned int data;
-	data = atv_dmd_rd_byte(APB_BLOCK_ADDR_CARR_RCVY, 0x43);
-	*lock = (data & 0x1);
-}
-int retrieve_vpll_carrier_afc(void)
-{
-	int data_ret, pll_lock, field_lock, line_lock, line_lock_strong;
-	unsigned int data_h, data_l, data_exg = 0;
-	pll_lock = atv_dmd_rd_byte(APB_BLOCK_ADDR_CARR_RCVY, 0x43)&0x1;
-	field_lock = atv_dmd_rd_byte(APB_BLOCK_ADDR_VDAGC, 0x4f)&0x4;
-	line_lock = atv_dmd_rd_byte(APB_BLOCK_ADDR_VDAGC, 0x4f)&0x10;
-	line_lock_strong = atv_dmd_rd_byte(APB_BLOCK_ADDR_VDAGC, 0x4f)&0x8;
-	/* if((atv_dmd_rd_byte(APB_BLOCK_ADDR_CARR_RCVY,0x43)&0x1) == 1){ */
-	if ((pll_lock == 1) || (line_lock == 0x10)) {
-		/*if pll unlock, afc is invalid*/
-		data_ret = 0xffff;/* 500; */
-		return data_ret;
-	}
-	data_h = atv_dmd_rd_byte(APB_BLOCK_ADDR_CARR_RCVY, 0x40);
-	data_l = atv_dmd_rd_byte(APB_BLOCK_ADDR_CARR_RCVY, 0x41);
-	data_exg = ((data_h&0x7) << 8) | data_l;
-	if (data_h&0x8) {
-		data_ret = (((~data_exg)&0x7ff) - 1);
-		data_ret = data_ret*488*(-1)/1000;
-	} else {
-		data_ret = data_exg;
-		data_ret = data_ret*488/1000;
-	}
-	if ((abs(data_ret) < 50) && (line_lock_strong == 0x8) &&
-		(field_lock == 0x4)) {
-		data_ret = 100;
-		return data_ret;
-	}
-	return data_ret;
-}
-void set_pll_lpf(unsigned int lock)
-{
-	atv_dmd_wr_byte(APB_BLOCK_ADDR_CARR_RCVY, 0x24, lock);
-}
-
-void retrieve_frequency_offset(int *freq_offset)
-{
-	/*unsigned int data;
-	data = atv_dmd_rd_word(APB_BLOCK_ADDR_CARR_RCVY,0x40);
-	*freq_offset = (int)data;*/
-	unsigned int data_h, data_l, data_exg;
-	int data_ret;
-	data_h = atv_dmd_rd_byte(APB_BLOCK_ADDR_CARR_RCVY, 0x40);
-	data_l = atv_dmd_rd_byte(APB_BLOCK_ADDR_CARR_RCVY, 0x41);
-	data_exg = ((data_h&0x7)<<8) | data_l;
-	if (data_h&0x8) {
-		data_ret = (((~data_exg) & 0x7ff)  - 1);
-		data_ret = data_ret*(-1);
-		/* data_ret = data_ret*488*(-1) /1000; */
-	} else
-		data_ret = data_exg;/* data_ret = data_ret*488/100; */
-	*freq_offset = data_ret;
-}
-EXPORT_SYMBOL(retrieve_frequency_offset);
-void retrieve_video_lock(int *lock)
-{
-	unsigned int data, wlock, slock;
-	data = atv_dmd_rd_byte(APB_BLOCK_ADDR_VDAGC, 0x4f);
-	wlock = data & 0x10;
-	slock = data & 0x80;
-	*lock = wlock & slock;
-}
-
-void retrieve_fh_frequency(int *fh)
-{
-	unsigned long data1, data2;
-	data1 = atv_dmd_rd_word(APB_BLOCK_ADDR_VDAGC, 0x58);
-	data2 = atv_dmd_rd_long(APB_BLOCK_ADDR_VDAGC, 0x10);
-	data1 = data1 >> 11;
-	data2 = data2 >> 3;
-	*fh = data1 + data2;
-}
-/*tune mix to adapt afc*/
-void atvdemod_afc_tune(void)
-{
-	/* int adc_level,lock,freq_offset,fh; */
-	int freq_offset, lock, mix1_freq_cur, delta_mix1_freq;
-
-	/* retrieve_adc_power(&adc_level); */
-	/* pr_info("adc_level: 0x%x\n",adc_level); */
-	retrieve_vpll_carrier_lock(&lock);
-	mix1_freq_cur = atv_dmd_rd_byte(APB_BLOCK_ADDR_MIXER_1, 0x0);
-	delta_mix1_freq = abs(mix1_freq_cur - mix1_freq);
-	if ((lock&0x1) == 0)
-		pr_info("%s visual carrier lock:locked\n", __func__);
-	else
-		pr_info("%s visual carrier lock:unlocked\n", __func__);
-	/* set_pll_lpf(lock); */
-	retrieve_frequency_offset(&freq_offset);
-	freq_offset = freq_offset*488/1000;
-	/* pr_info("visual carrier offset:%d Hz\n",
-	freq_offset*48828125/100000); */
-	/* retrieve_video_lock(&lock); */
-	if ((lock&0x1) == 1) {
-		if (delta_mix1_freq == atvdemod_afc_range)
-			atv_dmd_wr_byte(APB_BLOCK_ADDR_MIXER_1, 0x0, mix1_freq);
-		else if ((freq_offset >= atvdemod_afc_offset) &&
-			(delta_mix1_freq < atvdemod_afc_range))
-			atv_dmd_wr_byte(APB_BLOCK_ADDR_MIXER_1, 0x0,
-				mix1_freq_cur-1);
-		else if ((freq_offset <= (-1)*atvdemod_afc_offset) &&
-			(delta_mix1_freq < atvdemod_afc_range-1))
-			atv_dmd_wr_byte(APB_BLOCK_ADDR_MIXER_1, 0x0,
-				mix1_freq_cur+1);
-		/* pr_info("video lock:locked\n"); */
-	}
-	/* retrieve_fh_frequency(&fh); */
-	/* pr_info("horizontal frequency:%d Hz\n",fh*190735/100000); */
-}
-static enum amlatvdemod_snr_level_e aml_atvdemod_get_snr_level(void)
-{
-	unsigned int snr_val, i, snr_d[8];
-	enum amlatvdemod_snr_level_e ret;
-	unsigned long fsnr;
-	snr_val = atv_dmd_rd_long(APB_BLOCK_ADDR_VDAGC, 0x50)>>8;
-	fsnr = snr_val;
-	for (i = 1; i < 8; i++) {
-		snr_d[i] = snr_d[i-1];
-		fsnr = fsnr + snr_d[i];
-	}
-	snr_d[0] = snr_val;
-	fsnr = fsnr >> 3;
-	if (fsnr < 316)
-		ret = high;
-	else if (fsnr < 31600)
-		ret = ok_plus;
-	else if (fsnr < 158000)
-		ret = ok_minus;
-	else if (fsnr < 700000)
-		ret = low;
-	else
-		ret = very_low;
-	return ret;
-}
-
-void atvdemod_monitor_serice(void)
-{
-	enum amlatvdemod_snr_level_e snr_level;
-	unsigned int vagc_bw_typ, vagc_bw_fast, vpll_kptrack, vpll_kitrack;
-	unsigned int agc_register, vfmat_reg, agc_pll_kptrack, agc_pll_kitrack;
-	/*1.get current snr*/
-	snr_level = aml_atvdemod_get_snr_level();
-	/*2.*/
-	if (snr_level > very_low) {
-		vagc_bw_typ = 0x1818;
-		vagc_bw_fast = (snr_level == low) ? 0x18:0x10;
-		vpll_kptrack = 0x05;
-		vpll_kitrack = 0x0c;
-		agc_pll_kptrack = 0x6;
-		agc_pll_kitrack = 0xc;
-	} else {
-		vagc_bw_typ = 0x6f6f;
-		vagc_bw_fast = 0x6f;
-		vpll_kptrack = 0x06;
-		vpll_kitrack = 0x0e;
-		agc_pll_kptrack = 0x8;
-		agc_pll_kitrack = 0xf;
-	}
-	atv_dmd_wr_word(APB_BLOCK_ADDR_VDAGC, 0x3c, vagc_bw_typ);
-	atv_dmd_wr_byte(APB_BLOCK_ADDR_VDAGC, 0x3e, vagc_bw_fast);
-	atv_dmd_wr_byte(APB_BLOCK_ADDR_CARR_RCVY, 0x23, vpll_kptrack);
-	atv_dmd_wr_byte(APB_BLOCK_ADDR_CARR_RCVY, 0x24, vpll_kitrack);
-	atv_dmd_wr_byte(APB_BLOCK_ADDR_VDAGC, 0x0c,
-		((atv_dmd_rd_byte(APB_BLOCK_ADDR_VDAGC, 0x0c) & 0xf0)|
-		agc_pll_kptrack));
-	atv_dmd_wr_byte(APB_BLOCK_ADDR_VDAGC, 0x0d,
-		((atv_dmd_rd_byte(APB_BLOCK_ADDR_VDAGC, 0x0d) & 0xf0)|
-		agc_pll_kitrack));
-	/*3.*/
-	agc_register = atv_dmd_rd_long(APB_BLOCK_ADDR_VDAGC, 0x28);
-	if (snr_level < low) {
-		agc_register = ((agc_register&0xff80fe03) | (25 << 16) |
-			(15 << 2));
-		atv_dmd_wr_long(APB_BLOCK_ADDR_VDAGC, 0x28, agc_register);
-	} else if (snr_level > low) {
-		agc_register = ((agc_register&0xff80fe03) | (38 << 16) |
-			(30 << 2));
-		atv_dmd_wr_long(APB_BLOCK_ADDR_VDAGC, 0x28, agc_register);
-	}
-	/*4.*/
-	if (snr_level < ok_minus)
-		atv_dmd_wr_byte(APB_BLOCK_ADDR_VDAGC, 0x47,
-			(atv_dmd_rd_byte(APB_BLOCK_ADDR_VDAGC, 0x47) & 0x7f));
-	else
-		atv_dmd_wr_byte(APB_BLOCK_ADDR_VDAGC, 0x47,
-			(atv_dmd_rd_byte(APB_BLOCK_ADDR_VDAGC, 0x47) | 0x80));
-	/*5.vformat*/
-	if (snr_level < ok_minus) {
-		if (atv_dmd_rd_byte(APB_BLOCK_ADDR_VFORMAT, 0xe) != 0xf)
-			atv_dmd_wr_byte(APB_BLOCK_ADDR_VFORMAT, 0xe, 0xf);
-	} else if (snr_level > ok_minus) {
-		vfmat_reg = atv_dmd_rd_word(APB_BLOCK_ADDR_VFORMAT, 0x16);
-		if ((vfmat_reg << 4) < 0xf000) {
-			if (atv_dmd_rd_byte(APB_BLOCK_ADDR_VFORMAT, 0xe) ==
-				0x0f)
-				atv_dmd_wr_byte(APB_BLOCK_ADDR_VFORMAT, 0xe,
-					0x6);
-			else
-				atv_dmd_wr_byte(APB_BLOCK_ADDR_VFORMAT, 0xe,
-					0x6);
-		}
-	} else {
-		if (atv_dmd_rd_byte(APB_BLOCK_ADDR_VFORMAT, 0xe) == 0x0f)
-			atv_dmd_wr_byte(APB_BLOCK_ADDR_VFORMAT, 0xe, 0xe);
-		else
-			atv_dmd_wr_byte(APB_BLOCK_ADDR_VFORMAT, 0xe, 0xe);
-	}
-}
-
-static int atvdemod_get_snr(struct dvb_frontend *fe)
-{
-	unsigned int snr_val = 0;
-	int ret = 0;
-	snr_val = atv_dmd_rd_long(APB_BLOCK_ADDR_VDAGC, 0x50) >> 8;
-	/* snr_val:900000~0xffffff,ret:5~15 */
-	if (snr_val > 900000)
-		ret = 15 - (snr_val - 900000)*10/(0xffffff - 900000);
-	/* snr_val:158000~900000,ret:15~30 */
-	else if (snr_val > 158000)
-		ret = 30 - (snr_val - 158000)*15/(900000 - 158000);
-	/* snr_val:31600~158000,ret:30~50 */
-	else if (snr_val > 31600)
-		ret = 50 - (snr_val - 31600)*20/(158000 - 31600);
-	/* snr_val:316~31600,ret:50~80 */
-	else if (snr_val > 316)
-		ret = 80 - (snr_val - 316)*30/(31600 - 316);
-	/* snr_val:0~316,ret:80~100 */
-	else
-		ret = 100 - (316 - snr_val)*20/316;
-	return ret;
-}
-
-void atvdemod_det_snr_serice(void)
-{
-	snr_val = atvdemod_get_snr(NULL);
-}
-
-void atvdemod_timer_hander(unsigned long arg)
-{
-	if (atvdemod_timer_en == 0)
-		return;
-	atvdemod_timer.expires = jiffies + ATVDEMOD_INTERVAL*10;/*100ms timer*/
-	add_timer(&atvdemod_timer);
-	if (atvdemod_afc_en)
-		atvdemod_afc_tune();
-	if (atvdemod_monitor_en)
-		atvdemod_monitor_serice();
-	if (audio_det_en)
-		aml_atvdemod_overmodule_det();
-	if (atvdemod_det_snr_en)
-		atvdemod_det_snr_serice();
-}
-
-int atvdemod_clk_init(void)
-{
-	/* clocks_set_hdtv (); */
-	/* 1.set system clock */
-#if 0 /* now set pll in tvafe_general.c */
-	if (is_meson_txl_cpu()) {
-		amlatvdemod_hiu_reg_write(HHI_VDAC_CNTL0, 0x6e0201);
-		amlatvdemod_hiu_reg_write(HHI_VDAC_CNTL1, 0x8);
-		/* for TXL(T962)  */
-		pr_err("%s in TXL\n", __func__);
-
-		/* W_HIU_REG(HHI_ADC_PLL_CNTL,  0x30c54260); */
-	#if 0
-		W_HIU_REG(HHI_ADC_PLL_CNTL,  0x30f14250);
-		W_HIU_REG(HHI_ADC_PLL_CNTL1, 0x22000442);
-		W_HIU_REG(HHI_ADC_PLL_CNTL2, 0x5ba00380);
-		W_HIU_REG(HHI_ADC_PLL_CNTL3, 0xac6a2114);
-		W_HIU_REG(HHI_ADC_PLL_CNTL4, 0x02953004);
-		W_HIU_REG(HHI_ADC_PLL_CNTL5, 0x00030a00);
-		W_HIU_REG(HHI_ADC_PLL_CNTL6, 0x00005000);
-		W_HIU_REG(HHI_ADC_PLL_CNTL3, 0x2c6a2114);
-	#else /* get from feijun 2015/07/19 */
-		W_HIU_REG(HHI_ADC_PLL_CNTL3, 0x4a6a2110);
-		W_HIU_REG(HHI_ADC_PLL_CNTL, 0x30f14250);
-		W_HIU_REG(HHI_ADC_PLL_CNTL1, 0x22000442);
-		/*0x5ba00380 from pll;0x5ba00384 clk
-		form crystal*/
-		W_HIU_REG(HHI_ADC_PLL_CNTL2, 0x5ba00384);
-		W_HIU_REG(HHI_ADC_PLL_CNTL3, 0x4a6a2110);
-		W_HIU_REG(HHI_ADC_PLL_CNTL4, 0x02913004);
-		W_HIU_REG(HHI_ADC_PLL_CNTL5, 0x00034a00);
-		W_HIU_REG(HHI_ADC_PLL_CNTL6, 0x00005000);
-		W_HIU_REG(HHI_ADC_PLL_CNTL3, 0xca6a2110);
-		W_HIU_REG(HHI_ADC_PLL_CNTL3, 0x4a6a2110);
-	#endif
-		W_HIU_REG(HHI_DADC_CNTL,  0x00102038);
-		W_HIU_REG(HHI_DADC_CNTL2, 0x00000406);
-		W_HIU_REG(HHI_DADC_CNTL3, 0x00082183);
-
-	} else {
-		W_HIU_REG(HHI_ADC_PLL_CNTL3, 0xca2a2110);
-		W_HIU_REG(HHI_ADC_PLL_CNTL4, 0x2933800);
-		W_HIU_REG(HHI_ADC_PLL_CNTL, 0xe0644220);
-		W_HIU_REG(HHI_ADC_PLL_CNTL2, 0x34e0bf84);
-		W_HIU_REG(HHI_ADC_PLL_CNTL3, 0x4a2a2110);
-
-		W_HIU_REG(HHI_ATV_DMD_SYS_CLK_CNTL, 0x80);
-		/* TVFE reset */
-		W_HIU_BIT(RESET1_REGISTER, 1, 7, 1);
-	}
-#endif
-	W_HIU_REG(HHI_ATV_DMD_SYS_CLK_CNTL, 0x80);
-
-	/* read_version_register(); */
-
-	/*2.set atv demod top page control register*/
-	atv_dmd_input_clk_32m();
-	atv_dmd_wr_long(APB_BLOCK_ADDR_TOP, ATV_DMD_TOP_CTRL, 0x1037);
-	atv_dmd_wr_long(APB_BLOCK_ADDR_TOP, (ATV_DMD_TOP_CTRL1 << 2), 0x1f);
-
-	/*3.configure atv demod*/
-	check_communication_interface();
-	power_on_receiver();
-	pr_err("%s done\n", __func__);
-
-	return 0;
-}
-
-int atvdemod_init(void)
-{
-	/* unsigned long data32; */
-	if (atvdemod_timer_en == 1) {
-		if (timer_init_flag == 1) {
-			del_timer_sync(&atvdemod_timer);
-			timer_init_flag = 0;
-		}
-	}
-
-	/* 1.set system clock when atv enter*/
-
-	configure_receiver(broad_std, if_freq, if_inv, gde_curve, sound_format);
-	atv_dmd_misc();
-	/*4.software reset*/
-	atv_dmd_soft_reset();
-	atv_dmd_soft_reset();
-	atv_dmd_soft_reset();
-	atv_dmd_soft_reset();
-
-	/* ?????
-	while (!all_lock) {
-		data32 = atv_dmd_rd_long(APB_BLOCK_ADDR_VDAGC,0x13<<2);
-		if ((data32 & 0x1c) == 0x0) {
-			all_lock = 1;
-		}
-		delay_us(400);
-	}*/
-	#if 1/* temp mark */
-	if (atvdemod_timer_en == 1) {
-		/*atvdemod timer hander*/
-		init_timer(&atvdemod_timer);
-		/* atvdemod_timer.data = (ulong) devp; */
-		atvdemod_timer.function = atvdemod_timer_hander;
-		/* after 3s enable demod auto detect */
-		atvdemod_timer.expires = jiffies + ATVDEMOD_INTERVAL*300;
-		add_timer(&atvdemod_timer);
-		mix1_freq = atv_dmd_rd_byte(APB_BLOCK_ADDR_MIXER_1, 0x0);
-		timer_init_flag = 1;
-	}
-	#endif
-	pr_info("delay done\n");
-	return 0;
-}
-void atvdemod_uninit(void)
-{
-	/* del the timer */
-	if (atvdemod_timer_en == 1) {
-		if (timer_init_flag == 1) {
-			del_timer_sync(&atvdemod_timer);
-			timer_init_flag = 0;
-		}
-	}
-}
-
-void atv_dmd_set_std(void)
-{
-	v4l2_std_id ptstd = amlatvdemod_devp->parm.std;
-	/* set broad standard of tuner*/
-	if ((ptstd & V4L2_COLOR_STD_PAL) && ((ptstd & V4L2_STD_B) ||
-		(ptstd & V4L2_STD_G))) {
-		amlatvdemod_devp->fre_offset = 2250000;
-		freq_hz_cvrt = AML_ATV_DEMOD_FREQ_50HZ_VERT;
-		broad_std = AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_BG;
-		if_freq = 3250000;
-		gde_curve = 2;
-	} else if ((ptstd & V4L2_COLOR_STD_PAL) && (ptstd & V4L2_STD_DK)) {
-		amlatvdemod_devp->fre_offset = 2250000;
-		freq_hz_cvrt = AML_ATV_DEMOD_FREQ_50HZ_VERT;
-		if_freq = 3250000;
-		broad_std = AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_DK;
-		gde_curve = 3;
-	} else if ((ptstd & V4L2_COLOR_STD_PAL) && (ptstd & V4L2_STD_PAL_M)) {
-		amlatvdemod_devp->fre_offset = 2250000;
-		freq_hz_cvrt = AML_ATV_DEMOD_FREQ_60HZ_VERT;
-		broad_std = AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_M;
-		if_freq = 4250000;
-		gde_curve = 0;
-	} else if ((ptstd & V4L2_COLOR_STD_NTSC) && (ptstd & V4L2_STD_NTSC_M)) {
-		amlatvdemod_devp->fre_offset = 1750000;
-		freq_hz_cvrt = AML_ATV_DEMOD_FREQ_60HZ_VERT;
-		if_freq = 4250000;
-		broad_std = AML_ATV_DEMOD_VIDEO_MODE_PROP_NTSC;
-		gde_curve = 0;
-	} else if ((ptstd & V4L2_COLOR_STD_NTSC) && (ptstd & V4L2_STD_DK)) {
-		amlatvdemod_devp->fre_offset = 1750000;
-		freq_hz_cvrt = AML_ATV_DEMOD_FREQ_60HZ_VERT;
-		if_freq = 4250000;
-		broad_std = AML_ATV_DEMOD_VIDEO_MODE_PROP_NTSC_DK;
-		gde_curve = 0;
-	} else if ((ptstd & V4L2_COLOR_STD_NTSC) && (ptstd & V4L2_STD_BG)) {
-		amlatvdemod_devp->fre_offset = 1750000;
-		freq_hz_cvrt = AML_ATV_DEMOD_FREQ_60HZ_VERT;
-		if_freq = 4250000;
-		broad_std = AML_ATV_DEMOD_VIDEO_MODE_PROP_NTSC_BG;
-		gde_curve = 0;
-	} else if ((ptstd & V4L2_COLOR_STD_NTSC) && (ptstd & V4L2_STD_PAL_I)) {
-		amlatvdemod_devp->fre_offset = 1750000;
-		freq_hz_cvrt = AML_ATV_DEMOD_FREQ_60HZ_VERT;
-		if_freq = 4250000;
-		broad_std = AML_ATV_DEMOD_VIDEO_MODE_PROP_NTSC_I;
-		gde_curve = 0;
-	} else if ((ptstd & V4L2_COLOR_STD_NTSC) &&
-		(ptstd & V4L2_STD_NTSC_M_JP)) {
-		amlatvdemod_devp->fre_offset = 1750000;
-		freq_hz_cvrt = AML_ATV_DEMOD_FREQ_50HZ_VERT;
-		broad_std = AML_ATV_DEMOD_VIDEO_MODE_PROP_NTSC_J;
-		if_freq = 4250000;
-		gde_curve = 0;
-	} else if ((ptstd & V4L2_COLOR_STD_PAL) && (ptstd & V4L2_STD_PAL_I)) {
-		amlatvdemod_devp->fre_offset = 2750000;
-		freq_hz_cvrt = AML_ATV_DEMOD_FREQ_50HZ_VERT;
-		broad_std = AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_I;
-		if_freq = 3250000;
-		gde_curve = 4;
-	} else if (ptstd & (V4L2_STD_SECAM_L | V4L2_STD_SECAM_LC)) {
-		amlatvdemod_devp->fre_offset = 2750000;
-		freq_hz_cvrt = AML_ATV_DEMOD_FREQ_50HZ_VERT;
-		broad_std = AML_ATV_DEMOD_VIDEO_MODE_PROP_SECAM_L;
-		gde_curve = 4;
-	}
-	if (amlatvdemod_devp->parm.tuner_id == AM_TUNER_R840) {
-		if_freq = amlatvdemod_devp->parm.if_freq;
-		if_inv = amlatvdemod_devp->parm.if_inv;
-	} else if (amlatvdemod_devp->parm.tuner_id == AM_TUNER_MXL661) {
-		if_freq = amlatvdemod_devp->parm.if_freq;
-		if_inv = amlatvdemod_devp->parm.if_inv;
-	} else if (amlatvdemod_devp->parm.tuner_id == AM_TUNER_SI2151) {
-		if_freq = amlatvdemod_devp->parm.if_freq;
-		if_inv = amlatvdemod_devp->parm.if_inv;
-	}
-	pr_info
-	    ("[atvdemod..]%s: broad_std %d,freq_hz_cvrt:0x%x,fre_offset:%d.\n",
-	     __func__, broad_std, freq_hz_cvrt, amlatvdemod_devp->fre_offset);
-	if (atvdemod_init())
-		pr_info("[atvdemod..]%s: atv restart error.\n", __func__);
-}
-
-int aml_audiomode_autodet(struct dvb_frontend *fe)
-{
-	unsigned long carrier_power = 0;
-	unsigned long carrier_power_max = 0;
-	unsigned long carrier_power_average_max = 0;
-	unsigned long carrier_power_average[4] = {0};
-	unsigned long reg_addr = 0x03 , temp_data;
-	int carrier_lock_count = 0;
-	int lock = 0;
-	int broad_std_final = 0;
-	int num = 0, i = 0, final_id = 0;
-	int delay_ms = 10, delay_ms_default = 10;
-	int cur_std = ID_PAL_DK;
-	struct dtv_frontend_properties
-		*p = fe != NULL ? &fe->dtv_property_cache:NULL;
-#if 0
-	temp_data = atv_dmd_rd_reg(APB_BLOCK_ADDR_SIF_STG_2, 0x02);
-	temp_data = temp_data | 0x80;/* 0x40 */
-	atv_dmd_wr_reg(APB_BLOCK_ADDR_SIF_STG_2, 0x02, temp_data);
-#endif
-
-	switch (broad_std) {
-	case AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_DK:
-	case AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_I:
-	case AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_BG:
-	case AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_M:
-		broad_std = AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_M;
-		break;
-	case AML_ATV_DEMOD_VIDEO_MODE_PROP_NTSC_DK:
-	case AML_ATV_DEMOD_VIDEO_MODE_PROP_NTSC_I:
-	case AML_ATV_DEMOD_VIDEO_MODE_PROP_NTSC_BG:
-	case AML_ATV_DEMOD_VIDEO_MODE_PROP_NTSC_M:
-	case AML_ATV_DEMOD_VIDEO_MODE_PROP_NTSC:
-
-		broad_std = AML_ATV_DEMOD_VIDEO_MODE_PROP_NTSC_M;
-		atvdemod_init();
-		temp_data = atv_dmd_rd_reg(APB_BLOCK_ADDR_SIF_STG_2, 0x02);
-		temp_data = temp_data & (~0x80); /* 0xbf; */
-		atv_dmd_wr_reg(APB_BLOCK_ADDR_SIF_STG_2, 0x02, temp_data);
-		/* pr_err("%s, SECAM ,audio set SECAM_L\n", __func__); */
-		return broad_std;
-
-	case AML_ATV_DEMOD_VIDEO_MODE_PROP_SECAM_L:
-	case AML_ATV_DEMOD_VIDEO_MODE_PROP_SECAM_DK2:
-	case AML_ATV_DEMOD_VIDEO_MODE_PROP_SECAM_DK3:
-		broad_std = AML_ATV_DEMOD_VIDEO_MODE_PROP_SECAM_L;
-		atvdemod_init();
-		temp_data = atv_dmd_rd_reg(APB_BLOCK_ADDR_SIF_STG_2, 0x02);
-
-		temp_data = temp_data & (~0x80); /* 0xbf; */
-
-		atv_dmd_wr_reg(APB_BLOCK_ADDR_SIF_STG_2, 0x02, temp_data);
-		/* pr_err("%s, SECAM ,audio set SECAM_L\n", __func__); */
-		return broad_std;
-	default:
-		pr_err("unsupport broadcast_standard!!!\n");
-		temp_data = atv_dmd_rd_reg(APB_BLOCK_ADDR_SIF_STG_2, 0x02);
-		temp_data = temp_data & (~0x80); /* 0xbf; */
-		atv_dmd_wr_reg(APB_BLOCK_ADDR_SIF_STG_2, 0x02, temp_data);
-		return broad_std;
-	}
-	/* ----------------read carrier_power--------------------- */
-	/* SIF_STG_2[0x09],address 0x03 */
-	while (1) {
-		if (num >= 4) {
-			temp_data =
-				atv_dmd_rd_reg(APB_BLOCK_ADDR_SIF_STG_2, 0x02);
-			temp_data = temp_data & (~0x80);
-			atv_dmd_wr_reg(APB_BLOCK_ADDR_SIF_STG_2, 0x02,
-					temp_data);
-			carrier_power_max = carrier_power_average[0];
-			for (i = 0; i < ID_MAX; i++) {
-				if (carrier_power_max
-					< carrier_power_average[i]) {
-					carrier_power_max =
-						carrier_power_average[i];
-					final_id = i;
-				}
-			}
-			switch (final_id) {
-			case ID_PAL_I:
-				broad_std_final =
-					AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_I;
-				break;
-			case ID_PAL_BG:
-				broad_std_final =
-					AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_BG;
-				break;
-			case ID_PAL_M:
-				broad_std_final =
-					AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_M;
-				break;
-			case ID_PAL_DK:
-				broad_std_final =
-					AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_DK;
-				break;
-			}
-			carrier_power_average_max = carrier_power_max;
-			broad_std = broad_std_final;
-			pr_err("%s:broad_std:%d,carrier_power_average_max:%lu\n",
-				__func__, broad_std, carrier_power_average_max);
-			if (carrier_power_average_max < 150)
-				pr_err("%s,carrier too low error\n", __func__);
-			if (broad_std == AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_M) {
-				/*the max except palm*/
-				carrier_power_average[final_id] = 0;
-				final_id = 0;
-				carrier_power_max = carrier_power_average[0];
-				for (i = 0; i < ID_MAX; i++) {
-					if (carrier_power_max
-						< carrier_power_average[i]) {
-						carrier_power_max =
-						carrier_power_average[i];
-						final_id = i;
-					}
-				}
-			switch (final_id) {
-			case ID_PAL_I:
-				broad_std_except_pal_m =
-					AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_I;
-				break;
-			case ID_PAL_BG:
-				broad_std_except_pal_m =
-					AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_BG;
-				break;
-			case ID_PAL_DK:
-				broad_std_except_pal_m =
-					AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_DK;
-				break;
-			}
-			}
-			if (p != NULL) {
-				p->analog.std = V4L2_COLOR_STD_PAL;
-				switch (broad_std) {
-				case AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_DK:
-					p->analog.std |= V4L2_STD_PAL_DK;
-					p->analog.audmode = V4L2_STD_PAL_DK;
-				break;
-				case AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_I:
-					p->analog.std |= V4L2_STD_PAL_I;
-					p->analog.audmode = V4L2_STD_PAL_I;
-				break;
-				case AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_BG:
-					p->analog.std |= V4L2_STD_PAL_BG;
-					p->analog.audmode = V4L2_STD_PAL_BG;
-				break;
-				case AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_M:
-					p->analog.std |= V4L2_STD_PAL_M;
-					p->analog.audmode = V4L2_STD_PAL_M;
-				break;
-				default:
-					p->analog.std |= V4L2_STD_PAL_DK;
-					p->analog.audmode = V4L2_STD_PAL_DK;
-				}
-				p->frequency += 1;
-				fe->ops.set_frontend(fe);
-			}
-			return broad_std;
-		}
-		switch (broad_std) {
-		case AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_DK:
-			broad_std = AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_I;
-			cur_std = ID_PAL_I;
-			if (p != NULL) {
-				p->analog.std =
-					V4L2_COLOR_STD_PAL | V4L2_STD_PAL_I;
-				p->frequency += 1;
-				p->analog.audmode = V4L2_STD_PAL_I;
-			}
-			delay_ms = delay_ms_default;
-			break;
-		case AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_I:
-			broad_std = AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_BG;
-			cur_std = ID_PAL_BG;
-			if (p != NULL) {
-				p->analog.std =
-					V4L2_COLOR_STD_PAL | V4L2_STD_PAL_BG;
-				p->frequency += 1;
-				p->analog.audmode = V4L2_STD_PAL_BG;
-			}
-			delay_ms = delay_ms_default;
-			break;
-		case AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_BG:
-			broad_std = AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_M;
-			cur_std = ID_PAL_M;
-			if (p != NULL) {
-				p->analog.std =
-					V4L2_COLOR_STD_PAL | V4L2_STD_PAL_M;
-				p->frequency += 1;
-				p->analog.audmode = V4L2_STD_PAL_M;
-			}
-			delay_ms = delay_ms_default;
-			break;
-		case AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_M:
-			broad_std = AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_DK;
-			cur_std = ID_PAL_DK;
-			if (p != NULL) {
-				p->analog.std =
-					V4L2_COLOR_STD_PAL | V4L2_STD_PAL_DK;
-				p->frequency += 1;
-				p->analog.audmode = V4L2_STD_PAL_DK;
-			}
-			delay_ms = delay_ms_default;
-			break;
-
-		default:
-			pr_err("unsupport broadcast_standard!!!\n");
-			break;
-		}
-		if (p != NULL)
-			fe->ops.set_frontend(fe);
-		/* atvdemod_init(); //set_frontend has already been called it */
-
-		/* enable audio detect function */
-		temp_data = atv_dmd_rd_reg(APB_BLOCK_ADDR_SIF_STG_2, 0x02);
-		temp_data = temp_data | 0x80;/* 0x40 */
-		atv_dmd_wr_reg(APB_BLOCK_ADDR_SIF_STG_2, 0x02, temp_data);
-
-		usleep_range(delay_ms*1000, delay_ms*1000+100);
-
-		carrier_lock_count = 0;
-		i = 4;
-		while (i--) {
-			retrieve_vpll_carrier_lock(&lock);
-			if (lock == 0)
-				break;
-			carrier_lock_count++;
-			if (carrier_lock_count >= 20) {
-				pr_err("%s step2, retrieve_vpll_carrier_lock failed\n",
-					__func__);
-			/* return broad_std; */
-			}
-			usleep_range(6000, 9000);
-		}
-		/* ----------------read carrier_power--------------------- */
-		for (i = 0; i < 100; i++) {
-			carrier_power =
-				atv_dmd_rd_reg(APB_BLOCK_ADDR_SIF_STG_2,
-					reg_addr);
-			carrier_power_max += carrier_power;
-		}
-		carrier_power = carrier_power_max/i;
-		carrier_power_max = 0;
-		pr_err("[amlatvdemod.. %d,std:%d ]%s: atvdemo audio carrier power report:%lu. @@@@@@@@@@\n",
-			num, broad_std, __func__, carrier_power);
-		carrier_power_average[cur_std] += carrier_power;
-		num++;
-	}
-
-	return broad_std;
-}
-
-void aml_audio_valume_gain_set(unsigned int audio_gain)
-{
-	unsigned long audio_gain_data , temp_data;
-	if (audio_gain > 0xfff) {
-		pr_err("Error: atv in gain max 7.998, min 0.002! gain = value/512\n");
-		pr_err("value (0~0xfff)\n");
-		return;
-	}
-	audio_gain_data = audio_gain & 0xfff;
-	temp_data = atv_dmd_rd_word(APB_BLOCK_ADDR_MONO_PROC, 0x52);
-	temp_data = (temp_data & 0xf000) | audio_gain_data;
-	atv_dmd_wr_word(APB_BLOCK_ADDR_MONO_PROC, 0x52, temp_data);
-}
-
-unsigned int aml_audio_valume_gain_get(void)
-{
-	unsigned long audio_gain_data;
-	audio_gain_data = atv_dmd_rd_word(APB_BLOCK_ADDR_MONO_PROC, 0x52);
-	audio_gain_data = audio_gain_data & 0xfff;
-	return audio_gain_data;
-}
-
-void aml_atvdemod_overmodule_det(void)
-{
-	unsigned long temp_data , temp_data2;/* , temp_data3 , temp_data4; */
-	unsigned long counter_report;
-	int  carrier_lock_count = 0;
-	int vlock = 0;
-	switch (audio_det_mode) {
-	case AUDIO_AUTO_DETECT:
-		aml_audiomode_autodet(NULL);
-		return;
-#if 0
-		while (1) {
-			retrieve_vpll_carrier_lock(&vlock);
-			if (vlock)
-				break;
-			carrier_lock_count++;
-			if (carrier_lock_count >= 1000)
-				return;
-	/* ------------whether need timer delays between the detect lock---- */
-		}
-	/* -----------------enable auto_adjust_en------------- */
-		temp_data = atv_dmd_rd_word(APB_BLOCK_ADDR_SIF_STG_2, 0x02);
-		temp_data = temp_data | 0x100;
-		/* set the bit 9 of the temp_data to 1 */
-		atv_dmd_wr_word(APB_BLOCK_ADDR_SIF_STG_2, 0x02, temp_data);
-	/* -----------------enable auto_adjust_en end----------------- */
-	/* -----------------begain to set ov_cnt_en enable------------- */
-		temp_data2 = atv_dmd_rd_word(APB_BLOCK_ADDR_SIF_STG_2, 0x02);
-		temp_data2 = temp_data2 | 0x80;
-		/* set the bit 8 of the temp_data to 1 */
-		atv_dmd_wr_word(APB_BLOCK_ADDR_SIF_STG_2, 0x02, temp_data2);
-	/* ------------------set ov_cnt_en enable end---------------- */
-		udelay(1000);/* timer delay needed , */
-	/* ------------------------------------------------------------ */
-		/* -----------------disable auto_adjust_en------------- */
-		temp_data3 = atv_dmd_rd_word(APB_BLOCK_ADDR_SIF_STG_2, 0x02);
-		temp_data3 = temp_data3 & 0xfeff;
-		/* set the bit 9 of the temp_data to 0 */
-		atv_dmd_wr_word(APB_BLOCK_ADDR_SIF_STG_2, 0x02, temp_data3);
-	/* -----------------disable auto_adjust_en end------------ */
-	/* -----------------begain to set ov_cnt_en disable------------- */
-		temp_data4 = atv_dmd_rd_word(APB_BLOCK_ADDR_SIF_STG_2, 0x02);
-		temp_data4 = temp_data4 & 0xff7f;
-		/* set the bit 8 of the temp_data to 0 */
-		atv_dmd_wr_word(APB_BLOCK_ADDR_SIF_STG_2, 0x02, temp_data4);
-		break;
-	/* ------------------set ov_cnt_en disable end------ */
-#endif
-	case AUDIO_MANUAL_DETECT:
-		while (1) {
-			retrieve_vpll_carrier_lock(&vlock);
-			if (vlock)
-				break;
-			carrier_lock_count++;
-			if (carrier_lock_count >= 1000)
-				return;
-		}
-
-		/* -----------------begain to set ov_cnt_en enable---- */
-		temp_data = atv_dmd_rd_word(APB_BLOCK_ADDR_SIF_STG_2, 0x02);
-		temp_data = temp_data | 0x80;
-		/* set the bit 8 of the temp_data to 1 */
-		atv_dmd_wr_word(APB_BLOCK_ADDR_SIF_STG_2, 0x02, temp_data);
-	/* ------------------set ov_cnt_en enable end--------------- */
-	/* -----------------disable auto_adjust_en------------- */
-		temp_data2 = atv_dmd_rd_word(APB_BLOCK_ADDR_SIF_STG_2, 0x02);
-		temp_data2 = temp_data2 & 0xfeff;
-		/* set the bit 9 of the temp_data to 0 */
-		atv_dmd_wr_word(APB_BLOCK_ADDR_SIF_STG_2, 0x02, temp_data2);
-	/* -----------------disable auto_adjust_en end------------ */
-			udelay(1000);/* timer delay needed , */
-	/* ------------------------------------------------------- */
-		counter_report =
-			atv_dmd_rd_word(APB_BLOCK_ADDR_SIF_STG_2, 0x04);
-
-		while (counter_report > over_threshold) {
-
-				unsigned long shift_gain , shift_gain_report;
-				temp_data2 = atv_dmd_rd_byte(
-					APB_BLOCK_ADDR_SIF_STG_2, 0x00);
-				shift_gain = temp_data2 & 0x07;
-				shift_gain--;
-				temp_data2 = (temp_data2 & 0xf8) | shift_gain;
-				atv_dmd_wr_byte(APB_BLOCK_ADDR_SIF_STG_2, 0x00,
-						temp_data2);
-				shift_gain_report = (
-				(atv_dmd_rd_long(APB_BLOCK_ADDR_SIF_STG_2, 0x04)
-							& 0x00070000) >> 16);
-
-				if (shift_gain_report != shift_gain)
-					pr_info("[atvdemo...]:set shift_gain error\n");
-				/* ------------------timer delay needed- */
-				udelay(1000);/* timer delay needed , */
-				/* ----------------------- */
-				counter_report =
-				atv_dmd_rd_word(APB_BLOCK_ADDR_SIF_STG_2, 0x04);
-		}
-		break;
-	default:
-		pr_info("invalid over_module_det mode!!!\n");
-		break;
-	}
-}
-
-void aml_fix_PWM_adjust(int enable)
-{
-	unsigned long  temp_data;
-	/*
-	temp_data = atv_dmd_rd_byte(APB_BLOCK_ADDR_AGC_PWM, 0x08);
-	temp_data = temp_data | 0x01;
-	atv_dmd_wr_byte(APB_BLOCK_ADDR_AGC_PWM, 0x08, temp_data);
-	*/
-	temp_data = atv_dmd_rd_reg(APB_BLOCK_ADDR_SIF_STG_2, 0x02);
-	if (enable)
-		temp_data = temp_data & ~((0x3)<<8);
-	else
-		temp_data = temp_data & ~((0x1)<<9);
-
-	atv_dmd_wr_reg(APB_BLOCK_ADDR_SIF_STG_2, 0x02, temp_data);
-	if (enable) {
-		temp_data = temp_data | ((0x3)<<8);
-		atv_dmd_wr_reg(APB_BLOCK_ADDR_SIF_STG_2, 0x02, temp_data);
-	}
-}
-
-
diff --git a/drivers/amlogic/dvb_tv/amlatvdemod/atvdemod_func.h b/drivers/amlogic/dvb_tv/amlatvdemod/atvdemod_func.h
deleted file mode 100644
index 0c1c9d9db842..000000000000
--- a/drivers/amlogic/dvb_tv/amlatvdemod/atvdemod_func.h
+++ /dev/null
@@ -1,318 +0,0 @@
-/*
- * ATVDEMOD Device Driver
- *
- * Author: dezhi kong <dezhi.kong@amlogic.com>
- *
- *
- * Copyright (C) 2014 Amlogic Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
-
-#ifndef __ATVDEMOD_FUN_H
-#define __ATVDEMOD_FUN_H
-
-/*#include "../aml_fe.h"*/
-#include <linux/amlogic/tvin/tvin.h>
-#include "../aml_fe.h"
-#include <linux/amlogic/iomap.h>
-
-/*#define TVFE_APB_BASE_ADDR 0xd0046000*/
-#define ATV_DMD_APB_BASE_ADDR 0xc8008000
-#define ATV_DMD_APB_BASE_ADDR_GXTVBB 0xc8840000
-
-#define HHI_ATV_DMD_SYS_CLK_CNTL		0x10f3
-
-extern int atvdemod_debug_en;
-extern struct amlatvdemod_device_s *amlatvdemod_devp;
-extern unsigned int reg_23cf; /* IIR filter */
-extern int broad_std_except_pal_m;
-#undef pr_info
-#define pr_info(args...)\
-	do {\
-		if (atvdemod_debug_en)\
-			printk(args);\
-	} while (0)
-#undef pr_dbg
-#define pr_dbg(a...) \
-	do {\
-		if (1)\
-			printk(a);\
-	} while (0)
-
-#define ATVDEMOD_INTERVAL	(HZ/100)	/*10ms, #define HZ 100*/
-
-extern int amlatvdemod_reg_read(unsigned int reg, unsigned int *val);
-extern int amlatvdemod_reg_write(unsigned int reg, unsigned int val);
-extern int amlatvdemod_hiu_reg_read(unsigned int reg, unsigned int *val);
-extern int amlatvdemod_hiu_reg_write(unsigned int reg, unsigned int val);
-
-static inline uint32_t R_ATVDEMOD_REG(uint32_t reg)
-{
-	unsigned int val;
-	amlatvdemod_reg_read(reg, &val);
-	return val;
-}
-
-static inline void W_ATVDEMOD_REG(uint32_t reg,
-				 const uint32_t val)
-{
-	amlatvdemod_reg_write(reg, val);
-}
-
-static inline void W_ATVDEMOD_BIT(uint32_t reg,
-				    const uint32_t value,
-				    const uint32_t start,
-				    const uint32_t len)
-{
-	W_ATVDEMOD_REG(reg, ((R_ATVDEMOD_REG(reg) &
-			     ~(((1L << (len)) - 1) << (start))) |
-			    (((value) & ((1L << (len)) - 1)) << (start))));
-}
-
-static inline uint32_t R_ATVDEMOD_BIT(uint32_t reg,
-				    const uint32_t start,
-				    const uint32_t len)
-{
-	uint32_t val;
-
-	val = ((R_ATVDEMOD_REG(reg) >> (start)) & ((1L << (len)) - 1));
-
-	return val;
-}
-
-static inline uint32_t R_HIU_REG(uint32_t reg)
-{
-	unsigned int val;
-	amlatvdemod_hiu_reg_read(reg, &val);
-	return val;
-}
-
-static inline void W_HIU_REG(uint32_t reg,
-				 const uint32_t val)
-{
-	amlatvdemod_hiu_reg_write(reg, val);
-}
-
-static inline void W_HIU_BIT(uint32_t reg,
-				    const uint32_t value,
-				    const uint32_t start,
-				    const uint32_t len)
-{
-	W_HIU_REG(reg, ((R_HIU_REG(reg) &
-			     ~(((1L << (len)) - 1) << (start))) |
-			    (((value) & ((1L << (len)) - 1)) << (start))));
-}
-
-static inline uint32_t R_HIU_BIT(uint32_t reg,
-				    const uint32_t start,
-				    const uint32_t len)
-{
-	uint32_t val;
-
-	val = ((R_HIU_REG(reg) >> (start)) & ((1L << (len)) - 1));
-
-	return val;
-}
-
-enum broadcast_standard_e {
-	ATVDEMOD_STD_NTSC = 0,
-	ATVDEMOD_STD_NTSC_J,
-	ATVDEMOD_STD_PAL_M,
-	ATVDEMOD_STD_PAL_BG,
-	ATVDEMOD_STD_DTV,
-	ATVDEMOD_STD_SECAM_DK2,
-	ATVDEMOD_STD_SECAM_DK3,
-	ATVDEMOD_STD_PAL_BG_NICAM,
-	ATVDEMOD_STD_PAL_DK_CHINA,
-	ATVDEMOD_STD_SECAM_L,
-	ATVDEMOD_STD_PAL_I,
-	ATVDEMOD_STD_PAL_DK1,
-	ATVDEMOD_STD_MAX,
-};
-enum gde_curve_e {
-	ATVDEMOD_CURVE_M = 0,
-	ATVDEMOD_CURVE_A,
-	ATVDEMOD_CURVE_B,
-	ATVDEMOD_CURVE_CHINA,
-	ATVDEMOD_CURVE_MAX,
-};
-enum sound_format_e {
-	ATVDEMOD_SOUND_STD_MONO = 0,
-	ATVDEMOD_SOUND_STD_NICAM,
-	ATVDEMOD_SOUND_STD_MAX,
-};
-extern void atv_dmd_wr_reg(unsigned char block, unsigned char reg,
-	unsigned long data);
-extern unsigned long atv_dmd_rd_reg(unsigned char block, unsigned char reg);
-extern unsigned long atv_dmd_rd_byte(unsigned long block_address,
-				     unsigned long reg_addr);
-extern unsigned long atv_dmd_rd_word(unsigned long block_address,
-				     unsigned long reg_addr);
-extern unsigned long atv_dmd_rd_long(unsigned long block_address,
-				     unsigned long reg_addr);
-extern void atv_dmd_wr_long(unsigned long block_address,
-				unsigned long reg_addr,
-				unsigned long data);
-extern void atv_dmd_wr_word(unsigned long block_address,
-				unsigned long reg_addr,
-				unsigned long data);
-extern void atv_dmd_wr_byte(unsigned long block_address,
-				unsigned long reg_addr,
-				unsigned long data);
-extern void set_audio_gain_val(int val);
-extern void set_video_gain_val(int val);
-extern void atv_dmd_soft_reset(void);
-extern void atv_dmd_input_clk_32m(void);
-extern void read_version_register(void);
-extern void check_communication_interface(void);
-extern void power_on_receiver(void);
-extern void atv_dmd_misc(void);
-extern void configure_receiver(int Broadcast_Standard,
-			       unsigned int Tuner_IF_Frequency,
-			       int Tuner_Input_IF_inverted, int GDE_Curve,
-			       int sound_format);
-extern int atvdemod_clk_init(void);
-extern int atvdemod_init(void);
-extern void atvdemod_uninit(void);
-extern void atv_dmd_set_std(void);
-extern void retrieve_vpll_carrier_lock(int *lock);
-extern void retrieve_video_lock(int *lock);
-extern int retrieve_vpll_carrier_afc(void);
-
-extern int get_atvdemod_snr_val(void);
-extern int aml_atvdemod_get_snr(struct dvb_frontend *fe);
-
-/*atv demod block address*/
-/*address interval is 4, because it's 32bit interface,
- but the address is in byte*/
-#define ATV_DMD_TOP_CTRL			0x0
-#define ATV_DMD_TOP_CTRL1			0x4
-#define ATV_DMD_RST_CTRL			0x8
-
-#define APB_BLOCK_ADDR_SYSTEM_MGT			0x0
-#define APB_BLOCK_ADDR_AA_LP_NOTCH			0x1
-#define APB_BLOCK_ADDR_MIXER_1				0x2
-#define APB_BLOCK_ADDR_MIXER_3				0x3
-#define APB_BLOCK_ADDR_ADC_SE				0x4
-#define APB_BLOCK_ADDR_PWR_ANL				0x5
-#define APB_BLOCK_ADDR_CARR_RCVY			0x6
-#define APB_BLOCK_ADDR_FE_DROOP_MDF			0x7
-#define APB_BLOCK_ADDR_SIF_IC_STD			0x8
-#define APB_BLOCK_ADDR_SIF_STG_2			0x9
-#define APB_BLOCK_ADDR_SIF_STG_3			0xa
-#define APB_BLOCK_ADDR_IC_AGC				0xb
-#define APB_BLOCK_ADDR_DAC_UPS				0xc
-#define APB_BLOCK_ADDR_GDE_EQUAL			0xd
-#define APB_BLOCK_ADDR_VFORMAT				0xe
-#define APB_BLOCK_ADDR_VDAGC				0xf
-#define APB_BLOCK_ADDR_VERS_REGISTER			0x10
-#define APB_BLOCK_ADDR_INTERPT_MGT			0x11
-#define APB_BLOCK_ADDR_ADC_MGR				0x12
-#define APB_BLOCK_ADDR_GP_VD_FLT			0x13
-#define APB_BLOCK_ADDR_CARR_DMD				0x14
-#define APB_BLOCK_ADDR_SIF_VD_IF			0x15
-#define APB_BLOCK_ADDR_VD_PKING				0x16
-#define APB_BLOCK_ADDR_FE_DR_SMOOTH			0x17
-#define APB_BLOCK_ADDR_AGC_PWM				0x18
-#define APB_BLOCK_ADDR_DAC_UPS_24M			0x19
-#define APB_BLOCK_ADDR_VFORMAT_DP			0x1a
-#define APB_BLOCK_ADDR_VD_PKING_DAC			0x1b
-#define APB_BLOCK_ADDR_MONO_PROC			0x1c
-#define APB_BLOCK_ADDR_TOP				0x1d
-
-#define SLAVE_BLOCKS_NUMBER 0x1d	/*indeed totals 0x1e, adding top*/
-
-/*Broadcast_Standard*/
-/*                      0: NTSC*/
-/*                      1: NTSC-J*/
-/*                      2: PAL-M,*/
-/*                      3: PAL-BG*/
-/*                      4: DTV*/
-/*                      5: SECAM- DK2*/
-/*                      6: SECAM -DK3*/
-/*                      7: PAL-BG, NICAM*/
-/*                      8: PAL-DK-CHINA*/
-/*                      9: SECAM-L / SECAM-DK3*/
-/*                      10: PAL-I*/
-/*                      11: PAL-DK1*/
-#define AML_ATV_DEMOD_VIDEO_MODE_PROP_NTSC		0
-#define AML_ATV_DEMOD_VIDEO_MODE_PROP_NTSC_J		1
-#define AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_M		2
-#define AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_BG		3
-#define AML_ATV_DEMOD_VIDEO_MODE_PROP_DTV		4
-#define AML_ATV_DEMOD_VIDEO_MODE_PROP_SECAM_DK2		5
-#define AML_ATV_DEMOD_VIDEO_MODE_PROP_SECAM_DK3		6
-#define AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_BG_NICAM	7
-#define AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_DK		8
-#define AML_ATV_DEMOD_VIDEO_MODE_PROP_SECAM_L	9
-#define AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_I	10
-#define AML_ATV_DEMOD_VIDEO_MODE_PROP_PAL_DK1	11
-/* new add @20150813 begin */
-#define AML_ATV_DEMOD_VIDEO_MODE_PROP_NTSC_DK		12
-#define AML_ATV_DEMOD_VIDEO_MODE_PROP_NTSC_BG	13
-#define AML_ATV_DEMOD_VIDEO_MODE_PROP_NTSC_I	14
-#define AML_ATV_DEMOD_VIDEO_MODE_PROP_NTSC_M    15
-/* new add @20150813 end */
-
-/*GDE_Curve*/
-/*                      0: CURVE-M*/
-/*                      1: CURVE-A*/
-/*                      2: CURVE-B*/
-/*                      3: CURVE-CHINA*/
-/*                      4: BYPASS*/
-#define AML_ATV_DEMOD_VIDEO_MODE_PROP_CURVE_M		0
-#define AML_ATV_DEMOD_VIDEO_MODE_PROP_CURVE_A		1
-#define AML_ATV_DEMOD_VIDEO_MODE_PROP_CURVE_B		2
-#define AML_ATV_DEMOD_VIDEO_MODE_PROP_CURVE_CHINA	3
-#define AML_ATV_DEMOD_VIDEO_MODE_PROP_CURVE_BYPASS	4
-
-/*sound format 0: MONO;1:NICAM*/
-#define AML_ATV_DEMOD_SOUND_MODE_PROP_MONO	0
-#define AML_ATV_DEMOD_SOUND_MODE_PROP_NICAM	1
-/**
-freq_hz:hs_freq
-freq_hz_cvrt=hs_freq/0.23841858
-vs_freq==50,freq_hz=15625;freq_hz_cvrt=0xffff
-vs_freq==60,freq_hz=15734,freq_hz_cvrt=0x101c9
-**/
-#define AML_ATV_DEMOD_FREQ_50HZ_VERT	0xffff	/*65535*/
-#define AML_ATV_DEMOD_FREQ_60HZ_VERT	0x101c9	/*65993*/
-
-#define CARR_AFC_DEFAULT_VAL 0xffff
-
-enum amlatvdemod_snr_level_e {
-	very_low = 1,
-	low,
-	ok_minus,
-	ok_plus,
-	high,
-};
-
-enum audio_detect_mode {
-	AUDIO_AUTO_DETECT = 0,
-	AUDIO_MANUAL_DETECT,
-};
-
-struct amlatvdemod_device_s {
-	struct class *clsp;
-	struct device *dev;
-	struct analog_parameters parm;
-	int fre_offset;
-	struct pinctrl *pin;
-	const char *pin_name;
-};
-
-extern void amlatvdemod_set_std(int val);
-extern struct amlatvdemod_device_s *amlatvdemod_devp;
-extern void aml_fix_PWM_adjust(int enable);
-extern void aml_audio_valume_gain_set(unsigned int audio_gain);
-extern unsigned int aml_audio_valume_gain_get(void);
-extern void aml_atvdemod_overmodule_det(void);
-extern int aml_audiomode_autodet(struct dvb_frontend *fe);
-extern void retrieve_frequency_offset(int *freq_offset);
-extern int aml_atvdemod_get_snr_ex(void);
-
-#endif /* __ATVDEMOD_FUN_H */
diff --git a/drivers/amlogic/dvb_tv/amldemod/Makefile b/drivers/amlogic/dvb_tv/amldemod/Makefile
deleted file mode 100644
index 039a53b59545..000000000000
--- a/drivers/amlogic/dvb_tv/amldemod/Makefile
+++ /dev/null
@@ -1,29 +0,0 @@
-
-obj-$(CONFIG_AM_DTVDEMOD) += aml_fe.o
-
-aml_fe-objs := demod_func.o  dvbc_func.o i2c_func.o tuner_func.o #dvbt_func.o
-
-#aml_fe-objs += mxl/MxL5007.o
-#aml_fe-objs += mxl/MxL5007_API.o
-#aml_fe-objs += mxl/MxL_User_Define.o
-#aml_fe-objs += nxp/tuner_fj2207.o
-#aml_fe-objs += nxp/tmbslNT220x.o
-#aml_fe-objs += nxp/tmbslNT220xInstance.o
-#aml_fe-objs += nxp/tmddNT220x.o
-#aml_fe-objs += nxp/tmddNT220xInstance.o
-#aml_fe-objs += nxp/tmddNT220x_Advanced.o
-#aml_fe-objs += si2176/si2176_func.o
-
-##ifeq ($(CONFIG_AM_DEMOD_DVBAPI), y)
-aml_fe-objs += amlfrontend.o
-##endif
-
-##ifeq ($(CONFIG_AM_DEMOD_DEBUG), y)
-aml_fe-objs	+= aml_demod.o
-##endif
-
-ccflags-y += -I.
-ccflags-y += -Idrivers/media/dvb-core
-ccflags-y += -Idrivers/amlogic/dvb_tv/amldemod/include
-ccflags-y += -Idrivers/amlogic/dvb_tv/
-
diff --git a/drivers/amlogic/dvb_tv/amldemod/aml_demod.c b/drivers/amlogic/dvb_tv/amldemod/aml_demod.c
deleted file mode 100644
index 1b9d4da0c7a9..000000000000
--- a/drivers/amlogic/dvb_tv/amldemod/aml_demod.c
+++ /dev/null
@@ -1,700 +0,0 @@
-#include <linux/init.h>
-#include <linux/types.h>
-#include <linux/ioport.h>
-#include <linux/platform_device.h>
-#include <linux/version.h>
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/spinlock.h>
-#include <linux/interrupt.h>
-#include <linux/fs.h>
-#include <linux/string.h>
-#include <linux/io.h>
-#include <linux/mm.h>
-#include <linux/major.h>
-#include <linux/err.h>
-#include <linux/mutex.h>
-#include <linux/ctype.h>
-#include <linux/sched.h>
-#include <linux/poll.h>
-#include <linux/i2c.h>
-#include <linux/delay.h>
-/* #include <mach/am_regs.h> */
-#include <linux/device.h>
-#include <linux/cdev.h>
-
-/* #include <asm/fiq.h> */
-#include <linux/uaccess.h>
-#include <linux/dvb/aml_demod.h>
-#include "demod_func.h"
-
-#include <linux/slab.h>
-#ifdef CONFIG_COMPAT
-#include <linux/compat.h>
-#endif
-/*#include "sdio/sdio_init.h"*/
-#define DRIVER_NAME "aml_demod"
-#define MODULE_NAME "aml_demod"
-#define DEVICE_NAME "aml_demod"
-#define DEVICE_UI_NAME "aml_demod_ui"
-
-#define pr_dbg(a ...) \
-	do { \
-		if (1) { \
-			printk(a); \
-		} \
-	} while (0)
-
-
-const char aml_demod_dev_id[] = "aml_demod";
-
-/*#ifndef CONFIG_AM_DEMOD_DVBAPI
- * static struct aml_demod_i2c demod_i2c;
- * static struct aml_demod_sta demod_sta;
- * #else
- * extern struct aml_demod_i2c demod_i2c;
- * extern struct aml_demod_sta demod_sta;
- #endif*/
-
-static struct aml_demod_i2c demod_i2c;
-static struct aml_demod_sta demod_sta;
-static int read_start;
-
-int sdio_read_ddr(unsigned long sdio_addr, unsigned long byte_count,
-		  unsigned char *data_buf)
-{
-	return 0;
-}
-
-int sdio_write_ddr(unsigned long sdio_addr, unsigned long byte_count,
-		   unsigned char *data_buf)
-{
-	return 0;
-}
-
-int read_reg(int addr)
-{
-	addr = addr + DEMOD_BASE;
-	return apb_read_reg(addr);
-}
-
-void wait_capture(int cap_cur_addr, int depth_MB, int start)
-{
-	int readfirst;
-	int tmp;
-	int time_out;
-	int last = 0x90000000;
-
-	time_out = readfirst = 0;
-	tmp = depth_MB << 20;
-	while (tmp && (time_out < 1000)) {      /*10seconds time out */
-		time_out = time_out + 1;
-		msleep(20);
-		readfirst = app_apb_read_reg(cap_cur_addr);
-		if ((last - readfirst) > 0)
-			tmp = 0;
-		else
-			last = readfirst;
-		/*      usleep(1000); */
-		/*      readsecond= app_apb_read_reg(cap_cur_addr); */
-
-		/*      if((readsecond-start)>tmp) */
-/*                      tmp=0;*/
-/*              if((readsecond-readfirst)<0)  // turn around*/
-/*                      tmp=0;*/
-		pr_dbg("First  %x = [%08x],[%08x]%x\n", cap_cur_addr, readfirst,
-		       last, (last - readfirst));
-/*              printf("Second %x = [%08x]\n",cap_cur_addr, readsecond);*/
-		msleep(20);
-	}
-	read_start = readfirst + 0x40000000;
-	pr_dbg("read_start is %x\n", read_start);
-}
-
-int cap_adc_data(struct aml_cap_data *cap)
-{
-	int tmp;
-	int tb_depth;
-
-	pr_dbg("capture ADC\n ");
-	/*      printf("set mem_start (you can read in kernel start log
-	 * (memstart is ).(hex)  :  ");*/
-	/*      scanf("%x",&tmp);*/
-	tmp = 0x94400000;
-	app_apb_write_reg(0x9d, cap->cap_addr);
-	app_apb_write_reg(0x9e, cap->cap_addr + cap->cap_size * 0x100000);
-	/*0x8000000-128m, 0x400000-4m */
-	read_start = tmp + 0x40000000;
-	/*printf("set afifo rate. (hex)(adc_clk/demod_clk)*256+2 :  ");   //
-	 * (adc_clk/demod_clk)*256+2 */
-	/*  scanf("%x",&tmp); */
-	cap->cap_afifo = 0x60;
-	app_apb_write_reg(0x15, 0x18715f2);
-	app_apb_write_reg(0x15, (app_apb_read_reg(0x15) & 0xfff00fff) |
-			  ((cap->cap_afifo & 0xff) << 12));     /* set afifo */
-	app_apb_write_reg(0x9b, 0x1c9);	/* capture ADC 10bits */
-	app_apb_write_reg(0x7f, 0x00008000);	/* enable testbus 0x8000 */
-
-	tb_depth = cap->cap_size;                               /*127; */
-	tmp = 9;
-	app_apb_write_reg(0x9b, (app_apb_read_reg(0x9b) & ~0x1f) | tmp);
-	/* set testbus width */
-
-	tmp = 0x100000;
-	app_apb_write_reg(0x9c, tmp);   /* by ADC data enable */
-	/*  printf("Set test mode. (0 is normal ,1 is testmode) :  ");  //0 */
-	/*  scanf("%d",&tmp); */
-	tmp = 0;
-	if (tmp == 1)
-		app_apb_write_reg(0x9b, app_apb_read_reg(0x9b) | (1 << 10));
-	/* set test mode; */
-	else
-		app_apb_write_reg(0x9b, app_apb_read_reg(0x9b) & ~(1 << 10));
-	/* close test mode; */
-
-	app_apb_write_reg(0x9b, app_apb_read_reg(0x9b) & ~(1 << 9));
-	/* close cap; */
-	app_apb_write_reg(0x9b, app_apb_read_reg(0x9b) | (1 << 9));
-	/* open  cap; */
-
-	app_apb_write_reg(0x9b, app_apb_read_reg(0x9b) | (1 << 7));
-	/* close tb; */
-	app_apb_write_reg(0x9b, app_apb_read_reg(0x9b) & ~(1 << 7));
-	/* open  tb; */
-
-	app_apb_write_reg(0x9b, app_apb_read_reg(0x9b) | (1 << 5));
-	/* close intlv; */
-
-	app_apb_write_reg(0x303, 0x8);  /* open dc_arbit */
-
-	tmp = 0;
-	if (tmp)
-		app_apb_write_reg(0x9b, app_apb_read_reg(0x9b) & ~(1 << 5));
-	/* open  intlv; */
-
-	app_apb_write_reg(0x9b, app_apb_read_reg(0x9b) & ~(1 << 8));
-	/* go  tb; */
-
-	wait_capture(0x9f, tb_depth, app_apb_read_reg(0x9d));
-
-	app_apb_write_reg(0x9b, app_apb_read_reg(0x9b) | (1 << 8));
-	/* stop  tb; */
-	app_apb_write_reg(0x9b, app_apb_read_reg(0x9b) | (1 << 7));
-	/* close tb; */
-	return 0;
-}
-
-static DECLARE_WAIT_QUEUE_HEAD(lock_wq);
-
-static ssize_t aml_demod_info(struct class *cla,
-			      struct class_attribute *attr, char *buf)
-{
-	return 0;
-}
-
-static struct class_attribute aml_demod_class_attrs[] = {
-	__ATTR(info,
-	       S_IRUGO | S_IWUSR,
-	       aml_demod_info,
-	       NULL),
-	__ATTR_NULL
-};
-
-static struct class aml_demod_class = {
-	.name		= "aml_demod",
-	.class_attrs	= aml_demod_class_attrs,
-};
-
-#if 0
-
-static irqreturn_t aml_demod_isr(int irq, void *dev_id)
-{
-	if (demod_sta.dvb_mode == 0) {
-		/*dvbc_isr(&demod_sta); */
-		if (dvbc_isr_islock()) {
-			pr_dbg("sync4\n");
-			if (waitqueue_active(&lock_wq))
-				wake_up_interruptible(&lock_wq);
-		}
-	} else {
-		dvbt_isr(&demod_sta);
-	}
-
-	return IRQ_HANDLED;
-}
-#endif
-
-static int aml_demod_open(struct inode *inode, struct file *file)
-{
-	pr_dbg("Amlogic Demod DVB-T/C Open\n");
-	return 0;
-}
-
-static int aml_demod_release(struct inode *inode, struct file *file)
-{
-	pr_dbg("Amlogic Demod DVB-T/C Release\n");
-	return 0;
-}
-
-#if 0
-static int amdemod_islock(void)
-{
-	struct aml_demod_sts demod_sts;
-
-	if (demod_sta.dvb_mode == 0) {
-		dvbc_status(&demod_sta, &demod_i2c, &demod_sts);
-		return demod_sts.ch_sts & 0x1;
-	} else if (demod_sta.dvb_mode == 1) {
-		dvbt_status(&demod_sta, &demod_i2c, &demod_sts);
-		return demod_sts.ch_sts >> 12 & 0x1;
-	}
-	return 0;
-}
-#endif
-
-void mem_read(struct aml_demod_mem *arg)
-{
-	int data;
-	int addr;
-
-	addr = arg->addr;
-	data = arg->dat;
-/*      memcpy(mem_buf[addr],data,1);*/
-	pr_dbg("[addr %x] data is %x\n", addr, data);
-}
-static long aml_demod_ioctl(struct file *file,
-			    unsigned int cmd, unsigned long arg)
-{
-	int strength = 0;
-	struct dvb_frontend *dvbfe;
-	struct aml_tuner_sys *tuner;
-	switch (cmd) {
-	case AML_DEMOD_GET_RSSI:
-		pr_dbg("Ioctl Demod GET_RSSI.\n");
-		dvbfe = get_si2177_tuner();
-		if (dvbfe != NULL)
-			strength = dvbfe->ops.tuner_ops.get_strength(dvbfe);
-		pr_dbg("[si2177] strength is %d\n", strength - 256);
-		if (strength < 0)
-			strength = 0 - strength;
-		tuner = (struct aml_tuner_sys *)arg;
-		tuner->rssi = strength;
-		break;
-
-	case AML_DEMOD_SET_TUNER:
-		pr_dbg("Ioctl Demod Set Tuner.\n");
-		dvbfe = get_si2177_tuner();
-		if (dvbfe != NULL)
-			dvbfe->ops.tuner_ops.set_tuner(dvbfe, &demod_sta,
-						       &demod_i2c,
-						       (struct aml_tuner_sys *)
-						       arg);
-		break;
-
-	case AML_DEMOD_SET_SYS:
-		pr_dbg("Ioctl Demod Set System\n");
-		demod_set_sys(&demod_sta, &demod_i2c,
-			      (struct aml_demod_sys *)arg);
-		break;
-
-	case AML_DEMOD_GET_SYS:
-		pr_dbg("Ioctl Demod Get System\n");
-
-		/*demod_get_sys(&demod_i2c, (struct aml_demod_sys *)arg); */
-		break;
-
-	case AML_DEMOD_TEST:
-		pr_dbg("Ioctl Demod Test. It is blank now\n");
-		/*demod_msr_clk(13); */
-		/*demod_msr_clk(14); */
-		/*demod_calc_clk(&demod_sta); */
-		break;
-
-	case AML_DEMOD_TURN_ON:
-		pr_dbg("Ioctl Demod Turn ON.It is blank now\n");
-		/*demod_turn_on(&demod_sta, (struct aml_demod_sys *)arg); */
-		break;
-
-	case AML_DEMOD_TURN_OFF:
-		pr_dbg("Ioctl Demod Turn OFF.It is blank now\n");
-		/*demod_turn_off(&demod_sta, (struct aml_demod_sys *)arg); */
-		break;
-
-	case AML_DEMOD_DVBC_SET_CH:
-		pr_dbg("Ioctl DVB-C Set Channel.\n");
-		dvbc_set_ch(&demod_sta, &demod_i2c,
-			    (struct aml_demod_dvbc *)arg);
-		break;
-
-	case AML_DEMOD_DVBC_GET_CH:
-		/*      pr_dbg("Ioctl DVB-C Get Channel. It is blank\n"); */
-		dvbc_status(&demod_sta, &demod_i2c,
-			    (struct aml_demod_sts *)arg);
-		break;
-	case AML_DEMOD_DVBC_TEST:
-		pr_dbg("Ioctl DVB-C Test. It is blank\n");
-		/*dvbc_get_test_out(0xb, 1000, (u32 *)arg); */
-		break;
-	case AML_DEMOD_DVBT_SET_CH:
-		pr_dbg("Ioctl DVB-T Set Channel\n");
-		dvbt_set_ch(&demod_sta, &demod_i2c,
-			    (struct aml_demod_dvbt *)arg);
-		break;
-
-	case AML_DEMOD_DVBT_GET_CH:
-		pr_dbg("Ioctl DVB-T Get Channel\n");
-		/*dvbt_status(&demod_sta, &demod_i2c,
-		 * (struct aml_demod_sts *)arg); */
-		break;
-
-	case AML_DEMOD_DVBT_TEST:
-		pr_dbg("Ioctl DVB-T Test. It is blank\n");
-		/*dvbt_get_test_out(0x1e, 1000, (u32 *)arg); */
-		break;
-
-	case AML_DEMOD_DTMB_SET_CH:
-		dtmb_set_ch(&demod_sta, &demod_i2c,
-			    (struct aml_demod_dtmb *)arg);
-		break;
-
-	case AML_DEMOD_DTMB_GET_CH:
-		break;
-
-	case AML_DEMOD_DTMB_TEST:
-		break;
-
-	case AML_DEMOD_ATSC_SET_CH:
-		atsc_set_ch(&demod_sta, &demod_i2c,
-			    (struct aml_demod_atsc *)arg);
-		break;
-
-	case AML_DEMOD_ATSC_GET_CH:
-		check_atsc_fsm_status();
-		break;
-
-	case AML_DEMOD_ATSC_TEST:
-		break;
-
-	case AML_DEMOD_SET_REG:
-		/*      pr_dbg("Ioctl Set Register\n"); */
-		demod_set_reg((struct aml_demod_reg *)arg);
-		break;
-
-	case AML_DEMOD_GET_REG:
-		/*      pr_dbg("Ioctl Get Register\n"); */
-		demod_get_reg((struct aml_demod_reg *)arg);
-		break;
-
-/* case AML_DEMOD_SET_REGS: */
-/* break; */
-
-/* case AML_DEMOD_GET_REGS: */
-/* break; */
-
-	case AML_DEMOD_RESET_MEM:
-		pr_dbg("set mem ok\n");
-		break;
-
-	case AML_DEMOD_READ_MEM:
-		break;
-	case AML_DEMOD_SET_MEM:
-		/*step=(struct aml_demod_mem)arg;
-		 * pr_dbg("[%x]0x%x------------------\n",i,mem_buf[step]);
-		 * for(i=step;i<1024-1;i++){
-		 * pr_dbg("0x%x,",mem_buf[i]);
-		 * } */
-		mem_read((struct aml_demod_mem *)arg);
-		break;
-
-	case AML_DEMOD_ATSC_IRQ:
-		atsc_read_iqr_reg();
-		break;
-
-	default:
-		pr_dbg("Enter Default ! 0x%X\n", cmd);
-/* pr_dbg("AML_DEMOD_GET_REGS=0x%08X\n", AML_DEMOD_GET_REGS); */
-/* pr_dbg("AML_DEMOD_SET_REGS=0x%08X\n", AML_DEMOD_SET_REGS); */
-		return -EINVAL;
-	}
-
-	return 0;
-}
-
-#ifdef CONFIG_COMPAT
-
-static long aml_demod_compat_ioctl(struct file *file, unsigned int cmd,
-				   ulong arg)
-{
-	return aml_demod_ioctl(file, cmd, (ulong)compat_ptr(arg));
-}
-
-#endif
-
-
-static const struct file_operations aml_demod_fops = {
-	.owner		= THIS_MODULE,
-	.open		= aml_demod_open,
-	.release	= aml_demod_release,
-	.unlocked_ioctl = aml_demod_ioctl,
-#ifdef CONFIG_COMPAT
-	.compat_ioctl	= aml_demod_compat_ioctl,
-#endif
-};
-
-static int aml_demod_ui_open(struct inode *inode, struct file *file)
-{
-	pr_dbg("Amlogic aml_demod_ui_open Open\n");
-	return 0;
-}
-
-static int aml_demod_ui_release(struct inode *inode, struct file *file)
-{
-	pr_dbg("Amlogic aml_demod_ui_open Release\n");
-	return 0;
-}
-char buf_all[100];
-static ssize_t aml_demod_ui_read(struct file *file, char __user *buf,
-				 size_t count, loff_t *ppos)
-{
-	char *capture_buf = buf_all;
-	int res = 0;
-
-	if (count >= 4 * 1024 * 1024)
-		count = 4 * 1024 * 1024;
-	else if (count == 0)
-		return 0;
-
-	res = copy_to_user((void *)buf, (char *)capture_buf, count);
-	if (res < 0) {
-		pr_dbg("[aml_demod_ui_read]res is %d", res);
-		return res;
-	}
-
-	return count;
-}
-
-static ssize_t aml_demod_ui_write(struct file *file, const char *buf,
-				  size_t count, loff_t *ppos)
-{
-	return 0;
-}
-
-static struct device *aml_demod_ui_dev;
-static dev_t aml_demod_devno_ui;
-static struct cdev *aml_demod_cdevp_ui;
-static const struct file_operations aml_demod_ui_fops = {
-	.owner		= THIS_MODULE,
-	.open		= aml_demod_ui_open,
-	.release	= aml_demod_ui_release,
-	.read		= aml_demod_ui_read,
-	.write		= aml_demod_ui_write,
-	/*   .unlocked_ioctl    = aml_demod_ui_ioctl, */
-};
-
-#if 0
-static ssize_t aml_demod_ui_info(struct class *cla,
-				 struct class_attribute *attr, char *buf)
-{
-	return 0;
-}
-
-static struct class_attribute aml_demod_ui_class_attrs[] = {
-	__ATTR(info,
-	       S_IRUGO | S_IWUSR,
-	       aml_demod_ui_info,
-	       NULL),
-	__ATTR_NULL
-};
-#endif
-
-static struct class aml_demod_ui_class = {
-	.name	= "aml_demod_ui",
-/*    .class_attrs = aml_demod_ui_class_attrs,*/
-};
-
-int aml_demod_ui_init(void)
-{
-	int r = 0;
-
-	r = class_register(&aml_demod_ui_class);
-	if (r) {
-		pr_dbg("create aml_demod class fail\r\n");
-		class_unregister(&aml_demod_ui_class);
-		return r;
-	}
-
-	r = alloc_chrdev_region(&aml_demod_devno_ui, 0, 1, DEVICE_UI_NAME);
-	if (r < 0) {
-		pr_dbg(KERN_ERR "aml_demod_ui: faild to alloc major number\n");
-		r = -ENODEV;
-		unregister_chrdev_region(aml_demod_devno_ui, 1);
-		class_unregister(&aml_demod_ui_class);
-		return r;
-	}
-
-	aml_demod_cdevp_ui = kmalloc(sizeof(struct cdev), GFP_KERNEL);
-	if (!aml_demod_cdevp_ui) {
-		pr_dbg(KERN_ERR "aml_demod_ui: failed to allocate memory\n");
-		r = -ENOMEM;
-		unregister_chrdev_region(aml_demod_devno_ui, 1);
-		kfree(aml_demod_cdevp_ui);
-		class_unregister(&aml_demod_ui_class);
-		return r;
-	}
-	/* connect the file operation with cdev */
-	cdev_init(aml_demod_cdevp_ui, &aml_demod_ui_fops);
-	aml_demod_cdevp_ui->owner = THIS_MODULE;
-	/* connect the major/minor number to cdev */
-	r = cdev_add(aml_demod_cdevp_ui, aml_demod_devno_ui, 1);
-	if (r) {
-		pr_dbg(KERN_ERR "aml_demod_ui:failed to add cdev\n");
-		unregister_chrdev_region(aml_demod_devno_ui, 1);
-		cdev_del(aml_demod_cdevp_ui);
-		kfree(aml_demod_cdevp_ui);
-		class_unregister(&aml_demod_ui_class);
-		return r;
-	}
-
-	aml_demod_ui_dev = device_create(&aml_demod_ui_class, NULL,
-					 MKDEV(MAJOR(aml_demod_devno_ui), 0),
-					 NULL, DEVICE_UI_NAME);
-
-	if (IS_ERR(aml_demod_ui_dev)) {
-		pr_dbg("Can't create aml_demod device\n");
-		unregister_chrdev_region(aml_demod_devno_ui, 1);
-		cdev_del(aml_demod_cdevp_ui);
-		kfree(aml_demod_cdevp_ui);
-		class_unregister(&aml_demod_ui_class);
-		return r;
-	}
-
-	return r;
-}
-
-void aml_demod_exit_ui(void)
-{
-	unregister_chrdev_region(aml_demod_devno_ui, 1);
-	cdev_del(aml_demod_cdevp_ui);
-	kfree(aml_demod_cdevp_ui);
-	class_unregister(&aml_demod_ui_class);
-}
-
-static struct device *aml_demod_dev;
-static dev_t aml_demod_devno;
-static struct cdev *aml_demod_cdevp;
-
-#ifdef CONFIG_AM_DEMOD_DVBAPI
-int aml_demod_init(void)
-#else
-static int __init aml_demod_init(void)
-#endif
-{
-	int r = 0;
-
-	pr_dbg("Amlogic Demod DVB-T/C DebugIF Init\n");
-
-	init_waitqueue_head(&lock_wq);
-
-	/* hook demod isr */
-	/* r = request_irq(INT_DEMOD, &aml_demod_isr,
-	 *              IRQF_SHARED, "aml_demod",
-	 *              (void *)aml_demod_dev_id);
-	 * if (r) {
-	 *      pr_dbg("aml_demod irq register error.\n");
-	 *      r = -ENOENT;
-	 *      goto err0;
-	 * }*/
-
-	/* sysfs node creation */
-	r = class_register(&aml_demod_class);
-	if (r) {
-		pr_dbg("create aml_demod class fail\r\n");
-		goto err1;
-	}
-
-	r = alloc_chrdev_region(&aml_demod_devno, 0, 1, DEVICE_NAME);
-	if (r < 0) {
-		pr_dbg(KERN_ERR "aml_demod: faild to alloc major number\n");
-		r = -ENODEV;
-		goto err2;
-	}
-
-	aml_demod_cdevp = kmalloc(sizeof(struct cdev), GFP_KERNEL);
-	if (!aml_demod_cdevp) {
-		pr_dbg(KERN_ERR "aml_demod: failed to allocate memory\n");
-		r = -ENOMEM;
-		goto err3;
-	}
-	/* connect the file operation with cdev */
-	cdev_init(aml_demod_cdevp, &aml_demod_fops);
-	aml_demod_cdevp->owner = THIS_MODULE;
-	/* connect the major/minor number to cdev */
-	r = cdev_add(aml_demod_cdevp, aml_demod_devno, 1);
-	if (r) {
-		pr_dbg(KERN_ERR "aml_demod:failed to add cdev\n");
-		goto err4;
-	}
-
-	aml_demod_dev = device_create(&aml_demod_class, NULL,
-				      MKDEV(MAJOR(aml_demod_devno), 0), NULL,
-				      DEVICE_NAME);
-
-	if (IS_ERR(aml_demod_dev)) {
-		pr_dbg("Can't create aml_demod device\n");
-		goto err5;
-	}
-	pr_dbg("Amlogic Demod DVB-T/C DebugIF Init ok----------------\n");
-#if defined(CONFIG_AM_AMDEMOD_FPGA_VER) && !defined(CONFIG_AM_DEMOD_DVBAPI)
-	pr_dbg("sdio_init\n");
-	sdio_init();
-#endif
-	aml_demod_ui_init();
-
-	return 0;
-
-err5:
-	cdev_del(aml_demod_cdevp);
-err4:
-	kfree(aml_demod_cdevp);
-
-err3:
-	unregister_chrdev_region(aml_demod_devno, 1);
-
-err2:
-/*    free_irq(INT_DEMOD, (void *)aml_demod_dev_id);*/
-
-err1:
-	class_unregister(&aml_demod_class);
-
-/*  err0:*/
-	return r;
-}
-
-#ifdef CONFIG_AM_DEMOD_DVBAPI
-void aml_demod_exit(void)
-#else
-static void __exit aml_demod_exit(void)
-#endif
-{
-	pr_dbg("Amlogic Demod DVB-T/C DebugIF Exit\n");
-
-	unregister_chrdev_region(aml_demod_devno, 1);
-	device_destroy(&aml_demod_class, MKDEV(MAJOR(aml_demod_devno), 0));
-	cdev_del(aml_demod_cdevp);
-	kfree(aml_demod_cdevp);
-
-	/*   free_irq(INT_DEMOD, (void *)aml_demod_dev_id); */
-
-	class_unregister(&aml_demod_class);
-
-	aml_demod_exit_ui();
-}
-
-#ifndef CONFIG_AM_DEMOD_DVBAPI
-module_init(aml_demod_init);
-module_exit(aml_demod_exit);
-
-MODULE_LICENSE("GPL");
-/*MODULE_AUTHOR(DRV_AUTHOR);*/
-/*MODULE_DESCRIPTION(DRV_DESC);*/
-#endif
diff --git a/drivers/amlogic/dvb_tv/amldemod/amlfrontend.c b/drivers/amlogic/dvb_tv/amldemod/amlfrontend.c
deleted file mode 100644
index f58b2d470398..000000000000
--- a/drivers/amlogic/dvb_tv/amldemod/amlfrontend.c
+++ /dev/null
@@ -1,1318 +0,0 @@
-/*****************************************************************
-**
-**  Copyright (C) 2009 Amlogic,Inc.
-**  All rights reserved
-**        Filename : amlfrontend.c
-**
-**  comment:
-**        Driver for m6_demod demodulator
-**  author :
-**	    Shijie.Rong@amlogic
-**  version :
-**	    v1.0	 12/3/13
-**          v2.0     15/10/12
-*****************************************************************/
-
-/*
- *  Driver for gxtv_demod demodulator
- */
-
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/string.h>
-#include <linux/delay.h>
-#include <linux/jiffies.h>
-#include <linux/slab.h>
-#include <linux/platform_device.h>
-#ifdef ARC_700
-#include <asm/arch/am_regs.h>
-#else
-/* #include <mach/am_regs.h> */
-#endif
-#include <linux/i2c.h>
-#include <linux/gpio.h>
-#include "../aml_fe.h"
-
-#include <linux/dvb/aml_demod.h>
-#include "demod_func.h"
-#include "../aml_dvb.h"
-#include "amlfrontend.h"
-
-MODULE_PARM_DESC(debug_aml, "\n\t\t Enable frontend debug information");
-static int debug_aml;
-module_param(debug_aml, int, 0644);
-
-#define pr_dbg(a ...) \
-	do { \
-		if (debug_aml) { \
-			printk(a); \
-		} \
-	} while (0)
-#define pr_error(fmt, args ...) pr_err("GXTV_DEMOD: "fmt, ## args)
-
-static int last_lock = -1;
-#define DEMOD_DEVICE_NAME  "gxtv_demod"
-static int cci_thread;
-static int freq_dvbc;
-static struct aml_demod_sta demod_status;
-static fe_modulation_t atsc_mode = VSB_8;
-
-long *mem_buf;
-
-MODULE_PARM_DESC(frontend_mode, "\n\t\t Frontend mode 0-DVBC, 1-DVBT");
-static int frontend_mode = -1;
-module_param(frontend_mode, int, S_IRUGO);
-
-MODULE_PARM_DESC(frontend_i2c, "\n\t\t IIc adapter id of frontend");
-static int frontend_i2c = -1;
-module_param(frontend_i2c, int, S_IRUGO);
-
-MODULE_PARM_DESC(frontend_tuner,
-		 "\n\t\t Frontend tuner type 0-NULL, 1-DCT7070, 2-Maxliner, 3-FJ2207, 4-TD1316");
-static int frontend_tuner = -1;
-module_param(frontend_tuner, int, S_IRUGO);
-
-MODULE_PARM_DESC(frontend_tuner_addr, "\n\t\t Tuner IIC address of frontend");
-static int frontend_tuner_addr = -1;
-module_param(frontend_tuner_addr, int, S_IRUGO);
-static int autoflags, autoFlagsTrig;
-static struct mutex aml_lock;
-
-static int Gxtv_Demod_Dvbc_Init(struct aml_fe_dev *dev, int mode);
-
-static ssize_t dvbc_auto_sym_show(struct class *cls,
-				  struct class_attribute *attr, char *buf)
-{
-	return sprintf(buf, "dvbc_autoflags: %s\n", autoflags ? "on" : "off");
-}
-
-static ssize_t dvbc_auto_sym_store(struct class *cls,
-				   struct class_attribute *attr,
-				   const char *buf, size_t count)
-{
-
-	return 0;
-}
-
-static unsigned dtmb_mode;
-
-enum {
-	DTMB_READ_STRENGTH = 0,
-	DTMB_READ_SNR = 1,
-	DTMB_READ_LOCK = 2,
-	DTMB_READ_BCH = 3,
-};
-
-
-
-int convert_snr(int in_snr)
-{
-	int out_snr;
-	static int calce_snr[40] = {
-		5, 6, 8, 10, 13,
-		16, 20, 25, 32, 40,
-		50, 63, 80, 100, 126,
-		159, 200, 252, 318, 400,
-		504, 634, 798, 1005, 1265,
-		1592, 2005, 2524, 3177, 4000,
-		5036, 6340, 7981, 10048, 12649,
-		15924, 20047, 25238, 31773, 40000};
-	for (out_snr = 1 ; out_snr <= 40; out_snr++)
-		if (in_snr <= calce_snr[out_snr])
-			break;
-
-	return out_snr;
-}
-
-
-static ssize_t dtmb_para_show(struct class *cls,
-				  struct class_attribute *attr, char *buf)
-{
-	int snr, lock_status, bch, agc_if_gain;
-	struct dvb_frontend *dvbfe;
-	int strength = 0;
-	if (dtmb_mode == DTMB_READ_STRENGTH) {
-		dvbfe = get_si2177_tuner();
-		if (dvbfe != NULL)
-			if (dvbfe->ops.tuner_ops.get_strength) {
-				strength =
-				dvbfe->ops.tuner_ops.get_strength(dvbfe);
-			}
-		if (strength <= -56) {
-			agc_if_gain =
-				((dtmb_read_reg(DTMB_TOP_FRONT_AGC))&0x3ff);
-			strength = dtmb_get_power_strength(agc_if_gain);
-		}
-		return sprintf(buf, "strength is %d\n", strength);
-	} else if (dtmb_mode == DTMB_READ_SNR) {
-		snr = dtmb_read_reg(DTMB_TOP_FEC_LOCK_SNR) & 0x3fff;
-		snr = convert_snr(snr);
-		return sprintf(buf, "snr is %d\n", snr);
-	} else if (dtmb_mode == DTMB_READ_LOCK) {
-		lock_status =
-			(dtmb_read_reg(DTMB_TOP_FEC_LOCK_SNR) >> 14) & 0x1;
-		return sprintf(buf, "lock_status is %d\n", lock_status);
-	} else if (dtmb_mode == DTMB_READ_BCH) {
-		bch = dtmb_read_reg(DTMB_TOP_FEC_BCH_ACC);
-		return sprintf(buf, "bch is %d\n", bch);
-	} else {
-		return sprintf(buf, "dtmb_para_show can't match mode\n");
-	}
-}
-
-
-
-static ssize_t dtmb_para_store(struct class *cls,
-				   struct class_attribute *attr,
-				   const char *buf, size_t count)
-{
-	if (buf[0] == '0')
-		dtmb_mode = DTMB_READ_STRENGTH;
-	else if (buf[0] == '1')
-		dtmb_mode = DTMB_READ_SNR;
-	else if (buf[0] == '2')
-		dtmb_mode = DTMB_READ_LOCK;
-	else if (buf[0] == '3')
-		dtmb_mode = DTMB_READ_BCH;
-
-	return count;
-}
-
-static int readregdata;
-
-static ssize_t dvbc_reg_show(struct class *cls, struct class_attribute *attr,
-			     char *buf)
-{
-/*      int readregaddr=0;*/
-	char *pbuf = buf;
-
-	pbuf += sprintf(pbuf, "%x", readregdata);
-
-	pr_dbg("read dvbc_reg\n");
-	return pbuf - buf;
-}
-
-static ssize_t dvbc_reg_store(struct class *cls, struct class_attribute *attr,
-			      const char *buf, size_t count)
-{
-	return 0;
-}
-
-static CLASS_ATTR(auto_sym, 0644, dvbc_auto_sym_show, dvbc_auto_sym_store);
-static CLASS_ATTR(dtmb_para, 0644, dtmb_para_show, dtmb_para_store);
-static CLASS_ATTR(dvbc_reg, 0666, dvbc_reg_show, dvbc_reg_store);
-
-#if 0
-static irqreturn_t amdemod_isr(int irq, void *data)
-{
-/*	struct aml_fe_dev *state = data;
- *
- * #define dvb_isr_islock() (((frontend_mode==0)&&dvbc_isr_islock()) \
- * ||((frontend_mode==1)&&dvbt_isr_islock()))
- * #define dvb_isr_monitor() do {\
- *              if(frontend_mode==1) dvbt_isr_monitor(); }while(0)
- * #define dvb_isr_cancel() do { if(frontend_mode==1) dvbt_isr_cancel(); \
- *              else if(frontend_mode==0) dvbc_isr_cancel();}while(0)
- *
- *      dvb_isr_islock();
- *      {
- *              if(waitqueue_active(&state->lock_wq))
- *                      wake_up_interruptible(&state->lock_wq);
- *      }
- *
- *      dvb_isr_monitor();
- *
- *      dvb_isr_cancel();*/
-
-	return IRQ_HANDLED;
-}
-#endif
-
-static int install_isr(struct aml_fe_dev *state)
-{
-	int r = 0;
-
-	/* hook demod isr */
-/*	pr_dbg("amdemod irq register[IRQ(%d)].\n", INT_DEMOD);
- *      r = request_irq(INT_DEMOD, &amdemod_isr,
- *                              IRQF_SHARED, "amldemod",
- *                              (void *)state);
- *      if (r) {
- *              pr_error("amdemod irq register error.\n");
- *      }*/
-	return r;
-}
-
-static void uninstall_isr(struct aml_fe_dev *state)
-{
-/*      pr_dbg("amdemod irq unregister[IRQ(%d)].\n", INT_DEMOD);*/
-
-/*      free_irq(INT_DEMOD, (void*)state);*/
-}
-
-static int amdemod_qam(fe_modulation_t qam)
-{
-	switch (qam) {
-	case QAM_16:
-		return 0;
-	case QAM_32:
-		return 1;
-	case QAM_64:
-		return 2;
-	case QAM_128:
-		return 3;
-	case QAM_256:
-		return 4;
-	case VSB_8:
-		return 5;
-	case QAM_AUTO:
-		return 6;
-	default:
-		return 2;
-	}
-	return 2;
-}
-
-static int amdemod_stat_islock(struct aml_fe_dev *dev, int mode)
-{
-	struct aml_demod_sts demod_sts;
-	int lock_status;
-	int dvbt_status1;
-
-	if (mode == 0) {
-		/*DVBC*/
-		/*dvbc_status(state->sta, state->i2c, &demod_sts);*/
-		demod_sts.ch_sts = apb_read_reg(QAM_BASE + 0x18);
-		return demod_sts.ch_sts & 0x1;
-	} else if (mode == 1) {
-		/*DVBT*/
-		dvbt_status1 =
-			((apb_read_reg(DVBT_BASE + (0x0a << 2)) >> 20) & 0x3ff);
-		lock_status = (apb_read_reg(DVBT_BASE + (0x2a << 2))) & 0xf;
-		if ((((lock_status) == 9) || ((lock_status) == 10))
-		    && ((dvbt_status1) != 0))
-			return 1;
-		else
-			return 0;
-		/*((apb_read_reg(DVBT_BASE+0x0)>>12)&0x1);//
-		 * dvbt_get_status_ops()->get_status(&demod_sts, &demod_sta);*/
-	} else if (mode == 2) {
-		/*ISDBT*/
-		/*return dvbt_get_status_ops()->get_status
-		 * (demod_sts, demod_sta);*/
-	} else if (mode == 3) {
-		/*ATSC*/
-		if ((atsc_mode == QAM_64) || (atsc_mode == QAM_256))
-			return (atsc_read_iqr_reg() >> 16) == 0x1f;
-		else if (atsc_mode == VSB_8)
-			return atsc_read_reg(0x0980) == 0x79;
-		else
-			return (atsc_read_iqr_reg() >> 16) == 0x1f;
-	} else if (mode == 4) {
-		/*DTMB*/
-	/*	pr_dbg("DTMB lock status is %u\n",
-		       ((dtmb_read_reg(DTMB_BASE + (0x0e3 << 2)) >> 14) &
-			0x1));*/
-		return (dtmb_read_reg(DTMB_BASE + (0x0e3 << 2)) >> 14) & 0x1;
-	}
-	return 0;
-}
-
-#define amdemod_dvbc_stat_islock(dev)  amdemod_stat_islock((dev), 0)
-#define amdemod_dvbt_stat_islock(dev)  amdemod_stat_islock((dev), 1)
-#define amdemod_isdbt_stat_islock(dev)  amdemod_stat_islock((dev), 2)
-#define amdemod_atsc_stat_islock(dev)  amdemod_stat_islock((dev), 3)
-#define amdemod_dtmb_stat_islock(dev)  amdemod_stat_islock((dev), 4)
-
-static int gxtv_demod_dvbc_set_qam_mode(struct dvb_frontend *fe)
-{
-	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
-	struct aml_demod_dvbc param;    /*mode 0:16, 1:32, 2:64, 3:128, 4:256*/
-
-	memset(&param, 0, sizeof(param));
-	param.mode = amdemod_qam(c->modulation);
-	dvbc_set_qam_mode(param.mode);
-	return 0;
-}
-
-static void gxtv_demod_dvbc_release(struct dvb_frontend *fe)
-{
-	struct aml_fe_dev *state = fe->demodulator_priv;
-
-	uninstall_isr(state);
-
-	kfree(state);
-}
-
-static int gxtv_demod_dvbc_read_status
-	(struct dvb_frontend *fe, fe_status_t *status)
-{
-/*      struct aml_fe_dev *dev = afe->dtv_demod;*/
-	struct aml_demod_sts demod_sts;
-/*      struct aml_demod_sta demod_sta;*/
-/*      struct aml_demod_i2c demod_i2c;*/
-	int ilock;
-
-	demod_sts.ch_sts = apb_read_reg(QAM_BASE + 0x18);
-/*      dvbc_status(&demod_sta, &demod_i2c, &demod_sts);*/
-	if (demod_sts.ch_sts & 0x1) {
-		ilock = 1;
-		*status =
-			FE_HAS_LOCK | FE_HAS_SIGNAL | FE_HAS_CARRIER |
-			FE_HAS_VITERBI | FE_HAS_SYNC;
-	} else {
-		ilock = 0;
-		*status = FE_TIMEDOUT;
-	}
-	if (last_lock != ilock) {
-		pr_error("%s.\n",
-			 ilock ? "!!  >> LOCK << !!" : "!! >> UNLOCK << !!");
-		last_lock = ilock;
-	}
-
-	return 0;
-}
-
-static int gxtv_demod_dvbc_read_ber(struct dvb_frontend *fe, u32 *ber)
-{
-	/*struct aml_fe_dev *dev = afe->dtv_demod;*/
-	struct aml_demod_sts demod_sts;
-	struct aml_demod_i2c demod_i2c;
-	struct aml_demod_sta demod_sta;
-
-	dvbc_status(&demod_sta, &demod_i2c, &demod_sts);
-	*ber = demod_sts.ch_ber;
-	return 0;
-}
-
-static int gxtv_demod_dvbc_read_signal_strength
-	(struct dvb_frontend *fe, u16 *strength)
-{
-	struct aml_fe *afe = fe->demodulator_priv;
-	struct aml_fe_dev *dev = afe->dtv_demod;
-
-	*strength = 256 - tuner_get_ch_power(dev);
-
-	return 0;
-}
-
-static int gxtv_demod_dvbc_read_snr(struct dvb_frontend *fe, u16 *snr)
-{
-	struct aml_demod_sts demod_sts;
-	struct aml_demod_i2c demod_i2c;
-	struct aml_demod_sta demod_sta;
-
-	dvbc_status(&demod_sta, &demod_i2c, &demod_sts);
-	*snr = demod_sts.ch_snr / 100;
-	return 0;
-}
-
-static int gxtv_demod_dvbc_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)
-{
-	*ucblocks = 0;
-	return 0;
-}
-
-/*extern int aml_fe_analog_set_frontend(struct dvb_frontend *fe);*/
-
-static int gxtv_demod_dvbc_set_frontend(struct dvb_frontend *fe)
-{
-	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
-	struct aml_demod_dvbc param;    /*mode 0:16, 1:32, 2:64, 3:128, 4:256*/
-	struct aml_demod_sts demod_sts;
-	struct aml_demod_i2c demod_i2c;
-	struct aml_fe *afe = fe->demodulator_priv;
-	struct aml_fe_dev *dev = afe->dtv_demod;
-	int error, times;
-
-	demod_i2c.tuner = dev->drv->id;
-	demod_i2c.addr = dev->i2c_addr;
-	times = 2;
-	memset(&param, 0, sizeof(param));
-	param.ch_freq = c->frequency / 1000;
-	param.mode = amdemod_qam(c->modulation);
-	param.symb_rate = c->symbol_rate / 1000;
-	if ((param.mode == 3) && (demod_status.tmp != Adc_mode)) {
-		Gxtv_Demod_Dvbc_Init(dev, Adc_mode);
-		pr_dbg("Gxtv_Demod_Dvbc_Init,Adc_mode\n");
-	} else {
-		/*Gxtv_Demod_Dvbc_Init(dev,Cry_mode);*/
-	}
-	if (autoflags == 0) {
-		/*pr_dbg("QAM_TUNING mode\n");*/
-		/*flag=0;*/
-	}
-	if ((autoflags == 1) && (autoFlagsTrig == 0)
-	    && (freq_dvbc == param.ch_freq)) {
-		pr_dbg("now is auto symbrating\n");
-		return 0;
-	}
-	autoFlagsTrig = 0;
-	last_lock = -1;
-	pr_dbg("[gxtv_demod_dvbc_set_frontend]PARA\t"
-	       "demod_i2c.tuner is %d||||demod_i2c.addr is %d||||\t"
-	       "param.ch_freq is %d||||param.symb_rate is %d,\t"
-	       "param.mode is %d\n",
-	       demod_i2c.tuner, demod_i2c.addr, param.ch_freq,
-	       param.symb_rate, param.mode);
-retry:
-	aml_dmx_before_retune(afe->ts, fe);
-	aml_fe_analog_set_frontend(fe);
-	dvbc_set_ch(&demod_status, &demod_i2c, &param);
-	if (autoflags == 1) {
-		pr_dbg("QAM_PLAYING mode,start auto sym\n");
-		dvbc_set_auto_symtrack();
-		/*      flag=1;*/
-	}
-/*rsj_debug*/
-
-	dvbc_status(&demod_status, &demod_i2c, &demod_sts);
-	freq_dvbc = param.ch_freq;
-
-	times--;
-	if (amdemod_dvbc_stat_islock(dev) && times) {
-		int lock;
-
-		aml_dmx_start_error_check(afe->ts, fe);
-		msleep(20);
-		error = aml_dmx_stop_error_check(afe->ts, fe);
-		lock = amdemod_dvbc_stat_islock(dev);
-		if ((error > 200) || !lock) {
-			pr_error
-				("amlfe too many error, error count:%d\t"
-				"lock statuc:%d, retry\n",
-				error, lock);
-			goto retry;
-		}
-	}
-
-	aml_dmx_after_retune(afe->ts, fe);
-
-	afe->params = *c;
-/*	afe->params.frequency = c->frequency;
- *      afe->params.u.qam.symbol_rate = c->symbol_rate;
- *      afe->params.u.qam.modulation = c->modulation;*/
-
-	pr_dbg("AML amldemod => frequency=%d,symbol_rate=%d\r\n", c->frequency,
-	       c->symbol_rate);
-	return 0;
-}
-
-static int gxtv_demod_dvbc_get_frontend(struct dvb_frontend *fe)
-{                               /*these content will be writed into eeprom .*/
-	struct aml_fe *afe = fe->demodulator_priv;
-	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
-	int qam_mode;
-
-	qam_mode = apb_read_reg(QAM_BASE + 0x008);
-	afe->params.modulation = (qam_mode & 7) + 1;
-	pr_dbg("[mode] is %d\n", afe->params.modulation);
-
-	*c = afe->params;
-/*	c->modulation= afe->params.u.qam.modulation;
- *      c->frequency= afe->params.frequency;
- *      c->symbol_rate= afe->params.u.qam.symbol_rate;*/
-	return 0;
-}
-
-static int Gxtv_Demod_Dvbc_Init(struct aml_fe_dev *dev, int mode)
-{
-	struct aml_demod_sys sys;
-	struct aml_demod_i2c i2c;
-
-	pr_dbg("AML Demod DVB-C init\r\n");
-	memset(&sys, 0, sizeof(sys));
-	memset(&i2c, 0, sizeof(i2c));
-	i2c.tuner = dev->drv->id;
-	i2c.addr = dev->i2c_addr;
-	/* 0 -DVBC, 1-DVBT, ISDBT, 2-ATSC*/
-	demod_status.dvb_mode = Gxtv_Dvbc;
-
-	if (mode == Adc_mode) {
-		sys.adc_clk = Adc_Clk_25M;
-		sys.demod_clk = Demod_Clk_200M;
-		demod_status.tmp = Adc_mode;
-	} else {
-		sys.adc_clk = Adc_Clk_24M;
-		sys.demod_clk = Demod_Clk_72M;
-		demod_status.tmp = Cry_mode;
-	}
-	demod_status.ch_if = Si2176_5M_If * 1000;
-	pr_dbg("[%s]adc_clk is %d,demod_clk is %d\n", __func__, sys.adc_clk,
-	       sys.demod_clk);
-	autoFlagsTrig = 0;
-	demod_set_sys(&demod_status, &i2c, &sys);
-	return 0;
-}
-
-static void gxtv_demod_dvbt_release(struct dvb_frontend *fe)
-{
-	struct aml_fe_dev *state = fe->demodulator_priv;
-
-	uninstall_isr(state);
-
-	kfree(state);
-}
-
-static int gxtv_demod_dvbt_read_status
-	(struct dvb_frontend *fe, fe_status_t *status)
-{
-/*      struct aml_fe *afe = fe->demodulator_priv;*/
-	struct aml_demod_i2c demod_i2c;
-	struct aml_demod_sta demod_sta;
-	int ilock;
-	unsigned char s = 0;
-
-	s = dvbt_get_status_ops()->get_status(&demod_sta, &demod_i2c);
-	if (s == 1) {
-		ilock = 1;
-		*status =
-			FE_HAS_LOCK | FE_HAS_SIGNAL | FE_HAS_CARRIER |
-			FE_HAS_VITERBI | FE_HAS_SYNC;
-	} else {
-		ilock = 0;
-		*status = FE_TIMEDOUT;
-	}
-	if (last_lock != ilock) {
-		pr_error("%s.\n",
-			 ilock ? "!!  >> LOCK << !!" : "!! >> UNLOCK << !!");
-		last_lock = ilock;
-	}
-
-	return 0;
-}
-
-static int gxtv_demod_dvbt_read_ber(struct dvb_frontend *fe, u32 *ber)
-{
-/*      struct aml_fe *afe = fe->demodulator_priv;*/
-	struct aml_demod_i2c demod_i2c;
-	struct aml_demod_sta demod_sta;
-
-	*ber = dvbt_get_status_ops()->get_ber(&demod_sta, &demod_i2c) & 0xffff;
-	return 0;
-}
-
-static int gxtv_demod_dvbt_read_signal_strength
-	(struct dvb_frontend *fe, u16 *strength)
-{
-	struct aml_fe *afe = fe->demodulator_priv;
-	struct aml_fe_dev *dev = afe->dtv_demod;
-
-	*strength = 256 - tuner_get_ch_power(dev);
-	pr_dbg("[RSJ]tuner strength is %d dbm\n", *strength);
-	return 0;
-}
-
-static int gxtv_demod_dvbt_read_snr(struct dvb_frontend *fe, u16 *snr)
-{
-/*      struct aml_fe *afe = fe->demodulator_priv;*/
-/*      struct aml_demod_sts demod_sts;*/
-	struct aml_demod_i2c demod_i2c;
-	struct aml_demod_sta demod_sta;
-
-	*snr = dvbt_get_status_ops()->get_snr(&demod_sta, &demod_i2c);
-	*snr /= 8;
-	pr_dbg("[RSJ]snr is %d dbm\n", *snr);
-	return 0;
-}
-
-static int gxtv_demod_dvbt_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)
-{
-	*ucblocks = 0;
-	return 0;
-}
-
-static int gxtv_demod_dvbt_set_frontend(struct dvb_frontend *fe)
-{
-	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
-	/*struct aml_demod_sts demod_sts;*/
-	struct aml_demod_i2c demod_i2c;
-	int error, times;
-	struct aml_demod_dvbt param;
-	struct aml_fe *afe = fe->demodulator_priv;
-	struct aml_fe_dev *dev = afe->dtv_demod;
-
-	demod_i2c.tuner = dev->drv->id;
-	demod_i2c.addr = dev->i2c_addr;
-
-	times = 2;
-
-	/*////////////////////////////////////*/
-	/* bw == 0 : 8M*/
-	/*       1 : 7M*/
-	/*       2 : 6M*/
-	/*       3 : 5M*/
-	/* agc_mode == 0: single AGC*/
-	/*             1: dual AGC*/
-	/*////////////////////////////////////*/
-	memset(&param, 0, sizeof(param));
-	param.ch_freq = c->frequency / 1000;
-	param.bw = c->bandwidth_hz;
-	param.agc_mode = 1;
-	/*ISDBT or DVBT : 0 is QAM, 1 is DVBT, 2 is ISDBT,
-	 * 3 is DTMB, 4 is ATSC */
-	param.dat0 = 1;
-	last_lock = -1;
-
-retry:
-	aml_dmx_before_retune(AM_TS_SRC_TS2, fe);
-	aml_fe_analog_set_frontend(fe);
-	dvbt_set_ch(&demod_status, &demod_i2c, &param);
-
-	/*      for(count=0;count<10;count++){
-	 * if(amdemod_dvbt_stat_islock(dev)){
-	 * pr_dbg("first lock success\n");
-	 * break;
-	 * }
-	 *
-	 * msleep(200);
-	 * }    */
-/*rsj_debug*/
-
-/**/
-
-	times--;
-	if (amdemod_dvbt_stat_islock(dev) && times) {
-		int lock;
-
-		aml_dmx_start_error_check(AM_TS_SRC_TS2, fe);
-		msleep(20);
-		error = aml_dmx_stop_error_check(AM_TS_SRC_TS2, fe);
-		lock = amdemod_dvbt_stat_islock(dev);
-		if ((error > 200) || !lock) {
-			pr_error
-				("amlfe too many error,\t"
-				"error count:%d lock statuc:%d, retry\n",
-				error, lock);
-			goto retry;
-		}
-	}
-
-	aml_dmx_after_retune(AM_TS_SRC_TS2, fe);
-
-	afe->params = *c;
-
-	/*pr_dbg("AML amldemod => frequency=%d,symbol_rate=%d\r\n",
-	 * p->frequency,p->u.qam.symbol_rate);*/
-	return 0;
-}
-
-static int gxtv_demod_dvbt_get_frontend(struct dvb_frontend *fe)
-{                               /*these content will be writed into eeprom .*/
-	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
-	struct aml_fe *afe = fe->demodulator_priv;
-
-	*c = afe->params;
-	return 0;
-}
-
-int Gxtv_Demod_Dvbt_Init(struct aml_fe_dev *dev)
-{
-	struct aml_demod_sys sys;
-	struct aml_demod_i2c i2c;
-
-	pr_dbg("AML Demod DVB-T init\r\n");
-
-	memset(&sys, 0, sizeof(sys));
-	memset(&i2c, 0, sizeof(i2c));
-	memset(&demod_status, 0, sizeof(demod_status));
-	i2c.tuner = dev->drv->id;
-	i2c.addr = dev->i2c_addr;
-	/* 0 -DVBC, 1-DVBT, ISDBT, 2-ATSC*/
-	demod_status.dvb_mode = Gxtv_Dvbt_Isdbt;
-	sys.adc_clk = Adc_Clk_24M;
-	sys.demod_clk = Demod_Clk_60M;
-	demod_status.ch_if = Si2176_5M_If * 1000;
-	demod_set_sys(&demod_status, &i2c, &sys);
-	return 0;
-}
-
-static void gxtv_demod_atsc_release(struct dvb_frontend *fe)
-{
-	struct aml_fe_dev *state = fe->demodulator_priv;
-
-	uninstall_isr(state);
-
-	kfree(state);
-}
-
-static int gxtv_demod_atsc_set_qam_mode(struct dvb_frontend *fe)
-{
-	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
-	struct aml_demod_atsc param;    /*mode  3:64,  5:256, 7:vsb*/
-	fe_modulation_t mode;
-
-	memset(&param, 0, sizeof(param));
-	mode = c->modulation;
-	pr_dbg("mode is %d\n", mode);
-	atsc_qam_set(mode);
-	return 0;
-}
-
-static int gxtv_demod_atsc_read_status
-	(struct dvb_frontend *fe, fe_status_t *status)
-{
-	struct aml_fe *afe = fe->demodulator_priv;
-	struct aml_fe_dev *dev = afe->dtv_demod;
-/*      struct aml_demod_i2c demod_i2c;*/
-/*      struct aml_demod_sta demod_sta;*/
-	int ilock;
-	unsigned char s = 0;
-
-	s = amdemod_atsc_stat_islock(dev);
-	if (s == 1) {
-		ilock = 1;
-		*status =
-			FE_HAS_LOCK | FE_HAS_SIGNAL | FE_HAS_CARRIER |
-			FE_HAS_VITERBI | FE_HAS_SYNC;
-	} else {
-		ilock = 0;
-		*status = FE_TIMEDOUT;
-	}
-	if (last_lock != ilock) {
-		pr_error("%s.\n",
-			 ilock ? "!!  >> LOCK << !!" : "!! >> UNLOCK << !!");
-		last_lock = ilock;
-	}
-
-	return 0;
-}
-
-static int gxtv_demod_atsc_read_ber(struct dvb_frontend *fe, u32 *ber)
-{
-/*      struct aml_fe *afe = fe->demodulator_priv;*/
-/*      struct aml_fe_dev *dev = afe->dtv_demod;*/
-/*      struct aml_demod_sts demod_sts;*/
-/*      struct aml_demod_i2c demod_i2c;*/
-/*      struct aml_demod_sta demod_sta;*/
-
-/* check_atsc_fsm_status();*/
-	return 0;
-}
-
-static int gxtv_demod_atsc_read_signal_strength
-	(struct dvb_frontend *fe, u16 *strength)
-{
-	struct aml_fe *afe = fe->demodulator_priv;
-	struct aml_fe_dev *dev = afe->dtv_demod;
-
-	*strength = tuner_get_ch_power(dev);
-	return 0;
-}
-
-static int gxtv_demod_atsc_read_snr(struct dvb_frontend *fe, u16 *snr)
-{
-/*      struct aml_fe *afe = fe->demodulator_priv;*/
-/*      struct aml_fe_dev *dev = afe->dtv_demod;*/
-
-/*      struct aml_demod_sts demod_sts;*/
-/*      struct aml_demod_i2c demod_i2c;*/
-/*      struct aml_demod_sta demod_sta;*/
-
-/*      * snr=check_atsc_fsm_status();*/
-	return 0;
-}
-
-static int gxtv_demod_atsc_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)
-{
-	*ucblocks = 0;
-	return 0;
-}
-
-static int gxtv_demod_atsc_set_frontend(struct dvb_frontend *fe)
-{
-/*      struct amlfe_state *state = fe->demodulator_priv;*/
-	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
-	struct aml_demod_atsc param;
-/*      struct aml_demod_sta demod_sta;*/
-/*      struct aml_demod_sts demod_sts;*/
-	struct aml_demod_i2c demod_i2c;
-	int error, times;
-	struct aml_fe *afe = fe->demodulator_priv;
-	struct aml_fe_dev *dev = afe->dtv_demod;
-
-	demod_i2c.tuner = dev->drv->id;
-	demod_i2c.addr = dev->i2c_addr;
-	times = 2;
-
-	memset(&param, 0, sizeof(param));
-	param.ch_freq = c->frequency / 1000;
-
-	last_lock = -1;
-	/*p->u.vsb.modulation=QAM_64;*/
-	atsc_mode = c->modulation;
-	/* param.mode = amdemod_qam(p->u.vsb.modulation);*/
-	param.mode = c->modulation;
-
-retry:
-	aml_dmx_before_retune(AM_TS_SRC_TS2, fe);
-	aml_fe_analog_set_frontend(fe);
-	atsc_set_ch(&demod_status, &demod_i2c, &param);
-
-	/*{
-	 * int ret;
-	 * ret = wait_event_interruptible_timeout(
-	 *              dev->lock_wq, amdemod_atsc_stat_islock(dev), 4*HZ);
-	 * if(!ret)     pr_error("amlfe wait lock timeout.\n");
-	 * } */
-/*rsj_debug*/
-	/*      int count;
-	 * for(count=0;count<10;count++){
-	 * if(amdemod_atsc_stat_islock(dev)){
-	 * pr_dbg("first lock success\n");
-	 * break;
-	 * }
-	 *
-	 * msleep(200);
-	 * }    */
-
-	times--;
-	if (amdemod_atsc_stat_islock(dev) && times) {
-		int lock;
-
-		aml_dmx_start_error_check(AM_TS_SRC_TS2, fe);
-		msleep(20);
-		error = aml_dmx_stop_error_check(AM_TS_SRC_TS2, fe);
-		lock = amdemod_atsc_stat_islock(dev);
-		if ((error > 200) || !lock) {
-			pr_error
-				("amlfe too many error,\t"
-				"error count:%d lock statuc:%d, retry\n",
-				error, lock);
-			goto retry;
-		}
-	}
-
-	aml_dmx_after_retune(AM_TS_SRC_TS2, fe);
-
-	afe->params = *c;
-	/*pr_dbg("AML amldemod => frequency=%d,symbol_rate=%d\r\n",
-	 * p->frequency,p->u.qam.symbol_rate);*/
-	return 0;
-}
-
-static int gxtv_demod_atsc_get_frontend(struct dvb_frontend *fe)
-{                               /*these content will be writed into eeprom .*/
-	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
-	struct aml_fe *afe = fe->demodulator_priv;
-
-	pr_dbg("c->frequency is %d\n", c->frequency);
-	*c = afe->params;
-	return 0;
-}
-
-int Gxtv_Demod_Atsc_Init(struct aml_fe_dev *dev)
-{
-	struct aml_demod_sys sys;
-	struct aml_demod_i2c i2c;
-
-	pr_dbg("AML Demod ATSC init\r\n");
-
-	memset(&sys, 0, sizeof(sys));
-	memset(&i2c, 0, sizeof(i2c));
-	memset(&demod_status, 0, sizeof(demod_status));
-	/* 0 -DVBC, 1-DVBT, ISDBT, 2-ATSC*/
-	demod_status.dvb_mode = Gxtv_Atsc;
-	sys.adc_clk = Adc_Clk_25_2M;    /*Adc_Clk_26M;*/
-	sys.demod_clk = Demod_Clk_75M;  /*Demod_Clk_71M;//Demod_Clk_78M;*/
-	demod_status.ch_if = 6350;
-	demod_status.tmp = Adc_mode;
-	demod_set_sys(&demod_status, &i2c, &sys);
-	return 0;
-}
-
-static void gxtv_demod_dtmb_release(struct dvb_frontend *fe)
-{
-	struct aml_fe_dev *state = fe->demodulator_priv;
-
-	uninstall_isr(state);
-
-	kfree(state);
-}
-
-static int gxtv_demod_dtmb_read_status
-	(struct dvb_frontend *fe, fe_status_t *status)
-{
-	struct aml_fe *afe = fe->demodulator_priv;
-	struct aml_fe_dev *dev = afe->dtv_demod;
-/*      struct aml_demod_i2c demod_i2c;*/
-/*      struct aml_demod_sta demod_sta;*/
-	int ilock;
-	unsigned char s = 0;
-
-/*      s = amdemod_dtmb_stat_islock(dev);*/
-/*      if(s==1)*/
-	if (is_meson_txl_cpu())
-		s = dtmb_check_status_txl(fe);
-	else
-		s = dtmb_check_status_gxtv(fe);
-	s = amdemod_dtmb_stat_islock(dev);
-/*      s=1;*/
-	if (s == 1) {
-		ilock = 1;
-		*status =
-			FE_HAS_LOCK | FE_HAS_SIGNAL | FE_HAS_CARRIER |
-			FE_HAS_VITERBI | FE_HAS_SYNC;
-	} else {
-		ilock = 0;
-		*status = FE_TIMEDOUT;
-	}
-	if (last_lock != ilock) {
-		pr_error("%s.\n",
-			 ilock ? "!!  >> LOCK << !!" : "!! >> UNLOCK << !!");
-		last_lock = ilock;
-	}
-
-	return 0;
-}
-
-static int gxtv_demod_dtmb_read_ber(struct dvb_frontend *fe, u32 *ber)
-{
-/*      struct aml_fe *afe = fe->demodulator_priv;*/
-/*      struct aml_fe_dev *dev = afe->dtv_demod;*/
-/*      struct aml_demod_sts demod_sts;*/
-/*      struct aml_demod_i2c demod_i2c;*/
-/*      struct aml_demod_sta demod_sta;*/
-
-/* check_atsc_fsm_status();*/
-/* int fec_bch_add; */
-/* fec_bch_add = dtmb_read_reg(0xdf); */
-/* *ber = fec_bch_add; */
-	return 0;
-}
-
-static int gxtv_demod_dtmb_read_signal_strength
-		(struct dvb_frontend *fe, u16 *strength)
-{
-	struct aml_fe *afe = fe->demodulator_priv;
-	struct aml_fe_dev *dev = afe->dtv_demod;
-
-	*strength = tuner_get_ch_power(dev);
-	return 0;
-}
-
-static int gxtv_demod_dtmb_read_snr(struct dvb_frontend *fe, u16 *snr)
-{
-/*      struct aml_fe *afe = fe->demodulator_priv;*/
-/*      struct aml_fe_dev *dev = afe->dtv_demod;*/
-#if 1
-	int tmp, snr_avg;
-	tmp = snr_avg = 0;
-	tmp = dtmb_read_reg(DTMB_TOP_FEC_LOCK_SNR);
-/*	snr_avg = (tmp >> 16) & 0x3fff;
-	if (snr_avg >= 2048)
-		snr_avg = snr_avg - 4096;
-	snr_avg = snr_avg / 32;*/
-	*snr = tmp&0xff;
-#endif
-	return 0;
-}
-
-static int gxtv_demod_dtmb_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)
-{
-	*ucblocks = 0;
-	return 0;
-}
-
-static int gxtv_demod_dtmb_read_fsm(struct dvb_frontend *fe, u32 *fsm_status)
-{
-	int tmp;
-	tmp = dtmb_read_reg(DTMB_TOP_CTRL_FSM_STATE0);
-	*fsm_status =  tmp&0xffffffff;
-	pr_dbg("[rsj] fsm_status is %x\n", *fsm_status);
-	return 0;
-}
-
-
-static int gxtv_demod_dtmb_set_frontend(struct dvb_frontend *fe)
-{
-	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
-	struct aml_demod_dtmb param;
-/*      struct aml_demod_sta demod_sta;*/
-/*      struct aml_demod_sts demod_sts;*/
-	struct aml_demod_i2c demod_i2c;
-	int times;
-	struct aml_fe *afe = fe->demodulator_priv;
-	struct aml_fe_dev *dev = afe->dtv_demod;
-
-	demod_i2c.tuner = dev->drv->id;
-	demod_i2c.addr = dev->i2c_addr;
-	times = 2;
-	pr_dbg("gxtv_demod_dtmb_set_frontend,freq is %d\n", c->frequency);
-	memset(&param, 0, sizeof(param));
-	param.ch_freq = c->frequency / 1000;
-
-	last_lock = -1;
-/* demod_power_switch(PWR_OFF); */
-	aml_fe_analog_set_frontend(fe);
-	msleep(100);
-/* demod_power_switch(PWR_ON); */
-	dtmb_set_ch(&demod_status, &demod_i2c, &param);
-	afe->params = *c;
-	/*      pr_dbg("AML amldemod => frequency=%d,symbol_rate=%d\r\n",
-	 * p->frequency,p->u.qam.symbol_rate);*/
-	return 0;
-}
-
-static int gxtv_demod_dtmb_get_frontend(struct dvb_frontend *fe)
-{                               /*these content will be writed into eeprom .*/
-	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
-	struct aml_fe *afe = fe->demodulator_priv;
-
-	*c = afe->params;
-/*      pr_dbg("[get frontend]c->frequency is %d\n",c->frequency);*/
-	return 0;
-}
-
-int Gxtv_Demod_Dtmb_Init(struct aml_fe_dev *dev)
-{
-	struct aml_demod_sys sys;
-	struct aml_demod_i2c i2c;
-	pr_dbg("AML Demod DTMB init\r\n");
-
-	memset(&sys, 0, sizeof(sys));
-	memset(&i2c, 0, sizeof(i2c));
-	memset(&demod_status, 0, sizeof(demod_status));
-	/* 0 -DVBC, 1-DVBT, ISDBT, 2-ATSC*/
-	demod_status.dvb_mode = Gxtv_Dtmb;
-	if (is_meson_txl_cpu()) {
-		sys.adc_clk = Adc_Clk_25M;      /*Adc_Clk_26M;*/
-		sys.demod_clk = Demod_Clk_225M;
-	} else {
-		sys.adc_clk = Adc_Clk_25M;      /*Adc_Clk_26M;*/
-		sys.demod_clk = Demod_Clk_200M;
-	}
-	demod_status.ch_if = Si2176_5M_If;
-	demod_status.tmp = Adc_mode;
-	demod_status.spectrum = dev->spectrum;
-	demod_set_sys(&demod_status, &i2c, &sys);
-	return 0;
-}
-
-static int gxtv_demod_fe_get_ops(struct aml_fe_dev *dev, int mode, void *ops)
-{
-	struct dvb_frontend_ops *fe_ops = (struct dvb_frontend_ops *)ops;
-
-	if (mode == AM_FE_OFDM) {
-		fe_ops->info.frequency_min = 51000000;
-		fe_ops->info.frequency_max = 858000000;
-		fe_ops->info.frequency_stepsize = 0;
-		fe_ops->info.frequency_tolerance = 0;
-		fe_ops->info.caps =
-			FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |
-			FE_CAN_FEC_5_6 | FE_CAN_FEC_7_8 | FE_CAN_FEC_AUTO |
-			FE_CAN_QPSK | FE_CAN_QAM_16 | FE_CAN_QAM_64 |
-			FE_CAN_QAM_AUTO | FE_CAN_TRANSMISSION_MODE_AUTO |
-			FE_CAN_GUARD_INTERVAL_AUTO | FE_CAN_HIERARCHY_AUTO |
-			FE_CAN_RECOVER | FE_CAN_MUTE_TS;
-		fe_ops->release = gxtv_demod_dvbt_release;
-		fe_ops->set_frontend = gxtv_demod_dvbt_set_frontend;
-		fe_ops->get_frontend = gxtv_demod_dvbt_get_frontend;
-		fe_ops->read_status = gxtv_demod_dvbt_read_status;
-		fe_ops->read_ber = gxtv_demod_dvbt_read_ber;
-		fe_ops->read_signal_strength =
-			gxtv_demod_dvbt_read_signal_strength;
-		fe_ops->read_snr = gxtv_demod_dvbt_read_snr;
-		fe_ops->read_ucblocks = gxtv_demod_dvbt_read_ucblocks;
-
-		pr_dbg("=========================dvbt demod init\r\n");
-		Gxtv_Demod_Dvbt_Init(dev);
-	} else if (mode == AM_FE_QAM) {
-		fe_ops->info.frequency_min = 51000000;
-		fe_ops->info.frequency_max = 858000000;
-		fe_ops->info.frequency_stepsize = 0;
-		fe_ops->info.frequency_tolerance = 0;
-		fe_ops->info.caps =
-			FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |
-			FE_CAN_FEC_5_6 | FE_CAN_FEC_7_8 | FE_CAN_FEC_AUTO |
-			FE_CAN_QPSK | FE_CAN_QAM_16 | FE_CAN_QAM_32 |
-			FE_CAN_QAM_128 | FE_CAN_QAM_256 | FE_CAN_QAM_64 |
-			FE_CAN_QAM_AUTO | FE_CAN_TRANSMISSION_MODE_AUTO |
-			FE_CAN_GUARD_INTERVAL_AUTO | FE_CAN_HIERARCHY_AUTO |
-			FE_CAN_RECOVER | FE_CAN_MUTE_TS;
-
-		fe_ops->release = gxtv_demod_dvbc_release;
-		fe_ops->set_frontend = gxtv_demod_dvbc_set_frontend;
-		fe_ops->get_frontend = gxtv_demod_dvbc_get_frontend;
-		fe_ops->read_status = gxtv_demod_dvbc_read_status;
-		fe_ops->read_ber = gxtv_demod_dvbc_read_ber;
-		fe_ops->read_signal_strength =
-			gxtv_demod_dvbc_read_signal_strength;
-		fe_ops->read_snr = gxtv_demod_dvbc_read_snr;
-		fe_ops->read_ucblocks = gxtv_demod_dvbc_read_ucblocks;
-		fe_ops->set_qam_mode = gxtv_demod_dvbc_set_qam_mode;
-		install_isr(dev);
-		pr_dbg("=========================dvbc demod init\r\n");
-		Gxtv_Demod_Dvbc_Init(dev, Adc_mode);
-	} else if (mode == AM_FE_ATSC) {
-		fe_ops->info.frequency_min = 51000000;
-		fe_ops->info.frequency_max = 858000000;
-		fe_ops->info.frequency_stepsize = 0;
-		fe_ops->info.frequency_tolerance = 0;
-		fe_ops->info.caps =
-			FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |
-			FE_CAN_FEC_5_6 | FE_CAN_FEC_7_8 | FE_CAN_FEC_AUTO |
-			FE_CAN_QPSK | FE_CAN_QAM_16 | FE_CAN_QAM_64 |
-			FE_CAN_QAM_AUTO | FE_CAN_TRANSMISSION_MODE_AUTO |
-			FE_CAN_GUARD_INTERVAL_AUTO | FE_CAN_HIERARCHY_AUTO |
-			FE_CAN_RECOVER | FE_CAN_MUTE_TS;
-
-		fe_ops->release = gxtv_demod_atsc_release;
-		fe_ops->set_frontend = gxtv_demod_atsc_set_frontend;
-		fe_ops->get_frontend = gxtv_demod_atsc_get_frontend;
-		fe_ops->read_status = gxtv_demod_atsc_read_status;
-		fe_ops->read_ber = gxtv_demod_atsc_read_ber;
-		fe_ops->read_signal_strength =
-			gxtv_demod_atsc_read_signal_strength;
-		fe_ops->read_snr = gxtv_demod_atsc_read_snr;
-		fe_ops->read_ucblocks = gxtv_demod_atsc_read_ucblocks;
-		fe_ops->set_qam_mode = gxtv_demod_atsc_set_qam_mode;
-		Gxtv_Demod_Atsc_Init(dev);
-	} else if (mode == AM_FE_DTMB) {
-		fe_ops->info.frequency_min = 51000000;
-		fe_ops->info.frequency_max = 900000000;
-		fe_ops->info.frequency_stepsize = 0;
-		fe_ops->info.frequency_tolerance = 0;
-		fe_ops->info.caps =
-			FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |
-			FE_CAN_FEC_5_6 | FE_CAN_FEC_7_8 | FE_CAN_FEC_AUTO |
-			FE_CAN_QPSK | FE_CAN_QAM_16 | FE_CAN_QAM_64 |
-			FE_CAN_QAM_AUTO | FE_CAN_TRANSMISSION_MODE_AUTO |
-			FE_CAN_GUARD_INTERVAL_AUTO | FE_CAN_HIERARCHY_AUTO |
-			FE_CAN_RECOVER | FE_CAN_MUTE_TS;
-
-		fe_ops->release = gxtv_demod_dtmb_release;
-		fe_ops->set_frontend = gxtv_demod_dtmb_set_frontend;
-		fe_ops->get_frontend = gxtv_demod_dtmb_get_frontend;
-		fe_ops->read_status = gxtv_demod_dtmb_read_status;
-		fe_ops->read_ber = gxtv_demod_dtmb_read_ber;
-		fe_ops->read_signal_strength =
-			gxtv_demod_dtmb_read_signal_strength;
-		fe_ops->read_snr = gxtv_demod_dtmb_read_snr;
-		fe_ops->read_ucblocks = gxtv_demod_dtmb_read_ucblocks;
-		fe_ops->read_dtmb_fsm = gxtv_demod_dtmb_read_fsm;
-		Gxtv_Demod_Dtmb_Init(dev);
-	}
-	return 0;
-}
-
-static int gxtv_demod_fe_resume(struct aml_fe_dev *dev)
-{
-	pr_dbg("gxtv_demod_fe_resume\n");
-/*	demod_power_switch(PWR_ON);*/
-	Gxtv_Demod_Dtmb_Init(dev);
-	return 0;
-}
-
-static int gxtv_demod_fe_suspend(struct aml_fe_dev *dev)
-{
-	pr_dbg("gxtv_demod_fe_suspend\n");
-/*	demod_power_switch(PWR_OFF);*/
-	return 0;
-}
-
-static int gxtv_demod_fe_enter_mode(struct aml_fe *fe, int mode)
-{
-	struct aml_fe_dev *dev = fe->dtv_demod;
-	int memstart_dtmb;
-
-	/* must enable the adc ref signal for demod, */
-	vdac_enable(1, 0x2);
-
-	autoFlagsTrig = 1;
-	if (cci_thread)
-		if (dvbc_get_cci_task() == 1)
-			dvbc_create_cci_task();
-	memstart_dtmb = fe->dtv_demod->mem_start;
-	pr_dbg("[im]memstart is %x\n", memstart_dtmb);
-	/*mem_buf = (long *)phys_to_virt(memstart);*/
-	if (mode == AM_FE_DTMB) {
-		Gxtv_Demod_Dtmb_Init(dev);
-		dtmb_write_reg(DTMB_FRONT_MEM_ADDR, memstart_dtmb);
-		pr_dbg("[dtmb]mem_buf is 0x%x\n",
-			dtmb_read_reg(DTMB_FRONT_MEM_ADDR));
-	} else if (mode == AM_FE_QAM) {
-		Gxtv_Demod_Dvbc_Init(dev, Adc_mode);
-	}
-
-	return 0;
-}
-
-static int gxtv_demod_fe_leave_mode(struct aml_fe *fe, int mode)
-{
-	dtvpll_init_flag(0);
-	/*dvbc_timer_exit();*/
-	if (cci_thread)
-		dvbc_kill_cci_task();
-
-	/* should disable the adc ref signal for demod */
-	vdac_enable(0, 0x2);
-
-	return 0;
-}
-
-static struct aml_fe_drv gxtv_demod_dtv_demod_drv = {
-	.id		= AM_DTV_DEMOD_M1,
-	.name		= "AMLDEMOD",
-	.capability	=
-		AM_FE_QPSK | AM_FE_QAM | AM_FE_ATSC | AM_FE_OFDM | AM_FE_DTMB,
-	.get_ops	= gxtv_demod_fe_get_ops,
-	.suspend	= gxtv_demod_fe_suspend,
-	.resume		= gxtv_demod_fe_resume,
-	.enter_mode	= gxtv_demod_fe_enter_mode,
-	.leave_mode	= gxtv_demod_fe_leave_mode
-};
-
-struct class *gxtv_clsp;
-struct class *gxtv_para_clsp;
-
-static int __init gxtvdemodfrontend_init(void)
-{
-	int ret;
-
-	pr_dbg("register gxtv_demod demod driver\n");
-	ret = 0;
-
-	dtvpll_lock_init();
-	mutex_init(&aml_lock);
-
-	gxtv_clsp = class_create(THIS_MODULE, DEMOD_DEVICE_NAME);
-	if (!gxtv_clsp) {
-		pr_error("[gxtv demod]%s:create class error.\n", __func__);
-		return PTR_ERR(gxtv_clsp);
-	}
-	ret = class_create_file(gxtv_clsp, &class_attr_auto_sym);
-	if (ret)
-		pr_error("[gxtv demod]%s create class error.\n", __func__);
-
-	ret = class_create_file(gxtv_clsp, &class_attr_dtmb_para);
-	if (ret)
-		pr_error("[gxtv demod]%s create class error.\n", __func__);
-
-	ret = class_create_file(gxtv_clsp, &class_attr_dvbc_reg);
-	if (ret)
-		pr_error("[gxtv demod]%s create class error.\n", __func__);
-
-	return aml_register_fe_drv(AM_DEV_DTV_DEMOD, &gxtv_demod_dtv_demod_drv);
-}
-
-static void __exit gxtvdemodfrontend_exit(void)
-{
-	pr_dbg("unregister gxtv_demod demod driver\n");
-
-	mutex_destroy(&aml_lock);
-
-	class_remove_file(gxtv_clsp, &class_attr_auto_sym);
-	class_remove_file(gxtv_clsp, &class_attr_dtmb_para);
-	class_remove_file(gxtv_clsp, &class_attr_dvbc_reg);
-	class_destroy(gxtv_clsp);
-	aml_unregister_fe_drv(AM_DEV_DTV_DEMOD, &gxtv_demod_dtv_demod_drv);
-}
-
-fs_initcall(gxtvdemodfrontend_init);
-module_exit(gxtvdemodfrontend_exit);
-
-MODULE_DESCRIPTION("gxtv_demod DVB-T/DVB-C/DTMB Demodulator driver");
-MODULE_AUTHOR("RSJ");
-MODULE_LICENSE("GPL");
diff --git a/drivers/amlogic/dvb_tv/amldemod/demod_func.c b/drivers/amlogic/dvb_tv/amldemod/demod_func.c
deleted file mode 100644
index 405886109fef..000000000000
--- a/drivers/amlogic/dvb_tv/amldemod/demod_func.c
+++ /dev/null
@@ -1,2852 +0,0 @@
-/*#include "register.h"*/
-/*#include "c_arc_pointer_reg.h"*/
-/*#include "a9_func.h"*/
-/*#include "clk_util.h"*/
-/*#include "c_stimulus.h"*/
-/*#include "a9_l2_func.h"*/
-
-#include "demod_func.h"
-#include <linux/dvb/aml_demod.h>
-#include <linux/string.h>
-#include <linux/kernel.h>
-#include "acf_filter_coefficient.h"
-#include <linux/mutex.h>
-
-#define M6D
-
-/* static void __iomem * demod_meson_reg_map[4]; */
-
-#define pr_dbg(fmt, args ...) \
-	do { \
-		if (debug_demod) \
-			pr_info("FE: " fmt, ## args); \
-	} while (0)
-#define pr_error(fmt, args ...) printk("FE: " fmt, ## args)
-
-MODULE_PARM_DESC(debug_demod, "\n\t\t Enable frontend debug information");
-static int debug_demod;
-module_param(debug_demod, int, 0644);
-
-MODULE_PARM_DESC(demod_timeout, "\n\t\t timeout debug information");
-static int demod_timeout = 120;
-module_param(demod_timeout, int, 0644);
-
-MODULE_PARM_DESC(demod_sync_count, "\n\t\t timeout debug information");
-static int demod_sync_count = 60;
-module_param(demod_sync_count, int, 0644);
-
-MODULE_PARM_DESC(demod_sync_delay_time, "\n\t\t timeout debug information");
-static int demod_sync_delay_time = 8;
-module_param(demod_sync_delay_time, int, 0644);
-
-
-
-MODULE_PARM_DESC(demod_mobile_power, "\n\t\t demod_mobile_power debug information");
-static int demod_mobile_power = 100;
-module_param(demod_mobile_power, int, 0644);
-
-MODULE_PARM_DESC(demod_enable_performance, "\n\t\t demod_enable_performance information");
-static int demod_enable_performance = 1;
-module_param(demod_enable_performance, int, 0644);
-
-
-static struct mutex mp;
-static struct mutex dtvpll_init_lock;
-static int dtvpll_init;
-static int dtmb_spectrum = 2;
-
-
-/* 8vsb */
-static struct atsc_cfg list_8vsb[22] = {
-	{0x0733, 0x00, 0},
-	{0x0734, 0xff, 0},
-	{0x0716, 0x02, 0},	/* F06[7] invert spectrum  0x02 0x06 */
-	{0x05e7, 0x00, 0},
-	{0x05e8, 0x00, 0},
-	{0x0f06, 0x80, 0},
-	{0x0f09, 0x04, 0},
-	{0x070c, 0x18, 0},
-	{0x070d, 0x9d, 0},
-	{0x070e, 0x89, 0},
-	{0x070f, 0x6a, 0},
-	{0x0710, 0x75, 0},
-	{0x0711, 0x6f, 0},
-	{0x072a, 0x02, 0},
-	{0x072c, 0x02, 0},
-	{0x090d, 0x03, 0},
-	{0x090e, 0x02, 0},
-	{0x090f, 0x00, 0},
-	{0x0900, 0x01, 0},
-	{0x0900, 0x00, 0},
-	{0x0f00, 0x01, 0},
-	{0x0000, 0x00, 1}
-};
-
-/* 64qam */
-static struct atsc_cfg list_qam64[111] = {
-	{0x0900, 0x01, 0},
-	{0x0f04, 0x08, 0},
-	{0x0f06, 0x80, 0},
-	{0x0f07, 0x00, 0},
-	{0x0f00, 0xe0, 0},
-	{0x0f00, 0xec, 0},
-	{0x0001, 0x05, 0},
-	{0x0002, 0x61, 0},	/* /0x61 invert spectrum */
-	{0x0003, 0x3e, 0},
-	{0x0004, 0xed, 0},	/* 0x9d */
-	{0x0005, 0x10, 0},
-	{0x0006, 0xc0, 0},
-	{0x0007, 0x5c, 0},
-	{0x0008, 0x0f, 0},
-	{0x0009, 0x4f, 0},
-	{0x000a, 0xfc, 0},
-	{0x000b, 0x0c, 0},
-	{0x000c, 0x6c, 0},
-	{0x000d, 0x3a, 0},
-	{0x000e, 0x10, 0},
-	{0x000f, 0x02, 0},
-	{0x0011, 0x00, 0},
-	{0x0012, 0xf5, 0},
-	{0x0013, 0x74, 0},
-	{0x0014, 0xb9, 0},
-	{0x0015, 0x1f, 0},
-	{0x0016, 0x80, 0},
-	{0x0017, 0x1f, 0},
-	{0x0018, 0x0f, 0},
-	{0x001e, 0x00, 0},
-	{0x001f, 0x00, 0},
-	{0x0023, 0x03, 0},
-	{0x0025, 0x20, 0},
-	{0x0026, 0xff, 0},
-	{0x0027, 0xff, 0},
-	{0x0028, 0xf8, 0},
-	{0x0200, 0x20, 0},
-	{0x0201, 0x62, 0},
-	{0x0202, 0x23, 0},
-	{0x0204, 0x19, 0},
-	{0x0205, 0x74, 0},
-	{0x0206, 0xab, 0},
-	{0x0207, 0xff, 0},
-	{0x0208, 0xc0, 0},
-	{0x0209, 0xff, 0},
-	{0x0211, 0xc0, 0},
-	{0x0212, 0xb0, 0},
-	{0x0213, 0x05, 0},
-	{0x0215, 0x08, 0},
-	{0x0222, 0xe0, 0},
-	{0x0223, 0xf0, 0},
-	{0x0226, 0x40, 0},
-	{0x0229, 0x23, 0},
-	{0x022a, 0x02, 0},
-	{0x022c, 0x01, 0},
-	{0x022e, 0x01, 0},
-	{0x022f, 0x25, 0},
-	{0x0230, 0x40, 0},
-	{0x0231, 0x01, 0},
-	{0x0734, 0xff, 0},
-	{0x073a, 0xff, 0},
-	{0x073b, 0x04, 0},
-	{0x073c, 0x08, 0},
-	{0x073d, 0x08, 0},
-	{0x073e, 0x01, 0},
-	{0x073f, 0xf8, 0},
-	{0x0740, 0xf1, 0},
-	{0x0741, 0xf3, 0},
-	{0x0742, 0xff, 0},
-	{0x0743, 0x0f, 0},
-	{0x0744, 0x1a, 0},
-	{0x0745, 0x16, 0},
-	{0x0746, 0x00, 0},
-	{0x0747, 0xe3, 0},
-	{0x0748, 0xce, 0},
-	{0x0749, 0xd4, 0},
-	{0x074a, 0x00, 0},
-	{0x074b, 0x4b, 0},
-	{0x074c, 0x00, 0},
-	{0x074d, 0xa2, 0},
-	{0x074e, 0x00, 0},
-	{0x074f, 0xe6, 0},
-	{0x0750, 0x00, 0},
-	{0x0751, 0x00, 0},
-	{0x0752, 0x01, 0},
-	{0x0753, 0x03, 0},
-	{0x0400, 0x00, 0},
-	{0x0408, 0x04, 0},
-	{0x040e, 0xe0, 0},
-	{0x0500, 0x02, 0},
-	{0x05e7, 0x00, 0},
-	{0x05e8, 0x00, 0},
-	{0x0f09, 0x18, 0},
-	{0x070c, 0x20, 0},
-	{0x070d, 0x41, 0},	/* 0x49 */
-	{0x070e, 0x04, 0},	/* 0x37 */
-	{0x070f, 0x00, 0},
-	{0x0710, 0x00, 0},
-	{0x0711, 0x00, 0},
-	{0x0716, 0xf0, 0},
-	{0x090f, 0x00, 0},
-	{0x0900, 0x01, 1},
-	{0x0900, 0x00, 0},
-	{0x0001, 0xf5, 0},
-	{0x0001, 0xf5, 1},
-	{0x0001, 0xf5, 1},
-	{0x0001, 0xf5, 1},
-	{0x0001, 0xf5, 1},
-	{0x0001, 0x05, 0},
-	{0x0001, 0x05, 1},
-	{0x0000, 0x00, 1}
-};
-
-/* 256qam */
-static struct atsc_cfg list_qam256[113] = {
-	{0x0900, 0x01, 0},
-	{0x0f04, 0x08, 0},
-	{0x0f06, 0x80, 0},
-	{0x0f00, 0xe0, 0},
-	{0x0f00, 0xec, 0},
-	{0x0001, 0x05, 0},
-	{0x0002, 0x01, 0},	/* 0x09 */
-	{0x0003, 0x2c, 0},
-	{0x0004, 0x91, 0},
-	{0x0005, 0x10, 0},
-	{0x0006, 0xc0, 0},
-	{0x0007, 0x5c, 0},
-	{0x0008, 0x0f, 0},
-	{0x0009, 0x4f, 0},
-	{0x000a, 0xfc, 0},
-	{0x000b, 0x0c, 0},
-	{0x000c, 0x6c, 0},
-	{0x000d, 0x3a, 0},
-	{0x000e, 0x10, 0},
-	{0x000f, 0x02, 0},
-	{0x0011, 0x80, 0},
-	{0x0012, 0xf5, 0},	/* a5 */
-	{0x0013, 0x74, 0},
-	{0x0014, 0xb9, 0},
-	{0x0015, 0x1f, 0},
-	{0x0016, 0x80, 0},
-	{0x0017, 0x1f, 0},
-	{0x0018, 0x0f, 0},
-	{0x001e, 0x00, 0},
-	{0x001f, 0x00, 0},
-	{0x0023, 0x03, 0},
-	{0x0025, 0x20, 0},
-	{0x0026, 0xff, 0},
-	{0x0027, 0xff, 0},
-	{0x0028, 0xf8, 0},
-	{0x0200, 0x20, 0},
-	{0x0201, 0x62, 0},
-	{0x0202, 0x23, 0},
-	{0x0204, 0x19, 0},
-	{0x0205, 0x76, 0},
-	{0x0206, 0xd2, 0},
-	{0x0207, 0xff, 0},
-	{0x0208, 0xc0, 0},
-	{0x0209, 0xff, 0},
-	{0x0211, 0xc0, 0},
-	{0x0212, 0xb0, 0},
-	{0x0213, 0x05, 0},
-	{0x0215, 0x08, 0},
-	{0x0222, 0xf0, 0},
-	{0x0223, 0xff, 0},
-	{0x0226, 0x40, 0},
-	{0x0229, 0x23, 0},
-	{0x022a, 0x02, 0},
-	{0x022c, 0x01, 0},
-	{0x022e, 0x01, 0},
-	{0x022f, 0x05, 0},
-	{0x0230, 0x40, 0},
-	{0x0231, 0x01, 0},
-	{0x0400, 0x02, 0},
-	{0x0401, 0x30, 0},
-	{0x0402, 0x13, 0},
-	{0x0406, 0x06, 0},
-	{0x0408, 0x04, 0},
-	{0x040e, 0xe0, 0},
-	{0x0411, 0x02, 0},
-	{0x073a, 0x02, 0},
-	{0x073b, 0x09, 0},
-	{0x073c, 0x0c, 0},
-	{0x073d, 0x08, 0},
-	{0x073e, 0xfd, 0},
-	{0x073f, 0xf2, 0},
-	{0x0740, 0xed, 0},
-	{0x0741, 0xf4, 0},
-	{0x0742, 0x03, 0},
-	{0x0743, 0x15, 0},
-	{0x0744, 0x1d, 0},
-	{0x0745, 0x15, 0},
-	{0x0746, 0xfc, 0},
-	{0x0747, 0xde, 0},
-	{0x0748, 0xcc, 0},
-	{0x0749, 0xd6, 0},
-	{0x074a, 0x04, 0},
-	{0x074b, 0x4f, 0},
-	{0x074c, 0x00, 0},
-	{0x074d, 0xa2, 0},
-	{0x074e, 0x00, 0},
-	{0x074f, 0xe3, 0},
-	{0x0750, 0x00, 0},
-	{0x0751, 0xfc, 0},
-	{0x0752, 0x00, 0},
-	{0x0753, 0x03, 0},
-	{0x0500, 0x02, 0},
-	{0x05e7, 0x00, 0},
-	{0x05e8, 0x00, 0},
-	{0x0f09, 0x18, 0},
-	{0x070c, 0x20, 0},
-	{0x070d, 0x49, 0},
-	{0x070e, 0x37, 0},
-	{0x070f, 0x00, 0},
-	{0x0710, 0x00, 0},
-	{0x0711, 0x00, 0},
-	{0x0716, 0xf0, 0},
-	{0x090f, 0x00, 0},
-	{0x0900, 0x01, 1},
-	{0x0900, 0x00, 0},
-	{0x0001, 0xf5, 0},
-	{0x0001, 0xf5, 1},
-	{0x0001, 0xf5, 1},
-	{0x0001, 0xf5, 1},
-	{0x0001, 0xf5, 1},
-	{0x0001, 0x05, 0},
-	{0x0001, 0x05, 1},
-	{0x0000, 0x00, 1}
-};
-
-void dtvpll_lock_init(void)
-{
-	mutex_init(&dtvpll_init_lock);
-}
-
-void dtvpll_init_flag(int on)
-{
-	mutex_lock(&dtvpll_init_lock);
-	dtvpll_init = on;
-	mutex_unlock(&dtvpll_init_lock);
-	pr_err("%s %d\n", __func__, on);
-}
-
-int get_dtvpll_init_flag(void)
-{
-	int val;
-	mutex_lock(&dtvpll_init_lock);
-	val = dtvpll_init;
-	mutex_unlock(&dtvpll_init_lock);
-	if (!val)
-		pr_err("%s: %d\n", __func__, val);
-	return val;
-}
-
-void adc_dpll_setup(int clk_a, int clk_b, int clk_sys)
-{
-	int unit, found, ena, enb, div2;
-	int pll_m, pll_n, pll_od_a, pll_od_b, pll_xd_a, pll_xd_b;
-	long freq_osc, freq_dco, freq_b, freq_a, freq_sys;
-	long freq_b_act, freq_a_act, freq_sys_act, err_tmp, best_err;
-	union adc_pll_cntl adc_pll_cntl;
-	union adc_pll_cntl2 adc_pll_cntl2;
-	union adc_pll_cntl3 adc_pll_cntl3;
-	union adc_pll_cntl4 adc_pll_cntl4;
-	union demod_dig_clk dig_clk_cfg;
-
-	adc_pll_cntl.d32 = 0;
-	adc_pll_cntl2.d32 = 0;
-	adc_pll_cntl3.d32 = 0;
-	adc_pll_cntl4.d32 = 0;
-
-	pr_dbg("target clk_a %d  clk_b %d\n", clk_a, clk_b);
-
-	unit = 10000;		/* 10000 as 1 MHz, 0.1 kHz resolution. */
-	freq_osc = 24 * unit;
-
-	if (clk_a < 1000)
-		freq_a = clk_a * unit;
-	else
-		freq_a = clk_a * (unit / 1000);
-
-	if (clk_b < 1000)
-		freq_b = clk_b * unit;
-	else
-		freq_b = clk_b * (unit / 1000);
-
-	ena = clk_a > 0 ? 1 : 0;
-	enb = clk_b > 0 ? 1 : 0;
-
-	if (ena || enb)
-		adc_pll_cntl3.b.enable = 1;
-	adc_pll_cntl3.b.reset = 1;
-
-	found = 0;
-	best_err = 100 * unit;
-	pll_od_a = 1;
-	pll_od_b = 1;
-	pll_n = 1;
-	for (pll_m = 1; pll_m < 512; pll_m++) {
-		/* for (pll_n=1; pll_n<=5; pll_n++) { */
-		if (is_meson_txl_cpu()) {
-			freq_dco = freq_osc * pll_m / pll_n / 2;/*txl add div2*/
-			if (freq_dco < 700 * unit || freq_dco > 1000 * unit)
-				continue;
-		} else {
-			freq_dco = freq_osc * pll_m / pll_n;
-			if (freq_dco < 750 * unit || freq_dco > 1550 * unit)
-				continue;
-		}
-		pll_xd_a = freq_dco / (1 << pll_od_a) / freq_a;
-		pll_xd_b = freq_dco / (1 << pll_od_b) / freq_b;
-
-		freq_a_act = freq_dco / (1 << pll_od_a) / pll_xd_a;
-		freq_b_act = freq_dco / (1 << pll_od_b) / pll_xd_b;
-
-		err_tmp = (freq_a_act - freq_a) * ena + (freq_b_act - freq_b) *
-		    enb;
-
-		if (err_tmp >= best_err)
-			continue;
-
-		adc_pll_cntl.b.pll_m = pll_m;
-		adc_pll_cntl.b.pll_n = pll_n;
-		adc_pll_cntl.b.pll_od0 = pll_od_b;
-		adc_pll_cntl.b.pll_od1 = pll_od_a;
-		adc_pll_cntl.b.pll_xd0 = pll_xd_b;
-		adc_pll_cntl.b.pll_xd1 = pll_xd_a;
-		if (is_meson_txl_cpu()) {
-			adc_pll_cntl4.b.pll_od3 = 0;
-			adc_pll_cntl.b.pll_od2 = 0;
-		} else {
-			adc_pll_cntl2.b.div2_ctrl =
-				freq_dco > 1000 * unit ? 1 : 0;
-		}
-		found = 1;
-		best_err = err_tmp;
-		/* } */
-	}
-
-	pll_m = adc_pll_cntl.b.pll_m;
-	pll_n = adc_pll_cntl.b.pll_n;
-	pll_od_b = adc_pll_cntl.b.pll_od0;
-	pll_od_a = adc_pll_cntl.b.pll_od1;
-	pll_xd_b = adc_pll_cntl.b.pll_xd0;
-	pll_xd_a = adc_pll_cntl.b.pll_xd1;
-
-	if (is_meson_txl_cpu())
-		div2 = 1;
-	else
-		div2 = adc_pll_cntl2.b.div2_ctrl;
-	/*
-	 * p_adc_pll_cntl  =  adc_pll_cntl.d32;
-	 * p_adc_pll_cntl2 = adc_pll_cntl2.d32;
-	 * p_adc_pll_cntl3 = adc_pll_cntl3.d32;
-	 * p_adc_pll_cntl4 = adc_pll_cntl4.d32;
-	 */
-	adc_pll_cntl3.b.reset = 0;
-	/* *p_adc_pll_cntl3 = adc_pll_cntl3.d32; */
-	if (!found) {
-		pr_dbg(" ERROR can't setup %7ld kHz %7ld kHz\n",
-		       freq_b / (unit / 1000), freq_a / (unit / 1000));
-	} else {
-		if (is_meson_txl_cpu())
-			freq_dco = freq_osc * pll_m / pll_n / 2;
-		else
-			freq_dco = freq_osc * pll_m / pll_n;
-		pr_dbg(" ADC PLL  M %3d   N %3d\n", pll_m, pll_n);
-		pr_dbg(" ADC PLL DCO %ld kHz\n", freq_dco / (unit / 1000));
-
-		pr_dbg(" ADC PLL XD %3d  OD %3d\n", pll_xd_b, pll_od_b);
-		pr_dbg(" ADC PLL XD %3d  OD %3d\n", pll_xd_a, pll_od_a);
-
-		freq_a_act = freq_dco / (1 << pll_od_a) / pll_xd_a;
-		freq_b_act = freq_dco / (1 << pll_od_b) / pll_xd_b;
-
-		pr_dbg(" B %7ld kHz %7ld kHz\n",
-		       freq_b / (unit / 1000), freq_b_act / (unit / 1000));
-		pr_dbg(" A %7ld kHz %7ld kHz\n",
-		       freq_a / (unit / 1000), freq_a_act / (unit / 1000));
-
-		if (clk_sys > 0) {
-			dig_clk_cfg.b.demod_clk_en = 1;
-			dig_clk_cfg.b.demod_clk_sel = 3;
-			if (clk_sys < 1000)
-				freq_sys = clk_sys * unit;
-			else
-				freq_sys = clk_sys * (unit / 1000);
-
-			dig_clk_cfg.b.demod_clk_div = freq_dco / (1 + div2) /
-			    freq_sys - 1;
-			freq_sys_act = freq_dco / (1 + div2) /
-			    (dig_clk_cfg.b.demod_clk_div + 1);
-			pr_dbg(" SYS %7ld kHz div %d+1  %7ld kHz\n",
-			       freq_sys / (unit / 1000),
-			       dig_clk_cfg.b.demod_clk_div,
-			       freq_sys_act / (unit / 1000));
-		} else {
-			dig_clk_cfg.b.demod_clk_en = 0;
-		}
-
-		/* *p_demod_dig_clk = dig_clk_cfg.d32; */
-	}
-	if (is_meson_txl_cpu()) {
-		demod_set_demod_reg(TXLTV_ADC_RESET_VALUE, ADC_REG3);
-		demod_set_demod_reg(adc_pll_cntl.d32, ADC_REG1);
-		demod_set_demod_reg(dig_clk_cfg.d32, ADC_REG6);
-		demod_set_demod_reg(TXLTV_ADC_REG3_VALUE, ADC_REG3);
-		/* debug */
-		pr_dbg("[adc][%x]%x\n", ADC_REG1,
-				demod_read_demod_reg(ADC_REG1));
-		pr_dbg("[adc][%x]%x\n", ADC_REG2,
-				demod_read_demod_reg(ADC_REG2));
-		pr_dbg("[adc][%x]%x\n", ADC_REG3,
-				demod_read_demod_reg(ADC_REG3));
-		pr_dbg("[adc][%x]%x\n", ADC_REG4,
-				demod_read_demod_reg(ADC_REG4));
-		pr_dbg("[adc][%x]%x\n", ADC_REG5,
-				demod_read_demod_reg(ADC_REG5));
-		pr_dbg("[adc][%x]%x\n", ADC_REG6,
-				demod_read_demod_reg(ADC_REG6));
-		pr_dbg("[adc][%x]%x\n", ADC_REG7,
-				demod_read_demod_reg(ADC_REG7));
-		pr_dbg("[adc][%x]%x\n", ADC_REG8,
-				demod_read_demod_reg(ADC_REG8));
-		pr_dbg("[adc][%x]%x\n", ADC_REG9,
-				demod_read_demod_reg(ADC_REG9));
-		pr_dbg("[adc][%x]%x\n", ADC_REGB,
-				demod_read_demod_reg(ADC_REGB));
-		pr_dbg("[adc][%x]%x\n", ADC_REGC,
-				demod_read_demod_reg(ADC_REGC));
-		pr_dbg("[adc][%x]%x\n", ADC_REGD,
-				demod_read_demod_reg(ADC_REGD));
-		pr_dbg("[adc][%x]%x\n", ADC_REGE,
-				demod_read_demod_reg(ADC_REGE));
-		pr_dbg("[demod][%x]%x\n", DEMOD_REG1,
-				demod_read_demod_reg(DEMOD_REG1));
-		pr_dbg("[demod][%x]%x\n", DEMOD_REG2,
-				demod_read_demod_reg(DEMOD_REG2));
-		pr_dbg("[demod][%x]%x\n", DEMOD_REG3,
-				demod_read_demod_reg(DEMOD_REG3));
-	} else {
-		demod_set_demod_reg(ADC_RESET_VALUE, ADC_REG3);	/* adc reset */
-		demod_set_demod_reg(adc_pll_cntl.d32, ADC_REG1);
-		demod_set_demod_reg(dig_clk_cfg.d32, ADC_REG6);
-		demod_set_demod_reg(ADC_REG3_VALUE, ADC_REG3);
-		/* debug */
-		pr_dbg("[adc][%x]%x\n", ADC_REG1,
-				demod_read_demod_reg(ADC_REG1));
-		pr_dbg("[adc][%x]%x\n", ADC_REG2,
-				demod_read_demod_reg(ADC_REG2));
-		pr_dbg("[adc][%x]%x\n", ADC_REG3,
-				demod_read_demod_reg(ADC_REG3));
-		pr_dbg("[adc][%x]%x\n", ADC_REG4,
-				demod_read_demod_reg(ADC_REG4));
-		pr_dbg("[adc][%x]%x\n", ADC_REG6,
-				demod_read_demod_reg(ADC_REG6));
-		pr_dbg("[demod][%x]%x\n", DEMOD_REG1,
-				demod_read_demod_reg(DEMOD_REG1));
-		pr_dbg("[demod][%x]%x\n", DEMOD_REG2,
-				demod_read_demod_reg(DEMOD_REG2));
-		pr_dbg("[demod][%x]%x\n", DEMOD_REG3,
-				demod_read_demod_reg(DEMOD_REG3));
-	}
-	dtvpll_init_flag(1);
-}
-
-void demod_set_adc_core_clk(int adc_clk, int sys_clk, int dvb_mode)
-{
-	adc_dpll_setup(25, adc_clk, sys_clk);
-}
-
-void demod_set_cbus_reg(unsigned data, unsigned addr)
-{
-	void __iomem *vaddr;
-	pr_dbg("[cbus][write]%x\n", (IO_CBUS_PHY_BASE + (addr << 2)));
-	vaddr = ioremap((IO_CBUS_PHY_BASE + (addr << 2)), 0x4);
-	writel(data, vaddr);
-	iounmap(vaddr);
-}
-
-unsigned demod_read_cbus_reg(unsigned addr)
-{
-/* return __raw_readl(CBUS_REG_ADDR(addr)); */
-	unsigned tmp;
-	void __iomem *vaddr;
-	vaddr = ioremap((IO_CBUS_PHY_BASE + (addr << 2)), 0x4);
-	tmp = readl(vaddr);
-	iounmap(vaddr);
-/* tmp = aml_read_cbus(addr); */
-	pr_dbg("[cbus][read]%x,data is %x\n",
-	(IO_CBUS_PHY_BASE + (addr << 2)), tmp);
-	return tmp;
-}
-
-void demod_set_ao_reg(unsigned data, unsigned addr)
-{
-	void __iomem *vaddr;
-
-/* pr_dbg("[ao][write]%x,data is %x\n",(IO_AOBUS_BASE+addr),data); */
-	vaddr = ioremap((IO_AOBUS_BASE + addr), 0x4);
-	writel(data, vaddr);
-	iounmap(vaddr);
-}
-
-unsigned demod_read_ao_reg(unsigned addr)
-{
-	unsigned tmp;
-	void __iomem *vaddr;
-
-/* pr_dbg("[ao][read]%x\n",(IO_AOBUS_BASE+addr)); */
-	vaddr = ioremap((IO_AOBUS_BASE + addr), 0x4);
-	tmp = readl(vaddr);
-/* pr_dbg("[ao][read]%x,data is %x\n",(IO_AOBUS_BASE+addr),tmp); */
-	iounmap(vaddr);
-	return tmp;
-}
-
-void demod_set_demod_reg(unsigned data, unsigned addr)
-{
-	void __iomem *vaddr;
-	mutex_lock(&mp);
-/* printk("[demod][write]%x,data is %x\n",(addr),data); */
-	vaddr = ioremap((addr), 0x4);
-	writel(data, vaddr);
-	iounmap(vaddr);
-	mutex_unlock(&mp);
-}
-
-unsigned demod_read_demod_reg(unsigned addr)
-{
-	unsigned tmp;
-	void __iomem *vaddr;
-	mutex_lock(&mp);
-	vaddr = ioremap((addr), 0x4);
-	tmp = readl(vaddr);
-	iounmap(vaddr);
-	mutex_unlock(&mp);
-/* printk("[demod][read]%x,data is %x\n",(addr),tmp); */
-	return tmp;
-}
-
-void demod_power_switch(int pwr_cntl)
-{
-	int reg_data;
-#if 1
-	if (pwr_cntl == PWR_ON) {
-		pr_dbg("[PWR]: Power on demod_comp %x,%x\n",
-		       AO_RTI_GEN_PWR_SLEEP0, AO_RTI_GEN_PWR_ISO0);
-		/* Powerup demod_comb */
-		reg_data = demod_read_ao_reg(AO_RTI_GEN_PWR_SLEEP0);
-		demod_set_ao_reg((reg_data & (~(0x1 << 10))),
-				 AO_RTI_GEN_PWR_SLEEP0);
-		/* [10] power on */
-		pr_dbg("[PWR]: Power on demod_comp %x,%x\n",
-		       HHI_DEMOD_MEM_PD_REG, RESET0_LEVEL);
-		/* Power up memory */
-		demod_set_demod_reg((demod_read_demod_reg(HHI_DEMOD_MEM_PD_REG)
-				     & (~0x2fff)), HHI_DEMOD_MEM_PD_REG);
-		/* reset */
-		demod_set_demod_reg((demod_read_demod_reg(RESET0_LEVEL) &
-				     (~(0x1 << 8))), RESET0_LEVEL);
-	/*	msleep(20);*/
-
-		/* remove isolation */
-			demod_set_ao_reg(
-				(demod_read_ao_reg(AO_RTI_GEN_PWR_ISO0) &
-				  (~(0x3 << 14))), AO_RTI_GEN_PWR_ISO0);
-		/* pull up reset */
-		demod_set_demod_reg((demod_read_demod_reg(RESET0_LEVEL) |
-				     (0x1 << 8)), RESET0_LEVEL);
-/* *P_RESET0_LEVEL |= (0x1<<8); */
-	} else {
-		pr_dbg("[PWR]: Power off demod_comp\n");
-		/* add isolation */
-
-			demod_set_ao_reg(
-				(demod_read_ao_reg(AO_RTI_GEN_PWR_ISO0) |
-				  (0x3 << 14)), AO_RTI_GEN_PWR_ISO0);
-
-		/* power down memory */
-		demod_set_demod_reg((demod_read_demod_reg(HHI_DEMOD_MEM_PD_REG)
-			 | 0x2fff), HHI_DEMOD_MEM_PD_REG);
-		/* power down demod_comb */
-		reg_data = demod_read_ao_reg(AO_RTI_GEN_PWR_SLEEP0);
-		demod_set_ao_reg((reg_data | (0x1 << 10)),
-				 AO_RTI_GEN_PWR_SLEEP0);
-		/* [10] power on */
-	}
-#endif
-}
-
-static void clocks_set_sys_defaults(unsigned char dvb_mode)
-{
-	union demod_cfg0 cfg0;
-	union demod_cfg2 cfg2;
-
-	demod_power_switch(PWR_ON);
-
-	if (is_meson_gxtvbb_cpu()) {
-		pr_dbg("GX_TV config\n");
-		demod_set_demod_reg(ADC_RESET_VALUE, ADC_REG3);
-		demod_set_demod_reg(ADC_REG1_VALUE, ADC_REG1);
-		demod_set_demod_reg(ADC_REG2_VALUE, ADC_REG2);
-		demod_set_demod_reg(ADC_REG4_VALUE, ADC_REG4);
-		demod_set_demod_reg(ADC_REG3_VALUE, ADC_REG3);
-		/* dadc */
-		demod_set_demod_reg(ADC_REG7_VALUE, ADC_REG7);
-		demod_set_demod_reg(ADC_REG8_VALUE, ADC_REG8);
-		demod_set_demod_reg(ADC_REG9_VALUE, ADC_REG9);
-		demod_set_demod_reg(ADC_REGA_VALUE, ADC_REGA);
-	} else if (is_meson_txl_cpu()) {
-		pr_dbg("TXL_TV config\n");
-		demod_set_demod_reg(TXLTV_ADC_REG3_VALUE, ADC_REG3);
-		demod_set_demod_reg(TXLTV_ADC_REG1_VALUE, ADC_REG1);
-		demod_set_demod_reg(TXLTV_ADC_REGB_VALUE, ADC_REGB);
-		demod_set_demod_reg(TXLTV_ADC_REG2_VALUE, ADC_REG2);
-		demod_set_demod_reg(TXLTV_ADC_REG3_VALUE, ADC_REG3);
-		demod_set_demod_reg(TXLTV_ADC_REG4_VALUE, ADC_REG4);
-		demod_set_demod_reg(TXLTV_ADC_REGC_VALUE, ADC_REGC);
-		demod_set_demod_reg(TXLTV_ADC_REGD_VALUE, ADC_REGD);
-		demod_set_demod_reg(TXLTV_ADC_RESET_VALUE, ADC_REG3);
-		demod_set_demod_reg(TXLTV_ADC_REG3_VALUE, ADC_REG3);
-
-		/* dadc */
-		demod_set_demod_reg(TXLTV_ADC_REG7_VALUE, ADC_REG7);
-		demod_set_demod_reg(TXLTV_ADC_REG8_VALUE, ADC_REG8);
-		demod_set_demod_reg(TXLTV_ADC_REG9_VALUE, ADC_REG9);
-		demod_set_demod_reg(TXLTV_ADC_REGE_VALUE, ADC_REGE);
-	}
-
-	demod_set_demod_reg(DEMOD_REG1_VALUE, DEMOD_REG1);
-	demod_set_demod_reg(DEMOD_REG2_VALUE, DEMOD_REG2);
-	demod_set_demod_reg(DEMOD_REG3_VALUE, DEMOD_REG3);
-	cfg0.b.mode = 7;
-	cfg0.b.adc_format = 1;
-	if (dvb_mode == Gxtv_Dvbc) {	/* // 0 -DVBC, 1-DVBT, ISDBT, 2-ATSC */
-		cfg0.b.ts_sel = 2;
-	} else if ((dvb_mode == Gxtv_Dvbt_Isdbt) || (dvb_mode == Gxtv_Dtmb)) {
-		cfg0.b.ts_sel = 1;
-		cfg0.b.adc_regout = 1;
-	} else if (dvb_mode == Gxtv_Atsc) {
-		cfg0.b.ts_sel = 4;
-	}
-	demod_set_demod_reg(cfg0.d32, DEMOD_REG1);
-	cfg2.b.biasgen_en = 1;
-	cfg2.b.en_adc = 1;
-	demod_set_demod_reg(cfg2.d32, DEMOD_REG3);
-	pr_dbg("0xc8020c00 is %x,dvb_mode is %d\n",
-	       demod_read_demod_reg(DEMOD_REG1), dvb_mode);
-}
-
-void dtmb_write_reg(int reg_addr, int reg_data)
-{
-	if (!get_dtvpll_init_flag())
-		return;
-	demod_set_demod_reg(reg_data, reg_addr);
-/* apb_write_reg(reg_addr,reg_data); */
-}
-
-int dtmb_read_reg(int reg_addr)
-{
-	if (!get_dtvpll_init_flag())
-		return 0;
-	return demod_read_demod_reg(reg_addr);	/* apb_read_reg(reg_addr); */
-}
-
-void atsc_write_reg(int reg_addr, int reg_data)
-{
-	if (!get_dtvpll_init_flag())
-		return;
-	apb_write_reg(ATSC_BASE, (reg_addr & 0xffff) << 8 | (reg_data & 0xff));
-}
-
-unsigned long atsc_read_reg(int reg_addr)
-{
-	unsigned long tmp;
-
-	if (!get_dtvpll_init_flag())
-		return 0;
-	apb_write_reg(ATSC_BASE + 4, (reg_addr & 0xffff) << 8);
-	tmp = apb_read_reg(ATSC_BASE);
-
-	return tmp & 0xff;
-}
-
-unsigned long atsc_read_iqr_reg(void)
-{
-	unsigned long tmp;
-
-	tmp = apb_read_reg(ATSC_BASE + 8);
-	pr_dbg("[atsc irq] is %lx\n", tmp);
-	return tmp & 0xffffffff;
-}
-
-int atsc_qam_set(fe_modulation_t mode)
-{
-	int i, j;
-
-	if (mode == VSB_8) {	/* 5-8vsb, 2-64qam, 4-256qam */
-		for (i = 0; list_8vsb[i].adr != 0; i++) {
-			if (list_8vsb[i].rw)
-				atsc_read_reg(list_8vsb[i].adr);
-			/* msleep(20); */
-			else
-				atsc_write_reg(list_8vsb[i].adr,
-					       list_8vsb[i].dat);
-			/* msleep(20); */
-		}
-		j = 15589;
-		pr_dbg("8-vsb mode\n");
-	} else if (mode == QAM_64) {
-		for (i = 0; list_qam64[i].adr != 0; i++) {
-			if (list_qam64[i].rw) {
-				atsc_read_reg(list_qam64[i].adr);
-				msleep(20);
-			} else {
-				atsc_write_reg(list_qam64[i].adr,
-					       list_qam64[i].dat);
-				msleep(20);
-			}
-		}
-		j = 16588;	/* 33177; */
-		pr_dbg("64qam mode\n");
-	} else if (mode == QAM_256) {
-		for (i = 0; list_qam256[i].adr != 0; i++) {
-			if (list_qam256[i].rw) {
-				atsc_read_reg(list_qam256[i].adr);
-				msleep(20);
-			} else {
-				atsc_write_reg(list_qam256[i].adr,
-					       list_qam256[i].dat);
-				msleep(20);
-			}
-		}
-		j = 15649;	/* 31298; */
-		pr_dbg("256qam mode\n");
-	} else {
-		for (i = 0; list_qam256[i].adr != 0; i++) {
-			if (list_qam256[i].rw) {
-				atsc_read_reg(list_qam256[i].adr);
-				msleep(20);
-			} else {
-				atsc_write_reg(list_qam256[i].adr,
-					       list_qam256[i].dat);
-				msleep(20);
-			}
-		}
-		j = 15649;	/* 31298; */
-		pr_dbg("256qam mode\n");
-	}
-	return j;
-}
-
-void atsc_initial(struct aml_demod_sta *demod_sta)
-{
-	int fc, fs, cr, ck, j;
-	fe_modulation_t mode;
-
-	mode = demod_sta->ch_mode;
-
-	j = atsc_qam_set(mode);	/* set mode */
-
-	fs = demod_sta->adc_freq;	/* KHZ 25200 */
-	fc = demod_sta->ch_if;	/* KHZ 6350 */
-
-	cr = (fc * (1 << 17) / fs) * (1 << 6);
-	ck = fs * j / 10 - (1 << 25);
-	/* ck_rate = (f_samp / f_vsb /2 -1)*(1<<25);
-	double f_vsb = 10.76238;// double f_64q = 5.056941;
-	// double f_256q = 5.360537; */
-
-	atsc_write_reg(0x070e, cr & 0xff);
-	atsc_write_reg(0x070d, (cr >> 8) & 0xff);
-	atsc_write_reg(0x070c, (cr >> 16) & 0xff);
-
-	if (demod_sta->ch_mode == VSB_8) {
-		atsc_write_reg(0x0711, ck & 0xff);
-		atsc_write_reg(0x0710, (ck >> 8) & 0xff);
-		atsc_write_reg(0x070f, (ck >> 16) & 0xff);
-	}
-	pr_dbg("0x70e is %x, 0x70d is %x, 0x70c is %x\n", cr & 0xff,
-	       (cr >> 8) & 0xff, (cr >> 16) & 0xff);
-	pr_dbg("fs is %d(SR),fc is %d(IF),cr is %x,ck is %x\n", fs, fc, cr, ck);
-}
-
-int atsc_set_ch(struct aml_demod_sta *demod_sta,
-		struct aml_demod_i2c *demod_i2c,
-		struct aml_demod_atsc *demod_atsc)
-{
-	int ret = 0;
-	u8 demod_mode;
-	u8 bw, sr, ifreq, agc_mode;
-	u32 ch_freq;
-
-	bw = demod_atsc->bw;
-	sr = demod_atsc->sr;
-	ifreq = demod_atsc->ifreq;
-	agc_mode = demod_atsc->agc_mode;
-	ch_freq = demod_atsc->ch_freq;
-	demod_mode = demod_atsc->dat0;
-	demod_sta->ch_mode = demod_atsc->mode;	/* TODO */
-	demod_sta->agc_mode = agc_mode;
-	demod_sta->ch_freq = ch_freq;
-	demod_sta->dvb_mode = demod_mode;
-	demod_sta->ch_bw = (8 - bw) * 1000;
-	atsc_initial(demod_sta);
-	pr_dbg("ATSC mode\n");
-	return ret;
-}
-
-#if 0
-static dtmb_cfg_t list_dtmb_v1[99] = {
-	{0x00000000, 0x01, 0},
-	{0x00001000, 0x02, 0},
-	{0x00000000, 0x03, 0},
-	{0x00000000, 0x04, 0},
-	{0x00000000, 0x05, 0},
-	{0x00000000, 0x06, 0},
-	{0x007fffff, 0x07, 0},
-	{0x0000000f, 0x08, 0},
-	{0x00003000, 0x09, 0},
-	{0x00000001, 0x0a, 0},
-	{0x0c403006, 0x0b, 0},
-	{0x44444400, 0x0c, 0},
-	{0x1412c320, 0x0d, 0},
-	{0x00000152, 0x10, 0},
-	{0x47080137, 0x11, 0},
-	{0x02200a16, 0x12, 0},
-	{0x42190190, 0x13, 0},
-	{0x7f807f80, 0x14, 0},
-	{0x0000199a, 0x15, 0},
-	{0x000a1466, 0x18, 0},
-	{0x00274217, 0x1a, 0},
-	{0x00131036, 0x1b, 1},
-	{0x00000396, 0x1c, 0},
-	{0x0037f3cc, 0x1d, 0},
-	{0x00000029, 0x1e, 0},
-	{0x0004f031, 0x1f, 0},
-	{0x00f3cbd4, 0x20, 0},
-	{0x0000007e, 0x21, 0},
-	{0x23270b6a, 0x22, 0},
-	{0x5f700c1b, 0x23, 0},
-	{0x00133c2b, 0x24, 0},
-	{0x2d3e0f12, 0x25, 0},
-	{0x06363038, 0x26, 0},
-	{0x060e0a3e, 0x27, 0},
-	{0x0015161f, 0x28, 0},
-	{0x0809031b, 0x29, 0},
-	{0x181c0307, 0x2a, 0},
-	{0x051f1a1b, 0x2b, 0},
-	{0x00451dce, 0x2c, 0},
-	{0x242fde12, 0x2d, 0},
-	{0x0034e8fa, 0x2e, 0},
-	{0x00000007, 0x30, 0},
-	{0x16000d0c, 0x31, 0},
-	{0x0000011f, 0x32, 0},
-	{0x01000200, 0x33, 0},
-	{0x10bbf376, 0x34, 0},
-	{0x00000044, 0x35, 0},
-	{0x00000000, 0x36, 0},
-	{0x00000000, 0x37, 0},
-	{0x00000000, 0x38, 0},
-	{0x00000000, 0x39, 0},
-	{0x00000031, 0x3a, 0},
-	{0x4d6b0a58, 0x3b, 0},
-	{0x00000c04, 0x3c, 0},
-	{0x0d3b0a50, 0x3d, 0},
-	{0x03140480, 0x3e, 0},
-	{0x05e60452, 0x3f, 0},
-	{0x05780400, 0x40, 0},
-	{0x0063c025, 0x41, 0},
-	{0x05050202, 0x42, 0},
-	{0x5e4a0a14, 0x43, 0},
-	{0x00003b42, 0x44, 0},
-	{0xa53080ff, 0x45, 0},
-	{0x00000000, 0x46, 0},
-	{0x00133202, 0x47, 0},
-	{0x01f00000, 0x48, 0},
-	{0x00000000, 0x49, 0},
-	{0x00000000, 0x4a, 0},
-	{0x00000000, 0x4b, 0},
-	{0x00000000, 0x4c, 0},
-	{0x20405dc8, 0x4d, 0},
-	{0x00000000, 0x4e, 0},
-	{0x1f0205df, 0x4f, 0},
-	{0x00001120, 0x50, 0},
-	{0x4f190803, 0x51, 0},
-	{0x00000000, 0x52, 0},
-	{0x00000040, 0x53, 0},
-	{0x00100050, 0x54, 0},
-	{0x00cd1000, 0x55, 0},
-	{0x00010fab, 0x56, 0},
-	{0x03f0fc3f, 0x58, 0},
-	{0x02005014, 0x59, 0},
-	{0x01405014, 0x5a, 0},
-	{0x00014284, 0x5b, 0},
-	{0x00000320, 0x5c, 0},
-	{0x14130e05, 0x5d, 0},
-	{0x4321c963, 0x5f, 0},
-	{0x624668f8, 0x60, 0},
-	{0xccc08888, 0x61, 0},
-	{0x13212111, 0x62, 0},
-	{0x21100000, 0x63, 0},
-	{0x624668f8, 0x64, 0},
-	{0xccc08888, 0x65, 0},
-	{0x13212111, 0x66, 0},
-	{0x21100000, 0x67, 0},
-	{0x624668f8, 0x68, 0},
-	{0xccc08888, 0x69, 0},
-	{0x0, 0x0, 0}
-};
-#endif
-
-void dtmb_all_reset(void)
-{
-	int temp_data = 0;
-	if (is_meson_txl_cpu()) {
-		dtmb_write_reg(DTMB_FRONT_AFIFO_ADC, 0x1f);
-		dtmb_write_reg(DTMB_CHE_TPS_CONFIG, 0xc00000);
-		dtmb_write_reg(DTMB_FRONT_AGC_CONFIG1, 0x101a7);
-	} else {
-		dtmb_write_reg(DTMB_FRONT_AGC_CONFIG1, 0x10127);
-		dtmb_write_reg(DTMB_CHE_IBDFE_CONFIG6, 0x943228cc);
-		dtmb_write_reg(DTMB_CHE_IBDFE_CONFIG7, 0xc09aa8cd);
-		dtmb_write_reg(DTMB_CHE_FD_TD_COEFF, 0x0);
-		dtmb_write_reg(DTMB_CHE_EQ_CONFIG, 0x9dc59);
-		/*0x2 is auto,0x406 is  invert spectrum*/
-		if (dtmb_spectrum == 0)
-			dtmb_write_reg(DTMB_TOP_CTRL_TPS, 0x406);
-		else if (dtmb_spectrum == 1)
-			dtmb_write_reg(DTMB_TOP_CTRL_TPS, 0x402);
-		else
-			dtmb_write_reg(DTMB_TOP_CTRL_TPS, 0x2);
-
-		pr_dbg("dtmb_spectrum is %d\n", dtmb_spectrum);
-		dtmb_write_reg(DTMB_TOP_CTRL_FEC, 0x41444400);
-		dtmb_write_reg(DTMB_TOP_CTRL_INTLV_TIME, 0x180300);
-		dtmb_write_reg(DTMB_FRONT_DDC_BYPASS, 0x662ca0);
-		dtmb_write_reg(DTMB_FRONT_AFIFO_ADC, 0x29);
-		dtmb_write_reg(DTMB_FRONT_DC_HOLD, 0xa1066);
-		/*cci para*/
-		dtmb_write_reg(DTMB_CHE_M_CCI_THR_CONFIG3, 0x80201f6);
-		dtmb_write_reg(DTMB_CHE_M_CCI_THR_CONFIG2, 0x3f20080);
-		dtmb_write_reg(DTMB_CHE_TPS_CONFIG, 0xc00000);
-		dtmb_write_reg(DTMB_TOP_CTRL_AGC, 0x3);
-		dtmb_write_reg(DTMB_TOP_CTRL_TS_SFO_CFO, 0x20403006);
-		dtmb_write_reg(DTMB_FRONT_AGC_CONFIG2, 0x7200a16);
-		dtmb_write_reg(DTMB_FRONT_DEBUG_CFG, 0x1e00000);
-		dtmb_write_reg(DTMB_TOP_CTRL_ENABLE, 0x7fffff);
-		/*close ts3 timing loop*/
-		dtmb_write_reg(DTMB_TOP_CTRL_DAGC_CCI, 0x305);
-		/*dektec card issue,close f case snr drop*/
-		dtmb_write_reg(DTMB_CHE_MC_SC_TIMING_POWTHR, 0xc06100a);
-		if (demod_enable_performance) {
-			dtmb_write_reg(DTMB_CHE_IBDFE_CONFIG1, 0x4040002);
-			temp_data = dtmb_read_reg(DTMB_CHE_FD_TD_COEFF);
-		    temp_data = (temp_data & ~0x3fff)|(0x241f & 0x3fff);
-		    temp_data = temp_data | (1<<21);
-			/*Set freeze_mode and reset coeff*/
-		    dtmb_write_reg(DTMB_CHE_FD_TD_COEFF, temp_data);
-		    temp_data = temp_data & ~(1<<21);
-			/*Set freeze_mode and reset coeff*/
-		    dtmb_write_reg(DTMB_CHE_FD_TD_COEFF, temp_data);
-		}
-	}
-}
-
-void dtmb_initial(struct aml_demod_sta *demod_sta)
-{
-/* dtmb_write_reg(0x049, memstart);		//only for init */
-	dtmb_spectrum = 1;
-	dtmb_spectrum = demod_sta->spectrum;
-	dtmb_register_reset();
-	dtmb_all_reset();
-#if 0
-	int i;
-	for (i = 0; list_dtmb_v1[i].adr != 0; i++) {
-		if (list_dtmb_v1[i].rw)
-			apb_read_reg(DTMB_BASE + ((list_dtmb_v1[i].adr) << 2));
-		/* msleep(20); */
-		else
-			apb_write_reg(DTMB_BASE + ((list_dtmb_v1[i].adr) << 2),
-				      list_dtmb_v1[i].dat);
-		/* msleep(20); */
-	}
-#endif
-}
-
-int check_dtmb_fec_lock(void)
-{
-	int fec_lock, snr, status;
-	fec_lock = (dtmb_read_reg(DTMB_TOP_FEC_LOCK_SNR) >> 14) & 0x1;
-	snr = dtmb_read_reg(DTMB_TOP_FEC_LOCK_SNR) & 0x3fff;
-	if (fec_lock && (snr > 4))
-		status = 1;
-	else
-		status = 0;
-	return status;
-}
-
-int check_dtmb_mobile_det(void)
-{
-	int mobile_det = 0;
-	mobile_det = (dtmb_read_reg(DTMB_TOP_CTRL_SYS_OFDM_CNT) >> 8) & 0x7ffff;
-	return mobile_det;
-
-}
-
-
-int dtmb_information(void)
-{
-	int tps, snr, fec_lock, fec_bch_add, fec_ldpc_unc_acc, fec_ldpc_it_avg,
-	    tmp, che_snr;
-	struct aml_fe_dev *dev;
-
-	dev = NULL;
-	tps = dtmb_read_reg(DTMB_TOP_CTRL_CHE_WORKCNT);
-	tmp = dtmb_read_reg(DTMB_TOP_FEC_LOCK_SNR);
-	che_snr = tmp & 0xfff;
-	snr = che_snr;
-	/*	if (che_snr >= 8192) */
-	/*		che_snr = che_snr - 16384;*/
-	/*	snr = che_snr / 32;*/
-	/* snr = 10*log10(snr)-6; */
-	fec_lock = (dtmb_read_reg(DTMB_TOP_FEC_LOCK_SNR) >> 14) & 0x1;
-	fec_bch_add = dtmb_read_reg(DTMB_TOP_FEC_BCH_ACC);
-	fec_ldpc_unc_acc = dtmb_read_reg(DTMB_TOP_FEC_LDPC_UNC_ACC);
-	fec_ldpc_it_avg = dtmb_read_reg(DTMB_TOP_FEC_LDPC_IT_AVG);
-	pr_dbg("FSM : %x %x %x %x\n",
-	       dtmb_read_reg(DTMB_TOP_CTRL_FSM_STATE0),
-	       dtmb_read_reg(DTMB_TOP_CTRL_FSM_STATE1),
-	       dtmb_read_reg(DTMB_TOP_CTRL_FSM_STATE2),
-	       dtmb_read_reg(DTMB_TOP_CTRL_FSM_STATE3));
-	pr_dbg
-	    ("AGC : agc_power %d,agc_if_gain %d,agc_rf_gain %d,",
-	     (-(((dtmb_read_reg(DTMB_TOP_FRONT_AGC) >> 22) & 0x3ff) / 16)),
-	     ((dtmb_read_reg(DTMB_TOP_FRONT_AGC)) & 0x3ff),
-	     ((dtmb_read_reg(DTMB_TOP_FRONT_AGC) >> 11) & 0x7ff));
-	pr_dbg
-	      ("dagc_power %3d,dagc_gain %3d mobi_det_power %d\n",
-	      ((dtmb_read_reg(DTMB_TOP_FRONT_DAGC) >> 0) & 0xff),
-	     ((dtmb_read_reg(DTMB_TOP_FRONT_DAGC) >> 8) & 0xfff),
-	     (dtmb_read_reg(DTMB_TOP_CTRL_SYS_OFDM_CNT) >> 8) & 0x7ffff);
-	pr_dbg
-	    ("TPS  SC or MC %2d,f_r %2d qam_nr %2d ",
-	     (dtmb_read_reg(DTMB_TOP_CHE_OBS_STATE1) >> 1) & 0x1,
-	     (tps >> 22) & 0x1, (tps >> 21) & 0x1);
-	pr_dbg
-		("intlv %2d,cr %2d constl %2d\n",
-		(tps >> 20) & 0x1,
-	     (tps >> 18) & 0x3, (tps >> 16) & 0x3);
-
-	pr_dbg
-	    ("[dtmb] snr is %d,fec_lock is %d,fec_bch_add is %d,",
-	     snr, fec_lock, fec_bch_add);
-	pr_dbg
-	    ("fec_ldpc_unc_acc is %d ,fec_ldpc_it_avg is %d\n",
-	     fec_ldpc_unc_acc,
-	     fec_ldpc_it_avg / 256);
-	pr_dbg
-	    ("------------------------------------------------------------\n");
-
-	tuner_get_ch_power(dev);
-
-	return 0;
-}
-
-int dtmb_check_cci(void)
-{
-	int cci_det = 0;
-	cci_det =
-	((dtmb_read_reg(DTMB_TOP_SYNC_CCI_NF2_POSITION) >> 22)
-		& 0x3);
-	if (cci_det > 0) {
-			pr_dbg("find cci\n");
-			dtmb_write_reg(DTMB_CHE_CCIDET_CONFIG, 0x20210290);
-			dtmb_write_reg(DTMB_CHE_M_CCI_THR_CONFIG3, 0x20081f6);
-			dtmb_write_reg(DTMB_CHE_M_CCI_THR_CONFIG2, 0x3f08020);
-	}
-	return cci_det;
-}
-
-int dtmb_check_fsm(void)
-{
-	int tmp, fsm_status, i, has_singal;
-	tmp = dtmb_read_reg(DTMB_TOP_CTRL_FSM_STATE0);
-	fsm_status =  tmp&0xffffffff;
-	has_singal = 0;
-	pr_dbg("[rsj1] fsm_status is %x\n", fsm_status);
-	for (i = 0 ; i < 8 ; i++) {
-		if (((fsm_status >> (i*4)) & 0xf) > 3) {
-			/*has signal*/
-		/*	pr_dbg("has signal\n");*/
-			has_singal = 1;
-		}
-	}
-	return has_singal;
-
-}
-
-int patch_ts3(int delay1_us, int delay2_us)
-{
-	if (((dtmb_read_reg(DTMB_TOP_CTRL_FSM_STATE0)&0xf) == 0x7)&1) {
-		dtmb_write_reg(DTMB_TOP_CTRL_FSM, 0x300f);
-		dtmb_write_reg(DTMB_TOP_CTRL_FSM, 0x310f);
-		msleep(delay1_us);
-		dtmb_write_reg(DTMB_TOP_CTRL_ENABLE, 0xffdfff);
-		dtmb_write_reg(DTMB_TOP_CTRL_ENABLE, 0xffffff);
-		dtmb_write_reg(DTMB_TOP_CTRL_FSM, 0x3110);
-		dtmb_write_reg(DTMB_TOP_CTRL_FSM, 0x3010);
-		dtmb_write_reg(DTMB_TOP_CTRL_FSM, 0x3000);
-		return 1;
-	} else
-		return 0;
-}
-
-
-int read_cfo_all(void)
-{
-	int icfo_all, fcfo_all;
-	icfo_all = dtmb_read_reg(DTMB_TOP_CTRL_ICFO_ALL) & 0xfffff;
-	fcfo_all = dtmb_read_reg(DTMB_TOP_CTRL_FCFO_ALL) & 0x3fff;
-	if (icfo_all > (1 << 19))
-		icfo_all = icfo_all - (1 << 20);
-	if (fcfo_all > (1 << 13))
-		fcfo_all = fcfo_all - (1 << 14);
-
-	return (int)(icfo_all*4+fcfo_all);
-
-}
-
-
-int dtmb_v3_soft_sync(int cfo_init)
-{
-
-/*	int cfo_all;*/
-/*	int cfo_setting;*/
-
-	if (cfo_init == 0) {
-		cfo_init = patch_ts3(11, 0);
-		#if 0
-		if (cfo_init == 1) {
-			cfo_all = read_cfo_all();
-			cfo_setting = dtmb_read_reg(DTMB_FRONT_DDC_BYPASS);
-			dtmb_write_reg(DTMB_FRONT_DDC_BYPASS,
-			cfo_setting+cfo_all);
-			dtmb_write_reg(DTMB_TOP_CTRL_LOOP, 0x3);
-			dtmb_reset();
-		}
-		#endif
-	}
-	return cfo_init;
-
-}
-
-int dtmb_check_status_gxtv(struct dvb_frontend *fe)
-{
-	int local_state;
-	int time_cnt;/* cci_det, src_config;*/
-	int cfo_init, count;
-
-	dtmb_information();
-	time_cnt = 0;
-	local_state = 0;
-	cfo_init = 0;
-	if (check_dtmb_fec_lock() != 1) {
-		dtmb_register_reset();
-		dtmb_all_reset();
-		count = 15;
-		while ((count) &&
-		((dtmb_read_reg(DTMB_TOP_CTRL_FSM_STATE0)&0xf) < 0x6)) {
-			msleep(20);
-			count--;
-		}
-
-		count = demod_sync_count;
-		while ((count) && (cfo_init == 0)) {
-
-			cfo_init = dtmb_v3_soft_sync(cfo_init);
-
-			msleep(demod_sync_delay_time);
-			count--;
-		}
-		if ((cfo_init == 0) &&
-			((dtmb_read_reg(DTMB_TOP_CTRL_FSM_STATE0)&0xf) <= 7)) {
-			pr_dbg("over 400ms,status is %x, need reset\n",
-				(dtmb_read_reg(DTMB_TOP_CTRL_FSM_STATE0)&0xf));
-			return 0;
-		}
-		while ((time_cnt < 10) && (check_dtmb_fec_lock() != 1)) {
-			msleep(demod_timeout);
-			time_cnt++;
-			local_state = AMLOGIC_DTMB_STEP3;
-			dtmb_information();
-			dtmb_check_cci();
-			if (time_cnt > 8)
-				pr_dbg
-					("* local_state = %d\n", local_state);
-		}
-		if (time_cnt >= 10 && (check_dtmb_fec_lock() != 1)) {
-			local_state = AMLOGIC_DTMB_STEP4;
-			time_cnt = 0;
-			pr_dbg
-				("*all reset,timeout is %d\n", demod_timeout);
-		}
-	} else {
-		dtmb_check_cci();
-	#if 0
-		cci_det = dtmb_check_cci();
-		if ((check_dtmb_mobile_det() <= demod_mobile_power)
-				&& (cci_det == 0)) {
-			/* open */
-			src_config = (dtmb_read_reg(DTMB_FRONT_SRC_CONFIG1));
-			dtmb_write_reg(DTMB_FRONT_SRC_CONFIG1,
-				src_config & (~(0x1 << 28)));
-		} else {
-			/* close */
-			src_config = (dtmb_read_reg(DTMB_FRONT_SRC_CONFIG1));
-			dtmb_write_reg(DTMB_FRONT_SRC_CONFIG1,
-				src_config | (0x1 << 28));
-		}
-	#endif
-	}
-	if (check_dtmb_fec_lock() == 1)
-		dtmb_write_reg(DTMB_TOP_CTRL_LOOP, 0xf);
-	return 0;
-}
-
-
-int dtmb_check_status_txl(struct dvb_frontend *fe)
-{
-	dtmb_information();
-	return 0;
-}
-
-
-void dtmb_reset(void)
-{
-	union DTMB_TOP_CTRL_SW_RST_BITS sw_rst;
-
-	sw_rst.b.ctrl_sw_rst = 1;
-	sw_rst.b.ctrl_sw_rst_noreg = 1;
-	dtmb_write_reg(DTMB_TOP_CTRL_SW_RST, sw_rst.d32);
-	sw_rst.b.ctrl_sw_rst = 0;
-	sw_rst.b.ctrl_sw_rst_noreg = 0;
-	dtmb_write_reg(DTMB_TOP_CTRL_SW_RST, sw_rst.d32);
-}
-
-void dtmb_register_reset(void)
-{
-	union DTMB_TOP_CTRL_SW_RST_BITS sw_rst;
-
-	sw_rst.b.ctrl_sw_rst = 1;
-	dtmb_write_reg(DTMB_TOP_CTRL_SW_RST, sw_rst.d32);
-	sw_rst.b.ctrl_sw_rst = 0;
-	dtmb_write_reg(DTMB_TOP_CTRL_SW_RST, sw_rst.d32);
-}
-
-int dtmb_set_ch(struct aml_demod_sta *demod_sta,
-		struct aml_demod_i2c *demod_i2c,
-		struct aml_demod_dtmb *demod_dtmb)
-{
-	int ret = 0;
-	u8 demod_mode;
-	u8 bw, sr, ifreq, agc_mode;
-	u32 ch_freq;
-
-	bw = demod_dtmb->bw;
-	sr = demod_dtmb->sr;
-	ifreq = demod_dtmb->ifreq;
-	agc_mode = demod_dtmb->agc_mode;
-	ch_freq = demod_dtmb->ch_freq;
-	demod_mode = demod_dtmb->dat0;
-	demod_sta->ch_mode = demod_dtmb->mode;	/* TODO */
-	demod_sta->agc_mode = agc_mode;
-	demod_sta->ch_freq = ch_freq;
-	demod_sta->dvb_mode = demod_mode;
-	demod_sta->ch_bw = (8 - bw) * 1000;
-	dtmb_initial(demod_sta);
-	pr_dbg("DTMB mode\n");
-	return ret;
-}
-
-int dvbt_set_ch(struct aml_demod_sta *demod_sta,
-		struct aml_demod_i2c *demod_i2c,
-		struct aml_demod_dvbt *demod_dvbt)
-{
-	int ret = 0;
-	u8_t demod_mode = 1;
-	u8_t bw, sr, ifreq, agc_mode;
-	u32_t ch_freq;
-
-	bw = demod_dvbt->bw;
-	sr = demod_dvbt->sr;
-	ifreq = demod_dvbt->ifreq;
-	agc_mode = demod_dvbt->agc_mode;
-	ch_freq = demod_dvbt->ch_freq;
-	demod_mode = demod_dvbt->dat0;
-	if (ch_freq < 1000 || ch_freq > 900000000) {
-		/* pr_dbg("Error: Invalid Channel Freq option %d\n",
-		ch_freq); */
-		ch_freq = 474000;
-		ret = -1;
-	}
-
-	if (demod_mode < 0 || demod_mode > 4) {
-		/* pr_dbg("Error: Invalid demod mode option %d\n",
-		demod_mode); */
-		demod_mode = 1;
-		ret = -1;
-	}
-
-	/* demod_sta->dvb_mode  = 1; */
-	demod_sta->ch_mode = 0;	/* TODO */
-	demod_sta->agc_mode = agc_mode;
-	demod_sta->ch_freq = ch_freq;
-	demod_sta->dvb_mode = demod_mode;
-	/*   if (demod_i2c->tuner == 1)
-	 *     demod_sta->ch_if = 36130;
-	 * else if (demod_i2c->tuner == 2)
-	 *     demod_sta->ch_if = 4570;
-	 * else if (demod_i2c->tuner == 3)
-	 *     demod_sta->ch_if = 4000;// It is nouse.(alan)
-	 * else if (demod_i2c->tuner == 7)
-	 *     demod_sta->ch_if = 5000;//silab 5000kHz IF*/
-
-	demod_sta->ch_bw = (8 - bw) * 1000;
-	demod_sta->symb_rate = 0;	/* TODO */
-
-/* bw=0; */
-	demod_mode = 1;
-	/* for si2176 IF:5M   sr 28.57 */
-	sr = 4;
-	ifreq = 4;
-	if (bw == BANDWIDTH_AUTO)
-		demod_mode = 2;
-	ofdm_initial(bw,
-			/* 00:8M 01:7M 10:6M 11:5M */
-		     sr,
-		     /* 00:45M 01:20.8333M 10:20.7M 11:28.57  100:24m */
-		     ifreq,
-		     /* 000:36.13M 001:-5.5M 010:4.57M 011:4M 100:5M */
-		     demod_mode - 1,
-		     /* 00:DVBT,01:ISDBT */
-		     1
-		     /* 0: Unsigned, 1:TC */
-	    );
-	pr_dbg("DVBT/ISDBT mode\n");
-
-	return ret;
-}
-
-int demod_set_sys(struct aml_demod_sta *demod_sta,
-		  struct aml_demod_i2c *demod_i2c,
-		  struct aml_demod_sys *demod_sys)
-{
-/* int adc_clk; */
-/* demod_sta->tmp=Adc_mode; */
-	unsigned char dvb_mode;
-	int clk_adc, clk_dem;
-	int gpioDV_2;
-	int gpiW_2;
-
-	dvb_mode = demod_sta->dvb_mode;
-	clk_adc = demod_sys->adc_clk;
-	clk_dem = demod_sys->demod_clk;
-	pr_dbg
-	    ("demod_set_sys,clk_adc is %d,clk_demod is %d\n",
-	     clk_adc, clk_dem);
-	mutex_init(&mp);
-	clocks_set_sys_defaults(dvb_mode);
-	/* open dtv adc pinmux */
-	if (is_meson_txl_cpu()) {
-		gpioDV_2 = demod_read_demod_reg(0xc8834400 + (0x2e << 2));
-		pr_dbg("[R840]set adc pinmux,gpioDV_2 %x\n", gpioDV_2);
-		gpioDV_2 = gpioDV_2 | (0x1 << 22);
-		gpioDV_2 = gpioDV_2 & ~(0x3 << 19);
-		gpioDV_2 = gpioDV_2 & ~(0x1 << 23);
-		gpioDV_2 = gpioDV_2 & ~(0x1 << 31);
-		demod_set_demod_reg(gpioDV_2, 0xc8834400 + (0x2e << 2));
-		pr_dbg("[R840]set adc pinmux,gpioDV_2 %x\n", gpioDV_2);
-	} else {
-		gpiW_2 = demod_read_demod_reg(0xc88344c4);
-		gpiW_2 = gpiW_2 | (0x1 << 25);
-		gpiW_2 = gpiW_2 & ~(0xd << 24);
-		demod_set_demod_reg(gpiW_2, 0xc88344c4);
-		pr_dbg("[R840]set adc pinmux,gpiW_2 %x\n", gpiW_2);
-	}
-	/* set adc clk */
-	demod_set_adc_core_clk(clk_adc, clk_dem, dvb_mode);
-	/* init for dtmb */
-	if (dvb_mode == Gxtv_Dtmb) {
-		/* open arbit */
-		demod_set_demod_reg(0x8, DEMOD_REG4);
-	}
-	demod_sta->adc_freq = clk_adc;
-	demod_sta->clk_freq = clk_dem;
-	return 0;
-}
-
-void demod_set_reg(struct aml_demod_reg *demod_reg)
-{
-	switch (demod_reg->mode) {
-	case 0:
-		demod_reg->addr = demod_reg->addr + QAM_BASE;
-		break;
-	case 1:
-	case 2:
-		demod_reg->addr = DTMB_TOP_ADDR(demod_reg->addr);
-		break;
-	case 3:
-		/* demod_reg->addr=ATSC_BASE; */
-		break;
-	case 4:
-		demod_reg->addr = demod_reg->addr * 4 + DEMOD_CFG_BASE;
-		break;
-	case 5:
-		demod_reg->addr = demod_reg->addr + DEMOD_BASE;
-		break;
-	case 6:
-		/* demod_reg->addr=demod_reg->addr*4+DEMOD_CFG_BASE; */
-		break;
-	case 11:
-		demod_reg->addr = demod_reg->addr;
-		break;
-	case 10:
-		/* demod_reg->addr=(u32_t)phys_to_virt(demod_reg->addr); */
-		break;
-	}
-
-	if (demod_reg->mode == 3)
-		atsc_write_reg(demod_reg->addr, demod_reg->val);
-	else if (demod_reg->mode == 11)
-		demod_set_cbus_reg(demod_reg->val, demod_reg->addr);
-	else if (demod_reg->mode == 10)
-		apb_write_reg_collect(demod_reg->addr, demod_reg->val);
-	/* demod_reg->val_high = apb_read_reg_high(demod_reg->addr); */
-	else
-		demod_set_demod_reg(demod_reg->val, demod_reg->addr);
-}
-
-void demod_get_reg(struct aml_demod_reg *demod_reg)
-{
-	if (demod_reg->mode == 0) {
-		demod_reg->addr = demod_reg->addr + QAM_BASE;
-	} else if ((demod_reg->mode == 1) || (demod_reg->mode == 2)) {
-		demod_reg->addr = DTMB_TOP_ADDR(demod_reg->addr);
-	} else if (demod_reg->mode == 3) {
-		/* demod_reg->addr=demod_reg->addr+ATSC_BASE; */
-	} else if (demod_reg->mode == 4) {
-		demod_reg->addr = demod_reg->addr * 4 + DEMOD_CFG_BASE;
-	} else if (demod_reg->mode == 5) {
-		demod_reg->addr = demod_reg->addr + DEMOD_BASE;
-	} else if (demod_reg->mode == 6) {
-		/* demod_reg->addr=demod_reg->addr*4+DEMOD_CFG_BASE; */
-	} else if (demod_reg->mode == 11) {
-		demod_reg->addr = demod_reg->addr;
-	} else if (demod_reg->mode == 10) {
-		/* printk("demod_reg->addr is %x\n",demod_reg->addr); */
-		/* test=(unsigned long)phys_to_virt(test); */
-/* demod_reg->addr=(unsigned long)phys_to_virt(demod_reg->addr); */
-/* printk("demod_reg->addr is %lx %x\n",test,demod_reg->addr); */
-	}
-
-	if (demod_reg->mode == 3) {
-		demod_reg->val = atsc_read_reg(demod_reg->addr);
-		/* apb_write_reg(ATSC_BASE+4, (demod_reg->addr&0xffff)<<8); */
-		/* demod_reg->val = apb_read_reg(ATSC_BASE)&0xff; */
-	} else if (demod_reg->mode == 6) {
-		demod_reg->val = atsc_read_iqr_reg();
-		/* apb_write_reg(ATSC_BASE+4, (demod_reg->addr&0xffff)<<8); */
-		/* demod_reg->val = apb_read_reg(ATSC_BASE)&0xff; */
-	} else if (demod_reg->mode == 11) {
-		demod_reg->val = demod_read_cbus_reg(demod_reg->addr);
-	} else if (demod_reg->mode == 10) {
-		demod_reg->val = apb_read_reg_collect(demod_reg->addr);
-	/*	demod_reg->val_high = apb_read_reg_high(demod_reg->addr);*/
-	} else {
-		demod_reg->val = demod_read_demod_reg(demod_reg->addr);
-	}
-}
-
-void apb_write_reg_collect(unsigned int addr, unsigned int data)
-{
-	writel(data, ((void __iomem *)(phys_to_virt(addr))));
-/* *(volatile unsigned int*)addr = data; */
-}
-
-unsigned long apb_read_reg_collect(unsigned long addr)
-{
-	unsigned long tmp;
-/*	void __iomem *vaddr;
-	vaddr = ioremap(((unsigned long)phys_to_virt(addr)), 0x4);
-	tmp = readl(vaddr);
-	iounmap(vaddr);*/
-	tmp = readl((void __iomem *)(phys_to_virt(addr)));
-/*tmp = *(volatile unsigned long *)((unsigned long)phys_to_virt(addr));*/
-/* printk("[all][read]%lx,data is %lx\n",addr,tmp); */
-	return tmp & 0xffffffff;
-}
-
-
-
-void apb_write_reg(unsigned int addr, unsigned int data)
-{
-	demod_set_demod_reg(data, addr);
-}
-
-unsigned long apb_read_reg_high(unsigned long addr)
-{
-	unsigned long tmp;
-	tmp = 0;
-	return (tmp >> 32) & 0xffffffff;
-}
-
-unsigned long apb_read_reg(unsigned long addr)
-{
-	return demod_read_demod_reg(addr);
-}
-
-void apb_write_regb(unsigned long addr, int index, unsigned long data)
-{
-	/*to achieve write func*/
-}
-
-void enable_qam_int(int idx)
-{
-	unsigned long mask;
-
-	mask = apb_read_reg(QAM_BASE + 0xd0);
-	mask |= (1 << idx);
-	apb_write_reg(QAM_BASE + 0xd0, mask);
-}
-
-void disable_qam_int(int idx)
-{
-	unsigned long mask;
-
-	mask = apb_read_reg(QAM_BASE + 0xd0);
-	mask &= ~(1 << idx);
-	apb_write_reg(QAM_BASE + 0xd0, mask);
-}
-
-char *qam_int_name[] = { "      ADC",
-	"   Symbol",
-	"       RS",
-	" In_Sync0",
-	" In_Sync1",
-	" In_Sync2",
-	" In_Sync3",
-	" In_Sync4",
-	"Out_Sync0",
-	"Out_Sync1",
-	"Out_Sync2",
-	"Out_Sync3",
-	"Out_Sync4",
-	"In_SyncCo",
-	"OutSyncCo",
-	"  In_Dagc",
-	" Out_Dagc",
-	"  Eq_Mode",
-	"RS_Uncorr"
-};
-
-#define OFDM_INT_STS         0
-#define OFDM_INT_EN          0
-
-void enable_ofdm_int(int ofdm_irq)
-{
-
-}
-
-void disable_ofdm_int(int ofdm_irq)
-{
-
-}
-
-char *ofdm_int_name[] = { "PFS_FCFO",
-	"PFS_ICFO",
-	" CS_FCFO",
-	" PFS_SFO",
-	" PFS_TPS",
-	"      SP",
-	"     CCI",
-	"  Symbol",
-	" In_Sync",
-	"Out_Sync",
-	"FSM Stat"
-};
-
-unsigned long read_ofdm_int(void)
-{
-
-	return 0;
-}
-
-#define PHS_LOOP_OPEN
-
-void qam_read_all_regs(void)
-{
-
-}
-
-void ini_icfo_pn_index(int mode)
-{				/* 00:DVBT,01:ISDBT */
-	if (mode == 0) {
-		apb_write_reg(DVBT_BASE + 0x3f8, 0x00000031);
-		apb_write_reg(DVBT_BASE + 0x3fc, 0x00030000);
-		apb_write_reg(DVBT_BASE + 0x3f8, 0x00000032);
-		apb_write_reg(DVBT_BASE + 0x3fc, 0x00057036);
-		apb_write_reg(DVBT_BASE + 0x3f8, 0x00000033);
-		apb_write_reg(DVBT_BASE + 0x3fc, 0x0009c08d);
-		apb_write_reg(DVBT_BASE + 0x3f8, 0x00000034);
-		apb_write_reg(DVBT_BASE + 0x3fc, 0x000c90c0);
-		apb_write_reg(DVBT_BASE + 0x3f8, 0x00000035);
-		apb_write_reg(DVBT_BASE + 0x3fc, 0x001170ff);
-		apb_write_reg(DVBT_BASE + 0x3f8, 0x00000036);
-		apb_write_reg(DVBT_BASE + 0x3fc, 0x0014d11a);
-	} else if (mode == 1) {
-		apb_write_reg(DVBT_BASE + 0x3f8, 0x00000031);
-		apb_write_reg(DVBT_BASE + 0x3fc, 0x00085046);
-		apb_write_reg(DVBT_BASE + 0x3f8, 0x00000032);
-		apb_write_reg(DVBT_BASE + 0x3fc, 0x0019a0e9);
-		apb_write_reg(DVBT_BASE + 0x3f8, 0x00000033);
-		apb_write_reg(DVBT_BASE + 0x3fc, 0x0024b1dc);
-		apb_write_reg(DVBT_BASE + 0x3f8, 0x00000034);
-		apb_write_reg(DVBT_BASE + 0x3fc, 0x003b3313);
-		apb_write_reg(DVBT_BASE + 0x3f8, 0x00000035);
-		apb_write_reg(DVBT_BASE + 0x3fc, 0x0048d409);
-		apb_write_reg(DVBT_BASE + 0x3f8, 0x00000036);
-		apb_write_reg(DVBT_BASE + 0x3fc, 0x00527509);
-	}
-}
-
-static int coef[] = {
-	0xf900, 0xfe00, 0x0000, 0x0000, 0x0100, 0x0100, 0x0000, 0x0000,
-	0xfd00, 0xf700, 0x0000, 0x0000, 0x4c00, 0x0000, 0x0000, 0x0000,
-	0x2200, 0x0c00, 0x0000, 0x0000, 0xf700, 0xf700, 0x0000, 0x0000,
-	0x0300, 0x0900, 0x0000, 0x0000, 0x0600, 0x0600, 0x0000, 0x0000,
-	0xfc00, 0xf300, 0x0000, 0x0000, 0x2e00, 0x0000, 0x0000, 0x0000,
-	0x3900, 0x1300, 0x0000, 0x0000, 0xfa00, 0xfa00, 0x0000, 0x0000,
-	0x0100, 0x0200, 0x0000, 0x0000, 0xf600, 0x0000, 0x0000, 0x0000,
-	0x0700, 0x0700, 0x0000, 0x0000, 0xfe00, 0xfb00, 0x0000, 0x0000,
-	0x0900, 0x0000, 0x0000, 0x0000, 0x3200, 0x1100, 0x0000, 0x0000,
-	0x0400, 0x0400, 0x0000, 0x0000, 0xfe00, 0xfb00, 0x0000, 0x0000,
-	0x0e00, 0x0000, 0x0000, 0x0000, 0xfb00, 0xfb00, 0x0000, 0x0000,
-	0x0100, 0x0200, 0x0000, 0x0000, 0xf400, 0x0000, 0x0000, 0x0000,
-	0x3900, 0x1300, 0x0000, 0x0000, 0x1700, 0x1700, 0x0000, 0x0000,
-	0xfc00, 0xf300, 0x0000, 0x0000, 0x0c00, 0x0000, 0x0000, 0x0000,
-	0x0300, 0x0900, 0x0000, 0x0000, 0xee00, 0x0000, 0x0000, 0x0000,
-	0x2200, 0x0c00, 0x0000, 0x0000, 0x2600, 0x2600, 0x0000, 0x0000,
-	0xfd00, 0xf700, 0x0000, 0x0000, 0x0200, 0x0000, 0x0000, 0x0000,
-	0xf900, 0xfe00, 0x0000, 0x0000, 0x0400, 0x0b00, 0x0000, 0x0000,
-	0xf900, 0x0000, 0x0000, 0x0000, 0x0700, 0x0200, 0x0000, 0x0000,
-	0x2100, 0x2100, 0x0000, 0x0000, 0x0200, 0x0700, 0x0000, 0x0000,
-	0xf900, 0x0000, 0x0000, 0x0000, 0x0b00, 0x0400, 0x0000, 0x0000,
-	0xfe00, 0xf900, 0x0000, 0x0000, 0x0200, 0x0000, 0x0000, 0x0000,
-	0xf700, 0xfd00, 0x0000, 0x0000, 0x2600, 0x2600, 0x0000, 0x0000,
-	0x0c00, 0x2200, 0x0000, 0x0000, 0xee00, 0x0000, 0x0000, 0x0000,
-	0x0900, 0x0300, 0x0000, 0x0000, 0x0c00, 0x0000, 0x0000, 0x0000,
-	0xf300, 0xfc00, 0x0000, 0x0000, 0x1700, 0x1700, 0x0000, 0x0000,
-	0x1300, 0x3900, 0x0000, 0x0000, 0xf400, 0x0000, 0x0000, 0x0000,
-	0x0200, 0x0100, 0x0000, 0x0000, 0xfb00, 0xfb00, 0x0000, 0x0000,
-	0x0e00, 0x0000, 0x0000, 0x0000, 0xfb00, 0xfe00, 0x0000, 0x0000,
-	0x0400, 0x0400, 0x0000, 0x0000, 0x1100, 0x3200, 0x0000, 0x0000,
-	0x0900, 0x0000, 0x0000, 0x0000, 0xfb00, 0xfe00, 0x0000, 0x0000,
-	0x0700, 0x0700, 0x0000, 0x0000, 0xf600, 0x0000, 0x0000, 0x0000,
-	0x0200, 0x0100, 0x0000, 0x0000, 0xfa00, 0xfa00, 0x0000, 0x0000,
-	0x1300, 0x3900, 0x0000, 0x0000, 0x2e00, 0x0000, 0x0000, 0x0000,
-	0xf300, 0xfc00, 0x0000, 0x0000, 0x0600, 0x0600, 0x0000, 0x0000,
-	0x0900, 0x0300, 0x0000, 0x0000, 0xf700, 0xf700, 0x0000, 0x0000,
-	0x0c00, 0x2200, 0x0000, 0x0000, 0x4c00, 0x0000, 0x0000, 0x0000,
-	0xf700, 0xfd00, 0x0000, 0x0000, 0x0100, 0x0100, 0x0000, 0x0000,
-	0xfe00, 0xf900, 0x0000, 0x0000, 0x0b00, 0x0400, 0x0000, 0x0000,
-	0xfc00, 0xfc00, 0x0000, 0x0000, 0x0200, 0x0700, 0x0000, 0x0000,
-	0x4200, 0x0000, 0x0000, 0x0000, 0x0700, 0x0200, 0x0000, 0x0000,
-	0xfc00, 0xfc00, 0x0000, 0x0000, 0x0400, 0x0b00, 0x0000, 0x0000
-};
-
-void tfd_filter_coff_ini(void)
-{
-	int i = 0;
-
-	for (i = 0; i < 336; i++) {
-		apb_write_reg(DVBT_BASE + 0x99 * 4, (i << 16) | coef[i]);
-		apb_write_reg(DVBT_BASE + 0x03 * 4, (1 << 12));
-	}
-}
-
-void ofdm_initial(int bandwidth,
-		/* 00:8M 01:7M 10:6M 11:5M */
-		int samplerate,
-		/* 00:45M 01:20.8333M 10:20.7M 11:28.57 100: 24.00 */
-		int IF,
-		/* 000:36.13M 001:-5.5M 010:4.57M 011:4M 100:5M */
-		int mode,
-		/* 00:DVBT,01:ISDBT */
-		int tc_mode
-		/* 0: Unsigned, 1:TC */
-		)
-{
-#if 0
-	int tmp;
-	int ch_if;
-	int adc_freq;
-	pr_dbg
-	    ("[ofdm_initial]bandwidth is %d,samplerate is %d",
-	     bandwidth, samplerate);
-	pr_dbg
-	    ("IF is %d, mode is %d,tc_mode is %d\n",
-	    IF, mode, tc_mode);
-	switch (IF) {
-	case 0:
-		ch_if = 36130;
-		break;
-	case 1:
-		ch_if = -5500;
-		break;
-	case 2:
-		ch_if = 4570;
-		break;
-	case 3:
-		ch_if = 4000;
-		break;
-	case 4:
-		ch_if = 5000;
-		break;
-	default:
-		ch_if = 4000;
-		break;
-	}
-	switch (samplerate) {
-	case 0:
-		adc_freq = 45000;
-		break;
-	case 1:
-		adc_freq = 20833;
-		break;
-	case 2:
-		adc_freq = 20700;
-		break;
-	case 3:
-		adc_freq = 28571;
-		break;
-	case 4:
-		adc_freq = 24000;
-		break;
-	default:
-		adc_freq = 28571;
-		break;
-	}
-
-	apb_write_reg(DVBT_BASE + (0x02 << 2), 0x00800000);
-	/* SW reset bit[23] ; write anything to zero */
-	apb_write_reg(DVBT_BASE + (0x00 << 2), 0x00000000);
-
-	apb_write_reg(DVBT_BASE + (0xe << 2), 0xffff);
-	/* enable interrupt */
-
-	if (mode == 0) {	/* DVBT */
-		switch (samplerate) {
-		case 0:
-			apb_write_reg(DVBT_BASE + (0x08 << 2), 0x00005a00);
-			break;	/* 45MHz */
-		case 1:
-			apb_write_reg(DVBT_BASE + (0x08 << 2), 0x000029aa);
-			break;	/* 20.833 */
-		case 2:
-			apb_write_reg(DVBT_BASE + (0x08 << 2), 0x00002966);
-			break;	/* 20.7   SAMPLERATE*512 */
-		case 3:
-			apb_write_reg(DVBT_BASE + (0x08 << 2), 0x00003924);
-			break;	/* 28.571 */
-		case 4:
-			apb_write_reg(DVBT_BASE + (0x08 << 2), 0x00003000);
-			break;	/* 24 */
-		default:
-			apb_write_reg(DVBT_BASE + (0x08 << 2), 0x00003924);
-			break;	/* 28.571 */
-		}
-	} else {		/* ISDBT */
-		switch (samplerate) {
-		case 0:
-			apb_write_reg(DVBT_BASE + (0x08 << 2), 0x0000580d);
-			break;	/* 45MHz */
-		case 1:
-			apb_write_reg(DVBT_BASE + (0x08 << 2), 0x0000290d);
-			break;	/* 20.833 = 56/7 * 20.8333 / (512/63)*512 */
-		case 2:
-			apb_write_reg(DVBT_BASE + (0x08 << 2), 0x000028da);
-			break;	/* 20.7 */
-		case 3:
-			apb_write_reg(DVBT_BASE + (0x08 << 2), 0x0000383F);
-			break;	/* 28.571  3863 */
-		case 4:
-			apb_write_reg(DVBT_BASE + (0x08 << 2), 0x00002F40);
-			break;	/* 24 */
-		default:
-			apb_write_reg(DVBT_BASE + (0x08 << 2), 0x00003863);
-			break;	/* 28.571 */
-		}
-	}
-/* memstart=0x93900000; */
-	pr_dbg("memstart is %x\n", memstart);
-	apb_write_reg(DVBT_BASE + (0x10 << 2), memstart);
-	/* 0x8f300000 */
-
-	apb_write_reg(DVBT_BASE + (0x14 << 2), 0xe81c4ff6);
-	/* AGC_TARGET 0xf0121385 */
-
-	switch (samplerate) {
-	case 0:
-		apb_write_reg(DVBT_BASE + (0x15 << 2), 0x018c2df2);
-		break;
-	case 1:
-		apb_write_reg(DVBT_BASE + (0x15 << 2), 0x0185bdf2);
-		break;
-	case 2:
-		apb_write_reg(DVBT_BASE + (0x15 << 2), 0x0185bdf2);
-		break;
-	case 3:
-		apb_write_reg(DVBT_BASE + (0x15 << 2), 0x0187bdf2);
-		break;
-	case 4:
-		apb_write_reg(DVBT_BASE + (0x15 << 2), 0x0187bdf2);
-		break;
-	default:
-		apb_write_reg(DVBT_BASE + (0x15 << 2), 0x0187bdf2);
-		break;
-	}
-	if (tc_mode == 1)
-		apb_write_regb(DVBT_BASE + (0x15 << 2), 11, 0);
-	/* For TC mode. Notice, For ADC input is Unsigned,
-	For Capture Data, It is TC. */
-	apb_write_regb(DVBT_BASE + (0x15 << 2), 26, 1);
-	/* [19:0] = [I , Q], I is high, Q is low. This bit is swap I/Q. */
-
-	apb_write_reg(DVBT_BASE + (0x16 << 2), 0x00047f80);
-	/* AGC_IFGAIN_CTRL */
-	apb_write_reg(DVBT_BASE + (0x17 << 2), 0x00027f80);
-	/* AGC_RFGAIN_CTRL */
-	apb_write_reg(DVBT_BASE + (0x18 << 2), 0x00000190);
-	/* AGC_IFGAIN_ACCUM */
-	apb_write_reg(DVBT_BASE + (0x19 << 2), 0x00000190);
-	/* AGC_RFGAIN_ACCUM */
-	if (ch_if < 0)
-		ch_if += adc_freq;
-	if (ch_if > adc_freq)
-		ch_if -= adc_freq;
-
-	tmp = ch_if * (1 << 15) / adc_freq;
-	apb_write_reg(DVBT_BASE + (0x20 << 2), tmp);
-
-	apb_write_reg(DVBT_BASE + (0x21 << 2), 0x001ff000);
-	/* DDC CS_FCFO_ADJ_CTRL */
-	apb_write_reg(DVBT_BASE + (0x22 << 2), 0x00000000);
-	/* DDC ICFO_ADJ_CTRL */
-	apb_write_reg(DVBT_BASE + (0x23 << 2), 0x00004000);
-	/* DDC TRACK_FCFO_ADJ_CTRL */
-
-	apb_write_reg(DVBT_BASE + (0x27 << 2), (1 << 23)
-	| (3 << 19) | (3 << 15) |  (1000 << 4) | 9);
-	/* {8'd0,1'd1,4'd3,4'd3,11'd50,4'd9});//FSM_1 */
-	apb_write_reg(DVBT_BASE + (0x28 << 2), (100 << 13) | 1000);
-	/* {8'd0,11'd40,13'd50});//FSM_2 */
-	apb_write_reg(DVBT_BASE + (0x29 << 2), (31 << 20) | (1 << 16) |
-	(24 << 9) | (3 << 6) | 20);
-	/* {5'd0,7'd127,1'd0,3'd0,7'd24,3'd5,6'd20}); */
-
-	if (mode == 0) {	/* DVBT */
-		if (bandwidth == 0) {	/* 8M */
-			switch (samplerate) {
-			case 0:
-				ini_acf_iireq_src_45m_8m();
-				apb_write_reg(DVBT_BASE + (0x44 << 2),
-					      0x004ebf2e);
-				break;	/* 45M */
-			case 1:
-				ini_acf_iireq_src_207m_8m();
-				apb_write_reg(DVBT_BASE + (0x44 << 2),
-					      0x00247551);
-				break;	/* 20.833M */
-			case 2:
-				ini_acf_iireq_src_207m_8m();
-				apb_write_reg(DVBT_BASE + (0x44 << 2),
-					      0x00243999);
-				break;	/* 20.7M */
-			case 3:
-				ini_acf_iireq_src_2857m_8m();
-				apb_write_reg(DVBT_BASE + (0x44 << 2),
-					      0x0031ffcd);
-				break;	/* 28.57M */
-			case 4:
-				ini_acf_iireq_src_24m_8m();
-				apb_write_reg(DVBT_BASE + (0x44 << 2),
-					      0x002A0000);
-				break;	/* 24M */
-			default:
-				ini_acf_iireq_src_2857m_8m();
-				apb_write_reg(DVBT_BASE + (0x44 << 2),
-					      0x0031ffcd);
-				break;	/* 28.57M */
-			}
-		} else if (bandwidth == 1) {	/* 7M */
-			switch (samplerate) {
-			case 0:
-				ini_acf_iireq_src_45m_7m();
-				apb_write_reg(DVBT_BASE + (0x44 << 2),
-					      0x0059ff10);
-				break;	/* 45M */
-			case 1:
-				ini_acf_iireq_src_207m_7m();
-				apb_write_reg(DVBT_BASE + (0x44 << 2),
-					      0x0029aaa6);
-				break;	/* 20.833M */
-			case 2:
-				ini_acf_iireq_src_207m_7m();
-				apb_write_reg(DVBT_BASE + (0x44 << 2),
-					      0x00296665);
-				break;	/* 20.7M */
-			case 3:
-				ini_acf_iireq_src_2857m_7m();
-				apb_write_reg(DVBT_BASE + (0x44 << 2),
-					      0x00392491);
-				break;	/* 28.57M */
-			case 4:
-				ini_acf_iireq_src_24m_7m();
-				apb_write_reg(DVBT_BASE + (0x44 << 2),
-					      0x00300000);
-				break;	/* 24M */
-			default:
-				ini_acf_iireq_src_2857m_7m();
-				apb_write_reg(DVBT_BASE + (0x44 << 2),
-					      0x00392491);
-				break;	/* 28.57M */
-			}
-		} else if (bandwidth == 2) {	/* 6M */
-			switch (samplerate) {
-			case 0:
-				ini_acf_iireq_src_45m_6m();
-				apb_write_reg(DVBT_BASE + (0x44 << 2),
-					      0x00690000);
-				break;	/* 45M */
-			case 1:
-				ini_acf_iireq_src_207m_6m();
-				apb_write_reg(DVBT_BASE + (0x44 << 2),
-					      0x00309c3e);
-				break;	/* 20.833M */
-			case 2:
-				ini_acf_iireq_src_207m_6m();
-				apb_write_reg(DVBT_BASE + (0x44 << 2),
-					      0x002eaaaa);
-				break;	/* 20.7M */
-			case 3:
-				ini_acf_iireq_src_2857m_6m();
-				apb_write_reg(DVBT_BASE + (0x44 << 2),
-					      0x0042AA69);
-				break;	/* 28.57M */
-			case 4:
-				ini_acf_iireq_src_24m_6m();
-				apb_write_reg(DVBT_BASE + (0x44 << 2),
-					      0x00380000);
-				break;	/* 24M */
-			default:
-				ini_acf_iireq_src_2857m_6m();
-				apb_write_reg(DVBT_BASE + (0x44 << 2),
-					      0x0042AA69);
-				break;	/* 28.57M */
-			}
-		} else {	/* 5M */
-			switch (samplerate) {
-			case 0:
-				ini_acf_iireq_src_45m_5m();
-				apb_write_reg(DVBT_BASE + (0x44 << 2),
-					      0x007dfbe0);
-				break;	/* 45M */
-			case 1:
-				ini_acf_iireq_src_207m_5m();
-				apb_write_reg(DVBT_BASE + (0x44 << 2),
-					      0x003a554f);
-				break;	/* 20.833M */
-			case 2:
-				ini_acf_iireq_src_207m_5m();
-				apb_write_reg(DVBT_BASE + (0x44 << 2),
-					      0x0039f5c0);
-				break;	/* 20.7M */
-			case 3:
-				ini_acf_iireq_src_2857m_5m();
-				apb_write_reg(DVBT_BASE + (0x44 << 2),
-					      0x004FFFFE);
-				break;	/* 28.57M */
-			case 4:
-				ini_acf_iireq_src_24m_5m();
-				apb_write_reg(DVBT_BASE + (0x44 << 2),
-					      0x00433333);
-				break;	/* 24M */
-			default:
-				ini_acf_iireq_src_2857m_5m();
-				apb_write_reg(DVBT_BASE + (0x44 << 2),
-					      0x004FFFFE);
-				break;	/* 28.57M */
-			}
-		}
-	} else {		/* ISDBT */
-		switch (samplerate) {
-		case 0:
-			ini_acf_iireq_src_45m_6m();
-			apb_write_reg(DVBT_BASE + (0x44 << 2), 0x00589800);
-			break;	/* 45M
-			SampleRate/(symbolRate)*2^20,
-			symbolRate = 512/63 for isdbt */
-		case 1:
-			ini_acf_iireq_src_207m_6m();
-			apb_write_reg(DVBT_BASE + (0x44 << 2), 0x002903d4);
-			break;	/* 20.833M */
-		case 2:
-			ini_acf_iireq_src_207m_6m();
-			apb_write_reg(DVBT_BASE + (0x44 << 2), 0x00280ccc);
-			break;	/* 20.7M */
-		case 3:
-			ini_acf_iireq_src_2857m_6m();
-			apb_write_reg(DVBT_BASE + (0x44 << 2), 0x00383fc8);
-			break;	/* 28.57M */
-		case 4:
-			ini_acf_iireq_src_24m_6m();
-			apb_write_reg(DVBT_BASE + (0x44 << 2), 0x002F4000);
-			break;	/* 24M */
-		default:
-			ini_acf_iireq_src_2857m_6m();
-			apb_write_reg(DVBT_BASE + (0x44 << 2), 0x00383fc8);
-			break;	/* 28.57M */
-		}
-	}
-
-	if (mode == 0)		/* DVBT */
-		apb_write_reg(DVBT_BASE + (0x02 << 2),
-			      (bandwidth << 20) | 0x10002);
-	else			/* ISDBT */
-		apb_write_reg(DVBT_BASE + (0x02 << 2), (1 << 20) | 0x1001a);
-	/* {0x000,2'h1,20'h1_001a});    // For ISDBT , bandwith should be 1, */
-
-	apb_write_reg(DVBT_BASE + (0x45 << 2), 0x00000000);
-	/* SRC SFO_ADJ_CTRL */
-	apb_write_reg(DVBT_BASE + (0x46 << 2), 0x02004000);
-	/* SRC SFO_ADJ_CTRL */
-	apb_write_reg(DVBT_BASE + (0x48 << 2), 0x000c0287);
-	/* DAGC_CTRL1 */
-	apb_write_reg(DVBT_BASE + (0x49 << 2), 0x00000005);
-	/* DAGC_CTRL2 */
-	apb_write_reg(DVBT_BASE + (0x4c << 2), 0x00000bbf);
-	/* CCI_RP */
-	apb_write_reg(DVBT_BASE + (0x4d << 2), 0x00000376);
-	/* CCI_RPSQ */
-	apb_write_reg(DVBT_BASE + (0x4e << 2), 0x0f0f1d09);
-	/* CCI_CTRL */
-	apb_write_reg(DVBT_BASE + (0x4f << 2), 0x00000000);
-	/* CCI DET_INDX1 */
-	apb_write_reg(DVBT_BASE + (0x50 << 2), 0x00000000);
-	/* CCI DET_INDX2 */
-	apb_write_reg(DVBT_BASE + (0x51 << 2), 0x00000000);
-	/* CCI_NOTCH1_A1 */
-	apb_write_reg(DVBT_BASE + (0x52 << 2), 0x00000000);
-	/* CCI_NOTCH1_A2 */
-	apb_write_reg(DVBT_BASE + (0x53 << 2), 0x00000000);
-	/* CCI_NOTCH1_B1 */
-	apb_write_reg(DVBT_BASE + (0x54 << 2), 0x00000000);
-	/* CCI_NOTCH2_A1 */
-	apb_write_reg(DVBT_BASE + (0x55 << 2), 0x00000000);
-	/* CCI_NOTCH2_A2 */
-	apb_write_reg(DVBT_BASE + (0x56 << 2), 0x00000000);
-	/* CCI_NOTCH2_B1 */
-	apb_write_reg(DVBT_BASE + (0x58 << 2), 0x00000885);
-	/* MODE_DETECT_CTRL // 582 */
-	if (mode == 0)		/* DVBT */
-		apb_write_reg(DVBT_BASE + (0x5c << 2), 0x00001011);	/*  */
-	else
-		apb_write_reg(DVBT_BASE + (0x5c << 2), 0x00000753);
-	/* ICFO_EST_CTRL ISDBT ICFO thres = 2 */
-
-	apb_write_reg(DVBT_BASE + (0x5f << 2), 0x0ffffe10);
-	/* TPS_FCFO_CTRL */
-	apb_write_reg(DVBT_BASE + (0x61 << 2), 0x0000006c);
-	/* FWDT ctrl */
-	apb_write_reg(DVBT_BASE + (0x68 << 2), 0x128c3929);
-	apb_write_reg(DVBT_BASE + (0x69 << 2), 0x91017f2d);
-	/* 0x1a8 */
-	apb_write_reg(DVBT_BASE + (0x6b << 2), 0x00442211);
-	/* 0x1a8 */
-	apb_write_reg(DVBT_BASE + (0x6c << 2), 0x01fc400a);
-	/* 0x */
-	apb_write_reg(DVBT_BASE + (0x6d << 2), 0x0030303f);
-	/* 0x */
-	apb_write_reg(DVBT_BASE + (0x73 << 2), 0xffffffff);
-	/* CCI0_PILOT_UPDATE_CTRL */
-	apb_write_reg(DVBT_BASE + (0x74 << 2), 0xffffffff);
-	/* CCI0_DATA_UPDATE_CTRL */
-	apb_write_reg(DVBT_BASE + (0x75 << 2), 0xffffffff);
-	/* CCI1_PILOT_UPDATE_CTRL */
-	apb_write_reg(DVBT_BASE + (0x76 << 2), 0xffffffff);
-	/* CCI1_DATA_UPDATE_CTRL */
-
-	tmp = mode == 0 ? 0x000001a2 : 0x00000da2;
-	apb_write_reg(DVBT_BASE + (0x78 << 2), tmp);	/* FEC_CTR */
-
-	apb_write_reg(DVBT_BASE + (0x7d << 2), 0x0000009d);
-	apb_write_reg(DVBT_BASE + (0x7e << 2), 0x00004000);
-	apb_write_reg(DVBT_BASE + (0x7f << 2), 0x00008000);
-
-	apb_write_reg(DVBT_BASE + ((0x8b + 0) << 2), 0x20002000);
-	apb_write_reg(DVBT_BASE + ((0x8b + 1) << 2), 0x20002000);
-	apb_write_reg(DVBT_BASE + ((0x8b + 2) << 2), 0x20002000);
-	apb_write_reg(DVBT_BASE + ((0x8b + 3) << 2), 0x20002000);
-	apb_write_reg(DVBT_BASE + ((0x8b + 4) << 2), 0x20002000);
-	apb_write_reg(DVBT_BASE + ((0x8b + 5) << 2), 0x20002000);
-	apb_write_reg(DVBT_BASE + ((0x8b + 6) << 2), 0x20002000);
-	apb_write_reg(DVBT_BASE + ((0x8b + 7) << 2), 0x20002000);
-
-	apb_write_reg(DVBT_BASE + (0x93 << 2), 0x31);
-	apb_write_reg(DVBT_BASE + (0x94 << 2), 0x00);
-	apb_write_reg(DVBT_BASE + (0x95 << 2), 0x7f1);
-	apb_write_reg(DVBT_BASE + (0x96 << 2), 0x20);
-
-	apb_write_reg(DVBT_BASE + (0x98 << 2), 0x03f9115a);
-	apb_write_reg(DVBT_BASE + (0x9b << 2), 0x000005df);
-
-	apb_write_reg(DVBT_BASE + (0x9c << 2), 0x00100000);
-	/* TestBus write valid, 0 is system clk valid */
-	apb_write_reg(DVBT_BASE + (0x9d << 2), 0x01000000);
-	/* DDR Start address */
-	apb_write_reg(DVBT_BASE + (0x9e << 2), 0x02000000);
-	/* DDR End   address */
-
-	apb_write_regb(DVBT_BASE + (0x9b << 2), 7, 0);
-	/* Enable Testbus dump to DDR */
-	apb_write_regb(DVBT_BASE + (0x9b << 2), 8, 0);
-	/* Run Testbus dump to DDR */
-
-	apb_write_reg(DVBT_BASE + (0xd6 << 2), 0x00000003);
-	/* apb_write_reg(DVBT_BASE+(0xd7<<2), 0x00000008); */
-	apb_write_reg(DVBT_BASE + (0xd8 << 2), 0x00000120);
-	apb_write_reg(DVBT_BASE + (0xd9 << 2), 0x01010101);
-
-	ini_icfo_pn_index(mode);
-	tfd_filter_coff_ini();
-
-	calculate_cordic_para();
-	msleep(20);
-	/* delay_us(1); */
-
-	apb_write_reg(DVBT_BASE + (0x02 << 2),
-		      apb_read_reg(DVBT_BASE + (0x02 << 2)) | (1 << 0));
-	apb_write_reg(DVBT_BASE + (0x02 << 2),
-		      apb_read_reg(DVBT_BASE + (0x02 << 2)) | (1 << 24));
-#endif
-/* dvbt_check_status(); */
-}
-
-void calculate_cordic_para(void)
-{
-	apb_write_reg(DVBT_BASE + 0x0c, 0x00000040);
-}
-
-char *ofdm_fsm_name[] = { "    IDLE",
-	"     AGC",
-	"     CCI",
-	"     ACQ",
-	"    SYNC",
-	"TRACKING",
-	"  TIMING",
-	" SP_SYNC",
-	" TPS_DEC",
-	"FEC_LOCK",
-	"FEC_LOST"
-};
-
-void check_fsm_state(void)
-{
-	unsigned long tmp;
-
-	tmp = apb_read_reg(DVBT_BASE + 0xa8);
-	/* printk(">>>>>>>>>>>>>>>>>>>>>>>>> OFDM FSM From %d
-	to %d\n", tmp>>4&0xf, tmp&0xf); */
-
-	if ((tmp & 0xf) == 3) {
-		apb_write_regb(DVBT_BASE + (0x9b << 2), 8, 1);
-		/* Stop dump testbus; */
-		apb_write_regb(DVBT_BASE + (0x0f << 2), 0, 1);
-		tmp = apb_read_reg(DVBT_BASE + (0x9f << 2));
-		/* printk(">>>>>>>>>>>>>>>>>>>>>>>>> STOP DUMP DATA To DDR :
-		End Addr %d,Is it overflow?%d\n", tmp>>1, tmp&0x1); */
-	}
-}
-
-void ofdm_read_all_regs(void)
-{
-	int i;
-	unsigned long tmp;
-
-	for (i = 0; i < 0xff; i++)
-		tmp = apb_read_reg(DVBT_BASE + 0x00 + i * 4);
-	/* printk("OFDM Reg (0x%x) is 0x%x\n", i, tmp); */
-
-}
-
-static int dvbt_get_status(struct aml_demod_sta *demod_sta,
-			   struct aml_demod_i2c *demod_i2c)
-{
-	return apb_read_reg(DVBT_BASE + 0x0) >> 12 & 1;
-}
-
-static int dvbt_get_ber(struct aml_demod_sta *demod_sta,
-			struct aml_demod_i2c *demod_i2c)
-{
-/* pr_dbg("[RSJ]per is %u\n",apb_read_reg(DVBT_BASE+(0xbf<<2))); */
-	return apb_read_reg(DVBT_BASE + (0xbf << 2));
-}
-
-static int dvbt_get_snr(struct aml_demod_sta *demod_sta,
-			struct aml_demod_i2c *demod_i2c)
-{
-/* pr_dbg("2snr is %u\n",((apb_read_reg(DVBT_BASE+(0x0a<<2)))>>20)&0x3ff); */
-	return ((apb_read_reg(DVBT_BASE + (0x0a << 2))) >> 20) & 0x3ff;
-	/*dBm: bit0~bit2=decimal */
-}
-
-static int dvbt_get_strength(struct aml_demod_sta *demod_sta,
-			     struct aml_demod_i2c *demod_i2c)
-{
-/* int dbm = dvbt_get_ch_power(demod_sta, demod_i2c); */
-/* return dbm; */
-	return 0;
-}
-
-static int dvbt_get_ucblocks(struct aml_demod_sta *demod_sta,
-			     struct aml_demod_i2c *demod_i2c)
-{
-	return 0;
-/* return dvbt_get_per(); */
-}
-
-struct demod_status_ops *dvbt_get_status_ops(void)
-{
-	static struct demod_status_ops ops = {
-		.get_status = dvbt_get_status,
-		.get_ber = dvbt_get_ber,
-		.get_snr = dvbt_get_snr,
-		.get_strength = dvbt_get_strength,
-		.get_ucblocks = dvbt_get_ucblocks,
-	};
-
-	return &ops;
-}
-
-int app_apb_read_reg(int addr)
-{
-	addr = DTMB_TOP_ADDR(addr);
-	return (int)demod_read_demod_reg(addr);
-}
-
-int app_apb_write_reg(int addr, int data)
-{
-	addr = DTMB_TOP_ADDR(addr);
-	demod_set_demod_reg(data, addr);
-	return 0;
-}
-
-void monitor_isdbt(void)
-{
-	int SNR;
-	int SNR_SP = 500;
-	int SNR_TPS = 0;
-	int SNR_CP = 0;
-	int timeStamp = 0;
-	int SFO_residual = 0;
-	int SFO_esti = 0;
-	int FCFO_esti = 0;
-	int FCFO_residual = 0;
-	int AGC_Gain = 0;
-	int RF_AGC = 0;
-	int Signal_power = 0;
-	int FECFlag = 0;
-	int EQ_seg_ratio = 0;
-	int tps_0 = 0;
-	int tps_1 = 0;
-	int tps_2 = 0;
-
-	int time_stamp;
-	int SFO;
-	int FCFO;
-	int timing_adj;
-	int RS_CorrectNum;
-
-	int cnt;
-	int tmpAGCGain;
-
-	tmpAGCGain = 0;
-	cnt = 0;
-
-/* app_apb_write_reg(0x8, app_apb_read_reg(0x8) & ~(1 << 17));
-// TPS symbol index update : active high */
-	time_stamp = app_apb_read_reg(0x07) & 0xffff;
-	SNR = app_apb_read_reg(0x0a);
-	FECFlag = (app_apb_read_reg(0x00) >> 11) & 0x3;
-	SFO = app_apb_read_reg(0x47) & 0xfff;
-	SFO_esti = app_apb_read_reg(0x60) & 0xfff;
-	FCFO_esti = (app_apb_read_reg(0x60) >> 11) & 0xfff;
-	FCFO = (app_apb_read_reg(0x26)) & 0xffffff;
-	RF_AGC = app_apb_read_reg(0x0c) & 0x1fff;
-	timing_adj = app_apb_read_reg(0x6f) & 0x1fff;
-	RS_CorrectNum = app_apb_read_reg(0xc1) & 0xfffff;
-	Signal_power = (app_apb_read_reg(0x1b)) & 0x1ff;
-	EQ_seg_ratio = app_apb_read_reg(0x6e) & 0x3ffff;
-	tps_0 = app_apb_read_reg(0x64);
-	tps_1 = app_apb_read_reg(0x65);
-	tps_2 = app_apb_read_reg(0x66) & 0xf;
-
-	timeStamp = (time_stamp >> 8) * 68 + (time_stamp & 0x7f);
-	SFO_residual = (SFO > 0x7ff) ? (SFO - 0x1000) : SFO;
-	FCFO_residual = (FCFO > 0x7fffff) ? (FCFO - 0x1000000) : FCFO;
-	/* RF_AGC          = (RF_AGC>0x3ff)? (RF_AGC - 0x800): RF_AGC; */
-	FCFO_esti = (FCFO_esti > 0x7ff) ? (FCFO_esti - 0x1000) : FCFO_esti;
-	SNR_CP = (SNR) & 0x3ff;
-	SNR_TPS = (SNR >> 10) & 0x3ff;
-	SNR_SP = (SNR >> 20) & 0x3ff;
-	SNR_SP = (SNR_SP > 0x1ff) ? SNR_SP - 0x400 : SNR_SP;
-	SNR_TPS = (SNR_TPS > 0x1ff) ? SNR_TPS - 0x400 : SNR_TPS;
-	SNR_CP = (SNR_CP > 0x1ff) ? SNR_CP - 0x400 : SNR_CP;
-	AGC_Gain = tmpAGCGain >> 4;
-	tmpAGCGain = (AGC_Gain > 0x3ff) ? AGC_Gain - 0x800 : AGC_Gain;
-	timing_adj = (timing_adj > 0xfff) ? timing_adj - 0x2000 : timing_adj;
-	EQ_seg_ratio =
-	    (EQ_seg_ratio > 0x1ffff) ? EQ_seg_ratio - 0x40000 : EQ_seg_ratio;
-
-	pr_dbg
-	    ("T %4x SP %3d TPS %3d CP %3d EQS %8x RSC %4d",
-	     app_apb_read_reg(0xbf)
-	     , SNR_SP, SNR_TPS, SNR_CP
-/* ,EQ_seg_ratio */
-	     , app_apb_read_reg(0x62)
-	     , RS_CorrectNum);
-	pr_dbg
-	    ("SFO %4d FCFO %4d Vit %4x Timing %3d SigP %3x",
-	    SFO_residual, FCFO_residual, RF_AGC, timing_adj,
-	     Signal_power);
-	pr_dbg
-	    ("FEC %x RSErr %8x ReSyn %x tps %03x%08x",
-	    FECFlag, app_apb_read_reg(0x0b)
-	     , (app_apb_read_reg(0xc0) >> 20) & 0xff,
-	     app_apb_read_reg(0x05) & 0xfff, app_apb_read_reg(0x04)
-	    );
-	pr_dbg("\n");
-}
-
-int find_2(int data, int *table, int len)
-{
-	int end;
-	int index;
-	int start;
-	int cnt = 0;
-
-	start = 0;
-	end = len;
-	/* printf("data is %d\n",data); */
-	while ((len > 1) && (cnt < 10)) {
-		cnt++;
-		index = (len / 2);
-		if (data > table[start + index]) {
-			start = start + index;
-			len = len - index - 1;
-		}
-		if (data < table[start + index]) {
-			len = index + 1;
-		} else if (data == table[start + index]) {
-			start = start + index;
-			break;
-		}
-	}
-	return start;
-}
-
-int read_atsc_all_reg(void)
-{
-	return 0;
-#if 0
-	int i, j, k;
-	j = 4;
-	unsigned long data;
-	pr_dbg("system agc is:");	/* system agc */
-	for (i = 0xc00; i <= 0xc0c; i++) {
-		data = atsc_read_reg(i);
-		if (j == 4) {
-			pr_dbg("\n[addr:0x%x]", i);
-			j = 0;
-		}
-		pr_dbg("%02x   ", data);
-		j++;
-	}
-	j = 4;
-	for (i = 0xc80; i <= 0xc87; i++) {
-		data = atsc_read_reg(i);
-		if (j == 4) {
-			pr_dbg("\n[addr:0x%x]", i);
-			j = 0;
-		}
-		pr_dbg("%02x   ", data);
-		j++;
-	}
-	pr_dbg("\n vsb control is:");	/*vsb control */
-	j = 4;
-	for (i = 0x900; i <= 0x905; i++) {
-		data = atsc_read_reg(i);
-		if (j == 4) {
-			pr_dbg("\n[addr:0x%x]", i);
-			j = 0;
-		}
-		pr_dbg("%02x   ", data);
-		j++;
-	}
-	j = 4;
-	for (i = 0x908; i <= 0x912; i++) {
-		data = atsc_read_reg(i);
-		if (j == 4) {
-			pr_dbg("\n[addr:0x%x]", i);
-			j = 0;
-		}
-		pr_dbg("%02x   ", data);
-		j++;
-	}
-	j = 4;
-	for (i = 0x917; i <= 0x91b; i++) {
-		data = atsc_read_reg(i);
-		if (j == 4) {
-			pr_dbg("\n[addr:0x%x]", i);
-			j = 0;
-		}
-		pr_dbg("%02x   ", data);
-		j++;
-	}
-	j = 4;
-	for (i = 0x980; i <= 0x992; i++) {
-		data = atsc_read_reg(i);
-		if (j == 4) {
-			pr_dbg("\n[addr:0x%x]", i);
-			j = 0;
-		}
-		pr_dbg("%02x   ", data);
-		j++;
-	}
-	pr_dbg("\n vsb demod is:");	/*vsb demod */
-	j = 4;
-	for (i = 0x700; i <= 0x711; i++) {
-		data = atsc_read_reg(i);
-		if (j == 4) {
-			pr_dbg("\n[addr:0x%x]", i);
-			j = 0;
-		}
-		pr_dbg("%02x   ", data);
-		j++;
-	}
-	j = 4;
-	for (i = 0x716; i <= 0x720; i++) {
-		data = atsc_read_reg(i);
-		if (j == 4) {
-			pr_dbg("\n[addr:0x%x]", i);
-			j = 0;
-		}
-		pr_dbg("%02x   ", data);
-		j++;
-	}
-	j = 4;
-	for (i = 0x722; i <= 0x724; i++) {
-		data = atsc_read_reg(i);
-		if (j == 4) {
-			pr_dbg("\n[addr:0x%x]", i);
-			j = 0;
-		}
-		pr_dbg("%02x   ", data);
-		j++;
-	}
-	j = 4;
-	for (i = 0x726; i <= 0x72c; i++) {
-		data = atsc_read_reg(i);
-		if (j == 4) {
-			pr_dbg("\n[addr:0x%x]", i);
-			j = 0;
-		}
-		pr_dbg("%02x   ", data);
-		j++;
-	}
-	j = 4;
-	for (i = 0x730; i <= 0x732; i++) {
-		data = atsc_read_reg(i);
-		if (j == 4) {
-			pr_dbg("\n[addr:0x%x]", i);
-			j = 0;
-		}
-		pr_dbg("%02x   ", data);
-		j++;
-	}
-	j = 4;
-	for (i = 0x735; i <= 0x751; i++) {
-		data = atsc_read_reg(i);
-		if (j == 4) {
-			pr_dbg("\n[addr:0x%x]", i);
-			j = 0;
-		}
-		pr_dbg("%02x   ", data);
-		j++;
-	}
-	j = 4;
-	for (i = 0x780; i <= 0x795; i++) {
-		data = atsc_read_reg(i);
-		if (j == 4) {
-			pr_dbg("\n[addr:0x%x]", i);
-			j = 0;
-		}
-		pr_dbg("%02x   ", data);
-		j++;
-	}
-	j = 4;
-	for (i = 0x752; i <= 0x755; i++) {
-		data = atsc_read_reg(i);
-		if (j == 4) {
-			pr_dbg("\n[addr:0x%x]", i);
-			j = 0;
-		}
-		pr_dbg("%02x   ", data);
-		j++;
-	}
-	pr_dbg("\n vsb equalizer is:");	/*vsb equalizer */
-	j = 4;
-	for (i = 0x501; i <= 0x5ff; i++) {
-		data = atsc_read_reg(i);
-		if (j == 4) {
-			pr_dbg("\n[addr:0x%x]", i);
-			j = 0;
-		}
-		pr_dbg("%02x   ", data);
-		j++;
-	}
-	pr_dbg("\n vsb fec is:");	/*vsb fec */
-	j = 4;
-	for (i = 0x601; i <= 0x601; i++) {
-		data = atsc_read_reg(i);
-		if (j == 4) {
-			pr_dbg("\n[addr:0x%x]", i);
-			j = 0;
-		}
-		pr_dbg("%02x   ", data);
-		j++;
-	}
-	j = 4;
-	for (i = 0x682; i <= 0x685; i++) {
-		data = atsc_read_reg(i);
-		if (j == 4) {
-			pr_dbg("\n[addr:0x%x]", i);
-			j = 0;
-		}
-		pr_dbg("%02x   ", data);
-		j++;
-	}
-	pr_dbg("\n qam demod is:");	/*qam demod */
-	j = 4;
-	for (i = 0x1; i <= 0x1a; i++) {
-		data = atsc_read_reg(i);
-		if (j == 4) {
-			pr_dbg("\n[addr:0x%x]", i);
-			j = 0;
-		}
-		pr_dbg("%02x   ", data);
-		j++;
-	}
-	j = 4;
-	for (i = 0x25; i <= 0x28; i++) {
-		data = atsc_read_reg(i);
-		if (j == 4) {
-			pr_dbg("\n[addr:0x%x]", i);
-			j = 0;
-		}
-		pr_dbg("%02x   ", data);
-		j++;
-	}
-	j = 4;
-	for (i = 0x101; i <= 0x10b; i++) {
-		data = atsc_read_reg(i);
-		if (j == 4) {
-			pr_dbg("\n[addr:0x%x]", i);
-			j = 0;
-		}
-		pr_dbg("%02x   ", data);
-		j++;
-	}
-	j = 4;
-	for (i = 0x206; i <= 0x207; i++) {
-		data = atsc_read_reg(i);
-		if (j == 4) {
-			pr_dbg("\n[addr:0x%x]", i);
-			j = 0;
-		}
-		pr_dbg("%02x   ", data);
-		j++;
-	}
-	pr_dbg("\n qam equalize is:");	/*qam equalize */
-	j = 4;
-	for (i = 0x200; i <= 0x23d; i++) {
-		data = atsc_read_reg(i);
-		if (j == 4) {
-			pr_dbg("\n[addr:0x%x]", i);
-			j = 0;
-		}
-		pr_dbg("%02x   ", data);
-		j++;
-	}
-	j = 4;
-	for (i = 0x260; i <= 0x275; i++) {
-		data = atsc_read_reg(i);
-		if (j == 4) {
-			pr_dbg("\n[addr:0x%x]", i);
-			j = 0;
-		}
-		pr_dbg("%02x   ", data);
-		j++;
-	}
-	pr_dbg("\n qam fec is:");	/*qam fec */
-	j = 4;
-	for (i = 0x400; i <= 0x418; i++) {
-		data = atsc_read_reg(i);
-		if (j == 4) {
-			pr_dbg("\n[addr:0x%x]", i);
-			j = 0;
-		}
-		pr_dbg("%02x   ", data);
-		j++;
-	}
-	pr_dbg("\n system mpeg formatter is:");	/*system mpeg formatter */
-	j = 4;
-	for (i = 0xf00; i <= 0xf09; i++) {
-		data = atsc_read_reg(i);
-		if (j == 4) {
-			pr_dbg("\n[addr:0x%x]", i);
-			j = 0;
-		}
-		pr_dbg("%02x   ", data);
-		j++;
-	}
-	pr_dbg("\n\n");
-	return 0;
-#endif
-}
-
-int check_atsc_fsm_status(void)
-{
-	int SNR;
-	int atsc_snr = 0;
-	int SNR_dB;
-	int SNR_table[56] = { 0, 7, 9, 11, 14,
-		17,
-		22,
-		27, 34, 43, 54,
-		68, 86, 108, 136, 171,
-		215,
-		271, 341,
-		429, 540,
-		566, 592, 620, 649, 680,
-		712,
-		746, 781,
-		818, 856,
-		896, 939, 983, 1029, 1078,
-		1182,
-		1237,
-		1237, 1296, 1357,
-		1708, 2150, 2707, 3408, 4291,
-		5402,
-		6800,
-		8561, 10778, 13568,
-		16312, 17081, 18081, 19081, 65536
-	};
-	int SNR_dB_table[56] = { 360, 350, 340, 330, 320, 310, 300,
-		290,
-		280,
-		270, 260,
-		250, 240, 230, 220, 210, 200, 190,
-		180,
-		170,
-		160,
-		158, 156, 154, 152, 150, 148, 146,
-		144,
-		142,
-		140,
-		138, 136, 134, 132, 130, 128, 126,
-		124,
-		122,
-		120,
-		110, 100, 90, 80, 70, 60, 50,
-		40,
-		30,
-		20,
-		12, 10, 4, 2, 0
-	};
-
-	int tmp[3];
-	int cr;
-	int ck;
-	int SM;
-	int tni;
-	int ber;
-	int per;
-
-	int cnt;
-
-	cnt = 0;
-	ber = 0;
-	per = 0;
-
-/* g_demod_mode    = 2; */
-	tni = atsc_read_reg((0x08) >> 16);
-/* g_demod_mode    = 4; */
-	tmp[0] = atsc_read_reg(0x0511);
-	tmp[1] = atsc_read_reg(0x0512);
-	SNR = (tmp[0] << 8) + tmp[1];
-	SNR_dB = SNR_dB_table[find_2(SNR, SNR_table, 56)];
-
-	tmp[0] = atsc_read_reg(0x0780);
-	tmp[1] = atsc_read_reg(0x0781);
-	tmp[2] = atsc_read_reg(0x0782);
-	cr = tmp[0] + (tmp[1] << 8) + (tmp[2] << 16);
-	tmp[0] = atsc_read_reg(0x0786);
-	tmp[1] = atsc_read_reg(0x0787);
-	tmp[2] = atsc_read_reg(0x0788);
-	ck = (tmp[0] << 16) + (tmp[1] << 8) + tmp[2];
-	ck = (ck > 8388608) ? ck - 16777216 : ck;
-	SM = atsc_read_reg(0x0980);
-/* ber per */
-	atsc_write_reg(0x0601, atsc_read_reg(0x0601) & (~(1 << 3)));
-	atsc_write_reg(0x0601, atsc_read_reg(0x0601) | (1 << 3));
-	ber = atsc_read_reg(0x0683) + (atsc_read_reg(0x0682) << 8);
-	per = atsc_read_reg(0x0685) + (atsc_read_reg(0x0684) << 8);
-
-/* read_atsc_all_reg(); */
-
-	pr_dbg
-	    ("INT %x SNR %x SNRdB %d.%d FSM %x cr %d ck %d",
-	     tni, SNR, (SNR_dB / 10)
-	     , (SNR_dB - (SNR_dB / 10) * 10)
-	     , SM, cr, ck);
-	pr_dbg
-		("ber is %d, per is %d\n",
-		ber, per);
-
-	atsc_snr = (SNR_dB / 10);
-	return atsc_snr;
-
-	/*   unsigned long sm,snr1,snr2,snr;
-	 * static int fec_lock_cnt = 0;
-	 *
-	 * delay_us(10000);
-	 * sm = atsc_read_reg(0x0980);
-	 * snr1 = atsc_read_reg(0x0511)&0xff;
-	 * snr2 = atsc_read_reg(0x0512)&0xff;
-	 * snr  = (snr1 << 8) + snr2;
-	 *
-	 * printk(">>>>>>>>>>>>>>>>>>>>>>>>>
-	 OFDM FSM %x    SNR %x\n", sm&0xff, snr);
-	 *
-	 * if (sm == 0x79) stimulus_finish_pass();*/
-}
diff --git a/drivers/amlogic/dvb_tv/amldemod/dvbc_func.c b/drivers/amlogic/dvb_tv/amldemod/dvbc_func.c
deleted file mode 100644
index 4db65c5812f7..000000000000
--- a/drivers/amlogic/dvb_tv/amldemod/dvbc_func.c
+++ /dev/null
@@ -1,1238 +0,0 @@
-#include <linux/kernel.h>
-#include <linux/i2c.h>
-#include <linux/delay.h>
-#include <linux/dvb/aml_demod.h>
-#include "demod_func.h"
-#include <linux/kthread.h>
-
-static int debug_amldvbc = 1;
-#define dprintk(a ...) do { if (debug_amldvbc) printk(a); } while (0)
-
-static struct task_struct *cci_task;
-int cciflag = 0;
-struct timer_list mytimer;
-
-static void dvbc_cci_timer(unsigned long data)
-{
-#if 0
-	int count;
-	int maxCCI_p, re, im, j, i, times, maxCCI, sum, sum1, reg_0xf0, tmp1,
-	    tmp, tmp2, reg_0xa8, reg_0xac;
-	int reg_0xa8_t, reg_0xac_t;
-	count = 100;
-	if ((((apb_read_reg(QAM_BASE + 0x18)) & 0x1) == 1)) {
-		dprintk("[cci]lock ");
-		if (cciflag == 0) {
-			apb_write_reg(QAM_BASE + 0xa8, 0);
-
-			cciflag = 0;
-		}
-		dprintk("\n");
-		mdelay(500);
-		mod_timer(&mytimer, jiffies + 2 * HZ);
-		return;
-	}
-	if (cciflag == 1) {
-		dprintk("[cci]cciflag is 1,wait 20\n");
-		mdelay(20000);
-	}
-	times = 300;
-	tmp = 0x2be2be3;
-	/*0x2ae4772;  IF = 6M, fs = 35M, dec2hex(round(8*IF/fs*2^25)) */
-	tmp2 = 0x2000;
-	tmp1 = 8;
-	reg_0xa8 = 0xc0000000;	/* bypass CCI */
-	reg_0xac = 0xc0000000;	/* bypass CCI */
-
-	maxCCI = 0;
-	maxCCI_p = 0;
-	for (i = 0; i < times; i++) {
-		/*reg_0xa8 = app_apb_read_reg(0xa8); */
-		reg_0xa8_t = reg_0xa8 + tmp + i * tmp2;
-		apb_write_reg(QAM_BASE + 0xa8, reg_0xa8_t);
-		reg_0xac_t = reg_0xac + tmp - i * tmp2;
-		apb_write_reg(QAM_BASE + 0xac, reg_0xac_t);
-		sum = 0;
-		sum1 = 0;
-		for (j = 0; j < tmp1; j++) {
-			/* msleep(20); */
-			/* mdelay(20); */
-			reg_0xf0 = apb_read_reg(QAM_BASE + 0xf0);
-			re = (reg_0xf0 >> 24) & 0xff;
-			im = (reg_0xf0 >> 16) & 0xff;
-			if (re > 127)
-				/*re = re - 256; */
-				re = 256 - re;
-			if (im > 127)
-				/*im = im - 256; */
-				im = 256 - im;
-
-			sum += re + im;
-			re = (reg_0xf0 >> 8) & 0xff;
-			im = (reg_0xf0 >> 0) & 0xff;
-			if (re > 127)
-				/*re = re - 256; */
-				re = 256 - re;
-			if (im > 127)
-				/*im = im - 256; */
-				im = 256 - im;
-
-			sum1 += re + im;
-		}
-		sum = sum / tmp1;
-		sum1 = sum1 / tmp1;
-		if (sum1 > sum) {
-			sum = sum1;
-			reg_0xa8_t = reg_0xac_t;
-		}
-		if (sum > maxCCI) {
-			maxCCI = sum;
-			if (maxCCI > 24)
-				maxCCI_p = reg_0xa8_t & 0x7fffffff;
-		}
-		if ((sum < 24) && (maxCCI_p > 0))
-			break;	/* stop CCI detect. */
-	}
-
-	if (maxCCI_p > 0) {
-		apb_write_reg(QAM_BASE + 0xa8, maxCCI_p & 0x7fffffff);
-		/* enable CCI */
-		apb_write_reg(QAM_BASE + 0xac, maxCCI_p & 0x7fffffff);
-		/* enable CCI */
-		/*     if(dvbc.mode == 4) // 256QAM */
-		apb_write_reg(QAM_BASE + 0x54, 0xa25705fa);
-		/**/ cciflag = 1;
-		mdelay(1000);
-	} else {
-		dprintk
-		    ("[cci] ------------  find NO CCI -------------------\n");
-		cciflag = 0;
-	}
-
-	dprintk("[cci][%s]--------------------------\n", __func__);
-	mod_timer(&mytimer, jiffies + 2 * HZ);
-	return;
-/*      }*/
-#endif
-}
-
-int dvbc_timer_init(void)
-{
-	dprintk("%s\n", __func__);
-	setup_timer(&mytimer, dvbc_cci_timer, (unsigned long)"Hello, world!");
-	mytimer.expires = jiffies + 2 * HZ;
-	add_timer(&mytimer);
-	return 0;
-}
-
-void dvbc_timer_exit(void)
-{
-	dprintk("%s\n", __func__);
-	del_timer(&mytimer);
-}
-
-int dvbc_cci_task(void *data)
-{
-	int count;
-	int maxCCI_p, re, im, j, i, times, maxCCI, sum, sum1, reg_0xf0, tmp1,
-	    tmp, tmp2, reg_0xa8, reg_0xac;
-	int reg_0xa8_t, reg_0xac_t;
-
-	count = 100;
-	while (1) {
-		msleep(200);
-		if ((((apb_read_reg(QAM_BASE + 0x18)) & 0x1) == 1)) {
-			dprintk("[cci]lock ");
-			if (cciflag == 0) {
-				apb_write_reg(QAM_BASE + 0xa8, 0);
-				apb_write_reg(QAM_BASE + 0xac, 0);
-				dprintk("no cci ");
-				cciflag = 0;
-			}
-			dprintk("\n");
-			msleep(500);
-			continue;
-		}
-
-		if (cciflag == 1) {
-			dprintk("[cci]cciflag is 1,wait 20\n");
-			msleep(20000);
-		}
-		times = 300;
-		tmp = 0x2be2be3;
-		/*0x2ae4772; IF = 6M,fs = 35M, dec2hex(round(8*IF/fs*2^25)) */
-		tmp2 = 0x2000;
-		tmp1 = 8;
-		reg_0xa8 = 0xc0000000;	/* bypass CCI */
-		reg_0xac = 0xc0000000;	/* bypass CCI */
-
-		maxCCI = 0;
-		maxCCI_p = 0;
-		for (i = 0; i < times; i++) {
-			/*reg_0xa8 = app_apb_read_reg(0xa8); */
-			reg_0xa8_t = reg_0xa8 + tmp + i * tmp2;
-			apb_write_reg(QAM_BASE + 0xa8, reg_0xa8_t);
-			reg_0xac_t = reg_0xac + tmp - i * tmp2;
-			apb_write_reg(QAM_BASE + 0xac, reg_0xac_t);
-			sum = 0;
-			sum1 = 0;
-			for (j = 0; j < tmp1; j++) {
-				/*         msleep(1); */
-				reg_0xf0 = apb_read_reg(QAM_BASE + 0xf0);
-				re = (reg_0xf0 >> 24) & 0xff;
-				im = (reg_0xf0 >> 16) & 0xff;
-				if (re > 127)
-					/*re = re - 256; */
-					re = 256 - re;
-				if (im > 127)
-					/*im = im - 256; */
-					im = 256 - im;
-
-				sum += re + im;
-
-				re = (reg_0xf0 >> 8) & 0xff;
-				im = (reg_0xf0 >> 0) & 0xff;
-				if (re > 127)
-					/*re = re - 256; */
-					re = 256 - re;
-				if (im > 127)
-					/*im = im - 256; */
-					im = 256 - im;
-
-				sum1 += re + im;
-			}
-			sum = sum / tmp1;
-			sum1 = sum1 / tmp1;
-			if (sum1 > sum) {
-				sum = sum1;
-				reg_0xa8_t = reg_0xac_t;
-			}
-			if (sum > maxCCI) {
-				maxCCI = sum;
-				if (maxCCI > 24)
-					maxCCI_p = reg_0xa8_t & 0x7fffffff;
-			}
-
-			if ((sum < 24) && (maxCCI_p > 0))
-				break;	/* stop CCI detect. */
-		}
-
-		if (maxCCI_p > 0) {
-			apb_write_reg(QAM_BASE + 0xa8, maxCCI_p & 0x7fffffff);
-			/* enable CCI */
-			apb_write_reg(QAM_BASE + 0xac, maxCCI_p & 0x7fffffff);
-			/* enable CCI */
-			/*     if(dvbc.mode == 4) // 256QAM */
-			apb_write_reg(QAM_BASE + 0x54, 0xa25705fa);
-			/**/ cciflag = 1;
-			msleep(1000);
-		} else {
-			cciflag = 0;
-		}
-
-		dprintk("[cci][%s]--------------------------\n", __func__);
-	}
-	return 0;
-}
-
-int dvbc_get_cci_task(void)
-{
-	if (cci_task)
-		return 0;
-	else
-		return 1;
-}
-
-void dvbc_create_cci_task(void)
-{
-	int ret;
-
-	/*apb_write_reg(QAM_BASE+0xa8, 0x42b2ebe3); // enable CCI */
-	/* apb_write_reg(QAM_BASE+0xac, 0x42b2ebe3); // enable CCI */
-/*     if(dvbc.mode == 4) // 256QAM*/
-	/* apb_write_reg(QAM_BASE+0x54, 0xa25705fa); // */
-	ret = 0;
-	cci_task = kthread_create(dvbc_cci_task, NULL, "cci_task");
-	if (ret != 0) {
-		dprintk("[%s]Create cci kthread error!\n", __func__);
-		cci_task = NULL;
-		return;
-	}
-	wake_up_process(cci_task);
-	dprintk("[%s]Create cci kthread and wake up!\n", __func__);
-}
-
-void dvbc_kill_cci_task(void)
-{
-	if (cci_task) {
-		kthread_stop(cci_task);
-		cci_task = NULL;
-		dprintk("[%s]kill cci kthread !\n", __func__);
-	}
-}
-
-u32 dvbc_set_qam_mode(unsigned char mode)
-{
-	dprintk("auto change mode ,now mode is %d\n", mode);
-	apb_write_reg(QAM_BASE + 0x008, (mode & 7));
-	/* qam mode */
-	switch (mode) {
-	case 0:		/* 16 QAM */
-		apb_write_reg(QAM_BASE + 0x054, 0x23460224);
-		/* EQ_FIR_CTL, */
-		apb_write_reg(QAM_BASE + 0x068, 0x00c000c0);
-		/* EQ_CRTH_SNR */
-		apb_write_reg(QAM_BASE + 0x074, 0x50001a0);
-		/* EQ_TH_LMS  40db      13db */
-		apb_write_reg(QAM_BASE + 0x07c, 0x003001e9);
-		/* EQ_NORM and EQ_TH_MMA */
-		/*apb_write_reg(QAM_BASE+0x080, 0x000be1ff);
-		 * // EQ_TH_SMMA0*/
-		apb_write_reg(QAM_BASE + 0x080, 0x000e01fe);
-		/* EQ_TH_SMMA0 */
-		apb_write_reg(QAM_BASE + 0x084, 0x00000000);
-		/* EQ_TH_SMMA1 */
-		apb_write_reg(QAM_BASE + 0x088, 0x00000000);
-		/* EQ_TH_SMMA2 */
-		apb_write_reg(QAM_BASE + 0x08c, 0x00000000);
-		/* EQ_TH_SMMA3 */
-		/*apb_write_reg(QAM_BASE+0x094, 0x7f800d2b);
-		 * // AGC_CTRL  ALPS tuner*/
-		/*apb_write_reg(QAM_BASE+0x094, 0x7f80292b);
-		 * // Pilips Tuner*/
-		/*apb_write_reg(QAM_BASE+0x094, 0x7f80292d);
-		 * // Pilips Tuner*/
-		apb_write_reg(QAM_BASE + 0x094, 0x7f80092d);
-		/* Pilips Tuner */
-		apb_write_reg(QAM_BASE + 0x0c0, 0x061f2f66);
-		/* by raymond 20121213 */
-		break;
-
-	case 1:		/* 32 QAM */
-		apb_write_reg(QAM_BASE + 0x054, 0x24560506);
-		/* EQ_FIR_CTL, */
-		apb_write_reg(QAM_BASE + 0x068, 0x00c000c0);
-		/* EQ_CRTH_SNR */
-		/*apb_write_reg(QAM_BASE+0x074, 0x5000260);
-		 * // EQ_TH_LMS      40db  19db*/
-		apb_write_reg(QAM_BASE + 0x074, 0x50001f0);
-		/* EQ_TH_LMS  40db      17.5db */
-		apb_write_reg(QAM_BASE + 0x07c, 0x00500102);
-		/* EQ_TH_MMA  0x000001cc */
-		apb_write_reg(QAM_BASE + 0x080, 0x00077140);
-		/* EQ_TH_SMMA0 */
-		apb_write_reg(QAM_BASE + 0x084, 0x001fb000);
-		/* EQ_TH_SMMA1 */
-		apb_write_reg(QAM_BASE + 0x088, 0x00000000);
-		/* EQ_TH_SMMA2 */
-		apb_write_reg(QAM_BASE + 0x08c, 0x00000000);
-		/* EQ_TH_SMMA3 */
-		/*apb_write_reg(QAM_BASE+0x094, 0x7f800d2b);
-		 * // AGC_CTRL  ALPS tuner*/
-		/*apb_write_reg(QAM_BASE+0x094, 0x7f80292b);
-		 * // Pilips Tuner*/
-		apb_write_reg(QAM_BASE + 0x094, 0x7f80092b);
-		/* Pilips Tuner */
-		apb_write_reg(QAM_BASE + 0x0c0, 0x061f2f66);
-		/* by raymond 20121213 */
-		break;
-
-	case 2:		/* 64 QAM */
-		/*apb_write_reg(QAM_BASE+0x054, 0x2256033a);
-		 * // EQ_FIR_CTL,*/
-		apb_write_reg(QAM_BASE + 0x054, 0x2336043a);
-		/* EQ_FIR_CTL, by raymond */
-		apb_write_reg(QAM_BASE + 0x068, 0x00c000c0);
-		/* EQ_CRTH_SNR */
-		/*apb_write_reg(QAM_BASE+0x074, 0x5000260);
-		 * // EQ_TH_LMS  40db  19db*/
-		apb_write_reg(QAM_BASE + 0x074, 0x5000230);
-		/* EQ_TH_LMS  40db      17.5db */
-		apb_write_reg(QAM_BASE + 0x07c, 0x007001bd);
-		/* EQ_TH_MMA */
-		apb_write_reg(QAM_BASE + 0x080, 0x000580ed);
-		/* EQ_TH_SMMA0 */
-		apb_write_reg(QAM_BASE + 0x084, 0x001771fb);
-		/* EQ_TH_SMMA1 */
-		apb_write_reg(QAM_BASE + 0x088, 0x00000000);
-		/* EQ_TH_SMMA2 */
-		apb_write_reg(QAM_BASE + 0x08c, 0x00000000);
-		/* EQ_TH_SMMA3 */
-		/*apb_write_reg(QAM_BASE+0x094, 0x7f800d2c);
-		 * // AGC_CTRL  ALPS tuner*/
-		/*apb_write_reg(QAM_BASE+0x094, 0x7f80292c);
-		 * // Pilips & maxlinear Tuner*/
-		apb_write_reg(QAM_BASE + 0x094, 0x7f802b3d);
-		/* Pilips Tuner & maxlinear Tuner */
-		/*apb_write_reg(QAM_BASE+0x094, 0x7f802b3a);
-		 * // Pilips Tuner & maxlinear Tuner*/
-		apb_write_reg(QAM_BASE + 0x0c0, 0x061f2f66);
-		/* by raymond 20121213 */
-		break;
-
-	case 3:		/* 128 QAM */
-		/*apb_write_reg(QAM_BASE+0x054, 0x2557046a);
-		 * // EQ_FIR_CTL,*/
-		apb_write_reg(QAM_BASE + 0x054, 0x2437067a);
-		/* EQ_FIR_CTL, by raymond 20121213 */
-		apb_write_reg(QAM_BASE + 0x068, 0x00c000d0);
-		/* EQ_CRTH_SNR */
-		/* apb_write_reg(QAM_BASE+0x074, 0x02440240);
-		 * // EQ_TH_LMS  18.5db  18db*/
-		/* apb_write_reg(QAM_BASE+0x074, 0x04000400);
-		 * // EQ_TH_LMS  22db  22.5db*/
-		apb_write_reg(QAM_BASE + 0x074, 0x5000260);
-		/* EQ_TH_LMS  40db      19db */
-		/*apb_write_reg(QAM_BASE+0x07c, 0x00b000f2);
-		 * // EQ_TH_MMA0x000000b2*/
-		apb_write_reg(QAM_BASE + 0x07c, 0x00b00132);
-		/* EQ_TH_MMA0x000000b2 by raymond 20121213 */
-		apb_write_reg(QAM_BASE + 0x080, 0x0003a09d);
-		/* EQ_TH_SMMA0 */
-		apb_write_reg(QAM_BASE + 0x084, 0x000f8150);
-		/* EQ_TH_SMMA1 */
-		apb_write_reg(QAM_BASE + 0x088, 0x001a51f8);
-		/* EQ_TH_SMMA2 */
-		apb_write_reg(QAM_BASE + 0x08c, 0x00000000);
-		/* EQ_TH_SMMA3 */
-		/*apb_write_reg(QAM_BASE+0x094, 0x7f800d2c);
-		 * // AGC_CTRL  ALPS tuner*/
-		/*apb_write_reg(QAM_BASE+0x094, 0x7f80292c);
-		 * // Pilips Tuner*/
-		apb_write_reg(QAM_BASE + 0x094, 0x7f80092c);
-		/* Pilips Tuner */
-		apb_write_reg(QAM_BASE + 0x0c0, 0x061f2f66);
-		/* by raymond 20121213 */
-		break;
-
-	case 4:		/* 256 QAM */
-		/*apb_write_reg(QAM_BASE+0x054, 0xa2580588);
-		 * // EQ_FIR_CTL,*/
-		apb_write_reg(QAM_BASE + 0x054, 0xa25905f9);
-		/* EQ_FIR_CTL, by raymond 20121213 */
-		apb_write_reg(QAM_BASE + 0x068, 0x01e00220);
-		/* EQ_CRTH_SNR */
-		/*apb_write_reg(QAM_BASE+0x074,  0x50002a0);
-		 * // EQ_TH_LMS      40db  19db*/
-		apb_write_reg(QAM_BASE + 0x074, 0x5000270);
-		/* EQ_TH_LMS  40db      19db by raymond 201211213 */
-		apb_write_reg(QAM_BASE + 0x07c, 0x00f001a5);
-		/* EQ_TH_MMA */
-		apb_write_reg(QAM_BASE + 0x080, 0x0002c077);
-		/* EQ_TH_SMMA0 */
-		apb_write_reg(QAM_BASE + 0x084, 0x000bc0fe);
-		/* EQ_TH_SMMA1 */
-		apb_write_reg(QAM_BASE + 0x088, 0x0013f17e);
-		/* EQ_TH_SMMA2 */
-		apb_write_reg(QAM_BASE + 0x08c, 0x01bc01f9);
-		/* EQ_TH_SMMA3 */
-		/*apb_write_reg(QAM_BASE+0x094, 0x7f800d2c);
-		 * // AGC_CTRL  ALPS tuner*/
-		/*apb_write_reg(QAM_BASE+0x094, 0x7f80292c);
-		 * // Pilips Tuner*/
-		/*apb_write_reg(QAM_BASE+0x094, 0x7f80292d);
-		 * // Maxlinear Tuner*/
-		apb_write_reg(QAM_BASE + 0x094, 0x7f80092d);
-		/* Maxlinear Tuner */
-		apb_write_reg(QAM_BASE + 0x0c0, 0x061f2f67);
-		/* by raymond 20121213, when adc=35M,sys=70M,
-		 * its better than 0x61f2f66*/
-		break;
-	default:		/*64qam */
-		/*apb_write_reg(QAM_BASE+0x054, 0x2256033a);
-		 * // EQ_FIR_CTL,*/
-		apb_write_reg(QAM_BASE + 0x054, 0x2336043a);
-		/* EQ_FIR_CTL, by raymond */
-		apb_write_reg(QAM_BASE + 0x068, 0x00c000c0);
-		/* EQ_CRTH_SNR */
-		/*apb_write_reg(QAM_BASE+0x074, 0x5000260);
-		 * // EQ_TH_LMS  40db  19db*/
-		apb_write_reg(QAM_BASE + 0x074, 0x5000230);
-		/* EQ_TH_LMS  40db      17.5db */
-		apb_write_reg(QAM_BASE + 0x07c, 0x007001bd);
-		/* EQ_TH_MMA */
-		apb_write_reg(QAM_BASE + 0x080, 0x000580ed);
-		/* EQ_TH_SMMA0 */
-		apb_write_reg(QAM_BASE + 0x084, 0x001771fb);
-		/* EQ_TH_SMMA1 */
-		apb_write_reg(QAM_BASE + 0x088, 0x00000000);
-		/* EQ_TH_SMMA2 */
-		apb_write_reg(QAM_BASE + 0x08c, 0x00000000);
-		/* EQ_TH_SMMA3 */
-		/*apb_write_reg(QAM_BASE+0x094, 0x7f800d2c);
-		 * // AGC_CTRL  ALPS tuner*/
-		/*apb_write_reg(QAM_BASE+0x094, 0x7f80292c);
-		 * // Pilips & maxlinear Tuner*/
-		apb_write_reg(QAM_BASE + 0x094, 0x7f802b3d);
-		/* Pilips Tuner & maxlinear Tuner */
-		/*apb_write_reg(QAM_BASE+0x094, 0x7f802b3a);
-		 * // Pilips Tuner & maxlinear Tuner*/
-		apb_write_reg(QAM_BASE + 0x0c0, 0x061f2f66);
-		/* by raymond 20121213 */
-		break;
-	}
-	return 0;
-}
-
-u32 dvbc_get_status(void)
-{
-/*      dprintk("c4 is %x\n",apb_read_reg(QAM_BASE+0xc4));*/
-	return apb_read_reg(QAM_BASE + 0xc4) & 0xf;
-}
-
-EXPORT_SYMBOL(dvbc_get_status);
-
-static u32 dvbc_get_ch_power(void)
-{
-	u32 tmp;
-	u32 ad_power;
-	u32 agc_gain;
-	u32 ch_power;
-
-	tmp = apb_read_reg(QAM_BASE + 0x09c);
-
-	ad_power = (tmp >> 22) & 0x1ff;
-	agc_gain = (tmp >> 0) & 0x7ff;
-
-	ad_power = ad_power >> 4;
-	/* ch_power = lookuptable(agc_gain) + ad_power; TODO */
-	ch_power = (ad_power & 0xffff) + ((agc_gain & 0xffff) << 16);
-
-	return ch_power;
-}
-
-static u32 dvbc_get_snr(void)
-{
-	u32 tmp, snr;
-
-	tmp = apb_read_reg(QAM_BASE + 0x14) & 0xfff;
-	snr = tmp * 100 / 32;	/* * 1e2 */
-
-	return snr;
-}
-
-static u32 dvbc_get_ber(void)
-{
-	u32 rs_ber;
-	u32 rs_packet_len;
-
-	rs_packet_len = apb_read_reg(QAM_BASE + 0x10) & 0xffff;
-	rs_ber = apb_read_reg(QAM_BASE + 0x14) >> 12 & 0xfffff;
-
-	/* rs_ber = rs_ber / 204.0 / 8.0 / rs_packet_len; */
-	if (rs_packet_len == 0)
-		rs_ber = 1000000;
-	else
-		rs_ber = rs_ber * 613 / rs_packet_len;	/* 1e-6 */
-
-	return rs_ber;
-}
-
-static u32 dvbc_get_per(void)
-{
-	u32 rs_per;
-	u32 rs_packet_len;
-	u32 acc_rs_per_times;
-
-	rs_packet_len = apb_read_reg(QAM_BASE + 0x10) & 0xffff;
-	rs_per = apb_read_reg(QAM_BASE + 0x18) >> 16 & 0xffff;
-
-	acc_rs_per_times = apb_read_reg(QAM_BASE + 0xcc) & 0xffff;
-	/*rs_per = rs_per / rs_packet_len; */
-
-	if (rs_packet_len == 0)
-		rs_per = 10000;
-	else
-		rs_per = 10000 * rs_per / rs_packet_len;	/* 1e-4 */
-
-	/*return rs_per; */
-	return acc_rs_per_times;
-}
-
-static u32 dvbc_get_symb_rate(void)
-{
-	u32 tmp;
-	u32 adc_freq;
-	u32 symb_rate;
-
-	adc_freq = apb_read_reg(QAM_BASE + 0x34) >> 16 & 0xffff;
-	tmp = apb_read_reg(QAM_BASE + 0xb8);
-
-	if ((tmp >> 15) == 0)
-		symb_rate = 0;
-	else
-		symb_rate = 10 * (adc_freq << 12) / (tmp >> 15);
-	/* 1e4 */
-
-	return symb_rate;
-}
-
-static int dvbc_get_freq_off(void)
-{
-	int tmp;
-	int symb_rate;
-	int freq_off;
-
-	symb_rate = dvbc_get_symb_rate();
-	tmp = apb_read_reg(QAM_BASE + 0xe0) & 0x3fffffff;
-	if (tmp >> 29 & 1)
-		tmp -= (1 << 30);
-
-	freq_off = ((tmp >> 16) * 25 * (symb_rate >> 10)) >> 3;
-
-	return freq_off;
-}
-
-static void dvbc_set_test_bus(u8 sel)
-{
-	u32 tmp;
-
-	tmp = apb_read_reg(QAM_BASE + 0x08);
-	tmp &= ~(0x1f << 4);
-	tmp |= ((sel & 0x1f) << 4) | (1 << 3);
-	apb_write_reg(QAM_BASE + 0x08, tmp);
-}
-
-void dvbc_get_test_out(u8 sel, u32 len, u32 *buf)
-{
-	int i, cnt;
-
-	dvbc_set_test_bus(sel);
-
-	for (i = 0, cnt = 0; i < len - 4 && cnt < 1000000; i++) {
-		buf[i] = apb_read_reg(QAM_BASE + 0xb0);
-		if (buf[i] >> 11 & 1) {
-			buf[i++] = apb_read_reg(QAM_BASE + 0xb0);
-			buf[i++] = apb_read_reg(QAM_BASE + 0xb0);
-			buf[i++] = apb_read_reg(QAM_BASE + 0xb0);
-			buf[i++] = apb_read_reg(QAM_BASE + 0xb0);
-		} else {
-			i--;
-		}
-
-		cnt++;
-	}
-}
-
-#if 0
-static void dvbc_sw_reset(int addr, int idx)
-{
-	u32 tmp;
-
-	tmp = apb_read_reg(QAM_BASE + addr);
-
-	tmp &= ~(1 << idx);
-	apb_write_reg(QAM_BASE + addr, tmp);
-
-	udelay(1);
-
-	tmp |= (1 << idx);
-	apb_write_reg(QAM_BASE + addr, tmp);
-}
-
-static void dvbc_reset(void)
-{
-	dvbc_sw_reset(0x04, 0);
-}
-
-static void dvbc_eq_reset(void)
-{
-	dvbc_sw_reset(0x50, 3);
-}
-
-static void dvbc_eq_smma_reset(void)
-{
-	dvbc_sw_reset(0xe8, 0);
-}
-#endif
-static void dvbc_reg_initial(struct aml_demod_sta *demod_sta)
-{
-	u32 clk_freq;
-	u32 adc_freq;
-	u8 tuner;
-	u8 ch_mode;
-	u8 agc_mode;
-	u32 ch_freq;
-	u16 ch_if;
-	u16 ch_bw;
-	u16 symb_rate;
-	u32 phs_cfg;
-	int afifo_ctr;
-	int max_frq_off, tmp;
-
-	clk_freq = demod_sta->clk_freq;	/* kHz */
-	adc_freq = demod_sta->adc_freq;	/* kHz */
-/*    adc_freq  = 25414;*/
-	tuner = demod_sta->tuner;
-	ch_mode = demod_sta->ch_mode;
-	agc_mode = demod_sta->agc_mode;
-	ch_freq = demod_sta->ch_freq;	/* kHz */
-	ch_if = demod_sta->ch_if;	/* kHz */
-	ch_bw = demod_sta->ch_bw;	/* kHz */
-	symb_rate = demod_sta->symb_rate;	/* k/sec */
-	dprintk("ch_if is %d,  %d,  %d,  %d, %d\n",
-		ch_if, ch_mode, ch_freq, ch_bw, symb_rate);
-/*    ch_mode=4;*/
-/*      apb_write_reg(DEMOD_CFG_BASE,0x00000007);*/
-	/* disable irq */
-	apb_write_reg(QAM_BASE + 0xd0, 0);
-
-	/* reset */
-	/*dvbc_reset(); */
-	apb_write_reg(QAM_BASE + 0x4, apb_read_reg(QAM_BASE + 0x4) & ~(1 << 4));
-	/* disable fsm_en */
-	apb_write_reg(QAM_BASE + 0x4, apb_read_reg(QAM_BASE + 0x4) & ~(1 << 0));
-	/* Sw disable demod */
-	apb_write_reg(QAM_BASE + 0x4, apb_read_reg(QAM_BASE + 0x4) | (1 << 0));
-	/* Sw enable demod */
-
-	apb_write_reg(QAM_BASE + 0x000, 0x00000000);
-	/* QAM_STATUS */
-	apb_write_reg(QAM_BASE + 0x004, 0x00000f00);
-	/* QAM_GCTL0 */
-	apb_write_reg(QAM_BASE + 0x008, (ch_mode & 7));
-	/* qam mode */
-
-	switch (ch_mode) {
-	case 0:		/* 16 QAM */
-		apb_write_reg(QAM_BASE + 0x054, 0x23460224);
-		/* EQ_FIR_CTL, */
-		apb_write_reg(QAM_BASE + 0x068, 0x00c000c0);
-		/* EQ_CRTH_SNR */
-		apb_write_reg(QAM_BASE + 0x074, 0x50001a0);
-		/* EQ_TH_LMS  40db  13db */
-		apb_write_reg(QAM_BASE + 0x07c, 0x003001e9);
-		/* EQ_NORM and EQ_TH_MMA */
-		/*apb_write_reg(QAM_BASE+0x080, 0x000be1ff);
-		 * // EQ_TH_SMMA0*/
-		apb_write_reg(QAM_BASE + 0x080, 0x000e01fe);
-		/* EQ_TH_SMMA0 */
-		apb_write_reg(QAM_BASE + 0x084, 0x00000000);
-		/* EQ_TH_SMMA1 */
-		apb_write_reg(QAM_BASE + 0x088, 0x00000000);
-		/* EQ_TH_SMMA2 */
-		apb_write_reg(QAM_BASE + 0x08c, 0x00000000);
-		/* EQ_TH_SMMA3 */
-		/*apb_write_reg(QAM_BASE+0x094, 0x7f800d2b);
-		 * // AGC_CTRL  ALPS tuner*/
-		/*apb_write_reg(QAM_BASE+0x094, 0x7f80292b);
-		 * // Pilips Tuner*/
-		/*apb_write_reg(QAM_BASE+0x094, 0x7f80292d);
-		 * // Pilips Tuner*/
-		apb_write_reg(QAM_BASE + 0x094, 0x7f80092d);
-		/* Pilips Tuner */
-		apb_write_reg(QAM_BASE + 0x0c0, 0x061f2f67);
-		/* by raymond 20121213 */
-		break;
-
-	case 1:		/* 32 QAM */
-		apb_write_reg(QAM_BASE + 0x054, 0x24560506);
-		/* EQ_FIR_CTL, */
-		apb_write_reg(QAM_BASE + 0x068, 0x00c000c0);
-		/* EQ_CRTH_SNR */
-		/*apb_write_reg(QAM_BASE+0x074, 0x5000260);
-		 * // EQ_TH_LMS  40db  19db*/
-		apb_write_reg(QAM_BASE + 0x074, 0x50001f0);
-		/* EQ_TH_LMS  40db  17.5db */
-		apb_write_reg(QAM_BASE + 0x07c, 0x00500102);
-		/* EQ_TH_MMA  0x000001cc */
-		apb_write_reg(QAM_BASE + 0x080, 0x00077140);
-		/* EQ_TH_SMMA0 */
-		apb_write_reg(QAM_BASE + 0x084, 0x001fb000);
-		/* EQ_TH_SMMA1 */
-		apb_write_reg(QAM_BASE + 0x088, 0x00000000);
-		/* EQ_TH_SMMA2 */
-		apb_write_reg(QAM_BASE + 0x08c, 0x00000000);
-		/* EQ_TH_SMMA3 */
-		/*apb_write_reg(QAM_BASE+0x094, 0x7f800d2b);
-		 * // AGC_CTRL  ALPS tuner*/
-		/*apb_write_reg(QAM_BASE+0x094, 0x7f80292b);
-		 * // Pilips Tuner*/
-		apb_write_reg(QAM_BASE + 0x094, 0x7f80092b);
-		/* Pilips Tuner */
-		apb_write_reg(QAM_BASE + 0x0c0, 0x061f2f67);
-		/* by raymond 20121213 */
-		break;
-
-	case 2:		/* 64 QAM */
-		/*apb_write_reg(QAM_BASE+0x054, 0x2256033a);
-		 * // EQ_FIR_CTL,*/
-		apb_write_reg(QAM_BASE + 0x054, 0x2336043a);
-		/* EQ_FIR_CTL, by raymond */
-		apb_write_reg(QAM_BASE + 0x068, 0x00c000c0);
-		/* EQ_CRTH_SNR */
-		/*apb_write_reg(QAM_BASE+0x074, 0x5000260);
-		 * // EQ_TH_LMS  40db  19db*/
-		apb_write_reg(QAM_BASE + 0x074, 0x5000230);
-		/* EQ_TH_LMS  40db  17.5db */
-		apb_write_reg(QAM_BASE + 0x07c, 0x007001bd);
-		/* EQ_TH_MMA */
-		apb_write_reg(QAM_BASE + 0x080, 0x000580ed);
-		/* EQ_TH_SMMA0 */
-		apb_write_reg(QAM_BASE + 0x084, 0x001771fb);
-		/* EQ_TH_SMMA1 */
-		apb_write_reg(QAM_BASE + 0x088, 0x00000000);
-		/* EQ_TH_SMMA2 */
-		apb_write_reg(QAM_BASE + 0x08c, 0x00000000);
-		/* EQ_TH_SMMA3 */
-		/*apb_write_reg(QAM_BASE+0x094, 0x7f800d2c);
-		 * // AGC_CTRL  ALPS tuner*/
-		/*apb_write_reg(QAM_BASE+0x094, 0x7f80292c);
-		 * // Pilips & maxlinear Tuner*/
-		apb_write_reg(QAM_BASE + 0x094, 0x7f802b3d);
-		/* Pilips Tuner & maxlinear Tuner */
-		/*apb_write_reg(QAM_BASE+0x094, 0x7f802b3a);
-		 * // Pilips Tuner & maxlinear Tuner*/
-		apb_write_reg(QAM_BASE + 0x0c0, 0x061f2f67);
-		/* by raymond 20121213 */
-		break;
-
-	case 3:		/* 128 QAM */
-		/*apb_write_reg(QAM_BASE+0x054, 0x2557046a);
-		 * // EQ_FIR_CTL,*/
-		apb_write_reg(QAM_BASE + 0x054, 0x2437067a);
-		/* EQ_FIR_CTL, by raymond 20121213 */
-		apb_write_reg(QAM_BASE + 0x068, 0x00c000d0);
-		/* EQ_CRTH_SNR */
-		/* apb_write_reg(QAM_BASE+0x074, 0x02440240);
-		 * // EQ_TH_LMS  18.5db  18db*/
-		/* apb_write_reg(QAM_BASE+0x074, 0x04000400);
-		 * // EQ_TH_LMS  22db  22.5db*/
-		apb_write_reg(QAM_BASE + 0x074, 0x5000260);
-		/* EQ_TH_LMS  40db  19db */
-		/*apb_write_reg(QAM_BASE+0x07c, 0x00b000f2);
-		 * // EQ_TH_MMA0x000000b2*/
-		apb_write_reg(QAM_BASE + 0x07c, 0x00b00132);
-		/* EQ_TH_MMA0x000000b2 by raymond 20121213 */
-		apb_write_reg(QAM_BASE + 0x080, 0x0003a09d);
-		/* EQ_TH_SMMA0 */
-		apb_write_reg(QAM_BASE + 0x084, 0x000f8150);
-		/* EQ_TH_SMMA1 */
-		apb_write_reg(QAM_BASE + 0x088, 0x001a51f8);
-		/* EQ_TH_SMMA2 */
-		apb_write_reg(QAM_BASE + 0x08c, 0x00000000);
-		/* EQ_TH_SMMA3 */
-		/*apb_write_reg(QAM_BASE+0x094, 0x7f800d2c);
-		 * // AGC_CTRL  ALPS tuner*/
-		/*apb_write_reg(QAM_BASE+0x094, 0x7f80292c);
-		 * // Pilips Tuner*/
-		apb_write_reg(QAM_BASE + 0x094, 0x7f80092c);
-		/* Pilips Tuner */
-		apb_write_reg(QAM_BASE + 0x0c0, 0x061f2f67);
-		/* by raymond 20121213 */
-		break;
-
-	case 4:		/* 256 QAM */
-		/*apb_write_reg(QAM_BASE+0x054, 0xa2580588);
-		 * // EQ_FIR_CTL,*/
-		apb_write_reg(QAM_BASE + 0x054, 0xa25905f9);
-		/* EQ_FIR_CTL, by raymond 20121213 */
-		apb_write_reg(QAM_BASE + 0x068, 0x01e00220);
-		/* EQ_CRTH_SNR */
-		/*apb_write_reg(QAM_BASE+0x074,  0x50002a0);
-		 * // EQ_TH_LMS  40db  19db*/
-		apb_write_reg(QAM_BASE + 0x074, 0x5000270);
-		/* EQ_TH_LMS  40db  19db by raymond 201211213 */
-		apb_write_reg(QAM_BASE + 0x07c, 0x00f001a5);
-		/* EQ_TH_MMA */
-		apb_write_reg(QAM_BASE + 0x080, 0x0002c077);
-		/* EQ_TH_SMMA0 */
-		apb_write_reg(QAM_BASE + 0x084, 0x000bc0fe);
-		/* EQ_TH_SMMA1 */
-		apb_write_reg(QAM_BASE + 0x088, 0x0013f17e);
-		/* EQ_TH_SMMA2 */
-		apb_write_reg(QAM_BASE + 0x08c, 0x01bc01f9);
-		/* EQ_TH_SMMA3 */
-		/*apb_write_reg(QAM_BASE+0x094, 0x7f800d2c);
-		 * // AGC_CTRL  ALPS tuner*/
-		/*apb_write_reg(QAM_BASE+0x094, 0x7f80292c);
-		 * // Pilips Tuner*/
-		/*apb_write_reg(QAM_BASE+0x094, 0x7f80292d);
-		 * // Maxlinear Tuner*/
-		apb_write_reg(QAM_BASE + 0x094, 0x7f80092d);
-		/* Maxlinear Tuner */
-		apb_write_reg(QAM_BASE + 0x0c0, 0x061f2f67);
-		/* by raymond 20121213, when adc=35M,sys=70M,
-		 * its better than 0x61f2f66*/
-		break;
-	default:		/*64qam */
-		/*apb_write_reg(QAM_BASE+0x054, 0x2256033a);
-		 * // EQ_FIR_CTL,*/
-		apb_write_reg(QAM_BASE + 0x054, 0x2336043a);
-		/* EQ_FIR_CTL, by raymond */
-		apb_write_reg(QAM_BASE + 0x068, 0x00c000c0);
-		/* EQ_CRTH_SNR */
-		/* EQ_TH_LMS  40db  19db */
-		apb_write_reg(QAM_BASE + 0x074, 0x5000230);
-		/* EQ_TH_LMS  40db  17.5db */
-		apb_write_reg(QAM_BASE + 0x07c, 0x007001bd);
-		/* EQ_TH_MMA */
-		apb_write_reg(QAM_BASE + 0x080, 0x000580ed);
-		/* EQ_TH_SMMA0 */
-		apb_write_reg(QAM_BASE + 0x084, 0x001771fb);
-		/* EQ_TH_SMMA1 */
-		apb_write_reg(QAM_BASE + 0x088, 0x00000000);
-		/* EQ_TH_SMMA2 */
-		apb_write_reg(QAM_BASE + 0x08c, 0x00000000);
-		/* EQ_TH_SMMA3 */
-		/*apb_write_reg(QAM_BASE+0x094, 0x7f800d2c);
-		 * // AGC_CTRL  ALPS tuner*/
-		/*apb_write_reg(QAM_BASE+0x094, 0x7f80292c);
-		 * // Pilips & maxlinear Tuner*/
-		apb_write_reg(QAM_BASE + 0x094, 0x7f802b3d);
-		/* Pilips Tuner & maxlinear Tuner */
-		/*apb_write_reg(QAM_BASE+0x094, 0x7f802b3a);
-		 * // Pilips Tuner & maxlinear Tuner*/
-		apb_write_reg(QAM_BASE + 0x0c0, 0x061f2f67);
-		/* by raymond 20121213 */
-		break;
-	}
-
-	/*apb_write_reg(QAM_BASE+0x00c, 0xfffffffe);
-	 * // adc_cnt, symb_cnt*/
-	apb_write_reg(QAM_BASE + 0x00c, 0xffff8ffe);
-	/* adc_cnt, symb_cnt    by raymond 20121213 */
-	if (clk_freq == 0)
-		afifo_ctr = 0;
-	else
-		afifo_ctr = (adc_freq * 256 / clk_freq) + 2;
-	if (afifo_ctr > 255)
-		afifo_ctr = 255;
-	apb_write_reg(QAM_BASE + 0x010, (afifo_ctr << 16) | 8000);
-	/* afifo, rs_cnt_cfg */
-
-	/*apb_write_reg(QAM_BASE+0x020, 0x21353e54);
-	 * // PHS_reset & TIM_CTRO_ACCURATE  sw_tim_select=0*/
-	/*apb_write_reg(QAM_BASE+0x020, 0x21b53e54);
-	 * //modified by qiancheng*/
-	apb_write_reg(QAM_BASE + 0x020, 0x61b53e54);
-	/*modified by qiancheng by raymond 20121208  0x63b53e54 for cci */
-	/*  apb_write_reg(QAM_BASE+0x020, 0x6192bfe2);
-	 * //modifed by ligg 20130613 auto symb_rate scan*/
-	if (adc_freq == 0)
-		phs_cfg = 0;
-	else
-		phs_cfg = (1 << 31) / adc_freq * ch_if / (1 << 8);
-	/*  8*fo/fs*2^20 fo=36.125, fs = 28.57114, = 21d775 */
-	/* dprintk("phs_cfg = %x\n", phs_cfg); */
-	apb_write_reg(QAM_BASE + 0x024, 0x4c000000 | (phs_cfg & 0x7fffff));
-	/* PHS_OFFSET, IF offset, */
-
-	if (adc_freq == 0) {
-		max_frq_off = 0;
-	} else {
-		max_frq_off = (1 << 29) / symb_rate;
-		/* max_frq_off = (400KHz * 2^29) /
-		   (AD=28571 * symbol_rate=6875) */
-		tmp = 40000000 / adc_freq;
-		max_frq_off = tmp * max_frq_off;
-	}
-	dprintk("max_frq_off is %x,\n", max_frq_off);
-	apb_write_reg(QAM_BASE + 0x02c, max_frq_off & 0x3fffffff);
-	/* max frequency offset, by raymond 20121208 */
-
-	/*apb_write_reg(QAM_BASE+0x030, 0x011bf400);
-	 * // TIM_CTL0 start speed is 0,  when know symbol rate*/
-	apb_write_reg(QAM_BASE + 0x030, 0x245cf451);
-	/*MODIFIED BY QIANCHENG */
-/*      apb_write_reg(QAM_BASE+0x030, 0x245bf451);
- * //modified by ligg 20130613 --auto symb_rate scan*/
-	apb_write_reg(QAM_BASE + 0x034,
-		      ((adc_freq & 0xffff) << 16) | (symb_rate & 0xffff));
-
-	apb_write_reg(QAM_BASE + 0x038, 0x00400000);
-	/* TIM_SWEEP_RANGE 16000 */
-
-/************* hw state machine config **********/
-	apb_write_reg(QAM_BASE + 0x040, 0x003c);
-/* configure symbol rate step step 0*/
-
-	/* modified 0x44 0x48 */
-	apb_write_reg(QAM_BASE + 0x044, (symb_rate & 0xffff) * 256);
-	/* blind search, configure max symbol_rate      for 7218  fb=3.6M */
-	/*apb_write_reg(QAM_BASE+0x048, 3600*256);
-	 * // configure min symbol_rate fb = 6.95M*/
-	apb_write_reg(QAM_BASE + 0x048, 3400 * 256);
-	/* configure min symbol_rate fb = 6.95M */
-
-	/*apb_write_reg(QAM_BASE+0x0c0, 0xffffff68); // threshold */
-	/*apb_write_reg(QAM_BASE+0x0c0, 0xffffff6f); // threshold */
-	/*apb_write_reg(QAM_BASE+0x0c0, 0xfffffd68); // threshold */
-	/*apb_write_reg(QAM_BASE+0x0c0, 0xffffff68); // threshold */
-	/*apb_write_reg(QAM_BASE+0x0c0, 0xffffff68); // threshold */
-	/*apb_write_reg(QAM_BASE+0x0c0, 0xffff2f67);
-	 * // threshold for skyworth*/
-	/* apb_write_reg(QAM_BASE+0x0c0, 0x061f2f67); // by raymond 20121208 */
-	/* apb_write_reg(QAM_BASE+0x0c0, 0x061f2f66);
-	 * // by raymond 20121213, remove it to every constellation*/
-/************* hw state machine config **********/
-
-	apb_write_reg(QAM_BASE + 0x04c, 0x00008800);	/* reserved */
-
-	/*apb_write_reg(QAM_BASE+0x050, 0x00000002);  // EQ_CTL0 */
-	apb_write_reg(QAM_BASE + 0x050, 0x01472002);
-	/* EQ_CTL0 by raymond 20121208 */
-
-	/*apb_write_reg(QAM_BASE+0x058, 0xff550e1e);  // EQ_FIR_INITPOS */
-	apb_write_reg(QAM_BASE + 0x058, 0xff100e1e);
-	/* EQ_FIR_INITPOS for skyworth */
-
-	apb_write_reg(QAM_BASE + 0x05c, 0x019a0000);	/* EQ_FIR_INITVAL0 */
-	apb_write_reg(QAM_BASE + 0x060, 0x019a0000);	/* EQ_FIR_INITVAL1 */
-
-	/*apb_write_reg(QAM_BASE+0x064, 0x01101128);  // EQ_CRTH_TIMES */
-	apb_write_reg(QAM_BASE + 0x064, 0x010a1128);
-	/* EQ_CRTH_TIMES for skyworth */
-	apb_write_reg(QAM_BASE + 0x06c, 0x00041a05);	/* EQ_CRTH_PPM */
-
-	apb_write_reg(QAM_BASE + 0x070, 0xffb9aa01);	/* EQ_CRLP */
-
-	/*apb_write_reg(QAM_BASE+0x090, 0x00020bd5); // agc control */
-	apb_write_reg(QAM_BASE + 0x090, 0x00000bd5);	/* agc control */
-
-	/* agc control */
-	/* apb_write_reg(QAM_BASE+0x094, 0x7f800d2c);// AGC_CTRL  ALPS tuner */
-	/* apb_write_reg(QAM_BASE+0x094, 0x7f80292c);     // Pilips Tuner */
-	if ((agc_mode & 1) == 0)
-		/* freeze if agc */
-		apb_write_reg(QAM_BASE + 0x094,
-			      apb_read_reg(QAM_BASE + 0x94) | (0x1 << 10));
-	if ((agc_mode & 2) == 0) {
-		/* IF control */
-		/*freeze rf agc */
-		apb_write_reg(QAM_BASE + 0x094,
-			      apb_read_reg(QAM_BASE + 0x94) | (0x1 << 13));
-	}
-	/*Maxlinear Tuner */
-	/*apb_write_reg(QAM_BASE+0x094, 0x7f80292d); */
-	apb_write_reg(QAM_BASE + 0x098, 0x9fcc8190);
-	/* AGC_IFGAIN_CTRL */
-	/*apb_write_reg(QAM_BASE+0x0a0, 0x0e028c00);
-	 * // AGC_RFGAIN_CTRL 0x0e020800*/
-	/*apb_write_reg(QAM_BASE+0x0a0, 0x0e03cc00);
-	 * // AGC_RFGAIN_CTRL 0x0e020800*/
-	/*apb_write_reg(QAM_BASE+0x0a0, 0x0e028700);
-	 * // AGC_RFGAIN_CTRL 0x0e020800 now*/
-	/*apb_write_reg(QAM_BASE+0x0a0, 0x0e03cd00);
-	 * // AGC_RFGAIN_CTRL 0x0e020800*/
-	/*apb_write_reg(QAM_BASE+0x0a0, 0x0603cd11);
-	 * // AGC_RFGAIN_CTRL 0x0e020800 by raymond,
-	 * if Adjcent channel test, maybe it need change.20121208 ad invert*/
-	apb_write_reg(QAM_BASE + 0x0a0, 0x0603cd10);
-	/* AGC_RFGAIN_CTRL 0x0e020800 by raymond,
-	 * if Adjcent channel test, maybe it need change.
-	 * 20121208 ad invert,20130221, suit for two path channel.*/
-
-	apb_write_reg(QAM_BASE + 0x004, apb_read_reg(QAM_BASE + 0x004) | 0x33);
-	/* IMQ, QAM Enable */
-
-	/* start hardware machine */
-	/*dvbc_sw_reset(0x004, 4); */
-	apb_write_reg(QAM_BASE + 0x4, apb_read_reg(QAM_BASE + 0x4) | (1 << 4));
-	apb_write_reg(QAM_BASE + 0x0e8,
-		      (apb_read_reg(QAM_BASE + 0x0e8) | (1 << 2)));
-
-	/* clear irq status */
-	apb_read_reg(QAM_BASE + 0xd4);
-
-	/* enable irq */
-	apb_write_reg(QAM_BASE + 0xd0, 0x7fff << 3);
-
-/*auto track*/
-	/*      dvbc_set_auto_symtrack(); */
-}
-
-u32 dvbc_set_auto_symtrack(void)
-{
-	apb_write_reg(QAM_BASE + 0x030, 0x245bf45c);	/*open track */
-	apb_write_reg(QAM_BASE + 0x020, 0x61b2bf5c);
-	apb_write_reg(QAM_BASE + 0x044, (7000 & 0xffff) * 256);
-	apb_write_reg(QAM_BASE + 0x038, 0x00220000);
-	apb_write_reg(QAM_BASE + 0x4, apb_read_reg(QAM_BASE + 0x4) & ~(1 << 0));
-	/* Sw disable demod */
-	apb_write_reg(QAM_BASE + 0x4, apb_read_reg(QAM_BASE + 0x4) | (1 << 0));
-	/* Sw enable demod */
-	return 0;
-}
-
-int dvbc_set_ch(struct aml_demod_sta *demod_sta,
-		struct aml_demod_i2c *demod_i2c,
-		struct aml_demod_dvbc *demod_dvbc)
-{
-	int ret = 0;
-	u16 symb_rate;
-	u8 mode;
-	u32 ch_freq;
-	dprintk("f=%d, s=%d, q=%d\n",
-		demod_dvbc->ch_freq, demod_dvbc->symb_rate, demod_dvbc->mode);
-	demod_i2c->tuner = 7;
-	mode = demod_dvbc->mode;
-	symb_rate = demod_dvbc->symb_rate;
-	ch_freq = demod_dvbc->ch_freq;
-	if (mode > 4) {
-		dprintk("Error: Invalid QAM mode option %d\n", mode);
-		mode = 2;
-		ret = -1;
-	}
-
-	if (symb_rate < 1000 || symb_rate > 7000) {
-		dprintk("Error: Invalid Symbol Rate option %d\n", symb_rate);
-		symb_rate = 6875;
-		ret = -1;
-	}
-
-	if (ch_freq < 1000 || ch_freq > 900000) {
-		dprintk("Error: Invalid Channel Freq option %d\n", ch_freq);
-		ch_freq = 474000;
-		ret = -1;
-	}
-	/* if (ret != 0) return ret; */
-	demod_sta->dvb_mode = 0;
-	demod_sta->ch_mode = mode;
-	/* 0:16, 1:32, 2:64, 3:128, 4:256 */
-	demod_sta->agc_mode = 1;
-	/* 0:NULL, 1:IF, 2:RF, 3:both */
-	demod_sta->ch_freq = ch_freq;
-	demod_sta->tuner = demod_i2c->tuner;
-
-	if (demod_i2c->tuner == 1)
-		demod_sta->ch_if = 36130;	/* TODO  DCT tuner */
-	else if (demod_i2c->tuner == 2)
-		demod_sta->ch_if = 4570;	/* TODO  Maxlinear tuner */
-	else if (demod_i2c->tuner == 7)
-		/*   demod_sta->ch_if     = 5000; // TODO  Si2176 tuner */
-
-	demod_sta->ch_bw = 8000;	/* TODO */
-	if (demod_sta->ch_if == 0)
-		demod_sta->ch_if = 5000;
-	demod_sta->symb_rate = symb_rate;
-	dvbc_reg_initial(demod_sta);
-
-	return ret;
-}
-
-int dvbc_status(struct aml_demod_sta *demod_sta,
-		struct aml_demod_i2c *demod_i2c,
-		struct aml_demod_sts *demod_sts)
-{
-	struct aml_fe_dev *dev;
-
-/* int ftmp, tmp; */
-	dev = NULL;
-	demod_sts->ch_sts = apb_read_reg(QAM_BASE + 0x18);
-	demod_sts->ch_pow = dvbc_get_ch_power();
-	demod_sts->ch_snr = dvbc_get_snr();
-	demod_sts->ch_ber = dvbc_get_ber();
-	demod_sts->ch_per = dvbc_get_per();
-	demod_sts->symb_rate = dvbc_get_symb_rate();
-	demod_sts->freq_off = dvbc_get_freq_off();
-	/*demod_sts->dat0 = apb_read_reg(QAM_BASE+0x28); */
-/*    demod_sts->dat0 = tuner_get_ch_power(demod_i2c);*/
-	demod_sts->dat1 = tuner_get_ch_power(dev);
-#if 0
-
-	ftmp = demod_sts->ch_sts;
-	dprintk("[dvbc debug] ch_sts is %x\n", ftmp);
-	ftmp = demod_sts->ch_snr;
-	ftmp /= 100;
-	dprintk("snr %d dB ", ftmp);
-	ftmp = demod_sts->ch_ber;
-	dprintk("ber %.d ", ftmp);
-	tmp = demod_sts->ch_per;
-	dprintk("per %d ", tmp);
-	ftmp = demod_sts->symb_rate;
-	dprintk("srate %.d ", ftmp);
-	ftmp = demod_sts->freq_off;
-	dprintk("freqoff %.d kHz ", ftmp);
-	tmp = demod_sts->dat1;
-	dprintk("strength %ddb  0xe0 status is %lu ,b4 status is %lu", tmp,
-		(apb_read_reg(QAM_BASE + 0xe0) & 0xffff),
-		(apb_read_reg(QAM_BASE + 0xb4) & 0xffff));
-	dprintk("dagc_gain is %lu ", apb_read_reg(QAM_BASE + 0xa4) & 0x7f);
-	tmp = demod_sts->ch_pow;
-	dprintk("power is %ddb\n", (tmp & 0xffff));
-
-#endif
-
-	return 0;
-}
-
-void dvbc_enable_irq(int dvbc_irq)
-{
-	u32 mask;
-
-	/* clear status */
-	apb_read_reg(QAM_BASE + 0xd4);
-	/* enable irq */
-	mask = apb_read_reg(QAM_BASE + 0xd0);
-	mask |= (1 << dvbc_irq);
-	apb_write_reg(QAM_BASE + 0xd0, mask);
-}
-
-void dvbc_disable_irq(int dvbc_irq)
-{
-	u32 mask;
-
-	/* disable irq */
-	mask = apb_read_reg(QAM_BASE + 0xd0);
-	mask &= ~(1 << dvbc_irq);
-	apb_write_reg(QAM_BASE + 0xd0, mask);
-	/* clear status */
-	apb_read_reg(QAM_BASE + 0xd4);
-}
-
-char *dvbc_irq_name[] = {
-	"      ADC",
-	"   Symbol",
-	"       RS",
-	" In_Sync0",
-	" In_Sync1",
-	" In_Sync2",
-	" In_Sync3",
-	" In_Sync4",
-	"Out_Sync0",
-	"Out_Sync1",
-	"Out_Sync2",
-	"Out_Sync3",
-	"Out_Sync4",
-	"In_SyncCo",
-	"OutSyncCo",
-	"  In_Dagc",
-	" Out_Dagc",
-	"  Eq_Mode",
-	"RS_Uncorr"
-};
-
-void dvbc_isr(struct aml_demod_sta *demod_sta)
-{
-	u32 stat, mask;
-	int dvbc_irq;
-
-	stat = apb_read_reg(QAM_BASE + 0xd4);
-	mask = apb_read_reg(QAM_BASE + 0xd0);
-	stat &= mask;
-
-	for (dvbc_irq = 0; dvbc_irq < 20; dvbc_irq++) {
-		if (stat >> dvbc_irq & 1) {
-			if (demod_sta->debug)
-				dprintk("irq: dvbc %2d %s %8x\n",
-					dvbc_irq, dvbc_irq_name[dvbc_irq],
-					stat);
-			/* dvbc_disable_irq(dvbc_irq); */
-		}
-	}
-}
-
-int dvbc_isr_islock(void)
-{
-#define IN_SYNC4_MASK (0x80)
-
-	u32 stat, mask;
-
-	stat = apb_read_reg(QAM_BASE + 0xd4);
-	apb_write_reg(QAM_BASE + 0xd4, 0);
-	mask = apb_read_reg(QAM_BASE + 0xd0);
-	stat &= mask;
-
-	return (stat & IN_SYNC4_MASK) == IN_SYNC4_MASK;
-}
diff --git a/drivers/amlogic/dvb_tv/amldemod/dvbt_func.c b/drivers/amlogic/dvb_tv/amldemod/dvbt_func.c
deleted file mode 100644
index b40752091dfd..000000000000
--- a/drivers/amlogic/dvb_tv/amldemod/dvbt_func.c
+++ /dev/null
@@ -1,2160 +0,0 @@
-#include <linux/kernel.h>
-#include <linux/i2c.h>
-#include <linux/delay.h>
-#include <linux/dvb/aml_demod.h>
-#include "demod_func.h"
-
-static int debug_amldvbt;
-
-module_param(debug_amldvbt, int, 0644);
-MODULE_PARM_DESC(debug_amldvbt, "turn on debugging (default: 0)");
-#define dprintk(args ...) do { if (debug_amldvbt) printk(args); } while (0)
-
-static int tuner_type = 3;
-
-static void set_ACF_coef(int ADsample, int bandwidth)
-{
-	if (ADsample == 45) {
-		/* Set ACF and IIREQ */
-		if (bandwidth == 0) {
-			/*8M Hz */
-			apb_write_reg(2, 0x2c, 0x255);  /* ACF_STAGE1_A1 */
-			apb_write_reg(2, 0x2d, 0x0B5);  /* ACF_STAGE1_A2 */
-			apb_write_reg(2, 0x2e, 0x091);  /* ACF_STAGE1_B1 */
-			apb_write_reg(2, 0x2f, 0x02E);  /* ACF_STAGE1_GAIN */
-			apb_write_reg(2, 0x30, 0x253);  /* ACF_STAGE2_A1 */
-			apb_write_reg(2, 0x31, 0x0CB);  /* ACF_STAGE2_A2 */
-			apb_write_reg(2, 0x32, 0x2CD);  /* ACF_STAGE2_B1 */
-			apb_write_reg(2, 0x33, 0x07C);  /* ACF_STAGE2_GAIN */
-			apb_write_reg(2, 0x34, 0x250);  /* ACF_STAGE3_A1 */
-			apb_write_reg(2, 0x35, 0x0E4);  /* ACF_STAGE3_A2 */
-			apb_write_reg(2, 0x36, 0x276);  /* ACF_STAGE3_B1 */
-			apb_write_reg(2, 0x37, 0x05D);  /* ACF_STAGE3_GAIN */
-			apb_write_reg(2, 0x38, 0x24D);  /* ACF_STAGE4_A1 */
-			apb_write_reg(2, 0x39, 0x0F3);  /* ACF_STAGE4_A2 */
-			apb_write_reg(2, 0x3a, 0x25E);  /* ACF_STAGE4_B1 */
-			apb_write_reg(2, 0x3b, 0x05A);  /* ACF_STAGE4_GAIN */
-			apb_write_reg(2, 0x3c, 0x24A);  /* ACF_STAGE5_A1 */
-			apb_write_reg(2, 0x3d, 0x0FD);  /* ACF_STAGE5_A2 */
-			apb_write_reg(2, 0x3e, 0x256);  /* ACF_STAGE5_B1 */
-			apb_write_reg(2, 0x3f, 0x04B);  /* ACF_STAGE5_GAIN */
-
-			apb_write_reg(2, 0xfe, 0x000);
-			apb_write_reg(2, 0xff, 0x003effff);
-			apb_write_reg(2, 0xfe, 0x001);
-			apb_write_reg(2, 0xff, 0x003cefbe);
-			apb_write_reg(2, 0xfe, 0x002);
-			apb_write_reg(2, 0xff, 0x003adf7c);
-			apb_write_reg(2, 0xfe, 0x003);
-			apb_write_reg(2, 0xff, 0x0038bf39);
-			apb_write_reg(2, 0xfe, 0x004);
-			apb_write_reg(2, 0xff, 0x003696f5);
-			apb_write_reg(2, 0xfe, 0x005);
-			apb_write_reg(2, 0xff, 0x003466b0);
-			apb_write_reg(2, 0xfe, 0x006);
-			apb_write_reg(2, 0xff, 0x00322e69);
-			apb_write_reg(2, 0xfe, 0x007);
-			apb_write_reg(2, 0xff, 0x002fee21);
-			apb_write_reg(2, 0xfe, 0x008);
-			apb_write_reg(2, 0xff, 0x002dadd9);
-			apb_write_reg(2, 0xfe, 0x009);
-			apb_write_reg(2, 0xff, 0x002b6d91);
-			apb_write_reg(2, 0xfe, 0x00a);
-			apb_write_reg(2, 0xff, 0x00291d48);
-			apb_write_reg(2, 0xfe, 0x00b);
-			apb_write_reg(2, 0xff, 0x0026ccfe);
-			apb_write_reg(2, 0xfe, 0x00c);
-			apb_write_reg(2, 0xff, 0x00245cb2);
-			apb_write_reg(2, 0xfe, 0x00d);
-			apb_write_reg(2, 0xff, 0x0021d463);
-			apb_write_reg(2, 0xfe, 0x00e);
-			apb_write_reg(2, 0xff, 0x001f2410);
-			apb_write_reg(2, 0xfe, 0x00f);
-			apb_write_reg(2, 0xff, 0x001c3bb6);
-			apb_write_reg(2, 0xfe, 0x010);
-			apb_write_reg(2, 0xff, 0x00192b57);
-			apb_write_reg(2, 0xfe, 0x011);
-			apb_write_reg(2, 0xff, 0x0015e2f1);
-			apb_write_reg(2, 0xfe, 0x012);
-			apb_write_reg(2, 0xff, 0x00127285);
-			apb_write_reg(2, 0xfe, 0x013);
-			apb_write_reg(2, 0xff, 0x000eca14);
-			apb_write_reg(2, 0xfe, 0x014);
-			apb_write_reg(2, 0xff, 0x000ac99b);
-			apb_write_reg(2, 0xfe, 0x015);
-			apb_write_reg(2, 0xff, 0x00063913);
-			apb_write_reg(2, 0xfe, 0x016);
-			apb_write_reg(2, 0xff, 0x0000c073);
-			apb_write_reg(2, 0xfe, 0x017);
-			apb_write_reg(2, 0xff, 0x003a3fb4);
-			apb_write_reg(2, 0xfe, 0x018);
-			apb_write_reg(2, 0xff, 0x00347ecf);
-			apb_write_reg(2, 0xfe, 0x019);
-			apb_write_reg(2, 0xff, 0x002ff649);
-			apb_write_reg(2, 0xfe, 0x01a);
-			apb_write_reg(2, 0xff, 0x002a8dab);
-			apb_write_reg(2, 0xfe, 0x01b);
-			apb_write_reg(2, 0xff, 0x002444f0);
-			apb_write_reg(2, 0xfe, 0x01c);
-			apb_write_reg(2, 0xff, 0x001d0c1b);
-			apb_write_reg(2, 0xfe, 0x01d);
-			apb_write_reg(2, 0xff, 0x000fc300);
-			apb_write_reg(2, 0xfe, 0x01e);
-			apb_write_reg(2, 0xff, 0x000118ce);
-			apb_write_reg(2, 0xfe, 0x01f);
-			apb_write_reg(2, 0xff, 0x003c17c3);
-			apb_write_reg(2, 0xfe, 0x020);
-			apb_write_reg(2, 0xff, 0x00000751);
-		} else if (bandwidth == 1) {
-			/* 7Mhz */
-			apb_write_reg(2, 0x2c, 0x24B);  /* ACF_STAGE1_A1 */
-			apb_write_reg(2, 0x2d, 0x0BD);  /* ACF_STAGE1_A2 */
-			apb_write_reg(2, 0x2e, 0x04B);  /* ACF_STAGE1_B1 */
-			apb_write_reg(2, 0x2f, 0x03E);  /* ACF_STAGE1_GAIN */
-			apb_write_reg(2, 0x30, 0x246);  /* ACF_STAGE2_A1 */
-			apb_write_reg(2, 0x31, 0x0D1);  /* ACF_STAGE2_A2 */
-			apb_write_reg(2, 0x32, 0x2A2);  /* ACF_STAGE2_B1 */
-			apb_write_reg(2, 0x33, 0x07C);  /* ACF_STAGE2_GAIN */
-			apb_write_reg(2, 0x34, 0x241);  /* ACF_STAGE3_A1 */
-			apb_write_reg(2, 0x35, 0x0E7);  /* ACF_STAGE3_A2 */
-			apb_write_reg(2, 0x36, 0x25B);  /* ACF_STAGE3_B1 */
-			apb_write_reg(2, 0x37, 0x05D);  /* ACF_STAGE3_GAIN */
-			apb_write_reg(2, 0x38, 0x23D);  /* ACF_STAGE4_A1 */
-			apb_write_reg(2, 0x39, 0x0F5);  /* ACF_STAGE4_A2 */
-			apb_write_reg(2, 0x3a, 0x248);  /* ACF_STAGE4_B1 */
-			apb_write_reg(2, 0x3b, 0x05A);  /* ACF_STAGE4_GAIN */
-			apb_write_reg(2, 0x3c, 0x23A);  /* ACF_STAGE5_A1 */
-			apb_write_reg(2, 0x3d, 0x0FD);  /* ACF_STAGE5_A2 */
-			apb_write_reg(2, 0x3e, 0x242);  /* ACF_STAGE5_B1 */
-			apb_write_reg(2, 0x3f, 0x04B);  /* ACF_STAGE5_GAIN */
-			apb_write_reg(2, 0xfe, 0x000);
-			apb_write_reg(2, 0xff, 0x003f07ff);
-			apb_write_reg(2, 0xfe, 0x001);
-			apb_write_reg(2, 0xff, 0x003cffbf);
-			apb_write_reg(2, 0xfe, 0x002);
-			apb_write_reg(2, 0xff, 0x003aef7e);
-			apb_write_reg(2, 0xfe, 0x003);
-			apb_write_reg(2, 0xff, 0x0038d73c);
-			apb_write_reg(2, 0xfe, 0x004);
-			apb_write_reg(2, 0xff, 0x0036b6f9);
-			apb_write_reg(2, 0xfe, 0x005);
-			apb_write_reg(2, 0xff, 0x003486b3);
-			apb_write_reg(2, 0xfe, 0x006);
-			apb_write_reg(2, 0xff, 0x00324e6d);
-			apb_write_reg(2, 0xfe, 0x007);
-			apb_write_reg(2, 0xff, 0x00300e25);
-			apb_write_reg(2, 0xfe, 0x008);
-			apb_write_reg(2, 0xff, 0x002dcddd);
-			apb_write_reg(2, 0xfe, 0x009);
-			apb_write_reg(2, 0xff, 0x002b8594);
-			apb_write_reg(2, 0xfe, 0x00a);
-			apb_write_reg(2, 0xff, 0x00292d4b);
-			apb_write_reg(2, 0xfe, 0x00b);
-			apb_write_reg(2, 0xff, 0x0026d500);
-			apb_write_reg(2, 0xfe, 0x00c);
-			apb_write_reg(2, 0xff, 0x00245cb3);
-			apb_write_reg(2, 0xfe, 0x00d);
-			apb_write_reg(2, 0xff, 0x0021cc62);
-			apb_write_reg(2, 0xfe, 0x00e);
-			apb_write_reg(2, 0xff, 0x001f0c0d);
-			apb_write_reg(2, 0xfe, 0x00f);
-			apb_write_reg(2, 0xff, 0x001c1bb3);
-			apb_write_reg(2, 0xfe, 0x010);
-			apb_write_reg(2, 0xff, 0x0018fb52);
-			apb_write_reg(2, 0xfe, 0x011);
-			apb_write_reg(2, 0xff, 0x0015b2eb);
-			apb_write_reg(2, 0xfe, 0x012);
-			apb_write_reg(2, 0xff, 0x00123a7f);
-			apb_write_reg(2, 0xfe, 0x013);
-			apb_write_reg(2, 0xff, 0x000e9a0e);
-			apb_write_reg(2, 0xfe, 0x014);
-			apb_write_reg(2, 0xff, 0x000a9995);
-			apb_write_reg(2, 0xfe, 0x015);
-			apb_write_reg(2, 0xff, 0x0006090d);
-			apb_write_reg(2, 0xfe, 0x016);
-			apb_write_reg(2, 0xff, 0x0000a06e);
-			apb_write_reg(2, 0xfe, 0x017);
-			apb_write_reg(2, 0xff, 0x003a57b3);
-			apb_write_reg(2, 0xfe, 0x018);
-			apb_write_reg(2, 0xff, 0x0034ded8);
-			apb_write_reg(2, 0xfe, 0x019);
-			apb_write_reg(2, 0xff, 0x00309659);
-			apb_write_reg(2, 0xfe, 0x01a);
-			apb_write_reg(2, 0xff, 0x002b75c4);
-			apb_write_reg(2, 0xfe, 0x01b);
-			apb_write_reg(2, 0xff, 0x0025350e);
-			apb_write_reg(2, 0xfe, 0x01c);
-			apb_write_reg(2, 0xff, 0x001dec37);
-			apb_write_reg(2, 0xfe, 0x01d);
-			apb_write_reg(2, 0xff, 0x00126b28);
-			apb_write_reg(2, 0xfe, 0x01e);
-			apb_write_reg(2, 0xff, 0x00031130);
-			apb_write_reg(2, 0xfe, 0x01f);
-			apb_write_reg(2, 0xff, 0x003cffec);
-			apb_write_reg(2, 0xfe, 0x020);
-			apb_write_reg(2, 0xff, 0x00000767);
-		} else if (bandwidth == 2) {
-			/* 6MHz */
-			apb_write_reg(2, 0x2c, 0x240);  /* ACF_STAGE1_A1 */
-			apb_write_reg(2, 0x2d, 0x0C6);  /* ACF_STAGE1_A2 */
-			apb_write_reg(2, 0x2e, 0x3F9);  /* ACF_STAGE1_B1 */
-			apb_write_reg(2, 0x2f, 0x03E);  /* ACF_STAGE1_GAIN */
-			apb_write_reg(2, 0x30, 0x23A);  /* ACF_STAGE2_A1 */
-			apb_write_reg(2, 0x31, 0x0D7);  /* ACF_STAGE2_A2 */
-			apb_write_reg(2, 0x32, 0x27B);  /* ACF_STAGE2_B1 */
-			apb_write_reg(2, 0x33, 0x07C);  /* ACF_STAGE2_GAIN */
-			apb_write_reg(2, 0x34, 0x233);  /* ACF_STAGE3_A1 */
-			apb_write_reg(2, 0x35, 0x0EA);  /* ACF_STAGE3_A2 */
-			apb_write_reg(2, 0x36, 0x244);  /* ACF_STAGE3_B1 */
-			apb_write_reg(2, 0x37, 0x05D);  /* ACF_STAGE3_GAIN */
-			apb_write_reg(2, 0x38, 0x22F);  /* ACF_STAGE4_A1 */
-			apb_write_reg(2, 0x39, 0x0F6);  /* ACF_STAGE4_A2 */
-			apb_write_reg(2, 0x3a, 0x235);  /* ACF_STAGE4_B1 */
-			apb_write_reg(2, 0x3b, 0x05A);  /* ACF_STAGE4_GAIN */
-			apb_write_reg(2, 0x3c, 0x22B);  /* ACF_STAGE5_A1 */
-			apb_write_reg(2, 0x3d, 0x0FD);  /* ACF_STAGE5_A2 */
-			apb_write_reg(2, 0x3e, 0x231);  /* ACF_STAGE5_B1 */
-			apb_write_reg(2, 0x3f, 0x04B);  /* ACF_STAGE5_GAIN */
-			apb_write_reg(2, 0xfe, 0x000);
-			apb_write_reg(2, 0xff, 0x003f07ff);
-			apb_write_reg(2, 0xfe, 0x001);
-			apb_write_reg(2, 0xff, 0x003cffbf);
-			apb_write_reg(2, 0xfe, 0x002);
-			apb_write_reg(2, 0xff, 0x003aef7e);
-			apb_write_reg(2, 0xfe, 0x003);
-			apb_write_reg(2, 0xff, 0x0038d73c);
-			apb_write_reg(2, 0xfe, 0x004);
-			apb_write_reg(2, 0xff, 0x0036b6f8);
-			apb_write_reg(2, 0xfe, 0x005);
-			apb_write_reg(2, 0xff, 0x003486b3);
-			apb_write_reg(2, 0xfe, 0x006);
-			apb_write_reg(2, 0xff, 0x0032466c);
-			apb_write_reg(2, 0xfe, 0x007);
-			apb_write_reg(2, 0xff, 0x002ffe24);
-			apb_write_reg(2, 0xfe, 0x008);
-			apb_write_reg(2, 0xff, 0x002dadda);
-			apb_write_reg(2, 0xfe, 0x009);
-			apb_write_reg(2, 0xff, 0x002b5d90);
-			apb_write_reg(2, 0xfe, 0x00a);
-			apb_write_reg(2, 0xff, 0x0028fd45);
-			apb_write_reg(2, 0xfe, 0x00b);
-			apb_write_reg(2, 0xff, 0x002694f9);
-			apb_write_reg(2, 0xfe, 0x00c);
-			apb_write_reg(2, 0xff, 0x002414ab);
-			apb_write_reg(2, 0xfe, 0x00d);
-			apb_write_reg(2, 0xff, 0x00217458);
-			apb_write_reg(2, 0xfe, 0x00e);
-			apb_write_reg(2, 0xff, 0x001ea402);
-			apb_write_reg(2, 0xfe, 0x00f);
-			apb_write_reg(2, 0xff, 0x001ba3a5);
-			apb_write_reg(2, 0xfe, 0x010);
-			apb_write_reg(2, 0xff, 0x00187342);
-			apb_write_reg(2, 0xfe, 0x011);
-			apb_write_reg(2, 0xff, 0x00151ad9);
-			apb_write_reg(2, 0xfe, 0x012);
-			apb_write_reg(2, 0xff, 0x0011926b);
-			apb_write_reg(2, 0xfe, 0x013);
-			apb_write_reg(2, 0xff, 0x000dc9f6);
-			apb_write_reg(2, 0xfe, 0x014);
-			apb_write_reg(2, 0xff, 0x0009a178);
-			apb_write_reg(2, 0xfe, 0x015);
-			apb_write_reg(2, 0xff, 0x0004d8eb);
-			apb_write_reg(2, 0xfe, 0x016);
-			apb_write_reg(2, 0xff, 0x003f4045);
-			apb_write_reg(2, 0xfe, 0x017);
-			apb_write_reg(2, 0xff, 0x0038e785);
-			apb_write_reg(2, 0xfe, 0x018);
-			apb_write_reg(2, 0xff, 0x00337eab);
-			apb_write_reg(2, 0xfe, 0x019);
-			apb_write_reg(2, 0xff, 0x002f3e2d);
-			apb_write_reg(2, 0xfe, 0x01a);
-			apb_write_reg(2, 0xff, 0x002a1599);
-			apb_write_reg(2, 0xfe, 0x01b);
-			apb_write_reg(2, 0xff, 0x0023ace1);
-			apb_write_reg(2, 0xfe, 0x01c);
-			apb_write_reg(2, 0xff, 0x001b33fb);
-			apb_write_reg(2, 0xfe, 0x01d);
-			apb_write_reg(2, 0xff, 0x000cd29c);
-			apb_write_reg(2, 0xfe, 0x01e);
-			apb_write_reg(2, 0xff, 0x0001c0c1);
-			apb_write_reg(2, 0xfe, 0x01f);
-			apb_write_reg(2, 0xff, 0x003cefde);
-			apb_write_reg(2, 0xfe, 0x020);
-			apb_write_reg(2, 0xff, 0x0000076a);
-		} else {
-			/* 5MHz */
-			apb_write_reg(2, 0x2c, 0x236);  /* ACF_STAGE1_A1 */
-			apb_write_reg(2, 0x2d, 0x0CE);  /* ACF_STAGE1_A2 */
-			apb_write_reg(2, 0x2e, 0x39A);  /* ACF_STAGE1_B1 */
-			apb_write_reg(2, 0x2f, 0x03E);  /* ACF_STAGE1_GAIN */
-			apb_write_reg(2, 0x30, 0x22F);  /* ACF_STAGE2_A1 */
-			apb_write_reg(2, 0x31, 0x0DE);  /* ACF_STAGE2_A2 */
-			apb_write_reg(2, 0x32, 0x257);  /* ACF_STAGE2_B1 */
-			apb_write_reg(2, 0x33, 0x07C);  /* ACF_STAGE2_GAIN */
-			apb_write_reg(2, 0x34, 0x227);  /* ACF_STAGE3_A1 */
-			apb_write_reg(2, 0x35, 0x0EE);  /* ACF_STAGE3_A2 */
-			apb_write_reg(2, 0x36, 0x230);  /* ACF_STAGE3_B1 */
-			apb_write_reg(2, 0x37, 0x05D);  /* ACF_STAGE3_GAIN */
-			apb_write_reg(2, 0x38, 0x222);  /* ACF_STAGE4_A1 */
-			apb_write_reg(2, 0x39, 0x0F8);  /* ACF_STAGE4_A2 */
-			apb_write_reg(2, 0x3a, 0x225);  /* ACF_STAGE4_B1 */
-			apb_write_reg(2, 0x3b, 0x05A);  /* ACF_STAGE4_GAIN */
-			apb_write_reg(2, 0x3c, 0x21E);  /* ACF_STAGE5_A1 */
-			apb_write_reg(2, 0x3d, 0x0FE);  /* ACF_STAGE5_A2 */
-			apb_write_reg(2, 0x3e, 0x222);  /* ACF_STAGE5_B1 */
-			apb_write_reg(2, 0x3f, 0x04B);  /* ACF_STAGE5_GAIN */
-			apb_write_reg(2, 0xfe, 0x000);
-			apb_write_reg(2, 0xff, 0x003effff);
-			apb_write_reg(2, 0xfe, 0x001);
-			apb_write_reg(2, 0xff, 0x003ce7bd);
-			apb_write_reg(2, 0xfe, 0x002);
-			apb_write_reg(2, 0xff, 0x003ac77a);
-			apb_write_reg(2, 0xfe, 0x003);
-			apb_write_reg(2, 0xff, 0x0038a737);
-			apb_write_reg(2, 0xfe, 0x004);
-			apb_write_reg(2, 0xff, 0x00367ef2);
-			apb_write_reg(2, 0xfe, 0x005);
-			apb_write_reg(2, 0xff, 0x00344eac);
-			apb_write_reg(2, 0xfe, 0x006);
-			apb_write_reg(2, 0xff, 0x00321e66);
-			apb_write_reg(2, 0xfe, 0x007);
-			apb_write_reg(2, 0xff, 0x002fee20);
-			apb_write_reg(2, 0xfe, 0x008);
-			apb_write_reg(2, 0xff, 0x002dbdda);
-			apb_write_reg(2, 0xfe, 0x009);
-			apb_write_reg(2, 0xff, 0x002b8d94);
-			apb_write_reg(2, 0xfe, 0x00a);
-			apb_write_reg(2, 0xff, 0x00295d4e);
-			apb_write_reg(2, 0xfe, 0x00b);
-			apb_write_reg(2, 0xff, 0x00272508);
-			apb_write_reg(2, 0xfe, 0x00c);
-			apb_write_reg(2, 0xff, 0x0024dcc0);
-			apb_write_reg(2, 0xfe, 0x00d);
-			apb_write_reg(2, 0xff, 0x00227475);
-			apb_write_reg(2, 0xfe, 0x00e);
-			apb_write_reg(2, 0xff, 0x001fe426);
-			apb_write_reg(2, 0xfe, 0x00f);
-			apb_write_reg(2, 0xff, 0x001d1bd1);
-			apb_write_reg(2, 0xfe, 0x010);
-			apb_write_reg(2, 0xff, 0x001a2374);
-			apb_write_reg(2, 0xfe, 0x011);
-			apb_write_reg(2, 0xff, 0x0016e311);
-			apb_write_reg(2, 0xfe, 0x012);
-			apb_write_reg(2, 0xff, 0x00136aa6);
-			apb_write_reg(2, 0xfe, 0x013);
-			apb_write_reg(2, 0xff, 0x000fba33);
-			apb_write_reg(2, 0xfe, 0x014);
-			apb_write_reg(2, 0xff, 0x000ba9b8);
-			apb_write_reg(2, 0xfe, 0x015);
-			apb_write_reg(2, 0xff, 0x0007092e);
-			apb_write_reg(2, 0xfe, 0x016);
-			apb_write_reg(2, 0xff, 0x0001988e);
-			apb_write_reg(2, 0xfe, 0x017);
-			apb_write_reg(2, 0xff, 0x003b37d0);
-			apb_write_reg(2, 0xfe, 0x018);
-			apb_write_reg(2, 0xff, 0x0035aef3);
-			apb_write_reg(2, 0xfe, 0x019);
-			apb_write_reg(2, 0xff, 0x00316673);
-			apb_write_reg(2, 0xfe, 0x01a);
-			apb_write_reg(2, 0xff, 0x002c45de);
-			apb_write_reg(2, 0xfe, 0x01b);
-			apb_write_reg(2, 0xff, 0x0025e527);
-			apb_write_reg(2, 0xfe, 0x01c);
-			apb_write_reg(2, 0xff, 0x001da444);
-			apb_write_reg(2, 0xfe, 0x01d);
-			apb_write_reg(2, 0xff, 0x000deaea);
-			apb_write_reg(2, 0xfe, 0x01e);
-			apb_write_reg(2, 0xff, 0x000178bf);
-			apb_write_reg(2, 0xfe, 0x01f);
-			apb_write_reg(2, 0xff, 0x003cb7d6);
-			apb_write_reg(2, 0xfe, 0x020);
-			apb_write_reg(2, 0xff, 0x00000765);
-		}
-	} else if (ADsample == 28) {
-		/* 28.5714 MHz Set ACF */
-		if (bandwidth == 0) {
-			/*8M Hz */
-			apb_write_reg(2, 0x2c, 0x2DB);  /* ACF_STAGE1_A1 */
-			apb_write_reg(2, 0x2d, 0x05B);  /* ACF_STAGE1_A2 */
-			apb_write_reg(2, 0x2e, 0x163);  /* ACF_STAGE1_B1 */
-			apb_write_reg(2, 0x2f, 0x00E);  /* ACF_STAGE1_GAIN */
-			apb_write_reg(2, 0x30, 0x2D5);  /* ACF_STAGE2_A1 */
-			apb_write_reg(2, 0x31, 0x08B);  /* ACF_STAGE2_A2 */
-			apb_write_reg(2, 0x32, 0x3BC);  /* ACF_STAGE2_B1 */
-			apb_write_reg(2, 0x33, 0x06D);  /* ACF_STAGE2_GAIN */
-			apb_write_reg(2, 0x34, 0x2CF);  /* ACF_STAGE3_A1 */
-			apb_write_reg(2, 0x35, 0x0BF);  /* ACF_STAGE3_A2 */
-			apb_write_reg(2, 0x36, 0x321);  /* ACF_STAGE3_B1 */
-			apb_write_reg(2, 0x37, 0x008);  /* ACF_STAGE3_GAIN */
-			apb_write_reg(2, 0x38, 0x2C9);  /* ACF_STAGE4_A1 */
-			apb_write_reg(2, 0x39, 0x0E3);  /* ACF_STAGE4_A2 */
-			apb_write_reg(2, 0x3a, 0x2EE);  /* ACF_STAGE4_B1 */
-			apb_write_reg(2, 0x3b, 0x058);  /* ACF_STAGE4_GAIN */
-			apb_write_reg(2, 0x3c, 0x2C3);  /* ACF_STAGE5_A1 */
-			apb_write_reg(2, 0x3d, 0x0F8);  /* ACF_STAGE5_A2 */
-			apb_write_reg(2, 0x3e, 0x2DD);  /* ACF_STAGE5_B1 */
-			apb_write_reg(2, 0x3f, 0x04D);  /* ACF_STAGE5_GAIN */
-
-			apb_write_reg(2, 0xfe, 0x000);
-			apb_write_reg(2, 0xff, 0x003ef7ff);
-			apb_write_reg(2, 0xfe, 0x001);
-			apb_write_reg(2, 0xff, 0x003d37c0);
-			apb_write_reg(2, 0xfe, 0x002);
-			apb_write_reg(2, 0xff, 0x003c3f94);
-			apb_write_reg(2, 0xfe, 0x003);
-			apb_write_reg(2, 0xff, 0x003b0f78);
-			apb_write_reg(2, 0xfe, 0x004);
-			apb_write_reg(2, 0xff, 0x0038c73f);
-			apb_write_reg(2, 0xfe, 0x005);
-			apb_write_reg(2, 0xff, 0x00369ef1);
-			apb_write_reg(2, 0xfe, 0x006);
-			apb_write_reg(2, 0xff, 0x003576be);
-			apb_write_reg(2, 0xfe, 0x007);
-			apb_write_reg(2, 0xff, 0x0033b698);
-			apb_write_reg(2, 0xfe, 0x008);
-			apb_write_reg(2, 0xff, 0x0031164d);
-			apb_write_reg(2, 0xfe, 0x009);
-			apb_write_reg(2, 0xff, 0x002f1dfd);
-			apb_write_reg(2, 0xfe, 0x00a);
-			apb_write_reg(2, 0xff, 0x002de5cf);
-			apb_write_reg(2, 0xfe, 0x00b);
-			apb_write_reg(2, 0xff, 0x002c15a2);
-			apb_write_reg(2, 0xfe, 0x00c);
-			apb_write_reg(2, 0xff, 0x0029f560);
-			apb_write_reg(2, 0xfe, 0x00d);
-			apb_write_reg(2, 0xff, 0x0027bd1b);
-			apb_write_reg(2, 0xfe, 0x00e);
-			apb_write_reg(2, 0xff, 0x00252ccf);
-			apb_write_reg(2, 0xfe, 0x00f);
-			apb_write_reg(2, 0xff, 0x0022bc7c);
-			apb_write_reg(2, 0xfe, 0x010);
-			apb_write_reg(2, 0xff, 0x00207c34);
-			apb_write_reg(2, 0xfe, 0x011);
-			apb_write_reg(2, 0xff, 0x001da3e5);
-			apb_write_reg(2, 0xfe, 0x012);
-			apb_write_reg(2, 0xff, 0x001a9b83);
-			apb_write_reg(2, 0xfe, 0x013);
-			apb_write_reg(2, 0xff, 0x0017db27);
-			apb_write_reg(2, 0xfe, 0x014);
-			apb_write_reg(2, 0xff, 0x001432c6);
-			apb_write_reg(2, 0xfe, 0x015);
-			apb_write_reg(2, 0xff, 0x000fa23e);
-			apb_write_reg(2, 0xfe, 0x016);
-			apb_write_reg(2, 0xff, 0x000b91af);
-			apb_write_reg(2, 0xfe, 0x017);
-			apb_write_reg(2, 0xff, 0x00077136);
-			apb_write_reg(2, 0xfe, 0x018);
-			apb_write_reg(2, 0xff, 0x0002c090);
-			apb_write_reg(2, 0xfe, 0x019);
-			apb_write_reg(2, 0xff, 0x003ec01a);
-			apb_write_reg(2, 0xfe, 0x01a);
-			apb_write_reg(2, 0xff, 0x003a3f92);
-			apb_write_reg(2, 0xfe, 0x01b);
-			apb_write_reg(2, 0xff, 0x00354efa);
-			apb_write_reg(2, 0xfe, 0x01c);
-			apb_write_reg(2, 0xff, 0x002fee54);
-			apb_write_reg(2, 0xfe, 0x01d);
-			apb_write_reg(2, 0xff, 0x002a35a3);
-			apb_write_reg(2, 0xfe, 0x01e);
-			apb_write_reg(2, 0xff, 0x0023f4e4);
-			apb_write_reg(2, 0xfe, 0x01f);
-			apb_write_reg(2, 0xff, 0x001cdc12);
-			apb_write_reg(2, 0xfe, 0x020);
-			apb_write_reg(2, 0xff, 0x00000316);
-		} else if (bandwidth == 1) {
-			apb_write_reg(2, 0x2c, 0x2C2);  /* ACF_STAGE1_A1 */
-			apb_write_reg(2, 0x2d, 0x069);  /* ACF_STAGE1_A2 */
-			apb_write_reg(2, 0x2e, 0x134);  /* ACF_STAGE1_B1 */
-			apb_write_reg(2, 0x2f, 0x00E);  /* ACF_STAGE1_GAIN */
-			apb_write_reg(2, 0x30, 0x2B7);  /* ACF_STAGE2_A1 */
-			apb_write_reg(2, 0x31, 0x095);  /* ACF_STAGE2_A2 */
-			apb_write_reg(2, 0x32, 0x36F);  /* ACF_STAGE2_B1 */
-			apb_write_reg(2, 0x33, 0x06D);  /* ACF_STAGE2_GAIN */
-			apb_write_reg(2, 0x34, 0x2AA);  /* ACF_STAGE3_A1 */
-			apb_write_reg(2, 0x35, 0x0C6);  /* ACF_STAGE3_A2 */
-			apb_write_reg(2, 0x36, 0x2E5);  /* ACF_STAGE3_B1 */
-			apb_write_reg(2, 0x37, 0x008);  /* ACF_STAGE3_GAIN */
-			apb_write_reg(2, 0x38, 0x2A1);  /* ACF_STAGE4_A1 */
-			apb_write_reg(2, 0x39, 0x0E6);  /* ACF_STAGE4_A2 */
-			apb_write_reg(2, 0x3a, 0x2BA);  /* ACF_STAGE4_B1 */
-			apb_write_reg(2, 0x3b, 0x058);  /* ACF_STAGE4_GAIN */
-			apb_write_reg(2, 0x3c, 0x299);  /* ACF_STAGE5_A1 */
-			apb_write_reg(2, 0x3d, 0x0F9);  /* ACF_STAGE5_A2 */
-			apb_write_reg(2, 0x3e, 0x2AC);  /* ACF_STAGE5_B1 */
-			apb_write_reg(2, 0x3f, 0x04D);  /* ACF_STAGE5_GAIN */
-
-			apb_write_reg(2, 0xfe, 0x000);
-			apb_write_reg(2, 0xff, 0x003ee7ff);
-			apb_write_reg(2, 0xfe, 0x001);
-			apb_write_reg(2, 0xff, 0x003d1fbc);
-			apb_write_reg(2, 0xfe, 0x002);
-			apb_write_reg(2, 0xff, 0x003bf790);
-			apb_write_reg(2, 0xfe, 0x003);
-			apb_write_reg(2, 0xff, 0x003a876a);
-			apb_write_reg(2, 0xfe, 0x004);
-			apb_write_reg(2, 0xff, 0x00388f31);
-			apb_write_reg(2, 0xfe, 0x005);
-			apb_write_reg(2, 0xff, 0x0036c6f3);
-			apb_write_reg(2, 0xfe, 0x006);
-			apb_write_reg(2, 0xff, 0x003536bf);
-			apb_write_reg(2, 0xfe, 0x007);
-			apb_write_reg(2, 0xff, 0x00334689);
-			apb_write_reg(2, 0xfe, 0x008);
-			apb_write_reg(2, 0xff, 0x00310644);
-			apb_write_reg(2, 0xfe, 0x009);
-			apb_write_reg(2, 0xff, 0x002ef5fd);
-			apb_write_reg(2, 0xfe, 0x00a);
-			apb_write_reg(2, 0xff, 0x002d45c2);
-			apb_write_reg(2, 0xfe, 0x00b);
-			apb_write_reg(2, 0xff, 0x002b7d8c);
-			apb_write_reg(2, 0xfe, 0x00c);
-			apb_write_reg(2, 0xff, 0x00298550);
-			apb_write_reg(2, 0xfe, 0x00d);
-			apb_write_reg(2, 0xff, 0x00278510);
-			apb_write_reg(2, 0xfe, 0x00e);
-			apb_write_reg(2, 0xff, 0x00252ccc);
-			apb_write_reg(2, 0xfe, 0x00f);
-			apb_write_reg(2, 0xff, 0x0022847c);
-			apb_write_reg(2, 0xfe, 0x010);
-			apb_write_reg(2, 0xff, 0x00201427);
-			apb_write_reg(2, 0xfe, 0x011);
-			apb_write_reg(2, 0xff, 0x001e03e0);
-			apb_write_reg(2, 0xfe, 0x012);
-			apb_write_reg(2, 0xff, 0x001b6b9b);
-			apb_write_reg(2, 0xfe, 0x013);
-			apb_write_reg(2, 0xff, 0x0017c336);
-			apb_write_reg(2, 0xfe, 0x014);
-			apb_write_reg(2, 0xff, 0x0013e2b8);
-			apb_write_reg(2, 0xfe, 0x015);
-			apb_write_reg(2, 0xff, 0x0010b246);
-			apb_write_reg(2, 0xfe, 0x016);
-			apb_write_reg(2, 0xff, 0x000d81e8);
-			apb_write_reg(2, 0xfe, 0x017);
-			apb_write_reg(2, 0xff, 0x00084966);
-			apb_write_reg(2, 0xfe, 0x018);
-			apb_write_reg(2, 0xff, 0x0003089c);
-			apb_write_reg(2, 0xfe, 0x019);
-			apb_write_reg(2, 0xff, 0x003f0022);
-			apb_write_reg(2, 0xfe, 0x01a);
-			apb_write_reg(2, 0xff, 0x003aaf9c);
-			apb_write_reg(2, 0xfe, 0x01b);
-			apb_write_reg(2, 0xff, 0x00360f0c);
-			apb_write_reg(2, 0xfe, 0x01c);
-			apb_write_reg(2, 0xff, 0x00312e74);
-			apb_write_reg(2, 0xfe, 0x01d);
-			apb_write_reg(2, 0xff, 0x002c05d3);
-			apb_write_reg(2, 0xfe, 0x01e);
-			apb_write_reg(2, 0xff, 0x00268d2a);
-			apb_write_reg(2, 0xfe, 0x01f);
-			apb_write_reg(2, 0xff, 0x0020bc76);
-			apb_write_reg(2, 0xfe, 0x020);
-			apb_write_reg(2, 0xff, 0x000003b3);
-		} else if (bandwidth == 2) {
-			/* 6MHz */
-			apb_write_reg(2, 0x2c, 0x2A9);  /* ACF_STAGE1_A1 */
-			apb_write_reg(2, 0x2d, 0x078);  /* ACF_STAGE1_A2 */
-			apb_write_reg(2, 0x2e, 0x0F4);  /* ACF_STAGE1_B1 */
-			apb_write_reg(2, 0x2f, 0x01E);  /* ACF_STAGE1_GAIN */
-			apb_write_reg(2, 0x30, 0x299);  /* ACF_STAGE2_A1 */
-			apb_write_reg(2, 0x31, 0x0A1);  /* ACF_STAGE2_A2 */
-			apb_write_reg(2, 0x32, 0x321);  /* ACF_STAGE2_B1 */
-			apb_write_reg(2, 0x33, 0x078);  /* ACF_STAGE2_GAIN */
-			apb_write_reg(2, 0x34, 0x288);  /* ACF_STAGE3_A1 */
-			apb_write_reg(2, 0x35, 0x0CD);  /* ACF_STAGE3_A2 */
-			apb_write_reg(2, 0x36, 0x2AE);  /* ACF_STAGE3_B1 */
-			apb_write_reg(2, 0x37, 0x05F);  /* ACF_STAGE3_GAIN */
-			apb_write_reg(2, 0x38, 0x27C);  /* ACF_STAGE4_A1 */
-			apb_write_reg(2, 0x39, 0x0E9);  /* ACF_STAGE4_A2 */
-			apb_write_reg(2, 0x3a, 0x28B);  /* ACF_STAGE4_B1 */
-			apb_write_reg(2, 0x3b, 0x058);  /* ACF_STAGE4_GAIN */
-			apb_write_reg(2, 0x3c, 0x273);  /* ACF_STAGE5_A1 */
-			apb_write_reg(2, 0x3d, 0x0FA);  /* ACF_STAGE5_A2 */
-			apb_write_reg(2, 0x3e, 0x281);  /* ACF_STAGE5_B1 */
-			apb_write_reg(2, 0x3f, 0x04D);  /* ACF_STAGE5_GAIN */
-
-			apb_write_reg(2, 0xfe, 0x000);
-			apb_write_reg(2, 0xff, 0x003f17ff);
-			apb_write_reg(2, 0xfe, 0x001);
-			apb_write_reg(2, 0xff, 0x003d3fc4);
-			apb_write_reg(2, 0xfe, 0x002);
-			apb_write_reg(2, 0xff, 0x003b7f8a);
-			apb_write_reg(2, 0xfe, 0x003);
-			apb_write_reg(2, 0xff, 0x0039df55);
-			apb_write_reg(2, 0xfe, 0x004);
-			apb_write_reg(2, 0xff, 0x00381720);
-			apb_write_reg(2, 0xfe, 0x005);
-			apb_write_reg(2, 0xff, 0x00360ee2);
-			apb_write_reg(2, 0xfe, 0x006);
-			apb_write_reg(2, 0xff, 0x00342ea1);
-			apb_write_reg(2, 0xfe, 0x007);
-			apb_write_reg(2, 0xff, 0x0032ee6e);
-			apb_write_reg(2, 0xfe, 0x008);
-			apb_write_reg(2, 0xff, 0x0031e64e);
-			apb_write_reg(2, 0xfe, 0x009);
-			apb_write_reg(2, 0xff, 0x00300e22);
-			apb_write_reg(2, 0xfe, 0x00a);
-			apb_write_reg(2, 0xff, 0x002daddc);
-			apb_write_reg(2, 0xfe, 0x00b);
-			apb_write_reg(2, 0xff, 0x002b758f);
-			apb_write_reg(2, 0xfe, 0x00c);
-			apb_write_reg(2, 0xff, 0x0029ad51);
-			apb_write_reg(2, 0xfe, 0x00d);
-			apb_write_reg(2, 0xff, 0x0027ad18);
-			apb_write_reg(2, 0xfe, 0x00e);
-			apb_write_reg(2, 0xff, 0x00250ccd);
-			apb_write_reg(2, 0xfe, 0x00f);
-			apb_write_reg(2, 0xff, 0x00227476);
-			apb_write_reg(2, 0xfe, 0x010);
-			apb_write_reg(2, 0xff, 0x00204c2a);
-			apb_write_reg(2, 0xfe, 0x011);
-			apb_write_reg(2, 0xff, 0x001de3e6);
-			apb_write_reg(2, 0xfe, 0x012);
-			apb_write_reg(2, 0xff, 0x001a838a);
-			apb_write_reg(2, 0xfe, 0x013);
-			apb_write_reg(2, 0xff, 0x0016ab12);
-			apb_write_reg(2, 0xfe, 0x014);
-			apb_write_reg(2, 0xff, 0x00137a9d);
-			apb_write_reg(2, 0xfe, 0x015);
-			apb_write_reg(2, 0xff, 0x00113a4a);
-			apb_write_reg(2, 0xfe, 0x016);
-			apb_write_reg(2, 0xff, 0x000db1f8);
-			apb_write_reg(2, 0xfe, 0x017);
-			apb_write_reg(2, 0xff, 0x0007c15f);
-			apb_write_reg(2, 0xfe, 0x018);
-			apb_write_reg(2, 0xff, 0x00022883);
-			apb_write_reg(2, 0xfe, 0x019);
-			apb_write_reg(2, 0xff, 0x003df803);
-			apb_write_reg(2, 0xfe, 0x01a);
-			apb_write_reg(2, 0xff, 0x00398f79);
-			apb_write_reg(2, 0xfe, 0x01b);
-			apb_write_reg(2, 0xff, 0x0034d6e6);
-			apb_write_reg(2, 0xfe, 0x01c);
-			apb_write_reg(2, 0xff, 0x002fd64b);
-			apb_write_reg(2, 0xfe, 0x01d);
-			apb_write_reg(2, 0xff, 0x002a8da7);
-			apb_write_reg(2, 0xfe, 0x01e);
-			apb_write_reg(2, 0xff, 0x002504fa);
-			apb_write_reg(2, 0xfe, 0x01f);
-			apb_write_reg(2, 0xff, 0x001f2443);
-			apb_write_reg(2, 0xfe, 0x020);
-			apb_write_reg(2, 0xff, 0x00000382);
-		} else {
-			apb_write_reg(2, 0x2c, 0x28F);  /* ACF_STAGE1_A1 */
-			apb_write_reg(2, 0x2d, 0x088);  /* ACF_STAGE1_A2 */
-			apb_write_reg(2, 0x2e, 0x09E);  /* ACF_STAGE1_B1 */
-			apb_write_reg(2, 0x2f, 0x01E);  /* ACF_STAGE1_GAIN */
-			apb_write_reg(2, 0x30, 0x27C);  /* ACF_STAGE2_A1 */
-			apb_write_reg(2, 0x31, 0x0AD);  /* ACF_STAGE2_A2 */
-			apb_write_reg(2, 0x32, 0x2D6);  /* ACF_STAGE2_B1 */
-			apb_write_reg(2, 0x33, 0x078);  /* ACF_STAGE2_GAIN */
-			apb_write_reg(2, 0x34, 0x268);  /* ACF_STAGE3_A1 */
-			apb_write_reg(2, 0x35, 0x0D4);  /* ACF_STAGE3_A2 */
-			apb_write_reg(2, 0x36, 0x27C);  /* ACF_STAGE3_B1 */
-			apb_write_reg(2, 0x37, 0x05F);  /* ACF_STAGE3_GAIN */
-			apb_write_reg(2, 0x38, 0x25B);  /* ACF_STAGE4_A1 */
-			apb_write_reg(2, 0x39, 0x0ED);  /* ACF_STAGE4_A2 */
-			apb_write_reg(2, 0x3a, 0x262);  /* ACF_STAGE4_B1 */
-			apb_write_reg(2, 0x3b, 0x058);  /* ACF_STAGE4_GAIN */
-			apb_write_reg(2, 0x3c, 0x252);  /* ACF_STAGE5_A1 */
-			apb_write_reg(2, 0x3d, 0x0FB);  /* ACF_STAGE5_A2 */
-			apb_write_reg(2, 0x3e, 0x25A);  /* ACF_STAGE5_B1 */
-			apb_write_reg(2, 0x3f, 0x04D);  /* ACF_STAGE5_GAIN */
-
-			apb_write_reg(2, 0xfe, 0x000);
-			apb_write_reg(2, 0xff, 0x003f17ff);
-			apb_write_reg(2, 0xfe, 0x001);
-			apb_write_reg(2, 0xff, 0x003d4fc5);
-			apb_write_reg(2, 0xfe, 0x002);
-			apb_write_reg(2, 0xff, 0x003baf8e);
-			apb_write_reg(2, 0xfe, 0x003);
-			apb_write_reg(2, 0xff, 0x003a3f5d);
-			apb_write_reg(2, 0xfe, 0x004);
-			apb_write_reg(2, 0xff, 0x0038df32);
-			apb_write_reg(2, 0xfe, 0x005);
-			apb_write_reg(2, 0xff, 0x00374703);
-			apb_write_reg(2, 0xfe, 0x006);
-			apb_write_reg(2, 0xff, 0x00354ec9);
-			apb_write_reg(2, 0xfe, 0x007);
-			apb_write_reg(2, 0xff, 0x00333e88);
-			apb_write_reg(2, 0xfe, 0x008);
-			apb_write_reg(2, 0xff, 0x00314e47);
-			apb_write_reg(2, 0xfe, 0x009);
-			apb_write_reg(2, 0xff, 0x002f860c);
-			apb_write_reg(2, 0xfe, 0x00a);
-			apb_write_reg(2, 0xff, 0x002d9dd2);
-			apb_write_reg(2, 0xfe, 0x00b);
-			apb_write_reg(2, 0xff, 0x002b5590);
-			apb_write_reg(2, 0xfe, 0x00c);
-			apb_write_reg(2, 0xff, 0x0028cd42);
-			apb_write_reg(2, 0xfe, 0x00d);
-			apb_write_reg(2, 0xff, 0x00266cf2);
-			apb_write_reg(2, 0xfe, 0x00e);
-			apb_write_reg(2, 0xff, 0x00245cab);
-			apb_write_reg(2, 0xfe, 0x00f);
-			apb_write_reg(2, 0xff, 0x00225c6b);
-			apb_write_reg(2, 0xfe, 0x010);
-			apb_write_reg(2, 0xff, 0x00200427);
-			apb_write_reg(2, 0xfe, 0x011);
-			apb_write_reg(2, 0xff, 0x001d4bd5);
-			apb_write_reg(2, 0xfe, 0x012);
-			apb_write_reg(2, 0xff, 0x001a9b7d);
-			apb_write_reg(2, 0xfe, 0x013);
-			apb_write_reg(2, 0xff, 0x00183b2b);
-			apb_write_reg(2, 0xfe, 0x014);
-			apb_write_reg(2, 0xff, 0x0015b2e1);
-			apb_write_reg(2, 0xfe, 0x015);
-			apb_write_reg(2, 0xff, 0x00122a83);
-			apb_write_reg(2, 0xfe, 0x016);
-			apb_write_reg(2, 0xff, 0x000d49fc);
-			apb_write_reg(2, 0xfe, 0x017);
-			apb_write_reg(2, 0xff, 0x0007594e);
-			apb_write_reg(2, 0xfe, 0x018);
-			apb_write_reg(2, 0xff, 0x00024080);
-			apb_write_reg(2, 0xfe, 0x019);
-			apb_write_reg(2, 0xff, 0x003e980e);
-			apb_write_reg(2, 0xfe, 0x01a);
-			apb_write_reg(2, 0xff, 0x003ab796);
-			apb_write_reg(2, 0xfe, 0x01b);
-			apb_write_reg(2, 0xff, 0x00368f15);
-			apb_write_reg(2, 0xfe, 0x01c);
-			apb_write_reg(2, 0xff, 0x00320e8a);
-			apb_write_reg(2, 0xfe, 0x01d);
-			apb_write_reg(2, 0xff, 0x002d25f4);
-			apb_write_reg(2, 0xfe, 0x01e);
-			apb_write_reg(2, 0xff, 0x0027ad4f);
-			apb_write_reg(2, 0xfe, 0x01f);
-			apb_write_reg(2, 0xff, 0x00219496);
-			apb_write_reg(2, 0xfe, 0x020);
-			apb_write_reg(2, 0xff, 0x000003c9);
-		}
-	} else {
-		/* 20.7 MHz Set ACF */
-		if (bandwidth == 0) {
-			/*8M Hz */
-			apb_write_reg(2, 0x2c, 0x318);  /* ACF_STAGE1_A1 */
-			apb_write_reg(2, 0x2d, 0x03E);  /* ACF_STAGE1_A2 */
-			apb_write_reg(2, 0x2e, 0x1AE);  /* ACF_STAGE1_B1 */
-			apb_write_reg(2, 0x2f, 0x00E);  /* ACF_STAGE1_GAIN */
-			apb_write_reg(2, 0x30, 0x326);  /* ACF_STAGE2_A1 */
-			apb_write_reg(2, 0x31, 0x074);  /* ACF_STAGE2_A2 */
-			apb_write_reg(2, 0x32, 0x074);  /* ACF_STAGE2_B1 */
-			apb_write_reg(2, 0x33, 0x06F);  /* ACF_STAGE2_GAIN */
-			apb_write_reg(2, 0x34, 0x336);  /* ACF_STAGE3_A1 */
-			apb_write_reg(2, 0x35, 0x0B1);  /* ACF_STAGE3_A2 */
-			apb_write_reg(2, 0x36, 0x3C9);  /* ACF_STAGE3_B1 */
-			apb_write_reg(2, 0x37, 0x008);  /* ACF_STAGE3_GAIN */
-			apb_write_reg(2, 0x38, 0x33F);  /* ACF_STAGE4_A1 */
-			apb_write_reg(2, 0x39, 0x0DC);  /* ACF_STAGE4_A2 */
-			apb_write_reg(2, 0x3a, 0x384);  /* ACF_STAGE4_B1 */
-			apb_write_reg(2, 0x3b, 0x05A);  /* ACF_STAGE4_GAIN */
-			apb_write_reg(2, 0x3c, 0x340);  /* ACF_STAGE5_A1 */
-			apb_write_reg(2, 0x3d, 0x0F6);  /* ACF_STAGE5_A2 */
-			apb_write_reg(2, 0x3e, 0x36D);  /* ACF_STAGE5_B1 */
-			apb_write_reg(2, 0x3f, 0x04B);  /* ACF_STAGE5_GAIN */
-
-			apb_write_reg(2, 0xfe, 0x000);
-			apb_write_reg(2, 0xff, 0x003f37ff);
-			apb_write_reg(2, 0xfe, 0x001);
-			apb_write_reg(2, 0xff, 0x003d97cc);
-			apb_write_reg(2, 0xfe, 0x002);
-			apb_write_reg(2, 0xff, 0x003bf798);
-			apb_write_reg(2, 0xfe, 0x003);
-			apb_write_reg(2, 0xff, 0x003a4f64);
-			apb_write_reg(2, 0xfe, 0x004);
-			apb_write_reg(2, 0xff, 0x0038a72f);
-			apb_write_reg(2, 0xfe, 0x005);
-			apb_write_reg(2, 0xff, 0x0036f6f9);
-			apb_write_reg(2, 0xfe, 0x006);
-			apb_write_reg(2, 0xff, 0x003546c3);
-			apb_write_reg(2, 0xfe, 0x007);
-			apb_write_reg(2, 0xff, 0x0033868c);
-			apb_write_reg(2, 0xfe, 0x008);
-			apb_write_reg(2, 0xff, 0x0031be54);
-			apb_write_reg(2, 0xfe, 0x009);
-			apb_write_reg(2, 0xff, 0x002fe61a);
-			apb_write_reg(2, 0xfe, 0x00a);
-			apb_write_reg(2, 0xff, 0x002e05df);
-			apb_write_reg(2, 0xfe, 0x00b);
-			apb_write_reg(2, 0xff, 0x002c15a2);
-			apb_write_reg(2, 0xfe, 0x00c);
-			apb_write_reg(2, 0xff, 0x002a1562);
-			apb_write_reg(2, 0xfe, 0x00d);
-			apb_write_reg(2, 0xff, 0x0027f520);
-			apb_write_reg(2, 0xfe, 0x00e);
-			apb_write_reg(2, 0xff, 0x0025c4dc);
-			apb_write_reg(2, 0xfe, 0x00f);
-			apb_write_reg(2, 0xff, 0x00236c93);
-			apb_write_reg(2, 0xfe, 0x010);
-			apb_write_reg(2, 0xff, 0x0020f446);
-			apb_write_reg(2, 0xfe, 0x011);
-			apb_write_reg(2, 0xff, 0x001e4bf4);
-			apb_write_reg(2, 0xfe, 0x012);
-			apb_write_reg(2, 0xff, 0x001b739d);
-			apb_write_reg(2, 0xfe, 0x013);
-			apb_write_reg(2, 0xff, 0x00185b3d);
-			apb_write_reg(2, 0xfe, 0x014);
-			apb_write_reg(2, 0xff, 0x0014ead5);
-			apb_write_reg(2, 0xfe, 0x015);
-			apb_write_reg(2, 0xff, 0x00111a62);
-			apb_write_reg(2, 0xfe, 0x016);
-			apb_write_reg(2, 0xff, 0x000cb9df);
-			apb_write_reg(2, 0xfe, 0x017);
-			apb_write_reg(2, 0xff, 0x00079148);
-			apb_write_reg(2, 0xfe, 0x018);
-			apb_write_reg(2, 0xff, 0x00030093);
-			apb_write_reg(2, 0xfe, 0x019);
-			apb_write_reg(2, 0xff, 0x003f802a);
-			apb_write_reg(2, 0xfe, 0x01a);
-			apb_write_reg(2, 0xff, 0x003b77b2);
-			apb_write_reg(2, 0xfe, 0x01b);
-			apb_write_reg(2, 0xff, 0x0036a725);
-			apb_write_reg(2, 0xfe, 0x01c);
-			apb_write_reg(2, 0xff, 0x0030ae7b);
-			apb_write_reg(2, 0xfe, 0x01d);
-			apb_write_reg(2, 0xff, 0x00285d9f);
-			apb_write_reg(2, 0xfe, 0x01e);
-			apb_write_reg(2, 0xff, 0x001abc46);
-			apb_write_reg(2, 0xfe, 0x01f);
-			apb_write_reg(2, 0xff, 0x000f8a85);
-			apb_write_reg(2, 0xfe, 0x020);
-			apb_write_reg(2, 0xff, 0x00000187);
-		} else if (bandwidth == 1) {
-			apb_write_reg(2, 0x2c, 0x2F9);  /* ACF_STAGE1_A1 */
-			apb_write_reg(2, 0x2d, 0x04C);  /* ACF_STAGE1_A2 */
-			apb_write_reg(2, 0x2e, 0x18E);  /* ACF_STAGE1_B1 */
-			apb_write_reg(2, 0x2f, 0x00E);  /* ACF_STAGE1_GAIN */
-			apb_write_reg(2, 0x30, 0x2FD);  /* ACF_STAGE2_A1 */
-			apb_write_reg(2, 0x31, 0x07F);  /* ACF_STAGE2_A2 */
-			apb_write_reg(2, 0x32, 0x01A);  /* ACF_STAGE2_B1 */
-			apb_write_reg(2, 0x33, 0x06D);  /* ACF_STAGE2_GAIN */
-			apb_write_reg(2, 0x34, 0x300);  /* ACF_STAGE3_A1 */
-			apb_write_reg(2, 0x35, 0x0B8);  /* ACF_STAGE3_A2 */
-			apb_write_reg(2, 0x36, 0x372);  /* ACF_STAGE3_B1 */
-			apb_write_reg(2, 0x37, 0x05F);  /* ACF_STAGE3_GAIN */
-			apb_write_reg(2, 0x38, 0x301);  /* ACF_STAGE4_A1 */
-			apb_write_reg(2, 0x39, 0x0DF);  /* ACF_STAGE4_A2 */
-			apb_write_reg(2, 0x3a, 0x335);  /* ACF_STAGE4_B1 */
-			apb_write_reg(2, 0x3b, 0x05A);  /* ACF_STAGE4_GAIN */
-			apb_write_reg(2, 0x3c, 0x2FE);  /* ACF_STAGE5_A1 */
-			apb_write_reg(2, 0x3d, 0x0F7);  /* ACF_STAGE5_A2 */
-			apb_write_reg(2, 0x3e, 0x320);  /* ACF_STAGE5_B1 */
-			apb_write_reg(2, 0x3f, 0x04B);  /* ACF_STAGE5_GAIN */
-
-			apb_write_reg(2, 0xfe, 0x000);
-			apb_write_reg(2, 0xff, 0x003f37ff);
-			apb_write_reg(2, 0xfe, 0x001);
-			apb_write_reg(2, 0xff, 0x003d8fcc);
-			apb_write_reg(2, 0xfe, 0x002);
-			apb_write_reg(2, 0xff, 0x003bef97);
-			apb_write_reg(2, 0xfe, 0x003);
-			apb_write_reg(2, 0xff, 0x003a4762);
-			apb_write_reg(2, 0xfe, 0x004);
-			apb_write_reg(2, 0xff, 0x0038972d);
-			apb_write_reg(2, 0xfe, 0x005);
-			apb_write_reg(2, 0xff, 0x0036e6f7);
-			apb_write_reg(2, 0xfe, 0x006);
-			apb_write_reg(2, 0xff, 0x00352ec1);
-			apb_write_reg(2, 0xfe, 0x007);
-			apb_write_reg(2, 0xff, 0x00336e89);
-			apb_write_reg(2, 0xfe, 0x008);
-			apb_write_reg(2, 0xff, 0x00319e50);
-			apb_write_reg(2, 0xfe, 0x009);
-			apb_write_reg(2, 0xff, 0x002fce16);
-			apb_write_reg(2, 0xfe, 0x00a);
-			apb_write_reg(2, 0xff, 0x002de5db);
-			apb_write_reg(2, 0xfe, 0x00b);
-			apb_write_reg(2, 0xff, 0x002bf59d);
-			apb_write_reg(2, 0xfe, 0x00c);
-			apb_write_reg(2, 0xff, 0x0029ed5e);
-			apb_write_reg(2, 0xfe, 0x00d);
-			apb_write_reg(2, 0xff, 0x0027d51c);
-			apb_write_reg(2, 0xfe, 0x00e);
-			apb_write_reg(2, 0xff, 0x00259cd7);
-			apb_write_reg(2, 0xfe, 0x00f);
-			apb_write_reg(2, 0xff, 0x0023448e);
-			apb_write_reg(2, 0xfe, 0x010);
-			apb_write_reg(2, 0xff, 0x0020cc41);
-			apb_write_reg(2, 0xfe, 0x011);
-			apb_write_reg(2, 0xff, 0x001e23ef);
-			apb_write_reg(2, 0xfe, 0x012);
-			apb_write_reg(2, 0xff, 0x001b4b98);
-			apb_write_reg(2, 0xfe, 0x013);
-			apb_write_reg(2, 0xff, 0x00183339);
-			apb_write_reg(2, 0xfe, 0x014);
-			apb_write_reg(2, 0xff, 0x0014cad1);
-			apb_write_reg(2, 0xfe, 0x015);
-			apb_write_reg(2, 0xff, 0x0010fa5e);
-			apb_write_reg(2, 0xfe, 0x016);
-			apb_write_reg(2, 0xff, 0x000c99dc);
-			apb_write_reg(2, 0xfe, 0x017);
-			apb_write_reg(2, 0xff, 0x00078145);
-			apb_write_reg(2, 0xfe, 0x018);
-			apb_write_reg(2, 0xff, 0x0002f892);
-			apb_write_reg(2, 0xfe, 0x019);
-			apb_write_reg(2, 0xff, 0x003f802a);
-			apb_write_reg(2, 0xfe, 0x01a);
-			apb_write_reg(2, 0xff, 0x003b8fb3);
-			apb_write_reg(2, 0xfe, 0x01b);
-			apb_write_reg(2, 0xff, 0x0036d729);
-			apb_write_reg(2, 0xfe, 0x01c);
-			apb_write_reg(2, 0xff, 0x00310682);
-			apb_write_reg(2, 0xfe, 0x01d);
-			apb_write_reg(2, 0xff, 0x00290dae);
-			apb_write_reg(2, 0xfe, 0x01e);
-			apb_write_reg(2, 0xff, 0x001c0c67);
-			apb_write_reg(2, 0xfe, 0x01f);
-			apb_write_reg(2, 0xff, 0x0010a2ad);
-			apb_write_reg(2, 0xfe, 0x020);
-			apb_write_reg(2, 0xff, 0x000001a8);
-		} else if (bandwidth == 2) {
-			/* 6MHz */
-			apb_write_reg(2, 0x2c, 0x2D9);  /* ACF_STAGE1_A1 */
-			apb_write_reg(2, 0x2d, 0x05C);  /* ACF_STAGE1_A2 */
-			apb_write_reg(2, 0x2e, 0x161);  /* ACF_STAGE1_B1 */
-			apb_write_reg(2, 0x2f, 0x00E);  /* ACF_STAGE1_GAIN */
-			apb_write_reg(2, 0x30, 0x2D4);  /* ACF_STAGE2_A1 */
-			apb_write_reg(2, 0x31, 0x08B);  /* ACF_STAGE2_A2 */
-			apb_write_reg(2, 0x32, 0x3B8);  /* ACF_STAGE2_B1 */
-			apb_write_reg(2, 0x33, 0x06B);  /* ACF_STAGE2_GAIN */
-			apb_write_reg(2, 0x34, 0x2CD);  /* ACF_STAGE3_A1 */
-			apb_write_reg(2, 0x35, 0x0C0);  /* ACF_STAGE3_A2 */
-			apb_write_reg(2, 0x36, 0x31E);  /* ACF_STAGE3_B1 */
-			apb_write_reg(2, 0x37, 0x05F);  /* ACF_STAGE3_GAIN */
-			apb_write_reg(2, 0x38, 0x2C7);  /* ACF_STAGE4_A1 */
-			apb_write_reg(2, 0x39, 0x0E3);  /* ACF_STAGE4_A2 */
-			apb_write_reg(2, 0x3a, 0x2EB);  /* ACF_STAGE4_B1 */
-			apb_write_reg(2, 0x3b, 0x05A);  /* ACF_STAGE4_GAIN */
-			apb_write_reg(2, 0x3c, 0x2C1);  /* ACF_STAGE5_A1 */
-			apb_write_reg(2, 0x3d, 0x0F8);  /* ACF_STAGE5_A2 */
-			apb_write_reg(2, 0x3e, 0x2DA);  /* ACF_STAGE5_B1 */
-			apb_write_reg(2, 0x3f, 0x04B);  /* ACF_STAGE5_GAIN */
-			apb_write_reg(2, 0xfe, 0x000);
-			apb_write_reg(2, 0xff, 0x003f2fff);
-			apb_write_reg(2, 0xfe, 0x001);
-			apb_write_reg(2, 0xff, 0x003d87cb);
-			apb_write_reg(2, 0xfe, 0x002);
-			apb_write_reg(2, 0xff, 0x003bdf96);
-			apb_write_reg(2, 0xfe, 0x003);
-			apb_write_reg(2, 0xff, 0x003a2f60);
-			apb_write_reg(2, 0xfe, 0x004);
-			apb_write_reg(2, 0xff, 0x00387f2a);
-			apb_write_reg(2, 0xfe, 0x005);
-			apb_write_reg(2, 0xff, 0x0036c6f4);
-			apb_write_reg(2, 0xfe, 0x006);
-			apb_write_reg(2, 0xff, 0x00350ebd);
-			apb_write_reg(2, 0xfe, 0x007);
-			apb_write_reg(2, 0xff, 0x00334684);
-			apb_write_reg(2, 0xfe, 0x008);
-			apb_write_reg(2, 0xff, 0x0031764b);
-			apb_write_reg(2, 0xfe, 0x009);
-			apb_write_reg(2, 0xff, 0x002f9e11);
-			apb_write_reg(2, 0xfe, 0x00a);
-			apb_write_reg(2, 0xff, 0x002db5d4);
-			apb_write_reg(2, 0xfe, 0x00b);
-			apb_write_reg(2, 0xff, 0x002bbd97);
-			apb_write_reg(2, 0xfe, 0x00c);
-			apb_write_reg(2, 0xff, 0x0029b557);
-			apb_write_reg(2, 0xfe, 0x00d);
-			apb_write_reg(2, 0xff, 0x00279515);
-			apb_write_reg(2, 0xfe, 0x00e);
-			apb_write_reg(2, 0xff, 0x00255ccf);
-			apb_write_reg(2, 0xfe, 0x00f);
-			apb_write_reg(2, 0xff, 0x00230c87);
-			apb_write_reg(2, 0xfe, 0x010);
-			apb_write_reg(2, 0xff, 0x0020943a);
-			apb_write_reg(2, 0xfe, 0x011);
-			apb_write_reg(2, 0xff, 0x001debe8);
-			apb_write_reg(2, 0xfe, 0x012);
-			apb_write_reg(2, 0xff, 0x001b1b91);
-			apb_write_reg(2, 0xfe, 0x013);
-			apb_write_reg(2, 0xff, 0x00180b33);
-			apb_write_reg(2, 0xfe, 0x014);
-			apb_write_reg(2, 0xff, 0x0014aacc);
-			apb_write_reg(2, 0xfe, 0x015);
-			apb_write_reg(2, 0xff, 0x0010e25a);
-			apb_write_reg(2, 0xfe, 0x016);
-			apb_write_reg(2, 0xff, 0x000c91da);
-			apb_write_reg(2, 0xfe, 0x017);
-			apb_write_reg(2, 0xff, 0x00078945);
-			apb_write_reg(2, 0xfe, 0x018);
-			apb_write_reg(2, 0xff, 0x00031895);
-			apb_write_reg(2, 0xfe, 0x019);
-			apb_write_reg(2, 0xff, 0x003fa82e);
-			apb_write_reg(2, 0xfe, 0x01a);
-			apb_write_reg(2, 0xff, 0x003bbfb8);
-			apb_write_reg(2, 0xfe, 0x01b);
-			apb_write_reg(2, 0xff, 0x00371730);
-			apb_write_reg(2, 0xfe, 0x01c);
-			apb_write_reg(2, 0xff, 0x0031668c);
-			apb_write_reg(2, 0xfe, 0x01d);
-			apb_write_reg(2, 0xff, 0x00299dbc);
-			apb_write_reg(2, 0xfe, 0x01e);
-			apb_write_reg(2, 0xff, 0x001d1480);
-			apb_write_reg(2, 0xfe, 0x01f);
-			apb_write_reg(2, 0xff, 0x00119acf);
-			apb_write_reg(2, 0xfe, 0x020);
-			apb_write_reg(2, 0xff, 0x000001c4);
-		} else {
-			apb_write_reg(2, 0x2c, 0x2B9);  /* ACF_STAGE1_A1 */
-			apb_write_reg(2, 0x2d, 0x06E);  /* ACF_STAGE1_A2 */
-			apb_write_reg(2, 0x2e, 0x11E);  /* ACF_STAGE1_B1 */
-			apb_write_reg(2, 0x2f, 0x01E);  /* ACF_STAGE1_GAIN */
-			apb_write_reg(2, 0x30, 0x2AB);  /* ACF_STAGE2_A1 */
-			apb_write_reg(2, 0x31, 0x099);  /* ACF_STAGE2_A2 */
-			apb_write_reg(2, 0x32, 0x351);  /* ACF_STAGE2_B1 */
-			apb_write_reg(2, 0x33, 0x06B);  /* ACF_STAGE2_GAIN */
-			apb_write_reg(2, 0x34, 0x29D);  /* ACF_STAGE3_A1 */
-			apb_write_reg(2, 0x35, 0x0C8);  /* ACF_STAGE3_A2 */
-			apb_write_reg(2, 0x36, 0x2D0);  /* ACF_STAGE3_B1 */
-			apb_write_reg(2, 0x37, 0x05F);  /* ACF_STAGE3_GAIN */
-			apb_write_reg(2, 0x38, 0x292);  /* ACF_STAGE4_A1 */
-			apb_write_reg(2, 0x39, 0x0E7);  /* ACF_STAGE4_A2 */
-			apb_write_reg(2, 0x3a, 0x2A8);  /* ACF_STAGE4_B1 */
-			apb_write_reg(2, 0x3b, 0x05A);  /* ACF_STAGE4_GAIN */
-			apb_write_reg(2, 0x3c, 0x28A);  /* ACF_STAGE5_A1 */
-			apb_write_reg(2, 0x3d, 0x0F9);  /* ACF_STAGE5_A2 */
-			apb_write_reg(2, 0x3e, 0x29B);  /* ACF_STAGE5_B1 */
-			apb_write_reg(2, 0x3f, 0x04B);  /* ACF_STAGE5_GAIN */
-
-			apb_write_reg(2, 0xfe, 0x000);
-			apb_write_reg(2, 0xff, 0x003f2fff);
-			apb_write_reg(2, 0xfe, 0x001);
-			apb_write_reg(2, 0xff, 0x003d7fca);
-			apb_write_reg(2, 0xfe, 0x002);
-			apb_write_reg(2, 0xff, 0x003bcf94);
-			apb_write_reg(2, 0xfe, 0x003);
-			apb_write_reg(2, 0xff, 0x003a1f5e);
-			apb_write_reg(2, 0xfe, 0x004);
-			apb_write_reg(2, 0xff, 0x00386727);
-			apb_write_reg(2, 0xfe, 0x005);
-			apb_write_reg(2, 0xff, 0x0036a6f0);
-			apb_write_reg(2, 0xfe, 0x006);
-			apb_write_reg(2, 0xff, 0x0034e6b8);
-			apb_write_reg(2, 0xfe, 0x007);
-			apb_write_reg(2, 0xff, 0x0033167f);
-			apb_write_reg(2, 0xfe, 0x008);
-			apb_write_reg(2, 0xff, 0x00314645);
-			apb_write_reg(2, 0xfe, 0x009);
-			apb_write_reg(2, 0xff, 0x002f660a);
-			apb_write_reg(2, 0xfe, 0x00a);
-			apb_write_reg(2, 0xff, 0x002d75cd);
-			apb_write_reg(2, 0xfe, 0x00b);
-			apb_write_reg(2, 0xff, 0x002b758e);
-			apb_write_reg(2, 0xfe, 0x00c);
-			apb_write_reg(2, 0xff, 0x0029654e);
-			apb_write_reg(2, 0xfe, 0x00d);
-			apb_write_reg(2, 0xff, 0x0027450a);
-			apb_write_reg(2, 0xfe, 0x00e);
-			apb_write_reg(2, 0xff, 0x002504c4);
-			apb_write_reg(2, 0xfe, 0x00f);
-			apb_write_reg(2, 0xff, 0x0022a47b);
-			apb_write_reg(2, 0xfe, 0x010);
-			apb_write_reg(2, 0xff, 0x0020242d);
-			apb_write_reg(2, 0xfe, 0x011);
-			apb_write_reg(2, 0xff, 0x001d7bdb);
-			apb_write_reg(2, 0xfe, 0x012);
-			apb_write_reg(2, 0xff, 0x001aa383);
-			apb_write_reg(2, 0xfe, 0x013);
-			apb_write_reg(2, 0xff, 0x00178b24);
-			apb_write_reg(2, 0xfe, 0x014);
-			apb_write_reg(2, 0xff, 0x00142abd);
-			apb_write_reg(2, 0xfe, 0x015);
-			apb_write_reg(2, 0xff, 0x0010624a);
-			apb_write_reg(2, 0xfe, 0x016);
-			apb_write_reg(2, 0xff, 0x000c11ca);
-			apb_write_reg(2, 0xfe, 0x017);
-			apb_write_reg(2, 0xff, 0x00070935);
-			apb_write_reg(2, 0xfe, 0x018);
-			apb_write_reg(2, 0xff, 0x00029885);
-			apb_write_reg(2, 0xfe, 0x019);
-			apb_write_reg(2, 0xff, 0x003f281e);
-			apb_write_reg(2, 0xfe, 0x01a);
-			apb_write_reg(2, 0xff, 0x003b3fa9);
-			apb_write_reg(2, 0xfe, 0x01b);
-			apb_write_reg(2, 0xff, 0x00369720);
-			apb_write_reg(2, 0xfe, 0x01c);
-			apb_write_reg(2, 0xff, 0x0030ce7b);
-			apb_write_reg(2, 0xfe, 0x01d);
-			apb_write_reg(2, 0xff, 0x0028dda7);
-			apb_write_reg(2, 0xfe, 0x01e);
-			apb_write_reg(2, 0xff, 0x001c6464);
-			apb_write_reg(2, 0xfe, 0x01f);
-			apb_write_reg(2, 0xff, 0x0011b2c7);
-			apb_write_reg(2, 0xfe, 0x020);
-			apb_write_reg(2, 0xff, 0x000001cb);
-		}
-	}
-}
-
-static void dvbt_reg_initial(struct aml_demod_sta *demod_sta)
-{
-	u32 clk_freq;
-	u32 adc_freq;
-	u8 ch_mode;
-	u8 agc_mode;
-	u32 ch_freq;
-	u16 ch_if;
-	u16 ch_bw;
-	u16 symb_rate;
-
-	u8 bw;
-	u8 sr;
-	u8 ifreq;
-	u32 tmp;
-
-	clk_freq = demod_sta->clk_freq; /* kHz */
-	adc_freq = demod_sta->adc_freq; /* kHz */
-	ch_mode = demod_sta->ch_mode;
-	agc_mode = demod_sta->agc_mode;
-	ch_freq = demod_sta->ch_freq;           /* kHz */
-	ch_if = demod_sta->ch_if;               /* kHz */
-	ch_bw = demod_sta->ch_bw;               /* kHz */
-	symb_rate = demod_sta->symb_rate;       /* k/sec */
-
-	bw = 8 - ch_bw / 1000;
-	sr = adc_freq > 40000 ? 3 : adc_freq > 24000 ? 2 :
-	     adc_freq > 20770 ? 1 : 0;
-	ifreq = ch_if > 35000 ? 0 : 1;
-
-	/*//////////////////////////////////// */
-	/* bw == 0 : 8M */
-	/*       1 : 7M */
-	/*       2 : 6M */
-	/*       3 : 5M */
-	/* sr == 0 : 20.7M */
-	/*       1 : 20.8333M */
-	/*       2 : 28.5714M */
-	/*       3 : 45M */
-	/* ifreq == 0: 36.13MHz */
-	/*          1: 4.57MHz */
-	/* agc_mode == 0: single AGC */
-	/*             1: dual AGC */
-	/*//////////////////////////////////// */
-	apb_write_reg(2, 0x02, 0x00800000);
-	/* SW reset bit[23] ; write anything to zero */
-	apb_write_reg(2, 0x00, 0x00000000);
-
-	switch (sr) {
-	case 0:
-		apb_write_reg(2, 0x08, 0x00002966);
-		break;
-	case 1:
-		apb_write_reg(2, 0x08, 0x00002999);
-		break;
-	case 2:
-		apb_write_reg(2, 0x08, 0x00003924);
-		break;
-	case 3:
-		apb_write_reg(2, 0x08, 0x00005a00);
-		break;          /*sample_rate   /*45M */
-	default:
-		break;
-	}
-
-	apb_write_reg(2, 0x0d, 0x00000000);
-	apb_write_reg(2, 0x0e, 0x00000000);
-	dvbt_enable_irq(8);
-
-	apb_write_reg(2, 0x11, 0x00100002);     /* FSM [15:0] TIMER_FEC_LOST */
-	apb_write_reg(2, 0x12, 0x02100201);     /* FSM */
-	apb_write_reg(2, 0x14, 0xe81c4ff6);     /* AGC_TARGET 0xf0121385 */
-	apb_write_reg(2, 0x15, 0x02050ca6);     /* AGC_CTRL */
-
-	switch (sr) {
-	case 0:
-		apb_write_reg(2, 0x15, apb_read_reg(2, 0x15) | (0x5b << 12));
-		break;
-	case 1:
-		apb_write_reg(2, 0x15, apb_read_reg(2, 0x15) | (0x5b << 12));
-		break;
-	case 2:
-		apb_write_reg(2, 0x15, apb_read_reg(2, 0x15) | (0x7b << 12));
-		break;
-	case 3:
-		apb_write_reg(2, 0x15, apb_read_reg(2, 0x15) | (0xc2 << 12));
-		break;          /* sample_rate /*45M */
-	default:
-		break;
-	}
-
-	if (agc_mode == 0)
-		apb_write_reg(2, 0x16, 0x67f80);        /* AGC_IFGAIN_CTRL */
-	else if (agc_mode == 1)
-		apb_write_reg(2, 0x16, 0x07f80);        /* AGC_IFGAIN_CTRL */
-
-	apb_write_reg(2, 0x17, 0x07f80);                /* AGC_RFGAIN_CTRL */
-	apb_write_reg(2, 0x18, 0x00000000);             /* AGC_IFGAIN_ACCUM */
-	apb_write_reg(2, 0x19, 0x00000000);             /* AGC_RFGAIN_ACCUM */
-
-	if (ifreq == 0) {
-		switch (sr) {
-		case 0:
-			apb_write_reg(2, 0x20, 0x00002096);
-			break;
-		/* DDC NORM_PHASE 36.13M IF For 20.7M sample rate */
-		case 1:
-			apb_write_reg(2, 0x20, 0x000021a9);
-			break;
-		/* DDC NORM_PHASE 36.13M IF For 20.8333M sample rate*/
-		case 2:
-			apb_write_reg(2, 0x20, 0x000021dc);
-			break;
-		/* DDC NORM_PHASE 36.13M IF For 28.57142M sample rate*/
-		case 3:
-			apb_write_reg(2, 0x20, 0x000066e2);
-			break;
-		/* DDC NORM_PHASE    36.13M IF  For 45M sample rate */
-		default:
-			break;
-		}
-	} else if (ifreq == 1) {
-		switch (sr) {
-		case 0:
-			apb_write_reg(2, 0x20, 0x00001c42);
-			break;
-		/* DDC NORM_PHASE 4.57M IF For 20.7M sample rate */
-		case 1:
-			apb_write_reg(2, 0x20, 0x00001c1f);
-			break;
-		/* DDC NORM_PHASE 4.57M IF For 20.8333M sample rate */
-		case 2:
-			apb_write_reg(2, 0x20, 0x00001479);
-			break;
-		/* DDC NORM_PHASE 4.57M IF For 28.57142M sample rate*/
-		case 3:
-			apb_write_reg(2, 0x20, 0x0000d00);
-			break;
-		/* DDC NORM_PHASE    4.57M IF  For 45M sample rate */
-		default:
-			break;
-		}
-	}
-	*/tmp = ch_if * (1 << 15)/adc_freq;
-	tmp &= 0x3fff;
-	apb_write_reg(2, 0x20, tmp);
-	if (demod_sta->debug)
-		dprintk("IF: %d kHz  ADC: %d kHz  DDC: %04x\n", ch_if, adc_freq,
-			tmp);
-
-	apb_write_reg(2, 0x21, 0x001ff000);     /* DDC CS_FCFO_ADJ_CTRL */
-	apb_write_reg(2, 0x22, 0x00000000);     /* DDC ICFO_ADJ_CTRL */
-	apb_write_reg(2, 0x23, 0x00004000);     /* DDC TRACK_FCFO_ADJ_CTRL */
-	apb_write_reg(2, 0x27, 0x00a98200);
-	/*[23] agc state mode [22:19] icfo_time_limit ;[18:15] tps_time_limit ;
-	 * [14:4] cs_cfo_thres ;  [3:0] fsm_state_d; */
-	/*            1              010,1                   001,1
-	 *      000,0010,0000,                xxxx */
-	apb_write_reg(2, 0x28, 0x04028032);
-	/* [31:24] cs_Q_thres; [23:13] sfo_thres;  FSM [12:0] fcfo_thres;; */
-	/*      0000,0100,        0000,0010,100          0,0000,0011,0010 */
-	apb_write_reg(2, 0x29, 0x0051117F);
-	/*apb_write_reg(2, 0x29, 0x00010f7F); */
-	/*  [18:16] fec_rs_sh_ctrl ;[15:9] fsm_total_timer;
-	 * [8:6] modeDet_time_limit; FSM [5:0] sfo_time_limit; ; */
-	/*     01,     ()   0000,111 1,01                     11,1111 */
-
-	/* SRC NORM_INRATE */
-	switch (bw) {
-	case 0:
-		tmp = (1 << 14) * adc_freq / 125 / 8 * 7;
-		break;
-	case 1:
-		tmp = (1 << 14) * adc_freq / 125;
-		break;
-	case 2:
-		tmp = (1 << 14) * adc_freq / 125 / 6 * 7;
-		break;
-	case 3:
-		tmp = (1 << 14) * adc_freq / 125 / 5 * 7;
-		break;
-	default:
-		tmp = (1 << 14) * adc_freq / 125 / 8 * 7;
-		break;
-	}
-
-	apb_write_reg(2, 0x44, tmp & 0x7fffff);
-
-	apb_write_reg(2, 0x45, 0x00000000);     /* SRC SRC_PHASE_INI */
-	apb_write_reg(2, 0x46, 0x02004000);
-	/* SRC SFO_ADJ_CTRL SFO limit 0x100!! */
-	apb_write_reg(2, 0x48, 0xc0287);        /* DAGC_CTRL */
-	apb_write_reg(2, 0x49, 0x00000005);     /* DAGC_CTRL1 */
-	apb_write_reg(2, 0x4c, 0x00000bbf);     /* CCI_RP */
-	apb_write_reg(2, 0x4d, 0x00000376);     /* CCI_RPSQ */
-	apb_write_reg(2, 0x4e, 0x00202109);     /* CCI_CTRL */
-	apb_write_reg(2, 0x52, 0x00000000);     /* CCI_NOTCH1_A2 */
-	apb_write_reg(2, 0x53, 0x00000000);     /* CCI_NOTCH1_B1 */
-	apb_write_reg(2, 0x54, 0x00c00000);     /* CCI_NOTCH2_A1 */
-	apb_write_reg(2, 0x55, 0x00000000);     /* CCI_NOTCH2_A2 */
-	apb_write_reg(2, 0x56, 0x00000000);     /* CCI_NOTCH2_B1 */
-	apb_write_reg(2, 0x57, 0x00000000);     /* CCI_NOTCH2_B1 */
-	apb_write_reg(2, 0x58, 0x00000886);     /* MODE_DETECT_CTRL */
-	apb_write_reg(2, 0x5c, 0x00001011);     /* ICFO_EST_CTRL */
-	apb_write_reg(2, 0x5f, 0x00010503);     /* TPS_FCFO_CTRL */
-	apb_write_reg(2, 0x61, 0x00000003);     /* DE_PN_CTRL */
-	apb_write_reg(2, 0x61, apb_read_reg(2, 0x61) | (1 << 2));
-	/* DE_PN_CTRL SP sync close , Use TPS only ; */
-	apb_write_reg(2, 0x68, 0x004060c0);     /* CHAN_EST_CTRL0 */
-	apb_write_reg(2, 0x68, apb_read_reg(2, 0x68) & ~(1 << 7));
-	/* SNR report filter; */
-	/*apb_write_reg(2, 0x68, apb_read_reg(2, 0x68) &~(1<<13));  //
-	 * Timing Adjust Shutdown; */
-	apb_write_reg(2, 0x69, 0x148c3812);     /* CHAN_EST_CTRL1 */
-	/*apb_write_reg(2, 0x69, apb_read_reg(2, 0x69) | (1<<10));  //
-	 * Disable FD data update */
-	/*apb_write_reg(2, 0x69, apb_read_reg(2, 0x69) | (1<<9));  //
-	 * set FD coeff */
-	/*apb_write_reg(2, 0x69, apb_read_reg(2, 0x69) | (1<<8));  //
-	 * set TD coeff */
-	apb_write_reg(2, 0x6a, 0x9101012d);     /* CHAN_EST_CTRL2 */
-	apb_write_reg(2, 0x6b, 0x00442211);     /* CHAN_EST_CTRL2 */
-	apb_write_reg(2, 0x6c, 0x01fc040a);     /* CHAN_EST_CTRL3 */
-	apb_write_reg(2, 0x6d, 0x0030303f);     /* SET SNR THRESHOLD */
-	apb_write_reg(2, 0x73, 0xffffffff);     /* CCI0_PILOT_UPDATE_CTRL */
-	apb_write_reg(2, 0x74, 0xffffffff);     /* CCI0_DATA_UPDATE_CTRL */
-	apb_write_reg(2, 0x75, 0xffffffff);     /* CCI1_PILOT_UPDATE_CTRL */
-	apb_write_reg(2, 0x76, 0xffffffff);     /* CCI1_DATA_UPDATE_CTRL */
-
-	/* Set ACF and ACFEQ coeffecient */
-	switch (sr) {
-	case 0:
-		set_ACF_coef(21, bw);
-		break;
-	case 1:
-		set_ACF_coef(21, bw);
-		break;
-	case 2:
-		set_ACF_coef(28, bw);
-		break;
-	case 3:
-		set_ACF_coef(45, bw);
-		break;
-	default:
-		break;
-	}
-
-	apb_write_reg(2, 0x78, 0x000001a2);
-	/* FEC_CTRL  parallel mode ; [27:24] is TS clk/valid/sync/error */
-	apb_write_reg(2, 0x7d, 0x0000009d);
-	apb_write_reg(2, 0xd6, 0x00000003);
-	apb_write_reg(2, 0xd7, 0x00000008);
-	apb_write_reg(2, 0xd8, 0x00000120);
-	apb_write_reg(2, 0xd9, 0x01010101);
-	apb_write_reg(2, 0x04, 0x00000000);
-	/* TPS Current, QPSK, none Hierarchy, HP, LP 1/2 */
-
-	tmp = (1 << 25) | ((bw & 3) << 20) | (1 << 16) | (1 << 1);
-	apb_write_reg(2, 0x02, tmp);
-	apb_write_reg(2, 0x03, (1 << 6));       /* Cordic parameter Calc */
-
-	udelay(1);
-
-	tmp = apb_read_reg(2, 0x02);
-	tmp |= (1 << 24) | 1;   /* FSM, Demod enable. */
-	apb_write_reg(2, 0x02, tmp);
-}
-
-int dvbt_set_ch(struct aml_demod_sta *demod_sta,
-		struct aml_demod_i2c *demod_i2c,
-		struct aml_demod_dvbt *demod_dvbt)
-{
-	int ret = 0;
-	u8 bw, sr, ifreq, agc_mode;
-	u32 ch_freq;
-
-	bw = demod_dvbt->bw;
-	sr = demod_dvbt->sr;
-	ifreq = demod_dvbt->ifreq;
-	agc_mode = demod_dvbt->agc_mode;
-	ch_freq = demod_dvbt->ch_freq;
-
-	/* Set registers */
-	/*//////////////////////////////////// */
-	/* bw == 0 : 8M */
-	/*       1 : 7M */
-	/*       2 : 6M */
-	/*       3 : 5M */
-	/* sr == 0 : 20.7M */
-	/*       1 : 20.8333M */
-	/*       2 : 28.5714M */
-	/*       3 : 45M */
-	/* ifreq == 0: 36.13MHz */
-	/*          1: 4.57MHz */
-	/* agc_mode == 0: single AGC */
-	/*             1: dual AGC */
-	/*//////////////////////////////////// */
-	if (bw > 3) {
-		dprintk("Error: Invalid Bandwidth option %d\n", bw);
-		bw = 0;
-		ret = -1;
-	}
-
-	if (sr > 3) {
-		dprintk("Error: Invalid Sampling Freq option %d\n", sr);
-		sr = 2;
-		ret = -1;
-	}
-
-	if (ifreq > 1) {
-		dprintk("Error: Invalid IFreq option %d\n", ifreq);
-		ifreq = 0;
-		ret = -1;
-	}
-
-	if (agc_mode > 3) {
-		dprintk("Error: Invalid AGC mode option %d\n", agc_mode);
-		agc_mode = 0;
-		ret = -1;
-	}
-	/* if (ret != 0) return ret; */
-
-	/* Set DVB-T */
-	(*DEMOD_REG0) |= 1;
-
-	demod_sta->dvb_mode = 1;
-	demod_sta->ch_mode = 0; /* TODO */
-	demod_sta->agc_mode = agc_mode;
-	demod_sta->ch_freq = ch_freq;
-	if (demod_i2c->tuner == 1)
-		demod_sta->ch_if = 36130;
-	else if (demod_i2c->tuner == 2)
-		demod_sta->ch_if = 4570;
-
-	demod_sta->ch_bw = (8 - bw) * 1000;
-	demod_sta->symb_rate = 0;       /* TODO */
-
-	/* Set Tuner */
-	if (ch_freq < 1000 || ch_freq > 900000) {
-		dprintk
-		(
-			"Error: Invalid Channel Freq option %d, Skip Set tuner\n",
-			ch_freq);
-		/*ch_freq = 474000; */
-		ret = -1;
-	} else {
-		/*  tuner_set_ch(demod_sta, demod_i2c); */
-	}
-
-	if ((ch_freq % 100) == 2)
-		dprintk("Input frequency is XXX002, Skip initial demod\n");
-	else
-		dvbt_reg_initial(demod_sta);
-
-	dvbt_enable_irq(7);     /* open symbolhead int */
-
-	tuner_type = demod_i2c->tuner;
-
-	return ret;
-}
-
-static int dvbt_get_ch_power(struct aml_demod_sta *demod_sta,
-			     struct aml_demod_i2c *demod_i2c)
-{
-	u32 ad_power;
-
-	ad_power =
-		agc_power_to_dbm((apb_read_reg(2, 0x1c) & 0x7ff),
-				 apb_read_reg(2, 0x1b) & 0x1ff, 0,
-				 demod_i2c->tuner);
-	return ad_power;
-}
-
-int dvbt_sfo(void)
-{
-	int sfo;
-
-	sfo = apb_read_reg(2, 0x47) & 0xfff;
-	sfo = (sfo > 0x7ff) ? (sfo - 0x1000) : sfo;
-	return sfo;
-}
-
-int dvbt_fcfo(void)
-{
-	int fcfo;
-
-	fcfo = (apb_read_reg(2, 0x26)) & 0xffffff;
-	fcfo = (fcfo > 0x7fffff) ? (fcfo - 0x1000000) : fcfo;
-	return fcfo;
-}
-
-static int dvbt_total_packet_error(void)
-{
-	return apb_read_reg(2, 0xbf);
-}
-
-static int dvbt_super_frame_counter(void)
-{
-	return apb_read_reg(2, 0xc0) & 0xfffff;
-}
-
-static int dvbt_packet_correct_in_sframe(void)
-{
-	return apb_read_reg(2, 0xc1) & 0xfffff;
-}
-
-/*static int dvbt_resync_counter(void)
- * {return((apb_read_reg(2, 0xc0)>>20)&0xff);}*/
-static int dvbt_packets_per_sframe(void)
-{
-	u32 tmp;
-	int hier_mode;
-	int constel;
-	int hp_code_rate;
-	int lp_code_rate;
-	int hier_sel;
-	int code_rate;
-	int ret;
-
-	tmp = apb_read_reg(2, 0x06);
-	constel = tmp >> 13 & 3;
-	hier_mode = tmp >> 10 & 7;
-	hp_code_rate = tmp >> 7 & 7;
-	lp_code_rate = tmp >> 4 & 7;
-
-	if (hier_mode == 0) {
-		code_rate = hp_code_rate;
-	} else {
-		tmp = apb_read_reg(2, 0x78);
-		hier_sel = tmp >> 9 & 1;
-		if (hier_sel == 0) {
-			constel = 0;    /* QPSK; */
-			code_rate = hp_code_rate;
-		} else {
-			constel = constel == 2 ? 1 : 0;
-			code_rate = lp_code_rate;
-		}
-	}
-
-	switch (code_rate) {
-	case 0:
-		ret = (constel == 0) ? 1008 : (constel == 1) ? 2016 : 3024;
-		break;
-	case 1:
-		ret = (constel == 0) ? 1344 : (constel == 1) ? 2688 : 4032;
-		break;
-	case 2:
-		ret = (constel == 0) ? 1512 : (constel == 1) ? 3024 : 4536;
-		break;
-	case 3:
-		ret = (constel == 0) ? 1680 : (constel == 1) ? 3360 : 5040;
-		break;
-	case 4:
-		ret = (constel == 0) ? 1764 : (constel == 1) ? 3528 : 5292;
-		break;
-	default:
-		ret = (constel == 0) ? 1008 : (constel == 1) ? 2016 : 3024;
-		break;
-	}
-	return ret;
-}
-
-static int dvbt_get_per(void)
-{
-	int packets_per_sframe;
-	int error;
-	int per;
-
-	packets_per_sframe = dvbt_packets_per_sframe();
-	error = packets_per_sframe - dvbt_packet_correct_in_sframe();
-	per = 1000 * error / packets_per_sframe;
-
-	return per;
-}
-
-static void dvbt_set_test_bus(u8 sel)
-{
-	u32 tmp;
-
-	tmp = apb_read_reg(2, 0x7f);
-	tmp &= ~(0x1f);
-	tmp |= ((1 << 15) | (1 << 5) | (sel & 0x1f));
-	apb_write_reg(2, 0x7f, tmp);
-}
-
-/*
- * void dvbt_get_test_out(u8 sel, u32 len, u32 *buf)
- * {
- *  int i;
- *
- *  dvbt_set_test_bus(sel);
- *
- *  for (i=0; i<len; i++) {
- *      buf[i] = apb_read_reg(2, 0x13);
- *  }
- * }
- */
-void dvbt_get_test_out(u8 sel, u32 len, u32 *buf)
-{
-	int i, cnt;
-
-	dvbt_set_test_bus(sel);
-
-	for (i = 0, cnt = 0; i < len - 4 && cnt < 1000000; i++) {
-		buf[i] = apb_read_reg(2, 0x13);
-		if ((buf[i] >> 10) & 0x1) {
-			buf[i++] = apb_read_reg(2, 0x13);
-			buf[i++] = apb_read_reg(2, 0x13);
-			buf[i++] = apb_read_reg(2, 0x13);
-			buf[i++] = apb_read_reg(2, 0x13);
-			buf[i++] = apb_read_reg(2, 0x13);
-			buf[i++] = apb_read_reg(2, 0x13);
-			buf[i++] = apb_read_reg(2, 0x13);
-			buf[i++] = apb_read_reg(2, 0x13);
-		} else {
-			i--;
-		}
-
-		cnt++;
-	}
-}
-
-static int dvbt_get_avg_per(void)
-{
-	int packets_per_sframe;
-	static int err_last;
-	static int err_now;
-	static int rsnum_now;
-	static int rsnum_last;
-	int per;
-
-	packets_per_sframe = dvbt_packets_per_sframe();
-	rsnum_last = rsnum_now;
-	rsnum_now = dvbt_super_frame_counter();
-	err_last = err_now;
-	err_now = dvbt_total_packet_error();
-	if (rsnum_now != rsnum_last)
-		per = 1000 * (err_now - err_last) /
-		      ((rsnum_now - rsnum_last) * packets_per_sframe);
-	else
-		per = 123;
-
-	return per;
-}
-
-int dvbt_status(struct aml_demod_sta *demod_sta,
-		struct aml_demod_i2c *demod_i2c,
-		struct aml_demod_sts *demod_sts)
-{
-	/* if parameters are needed to calc, pass the struct to func. */
-	/* all small funcs like read_snr() should be static. */
-
-	demod_sts->ch_snr = apb_read_reg(2, 0x0a);
-	demod_sts->ch_per = dvbt_get_per();
-	demod_sts->ch_pow = dvbt_get_ch_power(demod_sta, demod_i2c);
-	demod_sts->ch_ber = apb_read_reg(2, 0x0b);
-	demod_sts->ch_sts = apb_read_reg(2, 0);
-	demod_sts->dat0 = dvbt_get_avg_per();
-	demod_sts->dat1 = apb_read_reg(2, 0x06);
-	return 0;
-}
-
-static int dvbt_get_status(struct aml_demod_sta *demod_sta,
-			   struct aml_demod_i2c *demod_i2c)
-{
-	return apb_read_reg(2, 0x0) >> 12 & 1;
-}
-
-static int dvbt_ber(void);
-
-static int dvbt_get_ber(struct aml_demod_sta *demod_sta,
-			struct aml_demod_i2c *demod_i2c)
-{
-	return dvbt_ber();      /*unit: 1e-7 */
-}
-
-static int dvbt_get_snr(struct aml_demod_sta *demod_sta,
-			struct aml_demod_i2c *demod_i2c)
-{
-	return apb_read_reg(2, 0x0a) & 0x3ff;   /*dBm: bit0~bit2=decimal */
-}
-
-static int dvbt_get_strength(struct aml_demod_sta *demod_sta,
-			     struct aml_demod_i2c *demod_i2c)
-{
-	int dbm = dvbt_get_ch_power(demod_sta, demod_i2c);
-
-	return dbm;
-}
-
-static int dvbt_get_ucblocks(struct aml_demod_sta *demod_sta,
-			     struct aml_demod_i2c *demod_i2c)
-{
-	return dvbt_get_per();
-}
-
-struct demod_status_ops *dvbt_get_status_ops(void)
-{
-	static struct demod_status_ops ops = {
-		.get_status	= dvbt_get_status,
-		.get_ber	= dvbt_get_ber,
-		.get_snr	= dvbt_get_snr,
-		.get_strength	= dvbt_get_strength,
-		.get_ucblocks	= dvbt_get_ucblocks,
-	};
-
-	return &ops;
-}
-
-void dvbt_enable_irq(int dvbt_irq)
-{
-	/* clear status & enable irq */
-	(*OFDM_INT_STS) &= ~(1 << dvbt_irq);
-	(*OFDM_INT_EN) |= (1 << dvbt_irq);
-}
-
-void dvbt_disable_irq(int dvbt_irq)
-{
-	/* disable irq & clear status */
-	(*OFDM_INT_EN) &= ~(1 << dvbt_irq);
-	(*OFDM_INT_STS) &= ~(1 << dvbt_irq);
-}
-
-char *dvbt_irq_name[] = {
-	"PFS_FCFO",
-	"PFS_ICFO",
-	" CS_FCFO",
-	" PFS_SFO",
-	" PFS_TPS",
-	"      SP",
-	"     CCI",
-	"  Symbol",
-	" In_Sync",
-	"Out_Sync",
-	"FSM Stat"
-};
-
-void dvbt_isr(struct aml_demod_sta *demod_sta)
-{
-	u32 stat, mask;
-	int dvbt_irq;
-
-	stat = (*OFDM_INT_STS);
-	mask = (*OFDM_INT_EN);
-	stat &= mask;
-
-	for (dvbt_irq = 0; dvbt_irq < 11; dvbt_irq++) {
-		if (stat >> dvbt_irq & 1) {
-			if (demod_sta->debug)
-				dprintk("irq: aml_demod dvbt %2d %s %8x %8x\n",
-					dvbt_irq, dvbt_irq_name[dvbt_irq], stat,
-					mask);
-			/* dvbt_disable_irq(dvbt_irq); */
-		}
-	}
-	/* clear status */
-	(*OFDM_INT_STS) = 0;
-}
-
-static int demod_monitor_ave(void);
-int dvbt_isr_islock(void)
-{
-#define IN_SYNC_MASK (0x100)
-
-	u32 stat, mask;
-
-	stat = (*OFDM_INT_STS);
-	*OFDM_INT_STS = stat & (~IN_SYNC_MASK);
-
-	mask = (*OFDM_INT_EN);
-	stat &= mask;
-
-	return (stat & IN_SYNC_MASK) == IN_SYNC_MASK;
-}
-
-int dvbt_isr_monitor(void)
-{
-#define SYM_HEAD_MASK (0x80)
-	u32 stat, mask;
-
-	stat = (*OFDM_INT_STS);
-	*OFDM_INT_STS = stat & (~SYM_HEAD_MASK);
-
-	mask = (*OFDM_INT_EN);
-	stat &= mask;
-	/* symbol_head int */
-	if ((stat & SYM_HEAD_MASK) == SYM_HEAD_MASK)
-		demod_monitor_ave();
-	return 0;
-}
-
-int dvbt_isr_cancel(void)
-{
-	*OFDM_INT_STS = 0;
-	*OFDM_INT_EN = 0;
-	return 0;
-}
-
-static int demod_monitor_instant(void)
-{
-	int SNR;
-	int SNR_SP = 500;
-	int SNR_TPS = 0;
-	int SNR_CP = 0;
-	int SFO_residual = 0;
-	int SFO_esti = 0;
-	int FCFO_esti = 0;
-	int FCFO_residual = 0;
-	int AGC_Gain = 0;
-	int be_vit_error = 0;
-	int Signal_power = 0;
-	int FECFlag = 0;
-	int EQ_seg_ratio = 0;
-	int tps_0 = 0;
-	int tps_1 = 0;
-	int tps_2 = 0;
-	int cci_blank = 0;
-
-	int SFO;
-	int FCFO;
-	int timing_adj;
-	int RS_CorrectNum;
-	int RS_Error_sum;
-	int resync_times;
-	int tps_summary;
-
-	int tps_window;
-	int tps_guard;
-	int tps_constell;
-	int tps_Hier_none;
-	int tps_Hier_alpha;
-	int tps_HP_cr;
-	int tps_LP_cr;
-
-	int tmpAGCGain;
-
-	/* Read Registers */
-	SNR = apb_read_reg(2, 0x0a);
-	FECFlag = (apb_read_reg(2, 0x00) >> 11) & 0x3;
-	SFO = apb_read_reg(2, 0x47) & 0xfff;
-	SFO_esti = apb_read_reg(2, 0x60) & 0xfff;
-	FCFO_esti = (apb_read_reg(2, 0x60) >> 11) & 0xfff;
-	FCFO = (apb_read_reg(2, 0x26)) & 0xffffff;
-	be_vit_error = apb_read_reg(2, 0x0c) & 0x1fff;
-	timing_adj = apb_read_reg(2, 0x6f) & 0x1fff;
-	RS_CorrectNum = apb_read_reg(2, 0xc1) & 0xfffff;
-	Signal_power = (apb_read_reg(2, 0x1b)) & 0x1ff;
-	EQ_seg_ratio = apb_read_reg(2, 0x6e) & 0x3ffff;
-	tps_0 = apb_read_reg(2, 0x64);
-	tps_1 = apb_read_reg(2, 0x65);
-	tps_2 = apb_read_reg(2, 0x66) & 0xf;
-	tps_summary = apb_read_reg(2, 0x04) & 0x7fff;
-	cci_blank = (apb_read_reg(2, 0x66) >> 16);
-	RS_Error_sum = apb_read_reg(2, 0xbf) & 0x3ffff;
-	resync_times = (apb_read_reg(2, 0xc0) >> 20) & 0xff;
-	AGC_Gain = apb_read_reg(2, 0x1c) & 0x7ff;
-
-	/* Calc */
-	SFO_residual = (SFO > 0x7ff) ? (SFO - 0x1000) : SFO;
-	FCFO_residual = (FCFO > 0x7fffff) ? (FCFO - 0x1000000) : FCFO;
-	FCFO_esti = (FCFO_esti > 0x7ff) ? (FCFO_esti - 0x1000) : FCFO_esti;
-	SNR_CP = (SNR) & 0x3ff;
-	SNR_TPS = (SNR >> 10) & 0x3ff;
-	SNR_SP = (SNR >> 20) & 0x3ff;
-	SNR_SP = (SNR_SP > 0x1ff) ? SNR_SP - 0x400 : SNR_SP;
-	SNR_TPS = (SNR_TPS > 0x1ff) ? SNR_TPS - 0x400 : SNR_TPS;
-	SNR_CP = (SNR_CP > 0x1ff) ? SNR_CP - 0x400 : SNR_CP;
-	tmpAGCGain = AGC_Gain;
-	timing_adj = (timing_adj > 0xfff) ? timing_adj - 0x2000 : timing_adj;
-
-	tps_window = (tps_summary & 0x3);
-	tps_guard = ((tps_summary >> 2) & 0x3);
-	tps_constell = ((tps_summary >> 13) & 0x3);
-	tps_Hier_none = (((tps_summary >> 10) & 0x7) == 0) ? 1 : 0;
-	tps_Hier_alpha = (tps_summary >> 11) & 0x3;
-	tps_Hier_alpha = (tps_Hier_alpha == 3) ? 4 : tps_Hier_alpha;
-	tps_LP_cr = (tps_summary >> 4) & 0x7;
-	tps_HP_cr = (tps_summary >> 7) & 0x7;
-
-	dprintk("\n\n");
-	switch (tps_window) {
-	case 0:
-		dprintk("2K ");
-		break;
-	case 1:
-		dprintk("8K ");
-		break;
-	case 2:
-		dprintk("4K ");
-		break;
-	default:
-		dprintk("UnWin ");
-		break;
-	}
-	switch (tps_guard) {
-	case 0:
-		dprintk("1/32 ");
-		break;
-	case 1:
-		dprintk("1/16 ");
-		break;
-	case 2:
-		dprintk("1/ 8 ");
-		break;
-	case 3:
-		dprintk("1/ 4 ");
-		break;
-	default:
-		dprintk("UnGuard ");
-		break;
-	}
-	switch (tps_constell) {
-	case 0:
-		dprintk(" QPSK ");
-		break;
-	case 1:
-		dprintk("16QAM ");
-		break;
-	case 2:
-		dprintk("64QAM ");
-		break;
-	default:
-		dprintk("UnConstl ");
-		break;
-	}
-	switch (tps_Hier_none) {
-	case 0:
-		dprintk("Hiera ");
-		break;
-	case 1:
-		dprintk("non-H ");
-		break;
-	default:
-		dprintk("UnHier ");
-		break;
-	}
-	dprintk("%d ", tps_Hier_alpha);
-	dprintk("HP ");
-	switch (tps_HP_cr) {
-	case 0:
-		dprintk("1/2 ");
-		break;
-	case 1:
-		dprintk("2/3 ");
-		break;
-	case 2:
-		dprintk("3/4 ");
-		break;
-	case 3:
-		dprintk("5/6 ");
-		break;
-	case 4:
-		dprintk("7/8 ");
-		break;
-	default:
-		dprintk("UnHCr ");
-		break;
-	}
-	dprintk("LP ");
-	switch (tps_LP_cr) {
-	case 0:
-		dprintk("1/2 ");
-		break;
-	case 1:
-		dprintk("2/3 ");
-		break;
-	case 2:
-		dprintk("3/4 ");
-		break;
-	case 3:
-		dprintk("5/6 ");
-		break;
-	case 4:
-		dprintk("7/8 ");
-		break;
-	default:
-		dprintk("UnLCr ");
-		break;
-	}
-	dprintk("\n");
-	dprintk("P %4x ", RS_Error_sum);
-	dprintk("SP %2d ", SNR_SP);
-	dprintk("TPS %2d ", SNR_TPS);
-	dprintk("CP %2d ", SNR_CP);
-	dprintk("EQS %2x ", EQ_seg_ratio);
-	dprintk("RSC %4d ", RS_CorrectNum);
-	dprintk("SFO %3d ", SFO_residual);
-	dprintk("FCFO %4d ", FCFO_residual);
-	dprintk("Vit %3x ", be_vit_error);
-	dprintk("Timing %3d ", timing_adj);
-	dprintk("SigP %3x ", Signal_power);
-	dprintk("AGC %d ", tmpAGCGain);
-	dprintk("SigP %d ",
-		agc_power_to_dbm(tmpAGCGain, Signal_power, 0, tuner_type));
-	dprintk("FEC %x ", FECFlag);
-	dprintk("ReSyn %x ", resync_times);
-	dprintk("cciB %x", cci_blank);
-
-	dprintk("\n");
-
-	return 0;
-}
-
-int serial_div(int a, int b)
-{
-	int c;
-	int cnt;
-	int b_buf;
-
-	if (b == 0)
-		return 0x7fffffff;
-	if (a == 0)
-		return 0;
-
-	c = 0;
-	cnt = 0;
-
-	a = (a < 0) ? -1 * a : a;
-	b = (b < 0) ? -1 * b : b;
-
-	b_buf = b;
-
-	while (a >= b) {
-		b = b << 1;
-		cnt++;
-	}
-	while (b > b_buf) {
-		b = b >> 1;
-		c = c << 1;
-		if (a > b) {
-			c = c + 1;
-			a = a - b;
-		}
-	}
-	return c;
-}
-
-static int ave0, bit_unit_L;
-
-static int dvbt_ber(void)
-{
-	int BER_e_n7 = serial_div(ave0 * 40, bit_unit_L);
-
-	return BER_e_n7;
-}
-
-static int demod_monitor_ave(void)
-{
-	static int i;
-	static int ave[3] = { 0, 0, 0 };
-
-	ave[0] = ave[0] + (apb_read_reg(2, 0x0b) & 0x7ff);
-	ave[1] = ave[1] + (apb_read_reg(2, 0x0a) & 0x3ff);
-	ave[2] = ave[2] + (apb_read_reg(2, 0x0c) & 0x1fff);
-
-	i++;
-
-	if (i >= 8192) {
-		int tps_mode;
-		int tps_constell;
-		int r_t;
-		int mode_L;
-		int const_L;
-		int SNR_Int;
-		int SNR_fra;
-
-		if (debug_amldvbt)
-			demod_monitor_instant();
-
-		r_t = apb_read_reg(2, 0x04);
-		tps_mode = r_t & 0x3;
-		tps_constell = (r_t >> 13) & 0x3;
-		mode_L = (tps_mode == 0) ? 1 : (tps_mode == 1) ? 4 : 2;
-		const_L = (tps_constell == 0) ? 2 : (tps_constell == 1) ? 4 : 6;
-		bit_unit_L = 189 * mode_L * const_L;
-		SNR_Int = (ave[1] >> 16);
-		switch ((ave[1] >> 13) & 0x7) {
-		case 0:
-			SNR_fra = 0;
-			break;
-		case 1:
-			SNR_fra = 125;
-			break;
-		case 2:
-			SNR_fra = 250;
-			break;
-		case 3:
-			SNR_fra = 375;
-			break;
-		case 4:
-			SNR_fra = 500;
-			break;
-		case 5:
-			SNR_fra = 625;
-			break;
-		case 6:
-			SNR_fra = 750;
-			break;
-		case 7:
-			SNR_fra = 875;
-			break;
-		default:
-			SNR_fra = 0;
-			break;
-		}
-
-		ave0 = ave[0];
-
-		if (debug_amldvbt)
-			dprintk("RSBi %d Thresh %d SNR %d.%d Vit %x\n\n",
-				(ave[0] >> 3) * 5, (bit_unit_L * 8), SNR_Int,
-				SNR_fra, (ave[2] >> 13));
-		i = 0;
-		ave[0] = ave[1] = ave[2] = 0;
-	}
-
-	return i;
-}
-
-int dvbt_switch_to_HP(void)
-{
-	apb_write_reg(2, 0x78, apb_read_reg(2, 0x78) & ~(1 << 9));
-	return 0;
-}
-
-int dvbt_switch_to_LP(void)
-{
-	apb_write_reg(2, 0x78, apb_read_reg(2, 0x78) | (1 << 9));
-	return 0;
-}
-
-int dvbt_shutdown(void)
-{
-	apb_write_reg(2, 0x02, 0x00800000);
-	/* SW reset bit[23] ; write anything to zero */
-	apb_write_reg(2, 0x00, 0x00000000);
-	return 0;
-}
-
-int dvbt_get_params(struct aml_demod_sta *demod_sta,
-		    struct aml_demod_i2c *adap, int *code_rate_HP,
-		    /* high priority stream code rate */
-			int *code_rate_LP,  /* low priority stream code rate */
-			int *constellation, /* modulation type (see above) */
-			int *transmission_mode,
-			int *guard_interval, int *hierarchy_information)
-{
-	int tps_summary, tps_window, tps_guard, tps_constell, tps_Hier_none;
-	int tps_Hier_alpha, tps_LP_cr, tps_HP_cr;
-	tps_summary = apb_read_reg(2, 0x04) & 0x7fff;
-	tps_window = (tps_summary & 0x3);
-	tps_guard = ((tps_summary >> 2) & 0x3);
-	tps_constell = ((tps_summary >> 13) & 0x3);
-	tps_Hier_none = (((tps_summary >> 10) & 0x7) == 0) ? 1 : 0;
-	tps_Hier_alpha = (tps_summary >> 11) & 0x3;
-	tps_Hier_alpha = (tps_Hier_alpha == 3) ? 4 : tps_Hier_alpha;
-	tps_LP_cr = (tps_summary >> 4) & 0x7;
-	tps_HP_cr = (tps_summary >> 7) & 0x7;
-	if (code_rate_HP)
-		*code_rate_HP = tps_HP_cr;	/*1/2:2/3:3/4:5/6:7/8 */
-	if (code_rate_LP)
-		*code_rate_LP = tps_LP_cr;	/*1/2:2/3:3/4:5/6:7/8 */
-	if (constellation)
-		*constellation = tps_constell;	/*QPSK/16QAM/64QAM */
-	if (transmission_mode)
-		*transmission_mode = tps_window;	/*2K/8K/4K */
-	if (guard_interval)
-		*guard_interval = tps_guard;	/*1/32:1/16:1/8:1/4 */
-	if (hierarchy_information)
-		*hierarchy_information = tps_Hier_alpha;	/*1/2/4 */
-	return 0;
-}
diff --git a/drivers/amlogic/dvb_tv/amldemod/i2c_func.c b/drivers/amlogic/dvb_tv/amldemod/i2c_func.c
deleted file mode 100644
index b00d14b787fe..000000000000
--- a/drivers/amlogic/dvb_tv/amldemod/i2c_func.c
+++ /dev/null
@@ -1,22 +0,0 @@
-#include <linux/kernel.h>
-#include <linux/i2c.h>
-#include <linux/delay.h>
-#include <linux/dvb/aml_demod.h>
-#include "demod_func.h"
-
-int am_demod_i2c_xfer(struct aml_demod_i2c *adap, struct i2c_msg msgs[],
-		      int num)
-{
-	int ret = 0;
-	if (adap->scl_oe) {
-		/*      ret = aml_i2c_sw_bit_xfer(adap, msgs, num);*/
-	} else {
-		if (adap->i2c_priv)
-			ret = i2c_transfer((struct i2c_adapter *)adap->i2c_priv,
-					   msgs, num);
-		else
-			;
-		/*	printk("i2c error, no valid i2c\n");*/
-	}
-	return ret;
-}
diff --git a/drivers/amlogic/dvb_tv/amldemod/include/acf_filter_coefficient.h b/drivers/amlogic/dvb_tv/amldemod/include/acf_filter_coefficient.h
deleted file mode 100644
index b1437a2cdab2..000000000000
--- a/drivers/amlogic/dvb_tv/amldemod/include/acf_filter_coefficient.h
+++ /dev/null
@@ -1,395 +0,0 @@
-void program_acf(int acf1[20], int acf2[33])
-{
-	int i;
-
-	for (i = 0; i < 20; i++)
-		apb_write_reg(DVBT_BASE + (0x2c + i) * 4, acf1[i]);
-	for (i = 0; i < 33; i++) {
-		apb_write_reg(DVBT_BASE + 0xfe * 4, i);
-		apb_write_reg(DVBT_BASE + 0xff * 4, acf2[i]);
-	}
-}
-
-void ini_acf_iireq_src_45m_8m(void)
-{
-	int acf1[] = { 0x294, 0x085, 0x076, 0x01e,
-		0x27c, 0x0af, 0x2bf, 0x06d,
-		0x265, 0x0d8, 0x270, 0x05e,
-		0x257, 0x0ef, 0x25b, 0x04b,
-		0x24f, 0x0fc, 0x254, 0x04d
-	};
-	int acf2[] = { 0x3f3fff, 0x3da7cd, 0x3c0f9b, 0x3a7768, 0x38df35,
-		0x373f01,
-		0x3596cd, 0x33ee98, 0x323e62, 0x307e2b, 0x2eb5f3,
-		0x2ce5b9,
-		0x2b057e, 0x290d41, 0x26fd00, 0x24dcbd, 0x229477,
-		0x202c2c,
-		0x1d93dc, 0x1ac386, 0x17b328, 0x144ac1, 0x106a4d,
-		0x0be1c8,
-		0x07e129, 0x04d0cc, 0x015064, 0x3d47ec, 0x38675e,
-		0x326eb1,
-		0x326e4d, 0x326e4d, 0x00064d
-	};
-
-	program_acf(acf1, acf2);
-}
-
-void ini_acf_iireq_src_45m_7m(void)
-{
-	int acf1[] = { 0x283, 0x091, 0x02f, 0x01e,
-		0x26a, 0x0b8, 0x296, 0x06d,
-		0x253, 0x0dc, 0x257, 0x05e,
-		0x245, 0x0f1, 0x246, 0x04b,
-		0x23d, 0x0fc, 0x241, 0x04d
-	};
-	int acf2[] = { 0x3f3fff, 0x3dafce, 0x3c1f9c, 0x3a8769, 0x38ef37,
-		0x374f03,
-		0x35aecf, 0x34069b, 0x325665, 0x30962e, 0x2ecdf6,
-		0x2cfdbc,
-		0x2b1581, 0x291d43, 0x271503, 0x24e4bf, 0x229c78,
-		0x202c2d,
-		0x1d8bdc, 0x1ab384, 0x179325, 0x141abc, 0x102a46,
-		0x0b81be,
-		0x07711c, 0x0448bd, 0x00b052, 0x3c7fd6, 0x374740,
-		0x308684,
-		0x308610, 0x308610, 0x000610
-	};
-
-	program_acf(acf1, acf2);
-}
-
-void ini_acf_iireq_src_45m_6m(void)
-{
-	int acf1[] = { 0x272, 0x09e, 0x3dc, 0x01e,
-		0x259, 0x0c0, 0x272, 0x06d,
-		0x242, 0x0e1, 0x240, 0x05e,
-		0x235, 0x0f3, 0x234, 0x04b,
-		0x22e, 0x0fd, 0x230, 0x04d
-	};
-	int acf2[] = { 0x3f47ff, 0x3dbfcf, 0x3c379e, 0x3aa76d, 0x391f3c,
-		0x378709,
-		0x35e6d6, 0x343ea2, 0x328e6d, 0x30d636, 0x2f0dfe,
-		0x2d35c4,
-		0x2b4d88, 0x294d49, 0x273d08, 0x2504c4, 0x22b47c,
-		0x203c2f,
-		0x1d9bde, 0x1ac386, 0x17a327, 0x1432bf, 0x104249,
-		0x0ba9c2,
-		0x07a922, 0x0490c5, 0x01185c, 0x3d0fe5, 0x383f58,
-		0x3286af,
-		0x328650, 0x328650, 0x000650
-	};
-
-	program_acf(acf1, acf2);
-}
-
-void ini_acf_iireq_src_45m_5m(void)
-{
-	int acf1[] = { 0x260, 0x0ab, 0x37e, 0x02e,
-		0x249, 0x0ca, 0x251, 0x06d,
-		0x233, 0x0e6, 0x22d, 0x05e,
-		0x227, 0x0f5, 0x224, 0x04b,
-		0x220, 0x0fd, 0x221, 0x04d
-	};
-	int acf2[] = { 0x3f3fff, 0x3db7cf, 0x3c279d, 0x3a9f6c, 0x39073a,
-		0x377707,
-		0x35d6d4, 0x3436a0, 0x328e6b, 0x30d636, 0x2f15ff,
-		0x2d4dc6,
-		0x2b758c, 0x29854f, 0x278511, 0x256ccf, 0x232c89,
-		0x20cc3f,
-		0x1e33f0, 0x1b6b9b, 0x185b3d, 0x14e2d5, 0x10f260,
-		0x0c51d7,
-		0x082934, 0x04f8d4, 0x014066, 0x3ccfe4, 0x372f46,
-		0x2f5673,
-		0x2f55ea, 0x2f55ea, 0x0005ea
-	};
-
-	program_acf(acf1, acf2);
-}
-
-void ini_acf_iireq_src_2857m_8m(void)
-{
-	int acf1[] = { 0x2df, 0x059, 0x144, 0x00e,
-		0x2d3, 0x08f, 0x38d, 0x06f,
-		0x2c6, 0x0c5, 0x302, 0x05e,
-		0x2be, 0x0e7, 0x2d6, 0x04b,
-		0x2b7, 0x0f9, 0x2c8, 0x04d
-	};
-	int acf2[] = { 0x3f3fff, 0x3dbfcf, 0x3c379e, 0x3aaf6d, 0x391f3c,
-		0x37870a,
-		0x35eed7, 0x344ea3, 0x32a66f, 0x30f639, 0x2f3602,
-		0x2d65c9,
-		0x2b858e, 0x299552, 0x278d12, 0x2564cf, 0x231c88,
-		0x20b43d,
-		0x1e13ec, 0x1b3395, 0x181336, 0x1492cc, 0x109254,
-		0x0be1cb,
-		0x07c127, 0x0498c7, 0x00f85b, 0x3cbfde, 0x377747,
-		0x309e88,
-		0x309e13, 0x309e13, 0x000613
-	};
-
-	program_acf(acf1, acf2);
-}
-
-void ini_acf_iireq_src_2857m_7m(void)
-{
-	int acf1[] = { 0x2c6, 0x067, 0x10f, 0x01e,
-		0x2b4, 0x099, 0x344, 0x06f,
-		0x2a2, 0x0cb, 0x2cb, 0x05e,
-		0x297, 0x0ea, 0x2a7, 0x04b,
-		0x28f, 0x0fa, 0x29c, 0x04d
-	};
-	int acf2[] = { 0x3f3fff, 0x3dbfcf, 0x3c379e, 0x3aa76d, 0x39173b,
-		0x378709,
-		0x35e6d6, 0x3446a2, 0x329e6d, 0x30e637, 0x2f2600,
-		0x2d4dc7,
-		0x2b6d8c, 0x297d4e, 0x276d0e, 0x2544cb, 0x22fc84,
-		0x208438,
-		0x1de3e7, 0x1b0b90, 0x17eb30, 0x146ac7, 0x107250,
-		0x0bc9c6,
-		0x07b124, 0x0490c5, 0x00f85b, 0x3cc7df, 0x37974a,
-		0x30ce8d,
-		0x30ce19, 0x30ce19, 0x000619
-	};
-
-	program_acf(acf1, acf2);
-}
-
-void ini_acf_iireq_src_2857m_6m(void)
-{
-	int acf1[] = { 0x2ac, 0x076, 0x0c9, 0x01e,
-		0x297, 0x0a4, 0x2fd, 0x06d,
-		0x281, 0x0d2, 0x299, 0x05e,
-		0x274, 0x0ed, 0x27d, 0x04b,
-		0x26c, 0x0fb, 0x274, 0x04d
-	};
-	int acf2[] = { 0x3f3fff, 0x3db7cf, 0x3c279d, 0x3a976b, 0x390739,
-		0x376f07,
-		0x35ced3, 0x342e9f, 0x327e6a, 0x30c634, 0x2f05fc,
-		0x2d35c4,
-		0x2b5d89, 0x29654c, 0x275d0c, 0x253cca, 0x22fc83,
-		0x209439,
-		0x1dfbe9, 0x1b2b93, 0x181b35, 0x14b2ce, 0x10ca5a,
-		0x0c41d4,
-		0x084935, 0x0538d9, 0x01c071, 0x3db7fa, 0x38bf6b,
-		0x327eb9,
-		0x327e4f, 0x327e4f, 0x00064f
-	};
-
-	program_acf(acf1, acf2);
-}
-
-void ini_acf_iireq_src_2857m_5m(void)
-{
-	int acf1[] = { 0x292, 0x087, 0x06e, 0x01e,
-		0x27a, 0x0b0, 0x2b9, 0x06d,
-		0x262, 0x0d8, 0x26d, 0x05e,
-		0x254, 0x0f0, 0x258, 0x04b,
-		0x24c, 0x0fc, 0x252, 0x04d
-	};
-	int acf2[] = { 0x3f3fff, 0x3db7ce, 0x3c279d, 0x3a976b, 0x38ff38,
-		0x376706,
-		0x35c6d2, 0x341e9d, 0x326e68, 0x30ae31, 0x2eedf9,
-		0x2d15c0,
-		0x2b2d84, 0x293546, 0x272506, 0x24fcc2, 0x22ac7b,
-		0x203c2f,
-		0x1d9bde, 0x1ac386, 0x17a327, 0x1422be, 0x103247,
-		0x0b91bf,
-		0x07891e, 0x0470c1, 0x00e858, 0x3ccfde, 0x37bf4d,
-		0x313e96,
-		0x313e27, 0x313e27, 0x000627
-	};
-
-	program_acf(acf1, acf2);
-}
-
-void ini_acf_iireq_src_24m_8m(void)
-{
-	int acf1[] = { 0x303, 0x048, 0x17e, 0x00e,
-		0x302, 0x081, 0x3f8, 0x00a,
-		0x300, 0x0bd, 0x35b, 0x05e,
-		0x2fe, 0x0e3, 0x325, 0x04b,
-		0x2fb, 0x0f8, 0x313, 0x04d
-	};
-	int acf2[] = { 0x3f47ff, 0x3dc7d0, 0x3c3fa0, 0x3abf6f, 0x392f3e,
-		0x37a70d,
-		0x360eda, 0x346ea7, 0x32c673, 0x31163d, 0x2f5606,
-		0x2d8dce,
-		0x2bad93, 0x29bd56, 0x27b517, 0x258cd4, 0x23448d,
-		0x20cc41,
-		0x1e2bf0, 0x1b4b98, 0x182338, 0x149ace, 0x109255,
-		0x0bd1ca,
-		0x07a123, 0x0468c2, 0x00b054, 0x3c5fd4, 0x37073a,
-		0x302e79,
-		0x302e05, 0x302e05, 0x000605
-	};
-
-	program_acf(acf1, acf2);
-}
-
-void ini_acf_iireq_src_24m_7m(void)
-{
-	int acf1[] = { 0x2e7, 0x055, 0x153, 0x00e,
-		0x2dd, 0x08b, 0x3a5, 0x06f,
-		0x2d2, 0x0c4, 0x315, 0x05e,
-		0x2cb, 0x0e6, 0x2e7, 0x04b,
-		0x2c5, 0x0f9, 0x2d8, 0x04d
-	};
-	int acf2[] = { 0x3f3fff, 0x3dbfcf, 0x3c379e, 0x3aaf6d, 0x391f3c,
-		0x37870a,
-		0x35eed7, 0x344ea3, 0x32a66f, 0x30ee39, 0x2f2e02,
-		0x2d65c9,
-		0x2b858e, 0x298d51, 0x278511, 0x255cce, 0x231487,
-		0x20a43c,
-		0x1e0beb, 0x1b3394, 0x181335, 0x1492cb, 0x109254,
-		0x0be1ca,
-		0x07b925, 0x0480c5, 0x00d858, 0x3c87d8, 0x373740,
-		0x305e80,
-		0x305e0b, 0x305e0b, 0x00060b
-	};
-
-	program_acf(acf1, acf2);
-}
-
-void ini_acf_iireq_src_24m_6m(void)
-{
-	int acf1[] = { 0x2c9, 0x065, 0x118, 0x01e,
-		0x2b9, 0x097, 0x34f, 0x06f,
-		0x2a7, 0x0ca, 0x2d3, 0x05e,
-		0x29c, 0x0e9, 0x2ae, 0x04b,
-		0x295, 0x0fa, 0x2a2, 0x04d
-	};
-	int acf2[] = { 0x3f3fff, 0x3db7cf, 0x3c2f9d, 0x3a9f6c, 0x390f3a,
-		0x377707,
-		0x35d6d4, 0x342ea0, 0x32866b, 0x30ce34, 0x2f05fd,
-		0x2d35c3,
-		0x2b5588, 0x295d4b, 0x27550b, 0x252cc8, 0x22dc80,
-		0x206c35,
-		0x1dcbe4, 0x1af38c, 0x17cb2d, 0x144ac3, 0x104a4b,
-		0x0b99c1,
-		0x07791d, 0x0448be, 0x00b052, 0x3c6fd4, 0x37473f,
-		0x30c686,
-		0x30c618, 0x30c618, 0x000618
-	};
-
-	program_acf(acf1, acf2);
-}
-
-void ini_acf_iireq_src_24m_5m(void)
-{
-	int acf1[] = { 0x2ab, 0x077, 0x0c6, 0x01e,
-		0x295, 0x0a5, 0x2fa, 0x06d,
-		0x27f, 0x0d2, 0x297, 0x05e,
-		0x272, 0x0ed, 0x27b, 0x04b,
-		0x26a, 0x0fb, 0x272, 0x04d
-	};
-	int acf2[] = { 0x3f3fff, 0x3db7cf, 0x3c2f9e, 0x3aa76c, 0x39173b,
-		0x377f08,
-		0x35ded5, 0x343ea1, 0x328e6c, 0x30de36, 0x2f15ff,
-		0x2d45c6,
-		0x2b658a, 0x29754d, 0x27650d, 0x253cca, 0x22f483,
-		0x208438,
-		0x1de3e7, 0x1b0b90, 0x17eb30, 0x1472c7, 0x107a51,
-		0x0bd9c8,
-		0x07c927, 0x04a8c9, 0x01205f, 0x3cf7e4, 0x37e752,
-		0x31669a,
-		0x31662c, 0x31662c, 0x00062c
-	};
-
-	program_acf(acf1, acf2);
-}
-
-void ini_acf_iireq_src_207m_8m(void)
-{
-	int acf1[] = { 0x327, 0x039, 0x1a5, 0x07b,
-		0x332, 0x076, 0x05c, 0x06e,
-		0x33e, 0x0b6, 0x3b8, 0x05e,
-		0x344, 0x0e0, 0x37a, 0x04b,
-		0x345, 0x0f7, 0x365, 0x04d
-	};
-	int acf2[] = { 0x3f47ff, 0x3dcfd1, 0x3c57a1, 0x3ad772, 0x394f42,
-		0x37c711,
-		0x3636df, 0x34a6ad, 0x32fe7a, 0x315645, 0x2f9e0f,
-		0x2dd5d7,
-		0x2bfd9d, 0x2a0d61, 0x280d21, 0x25e4df, 0x239c98,
-		0x212c4d,
-		0x1e8bfc, 0x1baba4, 0x188344, 0x14fad9, 0x10ea61,
-		0x0c29d4,
-		0x07e92d, 0x04a8cb, 0x00f05c, 0x3c87da, 0x371f3e,
-		0x30267a,
-		0x302604, 0x302604, 0x000604
-	};
-
-	program_acf(acf1, acf2);
-}
-
-void ini_acf_iireq_src_207m_7m(void)
-{
-	int acf1[] = { 0x307, 0x046, 0x182, 0x00e,
-		0x306, 0x080, 0x002, 0x00a,
-		0x306, 0x0bd, 0x364, 0x05e,
-		0x304, 0x0e3, 0x32d, 0x04b,
-		0x301, 0x0f8, 0x31b, 0x04d
-	};
-	int acf2[] = { 0x3f47ff, 0x3dc7d0, 0x3c47a0, 0x3abf6f, 0x39373f,
-		0x37a70d,
-		0x3616db, 0x3476a8, 0x32d674, 0x31263f, 0x2f6608,
-		0x2d9dd0,
-		0x2bbd96, 0x29d559, 0x27cd19, 0x25a4d7, 0x235c90,
-		0x20ec45,
-		0x1e53f4, 0x1b739d, 0x18533d, 0x14d2d4, 0x10d25c,
-		0x0c19d1,
-		0x07e12c, 0x04a8ca, 0x00f05c, 0x3c8fdb, 0x372740,
-		0x302e7c,
-		0x302e05, 0x302e05, 0x000605
-	};
-
-	program_acf(acf1, acf2);
-}
-
-void ini_acf_iireq_src_207m_6m(void)
-{
-	int acf1[] = { 0x2e6, 0x056, 0x151, 0x00e,
-		0x2db, 0x08c, 0x3a1, 0x06f,
-		0x2d0, 0x0c4, 0x312, 0x05e,
-		0x2c9, 0x0e6, 0x2e4, 0x04b,
-		0x2c3, 0x0f9, 0x2d6, 0x04d
-	};
-	int acf2[] = { 0x3f47ff, 0x3dbfd0, 0x3c3f9f, 0x3ab76e, 0x39273d,
-		0x37970b,
-		0x35fed9, 0x345ea5, 0x32b671, 0x31063b, 0x2f4604,
-		0x2d75cb,
-		0x2b9590, 0x29a553, 0x279513, 0x256cd0, 0x232489,
-		0x20b43d,
-		0x1e0bec, 0x1b3395, 0x180b35, 0x148acb, 0x108253,
-		0x0bd1c8,
-		0x07a123, 0x0470c2, 0x00c055, 0x3c77d6, 0x372f3e,
-		0x306e80,
-		0x306e0d, 0x306e0d, 0x00060d
-	};
-
-	program_acf(acf1, acf2);
-}
-
-void ini_acf_iireq_src_207m_5m(void)
-{
-	int acf1[] = { 0x2c3, 0x068, 0x109, 0x01e,
-		0x2b1, 0x09a, 0x33d, 0x06f,
-		0x29f, 0x0cc, 0x2c6, 0x05e,
-		0x293, 0x0ea, 0x2a3, 0x04b,
-		0x28c, 0x0fa, 0x298, 0x04d
-	};
-	int acf2[] = { 0x3f3fff, 0x3db7ce, 0x3c279d, 0x3a976b, 0x38ff38,
-		0x376706,
-		0x35c6d2, 0x341e9e, 0x327669, 0x30be32, 0x2ef5fb,
-		0x2d25c1,
-		0x2b4586, 0x295549, 0x274509, 0x251cc6, 0x22dc80,
-		0x206c34,
-		0x1dcbe4, 0x1afb8d, 0x17db2e, 0x1462c5, 0x106a4f,
-		0x0bc9c6,
-		0x07b124, 0x0488c5, 0x00e859, 0x3cafdc, 0x377f47,
-		0x30ee8c,
-		0x30ee1d, 0x30ee1d, 0x00061d
-	};
-
-	program_acf(acf1, acf2);
-}
diff --git a/drivers/amlogic/dvb_tv/amldemod/include/addr_dtmb_che.h b/drivers/amlogic/dvb_tv/amldemod/include/addr_dtmb_che.h
deleted file mode 100644
index 01ff78361d2b..000000000000
--- a/drivers/amlogic/dvb_tv/amldemod/include/addr_dtmb_che.h
+++ /dev/null
@@ -1,58 +0,0 @@
-#ifndef __ADDR_DTMB_CHE_H__
-#define __ADDR_DTMB_CHE_H__
-
-#include "addr_dtmb_top.h"
-
-#define  DTMB_CHE_ADDR(x) (DTMB_DEMOD_BASE + (x << 2))
-
-#define  DTMB_CHE_TE_HREB_SNR               DTMB_CHE_ADDR(0x8d)
-#define  DTMB_CHE_MC_SC_TIMING_POWTHR       DTMB_CHE_ADDR(0x8e)
-#define  DTMB_CHE_MC_SC_PROTECT_GD          DTMB_CHE_ADDR(0x8f)
-#define  DTMB_CHE_TIMING_LIMIT              DTMB_CHE_ADDR(0x90)
-#define  DTMB_CHE_TPS_CONFIG                DTMB_CHE_ADDR(0x91)
-#define  DTMB_CHE_FD_TD_STEPSIZE            DTMB_CHE_ADDR(0x92)
-#define  DTMB_CHE_QSTEP_SET                 DTMB_CHE_ADDR(0x93)
-#define  DTMB_CHE_SEG_CONFIG                DTMB_CHE_ADDR(0x94)
-#define  DTMB_CHE_FD_TD_LEAKSIZE_CONFIG1    DTMB_CHE_ADDR(0x95)
-#define  DTMB_CHE_FD_TD_LEAKSIZE_CONFIG2    DTMB_CHE_ADDR(0x96)
-#define  DTMB_CHE_FD_TD_COEFF               DTMB_CHE_ADDR(0x97)
-#define  DTMB_CHE_M_CCI_THR_CONFIG1         DTMB_CHE_ADDR(0x98)
-#define  DTMB_CHE_M_CCI_THR_CONFIG2         DTMB_CHE_ADDR(0x99)
-#define  DTMB_CHE_M_CCI_THR_CONFIG3         DTMB_CHE_ADDR(0x9a)
-#define  DTMB_CHE_CCIDET_CONFIG             DTMB_CHE_ADDR(0x9b)
-#define  DTMB_CHE_IBDFE_CONFIG1             DTMB_CHE_ADDR(0x9d)
-#define  DTMB_CHE_IBDFE_CONFIG2             DTMB_CHE_ADDR(0x9e)
-#define  DTMB_CHE_IBDFE_CONFIG3             DTMB_CHE_ADDR(0x9f)
-#define  DTMB_CHE_TD_COEFF                  DTMB_CHE_ADDR(0xa0)
-#define  DTMB_CHE_FD_TD_STEPSIZE_ADJ        DTMB_CHE_ADDR(0xa1)
-#define  DTMB_CHE_FD_COEFF_FRZ              DTMB_CHE_ADDR(0xa2)
-#define  DTMB_CHE_FD_COEFF                  DTMB_CHE_ADDR(0xa3)
-#define  DTMB_CHE_FD_LEAKSIZE               DTMB_CHE_ADDR(0xa4)
-#define  DTMB_CHE_IBDFE_CONFIG4             DTMB_CHE_ADDR(0xa5)
-#define  DTMB_CHE_IBDFE_CONFIG5             DTMB_CHE_ADDR(0xa6)
-#define  DTMB_CHE_IBDFE_CONFIG6             DTMB_CHE_ADDR(0xa7)
-#define  DTMB_CHE_IBDFE_CONFIG7             DTMB_CHE_ADDR(0xa8)
-#define  DTMB_CHE_DCM_SC_MC_GD_LEN          DTMB_CHE_ADDR(0xa9)
-#define  DTMB_CHE_EQMC_PICK_THR             DTMB_CHE_ADDR(0xaa)
-#define  DTMB_CHE_EQMC_THRESHOLD            DTMB_CHE_ADDR(0xab)
-#define  DTMB_CHE_EQSC_PICK_THR             DTMB_CHE_ADDR(0xad)
-#define  DTMB_CHE_EQSC_THRESHOLD            DTMB_CHE_ADDR(0xae)
-#define  DTMB_CHE_PROTECT_GD_TPS            DTMB_CHE_ADDR(0xaf)
-#define  DTMB_CHE_FD_TD_STEPSIZE_THR1       DTMB_CHE_ADDR(0xb0)
-#define  DTMB_CHE_TDFD_SWITCH_SYM1          DTMB_CHE_ADDR(0xb1)
-#define  DTMB_CHE_TDFD_SWITCH_SYM2          DTMB_CHE_ADDR(0xb2)
-#define  DTMB_CHE_EQ_CONFIG                 DTMB_CHE_ADDR(0xb3)
-#define  DTMB_CHE_EQSC_SNR_IMP_THR1         DTMB_CHE_ADDR(0xb4)
-#define  DTMB_CHE_EQSC_SNR_IMP_THR2         DTMB_CHE_ADDR(0xb5)
-#define  DTMB_CHE_EQMC_SNR_IMP_THR1         DTMB_CHE_ADDR(0xb6)
-#define  DTMB_CHE_EQMC_SNR_IMP_THR2         DTMB_CHE_ADDR(0xb7)
-#define  DTMB_CHE_EQSC_SNR_DROP_THR         DTMB_CHE_ADDR(0xb8)
-#define  DTMB_CHE_EQMC_SNR_DROP_THR         DTMB_CHE_ADDR(0xb9)
-#define  DTMB_CHE_M_CCI_THR                 DTMB_CHE_ADDR(0xba)
-#define  DTMB_CHE_TPS_MC                    DTMB_CHE_ADDR(0xbb)
-#define  DTMB_CHE_TPS_SC                    DTMB_CHE_ADDR(0xbc)
-#define  DTMB_CHE_CHE_SET_FSM               DTMB_CHE_ADDR(0xbd)
-#define  DTMB_CHE_ZERO_NUM_THR              DTMB_CHE_ADDR(0xbe)
-#define  DTMB_CHE_TIMING_READY              DTMB_CHE_ADDR(0xbf)
-
-#endif
diff --git a/drivers/amlogic/dvb_tv/amldemod/include/addr_dtmb_che_bit.h b/drivers/amlogic/dvb_tv/amldemod/include/addr_dtmb_che_bit.h
deleted file mode 100644
index edb848c9e676..000000000000
--- a/drivers/amlogic/dvb_tv/amldemod/include/addr_dtmb_che_bit.h
+++ /dev/null
@@ -1,247 +0,0 @@
-#ifndef __ADDR_DTMB_CHE_BIT_H__
-#define __ADDR_DTMB_CHE_BIT_H__
-
-struct DTMB_CHE_TE_HREB_SNR_BITS {
-	unsigned int te_hreb_snr:21, reserved0:11;
-};
-struct DTMB_CHE_MC_SC_TIMING_POWTHR_BITS {
-	unsigned int mc_timing_powthr1:5,
-	    reserved1:3,
-	    mc_timing_powthr0:5,
-	    reserved2:2,
-	    sc_timing_powthr1:5, reserved3:4, sc_timing_powthr0:5, reserved4:3;
-};
-struct DTMB_CHE_MC_SC_PROTECT_GD_BITS {
-	unsigned int h_valid:2,
-	    reserved5:2,
-	    dist:3,
-	    reserved6:1,
-	    ma_size:3,
-	    reserved7:1,
-	    mc_protect_gd:5, reserved8:3, sc_protect_gd:5, reserved9:7;
-};
-struct DTMB_CHE_TIMING_LIMIT_BITS {
-	unsigned int ncoh_thd:3,
-	    reserved10:1,
-	    coh_thd:3,
-	    reserved11:1,
-	    strong_loc_thd:8, reserved12:4, timing_limit:5, reserved13:7;
-};
-struct DTMB_CHE_TPS_CONFIG_BITS {
-	unsigned int tps_pst_num:5,
-	    reserved14:3,
-	    tps_pre_num:5, reserved15:3, chi_power_thr:8, reserved16:8;
-};
-struct DTMB_CHE_FD_TD_STEPSIZE_BITS {
-	unsigned int fd_stepsize_thr03:5,
-	    fd_stepsize_thr02:5,
-	    fd_stepsize_thr01:5,
-	    td_stepsize_thr03:5,
-	    td_stepsize_thr02:5, td_stepsize_thr01:5, reserved17:2;
-};
-struct DTMB_CHE_QSTEP_SET_BITS {
-	unsigned int factor_stable_thres:10,
-	    reserved18:2, qstep_set:13, qstep_set_val:1, reserved19:6;
-};
-struct DTMB_CHE_SEG_CONFIG_BITS {
-	unsigned int seg_bypass:1,
-	    seg_num_1seg_log2:3,
-	    seg_alpha:3,
-	    seg_read_val:1, seg_read_addr:12, noise_input_shift:4, reserved20:8;
-};
-struct DTMB_CHE_FD_TD_LEAKSIZE_CONFIG1_BITS {
-	unsigned int fd_leaksize_thr03:5,
-	    fd_leaksize_thr02:5,
-	    fd_leaksize_thr01:5,
-	    td_leaksize_thr03:5,
-	    td_leaksize_thr02:5, td_leaksize_thr01:5, reserved21:2;
-};
-struct DTMB_CHE_FD_TD_LEAKSIZE_CONFIG2_BITS {
-	unsigned int fd_leaksize_thr13:5,
-	    fd_leaksize_thr12:5,
-	    fd_leaksize_thr11:5,
-	    td_leaksize_thr13:5,
-	    td_leaksize_thr12:5, td_leaksize_thr11:5, reserved22:2;
-};
-struct DTMB_CHE_FD_TD_COEFF_BITS {
-	unsigned int td_coeff_frz:14,
-	    reserved23:2,
-	    td_coeff_addr:4,
-	    td_coeff_init:1,
-	    td_coeff_rst:1,
-	    fd_coeff_init:1,
-	    fd_coeff_done:1,
-	    fd_coeff_rst:1, td_coeff_done:1, fd_coeff_addr:5, reserved24:1;
-};
-struct DTMB_CHE_M_CCI_THR_CONFIG1_BITS {
-	unsigned int m_cci_thr_mc1:10,
-	    m_cci_thr_mc2:10, m_cci_thr_mc3:10, reserved25:2;
-};
-struct DTMB_CHE_M_CCI_THR_CONFIG2_BITS {
-	unsigned int m_cci_thr_sc2:10,
-	    m_cci_thr_sc3:10, m_cci_thr_mc0:10, reserved26:2;
-};
-struct DTMB_CHE_M_CCI_THR_CONFIG3_BITS {
-	unsigned int m_cci_thr_ma:10,
-	    m_cci_thr_sc0:10, m_cci_thr_sc1:10, reserved27:2;
-};
-struct DTMB_CHE_CCIDET_CONFIG_BITS {
-	unsigned int ccidet_dly:7,
-	    ccidet_malpha:3,
-	    ccidet_sc_mask_rng:5,
-	    ccidet_mc_mask_rng:5,
-	    ccidet_masize:4,
-	    ccidect_sat_sft:3,
-	    ccicnt_out_sel:2, tune_mask:1, m_cci_bypass:1, reserved28:1;
-};
-struct DTMB_CHE_IBDFE_CONFIG1_BITS {
-	unsigned int ibdfe_cci_just_thr:13,
-	    reserved29:3,
-	    ibdfe_dmsg_point:5, reserved30:3, ibdfe_dmsg_alp:3, reserved31:5;
-};
-struct DTMB_CHE_IBDFE_CONFIG2_BITS {
-	unsigned int ibdfe_rou_rat_1:10,
-	    reserved32:6, ibdfe_rou_rat_0:10, reserved33:6;
-};
-struct DTMB_CHE_IBDFE_CONFIG3_BITS {
-	unsigned int ibdfe_rou_rat_3:10,
-	    reserved34:6, ibdfe_rou_rat_2:10, reserved35:6;
-};
-struct DTMB_CHE_TD_COEFF_BITS {
-	unsigned int td_coeff:24, reserved36:8;
-};
-struct DTMB_CHE_FD_TD_STEPSIZE_ADJ_BITS {
-	unsigned int fd_stepsize_adj:3, td_stepsize_adj:3, reserved37:26;
-};
-struct DTMB_CHE_FD_COEFF_BITS {
-	unsigned int fd_coeff:24, reserved38:8;
-};
-struct DTMB_CHE_FD_LEAKSIZE_BITS {
-	unsigned int fd_leaksize:18, reserved39:14;
-};
-struct DTMB_CHE_IBDFE_CONFIG4_BITS {
-	unsigned int ibdfe_fdbk_iter:4,
-	    ibdfe_eqout_iter:4,
-	    eq_dist_thr_tps:4,
-	    eq_soft_slicer_en:1,
-	    reserved40:3,
-	    gd_len:5, ibdfe_blank_y:1, reserved41:1, ibdfe_dmsg_start_cnt:9;
-};
-struct DTMB_CHE_IBDFE_CONFIG5_BITS {
-	unsigned int ibdfe_init_snr:12,
-	    reserved42:4, eq_init_snr:12, reserved43:4;
-};
-struct DTMB_CHE_IBDFE_CONFIG6_BITS {
-	unsigned int ibdfe_const_thr3:4,
-	    ibdfe_const_thr2:4,
-	    ibdfe_const_thr1:4,
-	    ibdfe_const_thr0:4,
-	    ibdfe_threshold3:4,
-	    ibdfe_threshold2:4, ibdfe_threshold1:4, ibdfe_threshold0:4;
-};
-struct DTMB_CHE_IBDFE_CONFIG7_BITS {
-	unsigned int ibdfe_pick_thr3:8,
-	    ibdfe_pick_thr2:8, ibdfe_pick_thr1:8, ibdfe_pick_thr0:8;
-};
-struct DTMB_CHE_DCM_SC_MC_GD_LEN_BITS {
-	unsigned int dcm_mc_gd_len:6,
-	    reserved44:2, dcm_sc_gd_len:6, reserved45:2, eq_dsnr_slc2drm:16;
-};
-struct DTMB_CHE_EQMC_PICK_THR_BITS {
-	unsigned int eqmc_pick_thr3:8,
-	    eqmc_pick_thr2:8, eqmc_pick_thr1:8, eqmc_pick_thr0:8;
-};
-struct DTMB_CHE_EQMC_THRESHOLD_BITS {
-	unsigned int eqmc_const_thr3:4,
-	    eqmc_const_thr2:4,
-	    eqmc_const_thr1:4,
-	    eqmc_const_thr0:4,
-	    eqmc_threshold3:4,
-	    eqmc_threshold2:4, eqmc_threshold1:4, eqmc_threshold0:4;
-};
-struct DTMB_CHE_EQSC_PICK_THR_BITS {
-	unsigned int eqsc_pick_thr3:8,
-	    eqsc_pick_thr2:8, eqsc_pick_thr1:8, eqsc_pick_thr0:8;
-};
-struct DTMB_CHE_EQSC_THRESHOLD_BITS {
-	unsigned int eqsc_const_thr3:4,
-	    eqsc_const_thr2:4,
-	    eqsc_const_thr1:4,
-	    eqsc_const_thr0:4,
-	    eqsc_threshold3:4,
-	    eqsc_threshold2:4, eqsc_threshold1:4, eqsc_threshold0:4;
-};
-struct DTMB_CHE_PROTECT_GD_TPS_BITS {
-	unsigned int pow_norm:10,
-	    ncoh_thd_tps:3,
-	    coh_thd_tps:3, thr_max:10, protect_gd_tps:5, reserved46:1;
-};
-struct DTMB_CHE_FD_TD_STEPSIZE_THR1_BITS {
-	unsigned int fd_stepsize_thr13:5,
-	    fd_stepsize_thr12:5,
-	    fd_stepsize_thr11:5,
-	    td_stepsize_thr13:5,
-	    td_stepsize_thr12:5, td_stepsize_thr11:5, reserved47:2;
-};
-struct DTMB_CHE_TDFD_SWITCH_SYM1_BITS {
-	unsigned int tdfd_switch_sym00:16, tdfd_switch_sym01:16;
-};
-struct DTMB_CHE_TDFD_SWITCH_SYM2_BITS {
-	unsigned int tdfd_switch_sym10:16, tdfd_switch_sym11:16;
-};
-struct DTMB_CHE_EQ_CONFIG_BITS {
-	unsigned int eq_dsnr_h2drm:6,
-	    eq_cmp_en:1,
-	    eq_imp_setzero_en:1,
-	    dcm_sc_bypass:1,
-	    dcm_mc_bypass:1,
-	    dcm_sc_h_limit:4,
-	    dcm_mc_h_limit:4,
-	    eqsnr_imp_alp:3, eqsnr_avg_alp:3, dcm_alpha:2, reserved48:6;
-};
-struct DTMB_CHE_EQSC_SNR_IMP_THR1_BITS {
-	unsigned int eqsc_snr_imp_thr1:12, eqsc_snr_imp_thr0:12, reserved49:8;
-};
-struct DTMB_CHE_EQSC_SNR_IMP_THR2_BITS {
-	unsigned int eqsc_snr_imp_thr3:12, eqsc_snr_imp_thr2:12, reserved50:8;
-};
-struct DTMB_CHE_EQMC_SNR_IMP_THR1_BITS {
-	unsigned int eqmc_snr_imp_thr1:12, eqmc_snr_imp_thr0:12, reserved51:8;
-};
-struct DTMB_CHE_EQMC_SNR_IMP_THR2_BITS {
-	unsigned int eqmc_snr_imp_thr3:12, eqmc_snr_imp_thr2:12, reserved52:8;
-};
-struct DTMB_CHE_EQSC_SNR_DROP_THR_BITS {
-	unsigned int eqsc_snr_drop_thr3:8,
-	    eqsc_snr_drop_thr2:8, eqsc_snr_drop_thr1:8, eqsc_snr_drop_thr0:8;
-};
-struct DTMB_CHE_EQMC_SNR_DROP_THR_BITS {
-	unsigned int eqmc_snr_drop_thr3:8,
-	    eqmc_snr_drop_thr2:8, eqmc_snr_drop_thr1:8, eqmc_snr_drop_thr0:8;
-};
-struct DTMB_CHE_M_CCI_THR_BITS {
-	unsigned int ccidet_mask_rng_tps:5,
-	    m_cci_thr_tps:10, m_cci_thr_ma_tps:10, reserved53:7;
-};
-struct DTMB_CHE_TPS_MC_BITS {
-	unsigned int tps_mc_run_tim_limit:10,
-	    tps_mc_suc_limit:7, tps_mc_q_thr:7, tps_mc_alpha:3, reserved54:5;
-};
-struct DTMB_CHE_TPS_SC_BITS {
-	unsigned int tps_sc_run_tim_limit:10,
-	    tps_sc_suc_limit:7, tps_sc_q_thr:7, tps_sc_alpha:3, reserved55:5;
-};
-struct DTMB_CHE_CHE_SET_FSM_BITS {
-	unsigned int che_open_loop_len:12,
-	    reserved56:4,
-	    che_set_fsm_st:3, reserved57:1, che_set_fsm_en:1, reserved58:11;
-};
-struct DTMB_CHE_ZERO_NUM_THR_BITS {
-	unsigned int null_frame_thr:16, zero_num_thr:12, reserved59:4;
-};
-struct DTMB_CHE_TIMING_READY_BITS {
-	unsigned int timing_offset:11,
-	    reserved60:5, timing_ready:1, reserved61:15;
-};
-
-#endif
diff --git a/drivers/amlogic/dvb_tv/amldemod/include/addr_dtmb_front.h b/drivers/amlogic/dvb_tv/amldemod/include/addr_dtmb_front.h
deleted file mode 100644
index aa404a5e594b..000000000000
--- a/drivers/amlogic/dvb_tv/amldemod/include/addr_dtmb_front.h
+++ /dev/null
@@ -1,48 +0,0 @@
-#ifndef __ADDR_DTMB_FRONT_H__
-#define __ADDR_DTMB_FRONT_H__
-
-#include "addr_dtmb_top.h"
-
-#define  DTMB_FRONT_ADDR(x) (DTMB_DEMOD_BASE + (x << 2))
-
-#define  DTMB_FRONT_AFIFO_ADC                 DTMB_FRONT_ADDR(0x20)
-#define  DTMB_FRONT_AGC_CONFIG1               DTMB_FRONT_ADDR(0x21)
-#define  DTMB_FRONT_AGC_CONFIG2               DTMB_FRONT_ADDR(0x22)
-#define  DTMB_FRONT_AGC_CONFIG3               DTMB_FRONT_ADDR(0x23)
-#define  DTMB_FRONT_AGC_CONFIG4               DTMB_FRONT_ADDR(0x24)
-#define  DTMB_FRONT_DDC_BYPASS                DTMB_FRONT_ADDR(0x25)
-#define  DTMB_FRONT_DC_HOLD                   DTMB_FRONT_ADDR(0x28)
-#define  DTMB_FRONT_DAGC_TARGET_POWER         DTMB_FRONT_ADDR(0x29)
-#define  DTMB_FRONT_ACF_BYPASS                DTMB_FRONT_ADDR(0x2a)
-#define  DTMB_FRONT_COEF_SET1                 DTMB_FRONT_ADDR(0x2b)
-#define  DTMB_FRONT_COEF_SET2                 DTMB_FRONT_ADDR(0x2c)
-#define  DTMB_FRONT_COEF_SET3                 DTMB_FRONT_ADDR(0x2d)
-#define  DTMB_FRONT_COEF_SET4                 DTMB_FRONT_ADDR(0x2e)
-#define  DTMB_FRONT_COEF_SET5                 DTMB_FRONT_ADDR(0x2f)
-#define  DTMB_FRONT_COEF_SET6                 DTMB_FRONT_ADDR(0x30)
-#define  DTMB_FRONT_COEF_SET7                 DTMB_FRONT_ADDR(0x31)
-#define  DTMB_FRONT_COEF_SET8                 DTMB_FRONT_ADDR(0x32)
-#define  DTMB_FRONT_COEF_SET9                 DTMB_FRONT_ADDR(0x33)
-#define  DTMB_FRONT_COEF_SET10                DTMB_FRONT_ADDR(0x34)
-#define  DTMB_FRONT_COEF_SET11                DTMB_FRONT_ADDR(0x35)
-#define  DTMB_FRONT_COEF_SET12                DTMB_FRONT_ADDR(0x36)
-#define  DTMB_FRONT_COEF_SET13                DTMB_FRONT_ADDR(0x37)
-#define  DTMB_FRONT_COEF_SET14                DTMB_FRONT_ADDR(0x38)
-#define  DTMB_FRONT_COEF_SET15                DTMB_FRONT_ADDR(0x39)
-#define  DTMB_FRONT_COEF_SET16                DTMB_FRONT_ADDR(0x3a)
-#define  DTMB_FRONT_COEF_SET17                DTMB_FRONT_ADDR(0x3b)
-#define  DTMB_FRONT_COEF_SET18                DTMB_FRONT_ADDR(0x3c)
-#define  DTMB_FRONT_COEF_SET19                DTMB_FRONT_ADDR(0x3d)
-#define  DTMB_FRONT_SRC_CONFIG1               DTMB_FRONT_ADDR(0x3e)
-#define  DTMB_FRONT_SRC_CONFIG2               DTMB_FRONT_ADDR(0x3f)
-#define  DTMB_FRONT_SFIFO_OUT_LEN             DTMB_FRONT_ADDR(0x40)
-#define  DTMB_FRONT_DAGC_GAIN                 DTMB_FRONT_ADDR(0x41)
-#define  DTMB_FRONT_IQIB_STEP                 DTMB_FRONT_ADDR(0x42)
-#define  DTMB_FRONT_IQIB_CONFIG               DTMB_FRONT_ADDR(0x43)
-#define  DTMB_FRONT_ST_CONFIG                 DTMB_FRONT_ADDR(0x44)
-#define  DTMB_FRONT_ST_FREQ                   DTMB_FRONT_ADDR(0x45)
-
-#define  DTMB_FRONT_DEBUG_CFG                  DTMB_FRONT_ADDR(0x48)
-#define  DTMB_FRONT_MEM_ADDR                  DTMB_FRONT_ADDR(0x49)
-
-#endif
diff --git a/drivers/amlogic/dvb_tv/amldemod/include/addr_dtmb_front_bit.h b/drivers/amlogic/dvb_tv/amldemod/include/addr_dtmb_front_bit.h
deleted file mode 100644
index b6df7f602041..000000000000
--- a/drivers/amlogic/dvb_tv/amldemod/include/addr_dtmb_front_bit.h
+++ /dev/null
@@ -1,312 +0,0 @@
-#ifndef __ADDR_DTMB_FRONT_BIT_H__
-#define __ADDR_DTMB_FRONT_BIT_H__
-
-union   DTMB_FRONT_AFIFO_ADC_BITS {
-	unsigned int d32;
-	struct {
-		unsigned int afifo_nco_rate:8,
-			     afifo_data_format:1,
-			     afifo_bypass:1,
-			     adc_sample:6,
-			     adc_IQ:1,
-			     reserved0:15;
-	} b;
-};
-struct  DTMB_FRONT_AGC_CONFIG1_BITS {
-	unsigned int agc_target:4,
-		     agc_cal_intv:2,
-		     reserved1:2,
-		     agc_gain_step2:6,
-		     reserved2:2,
-		     agc_gain_step1:6,
-		     reserved3:2,
-		     agc_a_filter_coef2:3,
-		     reserved4:1,
-		     agc_a_filter_coef1:3,
-		     reserved5:1;
-};
-struct  DTMB_FRONT_AGC_CONFIG2_BITS {
-	unsigned int agc_imp_thresh:4,
-		     agc_imp_en:1,
-		     agc_iq_exchange:1,
-		     reserved6:2,
-		     agc_clip_ratio:5,
-		     reserved7:3,
-		     agc_signal_clip_thr:6,
-		     reserved8:2,
-		     agc_sd_rate:7,
-		     reserved9:1;
-};
-struct  DTMB_FRONT_AGC_CONFIG3_BITS {
-	unsigned int agc_rffb_value:11,
-		     reserved10:1,
-		     agc_iffb_value:11,
-		     reserved11:1,
-		     agc_gain_step_rf:1,
-		     agc_rfgain_freeze:1,
-		     agc_tuning_slope:1,
-		     agc_rffb_set:1,
-		     agc_gain_step_if:1,
-		     agc_ifgain_freeze:1,
-		     agc_if_only:1,
-		     agc_iffb_set:1;
-};
-struct  DTMB_FRONT_AGC_CONFIG4_BITS {
-	unsigned int agc_rffb_gain_sat_i:8,
-		     agc_rffb_gain_sat:8,
-		     agc_iffb_gain_sat_i:8,
-		     agc_iffb_gain_sat:8;
-};
-struct  DTMB_FRONT_DDC_BYPASS_BITS {
-	unsigned int ddc_phase:25,
-		     reserved12:3,
-		     ddc_bypass:1,
-		     reserved13:3;
-};
-struct  DTMB_FRONT_DC_HOLD_BITS {
-	unsigned int dc_hold:1,
-		     dc_alpha:3,
-		     mobi_det_accu_len:3,
-		     reserved14:1,
-		     mobi_det_observe_len:3,
-		     reserved15:1,
-		     channel_static_th:4,
-		     channel_portable_th:4,
-		     dc_bypass:1,
-		     reserved16:3,
-		     dc_len:3,
-		     reserved17:5;
-};
-struct  DTMB_FRONT_DAGC_TARGET_POWER_BITS {
-	unsigned int dagc_target_power_l:8,
-		     dagc_target_power_h:8,
-		     dagc_target_power_ler:8,
-		     dagc_target_power_her:8;
-};
-struct  DTMB_FRONT_ACF_BYPASS_BITS {
-	unsigned int coef65:11,
-		     reserved18:1,
-		     coef66:11,
-		     reserved19:1,
-		     acf_bypass:1,
-		     reserved20:7;
-};
-struct  DTMB_FRONT_COEF_SET1_BITS {
-	unsigned int coef63:11,
-		     reserved21:1,
-		     coef64:11,
-		     reserved22:9;
-};
-struct  DTMB_FRONT_COEF_SET2_BITS {
-	unsigned int coef62:10,
-		     reserved23:22;
-};
-struct  DTMB_FRONT_COEF_SET3_BITS {
-	unsigned int coef60:10,
-		     reserved24:2,
-		     coef61:10,
-		     reserved25:10;
-};
-struct  DTMB_FRONT_COEF_SET4_BITS {
-	unsigned int coef59:9,
-		     reserved26:23;
-};
-struct  DTMB_FRONT_COEF_SET5_BITS {
-	unsigned int coef57:9,
-		     reserved27:3,
-		     coef58:9,
-		     reserved28:11;
-};
-struct  DTMB_FRONT_COEF_SET6_BITS {
-	unsigned int coef54:8,
-		     coef55:8,
-		     coef56:8,
-		     reserved29:8;
-};
-struct  DTMB_FRONT_COEF_SET7_BITS {
-	unsigned int coef53:7,
-		     reserved30:25;
-};
-struct  DTMB_FRONT_COEF_SET8_BITS {
-	unsigned int coef49:7,
-		     reserved31:1,
-		     coef50:7,
-		     reserved32:1,
-		     coef51:7,
-		     reserved33:1,
-		     coef52:7,
-		     reserved34:1;
-};
-struct  DTMB_FRONT_COEF_SET9_BITS {
-	unsigned int coef45:7,
-		     reserved35:1,
-		     coef46:7,
-		     reserved36:1,
-		     coef47:7,
-		     reserved37:1,
-		     coef48:7,
-		     reserved38:1;
-};
-struct  DTMB_FRONT_COEF_SET10_BITS {
-	unsigned int coef42:6,
-		     reserved39:2,
-		     coef43:6,
-		     reserved40:2,
-		     coef44:6,
-		     reserved41:10;
-};
-struct  DTMB_FRONT_COEF_SET11_BITS {
-	unsigned int coef38:6,
-		     reserved42:2,
-		     coef39:6,
-		     reserved43:2,
-		     coef40:6,
-		     reserved44:2,
-		     coef41:6,
-		     reserved45:2;
-};
-struct  DTMB_FRONT_COEF_SET12_BITS {
-	unsigned int coef34:6,
-		     reserved46:2,
-		     coef35:6,
-		     reserved47:2,
-		     coef36:6,
-		     reserved48:2,
-		     coef37:6,
-		     reserved49:2;
-};
-struct  DTMB_FRONT_COEF_SET13_BITS {
-	unsigned int coef30:6,
-		     reserved50:2,
-		     coef31:6,
-		     reserved51:2,
-		     coef32:6,
-		     reserved52:2,
-		     coef33:6,
-		     reserved53:2;
-};
-struct  DTMB_FRONT_COEF_SET14_BITS {
-	unsigned int coef27:5,
-		     reserved54:3,
-		     coef28:5,
-		     reserved55:3,
-		     coef29:5,
-		     reserved56:11;
-};
-struct  DTMB_FRONT_COEF_SET15_BITS {
-	unsigned int coef23:5,
-		     reserved57:3,
-		     coef24:5,
-		     reserved58:3,
-		     coef25:5,
-		     reserved59:3,
-		     coef26:5,
-		     reserved60:3;
-};
-struct  DTMB_FRONT_COEF_SET16_BITS {
-	unsigned int coef19:5,
-		     reserved61:3,
-		     coef20:5,
-		     reserved62:3,
-		     coef21:5,
-		     reserved63:3,
-		     coef22:5,
-		     reserved64:3;
-};
-struct  DTMB_FRONT_COEF_SET17_BITS {
-	unsigned int coef15:5,
-		     reserved65:3,
-		     coef16:5,
-		     reserved66:3,
-		     coef17:5,
-		     reserved67:3,
-		     coef18:5,
-		     reserved68:3;
-};
-struct  DTMB_FRONT_COEF_SET18_BITS {
-	unsigned int coef08:4,
-		     coef09:4,
-		     coef10:4,
-		     coef11:4,
-		     coef12:4,
-		     coef13:4,
-		     coef14:4,
-		     reserved69:4;
-};
-struct  DTMB_FRONT_COEF_SET19_BITS {
-	unsigned int coef00:4,
-		     coef01:4,
-		     coef02:4,
-		     coef03:4,
-		     coef04:4,
-		     coef05:4,
-		     coef06:4,
-		     coef07:4;
-};
-struct  DTMB_FRONT_SRC_CONFIG1_BITS {
-	unsigned int src_norm_inrate:24,
-		     src_tim_shr:4,
-		     src_ted_disable:1,
-		     reserved70:3;
-};
-struct  DTMB_FRONT_SRC_CONFIG2_BITS {
-	unsigned int src_stable_timeout:4,
-		     src_seg_len:3,
-		     reserved71:1,
-		     src_ted_beta:3,
-		     reserved72:1,
-		     src_time_err_thr:4,
-		     src_time_mu1:5,
-		     reserved73:3,
-		     src_time_mu2:5,
-		     reserved74:3;
-};
-struct  DTMB_FRONT_SFIFO_OUT_LEN_BITS {
-	unsigned int sfifo_out_len:4,
-		     reserved75:28;
-};
-struct  DTMB_FRONT_DAGC_GAIN_BITS {
-	unsigned int dagc_bypass:1,
-		     dagc_power_alpha:2,
-		     dagc_bw:3,
-		     dagc_gain_ctrl:12,
-		     dagc_gain_step_er:6,
-		     dagc_gain_step:6,
-		     reserved76:2;
-};
-struct  DTMB_FRONT_IQIB_STEP_BITS {
-	unsigned int iqib_step_b:2,
-		     iqib_step_a:2,
-		     iqib_period:3,
-		     reserved77:1,
-		     iqib_bypass:1,
-		     reserved78:23;
-};
-struct  DTMB_FRONT_IQIB_CONFIG_BITS {
-	unsigned int iqib_set_b:12,
-		     iqib_set_a:10,
-		     reserved79:2,
-		     iqib_set_val:1,
-		     iqib_hold:1,
-		     reserved80:6;
-};
-struct  DTMB_FRONT_ST_CONFIG_BITS {
-	unsigned int st_enable:1,
-		     reserved81:3,
-		     st_dc_len:3,
-		     reserved82:1,
-		     st_alpha:3,
-		     reserved83:1,
-		     st_Q_thrsh:8,
-		     st_dist:3,
-		     reserved84:1,
-		     st_len:5,
-		     reserved85:3;
-};
-struct  DTMB_FRONT_ST_FREQ_BITS {
-	unsigned int st_freq_v:1,
-		     st_freq_i:19,
-		     reserved86:12;
-};
-
-#endif
diff --git a/drivers/amlogic/dvb_tv/amldemod/include/addr_dtmb_sync.h b/drivers/amlogic/dvb_tv/amldemod/include/addr_dtmb_sync.h
deleted file mode 100644
index 0455a4e3e35f..000000000000
--- a/drivers/amlogic/dvb_tv/amldemod/include/addr_dtmb_sync.h
+++ /dev/null
@@ -1,34 +0,0 @@
-#ifndef __ADDR_DTMB_SYNC_H__
-#define __ADDR_DTMB_SYNC_H__
-
-#include "addr_dtmb_top.h"
-#define  DTMB_SYNC_ADDR(x) (DTMB_DEMOD_BASE + (x << 2))
-
-#define  DTMB_SYNC_TS_CFO_PN_VALUE           DTMB_SYNC_ADDR(0x57)
-#define  DTMB_SYNC_TS_CFO_ERR_LIMIT          DTMB_SYNC_ADDR(0x58)
-#define  DTMB_SYNC_TS_CFO_PN_MODIFY          DTMB_SYNC_ADDR(0x59)
-#define  DTMB_SYNC_TS_GAIN                   DTMB_SYNC_ADDR(0x5a)
-#define  DTMB_SYNC_FE_CONFIG                 DTMB_SYNC_ADDR(0x5b)
-#define  DTMB_SYNC_PNPHASE_OFFSET            DTMB_SYNC_ADDR(0x5c)
-#define  DTMB_SYNC_PNPHASE_CONFIG            DTMB_SYNC_ADDR(0x5d)
-#define  DTMB_SYNC_SFO_SFO_PN0_MODIFY        DTMB_SYNC_ADDR(0x5e)
-#define  DTMB_SYNC_SFO_SFO_PN1_MODIFY        DTMB_SYNC_ADDR(0x5f)
-#define  DTMB_SYNC_SFO_SFO_PN2_MODIFY        DTMB_SYNC_ADDR(0x60)
-#define  DTMB_SYNC_SFO_CONFIG                DTMB_SYNC_ADDR(0x61)
-#define  DTMB_SYNC_FEC_CFG                   DTMB_SYNC_ADDR(0x67)
-#define  DTMB_SYNC_FEC_DEBUG_CFG             DTMB_SYNC_ADDR(0x68)
-#define  DTMB_SYNC_DATA_DDR_ADR              DTMB_SYNC_ADDR(0x69)
-#define  DTMB_SYNC_DEBUG_DDR_ADR             DTMB_SYNC_ADDR(0x6a)
-#define  DTMB_SYNC_FEC_SIM_CFG1              DTMB_SYNC_ADDR(0x6b)
-#define  DTMB_SYNC_FEC_SIM_CFG2              DTMB_SYNC_ADDR(0x6c)
-#define  DTMB_SYNC_TRACK_CFO_MAX             DTMB_SYNC_ADDR(0x6d)
-#define  DTMB_SYNC_CCI_DAGC_CONFIG1          DTMB_SYNC_ADDR(0x6e)
-#define  DTMB_SYNC_CCI_DAGC_CONFIG2          DTMB_SYNC_ADDR(0x6f)
-#define  DTMB_SYNC_CCI_RP                    DTMB_SYNC_ADDR(0x70)
-#define  DTMB_SYNC_CCI_DET_THRES             DTMB_SYNC_ADDR(0x71)
-#define  DTMB_SYNC_CCI_NOTCH1_CONFIG1        DTMB_SYNC_ADDR(0x72)
-#define  DTMB_SYNC_CCI_NOTCH1_CONFIG2        DTMB_SYNC_ADDR(0x73)
-#define  DTMB_SYNC_CCI_NOTCH2_CONFIG1        DTMB_SYNC_ADDR(0x74)
-#define  DTMB_SYNC_CCI_NOTCH2_CONFIG2        DTMB_SYNC_ADDR(0x75)
-
-#endif
diff --git a/drivers/amlogic/dvb_tv/amldemod/include/addr_dtmb_sync_bit.h b/drivers/amlogic/dvb_tv/amldemod/include/addr_dtmb_sync_bit.h
deleted file mode 100644
index 51c2517d6eec..000000000000
--- a/drivers/amlogic/dvb_tv/amldemod/include/addr_dtmb_sync_bit.h
+++ /dev/null
@@ -1,91 +0,0 @@
-#ifndef __ADDR_DTMB_SYNC_BIT_H__
-#define __ADDR_DTMB_SYNC_BIT_H__
-
-struct DTMB_SYNC_TS_CFO_PN_VALUE_BITS {
-	unsigned int ts_cfo_pn1_value:16, ts_cfo_pn0_value:16;
-};
-struct DTMB_SYNC_TS_CFO_ERR_LIMIT_BITS {
-	unsigned int ts_cfo_err_limit:16, ts_cfo_pn2_value:16;
-};
-struct DTMB_SYNC_TS_CFO_PN_MODIFY_BITS {
-	unsigned int ts_cfo_pn1_modify:16, ts_cfo_pn0_modify:16;
-};
-struct DTMB_SYNC_TS_GAIN_BITS {
-	unsigned int ts_gain:2,
-	    reserved0:2,
-	    ts_sat_shift:3,
-	    reserved1:1,
-	    ts_fixpn_en:1,
-	    ts_fixpn:2, reserved2:1, ts_cfo_cut:4, ts_cfo_pn2_modify:16;
-};
-struct DTMB_SYNC_FE_CONFIG_BITS {
-	unsigned int fe_lock_len:4,
-	    fe_sat_shift:3, reserved3:1, fe_cut:4, reserved4:4, fe_modify:16;
-};
-struct DTMB_SYNC_PNPHASE_OFFSET_BITS {
-	unsigned int pnphase_offset2:4,
-	    pnphase_offset1:4, pnphase_offset0:4, reserved5:20;
-};
-struct DTMB_SYNC_PNPHASE_CONFIG_BITS {
-	unsigned int pnphase_gain:2,
-	    reserved6:2,
-	    pnphase_sat_shift:4, pnphase_cut:4, reserved7:4, pnphase_modify:16;
-};
-struct DTMB_SYNC_SFO_SFO_PN0_MODIFY_BITS {
-	unsigned int sfo_cfo_pn0_modify:16, sfo_sfo_pn0_modify:16;
-};
-struct DTMB_SYNC_SFO_SFO_PN1_MODIFY_BITS {
-	unsigned int sfo_cfo_pn1_modify:16, sfo_sfo_pn1_modify:16;
-};
-struct DTMB_SYNC_SFO_SFO_PN2_MODIFY_BITS {
-	unsigned int sfo_cfo_pn2_modify:16, sfo_sfo_pn2_modify:16;
-};
-struct DTMB_SYNC_SFO_CONFIG_BITS {
-	unsigned int sfo_sat_shift:4,
-	    sfo_gain:2,
-	    reserved8:2,
-	    sfo_dist:2,
-	    reserved9:2,
-	    sfo_cfo_cut:4, sfo_sfo_cut:4, sfo_cci_th:4, reserved10:8;
-};
-struct DTMB_SYNC_TRACK_CFO_MAX_BITS {
-	unsigned int track_cfo_max:8,
-	    track_sfo_max:8, track_max_en:1, ctrl_fe_to_th:4, reserved11:11;
-};
-struct DTMB_SYNC_CCI_DAGC_CONFIG1_BITS {
-	unsigned int cci_dagc_bypass:1,
-	    cci_dagc_power_alpha:2,
-	    cci_dagc_bw:3,
-	    cci_dagc_gain_ctrl:12,
-	    cci_dagc_gain_step_er:6, cci_dagc_gain_step:6, reserved12:2;
-};
-struct DTMB_SYNC_CCI_DAGC_CONFIG2_BITS {
-	unsigned int cci_dagc_target_power_l:8,
-	    cci_dagc_target_power_h:8,
-	    cci_dagc_target_power_ler:8, cci_dagc_target_power_her:8;
-};
-struct DTMB_SYNC_CCI_RP_BITS {
-	unsigned int cci_rpsq_n:10, reserved13:2, cci_rp_n:13, reserved14:7;
-};
-struct DTMB_SYNC_CCI_DET_THRES_BITS {
-	unsigned int cci_avr_times:5,
-	    reserved15:3, cci_det_thres:3, reserved16:21;
-};
-struct DTMB_SYNC_CCI_NOTCH1_CONFIG1_BITS {
-	unsigned int cci_notch1_a1:10,
-	    reserved17:2, cci_notch1_en:1, reserved18:19;
-};
-struct DTMB_SYNC_CCI_NOTCH1_CONFIG2_BITS {
-	unsigned int cci_notch1_b1:10,
-	    reserved19:2, cci_notch1_a2:10, reserved20:10;
-};
-struct DTMB_SYNC_CCI_NOTCH2_CONFIG1_BITS {
-	unsigned int cci_notch2_a1:10,
-	    reserved21:2, cci_notch2_en:1, reserved22:3, cci_mpthres:16;
-};
-struct DTMB_SYNC_CCI_NOTCH2_CONFIG2_BITS {
-	unsigned int cci_notch2_b1:10,
-	    reserved23:2, cci_notch2_a2:10, reserved24:10;
-};
-
-#endif
diff --git a/drivers/amlogic/dvb_tv/amldemod/include/addr_dtmb_top.h b/drivers/amlogic/dvb_tv/amldemod/include/addr_dtmb_top.h
deleted file mode 100644
index 827c87a75260..000000000000
--- a/drivers/amlogic/dvb_tv/amldemod/include/addr_dtmb_top.h
+++ /dev/null
@@ -1,71 +0,0 @@
-#ifndef __ADDR_DTMB_TOP_H__
-#define __ADDR_DTMB_TOP_H__
-
-#include "addr_dtmb_top_bit.h"
-#include "addr_dtmb_sync.h"
-#include "addr_dtmb_sync_bit.h"
-#include "addr_dtmb_che.h"
-#include "addr_dtmb_che_bit.h"
-#include "addr_dtmb_front.h"
-#include "addr_dtmb_front_bit.h"
-
-#define DTMB_DEMOD_BASE DEMOD_REG_ADDR(0x0)
-#define  DTMB_TOP_ADDR(x) (DTMB_DEMOD_BASE + (x << 2))
-
-#define  DTMB_TOP_CTRL_SW_RST               DTMB_TOP_ADDR(0x1)
-#define  DTMB_TOP_TESTBUS                   DTMB_TOP_ADDR(0x2)
-#define  DTMB_TOP_TB                        DTMB_TOP_ADDR(0x3)
-#define  DTMB_TOP_TB_V                      DTMB_TOP_ADDR(0x4)
-#define  DTMB_TOP_TB_ADDR_BEGIN             DTMB_TOP_ADDR(0x5)
-#define  DTMB_TOP_TB_ADDR_END               DTMB_TOP_ADDR(0x6)
-#define  DTMB_TOP_CTRL_ENABLE               DTMB_TOP_ADDR(0x7)
-#define  DTMB_TOP_CTRL_LOOP                 DTMB_TOP_ADDR(0x8)
-#define  DTMB_TOP_CTRL_FSM                  DTMB_TOP_ADDR(0x9)
-#define  DTMB_TOP_CTRL_AGC                  DTMB_TOP_ADDR(0xa)
-#define  DTMB_TOP_CTRL_TS_SFO_CFO           DTMB_TOP_ADDR(0xb)
-#define  DTMB_TOP_CTRL_FEC                  DTMB_TOP_ADDR(0xc)
-#define  DTMB_TOP_CTRL_INTLV_TIME           DTMB_TOP_ADDR(0xd)
-#define  DTMB_TOP_CTRL_DAGC_CCI             DTMB_TOP_ADDR(0xe)
-#define  DTMB_TOP_CTRL_TPS                  DTMB_TOP_ADDR(0xf)
-#define  DTMB_TOP_TPS_BIT                   DTMB_TOP_ADDR(0x10)
-#define  DTMB_TOP_CCI_FLG                   DTMB_TOP_ADDR(0xc7)
-#define  DTMB_TOP_TESTBUS_OUT               DTMB_TOP_ADDR(0xc8)
-#define  DTMB_TOP_TBUS_DC_ADDR              DTMB_TOP_ADDR(0xc9)
-#define  DTMB_TOP_FRONT_IQIB_CHECK          DTMB_TOP_ADDR(0xca)
-#define  DTMB_TOP_SYNC_TS                   DTMB_TOP_ADDR(0xcb)
-#define  DTMB_TOP_SYNC_PNPHASE              DTMB_TOP_ADDR(0xcd)
-#define  DTMB_TOP_CTRL_DDC_ICFO             DTMB_TOP_ADDR(0xd2)
-#define  DTMB_TOP_CTRL_DDC_FCFO             DTMB_TOP_ADDR(0xd3)
-#define  DTMB_TOP_CTRL_FSM_STATE0           DTMB_TOP_ADDR(0xd4)
-#define  DTMB_TOP_CTRL_FSM_STATE1           DTMB_TOP_ADDR(0xd5)
-#define  DTMB_TOP_CTRL_FSM_STATE2           DTMB_TOP_ADDR(0xd6)
-#define  DTMB_TOP_CTRL_FSM_STATE3           DTMB_TOP_ADDR(0xd7)
-#define  DTMB_TOP_CTRL_TS2                  DTMB_TOP_ADDR(0xd8)
-#define  DTMB_TOP_FRONT_AGC                 DTMB_TOP_ADDR(0xd9)
-#define  DTMB_TOP_FRONT_DAGC                DTMB_TOP_ADDR(0xda)
-#define  DTMB_TOP_FEC_TIME_STS              DTMB_TOP_ADDR(0xdb)
-#define  DTMB_TOP_FEC_LDPC_STS              DTMB_TOP_ADDR(0xdc)
-#define  DTMB_TOP_FEC_LDPC_IT_AVG           DTMB_TOP_ADDR(0xdd)
-#define  DTMB_TOP_FEC_LDPC_UNC_ACC          DTMB_TOP_ADDR(0xde)
-#define  DTMB_TOP_FEC_BCH_ACC               DTMB_TOP_ADDR(0xdf)
-#define  DTMB_TOP_CTRL_ICFO_ALL             DTMB_TOP_ADDR(0xe0)
-#define  DTMB_TOP_CTRL_FCFO_ALL             DTMB_TOP_ADDR(0xe1)
-#define  DTMB_TOP_CTRL_SFO_ALL              DTMB_TOP_ADDR(0xe2)
-#define  DTMB_TOP_FEC_LOCK_SNR              DTMB_TOP_ADDR(0xe3)
-#define  DTMB_TOP_CHE_SEG_FACTOR            DTMB_TOP_ADDR(0xe4)
-#define  DTMB_TOP_CTRL_CHE_WORKCNT          DTMB_TOP_ADDR(0xe5)
-#define  DTMB_TOP_CHE_OBS_STATE1            DTMB_TOP_ADDR(0xe6)
-#define  DTMB_TOP_CHE_OBS_STATE2            DTMB_TOP_ADDR(0xe7)
-#define  DTMB_TOP_CHE_OBS_STATE3            DTMB_TOP_ADDR(0xe8)
-#define  DTMB_TOP_CHE_OBS_STATE4            DTMB_TOP_ADDR(0xe9)
-#define  DTMB_TOP_CHE_OBS_STATE5            DTMB_TOP_ADDR(0xea)
-#define  DTMB_TOP_SYNC_CCI_NF1              DTMB_TOP_ADDR(0xee)
-#define  DTMB_TOP_SYNC_CCI_NF2              DTMB_TOP_ADDR(0xef)
-#define  DTMB_TOP_SYNC_CCI_NF2_POSITION     DTMB_TOP_ADDR(0xf0)
-#define  DTMB_TOP_CTRL_SYS_OFDM_CNT         DTMB_TOP_ADDR(0xf1)
-#define  DTMB_TOP_CTRL_TPS_Q_FINAL          DTMB_TOP_ADDR(0xf2)
-#define  DTMB_TOP_FRONT_DC                  DTMB_TOP_ADDR(0xf3)
-#define  DTMB_TOP_CHE_DEBUG                 DTMB_TOP_ADDR(0xf6)
-#define  DTMB_TOP_CTRL_TOTPS_READY_CNT      DTMB_TOP_ADDR(0xff)
-
-#endif
diff --git a/drivers/amlogic/dvb_tv/amldemod/include/addr_dtmb_top_bit.h b/drivers/amlogic/dvb_tv/amldemod/include/addr_dtmb_top_bit.h
deleted file mode 100644
index 4a6df5d5e8b6..000000000000
--- a/drivers/amlogic/dvb_tv/amldemod/include/addr_dtmb_top_bit.h
+++ /dev/null
@@ -1,159 +0,0 @@
-#ifndef __ADDR_DTMB_TOP_BIT_H__
-#define __ADDR_DTMB_TOP_BIT_H__
-
-union DTMB_TOP_CTRL_SW_RST_BITS {
-	unsigned int d32;
-	struct {
-		unsigned int ctrl_sw_rst:1, ctrl_sw_rst_noreg:1, reserved0:30;
-	} b;
-};
-struct DTMB_TOP_TESTBUS_BITS {
-	unsigned int testbus_addr:16, testbus_en:1, reserved1:15;
-};
-struct DTMB_TOP_TB_BITS {
-	unsigned int tb_act_width:5,
-	    reserved2:3,
-	    tb_dc_mk:3,
-	    reserved3:1, tb_capture_stop:1, tb_self_test:1, reserved4:18;
-};
-struct DTMB_TOP_CTRL_ENABLE_BITS {
-	unsigned int ctrl_enable:24, reserved5:8;
-};
-struct DTMB_TOP_CTRL_LOOP_BITS {
-	unsigned int ctrl_src_pnphase_loop:1,
-	    ctrl_src_sfo_loop:1,
-	    ctrl_ddc_fcfo_loop:1, ctrl_ddc_icfo_loop:1, reserved6:28;
-};
-struct DTMB_TOP_CTRL_FSM_BITS {
-	unsigned int ctrl_fsm_state:5,
-	    reserved7:3,
-	    ctrl_fsm_v:1, reserved8:3, ctrl_reset_state:4, reserved9:16;
-};
-struct DTMB_TOP_CTRL_AGC_BITS {
-	unsigned int ctrl_fast_agc:1,
-	    ctrl_agc_bypass:1,
-	    ts_cfo_bypass:1, sfo_strong0_bypass:1, reserved10:28;
-};
-struct DTMB_TOP_CTRL_TS_SFO_CFO_BITS {
-	unsigned int ctrl_ts_q:10,
-	    reserved11:2,
-	    ctrl_pnphase_q:7, reserved12:1, ctrl_sfo_q:4, ctrl_cfo_q:8;
-};
-struct DTMB_TOP_CTRL_FEC_BITS {
-	unsigned int reserved13:8,
-	    ctrl_ts_to_th:4,
-	    ctrl_pnphase_to_th:4,
-	    ctrl_sfo_to_th:4,
-	    ctrl_fe_to_th:4, ctrl_che_to_th:4, ctrl_fec_to_th:4;
-};
-struct DTMB_TOP_CTRL_INTLV_TIME_BITS {
-	unsigned int ctrl_intlv720_time:12, ctrl_intlv240_time:12, reserved14:8;
-};
-struct DTMB_TOP_CTRL_DAGC_CCI_BITS {
-	unsigned int dagc_mode:2,
-	    cci_dagc_mode:2,
-	    cci_bypass:1,
-	    fe_bypass:1,
-	    reserved15:1,
-	    new_sync1:1, new_sync2:1, fec_inzero_check:1, reserved16:22;
-};
-struct DTMB_TOP_CTRL_TPS_BITS {
-	unsigned int sfo_gain:2,
-	    freq_reverse:1,
-	    qam4_nr:1,
-	    intlv_mode:1,
-	    code_rate:2,
-	    constell:2,
-	    tps_carrier_mode:1,
-	    freq_reverse_known:1, tps_known:1, ctrl_tps_to_th:4, reserved17:16;
-};
-struct DTMB_TOP_CCI_FLG_BITS {
-	unsigned int cci_flg_cnt:8, m_cci_ready:1, reserved18:23;
-};
-struct DTMB_TOP_FRONT_IQIB_CHECK_BITS {
-	unsigned int front_iqib_check_b:12,
-	    front_iqib_check_a:10, reserved19:10;
-};
-struct DTMB_TOP_SYNC_TS_BITS {
-	unsigned int sync_ts_idx:2, sync_ts_pos:13, sync_ts_q:10, reserved20:7;
-};
-struct DTMB_TOP_SYNC_PNPHASE_BITS {
-	unsigned int sync_pnphase_max_q_idx:2,
-	    sync_pnphase:8, sync_pnphase_max_q:7, reserved21:15;
-};
-struct DTMB_TOP_CTRL_DDC_ICFO_BITS {
-	unsigned int ctrl_ddc_icfo:20, reserved22:12;
-};
-struct DTMB_TOP_CTRL_DDC_FCFO_BITS {
-	unsigned int ctrl_src_sfo:17, ctrl_ddc_fcfo:14, reserved23:1;
-};
-struct DTMB_TOP_CTRL_TS2_BITS {
-	unsigned int ctrl_ts2_workcnt:8,
-	    ctrl_pnphase_workcnt:8, ctrl_sfo_workcnt:8, sync_fe_workcnt:8;
-};
-struct DTMB_TOP_FRONT_AGC_BITS {
-	unsigned int front_agc_if_gain:11,
-	    front_agc_rf_gain:11, front_agc_power:10;
-};
-struct DTMB_TOP_FRONT_DAGC_BITS {
-	unsigned int front_dagc_power:8, front_dagc_gain:12, reserved24:12;
-};
-struct DTMB_TOP_FEC_LDPC_IT_AVG_BITS {
-	unsigned int fec_ldpc_it_avg:16, fec_ldpc_per_rpt:13, reserved25:3;
-};
-struct DTMB_TOP_CTRL_ICFO_ALL_BITS {
-	unsigned int ctrl_icfo_all:20, reserved26:12;
-};
-struct DTMB_TOP_CTRL_FCFO_ALL_BITS {
-	unsigned int ctrl_fcfo_all:20, reserved27:12;
-};
-struct DTMB_TOP_CTRL_SFO_ALL_BITS {
-	unsigned int ctrl_sfo_all:25, reserved28:7;
-};
-struct DTMB_TOP_FEC_LOCK_SNR_BITS {
-	unsigned int che_snr:14,
-	    fec_lock:1, reserved29:1, che_snr_average:14, reserved30:2;
-};
-struct DTMB_TOP_CHE_SEG_FACTOR_BITS {
-	unsigned int che_seg_factor:14, reserved31:18;
-};
-struct DTMB_TOP_CTRL_CHE_WORKCNT_BITS {
-	unsigned int ctrl_che_workcnt:8,
-	    ctrl_fec_workcnt:8,
-	    ctrl_constell:2,
-	    ctrl_code_rate:2,
-	    ctrl_intlv_mode:1,
-	    ctrl_qam4_nr:1, ctrl_freq_reverse:1, reserved32:9;
-};
-struct DTMB_TOP_SYNC_CCI_NF1_BITS {
-	unsigned int sync_cci_nf1_b1:10,
-	    sync_cci_nf1_a2:10, sync_cci_nf1_a1:10, reserved33:2;
-};
-struct DTMB_TOP_SYNC_CCI_NF2_BITS {
-	unsigned int sync_cci_nf2_b1:10,
-	    sync_cci_nf2_a2:10, sync_cci_nf2_a1:10, reserved34:2;
-};
-struct DTMB_TOP_SYNC_CCI_NF2_POSITION_BITS {
-	unsigned int sync_cci_nf2_position:11,
-	    sync_cci_nf1_position:11,
-	    sync_cci_nf2_det:1, sync_cci_nf1_det:1, reserved35:8;
-};
-struct DTMB_TOP_CTRL_SYS_OFDM_CNT_BITS {
-	unsigned int ctrl_sys_ofdm_cnt:8,
-	    mobi_det_power_var:19,
-	    reserved36:1, ctrl_che_working_state:2, reserved37:2;
-};
-struct DTMB_TOP_CTRL_TPS_Q_FINAL_BITS {
-	unsigned int ctrl_tps_q_final:7, ctrl_tps_suc_cnt:7, reserved38:18;
-};
-struct DTMB_TOP_FRONT_DC_BITS {
-	unsigned int front_dc_q:10, front_dc_i:10, reserved39:12;
-};
-struct DTMB_TOP_CTRL_TOTPS_READY_CNT_BITS {
-	unsigned int ctrl_dead_lock_det:1,
-	    ctrl_dead_lock:1,
-	    reserved40:2,
-	    ctrl_dead_cnt:4, reserved41:8, ctrl_totps_ready_cnt:16;
-};
-
-#endif
diff --git a/drivers/amlogic/dvb_tv/amldemod/include/aml_dtv_demod_reg.h b/drivers/amlogic/dvb_tv/amldemod/include/aml_dtv_demod_reg.h
deleted file mode 100644
index 9c318b1524f3..000000000000
--- a/drivers/amlogic/dvb_tv/amldemod/include/aml_dtv_demod_reg.h
+++ /dev/null
@@ -1,9 +0,0 @@
-#ifndef _DTV_REG_H_
-#define _DTV_REG_H_
-
-#include <linux/amlogic/iomap.h>
-
-#define DTV_WRITE_CBUS_REG(_r, _v)   aml_write_cbus(_r, _v)
-#define DTV_READ_CBUS_REG(_r)        aml_read_cbus(_r)
-
-#endif	/*  */
diff --git a/drivers/amlogic/dvb_tv/amldemod/include/amlfrontend.h b/drivers/amlogic/dvb_tv/amldemod/include/amlfrontend.h
deleted file mode 100644
index 01143061a99b..000000000000
--- a/drivers/amlogic/dvb_tv/amldemod/include/amlfrontend.h
+++ /dev/null
@@ -1,64 +0,0 @@
-/*****************************************************************
-**
-**  Copyright (C) 2010 Amlogic,Inc.
-**  All rights reserved
-**        Filename : amlfrontend.h
-**
-**  comment:
-**        Driver for aml demodulator
-**
-*****************************************************************/
-
-#ifndef _AMLFRONTEND_H
-#define _AMLFRONTEND_H
-
-struct amlfe_config {
-	int fe_mode;
-	int i2c_id;
-	int tuner_type;
-	int tuner_addr;
-};
-enum Gxtv_Demod_Tuner_If {
-	Si2176_5M_If = 5,
-	Si2176_6M_If = 6
-};
-/* 0 -DVBC, 1-DVBT, ISDBT, 2-ATSC */
-enum Gxtv_Demod_Dvb_Mode {
-	Gxtv_Dvbc = 0,
-	Gxtv_Dvbt_Isdbt = 1,
-	Gxtv_Atsc = 2,
-	Gxtv_Dtmb = 3,
-};
-#define Adc_Clk_35M             35714	/* adc clk    dvbc */
-#define Demod_Clk_71M   71428	/* demod clk */
-
-#define Adc_Clk_24M             24000
-#define Demod_Clk_72M       72000
-#define Demod_Clk_60M       60000
-
-#define Adc_Clk_28M             28571	/* dvbt,isdbt */
-#define Demod_Clk_66M   66666
-
-#define Adc_Clk_26M                     26000	/* atsc  air */
-#define Demod_Clk_78M     78000	/*  */
-
-#define Adc_Clk_25_2M                   25200	/* atsc  cable */
-#define Demod_Clk_75M     75600	/*  */
-
-#define Adc_Clk_25M                     25000	/* dtmb */
-#define Demod_Clk_100M    100000	/*  */
-#define Demod_Clk_180M    180000	/*  */
-#define Demod_Clk_200M    200000	/*  */
-#define Demod_Clk_225M    225000
-
-#define Adc_Clk_27M                     27777	/* atsc */
-#define Demod_Clk_83M     83333	/*  */
-
-enum M6_Demod_Pll_Mode {
-	Cry_mode = 0,
-	Adc_mode = 1
-};
-
-int M6_Demod_Dtmb_Init(struct aml_fe_dev *dev);
-
-#endif
diff --git a/drivers/amlogic/dvb_tv/amldemod/include/demod_func.h b/drivers/amlogic/dvb_tv/amldemod/include/demod_func.h
deleted file mode 100644
index 4587b094c573..000000000000
--- a/drivers/amlogic/dvb_tv/amldemod/include/demod_func.h
+++ /dev/null
@@ -1,604 +0,0 @@
-#ifdef DEMOD_FUNC_H
-#else
-#define DEMOD_FUNC_H
-
-#include <linux/types.h>
-/* #include <mach/am_regs.h> */
-/*#include <mach/register.h>
- * #include <mach/avosstyle_io.h>
- #include <mach/io.h>*/
-#include <linux/dvb/aml_demod.h>
-#include "aml_fe.h"
-#include "amlfrontend.h"
-#include "addr_dtmb_top.h"
-#include "c_stb_define.h"
-#include "c_stb_regs_define.h"
-#include <linux/io.h>
-
-/* #define G9_TV */
-#define GX_TV
-#define safe_addr
-
-#define PWR_ON    1
-#define PWR_OFF   0
-
-#define dtmb_mobile_mode
-
-
-/* void __iomem *meson_reg_demod_map[1024]; */
-
-#define IO_CBUS_PHY_BASE        (0xc0800000)
-
-#ifdef safe_addr
-#define IO_DEMOD_BASE           (0xc8844000)
-#define IO_AOBUS_BASE           (0xc8100000)
-#define IO_HIU_BASE                     (0xc883c000)
-#else
-#define IO_DEMOD_BASE           (0xda844000)
-#define IO_AOBUS_BASE           (0xda100000)
-#define IO_HIU_BASE                     (0xda83c000)
-#endif
-
-#define DEMOD_REG_OFFSET(reg)           (reg & 0xfffff)
-#define DEMOD_REG_ADDR(reg)             (IO_DEMOD_BASE + DEMOD_REG_OFFSET(reg))
-
-#define DEMOD_CBUS_REG_OFFSET(reg)              (reg << 2)
-#define DEMOD_CBUS_REG_ADDR(reg)                (IO_CBUS_PHY_BASE + \
-						 DEMOD_CBUS_REG_OFFSET(reg))
-
-#define DEMOD_AOBUS_REG_OFFSET(reg)             ((reg))
-#define DEMOD_AOBUS_REG_ADDR(reg)               (IO_AOBUS_BASE + \
-						 DEMOD_AOBUS_REG_OFFSET(reg))
-
-/* #define DEMOD_BASE     APB_REG_ADDR(0x20000) */
-#define DEMOD_BASE DEMOD_REG_ADDR(0x0)	/* 0xc8020000 */
-
-/* #define DEMOD_BASE 0xc8020000 */
-#define DTMB_BASE  (DEMOD_BASE + 0x000)
-#define DVBT_BASE  (DEMOD_BASE + 0x000)
-#define ISDBT_BASE (DEMOD_BASE + 0x000)
-#define QAM_BASE   (DEMOD_BASE + 0x400)
-#define ATSC_BASE  (DEMOD_BASE + 0x800)
-#define DEMOD_CFG_BASE  (DEMOD_BASE + 0xC00)
-
-/* #ifdef TXL_TV */
-#define TXLTV_ADC_RESET_VALUE          0xca6a2110	/* 0xce7a2110 */
-#define TXLTV_ADC_REG1_VALUE           0x5d414260
-#define TXLTV_ADC_REG2_VALUE           0x5ba00384	/* 0x34e0bf81 */
-#define TXLTV_ADC_REG2_VALUE_CRY       0x34e0bf81
-#define TXLTV_ADC_REG3_VALUE           0x4a6a2110	/* 0x4e7a2110 */
-#define TXLTV_ADC_REG4_VALUE           0x02913004
-#define TXLTV_ADC_REG4_CRY_VALUE 0x301
-#define TXLTV_ADC_REG7_VALUE           0x00102038
-#define TXLTV_ADC_REG8_VALUE           0x00000406
-#define TXLTV_ADC_REG9_VALUE           0x00082183
-#define TXLTV_ADC_REGA_VALUE           0x80480240
-#define TXLTV_ADC_REGB_VALUE           0x22000442
-#define TXLTV_ADC_REGC_VALUE           0x00034a00
-#define TXLTV_ADC_REGD_VALUE           0x00005000
-#define TXLTV_ADC_REGE_VALUE           0x00000200
-
-
-/* DADC DPLL */
-#define ADC_REG1         (IO_HIU_BASE + (0xaa << 2))
-#define ADC_REG2         (IO_HIU_BASE + (0xab << 2))
-#define ADC_REG3         (IO_HIU_BASE + (0xac << 2))
-#define ADC_REG4         (IO_HIU_BASE + (0xad << 2))
-
-#define ADC_REG5         (IO_HIU_BASE + (0x73 << 2))
-#define ADC_REG6         (IO_HIU_BASE + (0x74 << 2))
-
-#define ADC_REGB         (IO_HIU_BASE + (0xaf << 2))
-#define ADC_REGC         (IO_HIU_BASE + (0x9e << 2))
-#define ADC_REGD         (IO_HIU_BASE + (0x9f << 2))
-
-/* DADC REG */
-#define ADC_REG7         (IO_HIU_BASE + (0x27 << 2))
-#define ADC_REG8         (IO_HIU_BASE + (0x28 << 2))
-#define ADC_REG9         (IO_HIU_BASE + (0x2a << 2))
-#define ADC_REGA         (IO_HIU_BASE + (0x2b << 2))
-#define ADC_REGE         (IO_HIU_BASE + (0xbd << 2))
-
-/* #endif  */
-
-
-/* #ifdef GX_TV */
-
-#define ADC_RESET_VALUE          0x8a2a2110	/* 0xce7a2110 */
-#define ADC_REG1_VALUE           0x00100228
-#define ADC_REG2_VALUE           0x34e0bf80	/* 0x34e0bf81 */
-#define ADC_REG2_VALUE_CRY       0x34e0bf81
-#define ADC_REG3_VALUE           0x0a2a2110	/* 0x4e7a2110 */
-#define ADC_REG4_VALUE           0x02933800
-#define ADC_REG4_CRY_VALUE 0x301
-#define ADC_REG7_VALUE           0x01411036
-#define ADC_REG8_VALUE           0x00000000
-#define ADC_REG9_VALUE           0x00430036
-#define ADC_REGA_VALUE           0x80480240
-#if 0
-/* DADC DPLL */
-#define ADC_REG1         (IO_HIU_BASE + (0xaa << 2))
-#define ADC_REG2         (IO_HIU_BASE + (0xab << 2))
-#define ADC_REG3         (IO_HIU_BASE + (0xac << 2))
-#define ADC_REG4         (IO_HIU_BASE + (0xad << 2))
-
-#define ADC_REG5         (IO_HIU_BASE + (0x73 << 2))
-#define ADC_REG6         (IO_HIU_BASE + (0x74 << 2))
-
-/* DADC REG */
-#define ADC_REG7         (IO_HIU_BASE + (0x27 << 2))
-#define ADC_REG8         (IO_HIU_BASE + (0x28 << 2))
-#define ADC_REG9         (IO_HIU_BASE + (0x2a << 2))
-#define ADC_REGA         (IO_HIU_BASE + (0x2b << 2))
-#endif
-/* #endif */
-
-#ifdef G9_TV
-
-#define ADC_RESET_VALUE          0x8a2a2110	/* 0xce7a2110 */
-#define ADC_REG1_VALUE           0x00100228
-#define ADC_REG2_VALUE           0x34e0bf80	/* 0x34e0bf81 */
-#define ADC_REG2_VALUE_CRY       0x34e0bf81
-#define ADC_REG3_VALUE           0x0a2a2110	/* 0x4e7a2110 */
-#define ADC_REG4_VALUE           0x02933800
-#define ADC_REG4_CRY_VALUE 0x301
-#define ADC_REG7_VALUE           0x01411036
-#define ADC_REG8_VALUE           0x00000000
-#define ADC_REG9_VALUE           0x00430036
-#define ADC_REGA_VALUE           0x80480240
-
-/* DADC DPLL */
-#define ADC_REG1         0x10aa
-#define ADC_REG2         0x10ab
-#define ADC_REG3         0x10ac
-#define ADC_REG4         0x10ad
-
-#define ADC_REG5         0x1073
-#define ADC_REG6         0x1074
-
-/* DADC REG */
-#define ADC_REG7         0x1027
-#define ADC_REG8         0x1028
-#define ADC_REG9         0x102a
-#define ADC_REGA         0x102b
-#endif
-
-#ifdef M6_TV
-#define ADC_REG1_VALUE           0x003b0232
-#define ADC_REG2_VALUE           0x814d3928
-#define ADC_REG3_VALUE           0x6b425012
-#define ADC_REG4_VALUE           0x101
-#define ADC_REG4_CRY_VALUE 0x301
-#define ADC_REG5_VALUE           0x70b
-#define ADC_REG6_VALUE           0x713
-
-#define ADC_REG1         0x10aa
-#define ADC_REG2         0x10ab
-#define ADC_REG3         0x10ac
-#define ADC_REG4         0x10ad
-#define ADC_REG5         0x1073
-#define ADC_REG6         0x1074
-#endif
-
-#define DEMOD_REG1_VALUE                 0x0000d007
-#define DEMOD_REG2_VALUE                 0x2e805400
-#define DEMOD_REG3_VALUE                 0x201
-
-#define DEMOD_REG1               (DEMOD_BASE + 0xc00)
-#define DEMOD_REG2               (DEMOD_BASE + 0xc04)
-#define DEMOD_REG3               (DEMOD_BASE + 0xc08)
-#define DEMOD_REG4               (DEMOD_BASE + 0xc0c)
-
-/* #define Wr(addr, data)   WRITE_CBUS_REG(addr, data)*/
-/* #define Rd(addr)             READ_CBUS_REG(addr)  */
-
-/*#define Wr(addr, data) *(volatile unsigned long *)(addr) = (data)*/
-/*#define Rd(addr) *(volatile unsigned long *)(addr)*/
-
-enum {
-	enable_mobile,
-	disable_mobile
-};
-
-enum {
-	OPEN_TIME_EQ,
-	CLOSE_TIME_EQ
-};
-
-enum {
-	AMLOGIC_DTMB_STEP0,
-	AMLOGIC_DTMB_STEP1,
-	AMLOGIC_DTMB_STEP2,
-	AMLOGIC_DTMB_STEP3,
-	AMLOGIC_DTMB_STEP4,
-	AMLOGIC_DTMB_STEP5,	/* time eq */
-	AMLOGIC_DTMB_STEP6,	/* set normal mode sc */
-	AMLOGIC_DTMB_STEP7,
-	AMLOGIC_DTMB_STEP8,	/* set time eq mode */
-	AMLOGIC_DTMB_STEP9,	/* reset */
-	AMLOGIC_DTMB_STEP10,	/* set normal mode mc */
-	AMLOGIC_DTMB_STEP11,
-};
-
-enum {
-	DTMB_IDLE = 0,
-	DTMB_AGC_READY = 1,
-	DTMB_TS1_READY = 2,
-	DTMB_TS2_READY = 3,
-	DTMB_FE_READY = 4,
-	DTMB_PNPHASE_READY = 5,
-	DTMB_SFO_INIT_READY = 6,
-	DTMB_TS3_READY = 7,
-	DTMB_PM_INIT_READY = 8,
-	DTMB_CHE_INIT_READY = 9,
-	DTMB_FEC_READY = 10
-};
-
-/* i2c functions */
-/* int aml_i2c_sw_test_bus(struct aml_demod_i2c *adap, char *name); */
-int am_demod_i2c_xfer(struct aml_demod_i2c *adap, struct i2c_msg *msgs,
-		      int num);
-int init_tuner_fj2207(struct aml_demod_sta *demod_sta,
-		      struct aml_demod_i2c *adap);
-int set_tuner_fj2207(struct aml_demod_sta *demod_sta,
-		     struct aml_demod_i2c *adap);
-
-int get_fj2207_ch_power(void);
-int tuner_get_ch_power(struct aml_fe_dev *adap);
-int tda18273_tuner_set_frequncy(unsigned int dwFrequency,
-				unsigned int dwStandard);
-int dtmb_get_power_strength(int agc_gain);
-
-
-int tuner_set_ch(struct aml_demod_sta *demod_sta,
-		 struct aml_demod_i2c *demod_i2c);
-
-/* dvbt */
-int dvbt_set_ch(struct aml_demod_sta *demod_sta,
-		struct aml_demod_i2c *demod_i2c,
-		struct aml_demod_dvbt *demod_dvbt);
-
-struct demod_status_ops {
-	int (*get_status)(struct aml_demod_sta *demod_sta,
-			   struct aml_demod_i2c *demod_i2c);
-	int (*get_ber)(struct aml_demod_sta *demod_sta,
-			struct aml_demod_i2c *demod_i2c);
-	int (*get_snr)(struct aml_demod_sta *demod_sta,
-			struct aml_demod_i2c *demod_i2c);
-	int (*get_strength)(struct aml_demod_sta *demod_sta,
-			     struct aml_demod_i2c *demod_i2c);
-	int (*get_ucblocks)(struct aml_demod_sta *demod_sta,
-			     struct aml_demod_i2c *demod_i2c);
-};
-
-struct demod_status_ops *dvbt_get_status_ops(void);
-
-/* dvbc */
-
-int dvbc_set_ch(struct aml_demod_sta *demod_sta,
-		struct aml_demod_i2c *demod_i2c,
-		struct aml_demod_dvbc *demod_dvbc);
-int dvbc_status(struct aml_demod_sta *demod_sta,
-		struct aml_demod_i2c *demod_i2c,
-		struct aml_demod_sts *demod_sts);
-int dvbc_isr_islock(void);
-void dvbc_isr(struct aml_demod_sta *demod_sta);
-u32 dvbc_set_qam_mode(unsigned char mode);
-u32 dvbc_get_status(void);
-u32 dvbc_set_auto_symtrack(void);
-int dvbc_timer_init(void);
-void dvbc_timer_exit(void);
-int dvbc_cci_task(void *);
-int dvbc_get_cci_task(void);
-void dvbc_create_cci_task(void);
-void dvbc_kill_cci_task(void);
-
-/* atsc */
-
-int atsc_set_ch(struct aml_demod_sta *demod_sta,
-		struct aml_demod_i2c *demod_i2c,
-		struct aml_demod_atsc *demod_atsc);
-int check_atsc_fsm_status(void);
-
-void atsc_write_reg(int reg_addr, int reg_data);
-
-unsigned long atsc_read_reg(int reg_addr);
-
-unsigned long atsc_read_iqr_reg(void);
-
-int atsc_qam_set(fe_modulation_t mode);
-
-void qam_initial(int qam_id);
-
-/* dtmb */
-
-int dtmb_set_ch(struct aml_demod_sta *demod_sta,
-		struct aml_demod_i2c *demod_i2c,
-		struct aml_demod_dtmb *demod_atsc);
-
-void dtmb_reset(void);
-
-int dtmb_check_status_gxtv(struct dvb_frontend *fe);
-int dtmb_check_status_txl(struct dvb_frontend *fe);
-
-
-void dtmb_write_reg(int reg_addr, int reg_data);
-int dtmb_read_reg(int reg_addr);
-void dtmb_register_reset(void);
-
-/* demod functions */
-unsigned long apb_read_reg_collect(unsigned long addr);
-void apb_write_reg_collect(unsigned int addr, unsigned int data);
-void apb_write_reg(unsigned int reg, unsigned int val);
-unsigned long apb_read_reg_high(unsigned long addr);
-unsigned long apb_read_reg(unsigned long reg);
-int app_apb_write_reg(int addr, int data);
-int app_apb_read_reg(int addr);
-
-void demod_set_cbus_reg(unsigned data, unsigned addr);
-unsigned demod_read_cbus_reg(unsigned addr);
-void demod_set_demod_reg(unsigned data, unsigned addr);
-unsigned demod_read_demod_reg(unsigned addr);
-
-/* extern int clk_measure(char index); */
-
-void ofdm_initial(int bandwidth,
-		  /* 00:8M 01:7M 10:6M 11:5M */
-		  int samplerate,
-		  /* 00:45M 01:20.8333M 10:20.7M 11:28.57 */
-		  int IF,
-		  /* 000:36.13M 001:-5.5M 010:4.57M 011:4M 100:5M */
-		  int mode,
-		  /* 00:DVBT,01:ISDBT */
-		  int tc_mode
-		  /* 0: Unsigned, 1:TC */);
-
-void monitor_isdbt(void);
-void demod_set_reg(struct aml_demod_reg *demod_reg);
-void demod_get_reg(struct aml_demod_reg *demod_reg);
-
-/* void demod_calc_clk(struct aml_demod_sta *demod_sta); */
-int demod_set_sys(struct aml_demod_sta *demod_sta,
-		  struct aml_demod_i2c *demod_i2c,
-		  struct aml_demod_sys *demod_sys);
-/* int demod_get_sys(struct aml_demod_i2c *demod_i2c, */
-/* struct aml_demod_sys *demod_sys); */
-/* int dvbt_set_ch(struct aml_demod_sta *demod_sta, */
-/* struct aml_demod_i2c *demod_i2c, */
-/* struct aml_demod_dvbt *demod_dvbt); */
-/* int tuner_set_ch (struct aml_demod_sta *demod_sta, */
-/* struct aml_demod_i2c *demod_i2c); */
-
-/* typedef char               int8_t; */
-/* typedef short int          int16_t; */
-/* typedef int                int32_t; */
-/* typedef long               int64_t; */
-/*typedef unsigned char      uint8_t;
- * typedef unsigned short int uint16_t;
- * typedef unsigned int       uint32_t;
- * typedef unsigned long      uint64_t;*/
-
-/*typedef unsigned   char    u8_t;
- * typedef signed     char    s8_t;
- * typedef unsigned   short   u16_t;
- * typedef signed     short   s16_t;
- * typedef unsigned   int     u32_t;
- * typedef signed     int     s32_t;
- * typedef unsigned   long    u64_t;
- * typedef signed     long    s64_t;*/
-
-/* #define extadc */
-
-/* for g9tv */
-void adc_dpll_setup(int clk_a, int clk_b, int clk_sys);
-void demod_power_switch(int pwr_cntl);
-
-union adc_pll_cntl {
-	/** raw register data */
-	uint32_t d32;
-	/** register bits */
-	struct {
-		unsigned pll_m:9;
-		unsigned pll_n:5;
-		unsigned pll_od0:2;
-		unsigned pll_od1:2;
-		unsigned pll_od2:2;
-		unsigned pll_xd0:6;
-		unsigned pll_xd1:6;
-	} b;
-};
-
-union adc_pll_cntl2 {
-	/** raw register data */
-	uint32_t d32;
-	/** register bits */
-	struct {
-		unsigned output_mux_ctrl:4;
-		unsigned div2_ctrl:1;
-		unsigned b_polar_control:1;
-		unsigned a_polar_control:1;
-		unsigned gate_ctrl:6;
-		unsigned tdc_buf:8;
-		unsigned lm_s:6;
-		unsigned lm_w:4;
-		unsigned reserved:1;
-	} b;
-};
-
-union adc_pll_cntl3 {
-	/** raw register data */
-	uint32_t d32;
-	/** register bits */
-	struct {
-		unsigned afc_dsel_in:1;
-		unsigned afc_dsel_bypass:1;
-		unsigned dco_sdmck_sel:2;
-		unsigned dc_vc_in:2;
-		unsigned dco_m_en:1;
-		unsigned dpfd_lmode:1;
-		unsigned filter_acq1:11;
-		unsigned enable:1;
-		unsigned filter_acq2:11;
-		unsigned reset:1;
-	} b;
-};
-
-union adc_pll_cntl4 {
-	/** raw register data */
-	uint32_t d32;
-	/** register bits */
-	struct {
-		unsigned reve:12;
-		unsigned tdc_en:1;
-		unsigned dco_sdm_en:1;
-		unsigned dco_iup:2;
-		unsigned pvt_fix_en:1;
-		unsigned iir_bypass_n:1;
-		unsigned pll_od3:2;
-		unsigned filter_pvt1:4;
-		unsigned filter_pvt2:4;
-		unsigned reserved:4;
-	} b;
-};
-
-/* ///////////////////////////////////////////////////////////////// */
-
-union demod_dig_clk {
-	/** raw register data */
-	uint32_t d32;
-	/** register bits */
-	struct {
-		unsigned demod_clk_div:7;
-		unsigned reserved0:1;
-		unsigned demod_clk_en:1;
-		unsigned demod_clk_sel:2;
-		unsigned reserved1:5;
-		unsigned adc_extclk_div:7;	/* 34 */
-		unsigned use_adc_extclk:1;	/* 1 */
-		unsigned adc_extclk_en:1;	/* 1 */
-		unsigned adc_extclk_sel:3;	/* 1 */
-		unsigned reserved2:4;
-	} b;
-};
-
-union demod_adc_clk {
-	/** raw register data */
-	uint32_t d32;
-	/** register bits */
-	struct {
-		unsigned pll_m:9;
-		unsigned pll_n:5;
-		unsigned pll_od:2;
-		unsigned pll_xd:5;
-		unsigned reserved0:3;
-		unsigned pll_ss_clk:4;
-		unsigned pll_ss_en:1;
-		unsigned reset:1;
-		unsigned pll_pd:1;
-		unsigned reserved1:1;
-	} b;
-};
-
-union demod_cfg0 {
-	/** raw register data */
-	uint32_t d32;
-	/** register bits */
-	struct {
-		unsigned mode:4;
-		unsigned ts_sel:4;
-		unsigned test_bus_clk:1;
-		unsigned adc_ext:1;
-		unsigned adc_rvs:1;
-		unsigned adc_swap:1;
-		unsigned adc_format:1;
-		unsigned adc_regout:1;
-		unsigned adc_regsel:1;
-		unsigned adc_regadj:5;
-		unsigned adc_value:10;
-		unsigned adc_test:1;
-		unsigned ddr_sel:1;
-	} b;
-};
-
-union demod_cfg1 {
-	/** raw register data */
-	uint32_t d32;
-	/** register bits */
-	struct {
-		unsigned reserved:8;
-		unsigned ref_top:2;
-		unsigned ref_bot:2;
-		unsigned cml_xs:2;
-		unsigned cml_1s:2;
-		unsigned vdda_sel:2;
-		unsigned bias_sel_sha:2;
-		unsigned bias_sel_mdac2:2;
-		unsigned bias_sel_mdac1:2;
-		unsigned fast_chg:1;
-		unsigned rin_sel:3;
-		unsigned en_ext_vbg:1;
-		unsigned en_cmlgen_res:1;
-		unsigned en_ext_vdd12:1;
-		unsigned en_ext_ref:1;
-	} b;
-};
-
-union demod_cfg2 {
-	/** raw register data */
-	uint32_t d32;
-	/** register bits */
-	struct {
-		unsigned en_adc:1;
-		unsigned biasgen_ibipt_sel:2;
-		unsigned biasgen_ibic_sel:2;
-		unsigned biasgen_rsv:4;
-		unsigned biasgen_en:1;
-		unsigned biasgen_bias_sel_adc:2;
-		unsigned biasgen_bias_sel_cml1:2;
-		unsigned biasgen_bias_sel_ref_op:2;
-		unsigned clk_phase_sel:1;
-		unsigned reserved:15;
-	} b;
-};
-
-union demod_cfg3 {
-	/** raw register data */
-	uint32_t d32;
-	/** register bits */
-	struct {
-		unsigned dc_arb_mask:3;
-		unsigned dc_arb_enable:1;
-		unsigned reserved:28;
-	} b;
-};
-
-struct atsc_cfg {
-	int adr;
-	int dat;
-	int rw;
-};
-
-struct agc_power_tab {
-	char name[128];
-	int level;
-	int ncalcE;
-	int *calcE;
-};
-
-struct dtmb_cfg {
-	int dat;
-	int adr;
-	int rw;
-};
-
-void dtvpll_lock_init(void);
-void dtvpll_init_flag(int on);
-void demod_set_irq_mask(void);
-void demod_clr_irq_stat(void);
-void demod_set_adc_core_clk(int, int, int);
-void demod_set_adc_core_clk_fix(int clk_adc, int clk_dem);
-void calculate_cordic_para(void);
-void ofdm_read_all_regs(void);
-extern int aml_fe_analog_set_frontend(struct dvb_frontend *fe);
-
-#endif
diff --git a/drivers/amlogic/dvb_tv/amldemod/tuner_func.c b/drivers/amlogic/dvb_tv/amldemod/tuner_func.c
deleted file mode 100644
index 20df2991d2b4..000000000000
--- a/drivers/amlogic/dvb_tv/amldemod/tuner_func.c
+++ /dev/null
@@ -1,169 +0,0 @@
-#include <linux/kernel.h>
-#include <linux/i2c.h>
-#include <linux/dvb/aml_demod.h>
-#include "demod_func.h"
-#include "../aml_fe.h"
-
-int tuner_get_ch_power(struct aml_fe_dev *adap)
-{
-	int strength = 0;
-	int agc_if_gain;
-
-	struct dvb_frontend *dvbfe;
-	dvbfe = get_si2177_tuner();
-	if (dvbfe != NULL)
-		if (dvbfe->ops.tuner_ops.get_strength)
-			strength = dvbfe->ops.tuner_ops.get_strength(dvbfe);
-	if (strength <= -56) {
-		agc_if_gain =
-			((dtmb_read_reg(DTMB_TOP_FRONT_AGC))&0x3ff);
-		strength = dtmb_get_power_strength(agc_if_gain);
-	 }
-
-	return strength;
-}
-
-struct dvb_tuner_info *tuner_get_info(int type, int mode)
-{
-	/*type :  0-NULL, 1-DCT7070, 2-Maxliner, 3-FJ2207, 4-TD1316 */
-	/*mode: 0-DVBC 1-DVBT */
-	static struct dvb_tuner_info tinfo_null = { };
-
-	static struct dvb_tuner_info tinfo_MXL5003S[2] = {
-		[1] = { /*DVBT*/ .name		= "Maxliner",
-				 .frequency_min = 44000000,
-				 .frequency_max = 885000000, }
-	};
-	static struct dvb_tuner_info tinfo_FJ2207[2] = {
-		[0] = { /*DVBC*/ .name		= "FJ2207",
-				 .frequency_min = 54000000,
-				 .frequency_max = 870000000, },
-		[1] = { /*DVBT*/ .name		= "FJ2207",
-				 .frequency_min = 174000000,
-				 .frequency_max = 864000000, },
-	};
-	static struct dvb_tuner_info tinfo_DCT7070[2] = {
-		[0] = { /*DVBC*/ .name		= "DCT7070",
-				 .frequency_min = 51000000,
-				 .frequency_max = 860000000, }
-	};
-	static struct dvb_tuner_info tinfo_TD1316[2] = {
-		[1] = { /*DVBT*/ .name		= "TD1316",
-				 .frequency_min = 51000000,
-				 .frequency_max = 858000000, }
-	};
-	static struct dvb_tuner_info tinfo_SI2176[2] = {
-		[0] = { /*DVBC*/
-			/*#error please add SI2176 code*/
-			.name		= "SI2176",
-			.frequency_min	= 51000000,
-			.frequency_max	= 860000000,
-		}
-	};
-
-	struct dvb_tuner_info *tinfo[] = {
-		&tinfo_null,
-		tinfo_DCT7070,
-		tinfo_MXL5003S,
-		tinfo_FJ2207,
-		tinfo_TD1316,
-		tinfo_SI2176
-	};
-
-	if ((type < 0) || (type > 4) || (mode < 0) || (mode > 1))
-		return tinfo[0];
-
-	return &tinfo[type][mode];
-}
-
-struct agc_power_tab *tuner_get_agc_power_table(int type)
-{
-	/*type :  0-NULL, 1-DCT7070, 2-Maxliner, 3-FJ2207, 4-TD1316 */
-	static int calcE_FJ2207[31] = {
-		87, 118, 138, 154, 172, 197, 245,
-		273, 292, 312, 327, 354, 406, 430,
-		448, 464, 481, 505, 558, 583, 599,
-		616, 632, 653, 698, 725, 745, 762,
-		779, 801, 831 };
-	static int calcE_Maxliner[79] = {
-		543, 552, 562, 575, 586, 596, 608,
-		618, 627, 635, 645, 653, 662, 668,
-		678, 689, 696, 705, 715, 725, 733,
-		742, 752, 763, 769, 778, 789, 800,
-		807, 816, 826, 836, 844, 854, 864,
-		874, 884, 894, 904, 913, 923, 932,
-		942, 951, 961, 970, 980, 990, 1000,
-		1012, 1022, 1031, 1040, 1049, 1059,
-		1069, 1079, 1088, 1098, 1107, 1115,
-		1123, 1132, 1140, 1148, 1157, 1165,
-		1173, 1179, 1186, 1192, 1198, 1203,
-		1208, 1208, 1214, 1217, 1218, 1220 };
-
-	static struct agc_power_tab power_tab[] = {
-		[0] = { "null", 0, 0, NULL },
-		[1] = {
-			.name	= "DCT7070",
-			.level	= 0,
-			.ncalcE = 0,
-			.calcE	= NULL,
-		},
-		[2] = {
-			.name	= "Maxlear",
-			.level	= -22,
-			.ncalcE = sizeof(calcE_Maxliner) / sizeof(int),
-			.calcE	= calcE_Maxliner,
-		},
-		[3] = {
-			.name	= "FJ2207",
-			.level	= -62,
-			.ncalcE = sizeof(calcE_FJ2207) / sizeof(int),
-			.calcE	= calcE_FJ2207,
-		},
-		[4] = {
-			.name	= "TD1316",
-			.level	= 0,
-			.ncalcE = 0,
-			.calcE	= NULL,
-		},
-	};
-
-	if (type >= 2 && type <= 3)
-		return &power_tab[type];
-	else
-		return &power_tab[3];
-};
-
-int agc_power_to_dbm(int agc_gain, int ad_power, int offset, int tuner)
-{
-	struct agc_power_tab *ptab = tuner_get_agc_power_table(tuner);
-	int est_rf_power;
-	int j;
-
-	for (j = 0; j < ptab->ncalcE; j++)
-		if (agc_gain <= ptab->calcE[j])
-			break;
-
-	est_rf_power = ptab->level - j - (ad_power >> 4) + 12 + offset;
-
-	return est_rf_power;
-}
-
-int dtmb_get_power_strength(int agc_gain)
-{
-	int strength;
-	int j;
-	static int calcE_R840[13] = {
-		1010, 969, 890, 840, 800,
-		760, 720, 680, 670, 660,
-		510, 440, 368};
-	for (j = 0; j < sizeof(calcE_R840)/sizeof(int); j++)
-		if (agc_gain >= calcE_R840[j])
-			break;
-	if (agc_gain >= 440)
-		strength = -90+j*3;
-	else
-		strength = -56;
-	return strength;
-}
-
-
diff --git a/drivers/amlogic/dvb_tv/amsmc.h b/drivers/amlogic/dvb_tv/amsmc.h
deleted file mode 100644
index 53b9d295cdc6..000000000000
--- a/drivers/amlogic/dvb_tv/amsmc.h
+++ /dev/null
@@ -1,61 +0,0 @@
-/*
- * AMLOGIC Smart card driver.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the named License,
- * or any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- */
-
-#ifndef _AMSMC_H
-#define _AMSMC_H
-
-/* #include <asm/types.h> */
-#include <linux/types.h>
-
-#define AMSMC_MAX_ATR_LEN    33
-
-enum {
-	AMSMC_CARDOUT = 0,
-	AMSMC_CARDIN = 1
-};
-
-struct am_smc_atr {
-	char    atr[AMSMC_MAX_ATR_LEN];
-	int     atr_len;
-};
-
-struct am_smc_param {
-	int     f;
-	int     d;
-	int     n;
-	int     bwi;
-	int     cwi;
-	int     bgt;
-	int     freq;
-	int     recv_invert;
-	int     recv_lsb_msb;
-	int     recv_no_parity;
-	int     recv_parity;
-	int     xmit_invert;
-	int     xmit_lsb_msb;
-	int     xmit_retries;
-	int     xmit_repeat_dis;
-	int     xmit_parity;
-};
-
-#define AMSMC_IOC_MAGIC  'C'
-
-#define AMSMC_IOC_RESET        _IOR(AMSMC_IOC_MAGIC, 0x00, struct am_smc_atr)
-#define AMSMC_IOC_GET_STATUS   _IOR(AMSMC_IOC_MAGIC, 0x01, int)
-#define AMSMC_IOC_ACTIVE       _IO(AMSMC_IOC_MAGIC, 0x02)
-#define AMSMC_IOC_DEACTIVE     _IO(AMSMC_IOC_MAGIC, 0x03)
-#define AMSMC_IOC_GET_PARAM    _IOR(AMSMC_IOC_MAGIC, 0x04, struct am_smc_param)
-#define AMSMC_IOC_SET_PARAM    _IOW(AMSMC_IOC_MAGIC, 0x05, struct am_smc_param)
-
-#endif
diff --git a/drivers/amlogic/dvb_tv/ascot3.c b/drivers/amlogic/dvb_tv/ascot3.c
new file mode 100644
index 000000000000..0b424e888be7
--- /dev/null
+++ b/drivers/amlogic/dvb_tv/ascot3.c
@@ -0,0 +1,563 @@
+/*
+ * ascot3.c
+ *
+ * Sony Ascot3 DVB-T/T2/C tuner driver
+ *
+ * Copyright (C) 2015 Sasa Savic <sasa.savic.sr@gmail.com>
+ *
+ * Based on ascot2e driver
+ *
+ * Copyright 2012 Sony Corporation
+ * Copyright (C) 2014 NetUP Inc.
+ * Copyright (C) 2014 Sergey Kozlov <serjk@netup.ru>
+ * Copyright (C) 2014 Abylay Ospan <aospan@netup.ru>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+  */
+
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/dvb/frontend.h>
+#include <linux/types.h>
+#include "ascot3.h"
+#include "dvb_frontend.h"
+
+#define MAX_WRITE_REGSIZE 32
+
+enum ascot3_state {
+	STATE_UNKNOWN,
+	STATE_SLEEP,
+	STATE_ACTIVE
+};
+
+struct ascot3_priv {
+	u32			frequency;
+	u8			i2c_address;
+	struct i2c_adapter	*i2c;
+	enum ascot3_state	state;
+};
+
+enum ascot3_tv_system_t {
+	ASCOT3_DTV_DVBT_5,
+	ASCOT3_DTV_DVBT_6,
+	ASCOT3_DTV_DVBT_7,
+	ASCOT3_DTV_DVBT_8,
+	ASCOT3_DTV_DVBT2_1_7,
+	ASCOT3_DTV_DVBT2_5,
+	ASCOT3_DTV_DVBT2_6,
+	ASCOT3_DTV_DVBT2_7,
+	ASCOT3_DTV_DVBT2_8,
+	ASCOT3_DTV_DVBC_6,
+	ASCOT3_DTV_DVBC_8,
+	ASCOT3_DTV_DVBC2_6,
+	ASCOT3_DTV_DVBC2_8,
+	ASCOT3_DTV_UNKNOWN
+};
+
+struct ascot3_band_sett {
+	u8 	outlmt;
+	u8	rf_gain;
+	u8	if_bpf_gc;
+	u8	rfovld_det_lv1_vl;
+	u8	rfovld_det_lv1_vh;
+	u8	rfovld_det_lv1_u;
+	u8	ifovld_det_lv_vl;
+	u8	ifovld_det_lv_vh;
+	u8	ifovld_det_lv_u;
+	u8	if_bpf_f0;
+	u8	bw;
+	u8	fif_offset;
+	u8	bw_offset;
+	u8	agc_sel;
+	u8	if_out_sel;	
+	u8	is_lowerlocal;	
+};
+
+#define ASCOT3_AUTO		0xff
+#define ASCOT3_OFFSET(ofs)	((u8)(ofs) & 0x1F)
+#define ASCOT3_BW_6		0x00
+#define ASCOT3_BW_7		0x01
+#define ASCOT3_BW_8		0x02
+#define ASCOT3_BW_1_7	0x03
+
+static struct ascot3_band_sett ascot3_sett[] = {
+	{ 0x00, ASCOT3_AUTO, 0x09, 0x0C, 0x0C, 0x0C, 0x02, 0x02, 0x02, 0x00, 
+	  ASCOT3_BW_6, ASCOT3_OFFSET(-8), ASCOT3_OFFSET(-3), ASCOT3_AUTO, ASCOT3_AUTO, 0x00 }, 
+	{ 0x00, ASCOT3_AUTO, 0x09, 0x0C, 0x0C, 0x0C, 0x02, 0x02, 0x02, 0x00, 
+	  ASCOT3_BW_6,  ASCOT3_OFFSET(-8), ASCOT3_OFFSET(-3), ASCOT3_AUTO, ASCOT3_AUTO, 0x00 },
+	{ 0x00, ASCOT3_AUTO, 0x09, 0x0C, 0x0C, 0x0C, 0x02, 0x02, 0x02, 0x00, 
+	  ASCOT3_BW_7,  ASCOT3_OFFSET(-6), ASCOT3_OFFSET(-5), ASCOT3_AUTO, ASCOT3_AUTO, 0x00 },
+	{ 0x00, ASCOT3_AUTO, 0x09, 0x0C, 0x0C, 0x0C, 0x02, 0x02, 0x02, 0x00, 
+	  ASCOT3_BW_8,  ASCOT3_OFFSET(-4), ASCOT3_OFFSET(-6), ASCOT3_AUTO, ASCOT3_AUTO, 0x00 }, 
+	{ 0x00, ASCOT3_AUTO, 0x09, 0x0C, 0x0C, 0x0C, 0x02, 0x02, 0x02, 0x00, 
+	  ASCOT3_BW_1_7,ASCOT3_OFFSET(-10),ASCOT3_OFFSET(-10),ASCOT3_AUTO, ASCOT3_AUTO, 0x00 }, 
+	{ 0x00, ASCOT3_AUTO, 0x09, 0x0C, 0x0C, 0x0C, 0x02, 0x02, 0x02, 0x00, 
+	  ASCOT3_BW_6,  ASCOT3_OFFSET(-8), ASCOT3_OFFSET(-3), ASCOT3_AUTO, ASCOT3_AUTO, 0x00 },
+	{ 0x00, ASCOT3_AUTO, 0x09, 0x0C, 0x0C, 0x0C, 0x02, 0x02, 0x02, 0x00, 
+	  ASCOT3_BW_6,  ASCOT3_OFFSET(-8), ASCOT3_OFFSET(-3), ASCOT3_AUTO, ASCOT3_AUTO, 0x00 }, 
+	{ 0x00, ASCOT3_AUTO, 0x09, 0x0C, 0x0C, 0x0C, 0x02, 0x02, 0x02, 0x00, 
+	  ASCOT3_BW_7,  ASCOT3_OFFSET(-6), ASCOT3_OFFSET(-5), ASCOT3_AUTO, ASCOT3_AUTO, 0x00 }, 
+	{ 0x00, ASCOT3_AUTO, 0x09, 0x0C, 0x0C, 0x0C, 0x02, 0x02, 0x02, 0x00, 
+	  ASCOT3_BW_8,  ASCOT3_OFFSET(-4), ASCOT3_OFFSET(-6), ASCOT3_AUTO, ASCOT3_AUTO, 0x00 },
+	{ 0x00, ASCOT3_AUTO, 0x05, 0x09, 0x09, 0x09, 0x02, 0x02, 0x02, 0x00, 
+	  ASCOT3_BW_6,  ASCOT3_OFFSET(-6), ASCOT3_OFFSET(-4), ASCOT3_AUTO, ASCOT3_AUTO, 0x00 }, 
+	{ 0x00, ASCOT3_AUTO, 0x05, 0x09, 0x09, 0x09, 0x02, 0x02, 0x02, 0x00, 
+	  ASCOT3_BW_8,  ASCOT3_OFFSET(-2), ASCOT3_OFFSET(-3), ASCOT3_AUTO, ASCOT3_AUTO, 0x00 }, 
+	{ 0x00, ASCOT3_AUTO, 0x03, 0x0A, 0x0A, 0x0A, 0x02, 0x02, 0x02, 0x00, 
+	  ASCOT3_BW_6,  ASCOT3_OFFSET(-6), ASCOT3_OFFSET(-2), ASCOT3_AUTO, ASCOT3_AUTO, 0x00 },
+	{ 0x00, ASCOT3_AUTO, 0x03, 0x0A, 0x0A, 0x0A, 0x02, 0x02, 0x02, 0x00, 
+	  ASCOT3_BW_8,  ASCOT3_OFFSET(-2), ASCOT3_OFFSET(0),  ASCOT3_AUTO, ASCOT3_AUTO, 0x00 }
+};
+  
+static int ascot3_write_regs(struct ascot3_priv *priv,
+			      u8 reg, const u8 *data, u32 len)
+{
+	int ret;
+	u8 buf[MAX_WRITE_REGSIZE + 1];
+	struct i2c_msg msg[1] = {
+		{
+			.addr = priv->i2c_address,
+			.flags = 0,
+			.len = len + 1,
+			.buf = buf,
+		}
+	};
+
+	if (len + 1 >= sizeof(buf)) {
+		dev_warn(&priv->i2c->dev,"wr reg=%04x: len=%d is too big!\n",
+			 reg, len + 1);
+		return -E2BIG;
+	}
+
+
+	buf[0] = reg;
+	memcpy(&buf[1], data, len);
+	ret = i2c_transfer(priv->i2c, msg, 1);
+	if (ret >= 0 && ret != 1)
+		ret = -EREMOTEIO;
+	if (ret < 0) {
+		dev_warn(&priv->i2c->dev,
+			"i2c wr failed=%d reg=%02x len=%d\n",
+			ret, reg, len);
+		return ret;
+	}
+	return 0;
+}
+
+static int ascot3_write_reg(struct ascot3_priv *priv, u8 reg, u8 val)
+{
+	return ascot3_write_regs(priv, reg, &val, 1);
+}
+
+static int ascot3_read_regs(struct ascot3_priv *priv,
+			     u8 reg, u8 *val, u32 len)
+{
+	int ret;
+	struct i2c_msg msg[2] = {
+		{
+			.addr = priv->i2c_address,
+			.flags = 0,
+			.len = 1,
+			.buf = &reg,
+		}, {
+			.addr = priv->i2c_address,
+			.flags = I2C_M_RD,
+			.len = len,
+			.buf = val,
+		}
+	};
+
+	ret = i2c_transfer(priv->i2c, &msg[0], 1);
+	if (ret >= 0 && ret != 1)
+		ret = -EREMOTEIO;
+	if (ret < 0) {
+		dev_warn(&priv->i2c->dev,
+			"I2C rw failed=%d addr=%02x reg=%02x\n",
+			ret, priv->i2c_address, reg);
+		return ret;
+	}
+	ret = i2c_transfer(priv->i2c, &msg[1], 1);
+	if (ret >= 0 && ret != 1)
+		ret = -EREMOTEIO;
+	if (ret < 0) {
+		dev_warn(&priv->i2c->dev,
+			"i2c rd failed=%d addr=%02x reg=%02x\n",
+			 ret, priv->i2c_address, reg);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int ascot3_read_reg(struct ascot3_priv *priv, u8 reg, u8 *val)
+{
+	return ascot3_read_regs(priv, reg, val, 1);
+}
+
+static int ascot3_set_reg_bits(struct ascot3_priv *priv,
+				u8 reg, u8 data, u8 mask)
+{
+	int res;
+	u8 rdata;
+
+	if (mask != 0xff) {
+		res = ascot3_read_reg(priv, reg, &rdata);
+		if (res != 0)
+			return res;
+		data = ((data & mask) | (rdata & (mask ^ 0xFF)));
+	}
+	return ascot3_write_reg(priv, reg, data);
+}
+
+static int ascot3_enter_power_save(struct ascot3_priv *priv)
+{
+	u8 data[3];
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	
+	if (priv->state == STATE_SLEEP)
+		return 0;
+		
+	/* Loop Through setting And RFIN matching in Power Save */
+	ascot3_write_reg(priv, 0x67, 0x06);
+	/* Disable IF signal output (IF_OUT_SEL setting) */
+	ascot3_set_reg_bits(priv, 0x74, 0x02, 0x03);
+	/* Power save setting for analog block */
+	data[0] = 0x15;
+	data[1] = 0x00;
+	data[2] = 0x00;
+	ascot3_write_regs(priv, 0x5E, data, 3);
+	/* Standby setting for CPU */
+	ascot3_write_reg(priv, 0x88, 0x00);
+	/* Standby setting for internal logic block */
+	ascot3_write_reg(priv, 0x87, 0xC0);	
+	priv->state = STATE_SLEEP;	
+	return 0;
+}
+
+static int ascot3_init(struct dvb_frontend *fe)
+{
+	struct ascot3_priv *priv = fe->tuner_priv;
+
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	return 0;
+}
+
+static int ascot3_release(struct dvb_frontend *fe)
+{
+	struct ascot3_priv *priv = fe->tuner_priv;
+
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	kfree(fe->tuner_priv);
+	fe->tuner_priv = NULL;
+	return 0;
+}
+
+static int ascot3_sleep(struct dvb_frontend *fe)
+{
+	struct ascot3_priv *priv = fe->tuner_priv;
+
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 1);
+		
+	ascot3_enter_power_save(priv);
+	
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 0);
+		
+	return 0;
+}
+
+static enum ascot3_tv_system_t ascot3_get_tv_system(struct dvb_frontend *fe)
+{
+	enum ascot3_tv_system_t system = ASCOT3_DTV_UNKNOWN;
+	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
+	struct ascot3_priv *priv = fe->tuner_priv;
+
+	if (p->delivery_system == SYS_DVBT) {
+		if (p->bandwidth_hz <= 5000000)
+			system = ASCOT3_DTV_DVBT_5;
+		else if (p->bandwidth_hz <= 6000000)
+			system = ASCOT3_DTV_DVBT_6;
+		else if (p->bandwidth_hz <= 7000000)
+			system = ASCOT3_DTV_DVBT_7;
+		else if (p->bandwidth_hz <= 8000000)
+			system = ASCOT3_DTV_DVBT_8;
+		else {
+			system = ASCOT3_DTV_DVBT_8;
+			p->bandwidth_hz = 8000000;
+		}
+	} else if (p->delivery_system == SYS_DVBT2) {
+		if (p->bandwidth_hz <= 5000000)
+			system = ASCOT3_DTV_DVBT2_5;
+		else if (p->bandwidth_hz <= 6000000)
+			system = ASCOT3_DTV_DVBT2_6;
+		else if (p->bandwidth_hz <= 7000000)
+			system = ASCOT3_DTV_DVBT2_7;
+		else if (p->bandwidth_hz <= 8000000)
+			system = ASCOT3_DTV_DVBT2_8;
+		else {
+			system = ASCOT3_DTV_DVBT2_8;
+			p->bandwidth_hz = 8000000;
+		}
+	} else if (p->delivery_system == SYS_DVBC_ANNEX_A) {
+		if (p->bandwidth_hz <= 6000000)
+			system = ASCOT3_DTV_DVBC_6;
+		else if (p->bandwidth_hz <= 8000000)
+			system = ASCOT3_DTV_DVBC_8;
+	}
+	dev_dbg(&priv->i2c->dev,
+		"%s(): ASCOT2E DTV system %d (delsys %d, bandwidth %d)\n",
+		__func__, (int)system, p->delivery_system, p->bandwidth_hz);
+	return system;
+}
+
+static int ascot3_set_params(struct dvb_frontend *fe)
+{
+	u8 data[20];
+	u32 frequency;
+	enum ascot3_tv_system_t tv_system;
+	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
+	struct ascot3_priv *priv = fe->tuner_priv;
+
+	dev_dbg(&priv->i2c->dev, "%s(): tune frequency %dkHz\n",
+		__func__, p->frequency / 1000);
+	tv_system = ascot3_get_tv_system(fe);
+
+	if (tv_system == ASCOT3_DTV_UNKNOWN) {
+		dev_dbg(&priv->i2c->dev, "%s(): unknown DTV system\n",
+			__func__);
+		return -EINVAL;
+	}
+
+	frequency = roundup(p->frequency / 1000, 25);
+
+	/* Disable IF signal output (IF_OUT_SEL setting) */
+	ascot3_set_reg_bits(priv, 0x74, 0x02, 0x03);
+	/* Clock enable for internal logic block, CPU wake-up */
+	data[0] = 0xC4;
+	data[1] = 0x40;
+	ascot3_write_regs(priv, 0x87, data, 2);
+	
+	/* Initial setting for internal analog block */	
+	if (tv_system == ASCOT3_DTV_DVBC_6 ||
+			tv_system == ASCOT3_DTV_DVBC_8) {		
+		data[0] = 0x16;
+		data[1] = 0x26;
+	} else {		
+		data[0] = 0x10;
+		data[1] = 0x20;
+	}
+	ascot3_write_regs(priv, 0x91, data, 2);
+	
+	/* Setting for analog block */
+	data[0] = 0x00;
+	data[1] = (u8)(ascot3_sett[tv_system].is_lowerlocal & 0x01);
+	ascot3_write_regs(priv, 0x9C, data, 2);
+	
+	/* Enable for analog block */
+	data[0] = 0xEE;
+	data[1] = 0x02;
+	data[2] = 0x1E;
+	/* Tuning setting for CPU */
+	data[3] = 0x67;
+	/* Setting for PLL reference divider (REF_R) */
+	data[4] = 0x02;
+	/* Tuning setting for analog block*/
+	if (tv_system == ASCOT3_DTV_DVBC_6 ||
+			tv_system == ASCOT3_DTV_DVBC_8) {		
+		data[5] = 0x50;
+		data[6] = 0x78;
+		data[7] = 0x08;
+		data[8] = 0x30;
+	} else {		
+		data[5] = 0xAF;
+		data[6] = 0x78;
+		data[7] = 0x08;
+		data[8] = 0x30;
+	}
+	ascot3_write_regs(priv, 0x5E, data, 9);
+	
+	/* Setting for IFOUT_LIMIT */
+	data[0] = (u8)(ascot3_sett[tv_system].outlmt & 0x03);
+	/* Setting for IF BPF buffer gain */
+	/* RF_GAIN setting */
+	if (ascot3_sett[tv_system].rf_gain == ASCOT3_AUTO) 
+		data[1] = 0x80;
+	else
+		data[1] = (u8)((ascot3_sett[tv_system].rf_gain << 4) & 0x70);
+	
+	/* IF_BPF_GC setting */
+	data[1] |= (u8)(ascot3_sett[tv_system].if_bpf_gc & 0x0F);
+
+	/* Setting for internal RFAGC */
+	data[2] = 0x00;	
+	if (frequency <= 172000) {
+		data[3] = (u8)(ascot3_sett[tv_system].rfovld_det_lv1_vl & 0x0F);
+		data[4] = (u8)(ascot3_sett[tv_system].ifovld_det_lv_vl & 0x07);
+	} else if (frequency <= 464000) {		
+		data[3] = (u8)(ascot3_sett[tv_system].rfovld_det_lv1_vh & 0x0F);
+		data[4] = (u8)(ascot3_sett[tv_system].ifovld_det_lv_vh & 0x07);
+	} else {	
+		data[3] = (u8)(ascot3_sett[tv_system].rfovld_det_lv1_u & 0x0F);
+		data[4] = (u8)(ascot3_sett[tv_system].ifovld_det_lv_u & 0x07);
+	}	
+	data[4] |= 0x20;
+	
+	/* Setting for IF frequency and bandwidth */
+	data[5] = (u8)((ascot3_sett[tv_system].if_bpf_f0 << 4) & 0x30);
+	data[5] |= (u8)(ascot3_sett[tv_system].bw & 0x03);
+	data[6] = (u8)(ascot3_sett[tv_system].fif_offset & 0x1F);
+	data[7] = (u8)(ascot3_sett[tv_system].bw_offset & 0x1F);
+	
+	/* RF tuning frequency setting */
+	data[8] = (u8)(frequency & 0xFF);         /* 0x10: FRF_L */
+	data[9] = (u8)((frequency >> 8) & 0xFF);  /* 0x11: FRF_M */
+	data[10] = (u8)((frequency >> 16) & 0x0F); /* 0x12: FRF_H (bit[3:0]) */
+	/* Tuning command */
+	data[11] = 0xFF;
+	/* Enable IF output, AGC and IFOUT pin selection */
+	data[12] = 0x11;
+	/* Tuning setting for analog block*/
+	if (tv_system == ASCOT3_DTV_DVBC_6 ||
+			tv_system == ASCOT3_DTV_DVBC_8) {		
+		data[13] = 0xD9;
+		data[14] = 0x0F;
+		data[15] = 0x25;
+		data[16] = 0x87;
+	} else {		
+		data[13] = 0x99;
+		data[14] = 0x00;
+		data[15] = 0x24;
+		data[16] = 0x87;
+	}
+	ascot3_write_regs(priv, 0x68, data, 17);
+
+	msleep(50);
+	
+	priv->state = STATE_ACTIVE;	
+	ascot3_write_reg(priv, 0x88, 0x00);
+	ascot3_write_reg(priv, 0x87, 0xC0);
+	
+	priv->frequency = frequency;
+	return 0;
+}
+
+static int ascot3_get_frequency(struct dvb_frontend *fe, u32 *frequency)
+{
+	struct ascot3_priv *priv = fe->tuner_priv;
+
+	*frequency = priv->frequency * 1000;
+	return 0;
+}
+
+static struct dvb_tuner_ops ascot3_tuner_ops = {
+	.info = {
+		.name = "Sony ASCOT3",
+		.frequency_min = 1000000,
+		.frequency_max = 1200000000,
+		.frequency_step = 25000,
+	},
+	.init = ascot3_init,
+	.release = ascot3_release,
+	.sleep = ascot3_sleep,
+	.set_params = ascot3_set_params,
+	.get_frequency = ascot3_get_frequency,
+};
+
+struct dvb_frontend *ascot3_attach(struct dvb_frontend *fe,
+				    const struct ascot3_config *config,
+				    struct i2c_adapter *i2c)
+{
+	u8 data[20];
+	struct ascot3_priv *priv = NULL;
+
+	priv = kzalloc(sizeof(struct ascot3_priv), GFP_KERNEL);
+	if (priv == NULL)
+		return NULL;
+	priv->i2c_address = config->i2c_address;
+	priv->i2c = i2c;
+
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 1);
+
+	/* Check if tuner is Sony ASCOT3 */
+	data[0] = 0x00;
+	ascot3_read_reg(priv, 0x7F, data);
+	if (((data[0] & 0xF0) != 0xC0) && ((data[0] & 0xF0) != 0xD0)) {
+		kfree(priv);
+		return NULL;	
+	}	
+	/* Initial setting for internal logic block */	
+	data[0] = 0x7A;
+	data[1] = 0x01;
+	ascot3_write_regs(priv, 0x99, data, 2);
+	/* 16 MHz xTal frequency */
+	data[0] = 16;
+	/* Driver current setting for crystal oscillator */	
+	/* Load capacitance setting for crystal oscillator */
+	data[1] = 0x84;
+	data[2] = 0xB0;
+	/* Setting for REFOUT signal output */
+	data[3] = 0x00;
+	/* GPIO0, GPIO1 port setting */
+	data[4] = 0x00;
+	data[5] = 0x00;
+	/* Logic wake up, CPU boot */
+	data[6] = 0xC4;
+	data[7] = 0x40;
+	/* For burst-write */
+	data[8] = 0x10;
+	/* Setting for internal RFAGC */
+	data[9] = 0x00;
+	data[10] = 0x45;
+	data[11] = 0x56;
+	/* Setting for analog block */
+	data[12] = 0x07;
+	/* Initial setting for internal analog block */
+	data[13] = 0x1C;
+	data[14] = 0x3F;
+	data[15] = 0x02;
+	data[16] = 0x10;
+	data[17] = 0x20;
+	data[18] = 0x0A;
+	data[19] = 0x00;
+	ascot3_write_regs(priv, 0x81, data, 20);
+	/* Setting for internal RFAGC */
+	ascot3_write_reg(priv, 0x9B, 0x00);
+	msleep(10);
+	/* VCO current setting */
+	data[0] = 0x8D;
+	data[1] = 0x06;
+	ascot3_write_regs(priv, 0x17, data, 2);
+	msleep(1);
+	ascot3_read_reg(priv, 0x19, data);
+	ascot3_write_reg(priv, 0x95, ((data[0] >> 4) & 0x0F));
+	ascot3_enter_power_save(priv);	
+	/* Load capacitance control setting for crystal oscillator */
+	ascot3_write_reg(priv, 0x80, 0x01);
+	
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 0);
+
+	memcpy(&fe->ops.tuner_ops, &ascot3_tuner_ops,
+				sizeof(struct dvb_tuner_ops));
+	fe->tuner_priv = priv;
+	dev_info(&priv->i2c->dev,
+		"Sony ASCOT3 attached on addr=%x at I2C adapter %p\n",
+		priv->i2c_address, priv->i2c);
+	return fe;
+}
+EXPORT_SYMBOL(ascot3_attach);
+
+MODULE_DESCRIPTION("Sony ASCOT3 terr/cab tuner driver");
+MODULE_AUTHOR("sasa.savic.sr@gmail.com");
+MODULE_LICENSE("GPL");
diff --git a/drivers/amlogic/dvb_tv/ascot3.h b/drivers/amlogic/dvb_tv/ascot3.h
new file mode 100644
index 000000000000..e245539bdc6f
--- /dev/null
+++ b/drivers/amlogic/dvb_tv/ascot3.h
@@ -0,0 +1,46 @@
+/*
+ * ascot3.h
+ *
+ * Sony Ascot3 DVB-T/T2/C tuner driver
+ *
+ * Copyright (C) 2015 Sasa Savic <sasa.savic.sr@gmail.com>
+ *
+ * Based on ascot2e driver
+ *
+ * Copyright 2012 Sony Corporation
+ * Copyright (C) 2014 NetUP Inc.
+ * Copyright (C) 2014 Sergey Kozlov <serjk@netup.ru>
+ * Copyright (C) 2014 Abylay Ospan <aospan@netup.ru>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+  */
+
+#ifndef __DVB_ASCOT3_H__
+#define __DVB_ASCOT3_H__
+
+#include <linux/kconfig.h>
+#include <linux/dvb/frontend.h>
+#include <linux/i2c.h>
+
+/**
+ * struct ascot3_config - the configuration of Ascot2E tuner driver
+ * @i2c_address:	I2C address of the tuner
+ * @xtal_freq_mhz:	Oscillator frequency, MHz
+ */
+struct ascot3_config {
+	u8	i2c_address;
+	u8	xtal_freq_mhz;
+};
+
+extern struct dvb_frontend *ascot3_attach(struct dvb_frontend *fe,
+					const struct ascot3_config *config,
+					struct i2c_adapter *i2c);
+#endif
diff --git a/drivers/amlogic/dvb_tv/avl6211.c b/drivers/amlogic/dvb_tv/avl6211.c
new file mode 100644
index 000000000000..278f0263e26c
--- /dev/null
+++ b/drivers/amlogic/dvb_tv/avl6211.c
@@ -0,0 +1,1979 @@
+/*
+ * Driver for the Availink AVL6211+AV2011 DVB-S/S2 demod+tuner
+ *
+ * Copyright (C) 2014 Sasa Savic <sasa.savic.sr@gmail.com>
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License along
+ *    with this program; if not, write to the Free Software Foundation, Inc.,
+ *    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/firmware.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/version.h>
+
+#include "dvb_frontend.h"
+#include "avl6211_reg.h"
+#include "avl6211.h"
+
+
+const struct avl6211_pllconf pll_conf[] = {
+	/* The following set of PLL configuration at different reference clock frequencies refer to demod operation */
+	/* in standard performance mode. */
+	 { 503,  1, 7, 4, 2,  4000, 11200, 16800, 25200 } /* Reference clock 4 MHz,   Demod clock 112 MHz, FEC clock 168 MHz, MPEG clock 252 MHz */
+	,{ 447,  1, 7, 4, 2,  4500, 11200, 16800, 25200 } /* Reference clock 4.5 MHz, Demod clock 112 MHz, FEC clock 168 MHz, MPEG clock 252 MHz */
+	,{ 503,  4, 7, 4, 2, 10000, 11200, 16800, 25200 } /* Reference clock 10 MHz,  Demod clock 112 MHz, FEC clock 168 MHz, MPEG clock 252 MHz */
+	,{ 503,  7, 7, 4, 2, 16000, 11200, 16800, 25200 } /* Reference clock 16 MHz,  Demod clock 112 MHz, FEC clock 168 MHz, MPEG clock 252 MHz */
+	,{ 111,  2, 7, 4, 2, 27000, 11200, 16800, 25200 } /* Reference clock 27 MHz,  Demod clock 112 MHz, FEC clock 168 MHz, MPEG clock 252 MHz */
+	
+	/* The following set of PLL configuration at different reference clock frequencies refer to demod operation */
+	/* in high performance mode. */
+	,{ 566,  1, 7, 4, 2,  4000, 12600, 18900, 28350 } /* Reference clock 4 MHz,   Demod clock 126 MHz, FEC clock 189 MHz, MPEG clock 283.5 MHz */
+	,{ 503,  1, 7, 4, 2,  4500, 12600, 18900, 28350 } /* Reference clock 4.5 MHz, Demod clock 126 MHz, FEC clock 189 MHz, MPEG clock 283.5 MHz */
+	,{ 566,  4, 7, 4, 2, 10000, 12600, 18900, 28350 } /* Reference clock 10 MHz,  Demod clock 126 MHz, FEC clock 189 MHz, MPEG clock 283.5 MHz */
+	,{ 566,  7, 7, 4, 2, 16000, 12600, 18900, 28350 } /* Reference clock 16 MHz,  Demod clock 126 MHz, FEC clock 189 MHz, MPEG clock 283.5 MHz */
+	,{ 377,  8, 7, 4, 2, 27000, 12600, 18900, 28350 } /* Reference clock 27 MHz,  Demod clock 126 MHz, FEC clock 189 MHz, MPEG clock 283.5 MHz */
+};
+
+const unsigned short pll_array_size = sizeof(pll_conf) / sizeof(struct avl6211_pllconf);
+
+struct avl6211_state
+{
+	struct i2c_adapter* i2c;
+	struct avl6211_config* config;
+	struct dvb_frontend frontend;
+	
+	u8 diseqc_status;
+	u16 locked;
+	u32 frequency;
+	u32 symbol_rate;	
+	u32 flags;
+	
+	int demod_id;
+	
+	u16 tuner_lpf;
+	u16 demod_freq;	/* Demod clock in 10kHz units */
+	u16 fec_freq;	/* FEC clock in 10kHz units */
+	u16 mpeg_freq;	/* MPEG clock in 10kHz units */
+	
+	bool boot;
+	bool gpio_on;
+};
+struct avl6211_diseqc_tx_status
+{
+	u8 tx_done;		
+	u8 tx_fifo_cnt;
+};
+static u16 extract_16(const u8 * buf)
+{
+	u16 data;
+	data = buf[0];
+	data = (u16)(data << 8) + buf[1];
+	return data;
+}
+static u32 extract_32(const u8 * buf)
+{
+	unsigned int data;
+	data = buf[0];
+	data = (data << 8) + buf[1];
+	data = (data << 8) + buf[2];
+	data = (data << 8) + buf[3];
+	return data;
+}
+static int avl6211_i2c_writereg(struct avl6211_state *state, u8 *data, u16 *size)
+{
+	int ret;
+	struct i2c_msg msg[1] = {
+			{
+				.addr = state->config->demod_address, 
+				.flags = 0,
+				.buf = data,
+				.len = *size,
+			}
+	};
+	
+	ret = i2c_transfer(state->i2c, msg, 1);	
+	if (ret == 1) {
+		ret = 0;
+	} else {
+		dev_warn(&state->i2c->dev, "i2c wr failed=%d", ret);
+		ret = -EREMOTEIO;
+	}
+	
+	return ret;
+}
+static int avl6211_i2c_readreg(struct avl6211_state* state, u8 * data, u16 * size)
+{
+	int ret;
+	struct i2c_msg msg[1] = {
+			{
+					.addr = state->config->demod_address, 
+					.flags = I2C_M_RD,
+					.buf = data,
+					.len = *size,
+			}
+	};
+
+	ret = i2c_transfer(state->i2c, msg, 1);
+	
+	if (ret == 1) {
+		ret = 0;
+	} else {
+		dev_warn(&state->i2c->dev, "i2c rd failed=%d", ret);
+		ret = -EREMOTEIO;
+	}
+	
+	return ret;
+}
+static int avl6211_i2c_read(struct avl6211_state* state, u32 offset, u8 * buf, u16 buf_size)
+{
+	int ret;
+	u8 buf_tmp[3];
+	u16 x1 = 3, x2 = 0;
+	u16 size;
+
+	format_addr(offset, buf_tmp);
+	ret = avl6211_i2c_writereg(state, buf_tmp, &x1);  
+	if (ret)
+		goto err;
+
+	if (buf_size & 1)
+		size = buf_size - 1;
+	else
+		size = buf_size;
+
+	while (size > I2C_MAX_READ) {
+		x1 = I2C_MAX_READ;
+		ret = avl6211_i2c_readreg(state, buf + x2, &x1);
+		if (ret)
+			goto err;			
+		x2 += I2C_MAX_READ;
+		size -= I2C_MAX_READ;
+	}
+
+	if (size != 0) {
+		ret = avl6211_i2c_readreg(state, buf + x2, &size);
+		if (ret)
+			goto err;
+	}
+
+	if (buf_size & 1) {
+		x1 = 2;
+		ret = avl6211_i2c_readreg(state, buf_tmp, &x1);
+		if (ret)
+			goto err;
+		buf[buf_size-1] = buf_tmp[0];
+	}
+	
+	return 0;
+	
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int avl6211_i2c_write(struct avl6211_state* state, u8 * buf, u16 buf_size)
+{
+	int ret;
+	u8 buf_tmp[5], *x3;
+	u16 x1, x2 = 0, tmp;
+	u16 size;
+	u32 addr;
+
+	if (WARN_ON(buf_size < 3))
+		return -EINVAL;	
+		
+	/* Actual data size */
+	buf_size -= 3;
+	/* Dump address */
+	addr = buf[0];
+	addr = addr << 8;
+	addr += buf[1];
+	addr = addr << 8;
+	addr += buf[2];
+	
+	if (buf_size & 1)
+		size = buf_size -1;
+	else
+		size = buf_size;
+	
+	tmp = (I2C_MAX_WRITE - 3) & 0xfffe; /* How many bytes data we can transfer every time */
+	
+	x2 = 0;
+	while( size > tmp ) {
+		x1 = tmp + 3;
+		/* Save the data */
+		buf_tmp[0] = buf[x2];
+		buf_tmp[1] = buf[x2 + 1];
+		buf_tmp[2] = buf[x2 + 2];
+		x3 = buf + x2;
+		format_addr(addr, x3);
+		ret = avl6211_i2c_writereg(state, buf + x2, &x1);
+		if (ret)
+			goto err;
+		/* Restore data */
+		buf[x2] = buf_tmp[0];
+		buf[x2 + 1] = buf_tmp[1];
+		buf[x2 + 2] = buf_tmp[2];
+		addr += tmp;
+		x2 += tmp;
+		size -= tmp;
+	}
+
+	x1 = size + 3;
+	/* Save the data */
+	buf_tmp[0] = buf[x2];
+	buf_tmp[1] = buf[x2 + 1];
+	buf_tmp[2] = buf[x2 + 2];
+	x3 = buf + x2;
+	format_addr(addr, x3);
+	ret = avl6211_i2c_writereg(state, buf + x2, &x1);
+	if (ret)
+		goto err;
+	/* Restore data */
+	buf[x2] = buf_tmp[0];
+	buf[x2 + 1] = buf_tmp[1];
+	buf[x2 + 2] = buf_tmp[2];
+	addr += size;
+	x2 += size;
+		
+	if (buf_size & 1) {
+		format_addr(addr, buf_tmp);
+		x1 = 3;
+		ret = avl6211_i2c_writereg(state, buf_tmp, &x1);
+		if (ret)
+			goto err;
+		x1 = 2;
+		ret = avl6211_i2c_readreg(state, buf_tmp + 3, &x1);
+			goto err;
+		buf_tmp[3] = buf[x2 + 3];
+		x1 = 5;
+		ret = avl6211_i2c_writereg(state, buf_tmp, &x1);
+		if (ret)
+			goto err;
+	}
+		
+	return 0;
+
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int avl6211_i2c_read16(struct avl6211_state* state, u32 addr, u16 *data)
+{
+	int ret;
+	u8 buf[2];
+
+	ret = avl6211_i2c_read(state, addr, buf, 2);
+	if (ret)
+		goto err;
+		
+	*data = extract_16(buf);
+
+	return 0;
+	
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int avl6211_i2c_read32(struct avl6211_state* state, u32 addr, u32 *data)
+{
+	int ret;
+	u8 buf[4];
+
+	ret = avl6211_i2c_read(state, addr, buf, 4);
+	if (ret)
+		goto err;
+		
+	*data = extract_32(buf);
+
+	return 0;
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int avl6211_i2c_write16(struct avl6211_state* state, u32 addr, u16 data)
+{
+	int ret;
+	u8 buf[5], *p;
+
+	format_addr(addr, buf);
+	p = buf + 3;
+	format_16(data, p);
+
+	ret = avl6211_i2c_write(state, buf, 5);
+	if (ret)
+		goto err;
+		
+	return 0;
+
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int avl6211_i2c_write32(struct avl6211_state* state, u32 addr, u32 data)
+{
+	int ret;
+	u8 buf[7], *p;
+
+	format_addr(addr, buf);
+	p = buf + 3;
+	format_32(data, p);
+	ret = avl6211_i2c_write(state, buf, 7);
+	if (ret)
+		goto err;
+		
+	return 0;
+	
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int avl6211_get_op_status(struct avl6211_state* state)
+{
+	int ret;
+	u8 buf[2];
+
+	ret = avl6211_i2c_read(state, rx_cmd_addr, buf, 2);
+	if (ret)
+		goto err;
+		
+	if (buf[1] != 0) {
+		ret = -EINVAL;
+		goto err;
+	}
+	
+	return 0;
+err:	
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int avl6211_send_op(u8 ucOpCmd, struct avl6211_state* state)
+{
+	int ret;
+	u8 buf[2];
+	u16 x1;
+	int cnt = 20;
+
+	do {
+		ret = avl6211_get_op_status(state);
+		if (!ret)
+			break;
+	
+		msleep(10);
+		cnt--;
+	} while (cnt != 0);
+	
+	if (ret)
+		goto err;
+		
+	buf[0] = 0;
+	buf[1] = ucOpCmd;
+	x1 = extract_16(buf);
+	ret = avl6211_i2c_write16(state, rx_cmd_addr, x1);   
+	if (ret)
+		goto err;
+		
+	return 0;
+	
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int avl6211_i2c_repeater_get_status(struct avl6211_state* state)
+{
+	int ret;
+	u8 buf[2];
+
+	ret = avl6211_i2c_read(state, i2cm_cmd_addr + I2CM_CMD_LENGTH - 2, buf, 2);
+	if (ret)
+		goto err;
+		
+	if (buf[1] != 0) {
+		ret = -EINVAL;
+		goto err;
+	}
+		
+	return 0;
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+
+static int avl6211_i2c_repeater_exec(struct avl6211_state* state, u8 * buf, u8 size)
+{
+	int ret, i = 0;
+
+	do {
+		ret = avl6211_i2c_repeater_get_status(state);
+		if (ret && 60 < i++) 
+			goto err;
+			
+		msleep(5);
+	
+	} while (ret);
+	
+	ret = avl6211_i2c_write(state, buf, size);
+	if (ret)
+		goto err;
+		
+	return 0;
+
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int avl6211_i2c_repeater_send(struct avl6211_state* state, u8 * buf, u16 size)
+{
+	int ret;
+	u8 tmp_buf[I2CM_CMD_LENGTH + 3];
+	u16 i, j;
+	u16 cmd_size;
+
+	if (WARN_ON(size > I2CM_CMD_LENGTH - 3))
+		return -EINVAL;
+
+	memset(tmp_buf, 0, sizeof(tmp_buf));
+	
+	cmd_size = ((size + 3) % 2) + 3 + size;
+	format_addr(i2cm_cmd_addr + I2CM_CMD_LENGTH - cmd_size, tmp_buf);
+
+	i = 3 + ((3 + size) % 2);	  /* skip one byte if the size +3 is odd */
+
+	for (j = 0; j < size; j++)
+		tmp_buf[i++] = buf[j];
+
+	tmp_buf[i++] = (u8)size;
+	tmp_buf[i++] = state->config->tuner_address;
+	tmp_buf[i++] = OP_I2CM_WRITE;
+
+			
+	ret = avl6211_i2c_repeater_exec(state, tmp_buf, (u8)(cmd_size + 3));
+	if (ret)
+		goto err;
+		
+	return 0;
+
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+
+static int avl6211_i2c_repeater_recv(struct avl6211_state* state, u8 * buf, u16 size)
+{
+	int ret, i = 0;
+	u8 tmp_buf[I2CM_RSP_LENGTH];
+
+	if (WARN_ON(size > I2CM_RSP_LENGTH))
+		return -EINVAL;
+
+	memset(tmp_buf, 0, sizeof(tmp_buf));
+	
+	format_addr(i2cm_cmd_addr + I2CM_CMD_LENGTH - 4, tmp_buf);
+	tmp_buf[3] = 0x0;
+	tmp_buf[4] = (u8)size;
+	tmp_buf[5] = state->config->tuner_address;
+	tmp_buf[6] = OP_I2CM_READ;
+
+	ret = avl6211_i2c_repeater_exec(state, tmp_buf, 7);
+	if (ret)
+		goto err;
+	
+	do {
+		ret = avl6211_i2c_repeater_get_status(state);
+		if (ret && 100 < i++) 
+			goto err;
+			
+		msleep(10);
+	
+	} while (ret);
+
+	ret = avl6211_i2c_read(state, i2cm_rsp_addr, buf, size);
+	if (ret)
+		goto err;
+		
+	return 0;
+
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int avl6211_i2c_repeater_init(u16 bus_clk, struct avl6211_state* state)
+{
+	u8 buf[5];
+	int ret;
+
+	ret = avl6211_i2c_write16(state, rc_i2cm_speed_kHz_addr, bus_clk);
+	if (ret)
+		goto err;
+		
+	format_addr(i2cm_cmd_addr + I2CM_CMD_LENGTH - 2, buf);
+	buf[3] = 0x01;
+	buf[4] = OP_I2CM_INIT;
+	ret = avl6211_i2c_repeater_exec(state, buf, 5);
+	if (ret)
+		goto err;
+
+	return 0;
+	
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int AV2011_I2C_write(u8 reg_start, u8* buff, u8 len, struct avl6211_state* state)
+{
+	int ret, i = 0;
+	u8 ucTemp[50] = { 0 };
+	
+	msleep(5);
+	ucTemp[0] = reg_start;
+	ret = avl6211_i2c_repeater_get_status(state);
+	
+	do {
+		ret = avl6211_i2c_repeater_get_status(state);
+		if (ret && 100 < i++) 
+			goto err;
+			
+		msleep(1);
+	
+	} while (ret);
+		
+	for (i = 1; i < len + 1; i++)			
+		ucTemp[i] = *(buff + i - 1);
+			
+	ret = avl6211_i2c_repeater_send(state, ucTemp, len+1);
+	if (ret)
+		goto err;
+	
+	msleep(5);
+	return 0;
+	
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+
+static int av2011_tuner_lock_status(struct dvb_frontend* fe)
+{
+	struct avl6211_state *state = fe->demodulator_priv;	
+	int ret;
+	u8 lock = 0x0b;
+	u8 locked = 0;
+	ret = avl6211_i2c_repeater_send(state, &lock, 1);
+	if (ret)
+		goto err;
+		
+	ret = avl6211_i2c_repeater_recv(state, &locked, 1);
+	if (ret)
+		goto err;
+
+	if (!(locked & 0x01)) 
+		return -EINVAL;
+		
+	return 0;
+
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int av2011_lock(struct dvb_frontend* fe)
+{
+	int ret;
+	struct avl6211_state *state = fe->demodulator_priv;	
+	u8 reg[50];
+	u32 fracN;
+	u32 BW;
+	u32 BF;
+	u32 freq = state->frequency / 1000;
+	u32 LPF = state->tuner_lpf * 100;
+
+	memset(reg, 0, sizeof(reg));
+
+	msleep(50);
+	
+	fracN = (freq + 27/2) / 27;
+	if (fracN > 0xff)
+		fracN = 0xff;
+		
+	reg[0] = (char)(fracN & 0xff);
+	fracN = (freq << 17) / 27;
+	fracN = fracN & 0x1ffff;
+	reg[1] = (char)((fracN >> 9) & 0xff);
+	reg[2] = (char)((fracN >> 1) & 0xff);
+	reg[3] = (char)((fracN << 7) & 0x80) | 0x50;
+
+	BW = (LPF * 135) / 200;
+	if (LPF < 6500)
+		BW = BW + 6000;
+   	BW = BW + 2000;
+	BW = BW*108/100;
+
+	if (BW < 4000)
+		BW = 4000;
+	if ( BW > 40000)
+		BW = 40000;
+	BF = (BW * 127 + 21100/2) / 21100; 
+	
+	dev_dbg(&state->i2c->dev, "BF is %d,BW is %d\n", BF, BW);
+	
+	reg[5] = (u8)BF;
+
+	msleep(5);
+	ret = AV2011_I2C_write(0, reg, 4, state);
+	if (ret)
+		goto err;
+		
+	msleep(5);
+		
+	ret = AV2011_I2C_write(5, reg+5, 1, state);
+	if (ret)
+		goto err;
+		
+	msleep(5);
+			
+	reg[37] = 0x06;
+	ret = AV2011_I2C_write(37, reg+37, 1, state);
+	if (ret)
+		goto err;;
+		
+	msleep(5);
+		
+	reg[12] = 0x96 + (1 << 6);
+	ret = AV2011_I2C_write(12, reg+12, 1, state);
+	if (ret)
+		goto err;
+
+	return 0;
+	
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int av2011_tuner_reg_init(struct dvb_frontend* fe)
+{
+	struct avl6211_state *state = fe->demodulator_priv;
+    int ret;
+	
+	u8 reg[50] = { 
+		0x38, 0x00, 0x00, 0x50, 0x1f, 0xa3, 0xfd, 0x58, 0x0e,
+		0xc2, 0x88, 0xb4, 0xd6, 0x40, 0x94, 0x9a, 0x66, 0x40,
+		0x80, 0x2b, 0x6a, 0x50, 0x91, 0x27, 0x8f, 0xcc, 0x21,
+		0x10, 0x80, 0x02, 0xf5, 0x7f, 0x4a, 0x9b, 0xe0, 0xe0,
+		0x36, 0x00, 0xab, 0x97, 0xc5, 0xa8,
+	};
+	
+	ret = AV2011_I2C_write(0, reg, 12, state);
+	if (ret)
+		goto err;
+		
+	msleep(1);
+		
+	ret = AV2011_I2C_write(13, reg+13, 12, state);
+	if (ret)
+		goto err;
+		
+	ret = AV2011_I2C_write(25, reg+25, 11, state);
+	if (ret)
+		goto err;
+		
+	ret = AV2011_I2C_write(36, reg+36, 6, state);
+	if (ret)
+		goto err;
+		
+	msleep(1);
+		
+	ret = AV2011_I2C_write(12, reg+12, 1, state);
+	if (ret)
+		goto err;
+		
+	msleep(10);
+	
+	ret = AV2011_I2C_write(0, reg, 12, state);
+	if (ret)
+		goto err;
+			
+	msleep(1);
+					
+	ret = AV2011_I2C_write(13, reg+13 , 12, state);
+	if (ret)
+		goto err;
+			
+	ret = AV2011_I2C_write(25, reg+25 , 11, state);
+	if (ret)
+		goto err;
+			
+	ret = AV2011_I2C_write(36, reg+36, 6, state);
+	if (ret)
+		goto err;
+			
+	msleep(1);
+		
+	ret = AV2011_I2C_write(12, reg+12, 1, state);
+	if (ret)
+		goto err;
+		
+	msleep(5);
+	
+	return 0;
+
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int av2011_tuner_init(struct dvb_frontend* fe) 
+{
+    struct avl6211_state *state = fe->demodulator_priv;
+    int ret;
+	
+    ret = avl6211_i2c_write16(state, rc_tuner_slave_addr_addr, state->config->tuner_address);
+	if (ret)
+		goto err;
+	/* Use external control */
+	ret = avl6211_i2c_write16(state, rc_tuner_use_internal_control_addr, 0);
+	if (ret)
+		goto err;
+	ret = avl6211_i2c_write16(state, rc_tuner_LPF_margin_100kHz_addr, 0);
+	if (ret)
+		goto err;
+	ret = avl6211_i2c_write16(state, rc_tuner_max_LPF_100kHz_addr, 360 );
+	if (ret)
+		goto err;
+	
+    ret = avl6211_i2c_repeater_init(state->config->tuner_i2c_clock, state);
+	if (ret)
+		goto err;
+
+	ret = av2011_tuner_reg_init(fe);
+	if (ret)
+		goto err;
+
+	return 0;
+	
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+    return ret;
+}
+
+static int avl6211_diseqc_init(struct dvb_frontend* fe)
+{
+	struct avl6211_state *state = fe->demodulator_priv;
+	int ret;
+	u32 x1;
+	
+	ret = avl6211_i2c_write32(state, diseqc_srst_addr, 1);
+	if (ret)
+		goto err;
+	ret = avl6211_i2c_write32(state, diseqc_samp_frac_n_addr, 200);	/* 2M = 200 * 10kHz */
+	if (ret)
+		goto err;
+	ret = avl6211_i2c_write32(state, diseqc_samp_frac_d_addr, state->demod_freq);
+	if (ret)
+		goto err;
+	ret = avl6211_i2c_write32(state, diseqc_tone_frac_n_addr, (22 << 1));
+	if (ret)
+		goto err;
+	ret = avl6211_i2c_write32(state, diseqc_tone_frac_d_addr, state->demod_freq * 10);
+	if (ret)
+		goto err;
+
+	/* Initialize the tx_control */
+	ret = avl6211_i2c_read32(state, diseqc_tx_cntrl_addr, &x1);
+	if (ret)
+		goto err;
+	x1 &= 0x00000300;
+	x1 |= 0x20;		/* Reset tx_fifo */
+	x1 |= (u32)(0 << 6);
+	x1 |= (u32)(0 << 4);
+	x1 |= (1 << 3);			/* Enable tx gap */
+	ret = avl6211_i2c_write32(state, diseqc_tx_cntrl_addr, x1);
+	if (ret)
+		goto err;
+	x1 &= ~(0x20);	/* Release tx_fifo reset */
+	ret = avl6211_i2c_write32(state, diseqc_tx_cntrl_addr, x1);
+	if (ret)
+		goto err;
+
+	/* Initialize the rx_control */
+	x1 = (u32)(0 << 2);
+	x1 |= (1 << 1);	/* Activate the receiver */
+	x1 |= (1 << 3);	/* Envelop high when tone present */
+	ret = avl6211_i2c_write32(state, diseqc_rx_cntrl_addr, x1);
+	if (ret)
+		goto err;
+	x1 = (u32)(0 >> 12);
+	ret = avl6211_i2c_write32(state, diseqc_rx_msg_tim_addr, x1);
+	if (ret)
+		goto err;
+
+	ret = avl6211_i2c_write32(state, diseqc_srst_addr, 0);
+	if (ret)
+		goto err;
+
+	
+	state->diseqc_status = DISEQC_STATUS_INIT;
+
+	return 0;
+	
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int avl6211_diseqc_switch_mode(struct dvb_frontend* fe)
+{
+	struct avl6211_state *state = fe->demodulator_priv;
+	int ret = 0;
+	u32 x1;
+
+	switch (state->diseqc_status) {
+		case DISEQC_STATUS_MOD:
+		case DISEQC_STATUS_TONE:
+			ret = avl6211_i2c_read32(state, diseqc_tx_st_addr, &x1);
+			if (ret)
+				goto err;
+			if (((x1 & 0x00000040) >> 6) != 1)
+				ret = -EINVAL;
+			break;
+		case DISEQC_STATUS_CONTINUOUS:
+		case DISEQC_STATUS_INIT:
+			break;
+		default:
+			ret = -EINVAL;
+			break;
+	}
+	if (ret)
+		goto err;
+	
+	return 0;
+	
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int avl6211_diseqc_get_tx_status(struct dvb_frontend* fe, struct avl6211_diseqc_tx_status * pTxStatus)
+{
+	struct avl6211_state *state = fe->demodulator_priv;
+	int ret;
+	u32 x1;
+
+	if ((state->diseqc_status == DISEQC_STATUS_MOD) || 
+		(state->diseqc_status == DISEQC_STATUS_TONE)) {
+		ret = avl6211_i2c_read32(state, diseqc_tx_st_addr, &x1);
+		if (ret)
+			goto err;
+			
+		pTxStatus->tx_done = (u8)((x1 & 0x00000040) >> 6);
+		pTxStatus->tx_fifo_cnt = (u8)((x1 & 0x0000003c) >> 2);
+	}
+	else
+		ret = -EINVAL;
+
+	if (ret)
+		goto err;
+	
+	return 0;
+	
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int avl6211_diseqc_send_mod_data(struct dvb_frontend* fe, const u8 * buf, u8 size)
+{
+	struct avl6211_state *state = fe->demodulator_priv;
+	int ret;
+	u32 x1, x2;
+	int cnt = 0;
+	u8 buf_tmp[8];
+	u8 Continuousflag = 0;
+
+
+	if (WARN_ON(size > 8))
+		return -EINVAL;		
+	else {
+		ret = avl6211_diseqc_switch_mode(fe);
+		if (ret)
+			goto err;
+		
+		if (state->diseqc_status == DISEQC_STATUS_CONTINUOUS) {
+			ret = avl6211_i2c_read32(state, diseqc_tx_cntrl_addr, &x1);
+			if (ret)
+				goto err;
+			if ((x1 >> 10) & 0x01) {
+				Continuousflag = 1;
+				x1 &= 0xfffff3ff;
+				ret = avl6211_i2c_write32(state, diseqc_tx_cntrl_addr, x1);
+				if (ret)
+					goto err;
+				msleep(20);
+			}
+		}
+			/* Reset rx_fifo */
+		ret = avl6211_i2c_read32(state, diseqc_rx_cntrl_addr, &x2);
+		if (ret)
+			goto err;
+		ret = avl6211_i2c_write32(state, diseqc_rx_cntrl_addr, (x2 | 0x01));
+		if (ret)
+			goto err;
+		ret = avl6211_i2c_write32(state, diseqc_rx_cntrl_addr, (x2 & 0xfffffffe));
+		if (ret)
+			goto err;
+
+		ret = avl6211_i2c_read32(state, diseqc_tx_cntrl_addr, &x1);
+		if (ret)
+			goto err;
+		x1 &= 0xfffffff8;	//set to modulation mode and put it to FIFO load mode
+		ret = avl6211_i2c_write32(state, diseqc_tx_cntrl_addr, x1);
+		if (ret)
+			goto err;
+			
+			/* Trunk address */
+		format_addr(diseqc_tx_fifo_map_addr, buf_tmp);
+		buf_tmp[3] = 0;
+		buf_tmp[4] = 0;
+		buf_tmp[5] = 0;
+		for (x2 = 0; x2 < size; x2++) {
+			buf_tmp[6] = buf[x2];
+			ret = avl6211_i2c_write(state, buf_tmp, 7);
+			if (ret)
+				goto err;
+		}
+
+		x1 |= (1 << 2);  //start fifo transmit.
+		ret = avl6211_i2c_write32(state, diseqc_tx_cntrl_addr, x1);
+		if (ret)
+			goto err;
+		
+		state->diseqc_status = DISEQC_STATUS_MOD;
+		do 
+		{
+			msleep(1);
+			if (++cnt > 500) {
+				ret = -ETIME;
+				goto err;
+			}
+			ret = avl6211_i2c_read32(state, diseqc_tx_st_addr, &x1);
+			if (ret)
+				goto err;
+		} while ( 1 != ((x1 & 0x00000040) >> 6) );
+
+		msleep(20);
+		if (Continuousflag == 1)			//resume to send out wave
+		{
+			//No data in FIFO
+			ret = avl6211_i2c_read32(state, diseqc_tx_cntrl_addr, &x1);
+			if (ret)
+				goto err;
+			x1 &= 0xfffffff8; 
+			x1 |= 0x03;		//switch to continuous mode
+			ret = avl6211_i2c_write32(state, diseqc_tx_cntrl_addr, x1);
+			if (ret)
+				goto err;
+
+			//start to send out wave
+			x1 |= (1<<10);  
+			ret = avl6211_i2c_write32(state, diseqc_tx_cntrl_addr, x1);
+			if (ret)
+				goto err;
+			
+			state->diseqc_status = DISEQC_STATUS_CONTINUOUS;
+		}
+	}
+
+	return 0;
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;;
+}
+
+static int avl6211_send_diseqc_msg(struct dvb_frontend* fe, struct dvb_diseqc_master_cmd *d)
+{
+	struct avl6211_state *state = fe->demodulator_priv;
+	struct avl6211_diseqc_tx_status tx_status;
+	int cnt = 100;
+	int ret;
+
+	if ((d->msg_len < 3) || (d->msg_len > 6))
+        	return -EINVAL;
+
+	ret = avl6211_diseqc_send_mod_data(fe, d->msg, d->msg_len);
+	if (ret)
+		goto err;
+	
+	msleep(55);		
+		
+	do {
+		ret = avl6211_diseqc_get_tx_status(fe, &tx_status);
+		if (ret)
+			goto err;
+			
+		if ( tx_status.tx_done == 1 )
+			break;
+
+		msleep(10);
+		cnt--;
+		if (!cnt) {
+			ret = -ETIME;
+			goto err;
+		}
+	} while (tx_status.tx_done != 1);
+
+	return 0;
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+
+static int avl6211_diseqc_send_burst(struct dvb_frontend* fe, fe_sec_mini_cmd_t burst)
+{
+	struct avl6211_state *state = fe->demodulator_priv;
+	struct avl6211_diseqc_tx_status tx_status;
+	int cnt = 100;
+	int tx_cnt = 0;
+	int ret;
+	u32 x1;
+	u8 buf[8];
+	u8 Continuousflag = 0;
+	
+	ret = avl6211_diseqc_switch_mode(fe);
+	if (ret)
+		goto err;
+
+	if (state->diseqc_status == DISEQC_STATUS_CONTINUOUS) {
+		ret = avl6211_i2c_read32(state, diseqc_tx_cntrl_addr, &x1);
+		if (ret)
+			goto err;
+		if ((x1 >> 10) & 0x01) {
+			Continuousflag = 1;
+			x1 &= 0xfffff3ff;
+			ret = avl6211_i2c_write32(state, diseqc_tx_cntrl_addr, x1);
+			if (ret)
+				goto err;
+			msleep(20);
+		}
+	}
+	/* No data in the FIFO */
+	ret = avl6211_i2c_read32(state, diseqc_tx_cntrl_addr, &x1);
+	if (ret)
+		goto err;
+	x1 &= 0xfffffff8;  /* Put it into the FIFO load mode */
+	if (burst == SEC_MINI_A)
+		x1 |= 0x02;
+	else
+		x1 |= 0x01;
+	ret = avl6211_i2c_write32(state, diseqc_tx_cntrl_addr, x1);
+	if (ret)
+		goto err;
+	/* Trunk address */
+	format_addr(diseqc_tx_fifo_map_addr, buf);
+	buf[3] = 0;
+	buf[4] = 0;
+	buf[5] = 0;
+	buf[6] = 1;
+
+	ret = avl6211_i2c_write(state, buf, 7);
+	if (ret)
+		goto err;
+
+	x1 |= (1<<2);  /* Start fifo transmit */
+	ret = avl6211_i2c_write32(state, diseqc_tx_cntrl_addr, x1);
+	if (ret)
+		goto err;
+	
+	state->diseqc_status = DISEQC_STATUS_TONE;
+	
+	do 
+	{
+		msleep(1);
+		if (++tx_cnt > 500) {
+			ret = -ETIME;
+			goto err;
+		}
+		ret = avl6211_i2c_read32(state, diseqc_tx_st_addr, &x1);
+		if (ret)
+			goto err;
+	} while ( 1 != ((x1 & 0x00000040) >> 6) );
+
+	msleep(20);
+	
+	if (Continuousflag == 1)			//resume to send out wave
+	{
+		//No data in FIFO
+		ret = avl6211_i2c_read32(state, diseqc_tx_cntrl_addr, &x1);
+		if (ret)
+			goto err;
+		x1 &= 0xfffffff8; 
+		x1 |= 0x03;		//switch to continuous mode
+		ret = avl6211_i2c_write32(state, diseqc_tx_cntrl_addr, x1);
+		if (ret)
+			goto err;
+
+		//start to send out wave
+		x1 |= (1<<10);  
+		ret = avl6211_i2c_write32(state, diseqc_tx_cntrl_addr, x1);
+		if (ret)
+			goto err;
+		
+		state->diseqc_status = DISEQC_STATUS_CONTINUOUS;
+			
+	}	
+	do {
+		ret = avl6211_diseqc_get_tx_status(fe, &tx_status);
+		if ( tx_status.tx_done == 1 )
+			break;
+
+		msleep(10);
+		cnt--;
+		if (!cnt) {
+			ret = -ETIME;
+			goto err;
+		}
+	} while (tx_status.tx_done != 1);
+	
+	return 0;
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int avl6211_set_tone(struct dvb_frontend* fe, fe_sec_tone_mode_t tone)
+{
+	struct avl6211_state *state = fe->demodulator_priv;
+	int ret;
+	u32 x1;
+
+	if (tone == SEC_TONE_ON) {
+		
+		ret = avl6211_diseqc_switch_mode(fe);
+		if (ret)
+			goto err;
+
+		ret = avl6211_i2c_read32(state, diseqc_tx_cntrl_addr, &x1);
+		if (ret)
+			goto err;
+		x1 &= 0xfffffff8;
+		x1 |= 0x03;	
+		ret = avl6211_i2c_write32(state, diseqc_tx_cntrl_addr, x1);
+		if (ret)
+			goto err;
+		x1 |= (1 << 10);
+		ret = avl6211_i2c_write32(state, diseqc_tx_cntrl_addr, x1);
+		if (ret)
+			goto err;
+			
+		state->diseqc_status = DISEQC_STATUS_CONTINUOUS;
+	} else {
+	
+		if (state->diseqc_status == DISEQC_STATUS_CONTINUOUS) {
+			ret = avl6211_i2c_read32(state, diseqc_tx_cntrl_addr, &x1);
+			if (ret)
+				goto err;
+			x1 &= 0xfffff3ff;
+			ret = avl6211_i2c_write32(state, diseqc_tx_cntrl_addr, x1);
+			if (ret)
+				goto err;
+		}
+	}
+	
+	return 0;
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int avl6211_set_voltage(struct dvb_frontend *fe,
+	fe_sec_voltage_t voltage)
+{
+	struct avl6211_state *state = fe->demodulator_priv;
+	int ret;
+	u32 x1;
+	
+	if (voltage == SEC_VOLTAGE_OFF) {
+	
+		if (state->config->set_external_vol_gpio)
+			state->config->set_external_vol_gpio(&state->demod_id, 0);
+		
+		state->gpio_on = false;
+		
+		return 0;
+	}
+	if (voltage == SEC_VOLTAGE_13) {
+		if (state->config->use_lnb_pin59) {
+			ret = avl6211_i2c_read32(state, diseqc_tx_cntrl_addr, &x1);
+			if (ret)
+				goto err;
+			x1 &= 0xfffffdff;		
+			ret = avl6211_i2c_write32(state, diseqc_tx_cntrl_addr, x1);
+			if (ret)
+				goto err;
+			msleep(20);	//delay 20ms
+		}
+		
+		if (state->config->use_lnb_pin60) {
+					
+			ret = avl6211_i2c_read32(state, gpio_reg_enb, &x1);
+			if (ret)
+				goto err;
+			x1 &= ~(1<<1);
+			ret = avl6211_i2c_write32(state, gpio_reg_enb, x1);  
+			if (ret)
+				goto err;
+			ret = avl6211_i2c_read32(state, gpio_data_reg_out, &x1);	
+			if (ret)
+				goto err;
+			x1 &= ~(1<<1) ;			
+			ret = avl6211_i2c_write32(state, gpio_data_reg_out, x1);
+			if (ret)
+				goto err;
+			msleep(20);
+
+		}						
+	} else if (voltage == SEC_VOLTAGE_18) {
+	
+		if (state->config->use_lnb_pin59) {
+			ret = avl6211_i2c_read32(state, diseqc_tx_cntrl_addr, &x1);
+			if (ret)
+				goto err;
+			x1 &= 0xfffffdff;
+			x1 |= 0x200;
+			ret = avl6211_i2c_write32(state, diseqc_tx_cntrl_addr, x1);
+			if (ret)
+				goto err;
+			msleep(20);	//delay 20ms
+		}
+		if (state->config->use_lnb_pin60) {
+			ret = avl6211_i2c_read32(state, gpio_reg_enb, &x1);
+			if (ret)
+				goto err;
+			x1 &= ~(1<<1);
+			ret = avl6211_i2c_write32(state, gpio_reg_enb, x1);  
+			if (ret)
+				goto err;
+			ret = avl6211_i2c_read32(state, gpio_data_reg_out, &x1);	
+			if (ret)
+				goto err;
+			x1 |= 1<<1 ;			
+			ret = avl6211_i2c_write32(state, gpio_data_reg_out, x1);
+			if (ret)
+				goto err;
+			msleep(20);
+		}		
+	}
+	
+	if (!state->gpio_on) {	
+		state->gpio_on = true;		
+		if (state->config->set_external_vol_gpio) 
+			state->config->set_external_vol_gpio(&state->demod_id, 1);
+	}
+	return 0;
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int avl6211_read_ber(struct dvb_frontend* fe, u32* ber)
+{
+	struct avl6211_state *state = fe->demodulator_priv;
+	int ret;
+	u32 r_ber;
+
+	*ber = 0;
+	
+	if (state->locked == 1) {		
+		ret = avl6211_i2c_read32(state, rp_uint_BER_addr, &r_ber);
+		if (ret)
+			goto err;
+			
+		if (r_ber > 0)			
+			*ber = r_ber / 1000000000;			
+	}
+	
+	return 0;
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+
+u8 DVBS_SNR[6] = { 12, 32, 41, 52, 58, 62 };
+u8 DVBS2Qpsk_SNR[8] = { 10, 24, 32, 41, 47, 52, 63, 65 };
+u8 DVBS28psk_SNR[6] = { 57, 67, 80, 95, 100, 110 };
+static int avl6211_read_snr(struct dvb_frontend* fe, u16 *snr)
+{
+	struct avl6211_state *state = fe->demodulator_priv;
+	int ret;
+	u8 SNRrefer = 0;
+	u32 r_snr, code_rate, modulation;
+
+	*snr = 0;
+	
+	if (state->locked == 1) {
+		ret = avl6211_i2c_read32(state, rs_int_SNR_dB_addr, &r_snr);
+		if (ret)
+			goto err;
+		if (r_snr < 10000) {
+			ret = avl6211_i2c_read32(state, rs_code_rate_addr, &code_rate);
+			if (ret)
+				goto err;
+			ret = avl6211_i2c_read32(state, rs_modulation_addr, &modulation);
+			if (ret)
+				goto err;
+				
+			if (code_rate < 6)
+				SNRrefer = DVBS_SNR[code_rate];			
+			else {
+				if (modulation == 1)
+					SNRrefer = DVBS28psk_SNR[code_rate - 10];
+				else	
+					SNRrefer = DVBS2Qpsk_SNR[code_rate - 9];
+			}	
+			if ((r_snr / 10) > SNRrefer) {
+				r_snr = r_snr/10 - SNRrefer;
+				if (r_snr >= 100)
+					*snr = 99;
+				else if (r_snr >= 50)  //  >5.0dB
+					*snr = 80+ (r_snr - 50)*20/50;
+				else if (r_snr >= 25)  //  > 2.5dB
+					*snr = 50+ (r_snr - 25)*30/25;
+				else if (r_snr >= 10)  //  > 1dB
+					*snr = 25+ (r_snr - 10)*25/15;			
+				else 
+					*snr = 5 + (r_snr)*20/10;
+					
+					*snr = (*snr * 65535) / 100;
+			}
+		}
+	}
+	
+	return 0;
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+struct Signal_Level
+{
+	u16 SignalLevel;
+	short SignalDBM;
+};
+struct Signal_Level  AGC_LUT [91]=
+{
+    {63688,  0},{62626, -1},{61840, -2},{61175, -3},{60626, -4},{60120, -5},{59647, -6},{59187, -7},{58741, -8},{58293, -9},
+    {57822,-10},{57387,-11},{56913,-12},{56491,-13},{55755,-14},{55266,-15},{54765,-16},{54221,-17},{53710,-18},{53244,-19},
+    {52625,-20},{52043,-21},{51468,-22},{50904,-23},{50331,-24},{49772,-25},{49260,-26},{48730,-27},{48285,-28},{47804,-29},
+    {47333,-30},{46880,-31},{46460,-32},{46000,-33},{45539,-34},{45066,-35},{44621,-36},{44107,-37},{43611,-38},{43082,-39},
+    {42512,-40},{41947,-41},{41284,-42},{40531,-43},{39813,-44},{38978,-45},{38153,-46},{37294,-47},{36498,-48},{35714,-49},
+    {35010,-50},{34432,-51},{33814,-52},{33315,-53},{32989,-54},{32504,-55},{32039,-56},{31608,-57},{31141,-58},{30675,-59},
+    {30215,-60},{29711,-61},{29218,-62},{28688,-63},{28183,-64},{27593,-65},{26978,-66},{26344,-67},{25680,-68},{24988,-69},
+    {24121,-70},{23285,-71},{22460,-72},{21496,-73},{20495,-74},{19320,-75},{18132,-76},{16926,-77},{15564,-78},{14398,-79},
+    {12875,-80},{11913,-81},{10514,-82},{ 9070,-83},{ 7588,-84},{ 6044,-85},{ 4613,-86},{ 3177,-87},{ 1614,-88},{  123,-89},
+    {    0,-90}
+};
+static int avl6211_read_signal_strength(struct dvb_frontend* fe, u16* signal_strength)
+{
+	#define Level_High_Stage	36
+	#define Level_Low_Stage		76
+
+	#define Percent_Space_High	10
+	#define Percent_Space_Mid	30
+	#define Percent_Space_Low	60
+	
+	struct avl6211_state *state = fe->demodulator_priv;
+	int ret;
+	u32 rf;
+	u16 Level;
+	int i = 0;
+	int Percent = 0;
+	*signal_strength = 0;
+		
+	if (state->locked == 1) {
+		ret = avl6211_i2c_read32(state, rx_aagc_gain, &rf);
+		if (ret)
+			goto err;
+		
+		rf += 0x800000;
+		rf &= 0xffffff;	
+		Level = (u16)(rf >> 8);
+
+	while( Level < AGC_LUT[i++].SignalLevel);
+	
+	if (i <= Level_High_Stage)
+		Percent = Percent_Space_Low+Percent_Space_Mid+ (Level_High_Stage-i)*Percent_Space_High/Level_High_Stage;
+	else if(i<=Level_Low_Stage)
+		Percent = Percent_Space_Low+ (Level_Low_Stage-i)*Percent_Space_Mid/(Level_Low_Stage-Level_High_Stage);
+	else
+		Percent =(90-i)*Percent_Space_Low/(90-Level_Low_Stage);
+
+	*signal_strength = (Percent * 65535) / 100;	
+	}
+	
+	return 0;
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int avl6211_read_status(struct dvb_frontend* fe, fe_status_t* status)
+{
+	struct avl6211_state *state = fe->demodulator_priv;	
+	int ret;
+	*status = 0;
+	
+	ret = avl6211_i2c_read16(state, rs_fec_lock_addr, &state->locked);
+	if (ret)
+		goto err;
+
+	if (state->locked == 1) 
+		*status |= FE_HAS_SIGNAL | FE_HAS_CARRIER | 
+				FE_HAS_VITERBI | FE_HAS_SYNC | FE_HAS_LOCK;
+		
+	return 0;
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int avl6211_read_ucblocks(struct dvb_frontend* fe, u32* ucblocks)
+{
+	*ucblocks = 0;
+	return 0;
+}
+static int avl6211_get_frontend(struct dvb_frontend* fe)
+{
+	struct avl6211_state *state = fe->demodulator_priv;
+	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
+	u32 code_rate;
+	u16 ret;
+		
+	if (!state->locked)
+		return 0;
+	
+	ret = avl6211_i2c_read32(state, rs_code_rate_addr, &code_rate);
+	if (ret)
+		goto err;
+		
+	p->frequency = state->frequency;
+	p->inversion = INVERSION_AUTO;
+	p->symbol_rate = state->symbol_rate;
+	
+	switch (code_rate) { 
+		case 0:
+		p->fec_inner = FEC_1_2;
+		break;
+		case 1:
+		p->fec_inner = FEC_2_3;
+		break;
+		case 2:
+		p->fec_inner = FEC_3_4;
+		break;
+		case 13:
+		p->fec_inner = FEC_4_5;
+		break;
+		case 14:
+		p->fec_inner = FEC_5_6;
+		break;
+		case 4:
+		p->fec_inner = FEC_6_7;
+		break;
+		case 5:
+		p->fec_inner = FEC_7_8;
+		break;
+		case 15:
+		p->fec_inner = FEC_8_9;
+		break;
+		case 10:
+		p->fec_inner = FEC_3_5;
+		break;
+		case 16:
+		p->fec_inner = FEC_9_10;
+		break;
+		default:
+		p->fec_inner = FEC_AUTO;
+		break;
+	}
+	return 0;
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int avl6211_channel_lock(struct dvb_frontend* fe)
+{
+    struct avl6211_state *state = fe->demodulator_priv;
+	int ret;
+	u32 IQ;
+	u32 autoIQ_Detect;
+	u16 Standard;
+	u16 auto_manual_lock;
+	int cnt = 0;
+
+	ret = avl6211_i2c_write16(state, rc_lock_mode_addr, 0);	
+	if (ret)
+		goto err;
+		
+	IQ = ((state->flags) & CI_FLAG_IQ_BIT_MASK) >> CI_FLAG_IQ_BIT;
+	ret = avl6211_i2c_write32(state, rc_specinv_addr, IQ);
+	if (ret)
+		goto err;
+	
+	Standard = (u16)(((state->flags) & CI_FLAG_DVBS2_BIT_MASK) >> CI_FLAG_DVBS2_BIT);
+	autoIQ_Detect = (((state->flags) & CI_FLAG_IQ_AUTO_BIT_MASK) >> CI_FLAG_IQ_AUTO_BIT);
+	auto_manual_lock = (u16)(((state->flags) & CI_FLAG_MANUAL_LOCK_MODE_BIT_MASK) >> CI_FLAG_MANUAL_LOCK_MODE_BIT);
+
+	
+	if((Standard == CI_FLAG_DVBS2_UNDEF) || (autoIQ_Detect == 1))
+		Standard = 0x14;
+
+	if (state->symbol_rate == 0)
+		state->symbol_rate = 1;
+	
+	ret = avl6211_i2c_write16(state, rc_fec_bypass_coderate_addr, auto_manual_lock);
+	if (ret)
+		goto err;
+	ret = avl6211_i2c_write16(state, rc_decode_mode_addr, Standard);
+	if (ret)
+		goto err;
+	ret = avl6211_i2c_write16(state, rc_iq_mode_addr, (u16)autoIQ_Detect);
+	if (ret)
+		goto err;
+	ret = avl6211_i2c_write32(state, rc_int_sym_rate_MHz_addr, state->symbol_rate);
+	if (ret)
+		goto err;
+	
+	
+	ret = avl6211_send_op(OP_RX_INIT_GO, state);
+	if (ret)
+		goto err;
+		
+	do {
+		ret = avl6211_get_op_status(state);
+		if(!ret)
+			break;
+		msleep(1);
+	} while(cnt++ < 200);
+	
+	if (ret)
+		goto err;
+		
+	return 0;
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int avl6211_set_frontend(struct dvb_frontend* fe)
+{
+	struct avl6211_state *state = fe->demodulator_priv;
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	int ret;
+	u16 cnt;
+	u32 max_time;
+	
+	
+	state->frequency = c->frequency;
+	state->symbol_rate = c->symbol_rate;
+	
+	state->locked = 0;
+
+	dev_dbg(&state->i2c->dev, 
+		"%s: delivery_system=%d frequency=%d symbol_rate=%d\n", 
+		__func__, c->delivery_system, c->frequency, c->symbol_rate);
+
+	state->tuner_lpf = (state->symbol_rate / 100000);
+	if (state->tuner_lpf > 440)
+		state->tuner_lpf = 440;
+
+	ret = av2011_lock(fe);
+	if (ret)
+		goto err;
+
+	/* Wait for tuner locking */
+	max_time = 150;  /* Max waiting time: 150ms */
+
+	cnt = max_time / 10;
+	do {	
+		ret = av2011_tuner_lock_status(fe);		
+
+		if (!ret)
+			break;
+		else {		
+			msleep(10);    /* Wait 10ms for demod to lock the channel */			
+			continue;
+		}		
+		
+	} while (--cnt);
+
+	if (!cnt) {
+		ret = -EAGAIN;
+		goto err;
+	}
+	
+	dev_dbg(&state->i2c->dev, "Tuner successfully lock!\n");
+
+	state->flags = (CI_FLAG_IQ_NO_SWAPPED) << CI_FLAG_IQ_BIT;			//Normal IQ
+	state->flags |= (CI_FLAG_IQ_AUTO_BIT_AUTO) << CI_FLAG_IQ_AUTO_BIT;	//Enable automatic IQ swap detection
+	state->flags |= (CI_FLAG_DVBS2_UNDEF) << CI_FLAG_DVBS2_BIT;			//Enable automatic standard detection
+
+	//This function should be called after tuner locked to lock the channel.
+	ret = avl6211_channel_lock(fe);
+	if (ret)
+		goto err;
+		
+	/* Wait a bit more when we have slow symbol rates */
+	if (c->symbol_rate < 5000000)
+		max_time = 5000*2; /* Max waiting time: 1000ms */
+	else if (c->symbol_rate < 10000000)
+		max_time = 600*2;  /* Max waiting time: 600ms */
+	else
+		max_time = 250*2;  /* Max waiting time: 250ms */
+
+	cnt = max_time / 10;
+	do {
+		ret = avl6211_i2c_read16(state, rs_fec_lock_addr, &state->locked);
+
+		if (!ret && state->locked == 1)
+				break;
+
+		msleep(10);    /* Wait 10ms for demod to lock the channel */		
+	} while (--cnt);
+	
+	if (!cnt) {
+		ret = -EAGAIN;
+		goto err;
+	}
+	dev_dbg(&state->i2c->dev, "Service locked!!!\n");
+
+	ret = avl6211_send_op(OP_RX_RESET_BERPER, state);
+	if (ret)
+		goto err;
+	
+	return 0;
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+	
+}
+
+static int avl6211_get_demod_status(struct dvb_frontend* fe)
+{
+	struct avl6211_state *state = fe->demodulator_priv;
+	int ret;
+	u8	buf[2]; 
+	u32 x1 = 0;
+	
+	ret = avl6211_i2c_read32(state, core_reset_b_reg, &x1);
+	if (ret)
+		goto err;
+	ret = avl6211_i2c_read16(state, core_ready_word_addr, (u16 *)buf);	
+	if (ret)
+		goto err;
+	
+	if ((x1 == 0) || (buf[0] != 0x5a) || (buf[1] != 0xa5)) {
+		ret = -EINVAL;
+		goto err;
+	}
+	
+	return 0;
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+
+static int avl6211_setup_pll(struct avl6211_state* state, const struct avl6211_pllconf * pll_ptr)
+{
+	int ret;
+	
+	ret = avl6211_i2c_write32(state, pll_clkf_map_addr, pll_ptr->m_uiClkf);
+	if (ret)
+		goto err;
+	ret = avl6211_i2c_write32(state, pll_bwadj_map_addr, pll_ptr->m_uiClkf);
+	if (ret)
+		goto err;
+	ret = avl6211_i2c_write32(state, pll_clkr_map_addr, pll_ptr->m_uiClkr);
+	if (ret)
+		goto err;
+	ret = avl6211_i2c_write32(state, pll_od_map_addr, pll_ptr->m_uiPllod);
+	if (ret)
+		goto err;
+	ret = avl6211_i2c_write32(state, pll_od2_map_addr, pll_ptr->m_uiPllod2);
+	if (ret)
+		goto err;
+	ret = avl6211_i2c_write32(state, pll_od3_map_addr, pll_ptr->m_uiPllod3);
+	if (ret)
+		goto err;
+	ret = avl6211_i2c_write32(state, pll_softvalue_en_map_addr, 1);
+	if (ret)
+		goto err;
+	ret = avl6211_i2c_write32(state, reset_register_addr, 0);
+	if (ret)
+		goto err;
+	
+	/* Reset do not check for error */
+	avl6211_i2c_write32(state, reset_register_addr, 1);
+	
+	state->demod_freq = pll_ptr->demod_freq;
+	state->fec_freq = pll_ptr->fec_freq;
+	state->mpeg_freq = pll_ptr->mpeg_freq;
+
+	return 0;
+	
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int avl6211_load_firmware(struct dvb_frontend* fe)
+{
+	struct avl6211_state* state = fe->demodulator_priv;
+	const struct firmware *fw = NULL;
+	u8 *buffer = NULL;
+	u32 buf_size, data_size;
+	u32 i = 4;
+	int ret;
+	
+	ret = avl6211_i2c_write32(state, core_reset_b_reg, 0);
+	if (ret)
+		goto err;
+
+	dev_dbg(&state->i2c->dev, "Uploading demod firmware (%s)...\n", AVL6211_DEMOD_FW);
+	ret = request_firmware(&fw, AVL6211_DEMOD_FW, &state->i2c->dev);
+	if (ret) {
+		dev_dbg(&state->i2c->dev, "Firmware upload failed. Timeout or file not found\n");
+		goto err;
+	}    
+
+	buffer = kmalloc(fw->size , GFP_KERNEL);
+	if (!buffer) {
+		release_firmware(fw);
+		fw = NULL;
+		dev_dbg(&state->i2c->dev, "Failed to allocate tmp memory for firmware\n");
+		return -ENOMEM;
+	}
+	memcpy(buffer, fw->data, fw->size);
+	
+	release_firmware(fw);
+	fw = NULL;
+	
+	data_size = extract_32(buffer);
+	while (i < data_size)
+	{
+		buf_size = extract_32(buffer + i);
+		i += 4;
+		ret = avl6211_i2c_write(state, buffer + i + 1, (u16)(buf_size + 3));
+		if (ret)
+			goto err;
+			
+		i += 4 + buf_size;
+	}
+	
+	ret = avl6211_i2c_write32(state, 0x00000000, 0x00003ffc);
+	if (ret)
+			goto err;
+	ret = avl6211_i2c_write16(state, core_ready_word_addr, 0x0000);
+	if (ret)
+			goto err;
+	ret = avl6211_i2c_write32(state, error_msg_addr, 0x00000000);
+	if (ret)
+			goto err;
+	ret = avl6211_i2c_write32(state, error_msg_addr + 4, 0x00000000);
+	if (ret)
+			goto err;
+
+	/* Reset do not check for error */
+	avl6211_i2c_write32(state, core_reset_b_reg, 1);
+	
+	kfree(buffer);
+	return 0;
+	
+err:
+	kfree(buffer);
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+
+static int avl6211_init(struct dvb_frontend* fe)
+{
+	struct avl6211_state* state = fe->demodulator_priv;
+	int ret;
+
+	if (state->boot)
+		return 0;
+		
+	ret = avl6211_setup_pll(state, (const struct avl6211_pllconf * )(pll_conf + state->config->demod_refclk));
+	if (ret)
+		goto err;
+		
+	msleep(100);
+	
+	ret = avl6211_load_firmware(fe);
+	if (ret)
+		goto err;
+		
+	msleep(100);
+	
+	ret = avl6211_get_demod_status(fe);
+	if (ret)
+		goto err;
+	
+	
+	ret = avl6211_i2c_write32(state, 0x263E, 50000);
+	if (ret)
+		goto err;
+	/* Set clk to match the PLL */
+	ret = avl6211_i2c_write16(state, rc_int_dmd_clk_MHz_addr,  state->demod_freq);
+	if (ret)
+		goto err;
+	ret = avl6211_i2c_write16(state, rc_int_fec_clk_MHz_addr, state->fec_freq);
+	if (ret)
+		goto err;
+	ret = avl6211_i2c_write16(state, rc_int_mpeg_clk_MHz_addr, state->mpeg_freq);
+	if (ret)
+		goto err;
+	ret = avl6211_i2c_write32(state, rc_format_addr, 1);
+	if (ret)
+		goto err;
+	
+	/* Set AGC polarization */
+	ret = avl6211_i2c_write32(state, rc_rfagc_pol_addr, (u32)state->config->tuner_rfagc);
+	if (ret)
+		goto err;	
+	/* Drive RF AGC */
+	ret = avl6211_i2c_write16(state, rc_aagc_ref_addr, 0x30);
+	if (ret)
+		goto err;
+	ret = avl6211_i2c_write32(state, rc_rfagc_tri_enb, 1);
+	if (ret)
+		goto err;
+
+	ret = avl6211_i2c_write16(state, rc_blind_scan_tuner_spectrum_inversion_addr, (u16)state->config->tuner_spectrum);
+	if (ret)
+		goto err;
+	
+	ret = avl6211_i2c_write32(state, rc_mpeg_mode_addr, (u32)(state->config->mpeg_format));
+	if (ret)
+		goto err;
+	ret = avl6211_i2c_write16(state, rc_mpeg_serial_addr, (u16)(state->config->mpeg_mode));
+	if (ret)
+		goto err;
+	ret = avl6211_i2c_write16(state, rc_mpeg_posedge_addr, (u16)(state->config->mpeg_pol));
+	if (ret)
+		goto err;
+	
+	if (state->config->mpeg_mode) {
+		ret = avl6211_i2c_write32(state, rc_outpin_sel_addr, (u32)(state->config->mpeg_pin));		
+		if (ret)
+			goto err;
+	}
+	
+	ret = avl6211_i2c_write32(state, rc_mpeg_bus_tri_enb, 1);
+	if (ret)
+		goto err;
+	
+	ret = av2011_tuner_init(fe);
+	if (ret)
+		goto err;
+	ret = avl6211_diseqc_init(fe);
+	if (ret)
+		goto err;
+	
+	ret = avl6211_i2c_write32(state,  gpio_data_reg_out, 0);
+	if (ret)
+		goto err;
+	
+	ret = avl6211_i2c_write32(state, gpio_reg_enb, 0);
+	if (ret)
+		goto err;
+	
+	state->boot = true;
+	
+	dev_dbg(&state->i2c->dev, "AVL6211+AV2011 init OK\n");
+	
+	return 0;
+
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static void avl6211_release(struct dvb_frontend* fe)
+{
+	struct avl6211_state* state = fe->demodulator_priv;
+	kfree(state);
+}
+
+static struct dvb_frontend_ops avl6211_ops = {
+	.delsys = { SYS_DVBS, SYS_DVBS2 }, 
+	.info = {
+		.name = "Availink AVL6211+AV2011 DVB-S/S2",	
+		.frequency_min = 950000,
+		.frequency_max = 2150000,
+		.frequency_stepsize = 0,		
+		.frequency_tolerance = 0,
+		.symbol_rate_min = 800000,		/* Min = 800K */
+		.symbol_rate_max = 50000000,	/* Max = 50M */
+		.caps = FE_CAN_INVERSION_AUTO |
+			FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |
+			FE_CAN_FEC_4_5 | FE_CAN_FEC_5_6 | FE_CAN_FEC_6_7 |
+			FE_CAN_FEC_7_8 | FE_CAN_FEC_8_9 | FE_CAN_FEC_AUTO |
+			FE_CAN_QPSK    | FE_CAN_RECOVER | FE_CAN_2G_MODULATION			
+	},
+
+	.init = avl6211_init,
+	.release = avl6211_release,
+	.read_status = avl6211_read_status,
+	.read_ber = avl6211_read_ber,
+	.read_signal_strength = avl6211_read_signal_strength,
+	.read_snr = avl6211_read_snr,
+	.read_ucblocks = avl6211_read_ucblocks,
+	.set_tone = avl6211_set_tone,	
+	.set_voltage = avl6211_set_voltage,
+	.diseqc_send_master_cmd = avl6211_send_diseqc_msg,
+	.diseqc_send_burst = avl6211_diseqc_send_burst,
+	.set_frontend = avl6211_set_frontend,
+	.get_frontend = avl6211_get_frontend,
+};
+
+struct dvb_frontend* avl6211_attach(struct i2c_adapter* i2c,
+									struct avl6211_config* config,
+									int id)
+									
+{
+	struct avl6211_state* state = NULL;
+	int ret;
+	u32 ChipID = 0;
+	
+	state = kzalloc(sizeof(struct avl6211_state), GFP_KERNEL);
+	if (!state) {
+		ret = -ENOMEM;
+		dev_err(&i2c->dev, "kzalloc() failed\n");
+		goto err1;
+	}
+
+	state->config = config;
+	state->i2c = i2c;	
+	state->demod_id = id;
+	
+	ret = avl6211_i2c_read32(state, rs_cust_chip_id_addr, &ChipID);
+	if (ret || ChipID != 0x0000000F)
+		goto err2;
+
+	dev_info(&i2c->dev, "AVL6211+AV2011 DVB-S/S2 successfully attached\n");	
+	
+	memcpy(&state->frontend.ops, &avl6211_ops, sizeof(struct dvb_frontend_ops));
+	state->frontend.demodulator_priv = state;
+
+	return &state->frontend;
+	
+err2:	
+	kfree(state);
+err1:	
+	dev_dbg(&i2c->dev, "%s: failed=%d\n", __func__, ret);	
+	return NULL;
+}
+
+EXPORT_SYMBOL(avl6211_attach);
+
+MODULE_DESCRIPTION("Availink AVL6211+AV2011 demod+tuner driver");
+MODULE_AUTHOR("Sasa Savic <sasa.savic.sr@gmail.com>");
+MODULE_LICENSE("GPL");
diff --git a/drivers/amlogic/dvb_tv/avl6211.h b/drivers/amlogic/dvb_tv/avl6211.h
new file mode 100644
index 000000000000..75c68cfb631c
--- /dev/null
+++ b/drivers/amlogic/dvb_tv/avl6211.h
@@ -0,0 +1,156 @@
+/*
+ * Driver for the Availink AVL6211+AV2011 DVB-S/S2 demod+tuner
+ *
+ * Copyright (C) 2014 Sasa Savic <sasa.savic.sr@gmail.com>
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License along
+ *    with this program; if not, write to the Free Software Foundation, Inc.,
+ *    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+ 
+#ifndef __AVL6211_H_
+#define __AVL6211_H_
+
+#include <linux/types.h>
+#include <linux/i2c.h>
+
+
+#define AVL6211_DEMOD_FW 		"dvb-fe-avl6211.fw" 
+
+#define I2C_MAX_READ	64
+#define I2C_MAX_WRITE	64
+
+
+#define CI_FLAG_IQ_BIT							0x00000000
+#define CI_FLAG_IQ_BIT_MASK						0x00000001
+#define CI_FLAG_IQ_NO_SWAPPED					0x00000000
+#define CI_FLAG_IQ_SWAPPED						0x00000001
+#define CI_FLAG_IQ_AUTO_BIT_MASK				0x00000020  
+
+
+#define CI_FLAG_IQ_AUTO_BIT						0x00000005
+#define CI_FLAG_IQ_AUTO_BIT_AUTO				0x00000001
+
+#define CI_FLAG_DVBS2_BIT						0x00000002
+#define CI_FLAG_DVBS2_UNDEF						0x00000004
+#define CI_FLAG_DVBS2_BIT_MASK					0x0000001c
+
+#define CI_FLAG_MANUAL_LOCK_MODE_BIT			0x00000001
+#define CI_FLAG_MANUAL_LOCK_MODE_BIT_MASK		0x00000002
+#define CI_FLAG_LOCK_MODE_BIT_MASK				0x00000040
+
+
+#define ENABLE_FAST_REACQ           0x01
+#define DISABLE_FAST_REACQ          0x00
+#define ENABLE_CCI                  0x03
+#define DISABLE_CCI                 0x02
+#define MAX_LOWIF_SR                5000000
+#define IF_OFFSET                   500
+
+
+/* Demod commands */
+#define OP_RX_NOOP                  0x00
+#define OP_RX_LD_DEFAULT            0x01
+#define OP_RX_INIT_GO               0x02
+#define OP_RX_RESET_BERPER          0x03
+#define OP_RX_HALT                  0x04
+#define OP_RX_SLEEP                 0x05
+#define OP_RX_WAKE                  0x06
+#define OP_RX_BLIND_SCAN            0x08
+#define OP_RX_STDOUT_MODE           0x09
+	
+/* Diseqc status */
+#define DISEQC_STATUS_UNINIT				0x00
+#define DISEQC_STATUS_INIT					0x01
+#define DISEQC_STATUS_CONTINUOUS			0x02
+#define DISEQC_STATUS_TONE					0x03
+#define DISEQC_STATUS_MOD					0x04
+
+#define I2CM_CMD_LENGTH   0x14
+#define I2CM_RSP_LENGTH   0x14
+
+#define OP_I2CM_NOOP      0x00
+#define OP_I2CM_INIT	  0x01
+#define OP_I2CM_WRITE     0x02
+#define OP_I2CM_READ      0x03
+
+	
+
+#define format_addr(X, Y)		\
+	do {						\
+		Y[0] =(u8)((X) >> 16);	\
+		Y[1] =(u8)((X) >> 8);	\
+		Y[2] =(u8)(X);			\
+	} while (0)
+
+
+#define format_16(X, Y)			\
+	do {						\
+		Y[0] =(u8)((X) >> 8);	\
+		Y[1] =(u8)((X) & 0xFF);	\
+	} while (0)
+
+
+#define format_32(X, Y)			\
+	do {						\
+		Y[0] =(u8)((X) >> 24);	\
+		Y[1] =(u8)((X) >> 16);	\
+		Y[2] =(u8)((X) >> 8);	\
+		Y[3] =(u8)((X) & 0xFF);	\
+	} while (0)
+
+
+struct avl6211_pllconf
+{
+	u16 m_uiClkf; /* Feedback clock divider */
+	u16 m_uiClkr; /* Reference clock divider */
+	u16 m_uiPllod; /* PLL output divider */
+	u16 m_uiPllod2; /* PLL output divider 2 */
+	u16 m_uiPllod3; /* PLL output divider 3 */
+	u16 ref_freq; /* Reference clock in kHz */
+	u16 demod_freq; /* Demod clock in 10kHz */
+	u16 fec_freq; /* FEC clock in 10kHz */
+	u16 mpeg_freq; /* MPEG clock in 10kHz */
+};
+
+struct avl6211_config
+{
+	u8 tuner_address; /* Tuner i2c address */
+	u16 tuner_i2c_clock;	
+	u8 demod_address;	/* The demodulator's i2c address  0x0C */ 
+				
+	u8 mpeg_pol; /* 0 - Falling, 1 - Rising */
+	u8 mpeg_mode; /* 0 - Parallel, 1 - Serial */
+	u8 mpeg_format; /* 0 - Default TS stream, 1 - TS stream plus parity format */
+	
+	u8 demod_refclk; /* Reference clock frequency selection */
+
+	/* Serial data is output on pin */
+	u8 mpeg_pin; /* 0 -  MPEG_DATA_0, 1 - MPEG_DATA_7 */
+	
+	u8 tuner_rfagc; /* 0 - Normal pol, 1 - Inverted pol */
+	u8 tuner_spectrum; /* 0 - signal spectrum normal, 1 - signal spectrum inverted */
+	
+	u8 use_lnb_pin59; /* control 13/18V over demod GPIO pin59 */
+	u8 use_lnb_pin60; /* control 13/18V over demod GPIO pin60 */
+
+	int (*set_external_vol_gpio)(int *demod_id, int on); /* external 13/18V control */
+};
+
+
+
+extern struct dvb_frontend* avl6211_attach(struct i2c_adapter* i2c,
+											struct avl6211_config* config,
+											int id);
+
+#endif
\ No newline at end of file
diff --git a/drivers/amlogic/dvb_tv/avl6211_reg.h b/drivers/amlogic/dvb_tv/avl6211_reg.h
new file mode 100644
index 000000000000..b7a0fe574a42
--- /dev/null
+++ b/drivers/amlogic/dvb_tv/avl6211_reg.h
@@ -0,0 +1,101 @@
+/*
+ * Driver for the Availink AVL6211+AV2011 DVB-S/S2 demod+tuner
+ *
+ * Copyright (C) 2014 Sasa Savic <sasa.savic.sr@gmail.com>
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License along
+ *    with this program; if not, write to the Free Software Foundation, Inc.,
+ *    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+ 
+#ifndef __AVL6211_REG_H_
+#define __AVL6211_REG_H_
+
+
+#define core_reset_b_reg            				0x600000
+#define gpio_data_in_to_reg         				0x6C0004
+#define gpio_data_reg_out           				0x6C0008
+#define gpio_reg_enb                				0x6C000C
+
+#define pll_clkr_map_addr           				0x6C40C0
+#define pll_clkf_map_addr          					0x6C4100
+#define pll_od_map_addr             				0x6C4080
+#define pll_od2_map_addr            				0x6C4140
+#define pll_od3_map_addr            				0x6C4180
+#define pll_bwadj_map_addr          				0x6C41C0
+#define pll_softvalue_en_map_addr   				0x6C4200
+#define reset_register_addr         				0x6C4000
+
+	
+#define rx_aagc_gain                                0x0040004C
+#define rc_rfagc_tri_enb                            0x006C002C
+#define rc_mpeg_bus_tri_enb                         0x006C0028
+
+
+#define raptor_status_addr						   (0x00000860 + 0x0)
+#define rx_state_addr                              (0x00000690 + 0x0)
+#define rx_cmd_addr                                (0x00000400 + 0x0)
+#define i2cm_cmd_addr                              (0x00000404 + 0x0)
+#define i2cm_rsp_addr                              (0x00000418 + 0x0)
+#define error_msg_addr                             (0x0000042c + 0x0)
+#define rx_config_addr                             (0x0000043c + 0x0)
+#define core_ready_word_addr                       (0x00000434 + 0x0)
+
+#define rs_cust_chip_id_addr                        0x006C0034
+
+#define	rp_uint_BER_addr                           (raptor_status_addr + 0x0)
+#define	rc_rfagc_pol_addr                          (rx_config_addr + 0x0)
+#define	rc_equalizer_addr                          (rx_config_addr + 0x8)
+#define	rs_code_rate_addr                          (rx_state_addr + 0x8)
+#define	rs_modulation_addr                         (rx_state_addr + 0xc)
+#define	rc_format_addr                             (rx_config_addr + 0x10)
+#define	rc_mpeg_mode_addr                          (rx_config_addr + 0x20)
+#define	rc_outpin_sel_addr                         (rx_config_addr + 0x24)
+#define	rs_int_SNR_dB_addr                         (rx_state_addr + 0x40)
+#define	rc_aagc_ref_addr                           (rx_config_addr + 0xaa)
+#define	rc_mpeg_posedge_addr                       (rx_config_addr + 0xbc)
+#define	rc_mpeg_serial_addr                        (rx_config_addr + 0xbe)
+#define	rs_fec_lock_addr                           (rx_state_addr + 0x164)
+#define	rc_specinv_addr                            (rx_config_addr + 0x34)
+#define	rc_int_sym_rate_MHz_addr                   (rx_config_addr + 0x54)
+#define	rc_dvbs_ber_addr                           (rx_config_addr + 0x98)
+#define	rc_int_dmd_clk_MHz_addr                    (rx_config_addr + 0x162)
+#define	rc_int_fec_clk_MHz_addr                    (rx_config_addr + 0x164)
+#define	rc_int_mpeg_clk_MHz_addr                   (rx_config_addr + 0x166)
+#define	rc_int_carrier_freq_half_range_MHz_addr    (rx_config_addr + 0x16c)
+#define	rc_fec_bypass_coderate_addr                (rx_config_addr + 0x194)
+#define	rc_i2cm_speed_kHz_addr                     (rx_config_addr + 0x1ae)
+#define	rc_tuner_slave_addr_addr                   (rx_config_addr + 0x1b6)
+#define	rc_tuner_max_LPF_100kHz_addr               (rx_config_addr + 0x1b8)
+#define	rc_tuner_LPF_margin_100kHz_addr            (rx_config_addr + 0x1ba)
+#define	rc_tuner_use_internal_control_addr         (rx_config_addr + 0x1bc)
+
+#define	rc_decode_mode_addr                        (rx_config_addr + 0x202)
+#define	rc_iq_mode_addr                            (rx_config_addr + 0x204)
+#define	rc_lock_mode_addr                          (rx_config_addr + 0x20a)
+#define	rc_blind_scan_tuner_spectrum_inversion_addr (rx_config_addr + 0x220)
+
+
+
+#define diseqc_tx_cntrl_addr						0x00700000
+#define diseqc_tone_frac_n_addr						0x00700004
+#define diseqc_tone_frac_d_addr						0x00700008
+#define diseqc_tx_st_addr							0x0070000c
+#define diseqc_rx_msg_tim_addr						0x00700014
+#define diseqc_rx_cntrl_addr						0x0070001c
+#define diseqc_srst_addr							0x00700020
+#define diseqc_samp_frac_n_addr						0x00700028
+#define diseqc_samp_frac_d_addr						0x0070002c
+#define diseqc_tx_fifo_map_addr						0x00700080
+
+#endif
diff --git a/drivers/amlogic/dvb_tv/c_stb_define.h b/drivers/amlogic/dvb_tv/c_stb_define.h
deleted file mode 100644
index 66e30f17c50a..000000000000
--- a/drivers/amlogic/dvb_tv/c_stb_define.h
+++ /dev/null
@@ -1,1162 +0,0 @@
-/* ----------------------------------------------------------------------*/
-/* This file is automatically generated from the script:*/
-/**/
-/* ./create_stb_define_for_C_code.pl*/
-/**/
-/* and was applied to the file*/
-/**/
-/* ./stb_define.h*/
-/**/
-/* DO NOT EDIT!!!!!*/
-/* ----------------------------------------------------------------------*/
-/**/
-#ifdef C_STB_DEFINE_H
-#else
-#define C_STB_DEFINE_H
-
-/*=================================================*/
-/*  STB Registers Start*/
-/*=================================================*/
-/* -----------------------------------------------*/
-#define STB_CBUS_BASE           0x1600
-/* -----------------------------------------------*/
-/* There are two instantiations under one CBUS slave.
- * Each CBUS slave can support*/
-/* 256 registers.
- * Each demux is allocated 128 registers so set the offset in*/
-/* the middle*/
-/* Copy this define but don't add a base address*/
-#define DEMUX_1_OFFSET         0x00
-#define DEMUX_2_OFFSET         0x50
-#define DEMUX_3_OFFSET         0xa0
-/*======================================================*/
-/*  STB TOP Registers                   (8'hf0 - 8'hf7)*/
-/*======================================================*/
-/* bit 30:28 -- ciplus_o_sel*/
-/* bit 27:26 -- ciplus_i_sel*/
-/* bit 25 -- use FAIL fro TS2*/
-/* bit 24 -- use FAIL fro TS1*/
-/* bit 23 -- use FAIL fro TS0*/
-/* bit 22 -- invert fec_error for S2P1*/
-/* bit 21 -- invert fec_data for S2P1*/
-/* bit 20 -- invert fec_sync for S2P1*/
-/* bit 19 -- invert fec_valid for S2P1*/
-/* bit 18 -- invert fec_clk for S2P1*/
-/* bit 17:16 -- fec_s_sel for S2P1
- * 00 - select TS0, 01 -- select TS1, 10 -- select TS2, 11 - reserved*/
-/* Bit 15 -- enable_des_pl_clk*/
-/* Bit 14:13 -- reserved*/
-/* Bit 12:10 -- ts_out_select,
- * 0-TS0, 1-TS1, 2-TS2, 3,4-Reserved, 5-S2P1, 6-S2P0, 7-File*/
-/* bit 9:8 -- des_i_sel 00 -- select demux0 as des input,
-*  01 -- select_demux1, 10 -- select_demux2, 11 - reserved*/
-/* bit 7 -- enable_des_pl*/
-/* bit 6 -- invert fec_error for S2P0*/
-/* bit 5 -- invert fec_data for S2P0*/
-/* bit 4 -- invert fec_sync for S2P0*/
-/* bit 3 -- invert fec_valid for S2P0*/
-/* bit 2 -- invert fec_clk for S2P0*/
-/* bit 1:0 -- fec_s_sel for S2P0
- * 00 - select TS0, 01 -- select TS1, 10 -- select TS2, 11 - reserved*/
-/*#define STB_TOP_CONFIG          (STB_CBUS_BASE + 0xf0) // 0x16f0*/
-/*----------- bit define -----------*/
-#define INVERT_S2P1_FEC_ERROR       22
-#define INVERT_S2P1_FEC_DATA        21
-#define INVERT_S2P1_FEC_SYNC        20
-#define INVERT_S2P1_FEC_VALID       19
-#define INVERT_S2P1_FEC_CLK         18
-#define S2P1_FEC_SERIAL_SEL         16
-#define ENABLE_DES_PL_CLK           15
-#define TS_OUTPUT_SOURCE            10
-#define DES_INPUT_SEL               8
-#define ENABLE_DES_PL               7
-#define INVERT_S2P0_FEC_ERROR       6
-#define INVERT_S2P0_FEC_DATA        5
-#define INVERT_S2P0_FEC_SYNC        4
-#define INVERT_S2P0_FEC_VALID       3
-#define INVERT_S2P0_FEC_CLK         2
-#define S2P0_FEC_SERIAL_SEL         0
-
-/* 31:28 - s2p1_clk_div*/
-/* 27:24 - s2p0_clk_div*/
-/* 23    - s2p1_disable*/
-/* 22    - s2p0_disable*/
-/* 21    - Reserved*/
-/* 20 -- TS_OUT_error_INVERT*/
-/* 19 -- TS_OUT_data_INVERT*/
-/* 18 -- TS_OUT_sync_INVERT*/
-/* 17 -- TS_OUT_valid_INVERT*/
-/* 16 -- TS_OUT_clk_INVERT*/
-/* 15:8 -- TS_package_length_sub_1 (default : 187)*/
-/*  7:0 -- fec_sync_byte (default : 0x47)*/
-/*#define TS_TOP_CONFIG           (STB_CBUS_BASE + 0xf1) // 0x16f1*/
-/*----------- bit define -----------*/
-#define TS_PACKAGE_LENGTH_SUB_1     8
-#define FEC_DEFAULT_SYNC_BYTE       0
-
-/* Bit 25:24 -- transport_scrambling_control_odd_2 // should be 3*/
-/* Bit 23:16 -- file_m2ts_skip_bytes*/
-/* Bit 15:8 -- des_out_dly*/
-/* Bit 7:6 -- transport_scrambling_control_odd // should be 3*/
-/* Bit 5 -- ts_hiu_enable*/
-/* Bit 4:0 -- fec_clk_div*/
-/*#define TS_FILE_CONFIG          (STB_CBUS_BASE + 0xf2) // 0x16f2*/
-/*----------- bit define -----------*/
-#define TRANSPORT_SCRAMBLING_CONTROL_ODD_2 24
-#define FILE_M2TS_SKIP_BYTES        16
-#define DES_OUT_DLY                 8
-#define TRANSPORT_SCRAMBLING_CONTROL_ODD 6
-#define TS_HIU_ENABLE               5
-#define FEC_FILE_CLK_DIV            0
-
-/* Bit 19:14 -- des_2 ts pl state   -- Read Only*/
-/* Bit 13:8 -- des ts pl state   -- Read Only*/
-/* Bit 3:0 PID index to 8 PID to get key-set*/
-/* auto increse after TS_PL_PID_DATA read/write*/
-/*#define TS_PL_PID_INDEX         (STB_CBUS_BASE + 0xf3) // 0x16f3*/
-/*----------- bit define -----------*/
-#define DES_TS_PL_STATE             8
-#define DES_2_TS_PL_STATE           14
-
-/* Bit 13 -- PID match disble*/
-/* Bit 12:0 -- PID*/
-/*#define TS_PL_PID_DATA          (STB_CBUS_BASE + 0xf4) // 0x16f4*/
-/*----------- bit define -----------*/
-#define PID_MATCH_DISABLE_HIGH       29
-#define PID_MATCH_HIGH               16
-#define PID_MATCH_DISABLE_LOW        13
-#define PID_MATCH_LOW                0
-
-/*#define COMM_DESC_KEY0
- * (STB_CBUS_BASE + 0xf5) // 0x16f5
- Common descrambler key (key bits[63:32])*/
-/*#define COMM_DESC_KEY1
- * (STB_CBUS_BASE + 0xf6) // 0x16f6
- Common descrambler key (key bits[31:0])*/
-/*#define COMM_DESC_KEY_RW
- * (STB_CBUS_BASE + 0xf7) // 0x16f7 // bits[3:0]
- * point to the address to write the key
- * {COMM_DESC_KEY3,...,COMM_DESC_KEY0}*/
-/* Writing this register writes the key to RAM*/
-
-/* bit 15:8 - des_out_dly_2*/
-/* bit   7 - reserved*/
-/* Bit   6-- enable_des_pl_clk_2*/
-/* bit   5 - enable_des_pl_2*/
-/* bit 4:2 -- use_des_2  bit[2] -- demux0, bit[3] -- demux1, bit[4] -- demux2*/
-/* bit 1:0 -- des_i_sel_2 00 -- select_fec_0, 01 -- select_fec_1,
- *                        10 -- select_fec_2, 11 - reserved*/
-#define COMM_DESC_2_CTL     (STB_CBUS_BASE + 0xff) /*0x16ff*/
-
-/*=======================================================*/
-/*  Multiple STB Registers                  (8'h00 - 8'h45)*/
-/*=======================================================*/
-/* STB registers are 8'h0x*/
-/* Bit 15:0 -- version number : 0x0002  (v0.01)*/
-/*#define STB_VERSION
- * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x00)  // 0x1600 // read only*/
-/*#define STB_VERSION_2
- * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x00)  // 0x1650 // read only*/
-/*#define STB_VERSION_3
- * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x00)  // 0x16a0 // read only*/
-
-/*#define STB_TEST_REG
- *     (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x01)  // 0x1601*/
-/*#define STB_TEST_REG_2
- *     (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x01)  // 0x1651*/
-/*#define STB_TEST_REG_3
- *    (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x01)  // 0x16a1*/
-
-/* Bit 15 -- fec_core_select 1 - select descramble output*/
-/* Bit 14:12 -  fec_select
- * 0-TS0, 1-TS1, 2-TS2, 3,4-Reserved, 5-S2P1, 6-S2P0, 7-File*/
-/* Bit 11 -- FEC_CLK*/
-/* Bit 10 -- SOP*/
-/* Bit 9 -- D_VALID*/
-/* Bit 8 -- D_FAIL*/
-/* Bit 7:0 -- D_DATA 7:0*/
-/*#define FEC_INPUT_CONTROL
- * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x02)  // 0x1602*/
-/*#define FEC_INPUT_CONTROL_2
- * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x02)  // 0x1652*/
-/*#define FEC_INPUT_CONTROL_3
- * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x02)  // 0x16a2*/
-/*----------- bit define -----------*/
-#define FEC_CORE_SEL               15
-#define FEC_SEL                    12
-#define FEC_INPUT_FEC_CLK          11
-#define FEC_INPUT_SOP              10
-#define FEC_INPUT_D_VALID           9
-#define FEC_INPUT_D_FAIL            8
-
-/*#define FEC_INPUT_DATA
- * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x03)  // 0x1603 // read only*/
-/*#define FEC_INPUT_DATA_2
- * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x03)  // 0x1653 // read only*/
-/*#define FEC_INPUT_DATA_3
- * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x03)  // 0x16a3 // read only*/
-
-/* bit 31 -- enable_free_clk_fec_data_valid*/
-/* bit 30 -- enable_free_clk_stb_reg*/
-/* bit 29 -- always_use_pes_package_length*/
-/* bit 28 -- disable_pre_incomplete_section_fix*/
-/* bit 27 -- pointer_field_multi_pre_en*/
-/* bit 26 -- ignore_pre_incomplete_section*/
-/* bit 25 -- video2_enable*/
-/* bit 24:22 -- video2_type*/
-/* bit 21 -- do_not_trust_pes_package_length*/
-/* bit 20 (bit 4) -- Bypass use recoder path*/
-/* bit 19 (bit 3) -- clear_PID_continuity_counter_valid*/
-/* bit 18 (bit 2) -- Disable Splicing*/
-/* bit 17 (bit 1) -- Insert PES_STRONG_SYNC in Audio PES*/
-/* bit 16 (bit 0) -- Insert PES_STRONG_SYNC in Video PES*/
-/* Bit 15 - do not trust section length*/
-/* Bit 14 - om cmd push even zero*/
-/* Bit 13 - reserved*/
-/* Bit 12 - SUB, OTHER PES interrupt at beginning of PES*/
-/* Bit 11 - discard_av_package -- for ts_recorder use only*/
-/* Bit 10 - ts_recorder_select  0:after PID filter 1:before PID filter*/
-/* Bit 9 - ts_recorder_enable*/
-/* Bit 8 - (table_id == 0xff) means section_end*/
-/* Bit 7 - do not send uncomplete section*/
-/* Bit 6 - do not discard duplicate package*/
-/* Bit 5 - search SOP when trasport_error_indicator*/
-/* Bit 4 - stb demux enable*/
-/* Bit 3 - do not reset state machine on SOP*/
-/* Bit 2 - search SOP when error happened
- * ( when ignore_fail_n_sop, will have this case)*/
-/* Bit 1 - do not use SOP input ( check FEC sync byte instead )*/
-/* Bit 0 - ignore fec_error bit when non sop ( check error on SOP only)*/
-/*#define DEMUX_CONTROL
- * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x04)  // 0x1604*/
-/*#define DEMUX_CONTROL_2
- * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x04)  // 0x1654*/
-/*#define DEMUX_CONTROL_3
- * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x04)  // 0x16a4*/
-/*----------- bit define -----------*/
-#define ENABLE_FREE_CLK_FEC_DATA_VALID          31
-#define ENABLE_FREE_CLK_STB_REG                 30
-#define BYPASS_USE_RECODER_PATH                 20
-#define CLEAR_PID_CONTINUITY_COUNTER_VALID      19
-#define DISABLE_SPLICING                        18
-#define INSERT_AUDIO_PES_STRONG_SYNC            17
-#define INSERT_VIDEO_PES_STRONG_SYNC            16
-#define SECTION_LENGTH_UNTRUSTY                 15
-#define OM_CMD_PUSH_EVEN_ZERO                   14
-#define OTHER_INT_AT_PES_BEGINING               12
-#define DISCARD_AV_PACKAGE                      11
-#define TS_RECORDER_SELECT                      10
-#define TS_RECORDER_ENABLE                      9
-#define SECTION_END_WITH_TABLE_ID               8
-#define SEND_COMPLETE_SECTION_ONLY              7
-#define KEEP_DUPLICATE_PACKAGE                  6
-#define SEACH_SOP_ON_TRANSPORT_ERROR            5
-#define STB_DEMUX_ENABLE                        4
-#define NO_RESET_ON_SOP                         3
-#define SEARCH_SOP_ON_ERROR                     2
-#define NOT_USE_OF_SOP_INPUT                    1
-#define IGNORE_NONSOP_FEC_ERROR                 0
-
-/* bit 15:8 demux package length - 1 ( default : 187 )*/
-/* bit 7:0 default is 0x47*/
-/*#define FEC_SYNC_BYTE
- * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x05)  // 0x1605*/
-/*#define FEC_SYNC_BYTE_2
- * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x05)  // 0x1655*/
-/*#define FEC_SYNC_BYTE_3
- * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x05)  // 0x16a5*/
-
-/****************************************
- * FM Memory Usage :
- * 0-15 (32 PID filter target) ---- 15:13-PID type 12:0-PID target or force data
- * (force data : 1 will mask corespoding bit,
- * 0 will disable this PID filter channel)
- * advanced setting --	bit 7:0
- *                      bit 7 -- PID bit 12:11 compare result force
- *                      bit 6 -- PID bit 10:9 compare result force
- *                      bit 5 -- PID bit 8:7 compare result force
- *                      bit 4 -- PID bit 6:5 compare result force
- *                      bit 3 -- PID bit 4:3 compare result force
- *                      bit 2 -- PID bit 2 compare result force
- *                      bit 1 -- PID bit 1 compare result force
- *                      bit 0 -- PID bit 0 compare result force
- * 16-255(15x32 Section filter target)
- * For first byte : Table_ID
- * ---- 15-Mask High 4-bits
- *   14-Mask Low 4-bits
- *   13-disable_PID_check
- *   12:8-PIDindex
- *   7:0-section target (always EQ)
- * For rest of bytes :
- * ---- 15-Mask 14-EQ/NE 13-disable_PID_check
- * ----12:8-PIDindex 7:0-section target (or force data)
- * advanced setting -- bit 7:0 force compare result
- **************************************************/
-/*----------- bit define -----------*/
-#define PID_TYPE                                13
-#define PID_TARGET                              0
-
-#define SECTION_FIRSTBYTE_MASKHIGH              15
-#define SECTION_FIRSTBYTE_MASKLOW               14
-#define SECTION_FIRSTBYTE_DISABLE_PID_CHECK     13
-#define SECTION_FIRSTBYTE_PID_INDEX             8
-#define SECTION_TARGET                          0
-
-#define SECTION_RESTBYTE_MASK                   15
-#define SECTION_RESTBYTE_MASK_EQ                14
-#define SECTION_RESTBYTE_DISABLE_PID_CHECK      13
-#define SECTION_RESTBYTE_PID_INDEX              8
-
-/* bit 31:16 -- filter memory write data hi[31:16]*/
-/* bit 15:0 -- filter memory write data low [15:0]*/
-/*#define FM_WR_DATA
- * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x06)  // 0x1606*/
-/*#define FM_WR_DATA_2
- * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x06)  // 0x1656*/
-/*#define FM_WR_DATA_3
- * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x06)  // 0x16a6*/
-/*----------- bit define -----------*/
-#define FM_WR_DATA_HI                           16
-
-/* bit 31:24 -- advanced setting hi*/
-/* bit 23:16 -- advanced setting low*/
-/* bit 15 -- filter memory write data request*/
-/* bit 7:0 -- filter memory write addr*/
-/*#define FM_WR_ADDR
- * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x07)  // 0x1607*/
-/*#define FM_WR_ADDR_2
- * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x07)  // 0x1657*/
-/*#define FM_WR_ADDR_3
- * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x07)  // 0x16a7*/
-/*----------- bit define -----------*/
-#define FM_ADVANCED_SETTING_HI                  24
-#define FM_ADVANCED_SETTING_LO                  16
-#define FM_WR_DATA_REQUEST                      15
-
-/* bit 13:8 demux state  -- read only*/
-/* bit 7:4 -- maxnum section filter compare address*/
-/* bit 3:0 -- maxnum PID filter compare address*/
-/*#define MAX_FM_COMP_ADDR
- * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x08)  // 0x1608*/
-/*#define MAX_FM_COMP_ADDR_2
- * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x08)  // 0x1658*/
-/*#define MAX_FM_COMP_ADDR_3
- * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x08)  // 0x16a8*/
-/*----------- bit define -----------*/
-#define DEMUX_STATE                             8
-#define MAX_FM_SECTION_FILTER_COMP_ADDR         4
-
-/* bit 15 - transport_error_indicator*/
-/* bit 14 - payload_unit_start_indicator*/
-/* bit 13 - transport_priority*/
-/* bit 12:0 - PID*/
-/*#define TS_HEAD_0
- * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x09)  // 0x1609*/
-/*#define TS_HEAD_0_2
- * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x09)  // 0x1659*/
-/*#define TS_HEAD_0_3
- * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x09)  // 0x16a9*/
-/*----------- bit define -----------*/
-#define TRANSPORT_ERROR_INDICATOR               15
-#define PAYLOAD_UNIT_START_INDICATOR            14
-#define TRANSPORT_PRIORITY                      13
-
-/* bit 7:6 transport_scrambling_control*/
-/* bit 5:4 adaptation_field_control*/
-/* bit 3:0 continuity_counter*/
-/*#define TS_HEAD_1
- * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x0a)  // 0x160a*/
-/*#define TS_HEAD_1_2
- * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x0a)  // 0x165a*/
-/*#define TS_HEAD_1_3
- * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x0a)  // 0x16aa*/
-/*----------- bit define -----------*/
-#define TRANSPORT_SCRAMBLING_CONTROL            6
-#define ADAPTATION_FIELD_CONTROL                4
-
-/* bit 15:12 -- om_cmd_count (read only)*/
-/* bit  11:9 -- overflow_count // bit  11:9 -- om_cmd_wr_ptr (read only)*/
-/* bit   8:6 -- om_overwrite_count // bit   8:6 -- om_cmd_rd_ptr (read only)*/
-/* bit   5:3 -- type_stb_om_w_rd (read only)*/
-/* bit     2 -- unit_start_stb_om_w_rd (read only)*/
-/* bit     1 -- om_cmd_overflow (read only)*/
-/* bit     0 -- om_cmd_pending (read)*/
-/* bit     0 -- om_cmd_read_finished (write)*/
-/*#define OM_CMD_STATUS
- * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x0b)  // 0x160b*/
-/*#define OM_CMD_STATUS_2
- * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x0b)  // 0x165b*/
-/*#define OM_CMD_STATUS_3
- * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x0b)  // 0x16ab*/
-/*----------- bit define -----------*/
-#define OM_CMD_COUNT                            12
-#define OM_OVERFLOW_COUNT                       9
-#define OM_OVERWRITE_COUNT                      6
-#define TYPE_STB_OM_W_RD                        3
-#define UNIT_START_STB_OM_W_RD                  2
-#define OM_CMD_OVERFLOW                         1
-
-/* bit 15:9 -- count_stb_om_w_rd  (read only)*/
-/* bit 8:0 -- start_stb_om_wa_rd (read only)*/
-/*#define OM_CMD_DATA
- * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x0c)  // 0x160c*/
-/*#define OM_CMD_DATA_2
- * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x0c)  // 0x165c*/
-/*#define OM_CMD_DATA_3
- * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x0c)  // 0x16ac*/
-/*----------- bit define -----------*/
-#define COUNT_STB_OM_W_RD                       9
-
-/* bit 11:0 -- offset for section data*/
-/*#define OM_CMD_DATA2
- * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x0d)  // 0x160d*/
-/*#define OM_CMD_DATA2_2
- * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x0d)  // 0x165d*/
-/*#define OM_CMD_DATA2_3
- * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x0d)  // 0x16ad*/
-
-/* bit 31:16 -- base address for section buffer group 0
- * (*0x400 to get real address)*/
-/* bit 15:0 -- base address for section buffer group 1
- * (*0x400 to get real address)*/
-/*#define SEC_BUFF_01_START
- * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x0e)  // 0x160e*/
-/*#define SEC_BUFF_01_START_2
- * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x0e)  // 0x165e*/
-/*#define SEC_BUFF_01_START_3
- * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x0e)  // 0x16ae*/
-/*----------- bit define -----------*/
-#define SEC_BUFF_0_BASE_ADDR                    16
-
-/* bit 31:16 -- base address for section buffer group 2
- * (*0x400 to get real address)*/
-/* bit 15:0 -- base address for section buffer group 3
- * (*0x400 to get real address)*/
-/*#define SEC_BUFF_23_START
- * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x0f)  // 0x160f*/
-/*#define SEC_BUFF_23_START_2
- * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x0f)  // 0x165f*/
-/*#define SEC_BUFF_23_START_3
- * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x0f)  // 0x16af*/
-/*----------- bit define -----------*/
-#define SEC_BUFF_2_BASE_ADDR                    16
-
-/* bit 15:12 -- section buffer size for group 3*/
-/* bit 11:8 -- section buffer size for group 2*/
-/* bit 7:4 -- section buffer size for group 1*/
-/* bit 3:0 -- section buffer size for group 0
- * (bit used,  for example, 10 means 1K)*/
-/*#define SEC_BUFF_SIZE
- * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x10)  // 0x1610*/
-/*#define SEC_BUFF_SIZE_2
- * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x10)  // 0x1660*/
-/*#define SEC_BUFF_SIZE_3
- * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x10)  // 0x16b0*/
-/*----------- bit define -----------*/
-#define SEC_BUFF_3_SIZE                        12
-#define SEC_BUFF_2_SIZE                         8
-#define SEC_BUFF_1_SIZE                         4
-
-/* section buffer busy status for buff 31:0 ( Read Only )*/
-/*#define SEC_BUFF_BUSY
- * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x11)  // 0x1611*/
-/*#define SEC_BUFF_BUSY_2
- * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x11)  // 0x1661*/
-/*#define SEC_BUFF_BUSY_3
- * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x11)  // 0x16b1*/
-
-/* section buffer write status for buff 31:0 -- Read*/
-/* clear buffer status ( buff READY and BUSY ) -- write*/
-/*#define SEC_BUFF_READY
- * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x12)  // 0x1612*/
-/*#define SEC_BUFF_READY_2
- * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x12)  // 0x1662*/
-/*#define SEC_BUFF_READY_3
- * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x12)  // 0x16b2*/
-
-/* bit 15 -- section_reset_busy (Read Only)*/
-/* bit 14 -- output_section_buffer_valid*/
-/* bit 12:8 -- SEC_BUFFER_NUMBER for the INDEX buffer  Read_Only*/
-/* bit 4:0 -- SEC_BUFFER_INDEX   RW*/
-/*#define SEC_BUFF_NUMBER
- * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x13)  // 0x1613*/
-/*#define SEC_BUFF_NUMBER_2
- * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x13)  // 0x1663*/
-/*#define SEC_BUFF_NUMBER_3
- * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x13)  // 0x16b3*/
-/*----------- bit define -----------*/
-#define SECTION_RESET_BUSY                      15
-#define OUTPUT_SECTION_BUFFER_VALID             14
-#define INDEXED_SEC_BUFF_NUMBER                 8
-
-/* bit 9:5 -- BYPASS PID number*/
-/* bit 4:0 -- PCR PID number*/
-/*#define ASSIGN_PID_NUMBER
- * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x14)  // 0x1614*/
-/*#define ASSIGN_PID_NUMBER_2
- * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x14)  // 0x1664*/
-/*#define ASSIGN_PID_NUMBER_3
- * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x14)  // 0x16b4*/
-/*----------- bit define -----------*/
-#define BYPASS_PID_NUMBER                       5
-
-/* bit 15:0 -- stream_id filter bit enable*/
-/* bit 7:0 -- stream_id filter target*/
-/*#define VIDEO_STREAM_ID
- * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x15)  // 0x1615*/
-/*#define VIDEO_STREAM_ID_2
- * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x15)  // 0x1665*/
-/*#define VIDEO_STREAM_ID_3
- * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x15)  // 0x16b5*/
-
-/*#define AUDIO_STREAM_ID
- * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x16)  // 0x1616*/
-/*#define AUDIO_STREAM_ID_2
- * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x16)  // 0x1666*/
-/*#define AUDIO_STREAM_ID_3
- * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x16)  // 0x16b6*/
-
-/*#define SUB_STREAM_ID
- * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x17)  // 0x1617*/
-/*#define SUB_STREAM_ID_2
- * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x17)  // 0x1667*/
-/*#define SUB_STREAM_ID_3
- * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x17)  // 0x16b7*/
-
-/*#define OTHER_STREAM_ID
- * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x18)  // 0x1618*/
-/*#define OTHER_STREAM_ID_2
- * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x18)  // 0x1668*/
-/*#define OTHER_STREAM_ID_3
- * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x18)  // 0x16b8*/
-
-/* bit 12 -- PCR_EN*/
-/* bit 11:0 -- PCR90K_DIV*/
-/*#define PCR90K_CTL
- * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x19)  // 0x1619*/
-/*#define PCR90K_CTL_2
- * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x19)  // 0x1669*/
-/*#define PCR90K_CTL_3
- * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x19)  // 0x16b9*/
-/*----------- bit define -----------*/
-#define PCR_EN                     12
-
-/* bit 15:0 -- PCR[31:0] R/W*/
-/*#define PCR_DEMUX
- * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x1a)  // 0x161a*/
-/*#define PCR_DEMUX_2
- * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x1a)  // 0x166a*/
-/*#define PCR_DEMUX_3
- * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x1a)  // 0x16ba*/
-
-/* bit 15:0 -- VPTS[31:0] R/W*/
-/*#define VIDEO_PTS_DEMUX
- * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x1b)  // 0x161b*/
-/*#define VIDEO_PTS_DEMUX_2
- * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x1b)  // 0x166b*/
-/*#define VIDEO_PTS_DEMUX_3
- * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x1b)  // 0x16bb*/
-
-/* bit 15:0 -- VDTS[31:0] R/W*/
-/*#define VIDEO_DTS_DEMUX
- * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x1c)  // 0x161c*/
-/*#define VIDEO_DTS_DEMUX_2
- * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x1c)  // 0x166c*/
-/*#define VIDEO_DTS_DEMUX_3
- * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x1c)  // 0x16bc*/
-
-/* bit 15:0 -- APTS[31:0] R/W*/
-/*#define AUDIO_PTS_DEMUX
- * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x1d)  // 0x161d*/
-/*#define AUDIO_PTS_DEMUX_2
- * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x1d)  // 0x166d*/
-/*#define AUDIO_PTS_DEMUX_3
- * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x1d)  // 0x16bd*/
-
-/* bit 15:0 -- SPTS[31:0] R/W*/
-/*#define SUB_PTS_DEMUX
- * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x1e)  // 0x161e*/
-/*#define SUB_PTS_DEMUX_2
- * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x1e)  // 0x166e*/
-/*#define SUB_PTS_DEMUX_3
- * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x1e)  // 0x16be*/
-
-/* read -- status, write 1 clear status*/
-/* bit 15 -- SUB_PTS[32]*/
-/* bit 14 -- AUDIO_PTS[32]*/
-/* bit 13 -- VIDEO_DTS[32]*/
-/* bit 12 -- VIDEO_PTS[32]*/
-/* bit 3 -- sub_pts_ready*/
-/* bit 2 -- audio_pts_ready*/
-/* bit 1 -- video_dts_ready*/
-/* bit 0 -- video_pts_ready*/
-/*#define STB_PTS_DTS_STATUS
- * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x1f)  // 0x161f*/
-/*#define STB_PTS_DTS_STATUS_2
- * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x1f)  // 0x166f*/
-/*#define STB_PTS_DTS_STATUS_3
- * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x1f)  // 0x16bf*/
-/*----------- bit define -----------*/
-#define SUB_PTS_BIT32              15
-#define AUDIO_PTS_BIT32            14
-#define VIDEO_DTS_BIT32            13
-#define VIDEO_PTS_BIT32            12
-#define SUB_PTS_READY              3
-#define AUDIO_PTS_READY            2
-#define VIDEO_DTS_READY            1
-#define VIDEO_PTS_READY            0
-
-/* bit 3:0 --*/
-/*  0 -- adaptation_field_length[7:0], adaption_field_byte_1[7:0]*/
-/*  1 -- stream_id[7:0], pes_header_bytes_left[7:0]*/
-/*  2 -- pes_package_bytes_left[15:0]*/
-/*  3 -- pes_ctr_byte[7:0], pes_flag_byte[7:0]*/
-/*#define STB_DEBUG_INDEX
- * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x20)  // 0x1620*/
-/*#define STB_DEBUG_INDEX_2
- * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x20)  // 0x1670*/
-/*#define STB_DEBUG_INDEX_3
- * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x20)  // 0x16c0*/
-
-/* read only*/
-/*#define STB_DEBUG_DATA_OUT
- * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x21)  // 0x1621*/
-/*#define STB_DEBUG_DATA_OUT_2
- * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x21)  // 0x1671*/
-/*#define STB_DEBUG_DATA_OUT_3
- * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x21)  // 0x16c1*/
-
-/* bit[31] -- no_match_record_en*/
-/* bit[30:16] - reserved*/
-/* default : 0x807f*/
-/* bit 15:9  -- MAX OM DMA COUNT  (default: 0x40)*/
-/* bit 8:0   -- LAST ADDR OF OM ADDR (default: 127)*/
-#define STB_OM_CTL \
-	(STB_CBUS_BASE + DEMUX_1_OFFSET + 0x22) /* 0x1622*/
-#define STB_OM_CTL_2 \
-	(STB_CBUS_BASE + DEMUX_2_OFFSET + 0x22) /* 0x1672*/
-#define STB_OM_CTL_3 \
-	(STB_CBUS_BASE + DEMUX_3_OFFSET + 0x22) /* 0x16c2*/
-/*----------- bit define -----------*/
-#define MAX_OM_DMA_COUNT           9
-#define LAST_OM_ADDR               0
-
-/* 15:0  WRITE 1 CLEAR to clear interrupt source*/
-/*12 -- INPUT_TIME_OUT*/
-/*11 -- PCR_ready*/
-/*10 -- audio_splicing_point*/
-/* 9 -- video_splicing_point*/
-/* 8 -- other_PES_int*/
-/* 7 -- sub_PES_int*/
-/* 6 -- discontinuity*/
-/* 5 -- duplicated_pack_found*/
-/* 4 -- New PDTS ready*/
-/* 3 -- om_cmd_buffer ready for access*/
-/* 2 -- section buffer ready*/
-/* 1 -- transport_error_indicator*/
-/* 0 -- TS ERROR PIN*/
-/*#define STB_INT_STATUS
- * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x23)  // 0x1623*/
-/*#define STB_INT_STATUS_2
- * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x23)  // 0x1673*/
-/*#define STB_INT_STATUS_3
- * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x23)  // 0x16c3*/
-/*----------- bit define -----------*/
-#define INPUT_TIME_OUT             12
-#define PCR_READY                  11
-#define AUDIO_SPLICING_POINT       10
-#define VIDEO_SPLICING_POINT       9
-#define OTHER_PES_READY            8
-#define SUB_PES_READY              7
-#define DIS_CONTINUITY_PACKET      6
-#define DUPLICATED_PACKET          5
-#define NEW_PDTS_READY             4
-#define OM_CMD_READ_PENDING        3
-#define SECTION_BUFFER_READY       2
-#define TS_ERROR_PACKAGE           1
-#define TS_ERROR_PIN               0
-
-/* When Bit 31 - 1 write will indicate all type use sepertate endian
- * (Write Only)*/
-/* When Bit 31 - 0 write will indicate all type else use Bit 8:6*/
-/* Bit 23:21 - demux om write endian control for OTHER_PES_PACKET*/
-/* Bit 20:18 - demux om write endian control for SCR_ONLY_PACKET*/
-/* Bit 17:15 - demux om write endian control for SUB_PACKET*/
-/* Bit 14:12 - demux om write endian control for AUDIO_PACKET*/
-/* Bit 11:9  - demux om write endian control for VIDEO_PACKET*/
-/* Bit 8:6 - demux om write endian control for else*/
-/* Bit 5:3 - demux om write endian control for bypass*/
-/* Bit 2:0 - demux om write endian control for section*/
-/*#define DEMUX_ENDIAN
- * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x24)  // 0x1624*/
-/*#define DEMUX_ENDIAN_2
- * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x24)  // 0x1674*/
-/*#define DEMUX_ENDIAN_3
- * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x24)  // 0x16c4*/
-/*----------- bit define -----------*/
-#define SEPERATE_ENDIAN            31
-#define OTHER_PES_ENDIAN           21
-#define SCR_ENDIAN                 18
-#define SUB_ENDIAN                 15
-#define AUDIO_ENDIAN               12
-#define VIDEO_ENDIAN               9
-#define OTHER_ENDIAN               6
-#define BYPASS_ENDIAN              3
-#define SECTION_ENDIAN             0
-
-/* Bit 15:8 -- last_burst_threshold*/
-/* Bit 7 -- use hi_bsf interface*/
-/* Bit 6:2 - fec_clk_div*/
-/* Bit 1 ts_source_sel */
-/* Bit 0 - Hiu TS generate enable */
-/*#define TS_HIU_CTL
- * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x25)  // 0x1625*/
-/*#define TS_HIU_CTL_2
- * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x25)  // 0x1675*/
-/*#define TS_HIU_CTL_3
- * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x25)  // 0x16c5*/
-/*----------- bit define -----------*/
-#define LAST_BURST_THRESHOLD       8
-#define USE_HI_BSF_INTERFACE       7
-
-/* bit 15:0 -- base address for section buffer start
- * (*0x10000 to get real base)*/
-/*#define SEC_BUFF_BASE
- * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x26)  // 0x1626*/
-/*#define SEC_BUFF_BASE_2
- * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x26)  // 0x1676*/
-/*#define SEC_BUFF_BASE_3
- * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x26)  // 0x16c6*/
-
-/* bit 11 -- mask bit for OTHER_PES_AHB_DMA_EN*/
-/* bit 10 -- mask bit for SUB_AHB_DMA_EN*/
-/* bit 9 -- mask bit for BYPASS_AHB_DMA_EN*/
-/* bit 8 -- mask bit for SECTION_AHB_DMA_EN*/
-/* bit 7 -- mask bit for recoder stream*/
-/* bit 6:0 -- mask bit for each type*/
-/*#define DEMUX_MEM_REQ_EN
- * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x27)  // 0x1627*/
-/*#define DEMUX_MEM_REQ_EN_2
- * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x27)  // 0x1677*/
-/*#define DEMUX_MEM_REQ_EN_3
- * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x27)  // 0x16c7*/
-/*----------- bit define -----------*/
-#define VIDEO2_DMA_EN_BIT          12
-#define OTHER_PES_AHB_DMA_EN       11
-#define SUB_AHB_DMA_EN             10
-#define BYPASS_AHB_DMA_EN          9
-#define SECTION_AHB_DMA_EN         8
-#define RECORDER_STREAM            7
-#define OTHER_PES_PACKET           6
-#define SCR_ONLY_PACKET            5  /*will never be used*/
-#define BYPASS_PACKET              4
-#define SECTION_PACKET             3
-#define SUB_PACKET                 2
-#define AUDIO_PACKET               1
-#define VIDEO_PACKET               0
-
-/* bit 31:0 -- vb_wr_ptr for video PDTS*/
-/*#define VIDEO_PDTS_WR_PTR
- * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x28)  // 0x1628*/
-/*#define VIDEO_PDTS_WR_PTR_2
- * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x28)  // 0x1678*/
-/*#define VIDEO_PDTS_WR_PTR_3
- * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x28)  // 0x16c8*/
-
-/* bit 31:0 -- ab_wr_ptr for audio PDTS*/
-/*#define AUDIO_PDTS_WR_PTR
- * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x29)  // 0x1629*/
-/*#define AUDIO_PDTS_WR_PTR_2
- * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x29)  // 0x1679*/
-/*#define AUDIO_PDTS_WR_PTR_3
- * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x29)  // 0x16c9*/
-
-/* bit 20:0 -- SB_WRITE_PTR (sb_wr_ptr << 3 == byte write position)*/
-/*#define SUB_WR_PTR
- * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x2a)  // 0x162a*/
-/*#define SUB_WR_PTR_2
- * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x2a)  // 0x167a*/
-/*#define SUB_WR_PTR_3
- * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x2a)  // 0x16ca*/
-
-/* bit 19:0 -- SB_START (sb_start << 12 == byte address);*/
-/*#define SB_START
- * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x2b)  // 0x162b*/
-/*#define SB_START_2
- * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x2b)  // 0x167b*/
-/*#define SB_START_3
- * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x2b)  // 0x16cb*/
-
-/* bit 20:0 -- SB_SIZE (sb_size << 3 == byte size, 16M maximun)*/
-/*#define SB_LAST_ADDR
- * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x2c)  // 0x162c*/
-/*#define SB_LAST_ADDR_2
- * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x2c)  // 0x167c*/
-/*#define SB_LAST_ADDR_3
- * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x2c)  // 0x16cc*/
-
-/* bit 31:0 -- sb_wr_ptr for sub PES*/
-/*#define SB_PES_WRITE_PTR
- * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x2d)  // 0x162d*/
-/*#define SB_PES_WRITE_PTR_2
- * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x2d)  // 0x167d*/
-/*#define SB_PES_WRITE_PTR_3
- * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x2d)  // 0x16cd*/
-
-/* bit 31:16 -- ob_wr_ptr for other PES*/
-/* bit 20:0 -- OB_WRITE_PTR (ob_wr_ptr << 3 == byte write position)*/
-/*#define OTHER_WR_PTR
- * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x2e)  // 0x162e*/
-/*#define OTHER_WR_PTR_2
- * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x2e)  // 0x167e*/
-/*#define OTHER_WR_PTR_3
- * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x2e)  // 0x16ce*/
-
-/* bit 19:0 -- OB_START (ob_start << 12 == byte address);*/
-/*#define OB_START
- * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x2f)  // 0x162f*/
-/*#define OB_START_2
- * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x2f)  // 0x167f*/
-/*#define OB_START_3
- * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x2f)  // 0x16cf*/
-
-/* bit 20:0 -- OB_SIZE (ob_size << 3 == byte size, 16M maximun)*/
-/*#define OB_LAST_ADDR
- * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x30)  // 0x1630*/
-/*#define OB_LAST_ADDR_2
- * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x30)  // 0x1680*/
-/*#define OB_LAST_ADDR_3
- * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x30)  // 0x16d0*/
-
-/* bit 31:0 -- ob_wr_ptr for sub PES*/
-/*#define OB_PES_WRITE_PTR
- * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x31)  // 0x1631*/
-/*#define OB_PES_WRITE_PTR_2
- * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x31)  // 0x1681*/
-/*#define OB_PES_WRITE_PTR_3
- * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x31)  // 0x16d1*/
-
-/* 15:0  DEMUX interrupt MASK*/
-/* 11 -- PCR_READY*/
-/* 10 -- audio_splicing_point*/
-/* 9 -- video_splicing_point*/
-/* 8 -- other_PES_int*/
-/* 7 -- sub_PES_int*/
-/* 6 -- discontinuity*/
-/* 5 -- duplicated_pack_found*/
-/* 4 -- New PDTS ready*/
-/* 3 -- om_cmd_buffer ready for access*/
-/* 2 -- section buffer ready*/
-/* 1 -- transport_error_indicator*/
-/* 0 -- TS ERROR PIN*/
-/*#define STB_INT_MASK
- * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x32)  // 0x1632*/
-/*#define STB_INT_MASK_2
- * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x32)  // 0x1682*/
-/*#define STB_INT_MASK_3
- * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x32)  // 0x16d2*/
-
-/* 31:16 VIDEO PID filter data*/
-/*15 -- splicing VIDEO PID change enable*/
-/*14:10 -- VIDEO PID FILTER ADDRESS*/
-/* 9 -- PES splicing active (Read Only)*/
-/* 8 -- splicing active (Read Only)*/
-/* 7:0  splicing countdown (Read Only)*/
-/*#define VIDEO_SPLICING_CTL
- * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x33)  // 0x1633*/
-/*#define VIDEO_SPLICING_CTL_2
- * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x33)  // 0x1683*/
-/*#define VIDEO_SPLICING_CTL_3
- * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x33)  // 0x16d3*/
-/*----------- bit define -----------*/
-#define VIDEO_PID_FILTER_DATA      16
-#define VIDEO_SPLICING_PID_CHANGE_ENABLE       15
-#define VIDEO_PID_FILTER_ADDRESS   10
-#define VIDEO_PES_SPLICING_ACTIVE  9
-#define VIDEO_SPLICING_ACTIVE      8
-
-
-/* 31:16 AUDIO PID filter data*/
-/*15 -- splicing AUDIO PID change enable*/
-/*14:10 -- AUDIO PID FILTER ADDRESS*/
-/* 9 -- PES splicing active (Read Only)*/
-/* 8 -- splicing active (Read Only)*/
-/* 7:0  splicing countdown (Read Only)*/
-/*#define AUDIO_SPLICING_CTL
- * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x34)  // 0x1634*/
-/*#define AUDIO_SPLICING_CTL_2
- * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x34)  // 0x1684*/
-/*#define AUDIO_SPLICING_CTL_3
- * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x34)  // 0x16d4*/
-/*----------- bit define -----------*/
-#define AUDIO_PID_FILTER_DATA      16
-#define AUDIO_SPLICING_PID_CHANGE_ENABLE       15
-#define AUDIO_PID_FILTER_ADDRESS   10
-#define AUDIO_PES_SPLICING_ACTIVE  9
-#define AUDIO_SPLICING_ACTIVE      8
-
-/* 23:16 M2TS_SKIP_BYTES*/
-/* 15:8 LAST TS PACKAGE BYTE COUNT (Read Only)*/
-/* 7:0  PACKAGE BYTE COUNT (Read Only)*/
-/*#define TS_PACKAGE_BYTE_COUNT
- * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x35)  // 0x1635*/
-/*#define TS_PACKAGE_BYTE_COUNT_2
- * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x35)  // 0x1685*/
-/*#define TS_PACKAGE_BYTE_COUNT_3
- * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x35)  // 0x16d5*/
-/*----------- bit define -----------*/
-#define M2TS_SKIP_BYTES            16
-#define LAST_TS_PACKAGE_BYTE_COUNT 8
-
-/* 15:0 2 bytes strong sync add to PES*/
-/*#define PES_STRONG_SYNC
- * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x36)  // 0x1636*/
-/*#define PES_STRONG_SYNC_2
- * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x36)  // 0x1686*/
-/*#define PES_STRONG_SYNC_3
- * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x36)  // 0x16d6*/
-
-/* bit 15 -- stb_om_ren*/
-/* bit 14:11 -- reserved*/
-/* bit  10:0 -- OM_DATA_RD_ADDR*/
-/*#define OM_DATA_RD_ADDR
- * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x37)  // 0x1637*/
-/*#define OM_DATA_RD_ADDR_2
- * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x37)  // 0x1687*/
-/*#define OM_DATA_RD_ADDR_3
- * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x37)  // 0x16d7*/
-/*----------- bit define -----------*/
-#define STB_OM_REN                 15
-
-/* bit 15:0 -- OM_DATA_RD*/
-/*#define OM_DATA_RD
- * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x38)  // 0x1638*/
-/*#define OM_DATA_RD_2
- * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x38)  // 0x1688*/
-/*#define OM_DATA_RD_3
- * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x38)  // 0x16d8*/
-
-/* AUTO STOP SETTING for 32 channels*/
-/* 4-bits per channel*/
-/* when write*/
-/* bit 3 -- set section active*/
-/* bit 2:0 -- auto stop after count (0 means never stop)*/
-/* when read*/
-/* bit 3 -- current active status (1 - active, 0 - stopped )*/
-/* bit 2:0 -- count down to auto stop*/
-/* section 31:24*/
-/*#define SECTION_AUTO_STOP_3
- * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x39)  // 0x1639*/
-/*#define SECTION_AUTO_STOP_3_2
- * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x39)  // 0x1689*/
-/*#define SECTION_AUTO_STOP_3_3
- * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x39)  // 0x16d9*/
-/* section 23:16*/
-/*#define SECTION_AUTO_STOP_2
- * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x3a)  // 0x163a*/
-/*#define SECTION_AUTO_STOP_2_2
- * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x3a)  // 0x168a*/
-/*#define SECTION_AUTO_STOP_2_3
- * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x3a)  // 0x16da*/
-/* section 15:8*/
-/*#define SECTION_AUTO_STOP_1
- * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x3b)  // 0x163b*/
-/*#define SECTION_AUTO_STOP_1_2
- * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x3b)  // 0x168b*/
-/*#define SECTION_AUTO_STOP_1_3
- * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x3b)  // 0x16db*/
-/* section 7:0*/
-/*#define SECTION_AUTO_STOP_0
- * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x3c)  // 0x163c*/
-/*#define SECTION_AUTO_STOP_0_2
- * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x3c)  // 0x168c*/
-/*#define SECTION_AUTO_STOP_0_3
- * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x3c)  // 0x16dc*/
-
-/* bit 31:0 reset channel status - each bit reset each channel*/
-/* read -- 32 channel status*/
-/*#define DEMUX_CHANNEL_RESET
- * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x3d)  // 0x163d*/
-/*#define DEMUX_CHANNEL_RESET_2
- * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x3d)  // 0x168d*/
-/*#define DEMUX_CHANNEL_RESET_3
- * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x3d)  // 0x16dd*/
-
-/*#define DEMUX_SCRAMBLING_STATE
- * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x3e)  // 0x163e*/
-/*#define DEMUX_SCRAMBLING_STATE_2
- * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x3e)  // 0x168e*/
-/*#define DEMUX_SCRAMBLING_STATE_3
- * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x3e)  // 0x16de*/
-
-/*#define DEMUX_CHANNEL_ACTIVITY
- * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x3f)  // 0x163f*/
-/*#define DEMUX_CHANNEL_ACTIVITY_2
- * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x3f)  // 0x168f*/
-/*#define DEMUX_CHANNEL_ACTIVITY_3
- * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x3f)  // 0x16df*/
-
-/* bit 4 -- video_stamp_use_dts*/
-/* bit 3 -- audio_stamp_sync_1_en*/
-/* bit 2 -- audio_stamp_insert_en*/
-/* bit 1 -- video_stamp_sync_1_en*/
-/* bit 0 -- video_stamp_insert_en*/
-/*#define DEMUX_STAMP_CTL
- * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x40)  // 0x1640*/
-/*#define DEMUX_STAMP_CTL_2
- * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x40)  // 0x1690*/
-/*#define DEMUX_STAMP_CTL_3
- * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x40)  // 0x16e0*/
-
-/*#define DEMUX_VIDEO_STAMP_SYNC_0
- * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x41)  // 0x1641*/
-/*#define DEMUX_VIDEO_STAMP_SYNC_0_2
- * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x41)  // 0x1691*/
-/*#define DEMUX_VIDEO_STAMP_SYNC_0_3
- * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x41)  // 0x16e1*/
-
-/*#define DEMUX_VIDEO_STAMP_SYNC_1
- * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x42)  // 0x1642*/
-/*#define DEMUX_VIDEO_STAMP_SYNC_1_2
- * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x42)  // 0x1692*/
-/*#define DEMUX_VIDEO_STAMP_SYNC_1_3
- * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x42)  // 0x16e2*/
-
-/*#define DEMUX_AUDIO_STAMP_SYNC_0
- * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x43)  // 0x1643*/
-/*#define DEMUX_AUDIO_STAMP_SYNC_0_2
- * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x43)  // 0x1693*/
-/*#define DEMUX_AUDIO_STAMP_SYNC_0_3
- * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x43)  // 0x16e3*/
-
-/*#define DEMUX_AUDIO_STAMP_SYNC_1
- * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x44)  // 0x1644*/
-/*#define DEMUX_AUDIO_STAMP_SYNC_1_2
- * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x44)  // 0x1694*/
-/*#define DEMUX_AUDIO_STAMP_SYNC_1_3
- * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x44)  // 0x16e4*/
-
-/* Write : Bit[4:0] secter filter number for reset*/
-/* Read  : select according to output_section_buffer_valid :*/
-/*         per bit per section buffer valid status*/
-/*         or section_buffer_ignore*/
-/*#define DEMUX_SECTION_RESET
- * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x45)  // 0x1645*/
-/*#define DEMUX_SECTION_RESET_2
- * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x45)  // 0x1695*/
-/*#define DEMUX_SECTION_RESET_3
- * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x45)  // 0x16e5*/
-
-
-/* bit[31:0] - channel_reset_timeout_disable*/
-#define DEMUX_INPUT_TIMEOUT_C   \
-	(STB_CBUS_BASE + DEMUX_1_OFFSET + 0x46)         /* 0x1646*/
-#define DEMUX_INPUT_TIMEOUT_C_2 \
-	(STB_CBUS_BASE + DEMUX_2_OFFSET + 0x46)         /* 0x1696*/
-#define DEMUX_INPUT_TIMEOUT_C_3 \
-	(STB_CBUS_BASE + DEMUX_3_OFFSET + 0x46)         /* 0x16e6*/
-/* bit[31] - no_match_reset_timeout_disable*/
-/* bit[30:0] input_time_out_int_cnt (0 -- means disable) Wr-setting, Rd-count*/
-#define DEMUX_INPUT_TIMEOUT     \
-	(STB_CBUS_BASE + DEMUX_1_OFFSET + 0x47)         /* 0x1647*/
-#define DEMUX_INPUT_TIMEOUT_2   \
-	(STB_CBUS_BASE + DEMUX_2_OFFSET + 0x47)         /* 0x1697*/
-#define DEMUX_INPUT_TIMEOUT_3   \
-	(STB_CBUS_BASE + DEMUX_3_OFFSET + 0x47)         /* 0x16e7*/
-
-/* bit[31:0] - channel_packet_count_disable*/
-#define DEMUX_PACKET_COUNT_C    \
-	(STB_CBUS_BASE + DEMUX_1_OFFSET + 0x48)         /* 0x1648*/
-#define DEMUX_PACKET_COUNT_C_2  \
-	(STB_CBUS_BASE + DEMUX_2_OFFSET + 0x48)         /* 0x1698*/
-#define DEMUX_PACKET_COUNT_C_3  \
-	(STB_CBUS_BASE + DEMUX_3_OFFSET + 0x48)         /* 0x16e8*/
-/* bit[31] - no_match_packet_count_disable*/
-/* bit[30:0] input_packet_count*/
-#define DEMUX_PACKET_COUNT      \
-	(STB_CBUS_BASE + DEMUX_1_OFFSET + 0x49)         /* 0x1649*/
-#define DEMUX_PACKET_COUNT_2    \
-	(STB_CBUS_BASE + DEMUX_2_OFFSET + 0x49)         /* 0x1699*/
-#define DEMUX_PACKET_COUNT_3    \
-	(STB_CBUS_BASE + DEMUX_3_OFFSET + 0x49)         /* 0x16e9*/
-
-/* bit[31:0] channel_record_enable*/
-#define DEMUX_CHAN_RECORD_EN    \
-	(STB_CBUS_BASE + DEMUX_1_OFFSET + 0x4a)         /* 0x164a*/
-#define DEMUX_CHAN_RECORD_EN_2  \
-	(STB_CBUS_BASE + DEMUX_2_OFFSET + 0x4a)         /* 0x169a*/
-#define DEMUX_CHAN_RECORD_EN_3  \
-	(STB_CBUS_BASE + DEMUX_3_OFFSET + 0x4a)         /* 0x16ea*/
-
-/* bit[31:0] channel_process_enable*/
-#define DEMUX_CHAN_PROCESS_EN   \
-	(STB_CBUS_BASE + DEMUX_1_OFFSET + 0x4b)         /* 0x164b*/
-#define DEMUX_CHAN_PROCESS_EN_2 \
-	(STB_CBUS_BASE + DEMUX_2_OFFSET + 0x4b)         /* 0x169b*/
-#define DEMUX_CHAN_PROCESS_EN_3 \
-	(STB_CBUS_BASE + DEMUX_3_OFFSET + 0x4b)         /* 0x16eb*/
-
-/* bit[31:24] small_sec_size ((n+1) * 256 Bytes)*/
-/* bit[23:16] small_sec_rd_ptr */
-/* bit[15:8]  small_sec_wr_ptr */
-/* bit[7:2]   reserved*/
-/* bit[1] small_sec_wr_ptr_wr_enable*/
-/* bit[0] small_section_enable*/
-#define DEMUX_SMALL_SEC_CTL     \
-	(STB_CBUS_BASE + DEMUX_1_OFFSET + 0x4c)         /* 0x164c*/
-#define DEMUX_SMALL_SEC_CTL_2   \
-	(STB_CBUS_BASE + DEMUX_2_OFFSET + 0x4c)         /* 0x169c*/
-#define DEMUX_SMALL_SEC_CTL_3   \
-	(STB_CBUS_BASE + DEMUX_3_OFFSET + 0x4c)         /* 0x16ec*/
-/* bit[31:0] small_sec_start_addr*/
-#define DEMUX_SMALL_SEC_ADDR    \
-	(STB_CBUS_BASE + DEMUX_1_OFFSET + 0x4d)         /* 0x164d*/
-#define DEMUX_SMALL_SEC_ADDR_2  \
-	(STB_CBUS_BASE + DEMUX_2_OFFSET + 0x4d)         /* 0x169d*/
-#define DEMUX_SMALL_SEC_ADDR_3  \
-	(STB_CBUS_BASE + DEMUX_3_OFFSET + 0x4d)         /* 0x16ed*/
-
-
-/*======================================================*/
-/*  STB Registers End*/
-/*====================================================*/
-/* ----------------------------*/
-/* ASYNC FIFO (4)*/
-/* ----------------------------*/
-/*#define ASYNC_FIFO_REG0                            0x2310*/
-/*#define ASYNC_FIFO_REG1                            0x2311*/
-#define ASYNC_FIFO_FLUSH_STATUS     31
-#define ASYNC_FIFO_ERR              30
-#define ASYNC_FIFO_FIFO_EMPTY       29
-#define ASYNC_FIFO_TO_HIU           24
-#define ASYNC_FIFO_FLUSH            23
-#define ASYNC_FIFO_RESET            22
-#define ASYNC_FIFO_WRAP_EN          21
-#define ASYNC_FIFO_FLUSH_EN         20
-#define ASYNC_FIFO_RESIDUAL_MSB     19
-#define ASYNC_FIFO_RESIDUAL_LSB     15
-#define ASYNC_FIFO_FLUSH_CNT_MSB    14
-#define ASYNC_FIFO_FLUSH_CNT_LSB    0
-/*#define ASYNC_FIFO_REG2                            0x2312*/
-#define ASYNC_FIFO_FIFO_FULL        26
-#define ASYNC_FIFO_FILL_STATUS      25
-#define ASYNC_FIFO_SOURCE_MSB       24
-#define ASYNC_FIFO_SOURCE_LSB       23
-#define ASYNC_FIFO_ENDIAN_MSB       22
-#define ASYNC_FIFO_ENDIAN_LSB       21
-#define ASYNC_FIFO_FILL_EN          20
-#define ASYNC_FIFO_FILL_CNT_MSB     19
-#define ASYNC_FIFO_FILL_CNT_LSB     0
-/*#define ASYNC_FIFO_REG3                            0x2313*/
-#define ASYNC_FLUSH_SIZE_IRQ_MSB    15
-#define ASYNC_FLUSH_SIZE_IRQ_LSB    0
-/* ----------------------------*/
-/* ASYNC FIFO (4)*/
-/* ----------------------------*/
-/*#define ASYNC_FIFO2_REG0                           0x2314*/
-/*#define ASYNC_FIFO2_REG1                           0x2315*/
-/*#define ASYNC_FIFO2_REG2                           0x2316*/
-/*#define ASYNC_FIFO2_REG3                           0x2317*/
-
-#define RESET_DEMUXSTB      (1 << 1)
-#endif /* C_STB_DEFINE_H*/
diff --git a/drivers/amlogic/dvb_tv/c_stb_regs_define.h b/drivers/amlogic/dvb_tv/c_stb_regs_define.h
deleted file mode 100644
index 2612fa6efafd..000000000000
--- a/drivers/amlogic/dvb_tv/c_stb_regs_define.h
+++ /dev/null
@@ -1,8889 +0,0 @@
-/*
- * This file is automaticly generated by genregs.awk. Please do not edit it
- * Base files are ..
- *   ..
- *   ..
- * Tue Oct 22 15:28:48 CST 2013
- **/
-#ifndef __MACH_MESON8_REG_ADDR_H_
-#define __MACH_MESON8_REG_ADDR_H_
-#include <linux/amlogic/iomap.h>
-#define CBUS_REG_ADDR(_r) aml_read_cbus(_r)
-#define HHI_DEMOD_MEM_PD_REG         (0xc883c000 + (0x43 << 2))
-#define STB_TOP_CONFIG 0x16f0
-#define P_STB_TOP_CONFIG                CBUS_REG_ADDR(STB_TOP_CONFIG)
-#define TS_TOP_CONFIG 0x16f1
-#define P_TS_TOP_CONFIG                 CBUS_REG_ADDR(TS_TOP_CONFIG)
-#define TS_FILE_CONFIG 0x16f2
-#define P_TS_FILE_CONFIG        CBUS_REG_ADDR(TS_FILE_CONFIG)
-#define TS_PL_PID_INDEX 0x16f3
-#define P_TS_PL_PID_INDEX               CBUS_REG_ADDR(TS_PL_PID_INDEX)
-#define TS_PL_PID_DATA 0x16f4
-#define P_TS_PL_PID_DATA                CBUS_REG_ADDR(TS_PL_PID_DATA)
-#define COMM_DESC_KEY0 0x16f5
-#define P_COMM_DESC_KEY0                CBUS_REG_ADDR(COMM_DESC_KEY0)
-#define COMM_DESC_KEY1 0x16f6
-#define P_COMM_DESC_KEY1                CBUS_REG_ADDR(COMM_DESC_KEY1)
-#define COMM_DESC_KEY_RW 0x16f7
-#define P_COMM_DESC_KEY_RW              CBUS_REG_ADDR(COMM_DESC_KEY_RW)
-#define CIPLUS_KEY0 0x16f8
-#define P_CIPLUS_KEY0           CBUS_REG_ADDR(CIPLUS_KEY0)
-#define CIPLUS_KEY1 0x16f9
-#define P_CIPLUS_KEY1           CBUS_REG_ADDR(CIPLUS_KEY1)
-#define CIPLUS_KEY2 0x16fa
-#define P_CIPLUS_KEY2           CBUS_REG_ADDR(CIPLUS_KEY2)
-#define CIPLUS_KEY3 0x16fb
-#define P_CIPLUS_KEY3           CBUS_REG_ADDR(CIPLUS_KEY3)
-#define CIPLUS_KEY_WR 0x16fc
-#define P_CIPLUS_KEY_WR                 CBUS_REG_ADDR(CIPLUS_KEY_WR)
-#define CIPLUS_CONFIG 0x16fd
-#define P_CIPLUS_CONFIG                 CBUS_REG_ADDR(CIPLUS_CONFIG)
-#define CIPLUS_ENDIAN 0x16fe
-#define P_CIPLUS_ENDIAN                 CBUS_REG_ADDR(CIPLUS_ENDIAN)
-#define PREG_CTLREG0_ADDR 0x2000
-#define P_PREG_CTLREG0_ADDR             CBUS_REG_ADDR(PREG_CTLREG0_ADDR)
-#define PREG_PAD_GPIO6_EN_N 0x2008
-#define P_PREG_PAD_GPIO6_EN_N   CBUS_REG_ADDR(PREG_PAD_GPIO6_EN_N)
-#define PREG_PAD_GPIO6_O 0x2009
-#define P_PREG_PAD_GPIO6_O              CBUS_REG_ADDR(PREG_PAD_GPIO6_O)
-#define PREG_PAD_GPIO6_I 0x200a
-#define P_PREG_PAD_GPIO6_I              CBUS_REG_ADDR(PREG_PAD_GPIO6_I)
-#define PREG_JTAG_GPIO_ADDR 0x200b
-#define P_PREG_JTAG_GPIO_ADDR           CBUS_REG_ADDR(PREG_JTAG_GPIO_ADDR)
-#define PREG_PAD_GPIO0_EN_N 0x200c
-#define P_PREG_PAD_GPIO0_EN_N           CBUS_REG_ADDR(PREG_PAD_GPIO0_EN_N)
-#define PREG_PAD_GPIO0_O 0x200d
-#define P_PREG_PAD_GPIO0_O              CBUS_REG_ADDR(PREG_PAD_GPIO0_O)
-#define PREG_PAD_GPIO0_I 0x200e
-#define P_PREG_PAD_GPIO0_I              CBUS_REG_ADDR(PREG_PAD_GPIO0_I)
-#define PREG_PAD_GPIO1_EN_N 0x200f
-#define P_PREG_PAD_GPIO1_EN_N           CBUS_REG_ADDR(PREG_PAD_GPIO1_EN_N)
-#define PREG_PAD_GPIO1_O 0x2010
-#define P_PREG_PAD_GPIO1_O              CBUS_REG_ADDR(PREG_PAD_GPIO1_O)
-#define PREG_PAD_GPIO1_I 0x2011
-#define P_PREG_PAD_GPIO1_I              CBUS_REG_ADDR(PREG_PAD_GPIO1_I)
-#define PREG_PAD_GPIO2_EN_N 0x2012
-#define P_PREG_PAD_GPIO2_EN_N           CBUS_REG_ADDR(PREG_PAD_GPIO2_EN_N)
-#define PREG_PAD_GPIO2_O 0x2013
-#define P_PREG_PAD_GPIO2_O              CBUS_REG_ADDR(PREG_PAD_GPIO2_O)
-#define PREG_PAD_GPIO2_I 0x2014
-#define P_PREG_PAD_GPIO2_I              CBUS_REG_ADDR(PREG_PAD_GPIO2_I)
-#define PREG_PAD_GPIO3_EN_N 0x2015
-#define P_PREG_PAD_GPIO3_EN_N           CBUS_REG_ADDR(PREG_PAD_GPIO3_EN_N)
-#define PREG_PAD_GPIO3_O 0x2016
-#define P_PREG_PAD_GPIO3_O              CBUS_REG_ADDR(PREG_PAD_GPIO3_O)
-#define PREG_PAD_GPIO3_I 0x2017
-#define P_PREG_PAD_GPIO3_I              CBUS_REG_ADDR(PREG_PAD_GPIO3_I)
-#define PREG_PAD_GPIO4_EN_N 0x2018
-#define P_PREG_PAD_GPIO4_EN_N           CBUS_REG_ADDR(PREG_PAD_GPIO4_EN_N)
-#define PREG_PAD_GPIO4_O 0x2019
-#define P_PREG_PAD_GPIO4_O              CBUS_REG_ADDR(PREG_PAD_GPIO4_O)
-#define PREG_PAD_GPIO4_I 0x201a
-#define P_PREG_PAD_GPIO4_I              CBUS_REG_ADDR(PREG_PAD_GPIO4_I)
-#define PREG_PAD_GPIO5_EN_N 0x201b
-#define P_PREG_PAD_GPIO5_EN_N           CBUS_REG_ADDR(PREG_PAD_GPIO5_EN_N)
-#define PREG_PAD_GPIO5_O 0x201c
-#define P_PREG_PAD_GPIO5_O              CBUS_REG_ADDR(PREG_PAD_GPIO5_O)
-#define PREG_PAD_GPIO5_I 0x201d
-#define P_PREG_PAD_GPIO5_I              CBUS_REG_ADDR(PREG_PAD_GPIO5_I)
-#define A9_STATUS1 0x201f
-#define P_A9_STATUS1            CBUS_REG_ADDR(A9_STATUS1)
-#define A9_CFG0 0x2020
-#define P_A9_CFG0               CBUS_REG_ADDR(A9_CFG0)
-#define A9_CFG1 0x2021
-#define P_A9_CFG1               CBUS_REG_ADDR(A9_CFG1)
-#define A9_CFG2 0x2022
-#define P_A9_CFG2               CBUS_REG_ADDR(A9_CFG2)
-#define A9_PERIPH_BASE 0x2023
-#define P_A9_PERIPH_BASE                CBUS_REG_ADDR(A9_PERIPH_BASE)
-#define A9_L2_REG_BASE 0x2024
-#define P_A9_L2_REG_BASE                CBUS_REG_ADDR(A9_L2_REG_BASE)
-#define A9_L2_STATUS 0x2025
-#define P_A9_L2_STATUS          CBUS_REG_ADDR(A9_L2_STATUS)
-#define A9_POR_CFG 0x2026
-#define P_A9_POR_CFG            CBUS_REG_ADDR(A9_POR_CFG)
-#define A9_STATUS2 0x2027
-#define P_A9_STATUS2            CBUS_REG_ADDR(A9_STATUS2)
-#define AXI_REG_EN 0x2028
-#define P_AXI_REG_EN            CBUS_REG_ADDR(AXI_REG_EN)
-#define A9_CFG3 0x2029
-#define P_A9_CFG3               CBUS_REG_ADDR(A9_CFG3)
-#define A9_CFG4 0x202a
-#define P_A9_CFG4               CBUS_REG_ADDR(A9_CFG4)
-#define A9_STATUS3 0x202b
-#define P_A9_STATUS3            CBUS_REG_ADDR(A9_STATUS3)
-#define PERIPHS_PIN_MUX_0 0x202c
-#define P_PERIPHS_PIN_MUX_0             CBUS_REG_ADDR(PERIPHS_PIN_MUX_0)
-#define PERIPHS_PIN_MUX_1 0x202d
-#define P_PERIPHS_PIN_MUX_1             CBUS_REG_ADDR(PERIPHS_PIN_MUX_1)
-#define PERIPHS_PIN_MUX_2 0x202e
-#define P_PERIPHS_PIN_MUX_2             CBUS_REG_ADDR(PERIPHS_PIN_MUX_2)
-#define PERIPHS_PIN_MUX_3 0x202f
-#define P_PERIPHS_PIN_MUX_3             CBUS_REG_ADDR(PERIPHS_PIN_MUX_3)
-#define PERIPHS_PIN_MUX_4 0x2030
-#define P_PERIPHS_PIN_MUX_4             CBUS_REG_ADDR(PERIPHS_PIN_MUX_4)
-#define PERIPHS_PIN_MUX_5 0x2031
-#define P_PERIPHS_PIN_MUX_5             CBUS_REG_ADDR(PERIPHS_PIN_MUX_5)
-#define PERIPHS_PIN_MUX_6 0x2032
-#define P_PERIPHS_PIN_MUX_6             CBUS_REG_ADDR(PERIPHS_PIN_MUX_6)
-#define PERIPHS_PIN_MUX_7 0x2033
-#define P_PERIPHS_PIN_MUX_7             CBUS_REG_ADDR(PERIPHS_PIN_MUX_7)
-#define PERIPHS_PIN_MUX_8 0x2034
-#define P_PERIPHS_PIN_MUX_8             CBUS_REG_ADDR(PERIPHS_PIN_MUX_8)
-#define PERIPHS_PIN_MUX_9 0x2035
-#define P_PERIPHS_PIN_MUX_9             CBUS_REG_ADDR(PERIPHS_PIN_MUX_9)
-#define PERIPHS_PIN_MUX_10 0x2036
-#define P_PERIPHS_PIN_MUX_10            CBUS_REG_ADDR(PERIPHS_PIN_MUX_10)
-#define PERIPHS_PIN_MUX_11 0x2037
-#define P_PERIPHS_PIN_MUX_11            CBUS_REG_ADDR(PERIPHS_PIN_MUX_11)
-#define PERIPHS_PIN_MUX_12 0x2038
-#define P_PERIPHS_PIN_MUX_12            CBUS_REG_ADDR(PERIPHS_PIN_MUX_12)
-#define PAD_PULL_UP_REG6 0x2039
-#define P_PAD_PULL_UP_REG6              CBUS_REG_ADDR(PAD_PULL_UP_REG6)
-#define PAD_PULL_UP_REG0 0x203a
-#define P_PAD_PULL_UP_REG0              CBUS_REG_ADDR(PAD_PULL_UP_REG0)
-#define PAD_PULL_UP_REG1 0x203b
-#define P_PAD_PULL_UP_REG1              CBUS_REG_ADDR(PAD_PULL_UP_REG1)
-#define PAD_PULL_UP_REG2 0x203c
-#define P_PAD_PULL_UP_REG2              CBUS_REG_ADDR(PAD_PULL_UP_REG2)
-#define PAD_PULL_UP_REG3 0x203d
-#define P_PAD_PULL_UP_REG3              CBUS_REG_ADDR(PAD_PULL_UP_REG3)
-#define PAD_PULL_UP_REG4 0x203e
-#define P_PAD_PULL_UP_REG4              CBUS_REG_ADDR(PAD_PULL_UP_REG4)
-#define PAD_PULL_UP_REG5 0x203f
-#define P_PAD_PULL_UP_REG5              CBUS_REG_ADDR(PAD_PULL_UP_REG5)
-#define RAND64_ADDR0 0x2040
-#define P_RAND64_ADDR0          CBUS_REG_ADDR(RAND64_ADDR0)
-#define RAND64_ADDR1 0x2041
-#define P_RAND64_ADDR1          CBUS_REG_ADDR(RAND64_ADDR1)
-#define PREG_ETHERNET_ADDR0 0x2042
-#define P_PREG_ETHERNET_ADDR0           CBUS_REG_ADDR(PREG_ETHERNET_ADDR0)
-#define PREG_AM_ANALOG_ADDR 0x2043
-#define P_PREG_AM_ANALOG_ADDR           CBUS_REG_ADDR(PREG_AM_ANALOG_ADDR)
-#define PREG_MALI_BYTE_CNTL 0x2044
-#define P_PREG_MALI_BYTE_CNTL           CBUS_REG_ADDR(PREG_MALI_BYTE_CNTL)
-#define PREG_WIFI_CNTL 0x2045
-#define P_PREG_WIFI_CNTL                CBUS_REG_ADDR(PREG_WIFI_CNTL)
-#define PAD_PULL_UP_EN_REG0 0x2048
-#define P_PAD_PULL_UP_EN_REG0           CBUS_REG_ADDR(PAD_PULL_UP_EN_REG0)
-#define PAD_PULL_UP_EN_REG1 0x2049
-#define P_PAD_PULL_UP_EN_REG1           CBUS_REG_ADDR(PAD_PULL_UP_EN_REG1)
-#define PAD_PULL_UP_EN_REG2 0x204a
-#define P_PAD_PULL_UP_EN_REG2           CBUS_REG_ADDR(PAD_PULL_UP_EN_REG2)
-#define PAD_PULL_UP_EN_REG3 0x204b
-#define P_PAD_PULL_UP_EN_REG3           CBUS_REG_ADDR(PAD_PULL_UP_EN_REG3)
-#define PAD_PULL_UP_EN_REG4 0x204c
-#define P_PAD_PULL_UP_EN_REG4           CBUS_REG_ADDR(PAD_PULL_UP_EN_REG4)
-#define PAD_PULL_UP_EN_REG5 0x204d
-#define P_PAD_PULL_UP_EN_REG5           CBUS_REG_ADDR(PAD_PULL_UP_EN_REG5)
-#define PAD_PULL_UP_EN_REG6 0x204e
-#define P_PAD_PULL_UP_EN_REG6           CBUS_REG_ADDR(PAD_PULL_UP_EN_REG6)
-/* add from M8M2*/
-#define PREG_ETH_REG0 0x2050
-#define P_PREG_ETH_REG0                 CBUS_REG_ADDR(PREG_ETH_REG0)
-#define PREG_ETH_REG1 0x2051
-#define P_PREG_ETH_REG1                 CBUS_REG_ADDR(PREG_ETH_REG1)
-/***************/
-#define PROD_TEST_REG0 0x2068
-#define P_PROD_TEST_REG0                CBUS_REG_ADDR(PROD_TEST_REG0)
-#define PROD_TEST_REG1 0x2067
-#define P_PROD_TEST_REG1                CBUS_REG_ADDR(PROD_TEST_REG1)
-#define METAL_REVISION 0x206a
-#define P_METAL_REVISION                CBUS_REG_ADDR(METAL_REVISION)
-#define ADC_TOP_MISC 0x206b
-#define P_ADC_TOP_MISC          CBUS_REG_ADDR(ADC_TOP_MISC)
-#define DPLL_TOP_MISC 0x206c
-#define P_DPLL_TOP_MISC                 CBUS_REG_ADDR(DPLL_TOP_MISC)
-#define ANALOG_TOP_MISC 0x206d
-#define P_ANALOG_TOP_MISC               CBUS_REG_ADDR(ANALOG_TOP_MISC)
-#define AM_ANALOG_TOP_REG0 0x206e
-#define P_AM_ANALOG_TOP_REG0            CBUS_REG_ADDR(AM_ANALOG_TOP_REG0)
-#define AM_ANALOG_TOP_REG1 0x206f
-#define P_AM_ANALOG_TOP_REG1            CBUS_REG_ADDR(AM_ANALOG_TOP_REG1)
-#define PREG_STICKY_REG0 0x207c
-#define P_PREG_STICKY_REG0              CBUS_REG_ADDR(PREG_STICKY_REG0)
-#define PREG_STICKY_REG1 0x207d
-#define P_PREG_STICKY_REG1              CBUS_REG_ADDR(PREG_STICKY_REG1)
-#define PREG_WRITE_ONCE_REG 0x207e
-#define P_PREG_WRITE_ONCE_REG           CBUS_REG_ADDR(PREG_WRITE_ONCE_REG)
-#define AM_RING_OSC_REG0 0x207f
-#define P_AM_RING_OSC_REG0              CBUS_REG_ADDR(AM_RING_OSC_REG0)
-#define SMARTCARD_REG0 0x2110
-#define P_SMARTCARD_REG0                CBUS_REG_ADDR(SMARTCARD_REG0)
-#define SMARTCARD_REG1 0x2111
-#define P_SMARTCARD_REG1                CBUS_REG_ADDR(SMARTCARD_REG1)
-#define SMARTCARD_REG2 0x2112
-#define P_SMARTCARD_REG2                CBUS_REG_ADDR(SMARTCARD_REG2)
-#define SMARTCARD_STATUS 0x2113
-#define P_SMARTCARD_STATUS              CBUS_REG_ADDR(SMARTCARD_STATUS)
-#define SMARTCARD_INTR 0x2114
-#define P_SMARTCARD_INTR                CBUS_REG_ADDR(SMARTCARD_INTR)
-#define SMARTCARD_REG5 0x2115
-#define P_SMARTCARD_REG5                CBUS_REG_ADDR(SMARTCARD_REG5)
-#define SMARTCARD_REG6 0x2116
-#define P_SMARTCARD_REG6                CBUS_REG_ADDR(SMARTCARD_REG6)
-#define SMARTCARD_FIFO 0x2117
-#define P_SMARTCARD_FIFO                CBUS_REG_ADDR(SMARTCARD_FIFO)
-#define SMARTCARD_REG8 0x2118
-#define P_SMARTCARD_REG8                CBUS_REG_ADDR(SMARTCARD_REG8)
-#define IR_DEC_LDR_ACTIVE 0x2120
-#define P_IR_DEC_LDR_ACTIVE             CBUS_REG_ADDR(IR_DEC_LDR_ACTIVE)
-#define IR_DEC_LDR_IDLE 0x2121
-#define P_IR_DEC_LDR_IDLE               CBUS_REG_ADDR(IR_DEC_LDR_IDLE)
-#define IR_DEC_LDR_REPEAT 0x2122
-#define P_IR_DEC_LDR_REPEAT             CBUS_REG_ADDR(IR_DEC_LDR_REPEAT)
-#define IR_DEC_BIT_0 0x2123
-#define P_IR_DEC_BIT_0          CBUS_REG_ADDR(IR_DEC_BIT_0)
-#define IR_DEC_REG0 0x2124
-#define P_IR_DEC_REG0           CBUS_REG_ADDR(IR_DEC_REG0)
-#define IR_DEC_FRAME 0x2125
-#define P_IR_DEC_FRAME          CBUS_REG_ADDR(IR_DEC_FRAME)
-#define IR_DEC_STATUS 0x2126
-#define P_IR_DEC_STATUS                 CBUS_REG_ADDR(IR_DEC_STATUS)
-#define IR_DEC_REG1 0x2127
-#define P_IR_DEC_REG1           CBUS_REG_ADDR(IR_DEC_REG1)
-#define DEMOD_ADC_SAMPLING 0x212d
-#define P_DEMOD_ADC_SAMPLING            CBUS_REG_ADDR(DEMOD_ADC_SAMPLING)
-#define UART0_WFIFO 0x2130
-#define P_UART0_WFIFO           CBUS_REG_ADDR(UART0_WFIFO)
-#define UART0_RFIFO 0x2131
-#define P_UART0_RFIFO           CBUS_REG_ADDR(UART0_RFIFO)
-#define UART0_CONTROL 0x2132
-#define P_UART0_CONTROL                 CBUS_REG_ADDR(UART0_CONTROL)
-#define UART0_STATUS 0x2133
-#define P_UART0_STATUS          CBUS_REG_ADDR(UART0_STATUS)
-#define UART0_MISC 0x2134
-#define P_UART0_MISC            CBUS_REG_ADDR(UART0_MISC)
-#define UART0_REG5 0x2135
-#define P_UART0_REG5            CBUS_REG_ADDR(UART0_REG5)
-#define UART1_WFIFO 0x2137
-#define P_UART1_WFIFO           CBUS_REG_ADDR(UART1_WFIFO)
-#define UART1_RFIFO 0x2138
-#define P_UART1_RFIFO           CBUS_REG_ADDR(UART1_RFIFO)
-#define UART1_CONTROL 0x2139
-#define P_UART1_CONTROL                 CBUS_REG_ADDR(UART1_CONTROL)
-#define UART1_STATUS 0x213a
-#define P_UART1_STATUS          CBUS_REG_ADDR(UART1_STATUS)
-#define UART1_MISC 0x213b
-#define P_UART1_MISC            CBUS_REG_ADDR(UART1_MISC)
-#define UART1_REG5 0x213c
-#define P_UART1_REG5            CBUS_REG_ADDR(UART1_REG5)
-#define I2C_M_0_CONTROL_REG 0x2140
-#define P_I2C_M_0_CONTROL_REG           CBUS_REG_ADDR(I2C_M_0_CONTROL_REG)
-#define I2C_M_0_SLAVE_ADDR 0x2141
-#define P_I2C_M_0_SLAVE_ADDR            CBUS_REG_ADDR(I2C_M_0_SLAVE_ADDR)
-#define I2C_M_0_TOKEN_LIST0 0x2142
-#define P_I2C_M_0_TOKEN_LIST0           CBUS_REG_ADDR(I2C_M_0_TOKEN_LIST0)
-#define I2C_M_0_TOKEN_LIST1 0x2143
-#define P_I2C_M_0_TOKEN_LIST1           CBUS_REG_ADDR(I2C_M_0_TOKEN_LIST1)
-#define I2C_M_0_WDATA_REG0 0x2144
-#define P_I2C_M_0_WDATA_REG0            CBUS_REG_ADDR(I2C_M_0_WDATA_REG0)
-#define I2C_M_0_WDATA_REG1 0x2145
-#define P_I2C_M_0_WDATA_REG1            CBUS_REG_ADDR(I2C_M_0_WDATA_REG1)
-#define I2C_M_0_RDATA_REG0 0x2146
-#define P_I2C_M_0_RDATA_REG0            CBUS_REG_ADDR(I2C_M_0_RDATA_REG0)
-#define I2C_M_0_RDATA_REG1 0x2147
-#define P_I2C_M_0_RDATA_REG1            CBUS_REG_ADDR(I2C_M_0_RDATA_REG1)
-#define I2C_S_CONTROL_REG 0x2150
-#define P_I2C_S_CONTROL_REG             CBUS_REG_ADDR(I2C_S_CONTROL_REG)
-#define I2C_S_SEND_REG 0x2151
-#define P_I2C_S_SEND_REG                CBUS_REG_ADDR(I2C_S_SEND_REG)
-#define I2C_S_RECV_REG 0x2152
-#define P_I2C_S_RECV_REG                CBUS_REG_ADDR(I2C_S_RECV_REG)
-#define I2C_S_CNTL1_REG 0x2153
-#define P_I2C_S_CNTL1_REG               CBUS_REG_ADDR(I2C_S_CNTL1_REG)
-#define PWM_PWM_A 0x2154
-#define P_PWM_PWM_A             CBUS_REG_ADDR(PWM_PWM_A)
-#define PWM_PWM_B 0x2155
-#define P_PWM_PWM_B             CBUS_REG_ADDR(PWM_PWM_B)
-#define PWM_MISC_REG_AB 0x2156
-#define P_PWM_MISC_REG_AB               CBUS_REG_ADDR(PWM_MISC_REG_AB)
-#define PWM_DELTA_SIGMA_AB 0x2157
-#define P_PWM_DELTA_SIGMA_AB            CBUS_REG_ADDR(PWM_DELTA_SIGMA_AB)
-#define ATAPI_IDEREG0 0x2160
-#define P_ATAPI_IDEREG0                 CBUS_REG_ADDR(ATAPI_IDEREG0)
-#define ATAPI_IDEREG1 0x2161
-#define P_ATAPI_IDEREG1                 CBUS_REG_ADDR(ATAPI_IDEREG1)
-#define ATAPI_IDEREG2 0x2162
-#define P_ATAPI_IDEREG2                 CBUS_REG_ADDR(ATAPI_IDEREG2)
-#define ATAPI_CYCTIME 0x2163
-#define P_ATAPI_CYCTIME                 CBUS_REG_ADDR(ATAPI_CYCTIME)
-#define ATAPI_IDETIME 0x2164
-#define P_ATAPI_IDETIME                 CBUS_REG_ADDR(ATAPI_IDETIME)
-#define ATAPI_PIO_TIMING 0x2165
-#define P_ATAPI_PIO_TIMING              CBUS_REG_ADDR(ATAPI_PIO_TIMING)
-#define ATAPI_TABLE_ADD_REG 0x2166
-#define P_ATAPI_TABLE_ADD_REG           CBUS_REG_ADDR(ATAPI_TABLE_ADD_REG)
-#define ATAPI_IDEREG3 0x2167
-#define P_ATAPI_IDEREG3                 CBUS_REG_ADDR(ATAPI_IDEREG3)
-#define ATAPI_UDMA_REG0 0x2168
-#define P_ATAPI_UDMA_REG0               CBUS_REG_ADDR(ATAPI_UDMA_REG0)
-#define ATAPI_UDMA_REG1 0x2169
-#define P_ATAPI_UDMA_REG1               CBUS_REG_ADDR(ATAPI_UDMA_REG1)
-#define TRANS_PWMA_REG0 0x2170
-#define P_TRANS_PWMA_REG0               CBUS_REG_ADDR(TRANS_PWMA_REG0)
-#define TRANS_PWMA_REG1 0x2171
-#define P_TRANS_PWMA_REG1               CBUS_REG_ADDR(TRANS_PWMA_REG1)
-#define TRANS_PWMA_MUX0 0x2172
-#define P_TRANS_PWMA_MUX0               CBUS_REG_ADDR(TRANS_PWMA_MUX0)
-#define TRANS_PWMA_MUX1 0x2173
-#define P_TRANS_PWMA_MUX1               CBUS_REG_ADDR(TRANS_PWMA_MUX1)
-#define TRANS_PWMA_MUX2 0x2174
-#define P_TRANS_PWMA_MUX2               CBUS_REG_ADDR(TRANS_PWMA_MUX2)
-#define TRANS_PWMA_MUX3 0x2175
-#define P_TRANS_PWMA_MUX3               CBUS_REG_ADDR(TRANS_PWMA_MUX3)
-#define TRANS_PWMA_MUX4 0x2176
-#define P_TRANS_PWMA_MUX4               CBUS_REG_ADDR(TRANS_PWMA_MUX4)
-#define TRANS_PWMA_MUX5 0x2177
-#define P_TRANS_PWMA_MUX5               CBUS_REG_ADDR(TRANS_PWMA_MUX5)
-#define TRANS_PWMB_REG0 0x2178
-#define P_TRANS_PWMB_REG0               CBUS_REG_ADDR(TRANS_PWMB_REG0)
-#define TRANS_PWMB_REG1 0x2179
-#define P_TRANS_PWMB_REG1               CBUS_REG_ADDR(TRANS_PWMB_REG1)
-#define TRANS_PWMB_MUX0 0x217a
-#define P_TRANS_PWMB_MUX0               CBUS_REG_ADDR(TRANS_PWMB_MUX0)
-#define TRANS_PWMB_MUX1 0x217b
-#define P_TRANS_PWMB_MUX1               CBUS_REG_ADDR(TRANS_PWMB_MUX1)
-#define TRANS_PWMB_MUX2 0x217c
-#define P_TRANS_PWMB_MUX2               CBUS_REG_ADDR(TRANS_PWMB_MUX2)
-#define TRANS_PWMB_MUX3 0x217d
-#define P_TRANS_PWMB_MUX3               CBUS_REG_ADDR(TRANS_PWMB_MUX3)
-#define TRANS_PWMB_MUX4 0x217e
-#define P_TRANS_PWMB_MUX4               CBUS_REG_ADDR(TRANS_PWMB_MUX4)
-#define TRANS_PWMB_MUX5 0x217f
-#define P_TRANS_PWMB_MUX5               CBUS_REG_ADDR(TRANS_PWMB_MUX5)
-#define NAND_START 0x2180
-#define P_NAND_START            CBUS_REG_ADDR(NAND_START)
-#define NAND_ADR_CMD 0x218a
-#define P_NAND_ADR_CMD          CBUS_REG_ADDR(NAND_ADR_CMD)
-#define NAND_ADR_STS 0x218b
-#define P_NAND_ADR_STS          CBUS_REG_ADDR(NAND_ADR_STS)
-#define NAND_END 0x218f
-#define P_NAND_END              CBUS_REG_ADDR(NAND_END)
-#define PWM_PWM_C 0x2194
-#define P_PWM_PWM_C             CBUS_REG_ADDR(PWM_PWM_C)
-#define PWM_PWM_D 0x2195
-#define P_PWM_PWM_D             CBUS_REG_ADDR(PWM_PWM_D)
-#define PWM_MISC_REG_CD 0x2196
-#define P_PWM_MISC_REG_CD               CBUS_REG_ADDR(PWM_MISC_REG_CD)
-#define PWM_DELTA_SIGMA_CD 0x2197
-#define P_PWM_DELTA_SIGMA_CD            CBUS_REG_ADDR(PWM_DELTA_SIGMA_CD)
-#define ISP_LED_CTRL 0x2198
-#define P_ISP_LED_CTRL          CBUS_REG_ADDR(ISP_LED_CTRL)
-#define ISP_LED_TIMING1 0x2199
-#define P_ISP_LED_TIMING1               CBUS_REG_ADDR(ISP_LED_TIMING1)
-#define ISP_LED_TIMING2 0x219a
-#define P_ISP_LED_TIMING2               CBUS_REG_ADDR(ISP_LED_TIMING2)
-#define ISP_LED_TIMING3 0x219b
-#define P_ISP_LED_TIMING3               CBUS_REG_ADDR(ISP_LED_TIMING3)
-#define ISP_LED_TIMING4 0x219c
-#define P_ISP_LED_TIMING4               CBUS_REG_ADDR(ISP_LED_TIMING4)
-#define ISP_LED_TIMING5 0x219d
-#define P_ISP_LED_TIMING5               CBUS_REG_ADDR(ISP_LED_TIMING5)
-#define ISP_LED_TIMING6 0x219e
-#define P_ISP_LED_TIMING6               CBUS_REG_ADDR(ISP_LED_TIMING6)
-#define SAR_ADC_REG0 0x21a0
-#define P_SAR_ADC_REG0          CBUS_REG_ADDR(SAR_ADC_REG0)
-#define SAR_ADC_CHAN_LIST 0x21a1
-#define P_SAR_ADC_CHAN_LIST             CBUS_REG_ADDR(SAR_ADC_CHAN_LIST)
-#define SAR_ADC_AVG_CNTL 0x21a2
-#define P_SAR_ADC_AVG_CNTL              CBUS_REG_ADDR(SAR_ADC_AVG_CNTL)
-#define SAR_ADC_REG3 0x21a3
-#define P_SAR_ADC_REG3          CBUS_REG_ADDR(SAR_ADC_REG3)
-#define SAR_ADC_DELAY 0x21a4
-#define P_SAR_ADC_DELAY                 CBUS_REG_ADDR(SAR_ADC_DELAY)
-#define SAR_ADC_LAST_RD 0x21a5
-#define P_SAR_ADC_LAST_RD               CBUS_REG_ADDR(SAR_ADC_LAST_RD)
-#define SAR_ADC_FIFO_RD 0x21a6
-#define P_SAR_ADC_FIFO_RD               CBUS_REG_ADDR(SAR_ADC_FIFO_RD)
-#define SAR_ADC_AUX_SW 0x21a7
-#define P_SAR_ADC_AUX_SW                CBUS_REG_ADDR(SAR_ADC_AUX_SW)
-#define SAR_ADC_CHAN_10_SW 0x21a8
-#define P_SAR_ADC_CHAN_10_SW            CBUS_REG_ADDR(SAR_ADC_CHAN_10_SW)
-#define SAR_ADC_DETECT_IDLE_SW 0x21a9
-#define P_SAR_ADC_DETECT_IDLE_SW \
-	CBUS_REG_ADDR(SAR_ADC_DETECT_IDLE_SW)
-#define SAR_ADC_DELTA_10 0x21aa
-#define P_SAR_ADC_DELTA_10              CBUS_REG_ADDR(SAR_ADC_DELTA_10)
-#define PWM_PWM_E 0x21b0
-#define P_PWM_PWM_E             CBUS_REG_ADDR(PWM_PWM_E)
-#define PWM_PWM_F 0x21b1
-#define P_PWM_PWM_F             CBUS_REG_ADDR(PWM_PWM_F)
-#define PWM_MISC_REG_EF 0x21b2
-#define P_PWM_MISC_REG_EF               CBUS_REG_ADDR(PWM_MISC_REG_EF)
-#define PWM_DELTA_SIGMA_EF 0x21b3
-#define P_PWM_DELTA_SIGMA_EF            CBUS_REG_ADDR(PWM_DELTA_SIGMA_EF)
-#define UART2_WFIFO 0x21c0
-#define P_UART2_WFIFO           CBUS_REG_ADDR(UART2_WFIFO)
-#define UART2_RFIFO 0x21c1
-#define P_UART2_RFIFO           CBUS_REG_ADDR(UART2_RFIFO)
-#define UART2_CONTROL 0x21c2
-#define P_UART2_CONTROL                 CBUS_REG_ADDR(UART2_CONTROL)
-#define UART2_STATUS 0x21c3
-#define P_UART2_STATUS          CBUS_REG_ADDR(UART2_STATUS)
-#define UART2_MISC 0x21c4
-#define P_UART2_MISC            CBUS_REG_ADDR(UART2_MISC)
-#define UART2_REG5 0x21c5
-#define P_UART2_REG5            CBUS_REG_ADDR(UART2_REG5)
-#define UART3_WFIFO 0x21c8
-#define P_UART3_WFIFO           CBUS_REG_ADDR(UART3_WFIFO)
-#define UART3_RFIFO 0x21c9
-#define P_UART3_RFIFO           CBUS_REG_ADDR(UART3_RFIFO)
-#define UART3_CONTROL 0x21ca
-#define P_UART3_CONTROL                 CBUS_REG_ADDR(UART3_CONTROL)
-#define UART3_STATUS 0x21cb
-#define P_UART3_STATUS          CBUS_REG_ADDR(UART3_STATUS)
-#define UART3_MISC 0x21cc
-#define P_UART3_MISC            CBUS_REG_ADDR(UART3_MISC)
-#define UART3_REG5 0x21cd
-#define P_UART3_REG5            CBUS_REG_ADDR(UART3_REG5)
-#define RTC_ADDR0 0x21d0
-#define P_RTC_ADDR0             CBUS_REG_ADDR(RTC_ADDR0)
-#define RTC_ADDR1 0x21d1
-#define P_RTC_ADDR1             CBUS_REG_ADDR(RTC_ADDR1)
-#define RTC_ADDR2 0x21d2
-#define P_RTC_ADDR2             CBUS_REG_ADDR(RTC_ADDR2)
-#define RTC_ADDR3 0x21d3
-#define P_RTC_ADDR3             CBUS_REG_ADDR(RTC_ADDR3)
-#define RTC_ADDR4 0x21d4
-#define P_RTC_ADDR4             CBUS_REG_ADDR(RTC_ADDR4)
-#define MSR_CLK_DUTY 0x21d6
-#define P_MSR_CLK_DUTY          CBUS_REG_ADDR(MSR_CLK_DUTY)
-#define MSR_CLK_REG0 0x21d7
-#define P_MSR_CLK_REG0          CBUS_REG_ADDR(MSR_CLK_REG0)
-#define MSR_CLK_REG1 0x21d8
-#define P_MSR_CLK_REG1          CBUS_REG_ADDR(MSR_CLK_REG1)
-#define MSR_CLK_REG2 0x21d9
-#define P_MSR_CLK_REG2          CBUS_REG_ADDR(MSR_CLK_REG2)
-/*add from M8M2*/
-#define MSR_CLK_REG3 0x21da
-#define P_MSR_CLK_REG3          CBUS_REG_ADDR(MSR_CLK_REG3)
-#define MSR_CLK_REG4 0x21db
-#define P_MSR_CLK_REG4          CBUS_REG_ADDR(MSR_CLK_REG4)
-#define MSR_CLK_REG5 0x21de
-#define P_MSR_CLK_REG5          CBUS_REG_ADDR(MSR_CLK_REG5)
-/**/
-/*
- * #define LED_PWM_REG0 0x21da
- * #define P_LED_PWM_REG0		CBUS_REG_ADDR(LED_PWM_REG0)
- * #define LED_PWM_REG1 0x21db
- * #define P_LED_PWM_REG1		CBUS_REG_ADDR(LED_PWM_REG1)
- * #define LED_PWM_REG2 0x21dc
- * #define P_LED_PWM_REG2		CBUS_REG_ADDR(LED_PWM_REG2)
- * #define LED_PWM_REG3 0x21dd
- * #define P_LED_PWM_REG3		CBUS_REG_ADDR(LED_PWM_REG3)
- * #define LED_PWM_REG4 0x21de
- * #define P_LED_PWM_REG4		CBUS_REG_ADDR(LED_PWM_REG4)
- * #define LED_PWM_REG5 0x21df
- * #define P_LED_PWM_REG5		CBUS_REG_ADDR(LED_PWM_REG5)
- * #define LED_PWM_REG6 0x21e0
- * #define P_LED_PWM_REG6		CBUS_REG_ADDR(LED_PWM_REG6)
- */
-#define VGHL_PWM_REG0 0x21e1
-#define P_VGHL_PWM_REG0                 CBUS_REG_ADDR(VGHL_PWM_REG0)
-#define VGHL_PWM_REG1 0x21e2
-#define P_VGHL_PWM_REG1                 CBUS_REG_ADDR(VGHL_PWM_REG1)
-#define VGHL_PWM_REG2 0x21e3
-#define P_VGHL_PWM_REG2                 CBUS_REG_ADDR(VGHL_PWM_REG2)
-#define VGHL_PWM_REG3 0x21e4
-#define P_VGHL_PWM_REG3                 CBUS_REG_ADDR(VGHL_PWM_REG3)
-#define VGHL_PWM_REG4 0x21e5
-#define P_VGHL_PWM_REG4                 CBUS_REG_ADDR(VGHL_PWM_REG4)
-#define VGHL_PWM_REG5 0x21e6
-#define P_VGHL_PWM_REG5                 CBUS_REG_ADDR(VGHL_PWM_REG5)
-#define VGHL_PWM_REG6 0x21e7
-#define P_VGHL_PWM_REG6                 CBUS_REG_ADDR(VGHL_PWM_REG6)
-#define I2C_M_1_CONTROL_REG 0x21f0
-#define P_I2C_M_1_CONTROL_REG           CBUS_REG_ADDR(I2C_M_1_CONTROL_REG)
-#define I2C_M_1_SLAVE_ADDR 0x21f1
-#define P_I2C_M_1_SLAVE_ADDR            CBUS_REG_ADDR(I2C_M_1_SLAVE_ADDR)
-#define I2C_M_1_TOKEN_LIST0 0x21f2
-#define P_I2C_M_1_TOKEN_LIST0           CBUS_REG_ADDR(I2C_M_1_TOKEN_LIST0)
-#define I2C_M_1_TOKEN_LIST1 0x21f3
-#define P_I2C_M_1_TOKEN_LIST1           CBUS_REG_ADDR(I2C_M_1_TOKEN_LIST1)
-#define I2C_M_1_WDATA_REG0 0x21f4
-#define P_I2C_M_1_WDATA_REG0            CBUS_REG_ADDR(I2C_M_1_WDATA_REG0)
-#define I2C_M_1_WDATA_REG1 0x21f5
-#define P_I2C_M_1_WDATA_REG1            CBUS_REG_ADDR(I2C_M_1_WDATA_REG1)
-#define I2C_M_1_RDATA_REG0 0x21f6
-#define P_I2C_M_1_RDATA_REG0            CBUS_REG_ADDR(I2C_M_1_RDATA_REG0)
-#define I2C_M_1_RDATA_REG1 0x21f7
-#define P_I2C_M_1_RDATA_REG1            CBUS_REG_ADDR(I2C_M_1_RDATA_REG1)
-#define I2C_M_2_CONTROL_REG 0x21f8
-#define P_I2C_M_2_CONTROL_REG           CBUS_REG_ADDR(I2C_M_2_CONTROL_REG)
-#define I2C_M_2_SLAVE_ADDR 0x21f9
-#define P_I2C_M_2_SLAVE_ADDR            CBUS_REG_ADDR(I2C_M_2_SLAVE_ADDR)
-#define I2C_M_2_TOKEN_LIST0 0x21fa
-#define P_I2C_M_2_TOKEN_LIST0           CBUS_REG_ADDR(I2C_M_2_TOKEN_LIST0)
-#define I2C_M_2_TOKEN_LIST1 0x21fb
-#define P_I2C_M_2_TOKEN_LIST1           CBUS_REG_ADDR(I2C_M_2_TOKEN_LIST1)
-#define I2C_M_2_WDATA_REG0 0x21fc
-#define P_I2C_M_2_WDATA_REG0            CBUS_REG_ADDR(I2C_M_2_WDATA_REG0)
-#define I2C_M_2_WDATA_REG1 0x21fd
-#define P_I2C_M_2_WDATA_REG1            CBUS_REG_ADDR(I2C_M_2_WDATA_REG1)
-#define I2C_M_2_RDATA_REG0 0x21fe
-#define P_I2C_M_2_RDATA_REG0            CBUS_REG_ADDR(I2C_M_2_RDATA_REG0)
-#define I2C_M_2_RDATA_REG1 0x21ff
-#define P_I2C_M_2_RDATA_REG1            CBUS_REG_ADDR(I2C_M_2_RDATA_REG1)
-#define USB_ADDR0 0x2200
-#define P_USB_ADDR0             CBUS_REG_ADDR(USB_ADDR0)
-#define USB_ADDR1 0x2201
-#define P_USB_ADDR1             CBUS_REG_ADDR(USB_ADDR1)
-#define USB_ADDR2 0x2202
-#define P_USB_ADDR2             CBUS_REG_ADDR(USB_ADDR2)
-#define USB_ADDR3 0x2203
-#define P_USB_ADDR3             CBUS_REG_ADDR(USB_ADDR3)
-#define USB_ADDR4 0x2204
-#define P_USB_ADDR4             CBUS_REG_ADDR(USB_ADDR4)
-#define USB_ADDR5 0x2205
-#define P_USB_ADDR5             CBUS_REG_ADDR(USB_ADDR5)
-#define USB_ADDR6 0x2206
-#define P_USB_ADDR6             CBUS_REG_ADDR(USB_ADDR6)
-#define USB_ADDR7 0x2207
-#define P_USB_ADDR7             CBUS_REG_ADDR(USB_ADDR7)
-#define USB_ADDR8 0x2208
-#define P_USB_ADDR8             CBUS_REG_ADDR(USB_ADDR8)
-#define USB_ADDR9 0x2209
-#define P_USB_ADDR9             CBUS_REG_ADDR(USB_ADDR9)
-#define USB_ADDR10 0x220a
-#define P_USB_ADDR10            CBUS_REG_ADDR(USB_ADDR10)
-#define USB_ADDR11 0x220b
-#define P_USB_ADDR11            CBUS_REG_ADDR(USB_ADDR11)
-#define USB_ADDR12 0x220c
-#define P_USB_ADDR12            CBUS_REG_ADDR(USB_ADDR12)
-#define USB_ADDR13 0x220d
-#define P_USB_ADDR13            CBUS_REG_ADDR(USB_ADDR13)
-#define USB_ADDR14 0x220e
-#define P_USB_ADDR14            CBUS_REG_ADDR(USB_ADDR14)
-#define USB_ADDR15 0x220f
-#define P_USB_ADDR15            CBUS_REG_ADDR(USB_ADDR15)
-#define USB_ADDR16 0x2210
-#define P_USB_ADDR16            CBUS_REG_ADDR(USB_ADDR16)
-#define USB_ADDR17 0x2211
-#define P_USB_ADDR17            CBUS_REG_ADDR(USB_ADDR17)
-#define USB_ADDR18 0x2212
-#define P_USB_ADDR18            CBUS_REG_ADDR(USB_ADDR18)
-#define USB_ADDR19 0x2213
-#define P_USB_ADDR19            CBUS_REG_ADDR(USB_ADDR19)
-#define USB_ADDR20 0x2214
-#define P_USB_ADDR20            CBUS_REG_ADDR(USB_ADDR20)
-#define USB_ADDR21 0x2215
-#define P_USB_ADDR21            CBUS_REG_ADDR(USB_ADDR21)
-#define USB_ADDR22 0x2216
-#define P_USB_ADDR22            CBUS_REG_ADDR(USB_ADDR22)
-#define USB_ADDR23 0x2217
-#define P_USB_ADDR23            CBUS_REG_ADDR(USB_ADDR23)
-#define USB_ADDR24 0x2218
-#define P_USB_ADDR24            CBUS_REG_ADDR(USB_ADDR24)
-#define USB_ADDR25 0x2219
-#define P_USB_ADDR25            CBUS_REG_ADDR(USB_ADDR25)
-#define USB_ADDR26 0x221a
-#define P_USB_ADDR26            CBUS_REG_ADDR(USB_ADDR26)
-#define USB_ADDR27 0x221b
-#define P_USB_ADDR27            CBUS_REG_ADDR(USB_ADDR27)
-#define USB_ADDR28 0x221c
-#define P_USB_ADDR28            CBUS_REG_ADDR(USB_ADDR28)
-#define USB_ADDR29 0x221d
-#define P_USB_ADDR29            CBUS_REG_ADDR(USB_ADDR29)
-#define USB_ADDR30 0x221e
-#define P_USB_ADDR30            CBUS_REG_ADDR(USB_ADDR30)
-#define USB_ADDR31 0x221f
-#define P_USB_ADDR31            CBUS_REG_ADDR(USB_ADDR31)
-/*add from M8M2*/
-#define SANA_STREAM_CONTROL 0x2220
-#define P_SANA_STREAM_CONTROL           CBUS_REG_ADDR(SANA_STREAM_CONTROL)
-#define SANA_STREAM_START_ADDR 0x2221
-#define P_SANA_STREAM_START_ADDR        \
-	CBUS_REG_ADDR(SANA_STREAM_START_ADDR)
-#define SANA_STREAM_END_ADDR 0x2222
-#define P_SANA_STREAM_END_ADDR          CBUS_REG_ADDR(SANA_STREAM_END_ADDR)
-#define SANA_STREAM_WR_PTR 0x2223
-#define P_SANA_STREAM_WR_PTR            CBUS_REG_ADDR(SANA_STREAM_WR_PTR)
-#define SANA_STREAM_RD_PTR 0x2224
-#define P_SANA_STREAM_RD_PTR            CBUS_REG_ADDR(SANA_STREAM_RD_PTR)
-#define SANA_STREAM_LEVEL 0x2225
-#define P_SANA_STREAM_LEVEL             CBUS_REG_ADDR(SANA_STREAM_LEVEL)
-#define SANA_STREAM_FIFO_CTL 0x2226
-#define P_SANA_STREAM_FIFO_CTL          CBUS_REG_ADDR(SANA_STREAM_FIFO_CTL)
-#define SANA_SHIFT_CONTROL 0x2227
-#define P_SANA_SHIFT_CONTROL            CBUS_REG_ADDR(SANA_SHIFT_CONTROL)
-#define SANA_SHIFT_STARTCODE 0x2228
-#define P_SANA_SHIFT_STARTCODE          CBUS_REG_ADDR(SANA_SHIFT_STARTCODE)
-#define SANA_SHIFT_EMULATECODE 0x2229
-#define P_SANA_SHIFT_EMULATECODE        \
-	CBUS_REG_ADDR(SANA_SHIFT_EMULATECODE)
-#define SANA_SHIFT_STATUS 0x222a
-#define P_SANA_SHIFT_STATUS             CBUS_REG_ADDR(SANA_SHIFT_STATUS)
-#define SANA_SHIFTED_DATA 0x222b
-#define P_SANA_SHIFTED_DATA             CBUS_REG_ADDR(SANA_SHIFTED_DATA)
-#define SANA_SHIFT_BYTE_COUNT 0x222c
-#define P_SANA_SHIFT_BYTE_COUNT         \
-	CBUS_REG_ADDR(SANA_SHIFT_BYTE_COUNT)
-#define SANA_SHIFT_COMMAND 0x222d
-#define P_SANA_SHIFT_COMMAND            CBUS_REG_ADDR(SANA_SHIFT_COMMAND)
-#define SANA_ELEMENT_RESULT 0x222e
-#define P_SANA_ELEMENT_RESULT           CBUS_REG_ADDR(SANA_ELEMENT_RESULT)
-#define ATOM_LOCK 0x222f
-#define P_ATOM_LOCK             CBUS_REG_ADDR(ATOM_LOCK)
-/**/
-#define NDMA_CNTL_REG0 0x2270
-#define P_NDMA_CNTL_REG0                CBUS_REG_ADDR(NDMA_CNTL_REG0)
-#define NDMA_TABLE_ADD_REG 0x2272
-#define P_NDMA_TABLE_ADD_REG            CBUS_REG_ADDR(NDMA_TABLE_ADD_REG)
-#define NDMA_TDES_KEY_LO 0x2273
-#define P_NDMA_TDES_KEY_LO              CBUS_REG_ADDR(NDMA_TDES_KEY_LO)
-#define NDMA_TDES_KEY_HI 0x2274
-#define P_NDMA_TDES_KEY_HI              CBUS_REG_ADDR(NDMA_TDES_KEY_HI)
-#define NDMA_TDES_CONTROL 0x2275
-#define P_NDMA_TDES_CONTROL             CBUS_REG_ADDR(NDMA_TDES_CONTROL)
-#define NDMA_RIJNDAEL_CONTROL 0x2276
-#define P_NDMA_RIJNDAEL_CONTROL         \
-	CBUS_REG_ADDR(NDMA_RIJNDAEL_CONTROL)
-#define NDMA_RIJNDAEL_RK_FIFO 0x2277
-#define P_NDMA_RIJNDAEL_RK_FIFO         \
-	CBUS_REG_ADDR(NDMA_RIJNDAEL_RK_FIFO)
-#define NDMA_CRC_OUT 0x2278
-#define P_NDMA_CRC_OUT          CBUS_REG_ADDR(NDMA_CRC_OUT)
-#define NDMA_THREAD_REG 0x2279
-#define P_NDMA_THREAD_REG               CBUS_REG_ADDR(NDMA_THREAD_REG)
-#define NDMA_THREAD_TABLE_START0 0x2280
-#define P_NDMA_THREAD_TABLE_START0      \
-	CBUS_REG_ADDR(NDMA_THREAD_TABLE_START0)
-#define NDMA_THREAD_TABLE_CURR0 0x2281
-
-#define NDMA_CNTL_REG1 0x228c
-#define P_NDMA_CNTL_REG1                CBUS_REG_ADDR(NDMA_CNTL_REG1)
-#define NDMA_AES_KEY_0 0x2290
-#define P_NDMA_AES_KEY_0                CBUS_REG_ADDR(NDMA_AES_KEY_0)
-#define NDMA_AES_KEY_1 0x2291
-#define P_NDMA_AES_KEY_1                CBUS_REG_ADDR(NDMA_AES_KEY_1)
-#define NDMA_AES_KEY_2 0x2292
-#define P_NDMA_AES_KEY_2                CBUS_REG_ADDR(NDMA_AES_KEY_2)
-#define NDMA_AES_KEY_3 0x2293
-#define P_NDMA_AES_KEY_3                CBUS_REG_ADDR(NDMA_AES_KEY_3)
-#define NDMA_AES_KEY_4 0x2294
-#define P_NDMA_AES_KEY_4                CBUS_REG_ADDR(NDMA_AES_KEY_4)
-#define NDMA_AES_KEY_5 0x2295
-#define P_NDMA_AES_KEY_5                CBUS_REG_ADDR(NDMA_AES_KEY_5)
-#define NDMA_AES_KEY_6 0x2296
-#define P_NDMA_AES_KEY_6                CBUS_REG_ADDR(NDMA_AES_KEY_6)
-#define NDMA_AES_KEY_7 0x2297
-#define P_NDMA_AES_KEY_7                CBUS_REG_ADDR(NDMA_AES_KEY_7)
-#define NDMA_AES_IV_0 0x2298
-#define P_NDMA_AES_IV_0                 CBUS_REG_ADDR(NDMA_AES_IV_0)
-#define NDMA_AES_IV_1 0x2299
-#define P_NDMA_AES_IV_1                 CBUS_REG_ADDR(NDMA_AES_IV_1)
-#define NDMA_AES_IV_2 0x229a
-#define P_NDMA_AES_IV_2                 CBUS_REG_ADDR(NDMA_AES_IV_2)
-#define NDMA_AES_IV_3 0x229b
-#define P_NDMA_AES_IV_3                 CBUS_REG_ADDR(NDMA_AES_IV_3)
-#define NDMA_AES_REG0 0x229c
-#define P_NDMA_AES_REG0                 CBUS_REG_ADDR(NDMA_AES_REG0)
-#define STREAM_EVENT_INFO 0x2300
-#define P_STREAM_EVENT_INFO             CBUS_REG_ADDR(STREAM_EVENT_INFO)
-#define STREAM_OUTPUT_CONFIG 0x2301
-#define P_STREAM_OUTPUT_CONFIG          CBUS_REG_ADDR(STREAM_OUTPUT_CONFIG)
-#define C_D_BUS_CONTROL 0x2302
-#define P_C_D_BUS_CONTROL               CBUS_REG_ADDR(C_D_BUS_CONTROL)
-#define C_DATA 0x2303
-#define P_C_DATA                CBUS_REG_ADDR(C_DATA)
-#define STREAM_BUS_CONFIG 0x2304
-#define P_STREAM_BUS_CONFIG             CBUS_REG_ADDR(STREAM_BUS_CONFIG)
-#define STREAM_EVENT_CTL 0x2307
-#define P_STREAM_EVENT_CTL              CBUS_REG_ADDR(STREAM_EVENT_CTL)
-#define CMD_ARGUMENT 0x2308
-#define P_CMD_ARGUMENT          CBUS_REG_ADDR(CMD_ARGUMENT)
-#define CMD_SEND 0x2309
-#define P_CMD_SEND              CBUS_REG_ADDR(CMD_SEND)
-#define SDIO_CONFIG 0x230a
-#define P_SDIO_CONFIG           CBUS_REG_ADDR(SDIO_CONFIG)
-#define SDIO_STATUS_IRQ 0x230b
-#define P_SDIO_STATUS_IRQ               CBUS_REG_ADDR(SDIO_STATUS_IRQ)
-#define SDIO_IRQ_CONFIG 0x230c
-#define P_SDIO_IRQ_CONFIG               CBUS_REG_ADDR(SDIO_IRQ_CONFIG)
-#define SDIO_MULT_CONFIG 0x230d
-#define P_SDIO_MULT_CONFIG              CBUS_REG_ADDR(SDIO_MULT_CONFIG)
-#define SDIO_M_ADDR 0x230e
-#define P_SDIO_M_ADDR           CBUS_REG_ADDR(SDIO_M_ADDR)
-#define SDIO_EXTENSION 0x230f
-#define P_SDIO_EXTENSION                CBUS_REG_ADDR(SDIO_EXTENSION)
-#define ASYNC_FIFO_REG0 0x2310
-#define P_ASYNC_FIFO_REG0               CBUS_REG_ADDR(ASYNC_FIFO_REG0)
-#define ASYNC_FIFO_REG1 0x2311
-#define P_ASYNC_FIFO_REG1               CBUS_REG_ADDR(ASYNC_FIFO_REG1)
-#define ASYNC_FIFO_REG2 0x2312
-#define P_ASYNC_FIFO_REG2               CBUS_REG_ADDR(ASYNC_FIFO_REG2)
-#define ASYNC_FIFO_REG3 0x2313
-#define P_ASYNC_FIFO_REG3               CBUS_REG_ADDR(ASYNC_FIFO_REG3)
-#define ASYNC_FIFO2_REG0 0x2314
-#define P_ASYNC_FIFO2_REG0              CBUS_REG_ADDR(ASYNC_FIFO2_REG0)
-#define ASYNC_FIFO2_REG1 0x2315
-#define P_ASYNC_FIFO2_REG1              CBUS_REG_ADDR(ASYNC_FIFO2_REG1)
-#define ASYNC_FIFO2_REG2 0x2316
-#define P_ASYNC_FIFO2_REG2              CBUS_REG_ADDR(ASYNC_FIFO2_REG2)
-#define ASYNC_FIFO2_REG3 0x2317
-#define P_ASYNC_FIFO2_REG3              CBUS_REG_ADDR(ASYNC_FIFO2_REG3)
-#define SDIO_AHB_CBUS_CTRL 0x2318
-#define P_SDIO_AHB_CBUS_CTRL            CBUS_REG_ADDR(SDIO_AHB_CBUS_CTRL)
-#define SDIO_AHB_CBUS_M_DATA 0x2319
-#define P_SDIO_AHB_CBUS_M_DATA          CBUS_REG_ADDR(SDIO_AHB_CBUS_M_DATA)
-#define SPI_FLASH_CMD 0x2320
-#define P_SPI_FLASH_CMD                 CBUS_REG_ADDR(SPI_FLASH_CMD)
-#define SPI_FLASH_ADDR 0x2321
-#define P_SPI_FLASH_ADDR                CBUS_REG_ADDR(SPI_FLASH_ADDR)
-#define SPI_FLASH_CTRL 0x2322
-#define P_SPI_FLASH_CTRL                CBUS_REG_ADDR(SPI_FLASH_CTRL)
-#define SPI_FLASH_CTRL1 0x2323
-#define P_SPI_FLASH_CTRL1               CBUS_REG_ADDR(SPI_FLASH_CTRL1)
-#define SPI_FLASH_STATUS 0x2324
-#define P_SPI_FLASH_STATUS              CBUS_REG_ADDR(SPI_FLASH_STATUS)
-#define SPI_FLASH_CTRL2 0x2325
-#define P_SPI_FLASH_CTRL2               CBUS_REG_ADDR(SPI_FLASH_CTRL2)
-#define SPI_FLASH_CLOCK 0x2326
-#define P_SPI_FLASH_CLOCK               CBUS_REG_ADDR(SPI_FLASH_CLOCK)
-#define SPI_FLASH_USER 0x2327
-#define P_SPI_FLASH_USER                CBUS_REG_ADDR(SPI_FLASH_USER)
-#define SPI_FLASH_USER1 0x2328
-#define P_SPI_FLASH_USER1               CBUS_REG_ADDR(SPI_FLASH_USER1)
-#define SPI_FLASH_USER2 0x2329
-#define P_SPI_FLASH_USER2               CBUS_REG_ADDR(SPI_FLASH_USER2)
-#define SPI_FLASH_USER3 0x232a
-#define P_SPI_FLASH_USER3               CBUS_REG_ADDR(SPI_FLASH_USER3)
-#define SPI_FLASH_USER4 0x232b
-#define P_SPI_FLASH_USER4               CBUS_REG_ADDR(SPI_FLASH_USER4)
-#define SPI_FLASH_SLAVE 0x232c
-#define P_SPI_FLASH_SLAVE               CBUS_REG_ADDR(SPI_FLASH_SLAVE)
-#define SPI_FLASH_SLAVE1 0x232d
-#define P_SPI_FLASH_SLAVE1              CBUS_REG_ADDR(SPI_FLASH_SLAVE1)
-#define SPI_FLASH_SLAVE2 0x232e
-#define P_SPI_FLASH_SLAVE2              CBUS_REG_ADDR(SPI_FLASH_SLAVE2)
-#define SPI_FLASH_SLAVE3 0x232f
-#define P_SPI_FLASH_SLAVE3              CBUS_REG_ADDR(SPI_FLASH_SLAVE3)
-#define SPI_FLASH_C0 0x2330
-#define P_SPI_FLASH_C0          CBUS_REG_ADDR(SPI_FLASH_C0)
-#define SPI_FLASH_C1 0x2331
-#define P_SPI_FLASH_C1          CBUS_REG_ADDR(SPI_FLASH_C1)
-#define SPI_FLASH_C2 0x2332
-#define P_SPI_FLASH_C2          CBUS_REG_ADDR(SPI_FLASH_C2)
-#define SPI_FLASH_C3 0x2333
-#define P_SPI_FLASH_C3          CBUS_REG_ADDR(SPI_FLASH_C3)
-#define SPI_FLASH_C4 0x2334
-#define P_SPI_FLASH_C4          CBUS_REG_ADDR(SPI_FLASH_C4)
-#define SPI_FLASH_C5 0x2335
-#define P_SPI_FLASH_C5          CBUS_REG_ADDR(SPI_FLASH_C5)
-#define SPI_FLASH_C6 0x2336
-#define P_SPI_FLASH_C6          CBUS_REG_ADDR(SPI_FLASH_C6)
-#define SPI_FLASH_C7 0x2337
-#define P_SPI_FLASH_C7          CBUS_REG_ADDR(SPI_FLASH_C7)
-#define SPI_FLASH_B8 0x2338
-#define P_SPI_FLASH_B8          CBUS_REG_ADDR(SPI_FLASH_B8)
-#define SPI_FLASH_B9 0x2339
-#define P_SPI_FLASH_B9          CBUS_REG_ADDR(SPI_FLASH_B9)
-#define SPI_FLASH_B10 0x233a
-#define P_SPI_FLASH_B10                 CBUS_REG_ADDR(SPI_FLASH_B10)
-#define SPI_FLASH_B11 0x233b
-#define P_SPI_FLASH_B11                 CBUS_REG_ADDR(SPI_FLASH_B11)
-#define SPI_FLASH_B12 0x233c
-#define P_SPI_FLASH_B12                 CBUS_REG_ADDR(SPI_FLASH_B12)
-#define SPI_FLASH_B13 0x233d
-#define P_SPI_FLASH_B13                 CBUS_REG_ADDR(SPI_FLASH_B13)
-#define SPI_FLASH_B14 0x233e
-#define P_SPI_FLASH_B14                 CBUS_REG_ADDR(SPI_FLASH_B14)
-#define SPI_FLASH_B15 0x233f
-#define P_SPI_FLASH_B15                 CBUS_REG_ADDR(SPI_FLASH_B15)
-#define I2C_M_3_CONTROL_REG 0x2348
-#define P_I2C_M_3_CONTROL_REG           CBUS_REG_ADDR(I2C_M_3_CONTROL_REG)
-#define I2C_M_3_SLAVE_ADDR 0x2349
-#define P_I2C_M_3_SLAVE_ADDR            CBUS_REG_ADDR(I2C_M_3_SLAVE_ADDR)
-#define I2C_M_3_TOKEN_LIST0 0x234a
-#define P_I2C_M_3_TOKEN_LIST0           CBUS_REG_ADDR(I2C_M_3_TOKEN_LIST0)
-#define I2C_M_3_TOKEN_LIST1 0x234b
-#define P_I2C_M_3_TOKEN_LIST1           CBUS_REG_ADDR(I2C_M_3_TOKEN_LIST1)
-#define I2C_M_3_WDATA_REG0 0x234c
-#define P_I2C_M_3_WDATA_REG0            CBUS_REG_ADDR(I2C_M_3_WDATA_REG0)
-#define I2C_M_3_WDATA_REG1 0x234d
-#define P_I2C_M_3_WDATA_REG1            CBUS_REG_ADDR(I2C_M_3_WDATA_REG1)
-#define I2C_M_3_RDATA_REG0 0x234e
-#define P_I2C_M_3_RDATA_REG0            CBUS_REG_ADDR(I2C_M_3_RDATA_REG0)
-#define I2C_M_3_RDATA_REG1 0x234f
-#define P_I2C_M_3_RDATA_REG1            CBUS_REG_ADDR(I2C_M_3_RDATA_REG1)
-#define SPICC_RXDATA 0x2360
-#define P_SPICC_RXDATA          CBUS_REG_ADDR(SPICC_RXDATA)
-#define SPICC_TXDATA 0x2361
-#define P_SPICC_TXDATA          CBUS_REG_ADDR(SPICC_TXDATA)
-#define SPICC_CONREG 0x2362
-#define P_SPICC_CONREG          CBUS_REG_ADDR(SPICC_CONREG)
-#define SPICC_INTREG 0x2363
-#define P_SPICC_INTREG          CBUS_REG_ADDR(SPICC_INTREG)
-#define SPICC_DMAREG 0x2364
-#define P_SPICC_DMAREG          CBUS_REG_ADDR(SPICC_DMAREG)
-#define SPICC_STATREG 0x2365
-#define P_SPICC_STATREG                 CBUS_REG_ADDR(SPICC_STATREG)
-#define SPICC_PERIODREG 0x2366
-#define P_SPICC_PERIODREG               CBUS_REG_ADDR(SPICC_PERIODREG)
-#define SPICC_TESTREG 0x2367
-#define P_SPICC_TESTREG                 CBUS_REG_ADDR(SPICC_TESTREG)
-#define SPICC_DRADDR 0x2368
-#define P_SPICC_DRADDR          CBUS_REG_ADDR(SPICC_DRADDR)
-#define SPICC_DWADDR 0x2369
-#define P_SPICC_DWADDR          CBUS_REG_ADDR(SPICC_DWADDR)
-#define SD_REG0_ARGU 0x2380
-#define P_SD_REG0_ARGU          CBUS_REG_ADDR(SD_REG0_ARGU)
-#define SD_REG1_SEND 0x2381
-#define P_SD_REG1_SEND          CBUS_REG_ADDR(SD_REG1_SEND)
-#define SD_REG2_CNTL 0x2382
-#define P_SD_REG2_CNTL          CBUS_REG_ADDR(SD_REG2_CNTL)
-#define SD_REG3_STAT 0x2383
-#define P_SD_REG3_STAT          CBUS_REG_ADDR(SD_REG3_STAT)
-#define SD_REG4_CLKC 0x2384
-#define P_SD_REG4_CLKC          CBUS_REG_ADDR(SD_REG4_CLKC)
-#define SD_REG5_ADDR 0x2385
-#define P_SD_REG5_ADDR          CBUS_REG_ADDR(SD_REG5_ADDR)
-#define SD_REG6_PDMA 0x2386
-#define P_SD_REG6_PDMA          CBUS_REG_ADDR(SD_REG6_PDMA)
-#define SD_REG7_MISC 0x2387
-#define P_SD_REG7_MISC          CBUS_REG_ADDR(SD_REG7_MISC)
-#define SD_REG8_DATA 0x2388
-#define P_SD_REG8_DATA          CBUS_REG_ADDR(SD_REG8_DATA)
-#define SD_REG9_ICTL 0x2389
-#define P_SD_REG9_ICTL          CBUS_REG_ADDR(SD_REG9_ICTL)
-#define SD_REGA_ISTA 0x238a
-#define P_SD_REGA_ISTA          CBUS_REG_ADDR(SD_REGA_ISTA)
-#define SD_REGB_SRST 0x238b
-#define P_SD_REGB_SRST          CBUS_REG_ADDR(SD_REGB_SRST)
-#define SD_REGC_ESTA 0x238c
-#define P_SD_REGC_ESTA          CBUS_REG_ADDR(SD_REGC_ESTA)
-#define SD_REGD_ENHC 0x238d
-#define P_SD_REGD_ENHC          CBUS_REG_ADDR(SD_REGD_ENHC)
-#define SD_REGE_CLK2 0x238e
-#define P_SD_REGE_CLK2          CBUS_REG_ADDR(SD_REGE_CLK2)
-#define ISA_DEBUG_REG0 0x2600
-#define P_ISA_DEBUG_REG0                CBUS_REG_ADDR(ISA_DEBUG_REG0)
-#define ISA_DEBUG_REG1 0x2601
-#define P_ISA_DEBUG_REG1                CBUS_REG_ADDR(ISA_DEBUG_REG1)
-#define ISA_DEBUG_REG2 0x2602
-#define P_ISA_DEBUG_REG2                CBUS_REG_ADDR(ISA_DEBUG_REG2)
-#define ISA_DEBUG_REG3 0x2603
-#define P_ISA_DEBUG_REG3                CBUS_REG_ADDR(ISA_DEBUG_REG3)
-#define ISA_PLL_CLK_SIM0 0x2608
-#define P_ISA_PLL_CLK_SIM0              CBUS_REG_ADDR(ISA_PLL_CLK_SIM0)
-#define ISA_CNTL_REG0 0x2609
-#define P_ISA_CNTL_REG0                 CBUS_REG_ADDR(ISA_CNTL_REG0)
-#define AO_CPU_IRQ_IN0_INTR_STAT 0x2610
-#define P_AO_CPU_IRQ_IN0_INTR_STAT      \
-	CBUS_REG_ADDR(AO_CPU_IRQ_IN0_INTR_STAT)
-#define AO_CPU_IRQ_IN0_INTR_STAT_CLR 0x2611
-#define P_AO_CPU_IRQ_IN0_INTR_STAT_CLR  \
-	CBUS_REG_ADDR(AO_CPU_IRQ_IN0_INTR_STAT_CLR)
-#define AO_CPU_IRQ_IN0_INTR_MASK 0x2612
-#define P_AO_CPU_IRQ_IN0_INTR_MASK      \
-	CBUS_REG_ADDR(AO_CPU_IRQ_IN0_INTR_MASK)
-#define AO_CPU_IRQ_IN0_INTR_FIRQ_SEL 0x2613
-#define P_AO_CPU_IRQ_IN0_INTR_FIRQ_SEL  \
-	CBUS_REG_ADDR(AO_CPU_IRQ_IN0_INTR_FIRQ_SEL)
-#define GPIO_INTR_EDGE_POL 0x2620
-#define P_GPIO_INTR_EDGE_POL            CBUS_REG_ADDR(GPIO_INTR_EDGE_POL)
-#define GPIO_INTR_GPIO_SEL0 0x2621
-#define P_GPIO_INTR_GPIO_SEL0           CBUS_REG_ADDR(GPIO_INTR_GPIO_SEL0)
-#define GPIO_INTR_GPIO_SEL1 0x2622
-#define P_GPIO_INTR_GPIO_SEL1           CBUS_REG_ADDR(GPIO_INTR_GPIO_SEL1)
-#define GPIO_INTR_FILTER_SEL0 0x2623
-#define P_GPIO_INTR_FILTER_SEL0         \
-	CBUS_REG_ADDR(GPIO_INTR_FILTER_SEL0)
-#define MEDIA_CPU_INTR_STAT 0x2628
-#define P_MEDIA_CPU_INTR_STAT           CBUS_REG_ADDR(MEDIA_CPU_INTR_STAT)
-#define ISA_BIST_REG1 0x2631
-#define P_ISA_BIST_REG1                 CBUS_REG_ADDR(ISA_BIST_REG1)
-#define WATCHDOG_TC 0x2640
-#define P_WATCHDOG_TC           CBUS_REG_ADDR(WATCHDOG_TC)
-#define WATCHDOG_RESET 0x2641
-#define P_WATCHDOG_RESET                CBUS_REG_ADDR(WATCHDOG_RESET)
-#define AHB_ARBITER_REG 0x2642
-#define P_AHB_ARBITER_REG               CBUS_REG_ADDR(AHB_ARBITER_REG)
-#define AHB_ARBDEC_REG 0x2643
-#define P_AHB_ARBDEC_REG                CBUS_REG_ADDR(AHB_ARBDEC_REG)
-#define AHB_ARBITER2_REG 0x264a
-#define P_AHB_ARBITER2_REG              CBUS_REG_ADDR(AHB_ARBITER2_REG)
-#define DEVICE_MMCP_CNTL 0x264b
-#define P_DEVICE_MMCP_CNTL              CBUS_REG_ADDR(DEVICE_MMCP_CNTL)
-#define AUDIO_MMCP_CNTL 0x264c
-#define P_AUDIO_MMCP_CNTL               CBUS_REG_ADDR(AUDIO_MMCP_CNTL)
-#define ISA_TIMER_MUX 0x2650
-#define P_ISA_TIMER_MUX                 CBUS_REG_ADDR(ISA_TIMER_MUX)
-#define ISA_TIMERA 0x2651
-#define P_ISA_TIMERA            CBUS_REG_ADDR(ISA_TIMERA)
-#define ISA_TIMERB 0x2652
-#define P_ISA_TIMERB            CBUS_REG_ADDR(ISA_TIMERB)
-#define ISA_TIMERC 0x2653
-#define P_ISA_TIMERC            CBUS_REG_ADDR(ISA_TIMERC)
-#define ISA_TIMERD 0x2654
-#define P_ISA_TIMERD            CBUS_REG_ADDR(ISA_TIMERD)
-#define ISA_TIMERE 0x2655
-#define P_ISA_TIMERE            CBUS_REG_ADDR(ISA_TIMERE)
-#define FBUF_ADDR 0x2656
-#define P_FBUF_ADDR             CBUS_REG_ADDR(FBUF_ADDR)
-#define SDRAM_CTL0 0x2657
-#define P_SDRAM_CTL0            CBUS_REG_ADDR(SDRAM_CTL0)
-#define SDRAM_CTL2 0x2658
-#define P_SDRAM_CTL2            CBUS_REG_ADDR(SDRAM_CTL2)
-#define SDRAM_CTL4 0x265a
-#define P_SDRAM_CTL4            CBUS_REG_ADDR(SDRAM_CTL4)
-#define SDRAM_CTL5 0x265b
-#define P_SDRAM_CTL5            CBUS_REG_ADDR(SDRAM_CTL5)
-#define SDRAM_CTL6 0x265c
-#define P_SDRAM_CTL6            CBUS_REG_ADDR(SDRAM_CTL6)
-#define SDRAM_CTL7 0x265d
-#define P_SDRAM_CTL7            CBUS_REG_ADDR(SDRAM_CTL7)
-#define SDRAM_CTL8 0x265e
-#define P_SDRAM_CTL8            CBUS_REG_ADDR(SDRAM_CTL8)
-#define AHB_MP4_MC_CTL 0x265f
-#define P_AHB_MP4_MC_CTL                CBUS_REG_ADDR(AHB_MP4_MC_CTL)
-#define MEDIA_CPU_PCR 0x2660
-#define P_MEDIA_CPU_PCR                 CBUS_REG_ADDR(MEDIA_CPU_PCR)
-#define MEDIA_CPU_CTL 0x2661
-#define P_MEDIA_CPU_CTL                 CBUS_REG_ADDR(MEDIA_CPU_CTL)
-#define ISA_TIMER_MUX1 0x2664
-#define P_ISA_TIMER_MUX1                CBUS_REG_ADDR(ISA_TIMER_MUX1)
-#define ISA_TIMERF 0x2665
-#define P_ISA_TIMERF            CBUS_REG_ADDR(ISA_TIMERF)
-#define ISA_TIMERG 0x2666
-#define P_ISA_TIMERG            CBUS_REG_ADDR(ISA_TIMERG)
-#define ISA_TIMERH 0x2667
-#define P_ISA_TIMERH            CBUS_REG_ADDR(ISA_TIMERH)
-#define ISA_TIMERI 0x2668
-#define P_ISA_TIMERI            CBUS_REG_ADDR(ISA_TIMERI)
-#define ABUF_WR_CTL0 0x2670
-#define P_ABUF_WR_CTL0          CBUS_REG_ADDR(ABUF_WR_CTL0)
-#define ABUF_WR_CTL1 0x2671
-#define P_ABUF_WR_CTL1          CBUS_REG_ADDR(ABUF_WR_CTL1)
-#define ABUF_WR_CTL2 0x2672
-#define P_ABUF_WR_CTL2          CBUS_REG_ADDR(ABUF_WR_CTL2)
-#define ABUF_WR_CTL3 0x2673
-#define P_ABUF_WR_CTL3          CBUS_REG_ADDR(ABUF_WR_CTL3)
-#define ABUF_RD_CTL0 0x2674
-#define P_ABUF_RD_CTL0          CBUS_REG_ADDR(ABUF_RD_CTL0)
-#define ABUF_RD_CTL1 0x2675
-#define P_ABUF_RD_CTL1          CBUS_REG_ADDR(ABUF_RD_CTL1)
-#define ABUF_RD_CTL2 0x2676
-#define P_ABUF_RD_CTL2          CBUS_REG_ADDR(ABUF_RD_CTL2)
-#define ABUF_RD_CTL3 0x2677
-#define P_ABUF_RD_CTL3          CBUS_REG_ADDR(ABUF_RD_CTL3)
-#define ABUF_ARB_CTL0 0x2678
-#define P_ABUF_ARB_CTL0                 CBUS_REG_ADDR(ABUF_ARB_CTL0)
-#define ABUF_FIFO_CTL0 0x2679
-#define P_ABUF_FIFO_CTL0                CBUS_REG_ADDR(ABUF_FIFO_CTL0)
-#define AHB_BRIDGE_CNTL_WR 0x2680
-#define P_AHB_BRIDGE_CNTL_WR            CBUS_REG_ADDR(AHB_BRIDGE_CNTL_WR)
-#define AHB_BRIDGE_REMAP0 0x2681
-#define P_AHB_BRIDGE_REMAP0             CBUS_REG_ADDR(AHB_BRIDGE_REMAP0)
-#define AHB_BRIDGE_REMAP1 0x2682
-#define P_AHB_BRIDGE_REMAP1             CBUS_REG_ADDR(AHB_BRIDGE_REMAP1)
-#define AHB_BRIDGE_REMAP2 0x2683
-#define P_AHB_BRIDGE_REMAP2             CBUS_REG_ADDR(AHB_BRIDGE_REMAP2)
-#define AHB_BRIDGE_REMAP3 0x2684
-#define P_AHB_BRIDGE_REMAP3             CBUS_REG_ADDR(AHB_BRIDGE_REMAP3)
-#define AHB_BRIDGE_CNTL_REG1 0x2685
-#define P_AHB_BRIDGE_CNTL_REG1          CBUS_REG_ADDR(AHB_BRIDGE_CNTL_REG1)
-#define AHB_BRIDGE_CNTL_REG2 0x2686
-#define P_AHB_BRIDGE_CNTL_REG2          CBUS_REG_ADDR(AHB_BRIDGE_CNTL_REG2)
-#define IQ_OM_WIDTH 0x2510
-#define P_IQ_OM_WIDTH           CBUS_REG_ADDR(IQ_OM_WIDTH)
-#define DBG_ADDR_START 0x2ff0
-#define P_DBG_ADDR_START                CBUS_REG_ADDR(DBG_ADDR_START)
-#define DBG_ADDR_END 0x2fff
-#define P_DBG_ADDR_END          CBUS_REG_ADDR(DBG_ADDR_END)
-#define DBG_CTRL 0x2ff1
-#define P_DBG_CTRL              CBUS_REG_ADDR(DBG_CTRL)
-#define DBG_LED 0x2ff2
-#define P_DBG_LED               CBUS_REG_ADDR(DBG_LED)
-#define DBG_SWITCH 0x2ff3
-#define P_DBG_SWITCH            CBUS_REG_ADDR(DBG_SWITCH)
-#define DBG_VERSION 0x2ff4
-#define P_DBG_VERSION           CBUS_REG_ADDR(DBG_VERSION)
-#define VERSION_CTRL 0x1100
-#define P_VERSION_CTRL          CBUS_REG_ADDR(VERSION_CTRL)
-#define RESET0_REGISTER 0x1101
-#define P_RESET0_REGISTER               CBUS_REG_ADDR(RESET0_REGISTER)
-#define RESET1_REGISTER 0x1102
-#define P_RESET1_REGISTER               CBUS_REG_ADDR(RESET1_REGISTER)
-#define RESET2_REGISTER 0x1103
-#define P_RESET2_REGISTER               CBUS_REG_ADDR(RESET2_REGISTER)
-#define RESET3_REGISTER 0x1104
-#define P_RESET3_REGISTER               CBUS_REG_ADDR(RESET3_REGISTER)
-#define RESET4_REGISTER 0x1105
-#define P_RESET4_REGISTER               CBUS_REG_ADDR(RESET4_REGISTER)
-#define RESET5_REGISTER 0x1106
-#define P_RESET5_REGISTER               CBUS_REG_ADDR(RESET5_REGISTER)
-#define RESET6_REGISTER 0x1107
-#define P_RESET6_REGISTER               CBUS_REG_ADDR(RESET6_REGISTER)
-#define RESET7_REGISTER 0x1108
-#define P_RESET7_REGISTER               CBUS_REG_ADDR(RESET7_REGISTER)
-#define RESET0_MASK 0x1110
-#define P_RESET0_MASK           CBUS_REG_ADDR(RESET0_MASK)
-#define RESET1_MASK 0x1111
-#define P_RESET1_MASK           CBUS_REG_ADDR(RESET1_MASK)
-#define RESET2_MASK 0x1112
-#define P_RESET2_MASK           CBUS_REG_ADDR(RESET2_MASK)
-#define RESET3_MASK 0x1113
-#define P_RESET3_MASK           CBUS_REG_ADDR(RESET3_MASK)
-#define RESET4_MASK 0x1114
-#define P_RESET4_MASK           CBUS_REG_ADDR(RESET4_MASK)
-#define RESET5_MASK 0x1115
-#define P_RESET5_MASK           CBUS_REG_ADDR(RESET5_MASK)
-#define RESET6_MASK 0x1116
-#define P_RESET6_MASK           CBUS_REG_ADDR(RESET6_MASK)
-#define CRT_MASK 0x1117
-#define P_CRT_MASK              CBUS_REG_ADDR(CRT_MASK)
-#define RESET7_MASK 0x1118
-#define P_RESET7_MASK           CBUS_REG_ADDR(RESET7_MASK)
-/*add from M8M2*/
-#define RESET0_LEVEL 0xc1104480
-#define RESET1_LEVEL 0x1121
-#define P_RESET1_LEVEL          CBUS_REG_ADDR(RESET1_LEVEL)
-#define RESET2_LEVEL 0x1122
-#define P_RESET2_LEVEL          CBUS_REG_ADDR(RESET2_LEVEL)
-#define RESET3_LEVEL 0x1123
-#define P_RESET3_LEVEL          CBUS_REG_ADDR(RESET3_LEVEL)
-#define RESET4_LEVEL 0x1124
-#define P_RESET4_LEVEL          CBUS_REG_ADDR(RESET4_LEVEL)
-#define RESET5_LEVEL 0x1125
-#define P_RESET5_LEVEL          CBUS_REG_ADDR(RESET5_LEVEL)
-#define RESET6_LEVEL 0x1126
-#define P_RESET6_LEVEL          CBUS_REG_ADDR(RESET6_LEVEL)
-#define RESET7_LEVEL 0x1127
-#define P_RESET7_LEVEL          CBUS_REG_ADDR(RESET7_LEVEL)
-/**/
-#define SCR_HIU 0x100b
-#define P_SCR_HIU               CBUS_REG_ADDR(SCR_HIU)
-#define HPG_TIMER 0x100f
-#define P_HPG_TIMER             CBUS_REG_ADDR(HPG_TIMER)
-/*add from M8M2*/
-#define HHI_GP_PLL_CNTL 0x1010
-#define P_HHI_GP_PLL_CNTL               CBUS_REG_ADDR(HHI_GP_PLL_CNTL)
-#define HHI_GP_PLL_CNTL2 0x1011
-#define P_HHI_GP_PLL_CNTL2              CBUS_REG_ADDR(HHI_GP_PLL_CNTL2)
-#define HHI_GP_PLL_CNTL3 0x1012
-#define P_HHI_GP_PLL_CNTL3              CBUS_REG_ADDR(HHI_GP_PLL_CNTL3)
-#define HHI_GP_PLL_CNTL4 0x1013
-#define P_HHI_GP_PLL_CNTL4              CBUS_REG_ADDR(HHI_GP_PLL_CNTL4)
-#define HHI_GP_PLL_CNTL5 0x1014
-#define P_HHI_GP_PLL_CNTL5              CBUS_REG_ADDR(HHI_GP_PLL_CNTL5)
-/**/
-
-#define HHI_DADC_CNTL				0x1027
-#define P_HHI_DADC_CNTL             CBUS_REG_ADDR(HHI_DADC_CNTL)
-#define HHI_DADC_CNTL2				0x1028
-#define P_HHI_DADC_CNTL2             CBUS_REG_ADDR(HHI_DADC_CNTL2)
-#define HHI_DADC_RDBK0_I			0x1029
-#define P_HHI_DADC_RDBK0_I             CBUS_REG_ADDR(HHI_DADC_RDBK0_I)
-#define HHI_DADC_CNTL3				0x102a
-#define P_HHI_DADC_CNTL3             CBUS_REG_ADDR(HHI_DADC_CNTL3)
-#define HHI_DADC_CNTL4				0x102b
-#define P_HHI_DADC_CNTL4             CBUS_REG_ADDR(HHI_DADC_CNTL4)
-
-
-#define HARM_ASB_MB0 0x1030
-#define P_HARM_ASB_MB0          CBUS_REG_ADDR(HARM_ASB_MB0)
-#define HARM_ASB_MB1 0x1031
-#define P_HARM_ASB_MB1          CBUS_REG_ADDR(HARM_ASB_MB1)
-#define HARM_ASB_MB2 0x1032
-#define P_HARM_ASB_MB2          CBUS_REG_ADDR(HARM_ASB_MB2)
-#define HARM_ASB_MB3 0x1033
-#define P_HARM_ASB_MB3          CBUS_REG_ADDR(HARM_ASB_MB3)
-#define HASB_ARM_MB0 0x1034
-#define P_HASB_ARM_MB0          CBUS_REG_ADDR(HASB_ARM_MB0)
-#define HASB_ARM_MB1 0x1035
-#define P_HASB_ARM_MB1          CBUS_REG_ADDR(HASB_ARM_MB1)
-#define HASB_ARM_MB2 0x1036
-#define P_HASB_ARM_MB2          CBUS_REG_ADDR(HASB_ARM_MB2)
-#define HASB_ARM_MB3 0x1037
-#define P_HASB_ARM_MB3          CBUS_REG_ADDR(HASB_ARM_MB3)
-#define HHI_TIMER90K 0x103b
-#define P_HHI_TIMER90K          CBUS_REG_ADDR(HHI_TIMER90K)
-#define HHI_MEM_PD_REG0 0x1040
-#define P_HHI_MEM_PD_REG0               CBUS_REG_ADDR(HHI_MEM_PD_REG0)
-#define HHI_VPU_MEM_PD_REG0 0x1041
-#define P_HHI_VPU_MEM_PD_REG0           CBUS_REG_ADDR(HHI_VPU_MEM_PD_REG0)
-#define HHI_VPU_MEM_PD_REG1 0x1042
-#define P_HHI_VPU_MEM_PD_REG1           CBUS_REG_ADDR(HHI_VPU_MEM_PD_REG1)
-#define HHI_AUD_DAC_CTRL 0x1044
-#define P_HHI_AUD_DAC_CTRL              CBUS_REG_ADDR(HHI_AUD_DAC_CTRL)
-#define HHI_VIID_CLK_DIV 0x104a
-#define P_HHI_VIID_CLK_DIV              CBUS_REG_ADDR(HHI_VIID_CLK_DIV)
-#define HHI_VIID_CLK_CNTL 0x104b
-#define P_HHI_VIID_CLK_CNTL             CBUS_REG_ADDR(HHI_VIID_CLK_CNTL)
-#define HHI_VIID_DIVIDER_CNTL 0x104c
-#define P_HHI_VIID_DIVIDER_CNTL         \
-	CBUS_REG_ADDR(HHI_VIID_DIVIDER_CNTL)
-#define HHI_GCLK_MPEG0 0x1050
-#define P_HHI_GCLK_MPEG0                CBUS_REG_ADDR(HHI_GCLK_MPEG0)
-#define HHI_GCLK_MPEG1 0x1051
-#define P_HHI_GCLK_MPEG1                CBUS_REG_ADDR(HHI_GCLK_MPEG1)
-#define HHI_GCLK_MPEG2 0x1052
-#define P_HHI_GCLK_MPEG2                CBUS_REG_ADDR(HHI_GCLK_MPEG2)
-#define HHI_GCLK_OTHER 0x1054
-#define P_HHI_GCLK_OTHER                CBUS_REG_ADDR(HHI_GCLK_OTHER)
-#define HHI_GCLK_AO 0x1055
-#define P_HHI_GCLK_AO           CBUS_REG_ADDR(HHI_GCLK_AO)
-#define HHI_SYS_CPU_CLK_CNTL1 0x1057
-#define P_HHI_SYS_CPU_CLK_CNTL1         \
-	CBUS_REG_ADDR(HHI_SYS_CPU_CLK_CNTL1)
-#define HHI_VID_CLK_DIV 0x1059
-#define P_HHI_VID_CLK_DIV               CBUS_REG_ADDR(HHI_VID_CLK_DIV)
-#define HHI_MPEG_CLK_CNTL 0x105d
-#define P_HHI_MPEG_CLK_CNTL             CBUS_REG_ADDR(HHI_MPEG_CLK_CNTL)
-#define HHI_AUD_CLK_CNTL 0x105e
-#define P_HHI_AUD_CLK_CNTL              CBUS_REG_ADDR(HHI_AUD_CLK_CNTL)
-#define HHI_VID_CLK_CNTL 0x105f
-#define P_HHI_VID_CLK_CNTL              CBUS_REG_ADDR(HHI_VID_CLK_CNTL)
-#define HHI_WIFI_CLK_CNTL 0x1060
-#define P_HHI_WIFI_CLK_CNTL             CBUS_REG_ADDR(HHI_WIFI_CLK_CNTL)
-#define HHI_WIFI_PLL_CNTL 0x1061
-#define P_HHI_WIFI_PLL_CNTL             CBUS_REG_ADDR(HHI_WIFI_PLL_CNTL)
-#define HHI_WIFI_PLL_CNTL2 0x1062
-#define P_HHI_WIFI_PLL_CNTL2            CBUS_REG_ADDR(HHI_WIFI_PLL_CNTL2)
-#define HHI_WIFI_PLL_CNTL3 0x1063
-#define P_HHI_WIFI_PLL_CNTL3            CBUS_REG_ADDR(HHI_WIFI_PLL_CNTL3)
-#define HHI_AUD_CLK_CNTL2 0x1064
-#define P_HHI_AUD_CLK_CNTL2             CBUS_REG_ADDR(HHI_AUD_CLK_CNTL2)
-/*add from M8m2*/
-#define HHI_VID_CLK_CNTL2 0x1065
-#define P_HHI_VID_CLK_CNTL2             CBUS_REG_ADDR(HHI_VID_CLK_CNTL2)
-/**/
-#define HHI_VID_DIVIDER_CNTL 0x1066
-#define P_HHI_VID_DIVIDER_CNTL          CBUS_REG_ADDR(HHI_VID_DIVIDER_CNTL)
-#define HHI_SYS_CPU_CLK_CNTL 0x1067
-#define P_HHI_SYS_CPU_CLK_CNTL          CBUS_REG_ADDR(HHI_SYS_CPU_CLK_CNTL)
-#define HHI_MALI_CLK_CNTL 0x106c
-#define P_HHI_MALI_CLK_CNTL             CBUS_REG_ADDR(HHI_MALI_CLK_CNTL)
-#define HHI_MIPI_PHY_CLK_CNTL 0x106e
-#define P_HHI_MIPI_PHY_CLK_CNTL         \
-	CBUS_REG_ADDR(HHI_MIPI_PHY_CLK_CNTL)
-#define HHI_VPU_CLK_CNTL 0x106f
-#define P_HHI_VPU_CLK_CNTL              CBUS_REG_ADDR(HHI_VPU_CLK_CNTL)
-#define HHI_OTHER_PLL_CNTL 0x1070
-#define P_HHI_OTHER_PLL_CNTL            CBUS_REG_ADDR(HHI_OTHER_PLL_CNTL)
-#define HHI_OTHER_PLL_CNTL2 0x1071
-#define P_HHI_OTHER_PLL_CNTL2           CBUS_REG_ADDR(HHI_OTHER_PLL_CNTL2)
-#define HHI_OTHER_PLL_CNTL3 0x1072
-#define P_HHI_OTHER_PLL_CNTL3           CBUS_REG_ADDR(HHI_OTHER_PLL_CNTL3)
-#define HHI_HDMI_CLK_CNTL 0x1073
-#define P_HHI_HDMI_CLK_CNTL             CBUS_REG_ADDR(HHI_HDMI_CLK_CNTL)
-#define HHI_DEMOD_CLK_CNTL 0x1074
-#define P_HHI_DEMOD_CLK_CNTL            CBUS_REG_ADDR(HHI_DEMOD_CLK_CNTL)
-#define HHI_SATA_CLK_CNTL 0x1075
-#define P_HHI_SATA_CLK_CNTL             CBUS_REG_ADDR(HHI_SATA_CLK_CNTL)
-#define HHI_ETH_CLK_CNTL 0x1076
-#define P_HHI_ETH_CLK_CNTL              CBUS_REG_ADDR(HHI_ETH_CLK_CNTL)
-#define HHI_CLK_DOUBLE_CNTL 0x1077
-#define P_HHI_CLK_DOUBLE_CNTL           CBUS_REG_ADDR(HHI_CLK_DOUBLE_CNTL)
-#define HHI_VDEC_CLK_CNTL 0x1078
-#define P_HHI_VDEC_CLK_CNTL             CBUS_REG_ADDR(HHI_VDEC_CLK_CNTL)
-#define HHI_VDEC2_CLK_CNTL 0x1079
-#define P_HHI_VDEC2_CLK_CNTL            CBUS_REG_ADDR(HHI_VDEC2_CLK_CNTL)
-/*add from M8M2*/
-#define HHI_VDEC3_CLK_CNTL 0x107a
-#define P_HHI_VDEC3_CLK_CNTL            CBUS_REG_ADDR(HHI_VDEC3_CLK_CNTL)
-#define HHI_VDEC4_CLK_CNTL 0x107b
-#define P_HHI_VDEC4_CLK_CNTL            CBUS_REG_ADDR(HHI_VDEC4_CLK_CNTL)
-/**/
-#define HHI_HDMI_PLL_CNTL 0x107c
-#define P_HHI_HDMI_PLL_CNTL             CBUS_REG_ADDR(HHI_HDMI_PLL_CNTL)
-#define HHI_HDMI_PLL_CNTL1 0x107d
-#define P_HHI_HDMI_PLL_CNTL1            CBUS_REG_ADDR(HHI_HDMI_PLL_CNTL1)
-#define HHI_HDMI_PLL_CNTL2 0x107e
-#define P_HHI_HDMI_PLL_CNTL2            CBUS_REG_ADDR(HHI_HDMI_PLL_CNTL2)
-#define HHI_HDMI_AFC_CNTL 0x107f
-#define P_HHI_HDMI_AFC_CNTL             CBUS_REG_ADDR(HHI_HDMI_AFC_CNTL)
-#define HHI_HDMIRX_CLK_CNTL 0x1080
-#define P_HHI_HDMIRX_CLK_CNTL           CBUS_REG_ADDR(HHI_HDMIRX_CLK_CNTL)
-#define HHI_HDMIRX_AUD_CLK_CNTL 0x1081
-#define P_HHI_HDMIRX_AUD_CLK_CNTL       \
-	CBUS_REG_ADDR(HHI_HDMIRX_AUD_CLK_CNTL)
-/*M8 M8M2 diff*/
-#define HHI_EDP_APB_CLK_CNTL_M8M2 0x1082
-#define HHI_EDP_APB_CLK_CNTL 0x107b
-#define P_HHI_EDP_APB_CLK_CNTL          CBUS_REG_ADDR(HHI_EDP_APB_CLK_CNTL)
-#define P_HHI_EDP_APB_CLK_CNTL_M8M2     \
-	CBUS_REG_ADDR(HHI_EDP_APB_CLK_CNTL_M8M2)
-/**/
-#define HHI_VID_PLL_MOD_CNTL0 0x1084
-#define P_HHI_VID_PLL_MOD_CNTL0         \
-	CBUS_REG_ADDR(HHI_VID_PLL_MOD_CNTL0)
-#define HHI_VID_PLL_MOD_LOW_TCNT 0x1085
-#define P_HHI_VID_PLL_MOD_LOW_TCNT      \
-	CBUS_REG_ADDR(HHI_VID_PLL_MOD_LOW_TCNT)
-#define HHI_VID_PLL_MOD_HIGH_TCNT 0x1086
-#define P_HHI_VID_PLL_MOD_HIGH_TCNT     \
-	CBUS_REG_ADDR(HHI_VID_PLL_MOD_HIGH_TCNT)
-#define HHI_VID_PLL_MOD_NOM_TCNT 0x1087
-#define P_HHI_VID_PLL_MOD_NOM_TCNT      \
-	CBUS_REG_ADDR(HHI_VID_PLL_MOD_NOM_TCNT)
-#define HHI_USB_CLK_CNTL 0x1089
-#define P_HHI_USB_CLK_CNTL              CBUS_REG_ADDR(HHI_USB_CLK_CNTL)
-#define HHI_GEN_CLK_CNTL 0x108a
-#define P_HHI_GEN_CLK_CNTL              CBUS_REG_ADDR(HHI_GEN_CLK_CNTL)
-#define HHI_GEN_CLK_CNTL2 0x108b
-#define P_HHI_GEN_CLK_CNTL2             CBUS_REG_ADDR(HHI_GEN_CLK_CNTL2)
-#define HHI_JTAG_CONFIG 0x108e
-#define P_HHI_JTAG_CONFIG               CBUS_REG_ADDR(HHI_JTAG_CONFIG)
-#define HHI_VAFE_CLKXTALIN_CNTL 0x108f
-#define P_HHI_VAFE_CLKXTALIN_CNTL       \
-	CBUS_REG_ADDR(HHI_VAFE_CLKXTALIN_CNTL)
-#define HHI_VAFE_CLKOSCIN_CNTL 0x1090
-#define P_HHI_VAFE_CLKOSCIN_CNTL        \
-	CBUS_REG_ADDR(HHI_VAFE_CLKOSCIN_CNTL)
-#define HHI_VAFE_CLKIN_CNTL 0x1091
-#define P_HHI_VAFE_CLKIN_CNTL           CBUS_REG_ADDR(HHI_VAFE_CLKIN_CNTL)
-#define HHI_TVFE_AUTOMODE_CLK_CNTL 0x1092
-#define P_HHI_TVFE_AUTOMODE_CLK_CNTL            \
-	CBUS_REG_ADDR(HHI_TVFE_AUTOMODE_CLK_CNTL)
-#define HHI_VAFE_CLKPI_CNTL 0x1093
-#define P_HHI_VAFE_CLKPI_CNTL           CBUS_REG_ADDR(HHI_VAFE_CLKPI_CNTL)
-#define HHI_VDIN_MEAS_CLK_CNTL 0x1094
-#define HHI_PCM2_CLK_CNTL 0x1095
-#define P_HHI_PCM2_CLK_CNTL             CBUS_REG_ADDR(HHI_PCM2_CLK_CNTL)
-#define HHI_PCM_CLK_CNTL 0x1096
-#define P_HHI_PCM_CLK_CNTL              CBUS_REG_ADDR(HHI_PCM_CLK_CNTL)
-#define HHI_NAND_CLK_CNTL 0x1097
-#define P_HHI_NAND_CLK_CNTL             CBUS_REG_ADDR(HHI_NAND_CLK_CNTL)
-#define HHI_ISP_LED_CLK_CNTL 0x1098
-#define P_HHI_ISP_LED_CLK_CNTL          CBUS_REG_ADDR(HHI_ISP_LED_CLK_CNTL)
-#define HHI_EDP_TX_PHY_CNTL0 0x109c
-#define P_HHI_EDP_TX_PHY_CNTL0          CBUS_REG_ADDR(HHI_EDP_TX_PHY_CNTL0)
-#define HHI_EDP_TX_PHY_CNTL1 0x109d
-#define P_HHI_EDP_TX_PHY_CNTL1          CBUS_REG_ADDR(HHI_EDP_TX_PHY_CNTL1)
-#define HHI_MPLL_CNTL 0x10a0
-#define P_HHI_MPLL_CNTL                 CBUS_REG_ADDR(HHI_MPLL_CNTL)
-#define HHI_MPLL_CNTL2 0x10a1
-#define P_HHI_MPLL_CNTL2                CBUS_REG_ADDR(HHI_MPLL_CNTL2)
-#define HHI_MPLL_CNTL3 0x10a2
-#define P_HHI_MPLL_CNTL3                CBUS_REG_ADDR(HHI_MPLL_CNTL3)
-#define HHI_MPLL_CNTL4 0x10a3
-#define P_HHI_MPLL_CNTL4                CBUS_REG_ADDR(HHI_MPLL_CNTL4)
-#define HHI_MPLL_CNTL5 0x10a4
-#define P_HHI_MPLL_CNTL5                CBUS_REG_ADDR(HHI_MPLL_CNTL5)
-#define HHI_MPLL_CNTL6 0x10a5
-#define P_HHI_MPLL_CNTL6                CBUS_REG_ADDR(HHI_MPLL_CNTL6)
-#define HHI_MPLL_CNTL7 0x10a6
-#define P_HHI_MPLL_CNTL7                CBUS_REG_ADDR(HHI_MPLL_CNTL7)
-#define HHI_MPLL_CNTL8 0x10a7
-#define P_HHI_MPLL_CNTL8                CBUS_REG_ADDR(HHI_MPLL_CNTL8)
-#define HHI_MPLL_CNTL9 0x10a8
-#define P_HHI_MPLL_CNTL9                CBUS_REG_ADDR(HHI_MPLL_CNTL9)
-#define HHI_MPLL_CNTL10 0x10a9
-#define P_HHI_MPLL_CNTL10               CBUS_REG_ADDR(HHI_MPLL_CNTL10)
-
-
-#define HHI_ADC_PLL_CNTL			0x10aa
-#define P_HHI_ADC_PLL_CNTL			CBUS_REG_ADDR(HHI_ADC_PLL_CNTL)
-#define HHI_ADC_PLL_CNTL2			0x10ab
-#define P_HHI_ADC_PLL_CNTL2			CBUS_REG_ADDR(HHI_ADC_PLL_CNTL2)
-#define HHI_ADC_PLL_CNTL3			0x10ac
-#define P_HHI_ADC_PLL_CNTL3			CBUS_REG_ADDR(HHI_ADC_PLL_CNTL3)
-#define HHI_ADC_PLL_CNTL4			0x10ad
-#define P_HHI_ADC_PLL_CNTL4			CBUS_REG_ADDR(HHI_ADC_PLL_CNTL4)
-#define HHI_ADC_PLL_CNTL5			0x109e
-#define P_HHI_ADC_PLL_CNTL5			CBUS_REG_ADDR(HHI_ADC_PLL_CNTL5)
-#define HHI_ADC_PLL_CNTL6			0x109f
-#define P_HHI_ADC_PLL_CNTL6			CBUS_REG_ADDR(HHI_ADC_PLL_CNTL6)
-#define HHI_ADC_PLL_CNTL1			0x10af
-#define P_HHI_ADC_PLL_CNTL1			CBUS_REG_ADDR(HHI_ADC_PLL_CNTL1)
-
-
-#define HHI_AUDCLK_PLL_CNTL 0x10b0
-#define P_HHI_AUDCLK_PLL_CNTL           CBUS_REG_ADDR(HHI_AUDCLK_PLL_CNTL)
-#define HHI_AUDCLK_PLL_CNTL2 0x10b1
-#define P_HHI_AUDCLK_PLL_CNTL2          CBUS_REG_ADDR(HHI_AUDCLK_PLL_CNTL2)
-#define HHI_AUDCLK_PLL_CNTL3 0x10b2
-#define P_HHI_AUDCLK_PLL_CNTL3          CBUS_REG_ADDR(HHI_AUDCLK_PLL_CNTL3)
-#define HHI_AUDCLK_PLL_CNTL4 0x10b3
-#define P_HHI_AUDCLK_PLL_CNTL4          CBUS_REG_ADDR(HHI_AUDCLK_PLL_CNTL4)
-#define HHI_AUDCLK_PLL_CNTL5 0x10b4
-#define P_HHI_AUDCLK_PLL_CNTL5          CBUS_REG_ADDR(HHI_AUDCLK_PLL_CNTL5)
-#define HHI_AUDCLK_PLL_CNTL6 0x10b5
-#define P_HHI_AUDCLK_PLL_CNTL6          CBUS_REG_ADDR(HHI_AUDCLK_PLL_CNTL6)
-#define HHI_L2_DDR_CLK_CNTL 0x10b6
-#define P_HHI_L2_DDR_CLK_CNTL           CBUS_REG_ADDR(HHI_L2_DDR_CLK_CNTL)
-#define HHI_VDAC_CNTL0 0x10bd
-#define P_HHI_VDAC_CNTL0                CBUS_REG_ADDR(HHI_VDAC_CNTL0)
-#define HHI_VDAC_CNTL1 0x10be
-#define P_HHI_VDAC_CNTL1                CBUS_REG_ADDR(HHI_VDAC_CNTL1)
-#define HHI_SYS_PLL_CNTL 0x10c0
-#define P_HHI_SYS_PLL_CNTL              CBUS_REG_ADDR(HHI_SYS_PLL_CNTL)
-#define HHI_SYS_PLL_CNTL2 0x10c1
-#define P_HHI_SYS_PLL_CNTL2             CBUS_REG_ADDR(HHI_SYS_PLL_CNTL2)
-#define HHI_SYS_PLL_CNTL3 0x10c2
-#define P_HHI_SYS_PLL_CNTL3             CBUS_REG_ADDR(HHI_SYS_PLL_CNTL3)
-#define HHI_SYS_PLL_CNTL4 0x10c3
-#define P_HHI_SYS_PLL_CNTL4             CBUS_REG_ADDR(HHI_SYS_PLL_CNTL4)
-#define HHI_SYS_PLL_CNTL5 0x10c4
-#define P_HHI_SYS_PLL_CNTL5             CBUS_REG_ADDR(HHI_SYS_PLL_CNTL5)
-#define HHI_DPLL_TOP_0 0x10c6
-#define P_HHI_DPLL_TOP_0                CBUS_REG_ADDR(HHI_DPLL_TOP_0)
-#define HHI_DPLL_TOP_1 0x10c7
-#define P_HHI_DPLL_TOP_1                CBUS_REG_ADDR(HHI_DPLL_TOP_1)
-#define HHI_VID_PLL_CNTL 0x10c8
-#define P_HHI_VID_PLL_CNTL              CBUS_REG_ADDR(HHI_VID_PLL_CNTL)
-#define HHI_VID_PLL_CNTL2 0x10c9
-#define P_HHI_VID_PLL_CNTL2             CBUS_REG_ADDR(HHI_VID_PLL_CNTL2)
-#define HHI_VID_PLL_CNTL3 0x10ca
-#define P_HHI_VID_PLL_CNTL3             CBUS_REG_ADDR(HHI_VID_PLL_CNTL3)
-#define HHI_VID_PLL_CNTL4 0x10cb
-#define P_HHI_VID_PLL_CNTL4             CBUS_REG_ADDR(HHI_VID_PLL_CNTL4)
-#define HHI_VID_PLL_CNTL5 0x10cc
-#define P_HHI_VID_PLL_CNTL5             CBUS_REG_ADDR(HHI_VID_PLL_CNTL5)
-#define HHI_VID_PLL_CNTL6 0x10cd
-#define P_HHI_VID_PLL_CNTL6             CBUS_REG_ADDR(HHI_VID_PLL_CNTL6)
-#define HHI_CSI_PHY_CNTL0 0x10d3
-#define P_HHI_CSI_PHY_CNTL0             CBUS_REG_ADDR(HHI_CSI_PHY_CNTL0)
-#define HHI_CSI_PHY_CNTL1 0x10d4
-#define P_HHI_CSI_PHY_CNTL1             CBUS_REG_ADDR(HHI_CSI_PHY_CNTL1)
-#define HHI_CSI_PHY_CNTL2 0x10d5
-#define P_HHI_CSI_PHY_CNTL2             CBUS_REG_ADDR(HHI_CSI_PHY_CNTL2)
-#define HHI_CSI_PHY_CNTL3 0x10d6
-#define P_HHI_CSI_PHY_CNTL3             CBUS_REG_ADDR(HHI_CSI_PHY_CNTL3)
-#define HHI_CSI_PHY_CNTL4 0x10d7
-#define P_HHI_CSI_PHY_CNTL4             CBUS_REG_ADDR(HHI_CSI_PHY_CNTL4)
-#define HHI_DIF_CSI_PHY_CNTL0 0x10d8
-#define P_HHI_DIF_CSI_PHY_CNTL0         \
-	CBUS_REG_ADDR(HHI_DIF_CSI_PHY_CNTL0)
-#define HHI_DIF_CSI_PHY_CNTL1 0x10d9
-#define P_HHI_DIF_CSI_PHY_CNTL1         \
-	CBUS_REG_ADDR(HHI_DIF_CSI_PHY_CNTL1)
-#define HHI_DIF_CSI_PHY_CNTL2 0x10da
-#define P_HHI_DIF_CSI_PHY_CNTL2         \
-	CBUS_REG_ADDR(HHI_DIF_CSI_PHY_CNTL2)
-#define HHI_DIF_CSI_PHY_CNTL3 0x10db
-#define P_HHI_DIF_CSI_PHY_CNTL3         \
-	CBUS_REG_ADDR(HHI_DIF_CSI_PHY_CNTL3)
-#define HHI_DIF_CSI_PHY_CNTL4 0x10dc
-#define P_HHI_DIF_CSI_PHY_CNTL4         \
-	CBUS_REG_ADDR(HHI_DIF_CSI_PHY_CNTL4)
-#define HHI_DIF_CSI_PHY_CNTL5 0x10dd
-#define P_HHI_DIF_CSI_PHY_CNTL5         \
-	CBUS_REG_ADDR(HHI_DIF_CSI_PHY_CNTL5)
-#define HHI_LVDS_TX_PHY_CNTL0 0x10de
-#define P_HHI_LVDS_TX_PHY_CNTL0         \
-	CBUS_REG_ADDR(HHI_LVDS_TX_PHY_CNTL0)
-#define HHI_LVDS_TX_PHY_CNTL1 0x10df
-#define P_HHI_LVDS_TX_PHY_CNTL1         \
-	CBUS_REG_ADDR(HHI_LVDS_TX_PHY_CNTL1)
-#define HHI_VID2_PLL_CNTL 0x10e0
-#define P_HHI_VID2_PLL_CNTL             CBUS_REG_ADDR(HHI_VID2_PLL_CNTL)
-#define HHI_VID2_PLL_CNTL2 0x10e1
-#define P_HHI_VID2_PLL_CNTL2            CBUS_REG_ADDR(HHI_VID2_PLL_CNTL2)
-#define HHI_VID2_PLL_CNTL3 0x10e2
-#define P_HHI_VID2_PLL_CNTL3            CBUS_REG_ADDR(HHI_VID2_PLL_CNTL3)
-#define HHI_VID2_PLL_CNTL4 0x10e3
-#define P_HHI_VID2_PLL_CNTL4            CBUS_REG_ADDR(HHI_VID2_PLL_CNTL4)
-#define HHI_VID2_PLL_CNTL5 0x10e4
-#define P_HHI_VID2_PLL_CNTL5            CBUS_REG_ADDR(HHI_VID2_PLL_CNTL5)
-#define HHI_VID2_PLL_CNTL6 0x10e5
-#define P_HHI_VID2_PLL_CNTL6            CBUS_REG_ADDR(HHI_VID2_PLL_CNTL6)
-#define HHI_HDMI_PHY_CNTL0 0x10e8
-#define P_HHI_HDMI_PHY_CNTL0            CBUS_REG_ADDR(HHI_HDMI_PHY_CNTL0)
-#define HHI_HDMI_PHY_CNTL1 0x10e9
-#define P_HHI_HDMI_PHY_CNTL1            CBUS_REG_ADDR(HHI_HDMI_PHY_CNTL1)
-#define HHI_HDMI_PHY_CNTL2 0x10ea
-#define P_HHI_HDMI_PHY_CNTL2            CBUS_REG_ADDR(HHI_HDMI_PHY_CNTL2)
-#define PARSER_CONTROL 0x2960
-#define P_PARSER_CONTROL                CBUS_REG_ADDR(PARSER_CONTROL)
-#define PARSER_FETCH_ADDR 0x2961
-#define P_PARSER_FETCH_ADDR             CBUS_REG_ADDR(PARSER_FETCH_ADDR)
-#define PARSER_FETCH_CMD 0x2962
-#define P_PARSER_FETCH_CMD              CBUS_REG_ADDR(PARSER_FETCH_CMD)
-#define PARSER_FETCH_LEVEL 0x2964
-#define P_PARSER_FETCH_LEVEL            CBUS_REG_ADDR(PARSER_FETCH_LEVEL)
-#define PARSER_CONFIG 0x2965
-#define P_PARSER_CONFIG                 CBUS_REG_ADDR(PARSER_CONFIG)
-#define PFIFO_WR_PTR 0x2966
-#define P_PFIFO_WR_PTR          CBUS_REG_ADDR(PFIFO_WR_PTR)
-#define PFIFO_RD_PTR 0x2967
-#define P_PFIFO_RD_PTR          CBUS_REG_ADDR(PFIFO_RD_PTR)
-#define PFIFO_DATA 0x2968
-#define P_PFIFO_DATA            CBUS_REG_ADDR(PFIFO_DATA)
-#define PARSER_SEARCH_PATTERN 0x2969
-#define P_PARSER_SEARCH_PATTERN         \
-	CBUS_REG_ADDR(PARSER_SEARCH_PATTERN)
-#define PARSER_SEARCH_MASK 0x296a
-#define P_PARSER_SEARCH_MASK            CBUS_REG_ADDR(PARSER_SEARCH_MASK)
-#define PARSER_INT_ENABLE 0x296b
-#define P_PARSER_INT_ENABLE             CBUS_REG_ADDR(PARSER_INT_ENABLE)
-#define PARSER_INT_STATUS 0x296c
-#define P_PARSER_INT_STATUS             CBUS_REG_ADDR(PARSER_INT_STATUS)
-#define PARSER_SCR_CTL 0x296d
-#define P_PARSER_SCR_CTL                CBUS_REG_ADDR(PARSER_SCR_CTL)
-#define PARSER_SCR 0x296e
-#define P_PARSER_SCR            CBUS_REG_ADDR(PARSER_SCR)
-#define PARSER_PARAMETER 0x296f
-#define P_PARSER_PARAMETER              CBUS_REG_ADDR(PARSER_PARAMETER)
-#define PARSER_INSERT_DATA 0x2970
-#define P_PARSER_INSERT_DATA            CBUS_REG_ADDR(PARSER_INSERT_DATA)
-#define VAS_STREAM_ID 0x2971
-#define P_VAS_STREAM_ID                 CBUS_REG_ADDR(VAS_STREAM_ID)
-#define VIDEO_DTS 0x2972
-#define P_VIDEO_DTS             CBUS_REG_ADDR(VIDEO_DTS)
-#define VIDEO_PTS 0x2973
-#define P_VIDEO_PTS             CBUS_REG_ADDR(VIDEO_PTS)
-#define VIDEO_PTS_DTS_WR_PTR 0x2974
-#define P_VIDEO_PTS_DTS_WR_PTR          CBUS_REG_ADDR(VIDEO_PTS_DTS_WR_PTR)
-#define AUDIO_PTS 0x2975
-#define P_AUDIO_PTS             CBUS_REG_ADDR(AUDIO_PTS)
-#define AUDIO_PTS_WR_PTR 0x2976
-#define P_AUDIO_PTS_WR_PTR              CBUS_REG_ADDR(AUDIO_PTS_WR_PTR)
-#define PARSER_ES_CONTROL 0x2977
-#define P_PARSER_ES_CONTROL             CBUS_REG_ADDR(PARSER_ES_CONTROL)
-#define PFIFO_MONITOR 0x2978
-#define P_PFIFO_MONITOR                 CBUS_REG_ADDR(PFIFO_MONITOR)
-#define PARSER_VIDEO_START_PTR 0x2980
-#define P_PARSER_VIDEO_START_PTR        \
-	CBUS_REG_ADDR(PARSER_VIDEO_START_PTR)
-#define PARSER_VIDEO_END_PTR 0x2981
-#define P_PARSER_VIDEO_END_PTR          CBUS_REG_ADDR(PARSER_VIDEO_END_PTR)
-#define PARSER_VIDEO_WP 0x2982
-#define P_PARSER_VIDEO_WP               CBUS_REG_ADDR(PARSER_VIDEO_WP)
-#define PARSER_VIDEO_RP 0x2983
-#define P_PARSER_VIDEO_RP               CBUS_REG_ADDR(PARSER_VIDEO_RP)
-#define PARSER_VIDEO_HOLE 0x2984
-#define P_PARSER_VIDEO_HOLE             CBUS_REG_ADDR(PARSER_VIDEO_HOLE)
-#define PARSER_AUDIO_START_PTR 0x2985
-#define P_PARSER_AUDIO_START_PTR        \
-	CBUS_REG_ADDR(PARSER_AUDIO_START_PTR)
-#define PARSER_AUDIO_END_PTR 0x2986
-#define P_PARSER_AUDIO_END_PTR          CBUS_REG_ADDR(PARSER_AUDIO_END_PTR)
-#define PARSER_AUDIO_WP 0x2987
-#define P_PARSER_AUDIO_WP               CBUS_REG_ADDR(PARSER_AUDIO_WP)
-#define PARSER_AUDIO_RP 0x2988
-#define P_PARSER_AUDIO_RP               CBUS_REG_ADDR(PARSER_AUDIO_RP)
-#define PARSER_AUDIO_HOLE 0x2989
-#define P_PARSER_AUDIO_HOLE             CBUS_REG_ADDR(PARSER_AUDIO_HOLE)
-#define PARSER_SUB_START_PTR 0x298a
-#define P_PARSER_SUB_START_PTR          CBUS_REG_ADDR(PARSER_SUB_START_PTR)
-#define PARSER_SUB_END_PTR 0x298b
-#define P_PARSER_SUB_END_PTR            CBUS_REG_ADDR(PARSER_SUB_END_PTR)
-#define PARSER_SUB_WP 0x298c
-#define P_PARSER_SUB_WP                 CBUS_REG_ADDR(PARSER_SUB_WP)
-#define PARSER_SUB_RP 0x298d
-#define P_PARSER_SUB_RP                 CBUS_REG_ADDR(PARSER_SUB_RP)
-#define PARSER_SUB_HOLE 0x298e
-#define P_PARSER_SUB_HOLE               CBUS_REG_ADDR(PARSER_SUB_HOLE)
-#define PARSER_FETCH_INFO 0x298f
-#define P_PARSER_FETCH_INFO             CBUS_REG_ADDR(PARSER_FETCH_INFO)
-#define PARSER_STATUS 0x2990
-#define P_PARSER_STATUS                 CBUS_REG_ADDR(PARSER_STATUS)
-#define PARSER_AV_WRAP_COUNT 0x2991
-#define P_PARSER_AV_WRAP_COUNT          CBUS_REG_ADDR(PARSER_AV_WRAP_COUNT)
-#define WRRSP_PARSER 0x2992
-#define P_WRRSP_PARSER          CBUS_REG_ADDR(WRRSP_PARSER)
-#define PARSER_VIDEO2_START_PTR 0x2993
-#define P_PARSER_VIDEO2_START_PTR       \
-	CBUS_REG_ADDR(PARSER_VIDEO2_START_PTR)
-#define PARSER_VIDEO2_END_PTR 0x2994
-#define P_PARSER_VIDEO2_END_PTR         \
-	CBUS_REG_ADDR(PARSER_VIDEO2_END_PTR)
-#define PARSER_VIDEO2_WP 0x2995
-#define P_PARSER_VIDEO2_WP              CBUS_REG_ADDR(PARSER_VIDEO2_WP)
-#define PARSER_VIDEO2_RP 0x2996
-#define P_PARSER_VIDEO2_RP              CBUS_REG_ADDR(PARSER_VIDEO2_RP)
-#define PARSER_VIDEO2_HOLE 0x2997
-#define P_PARSER_VIDEO2_HOLE            CBUS_REG_ADDR(PARSER_VIDEO2_HOLE)
-#define PARSER_AV2_WRAP_COUNT 0x2998
-#define P_PARSER_AV2_WRAP_COUNT         \
-	CBUS_REG_ADDR(PARSER_AV2_WRAP_COUNT)
-#define DVIN_FRONT_END_CTRL 0x12e0
-#define P_DVIN_FRONT_END_CTRL           CBUS_REG_ADDR(DVIN_FRONT_END_CTRL)
-#define DVIN_HS_LEAD_VS_ODD 0x12e1
-#define P_DVIN_HS_LEAD_VS_ODD           CBUS_REG_ADDR(DVIN_HS_LEAD_VS_ODD)
-#define DVIN_ACTIVE_START_PIX 0x12e2
-#define P_DVIN_ACTIVE_START_PIX         \
-	CBUS_REG_ADDR(DVIN_ACTIVE_START_PIX)
-#define DVIN_ACTIVE_START_LINE 0x12e3
-#define P_DVIN_ACTIVE_START_LINE        \
-	CBUS_REG_ADDR(DVIN_ACTIVE_START_LINE)
-#define DVIN_DISPLAY_SIZE 0x12e4
-#define P_DVIN_DISPLAY_SIZE             CBUS_REG_ADDR(DVIN_DISPLAY_SIZE)
-#define DVIN_CTRL_STAT 0x12e5
-#define P_DVIN_CTRL_STAT                CBUS_REG_ADDR(DVIN_CTRL_STAT)
-#define AIU_958_BPF 0x1500
-#define P_AIU_958_BPF           CBUS_REG_ADDR(AIU_958_BPF)
-#define AIU_958_BRST 0x1501
-#define P_AIU_958_BRST          CBUS_REG_ADDR(AIU_958_BRST)
-#define AIU_958_LENGTH 0x1502
-#define P_AIU_958_LENGTH                CBUS_REG_ADDR(AIU_958_LENGTH)
-#define AIU_958_PADDSIZE 0x1503
-#define P_AIU_958_PADDSIZE              CBUS_REG_ADDR(AIU_958_PADDSIZE)
-#define AIU_958_MISC 0x1504
-#define P_AIU_958_MISC          CBUS_REG_ADDR(AIU_958_MISC)
-#define AIU_958_FORCE_LEFT 0x1505
-#define P_AIU_958_FORCE_LEFT            CBUS_REG_ADDR(AIU_958_FORCE_LEFT)
-#define AIU_958_DISCARD_NUM 0x1506
-#define P_AIU_958_DISCARD_NUM           CBUS_REG_ADDR(AIU_958_DISCARD_NUM)
-#define AIU_958_DCU_FF_CTRL 0x1507
-#define P_AIU_958_DCU_FF_CTRL           CBUS_REG_ADDR(AIU_958_DCU_FF_CTRL)
-#define AIU_958_CHSTAT_L0 0x1508
-#define P_AIU_958_CHSTAT_L0             CBUS_REG_ADDR(AIU_958_CHSTAT_L0)
-#define AIU_958_CHSTAT_L1 0x1509
-#define P_AIU_958_CHSTAT_L1             CBUS_REG_ADDR(AIU_958_CHSTAT_L1)
-#define AIU_958_CTRL 0x150a
-#define P_AIU_958_CTRL          CBUS_REG_ADDR(AIU_958_CTRL)
-#define AIU_958_RPT 0x150b
-#define P_AIU_958_RPT           CBUS_REG_ADDR(AIU_958_RPT)
-#define AIU_I2S_MUTE_SWAP 0x150c
-#define P_AIU_I2S_MUTE_SWAP             CBUS_REG_ADDR(AIU_I2S_MUTE_SWAP)
-#define AIU_I2S_SOURCE_DESC 0x150d
-#define P_AIU_I2S_SOURCE_DESC           CBUS_REG_ADDR(AIU_I2S_SOURCE_DESC)
-#define AIU_I2S_MED_CTRL 0x150e
-#define P_AIU_I2S_MED_CTRL              CBUS_REG_ADDR(AIU_I2S_MED_CTRL)
-#define AIU_I2S_MED_THRESH 0x150f
-#define P_AIU_I2S_MED_THRESH            CBUS_REG_ADDR(AIU_I2S_MED_THRESH)
-#define AIU_I2S_DAC_CFG 0x1510
-#define P_AIU_I2S_DAC_CFG               CBUS_REG_ADDR(AIU_I2S_DAC_CFG)
-#define AIU_I2S_SYNC 0x1511
-#define P_AIU_I2S_SYNC          CBUS_REG_ADDR(AIU_I2S_SYNC)
-#define AIU_I2S_MISC 0x1512
-#define P_AIU_I2S_MISC          CBUS_REG_ADDR(AIU_I2S_MISC)
-#define AIU_I2S_OUT_CFG 0x1513
-#define P_AIU_I2S_OUT_CFG               CBUS_REG_ADDR(AIU_I2S_OUT_CFG)
-#define AIU_I2S_FF_CTRL 0x1514
-#define P_AIU_I2S_FF_CTRL               CBUS_REG_ADDR(AIU_I2S_FF_CTRL)
-#define AIU_RST_SOFT 0x1515
-#define P_AIU_RST_SOFT          CBUS_REG_ADDR(AIU_RST_SOFT)
-#define AIU_CLK_CTRL 0x1516
-#define P_AIU_CLK_CTRL          CBUS_REG_ADDR(AIU_CLK_CTRL)
-#define AIU_MIX_ADCCFG 0x1517
-#define P_AIU_MIX_ADCCFG                CBUS_REG_ADDR(AIU_MIX_ADCCFG)
-#define AIU_MIX_CTRL 0x1518
-#define P_AIU_MIX_CTRL          CBUS_REG_ADDR(AIU_MIX_CTRL)
-#define AIU_CLK_CTRL_MORE 0x1519
-#define P_AIU_CLK_CTRL_MORE             CBUS_REG_ADDR(AIU_CLK_CTRL_MORE)
-#define AIU_958_POP 0x151a
-#define P_AIU_958_POP           CBUS_REG_ADDR(AIU_958_POP)
-#define AIU_MIX_GAIN 0x151b
-#define P_AIU_MIX_GAIN          CBUS_REG_ADDR(AIU_MIX_GAIN)
-#define AIU_958_SYNWORD1 0x151c
-#define P_AIU_958_SYNWORD1              CBUS_REG_ADDR(AIU_958_SYNWORD1)
-#define AIU_958_SYNWORD2 0x151d
-#define P_AIU_958_SYNWORD2              CBUS_REG_ADDR(AIU_958_SYNWORD2)
-#define AIU_958_SYNWORD3 0x151e
-#define P_AIU_958_SYNWORD3              CBUS_REG_ADDR(AIU_958_SYNWORD3)
-#define AIU_958_SYNWORD1_MASK 0x151f
-#define P_AIU_958_SYNWORD1_MASK         \
-	CBUS_REG_ADDR(AIU_958_SYNWORD1_MASK)
-#define AIU_958_SYNWORD2_MASK 0x1520
-#define P_AIU_958_SYNWORD2_MASK         \
-	CBUS_REG_ADDR(AIU_958_SYNWORD2_MASK)
-#define AIU_958_SYNWORD3_MASK 0x1521
-#define P_AIU_958_SYNWORD3_MASK         \
-	CBUS_REG_ADDR(AIU_958_SYNWORD3_MASK)
-#define AIU_958_FFRDOUT_THD 0x1522
-#define P_AIU_958_FFRDOUT_THD           CBUS_REG_ADDR(AIU_958_FFRDOUT_THD)
-#define AIU_958_LENGTH_PER_PAUSE 0x1523
-#define P_AIU_958_LENGTH_PER_PAUSE      \
-	CBUS_REG_ADDR(AIU_958_LENGTH_PER_PAUSE)
-#define AIU_958_PAUSE_NUM 0x1524
-#define P_AIU_958_PAUSE_NUM             CBUS_REG_ADDR(AIU_958_PAUSE_NUM)
-#define AIU_958_PAUSE_PAYLOAD 0x1525
-#define P_AIU_958_PAUSE_PAYLOAD         \
-	CBUS_REG_ADDR(AIU_958_PAUSE_PAYLOAD)
-#define AIU_958_AUTO_PAUSE 0x1526
-#define P_AIU_958_AUTO_PAUSE            CBUS_REG_ADDR(AIU_958_AUTO_PAUSE)
-#define AIU_958_PAUSE_PD_LENGTH 0x1527
-#define P_AIU_958_PAUSE_PD_LENGTH       \
-	CBUS_REG_ADDR(AIU_958_PAUSE_PD_LENGTH)
-#define AIU_CODEC_DAC_LRCLK_CTRL 0x1528
-#define P_AIU_CODEC_DAC_LRCLK_CTRL      \
-	CBUS_REG_ADDR(AIU_CODEC_DAC_LRCLK_CTRL)
-#define AIU_CODEC_ADC_LRCLK_CTRL 0x1529
-#define P_AIU_CODEC_ADC_LRCLK_CTRL      \
-	CBUS_REG_ADDR(AIU_CODEC_ADC_LRCLK_CTRL)
-#define AIU_CODEC_CLK_DATA_CTRL 0x152b
-#define P_AIU_CODEC_CLK_DATA_CTRL       \
-	CBUS_REG_ADDR(AIU_CODEC_CLK_DATA_CTRL)
-#define AIU_958_CHSTAT_R0 0x1530
-#define P_AIU_958_CHSTAT_R0             CBUS_REG_ADDR(AIU_958_CHSTAT_R0)
-#define AIU_958_CHSTAT_R1 0x1531
-#define P_AIU_958_CHSTAT_R1             CBUS_REG_ADDR(AIU_958_CHSTAT_R1)
-#define AIU_958_VALID_CTRL 0x1532
-#define P_AIU_958_VALID_CTRL            CBUS_REG_ADDR(AIU_958_VALID_CTRL)
-#define AIU_AUDIO_AMP_REG0 0x153c
-#define P_AIU_AUDIO_AMP_REG0            CBUS_REG_ADDR(AIU_AUDIO_AMP_REG0)
-#define AIU_AUDIO_AMP_REG1 0x153d
-#define P_AIU_AUDIO_AMP_REG1            CBUS_REG_ADDR(AIU_AUDIO_AMP_REG1)
-#define AIU_AUDIO_AMP_REG2 0x153e
-#define P_AIU_AUDIO_AMP_REG2            CBUS_REG_ADDR(AIU_AUDIO_AMP_REG2)
-#define AIU_AUDIO_AMP_REG3 0x153f
-#define P_AIU_AUDIO_AMP_REG3            CBUS_REG_ADDR(AIU_AUDIO_AMP_REG3)
-#define AIU_AIFIFO2_CTRL 0x1540
-#define P_AIU_AIFIFO2_CTRL              CBUS_REG_ADDR(AIU_AIFIFO2_CTRL)
-#define AIU_AIFIFO2_STATUS 0x1541
-#define P_AIU_AIFIFO2_STATUS            CBUS_REG_ADDR(AIU_AIFIFO2_STATUS)
-#define AIU_AIFIFO2_GBIT 0x1542
-#define P_AIU_AIFIFO2_GBIT              CBUS_REG_ADDR(AIU_AIFIFO2_GBIT)
-#define AIU_AIFIFO2_CLB 0x1543
-#define P_AIU_AIFIFO2_CLB               CBUS_REG_ADDR(AIU_AIFIFO2_CLB)
-#define AIU_CRC_CTRL 0x1544
-#define P_AIU_CRC_CTRL          CBUS_REG_ADDR(AIU_CRC_CTRL)
-#define AIU_CRC_STATUS 0x1545
-#define P_AIU_CRC_STATUS                CBUS_REG_ADDR(AIU_CRC_STATUS)
-#define AIU_CRC_SHIFT_REG 0x1546
-#define P_AIU_CRC_SHIFT_REG             CBUS_REG_ADDR(AIU_CRC_SHIFT_REG)
-#define AIU_CRC_IREG 0x1547
-#define P_AIU_CRC_IREG          CBUS_REG_ADDR(AIU_CRC_IREG)
-#define AIU_CRC_CAL_REG1 0x1548
-#define P_AIU_CRC_CAL_REG1              CBUS_REG_ADDR(AIU_CRC_CAL_REG1)
-#define AIU_CRC_CAL_REG0 0x1549
-#define P_AIU_CRC_CAL_REG0              CBUS_REG_ADDR(AIU_CRC_CAL_REG0)
-#define AIU_CRC_POLY_COEF1 0x154a
-#define P_AIU_CRC_POLY_COEF1            CBUS_REG_ADDR(AIU_CRC_POLY_COEF1)
-#define AIU_CRC_POLY_COEF0 0x154b
-#define P_AIU_CRC_POLY_COEF0            CBUS_REG_ADDR(AIU_CRC_POLY_COEF0)
-#define AIU_CRC_BIT_SIZE1 0x154c
-#define P_AIU_CRC_BIT_SIZE1             CBUS_REG_ADDR(AIU_CRC_BIT_SIZE1)
-#define AIU_CRC_BIT_SIZE0 0x154d
-#define P_AIU_CRC_BIT_SIZE0             CBUS_REG_ADDR(AIU_CRC_BIT_SIZE0)
-#define AIU_CRC_BIT_CNT1 0x154e
-#define P_AIU_CRC_BIT_CNT1              CBUS_REG_ADDR(AIU_CRC_BIT_CNT1)
-#define AIU_CRC_BIT_CNT0 0x154f
-#define P_AIU_CRC_BIT_CNT0              CBUS_REG_ADDR(AIU_CRC_BIT_CNT0)
-#define AIU_AMCLK_GATE_HI 0x1550
-#define P_AIU_AMCLK_GATE_HI             CBUS_REG_ADDR(AIU_AMCLK_GATE_HI)
-#define AIU_AMCLK_GATE_LO 0x1551
-#define P_AIU_AMCLK_GATE_LO             CBUS_REG_ADDR(AIU_AMCLK_GATE_LO)
-#define AIU_AMCLK_MSR 0x1552
-#define P_AIU_AMCLK_MSR                 CBUS_REG_ADDR(AIU_AMCLK_MSR)
-#define AIU_AUDAC_CTRL0 0x1553
-#define P_AIU_AUDAC_CTRL0               CBUS_REG_ADDR(AIU_AUDAC_CTRL0)
-#define AIU_DELTA_SIGMA0 0x1555
-#define P_AIU_DELTA_SIGMA0              CBUS_REG_ADDR(AIU_DELTA_SIGMA0)
-#define AIU_DELTA_SIGMA1 0x1556
-#define P_AIU_DELTA_SIGMA1              CBUS_REG_ADDR(AIU_DELTA_SIGMA1)
-#define AIU_DELTA_SIGMA2 0x1557
-#define P_AIU_DELTA_SIGMA2              CBUS_REG_ADDR(AIU_DELTA_SIGMA2)
-#define AIU_DELTA_SIGMA3 0x1558
-#define P_AIU_DELTA_SIGMA3              CBUS_REG_ADDR(AIU_DELTA_SIGMA3)
-#define AIU_DELTA_SIGMA4 0x1559
-#define P_AIU_DELTA_SIGMA4              CBUS_REG_ADDR(AIU_DELTA_SIGMA4)
-#define AIU_DELTA_SIGMA5 0x155a
-#define P_AIU_DELTA_SIGMA5              CBUS_REG_ADDR(AIU_DELTA_SIGMA5)
-#define AIU_DELTA_SIGMA6 0x155b
-#define P_AIU_DELTA_SIGMA6              CBUS_REG_ADDR(AIU_DELTA_SIGMA6)
-#define AIU_DELTA_SIGMA7 0x155c
-#define P_AIU_DELTA_SIGMA7              CBUS_REG_ADDR(AIU_DELTA_SIGMA7)
-#define AIU_DELTA_SIGMA_LCNTS 0x155d
-#define P_AIU_DELTA_SIGMA_LCNTS         \
-	CBUS_REG_ADDR(AIU_DELTA_SIGMA_LCNTS)
-#define AIU_DELTA_SIGMA_RCNTS 0x155e
-#define P_AIU_DELTA_SIGMA_RCNTS         \
-	CBUS_REG_ADDR(AIU_DELTA_SIGMA_RCNTS)
-#define AIU_MEM_I2S_START_PTR 0x1560
-#define P_AIU_MEM_I2S_START_PTR         \
-	CBUS_REG_ADDR(AIU_MEM_I2S_START_PTR)
-#define AIU_MEM_I2S_RD_PTR 0x1561
-#define P_AIU_MEM_I2S_RD_PTR            CBUS_REG_ADDR(AIU_MEM_I2S_RD_PTR)
-#define AIU_MEM_I2S_END_PTR 0x1562
-#define P_AIU_MEM_I2S_END_PTR           CBUS_REG_ADDR(AIU_MEM_I2S_END_PTR)
-#define AIU_MEM_I2S_MASKS 0x1563
-#define P_AIU_MEM_I2S_MASKS             CBUS_REG_ADDR(AIU_MEM_I2S_MASKS)
-#define AIU_MEM_I2S_CONTROL 0x1564
-#define P_AIU_MEM_I2S_CONTROL           CBUS_REG_ADDR(AIU_MEM_I2S_CONTROL)
-#define AIU_MEM_IEC958_START_PTR 0x1565
-#define P_AIU_MEM_IEC958_START_PTR      \
-	CBUS_REG_ADDR(AIU_MEM_IEC958_START_PTR)
-#define AIU_MEM_IEC958_RD_PTR 0x1566
-#define P_AIU_MEM_IEC958_RD_PTR         \
-	CBUS_REG_ADDR(AIU_MEM_IEC958_RD_PTR)
-#define AIU_MEM_IEC958_END_PTR 0x1567
-#define AIU_MEM_AIFIFO2_START_PTR 0x156a
-#define P_AIU_MEM_AIFIFO2_START_PTR     \
-	CBUS_REG_ADDR(AIU_MEM_AIFIFO2_START_PTR)
-#define AIU_MEM_AIFIFO2_CURR_PTR 0x156b
-#define P_AIU_MEM_AIFIFO2_CURR_PTR      \
-	CBUS_REG_ADDR(AIU_MEM_AIFIFO2_CURR_PTR)
-#define AIU_MEM_AIFIFO2_BYTES_AVAIL 0x156d
-#define P_AIU_MEM_AIFIFO2_BYTES_AVAIL           \
-	CBUS_REG_ADDR(AIU_MEM_AIFIFO2_BYTES_AVAIL)
-#define AIU_MEM_AIFIFO2_CONTROL 0x156e
-#define P_AIU_MEM_AIFIFO2_CONTROL               \
-	CBUS_REG_ADDR(AIU_MEM_AIFIFO2_CONTROL)
-#define AIU_MEM_AIFIFO2_LEVEL 0x1571
-#define P_AIU_MEM_AIFIFO2_LEVEL                 \
-	CBUS_REG_ADDR(AIU_MEM_AIFIFO2_LEVEL)
-#define AIU_MEM_AIFIFO2_BUF_CNTL 0x1572
-#define P_AIU_MEM_AIFIFO2_BUF_CNTL              \
-	CBUS_REG_ADDR(AIU_MEM_AIFIFO2_BUF_CNTL)
-#define AIU_MEM_I2S_MAN_WP 0x1573
-#define P_AIU_MEM_I2S_MAN_WP            CBUS_REG_ADDR(AIU_MEM_I2S_MAN_WP)
-#define AIU_MEM_I2S_MAN_RP 0x1574
-#define P_AIU_MEM_I2S_MAN_RP            CBUS_REG_ADDR(AIU_MEM_I2S_MAN_RP)
-#define AIU_MEM_I2S_LEVEL 0x1575
-#define P_AIU_MEM_I2S_LEVEL             CBUS_REG_ADDR(AIU_MEM_I2S_LEVEL)
-#define AIU_MEM_I2S_BUF_CNTL 0x1576
-#define P_AIU_MEM_I2S_BUF_CNTL          CBUS_REG_ADDR(AIU_MEM_I2S_BUF_CNTL)
-#define AIU_MEM_I2S_BUF_WRAP_COUNT 0x1577
-#define P_AIU_MEM_I2S_BUF_WRAP_COUNT            \
-	CBUS_REG_ADDR(AIU_MEM_I2S_BUF_WRAP_COUNT)
-#define AIU_MEM_I2S_MEM_CTL 0x1578
-#define P_AIU_MEM_I2S_MEM_CTL           CBUS_REG_ADDR(AIU_MEM_I2S_MEM_CTL)
-#define AIU_MEM_IEC958_WRAP_COUNT 0x157a
-#define P_AIU_MEM_IEC958_WRAP_COUNT             \
-	CBUS_REG_ADDR(AIU_MEM_IEC958_WRAP_COUNT)
-#define AIU_MEM_IEC958_IRQ_LEVEL 0x157b
-#define P_AIU_MEM_IEC958_IRQ_LEVEL              \
-	CBUS_REG_ADDR(AIU_MEM_IEC958_IRQ_LEVEL)
-#define AIU_MEM_IEC958_MAN_WP 0x157c
-#define P_AIU_MEM_IEC958_MAN_WP                 \
-	CBUS_REG_ADDR(AIU_MEM_IEC958_MAN_WP)
-#define AIU_MEM_IEC958_MAN_RP 0x157d
-#define P_AIU_MEM_IEC958_MAN_RP                 \
-	CBUS_REG_ADDR(AIU_MEM_IEC958_MAN_RP)
-#define AIU_MEM_IEC958_LEVEL 0x157e
-#define P_AIU_MEM_IEC958_LEVEL          \
-	CBUS_REG_ADDR(AIU_MEM_IEC958_LEVEL)
-#define AIU_AIFIFO_CTRL 0x1580
-#define P_AIU_AIFIFO_CTRL               CBUS_REG_ADDR(AIU_AIFIFO_CTRL)
-#define AIU_AIFIFO_STATUS 0x1581
-#define P_AIU_AIFIFO_STATUS             CBUS_REG_ADDR(AIU_AIFIFO_STATUS)
-#define AIU_AIFIFO_GBIT 0x1582
-#define P_AIU_AIFIFO_GBIT               CBUS_REG_ADDR(AIU_AIFIFO_GBIT)
-#define AIU_AIFIFO_CLB 0x1583
-#define P_AIU_AIFIFO_CLB                CBUS_REG_ADDR(AIU_AIFIFO_CLB)
-#define AIU_MEM_AIFIFO_START_PTR 0x1584
-#define P_AIU_MEM_AIFIFO_START_PTR              \
-	CBUS_REG_ADDR(AIU_MEM_AIFIFO_START_PTR)
-#define AIU_MEM_AIFIFO_BYTES_AVAIL 0x1587
-#define P_AIU_MEM_AIFIFO_BYTES_AVAIL            \
-	CBUS_REG_ADDR(AIU_MEM_AIFIFO_BYTES_AVAIL)
-#define AIU_MEM_AIFIFO_MAN_WP 0x1589
-#define P_AIU_MEM_AIFIFO_MAN_WP                 \
-	CBUS_REG_ADDR(AIU_MEM_AIFIFO_MAN_WP)
-#define AIU_MEM_AIFIFO_MAN_RP 0x158a
-#define P_AIU_MEM_AIFIFO_MAN_RP                 \
-	CBUS_REG_ADDR(AIU_MEM_AIFIFO_MAN_RP)
-#define AIU_MEM_AIFIFO_BUF_WRAP_COUNT 0x158d
-#define P_AIU_MEM_AIFIFO_BUF_WRAP_COUNT                 \
-	CBUS_REG_ADDR(AIU_MEM_AIFIFO_BUF_WRAP_COUNT)
-#define AIU_MEM_AIFIFO2_BUF_WRAP_COUNT 0x158e
-#define P_AIU_MEM_AIFIFO2_BUF_WRAP_COUNT                \
-	CBUS_REG_ADDR(AIU_MEM_AIFIFO2_BUF_WRAP_COUNT)
-#define AIFIFO_TIME_STAMP_SYNC_0 0x1591
-#define P_AIFIFO_TIME_STAMP_SYNC_0              \
-	CBUS_REG_ADDR(AIFIFO_TIME_STAMP_SYNC_0)
-#define AIFIFO_TIME_STAMP_SYNC_1 0x1592
-#define P_AIFIFO_TIME_STAMP_SYNC_1              \
-	CBUS_REG_ADDR(AIFIFO_TIME_STAMP_SYNC_1)
-#define AIFIFO_TIME_STAMP_0 0x1593
-#define P_AIFIFO_TIME_STAMP_0           CBUS_REG_ADDR(AIFIFO_TIME_STAMP_0)
-#define AIFIFO_TIME_STAMP_1 0x1594
-#define P_AIFIFO_TIME_STAMP_1           CBUS_REG_ADDR(AIFIFO_TIME_STAMP_1)
-#define AIFIFO_TIME_STAMP_2 0x1595
-#define P_AIFIFO_TIME_STAMP_2           CBUS_REG_ADDR(AIFIFO_TIME_STAMP_2)
-#define AIFIFO_TIME_STAMP_3 0x1596
-#define P_AIFIFO_TIME_STAMP_3           CBUS_REG_ADDR(AIFIFO_TIME_STAMP_3)
-#define AIFIFO_TIME_STAMP_LENGTH 0x1597
-#define P_AIFIFO_TIME_STAMP_LENGTH              \
-	CBUS_REG_ADDR(AIFIFO_TIME_STAMP_LENGTH)
-#define AIFIFO2_TIME_STAMP_CNTL 0x1598
-#define P_AIFIFO2_TIME_STAMP_CNTL       \
-	CBUS_REG_ADDR(AIFIFO2_TIME_STAMP_CNTL)
-#define AIFIFO2_TIME_STAMP_SYNC_0 0x1599
-#define P_AIFIFO2_TIME_STAMP_SYNC_0             \
-	CBUS_REG_ADDR(AIFIFO2_TIME_STAMP_SYNC_0)
-#define AIFIFO2_TIME_STAMP_SYNC_1 0x159a
-#define P_AIFIFO2_TIME_STAMP_SYNC_1             \
-	CBUS_REG_ADDR(AIFIFO2_TIME_STAMP_SYNC_1)
-#define AIFIFO2_TIME_STAMP_0 0x159b
-#define P_AIFIFO2_TIME_STAMP_0          CBUS_REG_ADDR(AIFIFO2_TIME_STAMP_0)
-#define AIFIFO2_TIME_STAMP_1 0x159c
-#define P_AIFIFO2_TIME_STAMP_1          CBUS_REG_ADDR(AIFIFO2_TIME_STAMP_1)
-#define AIFIFO2_TIME_STAMP_2 0x159d
-#define P_AIFIFO2_TIME_STAMP_2          CBUS_REG_ADDR(AIFIFO2_TIME_STAMP_2)
-#define AIFIFO2_TIME_STAMP_3 0x159e
-#define P_AIFIFO2_TIME_STAMP_3          CBUS_REG_ADDR(AIFIFO2_TIME_STAMP_3)
-#define AIFIFO2_TIME_STAMP_LENGTH 0x159f
-#define P_AIFIFO2_TIME_STAMP_LENGTH             \
-	CBUS_REG_ADDR(AIFIFO2_TIME_STAMP_LENGTH)
-#define IEC958_TIME_STAMP_SYNC_0 0x15a1
-#define P_IEC958_TIME_STAMP_SYNC_0              \
-	CBUS_REG_ADDR(IEC958_TIME_STAMP_SYNC_0)
-#define IEC958_TIME_STAMP_SYNC_1 0x15a2
-#define P_IEC958_TIME_STAMP_SYNC_1              \
-	CBUS_REG_ADDR(IEC958_TIME_STAMP_SYNC_1)
-#define IEC958_TIME_STAMP_0 0x15a3
-#define P_IEC958_TIME_STAMP_0           CBUS_REG_ADDR(IEC958_TIME_STAMP_0)
-#define IEC958_TIME_STAMP_1 0x15a4
-#define P_IEC958_TIME_STAMP_1           CBUS_REG_ADDR(IEC958_TIME_STAMP_1)
-#define IEC958_TIME_STAMP_2 0x15a5
-#define P_IEC958_TIME_STAMP_2           CBUS_REG_ADDR(IEC958_TIME_STAMP_2)
-#define IEC958_TIME_STAMP_3 0x15a6
-#define P_IEC958_TIME_STAMP_3           CBUS_REG_ADDR(IEC958_TIME_STAMP_3)
-#define IEC958_TIME_STAMP_LENGTH 0x15a7
-#define P_IEC958_TIME_STAMP_LENGTH              \
-	CBUS_REG_ADDR(IEC958_TIME_STAMP_LENGTH)
-#define AIU_MEM_AIFIFO2_MEM_CTL 0x15a8
-#define P_AIU_MEM_AIFIFO2_MEM_CTL               \
-	CBUS_REG_ADDR(AIU_MEM_AIFIFO2_MEM_CTL)
-#define AIU_I2S_CBUS_DDR_CNTL 0x15a9
-#define P_AIU_I2S_CBUS_DDR_CNTL                 \
-	CBUS_REG_ADDR(AIU_I2S_CBUS_DDR_CNTL)
-#define AIU_I2S_CBUS_DDR_WDATA 0x15aa
-#define P_AIU_I2S_CBUS_DDR_WDATA                \
-	CBUS_REG_ADDR(AIU_I2S_CBUS_DDR_WDATA)
-#define AIU_I2S_CBUS_DDR_ADDR 0x15ab
-#define P_AIU_I2S_CBUS_DDR_ADDR                 \
-	CBUS_REG_ADDR(AIU_I2S_CBUS_DDR_ADDR)
-#define GE2D_GEN_CTRL0 0x18a0
-#define P_GE2D_GEN_CTRL0                CBUS_REG_ADDR(GE2D_GEN_CTRL0)
-#define GE2D_GEN_CTRL1 0x18a1
-#define P_GE2D_GEN_CTRL1                CBUS_REG_ADDR(GE2D_GEN_CTRL1)
-#define GE2D_GEN_CTRL2 0x18a2
-#define P_GE2D_GEN_CTRL2                CBUS_REG_ADDR(GE2D_GEN_CTRL2)
-#define GE2D_CMD_CTRL 0x18a3
-#define P_GE2D_CMD_CTRL                 CBUS_REG_ADDR(GE2D_CMD_CTRL)
-#define GE2D_STATUS0 0x18a4
-#define P_GE2D_STATUS0          CBUS_REG_ADDR(GE2D_STATUS0)
-#define GE2D_STATUS1 0x18a5
-#define P_GE2D_STATUS1          CBUS_REG_ADDR(GE2D_STATUS1)
-#define GE2D_SRC1_DEF_COLOR 0x18a6
-#define P_GE2D_SRC1_DEF_COLOR           CBUS_REG_ADDR(GE2D_SRC1_DEF_COLOR)
-#define GE2D_SRC1_CLIPX_START_END 0x18a7
-#define P_GE2D_SRC1_CLIPX_START_END             \
-	CBUS_REG_ADDR(GE2D_SRC1_CLIPX_START_END)
-#define GE2D_SRC1_CLIPY_START_END 0x18a8
-#define P_GE2D_SRC1_CLIPY_START_END             \
-	CBUS_REG_ADDR(GE2D_SRC1_CLIPY_START_END)
-#define GE2D_SRC1_CANVAS 0x18a9
-#define P_GE2D_SRC1_CANVAS              CBUS_REG_ADDR(GE2D_SRC1_CANVAS)
-#define GE2D_SRC1_X_START_END 0x18aa
-#define P_GE2D_SRC1_X_START_END                 \
-	CBUS_REG_ADDR(GE2D_SRC1_X_START_END)
-#define GE2D_SRC1_Y_START_END 0x18ab
-#define P_GE2D_SRC1_Y_START_END                 \
-	CBUS_REG_ADDR(GE2D_SRC1_Y_START_END)
-#define GE2D_SRC1_LUT_ADDR 0x18ac
-#define P_GE2D_SRC1_LUT_ADDR            \
-	CBUS_REG_ADDR(GE2D_SRC1_LUT_ADDR)
-#define GE2D_SRC1_LUT_DAT 0x18ad
-#define P_GE2D_SRC1_LUT_DAT             \
-	CBUS_REG_ADDR(GE2D_SRC1_LUT_DAT)
-#define GE2D_SRC1_FMT_CTRL 0x18ae
-#define P_GE2D_SRC1_FMT_CTRL            \
-	CBUS_REG_ADDR(GE2D_SRC1_FMT_CTRL)
-#define GE2D_SRC2_DEF_COLOR 0x18af
-#define P_GE2D_SRC2_DEF_COLOR           CBUS_REG_ADDR(GE2D_SRC2_DEF_COLOR)
-#define GE2D_SRC2_CLIPX_START_END 0x18b0
-#define P_GE2D_SRC2_CLIPX_START_END             \
-	CBUS_REG_ADDR(GE2D_SRC2_CLIPX_START_END)
-#define GE2D_SRC2_CLIPY_START_END 0x18b1
-#define P_GE2D_SRC2_CLIPY_START_END             \
-	CBUS_REG_ADDR(GE2D_SRC2_CLIPY_START_END)
-#define GE2D_SRC2_X_START_END 0x18b2
-#define P_GE2D_SRC2_X_START_END                 \
-	CBUS_REG_ADDR(GE2D_SRC2_X_START_END)
-#define GE2D_SRC2_Y_START_END 0x18b3
-#define P_GE2D_SRC2_Y_START_END                 \
-	CBUS_REG_ADDR(GE2D_SRC2_Y_START_END)
-#define GE2D_DST_CLIPX_START_END 0x18b4
-#define P_GE2D_DST_CLIPX_START_END              \
-	CBUS_REG_ADDR(GE2D_DST_CLIPX_START_END)
-#define GE2D_DST_CLIPY_START_END 0x18b5
-#define P_GE2D_DST_CLIPY_START_END              \
-	CBUS_REG_ADDR(GE2D_DST_CLIPY_START_END)
-#define GE2D_DST_X_START_END 0x18b6
-#define P_GE2D_DST_X_START_END          CBUS_REG_ADDR(GE2D_DST_X_START_END)
-#define GE2D_DST_Y_START_END 0x18b7
-#define P_GE2D_DST_Y_START_END          CBUS_REG_ADDR(GE2D_DST_Y_START_END)
-#define GE2D_SRC2_DST_CANVAS 0x18b8
-#define P_GE2D_SRC2_DST_CANVAS          CBUS_REG_ADDR(GE2D_SRC2_DST_CANVAS)
-#define GE2D_VSC_PHASE_SLOPE 0x18ba
-#define P_GE2D_VSC_PHASE_SLOPE          CBUS_REG_ADDR(GE2D_VSC_PHASE_SLOPE)
-#define GE2D_VSC_INI_CTRL 0x18bb
-#define P_GE2D_VSC_INI_CTRL             CBUS_REG_ADDR(GE2D_VSC_INI_CTRL)
-#define GE2D_HSC_PHASE_SLOPE 0x18bd
-#define P_GE2D_HSC_PHASE_SLOPE          CBUS_REG_ADDR(GE2D_HSC_PHASE_SLOPE)
-#define GE2D_HSC_INI_CTRL 0x18be
-#define P_GE2D_HSC_INI_CTRL             CBUS_REG_ADDR(GE2D_HSC_INI_CTRL)
-#define GE2D_HSC_ADV_CTRL 0x18bf
-#define P_GE2D_HSC_ADV_CTRL             CBUS_REG_ADDR(GE2D_HSC_ADV_CTRL)
-#define GE2D_SC_MISC_CTRL 0x18c0
-#define P_GE2D_SC_MISC_CTRL             CBUS_REG_ADDR(GE2D_SC_MISC_CTRL)
-#define GE2D_VSC_NRND_POINT 0x18c1
-#define P_GE2D_VSC_NRND_POINT           CBUS_REG_ADDR(GE2D_VSC_NRND_POINT)
-#define GE2D_VSC_NRND_PHASE 0x18c2
-#define P_GE2D_VSC_NRND_PHASE           CBUS_REG_ADDR(GE2D_VSC_NRND_PHASE)
-#define GE2D_HSC_NRND_POINT 0x18c3
-#define P_GE2D_HSC_NRND_POINT           CBUS_REG_ADDR(GE2D_HSC_NRND_POINT)
-#define GE2D_HSC_NRND_PHASE 0x18c4
-#define P_GE2D_HSC_NRND_PHASE           CBUS_REG_ADDR(GE2D_HSC_NRND_PHASE)
-#define GE2D_MATRIX_COEF00_01 0x18c6
-#define P_GE2D_MATRIX_COEF00_01                 \
-	CBUS_REG_ADDR(GE2D_MATRIX_COEF00_01)
-#define GE2D_MATRIX_COEF02_10 0x18c7
-#define P_GE2D_MATRIX_COEF02_10                 \
-	CBUS_REG_ADDR(GE2D_MATRIX_COEF02_10)
-#define GE2D_MATRIX_COEF11_12 0x18c8
-#define P_GE2D_MATRIX_COEF11_12                 \
-	CBUS_REG_ADDR(GE2D_MATRIX_COEF11_12)
-#define GE2D_MATRIX_COEF20_21 0x18c9
-#define P_GE2D_MATRIX_COEF20_21                 \
-	CBUS_REG_ADDR(GE2D_MATRIX_COEF20_21)
-#define GE2D_MATRIX_COEF22_CTRL 0x18ca
-#define P_GE2D_MATRIX_COEF22_CTRL               \
-	CBUS_REG_ADDR(GE2D_MATRIX_COEF22_CTRL)
-#define GE2D_MATRIX_OFFSET 0x18cb
-#define P_GE2D_MATRIX_OFFSET            CBUS_REG_ADDR(GE2D_MATRIX_OFFSET)
-#define GE2D_ALU_OP_CTRL 0x18cc
-#define P_GE2D_ALU_OP_CTRL              CBUS_REG_ADDR(GE2D_ALU_OP_CTRL)
-#define GE2D_ALU_CONST_COLOR 0x18cd
-#define P_GE2D_ALU_CONST_COLOR          CBUS_REG_ADDR(GE2D_ALU_CONST_COLOR)
-#define GE2D_SRC1_KEY 0x18ce
-#define P_GE2D_SRC1_KEY                 CBUS_REG_ADDR(GE2D_SRC1_KEY)
-#define GE2D_SRC1_KEY_MASK 0x18cf
-#define P_GE2D_SRC1_KEY_MASK            CBUS_REG_ADDR(GE2D_SRC1_KEY_MASK)
-#define GE2D_SRC2_KEY 0x18d0
-#define P_GE2D_SRC2_KEY                 CBUS_REG_ADDR(GE2D_SRC2_KEY)
-#define GE2D_SRC2_KEY_MASK 0x18d1
-#define P_GE2D_SRC2_KEY_MASK            CBUS_REG_ADDR(GE2D_SRC2_KEY_MASK)
-#define GE2D_DST_BITMASK 0x18d2
-#define P_GE2D_DST_BITMASK              CBUS_REG_ADDR(GE2D_DST_BITMASK)
-#define GE2D_DP_ONOFF_CTRL 0x18d3
-#define P_GE2D_DP_ONOFF_CTRL            CBUS_REG_ADDR(GE2D_DP_ONOFF_CTRL)
-#define GE2D_SCALE_COEF_IDX 0x18d4
-#define P_GE2D_SCALE_COEF_IDX           CBUS_REG_ADDR(GE2D_SCALE_COEF_IDX)
-#define GE2D_SCALE_COEF 0x18d5
-#define P_GE2D_SCALE_COEF               CBUS_REG_ADDR(GE2D_SCALE_COEF)
-#define GE2D_ANTIFLICK_CTRL0 0x18d8
-#define P_GE2D_ANTIFLICK_CTRL0          CBUS_REG_ADDR(GE2D_ANTIFLICK_CTRL0)
-#define GE2D_ANTIFLICK_CTRL1 0x18d9
-#define P_GE2D_ANTIFLICK_CTRL1          CBUS_REG_ADDR(GE2D_ANTIFLICK_CTRL1)
-#define GE2D_ANTIFLICK_COLOR_FILT0 0x18da
-#define P_GE2D_ANTIFLICK_COLOR_FILT0            \
-	CBUS_REG_ADDR(GE2D_ANTIFLICK_COLOR_FILT0)
-#define GE2D_ANTIFLICK_COLOR_FILT1 0x18db
-#define P_GE2D_ANTIFLICK_COLOR_FILT1            \
-	CBUS_REG_ADDR(GE2D_ANTIFLICK_COLOR_FILT1)
-#define GE2D_ANTIFLICK_COLOR_FILT2 0x18dc
-#define P_GE2D_ANTIFLICK_COLOR_FILT2            \
-	CBUS_REG_ADDR(GE2D_ANTIFLICK_COLOR_FILT2)
-#define GE2D_ANTIFLICK_COLOR_FILT3 0x18dd
-#define P_GE2D_ANTIFLICK_COLOR_FILT3            \
-	CBUS_REG_ADDR(GE2D_ANTIFLICK_COLOR_FILT3)
-#define GE2D_ANTIFLICK_ALPHA_FILT0 0x18de
-#define P_GE2D_ANTIFLICK_ALPHA_FILT0            \
-	CBUS_REG_ADDR(GE2D_ANTIFLICK_ALPHA_FILT0)
-#define GE2D_ANTIFLICK_ALPHA_FILT1 0x18df
-#define P_GE2D_ANTIFLICK_ALPHA_FILT1            \
-	CBUS_REG_ADDR(GE2D_ANTIFLICK_ALPHA_FILT1)
-#define GE2D_ANTIFLICK_ALPHA_FILT2 0x18e0
-#define P_GE2D_ANTIFLICK_ALPHA_FILT2            \
-	CBUS_REG_ADDR(GE2D_ANTIFLICK_ALPHA_FILT2)
-#define GE2D_ANTIFLICK_ALPHA_FILT3 0x18e1
-#define P_GE2D_ANTIFLICK_ALPHA_FILT3            \
-	CBUS_REG_ADDR(GE2D_ANTIFLICK_ALPHA_FILT3)
-#define GE2D_SRC1_RANGE_MAP_Y_CTRL 0x18e3
-#define P_GE2D_SRC1_RANGE_MAP_Y_CTRL            \
-	CBUS_REG_ADDR(GE2D_SRC1_RANGE_MAP_Y_CTRL)
-#define GE2D_SRC1_RANGE_MAP_CB_CTRL 0x18e4
-#define P_GE2D_SRC1_RANGE_MAP_CB_CTRL           \
-	CBUS_REG_ADDR(GE2D_SRC1_RANGE_MAP_CB_CTRL)
-#define GE2D_SRC1_RANGE_MAP_CR_CTRL 0x18e5
-#define P_GE2D_SRC1_RANGE_MAP_CR_CTRL           \
-	CBUS_REG_ADDR(GE2D_SRC1_RANGE_MAP_CR_CTRL)
-#define GE2D_ARB_BURST_NUM 0x18e6
-#define P_GE2D_ARB_BURST_NUM            CBUS_REG_ADDR(GE2D_ARB_BURST_NUM)
-#define GE2D_TID_TOKEN 0x18e7
-#define P_GE2D_TID_TOKEN                CBUS_REG_ADDR(GE2D_TID_TOKEN)
-#define GE2D_GEN_CTRL3 0x18e8
-#define P_GE2D_GEN_CTRL3                CBUS_REG_ADDR(GE2D_GEN_CTRL3)
-#define GE2D_STATUS2 0x18e9
-#define P_GE2D_STATUS2          CBUS_REG_ADDR(GE2D_STATUS2)
-#define GE2D_GEN_CTRL4 0x18ea
-#define P_GE2D_GEN_CTRL4                CBUS_REG_ADDR(GE2D_GEN_CTRL4)
-#define AUDIO_COP_CTL2 0x1f01
-#define P_AUDIO_COP_CTL2                CBUS_REG_ADDR(AUDIO_COP_CTL2)
-#define OPERAND_M_CTL 0x1f02
-#define P_OPERAND_M_CTL                 CBUS_REG_ADDR(OPERAND_M_CTL)
-#define OPERAND1_ADDR 0x1f03
-#define P_OPERAND1_ADDR                 CBUS_REG_ADDR(OPERAND1_ADDR)
-#define OPERAND2_ADDR 0x1f04
-#define P_OPERAND2_ADDR                 CBUS_REG_ADDR(OPERAND2_ADDR)
-#define RESULT_M_CTL 0x1f05
-#define P_RESULT_M_CTL          CBUS_REG_ADDR(RESULT_M_CTL)
-#define RESULT1_ADDR 0x1f06
-#define P_RESULT1_ADDR          CBUS_REG_ADDR(RESULT1_ADDR)
-#define RESULT2_ADDR 0x1f07
-#define P_RESULT2_ADDR          CBUS_REG_ADDR(RESULT2_ADDR)
-#define ADD_SHFT_CTL 0x1f08
-#define P_ADD_SHFT_CTL          CBUS_REG_ADDR(ADD_SHFT_CTL)
-#define OPERAND_ONE_H 0x1f09
-#define P_OPERAND_ONE_H                 CBUS_REG_ADDR(OPERAND_ONE_H)
-#define OPERAND_ONE_L 0x1f0a
-#define P_OPERAND_ONE_L                 CBUS_REG_ADDR(OPERAND_ONE_L)
-#define OPERAND_TWO_H 0x1f0b
-#define P_OPERAND_TWO_H                 CBUS_REG_ADDR(OPERAND_TWO_H)
-#define OPERAND_TWO_L 0x1f0c
-#define P_OPERAND_TWO_L                 CBUS_REG_ADDR(OPERAND_TWO_L)
-#define RESULT_H 0x1f0d
-#define P_RESULT_H              CBUS_REG_ADDR(RESULT_H)
-#define RESULT_M 0x1f0e
-#define P_RESULT_M              CBUS_REG_ADDR(RESULT_M)
-#define RESULT_L 0x1f0f
-#define P_RESULT_L              CBUS_REG_ADDR(RESULT_L)
-#define WMEM_R_PTR 0x1f10
-#define P_WMEM_R_PTR            CBUS_REG_ADDR(WMEM_R_PTR)
-#define WMEM_W_PTR 0x1f11
-#define P_WMEM_W_PTR            CBUS_REG_ADDR(WMEM_W_PTR)
-#define AUDIO_LAYER 0x1f20
-#define P_AUDIO_LAYER           CBUS_REG_ADDR(AUDIO_LAYER)
-#define AC3_DECODING 0x1f21
-#define P_AC3_DECODING          CBUS_REG_ADDR(AC3_DECODING)
-#define AC3_DYNAMIC 0x1f22
-#define P_AC3_DYNAMIC           CBUS_REG_ADDR(AC3_DYNAMIC)
-#define AC3_MELODY 0x1f23
-#define P_AC3_MELODY            CBUS_REG_ADDR(AC3_MELODY)
-#define AC3_VOCAL 0x1f24
-#define P_AC3_VOCAL             CBUS_REG_ADDR(AC3_VOCAL)
-#define ASSIST_AMR_SCRATCH0 0x1f4f
-#define P_ASSIST_AMR_SCRATCH0           CBUS_REG_ADDR(ASSIST_AMR_SCRATCH0)
-#define ASSIST_AMR_SCRATCH1 0x1f50
-#define P_ASSIST_AMR_SCRATCH1           CBUS_REG_ADDR(ASSIST_AMR_SCRATCH1)
-#define ASSIST_AMR_SCRATCH2 0x1f51
-#define P_ASSIST_AMR_SCRATCH2           CBUS_REG_ADDR(ASSIST_AMR_SCRATCH2)
-#define ASSIST_AMR_SCRATCH3 0x1f52
-#define P_ASSIST_AMR_SCRATCH3           CBUS_REG_ADDR(ASSIST_AMR_SCRATCH3)
-#define ASSIST_HW_REV 0x1f53
-#define P_ASSIST_HW_REV                 CBUS_REG_ADDR(ASSIST_HW_REV)
-#define ASSIST_POR_CONFIG 0x1f55
-#define P_ASSIST_POR_CONFIG             CBUS_REG_ADDR(ASSIST_POR_CONFIG)
-#define ASSIST_SPARE16_REG1 0x1f56
-#define P_ASSIST_SPARE16_REG1           CBUS_REG_ADDR(ASSIST_SPARE16_REG1)
-#define ASSIST_SPARE16_REG2 0x1f57
-#define P_ASSIST_SPARE16_REG2           CBUS_REG_ADDR(ASSIST_SPARE16_REG2)
-#define ASSIST_SPARE8_REG1 0x1f58
-#define P_ASSIST_SPARE8_REG1            CBUS_REG_ADDR(ASSIST_SPARE8_REG1)
-#define ASSIST_SPARE8_REG2 0x1f59
-#define P_ASSIST_SPARE8_REG2            CBUS_REG_ADDR(ASSIST_SPARE8_REG2)
-#define ASSIST_SPARE8_REG3 0x1f5a
-#define P_ASSIST_SPARE8_REG3            CBUS_REG_ADDR(ASSIST_SPARE8_REG3)
-#define AC3_CTRL_REG1 0x1f5b
-#define P_AC3_CTRL_REG1                 CBUS_REG_ADDR(AC3_CTRL_REG1)
-#define AC3_CTRL_REG2 0x1f5c
-#define P_AC3_CTRL_REG2                 CBUS_REG_ADDR(AC3_CTRL_REG2)
-#define AC3_CTRL_REG3 0x1f5d
-#define P_AC3_CTRL_REG3                 CBUS_REG_ADDR(AC3_CTRL_REG3)
-#define AC3_CTRL_REG4 0x1f5e
-#define P_AC3_CTRL_REG4                 CBUS_REG_ADDR(AC3_CTRL_REG4)
-#define ASSIST_GEN_CNTL 0x1f68
-#define P_ASSIST_GEN_CNTL               CBUS_REG_ADDR(ASSIST_GEN_CNTL)
-#define EE_ASSIST_MBOX0_IRQ_REG 0x1f70
-
-#define EE_ASSIST_MBOX3_MASK 0x1f7e
-#define P_EE_ASSIST_MBOX3_MASK          CBUS_REG_ADDR(EE_ASSIST_MBOX3_MASK)
-#define AUDIN_SPDIF_MODE 0x2800
-#define P_AUDIN_SPDIF_MODE              CBUS_REG_ADDR(AUDIN_SPDIF_MODE)
-#define AUDIN_SPDIF_MISC 0x2804
-#define P_AUDIN_SPDIF_MISC              CBUS_REG_ADDR(AUDIN_SPDIF_MISC)
-#define AUDIN_SPDIF_END 0x280f
-#define P_AUDIN_SPDIF_END               CBUS_REG_ADDR(AUDIN_SPDIF_END)
-#define AUDIN_I2SIN_CTRL 0x2810
-#define P_AUDIN_I2SIN_CTRL              CBUS_REG_ADDR(AUDIN_I2SIN_CTRL)
-#define AUDIN_SOURCE_SEL 0x2811
-#define P_AUDIN_SOURCE_SEL              CBUS_REG_ADDR(AUDIN_SOURCE_SEL)
-#define AUDIN_DECODE_FORMAT 0x2812
-#define P_AUDIN_DECODE_FORMAT           CBUS_REG_ADDR(AUDIN_DECODE_FORMAT)
-#define AUDIN_DECODE_CONTROL_STATUS 0x2813
-#define P_AUDIN_DECODE_CONTROL_STATUS           \
-	CBUS_REG_ADDR(AUDIN_DECODE_CONTROL_STATUS)
-#define AUDIN_DECODE_CHANNEL_STATUS_A_0 0x2814
-#define P_AUDIN_DECODE_CHANNEL_STATUS_A_0               \
-	CBUS_REG_ADDR(AUDIN_DECODE_CHANNEL_STATUS_A_0)
-#define AUDIN_DECODE_CHANNEL_STATUS_A_1 0x2815
-#define P_AUDIN_DECODE_CHANNEL_STATUS_A_1               \
-	CBUS_REG_ADDR(AUDIN_DECODE_CHANNEL_STATUS_A_1)
-#define AUDIN_DECODE_CHANNEL_STATUS_A_2 0x2816
-#define P_AUDIN_DECODE_CHANNEL_STATUS_A_2               \
-	CBUS_REG_ADDR(AUDIN_DECODE_CHANNEL_STATUS_A_2)
-#define AUDIN_DECODE_CHANNEL_STATUS_A_3 0x2817
-#define P_AUDIN_DECODE_CHANNEL_STATUS_A_3               \
-	CBUS_REG_ADDR(AUDIN_DECODE_CHANNEL_STATUS_A_3)
-#define AUDIN_DECODE_CHANNEL_STATUS_A_4 0x2818
-#define P_AUDIN_DECODE_CHANNEL_STATUS_A_4               \
-	CBUS_REG_ADDR(AUDIN_DECODE_CHANNEL_STATUS_A_4)
-#define AUDIN_DECODE_CHANNEL_STATUS_A_5 0x2819
-#define P_AUDIN_DECODE_CHANNEL_STATUS_A_5               \
-	CBUS_REG_ADDR(AUDIN_DECODE_CHANNEL_STATUS_A_5)
-#define AUDIN_FIFO0_START 0x2820
-#define P_AUDIN_FIFO0_START             CBUS_REG_ADDR(AUDIN_FIFO0_START)
-#define AUDIN_FIFO0_END 0x2821
-#define P_AUDIN_FIFO0_END               CBUS_REG_ADDR(AUDIN_FIFO0_END)
-#define AUDIN_FIFO0_PTR 0x2822
-#define P_AUDIN_FIFO0_PTR               CBUS_REG_ADDR(AUDIN_FIFO0_PTR)
-#define AUDIN_FIFO0_INTR 0x2823
-#define P_AUDIN_FIFO0_INTR              CBUS_REG_ADDR(AUDIN_FIFO0_INTR)
-#define AUDIN_FIFO0_RDPTR 0x2824
-#define P_AUDIN_FIFO0_RDPTR             CBUS_REG_ADDR(AUDIN_FIFO0_RDPTR)
-#define AUDIN_FIFO0_CTRL 0x2825
-#define P_AUDIN_FIFO0_CTRL              CBUS_REG_ADDR(AUDIN_FIFO0_CTRL)
-#define AUDIN_FIFO0_CTRL1 0x2826
-#define P_AUDIN_FIFO0_CTRL1             CBUS_REG_ADDR(AUDIN_FIFO0_CTRL1)
-#define AUDIN_FIFO0_LVL0 0x2827
-#define P_AUDIN_FIFO0_LVL0              CBUS_REG_ADDR(AUDIN_FIFO0_LVL0)
-#define AUDIN_FIFO0_LVL1 0x2828
-#define P_AUDIN_FIFO0_LVL1              CBUS_REG_ADDR(AUDIN_FIFO0_LVL1)
-#define AUDIN_FIFO0_LVL2 0x2829
-#define P_AUDIN_FIFO0_LVL2              CBUS_REG_ADDR(AUDIN_FIFO0_LVL2)
-#define AUDIN_FIFO0_REQID 0x2830
-#define P_AUDIN_FIFO0_REQID             CBUS_REG_ADDR(AUDIN_FIFO0_REQID)
-#define AUDIN_FIFO0_WRAP 0x2831
-#define P_AUDIN_FIFO0_WRAP              CBUS_REG_ADDR(AUDIN_FIFO0_WRAP)
-#define AUDIN_FIFO1_START 0x2833
-#define P_AUDIN_FIFO1_START             CBUS_REG_ADDR(AUDIN_FIFO1_START)
-#define AUDIN_FIFO1_END 0x2834
-#define P_AUDIN_FIFO1_END               CBUS_REG_ADDR(AUDIN_FIFO1_END)
-#define AUDIN_FIFO1_PTR 0x2835
-#define P_AUDIN_FIFO1_PTR               CBUS_REG_ADDR(AUDIN_FIFO1_PTR)
-#define AUDIN_FIFO1_INTR 0x2836
-#define P_AUDIN_FIFO1_INTR              CBUS_REG_ADDR(AUDIN_FIFO1_INTR)
-#define AUDIN_FIFO1_RDPTR 0x2837
-#define P_AUDIN_FIFO1_RDPTR             CBUS_REG_ADDR(AUDIN_FIFO1_RDPTR)
-#define AUDIN_FIFO1_CTRL 0x2838
-#define P_AUDIN_FIFO1_CTRL              CBUS_REG_ADDR(AUDIN_FIFO1_CTRL)
-#define AUDIN_FIFO1_CTRL1 0x2839
-#define P_AUDIN_FIFO1_CTRL1             CBUS_REG_ADDR(AUDIN_FIFO1_CTRL1)
-#define AUDIN_FIFO1_LVL0 0x2840
-#define P_AUDIN_FIFO1_LVL0              CBUS_REG_ADDR(AUDIN_FIFO1_LVL0)
-#define AUDIN_FIFO1_LVL1 0x2841
-#define P_AUDIN_FIFO1_LVL1              CBUS_REG_ADDR(AUDIN_FIFO1_LVL1)
-#define AUDIN_FIFO1_LVL2 0x2842
-#define P_AUDIN_FIFO1_LVL2              CBUS_REG_ADDR(AUDIN_FIFO1_LVL2)
-#define AUDIN_FIFO1_REQID 0x2843
-#define P_AUDIN_FIFO1_REQID             CBUS_REG_ADDR(AUDIN_FIFO1_REQID)
-#define AUDIN_FIFO1_WRAP 0x2844
-#define P_AUDIN_FIFO1_WRAP              CBUS_REG_ADDR(AUDIN_FIFO1_WRAP)
-#define AUDIN_FIFO2_START 0x2845
-#define P_AUDIN_FIFO2_START             CBUS_REG_ADDR(AUDIN_FIFO2_START)
-#define AUDIN_FIFO2_END 0x2846
-#define P_AUDIN_FIFO2_END               CBUS_REG_ADDR(AUDIN_FIFO2_END)
-#define AUDIN_FIFO2_PTR 0x2847
-#define P_AUDIN_FIFO2_PTR               CBUS_REG_ADDR(AUDIN_FIFO2_PTR)
-#define AUDIN_FIFO2_INTR 0x2848
-#define P_AUDIN_FIFO2_INTR              CBUS_REG_ADDR(AUDIN_FIFO2_INTR)
-#define AUDIN_FIFO2_RDPTR 0x2849
-#define P_AUDIN_FIFO2_RDPTR             CBUS_REG_ADDR(AUDIN_FIFO2_RDPTR)
-#define AUDIN_FIFO2_CTRL 0x284a
-#define P_AUDIN_FIFO2_CTRL              CBUS_REG_ADDR(AUDIN_FIFO2_CTRL)
-#define AUDIN_FIFO2_CTRL1 0x284b
-#define P_AUDIN_FIFO2_CTRL1             CBUS_REG_ADDR(AUDIN_FIFO2_CTRL1)
-#define AUDIN_FIFO2_LVL0 0x284c
-#define P_AUDIN_FIFO2_LVL0              CBUS_REG_ADDR(AUDIN_FIFO2_LVL0)
-#define AUDIN_FIFO2_LVL1 0x284d
-#define P_AUDIN_FIFO2_LVL1              CBUS_REG_ADDR(AUDIN_FIFO2_LVL1)
-#define AUDIN_FIFO2_LVL2 0x284e
-#define P_AUDIN_FIFO2_LVL2              CBUS_REG_ADDR(AUDIN_FIFO2_LVL2)
-#define AUDIN_FIFO2_REQID 0x284f
-#define P_AUDIN_FIFO2_REQID             CBUS_REG_ADDR(AUDIN_FIFO2_REQID)
-#define AUDIN_FIFO2_WRAP 0x2850
-#define P_AUDIN_FIFO2_WRAP              CBUS_REG_ADDR(AUDIN_FIFO2_WRAP)
-#define AUDIN_INT_CTRL 0x2851
-#define P_AUDIN_INT_CTRL                CBUS_REG_ADDR(AUDIN_INT_CTRL)
-#define AUDIN_FIFO_INT 0x2852
-#define P_AUDIN_FIFO_INT                CBUS_REG_ADDR(AUDIN_FIFO_INT)
-#define PCMIN_CTRL0 0x2860
-#define P_PCMIN_CTRL0           CBUS_REG_ADDR(PCMIN_CTRL0)
-#define PCMIN_CTRL1 0x2861
-#define P_PCMIN_CTRL1           CBUS_REG_ADDR(PCMIN_CTRL1)
-#define PCMIN1_CTRL0 0x2862
-#define P_PCMIN1_CTRL0          CBUS_REG_ADDR(PCMIN1_CTRL0)
-#define PCMIN1_CTRL1 0x2863
-#define P_PCMIN1_CTRL1          CBUS_REG_ADDR(PCMIN1_CTRL1)
-#define PCMOUT_CTRL0 0x2870
-#define P_PCMOUT_CTRL0          CBUS_REG_ADDR(PCMOUT_CTRL0)
-#define PCMOUT_CTRL1 0x2871
-#define P_PCMOUT_CTRL1          CBUS_REG_ADDR(PCMOUT_CTRL1)
-#define PCMOUT_CTRL2 0x2872
-#define P_PCMOUT_CTRL2          CBUS_REG_ADDR(PCMOUT_CTRL2)
-#define PCMOUT_CTRL3 0x2873
-#define P_PCMOUT_CTRL3          CBUS_REG_ADDR(PCMOUT_CTRL3)
-#define PCMOUT1_CTRL0 0x2874
-#define P_PCMOUT1_CTRL0                 CBUS_REG_ADDR(PCMOUT1_CTRL0)
-#define PCMOUT1_CTRL1 0x2875
-#define P_PCMOUT1_CTRL1                 CBUS_REG_ADDR(PCMOUT1_CTRL1)
-#define PCMOUT1_CTRL2 0x2876
-#define P_PCMOUT1_CTRL2                 CBUS_REG_ADDR(PCMOUT1_CTRL2)
-#define PCMOUT1_CTRL3 0x2877
-#define P_PCMOUT1_CTRL3                 CBUS_REG_ADDR(PCMOUT1_CTRL3)
-#define AUDOUT_CTRL 0x2880
-#define P_AUDOUT_CTRL           CBUS_REG_ADDR(AUDOUT_CTRL)
-#define AUDOUT_CTRL1 0x2881
-#define P_AUDOUT_CTRL1          CBUS_REG_ADDR(AUDOUT_CTRL1)
-#define AUDOUT_BUF0_STA 0x2882
-#define P_AUDOUT_BUF0_STA               CBUS_REG_ADDR(AUDOUT_BUF0_STA)
-#define AUDOUT_BUF0_EDA 0x2883
-#define P_AUDOUT_BUF0_EDA               CBUS_REG_ADDR(AUDOUT_BUF0_EDA)
-#define AUDOUT_BUF0_WPTR 0x2884
-#define P_AUDOUT_BUF0_WPTR              CBUS_REG_ADDR(AUDOUT_BUF0_WPTR)
-#define AUDOUT_BUF1_STA 0x2885
-#define P_AUDOUT_BUF1_STA               CBUS_REG_ADDR(AUDOUT_BUF1_STA)
-#define AUDOUT_BUF1_EDA 0x2886
-#define P_AUDOUT_BUF1_EDA               CBUS_REG_ADDR(AUDOUT_BUF1_EDA)
-#define AUDOUT_BUF1_WPTR 0x2887
-#define P_AUDOUT_BUF1_WPTR              CBUS_REG_ADDR(AUDOUT_BUF1_WPTR)
-#define AUDOUT_FIFO_RPTR 0x2888
-#define P_AUDOUT_FIFO_RPTR              CBUS_REG_ADDR(AUDOUT_FIFO_RPTR)
-#define AUDOUT_INTR_PTR 0x2889
-#define P_AUDOUT_INTR_PTR               CBUS_REG_ADDR(AUDOUT_INTR_PTR)
-#define AUDOUT_FIFO_STS 0x288a
-#define P_AUDOUT_FIFO_STS               CBUS_REG_ADDR(AUDOUT_FIFO_STS)
-#define AUDOUT1_CTRL 0x2890
-#define P_AUDOUT1_CTRL          CBUS_REG_ADDR(AUDOUT1_CTRL)
-#define AUDOUT1_CTRL1 0x2891
-#define P_AUDOUT1_CTRL1                 CBUS_REG_ADDR(AUDOUT1_CTRL1)
-#define AUDOUT1_BUF0_STA 0x2892
-#define P_AUDOUT1_BUF0_STA              CBUS_REG_ADDR(AUDOUT1_BUF0_STA)
-#define AUDOUT1_BUF0_EDA 0x2893
-#define P_AUDOUT1_BUF0_EDA              CBUS_REG_ADDR(AUDOUT1_BUF0_EDA)
-#define AUDOUT1_BUF0_WPTR 0x2894
-#define P_AUDOUT1_BUF0_WPTR             CBUS_REG_ADDR(AUDOUT1_BUF0_WPTR)
-#define AUDOUT1_BUF1_STA 0x2895
-#define P_AUDOUT1_BUF1_STA              CBUS_REG_ADDR(AUDOUT1_BUF1_STA)
-#define AUDOUT1_BUF1_EDA 0x2896
-#define P_AUDOUT1_BUF1_EDA              CBUS_REG_ADDR(AUDOUT1_BUF1_EDA)
-#define AUDOUT1_BUF1_WPTR 0x2897
-#define P_AUDOUT1_BUF1_WPTR             CBUS_REG_ADDR(AUDOUT1_BUF1_WPTR)
-#define AUDOUT1_FIFO_RPTR 0x2898
-#define P_AUDOUT1_FIFO_RPTR             CBUS_REG_ADDR(AUDOUT1_FIFO_RPTR)
-#define AUDOUT1_INTR_PTR 0x2899
-#define P_AUDOUT1_INTR_PTR              CBUS_REG_ADDR(AUDOUT1_INTR_PTR)
-#define AUDOUT1_FIFO_STS 0x289a
-#define P_AUDOUT1_FIFO_STS              CBUS_REG_ADDR(AUDOUT1_FIFO_STS)
-#define AUDIN_HDMI_MEAS_CTRL 0x28a0
-#define P_AUDIN_HDMI_MEAS_CTRL          CBUS_REG_ADDR(AUDIN_HDMI_MEAS_CTRL)
-#define AUDIN_HDMI_MEAS_CYCLES_M1 0x28a1
-#define AUDIN_FIFO0_PIO_STS 0x28b0
-#define P_AUDIN_FIFO0_PIO_STS           CBUS_REG_ADDR(AUDIN_FIFO0_PIO_STS)
-#define AUDIN_FIFO0_PIO_RDL 0x28b1
-#define P_AUDIN_FIFO0_PIO_RDL           CBUS_REG_ADDR(AUDIN_FIFO0_PIO_RDL)
-#define AUDIN_FIFO0_PIO_RDH 0x28b2
-#define P_AUDIN_FIFO0_PIO_RDH           CBUS_REG_ADDR(AUDIN_FIFO0_PIO_RDH)
-#define AUDIN_FIFO1_PIO_STS 0x28b3
-#define P_AUDIN_FIFO1_PIO_STS           CBUS_REG_ADDR(AUDIN_FIFO1_PIO_STS)
-#define AUDIN_FIFO1_PIO_RDL 0x28b4
-#define P_AUDIN_FIFO1_PIO_RDL           CBUS_REG_ADDR(AUDIN_FIFO1_PIO_RDL)
-#define AUDIN_FIFO1_PIO_RDH 0x28b5
-#define P_AUDIN_FIFO1_PIO_RDH           CBUS_REG_ADDR(AUDIN_FIFO1_PIO_RDH)
-#define AUDIN_FIFO2_PIO_STS 0x28b6
-#define P_AUDIN_FIFO2_PIO_STS           CBUS_REG_ADDR(AUDIN_FIFO2_PIO_STS)
-#define AUDIN_FIFO2_PIO_RDL 0x28b7
-#define P_AUDIN_FIFO2_PIO_RDL           CBUS_REG_ADDR(AUDIN_FIFO2_PIO_RDL)
-#define AUDIN_FIFO2_PIO_RDH 0x28b8
-#define P_AUDIN_FIFO2_PIO_RDH           CBUS_REG_ADDR(AUDIN_FIFO2_PIO_RDH)
-#define AUDOUT_FIFO_PIO_STS 0x28b9
-#define P_AUDOUT_FIFO_PIO_STS           CBUS_REG_ADDR(AUDOUT_FIFO_PIO_STS)
-#define AUDOUT_FIFO_PIO_WRL 0x28ba
-#define P_AUDOUT_FIFO_PIO_WRL           CBUS_REG_ADDR(AUDOUT_FIFO_PIO_WRL)
-#define AUDOUT_FIFO_PIO_WRH 0x28bb
-#define P_AUDOUT_FIFO_PIO_WRH           CBUS_REG_ADDR(AUDOUT_FIFO_PIO_WRH)
-#define AUDOUT1_FIFO_PIO_STS 0x28bc
-#define P_AUDOUT1_FIFO_PIO_STS          CBUS_REG_ADDR(AUDOUT1_FIFO_PIO_STS)
-#define AUDOUT1_FIFO_PIO_WRL 0x28bd
-#define P_AUDOUT1_FIFO_PIO_WRL          CBUS_REG_ADDR(AUDOUT1_FIFO_PIO_WRL)
-#define AUDOUT1_FIFO_PIO_WRH 0x28be
-#define P_AUDOUT1_FIFO_PIO_WRH          CBUS_REG_ADDR(AUDOUT1_FIFO_PIO_WRH)
-#define AUDIN_ADDR_END 0x28bf
-#define P_AUDIN_ADDR_END                CBUS_REG_ADDR(AUDIN_ADDR_END)
-#define VDIN_SCALE_COEF_IDX 0x1200
-#define P_VDIN_SCALE_COEF_IDX           VCBUS_REG_ADDR(VDIN_SCALE_COEF_IDX)
-#define VDIN_SCALE_COEF 0x1201
-#define P_VDIN_SCALE_COEF               VCBUS_REG_ADDR(VDIN_SCALE_COEF)
-#define VDIN_COM_CTRL0 0x1202
-#define P_VDIN_COM_CTRL0                VCBUS_REG_ADDR(VDIN_COM_CTRL0)
-#define VDIN_ACTIVE_MAX_PIX_CNT_STATUS 0x1203
-#define VDIN_LCNT_STATUS 0x1204
-#define P_VDIN_LCNT_STATUS              VCBUS_REG_ADDR(VDIN_LCNT_STATUS)
-#define VDIN_COM_STATUS0 0x1205
-#define P_VDIN_COM_STATUS0              VCBUS_REG_ADDR(VDIN_COM_STATUS0)
-#define VDIN_COM_STATUS1 0x1206
-#define P_VDIN_COM_STATUS1              VCBUS_REG_ADDR(VDIN_COM_STATUS1)
-#define VDIN_LCNT_SHADOW_STATUS 0x1207
-#define VDIN_ASFIFO_CTRL0 0x1208
-#define P_VDIN_ASFIFO_CTRL0             VCBUS_REG_ADDR(VDIN_ASFIFO_CTRL0)
-#define VDIN_ASFIFO_CTRL1 0x1209
-#define P_VDIN_ASFIFO_CTRL1             VCBUS_REG_ADDR(VDIN_ASFIFO_CTRL1)
-#define VDIN_WIDTHM1I_WIDTHM1O 0x120a
-#define VDIN_SC_MISC_CTRL 0x120b
-#define P_VDIN_SC_MISC_CTRL             VCBUS_REG_ADDR(VDIN_SC_MISC_CTRL)
-#define VDIN_HSC_PHASE_STEP 0x120c
-#define P_VDIN_HSC_PHASE_STEP           VCBUS_REG_ADDR(VDIN_HSC_PHASE_STEP)
-#define VDIN_HSC_INI_CTRL 0x120d
-#define P_VDIN_HSC_INI_CTRL             VCBUS_REG_ADDR(VDIN_HSC_INI_CTRL)
-#define VDIN_COM_STATUS2 0x120e
-#define P_VDIN_COM_STATUS2              VCBUS_REG_ADDR(VDIN_COM_STATUS2)
-#define VDIN_ASFIFO_CTRL2 0x120f
-#define P_VDIN_ASFIFO_CTRL2             VCBUS_REG_ADDR(VDIN_ASFIFO_CTRL2)
-#define VDIN_MATRIX_CTRL 0x1210
-#define P_VDIN_MATRIX_CTRL              VCBUS_REG_ADDR(VDIN_MATRIX_CTRL)
-#define VDIN_LFIFO_CTRL 0x121a
-#define P_VDIN_LFIFO_CTRL               VCBUS_REG_ADDR(VDIN_LFIFO_CTRL)
-#define VDIN_COM_GCLK_CTRL 0x121b
-#define P_VDIN_COM_GCLK_CTRL            VCBUS_REG_ADDR(VDIN_COM_GCLK_CTRL)
-#define VDIN_INTF_WIDTHM1 0x121c
-#define P_VDIN_INTF_WIDTHM1             VCBUS_REG_ADDR(VDIN_INTF_WIDTHM1)
-#define VDIN_WR_CTRL2 0x121f
-#define P_VDIN_WR_CTRL2                 VCBUS_REG_ADDR(VDIN_WR_CTRL2)
-#define VDIN_WR_CTRL 0x1220
-#define P_VDIN_WR_CTRL          VCBUS_REG_ADDR(VDIN_WR_CTRL)
-#define VDIN_WR_H_START_END 0x1221
-#define P_VDIN_WR_H_START_END           VCBUS_REG_ADDR(VDIN_WR_H_START_END)
-#define VDIN_WR_V_START_END 0x1222
-#define P_VDIN_WR_V_START_END           VCBUS_REG_ADDR(VDIN_WR_V_START_END)
-#define VDIN_VSC_PHASE_STEP 0x1223
-#define P_VDIN_VSC_PHASE_STEP           VCBUS_REG_ADDR(VDIN_VSC_PHASE_STEP)
-#define VDIN_VSC_INI_CTRL 0x1224
-#define P_VDIN_VSC_INI_CTRL             VCBUS_REG_ADDR(VDIN_VSC_INI_CTRL)
-#define VDIN_SCIN_HEIGHTM1 0x1225
-#define P_VDIN_SCIN_HEIGHTM1            VCBUS_REG_ADDR(VDIN_SCIN_HEIGHTM1)
-#define VDIN_DUMMY_DATA 0x1226
-#define P_VDIN_DUMMY_DATA               VCBUS_REG_ADDR(VDIN_DUMMY_DATA)
-#define VDIN_HIST_MAX_MIN 0x1233
-#define P_VDIN_HIST_MAX_MIN             VCBUS_REG_ADDR(VDIN_HIST_MAX_MIN)
-#define VDIN_HIST_SPL_VAL 0x1234
-#define P_VDIN_HIST_SPL_VAL             VCBUS_REG_ADDR(VDIN_HIST_SPL_VAL)
-#define VDIN_HIST_SPL_PIX_CNT 0x1235
-#define P_VDIN_HIST_CHROMA_SUM          VCBUS_REG_ADDR(VDIN_HIST_CHROMA_SUM)
-#define VDIN_DNLP_HIST00 0x1237
-#define P_VDIN_DNLP_HIST00              VCBUS_REG_ADDR(VDIN_DNLP_HIST00)
-#define VDIN_DNLP_HIST01 0x1238
-#define P_VDIN_DNLP_HIST01              VCBUS_REG_ADDR(VDIN_DNLP_HIST01)
-#define VDIN_DNLP_HIST02 0x1239
-#define P_VDIN_DNLP_HIST02              VCBUS_REG_ADDR(VDIN_DNLP_HIST02)
-#define VDIN_DNLP_HIST03 0x123a
-#define P_VDIN_DNLP_HIST03              VCBUS_REG_ADDR(VDIN_DNLP_HIST03)
-#define VDIN_DNLP_HIST04 0x123b
-#define P_VDIN_DNLP_HIST04              VCBUS_REG_ADDR(VDIN_DNLP_HIST04)
-#define VDIN_DNLP_HIST05 0x123c
-#define P_VDIN_DNLP_HIST05              VCBUS_REG_ADDR(VDIN_DNLP_HIST05)
-#define VDIN_DNLP_HIST06 0x123d
-#define P_VDIN_DNLP_HIST06              VCBUS_REG_ADDR(VDIN_DNLP_HIST06)
-#define VDIN_DNLP_HIST07 0x123e
-#define P_VDIN_DNLP_HIST07              VCBUS_REG_ADDR(VDIN_DNLP_HIST07)
-#define VDIN_DNLP_HIST08 0x123f
-#define P_VDIN_DNLP_HIST08              VCBUS_REG_ADDR(VDIN_DNLP_HIST08)
-#define VDIN_DNLP_HIST09 0x1240
-#define P_VDIN_DNLP_HIST09              VCBUS_REG_ADDR(VDIN_DNLP_HIST09)
-#define VDIN_DNLP_HIST10 0x1241
-#define P_VDIN_DNLP_HIST10              VCBUS_REG_ADDR(VDIN_DNLP_HIST10)
-#define VDIN_DNLP_HIST11 0x1242
-#define P_VDIN_DNLP_HIST11              VCBUS_REG_ADDR(VDIN_DNLP_HIST11)
-#define VDIN_DNLP_HIST12 0x1243
-#define P_VDIN_DNLP_HIST12              VCBUS_REG_ADDR(VDIN_DNLP_HIST12)
-#define VDIN_DNLP_HIST13 0x1244
-#define P_VDIN_DNLP_HIST13              VCBUS_REG_ADDR(VDIN_DNLP_HIST13)
-#define VDIN_DNLP_HIST14 0x1245
-#define P_VDIN_DNLP_HIST14              VCBUS_REG_ADDR(VDIN_DNLP_HIST14)
-#define VDIN_DNLP_HIST15 0x1246
-#define P_VDIN_DNLP_HIST15              VCBUS_REG_ADDR(VDIN_DNLP_HIST15)
-#define VDIN_DNLP_HIST16 0x1247
-#define P_VDIN_DNLP_HIST16              VCBUS_REG_ADDR(VDIN_DNLP_HIST16)
-#define VDIN_DNLP_HIST17 0x1248
-#define P_VDIN_DNLP_HIST17              VCBUS_REG_ADDR(VDIN_DNLP_HIST17)
-#define VDIN_DNLP_HIST18 0x1249
-#define P_VDIN_DNLP_HIST18              VCBUS_REG_ADDR(VDIN_DNLP_HIST18)
-#define VDIN_DNLP_HIST19 0x124a
-#define P_VDIN_DNLP_HIST19              VCBUS_REG_ADDR(VDIN_DNLP_HIST19)
-#define VDIN_DNLP_HIST20 0x124b
-#define P_VDIN_DNLP_HIST20              VCBUS_REG_ADDR(VDIN_DNLP_HIST20)
-#define VDIN_DNLP_HIST21 0x124c
-#define P_VDIN_DNLP_HIST21              VCBUS_REG_ADDR(VDIN_DNLP_HIST21)
-#define VDIN_DNLP_HIST22 0x124d
-#define P_VDIN_DNLP_HIST22              VCBUS_REG_ADDR(VDIN_DNLP_HIST22)
-#define VDIN_DNLP_HIST23 0x124e
-#define P_VDIN_DNLP_HIST23              VCBUS_REG_ADDR(VDIN_DNLP_HIST23)
-#define VDIN_DNLP_HIST24 0x124f
-#define P_VDIN_DNLP_HIST24              VCBUS_REG_ADDR(VDIN_DNLP_HIST24)
-#define VDIN_DNLP_HIST25 0x1250
-#define P_VDIN_DNLP_HIST25              VCBUS_REG_ADDR(VDIN_DNLP_HIST25)
-#define VDIN_DNLP_HIST26 0x1251
-#define P_VDIN_DNLP_HIST26              VCBUS_REG_ADDR(VDIN_DNLP_HIST26)
-#define VDIN_DNLP_HIST27 0x1252
-#define P_VDIN_DNLP_HIST27              VCBUS_REG_ADDR(VDIN_DNLP_HIST27)
-#define VDIN_DNLP_HIST28 0x1253
-#define P_VDIN_DNLP_HIST28              VCBUS_REG_ADDR(VDIN_DNLP_HIST28)
-#define VDIN_DNLP_HIST29 0x1254
-#define P_VDIN_DNLP_HIST29              VCBUS_REG_ADDR(VDIN_DNLP_HIST29)
-#define VDIN_DNLP_HIST30 0x1255
-#define P_VDIN_DNLP_HIST30              VCBUS_REG_ADDR(VDIN_DNLP_HIST30)
-#define VDIN_DNLP_HIST31 0x1256
-#define P_VDIN_DNLP_HIST31              VCBUS_REG_ADDR(VDIN_DNLP_HIST31)
-
-#define P_VDIN1_ASFIFO_CTRL3            VCBUS_REG_ADDR(VDIN1_ASFIFO_CTRL3)
-#define VPP_DUMMY_DATA 0x1d00
-#define P_VPP_DUMMY_DATA                VCBUS_REG_ADDR(VPP_DUMMY_DATA)
-#define VPP_LINE_IN_LENGTH 0x1d01
-#define P_VPP_LINE_IN_LENGTH            VCBUS_REG_ADDR(VPP_LINE_IN_LENGTH)
-#define VPP_PIC_IN_HEIGHT 0x1d02
-#define P_VPP_PIC_IN_HEIGHT             VCBUS_REG_ADDR(VPP_PIC_IN_HEIGHT)
-#define VPP_SCALE_COEF_IDX 0x1d03
-#define P_VPP_SCALE_COEF_IDX            VCBUS_REG_ADDR(VPP_SCALE_COEF_IDX)
-#define VPP_SCALE_COEF 0x1d04
-#define P_VPP_SCALE_COEF                VCBUS_REG_ADDR(VPP_SCALE_COEF)
-
-#define VPP_VSC_PHASE_CTRL 0x1d0d
-#define P_VPP_VSC_PHASE_CTRL            VCBUS_REG_ADDR(VPP_VSC_PHASE_CTRL)
-#define VPP_VSC_INI_PHASE 0x1d0e
-#define P_VPP_VSC_INI_PHASE             VCBUS_REG_ADDR(VPP_VSC_INI_PHASE)
-#define VPP_HSC_REGION12_STARTP 0x1d10
-
-#define VPP_DUMMY_DATA1 0x1d69
-#define P_VPP_DUMMY_DATA1               VCBUS_REG_ADDR(VPP_DUMMY_DATA1)
-#define VPP_GAINOFF_CTRL0 0x1d6a
-#define P_VPP_GAINOFF_CTRL0             VCBUS_REG_ADDR(VPP_GAINOFF_CTRL0)
-#define VPP_GAINOFF_CTRL1 0x1d6b
-#define P_VPP_GAINOFF_CTRL1             VCBUS_REG_ADDR(VPP_GAINOFF_CTRL1)
-#define VPP_GAINOFF_CTRL2 0x1d6c
-#define P_VPP_GAINOFF_CTRL2             VCBUS_REG_ADDR(VPP_GAINOFF_CTRL2)
-#define VPP_GAINOFF_CTRL3 0x1d6d
-#define P_VPP_GAINOFF_CTRL3             VCBUS_REG_ADDR(VPP_GAINOFF_CTRL3)
-#define VPP_GAINOFF_CTRL4 0x1d6e
-#define P_VPP_GAINOFF_CTRL4             VCBUS_REG_ADDR(VPP_GAINOFF_CTRL4)
-#define VPP_CHROMA_ADDR_PORT 0x1d70
-#define P_VPP_CHROMA_ADDR_PORT          VCBUS_REG_ADDR(VPP_CHROMA_ADDR_PORT)
-#define VPP_CHROMA_DATA_PORT 0x1d71
-#define P_VPP_CHROMA_DATA_PORT          VCBUS_REG_ADDR(VPP_CHROMA_DATA_PORT)
-#define VPP_GCLK_CTRL0 0x1d72
-#define P_VPP_GCLK_CTRL0                VCBUS_REG_ADDR(VPP_GCLK_CTRL0)
-#define VPP_GCLK_CTRL1 0x1d73
-#define P_VPP_GCLK_CTRL1                VCBUS_REG_ADDR(VPP_GCLK_CTRL1)
-#define VPP_SC_GCLK_CTRL 0x1d74
-#define P_VPP_SC_GCLK_CTRL              VCBUS_REG_ADDR(VPP_SC_GCLK_CTRL)
-#define VPP_MISC1 0x1d76
-#define P_VPP_MISC1             VCBUS_REG_ADDR(VPP_MISC1)
-#define VPP_BLACKEXT_CTRL 0x1d80
-#define P_VPP_BLACKEXT_CTRL             VCBUS_REG_ADDR(VPP_BLACKEXT_CTRL)
-#define VPP_DNLP_CTRL_00 0x1d81
-#define P_VPP_DNLP_CTRL_00              VCBUS_REG_ADDR(VPP_DNLP_CTRL_00)
-#define VPP_DNLP_CTRL_01 0x1d82
-#define P_VPP_DNLP_CTRL_01              VCBUS_REG_ADDR(VPP_DNLP_CTRL_01)
-#define VPP_DNLP_CTRL_02 0x1d83
-#define P_VPP_DNLP_CTRL_02              VCBUS_REG_ADDR(VPP_DNLP_CTRL_02)
-#define VPP_DNLP_CTRL_03 0x1d84
-#define P_VPP_DNLP_CTRL_03              VCBUS_REG_ADDR(VPP_DNLP_CTRL_03)
-#define VPP_DNLP_CTRL_04 0x1d85
-#define P_VPP_DNLP_CTRL_04              VCBUS_REG_ADDR(VPP_DNLP_CTRL_04)
-#define VPP_DNLP_CTRL_05 0x1d86
-#define P_VPP_DNLP_CTRL_05              VCBUS_REG_ADDR(VPP_DNLP_CTRL_05)
-#define VPP_DNLP_CTRL_06 0x1d87
-#define P_VPP_DNLP_CTRL_06              VCBUS_REG_ADDR(VPP_DNLP_CTRL_06)
-#define VPP_DNLP_CTRL_07 0x1d88
-#define P_VPP_DNLP_CTRL_07              VCBUS_REG_ADDR(VPP_DNLP_CTRL_07)
-#define VPP_DNLP_CTRL_08 0x1d89
-#define P_VPP_DNLP_CTRL_08              VCBUS_REG_ADDR(VPP_DNLP_CTRL_08)
-#define VPP_DNLP_CTRL_09 0x1d8a
-#define P_VPP_DNLP_CTRL_09              VCBUS_REG_ADDR(VPP_DNLP_CTRL_09)
-#define VPP_DNLP_CTRL_10 0x1d8b
-#define P_VPP_DNLP_CTRL_10              VCBUS_REG_ADDR(VPP_DNLP_CTRL_10)
-#define VPP_DNLP_CTRL_11 0x1d8c
-#define P_VPP_DNLP_CTRL_11              VCBUS_REG_ADDR(VPP_DNLP_CTRL_11)
-#define VPP_DNLP_CTRL_12 0x1d8d
-#define P_VPP_DNLP_CTRL_12              VCBUS_REG_ADDR(VPP_DNLP_CTRL_12)
-#define VPP_DNLP_CTRL_13 0x1d8e
-#define P_VPP_DNLP_CTRL_13              VCBUS_REG_ADDR(VPP_DNLP_CTRL_13)
-#define VPP_DNLP_CTRL_14 0x1d8f
-#define P_VPP_DNLP_CTRL_14              VCBUS_REG_ADDR(VPP_DNLP_CTRL_14)
-#define VPP_DNLP_CTRL_15 0x1d90
-#define P_VPP_DNLP_CTRL_15              VCBUS_REG_ADDR(VPP_DNLP_CTRL_15)
-#define VPP_PEAKING_HGAIN 0x1d91
-#define P_VPP_PEAKING_HGAIN             VCBUS_REG_ADDR(VPP_PEAKING_HGAIN)
-#define VPP_PEAKING_VGAIN 0x1d92
-#define P_VPP_PEAKING_VGAIN             VCBUS_REG_ADDR(VPP_PEAKING_VGAIN)
-#define VPP_PEAKING_NLP_1 0x1d93
-#define P_VPP_PEAKING_NLP_1             VCBUS_REG_ADDR(VPP_PEAKING_NLP_1)
-#define VPP_PEAKING_NLP_2 0x1d94
-#define P_VPP_PEAKING_NLP_2             VCBUS_REG_ADDR(VPP_PEAKING_NLP_2)
-#define VPP_PEAKING_NLP_3 0x1d95
-#define P_VPP_PEAKING_NLP_3             VCBUS_REG_ADDR(VPP_PEAKING_NLP_3)
-#define VPP_PEAKING_NLP_4 0x1d96
-#define P_VPP_PEAKING_NLP_4             VCBUS_REG_ADDR(VPP_PEAKING_NLP_4)
-#define VPP_PEAKING_NLP_5 0x1d97
-#define P_VPP_PEAKING_NLP_5             VCBUS_REG_ADDR(VPP_PEAKING_NLP_5)
-#define VPP_SHARP_LIMIT 0x1d98
-#define P_VPP_SHARP_LIMIT               VCBUS_REG_ADDR(VPP_SHARP_LIMIT)
-#define VPP_VLTI_CTRL 0x1d99
-#define P_VPP_VLTI_CTRL                 VCBUS_REG_ADDR(VPP_VLTI_CTRL)
-#define VPP_HLTI_CTRL 0x1d9a
-#define P_VPP_HLTI_CTRL                 VCBUS_REG_ADDR(VPP_HLTI_CTRL)
-#define VPP_CTI_CTRL 0x1d9b
-#define P_VPP_CTI_CTRL          VCBUS_REG_ADDR(VPP_CTI_CTRL)
-#define VPP_BLUE_STRETCH_1 0x1d9c
-#define P_VPP_BLUE_STRETCH_1            VCBUS_REG_ADDR(VPP_BLUE_STRETCH_1)
-#define VPP_BLUE_STRETCH_2 0x1d9d
-#define P_VPP_BLUE_STRETCH_2            VCBUS_REG_ADDR(VPP_BLUE_STRETCH_2)
-#define VPP_BLUE_STRETCH_3 0x1d9e
-#define P_VPP_BLUE_STRETCH_3            VCBUS_REG_ADDR(VPP_BLUE_STRETCH_3)
-#define VPP_CCORING_CTRL 0x1da0
-#define P_VPP_CCORING_CTRL              VCBUS_REG_ADDR(VPP_CCORING_CTRL)
-#define VPP_VE_ENABLE_CTRL 0x1da1
-#define P_VPP_VE_ENABLE_CTRL            VCBUS_REG_ADDR(VPP_VE_ENABLE_CTRL)
-#define VPP_INPUT_CTRL 0x1dab
-#define P_VPP_INPUT_CTRL                VCBUS_REG_ADDR(VPP_INPUT_CTRL)
-#define VPP_CTI_CTRL2 0x1dac
-#define P_VPP_CTI_CTRL2                 VCBUS_REG_ADDR(VPP_CTI_CTRL2)
-#define VPP_PEAKING_SAT_THD1 0x1dad
-#define P_VPP_PEAKING_SAT_THD1          VCBUS_REG_ADDR(VPP_PEAKING_SAT_THD1)
-#define VPP_PEAKING_SAT_THD2 0x1dae
-#define P_VPP_PEAKING_SAT_THD2          VCBUS_REG_ADDR(VPP_PEAKING_SAT_THD2)
-#define VPP_PEAKING_SAT_THD3 0x1daf
-#define P_VPP_PEAKING_SAT_THD3          VCBUS_REG_ADDR(VPP_PEAKING_SAT_THD3)
-#define VPP_PEAKING_SAT_THD4 0x1db0
-#define P_VPP_PEAKING_SAT_THD4          VCBUS_REG_ADDR(VPP_PEAKING_SAT_THD4)
-#define VPP_PEAKING_SAT_THD5 0x1db1
-#define P_VPP_PEAKING_SAT_THD5          VCBUS_REG_ADDR(VPP_PEAKING_SAT_THD5)
-#define VPP_PEAKING_SAT_THD6 0x1db2
-#define P_VPP_PEAKING_SAT_THD6          VCBUS_REG_ADDR(VPP_PEAKING_SAT_THD6)
-#define VPP_PEAKING_SAT_THD7 0x1db3
-#define P_VPP_PEAKING_SAT_THD7          VCBUS_REG_ADDR(VPP_PEAKING_SAT_THD7)
-#define VPP_PEAKING_SAT_THD8 0x1db4
-#define P_VPP_PEAKING_SAT_THD8          VCBUS_REG_ADDR(VPP_PEAKING_SAT_THD8)
-#define VPP_PEAKING_SAT_THD9 0x1db5
-#define P_VPP_PEAKING_SAT_THD9          VCBUS_REG_ADDR(VPP_PEAKING_SAT_THD9)
-#define VPP_PEAKING_GAIN_ADD1 0x1db6
-#define VPP2_GCLK_CTRL0 0x1972
-#define P_VPP2_GCLK_CTRL0               VCBUS_REG_ADDR(VPP2_GCLK_CTRL0)
-#define VPP2_GCLK_CTRL1 0x1973
-#define P_VPP2_GCLK_CTRL1               VCBUS_REG_ADDR(VPP2_GCLK_CTRL1)
-#define VPP2_SC_GCLK_CTRL 0x1974
-#define P_VPP2_SC_GCLK_CTRL             VCBUS_REG_ADDR(VPP2_SC_GCLK_CTRL)
-#define VPP2_MISC1 0x1976
-#define P_VPP2_MISC1            VCBUS_REG_ADDR(VPP2_MISC1)
-#define VPP2_DNLP_CTRL_00 0x1981
-#define P_VPP2_DNLP_CTRL_00             VCBUS_REG_ADDR(VPP2_DNLP_CTRL_00)
-#define VPP2_DNLP_CTRL_01 0x1982
-#define P_VPP2_DNLP_CTRL_01             VCBUS_REG_ADDR(VPP2_DNLP_CTRL_01)
-#define VPP2_DNLP_CTRL_02 0x1983
-#define P_VPP2_DNLP_CTRL_02             VCBUS_REG_ADDR(VPP2_DNLP_CTRL_02)
-#define VPP2_DNLP_CTRL_03 0x1984
-#define P_VPP2_DNLP_CTRL_03             VCBUS_REG_ADDR(VPP2_DNLP_CTRL_03)
-#define VPP2_DNLP_CTRL_04 0x1985
-#define P_VPP2_DNLP_CTRL_04             VCBUS_REG_ADDR(VPP2_DNLP_CTRL_04)
-#define VPP2_DNLP_CTRL_05 0x1986
-#define P_VPP2_DNLP_CTRL_05             VCBUS_REG_ADDR(VPP2_DNLP_CTRL_05)
-#define VPP2_DNLP_CTRL_06 0x1987
-#define P_VPP2_DNLP_CTRL_06             VCBUS_REG_ADDR(VPP2_DNLP_CTRL_06)
-#define VPP2_DNLP_CTRL_07 0x1988
-#define P_VPP2_DNLP_CTRL_07             VCBUS_REG_ADDR(VPP2_DNLP_CTRL_07)
-#define VPP2_DNLP_CTRL_08 0x1989
-#define P_VPP2_DNLP_CTRL_08             VCBUS_REG_ADDR(VPP2_DNLP_CTRL_08)
-#define VPP2_DNLP_CTRL_09 0x198a
-#define P_VPP2_DNLP_CTRL_09             VCBUS_REG_ADDR(VPP2_DNLP_CTRL_09)
-#define VPP2_DNLP_CTRL_10 0x198b
-#define P_VPP2_DNLP_CTRL_10             VCBUS_REG_ADDR(VPP2_DNLP_CTRL_10)
-#define VPP2_DNLP_CTRL_11 0x198c
-#define P_VPP2_DNLP_CTRL_11             VCBUS_REG_ADDR(VPP2_DNLP_CTRL_11)
-#define VPP2_DNLP_CTRL_12 0x198d
-#define P_VPP2_DNLP_CTRL_12             VCBUS_REG_ADDR(VPP2_DNLP_CTRL_12)
-#define VPP2_DNLP_CTRL_13 0x198e
-#define P_VPP2_DNLP_CTRL_13             VCBUS_REG_ADDR(VPP2_DNLP_CTRL_13)
-#define VPP2_DNLP_CTRL_14 0x198f
-#define P_VPP2_DNLP_CTRL_14             VCBUS_REG_ADDR(VPP2_DNLP_CTRL_14)
-#define VPP2_DNLP_CTRL_15 0x1990
-#define P_VPP2_DNLP_CTRL_15             VCBUS_REG_ADDR(VPP2_DNLP_CTRL_15)
-#define VPP2_VE_ENABLE_CTRL 0x19a1
-#define P_VPP2_VE_ENABLE_CTRL           VCBUS_REG_ADDR(VPP2_VE_ENABLE_CTRL)
-#define VPP2_VE_DEMO_LEFT_TOP_SCREEN_WIDTH 0x19a2
-#define VPP2_OSD_SCALE_COEF 0x19cd
-#define P_VPP2_OSD_SCALE_COEF           VCBUS_REG_ADDR(VPP2_OSD_SCALE_COEF)
-#define VPP2_INT_LINE_NUM 0x19ce
-#define P_VPP2_INT_LINE_NUM             VCBUS_REG_ADDR(VPP2_INT_LINE_NUM)
-#define VIU_ADDR_START 0x1a00
-#define P_VIU_ADDR_START                VCBUS_REG_ADDR(VIU_ADDR_START)
-#define VIU_ADDR_END 0x1aff
-#define P_VIU_ADDR_END          VCBUS_REG_ADDR(VIU_ADDR_END)
-#define VIU_SW_RESET 0x1a01
-#define P_VIU_SW_RESET          VCBUS_REG_ADDR(VIU_SW_RESET)
-#define VIU_MISC_CTRL0 0x1a06
-#define P_VIU_MISC_CTRL0                VCBUS_REG_ADDR(VIU_MISC_CTRL0)
-#define D2D3_INTF_LENGTH 0x1a08
-#define P_D2D3_INTF_LENGTH              VCBUS_REG_ADDR(D2D3_INTF_LENGTH)
-#define D2D3_INTF_CTRL0 0x1a09
-#define P_D2D3_INTF_CTRL0               VCBUS_REG_ADDR(D2D3_INTF_CTRL0)
-#define VIU_OSD1_CTRL_STAT 0x1a10
-#define P_VIU_OSD1_CTRL_STAT            VCBUS_REG_ADDR(VIU_OSD1_CTRL_STAT)
-#define VIU_OSD1_CTRL_STAT2 0x1a2d
-#define P_VIU_OSD1_CTRL_STAT2           VCBUS_REG_ADDR(VIU_OSD1_CTRL_STAT2)
-#define VIU_OSD1_COLOR_ADDR 0x1a11
-#define P_VIU_OSD1_COLOR_ADDR           VCBUS_REG_ADDR(VIU_OSD1_COLOR_ADDR)
-#define VIU_OSD1_COLOR 0x1a12
-#define P_VIU_OSD1_COLOR                VCBUS_REG_ADDR(VIU_OSD1_COLOR)
-#define VIU_OSD1_TCOLOR_AG0 0x1a17
-#define P_VIU_OSD1_TCOLOR_AG0           VCBUS_REG_ADDR(VIU_OSD1_TCOLOR_AG0)
-#define VIU_OSD1_TCOLOR_AG1 0x1a18
-#define P_VIU_OSD1_TCOLOR_AG1           VCBUS_REG_ADDR(VIU_OSD1_TCOLOR_AG1)
-#define VIU_OSD1_TCOLOR_AG2 0x1a19
-#define P_VIU_OSD1_TCOLOR_AG2           VCBUS_REG_ADDR(VIU_OSD1_TCOLOR_AG2)
-#define VIU_OSD1_TCOLOR_AG3 0x1a1a
-#define P_VIU_OSD1_TCOLOR_AG3           VCBUS_REG_ADDR(VIU_OSD1_TCOLOR_AG3)
-#define VIU_OSD1_BLK0_CFG_W0 0x1a1b
-#define P_VIU_OSD1_BLK0_CFG_W0          VCBUS_REG_ADDR(VIU_OSD1_BLK0_CFG_W0)
-#define VIU_OSD1_BLK1_CFG_W0 0x1a1f
-#define P_VIU_OSD1_BLK1_CFG_W0          VCBUS_REG_ADDR(VIU_OSD1_BLK1_CFG_W0)
-#define VIU_OSD1_BLK2_CFG_W0 0x1a23
-#define P_VIU_OSD1_BLK2_CFG_W0          VCBUS_REG_ADDR(VIU_OSD1_BLK2_CFG_W0)
-#define VIU_OSD1_BLK3_CFG_W0 0x1a27
-#define P_VIU_OSD1_BLK3_CFG_W0          VCBUS_REG_ADDR(VIU_OSD1_BLK3_CFG_W0)
-#define VIU_OSD1_BLK0_CFG_W1 0x1a1c
-#define P_VIU_OSD1_BLK0_CFG_W1          VCBUS_REG_ADDR(VIU_OSD1_BLK0_CFG_W1)
-#define VIU_OSD1_BLK1_CFG_W1 0x1a20
-#define P_VIU_OSD1_BLK1_CFG_W1          VCBUS_REG_ADDR(VIU_OSD1_BLK1_CFG_W1)
-#define VIU_OSD1_BLK2_CFG_W1 0x1a24
-#define P_VIU_OSD1_BLK2_CFG_W1          VCBUS_REG_ADDR(VIU_OSD1_BLK2_CFG_W1)
-#define VIU_OSD1_BLK3_CFG_W1 0x1a28
-#define P_VIU_OSD1_BLK3_CFG_W1          VCBUS_REG_ADDR(VIU_OSD1_BLK3_CFG_W1)
-#define VIU_OSD1_BLK0_CFG_W2 0x1a1d
-#define P_VIU_OSD1_BLK0_CFG_W2          VCBUS_REG_ADDR(VIU_OSD1_BLK0_CFG_W2)
-#define VIU_OSD1_BLK1_CFG_W2 0x1a21
-#define P_VIU_OSD1_BLK1_CFG_W2          VCBUS_REG_ADDR(VIU_OSD1_BLK1_CFG_W2)
-#define VIU_OSD1_BLK2_CFG_W2 0x1a25
-#define P_VIU_OSD1_BLK2_CFG_W2          VCBUS_REG_ADDR(VIU_OSD1_BLK2_CFG_W2)
-#define VIU_OSD1_BLK3_CFG_W2 0x1a29
-#define P_VIU_OSD1_BLK3_CFG_W2          VCBUS_REG_ADDR(VIU_OSD1_BLK3_CFG_W2)
-#define VIU_OSD1_BLK0_CFG_W3 0x1a1e
-#define P_VIU_OSD1_BLK0_CFG_W3          VCBUS_REG_ADDR(VIU_OSD1_BLK0_CFG_W3)
-#define VIU_OSD1_BLK1_CFG_W3 0x1a22
-#define P_VIU_OSD1_BLK1_CFG_W3          VCBUS_REG_ADDR(VIU_OSD1_BLK1_CFG_W3)
-#define VIU_OSD1_BLK2_CFG_W3 0x1a26
-#define P_VIU_OSD1_BLK2_CFG_W3          VCBUS_REG_ADDR(VIU_OSD1_BLK2_CFG_W3)
-#define VIU_OSD1_BLK3_CFG_W3 0x1a2a
-#define P_VIU_OSD1_BLK3_CFG_W3          VCBUS_REG_ADDR(VIU_OSD1_BLK3_CFG_W3)
-#define VIU_OSD1_BLK0_CFG_W4 0x1a13
-#define P_VIU_OSD1_BLK0_CFG_W4          VCBUS_REG_ADDR(VIU_OSD1_BLK0_CFG_W4)
-#define VIU_OSD1_BLK1_CFG_W4 0x1a14
-#define P_VIU_OSD1_BLK1_CFG_W4          VCBUS_REG_ADDR(VIU_OSD1_BLK1_CFG_W4)
-#define VIU_OSD1_BLK2_CFG_W4 0x1a15
-#define P_VIU_OSD1_BLK2_CFG_W4          VCBUS_REG_ADDR(VIU_OSD1_BLK2_CFG_W4)
-#define VIU_OSD1_BLK3_CFG_W4 0x1a16
-#define P_VIU_OSD1_BLK3_CFG_W4          VCBUS_REG_ADDR(VIU_OSD1_BLK3_CFG_W4)
-#define VIU_OSD1_TEST_RDDATA 0x1a2c
-#define P_VIU_OSD1_TEST_RDDATA          VCBUS_REG_ADDR(VIU_OSD1_TEST_RDDATA)
-#define VIU_OSD1_PROT_CTRL 0x1a2e
-#define P_VIU_OSD1_PROT_CTRL            VCBUS_REG_ADDR(VIU_OSD1_PROT_CTRL)
-#define VIU_OSD2_CTRL_STAT 0x1a30
-#define P_VIU_OSD2_CTRL_STAT            VCBUS_REG_ADDR(VIU_OSD2_CTRL_STAT)
-#define VIU_OSD2_CTRL_STAT2 0x1a4d
-#define P_VIU_OSD2_CTRL_STAT2           VCBUS_REG_ADDR(VIU_OSD2_CTRL_STAT2)
-#define VIU_OSD2_COLOR_ADDR 0x1a31
-#define P_VIU_OSD2_COLOR_ADDR           VCBUS_REG_ADDR(VIU_OSD2_COLOR_ADDR)
-#define VIU_OSD2_COLOR 0x1a32
-#define P_VIU_OSD2_COLOR                VCBUS_REG_ADDR(VIU_OSD2_COLOR)
-#define VIU_OSD2_HL1_H_START_END 0x1a33
-#define VIU_OSD2_TCOLOR_AG0 0x1a37
-#define P_VIU_OSD2_TCOLOR_AG0           VCBUS_REG_ADDR(VIU_OSD2_TCOLOR_AG0)
-#define VIU_OSD2_TCOLOR_AG1 0x1a38
-#define P_VIU_OSD2_TCOLOR_AG1           VCBUS_REG_ADDR(VIU_OSD2_TCOLOR_AG1)
-#define VIU_OSD2_TCOLOR_AG2 0x1a39
-#define P_VIU_OSD2_TCOLOR_AG2           VCBUS_REG_ADDR(VIU_OSD2_TCOLOR_AG2)
-#define VIU_OSD2_TCOLOR_AG3 0x1a3a
-#define P_VIU_OSD2_TCOLOR_AG3           VCBUS_REG_ADDR(VIU_OSD2_TCOLOR_AG3)
-#define VIU_OSD2_BLK0_CFG_W0 0x1a3b
-#define P_VIU_OSD2_BLK0_CFG_W0          VCBUS_REG_ADDR(VIU_OSD2_BLK0_CFG_W0)
-#define VIU_OSD2_BLK1_CFG_W0 0x1a3f
-#define P_VIU_OSD2_BLK1_CFG_W0          VCBUS_REG_ADDR(VIU_OSD2_BLK1_CFG_W0)
-#define VIU_OSD2_BLK2_CFG_W0 0x1a43
-#define P_VIU_OSD2_BLK2_CFG_W0          VCBUS_REG_ADDR(VIU_OSD2_BLK2_CFG_W0)
-#define VIU_OSD2_BLK3_CFG_W0 0x1a47
-#define P_VIU_OSD2_BLK3_CFG_W0          VCBUS_REG_ADDR(VIU_OSD2_BLK3_CFG_W0)
-#define VIU_OSD2_BLK0_CFG_W1 0x1a3c
-#define P_VIU_OSD2_BLK0_CFG_W1          VCBUS_REG_ADDR(VIU_OSD2_BLK0_CFG_W1)
-#define VIU_OSD2_BLK1_CFG_W1 0x1a40
-#define P_VIU_OSD2_BLK1_CFG_W1          VCBUS_REG_ADDR(VIU_OSD2_BLK1_CFG_W1)
-#define VIU_OSD2_BLK2_CFG_W1 0x1a44
-#define P_VIU_OSD2_BLK2_CFG_W1          VCBUS_REG_ADDR(VIU_OSD2_BLK2_CFG_W1)
-#define VIU_OSD2_BLK3_CFG_W1 0x1a48
-#define P_VIU_OSD2_BLK3_CFG_W1          VCBUS_REG_ADDR(VIU_OSD2_BLK3_CFG_W1)
-#define VIU_OSD2_BLK0_CFG_W2 0x1a3d
-#define P_VIU_OSD2_BLK0_CFG_W2          VCBUS_REG_ADDR(VIU_OSD2_BLK0_CFG_W2)
-#define VIU_OSD2_BLK1_CFG_W2 0x1a41
-#define P_VIU_OSD2_BLK1_CFG_W2          VCBUS_REG_ADDR(VIU_OSD2_BLK1_CFG_W2)
-#define VIU_OSD2_BLK2_CFG_W2 0x1a45
-#define P_VIU_OSD2_BLK2_CFG_W2          VCBUS_REG_ADDR(VIU_OSD2_BLK2_CFG_W2)
-#define VIU_OSD2_BLK3_CFG_W2 0x1a49
-#define P_VIU_OSD2_BLK3_CFG_W2          VCBUS_REG_ADDR(VIU_OSD2_BLK3_CFG_W2)
-#define VIU_OSD2_BLK0_CFG_W3 0x1a3e
-#define P_VIU_OSD2_BLK0_CFG_W3          VCBUS_REG_ADDR(VIU_OSD2_BLK0_CFG_W3)
-#define VIU_OSD2_BLK1_CFG_W3 0x1a42
-#define P_VIU_OSD2_BLK1_CFG_W3          VCBUS_REG_ADDR(VIU_OSD2_BLK1_CFG_W3)
-#define VIU_OSD2_BLK2_CFG_W3 0x1a46
-#define P_VIU_OSD2_BLK2_CFG_W3          VCBUS_REG_ADDR(VIU_OSD2_BLK2_CFG_W3)
-#define VIU_OSD2_BLK3_CFG_W3 0x1a4a
-#define P_VIU_OSD2_BLK3_CFG_W3          VCBUS_REG_ADDR(VIU_OSD2_BLK3_CFG_W3)
-#define VIU_OSD2_BLK0_CFG_W4 0x1a64
-#define P_VIU_OSD2_BLK0_CFG_W4          VCBUS_REG_ADDR(VIU_OSD2_BLK0_CFG_W4)
-#define VIU_OSD2_BLK1_CFG_W4 0x1a65
-#define P_VIU_OSD2_BLK1_CFG_W4          VCBUS_REG_ADDR(VIU_OSD2_BLK1_CFG_W4)
-#define VIU_OSD2_BLK2_CFG_W4 0x1a66
-#define P_VIU_OSD2_BLK2_CFG_W4          VCBUS_REG_ADDR(VIU_OSD2_BLK2_CFG_W4)
-#define VIU_OSD2_BLK3_CFG_W4 0x1a67
-#define P_VIU_OSD2_BLK3_CFG_W4          VCBUS_REG_ADDR(VIU_OSD2_BLK3_CFG_W4)
-#define VIU_OSD2_TEST_RDDATA 0x1a4c
-#define P_VIU_OSD2_TEST_RDDATA          VCBUS_REG_ADDR(VIU_OSD2_TEST_RDDATA)
-#define VIU_OSD2_PROT_CTRL 0x1a4e
-#define P_VIU_OSD2_PROT_CTRL            VCBUS_REG_ADDR(VIU_OSD2_PROT_CTRL)
-#define VD1_IF0_GEN_REG 0x1a50
-#define P_VD1_IF0_GEN_REG               VCBUS_REG_ADDR(VD1_IF0_GEN_REG)
-#define VD1_IF0_CANVAS0 0x1a51
-#define P_VD1_IF0_CANVAS0               VCBUS_REG_ADDR(VD1_IF0_CANVAS0)
-#define VD1_IF0_CANVAS1 0x1a52
-#define P_VD1_IF0_CANVAS1               VCBUS_REG_ADDR(VD1_IF0_CANVAS1)
-#define VD1_IF0_LUMA_X0 0x1a53
-#define P_VD1_IF0_LUMA_X0               VCBUS_REG_ADDR(VD1_IF0_LUMA_X0)
-#define VD1_IF0_LUMA_Y0 0x1a54
-#define P_VD1_IF0_LUMA_Y0               VCBUS_REG_ADDR(VD1_IF0_LUMA_Y0)
-#define VD1_IF0_CHROMA_X0 0x1a55
-#define P_VD1_IF0_CHROMA_X0             VCBUS_REG_ADDR(VD1_IF0_CHROMA_X0)
-#define VD1_IF0_CHROMA_Y0 0x1a56
-#define P_VD1_IF0_CHROMA_Y0             VCBUS_REG_ADDR(VD1_IF0_CHROMA_Y0)
-#define VD1_IF0_LUMA_X1 0x1a57
-#define P_VD1_IF0_LUMA_X1               VCBUS_REG_ADDR(VD1_IF0_LUMA_X1)
-#define VD1_IF0_LUMA_Y1 0x1a58
-#define P_VD1_IF0_LUMA_Y1               VCBUS_REG_ADDR(VD1_IF0_LUMA_Y1)
-#define VD1_IF0_CHROMA_X1 0x1a59
-#define P_VD1_IF0_CHROMA_X1             VCBUS_REG_ADDR(VD1_IF0_CHROMA_X1)
-#define VD1_IF0_CHROMA_Y1 0x1a5a
-#define P_VD1_IF0_CHROMA_Y1             VCBUS_REG_ADDR(VD1_IF0_CHROMA_Y1)
-#define VD1_IF0_RPT_LOOP 0x1a5b
-#define P_VD1_IF0_RPT_LOOP              VCBUS_REG_ADDR(VD1_IF0_RPT_LOOP)
-
-#define VD1_IF0_LUMA_PSEL 0x1a60
-#define P_VD1_IF0_LUMA_PSEL             VCBUS_REG_ADDR(VD1_IF0_LUMA_PSEL)
-#define VD1_IF0_CHROMA_PSEL 0x1a61
-#define P_VD1_IF0_CHROMA_PSEL           VCBUS_REG_ADDR(VD1_IF0_CHROMA_PSEL)
-#define VD1_IF0_DUMMY_PIXEL 0x1a62
-#define P_VD1_IF0_DUMMY_PIXEL           VCBUS_REG_ADDR(VD1_IF0_DUMMY_PIXEL)
-#define VD1_IF0_RANGE_MAP_Y 0x1a6a
-#define P_VD1_IF0_RANGE_MAP_Y           VCBUS_REG_ADDR(VD1_IF0_RANGE_MAP_Y)
-#define VD1_IF0_RANGE_MAP_CB 0x1a6b
-#define P_VD1_IF0_RANGE_MAP_CB          VCBUS_REG_ADDR(VD1_IF0_RANGE_MAP_CB)
-#define VD1_IF0_RANGE_MAP_CR 0x1a6c
-#define P_VD1_IF0_RANGE_MAP_CR          VCBUS_REG_ADDR(VD1_IF0_RANGE_MAP_CR)
-#define VD1_IF0_GEN_REG2 0x1a6d
-#define P_VD1_IF0_GEN_REG2              VCBUS_REG_ADDR(VD1_IF0_GEN_REG2)
-#define VD1_IF0_PROT_CNTL 0x1a6e
-#define P_VD1_IF0_PROT_CNTL             VCBUS_REG_ADDR(VD1_IF0_PROT_CNTL)
-#define VIU_VD1_FMT_CTRL 0x1a68
-#define P_VIU_VD1_FMT_CTRL              VCBUS_REG_ADDR(VIU_VD1_FMT_CTRL)
-#define VIU_VD1_FMT_W 0x1a69
-#define P_VIU_VD1_FMT_W                 VCBUS_REG_ADDR(VIU_VD1_FMT_W)
-#define VD2_IF0_GEN_REG 0x1a70
-#define P_VD2_IF0_GEN_REG               VCBUS_REG_ADDR(VD2_IF0_GEN_REG)
-#define VD2_IF0_CANVAS0 0x1a71
-#define P_VD2_IF0_CANVAS0               VCBUS_REG_ADDR(VD2_IF0_CANVAS0)
-#define VD2_IF0_CANVAS1 0x1a72
-#define P_VD2_IF0_CANVAS1               VCBUS_REG_ADDR(VD2_IF0_CANVAS1)
-#define VD2_IF0_LUMA_X0 0x1a73
-#define P_VD2_IF0_LUMA_X0               VCBUS_REG_ADDR(VD2_IF0_LUMA_X0)
-#define VD2_IF0_LUMA_Y0 0x1a74
-#define P_VD2_IF0_LUMA_Y0               VCBUS_REG_ADDR(VD2_IF0_LUMA_Y0)
-#define VD2_IF0_CHROMA_X0 0x1a75
-#define P_VD2_IF0_CHROMA_X0             VCBUS_REG_ADDR(VD2_IF0_CHROMA_X0)
-#define VD2_IF0_CHROMA_Y0 0x1a76
-#define P_VD2_IF0_CHROMA_Y0             VCBUS_REG_ADDR(VD2_IF0_CHROMA_Y0)
-#define VD2_IF0_LUMA_X1 0x1a77
-#define P_VD2_IF0_LUMA_X1               VCBUS_REG_ADDR(VD2_IF0_LUMA_X1)
-#define VD2_IF0_LUMA_Y1 0x1a78
-#define P_VD2_IF0_LUMA_Y1               VCBUS_REG_ADDR(VD2_IF0_LUMA_Y1)
-#define VD2_IF0_CHROMA_X1 0x1a79
-#define P_VD2_IF0_CHROMA_X1             VCBUS_REG_ADDR(VD2_IF0_CHROMA_X1)
-#define VD2_IF0_CHROMA_Y1 0x1a7a
-#define P_VD2_IF0_CHROMA_Y1             VCBUS_REG_ADDR(VD2_IF0_CHROMA_Y1)
-
-#define VD2_IF0_LUMA_PSEL 0x1a80
-#define P_VD2_IF0_LUMA_PSEL             VCBUS_REG_ADDR(VD2_IF0_LUMA_PSEL)
-#define VD2_IF0_CHROMA_PSEL 0x1a81
-#define P_VD2_IF0_CHROMA_PSEL           VCBUS_REG_ADDR(VD2_IF0_CHROMA_PSEL)
-#define VD2_IF0_DUMMY_PIXEL 0x1a82
-#define P_VD2_IF0_DUMMY_PIXEL           VCBUS_REG_ADDR(VD2_IF0_DUMMY_PIXEL)
-#define VD2_IF0_LUMA_FIFO_SIZE 0x1a83
-#define P_VD2_IF0_RANGE_MAP_Y           VCBUS_REG_ADDR(VD2_IF0_RANGE_MAP_Y)
-#define VD2_IF0_RANGE_MAP_CB 0x1a8b
-#define P_VD2_IF0_RANGE_MAP_CB          VCBUS_REG_ADDR(VD2_IF0_RANGE_MAP_CB)
-#define VD2_IF0_RANGE_MAP_CR 0x1a8c
-#define P_VD2_IF0_RANGE_MAP_CR          VCBUS_REG_ADDR(VD2_IF0_RANGE_MAP_CR)
-#define VD2_IF0_GEN_REG2 0x1a8d
-#define P_VD2_IF0_GEN_REG2              VCBUS_REG_ADDR(VD2_IF0_GEN_REG2)
-#define VD2_IF0_PROT_CNTL 0x1a8e
-#define P_VD2_IF0_PROT_CNTL             VCBUS_REG_ADDR(VD2_IF0_PROT_CNTL)
-#define VIU_VD2_FMT_CTRL 0x1a88
-#define P_VIU_VD2_FMT_CTRL              VCBUS_REG_ADDR(VIU_VD2_FMT_CTRL)
-#define VIU_VD2_FMT_W 0x1a89
-#define P_VIU_VD2_FMT_W                 VCBUS_REG_ADDR(VIU_VD2_FMT_W)
-#define LDIM_STTS_GCLK_CTRL0 0x1a90
-#define P_LDIM_STTS_GCLK_CTRL0          VCBUS_REG_ADDR(LDIM_STTS_GCLK_CTRL0)
-#define LDIM_STTS_CTRL0 0x1a91
-#define P_LDIM_STTS_CTRL0               VCBUS_REG_ADDR(LDIM_STTS_CTRL0)
-
-#define DI_PRE_CTRL 0x1700
-#define P_DI_PRE_CTRL           VCBUS_REG_ADDR(DI_PRE_CTRL)
-#define DI_POST_CTRL 0x1701
-#define P_DI_POST_CTRL          VCBUS_REG_ADDR(DI_POST_CTRL)
-#define DI_POST_SIZE 0x1702
-#define P_DI_POST_SIZE          VCBUS_REG_ADDR(DI_POST_SIZE)
-#define DI_PRE_SIZE 0x1703
-#define P_DI_PRE_SIZE           VCBUS_REG_ADDR(DI_PRE_SIZE)
-#define DI_EI_CTRL0 0x1704
-#define P_DI_EI_CTRL0           VCBUS_REG_ADDR(DI_EI_CTRL0)
-#define DI_EI_CTRL1 0x1705
-#define P_DI_EI_CTRL1           VCBUS_REG_ADDR(DI_EI_CTRL1)
-#define DI_EI_CTRL2 0x1706
-#define P_DI_EI_CTRL2           VCBUS_REG_ADDR(DI_EI_CTRL2)
-#define DI_NR_CTRL0 0x1707
-#define P_DI_NR_CTRL0           VCBUS_REG_ADDR(DI_NR_CTRL0)
-#define DI_NR_CTRL1 0x1708
-#define P_DI_NR_CTRL1           VCBUS_REG_ADDR(DI_NR_CTRL1)
-#define DI_NR_CTRL2 0x1709
-#define P_DI_NR_CTRL2           VCBUS_REG_ADDR(DI_NR_CTRL2)
-#define DI_NR_CTRL3 0x170a
-#define P_DI_NR_CTRL3           VCBUS_REG_ADDR(DI_NR_CTRL3)
-#define DI_MTN_CTRL 0x170b
-#define P_DI_MTN_CTRL           VCBUS_REG_ADDR(DI_MTN_CTRL)
-#define DI_MTN_CTRL1 0x170c
-#define P_DI_MTN_CTRL1          VCBUS_REG_ADDR(DI_MTN_CTRL1)
-#define DI_BLEND_CTRL 0x170d
-#define P_DI_BLEND_CTRL                 VCBUS_REG_ADDR(DI_BLEND_CTRL)
-#define DI_BLEND_CTRL1 0x170e
-#define P_DI_BLEND_CTRL1                VCBUS_REG_ADDR(DI_BLEND_CTRL1)
-#define DI_BLEND_CTRL2 0x170f
-#define P_DI_BLEND_CTRL2                VCBUS_REG_ADDR(DI_BLEND_CTRL2)
-#define DI_BLEND_REG0_X 0x1710
-#define P_DI_BLEND_REG0_X               VCBUS_REG_ADDR(DI_BLEND_REG0_X)
-#define DI_BLEND_REG0_Y 0x1711
-#define P_DI_BLEND_REG0_Y               VCBUS_REG_ADDR(DI_BLEND_REG0_Y)
-#define DI_BLEND_REG1_X 0x1712
-#define P_DI_BLEND_REG1_X               VCBUS_REG_ADDR(DI_BLEND_REG1_X)
-#define DI_BLEND_REG1_Y 0x1713
-#define P_DI_BLEND_REG1_Y               VCBUS_REG_ADDR(DI_BLEND_REG1_Y)
-#define DI_BLEND_REG2_X 0x1714
-#define P_DI_BLEND_REG2_X               VCBUS_REG_ADDR(DI_BLEND_REG2_X)
-#define DI_BLEND_REG2_Y 0x1715
-#define P_DI_BLEND_REG2_Y               VCBUS_REG_ADDR(DI_BLEND_REG2_Y)
-#define DI_BLEND_REG3_X 0x1716
-#define P_DI_BLEND_REG3_X               VCBUS_REG_ADDR(DI_BLEND_REG3_X)
-#define DI_BLEND_REG3_Y 0x1717
-#define P_DI_BLEND_REG3_Y               VCBUS_REG_ADDR(DI_BLEND_REG3_Y)
-#define DI_CLKG_CTRL 0x1718
-#define P_DI_CLKG_CTRL          VCBUS_REG_ADDR(DI_CLKG_CTRL)
-#define DI_EI_CTRL3 0x1719
-#define P_DI_EI_CTRL3           VCBUS_REG_ADDR(DI_EI_CTRL3)
-#define DI_EI_CTRL4 0x171a
-#define P_DI_EI_CTRL4           VCBUS_REG_ADDR(DI_EI_CTRL4)
-#define DI_EI_CTRL5 0x171b
-#define P_DI_EI_CTRL5           VCBUS_REG_ADDR(DI_EI_CTRL5)
-#define DI_EI_CTRL6 0x171c
-#define P_DI_EI_CTRL6           VCBUS_REG_ADDR(DI_EI_CTRL6)
-#define DI_EI_CTRL7 0x171d
-#define P_DI_EI_CTRL7           VCBUS_REG_ADDR(DI_EI_CTRL7)
-#define DI_EI_CTRL8 0x171e
-#define P_DI_EI_CTRL8           VCBUS_REG_ADDR(DI_EI_CTRL8)
-#define DI_EI_CTRL9 0x171f
-#define P_DI_EI_CTRL9           VCBUS_REG_ADDR(DI_EI_CTRL9)
-#define DI_EI_CTRL10 0x1793
-#define P_DI_EI_CTRL10          VCBUS_REG_ADDR(DI_EI_CTRL10)
-#define DI_EI_CTRL11 0x179e
-#define P_DI_EI_CTRL11          VCBUS_REG_ADDR(DI_EI_CTRL11)
-#define DI_EI_CTRL12 0x179f
-#define P_DI_EI_CTRL12          VCBUS_REG_ADDR(DI_EI_CTRL12)
-#define DI_EI_CTRL13 0x17a8
-#define P_DI_EI_CTRL13          VCBUS_REG_ADDR(DI_EI_CTRL13)
-#define DI_EI_XWIN0 0x1798
-#define P_DI_EI_XWIN0           VCBUS_REG_ADDR(DI_EI_XWIN0)
-#define DI_EI_XWIN1 0x1799
-#define P_DI_EI_XWIN1           VCBUS_REG_ADDR(DI_EI_XWIN1)
-#define DI_MC_REG0_X 0x1720
-#define P_DI_MC_REG0_X          VCBUS_REG_ADDR(DI_MC_REG0_X)
-#define DI_MC_REG0_Y 0x1721
-#define P_DI_MC_REG0_Y          VCBUS_REG_ADDR(DI_MC_REG0_Y)
-#define DI_MC_REG1_X 0x1722
-#define P_DI_MC_REG1_X          VCBUS_REG_ADDR(DI_MC_REG1_X)
-#define DI_MC_REG1_Y 0x1723
-#define P_DI_MC_REG1_Y          VCBUS_REG_ADDR(DI_MC_REG1_Y)
-#define DI_MC_REG2_X 0x1724
-#define P_DI_MC_REG2_X          VCBUS_REG_ADDR(DI_MC_REG2_X)
-#define DI_MC_REG2_Y 0x1725
-#define P_DI_MC_REG2_Y          VCBUS_REG_ADDR(DI_MC_REG2_Y)
-#define DI_MC_REG3_X 0x1726
-#define P_DI_MC_REG3_X          VCBUS_REG_ADDR(DI_MC_REG3_X)
-#define DI_MC_REG3_Y 0x1727
-#define P_DI_MC_REG3_Y          VCBUS_REG_ADDR(DI_MC_REG3_Y)
-#define DI_MC_REG4_X 0x1728
-#define P_DI_MC_REG4_X          VCBUS_REG_ADDR(DI_MC_REG4_X)
-#define DI_MC_REG4_Y 0x1729
-#define P_DI_MC_REG4_Y          VCBUS_REG_ADDR(DI_MC_REG4_Y)
-#define DI_MC_32LVL0 0x172a
-#define P_DI_MC_32LVL0          VCBUS_REG_ADDR(DI_MC_32LVL0)
-#define DI_MC_32LVL1 0x172b
-#define P_DI_MC_32LVL1          VCBUS_REG_ADDR(DI_MC_32LVL1)
-#define DI_MC_22LVL0 0x172c
-#define P_DI_MC_22LVL0          VCBUS_REG_ADDR(DI_MC_22LVL0)
-#define DI_MC_22LVL1 0x172d
-#define P_DI_MC_22LVL1          VCBUS_REG_ADDR(DI_MC_22LVL1)
-#define DI_MC_22LVL2 0x172e
-#define P_DI_MC_22LVL2          VCBUS_REG_ADDR(DI_MC_22LVL2)
-#define DI_MC_CTRL 0x172f
-#define P_DI_MC_CTRL            VCBUS_REG_ADDR(DI_MC_CTRL)
-#define DI_INTR_CTRL 0x1730
-#define P_DI_INTR_CTRL          VCBUS_REG_ADDR(DI_INTR_CTRL)
-#define DI_INFO_ADDR 0x1731
-#define P_DI_INFO_ADDR          VCBUS_REG_ADDR(DI_INFO_ADDR)
-#define DI_INFO_DATA 0x1732
-#define P_DI_INFO_DATA          VCBUS_REG_ADDR(DI_INFO_DATA)
-#define DI_PRE_HOLD 0x1733
-#define P_DI_PRE_HOLD           VCBUS_REG_ADDR(DI_PRE_HOLD)
-#define DI_MTN_1_CTRL1 0x1740
-#define P_DI_MTN_1_CTRL1                VCBUS_REG_ADDR(DI_MTN_1_CTRL1)
-#define DI_MTN_1_CTRL2 0x1741
-#define P_DI_MTN_1_CTRL2                VCBUS_REG_ADDR(DI_MTN_1_CTRL2)
-#define DI_MTN_1_CTRL3 0x1742
-#define P_DI_MTN_1_CTRL3                VCBUS_REG_ADDR(DI_MTN_1_CTRL3)
-#define DI_MTN_1_CTRL4 0x1743
-#define P_DI_MTN_1_CTRL4                VCBUS_REG_ADDR(DI_MTN_1_CTRL4)
-#define DI_MTN_1_CTRL5 0x1744
-#define P_DI_MTN_1_CTRL5                VCBUS_REG_ADDR(DI_MTN_1_CTRL5)
-#define DI_MTN_1_CTRL6 0x17a9
-#define P_DI_MTN_1_CTRL6                VCBUS_REG_ADDR(DI_MTN_1_CTRL6)
-#define DI_MTN_1_CTRL7 0x17aa
-#define P_DI_MTN_1_CTRL7                VCBUS_REG_ADDR(DI_MTN_1_CTRL7)
-#define DI_MTN_1_CTRL8 0x17ab
-#define P_DI_MTN_1_CTRL8                VCBUS_REG_ADDR(DI_MTN_1_CTRL8)
-#define DI_MTN_1_CTRL9 0x17ac
-#define P_DI_MTN_1_CTRL9                VCBUS_REG_ADDR(DI_MTN_1_CTRL9)
-#define DI_MTN_1_CTRL10 0x17ad
-#define P_DI_MTN_1_CTRL10               VCBUS_REG_ADDR(DI_MTN_1_CTRL10)
-#define DI_MTN_1_CTRL11 0x17ae
-#define P_DI_MTN_1_CTRL11               VCBUS_REG_ADDR(DI_MTN_1_CTRL11)
-#define DI_MTN_1_CTRL12 0x17af
-#define P_DI_MTN_1_CTRL12               VCBUS_REG_ADDR(DI_MTN_1_CTRL12)
-#define DET3D_MOTN_CFG 0x1734
-#define P_DET3D_MOTN_CFG                VCBUS_REG_ADDR(DET3D_MOTN_CFG)
-#define DET3D_CB_CFG 0x1735
-#define P_DET3D_CB_CFG          VCBUS_REG_ADDR(DET3D_CB_CFG)
-#define DET3D_SPLT_CFG 0x1736
-#define P_DET3D_SPLT_CFG                VCBUS_REG_ADDR(DET3D_SPLT_CFG)
-#define DET3D_HV_MUTE 0x1737
-#define P_DET3D_HV_MUTE                 VCBUS_REG_ADDR(DET3D_HV_MUTE)
-#define DET3D_MAT_STA_P1M1 0x1738
-#define P_DET3D_MAT_STA_P1M1            VCBUS_REG_ADDR(DET3D_MAT_STA_P1M1)
-#define DET3D_MAT_STA_P1TH 0x1739
-#define P_DET3D_MAT_STA_P1TH            VCBUS_REG_ADDR(DET3D_MAT_STA_P1TH)
-#define DET3D_MAT_STA_M1TH 0x173a
-#define P_DET3D_MAT_STA_M1TH            VCBUS_REG_ADDR(DET3D_MAT_STA_M1TH)
-#define DET3D_MAT_STA_RSFT 0x173b
-#define P_DET3D_MAT_STA_RSFT            VCBUS_REG_ADDR(DET3D_MAT_STA_RSFT)
-#define DET3D_MAT_SYMTC_TH 0x173c
-#define P_DET3D_MAT_SYMTC_TH            VCBUS_REG_ADDR(DET3D_MAT_SYMTC_TH)
-#define DET3D_RO_DET_CB_HOR 0x173d
-#define P_DET3D_RO_DET_CB_HOR           VCBUS_REG_ADDR(DET3D_RO_DET_CB_HOR)
-#define DET3D_RO_DET_CB_VER 0x173e
-#define P_DET3D_RO_DET_CB_VER           VCBUS_REG_ADDR(DET3D_RO_DET_CB_VER)
-#define DET3D_RO_SPLT_HT 0x173f
-#define P_DET3D_RO_SPLT_HT              VCBUS_REG_ADDR(DET3D_RO_SPLT_HT)
-#define NR2_MET_NM_CTRL 0x1745
-#define P_NR2_MET_NM_CTRL               VCBUS_REG_ADDR(NR2_MET_NM_CTRL)
-#define NR2_MET_NM_YCTRL 0x1746
-#define P_NR2_MET_NM_YCTRL              VCBUS_REG_ADDR(NR2_MET_NM_YCTRL)
-#define NR2_MET_NM_CCTRL 0x1747
-#define P_NR2_MET_NM_CCTRL              VCBUS_REG_ADDR(NR2_MET_NM_CCTRL)
-
-#define NR2_MATNR_SNR_EDGE2B 0x1757
-#define P_NR2_MATNR_SNR_EDGE2B          VCBUS_REG_ADDR(NR2_MATNR_SNR_EDGE2B)
-#define NR2_MATNR_BETA_EGAIN 0x1758
-#define P_NR2_MATNR_BETA_EGAIN          VCBUS_REG_ADDR(NR2_MATNR_BETA_EGAIN)
-#define NR2_MATNR_BETA_BRT 0x1759
-#define P_NR2_MATNR_BETA_BRT            VCBUS_REG_ADDR(NR2_MATNR_BETA_BRT)
-#define NR2_MATNR_XBETA_CFG 0x175a
-#define P_NR2_MATNR_XBETA_CFG           VCBUS_REG_ADDR(NR2_MATNR_XBETA_CFG)
-#define NR2_MATNR_YBETA_SCL 0x175b
-#define P_NR2_MATNR_YBETA_SCL           VCBUS_REG_ADDR(NR2_MATNR_YBETA_SCL)
-#define NR2_MATNR_CBETA_SCL 0x175c
-#define P_NR2_MATNR_CBETA_SCL           VCBUS_REG_ADDR(NR2_MATNR_CBETA_SCL)
-#define NR2_SNR_MASK 0x175d
-#define P_NR2_SNR_MASK          VCBUS_REG_ADDR(NR2_SNR_MASK)
-#define NR2_SAD2NORM_LUT0 0x175e
-#define P_NR2_SAD2NORM_LUT0             VCBUS_REG_ADDR(NR2_SAD2NORM_LUT0)
-#define NR2_SAD2NORM_LUT1 0x175f
-#define P_NR2_SAD2NORM_LUT1             VCBUS_REG_ADDR(NR2_SAD2NORM_LUT1)
-#define NR2_SAD2NORM_LUT2 0x1760
-#define P_NR2_SAD2NORM_LUT2             VCBUS_REG_ADDR(NR2_SAD2NORM_LUT2)
-#define NR2_SAD2NORM_LUT3 0x1761
-#define P_NR2_SAD2NORM_LUT3             VCBUS_REG_ADDR(NR2_SAD2NORM_LUT3)
-#define NR2_EDGE2BETA_LUT0 0x1762
-#define P_NR2_EDGE2BETA_LUT0            VCBUS_REG_ADDR(NR2_EDGE2BETA_LUT0)
-#define NR2_EDGE2BETA_LUT1 0x1763
-#define P_NR2_EDGE2BETA_LUT1            VCBUS_REG_ADDR(NR2_EDGE2BETA_LUT1)
-#define NR2_EDGE2BETA_LUT2 0x1764
-#define P_NR2_EDGE2BETA_LUT2            VCBUS_REG_ADDR(NR2_EDGE2BETA_LUT2)
-#define NR2_EDGE2BETA_LUT3 0x1765
-#define P_NR2_EDGE2BETA_LUT3            VCBUS_REG_ADDR(NR2_EDGE2BETA_LUT3)
-#define NR2_MOTION2BETA_LUT0 0x1766
-#define P_NR2_MOTION2BETA_LUT0          VCBUS_REG_ADDR(NR2_MOTION2BETA_LUT0)
-#define NR2_MOTION2BETA_LUT1 0x1767
-#define P_NR2_MOTION2BETA_LUT1          VCBUS_REG_ADDR(NR2_MOTION2BETA_LUT1)
-#define NR2_MOTION2BETA_LUT2 0x1768
-#define P_NR2_MOTION2BETA_LUT2          VCBUS_REG_ADDR(NR2_MOTION2BETA_LUT2)
-#define NR2_MOTION2BETA_LUT3 0x1769
-#define P_NR2_MOTION2BETA_LUT3          VCBUS_REG_ADDR(NR2_MOTION2BETA_LUT3)
-#define NR2_MATNR_MTN_CRTL 0x176a
-#define P_NR2_MATNR_MTN_CRTL            VCBUS_REG_ADDR(NR2_MATNR_MTN_CRTL)
-#define NR2_MATNR_MTN_CRTL2 0x176b
-#define P_NR2_MATNR_MTN_CRTL2           VCBUS_REG_ADDR(NR2_MATNR_MTN_CRTL2)
-#define NR2_MATNR_MTN_COR 0x176c
-#define P_NR2_MATNR_MTN_COR             VCBUS_REG_ADDR(NR2_MATNR_MTN_COR)
-#define NR2_MATNR_MTN_GAIN 0x176d
-#define P_NR2_MATNR_MTN_GAIN            VCBUS_REG_ADDR(NR2_MATNR_MTN_GAIN)
-#define NR2_MATNR_DEGHOST 0x176e
-#define P_NR2_MATNR_DEGHOST             VCBUS_REG_ADDR(NR2_MATNR_DEGHOST)
-#define NR2_MATNR_MTNB_BRT 0x1777
-#define P_NR2_MATNR_MTNB_BRT            VCBUS_REG_ADDR(NR2_MATNR_MTNB_BRT)
-#define NR2_CUE_MODE 0x1778
-#define P_NR2_CUE_MODE          VCBUS_REG_ADDR(NR2_CUE_MODE)
-#define NR2_CUE_CON_MOT_TH 0x1779
-#define P_NR2_CUE_CON_MOT_TH            VCBUS_REG_ADDR(NR2_CUE_CON_MOT_TH)
-#define NR2_CUE_CON_DIF0 0x177a
-#define P_NR2_CUE_CON_DIF0              VCBUS_REG_ADDR(NR2_CUE_CON_DIF0)
-#define NR2_CUE_CON_DIF1 0x177b
-#define P_NR2_CUE_CON_DIF1              VCBUS_REG_ADDR(NR2_CUE_CON_DIF1)
-#define NR2_CUE_CON_DIF2 0x177c
-#define P_NR2_CUE_CON_DIF2              VCBUS_REG_ADDR(NR2_CUE_CON_DIF2)
-#define NR2_CUE_CON_DIF3 0x177d
-#define P_NR2_CUE_CON_DIF3              VCBUS_REG_ADDR(NR2_CUE_CON_DIF3)
-#define NR2_CUE_PRG_DIF 0x177e
-#define P_NR2_CUE_PRG_DIF               VCBUS_REG_ADDR(NR2_CUE_PRG_DIF)
-#define NR2_CONV_MODE 0x177f
-#define P_NR2_CONV_MODE                 VCBUS_REG_ADDR(NR2_CONV_MODE)
-#define DET3D_RO_SPLT_HB 0x1780
-#define P_DET3D_RO_SPLT_HB              VCBUS_REG_ADDR(DET3D_RO_SPLT_HB)
-#define DET3D_RO_SPLT_VL 0x1781
-#define P_DET3D_RO_SPLT_VL              VCBUS_REG_ADDR(DET3D_RO_SPLT_VL)
-#define DET3D_RO_SPLT_VR 0x1782
-#define P_DET3D_RO_SPLT_VR              VCBUS_REG_ADDR(DET3D_RO_SPLT_VR)
-#define DET3D_RO_MAT_LUMA_LR 0x1783
-#define P_DET3D_RO_MAT_LUMA_LR          VCBUS_REG_ADDR(DET3D_RO_MAT_LUMA_LR)
-#define DET3D_RO_MAT_LUMA_TB 0x1784
-#define P_DET3D_RO_MAT_LUMA_TB          VCBUS_REG_ADDR(DET3D_RO_MAT_LUMA_TB)
-#define DET3D_RO_MAT_CHRU_LR 0x1785
-#define P_DET3D_RO_MAT_CHRU_LR          VCBUS_REG_ADDR(DET3D_RO_MAT_CHRU_LR)
-#define DET3D_RO_MAT_CHRU_TB 0x1786
-#define P_DET3D_RO_MAT_CHRU_TB          VCBUS_REG_ADDR(DET3D_RO_MAT_CHRU_TB)
-#define DET3D_RO_MAT_CHRV_LR 0x1787
-#define P_DET3D_RO_MAT_CHRV_LR          VCBUS_REG_ADDR(DET3D_RO_MAT_CHRV_LR)
-#define NR2_CFR_PARA_CFG0 0x179c
-#define P_NR2_CFR_PARA_CFG0             VCBUS_REG_ADDR(NR2_CFR_PARA_CFG0)
-#define NR2_CFR_PARA_CFG1 0x179d
-#define P_NR2_CFR_PARA_CFG1             VCBUS_REG_ADDR(NR2_CFR_PARA_CFG1)
-#define DI_NR_1_CTRL0 0x1794
-#define P_DI_NR_1_CTRL0                 VCBUS_REG_ADDR(DI_NR_1_CTRL0)
-#define DI_NR_1_CTRL1 0x1795
-#define P_DI_NR_1_CTRL1                 VCBUS_REG_ADDR(DI_NR_1_CTRL1)
-#define DI_NR_1_CTRL2 0x1796
-#define P_DI_NR_1_CTRL2                 VCBUS_REG_ADDR(DI_NR_1_CTRL2)
-#define DI_NR_1_CTRL3 0x1797
-#define P_DI_NR_1_CTRL3                 VCBUS_REG_ADDR(DI_NR_1_CTRL3)
-#define DI_CONTWR_X 0x17a0
-#define P_DI_CONTWR_X           VCBUS_REG_ADDR(DI_CONTWR_X)
-#define DI_CONTWR_Y 0x17a1
-#define P_DI_CONTWR_Y           VCBUS_REG_ADDR(DI_CONTWR_Y)
-#define DI_CONTWR_CTRL 0x17a2
-#define P_DI_CONTWR_CTRL                VCBUS_REG_ADDR(DI_CONTWR_CTRL)
-#define DI_CONTPRD_X 0x17a3
-#define P_DI_CONTPRD_X          VCBUS_REG_ADDR(DI_CONTPRD_X)
-#define DI_CONTPRD_Y 0x17a4
-#define P_DI_CONTPRD_Y          VCBUS_REG_ADDR(DI_CONTPRD_Y)
-#define DI_CONTP2RD_X 0x17a5
-#define P_DI_CONTP2RD_X                 VCBUS_REG_ADDR(DI_CONTP2RD_X)
-#define DI_CONTP2RD_Y 0x17a6
-#define P_DI_CONTP2RD_Y                 VCBUS_REG_ADDR(DI_CONTP2RD_Y)
-#define DI_CONTRD_CTRL 0x17a7
-#define P_DI_CONTRD_CTRL                VCBUS_REG_ADDR(DI_CONTRD_CTRL)
-#define DI_NRWR_X 0x17c0
-#define P_DI_NRWR_X             VCBUS_REG_ADDR(DI_NRWR_X)
-#define DI_NRWR_Y 0x17c1
-#define P_DI_NRWR_Y             VCBUS_REG_ADDR(DI_NRWR_Y)
-#define DI_NRWR_CTRL 0x17c2
-#define P_DI_NRWR_CTRL          VCBUS_REG_ADDR(DI_NRWR_CTRL)
-#define DI_MTNWR_X 0x17c3
-#define P_DI_MTNWR_X            VCBUS_REG_ADDR(DI_MTNWR_X)
-#define DI_MTNWR_Y 0x17c4
-#define P_DI_MTNWR_Y            VCBUS_REG_ADDR(DI_MTNWR_Y)
-#define DI_MTNWR_CTRL 0x17c5
-#define P_DI_MTNWR_CTRL                 VCBUS_REG_ADDR(DI_MTNWR_CTRL)
-#define DI_DIWR_X 0x17c6
-#define P_DI_DIWR_X             VCBUS_REG_ADDR(DI_DIWR_X)
-#define DI_DIWR_Y 0x17c7
-#define P_DI_DIWR_Y             VCBUS_REG_ADDR(DI_DIWR_Y)
-#define DI_DIWR_CTRL 0x17c8
-#define P_DI_DIWR_CTRL          VCBUS_REG_ADDR(DI_DIWR_CTRL)
-#define DI_MTNCRD_X 0x17c9
-#define P_DI_MTNCRD_X           VCBUS_REG_ADDR(DI_MTNCRD_X)
-#define DI_MTNCRD_Y 0x17ca
-#define P_DI_MTNCRD_Y           VCBUS_REG_ADDR(DI_MTNCRD_Y)
-#define DI_MTNPRD_X 0x17cb
-#define P_DI_MTNPRD_X           VCBUS_REG_ADDR(DI_MTNPRD_X)
-#define DI_MTNPRD_Y 0x17cc
-#define P_DI_MTNPRD_Y           VCBUS_REG_ADDR(DI_MTNPRD_Y)
-#define DI_MTNRD_CTRL 0x17cd
-#define P_DI_MTNRD_CTRL                 VCBUS_REG_ADDR(DI_MTNRD_CTRL)
-#define DI_INP_GEN_REG 0x17ce
-#define P_DI_INP_GEN_REG                VCBUS_REG_ADDR(DI_INP_GEN_REG)
-#define DI_INP_CANVAS0 0x17cf
-#define P_DI_INP_CANVAS0                VCBUS_REG_ADDR(DI_INP_CANVAS0)
-#define DI_INP_LUMA_X0 0x17d0
-#define P_DI_INP_LUMA_X0                VCBUS_REG_ADDR(DI_INP_LUMA_X0)
-#define DI_INP_LUMA_Y0 0x17d1
-#define P_DI_INP_LUMA_Y0                VCBUS_REG_ADDR(DI_INP_LUMA_Y0)
-#define DI_INP_CHROMA_X0 0x17d2
-#define P_DI_INP_CHROMA_X0              VCBUS_REG_ADDR(DI_INP_CHROMA_X0)
-#define DI_INP_CHROMA_Y0 0x17d3
-#define P_DI_INP_CHROMA_Y0              VCBUS_REG_ADDR(DI_INP_CHROMA_Y0)
-#define DI_INP_RPT_LOOP 0x17d4
-#define P_DI_INP_RPT_LOOP               VCBUS_REG_ADDR(DI_INP_RPT_LOOP)
-#define DI_INP_LUMA0_RPT_PAT 0x17d5
-#define P_DI_INP_LUMA0_RPT_PAT          VCBUS_REG_ADDR(DI_INP_LUMA0_RPT_PAT)
-#define DI_INP_CHROMA0_RPT_PAT 0x17d6
-
-#define DI_INP_RANGE_MAP_Y 0x17ba
-#define P_DI_INP_RANGE_MAP_Y            VCBUS_REG_ADDR(DI_INP_RANGE_MAP_Y)
-#define DI_INP_RANGE_MAP_CB 0x17bb
-#define P_DI_INP_RANGE_MAP_CB           VCBUS_REG_ADDR(DI_INP_RANGE_MAP_CB)
-#define DI_INP_RANGE_MAP_CR 0x17bc
-#define P_DI_INP_RANGE_MAP_CR           VCBUS_REG_ADDR(DI_INP_RANGE_MAP_CR)
-#define DI_INP_GEN_REG2 0x1791
-#define P_DI_INP_GEN_REG2               VCBUS_REG_ADDR(DI_INP_GEN_REG2)
-#define DI_INP_FMT_CTRL 0x17d9
-#define P_DI_INP_FMT_CTRL               VCBUS_REG_ADDR(DI_INP_FMT_CTRL)
-#define DI_INP_FMT_W 0x17da
-#define P_DI_INP_FMT_W          VCBUS_REG_ADDR(DI_INP_FMT_W)
-#define DI_MEM_GEN_REG 0x17db
-#define P_DI_MEM_GEN_REG                VCBUS_REG_ADDR(DI_MEM_GEN_REG)
-#define DI_MEM_CANVAS0 0x17dc
-#define P_DI_MEM_CANVAS0                VCBUS_REG_ADDR(DI_MEM_CANVAS0)
-#define DI_MEM_LUMA_X0 0x17dd
-#define P_DI_MEM_LUMA_X0                VCBUS_REG_ADDR(DI_MEM_LUMA_X0)
-#define DI_MEM_LUMA_Y0 0x17de
-#define P_DI_MEM_LUMA_Y0                VCBUS_REG_ADDR(DI_MEM_LUMA_Y0)
-#define DI_MEM_CHROMA_X0 0x17df
-#define P_DI_MEM_CHROMA_X0              VCBUS_REG_ADDR(DI_MEM_CHROMA_X0)
-#define DI_MEM_CHROMA_Y0 0x17e0
-#define P_DI_MEM_CHROMA_Y0              VCBUS_REG_ADDR(DI_MEM_CHROMA_Y0)
-#define DI_MEM_RPT_LOOP 0x17e1
-#define P_DI_MEM_RPT_LOOP               VCBUS_REG_ADDR(DI_MEM_RPT_LOOP)
-
-#define DI_MEM_RANGE_MAP_Y 0x17bd
-#define P_DI_MEM_RANGE_MAP_Y            VCBUS_REG_ADDR(DI_MEM_RANGE_MAP_Y)
-#define DI_MEM_RANGE_MAP_CB 0x17be
-#define P_DI_MEM_RANGE_MAP_CB           VCBUS_REG_ADDR(DI_MEM_RANGE_MAP_CB)
-#define DI_MEM_RANGE_MAP_CR 0x17bf
-#define P_DI_MEM_RANGE_MAP_CR           VCBUS_REG_ADDR(DI_MEM_RANGE_MAP_CR)
-#define DI_MEM_GEN_REG2 0x1792
-#define P_DI_MEM_GEN_REG2               VCBUS_REG_ADDR(DI_MEM_GEN_REG2)
-#define DI_MEM_FMT_CTRL 0x17e6
-#define P_DI_MEM_FMT_CTRL               VCBUS_REG_ADDR(DI_MEM_FMT_CTRL)
-#define DI_MEM_FMT_W 0x17e7
-#define P_DI_MEM_FMT_W          VCBUS_REG_ADDR(DI_MEM_FMT_W)
-#define DI_IF1_GEN_REG 0x17e8
-#define P_DI_IF1_GEN_REG                VCBUS_REG_ADDR(DI_IF1_GEN_REG)
-#define DI_IF1_CANVAS0 0x17e9
-#define P_DI_IF1_CANVAS0                VCBUS_REG_ADDR(DI_IF1_CANVAS0)
-#define DI_IF1_LUMA_X0 0x17ea
-#define P_DI_IF1_LUMA_X0                VCBUS_REG_ADDR(DI_IF1_LUMA_X0)
-#define DI_IF1_LUMA_Y0 0x17eb
-#define P_DI_IF1_LUMA_Y0                VCBUS_REG_ADDR(DI_IF1_LUMA_Y0)
-#define DI_IF1_CHROMA_X0 0x17ec
-#define P_DI_IF1_CHROMA_X0              VCBUS_REG_ADDR(DI_IF1_CHROMA_X0)
-#define DI_IF1_CHROMA_Y0 0x17ed
-#define P_DI_IF1_CHROMA_Y0              VCBUS_REG_ADDR(DI_IF1_CHROMA_Y0)
-#define DI_IF1_RPT_LOOP 0x17ee
-#define P_DI_IF1_RPT_LOOP               VCBUS_REG_ADDR(DI_IF1_RPT_LOOP)
-#define DI_IF1_LUMA0_RPT_PAT 0x17ef
-#define P_DI_IF1_LUMA0_RPT_PAT          VCBUS_REG_ADDR(DI_IF1_LUMA0_RPT_PAT)
-#define DI_IF1_CHROMA0_RPT_PAT 0x17f0
-#define P_DI_IF1_DUMMY_PIXEL            VCBUS_REG_ADDR(DI_IF1_DUMMY_PIXEL)
-#define DI_IF1_LUMA_FIFO_SIZE 0x17f2
-
-#define DI_CHAN2_GEN_REG2 0x17b7
-#define P_DI_CHAN2_GEN_REG2             VCBUS_REG_ADDR(DI_CHAN2_GEN_REG2)
-#define DI_CHAN2_FMT_CTRL 0x17b8
-#define P_DI_CHAN2_FMT_CTRL             VCBUS_REG_ADDR(DI_CHAN2_FMT_CTRL)
-#define DI_CHAN2_FMT_W 0x17b9
-#define P_DI_CHAN2_FMT_W                VCBUS_REG_ADDR(DI_CHAN2_FMT_W)
-#define VIU2_ADDR_START 0x1e00
-#define P_VIU2_ADDR_START               VCBUS_REG_ADDR(VIU2_ADDR_START)
-#define VIU2_ADDR_END 0x1eff
-#define P_VIU2_ADDR_END                 VCBUS_REG_ADDR(VIU2_ADDR_END)
-#define VIU2_SW_RESET 0x1e01
-#define P_VIU2_SW_RESET                 VCBUS_REG_ADDR(VIU2_SW_RESET)
-#define VIU2_OSD1_CTRL_STAT 0x1e10
-#define P_VIU2_OSD1_CTRL_STAT           VCBUS_REG_ADDR(VIU2_OSD1_CTRL_STAT)
-#define VIU2_OSD1_CTRL_STAT2 0x1e2d
-#define P_VIU2_OSD1_CTRL_STAT2          VCBUS_REG_ADDR(VIU2_OSD1_CTRL_STAT2)
-#define VIU2_OSD1_COLOR_ADDR 0x1e11
-#define P_VIU2_OSD1_COLOR_ADDR          VCBUS_REG_ADDR(VIU2_OSD1_COLOR_ADDR)
-#define VIU2_OSD1_COLOR 0x1e12
-#define P_VIU2_OSD1_COLOR               VCBUS_REG_ADDR(VIU2_OSD1_COLOR)
-#define VIU2_OSD1_TCOLOR_AG0 0x1e17
-#define P_VIU2_OSD1_TCOLOR_AG0          VCBUS_REG_ADDR(VIU2_OSD1_TCOLOR_AG0)
-#define VIU2_OSD1_TCOLOR_AG1 0x1e18
-#define P_VIU2_OSD1_TCOLOR_AG1          VCBUS_REG_ADDR(VIU2_OSD1_TCOLOR_AG1)
-#define VIU2_OSD1_TCOLOR_AG2 0x1e19
-#define P_VIU2_OSD1_TCOLOR_AG2          VCBUS_REG_ADDR(VIU2_OSD1_TCOLOR_AG2)
-#define VIU2_OSD1_TCOLOR_AG3 0x1e1a
-#define P_VIU2_OSD1_TCOLOR_AG3          VCBUS_REG_ADDR(VIU2_OSD1_TCOLOR_AG3)
-
-
-#define VENC_SYNC_ROUTE 0x1b60
-#define P_VENC_SYNC_ROUTE               VCBUS_REG_ADDR(VENC_SYNC_ROUTE)
-#define VENC_VIDEO_EXSRC 0x1b61
-#define P_VENC_VIDEO_EXSRC              VCBUS_REG_ADDR(VENC_VIDEO_EXSRC)
-#define VENC_DVI_SETTING 0x1b62
-#define P_VENC_DVI_SETTING              VCBUS_REG_ADDR(VENC_DVI_SETTING)
-#define VENC_C656_CTRL 0x1b63
-#define P_VENC_C656_CTRL                VCBUS_REG_ADDR(VENC_C656_CTRL)
-#define VENC_UPSAMPLE_CTRL0 0x1b64
-#define P_VENC_UPSAMPLE_CTRL0           VCBUS_REG_ADDR(VENC_UPSAMPLE_CTRL0)
-#define VENC_UPSAMPLE_CTRL1 0x1b65
-#define P_VENC_UPSAMPLE_CTRL1           VCBUS_REG_ADDR(VENC_UPSAMPLE_CTRL1)
-#define VENC_UPSAMPLE_CTRL2 0x1b66
-#define P_VENC_UPSAMPLE_CTRL2           VCBUS_REG_ADDR(VENC_UPSAMPLE_CTRL2)
-#define TCON_INVERT_CTL 0x1b67
-#define P_TCON_INVERT_CTL               VCBUS_REG_ADDR(TCON_INVERT_CTL)
-#define VENC_VIDEO_PROG_MODE 0x1b68
-#define P_VENC_VIDEO_PROG_MODE          VCBUS_REG_ADDR(VENC_VIDEO_PROG_MODE)
-#define VENC_ENCI_LINE 0x1b69
-#define P_VENC_ENCI_LINE                VCBUS_REG_ADDR(VENC_ENCI_LINE)
-#define VENC_ENCI_PIXEL 0x1b6a
-#define P_VENC_ENCI_PIXEL               VCBUS_REG_ADDR(VENC_ENCI_PIXEL)
-#define VENC_ENCP_LINE 0x1b6b
-#define P_VENC_ENCP_LINE                VCBUS_REG_ADDR(VENC_ENCP_LINE)
-#define VENC_ENCP_PIXEL 0x1b6c
-#define P_VENC_ENCP_PIXEL               VCBUS_REG_ADDR(VENC_ENCP_PIXEL)
-#define VENC_STATA 0x1b6d
-#define P_VENC_STATA            VCBUS_REG_ADDR(VENC_STATA)
-#define VENC_INTCTRL 0x1b6e
-#define P_VENC_INTCTRL          VCBUS_REG_ADDR(VENC_INTCTRL)
-#define VENC_INTFLAG 0x1b6f
-#define P_VENC_INTFLAG          VCBUS_REG_ADDR(VENC_INTFLAG)
-#define VENC_VIDEO_TST_EN 0x1b70
-#define P_VENC_VIDEO_TST_EN             VCBUS_REG_ADDR(VENC_VIDEO_TST_EN)
-#define VENC_VIDEO_TST_MDSEL 0x1b71
-#define P_VENC_VIDEO_TST_MDSEL          VCBUS_REG_ADDR(VENC_VIDEO_TST_MDSEL)
-#define VENC_VIDEO_TST_Y 0x1b72
-#define P_VENC_VIDEO_TST_Y              VCBUS_REG_ADDR(VENC_VIDEO_TST_Y)
-#define VENC_VIDEO_TST_CB 0x1b73
-#define P_VENC_VIDEO_TST_CB             VCBUS_REG_ADDR(VENC_VIDEO_TST_CB)
-#define VENC_VIDEO_TST_CR 0x1b74
-#define P_VENC_VIDEO_TST_CR             VCBUS_REG_ADDR(VENC_VIDEO_TST_CR)
-#define VENC_VIDEO_TST_CLRBAR_STRT 0x1b75
-#define VENC_VDAC_FIFO_CTRL 0x1bfc
-#define P_VENC_VDAC_FIFO_CTRL           VCBUS_REG_ADDR(VENC_VDAC_FIFO_CTRL)
-#define ENCL_TCON_INVERT_CTL 0x1bfd
-#define P_ENCL_TCON_INVERT_CTL          VCBUS_REG_ADDR(ENCL_TCON_INVERT_CTL)
-#define ENCP_VIDEO_EN 0x1b80
-#define P_ENCP_VIDEO_EN                 VCBUS_REG_ADDR(ENCP_VIDEO_EN)
-#define ENCP_VIDEO_SYNC_MODE 0x1b81
-#define P_ENCP_VIDEO_SYNC_MODE          VCBUS_REG_ADDR(ENCP_VIDEO_SYNC_MODE)
-#define ENCP_MACV_EN 0x1b82
-#define P_ENCP_MACV_EN          VCBUS_REG_ADDR(ENCP_MACV_EN)
-#define ENCP_VIDEO_Y_SCL 0x1b83
-#define P_ENCP_VIDEO_Y_SCL              VCBUS_REG_ADDR(ENCP_VIDEO_Y_SCL)
-#define ENCP_VIDEO_PB_SCL 0x1b84
-#define P_ENCP_VIDEO_PB_SCL             VCBUS_REG_ADDR(ENCP_VIDEO_PB_SCL)
-#define ENCP_VIDEO_PR_SCL 0x1b85
-#define P_ENCP_VIDEO_PR_SCL             VCBUS_REG_ADDR(ENCP_VIDEO_PR_SCL)
-#define ENCP_VIDEO_SYNC_SCL 0x1b86
-#define P_ENCP_VIDEO_SYNC_SCL           VCBUS_REG_ADDR(ENCP_VIDEO_SYNC_SCL)
-#define ENCP_VIDEO_MACV_SCL 0x1b87
-#define P_ENCP_VIDEO_MACV_SCL           VCBUS_REG_ADDR(ENCP_VIDEO_MACV_SCL)
-#define ENCP_VIDEO_Y_OFFST 0x1b88
-#define P_ENCP_VIDEO_Y_OFFST            VCBUS_REG_ADDR(ENCP_VIDEO_Y_OFFST)
-#define ENCP_VIDEO_PB_OFFST 0x1b89
-#define P_ENCP_VIDEO_PB_OFFST           VCBUS_REG_ADDR(ENCP_VIDEO_PB_OFFST)
-#define ENCP_VIDEO_PR_OFFST 0x1b8a
-#define P_ENCP_VIDEO_PR_OFFST           VCBUS_REG_ADDR(ENCP_VIDEO_PR_OFFST)
-#define ENCP_VIDEO_MACV_OFFST 0x1b8c
-#define ENCP_VIDEO_MODE 0x1b8d
-#define P_ENCP_VIDEO_MODE               VCBUS_REG_ADDR(ENCP_VIDEO_MODE)
-#define ENCP_VIDEO_MODE_ADV 0x1b8e
-#define P_ENCP_VIDEO_MODE_ADV           VCBUS_REG_ADDR(ENCP_VIDEO_MODE_ADV)
-#define ENCP_DBG_PX_RST 0x1b90
-#define P_ENCP_DBG_PX_RST               VCBUS_REG_ADDR(ENCP_DBG_PX_RST)
-#define ENCP_DBG_LN_RST 0x1b91
-#define P_ENCP_DBG_LN_RST               VCBUS_REG_ADDR(ENCP_DBG_LN_RST)
-#define ENCP_DBG_PX_INT 0x1b92
-#define P_ENCP_DBG_PX_INT               VCBUS_REG_ADDR(ENCP_DBG_PX_INT)
-#define ENCP_DBG_LN_INT 0x1b93
-#define P_ENCP_DBG_LN_INT               VCBUS_REG_ADDR(ENCP_DBG_LN_INT)
-#define ENCP_VIDEO_YFP1_HTIME 0x1b94
-#define ENCP_VIDEO_YFP2_HTIME 0x1b95
-#define ENCP_VIDEO_YC_DLY 0x1b96
-#define P_ENCP_VIDEO_YC_DLY             VCBUS_REG_ADDR(ENCP_VIDEO_YC_DLY)
-#define ENCP_VIDEO_MAX_PXCNT 0x1b97
-#define P_ENCP_VIDEO_MAX_PXCNT          VCBUS_REG_ADDR(ENCP_VIDEO_MAX_PXCNT)
-#define ENCP_VIDEO_HSO_END 0x1ba8
-#define P_ENCP_VIDEO_HSO_END            VCBUS_REG_ADDR(ENCP_VIDEO_HSO_END)
-#define ENCP_VIDEO_VSO_BEGIN 0x1ba9
-#define P_ENCP_VIDEO_VSO_BEGIN          VCBUS_REG_ADDR(ENCP_VIDEO_VSO_BEGIN)
-#define ENCP_VIDEO_VSO_END 0x1baa
-#define P_ENCP_VIDEO_VSO_END            VCBUS_REG_ADDR(ENCP_VIDEO_VSO_END)
-#define ENCP_VIDEO_VSO_BLINE 0x1bab
-#define P_ENCP_VIDEO_VSO_BLINE          VCBUS_REG_ADDR(ENCP_VIDEO_VSO_BLINE)
-#define ENCP_VIDEO_VSO_ELINE 0x1bac
-#define P_ENCP_VIDEO_VSO_ELINE          VCBUS_REG_ADDR(ENCP_VIDEO_VSO_ELINE)
-#define ENCP_VIDEO_SYNC_WAVE_CURVE 0x1bad
-#define ENCP_VIDEO_MAX_LNCNT 0x1bae
-#define P_ENCP_VIDEO_MAX_LNCNT          VCBUS_REG_ADDR(ENCP_VIDEO_MAX_LNCNT)
-#define ENCP_VIDEO_SY_VAL 0x1bb0
-#define P_ENCP_VIDEO_SY_VAL             VCBUS_REG_ADDR(ENCP_VIDEO_SY_VAL)
-#define ENCP_VIDEO_SY2_VAL 0x1bb1
-#define P_ENCP_VIDEO_SY2_VAL            VCBUS_REG_ADDR(ENCP_VIDEO_SY2_VAL)
-#define ENCP_VIDEO_BLANKY_VAL 0x1bb2
-#define ENCP_VIDEO_HOFFST 0x1bb5
-#define P_ENCP_VIDEO_HOFFST             VCBUS_REG_ADDR(ENCP_VIDEO_HOFFST)
-#define ENCP_VIDEO_VOFFST 0x1bb6
-#define P_ENCP_VIDEO_VOFFST             VCBUS_REG_ADDR(ENCP_VIDEO_VOFFST)
-#define ENCP_VIDEO_RGB_CTRL 0x1bb7
-#define P_ENCP_VIDEO_RGB_CTRL           VCBUS_REG_ADDR(ENCP_VIDEO_RGB_CTRL)
-#define ENCP_VIDEO_FILT_CTRL 0x1bb8
-#define P_ENCP_VIDEO_FILT_CTRL          VCBUS_REG_ADDR(ENCP_VIDEO_FILT_CTRL)
-#define ENCP_VIDEO_OFLD_VPEQ_OFST 0x1bb9
-#define ENCP_MACV_TIME_DOWN 0x1bcb
-#define P_ENCP_MACV_TIME_DOWN           VCBUS_REG_ADDR(ENCP_MACV_TIME_DOWN)
-#define ENCP_MACV_TIME_LO 0x1bcc
-#define P_ENCP_MACV_TIME_LO             VCBUS_REG_ADDR(ENCP_MACV_TIME_LO)
-#define ENCP_MACV_TIME_UP 0x1bcd
-#define P_ENCP_MACV_TIME_UP             VCBUS_REG_ADDR(ENCP_MACV_TIME_UP)
-#define ENCP_MACV_TIME_RST 0x1bce
-#define P_ENCP_MACV_TIME_RST            VCBUS_REG_ADDR(ENCP_MACV_TIME_RST)
-#define ENCP_VBI_CTRL 0x1bd0
-#define P_ENCP_VBI_CTRL                 VCBUS_REG_ADDR(ENCP_VBI_CTRL)
-#define ENCP_VBI_SETTING 0x1bd1
-#define P_ENCP_VBI_SETTING              VCBUS_REG_ADDR(ENCP_VBI_SETTING)
-#define ENCP_VBI_BEGIN 0x1bd2
-#define P_ENCP_VBI_BEGIN                VCBUS_REG_ADDR(ENCP_VBI_BEGIN)
-#define ENCP_VBI_WIDTH 0x1bd3
-#define P_ENCP_VBI_WIDTH                VCBUS_REG_ADDR(ENCP_VBI_WIDTH)
-#define ENCP_VBI_HVAL 0x1bd4
-#define P_ENCP_VBI_HVAL                 VCBUS_REG_ADDR(ENCP_VBI_HVAL)
-#define ENCP_VBI_DATA0 0x1bd5
-#define P_ENCP_VBI_DATA0                VCBUS_REG_ADDR(ENCP_VBI_DATA0)
-#define ENCP_VBI_DATA1 0x1bd6
-#define P_ENCP_VBI_DATA1                VCBUS_REG_ADDR(ENCP_VBI_DATA1)
-#define C656_HS_ST 0x1be0
-#define P_C656_HS_ST            VCBUS_REG_ADDR(C656_HS_ST)
-#define C656_HS_ED 0x1be1
-#define P_C656_HS_ED            VCBUS_REG_ADDR(C656_HS_ED)
-#define C656_VS_LNST_E 0x1be2
-#define P_C656_VS_LNST_E                VCBUS_REG_ADDR(C656_VS_LNST_E)
-#define C656_VS_LNST_O 0x1be3
-#define P_C656_VS_LNST_O                VCBUS_REG_ADDR(C656_VS_LNST_O)
-#define C656_VS_LNED_E 0x1be4
-#define P_C656_VS_LNED_E                VCBUS_REG_ADDR(C656_VS_LNED_E)
-#define C656_VS_LNED_O 0x1be5
-#define P_C656_VS_LNED_O                VCBUS_REG_ADDR(C656_VS_LNED_O)
-#define C656_FS_LNST 0x1be6
-#define P_C656_FS_LNST          VCBUS_REG_ADDR(C656_FS_LNST)
-#define C656_FS_LNED 0x1be7
-#define P_C656_FS_LNED          VCBUS_REG_ADDR(C656_FS_LNED)
-#define ENCI_VIDEO_MODE 0x1b00
-#define P_ENCI_VIDEO_MODE               VCBUS_REG_ADDR(ENCI_VIDEO_MODE)
-#define ENCI_VIDEO_MODE_ADV 0x1b01
-#define P_ENCI_VIDEO_MODE_ADV           VCBUS_REG_ADDR(ENCI_VIDEO_MODE_ADV)
-#define ENCI_VIDEO_FSC_ADJ 0x1b02
-#define P_ENCI_VIDEO_FSC_ADJ            VCBUS_REG_ADDR(ENCI_VIDEO_FSC_ADJ)
-#define ENCI_VIDEO_BRIGHT 0x1b03
-#define P_ENCI_VIDEO_BRIGHT             VCBUS_REG_ADDR(ENCI_VIDEO_BRIGHT)
-#define ENCI_VIDEO_CONT 0x1b04
-#define P_ENCI_VIDEO_CONT               VCBUS_REG_ADDR(ENCI_VIDEO_CONT)
-#define ENCI_VIDEO_SAT 0x1b05
-#define P_ENCI_VIDEO_SAT                VCBUS_REG_ADDR(ENCI_VIDEO_SAT)
-#define ENCI_VIDEO_HUE 0x1b06
-#define P_ENCI_VIDEO_HUE                VCBUS_REG_ADDR(ENCI_VIDEO_HUE)
-#define ENCI_VIDEO_SCH 0x1b07
-#define P_ENCI_VIDEO_SCH                VCBUS_REG_ADDR(ENCI_VIDEO_SCH)
-#define ENCI_SYNC_MODE 0x1b08
-#define P_ENCI_SYNC_MODE                VCBUS_REG_ADDR(ENCI_SYNC_MODE)
-#define ENCI_SYNC_CTRL 0x1b09
-#define P_ENCI_SYNC_CTRL                VCBUS_REG_ADDR(ENCI_SYNC_CTRL)
-#define ENCI_SYNC_HSO_BEGIN 0x1b0a
-#define P_ENCI_SYNC_HSO_BEGIN           VCBUS_REG_ADDR(ENCI_SYNC_HSO_BEGIN)
-#define ENCI_SYNC_HSO_END 0x1b0b
-#define P_ENCI_SYNC_HSO_END             VCBUS_REG_ADDR(ENCI_SYNC_HSO_END)
-#define ENCI_SYNC_VSO_EVN 0x1b0c
-#define P_ENCI_SYNC_VSO_EVN             VCBUS_REG_ADDR(ENCI_SYNC_VSO_EVN)
-#define ENCI_SYNC_VSO_ODD 0x1b0d
-#define P_ENCI_SYNC_VSO_ODD             VCBUS_REG_ADDR(ENCI_SYNC_VSO_ODD)
-#define ENCI_SYNC_VSO_EVNLN 0x1b0e
-#define P_ENCI_SYNC_VSO_EVNLN           VCBUS_REG_ADDR(ENCI_SYNC_VSO_EVNLN)
-#define ENCI_SYNC_VSO_ODDLN 0x1b0f
-#define P_ENCI_SYNC_VSO_ODDLN           VCBUS_REG_ADDR(ENCI_SYNC_VSO_ODDLN)
-#define ENCI_SYNC_HOFFST 0x1b10
-#define P_ENCI_SYNC_HOFFST              VCBUS_REG_ADDR(ENCI_SYNC_HOFFST)
-#define ENCI_SYNC_VOFFST 0x1b11
-#define P_ENCI_SYNC_VOFFST              VCBUS_REG_ADDR(ENCI_SYNC_VOFFST)
-#define ENCI_SYNC_ADJ 0x1b12
-#define P_ENCI_SYNC_ADJ                 VCBUS_REG_ADDR(ENCI_SYNC_ADJ)
-#define ENCI_RGB_SETTING 0x1b13
-#define P_ENCI_RGB_SETTING              VCBUS_REG_ADDR(ENCI_RGB_SETTING)
-#define ENCI_DE_H_BEGIN 0x1b16
-#define P_ENCI_DE_H_BEGIN               VCBUS_REG_ADDR(ENCI_DE_H_BEGIN)
-#define ENCI_DE_H_END 0x1b17
-#define P_ENCI_DE_H_END                 VCBUS_REG_ADDR(ENCI_DE_H_END)
-#define ENCI_DE_V_BEGIN_EVEN 0x1b18
-#define P_ENCI_DE_V_BEGIN_EVEN          VCBUS_REG_ADDR(ENCI_DE_V_BEGIN_EVEN)
-#define ENCI_DE_V_END_EVEN 0x1b19
-#define P_ENCI_DE_V_END_EVEN            VCBUS_REG_ADDR(ENCI_DE_V_END_EVEN)
-#define ENCI_DE_V_BEGIN_ODD 0x1b1a
-#define P_ENCI_DE_V_BEGIN_ODD           VCBUS_REG_ADDR(ENCI_DE_V_BEGIN_ODD)
-#define ENCI_DE_V_END_ODD 0x1b1b
-#define P_ENCI_DE_V_END_ODD             VCBUS_REG_ADDR(ENCI_DE_V_END_ODD)
-#define ENCI_VBI_SETTING 0x1b20
-#define P_ENCI_VBI_SETTING              VCBUS_REG_ADDR(ENCI_VBI_SETTING)
-#define ENCI_VBI_CCDT_EVN 0x1b21
-#define P_ENCI_VBI_CCDT_EVN             VCBUS_REG_ADDR(ENCI_VBI_CCDT_EVN)
-#define ENCI_VBI_CCDT_ODD 0x1b22
-#define P_ENCI_VBI_CCDT_ODD             VCBUS_REG_ADDR(ENCI_VBI_CCDT_ODD)
-#define ENCI_VBI_CC525_LN 0x1b23
-#define P_ENCI_VBI_CC525_LN             VCBUS_REG_ADDR(ENCI_VBI_CC525_LN)
-#define ENCI_VBI_CC625_LN 0x1b24
-#define P_ENCI_VBI_CC625_LN             VCBUS_REG_ADDR(ENCI_VBI_CC625_LN)
-#define ENCI_VBI_WSSDT 0x1b25
-#define P_ENCI_VBI_WSSDT                VCBUS_REG_ADDR(ENCI_VBI_WSSDT)
-#define ENCI_VBI_WSS_LN 0x1b26
-#define P_ENCI_VBI_WSS_LN               VCBUS_REG_ADDR(ENCI_VBI_WSS_LN)
-#define ENCI_VBI_CGMSDT_L 0x1b27
-#define P_ENCI_VBI_CGMSDT_L             VCBUS_REG_ADDR(ENCI_VBI_CGMSDT_L)
-#define ENCI_VBI_CGMSDT_H 0x1b28
-#define P_ENCI_VBI_CGMSDT_H             VCBUS_REG_ADDR(ENCI_VBI_CGMSDT_H)
-#define ENCI_VBI_CGMS_LN 0x1b29
-#define P_ENCI_VBI_CGMS_LN              VCBUS_REG_ADDR(ENCI_VBI_CGMS_LN)
-#define ENCI_VBI_TTX_HTIME 0x1b2a
-#define P_ENCI_VBI_TTX_HTIME            VCBUS_REG_ADDR(ENCI_VBI_TTX_HTIME)
-#define ENCI_VBI_TTX_LN 0x1b2b
-#define P_ENCI_VBI_TTX_LN               VCBUS_REG_ADDR(ENCI_VBI_TTX_LN)
-#define ENCI_VBI_TTXDT0 0x1b2c
-#define P_ENCI_VBI_TTXDT0               VCBUS_REG_ADDR(ENCI_VBI_TTXDT0)
-#define ENCI_VBI_TTXDT1 0x1b2d
-#define P_ENCI_VBI_TTXDT1               VCBUS_REG_ADDR(ENCI_VBI_TTXDT1)
-#define ENCI_VBI_TTXDT2 0x1b2e
-#define P_ENCI_VBI_TTXDT2               VCBUS_REG_ADDR(ENCI_VBI_TTXDT2)
-#define ENCI_VBI_TTXDT3 0x1b2f
-#define P_ENCI_VBI_TTXDT3               VCBUS_REG_ADDR(ENCI_VBI_TTXDT3)
-#define ENCI_MACV_N0 0x1b30
-#define P_ENCI_MACV_N0          VCBUS_REG_ADDR(ENCI_MACV_N0)
-#define ENCI_MACV_N1 0x1b31
-#define P_ENCI_MACV_N1          VCBUS_REG_ADDR(ENCI_MACV_N1)
-#define ENCI_MACV_N2 0x1b32
-#define P_ENCI_MACV_N2          VCBUS_REG_ADDR(ENCI_MACV_N2)
-#define ENCI_MACV_N3 0x1b33
-#define P_ENCI_MACV_N3          VCBUS_REG_ADDR(ENCI_MACV_N3)
-#define ENCI_MACV_N4 0x1b34
-#define P_ENCI_MACV_N4          VCBUS_REG_ADDR(ENCI_MACV_N4)
-#define ENCI_MACV_N5 0x1b35
-#define P_ENCI_MACV_N5          VCBUS_REG_ADDR(ENCI_MACV_N5)
-#define ENCI_MACV_N6 0x1b36
-#define P_ENCI_MACV_N6          VCBUS_REG_ADDR(ENCI_MACV_N6)
-#define ENCI_MACV_N7 0x1b37
-#define P_ENCI_MACV_N7          VCBUS_REG_ADDR(ENCI_MACV_N7)
-#define ENCI_MACV_N8 0x1b38
-#define P_ENCI_MACV_N8          VCBUS_REG_ADDR(ENCI_MACV_N8)
-#define ENCI_MACV_N9 0x1b39
-#define P_ENCI_MACV_N9          VCBUS_REG_ADDR(ENCI_MACV_N9)
-#define ENCI_MACV_N10 0x1b3a
-#define P_ENCI_MACV_N10                 VCBUS_REG_ADDR(ENCI_MACV_N10)
-#define ENCI_MACV_N11 0x1b3b
-#define P_ENCI_MACV_N11                 VCBUS_REG_ADDR(ENCI_MACV_N11)
-#define ENCI_MACV_N12 0x1b3c
-#define P_ENCI_MACV_N12                 VCBUS_REG_ADDR(ENCI_MACV_N12)
-#define ENCI_MACV_N13 0x1b3d
-#define P_ENCI_MACV_N13                 VCBUS_REG_ADDR(ENCI_MACV_N13)
-#define ENCI_MACV_N14 0x1b3e
-#define P_ENCI_MACV_N14                 VCBUS_REG_ADDR(ENCI_MACV_N14)
-#define ENCI_MACV_N15 0x1b3f
-#define P_ENCI_MACV_N15                 VCBUS_REG_ADDR(ENCI_MACV_N15)
-#define ENCI_MACV_N16 0x1b40
-#define P_ENCI_MACV_N16                 VCBUS_REG_ADDR(ENCI_MACV_N16)
-#define ENCI_MACV_N17 0x1b41
-#define P_ENCI_MACV_N17                 VCBUS_REG_ADDR(ENCI_MACV_N17)
-#define ENCI_MACV_N18 0x1b42
-#define P_ENCI_MACV_N18                 VCBUS_REG_ADDR(ENCI_MACV_N18)
-#define ENCI_MACV_N19 0x1b43
-#define P_ENCI_MACV_N19                 VCBUS_REG_ADDR(ENCI_MACV_N19)
-#define ENCI_MACV_N20 0x1b44
-#define P_ENCI_MACV_N20                 VCBUS_REG_ADDR(ENCI_MACV_N20)
-#define ENCI_MACV_N21 0x1b45
-#define P_ENCI_MACV_N21                 VCBUS_REG_ADDR(ENCI_MACV_N21)
-#define ENCI_MACV_N22 0x1b46
-#define P_ENCI_MACV_N22                 VCBUS_REG_ADDR(ENCI_MACV_N22)
-#define ENCI_DBG_PX_RST 0x1b48
-#define P_ENCI_DBG_PX_RST               VCBUS_REG_ADDR(ENCI_DBG_PX_RST)
-#define ENCI_DBG_FLDLN_RST 0x1b49
-#define P_ENCI_DBG_FLDLN_RST            VCBUS_REG_ADDR(ENCI_DBG_FLDLN_RST)
-#define ENCI_DBG_PX_INT 0x1b4a
-#define P_ENCI_DBG_PX_INT               VCBUS_REG_ADDR(ENCI_DBG_PX_INT)
-#define ENCI_DBG_FLDLN_INT 0x1b4b
-#define P_ENCI_DBG_FLDLN_INT            VCBUS_REG_ADDR(ENCI_DBG_FLDLN_INT)
-#define ENCI_DBG_MAXPX 0x1b4c
-#define P_ENCI_DBG_MAXPX                VCBUS_REG_ADDR(ENCI_DBG_MAXPX)
-#define ENCI_DBG_MAXLN 0x1b4d
-#define P_ENCI_DBG_MAXLN                VCBUS_REG_ADDR(ENCI_DBG_MAXLN)
-#define ENCI_MACV_MAX_AMP 0x1b50
-#define P_ENCI_MACV_MAX_AMP             VCBUS_REG_ADDR(ENCI_MACV_MAX_AMP)
-#define ENCI_MACV_PULSE_LO 0x1b51
-#define P_ENCI_MACV_PULSE_LO            VCBUS_REG_ADDR(ENCI_MACV_PULSE_LO)
-#define ENCI_MACV_PULSE_HI 0x1b52
-#define P_ENCI_MACV_PULSE_HI            VCBUS_REG_ADDR(ENCI_MACV_PULSE_HI)
-#define ENCI_MACV_BKP_MAX 0x1b53
-#define P_ENCI_MACV_BKP_MAX             VCBUS_REG_ADDR(ENCI_MACV_BKP_MAX)
-#define ENCI_CFILT_CTRL 0x1b54
-#define P_ENCI_CFILT_CTRL               VCBUS_REG_ADDR(ENCI_CFILT_CTRL)
-#define ENCI_CFILT7 0x1b55
-#define P_ENCI_CFILT7           VCBUS_REG_ADDR(ENCI_CFILT7)
-#define ENCI_YC_DELAY 0x1b56
-#define P_ENCI_YC_DELAY                 VCBUS_REG_ADDR(ENCI_YC_DELAY)
-#define ENCI_VIDEO_EN 0x1b57
-#define P_ENCI_VIDEO_EN                 VCBUS_REG_ADDR(ENCI_VIDEO_EN)
-#define ENCI_DVI_HSO_BEGIN 0x1c00
-#define P_ENCI_DVI_HSO_BEGIN            VCBUS_REG_ADDR(ENCI_DVI_HSO_BEGIN)
-#define ENCI_DVI_HSO_END 0x1c01
-#define P_ENCI_DVI_HSO_END              VCBUS_REG_ADDR(ENCI_DVI_HSO_END)
-#define ENCI_DVI_VSO_END_ODD 0x1c09
-#define P_ENCI_DVI_VSO_END_ODD          VCBUS_REG_ADDR(ENCI_DVI_VSO_END_ODD)
-#define ENCI_CFILT_CTRL2 0x1c0a
-#define P_ENCI_CFILT_CTRL2              VCBUS_REG_ADDR(ENCI_CFILT_CTRL2)
-#define ENCI_DACSEL_0 0x1c0b
-#define P_ENCI_DACSEL_0                 VCBUS_REG_ADDR(ENCI_DACSEL_0)
-#define ENCI_DACSEL_1 0x1c0c
-#define P_ENCI_DACSEL_1                 VCBUS_REG_ADDR(ENCI_DACSEL_1)
-#define ENCP_DACSEL_0 0x1c0d
-#define P_ENCP_DACSEL_0                 VCBUS_REG_ADDR(ENCP_DACSEL_0)
-#define ENCP_DACSEL_1 0x1c0e
-#define P_ENCP_DACSEL_1                 VCBUS_REG_ADDR(ENCP_DACSEL_1)
-#define ENCI_TST_EN 0x1c10
-#define P_ENCI_TST_EN           VCBUS_REG_ADDR(ENCI_TST_EN)
-#define ENCI_TST_MDSEL 0x1c11
-#define P_ENCI_TST_MDSEL                VCBUS_REG_ADDR(ENCI_TST_MDSEL)
-#define ENCI_TST_Y 0x1c12
-#define P_ENCI_TST_Y            VCBUS_REG_ADDR(ENCI_TST_Y)
-#define ENCI_TST_CB 0x1c13
-#define P_ENCI_TST_CB           VCBUS_REG_ADDR(ENCI_TST_CB)
-#define ENCI_TST_CR 0x1c14
-#define P_ENCI_TST_CR           VCBUS_REG_ADDR(ENCI_TST_CR)
-#define ENCI_TST_CLRBAR_STRT 0x1c15
-#define ENCT_VFIFO2VD_CTL2 0x1c27
-#define P_ENCT_VFIFO2VD_CTL2            VCBUS_REG_ADDR(ENCT_VFIFO2VD_CTL2)
-#define ENCT_TST_EN 0x1c28
-#define P_ENCT_TST_EN           VCBUS_REG_ADDR(ENCT_TST_EN)
-#define ENCT_TST_MDSEL 0x1c29
-#define P_ENCT_TST_MDSEL                VCBUS_REG_ADDR(ENCT_TST_MDSEL)
-#define ENCT_TST_Y 0x1c2a
-#define P_ENCT_TST_Y            VCBUS_REG_ADDR(ENCT_TST_Y)
-#define ENCT_TST_CB 0x1c2b
-#define P_ENCT_TST_CB           VCBUS_REG_ADDR(ENCT_TST_CB)
-#define ENCT_TST_CR 0x1c2c
-#define P_ENCT_TST_CR           VCBUS_REG_ADDR(ENCT_TST_CR)
-#define ENCT_TST_CLRBAR_STRT 0x1c2d
-#define P_ENCT_TST_CLRBAR_STRT          VCBUS_REG_ADDR(ENCT_TST_CLRBAR_STRT)
-#define ENCT_TST_CLRBAR_WIDTH 0x1c2e
-#define ENCT_TST_VDCNT_STSET 0x1c2f
-#define P_ENCT_TST_VDCNT_STSET          VCBUS_REG_ADDR(ENCT_TST_VDCNT_STSET)
-#define ENCP_DVI_HSO_BEGIN 0x1c30
-#define P_ENCP_DVI_HSO_BEGIN            VCBUS_REG_ADDR(ENCP_DVI_HSO_BEGIN)
-#define ENCP_DVI_HSO_END 0x1c31
-#define P_ENCP_DVI_HSO_END              VCBUS_REG_ADDR(ENCP_DVI_HSO_END)
-#define ENCP_DVI_VSO_END_EVN 0x1c38
-#define P_ENCP_DVI_VSO_END_EVN          VCBUS_REG_ADDR(ENCP_DVI_VSO_END_EVN)
-#define ENCP_DVI_VSO_END_ODD 0x1c39
-#define P_ENCP_DVI_VSO_END_ODD          VCBUS_REG_ADDR(ENCP_DVI_VSO_END_ODD)
-#define ENCP_DE_H_BEGIN 0x1c3a
-#define P_ENCP_DE_H_BEGIN               VCBUS_REG_ADDR(ENCP_DE_H_BEGIN)
-#define ENCP_DE_H_END 0x1c3b
-#define P_ENCP_DE_H_END                 VCBUS_REG_ADDR(ENCP_DE_H_END)
-#define ENCP_DE_V_BEGIN_EVEN 0x1c3c
-#define P_ENCP_DE_V_BEGIN_EVEN          VCBUS_REG_ADDR(ENCP_DE_V_BEGIN_EVEN)
-#define ENCP_DE_V_END_EVEN 0x1c3d
-#define P_ENCP_DE_V_END_EVEN            VCBUS_REG_ADDR(ENCP_DE_V_END_EVEN)
-#define ENCP_DE_V_BEGIN_ODD 0x1c3e
-#define P_ENCP_DE_V_BEGIN_ODD           VCBUS_REG_ADDR(ENCP_DE_V_BEGIN_ODD)
-#define ENCP_DE_V_END_ODD 0x1c3f
-#define P_ENCP_DE_V_END_ODD             VCBUS_REG_ADDR(ENCP_DE_V_END_ODD)
-
-#define ENCI_SYNC_PIXEL_EN 0x1c41
-#define P_ENCI_SYNC_PIXEL_EN            VCBUS_REG_ADDR(ENCI_SYNC_PIXEL_EN)
-#define ENCI_SYNC_TO_LINE_EN 0x1c42
-#define P_ENCI_SYNC_TO_LINE_EN          VCBUS_REG_ADDR(ENCI_SYNC_TO_LINE_EN)
-#define ENCI_SYNC_TO_PIXEL 0x1c43
-#define P_ENCI_SYNC_TO_PIXEL            VCBUS_REG_ADDR(ENCI_SYNC_TO_PIXEL)
-
-#define ENCT_VIDEO_EN 0x1c60
-#define P_ENCT_VIDEO_EN                 VCBUS_REG_ADDR(ENCT_VIDEO_EN)
-#define ENCT_VIDEO_Y_SCL 0x1c61
-#define P_ENCT_VIDEO_Y_SCL              VCBUS_REG_ADDR(ENCT_VIDEO_Y_SCL)
-#define ENCT_VIDEO_PB_SCL 0x1c62
-#define P_ENCT_VIDEO_PB_SCL             VCBUS_REG_ADDR(ENCT_VIDEO_PB_SCL)
-#define ENCT_VIDEO_PR_SCL 0x1c63
-#define P_ENCT_VIDEO_PR_SCL             VCBUS_REG_ADDR(ENCT_VIDEO_PR_SCL)
-#define ENCT_VIDEO_Y_OFFST 0x1c64
-#define P_ENCT_VIDEO_Y_OFFST            VCBUS_REG_ADDR(ENCT_VIDEO_Y_OFFST)
-#define ENCT_VIDEO_PB_OFFST 0x1c65
-#define P_ENCT_VIDEO_PB_OFFST           VCBUS_REG_ADDR(ENCT_VIDEO_PB_OFFST)
-#define ENCT_VIDEO_PR_OFFST 0x1c66
-#define P_ENCT_VIDEO_PR_OFFST           VCBUS_REG_ADDR(ENCT_VIDEO_PR_OFFST)
-#define ENCT_VIDEO_MODE 0x1c67
-#define P_ENCT_VIDEO_MODE               VCBUS_REG_ADDR(ENCT_VIDEO_MODE)
-#define ENCT_VIDEO_MODE_ADV 0x1c68
-#define P_ENCT_VIDEO_MODE_ADV           VCBUS_REG_ADDR(ENCT_VIDEO_MODE_ADV)
-#define ENCT_DBG_PX_RST 0x1c69
-#define P_ENCT_DBG_PX_RST               VCBUS_REG_ADDR(ENCT_DBG_PX_RST)
-#define ENCT_DBG_LN_RST 0x1c6a
-#define P_ENCT_DBG_LN_RST               VCBUS_REG_ADDR(ENCT_DBG_LN_RST)
-#define ENCT_DBG_PX_INT 0x1c6b
-#define P_ENCT_DBG_PX_INT               VCBUS_REG_ADDR(ENCT_DBG_PX_INT)
-#define ENCT_DBG_LN_INT 0x1c6c
-#define P_ENCT_DBG_LN_INT               VCBUS_REG_ADDR(ENCT_DBG_LN_INT)
-#define ENCL_TST_VDCNT_STSET 0x1c9f
-#define P_ENCL_TST_VDCNT_STSET          VCBUS_REG_ADDR(ENCL_TST_VDCNT_STSET)
-#define ENCL_VIDEO_EN 0x1ca0
-#define P_ENCL_VIDEO_EN                 VCBUS_REG_ADDR(ENCL_VIDEO_EN)
-#define ENCL_VIDEO_Y_SCL 0x1ca1
-#define P_ENCL_VIDEO_Y_SCL              VCBUS_REG_ADDR(ENCL_VIDEO_Y_SCL)
-#define ENCL_VIDEO_PB_SCL 0x1ca2
-#define P_ENCL_VIDEO_PB_SCL             VCBUS_REG_ADDR(ENCL_VIDEO_PB_SCL)
-#define ENCL_VIDEO_PR_SCL 0x1ca3
-#define P_ENCL_VIDEO_PR_SCL             VCBUS_REG_ADDR(ENCL_VIDEO_PR_SCL)
-#define ENCL_VIDEO_Y_OFFST 0x1ca4
-#define P_ENCL_VIDEO_Y_OFFST            VCBUS_REG_ADDR(ENCL_VIDEO_Y_OFFST)
-#define ENCL_VIDEO_PB_OFFST 0x1ca5
-#define P_ENCL_VIDEO_PB_OFFST           VCBUS_REG_ADDR(ENCL_VIDEO_PB_OFFST)
-#define ENCL_VIDEO_PR_OFFST 0x1ca6
-#define P_ENCL_VIDEO_PR_OFFST           VCBUS_REG_ADDR(ENCL_VIDEO_PR_OFFST)
-#define ENCL_VIDEO_MODE 0x1ca7
-#define P_ENCL_VIDEO_MODE               VCBUS_REG_ADDR(ENCL_VIDEO_MODE)
-#define ENCL_VIDEO_MODE_ADV 0x1ca8
-#define P_ENCL_VIDEO_MODE_ADV           VCBUS_REG_ADDR(ENCL_VIDEO_MODE_ADV)
-#define ENCL_DBG_PX_RST 0x1ca9
-#define P_ENCL_DBG_PX_RST               VCBUS_REG_ADDR(ENCL_DBG_PX_RST)
-#define ENCL_DBG_LN_RST 0x1caa
-#define P_ENCL_DBG_LN_RST               VCBUS_REG_ADDR(ENCL_DBG_LN_RST)
-#define ENCL_DBG_PX_INT 0x1cab
-#define P_ENCL_DBG_PX_INT               VCBUS_REG_ADDR(ENCL_DBG_PX_INT)
-#define ENCL_DBG_LN_INT 0x1cac
-#define P_ENCL_DBG_LN_INT               VCBUS_REG_ADDR(ENCL_DBG_LN_INT)
-#define ENCL_VIDEO_YC_DLY 0x1caf
-#define P_ENCL_VIDEO_YC_DLY             VCBUS_REG_ADDR(ENCL_VIDEO_YC_DLY)
-#define ENCL_VIDEO_MAX_PXCNT 0x1cb0
-#define P_ENCL_VIDEO_MAX_PXCNT          VCBUS_REG_ADDR(ENCL_VIDEO_MAX_PXCNT)
-#define ENCL_VIDEO_HAVON_END 0x1cb1
-#define P_ENCL_VIDEO_HAVON_END          VCBUS_REG_ADDR(ENCL_VIDEO_HAVON_END)
-#define ENCL_VIDEO_HSO_BEGIN 0x1cb5
-#define P_ENCL_VIDEO_HSO_BEGIN          VCBUS_REG_ADDR(ENCL_VIDEO_HSO_BEGIN)
-#define ENCL_VIDEO_HSO_END 0x1cb6
-#define P_ENCL_VIDEO_HSO_END            VCBUS_REG_ADDR(ENCL_VIDEO_HSO_END)
-#define ENCL_VIDEO_VSO_BEGIN 0x1cb7
-#define P_ENCL_VIDEO_VSO_BEGIN          VCBUS_REG_ADDR(ENCL_VIDEO_VSO_BEGIN)
-#define ENCL_VIDEO_VSO_END 0x1cb8
-#define P_ENCL_VIDEO_VSO_END            VCBUS_REG_ADDR(ENCL_VIDEO_VSO_END)
-#define ENCL_VIDEO_VSO_BLINE 0x1cb9
-#define P_ENCL_VIDEO_VSO_BLINE          VCBUS_REG_ADDR(ENCL_VIDEO_VSO_BLINE)
-#define ENCL_VIDEO_VSO_ELINE 0x1cba
-#define P_ENCL_VIDEO_VSO_ELINE          VCBUS_REG_ADDR(ENCL_VIDEO_VSO_ELINE)
-#define ENCL_VIDEO_MAX_LNCNT 0x1cbb
-#define P_ENCL_VIDEO_MAX_LNCNT          VCBUS_REG_ADDR(ENCL_VIDEO_MAX_LNCNT)
-#define ENCL_VIDEO_BLANKY_VAL 0x1cbc
-#define RDMA_AHB_END_ADDR_3 0x1cf7
-#define P_RDMA_AHB_END_ADDR_3           VCBUS_REG_ADDR(RDMA_AHB_END_ADDR_3)
-#define RDMA_ACCESS_AUTO 0x1cf8
-#define P_RDMA_ACCESS_AUTO              VCBUS_REG_ADDR(RDMA_ACCESS_AUTO)
-#define RDMA_ACCESS_MAN 0x1cf9
-#define P_RDMA_ACCESS_MAN               VCBUS_REG_ADDR(RDMA_ACCESS_MAN)
-#define RDMA_CTRL 0x1cfa
-#define P_RDMA_CTRL             VCBUS_REG_ADDR(RDMA_CTRL)
-#define RDMA_STATUS 0x1cfb
-#define P_RDMA_STATUS           VCBUS_REG_ADDR(RDMA_STATUS)
-#define L_GAMMA_CNTL_PORT 0x1400
-#define P_L_GAMMA_CNTL_PORT             VCBUS_REG_ADDR(L_GAMMA_CNTL_PORT)
-#define L_GAMMA_DATA_PORT 0x1401
-#define P_L_GAMMA_DATA_PORT             VCBUS_REG_ADDR(L_GAMMA_DATA_PORT)
-#define L_GAMMA_ADDR_PORT 0x1402
-#define P_L_GAMMA_ADDR_PORT             VCBUS_REG_ADDR(L_GAMMA_ADDR_PORT)
-#define L_GAMMA_VCOM_HSWITCH_ADDR 0x1403
-#define L_GAMMA_PROBE_POS_X 0x140d
-#define P_L_GAMMA_PROBE_POS_X           VCBUS_REG_ADDR(L_GAMMA_PROBE_POS_X)
-#define L_GAMMA_PROBE_POS_Y 0x140e
-#define P_L_GAMMA_PROBE_POS_Y           VCBUS_REG_ADDR(L_GAMMA_PROBE_POS_Y)
-#define L_STH1_HS_ADDR 0x1410
-#define P_L_STH1_HS_ADDR                VCBUS_REG_ADDR(L_STH1_HS_ADDR)
-#define L_STH1_HE_ADDR 0x1411
-#define P_L_STH1_HE_ADDR                VCBUS_REG_ADDR(L_STH1_HE_ADDR)
-#define L_STH1_VS_ADDR 0x1412
-#define P_L_STH1_VS_ADDR                VCBUS_REG_ADDR(L_STH1_VS_ADDR)
-#define L_STH1_VE_ADDR 0x1413
-#define P_L_STH1_VE_ADDR                VCBUS_REG_ADDR(L_STH1_VE_ADDR)
-#define L_STH2_HS_ADDR 0x1414
-#define P_L_STH2_HS_ADDR                VCBUS_REG_ADDR(L_STH2_HS_ADDR)
-#define L_STH2_HE_ADDR 0x1415
-#define P_L_STH2_HE_ADDR                VCBUS_REG_ADDR(L_STH2_HE_ADDR)
-#define L_STH2_VS_ADDR 0x1416
-#define P_L_STH2_VS_ADDR                VCBUS_REG_ADDR(L_STH2_VS_ADDR)
-#define L_STH2_VE_ADDR 0x1417
-#define P_L_STH2_VE_ADDR                VCBUS_REG_ADDR(L_STH2_VE_ADDR)
-#define L_OEH_HS_ADDR 0x1418
-#define P_L_OEH_HS_ADDR                 VCBUS_REG_ADDR(L_OEH_HS_ADDR)
-#define L_OEH_HE_ADDR 0x1419
-#define P_L_OEH_HE_ADDR                 VCBUS_REG_ADDR(L_OEH_HE_ADDR)
-#define L_OEH_VS_ADDR 0x141a
-#define P_L_OEH_VS_ADDR                 VCBUS_REG_ADDR(L_OEH_VS_ADDR)
-#define L_OEH_VE_ADDR 0x141b
-#define P_L_OEH_VE_ADDR                 VCBUS_REG_ADDR(L_OEH_VE_ADDR)
-#define L_VCOM_HSWITCH_ADDR 0x141c
-#define P_L_VCOM_HSWITCH_ADDR           VCBUS_REG_ADDR(L_VCOM_HSWITCH_ADDR)
-#define L_VCOM_VS_ADDR 0x141d
-#define P_L_VCOM_VS_ADDR                VCBUS_REG_ADDR(L_VCOM_VS_ADDR)
-#define L_VCOM_VE_ADDR 0x141e
-#define P_L_VCOM_VE_ADDR                VCBUS_REG_ADDR(L_VCOM_VE_ADDR)
-#define L_CPV1_HS_ADDR 0x141f
-#define P_L_CPV1_HS_ADDR                VCBUS_REG_ADDR(L_CPV1_HS_ADDR)
-#define L_CPV1_HE_ADDR 0x1420
-#define P_L_CPV1_HE_ADDR                VCBUS_REG_ADDR(L_CPV1_HE_ADDR)
-#define L_CPV1_VS_ADDR 0x1421
-#define P_L_CPV1_VS_ADDR                VCBUS_REG_ADDR(L_CPV1_VS_ADDR)
-#define L_CPV1_VE_ADDR 0x1422
-#define P_L_CPV1_VE_ADDR                VCBUS_REG_ADDR(L_CPV1_VE_ADDR)
-#define L_CPV2_HS_ADDR 0x1423
-#define P_L_CPV2_HS_ADDR                VCBUS_REG_ADDR(L_CPV2_HS_ADDR)
-#define L_CPV2_HE_ADDR 0x1424
-#define P_L_CPV2_HE_ADDR                VCBUS_REG_ADDR(L_CPV2_HE_ADDR)
-#define L_CPV2_VS_ADDR 0x1425
-#define P_L_CPV2_VS_ADDR                VCBUS_REG_ADDR(L_CPV2_VS_ADDR)
-#define L_CPV2_VE_ADDR 0x1426
-#define P_L_CPV2_VE_ADDR                VCBUS_REG_ADDR(L_CPV2_VE_ADDR)
-#define L_STV1_HS_ADDR 0x1427
-#define P_L_STV1_HS_ADDR                VCBUS_REG_ADDR(L_STV1_HS_ADDR)
-#define L_STV1_HE_ADDR 0x1428
-#define P_L_STV1_HE_ADDR                VCBUS_REG_ADDR(L_STV1_HE_ADDR)
-#define L_STV1_VS_ADDR 0x1429
-#define P_L_STV1_VS_ADDR                VCBUS_REG_ADDR(L_STV1_VS_ADDR)
-#define L_STV1_VE_ADDR 0x142a
-#define P_L_STV1_VE_ADDR                VCBUS_REG_ADDR(L_STV1_VE_ADDR)
-#define L_STV2_HS_ADDR 0x142b
-#define P_L_STV2_HS_ADDR                VCBUS_REG_ADDR(L_STV2_HS_ADDR)
-#define L_STV2_HE_ADDR 0x142c
-#define P_L_STV2_HE_ADDR                VCBUS_REG_ADDR(L_STV2_HE_ADDR)
-#define L_STV2_VS_ADDR 0x142d
-#define P_L_STV2_VS_ADDR                VCBUS_REG_ADDR(L_STV2_VS_ADDR)
-#define L_STV2_VE_ADDR 0x142e
-#define P_L_STV2_VE_ADDR                VCBUS_REG_ADDR(L_STV2_VE_ADDR)
-#define L_OEV1_HS_ADDR 0x142f
-#define P_L_OEV1_HS_ADDR                VCBUS_REG_ADDR(L_OEV1_HS_ADDR)
-#define L_OEV1_HE_ADDR 0x1430
-#define P_L_OEV1_HE_ADDR                VCBUS_REG_ADDR(L_OEV1_HE_ADDR)
-#define L_OEV1_VS_ADDR 0x1431
-#define P_L_OEV1_VS_ADDR                VCBUS_REG_ADDR(L_OEV1_VS_ADDR)
-#define L_OEV1_VE_ADDR 0x1432
-#define P_L_OEV1_VE_ADDR                VCBUS_REG_ADDR(L_OEV1_VE_ADDR)
-#define L_OEV2_HS_ADDR 0x1433
-#define P_L_OEV2_HS_ADDR                VCBUS_REG_ADDR(L_OEV2_HS_ADDR)
-#define L_OEV2_HE_ADDR 0x1434
-#define P_L_OEV2_HE_ADDR                VCBUS_REG_ADDR(L_OEV2_HE_ADDR)
-#define L_OEV2_VS_ADDR 0x1435
-#define P_L_OEV2_VS_ADDR                VCBUS_REG_ADDR(L_OEV2_VS_ADDR)
-#define L_OEV2_VE_ADDR 0x1436
-#define P_L_OEV2_VE_ADDR                VCBUS_REG_ADDR(L_OEV2_VE_ADDR)
-#define L_OEV3_HS_ADDR 0x1437
-#define P_L_OEV3_HS_ADDR                VCBUS_REG_ADDR(L_OEV3_HS_ADDR)
-#define L_OEV3_HE_ADDR 0x1438
-#define P_L_OEV3_HE_ADDR                VCBUS_REG_ADDR(L_OEV3_HE_ADDR)
-#define L_OEV3_VS_ADDR 0x1439
-#define P_L_OEV3_VS_ADDR                VCBUS_REG_ADDR(L_OEV3_VS_ADDR)
-#define L_OEV3_VE_ADDR 0x143a
-#define P_L_OEV3_VE_ADDR                VCBUS_REG_ADDR(L_OEV3_VE_ADDR)
-#define L_LCD_PWR_ADDR 0x143b
-#define P_L_LCD_PWR_ADDR                VCBUS_REG_ADDR(L_LCD_PWR_ADDR)
-#define L_LCD_PWM0_LO_ADDR 0x143c
-#define P_L_LCD_PWM0_LO_ADDR            VCBUS_REG_ADDR(L_LCD_PWM0_LO_ADDR)
-#define L_LCD_PWM0_HI_ADDR 0x143d
-#define P_L_LCD_PWM0_HI_ADDR            VCBUS_REG_ADDR(L_LCD_PWM0_HI_ADDR)
-#define L_LCD_PWM1_LO_ADDR 0x143e
-#define P_L_LCD_PWM1_LO_ADDR            VCBUS_REG_ADDR(L_LCD_PWM1_LO_ADDR)
-#define L_LCD_PWM1_HI_ADDR 0x143f
-#define P_L_LCD_PWM1_HI_ADDR            VCBUS_REG_ADDR(L_LCD_PWM1_HI_ADDR)
-#define L_INV_CNT_ADDR 0x1440
-#define P_L_INV_CNT_ADDR                VCBUS_REG_ADDR(L_INV_CNT_ADDR)
-#define L_TCON_MISC_SEL_ADDR 0x1441
-#define P_L_TCON_MISC_SEL_ADDR          VCBUS_REG_ADDR(L_TCON_MISC_SEL_ADDR)
-#define MLVDS_CLK_CTL1_HI 0x1443
-#define P_MLVDS_CLK_CTL1_HI             VCBUS_REG_ADDR(MLVDS_CLK_CTL1_HI)
-#define MLVDS_CLK_CTL1_LO 0x1444
-#define P_MLVDS_CLK_CTL1_LO             VCBUS_REG_ADDR(MLVDS_CLK_CTL1_LO)
-#define L_TCON_DOUBLE_CTL 0x1449
-#define P_L_TCON_DOUBLE_CTL             VCBUS_REG_ADDR(L_TCON_DOUBLE_CTL)
-#define L_TCON_PATTERN_HI 0x144a
-#define P_L_TCON_PATTERN_HI             VCBUS_REG_ADDR(L_TCON_PATTERN_HI)
-#define L_TCON_PATTERN_LO 0x144b
-#define P_L_TCON_PATTERN_LO             VCBUS_REG_ADDR(L_TCON_PATTERN_LO)
-#define LDIM_BL_ADDR_PORT 0x144e
-#define P_LDIM_BL_ADDR_PORT             VCBUS_REG_ADDR(LDIM_BL_ADDR_PORT)
-#define LDIM_BL_DATA_PORT 0x144f
-#define P_LDIM_BL_DATA_PORT             VCBUS_REG_ADDR(LDIM_BL_DATA_PORT)
-#define L_DE_HS_ADDR 0x1451
-#define P_L_DE_HS_ADDR          VCBUS_REG_ADDR(L_DE_HS_ADDR)
-#define L_DE_HE_ADDR 0x1452
-#define P_L_DE_HE_ADDR          VCBUS_REG_ADDR(L_DE_HE_ADDR)
-#define L_DE_VS_ADDR 0x1453
-#define P_L_DE_VS_ADDR          VCBUS_REG_ADDR(L_DE_VS_ADDR)
-#define L_DE_VE_ADDR 0x1454
-#define P_L_DE_VE_ADDR          VCBUS_REG_ADDR(L_DE_VE_ADDR)
-#define L_HSYNC_HS_ADDR 0x1455
-#define P_L_HSYNC_HS_ADDR               VCBUS_REG_ADDR(L_HSYNC_HS_ADDR)
-#define L_HSYNC_HE_ADDR 0x1456
-#define P_L_HSYNC_HE_ADDR               VCBUS_REG_ADDR(L_HSYNC_HE_ADDR)
-#define L_HSYNC_VS_ADDR 0x1457
-#define P_L_HSYNC_VS_ADDR               VCBUS_REG_ADDR(L_HSYNC_VS_ADDR)
-#define L_HSYNC_VE_ADDR 0x1458
-#define P_L_HSYNC_VE_ADDR               VCBUS_REG_ADDR(L_HSYNC_VE_ADDR)
-#define L_VSYNC_HS_ADDR 0x1459
-#define P_L_VSYNC_HS_ADDR               VCBUS_REG_ADDR(L_VSYNC_HS_ADDR)
-#define L_VSYNC_HE_ADDR 0x145a
-#define P_L_VSYNC_HE_ADDR               VCBUS_REG_ADDR(L_VSYNC_HE_ADDR)
-#define L_VSYNC_VS_ADDR 0x145b
-#define P_L_VSYNC_VS_ADDR               VCBUS_REG_ADDR(L_VSYNC_VS_ADDR)
-#define L_VSYNC_VE_ADDR 0x145c
-#define P_L_VSYNC_VE_ADDR               VCBUS_REG_ADDR(L_VSYNC_VE_ADDR)
-#define L_LCD_MCU_CTL 0x145d
-#define P_L_LCD_MCU_CTL                 VCBUS_REG_ADDR(L_LCD_MCU_CTL)
-#define DUAL_MLVDS_CTL 0x1460
-#define P_DUAL_MLVDS_CTL                VCBUS_REG_ADDR(DUAL_MLVDS_CTL)
-
-#define V_INVERSION_PIXEL 0x1470
-#define P_V_INVERSION_PIXEL             VCBUS_REG_ADDR(V_INVERSION_PIXEL)
-#define V_INVERSION_LINE 0x1471
-#define P_V_INVERSION_LINE              VCBUS_REG_ADDR(V_INVERSION_LINE)
-#define V_INVERSION_CONTROL 0x1472
-#define P_V_INVERSION_CONTROL           VCBUS_REG_ADDR(V_INVERSION_CONTROL)
-#define MLVDS2_CONTROL 0x1474
-#define P_MLVDS2_CONTROL                VCBUS_REG_ADDR(MLVDS2_CONTROL)
-#define MLVDS2_CONFIG_HI 0x1475
-#define P_MLVDS2_CONFIG_HI              VCBUS_REG_ADDR(MLVDS2_CONFIG_HI)
-#define MLVDS2_CONFIG_LO 0x1476
-#define P_MLVDS2_CONFIG_LO              VCBUS_REG_ADDR(MLVDS2_CONFIG_LO)
-#define MLVDS2_DUAL_GATE_WR_START 0x1477
-#define RGB_BASE_ADDR 0x1485
-#define P_RGB_BASE_ADDR                 VCBUS_REG_ADDR(RGB_BASE_ADDR)
-#define RGB_COEFF_ADDR 0x1486
-#define P_RGB_COEFF_ADDR                VCBUS_REG_ADDR(RGB_COEFF_ADDR)
-#define POL_CNTL_ADDR 0x1487
-#define P_POL_CNTL_ADDR                 VCBUS_REG_ADDR(POL_CNTL_ADDR)
-#define DITH_CNTL_ADDR 0x1488
-#define P_DITH_CNTL_ADDR                VCBUS_REG_ADDR(DITH_CNTL_ADDR)
-#define GAMMA_PROBE_CTRL 0x1489
-#define P_GAMMA_PROBE_CTRL              VCBUS_REG_ADDR(GAMMA_PROBE_CTRL)
-#define GAMMA_PROBE_COLOR_L 0x148a
-#define P_GAMMA_PROBE_COLOR_L           VCBUS_REG_ADDR(GAMMA_PROBE_COLOR_L)
-#define GAMMA_PROBE_COLOR_H 0x148b
-#define P_GAMMA_PROBE_COLOR_H           VCBUS_REG_ADDR(GAMMA_PROBE_COLOR_H)
-#define GAMMA_PROBE_HL_COLOR 0x148c
-#define P_GAMMA_PROBE_HL_COLOR          VCBUS_REG_ADDR(GAMMA_PROBE_HL_COLOR)
-#define GAMMA_PROBE_POS_X 0x148d
-#define P_GAMMA_PROBE_POS_X             VCBUS_REG_ADDR(GAMMA_PROBE_POS_X)
-#define GAMMA_PROBE_POS_Y 0x148e
-#define P_GAMMA_PROBE_POS_Y             VCBUS_REG_ADDR(GAMMA_PROBE_POS_Y)
-#define STH1_HS_ADDR 0x1490
-#define P_STH1_HS_ADDR          VCBUS_REG_ADDR(STH1_HS_ADDR)
-#define STH1_HE_ADDR 0x1491
-#define P_STH1_HE_ADDR          VCBUS_REG_ADDR(STH1_HE_ADDR)
-#define STH1_VS_ADDR 0x1492
-#define P_STH1_VS_ADDR          VCBUS_REG_ADDR(STH1_VS_ADDR)
-#define STH1_VE_ADDR 0x1493
-#define P_STH1_VE_ADDR          VCBUS_REG_ADDR(STH1_VE_ADDR)
-#define STH2_HS_ADDR 0x1494
-#define P_STH2_HS_ADDR          VCBUS_REG_ADDR(STH2_HS_ADDR)
-#define STH2_HE_ADDR 0x1495
-#define P_STH2_HE_ADDR          VCBUS_REG_ADDR(STH2_HE_ADDR)
-#define STH2_VS_ADDR 0x1496
-#define P_STH2_VS_ADDR          VCBUS_REG_ADDR(STH2_VS_ADDR)
-#define STH2_VE_ADDR 0x1497
-#define P_STH2_VE_ADDR          VCBUS_REG_ADDR(STH2_VE_ADDR)
-#define OEH_HS_ADDR 0x1498
-#define P_OEH_HS_ADDR           VCBUS_REG_ADDR(OEH_HS_ADDR)
-#define OEH_HE_ADDR 0x1499
-#define P_OEH_HE_ADDR           VCBUS_REG_ADDR(OEH_HE_ADDR)
-#define OEH_VS_ADDR 0x149a
-#define P_OEH_VS_ADDR           VCBUS_REG_ADDR(OEH_VS_ADDR)
-#define OEH_VE_ADDR 0x149b
-#define P_OEH_VE_ADDR           VCBUS_REG_ADDR(OEH_VE_ADDR)
-#define VCOM_HSWITCH_ADDR 0x149c
-#define P_VCOM_HSWITCH_ADDR             VCBUS_REG_ADDR(VCOM_HSWITCH_ADDR)
-#define VCOM_VS_ADDR 0x149d
-#define P_VCOM_VS_ADDR          VCBUS_REG_ADDR(VCOM_VS_ADDR)
-#define VCOM_VE_ADDR 0x149e
-#define P_VCOM_VE_ADDR          VCBUS_REG_ADDR(VCOM_VE_ADDR)
-#define CPV1_HS_ADDR 0x149f
-#define P_CPV1_HS_ADDR          VCBUS_REG_ADDR(CPV1_HS_ADDR)
-#define CPV1_HE_ADDR 0x14a0
-#define P_CPV1_HE_ADDR          VCBUS_REG_ADDR(CPV1_HE_ADDR)
-#define CPV1_VS_ADDR 0x14a1
-#define P_CPV1_VS_ADDR          VCBUS_REG_ADDR(CPV1_VS_ADDR)
-#define CPV1_VE_ADDR 0x14a2
-#define P_CPV1_VE_ADDR          VCBUS_REG_ADDR(CPV1_VE_ADDR)
-#define CPV2_HS_ADDR 0x14a3
-#define P_CPV2_HS_ADDR          VCBUS_REG_ADDR(CPV2_HS_ADDR)
-#define CPV2_HE_ADDR 0x14a4
-#define P_CPV2_HE_ADDR          VCBUS_REG_ADDR(CPV2_HE_ADDR)
-#define CPV2_VS_ADDR 0x14a5
-#define P_CPV2_VS_ADDR          VCBUS_REG_ADDR(CPV2_VS_ADDR)
-#define CPV2_VE_ADDR 0x14a6
-#define P_CPV2_VE_ADDR          VCBUS_REG_ADDR(CPV2_VE_ADDR)
-#define STV1_HS_ADDR 0x14a7
-#define P_STV1_HS_ADDR          VCBUS_REG_ADDR(STV1_HS_ADDR)
-#define STV1_HE_ADDR 0x14a8
-#define P_STV1_HE_ADDR          VCBUS_REG_ADDR(STV1_HE_ADDR)
-#define STV1_VS_ADDR 0x14a9
-#define P_STV1_VS_ADDR          VCBUS_REG_ADDR(STV1_VS_ADDR)
-#define STV1_VE_ADDR 0x14aa
-#define P_STV1_VE_ADDR          VCBUS_REG_ADDR(STV1_VE_ADDR)
-#define STV2_HS_ADDR 0x14ab
-#define P_STV2_HS_ADDR          VCBUS_REG_ADDR(STV2_HS_ADDR)
-#define STV2_HE_ADDR 0x14ac
-#define P_STV2_HE_ADDR          VCBUS_REG_ADDR(STV2_HE_ADDR)
-#define STV2_VS_ADDR 0x14ad
-#define P_STV2_VS_ADDR          VCBUS_REG_ADDR(STV2_VS_ADDR)
-#define STV2_VE_ADDR 0x14ae
-#define P_STV2_VE_ADDR          VCBUS_REG_ADDR(STV2_VE_ADDR)
-#define OEV1_HS_ADDR 0x14af
-#define P_OEV1_HS_ADDR          VCBUS_REG_ADDR(OEV1_HS_ADDR)
-#define OEV1_HE_ADDR 0x14b0
-#define P_OEV1_HE_ADDR          VCBUS_REG_ADDR(OEV1_HE_ADDR)
-#define OEV1_VS_ADDR 0x14b1
-#define P_OEV1_VS_ADDR          VCBUS_REG_ADDR(OEV1_VS_ADDR)
-#define OEV1_VE_ADDR 0x14b2
-#define P_OEV1_VE_ADDR          VCBUS_REG_ADDR(OEV1_VE_ADDR)
-#define OEV2_HS_ADDR 0x14b3
-#define P_OEV2_HS_ADDR          VCBUS_REG_ADDR(OEV2_HS_ADDR)
-#define OEV2_HE_ADDR 0x14b4
-#define P_OEV2_HE_ADDR          VCBUS_REG_ADDR(OEV2_HE_ADDR)
-#define OEV2_VS_ADDR 0x14b5
-#define P_OEV2_VS_ADDR          VCBUS_REG_ADDR(OEV2_VS_ADDR)
-#define OEV2_VE_ADDR 0x14b6
-#define P_OEV2_VE_ADDR          VCBUS_REG_ADDR(OEV2_VE_ADDR)
-#define OEV3_HS_ADDR 0x14b7
-#define P_OEV3_HS_ADDR          VCBUS_REG_ADDR(OEV3_HS_ADDR)
-#define OEV3_HE_ADDR 0x14b8
-#define P_OEV3_HE_ADDR          VCBUS_REG_ADDR(OEV3_HE_ADDR)
-#define OEV3_VS_ADDR 0x14b9
-#define P_OEV3_VS_ADDR          VCBUS_REG_ADDR(OEV3_VS_ADDR)
-#define OEV3_VE_ADDR 0x14ba
-#define P_OEV3_VE_ADDR          VCBUS_REG_ADDR(OEV3_VE_ADDR)
-#define LCD_PWR_ADDR 0x14bb
-#define P_LCD_PWR_ADDR          VCBUS_REG_ADDR(LCD_PWR_ADDR)
-#define LCD_PWM0_LO_ADDR 0x14bc
-#define P_LCD_PWM0_LO_ADDR              VCBUS_REG_ADDR(LCD_PWM0_LO_ADDR)
-#define LCD_PWM0_HI_ADDR 0x14bd
-#define P_LCD_PWM0_HI_ADDR              VCBUS_REG_ADDR(LCD_PWM0_HI_ADDR)
-#define LCD_PWM1_LO_ADDR 0x14be
-#define P_LCD_PWM1_LO_ADDR              VCBUS_REG_ADDR(LCD_PWM1_LO_ADDR)
-#define LCD_PWM1_HI_ADDR 0x14bf
-#define P_LCD_PWM1_HI_ADDR              VCBUS_REG_ADDR(LCD_PWM1_HI_ADDR)
-#define INV_CNT_ADDR 0x14c0
-#define P_INV_CNT_ADDR          VCBUS_REG_ADDR(INV_CNT_ADDR)
-#define TCON_MISC_SEL_ADDR 0x14c1
-#define P_TCON_MISC_SEL_ADDR            VCBUS_REG_ADDR(TCON_MISC_SEL_ADDR)
-#define DUAL_PORT_CNTL_ADDR 0x14c2
-#define P_DUAL_PORT_CNTL_ADDR           VCBUS_REG_ADDR(DUAL_PORT_CNTL_ADDR)
-#define MLVDS_CONTROL 0x14c3
-#define P_MLVDS_CONTROL                 VCBUS_REG_ADDR(MLVDS_CONTROL)
-#define MLVDS_CONFIG_HI 0x14c7
-#define P_MLVDS_CONFIG_HI               VCBUS_REG_ADDR(MLVDS_CONFIG_HI)
-#define MLVDS_CONFIG_LO 0x14c8
-#define P_MLVDS_CONFIG_LO               VCBUS_REG_ADDR(MLVDS_CONFIG_LO)
-#define TCON_DOUBLE_CTL 0x14c9
-#define P_TCON_DOUBLE_CTL               VCBUS_REG_ADDR(TCON_DOUBLE_CTL)
-#define TCON_PATTERN_HI 0x14ca
-#define P_TCON_PATTERN_HI               VCBUS_REG_ADDR(TCON_PATTERN_HI)
-#define TCON_PATTERN_LO 0x14cb
-#define P_TCON_PATTERN_LO               VCBUS_REG_ADDR(TCON_PATTERN_LO)
-#define TCON_CONTROL_HI 0x14cc
-#define P_TCON_CONTROL_HI               VCBUS_REG_ADDR(TCON_CONTROL_HI)
-#define TCON_CONTROL_LO 0x14cd
-#define P_TCON_CONTROL_LO               VCBUS_REG_ADDR(TCON_CONTROL_LO)
-#define LVDS_BLANK_DATA_HI 0x14ce
-#define P_LVDS_BLANK_DATA_HI            VCBUS_REG_ADDR(LVDS_BLANK_DATA_HI)
-#define LVDS_BLANK_DATA_LO 0x14cf
-#define P_LVDS_BLANK_DATA_LO            VCBUS_REG_ADDR(LVDS_BLANK_DATA_LO)
-#define LVDS_PACK_CNTL_ADDR 0x14d0
-#define P_LVDS_PACK_CNTL_ADDR           VCBUS_REG_ADDR(LVDS_PACK_CNTL_ADDR)
-#define DE_HS_ADDR 0x14d1
-#define P_DE_HS_ADDR            VCBUS_REG_ADDR(DE_HS_ADDR)
-#define DE_HE_ADDR 0x14d2
-#define P_DE_HE_ADDR            VCBUS_REG_ADDR(DE_HE_ADDR)
-#define DE_VS_ADDR 0x14d3
-#define P_DE_VS_ADDR            VCBUS_REG_ADDR(DE_VS_ADDR)
-#define DE_VE_ADDR 0x14d4
-#define P_DE_VE_ADDR            VCBUS_REG_ADDR(DE_VE_ADDR)
-#define HSYNC_HS_ADDR 0x14d5
-#define P_HSYNC_HS_ADDR                 VCBUS_REG_ADDR(HSYNC_HS_ADDR)
-#define HSYNC_HE_ADDR 0x14d6
-#define P_HSYNC_HE_ADDR                 VCBUS_REG_ADDR(HSYNC_HE_ADDR)
-#define HSYNC_VS_ADDR 0x14d7
-#define P_HSYNC_VS_ADDR                 VCBUS_REG_ADDR(HSYNC_VS_ADDR)
-#define HSYNC_VE_ADDR 0x14d8
-#define P_HSYNC_VE_ADDR                 VCBUS_REG_ADDR(HSYNC_VE_ADDR)
-#define VSYNC_HS_ADDR 0x14d9
-#define P_VSYNC_HS_ADDR                 VCBUS_REG_ADDR(VSYNC_HS_ADDR)
-#define VSYNC_HE_ADDR 0x14da
-#define P_VSYNC_HE_ADDR                 VCBUS_REG_ADDR(VSYNC_HE_ADDR)
-#define VSYNC_VS_ADDR 0x14db
-#define P_VSYNC_VS_ADDR                 VCBUS_REG_ADDR(VSYNC_VS_ADDR)
-#define VSYNC_VE_ADDR 0x14dc
-#define P_VSYNC_VE_ADDR                 VCBUS_REG_ADDR(VSYNC_VE_ADDR)
-#define LCD_MCU_CTL 0x14dd
-#define P_LCD_MCU_CTL           VCBUS_REG_ADDR(LCD_MCU_CTL)
-#define LCD_MCU_DATA_0 0x14de
-#define P_LCD_MCU_DATA_0                VCBUS_REG_ADDR(LCD_MCU_DATA_0)
-#define LCD_MCU_DATA_1 0x14df
-#define P_LCD_MCU_DATA_1                VCBUS_REG_ADDR(LCD_MCU_DATA_1)
-#define LVDS_GEN_CNTL 0x14e0
-#define P_LVDS_GEN_CNTL                 VCBUS_REG_ADDR(LVDS_GEN_CNTL)
-#define LVDS_PHY_CNTL0 0x14e1
-#define P_LVDS_PHY_CNTL0                VCBUS_REG_ADDR(LVDS_PHY_CNTL0)
-#define LVDS_PHY_CNTL1 0x14e2
-#define P_LVDS_PHY_CNTL1                VCBUS_REG_ADDR(LVDS_PHY_CNTL1)
-#define LVDS_PHY_CNTL2 0x14e3
-#define P_LVDS_PHY_CNTL2                VCBUS_REG_ADDR(LVDS_PHY_CNTL2)
-#define LVDS_PHY_CNTL3 0x14e4
-#define P_LVDS_PHY_CNTL3                VCBUS_REG_ADDR(LVDS_PHY_CNTL3)
-#define LVDS_PHY_CNTL4 0x14e5
-#define P_LVDS_PHY_CNTL4                VCBUS_REG_ADDR(LVDS_PHY_CNTL4)
-#define LVDS_PHY_CNTL5 0x14e6
-#define P_LVDS_PHY_CNTL5                VCBUS_REG_ADDR(LVDS_PHY_CNTL5)
-#define LVDS_SRG_TEST 0x14e8
-#define P_LVDS_SRG_TEST                 VCBUS_REG_ADDR(LVDS_SRG_TEST)
-#define LVDS_BIST_MUX0 0x14e9
-#define P_LVDS_BIST_MUX0                VCBUS_REG_ADDR(LVDS_BIST_MUX0)
-#define LVDS_BIST_MUX1 0x14ea
-#define P_LVDS_BIST_MUX1                VCBUS_REG_ADDR(LVDS_BIST_MUX1)
-#define LVDS_BIST_FIXED0 0x14eb
-#define P_LVDS_BIST_FIXED0              VCBUS_REG_ADDR(LVDS_BIST_FIXED0)
-#define LVDS_BIST_FIXED1 0x14ec
-#define P_LVDS_BIST_FIXED1              VCBUS_REG_ADDR(LVDS_BIST_FIXED1)
-#define P_VPU_OSD1_MMC_CTRL             VCBUS_REG_ADDR(VPU_OSD1_MMC_CTRL)
-#define VPU_OSD2_MMC_CTRL 0x2702
-#define P_VPU_OSD2_MMC_CTRL             VCBUS_REG_ADDR(VPU_OSD2_MMC_CTRL)
-#define VPU_VD1_MMC_CTRL 0x2703
-#define P_VPU_VD1_MMC_CTRL              VCBUS_REG_ADDR(VPU_VD1_MMC_CTRL)
-#define VPU_VD2_MMC_CTRL 0x2704
-#define P_VPU_VD2_MMC_CTRL              VCBUS_REG_ADDR(VPU_VD2_MMC_CTRL)
-#define VPU_DI_IF1_MMC_CTRL 0x2705
-#define P_VPU_DI_IF1_MMC_CTRL           VCBUS_REG_ADDR(VPU_DI_IF1_MMC_CTRL)
-#define VPU_DI_MEM_MMC_CTRL 0x2706
-#define P_VPU_DI_MEM_MMC_CTRL           VCBUS_REG_ADDR(VPU_DI_MEM_MMC_CTRL)
-#define VPU_DI_INP_MMC_CTRL 0x2707
-#define P_VPU_DI_INP_MMC_CTRL           VCBUS_REG_ADDR(VPU_DI_INP_MMC_CTRL)
-#define VPU_DI_NRWR_MMC_CTRL 0x270b
-#define P_VPU_DI_NRWR_MMC_CTRL          VCBUS_REG_ADDR(VPU_DI_NRWR_MMC_CTRL)
-#define VPU_DI_DIWR_MMC_CTRL 0x270c
-#define P_VPU_DI_DIWR_MMC_CTRL          VCBUS_REG_ADDR(VPU_DI_DIWR_MMC_CTRL)
-#define VPU_VDIN0_MMC_CTRL 0x270d
-#define P_VPU_VDIN0_MMC_CTRL            VCBUS_REG_ADDR(VPU_VDIN0_MMC_CTRL)
-#define VPU_VDIN1_MMC_CTRL 0x270e
-#define P_VPU_VDIN1_MMC_CTRL            VCBUS_REG_ADDR(VPU_VDIN1_MMC_CTRL)
-#define VPU_BT656_MMC_CTRL 0x270f
-#define P_VPU_BT656_MMC_CTRL            VCBUS_REG_ADDR(VPU_BT656_MMC_CTRL)
-#define VPU_TVD3D_MMC_CTRL 0x2710
-#define P_VPU_TVD3D_MMC_CTRL            VCBUS_REG_ADDR(VPU_TVD3D_MMC_CTRL)
-#define VPU_TVDVBI_MMC_CTRL 0x2711
-#define P_VPU_TVDVBI_MMC_CTRL           VCBUS_REG_ADDR(VPU_TVDVBI_MMC_CTRL)
-#define VPU_TVDVBI_VSLATCH_ADDR 0x2712
-#define VPU_HDMI_SETTING 0x271b
-#define P_VPU_HDMI_SETTING              VCBUS_REG_ADDR(VPU_HDMI_SETTING)
-#define ENCI_INFO_READ 0x271c
-#define P_ENCI_INFO_READ                VCBUS_REG_ADDR(ENCI_INFO_READ)
-#define ENCP_INFO_READ 0x271d
-#define P_ENCP_INFO_READ                VCBUS_REG_ADDR(ENCP_INFO_READ)
-#define ENCT_INFO_READ 0x271e
-#define P_ENCT_INFO_READ                VCBUS_REG_ADDR(ENCT_INFO_READ)
-#define ENCL_INFO_READ 0x271f
-#define P_ENCL_INFO_READ                VCBUS_REG_ADDR(ENCL_INFO_READ)
-#define VPU_SW_RESET 0x2720
-#define P_VPU_SW_RESET          VCBUS_REG_ADDR(VPU_SW_RESET)
-#define VPU_D2D3_MMC_CTRL 0x2721
-#define P_VPU_D2D3_MMC_CTRL             VCBUS_REG_ADDR(VPU_D2D3_MMC_CTRL)
-#define VPU_CONT_MMC_CTRL 0x2722
-#define P_VPU_CONT_MMC_CTRL             VCBUS_REG_ADDR(VPU_CONT_MMC_CTRL)
-#define VPU_CLK_GATE 0x2723
-#define P_VPU_CLK_GATE          VCBUS_REG_ADDR(VPU_CLK_GATE)
-#define VPU_RDMA_MMC_CTRL 0x2724
-#define P_VPU_RDMA_MMC_CTRL             VCBUS_REG_ADDR(VPU_RDMA_MMC_CTRL)
-#define VPU_MEM_PD_REG0 0x2725
-#define P_VPU_MEM_PD_REG0               VCBUS_REG_ADDR(VPU_MEM_PD_REG0)
-#define VPU_MEM_PD_REG1 0x2726
-#define P_VPU_MEM_PD_REG1               VCBUS_REG_ADDR(VPU_MEM_PD_REG1)
-#define VPU_HDMI_DATA_OVR 0x2727
-#define P_VPU_HDMI_DATA_OVR             VCBUS_REG_ADDR(VPU_HDMI_DATA_OVR)
-#define VPU_PROT1_MMC_CTRL 0x2728
-#define P_VPU_PROT1_MMC_CTRL            VCBUS_REG_ADDR(VPU_PROT1_MMC_CTRL)
-#define VPU_PROT2_MMC_CTRL 0x2729
-#define P_VPU_PROT2_MMC_CTRL            VCBUS_REG_ADDR(VPU_PROT2_MMC_CTRL)
-#define VPU_PROT3_MMC_CTRL 0x272a
-#define P_VPU_PROT3_MMC_CTRL            VCBUS_REG_ADDR(VPU_PROT3_MMC_CTRL)
-#define VPU_ARB4_V1_MMC_CTRL 0x272b
-#define P_VPU_ARB4_V1_MMC_CTRL          VCBUS_REG_ADDR(VPU_ARB4_V1_MMC_CTRL)
-#define VPU_ARB4_V2_MMC_CTRL 0x272c
-#define P_VPU_ARB4_V2_MMC_CTRL          VCBUS_REG_ADDR(VPU_ARB4_V2_MMC_CTRL)
-#define VPU_VPU_PWM_V0 0x2730
-#define P_VPU_VPU_PWM_V0                VCBUS_REG_ADDR(VPU_VPU_PWM_V0)
-#define VPU_VPU_PWM_V1 0x2731
-#define P_VPU_VPU_PWM_V1                VCBUS_REG_ADDR(VPU_VPU_PWM_V1)
-#define VPU_VPU_PWM_V2 0x2732
-#define P_VPU_VPU_PWM_V2                VCBUS_REG_ADDR(VPU_VPU_PWM_V2)
-#define VPU_VPU_PWM_V3 0x2733
-#define P_VPU_VPU_PWM_V3                VCBUS_REG_ADDR(VPU_VPU_PWM_V3)
-#define VPU_VPU_PWM_H0 0x2734
-#define P_VPU_VPU_PWM_H0                VCBUS_REG_ADDR(VPU_VPU_PWM_H0)
-#define VPU_VPU_PWM_H1 0x2735
-#define P_VPU_VPU_PWM_H1                VCBUS_REG_ADDR(VPU_VPU_PWM_H1)
-#define VPU_VPU_PWM_H2 0x2736
-#define VPU_PROT2_Y_LEN_STEP 0x2764
-#define P_VPU_PROT2_Y_LEN_STEP          VCBUS_REG_ADDR(VPU_PROT2_Y_LEN_STEP)
-#define VPU_PROT2_RPT_LOOP 0x2765
-#define P_VPU_PROT2_RPT_LOOP            VCBUS_REG_ADDR(VPU_PROT2_RPT_LOOP)
-#define VPU_PROT2_RPT_PAT 0x2766
-#define P_VPU_PROT2_RPT_PAT             VCBUS_REG_ADDR(VPU_PROT2_RPT_PAT)
-#define VPU_PROT2_DDR 0x2767
-#define P_VPU_PROT2_DDR                 VCBUS_REG_ADDR(VPU_PROT2_DDR)
-#define VPU_PROT2_RBUF_ROOM 0x2768
-#define P_VPU_PROT2_RBUF_ROOM           VCBUS_REG_ADDR(VPU_PROT2_RBUF_ROOM)
-#define VPU_PROT2_STAT_0 0x2769
-#define P_VPU_PROT2_STAT_0              VCBUS_REG_ADDR(VPU_PROT2_STAT_0)
-#define VPU_PROT2_STAT_1 0x276a
-#define P_VPU_PROT2_STAT_1              VCBUS_REG_ADDR(VPU_PROT2_STAT_1)
-#define VPU_PROT2_STAT_2 0x276b
-#define MC_CTRL_REG 0x0900
-#define P_MC_CTRL_REG           DOS_REG_ADDR(MC_CTRL_REG)
-#define MC_MB_INFO 0x0901
-#define P_MC_MB_INFO            DOS_REG_ADDR(MC_MB_INFO)
-#define MC_PIC_INFO 0x0902
-#define P_MC_PIC_INFO           DOS_REG_ADDR(MC_PIC_INFO)
-#define MC_HALF_PEL_ONE 0x0903
-#define P_MC_HALF_PEL_ONE               DOS_REG_ADDR(MC_HALF_PEL_ONE)
-#define MC_HALF_PEL_TWO 0x0904
-#define P_MC_HALF_PEL_TWO               DOS_REG_ADDR(MC_HALF_PEL_TWO)
-#define POWER_CTL_MC 0x0905
-#define P_POWER_CTL_MC          DOS_REG_ADDR(POWER_CTL_MC)
-#define MC_CMD 0x0906
-#define P_MC_CMD                DOS_REG_ADDR(MC_CMD)
-#define MC_CTRL0 0x0907
-#define P_MC_CTRL0              DOS_REG_ADDR(MC_CTRL0)
-#define MC_PIC_W_H 0x0908
-#define P_MC_PIC_W_H            DOS_REG_ADDR(MC_PIC_W_H)
-#define MC_STATUS0 0x0909
-#define P_MC_STATUS0            DOS_REG_ADDR(MC_STATUS0)
-#define MC_STATUS1 0x090a
-#define P_MC_STATUS1            DOS_REG_ADDR(MC_STATUS1)
-#define MC_CTRL1 0x090b
-#define P_MC_CTRL1              DOS_REG_ADDR(MC_CTRL1)
-#define MC_MIX_RATIO0 0x090c
-#define P_MC_MIX_RATIO0                 DOS_REG_ADDR(MC_MIX_RATIO0)
-#define MC_MIX_RATIO1 0x090d
-#define P_MC_MIX_RATIO1                 DOS_REG_ADDR(MC_MIX_RATIO1)
-#define MC_DP_MB_XY 0x090e
-#define P_MC_DP_MB_XY           DOS_REG_ADDR(MC_DP_MB_XY)
-#define MC_OM_MB_XY 0x090f
-#define P_MC_OM_MB_XY           DOS_REG_ADDR(MC_OM_MB_XY)
-#define PSCALE_RST 0x0910
-#define P_PSCALE_RST            DOS_REG_ADDR(PSCALE_RST)
-#define PSCALE_CTRL 0x0911
-#define P_PSCALE_CTRL           DOS_REG_ADDR(PSCALE_CTRL)
-#define PSCALE_PICI_W 0x0912
-#define P_PSCALE_PICI_W                 DOS_REG_ADDR(PSCALE_PICI_W)
-#define PSCALE_PICI_H 0x0913
-#define P_PSCALE_PICI_H                 DOS_REG_ADDR(PSCALE_PICI_H)
-#define PSCALE_PICO_W 0x0914
-#define P_PSCALE_PICO_W                 DOS_REG_ADDR(PSCALE_PICO_W)
-#define PSCALE_PICO_H 0x0915
-#define P_PSCALE_PICO_H                 DOS_REG_ADDR(PSCALE_PICO_H)
-#define PSCALE_PICO_START_X 0x0916
-#define P_PSCALE_PICO_START_X           DOS_REG_ADDR(PSCALE_PICO_START_X)
-#define PSCALE_PICO_START_Y 0x0917
-#define P_PSCALE_PICO_START_Y           DOS_REG_ADDR(PSCALE_PICO_START_Y)
-#define PSCALE_DUMMY 0x0918
-#define P_PSCALE_DUMMY          DOS_REG_ADDR(PSCALE_DUMMY)
-#define PSCALE_FILT0_COEF0 0x0919
-#define P_PSCALE_FILT0_COEF0            DOS_REG_ADDR(PSCALE_FILT0_COEF0)
-#define PSCALE_FILT0_COEF1 0x091a
-#define P_PSCALE_FILT0_COEF1            DOS_REG_ADDR(PSCALE_FILT0_COEF1)
-#define PSCALE_CMD_CTRL 0x091b
-#define P_PSCALE_CMD_CTRL               DOS_REG_ADDR(PSCALE_CMD_CTRL)
-#define PSCALE_CMD_BLK_X 0x091c
-#define P_PSCALE_CMD_BLK_X              DOS_REG_ADDR(PSCALE_CMD_BLK_X)
-#define PSCALE_CMD_BLK_Y 0x091d
-#define P_PSCALE_CMD_BLK_Y              DOS_REG_ADDR(PSCALE_CMD_BLK_Y)
-#define PSCALE_STATUS 0x091e
-#define P_PSCALE_STATUS                 DOS_REG_ADDR(PSCALE_STATUS)
-#define PSCALE_BMEM_ADDR 0x091f
-#define P_PSCALE_BMEM_ADDR              DOS_REG_ADDR(PSCALE_BMEM_ADDR)
-#define PSCALE_BMEM_DAT 0x0920
-#define P_PSCALE_BMEM_DAT               DOS_REG_ADDR(PSCALE_BMEM_DAT)
-#define PSCALE_DRAM_BUF_CTRL 0x0921
-#define P_PSCALE_DRAM_BUF_CTRL          DOS_REG_ADDR(PSCALE_DRAM_BUF_CTRL)
-#define PSCALE_MCMD_CTRL 0x0922
-#define P_PSCALE_MCMD_CTRL              DOS_REG_ADDR(PSCALE_MCMD_CTRL)
-#define PSCALE_MCMD_XSIZE 0x0923
-#define P_PSCALE_MCMD_XSIZE             DOS_REG_ADDR(PSCALE_MCMD_XSIZE)
-#define PSCALE_MCMD_YSIZE 0x0924
-#define P_PSCALE_MCMD_YSIZE             DOS_REG_ADDR(PSCALE_MCMD_YSIZE)
-#define PSCALE_PICO_SHIFT_XY 0x0928
-#define P_PSCALE_PICO_SHIFT_XY          DOS_REG_ADDR(PSCALE_PICO_SHIFT_XY)
-#define PSCALE_CTRL1 0x0929
-#define P_PSCALE_CTRL1          DOS_REG_ADDR(PSCALE_CTRL1)
-#define PSCALE_SRCKEY_CTRL0 0x092a
-#define PSCALE_CTRL2 0x092e
-#define P_PSCALE_CTRL2          DOS_REG_ADDR(PSCALE_CTRL2)
-/*add from M8m2*/
-#define HDEC_MC_OMEM_AUTO 0x0930
-#define P_HDEC_MC_OMEM_AUTO             DOS_REG_ADDR(HDEC_MC_OMEM_AUTO)
-#define HDEC_MC_MBRIGHT_IDX 0x0931
-#define P_HDEC_MC_MBRIGHT_IDX           DOS_REG_ADDR(HDEC_MC_MBRIGHT_IDX)
-#define HDEC_MC_MBRIGHT_RD 0x0932
-#define P_HDEC_MC_MBRIGHT_RD            DOS_REG_ADDR(HDEC_MC_MBRIGHT_RD)
-/**/
-#define MC_MPORT_CTRL 0x0940
-#define P_MC_MPORT_CTRL                 DOS_REG_ADDR(MC_MPORT_CTRL)
-#define MC_MPORT_DAT 0x0941
-#define P_MC_MPORT_DAT          DOS_REG_ADDR(MC_MPORT_DAT)
-#define MC_WT_PRED_CTRL 0x0942
-#define P_MC_WT_PRED_CTRL               DOS_REG_ADDR(MC_WT_PRED_CTRL)
-#define MC_MBBOT_ST_ODD_ADDR 0x0945
-#define P_MC_MBBOT_ST_ODD_ADDR          DOS_REG_ADDR(MC_MBBOT_ST_ODD_ADDR)
-#define MC_DPDN_MB_XY 0x0946
-#define P_MC_DPDN_MB_XY                 DOS_REG_ADDR(MC_DPDN_MB_XY)
-#define MC_OMDN_MB_XY 0x0947
-#define P_MC_OMDN_MB_XY                 DOS_REG_ADDR(MC_OMDN_MB_XY)
-#define MC_HCMDBUF_H 0x0948
-#define P_MC_HCMDBUF_H          DOS_REG_ADDR(MC_HCMDBUF_H)
-#define MC_HCMDBUF_L 0x0949
-#define P_MC_HCMDBUF_L          DOS_REG_ADDR(MC_HCMDBUF_L)
-#define MC_HCMD_H 0x094a
-#define P_MC_HCMD_H             DOS_REG_ADDR(MC_HCMD_H)
-#define MC_HCMD_L 0x094b
-#define P_MC_HCMD_L             DOS_REG_ADDR(MC_HCMD_L)
-#define MC_IDCT_DAT 0x094c
-#define P_MC_IDCT_DAT           DOS_REG_ADDR(MC_IDCT_DAT)
-#define MC_CTRL_GCLK_CTRL 0x094d
-#define P_MC_CTRL_GCLK_CTRL             DOS_REG_ADDR(MC_CTRL_GCLK_CTRL)
-#define MC_OTHER_GCLK_CTRL 0x094e
-#define P_MC_OTHER_GCLK_CTRL            DOS_REG_ADDR(MC_OTHER_GCLK_CTRL)
-#define MC_CTRL2 0x094f
-#define P_MC_CTRL2              DOS_REG_ADDR(MC_CTRL2)
-#define MDEC_PIC_DC_CTRL 0x098e
-#define P_MDEC_PIC_DC_CTRL              DOS_REG_ADDR(MDEC_PIC_DC_CTRL)
-#define MDEC_PIC_DC_STATUS 0x098f
-#define P_MDEC_PIC_DC_STATUS            DOS_REG_ADDR(MDEC_PIC_DC_STATUS)
-#define ANC0_CANVAS_ADDR 0x0990
-#define P_ANC0_CANVAS_ADDR              DOS_REG_ADDR(ANC0_CANVAS_ADDR)
-#define ANC1_CANVAS_ADDR 0x0991
-#define P_ANC1_CANVAS_ADDR              DOS_REG_ADDR(ANC1_CANVAS_ADDR)
-#define ANC2_CANVAS_ADDR 0x0992
-#define P_ANC2_CANVAS_ADDR              DOS_REG_ADDR(ANC2_CANVAS_ADDR)
-#define ANC3_CANVAS_ADDR 0x0993
-#define P_ANC3_CANVAS_ADDR              DOS_REG_ADDR(ANC3_CANVAS_ADDR)
-#define ANC4_CANVAS_ADDR 0x0994
-#define P_ANC4_CANVAS_ADDR              DOS_REG_ADDR(ANC4_CANVAS_ADDR)
-#define ANC5_CANVAS_ADDR 0x0995
-#define P_ANC5_CANVAS_ADDR              DOS_REG_ADDR(ANC5_CANVAS_ADDR)
-#define ANC6_CANVAS_ADDR 0x0996
-#define P_ANC6_CANVAS_ADDR              DOS_REG_ADDR(ANC6_CANVAS_ADDR)
-#define ANC7_CANVAS_ADDR 0x0997
-#define P_ANC7_CANVAS_ADDR              DOS_REG_ADDR(ANC7_CANVAS_ADDR)
-#define ANC8_CANVAS_ADDR 0x0998
-#define P_ANC8_CANVAS_ADDR              DOS_REG_ADDR(ANC8_CANVAS_ADDR)
-#define ANC9_CANVAS_ADDR 0x0999
-#define P_ANC9_CANVAS_ADDR              DOS_REG_ADDR(ANC9_CANVAS_ADDR)
-#define ANC10_CANVAS_ADDR 0x099a
-#define P_ANC10_CANVAS_ADDR             DOS_REG_ADDR(ANC10_CANVAS_ADDR)
-#define ANC11_CANVAS_ADDR 0x099b
-#define P_ANC11_CANVAS_ADDR             DOS_REG_ADDR(ANC11_CANVAS_ADDR)
-#define ANC12_CANVAS_ADDR 0x099c
-#define P_ANC12_CANVAS_ADDR             DOS_REG_ADDR(ANC12_CANVAS_ADDR)
-#define ANC13_CANVAS_ADDR 0x099d
-#define P_ANC13_CANVAS_ADDR             DOS_REG_ADDR(ANC13_CANVAS_ADDR)
-#define ANC14_CANVAS_ADDR 0x099e
-#define P_ANC14_CANVAS_ADDR             DOS_REG_ADDR(ANC14_CANVAS_ADDR)
-#define ANC15_CANVAS_ADDR 0x099f
-#define P_ANC15_CANVAS_ADDR             DOS_REG_ADDR(ANC15_CANVAS_ADDR)
-#define ANC16_CANVAS_ADDR 0x09a0
-#define P_ANC16_CANVAS_ADDR             DOS_REG_ADDR(ANC16_CANVAS_ADDR)
-#define ANC17_CANVAS_ADDR 0x09a1
-#define P_ANC17_CANVAS_ADDR             DOS_REG_ADDR(ANC17_CANVAS_ADDR)
-#define ANC18_CANVAS_ADDR 0x09a2
-#define P_ANC18_CANVAS_ADDR             DOS_REG_ADDR(ANC18_CANVAS_ADDR)
-#define ANC19_CANVAS_ADDR 0x09a3
-#define P_ANC19_CANVAS_ADDR             DOS_REG_ADDR(ANC19_CANVAS_ADDR)
-#define ANC20_CANVAS_ADDR 0x09a4
-#define P_ANC20_CANVAS_ADDR             DOS_REG_ADDR(ANC20_CANVAS_ADDR)
-#define ANC21_CANVAS_ADDR 0x09a5
-#define P_ANC21_CANVAS_ADDR             DOS_REG_ADDR(ANC21_CANVAS_ADDR)
-#define ANC22_CANVAS_ADDR 0x09a6
-#define P_ANC22_CANVAS_ADDR             DOS_REG_ADDR(ANC22_CANVAS_ADDR)
-#define ANC23_CANVAS_ADDR 0x09a7
-#define P_ANC23_CANVAS_ADDR             DOS_REG_ADDR(ANC23_CANVAS_ADDR)
-#define ANC24_CANVAS_ADDR 0x09a8
-#define P_ANC24_CANVAS_ADDR             DOS_REG_ADDR(ANC24_CANVAS_ADDR)
-#define ANC25_CANVAS_ADDR 0x09a9
-#define P_ANC25_CANVAS_ADDR             DOS_REG_ADDR(ANC25_CANVAS_ADDR)
-#define ANC26_CANVAS_ADDR 0x09aa
-#define P_ANC26_CANVAS_ADDR             DOS_REG_ADDR(ANC26_CANVAS_ADDR)
-#define ANC27_CANVAS_ADDR 0x09ab
-#define P_ANC27_CANVAS_ADDR             DOS_REG_ADDR(ANC27_CANVAS_ADDR)
-#define ANC28_CANVAS_ADDR 0x09ac
-#define P_ANC28_CANVAS_ADDR             DOS_REG_ADDR(ANC28_CANVAS_ADDR)
-#define ANC29_CANVAS_ADDR 0x09ad
-#define P_ANC29_CANVAS_ADDR             DOS_REG_ADDR(ANC29_CANVAS_ADDR)
-#define ANC30_CANVAS_ADDR 0x09ae
-#define P_ANC30_CANVAS_ADDR             DOS_REG_ADDR(ANC30_CANVAS_ADDR)
-#define ANC31_CANVAS_ADDR 0x09af
-#define P_ANC31_CANVAS_ADDR             DOS_REG_ADDR(ANC31_CANVAS_ADDR)
-#define DBKR_CANVAS_ADDR 0x09b0
-#define P_DBKR_CANVAS_ADDR              DOS_REG_ADDR(DBKR_CANVAS_ADDR)
-#define DBKW_CANVAS_ADDR 0x09b1
-#define P_DBKW_CANVAS_ADDR              DOS_REG_ADDR(DBKW_CANVAS_ADDR)
-#define REC_CANVAS_ADDR 0x09b2
-#define P_REC_CANVAS_ADDR               DOS_REG_ADDR(REC_CANVAS_ADDR)
-#define CURR_CANVAS_CTRL 0x09b3
-#define P_CURR_CANVAS_CTRL              DOS_REG_ADDR(CURR_CANVAS_CTRL)
-#define MDEC_PIC_DC_THRESH 0x09b8
-#define P_MDEC_PIC_DC_THRESH            DOS_REG_ADDR(MDEC_PIC_DC_THRESH)
-#define MDEC_PICR_BUF_STATUS 0x09b9
-#define P_MDEC_PICR_BUF_STATUS          DOS_REG_ADDR(MDEC_PICR_BUF_STATUS)
-#define MDEC_PICW_BUF_STATUS 0x09ba
-#define P_MDEC_PICW_BUF_STATUS          DOS_REG_ADDR(MDEC_PICW_BUF_STATUS)
-#define MCW_DBLK_WRRSP_CNT 0x09bb
-#define P_MCW_DBLK_WRRSP_CNT            DOS_REG_ADDR(MCW_DBLK_WRRSP_CNT)
-#define MC_MBBOT_WRRSP_CNT 0x09bc
-#define P_MC_MBBOT_WRRSP_CNT            DOS_REG_ADDR(MC_MBBOT_WRRSP_CNT)
-#define WRRSP_FIFO_PICW_DBK 0x09be
-#define P_WRRSP_FIFO_PICW_DBK           DOS_REG_ADDR(WRRSP_FIFO_PICW_DBK)
-#define WRRSP_FIFO_PICW_MC 0x09bf
-#define P_WRRSP_FIFO_PICW_MC            DOS_REG_ADDR(WRRSP_FIFO_PICW_MC)
-#define AV_SCRATCH_0 0x09c0
-#define P_AV_SCRATCH_0          DOS_REG_ADDR(AV_SCRATCH_0)
-#define AV_SCRATCH_1 0x09c1
-#define P_AV_SCRATCH_1          DOS_REG_ADDR(AV_SCRATCH_1)
-#define AV_SCRATCH_2 0x09c2
-#define P_AV_SCRATCH_2          DOS_REG_ADDR(AV_SCRATCH_2)
-#define AV_SCRATCH_3 0x09c3
-#define P_AV_SCRATCH_3          DOS_REG_ADDR(AV_SCRATCH_3)
-#define AV_SCRATCH_4 0x09c4
-#define P_AV_SCRATCH_4          DOS_REG_ADDR(AV_SCRATCH_4)
-#define AV_SCRATCH_5 0x09c5
-#define P_AV_SCRATCH_5          DOS_REG_ADDR(AV_SCRATCH_5)
-#define AV_SCRATCH_6 0x09c6
-#define P_AV_SCRATCH_6          DOS_REG_ADDR(AV_SCRATCH_6)
-#define AV_SCRATCH_7 0x09c7
-#define P_AV_SCRATCH_7          DOS_REG_ADDR(AV_SCRATCH_7)
-#define AV_SCRATCH_8 0x09c8
-#define P_AV_SCRATCH_8          DOS_REG_ADDR(AV_SCRATCH_8)
-#define AV_SCRATCH_9 0x09c9
-#define P_AV_SCRATCH_9          DOS_REG_ADDR(AV_SCRATCH_9)
-#define AV_SCRATCH_A 0x09ca
-#define P_AV_SCRATCH_A          DOS_REG_ADDR(AV_SCRATCH_A)
-#define AV_SCRATCH_B 0x09cb
-#define P_AV_SCRATCH_B          DOS_REG_ADDR(AV_SCRATCH_B)
-#define AV_SCRATCH_C 0x09cc
-#define P_AV_SCRATCH_C          DOS_REG_ADDR(AV_SCRATCH_C)
-#define AV_SCRATCH_D 0x09cd
-#define P_AV_SCRATCH_D          DOS_REG_ADDR(AV_SCRATCH_D)
-#define AV_SCRATCH_E 0x09ce
-#define P_AV_SCRATCH_E          DOS_REG_ADDR(AV_SCRATCH_E)
-#define AV_SCRATCH_F 0x09cf
-#define P_AV_SCRATCH_F          DOS_REG_ADDR(AV_SCRATCH_F)
-#define AV_SCRATCH_G 0x09d0
-#define P_AV_SCRATCH_G          DOS_REG_ADDR(AV_SCRATCH_G)
-#define AV_SCRATCH_H 0x09d1
-#define P_AV_SCRATCH_H          DOS_REG_ADDR(AV_SCRATCH_H)
-#define AV_SCRATCH_I 0x09d2
-#define P_AV_SCRATCH_I          DOS_REG_ADDR(AV_SCRATCH_I)
-#define AV_SCRATCH_J 0x09d3
-#define P_AV_SCRATCH_J          DOS_REG_ADDR(AV_SCRATCH_J)
-#define AV_SCRATCH_K 0x09d4
-#define P_AV_SCRATCH_K          DOS_REG_ADDR(AV_SCRATCH_K)
-#define AV_SCRATCH_L 0x09d5
-#define P_AV_SCRATCH_L          DOS_REG_ADDR(AV_SCRATCH_L)
-#define AV_SCRATCH_M 0x09d6
-#define P_AV_SCRATCH_M          DOS_REG_ADDR(AV_SCRATCH_M)
-#define AV_SCRATCH_N 0x09d7
-#define P_AV_SCRATCH_N          DOS_REG_ADDR(AV_SCRATCH_N)
-#define WRRSP_CO_MB 0x09d8
-#define P_WRRSP_CO_MB           DOS_REG_ADDR(WRRSP_CO_MB)
-#define WRRSP_DCAC 0x09d9
-#define P_WRRSP_DCAC            DOS_REG_ADDR(WRRSP_DCAC)
-/*add from M8M2*/
-#define WRRSP_VLD 0x09da
-#define P_WRRSP_VLD             DOS_REG_ADDR(WRRSP_VLD)
-#define MDEC_DOUBLEW_CFG0 0x09db
-#define P_MDEC_DOUBLEW_CFG0             DOS_REG_ADDR(MDEC_DOUBLEW_CFG0)
-#define MDEC_DOUBLEW_CFG1 0x09dc
-#define P_MDEC_DOUBLEW_CFG1             DOS_REG_ADDR(MDEC_DOUBLEW_CFG1)
-#define MDEC_DOUBLEW_CFG2 0x09dd
-#define P_MDEC_DOUBLEW_CFG2             DOS_REG_ADDR(MDEC_DOUBLEW_CFG2)
-#define MDEC_DOUBLEW_CFG3 0x09de
-#define P_MDEC_DOUBLEW_CFG3             DOS_REG_ADDR(MDEC_DOUBLEW_CFG3)
-#define MDEC_DOUBLEW_CFG4 0x09df
-#define P_MDEC_DOUBLEW_CFG4             DOS_REG_ADDR(MDEC_DOUBLEW_CFG4)
-#define MDEC_DOUBLEW_CFG5 0x09e0
-#define P_MDEC_DOUBLEW_CFG5             DOS_REG_ADDR(MDEC_DOUBLEW_CFG5)
-#define MDEC_DOUBLEW_CFG6 0x09e1
-#define P_MDEC_DOUBLEW_CFG6             DOS_REG_ADDR(MDEC_DOUBLEW_CFG6)
-#define MDEC_DOUBLEW_CFG7 0x09e2
-#define P_MDEC_DOUBLEW_CFG7             DOS_REG_ADDR(MDEC_DOUBLEW_CFG7)
-#define MDEC_DOUBLEW_STATUS 0x09e3
-#define P_MDEC_DOUBLEW_STATUS           DOS_REG_ADDR(MDEC_DOUBLEW_STATUS)
-/**/
-#define DBLK_RST 0x0950
-#define P_DBLK_RST              DOS_REG_ADDR(DBLK_RST)
-#define DBLK_CTRL 0x0951
-#define P_DBLK_CTRL             DOS_REG_ADDR(DBLK_CTRL)
-#define DBLK_MB_WID_HEIGHT 0x0952
-#define P_DBLK_MB_WID_HEIGHT            DOS_REG_ADDR(DBLK_MB_WID_HEIGHT)
-#define DBLK_STATUS 0x0953
-#define P_DBLK_STATUS           DOS_REG_ADDR(DBLK_STATUS)
-#define DBLK_CMD_CTRL 0x0954
-#define P_DBLK_CMD_CTRL                 DOS_REG_ADDR(DBLK_CMD_CTRL)
-#define DBLK_MB_XY 0x0955
-#define P_DBLK_MB_XY            DOS_REG_ADDR(DBLK_MB_XY)
-#define DBLK_QP 0x0956
-#define P_DBLK_QP               DOS_REG_ADDR(DBLK_QP)
-#define DBLK_Y_BHFILT 0x0957
-#define P_DBLK_Y_BHFILT                 DOS_REG_ADDR(DBLK_Y_BHFILT)
-#define DBLK_Y_BHFILT_HIGH 0x0958
-#define P_DBLK_Y_BHFILT_HIGH            DOS_REG_ADDR(DBLK_Y_BHFILT_HIGH)
-#define DBLK_Y_BVFILT 0x0959
-#define P_DBLK_Y_BVFILT                 DOS_REG_ADDR(DBLK_Y_BVFILT)
-#define DBLK_CB_BFILT 0x095a
-#define P_DBLK_CB_BFILT                 DOS_REG_ADDR(DBLK_CB_BFILT)
-#define DBLK_CR_BFILT 0x095b
-#define P_DBLK_CR_BFILT                 DOS_REG_ADDR(DBLK_CR_BFILT)
-#define DBLK_Y_HFILT 0x095c
-#define P_DBLK_Y_HFILT          DOS_REG_ADDR(DBLK_Y_HFILT)
-#define DBLK_Y_HFILT_HIGH 0x095d
-#define P_DBLK_Y_HFILT_HIGH             DOS_REG_ADDR(DBLK_Y_HFILT_HIGH)
-#define DBLK_Y_VFILT 0x095e
-#define P_DBLK_Y_VFILT          DOS_REG_ADDR(DBLK_Y_VFILT)
-#define DBLK_CB_FILT 0x095f
-#define P_DBLK_CB_FILT          DOS_REG_ADDR(DBLK_CB_FILT)
-#define DBLK_CR_FILT 0x0960
-#define P_DBLK_CR_FILT          DOS_REG_ADDR(DBLK_CR_FILT)
-#define DBLK_BETAX_QP_SEL 0x0961
-#define P_DBLK_BETAX_QP_SEL             DOS_REG_ADDR(DBLK_BETAX_QP_SEL)
-#define DBLK_CLIP_CTRL0 0x0962
-#define P_DBLK_CLIP_CTRL0               DOS_REG_ADDR(DBLK_CLIP_CTRL0)
-#define DBLK_CLIP_CTRL1 0x0963
-#define P_DBLK_CLIP_CTRL1               DOS_REG_ADDR(DBLK_CLIP_CTRL1)
-#define DBLK_CLIP_CTRL2 0x0964
-#define P_DBLK_CLIP_CTRL2               DOS_REG_ADDR(DBLK_CLIP_CTRL2)
-#define DBLK_CLIP_CTRL3 0x0965
-#define P_DBLK_CLIP_CTRL3               DOS_REG_ADDR(DBLK_CLIP_CTRL3)
-#define DBLK_CLIP_CTRL4 0x0966
-#define P_DBLK_CLIP_CTRL4               DOS_REG_ADDR(DBLK_CLIP_CTRL4)
-#define DBLK_CLIP_CTRL5 0x0967
-#define P_DBLK_CLIP_CTRL5               DOS_REG_ADDR(DBLK_CLIP_CTRL5)
-#define DBLK_CLIP_CTRL6 0x0968
-#define P_DBLK_CLIP_CTRL6               DOS_REG_ADDR(DBLK_CLIP_CTRL6)
-#define DBLK_CLIP_CTRL7 0x0969
-#define P_DBLK_CLIP_CTRL7               DOS_REG_ADDR(DBLK_CLIP_CTRL7)
-#define DBLK_CLIP_CTRL8 0x096a
-#define P_DBLK_CLIP_CTRL8               DOS_REG_ADDR(DBLK_CLIP_CTRL8)
-#define DBLK_STATUS1 0x096b
-#define P_DBLK_STATUS1          DOS_REG_ADDR(DBLK_STATUS1)
-#define DBLK_GCLK_FREE 0x096c
-#define P_DBLK_GCLK_FREE                DOS_REG_ADDR(DBLK_GCLK_FREE)
-#define DBLK_GCLK_OFF 0x096d
-#define P_DBLK_GCLK_OFF                 DOS_REG_ADDR(DBLK_GCLK_OFF)
-#define DBLK_AVSFLAGS 0x096e
-#define P_DBLK_AVSFLAGS                 DOS_REG_ADDR(DBLK_AVSFLAGS)
-#define DBLK_CBPY 0x0970
-#define P_DBLK_CBPY             DOS_REG_ADDR(DBLK_CBPY)
-#define DBLK_CBPY_ADJ 0x0971
-#define P_DBLK_CBPY_ADJ                 DOS_REG_ADDR(DBLK_CBPY_ADJ)
-#define DBLK_CBPC 0x0972
-#define P_DBLK_CBPC             DOS_REG_ADDR(DBLK_CBPC)
-#define DBLK_CBPC_ADJ 0x0973
-#define P_DBLK_CBPC_ADJ                 DOS_REG_ADDR(DBLK_CBPC_ADJ)
-#define DBLK_VHMVD 0x0974
-#define P_DBLK_VHMVD            DOS_REG_ADDR(DBLK_VHMVD)
-#define DBLK_STRONG 0x0975
-#define P_DBLK_STRONG           DOS_REG_ADDR(DBLK_STRONG)
-#define DBLK_RV8_QUANT 0x0976
-#define P_DBLK_RV8_QUANT                DOS_REG_ADDR(DBLK_RV8_QUANT)
-#define DBLK_CBUS_HCMD2 0x0977
-#define P_DBLK_CBUS_HCMD2               DOS_REG_ADDR(DBLK_CBUS_HCMD2)
-#define DBLK_CBUS_HCMD1 0x0978
-#define P_DBLK_CBUS_HCMD1               DOS_REG_ADDR(DBLK_CBUS_HCMD1)
-#define DBLK_CBUS_HCMD0 0x0979
-#define P_DBLK_CBUS_HCMD0               DOS_REG_ADDR(DBLK_CBUS_HCMD0)
-#define DBLK_VLD_HCMD2 0x097a
-#define P_DBLK_VLD_HCMD2                DOS_REG_ADDR(DBLK_VLD_HCMD2)
-#define DBLK_VLD_HCMD1 0x097b
-#define P_DBLK_VLD_HCMD1                DOS_REG_ADDR(DBLK_VLD_HCMD1)
-#define DBLK_VLD_HCMD0 0x097c
-#define P_DBLK_VLD_HCMD0                DOS_REG_ADDR(DBLK_VLD_HCMD0)
-#define DBLK_OST_YBASE 0x097d
-#define P_DBLK_OST_YBASE                DOS_REG_ADDR(DBLK_OST_YBASE)
-#define DBLK_OST_CBCRDIFF 0x097e
-#define P_DBLK_OST_CBCRDIFF             DOS_REG_ADDR(DBLK_OST_CBCRDIFF)
-#define DBLK_CTRL1 0x097f
-#define P_DBLK_CTRL1            DOS_REG_ADDR(DBLK_CTRL1)
-#define MCRCC_CTL1 0x0980
-#define P_MCRCC_CTL1            DOS_REG_ADDR(MCRCC_CTL1)
-#define MCRCC_CTL2 0x0981
-#define P_MCRCC_CTL2            DOS_REG_ADDR(MCRCC_CTL2)
-#define MCRCC_CTL3 0x0982
-#define P_MCRCC_CTL3            DOS_REG_ADDR(MCRCC_CTL3)
-#define GCLK_EN 0x0983
-#define P_GCLK_EN               DOS_REG_ADDR(GCLK_EN)
-#define MDEC_SW_RESET 0x0984
-#define P_MDEC_SW_RESET                 DOS_REG_ADDR(MDEC_SW_RESET)
-#define VLD_STATUS_CTRL 0x0c00
-#define P_VLD_STATUS_CTRL               DOS_REG_ADDR(VLD_STATUS_CTRL)
-#define MPEG1_2_REG 0x0c01
-#define P_MPEG1_2_REG           DOS_REG_ADDR(MPEG1_2_REG)
-#define F_CODE_REG 0x0c02
-#define P_F_CODE_REG            DOS_REG_ADDR(F_CODE_REG)
-#define PIC_HEAD_INFO 0x0c03
-#define P_PIC_HEAD_INFO                 DOS_REG_ADDR(PIC_HEAD_INFO)
-#define QP_VALUE_REG 0x0c05
-#define P_QP_VALUE_REG          DOS_REG_ADDR(QP_VALUE_REG)
-#define MBA_INC 0x0c06
-#define P_MBA_INC               DOS_REG_ADDR(MBA_INC)
-#define MB_MOTION_MODE 0x0c07
-#define P_MB_MOTION_MODE                DOS_REG_ADDR(MB_MOTION_MODE)
-#define POWER_CTL_VLD 0x0c08
-#define P_POWER_CTL_VLD                 DOS_REG_ADDR(POWER_CTL_VLD)
-#define MB_WIDTH 0x0c09
-#define P_MB_WIDTH              DOS_REG_ADDR(MB_WIDTH)
-#define SLICE_QP 0x0c0a
-#define P_SLICE_QP              DOS_REG_ADDR(SLICE_QP)
-#define PRE_START_CODE 0x0c0b
-#define P_PRE_START_CODE                DOS_REG_ADDR(PRE_START_CODE)
-#define SLICE_START_BYTE_01 0x0c0c
-#define P_SLICE_START_BYTE_01           DOS_REG_ADDR(SLICE_START_BYTE_01)
-#define SLICE_START_BYTE_23 0x0c0d
-#define P_SLICE_START_BYTE_23           DOS_REG_ADDR(SLICE_START_BYTE_23)
-#define RESYNC_MARKER_LENGTH 0x0c0e
-#define P_RESYNC_MARKER_LENGTH          DOS_REG_ADDR(RESYNC_MARKER_LENGTH)
-#define DECODER_BUFFER_INFO 0x0c0f
-#define P_DECODER_BUFFER_INFO           DOS_REG_ADDR(DECODER_BUFFER_INFO)
-#define FST_FOR_MV_X 0x0c10
-#define P_FST_FOR_MV_X          DOS_REG_ADDR(FST_FOR_MV_X)
-#define FST_FOR_MV_Y 0x0c11
-#define P_FST_FOR_MV_Y          DOS_REG_ADDR(FST_FOR_MV_Y)
-#define SCD_FOR_MV_X 0x0c12
-#define P_SCD_FOR_MV_X          DOS_REG_ADDR(SCD_FOR_MV_X)
-#define SCD_FOR_MV_Y 0x0c13
-#define P_SCD_FOR_MV_Y          DOS_REG_ADDR(SCD_FOR_MV_Y)
-#define FST_BAK_MV_X 0x0c14
-#define P_FST_BAK_MV_X          DOS_REG_ADDR(FST_BAK_MV_X)
-#define FST_BAK_MV_Y 0x0c15
-#define P_FST_BAK_MV_Y          DOS_REG_ADDR(FST_BAK_MV_Y)
-#define SCD_BAK_MV_X 0x0c16
-#define P_SCD_BAK_MV_X          DOS_REG_ADDR(SCD_BAK_MV_X)
-#define SCD_BAK_MV_Y 0x0c17
-#define P_SCD_BAK_MV_Y          DOS_REG_ADDR(SCD_BAK_MV_Y)
-#define VLD_DECODE_CONTROL 0x0c18
-#define P_VLD_DECODE_CONTROL            DOS_REG_ADDR(VLD_DECODE_CONTROL)
-#define VLD_REVERVED_19 0x0c19
-#define P_VLD_REVERVED_19               DOS_REG_ADDR(VLD_REVERVED_19)
-#define VIFF_BIT_CNT 0x0c1a
-#define P_VIFF_BIT_CNT          DOS_REG_ADDR(VIFF_BIT_CNT)
-#define BYTE_ALIGN_PEAK_HI 0x0c1b
-#define P_BYTE_ALIGN_PEAK_HI            DOS_REG_ADDR(BYTE_ALIGN_PEAK_HI)
-#define BYTE_ALIGN_PEAK_LO 0x0c1c
-#define P_BYTE_ALIGN_PEAK_LO            DOS_REG_ADDR(BYTE_ALIGN_PEAK_LO)
-#define NEXT_ALIGN_PEAK 0x0c1d
-#define P_NEXT_ALIGN_PEAK               DOS_REG_ADDR(NEXT_ALIGN_PEAK)
-#define VC1_CONTROL_REG 0x0c1e
-#define P_VC1_CONTROL_REG               DOS_REG_ADDR(VC1_CONTROL_REG)
-#define PMV1_X 0x0c20
-#define P_PMV1_X                DOS_REG_ADDR(PMV1_X)
-#define PMV1_Y 0x0c21
-#define P_PMV1_Y                DOS_REG_ADDR(PMV1_Y)
-#define PMV2_X 0x0c22
-#define P_PMV2_X                DOS_REG_ADDR(PMV2_X)
-#define PMV2_Y 0x0c23
-#define P_PMV2_Y                DOS_REG_ADDR(PMV2_Y)
-#define PMV3_X 0x0c24
-#define P_PMV3_X                DOS_REG_ADDR(PMV3_X)
-#define PMV3_Y 0x0c25
-#define P_PMV3_Y                DOS_REG_ADDR(PMV3_Y)
-#define PMV4_X 0x0c26
-#define P_PMV4_X                DOS_REG_ADDR(PMV4_X)
-#define PMV4_Y 0x0c27
-#define P_PMV4_Y                DOS_REG_ADDR(PMV4_Y)
-#define M4_TABLE_SELECT 0x0c28
-#define P_M4_TABLE_SELECT               DOS_REG_ADDR(M4_TABLE_SELECT)
-#define M4_CONTROL_REG 0x0c29
-#define P_M4_CONTROL_REG                DOS_REG_ADDR(M4_CONTROL_REG)
-#define BLOCK_NUM 0x0c2a
-#define P_BLOCK_NUM             DOS_REG_ADDR(BLOCK_NUM)
-#define PATTERN_CODE 0x0c2b
-#define P_PATTERN_CODE          DOS_REG_ADDR(PATTERN_CODE)
-#define MB_INFO 0x0c2c
-#define P_MB_INFO               DOS_REG_ADDR(MB_INFO)
-#define VLD_DC_PRED 0x0c2d
-#define P_VLD_DC_PRED           DOS_REG_ADDR(VLD_DC_PRED)
-#define VLD_ERROR_MASK 0x0c2e
-#define P_VLD_ERROR_MASK                DOS_REG_ADDR(VLD_ERROR_MASK)
-#define VLD_DC_PRED_C 0x0c2f
-#define P_VLD_DC_PRED_C                 DOS_REG_ADDR(VLD_DC_PRED_C)
-#define LAST_SLICE_MV_ADDR 0x0c30
-#define P_LAST_SLICE_MV_ADDR            DOS_REG_ADDR(LAST_SLICE_MV_ADDR)
-#define LAST_MVX 0x0c31
-#define P_LAST_MVX              DOS_REG_ADDR(LAST_MVX)
-#define LAST_MVY 0x0c32
-#define P_LAST_MVY              DOS_REG_ADDR(LAST_MVY)
-#define VLD_C38 0x0c38
-#define P_VLD_C38               DOS_REG_ADDR(VLD_C38)
-#define VLD_C39 0x0c39
-#define P_VLD_C39               DOS_REG_ADDR(VLD_C39)
-#define VLD_STATUS 0x0c3a
-#define P_VLD_STATUS            DOS_REG_ADDR(VLD_STATUS)
-#define VLD_SHIFT_STATUS 0x0c3b
-#define P_VLD_SHIFT_STATUS              DOS_REG_ADDR(VLD_SHIFT_STATUS)
-#define VOFF_STATUS 0x0c3c
-#define P_VOFF_STATUS           DOS_REG_ADDR(VOFF_STATUS)
-#define VLD_C3D 0x0c3d
-#define P_VLD_C3D               DOS_REG_ADDR(VLD_C3D)
-#define VLD_DBG_INDEX 0x0c3e
-#define P_VLD_DBG_INDEX                 DOS_REG_ADDR(VLD_DBG_INDEX)
-#define VLD_DBG_DATA 0x0c3f
-#define P_VLD_DBG_DATA          DOS_REG_ADDR(VLD_DBG_DATA)
-#define VLD_MEM_VIFIFO_START_PTR 0x0c40
-#define P_VLD_TIME_STAMP_0              DOS_REG_ADDR(VLD_TIME_STAMP_0)
-#define VLD_TIME_STAMP_1 0x0c4d
-#define P_VLD_TIME_STAMP_1              DOS_REG_ADDR(VLD_TIME_STAMP_1)
-#define VLD_TIME_STAMP_2 0x0c4e
-#define P_VLD_TIME_STAMP_2              DOS_REG_ADDR(VLD_TIME_STAMP_2)
-#define VLD_TIME_STAMP_3 0x0c4f
-#define P_VLD_TIME_STAMP_3              DOS_REG_ADDR(VLD_TIME_STAMP_3)
-#define VLD_MEM_VBUF2_RD_PTR 0x0c54
-#define P_VLD_MEM_VBUF2_RD_PTR          DOS_REG_ADDR(VLD_MEM_VBUF2_RD_PTR)
-#define VLD_MEM_SWAP_ADDR 0x0c55
-#define P_VLD_MEM_SWAP_ADDR             DOS_REG_ADDR(VLD_MEM_SWAP_ADDR)
-#define VLD_MEM_SWAP_CTL 0x0c56
-#define P_VLD_MEM_SWAP_CTL              DOS_REG_ADDR(VLD_MEM_SWAP_CTL)
-#define VCOP_CTRL_REG 0x0e00
-#define P_VCOP_CTRL_REG                 DOS_REG_ADDR(VCOP_CTRL_REG)
-#define QP_CTRL_REG 0x0e01
-#define P_QP_CTRL_REG           DOS_REG_ADDR(QP_CTRL_REG)
-#define INTRA_QUANT_MATRIX 0x0e02
-#define P_INTRA_QUANT_MATRIX            DOS_REG_ADDR(INTRA_QUANT_MATRIX)
-#define NON_I_QUANT_MATRIX 0x0e03
-#define P_NON_I_QUANT_MATRIX            DOS_REG_ADDR(NON_I_QUANT_MATRIX)
-#define DC_SCALER 0x0e04
-#define P_DC_SCALER             DOS_REG_ADDR(DC_SCALER)
-#define DC_AC_CTRL 0x0e05
-#define P_DC_AC_CTRL            DOS_REG_ADDR(DC_AC_CTRL)
-#define DC_AC_SCALE_MUL 0x0e06
-#define P_DC_AC_SCALE_MUL               DOS_REG_ADDR(DC_AC_SCALE_MUL)
-#define DC_AC_SCALE_DIV 0x0e07
-#define P_DC_AC_SCALE_DIV               DOS_REG_ADDR(DC_AC_SCALE_DIV)
-#define POWER_CTL_IQIDCT 0x0e08
-#define P_POWER_CTL_IQIDCT              DOS_REG_ADDR(POWER_CTL_IQIDCT)
-#define RV_AI_Y_X 0x0e09
-#define P_RV_AI_Y_X             DOS_REG_ADDR(RV_AI_Y_X)
-#define RV_AI_U_X 0x0e0a
-#define P_RV_AI_U_X             DOS_REG_ADDR(RV_AI_U_X)
-#define RV_AI_V_X 0x0e0b
-#define P_RV_AI_V_X             DOS_REG_ADDR(RV_AI_V_X)
-#define RV_AI_MB_COUNT 0x0e0c
-#define P_RV_AI_MB_COUNT                DOS_REG_ADDR(RV_AI_MB_COUNT)
-#define IQIDCT_CONTROL 0x0e0e
-#define P_IQIDCT_CONTROL                DOS_REG_ADDR(IQIDCT_CONTROL)
-#define IQIDCT_DEBUG_INFO_0 0x0e0f
-#define P_IQIDCT_DEBUG_INFO_0           DOS_REG_ADDR(IQIDCT_DEBUG_INFO_0)
-#define DEBLK_CMD 0x0e10
-#define P_DEBLK_CMD             DOS_REG_ADDR(DEBLK_CMD)
-#define IQIDCT_DEBUG_IDCT 0x0e11
-#define P_IQIDCT_DEBUG_IDCT             DOS_REG_ADDR(IQIDCT_DEBUG_IDCT)
-#define DCAC_DMA_CTRL 0x0e12
-#define P_DCAC_DMA_CTRL                 DOS_REG_ADDR(DCAC_DMA_CTRL)
-#define DCAC_DMA_ADDRESS 0x0e13
-#define P_DCAC_DMA_ADDRESS              DOS_REG_ADDR(DCAC_DMA_ADDRESS)
-#define DCAC_CPU_ADDRESS 0x0e14
-#define P_DCAC_CPU_ADDRESS              DOS_REG_ADDR(DCAC_CPU_ADDRESS)
-#define DCAC_CPU_DATA 0x0e15
-#define P_DCAC_CPU_DATA                 DOS_REG_ADDR(DCAC_CPU_DATA)
-#define DCAC_MB_COUNT 0x0e16
-#define P_DCAC_MB_COUNT                 DOS_REG_ADDR(DCAC_MB_COUNT)
-#define IQ_QUANT 0x0e17
-#define P_IQ_QUANT              DOS_REG_ADDR(IQ_QUANT)
-#define VC1_BITPLANE_CTL 0x0e18
-#define P_VC1_BITPLANE_CTL              DOS_REG_ADDR(VC1_BITPLANE_CTL)
-#define MSP 0x0300
-#define P_MSP           DOS_REG_ADDR(MSP)
-#define MPSR 0x0301
-#define P_MPSR          DOS_REG_ADDR(MPSR)
-#define MINT_VEC_BASE 0x0302
-#define P_MINT_VEC_BASE                 DOS_REG_ADDR(MINT_VEC_BASE)
-#define MCPU_INTR_GRP 0x0303
-#define P_MCPU_INTR_GRP                 DOS_REG_ADDR(MCPU_INTR_GRP)
-#define MCPU_INTR_MSK 0x0304
-#define P_MCPU_INTR_MSK                 DOS_REG_ADDR(MCPU_INTR_MSK)
-#define MCPU_INTR_REQ 0x0305
-#define P_MCPU_INTR_REQ                 DOS_REG_ADDR(MCPU_INTR_REQ)
-#define MPC_P 0x0306
-#define P_MPC_P                 DOS_REG_ADDR(MPC_P)
-#define MPC_D 0x0307
-#define P_MPC_D                 DOS_REG_ADDR(MPC_D)
-#define MPC_E 0x0308
-#define P_MPC_E                 DOS_REG_ADDR(MPC_E)
-#define MPC_W 0x0309
-#define P_MPC_W                 DOS_REG_ADDR(MPC_W)
-#define MINDEX0_REG 0x030a
-#define P_MINDEX0_REG           DOS_REG_ADDR(MINDEX0_REG)
-#define MINDEX1_REG 0x030b
-#define P_MINDEX1_REG           DOS_REG_ADDR(MINDEX1_REG)
-#define MINDEX2_REG 0x030c
-#define P_MINDEX2_REG           DOS_REG_ADDR(MINDEX2_REG)
-#define MINDEX3_REG 0x030d
-#define P_MINDEX3_REG           DOS_REG_ADDR(MINDEX3_REG)
-#define MINDEX4_REG 0x030e
-#define P_MINDEX4_REG           DOS_REG_ADDR(MINDEX4_REG)
-#define MINDEX5_REG 0x030f
-#define P_MINDEX5_REG           DOS_REG_ADDR(MINDEX5_REG)
-#define MINDEX6_REG 0x0310
-#define P_MINDEX6_REG           DOS_REG_ADDR(MINDEX6_REG)
-#define MINDEX7_REG 0x0311
-#define P_MINDEX7_REG           DOS_REG_ADDR(MINDEX7_REG)
-#define MMIN_REG 0x0312
-#define P_MMIN_REG              DOS_REG_ADDR(MMIN_REG)
-#define MMAX_REG 0x0313
-#define P_MMAX_REG              DOS_REG_ADDR(MMAX_REG)
-#define MBREAK0_REG 0x0314
-#define P_MBREAK0_REG           DOS_REG_ADDR(MBREAK0_REG)
-#define MBREAK1_REG 0x0315
-#define P_MBREAK1_REG           DOS_REG_ADDR(MBREAK1_REG)
-#define MBREAK2_REG 0x0316
-#define P_MBREAK2_REG           DOS_REG_ADDR(MBREAK2_REG)
-#define MBREAK3_REG 0x0317
-#define P_MBREAK3_REG           DOS_REG_ADDR(MBREAK3_REG)
-#define MBREAK_TYPE 0x0318
-#define P_MBREAK_TYPE           DOS_REG_ADDR(MBREAK_TYPE)
-#define MBREAK_CTRL 0x0319
-#define P_MBREAK_CTRL           DOS_REG_ADDR(MBREAK_CTRL)
-#define MBREAK_STAUTS 0x031a
-#define P_MBREAK_STAUTS                 DOS_REG_ADDR(MBREAK_STAUTS)
-#define MDB_ADDR_REG 0x031b
-#define P_MDB_ADDR_REG          DOS_REG_ADDR(MDB_ADDR_REG)
-#define MDB_DATA_REG 0x031c
-#define P_MDB_DATA_REG          DOS_REG_ADDR(MDB_DATA_REG)
-#define MDB_CTRL 0x031d
-#define P_MDB_CTRL              DOS_REG_ADDR(MDB_CTRL)
-#define MSFTINT0 0x031e
-#define P_MSFTINT0              DOS_REG_ADDR(MSFTINT0)
-#define MSFTINT1 0x031f
-#define P_MSFTINT1              DOS_REG_ADDR(MSFTINT1)
-#define CSP 0x0320
-#define P_CSP           DOS_REG_ADDR(CSP)
-#define CPSR 0x0321
-#define P_CPSR          DOS_REG_ADDR(CPSR)
-#define CINT_VEC_BASE 0x0322
-#define P_CINT_VEC_BASE                 DOS_REG_ADDR(CINT_VEC_BASE)
-#define CCPU_INTR_GRP 0x0323
-#define P_CCPU_INTR_GRP                 DOS_REG_ADDR(CCPU_INTR_GRP)
-#define CCPU_INTR_MSK 0x0324
-#define P_CCPU_INTR_MSK                 DOS_REG_ADDR(CCPU_INTR_MSK)
-#define CCPU_INTR_REQ 0x0325
-#define P_CCPU_INTR_REQ                 DOS_REG_ADDR(CCPU_INTR_REQ)
-#define CPC_P 0x0326
-#define P_CPC_P                 DOS_REG_ADDR(CPC_P)
-#define CPC_D 0x0327
-#define P_CPC_D                 DOS_REG_ADDR(CPC_D)
-#define CPC_E 0x0328
-#define P_CPC_E                 DOS_REG_ADDR(CPC_E)
-#define CPC_W 0x0329
-#define P_CPC_W                 DOS_REG_ADDR(CPC_W)
-#define CINDEX0_REG 0x032a
-#define P_CINDEX0_REG           DOS_REG_ADDR(CINDEX0_REG)
-#define CINDEX1_REG 0x032b
-#define P_CINDEX1_REG           DOS_REG_ADDR(CINDEX1_REG)
-#define CINDEX2_REG 0x032c
-#define P_CINDEX2_REG           DOS_REG_ADDR(CINDEX2_REG)
-#define CINDEX3_REG 0x032d
-#define P_CINDEX3_REG           DOS_REG_ADDR(CINDEX3_REG)
-#define CINDEX4_REG 0x032e
-#define P_CINDEX4_REG           DOS_REG_ADDR(CINDEX4_REG)
-#define CINDEX5_REG 0x032f
-#define P_CINDEX5_REG           DOS_REG_ADDR(CINDEX5_REG)
-#define CINDEX6_REG 0x0330
-#define P_CINDEX6_REG           DOS_REG_ADDR(CINDEX6_REG)
-#define CINDEX7_REG 0x0331
-#define P_CINDEX7_REG           DOS_REG_ADDR(CINDEX7_REG)
-#define CMIN_REG 0x0332
-#define P_CMIN_REG              DOS_REG_ADDR(CMIN_REG)
-#define CMAX_REG 0x0333
-#define P_CMAX_REG              DOS_REG_ADDR(CMAX_REG)
-#define CBREAK0_REG 0x0334
-#define P_CBREAK0_REG           DOS_REG_ADDR(CBREAK0_REG)
-#define CBREAK1_REG 0x0335
-#define P_CBREAK1_REG           DOS_REG_ADDR(CBREAK1_REG)
-#define CBREAK2_REG 0x0336
-#define P_CBREAK2_REG           DOS_REG_ADDR(CBREAK2_REG)
-#define CBREAK3_REG 0x0337
-#define P_CBREAK3_REG           DOS_REG_ADDR(CBREAK3_REG)
-#define CBREAK_TYPE 0x0338
-#define P_CBREAK_TYPE           DOS_REG_ADDR(CBREAK_TYPE)
-#define CBREAK_CTRL 0x0339
-#define P_CBREAK_CTRL           DOS_REG_ADDR(CBREAK_CTRL)
-#define CBREAK_STAUTS 0x033a
-#define P_CBREAK_STAUTS                 DOS_REG_ADDR(CBREAK_STAUTS)
-#define CDB_ADDR_REG 0x033b
-#define P_CDB_ADDR_REG          DOS_REG_ADDR(CDB_ADDR_REG)
-#define CDB_DATA_REG 0x033c
-#define P_CDB_DATA_REG          DOS_REG_ADDR(CDB_DATA_REG)
-#define CDB_CTRL 0x033d
-#define P_CDB_CTRL              DOS_REG_ADDR(CDB_CTRL)
-#define CSFTINT0 0x033e
-#define P_CSFTINT0              DOS_REG_ADDR(CSFTINT0)
-#define CSFTINT1 0x033f
-#define P_CSFTINT1              DOS_REG_ADDR(CSFTINT1)
-#define IMEM_DMA_CTRL 0x0340
-#define P_IMEM_DMA_CTRL                 DOS_REG_ADDR(IMEM_DMA_CTRL)
-#define IMEM_DMA_ADR 0x0341
-#define P_IMEM_DMA_ADR          DOS_REG_ADDR(IMEM_DMA_ADR)
-#define IMEM_DMA_COUNT 0x0342
-#define P_IMEM_DMA_COUNT                DOS_REG_ADDR(IMEM_DMA_COUNT)
-#define WRRSP_IMEM 0x0343
-#define P_WRRSP_IMEM            DOS_REG_ADDR(WRRSP_IMEM)
-#define LMEM_DMA_CTRL 0x0350
-#define P_LMEM_DMA_CTRL                 DOS_REG_ADDR(LMEM_DMA_CTRL)
-#define LMEM_DMA_ADR 0x0351
-#define P_LMEM_DMA_ADR          DOS_REG_ADDR(LMEM_DMA_ADR)
-#define LMEM_DMA_COUNT 0x0352
-#define P_LMEM_DMA_COUNT                DOS_REG_ADDR(LMEM_DMA_COUNT)
-#define WRRSP_LMEM 0x0353
-#define P_WRRSP_LMEM            DOS_REG_ADDR(WRRSP_LMEM)
-#define MAC_CTRL1 0x0360
-#define P_MAC_CTRL1             DOS_REG_ADDR(MAC_CTRL1)
-#define ACC0REG1 0x0361
-#define P_ACC0REG1              DOS_REG_ADDR(ACC0REG1)
-#define ACC1REG1 0x0362
-#define P_ACC1REG1              DOS_REG_ADDR(ACC1REG1)
-#define MAC_CTRL2 0x0370
-#define P_MAC_CTRL2             DOS_REG_ADDR(MAC_CTRL2)
-#define ACC0REG2 0x0371
-#define P_ACC0REG2              DOS_REG_ADDR(ACC0REG2)
-#define ACC1REG2 0x0372
-#define P_ACC1REG2              DOS_REG_ADDR(ACC1REG2)
-#define CPU_TRACE 0x0380
-#define P_CPU_TRACE             DOS_REG_ADDR(CPU_TRACE)
-#define HENC_SCRATCH_0 0x1ac0
-#define P_HENC_SCRATCH_0                DOS_REG_ADDR(HENC_SCRATCH_0)
-#define HENC_SCRATCH_1 0x1ac1
-#define P_HENC_SCRATCH_1                DOS_REG_ADDR(HENC_SCRATCH_1)
-#define HENC_SCRATCH_2 0x1ac2
-#define P_HENC_SCRATCH_2                DOS_REG_ADDR(HENC_SCRATCH_2)
-#define HENC_SCRATCH_3 0x1ac3
-#define P_HENC_SCRATCH_3                DOS_REG_ADDR(HENC_SCRATCH_3)
-#define HENC_SCRATCH_4 0x1ac4
-#define P_HENC_SCRATCH_4                DOS_REG_ADDR(HENC_SCRATCH_4)
-#define HENC_SCRATCH_5 0x1ac5
-#define P_HENC_SCRATCH_5                DOS_REG_ADDR(HENC_SCRATCH_5)
-#define HENC_SCRATCH_6 0x1ac6
-#define P_HENC_SCRATCH_6                DOS_REG_ADDR(HENC_SCRATCH_6)
-#define HENC_SCRATCH_7 0x1ac7
-#define P_HENC_SCRATCH_7                DOS_REG_ADDR(HENC_SCRATCH_7)
-#define HENC_SCRATCH_8 0x1ac8
-#define P_HENC_SCRATCH_8                DOS_REG_ADDR(HENC_SCRATCH_8)
-#define HENC_SCRATCH_9 0x1ac9
-#define P_HENC_SCRATCH_9                DOS_REG_ADDR(HENC_SCRATCH_9)
-#define HENC_SCRATCH_A 0x1aca
-#define P_HENC_SCRATCH_A                DOS_REG_ADDR(HENC_SCRATCH_A)
-#define HENC_SCRATCH_B 0x1acb
-#define P_HENC_SCRATCH_B                DOS_REG_ADDR(HENC_SCRATCH_B)
-#define HENC_SCRATCH_C 0x1acc
-#define P_HENC_SCRATCH_C                DOS_REG_ADDR(HENC_SCRATCH_C)
-#define HENC_SCRATCH_D 0x1acd
-#define P_HENC_SCRATCH_D                DOS_REG_ADDR(HENC_SCRATCH_D)
-#define HENC_SCRATCH_E 0x1ace
-#define P_HENC_SCRATCH_E                DOS_REG_ADDR(HENC_SCRATCH_E)
-#define HENC_SCRATCH_F 0x1acf
-#define P_HENC_SCRATCH_F                DOS_REG_ADDR(HENC_SCRATCH_F)
-#define HENC_SCRATCH_G 0x1ad0
-#define P_HENC_SCRATCH_G                DOS_REG_ADDR(HENC_SCRATCH_G)
-#define HENC_SCRATCH_H 0x1ad1
-#define P_HENC_SCRATCH_H                DOS_REG_ADDR(HENC_SCRATCH_H)
-#define HENC_SCRATCH_I 0x1ad2
-#define P_HENC_SCRATCH_I                DOS_REG_ADDR(HENC_SCRATCH_I)
-#define HENC_SCRATCH_J 0x1ad3
-#define P_HENC_SCRATCH_J                DOS_REG_ADDR(HENC_SCRATCH_J)
-#define HENC_SCRATCH_K 0x1ad4
-#define P_HENC_SCRATCH_K                DOS_REG_ADDR(HENC_SCRATCH_K)
-#define HENC_SCRATCH_L 0x1ad5
-#define P_HENC_SCRATCH_L                DOS_REG_ADDR(HENC_SCRATCH_L)
-#define HENC_SCRATCH_M 0x1ad6
-#define P_HENC_SCRATCH_M                DOS_REG_ADDR(HENC_SCRATCH_M)
-#define HENC_SCRATCH_N 0x1ad7
-#define P_HENC_SCRATCH_N                DOS_REG_ADDR(HENC_SCRATCH_N)
-#define VLC_STATUS_CTRL 0x1d00
-#define P_VLC_STATUS_CTRL               DOS_REG_ADDR(VLC_STATUS_CTRL)
-#define VLC_CONFIG 0x1d01
-#define P_VLC_CONFIG            DOS_REG_ADDR(VLC_CONFIG)
-#define VLC_VB_START_PTR 0x1d10
-#define P_VLC_VB_START_PTR              DOS_REG_ADDR(VLC_VB_START_PTR)
-#define VLC_VB_END_PTR 0x1d11
-#define P_VLC_VB_END_PTR                DOS_REG_ADDR(VLC_VB_END_PTR)
-#define VLC_VB_WR_PTR 0x1d12
-#define P_VLC_VB_WR_PTR                 DOS_REG_ADDR(VLC_VB_WR_PTR)
-#define VLC_VB_RD_PTR 0x1d13
-#define P_VLC_VB_RD_PTR                 DOS_REG_ADDR(VLC_VB_RD_PTR)
-#define VLC_VB_SW_RD_PTR 0x1d14
-#define P_VLC_VB_SW_RD_PTR              DOS_REG_ADDR(VLC_VB_SW_RD_PTR)
-#define VLC_VB_LEFT 0x1d15
-#define P_VLC_VB_LEFT           DOS_REG_ADDR(VLC_VB_LEFT)
-#define VLC_VB_CONTROL 0x1d16
-#define P_VLC_VB_CONTROL                DOS_REG_ADDR(VLC_VB_CONTROL)
-#define VLC_VB_MEM_CTL 0x1d17
-#define P_VLC_VB_MEM_CTL                DOS_REG_ADDR(VLC_VB_MEM_CTL)
-#define VLC_VB_INT_PTR 0x1d18
-#define P_VLC_VB_INT_PTR                DOS_REG_ADDR(VLC_VB_INT_PTR)
-#define VLC_WRRSP 0x1d19
-#define P_VLC_WRRSP             DOS_REG_ADDR(VLC_WRRSP)
-#define VLC_TOTAL_BYTES 0x1d1a
-#define P_VLC_TOTAL_BYTES               DOS_REG_ADDR(VLC_TOTAL_BYTES)
-#define VLC_VB_BUFF 0x1d1b
-#define P_VLC_VB_BUFF           DOS_REG_ADDR(VLC_VB_BUFF)
-#define VLC_VB_PRE_BUFF_HI 0x1d1c
-#define P_VLC_VB_PRE_BUFF_HI            DOS_REG_ADDR(VLC_VB_PRE_BUFF_HI)
-#define VLC_VB_PRE_BUFF_LOW 0x1d1d
-#define P_VLC_VB_PRE_BUFF_LOW           DOS_REG_ADDR(VLC_VB_PRE_BUFF_LOW)
-#define VLC_STREAM_BUFF 0x1d1e
-#define P_VLC_STREAM_BUFF               DOS_REG_ADDR(VLC_STREAM_BUFF)
-#define VLC_PUSH_STREAM 0x1d1f
-#define P_VLC_PUSH_STREAM               DOS_REG_ADDR(VLC_PUSH_STREAM)
-#define VLC_PUSH_ELEMENT 0x1d20
-#define P_VLC_PUSH_ELEMENT              DOS_REG_ADDR(VLC_PUSH_ELEMENT)
-#define VLC_ELEMENT_DATA 0x1d21
-#define P_VLC_ELEMENT_DATA              DOS_REG_ADDR(VLC_ELEMENT_DATA)
-/*add from M8M2*/
-#define VLC_SPECIAL_CTL 0x1d22
-#define P_VLC_SPECIAL_CTL               DOS_REG_ADDR(VLC_SPECIAL_CTL)
-#define VLC_HCMD_T_L_INFO 0x1d23
-#define P_VLC_HCMD_T_L_INFO             DOS_REG_ADDR(VLC_HCMD_T_L_INFO)
-#define VLC_HCMD_CUR_INFO 0x1d24
-#define P_VLC_HCMD_CUR_INFO             DOS_REG_ADDR(VLC_HCMD_CUR_INFO)
-/**/
-#define IE_CONTROL 0x1f40
-#define P_IE_CONTROL            DOS_REG_ADDR(IE_CONTROL)
-#define IE_MB_POSITION 0x1f41
-#define P_IE_MB_POSITION                DOS_REG_ADDR(IE_MB_POSITION)
-#define IE_ME_MB_INFO 0x1f42
-#define P_IE_ME_MB_INFO                 DOS_REG_ADDR(IE_ME_MB_INFO)
-#define SAD_CONTROL 0x1f43
-#define P_SAD_CONTROL           DOS_REG_ADDR(SAD_CONTROL)
-#define IE_RESULT_BUFFER 0x1f44
-#define P_IE_RESULT_BUFFER              DOS_REG_ADDR(IE_RESULT_BUFFER)
-#define IE_I4_PRED_MODE_HI 0x1f45
-#define P_IE_I4_PRED_MODE_HI            DOS_REG_ADDR(IE_I4_PRED_MODE_HI)
-#define IE_I4_PRED_MODE_LO 0x1f46
-#define P_IE_I4_PRED_MODE_LO            DOS_REG_ADDR(IE_I4_PRED_MODE_LO)
-#define IE_C_PRED_MODE 0x1f47
-#define P_IE_C_PRED_MODE                DOS_REG_ADDR(IE_C_PRED_MODE)
-#define IE_CUR_REF_SEL 0x1f48
-#define P_IE_CUR_REF_SEL                DOS_REG_ADDR(IE_CUR_REF_SEL)
-#define ME_CONTROL 0x1f49
-#define P_ME_CONTROL            DOS_REG_ADDR(ME_CONTROL)
-#define ME_START_POSITION 0x1f4a
-#define P_ME_START_POSITION             DOS_REG_ADDR(ME_START_POSITION)
-#define ME_STATUS 0x1f4b
-#define P_ME_STATUS             DOS_REG_ADDR(ME_STATUS)
-#define ME_DEBUG 0x1f4c
-#define P_ME_DEBUG              DOS_REG_ADDR(ME_DEBUG)
-#define ME_SKIP_LINE 0x1f4d
-#define P_ME_SKIP_LINE          DOS_REG_ADDR(ME_SKIP_LINE)
-#define ME_AB_MEM_CTL 0x1f4e
-#define P_ME_AB_MEM_CTL                 DOS_REG_ADDR(ME_AB_MEM_CTL)
-#define ME_PIC_INFO 0x1f4f
-#define P_ME_PIC_INFO           DOS_REG_ADDR(ME_PIC_INFO)
-#define ME_SAD_ENOUGH_01 0x1f50
-#define P_ME_SAD_ENOUGH_01              DOS_REG_ADDR(ME_SAD_ENOUGH_01)
-#define ME_SAD_ENOUGH_23 0x1f51
-#define P_ME_SAD_ENOUGH_23              DOS_REG_ADDR(ME_SAD_ENOUGH_23)
-#define ME_STEP0_CLOSE_MV 0x1f52
-#define P_ME_STEP0_CLOSE_MV             DOS_REG_ADDR(ME_STEP0_CLOSE_MV)
-#define ME_F_SKIP_SAD 0x1f53
-#define P_ME_F_SKIP_SAD                 DOS_REG_ADDR(ME_F_SKIP_SAD)
-#define ME_F_SKIP_WEIGHT 0x1f54
-#define P_ME_F_SKIP_WEIGHT              DOS_REG_ADDR(ME_F_SKIP_WEIGHT)
-#define ME_MV_MERGE_CTL 0x1f55
-#define P_ME_MV_MERGE_CTL               DOS_REG_ADDR(ME_MV_MERGE_CTL)
-#define ME_MV_WEIGHT_01 0x1f56
-#define P_ME_MV_WEIGHT_01               DOS_REG_ADDR(ME_MV_WEIGHT_01)
-#define ME_MV_WEIGHT_23 0x1f57
-#define P_ME_MV_WEIGHT_23               DOS_REG_ADDR(ME_MV_WEIGHT_23)
-#define ME_SAD_RANGE_INC 0x1f58
-#define P_ME_SAD_RANGE_INC              DOS_REG_ADDR(ME_SAD_RANGE_INC)
-#define ME_SUB_MERGE_CTL 0x1f59
-#define P_ME_SUB_MERGE_CTL              DOS_REG_ADDR(ME_SUB_MERGE_CTL)
-#define ME_SUB_REF_MV_CTL 0x1f5a
-#define P_ME_SUB_REF_MV_CTL             DOS_REG_ADDR(ME_SUB_REF_MV_CTL)
-#define ME_SUB_FIX_SAD 0x1f5c
-#define P_ME_SUB_FIX_SAD                DOS_REG_ADDR(ME_SUB_FIX_SAD)
-#define ME_SUB_FIX_MIN_SAD 0x1f5d
-#define P_ME_SUB_FIX_MIN_SAD            DOS_REG_ADDR(ME_SUB_FIX_MIN_SAD)
-#define ME_SUB_SNAP_GLITCH 0x1f5e
-#define P_ME_SUB_SNAP_GLITCH            DOS_REG_ADDR(ME_SUB_SNAP_GLITCH)
-#define ME_SUB_ACT_CTL 0x1f5f
-#define P_ME_SUB_ACT_CTL                DOS_REG_ADDR(ME_SUB_ACT_CTL)
-/*add from M8M2*/
-#define HEVC_ASSIST_GCLK_EN 0x3003
-#define P_HEVC_ASSIST_GCLK_EN           DOS_REG_ADDR(HEVC_ASSIST_GCLK_EN)
-#define HEVC_ASSIST_SW_RESET 0x3004
-#define P_HEVC_ASSIST_SW_RESET          DOS_REG_ADDR(HEVC_ASSIST_SW_RESET)
-#define HEVC_ASSIST_AMR1_INT0 0x3025
-#define HEVC_ASSIST_DMA_INT2 0x3066
-#define P_HEVC_ASSIST_DMA_INT2          DOS_REG_ADDR(HEVC_ASSIST_DMA_INT2)
-#define HEVC_PARSER_VERSION 0x3100
-#define P_HEVC_PARSER_VERSION           DOS_REG_ADDR(HEVC_PARSER_VERSION)
-#define HEVC_STREAM_CONTROL 0x3101
-#define P_HEVC_STREAM_CONTROL           DOS_REG_ADDR(HEVC_STREAM_CONTROL)
-#define HEVC_STREAM_END_ADDR 0x3103
-#define P_HEVC_STREAM_END_ADDR          DOS_REG_ADDR(HEVC_STREAM_END_ADDR)
-#define HEVC_STREAM_WR_PTR 0x3104
-#define P_HEVC_STREAM_WR_PTR            DOS_REG_ADDR(HEVC_STREAM_WR_PTR)
-#define HEVC_STREAM_RD_PTR 0x3105
-#define P_HEVC_STREAM_RD_PTR            DOS_REG_ADDR(HEVC_STREAM_RD_PTR)
-#define HEVC_STREAM_LEVEL 0x3106
-#define P_HEVC_STREAM_LEVEL             DOS_REG_ADDR(HEVC_STREAM_LEVEL)
-#define HEVC_STREAM_FIFO_CTL 0x3107
-#define P_HEVC_STREAM_FIFO_CTL          DOS_REG_ADDR(HEVC_STREAM_FIFO_CTL)
-#define HEVC_SHIFT_CONTROL 0x3108
-#define P_HEVC_SHIFT_CONTROL            DOS_REG_ADDR(HEVC_SHIFT_CONTROL)
-#define HEVC_SHIFT_STARTCODE 0x3109
-#define P_HEVC_SHIFT_STARTCODE          DOS_REG_ADDR(HEVC_SHIFT_STARTCODE)
-#define HEVC_SHIFT_STATUS 0x310b
-#define P_HEVC_SHIFT_STATUS             DOS_REG_ADDR(HEVC_SHIFT_STATUS)
-#define HEVC_SHIFTED_DATA 0x310c
-#define P_HEVC_SHIFTED_DATA             DOS_REG_ADDR(HEVC_SHIFTED_DATA)
-#define HEVC_PARSER_RESULT_0 0x3118
-#define P_HEVC_PARSER_RESULT_0          DOS_REG_ADDR(HEVC_PARSER_RESULT_0)
-#define HEVC_PARSER_RESULT_1 0x3119
-#define P_HEVC_PARSER_RESULT_1          DOS_REG_ADDR(HEVC_PARSER_RESULT_1)
-#define HEVC_PARSER_RESULT_2 0x311a
-#define P_HEVC_PARSER_RESULT_2          DOS_REG_ADDR(HEVC_PARSER_RESULT_2)
-#define HEVC_PARSER_RESULT_3 0x311b
-#define P_HEVC_PARSER_RESULT_3          DOS_REG_ADDR(HEVC_PARSER_RESULT_3)
-#define HEVC_CABAC_TOP_INFO 0x311c
-#define P_HEVC_CABAC_TOP_INFO           DOS_REG_ADDR(HEVC_CABAC_TOP_INFO)
-#define HEVC_SAO_IF_STATUS 0x3130
-#define P_HEVC_SAO_IF_STATUS            DOS_REG_ADDR(HEVC_SAO_IF_STATUS)
-#define HEVC_SAO_IF_DATA_Y 0x3131
-#define P_HEVC_SAO_IF_DATA_Y            DOS_REG_ADDR(HEVC_SAO_IF_DATA_Y)
-#define HEVC_SAO_IF_DATA_U 0x3132
-#define P_HEVC_SAO_IF_DATA_U            DOS_REG_ADDR(HEVC_SAO_IF_DATA_U)
-#define HEVC_SAO_IF_DATA_V 0x3133
-#define P_HEVC_SAO_IF_DATA_V            DOS_REG_ADDR(HEVC_SAO_IF_DATA_V)
-#define HEVC_STREAM_SWAP_ADDR 0x3134
-#define HEVC_MPRED_VERSION 0x3200
-#define P_HEVC_MPRED_VERSION            DOS_REG_ADDR(HEVC_MPRED_VERSION)
-#define HEVC_MPRED_CTRL0 0x3201
-#define P_HEVC_MPRED_CTRL0              DOS_REG_ADDR(HEVC_MPRED_CTRL0)
-#define HEVC_MPRED_CTRL1 0x3202
-#define P_HEVC_MPRED_CTRL1              DOS_REG_ADDR(HEVC_MPRED_CTRL1)
-#define HEVC_MPRED_INT_EN 0x3203
-#define P_HEVC_MPRED_INT_EN             DOS_REG_ADDR(HEVC_MPRED_INT_EN)
-#define HEVC_MPRED_INT_STATUS 0x3204
-
-#define HEVC_MPRED_REF_NUM 0x3209
-#define P_HEVC_MPRED_REF_NUM            DOS_REG_ADDR(HEVC_MPRED_REF_NUM)
-#define HEVC_MPRED_LT_REF 0x320a
-#define P_HEVC_MPRED_LT_REF             DOS_REG_ADDR(HEVC_MPRED_LT_REF)
-#define HEVC_MPRED_LT_COLREF 0x320b
-#define P_HEVC_MPRED_LT_COLREF          DOS_REG_ADDR(HEVC_MPRED_LT_COLREF)
-#define HEVC_MPRED_REF_EN_L0 0x320c
-#define P_HEVC_MPRED_REF_EN_L0          DOS_REG_ADDR(HEVC_MPRED_REF_EN_L0)
-#define HEVC_MPRED_REF_EN_L1 0x320d
-#define P_HEVC_MPRED_REF_EN_L1          DOS_REG_ADDR(HEVC_MPRED_REF_EN_L1)
-#define HEVC_MPRED_CURR_LCU 0x3219
-#define P_HEVC_MPRED_CURR_LCU           DOS_REG_ADDR(HEVC_MPRED_CURR_LCU)
-#define HEVC_MPRED_ABV_WPTR 0x321a
-#define P_HEVC_MPRED_ABV_WPTR           DOS_REG_ADDR(HEVC_MPRED_ABV_WPTR)
-#define HEVC_MPRED_ABV_RPTR 0x321b
-#define P_HEVC_MPRED_ABV_RPTR           DOS_REG_ADDR(HEVC_MPRED_ABV_RPTR)
-#define HEVC_MPRED_CTRL2 0x321c
-#define P_HEVC_MPRED_CTRL2              DOS_REG_ADDR(HEVC_MPRED_CTRL2)
-#define HEVC_MPRED_CTRL3 0x321d
-#define P_HEVC_MPRED_CTRL3              DOS_REG_ADDR(HEVC_MPRED_CTRL3)
-#define HEVC_MPRED_MV_WLCUY 0x321e
-#define P_HEVC_MPRED_MV_WLCUY           DOS_REG_ADDR(HEVC_MPRED_MV_WLCUY)
-#define HEVC_MPRED_MV_RLCUY 0x321f
-#define P_HEVC_MPRED_MV_RLCUY           DOS_REG_ADDR(HEVC_MPRED_MV_RLCUY)
-
-#define HEVC_MPRED_DBG_MODE0 0x3241
-#define P_HEVC_MPRED_DBG_MODE0          DOS_REG_ADDR(HEVC_MPRED_DBG_MODE0)
-#define HEVC_MPRED_DBG_MODE1 0x3242
-#define P_HEVC_MPRED_DBG_MODE1          DOS_REG_ADDR(HEVC_MPRED_DBG_MODE1)
-#define HEVC_MPRED_DBG2_MODE 0x3243
-#define P_HEVC_MPRED_DBG2_MODE          DOS_REG_ADDR(HEVC_MPRED_DBG2_MODE)
-#define HEVC_MPRED_IMP_CMD0 0x3244
-#define P_HEVC_MPRED_IMP_CMD0           DOS_REG_ADDR(HEVC_MPRED_IMP_CMD0)
-#define HEVC_MPRED_IMP_CMD1 0x3245
-#define P_HEVC_MPRED_IMP_CMD1           DOS_REG_ADDR(HEVC_MPRED_IMP_CMD1)
-#define HEVC_MPRED_IMP_CMD2 0x3246
-#define P_HEVC_MPRED_IMP_CMD2           DOS_REG_ADDR(HEVC_MPRED_IMP_CMD2)
-#define HEVC_MPRED_IMP_CMD3 0x3247
-#define P_HEVC_MPRED_IMP_CMD3           DOS_REG_ADDR(HEVC_MPRED_IMP_CMD3)
-#define HEVCD_IPP_TOP_LCUCONFIG 0x3406
-#define P_HEVC_DBLK_CFG0                DOS_REG_ADDR(HEVC_DBLK_CFG0)
-#define HEVC_DBLK_CFG1 0x3501
-#define P_HEVC_DBLK_CFG1                DOS_REG_ADDR(HEVC_DBLK_CFG1)
-#define HEVC_DBLK_CFG2 0x3502
-#define P_HEVC_DBLK_CFG2                DOS_REG_ADDR(HEVC_DBLK_CFG2)
-#define HEVC_DBLK_CFG3 0x3503
-#define P_HEVC_DBLK_CFG3                DOS_REG_ADDR(HEVC_DBLK_CFG3)
-#define HEVC_DBLK_CFG4 0x3504
-#define P_HEVC_DBLK_CFG4                DOS_REG_ADDR(HEVC_DBLK_CFG4)
-#define HEVC_DBLK_CFG5 0x3505
-#define P_HEVC_DBLK_CFG5                DOS_REG_ADDR(HEVC_DBLK_CFG5)
-#define HEVC_DBLK_CFG6 0x3506
-#define P_HEVC_DBLK_CFG6                DOS_REG_ADDR(HEVC_DBLK_CFG6)
-#define HEVC_DBLK_CFG7 0x3507
-#define P_HEVC_DBLK_CFG7                DOS_REG_ADDR(HEVC_DBLK_CFG7)
-#define HEVC_DBLK_CFG8 0x3508
-#define P_HEVC_DBLK_CFG8                DOS_REG_ADDR(HEVC_DBLK_CFG8)
-#define HEVC_DBLK_CFG9 0x3509
-#define P_HEVC_DBLK_CFG9                DOS_REG_ADDR(HEVC_DBLK_CFG9)
-#define HEVC_DBLK_CFGA 0x350a
-#define P_HEVC_DBLK_CFGA                DOS_REG_ADDR(HEVC_DBLK_CFGA)
-#define HEVC_DBLK_STS0 0x350b
-#define P_HEVC_DBLK_STS0                DOS_REG_ADDR(HEVC_DBLK_STS0)
-#define HEVC_DBLK_STS1 0x350c
-#define P_HEVC_DBLK_STS1                DOS_REG_ADDR(HEVC_DBLK_STS1)
-#define HEVC_SAO_VERSION 0x3600
-#define P_HEVC_SAO_VERSION              DOS_REG_ADDR(HEVC_SAO_VERSION)
-#define HEVC_SAO_CTRL0 0x3601
-#define P_HEVC_SAO_CTRL0                DOS_REG_ADDR(HEVC_SAO_CTRL0)
-#define HEVC_SAO_CTRL1 0x3602
-#define P_HEVC_SAO_CTRL1                DOS_REG_ADDR(HEVC_SAO_CTRL1)
-#define HEVC_SAO_INT_EN 0x3603
-#define P_HEVC_SAO_INT_EN               DOS_REG_ADDR(HEVC_SAO_INT_EN)
-#define HEVC_SAO_INT_STATUS 0x3604
-#define P_HEVC_SAO_INT_STATUS           DOS_REG_ADDR(HEVC_SAO_INT_STATUS)
-
-#define HEVC_SAO_TILE_START 0x3607
-#define P_HEVC_SAO_TILE_START           DOS_REG_ADDR(HEVC_SAO_TILE_START)
-#define HEVC_SAO_AXI_WCTRL 0x3609
-#define P_HEVC_SAO_AXI_WCTRL            DOS_REG_ADDR(HEVC_SAO_AXI_WCTRL)
-#define HEVC_SAO_AXI_RCTRL 0x360a
-#define P_HEVC_SAO_AXI_RCTRL            DOS_REG_ADDR(HEVC_SAO_AXI_RCTRL)
-
-#define HEVC_SAO_ABV_WPTR 0x3614
-#define P_HEVC_SAO_ABV_WPTR             DOS_REG_ADDR(HEVC_SAO_ABV_WPTR)
-#define HEVC_SAO_ABV_RPTR 0x3615
-#define P_HEVC_SAO_ABV_RPTR             DOS_REG_ADDR(HEVC_SAO_ABV_RPTR)
-#define HEVC_SAO_VB_WPTR 0x3616
-#define P_HEVC_SAO_VB_WPTR              DOS_REG_ADDR(HEVC_SAO_VB_WPTR)
-#define HEVC_SAO_VB_RPTR 0x3617
-#define P_HEVC_SAO_VB_RPTR              DOS_REG_ADDR(HEVC_SAO_VB_RPTR)
-#define HEVC_SAO_DBG_MODE0 0x361e
-#define P_HEVC_SAO_DBG_MODE0            DOS_REG_ADDR(HEVC_SAO_DBG_MODE0)
-#define HEVC_SAO_DBG_MODE1 0x361f
-#define P_HEVC_SAO_DBG_MODE1            DOS_REG_ADDR(HEVC_SAO_DBG_MODE1)
-#define HEVC_SAO_CTRL2 0x3620
-#define P_HEVC_SAO_CTRL2                DOS_REG_ADDR(HEVC_SAO_CTRL2)
-#define HEVC_SAO_CTRL3 0x3621
-#define P_HEVC_SAO_CTRL3                DOS_REG_ADDR(HEVC_SAO_CTRL3)
-#define HEVC_SAO_CTRL4 0x3622
-#define P_HEVC_SAO_CTRL4                DOS_REG_ADDR(HEVC_SAO_CTRL4)
-#define HEVC_SAO_CTRL5 0x3623
-#define P_HEVC_SAO_CTRL5                DOS_REG_ADDR(HEVC_SAO_CTRL5)
-#define HEVC_SAO_CTRL6 0x3624
-#define P_HEVC_SAO_CTRL6                DOS_REG_ADDR(HEVC_SAO_CTRL6)
-#define HEVC_SAO_CTRL7 0x3625
-#define P_HEVC_SAO_CTRL7                DOS_REG_ADDR(HEVC_SAO_CTRL7)
-#define HEVC_SAO_DBG_DATA_0 0x3630
-#define P_HEVC_SAO_DBG_DATA_0           DOS_REG_ADDR(HEVC_SAO_DBG_DATA_0)
-#define HEVC_SAO_DBG_DATA_1 0x3631
-#define P_HEVC_SAO_DBG_DATA_1           DOS_REG_ADDR(HEVC_SAO_DBG_DATA_1)
-#define HEVC_SAO_DBG_DATA_2 0x3632
-#define P_HEVC_SAO_DBG_DATA_2           DOS_REG_ADDR(HEVC_SAO_DBG_DATA_2)
-#define HEVC_SAO_DBG_DATA_3 0x3633
-#define P_HEVC_SAO_DBG_DATA_3           DOS_REG_ADDR(HEVC_SAO_DBG_DATA_3)
-#define HEVC_SAO_DBG_DATA_4 0x3634
-#define P_HEVC_SAO_DBG_DATA_4           DOS_REG_ADDR(HEVC_SAO_DBG_DATA_4)
-#define HEVC_SAO_DBG_DATA_5 0x3635
-#define P_HEVC_SAO_DBG_DATA_5           DOS_REG_ADDR(HEVC_SAO_DBG_DATA_5)
-#define HEVC_SAO_DBG_DATA_6 0x3636
-#define P_HEVC_SAO_DBG_DATA_6           DOS_REG_ADDR(HEVC_SAO_DBG_DATA_6)
-#define HEVC_IQIT_STAT_GEN0 0x3708
-#define P_HEVC_IQIT_STAT_GEN0           DOS_REG_ADDR(HEVC_IQIT_STAT_GEN0)
-#define HEVC_QP_WRITE 0x3709
-#define P_HEVC_QP_WRITE                 DOS_REG_ADDR(HEVC_QP_WRITE)
-#define HEVC_IQIT_STAT_GEN1 0x370a
-#define P_HEVC_IQIT_STAT_GEN1           DOS_REG_ADDR(HEVC_IQIT_STAT_GEN1)
-/**/
-#define DOS_SW_RESET0 0x3f00
-#define P_DOS_SW_RESET0                 DOS_REG_ADDR(DOS_SW_RESET0)
-#define DOS_GCLK_EN0 0x3f01
-#define P_DOS_GCLK_EN0          DOS_REG_ADDR(DOS_GCLK_EN0)
-#define DOS_GEN_CTRL0 0x3f02
-#define P_DOS_GEN_CTRL0                 DOS_REG_ADDR(DOS_GEN_CTRL0)
-#define DOS_APB_ERR_CTRL 0x3f03
-#define P_DOS_APB_ERR_CTRL              DOS_REG_ADDR(DOS_APB_ERR_CTRL)
-#define DOS_APB_ERR_STAT 0x3f04
-#define P_DOS_APB_ERR_STAT              DOS_REG_ADDR(DOS_APB_ERR_STAT)
-#define DOS_VDEC_INT_EN 0x3f05
-#define P_DOS_VDEC_INT_EN               DOS_REG_ADDR(DOS_VDEC_INT_EN)
-#define DOS_HCODEC_INT_EN 0x3f06
-#define P_DOS_HCODEC_INT_EN             DOS_REG_ADDR(DOS_HCODEC_INT_EN)
-#define DOS_SW_RESET1 0x3f07
-#define P_DOS_SW_RESET1                 DOS_REG_ADDR(DOS_SW_RESET1)
-#define DOS_SW_RESET2 0x3f08
-#define P_DOS_SW_RESET2                 DOS_REG_ADDR(DOS_SW_RESET2)
-#define DOS_GCLK_EN1 0x3f09
-#define P_DOS_GCLK_EN1          DOS_REG_ADDR(DOS_GCLK_EN1)
-#define DOS_VDEC2_INT_EN 0x3f0a
-#define P_DOS_VDEC2_INT_EN              DOS_REG_ADDR(DOS_VDEC2_INT_EN)
-#define DOS_VDIN_LCNT 0x3f0b
-#define P_DOS_VDIN_LCNT                 DOS_REG_ADDR(DOS_VDIN_LCNT)
-#define DOS_VDIN_FCNT 0x3f0c
-#define P_DOS_VDIN_FCNT                 DOS_REG_ADDR(DOS_VDIN_FCNT)
-#define DOS_VDIN_CCTL 0x3f0d
-#define P_DOS_VDIN_CCTL                 DOS_REG_ADDR(DOS_VDIN_CCTL)
-#define DOS_SCRATCH0 0x3f10
-#define P_DOS_SCRATCH0          DOS_REG_ADDR(DOS_SCRATCH0)
-#define DOS_SCRATCH1 0x3f11
-#define P_DOS_SCRATCH1          DOS_REG_ADDR(DOS_SCRATCH1)
-#define DOS_SCRATCH2 0x3f12
-#define P_DOS_SCRATCH2          DOS_REG_ADDR(DOS_SCRATCH2)
-#define DOS_SCRATCH3 0x3f13
-#define P_DOS_SCRATCH3          DOS_REG_ADDR(DOS_SCRATCH3)
-#define DOS_SCRATCH4 0x3f14
-#define P_DOS_SCRATCH4          DOS_REG_ADDR(DOS_SCRATCH4)
-#define DOS_SCRATCH5 0x3f15
-#define P_DOS_SCRATCH5          DOS_REG_ADDR(DOS_SCRATCH5)
-#define DOS_SCRATCH6 0x3f16
-#define P_DOS_SCRATCH6          DOS_REG_ADDR(DOS_SCRATCH6)
-#define DOS_SCRATCH7 0x3f17
-#define P_DOS_SCRATCH7          DOS_REG_ADDR(DOS_SCRATCH7)
-#define DOS_SCRATCH8 0x3f18
-#define P_DOS_SCRATCH8          DOS_REG_ADDR(DOS_SCRATCH8)
-#define DOS_SCRATCH9 0x3f19
-#define P_DOS_SCRATCH9          DOS_REG_ADDR(DOS_SCRATCH9)
-#define DOS_SCRATCH10 0x3f1a
-#define P_DOS_SCRATCH10                 DOS_REG_ADDR(DOS_SCRATCH10)
-#define DOS_SCRATCH11 0x3f1b
-#define P_DOS_SCRATCH11                 DOS_REG_ADDR(DOS_SCRATCH11)
-#define DOS_SCRATCH12 0x3f1c
-#define P_DOS_SCRATCH12                 DOS_REG_ADDR(DOS_SCRATCH12)
-#define DOS_SCRATCH13 0x3f1d
-#define P_DOS_SCRATCH13                 DOS_REG_ADDR(DOS_SCRATCH13)
-#define DOS_SCRATCH14 0x3f1e
-#define P_DOS_SCRATCH14                 DOS_REG_ADDR(DOS_SCRATCH14)
-#define DOS_SCRATCH15 0x3f1f
-#define P_DOS_SCRATCH15                 DOS_REG_ADDR(DOS_SCRATCH15)
-#define DOS_SCRATCH16 0x3f20
-#define P_DOS_SCRATCH16                 DOS_REG_ADDR(DOS_SCRATCH16)
-#define DOS_SCRATCH17 0x3f21
-#define P_DOS_SCRATCH17                 DOS_REG_ADDR(DOS_SCRATCH17)
-#define DOS_SCRATCH18 0x3f22
-#define P_DOS_SCRATCH18                 DOS_REG_ADDR(DOS_SCRATCH18)
-#define DOS_SCRATCH19 0x3f23
-#define P_DOS_SCRATCH19                 DOS_REG_ADDR(DOS_SCRATCH19)
-#define DOS_SCRATCH20 0x3f24
-#define P_DOS_SCRATCH20                 DOS_REG_ADDR(DOS_SCRATCH20)
-#define DOS_SCRATCH21 0x3f25
-#define P_DOS_SCRATCH21                 DOS_REG_ADDR(DOS_SCRATCH21)
-#define DOS_SCRATCH22 0x3f26
-#define P_DOS_SCRATCH22                 DOS_REG_ADDR(DOS_SCRATCH22)
-#define DOS_SCRATCH23 0x3f27
-#define P_DOS_SCRATCH23                 DOS_REG_ADDR(DOS_SCRATCH23)
-#define DOS_SCRATCH24 0x3f28
-#define P_DOS_SCRATCH24                 DOS_REG_ADDR(DOS_SCRATCH24)
-#define DOS_SCRATCH25 0x3f29
-#define P_DOS_SCRATCH25                 DOS_REG_ADDR(DOS_SCRATCH25)
-#define DOS_SCRATCH26 0x3f2a
-#define P_DOS_SCRATCH26                 DOS_REG_ADDR(DOS_SCRATCH26)
-#define DOS_SCRATCH27 0x3f2b
-#define P_DOS_SCRATCH27                 DOS_REG_ADDR(DOS_SCRATCH27)
-#define DOS_SCRATCH28 0x3f2c
-#define P_DOS_SCRATCH28                 DOS_REG_ADDR(DOS_SCRATCH28)
-#define DOS_SCRATCH29 0x3f2d
-#define P_DOS_SCRATCH29                 DOS_REG_ADDR(DOS_SCRATCH29)
-#define DOS_SCRATCH30 0x3f2e
-#define P_DOS_SCRATCH30                 DOS_REG_ADDR(DOS_SCRATCH30)
-#define DOS_SCRATCH31 0x3f2f
-#define P_DOS_SCRATCH31                 DOS_REG_ADDR(DOS_SCRATCH31)
-#define DOS_MEM_PD_VDEC 0x3f30
-#define P_DOS_MEM_PD_VDEC               DOS_REG_ADDR(DOS_MEM_PD_VDEC)
-#define DOS_MEM_PD_VDEC2 0x3f31
-#define P_DOS_MEM_PD_VDEC2              DOS_REG_ADDR(DOS_MEM_PD_VDEC2)
-#define DOS_MEM_PD_HCODEC 0x3f32
-#define P_DOS_MEM_PD_HCODEC             DOS_REG_ADDR(DOS_MEM_PD_HCODEC)
-/*add from M8M2*/
-#define DOS_MEM_PD_HEVC 0x3f33
-#define P_DOS_MEM_PD_HEVC               DOS_REG_ADDR(DOS_MEM_PD_HEVC)
-#define DOS_SW_RESET3 0x3f34
-#define P_DOS_SW_RESET3                 DOS_REG_ADDR(DOS_SW_RESET3)
-#define DOS_GCLK_EN3 0x3f35
-#define P_DOS_GCLK_EN3          DOS_REG_ADDR(DOS_GCLK_EN3)
-#define DOS_HEVC_INT_EN 0x3f36
-#define P_DOS_HEVC_INT_EN               DOS_REG_ADDR(DOS_HEVC_INT_EN)
-/**/
-
-#define HCODEC_MC_CTRL_REG 0x1900
-#define P_HCODEC_MC_CTRL_REG            DOS_REG_ADDR(HCODEC_MC_CTRL_REG)
-#define HCODEC_MC_MB_INFO 0x1901
-#define P_HCODEC_MC_MB_INFO             DOS_REG_ADDR(HCODEC_MC_MB_INFO)
-#define HCODEC_MC_PIC_INFO 0x1902
-#define P_HCODEC_MC_PIC_INFO            DOS_REG_ADDR(HCODEC_MC_PIC_INFO)
-#define HCODEC_POWER_CTL_MC 0x1905
-#define P_HCODEC_POWER_CTL_MC           DOS_REG_ADDR(HCODEC_POWER_CTL_MC)
-#define HCODEC_MC_CMD 0x1906
-#define P_HCODEC_MC_CMD                 DOS_REG_ADDR(HCODEC_MC_CMD)
-#define HCODEC_MC_CTRL0 0x1907
-#define P_HCODEC_MC_CTRL0               DOS_REG_ADDR(HCODEC_MC_CTRL0)
-#define HCODEC_MC_PIC_W_H 0x1908
-#define P_HCODEC_MC_PIC_W_H             DOS_REG_ADDR(HCODEC_MC_PIC_W_H)
-#define HCODEC_MC_STATUS0 0x1909
-#define P_HCODEC_MC_STATUS0             DOS_REG_ADDR(HCODEC_MC_STATUS0)
-#define HCODEC_MC_STATUS1 0x190a
-#define P_HCODEC_MC_STATUS1             DOS_REG_ADDR(HCODEC_MC_STATUS1)
-#define HCODEC_MC_CTRL1 0x190b
-#define P_HCODEC_MC_CTRL1               DOS_REG_ADDR(HCODEC_MC_CTRL1)
-#define HCODEC_MC_MIX_RATIO0 0x190c
-#define P_HCODEC_MC_MIX_RATIO0          DOS_REG_ADDR(HCODEC_MC_MIX_RATIO0)
-#define HCODEC_MC_MIX_RATIO1 0x190d
-#define P_HCODEC_MC_MIX_RATIO1          DOS_REG_ADDR(HCODEC_MC_MIX_RATIO1)
-#define HCODEC_MC_DP_MB_XY 0x190e
-#define P_HCODEC_MC_DP_MB_XY            DOS_REG_ADDR(HCODEC_MC_DP_MB_XY)
-#define HCODEC_MC_OM_MB_XY 0x190f
-#define P_HCODEC_MC_OM_MB_XY            DOS_REG_ADDR(HCODEC_MC_OM_MB_XY)
-#define HCODEC_PSCALE_RST 0x1910
-#define P_HCODEC_PSCALE_RST             DOS_REG_ADDR(HCODEC_PSCALE_RST)
-#define HCODEC_PSCALE_CTRL 0x1911
-#define P_HCODEC_PSCALE_CTRL            DOS_REG_ADDR(HCODEC_PSCALE_CTRL)
-#define HCODEC_PSCALE_PICI_W 0x1912
-#define P_HCODEC_PSCALE_PICI_W          DOS_REG_ADDR(HCODEC_PSCALE_PICI_W)
-#define HCODEC_PSCALE_PICI_H 0x1913
-#define P_HCODEC_PSCALE_PICI_H          DOS_REG_ADDR(HCODEC_PSCALE_PICI_H)
-#define HCODEC_PSCALE_PICO_W 0x1914
-#define P_HCODEC_PSCALE_PICO_W          DOS_REG_ADDR(HCODEC_PSCALE_PICO_W)
-#define HCODEC_PSCALE_PICO_H 0x1915
-#define P_HCODEC_PSCALE_PICO_H          DOS_REG_ADDR(HCODEC_PSCALE_PICO_H)
-#define HCODEC_PSCALE_PICO_START_X 0x1916
-
-
-/**/
-#define HCODEC_MC_MPORT_CTRL 0x1940
-#define P_HCODEC_MC_MPORT_CTRL          DOS_REG_ADDR(HCODEC_MC_MPORT_CTRL)
-#define HCODEC_MC_MPORT_DAT 0x1941
-#define P_HCODEC_MC_MPORT_DAT           DOS_REG_ADDR(HCODEC_MC_MPORT_DAT)
-#define HCODEC_MC_DPDN_MB_XY 0x1946
-#define P_HCODEC_MC_DPDN_MB_XY          DOS_REG_ADDR(HCODEC_MC_DPDN_MB_XY)
-#define HCODEC_MC_OMDN_MB_XY 0x1947
-#define HCODEC_AV_SCRATCH_0 0x19c0
-#define P_HCODEC_AV_SCRATCH_0           DOS_REG_ADDR(HCODEC_AV_SCRATCH_0)
-#define HCODEC_AV_SCRATCH_1 0x19c1
-#define P_HCODEC_AV_SCRATCH_1           DOS_REG_ADDR(HCODEC_AV_SCRATCH_1)
-#define HCODEC_AV_SCRATCH_2 0x19c2
-#define P_HCODEC_AV_SCRATCH_2           DOS_REG_ADDR(HCODEC_AV_SCRATCH_2)
-#define HCODEC_AV_SCRATCH_3 0x19c3
-#define P_HCODEC_AV_SCRATCH_3           DOS_REG_ADDR(HCODEC_AV_SCRATCH_3)
-#define HCODEC_AV_SCRATCH_4 0x19c4
-#define P_HCODEC_AV_SCRATCH_4           DOS_REG_ADDR(HCODEC_AV_SCRATCH_4)
-#define HCODEC_AV_SCRATCH_5 0x19c5
-#define P_HCODEC_AV_SCRATCH_5           DOS_REG_ADDR(HCODEC_AV_SCRATCH_5)
-#define HCODEC_AV_SCRATCH_6 0x19c6
-#define P_HCODEC_AV_SCRATCH_6           DOS_REG_ADDR(HCODEC_AV_SCRATCH_6)
-#define HCODEC_AV_SCRATCH_7 0x19c7
-#define P_HCODEC_AV_SCRATCH_7           DOS_REG_ADDR(HCODEC_AV_SCRATCH_7)
-#define HCODEC_AV_SCRATCH_8 0x19c8
-#define P_HCODEC_AV_SCRATCH_8           DOS_REG_ADDR(HCODEC_AV_SCRATCH_8)
-#define HCODEC_AV_SCRATCH_9 0x19c9
-#define P_HCODEC_AV_SCRATCH_9           DOS_REG_ADDR(HCODEC_AV_SCRATCH_9)
-#define HCODEC_AV_SCRATCH_A 0x19ca
-#define P_HCODEC_AV_SCRATCH_A           DOS_REG_ADDR(HCODEC_AV_SCRATCH_A)
-#define HCODEC_AV_SCRATCH_B 0x19cb
-#define P_HCODEC_AV_SCRATCH_B           DOS_REG_ADDR(HCODEC_AV_SCRATCH_B)
-#define HCODEC_AV_SCRATCH_C 0x19cc
-#define P_HCODEC_AV_SCRATCH_C           DOS_REG_ADDR(HCODEC_AV_SCRATCH_C)
-#define HCODEC_AV_SCRATCH_D 0x19cd
-#define P_HCODEC_AV_SCRATCH_D           DOS_REG_ADDR(HCODEC_AV_SCRATCH_D)
-#define HCODEC_AV_SCRATCH_E 0x19ce
-#define P_HCODEC_AV_SCRATCH_E           DOS_REG_ADDR(HCODEC_AV_SCRATCH_E)
-#define HCODEC_AV_SCRATCH_F 0x19cf
-#define P_HCODEC_AV_SCRATCH_F           DOS_REG_ADDR(HCODEC_AV_SCRATCH_F)
-#define HCODEC_AV_SCRATCH_G 0x19d0
-#define P_HCODEC_AV_SCRATCH_G           DOS_REG_ADDR(HCODEC_AV_SCRATCH_G)
-#define HCODEC_AV_SCRATCH_H 0x19d1
-#define P_HCODEC_AV_SCRATCH_H           DOS_REG_ADDR(HCODEC_AV_SCRATCH_H)
-#define HCODEC_AV_SCRATCH_I 0x19d2
-#define P_HCODEC_AV_SCRATCH_I           DOS_REG_ADDR(HCODEC_AV_SCRATCH_I)
-#define HCODEC_AV_SCRATCH_J 0x19d3
-#define P_HCODEC_AV_SCRATCH_J           DOS_REG_ADDR(HCODEC_AV_SCRATCH_J)
-#define HCODEC_AV_SCRATCH_K 0x19d4
-#define P_HCODEC_AV_SCRATCH_K           DOS_REG_ADDR(HCODEC_AV_SCRATCH_K)
-#define HCODEC_AV_SCRATCH_L 0x19d5
-#define P_HCODEC_AV_SCRATCH_L           DOS_REG_ADDR(HCODEC_AV_SCRATCH_L)
-#define HCODEC_AV_SCRATCH_M 0x19d6
-#define P_HCODEC_AV_SCRATCH_M           DOS_REG_ADDR(HCODEC_AV_SCRATCH_M)
-#define HCODEC_AV_SCRATCH_N 0x19d7
-#define P_HCODEC_AV_SCRATCH_N           DOS_REG_ADDR(HCODEC_AV_SCRATCH_N)
-#define HCODEC_WRRSP_CO_MB 0x19d8
-#define P_HCODEC_WRRSP_CO_MB            DOS_REG_ADDR(HCODEC_WRRSP_CO_MB)
-#define HCODEC_WRRSP_DCAC 0x19d9
-#define P_HCODEC_WRRSP_DCAC             DOS_REG_ADDR(HCODEC_WRRSP_DCAC)
-/*add from M8M2*/
-#define VDEC2_AV_SCRATCH_0 0x29c0
-#define P_VDEC2_AV_SCRATCH_0            DOS_REG_ADDR(VDEC2_AV_SCRATCH_0)
-#define VDEC2_AV_SCRATCH_1 0x29c1
-#define P_VDEC2_AV_SCRATCH_1            DOS_REG_ADDR(VDEC2_AV_SCRATCH_1)
-#define VDEC2_AV_SCRATCH_2 0x29c2
-#define P_VDEC2_AV_SCRATCH_2            DOS_REG_ADDR(VDEC2_AV_SCRATCH_2)
-#define VDEC2_AV_SCRATCH_3 0x29c3
-#define P_VDEC2_AV_SCRATCH_3            DOS_REG_ADDR(VDEC2_AV_SCRATCH_3)
-#define VDEC2_AV_SCRATCH_4 0x29c4
-#define P_VDEC2_AV_SCRATCH_4            DOS_REG_ADDR(VDEC2_AV_SCRATCH_4)
-#define VDEC2_AV_SCRATCH_5 0x29c5
-#define P_VDEC2_AV_SCRATCH_5            DOS_REG_ADDR(VDEC2_AV_SCRATCH_5)
-#define VDEC2_AV_SCRATCH_6 0x29c6
-#define P_VDEC2_AV_SCRATCH_6            DOS_REG_ADDR(VDEC2_AV_SCRATCH_6)
-#define VDEC2_AV_SCRATCH_7 0x29c7
-#define P_VDEC2_AV_SCRATCH_7            DOS_REG_ADDR(VDEC2_AV_SCRATCH_7)
-#define VDEC2_AV_SCRATCH_8 0x29c8
-#define P_VDEC2_AV_SCRATCH_8            DOS_REG_ADDR(VDEC2_AV_SCRATCH_8)
-#define VDEC2_AV_SCRATCH_9 0x29c9
-#define P_VDEC2_AV_SCRATCH_9            DOS_REG_ADDR(VDEC2_AV_SCRATCH_9)
-#define VDEC2_AV_SCRATCH_A 0x29ca
-#define P_VDEC2_AV_SCRATCH_A            DOS_REG_ADDR(VDEC2_AV_SCRATCH_A)
-#define VDEC2_AV_SCRATCH_B 0x29cb
-#define P_VDEC2_AV_SCRATCH_B            DOS_REG_ADDR(VDEC2_AV_SCRATCH_B)
-#define VDEC2_AV_SCRATCH_C 0x29cc
-#define P_VDEC2_AV_SCRATCH_C            DOS_REG_ADDR(VDEC2_AV_SCRATCH_C)
-#define VDEC2_AV_SCRATCH_D 0x29cd
-#define P_VDEC2_AV_SCRATCH_D            DOS_REG_ADDR(VDEC2_AV_SCRATCH_D)
-#define VDEC2_AV_SCRATCH_E 0x29ce
-#define P_VDEC2_AV_SCRATCH_E            DOS_REG_ADDR(VDEC2_AV_SCRATCH_E)
-#define VDEC2_AV_SCRATCH_F 0x29cf
-#define P_VDEC2_AV_SCRATCH_F            DOS_REG_ADDR(VDEC2_AV_SCRATCH_F)
-#define VDEC2_AV_SCRATCH_G 0x29d0
-#define P_VDEC2_AV_SCRATCH_G            DOS_REG_ADDR(VDEC2_AV_SCRATCH_G)
-#define VDEC2_AV_SCRATCH_H 0x29d1
-#define P_VDEC2_AV_SCRATCH_H            DOS_REG_ADDR(VDEC2_AV_SCRATCH_H)
-#define VDEC2_AV_SCRATCH_I 0x29d2
-#define P_VDEC2_AV_SCRATCH_I            DOS_REG_ADDR(VDEC2_AV_SCRATCH_I)
-#define VDEC2_AV_SCRATCH_J 0x29d3
-#define P_VDEC2_AV_SCRATCH_J            DOS_REG_ADDR(VDEC2_AV_SCRATCH_J)
-#define VDEC2_AV_SCRATCH_K 0x29d4
-#define P_VDEC2_AV_SCRATCH_K            DOS_REG_ADDR(VDEC2_AV_SCRATCH_K)
-#define VDEC2_AV_SCRATCH_L 0x29d5
-#define P_VDEC2_AV_SCRATCH_L            DOS_REG_ADDR(VDEC2_AV_SCRATCH_L)
-#define VDEC2_AV_SCRATCH_M 0x29d6
-#define P_VDEC2_AV_SCRATCH_M            DOS_REG_ADDR(VDEC2_AV_SCRATCH_M)
-#define VDEC2_AV_SCRATCH_N 0x29d7
-#define P_VDEC2_AV_SCRATCH_N            DOS_REG_ADDR(VDEC2_AV_SCRATCH_N)
-#define VDEC2_WRRSP_CO_MB 0x29d8
-#define P_VDEC2_WRRSP_CO_MB             DOS_REG_ADDR(VDEC2_WRRSP_CO_MB)
-#define VDEC2_WRRSP_DCAC 0x29d9
-#define P_VDEC2_WRRSP_DCAC              DOS_REG_ADDR(VDEC2_WRRSP_DCAC)
-/*add from M8M2*/
-/**/
-#define VDEC2_DBLK_RST 0x2950
-#define P_VDEC2_DBLK_RST                DOS_REG_ADDR(VDEC2_DBLK_RST)
-#define VDEC2_DBLK_CTRL 0x2951
-#define P_VDEC2_DBLK_CTRL               DOS_REG_ADDR(VDEC2_DBLK_CTRL)
-#define VDEC2_DBLK_MB_WID_HEIGHT 0x2952
-#define VDEC2_DBLK_STATUS 0x2953
-#define P_VDEC2_DBLK_STATUS             DOS_REG_ADDR(VDEC2_DBLK_STATUS)
-#define VDEC2_DBLK_CMD_CTRL 0x2954
-#define P_VDEC2_DBLK_CMD_CTRL           DOS_REG_ADDR(VDEC2_DBLK_CMD_CTRL)
-#define VDEC2_DBLK_MB_XY 0x2955
-#define P_VDEC2_DBLK_MB_XY              DOS_REG_ADDR(VDEC2_DBLK_MB_XY)
-#define VDEC2_DBLK_QP 0x2956
-#define P_VDEC2_DBLK_QP                 DOS_REG_ADDR(VDEC2_DBLK_QP)
-#define VDEC2_DBLK_Y_BHFILT 0x2957
-#define P_VDEC2_DBLK_Y_BHFILT           DOS_REG_ADDR(VDEC2_DBLK_Y_BHFILT)
-#define VDEC2_DBLK_Y_BHFILT_HIGH 0x2958
-#define VDEC2_DBLK_Y_BVFILT 0x2959
-#define P_VDEC2_DBLK_Y_BVFILT           DOS_REG_ADDR(VDEC2_DBLK_Y_BVFILT)
-#define VDEC2_DBLK_CB_BFILT 0x295a
-#define P_VDEC2_DBLK_CB_BFILT           DOS_REG_ADDR(VDEC2_DBLK_CB_BFILT)
-#define VDEC2_DBLK_CR_BFILT 0x295b
-#define P_VDEC2_DBLK_CR_BFILT           DOS_REG_ADDR(VDEC2_DBLK_CR_BFILT)
-#define VDEC2_DBLK_Y_HFILT 0x295c
-#define P_VDEC2_DBLK_Y_HFILT            DOS_REG_ADDR(VDEC2_DBLK_Y_HFILT)
-#define VDEC2_DBLK_Y_VFILT 0x295e
-#define P_VDEC2_DBLK_Y_VFILT            DOS_REG_ADDR(VDEC2_DBLK_Y_VFILT)
-#define VDEC2_DBLK_CB_FILT 0x295f
-#define P_VDEC2_DBLK_CB_FILT            DOS_REG_ADDR(VDEC2_DBLK_CB_FILT)
-#define VDEC2_DBLK_CR_FILT 0x2960
-#define P_VDEC2_DBLK_CR_FILT            DOS_REG_ADDR(VDEC2_DBLK_CR_FILT)
-#define VDEC2_DBLK_STATUS1 0x296b
-#define P_VDEC2_DBLK_STATUS1            DOS_REG_ADDR(VDEC2_DBLK_STATUS1)
-#define VDEC2_DBLK_GCLK_FREE 0x296c
-#define P_VDEC2_DBLK_GCLK_FREE          DOS_REG_ADDR(VDEC2_DBLK_GCLK_FREE)
-#define VDEC2_DBLK_GCLK_OFF 0x296d
-#define P_VDEC2_DBLK_GCLK_OFF           DOS_REG_ADDR(VDEC2_DBLK_GCLK_OFF)
-#define VDEC2_DBLK_AVSFLAGS 0x296e
-#define P_VDEC2_DBLK_AVSFLAGS           DOS_REG_ADDR(VDEC2_DBLK_AVSFLAGS)
-#define VDEC2_DBLK_CBPY 0x2970
-#define P_VDEC2_DBLK_CBPY               DOS_REG_ADDR(VDEC2_DBLK_CBPY)
-#define VDEC2_DBLK_CBPY_ADJ 0x2971
-#define P_VDEC2_DBLK_CBPY_ADJ           DOS_REG_ADDR(VDEC2_DBLK_CBPY_ADJ)
-#define VDEC2_DBLK_CBPC 0x2972
-#define P_VDEC2_DBLK_CBPC               DOS_REG_ADDR(VDEC2_DBLK_CBPC)
-#define VDEC2_DBLK_CBPC_ADJ 0x2973
-#define P_VDEC2_DBLK_CBPC_ADJ           DOS_REG_ADDR(VDEC2_DBLK_CBPC_ADJ)
-#define VDEC2_DBLK_VHMVD 0x2974
-#define P_VDEC2_DBLK_VHMVD              DOS_REG_ADDR(VDEC2_DBLK_VHMVD)
-#define VDEC2_DBLK_STRONG 0x2975
-#define P_VDEC2_DBLK_STRONG             DOS_REG_ADDR(VDEC2_DBLK_STRONG)
-#define VDEC2_DBLK_RV8_QUANT 0x2976
-#define P_VDEC2_DBLK_RV8_QUANT          DOS_REG_ADDR(VDEC2_DBLK_RV8_QUANT)
-#define VDEC2_DBLK_CBUS_HCMD2 0x2977
-#define VDEC2_DBLK_VLD_HCMD2 0x297a
-#define P_VDEC2_DBLK_VLD_HCMD2          DOS_REG_ADDR(VDEC2_DBLK_VLD_HCMD2)
-#define VDEC2_DBLK_VLD_HCMD1 0x297b
-#define P_VDEC2_DBLK_VLD_HCMD1          DOS_REG_ADDR(VDEC2_DBLK_VLD_HCMD1)
-#define VDEC2_DBLK_VLD_HCMD0 0x297c
-#define P_VDEC2_DBLK_VLD_HCMD0          DOS_REG_ADDR(VDEC2_DBLK_VLD_HCMD0)
-#define VDEC2_MCRCC_CTL1 0x2980
-#define P_VDEC2_MCRCC_CTL1              DOS_REG_ADDR(VDEC2_MCRCC_CTL1)
-#define VDEC2_MCRCC_CTL2 0x2981
-#define P_VDEC2_MCRCC_CTL2              DOS_REG_ADDR(VDEC2_MCRCC_CTL2)
-#define VDEC2_MCRCC_CTL3 0x2982
-#define P_VDEC2_MCRCC_CTL3              DOS_REG_ADDR(VDEC2_MCRCC_CTL3)
-#define VDEC2_GCLK_EN 0x2983
-#define P_VDEC2_GCLK_EN                 DOS_REG_ADDR(VDEC2_GCLK_EN)
-#define VDEC2_MDEC_SW_RESET 0x2984
-#define P_VDEC2_MDEC_SW_RESET           DOS_REG_ADDR(VDEC2_MDEC_SW_RESET)
-/*add from M8M2*/
-#define HEVC_MC_CTRL_REG 0x3900
-#define P_HEVC_MC_CTRL_REG              DOS_REG_ADDR(HEVC_MC_CTRL_REG)
-#define HEVC_MC_MB_INFO 0x3901
-#define P_HEVC_MC_MB_INFO               DOS_REG_ADDR(HEVC_MC_MB_INFO)
-#define HEVC_MC_PIC_INFO 0x3902
-#define P_HEVC_MC_PIC_INFO              DOS_REG_ADDR(HEVC_MC_PIC_INFO)
-#define HEVC_MC_HALF_PEL_ONE 0x3903
-#define P_HEVC_MC_HALF_PEL_ONE          DOS_REG_ADDR(HEVC_MC_HALF_PEL_ONE)
-#define HEVC_MC_HALF_PEL_TWO 0x3904
-#define P_HEVC_MC_HALF_PEL_TWO          DOS_REG_ADDR(HEVC_MC_HALF_PEL_TWO)
-#define HEVC_POWER_CTL_MC 0x3905
-#define P_HEVC_POWER_CTL_MC             DOS_REG_ADDR(HEVC_POWER_CTL_MC)
-#define HEVC_MC_CMD 0x3906
-#define P_HEVC_MC_CMD           DOS_REG_ADDR(HEVC_MC_CMD)
-#define HEVC_MC_CTRL0 0x3907
-#define P_HEVC_MC_CTRL0                 DOS_REG_ADDR(HEVC_MC_CTRL0)
-#define HEVC_MC_PIC_W_H 0x3908
-#define P_HEVC_MC_PIC_W_H               DOS_REG_ADDR(HEVC_MC_PIC_W_H)
-#define HEVC_MC_STATUS0 0x3909
-#define P_HEVC_MC_STATUS0               DOS_REG_ADDR(HEVC_MC_STATUS0)
-#define HEVC_MC_STATUS1 0x390a
-#define P_HEVC_MC_STATUS1               DOS_REG_ADDR(HEVC_MC_STATUS1)
-#define HEVC_MC_CTRL1 0x390b
-#define P_HEVC_MC_CTRL1                 DOS_REG_ADDR(HEVC_MC_CTRL1)
-#define HEVC_MC_MIX_RATIO0 0x390c
-#define P_HEVC_MC_MIX_RATIO0            DOS_REG_ADDR(HEVC_MC_MIX_RATIO0)
-#define HEVC_MC_MIX_RATIO1 0x390d
-#define P_HEVC_MC_MIX_RATIO1            DOS_REG_ADDR(HEVC_MC_MIX_RATIO1)
-#define HEVC_MC_DP_MB_XY 0x390e
-#define P_HEVC_MC_DP_MB_XY              DOS_REG_ADDR(HEVC_MC_DP_MB_XY)
-#define HEVC_MC_OM_MB_XY 0x390f
-#define P_HEVC_MC_OM_MB_XY              DOS_REG_ADDR(HEVC_MC_OM_MB_XY)
-#define HEVC_PSCALE_RST 0x3910
-#define P_HEVC_PSCALE_RST               DOS_REG_ADDR(HEVC_PSCALE_RST)
-#define HEVC_PSCALE_CTRL 0x3911
-#define P_HEVC_PSCALE_CTRL              DOS_REG_ADDR(HEVC_PSCALE_CTRL)
-#define HEVC_PSCALE_PICI_W 0x3912
-#define P_HEVC_PSCALE_PICI_W            DOS_REG_ADDR(HEVC_PSCALE_PICI_W)
-#define HEVC_PSCALE_PICI_H 0x3913
-#define P_HEVC_PSCALE_PICI_H            DOS_REG_ADDR(HEVC_PSCALE_PICI_H)
-#define HEVC_PSCALE_PICO_W 0x3914
-#define P_HEVC_PSCALE_PICO_W            DOS_REG_ADDR(HEVC_PSCALE_PICO_W)
-#define HEVC_PSCALE_PICO_H 0x3915
-#define P_HEVC_PSCALE_PICO_H            DOS_REG_ADDR(HEVC_PSCALE_PICO_H)
-
-#define HEVC_MC_DPDN_MB_XY 0x3946
-#define P_HEVC_MC_DPDN_MB_XY            DOS_REG_ADDR(HEVC_MC_DPDN_MB_XY)
-#define HEVC_MC_OMDN_MB_XY 0x3947
-#define P_HEVC_MC_OMDN_MB_XY            DOS_REG_ADDR(HEVC_MC_OMDN_MB_XY)
-#define HEVC_MC_HCMDBUF_H 0x3948
-#define P_HEVC_MC_HCMDBUF_H             DOS_REG_ADDR(HEVC_MC_HCMDBUF_H)
-#define HEVC_MC_HCMDBUF_L 0x3949
-#define P_HEVC_MC_HCMDBUF_L             DOS_REG_ADDR(HEVC_MC_HCMDBUF_L)
-#define HEVC_MC_HCMD_H 0x394a
-#define P_HEVC_MC_HCMD_H                DOS_REG_ADDR(HEVC_MC_HCMD_H)
-#define HEVC_MC_HCMD_L 0x394b
-#define P_HEVC_MC_HCMD_L                DOS_REG_ADDR(HEVC_MC_HCMD_L)
-#define HEVC_MC_IDCT_DAT 0x394c
-#define P_HEVC_MC_IDCT_DAT              DOS_REG_ADDR(HEVC_MC_IDCT_DAT)
-#define HEVC_MC_OTHER_GCLK_CTRL 0x394e
-
-#define HEVC_AV_SCRATCH_0 0x39c0
-#define P_HEVC_AV_SCRATCH_0             DOS_REG_ADDR(HEVC_AV_SCRATCH_0)
-#define HEVC_AV_SCRATCH_1 0x39c1
-#define P_HEVC_AV_SCRATCH_1             DOS_REG_ADDR(HEVC_AV_SCRATCH_1)
-#define HEVC_AV_SCRATCH_2 0x39c2
-#define P_HEVC_AV_SCRATCH_2             DOS_REG_ADDR(HEVC_AV_SCRATCH_2)
-#define HEVC_AV_SCRATCH_3 0x39c3
-#define P_HEVC_AV_SCRATCH_3             DOS_REG_ADDR(HEVC_AV_SCRATCH_3)
-#define HEVC_AV_SCRATCH_4 0x39c4
-#define P_HEVC_AV_SCRATCH_4             DOS_REG_ADDR(HEVC_AV_SCRATCH_4)
-#define HEVC_AV_SCRATCH_5 0x39c5
-#define P_HEVC_AV_SCRATCH_5             DOS_REG_ADDR(HEVC_AV_SCRATCH_5)
-#define HEVC_AV_SCRATCH_6 0x39c6
-#define P_HEVC_AV_SCRATCH_6             DOS_REG_ADDR(HEVC_AV_SCRATCH_6)
-#define HEVC_AV_SCRATCH_7 0x39c7
-#define P_HEVC_AV_SCRATCH_7             DOS_REG_ADDR(HEVC_AV_SCRATCH_7)
-#define HEVC_AV_SCRATCH_8 0x39c8
-#define P_HEVC_AV_SCRATCH_8             DOS_REG_ADDR(HEVC_AV_SCRATCH_8)
-#define HEVC_AV_SCRATCH_9 0x39c9
-#define P_HEVC_AV_SCRATCH_9             DOS_REG_ADDR(HEVC_AV_SCRATCH_9)
-#define HEVC_AV_SCRATCH_A 0x39ca
-#define P_HEVC_AV_SCRATCH_A             DOS_REG_ADDR(HEVC_AV_SCRATCH_A)
-#define HEVC_AV_SCRATCH_B 0x39cb
-#define P_HEVC_AV_SCRATCH_B             DOS_REG_ADDR(HEVC_AV_SCRATCH_B)
-#define HEVC_AV_SCRATCH_C 0x39cc
-#define P_HEVC_AV_SCRATCH_C             DOS_REG_ADDR(HEVC_AV_SCRATCH_C)
-#define HEVC_AV_SCRATCH_D 0x39cd
-#define P_HEVC_AV_SCRATCH_D             DOS_REG_ADDR(HEVC_AV_SCRATCH_D)
-#define HEVC_AV_SCRATCH_E 0x39ce
-#define P_HEVC_AV_SCRATCH_E             DOS_REG_ADDR(HEVC_AV_SCRATCH_E)
-#define HEVC_AV_SCRATCH_F 0x39cf
-#define P_HEVC_AV_SCRATCH_F             DOS_REG_ADDR(HEVC_AV_SCRATCH_F)
-#define HEVC_AV_SCRATCH_G 0x39d0
-#define P_HEVC_AV_SCRATCH_G             DOS_REG_ADDR(HEVC_AV_SCRATCH_G)
-#define HEVC_AV_SCRATCH_H 0x39d1
-#define P_HEVC_AV_SCRATCH_H             DOS_REG_ADDR(HEVC_AV_SCRATCH_H)
-#define HEVC_AV_SCRATCH_I 0x39d2
-#define P_HEVC_AV_SCRATCH_I             DOS_REG_ADDR(HEVC_AV_SCRATCH_I)
-#define HEVC_AV_SCRATCH_J 0x39d3
-#define P_HEVC_AV_SCRATCH_J             DOS_REG_ADDR(HEVC_AV_SCRATCH_J)
-#define HEVC_AV_SCRATCH_K 0x39d4
-#define P_HEVC_AV_SCRATCH_K             DOS_REG_ADDR(HEVC_AV_SCRATCH_K)
-#define HEVC_AV_SCRATCH_L 0x39d5
-#define P_HEVC_AV_SCRATCH_L             DOS_REG_ADDR(HEVC_AV_SCRATCH_L)
-#define HEVC_AV_SCRATCH_M 0x39d6
-#define P_HEVC_AV_SCRATCH_M             DOS_REG_ADDR(HEVC_AV_SCRATCH_M)
-#define HEVC_AV_SCRATCH_N 0x39d7
-#define P_HEVC_AV_SCRATCH_N             DOS_REG_ADDR(HEVC_AV_SCRATCH_N)
-#define HEVC_WRRSP_CO_MB 0x39d8
-#define P_HEVC_WRRSP_CO_MB              DOS_REG_ADDR(HEVC_WRRSP_CO_MB)
-
-#define HEVC_DBLK_RST 0x3950
-#define P_HEVC_DBLK_RST                 DOS_REG_ADDR(HEVC_DBLK_RST)
-#define HEVC_DBLK_CTRL 0x3951
-#define P_HEVC_DBLK_CTRL                DOS_REG_ADDR(HEVC_DBLK_CTRL)
-#define HEVC_DBLK_MB_WID_HEIGHT 0x3952
-#define HEVC_DBLK_STATUS 0x3953
-#define P_HEVC_DBLK_STATUS              DOS_REG_ADDR(HEVC_DBLK_STATUS)
-#define HEVC_DBLK_CMD_CTRL 0x3954
-#define P_HEVC_DBLK_CMD_CTRL            DOS_REG_ADDR(HEVC_DBLK_CMD_CTRL)
-#define HEVC_DBLK_MB_XY 0x3955
-#define P_HEVC_DBLK_MB_XY               DOS_REG_ADDR(HEVC_DBLK_MB_XY)
-#define HEVC_DBLK_QP 0x3956
-#define P_HEVC_DBLK_QP          DOS_REG_ADDR(HEVC_DBLK_QP)
-#define HEVC_DBLK_Y_BHFILT 0x3957
-#define P_HEVC_DBLK_Y_BHFILT            DOS_REG_ADDR(HEVC_DBLK_Y_BHFILT)
-#define HEVC_DBLK_Y_BVFILT 0x3959
-#define P_HEVC_DBLK_Y_BVFILT            DOS_REG_ADDR(HEVC_DBLK_Y_BVFILT)
-#define HEVC_DBLK_CB_BFILT 0x395a
-#define P_HEVC_DBLK_CB_BFILT            DOS_REG_ADDR(HEVC_DBLK_CB_BFILT)
-#define HEVC_DBLK_CR_BFILT 0x395b
-#define P_HEVC_DBLK_CR_BFILT            DOS_REG_ADDR(HEVC_DBLK_CR_BFILT)
-#define HEVC_DBLK_Y_HFILT 0x395c
-#define P_HEVC_DBLK_Y_HFILT             DOS_REG_ADDR(HEVC_DBLK_Y_HFILT)
-#define HEVC_DBLK_Y_VFILT 0x395e
-#define P_HEVC_DBLK_Y_VFILT             DOS_REG_ADDR(HEVC_DBLK_Y_VFILT)
-#define HEVC_DBLK_CB_FILT 0x395f
-#define P_HEVC_DBLK_CB_FILT             DOS_REG_ADDR(HEVC_DBLK_CB_FILT)
-#define HEVC_DBLK_CR_FILT 0x3960
-#define P_HEVC_DBLK_CR_FILT             DOS_REG_ADDR(HEVC_DBLK_CR_FILT)
-#define HEVC_DBLK_CLIP_CTRL0 0x3962
-#define P_HEVC_DBLK_CLIP_CTRL0          DOS_REG_ADDR(HEVC_DBLK_CLIP_CTRL0)
-#define HEVC_DBLK_CLIP_CTRL1 0x3963
-#define P_HEVC_DBLK_CLIP_CTRL1          DOS_REG_ADDR(HEVC_DBLK_CLIP_CTRL1)
-#define HEVC_DBLK_CLIP_CTRL2 0x3964
-#define P_HEVC_DBLK_CLIP_CTRL2          DOS_REG_ADDR(HEVC_DBLK_CLIP_CTRL2)
-#define HEVC_DBLK_CLIP_CTRL3 0x3965
-#define P_HEVC_DBLK_CLIP_CTRL3          DOS_REG_ADDR(HEVC_DBLK_CLIP_CTRL3)
-#define HEVC_DBLK_CLIP_CTRL4 0x3966
-#define P_HEVC_DBLK_CLIP_CTRL4          DOS_REG_ADDR(HEVC_DBLK_CLIP_CTRL4)
-#define HEVC_DBLK_CLIP_CTRL5 0x3967
-#define P_HEVC_DBLK_CLIP_CTRL5          DOS_REG_ADDR(HEVC_DBLK_CLIP_CTRL5)
-#define HEVC_DBLK_CLIP_CTRL6 0x3968
-#define P_HEVC_DBLK_CLIP_CTRL6          DOS_REG_ADDR(HEVC_DBLK_CLIP_CTRL6)
-#define HEVC_DBLK_CLIP_CTRL7 0x3969
-#define P_HEVC_DBLK_CLIP_CTRL7          DOS_REG_ADDR(HEVC_DBLK_CLIP_CTRL7)
-#define HEVC_DBLK_CLIP_CTRL8 0x396a
-#define P_HEVC_DBLK_CLIP_CTRL8          DOS_REG_ADDR(HEVC_DBLK_CLIP_CTRL8)
-#define HEVC_DBLK_STATUS1 0x396b
-#define P_HEVC_DBLK_STATUS1             DOS_REG_ADDR(HEVC_DBLK_STATUS1)
-#define HEVC_DBLK_GCLK_FREE 0x396c
-#define P_HEVC_DBLK_GCLK_FREE           DOS_REG_ADDR(HEVC_DBLK_GCLK_FREE)
-#define HEVC_DBLK_GCLK_OFF 0x396d
-#define P_HEVC_DBLK_GCLK_OFF            DOS_REG_ADDR(HEVC_DBLK_GCLK_OFF)
-#define HEVC_DBLK_AVSFLAGS 0x396e
-#define P_HEVC_DBLK_AVSFLAGS            DOS_REG_ADDR(HEVC_DBLK_AVSFLAGS)
-#define HEVC_DBLK_CBPY 0x3970
-#define P_HEVC_DBLK_CBPY                DOS_REG_ADDR(HEVC_DBLK_CBPY)
-#define HEVC_DBLK_CBPY_ADJ 0x3971
-#define P_HEVC_DBLK_CBPY_ADJ            DOS_REG_ADDR(HEVC_DBLK_CBPY_ADJ)
-#define HEVC_DBLK_CBPC 0x3972
-#define P_HEVC_DBLK_CBPC                DOS_REG_ADDR(HEVC_DBLK_CBPC)
-#define HEVC_DBLK_CBPC_ADJ 0x3973
-#define P_HEVC_DBLK_CBPC_ADJ            DOS_REG_ADDR(HEVC_DBLK_CBPC_ADJ)
-#define HEVC_DBLK_VHMVD 0x3974
-#define P_HEVC_DBLK_VHMVD               DOS_REG_ADDR(HEVC_DBLK_VHMVD)
-#define HEVC_DBLK_STRONG 0x3975
-#define P_HEVC_DBLK_STRONG              DOS_REG_ADDR(HEVC_DBLK_STRONG)
-#define HEVC_DBLK_RV8_QUANT 0x3976
-#define P_HEVC_DBLK_RV8_QUANT           DOS_REG_ADDR(HEVC_DBLK_RV8_QUANT)
-#define HEVC_DBLK_CBUS_HCMD2 0x3977
-#define P_HEVC_DBLK_CBUS_HCMD2          DOS_REG_ADDR(HEVC_DBLK_CBUS_HCMD2)
-#define HEVC_DBLK_CBUS_HCMD1 0x3978
-#define P_HEVC_DBLK_CBUS_HCMD1          DOS_REG_ADDR(HEVC_DBLK_CBUS_HCMD1)
-#define HEVC_DBLK_CBUS_HCMD0 0x3979
-#define P_HEVC_DBLK_CBUS_HCMD0          DOS_REG_ADDR(HEVC_DBLK_CBUS_HCMD0)
-#define HEVC_DBLK_VLD_HCMD2 0x397a
-#define P_HEVC_DBLK_VLD_HCMD2           DOS_REG_ADDR(HEVC_DBLK_VLD_HCMD2)
-#define HEVC_DBLK_VLD_HCMD1 0x397b
-#define P_HEVC_DBLK_VLD_HCMD1           DOS_REG_ADDR(HEVC_DBLK_VLD_HCMD1)
-#define HEVC_DBLK_VLD_HCMD0 0x397c
-#define P_HEVC_DBLK_VLD_HCMD0           DOS_REG_ADDR(HEVC_DBLK_VLD_HCMD0)
-#define HEVC_DBLK_OST_YBASE 0x397d
-#define P_HEVC_DBLK_OST_YBASE           DOS_REG_ADDR(HEVC_DBLK_OST_YBASE)
-#define HEVC_DBLK_CTRL1 0x397f
-#define P_HEVC_DBLK_CTRL1               DOS_REG_ADDR(HEVC_DBLK_CTRL1)
-#define HEVC_MCRCC_CTL1 0x3980
-#define P_HEVC_MCRCC_CTL1               DOS_REG_ADDR(HEVC_MCRCC_CTL1)
-#define HEVC_MCRCC_CTL2 0x3981
-#define P_HEVC_MCRCC_CTL2               DOS_REG_ADDR(HEVC_MCRCC_CTL2)
-#define HEVC_MCRCC_CTL3 0x3982
-#define P_HEVC_MCRCC_CTL3               DOS_REG_ADDR(HEVC_MCRCC_CTL3)
-#define HEVC_GCLK_EN 0x3983
-#define P_HEVC_GCLK_EN          DOS_REG_ADDR(HEVC_GCLK_EN)
-#define HEVC_MDEC_SW_RESET 0x3984
-#define P_HEVC_MDEC_SW_RESET            DOS_REG_ADDR(HEVC_MDEC_SW_RESET)
-/**/
-#define HEVC_DCAC_CPU_DATA 0x3e15
-#define P_HEVC_DCAC_CPU_DATA            DOS_REG_ADDR(HEVC_DCAC_CPU_DATA)
-#define HEVC_DCAC_MB_COUNT 0x3e16
-#define P_HEVC_DCAC_MB_COUNT            DOS_REG_ADDR(HEVC_DCAC_MB_COUNT)
-#define HEVC_IQ_QUANT 0x3e17
-#define P_HEVC_IQ_QUANT                 DOS_REG_ADDR(HEVC_IQ_QUANT)
-/**/
-#define HCODEC_MSP 0x1300
-#define P_HCODEC_MSP            DOS_REG_ADDR(HCODEC_MSP)
-#define HCODEC_MPSR 0x1301
-#define P_HCODEC_MPSR           DOS_REG_ADDR(HCODEC_MPSR)
-#define HCODEC_MINT_VEC_BASE 0x1302
-#define P_HCODEC_MINT_VEC_BASE          DOS_REG_ADDR(HCODEC_MINT_VEC_BASE)
-#define HCODEC_MCPU_INTR_GRP 0x1303
-#define P_HCODEC_MCPU_INTR_GRP          DOS_REG_ADDR(HCODEC_MCPU_INTR_GRP)
-#define HCODEC_MCPU_INTR_MSK 0x1304
-#define P_HCODEC_MCPU_INTR_MSK          DOS_REG_ADDR(HCODEC_MCPU_INTR_MSK)
-#define HCODEC_MCPU_INTR_REQ 0x1305
-#define P_HCODEC_MCPU_INTR_REQ          DOS_REG_ADDR(HCODEC_MCPU_INTR_REQ)
-#define HCODEC_MPC_P 0x1306
-#define P_HCODEC_MPC_P          DOS_REG_ADDR(HCODEC_MPC_P)
-#define HCODEC_MPC_D 0x1307
-#define P_HCODEC_MPC_D          DOS_REG_ADDR(HCODEC_MPC_D)
-#define HCODEC_MPC_E 0x1308
-#define P_HCODEC_MPC_E          DOS_REG_ADDR(HCODEC_MPC_E)
-#define HCODEC_MPC_W 0x1309
-#define P_HCODEC_MPC_W          DOS_REG_ADDR(HCODEC_MPC_W)
-#define HCODEC_MINDEX0_REG 0x130a
-#define P_HCODEC_MINDEX0_REG            DOS_REG_ADDR(HCODEC_MINDEX0_REG)
-#define HCODEC_MINDEX1_REG 0x130b
-#define P_HCODEC_MINDEX1_REG            DOS_REG_ADDR(HCODEC_MINDEX1_REG)
-#define HCODEC_MINDEX2_REG 0x130c
-#define P_HCODEC_MINDEX2_REG            DOS_REG_ADDR(HCODEC_MINDEX2_REG)
-#define HCODEC_MINDEX3_REG 0x130d
-#define P_HCODEC_MINDEX3_REG            DOS_REG_ADDR(HCODEC_MINDEX3_REG)
-#define HCODEC_MINDEX4_REG 0x130e
-#define P_HCODEC_MINDEX4_REG            DOS_REG_ADDR(HCODEC_MINDEX4_REG)
-#define HCODEC_MINDEX5_REG 0x130f
-#define P_HCODEC_MINDEX5_REG            DOS_REG_ADDR(HCODEC_MINDEX5_REG)
-#define HCODEC_MINDEX6_REG 0x1310
-#define P_HCODEC_MINDEX6_REG            DOS_REG_ADDR(HCODEC_MINDEX6_REG)
-#define HCODEC_MINDEX7_REG 0x1311
-#define P_HCODEC_MINDEX7_REG            DOS_REG_ADDR(HCODEC_MINDEX7_REG)
-#define HCODEC_MMIN_REG 0x1312
-#define P_HCODEC_MMIN_REG               DOS_REG_ADDR(HCODEC_MMIN_REG)
-#define HCODEC_MMAX_REG 0x1313
-#define P_HCODEC_MMAX_REG               DOS_REG_ADDR(HCODEC_MMAX_REG)
-#define HCODEC_MBREAK0_REG 0x1314
-#define P_HCODEC_MBREAK0_REG            DOS_REG_ADDR(HCODEC_MBREAK0_REG)
-#define HCODEC_MBREAK1_REG 0x1315
-#define P_HCODEC_MBREAK1_REG            DOS_REG_ADDR(HCODEC_MBREAK1_REG)
-#define HCODEC_MBREAK2_REG 0x1316
-#define P_HCODEC_MBREAK2_REG            DOS_REG_ADDR(HCODEC_MBREAK2_REG)
-#define HCODEC_MBREAK3_REG 0x1317
-#define P_HCODEC_MBREAK3_REG            DOS_REG_ADDR(HCODEC_MBREAK3_REG)
-#define HCODEC_MBREAK_TYPE 0x1318
-#define P_HCODEC_MBREAK_TYPE            DOS_REG_ADDR(HCODEC_MBREAK_TYPE)
-#define HCODEC_MBREAK_CTRL 0x1319
-#define P_HCODEC_MBREAK_CTRL            DOS_REG_ADDR(HCODEC_MBREAK_CTRL)
-#define HCODEC_MBREAK_STAUTS 0x131a
-#define P_HCODEC_MBREAK_STAUTS          DOS_REG_ADDR(HCODEC_MBREAK_STAUTS)
-#define HCODEC_MDB_ADDR_REG 0x131b
-#define P_HCODEC_MDB_ADDR_REG           DOS_REG_ADDR(HCODEC_MDB_ADDR_REG)
-#define HCODEC_MDB_DATA_REG 0x131c
-#define P_HCODEC_MDB_DATA_REG           DOS_REG_ADDR(HCODEC_MDB_DATA_REG)
-#define HCODEC_MDB_CTRL 0x131d
-#define P_HCODEC_MDB_CTRL               DOS_REG_ADDR(HCODEC_MDB_CTRL)
-#define HCODEC_MSFTINT0 0x131e
-#define P_HCODEC_MSFTINT0               DOS_REG_ADDR(HCODEC_MSFTINT0)
-#define HCODEC_MSFTINT1 0x131f
-#define P_HCODEC_MSFTINT1               DOS_REG_ADDR(HCODEC_MSFTINT1)
-#define HCODEC_CSP 0x1320
-#define P_HCODEC_CSP            DOS_REG_ADDR(HCODEC_CSP)
-#define HCODEC_CPSR 0x1321
-#define P_HCODEC_CPSR           DOS_REG_ADDR(HCODEC_CPSR)
-#define HCODEC_CINT_VEC_BASE 0x1322
-#define P_HCODEC_CINT_VEC_BASE          DOS_REG_ADDR(HCODEC_CINT_VEC_BASE)
-#define HCODEC_CCPU_INTR_GRP 0x1323
-#define P_HCODEC_CCPU_INTR_GRP          DOS_REG_ADDR(HCODEC_CCPU_INTR_GRP)
-#define HCODEC_CCPU_INTR_MSK 0x1324
-#define P_HCODEC_CCPU_INTR_MSK          DOS_REG_ADDR(HCODEC_CCPU_INTR_MSK)
-#define HCODEC_CCPU_INTR_REQ 0x1325
-#define P_HCODEC_CCPU_INTR_REQ          DOS_REG_ADDR(HCODEC_CCPU_INTR_REQ)
-#define HCODEC_CPC_P 0x1326
-#define P_HCODEC_CPC_P          DOS_REG_ADDR(HCODEC_CPC_P)
-#define HCODEC_CPC_D 0x1327
-#define P_HCODEC_CPC_D          DOS_REG_ADDR(HCODEC_CPC_D)
-#define HCODEC_CPC_E 0x1328
-#define P_HCODEC_CPC_E          DOS_REG_ADDR(HCODEC_CPC_E)
-#define HCODEC_CPC_W 0x1329
-#define P_HCODEC_CPC_W          DOS_REG_ADDR(HCODEC_CPC_W)
-#define HCODEC_CINDEX0_REG 0x132a
-#define P_HCODEC_CINDEX0_REG            DOS_REG_ADDR(HCODEC_CINDEX0_REG)
-#define HCODEC_CINDEX1_REG 0x132b
-#define P_HCODEC_CINDEX1_REG            DOS_REG_ADDR(HCODEC_CINDEX1_REG)
-#define HCODEC_CINDEX2_REG 0x132c
-#define P_HCODEC_CINDEX2_REG            DOS_REG_ADDR(HCODEC_CINDEX2_REG)
-#define HCODEC_CINDEX3_REG 0x132d
-#define P_HCODEC_CINDEX3_REG            DOS_REG_ADDR(HCODEC_CINDEX3_REG)
-#define HCODEC_CINDEX4_REG 0x132e
-#define P_HCODEC_CINDEX4_REG            DOS_REG_ADDR(HCODEC_CINDEX4_REG)
-#define HCODEC_CINDEX5_REG 0x132f
-#define P_HCODEC_CINDEX5_REG            DOS_REG_ADDR(HCODEC_CINDEX5_REG)
-#define HCODEC_CINDEX6_REG 0x1330
-#define P_HCODEC_CINDEX6_REG            DOS_REG_ADDR(HCODEC_CINDEX6_REG)
-#define HCODEC_CINDEX7_REG 0x1331
-#define P_HCODEC_CINDEX7_REG            DOS_REG_ADDR(HCODEC_CINDEX7_REG)
-#define HCODEC_CMIN_REG 0x1332
-#define P_HCODEC_CMIN_REG               DOS_REG_ADDR(HCODEC_CMIN_REG)
-#define HCODEC_CMAX_REG 0x1333
-#define P_HCODEC_CMAX_REG               DOS_REG_ADDR(HCODEC_CMAX_REG)
-#define HCODEC_CBREAK0_REG 0x1334
-#define P_HCODEC_CBREAK0_REG            DOS_REG_ADDR(HCODEC_CBREAK0_REG)
-#define HCODEC_CBREAK1_REG 0x1335
-#define P_HCODEC_CBREAK1_REG            DOS_REG_ADDR(HCODEC_CBREAK1_REG)
-#define HCODEC_CBREAK2_REG 0x1336
-#define P_HCODEC_CBREAK2_REG            DOS_REG_ADDR(HCODEC_CBREAK2_REG)
-#define HCODEC_CBREAK3_REG 0x1337
-#define P_HCODEC_CBREAK3_REG            DOS_REG_ADDR(HCODEC_CBREAK3_REG)
-#define HCODEC_CBREAK_TYPE 0x1338
-#define P_HCODEC_CBREAK_TYPE            DOS_REG_ADDR(HCODEC_CBREAK_TYPE)
-#define HCODEC_CBREAK_CTRL 0x1339
-#define P_HCODEC_CBREAK_CTRL            DOS_REG_ADDR(HCODEC_CBREAK_CTRL)
-#define HCODEC_CBREAK_STAUTS 0x133a
-#define P_HCODEC_CBREAK_STAUTS          DOS_REG_ADDR(HCODEC_CBREAK_STAUTS)
-#define HCODEC_CDB_ADDR_REG 0x133b
-#define P_HCODEC_CDB_ADDR_REG           DOS_REG_ADDR(HCODEC_CDB_ADDR_REG)
-#define HCODEC_CDB_DATA_REG 0x133c
-#define P_HCODEC_CDB_DATA_REG           DOS_REG_ADDR(HCODEC_CDB_DATA_REG)
-#define HCODEC_CDB_CTRL 0x133d
-#define P_HCODEC_CDB_CTRL               DOS_REG_ADDR(HCODEC_CDB_CTRL)
-#define HCODEC_CSFTINT0 0x133e
-#define P_HCODEC_CSFTINT0               DOS_REG_ADDR(HCODEC_CSFTINT0)
-#define HCODEC_CSFTINT1 0x133f
-#define P_HCODEC_CSFTINT1               DOS_REG_ADDR(HCODEC_CSFTINT1)
-#define HCODEC_IMEM_DMA_CTRL 0x1340
-#define P_HCODEC_IMEM_DMA_CTRL          DOS_REG_ADDR(HCODEC_IMEM_DMA_CTRL)
-#define HCODEC_IMEM_DMA_ADR 0x1341
-#define P_HCODEC_IMEM_DMA_ADR           DOS_REG_ADDR(HCODEC_IMEM_DMA_ADR)
-#define HCODEC_WRRSP_IMEM 0x1343
-#define P_HCODEC_WRRSP_IMEM             DOS_REG_ADDR(HCODEC_WRRSP_IMEM)
-#define HCODEC_LMEM_DMA_CTRL 0x1350
-#define P_HCODEC_LMEM_DMA_CTRL          DOS_REG_ADDR(HCODEC_LMEM_DMA_CTRL)
-#define HCODEC_LMEM_DMA_ADR 0x1351
-#define P_HCODEC_LMEM_DMA_ADR           DOS_REG_ADDR(HCODEC_LMEM_DMA_ADR)
-#define HCODEC_WRRSP_LMEM 0x1353
-#define P_HCODEC_WRRSP_LMEM             DOS_REG_ADDR(HCODEC_WRRSP_LMEM)
-#define HCODEC_MAC_CTRL1 0x1360
-#define P_HCODEC_MAC_CTRL1              DOS_REG_ADDR(HCODEC_MAC_CTRL1)
-#define HCODEC_ACC0REG1 0x1361
-#define P_HCODEC_ACC0REG1               DOS_REG_ADDR(HCODEC_ACC0REG1)
-#define HCODEC_ACC1REG1 0x1362
-#define P_HCODEC_ACC1REG1               DOS_REG_ADDR(HCODEC_ACC1REG1)
-#define HCODEC_MAC_CTRL2 0x1370
-#define P_HCODEC_MAC_CTRL2              DOS_REG_ADDR(HCODEC_MAC_CTRL2)
-#define HCODEC_ACC0REG2 0x1371
-#define P_HCODEC_ACC0REG2               DOS_REG_ADDR(HCODEC_ACC0REG2)
-#define HCODEC_ACC1REG2 0x1372
-#define P_HCODEC_ACC1REG2               DOS_REG_ADDR(HCODEC_ACC1REG2)
-#define HCODEC_CPU_TRACE 0x1380
-#define P_HCODEC_CPU_TRACE              DOS_REG_ADDR(HCODEC_CPU_TRACE)
-#define VDEC2_MSP 0x2300
-#define P_VDEC2_MSP             DOS_REG_ADDR(VDEC2_MSP)
-#define VDEC2_MPSR 0x2301
-#define P_VDEC2_MPSR            DOS_REG_ADDR(VDEC2_MPSR)
-#define VDEC2_MINT_VEC_BASE 0x2302
-#define P_VDEC2_MINT_VEC_BASE           DOS_REG_ADDR(VDEC2_MINT_VEC_BASE)
-#define VDEC2_MCPU_INTR_GRP 0x2303
-#define P_VDEC2_MCPU_INTR_GRP           DOS_REG_ADDR(VDEC2_MCPU_INTR_GRP)
-#define VDEC2_MCPU_INTR_MSK 0x2304
-#define P_VDEC2_MCPU_INTR_MSK           DOS_REG_ADDR(VDEC2_MCPU_INTR_MSK)
-#define VDEC2_MCPU_INTR_REQ 0x2305
-#define P_VDEC2_MCPU_INTR_REQ           DOS_REG_ADDR(VDEC2_MCPU_INTR_REQ)
-#define VDEC2_MPC_P 0x2306
-#define P_VDEC2_MPC_P           DOS_REG_ADDR(VDEC2_MPC_P)
-#define VDEC2_MPC_D 0x2307
-#define P_VDEC2_MPC_D           DOS_REG_ADDR(VDEC2_MPC_D)
-#define VDEC2_MPC_E 0x2308
-#define P_VDEC2_MPC_E           DOS_REG_ADDR(VDEC2_MPC_E)
-#define VDEC2_MPC_W 0x2309
-#define P_VDEC2_MPC_W           DOS_REG_ADDR(VDEC2_MPC_W)
-#define VDEC2_MINDEX0_REG 0x230a
-#define P_VDEC2_MINDEX0_REG             DOS_REG_ADDR(VDEC2_MINDEX0_REG)
-#define VDEC2_MINDEX1_REG 0x230b
-#define P_VDEC2_MINDEX1_REG             DOS_REG_ADDR(VDEC2_MINDEX1_REG)
-#define VDEC2_MINDEX2_REG 0x230c
-#define P_VDEC2_MINDEX2_REG             DOS_REG_ADDR(VDEC2_MINDEX2_REG)
-#define VDEC2_MINDEX3_REG 0x230d
-#define P_VDEC2_MINDEX3_REG             DOS_REG_ADDR(VDEC2_MINDEX3_REG)
-#define VDEC2_MINDEX4_REG 0x230e
-#define P_VDEC2_MINDEX4_REG             DOS_REG_ADDR(VDEC2_MINDEX4_REG)
-#define VDEC2_MINDEX5_REG 0x230f
-#define P_VDEC2_MINDEX5_REG             DOS_REG_ADDR(VDEC2_MINDEX5_REG)
-#define VDEC2_MINDEX6_REG 0x2310
-#define P_VDEC2_MINDEX6_REG             DOS_REG_ADDR(VDEC2_MINDEX6_REG)
-#define VDEC2_MINDEX7_REG 0x2311
-#define P_VDEC2_MINDEX7_REG             DOS_REG_ADDR(VDEC2_MINDEX7_REG)
-#define VDEC2_MMIN_REG 0x2312
-#define P_VDEC2_MMIN_REG                DOS_REG_ADDR(VDEC2_MMIN_REG)
-#define VDEC2_MMAX_REG 0x2313
-#define P_VDEC2_MMAX_REG                DOS_REG_ADDR(VDEC2_MMAX_REG)
-#define VDEC2_MBREAK0_REG 0x2314
-#define P_VDEC2_MBREAK0_REG             DOS_REG_ADDR(VDEC2_MBREAK0_REG)
-#define VDEC2_MBREAK1_REG 0x2315
-#define P_VDEC2_MBREAK1_REG             DOS_REG_ADDR(VDEC2_MBREAK1_REG)
-#define VDEC2_MBREAK2_REG 0x2316
-#define P_VDEC2_MBREAK2_REG             DOS_REG_ADDR(VDEC2_MBREAK2_REG)
-#define VDEC2_MBREAK3_REG 0x2317
-#define P_VDEC2_MBREAK3_REG             DOS_REG_ADDR(VDEC2_MBREAK3_REG)
-#define VDEC2_MBREAK_TYPE 0x2318
-#define P_VDEC2_MBREAK_TYPE             DOS_REG_ADDR(VDEC2_MBREAK_TYPE)
-#define VDEC2_MBREAK_CTRL 0x2319
-#define P_VDEC2_MBREAK_CTRL             DOS_REG_ADDR(VDEC2_MBREAK_CTRL)
-#define VDEC2_MBREAK_STAUTS 0x231a
-#define P_VDEC2_MBREAK_STAUTS           DOS_REG_ADDR(VDEC2_MBREAK_STAUTS)
-#define VDEC2_MDB_ADDR_REG 0x231b
-#define P_VDEC2_MDB_ADDR_REG            DOS_REG_ADDR(VDEC2_MDB_ADDR_REG)
-#define VDEC2_MDB_DATA_REG 0x231c
-#define P_VDEC2_MDB_DATA_REG            DOS_REG_ADDR(VDEC2_MDB_DATA_REG)
-#define VDEC2_MDB_CTRL 0x231d
-#define P_VDEC2_MDB_CTRL                DOS_REG_ADDR(VDEC2_MDB_CTRL)
-#define VDEC2_MSFTINT0 0x231e
-#define P_VDEC2_MSFTINT0                DOS_REG_ADDR(VDEC2_MSFTINT0)
-#define VDEC2_MSFTINT1 0x231f
-#define P_VDEC2_MSFTINT1                DOS_REG_ADDR(VDEC2_MSFTINT1)
-#define VDEC2_CSP 0x2320
-#define P_VDEC2_CSP             DOS_REG_ADDR(VDEC2_CSP)
-#define VDEC2_CPSR 0x2321
-#define P_VDEC2_CPSR            DOS_REG_ADDR(VDEC2_CPSR)
-#define VDEC2_CINT_VEC_BASE 0x2322
-#define P_VDEC2_CINT_VEC_BASE           DOS_REG_ADDR(VDEC2_CINT_VEC_BASE)
-#define VDEC2_CCPU_INTR_GRP 0x2323
-#define P_VDEC2_CCPU_INTR_GRP           DOS_REG_ADDR(VDEC2_CCPU_INTR_GRP)
-#define VDEC2_CCPU_INTR_MSK 0x2324
-#define P_VDEC2_CCPU_INTR_MSK           DOS_REG_ADDR(VDEC2_CCPU_INTR_MSK)
-#define VDEC2_CCPU_INTR_REQ 0x2325
-#define P_VDEC2_CCPU_INTR_REQ           DOS_REG_ADDR(VDEC2_CCPU_INTR_REQ)
-#define VDEC2_CPC_P 0x2326
-#define P_VDEC2_CPC_P           DOS_REG_ADDR(VDEC2_CPC_P)
-#define VDEC2_CPC_D 0x2327
-#define P_VDEC2_CPC_D           DOS_REG_ADDR(VDEC2_CPC_D)
-#define VDEC2_CPC_E 0x2328
-#define P_VDEC2_CPC_E           DOS_REG_ADDR(VDEC2_CPC_E)
-#define VDEC2_CPC_W 0x2329
-#define P_VDEC2_CPC_W           DOS_REG_ADDR(VDEC2_CPC_W)
-#define VDEC2_CINDEX0_REG 0x232a
-#define P_VDEC2_CINDEX0_REG             DOS_REG_ADDR(VDEC2_CINDEX0_REG)
-#define VDEC2_CINDEX1_REG 0x232b
-#define P_VDEC2_CINDEX1_REG             DOS_REG_ADDR(VDEC2_CINDEX1_REG)
-#define VDEC2_CINDEX2_REG 0x232c
-#define P_VDEC2_CINDEX2_REG             DOS_REG_ADDR(VDEC2_CINDEX2_REG)
-#define VDEC2_CINDEX3_REG 0x232d
-#define P_VDEC2_CINDEX3_REG             DOS_REG_ADDR(VDEC2_CINDEX3_REG)
-#define VDEC2_CINDEX4_REG 0x232e
-#define P_VDEC2_CINDEX4_REG             DOS_REG_ADDR(VDEC2_CINDEX4_REG)
-#define VDEC2_CINDEX5_REG 0x232f
-#define P_VDEC2_CINDEX5_REG             DOS_REG_ADDR(VDEC2_CINDEX5_REG)
-#define VDEC2_CINDEX6_REG 0x2330
-#define P_VDEC2_CINDEX6_REG             DOS_REG_ADDR(VDEC2_CINDEX6_REG)
-#define VDEC2_CINDEX7_REG 0x2331
-#define P_VDEC2_CINDEX7_REG             DOS_REG_ADDR(VDEC2_CINDEX7_REG)
-#define VDEC2_CMIN_REG 0x2332
-#define P_VDEC2_CMIN_REG                DOS_REG_ADDR(VDEC2_CMIN_REG)
-#define VDEC2_CMAX_REG 0x2333
-#define P_VDEC2_CMAX_REG                DOS_REG_ADDR(VDEC2_CMAX_REG)
-#define VDEC2_CBREAK0_REG 0x2334
-#define P_VDEC2_CBREAK0_REG             DOS_REG_ADDR(VDEC2_CBREAK0_REG)
-#define VDEC2_CBREAK1_REG 0x2335
-#define P_VDEC2_CBREAK1_REG             DOS_REG_ADDR(VDEC2_CBREAK1_REG)
-#define VDEC2_CBREAK2_REG 0x2336
-#define P_VDEC2_CBREAK2_REG             DOS_REG_ADDR(VDEC2_CBREAK2_REG)
-#define VDEC2_CBREAK3_REG 0x2337
-#define P_VDEC2_CBREAK3_REG             DOS_REG_ADDR(VDEC2_CBREAK3_REG)
-#define VDEC2_CBREAK_TYPE 0x2338
-#define P_VDEC2_CBREAK_TYPE             DOS_REG_ADDR(VDEC2_CBREAK_TYPE)
-#define VDEC2_CBREAK_CTRL 0x2339
-#define P_VDEC2_CBREAK_CTRL             DOS_REG_ADDR(VDEC2_CBREAK_CTRL)
-#define VDEC2_CBREAK_STAUTS 0x233a
-#define P_VDEC2_CBREAK_STAUTS           DOS_REG_ADDR(VDEC2_CBREAK_STAUTS)
-#define VDEC2_CDB_ADDR_REG 0x233b
-#define P_VDEC2_CDB_ADDR_REG            DOS_REG_ADDR(VDEC2_CDB_ADDR_REG)
-#define VDEC2_CDB_DATA_REG 0x233c
-#define P_VDEC2_CDB_DATA_REG            DOS_REG_ADDR(VDEC2_CDB_DATA_REG)
-#define VDEC2_CDB_CTRL 0x233d
-#define P_VDEC2_CDB_CTRL                DOS_REG_ADDR(VDEC2_CDB_CTRL)
-#define VDEC2_CSFTINT0 0x233e
-#define P_VDEC2_CSFTINT0                DOS_REG_ADDR(VDEC2_CSFTINT0)
-#define VDEC2_CSFTINT1 0x233f
-#define P_VDEC2_CSFTINT1                DOS_REG_ADDR(VDEC2_CSFTINT1)
-#define VDEC2_IMEM_DMA_CTRL 0x2340
-#define P_VDEC2_IMEM_DMA_CTRL           DOS_REG_ADDR(VDEC2_IMEM_DMA_CTRL)
-#define VDEC2_IMEM_DMA_ADR 0x2341
-#define P_VDEC2_IMEM_DMA_ADR            DOS_REG_ADDR(VDEC2_IMEM_DMA_ADR)
-#define VDEC2_IMEM_DMA_COUNT 0x2342
-#define P_VDEC2_IMEM_DMA_COUNT          DOS_REG_ADDR(VDEC2_IMEM_DMA_COUNT)
-#define VDEC2_WRRSP_IMEM 0x2343
-#define P_VDEC2_WRRSP_IMEM              DOS_REG_ADDR(VDEC2_WRRSP_IMEM)
-#define VDEC2_LMEM_DMA_CTRL 0x2350
-#define P_VDEC2_LMEM_DMA_CTRL           DOS_REG_ADDR(VDEC2_LMEM_DMA_CTRL)
-#define VDEC2_LMEM_DMA_ADR 0x2351
-#define P_VDEC2_LMEM_DMA_ADR            DOS_REG_ADDR(VDEC2_LMEM_DMA_ADR)
-#define VDEC2_LMEM_DMA_COUNT 0x2352
-#define P_VDEC2_LMEM_DMA_COUNT          DOS_REG_ADDR(VDEC2_LMEM_DMA_COUNT)
-#define VDEC2_WRRSP_LMEM 0x2353
-#define P_VDEC2_WRRSP_LMEM              DOS_REG_ADDR(VDEC2_WRRSP_LMEM)
-#define VDEC2_MAC_CTRL1 0x2360
-#define P_VDEC2_MAC_CTRL1               DOS_REG_ADDR(VDEC2_MAC_CTRL1)
-#define VDEC2_ACC0REG1 0x2361
-#define P_VDEC2_ACC0REG1                DOS_REG_ADDR(VDEC2_ACC0REG1)
-#define VDEC2_ACC1REG1 0x2362
-#define P_VDEC2_ACC1REG1                DOS_REG_ADDR(VDEC2_ACC1REG1)
-#define VDEC2_MAC_CTRL2 0x2370
-#define P_VDEC2_MAC_CTRL2               DOS_REG_ADDR(VDEC2_MAC_CTRL2)
-#define VDEC2_ACC0REG2 0x2371
-#define P_VDEC2_ACC0REG2                DOS_REG_ADDR(VDEC2_ACC0REG2)
-#define VDEC2_ACC1REG2 0x2372
-#define P_VDEC2_ACC1REG2                DOS_REG_ADDR(VDEC2_ACC1REG2)
-#define VDEC2_CPU_TRACE 0x2380
-#define P_VDEC2_CPU_TRACE               DOS_REG_ADDR(VDEC2_CPU_TRACE)
-/*add from M8M2*/
-#define HEVC_MSP 0x3300
-#define P_HEVC_MSP              DOS_REG_ADDR(HEVC_MSP)
-#define HEVC_MPSR 0x3301
-#define P_HEVC_MPSR             DOS_REG_ADDR(HEVC_MPSR)
-#define HEVC_MINT_VEC_BASE 0x3302
-#define P_HEVC_MINT_VEC_BASE            DOS_REG_ADDR(HEVC_MINT_VEC_BASE)
-#define HEVC_MCPU_INTR_GRP 0x3303
-#define P_HEVC_MCPU_INTR_GRP            DOS_REG_ADDR(HEVC_MCPU_INTR_GRP)
-#define HEVC_MCPU_INTR_MSK 0x3304
-#define P_HEVC_MCPU_INTR_MSK            DOS_REG_ADDR(HEVC_MCPU_INTR_MSK)
-#define HEVC_MCPU_INTR_REQ 0x3305
-#define P_HEVC_MCPU_INTR_REQ            DOS_REG_ADDR(HEVC_MCPU_INTR_REQ)
-#define HEVC_MPC_P 0x3306
-#define P_HEVC_MPC_P            DOS_REG_ADDR(HEVC_MPC_P)
-#define HEVC_MPC_D 0x3307
-#define P_HEVC_MPC_D            DOS_REG_ADDR(HEVC_MPC_D)
-#define HEVC_MPC_E 0x3308
-#define P_HEVC_MPC_E            DOS_REG_ADDR(HEVC_MPC_E)
-#define HEVC_MPC_W 0x3309
-#define P_HEVC_MPC_W            DOS_REG_ADDR(HEVC_MPC_W)
-#define HEVC_MINDEX0_REG 0x330a
-#define P_HEVC_MINDEX0_REG              DOS_REG_ADDR(HEVC_MINDEX0_REG)
-#define HEVC_MINDEX1_REG 0x330b
-#define P_HEVC_MINDEX1_REG              DOS_REG_ADDR(HEVC_MINDEX1_REG)
-#define HEVC_MINDEX2_REG 0x330c
-#define P_HEVC_MINDEX2_REG              DOS_REG_ADDR(HEVC_MINDEX2_REG)
-#define HEVC_MINDEX3_REG 0x330d
-#define P_HEVC_MINDEX3_REG              DOS_REG_ADDR(HEVC_MINDEX3_REG)
-#define HEVC_MINDEX4_REG 0x330e
-#define P_HEVC_MINDEX4_REG              DOS_REG_ADDR(HEVC_MINDEX4_REG)
-#define HEVC_MINDEX5_REG 0x330f
-#define P_HEVC_MINDEX5_REG              DOS_REG_ADDR(HEVC_MINDEX5_REG)
-#define HEVC_MINDEX6_REG 0x3310
-#define P_HEVC_MINDEX6_REG              DOS_REG_ADDR(HEVC_MINDEX6_REG)
-#define HEVC_MINDEX7_REG 0x3311
-#define P_HEVC_MINDEX7_REG              DOS_REG_ADDR(HEVC_MINDEX7_REG)
-#define HEVC_MMIN_REG 0x3312
-#define P_HEVC_MMIN_REG                 DOS_REG_ADDR(HEVC_MMIN_REG)
-#define HEVC_MMAX_REG 0x3313
-#define P_HEVC_MMAX_REG                 DOS_REG_ADDR(HEVC_MMAX_REG)
-#define HEVC_MBREAK0_REG 0x3314
-#define P_HEVC_MBREAK0_REG              DOS_REG_ADDR(HEVC_MBREAK0_REG)
-#define HEVC_MBREAK1_REG 0x3315
-#define P_HEVC_MBREAK1_REG              DOS_REG_ADDR(HEVC_MBREAK1_REG)
-#define HEVC_MBREAK2_REG 0x3316
-#define P_HEVC_MBREAK2_REG              DOS_REG_ADDR(HEVC_MBREAK2_REG)
-#define HEVC_MBREAK3_REG 0x3317
-#define P_HEVC_MBREAK3_REG              DOS_REG_ADDR(HEVC_MBREAK3_REG)
-#define HEVC_MBREAK_TYPE 0x3318
-#define P_HEVC_MBREAK_TYPE              DOS_REG_ADDR(HEVC_MBREAK_TYPE)
-#define HEVC_MBREAK_CTRL 0x3319
-#define P_HEVC_MBREAK_CTRL              DOS_REG_ADDR(HEVC_MBREAK_CTRL)
-#define HEVC_MBREAK_STAUTS 0x331a
-#define P_HEVC_MBREAK_STAUTS            DOS_REG_ADDR(HEVC_MBREAK_STAUTS)
-#define HEVC_MDB_ADDR_REG 0x331b
-#define P_HEVC_MDB_ADDR_REG             DOS_REG_ADDR(HEVC_MDB_ADDR_REG)
-#define HEVC_MDB_DATA_REG 0x331c
-#define P_HEVC_MDB_DATA_REG             DOS_REG_ADDR(HEVC_MDB_DATA_REG)
-#define HEVC_MDB_CTRL 0x331d
-#define P_HEVC_MDB_CTRL                 DOS_REG_ADDR(HEVC_MDB_CTRL)
-#define HEVC_MSFTINT0 0x331e
-#define P_HEVC_MSFTINT0                 DOS_REG_ADDR(HEVC_MSFTINT0)
-#define HEVC_MSFTINT1 0x331f
-#define P_HEVC_MSFTINT1                 DOS_REG_ADDR(HEVC_MSFTINT1)
-#define HEVC_CSP 0x3320
-#define P_HEVC_CSP              DOS_REG_ADDR(HEVC_CSP)
-#define HEVC_CPSR 0x3321
-#define P_HEVC_CPSR             DOS_REG_ADDR(HEVC_CPSR)
-#define HEVC_CINT_VEC_BASE 0x3322
-#define P_HEVC_CINT_VEC_BASE            DOS_REG_ADDR(HEVC_CINT_VEC_BASE)
-#define HEVC_CCPU_INTR_GRP 0x3323
-#define P_HEVC_CCPU_INTR_GRP            DOS_REG_ADDR(HEVC_CCPU_INTR_GRP)
-#define HEVC_CCPU_INTR_MSK 0x3324
-#define P_HEVC_CCPU_INTR_MSK            DOS_REG_ADDR(HEVC_CCPU_INTR_MSK)
-#define HEVC_CCPU_INTR_REQ 0x3325
-#define P_HEVC_CCPU_INTR_REQ            DOS_REG_ADDR(HEVC_CCPU_INTR_REQ)
-#define HEVC_CPC_P 0x3326
-#define P_HEVC_CPC_P            DOS_REG_ADDR(HEVC_CPC_P)
-#define HEVC_CPC_D 0x3327
-#define P_HEVC_CPC_D            DOS_REG_ADDR(HEVC_CPC_D)
-#define HEVC_CPC_E 0x3328
-#define P_HEVC_CPC_E            DOS_REG_ADDR(HEVC_CPC_E)
-#define HEVC_CPC_W 0x3329
-#define P_HEVC_CPC_W            DOS_REG_ADDR(HEVC_CPC_W)
-#define HEVC_CINDEX0_REG 0x332a
-#define P_HEVC_CINDEX0_REG              DOS_REG_ADDR(HEVC_CINDEX0_REG)
-#define HEVC_CINDEX1_REG 0x332b
-#define P_HEVC_CINDEX1_REG              DOS_REG_ADDR(HEVC_CINDEX1_REG)
-#define HEVC_CINDEX2_REG 0x332c
-#define P_HEVC_CINDEX2_REG              DOS_REG_ADDR(HEVC_CINDEX2_REG)
-#define HEVC_CINDEX3_REG 0x332d
-#define P_HEVC_CINDEX3_REG              DOS_REG_ADDR(HEVC_CINDEX3_REG)
-#define HEVC_CINDEX4_REG 0x332e
-#define P_HEVC_CINDEX4_REG              DOS_REG_ADDR(HEVC_CINDEX4_REG)
-#define HEVC_CINDEX5_REG 0x332f
-#define P_HEVC_CINDEX5_REG              DOS_REG_ADDR(HEVC_CINDEX5_REG)
-#define HEVC_CINDEX6_REG 0x3330
-#define P_HEVC_CINDEX6_REG              DOS_REG_ADDR(HEVC_CINDEX6_REG)
-#define HEVC_CINDEX7_REG 0x3331
-#define P_HEVC_CINDEX7_REG              DOS_REG_ADDR(HEVC_CINDEX7_REG)
-#define HEVC_CMIN_REG 0x3332
-#define P_HEVC_CMIN_REG                 DOS_REG_ADDR(HEVC_CMIN_REG)
-#define HEVC_CMAX_REG 0x3333
-#define P_HEVC_CMAX_REG                 DOS_REG_ADDR(HEVC_CMAX_REG)
-#define HEVC_CBREAK0_REG 0x3334
-#define P_HEVC_CBREAK0_REG              DOS_REG_ADDR(HEVC_CBREAK0_REG)
-#define HEVC_CBREAK1_REG 0x3335
-#define P_HEVC_CBREAK1_REG              DOS_REG_ADDR(HEVC_CBREAK1_REG)
-#define HEVC_CBREAK2_REG 0x3336
-#define P_HEVC_CBREAK2_REG              DOS_REG_ADDR(HEVC_CBREAK2_REG)
-#define HEVC_CBREAK3_REG 0x3337
-#define P_HEVC_CBREAK3_REG              DOS_REG_ADDR(HEVC_CBREAK3_REG)
-#define HEVC_CBREAK_TYPE 0x3338
-#define P_HEVC_CBREAK_TYPE              DOS_REG_ADDR(HEVC_CBREAK_TYPE)
-#define HEVC_CBREAK_CTRL 0x3339
-#define P_HEVC_CBREAK_CTRL              DOS_REG_ADDR(HEVC_CBREAK_CTRL)
-#define HEVC_CBREAK_STAUTS 0x333a
-#define P_HEVC_CBREAK_STAUTS            DOS_REG_ADDR(HEVC_CBREAK_STAUTS)
-#define HEVC_CDB_ADDR_REG 0x333b
-#define P_HEVC_CDB_ADDR_REG             DOS_REG_ADDR(HEVC_CDB_ADDR_REG)
-#define HEVC_CDB_DATA_REG 0x333c
-#define P_HEVC_CDB_DATA_REG             DOS_REG_ADDR(HEVC_CDB_DATA_REG)
-#define HEVC_CDB_CTRL 0x333d
-#define P_HEVC_CDB_CTRL                 DOS_REG_ADDR(HEVC_CDB_CTRL)
-#define HEVC_CSFTINT0 0x333e
-#define P_HEVC_CSFTINT0                 DOS_REG_ADDR(HEVC_CSFTINT0)
-#define HEVC_CSFTINT1 0x333f
-#define P_HEVC_CSFTINT1                 DOS_REG_ADDR(HEVC_CSFTINT1)
-#define HEVC_IMEM_DMA_CTRL 0x3340
-#define P_HEVC_IMEM_DMA_CTRL            DOS_REG_ADDR(HEVC_IMEM_DMA_CTRL)
-#define HEVC_IMEM_DMA_ADR 0x3341
-#define P_HEVC_IMEM_DMA_ADR             DOS_REG_ADDR(HEVC_IMEM_DMA_ADR)
-#define HEVC_IMEM_DMA_COUNT 0x3342
-#define P_HEVC_IMEM_DMA_COUNT           DOS_REG_ADDR(HEVC_IMEM_DMA_COUNT)
-#define HEVC_WRRSP_IMEM 0x3343
-#define P_HEVC_WRRSP_IMEM               DOS_REG_ADDR(HEVC_WRRSP_IMEM)
-#define HEVC_LMEM_DMA_CTRL 0x3350
-#define P_HEVC_LMEM_DMA_CTRL            DOS_REG_ADDR(HEVC_LMEM_DMA_CTRL)
-#define HEVC_LMEM_DMA_ADR 0x3351
-#define P_HEVC_LMEM_DMA_ADR             DOS_REG_ADDR(HEVC_LMEM_DMA_ADR)
-#define HEVC_LMEM_DMA_COUNT 0x3352
-#define P_HEVC_LMEM_DMA_COUNT           DOS_REG_ADDR(HEVC_LMEM_DMA_COUNT)
-#define HEVC_WRRSP_LMEM 0x3353
-#define P_HEVC_WRRSP_LMEM               DOS_REG_ADDR(HEVC_WRRSP_LMEM)
-#define HEVC_MAC_CTRL1 0x3360
-#define P_HEVC_MAC_CTRL1                DOS_REG_ADDR(HEVC_MAC_CTRL1)
-#define HEVC_ACC0REG1 0x3361
-#define P_HEVC_ACC0REG1                 DOS_REG_ADDR(HEVC_ACC0REG1)
-#define HEVC_ACC1REG1 0x3362
-#define P_HEVC_ACC1REG1                 DOS_REG_ADDR(HEVC_ACC1REG1)
-#define HEVC_MAC_CTRL2 0x3370
-#define P_HEVC_MAC_CTRL2                DOS_REG_ADDR(HEVC_MAC_CTRL2)
-#define HEVC_ACC0REG2 0x3371
-#define P_HEVC_ACC0REG2                 DOS_REG_ADDR(HEVC_ACC0REG2)
-#define HEVC_ACC1REG2 0x3372
-#define P_HEVC_ACC1REG2                 DOS_REG_ADDR(HEVC_ACC1REG2)
-#define HEVC_CPU_TRACE 0x3380
-#define P_HEVC_CPU_TRACE                DOS_REG_ADDR(HEVC_CPU_TRACE)
-/**/
-#define HCODEC_VLC_MB_INFO 0x1d35
-#define P_HCODEC_VLC_MB_INFO            DOS_REG_ADDR(HCODEC_VLC_MB_INFO)
-#define HCODEC_VLC_ENC_PEND_CMD 0x1d36
-
-#define HCODEC_VLC_DC_RD_REQ 0x1d45
-#define P_HCODEC_VLC_DC_RD_REQ          DOS_REG_ADDR(HCODEC_VLC_DC_RD_REQ)
-#define HCODEC_VLC_DC 0x1d46
-#define P_HCODEC_VLC_DC                 DOS_REG_ADDR(HCODEC_VLC_DC)
-#define HCODEC_VLC_DC_INFO 0x1d47
-#define P_HCODEC_VLC_DC_INFO            DOS_REG_ADDR(HCODEC_VLC_DC_INFO)
-#define HCODEC_VLC_MV_INDEX 0x1d48
-#define P_HCODEC_VLC_MV_INDEX           DOS_REG_ADDR(HCODEC_VLC_MV_INDEX)
-#define HCODEC_VLC_MV 0x1d49
-#define P_HCODEC_VLC_MV                 DOS_REG_ADDR(HCODEC_VLC_MV)
-#define HCODEC_HENC_TOP_MV_0 0x1d4a
-#define P_HCODEC_HENC_TOP_MV_0          DOS_REG_ADDR(HCODEC_HENC_TOP_MV_0)
-#define HCODEC_HENC_TOP_MV_1 0x1d4b
-#define P_HCODEC_HENC_TOP_MV_1          DOS_REG_ADDR(HCODEC_HENC_TOP_MV_1)
-#define HCODEC_HENC_TOP_MV_2 0x1d4c
-#define P_HCODEC_HENC_TOP_MV_2          DOS_REG_ADDR(HCODEC_HENC_TOP_MV_2)
-#define HCODEC_HENC_TOP_MV_3 0x1d4d
-#define P_HCODEC_HENC_TOP_MV_3          DOS_REG_ADDR(HCODEC_HENC_TOP_MV_3)
-#define HCODEC_HENC_LEFT_MV_0 0x1d4e
-
-/*add from M8M2*/
-#define HCODEC_QDCT_I_PRED_REF_WR_IDX 0x1f32
-#define P_HCODEC_QDCT_I_PRED_REF_WR_IDX                 \
-	DOS_REG_ADDR(HCODEC_QDCT_I_PRED_REF_WR_IDX)
-#define HCODEC_QDCT_I_PRED_REF_WR_DATA 0x1f33
-#define P_HCODEC_QDCT_I_PRED_REF_WR_DATA                \
-	DOS_REG_ADDR(HCODEC_QDCT_I_PRED_REF_WR_DATA)
-/**/
-#define HCODEC_IE_CONTROL 0x1f40
-#define P_HCODEC_IE_CONTROL             DOS_REG_ADDR(HCODEC_IE_CONTROL)
-#define HCODEC_IE_MB_POSITION 0x1f41
-#define P_HCODEC_IE_MB_POSITION                 \
-	DOS_REG_ADDR(HCODEC_IE_MB_POSITION)
-#define HCODEC_IE_ME_MB_INFO 0x1f42
-#define P_HCODEC_IE_ME_MB_INFO          DOS_REG_ADDR(HCODEC_IE_ME_MB_INFO)
-#define HCODEC_SAD_CONTROL 0x1f43
-#define P_HCODEC_SAD_CONTROL            DOS_REG_ADDR(HCODEC_SAD_CONTROL)
-#define HCODEC_IE_I4_PRED_MODE_HI 0x1f45
-#define P_HCODEC_IE_I4_PRED_MODE_HI             \
-	DOS_REG_ADDR(HCODEC_IE_I4_PRED_MODE_HI)
-#define HCODEC_IE_I4_PRED_MODE_LO 0x1f46
-#define P_HCODEC_IE_I4_PRED_MODE_LO             \
-	DOS_REG_ADDR(HCODEC_IE_I4_PRED_MODE_LO)
-#define HCODEC_IE_C_PRED_MODE 0x1f47
-#define P_HCODEC_IE_C_PRED_MODE                 \
-	DOS_REG_ADDR(HCODEC_IE_C_PRED_MODE)
-#define HCODEC_IE_CUR_REF_SEL 0x1f48
-#define P_HCODEC_IE_CUR_REF_SEL                 \
-	DOS_REG_ADDR(HCODEC_IE_CUR_REF_SEL)
-#define HCODEC_ME_CONTROL 0x1f49
-#define P_HCODEC_ME_CONTROL             DOS_REG_ADDR(HCODEC_ME_CONTROL)
-#define HCODEC_ME_START_POSITION 0x1f4a
-#define P_HCODEC_ME_START_POSITION              \
-	DOS_REG_ADDR(HCODEC_ME_START_POSITION)
-#define HCODEC_ME_STATUS 0x1f4b
-#define P_HCODEC_ME_STATUS              DOS_REG_ADDR(HCODEC_ME_STATUS)
-#define HCODEC_ME_DEBUG 0x1f4c
-#define P_HCODEC_ME_DEBUG               DOS_REG_ADDR(HCODEC_ME_DEBUG)
-#define HCODEC_ME_SKIP_LINE 0x1f4d
-#define P_HCODEC_ME_SKIP_LINE           DOS_REG_ADDR(HCODEC_ME_SKIP_LINE)
-#define HCODEC_ME_AB_MEM_CTL 0x1f4e
-#define P_HCODEC_ME_AB_MEM_CTL          DOS_REG_ADDR(HCODEC_ME_AB_MEM_CTL)
-#define HCODEC_ME_PIC_INFO 0x1f4f
-#define P_HCODEC_ME_PIC_INFO            DOS_REG_ADDR(HCODEC_ME_PIC_INFO)
-#define HCODEC_ME_SAD_ENOUGH_01 0x1f50
-#define P_HCODEC_ME_SAD_ENOUGH_01               \
-	DOS_REG_ADDR(HCODEC_ME_SAD_ENOUGH_01)
-#define HCODEC_ME_SAD_ENOUGH_23 0x1f51
-#define P_HCODEC_ME_SAD_ENOUGH_23               \
-	DOS_REG_ADDR(HCODEC_ME_SAD_ENOUGH_23)
-#define HCODEC_ME_STEP0_CLOSE_MV 0x1f52
-#define P_HCODEC_ME_STEP0_CLOSE_MV              \
-	DOS_REG_ADDR(HCODEC_ME_STEP0_CLOSE_MV)
-#define HCODEC_ME_F_SKIP_SAD 0x1f53
-#define P_HCODEC_ME_F_SKIP_SAD          \
-	DOS_REG_ADDR(HCODEC_ME_F_SKIP_SAD)
-#define HCODEC_ME_F_SKIP_WEIGHT 0x1f54
-#define P_HCODEC_ME_F_SKIP_WEIGHT               \
-	DOS_REG_ADDR(HCODEC_ME_F_SKIP_WEIGHT)
-#define HCODEC_ME_MV_MERGE_CTL 0x1f55
-#define P_HCODEC_ME_MV_MERGE_CTL                \
-	DOS_REG_ADDR(HCODEC_ME_MV_MERGE_CTL)
-#define HCODEC_ME_MV_WEIGHT_01 0x1f56
-#define P_HCODEC_ME_MV_WEIGHT_01                \
-	DOS_REG_ADDR(HCODEC_ME_MV_WEIGHT_01)
-#define HCODEC_ME_MV_WEIGHT_23 0x1f57
-#define P_HCODEC_ME_MV_WEIGHT_23                \
-	DOS_REG_ADDR(HCODEC_ME_MV_WEIGHT_23)
-#define HCODEC_ME_SAD_RANGE_INC 0x1f58
-#define P_HCODEC_ME_SAD_RANGE_INC               \
-	DOS_REG_ADDR(HCODEC_ME_SAD_RANGE_INC)
-#define HCODEC_ME_SUB_MERGE_CTL 0x1f59
-#define P_HCODEC_ME_SUB_MERGE_CTL               \
-	DOS_REG_ADDR(HCODEC_ME_SUB_MERGE_CTL)
-#define HCODEC_ME_SUB_REF_MV_CTL 0x1f5a
-#define P_HCODEC_ME_SUB_REF_MV_CTL              \
-	DOS_REG_ADDR(HCODEC_ME_SUB_REF_MV_CTL)
-#define HCODEC_ME_SUB_ANY_WEIGHT_SAD 0x1f5b
-#define P_HCODEC_ME_SUB_ANY_WEIGHT_SAD          \
-	DOS_REG_ADDR(HCODEC_ME_SUB_ANY_WEIGHT_SAD)
-#define HCODEC_ME_SUB_FIX_SAD 0x1f5c
-#define P_HCODEC_ME_SUB_FIX_SAD                 \
-	DOS_REG_ADDR(HCODEC_ME_SUB_FIX_SAD)
-#define HCODEC_ME_SUB_FIX_MIN_SAD 0x1f5d
-#define P_HCODEC_ME_SUB_FIX_MIN_SAD             \
-	DOS_REG_ADDR(HCODEC_ME_SUB_FIX_MIN_SAD)
-#define HCODEC_ME_SUB_SNAP_GLITCH 0x1f5e
-#define P_HCODEC_ME_SUB_SNAP_GLITCH             \
-	DOS_REG_ADDR(HCODEC_ME_SUB_SNAP_GLITCH)
-#define HCODEC_ME_SUB_ACT_CTL 0x1f5f
-#define P_HCODEC_ME_SUB_ACT_CTL                 \
-	DOS_REG_ADDR(HCODEC_ME_SUB_ACT_CTL)
-#define AO_RTI_STATUS_REG0 ((0x00 << 10) | (0x00 << 2))
-#define P_AO_RTI_STATUS_REG0            AOBUS_REG_ADDR(AO_RTI_STATUS_REG0)
-#define AO_RTI_STATUS_REG1 ((0x00 << 10) | (0x01 << 2))
-#define P_AO_RTI_STATUS_REG1            AOBUS_REG_ADDR(AO_RTI_STATUS_REG1)
-#define AO_RTI_STATUS_REG2 ((0x00 << 10) | (0x02 << 2))
-#define P_AO_RTI_STATUS_REG2            AOBUS_REG_ADDR(AO_RTI_STATUS_REG2)
-#define AO_RTI_PWR_CNTL_REG1 ((0x00 << 10) | (0x03 << 2))
-#define P_AO_RTI_PWR_CNTL_REG1          AOBUS_REG_ADDR(AO_RTI_PWR_CNTL_REG1)
-#define AO_RTI_PWR_CNTL_REG0 ((0x00 << 10) | (0x04 << 2))
-#define P_AO_RTI_PWR_CNTL_REG0          AOBUS_REG_ADDR(AO_RTI_PWR_CNTL_REG0)
-#define AO_RTI_PIN_MUX_REG ((0x00 << 10) | (0x05 << 2))
-#define P_AO_RTI_PIN_MUX_REG            AOBUS_REG_ADDR(AO_RTI_PIN_MUX_REG)
-#define AO_WD_GPIO_REG ((0x00 << 10) | (0x06 << 2))
-#define P_AO_WD_GPIO_REG                AOBUS_REG_ADDR(AO_WD_GPIO_REG)
-#define AO_REMAP_REG0 ((0x00 << 10) | (0x07 << 2))
-#define P_AO_REMAP_REG0                 AOBUS_REG_ADDR(AO_REMAP_REG0)
-#define AO_REMAP_REG1 ((0x00 << 10) | (0x08 << 2))
-#define P_AO_REMAP_REG1                 AOBUS_REG_ADDR(AO_REMAP_REG1)
-#define AO_GPIO_O_EN_N ((0x00 << 10) | (0x09 << 2))
-#define P_AO_GPIO_O_EN_N                AOBUS_REG_ADDR(AO_GPIO_O_EN_N)
-#define AO_GPIO_I ((0x00 << 10) | (0x0A << 2))
-#define P_AO_GPIO_I             AOBUS_REG_ADDR(AO_GPIO_I)
-#define AO_RTI_PULL_UP_REG ((0x00 << 10) | (0x0B << 2))
-#define P_AO_RTI_PULL_UP_REG            AOBUS_REG_ADDR(AO_RTI_PULL_UP_REG)
-#define AO_RTI_WD_MARK ((0x00 << 10) | (0x0D << 2))
-#define P_AO_RTI_WD_MARK                AOBUS_REG_ADDR(AO_RTI_WD_MARK)
-#define AO_CPU_CNTL ((0x00 << 10) | (0x0E << 2))
-#define P_AO_CPU_CNTL           AOBUS_REG_ADDR(AO_CPU_CNTL)
-#define AO_CPU_STAT ((0x00 << 10) | (0x0F << 2))
-#define P_AO_CPU_STAT           AOBUS_REG_ADDR(AO_CPU_STAT)
-#define AO_RTI_GEN_CNTL_REG0 ((0x00 << 10) | (0x10 << 2))
-#define P_AO_RTI_GEN_CNTL_REG0          AOBUS_REG_ADDR(AO_RTI_GEN_CNTL_REG0)
-#define AO_WATCHDOG_REG ((0x00 << 10) | (0x11 << 2))
-#define P_AO_WATCHDOG_REG               AOBUS_REG_ADDR(AO_WATCHDOG_REG)
-#define AO_WATCHDOG_RESET ((0x00 << 10) | (0x12 << 2))
-#define P_AO_WATCHDOG_RESET             AOBUS_REG_ADDR(AO_WATCHDOG_RESET)
-#define AO_TIMER_REG ((0x00 << 10) | (0x13 << 2))
-#define P_AO_TIMER_REG          AOBUS_REG_ADDR(AO_TIMER_REG)
-#define AO_TIMERA_REG ((0x00 << 10) | (0x14 << 2))
-#define P_AO_TIMERA_REG                 AOBUS_REG_ADDR(AO_TIMERA_REG)
-#define AO_TIMERE_REG ((0x00 << 10) | (0x15 << 2))
-#define P_AO_TIMERE_REG                 AOBUS_REG_ADDR(AO_TIMERE_REG)
-#define AO_AHB2DDR_CNTL ((0x00 << 10) | (0x18 << 2))
-#define P_AO_AHB2DDR_CNTL               AOBUS_REG_ADDR(AO_AHB2DDR_CNTL)
-#define AO_IRQ_MASK_FIQ_SEL ((0x00 << 10) | (0x20 << 2))
-#define P_AO_IRQ_MASK_FIQ_SEL           AOBUS_REG_ADDR(AO_IRQ_MASK_FIQ_SEL)
-#define AO_IRQ_GPIO_REG ((0x00 << 10) | (0x21 << 2))
-#define P_AO_IRQ_GPIO_REG               AOBUS_REG_ADDR(AO_IRQ_GPIO_REG)
-#define AO_IRQ_STAT ((0x00 << 10) | (0x22 << 2))
-#define P_AO_IRQ_STAT           AOBUS_REG_ADDR(AO_IRQ_STAT)
-#define AO_IRQ_STAT_CLR ((0x00 << 10) | (0x23 << 2))
-#define P_AO_IRQ_STAT_CLR               AOBUS_REG_ADDR(AO_IRQ_STAT_CLR)
-#define AO_DEBUG_REG0 ((0x00 << 10) | (0x28 << 2))
-#define P_AO_DEBUG_REG0                 AOBUS_REG_ADDR(AO_DEBUG_REG0)
-#define AO_DEBUG_REG1 ((0x00 << 10) | (0x29 << 2))
-#define P_AO_DEBUG_REG1                 AOBUS_REG_ADDR(AO_DEBUG_REG1)
-#define AO_DEBUG_REG2 ((0x00 << 10) | (0x2a << 2))
-#define P_AO_DEBUG_REG2                 AOBUS_REG_ADDR(AO_DEBUG_REG2)
-#define AO_DEBUG_REG3 ((0x00 << 10) | (0x2b << 2))
-#define P_AO_DEBUG_REG3                 AOBUS_REG_ADDR(AO_DEBUG_REG3)
-#define AO_IR_BLASTER_ADDR0 ((0x00 << 10) | (0x30 << 2))
-#define P_AO_IR_BLASTER_ADDR0           AOBUS_REG_ADDR(AO_IR_BLASTER_ADDR0)
-#define AO_IR_BLASTER_ADDR1 ((0x00 << 10) | (0x31 << 2))
-#define P_AO_IR_BLASTER_ADDR1           AOBUS_REG_ADDR(AO_IR_BLASTER_ADDR1)
-#define AO_IR_BLASTER_ADDR2 ((0x00 << 10) | (0x32 << 2))
-#define P_AO_IR_BLASTER_ADDR2           AOBUS_REG_ADDR(AO_IR_BLASTER_ADDR2)
-/*add from M8M2*/
-#define AO_JTAG_TRIGGER_CNTL ((0x00 << 10) | (0x34 << 2))
-#define P_AO_JTAG_TRIGGER_CNTL          AOBUS_REG_ADDR(AO_JTAG_TRIGGER_CNTL)
-/**/
-#define AO_RTI_PWR_A9_CNTL0 ((0x00 << 10) | (0x38 << 2))
-#define P_AO_RTI_PWR_A9_CNTL0           AOBUS_REG_ADDR(AO_RTI_PWR_A9_CNTL0)
-#define AO_RTI_PWR_A9_CNTL1 ((0x00 << 10) | (0x39 << 2))
-#define P_AO_RTI_PWR_A9_CNTL1           AOBUS_REG_ADDR(AO_RTI_PWR_A9_CNTL1)
-#define AO_RTI_GEN_PWR_SLEEP0 ((0x00 << 10) | (0x3a << 2))
-#define P_AO_RTI_GEN_PWR_SLEEP0                 \
-	AOBUS_REG_ADDR(AO_RTI_GEN_PWR_SLEEP0)
-#define AO_RTI_GEN_PWR_ISO0 ((0x00 << 10) | (0x3b << 2))
-#define P_AO_RTI_GEN_PWR_ISO0           AOBUS_REG_ADDR(AO_RTI_GEN_PWR_ISO0)
-#define AO_CEC_GEN_CNTL ((0x00 << 10) | (0x40 << 2))
-#define P_AO_CEC_GEN_CNTL               AOBUS_REG_ADDR(AO_CEC_GEN_CNTL)
-#define AO_CEC_RW_REG ((0x00 << 10) | (0x41 << 2))
-#define P_AO_CEC_RW_REG                 AOBUS_REG_ADDR(AO_CEC_RW_REG)
-#define AO_CEC_INTR_MASKN ((0x00 << 10) | (0x42 << 2))
-#define P_AO_CEC_INTR_MASKN             AOBUS_REG_ADDR(AO_CEC_INTR_MASKN)
-#define AO_CEC_INTR_CLR ((0x00 << 10) | (0x43 << 2))
-#define P_AO_CEC_INTR_CLR               AOBUS_REG_ADDR(AO_CEC_INTR_CLR)
-#define AO_CEC_INTR_STAT ((0x00 << 10) | (0x44 << 2))
-#define P_AO_CEC_INTR_STAT              AOBUS_REG_ADDR(AO_CEC_INTR_STAT)
-#define AO_IR_DEC_LDR_ACTIVE ((0x01 << 10) | (0x20 << 2))
-#define P_AO_IR_DEC_LDR_ACTIVE          AOBUS_REG_ADDR(AO_IR_DEC_LDR_ACTIVE)
-#define AO_IR_DEC_LDR_IDLE ((0x01 << 10) | (0x21 << 2))
-#define P_AO_IR_DEC_LDR_IDLE            AOBUS_REG_ADDR(AO_IR_DEC_LDR_IDLE)
-#define AO_IR_DEC_LDR_REPEAT ((0x01 << 10) | (0x22 << 2))
-#define P_AO_IR_DEC_LDR_REPEAT          AOBUS_REG_ADDR(AO_IR_DEC_LDR_REPEAT)
-#define AO_IR_DEC_BIT_0 ((0x01 << 10) | (0x23 << 2))
-#define P_AO_IR_DEC_BIT_0               AOBUS_REG_ADDR(AO_IR_DEC_BIT_0)
-#define AO_IR_DEC_REG0 ((0x01 << 10) | (0x24 << 2))
-#define P_AO_IR_DEC_REG0                AOBUS_REG_ADDR(AO_IR_DEC_REG0)
-#define AO_IR_DEC_FRAME ((0x01 << 10) | (0x25 << 2))
-#define P_AO_IR_DEC_FRAME               AOBUS_REG_ADDR(AO_IR_DEC_FRAME)
-#define AO_IR_DEC_STATUS ((0x01 << 10) | (0x26 << 2))
-#define P_AO_IR_DEC_STATUS              AOBUS_REG_ADDR(AO_IR_DEC_STATUS)
-#define AO_IR_DEC_REG1 ((0x01 << 10) | (0x27 << 2))
-#define P_AO_IR_DEC_REG1                AOBUS_REG_ADDR(AO_IR_DEC_REG1)
-#define AO_UART_WFIFO ((0x01 << 10) | (0x30 << 2))
-#define P_AO_UART_WFIFO                 AOBUS_REG_ADDR(AO_UART_WFIFO)
-#define AO_UART_RFIFO ((0x01 << 10) | (0x31 << 2))
-#define P_AO_UART_RFIFO                 AOBUS_REG_ADDR(AO_UART_RFIFO)
-#define AO_UART_CONTROL ((0x01 << 10) | (0x32 << 2))
-#define P_AO_UART_CONTROL               AOBUS_REG_ADDR(AO_UART_CONTROL)
-#define AO_UART_STATUS ((0x01 << 10) | (0x33 << 2))
-#define P_AO_UART_STATUS                AOBUS_REG_ADDR(AO_UART_STATUS)
-#define AO_UART_MISC ((0x01 << 10) | (0x34 << 2))
-#define P_AO_UART_MISC          AOBUS_REG_ADDR(AO_UART_MISC)
-#define AO_UART_REG5 ((0x01 << 10) | (0x35 << 2))
-#define P_AO_UART_REG5          AOBUS_REG_ADDR(AO_UART_REG5)
-#define AO_UART2_WFIFO ((0x01 << 10) | (0x38 << 2))
-#define P_AO_UART2_WFIFO                AOBUS_REG_ADDR(AO_UART2_WFIFO)
-#define AO_UART2_RFIFO ((0x01 << 10) | (0x39 << 2))
-#define P_AO_UART2_RFIFO                AOBUS_REG_ADDR(AO_UART2_RFIFO)
-#define AO_UART2_CONTROL ((0x01 << 10) | (0x3a << 2))
-#define P_AO_UART2_CONTROL              AOBUS_REG_ADDR(AO_UART2_CONTROL)
-#define AO_UART2_STATUS ((0x01 << 10) | (0x3b << 2))
-#define P_AO_UART2_STATUS               AOBUS_REG_ADDR(AO_UART2_STATUS)
-#define AO_UART2_MISC ((0x01 << 10) | (0x3c << 2))
-#define P_AO_UART2_MISC                 AOBUS_REG_ADDR(AO_UART2_MISC)
-#define AO_UART2_REG5 ((0x01 << 10) | (0x3d << 2))
-#define P_AO_UART2_REG5                 AOBUS_REG_ADDR(AO_UART2_REG5)
-#define AO_I2C_M_0_CONTROL_REG ((0x01 << 10) | (0x40 << 2))
-#define P_AO_I2C_M_0_CONTROL_REG                \
-	AOBUS_REG_ADDR(AO_I2C_M_0_CONTROL_REG)
-#define AO_I2C_M_0_SLAVE_ADDR ((0x01 << 10) | (0x41 << 2))
-#define P_AO_I2C_M_0_SLAVE_ADDR                 \
-	AOBUS_REG_ADDR(AO_I2C_M_0_SLAVE_ADDR)
-#define AO_I2C_M_0_TOKEN_LIST0 ((0x01 << 10) | (0x42 << 2))
-#define P_AO_I2C_M_0_TOKEN_LIST0                \
-	AOBUS_REG_ADDR(AO_I2C_M_0_TOKEN_LIST0)
-#define AO_I2C_M_0_TOKEN_LIST1 ((0x01 << 10) | (0x43 << 2))
-#define P_AO_I2C_M_0_TOKEN_LIST1                \
-	AOBUS_REG_ADDR(AO_I2C_M_0_TOKEN_LIST1)
-#define AO_I2C_M_0_WDATA_REG0 ((0x01 << 10) | (0x44 << 2))
-#define P_AO_I2C_M_0_WDATA_REG0                 \
-	AOBUS_REG_ADDR(AO_I2C_M_0_WDATA_REG0)
-#define AO_I2C_M_0_WDATA_REG1 ((0x01 << 10) | (0x45 << 2))
-#define P_AO_I2C_M_0_WDATA_REG1                 \
-	AOBUS_REG_ADDR(AO_I2C_M_0_WDATA_REG1)
-#define AO_I2C_M_0_RDATA_REG0 ((0x01 << 10) | (0x46 << 2))
-#define P_AO_I2C_M_0_RDATA_REG0                 \
-	AOBUS_REG_ADDR(AO_I2C_M_0_RDATA_REG0)
-#define AO_I2C_M_0_RDATA_REG1 ((0x01 << 10) | (0x47 << 2))
-#define P_AO_I2C_M_0_RDATA_REG1                 \
-	AOBUS_REG_ADDR(AO_I2C_M_0_RDATA_REG1)
-#define AO_I2C_S_CONTROL_REG ((0x01 << 10) | (0x50 << 2))
-#define P_AO_I2C_S_CONTROL_REG          AOBUS_REG_ADDR(AO_I2C_S_CONTROL_REG)
-#define AO_I2C_S_SEND_REG ((0x01 << 10) | (0x51 << 2))
-#define P_AO_I2C_S_SEND_REG             AOBUS_REG_ADDR(AO_I2C_S_SEND_REG)
-#define AO_I2C_S_RECV_REG ((0x01 << 10) | (0x52 << 2))
-#define P_AO_I2C_S_RECV_REG             AOBUS_REG_ADDR(AO_I2C_S_RECV_REG)
-#define AO_I2C_S_CNTL1_REG ((0x01 << 10) | (0x53 << 2))
-#define P_AO_I2C_S_CNTL1_REG            AOBUS_REG_ADDR(AO_I2C_S_CNTL1_REG)
-#define AO_RTC_ADDR0 ((0x01 << 10) | (0xd0 << 2))
-#define P_AO_RTC_ADDR0          AOBUS_REG_ADDR(AO_RTC_ADDR0)
-#define AO_RTC_ADDR1 ((0x01 << 10) | (0xd1 << 2))
-#define P_AO_RTC_ADDR1          AOBUS_REG_ADDR(AO_RTC_ADDR1)
-#define AO_RTC_ADDR2 ((0x01 << 10) | (0xd2 << 2))
-#define P_AO_RTC_ADDR2          AOBUS_REG_ADDR(AO_RTC_ADDR2)
-#define AO_RTC_ADDR3 ((0x01 << 10) | (0xd3 << 2))
-#define P_AO_RTC_ADDR3          AOBUS_REG_ADDR(AO_RTC_ADDR3)
-#define AO_RTC_ADDR4 ((0x01 << 10) | (0xd4 << 2))
-#define P_AO_RTC_ADDR4          AOBUS_REG_ADDR(AO_RTC_ADDR4)
-#define AO_MF_IR_DEC_LDR_ACTIVE ((0x01 << 10) | (0x60 << 2))
-#define P_AO_MF_IR_DEC_LDR_ACTIVE               \
-	AOBUS_REG_ADDR(AO_MF_IR_DEC_LDR_ACTIVE)
-#define AO_MF_IR_DEC_LDR_IDLE ((0x01 << 10) | (0x61 << 2))
-#define P_AO_MF_IR_DEC_LDR_IDLE                 \
-	AOBUS_REG_ADDR(AO_MF_IR_DEC_LDR_IDLE)
-#define AO_MF_IR_DEC_LDR_REPEAT ((0x01 << 10) | (0x62 << 2))
-#define P_AO_MF_IR_DEC_LDR_REPEAT               \
-	AOBUS_REG_ADDR(AO_MF_IR_DEC_LDR_REPEAT)
-#define AO_MF_IR_DEC_BIT_0 ((0x01 << 10) | (0x63 << 2))
-#define P_AO_MF_IR_DEC_BIT_0            AOBUS_REG_ADDR(AO_MF_IR_DEC_BIT_0)
-#define AO_MF_IR_DEC_REG0 ((0x01 << 10) | (0x64 << 2))
-#define P_AO_MF_IR_DEC_REG0             AOBUS_REG_ADDR(AO_MF_IR_DEC_REG0)
-#define AO_MF_IR_DEC_FRAME ((0x01 << 10) | (0x65 << 2))
-#define P_AO_MF_IR_DEC_FRAME            AOBUS_REG_ADDR(AO_MF_IR_DEC_FRAME)
-#define AO_MF_IR_DEC_STATUS ((0x01 << 10) | (0x66 << 2))
-#define P_AO_MF_IR_DEC_STATUS           AOBUS_REG_ADDR(AO_MF_IR_DEC_STATUS)
-#define AO_MF_IR_DEC_REG1 ((0x01 << 10) | (0x67 << 2))
-#define P_AO_MF_IR_DEC_REG1             AOBUS_REG_ADDR(AO_MF_IR_DEC_REG1)
-#define AO_MF_IR_DEC_REG2 ((0x01 << 10) | (0x68 << 2))
-#define P_AO_MF_IR_DEC_REG2             AOBUS_REG_ADDR(AO_MF_IR_DEC_REG2)
-#define AO_MF_IR_DEC_DURATN2 ((0x01 << 10) | (0x69 << 2))
-#define P_AO_MF_IR_DEC_DURATN2          AOBUS_REG_ADDR(AO_MF_IR_DEC_DURATN2)
-#define AO_MF_IR_DEC_DURATN3 ((0x01 << 10) | (0x6a << 2))
-#define P_AO_MF_IR_DEC_DURATN3          AOBUS_REG_ADDR(AO_MF_IR_DEC_DURATN3)
-#define AO_MF_IR_DEC_FRAME1 ((0x01 << 10) | (0x6b << 2))
-#define P_AO_MF_IR_DEC_FRAME1           AOBUS_REG_ADDR(AO_MF_IR_DEC_FRAME1)
-#define AM_DDR_PLL_CNTL 0x0400
-#define P_AM_DDR_PLL_CNTL               MMC_REG_ADDR(AM_DDR_PLL_CNTL)
-#define AM_DDR_PLL_CNTL1 0x0404
-#define P_AM_DDR_PLL_CNTL1              MMC_REG_ADDR(AM_DDR_PLL_CNTL1)
-#define AM_DDR_PLL_CNTL2 0x0408
-#define P_AM_DDR_PLL_CNTL2              MMC_REG_ADDR(AM_DDR_PLL_CNTL2)
-#define AM_DDR_PLL_CNTL3 0x040c
-#define P_AM_DDR_PLL_CNTL3              MMC_REG_ADDR(AM_DDR_PLL_CNTL3)
-#define AM_DDR_PLL_CNTL4 0x0410
-#define P_AM_DDR_PLL_CNTL4              MMC_REG_ADDR(AM_DDR_PLL_CNTL4)
-#define AM_DDR_PLL_STS 0x0414
-#define P_AM_DDR_PLL_STS                MMC_REG_ADDR(AM_DDR_PLL_STS)
-#define AM_DDR_CLK_CNTL 0x0418
-#define P_AM_DDR_CLK_CNTL               MMC_REG_ADDR(AM_DDR_CLK_CNTL)
-#define DDR0_PCTL_SCFG 0x0000
-#define P_DDR0_PCTL_SCFG                MMC_REG_ADDR(DDR0_PCTL_SCFG)
-#define DDR0_PCTL_SCTL 0x0004
-#define P_DDR0_PCTL_SCTL                MMC_REG_ADDR(DDR0_PCTL_SCTL)
-#define DDR0_PCTL_STAT 0x0008
-#define P_DDR0_PCTL_STAT                MMC_REG_ADDR(DDR0_PCTL_STAT)
-#define DDR0_PCTL_INTRSTAT 0x000c
-#define P_DDR0_PCTL_INTRSTAT            MMC_REG_ADDR(DDR0_PCTL_INTRSTAT)
-#define DDR0_PCTL_POWSTAT 0x0048
-#define P_DDR0_PCTL_POWSTAT             MMC_REG_ADDR(DDR0_PCTL_POWSTAT)
-#define DDR0_PCTL_MRRSTAT0 0x0064
-#define P_DDR0_PCTL_MRRSTAT0            MMC_REG_ADDR(DDR0_PCTL_MRRSTAT0)
-#define DDR0_PCTL_CMDTSTAT 0x004c
-#define P_DDR0_PCTL_CMDTSTAT            MMC_REG_ADDR(DDR0_PCTL_CMDTSTAT)
-#define DDR0_PCTL_MCMD 0x0040
-#define P_DDR0_PCTL_MCMD                MMC_REG_ADDR(DDR0_PCTL_MCMD)
-#define DDR0_PCTL_MRRSTAT1 0x0068
-#define P_DDR0_PCTL_MRRSTAT1            MMC_REG_ADDR(DDR0_PCTL_MRRSTAT1)
-#define DDR0_PCTL_MRRCFG0 0x0060
-#define P_DDR0_PCTL_MRRCFG0             MMC_REG_ADDR(DDR0_PCTL_MRRCFG0)
-#define DDR0_PCTL_CMDTSTATEN 0x0050
-#define P_DDR0_PCTL_CMDTSTATEN          MMC_REG_ADDR(DDR0_PCTL_CMDTSTATEN)
-#define DDR0_PCTL_POWCTL 0x0044
-#define P_DDR0_PCTL_POWCTL              MMC_REG_ADDR(DDR0_PCTL_POWCTL)
-#define DDR0_PCTL_PPCFG 0x0084
-#define P_DDR0_PCTL_PPCFG               MMC_REG_ADDR(DDR0_PCTL_PPCFG)
-#define DDR0_PCTL_MCFG1 0x007c
-#define P_DDR0_PCTL_MCFG1               MMC_REG_ADDR(DDR0_PCTL_MCFG1)
-#define DDR0_PCTL_MSTAT 0x0088
-#define P_DDR0_PCTL_MSTAT               MMC_REG_ADDR(DDR0_PCTL_MSTAT)
-#define DDR0_PCTL_MCFG 0x0080
-#define P_DDR0_PCTL_MCFG                MMC_REG_ADDR(DDR0_PCTL_MCFG)
-#define DDR0_PCTL_DTUAWDT 0x00b0
-#define P_DDR0_PCTL_DTUAWDT             MMC_REG_ADDR(DDR0_PCTL_DTUAWDT)
-#define DDR0_PCTL_DTUPRD2 0x00a8
-#define P_DDR0_PCTL_DTUPRD2             MMC_REG_ADDR(DDR0_PCTL_DTUPRD2)
-#define DDR0_PCTL_DTUPRD3 0x00ac
-#define P_DDR0_PCTL_DTUPRD3             MMC_REG_ADDR(DDR0_PCTL_DTUPRD3)
-#define DDR0_PCTL_DTUNE 0x009c
-#define P_DDR0_PCTL_DTUNE               MMC_REG_ADDR(DDR0_PCTL_DTUNE)
-#define DDR0_PCTL_DTUPDES 0x0094
-#define P_DDR0_PCTL_DTUPDES             MMC_REG_ADDR(DDR0_PCTL_DTUPDES)
-#define DDR0_PCTL_DTUNA 0x0098
-#define P_DDR0_PCTL_DTUNA               MMC_REG_ADDR(DDR0_PCTL_DTUNA)
-#define DDR0_PCTL_DTUPRD0 0x00a0
-#define P_DDR0_PCTL_DTUPRD0             MMC_REG_ADDR(DDR0_PCTL_DTUPRD0)
-#define DDR0_PCTL_DTUPRD1 0x00a4
-#define P_DDR0_PCTL_DTUPRD1             MMC_REG_ADDR(DDR0_PCTL_DTUPRD1)
-#define DDR0_PCTL_TCKSRE 0x0124
-#define P_DDR0_PCTL_TCKSRE              MMC_REG_ADDR(DDR0_PCTL_TCKSRE)
-#define DDR0_PCTL_TZQCSI 0x011c
-#define P_DDR0_PCTL_TZQCSI              MMC_REG_ADDR(DDR0_PCTL_TZQCSI)
-#define DDR0_PCTL_TINIT 0x00c4
-#define P_DDR0_PCTL_TINIT               MMC_REG_ADDR(DDR0_PCTL_TINIT)
-#define DDR0_PCTL_TDPD 0x0144
-#define P_DDR0_PCTL_TDPD                MMC_REG_ADDR(DDR0_PCTL_TDPD)
-#define DDR0_PCTL_TOGCNT1U 0x00c0
-#define P_DDR0_PCTL_TOGCNT1U            MMC_REG_ADDR(DDR0_PCTL_TOGCNT1U)
-#define DDR0_PCTL_TCKE 0x012c
-#define P_DDR0_PCTL_TCKE                MMC_REG_ADDR(DDR0_PCTL_TCKE)
-#define DDR0_PCTL_TMOD 0x0130
-#define P_DDR0_PCTL_TMOD                MMC_REG_ADDR(DDR0_PCTL_TMOD)
-#define DDR0_PCTL_TEXSR 0x010c
-#define P_DDR0_PCTL_TEXSR               MMC_REG_ADDR(DDR0_PCTL_TEXSR)
-#define DDR0_PCTL_TAL 0x00e4
-#define P_DDR0_PCTL_TAL                 MMC_REG_ADDR(DDR0_PCTL_TAL)
-#define DDR0_PCTL_TRTP 0x0100
-#define P_DDR0_PCTL_TRTP                MMC_REG_ADDR(DDR0_PCTL_TRTP)
-#define DDR0_PCTL_TCKSRX 0x0128
-#define P_DDR0_PCTL_TCKSRX              MMC_REG_ADDR(DDR0_PCTL_TCKSRX)
-#define DDR0_PCTL_TRTW 0x00e0
-#define P_DDR0_PCTL_TRTW                MMC_REG_ADDR(DDR0_PCTL_TRTW)
-#define DDR0_PCTL_TCWL 0x00ec
-#define P_DDR0_PCTL_TCWL                MMC_REG_ADDR(DDR0_PCTL_TCWL)
-#define DDR0_PCTL_TWR 0x0104
-#define P_DDR0_PCTL_TWR                 MMC_REG_ADDR(DDR0_PCTL_TWR)
-#define DDR0_PCTL_TCL 0x00e8
-#define P_DDR0_PCTL_TCL                 MMC_REG_ADDR(DDR0_PCTL_TCL)
-#define DDR0_PCTL_TDQS 0x0120
-#define P_DDR0_PCTL_TDQS                MMC_REG_ADDR(DDR0_PCTL_TDQS)
-#define DDR0_PCTL_TRSTH 0x00c8
-#define P_DDR0_PCTL_TRSTH               MMC_REG_ADDR(DDR0_PCTL_TRSTH)
-#define DDR0_PCTL_TRCD 0x00f8
-#define P_DDR0_PCTL_TRCD                MMC_REG_ADDR(DDR0_PCTL_TRCD)
-#define DDR0_PCTL_TXP 0x0110
-#define P_DDR0_PCTL_TXP                 MMC_REG_ADDR(DDR0_PCTL_TXP)
-#define DDR0_PCTL_TOGCNT100N 0x00cc
-#define P_DDR0_PCTL_TOGCNT100N          MMC_REG_ADDR(DDR0_PCTL_TOGCNT100N)
-#define DDR0_PCTL_TMRD 0x00d4
-#define P_DDR0_PCTL_TMRD                MMC_REG_ADDR(DDR0_PCTL_TMRD)
-#define DDR0_PCTL_TRSTL 0x0134
-#define P_DDR0_PCTL_TRSTL               MMC_REG_ADDR(DDR0_PCTL_TRSTL)
-#define DDR0_PCTL_TREFI 0x00d0
-#define P_DDR0_PCTL_TREFI               MMC_REG_ADDR(DDR0_PCTL_TREFI)
-#define DDR0_PCTL_TRAS 0x00f0
-#define P_DDR0_PCTL_TRAS                MMC_REG_ADDR(DDR0_PCTL_TRAS)
-#define DDR0_PCTL_TREFI_MEM_DDR3 0x0148
-#define P_DDR0_PCTL_TWTR                MMC_REG_ADDR(DDR0_PCTL_TWTR)
-#define DDR0_PCTL_TRC 0x00f4
-#define P_DDR0_PCTL_TRC                 MMC_REG_ADDR(DDR0_PCTL_TRC)
-#define DDR0_PCTL_TRFC 0x00d8
-#define P_DDR0_PCTL_TRFC                MMC_REG_ADDR(DDR0_PCTL_TRFC)
-#define DDR0_PCTL_TMRR 0x013c
-#define P_DDR0_PCTL_TMRR                MMC_REG_ADDR(DDR0_PCTL_TMRR)
-#define DDR0_PCTL_TCKESR 0x0140
-#define P_DDR0_PCTL_TCKESR              MMC_REG_ADDR(DDR0_PCTL_TCKESR)
-#define DDR0_PCTL_TZQCL 0x0138
-#define P_DDR0_PCTL_TZQCL               MMC_REG_ADDR(DDR0_PCTL_TZQCL)
-#define DDR0_PCTL_TRRD 0x00fc
-#define P_DDR0_PCTL_TRRD                MMC_REG_ADDR(DDR0_PCTL_TRRD)
-#define DDR0_PCTL_TRP 0x00dc
-#define P_DDR0_PCTL_TRP                 MMC_REG_ADDR(DDR0_PCTL_TRP)
-#define DDR0_PCTL_TZQCS 0x0118
-#define P_DDR0_PCTL_TZQCS               MMC_REG_ADDR(DDR0_PCTL_TZQCS)
-#define DDR0_PCTL_TXPDLL 0x0114
-#define P_DDR0_PCTL_TXPDLL              MMC_REG_ADDR(DDR0_PCTL_TXPDLL)
-#define DDR0_PCTL_ECCCFG 0x0180
-#define P_DDR0_PCTL_ECCCFG              MMC_REG_ADDR(DDR0_PCTL_ECCCFG)
-#define DDR0_PCTL_ECCLOG 0x018c
-#define P_DDR0_PCTL_ECCLOG              MMC_REG_ADDR(DDR0_PCTL_ECCLOG)
-#define DDR0_PCTL_ECCCLR 0x0188
-#define P_DDR0_PCTL_ECCCLR              MMC_REG_ADDR(DDR0_PCTL_ECCCLR)
-#define DDR0_PCTL_ECCTST 0x0184
-#define P_DDR0_PCTL_ECCTST              MMC_REG_ADDR(DDR0_PCTL_ECCTST)
-#define DDR0_PCTL_DTUWD0 0x0210
-#define P_DDR0_PCTL_DTUWD0              MMC_REG_ADDR(DDR0_PCTL_DTUWD0)
-#define DDR0_PCTL_DTUWD1 0x0214
-#define P_DDR0_PCTL_DTUWD1              MMC_REG_ADDR(DDR0_PCTL_DTUWD1)
-#define DDR0_PCTL_DTUWACTL 0x0200
-#define P_DDR0_PCTL_DTUWACTL            MMC_REG_ADDR(DDR0_PCTL_DTUWACTL)
-#define DDR0_PCTL_DTULFSRRD 0x0238
-#define P_DDR0_PCTL_DTULFSRRD           MMC_REG_ADDR(DDR0_PCTL_DTULFSRRD)
-#define DDR0_PCTL_DTUWD2 0x0218
-#define P_DDR0_PCTL_DTUWD2              MMC_REG_ADDR(DDR0_PCTL_DTUWD2)
-#define DDR0_PCTL_DTUWD3 0x021c
-#define P_DDR0_PCTL_DTUWD3              MMC_REG_ADDR(DDR0_PCTL_DTUWD3)
-#define DDR0_PCTL_DTULFSRWD 0x0234
-#define P_DDR0_PCTL_DTULFSRWD           MMC_REG_ADDR(DDR0_PCTL_DTULFSRWD)
-#define DDR0_PCTL_DTURACTL 0x0204
-#define P_DDR0_PCTL_DTURACTL            MMC_REG_ADDR(DDR0_PCTL_DTURACTL)
-#define DDR0_PCTL_DTUWDM 0x0220
-#define P_DDR0_PCTL_DTUWDM              MMC_REG_ADDR(DDR0_PCTL_DTUWDM)
-#define DDR0_PCTL_DTURD0 0x0224
-#define P_DDR0_PCTL_DTURD0              MMC_REG_ADDR(DDR0_PCTL_DTURD0)
-#define DDR0_PCTL_DTURD1 0x0228
-#define P_DDR0_PCTL_DTURD1              MMC_REG_ADDR(DDR0_PCTL_DTURD1)
-#define DDR0_PCTL_DTURD2 0x022c
-#define P_DDR0_PCTL_DTURD2              MMC_REG_ADDR(DDR0_PCTL_DTURD2)
-#define DDR0_PCTL_DTURD3 0x0230
-#define P_DDR0_PCTL_DTURD3              MMC_REG_ADDR(DDR0_PCTL_DTURD3)
-#define DDR0_PCTL_DTUCFG 0x0208
-#define P_DDR0_PCTL_DTUCFG              MMC_REG_ADDR(DDR0_PCTL_DTUCFG)
-#define DDR0_PCTL_DTUEAF 0x023c
-#define P_DDR0_PCTL_DTUEAF              MMC_REG_ADDR(DDR0_PCTL_DTUEAF)
-#define DDR0_PCTL_DTUECTL 0x020c
-#define P_DDR0_PCTL_DTUECTL             MMC_REG_ADDR(DDR0_PCTL_DTUECTL)
-#define DDR0_PCTL_DFIODTCFG1 0x0248
-
-#define DDR0_PCTL_DFITDRAMCLKDIS 0x02d4
-#define P_DDR0_PCTL_DFITDRAMCLKDIS              \
-	MMC_REG_ADDR(DDR0_PCTL_DFITDRAMCLKDIS)
-#define DDR0_PCTL_DFILPCFG0 0x02f0
-#define P_DDR0_PCTL_DFILPCFG0           \
-	MMC_REG_ADDR(DDR0_PCTL_DFILPCFG0)
-#define DDR0_PCTL_DFITRWRLVLDELAY0 0x0318
-#define P_DDR0_PCTL_DFITRWRLVLDELAY0            \
-	MMC_REG_ADDR(DDR0_PCTL_DFITRWRLVLDELAY0)
-#define DDR0_PCTL_DFITRWRLVLDELAY1 0x031c
-#define P_DDR0_PCTL_DFITRWRLVLDELAY1            \
-	MMC_REG_ADDR(DDR0_PCTL_DFITRWRLVLDELAY1)
-#define DDR0_PCTL_DFITRWRLVLDELAY2 0x0320
-#define P_DDR0_PCTL_DFITRWRLVLDELAY2            \
-	MMC_REG_ADDR(DDR0_PCTL_DFITRWRLVLDELAY2)
-#define DDR0_PCTL_DFITRRDLVLRESP0 0x030c
-#define P_DDR0_PCTL_DFITRRDLVLRESP0             \
-	MMC_REG_ADDR(DDR0_PCTL_DFITRRDLVLRESP0)
-#define DDR0_PCTL_DFITRRDLVLRESP1 0x0310
-#define P_DDR0_PCTL_DFITRRDLVLRESP1             \
-	MMC_REG_ADDR(DDR0_PCTL_DFITRRDLVLRESP1)
-#define DDR0_PCTL_DFITRRDLVLRESP2 0x0314
-#define P_DDR0_PCTL_DFITRRDLVLRESP2             \
-	MMC_REG_ADDR(DDR0_PCTL_DFITRRDLVLRESP2)
-#define DDR0_PCTL_DFITRWRLVLRESP0 0x0300
-#define P_DDR0_PCTL_DFITRWRLVLRESP0             \
-	MMC_REG_ADDR(DDR0_PCTL_DFITRWRLVLRESP0)
-#define DDR0_PCTL_DFITRRDLVLDELAY0 0x0324
-#define P_DDR0_PCTL_DFITRRDLVLDELAY0            \
-	MMC_REG_ADDR(DDR0_PCTL_DFITRRDLVLDELAY0)
-#define DDR0_PCTL_DFITRRDLVLDELAY1 0x0328
-#define P_DDR0_PCTL_DFITRRDLVLDELAY1            \
-	MMC_REG_ADDR(DDR0_PCTL_DFITRRDLVLDELAY1)
-#define DDR0_PCTL_DFITRWRLVLRESP1 0x0304
-#define P_DDR0_PCTL_DFITRWRLVLRESP1             \
-	MMC_REG_ADDR(DDR0_PCTL_DFITRWRLVLRESP1)
-#define DDR0_PCTL_DFITRRDLVLDELAY2 0x032c
-#define P_DDR0_PCTL_DFITRRDLVLDELAY2            \
-	MMC_REG_ADDR(DDR0_PCTL_DFITRRDLVLDELAY2)
-#define DDR0_PCTL_DFITRWRLVLRESP2 0x0308
-#define P_DDR0_PCTL_DFITRWRLVLRESP2             \
-	MMC_REG_ADDR(DDR0_PCTL_DFITRWRLVLRESP2)
-#define DDR0_PCTL_DFITRRDLVLGATEDELAY0 0x0330
-#define P_DDR0_PCTL_DFITRRDLVLGATEDELAY0                \
-	MMC_REG_ADDR(DDR0_PCTL_DFITRRDLVLGATEDELAY0)
-#define DDR0_PCTL_DFITRCMD 0x033c
-#define P_DDR0_PCTL_DFITRCMD            MMC_REG_ADDR(DDR0_PCTL_DFITRCMD)
-#define DDR0_PCTL_DFITRRDLVLGATEDELAY1 0x0334
-#define P_DDR0_PCTL_DFITRRDLVLGATEDELAY1                \
-	MMC_REG_ADDR(DDR0_PCTL_DFITRRDLVLGATEDELAY1)
-#define DDR0_PCTL_DFITRRDLVLGATEDELAY2 0x0338
-#define P_DDR0_PCTL_DFITRRDLVLGATEDELAY2                \
-	MMC_REG_ADDR(DDR0_PCTL_DFITRRDLVLGATEDELAY2)
-#define DDR0_PCTL_IPTR 0x03fc
-#define P_DDR0_PCTL_IPTR                MMC_REG_ADDR(DDR0_PCTL_IPTR)
-#define DDR0_PCTL_IPVR 0x03f8
-#define P_DDR0_PCTL_IPVR                MMC_REG_ADDR(DDR0_PCTL_IPVR)
-#define DDR0_PUB_RIDR (0x1000 + (0x00 << 2))
-#define P_DDR0_PUB_RIDR                 MMC_REG_ADDR(DDR0_PUB_RIDR)
-#define DDR0_PUB_PIR (0x1000 + (0x01 << 2))
-#define P_DDR0_PUB_PIR          MMC_REG_ADDR(DDR0_PUB_PIR)
-#define DDR0_PUB_PGCR0 (0x1000 + (0x02 << 2))
-#define P_DDR0_PUB_PGCR0                MMC_REG_ADDR(DDR0_PUB_PGCR0)
-#define DDR0_PUB_PGCR1 (0x1000 + (0x03 << 2))
-#define P_DDR0_PUB_PGCR1                MMC_REG_ADDR(DDR0_PUB_PGCR1)
-#define DDR0_PUB_PGCR2 (0x1000 + (0x04 << 2))
-#define P_DDR0_PUB_PGCR2                MMC_REG_ADDR(DDR0_PUB_PGCR2)
-#define DDR0_PUB_PGCR3 (0x1000 + (0x05 << 2))
-#define P_DDR0_PUB_PGCR3                MMC_REG_ADDR(DDR0_PUB_PGCR3)
-#define DDR0_PUB_PGSR0 (0x1000 + (0x06 << 2))
-#define P_DDR0_PUB_PGSR0                MMC_REG_ADDR(DDR0_PUB_PGSR0)
-#define DDR0_PUB_PGSR1 (0x1000 + (0x07 << 2))
-#define P_DDR0_PUB_PGSR1                MMC_REG_ADDR(DDR0_PUB_PGSR1)
-#define DDR0_PUB_PLLCR (0x1000 + (0x08 << 2))
-#define P_DDR0_PUB_PLLCR                MMC_REG_ADDR(DDR0_PUB_PLLCR)
-#define DDR0_PUB_PTR0 (0x1000 + (0x09 << 2))
-#define P_DDR0_PUB_PTR0                 MMC_REG_ADDR(DDR0_PUB_PTR0)
-#define DDR0_PUB_PTR1 (0x1000 + (0x0A << 2))
-#define P_DDR0_PUB_PTR1                 MMC_REG_ADDR(DDR0_PUB_PTR1)
-#define DDR0_PUB_PTR2 (0x1000 + (0x0B << 2))
-#define P_DDR0_PUB_PTR2                 MMC_REG_ADDR(DDR0_PUB_PTR2)
-#define DDR0_PUB_PTR3 (0x1000 + (0x0C << 2))
-#define P_DDR0_PUB_PTR3                 MMC_REG_ADDR(DDR0_PUB_PTR3)
-#define DDR0_PUB_PTR4 (0x1000 + (0x0D << 2))
-#define P_DDR0_PUB_PTR4                 MMC_REG_ADDR(DDR0_PUB_PTR4)
-#define DDR0_PUB_ACMDLR (0x1000 + (0x0E << 2))
-#define P_DDR0_PUB_ACMDLR               MMC_REG_ADDR(DDR0_PUB_ACMDLR)
-#define DDR0_PUB_ACLCDLR (0x1000 + (0x0F << 2))
-#define P_DDR0_PUB_ACLCDLR              MMC_REG_ADDR(DDR0_PUB_ACLCDLR)
-#define DDR0_PUB_ACBDLR0 (0x1000 + (0x10 << 2))
-#define P_DDR0_PUB_ACBDLR0              MMC_REG_ADDR(DDR0_PUB_ACBDLR0)
-#define DDR0_PUB_ACBDLR1 (0x1000 + (0x11 << 2))
-#define P_DDR0_PUB_ACBDLR1              MMC_REG_ADDR(DDR0_PUB_ACBDLR1)
-#define DDR0_PUB_ACBDLR2 (0x1000 + (0x12 << 2))
-#define P_DDR0_PUB_ACBDLR2              MMC_REG_ADDR(DDR0_PUB_ACBDLR2)
-#define DDR0_PUB_ACBDLR3 (0x1000 + (0x13 << 2))
-#define P_DDR0_PUB_ACBDLR3              MMC_REG_ADDR(DDR0_PUB_ACBDLR3)
-#define DDR0_PUB_ACBDLR4 (0x1000 + (0x14 << 2))
-#define P_DDR0_PUB_ACBDLR4              MMC_REG_ADDR(DDR0_PUB_ACBDLR4)
-#define DDR0_PUB_ACBDLR5 (0x1000 + (0x15 << 2))
-#define P_DDR0_PUB_ACBDLR5              MMC_REG_ADDR(DDR0_PUB_ACBDLR5)
-#define DDR0_PUB_ACBDLR6 (0x1000 + (0x16 << 2))
-#define P_DDR0_PUB_ACBDLR6              MMC_REG_ADDR(DDR0_PUB_ACBDLR6)
-#define DDR0_PUB_ACBDLR7 (0x1000 + (0x17 << 2))
-#define P_DDR0_PUB_ACBDLR7              MMC_REG_ADDR(DDR0_PUB_ACBDLR7)
-#define DDR0_PUB_ACBDLR8 (0x1000 + (0x18 << 2))
-#define P_DDR0_PUB_ACBDLR8              MMC_REG_ADDR(DDR0_PUB_ACBDLR8)
-#define DDR0_PUB_ACBDLR9 (0x1000 + (0x19 << 2))
-#define P_DDR0_PUB_ACBDLR9              MMC_REG_ADDR(DDR0_PUB_ACBDLR9)
-#define DDR0_PUB_ACIOCR0 (0x1000 + (0x1A << 2))
-#define P_DDR0_PUB_ACIOCR0              MMC_REG_ADDR(DDR0_PUB_ACIOCR0)
-#define DDR0_PUB_ACIOCR1 (0x1000 + (0x1B << 2))
-#define P_DDR0_PUB_ACIOCR1              MMC_REG_ADDR(DDR0_PUB_ACIOCR1)
-#define DDR0_PUB_ACIOCR2 (0x1000 + (0x1C << 2))
-#define P_DDR0_PUB_ACIOCR2              MMC_REG_ADDR(DDR0_PUB_ACIOCR2)
-#define DDR0_PUB_ACIOCR3 (0x1000 + (0x1D << 2))
-#define P_DDR0_PUB_ACIOCR3              MMC_REG_ADDR(DDR0_PUB_ACIOCR3)
-#define DDR0_PUB_ACIOCR4 (0x1000 + (0x1E << 2))
-#define P_DDR0_PUB_ACIOCR4              MMC_REG_ADDR(DDR0_PUB_ACIOCR4)
-#define DDR0_PUB_ACIOCR5 (0x1000 + (0x1F << 2))
-#define P_DDR0_PUB_ACIOCR5              MMC_REG_ADDR(DDR0_PUB_ACIOCR5)
-#define DDR0_PUB_DXCCR (0x1000 + (0x20 << 2))
-#define P_DDR0_PUB_DXCCR                MMC_REG_ADDR(DDR0_PUB_DXCCR)
-#define DDR0_PUB_DSGCR (0x1000 + (0x21 << 2))
-#define P_DDR0_PUB_DSGCR                MMC_REG_ADDR(DDR0_PUB_DSGCR)
-#define DDR0_PUB_DCR (0x1000 + (0x22 << 2))
-#define P_DDR0_PUB_DCR          MMC_REG_ADDR(DDR0_PUB_DCR)
-#define DDR0_PUB_DTPR0 (0x1000 + (0x23 << 2))
-#define P_DDR0_PUB_DTPR0                MMC_REG_ADDR(DDR0_PUB_DTPR0)
-#define DDR0_PUB_DTPR1 (0x1000 + (0x24 << 2))
-#define P_DDR0_PUB_DTPR1                MMC_REG_ADDR(DDR0_PUB_DTPR1)
-#define DDR0_PUB_DTPR2 (0x1000 + (0x25 << 2))
-#define P_DDR0_PUB_DTPR2                MMC_REG_ADDR(DDR0_PUB_DTPR2)
-#define DDR0_PUB_DTPR3 (0x1000 + (0x26 << 2))
-#define P_DDR0_PUB_DTPR3                MMC_REG_ADDR(DDR0_PUB_DTPR3)
-#define DDR0_PUB_MR0 (0x1000 + (0x27 << 2))
-#define P_DDR0_PUB_MR0          MMC_REG_ADDR(DDR0_PUB_MR0)
-#define DDR0_PUB_MR1 (0x1000 + (0x28 << 2))
-#define P_DDR0_PUB_MR1          MMC_REG_ADDR(DDR0_PUB_MR1)
-#define DDR0_PUB_MR2 (0x1000 + (0x29 << 2))
-#define P_DDR0_PUB_MR2          MMC_REG_ADDR(DDR0_PUB_MR2)
-#define DDR0_PUB_MR3 (0x1000 + (0x2A << 2))
-#define P_DDR0_PUB_MR3          MMC_REG_ADDR(DDR0_PUB_MR3)
-#define DDR0_PUB_ODTCR (0x1000 + (0x2B << 2))
-#define P_DDR0_PUB_ODTCR                MMC_REG_ADDR(DDR0_PUB_ODTCR)
-#define DDR0_PUB_DTCR (0x1000 + (0x2C << 2))
-#define P_DDR0_PUB_DTCR                 MMC_REG_ADDR(DDR0_PUB_DTCR)
-#define DDR0_PUB_DTAR0 (0x1000 + (0x2D << 2))
-#define P_DDR0_PUB_DTAR0                MMC_REG_ADDR(DDR0_PUB_DTAR0)
-#define DDR0_PUB_DTAR1 (0x1000 + (0x2E << 2))
-#define P_DDR0_PUB_DTAR1                MMC_REG_ADDR(DDR0_PUB_DTAR1)
-#define DDR0_PUB_DTAR2 (0x1000 + (0x2F << 2))
-#define P_DDR0_PUB_DTAR2                MMC_REG_ADDR(DDR0_PUB_DTAR2)
-#define DDR0_PUB_DTAR3 (0x1000 + (0x30 << 2))
-#define P_DDR0_PUB_DTAR3                MMC_REG_ADDR(DDR0_PUB_DTAR3)
-#define DDR0_PUB_DTDR0 (0x1000 + (0x31 << 2))
-#define P_DDR0_PUB_DTDR0                MMC_REG_ADDR(DDR0_PUB_DTDR0)
-#define DDR0_PUB_DTDR1 (0x1000 + (0x32 << 2))
-#define P_DDR0_PUB_DTDR1                MMC_REG_ADDR(DDR0_PUB_DTDR1)
-#define DDR0_PUB_DTEDR0 (0x1000 + (0x33 << 2))
-#define P_DDR0_PUB_DTEDR0               MMC_REG_ADDR(DDR0_PUB_DTEDR0)
-#define DDR0_PUB_DTEDR1 (0x1000 + (0x34 << 2))
-#define P_DDR0_PUB_DTEDR1               MMC_REG_ADDR(DDR0_PUB_DTEDR1)
-#define DDR0_PUB_RDIMMGCR0 (0x1000 + (0x35 << 2))
-#define P_DDR0_PUB_RDIMMGCR0            MMC_REG_ADDR(DDR0_PUB_RDIMMGCR0)
-#define DDR0_PUB_RDIMMGCR1 (0x1000 + (0x36 << 2))
-#define P_DDR0_PUB_RDIMMGCR1            MMC_REG_ADDR(DDR0_PUB_RDIMMGCR1)
-#define DDR0_PUB_RDIMMCR0 (0x1000 + (0x37 << 2))
-#define P_DDR0_PUB_RDIMMCR0             MMC_REG_ADDR(DDR0_PUB_RDIMMCR0)
-#define DDR0_PUB_RDIMMCR1 (0x1000 + (0x38 << 2))
-#define P_DDR0_PUB_RDIMMCR1             MMC_REG_ADDR(DDR0_PUB_RDIMMCR1)
-#define DDR0_PUB_GPR0 (0x1000 + (0x39 << 2))
-#define P_DDR0_PUB_GPR0                 MMC_REG_ADDR(DDR0_PUB_GPR0)
-#define DDR0_PUB_GPR1 (0x1000 + (0x3A << 2))
-#define P_DDR0_PUB_GPR1                 MMC_REG_ADDR(DDR0_PUB_GPR1)
-#define DDR0_PUB_CATR0 (0x1000 + (0x3B << 2))
-#define P_DDR0_PUB_CATR0                MMC_REG_ADDR(DDR0_PUB_CATR0)
-#define DDR0_PUB_CATR1 (0x1000 + (0x3C << 2))
-#define P_DDR0_PUB_CATR1                MMC_REG_ADDR(DDR0_PUB_CATR1)
-#define DDR0_PUB_DCUAR (0x1000 + (0x60 << 2))
-#define P_DDR0_PUB_DCUAR                MMC_REG_ADDR(DDR0_PUB_DCUAR)
-#define DDR0_PUB_DCUDR (0x1000 + (0x61 << 2))
-#define P_DDR0_PUB_DCUDR                MMC_REG_ADDR(DDR0_PUB_DCUDR)
-#define DDR0_PUB_DCURR (0x1000 + (0x62 << 2))
-#define P_DDR0_PUB_DCURR                MMC_REG_ADDR(DDR0_PUB_DCURR)
-#define DDR0_PUB_DCULR (0x1000 + (0x63 << 2))
-#define P_DDR0_PUB_DCULR                MMC_REG_ADDR(DDR0_PUB_DCULR)
-#define DDR0_PUB_DCUGCR (0x1000 + (0x64 << 2))
-#define P_DDR0_PUB_DCUGCR               MMC_REG_ADDR(DDR0_PUB_DCUGCR)
-#define DDR0_PUB_DCUTPR (0x1000 + (0x65 << 2))
-#define P_DDR0_PUB_DCUTPR               MMC_REG_ADDR(DDR0_PUB_DCUTPR)
-#define DDR0_PUB_DCUSR0 (0x1000 + (0x66 << 2))
-#define P_DDR0_PUB_DCUSR0               MMC_REG_ADDR(DDR0_PUB_DCUSR0)
-#define DDR0_PUB_DCUSR1 (0x1000 + (0x67 << 2))
-#define P_DDR0_PUB_DCUSR1               MMC_REG_ADDR(DDR0_PUB_DCUSR1)
-#define DDR0_PUB_BISTRR (0x1000 + (0x70 << 2))
-#define P_DDR0_PUB_BISTRR               MMC_REG_ADDR(DDR0_PUB_BISTRR)
-#define DDR0_PUB_BISTWCR (0x1000 + (0x71 << 2))
-#define P_DDR0_PUB_BISTWCR              MMC_REG_ADDR(DDR0_PUB_BISTWCR)
-#define DDR0_PUB_BISTMSKR0 (0x1000 + (0x72 << 2))
-#define P_DDR0_PUB_BISTMSKR0            MMC_REG_ADDR(DDR0_PUB_BISTMSKR0)
-#define DDR0_PUB_BISTMSKR1 (0x1000 + (0x73 << 2))
-#define P_DDR0_PUB_BISTMSKR1            MMC_REG_ADDR(DDR0_PUB_BISTMSKR1)
-#define DDR0_PUB_BISTMSKR2 (0x1000 + (0x74 << 2))
-#define P_DDR0_PUB_BISTMSKR2            MMC_REG_ADDR(DDR0_PUB_BISTMSKR2)
-#define DDR0_PUB_BISTLSR (0x1000 + (0x75 << 2))
-#define P_DDR0_PUB_BISTLSR              MMC_REG_ADDR(DDR0_PUB_BISTLSR)
-#define DDR0_PUB_BISTAR0 (0x1000 + (0x76 << 2))
-#define P_DDR0_PUB_BISTAR0              MMC_REG_ADDR(DDR0_PUB_BISTAR0)
-#define DDR0_PUB_BISTAR1 (0x1000 + (0x77 << 2))
-#define P_DDR0_PUB_BISTAR1              MMC_REG_ADDR(DDR0_PUB_BISTAR1)
-#define DDR0_PUB_BISTAR2 (0x1000 + (0x78 << 2))
-#define P_DDR0_PUB_BISTAR2              MMC_REG_ADDR(DDR0_PUB_BISTAR2)
-#define DDR0_PUB_BISTUDPR (0x1000 + (0x79 << 2))
-#define P_DDR0_PUB_BISTUDPR             MMC_REG_ADDR(DDR0_PUB_BISTUDPR)
-#define DDR0_PUB_BISTGSR (0x1000 + (0x7A << 2))
-#define P_DDR0_PUB_BISTGSR              MMC_REG_ADDR(DDR0_PUB_BISTGSR)
-#define DDR0_PUB_BISTWER (0x1000 + (0x7B << 2))
-#define P_DDR0_PUB_BISTWER              MMC_REG_ADDR(DDR0_PUB_BISTWER)
-#define DDR0_PUB_BISTBER0 (0x1000 + (0x7C << 2))
-#define P_DDR0_PUB_BISTBER0             MMC_REG_ADDR(DDR0_PUB_BISTBER0)
-#define DDR0_PUB_BISTBER1 (0x1000 + (0x7D << 2))
-#define P_DDR0_PUB_BISTBER1             MMC_REG_ADDR(DDR0_PUB_BISTBER1)
-#define DDR0_PUB_BISTBER2 (0x1000 + (0x7E << 2))
-#define P_DDR0_PUB_BISTBER2             MMC_REG_ADDR(DDR0_PUB_BISTBER2)
-#define DDR0_PUB_BISTBER3 (0x1000 + (0x7F << 2))
-#define P_DDR0_PUB_BISTBER3             MMC_REG_ADDR(DDR0_PUB_BISTBER3)
-#define DDR0_PUB_BISTWCSR (0x1000 + (0x80 << 2))
-#define P_DDR0_PUB_BISTWCSR             MMC_REG_ADDR(DDR0_PUB_BISTWCSR)
-#define DDR0_PUB_BISTFWR0 (0x1000 + (0x81 << 2))
-#define P_DDR0_PUB_BISTFWR0             MMC_REG_ADDR(DDR0_PUB_BISTFWR0)
-#define DDR0_PUB_BISTFWR1 (0x1000 + (0x82 << 2))
-#define P_DDR0_PUB_BISTFWR1             MMC_REG_ADDR(DDR0_PUB_BISTFWR1)
-#define DDR0_PUB_BISTFWR2 (0x1000 + (0x83 << 2))
-#define P_DDR0_PUB_BISTFWR2             MMC_REG_ADDR(DDR0_PUB_BISTFWR2)
-#define DDR0_PUB_IOVCR0 (0x1000 + (0x8E << 2))
-#define P_DDR0_PUB_IOVCR0               MMC_REG_ADDR(DDR0_PUB_IOVCR0)
-#define DDR0_PUB_IOVCR1 (0x1000 + (0x8F << 2))
-#define P_DDR0_PUB_IOVCR1               MMC_REG_ADDR(DDR0_PUB_IOVCR1)
-#define DDR0_PUB_ZQCR (0x1000 + (0x90 << 2))
-#define P_DDR0_PUB_ZQCR                 MMC_REG_ADDR(DDR0_PUB_ZQCR)
-#define DDR0_PUB_ZQ0PR (0x1000 + (0x91 << 2))
-#define P_DDR0_PUB_ZQ0PR                MMC_REG_ADDR(DDR0_PUB_ZQ0PR)
-#define DDR0_PUB_ZQ0DR (0x1000 + (0x92 << 2))
-#define P_DDR0_PUB_ZQ0DR                MMC_REG_ADDR(DDR0_PUB_ZQ0DR)
-#define DDR0_PUB_ZQ0SR (0x1000 + (0x93 << 2))
-#define P_DDR0_PUB_ZQ0SR                MMC_REG_ADDR(DDR0_PUB_ZQ0SR)
-#define DDR0_PUB_ZQ1PR (0x1000 + (0x95 << 2))
-#define P_DDR0_PUB_ZQ1PR                MMC_REG_ADDR(DDR0_PUB_ZQ1PR)
-#define DDR0_PUB_ZQ1DR (0x1000 + (0x96 << 2))
-#define P_DDR0_PUB_ZQ1DR                MMC_REG_ADDR(DDR0_PUB_ZQ1DR)
-#define DDR0_PUB_ZQ1SR (0x1000 + (0x97 << 2))
-#define P_DDR0_PUB_ZQ1SR                MMC_REG_ADDR(DDR0_PUB_ZQ1SR)
-#define DDR0_PUB_ZQ2PR (0x1000 + (0x99 << 2))
-#define P_DDR0_PUB_ZQ2PR                MMC_REG_ADDR(DDR0_PUB_ZQ2PR)
-#define DDR0_PUB_ZQ2DR (0x1000 + (0x9A << 2))
-#define P_DDR0_PUB_ZQ2DR                MMC_REG_ADDR(DDR0_PUB_ZQ2DR)
-#define DDR0_PUB_ZQ2SR (0x1000 + (0x9B << 2))
-#define P_DDR0_PUB_ZQ2SR                MMC_REG_ADDR(DDR0_PUB_ZQ2SR)
-#define DDR0_PUB_ZQ3PR (0x1000 + (0x9D << 2))
-#define P_DDR0_PUB_ZQ3PR                MMC_REG_ADDR(DDR0_PUB_ZQ3PR)
-#define DDR0_PUB_ZQ3DR (0x1000 + (0x9E << 2))
-#define P_DDR0_PUB_ZQ3DR                MMC_REG_ADDR(DDR0_PUB_ZQ3DR)
-#define DDR0_PUB_ZQ3SR (0x1000 + (0x9F << 2))
-#define P_DDR0_PUB_ZQ3SR                MMC_REG_ADDR(DDR0_PUB_ZQ3SR)
-#define DDR0_PUB_DX0GCR0 (0x1000 + (0xA0 << 2))
-#define P_DDR0_PUB_DX0GCR0              MMC_REG_ADDR(DDR0_PUB_DX0GCR0)
-#define DDR0_PUB_DX0GCR1 (0x1000 + (0xA1 << 2))
-#define P_DDR0_PUB_DX0GCR1              MMC_REG_ADDR(DDR0_PUB_DX0GCR1)
-#define DDR0_PUB_DX0GCR2 (0x1000 + (0xA2 << 2))
-#define P_DDR0_PUB_DX0GCR2              MMC_REG_ADDR(DDR0_PUB_DX0GCR2)
-#define DDR0_PUB_DX0GCR3 (0x1000 + (0xA3 << 2))
-#define P_DDR0_PUB_DX0GCR3              MMC_REG_ADDR(DDR0_PUB_DX0GCR3)
-#define DDR0_PUB_DX0GSR0 (0x1000 + (0xA4 << 2))
-#define P_DDR0_PUB_DX0GSR0              MMC_REG_ADDR(DDR0_PUB_DX0GSR0)
-#define DDR0_PUB_DX0GSR1 (0x1000 + (0xA5 << 2))
-#define P_DDR0_PUB_DX0GSR1              MMC_REG_ADDR(DDR0_PUB_DX0GSR1)
-#define DDR0_PUB_DX0GSR2 (0x1000 + (0xA6 << 2))
-#define P_DDR0_PUB_DX0GSR2              MMC_REG_ADDR(DDR0_PUB_DX0GSR2)
-#define DDR0_PUB_DX0BDLR0 (0x1000 + (0xA7 << 2))
-#define P_DDR0_PUB_DX0BDLR0             MMC_REG_ADDR(DDR0_PUB_DX0BDLR0)
-#define DDR0_PUB_DX0BDLR1 (0x1000 + (0xA8 << 2))
-#define P_DDR0_PUB_DX0BDLR1             MMC_REG_ADDR(DDR0_PUB_DX0BDLR1)
-#define DDR0_PUB_DX0BDLR2 (0x1000 + (0xA9 << 2))
-#define P_DDR0_PUB_DX0BDLR2             MMC_REG_ADDR(DDR0_PUB_DX0BDLR2)
-#define DDR0_PUB_DX0BDLR3 (0x1000 + (0xAA << 2))
-#define P_DDR0_PUB_DX0BDLR3             MMC_REG_ADDR(DDR0_PUB_DX0BDLR3)
-#define DDR0_PUB_DX0BDLR4 (0x1000 + (0xAB << 2))
-#define P_DDR0_PUB_DX0BDLR4             MMC_REG_ADDR(DDR0_PUB_DX0BDLR4)
-#define DDR0_PUB_DX0BDLR5 (0x1000 + (0xAC << 2))
-#define P_DDR0_PUB_DX0BDLR5             MMC_REG_ADDR(DDR0_PUB_DX0BDLR5)
-#define DDR0_PUB_DX0BDLR6 (0x1000 + (0xAD << 2))
-#define P_DDR0_PUB_DX0BDLR6             MMC_REG_ADDR(DDR0_PUB_DX0BDLR6)
-#define DDR0_PUB_DX0LCDLR0 (0x1000 + (0xAE << 2))
-#define P_DDR0_PUB_DX0LCDLR0            MMC_REG_ADDR(DDR0_PUB_DX0LCDLR0)
-#define DDR0_PUB_DX0LCDLR1 (0x1000 + (0xAF << 2))
-#define P_DDR0_PUB_DX0LCDLR1            MMC_REG_ADDR(DDR0_PUB_DX0LCDLR1)
-#define DDR0_PUB_DX0LCDLR2 (0x1000 + (0xB0 << 2))
-#define P_DDR0_PUB_DX0LCDLR2            MMC_REG_ADDR(DDR0_PUB_DX0LCDLR2)
-#define DDR0_PUB_DX0MDLR (0x1000 + (0xB1 << 2))
-#define P_DDR0_PUB_DX0MDLR              MMC_REG_ADDR(DDR0_PUB_DX0MDLR)
-#define DDR0_PUB_DX0GTR (0x1000 + (0xB2 << 2))
-#define P_DDR0_PUB_DX0GTR               MMC_REG_ADDR(DDR0_PUB_DX0GTR)
-#define DDR0_PUB_DX1GCR0 (0x1000 + (0xC0 << 2))
-#define P_DDR0_PUB_DX1GCR0              MMC_REG_ADDR(DDR0_PUB_DX1GCR0)
-#define DDR0_PUB_DX1GCR1 (0x1000 + (0xC1 << 2))
-#define P_DDR0_PUB_DX1GCR1              MMC_REG_ADDR(DDR0_PUB_DX1GCR1)
-#define DDR0_PUB_DX1GCR2 (0x1000 + (0xC2 << 2))
-#define P_DDR0_PUB_DX1GCR2              MMC_REG_ADDR(DDR0_PUB_DX1GCR2)
-#define DDR0_PUB_DX1GCR3 (0x1000 + (0xC3 << 2))
-#define P_DDR0_PUB_DX1GCR3              MMC_REG_ADDR(DDR0_PUB_DX1GCR3)
-#define DDR0_PUB_DX1GSR0 (0x1000 + (0xC4 << 2))
-#define P_DDR0_PUB_DX1GSR0              MMC_REG_ADDR(DDR0_PUB_DX1GSR0)
-#define DDR0_PUB_DX1GSR1 (0x1000 + (0xC5 << 2))
-#define P_DDR0_PUB_DX1GSR1              MMC_REG_ADDR(DDR0_PUB_DX1GSR1)
-#define DDR0_PUB_DX1GSR2 (0x1000 + (0xC6 << 2))
-#define P_DDR0_PUB_DX1GSR2              MMC_REG_ADDR(DDR0_PUB_DX1GSR2)
-#define DDR0_PUB_DX1BDLR0 (0x1000 + (0xC7 << 2))
-#define P_DDR0_PUB_DX1BDLR0             MMC_REG_ADDR(DDR0_PUB_DX1BDLR0)
-#define DDR0_PUB_DX1BDLR1 (0x1000 + (0xC8 << 2))
-#define P_DDR0_PUB_DX1BDLR1             MMC_REG_ADDR(DDR0_PUB_DX1BDLR1)
-#define DDR0_PUB_DX1BDLR2 (0x1000 + (0xC9 << 2))
-#define P_DDR0_PUB_DX1BDLR2             MMC_REG_ADDR(DDR0_PUB_DX1BDLR2)
-#define DDR0_PUB_DX1BDLR3 (0x1000 + (0xCA << 2))
-#define P_DDR0_PUB_DX1BDLR3             MMC_REG_ADDR(DDR0_PUB_DX1BDLR3)
-#define DDR0_PUB_DX1BDLR4 (0x1000 + (0xCB << 2))
-#define P_DDR0_PUB_DX1BDLR4             MMC_REG_ADDR(DDR0_PUB_DX1BDLR4)
-#define DDR0_PUB_DX1BDLR5 (0x1000 + (0xCC << 2))
-#define P_DDR0_PUB_DX1BDLR5             MMC_REG_ADDR(DDR0_PUB_DX1BDLR5)
-#define DDR0_PUB_DX1BDLR6 (0x1000 + (0xCD << 2))
-#define P_DDR0_PUB_DX1BDLR6             MMC_REG_ADDR(DDR0_PUB_DX1BDLR6)
-#define DDR0_PUB_DX1LCDLR0 (0x1000 + (0xCE << 2))
-#define P_DDR0_PUB_DX1LCDLR0            MMC_REG_ADDR(DDR0_PUB_DX1LCDLR0)
-#define DDR0_PUB_DX1LCDLR1 (0x1000 + (0xCF << 2))
-#define P_DDR0_PUB_DX1LCDLR1            MMC_REG_ADDR(DDR0_PUB_DX1LCDLR1)
-#define DDR0_PUB_DX1LCDLR2 (0x1000 + (0xD0 << 2))
-#define P_DDR0_PUB_DX1LCDLR2            MMC_REG_ADDR(DDR0_PUB_DX1LCDLR2)
-#define DDR0_PUB_DX1MDLR (0x1000 + (0xD1 << 2))
-#define P_DDR0_PUB_DX1MDLR              MMC_REG_ADDR(DDR0_PUB_DX1MDLR)
-#define DDR0_PUB_DX1GTR (0x1000 + (0xD2 << 2))
-#define P_DDR0_PUB_DX1GTR               MMC_REG_ADDR(DDR0_PUB_DX1GTR)
-#define DDR0_PUB_DX2GCR0 (0x1000 + (0xE0 << 2))
-#define P_DDR0_PUB_DX2GCR0              MMC_REG_ADDR(DDR0_PUB_DX2GCR0)
-#define DDR0_PUB_DX2GCR1 (0x1000 + (0xE1 << 2))
-#define P_DDR0_PUB_DX2GCR1              MMC_REG_ADDR(DDR0_PUB_DX2GCR1)
-#define DDR0_PUB_DX2GCR2 (0x1000 + (0xE2 << 2))
-#define P_DDR0_PUB_DX2GCR2              MMC_REG_ADDR(DDR0_PUB_DX2GCR2)
-#define DDR0_PUB_DX2GCR3 (0x1000 + (0xE3 << 2))
-#define P_DDR0_PUB_DX2GCR3              MMC_REG_ADDR(DDR0_PUB_DX2GCR3)
-#define DDR0_PUB_DX2GSR0 (0x1000 + (0xE4 << 2))
-#define P_DDR0_PUB_DX2GSR0              MMC_REG_ADDR(DDR0_PUB_DX2GSR0)
-#define DDR0_PUB_DX2GSR1 (0x1000 + (0xE5 << 2))
-#define P_DDR0_PUB_DX2GSR1              MMC_REG_ADDR(DDR0_PUB_DX2GSR1)
-#define DDR0_PUB_DX2GSR2 (0x1000 + (0xE6 << 2))
-#define P_DDR0_PUB_DX2GSR2              MMC_REG_ADDR(DDR0_PUB_DX2GSR2)
-#define DDR0_PUB_DX2BDLR0 (0x1000 + (0xE7 << 2))
-#define P_DDR0_PUB_DX2BDLR0             MMC_REG_ADDR(DDR0_PUB_DX2BDLR0)
-#define DDR0_PUB_DX2BDLR1 (0x1000 + (0xE8 << 2))
-#define P_DDR0_PUB_DX2BDLR1             MMC_REG_ADDR(DDR0_PUB_DX2BDLR1)
-#define DDR0_PUB_DX2BDLR2 (0x1000 + (0xE9 << 2))
-#define P_DDR0_PUB_DX2BDLR2             MMC_REG_ADDR(DDR0_PUB_DX2BDLR2)
-#define DDR0_PUB_DX2BDLR3 (0x1000 + (0xEA << 2))
-#define P_DDR0_PUB_DX2BDLR3             MMC_REG_ADDR(DDR0_PUB_DX2BDLR3)
-#define DDR0_PUB_DX2BDLR4 (0x1000 + (0xEB << 2))
-#define P_DDR0_PUB_DX2BDLR4             MMC_REG_ADDR(DDR0_PUB_DX2BDLR4)
-#define DDR0_PUB_DX2BDLR5 (0x1000 + (0xEC << 2))
-#define P_DDR0_PUB_DX2BDLR5             MMC_REG_ADDR(DDR0_PUB_DX2BDLR5)
-#define DDR0_PUB_DX2BDLR6 (0x1000 + (0xED << 2))
-#define P_DDR0_PUB_DX2BDLR6             MMC_REG_ADDR(DDR0_PUB_DX2BDLR6)
-#define DDR0_PUB_DX2LCDLR0 (0x1000 + (0xEE << 2))
-#define P_DDR0_PUB_DX2LCDLR0            MMC_REG_ADDR(DDR0_PUB_DX2LCDLR0)
-#define DDR0_PUB_DX2LCDLR1 (0x1000 + (0xEF << 2))
-#define P_DDR0_PUB_DX2LCDLR1            MMC_REG_ADDR(DDR0_PUB_DX2LCDLR1)
-#define DDR0_PUB_DX2LCDLR2 (0x1000 + (0xF0 << 2))
-#define P_DDR0_PUB_DX2LCDLR2            MMC_REG_ADDR(DDR0_PUB_DX2LCDLR2)
-#define DDR0_PUB_DX2MDLR (0x1000 + (0xF1 << 2))
-#define P_DDR0_PUB_DX2MDLR              MMC_REG_ADDR(DDR0_PUB_DX2MDLR)
-#define DDR0_PUB_DX2GTR (0x1000 + (0xF2 << 2))
-#define P_DDR0_PUB_DX2GTR               MMC_REG_ADDR(DDR0_PUB_DX2GTR)
-#define DDR0_PUB_DX3GCR0 (0x1000 + (0x100 << 2))
-#define P_DDR0_PUB_DX3GCR0              MMC_REG_ADDR(DDR0_PUB_DX3GCR0)
-#define DDR0_PUB_DX3GCR1 (0x1000 + (0x101 << 2))
-#define P_DDR0_PUB_DX3GCR1              MMC_REG_ADDR(DDR0_PUB_DX3GCR1)
-#define DDR0_PUB_DX3GCR2 (0x1000 + (0x102 << 2))
-#define P_DDR0_PUB_DX3GCR2              MMC_REG_ADDR(DDR0_PUB_DX3GCR2)
-#define DDR0_PUB_DX3GCR3 (0x1000 + (0x103 << 2))
-#define P_DDR0_PUB_DX3GCR3              MMC_REG_ADDR(DDR0_PUB_DX3GCR3)
-#define DDR0_PUB_DX3GSR0 (0x1000 + (0x104 << 2))
-#define P_DDR0_PUB_DX3GSR0              MMC_REG_ADDR(DDR0_PUB_DX3GSR0)
-#define DDR0_PUB_DX3GSR1 (0x1000 + (0x105 << 2))
-#define P_DDR0_PUB_DX3GSR1              MMC_REG_ADDR(DDR0_PUB_DX3GSR1)
-#define DDR0_PUB_DX3GSR2 (0x1000 + (0x106 << 2))
-#define P_DDR0_PUB_DX3GSR2              MMC_REG_ADDR(DDR0_PUB_DX3GSR2)
-#define DDR0_PUB_DX3BDLR0 (0x1000 + (0x107 << 2))
-#define P_DDR0_PUB_DX3BDLR0             MMC_REG_ADDR(DDR0_PUB_DX3BDLR0)
-#define DDR0_PUB_DX3BDLR1 (0x1000 + (0x108 << 2))
-#define P_DDR0_PUB_DX3BDLR1             MMC_REG_ADDR(DDR0_PUB_DX3BDLR1)
-#define DDR0_PUB_DX3BDLR2 (0x1000 + (0x109 << 2))
-#define P_DDR0_PUB_DX3BDLR2             MMC_REG_ADDR(DDR0_PUB_DX3BDLR2)
-#define DDR0_PUB_DX3BDLR3 (0x1000 + (0x10A << 2))
-#define P_DDR0_PUB_DX3BDLR3             MMC_REG_ADDR(DDR0_PUB_DX3BDLR3)
-#define DDR0_PUB_DX3BDLR4 (0x1000 + (0x10B << 2))
-#define P_DDR0_PUB_DX3BDLR4             MMC_REG_ADDR(DDR0_PUB_DX3BDLR4)
-#define DDR0_PUB_DX3BDLR5 (0x1000 + (0x10C << 2))
-#define P_DDR0_PUB_DX3BDLR5             MMC_REG_ADDR(DDR0_PUB_DX3BDLR5)
-#define DDR0_PUB_DX3BDLR6 (0x1000 + (0x10D << 2))
-#define P_DDR0_PUB_DX3BDLR6             MMC_REG_ADDR(DDR0_PUB_DX3BDLR6)
-#define DDR0_PUB_DX3LCDLR0 (0x1000 + (0x10E << 2))
-#define P_DDR0_PUB_DX3LCDLR0            MMC_REG_ADDR(DDR0_PUB_DX3LCDLR0)
-#define DDR0_PUB_DX3LCDLR1 (0x1000 + (0x10F << 2))
-#define P_DDR0_PUB_DX3LCDLR1            MMC_REG_ADDR(DDR0_PUB_DX3LCDLR1)
-#define DDR0_PUB_DX3LCDLR2 (0x1000 + (0x110 << 2))
-#define P_DDR0_PUB_DX3LCDLR2            MMC_REG_ADDR(DDR0_PUB_DX3LCDLR2)
-#define DDR0_PUB_DX3MDLR (0x1000 + (0x111 << 2))
-#define P_DDR0_PUB_DX3MDLR              MMC_REG_ADDR(DDR0_PUB_DX3MDLR)
-#define DDR0_PUB_DX3GTR (0x1000 + (0x112 << 2))
-#define P_DDR0_PUB_DX3GTR               MMC_REG_ADDR(DDR0_PUB_DX3GTR)
-#define DDR0_PUB_DX4GCR0 (0x1000 + (0x120 << 2))
-#define P_DDR0_PUB_DX4GCR0              MMC_REG_ADDR(DDR0_PUB_DX4GCR0)
-#define DDR0_PUB_DX4GCR1 (0x1000 + (0x121 << 2))
-#define P_DDR0_PUB_DX4GCR1              MMC_REG_ADDR(DDR0_PUB_DX4GCR1)
-#define DDR0_PUB_DX4GCR2 (0x1000 + (0x122 << 2))
-#define P_DDR0_PUB_DX4GCR2              MMC_REG_ADDR(DDR0_PUB_DX4GCR2)
-#define DDR0_PUB_DX4GCR3 (0x1000 + (0x123 << 2))
-#define P_DDR0_PUB_DX4GCR3              MMC_REG_ADDR(DDR0_PUB_DX4GCR3)
-#define DDR0_PUB_DX4GSR0 (0x1000 + (0x124 << 2))
-#define P_DDR0_PUB_DX4GSR0              MMC_REG_ADDR(DDR0_PUB_DX4GSR0)
-#define DDR0_PUB_DX4GSR1 (0x1000 + (0x125 << 2))
-#define P_DDR0_PUB_DX4GSR1              MMC_REG_ADDR(DDR0_PUB_DX4GSR1)
-#define DDR0_PUB_DX4GSR2 (0x1000 + (0x126 << 2))
-#define P_DDR0_PUB_DX4GSR2              MMC_REG_ADDR(DDR0_PUB_DX4GSR2)
-#define DDR0_PUB_DX4BDLR0 (0x1000 + (0x127 << 2))
-#define P_DDR0_PUB_DX4BDLR0             MMC_REG_ADDR(DDR0_PUB_DX4BDLR0)
-#define DDR0_PUB_DX4BDLR1 (0x1000 + (0x128 << 2))
-#define P_DDR0_PUB_DX4BDLR1             MMC_REG_ADDR(DDR0_PUB_DX4BDLR1)
-#define DDR0_PUB_DX4BDLR2 (0x1000 + (0x129 << 2))
-#define P_DDR0_PUB_DX4BDLR2             MMC_REG_ADDR(DDR0_PUB_DX4BDLR2)
-#define DDR0_PUB_DX4BDLR3 (0x1000 + (0x12A << 2))
-#define P_DDR0_PUB_DX4BDLR3             MMC_REG_ADDR(DDR0_PUB_DX4BDLR3)
-#define DDR0_PUB_DX4BDLR4 (0x1000 + (0x12B << 2))
-#define P_DDR0_PUB_DX4BDLR4             MMC_REG_ADDR(DDR0_PUB_DX4BDLR4)
-#define DDR0_PUB_DX4BDLR5 (0x1000 + (0x12C << 2))
-#define P_DDR0_PUB_DX4BDLR5             MMC_REG_ADDR(DDR0_PUB_DX4BDLR5)
-#define DDR0_PUB_DX4BDLR6 (0x1000 + (0x12D << 2))
-#define P_DDR0_PUB_DX4BDLR6             MMC_REG_ADDR(DDR0_PUB_DX4BDLR6)
-#define DDR0_PUB_DX4LCDLR0 (0x1000 + (0x12E << 2))
-#define P_DDR0_PUB_DX4LCDLR0            MMC_REG_ADDR(DDR0_PUB_DX4LCDLR0)
-#define DDR0_PUB_DX4LCDLR1 (0x1000 + (0x12F << 2))
-#define P_DDR0_PUB_DX4LCDLR1            MMC_REG_ADDR(DDR0_PUB_DX4LCDLR1)
-#define DDR0_PUB_DX4LCDLR2 (0x1000 + (0x130 << 2))
-#define P_DDR0_PUB_DX4LCDLR2            MMC_REG_ADDR(DDR0_PUB_DX4LCDLR2)
-#define DDR0_PUB_DX4MDLR (0x1000 + (0x131 << 2))
-#define P_DDR0_PUB_DX4MDLR              MMC_REG_ADDR(DDR0_PUB_DX4MDLR)
-#define DDR0_PUB_DX4GTR (0x1000 + (0x132 << 2))
-#define P_DDR0_PUB_DX4GTR               MMC_REG_ADDR(DDR0_PUB_DX4GTR)
-#define DDR0_PUB_DX5GCR0 (0x1000 + (0x140 << 2))
-#define P_DDR0_PUB_DX5GCR0              MMC_REG_ADDR(DDR0_PUB_DX5GCR0)
-#define DDR0_PUB_DX5GCR1 (0x1000 + (0x141 << 2))
-#define P_DDR0_PUB_DX5GCR1              MMC_REG_ADDR(DDR0_PUB_DX5GCR1)
-#define DDR0_PUB_DX5GCR2 (0x1000 + (0x142 << 2))
-#define P_DDR0_PUB_DX5GCR2              MMC_REG_ADDR(DDR0_PUB_DX5GCR2)
-#define DDR0_PUB_DX5GCR3 (0x1000 + (0x143 << 2))
-#define P_DDR0_PUB_DX5GCR3              MMC_REG_ADDR(DDR0_PUB_DX5GCR3)
-#define DDR0_PUB_DX5GSR0 (0x1000 + (0x144 << 2))
-#define P_DDR0_PUB_DX5GSR0              MMC_REG_ADDR(DDR0_PUB_DX5GSR0)
-#define DDR0_PUB_DX5GSR1 (0x1000 + (0x145 << 2))
-#define P_DDR0_PUB_DX5GSR1              MMC_REG_ADDR(DDR0_PUB_DX5GSR1)
-#define DDR0_PUB_DX5GSR2 (0x1000 + (0x146 << 2))
-#define P_DDR0_PUB_DX5GSR2              MMC_REG_ADDR(DDR0_PUB_DX5GSR2)
-#define DDR0_PUB_DX5BDLR0 (0x1000 + (0x147 << 2))
-#define P_DDR0_PUB_DX5BDLR0             MMC_REG_ADDR(DDR0_PUB_DX5BDLR0)
-#define DDR0_PUB_DX5BDLR1 (0x1000 + (0x148 << 2))
-#define P_DDR0_PUB_DX5BDLR1             MMC_REG_ADDR(DDR0_PUB_DX5BDLR1)
-#define DDR0_PUB_DX5BDLR2 (0x1000 + (0x149 << 2))
-#define P_DDR0_PUB_DX5BDLR2             MMC_REG_ADDR(DDR0_PUB_DX5BDLR2)
-#define DDR0_PUB_DX5BDLR3 (0x1000 + (0x14A << 2))
-#define P_DDR0_PUB_DX5BDLR3             MMC_REG_ADDR(DDR0_PUB_DX5BDLR3)
-#define DDR0_PUB_DX5BDLR4 (0x1000 + (0x14B << 2))
-#define P_DDR0_PUB_DX5BDLR4             MMC_REG_ADDR(DDR0_PUB_DX5BDLR4)
-#define DDR0_PUB_DX5BDLR5 (0x1000 + (0x14C << 2))
-#define P_DDR0_PUB_DX5BDLR5             MMC_REG_ADDR(DDR0_PUB_DX5BDLR5)
-#define DDR0_PUB_DX5BDLR6 (0x1000 + (0x14D << 2))
-#define P_DDR0_PUB_DX5BDLR6             MMC_REG_ADDR(DDR0_PUB_DX5BDLR6)
-#define DDR0_PUB_DX5LCDLR0 (0x1000 + (0x14E << 2))
-#define P_DDR0_PUB_DX5LCDLR0            MMC_REG_ADDR(DDR0_PUB_DX5LCDLR0)
-#define DDR0_PUB_DX5LCDLR1 (0x1000 + (0x14F << 2))
-#define P_DDR0_PUB_DX5LCDLR1            MMC_REG_ADDR(DDR0_PUB_DX5LCDLR1)
-#define DDR0_PUB_DX5LCDLR2 (0x1000 + (0x150 << 2))
-#define P_DDR0_PUB_DX5LCDLR2            MMC_REG_ADDR(DDR0_PUB_DX5LCDLR2)
-#define DDR0_PUB_DX5MDLR (0x1000 + (0x151 << 2))
-#define P_DDR0_PUB_DX5MDLR              MMC_REG_ADDR(DDR0_PUB_DX5MDLR)
-#define DDR0_PUB_DX5GTR (0x1000 + (0x152 << 2))
-#define P_DDR0_PUB_DX5GTR               MMC_REG_ADDR(DDR0_PUB_DX5GTR)
-#define DDR0_PUB_DX6GCR0 (0x1000 + (0x160 << 2))
-#define P_DDR0_PUB_DX6GCR0              MMC_REG_ADDR(DDR0_PUB_DX6GCR0)
-#define DDR0_PUB_DX6GCR1 (0x1000 + (0x161 << 2))
-#define P_DDR0_PUB_DX6GCR1              MMC_REG_ADDR(DDR0_PUB_DX6GCR1)
-#define DDR0_PUB_DX6GCR2 (0x1000 + (0x162 << 2))
-#define P_DDR0_PUB_DX6GCR2              MMC_REG_ADDR(DDR0_PUB_DX6GCR2)
-#define DDR0_PUB_DX6GCR3 (0x1000 + (0x163 << 2))
-#define P_DDR0_PUB_DX6GCR3              MMC_REG_ADDR(DDR0_PUB_DX6GCR3)
-#define DDR0_PUB_DX6GSR0 (0x1000 + (0x164 << 2))
-#define P_DDR0_PUB_DX6GSR0              MMC_REG_ADDR(DDR0_PUB_DX6GSR0)
-#define DDR0_PUB_DX6GSR1 (0x1000 + (0x165 << 2))
-#define P_DDR0_PUB_DX6GSR1              MMC_REG_ADDR(DDR0_PUB_DX6GSR1)
-#define DDR0_PUB_DX6GSR2 (0x1000 + (0x166 << 2))
-#define P_DDR0_PUB_DX6GSR2              MMC_REG_ADDR(DDR0_PUB_DX6GSR2)
-#define DDR0_PUB_DX6BDLR0 (0x1000 + (0x167 << 2))
-#define P_DDR0_PUB_DX6BDLR0             MMC_REG_ADDR(DDR0_PUB_DX6BDLR0)
-#define DDR0_PUB_DX6BDLR1 (0x1000 + (0x168 << 2))
-#define P_DDR0_PUB_DX6BDLR1             MMC_REG_ADDR(DDR0_PUB_DX6BDLR1)
-#define DDR0_PUB_DX6BDLR2 (0x1000 + (0x169 << 2))
-#define P_DDR0_PUB_DX6BDLR2             MMC_REG_ADDR(DDR0_PUB_DX6BDLR2)
-#define DDR0_PUB_DX6BDLR3 (0x1000 + (0x16A << 2))
-#define P_DDR0_PUB_DX6BDLR3             MMC_REG_ADDR(DDR0_PUB_DX6BDLR3)
-#define DDR0_PUB_DX6BDLR4 (0x1000 + (0x16B << 2))
-#define P_DDR0_PUB_DX6BDLR4             MMC_REG_ADDR(DDR0_PUB_DX6BDLR4)
-#define DDR0_PUB_DX6BDLR5 (0x1000 + (0x16C << 2))
-#define P_DDR0_PUB_DX6BDLR5             MMC_REG_ADDR(DDR0_PUB_DX6BDLR5)
-#define DDR0_PUB_DX6BDLR6 (0x1000 + (0x16D << 2))
-#define P_DDR0_PUB_DX6BDLR6             MMC_REG_ADDR(DDR0_PUB_DX6BDLR6)
-#define DDR0_PUB_DX6LCDLR0 (0x1000 + (0x16E << 2))
-#define P_DDR0_PUB_DX6LCDLR0            MMC_REG_ADDR(DDR0_PUB_DX6LCDLR0)
-#define DDR0_PUB_DX6LCDLR1 (0x1000 + (0x16F << 2))
-#define P_DDR0_PUB_DX6LCDLR1            MMC_REG_ADDR(DDR0_PUB_DX6LCDLR1)
-#define DDR0_PUB_DX6LCDLR2 (0x1000 + (0x170 << 2))
-#define P_DDR0_PUB_DX6LCDLR2            MMC_REG_ADDR(DDR0_PUB_DX6LCDLR2)
-#define DDR0_PUB_DX6MDLR (0x1000 + (0x171 << 2))
-#define P_DDR0_PUB_DX6MDLR              MMC_REG_ADDR(DDR0_PUB_DX6MDLR)
-#define DDR0_PUB_DX6GTR (0x1000 + (0x172 << 2))
-#define P_DDR0_PUB_DX6GTR               MMC_REG_ADDR(DDR0_PUB_DX6GTR)
-#define DDR0_PUB_DX7GCR0 (0x1000 + (0x180 << 2))
-#define P_DDR0_PUB_DX7GCR0              MMC_REG_ADDR(DDR0_PUB_DX7GCR0)
-#define DDR0_PUB_DX7GCR1 (0x1000 + (0x181 << 2))
-#define P_DDR0_PUB_DX7GCR1              MMC_REG_ADDR(DDR0_PUB_DX7GCR1)
-#define DDR0_PUB_DX7GCR2 (0x1000 + (0x182 << 2))
-#define P_DDR0_PUB_DX7GCR2              MMC_REG_ADDR(DDR0_PUB_DX7GCR2)
-#define DDR0_PUB_DX7GCR3 (0x1000 + (0x183 << 2))
-#define P_DDR0_PUB_DX7GCR3              MMC_REG_ADDR(DDR0_PUB_DX7GCR3)
-#define DDR0_PUB_DX7GSR0 (0x1000 + (0x184 << 2))
-#define P_DDR0_PUB_DX7GSR0              MMC_REG_ADDR(DDR0_PUB_DX7GSR0)
-#define DDR0_PUB_DX7GSR1 (0x1000 + (0x185 << 2))
-#define P_DDR0_PUB_DX7GSR1              MMC_REG_ADDR(DDR0_PUB_DX7GSR1)
-#define DDR0_PUB_DX7GSR2 (0x1000 + (0x186 << 2))
-#define P_DDR0_PUB_DX7GSR2              MMC_REG_ADDR(DDR0_PUB_DX7GSR2)
-#define DDR0_PUB_DX7BDLR0 (0x1000 + (0x187 << 2))
-#define P_DDR0_PUB_DX7BDLR0             MMC_REG_ADDR(DDR0_PUB_DX7BDLR0)
-#define DDR0_PUB_DX7BDLR1 (0x1000 + (0x188 << 2))
-#define P_DDR0_PUB_DX7BDLR1             MMC_REG_ADDR(DDR0_PUB_DX7BDLR1)
-#define DDR0_PUB_DX7BDLR2 (0x1000 + (0x189 << 2))
-#define P_DDR0_PUB_DX7BDLR2             MMC_REG_ADDR(DDR0_PUB_DX7BDLR2)
-#define DDR0_PUB_DX7BDLR3 (0x1000 + (0x18A << 2))
-#define P_DDR0_PUB_DX7BDLR3             MMC_REG_ADDR(DDR0_PUB_DX7BDLR3)
-#define DDR0_PUB_DX7BDLR4 (0x1000 + (0x18B << 2))
-#define P_DDR0_PUB_DX7BDLR4             MMC_REG_ADDR(DDR0_PUB_DX7BDLR4)
-#define DDR0_PUB_DX7BDLR5 (0x1000 + (0x18C << 2))
-#define P_DDR0_PUB_DX7BDLR5             MMC_REG_ADDR(DDR0_PUB_DX7BDLR5)
-#define DDR0_PUB_DX7BDLR6 (0x1000 + (0x18D << 2))
-#define P_DDR0_PUB_DX7BDLR6             MMC_REG_ADDR(DDR0_PUB_DX7BDLR6)
-#define DDR0_PUB_DX7LCDLR0 (0x1000 + (0x18E << 2))
-#define P_DDR0_PUB_DX7LCDLR0            MMC_REG_ADDR(DDR0_PUB_DX7LCDLR0)
-#define DDR0_PUB_DX7LCDLR1 (0x1000 + (0x18F << 2))
-#define P_DDR0_PUB_DX7LCDLR1            MMC_REG_ADDR(DDR0_PUB_DX7LCDLR1)
-#define DDR0_PUB_DX7LCDLR2 (0x1000 + (0x190 << 2))
-#define P_DDR0_PUB_DX7LCDLR2            MMC_REG_ADDR(DDR0_PUB_DX7LCDLR2)
-#define DDR0_PUB_DX7MDLR (0x1000 + (0x191 << 2))
-#define P_DDR0_PUB_DX7MDLR              MMC_REG_ADDR(DDR0_PUB_DX7MDLR)
-#define DDR0_PUB_DX7GTR (0x1000 + (0x192 << 2))
-#define P_DDR0_PUB_DX7GTR               MMC_REG_ADDR(DDR0_PUB_DX7GTR)
-#define DDR0_PUB_DX8GCR0 (0x1000 + (0x1A0 << 2))
-#define P_DDR0_PUB_DX8GCR0              MMC_REG_ADDR(DDR0_PUB_DX8GCR0)
-#define DDR0_PUB_DX8GCR1 (0x1000 + (0x1A1 << 2))
-#define P_DDR0_PUB_DX8GCR1              MMC_REG_ADDR(DDR0_PUB_DX8GCR1)
-#define DDR0_PUB_DX8GCR2 (0x1000 + (0x1A2 << 2))
-#define P_DDR0_PUB_DX8GCR2              MMC_REG_ADDR(DDR0_PUB_DX8GCR2)
-#define DDR0_PUB_DX8GCR3 (0x1000 + (0x1A3 << 2))
-#define P_DDR0_PUB_DX8GCR3              MMC_REG_ADDR(DDR0_PUB_DX8GCR3)
-#define DDR0_PUB_DX8GSR0 (0x1000 + (0x1A4 << 2))
-#define P_DDR0_PUB_DX8GSR0              MMC_REG_ADDR(DDR0_PUB_DX8GSR0)
-#define DDR0_PUB_DX8GSR1 (0x1000 + (0x1A5 << 2))
-#define P_DDR0_PUB_DX8GSR1              MMC_REG_ADDR(DDR0_PUB_DX8GSR1)
-#define DDR0_PUB_DX8GSR2 (0x1000 + (0x1A6 << 2))
-#define P_DDR0_PUB_DX8GSR2              MMC_REG_ADDR(DDR0_PUB_DX8GSR2)
-#define DDR0_PUB_DX8BDLR0 (0x1000 + (0x1A7 << 2))
-#define P_DDR0_PUB_DX8BDLR0             MMC_REG_ADDR(DDR0_PUB_DX8BDLR0)
-#define DDR0_PUB_DX8BDLR1 (0x1000 + (0x1A8 << 2))
-#define P_DDR0_PUB_DX8BDLR1             MMC_REG_ADDR(DDR0_PUB_DX8BDLR1)
-#define DDR0_PUB_DX8BDLR2 (0x1000 + (0x1A9 << 2))
-#define P_DDR0_PUB_DX8BDLR2             MMC_REG_ADDR(DDR0_PUB_DX8BDLR2)
-#define DDR0_PUB_DX8BDLR3 (0x1000 + (0x1AA << 2))
-#define P_DDR0_PUB_DX8BDLR3             MMC_REG_ADDR(DDR0_PUB_DX8BDLR3)
-#define DDR0_PUB_DX8BDLR4 (0x1000 + (0x1AB << 2))
-#define P_DDR0_PUB_DX8BDLR4             MMC_REG_ADDR(DDR0_PUB_DX8BDLR4)
-#define DDR0_PUB_DX8BDLR5 (0x1000 + (0x1AC << 2))
-#define P_DDR0_PUB_DX8BDLR5             MMC_REG_ADDR(DDR0_PUB_DX8BDLR5)
-#define DDR0_PUB_DX8BDLR6 (0x1000 + (0x1AD << 2))
-#define P_DDR0_PUB_DX8BDLR6             MMC_REG_ADDR(DDR0_PUB_DX8BDLR6)
-#define DDR0_PUB_DX8LCDLR0 (0x1000 + (0x1AE << 2))
-#define P_DDR0_PUB_DX8LCDLR0            MMC_REG_ADDR(DDR0_PUB_DX8LCDLR0)
-#define DDR0_PUB_DX8LCDLR1 (0x1000 + (0x1AF << 2))
-#define P_DDR0_PUB_DX8LCDLR1            MMC_REG_ADDR(DDR0_PUB_DX8LCDLR1)
-#define DDR0_PUB_DX8LCDLR2 (0x1000 + (0x1B0 << 2))
-#define P_DDR0_PUB_DX8LCDLR2            MMC_REG_ADDR(DDR0_PUB_DX8LCDLR2)
-#define DDR0_PUB_DX8MDLR (0x1000 + (0x1B1 << 2))
-#define P_DDR0_PUB_DX8MDLR              MMC_REG_ADDR(DDR0_PUB_DX8MDLR)
-#define DDR0_PUB_DX8GTR (0x1000 + (0x1B2 << 2))
-#define P_DDR0_PUB_DX8GTR               MMC_REG_ADDR(DDR0_PUB_DX8GTR)
-
-#define DDR1_PCTL_DFILPCFG0 0x22f0
-#define P_DDR1_PCTL_DFILPCFG0           MMC_REG_ADDR(DDR1_PCTL_DFILPCFG0)
-#define DDR1_PCTL_DFITRWRLVLDELAY0 0x2318
-#define P_DDR1_PCTL_DFITRWRLVLDELAY0            \
-	MMC_REG_ADDR(DDR1_PCTL_DFITRWRLVLDELAY0)
-#define DDR1_PCTL_DFITRWRLVLDELAY1 0x231c
-#define P_DDR1_PCTL_DFITRWRLVLDELAY1            \
-	MMC_REG_ADDR(DDR1_PCTL_DFITRWRLVLDELAY1)
-#define DDR1_PCTL_DFITRWRLVLDELAY2 0x2320
-#define P_DDR1_PCTL_DFITRWRLVLDELAY2            \
-	MMC_REG_ADDR(DDR1_PCTL_DFITRWRLVLDELAY2)
-#define DDR1_PCTL_DFITRRDLVLRESP0 0x230c
-#define P_DDR1_PCTL_DFITRRDLVLRESP0             \
-	MMC_REG_ADDR(DDR1_PCTL_DFITRRDLVLRESP0)
-#define DDR1_PCTL_DFITRRDLVLRESP1 0x2310
-#define P_DDR1_PCTL_DFITRRDLVLRESP1             \
-	MMC_REG_ADDR(DDR1_PCTL_DFITRRDLVLRESP1)
-#define DDR1_PCTL_DFITRRDLVLRESP2 0x2314
-#define P_DDR1_PCTL_DFITRRDLVLRESP2             \
-	MMC_REG_ADDR(DDR1_PCTL_DFITRRDLVLRESP2)
-#define DDR1_PCTL_DFITRWRLVLRESP0 0x2300
-#define P_DDR1_PCTL_DFITRWRLVLRESP0             \
-	MMC_REG_ADDR(DDR1_PCTL_DFITRWRLVLRESP0)
-#define DDR1_PCTL_DFITRRDLVLDELAY0 0x2324
-#define P_DDR1_PCTL_DFITRRDLVLDELAY0            \
-	MMC_REG_ADDR(DDR1_PCTL_DFITRRDLVLDELAY0)
-#define DDR1_PCTL_DFITRWRLVLRESP1 0x2304
-#define P_DDR1_PCTL_DFITRWRLVLRESP1             \
-	MMC_REG_ADDR(DDR1_PCTL_DFITRWRLVLRESP1)
-#define DDR1_PCTL_DFITRRDLVLDELAY2 0x232c
-#define P_DDR1_PCTL_DFITRRDLVLDELAY2            \
-	MMC_REG_ADDR(DDR1_PCTL_DFITRRDLVLDELAY2)
-#define DDR1_PCTL_DFITRWRLVLRESP2 0x2308
-#define P_DDR1_PCTL_DFITRWRLVLRESP2             \
-	MMC_REG_ADDR(DDR1_PCTL_DFITRWRLVLRESP2)
-#define DDR1_PCTL_DFITRRDLVLGATEDELAY0 0x2330
-#define P_DDR1_PCTL_DFITRRDLVLGATEDELAY0                \
-	MMC_REG_ADDR(DDR1_PCTL_DFITRRDLVLGATEDELAY0)
-#define DDR1_PCTL_DFITRCMD 0x233c
-#define P_DDR1_PCTL_DFITRCMD            MMC_REG_ADDR(DDR1_PCTL_DFITRCMD)
-#define DDR1_PCTL_DFITRRDLVLGATEDELAY1 0x2334
-#define P_DDR1_PCTL_DFITRRDLVLGATEDELAY1                \
-	MMC_REG_ADDR(DDR1_PCTL_DFITRRDLVLGATEDELAY1)
-#define DDR1_PCTL_DFITRRDLVLGATEDELAY2 0x2338
-#define P_DDR1_PCTL_DFITRRDLVLGATEDELAY2                \
-	MMC_REG_ADDR(DDR1_PCTL_DFITRRDLVLGATEDELAY2)
-#define DDR1_PCTL_IPTR 0x23fc
-#define P_DDR1_PCTL_IPTR                MMC_REG_ADDR(DDR1_PCTL_IPTR)
-#define DDR1_PCTL_IPVR 0x23f8
-#define P_DDR1_PCTL_IPVR                MMC_REG_ADDR(DDR1_PCTL_IPVR)
-#define DDR1_PUB_RIDR (0x3000 + (0x00 << 2))
-#define P_DDR1_PUB_RIDR                 MMC_REG_ADDR(DDR1_PUB_RIDR)
-#define DDR1_PUB_PIR (0x3000 + (0x01 << 2))
-#define P_DDR1_PUB_PIR          MMC_REG_ADDR(DDR1_PUB_PIR)
-#define DDR1_PUB_PGCR0 (0x3000 + (0x02 << 2))
-#define P_DDR1_PUB_PGCR0                MMC_REG_ADDR(DDR1_PUB_PGCR0)
-#define DDR1_PUB_PGCR1 (0x3000 + (0x03 << 2))
-#define P_DDR1_PUB_PGCR1                MMC_REG_ADDR(DDR1_PUB_PGCR1)
-#define DDR1_PUB_PGCR2 (0x3000 + (0x04 << 2))
-#define P_DDR1_PUB_PGCR2                MMC_REG_ADDR(DDR1_PUB_PGCR2)
-#define DDR1_PUB_PGCR3 (0x3000 + (0x05 << 2))
-#define P_DDR1_PUB_PGCR3                MMC_REG_ADDR(DDR1_PUB_PGCR3)
-#define DDR1_PUB_PGSR0 (0x3000 + (0x06 << 2))
-#define P_DDR1_PUB_PGSR0                MMC_REG_ADDR(DDR1_PUB_PGSR0)
-#define DDR1_PUB_PGSR1 (0x3000 + (0x07 << 2))
-#define P_DDR1_PUB_PGSR1                MMC_REG_ADDR(DDR1_PUB_PGSR1)
-#define DDR1_PUB_PLLCR (0x3000 + (0x08 << 2))
-#define P_DDR1_PUB_PLLCR                MMC_REG_ADDR(DDR1_PUB_PLLCR)
-#define DDR1_PUB_PTR0 (0x3000 + (0x09 << 2))
-#define P_DDR1_PUB_PTR0                 MMC_REG_ADDR(DDR1_PUB_PTR0)
-#define DDR1_PUB_PTR1 (0x3000 + (0x0A << 2))
-#define P_DDR1_PUB_PTR1                 MMC_REG_ADDR(DDR1_PUB_PTR1)
-#define DDR1_PUB_PTR2 (0x3000 + (0x0B << 2))
-#define P_DDR1_PUB_PTR2                 MMC_REG_ADDR(DDR1_PUB_PTR2)
-#define DDR1_PUB_PTR3 (0x3000 + (0x0C << 2))
-#define P_DDR1_PUB_PTR3                 MMC_REG_ADDR(DDR1_PUB_PTR3)
-#define DDR1_PUB_PTR4 (0x3000 + (0x0D << 2))
-#define P_DDR1_PUB_PTR4                 MMC_REG_ADDR(DDR1_PUB_PTR4)
-#define DDR1_PUB_ACMDLR (0x3000 + (0x0E << 2))
-#define P_DDR1_PUB_ACMDLR               MMC_REG_ADDR(DDR1_PUB_ACMDLR)
-#define DDR1_PUB_ACLCDLR (0x3000 + (0x0F << 2))
-#define P_DDR1_PUB_ACLCDLR              MMC_REG_ADDR(DDR1_PUB_ACLCDLR)
-#define DDR1_PUB_ACBDLR0 (0x3000 + (0x10 << 2))
-#define P_DDR1_PUB_ACBDLR0              MMC_REG_ADDR(DDR1_PUB_ACBDLR0)
-#define DDR1_PUB_ACBDLR1 (0x3000 + (0x11 << 2))
-#define P_DDR1_PUB_ACBDLR1              MMC_REG_ADDR(DDR1_PUB_ACBDLR1)
-#define DDR1_PUB_ACBDLR2 (0x3000 + (0x12 << 2))
-#define P_DDR1_PUB_ACBDLR2              MMC_REG_ADDR(DDR1_PUB_ACBDLR2)
-#define DDR1_PUB_ACBDLR3 (0x3000 + (0x13 << 2))
-#define P_DDR1_PUB_ACBDLR3              MMC_REG_ADDR(DDR1_PUB_ACBDLR3)
-#define DDR1_PUB_ACBDLR4 (0x3000 + (0x14 << 2))
-#define P_DDR1_PUB_ACBDLR4              MMC_REG_ADDR(DDR1_PUB_ACBDLR4)
-#define DDR1_PUB_ACBDLR5 (0x3000 + (0x15 << 2))
-#define P_DDR1_PUB_ACBDLR5              MMC_REG_ADDR(DDR1_PUB_ACBDLR5)
-#define DDR1_PUB_ACBDLR6 (0x3000 + (0x16 << 2))
-#define P_DDR1_PUB_ACBDLR6              MMC_REG_ADDR(DDR1_PUB_ACBDLR6)
-#define DDR1_PUB_ACBDLR7 (0x3000 + (0x17 << 2))
-#define P_DDR1_PUB_ACBDLR7              MMC_REG_ADDR(DDR1_PUB_ACBDLR7)
-#define DDR1_PUB_ACBDLR8 (0x3000 + (0x18 << 2))
-#define P_DDR1_PUB_ACBDLR8              MMC_REG_ADDR(DDR1_PUB_ACBDLR8)
-#define DDR1_PUB_ACBDLR9 (0x3000 + (0x19 << 2))
-#define P_DDR1_PUB_ACBDLR9              MMC_REG_ADDR(DDR1_PUB_ACBDLR9)
-#define DDR1_PUB_ACIOCR0 (0x3000 + (0x1A << 2))
-#define P_DDR1_PUB_ACIOCR0              MMC_REG_ADDR(DDR1_PUB_ACIOCR0)
-#define DDR1_PUB_ACIOCR1 (0x3000 + (0x1B << 2))
-#define P_DDR1_PUB_ACIOCR1              MMC_REG_ADDR(DDR1_PUB_ACIOCR1)
-#define DDR1_PUB_ACIOCR2 (0x3000 + (0x1C << 2))
-#define P_DDR1_PUB_ACIOCR2              MMC_REG_ADDR(DDR1_PUB_ACIOCR2)
-#define DDR1_PUB_ACIOCR3 (0x3000 + (0x1D << 2))
-#define P_DDR1_PUB_ACIOCR3              MMC_REG_ADDR(DDR1_PUB_ACIOCR3)
-#define DDR1_PUB_ACIOCR4 (0x3000 + (0x1E << 2))
-#define P_DDR1_PUB_ACIOCR4              MMC_REG_ADDR(DDR1_PUB_ACIOCR4)
-#define DDR1_PUB_ACIOCR5 (0x3000 + (0x1F << 2))
-#define P_DDR1_PUB_ACIOCR5              MMC_REG_ADDR(DDR1_PUB_ACIOCR5)
-#define DDR1_PUB_DXCCR (0x3000 + (0x20 << 2))
-#define P_DDR1_PUB_DXCCR                MMC_REG_ADDR(DDR1_PUB_DXCCR)
-#define DDR1_PUB_DSGCR (0x3000 + (0x21 << 2))
-#define P_DDR1_PUB_DSGCR                MMC_REG_ADDR(DDR1_PUB_DSGCR)
-#define DDR1_PUB_DCR (0x3000 + (0x22 << 2))
-#define P_DDR1_PUB_DCR          MMC_REG_ADDR(DDR1_PUB_DCR)
-#define DDR1_PUB_DTPR0 (0x3000 + (0x23 << 2))
-#define P_DDR1_PUB_DTPR0                MMC_REG_ADDR(DDR1_PUB_DTPR0)
-#define DDR1_PUB_DTPR1 (0x3000 + (0x24 << 2))
-#define P_DDR1_PUB_DTPR1                MMC_REG_ADDR(DDR1_PUB_DTPR1)
-#define DDR1_PUB_DTPR2 (0x3000 + (0x25 << 2))
-#define P_DDR1_PUB_DTPR2                MMC_REG_ADDR(DDR1_PUB_DTPR2)
-#define DDR1_PUB_DTPR3 (0x3000 + (0x26 << 2))
-#define P_DDR1_PUB_DTPR3                MMC_REG_ADDR(DDR1_PUB_DTPR3)
-#define DDR1_PUB_MR0 (0x3000 + (0x27 << 2))
-#define P_DDR1_PUB_MR0          MMC_REG_ADDR(DDR1_PUB_MR0)
-#define DDR1_PUB_MR1 (0x3000 + (0x28 << 2))
-#define P_DDR1_PUB_MR1          MMC_REG_ADDR(DDR1_PUB_MR1)
-#define DDR1_PUB_MR2 (0x3000 + (0x29 << 2))
-#define P_DDR1_PUB_MR2          MMC_REG_ADDR(DDR1_PUB_MR2)
-#define DDR1_PUB_MR3 (0x3000 + (0x2A << 2))
-#define P_DDR1_PUB_MR3          MMC_REG_ADDR(DDR1_PUB_MR3)
-#define DDR1_PUB_ODTCR (0x3000 + (0x2B << 2))
-#define P_DDR1_PUB_ODTCR                MMC_REG_ADDR(DDR1_PUB_ODTCR)
-#define DDR1_PUB_DTCR (0x3000 + (0x2C << 2))
-#define P_DDR1_PUB_DTCR                 MMC_REG_ADDR(DDR1_PUB_DTCR)
-#define DDR1_PUB_DTAR0 (0x3000 + (0x2D << 2))
-#define P_DDR1_PUB_DTAR0                MMC_REG_ADDR(DDR1_PUB_DTAR0)
-#define DDR1_PUB_DTAR1 (0x3000 + (0x2E << 2))
-#define P_DDR1_PUB_DTAR1                MMC_REG_ADDR(DDR1_PUB_DTAR1)
-#define DDR1_PUB_DTAR2 (0x3000 + (0x2F << 2))
-#define P_DDR1_PUB_DTAR2                MMC_REG_ADDR(DDR1_PUB_DTAR2)
-#define DDR1_PUB_DTAR3 (0x3000 + (0x30 << 2))
-#define P_DDR1_PUB_DTAR3                MMC_REG_ADDR(DDR1_PUB_DTAR3)
-#define DDR1_PUB_DTDR0 (0x3000 + (0x31 << 2))
-#define P_DDR1_PUB_DTDR0                MMC_REG_ADDR(DDR1_PUB_DTDR0)
-#define DDR1_PUB_DTDR1 (0x3000 + (0x32 << 2))
-#define P_DDR1_PUB_DTDR1                MMC_REG_ADDR(DDR1_PUB_DTDR1)
-#define DDR1_PUB_DTEDR0 (0x3000 + (0x33 << 2))
-#define P_DDR1_PUB_DTEDR0               MMC_REG_ADDR(DDR1_PUB_DTEDR0)
-#define DDR1_PUB_DTEDR1 (0x3000 + (0x34 << 2))
-#define P_DDR1_PUB_DTEDR1               MMC_REG_ADDR(DDR1_PUB_DTEDR1)
-#define DDR1_PUB_RDIMMGCR0 (0x3000 + (0x35 << 2))
-#define P_DDR1_PUB_RDIMMGCR0            MMC_REG_ADDR(DDR1_PUB_RDIMMGCR0)
-#define DDR1_PUB_RDIMMGCR1 (0x3000 + (0x36 << 2))
-#define P_DDR1_PUB_RDIMMGCR1            MMC_REG_ADDR(DDR1_PUB_RDIMMGCR1)
-#define DDR1_PUB_RDIMMCR0 (0x3000 + (0x37 << 2))
-#define P_DDR1_PUB_RDIMMCR0             MMC_REG_ADDR(DDR1_PUB_RDIMMCR0)
-#define DDR1_PUB_RDIMMCR1 (0x3000 + (0x38 << 2))
-#define P_DDR1_PUB_RDIMMCR1             MMC_REG_ADDR(DDR1_PUB_RDIMMCR1)
-#define DDR1_PUB_GPR0 (0x3000 + (0x39 << 2))
-#define P_DDR1_PUB_GPR0                 MMC_REG_ADDR(DDR1_PUB_GPR0)
-#define DDR1_PUB_GPR1 (0x3000 + (0x3A << 2))
-#define P_DDR1_PUB_GPR1                 MMC_REG_ADDR(DDR1_PUB_GPR1)
-#define DDR1_PUB_CATR0 (0x3000 + (0x3B << 2))
-#define P_DDR1_PUB_CATR0                MMC_REG_ADDR(DDR1_PUB_CATR0)
-#define DDR1_PUB_CATR1 (0x3000 + (0x3C << 2))
-#define P_DDR1_PUB_CATR1                MMC_REG_ADDR(DDR1_PUB_CATR1)
-#define DDR1_PUB_DCUAR (0x3000 + (0x60 << 2))
-#define P_DDR1_PUB_DCUAR                MMC_REG_ADDR(DDR1_PUB_DCUAR)
-#define DDR1_PUB_DCUDR (0x3000 + (0x61 << 2))
-#define P_DDR1_PUB_DCUDR                MMC_REG_ADDR(DDR1_PUB_DCUDR)
-#define DDR1_PUB_DCURR (0x3000 + (0x62 << 2))
-#define P_DDR1_PUB_DCURR                MMC_REG_ADDR(DDR1_PUB_DCURR)
-#define DDR1_PUB_DCULR (0x3000 + (0x63 << 2))
-#define P_DDR1_PUB_DCULR                MMC_REG_ADDR(DDR1_PUB_DCULR)
-#define DDR1_PUB_DCUGCR (0x3000 + (0x64 << 2))
-#define P_DDR1_PUB_DCUGCR               MMC_REG_ADDR(DDR1_PUB_DCUGCR)
-#define DDR1_PUB_DCUTPR (0x3000 + (0x65 << 2))
-#define P_DDR1_PUB_DCUTPR               MMC_REG_ADDR(DDR1_PUB_DCUTPR)
-#define DDR1_PUB_DCUSR0 (0x3000 + (0x66 << 2))
-#define P_DDR1_PUB_DCUSR0               MMC_REG_ADDR(DDR1_PUB_DCUSR0)
-#define DDR1_PUB_DCUSR1 (0x3000 + (0x67 << 2))
-#define P_DDR1_PUB_DCUSR1               MMC_REG_ADDR(DDR1_PUB_DCUSR1)
-#define DDR1_PUB_BISTRR (0x3000 + (0x70 << 2))
-#define P_DDR1_PUB_BISTRR               MMC_REG_ADDR(DDR1_PUB_BISTRR)
-#define DDR1_PUB_BISTWCR (0x3000 + (0x71 << 2))
-#define P_DDR1_PUB_BISTWCR              MMC_REG_ADDR(DDR1_PUB_BISTWCR)
-#define DDR1_PUB_BISTMSKR0 (0x3000 + (0x72 << 2))
-#define P_DDR1_PUB_BISTMSKR0            MMC_REG_ADDR(DDR1_PUB_BISTMSKR0)
-#define DDR1_PUB_BISTMSKR1 (0x3000 + (0x73 << 2))
-#define P_DDR1_PUB_BISTMSKR1            MMC_REG_ADDR(DDR1_PUB_BISTMSKR1)
-#define DDR1_PUB_BISTMSKR2 (0x3000 + (0x74 << 2))
-#define P_DDR1_PUB_BISTMSKR2            MMC_REG_ADDR(DDR1_PUB_BISTMSKR2)
-#define DDR1_PUB_BISTLSR (0x3000 + (0x75 << 2))
-#define P_DDR1_PUB_BISTLSR              MMC_REG_ADDR(DDR1_PUB_BISTLSR)
-#define DDR1_PUB_BISTAR0 (0x3000 + (0x76 << 2))
-#define P_DDR1_PUB_BISTAR0              MMC_REG_ADDR(DDR1_PUB_BISTAR0)
-#define DDR1_PUB_BISTAR1 (0x3000 + (0x77 << 2))
-#define P_DDR1_PUB_BISTAR1              MMC_REG_ADDR(DDR1_PUB_BISTAR1)
-#define DDR1_PUB_BISTAR2 (0x3000 + (0x78 << 2))
-#define P_DDR1_PUB_BISTAR2              MMC_REG_ADDR(DDR1_PUB_BISTAR2)
-#define DDR1_PUB_BISTUDPR (0x3000 + (0x79 << 2))
-#define P_DDR1_PUB_BISTUDPR             MMC_REG_ADDR(DDR1_PUB_BISTUDPR)
-#define DDR1_PUB_BISTGSR (0x3000 + (0x7A << 2))
-#define P_DDR1_PUB_BISTGSR              MMC_REG_ADDR(DDR1_PUB_BISTGSR)
-#define DDR1_PUB_BISTWER (0x3000 + (0x7B << 2))
-#define P_DDR1_PUB_BISTWER              MMC_REG_ADDR(DDR1_PUB_BISTWER)
-#define DDR1_PUB_BISTBER0 (0x3000 + (0x7C << 2))
-#define P_DDR1_PUB_BISTBER0             MMC_REG_ADDR(DDR1_PUB_BISTBER0)
-#define DDR1_PUB_BISTBER1 (0x3000 + (0x7D << 2))
-#define P_DDR1_PUB_BISTBER1             MMC_REG_ADDR(DDR1_PUB_BISTBER1)
-#define DDR1_PUB_BISTBER2 (0x3000 + (0x7E << 2))
-#define P_DDR1_PUB_BISTBER2             MMC_REG_ADDR(DDR1_PUB_BISTBER2)
-#define DDR1_PUB_BISTBER3 (0x3000 + (0x7F << 2))
-#define P_DDR1_PUB_BISTBER3             MMC_REG_ADDR(DDR1_PUB_BISTBER3)
-#define DDR1_PUB_BISTWCSR (0x3000 + (0x80 << 2))
-#define P_DDR1_PUB_BISTWCSR             MMC_REG_ADDR(DDR1_PUB_BISTWCSR)
-#define DDR1_PUB_BISTFWR0 (0x3000 + (0x81 << 2))
-#define P_DDR1_PUB_BISTFWR0             MMC_REG_ADDR(DDR1_PUB_BISTFWR0)
-#define DDR1_PUB_BISTFWR1 (0x3000 + (0x82 << 2))
-#define P_DDR1_PUB_BISTFWR1             MMC_REG_ADDR(DDR1_PUB_BISTFWR1)
-#define DDR1_PUB_BISTFWR2 (0x3000 + (0x83 << 2))
-#define P_DDR1_PUB_BISTFWR2             MMC_REG_ADDR(DDR1_PUB_BISTFWR2)
-#define DDR1_PUB_IOVCR0 (0x3000 + (0x8E << 2))
-#define P_DDR1_PUB_IOVCR0               MMC_REG_ADDR(DDR1_PUB_IOVCR0)
-#define DDR1_PUB_IOVCR1 (0x3000 + (0x8F << 2))
-#define P_DDR1_PUB_IOVCR1               MMC_REG_ADDR(DDR1_PUB_IOVCR1)
-#define DDR1_PUB_ZQCR (0x3000 + (0x90 << 2))
-#define P_DDR1_PUB_ZQCR                 MMC_REG_ADDR(DDR1_PUB_ZQCR)
-#define DDR1_PUB_ZQ0PR (0x3000 + (0x91 << 2))
-#define P_DDR1_PUB_ZQ0PR                MMC_REG_ADDR(DDR1_PUB_ZQ0PR)
-#define DDR1_PUB_ZQ0DR (0x3000 + (0x92 << 2))
-#define P_DDR1_PUB_ZQ0DR                MMC_REG_ADDR(DDR1_PUB_ZQ0DR)
-#define DDR1_PUB_ZQ0SR (0x3000 + (0x93 << 2))
-#define P_DDR1_PUB_ZQ0SR                MMC_REG_ADDR(DDR1_PUB_ZQ0SR)
-#define DDR1_PUB_ZQ1PR (0x3000 + (0x95 << 2))
-#define P_DDR1_PUB_ZQ1PR                MMC_REG_ADDR(DDR1_PUB_ZQ1PR)
-#define DDR1_PUB_ZQ1DR (0x3000 + (0x96 << 2))
-#define P_DDR1_PUB_ZQ1DR                MMC_REG_ADDR(DDR1_PUB_ZQ1DR)
-#define DDR1_PUB_ZQ1SR (0x3000 + (0x97 << 2))
-#define P_DDR1_PUB_ZQ1SR                MMC_REG_ADDR(DDR1_PUB_ZQ1SR)
-#define DDR1_PUB_ZQ2PR (0x3000 + (0x99 << 2))
-#define P_DDR1_PUB_ZQ2PR                MMC_REG_ADDR(DDR1_PUB_ZQ2PR)
-#define DDR1_PUB_ZQ2DR (0x3000 + (0x9A << 2))
-#define P_DDR1_PUB_ZQ2DR                MMC_REG_ADDR(DDR1_PUB_ZQ2DR)
-#define DDR1_PUB_ZQ2SR (0x3000 + (0x9B << 2))
-#define P_DDR1_PUB_ZQ2SR                MMC_REG_ADDR(DDR1_PUB_ZQ2SR)
-#define DDR1_PUB_ZQ3PR (0x3000 + (0x9D << 2))
-#define P_DDR1_PUB_ZQ3PR                MMC_REG_ADDR(DDR1_PUB_ZQ3PR)
-#define DDR1_PUB_ZQ3DR (0x3000 + (0x9E << 2))
-#define P_DDR1_PUB_ZQ3DR                MMC_REG_ADDR(DDR1_PUB_ZQ3DR)
-#define DDR1_PUB_ZQ3SR (0x3000 + (0x9F << 2))
-#define P_DDR1_PUB_ZQ3SR                MMC_REG_ADDR(DDR1_PUB_ZQ3SR)
-#define DDR1_PUB_DX0GCR0 (0x3000 + (0xA0 << 2))
-#define P_DDR1_PUB_DX0GCR0              MMC_REG_ADDR(DDR1_PUB_DX0GCR0)
-#define DDR1_PUB_DX0GCR1 (0x3000 + (0xA1 << 2))
-#define P_DDR1_PUB_DX0GCR1              MMC_REG_ADDR(DDR1_PUB_DX0GCR1)
-#define DDR1_PUB_DX0GCR2 (0x3000 + (0xA2 << 2))
-#define P_DDR1_PUB_DX0GCR2              MMC_REG_ADDR(DDR1_PUB_DX0GCR2)
-#define DDR1_PUB_DX0GCR3 (0x3000 + (0xA3 << 2))
-#define P_DDR1_PUB_DX0GCR3              MMC_REG_ADDR(DDR1_PUB_DX0GCR3)
-#define DDR1_PUB_DX0GSR0 (0x3000 + (0xA4 << 2))
-#define P_DDR1_PUB_DX0GSR0              MMC_REG_ADDR(DDR1_PUB_DX0GSR0)
-#define DDR1_PUB_DX0GSR1 (0x3000 + (0xA5 << 2))
-#define P_DDR1_PUB_DX0GSR1              MMC_REG_ADDR(DDR1_PUB_DX0GSR1)
-#define DDR1_PUB_DX0GSR2 (0x3000 + (0xA6 << 2))
-#define P_DDR1_PUB_DX0GSR2              MMC_REG_ADDR(DDR1_PUB_DX0GSR2)
-#define DDR1_PUB_DX0BDLR0 (0x3000 + (0xA7 << 2))
-#define P_DDR1_PUB_DX0BDLR0             MMC_REG_ADDR(DDR1_PUB_DX0BDLR0)
-#define DDR1_PUB_DX0BDLR1 (0x3000 + (0xA8 << 2))
-#define P_DDR1_PUB_DX0BDLR1             MMC_REG_ADDR(DDR1_PUB_DX0BDLR1)
-#define DDR1_PUB_DX0BDLR2 (0x3000 + (0xA9 << 2))
-#define P_DDR1_PUB_DX0BDLR2             MMC_REG_ADDR(DDR1_PUB_DX0BDLR2)
-#define DDR1_PUB_DX0BDLR3 (0x3000 + (0xAA << 2))
-#define P_DDR1_PUB_DX0BDLR3             MMC_REG_ADDR(DDR1_PUB_DX0BDLR3)
-#define DDR1_PUB_DX0BDLR4 (0x3000 + (0xAB << 2))
-#define P_DDR1_PUB_DX0BDLR4             MMC_REG_ADDR(DDR1_PUB_DX0BDLR4)
-#define DDR1_PUB_DX0BDLR5 (0x3000 + (0xAC << 2))
-#define P_DDR1_PUB_DX0BDLR5             MMC_REG_ADDR(DDR1_PUB_DX0BDLR5)
-#define DDR1_PUB_DX0BDLR6 (0x3000 + (0xAD << 2))
-#define P_DDR1_PUB_DX0BDLR6             MMC_REG_ADDR(DDR1_PUB_DX0BDLR6)
-#define DDR1_PUB_DX0LCDLR0 (0x3000 + (0xAE << 2))
-#define P_DDR1_PUB_DX0LCDLR0            MMC_REG_ADDR(DDR1_PUB_DX0LCDLR0)
-#define DDR1_PUB_DX0LCDLR1 (0x3000 + (0xAF << 2))
-#define P_DDR1_PUB_DX0LCDLR1            MMC_REG_ADDR(DDR1_PUB_DX0LCDLR1)
-#define DDR1_PUB_DX0LCDLR2 (0x3000 + (0xB0 << 2))
-#define P_DDR1_PUB_DX0LCDLR2            MMC_REG_ADDR(DDR1_PUB_DX0LCDLR2)
-#define DDR1_PUB_DX0MDLR (0x3000 + (0xB1 << 2))
-#define P_DDR1_PUB_DX0MDLR              MMC_REG_ADDR(DDR1_PUB_DX0MDLR)
-#define DDR1_PUB_DX0GTR (0x3000 + (0xB2 << 2))
-#define P_DDR1_PUB_DX0GTR               MMC_REG_ADDR(DDR1_PUB_DX0GTR)
-#define DDR1_PUB_DX1GCR0 (0x3000 + (0xC0 << 2))
-#define P_DDR1_PUB_DX1GCR0              MMC_REG_ADDR(DDR1_PUB_DX1GCR0)
-#define DDR1_PUB_DX1GCR1 (0x3000 + (0xC1 << 2))
-#define P_DDR1_PUB_DX1GCR1              MMC_REG_ADDR(DDR1_PUB_DX1GCR1)
-#define DDR1_PUB_DX1GCR2 (0x3000 + (0xC2 << 2))
-#define P_DDR1_PUB_DX1GCR2              MMC_REG_ADDR(DDR1_PUB_DX1GCR2)
-#define DDR1_PUB_DX1GCR3 (0x3000 + (0xC3 << 2))
-#define P_DDR1_PUB_DX1GCR3              MMC_REG_ADDR(DDR1_PUB_DX1GCR3)
-#define DDR1_PUB_DX1GSR0 (0x3000 + (0xC4 << 2))
-#define P_DDR1_PUB_DX1GSR0              MMC_REG_ADDR(DDR1_PUB_DX1GSR0)
-#define DDR1_PUB_DX1GSR1 (0x3000 + (0xC5 << 2))
-#define P_DDR1_PUB_DX1GSR1              MMC_REG_ADDR(DDR1_PUB_DX1GSR1)
-#define DDR1_PUB_DX1GSR2 (0x3000 + (0xC6 << 2))
-#define P_DDR1_PUB_DX1GSR2              MMC_REG_ADDR(DDR1_PUB_DX1GSR2)
-#define DDR1_PUB_DX1BDLR0 (0x3000 + (0xC7 << 2))
-#define P_DDR1_PUB_DX1BDLR0             MMC_REG_ADDR(DDR1_PUB_DX1BDLR0)
-#define DDR1_PUB_DX1BDLR1 (0x3000 + (0xC8 << 2))
-#define P_DDR1_PUB_DX1BDLR1             MMC_REG_ADDR(DDR1_PUB_DX1BDLR1)
-#define DDR1_PUB_DX1BDLR2 (0x3000 + (0xC9 << 2))
-#define P_DDR1_PUB_DX1BDLR2             MMC_REG_ADDR(DDR1_PUB_DX1BDLR2)
-#define DDR1_PUB_DX1BDLR3 (0x3000 + (0xCA << 2))
-#define P_DDR1_PUB_DX1BDLR3             MMC_REG_ADDR(DDR1_PUB_DX1BDLR3)
-#define DDR1_PUB_DX1BDLR4 (0x3000 + (0xCB << 2))
-#define P_DDR1_PUB_DX1BDLR4             MMC_REG_ADDR(DDR1_PUB_DX1BDLR4)
-#define DDR1_PUB_DX1BDLR5 (0x3000 + (0xCC << 2))
-#define P_DDR1_PUB_DX1BDLR5             MMC_REG_ADDR(DDR1_PUB_DX1BDLR5)
-#define DDR1_PUB_DX1BDLR6 (0x3000 + (0xCD << 2))
-#define P_DDR1_PUB_DX1BDLR6             MMC_REG_ADDR(DDR1_PUB_DX1BDLR6)
-#define DDR1_PUB_DX1LCDLR0 (0x3000 + (0xCE << 2))
-#define P_DDR1_PUB_DX1LCDLR0            MMC_REG_ADDR(DDR1_PUB_DX1LCDLR0)
-#define DDR1_PUB_DX1LCDLR1 (0x3000 + (0xCF << 2))
-#define P_DDR1_PUB_DX1LCDLR1            MMC_REG_ADDR(DDR1_PUB_DX1LCDLR1)
-#define DDR1_PUB_DX1LCDLR2 (0x3000 + (0xD0 << 2))
-#define P_DDR1_PUB_DX1LCDLR2            MMC_REG_ADDR(DDR1_PUB_DX1LCDLR2)
-#define DDR1_PUB_DX1MDLR (0x3000 + (0xD1 << 2))
-#define P_DDR1_PUB_DX1MDLR              MMC_REG_ADDR(DDR1_PUB_DX1MDLR)
-#define DDR1_PUB_DX1GTR (0x3000 + (0xD2 << 2))
-#define P_DDR1_PUB_DX1GTR               MMC_REG_ADDR(DDR1_PUB_DX1GTR)
-#define DDR1_PUB_DX2GCR0 (0x3000 + (0xE0 << 2))
-#define P_DDR1_PUB_DX2GCR0              MMC_REG_ADDR(DDR1_PUB_DX2GCR0)
-#define DDR1_PUB_DX2GCR1 (0x3000 + (0xE1 << 2))
-#define P_DDR1_PUB_DX2GCR1              MMC_REG_ADDR(DDR1_PUB_DX2GCR1)
-#define DDR1_PUB_DX2GCR2 (0x3000 + (0xE2 << 2))
-#define P_DDR1_PUB_DX2GCR2              MMC_REG_ADDR(DDR1_PUB_DX2GCR2)
-#define DDR1_PUB_DX2GCR3 (0x3000 + (0xE3 << 2))
-#define P_DDR1_PUB_DX2GCR3              MMC_REG_ADDR(DDR1_PUB_DX2GCR3)
-#define DDR1_PUB_DX2GSR0 (0x3000 + (0xE4 << 2))
-#define P_DDR1_PUB_DX2GSR0              MMC_REG_ADDR(DDR1_PUB_DX2GSR0)
-#define DDR1_PUB_DX2GSR1 (0x3000 + (0xE5 << 2))
-#define P_DDR1_PUB_DX2GSR1              MMC_REG_ADDR(DDR1_PUB_DX2GSR1)
-#define DDR1_PUB_DX2GSR2 (0x3000 + (0xE6 << 2))
-#define P_DDR1_PUB_DX2GSR2              MMC_REG_ADDR(DDR1_PUB_DX2GSR2)
-#define DDR1_PUB_DX2BDLR0 (0x3000 + (0xE7 << 2))
-#define P_DDR1_PUB_DX2BDLR0             MMC_REG_ADDR(DDR1_PUB_DX2BDLR0)
-#define DDR1_PUB_DX2BDLR1 (0x3000 + (0xE8 << 2))
-#define P_DDR1_PUB_DX2BDLR1             MMC_REG_ADDR(DDR1_PUB_DX2BDLR1)
-#define DDR1_PUB_DX2BDLR2 (0x3000 + (0xE9 << 2))
-#define P_DDR1_PUB_DX2BDLR2             MMC_REG_ADDR(DDR1_PUB_DX2BDLR2)
-#define DDR1_PUB_DX2BDLR3 (0x3000 + (0xEA << 2))
-#define P_DDR1_PUB_DX2BDLR3             MMC_REG_ADDR(DDR1_PUB_DX2BDLR3)
-#define DDR1_PUB_DX2BDLR4 (0x3000 + (0xEB << 2))
-#define P_DDR1_PUB_DX2BDLR4             MMC_REG_ADDR(DDR1_PUB_DX2BDLR4)
-#define DDR1_PUB_DX2BDLR5 (0x3000 + (0xEC << 2))
-#define P_DDR1_PUB_DX2BDLR5             MMC_REG_ADDR(DDR1_PUB_DX2BDLR5)
-#define DDR1_PUB_DX2BDLR6 (0x3000 + (0xED << 2))
-#define P_DDR1_PUB_DX2BDLR6             MMC_REG_ADDR(DDR1_PUB_DX2BDLR6)
-#define DDR1_PUB_DX2LCDLR0 (0x3000 + (0xEE << 2))
-#define P_DDR1_PUB_DX2LCDLR0            MMC_REG_ADDR(DDR1_PUB_DX2LCDLR0)
-#define DDR1_PUB_DX2LCDLR1 (0x3000 + (0xEF << 2))
-#define P_DDR1_PUB_DX2LCDLR1            MMC_REG_ADDR(DDR1_PUB_DX2LCDLR1)
-#define DDR1_PUB_DX2LCDLR2 (0x3000 + (0xF0 << 2))
-#define P_DDR1_PUB_DX2LCDLR2            MMC_REG_ADDR(DDR1_PUB_DX2LCDLR2)
-#define DDR1_PUB_DX2MDLR (0x3000 + (0xF1 << 2))
-#define P_DDR1_PUB_DX2MDLR              MMC_REG_ADDR(DDR1_PUB_DX2MDLR)
-#define DDR1_PUB_DX2GTR (0x3000 + (0xF2 << 2))
-#define P_DDR1_PUB_DX2GTR               MMC_REG_ADDR(DDR1_PUB_DX2GTR)
-#define DDR1_PUB_DX3GCR0 (0x3000 + (0x100 << 2))
-#define P_DDR1_PUB_DX3GCR0              MMC_REG_ADDR(DDR1_PUB_DX3GCR0)
-#define DDR1_PUB_DX3GCR1 (0x3000 + (0x101 << 2))
-#define P_DDR1_PUB_DX3GCR1              MMC_REG_ADDR(DDR1_PUB_DX3GCR1)
-#define DDR1_PUB_DX3GCR2 (0x3000 + (0x102 << 2))
-#define P_DDR1_PUB_DX3GCR2              MMC_REG_ADDR(DDR1_PUB_DX3GCR2)
-#define DDR1_PUB_DX3GCR3 (0x3000 + (0x103 << 2))
-#define P_DDR1_PUB_DX3GCR3              MMC_REG_ADDR(DDR1_PUB_DX3GCR3)
-#define DDR1_PUB_DX3GSR0 (0x3000 + (0x104 << 2))
-#define P_DDR1_PUB_DX3GSR0              MMC_REG_ADDR(DDR1_PUB_DX3GSR0)
-#define DDR1_PUB_DX3GSR1 (0x3000 + (0x105 << 2))
-#define P_DDR1_PUB_DX3GSR1              MMC_REG_ADDR(DDR1_PUB_DX3GSR1)
-#define DDR1_PUB_DX3GSR2 (0x3000 + (0x106 << 2))
-#define P_DDR1_PUB_DX3GSR2              MMC_REG_ADDR(DDR1_PUB_DX3GSR2)
-#define DDR1_PUB_DX3BDLR0 (0x3000 + (0x107 << 2))
-#define P_DDR1_PUB_DX3BDLR0             MMC_REG_ADDR(DDR1_PUB_DX3BDLR0)
-#define DDR1_PUB_DX3BDLR1 (0x3000 + (0x108 << 2))
-#define P_DDR1_PUB_DX3BDLR1             MMC_REG_ADDR(DDR1_PUB_DX3BDLR1)
-#define DDR1_PUB_DX3BDLR2 (0x3000 + (0x109 << 2))
-#define P_DDR1_PUB_DX3BDLR2             MMC_REG_ADDR(DDR1_PUB_DX3BDLR2)
-#define DDR1_PUB_DX3BDLR3 (0x3000 + (0x10A << 2))
-#define P_DDR1_PUB_DX3BDLR3             MMC_REG_ADDR(DDR1_PUB_DX3BDLR3)
-#define DDR1_PUB_DX3BDLR4 (0x3000 + (0x10B << 2))
-#define P_DDR1_PUB_DX3BDLR4             MMC_REG_ADDR(DDR1_PUB_DX3BDLR4)
-#define DDR1_PUB_DX3BDLR5 (0x3000 + (0x10C << 2))
-#define P_DDR1_PUB_DX3BDLR5             MMC_REG_ADDR(DDR1_PUB_DX3BDLR5)
-#define DDR1_PUB_DX3BDLR6 (0x3000 + (0x10D << 2))
-#define P_DDR1_PUB_DX3BDLR6             MMC_REG_ADDR(DDR1_PUB_DX3BDLR6)
-#define DDR1_PUB_DX3LCDLR0 (0x3000 + (0x10E << 2))
-#define P_DDR1_PUB_DX3LCDLR0            MMC_REG_ADDR(DDR1_PUB_DX3LCDLR0)
-#define DDR1_PUB_DX3LCDLR1 (0x3000 + (0x10F << 2))
-#define P_DDR1_PUB_DX3LCDLR1            MMC_REG_ADDR(DDR1_PUB_DX3LCDLR1)
-#define DDR1_PUB_DX3LCDLR2 (0x3000 + (0x110 << 2))
-#define P_DDR1_PUB_DX3LCDLR2            MMC_REG_ADDR(DDR1_PUB_DX3LCDLR2)
-#define DDR1_PUB_DX3MDLR (0x3000 + (0x111 << 2))
-#define P_DDR1_PUB_DX3MDLR              MMC_REG_ADDR(DDR1_PUB_DX3MDLR)
-#define DDR1_PUB_DX3GTR (0x3000 + (0x112 << 2))
-#define P_DDR1_PUB_DX3GTR               MMC_REG_ADDR(DDR1_PUB_DX3GTR)
-#define DDR1_PUB_DX4GCR0 (0x3000 + (0x120 << 2))
-#define P_DDR1_PUB_DX4GCR0              MMC_REG_ADDR(DDR1_PUB_DX4GCR0)
-#define DDR1_PUB_DX4GCR1 (0x3000 + (0x121 << 2))
-#define P_DDR1_PUB_DX4GCR1              MMC_REG_ADDR(DDR1_PUB_DX4GCR1)
-#define DDR1_PUB_DX4GCR2 (0x3000 + (0x122 << 2))
-#define P_DDR1_PUB_DX4GCR2              MMC_REG_ADDR(DDR1_PUB_DX4GCR2)
-#define DDR1_PUB_DX4GCR3 (0x3000 + (0x123 << 2))
-#define P_DDR1_PUB_DX4GCR3              MMC_REG_ADDR(DDR1_PUB_DX4GCR3)
-#define DDR1_PUB_DX4GSR0 (0x3000 + (0x124 << 2))
-#define P_DDR1_PUB_DX4GSR0              MMC_REG_ADDR(DDR1_PUB_DX4GSR0)
-#define DDR1_PUB_DX4GSR1 (0x3000 + (0x125 << 2))
-#define P_DDR1_PUB_DX4GSR1              MMC_REG_ADDR(DDR1_PUB_DX4GSR1)
-#define DDR1_PUB_DX4GSR2 (0x3000 + (0x126 << 2))
-#define P_DDR1_PUB_DX4GSR2              MMC_REG_ADDR(DDR1_PUB_DX4GSR2)
-#define DDR1_PUB_DX4BDLR0 (0x3000 + (0x127 << 2))
-#define P_DDR1_PUB_DX4BDLR0             MMC_REG_ADDR(DDR1_PUB_DX4BDLR0)
-#define DDR1_PUB_DX4BDLR1 (0x3000 + (0x128 << 2))
-#define P_DDR1_PUB_DX4BDLR1             MMC_REG_ADDR(DDR1_PUB_DX4BDLR1)
-#define DDR1_PUB_DX4BDLR2 (0x3000 + (0x129 << 2))
-#define P_DDR1_PUB_DX4BDLR2             MMC_REG_ADDR(DDR1_PUB_DX4BDLR2)
-#define DDR1_PUB_DX4BDLR3 (0x3000 + (0x12A << 2))
-#define P_DDR1_PUB_DX4BDLR3             MMC_REG_ADDR(DDR1_PUB_DX4BDLR3)
-#define DDR1_PUB_DX4BDLR4 (0x3000 + (0x12B << 2))
-#define P_DDR1_PUB_DX4BDLR4             MMC_REG_ADDR(DDR1_PUB_DX4BDLR4)
-#define DDR1_PUB_DX4BDLR5 (0x3000 + (0x12C << 2))
-#define P_DDR1_PUB_DX4BDLR5             MMC_REG_ADDR(DDR1_PUB_DX4BDLR5)
-#define DDR1_PUB_DX4BDLR6 (0x3000 + (0x12D << 2))
-#define P_DDR1_PUB_DX4BDLR6             MMC_REG_ADDR(DDR1_PUB_DX4BDLR6)
-#define DDR1_PUB_DX4LCDLR0 (0x3000 + (0x12E << 2))
-#define P_DDR1_PUB_DX4LCDLR0            MMC_REG_ADDR(DDR1_PUB_DX4LCDLR0)
-#define DDR1_PUB_DX4LCDLR1 (0x3000 + (0x12F << 2))
-#define P_DDR1_PUB_DX4LCDLR1            MMC_REG_ADDR(DDR1_PUB_DX4LCDLR1)
-#define DDR1_PUB_DX4LCDLR2 (0x3000 + (0x130 << 2))
-#define P_DDR1_PUB_DX4LCDLR2            MMC_REG_ADDR(DDR1_PUB_DX4LCDLR2)
-#define DDR1_PUB_DX4MDLR (0x3000 + (0x131 << 2))
-#define P_DDR1_PUB_DX4MDLR              MMC_REG_ADDR(DDR1_PUB_DX4MDLR)
-#define DDR1_PUB_DX4GTR (0x3000 + (0x132 << 2))
-#define P_DDR1_PUB_DX4GTR               MMC_REG_ADDR(DDR1_PUB_DX4GTR)
-#define DDR1_PUB_DX5GCR0 (0x3000 + (0x140 << 2))
-#define P_DDR1_PUB_DX5GCR0              MMC_REG_ADDR(DDR1_PUB_DX5GCR0)
-#define DDR1_PUB_DX5GCR1 (0x3000 + (0x141 << 2))
-#define P_DDR1_PUB_DX5GCR1              MMC_REG_ADDR(DDR1_PUB_DX5GCR1)
-#define DDR1_PUB_DX5GCR2 (0x3000 + (0x142 << 2))
-#define P_DDR1_PUB_DX5GCR2              MMC_REG_ADDR(DDR1_PUB_DX5GCR2)
-#define DDR1_PUB_DX5GCR3 (0x3000 + (0x143 << 2))
-#define P_DDR1_PUB_DX5GCR3              MMC_REG_ADDR(DDR1_PUB_DX5GCR3)
-#define DDR1_PUB_DX5GSR0 (0x3000 + (0x144 << 2))
-#define P_DDR1_PUB_DX5GSR0              MMC_REG_ADDR(DDR1_PUB_DX5GSR0)
-#define DDR1_PUB_DX5GSR1 (0x3000 + (0x145 << 2))
-#define P_DDR1_PUB_DX5GSR1              MMC_REG_ADDR(DDR1_PUB_DX5GSR1)
-#define DDR1_PUB_DX5GSR2 (0x3000 + (0x146 << 2))
-#define P_DDR1_PUB_DX5GSR2              MMC_REG_ADDR(DDR1_PUB_DX5GSR2)
-#define DDR1_PUB_DX5BDLR0 (0x3000 + (0x147 << 2))
-#define P_DDR1_PUB_DX5BDLR0             MMC_REG_ADDR(DDR1_PUB_DX5BDLR0)
-#define DDR1_PUB_DX5BDLR1 (0x3000 + (0x148 << 2))
-#define P_DDR1_PUB_DX5BDLR1             MMC_REG_ADDR(DDR1_PUB_DX5BDLR1)
-#define DDR1_PUB_DX5BDLR2 (0x3000 + (0x149 << 2))
-#define P_DDR1_PUB_DX5BDLR2             MMC_REG_ADDR(DDR1_PUB_DX5BDLR2)
-#define DDR1_PUB_DX5BDLR3 (0x3000 + (0x14A << 2))
-#define P_DDR1_PUB_DX5BDLR3             MMC_REG_ADDR(DDR1_PUB_DX5BDLR3)
-#define DDR1_PUB_DX5BDLR4 (0x3000 + (0x14B << 2))
-#define P_DDR1_PUB_DX5BDLR4             MMC_REG_ADDR(DDR1_PUB_DX5BDLR4)
-#define DDR1_PUB_DX5BDLR5 (0x3000 + (0x14C << 2))
-#define P_DDR1_PUB_DX5BDLR5             MMC_REG_ADDR(DDR1_PUB_DX5BDLR5)
-#define DDR1_PUB_DX5BDLR6 (0x3000 + (0x14D << 2))
-#define P_DDR1_PUB_DX5BDLR6             MMC_REG_ADDR(DDR1_PUB_DX5BDLR6)
-#define DDR1_PUB_DX5LCDLR0 (0x3000 + (0x14E << 2))
-#define P_DDR1_PUB_DX5LCDLR0            MMC_REG_ADDR(DDR1_PUB_DX5LCDLR0)
-#define DDR1_PUB_DX5LCDLR1 (0x3000 + (0x14F << 2))
-#define P_DDR1_PUB_DX5LCDLR1            MMC_REG_ADDR(DDR1_PUB_DX5LCDLR1)
-#define DDR1_PUB_DX5LCDLR2 (0x3000 + (0x150 << 2))
-#define P_DDR1_PUB_DX5LCDLR2            MMC_REG_ADDR(DDR1_PUB_DX5LCDLR2)
-#define DDR1_PUB_DX5MDLR (0x3000 + (0x151 << 2))
-#define P_DDR1_PUB_DX5MDLR              MMC_REG_ADDR(DDR1_PUB_DX5MDLR)
-#define DDR1_PUB_DX5GTR (0x3000 + (0x152 << 2))
-#define P_DDR1_PUB_DX5GTR               MMC_REG_ADDR(DDR1_PUB_DX5GTR)
-#define DDR1_PUB_DX6GCR0 (0x3000 + (0x160 << 2))
-#define P_DDR1_PUB_DX6GCR0              MMC_REG_ADDR(DDR1_PUB_DX6GCR0)
-#define DDR1_PUB_DX6GCR1 (0x3000 + (0x161 << 2))
-#define P_DDR1_PUB_DX6GCR1              MMC_REG_ADDR(DDR1_PUB_DX6GCR1)
-#define DDR1_PUB_DX6GCR2 (0x3000 + (0x162 << 2))
-#define P_DDR1_PUB_DX6GCR2              MMC_REG_ADDR(DDR1_PUB_DX6GCR2)
-#define DDR1_PUB_DX6GCR3 (0x3000 + (0x163 << 2))
-#define P_DDR1_PUB_DX6GCR3              MMC_REG_ADDR(DDR1_PUB_DX6GCR3)
-#define DDR1_PUB_DX6GSR0 (0x3000 + (0x164 << 2))
-#define P_DDR1_PUB_DX6GSR0              MMC_REG_ADDR(DDR1_PUB_DX6GSR0)
-#define DDR1_PUB_DX6GSR1 (0x3000 + (0x165 << 2))
-#define P_DDR1_PUB_DX6GSR1              MMC_REG_ADDR(DDR1_PUB_DX6GSR1)
-#define DDR1_PUB_DX6GSR2 (0x3000 + (0x166 << 2))
-#define P_DDR1_PUB_DX6GSR2              MMC_REG_ADDR(DDR1_PUB_DX6GSR2)
-#define DDR1_PUB_DX6BDLR0 (0x3000 + (0x167 << 2))
-#define P_DDR1_PUB_DX6BDLR0             MMC_REG_ADDR(DDR1_PUB_DX6BDLR0)
-#define DDR1_PUB_DX6BDLR1 (0x3000 + (0x168 << 2))
-#define P_DDR1_PUB_DX6BDLR1             MMC_REG_ADDR(DDR1_PUB_DX6BDLR1)
-#define DDR1_PUB_DX6BDLR2 (0x3000 + (0x169 << 2))
-#define P_DDR1_PUB_DX6BDLR2             MMC_REG_ADDR(DDR1_PUB_DX6BDLR2)
-#define DDR1_PUB_DX6BDLR3 (0x3000 + (0x16A << 2))
-#define P_DDR1_PUB_DX6BDLR3             MMC_REG_ADDR(DDR1_PUB_DX6BDLR3)
-#define DDR1_PUB_DX6BDLR4 (0x3000 + (0x16B << 2))
-#define P_DDR1_PUB_DX6BDLR4             MMC_REG_ADDR(DDR1_PUB_DX6BDLR4)
-#define DDR1_PUB_DX6BDLR5 (0x3000 + (0x16C << 2))
-#define P_DDR1_PUB_DX6BDLR5             MMC_REG_ADDR(DDR1_PUB_DX6BDLR5)
-#define DDR1_PUB_DX6BDLR6 (0x3000 + (0x16D << 2))
-#define P_DDR1_PUB_DX6BDLR6             MMC_REG_ADDR(DDR1_PUB_DX6BDLR6)
-#define DDR1_PUB_DX6LCDLR0 (0x3000 + (0x16E << 2))
-#define P_DDR1_PUB_DX6LCDLR0            MMC_REG_ADDR(DDR1_PUB_DX6LCDLR0)
-#define DDR1_PUB_DX6LCDLR1 (0x3000 + (0x16F << 2))
-#define P_DDR1_PUB_DX6LCDLR1            MMC_REG_ADDR(DDR1_PUB_DX6LCDLR1)
-#define DDR1_PUB_DX6LCDLR2 (0x3000 + (0x170 << 2))
-#define P_DDR1_PUB_DX6LCDLR2            MMC_REG_ADDR(DDR1_PUB_DX6LCDLR2)
-#define DDR1_PUB_DX6MDLR (0x3000 + (0x171 << 2))
-#define P_DDR1_PUB_DX6MDLR              MMC_REG_ADDR(DDR1_PUB_DX6MDLR)
-#define DDR1_PUB_DX6GTR (0x3000 + (0x172 << 2))
-#define P_DDR1_PUB_DX6GTR               MMC_REG_ADDR(DDR1_PUB_DX6GTR)
-#define DDR1_PUB_DX7GCR0 (0x3000 + (0x180 << 2))
-#define P_DDR1_PUB_DX7GCR0              MMC_REG_ADDR(DDR1_PUB_DX7GCR0)
-#define DDR1_PUB_DX7GCR1 (0x3000 + (0x181 << 2))
-#define P_DDR1_PUB_DX7GCR1              MMC_REG_ADDR(DDR1_PUB_DX7GCR1)
-#define DDR1_PUB_DX7GCR2 (0x3000 + (0x182 << 2))
-#define P_DDR1_PUB_DX7GCR2              MMC_REG_ADDR(DDR1_PUB_DX7GCR2)
-#define DDR1_PUB_DX7GCR3 (0x3000 + (0x183 << 2))
-#define P_DDR1_PUB_DX7GCR3              MMC_REG_ADDR(DDR1_PUB_DX7GCR3)
-#define DDR1_PUB_DX7GSR0 (0x3000 + (0x184 << 2))
-#define P_DDR1_PUB_DX7GSR0              MMC_REG_ADDR(DDR1_PUB_DX7GSR0)
-#define DDR1_PUB_DX7GSR1 (0x3000 + (0x185 << 2))
-#define P_DDR1_PUB_DX7GSR1              MMC_REG_ADDR(DDR1_PUB_DX7GSR1)
-#define DDR1_PUB_DX7GSR2 (0x3000 + (0x186 << 2))
-#define P_DDR1_PUB_DX7GSR2              MMC_REG_ADDR(DDR1_PUB_DX7GSR2)
-#define DDR1_PUB_DX7BDLR0 (0x3000 + (0x187 << 2))
-#define P_DDR1_PUB_DX7BDLR0             MMC_REG_ADDR(DDR1_PUB_DX7BDLR0)
-#define DDR1_PUB_DX7BDLR1 (0x3000 + (0x188 << 2))
-#define P_DDR1_PUB_DX7BDLR1             MMC_REG_ADDR(DDR1_PUB_DX7BDLR1)
-#define DDR1_PUB_DX7BDLR2 (0x3000 + (0x189 << 2))
-#define P_DDR1_PUB_DX7BDLR2             MMC_REG_ADDR(DDR1_PUB_DX7BDLR2)
-#define DDR1_PUB_DX7BDLR3 (0x3000 + (0x18A << 2))
-#define P_DDR1_PUB_DX7BDLR3             MMC_REG_ADDR(DDR1_PUB_DX7BDLR3)
-#define DDR1_PUB_DX7BDLR4 (0x3000 + (0x18B << 2))
-#define P_DDR1_PUB_DX7BDLR4             MMC_REG_ADDR(DDR1_PUB_DX7BDLR4)
-#define DDR1_PUB_DX7BDLR5 (0x3000 + (0x18C << 2))
-#define P_DDR1_PUB_DX7BDLR5             MMC_REG_ADDR(DDR1_PUB_DX7BDLR5)
-#define DDR1_PUB_DX7BDLR6 (0x3000 + (0x18D << 2))
-#define P_DDR1_PUB_DX7BDLR6             MMC_REG_ADDR(DDR1_PUB_DX7BDLR6)
-#define DDR1_PUB_DX7LCDLR0 (0x3000 + (0x18E << 2))
-#define P_DDR1_PUB_DX7LCDLR0            MMC_REG_ADDR(DDR1_PUB_DX7LCDLR0)
-#define DDR1_PUB_DX7LCDLR1 (0x3000 + (0x18F << 2))
-#define P_DDR1_PUB_DX7LCDLR1            MMC_REG_ADDR(DDR1_PUB_DX7LCDLR1)
-#define DDR1_PUB_DX7LCDLR2 (0x3000 + (0x190 << 2))
-#define P_DDR1_PUB_DX7LCDLR2            MMC_REG_ADDR(DDR1_PUB_DX7LCDLR2)
-#define DDR1_PUB_DX7MDLR (0x3000 + (0x191 << 2))
-#define P_DDR1_PUB_DX7MDLR              MMC_REG_ADDR(DDR1_PUB_DX7MDLR)
-#define DDR1_PUB_DX7GTR (0x3000 + (0x192 << 2))
-#define P_DDR1_PUB_DX7GTR               MMC_REG_ADDR(DDR1_PUB_DX7GTR)
-#define DDR1_PUB_DX8GCR0 (0x3000 + (0x1A0 << 2))
-#define P_DDR1_PUB_DX8GCR0              MMC_REG_ADDR(DDR1_PUB_DX8GCR0)
-#define DDR1_PUB_DX8GCR1 (0x3000 + (0x1A1 << 2))
-#define P_DDR1_PUB_DX8GCR1              MMC_REG_ADDR(DDR1_PUB_DX8GCR1)
-#define DDR1_PUB_DX8GCR2 (0x3000 + (0x1A2 << 2))
-#define P_DDR1_PUB_DX8GCR2              MMC_REG_ADDR(DDR1_PUB_DX8GCR2)
-#define DDR1_PUB_DX8GCR3 (0x3000 + (0x1A3 << 2))
-#define P_DDR1_PUB_DX8GCR3              MMC_REG_ADDR(DDR1_PUB_DX8GCR3)
-#define DDR1_PUB_DX8GSR0 (0x3000 + (0x1A4 << 2))
-#define P_DDR1_PUB_DX8GSR0              MMC_REG_ADDR(DDR1_PUB_DX8GSR0)
-#define DDR1_PUB_DX8GSR1 (0x3000 + (0x1A5 << 2))
-#define P_DDR1_PUB_DX8GSR1              MMC_REG_ADDR(DDR1_PUB_DX8GSR1)
-#define DDR1_PUB_DX8GSR2 (0x3000 + (0x1A6 << 2))
-#define P_DDR1_PUB_DX8GSR2              MMC_REG_ADDR(DDR1_PUB_DX8GSR2)
-#define DDR1_PUB_DX8BDLR0 (0x3000 + (0x1A7 << 2))
-#define P_DDR1_PUB_DX8BDLR0             MMC_REG_ADDR(DDR1_PUB_DX8BDLR0)
-#define DDR1_PUB_DX8BDLR1 (0x3000 + (0x1A8 << 2))
-#define P_DDR1_PUB_DX8BDLR1             MMC_REG_ADDR(DDR1_PUB_DX8BDLR1)
-#define DDR1_PUB_DX8BDLR2 (0x3000 + (0x1A9 << 2))
-#define P_DDR1_PUB_DX8BDLR2             MMC_REG_ADDR(DDR1_PUB_DX8BDLR2)
-#define DDR1_PUB_DX8BDLR3 (0x3000 + (0x1AA << 2))
-#define P_DDR1_PUB_DX8BDLR3             MMC_REG_ADDR(DDR1_PUB_DX8BDLR3)
-#define DDR1_PUB_DX8BDLR4 (0x3000 + (0x1AB << 2))
-#define P_DDR1_PUB_DX8BDLR4             MMC_REG_ADDR(DDR1_PUB_DX8BDLR4)
-#define DDR1_PUB_DX8BDLR5 (0x3000 + (0x1AC << 2))
-#define P_DDR1_PUB_DX8BDLR5             MMC_REG_ADDR(DDR1_PUB_DX8BDLR5)
-#define DDR1_PUB_DX8BDLR6 (0x3000 + (0x1AD << 2))
-#define P_DDR1_PUB_DX8BDLR6             MMC_REG_ADDR(DDR1_PUB_DX8BDLR6)
-#define DDR1_PUB_DX8LCDLR0 (0x3000 + (0x1AE << 2))
-#define P_DDR1_PUB_DX8LCDLR0            MMC_REG_ADDR(DDR1_PUB_DX8LCDLR0)
-#define DDR1_PUB_DX8LCDLR1 (0x3000 + (0x1AF << 2))
-#define P_DDR1_PUB_DX8LCDLR1            MMC_REG_ADDR(DDR1_PUB_DX8LCDLR1)
-#define DDR1_PUB_DX8LCDLR2 (0x3000 + (0x1B0 << 2))
-#define P_DDR1_PUB_DX8LCDLR2            MMC_REG_ADDR(DDR1_PUB_DX8LCDLR2)
-#define DDR1_PUB_DX8MDLR (0x3000 + (0x1B1 << 2))
-#define P_DDR1_PUB_DX8MDLR              MMC_REG_ADDR(DDR1_PUB_DX8MDLR)
-#define DDR1_PUB_DX8GTR (0x3000 + (0x1B2 << 2))
-#define P_DDR1_PUB_DX8GTR               MMC_REG_ADDR(DDR1_PUB_DX8GTR)
-/*add from M8m2*/
-#define S_DMC_REG_BASE 0x6000
-#define DMC_REQ_CTRL (S_DMC_REG_BASE + (0x00 << 2))
-#define P_DMC_REQ_CTRL          MMC_REG_ADDR(DMC_REQ_CTRL)
-#define DMC_SOFT_RST (S_DMC_REG_BASE + (0x01 << 2))
-#define P_DMC_SOFT_RST          MMC_REG_ADDR(DMC_SOFT_RST)
-#define DMC_SOFT_RST1 (S_DMC_REG_BASE + (0x02 << 2))
-#define P_DMC_SOFT_RST1                 MMC_REG_ADDR(DMC_SOFT_RST1)
-#define DMC_RST_STS (S_DMC_REG_BASE + (0x03 << 2))
-#define P_DMC_RST_STS           MMC_REG_ADDR(DMC_RST_STS)
-#define DMC_RST_STS1 (S_DMC_REG_BASE + (0x04 << 2))
-#define P_DMC_RST_STS1          MMC_REG_ADDR(DMC_RST_STS1)
-#define DMC_VERSION (S_DMC_REG_BASE + (0x05 << 2))
-#define P_DMC_VERSION           MMC_REG_ADDR(DMC_VERSION)
-#define DMC_DDR_CTRL (S_DMC_REG_BASE + (0x10 << 2))
-#define P_DMC_DDR_CTRL          MMC_REG_ADDR(DMC_DDR_CTRL)
-#define DMC_DDR_CTRL1 (S_DMC_REG_BASE + (0x11 << 2))
-#define P_DMC_DDR_CTRL1                 MMC_REG_ADDR(DMC_DDR_CTRL1)
-#define DC_CAV_LUT_DATAL_M8M2 (S_DMC_REG_BASE + (0x12 << 2))
-#define P_DC_CAV_LUT_DATAL_M8M2 MMC_REG_ADDR(DC_CAV_LUT_DATAL_M8M2)
-#define DC_CAV_LUT_DATAH_M8M2 (S_DMC_REG_BASE + (0x13 << 2))
-#define P_DC_CAV_LUT_DATAH_M8M2 MMC_REG_ADDR(DC_CAV_LUT_DATAH_M8M2)
-#define DC_CAV_LUT_ADDR_M8M2  (S_DMC_REG_BASE + (0x14 << 2))
-#define P_DC_CAV_LUT_ADDR_M8M2  MMC_REG_ADDR(DC_CAV_LUT_ADDR_M8M2)
-#define DC_CAV_LUT_RDATAL_M8M2  (S_DMC_REG_BASE + (0x15 << 2))
-#define P_DC_CAV_LUT_RDATAL_M8M2 MMC_REG_ADDR(DC_CAV_LUT_RDATAL_M8M2)
-#define DC_CAV_LUT_RDATAH_M8M2  (S_DMC_REG_BASE + (0x16 << 2))
-#define P_DC_CAV_LUT_RDATAH_M8M2 MMC_REG_ADDR(DC_CAV_LUT_RDATAH_M8M2)
-#define DMC_2ARB_CTRL (S_DMC_REG_BASE + (0x20 << 2))
-#define P_DMC_2ARB_CTRL                 MMC_REG_ADDR(DMC_2ARB_CTRL)
-#define DMC_REFR_CTRL1 (S_DMC_REG_BASE + (0x23 << 2))
-#define P_DMC_REFR_CTRL1                MMC_REG_ADDR(DMC_REFR_CTRL1)
-#define DMC_REFR_CTRL2 (S_DMC_REG_BASE + (0x24 << 2))
-#define P_DMC_REFR_CTRL2                MMC_REG_ADDR(DMC_REFR_CTRL2)
-#define DMC_PARB_CTRL (S_DMC_REG_BASE + (0x25 << 2))
-#define P_DMC_PARB_CTRL                 MMC_REG_ADDR(DMC_PARB_CTRL)
-#define DMC_MON_CTRL2 (S_DMC_REG_BASE + (0x26 << 2))
-#define P_DMC_MON_CTRL2                 MMC_REG_ADDR(DMC_MON_CTRL2)
-#define DMC_MON_CTRL3 (S_DMC_REG_BASE + (0x27 << 2))
-#define P_DMC_MON_CTRL3                 MMC_REG_ADDR(DMC_MON_CTRL3)
-#define DMC_MON_ALL_REQ_CNT (S_DMC_REG_BASE + (0x28 << 2))
-#define P_DMC_MON_ALL_REQ_CNT           MMC_REG_ADDR(DMC_MON_ALL_REQ_CNT)
-#define DMC_MON_ALL_GRANT_CNT (S_DMC_REG_BASE + (0x29 << 2))
-#define P_DMC_MON_ALL_GRANT_CNT                 \
-	MMC_REG_ADDR(DMC_MON_ALL_GRANT_CNT)
-#define DMC_MON_ONE_GRANT_CNT (S_DMC_REG_BASE + (0x2a << 2))
-#define P_DMC_MON_ONE_GRANT_CNT                 \
-	MMC_REG_ADDR(DMC_MON_ONE_GRANT_CNT)
-#define DMC_CLKG_CTRL0 (S_DMC_REG_BASE + (0x30 << 2))
-#define P_DMC_CLKG_CTRL0                MMC_REG_ADDR(DMC_CLKG_CTRL0)
-#define DMC_CLKG_CTRL1 (S_DMC_REG_BASE + (0x31 << 2))
-#define P_DMC_CLKG_CTRL1                MMC_REG_ADDR(DMC_CLKG_CTRL1)
-#define DMC_CHAN_STS (S_DMC_REG_BASE + (0x32 << 2))
-#define P_DMC_CHAN_STS          MMC_REG_ADDR(DMC_CHAN_STS)
-#define DMC_CMD_FILTER_CTRL1 (S_DMC_REG_BASE + (0x40 << 2))
-#define P_DMC_CMD_FILTER_CTRL1          MMC_REG_ADDR(DMC_CMD_FILTER_CTRL1)
-#define DMC_CMD_FILTER_CTRL2 (S_DMC_REG_BASE + (0x41 << 2))
-#define P_DMC_CMD_FILTER_CTRL2          MMC_REG_ADDR(DMC_CMD_FILTER_CTRL2)
-#define DMC_CMD_FILTER_CTRL3 (S_DMC_REG_BASE + (0x42 << 2))
-#define P_DMC_CMD_FILTER_CTRL3          MMC_REG_ADDR(DMC_CMD_FILTER_CTRL3)
-#define DMC_CMD_FILTER_CTRL4 (S_DMC_REG_BASE + (0x43 << 2))
-#define P_DMC_CMD_FILTER_CTRL4          MMC_REG_ADDR(DMC_CMD_FILTER_CTRL4)
-#define DMC_CMD_BUFFER_CTRL (S_DMC_REG_BASE + (0x44 << 2))
-#define P_DMC_CMD_BUFFER_CTRL           MMC_REG_ADDR(DMC_CMD_BUFFER_CTRL)
-#define DMC_AM0_CHAN_CTRL (S_DMC_REG_BASE + (0x60 << 2))
-#define P_DMC_AM0_CHAN_CTRL             MMC_REG_ADDR(DMC_AM0_CHAN_CTRL)
-#define DMC_AM0_HOLD_CTRL (S_DMC_REG_BASE + (0x61 << 2))
-#define P_DMC_AM0_HOLD_CTRL             MMC_REG_ADDR(DMC_AM0_HOLD_CTRL)
-#define DMC_AM0_QOS_INC (S_DMC_REG_BASE + (0x62 << 2))
-#define P_DMC_AM0_QOS_INC               MMC_REG_ADDR(DMC_AM0_QOS_INC)
-#define DMC_AM0_QOS_INCBK (S_DMC_REG_BASE + (0x63 << 2))
-#define P_DMC_AM0_QOS_INCBK             MMC_REG_ADDR(DMC_AM0_QOS_INCBK)
-#define DMC_AM0_QOS_DEC (S_DMC_REG_BASE + (0x64 << 2))
-#define P_DMC_AM0_QOS_DEC               MMC_REG_ADDR(DMC_AM0_QOS_DEC)
-#define DMC_AM0_QOS_DECBK (S_DMC_REG_BASE + (0x65 << 2))
-#define P_DMC_AM0_QOS_DECBK             MMC_REG_ADDR(DMC_AM0_QOS_DECBK)
-#define DMC_AM0_QOS_DIS (S_DMC_REG_BASE + (0x66 << 2))
-#define P_DMC_AM0_QOS_DIS               MMC_REG_ADDR(DMC_AM0_QOS_DIS)
-#define DMC_AM0_QOS_DISBK (S_DMC_REG_BASE + (0x67 << 2))
-#define P_DMC_AM0_QOS_DISBK             MMC_REG_ADDR(DMC_AM0_QOS_DISBK)
-#define DMC_AM0_QOS_CTRL0 (S_DMC_REG_BASE + (0x68 << 2))
-#define P_DMC_AM0_QOS_CTRL0             MMC_REG_ADDR(DMC_AM0_QOS_CTRL0)
-#define DMC_AM0_QOS_CTRL1 (S_DMC_REG_BASE + (0x69 << 2))
-#define P_DMC_AM0_QOS_CTRL1             MMC_REG_ADDR(DMC_AM0_QOS_CTRL1)
-#define DMC_AM1_CHAN_CTRL (S_DMC_REG_BASE + (0x6a << 2))
-#define P_DMC_AM1_CHAN_CTRL             MMC_REG_ADDR(DMC_AM1_CHAN_CTRL)
-#define DMC_AM1_HOLD_CTRL (S_DMC_REG_BASE + (0x6b << 2))
-#define P_DMC_AM1_HOLD_CTRL             MMC_REG_ADDR(DMC_AM1_HOLD_CTRL)
-#define DMC_AM1_QOS_INC (S_DMC_REG_BASE + (0x6c << 2))
-#define P_DMC_AM1_QOS_INC               MMC_REG_ADDR(DMC_AM1_QOS_INC)
-#define DMC_AM1_QOS_INCBK (S_DMC_REG_BASE + (0x6d << 2))
-#define P_DMC_AM1_QOS_INCBK             MMC_REG_ADDR(DMC_AM1_QOS_INCBK)
-#define DMC_AM1_QOS_DEC (S_DMC_REG_BASE + (0x6e << 2))
-#define P_DMC_AM1_QOS_DEC               MMC_REG_ADDR(DMC_AM1_QOS_DEC)
-#define DMC_AM1_QOS_DECBK (S_DMC_REG_BASE + (0x6f << 2))
-#define P_DMC_AM1_QOS_DECBK             MMC_REG_ADDR(DMC_AM1_QOS_DECBK)
-#define DMC_AM1_QOS_DIS (S_DMC_REG_BASE + (0x70 << 2))
-#define P_DMC_AM1_QOS_DIS               MMC_REG_ADDR(DMC_AM1_QOS_DIS)
-#define DMC_AM1_QOS_DISBK (S_DMC_REG_BASE + (0x71 << 2))
-#define P_DMC_AM1_QOS_DISBK             MMC_REG_ADDR(DMC_AM1_QOS_DISBK)
-#define DMC_AM1_QOS_CTRL0 (S_DMC_REG_BASE + (0x72 << 2))
-#define P_DMC_AM1_QOS_CTRL0             MMC_REG_ADDR(DMC_AM1_QOS_CTRL0)
-#define DMC_AM1_QOS_CTRL1 (S_DMC_REG_BASE + (0x73 << 2))
-#define P_DMC_AM1_QOS_CTRL1             MMC_REG_ADDR(DMC_AM1_QOS_CTRL1)
-#define DMC_AM2_CHAN_CTRL (S_DMC_REG_BASE + (0x74 << 2))
-#define P_DMC_AM2_CHAN_CTRL             MMC_REG_ADDR(DMC_AM2_CHAN_CTRL)
-#define DMC_AM2_HOLD_CTRL (S_DMC_REG_BASE + (0x75 << 2))
-#define P_DMC_AM2_HOLD_CTRL             MMC_REG_ADDR(DMC_AM2_HOLD_CTRL)
-#define DMC_AM2_QOS_INC (S_DMC_REG_BASE + (0x76 << 2))
-#define P_DMC_AM2_QOS_INC               MMC_REG_ADDR(DMC_AM2_QOS_INC)
-#define DMC_AM2_QOS_INCBK (S_DMC_REG_BASE + (0x77 << 2))
-#define P_DMC_AM2_QOS_INCBK             MMC_REG_ADDR(DMC_AM2_QOS_INCBK)
-#define DMC_AM2_QOS_DEC (S_DMC_REG_BASE + (0x78 << 2))
-#define P_DMC_AM2_QOS_DEC               MMC_REG_ADDR(DMC_AM2_QOS_DEC)
-#define DMC_AM2_QOS_DECBK (S_DMC_REG_BASE + (0x79 << 2))
-#define P_DMC_AM2_QOS_DECBK             MMC_REG_ADDR(DMC_AM2_QOS_DECBK)
-#define DMC_AM2_QOS_DIS (S_DMC_REG_BASE + (0x7a << 2))
-#define P_DMC_AM2_QOS_DIS               MMC_REG_ADDR(DMC_AM2_QOS_DIS)
-#define DMC_AM2_QOS_DISBK (S_DMC_REG_BASE + (0x7b << 2))
-#define P_DMC_AM2_QOS_DISBK             MMC_REG_ADDR(DMC_AM2_QOS_DISBK)
-#define DMC_AM2_QOS_CTRL0 (S_DMC_REG_BASE + (0x7c << 2))
-#define P_DMC_AM2_QOS_CTRL0             MMC_REG_ADDR(DMC_AM2_QOS_CTRL0)
-#define DMC_AM2_QOS_CTRL1 (S_DMC_REG_BASE + (0x7d << 2))
-#define P_DMC_AM2_QOS_CTRL1             MMC_REG_ADDR(DMC_AM2_QOS_CTRL1)
-#define DMC_AM3_CHAN_CTRL (S_DMC_REG_BASE + (0x7e << 2))
-#define P_DMC_AM3_CHAN_CTRL             MMC_REG_ADDR(DMC_AM3_CHAN_CTRL)
-#define DMC_AM3_HOLD_CTRL (S_DMC_REG_BASE + (0x7f << 2))
-#define P_DMC_AM3_HOLD_CTRL             MMC_REG_ADDR(DMC_AM3_HOLD_CTRL)
-#define DMC_AM3_QOS_INC (S_DMC_REG_BASE + (0x80 << 2))
-#define P_DMC_AM3_QOS_INC               MMC_REG_ADDR(DMC_AM3_QOS_INC)
-#define DMC_AM3_QOS_INCBK (S_DMC_REG_BASE + (0x81 << 2))
-#define P_DMC_AM3_QOS_INCBK             MMC_REG_ADDR(DMC_AM3_QOS_INCBK)
-#define DMC_AM3_QOS_DEC (S_DMC_REG_BASE + (0x82 << 2))
-#define P_DMC_AM3_QOS_DEC               MMC_REG_ADDR(DMC_AM3_QOS_DEC)
-#define DMC_AM3_QOS_DECBK (S_DMC_REG_BASE + (0x83 << 2))
-#define P_DMC_AM3_QOS_DECBK             MMC_REG_ADDR(DMC_AM3_QOS_DECBK)
-#define DMC_AM3_QOS_DIS (S_DMC_REG_BASE + (0x84 << 2))
-#define P_DMC_AM3_QOS_DIS               MMC_REG_ADDR(DMC_AM3_QOS_DIS)
-#define DMC_AM3_QOS_DISBK (S_DMC_REG_BASE + (0x85 << 2))
-#define P_DMC_AM3_QOS_DISBK             MMC_REG_ADDR(DMC_AM3_QOS_DISBK)
-#define DMC_AM3_QOS_CTRL0 (S_DMC_REG_BASE + (0x86 << 2))
-#define P_DMC_AM3_QOS_CTRL0             MMC_REG_ADDR(DMC_AM3_QOS_CTRL0)
-#define DMC_AM3_QOS_CTRL1 (S_DMC_REG_BASE + (0x87 << 2))
-#define P_DMC_AM3_QOS_CTRL1             MMC_REG_ADDR(DMC_AM3_QOS_CTRL1)
-#define DMC_AM4_CHAN_CTRL (S_DMC_REG_BASE + (0x88 << 2))
-#define P_DMC_AM4_CHAN_CTRL             MMC_REG_ADDR(DMC_AM4_CHAN_CTRL)
-#define DMC_AM4_HOLD_CTRL (S_DMC_REG_BASE + (0x89 << 2))
-#define P_DMC_AM4_HOLD_CTRL             MMC_REG_ADDR(DMC_AM4_HOLD_CTRL)
-#define DMC_AM4_QOS_INC (S_DMC_REG_BASE + (0x8a << 2))
-#define P_DMC_AM4_QOS_INC               MMC_REG_ADDR(DMC_AM4_QOS_INC)
-#define DMC_AM4_QOS_INCBK (S_DMC_REG_BASE + (0x8b << 2))
-#define P_DMC_AM4_QOS_INCBK             MMC_REG_ADDR(DMC_AM4_QOS_INCBK)
-#define DMC_AM4_QOS_DEC (S_DMC_REG_BASE + (0x8c << 2))
-#define P_DMC_AM4_QOS_DEC               MMC_REG_ADDR(DMC_AM4_QOS_DEC)
-#define DMC_AM4_QOS_DECBK (S_DMC_REG_BASE + (0x8d << 2))
-#define P_DMC_AM4_QOS_DECBK             MMC_REG_ADDR(DMC_AM4_QOS_DECBK)
-#define DMC_AM4_QOS_DIS (S_DMC_REG_BASE + (0x8e << 2))
-#define P_DMC_AM4_QOS_DIS               MMC_REG_ADDR(DMC_AM4_QOS_DIS)
-#define DMC_AM4_QOS_DISBK (S_DMC_REG_BASE + (0x8f << 2))
-#define P_DMC_AM4_QOS_DISBK             MMC_REG_ADDR(DMC_AM4_QOS_DISBK)
-#define DMC_AM4_QOS_CTRL0 (S_DMC_REG_BASE + (0x90 << 2))
-#define P_DMC_AM4_QOS_CTRL0             MMC_REG_ADDR(DMC_AM4_QOS_CTRL0)
-#define DMC_AM4_QOS_CTRL1 (S_DMC_REG_BASE + (0x91 << 2))
-#define P_DMC_AM4_QOS_CTRL1             MMC_REG_ADDR(DMC_AM4_QOS_CTRL1)
-#define DMC_AM5_CHAN_CTRL (S_DMC_REG_BASE + (0x92 << 2))
-#define P_DMC_AM5_CHAN_CTRL             MMC_REG_ADDR(DMC_AM5_CHAN_CTRL)
-#define DMC_AM5_HOLD_CTRL (S_DMC_REG_BASE + (0x93 << 2))
-#define P_DMC_AM5_HOLD_CTRL             MMC_REG_ADDR(DMC_AM5_HOLD_CTRL)
-#define DMC_AM5_QOS_INC (S_DMC_REG_BASE + (0x94 << 2))
-#define P_DMC_AM5_QOS_INC               MMC_REG_ADDR(DMC_AM5_QOS_INC)
-#define DMC_AM5_QOS_INCBK (S_DMC_REG_BASE + (0x95 << 2))
-#define P_DMC_AM5_QOS_INCBK             MMC_REG_ADDR(DMC_AM5_QOS_INCBK)
-#define DMC_AM5_QOS_DEC (S_DMC_REG_BASE + (0x96 << 2))
-#define P_DMC_AM5_QOS_DEC               MMC_REG_ADDR(DMC_AM5_QOS_DEC)
-#define DMC_AM5_QOS_DECBK (S_DMC_REG_BASE + (0x97 << 2))
-#define P_DMC_AM5_QOS_DECBK             MMC_REG_ADDR(DMC_AM5_QOS_DECBK)
-#define DMC_AM5_QOS_DIS (S_DMC_REG_BASE + (0x98 << 2))
-#define P_DMC_AM5_QOS_DIS               MMC_REG_ADDR(DMC_AM5_QOS_DIS)
-#define DMC_AM5_QOS_DISBK (S_DMC_REG_BASE + (0x99 << 2))
-#define P_DMC_AM5_QOS_DISBK             MMC_REG_ADDR(DMC_AM5_QOS_DISBK)
-#define DMC_AM5_QOS_CTRL0 (S_DMC_REG_BASE + (0x9a << 2))
-#define P_DMC_AM5_QOS_CTRL0             MMC_REG_ADDR(DMC_AM5_QOS_CTRL0)
-#define DMC_AM5_QOS_CTRL1 (S_DMC_REG_BASE + (0x9b << 2))
-#define P_DMC_AM5_QOS_CTRL1             MMC_REG_ADDR(DMC_AM5_QOS_CTRL1)
-#define DMC_AM6_CHAN_CTRL (S_DMC_REG_BASE + (0x9c << 2))
-#define P_DMC_AM6_CHAN_CTRL             MMC_REG_ADDR(DMC_AM6_CHAN_CTRL)
-#define DMC_AM6_HOLD_CTRL (S_DMC_REG_BASE + (0x9d << 2))
-#define P_DMC_AM6_HOLD_CTRL             MMC_REG_ADDR(DMC_AM6_HOLD_CTRL)
-#define DMC_AM6_QOS_INC (S_DMC_REG_BASE + (0x9e << 2))
-#define P_DMC_AM6_QOS_INC               MMC_REG_ADDR(DMC_AM6_QOS_INC)
-#define DMC_AM6_QOS_INCBK (S_DMC_REG_BASE + (0x9f << 2))
-#define P_DMC_AM6_QOS_INCBK             MMC_REG_ADDR(DMC_AM6_QOS_INCBK)
-#define DMC_AM6_QOS_DEC (S_DMC_REG_BASE + (0xa0 << 2))
-#define P_DMC_AM6_QOS_DEC               MMC_REG_ADDR(DMC_AM6_QOS_DEC)
-#define DMC_AM6_QOS_DECBK (S_DMC_REG_BASE + (0xa1 << 2))
-#define P_DMC_AM6_QOS_DECBK             MMC_REG_ADDR(DMC_AM6_QOS_DECBK)
-#define DMC_AM6_QOS_DIS (S_DMC_REG_BASE + (0xa2 << 2))
-#define P_DMC_AM6_QOS_DIS               MMC_REG_ADDR(DMC_AM6_QOS_DIS)
-#define DMC_AM6_QOS_DISBK (S_DMC_REG_BASE + (0xa3 << 2))
-#define P_DMC_AM6_QOS_DISBK             MMC_REG_ADDR(DMC_AM6_QOS_DISBK)
-#define DMC_AM6_QOS_CTRL0 (S_DMC_REG_BASE + (0xa4 << 2))
-#define P_DMC_AM6_QOS_CTRL0             MMC_REG_ADDR(DMC_AM6_QOS_CTRL0)
-#define DMC_AM6_QOS_CTRL1 (S_DMC_REG_BASE + (0xa5 << 2))
-#define P_DMC_AM6_QOS_CTRL1             MMC_REG_ADDR(DMC_AM6_QOS_CTRL1)
-#define DMC_AM7_CHAN_CTRL (S_DMC_REG_BASE + (0xa6 << 2))
-#define P_DMC_AM7_CHAN_CTRL             MMC_REG_ADDR(DMC_AM7_CHAN_CTRL)
-#define DMC_AM7_HOLD_CTRL (S_DMC_REG_BASE + (0xa7 << 2))
-#define P_DMC_AM7_HOLD_CTRL             MMC_REG_ADDR(DMC_AM7_HOLD_CTRL)
-#define DMC_AM7_QOS_INC (S_DMC_REG_BASE + (0xa8 << 2))
-#define P_DMC_AM7_QOS_INC               MMC_REG_ADDR(DMC_AM7_QOS_INC)
-#define DMC_AM7_QOS_INCBK (S_DMC_REG_BASE + (0xa9 << 2))
-#define P_DMC_AM7_QOS_INCBK             MMC_REG_ADDR(DMC_AM7_QOS_INCBK)
-#define DMC_AM7_QOS_DEC (S_DMC_REG_BASE + (0xaa << 2))
-#define P_DMC_AM7_QOS_DEC               MMC_REG_ADDR(DMC_AM7_QOS_DEC)
-#define DMC_AM7_QOS_DECBK (S_DMC_REG_BASE + (0xab << 2))
-#define P_DMC_AM7_QOS_DECBK             MMC_REG_ADDR(DMC_AM7_QOS_DECBK)
-#define DMC_AM7_QOS_DIS (S_DMC_REG_BASE + (0xac << 2))
-#define P_DMC_AM7_QOS_DIS               MMC_REG_ADDR(DMC_AM7_QOS_DIS)
-#define DMC_AM7_QOS_DISBK (S_DMC_REG_BASE + (0xad << 2))
-#define P_DMC_AM7_QOS_DISBK             MMC_REG_ADDR(DMC_AM7_QOS_DISBK)
-#define DMC_AM7_QOS_CTRL0 (S_DMC_REG_BASE + (0xae << 2))
-#define P_DMC_AM7_QOS_CTRL0             MMC_REG_ADDR(DMC_AM7_QOS_CTRL0)
-#define DMC_AM7_QOS_CTRL1 (S_DMC_REG_BASE + (0xaf << 2))
-#define P_DMC_AM7_QOS_CTRL1             MMC_REG_ADDR(DMC_AM7_QOS_CTRL1)
-#define DMC_AXI0_CHAN_CTRL (S_DMC_REG_BASE + (0xb0 << 2))
-#define P_DMC_AXI0_CHAN_CTRL            MMC_REG_ADDR(DMC_AXI0_CHAN_CTRL)
-#define DMC_AXI0_HOLD_CTRL (S_DMC_REG_BASE + (0xb1 << 2))
-#define P_DMC_AXI0_HOLD_CTRL            MMC_REG_ADDR(DMC_AXI0_HOLD_CTRL)
-#define DMC_AXI0_QOS_INC (S_DMC_REG_BASE + (0xb2 << 2))
-#define P_DMC_AXI0_QOS_INC              MMC_REG_ADDR(DMC_AXI0_QOS_INC)
-#define DMC_AXI0_QOS_INCBK (S_DMC_REG_BASE + (0xb3 << 2))
-#define P_DMC_AXI0_QOS_INCBK            MMC_REG_ADDR(DMC_AXI0_QOS_INCBK)
-#define DMC_AXI0_QOS_DEC (S_DMC_REG_BASE + (0xb4 << 2))
-#define P_DMC_AXI0_QOS_DEC              MMC_REG_ADDR(DMC_AXI0_QOS_DEC)
-#define DMC_AXI0_QOS_DECBK (S_DMC_REG_BASE + (0xb5 << 2))
-#define P_DMC_AXI0_QOS_DECBK            MMC_REG_ADDR(DMC_AXI0_QOS_DECBK)
-#define DMC_AXI0_QOS_DIS (S_DMC_REG_BASE + (0xb6 << 2))
-#define P_DMC_AXI0_QOS_DIS              MMC_REG_ADDR(DMC_AXI0_QOS_DIS)
-#define DMC_AXI0_QOS_DISBK (S_DMC_REG_BASE + (0xb7 << 2))
-#define P_DMC_AXI0_QOS_DISBK            MMC_REG_ADDR(DMC_AXI0_QOS_DISBK)
-#define DMC_AXI0_QOS_CTRL0 (S_DMC_REG_BASE + (0xb8 << 2))
-#define P_DMC_AXI0_QOS_CTRL0            MMC_REG_ADDR(DMC_AXI0_QOS_CTRL0)
-#define DMC_AXI0_QOS_CTRL1 (S_DMC_REG_BASE + (0xb9 << 2))
-#define P_DMC_AXI0_QOS_CTRL1            MMC_REG_ADDR(DMC_AXI0_QOS_CTRL1)
-#define DMC_AXI1_CHAN_CTRL (S_DMC_REG_BASE + (0xba << 2))
-#define P_DMC_AXI1_CHAN_CTRL            MMC_REG_ADDR(DMC_AXI1_CHAN_CTRL)
-#define DMC_AXI1_HOLD_CTRL (S_DMC_REG_BASE + (0xbb << 2))
-#define P_DMC_AXI1_HOLD_CTRL            MMC_REG_ADDR(DMC_AXI1_HOLD_CTRL)
-#define DMC_AXI1_QOS_INC (S_DMC_REG_BASE + (0xbc << 2))
-#define P_DMC_AXI1_QOS_INC              MMC_REG_ADDR(DMC_AXI1_QOS_INC)
-#define DMC_AXI1_QOS_INCBK (S_DMC_REG_BASE + (0xbd << 2))
-#define P_DMC_AXI1_QOS_INCBK            MMC_REG_ADDR(DMC_AXI1_QOS_INCBK)
-#define DMC_AXI1_QOS_DEC (S_DMC_REG_BASE + (0xbe << 2))
-#define P_DMC_AXI1_QOS_DEC              MMC_REG_ADDR(DMC_AXI1_QOS_DEC)
-#define DMC_AXI1_QOS_DECBK (S_DMC_REG_BASE + (0xbf << 2))
-#define P_DMC_AXI1_QOS_DECBK            MMC_REG_ADDR(DMC_AXI1_QOS_DECBK)
-#define DMC_AXI1_QOS_DIS (S_DMC_REG_BASE + (0xc0 << 2))
-#define P_DMC_AXI1_QOS_DIS              MMC_REG_ADDR(DMC_AXI1_QOS_DIS)
-#define DMC_AXI1_QOS_DISBK (S_DMC_REG_BASE + (0xc1 << 2))
-#define P_DMC_AXI1_QOS_DISBK            MMC_REG_ADDR(DMC_AXI1_QOS_DISBK)
-#define DMC_AXI1_QOS_CTRL0 (S_DMC_REG_BASE + (0xc2 << 2))
-#define P_DMC_AXI1_QOS_CTRL0            MMC_REG_ADDR(DMC_AXI1_QOS_CTRL0)
-#define DMC_AXI1_QOS_CTRL1 (S_DMC_REG_BASE + (0xc3 << 2))
-#define P_DMC_AXI1_QOS_CTRL1            MMC_REG_ADDR(DMC_AXI1_QOS_CTRL1)
-#define DMC_AXI2_CHAN_CTRL (S_DMC_REG_BASE + (0xc4 << 2))
-#define P_DMC_AXI2_CHAN_CTRL            MMC_REG_ADDR(DMC_AXI2_CHAN_CTRL)
-#define DMC_AXI2_HOLD_CTRL (S_DMC_REG_BASE + (0xc5 << 2))
-#define P_DMC_AXI2_HOLD_CTRL            MMC_REG_ADDR(DMC_AXI2_HOLD_CTRL)
-#define DMC_AXI2_QOS_INC (S_DMC_REG_BASE + (0xc6 << 2))
-#define P_DMC_AXI2_QOS_INC              MMC_REG_ADDR(DMC_AXI2_QOS_INC)
-#define DMC_AXI2_QOS_INCBK (S_DMC_REG_BASE + (0xc7 << 2))
-#define P_DMC_AXI2_QOS_INCBK            MMC_REG_ADDR(DMC_AXI2_QOS_INCBK)
-#define DMC_AXI2_QOS_DEC (S_DMC_REG_BASE + (0xc8 << 2))
-#define P_DMC_AXI2_QOS_DEC              MMC_REG_ADDR(DMC_AXI2_QOS_DEC)
-#define DMC_AXI2_QOS_DECBK (S_DMC_REG_BASE + (0xc9 << 2))
-#define P_DMC_AXI2_QOS_DECBK            MMC_REG_ADDR(DMC_AXI2_QOS_DECBK)
-#define DMC_AXI2_QOS_DIS (S_DMC_REG_BASE + (0xca << 2))
-#define P_DMC_AXI2_QOS_DIS              MMC_REG_ADDR(DMC_AXI2_QOS_DIS)
-#define DMC_AXI2_QOS_DISBK (S_DMC_REG_BASE + (0xcb << 2))
-#define P_DMC_AXI2_QOS_DISBK            MMC_REG_ADDR(DMC_AXI2_QOS_DISBK)
-#define DMC_AXI2_QOS_CTRL0 (S_DMC_REG_BASE + (0xcc << 2))
-#define P_DMC_AXI2_QOS_CTRL0            MMC_REG_ADDR(DMC_AXI2_QOS_CTRL0)
-#define DMC_AXI2_QOS_CTRL1 (S_DMC_REG_BASE + (0xcd << 2))
-#define P_DMC_AXI2_QOS_CTRL1            MMC_REG_ADDR(DMC_AXI2_QOS_CTRL1)
-#define DMC_AXI3_CHAN_CTRL (S_DMC_REG_BASE + (0xce << 2))
-#define P_DMC_AXI3_CHAN_CTRL            MMC_REG_ADDR(DMC_AXI3_CHAN_CTRL)
-#define DMC_AXI3_HOLD_CTRL (S_DMC_REG_BASE + (0xcf << 2))
-#define P_DMC_AXI3_HOLD_CTRL            MMC_REG_ADDR(DMC_AXI3_HOLD_CTRL)
-#define DMC_AXI3_QOS_INC (S_DMC_REG_BASE + (0xd0 << 2))
-#define P_DMC_AXI3_QOS_INC              MMC_REG_ADDR(DMC_AXI3_QOS_INC)
-#define DMC_AXI3_QOS_INCBK (S_DMC_REG_BASE + (0xd1 << 2))
-#define P_DMC_AXI3_QOS_INCBK            MMC_REG_ADDR(DMC_AXI3_QOS_INCBK)
-#define DMC_AXI3_QOS_DEC (S_DMC_REG_BASE + (0xd2 << 2))
-#define P_DMC_AXI3_QOS_DEC              MMC_REG_ADDR(DMC_AXI3_QOS_DEC)
-#define DMC_AXI3_QOS_DECBK (S_DMC_REG_BASE + (0xd3 << 2))
-#define P_DMC_AXI3_QOS_DECBK            MMC_REG_ADDR(DMC_AXI3_QOS_DECBK)
-#define DMC_AXI3_QOS_DIS (S_DMC_REG_BASE + (0xd4 << 2))
-#define P_DMC_AXI3_QOS_DIS              MMC_REG_ADDR(DMC_AXI3_QOS_DIS)
-#define DMC_AXI3_QOS_DISBK (S_DMC_REG_BASE + (0xd5 << 2))
-#define P_DMC_AXI3_QOS_DISBK            MMC_REG_ADDR(DMC_AXI3_QOS_DISBK)
-#define DMC_AXI3_QOS_CTRL0 (S_DMC_REG_BASE + (0xd6 << 2))
-#define P_DMC_AXI3_QOS_CTRL0            MMC_REG_ADDR(DMC_AXI3_QOS_CTRL0)
-#define DMC_AXI3_QOS_CTRL1 (S_DMC_REG_BASE + (0xd7 << 2))
-#define P_DMC_AXI3_QOS_CTRL1            MMC_REG_ADDR(DMC_AXI3_QOS_CTRL1)
-#define DMC_AXI4_CHAN_CTRL (S_DMC_REG_BASE + (0xd8 << 2))
-#define P_DMC_AXI4_CHAN_CTRL            MMC_REG_ADDR(DMC_AXI4_CHAN_CTRL)
-#define DMC_AXI4_HOLD_CTRL (S_DMC_REG_BASE + (0xd9 << 2))
-#define P_DMC_AXI4_HOLD_CTRL            MMC_REG_ADDR(DMC_AXI4_HOLD_CTRL)
-#define DMC_AXI4_QOS_INC (S_DMC_REG_BASE + (0xda << 2))
-#define P_DMC_AXI4_QOS_INC              MMC_REG_ADDR(DMC_AXI4_QOS_INC)
-#define DMC_AXI4_QOS_INCBK (S_DMC_REG_BASE + (0xdb << 2))
-#define P_DMC_AXI4_QOS_INCBK            MMC_REG_ADDR(DMC_AXI4_QOS_INCBK)
-#define DMC_AXI4_QOS_DEC (S_DMC_REG_BASE + (0xdc << 2))
-#define P_DMC_AXI4_QOS_DEC              MMC_REG_ADDR(DMC_AXI4_QOS_DEC)
-#define DMC_AXI4_QOS_DECBK (S_DMC_REG_BASE + (0xdd << 2))
-#define P_DMC_AXI4_QOS_DECBK            MMC_REG_ADDR(DMC_AXI4_QOS_DECBK)
-#define DMC_AXI4_QOS_DIS (S_DMC_REG_BASE + (0xde << 2))
-#define P_DMC_AXI4_QOS_DIS              MMC_REG_ADDR(DMC_AXI4_QOS_DIS)
-#define DMC_AXI4_QOS_DISBK (S_DMC_REG_BASE + (0xdf << 2))
-#define P_DMC_AXI4_QOS_DISBK            MMC_REG_ADDR(DMC_AXI4_QOS_DISBK)
-#define DMC_AXI4_QOS_CTRL0 (S_DMC_REG_BASE + (0xe0 << 2))
-#define P_DMC_AXI4_QOS_CTRL0            MMC_REG_ADDR(DMC_AXI4_QOS_CTRL0)
-#define DMC_AXI4_QOS_CTRL1 (S_DMC_REG_BASE + (0xe1 << 2))
-#define P_DMC_AXI4_QOS_CTRL1            MMC_REG_ADDR(DMC_AXI4_QOS_CTRL1)
-#define DMC_AXI5_CHAN_CTRL (S_DMC_REG_BASE + (0xe2 << 2))
-#define P_DMC_AXI5_CHAN_CTRL            MMC_REG_ADDR(DMC_AXI5_CHAN_CTRL)
-#define DMC_AXI5_HOLD_CTRL (S_DMC_REG_BASE + (0xe3 << 2))
-#define P_DMC_AXI5_HOLD_CTRL            MMC_REG_ADDR(DMC_AXI5_HOLD_CTRL)
-#define DMC_AXI5_QOS_INC (S_DMC_REG_BASE + (0xe4 << 2))
-#define P_DMC_AXI5_QOS_INC              MMC_REG_ADDR(DMC_AXI5_QOS_INC)
-#define DMC_AXI5_QOS_INCBK (S_DMC_REG_BASE + (0xe5 << 2))
-#define P_DMC_AXI5_QOS_INCBK            MMC_REG_ADDR(DMC_AXI5_QOS_INCBK)
-#define DMC_AXI5_QOS_DEC (S_DMC_REG_BASE + (0xe6 << 2))
-#define P_DMC_AXI5_QOS_DEC              MMC_REG_ADDR(DMC_AXI5_QOS_DEC)
-#define DMC_AXI5_QOS_DECBK (S_DMC_REG_BASE + (0xe7 << 2))
-#define P_DMC_AXI5_QOS_DECBK            MMC_REG_ADDR(DMC_AXI5_QOS_DECBK)
-#define DMC_AXI5_QOS_DIS (S_DMC_REG_BASE + (0xe8 << 2))
-#define P_DMC_AXI5_QOS_DIS              MMC_REG_ADDR(DMC_AXI5_QOS_DIS)
-#define DMC_AXI5_QOS_DISBK (S_DMC_REG_BASE + (0xe9 << 2))
-#define P_DMC_AXI5_QOS_DISBK            MMC_REG_ADDR(DMC_AXI5_QOS_DISBK)
-#define DMC_AXI5_QOS_CTRL0 (S_DMC_REG_BASE + (0xea << 2))
-#define P_DMC_AXI5_QOS_CTRL0            MMC_REG_ADDR(DMC_AXI5_QOS_CTRL0)
-#define DMC_AXI5_QOS_CTRL1 (S_DMC_REG_BASE + (0xeb << 2))
-#define P_DMC_AXI5_QOS_CTRL1            MMC_REG_ADDR(DMC_AXI5_QOS_CTRL1)
-#define DMC_AXI6_CHAN_CTRL (S_DMC_REG_BASE + (0xec << 2))
-#define P_DMC_AXI6_CHAN_CTRL            MMC_REG_ADDR(DMC_AXI6_CHAN_CTRL)
-#define DMC_AXI6_HOLD_CTRL (S_DMC_REG_BASE + (0xed << 2))
-#define P_DMC_AXI6_HOLD_CTRL            MMC_REG_ADDR(DMC_AXI6_HOLD_CTRL)
-#define DMC_AXI6_QOS_INC (S_DMC_REG_BASE + (0xee << 2))
-#define P_DMC_AXI6_QOS_INC              MMC_REG_ADDR(DMC_AXI6_QOS_INC)
-#define DMC_AXI6_QOS_INCBK (S_DMC_REG_BASE + (0xef << 2))
-#define P_DMC_AXI6_QOS_INCBK            MMC_REG_ADDR(DMC_AXI6_QOS_INCBK)
-#define DMC_AXI6_QOS_DEC (S_DMC_REG_BASE + (0xf0 << 2))
-#define P_DMC_AXI6_QOS_DEC              MMC_REG_ADDR(DMC_AXI6_QOS_DEC)
-#define DMC_AXI6_QOS_DECBK (S_DMC_REG_BASE + (0xf1 << 2))
-#define P_DMC_AXI6_QOS_DECBK            MMC_REG_ADDR(DMC_AXI6_QOS_DECBK)
-#define DMC_AXI6_QOS_DIS (S_DMC_REG_BASE + (0xf2 << 2))
-#define P_DMC_AXI6_QOS_DIS              MMC_REG_ADDR(DMC_AXI6_QOS_DIS)
-#define DMC_AXI6_QOS_DISBK (S_DMC_REG_BASE + (0xf3 << 2))
-#define P_DMC_AXI6_QOS_DISBK            MMC_REG_ADDR(DMC_AXI6_QOS_DISBK)
-#define DMC_AXI6_QOS_CTRL0 (S_DMC_REG_BASE + (0xf4 << 2))
-#define P_DMC_AXI6_QOS_CTRL0            MMC_REG_ADDR(DMC_AXI6_QOS_CTRL0)
-#define DMC_AXI6_QOS_CTRL1 (S_DMC_REG_BASE + (0xf5 << 2))
-#define P_DMC_AXI6_QOS_CTRL1            MMC_REG_ADDR(DMC_AXI6_QOS_CTRL1)
-#define DMC_AXI7_CHAN_CTRL (S_DMC_REG_BASE + (0xf6 << 2))
-#define P_DMC_AXI7_CHAN_CTRL            MMC_REG_ADDR(DMC_AXI7_CHAN_CTRL)
-#define DMC_AXI7_HOLD_CTRL (S_DMC_REG_BASE + (0xf7 << 2))
-#define P_DMC_AXI7_HOLD_CTRL            MMC_REG_ADDR(DMC_AXI7_HOLD_CTRL)
-#define DMC_AXI7_QOS_INC (S_DMC_REG_BASE + (0xf8 << 2))
-#define P_DMC_AXI7_QOS_INC              MMC_REG_ADDR(DMC_AXI7_QOS_INC)
-#define DMC_AXI7_QOS_INCBK (S_DMC_REG_BASE + (0xf9 << 2))
-#define P_DMC_AXI7_QOS_INCBK            MMC_REG_ADDR(DMC_AXI7_QOS_INCBK)
-#define DMC_AXI7_QOS_DEC (S_DMC_REG_BASE + (0xfa << 2))
-#define P_DMC_AXI7_QOS_DEC              MMC_REG_ADDR(DMC_AXI7_QOS_DEC)
-#define DMC_AXI7_QOS_DECBK (S_DMC_REG_BASE + (0xfb << 2))
-#define P_DMC_AXI7_QOS_DECBK            MMC_REG_ADDR(DMC_AXI7_QOS_DECBK)
-#define DMC_AXI7_QOS_DIS (S_DMC_REG_BASE + (0xfc << 2))
-#define P_DMC_AXI7_QOS_DIS              MMC_REG_ADDR(DMC_AXI7_QOS_DIS)
-#define DMC_AXI7_QOS_DISBK (S_DMC_REG_BASE + (0xfd << 2))
-#define P_DMC_AXI7_QOS_DISBK            MMC_REG_ADDR(DMC_AXI7_QOS_DISBK)
-#define DMC_AXI7_QOS_CTRL0 (S_DMC_REG_BASE + (0xfe << 2))
-#define P_DMC_AXI7_QOS_CTRL0            MMC_REG_ADDR(DMC_AXI7_QOS_CTRL0)
-#define DMC_AXI7_QOS_CTRL1 (S_DMC_REG_BASE + (0xff << 2))
-#define P_DMC_AXI7_QOS_CTRL1            MMC_REG_ADDR(DMC_AXI7_QOS_CTRL1)
-/**/
-#define STB_VERSION 0x1600
-#define P_STB_VERSION           CBUS_REG_ADDR(STB_VERSION)
-#define STB_VERSION_2 0x1650
-#define P_STB_VERSION_2                 CBUS_REG_ADDR(STB_VERSION_2)
-#define STB_VERSION_3 0x16a0
-#define P_STB_VERSION_3                 CBUS_REG_ADDR(STB_VERSION_3)
-#define STB_TEST_REG 0x1601
-#define P_STB_TEST_REG          CBUS_REG_ADDR(STB_TEST_REG)
-#define STB_TEST_REG_2 0x1651
-#define P_STB_TEST_REG_2                CBUS_REG_ADDR(STB_TEST_REG_2)
-#define STB_TEST_REG_3 0x16a1
-#define P_STB_TEST_REG_3                CBUS_REG_ADDR(STB_TEST_REG_3)
-#define FEC_INPUT_CONTROL 0x1602
-#define P_FEC_INPUT_CONTROL             CBUS_REG_ADDR(FEC_INPUT_CONTROL)
-#define FEC_INPUT_CONTROL_2 0x1652
-#define P_FEC_INPUT_CONTROL_2           CBUS_REG_ADDR(FEC_INPUT_CONTROL_2)
-#define FEC_INPUT_CONTROL_3 0x16a2
-#define P_FEC_INPUT_CONTROL_3           CBUS_REG_ADDR(FEC_INPUT_CONTROL_3)
-#define FEC_INPUT_DATA 0x1603
-#define P_FEC_INPUT_DATA                CBUS_REG_ADDR(FEC_INPUT_DATA)
-#define FEC_INPUT_DATA_2 0x1653
-#define P_FEC_INPUT_DATA_2              CBUS_REG_ADDR(FEC_INPUT_DATA_2)
-#define FEC_INPUT_DATA_3 0x16a3
-#define P_FEC_INPUT_DATA_3              CBUS_REG_ADDR(FEC_INPUT_DATA_3)
-#define DEMUX_CONTROL 0x1604
-#define P_DEMUX_CONTROL                 CBUS_REG_ADDR(DEMUX_CONTROL)
-#define DEMUX_CONTROL_2 0x1654
-#define P_DEMUX_CONTROL_2               CBUS_REG_ADDR(DEMUX_CONTROL_2)
-#define DEMUX_CONTROL_3 0x16a4
-#define P_DEMUX_CONTROL_3               CBUS_REG_ADDR(DEMUX_CONTROL_3)
-#define FEC_SYNC_BYTE 0x1605
-#define P_FEC_SYNC_BYTE                 CBUS_REG_ADDR(FEC_SYNC_BYTE)
-#define FEC_SYNC_BYTE_2 0x1655
-#define P_FEC_SYNC_BYTE_2               CBUS_REG_ADDR(FEC_SYNC_BYTE_2)
-#define FEC_SYNC_BYTE_3 0x16a5
-#define P_FEC_SYNC_BYTE_3               CBUS_REG_ADDR(FEC_SYNC_BYTE_3)
-#define FM_WR_DATA 0x1606
-#define P_FM_WR_DATA            CBUS_REG_ADDR(FM_WR_DATA)
-#define FM_WR_DATA_2 0x1656
-#define P_FM_WR_DATA_2          CBUS_REG_ADDR(FM_WR_DATA_2)
-#define FM_WR_DATA_3 0x16a6
-#define P_FM_WR_DATA_3          CBUS_REG_ADDR(FM_WR_DATA_3)
-#define FM_WR_ADDR 0x1607
-#define P_FM_WR_ADDR            CBUS_REG_ADDR(FM_WR_ADDR)
-#define FM_WR_ADDR_2 0x1657
-#define P_FM_WR_ADDR_2          CBUS_REG_ADDR(FM_WR_ADDR_2)
-#define FM_WR_ADDR_3 0x16a7
-#define P_FM_WR_ADDR_3          CBUS_REG_ADDR(FM_WR_ADDR_3)
-#define MAX_FM_COMP_ADDR 0x1608
-#define P_MAX_FM_COMP_ADDR              CBUS_REG_ADDR(MAX_FM_COMP_ADDR)
-#define MAX_FM_COMP_ADDR_2 0x1658
-#define P_MAX_FM_COMP_ADDR_2            CBUS_REG_ADDR(MAX_FM_COMP_ADDR_2)
-#define MAX_FM_COMP_ADDR_3 0x16a8
-#define P_MAX_FM_COMP_ADDR_3            CBUS_REG_ADDR(MAX_FM_COMP_ADDR_3)
-#define TS_HEAD_0 0x1609
-#define P_TS_HEAD_0             CBUS_REG_ADDR(TS_HEAD_0)
-#define TS_HEAD_0_2 0x1659
-#define P_TS_HEAD_0_2           CBUS_REG_ADDR(TS_HEAD_0_2)
-#define TS_HEAD_0_3 0x16a9
-#define P_TS_HEAD_0_3           CBUS_REG_ADDR(TS_HEAD_0_3)
-#define TS_HEAD_1 0x160a
-#define P_TS_HEAD_1             CBUS_REG_ADDR(TS_HEAD_1)
-#define TS_HEAD_1_2 0x165a
-#define P_TS_HEAD_1_2           CBUS_REG_ADDR(TS_HEAD_1_2)
-#define TS_HEAD_1_3 0x16aa
-#define P_TS_HEAD_1_3           CBUS_REG_ADDR(TS_HEAD_1_3)
-#define OM_CMD_STATUS 0x160b
-#define P_OM_CMD_STATUS                 CBUS_REG_ADDR(OM_CMD_STATUS)
-#define OM_CMD_STATUS_2 0x165b
-#define P_OM_CMD_STATUS_2               CBUS_REG_ADDR(OM_CMD_STATUS_2)
-#define OM_CMD_STATUS_3 0x16ab
-#define P_OM_CMD_STATUS_3               CBUS_REG_ADDR(OM_CMD_STATUS_3)
-#define OM_CMD_DATA 0x160c
-#define P_OM_CMD_DATA           CBUS_REG_ADDR(OM_CMD_DATA)
-#define OM_CMD_DATA_2 0x165c
-#define P_OM_CMD_DATA_2                 CBUS_REG_ADDR(OM_CMD_DATA_2)
-#define OM_CMD_DATA_3 0x16ac
-#define P_OM_CMD_DATA_3                 CBUS_REG_ADDR(OM_CMD_DATA_3)
-#define OM_CMD_DATA2 0x160d
-#define P_OM_CMD_DATA2          CBUS_REG_ADDR(OM_CMD_DATA2)
-#define OM_CMD_DATA2_2 0x165d
-#define P_OM_CMD_DATA2_2                CBUS_REG_ADDR(OM_CMD_DATA2_2)
-#define OM_CMD_DATA2_3 0x16ad
-#define P_OM_CMD_DATA2_3                CBUS_REG_ADDR(OM_CMD_DATA2_3)
-#define SEC_BUFF_01_START 0x160e
-#define P_SEC_BUFF_01_START             CBUS_REG_ADDR(SEC_BUFF_01_START)
-#define SEC_BUFF_01_START_2 0x165e
-#define P_SEC_BUFF_01_START_2           CBUS_REG_ADDR(SEC_BUFF_01_START_2)
-#define SEC_BUFF_01_START_3 0x16ae
-#define P_SEC_BUFF_01_START_3           CBUS_REG_ADDR(SEC_BUFF_01_START_3)
-#define SEC_BUFF_23_START 0x160f
-#define P_SEC_BUFF_23_START             CBUS_REG_ADDR(SEC_BUFF_23_START)
-#define SEC_BUFF_23_START_2 0x165f
-#define P_SEC_BUFF_23_START_2           CBUS_REG_ADDR(SEC_BUFF_23_START_2)
-#define SEC_BUFF_23_START_3 0x16af
-#define P_SEC_BUFF_23_START_3           CBUS_REG_ADDR(SEC_BUFF_23_START_3)
-#define SEC_BUFF_SIZE 0x1610
-#define P_SEC_BUFF_SIZE                 CBUS_REG_ADDR(SEC_BUFF_SIZE)
-#define SEC_BUFF_SIZE_2 0x1660
-#define P_SEC_BUFF_SIZE_2               CBUS_REG_ADDR(SEC_BUFF_SIZE_2)
-#define SEC_BUFF_SIZE_3 0x16b0
-#define P_SEC_BUFF_SIZE_3               CBUS_REG_ADDR(SEC_BUFF_SIZE_3)
-#define SEC_BUFF_BUSY 0x1611
-#define P_SEC_BUFF_BUSY                 CBUS_REG_ADDR(SEC_BUFF_BUSY)
-#define SEC_BUFF_BUSY_2 0x1661
-#define P_SEC_BUFF_BUSY_2               CBUS_REG_ADDR(SEC_BUFF_BUSY_2)
-#define SEC_BUFF_BUSY_3 0x16b1
-#define P_SEC_BUFF_BUSY_3               CBUS_REG_ADDR(SEC_BUFF_BUSY_3)
-#define SEC_BUFF_READY 0x1612
-#define P_SEC_BUFF_READY                CBUS_REG_ADDR(SEC_BUFF_READY)
-#define SEC_BUFF_READY_2 0x1662
-#define P_SEC_BUFF_READY_2              CBUS_REG_ADDR(SEC_BUFF_READY_2)
-#define SEC_BUFF_READY_3 0x16b2
-#define P_SEC_BUFF_READY_3              CBUS_REG_ADDR(SEC_BUFF_READY_3)
-#define SEC_BUFF_NUMBER 0x1613
-#define P_SEC_BUFF_NUMBER               CBUS_REG_ADDR(SEC_BUFF_NUMBER)
-#define SEC_BUFF_NUMBER_2 0x1663
-#define P_SEC_BUFF_NUMBER_2             CBUS_REG_ADDR(SEC_BUFF_NUMBER_2)
-#define SEC_BUFF_NUMBER_3 0x16b3
-#define P_SEC_BUFF_NUMBER_3             CBUS_REG_ADDR(SEC_BUFF_NUMBER_3)
-#define ASSIGN_PID_NUMBER 0x1614
-#define P_ASSIGN_PID_NUMBER             CBUS_REG_ADDR(ASSIGN_PID_NUMBER)
-#define ASSIGN_PID_NUMBER_2 0x1664
-#define P_ASSIGN_PID_NUMBER_2           CBUS_REG_ADDR(ASSIGN_PID_NUMBER_2)
-#define ASSIGN_PID_NUMBER_3 0x16b4
-#define P_ASSIGN_PID_NUMBER_3           CBUS_REG_ADDR(ASSIGN_PID_NUMBER_3)
-#define VIDEO_STREAM_ID 0x1615
-#define P_VIDEO_STREAM_ID               CBUS_REG_ADDR(VIDEO_STREAM_ID)
-#define VIDEO_STREAM_ID_2 0x1665
-#define P_VIDEO_STREAM_ID_2             CBUS_REG_ADDR(VIDEO_STREAM_ID_2)
-#define VIDEO_STREAM_ID_3 0x16b5
-#define P_VIDEO_STREAM_ID_3             CBUS_REG_ADDR(VIDEO_STREAM_ID_3)
-#define AUDIO_STREAM_ID 0x1616
-#define P_AUDIO_STREAM_ID               CBUS_REG_ADDR(AUDIO_STREAM_ID)
-#define AUDIO_STREAM_ID_2 0x1666
-#define P_AUDIO_STREAM_ID_2             CBUS_REG_ADDR(AUDIO_STREAM_ID_2)
-#define AUDIO_STREAM_ID_3 0x16b6
-#define P_AUDIO_STREAM_ID_3             CBUS_REG_ADDR(AUDIO_STREAM_ID_3)
-#define SUB_STREAM_ID 0x1617
-#define P_SUB_STREAM_ID                 CBUS_REG_ADDR(SUB_STREAM_ID)
-#define SUB_STREAM_ID_2 0x1667
-#define P_SUB_STREAM_ID_2               CBUS_REG_ADDR(SUB_STREAM_ID_2)
-#define SUB_STREAM_ID_3 0x16b7
-#define P_SUB_STREAM_ID_3               CBUS_REG_ADDR(SUB_STREAM_ID_3)
-#define OTHER_STREAM_ID 0x1618
-#define P_OTHER_STREAM_ID               CBUS_REG_ADDR(OTHER_STREAM_ID)
-#define OTHER_STREAM_ID_2 0x1668
-#define P_OTHER_STREAM_ID_2             CBUS_REG_ADDR(OTHER_STREAM_ID_2)
-#define OTHER_STREAM_ID_3 0x16b8
-#define P_OTHER_STREAM_ID_3             CBUS_REG_ADDR(OTHER_STREAM_ID_3)
-#define PCR90K_CTL 0x1619
-#define P_PCR90K_CTL            CBUS_REG_ADDR(PCR90K_CTL)
-#define PCR90K_CTL_2 0x1669
-#define P_PCR90K_CTL_2          CBUS_REG_ADDR(PCR90K_CTL_2)
-#define PCR90K_CTL_3 0x16b9
-#define P_PCR90K_CTL_3          CBUS_REG_ADDR(PCR90K_CTL_3)
-#define PCR_DEMUX 0x161a
-#define P_PCR_DEMUX             CBUS_REG_ADDR(PCR_DEMUX)
-#define PCR_DEMUX_2 0x166a
-#define P_PCR_DEMUX_2           CBUS_REG_ADDR(PCR_DEMUX_2)
-#define PCR_DEMUX_3 0x16ba
-#define P_PCR_DEMUX_3           CBUS_REG_ADDR(PCR_DEMUX_3)
-#define VIDEO_PTS_DEMUX 0x161b
-#define P_VIDEO_PTS_DEMUX               CBUS_REG_ADDR(VIDEO_PTS_DEMUX)
-#define VIDEO_PTS_DEMUX_2 0x166b
-#define P_VIDEO_PTS_DEMUX_2             CBUS_REG_ADDR(VIDEO_PTS_DEMUX_2)
-#define VIDEO_PTS_DEMUX_3 0x16bb
-#define P_VIDEO_PTS_DEMUX_3             CBUS_REG_ADDR(VIDEO_PTS_DEMUX_3)
-#define VIDEO_DTS_DEMUX 0x161c
-#define P_VIDEO_DTS_DEMUX               CBUS_REG_ADDR(VIDEO_DTS_DEMUX)
-#define VIDEO_DTS_DEMUX_2 0x166c
-#define P_VIDEO_DTS_DEMUX_2             CBUS_REG_ADDR(VIDEO_DTS_DEMUX_2)
-#define VIDEO_DTS_DEMUX_3 0x16bc
-#define P_VIDEO_DTS_DEMUX_3             CBUS_REG_ADDR(VIDEO_DTS_DEMUX_3)
-#define AUDIO_PTS_DEMUX 0x161d
-#define P_AUDIO_PTS_DEMUX               CBUS_REG_ADDR(AUDIO_PTS_DEMUX)
-#define AUDIO_PTS_DEMUX_2 0x166d
-#define P_AUDIO_PTS_DEMUX_2             CBUS_REG_ADDR(AUDIO_PTS_DEMUX_2)
-#define AUDIO_PTS_DEMUX_3 0x16bd
-#define P_AUDIO_PTS_DEMUX_3             CBUS_REG_ADDR(AUDIO_PTS_DEMUX_3)
-#define SUB_PTS_DEMUX 0x161e
-#define P_SUB_PTS_DEMUX                 CBUS_REG_ADDR(SUB_PTS_DEMUX)
-#define SUB_PTS_DEMUX_2 0x166e
-#define P_SUB_PTS_DEMUX_2               CBUS_REG_ADDR(SUB_PTS_DEMUX_2)
-#define SUB_PTS_DEMUX_3 0x16be
-#define P_SUB_PTS_DEMUX_3               CBUS_REG_ADDR(SUB_PTS_DEMUX_3)
-#define STB_PTS_DTS_STATUS 0x161f
-#define P_STB_PTS_DTS_STATUS            CBUS_REG_ADDR(STB_PTS_DTS_STATUS)
-#define STB_PTS_DTS_STATUS_2 0x166f
-#define P_STB_PTS_DTS_STATUS_2          CBUS_REG_ADDR(STB_PTS_DTS_STATUS_2)
-#define STB_PTS_DTS_STATUS_3 0x16bf
-#define P_STB_PTS_DTS_STATUS_3          CBUS_REG_ADDR(STB_PTS_DTS_STATUS_3)
-#define STB_DEBUG_INDEX 0x1620
-#define P_STB_DEBUG_INDEX               CBUS_REG_ADDR(STB_DEBUG_INDEX)
-#define STB_DEBUG_INDEX_2 0x1670
-#define P_STB_DEBUG_INDEX_2             CBUS_REG_ADDR(STB_DEBUG_INDEX_2)
-#define STB_DEBUG_INDEX_3 0x16c0
-#define P_STB_DEBUG_INDEX_3             CBUS_REG_ADDR(STB_DEBUG_INDEX_3)
-#define STB_DEBUG_DATAUT_O 0x1621
-#define P_STB_DEBUG_DATAUT_O            CBUS_REG_ADDR(STB_DEBUG_DATAUT_O)
-#define STB_DEBUG_DATAUT_O_2 0x1671
-#define P_STB_DEBUG_DATAUT_O_2          CBUS_REG_ADDR(STB_DEBUG_DATAUT_O_2)
-#define STB_DEBUG_DATAUT_O_3 0x16c1
-#define P_STB_DEBUG_DATAUT_O_3          CBUS_REG_ADDR(STB_DEBUG_DATAUT_O_3)
-#define STBM_CTL_O 0x1622
-#define P_STBM_CTL_O            CBUS_REG_ADDR(STBM_CTL_O)
-#define STBM_CTL_O_2 0x1672
-#define P_STBM_CTL_O_2          CBUS_REG_ADDR(STBM_CTL_O_2)
-#define STBM_CTL_O_3 0x16c2
-#define P_STBM_CTL_O_3          CBUS_REG_ADDR(STBM_CTL_O_3)
-#define STB_INT_STATUS 0x1623
-#define P_STB_INT_STATUS                CBUS_REG_ADDR(STB_INT_STATUS)
-#define STB_INT_STATUS_2 0x1673
-#define P_STB_INT_STATUS_2              CBUS_REG_ADDR(STB_INT_STATUS_2)
-#define STB_INT_STATUS_3 0x16c3
-#define P_STB_INT_STATUS_3              CBUS_REG_ADDR(STB_INT_STATUS_3)
-#define DEMUX_ENDIAN 0x1624
-#define P_DEMUX_ENDIAN          CBUS_REG_ADDR(DEMUX_ENDIAN)
-#define DEMUX_ENDIAN_2 0x1674
-#define P_DEMUX_ENDIAN_2                CBUS_REG_ADDR(DEMUX_ENDIAN_2)
-#define DEMUX_ENDIAN_3 0x16c4
-#define P_DEMUX_ENDIAN_3                CBUS_REG_ADDR(DEMUX_ENDIAN_3)
-#define TS_HIU_CTL 0x1625
-#define P_TS_HIU_CTL            CBUS_REG_ADDR(TS_HIU_CTL)
-#define TS_HIU_CTL_2 0x1675
-#define P_TS_HIU_CTL_2          CBUS_REG_ADDR(TS_HIU_CTL_2)
-#define TS_HIU_CTL_3 0x16c5
-#define P_TS_HIU_CTL_3          CBUS_REG_ADDR(TS_HIU_CTL_3)
-#define SEC_BUFF_BASE 0x1626
-#define P_SEC_BUFF_BASE                 CBUS_REG_ADDR(SEC_BUFF_BASE)
-#define SEC_BUFF_BASE_2 0x1676
-#define P_SEC_BUFF_BASE_2               CBUS_REG_ADDR(SEC_BUFF_BASE_2)
-#define SEC_BUFF_BASE_3 0x16c6
-#define P_SEC_BUFF_BASE_3               CBUS_REG_ADDR(SEC_BUFF_BASE_3)
-#define DEMUX_MEM_REQ_EN 0x1627
-#define P_DEMUX_MEM_REQ_EN              CBUS_REG_ADDR(DEMUX_MEM_REQ_EN)
-#define DEMUX_MEM_REQ_EN_2 0x1677
-#define P_DEMUX_MEM_REQ_EN_2            CBUS_REG_ADDR(DEMUX_MEM_REQ_EN_2)
-#define DEMUX_MEM_REQ_EN_3 0x16c7
-#define P_DEMUX_MEM_REQ_EN_3            CBUS_REG_ADDR(DEMUX_MEM_REQ_EN_3)
-#define VIDEO_PDTS_WR_PTR 0x1628
-#define P_VIDEO_PDTS_WR_PTR             CBUS_REG_ADDR(VIDEO_PDTS_WR_PTR)
-#define VIDEO_PDTS_WR_PTR_2 0x1678
-#define P_VIDEO_PDTS_WR_PTR_2           CBUS_REG_ADDR(VIDEO_PDTS_WR_PTR_2)
-#define VIDEO_PDTS_WR_PTR_3 0x16c8
-#define P_VIDEO_PDTS_WR_PTR_3           CBUS_REG_ADDR(VIDEO_PDTS_WR_PTR_3)
-#define AUDIO_PDTS_WR_PTR 0x1629
-#define P_AUDIO_PDTS_WR_PTR             CBUS_REG_ADDR(AUDIO_PDTS_WR_PTR)
-#define AUDIO_PDTS_WR_PTR_2 0x1679
-#define P_AUDIO_PDTS_WR_PTR_2           CBUS_REG_ADDR(AUDIO_PDTS_WR_PTR_2)
-#define AUDIO_PDTS_WR_PTR_3 0x16c9
-#define P_AUDIO_PDTS_WR_PTR_3           CBUS_REG_ADDR(AUDIO_PDTS_WR_PTR_3)
-#define SUB_WR_PTR 0x162a
-#define P_SUB_WR_PTR            CBUS_REG_ADDR(SUB_WR_PTR)
-#define SUB_WR_PTR_2 0x167a
-#define P_SUB_WR_PTR_2          CBUS_REG_ADDR(SUB_WR_PTR_2)
-#define SUB_WR_PTR_3 0x16ca
-#define P_SUB_WR_PTR_3          CBUS_REG_ADDR(SUB_WR_PTR_3)
-#define SB_START 0x162b
-#define P_SB_START              CBUS_REG_ADDR(SB_START)
-#define SB_START_2 0x167b
-#define P_SB_START_2            CBUS_REG_ADDR(SB_START_2)
-#define SB_START_3 0x16cb
-#define P_SB_START_3            CBUS_REG_ADDR(SB_START_3)
-#define SB_LAST_ADDR 0x162c
-#define P_SB_LAST_ADDR          CBUS_REG_ADDR(SB_LAST_ADDR)
-#define SB_LAST_ADDR_2 0x167c
-#define P_SB_LAST_ADDR_2                CBUS_REG_ADDR(SB_LAST_ADDR_2)
-#define SB_LAST_ADDR_3 0x16cc
-#define P_SB_LAST_ADDR_3                CBUS_REG_ADDR(SB_LAST_ADDR_3)
-#define SB_PES_WR_PTR 0x162d
-#define P_SB_PES_WR_PTR                 CBUS_REG_ADDR(SB_PES_WR_PTR)
-#define SB_PES_WR_PTR_2 0x167d
-#define P_SB_PES_WR_PTR_2               CBUS_REG_ADDR(SB_PES_WR_PTR_2)
-#define SB_PES_WR_PTR_3 0x16cd
-#define P_SB_PES_WR_PTR_3               CBUS_REG_ADDR(SB_PES_WR_PTR_3)
-#define OTHER_WR_PTR 0x162e
-#define P_OTHER_WR_PTR          CBUS_REG_ADDR(OTHER_WR_PTR)
-#define OTHER_WR_PTR_2 0x167e
-#define P_OTHER_WR_PTR_2                CBUS_REG_ADDR(OTHER_WR_PTR_2)
-#define OTHER_WR_PTR_3 0x16ce
-#define P_OTHER_WR_PTR_3                CBUS_REG_ADDR(OTHER_WR_PTR_3)
-#define OB_START 0x162f
-#define P_OB_START              CBUS_REG_ADDR(OB_START)
-#define OB_START_2 0x167f
-#define P_OB_START_2            CBUS_REG_ADDR(OB_START_2)
-#define OB_START_3 0x16cf
-#define P_OB_START_3            CBUS_REG_ADDR(OB_START_3)
-#define OB_LAST_ADDR 0x1630
-#define P_OB_LAST_ADDR          CBUS_REG_ADDR(OB_LAST_ADDR)
-#define OB_LAST_ADDR_2 0x1680
-#define P_OB_LAST_ADDR_2                CBUS_REG_ADDR(OB_LAST_ADDR_2)
-#define OB_LAST_ADDR_3 0x16d0
-#define P_OB_LAST_ADDR_3                CBUS_REG_ADDR(OB_LAST_ADDR_3)
-#define OB_PES_WR_PTR 0x1631
-#define P_OB_PES_WR_PTR                 CBUS_REG_ADDR(OB_PES_WR_PTR)
-#define OB_PES_WR_PTR_2 0x1681
-#define P_OB_PES_WR_PTR_2               CBUS_REG_ADDR(OB_PES_WR_PTR_2)
-#define OB_PES_WR_PTR_3 0x16d1
-#define P_OB_PES_WR_PTR_3               CBUS_REG_ADDR(OB_PES_WR_PTR_3)
-#define STB_INT_MASK 0x1632
-#define P_STB_INT_MASK          CBUS_REG_ADDR(STB_INT_MASK)
-#define STB_INT_MASK_2 0x1682
-#define P_STB_INT_MASK_2                CBUS_REG_ADDR(STB_INT_MASK_2)
-#define STB_INT_MASK_3 0x16d2
-#define P_STB_INT_MASK_3                CBUS_REG_ADDR(STB_INT_MASK_3)
-#define VIDEO_SPLICING_CTL 0x1633
-#define P_VIDEO_SPLICING_CTL            CBUS_REG_ADDR(VIDEO_SPLICING_CTL)
-#define VIDEO_SPLICING_CTL_2 0x1683
-#define P_VIDEO_SPLICING_CTL_2          CBUS_REG_ADDR(VIDEO_SPLICING_CTL_2)
-#define VIDEO_SPLICING_CTL_3 0x16d3
-#define P_VIDEO_SPLICING_CTL_3          CBUS_REG_ADDR(VIDEO_SPLICING_CTL_3)
-#define AUDIO_SPLICING_CTL 0x1634
-#define P_AUDIO_SPLICING_CTL            CBUS_REG_ADDR(AUDIO_SPLICING_CTL)
-#define AUDIO_SPLICING_CTL_2 0x1684
-#define P_AUDIO_SPLICING_CTL_2          CBUS_REG_ADDR(AUDIO_SPLICING_CTL_2)
-#define AUDIO_SPLICING_CTL_3 0x16d4
-#define P_AUDIO_SPLICING_CTL_3          CBUS_REG_ADDR(AUDIO_SPLICING_CTL_3)
-#define TS_PACKAGE_BYTE_COUNT 0x1635
-#define P_TS_PACKAGE_BYTE_COUNT                 \
-	CBUS_REG_ADDR(TS_PACKAGE_BYTE_COUNT)
-#define TS_PACKAGE_BYTE_COUNT_2 0x1685
-#define P_TS_PACKAGE_BYTE_COUNT_2               \
-	CBUS_REG_ADDR(TS_PACKAGE_BYTE_COUNT_2)
-#define TS_PACKAGE_BYTE_COUNT_3 0x16d5
-#define P_TS_PACKAGE_BYTE_COUNT_3               \
-	CBUS_REG_ADDR(TS_PACKAGE_BYTE_COUNT_3)
-#define PES_STRONG_SYNC 0x1636
-#define P_PES_STRONG_SYNC               CBUS_REG_ADDR(PES_STRONG_SYNC)
-#define PES_STRONG_SYNC_2 0x1686
-#define P_PES_STRONG_SYNC_2             CBUS_REG_ADDR(PES_STRONG_SYNC_2)
-#define PES_STRONG_SYNC_3 0x16d6
-#define P_PES_STRONG_SYNC_3             CBUS_REG_ADDR(PES_STRONG_SYNC_3)
-#define OM_DATA_RD_ADDR 0x1637
-#define P_OM_DATA_RD_ADDR               CBUS_REG_ADDR(OM_DATA_RD_ADDR)
-#define OM_DATA_RD_ADDR_2 0x1687
-#define P_OM_DATA_RD_ADDR_2             CBUS_REG_ADDR(OM_DATA_RD_ADDR_2)
-#define OM_DATA_RD_ADDR_3 0x16d7
-#define P_OM_DATA_RD_ADDR_3             CBUS_REG_ADDR(OM_DATA_RD_ADDR_3)
-#define OM_DATA_RD 0x1638
-#define P_OM_DATA_RD            CBUS_REG_ADDR(OM_DATA_RD)
-#define OM_DATA_RD_2 0x1688
-#define P_OM_DATA_RD_2          CBUS_REG_ADDR(OM_DATA_RD_2)
-#define OM_DATA_RD_3 0x16d8
-#define P_OM_DATA_RD_3          CBUS_REG_ADDR(OM_DATA_RD_3)
-#define SECTION_AUTO_STOP_3 0x1639
-#define P_SECTION_AUTO_STOP_3           CBUS_REG_ADDR(SECTION_AUTO_STOP_3)
-#define SECTION_AUTO_STOP_3_2 0x1689
-#define P_SECTION_AUTO_STOP_3_2                 \
-	CBUS_REG_ADDR(SECTION_AUTO_STOP_3_2)
-#define SECTION_AUTO_STOP_3_3 0x16d9
-#define P_SECTION_AUTO_STOP_3_3                 \
-	CBUS_REG_ADDR(SECTION_AUTO_STOP_3_3)
-#define SECTION_AUTO_STOP_2 0x163a
-#define P_SECTION_AUTO_STOP_2           \
-	CBUS_REG_ADDR(SECTION_AUTO_STOP_2)
-#define SECTION_AUTO_STOP_2_2 0x168a
-#define P_SECTION_AUTO_STOP_2_2                 \
-	CBUS_REG_ADDR(SECTION_AUTO_STOP_2_2)
-#define SECTION_AUTO_STOP_2_3 0x16da
-#define P_SECTION_AUTO_STOP_2_3                 \
-	CBUS_REG_ADDR(SECTION_AUTO_STOP_2_3)
-#define SECTION_AUTO_STOP_1 0x163b
-#define P_SECTION_AUTO_STOP_1           CBUS_REG_ADDR(SECTION_AUTO_STOP_1)
-#define SECTION_AUTO_STOP_1_2 0x168b
-#define P_SECTION_AUTO_STOP_1_2                 \
-	CBUS_REG_ADDR(SECTION_AUTO_STOP_1_2)
-#define SECTION_AUTO_STOP_1_3 0x16db
-#define P_SECTION_AUTO_STOP_1_3                 \
-	CBUS_REG_ADDR(SECTION_AUTO_STOP_1_3)
-#define SECTION_AUTO_STOP_0 0x163c
-#define P_SECTION_AUTO_STOP_0           \
-	CBUS_REG_ADDR(SECTION_AUTO_STOP_0)
-#define SECTION_AUTO_STOP_0_2 0x168c
-#define P_SECTION_AUTO_STOP_0_2                 \
-	CBUS_REG_ADDR(SECTION_AUTO_STOP_0_2)
-#define SECTION_AUTO_STOP_0_3 0x16dc
-#define P_SECTION_AUTO_STOP_0_3                 \
-	CBUS_REG_ADDR(SECTION_AUTO_STOP_0_3)
-#define DEMUX_CHANNEL_RESET 0x163d
-#define P_DEMUX_CHANNEL_RESET           \
-	CBUS_REG_ADDR(DEMUX_CHANNEL_RESET)
-#define DEMUX_CHANNEL_RESET_2 0x168d
-#define P_DEMUX_CHANNEL_RESET_2                 \
-	CBUS_REG_ADDR(DEMUX_CHANNEL_RESET_2)
-#define DEMUX_CHANNEL_RESET_3 0x16dd
-#define P_DEMUX_CHANNEL_RESET_3                 \
-	CBUS_REG_ADDR(DEMUX_CHANNEL_RESET_3)
-#define DEMUX_SCRAMBLING_STATE 0x163e
-#define DEMUX_SCRAMBLING_STATE_2 0x168e
-#define P_DEMUX_SCRAMBLING_STATE_2              \
-	CBUS_REG_ADDR(DEMUX_SCRAMBLING_STATE_2)
-#define DEMUX_SCRAMBLING_STATE_3 0x16de
-#define P_DEMUX_SCRAMBLING_STATE_3              \
-	CBUS_REG_ADDR(DEMUX_SCRAMBLING_STATE_3)
-#define DEMUX_CHANNEL_ACTIVITY 0x163f
-#define P_DEMUX_CHANNEL_ACTIVITY                \
-	CBUS_REG_ADDR(DEMUX_CHANNEL_ACTIVITY)
-#define DEMUX_CHANNEL_ACTIVITY_2 0x168f
-#define P_DEMUX_CHANNEL_ACTIVITY_2              \
-	CBUS_REG_ADDR(DEMUX_CHANNEL_ACTIVITY_2)
-#define DEMUX_CHANNEL_ACTIVITY_3 0x16df
-#define P_DEMUX_CHANNEL_ACTIVITY_3              \
-	CBUS_REG_ADDR(DEMUX_CHANNEL_ACTIVITY_3)
-#define DEMUX_STAMP_CTL 0x1640
-#define P_DEMUX_STAMP_CTL               CBUS_REG_ADDR(DEMUX_STAMP_CTL)
-#define DEMUX_STAMP_CTL_2 0x1690
-#define P_DEMUX_STAMP_CTL_2             \
-	CBUS_REG_ADDR(DEMUX_STAMP_CTL_2)
-#define DEMUX_STAMP_CTL_3 0x16e0
-#define P_DEMUX_STAMP_CTL_3             \
-	CBUS_REG_ADDR(DEMUX_STAMP_CTL_3)
-#define DEMUX_VIDEO_STAMP_SYNC_0 0x1641
-#define P_DEMUX_VIDEO_STAMP_SYNC_0              \
-	CBUS_REG_ADDR(DEMUX_VIDEO_STAMP_SYNC_0)
-#define DEMUX_VIDEO_STAMP_SYNC_0_2 0x1691
-#define P_DEMUX_VIDEO_STAMP_SYNC_0_2            \
-	CBUS_REG_ADDR(DEMUX_VIDEO_STAMP_SYNC_0_2)
-#define DEMUX_VIDEO_STAMP_SYNC_0_3 0x16e1
-#define P_DEMUX_VIDEO_STAMP_SYNC_0_3            \
-	CBUS_REG_ADDR(DEMUX_VIDEO_STAMP_SYNC_0_3)
-#define DEMUX_VIDEO_STAMP_SYNC_1 0x1642
-#define P_DEMUX_VIDEO_STAMP_SYNC_1              \
-	CBUS_REG_ADDR(DEMUX_VIDEO_STAMP_SYNC_1)
-#define DEMUX_VIDEO_STAMP_SYNC_1_2 0x1692
-#define P_DEMUX_VIDEO_STAMP_SYNC_1_2            \
-	CBUS_REG_ADDR(DEMUX_VIDEO_STAMP_SYNC_1_2)
-#define DEMUX_VIDEO_STAMP_SYNC_1_3 0x16e2
-#define P_DEMUX_VIDEO_STAMP_SYNC_1_3            \
-	CBUS_REG_ADDR(DEMUX_VIDEO_STAMP_SYNC_1_3)
-#define DEMUX_AUDIO_STAMP_SYNC_0 0x1643
-#define P_DEMUX_AUDIO_STAMP_SYNC_0              \
-	CBUS_REG_ADDR(DEMUX_AUDIO_STAMP_SYNC_0)
-#define DEMUX_AUDIO_STAMP_SYNC_0_2 0x1693
-#define P_DEMUX_AUDIO_STAMP_SYNC_0_2            \
-	CBUS_REG_ADDR(DEMUX_AUDIO_STAMP_SYNC_0_2)
-#define DEMUX_AUDIO_STAMP_SYNC_0_3 0x16e3
-#define P_DEMUX_AUDIO_STAMP_SYNC_0_3            \
-	CBUS_REG_ADDR(DEMUX_AUDIO_STAMP_SYNC_0_3)
-#define DEMUX_AUDIO_STAMP_SYNC_1 0x1644
-#define P_DEMUX_AUDIO_STAMP_SYNC_1              \
-	CBUS_REG_ADDR(DEMUX_AUDIO_STAMP_SYNC_1)
-#define DEMUX_AUDIO_STAMP_SYNC_1_2 0x1694
-#define P_DEMUX_AUDIO_STAMP_SYNC_1_2            \
-	CBUS_REG_ADDR(DEMUX_AUDIO_STAMP_SYNC_1_2)
-#define DEMUX_AUDIO_STAMP_SYNC_1_3 0x16e4
-#define P_DEMUX_AUDIO_STAMP_SYNC_1_3            \
-	CBUS_REG_ADDR(DEMUX_AUDIO_STAMP_SYNC_1_3)
-#define DEMUX_SECTION_RESET 0x1645
-#define P_DEMUX_SECTION_RESET           CBUS_REG_ADDR(DEMUX_SECTION_RESET)
-#define DEMUX_SECTION_RESET_2 0x1695
-#define P_DEMUX_SECTION_RESET_2                 \
-	CBUS_REG_ADDR(DEMUX_SECTION_RESET_2)
-#define DEMUX_SECTION_RESET_3 0x16e5
-#define P_DEMUX_SECTION_RESET_3                 \
-	CBUS_REG_ADDR(DEMUX_SECTION_RESET_3)
-#define EFUSE_CNTL0 0x0
-#define P_EFUSE_CNTL0           SECBUS_REG_ADDR(EFUSE_CNTL0)
-#define EFUSE_CNTL1 0x1
-#define P_EFUSE_CNTL1           SECBUS_REG_ADDR(EFUSE_CNTL1)
-#define EFUSE_CNTL2 0x2
-#define P_EFUSE_CNTL2           SECBUS_REG_ADDR(EFUSE_CNTL2)
-#define EFUSE_CNTL3 0x3
-#define P_EFUSE_CNTL3           SECBUS_REG_ADDR(EFUSE_CNTL3)
-#define EFUSE_CNTL4 0x4
-#define P_EFUSE_CNTL4           SECBUS_REG_ADDR(EFUSE_CNTL4)
-#define AO_SECURE_REG0 0x00
-#define P_AO_SECURE_REG0                SECBUS2_REG_ADDR(AO_SECURE_REG0)
-#define AO_SECURE_REG1 0x01
-#define P_AO_SECURE_REG1                SECBUS2_REG_ADDR(AO_SECURE_REG1)
-#define AO_SECURE_REG2 0x02
-#define P_AO_SECURE_REG2                SECBUS2_REG_ADDR(AO_SECURE_REG2)
-#define SEC_BLKMV_AES_REG0 0x00
-#define P_SEC_BLKMV_AES_REG0            SECBUS3_REG_ADDR(SEC_BLKMV_AES_REG0)
-#define SEC_BLKMV_AES_W0 0x01
-#define P_SEC_BLKMV_AES_W0              SECBUS3_REG_ADDR(SEC_BLKMV_AES_W0)
-#define SEC_BLKMV_AES_W1 0x02
-#define P_SEC_BLKMV_AES_W1              SECBUS3_REG_ADDR(SEC_BLKMV_AES_W1)
-#define SEC_BLKMV_AES_W2 0x03
-#define P_SEC_BLKMV_AES_W2              SECBUS3_REG_ADDR(SEC_BLKMV_AES_W2)
-#define SEC_BLKMV_AES_W3 0x04
-#define P_SEC_BLKMV_AES_W3              SECBUS3_REG_ADDR(SEC_BLKMV_AES_W3)
-#define SEC_BLKMV_AES_R0 0x05
-#define P_SEC_BLKMV_AES_R0              SECBUS3_REG_ADDR(SEC_BLKMV_AES_R0)
-#define SEC_BLKMV_AES_R1 0x06
-#define P_SEC_BLKMV_AES_R1              SECBUS3_REG_ADDR(SEC_BLKMV_AES_R1)
-#define SEC_BLKMV_AES_R2 0x07
-#define P_SEC_BLKMV_AES_R2              SECBUS3_REG_ADDR(SEC_BLKMV_AES_R2)
-#define SEC_BLKMV_AES_R3 0x08
-#define P_SEC_BLKMV_AES_R3              SECBUS3_REG_ADDR(SEC_BLKMV_AES_R3)
-#define SEC_BLKMV_TDES_LAST_IV_LO 0x09
-#define P_SEC_BLKMV_TDES_LAST_IV_LO             \
-	SECBUS3_REG_ADDR(SEC_BLKMV_TDES_LAST_IV_LO)
-#define SEC_BLKMV_TDES_LAST_IV_HI 0x0a
-#define P_SEC_BLKMV_TDES_LAST_IV_HI             \
-	SECBUS3_REG_ADDR(SEC_BLKMV_TDES_LAST_IV_HI)
-#define SEC_BLKMV_AES_IV_0 0x0b
-#define P_SEC_BLKMV_AES_IV_0            SECBUS3_REG_ADDR(SEC_BLKMV_AES_IV_0)
-#define SEC_BLKMV_AES_IV_1 0x0c
-#define P_SEC_BLKMV_AES_IV_1            SECBUS3_REG_ADDR(SEC_BLKMV_AES_IV_1)
-#define SEC_BLKMV_AES_IV_2 0x0d
-#define P_SEC_BLKMV_AES_IV_2            SECBUS3_REG_ADDR(SEC_BLKMV_AES_IV_2)
-#define SEC_BLKMV_AES_IV_3 0x0e
-#define P_SEC_BLKMV_AES_IV_3            SECBUS3_REG_ADDR(SEC_BLKMV_AES_IV_3)
-/*add from M8M2*/
-#define SEC_BLKMV_AES_KEY_0 0x10
-#define P_SEC_BLKMV_AES_KEY_0           SECBUS3_REG_ADDR(SEC_BLKMV_AES_KEY_0)
-#define SEC_BLKMV_AES_KEY_1 0x11
-#define P_SEC_BLKMV_AES_KEY_1           SECBUS3_REG_ADDR(SEC_BLKMV_AES_KEY_1)
-#define SEC_BLKMV_AES_KEY_2 0x12
-#define P_SEC_BLKMV_AES_KEY_2           SECBUS3_REG_ADDR(SEC_BLKMV_AES_KEY_2)
-#define SEC_BLKMV_AES_KEY_3 0x13
-#define P_SEC_BLKMV_AES_KEY_3           SECBUS3_REG_ADDR(SEC_BLKMV_AES_KEY_3)
-#define SEC_BLKMV_AES_KEY_4 0x14
-#define P_SEC_BLKMV_AES_KEY_4           SECBUS3_REG_ADDR(SEC_BLKMV_AES_KEY_4)
-#define SEC_BLKMV_AES_KEY_5 0x15
-#define P_SEC_BLKMV_AES_KEY_5           SECBUS3_REG_ADDR(SEC_BLKMV_AES_KEY_5)
-#define SEC_BLKMV_AES_KEY_6 0x16
-#define P_SEC_BLKMV_AES_KEY_6           SECBUS3_REG_ADDR(SEC_BLKMV_AES_KEY_6)
-#define SEC_BLKMV_AES_KEY_7 0x17
-#define P_SEC_BLKMV_AES_KEY_7           SECBUS3_REG_ADDR(SEC_BLKMV_AES_KEY_7)
-#define SEC_BLKMV_THREAD_TABLE_START0 0x18
-#define P_SEC_BLKMV_THREAD_TABLE_START0                 \
-	SECBUS3_REG_ADDR(SEC_BLKMV_THREAD_TABLE_START0)
-#define SEC_BLKMV_THREAD_TABLE_CURR0 0x19
-#define P_SEC_BLKMV_THREAD_TABLE_CURR0          \
-	SECBUS3_REG_ADDR(SEC_BLKMV_THREAD_TABLE_CURR0)
-#define SEC_BLKMV_THREAD_TABLE_END0 0x1a
-#define P_SEC_BLKMV_THREAD_TABLE_END0           \
-	SECBUS3_REG_ADDR(SEC_BLKMV_THREAD_TABLE_END0)
-#define SEC_BLKMV_THREAD_TABLE_START1 0x1b
-#define P_SEC_BLKMV_THREAD_TABLE_START1                 \
-	SECBUS3_REG_ADDR(SEC_BLKMV_THREAD_TABLE_START1)
-#define SEC_BLKMV_THREAD_TABLE_CURR1 0x1c
-#define P_SEC_BLKMV_THREAD_TABLE_CURR1          \
-	SECBUS3_REG_ADDR(SEC_BLKMV_THREAD_TABLE_CURR1)
-#define SEC_BLKMV_THREAD_TABLE_END1 0x1d
-#define P_SEC_BLKMV_THREAD_TABLE_END1           \
-	SECBUS3_REG_ADDR(SEC_BLKMV_THREAD_TABLE_END1)
-#define SEC_BLKMV_THREAD_TABLE_START2 0x1e
-#define P_SEC_BLKMV_THREAD_TABLE_START2                 \
-	SECBUS3_REG_ADDR(SEC_BLKMV_THREAD_TABLE_START2)
-#define SEC_BLKMV_THREAD_TABLE_CURR2 0x1f
-#define P_SEC_BLKMV_THREAD_TABLE_CURR2          \
-	SECBUS3_REG_ADDR(SEC_BLKMV_THREAD_TABLE_CURR2)
-#define SEC_BLKMV_THREAD_TABLE_END2 0x20
-#define P_SEC_BLKMV_THREAD_TABLE_END2           \
-	SECBUS3_REG_ADDR(SEC_BLKMV_THREAD_TABLE_END2)
-#define SEC_BLKMV_THREAD_TABLE_START3 0x21
-#define P_SEC_BLKMV_THREAD_TABLE_START3                 \
-	SECBUS3_REG_ADDR(SEC_BLKMV_THREAD_TABLE_START3)
-#define SEC_BLKMV_THREAD_TABLE_CURR3 0x22
-#define P_SEC_BLKMV_THREAD_TABLE_CURR3          \
-	SECBUS3_REG_ADDR(SEC_BLKMV_THREAD_TABLE_CURR3)
-#define SEC_BLKMV_THREAD_TABLE_END3 0x23
-#define P_SEC_BLKMV_THREAD_TABLE_END3           \
-	SECBUS3_REG_ADDR(SEC_BLKMV_THREAD_TABLE_END3)
-#define SEC_BLKMV_GEN_REG0 0x24
-#define P_SEC_BLKMV_GEN_REG0            SECBUS3_REG_ADDR(SEC_BLKMV_GEN_REG0)
-#endif
diff --git a/drivers/amlogic/dvb_tv/cxd2841er.c b/drivers/amlogic/dvb_tv/cxd2841er.c
new file mode 100644
index 000000000000..acbe977c646c
--- /dev/null
+++ b/drivers/amlogic/dvb_tv/cxd2841er.c
@@ -0,0 +1,3812 @@
+/*
+ * cxd2841er.c
+ *
+ * Sony digital demodulator driver for
+ *	CXD2841ER - DVB-S/S2/T/T2/C/C2
+ *	CXD2854ER - DVB-S/S2/T/T2/C/C2, ISDB-T/S
+ *
+ * Copyright 2012 Sony Corporation
+ * Copyright (C) 2014 NetUP Inc.
+ * Copyright (C) 2014 Sergey Kozlov <serjk@netup.ru>
+ * Copyright (C) 2014 Abylay Ospan <aospan@netup.ru>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+  */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/string.h>
+#include <linux/slab.h>
+#include <linux/bitops.h>
+#include <linux/math64.h>
+#include <linux/log2.h>
+#include <linux/dynamic_debug.h>
+
+#include "dvb_math.h"
+#include "dvb_frontend.h"
+#include "cxd2841er.h"
+#include "cxd2841er_priv.h"
+
+#define MAX_WRITE_REGSIZE	16
+#define LOG2_E_100X 144
+
+/* DVB-C constellation */
+enum sony_dvbc_constellation_t {
+	SONY_DVBC_CONSTELLATION_16QAM,
+	SONY_DVBC_CONSTELLATION_32QAM,
+	SONY_DVBC_CONSTELLATION_64QAM,
+	SONY_DVBC_CONSTELLATION_128QAM,
+	SONY_DVBC_CONSTELLATION_256QAM
+};
+
+enum cxd2841er_state {
+	STATE_SHUTDOWN = 0,
+	STATE_SLEEP_S,
+	STATE_ACTIVE_S,
+	STATE_SLEEP_TC,
+	STATE_ACTIVE_TC
+};
+
+struct cxd2841er_priv {
+	struct dvb_frontend		frontend;
+	struct i2c_adapter		*i2c;
+	u8				i2c_addr_slvx;
+	u8				i2c_addr_slvt;
+	const struct cxd2841er_config	*config;
+	enum cxd2841er_state		state;
+	u8				system;
+	enum cxd2841er_xtal		xtal;
+	enum fe_caps caps;
+};
+
+static const struct cxd2841er_cnr_data s_cn_data[] = {
+	{ 0x033e, 0 }, { 0x0339, 100 }, { 0x0333, 200 },
+	{ 0x032e, 300 }, { 0x0329, 400 }, { 0x0324, 500 },
+	{ 0x031e, 600 }, { 0x0319, 700 }, { 0x0314, 800 },
+	{ 0x030f, 900 }, { 0x030a, 1000 }, { 0x02ff, 1100 },
+	{ 0x02f4, 1200 }, { 0x02e9, 1300 }, { 0x02de, 1400 },
+	{ 0x02d4, 1500 }, { 0x02c9, 1600 }, { 0x02bf, 1700 },
+	{ 0x02b5, 1800 }, { 0x02ab, 1900 }, { 0x02a1, 2000 },
+	{ 0x029b, 2100 }, { 0x0295, 2200 }, { 0x0290, 2300 },
+	{ 0x028a, 2400 }, { 0x0284, 2500 }, { 0x027f, 2600 },
+	{ 0x0279, 2700 }, { 0x0274, 2800 }, { 0x026e, 2900 },
+	{ 0x0269, 3000 }, { 0x0262, 3100 }, { 0x025c, 3200 },
+	{ 0x0255, 3300 }, { 0x024f, 3400 }, { 0x0249, 3500 },
+	{ 0x0242, 3600 }, { 0x023c, 3700 }, { 0x0236, 3800 },
+	{ 0x0230, 3900 }, { 0x022a, 4000 }, { 0x0223, 4100 },
+	{ 0x021c, 4200 }, { 0x0215, 4300 }, { 0x020e, 4400 },
+	{ 0x0207, 4500 }, { 0x0201, 4600 }, { 0x01fa, 4700 },
+	{ 0x01f4, 4800 }, { 0x01ed, 4900 }, { 0x01e7, 5000 },
+	{ 0x01e0, 5100 }, { 0x01d9, 5200 }, { 0x01d2, 5300 },
+	{ 0x01cb, 5400 }, { 0x01c4, 5500 }, { 0x01be, 5600 },
+	{ 0x01b7, 5700 }, { 0x01b1, 5800 }, { 0x01aa, 5900 },
+	{ 0x01a4, 6000 }, { 0x019d, 6100 }, { 0x0196, 6200 },
+	{ 0x018f, 6300 }, { 0x0189, 6400 }, { 0x0182, 6500 },
+	{ 0x017c, 6600 }, { 0x0175, 6700 }, { 0x016f, 6800 },
+	{ 0x0169, 6900 }, { 0x0163, 7000 }, { 0x015c, 7100 },
+	{ 0x0156, 7200 }, { 0x0150, 7300 }, { 0x014a, 7400 },
+	{ 0x0144, 7500 }, { 0x013e, 7600 }, { 0x0138, 7700 },
+	{ 0x0132, 7800 }, { 0x012d, 7900 }, { 0x0127, 8000 },
+	{ 0x0121, 8100 }, { 0x011c, 8200 }, { 0x0116, 8300 },
+	{ 0x0111, 8400 }, { 0x010b, 8500 }, { 0x0106, 8600 },
+	{ 0x0101, 8700 }, { 0x00fc, 8800 }, { 0x00f7, 8900 },
+	{ 0x00f2, 9000 }, { 0x00ee, 9100 }, { 0x00ea, 9200 },
+	{ 0x00e6, 9300 }, { 0x00e2, 9400 }, { 0x00de, 9500 },
+	{ 0x00da, 9600 }, { 0x00d7, 9700 }, { 0x00d3, 9800 },
+	{ 0x00d0, 9900 }, { 0x00cc, 10000 }, { 0x00c7, 10100 },
+	{ 0x00c3, 10200 }, { 0x00bf, 10300 }, { 0x00ba, 10400 },
+	{ 0x00b6, 10500 }, { 0x00b2, 10600 }, { 0x00ae, 10700 },
+	{ 0x00aa, 10800 }, { 0x00a7, 10900 }, { 0x00a3, 11000 },
+	{ 0x009f, 11100 }, { 0x009c, 11200 }, { 0x0098, 11300 },
+	{ 0x0094, 11400 }, { 0x0091, 11500 }, { 0x008e, 11600 },
+	{ 0x008a, 11700 }, { 0x0087, 11800 }, { 0x0084, 11900 },
+	{ 0x0081, 12000 }, { 0x007e, 12100 }, { 0x007b, 12200 },
+	{ 0x0079, 12300 }, { 0x0076, 12400 }, { 0x0073, 12500 },
+	{ 0x0071, 12600 }, { 0x006e, 12700 }, { 0x006c, 12800 },
+	{ 0x0069, 12900 }, { 0x0067, 13000 }, { 0x0065, 13100 },
+	{ 0x0062, 13200 }, { 0x0060, 13300 }, { 0x005e, 13400 },
+	{ 0x005c, 13500 }, { 0x005a, 13600 }, { 0x0058, 13700 },
+	{ 0x0056, 13800 }, { 0x0054, 13900 }, { 0x0052, 14000 },
+	{ 0x0050, 14100 }, { 0x004e, 14200 }, { 0x004c, 14300 },
+	{ 0x004b, 14400 }, { 0x0049, 14500 }, { 0x0047, 14600 },
+	{ 0x0046, 14700 }, { 0x0044, 14800 }, { 0x0043, 14900 },
+	{ 0x0041, 15000 }, { 0x003f, 15100 }, { 0x003e, 15200 },
+	{ 0x003c, 15300 }, { 0x003b, 15400 }, { 0x003a, 15500 },
+	{ 0x0037, 15700 }, { 0x0036, 15800 }, { 0x0034, 15900 },
+	{ 0x0033, 16000 }, { 0x0032, 16100 }, { 0x0031, 16200 },
+	{ 0x0030, 16300 }, { 0x002f, 16400 }, { 0x002e, 16500 },
+	{ 0x002d, 16600 }, { 0x002c, 16700 }, { 0x002b, 16800 },
+	{ 0x002a, 16900 }, { 0x0029, 17000 }, { 0x0028, 17100 },
+	{ 0x0027, 17200 }, { 0x0026, 17300 }, { 0x0025, 17400 },
+	{ 0x0024, 17500 }, { 0x0023, 17600 }, { 0x0022, 17800 },
+	{ 0x0021, 17900 }, { 0x0020, 18000 }, { 0x001f, 18200 },
+	{ 0x001e, 18300 }, { 0x001d, 18500 }, { 0x001c, 18700 },
+	{ 0x001b, 18900 }, { 0x001a, 19000 }, { 0x0019, 19200 },
+	{ 0x0018, 19300 }, { 0x0017, 19500 }, { 0x0016, 19700 },
+	{ 0x0015, 19900 }, { 0x0014, 20000 },
+};
+
+static const struct cxd2841er_cnr_data s2_cn_data[] = {
+	{ 0x05af, 0 }, { 0x0597, 100 }, { 0x057e, 200 },
+	{ 0x0567, 300 }, { 0x0550, 400 }, { 0x0539, 500 },
+	{ 0x0522, 600 }, { 0x050c, 700 }, { 0x04f6, 800 },
+	{ 0x04e1, 900 }, { 0x04cc, 1000 }, { 0x04b6, 1100 },
+	{ 0x04a1, 1200 }, { 0x048c, 1300 }, { 0x0477, 1400 },
+	{ 0x0463, 1500 }, { 0x044f, 1600 }, { 0x043c, 1700 },
+	{ 0x0428, 1800 }, { 0x0416, 1900 }, { 0x0403, 2000 },
+	{ 0x03ef, 2100 }, { 0x03dc, 2200 }, { 0x03c9, 2300 },
+	{ 0x03b6, 2400 }, { 0x03a4, 2500 }, { 0x0392, 2600 },
+	{ 0x0381, 2700 }, { 0x036f, 2800 }, { 0x035f, 2900 },
+	{ 0x034e, 3000 }, { 0x033d, 3100 }, { 0x032d, 3200 },
+	{ 0x031d, 3300 }, { 0x030d, 3400 }, { 0x02fd, 3500 },
+	{ 0x02ee, 3600 }, { 0x02df, 3700 }, { 0x02d0, 3800 },
+	{ 0x02c2, 3900 }, { 0x02b4, 4000 }, { 0x02a6, 4100 },
+	{ 0x0299, 4200 }, { 0x028c, 4300 }, { 0x027f, 4400 },
+	{ 0x0272, 4500 }, { 0x0265, 4600 }, { 0x0259, 4700 },
+	{ 0x024d, 4800 }, { 0x0241, 4900 }, { 0x0236, 5000 },
+	{ 0x022b, 5100 }, { 0x0220, 5200 }, { 0x0215, 5300 },
+	{ 0x020a, 5400 }, { 0x0200, 5500 }, { 0x01f6, 5600 },
+	{ 0x01ec, 5700 }, { 0x01e2, 5800 }, { 0x01d8, 5900 },
+	{ 0x01cf, 6000 }, { 0x01c6, 6100 }, { 0x01bc, 6200 },
+	{ 0x01b3, 6300 }, { 0x01aa, 6400 }, { 0x01a2, 6500 },
+	{ 0x0199, 6600 }, { 0x0191, 6700 }, { 0x0189, 6800 },
+	{ 0x0181, 6900 }, { 0x0179, 7000 }, { 0x0171, 7100 },
+	{ 0x0169, 7200 }, { 0x0161, 7300 }, { 0x015a, 7400 },
+	{ 0x0153, 7500 }, { 0x014b, 7600 }, { 0x0144, 7700 },
+	{ 0x013d, 7800 }, { 0x0137, 7900 }, { 0x0130, 8000 },
+	{ 0x012a, 8100 }, { 0x0124, 8200 }, { 0x011e, 8300 },
+	{ 0x0118, 8400 }, { 0x0112, 8500 }, { 0x010c, 8600 },
+	{ 0x0107, 8700 }, { 0x0101, 8800 }, { 0x00fc, 8900 },
+	{ 0x00f7, 9000 }, { 0x00f2, 9100 }, { 0x00ec, 9200 },
+	{ 0x00e7, 9300 }, { 0x00e2, 9400 }, { 0x00dd, 9500 },
+	{ 0x00d8, 9600 }, { 0x00d4, 9700 }, { 0x00cf, 9800 },
+	{ 0x00ca, 9900 }, { 0x00c6, 10000 }, { 0x00c2, 10100 },
+	{ 0x00be, 10200 }, { 0x00b9, 10300 }, { 0x00b5, 10400 },
+	{ 0x00b1, 10500 }, { 0x00ae, 10600 }, { 0x00aa, 10700 },
+	{ 0x00a6, 10800 }, { 0x00a3, 10900 }, { 0x009f, 11000 },
+	{ 0x009b, 11100 }, { 0x0098, 11200 }, { 0x0095, 11300 },
+	{ 0x0091, 11400 }, { 0x008e, 11500 }, { 0x008b, 11600 },
+	{ 0x0088, 11700 }, { 0x0085, 11800 }, { 0x0082, 11900 },
+	{ 0x007f, 12000 }, { 0x007c, 12100 }, { 0x007a, 12200 },
+	{ 0x0077, 12300 }, { 0x0074, 12400 }, { 0x0072, 12500 },
+	{ 0x006f, 12600 }, { 0x006d, 12700 }, { 0x006b, 12800 },
+	{ 0x0068, 12900 }, { 0x0066, 13000 }, { 0x0064, 13100 },
+	{ 0x0061, 13200 }, { 0x005f, 13300 }, { 0x005d, 13400 },
+	{ 0x005b, 13500 }, { 0x0059, 13600 }, { 0x0057, 13700 },
+	{ 0x0055, 13800 }, { 0x0053, 13900 }, { 0x0051, 14000 },
+	{ 0x004f, 14100 }, { 0x004e, 14200 }, { 0x004c, 14300 },
+	{ 0x004a, 14400 }, { 0x0049, 14500 }, { 0x0047, 14600 },
+	{ 0x0045, 14700 }, { 0x0044, 14800 }, { 0x0042, 14900 },
+	{ 0x0041, 15000 }, { 0x003f, 15100 }, { 0x003e, 15200 },
+	{ 0x003c, 15300 }, { 0x003b, 15400 }, { 0x003a, 15500 },
+	{ 0x0038, 15600 }, { 0x0037, 15700 }, { 0x0036, 15800 },
+	{ 0x0034, 15900 }, { 0x0033, 16000 }, { 0x0032, 16100 },
+	{ 0x0031, 16200 }, { 0x0030, 16300 }, { 0x002f, 16400 },
+	{ 0x002e, 16500 }, { 0x002d, 16600 }, { 0x002c, 16700 },
+	{ 0x002b, 16800 }, { 0x002a, 16900 }, { 0x0029, 17000 },
+	{ 0x0028, 17100 }, { 0x0027, 17200 }, { 0x0026, 17300 },
+	{ 0x0025, 17400 }, { 0x0024, 17500 }, { 0x0023, 17600 },
+	{ 0x0022, 17800 }, { 0x0021, 17900 }, { 0x0020, 18000 },
+	{ 0x001f, 18200 }, { 0x001e, 18300 }, { 0x001d, 18500 },
+	{ 0x001c, 18700 }, { 0x001b, 18900 }, { 0x001a, 19000 },
+	{ 0x0019, 19200 }, { 0x0018, 19300 }, { 0x0017, 19500 },
+	{ 0x0016, 19700 }, { 0x0015, 19900 }, { 0x0014, 20000 },
+};
+
+#define MAKE_IFFREQ_CONFIG(iffreq) ((u32)(((iffreq)/41.0)*16777216.0 + 0.5))
+#define MAKE_IFFREQ_CONFIG_XTAL(xtal, iffreq) ((xtal == SONY_XTAL_24000) ? \
+		(u32)(((iffreq)/48.0)*16777216.0 + 0.5) : \
+		(u32)(((iffreq)/41.0)*16777216.0 + 0.5))
+
+static void cxd2841er_i2c_debug(struct cxd2841er_priv *priv,
+				u8 addr, u8 reg, u8 write,
+				const u8 *data, u32 len)
+{
+	dev_dbg(&priv->i2c->dev,
+		"cxd2841er: I2C %s addr %02x reg 0x%02x size %d\n",
+		(write == 0 ? "read" : "write"), addr, reg, len);
+	print_hex_dump_bytes("cxd2841er: I2C data: ",
+		DUMP_PREFIX_OFFSET, data, len);
+}
+
+static int cxd2841er_write_regs(struct cxd2841er_priv *priv,
+				u8 addr, u8 reg, const u8 *data, u32 len)
+{
+	int ret;
+	u8 buf[MAX_WRITE_REGSIZE + 1];
+	u8 i2c_addr = (addr == I2C_SLVX ?
+		priv->i2c_addr_slvx : priv->i2c_addr_slvt);
+	struct i2c_msg msg[1] = {
+		{
+			.addr = i2c_addr,
+			.flags = 0,
+			.len = len + 1,
+			.buf = buf,
+		}
+	};
+
+	if (len + 1 >= sizeof(buf)) {
+		dev_warn(&priv->i2c->dev, "wr reg=%04x: len=%d is too big!\n",
+			 reg, len + 1);
+		return -E2BIG;
+	}
+
+	cxd2841er_i2c_debug(priv, i2c_addr, reg, 1, data, len);
+	buf[0] = reg;
+	memcpy(&buf[1], data, len);
+
+	ret = i2c_transfer(priv->i2c, msg, 1);
+	if (ret >= 0 && ret != 1)
+		ret = -EIO;
+	if (ret < 0) {
+		dev_warn(&priv->i2c->dev,
+			"%s: i2c wr failed=%d addr=%02x reg=%02x len=%d\n",
+			KBUILD_MODNAME, ret, i2c_addr, reg, len);
+		return ret;
+	}
+	return 0;
+}
+
+static int cxd2841er_write_reg(struct cxd2841er_priv *priv,
+			       u8 addr, u8 reg, u8 val)
+{
+	return cxd2841er_write_regs(priv, addr, reg, &val, 1);
+}
+
+static int cxd2841er_read_regs(struct cxd2841er_priv *priv,
+			       u8 addr, u8 reg, u8 *val, u32 len)
+{
+	int ret;
+	u8 i2c_addr = (addr == I2C_SLVX ?
+		priv->i2c_addr_slvx : priv->i2c_addr_slvt);
+	struct i2c_msg msg[2] = {
+		{
+			.addr = i2c_addr,
+			.flags = 0,
+			.len = 1,
+			.buf = &reg,
+		}, {
+			.addr = i2c_addr,
+			.flags = I2C_M_RD,
+			.len = len,
+			.buf = val,
+		}
+	};
+
+	ret = i2c_transfer(priv->i2c, &msg[0], 1);
+	if (ret >= 0 && ret != 1)
+		ret = -EIO;
+	if (ret < 0) {
+		dev_warn(&priv->i2c->dev,
+			"%s: i2c rw failed=%d addr=%02x reg=%02x\n",
+			KBUILD_MODNAME, ret, i2c_addr, reg);
+		return ret;
+	}
+	ret = i2c_transfer(priv->i2c, &msg[1], 1);
+	if (ret >= 0 && ret != 1)
+		ret = -EIO;
+	if (ret < 0) {
+		dev_warn(&priv->i2c->dev,
+			"%s: i2c rd failed=%d addr=%02x reg=%02x\n",
+			KBUILD_MODNAME, ret, i2c_addr, reg);
+		return ret;
+	}
+	cxd2841er_i2c_debug(priv, i2c_addr, reg, 0, val, len);
+	return 0;
+}
+
+static int cxd2841er_read_reg(struct cxd2841er_priv *priv,
+			      u8 addr, u8 reg, u8 *val)
+{
+	return cxd2841er_read_regs(priv, addr, reg, val, 1);
+}
+
+static int cxd2841er_set_reg_bits(struct cxd2841er_priv *priv,
+				  u8 addr, u8 reg, u8 data, u8 mask)
+{
+	int res;
+	u8 rdata;
+
+	if (mask != 0xff) {
+		res = cxd2841er_read_reg(priv, addr, reg, &rdata);
+		if (res)
+			return res;
+		data = ((data & mask) | (rdata & (mask ^ 0xFF)));
+	}
+	return cxd2841er_write_reg(priv, addr, reg, data);
+}
+
+static int cxd2841er_dvbs2_set_symbol_rate(struct cxd2841er_priv *priv,
+					   u32 symbol_rate)
+{
+	u32 reg_value = 0;
+	u8 data[3] = {0, 0, 0};
+
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	/*
+	 * regValue = (symbolRateKSps * 2^14 / 1000) + 0.5
+	 *          = ((symbolRateKSps * 2^14) + 500) / 1000
+	 *          = ((symbolRateKSps * 16384) + 500) / 1000
+	 */
+	reg_value = DIV_ROUND_CLOSEST(symbol_rate * 16384, 1000);
+	if ((reg_value == 0) || (reg_value > 0xFFFFF)) {
+		dev_err(&priv->i2c->dev,
+			"%s(): reg_value is out of range\n", __func__);
+		return -EINVAL;
+	}
+	data[0] = (u8)((reg_value >> 16) & 0x0F);
+	data[1] = (u8)((reg_value >>  8) & 0xFF);
+	data[2] = (u8)(reg_value & 0xFF);
+	/* Set SLV-T Bank : 0xAE */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0xae);
+	cxd2841er_write_regs(priv, I2C_SLVT, 0x20, data, 3);
+	return 0;
+}
+
+static void cxd2841er_set_ts_clock_mode(struct cxd2841er_priv *priv,
+					u8 system);
+
+static int cxd2841er_sleep_s_to_active_s(struct cxd2841er_priv *priv,
+					 u8 system, u32 symbol_rate)
+{
+	int ret;
+	u8 data[4] = { 0, 0, 0, 0 };
+
+	if (priv->state != STATE_SLEEP_S) {
+		dev_err(&priv->i2c->dev, "%s(): invalid state %d\n",
+			__func__, (int)priv->state);
+		return -EINVAL;
+	}
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	cxd2841er_set_ts_clock_mode(priv, SYS_DVBS);
+	/* Set demod mode */
+	if (system == SYS_DVBS) {
+		data[0] = 0x0A;
+	} else if (system == SYS_DVBS2) {
+		data[0] = 0x0B;
+	} else {
+		dev_err(&priv->i2c->dev, "%s(): invalid delsys %d\n",
+			__func__, system);
+		return -EINVAL;
+	}
+	/* Set SLV-X Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x00, 0x00);
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x17, data[0]);
+	/* DVB-S/S2 */
+	data[0] = 0x00;
+	/* Set SLV-T Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);
+	/* Enable S/S2 auto detection 1 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x2d, data[0]);
+	/* Set SLV-T Bank : 0xAE */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0xae);
+	/* Enable S/S2 auto detection 2 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x30, data[0]);
+	/* Set SLV-T Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);
+	/* Enable demod clock */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x2c, 0x01);
+	/* Enable ADC clock */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x31, 0x01);
+	/* Enable ADC 1 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x63, 0x16);
+	/* Enable ADC 2 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x65, 0x3f);
+	/* Set SLV-X Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x00, 0x00);
+	/* Enable ADC 3 */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x18, 0x00);
+	/* Set SLV-T Bank : 0xA3 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0xa3);
+	cxd2841er_write_reg(priv, I2C_SLVT, 0xac, 0x00);
+	data[0] = 0x07;
+	data[1] = 0x3B;
+	data[2] = 0x08;
+	data[3] = 0xC5;
+	/* Set SLV-T Bank : 0xAB */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0xab);
+	cxd2841er_write_regs(priv, I2C_SLVT, 0x98, data, 4);
+	data[0] = 0x05;
+	data[1] = 0x80;
+	data[2] = 0x0A;
+	data[3] = 0x80;
+	cxd2841er_write_regs(priv, I2C_SLVT, 0xa8, data, 4);
+	data[0] = 0x0C;
+	data[1] = 0xCC;
+	cxd2841er_write_regs(priv, I2C_SLVT, 0xc3, data, 2);
+	/* Set demod parameter */
+	ret = cxd2841er_dvbs2_set_symbol_rate(priv, symbol_rate);
+	if (ret != 0)
+		return ret;
+	/* Set SLV-T Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);
+	/* disable Hi-Z setting 1 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x80, 0x10);
+	/* disable Hi-Z setting 2 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x81, 0x00);
+	priv->state = STATE_ACTIVE_S;
+	return 0;
+}
+
+static int cxd2841er_init_tc(struct dvb_frontend *fe);
+
+static int cxd2841er_sleep_tc_to_active_t_band(struct cxd2841er_priv *priv,
+					       u32 bandwidth);
+
+static int cxd2841er_sleep_tc_to_active_t2_band(struct cxd2841er_priv *priv,
+						u32 bandwidth);
+
+static int cxd2841er_sleep_tc_to_active_c_band(struct cxd2841er_priv *priv,
+					       u32 bandwidth);
+
+static int cxd2841er_sleep_tc_to_active_i(struct cxd2841er_priv *priv,
+		u32 bandwidth);
+
+static int cxd2841er_active_i_to_sleep_tc(struct cxd2841er_priv *priv);
+
+static int cxd2841er_sleep_tc_to_shutdown(struct cxd2841er_priv *priv);
+
+static int cxd2841er_shutdown_to_sleep_tc(struct cxd2841er_priv *priv);
+
+static int cxd2841er_retune_active(struct cxd2841er_priv *priv,
+				   struct dtv_frontend_properties *p)
+{
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	if (priv->state != STATE_ACTIVE_S &&
+			priv->state != STATE_ACTIVE_TC) {
+		dev_dbg(&priv->i2c->dev, "%s(): invalid state %d\n",
+			__func__, priv->state);
+		return -EINVAL;
+	}
+	/* Set SLV-T Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);
+	/* disable TS output */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0xc3, 0x01);
+	if (priv->state == STATE_ACTIVE_S)
+		return cxd2841er_dvbs2_set_symbol_rate(
+				priv, p->symbol_rate / 1000);
+	else if (priv->state == STATE_ACTIVE_TC) {
+		switch (priv->system) {
+		case SYS_DVBT:
+			return cxd2841er_sleep_tc_to_active_t_band(
+					priv, p->bandwidth_hz);
+		case SYS_DVBT2:
+			return cxd2841er_sleep_tc_to_active_t2_band(
+					priv, p->bandwidth_hz);
+		case SYS_DVBC_ANNEX_A:
+			return cxd2841er_sleep_tc_to_active_c_band(
+					priv, p->bandwidth_hz);
+		case SYS_ISDBT:
+			cxd2841er_active_i_to_sleep_tc(priv);
+			cxd2841er_sleep_tc_to_shutdown(priv);
+			cxd2841er_shutdown_to_sleep_tc(priv);
+			return cxd2841er_sleep_tc_to_active_i(
+					priv, p->bandwidth_hz);
+		}
+	}
+	dev_dbg(&priv->i2c->dev, "%s(): invalid delivery system %d\n",
+		__func__, priv->system);
+	return -EINVAL;
+}
+
+static int cxd2841er_active_s_to_sleep_s(struct cxd2841er_priv *priv)
+{
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	if (priv->state != STATE_ACTIVE_S) {
+		dev_err(&priv->i2c->dev, "%s(): invalid state %d\n",
+			__func__, priv->state);
+		return -EINVAL;
+	}
+	/* Set SLV-T Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);
+	/* disable TS output */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0xc3, 0x01);
+	/* enable Hi-Z setting 1 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x80, 0x1f);
+	/* enable Hi-Z setting 2 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x81, 0xff);
+	/* Set SLV-X Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x00, 0x00);
+	/* disable ADC 1 */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x18, 0x01);
+	/* Set SLV-T Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);
+	/* disable ADC clock */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x31, 0x00);
+	/* disable ADC 2 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x63, 0x16);
+	/* disable ADC 3 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x65, 0x27);
+	/* SADC Bias ON */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x69, 0x06);
+	/* disable demod clock */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x2c, 0x00);
+	/* Set SLV-T Bank : 0xAE */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0xae);
+	/* disable S/S2 auto detection1 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x30, 0x00);
+	/* Set SLV-T Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);
+	/* disable S/S2 auto detection2 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x2d, 0x00);
+	priv->state = STATE_SLEEP_S;
+	return 0;
+}
+
+static int cxd2841er_sleep_s_to_shutdown(struct cxd2841er_priv *priv)
+{
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	if (priv->state != STATE_SLEEP_S) {
+		dev_dbg(&priv->i2c->dev, "%s(): invalid demod state %d\n",
+			__func__, priv->state);
+		return -EINVAL;
+	}
+	/* Set SLV-T Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);
+	/* Disable DSQOUT */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x80, 0x3f);
+	/* Disable DSQIN */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x9c, 0x00);
+	/* Set SLV-X Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x00, 0x00);
+	/* Disable oscillator */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x15, 0x01);
+	/* Set demod mode */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x17, 0x01);
+	priv->state = STATE_SHUTDOWN;
+	return 0;
+}
+
+static int cxd2841er_sleep_tc_to_shutdown(struct cxd2841er_priv *priv)
+{
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	if (priv->state != STATE_SLEEP_TC) {
+		dev_dbg(&priv->i2c->dev, "%s(): invalid demod state %d\n",
+			__func__, priv->state);
+		return -EINVAL;
+	}
+	/* Set SLV-X Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x00, 0x00);
+	/* Disable oscillator */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x15, 0x01);
+	/* Set demod mode */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x17, 0x01);
+	priv->state = STATE_SHUTDOWN;
+	return 0;
+}
+
+static int cxd2841er_active_t_to_sleep_tc(struct cxd2841er_priv *priv)
+{
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	if (priv->state != STATE_ACTIVE_TC) {
+		dev_err(&priv->i2c->dev, "%s(): invalid state %d\n",
+			__func__, priv->state);
+		return -EINVAL;
+	}
+	/* Set SLV-T Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);
+	/* disable TS output */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0xc3, 0x01);
+	/* enable Hi-Z setting 1 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x80, 0x3f);
+	/* enable Hi-Z setting 2 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x81, 0xff);
+	/* Set SLV-X Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x00, 0x00);
+	/* disable ADC 1 */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x18, 0x01);
+	/* Set SLV-T Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);
+	/* Disable ADC 2 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x43, 0x0a);
+	/* Disable ADC 3 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x41, 0x0a);
+	/* Disable ADC clock */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x30, 0x00);
+	/* Disable RF level monitor */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x2f, 0x00);
+	/* Disable demod clock */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x2c, 0x00);
+	priv->state = STATE_SLEEP_TC;
+	return 0;
+}
+
+static int cxd2841er_active_t2_to_sleep_tc(struct cxd2841er_priv *priv)
+{
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	if (priv->state != STATE_ACTIVE_TC) {
+		dev_err(&priv->i2c->dev, "%s(): invalid state %d\n",
+			__func__, priv->state);
+		return -EINVAL;
+	}
+	/* Set SLV-T Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);
+	/* disable TS output */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0xc3, 0x01);
+	/* enable Hi-Z setting 1 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x80, 0x3f);
+	/* enable Hi-Z setting 2 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x81, 0xff);
+	/* Cancel DVB-T2 setting */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x13);
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x83, 0x40);
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x86, 0x21);
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0x9e, 0x09, 0x0f);
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x9f, 0xfb);
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x2a);
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0x38, 0x00, 0x0f);
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x2b);
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0x11, 0x00, 0x3f);
+	/* Set SLV-X Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x00, 0x00);
+	/* disable ADC 1 */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x18, 0x01);
+	/* Set SLV-T Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);
+	/* Disable ADC 2 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x43, 0x0a);
+	/* Disable ADC 3 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x41, 0x0a);
+	/* Disable ADC clock */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x30, 0x00);
+	/* Disable RF level monitor */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x2f, 0x00);
+	/* Disable demod clock */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x2c, 0x00);
+	priv->state = STATE_SLEEP_TC;
+	return 0;
+}
+
+static int cxd2841er_active_c_to_sleep_tc(struct cxd2841er_priv *priv)
+{
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	if (priv->state != STATE_ACTIVE_TC) {
+		dev_err(&priv->i2c->dev, "%s(): invalid state %d\n",
+			__func__, priv->state);
+		return -EINVAL;
+	}
+	/* Set SLV-T Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);
+	/* disable TS output */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0xc3, 0x01);
+	/* enable Hi-Z setting 1 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x80, 0x3f);
+	/* enable Hi-Z setting 2 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x81, 0xff);
+	/* Cancel DVB-C setting */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x11);
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0xa3, 0x00, 0x1f);
+	/* Set SLV-X Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x00, 0x00);
+	/* disable ADC 1 */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x18, 0x01);
+	/* Set SLV-T Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);
+	/* Disable ADC 2 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x43, 0x0a);
+	/* Disable ADC 3 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x41, 0x0a);
+	/* Disable ADC clock */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x30, 0x00);
+	/* Disable RF level monitor */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x2f, 0x00);
+	/* Disable demod clock */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x2c, 0x00);
+	priv->state = STATE_SLEEP_TC;
+	return 0;
+}
+
+static int cxd2841er_active_i_to_sleep_tc(struct cxd2841er_priv *priv)
+{
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	if (priv->state != STATE_ACTIVE_TC) {
+		dev_err(&priv->i2c->dev, "%s(): invalid state %d\n",
+				__func__, priv->state);
+		return -EINVAL;
+	}
+	/* Set SLV-T Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);
+	/* disable TS output */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0xc3, 0x01);
+	/* enable Hi-Z setting 1 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x80, 0x3f);
+	/* enable Hi-Z setting 2 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x81, 0xff);
+
+	/* TODO: Cancel demod parameter */
+
+	/* Set SLV-X Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x00, 0x00);
+	/* disable ADC 1 */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x18, 0x01);
+	/* Set SLV-T Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);
+	/* Disable ADC 2 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x43, 0x0a);
+	/* Disable ADC 3 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x41, 0x0a);
+	/* Disable ADC clock */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x30, 0x00);
+	/* Disable RF level monitor */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x2f, 0x00);
+	/* Disable demod clock */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x2c, 0x00);
+	priv->state = STATE_SLEEP_TC;
+	return 0;
+}
+
+static int cxd2841er_shutdown_to_sleep_s(struct cxd2841er_priv *priv)
+{
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	if (priv->state != STATE_SHUTDOWN) {
+		dev_dbg(&priv->i2c->dev, "%s(): invalid demod state %d\n",
+			__func__, priv->state);
+		return -EINVAL;
+	}
+	/* Set SLV-X Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x00, 0x00);
+	/* Clear all demodulator registers */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x02, 0x00);
+	usleep_range(3000, 5000);
+	/* Set SLV-X Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x00, 0x00);
+	/* Set demod SW reset */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x10, 0x01);
+
+	switch (priv->xtal) {
+	case SONY_XTAL_20500:
+		cxd2841er_write_reg(priv, I2C_SLVX, 0x14, 0x00);
+		break;
+	case SONY_XTAL_24000:
+		/* Select demod frequency */
+		cxd2841er_write_reg(priv, I2C_SLVX, 0x12, 0x00);
+		cxd2841er_write_reg(priv, I2C_SLVX, 0x14, 0x03);
+		break;
+	case SONY_XTAL_41000:
+		cxd2841er_write_reg(priv, I2C_SLVX, 0x14, 0x01);
+		break;
+	default:
+		dev_dbg(&priv->i2c->dev, "%s(): invalid demod xtal %d\n",
+				__func__, priv->xtal);
+		return -EINVAL;
+	}
+
+	/* Set demod mode */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x17, 0x0a);
+	/* Clear demod SW reset */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x10, 0x00);
+	usleep_range(1000, 2000);
+	/* Set SLV-T Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);
+	/* enable DSQOUT */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x80, 0x1F);
+	/* enable DSQIN */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x9C, 0x40);
+	/* TADC Bias On */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x43, 0x0a);
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x41, 0x0a);
+	/* SADC Bias On */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x63, 0x16);
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x65, 0x27);
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x69, 0x06);
+	priv->state = STATE_SLEEP_S;
+	return 0;
+}
+
+static int cxd2841er_shutdown_to_sleep_tc(struct cxd2841er_priv *priv)
+{
+	u8 data = 0;
+
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	if (priv->state != STATE_SHUTDOWN) {
+		dev_dbg(&priv->i2c->dev, "%s(): invalid demod state %d\n",
+			__func__, priv->state);
+		return -EINVAL;
+	}
+	/* Set SLV-X Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x00, 0x00);
+	/* Clear all demodulator registers */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x02, 0x00);
+	usleep_range(3000, 5000);
+	/* Set SLV-X Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x00, 0x00);
+	/* Set demod SW reset */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x10, 0x01);
+  /* Select ADC clock mode */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x13, 0x00);
+
+	switch (priv->xtal) {
+	case SONY_XTAL_20500:
+		data = 0x0;
+		break;
+	case SONY_XTAL_24000:
+		/* Select demod frequency */
+		cxd2841er_write_reg(priv, I2C_SLVX, 0x12, 0x00);
+		data = 0x3;
+		break;
+	case SONY_XTAL_41000:
+		cxd2841er_write_reg(priv, I2C_SLVX, 0x12, 0x00);
+		data = 0x1;
+		break;
+	}
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x14, data);
+	/* Clear demod SW reset */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x10, 0x00);
+	usleep_range(1000, 2000);
+	/* Set SLV-T Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);
+	/* TADC Bias On */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x43, 0x0a);
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x41, 0x0a);
+	/* SADC Bias On */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x63, 0x16);
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x65, 0x27);
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x69, 0x06);
+	priv->state = STATE_SLEEP_TC;
+	return 0;
+}
+
+static int cxd2841er_tune_done(struct cxd2841er_priv *priv)
+{
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	/* Set SLV-T Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0, 0);
+	/* SW Reset */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0xfe, 0x01);
+	/* Enable TS output */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0xc3, 0x00);
+	return 0;
+}
+
+/* Set TS parallel mode */
+static void cxd2841er_set_ts_clock_mode(struct cxd2841er_priv *priv,
+					u8 system)
+{
+	u8 serial_ts, ts_rate_ctrl_off, ts_in_off;
+
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	/* Set SLV-T Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);
+	cxd2841er_read_reg(priv, I2C_SLVT, 0xc4, &serial_ts);
+	cxd2841er_read_reg(priv, I2C_SLVT, 0xd3, &ts_rate_ctrl_off);
+	cxd2841er_read_reg(priv, I2C_SLVT, 0xde, &ts_in_off);
+	dev_dbg(&priv->i2c->dev, "%s(): ser_ts=0x%02x rate_ctrl_off=0x%02x in_off=0x%02x\n",
+		__func__, serial_ts, ts_rate_ctrl_off, ts_in_off);
+
+	/*
+	 * slave    Bank    Addr    Bit    default    Name
+	 * <SLV-T>  00h     D9h     [7:0]  8'h08      OTSCKPERIOD
+	 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0xd9, 0x08);
+	/*
+	 * Disable TS IF Clock
+	 * slave    Bank    Addr    Bit    default    Name
+	 * <SLV-T>  00h     32h     [0]    1'b1       OREG_CK_TSIF_EN
+	 */
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0x32, 0x00, 0x01);
+	/*
+	 * slave    Bank    Addr    Bit    default    Name
+	 * <SLV-T>  00h     33h     [1:0]  2'b01      OREG_CKSEL_TSIF
+	 */
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0x33, 0x00, 0x03);
+	/*
+	 * Enable TS IF Clock
+	 * slave    Bank    Addr    Bit    default    Name
+	 * <SLV-T>  00h     32h     [0]    1'b1       OREG_CK_TSIF_EN
+	 */
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0x32, 0x01, 0x01);
+
+	if (system == SYS_DVBT) {
+		/* Enable parity period for DVB-T */
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);
+		cxd2841er_set_reg_bits(priv, I2C_SLVT, 0x66, 0x01, 0x01);
+	} else if (system == SYS_DVBC_ANNEX_A) {
+		/* Enable parity period for DVB-C */
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x40);
+		cxd2841er_set_reg_bits(priv, I2C_SLVT, 0x66, 0x01, 0x01);
+	}
+}
+
+static u8 cxd2841er_chip_id(struct cxd2841er_priv *priv)
+{
+	u8 chip_id = 0;
+
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	if (cxd2841er_write_reg(priv, I2C_SLVT, 0, 0) == 0)
+		cxd2841er_read_reg(priv, I2C_SLVT, 0xfd, &chip_id);
+	else if (cxd2841er_write_reg(priv, I2C_SLVX, 0, 0) == 0)
+		cxd2841er_read_reg(priv, I2C_SLVX, 0xfd, &chip_id);
+
+	return chip_id;
+}
+
+static int cxd2841er_read_status_s(struct dvb_frontend *fe,
+				   enum fe_status *status)
+{
+	u8 reg = 0;
+	struct cxd2841er_priv *priv = fe->demodulator_priv;
+
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	*status = 0;
+	if (priv->state != STATE_ACTIVE_S) {
+		dev_err(&priv->i2c->dev, "%s(): invalid state %d\n",
+			__func__, priv->state);
+		return -EINVAL;
+	}
+	/* Set SLV-T Bank : 0xA0 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0xa0);
+	/*
+	 *  slave     Bank      Addr      Bit      Signal name
+	 * <SLV-T>    A0h       11h       [2]      ITSLOCK
+	 */
+	cxd2841er_read_reg(priv, I2C_SLVT, 0x11, &reg);
+	if (reg & 0x04) {
+		*status = FE_HAS_SIGNAL
+			| FE_HAS_CARRIER
+			| FE_HAS_VITERBI
+			| FE_HAS_SYNC
+			| FE_HAS_LOCK;
+	}
+	dev_dbg(&priv->i2c->dev, "%s(): result 0x%x\n", __func__, *status);
+	return 0;
+}
+
+static int cxd2841er_read_status_t_t2(struct cxd2841er_priv *priv,
+				      u8 *sync, u8 *tslock, u8 *unlock)
+{
+	u8 data = 0;
+
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	if (priv->state != STATE_ACTIVE_TC)
+		return -EINVAL;
+	if (priv->system == SYS_DVBT) {
+		/* Set SLV-T Bank : 0x10 */
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);
+	} else {
+		/* Set SLV-T Bank : 0x20 */
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x20);
+	}
+	cxd2841er_read_reg(priv, I2C_SLVT, 0x10, &data);
+	if ((data & 0x07) == 0x07) {
+		dev_dbg(&priv->i2c->dev,
+			"%s(): invalid hardware state detected\n", __func__);
+		*sync = 0;
+		*tslock = 0;
+		*unlock = 0;
+	} else {
+		*sync = ((data & 0x07) == 0x6 ? 1 : 0);
+		*tslock = ((data & 0x20) ? 1 : 0);
+		*unlock = ((data & 0x10) ? 1 : 0);
+	}
+	return 0;
+}
+
+static int cxd2841er_read_status_c(struct cxd2841er_priv *priv, u8 *tslock)
+{
+	u8 data;
+
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	if (priv->state != STATE_ACTIVE_TC)
+		return -EINVAL;
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x40);
+	cxd2841er_read_reg(priv, I2C_SLVT, 0x88, &data);
+	if ((data & 0x01) == 0) {
+		*tslock = 0;
+	} else {
+		cxd2841er_read_reg(priv, I2C_SLVT, 0x10, &data);
+		*tslock = ((data & 0x20) ? 1 : 0);
+	}
+	return 0;
+}
+
+static int cxd2841er_read_status_i(struct cxd2841er_priv *priv,
+		u8 *sync, u8 *tslock, u8 *unlock)
+{
+	u8 data = 0;
+
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	if (priv->state != STATE_ACTIVE_TC)
+		return -EINVAL;
+	/* Set SLV-T Bank : 0x60 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x60);
+	cxd2841er_read_reg(priv, I2C_SLVT, 0x10, &data);
+	dev_dbg(&priv->i2c->dev,
+			"%s(): lock=0x%x\n", __func__, data);
+	*sync = ((data & 0x02) ? 1 : 0);
+	*tslock = ((data & 0x01) ? 1 : 0);
+	*unlock = ((data & 0x10) ? 1 : 0);
+	return 0;
+}
+
+static int cxd2841er_read_status_tc(struct dvb_frontend *fe,
+				    enum fe_status *status)
+{
+	int ret = 0;
+	u8 sync = 0;
+	u8 tslock = 0;
+	u8 unlock = 0;
+	struct cxd2841er_priv *priv = fe->demodulator_priv;
+
+	*status = 0;
+	if (priv->state == STATE_ACTIVE_TC) {
+		if (priv->system == SYS_DVBT || priv->system == SYS_DVBT2) {
+			ret = cxd2841er_read_status_t_t2(
+				priv, &sync, &tslock, &unlock);
+			if (ret)
+				goto done;
+			if (unlock)
+				goto done;
+			if (sync)
+				*status = FE_HAS_SIGNAL |
+					FE_HAS_CARRIER |
+					FE_HAS_VITERBI |
+					FE_HAS_SYNC;
+			if (tslock)
+				*status |= FE_HAS_LOCK;
+		} else if (priv->system == SYS_ISDBT) {
+			ret = cxd2841er_read_status_i(
+					priv, &sync, &tslock, &unlock);
+			if (ret)
+				goto done;
+			if (unlock)
+				goto done;
+			if (sync)
+				*status = FE_HAS_SIGNAL |
+					FE_HAS_CARRIER |
+					FE_HAS_VITERBI |
+					FE_HAS_SYNC;
+			if (tslock)
+				*status |= FE_HAS_LOCK;
+		} else if (priv->system == SYS_DVBC_ANNEX_A) {
+			ret = cxd2841er_read_status_c(priv, &tslock);
+			if (ret)
+				goto done;
+			if (tslock)
+				*status = FE_HAS_SIGNAL |
+					FE_HAS_CARRIER |
+					FE_HAS_VITERBI |
+					FE_HAS_SYNC |
+					FE_HAS_LOCK;
+		}
+	}
+done:
+	dev_dbg(&priv->i2c->dev, "%s(): status 0x%x\n", __func__, *status);
+	return ret;
+}
+
+static int cxd2841er_get_carrier_offset_s_s2(struct cxd2841er_priv *priv,
+					     int *offset)
+{
+	u8 data[3];
+	u8 is_hs_mode;
+	s32 cfrl_ctrlval;
+	s32 temp_div, temp_q, temp_r;
+
+	if (priv->state != STATE_ACTIVE_S) {
+		dev_dbg(&priv->i2c->dev, "%s(): invalid state %d\n",
+			__func__, priv->state);
+		return -EINVAL;
+	}
+	/*
+	 * Get High Sampling Rate mode
+	 *  slave     Bank      Addr      Bit      Signal name
+	 * <SLV-T>    A0h       10h       [0]      ITRL_LOCK
+	 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0xa0);
+	cxd2841er_read_reg(priv, I2C_SLVT, 0x10, &data[0]);
+	if (data[0] & 0x01) {
+		/*
+		 *  slave     Bank      Addr      Bit      Signal name
+		 * <SLV-T>    A0h       50h       [4]      IHSMODE
+		 */
+		cxd2841er_read_reg(priv, I2C_SLVT, 0x50, &data[0]);
+		is_hs_mode = (data[0] & 0x10 ? 1 : 0);
+	} else {
+		dev_dbg(&priv->i2c->dev,
+			"%s(): unable to detect sampling rate mode\n",
+			__func__);
+		return -EINVAL;
+	}
+	/*
+	 *  slave     Bank      Addr      Bit      Signal name
+	 * <SLV-T>    A0h       45h       [4:0]    ICFRL_CTRLVAL[20:16]
+	 * <SLV-T>    A0h       46h       [7:0]    ICFRL_CTRLVAL[15:8]
+	 * <SLV-T>    A0h       47h       [7:0]    ICFRL_CTRLVAL[7:0]
+	 */
+	cxd2841er_read_regs(priv, I2C_SLVT, 0x45, data, 3);
+	cfrl_ctrlval = sign_extend32((((u32)data[0] & 0x1F) << 16) |
+				(((u32)data[1] & 0xFF) <<  8) |
+				((u32)data[2] & 0xFF), 20);
+	temp_div = (is_hs_mode ? 1048576 : 1572864);
+	if (cfrl_ctrlval > 0) {
+		temp_q = div_s64_rem(97375LL * cfrl_ctrlval,
+			temp_div, &temp_r);
+	} else {
+		temp_q = div_s64_rem(-97375LL * cfrl_ctrlval,
+			temp_div, &temp_r);
+	}
+	if (temp_r >= temp_div / 2)
+		temp_q++;
+	if (cfrl_ctrlval > 0)
+		temp_q *= -1;
+	*offset = temp_q;
+	return 0;
+}
+
+static int cxd2841er_get_carrier_offset_i(struct cxd2841er_priv *priv,
+					   u32 bandwidth, int *offset)
+{
+	u8 data[4];
+
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	if (priv->state != STATE_ACTIVE_TC) {
+		dev_dbg(&priv->i2c->dev, "%s(): invalid state %d\n",
+			__func__, priv->state);
+		return -EINVAL;
+	}
+	if (priv->system != SYS_ISDBT) {
+		dev_dbg(&priv->i2c->dev, "%s(): invalid delivery system %d\n",
+			__func__, priv->system);
+		return -EINVAL;
+	}
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x60);
+	cxd2841er_read_regs(priv, I2C_SLVT, 0x4c, data, sizeof(data));
+	*offset = -1 * sign_extend32(
+		((u32)(data[0] & 0x1F) << 24) | ((u32)data[1] << 16) |
+		((u32)data[2] << 8) | (u32)data[3], 29);
+
+	switch (bandwidth) {
+	case 6000000:
+		*offset = -1 * ((*offset) * 8/264);
+		break;
+	case 7000000:
+		*offset = -1 * ((*offset) * 8/231);
+		break;
+	case 8000000:
+		*offset = -1 * ((*offset) * 8/198);
+		break;
+	default:
+		dev_dbg(&priv->i2c->dev, "%s(): invalid bandwidth %d\n",
+				__func__, bandwidth);
+		return -EINVAL;
+	}
+
+	dev_dbg(&priv->i2c->dev, "%s(): bandwidth %d offset %d\n",
+			__func__, bandwidth, *offset);
+
+	return 0;
+}
+
+static int cxd2841er_get_carrier_offset_t(struct cxd2841er_priv *priv,
+					   u32 bandwidth, int *offset)
+{
+	u8 data[4];
+
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	if (priv->state != STATE_ACTIVE_TC) {
+		dev_dbg(&priv->i2c->dev, "%s(): invalid state %d\n",
+			__func__, priv->state);
+		return -EINVAL;
+	}
+	if (priv->system != SYS_DVBT) {
+		dev_dbg(&priv->i2c->dev, "%s(): invalid delivery system %d\n",
+			__func__, priv->system);
+		return -EINVAL;
+	}
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);
+	cxd2841er_read_regs(priv, I2C_SLVT, 0x4c, data, sizeof(data));
+	*offset = -1 * sign_extend32(
+		((u32)(data[0] & 0x1F) << 24) | ((u32)data[1] << 16) |
+		((u32)data[2] << 8) | (u32)data[3], 29);
+	*offset *= (bandwidth / 1000000);
+	*offset /= 235;
+	return 0;
+}
+
+static int cxd2841er_get_carrier_offset_t2(struct cxd2841er_priv *priv,
+					   u32 bandwidth, int *offset)
+{
+	u8 data[4];
+
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	if (priv->state != STATE_ACTIVE_TC) {
+		dev_dbg(&priv->i2c->dev, "%s(): invalid state %d\n",
+			__func__, priv->state);
+		return -EINVAL;
+	}
+	if (priv->system != SYS_DVBT2) {
+		dev_dbg(&priv->i2c->dev, "%s(): invalid delivery system %d\n",
+			__func__, priv->system);
+		return -EINVAL;
+	}
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x20);
+	cxd2841er_read_regs(priv, I2C_SLVT, 0x4c, data, sizeof(data));
+	*offset = -1 * sign_extend32(
+		((u32)(data[0] & 0x0F) << 24) | ((u32)data[1] << 16) |
+		((u32)data[2] << 8) | (u32)data[3], 27);
+	switch (bandwidth) {
+	case 1712000:
+		*offset /= 582;
+		break;
+	case 5000000:
+	case 6000000:
+	case 7000000:
+	case 8000000:
+		*offset *= (bandwidth / 1000000);
+		*offset /= 940;
+		break;
+	default:
+		dev_dbg(&priv->i2c->dev, "%s(): invalid bandwidth %d\n",
+			__func__, bandwidth);
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int cxd2841er_get_carrier_offset_c(struct cxd2841er_priv *priv,
+					  int *offset)
+{
+	u8 data[2];
+
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	if (priv->state != STATE_ACTIVE_TC) {
+		dev_dbg(&priv->i2c->dev, "%s(): invalid state %d\n",
+			__func__, priv->state);
+		return -EINVAL;
+	}
+	if (priv->system != SYS_DVBC_ANNEX_A) {
+		dev_dbg(&priv->i2c->dev, "%s(): invalid delivery system %d\n",
+			__func__, priv->system);
+		return -EINVAL;
+	}
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x40);
+	cxd2841er_read_regs(priv, I2C_SLVT, 0x15, data, sizeof(data));
+	*offset = div_s64(41000LL * sign_extend32((((u32)data[0] & 0x3f) << 8)
+						| (u32)data[1], 13), 16384);
+	return 0;
+}
+
+static int cxd2841er_read_packet_errors_c(
+		struct cxd2841er_priv *priv, u32 *penum)
+{
+	u8 data[3];
+
+	*penum = 0;
+	if (priv->state != STATE_ACTIVE_TC) {
+		dev_dbg(&priv->i2c->dev, "%s(): invalid state %d\n",
+				__func__, priv->state);
+		return -EINVAL;
+	}
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x40);
+	cxd2841er_read_regs(priv, I2C_SLVT, 0xea, data, sizeof(data));
+	if (data[2] & 0x01)
+		*penum = ((u32)data[0] << 8) | (u32)data[1];
+	return 0;
+}
+
+static int cxd2841er_read_packet_errors_t(
+		struct cxd2841er_priv *priv, u32 *penum)
+{
+	u8 data[3];
+
+	*penum = 0;
+	if (priv->state != STATE_ACTIVE_TC) {
+		dev_dbg(&priv->i2c->dev, "%s(): invalid state %d\n",
+			__func__, priv->state);
+		return -EINVAL;
+	}
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);
+	cxd2841er_read_regs(priv, I2C_SLVT, 0xea, data, sizeof(data));
+	if (data[2] & 0x01)
+		*penum = ((u32)data[0] << 8) | (u32)data[1];
+	return 0;
+}
+
+static int cxd2841er_read_packet_errors_t2(
+		struct cxd2841er_priv *priv, u32 *penum)
+{
+	u8 data[3];
+
+	*penum = 0;
+	if (priv->state != STATE_ACTIVE_TC) {
+		dev_dbg(&priv->i2c->dev, "%s(): invalid state %d\n",
+			__func__, priv->state);
+		return -EINVAL;
+	}
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x24);
+	cxd2841er_read_regs(priv, I2C_SLVT, 0xfd, data, sizeof(data));
+	if (data[0] & 0x01)
+		*penum = ((u32)data[1] << 8) | (u32)data[2];
+	return 0;
+}
+
+static int cxd2841er_read_packet_errors_i(
+		struct cxd2841er_priv *priv, u32 *penum)
+{
+	u8 data[2];
+
+	*penum = 0;
+	if (priv->state != STATE_ACTIVE_TC) {
+		dev_dbg(&priv->i2c->dev, "%s(): invalid state %d\n",
+				__func__, priv->state);
+		return -EINVAL;
+	}
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x60);
+	cxd2841er_read_regs(priv, I2C_SLVT, 0xA1, data, 1);
+
+	if (!(data[0] & 0x01))
+		return 0;
+
+	/* Layer A */
+	cxd2841er_read_regs(priv, I2C_SLVT, 0xA2, data, sizeof(data));
+	*penum = ((u32)data[0] << 8) | (u32)data[1];
+
+	/* Layer B */
+	cxd2841er_read_regs(priv, I2C_SLVT, 0xA4, data, sizeof(data));
+	*penum += ((u32)data[0] << 8) | (u32)data[1];
+
+	/* Layer C */
+	cxd2841er_read_regs(priv, I2C_SLVT, 0xA6, data, sizeof(data));
+	*penum += ((u32)data[0] << 8) | (u32)data[1];
+
+	return 0;
+}
+
+static int cxd2841er_read_ber_c(struct cxd2841er_priv *priv,
+		u32 *bit_error, u32 *bit_count)
+{
+	u8 data[3];
+	u32 bit_err, period_exp;
+
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	if (priv->state != STATE_ACTIVE_TC) {
+		dev_dbg(&priv->i2c->dev, "%s(): invalid state %d\n",
+				__func__, priv->state);
+		return -EINVAL;
+	}
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x40);
+	cxd2841er_read_regs(priv, I2C_SLVT, 0x62, data, sizeof(data));
+	if (!(data[0] & 0x80)) {
+		dev_dbg(&priv->i2c->dev,
+				"%s(): no valid BER data\n", __func__);
+		return -EINVAL;
+	}
+	bit_err = ((u32)(data[0] & 0x3f) << 16) |
+		((u32)data[1] << 8) |
+		(u32)data[2];
+	cxd2841er_read_reg(priv, I2C_SLVT, 0x60, data);
+	period_exp = data[0] & 0x1f;
+
+	if ((period_exp <= 11) && (bit_err > (1 << period_exp) * 204 * 8)) {
+		dev_dbg(&priv->i2c->dev,
+				"%s(): period_exp(%u) or bit_err(%u)  not in range. no valid BER data\n",
+				__func__, period_exp, bit_err);
+		return -EINVAL;
+	}
+
+	dev_dbg(&priv->i2c->dev,
+			"%s(): period_exp(%u) or bit_err(%u) count=%d\n",
+			__func__, period_exp, bit_err,
+			((1 << period_exp) * 204 * 8));
+
+	*bit_error = bit_err;
+	*bit_count = ((1 << period_exp) * 204 * 8);
+
+	return 0;
+}
+
+static int cxd2841er_mon_read_ber_s(struct cxd2841er_priv *priv,
+				    u32 *bit_error, u32 *bit_count)
+{
+	u8 data[11];
+
+	/* Set SLV-T Bank : 0xA0 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0xa0);
+	/*
+	 *  slave     Bank      Addr      Bit      Signal name
+	 * <SLV-T>    A0h       35h       [0]      IFVBER_VALID
+	 * <SLV-T>    A0h       36h       [5:0]    IFVBER_BITERR[21:16]
+	 * <SLV-T>    A0h       37h       [7:0]    IFVBER_BITERR[15:8]
+	 * <SLV-T>    A0h       38h       [7:0]    IFVBER_BITERR[7:0]
+	 * <SLV-T>    A0h       3Dh       [5:0]    IFVBER_BITNUM[21:16]
+	 * <SLV-T>    A0h       3Eh       [7:0]    IFVBER_BITNUM[15:8]
+	 * <SLV-T>    A0h       3Fh       [7:0]    IFVBER_BITNUM[7:0]
+	 */
+	cxd2841er_read_regs(priv, I2C_SLVT, 0x35, data, 11);
+	if (data[0] & 0x01) {
+		*bit_error = ((u32)(data[1]  & 0x3F) << 16) |
+			     ((u32)(data[2]  & 0xFF) <<  8) |
+			     (u32)(data[3]  & 0xFF);
+		*bit_count = ((u32)(data[8]  & 0x3F) << 16) |
+			     ((u32)(data[9]  & 0xFF) <<  8) |
+			     (u32)(data[10] & 0xFF);
+		if ((*bit_count == 0) || (*bit_error > *bit_count)) {
+			dev_dbg(&priv->i2c->dev,
+				"%s(): invalid bit_error %d, bit_count %d\n",
+				__func__, *bit_error, *bit_count);
+			return -EINVAL;
+		}
+		return 0;
+	}
+	dev_dbg(&priv->i2c->dev, "%s(): no data available\n", __func__);
+	return -EINVAL;
+}
+
+
+static int cxd2841er_mon_read_ber_s2(struct cxd2841er_priv *priv,
+				     u32 *bit_error, u32 *bit_count)
+{
+	u8 data[5];
+	u32 period;
+
+	/* Set SLV-T Bank : 0xB2 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0xb2);
+	/*
+	 *  slave     Bank      Addr      Bit      Signal name
+	 * <SLV-T>    B2h       30h       [0]      IFLBER_VALID
+	 * <SLV-T>    B2h       31h       [3:0]    IFLBER_BITERR[27:24]
+	 * <SLV-T>    B2h       32h       [7:0]    IFLBER_BITERR[23:16]
+	 * <SLV-T>    B2h       33h       [7:0]    IFLBER_BITERR[15:8]
+	 * <SLV-T>    B2h       34h       [7:0]    IFLBER_BITERR[7:0]
+	 */
+	cxd2841er_read_regs(priv, I2C_SLVT, 0x30, data, 5);
+	if (data[0] & 0x01) {
+		/* Bit error count */
+		*bit_error = ((u32)(data[1] & 0x0F) << 24) |
+			     ((u32)(data[2] & 0xFF) << 16) |
+			     ((u32)(data[3] & 0xFF) <<  8) |
+			     (u32)(data[4] & 0xFF);
+
+		/* Set SLV-T Bank : 0xA0 */
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0xa0);
+		cxd2841er_read_reg(priv, I2C_SLVT, 0x7a, data);
+		/* Measurement period */
+		period = (u32)(1 << (data[0] & 0x0F));
+		if (period == 0) {
+			dev_dbg(&priv->i2c->dev,
+				"%s(): period is 0\n", __func__);
+			return -EINVAL;
+		}
+		if (*bit_error > (period * 64800)) {
+			dev_dbg(&priv->i2c->dev,
+				"%s(): invalid bit_err 0x%x period 0x%x\n",
+				__func__, *bit_error, period);
+			return -EINVAL;
+		}
+		*bit_count = period * 64800;
+
+		return 0;
+	} else {
+		dev_dbg(&priv->i2c->dev,
+			"%s(): no data available\n", __func__);
+	}
+	return -EINVAL;
+}
+
+static int cxd2841er_read_ber_t2(struct cxd2841er_priv *priv,
+				 u32 *bit_error, u32 *bit_count)
+{
+	u8 data[4];
+	u32 period_exp, n_ldpc;
+
+	if (priv->state != STATE_ACTIVE_TC) {
+		dev_dbg(&priv->i2c->dev,
+			"%s(): invalid state %d\n", __func__, priv->state);
+		return -EINVAL;
+	}
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x20);
+	cxd2841er_read_regs(priv, I2C_SLVT, 0x39, data, sizeof(data));
+	if (!(data[0] & 0x10)) {
+		dev_dbg(&priv->i2c->dev,
+			"%s(): no valid BER data\n", __func__);
+		return -EINVAL;
+	}
+	*bit_error = ((u32)(data[0] & 0x0f) << 24) |
+		     ((u32)data[1] << 16) |
+		     ((u32)data[2] << 8) |
+		     (u32)data[3];
+	cxd2841er_read_reg(priv, I2C_SLVT, 0x6f, data);
+	period_exp = data[0] & 0x0f;
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x22);
+	cxd2841er_read_reg(priv, I2C_SLVT, 0x5e, data);
+	n_ldpc = ((data[0] & 0x03) == 0 ? 16200 : 64800);
+	if (*bit_error > ((1U << period_exp) * n_ldpc)) {
+		dev_dbg(&priv->i2c->dev,
+			"%s(): invalid BER value\n", __func__);
+		return -EINVAL;
+	}
+
+	/*
+	 * FIXME: the right thing would be to return bit_error untouched,
+	 * but, as we don't know the scale returned by the counters, let's
+	 * at least preserver BER = bit_error/bit_count.
+	 */
+	if (period_exp >= 4) {
+		*bit_count = (1U << (period_exp - 4)) * (n_ldpc / 200);
+		*bit_error *= 3125ULL;
+	} else {
+		*bit_count = (1U << period_exp) * (n_ldpc / 200);
+		*bit_error *= 50000ULL;
+	}
+	return 0;
+}
+
+static int cxd2841er_read_ber_t(struct cxd2841er_priv *priv,
+				u32 *bit_error, u32 *bit_count)
+{
+	u8 data[2];
+	u32 period;
+
+	if (priv->state != STATE_ACTIVE_TC) {
+		dev_dbg(&priv->i2c->dev,
+			"%s(): invalid state %d\n", __func__, priv->state);
+		return -EINVAL;
+	}
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);
+	cxd2841er_read_reg(priv, I2C_SLVT, 0x39, data);
+	if (!(data[0] & 0x01)) {
+		dev_dbg(&priv->i2c->dev,
+			"%s(): no valid BER data\n", __func__);
+		return 0;
+	}
+	cxd2841er_read_regs(priv, I2C_SLVT, 0x22, data, sizeof(data));
+	*bit_error = ((u32)data[0] << 8) | (u32)data[1];
+	cxd2841er_read_reg(priv, I2C_SLVT, 0x6f, data);
+	period = ((data[0] & 0x07) == 0) ? 256 : (4096 << (data[0] & 0x07));
+
+	/*
+	 * FIXME: the right thing would be to return bit_error untouched,
+	 * but, as we don't know the scale returned by the counters, let's
+	 * at least preserver BER = bit_error/bit_count.
+	 */
+	*bit_count = period / 128;
+	*bit_error *= 78125ULL;
+	return 0;
+}
+
+static u32 cxd2841er_dvbs_read_snr(struct cxd2841er_priv *priv,
+		u8 delsys, u32 *snr)
+{
+	u8 data[3];
+	u32 res = 0, value;
+	int min_index, max_index, index;
+	static const struct cxd2841er_cnr_data *cn_data;
+
+	/* Set SLV-T Bank : 0xA1 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0xa1);
+	/*
+	 *  slave     Bank      Addr      Bit     Signal name
+	 * <SLV-T>    A1h       10h       [0]     ICPM_QUICKRDY
+	 * <SLV-T>    A1h       11h       [4:0]   ICPM_QUICKCNDT[12:8]
+	 * <SLV-T>    A1h       12h       [7:0]   ICPM_QUICKCNDT[7:0]
+	 */
+	cxd2841er_read_regs(priv, I2C_SLVT, 0x10, data, 3);
+	if (data[0] & 0x01) {
+		value = ((u32)(data[1] & 0x1F) << 8) | (u32)(data[2] & 0xFF);
+		min_index = 0;
+		if (delsys == SYS_DVBS) {
+			cn_data = s_cn_data;
+			max_index = sizeof(s_cn_data) /
+				sizeof(s_cn_data[0]) - 1;
+		} else {
+			cn_data = s2_cn_data;
+			max_index = sizeof(s2_cn_data) /
+				sizeof(s2_cn_data[0]) - 1;
+		}
+		if (value >= cn_data[min_index].value) {
+			res = cn_data[min_index].cnr_x1000;
+			goto done;
+		}
+		if (value <= cn_data[max_index].value) {
+			res = cn_data[max_index].cnr_x1000;
+			goto done;
+		}
+		while ((max_index - min_index) > 1) {
+			index = (max_index + min_index) / 2;
+			if (value == cn_data[index].value) {
+				res = cn_data[index].cnr_x1000;
+				goto done;
+			} else if (value > cn_data[index].value)
+				max_index = index;
+			else
+				min_index = index;
+			if ((max_index - min_index) <= 1) {
+				if (value == cn_data[max_index].value) {
+					res = cn_data[max_index].cnr_x1000;
+					goto done;
+				} else {
+					res = cn_data[min_index].cnr_x1000;
+					goto done;
+				}
+			}
+		}
+	} else {
+		dev_dbg(&priv->i2c->dev,
+			"%s(): no data available\n", __func__);
+		return -EINVAL;
+	}
+done:
+	*snr = res;
+	return 0;
+}
+
+static uint32_t sony_log(uint32_t x)
+{
+	return (((10000>>8)*(intlog2(x)>>16) + LOG2_E_100X/2)/LOG2_E_100X);
+}
+
+static int cxd2841er_read_snr_c(struct cxd2841er_priv *priv, u32 *snr)
+{
+	u32 reg;
+	u8 data[2];
+	enum sony_dvbc_constellation_t qam = SONY_DVBC_CONSTELLATION_16QAM;
+
+	*snr = 0;
+	if (priv->state != STATE_ACTIVE_TC) {
+		dev_dbg(&priv->i2c->dev,
+				"%s(): invalid state %d\n",
+				__func__, priv->state);
+		return -EINVAL;
+	}
+
+	/*
+	 * Freeze registers: ensure multiple separate register reads
+	 * are from the same snapshot
+	 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x01, 0x01);
+
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x40);
+	cxd2841er_read_regs(priv, I2C_SLVT, 0x19, data, 1);
+	qam = (enum sony_dvbc_constellation_t) (data[0] & 0x07);
+	cxd2841er_read_regs(priv, I2C_SLVT, 0x4C, data, 2);
+
+	reg = ((u32)(data[0]&0x1f) << 8) | (u32)data[1];
+	if (reg == 0) {
+		dev_dbg(&priv->i2c->dev,
+				"%s(): reg value out of range\n", __func__);
+		return 0;
+	}
+
+	switch (qam) {
+	case SONY_DVBC_CONSTELLATION_16QAM:
+	case SONY_DVBC_CONSTELLATION_64QAM:
+	case SONY_DVBC_CONSTELLATION_256QAM:
+		/* SNR(dB) = -9.50 * ln(IREG_SNR_ESTIMATE / (24320)) */
+		if (reg < 126)
+			reg = 126;
+		*snr = -95 * (int32_t)sony_log(reg) + 95941;
+		break;
+	case SONY_DVBC_CONSTELLATION_32QAM:
+	case SONY_DVBC_CONSTELLATION_128QAM:
+		/* SNR(dB) = -8.75 * ln(IREG_SNR_ESTIMATE / (20800)) */
+		if (reg < 69)
+			reg = 69;
+		*snr = -88 * (int32_t)sony_log(reg) + 86999;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int cxd2841er_read_snr_t(struct cxd2841er_priv *priv, u32 *snr)
+{
+	u32 reg;
+	u8 data[2];
+
+	*snr = 0;
+	if (priv->state != STATE_ACTIVE_TC) {
+		dev_dbg(&priv->i2c->dev,
+			"%s(): invalid state %d\n", __func__, priv->state);
+		return -EINVAL;
+	}
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);
+	cxd2841er_read_regs(priv, I2C_SLVT, 0x28, data, sizeof(data));
+	reg = ((u32)data[0] << 8) | (u32)data[1];
+	if (reg == 0) {
+		dev_dbg(&priv->i2c->dev,
+			"%s(): reg value out of range\n", __func__);
+		return 0;
+	}
+	if (reg > 4996)
+		reg = 4996;
+	*snr = 10000 * ((intlog10(reg) - intlog10(5350 - reg)) >> 24) + 28500;
+	return 0;
+}
+
+static int cxd2841er_read_snr_t2(struct cxd2841er_priv *priv, u32 *snr)
+{
+	u32 reg;
+	u8 data[2];
+
+	*snr = 0;
+	if (priv->state != STATE_ACTIVE_TC) {
+		dev_dbg(&priv->i2c->dev,
+			"%s(): invalid state %d\n", __func__, priv->state);
+		return -EINVAL;
+	}
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x20);
+	cxd2841er_read_regs(priv, I2C_SLVT, 0x28, data, sizeof(data));
+	reg = ((u32)data[0] << 8) | (u32)data[1];
+	if (reg == 0) {
+		dev_dbg(&priv->i2c->dev,
+			"%s(): reg value out of range\n", __func__);
+		return 0;
+	}
+	if (reg > 10876)
+		reg = 10876;
+	*snr = 10000 * ((intlog10(reg) -
+		intlog10(12600 - reg)) >> 24) + 32000;
+	return 0;
+}
+
+static int cxd2841er_read_snr_i(struct cxd2841er_priv *priv, u32 *snr)
+{
+	u32 reg;
+	u8 data[2];
+
+	*snr = 0;
+	if (priv->state != STATE_ACTIVE_TC) {
+		dev_dbg(&priv->i2c->dev,
+				"%s(): invalid state %d\n", __func__,
+				priv->state);
+		return -EINVAL;
+	}
+
+	/* Freeze all registers */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x01, 0x01);
+
+
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x60);
+	cxd2841er_read_regs(priv, I2C_SLVT, 0x28, data, sizeof(data));
+	reg = ((u32)data[0] << 8) | (u32)data[1];
+	if (reg == 0) {
+		dev_dbg(&priv->i2c->dev,
+				"%s(): reg value out of range\n", __func__);
+		return 0;
+	}
+	if (reg > 4996)
+		reg = 4996;
+	*snr = 100 * intlog10(reg) - 9031;
+	return 0;
+}
+
+static u16 cxd2841er_read_agc_gain_c(struct cxd2841er_priv *priv,
+					u8 delsys)
+{
+	u8 data[2];
+
+	cxd2841er_write_reg(
+		priv, I2C_SLVT, 0x00, 0x40);
+	cxd2841er_read_regs(priv, I2C_SLVT, 0x49, data, 2);
+	dev_dbg(&priv->i2c->dev,
+			"%s(): AGC value=%u\n",
+			__func__, (((u16)data[0] & 0x0F) << 8) |
+			(u16)(data[1] & 0xFF));
+	return ((((u16)data[0] & 0x0F) << 8) | (u16)(data[1] & 0xFF)) << 4;
+}
+
+static u16 cxd2841er_read_agc_gain_t_t2(struct cxd2841er_priv *priv,
+					u8 delsys)
+{
+	u8 data[2];
+
+	cxd2841er_write_reg(
+		priv, I2C_SLVT, 0x00, (delsys == SYS_DVBT ? 0x10 : 0x20));
+	cxd2841er_read_regs(priv, I2C_SLVT, 0x26, data, 2);
+	dev_dbg(&priv->i2c->dev,
+			"%s(): AGC value=%u\n",
+			__func__, (((u16)data[0] & 0x0F) << 8) |
+			(u16)(data[1] & 0xFF));
+	return ((((u16)data[0] & 0x0F) << 8) | (u16)(data[1] & 0xFF)) << 4;
+}
+
+static u16 cxd2841er_read_agc_gain_i(struct cxd2841er_priv *priv,
+		u8 delsys)
+{
+	u8 data[2];
+
+	cxd2841er_write_reg(
+			priv, I2C_SLVT, 0x00, 0x60);
+	cxd2841er_read_regs(priv, I2C_SLVT, 0x26, data, 2);
+
+	dev_dbg(&priv->i2c->dev,
+			"%s(): AGC value=%u\n",
+			__func__, (((u16)data[0] & 0x0F) << 8) |
+			(u16)(data[1] & 0xFF));
+	return ((((u16)data[0] & 0x0F) << 8) | (u16)(data[1] & 0xFF)) << 4;
+}
+
+static u16 cxd2841er_read_agc_gain_s(struct cxd2841er_priv *priv)
+{
+	u8 data[2];
+
+	/* Set SLV-T Bank : 0xA0 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0xa0);
+	/*
+	 *  slave     Bank      Addr      Bit       Signal name
+	 * <SLV-T>    A0h       1Fh       [4:0]     IRFAGC_GAIN[12:8]
+	 * <SLV-T>    A0h       20h       [7:0]     IRFAGC_GAIN[7:0]
+	 */
+	cxd2841er_read_regs(priv, I2C_SLVT, 0x1f, data, 2);
+	return ((((u16)data[0] & 0x1F) << 8) | (u16)(data[1] & 0xFF)) << 3;
+}
+
+static void cxd2841er_read_ber(struct dvb_frontend *fe)
+{
+	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
+	struct cxd2841er_priv *priv = fe->demodulator_priv;
+	u32 ret, bit_error = 0, bit_count = 0;
+
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	switch (p->delivery_system) {
+	case SYS_DVBC_ANNEX_A:
+	case SYS_DVBC_ANNEX_B:
+	case SYS_DVBC_ANNEX_C:
+		ret = cxd2841er_read_ber_c(priv, &bit_error, &bit_count);
+		break;
+	case SYS_DVBS:
+		ret = cxd2841er_mon_read_ber_s(priv, &bit_error, &bit_count);
+		break;
+	case SYS_DVBS2:
+		ret = cxd2841er_mon_read_ber_s2(priv, &bit_error, &bit_count);
+		break;
+	case SYS_DVBT:
+		ret = cxd2841er_read_ber_t(priv, &bit_error, &bit_count);
+		break;
+	case SYS_DVBT2:
+		ret = cxd2841er_read_ber_t2(priv, &bit_error, &bit_count);
+		break;
+	default:
+		p->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+		p->post_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+		return;
+	}
+
+	if (!ret) {
+		p->post_bit_error.stat[0].scale = FE_SCALE_COUNTER;
+		p->post_bit_error.stat[0].uvalue += bit_error;
+		p->post_bit_count.stat[0].scale = FE_SCALE_COUNTER;
+		p->post_bit_count.stat[0].uvalue += bit_count;
+	} else {
+		p->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+		p->post_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+	}
+}
+
+static void cxd2841er_read_signal_strength(struct dvb_frontend *fe)
+{
+	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
+	struct cxd2841er_priv *priv = fe->demodulator_priv;
+	s32 strength;
+
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	switch (p->delivery_system) {
+	case SYS_DVBT:
+	case SYS_DVBT2:
+		strength = cxd2841er_read_agc_gain_t_t2(priv,
+							p->delivery_system);
+		p->strength.stat[0].scale = FE_SCALE_DECIBEL;
+		/* Formula was empirically determinated @ 410 MHz */
+		p->strength.stat[0].uvalue = strength * 366 / 100 - 89520;
+		break;	/* Code moved out of the function */
+	case SYS_DVBC_ANNEX_A:
+	case SYS_DVBC_ANNEX_B:
+	case SYS_DVBC_ANNEX_C:
+		strength = cxd2841er_read_agc_gain_c(priv,
+							p->delivery_system);
+		p->strength.stat[0].scale = FE_SCALE_DECIBEL;
+		/*
+		 * Formula was empirically determinated via linear regression,
+		 * using frequencies: 175 MHz, 410 MHz and 800 MHz, and a
+		 * stream modulated with QAM64
+		 */
+		p->strength.stat[0].uvalue = strength * 4045 / 1000 - 85224;
+		break;
+	case SYS_ISDBT:
+		strength = cxd2841er_read_agc_gain_i(priv, p->delivery_system);
+		p->strength.stat[0].scale = FE_SCALE_DECIBEL;
+		/*
+		 * Formula was empirically determinated via linear regression,
+		 * using frequencies: 175 MHz, 410 MHz and 800 MHz.
+		 */
+		p->strength.stat[0].uvalue = strength * 3775 / 1000 - 90185;
+		break;
+	case SYS_DVBS:
+	case SYS_DVBS2:
+		strength = 65535 - cxd2841er_read_agc_gain_s(priv);
+		p->strength.stat[0].scale = FE_SCALE_RELATIVE;
+		p->strength.stat[0].uvalue = strength;
+		break;
+	default:
+		p->strength.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+		break;
+	}
+}
+
+static void cxd2841er_read_snr(struct dvb_frontend *fe)
+{
+	u32 tmp = 0;
+	int ret = 0;
+	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
+	struct cxd2841er_priv *priv = fe->demodulator_priv;
+
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	switch (p->delivery_system) {
+	case SYS_DVBC_ANNEX_A:
+	case SYS_DVBC_ANNEX_B:
+	case SYS_DVBC_ANNEX_C:
+		ret = cxd2841er_read_snr_c(priv, &tmp);
+		break;
+	case SYS_DVBT:
+		ret = cxd2841er_read_snr_t(priv, &tmp);
+		break;
+	case SYS_DVBT2:
+		ret = cxd2841er_read_snr_t2(priv, &tmp);
+		break;
+	case SYS_ISDBT:
+		ret = cxd2841er_read_snr_i(priv, &tmp);
+		break;
+	case SYS_DVBS:
+	case SYS_DVBS2:
+		ret = cxd2841er_dvbs_read_snr(priv, p->delivery_system, &tmp);
+		break;
+	default:
+		dev_dbg(&priv->i2c->dev, "%s(): unknown delivery system %d\n",
+			__func__, p->delivery_system);
+		p->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+		return;
+	}
+
+	if (!ret) {
+		p->cnr.stat[0].scale = FE_SCALE_DECIBEL;
+		p->cnr.stat[0].svalue = tmp;
+	} else {
+		p->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+	}
+}
+
+static void cxd2841er_read_ucblocks(struct dvb_frontend *fe)
+{
+	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
+	struct cxd2841er_priv *priv = fe->demodulator_priv;
+	u32 ucblocks;
+
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	switch (p->delivery_system) {
+	case SYS_DVBC_ANNEX_A:
+	case SYS_DVBC_ANNEX_B:
+	case SYS_DVBC_ANNEX_C:
+		cxd2841er_read_packet_errors_c(priv, &ucblocks);
+		break;
+	case SYS_DVBT:
+		cxd2841er_read_packet_errors_t(priv, &ucblocks);
+		break;
+	case SYS_DVBT2:
+		cxd2841er_read_packet_errors_t2(priv, &ucblocks);
+		break;
+	case SYS_ISDBT:
+		cxd2841er_read_packet_errors_i(priv, &ucblocks);
+		break;
+	default:
+		p->block_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+		return;
+	}
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+
+	p->block_error.stat[0].scale = FE_SCALE_COUNTER;
+	p->block_error.stat[0].uvalue = ucblocks;
+}
+
+static int cxd2841er_dvbt2_set_profile(
+	struct cxd2841er_priv *priv, enum cxd2841er_dvbt2_profile_t profile)
+{
+	u8 tune_mode;
+	u8 seq_not2d_time;
+
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	switch (profile) {
+	case DVBT2_PROFILE_BASE:
+		tune_mode = 0x01;
+		/* Set early unlock time */
+		seq_not2d_time = (priv->xtal == SONY_XTAL_24000)?0x0E:0x0C;
+		break;
+	case DVBT2_PROFILE_LITE:
+		tune_mode = 0x05;
+		/* Set early unlock time */
+		seq_not2d_time = (priv->xtal == SONY_XTAL_24000)?0x2E:0x28;
+		break;
+	case DVBT2_PROFILE_ANY:
+		tune_mode = 0x00;
+		/* Set early unlock time */
+		seq_not2d_time = (priv->xtal == SONY_XTAL_24000)?0x2E:0x28;
+		break;
+	default:
+		return -EINVAL;
+	}
+	/* Set SLV-T Bank : 0x2E */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x2e);
+	/* Set profile and tune mode */
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0x10, tune_mode, 0x07);
+	/* Set SLV-T Bank : 0x2B */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x2b);
+	/* Set early unlock detection time */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x9d, seq_not2d_time);
+	return 0;
+}
+
+static int cxd2841er_dvbt2_set_plp_config(struct cxd2841er_priv *priv,
+					  u8 is_auto, u8 plp_id)
+{
+	if (is_auto) {
+		dev_dbg(&priv->i2c->dev,
+			"%s() using auto PLP selection\n", __func__);
+	} else {
+		dev_dbg(&priv->i2c->dev,
+			"%s() using manual PLP selection, ID %d\n",
+			__func__, plp_id);
+	}
+	/* Set SLV-T Bank : 0x23 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x23);
+	if (!is_auto) {
+		/* Manual PLP selection mode. Set the data PLP Id. */
+		cxd2841er_write_reg(priv, I2C_SLVT, 0xaf, plp_id);
+	}
+	/* Auto PLP select (Scanning mode = 0x00). Data PLP select = 0x01. */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0xad, (is_auto ? 0x00 : 0x01));
+	return 0;
+}
+
+static int cxd2841er_sleep_tc_to_active_t2_band(struct cxd2841er_priv *priv,
+						u32 bandwidth)
+{
+	u32 iffreq;
+	u8 data[MAX_WRITE_REGSIZE];
+
+	const uint8_t nominalRate8bw[3][5] = {
+		/* TRCG Nominal Rate [37:0] */
+		{0x11, 0xF0, 0x00, 0x00, 0x00}, /* 20.5MHz XTal */
+		{0x15, 0x00, 0x00, 0x00, 0x00}, /* 24MHz XTal */
+		{0x11, 0xF0, 0x00, 0x00, 0x00}  /* 41MHz XTal */
+	};
+
+	const uint8_t nominalRate7bw[3][5] = {
+		/* TRCG Nominal Rate [37:0] */
+		{0x14, 0x80, 0x00, 0x00, 0x00}, /* 20.5MHz XTal */
+		{0x18, 0x00, 0x00, 0x00, 0x00}, /* 24MHz XTal */
+		{0x14, 0x80, 0x00, 0x00, 0x00}  /* 41MHz XTal */
+	};
+
+	const uint8_t nominalRate6bw[3][5] = {
+		/* TRCG Nominal Rate [37:0] */
+		{0x17, 0xEA, 0xAA, 0xAA, 0xAA}, /* 20.5MHz XTal */
+		{0x1C, 0x00, 0x00, 0x00, 0x00}, /* 24MHz XTal */
+		{0x17, 0xEA, 0xAA, 0xAA, 0xAA}  /* 41MHz XTal */
+	};
+
+	const uint8_t nominalRate5bw[3][5] = {
+		/* TRCG Nominal Rate [37:0] */
+		{0x1C, 0xB3, 0x33, 0x33, 0x33}, /* 20.5MHz XTal */
+		{0x21, 0x99, 0x99, 0x99, 0x99}, /* 24MHz XTal */
+		{0x1C, 0xB3, 0x33, 0x33, 0x33}  /* 41MHz XTal */
+	};
+
+	const uint8_t nominalRate17bw[3][5] = {
+		/* TRCG Nominal Rate [37:0] */
+		{0x58, 0xE2, 0xAF, 0xE0, 0xBC}, /* 20.5MHz XTal */
+		{0x68, 0x0F, 0xA2, 0x32, 0xD0}, /* 24MHz XTal */
+		{0x58, 0xE2, 0xAF, 0xE0, 0xBC}  /* 41MHz XTal */
+	};
+
+	const uint8_t itbCoef8bw[3][14] = {
+		{0x26, 0xAF, 0x06, 0xCD, 0x13, 0xBB, 0x28, 0xBA,
+			0x23, 0xA9, 0x1F, 0xA8, 0x2C, 0xC8}, /* 20.5MHz XTal */
+		{0x2F, 0xBA, 0x28, 0x9B, 0x28, 0x9D, 0x28, 0xA1,
+			0x29, 0xA5, 0x2A, 0xAC, 0x29, 0xB5}, /* 24MHz XTal   */
+		{0x26, 0xAF, 0x06, 0xCD, 0x13, 0xBB, 0x28, 0xBA,
+			0x23, 0xA9, 0x1F, 0xA8, 0x2C, 0xC8}  /* 41MHz XTal   */
+	};
+
+	const uint8_t itbCoef7bw[3][14] = {
+		{0x2C, 0xBD, 0x02, 0xCF, 0x04, 0xF8, 0x23, 0xA6,
+			0x29, 0xB0, 0x26, 0xA9, 0x21, 0xA5}, /* 20.5MHz XTal */
+		{0x30, 0xB1, 0x29, 0x9A, 0x28, 0x9C, 0x28, 0xA0,
+			0x29, 0xA2, 0x2B, 0xA6, 0x2B, 0xAD}, /* 24MHz XTal   */
+		{0x2C, 0xBD, 0x02, 0xCF, 0x04, 0xF8, 0x23, 0xA6,
+			0x29, 0xB0, 0x26, 0xA9, 0x21, 0xA5}  /* 41MHz XTal   */
+	};
+
+	const uint8_t itbCoef6bw[3][14] = {
+		{0x27, 0xA7, 0x28, 0xB3, 0x02, 0xF0, 0x01, 0xE8,
+			0x00, 0xCF, 0x00, 0xE6, 0x23, 0xA4}, /* 20.5MHz XTal */
+		{0x31, 0xA8, 0x29, 0x9B, 0x27, 0x9C, 0x28, 0x9E,
+			0x29, 0xA4, 0x29, 0xA2, 0x29, 0xA8}, /* 24MHz XTal   */
+		{0x27, 0xA7, 0x28, 0xB3, 0x02, 0xF0, 0x01, 0xE8,
+			0x00, 0xCF, 0x00, 0xE6, 0x23, 0xA4}  /* 41MHz XTal   */
+	};
+
+	const uint8_t itbCoef5bw[3][14] = {
+		{0x27, 0xA7, 0x28, 0xB3, 0x02, 0xF0, 0x01, 0xE8,
+			0x00, 0xCF, 0x00, 0xE6, 0x23, 0xA4}, /* 20.5MHz XTal */
+		{0x31, 0xA8, 0x29, 0x9B, 0x27, 0x9C, 0x28, 0x9E,
+			0x29, 0xA4, 0x29, 0xA2, 0x29, 0xA8}, /* 24MHz XTal   */
+		{0x27, 0xA7, 0x28, 0xB3, 0x02, 0xF0, 0x01, 0xE8,
+			0x00, 0xCF, 0x00, 0xE6, 0x23, 0xA4}  /* 41MHz XTal   */
+	};
+
+	const uint8_t itbCoef17bw[3][14] = {
+		{0x25, 0xA0, 0x36, 0x8D, 0x2E, 0x94, 0x28, 0x9B,
+			0x32, 0x90, 0x2C, 0x9D, 0x29, 0x99}, /* 20.5MHz XTal */
+		{0x33, 0x8E, 0x2B, 0x97, 0x2D, 0x95, 0x37, 0x8B,
+			0x30, 0x97, 0x2D, 0x9A, 0x21, 0xA4}, /* 24MHz XTal   */
+		{0x25, 0xA0, 0x36, 0x8D, 0x2E, 0x94, 0x28, 0x9B,
+			0x32, 0x90, 0x2C, 0x9D, 0x29, 0x99}  /* 41MHz XTal   */
+	};
+
+	/* Set SLV-T Bank : 0x20 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x20);
+
+	switch (bandwidth) {
+	case 8000000:
+		/* <Timing Recovery setting> */
+		cxd2841er_write_regs(priv, I2C_SLVT,
+				0x9F, nominalRate8bw[priv->xtal], 5);
+
+		/* Set SLV-T Bank : 0x27 */
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x27);
+		cxd2841er_set_reg_bits(priv, I2C_SLVT,
+				0x7a, 0x00, 0x0f);
+
+		/* Set SLV-T Bank : 0x10 */
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);
+
+		/* Group delay equaliser settings for
+		 * ASCOT2D, ASCOT2E and ASCOT3 tuners
+		 */
+		cxd2841er_write_regs(priv, I2C_SLVT,
+				0xA6, itbCoef8bw[priv->xtal], 14);
+		/* <IF freq setting> */
+		iffreq = MAKE_IFFREQ_CONFIG_XTAL(priv->xtal, 4.80);
+		data[0] = (u8) ((iffreq >> 16) & 0xff);
+		data[1] = (u8)((iffreq >> 8) & 0xff);
+		data[2] = (u8)(iffreq & 0xff);
+		cxd2841er_write_regs(priv, I2C_SLVT, 0xB6, data, 3);
+		/* System bandwidth setting */
+		cxd2841er_set_reg_bits(
+				priv, I2C_SLVT, 0xD7, 0x00, 0x07);
+		break;
+	case 7000000:
+		/* <Timing Recovery setting> */
+		cxd2841er_write_regs(priv, I2C_SLVT,
+				0x9F, nominalRate7bw[priv->xtal], 5);
+
+		/* Set SLV-T Bank : 0x27 */
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x27);
+		cxd2841er_set_reg_bits(priv, I2C_SLVT,
+				0x7a, 0x00, 0x0f);
+
+		/* Set SLV-T Bank : 0x10 */
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);
+
+		/* Group delay equaliser settings for
+		 * ASCOT2D, ASCOT2E and ASCOT3 tuners
+		 */
+		cxd2841er_write_regs(priv, I2C_SLVT,
+				0xA6, itbCoef7bw[priv->xtal], 14);
+		/* <IF freq setting> */
+		iffreq = MAKE_IFFREQ_CONFIG_XTAL(priv->xtal, 4.20);
+		data[0] = (u8) ((iffreq >> 16) & 0xff);
+		data[1] = (u8)((iffreq >> 8) & 0xff);
+		data[2] = (u8)(iffreq & 0xff);
+		cxd2841er_write_regs(priv, I2C_SLVT, 0xB6, data, 3);
+		/* System bandwidth setting */
+		cxd2841er_set_reg_bits(
+				priv, I2C_SLVT, 0xD7, 0x02, 0x07);
+		break;
+	case 6000000:
+		/* <Timing Recovery setting> */
+		cxd2841er_write_regs(priv, I2C_SLVT,
+				0x9F, nominalRate6bw[priv->xtal], 5);
+
+		/* Set SLV-T Bank : 0x27 */
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x27);
+		cxd2841er_set_reg_bits(priv, I2C_SLVT,
+				0x7a, 0x00, 0x0f);
+
+		/* Set SLV-T Bank : 0x10 */
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);
+
+		/* Group delay equaliser settings for
+		 * ASCOT2D, ASCOT2E and ASCOT3 tuners
+		 */
+		cxd2841er_write_regs(priv, I2C_SLVT,
+				0xA6, itbCoef6bw[priv->xtal], 14);
+		/* <IF freq setting> */
+		iffreq = MAKE_IFFREQ_CONFIG_XTAL(priv->xtal, 3.60);
+		data[0] = (u8) ((iffreq >> 16) & 0xff);
+		data[1] = (u8)((iffreq >> 8) & 0xff);
+		data[2] = (u8)(iffreq & 0xff);
+		cxd2841er_write_regs(priv, I2C_SLVT, 0xB6, data, 3);
+		/* System bandwidth setting */
+		cxd2841er_set_reg_bits(
+				priv, I2C_SLVT, 0xD7, 0x04, 0x07);
+		break;
+	case 5000000:
+		/* <Timing Recovery setting> */
+		cxd2841er_write_regs(priv, I2C_SLVT,
+				0x9F, nominalRate5bw[priv->xtal], 5);
+
+		/* Set SLV-T Bank : 0x27 */
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x27);
+		cxd2841er_set_reg_bits(priv, I2C_SLVT,
+				0x7a, 0x00, 0x0f);
+
+		/* Set SLV-T Bank : 0x10 */
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);
+
+		/* Group delay equaliser settings for
+		 * ASCOT2D, ASCOT2E and ASCOT3 tuners
+		 */
+		cxd2841er_write_regs(priv, I2C_SLVT,
+				0xA6, itbCoef5bw[priv->xtal], 14);
+		/* <IF freq setting> */
+		iffreq = MAKE_IFFREQ_CONFIG_XTAL(priv->xtal, 3.60);
+		data[0] = (u8) ((iffreq >> 16) & 0xff);
+		data[1] = (u8)((iffreq >> 8) & 0xff);
+		data[2] = (u8)(iffreq & 0xff);
+		cxd2841er_write_regs(priv, I2C_SLVT, 0xB6, data, 3);
+		/* System bandwidth setting */
+		cxd2841er_set_reg_bits(
+				priv, I2C_SLVT, 0xD7, 0x06, 0x07);
+		break;
+	case 1712000:
+		/* <Timing Recovery setting> */
+		cxd2841er_write_regs(priv, I2C_SLVT,
+				0x9F, nominalRate17bw[priv->xtal], 5);
+
+		/* Set SLV-T Bank : 0x27 */
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x27);
+		cxd2841er_set_reg_bits(priv, I2C_SLVT,
+				0x7a, 0x03, 0x0f);
+
+		/* Set SLV-T Bank : 0x10 */
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);
+
+		/* Group delay equaliser settings for
+		 * ASCOT2D, ASCOT2E and ASCOT3 tuners
+		 */
+		cxd2841er_write_regs(priv, I2C_SLVT,
+				0xA6, itbCoef17bw[priv->xtal], 14);
+		/* <IF freq setting> */
+		iffreq = MAKE_IFFREQ_CONFIG_XTAL(priv->xtal, 3.50);
+		data[0] = (u8) ((iffreq >> 16) & 0xff);
+		data[1] = (u8)((iffreq >> 8) & 0xff);
+		data[2] = (u8)(iffreq & 0xff);
+		cxd2841er_write_regs(priv, I2C_SLVT, 0xB6, data, 3);
+		/* System bandwidth setting */
+		cxd2841er_set_reg_bits(
+				priv, I2C_SLVT, 0xD7, 0x03, 0x07);
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int cxd2841er_sleep_tc_to_active_t_band(
+		struct cxd2841er_priv *priv, u32 bandwidth)
+{
+	u8 data[MAX_WRITE_REGSIZE];
+	u32 iffreq;
+	u8 nominalRate8bw[3][5] = {
+		/* TRCG Nominal Rate [37:0] */
+		{0x11, 0xF0, 0x00, 0x00, 0x00}, /* 20.5MHz XTal */
+		{0x15, 0x00, 0x00, 0x00, 0x00}, /* 24MHz XTal */
+		{0x11, 0xF0, 0x00, 0x00, 0x00}  /* 41MHz XTal */
+	};
+	u8 nominalRate7bw[3][5] = {
+		/* TRCG Nominal Rate [37:0] */
+		{0x14, 0x80, 0x00, 0x00, 0x00}, /* 20.5MHz XTal */
+		{0x18, 0x00, 0x00, 0x00, 0x00}, /* 24MHz XTal */
+		{0x14, 0x80, 0x00, 0x00, 0x00}  /* 41MHz XTal */
+	};
+	u8 nominalRate6bw[3][5] = {
+		/* TRCG Nominal Rate [37:0] */
+		{0x17, 0xEA, 0xAA, 0xAA, 0xAA}, /* 20.5MHz XTal */
+		{0x1C, 0x00, 0x00, 0x00, 0x00}, /* 24MHz XTal */
+		{0x17, 0xEA, 0xAA, 0xAA, 0xAA}  /* 41MHz XTal */
+	};
+	u8 nominalRate5bw[3][5] = {
+		/* TRCG Nominal Rate [37:0] */
+		{0x1C, 0xB3, 0x33, 0x33, 0x33}, /* 20.5MHz XTal */
+		{0x21, 0x99, 0x99, 0x99, 0x99}, /* 24MHz XTal */
+		{0x1C, 0xB3, 0x33, 0x33, 0x33}  /* 41MHz XTal */
+	};
+
+	u8 itbCoef8bw[3][14] = {
+		{0x26, 0xAF, 0x06, 0xCD, 0x13, 0xBB, 0x28, 0xBA, 0x23, 0xA9,
+			0x1F, 0xA8, 0x2C, 0xC8}, /* 20.5MHz XTal */
+		{0x2F, 0xBA, 0x28, 0x9B, 0x28, 0x9D, 0x28, 0xA1, 0x29, 0xA5,
+			0x2A, 0xAC, 0x29, 0xB5}, /* 24MHz XTal   */
+		{0x26, 0xAF, 0x06, 0xCD, 0x13, 0xBB, 0x28, 0xBA, 0x23, 0xA9,
+			0x1F, 0xA8, 0x2C, 0xC8}  /* 41MHz XTal   */
+	};
+	u8 itbCoef7bw[3][14] = {
+		{0x2C, 0xBD, 0x02, 0xCF, 0x04, 0xF8, 0x23, 0xA6, 0x29, 0xB0,
+			0x26, 0xA9, 0x21, 0xA5}, /* 20.5MHz XTal */
+		{0x30, 0xB1, 0x29, 0x9A, 0x28, 0x9C, 0x28, 0xA0, 0x29, 0xA2,
+			0x2B, 0xA6, 0x2B, 0xAD}, /* 24MHz XTal   */
+		{0x2C, 0xBD, 0x02, 0xCF, 0x04, 0xF8, 0x23, 0xA6, 0x29, 0xB0,
+			0x26, 0xA9, 0x21, 0xA5}  /* 41MHz XTal   */
+	};
+	u8 itbCoef6bw[3][14] = {
+		{0x27, 0xA7, 0x28, 0xB3, 0x02, 0xF0, 0x01, 0xE8, 0x00, 0xCF,
+			0x00, 0xE6, 0x23, 0xA4}, /* 20.5MHz XTal */
+		{0x31, 0xA8, 0x29, 0x9B, 0x27, 0x9C, 0x28, 0x9E, 0x29, 0xA4,
+			0x29, 0xA2, 0x29, 0xA8}, /* 24MHz XTal   */
+		{0x27, 0xA7, 0x28, 0xB3, 0x02, 0xF0, 0x01, 0xE8, 0x00, 0xCF,
+			0x00, 0xE6, 0x23, 0xA4}  /* 41MHz XTal   */
+	};
+	u8 itbCoef5bw[3][14] = {
+		{0x27, 0xA7, 0x28, 0xB3, 0x02, 0xF0, 0x01, 0xE8, 0x00, 0xCF,
+			0x00, 0xE6, 0x23, 0xA4}, /* 20.5MHz XTal */
+		{0x31, 0xA8, 0x29, 0x9B, 0x27, 0x9C, 0x28, 0x9E, 0x29, 0xA4,
+			0x29, 0xA2, 0x29, 0xA8}, /* 24MHz XTal   */
+		{0x27, 0xA7, 0x28, 0xB3, 0x02, 0xF0, 0x01, 0xE8, 0x00, 0xCF,
+			0x00, 0xE6, 0x23, 0xA4}  /* 41MHz XTal   */
+	};
+
+	/* Set SLV-T Bank : 0x13 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x13);
+	/* Echo performance optimization setting */
+	data[0] = 0x01;
+	data[1] = 0x14;
+	cxd2841er_write_regs(priv, I2C_SLVT, 0x9C, data, 2);
+
+	/* Set SLV-T Bank : 0x10 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);
+
+	switch (bandwidth) {
+	case 8000000:
+		/* <Timing Recovery setting> */
+		cxd2841er_write_regs(priv, I2C_SLVT,
+				0x9F, nominalRate8bw[priv->xtal], 5);
+		/* Group delay equaliser settings for
+		 * ASCOT2D, ASCOT2E and ASCOT3 tuners
+		*/
+		cxd2841er_write_regs(priv, I2C_SLVT,
+				0xA6, itbCoef8bw[priv->xtal], 14);
+		/* <IF freq setting> */
+		iffreq = MAKE_IFFREQ_CONFIG_XTAL(priv->xtal, 4.80);
+		data[0] = (u8) ((iffreq >> 16) & 0xff);
+		data[1] = (u8)((iffreq >> 8) & 0xff);
+		data[2] = (u8)(iffreq & 0xff);
+		cxd2841er_write_regs(priv, I2C_SLVT, 0xB6, data, 3);
+		/* System bandwidth setting */
+		cxd2841er_set_reg_bits(
+			priv, I2C_SLVT, 0xD7, 0x00, 0x07);
+
+		/* Demod core latency setting */
+		if (priv->xtal == SONY_XTAL_24000) {
+			data[0] = 0x15;
+			data[1] = 0x28;
+		} else {
+			data[0] = 0x01;
+			data[1] = 0xE0;
+		}
+		cxd2841er_write_regs(priv, I2C_SLVT, 0xD9, data, 2);
+
+		/* Notch filter setting */
+		data[0] = 0x01;
+		data[1] = 0x02;
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x17);
+		cxd2841er_write_regs(priv, I2C_SLVT, 0x38, data, 2);
+		break;
+	case 7000000:
+		/* <Timing Recovery setting> */
+		cxd2841er_write_regs(priv, I2C_SLVT,
+				0x9F, nominalRate7bw[priv->xtal], 5);
+		/* Group delay equaliser settings for
+		 * ASCOT2D, ASCOT2E and ASCOT3 tuners
+		*/
+		cxd2841er_write_regs(priv, I2C_SLVT,
+				0xA6, itbCoef7bw[priv->xtal], 14);
+		/* <IF freq setting> */
+		iffreq = MAKE_IFFREQ_CONFIG_XTAL(priv->xtal, 4.20);
+		data[0] = (u8) ((iffreq >> 16) & 0xff);
+		data[1] = (u8)((iffreq >> 8) & 0xff);
+		data[2] = (u8)(iffreq & 0xff);
+		cxd2841er_write_regs(priv, I2C_SLVT, 0xB6, data, 3);
+		/* System bandwidth setting */
+		cxd2841er_set_reg_bits(
+			priv, I2C_SLVT, 0xD7, 0x02, 0x07);
+
+		/* Demod core latency setting */
+		if (priv->xtal == SONY_XTAL_24000) {
+			data[0] = 0x1F;
+			data[1] = 0xF8;
+		} else {
+			data[0] = 0x12;
+			data[1] = 0xF8;
+		}
+		cxd2841er_write_regs(priv, I2C_SLVT, 0xD9, data, 2);
+
+		/* Notch filter setting */
+		data[0] = 0x00;
+		data[1] = 0x03;
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x17);
+		cxd2841er_write_regs(priv, I2C_SLVT, 0x38, data, 2);
+		break;
+	case 6000000:
+		/* <Timing Recovery setting> */
+		cxd2841er_write_regs(priv, I2C_SLVT,
+				0x9F, nominalRate6bw[priv->xtal], 5);
+		/* Group delay equaliser settings for
+		 * ASCOT2D, ASCOT2E and ASCOT3 tuners
+		*/
+		cxd2841er_write_regs(priv, I2C_SLVT,
+				0xA6, itbCoef6bw[priv->xtal], 14);
+		/* <IF freq setting> */
+		iffreq = MAKE_IFFREQ_CONFIG_XTAL(priv->xtal, 3.60);
+		data[0] = (u8) ((iffreq >> 16) & 0xff);
+		data[1] = (u8)((iffreq >> 8) & 0xff);
+		data[2] = (u8)(iffreq & 0xff);
+		cxd2841er_write_regs(priv, I2C_SLVT, 0xB6, data, 3);
+		/* System bandwidth setting */
+		cxd2841er_set_reg_bits(
+			priv, I2C_SLVT, 0xD7, 0x04, 0x07);
+
+		/* Demod core latency setting */
+		if (priv->xtal == SONY_XTAL_24000) {
+			data[0] = 0x25;
+			data[1] = 0x4C;
+		} else {
+			data[0] = 0x1F;
+			data[1] = 0xDC;
+		}
+		cxd2841er_write_regs(priv, I2C_SLVT, 0xD9, data, 2);
+
+		/* Notch filter setting */
+		data[0] = 0x00;
+		data[1] = 0x03;
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x17);
+		cxd2841er_write_regs(priv, I2C_SLVT, 0x38, data, 2);
+		break;
+	case 5000000:
+		/* <Timing Recovery setting> */
+		cxd2841er_write_regs(priv, I2C_SLVT,
+				0x9F, nominalRate5bw[priv->xtal], 5);
+		/* Group delay equaliser settings for
+		 * ASCOT2D, ASCOT2E and ASCOT3 tuners
+		*/
+		cxd2841er_write_regs(priv, I2C_SLVT,
+				0xA6, itbCoef5bw[priv->xtal], 14);
+		/* <IF freq setting> */
+		iffreq = MAKE_IFFREQ_CONFIG_XTAL(priv->xtal, 3.60);
+		data[0] = (u8) ((iffreq >> 16) & 0xff);
+		data[1] = (u8)((iffreq >> 8) & 0xff);
+		data[2] = (u8)(iffreq & 0xff);
+		cxd2841er_write_regs(priv, I2C_SLVT, 0xB6, data, 3);
+		/* System bandwidth setting */
+		cxd2841er_set_reg_bits(
+			priv, I2C_SLVT, 0xD7, 0x06, 0x07);
+
+		/* Demod core latency setting */
+		if (priv->xtal == SONY_XTAL_24000) {
+			data[0] = 0x2C;
+			data[1] = 0xC2;
+		} else {
+			data[0] = 0x26;
+			data[1] = 0x3C;
+		}
+		cxd2841er_write_regs(priv, I2C_SLVT, 0xD9, data, 2);
+
+		/* Notch filter setting */
+		data[0] = 0x00;
+		data[1] = 0x03;
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x17);
+		cxd2841er_write_regs(priv, I2C_SLVT, 0x38, data, 2);
+		break;
+	}
+
+	return 0;
+}
+
+static int cxd2841er_sleep_tc_to_active_i_band(
+		struct cxd2841er_priv *priv, u32 bandwidth)
+{
+	u32 iffreq;
+	u8 data[3];
+
+	/* TRCG Nominal Rate */
+	u8 nominalRate8bw[3][5] = {
+		{0x00, 0x00, 0x00, 0x00, 0x00}, /* 20.5MHz XTal */
+		{0x11, 0xB8, 0x00, 0x00, 0x00}, /* 24MHz XTal */
+		{0x00, 0x00, 0x00, 0x00, 0x00}  /* 41MHz XTal */
+	};
+
+	u8 nominalRate7bw[3][5] = {
+		{0x00, 0x00, 0x00, 0x00, 0x00}, /* 20.5MHz XTal */
+		{0x14, 0x40, 0x00, 0x00, 0x00}, /* 24MHz XTal */
+		{0x00, 0x00, 0x00, 0x00, 0x00}  /* 41MHz XTal */
+	};
+
+	u8 nominalRate6bw[3][5] = {
+		{0x14, 0x2E, 0x00, 0x00, 0x00}, /* 20.5MHz XTal */
+		{0x17, 0xA0, 0x00, 0x00, 0x00}, /* 24MHz XTal */
+		{0x14, 0x2E, 0x00, 0x00, 0x00}  /* 41MHz XTal */
+	};
+
+	u8 itbCoef8bw[3][14] = {
+		{0x00}, /* 20.5MHz XTal */
+		{0x2F, 0xBA, 0x28, 0x9B, 0x28, 0x9D, 0x28, 0xA1, 0x29,
+			0xA5, 0x2A, 0xAC, 0x29, 0xB5}, /* 24MHz Xtal */
+		{0x0}, /* 41MHz XTal   */
+	};
+
+	u8 itbCoef7bw[3][14] = {
+		{0x00}, /* 20.5MHz XTal */
+		{0x30, 0xB1, 0x29, 0x9A, 0x28, 0x9C, 0x28, 0xA0, 0x29,
+			0xA2, 0x2B, 0xA6, 0x2B, 0xAD}, /* 24MHz Xtal */
+		{0x00}, /* 41MHz XTal   */
+	};
+
+	u8 itbCoef6bw[3][14] = {
+		{0x27, 0xA7, 0x28, 0xB3, 0x02, 0xF0, 0x01, 0xE8, 0x00,
+			0xCF, 0x00, 0xE6, 0x23, 0xA4}, /* 20.5MHz XTal */
+		{0x31, 0xA8, 0x29, 0x9B, 0x27, 0x9C, 0x28, 0x9E, 0x29,
+			0xA4, 0x29, 0xA2, 0x29, 0xA8}, /* 24MHz Xtal   */
+		{0x27, 0xA7, 0x28, 0xB3, 0x02, 0xF0, 0x01, 0xE8, 0x00,
+			0xCF, 0x00, 0xE6, 0x23, 0xA4}, /* 41MHz XTal   */
+	};
+
+	dev_dbg(&priv->i2c->dev, "%s() bandwidth=%u\n", __func__, bandwidth);
+	/* Set SLV-T Bank : 0x10 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);
+
+	/*  20.5/41MHz Xtal support is not available
+	 *  on ISDB-T 7MHzBW and 8MHzBW
+	*/
+	if (priv->xtal != SONY_XTAL_24000 && bandwidth > 6000000) {
+		dev_err(&priv->i2c->dev,
+			"%s(): bandwidth %d supported only for 24MHz xtal\n",
+			__func__, bandwidth);
+		return -EINVAL;
+	}
+
+	switch (bandwidth) {
+	case 8000000:
+		/* TRCG Nominal Rate */
+		cxd2841er_write_regs(priv, I2C_SLVT,
+				0x9F, nominalRate8bw[priv->xtal], 5);
+		/*  Group delay equaliser settings for ASCOT tuners optimized */
+		cxd2841er_write_regs(priv, I2C_SLVT,
+				0xA6, itbCoef8bw[priv->xtal], 14);
+
+		/* IF freq setting */
+		iffreq = MAKE_IFFREQ_CONFIG_XTAL(priv->xtal, 4.75);
+		data[0] = (u8) ((iffreq >> 16) & 0xff);
+		data[1] = (u8)((iffreq >> 8) & 0xff);
+		data[2] = (u8)(iffreq & 0xff);
+		cxd2841er_write_regs(priv, I2C_SLVT, 0xB6, data, 3);
+
+		/* System bandwidth setting */
+		cxd2841er_set_reg_bits(priv, I2C_SLVT, 0xd7, 0x0, 0x7);
+
+		/* Demod core latency setting */
+		data[0] = 0x13;
+		data[1] = 0xFC;
+		cxd2841er_write_regs(priv, I2C_SLVT, 0xD9, data, 2);
+
+		/* Acquisition optimization setting */
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x12);
+		cxd2841er_set_reg_bits(priv, I2C_SLVT, 0x71, 0x03, 0x07);
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x15);
+		cxd2841er_write_reg(priv, I2C_SLVT, 0xBE, 0x03);
+		break;
+	case 7000000:
+		/* TRCG Nominal Rate */
+		cxd2841er_write_regs(priv, I2C_SLVT,
+				0x9F, nominalRate7bw[priv->xtal], 5);
+		/*  Group delay equaliser settings for ASCOT tuners optimized */
+		cxd2841er_write_regs(priv, I2C_SLVT,
+				0xA6, itbCoef7bw[priv->xtal], 14);
+
+		/* IF freq setting */
+		iffreq = MAKE_IFFREQ_CONFIG_XTAL(priv->xtal, 4.15);
+		data[0] = (u8) ((iffreq >> 16) & 0xff);
+		data[1] = (u8)((iffreq >> 8) & 0xff);
+		data[2] = (u8)(iffreq & 0xff);
+		cxd2841er_write_regs(priv, I2C_SLVT, 0xB6, data, 3);
+
+		/* System bandwidth setting */
+		cxd2841er_set_reg_bits(priv, I2C_SLVT, 0xd7, 0x02, 0x7);
+
+		/* Demod core latency setting */
+		data[0] = 0x1A;
+		data[1] = 0xFA;
+		cxd2841er_write_regs(priv, I2C_SLVT, 0xD9, data, 2);
+
+		/* Acquisition optimization setting */
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x12);
+		cxd2841er_set_reg_bits(priv, I2C_SLVT, 0x71, 0x03, 0x07);
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x15);
+		cxd2841er_write_reg(priv, I2C_SLVT, 0xBE, 0x02);
+		break;
+	case 6000000:
+		/* TRCG Nominal Rate */
+		cxd2841er_write_regs(priv, I2C_SLVT,
+				0x9F, nominalRate6bw[priv->xtal], 5);
+		/*  Group delay equaliser settings for ASCOT tuners optimized */
+		cxd2841er_write_regs(priv, I2C_SLVT,
+				0xA6, itbCoef6bw[priv->xtal], 14);
+
+		/* IF freq setting */
+		iffreq = MAKE_IFFREQ_CONFIG_XTAL(priv->xtal, 3.55);
+		data[0] = (u8) ((iffreq >> 16) & 0xff);
+		data[1] = (u8)((iffreq >> 8) & 0xff);
+		data[2] = (u8)(iffreq & 0xff);
+		cxd2841er_write_regs(priv, I2C_SLVT, 0xB6, data, 3);
+
+		/* System bandwidth setting */
+		cxd2841er_set_reg_bits(priv, I2C_SLVT, 0xd7, 0x04, 0x7);
+
+		/* Demod core latency setting */
+		if (priv->xtal == SONY_XTAL_24000) {
+			data[0] = 0x1F;
+			data[1] = 0x79;
+		} else {
+			data[0] = 0x1A;
+			data[1] = 0xE2;
+		}
+		cxd2841er_write_regs(priv, I2C_SLVT, 0xD9, data, 2);
+
+		/* Acquisition optimization setting */
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x12);
+		cxd2841er_set_reg_bits(priv, I2C_SLVT, 0x71, 0x07, 0x07);
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x15);
+		cxd2841er_write_reg(priv, I2C_SLVT, 0xBE, 0x02);
+		break;
+	default:
+		dev_dbg(&priv->i2c->dev, "%s(): invalid bandwidth %d\n",
+				__func__, bandwidth);
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int cxd2841er_sleep_tc_to_active_c_band(struct cxd2841er_priv *priv,
+					       u32 bandwidth)
+{
+	u8 bw7_8mhz_b10_a6[] = {
+		0x2D, 0xC7, 0x04, 0xF4, 0x07, 0xC5, 0x2A, 0xB8,
+		0x27, 0x9E, 0x27, 0xA4, 0x29, 0xAB };
+	u8 bw6mhz_b10_a6[] = {
+		0x27, 0xA7, 0x28, 0xB3, 0x02, 0xF0, 0x01, 0xE8,
+		0x00, 0xCF, 0x00, 0xE6, 0x23, 0xA4 };
+	u8 b10_b6[3];
+	u32 iffreq;
+
+	dev_dbg(&priv->i2c->dev, "%s() bw=%d\n", __func__, bandwidth);
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);
+	switch (bandwidth) {
+	case 8000000:
+	case 7000000:
+		cxd2841er_write_regs(
+			priv, I2C_SLVT, 0xa6,
+			bw7_8mhz_b10_a6, sizeof(bw7_8mhz_b10_a6));
+		iffreq = MAKE_IFFREQ_CONFIG(4.9);
+		break;
+	case 6000000:
+		cxd2841er_write_regs(
+			priv, I2C_SLVT, 0xa6,
+			bw6mhz_b10_a6, sizeof(bw6mhz_b10_a6));
+		iffreq = MAKE_IFFREQ_CONFIG(3.7);
+		break;
+	default:
+		dev_err(&priv->i2c->dev, "%s(): unsupported bandwidth %d\n",
+			__func__, bandwidth);
+		return -EINVAL;
+	}
+	/* <IF freq setting> */
+	b10_b6[0] = (u8) ((iffreq >> 16) & 0xff);
+	b10_b6[1] = (u8)((iffreq >> 8) & 0xff);
+	b10_b6[2] = (u8)(iffreq & 0xff);
+	cxd2841er_write_regs(priv, I2C_SLVT, 0xb6, b10_b6, sizeof(b10_b6));
+	/* Set SLV-T Bank : 0x11 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x11);
+	switch (bandwidth) {
+	case 8000000:
+	case 7000000:
+		cxd2841er_set_reg_bits(
+			priv, I2C_SLVT, 0xa3, 0x00, 0x1f);
+		break;
+	case 6000000:
+		cxd2841er_set_reg_bits(
+			priv, I2C_SLVT, 0xa3, 0x14, 0x1f);
+		break;
+	}
+	/* Set SLV-T Bank : 0x40 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x40);
+	switch (bandwidth) {
+	case 8000000:
+		cxd2841er_set_reg_bits(
+			priv, I2C_SLVT, 0x26, 0x0b, 0x0f);
+		cxd2841er_write_reg(priv, I2C_SLVT,  0x27, 0x3e);
+		break;
+	case 7000000:
+		cxd2841er_set_reg_bits(
+			priv, I2C_SLVT, 0x26, 0x09, 0x0f);
+		cxd2841er_write_reg(priv, I2C_SLVT,  0x27, 0xd6);
+		break;
+	case 6000000:
+		cxd2841er_set_reg_bits(
+			priv, I2C_SLVT, 0x26, 0x08, 0x0f);
+		cxd2841er_write_reg(priv, I2C_SLVT,  0x27, 0x6e);
+		break;
+	}
+	return 0;
+}
+
+static int cxd2841er_sleep_tc_to_active_t(struct cxd2841er_priv *priv,
+					  u32 bandwidth)
+{
+	u8 data[2] = { 0x09, 0x54 };
+	u8 data24m[3] = {0xDC, 0x6C, 0x00};
+
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	cxd2841er_set_ts_clock_mode(priv, SYS_DVBT);
+	/* Set SLV-X Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x00, 0x00);
+	/* Set demod mode */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x17, 0x01);
+	/* Set SLV-T Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);
+	/* Enable demod clock */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x2c, 0x01);
+	/* Disable RF level monitor */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x2f, 0x00);
+	/* Enable ADC clock */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x30, 0x00);
+	/* Enable ADC 1 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x41, 0x1a);
+	/* Enable ADC 2 & 3 */
+	if (priv->xtal == SONY_XTAL_41000) {
+		data[0] = 0x0A;
+		data[1] = 0xD4;
+	}
+	cxd2841er_write_regs(priv, I2C_SLVT, 0x43, data, 2);
+	/* Enable ADC 4 */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x18, 0x00);
+	/* Set SLV-T Bank : 0x10 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);
+	/* IFAGC gain settings */
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0xd2, 0x0c, 0x1f);
+	/* Set SLV-T Bank : 0x11 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x11);
+	/* BBAGC TARGET level setting */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x6a, 0x50);
+	/* Set SLV-T Bank : 0x10 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);
+	/* ASCOT setting ON */
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0xa5, 0x01, 0x01);
+	/* Set SLV-T Bank : 0x18 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x18);
+	/* Pre-RS BER moniter setting */
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0x36, 0x40, 0x07);
+	/* FEC Auto Recovery setting */
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0x30, 0x01, 0x01);
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0x31, 0x01, 0x01);
+	/* Set SLV-T Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);
+	/* TSIF setting */
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0xce, 0x01, 0x01);
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0xcf, 0x01, 0x01);
+
+	if (priv->xtal == SONY_XTAL_24000) {
+		/* Set SLV-T Bank : 0x10 */
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);
+		cxd2841er_write_reg(priv, I2C_SLVT, 0xBF, 0x60);
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x18);
+		cxd2841er_write_regs(priv, I2C_SLVT, 0x24, data24m, 3);
+	}
+
+	cxd2841er_sleep_tc_to_active_t_band(priv, bandwidth);
+	/* Set SLV-T Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);
+	/* Disable HiZ Setting 1 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x80, 0x28);
+	/* Disable HiZ Setting 2 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x81, 0x00);
+	priv->state = STATE_ACTIVE_TC;
+	return 0;
+}
+
+static int cxd2841er_sleep_tc_to_active_t2(struct cxd2841er_priv *priv,
+					   u32 bandwidth)
+{
+	u8 data[MAX_WRITE_REGSIZE];
+
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	cxd2841er_set_ts_clock_mode(priv, SYS_DVBT2);
+	/* Set SLV-X Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x00, 0x00);
+	/* Set demod mode */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x17, 0x02);
+	/* Set SLV-T Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);
+	/* Enable demod clock */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x2c, 0x01);
+	/* Disable RF level monitor */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x59, 0x00);
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x2f, 0x00);
+	/* Enable ADC clock */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x30, 0x00);
+	/* Enable ADC 1 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x41, 0x1a);
+
+	if (priv->xtal == SONY_XTAL_41000) {
+		data[0] = 0x0A;
+		data[1] = 0xD4;
+	} else {
+		data[0] = 0x09;
+		data[1] = 0x54;
+	}
+
+	cxd2841er_write_regs(priv, I2C_SLVT, 0x43, data, 2);
+	/* Enable ADC 4 */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x18, 0x00);
+	/* Set SLV-T Bank : 0x10 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);
+	/* IFAGC gain settings */
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0xd2, 0x0c, 0x1f);
+	/* Set SLV-T Bank : 0x11 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x11);
+	/* BBAGC TARGET level setting */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x6a, 0x50);
+	/* Set SLV-T Bank : 0x10 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);
+	/* ASCOT setting ON */
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0xa5, 0x01, 0x01);
+	/* Set SLV-T Bank : 0x20 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x20);
+	/* Acquisition optimization setting */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x8b, 0x3c);
+	/* Set SLV-T Bank : 0x2b */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x2b);
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0x76, 0x20, 0x70);
+	/* Set SLV-T Bank : 0x23 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x23);
+	/* L1 Control setting */
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0xE6, 0x00, 0x03);
+	/* Set SLV-T Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);
+	/* TSIF setting */
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0xce, 0x01, 0x01);
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0xcf, 0x01, 0x01);
+	/* DVB-T2 initial setting */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x13);
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x83, 0x10);
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x86, 0x34);
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0x9e, 0x09, 0x0f);
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x9f, 0xd8);
+	/* Set SLV-T Bank : 0x2a */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x2a);
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0x38, 0x04, 0x0f);
+	/* Set SLV-T Bank : 0x2b */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x2b);
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0x11, 0x20, 0x3f);
+
+	/* 24MHz Xtal setting */
+	if (priv->xtal == SONY_XTAL_24000) {
+		/* Set SLV-T Bank : 0x11 */
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x11);
+		data[0] = 0xEB;
+		data[1] = 0x03;
+		data[2] = 0x3B;
+		cxd2841er_write_regs(priv, I2C_SLVT, 0x33, data, 3);
+
+		/* Set SLV-T Bank : 0x20 */
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x20);
+		data[0] = 0x5E;
+		data[1] = 0x5E;
+		data[2] = 0x47;
+		cxd2841er_write_regs(priv, I2C_SLVT, 0x95, data, 3);
+
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x99, 0x18);
+
+		data[0] = 0x3F;
+		data[1] = 0xFF;
+		cxd2841er_write_regs(priv, I2C_SLVT, 0xD9, data, 2);
+
+		/* Set SLV-T Bank : 0x24 */
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x24);
+		data[0] = 0x0B;
+		data[1] = 0x72;
+		cxd2841er_write_regs(priv, I2C_SLVT, 0x34, data, 2);
+
+		data[0] = 0x93;
+		data[1] = 0xF3;
+		data[2] = 0x00;
+		cxd2841er_write_regs(priv, I2C_SLVT, 0xD2, data, 3);
+
+		data[0] = 0x05;
+		data[1] = 0xB8;
+		data[2] = 0xD8;
+		cxd2841er_write_regs(priv, I2C_SLVT, 0xDD, data, 3);
+
+		cxd2841er_write_reg(priv, I2C_SLVT, 0xE0, 0x00);
+
+		/* Set SLV-T Bank : 0x25 */
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x25);
+		cxd2841er_write_reg(priv, I2C_SLVT, 0xED, 0x60);
+
+		/* Set SLV-T Bank : 0x27 */
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x27);
+		cxd2841er_write_reg(priv, I2C_SLVT, 0xFA, 0x34);
+
+		/* Set SLV-T Bank : 0x2B */
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x2B);
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x4B, 0x2F);
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x9E, 0x0E);
+
+		/* Set SLV-T Bank : 0x2D */
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x2D);
+		data[0] = 0x89;
+		data[1] = 0x89;
+		cxd2841er_write_regs(priv, I2C_SLVT, 0x24, data, 2);
+
+		/* Set SLV-T Bank : 0x5E */
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x5E);
+		data[0] = 0x24;
+		data[1] = 0x95;
+		cxd2841er_write_regs(priv, I2C_SLVT, 0x8C, data, 2);
+	}
+
+	cxd2841er_sleep_tc_to_active_t2_band(priv, bandwidth);
+
+	/* Set SLV-T Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);
+	/* Disable HiZ Setting 1 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x80, 0x28);
+	/* Disable HiZ Setting 2 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x81, 0x00);
+	priv->state = STATE_ACTIVE_TC;
+	return 0;
+}
+
+/* ISDB-Tb part */
+static int cxd2841er_sleep_tc_to_active_i(struct cxd2841er_priv *priv,
+		u32 bandwidth)
+{
+	u8 data[2] = { 0x09, 0x54 };
+	u8 data24m[2] = {0x60, 0x00};
+	u8 data24m2[3] = {0xB7, 0x1B, 0x00};
+
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	cxd2841er_set_ts_clock_mode(priv, SYS_DVBT);
+	/* Set SLV-X Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x00, 0x00);
+	/* Set demod mode */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x17, 0x06);
+	/* Set SLV-T Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);
+	/* Enable demod clock */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x2c, 0x01);
+	/* Enable RF level monitor */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x2f, 0x01);
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x59, 0x01);
+	/* Enable ADC clock */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x30, 0x00);
+	/* Enable ADC 1 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x41, 0x1a);
+	/* xtal freq 20.5MHz or 24M */
+	cxd2841er_write_regs(priv, I2C_SLVT, 0x43, data, 2);
+	/* Enable ADC 4 */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x18, 0x00);
+	/* ASCOT setting ON */
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0xa5, 0x01, 0x01);
+	/* FEC Auto Recovery setting */
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0x30, 0x01, 0x01);
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0x31, 0x00, 0x01);
+	/* ISDB-T initial setting */
+	/* Set SLV-T Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0xce, 0x00, 0x01);
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0xcf, 0x00, 0x01);
+	/* Set SLV-T Bank : 0x10 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0x69, 0x04, 0x07);
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0x6B, 0x03, 0x07);
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0x9D, 0x50, 0xFF);
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0xD3, 0x06, 0x1F);
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0xED, 0x00, 0x01);
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0xE2, 0xCE, 0x80);
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0xF2, 0x13, 0x10);
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0xDE, 0x2E, 0x3F);
+	/* Set SLV-T Bank : 0x15 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x15);
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0xDE, 0x02, 0x03);
+	/* Set SLV-T Bank : 0x1E */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x1E);
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0x73, 0x68, 0xFF);
+	/* Set SLV-T Bank : 0x63 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x63);
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0x81, 0x00, 0x01);
+
+	/* for xtal 24MHz */
+	/* Set SLV-T Bank : 0x10 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);
+	cxd2841er_write_regs(priv, I2C_SLVT, 0xBF, data24m, 2);
+	/* Set SLV-T Bank : 0x60 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x60);
+	cxd2841er_write_regs(priv, I2C_SLVT, 0xA8, data24m2, 3);
+
+	cxd2841er_sleep_tc_to_active_i_band(priv, bandwidth);
+	/* Set SLV-T Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);
+	/* Disable HiZ Setting 1 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x80, 0x28);
+	/* Disable HiZ Setting 2 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x81, 0x00);
+	priv->state = STATE_ACTIVE_TC;
+	return 0;
+}
+
+static int cxd2841er_sleep_tc_to_active_c(struct cxd2841er_priv *priv,
+					  u32 bandwidth)
+{
+	u8 data[2] = { 0x09, 0x54 };
+
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	cxd2841er_set_ts_clock_mode(priv, SYS_DVBC_ANNEX_A);
+	/* Set SLV-X Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x00, 0x00);
+	/* Set demod mode */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x17, 0x04);
+	/* Set SLV-T Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);
+	/* Enable demod clock */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x2c, 0x01);
+	/* Disable RF level monitor */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x2f, 0x00);
+	/* Enable ADC clock */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x30, 0x00);
+	/* Enable ADC 1 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x41, 0x1a);
+	/* xtal freq 20.5MHz */
+	cxd2841er_write_regs(priv, I2C_SLVT, 0x43, data, 2);
+	/* Enable ADC 4 */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x18, 0x00);
+	/* Set SLV-T Bank : 0x10 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);
+	/* IFAGC gain settings */
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0xd2, 0x09, 0x1f);
+	/* Set SLV-T Bank : 0x11 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x11);
+	/* BBAGC TARGET level setting */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x6a, 0x48);
+	/* Set SLV-T Bank : 0x10 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);
+	/* ASCOT setting ON */
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0xa5, 0x01, 0x01);
+	/* Set SLV-T Bank : 0x40 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x40);
+	/* Demod setting */
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0xc3, 0x00, 0x04);
+	/* Set SLV-T Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);
+	/* TSIF setting */
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0xce, 0x01, 0x01);
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0xcf, 0x01, 0x01);
+
+	cxd2841er_sleep_tc_to_active_c_band(priv, bandwidth);
+	/* Set SLV-T Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);
+	/* Disable HiZ Setting 1 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x80, 0x28);
+	/* Disable HiZ Setting 2 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x81, 0x00);
+	priv->state = STATE_ACTIVE_TC;
+	return 0;
+}
+
+static int cxd2841er_get_frontend(struct dvb_frontend *fe,
+				  struct dtv_frontend_properties *p)
+{
+	enum fe_status status = 0;
+	struct cxd2841er_priv *priv = fe->demodulator_priv;
+
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	if (priv->state == STATE_ACTIVE_S)
+		cxd2841er_read_status_s(fe, &status);
+	else if (priv->state == STATE_ACTIVE_TC)
+		cxd2841er_read_status_tc(fe, &status);
+
+	cxd2841er_read_signal_strength(fe);
+
+	if (status & FE_HAS_LOCK) {
+		cxd2841er_read_snr(fe);
+		cxd2841er_read_ucblocks(fe);
+
+		cxd2841er_read_ber(fe);
+	} else {
+		p->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+		p->block_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+		p->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+		p->post_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+	}
+	return 0;
+}
+
+static int cxd2841er_set_frontend_s(struct dvb_frontend *fe)
+{
+	int ret = 0, i, timeout, carr_offset;
+	enum fe_status status;
+	struct cxd2841er_priv *priv = fe->demodulator_priv;
+	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
+	u32 symbol_rate = p->symbol_rate/1000;
+
+	dev_dbg(&priv->i2c->dev, "%s(): %s frequency=%d symbol_rate=%d xtal=%d\n",
+		__func__,
+		(p->delivery_system == SYS_DVBS ? "DVB-S" : "DVB-S2"),
+		 p->frequency, symbol_rate, priv->xtal);
+	switch (priv->state) {
+	case STATE_SLEEP_S:
+		ret = cxd2841er_sleep_s_to_active_s(
+			priv, p->delivery_system, symbol_rate);
+		break;
+	case STATE_ACTIVE_S:
+		ret = cxd2841er_retune_active(priv, p);
+		break;
+	default:
+		dev_dbg(&priv->i2c->dev, "%s(): invalid state %d\n",
+			__func__, priv->state);
+		ret = -EINVAL;
+		goto done;
+	}
+	if (ret) {
+		dev_dbg(&priv->i2c->dev, "%s(): tune failed\n", __func__);
+		goto done;
+	}
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 1);
+	if (fe->ops.tuner_ops.set_params)
+		fe->ops.tuner_ops.set_params(fe);
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 0);
+	cxd2841er_tune_done(priv);
+	timeout = ((3000000 + (symbol_rate - 1)) / symbol_rate) + 150;
+	for (i = 0; i < timeout / CXD2841ER_DVBS_POLLING_INVL; i++) {
+		usleep_range(CXD2841ER_DVBS_POLLING_INVL*1000,
+			(CXD2841ER_DVBS_POLLING_INVL + 2) * 1000);
+		cxd2841er_read_status_s(fe, &status);
+		if (status & FE_HAS_LOCK)
+			break;
+	}
+	if (status & FE_HAS_LOCK) {
+		if (cxd2841er_get_carrier_offset_s_s2(
+				priv, &carr_offset)) {
+			ret = -EINVAL;
+			goto done;
+		}
+		dev_dbg(&priv->i2c->dev, "%s(): carrier_offset=%d\n",
+			__func__, carr_offset);
+	}
+done:
+	/* Reset stats */
+	p->strength.stat[0].scale = FE_SCALE_RELATIVE;
+	p->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+	p->block_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+	p->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+	p->post_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+
+	return ret;
+}
+
+static int cxd2841er_set_frontend_tc(struct dvb_frontend *fe)
+{
+	int ret = 0, timeout;
+	enum fe_status status;
+	struct cxd2841er_priv *priv = fe->demodulator_priv;
+	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
+
+	
+	dev_dbg(&priv->i2c->dev, "%s() delivery_system=%d bandwidth_hz=%d\n",
+		 __func__, p->delivery_system, p->bandwidth_hz);
+		 
+	
+	cxd2841er_active_t_to_sleep_tc(priv);
+	cxd2841er_sleep_tc_to_shutdown(priv);
+	cxd2841er_init_tc(fe);
+	
+	if (p->delivery_system == SYS_DVBT) {
+		priv->system = SYS_DVBT;
+		switch (priv->state) {
+		case STATE_SLEEP_TC:
+			ret = cxd2841er_sleep_tc_to_active_t(
+				priv, p->bandwidth_hz);
+			break;
+		case STATE_ACTIVE_TC:
+			ret = cxd2841er_retune_active(priv, p);
+			break;
+		default:
+			dev_dbg(&priv->i2c->dev, "%s(): invalid state %d\n",
+				__func__, priv->state);
+			ret = -EINVAL;
+		}
+	} else if (p->delivery_system == SYS_DVBT2) {
+		priv->system = SYS_DVBT2;
+		cxd2841er_dvbt2_set_plp_config(priv,
+			(int)(p->stream_id > 255), p->stream_id);
+		cxd2841er_dvbt2_set_profile(priv, DVBT2_PROFILE_BASE);
+		switch (priv->state) {
+		case STATE_SLEEP_TC:
+			ret = cxd2841er_sleep_tc_to_active_t2(priv,
+				p->bandwidth_hz);
+			break;
+		case STATE_ACTIVE_TC:
+			ret = cxd2841er_retune_active(priv, p);
+			break;
+		default:
+			dev_dbg(&priv->i2c->dev, "%s(): invalid state %d\n",
+				__func__, priv->state);
+			ret = -EINVAL;
+		}
+	} else if (p->delivery_system == SYS_ISDBT) {
+		priv->system = SYS_ISDBT;
+		switch (priv->state) {
+		case STATE_SLEEP_TC:
+			ret = cxd2841er_sleep_tc_to_active_i(
+					priv, p->bandwidth_hz);
+			break;
+		case STATE_ACTIVE_TC:
+			ret = cxd2841er_retune_active(priv, p);
+			break;
+		default:
+			dev_dbg(&priv->i2c->dev, "%s(): invalid state %d\n",
+					__func__, priv->state);
+			ret = -EINVAL;
+		}
+	} else if (p->delivery_system == SYS_DVBC_ANNEX_A ||
+			p->delivery_system == SYS_DVBC_ANNEX_C) {
+		priv->system = SYS_DVBC_ANNEX_A;
+		/* correct bandwidth */
+		if (p->bandwidth_hz != 6000000 &&
+				p->bandwidth_hz != 7000000 &&
+				p->bandwidth_hz != 8000000) {
+			p->bandwidth_hz = 8000000;
+			dev_dbg(&priv->i2c->dev, "%s(): forcing bandwidth to %d\n",
+					__func__, p->bandwidth_hz);
+		}
+
+		switch (priv->state) {
+		case STATE_SLEEP_TC:
+			ret = cxd2841er_sleep_tc_to_active_c(
+				priv, p->bandwidth_hz);
+			break;
+		case STATE_ACTIVE_TC:
+			ret = cxd2841er_retune_active(priv, p);
+			break;
+		default:
+			dev_dbg(&priv->i2c->dev, "%s(): invalid state %d\n",
+				__func__, priv->state);
+			ret = -EINVAL;
+		}
+	} else {
+		dev_dbg(&priv->i2c->dev,
+			"%s(): invalid delivery system %d\n",
+			__func__, p->delivery_system);
+		ret = -EINVAL;
+	}
+	if (ret)
+		goto done;
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 1);
+	if (fe->ops.tuner_ops.set_params)
+		fe->ops.tuner_ops.set_params(fe);
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 0);
+	cxd2841er_tune_done(priv);
+	timeout = 2500;
+	while (timeout > 0) {
+		ret = cxd2841er_read_status_tc(fe, &status);
+		if (ret)
+			goto done;
+		if (status & FE_HAS_LOCK)
+			break;
+		msleep(20);
+		timeout -= 20;
+	}
+	if (timeout < 0)
+		dev_dbg(&priv->i2c->dev,
+			"%s(): LOCK wait timeout\n", __func__);
+done:
+	return ret;
+}
+
+static int cxd2841er_tune_s(struct dvb_frontend *fe,
+			    bool re_tune,
+			    unsigned int mode_flags,
+			    unsigned int *delay,
+			    enum fe_status *status)
+{
+	int ret, carrier_offset;
+	struct cxd2841er_priv *priv = fe->demodulator_priv;
+	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
+
+	dev_dbg(&priv->i2c->dev, "%s() re_tune=%d\n", __func__, re_tune);
+	if (re_tune) {
+		ret = cxd2841er_set_frontend_s(fe);
+		if (ret)
+			return ret;
+		cxd2841er_read_status_s(fe, status);
+		if (*status & FE_HAS_LOCK) {
+			if (cxd2841er_get_carrier_offset_s_s2(
+					priv, &carrier_offset))
+				return -EINVAL;
+			p->frequency += carrier_offset;
+			ret = cxd2841er_set_frontend_s(fe);
+			if (ret)
+				return ret;
+		}
+	}
+	*delay = HZ / 5;
+	return cxd2841er_read_status_s(fe, status);
+}
+
+static int cxd2841er_tune_tc(struct dvb_frontend *fe,
+			     bool re_tune,
+			     unsigned int mode_flags,
+			     unsigned int *delay,
+			     enum fe_status *status)
+{
+	int ret, carrier_offset;
+	struct cxd2841er_priv *priv = fe->demodulator_priv;
+	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
+
+	dev_dbg(&priv->i2c->dev, "%s(): re_tune %d bandwidth=%d\n", __func__,
+			re_tune, p->bandwidth_hz);
+	if (re_tune) {
+		ret = cxd2841er_set_frontend_tc(fe);
+		if (ret)
+			return ret;
+		cxd2841er_read_status_tc(fe, status);
+		if (*status & FE_HAS_LOCK) {
+			switch (priv->system) {
+			case SYS_ISDBT:
+				ret = cxd2841er_get_carrier_offset_i(
+						priv, p->bandwidth_hz,
+						&carrier_offset);
+				if (ret)
+					return ret;
+				break;
+			case SYS_DVBT:
+				ret = cxd2841er_get_carrier_offset_t(
+					priv, p->bandwidth_hz,
+					&carrier_offset);
+				if (ret)
+					return ret;
+				break;
+			case SYS_DVBT2:
+				ret = cxd2841er_get_carrier_offset_t2(
+					priv, p->bandwidth_hz,
+					&carrier_offset);
+				if (ret)
+					return ret;
+				break;
+			case SYS_DVBC_ANNEX_A:
+				ret = cxd2841er_get_carrier_offset_c(
+					priv, &carrier_offset);
+				if (ret)
+					return ret;
+				break;
+			default:
+				dev_dbg(&priv->i2c->dev,
+					"%s(): invalid delivery system %d\n",
+					__func__, priv->system);
+				return -EINVAL;
+			}
+			dev_dbg(&priv->i2c->dev, "%s(): carrier offset %d\n",
+				__func__, carrier_offset);
+			p->frequency += carrier_offset;
+			ret = cxd2841er_set_frontend_tc(fe);
+			if (ret)
+				return ret;
+		}
+	}
+	*delay = HZ / 5;
+	return cxd2841er_read_status_tc(fe, status);
+}
+
+static int cxd2841er_sleep_s(struct dvb_frontend *fe)
+{
+	struct cxd2841er_priv *priv = fe->demodulator_priv;
+
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	cxd2841er_active_s_to_sleep_s(fe->demodulator_priv);
+	cxd2841er_sleep_s_to_shutdown(fe->demodulator_priv);
+	return 0;
+}
+
+static int cxd2841er_sleep_tc(struct dvb_frontend *fe)
+{
+	struct cxd2841er_priv *priv = fe->demodulator_priv;
+
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	if (priv->state == STATE_ACTIVE_TC) {
+		switch (priv->system) {
+		case SYS_DVBT:
+			cxd2841er_active_t_to_sleep_tc(priv);
+			break;
+		case SYS_DVBT2:
+			cxd2841er_active_t2_to_sleep_tc(priv);
+			break;
+		case SYS_ISDBT:
+			cxd2841er_active_i_to_sleep_tc(priv);
+			break;
+		case SYS_DVBC_ANNEX_A:
+			cxd2841er_active_c_to_sleep_tc(priv);
+			break;
+		default:
+			dev_warn(&priv->i2c->dev,
+				"%s(): unknown delivery system %d\n",
+				__func__, priv->system);
+		}
+	}
+	if (priv->state != STATE_SLEEP_TC) {
+		dev_err(&priv->i2c->dev, "%s(): invalid state %d\n",
+			__func__, priv->state);
+		return -EINVAL;
+	}
+	cxd2841er_sleep_tc_to_shutdown(priv);
+	return 0;
+}
+
+static int cxd2841er_send_burst(struct dvb_frontend *fe,
+				enum fe_sec_mini_cmd burst)
+{
+	u8 data;
+	struct cxd2841er_priv *priv  = fe->demodulator_priv;
+
+	dev_dbg(&priv->i2c->dev, "%s(): burst mode %s\n", __func__,
+		(burst == SEC_MINI_A ? "A" : "B"));
+	if (priv->state != STATE_SLEEP_S &&
+			priv->state != STATE_ACTIVE_S) {
+		dev_err(&priv->i2c->dev, "%s(): invalid demod state %d\n",
+			__func__, priv->state);
+		return -EINVAL;
+	}
+	data = (burst == SEC_MINI_A ? 0 : 1);
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0xbb);
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x34, 0x01);
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x35, data);
+	return 0;
+}
+
+static int cxd2841er_set_tone(struct dvb_frontend *fe,
+			      enum fe_sec_tone_mode tone)
+{
+	u8 data;
+	struct cxd2841er_priv *priv  = fe->demodulator_priv;
+
+	dev_dbg(&priv->i2c->dev, "%s(): tone %s\n", __func__,
+		(tone == SEC_TONE_ON ? "On" : "Off"));
+	if (priv->state != STATE_SLEEP_S &&
+			priv->state != STATE_ACTIVE_S) {
+		dev_err(&priv->i2c->dev, "%s(): invalid demod state %d\n",
+			__func__, priv->state);
+		return -EINVAL;
+	}
+	data = (tone == SEC_TONE_ON ? 1 : 0);
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0xbb);
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x36, data);
+	return 0;
+}
+
+static int cxd2841er_send_diseqc_msg(struct dvb_frontend *fe,
+				     struct dvb_diseqc_master_cmd *cmd)
+{
+	int i;
+	u8 data[12];
+	struct cxd2841er_priv *priv  = fe->demodulator_priv;
+
+	if (priv->state != STATE_SLEEP_S &&
+			priv->state != STATE_ACTIVE_S) {
+		dev_err(&priv->i2c->dev, "%s(): invalid demod state %d\n",
+			__func__, priv->state);
+		return -EINVAL;
+	}
+	dev_dbg(&priv->i2c->dev,
+		"%s(): cmd->len %d\n", __func__, cmd->msg_len);
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0xbb);
+	/* DiDEqC enable */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x33, 0x01);
+	/* cmd1 length & data */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x3d, cmd->msg_len);
+	memset(data, 0, sizeof(data));
+	for (i = 0; i < cmd->msg_len && i < sizeof(data); i++)
+		data[i] = cmd->msg[i];
+	cxd2841er_write_regs(priv, I2C_SLVT, 0x3e, data, sizeof(data));
+	/* repeat count for cmd1 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x37, 1);
+	/* repeat count for cmd2: always 0 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x38, 0);
+	/* start transmit */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x32, 0x01);
+	/* wait for 1 sec timeout */
+	for (i = 0; i < 50; i++) {
+		cxd2841er_read_reg(priv, I2C_SLVT, 0x10, data);
+		if (!data[0]) {
+			dev_dbg(&priv->i2c->dev,
+				"%s(): DiSEqC cmd has been sent\n", __func__);
+			return 0;
+		}
+		msleep(20);
+	}
+	dev_dbg(&priv->i2c->dev,
+		"%s(): DiSEqC cmd transmit timeout\n", __func__);
+	return -ETIMEDOUT;
+}
+
+static void cxd2841er_release(struct dvb_frontend *fe)
+{
+	struct cxd2841er_priv *priv  = fe->demodulator_priv;
+
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	kfree(priv);
+}
+
+static int cxd2841er_i2c_gate_ctrl(struct dvb_frontend *fe, int enable)
+{
+	struct cxd2841er_priv *priv = fe->demodulator_priv;
+
+	dev_dbg(&priv->i2c->dev, "%s(): enable=%d\n", __func__, enable);
+	cxd2841er_set_reg_bits(
+		priv, I2C_SLVX, 0x8, (enable ? 0x01 : 0x00), 0x01);
+	return 0;
+}
+
+static enum dvbfe_algo cxd2841er_get_algo(struct dvb_frontend *fe)
+{
+	struct cxd2841er_priv *priv = fe->demodulator_priv;
+
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	return DVBFE_ALGO_HW;
+}
+
+static void cxd2841er_init_stats(struct dvb_frontend *fe)
+{
+	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
+
+	p->strength.len = 1;
+	p->strength.stat[0].scale = FE_SCALE_RELATIVE;
+	p->cnr.len = 1;
+	p->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+	p->block_error.len = 1;
+	p->block_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+	p->post_bit_error.len = 1;
+	p->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+	p->post_bit_count.len = 1;
+	p->post_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+}
+
+
+static int cxd2841er_init_s(struct dvb_frontend *fe)
+{
+	struct cxd2841er_priv *priv = fe->demodulator_priv;
+
+	/* sanity. force demod to SHUTDOWN state */
+	if (priv->state == STATE_SLEEP_S) {
+		dev_dbg(&priv->i2c->dev, "%s() forcing sleep->shutdown\n",
+				__func__);
+		cxd2841er_sleep_s_to_shutdown(priv);
+	} else if (priv->state == STATE_ACTIVE_S) {
+		dev_dbg(&priv->i2c->dev, "%s() forcing active->sleep->shutdown\n",
+				__func__);
+		cxd2841er_active_s_to_sleep_s(priv);
+		cxd2841er_sleep_s_to_shutdown(priv);
+	}
+
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	cxd2841er_shutdown_to_sleep_s(priv);
+	/* SONY_DEMOD_CONFIG_SAT_IFAGCNEG set to 1 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0xa0);
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0xb9, 0x01, 0x01);
+
+	cxd2841er_init_stats(fe);
+
+	return 0;
+}
+
+static int cxd2841er_init_tc(struct dvb_frontend *fe)
+{
+	struct cxd2841er_priv *priv = fe->demodulator_priv;
+	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
+
+	dev_dbg(&priv->i2c->dev, "%s() bandwidth_hz=%d\n",
+			__func__, p->bandwidth_hz);
+	cxd2841er_shutdown_to_sleep_tc(priv);
+	/* SONY_DEMOD_CONFIG_IFAGCNEG = 1 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0xcb, 
+						priv->config->if_agc ? 0x40 : 0x00, 0x40);
+	/* SONY_DEMOD_CONFIG_IFAGC_ADC_FS = 0 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0xcd, 
+						priv->config->ifagc_adc_range);
+	/* SONY_DEMOD_CONFIG_PARALLEL_SEL = 1 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0xCB, 
+					priv->config->ts_error_polarity ? 0x00 : 0x01, 0x01);
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0xC5, 
+					priv->config->clock_polarity ? 0x01 : 0x00, 0x01);
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0xc4, 0x00, 0x80);
+
+	cxd2841er_init_stats(fe);
+
+	return 0;
+}
+
+static struct dvb_frontend_ops cxd2841er_dvbs_s2_ops;
+static struct dvb_frontend_ops cxd2841er_t_c_ops;
+
+static struct dvb_frontend *cxd2841er_attach(struct cxd2841er_config *cfg,
+					     struct i2c_adapter *i2c,
+					     u8 system)
+{
+	u8 chip_id = 0;
+	const char *type;
+	const char *name;
+	struct cxd2841er_priv *priv = NULL;
+
+	/* allocate memory for the internal state */
+	priv = kzalloc(sizeof(struct cxd2841er_priv), GFP_KERNEL);
+	if (!priv)
+		return NULL;
+	priv->i2c = i2c;
+	priv->config = cfg;
+	priv->i2c_addr_slvx = cfg->i2c_addr + 2;
+	priv->i2c_addr_slvt = cfg->i2c_addr;
+	priv->xtal = cfg->xtal;
+	priv->frontend.demodulator_priv = priv;
+	dev_info(&priv->i2c->dev,
+		"%s(): I2C adapter %p SLVX addr %x SLVT addr %x\n",
+		__func__, priv->i2c,
+		priv->i2c_addr_slvx, priv->i2c_addr_slvt);
+	chip_id = cxd2841er_chip_id(priv);
+	switch (chip_id) {
+	case CXD2837ER_CHIP_ID:
+		snprintf(cxd2841er_t_c_ops.info.name, 128,
+				"Sony CXD2837ER DVB-T/T2/C demodulator");
+		name = "CXD2837ER";
+		break;
+	case CXD2841ER_CHIP_ID:
+		snprintf(cxd2841er_t_c_ops.info.name, 128,
+				"Sony CXD2841ER DVB-T/T2/C demodulator");
+		name = "CXD2841ER";
+		break;
+	case CXD2854ER_CHIP_ID:
+		snprintf(cxd2841er_t_c_ops.info.name, 128,
+				"Sony CXD2854ER DVB-T/T2/C and ISDB-T demodulator");
+		cxd2841er_t_c_ops.delsys[3] = SYS_ISDBT;
+		name = "CXD2854ER";
+		break;
+	default:
+		dev_err(&priv->i2c->dev, "%s(): invalid chip ID 0x%02x\n",
+				__func__, chip_id);
+		priv->frontend.demodulator_priv = NULL;
+		kfree(priv);
+		return NULL;
+	}
+
+	/* create dvb_frontend */
+	if (system == SYS_DVBS) {
+		memcpy(&priv->frontend.ops,
+			&cxd2841er_dvbs_s2_ops,
+			sizeof(struct dvb_frontend_ops));
+		type = "S/S2";
+	} else {
+		memcpy(&priv->frontend.ops,
+			&cxd2841er_t_c_ops,
+			sizeof(struct dvb_frontend_ops));
+		type = "T/T2/C/ISDB-T";
+	}
+
+	dev_info(&priv->i2c->dev,
+		"%s(): attaching %s DVB-%s frontend\n",
+		__func__, name, type);
+	dev_info(&priv->i2c->dev, "%s(): chip ID 0x%02x OK.\n",
+		__func__, chip_id);
+	return &priv->frontend;
+}
+
+struct dvb_frontend *cxd2841er_attach_s(struct cxd2841er_config *cfg,
+					struct i2c_adapter *i2c)
+{
+	return cxd2841er_attach(cfg, i2c, SYS_DVBS);
+}
+EXPORT_SYMBOL(cxd2841er_attach_s);
+
+struct dvb_frontend *cxd2841er_attach_t_c(struct cxd2841er_config *cfg,
+					struct i2c_adapter *i2c)
+{
+	return cxd2841er_attach(cfg, i2c, 0);
+}
+EXPORT_SYMBOL(cxd2841er_attach_t_c);
+
+static struct dvb_frontend_ops cxd2841er_dvbs_s2_ops = {
+	.delsys = { SYS_DVBS, SYS_DVBS2 },
+	.info = {
+		.name		= "Sony CXD2841ER DVB-S/S2 demodulator",
+		.frequency_min	= 500000,
+		.frequency_max	= 2500000,
+		.frequency_stepsize	= 0,
+		.symbol_rate_min = 1000000,
+		.symbol_rate_max = 45000000,
+		.symbol_rate_tolerance = 500,
+		.caps = FE_CAN_INVERSION_AUTO |
+			FE_CAN_FEC_AUTO |
+			FE_CAN_QPSK,
+	},
+	.init = cxd2841er_init_s,
+	.sleep = cxd2841er_sleep_s,
+	.release = cxd2841er_release,
+	.set_frontend = cxd2841er_set_frontend_s,
+	.get_frontend = cxd2841er_get_frontend,
+	.read_status = cxd2841er_read_status_s,
+	.i2c_gate_ctrl = cxd2841er_i2c_gate_ctrl,
+	.get_frontend_algo = cxd2841er_get_algo,
+	.set_tone = cxd2841er_set_tone,
+	.diseqc_send_burst = cxd2841er_send_burst,
+	.diseqc_send_master_cmd = cxd2841er_send_diseqc_msg,
+	.tune = cxd2841er_tune_s
+};
+
+static struct  dvb_frontend_ops cxd2841er_t_c_ops = {
+	.delsys = { SYS_DVBT, SYS_DVBT2, SYS_DVBC_ANNEX_A },
+	.info = {
+		.name	= "", /* will set in attach function */
+		.caps = FE_CAN_FEC_1_2 |
+			FE_CAN_FEC_2_3 |
+			FE_CAN_FEC_3_4 |
+			FE_CAN_FEC_5_6 |
+			FE_CAN_FEC_7_8 |
+			FE_CAN_FEC_AUTO |
+			FE_CAN_QPSK |
+			FE_CAN_QAM_16 |
+			FE_CAN_QAM_32 |
+			FE_CAN_QAM_64 |
+			FE_CAN_QAM_128 |
+			FE_CAN_QAM_256 |
+			FE_CAN_QAM_AUTO |
+			FE_CAN_TRANSMISSION_MODE_AUTO |
+			FE_CAN_GUARD_INTERVAL_AUTO |
+			FE_CAN_HIERARCHY_AUTO |
+			FE_CAN_MUTE_TS |
+			FE_CAN_2G_MODULATION,
+		.frequency_min = 42000000,
+		.frequency_max = 1002000000
+	},
+	.init = cxd2841er_init_tc,
+	.sleep = cxd2841er_sleep_tc,
+	.release = cxd2841er_release,
+	.set_frontend = cxd2841er_set_frontend_tc,
+	.get_frontend = cxd2841er_get_frontend,
+	.read_status = cxd2841er_read_status_tc,
+	.tune = cxd2841er_tune_tc,
+	.i2c_gate_ctrl = cxd2841er_i2c_gate_ctrl,
+	.get_frontend_algo = cxd2841er_get_algo
+};
+
+MODULE_DESCRIPTION("Sony CXD2841ER/CXD2854ER DVB-C/C2/T/T2/S/S2 demodulator driver");
+MODULE_AUTHOR("Sergey Kozlov <serjk@netup.ru>, Abylay Ospan <aospan@netup.ru>");
+MODULE_LICENSE("GPL");
diff --git a/drivers/amlogic/dvb_tv/cxd2841er.h b/drivers/amlogic/dvb_tv/cxd2841er.h
new file mode 100644
index 000000000000..98a468240a9e
--- /dev/null
+++ b/drivers/amlogic/dvb_tv/cxd2841er.h
@@ -0,0 +1,50 @@
+/*
+ * cxd2841er.h
+ *
+ * Sony CXD2441ER digital demodulator driver public definitions
+ *
+ * Copyright 2012 Sony Corporation
+ * Copyright (C) 2014 NetUP Inc.
+ * Copyright (C) 2014 Sergey Kozlov <serjk@netup.ru>
+ * Copyright (C) 2014 Abylay Ospan <aospan@netup.ru>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+  */
+
+#ifndef CXD2841ER_H
+#define CXD2841ER_H
+
+#include <linux/kconfig.h>
+#include <linux/dvb/frontend.h>
+
+enum cxd2841er_xtal {
+	SONY_XTAL_20500, /* 20.5 MHz */
+	SONY_XTAL_24000, /* 24 MHz */
+	SONY_XTAL_41000 /* 41 MHz */
+};
+
+struct cxd2841er_config {
+	u8	i2c_addr;
+	u8 	if_agc;
+	u8	ifagc_adc_range;
+	u8	ts_error_polarity;
+	u8	clock_polarity;
+	u8	mxl603;
+	enum cxd2841er_xtal	xtal;
+};
+
+extern struct dvb_frontend *cxd2841er_attach_s(struct cxd2841er_config *cfg,
+					       struct i2c_adapter *i2c);
+
+extern struct dvb_frontend *cxd2841er_attach_t_c(struct cxd2841er_config *cfg,
+					       struct i2c_adapter *i2c);
+
+#endif
diff --git a/drivers/amlogic/dvb_tv/cxd2841er_priv.h b/drivers/amlogic/dvb_tv/cxd2841er_priv.h
new file mode 100644
index 000000000000..5e2b8d84d968
--- /dev/null
+++ b/drivers/amlogic/dvb_tv/cxd2841er_priv.h
@@ -0,0 +1,45 @@
+/*
+ * cxd2841er_priv.h
+ *
+ * Sony CXD2441ER digital demodulator driver internal definitions
+ *
+ * Copyright 2012 Sony Corporation
+ * Copyright (C) 2014 NetUP Inc.
+ * Copyright (C) 2014 Sergey Kozlov <serjk@netup.ru>
+ * Copyright (C) 2014 Abylay Ospan <aospan@netup.ru>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef CXD2841ER_PRIV_H
+#define CXD2841ER_PRIV_H
+
+#define I2C_SLVX			0
+#define I2C_SLVT			1
+
+#define CXD2841ER_CHIP_ID		0xa7
+#define CXD2854ER_CHIP_ID		0xc1
+#define CXD2837ER_CHIP_ID		0xb1
+
+#define CXD2841ER_DVBS_POLLING_INVL	10
+
+struct cxd2841er_cnr_data {
+	u32 value;
+	int cnr_x1000;
+};
+
+enum cxd2841er_dvbt2_profile_t {
+	DVBT2_PROFILE_ANY = 0,
+	DVBT2_PROFILE_BASE = 1,
+	DVBT2_PROFILE_LITE = 2
+};
+
+#endif
diff --git a/drivers/amlogic/dvb_tv/mn88436.c b/drivers/amlogic/dvb_tv/mn88436.c
new file mode 100644
index 000000000000..d76c88d6bb99
--- /dev/null
+++ b/drivers/amlogic/dvb_tv/mn88436.c
@@ -0,0 +1,379 @@
+/*
+ * Driver for the Panasonic MN88436 ATSC demodulator
+ *
+ * Copyright (C) 2014 Sasa Savic <sasa.savic.sr@gmail.com>
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License along
+ *    with this program; if not, write to the Free Software Foundation, Inc.,
+ *    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/firmware.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/version.h>
+#include "dvb_frontend.h"
+#include "mn88436.h"
+
+struct mn88436_state { 
+	struct dvb_frontend frontend;
+	struct i2c_adapter   *i2c;
+	fe_modulation_t current_modulation;
+	u32 current_frequency;	
+	u8 mn88436_bank[DMD_REG_BANK];
+	bool boot;
+};
+static int mn88436_write_reg(struct mn88436_state *state, u8 id, u8 reg, u8 val)
+{
+	int ret;
+	u8 buf[] = { reg, val };
+	struct i2c_msg msg = {	.addr = state->mn88436_bank[id], 
+							.flags = 0,
+							.buf = buf, 
+							.len = 2 
+						};
+	
+		
+	ret = i2c_transfer(state->i2c, &msg, 1);
+	if (ret == 1) {
+		ret = 0;
+	} else {
+		dev_warn(&state->i2c->dev, "i2c wr failed=%d reg=%02x "
+				, ret, reg);				
+		ret = -EREMOTEIO;
+	}
+	return ret;
+}
+static int mn88436_read_reg(struct mn88436_state *state, u8 id, u8 reg, u8 *val)
+{	
+	int ret;
+	u8 buf[] = { reg };
+	struct i2c_msg msg[] = {
+		{	.addr = state->mn88436_bank[id], 
+			.flags = 0,
+			.buf = buf, 
+			.len = 1 
+		},
+		{ 	.addr = state->mn88436_bank[id], 
+			.flags = I2C_M_RD,
+			.buf = val, 
+			.len = 1 
+		}, 
+	};
+
+	ret = i2c_transfer(state->i2c, msg, 2);
+	if (ret == 2) {
+		ret = 0;
+	} else {
+		dev_warn(&state->i2c->dev, "i2c rd failed=%d reg=%02x "
+				, ret, reg);
+		ret = -EREMOTEIO;
+	}
+	return ret;
+}
+static int mn88436_write_reg_mask(struct mn88436_state *state, u8 id,
+								u8 reg , u8 mask , u8 data)
+{
+	int ret;
+	u8 rd;
+	
+	ret = mn88436_read_reg(state, id, reg, &rd);
+	if (ret)
+		goto err;
+	
+	rd |= mask & data;
+	rd &= (mask ^ 0xff) | data;
+	
+	ret = mn88436_write_reg(state, id, reg, rd);
+	if (ret)
+		goto err;
+	
+	return 0;
+	
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+
+
+static int mn88436_read_status(struct dvb_frontend* fe, fe_status_t* status)
+{
+	struct mn88436_state* state = fe->demodulator_priv;	
+	int ret;
+	u8 locked;
+	*status = 0;
+	
+	ret = mn88436_read_reg(state, 0, DMD_MAIN_STSMON1, &locked);
+	if (ret)
+		goto err;
+
+	if (locked & 1) 
+		*status |= FE_HAS_SIGNAL | FE_HAS_CARRIER | 
+				FE_HAS_VITERBI | FE_HAS_SYNC | FE_HAS_LOCK;
+		
+	return 0;
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+	
+}
+static int mn88436_set_frontend(struct dvb_frontend* fe)
+{
+	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
+	struct mn88436_state* state = fe->demodulator_priv;
+	int cnt = 50, ret;
+	u8 locked;
+	
+	if (!state->boot) {
+		ret = -EAGAIN;
+		goto err;
+	}
+
+	if (fe->ops.tuner_ops.set_params) {
+		ret = fe->ops.tuner_ops.set_params(fe);
+		if (ret)
+			goto err;
+	}
+	
+	ret = mn88436_write_reg(state, 0, DMD_MAIN_RSTSET1, 0x77);
+	if (ret)
+		goto err;
+			
+		
+	do {
+		ret = mn88436_read_reg(state, 0, DMD_MAIN_STSMON1, &locked);
+
+		if (!ret && (locked & 1))
+				break;
+
+		msleep(10);   
+		
+	} while (--cnt);
+	
+	if (!cnt) {
+		ret = -EAGAIN;
+		goto err;
+	}
+	
+	dev_dbg(&state->i2c->dev, "Service locked!!!\n");
+	
+	state->current_frequency = p->frequency;
+	state->current_modulation = p->modulation;
+	
+	return 0;
+	
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int mn88436_get_frontend(struct dvb_frontend *fe)
+{
+	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
+	struct mn88436_state *state = fe->demodulator_priv;
+
+	p->modulation = state->current_modulation;
+	p->frequency = state->current_frequency;
+	
+	return 0;
+}
+
+
+static int mn88436_init(struct dvb_frontend* fe)
+{
+	struct mn88436_state* state = fe->demodulator_priv;
+	const struct firmware *fw = NULL;	
+	int ret, i;
+	u8 d;
+	
+	if (state->boot)
+		return 0;
+		
+	dev_dbg(&state->i2c->dev, "Uploading demod firmware (%s)...\n", MN88436_DEMOD_ATSC);
+	
+	ret = request_firmware(&fw, MN88436_DEMOD_ATSC, &state->i2c->dev);
+	if (ret) {
+		dev_dbg(&state->i2c->dev, "Firmware upload failed. Timeout or file not found\n");
+		goto err1;
+	}    
+	
+	for (i = 0;;) {
+	
+		if (fw->data[i] == 0xff) 
+			break;
+			
+		ret = mn88436_write_reg(state, fw->data[i], fw->data[i + 1], fw->data[i + 2]);
+		if (ret)
+			goto err2;
+					
+		i = i + 3;		
+	}
+	
+	release_firmware(fw);
+	fw = NULL;
+	
+	dev_dbg(&state->i2c->dev, "Uploading demod pseq (%s)...\n", MN88436_DEMOD_PSEQ);
+	ret = request_firmware(&fw, MN88436_DEMOD_PSEQ, &state->i2c->dev);
+	if (ret) {
+		dev_dbg(&state->i2c->dev, "Pseq upload failed. Timeout or file not found\n");
+		goto err1;
+	}    
+	
+	/* Load PSEQ Program */
+	ret = mn88436_write_reg(state, 0, DMD_MAIN_PSEQSET , 0x03);
+	if (ret)
+		goto err2;
+	
+	for (i = 0; i < fw->size; i++) {
+		ret = mn88436_write_reg(state, 0, DMD_MAIN_PSEQPRG , fw->data[i]);
+		if (ret)
+			goto err2;
+	}
+	
+	release_firmware(fw);
+	fw = NULL;
+	
+	/* Check Parity bit */
+	ret = mn88436_read_reg(state, 0, DMD_MAIN_PSEQSET , &d);
+	if (ret)
+		goto err1;
+	
+	if (d & 0x20) {
+		ret = -EAGAIN;
+		goto err1;
+	}
+	
+	ret = mn88436_write_reg(state, 0, DMD_MAIN_PSEQSET , 0x00);
+	if (ret)
+		goto err1;
+		
+		
+	/* TS parallel (Fixed clock mode) */
+	ret = mn88436_write_reg(state, 0, DMD_MAIN_CPOSET2, 0xc1);
+	if (ret)
+		goto err1;
+	ret = mn88436_write_reg(state, 0, DMD_MAIN_GPSET1, 0xff);
+	if (ret)
+		goto err1;
+		
+
+	/* Set TCB Through Mode */
+	ret = mn88436_write_reg_mask(state, 0, DMD_MAIN_TCBSET, 0x7f, 0x53);	
+	if (ret)
+		goto err1;		
+	ret = mn88436_write_reg(state, 0, DMD_MAIN_TCBADR, 0x00);
+	if (ret)
+		goto err1;
+	
+	
+	ret = mn88436_write_reg(state, 0, DMD_MAIN_VEQSET2, 0x80);
+	if (ret)
+		goto err1;
+		
+	state->boot = true;
+	
+	return 0;
+	
+err2:
+	release_firmware(fw);
+	fw = NULL;
+err1:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+	
+}
+static void mn88436_release(struct dvb_frontend* fe)
+{
+	struct mn88436_state* state = fe->demodulator_priv;
+	kfree(state);
+}
+
+
+static struct dvb_frontend_ops mn88436_ops = {
+	.delsys = { SYS_ATSC },
+	.info = {
+		.name = "Panasonic MN88436",		
+		.frequency_min = 51000000,
+		.frequency_max = 858000000,
+		.caps = FE_CAN_8VSB
+	},
+	.init = mn88436_init,
+	.release = mn88436_release,	
+	.set_frontend = mn88436_set_frontend,
+	.get_frontend = mn88436_get_frontend,	
+	.read_status = mn88436_read_status,
+	
+};
+
+struct dvb_frontend *mn88436_attach(struct i2c_adapter *i2c, 
+									u8 device_id)
+{
+	struct mn88436_state *state = NULL;
+	int ret;
+	
+	
+	state = kzalloc(sizeof(struct mn88436_state), GFP_KERNEL);
+	if (!state) {
+		ret = -ENOMEM;
+		dev_err(&i2c->dev, "kzalloc() failed\n");
+		goto err1;
+	}
+
+	state->i2c = i2c;
+	
+	switch (device_id) {
+	case 0:
+	default:
+		state->mn88436_bank[0] = 0x18;
+		state->mn88436_bank[1] = 0x10;
+		break;
+	case 1:
+		state->mn88436_bank[0] = 0x19;
+		state->mn88436_bank[1] = 0x11;
+		break;
+	case 2:
+		state->mn88436_bank[0] = 0x1A;
+		state->mn88436_bank[1] = 0x12;
+		break;
+	case 3:
+		state->mn88436_bank[0] = 0x1B;
+		state->mn88436_bank[1] = 0x13;
+		break;		
+	}
+	/* Try SOFT reset */
+	ret = mn88436_write_reg(state, 0, DMD_MAIN_RSTSET1, 0x77);
+	if (ret)
+		goto err2;
+	
+	dev_info(&i2c->dev, "MN88436 ATSC successfully attached\n");						
+		
+	memcpy(&state->frontend.ops, &mn88436_ops,
+		       sizeof(struct dvb_frontend_ops));
+			   
+	state->frontend.demodulator_priv = state;
+	
+	return &state->frontend;
+	
+err2:	
+	kfree(state);
+err1:	
+	dev_dbg(&i2c->dev, "%s: failed=%d\n", __func__, ret);	
+	return NULL;
+}
+EXPORT_SYMBOL(mn88436_attach);
+
+MODULE_DESCRIPTION("Panasonic MN88436 ATSC demod driver");
+MODULE_AUTHOR("Sasa Savic <sasa.savic.sr@gmail.com>");
+MODULE_LICENSE("GPL");
diff --git a/drivers/amlogic/dvb_tv/mn88436.h b/drivers/amlogic/dvb_tv/mn88436.h
new file mode 100644
index 000000000000..e16db86f781d
--- /dev/null
+++ b/drivers/amlogic/dvb_tv/mn88436.h
@@ -0,0 +1,47 @@
+/*
+ * Driver for the Panasonic MN88436 ATSC demodulator
+ *
+ * Copyright (C) 2014 Sasa Savic <sasa.savic.sr@gmail.com>
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License along
+ *    with this program; if not, write to the Free Software Foundation, Inc.,
+ *    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+ 
+#ifndef __MN88436_H_
+#define __MN88436_H_
+
+#include <linux/types.h>
+#include <linux/i2c.h>
+
+
+#define MN88436_DEMOD_ATSC 		"dvb-fe-mn88436-atsc.fw" 
+#define MN88436_DEMOD_PSEQ 		"dvb-fe-mn88436-pseq.fw" 
+
+#define DMD_REG_BANK    		2
+
+#define DMD_MAIN_CPOSET2		0x2
+#define DMD_MAIN_GPSET1			0x5
+#define DMD_MAIN_RSTSET1		0x10
+#define DMD_MAIN_TCBSET			0x15
+#define DMD_MAIN_TCBADR			0x17
+#define DMD_MAIN_VEQSET2		0x69
+#define DMD_MAIN_STSMON1		0xC4
+#define DMD_MAIN_PSEQSET		0xF0
+#define DMD_MAIN_PSEQPRG		0xF1
+
+
+extern struct dvb_frontend *mn88436_attach(struct i2c_adapter *i2c,
+											u8 device_id);
+
+#endif
\ No newline at end of file
diff --git a/drivers/amlogic/dvb_tv/mxl603.c b/drivers/amlogic/dvb_tv/mxl603.c
new file mode 100644
index 000000000000..bc7018c3b639
--- /dev/null
+++ b/drivers/amlogic/dvb_tv/mxl603.c
@@ -0,0 +1,1096 @@
+/*
+ * Driver for the MaxLinear MxL603 tuner
+ *
+ * Copyright (C) 2014 Sasa Savic <sasa.savic.sr@gmail.com>
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License along
+ *    with this program; if not, write to the Free Software Foundation, Inc.,
+ *    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <linux/i2c.h>
+#include <linux/types.h>
+#include "tuner-i2c.h"
+#include "mxl603.h"
+
+
+enum mxl603_mode {
+	MxL603_MODE_CABLE,
+	MxL603_MODE_ISDBT_ATSC,
+	MxL603_MODE_DVBT,
+};
+
+enum mxl603_bw_mhz {
+	MxL603_CABLE_BW_6MHz = 0x00,
+	MxL603_CABLE_BW_7MHz = 0x01,
+	MxL603_CABLE_BW_8MHz = 0x02,
+	MxL603_TERR_BW_6MHz = 0x20,
+	MxL603_TERR_BW_7MHz = 0x21,
+	MxL603_TERR_BW_8MHz = 0x22,
+};
+
+struct reg_pair_t {
+	u8 reg;
+	u8 val;
+};
+
+struct freq_table {
+	u32 center_freq;
+	u8 reg1;
+	u8 reg2;
+};
+
+static struct freq_table MxL603_Cable[] = {
+	{ 1        , 0x00, 0xD8 },
+	{ 695000000, 0x20, 0xD7 },
+	{ 0, 0, 0 },
+};
+
+static struct freq_table MxL603_Digital[] = {
+	{ 1, 0x00, 0xD8 },
+	{ 0, 0, 0 },
+};
+
+static struct reg_pair_t MxL603_DigitalDvbc[] = {
+	{ 0x0C, 0x00 },
+	{ 0x13, 0x04 },
+	{ 0x53, 0x7E },
+	{ 0x57, 0x91 },
+	{ 0x5C, 0xB1 },
+	{ 0x62, 0xF2 },
+	{ 0x6E, 0x03 },
+	{ 0x6F, 0xD1 },
+	{ 0x87, 0x77 },
+	{ 0x88, 0x55 },
+	{ 0x93, 0x33 },
+	{ 0x97, 0x03 },
+	{ 0xBA, 0x40 },
+	{ 0x98, 0xAF },
+	{ 0x9B, 0x20 },
+	{ 0x9C, 0x1E },
+	{ 0xA0, 0x18 },
+	{ 0xA5, 0x09 },
+	{ 0xC2, 0xA9 },
+	{ 0xC5, 0x7C },
+	{ 0xCD, 0x64 },
+	{ 0xCE, 0x7C },
+	{ 0xD5, 0x05 },
+	{ 0xD9, 0x00 },
+	{ 0xEA, 0x00 },
+	{ 0xDC, 0x1C },
+	{ 0, 0 }
+};
+
+static struct reg_pair_t MxL603_DigitalIsdbtAtsc[] = {
+	{ 0x0C, 0x00 },
+	{ 0x13, 0x04 },
+	{ 0x53, 0xFE },
+	{ 0x57, 0x91 },
+	{ 0x62, 0xC2 },
+	{ 0x6E, 0x01 },
+	{ 0x6F, 0x51 },
+	{ 0x87, 0x77 },
+	{ 0x88, 0x55 },
+	{ 0x93, 0x22 },
+	{ 0x97, 0x02 },
+	{ 0xBA, 0x30 },
+	{ 0x98, 0xAF },
+	{ 0x9B, 0x20 },
+	{ 0x9C, 0x1E },
+	{ 0xA0, 0x18 },
+	{ 0xA5, 0x09 },
+	{ 0xC2, 0xA9 },
+	{ 0xC5, 0x7C },
+	{ 0xCD, 0xEB },
+	{ 0xCE, 0x7F },
+	{ 0xD5, 0x03 },
+	{ 0xD9, 0x04 },
+	{ 0, 0 }
+};
+
+static struct reg_pair_t MxL603_DigitalDvbt[] = {
+	{ 0x0C, 0x00 },
+	{ 0x13, 0x04 },
+	{ 0x53, 0xFE },
+	{ 0x57, 0x91 },
+	{ 0x62, 0xC2 },
+	{ 0x6E, 0x01 },
+	{ 0x6F, 0x51 },
+	{ 0x87, 0x77 },
+	{ 0x88, 0x55 },
+	{ 0x93, 0x22 },
+	{ 0x97, 0x02 },
+	{ 0xBA, 0x30 },
+	{ 0x98, 0xAF },
+	{ 0x9B, 0x20 },
+	{ 0x9C, 0x1E },
+	{ 0xA0, 0x18 },
+	{ 0xA5, 0x09 },
+	{ 0xC2, 0xA9 },
+	{ 0xC5, 0x7C },
+	{ 0xCD, 0x64 },
+	{ 0xCE, 0x7C },
+	{ 0xD5, 0x03 },
+	{ 0xD9, 0x04 },
+	{ 0, 0 }
+};
+
+struct mxl603_state {
+	struct mxl603_config *config;
+	struct i2c_adapter   *i2c;
+	u8 addr;
+	u32 frequency;
+	u32 bandwidth;
+};
+
+static int mxl603_write_reg(struct mxl603_state *state, u8 reg, u8 val)
+{
+	
+	u8 buf[] = { reg, val };
+	struct i2c_msg msg = { .addr = state->addr, .flags = 0,
+			       .buf = buf, .len = 2 };
+	int ret;
+		
+	ret = i2c_transfer(state->i2c, &msg, 1);
+	if (ret == 1) {
+		ret = 0;
+	} else {
+		dev_warn(&state->i2c->dev, "i2c wr failed=%d reg=%02x "
+				, ret, reg);				
+		ret = -EREMOTEIO;
+	}
+	return ret;
+}
+
+static int mxl603_write_regs(struct mxl603_state *state,
+			       struct reg_pair_t *reg_pair)
+{
+	unsigned int i = 0;
+	int ret = 0;
+
+	while ((ret == 0) && (reg_pair[i].reg || reg_pair[i].val)) {
+		ret = mxl603_write_reg(state,
+					 reg_pair[i].reg, reg_pair[i].val);
+		i++;
+	}
+	return ret;
+}
+static int mxl603_read_reg(struct mxl603_state *state, u8 reg, u8 *val)
+{
+	
+	u8 buf[2] = { 0xfb, reg };
+	struct i2c_msg msg[] = {
+		{ .addr = state->addr, .flags = 0,
+		  .buf = buf, .len = 2 },
+		{ .addr = state->addr, .flags = I2C_M_RD,
+		  .buf = val, .len = 1 },
+	};
+	int ret;
+
+	ret = i2c_transfer(state->i2c, msg, 2);
+	if (ret == 2) {
+		ret = 0;
+	} else {
+		dev_warn(&state->i2c->dev, "i2c rd failed=%d reg=%02x "
+				, ret, reg);
+		ret = -EREMOTEIO;
+	}
+	return ret;
+}
+static int mxl603_get_if_frequency(struct dvb_frontend *fe, u32 *frequency)
+{
+	struct mxl603_state *state = fe->tuner_priv;
+
+	*frequency = 0;
+
+	switch (state->config->if_freq_hz) {
+	case MXL603_IF_3_65MHz:
+		*frequency = 3650000;
+		break;
+	case MXL603_IF_4MHz:
+		*frequency = 4000000;
+		break;
+	case MXL603_IF_4_1MHz:
+		*frequency = 4100000;
+		break;
+	case MXL603_IF_4_15MHz:
+		*frequency = 4150000;
+		break;
+	case MXL603_IF_4_5MHz:
+		*frequency = 4500000;
+		break;
+	case MXL603_IF_4_57MHz:
+		*frequency = 4570000;
+		break;
+	case MXL603_IF_5MHz:
+		*frequency = 5000000;
+		break;
+	case MXL603_IF_5_38MHz:
+		*frequency = 5380000;
+		break;
+	case MXL603_IF_6MHz:
+		*frequency = 6000000;
+		break;
+	case MXL603_IF_6_28MHz:
+		*frequency = 6280000;
+		break;
+	case MXL603_IF_7_2MHz:
+		*frequency = 7200000;
+		break;
+	case MXL603_IF_8_25MHz:
+		*frequency = 8250000;
+		break;
+	case MXL603_IF_35_25MHz:
+		*frequency = 35250000;
+		break;
+	case MXL603_IF_36MHz:
+		*frequency = 36000000;
+		break;
+	case MXL603_IF_36_15MHz:
+		*frequency = 36150000;
+		break;
+	case MXL603_IF_36_65MHz:
+		*frequency = 36650000;
+		break;
+	case MXL603_IF_44MHz:
+		*frequency = 44000000;
+		break;
+	}
+	return 0;
+}
+
+static int mxl603_set_freq(struct mxl603_state *state,
+						   int freq,
+						   enum mxl603_mode mode,
+						   enum mxl603_bw_mhz bw,
+						   struct freq_table *ftable)
+{
+	u8 d = 0, d1 = 0, d2 = 0, d3 = 0;
+	u16 f;
+	u32 tmp, div;
+	int ret;
+	int i;
+
+	ret = mxl603_write_reg(state, 0x12, 0x00);
+	if (ret)
+		goto err;
+
+	if (freq < 700000000) {
+		ret = mxl603_write_reg(state, 0x7C, 0x1F);
+		if (ret)
+			goto err;
+
+		if (mode == MxL603_MODE_CABLE)
+			d = 0xC1;
+		else
+			d = 0x81;
+
+	} else {
+		ret = mxl603_write_reg(state, 0x7C, 0x9F);
+		if (ret)
+			goto err;
+
+		if (mode == MxL603_MODE_CABLE)
+			d = 0xD1;
+		else
+			d = 0x91;
+	}
+
+	ret = mxl603_write_reg(state, 0x00, 0x01);
+	if (ret)
+		goto err;
+
+	ret = mxl603_write_reg(state, 0x31, d);
+	if (ret)
+		goto err;
+
+	ret = mxl603_write_reg(state, 0x00, 0x00);
+	if (ret)
+		goto err;
+
+	for (i = 0; 0 != ftable->center_freq; i++, ftable++) {
+
+		if (ftable->center_freq == 1) {
+			d1 = ftable->reg1;
+			d2 = ftable->reg2;
+			break;
+		}
+	}
+
+	for (i = 0; 0 != ftable->center_freq; i++, ftable++) {
+
+		if ((ftable->center_freq - 500000) <= freq &&
+			(ftable->center_freq + 500000) >= freq) {
+			d1 = ftable->reg1;
+			d2 = ftable->reg2;
+			break;
+		}
+	}
+
+	ret = mxl603_write_reg(state, 0xEA, d1);
+	if (ret)
+		goto err;
+
+	ret = mxl603_write_reg(state, 0xEB, d2);
+	if (ret)
+		goto err;
+
+	ret = mxl603_write_reg(state, 0x0F, bw);
+	if (ret)
+		goto err;
+
+	 /* convert freq to 10.6 fixed point float [MHz] */
+	f = freq / 1000000;
+	tmp = freq % 1000000;
+	div = 1000000;
+	for (i = 0; i < 6; i++) {
+		f <<= 1;
+		div >>= 1;
+			if (tmp > div) {
+				tmp -= div;
+				f |= 1;
+			}
+	}
+	if (tmp > 7812)
+		f++;
+
+	d1 = f & 0xFF;
+	d2 = f >> 8;
+
+	ret = mxl603_write_reg(state, 0x10, d1);
+	if (ret)
+		goto err;
+
+	ret = mxl603_write_reg(state, 0x11, d2);
+	if (ret)
+		goto err;
+
+	ret = mxl603_write_reg(state, 0x0B, 0x01);
+	if (ret)
+		goto err;
+
+	ret = mxl603_write_reg(state, 0x00, 0x01);
+	if (ret)
+		goto err;
+
+	ret = mxl603_read_reg(state, 0x96, &d);
+	if (ret)
+		goto err;
+
+	ret = mxl603_write_reg(state, 0x00, 0x00);
+	if (ret)
+		goto err;
+
+	ret = mxl603_read_reg(state, 0xB6, &d1);
+	if (ret)
+		goto err;
+
+	ret = mxl603_write_reg(state, 0x00, 0x01);
+	if (ret)
+		goto err;
+
+	ret = mxl603_read_reg(state, 0x60, &d2);
+	if (ret)
+		goto err;
+
+	ret = mxl603_read_reg(state, 0x5F, &d3);
+	if (ret)
+		goto err;
+
+	if ((d & 0x10) == 0x10) {
+
+		d1 &= 0xBF;
+		d1 |= 0x0E;
+
+		d2 &= 0xC0;
+		d2 |= 0x0E;
+
+		d3 &= 0xC0;
+		d3 |= 0x0E;
+	} else {
+
+		d1 |= 0x40;
+		d1 &= 0xC0;
+
+		d2 &= 0xC0;
+		d2 |= 0x37;
+
+		d3 &= 0xC0;
+		d3 |= 0x37;
+
+	}
+
+	ret = mxl603_write_reg(state, 0x60, d2);
+	if (ret)
+		goto err;
+
+	ret = mxl603_write_reg(state, 0x5F, d3);
+	if (ret)
+		goto err;
+
+	ret = mxl603_write_reg(state, 0x00, 0x00);
+	if (ret)
+		goto err;
+
+	ret = mxl603_write_reg(state, 0xB6, d);
+	if (ret)
+		goto err;
+
+	ret = mxl603_write_reg(state, 0x12, 0x01);
+	if (ret)
+		goto err;
+
+	msleep(20);
+
+	d |= 0x40;
+
+	ret = mxl603_write_reg(state, 0xB6, d);
+	if (ret)
+		goto err;
+
+	msleep(20);
+	
+	return 0;
+	
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+
+static int mxl603_set_mode(struct dvb_frontend *fe,
+						struct mxl603_state *state,
+						enum mxl603_mode mode)
+{
+
+	u8 cfg_0, cfg_1, pwr, dfe;
+	int ret;
+	u32 if_out_freq;
+	struct reg_pair_t *reg_table;
+
+	ret = mxl603_get_if_frequency(fe, &if_out_freq);
+	if (!if_out_freq)
+		goto err;
+
+	if_out_freq /= 1000;
+
+	switch (mode) {
+	case MxL603_MODE_CABLE:
+		reg_table = MxL603_DigitalDvbc;
+		pwr = 0;
+		dfe = 0xFF;
+
+		if (if_out_freq <  35250) {
+			cfg_0 = 0xFE;
+			cfg_1 = 0x10;
+
+		} else {
+			cfg_0 = 0xD9;
+			cfg_1 = 0x16;
+		}
+		
+		break;
+	case MxL603_MODE_ISDBT_ATSC:
+		reg_table = MxL603_DigitalIsdbtAtsc;
+		dfe = 0x1C;
+
+		if (if_out_freq <  35250) {
+			cfg_0 = 0xF9;
+			cfg_1 = 0x18;
+			pwr = 0xF1;
+		} else {
+			cfg_0 = 0xD9;
+			cfg_1 = 0x16;
+			pwr = 0xB1;
+		}
+		switch(state->config->if_out_gain_level)
+		{
+			case 0x09: dfe = 0x44; break;
+			case 0x08: dfe = 0x43; break;
+			case 0x07: dfe = 0x42; break;
+			case 0x06: dfe = 0x41; break;
+			case 0x05: dfe = 0x40; break;
+			default: break;
+		}
+
+		break;
+	case MxL603_MODE_DVBT:
+		reg_table = MxL603_DigitalDvbt;
+		dfe = 0;
+		if (if_out_freq <  35250) {
+			cfg_0 = 0xFE;
+			cfg_1 = 0x18;
+			pwr = 0xF1;
+		} else {
+			cfg_0 = 0xD9;
+			cfg_1 = 0x16;
+			pwr = 0xB1;
+		}
+		switch(state->config->if_out_gain_level)
+		{
+			case 0x09: dfe = 0x44; break;
+			case 0x08: dfe = 0x43; break;
+			case 0x07: dfe = 0x42; break;
+			case 0x06: dfe = 0x41; break;
+			case 0x05: dfe = 0x40; break;
+			default: break;
+		}
+		break;
+	default:
+			return -EINVAL;
+	}
+
+	ret = mxl603_write_regs(state, reg_table);
+	if (ret)
+		goto err;
+
+	ret = mxl603_write_reg(state, 0x5A, cfg_0);
+	if (ret)
+		goto err;
+
+	ret = mxl603_write_reg(state, 0x5B, cfg_1);
+	if (ret)
+		goto err;
+
+	if (pwr) {
+		ret = mxl603_write_reg(state, 0x5C, pwr);
+		if (ret)
+			goto err;
+	}
+
+	ret = mxl603_write_reg(state, 0xEA,
+				state->config->xtal_freq_hz ? 0x0E : 0x0D);
+	if (ret)
+		goto err;
+
+	if (dfe != 0xFF) {
+		ret = mxl603_write_reg(state, 0xDC, dfe);
+		if (ret)
+			goto err;
+	}
+
+	ret = mxl603_write_reg(state, 0x03, 0x00);
+	if (ret)
+		goto err;
+
+	ret = mxl603_write_reg(state, 0x03, 0x01);
+	if (ret)
+		goto err;
+
+	msleep(50);
+	
+	return 0;
+	
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+
+static int mxl603_set_agc(struct mxl603_state *state)
+{
+	u8 d = 0;
+	int ret;
+
+	ret = mxl603_read_reg(state, 0x08, &d);
+	if (ret)
+		goto err;
+
+	d &= 0xF2;
+	d = (u8) (d | (state->config->agc_type << 2) | 0x01);
+	ret = mxl603_write_reg(state, 0x08, d);
+	if (ret)
+		goto err;
+
+	ret = mxl603_read_reg(state, 0x09, &d);
+	if (ret)
+		goto err;
+
+	d &= 0x80;
+	d |= (u8)(state->config->agc_set_point & 0xff);	
+	ret = mxl603_write_reg(state, 0x09, d);
+	if (ret)
+		goto err;
+
+	ret = mxl603_read_reg(state, 0x5E, &d);
+	if (ret)
+		goto err;
+
+	d &= 0xEF;
+	d |= (state->config->agc_invert_pol << 4);
+	ret = mxl603_write_reg(state, 0x5E, d);
+	if (ret)
+		goto err;
+
+	return 0;
+	
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int mxl603_set_if_out(struct mxl603_state *state)
+{
+	u8 d = 0;
+	int ret;
+
+	ret = mxl603_read_reg(state, 0x04, &d);
+	if (ret)
+		goto err;
+
+	d |= state->config->if_freq_hz;
+
+	ret = mxl603_write_reg(state, 0x04, d);
+	if (ret)
+		goto err;
+
+	d = 0;
+	if (state->config->invert_if)
+		d = 0x3 << 6;
+
+	d += (state->config->gain_level & 0x0F);	
+	d |= 0x20;
+	ret = mxl603_write_reg(state, 0x05, d);
+	if (ret)
+		goto err;
+
+	return 0;
+	
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int mxl603_set_xtal(struct mxl603_state *state)
+{
+	u8 d = 0;
+	int ret;
+
+	d = (u8)((state->config->xtal_freq_hz << 5)
+			| (state->config->xtal_cap & 0x1F));
+	d |= (state->config->clk_out_enable << 7);
+
+	ret = mxl603_write_reg(state, 0x01, d);
+	if (ret)
+		goto err;
+
+	d = (0x01 & (u8)state->config->clk_out_div);
+
+	if (state->config->xtal_sharing_mode) {
+		d |= 0x40;
+
+		ret = mxl603_write_reg(state, 0x02, d);
+		if (ret)
+			goto err;
+		ret = mxl603_write_reg(state, 0x6D, 0x80);
+		if (ret)
+			goto err;
+	} else {
+		d &= 0x01;
+		ret = mxl603_write_reg(state, 0x02, d);
+		if (ret)
+			goto err;
+		ret = mxl603_write_reg(state, 0x6D, 0x0A);
+		if (ret)
+			goto err;
+	}
+
+	if (state->config->single_supply_3_3V) {
+		ret = mxl603_write_reg(state, 0x0E, 0x14);
+		if (ret)
+			goto err;
+	}
+
+	return 0;
+	
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int mxl603_tuner_init_default(struct mxl603_state *state)
+{
+	u8 d = 0;
+	int ret;
+	
+	ret = mxl603_write_reg(state, 0xFF, 0x00);
+	if (ret)
+		goto err;
+
+	ret = mxl603_write_regs(state, MxL603_DigitalDvbc);
+	if (ret)
+		goto err;
+
+	ret = mxl603_write_reg(state, 0x00, 0x01);
+	if (ret)
+		goto err;
+
+	ret = mxl603_read_reg(state, 0x31, &d);
+	if (ret)
+		goto err;
+
+	d &= 0x2F;
+	d |= 0xD0;
+
+	ret = mxl603_write_reg(state, 0x31, d);
+	if (ret)
+		goto err;
+
+	ret = mxl603_write_reg(state, 0x00, 0x00);
+	if (ret)
+		goto err;
+
+	if (state->config->single_supply_3_3V) {
+		ret = mxl603_write_reg(state, 0x0E, 0x04);
+		if (ret)
+			goto err;
+	}
+
+	mdelay(1);
+	
+	return 0;
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+
+static int mxl603_synth_lock_status(struct mxl603_state *state,
+				      int *rf_locked, int *ref_locked)
+{
+	u8 d = 0;
+	int ret;
+
+	*rf_locked = 0;
+	*ref_locked = 0;
+
+	ret = mxl603_read_reg(state, 0x2B, &d);
+	if (ret)
+		goto err;
+
+	if ((d & 0x02) == 0x02)
+		*rf_locked = 1;
+
+	if ((d & 0x01) == 0x01)
+		*ref_locked = 1;
+	
+	return 0;
+	
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int mxl603_get_status(struct dvb_frontend *fe, u32 *status)
+{
+	struct mxl603_state *state = fe->tuner_priv;
+	int rf_locked, ref_locked, ret;
+
+	*status = 0;
+
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 1);
+
+	ret = mxl603_synth_lock_status(state, &rf_locked, &ref_locked);
+	if (ret)
+		goto err;
+
+	dev_dbg(&state->i2c->dev, "%s%s", rf_locked ? "rf locked " : "",
+			ref_locked ? "ref locked" : "");
+
+	if ((rf_locked) || (ref_locked))
+		*status |= TUNER_STATUS_LOCKED;
+
+		
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 0);
+
+	return 0;
+	
+err:
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 0);
+		
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int mxl603_set_params(struct dvb_frontend *fe)
+{	
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	struct mxl603_state *state = fe->tuner_priv;	
+	struct freq_table *ftable;
+	enum mxl603_bw_mhz bw;
+	enum mxl603_mode mode;
+	int ret;
+	u32 freq = c->frequency;
+	
+	dev_dbg(&state->i2c->dev, 
+		"%s: delivery_system=%d frequency=%d bandwidth_hz=%d\n", 
+		__func__, c->delivery_system, c->frequency, c->bandwidth_hz);		
+			
+
+	switch (c->delivery_system) {
+	case SYS_ATSC:
+		mode = MxL603_MODE_ISDBT_ATSC;
+		bw = MxL603_TERR_BW_6MHz;
+		ftable = MxL603_Digital;
+		break;
+	case SYS_DVBC_ANNEX_A:
+		mode = MxL603_MODE_CABLE;
+		ftable = MxL603_Cable;
+		bw = MxL603_CABLE_BW_8MHz;	
+		break;
+	case SYS_DVBT:
+	case SYS_DVBT2:
+		mode = MxL603_MODE_DVBT;
+		ftable = MxL603_Digital;
+		switch (c->bandwidth_hz) {
+		case 6000000:
+			bw = MxL603_TERR_BW_6MHz;
+			break;
+		case 7000000:
+			bw = MxL603_TERR_BW_7MHz;
+			break;
+		case 8000000:
+			bw = MxL603_TERR_BW_8MHz;
+			break;
+		default:
+			return -EINVAL;
+		}
+		break;
+	default:
+		 dev_dbg(&state->i2c->dev, "%s: err state=%d\n", 
+			__func__, fe->dtv_property_cache.delivery_system);
+		return -EINVAL;
+	}
+
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 1);
+	
+	ret = mxl603_tuner_init_default(state);
+	if (ret)
+		goto err;
+
+	ret = mxl603_set_xtal(state);
+	if (ret)
+		goto err;
+
+	ret = mxl603_set_if_out(state);
+	if (ret)
+		goto err;
+
+	ret = mxl603_set_agc(state);
+	if (ret)
+		goto err;
+
+	ret = mxl603_set_mode(fe, state, mode);
+	if (ret)
+		goto err;
+		
+	ret = mxl603_set_freq(state, freq, mode, bw, ftable);
+	if (ret)
+		goto err;
+
+	state->frequency = freq;
+	state->bandwidth = c->bandwidth_hz;
+
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 0);
+		
+	msleep(15);
+		
+	return 0;
+	
+err:
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 0);
+		
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+
+static int mxl603_get_frequency(struct dvb_frontend *fe, u32 *frequency)
+{
+	struct mxl603_state *state = fe->tuner_priv;
+	*frequency = state->frequency;
+	return 0;
+}
+
+static int mxl603_get_bandwidth(struct dvb_frontend *fe, u32 *bandwidth)
+{
+	struct mxl603_state *state = fe->tuner_priv;
+	*bandwidth = state->bandwidth;
+	return 0;
+}
+
+static int mxl603_init(struct dvb_frontend *fe)
+{
+	struct mxl603_state *state = fe->tuner_priv;
+	int ret;
+
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 1);
+
+	/* wake from standby */
+	ret = mxl603_write_reg(state, 0x0B, 0x01);
+	if (ret)
+		goto err;
+	ret = mxl603_write_reg(state, 0x12, 0x01);
+	if (ret)
+		goto err;
+	ret = mxl603_write_reg(state, 0x00, 0x01);
+	if (ret)
+		goto err;
+
+	if (state->config->loop_thru_enable)
+		ret = mxl603_write_reg(state, 0x60, 0x0E);
+	else
+		ret = mxl603_write_reg(state, 0x60, 0x37);
+	if (ret)
+		goto err;
+
+	ret = mxl603_write_reg(state, 0x00, 0x00);
+	if (ret)
+		goto err;
+		
+	return 0;
+	
+err:
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 0);
+		
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+
+static int mxl603_sleep(struct dvb_frontend *fe)
+{
+	struct mxl603_state *state = fe->tuner_priv;
+	int ret;
+
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 1);
+
+	/* enter standby mode */
+	ret = mxl603_write_reg(state, 0x12, 0x00);
+	if (ret)
+		goto err;
+		
+	ret = mxl603_write_reg(state, 0x0B, 0x00);
+	if (ret)
+		goto err;
+		
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 0);
+
+	return 0;
+	
+err:
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 0);
+		
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+
+static int mxl603_release(struct dvb_frontend *fe)
+{
+	struct mxl603_state *state = fe->tuner_priv;
+
+	fe->tuner_priv = NULL;
+	kfree(state);
+	
+	return 0;
+}
+static struct dvb_tuner_ops mxl603_tuner_ops = {
+	.info = {
+		.name = "MaxLinear MxL603",
+		.frequency_min = 1000000,
+		.frequency_max = 1200000000,
+		.frequency_step = 25000,
+	},
+	.init              = mxl603_init,
+	.sleep             = mxl603_sleep,
+	.set_params        = mxl603_set_params,
+	.get_status        = mxl603_get_status,
+	.get_frequency     = mxl603_get_frequency,
+	.get_bandwidth     = mxl603_get_bandwidth,
+	.release           = mxl603_release,
+	.get_if_frequency  = mxl603_get_if_frequency,
+};
+static int mxl603_get_chip_id(struct mxl603_state *state)
+{
+	int ret;
+	u8 id;
+
+	ret = mxl603_read_reg(state, 0x18, &id);
+	if (ret)
+		goto err;
+
+	if (id != 0x02) {
+		ret = -ENODEV;
+		goto err;
+	}
+
+	dev_info(&state->i2c->dev, "MxL603 detected id(%02x)\n"
+			, id);
+			
+	return ret;
+
+err:
+	dev_warn(&state->i2c->dev, "MxL603 unable to identify device(%02x)\n"
+			, id);
+	return ret;
+}
+struct dvb_frontend *mxl603_attach(struct dvb_frontend *fe,
+				     struct i2c_adapter *i2c, u8 addr,
+				     struct mxl603_config *config)
+{
+	struct mxl603_state *state = NULL;
+	int ret = 0;
+
+	state = kzalloc(sizeof(struct mxl603_state), GFP_KERNEL);
+	if (!state) {
+		ret = -ENOMEM;
+		dev_err(&i2c->dev, "kzalloc() failed\n");
+		goto err1;
+	}
+	
+	state->config = config;
+	state->i2c = i2c;
+	state->addr = addr;
+	
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 1);
+
+	ret = mxl603_get_chip_id(state);
+
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 0);
+
+	/* check return value of mxl603_get_chip_id */
+	if (ret)
+		goto err2;
+	
+	dev_info(&i2c->dev, "Attaching MxL603\n");
+	
+	fe->tuner_priv = state;
+
+	memcpy(&fe->ops.tuner_ops, &mxl603_tuner_ops,
+	       sizeof(struct dvb_tuner_ops));
+
+	return fe;
+	
+err2:
+	kfree(state);
+err1:
+	return NULL;
+}
+EXPORT_SYMBOL(mxl603_attach);
+
+MODULE_DESCRIPTION("MaxLinear MxL603 tuner driver");
+MODULE_AUTHOR("Sasa Savic <sasa.savic.sr@gmail.com>");
+MODULE_LICENSE("GPL");
diff --git a/drivers/amlogic/dvb_tv/mxl603.h b/drivers/amlogic/dvb_tv/mxl603.h
new file mode 100644
index 000000000000..8560a41e6d4f
--- /dev/null
+++ b/drivers/amlogic/dvb_tv/mxl603.h
@@ -0,0 +1,83 @@
+/*
+ * Driver for the MaxLinear MxL603 tuner
+ *
+ * Copyright (C) 2014 Sasa Savic <sasa.savic.sr@gmail.com>
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License along
+ *    with this program; if not, write to the Free Software Foundation, Inc.,
+ *    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+ 
+#ifndef __MXL603_H__
+#define __MXL603_H__
+
+#include <linux/dvb/version.h>
+#include "dvb_frontend.h"
+
+enum mxl603_if_freq {
+	MXL603_IF_3_65MHz,
+	MXL603_IF_4MHz,
+	MXL603_IF_4_1MHz,
+	MXL603_IF_4_15MHz,
+	MXL603_IF_4_5MHz, 
+	MXL603_IF_4_57MHz,
+	MXL603_IF_5MHz,
+	MXL603_IF_5_38MHz, 
+	MXL603_IF_6MHz,
+	MXL603_IF_6_28MHz,
+	MXL603_IF_7_2MHz, 
+	MXL603_IF_8_25MHz,
+	MXL603_IF_35_25MHz,
+	MXL603_IF_36MHz, 
+	MXL603_IF_36_15MHz, 
+	MXL603_IF_36_65MHz,
+	MXL603_IF_44MHz,
+};
+
+enum mxl603_xtal_freq {
+	MXL603_XTAL_16MHz,
+	MXL603_XTAL_24MHz,
+};
+
+enum mxl603_agc {
+	MXL603_AGC_SELF,   
+	MXL603_AGC_EXTERNAL,
+};
+
+struct mxl603_config {
+	enum mxl603_xtal_freq xtal_freq_hz;
+	enum mxl603_if_freq if_freq_hz;
+	enum mxl603_agc agc_type;
+	
+	u8 xtal_cap;
+	u8 gain_level;
+	u8 if_out_gain_level;
+	u8 agc_set_point;
+	
+	u8 agc_invert_pol;
+	u8 invert_if;
+	u8 loop_thru_enable;
+	u8 clk_out_enable;
+	u8 clk_out_div;
+	u8 clk_out_ext;
+	u8 xtal_sharing_mode;
+	u8 single_supply_3_3V;
+};
+
+
+
+extern struct dvb_frontend *mxl603_attach(struct dvb_frontend *fe,
+					    struct i2c_adapter *i2c, u8 addr,
+					    struct mxl603_config *cfg);
+
+#endif /* __MXL603_H__ */
diff --git a/drivers/amlogic/dvb_tv/nimdetect.c b/drivers/amlogic/dvb_tv/nimdetect.c
new file mode 100644
index 000000000000..7f7815e0524a
--- /dev/null
+++ b/drivers/amlogic/dvb_tv/nimdetect.c
@@ -0,0 +1,534 @@
+/*
+ * Wetek NIMs/DVB detection
+ *
+ * Copyright (C) 2014 Sasa Savic <sasa.savic.sr@gmail.com>
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License along
+ *    with this program; if not, write to the Free Software Foundation, Inc.,
+ *    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+
+#ifndef CONFIG_ARM64
+#include <mach/am_regs.h>
+#else
+#include <linux/reset.h>
+#endif
+#include <linux/amlogic/aml_gpio_consumer.h>
+#include <linux/usb.h>
+#include "nimdetect.h"
+
+#include "ascot3.h"
+#include "cxd2841er.h"
+#include "mxl603.h"
+#include "avl6211.h"
+#include "mn88436.h"
+
+#ifdef CONFIG_ARM64
+static struct reset_control *dvb_demux_reset_ctl;
+static struct reset_control *dvb_afifo_reset_ctl;
+static struct reset_control *dvb_ahbarb0_reset_ctl;
+static struct reset_control *dvb_uparsertop_reset_ctl;
+#define TOTAL_I2C		 	1
+#define TOTAL_DEMODS 		1
+#else
+#define TOTAL_I2C		 	2
+#define TOTAL_DEMODS 		2
+#endif
+#define TOTAL_AML_INPUTS 	3
+
+
+static struct wetek_nims weteknims;
+
+static struct cxd2841er_config cxd2837cfg = {
+		.i2c_addr = 0x6C,
+		.if_agc = 0,
+		.ifagc_adc_range = 0x39,
+		.ts_error_polarity = 0,
+		.clock_polarity = 1,
+		.mxl603	= 0,
+		.xtal = SONY_XTAL_20500,
+};
+struct ascot3_config ascot3cfg = {
+		.i2c_address = 0x60,
+};
+static struct mxl603_config mxl603cfg = {
+		.xtal_freq_hz = MXL603_XTAL_24MHz,
+		.if_freq_hz = MXL603_IF_5MHz,
+		.agc_type = MXL603_AGC_SELF,
+		.xtal_cap = 16,
+		.gain_level = 11,
+		.if_out_gain_level = 11,
+		.agc_set_point = 66,
+		.agc_invert_pol = 0,
+		.invert_if = 1,
+		.loop_thru_enable = 0,
+		.clk_out_enable = 1,
+		.clk_out_div = 0,
+		.clk_out_ext = 0,
+		.xtal_sharing_mode = 0,
+		.single_supply_3_3V = 1,
+};
+static struct mxl603_config mxl603cfg_atsc = {
+		.xtal_freq_hz = MXL603_XTAL_24MHz,
+		.if_freq_hz = MXL603_IF_5MHz,
+		.agc_type = MXL603_AGC_EXTERNAL,
+		.xtal_cap = 31,
+		.gain_level = 11,
+		.if_out_gain_level = 11,
+		.agc_set_point = 66,
+		.agc_invert_pol = 0,
+		.invert_if = 0,
+		.loop_thru_enable = 0,
+		.clk_out_enable = 1,
+		.clk_out_div = 0,
+		.clk_out_ext = 0,
+		.xtal_sharing_mode = 0,
+		.single_supply_3_3V = 1,
+};
+static struct avl6211_config avl6211cfg[] = {
+	{
+#ifndef CONFIG_ARM64
+		.tuner_address = 0xC2,
+#else		
+		.tuner_address = 0xC4,
+#endif
+		.tuner_i2c_clock = 200,	
+		.demod_address = 0x0C,
+		.mpeg_pol = 1,
+		.mpeg_mode = 0,
+		.mpeg_format = 0,
+		.demod_refclk = 9,
+		.mpeg_pin = 0,
+		.tuner_rfagc = 1,
+		.tuner_spectrum = 0,
+		.use_lnb_pin59 = 1,
+		.use_lnb_pin60 = 0,
+		.set_external_vol_gpio = set_external_vol_gpio,
+	},
+	{
+		.tuner_address = 0xC2,
+		.tuner_i2c_clock = 200,		
+		.demod_address = 0x0C,
+		.mpeg_pol = 1,
+		.mpeg_mode = 0,
+		.mpeg_format = 0,
+		.demod_refclk = 9,
+		.mpeg_pin = 0,
+		.tuner_rfagc = 1,
+		.tuner_spectrum = 0,
+		.use_lnb_pin59 = 1,
+		.use_lnb_pin60 = 0,
+		.set_external_vol_gpio = set_external_vol_gpio,
+	}
+};
+#ifndef CONFIG_ARM64
+extern struct list_head usb_bus_list;
+extern struct mutex usb_bus_list_lock;
+extern struct usb_device *usb_hub_find_child(struct usb_device *hdev, int port1);
+extern struct usb_device *usb_get_dev(struct usb_device *dev);
+extern int usb_control_msg(struct usb_device *dev, unsigned int pipe, __u8 request,
+                     __u8 requesttype, __u16 value, __u16 index, void *data,
+                     __u16 size, int timeout);
+extern const unsigned long cpu_bit_bitmap[BITS_PER_LONG+1][BITS_TO_LONGS(NR_CPUS)];
+extern int __irq_set_affinity(unsigned int irq, const struct cpumask *mask, bool force);
+
+EXPORT_SYMBOL(usb_bus_list);
+EXPORT_SYMBOL(usb_bus_list_lock);
+EXPORT_SYMBOL(usb_hub_find_child);
+EXPORT_SYMBOL(usb_get_dev);
+EXPORT_SYMBOL(usb_control_msg);
+EXPORT_SYMBOL(__irq_set_affinity);
+#endif
+
+
+int kc_class_register(struct class *cls)
+{
+	return class_register(cls);
+}
+EXPORT_SYMBOL(kc_class_register);
+void kc_class_unregister(struct class *cls)
+{
+	class_unregister(cls);
+}
+EXPORT_SYMBOL(kc_class_unregister);
+const struct cpumask *aml_get_cpu_mask(unsigned int cpu)
+{
+	const unsigned long *p = cpu_bit_bitmap[1 + cpu % BITS_PER_LONG];
+	p -= cpu / BITS_PER_LONG;
+	return to_cpumask(p);
+}
+EXPORT_SYMBOL(aml_get_cpu_mask);
+
+void get_nims_infos(struct wetek_nims *p)
+{
+	memcpy(p, &weteknims, sizeof(struct wetek_nims));
+}
+EXPORT_SYMBOL(get_nims_infos);
+int set_external_vol_gpio(int *demod_id, int on)
+{
+	if (on) {
+		if (*demod_id == 0 )
+#ifdef CONFIG_ARM64
+			gpio_direction_output(weteknims.power_ctrl, 1);
+#else		
+			amlogic_gpio_direction_output(GPIOAO_8, 1, "nimdetect");		
+#endif	
+#ifndef CONFIG_ARM64		
+        else if (*demod_id == 1)
+			amlogic_gpio_direction_output(GPIOAO_9, 1, "nimdetect");
+#endif			
+	} else if (!on) {
+		if (*demod_id == 0 )
+#ifdef CONFIG_ARM64
+			gpio_direction_output(weteknims.power_ctrl, 0);
+#else		
+			amlogic_gpio_direction_output(GPIOAO_8, 0, "nimdetect");		
+#endif
+#ifndef CONFIG_ARM64
+        else if (*demod_id == 1)		
+			amlogic_gpio_direction_output(GPIOAO_9, 0, "nimdetect");
+#endif			
+    }
+	return 0;
+}
+#ifndef CONFIG_ARM64
+static void nim_dvb_pinctrl_put(struct wetek_nims *p)
+{
+	if (p->ts[0].pinctrl) {
+		devm_pinctrl_put(p->ts[0].pinctrl);
+		p->ts[0].pinctrl = NULL;
+	}
+}
+static struct pinctrl * __must_check nim_dvb_pinctrl_get_select(
+		struct device *dev, struct wetek_nims *p, const char *name)
+{
+	/*all dvb pinctrls share the ts[0]'s pinctrl.*/
+	struct pinctrl *pctl = p->ts[0].pinctrl;
+	
+	struct pinctrl_state *s;
+	int ret;
+
+	if (!pctl) {
+		pctl = devm_pinctrl_get(dev);
+		if (IS_ERR(pctl))
+			return pctl;
+			
+		p->ts[0].pinctrl = pctl;
+	}
+
+	s = pinctrl_lookup_state(pctl, name);
+	if (IS_ERR(s)) {
+		devm_pinctrl_put(pctl);
+		return ERR_CAST(s);
+	}
+
+	ret = pinctrl_select_state(pctl, s);
+	if (ret < 0) {
+		devm_pinctrl_put(pctl);
+		return ERR_PTR(ret);
+	}
+
+	return pctl;
+}
+#endif
+
+void reset_demod(void)
+{
+#ifdef CONFIG_ARM64
+	gpio_direction_output(weteknims.fec_reset, 0);
+	msleep(600);
+	gpio_direction_output(weteknims.fec_reset, 1);
+	msleep(200);
+#else
+	amlogic_gpio_direction_output(GPIOD_8, 0, "nimdetect");
+	msleep(600);
+	amlogic_gpio_direction_output(GPIOD_8, 1, "nimdetect");
+	msleep(200);
+#endif
+
+}
+static int nim_dvb_probe(struct platform_device *pdev)
+{
+	int i;
+	int ret = 0;
+#ifdef CONFIG_ARM64
+    struct gpio_desc *desc;
+#endif	 
+	weteknims.pdev = pdev;
+	weteknims.dev  = &pdev->dev;
+
+#ifdef CONFIG_ARM64
+	for (i = 0; i < TOTAL_I2C; i++) {
+	
+		weteknims.i2c[i] = i2c_get_adapter(1); //tuner1 on I2C_D
+			
+		if (weteknims.i2c[i] != NULL)
+			dev_info(&pdev->dev, "Found Wetek i2c-1 adapter ...\n");
+		else {
+			dev_info(&pdev->dev, "Failed to acquire Wetek i2c-1 adapter ...\n");	
+			return 0;
+		}	
+	}
+#else
+	/* tuner0 on I2C_A
+	   tuner1 on I2C_B
+	*/
+	for (i = 0; i < TOTAL_I2C; i++) {
+		weteknims.i2c[i] = i2c_get_adapter(i + 1);
+		if (weteknims.i2c[i] != NULL)
+			dev_info(&pdev->dev, "Found Wetek i2c-%d adapter ...\n", i + 1);
+		else {
+			dev_info(&pdev->dev, "Failed to acquire Wetek i2c-%d adapter ...\n", i + 1);	
+			return 0;
+		}	
+	}
+#endif	
+	if (pdev->dev.of_node) {
+		for (i = 0; i <  TOTAL_AML_INPUTS; i++) {
+			char buf[32];
+			const char *str;
+
+			snprintf(buf, sizeof(buf), "ts%d", i);
+			ret = of_property_read_string(pdev->dev.of_node, buf, &str);
+			if (!ret) {
+				if (!strcmp(str, "parallel")) {
+					dev_info(&pdev->dev, "%s: parallel\n", buf);
+					snprintf(buf, sizeof(buf), "p_ts%d", i);
+					weteknims.ts[i].mode    = 1;
+#ifdef CONFIG_ARM64					
+					weteknims.ts[i].pinctrl = devm_pinctrl_get_select(&pdev->dev, buf);
+#else					
+					weteknims.ts[i].pinctrl = nim_dvb_pinctrl_get_select(&pdev->dev, &weteknims, buf);
+#endif					
+				}
+			}
+		}
+	}
+#ifdef CONFIG_ARM64
+
+	dvb_demux_reset_ctl = devm_reset_control_get(&pdev->dev, "demux");
+	dev_info(&pdev->dev, "dmx rst ctl = %p\n", dvb_demux_reset_ctl);
+	reset_control_deassert(dvb_demux_reset_ctl);
+
+	dvb_afifo_reset_ctl = devm_reset_control_get(&pdev->dev, "asyncfifo");
+	dev_info(&pdev->dev, "asyncfifo rst ctl = %p\n", dvb_afifo_reset_ctl);
+	reset_control_deassert(dvb_afifo_reset_ctl);
+	
+	dvb_ahbarb0_reset_ctl = devm_reset_control_get(&pdev->dev, "ahbarb0");
+	dev_info(&pdev->dev, "ahbarb0 rst ctl = %p\n", dvb_ahbarb0_reset_ctl);
+	reset_control_deassert(dvb_ahbarb0_reset_ctl);
+	
+	dvb_uparsertop_reset_ctl = devm_reset_control_get(&pdev->dev, "uparsertop");
+	dev_info(&pdev->dev, "uparsertop rst ctl = %p\n", dvb_uparsertop_reset_ctl);
+	reset_control_deassert(dvb_uparsertop_reset_ctl);
+	
+	desc = of_get_named_gpiod_flags(pdev->dev.of_node, "fec_reset_gpio-gpios", 0, NULL);
+    weteknims.fec_reset = desc_to_gpio(desc);
+	 
+	desc = of_get_named_gpiod_flags(pdev->dev.of_node, "power_ctrl_gpio-gpios", 0, NULL);
+    weteknims.power_ctrl = desc_to_gpio(desc);
+	/* FEC_RESET  GPIOY 13*/
+	gpio_request(weteknims.fec_reset, "nimdetect"); 
+	
+	/* INPUT1 POWER CTRL GPIOY 15*/
+	gpio_request(weteknims.power_ctrl, "nimdetect"); 
+	
+	
+	/* RESET DEMOD(s) */
+	reset_demod();
+#else
+	/* FEC_RESET */
+	amlogic_gpio_request(GPIOD_8, "nimdetect"); 
+	
+	/* INPUT1 POWER CTRL */
+	amlogic_gpio_request(GPIOAO_8, "nimdetect");
+	
+	/* INPUT2 POWER CTRL */
+	amlogic_gpio_request(GPIOAO_9, "nimdetect");
+
+	amlogic_gpio_direction_output(GPIOAO_8, 0, "nimdetect"); //SWITCH OFF INPUT1 POWER		
+	amlogic_gpio_direction_output(GPIOAO_9, 0, "nimdetect"); //SWITCH OFF INPUT2 POWER		
+
+	/* RESET DEMOD(s) */
+	reset_demod();
+#endif
+
+	dev_info(&pdev->dev, "Wetek NIM(s) detection in progress ...\n");
+
+	for (i = 0; i < TOTAL_DEMODS; i++) {		
+		
+		dev_info(&pdev->dev, "Checking for Sony CXD2837 DVB-C/T/T2 demod ...\n");	
+			
+		weteknims.fe[i] =  cxd2841er_attach_t_c(&cxd2837cfg, weteknims.i2c[i]);		
+		
+		if (weteknims.fe[i] != NULL) {																		
+			if (mxl603_attach(weteknims.fe[i], weteknims.i2c[i], 0x60, &mxl603cfg) == NULL) {
+				dev_info(&pdev->dev, "Failed to find MxL603 tuner!\n");
+				cxd2837cfg.if_agc = 1;
+				cxd2837cfg.ifagc_adc_range = 0x50;
+				if (ascot3_attach(weteknims.fe[i], &ascot3cfg, weteknims.i2c[i]) == NULL) {
+					dev_info(&pdev->dev, "Failed to find Sony ASCOT3 tuner!\n");
+					dvb_frontend_detach(weteknims.fe[i]);
+					goto panasonic;
+				}
+			} else 
+				cxd2837cfg.mxl603 = 1;
+				
+			weteknims.total_nims++;
+			dev_info(&pdev->dev, "Total Wetek NIM(s) found: %d\n", weteknims.total_nims);
+			return 0;
+		}
+panasonic:			
+		reset_demod();
+		dev_info(&pdev->dev, "Checking for Panasonic MN88436 ATSC demod ...\n");	
+			
+		weteknims.fe[i] =  mn88436_attach(weteknims.i2c[i], 0);				
+			
+		if (weteknims.fe[i] != NULL) {			
+												
+			if (mxl603_attach(weteknims.fe[i], weteknims.i2c[i], 0x60, &mxl603cfg_atsc) == NULL) {
+				dev_info(&pdev->dev, "Failed to find MxL603 tuner!\n");
+				dev_info(&pdev->dev, "Detaching Panasonic MN88436 ATSC frontend!\n");
+				dvb_frontend_detach(weteknims.fe[i]);
+				goto avl6211;
+			}
+				
+			weteknims.total_nims++;
+			dev_info(&pdev->dev, "Total Wetek NIM(s) found: %d\n", weteknims.total_nims);
+			return 0;
+		}
+avl6211:		
+		reset_demod();
+		dev_info(&pdev->dev, "Checking for AVL6211 DVB-S/S2 demod ...\n");
+		weteknims.fe[i] = avl6211_attach( weteknims.i2c[i], &avl6211cfg[i], i);
+		if (i == 0 && weteknims.fe[i] == NULL) {
+			dev_info(&pdev->dev, "No available NIM(s) found ...\n");
+			return 0;			
+		}
+		if (weteknims.fe[i] != NULL)
+			weteknims.total_nims++;		
+	}
+	
+	if (weteknims.total_nims > 0)
+		dev_info(&pdev->dev, "Total Wetek NIM(s) found: %d\n", weteknims.total_nims);
+	
+	return 0;
+}
+static int nim_dvb_remove(struct platform_device *pdev)
+{
+	int i;
+	
+	for (i = 0; i < TOTAL_DEMODS; i++) {
+		if (weteknims.fe[i] != NULL) 
+			dvb_frontend_detach(weteknims.fe[i]);
+	}
+
+	for (i = 0; i < TOTAL_I2C; i++) {
+		if (weteknims.i2c[i] != NULL)
+			i2c_put_adapter(weteknims.i2c[i]);
+	}
+#ifdef CONFIG_ARM64
+	gpio_free(weteknims.fec_reset);
+	gpio_free(weteknims.power_ctrl);
+#else
+	amlogic_gpio_free(GPIOD_8, "nimdetect");
+	amlogic_gpio_free(GPIOAO_8, "nimdetect");
+	amlogic_gpio_free(GPIOAO_9, "nimdetect");
+#endif	
+#ifdef CONFIG_ARM64
+	devm_pinctrl_put(weteknims.ts[0].pinctrl);
+	reset_control_assert(dvb_uparsertop_reset_ctl);
+	reset_control_assert(dvb_ahbarb0_reset_ctl);
+	reset_control_assert(dvb_afifo_reset_ctl);
+	reset_control_assert(dvb_demux_reset_ctl);
+#else	
+	nim_dvb_pinctrl_put(&weteknims);
+#endif	
+	return 0;
+}
+#ifndef CONFIG_ARM64
+static int wetekcard_probe(struct platform_device *pdev)
+{
+	if (pdev->dev.of_node)
+		weteknims.card_pinctrl = devm_pinctrl_get_select_default(&pdev->dev);
+
+	return 0;
+}
+static int wetekcard_remove(struct platform_device *pdev)
+{
+	if(weteknims.card_pinctrl)
+		devm_pinctrl_put(weteknims.card_pinctrl);
+	return 0;
+}
+#endif
+static const struct of_device_id nim_dvb_dt_match[] = {
+	{
+		.compatible = "amlogic,dvb",
+	},
+	{},
+};
+static struct platform_driver nim_dvb_detection = {
+	.probe		= nim_dvb_probe,
+	.remove		= nim_dvb_remove,
+	.driver		= {
+		.name	= "wetek-dvb",
+		.owner	= THIS_MODULE,
+		.of_match_table = nim_dvb_dt_match,
+	}
+};
+#ifndef CONFIG_ARM64
+static const struct of_device_id wetekcard_dt_match[]={
+	{	.compatible = "amlogic,smartcard",
+	},
+	{},
+};
+
+static struct platform_driver wetekcard_driver = {
+	.probe		= wetekcard_probe,
+    .remove		= wetekcard_remove,
+	.driver		= {
+		.name	= "wetek-card",
+		.owner	= THIS_MODULE,
+		.of_match_table = wetekcard_dt_match,
+	}
+};
+#endif
+
+int __init nim_dvb_init(void)
+{
+	int ret;
+	
+	memset(&weteknims, 0, sizeof(struct wetek_nims));
+	
+	ret = platform_driver_register(&nim_dvb_detection);
+#ifndef CONFIG_ARM64	
+	if (!ret)
+		return platform_driver_register(&wetekcard_driver);
+#endif		
+	return ret;
+}
+void __exit nim_dvb_exit(void)
+{
+	platform_driver_unregister(&nim_dvb_detection);
+#ifndef CONFIG_ARM64
+	platform_driver_unregister(&wetekcard_driver);
+#endif	
+}
+
+module_init(nim_dvb_init);
+module_exit(nim_dvb_exit);
+
+MODULE_DESCRIPTION("Wetek NIMs DVB detection");
+MODULE_AUTHOR("Sasa Savic <sasa.savic.sr@gmail.com>");
+MODULE_LICENSE("GPL");
diff --git a/drivers/amlogic/dvb_tv/nimdetect.h b/drivers/amlogic/dvb_tv/nimdetect.h
new file mode 100644
index 000000000000..ea38c8257373
--- /dev/null
+++ b/drivers/amlogic/dvb_tv/nimdetect.h
@@ -0,0 +1,54 @@
+/*
+ * Wetek NIM tuner(s) detection
+ *
+ * Copyright (C) 2014 Sasa Savic <sasa.savic.sr@gmail.com>
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License along
+ *    with this program; if not, write to the Free Software Foundation, Inc.,
+ *    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+ 
+#ifndef __NIMDETECT_H
+#define __NIMDETECT_H
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/dvb/version.h>
+#include <linux/platform_device.h>
+#include "dvb_frontend.h"
+
+struct ts_input {
+	int                  mode;
+	struct pinctrl      *pinctrl;
+	int                  control;
+};
+
+struct wetek_nims {
+	struct dvb_frontend 	*fe[2];
+	struct i2c_adapter 		*i2c[2];	
+	struct ts_input	   		ts[3];
+	struct device       	*dev;
+	struct platform_device  *pdev;
+	struct pinctrl      	*card_pinctrl;
+	u32 total_nims;
+#ifdef CONFIG_ARM64
+	int fec_reset;
+	int power_ctrl;
+#endif
+};
+
+void get_nims_infos(struct wetek_nims *p);
+int set_external_vol_gpio(int *demod_id, int on);
+
+#endif /* __NIMDETECT_H */
diff --git a/drivers/amlogic/dvb_tv/smartcard/Kconfig b/drivers/amlogic/dvb_tv/smartcard/Kconfig
deleted file mode 100644
index 3cb4880eaa3e..000000000000
--- a/drivers/amlogic/dvb_tv/smartcard/Kconfig
+++ /dev/null
@@ -1,7 +0,0 @@
-#
-#Smart card driver configuration
-#
-
-config AML_SMARTCARD
-	bool "Amlogic Smartcard driver"
-	default n
diff --git a/drivers/amlogic/dvb_tv/smartcard/Makefile b/drivers/amlogic/dvb_tv/smartcard/Makefile
deleted file mode 100644
index 8b775fb8663f..000000000000
--- a/drivers/amlogic/dvb_tv/smartcard/Makefile
+++ /dev/null
@@ -1,8 +0,0 @@
-#
-#Makefile for the Smart card driver.
-#
-
-obj-y += amsmc.o
-#obj-$(CONFIG_AML_SMARTCARD) += amsmc.o
-amsmc-objs = smartcard.o
-ccflags-y += -I$(srctree)/drivers/amlogic/dvb_tv
diff --git a/drivers/amlogic/dvb_tv/smartcard/Readme.txt b/drivers/amlogic/dvb_tv/smartcard/Readme.txt
deleted file mode 100644
index 4c7d8ff832c3..000000000000
--- a/drivers/amlogic/dvb_tv/smartcard/Readme.txt
+++ /dev/null
@@ -1,57 +0,0 @@
-Smartcard Support for S905-- --
-	----------------------To configure smartcard driver on your platform,
-	you must following two steps below 1)
-  Add configurations to your kernel config file using menuconfig, or you can add to.config.CONFIG_AML_SMARTCARD = y 2) Add dts configuration Samples below:
-
-	smartcard
-	{
-		compatible = "amlogic,smartcard";
-		irq_trigger_type = "GPIO_IRQ_LOW";
-
-		reset_pin - gpios = <&gpio GPIOX_11 GPIO_ACTIVE_HIGH >;	//Reset pin
-		detect_pin - gpios = <&gpio GPIOX_20 GPIO_ACTIVE_HIGH >;	//Detect pin
-		enable_5v3v_pin - gpios = <&gpio GPIOX_10 GPIO_ACTIVE_HIGH >;	//5V3V pin, can be ignored
-
-		interrupts = <0 69 4 >;	//smc irq
-
-		smc0_clock_source = <0 >;	//Smc clock source, if change this, you must adjust clk and divider in smartcard.c
-		smc0_irq = <69 >;		//smc irq
-		smc0_det_invert = <0 >;	//0: high voltage on detect pin indicates card in.
-		smc0_5v3v_level = <0 >;
-		smc_need_enable_pin = "no";	//Ordinarily, smartcard controller needs a enable pin.
-		if board
-			controls smartcard directly, then we don 't need it.
-	reset_level = <0>;					//0: pull low reset pin to reset card
-
-	smc0_clk_pinmux_reg = <0x30>;
-	smc0_clk_pinmux_bit = <0x80>;
-	smc0_clk_oen_reg = <0x200f>;
-	smc0_clk_out_reg = <0x2010>;
-	smc0_clk_bit = <0x2000>;
-	smc0_clk_oebit = <0x2000000>;
-	smc0_clk_oubit = <0x1000000>;
-
-	pinctrl-names = "default";
-	pinctrl-0 = <&smc_pins>;
-	resets = <&clock GCLK_IDX_SMART_CARD_MPEG_DOMAIN>;
-	reset-names = "smartcard";
-
-	status = "okay";
-};
-
-&pinmux {
-smc_pins:smc_pins {									 //Set gpio to 7816-clk 7816-data mode.
-			 amlogic,setmask = <4 0x000000c0>;       //Please refer to core-pin mux document
-			 amlogic,clrmask = <3 0x60000280>;
-			 amlogic,pins = "GPIOX_8","GPIOX_9";
-		 };
-}
-
-
-Daniel.yan
-yan.yan@amlogic.com
-
-
-
-
-
diff --git a/drivers/amlogic/dvb_tv/smartcard/smartcard.c b/drivers/amlogic/dvb_tv/smartcard/smartcard.c
deleted file mode 100644
index 8c7ba22c6eed..000000000000
--- a/drivers/amlogic/dvb_tv/smartcard/smartcard.c
+++ /dev/null
@@ -1,2660 +0,0 @@
-/*
- *AMLOGIC Smart card driver.
- *
- *This program is free software; you can redistribute it and/or modify
- *it under the terms of the GNU General Public License as published by
- *the Free Software Foundation; either version 2 of the named License,
- *or any later version.
- *
- *This program is distributed in the hope that it will be useful,
- *but WITHOUT ANY WARRANTY; without even the implied warranty of
- *MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *GNU General Public License for more details.
- *
- */
-
-#include <linux/version.h>
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/mutex.h>
-#include <linux/wait.h>
-#include <linux/string.h>
-#include <linux/interrupt.h>
-#include <linux/fs.h>
-#include <linux/cdev.h>
-#include <linux/device.h>
-#include <linux/spinlock.h>
-#include <linux/sched.h>
-#include <linux/fcntl.h>
-#include <asm/irq.h>
-#include <linux/uaccess.h>
-#include <linux/platform_device.h>
-#include <linux/pinctrl/pinmux.h>
-#include "smartcard.h"
-#include "linux/amlogic/cpu_version.h"
-#include "aml_dvb_reg.h"
-#include <linux/gpio/consumer.h>
-#ifndef MESON_CPU_TYPE
-#define MESON_CPU_TYPE 0x50
-#endif
-#ifndef MESON_CPU_TYPE_MESON6
-#define MESON_CPU_TYPE_MESON6		0x60
-#endif
-#ifdef CONFIG_ARCH_ARC700
-#include <asm/arch/am_regs.h>
-#else
-#include "c_stb_define.h"
-#include "c_stb_regs_define.h"
-#endif
-#include <linux/poll.h>
-#include <linux/delay.h>
-/*#include < mach/gpio.h > */
-#include <linux/platform_device.h>
-#include <linux/slab.h>
-#include <linux/amlogic/aml_gpio_consumer.h>
-#define OWNER_NAME "smc"
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
-#include <mach/mod_gate.h>
-#include <mach/power_gate.h>
-#endif
-
-#include <linux/version.h>
-#include <linux/amlogic/aml_gpio_consumer.h>
-#include "amsmc.h"
-#include <linux/clk.h>
-#include <linux/reset.h>
-#include <linux/amlogic/aml_gpio_consumer.h>
-
-#include "smc_reg.h"
-
-#define DRIVER_NAME "amsmc"
-#define MODULE_NAME "amsmc"
-#define DEVICE_NAME "amsmc"
-#define CLASS_NAME "amsmc-class"
-
-#define INPUT 0
-#define OUTPUT 1
-#define OUTLEVEL_LOW 0
-#define OUTLEVEL_HIGH 1
-#define PULLLOW 1
-#define PULLHIGH 0
-
-/*#define FILE_DEBUG*/
-#define MEM_DEBUG
-#define SMC_GPIO_NUM_PROP(node, prop_name, str, gpio_pin) { \
-	if (!of_property_read_string(node, prop_name, &str)) { \
-		gpio_pin = \
-		desc_to_gpio(of_get_named_gpiod_flags(node, \
-					prop_name, 0, NULL)); \
-	} \
-}
-
-#ifdef FILE_DEBUG
-#define DBUF_SIZE (512*2)
-#define pr_dbg(fmt, args...) \
-	do { if (smc_debug > 0) { \
-			dcnt = sprintf(dbuf, fmt, ## args); \
-			debug_write(dbuf, dcnt); \
-		} \
-	} while (0)
-#define pr_dbg printk
-#define Fpr(a...) \
-	do { \
-		if (smc_debug > 1) { \
-			dcnt = sprintf(dbuf, a); \
-			debug_write(dbuf, dcnt); \
-		} \
-	} while (0)
-#define Ipr		 Fpr
-
-#elif defined(MEM_DEBUG)
-#define DBUF_SIZE (1024*1024*1)
-#define pr_dbg(fmt, args...) \
-	do {\
-		if (smc_debug > 0) { \
-			if (dwrite > (DBUF_SIZE - 512)) \
-				sprintf(dbuf+dwrite, "lost\n"); \
-			else { \
-				dcnt = sprintf(dbuf+dwrite, fmt, ## args); \
-				dwrite += dcnt; \
-			} \
-		} \
-	} while (0)
-#define Fpr(_a...) \
-	do { \
-		if (smc_debug > 1) { \
-			if (dwrite > (DBUF_SIZE - 512)) \
-				sprintf(dbuf+dwrite, "lost\n"); \
-			else { \
-				dcnt = print_time(local_clock(), dbuf+dwrite); \
-				dwrite += dcnt; \
-				dcnt = sprintf(dbuf+dwrite, _a); \
-				dwrite += dcnt; \
-			} \
-		} \
-	} while (0)
-#define Ipr		 Fpr
-
-#else
-#if 1
-#define pr_dbg(fmt, args...) \
-do {\
-	if (smc_debug > 0) \
-		pr_err("Smartcard: " fmt, ## args); \
-} \
-while (0)
-#define Fpr(a...)	do { if (smc_debug > 1) printk(a); } while (0)
-#define Ipr		 Fpr
-#else
-#define pr_dbg(fmt, args...)
-#define Fpr(a...)
-#endif
-#endif
-
-#define pr_error(fmt, args...) pr_err("Smartcard: " fmt, ## args)
-#define pr_inf(fmt, args...)  pr_err(fmt, ## args)
-#define DEBUG_FILE_NAME	 "/storage/external_storage/debug.smc"
-static struct file *debug_filp;
-static loff_t debug_file_pos;
-static int smc_debug;
-static char *dbuf;
-static int dread, dwrite;
-static int dcnt;
-static struct reset_control *aml_smartcard_reset_ctrl;
-#define REG_READ 0
-#define REG_WRITE 1
-void operate_reg(unsigned reg, int read_write, unsigned *value)
-{
-	void __iomem *vaddr;
-	reg = round_down(reg, 0x3);
-	vaddr = ioremap(reg, 0x4);
-	pr_dbg("smc ioremap %x %p\n", reg, vaddr);
-	if (read_write == REG_READ)
-		*value = readl(vaddr);
-	else if (read_write == REG_WRITE)
-		writel(*value, vaddr);
-	iounmap(vaddr);
-}
-
-void debug_write(const char __user *buf, size_t count)
-{
-	mm_segment_t old_fs;
-
-	if (!debug_filp)
-		return;
-
-	old_fs = get_fs();
-	set_fs(KERNEL_DS);
-
-	if (count != vfs_write(debug_filp, buf, count, &debug_file_pos))
-		pr_dbg("Failed to write debug file\n");
-
-	set_fs(old_fs);
-
-	return;
-}
-static void open_debug(void)
-{
-	debug_filp = filp_open(DEBUG_FILE_NAME, O_WRONLY, 0);
-	if (IS_ERR(debug_filp)) {
-		pr_dbg("smartcard: open debug file failed\n");
-		debug_filp = NULL;
-	} else {
-		pr_dbg("smc: debug file[%s] open.\n", DEBUG_FILE_NAME);
-	}
-}
-static void close_debug(void)
-{
-	if (debug_filp) {
-		filp_close(debug_filp, current->files);
-		debug_filp = NULL;
-		debug_file_pos = 0;
-	}
-}
-
-static size_t print_time(u64 ts, char *buf)
-{
-	unsigned long rem_nsec;
-
-	rem_nsec = do_div(ts, 1000000000);
-
-	if (!buf)
-		return snprintf(NULL, 0, "[%5lu.000000] ", (unsigned long)ts);
-
-	return sprintf(buf, "[%5lu.%06lu] ",
-			(unsigned long)ts, rem_nsec / 1000);
-}
-
-#ifdef CONFIG_OF
-static const struct of_device_id smc_dt_match[] = {
-	{	.compatible = "amlogic,smartcard",
-	},
-	{},
-};
-#else
-#define smc_dt_match NULL
-#endif
-
-
-MODULE_PARM_DESC(smc0_irq, "\n\t\t Irq number of smartcard0");
-static int smc0_irq = -1;
-module_param(smc0_irq, int, S_IRUGO);
-
-MODULE_PARM_DESC(smc0_reset, "\n\t\t Reset GPIO pin of smartcard0");
-static int smc0_reset = -1;
-module_param(smc0_reset, int, S_IRUGO);
-
-MODULE_PARM_DESC(atr_delay, "\n\t\t atr delay");
-static int atr_delay;
-module_param(atr_delay, int, 0644);
-
-MODULE_PARM_DESC(atr_holdoff, "\n\t\t atr_holdoff");
-static int atr_holdoff = 1;
-module_param(atr_holdoff, int, 0644);
-
-MODULE_PARM_DESC(cwt_det_en, "\n\t\t cwt_det_en");
-static int cwt_det_en;
-module_param(cwt_det_en, int, 0644);
-MODULE_PARM_DESC(btw_det_en, "\n\t\t btw_det_en");
-static int btw_det_en;
-module_param(btw_det_en, int, 0644);
-MODULE_PARM_DESC(etu_msr_en, "\n\t\t etu_msr_en");
-static int etu_msr_en;
-module_param(etu_msr_en, int, 0644);
-MODULE_PARM_DESC(clock_source, "\n\t\t clock_source");
-static int clock_source;
-module_param(clock_source, int, 0644);
-
-#define NO_HOT_RESET
-/*#define DISABLE_RECV_INT*/
-/*#define ATR_FROM_INT*/
-#define SW_INVERT
-/*#define SMC_FIQ*/
-/*#define ATR_OUT_READ*/
-#define KEEP_PARAM_AFTER_CLOSE
-
-#define CONFIG_AML_SMARTCARD_GPIO_FOR_DET
-#define CONFIG_AM_SMARTCARD_GPIO_FOR_RST
-
-#ifdef CONFIG_AML_SMARTCARD_GPIO_FOR_DET
-#define DET_FROM_PIO
-#endif
-#ifdef CONFIG_AM_SMARTCARD_GPIO_FOR_RST
-#define RST_FROM_PIO
-#endif
-
-#ifndef CONFIG_MESON_ARM_GIC_FIQ
-#undef SMC_FIQ
-#endif
-
-#ifdef SMC_FIQ
-#include < plat/fiq_bridge.h >
-#ifndef ATR_FROM_INT
-#define ATR_FROM_INT
-#endif
-#endif
-
-#define RECV_BUF_SIZE	 1024
-#define SEND_BUF_SIZE	 1024
-
-#define RESET_ENABLE	  (smc->reset_level) /*reset*/
-#define RESET_DISABLE	 (!smc->reset_level) /*dis-reset*/
-
-enum sc_type {
-	SC_DIRECT,
-	SC_INVERSE,
-};
-
-struct smc_dev {
-	int		id;
-	struct device	 *dev;
-	struct platform_device *pdev;
-	int		init;
-	int		used;
-	int		cardin;
-	int		active;
-	struct mutex	  lock;
-	spinlock_t		 slock;
-	wait_queue_head_t rd_wq;
-	wait_queue_head_t wr_wq;
-	int		recv_start;
-	int		recv_count;
-	int		send_start;
-	int		send_count;
-	char	  recv_buf[RECV_BUF_SIZE];
-	char	  send_buf[SEND_BUF_SIZE];
-	struct am_smc_param param;
-	struct am_smc_atr  atr;
-
-	struct gpio_desc *enable_pin;
-#define SMC_ENABLE_PIN_NAME "smc:ENABLE"
-	int	  enable_level;
-
-	struct gpio_desc *enable_5v3v_pin;
-#define SMC_ENABLE_5V3V_PIN_NAME "smc:5V3V"
-	int	  enable_5v3v_level;
-	int (*reset)(void*, int);
-	u32		irq_num;
-	int		reset_level;
-
-	u32	 pin_clk_pinmux_reg;
-	u32	 pin_clk_pinmux_bit;
-	struct gpio_desc *pin_clk_pin;
-#define SMC_CLK_PIN_NAME "smc:PINCLK"
-	u32	 pin_clk_oen_reg;
-	u32	 pin_clk_out_reg;
-	u32	 pin_clk_oebit;
-	u32	 pin_clk_oubit;
-	u32	 use_enable_pin;
-
-#ifdef SW_INVERT
-	int		atr_mode;
-	enum sc_type		 sc_type;
-#endif
-
-	int	  recv_end;
-	int	  send_end;
-#ifdef SMC_FIQ
-	bridge_item_t	 smc_fiq_bridge;
-#endif
-
-#ifdef DET_FROM_PIO
-	struct gpio_desc *detect_pin;
-#define SMC_DETECT_PIN_NAME "smc:DETECT"
-#endif
-#ifdef RST_FROM_PIO
-	struct gpio_desc *reset_pin;
-#define SMC_RESET_PIN_NAME "smc:RESET"
-#endif
-
-	int		detect_invert;
-
-	struct pinctrl	  *pinctrl;
-
-	struct tasklet_struct	 tasklet;
-};
-
-#define SMC_DEV_NAME	 "smc"
-#define SMC_CLASS_NAME  "smc-class"
-#define SMC_DEV_COUNT	1
-
-#define SMC_READ_REG(a)		  READ_MPEG_REG(SMARTCARD_##a)
-#define SMC_WRITE_REG(a, b)		WRITE_MPEG_REG(SMARTCARD_##a, b)
-
-static struct mutex smc_lock;
-static int		 smc_major;
-static struct smc_dev	smc_dev[SMC_DEV_COUNT];
-static int ENA_GPIO_PULL = 1;
-
-#ifdef SW_INVERT
-static const unsigned char inv_table[256] = {
-	0xFF, 0x7F, 0xBF, 0x3F, 0xDF, 0x5F, 0x9F, 0x1F,
-	0xEF, 0x6F, 0xAF, 0x2F, 0xCF, 0x4F, 0x8F, 0x0F,
-	0xF7, 0x77, 0xB7, 0x37, 0xD7, 0x57, 0x97, 0x17,
-	0xE7, 0x67, 0xA7, 0x27, 0xC7, 0x47, 0x87, 0x07,
-	0xFB, 0x7B, 0xBB, 0x3B, 0xDB, 0x5B, 0x9B, 0x1B,
-	0xEB, 0x6B, 0xAB, 0x2B, 0xCB, 0x4B, 0x8B, 0x0B,
-	0xF3, 0x73, 0xB3, 0x33, 0xD3, 0x53, 0x93, 0x13,
-	0xE3, 0x63, 0xA3, 0x23, 0xC3, 0x43, 0x83, 0x03,
-	0xFD, 0x7D, 0xBD, 0x3D, 0xDD, 0x5D, 0x9D, 0x1D,
-	0xED, 0x6D, 0xAD, 0x2D, 0xCD, 0x4D, 0x8D, 0x0D,
-	0xF5, 0x75, 0xB5, 0x35, 0xD5, 0x55, 0x95, 0x15,
-	0xE5, 0x65, 0xA5, 0x25, 0xC5, 0x45, 0x85, 0x05,
-	0xF9, 0x79, 0xB9, 0x39, 0xD9, 0x59, 0x99, 0x19,
-	0xE9, 0x69, 0xA9, 0x29, 0xC9, 0x49, 0x89, 0x09,
-	0xF1, 0x71, 0xB1, 0x31, 0xD1, 0x51, 0x91, 0x11,
-	0xE1, 0x61, 0xA1, 0x21, 0xC1, 0x41, 0x81, 0x01,
-	0xFE, 0x7E, 0xBE, 0x3E, 0xDE, 0x5E, 0x9E, 0x1E,
-	0xEE, 0x6E, 0xAE, 0x2E, 0xCE, 0x4E, 0x8E, 0x0E,
-	0xF6, 0x76, 0xB6, 0x36, 0xD6, 0x56, 0x96, 0x16,
-	0xE6, 0x66, 0xA6, 0x26, 0xC6, 0x46, 0x86, 0x06,
-	0xFA, 0x7A, 0xBA, 0x3A, 0xDA, 0x5A, 0x9A, 0x1A,
-	0xEA, 0x6A, 0xAA, 0x2A, 0xCA, 0x4A, 0x8A, 0x0A,
-	0xF2, 0x72, 0xB2, 0x32, 0xD2, 0x52, 0x92, 0x12,
-	0xE2, 0x62, 0xA2, 0x22, 0xC2, 0x42, 0x82, 0x02,
-	0xFC, 0x7C, 0xBC, 0x3C, 0xDC, 0x5C, 0x9C, 0x1C,
-	0xEC, 0x6C, 0xAC, 0x2C, 0xCC, 0x4C, 0x8C, 0x0C,
-	0xF4, 0x74, 0xB4, 0x34, 0xD4, 0x54, 0x94, 0x14,
-	0xE4, 0x64, 0xA4, 0x24, 0xC4, 0x44, 0x84, 0x04,
-	0xF8, 0x78, 0xB8, 0x38, 0xD8, 0x58, 0x98, 0x18,
-	0xE8, 0x68, 0xA8, 0x28, 0xC8, 0x48, 0x88, 0x08,
-	0xF0, 0x70, 0xB0, 0x30, 0xD0, 0x50, 0x90, 0x10,
-	0xE0, 0x60, 0xA0, 0x20, 0xC0, 0x40, 0x80, 0x00
-};
-#endif /*SW_INVERT*/
-
-#define dump(b, l) do { \
-	int i; \
-	pr_dbg("dump: "); \
-	for (i = 0; i < (l); i++) \
-		pr_dbg("%02x ", *(((unsigned char *)(b))+i)); \
-		pr_dbg("\n"); \
-} while (0)
-
-static int _gpio_out(struct gpio_desc *gpio, int val, const char *owner);
-static int smc_default_init(struct smc_dev *smc);
-static int smc_hw_set_param(struct smc_dev *smc);
-static int smc_hw_reset(struct smc_dev *smc);
-static int smc_hw_active(struct smc_dev *smc);
-static int smc_hw_deactive(struct smc_dev *smc);
-static int smc_hw_get_status(struct smc_dev *smc, int *sret);
-
-static ssize_t show_gpio_pull(struct class *class,
-	struct class_attribute *attr,
-	char *buf)
-{
-	if (ENA_GPIO_PULL > 0)
-		return sprintf(buf, "%s\n", "enable GPIO pull low");
-	else
-		return sprintf(buf, "%s\n", "disable GPIO pull low");
-}
-
-static ssize_t set_gpio_pull(struct class *class,
-	struct class_attribute *attr,
-	const char *buf,
-	size_t count)
-{
-	int dbg;
-	ssize_t r;
-
-	r = sscanf(buf, "%d", &dbg);
-	if (r != 1)
-		return -EINVAL;
-
-	ENA_GPIO_PULL = dbg;
-	return count;
-}
-
-static ssize_t show_5v3v(struct class *class,
-	struct class_attribute *attr,
-	char *buf)
-{
-	struct smc_dev *smc = NULL;
-	int enable_5v3v = 0;
-
-	mutex_lock(&smc_lock);
-	smc = &smc_dev[0];
-	enable_5v3v = smc->enable_5v3v_level;
-	mutex_unlock(&smc_lock);
-
-	return sprintf(buf, "5v3v_pin level = %d\n", enable_5v3v);
-}
-
-static ssize_t store_5v3v(struct class *class,
-	struct class_attribute *attr,
-	const char *buf,
-	size_t count)
-{
-	unsigned int enable_5v3v = 0;
-	ssize_t r;
-	struct smc_dev *smc = NULL;
-
-	r = sscanf(buf, "%d", &enable_5v3v);
-	if (r != 1)
-		return -EINVAL;
-
-	mutex_lock(&smc_lock);
-	smc = &smc_dev[0];
-	smc->enable_5v3v_level = enable_5v3v;
-
-	if (smc->enable_5v3v_pin != NULL) {
-		_gpio_out(smc->enable_5v3v_pin,
-			smc->enable_5v3v_level,
-			SMC_ENABLE_5V3V_PIN_NAME);
-		pr_error("enable_pin: -->(%d)\n",
-			(smc->enable_5v3v_level) ? 1 : 0);
-	}
-	mutex_unlock(&smc_lock);
-
-	return count;
-}
-
-static ssize_t show_freq(struct class *class,
-	struct class_attribute *attr,
-	char *buf)
-{
-	return sprintf(buf, "%dKHz\n", smc_dev[0].param.freq);
-}
-
-static ssize_t store_freq(struct class *class,
-	struct class_attribute *attr,
-	const char *buf,
-	size_t count)
-{
-	int freq = 0;
-	int ret;
-
-	ret = sscanf(buf, "%d", &freq);
-	if (freq)
-		smc_dev[0].param.freq = freq;
-	pr_dbg("freq -> %dKHz\n", smc_dev[0].param.freq);
-	return count;
-}
-
-#ifdef MEM_DEBUG
-static ssize_t show_debug(struct class *class,
-	struct class_attribute *attr,
-	char *buf)
-{
-	pr_inf("Usage:\n");
-	pr_inf("\techo [ 1 | 2 | 0 | dump | reset ] >");
-	pr_inf("debug : enable(1/2)|diable|dump|reset\n");
-	pr_inf("\t dump file: "DEBUG_FILE_NAME"\n");
-	return 0;
-}
-
-static ssize_t store_debug(struct class *class,
-	struct class_attribute *attr,
-	const char *buf,
-	size_t count)
-{
-	int smc_debug_level = 0;
-
-	switch (buf[0]) {
-	case '2':
-		smc_debug_level++;
-	case '1': {
-		void *p = krealloc((const void *)dbuf, DBUF_SIZE, GFP_KERNEL);
-		smc_debug_level++;
-		if (p) {
-			dbuf = (char *)p;
-			smc_debug = smc_debug_level;
-		} else {
-			pr_error("krealloc(dbuf:%d) failed\n", DBUF_SIZE);
-		}
-	}
-		  break;
-	case '0':
-		smc_debug = 0;
-		kfree(dbuf);
-		dbuf = NULL;
-		break;
-	case 'r':
-	case 'R':
-		if (smc_debug) {
-			memset(dbuf, 0, DBUF_SIZE);
-			dwrite = 0;
-			dread = 0;
-			pr_inf("dbuf cleanup\n");
-		}
-		break;
-	case 'd':
-	case 'D':
-		if (smc_debug) {
-			open_debug();
-			debug_write(dbuf, dwrite+5);
-			close_debug();
-			pr_inf("dbuf dump ok\n");
-		}
-		break;
-	default:
-		break;
-	}
-	return count;
-}
-#endif
-
-static struct class_attribute smc_class_attrs[] = {
-	__ATTR(smc_gpio_pull, S_IRUGO | S_IWUSR, show_gpio_pull, set_gpio_pull),
-	__ATTR(ctrl_5v3v, S_IRUGO | S_IWUSR, show_5v3v, store_5v3v),
-	__ATTR(freq, S_IRUGO | S_IWUSR, show_freq, store_freq),
-#ifdef MEM_DEBUG
-	__ATTR(debug, S_IRUGO | S_IWUSR, show_debug, store_debug),
-#endif
-	__ATTR_NULL
-};
-
-static struct class smc_class = {
-	.name = SMC_CLASS_NAME,
-	.class_attrs = smc_class_attrs,
-};
-
-static unsigned long get_clk(char *name)
-{
-	struct clk *clk = NULL;
-	clk = clk_get_sys(name, NULL);
-	if (clk)
-		return clk_get_rate(clk);
-	return 0;
-}
-
-static unsigned long get_module_clk(int sel)
-{
-#ifdef CONFIG_ARCH_ARC700
-	return get_mpeg_clk();
-#else
-
-	unsigned long clk = 0;
-#ifdef CONFIG_ARCH_MESON6/*M6*/
-	/*sel = [0:clk81, 1:ddr-pll, 2:fclk-div5, 3:XTAL]*/
-	switch (sel) {
-	case 0:
-		clk = get_clk("clk81");
-		break;
-	case 1:
-		clk = get_clk("pll_ddr");
-		break;
-	case 2:
-		clk = get_clk("fixed")/5;
-		break;
-	case 3:
-		clk = get_clk("xtal");
-		break;
-	}
-#else
-	/*sel = [0:fclk-div2/fclk-div4(M8 and further),
-	1:fclk-div3, 2:fclk-div5, 3:XTAL]*/
-	switch (sel) {
-#if defined(MESON_CPU_TYPE_MESON8) && (MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8)
-	case 0:
-		clk = get_clk("pll_fixed") / 4;
-		break;
-#else/*M6TV/TVD/TVLITE*/
-	case 0:
-		clk = 1000000000;
-		break;
-			/*case 0: clk = get_clk("fixed")/2;
-			 break; */
-#endif
-	case 1:
-		clk = get_clk("pll_fixed") / 3;
-		break;
-	case 2:
-		clk = get_clk("pll_fixed") / 5;
-		break;
-	case 3:
-		clk = get_clk("xtal");
-		break;
-	}
-#endif /*M6*/
-
-	if (!clk)
-		pr_error("fail: unknown clk source");
-
-	return clk;
-
-#endif
-}
-
-#ifndef CONFIG_OF
-static int _gpio_request(unsigned int gpio, const char *owner)
-{
-	gpio_request(gpio, owner);
-	return 0;
-}
-#endif
-
-static int _gpio_out(struct gpio_desc *gpio, int val, const char *owner)
-{
-	int ret = 0;
-	if (val < 0) {
-		pr_dbg("gpio out val = -1.\n");
-		return -1;
-	}
-	if (val != 0)
-		val = 1;
-	ret = gpiod_direction_output(gpio, val);
-	pr_dbg("smc gpio out ret %d\n", ret);
-	return ret;
-}
-
-#ifdef DET_FROM_PIO
-static int _gpio_in(struct gpio_desc *gpio, const char *owner)
-{
-	int ret = 0;
-
-	ret = gpiod_get_value(gpio);
-	return ret;
-}
-#endif
-static int _gpio_free(struct gpio_desc *gpio, const char *owner)
-{
-
-	gpiod_put(gpio);
-	return 0;
-}
-
-static inline int smc_write_end(struct smc_dev *smc)
-{
-	int ret;
-	unsigned long flags;
-
-	spin_lock_irqsave(&smc->slock, flags);
-	ret = (!smc->cardin || !smc->send_count);
-	spin_unlock_irqrestore(&smc->slock, flags);
-
-	return ret;
-}
-
-
-static inline int smc_can_read(struct smc_dev *smc)
-{
-	int ret;
-	unsigned long flags;
-
-	spin_lock_irqsave(&smc->slock, flags);
-	ret = (!smc->cardin || smc->recv_count);
-	spin_unlock_irqrestore(&smc->slock, flags);
-
-	return ret;
-}
-
-static inline int smc_can_write(struct smc_dev *smc)
-{
-	int ret;
-	unsigned long flags;
-
-	spin_lock_irqsave(&smc->slock, flags);
-	ret = (!smc->cardin || (smc->send_count != SEND_BUF_SIZE));
-	spin_unlock_irqrestore(&smc->slock, flags);
-	return ret;
-}
-
-static int smc_hw_set_param(struct smc_dev *smc)
-{
-	unsigned long v = 0;
-	struct SMCCARD_HW_Reg0 *reg0;
-	struct SMCCARD_HW_Reg6 *reg6;
-	struct SMCCARD_HW_Reg2 *reg2;
-	struct SMCCARD_HW_Reg5 *reg5;
-	/*
-	  SMC_ANSWER_TO_RST *reg1;
-	  SMC_INTERRUPT_Reg *reg_int;
-	  */
-	unsigned sys_clk_rate = get_module_clk(clock_source);
-	unsigned long freq_cpu =
-	    sys_clk_rate / 1000 * 22; /**10 adjust freq temporarily*/
-
-	pr_error("hw set param\n");
-
-	v = SMC_READ_REG(REG0);
-	reg0 = (struct SMCCARD_HW_Reg0 *)&v;
-	reg0->etu_divider = ETU_DIVIDER_CLOCK_HZ * smc->param.f /
-	    (smc->param.d * smc->param.freq) - 1;
-	SMC_WRITE_REG(REG0, v);
-	pr_error("REG0: 0x%08lx\n", v);
-	pr_error("f	  :%d\n", smc->param.f);
-	pr_error("d	  :%d\n", smc->param.d);
-	pr_error("freq	:%d\n", smc->param.freq);
-
-	v = SMC_READ_REG(REG1);
-	pr_error("REG1: 0x%08lx\n", v);
-
-	v = SMC_READ_REG(REG2);
-	reg2 = (struct SMCCARD_HW_Reg2 *)&v;
-	reg2->recv_invert = smc->param.recv_invert;
-	reg2->recv_parity = smc->param.recv_parity;
-	reg2->recv_lsb_msb = smc->param.recv_lsb_msb;
-	reg2->xmit_invert = smc->param.xmit_invert;
-	reg2->xmit_parity = smc->param.xmit_parity;
-	reg2->xmit_lsb_msb = smc->param.xmit_lsb_msb;
-	reg2->xmit_retries = smc->param.xmit_retries;
-	reg2->xmit_repeat_dis = smc->param.xmit_repeat_dis;
-	reg2->recv_no_parity = smc->param.recv_no_parity;
-	reg2->clk_tcnt = freq_cpu/smc->param.freq - 1;
-	reg2->det_filter_sel = DET_FILTER_SEL_DEFAULT;
-	reg2->io_filter_sel = IO_FILTER_SEL_DEFAULT;
-	reg2->clk_sel = clock_source;
-	/*reg2->pulse_irq = 0;*/
-	SMC_WRITE_REG(REG2, v);
-	pr_error("REG2: 0x%08lx\n", v);
-	pr_error("recv_inv:%d\n", smc->param.recv_invert);
-	pr_error("recv_lsb:%d\n", smc->param.recv_lsb_msb);
-	pr_error("recv_par:%d\n", smc->param.recv_parity);
-	pr_error("recv_npa:%d\n", smc->param.recv_no_parity);
-	pr_error("xmit_inv:%d\n", smc->param.xmit_invert);
-	pr_error("xmit_lsb:%d\n", smc->param.xmit_lsb_msb);
-	pr_error("xmit_par:%d\n", smc->param.xmit_parity);
-	pr_error("xmit_rep:%d\n", smc->param.xmit_repeat_dis);
-	pr_error("xmit_try:%d\n", smc->param.xmit_retries);
-
-	v = SMC_READ_REG(REG5);
-	reg5 = (struct SMCCARD_HW_Reg5 *)&v;
-	reg5->cwt_detect_en = cwt_det_en;
-	reg5->bwt_base_time_gnt = BWT_BASE_DEFAULT;
-	SMC_WRITE_REG(REG5, v);
-	pr_error("REG5: 0x%08lx\n", v);
-
-	v = SMC_READ_REG(REG6);
-	reg6 = (struct SMCCARD_HW_Reg6 *)&v;
-	reg6->cwi_value = smc->param.cwi;
-	reg6->bwi = smc->param.bwi;
-	reg6->bgt = smc->param.bgt-2;
-	reg6->N_parameter = smc->param.n;
-	SMC_WRITE_REG(REG6, v);
-	pr_error("REG6: 0x%08lx\n", v);
-	pr_error("N	  :%d\n", smc->param.n);
-	pr_error("cwi	 :%d\n", smc->param.cwi);
-	pr_error("bgt	 :%d\n", smc->param.bgt);
-	pr_error("bwi	 :%d\n", smc->param.bwi);
-
-	return 0;
-}
-
-static int smc_default_init(struct smc_dev *smc)
-{
-	smc->param.f = F_DEFAULT;
-	smc->param.d = D_DEFAULT;
-	smc->param.freq = FREQ_DEFAULT;
-	smc->param.recv_invert = 0;
-	smc->param.recv_parity = 0;
-	smc->param.recv_lsb_msb = 0;
-	smc->param.recv_no_parity = 1;
-	smc->param.xmit_invert = 0;
-	smc->param.xmit_lsb_msb = 0;
-	smc->param.xmit_retries = 1;
-	smc->param.xmit_repeat_dis = 1;
-	smc->param.xmit_parity = 0;
-
-	/*set reg6 param value */
-	smc->param.n = N_DEFAULT;
-	smc->param.bwi = BWI_DEFAULT;
-	smc->param.cwi = CWI_DEFAULT;
-	smc->param.bgt = BGT_DEFAULT;
-	return 0;
-}
-
-static int smc_hw_setup(struct smc_dev *smc)
-{
-	unsigned long v = 0;
-	struct SMCCARD_HW_Reg0 *reg0;
-	struct SMC_ANSWER_TO_RST *reg1;
-	struct SMCCARD_HW_Reg2 *reg2;
-	struct SMC_INTERRUPT_Reg *reg_int;
-	struct SMCCARD_HW_Reg5 *reg5;
-	struct SMCCARD_HW_Reg6 *reg6;
-
-	unsigned sys_clk_rate = get_module_clk(clock_source);
-
-	unsigned long freq_cpu = sys_clk_rate
-	    / 1000 * 22; /**10 adjust freq temporarily*/
-
-	pr_error("SMC CLK SOURCE - %luKHz\n", freq_cpu);
-
-#ifdef RST_FROM_PIO
-	_gpio_out(smc->reset_pin, RESET_ENABLE, SMC_RESET_PIN_NAME);
-#endif
-
-	v = SMC_READ_REG(REG0);
-	reg0 = (struct SMCCARD_HW_Reg0 *)&v;
-	reg0->enable = 1;
-	reg0->clk_en = 0;
-	reg0->clk_oen = 0;
-	reg0->card_detect = 0;
-	reg0->start_atr = 0;
-	reg0->start_atr_en = 0;
-	reg0->rst_level = RESET_ENABLE;
-	reg0->io_level = 0;
-	reg0->recv_fifo_threshold = FIFO_THRESHOLD_DEFAULT;
-	reg0->etu_divider = ETU_DIVIDER_CLOCK_HZ * smc->param.f
-	    / (smc->param.d*smc->param.freq) - 1;
-	reg0->first_etu_offset = 5;
-	SMC_WRITE_REG(REG0, v);
-	pr_error("REG0: 0x%08lx\n", v);
-	pr_error("f	  :%d\n", smc->param.f);
-	pr_error("d	  :%d\n", smc->param.d);
-	pr_error("freq	:%d\n", smc->param.freq);
-
-	v = SMC_READ_REG(REG1);
-	reg1 = (struct SMC_ANSWER_TO_RST *)&v;
-	reg1->atr_final_tcnt = ATR_FINAL_TCNT_DEFAULT;
-	reg1->atr_holdoff_tcnt = ATR_HOLDOFF_TCNT_DEFAULT;
-	reg1->atr_clk_mux = ATR_CLK_MUX_DEFAULT;
-	reg1->atr_holdoff_en = atr_holdoff;/*ATR_HOLDOFF_EN;*/
-	reg1->etu_clk_sel = ETU_CLK_SEL;
-	SMC_WRITE_REG(REG1, v);
-	pr_error("REG1: 0x%08lx\n", v);
-
-	v = SMC_READ_REG(REG2);
-	reg2 = (struct SMCCARD_HW_Reg2 *)&v;
-	reg2->recv_invert = smc->param.recv_invert;
-	reg2->recv_parity = smc->param.recv_parity;
-	reg2->recv_lsb_msb = smc->param.recv_lsb_msb;
-	reg2->xmit_invert = smc->param.xmit_invert;
-	reg2->xmit_parity = smc->param.xmit_parity;
-	reg2->xmit_lsb_msb = smc->param.xmit_lsb_msb;
-	reg2->xmit_retries = smc->param.xmit_retries;
-	reg2->xmit_repeat_dis = smc->param.xmit_repeat_dis;
-	reg2->recv_no_parity = smc->param.recv_no_parity;
-	reg2->clk_tcnt = freq_cpu/smc->param.freq - 1;
-	reg2->det_filter_sel = DET_FILTER_SEL_DEFAULT;
-	reg2->io_filter_sel = IO_FILTER_SEL_DEFAULT;
-	reg2->clk_sel = clock_source;
-	/*reg2->pulse_irq = 0;*/
-	SMC_WRITE_REG(REG2, v);
-	pr_error("REG2: 0x%08lx\n", v);
-	pr_error("recv_inv:%d\n", smc->param.recv_invert);
-	pr_error("recv_lsb:%d\n", smc->param.recv_lsb_msb);
-	pr_error("recv_par:%d\n", smc->param.recv_parity);
-	pr_error("recv_npa:%d\n", smc->param.recv_no_parity);
-	pr_error("xmit_inv:%d\n", smc->param.xmit_invert);
-	pr_error("xmit_lsb:%d\n", smc->param.xmit_lsb_msb);
-	pr_error("xmit_par:%d\n", smc->param.xmit_parity);
-	pr_error("xmit_rep:%d\n", smc->param.xmit_repeat_dis);
-	pr_error("xmit_try:%d\n", smc->param.xmit_retries);
-
-	v = SMC_READ_REG(INTR);
-	reg_int = (struct SMC_INTERRUPT_Reg *)&v;
-	reg_int->recv_fifo_bytes_threshold_int_mask = 0;
-	reg_int->send_fifo_last_byte_int_mask = 1;
-	reg_int->cwt_expeired_int_mask = 1;
-	reg_int->bwt_expeired_int_mask = 1;
-	reg_int->write_full_fifo_int_mask = 1;
-	reg_int->send_and_recv_confilt_int_mask = 1;
-	reg_int->recv_error_int_mask = 1;
-	reg_int->send_error_int_mask = 1;
-	reg_int->rst_expired_int_mask = 1;
-	reg_int->card_detect_int_mask = 0;
-	SMC_WRITE_REG(INTR, v | 0x03FF);
-	pr_error("INTR: 0x%08lx\n", v);
-
-	v = SMC_READ_REG(REG5);
-	reg5 = (struct SMCCARD_HW_Reg5 *)&v;
-	reg5->cwt_detect_en = cwt_det_en;
-	reg5->btw_detect_en = btw_det_en;
-	reg5->etu_msr_en = etu_msr_en;
-	reg5->bwt_base_time_gnt = BWT_BASE_DEFAULT;
-	SMC_WRITE_REG(REG5, v);
-	pr_error("REG5: 0x%08lx\n", v);
-
-
-	v = SMC_READ_REG(REG6);
-	reg6 = (struct SMCCARD_HW_Reg6 *)&v;
-	reg6->N_parameter = smc->param.n;
-	reg6->cwi_value = smc->param.cwi;
-	reg6->bgt = smc->param.bgt-2;
-	reg6->bwi = smc->param.bwi;
-	SMC_WRITE_REG(REG6, v);
-	pr_error("REG6: 0x%08lx\n", v);
-	pr_error("N	  :%d\n", smc->param.n);
-	pr_error("cwi	 :%d\n", smc->param.cwi);
-	pr_error("bgt	 :%d\n", smc->param.bgt);
-	pr_error("bwi	 :%d\n", smc->param.bwi);
-	return 0;
-}
-
-static void enable_smc_clk(struct smc_dev *smc)
-{
-	unsigned int _value;
-
-	if ((smc->pin_clk_pinmux_reg == -1)
-			|| (smc->pin_clk_pinmux_bit == -1))
-		return;
-	_value = READ_CBUS_REG(smc->pin_clk_pinmux_reg);
-	_value |= smc->pin_clk_pinmux_bit;
-	WRITE_CBUS_REG(smc->pin_clk_pinmux_reg, _value);
-}
-
-static void disable_smc_clk(struct smc_dev *smc)
-{
-	unsigned int _value;
-
-	if ((smc->pin_clk_pinmux_reg == -1)
-			|| (smc->pin_clk_pinmux_bit == -1))
-		return;
-
-	_value = READ_CBUS_REG(smc->pin_clk_pinmux_reg);
-	_value &= ~smc->pin_clk_pinmux_bit;
-	WRITE_CBUS_REG(smc->pin_clk_pinmux_reg, _value);
-	_value = READ_CBUS_REG(smc->pin_clk_pinmux_reg);
-
-	/*pr_dbg("disable smc_clk: mux[%x]\n", _value);*/
-
-	if ((smc->pin_clk_oen_reg != -1)
-			&& (smc->pin_clk_out_reg != -1)
-			&& (smc->pin_clk_oebit != -1)
-			&& (smc->pin_clk_oubit != -1)) {
-
-		/*force the clk pin to low.*/
-		_value = READ_CBUS_REG(smc->pin_clk_oen_reg);
-		_value &= ~smc->pin_clk_oebit;
-		WRITE_CBUS_REG(smc->pin_clk_oen_reg, _value);
-		_value = READ_CBUS_REG(smc->pin_clk_out_reg);
-		_value &= ~smc->pin_clk_oubit;
-		WRITE_CBUS_REG(smc->pin_clk_out_reg, _value);
-		pr_dbg("disable smc_clk: pin[%x](reg)\n", _value);
-	} else if (smc->pin_clk_pin != NULL) {
-
-		udelay(20);
-		/*	_gpio_out(smc->pin_clk_pin,
-			0,
-			SMC_CLK_PIN_NAME);*/
-		udelay(1000);
-
-		/*pr_dbg("disable smc_clk: pin[%x](pin)\n", smc->pin_clk_pin);*/
-	} else {
-
-		pr_error("no reg/bit or pin");
-		pr_error("defined for clk-pin contrl.\n");
-	}
-
-	return;
-}
-
-static int smc_hw_active(struct smc_dev *smc)
-{
-	if (ENA_GPIO_PULL > 0) {
-		enable_smc_clk(smc);
-		udelay(200);
-	}
-	if (!smc->active) {
-
-		if (smc->reset) {
-			smc->reset(NULL, 0);
-			pr_dbg("call reset(0) in bsp.\n");
-		} else {
-			if (smc->use_enable_pin) {
-				_gpio_out(smc->enable_pin,
-					smc->enable_level,
-					SMC_ENABLE_PIN_NAME);
-			}
-		}
-
-		udelay(200);
-		smc_hw_setup(smc);
-
-		smc->active = 1;
-	}
-
-	return 0;
-}
-
-static int smc_hw_deactive(struct smc_dev *smc)
-{
-	if (smc->active) {
-		unsigned long sc_reg0 = SMC_READ_REG(REG0);
-		struct SMCCARD_HW_Reg0 *sc_reg0_reg = (void *)&sc_reg0;
-		sc_reg0_reg->rst_level = RESET_ENABLE;
-		sc_reg0_reg->enable = 1;
-		sc_reg0_reg->start_atr = 0;
-		sc_reg0_reg->start_atr_en = 0;
-		sc_reg0_reg->clk_en = 0;
-		SMC_WRITE_REG(REG0, sc_reg0);
-#ifdef RST_FROM_PIO
-		/*_gpio_out(smc->reset_pin, RESET_ENABLE, SMC_RESET_PIN_NAME);*/
-		_gpio_out(smc->reset_pin, RESET_DISABLE, SMC_RESET_PIN_NAME);
-#endif
-		udelay(200);
-
-		if (smc->reset) {
-			smc->reset(NULL, 1);
-			pr_dbg("call reset(1) in bsp.\n");
-		} else {
-			if (smc->use_enable_pin)
-				_gpio_out(smc->enable_pin,
-					!smc->enable_level,
-					SMC_ENABLE_PIN_NAME);
-		}
-		if (ENA_GPIO_PULL > 0) {
-			disable_smc_clk(smc);
-			/*smc_pull_down_data();*/
-		}
-
-		smc->active = 0;
-	}
-
-	return 0;
-}
-
-#define INV(a) ((smc->sc_type == SC_INVERSE) ? inv_table[(int)(a)] : (a))
-
-#ifndef ATR_FROM_INT
-static int smc_hw_get(struct smc_dev *smc, int cnt, int timeout)
-{
-	unsigned long sc_status;
-	int times = timeout*100;
-	struct SMC_STATUS_Reg *sc_status_reg =
-	    (struct SMC_STATUS_Reg *)&sc_status;
-
-	while ((times > 0) && (cnt > 0)) {
-		sc_status = SMC_READ_REG(STATUS);
-
-		/*pr_dbg("read atr status %08x\n", sc_status);*/
-
-		if (sc_status_reg->rst_expired_status)
-			pr_error("atr timeout\n");
-
-		if (sc_status_reg->cwt_expeired_status) {
-			pr_error("cwt timeout when get atr,");
-			pr_error("but maybe it is natural!\n");
-		}
-
-		if (sc_status_reg->recv_fifo_empty_status) {
-			udelay(10);
-			times--;
-		} else {
-			while (sc_status_reg->recv_fifo_bytes_number > 0) {
-				u8 byte = (SMC_READ_REG(FIFO))&0xff;
-
-#ifdef SW_INVERT
-				if (smc->sc_type == SC_INVERSE)
-					byte = inv_table[byte];
-#endif
-
-				smc->atr.atr[smc->atr.atr_len++] = byte;
-				sc_status_reg->recv_fifo_bytes_number--;
-				cnt--;
-				if (cnt == 0) {
-					pr_dbg("read atr bytes ok\n");
-					return 0;
-				}
-			}
-		}
-	}
-
-	pr_error("read atr failed\n");
-	return -1;
-}
-
-#else
-
-static int smc_fiq_get(struct smc_dev *smc, int size, int timeout)
-{
-	int ret = 0;
-	int times = timeout/10;
-	int start, end;
-
-	if (!times)
-		times = 1;
-
-	while ((times > 0) && (size > 0)) {
-
-		start = smc->recv_start;
-		end = smc->recv_end;/*momentary value*/
-
-		if (!smc->cardin) {
-			ret = -ENODEV;
-		} else if (start == end) {
-			ret = -EAGAIN;
-		} else {
-			int i;
-			/*ATR only, no loop*/
-			ret = end - start;
-			if (ret > size)
-				ret = size;
-			memcpy(&smc->atr.atr[smc->atr.atr_len],
-				&smc->recv_buf[start], ret);
-			for (i = smc->atr.atr_len;
-				i < smc->atr.atr_len+ret;
-				i++)
-				smc->atr.atr[i] = INV((int)smc->atr.atr[i]);
-			smc->atr.atr_len += ret;
-
-			smc->recv_start += ret;
-			size - = ret;
-		}
-
-		if (ret < 0) {
-			msleep(20);
-			times--;
-		}
-	}
-
-	if (size > 0)
-		ret = -ETIMEDOUT;
-
-	return ret;
-}
-#endif /*ifndef ATR_FROM_INT*/
-
-static int smc_hw_read_atr(struct smc_dev *smc)
-{
-	char *ptr = smc->atr.atr;
-	int his_len, t, tnext = 0, only_t0 = 1, loop_cnt = 0;
-	int i;
-
-	pr_dbg("read atr\n");
-
-#ifdef ATR_FROM_INT
-#define smc_hw_get smc_fiq_get
-#endif
-
-	smc->atr.atr_len = 0;
-	if (smc_hw_get(smc, 2, 2000) < 0)
-		goto end;
-
-#ifdef SW_INVERT
-	if (0x03 == ptr[0]) {
-		smc->sc_type = SC_INVERSE;
-		ptr[0] = inv_table[(int)ptr[0]];
-		if (smc->atr.atr_len > 1)
-			ptr[1] = inv_table[(int)ptr[1]];
-	} else if (0x3F == ptr[0]) {
-		smc->sc_type = SC_INVERSE;
-		if (smc->atr.atr_len > 1)
-			ptr[1] = inv_table[(int)ptr[1]];
-	} else if (0x3B == ptr[0]) {
-		smc->sc_type = SC_DIRECT;
-	} else if (0x23 == ptr[0]) {
-		smc->sc_type = SC_DIRECT;
-		ptr[0] = inv_table[(int)ptr[0]];
-		if (smc->atr.atr_len > 1)
-			ptr[1] = inv_table[(int)ptr[1]];
-	}
-#endif /*SW_INVERT*/
-
-	ptr++;
-	his_len = ptr[0]&0x0F;
-
-	do {
-		tnext = 0;
-		loop_cnt++;
-		if (ptr[0]&0x10) {
-			if (smc_hw_get(smc, 1, 1000) < 0)
-				goto end;
-		}
-		if (ptr[0]&0x20) {
-			if (smc_hw_get(smc, 1, 1000) < 0)
-				goto end;
-		}
-		if (ptr[0]&0x40) {
-			if (smc_hw_get(smc, 1, 1000) < 0)
-				goto end;
-		}
-		if (ptr[0]&0x80) {
-			if (smc_hw_get(smc, 1, 1000) < 0)
-				goto end;
-
-			ptr = &smc->atr.atr[smc->atr.atr_len-1];
-			t = ptr[0]&0x0F;
-			if (t)
-				only_t0 = 0;
-			if (ptr[0]&0xF0)
-				tnext = 1;
-		}
-	} while (tnext && loop_cnt < 4);
-
-	if (!only_t0)
-		his_len++;
-	smc_hw_get(smc, his_len, 2000);
-
-	pr_dbg("get atr len:%d data: ", smc->atr.atr_len);
-	for (i = 0; i < smc->atr.atr_len; i++)
-		pr_dbg("%02x ", smc->atr.atr[i]);
-	pr_dbg("\n");
-
-#ifdef ATR_OUT_READ
-	if (smc->atr.atr_len) {
-		pr_dbg("reset recv_start %d->0\n", smc->recv_start);
-		smc->recv_start = 0;
-		if (smc->sc_type == SC_INVERSE) {
-			int i;
-			for (i = 0; i < smc->atr.atr_len; i++)
-				smc->recv_buf[smc->recv_start+i] =
-				    smc->atr.atr[i];
-		}
-	}
-#endif
-	return 0;
-
-end:
-	pr_error("read atr failed\n");
-	return -EIO;
-#ifdef ATR_FROM_INT
-#undef smc_hw_get
-#endif
-}
-
-
-void smc_reset_prepare(struct smc_dev *smc)
-{
-	/*reset recv&send buf*/
-	smc->send_start = 0;
-	smc->send_count = 0;
-	smc->recv_start = 0;
-	smc->recv_count = 0;
-
-	/*Read ATR*/
-	smc->atr.atr_len = 0;
-	smc->recv_count = 0;
-	smc->send_count = 0;
-
-	smc->recv_end = 0;
-	smc->send_end = 0;
-
-#ifdef SW_INVERT
-	smc->sc_type = SC_DIRECT;
-	smc->atr_mode = 1;
-#endif
-}
-
-static int smc_hw_reset(struct smc_dev *smc)
-{
-	unsigned long flags;
-	int ret;
-	unsigned long sc_reg0 = SMC_READ_REG(REG0);
-	struct SMCCARD_HW_Reg0 *sc_reg0_reg = (void *)&sc_reg0;
-	unsigned long sc_int;
-	struct SMC_INTERRUPT_Reg *sc_int_reg = (void *)&sc_int;
-
-	pr_dbg("smc read reg0 0x%lx\n", sc_reg0);
-
-	spin_lock_irqsave(&smc->slock, flags);
-	if (smc->cardin)
-		ret = 0;
-	else
-		ret = -ENODEV;
-	spin_unlock_irqrestore(&smc->slock, flags);
-
-	if (ret >= 0) {
-		/*Reset*/
-#ifdef NO_HOT_RESET
-		smc->active = 0;
-#endif
-		if (smc->active) {
-
-			smc_reset_prepare(smc);
-
-			sc_reg0_reg->rst_level = RESET_ENABLE;
-			sc_reg0_reg->clk_en = 1;
-			sc_reg0_reg->etu_divider = ETU_DIVIDER_CLOCK_HZ *
-			    smc->param.f / (smc->param.d*smc->param.freq) - 1;
-			SMC_WRITE_REG(REG0, sc_reg0);
-#ifdef RST_FROM_PIO
-			_gpio_out(smc->reset_pin,
-				RESET_ENABLE,
-				SMC_RESET_PIN_NAME);
-#endif
-
-			udelay(800/smc->param.freq); /*>= 400/f ;*/
-
-			/*disable receive interrupt*/
-			sc_int = SMC_READ_REG(INTR);
-			sc_int_reg->recv_fifo_bytes_threshold_int_mask = 0;
-			SMC_WRITE_REG(INTR, sc_int|0x3FF);
-
-			sc_reg0_reg->rst_level = RESET_DISABLE;
-			sc_reg0_reg->start_atr = 1;
-			SMC_WRITE_REG(REG0, sc_reg0);
-#ifdef RST_FROM_PIO
-			_gpio_out(smc->reset_pin,
-				RESET_DISABLE,
-				SMC_RESET_PIN_NAME);
-#endif
-		} else {
-			smc_hw_deactive(smc);
-
-			udelay(200);
-
-			smc_hw_active(smc);
-
-			smc_reset_prepare(smc);
-
-			sc_reg0_reg->clk_en = 1;
-			sc_reg0_reg->enable = 0;
-			sc_reg0_reg->rst_level = RESET_ENABLE;
-			SMC_WRITE_REG(REG0, sc_reg0);
-#ifdef RST_FROM_PIO
-			if (smc->use_enable_pin) {
-				_gpio_out(smc->enable_pin,
-					smc->enable_level,
-					SMC_RESET_PIN_NAME);
-				udelay(100);
-			}
-			_gpio_out(smc->reset_pin,
-				RESET_ENABLE,
-				SMC_RESET_PIN_NAME);
-#endif
-			udelay(2000); /*>= 400/f ;*/
-
-			/*disable receive interrupt*/
-			sc_int = SMC_READ_REG(INTR);
-			sc_int_reg->recv_fifo_bytes_threshold_int_mask = 0;
-			SMC_WRITE_REG(INTR, sc_int|0x3FF);
-
-			sc_reg0_reg->rst_level = RESET_DISABLE;
-			sc_reg0_reg->start_atr_en = 1;
-			sc_reg0_reg->start_atr = 1;
-			sc_reg0_reg->enable = 1;
-			sc_reg0_reg->etu_divider = ETU_DIVIDER_CLOCK_HZ *
-			    smc->param.f / (smc->param.d*smc->param.freq) - 1;
-			SMC_WRITE_REG(REG0, sc_reg0);
-#ifdef RST_FROM_PIO
-
-			_gpio_out(smc->reset_pin,
-				RESET_DISABLE, SMC_RESET_PIN_NAME);
-#endif
-		}
-
-#if defined(ATR_FROM_INT)
-		/*enable receive interrupt*/
-		sc_int = SMC_READ_REG(INTR);
-		sc_int_reg->recv_fifo_bytes_threshold_int_mask = 1;
-		SMC_WRITE_REG(INTR, sc_int|0x3FF);
-#endif
-
-		/*msleep(atr_delay);*/
-		ret = smc_hw_read_atr(smc);
-
-#ifdef SW_INVERT
-		smc->atr_mode = 0;
-#endif
-
-#if defined(ATR_FROM_INT)
-		/*disable receive interrupt*/
-		sc_int = SMC_READ_REG(INTR);
-		sc_int_reg->recv_fifo_bytes_threshold_int_mask = 0;
-		SMC_WRITE_REG(INTR, sc_int|0x3FF);
-#endif
-
-		/*Disable ATR*/
-		sc_reg0 = SMC_READ_REG(REG0);
-		sc_reg0_reg->start_atr_en = 0;
-		sc_reg0_reg->start_atr = 0;
-		SMC_WRITE_REG(REG0, sc_reg0);
-
-#ifndef DISABLE_RECV_INT
-		sc_int_reg->recv_fifo_bytes_threshold_int_mask = 1;
-#endif
-		SMC_WRITE_REG(INTR, sc_int|0x3FF);
-
-	}
-
-	return ret;
-}
-
-static int smc_hw_get_status(struct smc_dev *smc, int *sret)
-{
-	unsigned long flags;
-#ifndef DET_FROM_PIO
-	unsigned int reg_val;
-	struct SMCCARD_HW_Reg0 *reg = (struct SMCCARD_HW_Reg0 *)&reg_val;
-#endif
-	spin_lock_irqsave(&smc->slock, flags);
-
-#ifdef DET_FROM_PIO
-	smc->cardin = _gpio_in(smc->detect_pin, OWNER_NAME);
-	pr_dbg("get_status: card detect: %d\n", smc->cardin);
-#else
-	reg_val = SMC_READ_REG(REG0);
-	smc->cardin = reg->card_detect;
-	/*pr_error("get_status: smc reg0 %08x,
-	 card detect: %d\n", reg_val, reg->card_detect);*/
-#endif
-	/*pr_dbg("det:%d, det_invert:%d\n",
-	 smc->cardin, smc->detect_invert);*/
-	if (smc->detect_invert)
-		smc->cardin = !smc->cardin;
-
-	*sret = smc->cardin;
-
-	spin_unlock_irqrestore(&smc->slock, flags);
-
-	return 0;
-}
-
-
-static inline void _atomic_wrap_inc(int *p, int wrap)
-{
-	int i = *p;
-	i++;
-	if (i >= wrap)
-		i = 0;
-	*p = i;
-}
-
-static inline void _atomic_wrap_add(int *p, int add, int wrap)
-{
-	int i = *p;
-	i += add;
-	if (i >= wrap)
-		i %= wrap;
-	*p = i;
-}
-
-static inline int smc_can_recv_max(struct smc_dev *smc)
-{
-	int start = smc->recv_start;
-	int end = smc->recv_end;
-
-	if (end >= start)
-		return RECV_BUF_SIZE - end + start;
-	else
-		return start - end;
-}
-
-static int smc_hw_start_send(struct smc_dev *smc)
-{
-	unsigned int sc_status;
-	struct SMC_STATUS_Reg *sc_status_reg =
-		(struct SMC_STATUS_Reg *)&sc_status;
-	u8 byte;
-
-	/*trigger only*/
-	sc_status = SMC_READ_REG(STATUS);
-	if (smc->send_end != smc->send_start &&
-		!sc_status_reg->send_fifo_full_status) {
-		pr_dbg("s i f [%d:%d]\n", smc->send_start, smc->send_end);
-		byte = smc->send_buf[smc->send_end];
-		_atomic_wrap_inc(&smc->send_end, SEND_BUF_SIZE);
-#ifdef SW_INVERT
-		if (smc->sc_type == SC_INVERSE)
-			byte = inv_table[byte];
-#endif
-		SMC_WRITE_REG(FIFO, byte);
-		pr_dbg("send 1st byte to hw\n");
-	}
-
-	return 0;
-}
-
-#ifdef SMC_FIQ
-static irqreturn_t smc_bridge_isr(int irq, void *dev_id)
-{
-	struct smc_dev *smc = (struct smc_dev *)dev_id;
-
-#ifdef DET_FROM_PIO
-	smc->cardin = _gpio_in(smc->detect_pin, SMC_DETECT_PIN_NAME);
-	if (smc->detect_invert)
-		smc->cardin = !smc->cardin;
-#endif
-
-	if (smc->recv_start != smc->recv_end)
-		wake_up_interruptible(&smc->rd_wq);
-	if (smc->send_start == smc->send_end)
-		wake_up_interruptible(&smc->wr_wq);
-
-	return IRQ_HANDLED;
-}
-
-static void smc_irq_handler(void)
-{
-	struct smc_dev *smc = &smc_dev[0];
-	unsigned int sc_status;
-	unsigned int sc_reg0;
-	unsigned int sc_int;
-	struct SMC_STATUS_Reg *sc_status_reg =
-		(struct SMC_STATUS_Reg *)&sc_status;
-	struct SMC_INTERRUPT_Reg *sc_int_reg =
-		(struct SMC_INTERRUPT_Reg *)&sc_int;
-	struct SMCCARD_HW_Reg0 *sc_reg0_reg =
-		(void *)&sc_reg0;
-
-	sc_int = SMC_READ_REG(INTR);
-	/*Fpr("smc intr:0x%x\n", sc_int);*/
-
-	if (sc_int_reg->recv_fifo_bytes_threshold_int) {
-
-		int num = 0;
-
-		sc_status = SMC_READ_REG(STATUS);
-		num = sc_status_reg->recv_fifo_bytes_number;
-
-		if (num > smc_can_recv_max(smc)) {
-			pr_error("receive buffer overflow\n");
-		} else {
-			u8 byte;
-
-			while (sc_status_reg->recv_fifo_bytes_number) {
-				byte = SMC_READ_REG(FIFO);
-#ifdef SW_INVERT
-				if (!smc->atr_mode &&
-					smc->sc_type == SC_INVERSE)
-					byte = inv_table[byte];
-#endif
-				smc->recv_buf[smc->recv_end] = byte;
-				_atomic_wrap_inc(&smc->recv_end, RECV_BUF_SIZE);
-				num++;
-				sc_status = SMC_READ_REG(STATUS);
-				Fpr("F%02x ", byte);
-			}
-			Fpr("Fr > %d bytes\n", num);
-
-			fiq_bridge_pulse_trigger(&smc->smc_fiq_bridge);
-		}
-
-		sc_int_reg->recv_fifo_bytes_threshold_int = 0;
-
-	}
-
-	if (sc_int_reg->send_fifo_last_byte_int) {
-		int start = smc->send_start;
-		int cnt = 0;
-		u8 byte;
-
-		while (1) {
-			sc_status = SMC_READ_REG(STATUS);
-			if (smc->send_end == start ||
-				sc_status_reg->send_fifo_full_status)
-				break;
-
-			byte = smc->send_buf[smc->send_end];
-			Fpr("Fs > %02x ", byte);
-			_atomic_wrap_inc(&smc->send_end, SEND_BUF_SIZE);
-#ifdef SW_INVERT
-			if (smc->sc_type == SC_INVERSE)
-				byte = inv_table[byte];
-#endif
-			SMC_WRITE_REG(FIFO, byte);
-			cnt++;
-		}
-
-		Fpr("Fs > %d bytes\n", cnt);
-
-		if (smc->send_end == start) {
-			sc_int_reg->send_fifo_last_byte_int_mask = 0;
-			sc_int_reg->recv_fifo_bytes_threshold_int_mask = 1;
-			fiq_bridge_pulse_trigger(&smc->smc_fiq_bridge);
-		}
-
-		sc_int_reg->send_fifo_last_byte_int = 0;
-
-	}
-
-	SMC_WRITE_REG(INTR, sc_int|0x3FF);
-
-#ifndef DET_FROM_PIO
-	sc_reg0 = SMC_READ_REG(REG0);
-	smc->cardin = sc_reg0_reg->card_detect;
-	if (smc->detect_invert)
-		smc->cardin = !smc->cardin;
-#endif
-
-	return;
-}
-
-#else
-
-static int transmit_chars(struct smc_dev *smc)
-{
-	unsigned int status;
-	struct SMC_STATUS_Reg *status_r = (struct SMC_STATUS_Reg *)&status;
-	int cnt = 0;
-	u8 byte;
-	int start = smc->send_start;
-
-	while (1) {
-		status = SMC_READ_REG(STATUS);
-		if (smc->send_end == start || status_r->send_fifo_full_status)
-			break;
-
-		byte = smc->send_buf[smc->send_end];
-		Ipr("s > %02x\n", byte);
-		_atomic_wrap_inc(&smc->send_end, SEND_BUF_SIZE);
-#ifdef SW_INVERT
-		if (smc->sc_type == SC_INVERSE)
-			byte = inv_table[byte];
-#endif
-		SMC_WRITE_REG(FIFO, byte);
-		cnt++;
-	}
-
-	Ipr("s > %d bytes\n", cnt);
-	return cnt;
-}
-
-static int receive_chars(struct smc_dev *smc)
-{
-	unsigned int status;
-	unsigned int intr;
-	struct SMC_STATUS_Reg *status_r = (struct SMC_STATUS_Reg *)&status;
-	int cnt = 0;
-	u8 byte;
-
-	status = SMC_READ_REG(STATUS);
-	if (status_r->recv_fifo_empty_status > smc_can_recv_max(smc)) {
-		pr_error("receive buffer overflow\n");
-		return -1;
-	}
-
-	/*clear recv_fifo_bytes_threshold_int_mask or INT lost*/
-	intr = SMC_READ_REG(INTR);
-	SMC_WRITE_REG(INTR, (intr & ~0x103ff));
-
-	status = SMC_READ_REG(STATUS);
-	while (!status_r->recv_fifo_empty_status) {
-		byte = SMC_READ_REG(FIFO);
-#ifdef SW_INVERT
-		if (!smc->atr_mode && smc->sc_type == SC_INVERSE)
-			byte = inv_table[byte];
-#endif
-		smc->recv_buf[smc->recv_end] = byte;
-		_atomic_wrap_inc(&smc->recv_end, RECV_BUF_SIZE);
-		cnt++;
-		status = SMC_READ_REG(STATUS);
-		Ipr("%02x ", byte);
-	}
-	Ipr("r > %d bytes\n", cnt);
-
-	return cnt;
-}
-
-static void smc_irq_bh_handler(unsigned long arg)
-{
-	struct smc_dev *smc = (struct smc_dev *)arg;
-#ifndef DET_FROM_PIO
-	unsigned int sc_reg0;
-	struct SMCCARD_HW_Reg0 *sc_reg0_reg = (void *)&sc_reg0;
-#endif
-
-	/*Read card status*/
-#ifndef DET_FROM_PIO
-	sc_reg0 = SMC_READ_REG(REG0);
-	smc->cardin = sc_reg0_reg->card_detect;
-#else
-	smc->cardin = _gpio_in(smc->detect_pin, SMC_DETECT_PIN_NAME);
-#endif
-	if (smc->detect_invert)
-		smc->cardin = !smc->cardin;
-
-	if (smc->recv_start != smc->recv_end)
-		wake_up_interruptible(&smc->rd_wq);
-	if (smc->send_start == smc->send_end)
-		wake_up_interruptible(&smc->wr_wq);
-
-	return;
-}
-
-
-static irqreturn_t smc_irq_handler(int irq, void *data)
-{
-	struct smc_dev *smc = (struct smc_dev *)data;
-	unsigned int sc_status;
-	unsigned int sc_int;
-	struct SMC_STATUS_Reg *sc_status_reg =
-		(struct SMC_STATUS_Reg *)&sc_status;
-	struct SMC_INTERRUPT_Reg *sc_int_reg =
-		(struct SMC_INTERRUPT_Reg *)&sc_int;
-
-	sc_int = SMC_READ_REG(INTR);
-	Ipr("Int:0x%x\n", sc_int);
-	sc_status = SMC_READ_REG(STATUS);
-	Ipr("Sta:0x%x\n", sc_status);
-
-	/*Receive*/
-	sc_status = SMC_READ_REG(STATUS);
-	if (!sc_status_reg->recv_fifo_empty_status)
-		receive_chars(smc);
-
-	/* Send */
-	sc_status = SMC_READ_REG(STATUS);
-	if (!sc_status_reg->send_fifo_full_status) {
-		transmit_chars(smc);
-		if (smc->send_end == smc->send_start) {
-			sc_int_reg->send_fifo_last_byte_int_mask = 0;
-			sc_int_reg->recv_fifo_bytes_threshold_int_mask = 1;
-		}
-	}
-
-	SMC_WRITE_REG(INTR, sc_int|0x3FF);
-
-	tasklet_schedule(&smc->tasklet);
-
-	return IRQ_HANDLED;
-}
-#endif /*ifdef SMC_FIQ*/
-
-static void smc_dev_deinit(struct smc_dev *smc)
-{
-	if (smc->irq_num != -1) {
-		free_irq(smc->irq_num, &smc);
-		smc->irq_num = -1;
-		tasklet_kill(&smc->tasklet);
-	}
-	if (smc->use_enable_pin)
-		_gpio_free(smc->enable_pin, SMC_ENABLE_PIN_NAME);
-	reset_control_assert(aml_smartcard_reset_ctrl);
-#if 0
-	if (smc->pin_clk_pin != -1)
-		_gpio_free(smc->pin_clk_pin, SMC_CLK_PIN_NAME);
-#endif
-#ifdef DET_FROM_PIO
-	if (smc->detect_pin != NULL)
-		_gpio_free(smc->detect_pin, SMC_DETECT_PIN_NAME);
-#endif
-#ifdef RST_FROM_PIO
-	if (smc->reset_pin != NULL)
-		_gpio_free(smc->reset_pin, SMC_RESET_PIN_NAME);
-#endif
-#ifdef CONFIG_OF
-	if (smc->pinctrl)
-		devm_pinctrl_put(smc->pinctrl);
-#endif
-	if (smc->dev)
-		device_destroy(&smc_class, MKDEV(smc_major, smc->id));
-
-	mutex_destroy(&smc->lock);
-
-	smc->init = 0;
-
-#if defined(MESON_CPU_TYPE_MESON8) && (MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8)
-	CLK_GATE_OFF(SMART_CARD_MPEG_DOMAIN);
-#endif
-
-}
-
-static int _set_gpio(struct smc_dev *smc, struct gpio_desc **gpiod,
-	char *str, int input_output, int output_level)
-{
-	int ret = 0;
-	*gpiod = gpiod_get(&smc->pdev->dev, str);
-	/*pr_dbg("smc _set_gpio %s %p\n", str, *gpiod);*/
-	if (IS_ERR(*gpiod)) {
-		pr_dbg("smc %s request failed\n", str);
-		return -1;
-	}
-	if (input_output == OUTPUT)
-		ret = gpiod_direction_output(*gpiod, output_level);
-	else if (input_output == INPUT)	{
-		ret = gpiod_direction_input(*gpiod);
-		ret |= gpiod_set_pullup(*gpiod, 1);
-	} else
-		pr_dbg("SMC Request gpio direction invalid\n");
-
-	return ret;
-}
-static int smc_dev_init(struct smc_dev *smc, int id)
-{
-#ifndef CONFIG_OF
-	struct resource *res;
-#else
-	int ret;
-	u32 value;
-	char buf[32];
-	const char *dts_str;
-#endif
-
-#if defined(MESON_CPU_TYPE_MESON8) && (MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8)
-	CLK_GATE_ON(SMART_CARD_MPEG_DOMAIN);
-#error
-#endif
-	/*of_match_node(smc_dt_match, smc->pdev->dev.of_node);*/
-	smc->id = id;
-
-#ifdef CONFIG_OF
-	smc->pinctrl = devm_pinctrl_get_select_default(&smc->pdev->dev);
-	if (IS_ERR(smc->pinctrl))
-		return -1;
-
-	of_property_read_string(smc->pdev->dev.of_node,
-		"smc_need_enable_pin", &dts_str);
-	if (strcmp(dts_str, "yes") == 0)
-		smc->use_enable_pin = 1;
-	else
-		smc->use_enable_pin = 0;
-	if (smc->use_enable_pin == 1) {
-		smc->enable_pin = NULL;
-		if (smc->enable_pin == NULL) {
-			snprintf(buf, sizeof(buf), "smc%d_enable_pin", id);
-			_set_gpio(smc, &smc->enable_pin, "enable_pin",
-				OUTPUT, OUTLEVEL_HIGH);
-#else /*CONFIG_OF*/
-			res = platform_get_resource_byname(smc->pdev,
-				IORESOURCE_MEM, buf);
-			if (!res)
-				pr_error("cannot get resource \"%s\"\n", buf);
-			else {
-				smc->enable_pin = res->start;
-				_gpio_request(smc->enable_pin,
-					SMC_ENABLE_PIN_NAME);
-			}
-#endif /*CONFIG_OF*/
-		}
-
-		if (smc->use_enable_pin) {
-			snprintf(buf, sizeof(buf), "smc%d_enable_level", id);
-#ifdef CONFIG_OF
-			ret = of_property_read_u32(smc->pdev->dev.of_node,
-				buf, &value);
-			if (!ret) {
-				smc->enable_level = value;
-				pr_error("%s: %d\n", buf, smc->enable_level);
-				if (smc->enable_pin != NULL) {
-					_gpio_out(smc->enable_pin,
-						!smc->enable_level,
-						SMC_ENABLE_PIN_NAME);
-					pr_error("enable_pin: -->(%d)\n",
-						(!smc->enable_level)?1:0);
-				}
-			} else {
-				pr_error("cannot find resource \"%s\"\n", buf);
-			}
-#else /*CONFIG_OF*/
-			res = platform_get_resource_byname(smc->pdev,
-				IORESOURCE_MEM, buf);
-			if (!res)
-				pr_error("cannot get resource \"%s\"\n", buf);
-			else
-				smc->enable_level = res->start;
-#endif /*CONFIG_OF*/
-		}
-	} else
-		pr_dbg("Smartcard is working with no enable pin\n");
-
-#ifdef CONFIG_OF
-	smc->reset_pin = NULL;
-	ret = _set_gpio(smc, &smc->reset_pin, "reset_pin",
-		OUTPUT, OUTLEVEL_HIGH);
-	if (ret) {
-		pr_dbg("smc reset pin request failed, we can not work now\n");
-		return -1;
-	}
-	ret = of_property_read_u32(smc->pdev->dev.of_node,
-		"reset_level", &value);
-	smc->reset_level = value;
-	pr_dbg("smc reset_level %d\n", value);
-
-#else /*CONFIG_OF*/
-	res = platform_get_resource_byname(smc->pdev, IORESOURCE_MEM, buf);
-	if (!res)
-		pr_error("cannot get resource \"%s\"\n", buf);
-	else
-		smc->reset_level = res->start;
-#endif /*CONFIG_OF*/
-	smc->irq_num = smc0_irq;
-	if (smc->irq_num == -1) {
-		snprintf(buf, sizeof(buf), "smc%d_irq", id);
-#ifdef CONFIG_OF
-		ret = of_property_read_u32(smc->pdev->dev.of_node, buf, &value);
-		if (!ret) {
-			smc->irq_num = value;
-			pr_error("%s: %d\n", buf, smc->irq_num);
-		} else {
-			pr_error("cannot find resource \"%s\"\n", buf);
-			return -1;
-		}
-#else /*CONFIG_OF*/
-		res = platform_get_resource_byname(smc->pdev,
-			IORESOURCE_IRQ, buf);
-		if (!res) {
-			pr_error("cannot get resource \"%s\"\n", buf);
-			return -1;
-		}
-		smc->irq_num = res->start;
-#endif /*CONFIG_OF*/
-	}
-	smc->pin_clk_pinmux_reg = -1;
-	if (smc->pin_clk_pinmux_reg == -1) {
-		snprintf(buf, sizeof(buf), "smc%d_clk_pinmux_reg", id);
-#ifdef CONFIG_OF
-		ret = of_property_read_u32(smc->pdev->dev.of_node, buf, &value);
-		if (!ret) {
-			smc->pin_clk_pinmux_reg = value;
-			pr_error("%s: 0x%x\n", buf, smc->pin_clk_pinmux_reg);
-		} else
-			pr_error("cannot find resource \"%s\"\n", buf);
-#else /*CONFIG_OF*/
-		res = platform_get_resource_byname(smc->pdev,
-			IORESOURCE_MEM, buf);
-		if (!res)
-			pr_error("cannot get resource \"%s\"\n", buf);
-		else
-			smc->pin_clk_pinmux_reg = res->start;
-#endif /*CONFIG_OF*/
-	}
-#if 1
-	smc->pin_clk_pinmux_bit = -1;
-	if (smc->pin_clk_pinmux_bit == -1) {
-		snprintf(buf, sizeof(buf), "smc%d_clk_pinmux_bit", id);
-#ifdef CONFIG_OF
-		ret = of_property_read_u32(smc->pdev->dev.of_node, buf, &value);
-		if (!ret) {
-			smc->pin_clk_pinmux_bit = value;
-			pr_error("%s: 0x%x\n", buf, smc->pin_clk_pinmux_bit);
-		} else
-			pr_error("cannot find resource \"%s\"\n", buf);
-		/*TODO:*/
-#else /*CONFIG_OF*/
-		res = platform_get_resource_byname(smc->pdev,
-			IORESOURCE_MEM, buf);
-		if (!res)
-			pr_error("cannot get resource \"%s\"\n", buf);
-		else
-			smc->pin_clk_pinmux_bit = res->start;
-#endif /*CONFIG_OF*/
-	}
-#endif
-	smc->pin_clk_oen_reg = -1;
-	if (smc->pin_clk_oen_reg == -1) {
-		snprintf(buf, sizeof(buf), "smc%d_clk_oen_reg", id);
-#ifdef CONFIG_OF
-		ret = of_property_read_u32(smc->pdev->dev.of_node, buf, &value);
-		if (!ret) {
-			smc->pin_clk_oen_reg = value;
-			pr_error("%s: 0x%x\n", buf, smc->pin_clk_oen_reg);
-		} else
-			pr_error("cannot find resource \"%s\"\n", buf);
-#else /*CONFIG_OF*/
-		res = platform_get_resource_byname(smc->pdev,
-			IORESOURCE_MEM, buf);
-		if (!res)
-			pr_error("cannot get resource \"%s\"\n", buf);
-		else {
-			smc->pin_clk_oen_reg = res->start;
-#endif /*CONFIG_OF*/
-	}
-
-	smc->pin_clk_out_reg = -1;
-	if (smc->pin_clk_out_reg == -1) {
-		snprintf(buf, sizeof(buf), "smc%d_clk_out_reg", id);
-#ifdef CONFIG_OF
-		ret = of_property_read_u32(smc->pdev->dev.of_node, buf, &value);
-		if (!ret) {
-			smc->pin_clk_out_reg = value;
-			pr_error("%s: 0x%x\n", buf, smc->pin_clk_out_reg);
-		} else {
-			pr_error("cannot find resource \"%s\"\n", buf);
-		}
-#else /*CONFIG_OF*/
-		res = platform_get_resource_byname(smc->pdev,
-			IORESOURCE_MEM, buf);
-		if (!res)
-			pr_error("cannot get resource \"%s\"\n", buf);
-		else
-			smc->pin_clk_out_reg = res->start;
-#endif /*CONFIG_OF*/
-	}
-
-	smc->pin_clk_oebit = -1;
-	if (smc->pin_clk_oebit == -1) {
-		snprintf(buf, sizeof(buf), "smc%d_clk_oebit", id);
-#ifdef CONFIG_OF
-		ret = of_property_read_u32(smc->pdev->dev.of_node, buf, &value);
-		if (!ret) {
-			smc->pin_clk_oebit = value;
-			pr_error("%s: 0x%x\n", buf, smc->pin_clk_oebit);
-		} else {
-			pr_error("cannot find resource \"%s\"\n", buf);
-		}
-#else /*CONFIG_OF*/
-		res = platform_get_resource_byname(smc->pdev,
-			IORESOURCE_MEM, buf);
-		if (!res)
-			pr_error("cannot get resource \"%s\"\n", buf);
-		else
-			smc->pin_clk_oebit = res->start;
-#endif /*CONFIG_OF*/
-	}
-	smc->pin_clk_oubit = -1;
-	if (smc->pin_clk_oubit == -1) {
-		snprintf(buf, sizeof(buf), "smc%d_clk_oubit", id);
-#ifdef CONFIG_OF
-		ret = of_property_read_u32(smc->pdev->dev.of_node, buf, &value);
-		if (!ret) {
-			smc->pin_clk_oubit = value;
-			pr_error("%s: 0x%x\n", buf, smc->pin_clk_oubit);
-		} else {
-			pr_error("cannot find resource \"%s\"\n", buf);
-		}
-#else /*CONFIG_OF*/
-		res = platform_get_resource_byname(smc->pdev,
-			IORESOURCE_MEM, buf);
-		if (!res)
-			pr_error("cannot get resource \"%s\"\n", buf);
-		else
-			smc->pin_clk_oubit = res->start;
-#endif /*CONFIG_OF*/
-	}
-
-#ifdef DET_FROM_PIO
-	smc->detect_pin = NULL;
-	if (smc->detect_pin == NULL) {
-#ifdef CONFIG_OF
-		ret = _set_gpio(smc, &smc->detect_pin, "detect_pin", INPUT, 0);
-		if (ret) {
-			pr_dbg("smc detect_pin request failed, we can not work\n");
-			return -1;
-		}
-#endif
-#else /*CONFIG_OF*/
-		ret = platform_get_resource_byname(smc->pdev,
-			IORESOURCE_MEM, buf);
-		if (!ret) {
-			pr_error("cannot get resource \"%s\"\n", buf);
-		} else {
-			smc->detect_pin = res->start;
-			_gpio_request(smc->detect_pin, SMC_DETECT_PIN_NAME);
-		}
-#endif /*CONFIG_OF*/
-	}
-	if (1) {
-		snprintf(buf, sizeof(buf), "smc%d_clock_source", id);
-#ifdef CONFIG_OF
-		ret = of_property_read_u32(smc->pdev->dev.of_node, buf, &value);
-		if (!ret) {
-			clock_source = value;
-			pr_error("%s: %d\n", buf, clock_source);
-		} else {
-			pr_error("cannot find resource \"%s\"\n", buf);
-			pr_error("using clock source default: %d\n",
-				clock_source);
-		}
-#else /*CONFIG_OF*/
-		res = platform_get_resource_byname(smc->pdev,
-			IORESOURCE_MEM, buf);
-		if (!res) {
-			pr_error("cannot get resource \"%s\"\n", buf);
-			pr_error("using clock source default: %d\n",
-				clock_source);
-		} else {
-			clock_source = res->start;
-		}
-#endif /*CONFIG_OF*/
-	}
-	smc->detect_invert = 0;
-	if (1) {
-		snprintf(buf, sizeof(buf), "smc%d_det_invert", id);
-#ifdef CONFIG_OF
-		ret = of_property_read_u32(smc->pdev->dev.of_node, buf, &value);
-		if (!ret) {
-			smc->detect_invert = value;
-			pr_error("%s: %d\n", buf, smc->detect_invert);
-		} else {
-			pr_error("cannot find resource \"%s\"\n", buf);
-		}
-#else /*CONFIG_OF*/
-		res = platform_get_resource_byname(smc->pdev,
-			IORESOURCE_MEM, buf);
-		if (!res)
-			pr_error("cannot get resource \"%s\"\n", buf);
-		else
-			smc->detect_invert = res->start;
-#endif /*CONFIG_OF*/
-	}
-#if 1
-	smc->enable_5v3v_pin = NULL;
-	if (smc->enable_5v3v_pin == NULL) {
-		snprintf(buf, sizeof(buf), "smc%d_5v3v_pin", id);
-#ifdef CONFIG_OF
-		ret = _set_gpio(smc, &smc->enable_5v3v_pin,
-			"enable_5v3v_pin", OUTPUT, OUTLEVEL_HIGH);
-		if (ret == -1)
-			pr_dbg("smc 5v3v_pin is not working, we might face some problems\n");
-#else /*CONFIG_OF*/
-		res = platform_get_resource_byname(smc->pdev,
-			IORESOURCE_MEM, buf);
-		if (!res) {
-			pr_error("cannot get resource \"%s\"\n", buf);
-		} else {
-			smc->enable_5v3v_pin = res->start;
-			_gpio_request(smc->enable_5v3v_pin,
-				SMC_ENABLE_5V3V_PIN_NAME);
-		}
-#endif /*CONFIG_OF*/
-	}
-#endif
-
-#if 0
-	smc->enable_5v3v_level = 0;
-	if (1) {
-		snprintf(buf, sizeof(buf), "smc%d_5v3v_level", id);
-#ifdef CONFIG_OF
-		ret = of_property_read_u32(smc->pdev->dev.of_node, buf, &value);
-		if (!ret) {
-			smc->enable_5v3v_level = value;
-			pr_error("%s: %d\n", buf, smc->enable_5v3v_level);
-			if (smc->enable_5v3v_pin != -1) {
-				_gpio_out(smc->enable_5v3v_pin,
-					smc->enable_5v3v_level,
-					SMC_ENABLE_5V3V_PIN_NAME);
-				pr_error("5v3v_pin: -->(%d)\n",
-					(smc->enable_5v3v_level) ? 1 : 0);
-			}
-		} else {
-			pr_error("cannot find resource \"%s\"\n", buf);
-		}
-#else /*CONFIG_OF*/
-		res = platform_get_resource_byname(smc->pdev,
-			IORESOURCE_MEM, buf);
-		if (!res)
-			pr_error("cannot get resource \"%s\"\n", buf);
-		else
-			smc->enable_5v3v_level = res->start;
-#endif /*CONFIG_OF*/
-	}
-#endif
-
-	init_waitqueue_head(&smc->rd_wq);
-	init_waitqueue_head(&smc->wr_wq);
-
-	spin_lock_init(&smc->slock);
-	mutex_init(&smc->lock);
-
-#ifdef SMC_FIQ
-	{
-		int r = -1;
-		smc->smc_fiq_bridge.handle = smc_bridge_isr;
-		smc->smc_fiq_bridge.key = (u32)smc;
-		smc->smc_fiq_bridge.name = "smc_bridge_isr";
-		r = register_fiq_bridge_handle(&smc->smc_fiq_bridge);
-		if (r) {
-			pr_error("smc fiq bridge register error.\n");
-			return -1;
-		}
-	}
-	request_fiq(smc->irq_num, &smc_irq_handler);
-#else
-	smc->irq_num = request_irq(smc->irq_num,
-			(irq_handler_t)smc_irq_handler,
-			IRQF_SHARED, "smc", smc);
-	if (smc->irq_num < 0) {
-		pr_error("request irq error!\n");
-		smc_dev_deinit(smc);
-		return -1;
-	}
-
-	tasklet_init(&smc->tasklet, smc_irq_bh_handler, (unsigned long)smc);
-#endif
-	snprintf(buf, sizeof(buf), "smc%d", smc->id);
-	smc->dev = device_create(&smc_class,
-		NULL, MKDEV(smc_major, smc->id), smc, buf);
-	if (!smc->dev) {
-		pr_error("create device error!\n");
-		smc_dev_deinit(smc);
-		return -1;
-	}
-
-	smc_default_init(smc);
-
-	smc->init = 1;
-
-	smc_hw_setup(smc);
-
-	return 0;
-}
-
-static int smc_open(struct inode *inode, struct file *filp)
-{
-	int id = iminor(inode);
-	struct smc_dev *smc = NULL;
-	id = 0;
-	smc = &smc_dev[id];
-	mutex_init(&smc->lock);
-	mutex_lock(&smc->lock);
-
-#ifdef FILE_DEBUG
-	open_debug();
-#endif
-
-	if (smc->used) {
-		mutex_unlock(&smc->lock);
-		pr_error("smartcard %d already openned!", id);
-		return -EBUSY;
-	}
-
-	smc->used = 1;
-
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
-	switch_mod_gate_by_name("smart_card", 1);
-#endif
-
-	mutex_unlock(&smc->lock);
-
-	filp->private_data = smc;
-
-	return 0;
-}
-
-static int smc_close(struct inode *inode, struct file *filp)
-{
-	struct smc_dev *smc = (struct smc_dev *)filp->private_data;
-
-	mutex_lock(&smc->lock);
-
-	smc_hw_deactive(smc);
-
-#ifndef KEEP_PARAM_AFTER_CLOSE
-	smc_default_init(smc);
-#endif
-
-	smc->used = 0;
-
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
-	switch_mod_gate_by_name("smart_card", 0);
-#endif
-
-#ifdef FILE_DEBUG
-	close_debug();
-#endif
-
-	mutex_unlock(&smc->lock);
-
-	return 0;
-}
-
-static ssize_t smc_read(struct file *filp,
-	char __user *buff, size_t size, loff_t *ppos)
-{
-	struct smc_dev *smc = (struct smc_dev *)filp->private_data;
-	unsigned long flags;
-	int ret;
-	int start = 0, end;
-
-	ret = mutex_lock_interruptible(&smc->lock);
-	if (ret)
-		return ret;
-
-	spin_lock_irqsave(&smc->slock, flags);
-	if (ret == 0) {
-
-		start = smc->recv_start;
-		end = smc->recv_end;
-
-		if (!smc->cardin) {
-			ret = -ENODEV;
-		} else if (start == end) {
-			ret = -EAGAIN;
-		} else {
-			ret = (end > start) ? (end-start) :
-			    (RECV_BUF_SIZE-start+end);
-			if (ret > size)
-				ret = size;
-		}
-	}
-
-	if (ret > 0) {
-		int cnt = RECV_BUF_SIZE-start;
-		long cr;
-
-		pr_dbg("read %d bytes\n", ret);
-		if (cnt >= ret) {
-			cr = copy_to_user(buff, smc->recv_buf+start, ret);
-		} else {
-			int cnt1 = ret-cnt;
-			cr = copy_to_user(buff, smc->recv_buf+start, cnt);
-			cr = copy_to_user(buff+cnt, smc->recv_buf, cnt1);
-		}
-		_atomic_wrap_add(&smc->recv_start, ret, RECV_BUF_SIZE);
-	}
-	spin_unlock_irqrestore(&smc->slock, flags);
-
-	mutex_unlock(&smc->lock);
-
-	return ret;
-}
-
-static ssize_t smc_write(struct file *filp,
-	const char __user *buff, size_t size, loff_t *offp)
-{
-	struct smc_dev *smc = (struct smc_dev *)filp->private_data;
-	unsigned long flags;
-	int ret;
-	unsigned long sc_int;
-	struct SMC_INTERRUPT_Reg *sc_int_reg = (void *)&sc_int;
-	int start = 0, end;
-
-	ret = mutex_lock_interruptible(&smc->lock);
-	if (ret)
-		return ret;
-
-	spin_lock_irqsave(&smc->slock, flags);
-
-	if (ret == 0) {
-
-		start = smc->send_start;
-		end = smc->send_end;
-
-		if (!smc->cardin) {
-			ret = -ENODEV;
-		} else if (start != end) {
-			ret = -EAGAIN;
-		} else {
-			ret = size;
-			if (ret >= SEND_BUF_SIZE)
-				ret = SEND_BUF_SIZE-1;
-		}
-	}
-
-	if (ret > 0) {
-		int cnt = SEND_BUF_SIZE-start;
-		long cr;
-
-		if (cnt >= ret) {
-			cr = copy_from_user(smc->send_buf+start, buff, ret);
-		} else {
-			int cnt1 = ret-cnt;
-			cr = copy_from_user(smc->send_buf+start, buff, cnt);
-			cr = copy_from_user(smc->send_buf, buff+cnt, cnt1);
-		}
-		_atomic_wrap_add(&smc->send_start, ret, SEND_BUF_SIZE);
-	}
-
-	spin_unlock_irqrestore(&smc->slock, flags);
-
-	if (ret > 0) {
-		sc_int = SMC_READ_REG(INTR);
-#ifdef DISABLE_RECV_INT
-		sc_int_reg->recv_fifo_bytes_threshold_int_mask = 0;
-#endif
-		sc_int_reg->send_fifo_last_byte_int_mask = 1;
-		SMC_WRITE_REG(INTR, sc_int|0x3FF);
-
-		pr_dbg("write %d bytes\n", ret);
-
-		smc_hw_start_send(smc);
-	}
-
-	mutex_unlock(&smc->lock);
-
-	return ret;
-}
-
-static unsigned int smc_poll(struct file *filp,
-	struct poll_table_struct *wait)
-{
-	struct smc_dev *smc = (struct smc_dev *)filp->private_data;
-	unsigned int ret = 0;
-	unsigned long flags;
-
-	poll_wait(filp, &smc->rd_wq, wait);
-	poll_wait(filp, &smc->wr_wq, wait);
-
-	spin_lock_irqsave(&smc->slock, flags);
-
-	if (smc->recv_start != smc->recv_end)
-		ret |= POLLIN|POLLRDNORM;
-	if (smc->send_start == smc->send_end)
-		ret |= POLLOUT|POLLWRNORM;
-	if (!smc->cardin)
-		ret |= POLLERR;
-
-	spin_unlock_irqrestore(&smc->slock, flags);
-
-	return ret;
-}
-
-static long smc_ioctl(struct file *file, unsigned int cmd, ulong arg)
-{
-	struct smc_dev *smc = (struct smc_dev *)file->private_data;
-	int ret = 0;
-	long cr;
-	switch (cmd) {
-	case AMSMC_IOC_RESET:
-	{
-		ret = mutex_lock_interruptible(&smc->lock);
-		if (ret)
-			return ret;
-		ret = smc_hw_reset(smc);
-		if (ret >= 0)
-			cr = copy_to_user((void *)arg, &smc->atr,
-				sizeof(struct am_smc_atr));
-		mutex_unlock(&smc->lock);
-	}
-	break;
-	case AMSMC_IOC_GET_STATUS:
-	{
-		int status;
-		smc_hw_get_status(smc, &status);
-		cr = copy_to_user((void *)arg, &status, sizeof(int));
-	}
-	break;
-	case AMSMC_IOC_ACTIVE:
-	{
-		ret = mutex_lock_interruptible(&smc->lock);
-		if (ret)
-			return ret;
-
-		ret = smc_hw_active(smc);
-
-		mutex_unlock(&smc->lock);
-	}
-	break;
-	case AMSMC_IOC_DEACTIVE:
-	{
-		ret = mutex_lock_interruptible(&smc->lock);
-		if (ret)
-			return ret;
-
-		ret = smc_hw_deactive(smc);
-
-		mutex_unlock(&smc->lock);
-	}
-	break;
-	case AMSMC_IOC_GET_PARAM:
-	{
-		ret = mutex_lock_interruptible(&smc->lock);
-		if (ret)
-			return ret;
-		cr = copy_to_user((void *)arg, &smc->param,
-			sizeof(struct am_smc_param));
-
-		mutex_unlock(&smc->lock);
-	}
-	break;
-	case AMSMC_IOC_SET_PARAM:
-	{
-		ret = mutex_lock_interruptible(&smc->lock);
-		if (ret)
-			return ret;
-
-		cr = copy_from_user(&smc->param, (void *)arg,
-			sizeof(struct am_smc_param));
-		ret = smc_hw_set_param(smc);
-
-		mutex_unlock(&smc->lock);
-	}
-	break;
-	default:
-		ret = -EINVAL;
-	break;
-	}
-
-	return ret;
-}
-
-#ifdef CONFIG_COMPAT
-static long smc_ioctl_compat(struct file *filp,
-		unsigned int cmd, unsigned long args)
-{
-	unsigned long ret;
-
-	args = (unsigned long)compat_ptr(args);
-	ret = smc_ioctl(filp, cmd, args);
-	return ret;
-}
-#endif
-
-
-static const struct file_operations smc_fops = {
-	.owner = THIS_MODULE,
-	.open = smc_open,
-	.write = smc_write,
-	.read = smc_read,
-	.release = smc_close,
-	.unlocked_ioctl = smc_ioctl,
-	.poll = smc_poll,
-#ifdef CONFIG_COMPAT
-	.compat_ioctl  = smc_ioctl_compat,
-#endif
-};
-
-static int smc_probe(struct platform_device *pdev)
-{
-	struct smc_dev *smc = NULL;
-	int i, ret;
-	mutex_lock(&smc_lock);
-
-	for (i = 0; i < SMC_DEV_COUNT; i++) {
-		if (!smc_dev[i].init) {
-			smc = &smc_dev[i];
-			break;
-		}
-	}
-	aml_smartcard_reset_ctrl =
-		devm_reset_control_get(&pdev->dev, "smartcard");
-	reset_control_deassert(aml_smartcard_reset_ctrl);
-	if (smc) {
-		smc->init = 1;
-		smc->pdev = pdev;
-		dev_set_drvdata(&pdev->dev, smc);
-		ret = smc_dev_init(smc, i);
-		if (ret < 0)
-			smc = NULL;
-	}
-
-	mutex_unlock(&smc_lock);
-
-	return smc ? 0 : -1;
-}
-
-static int smc_remove(struct platform_device *pdev)
-{
-	struct smc_dev *smc = (struct smc_dev *)dev_get_drvdata(&pdev->dev);
-
-	mutex_lock(&smc_lock);
-
-	smc_dev_deinit(smc);
-
-	mutex_unlock(&smc_lock);
-
-	return 0;
-}
-
-static struct platform_driver smc_driver = {
-	.probe		 = smc_probe,
-	.remove		 = smc_remove,
-	.driver		 = {
-		.name	 = "amlogic-smc",
-		.owner	 = THIS_MODULE,
-		.of_match_table = smc_dt_match,
-	},
-};
-
-static int __init smc_mod_init(void)
-{
-	int ret = -1;
-
-	mutex_init(&smc_lock);
-	smc_major = register_chrdev(0, SMC_DEV_NAME, &smc_fops);
-	if (smc_major <= 0) {
-		mutex_destroy(&smc_lock);
-		pr_error("register chrdev error\n");
-		goto error_register_chrdev;
-	}
-
-	if (class_register(&smc_class) < 0) {
-		pr_error("register class error\n");
-		goto error_class_register;
-	}
-
-	if (platform_driver_register(&smc_driver) < 0) {
-		pr_error("register platform driver error\n");
-		goto error_platform_drv_register;
-	}
-	return 0;
-error_platform_drv_register:
-	class_unregister(&smc_class);
-error_class_register:
-	unregister_chrdev(smc_major, SMC_DEV_NAME);
-error_register_chrdev:
-	mutex_destroy(&smc_lock);
-	return ret;
-}
-
-static void __exit smc_mod_exit(void)
-{
-	platform_driver_unregister(&smc_driver);
-	class_unregister(&smc_class);
-	unregister_chrdev(smc_major, SMC_DEV_NAME);
-	mutex_destroy(&smc_lock);
-}
-
-module_init(smc_mod_init);
-
-module_exit(smc_mod_exit);
-
-MODULE_AUTHOR("AMLOGIC");
-
-MODULE_DESCRIPTION("AMLOGIC smart card driver");
-
-MODULE_LICENSE("GPL");
diff --git a/drivers/amlogic/dvb_tv/smartcard/smartcard.h b/drivers/amlogic/dvb_tv/smartcard/smartcard.h
deleted file mode 100644
index 07a903521b89..000000000000
--- a/drivers/amlogic/dvb_tv/smartcard/smartcard.h
+++ /dev/null
@@ -1,8 +0,0 @@
-#ifndef _AML_SMC_H_
-#define _AML_SMC_H_
-extern int amlogic_gpio_name_map_num(const char *name);
-extern int amlogic_gpio_direction_output(unsigned int pin, int value,
-	const char *owner);
-extern int amlogic_gpio_request(unsigned int pin, const char *label);
-extern unsigned long get_mpeg_clk(void);
-#endif
diff --git a/drivers/amlogic/dvb_tv/smc_reg.h b/drivers/amlogic/dvb_tv/smc_reg.h
deleted file mode 100644
index 6cecdaa5d435..000000000000
--- a/drivers/amlogic/dvb_tv/smc_reg.h
+++ /dev/null
@@ -1,262 +0,0 @@
-/*
- * AMLOGIC Smart card driver.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the named License,
- * or any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- */
-
-#ifndef _SMC_REG_H
-#define _SMC_REG_H
-
-#include <asm/byteorder.h>
-
-#ifdef __LITTLE_ENDIAN
-#ifndef __LITTLE_ENDIAN__
-#define __LITTLE_ENDIAN__
-#endif
-#endif
-
-#define F_DEFAULT 372
-#define D_DEFAULT 1
-#define FREQ_DEFAULT 4000		/*KHz*/
-#define FIFO_THRESHOLD_DEFAULT 1
-#define ETU_DIVIDER_CLOCK_HZ	24000	/* KHz*/
-#define ETU_CLK_SEL  0
-#define ATR_HOLDOFF_EN 1
-#define ATR_CLK_MUX_DEFAULT 4
-#define ATR_HOLDOFF_TCNT_DEFAULT 255
-#define ATR_FINAL_TCNT_DEFAULT 40000
-#define DET_FILTER_SEL_DEFAULT 3
-#define IO_FILTER_SEL_DEFAULT 3
-#define BWT_BASE_DEFAULT 999
-#define N_DEFAULT 0
-#define CWI_DEFAULT 13
-#define BWI_DEFAULT 4
-#define BGT_DEFAULT 22
-
-struct SMCCARD_HW_Reg0 {
-#ifdef __LITTLE_ENDIAN__
-	unsigned etu_divider:16;	/* Bit 15:0*/
-	unsigned first_etu_offset:3;	/* Bit 18:16*/
-	unsigned enable:1;		/* Bit 19*/
-	unsigned recv_fifo_threshold:4;	/* Bit 23:20*/
-	unsigned clk_en:1;		/* Bit 24*/
-	unsigned clk_oen:1;		/* Bit 25*/
-	unsigned rst_level:1;			/* Bit 26*/
-	unsigned start_atr:1;			/* Bit 27*/
-	unsigned unused:1;		/* Bit 28*/
-	unsigned io_level:1;			/* Bit 29*/
-	unsigned card_detect:1;		/* Bit 30*/
-	unsigned start_atr_en:1;	/* Bit 31*/
-#else
-	unsigned start_atr_en:1;	/* Bit 31*/
-	unsigned card_detect:1;		/* Bit 30*/
-	unsigned io_level:1;			/* Bit 29*/
-	unsigned unused:1;		/* Bit 28*/
-	unsigned start_atr:1;			/* Bit 27*/
-	unsigned rst_level:1;			/* Bit 26*/
-	unsigned clk_oen:1;		/* Bit 25*/
-	unsigned clk_en:1;		/* Bit 24*/
-	unsigned recv_fifo_threshold:4;	/* Bit 23:20*/
-	unsigned enable:1;		/* Bit 19*/
-	unsigned first_etu_offset:3;	/* Bit 18:16*/
-	unsigned etu_divider:16;	/* Bit 15:0*/
-#endif
-};
-
-struct SMC_ANSWER_TO_RST {
-#ifdef __LITTLE_ENDIAN__
-	unsigned atr_final_tcnt:16;		/* Bit 15:0*/
-	unsigned atr_holdoff_tcnt:8;	/* Bit 23:16*/
-	unsigned atr_clk_mux:3;		/* Bit 26:24*/
-	unsigned atr_holdoff_en:1;		/* Bit 27*/
-	unsigned etu_clk_sel:2;		/* Bit 29:28*/
-	unsigned unused:2;		/* Bit 31:30*/
-#else
-	unsigned unused:2;		/* Bit 31:30*/
-	unsigned etu_clk_sel:2;		/* Bit 29:28*/
-	unsigned atr_holdoff_en:1;		/* Bit 27*/
-	unsigned atr_clk_mux:3;		/* Bit 26:24*/
-	unsigned atr_holdoff_tcnt:8;	/* Bit 23:16*/
-	unsigned atr_final_tcnt:16;		/* Bit 15:0*/
-#endif
-};
-
-struct SMCCARD_HW_Reg2 {
-#ifdef __LITTLE_ENDIAN__
-	unsigned xmit_invert:1;		/* Bit 0*/
-	unsigned xmit_lsb_msb:1;	/* Bit 1*/
-	unsigned xmit_parity:1;		/* Bit 2*/
-	unsigned xmit_retries:3;	/* Bit 5:3*/
-	unsigned xmit_repeat_dis:1;		/* Bit 6*/
-	unsigned recv_invert:1;		/* Bit 7*/
-	unsigned recv_lsb_msb:1;	/* Bit 8*/
-	unsigned recv_parity:1;		/* Bit 9*/
-	unsigned recv_no_parity:1;		/* Bit 10*/
-	unsigned pulse_irq:1;			/* Bit 11*/
-	unsigned clk_tcnt:8;			/* Bit 19:12*/
-	unsigned det_filter_sel:3;		/* Bit 22:20*/
-	unsigned io_filter_sel:3;	/* Bit 25:23*/
-	unsigned recv_retry_cnt:3;		/* Bit 28:26*/
-	unsigned reserved:1;			/* Bit 29*/
-	unsigned clk_sel:2;		/* Bit 31:30*/
-#else
-	unsigned clk_sel:2;		/* Bit 31:30*/
-	unsigned reserved:1;			/* Bit 29*/
-	unsigned recv_retry_cnt:3;		/* Bit 28:26*/
-	unsigned io_filter_sel:3;	/* Bit 25:23*/
-	unsigned det_filter_sel:3;		/* Bit 22:20*/
-	unsigned clk_tcnt:8;			/* Bit 19:12*/
-	unsigned pulse_irq:1;			/* Bit 11*/
-	unsigned recv_no_parity:1;		/* Bit 10*/
-	unsigned recv_parity:1;		/* Bit 9*/
-	unsigned recv_lsb_msb:1;	/* Bit 8*/
-	unsigned recv_invert:1;		/* Bit 7*/
-	unsigned xmit_repeat_dis:1;		/* Bit 6*/
-	unsigned xmit_retries:3;	/* Bit 5:3*/
-	unsigned xmit_parity:1;		/* Bit 2*/
-	unsigned xmit_lsb_msb:1;	/* Bit 1*/
-	unsigned xmit_invert:1;		/* Bit 0*/
-#endif
-};
-
-struct SMC_STATUS_Reg {
-#ifdef __LITTLE_ENDIAN__
-	unsigned recv_fifo_threshold_status:1;	/* Bit 0*/
-	unsigned send_fifo_last_byte_status:1;	/* Bit 1*/
-	unsigned cwt_expeired_status:1;	/* Bit 2*/
-	unsigned bwt_expeired_status:1;	/* Bit 3*/
-	unsigned write_full_send_fifo_status:1;	/* Bit 4*/
-	unsigned send_and_recv_confilt_status:1;	/* Bit 5*/
-	unsigned recv_error_status:1;	/* Bit 6*/
-	unsigned send_error_status:1;	/* Bit 7*/
-	unsigned rst_expired_status:1;	/* Bit 8*/
-	unsigned card_detect_status:1;	/* Bit 9*/
-	unsigned unused:6;		/* Bit 15:10*/
-	unsigned recv_fifo_bytes_number:4;	/* Bit 19:16*/
-	unsigned recv_fifo_empty_status:1;	/* Bit 20*/
-	unsigned recv_fifo_full_status:1;	/* Bit 21*/
-	unsigned send_fifo_bytes_number:4;	/* Bit 25:22*/
-	unsigned send_fifo_empty_status:1;	/* Bit 26*/
-	unsigned send_fifo_full_status:1;	/* Bit 27*/
-	unsigned recv_data_from_card_status:1;	/* Bit 28*/
-	unsigned recv_module_enable_status:1;	/* Bit 29*/
-	unsigned send_module_enable_status:1;	/* Bit 30*/
-	unsigned wait_for_atr_status:1;	/* Bit 31*/
-#else
-	unsigned wait_for_atr_status:1;	/* Bit 31*/
-	unsigned send_module_enable_status:1;	/* Bit 30*/
-	unsigned recv_module_enable_status:1;	/* Bit 29*/
-	unsigned recv_data_from_card_status:1;	/* Bit 28*/
-	unsigned send_fifo_full_status:1;	/* Bit 27*/
-	unsigned send_fifo_empty_status:1;	/* Bit 26*/
-	unsigned send_fifo_bytes_number:4;	/* Bit 25:22*/
-	unsigned recv_fifo_full_status:1;	/* Bit 21*/
-	unsigned recv_fifo_empty_status:1;	/* Bit 20*/
-	unsigned recv_fifo_bytes_number:4;	/* Bit 19:16*/
-	unsigned unused:6;		/* Bit 15:10*/
-	unsigned card_detect_status:1;	/* Bit 9*/
-	unsigned rst_expired_status:1;	/* Bit 8*/
-	unsigned send_error_status:1;	/* Bit 7*/
-	unsigned recv_error_status:1;	/* Bit 6*/
-	unsigned send_and_recv_confilt_status:1;	/* Bit 5*/
-	unsigned write_full_send_fifo_status:1;	/* Bit 4*/
-	unsigned bwt_expeired_status:1;	/* Bit 3*/
-	unsigned cwt_expeired_status:1;	/* Bit 2*/
-	unsigned send_fifo_last_byte_status:1;	/* Bit 1*/
-	unsigned recv_fifo_threshold_status:1;	/* Bit 0*/
-#endif
-};
-
-struct SMC_INTERRUPT_Reg {
-#ifdef __LITTLE_ENDIAN__
-	unsigned recv_fifo_bytes_threshold_int:1;	/* Bit 0*/
-	unsigned send_fifo_last_byte_int:1;	/* Bit 1*/
-	unsigned cwt_expeired_int:1;	/* Bit 2*/
-	unsigned bwt_expeired_int:1;	/* Bit 3*/
-	unsigned write_full_fifo_int:1;	/* Bit 4*/
-	unsigned send_and_recv_confilt_int:1;	/* Bit 5*/
-	unsigned recv_error_int:1;		/* Bit 6*/
-	unsigned send_error_int:1;		/* Bit 7*/
-	unsigned rst_expired_int:1;		/* Bit 8*/
-	unsigned card_detect_int:1;		/* Bit 9*/
-	unsigned unused1:6;		/* Bit 15:10*/
-	unsigned recv_fifo_bytes_threshold_int_mask:1;	/* Bit 16*/
-	unsigned send_fifo_last_byte_int_mask:1;	/* Bit 17*/
-	unsigned cwt_expeired_int_mask:1;	/* Bit 18*/
-	unsigned bwt_expeired_int_mask:1;	/* Bit 19*/
-	unsigned write_full_fifo_int_mask:1;	/* Bit 20*/
-	unsigned send_and_recv_confilt_int_mask:1;	/* Bit 21*/
-	unsigned recv_error_int_mask:1;	/* Bit 22*/
-	unsigned send_error_int_mask:1;	/* Bit 23*/
-	unsigned rst_expired_int_mask:1;	/* Bit 24*/
-	unsigned card_detect_int_mask:1;	/* Bit 25*/
-	unsigned unused2:6;		/* Bit 31:26*/
-#else
-	unsigned unused2:6;		/* Bit 31:26*/
-	unsigned card_detect_int_mask:1;	/* Bit 25*/
-	unsigned rst_expired_int_mask:1;	/* Bit 24*/
-	unsigned send_error_int_mask:1;	/* Bit 23*/
-	unsigned recv_error_int_mask:1;	/* Bit 22*/
-	unsigned send_and_recv_confilt_int_mask:1;	/* Bit 21*/
-	unsigned write_full_fifo_int_mask:1;	/* Bit 20*/
-	unsigned bwt_expeired_int_mask:1;	/* Bit 19*/
-	unsigned cwt_expeired_int_mask:1;	/* Bit 18*/
-	unsigned send_fifo_last_byte_int_mask:1;	/* Bit 17*/
-	unsigned recv_fifo_bytes_threshold_int_mask:1;	/* Bit 16*/
-	unsigned unused1:6;		/* Bit 15:10*/
-	unsigned card_detect_int:1;		/* Bit 9*/
-	unsigned rst_expired_int:1;		/* Bit 8*/
-	unsigned send_error_int:1;		/* Bit 7*/
-	unsigned recv_error_int:1;		/* Bit 6*/
-	unsigned send_and_recv_confilt_int:1;	/* Bit 5*/
-	unsigned write_full_fifo_int:1;	/* Bit 4*/
-	unsigned bwt_expeired_int:1;	/* Bit 3*/
-	unsigned cwt_expeired_int:1;	/* Bit 2*/
-	unsigned send_fifo_last_byte_int:1;	/* Bit 1*/
-	unsigned recv_fifo_bytes_threshold_int:1;	/* Bit 0*/
-#endif
-};
-
-struct SMCCARD_HW_Reg5 {
-#ifdef __LITTLE_ENDIAN__
-	unsigned bwt_base_time_gnt:16;	/* Bit 15:0*/
-	unsigned btw_detect_en:1;	/* Bit 16*/
-	unsigned cwt_detect_en:1;	/* Bit 17*/
-	unsigned etu_msr_en:1;		/* Bit 18*/
-	unsigned unused:1;		/* Bit 19*/
-	unsigned etu_msr_cnt:12;	/* Bit 31:20*/
-#else
-	unsigned etu_msr_cnt:12;	/* Bit 31:20*/
-	unsigned unused:1;		/* Bit 19*/
-	unsigned etu_msr_en:1;		/* Bit 18*/
-	unsigned cwt_detect_en:1;	/* Bit 17*/
-	unsigned btw_detect_en:1;	/* Bit 16*/
-	unsigned bwt_base_time_gnt:16;	/* Bit 15:0*/
-#endif
-};
-
-struct SMCCARD_HW_Reg6 {
-#ifdef __LITTLE_ENDIAN__
-	unsigned N_parameter:8;		/* Bit 7:0*/
-	unsigned cwi_value:4;			/* Bit 11:8*/
-	unsigned bgt:8;				/* Bit 19:12*/
-	unsigned bwi:4;				/* Bit 23:20*/
-	unsigned unused:8;		/* Bit 31:24*/
-#else
-	unsigned unused:8;		/* Bit 31:24*/
-	unsigned bwi:4;				/* Bit 23:20*/
-	unsigned bgt:8;				/* Bit 19:12*/
-	unsigned cwi_value:4;			/* Bit 11:8*/
-	unsigned N_parameter:8;		/* Bit 7:0*/
-#endif
-};
-
-#endif
-- 
2.11.0

