diff -Naur a/drivers/amlogic/dvb_tv/aml_dvb.c b/drivers/amlogic/dvb_tv/aml_dvb.c
--- a/drivers/amlogic/dvb_tv/aml_dvb.c	2014-12-11 15:40:00.073007604 +0100
+++ b/drivers/amlogic/dvb_tv/aml_dvb.c	2014-12-11 16:07:36.316473946 +0100
@@ -79,6 +79,10 @@
 static int aml_tsdemux_set_skipbyte(int skipbyte);
 static int aml_tsdemux_set_demux(int id);
 
+static void aml_dvb_pinctrl_put (struct aml_dvb *advb);
+static struct pinctrl * __must_check aml_dvb_pinctrl_get_select (
+					struct aml_dvb *advb, const char *name);
+
 static struct tsdemux_ops aml_tsdemux_ops = {
 .reset          = aml_tsdemux_reset,
 .set_reset_flag = aml_tsdemux_set_reset_flag,
@@ -154,8 +158,13 @@
 		dmx->dmx_irq = res->start;
 	}
 #endif
+	if(id == 0)
+		dmx->source = AM_TS_SRC_TS2;
+	else if(id == 1)
+		dmx->source = AM_TS_SRC_TS0;
+	else
+		dmx->source  = -1;
 
-	dmx->source  = -1;
 	dmx->dump_ts_select = 0;
 	dmx->dvr_irq = -1;
 
@@ -999,14 +1008,8 @@
 	}
 
 	if((mode != AM_TS_SERIAL) || (ts->s2p_id != -1)){
-		if(ts->pinctrl){
-			devm_pinctrl_put(ts->pinctrl);
-			ts->pinctrl = NULL;
-		}
 
-		ts->pinctrl  = devm_pinctrl_get_select(&dvb->pdev->dev, pname);
-		if(IS_ERR_VALUE(ts->pinctrl))
-			ts->pinctrl = NULL;
+		ts->pinctrl  = aml_dvb_pinctrl_get_select(dvb, pname);
 		ts->mode     = mode;
 		ts->control  = ctrl;
 
@@ -1109,6 +1112,49 @@
 extern int aml_regist_dmx_class(void);
 extern int aml_unregist_dmx_class(void);
 
+static void aml_dvb_pinctrl_put (struct aml_dvb *advb)
+{
+	/*all dvb pinctrls share the ts[0]'s pinctrl.*/
+    if (advb->ts[0].pinctrl) {
+        devm_pinctrl_put(advb->ts[0].pinctrl);
+        advb->ts[0].pinctrl = NULL;
+    }
+}
+
+static struct pinctrl * __must_check aml_dvb_pinctrl_get_select (
+					struct aml_dvb *advb, const char *name)
+{
+	/*all dvb pinctrls share the ts[0]'s pinctrl.*/
+	struct pinctrl *p = advb->ts[0].pinctrl;
+
+	struct pinctrl_state *s;
+	int ret;
+
+	if (!p) {
+		p = devm_pinctrl_get(&advb->pdev->dev);
+		if (IS_ERR(p)) {
+			return p;
+		}
+		advb->ts[0].pinctrl = p;
+	}
+
+	s = pinctrl_lookup_state(p, name);
+	if (IS_ERR(s)) {
+		pr_error("pinctl:lookup %s fail\n", name);
+		devm_pinctrl_put(p);
+		return ERR_CAST(s);
+	}
+
+	ret = pinctrl_select_state(p, s);
+	if (ret < 0) {
+		pr_error("pinctl:select %s fail\n", name);
+		devm_pinctrl_put(p);
+		return ERR_PTR(ret);
+	}
+
+	return p;
+}
+
 static int aml_dvb_probe(struct platform_device *pdev)
 {
 	struct aml_dvb *advb;
@@ -1158,7 +1204,7 @@
 					}else{
 						snprintf(buf, sizeof(buf), "s_ts%d", i);
 						advb->ts[i].mode    = AM_TS_SERIAL;
-						advb->ts[i].pinctrl = devm_pinctrl_get_select(&pdev->dev, buf);
+						advb->ts[i].pinctrl = aml_dvb_pinctrl_get_select(advb, buf);
 						advb->ts[i].s2p_id  = s2p_id;
 
 						s2p_id++;
@@ -1167,7 +1213,7 @@
 					pr_dbg("%s: parallel\n", buf);
 					snprintf(buf, sizeof(buf), "p_ts%d", i);
 					advb->ts[i].mode    = AM_TS_PARALLEL;
-					advb->ts[i].pinctrl = devm_pinctrl_get_select(&pdev->dev, buf);
+					advb->ts[i].pinctrl = aml_dvb_pinctrl_get_select(advb, buf);
 				}else{
 					advb->ts[i].mode    = AM_TS_DISABLE;
 					advb->ts[i].pinctrl = NULL;
@@ -1229,6 +1275,10 @@
 		if ((ret=aml_dvb_asyncfifo_init(advb, &advb->asyncfifo[i], i))<0) {
 			goto error;
 		}
+		if(i == 0)
+			aml_asyncfifo_hw_set_source(&advb->asyncfifo[i], AM_DMX_0);
+		else if(i == 1)
+			aml_asyncfifo_hw_set_source(&advb->asyncfifo[i], AM_DMX_1);
 	}
 
 	aml_regist_dmx_class();
@@ -1279,10 +1329,7 @@
 	}
 	dvb_unregister_adapter(&advb->dvb_adapter);
 
-	for (i=0; i<TS_IN_COUNT; i++){
-		if(advb->ts[i].pinctrl)
-			devm_pinctrl_put(advb->ts[i].pinctrl);
-	}
+	aml_dvb_pinctrl_put(advb);
 
 	switch_mod_gate_by_name("demux", 0);
 
diff -Naur a/drivers/amlogic/dvb_tv/aml_dvb.h b/drivers/amlogic/dvb_tv/aml_dvb.h
--- a/drivers/amlogic/dvb_tv/aml_dvb.h	2014-12-11 15:40:00.085007509 +0100
+++ b/drivers/amlogic/dvb_tv/aml_dvb.h	2014-12-11 15:54:32.910432233 +0100
@@ -23,14 +23,14 @@
 #endif
 
 
-#include "drivers/media/dvb-core/dvbdev.h"
-#include "drivers/media/dvb-core/demux.h"
-#include "drivers/media/dvb-core/dvb_demux.h"
-#include "drivers/media/dvb-core/dmxdev.h"
-#include "drivers/media/dvb-core/dvb_filter.h"
-#include "drivers/media/dvb-core/dvb_net.h"
-#include "drivers/media/dvb-core/dvb_ringbuffer.h"
-#include "drivers/media/dvb-core/dvb_frontend.h"
+#include "dvbdev.h"
+#include "demux.h"
+#include "dvb_demux.h"
+#include "dmxdev.h"
+#include "dvb_filter.h"
+#include "dvb_net.h"
+#include "dvb_ringbuffer.h"
+#include "dvb_frontend.h"
 
 #include <linux/of.h>
 #include <linux/pinctrl/consumer.h>
diff -Naur a/drivers/amlogic/dvb_tv/avl6211/AV2011/ExtAV2011.c b/drivers/amlogic/dvb_tv/avl6211/AV2011/ExtAV2011.c
--- a/drivers/amlogic/dvb_tv/avl6211/AV2011/ExtAV2011.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/amlogic/dvb_tv/avl6211/AV2011/ExtAV2011.c	2014-12-11 16:13:49.957618635 +0100
@@ -0,0 +1,473 @@
+/*****************************************************************************
+* Tuner sample code
+*
+* History:
+* Date Athor Version Reason
+* ============ ============= ========= =================
+* 1.Apr.29.2010 Version1.0
+*****************************************************************************/
+//#include "Board.h"
+//#include "MsCommon.h"
+//#include "HbCommon.h"
+//#if (FRONTEND_TUNER_TYPE == TUNER_AV2011 && FRONTEND_DEMOD_TYPE == DEMOD_AVL6211)
+#include "ExtAV2011.h"
+#include "IBSP.h"
+#include "IBase.h"
+#include "II2C.h"
+
+#define HB_printf printk
+#define AV2011_R0_PLL_LOCK 0x01
+#define AV2011_Tuner
+
+static AVL_uint16 tuner_crystal = 27; //unit is MHz
+static AVL_uchar auto_scan=0; //0 for normal mode, 1 for Blindscan mode
+static void Time_DELAY_MS(AVL_uint32 ms);
+ //Main function at tuner control
+static AVL_DVBSx_ErrorCode Tuner_control(AVL_uint32 channel_freq,AVL_uint32 bb_sym,struct AVL_Tuner * pTuner);
+// I2C write function ( start register, register array pointer, register length)
+static AVL_DVBSx_ErrorCode AV2011_I2C_write(AVL_uchar reg_start,AVL_uchar* buff,AVL_uchar len,struct AVL_Tuner * pTuner);
+static AVL_DVBSx_ErrorCode AV2011_I2C_Check(struct AVL_Tuner * pTuner);
+AVL_uint16 AVL_DVBSx_AV2011_CalculateLPF(AVL_uint16 uiSymbolRate_10kHz);
+AVL_DVBSx_ErrorCode ExtAV2011_RegInit(struct AVL_Tuner * pTuner);
+static AVL_DVBSx_ErrorCode AV2011_I2C_Read(AVL_uchar regAddr,AVL_uchar* buff,struct AVL_Tuner * pTuner);
+
+
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_ExtAV2011_GetLockStatus(struct AVL_Tuner * pTuner)
+{
+	AVL_DVBSx_ErrorCode r;
+	AVL_uchar uilock;
+
+	//Send register address
+		r = AVL_DVBSx_II2CRepeater_GetOPStatus(pTuner->m_pAVLChip);
+		if( AVL_DVBSx_EC_OK != r )
+		{
+			return(r);
+		}
+		AVL_DVBSx_IBSP_Delay(1);
+		r = AVL_DVBSx_II2CRepeater_ReadData_Multi(  pTuner->m_uiSlaveAddress, &uilock, 0x0B, 1, pTuner->m_pAVLChip );
+		printf("uilock is %x\n",uilock);
+		if( AVL_DVBSx_EC_OK == r )
+		{
+			if( 0 == (uilock & AV2011_R0_PLL_LOCK) )
+			{
+				r = AVL_DVBSx_EC_Running;
+			}
+		}
+	return(r);
+}
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_ExtAV2011_Initialize(struct AVL_Tuner * pTuner) {
+       printf("Javy --- AVL_DVBSx_ExtAV2011_Initialize!!!\n");
+       AVL_DVBSx_ErrorCode r;
+       
+       r = AVL_DVBSx_II2C_Write16(pTuner->m_pAVLChip, rc_tuner_slave_addr_addr, pTuner->m_uiSlaveAddress);
+       r |= AVL_DVBSx_II2C_Write16(pTuner->m_pAVLChip, rc_tuner_use_internal_control_addr, 0);
+       r |= AVL_DVBSx_II2C_Write16(pTuner->m_pAVLChip, rc_tuner_LPF_margin_100kHz_addr, 0);	//clean up the LPF margin for blind scan. for external driver, this must be zero.
+       r |= AVL_DVBSx_II2C_Write16(pTuner->m_pAVLChip, rc_tuner_max_LPF_100kHz_addr, 360);	//set up the right LPF for blind scan to regulate the freq_step. This field should corresponding the flat response part of the LPF.
+       r |= AVL_DVBSx_II2CRepeater_Initialize(pTuner->m_uiI2CBusClock_kHz, pTuner->m_pAVLChip);
+
+	AVL_puint16 rsj;
+	AVL_DVBSx_II2C_Read16( pTuner->m_pAVLChip, rc_tuner_slave_addr_addr, &rsj);
+	printf("rsj is (rc_tuner_slave_addr_addr)%x\n",rsj);
+
+	r |= AV2011_I2C_Check(pTuner);
+       r |= ExtAV2011_RegInit(pTuner);
+       return(r);
+}
+
+/********************************************************************************
+* INT32 Tuner_control(AVL_uint32 channel_freq, AVL_uint32 bb_sym)
+*
+* Arguments:
+* Parameter1: AVL_uint32 channel_freq : Channel freqency
+* Parameter2: AVL_uint32 bb_sym : Baseband Symbol Rate
+*
+* Return Value: INT32 : Result
+*****************************************************************************/
+AVL_DVBSx_ErrorCode ExtAV2011_RegInit(struct AVL_Tuner * pTuner)
+{
+	AVL_uchar reg[50];
+	AVL_uchar reg_start;
+	AVL_DVBSx_ErrorCode r;
+	// Register initial flag
+	//when sym is 0 or 45000, means auto-scan channel.
+	// At Power ON, tuner_initial = 0
+	// do the initial if not do yet.
+		//Tuner Initail registers R0~R41
+		reg[0]=(char) (0x38);
+		reg[1]=(char) (0x00);
+		reg[2]=(char) (0x00);
+		reg[3]=(char) (0x50);
+		reg[4]=(char) (0x1f);
+		reg[5]=(char) (0xa3);
+		reg[6]=(char) (0xfd);
+		reg[7]=(char) (0x58);
+		reg[8]=(char) (0x0e);
+		reg[9]=(char) (0xc2);//0x82 change into 0xc2- Fixed crystal issue
+		reg[10]=(char) (0x88);
+		reg[11]=(char) (0xb4);
+		reg[12]=(char) (0xd6); //RFLP=ON at Power on initial
+		reg[13]=(char) (0x40);
+#ifdef AV2011_Tuner
+		reg[14]=(char) (0x94);
+		reg[15]=(char) (0x9a);
+#else
+		reg[14]=(char) (0x5b);
+		reg[15]=(char) (0x6a);
+#endif
+		reg[16]=(char) (0x66);
+		reg[17]=(char) (0x40);
+		reg[18]=(char) (0x80);
+		reg[19]=(char) (0x2b);
+		reg[20]=(char) (0x6a);
+		reg[21]=(char) (0x50);
+		reg[22]=(char) (0x91);
+		reg[23]=(char) (0x27);
+		reg[24]=(char) (0x8f);
+		reg[25]=(char) (0xcc);
+		reg[26]=(char) (0x21);
+		reg[27]=(char) (0x10);
+		reg[28]=(char) (0x80);
+		reg[29]=(char) (0x02);
+		reg[30]=(char) (0xf5);
+		reg[31]=(char) (0x7f);
+		reg[32]=(char) (0x4a);
+		reg[33]=(char) (0x9b);
+		reg[34]=(char) (0xe0);
+		reg[35]=(char) (0xe0);
+		reg[36]=(char) (0x36);
+		//monsen 20080710. Disble FT-function at Power on initial
+		//reg[37]=(char) (0x02);
+		reg[37]=(char) (0x00);
+		reg[38]=(char) (0xab);
+		reg[39]=(char) (0x97);
+		reg[40]=(char) (0xc5);
+		reg[41]=(char) (0xa8);
+		//monsen 20080709. power on initial at first "Tuner_control()" call
+		// Sequence 1
+		// Send Reg0 ->Reg11
+		reg_start = 0;
+		r =  AV2011_I2C_write(reg_start,reg,12,pTuner);
+		if(r!=AVL_DVBSx_EC_OK){
+			return(r);
+		}
+		// Time delay 1ms
+		Time_DELAY_MS(1);
+		// Sequence 2
+		// Send Reg13 ->Reg24
+		reg_start = 13;
+		r = AV2011_I2C_write(reg_start,reg+13,12,pTuner);
+		if(r!=AVL_DVBSx_EC_OK){
+			return(r);
+		}
+		// Send Reg25 ->Reg35
+		reg_start = 25;
+		r = AV2011_I2C_write(reg_start,reg+25,11,pTuner);
+		if(r!=AVL_DVBSx_EC_OK){
+			return(r);
+		}
+		// Send Reg36 ->Reg41
+		reg_start = 36;
+		r = AV2011_I2C_write(reg_start, reg+36, 6, pTuner);
+		if(r!=AVL_DVBSx_EC_OK){
+			return(r);
+		}
+		// Time delay 1ms
+		Time_DELAY_MS(1);
+		// Sequence 3
+		// send reg12
+		reg_start = 12;
+		r = AV2011_I2C_write(reg_start,reg+12,1,pTuner);
+		if(r!=AVL_DVBSx_EC_OK){
+			return(r);
+		}
+
+
+#if 0
+//rsj for test
+		AVL_uchar buff;
+		AV2011_I2C_Read(reg_start,&buff,pTuner);
+		printf("reg_start is %x,buff is %x  \n",reg_start,buff);
+//rsj
+#endif
+
+		//monsen 20081125, Wait 100 ms
+		Time_DELAY_MS(10);
+		//monsen 20081030, Reinitial again
+		{
+			// Sequence 1
+			// Send Reg0 ->Reg11
+			reg_start = 0;
+			r = AV2011_I2C_write(reg_start,reg,12,pTuner);
+			if(r!=AVL_DVBSx_EC_OK){
+			return(r);
+			}
+			// Time delay 1ms
+			Time_DELAY_MS(1);
+			// Sequence 2
+			// Send Reg13 ->Reg24
+			reg_start = 13;
+			r = AV2011_I2C_write(reg_start,reg+13,12,pTuner);
+			if(r!=AVL_DVBSx_EC_OK){
+			return(r);
+		    }
+			// Send Reg25 ->Reg35
+			reg_start = 25;
+			r = AV2011_I2C_write(reg_start,reg+25,11,pTuner);
+			if(r!=AVL_DVBSx_EC_OK){
+			return(r);
+		    }
+			// Send Reg36 ->Reg41
+			reg_start = 36;
+			r = AV2011_I2C_write(reg_start,reg+36,6,pTuner);
+			if(r!=AVL_DVBSx_EC_OK){
+			return(r);
+			}
+			// Time delay 1ms
+			Time_DELAY_MS(1);
+			// Sequence 3
+			// send reg12
+			reg_start = 12;
+			r = AV2011_I2C_write(reg_start,reg+12,1,pTuner);
+			if(r!=AVL_DVBSx_EC_OK){
+			return(r);
+			}
+		Time_DELAY_MS(5);
+		return(r);
+	}
+}
+
+
+//Wake_Up = 0 Power_Down = 1
+void Tuner_Set_PD (AVL_uint32 val, struct AVL_Tuner * pTuner)
+{
+       AVL_uchar reg12 = 0 ;
+
+       reg12 = (0xd6 & 0xDF) | (val << 5);     
+
+       printf("Javy Set Reg12 : 0x%x\n",reg12);
+       
+       AV2011_I2C_write(12, &reg12,1,pTuner);       
+        /* Time delay ms*/
+       Time_DELAY_MS(5);
+}
+
+
+AVL_DVBSx_ErrorCode Tuner_control(AVL_uint32 channel_freq, AVL_uint32 bb_sym, struct AVL_Tuner * pTuner)
+{
+	AVL_uchar reg[50];
+	AVL_uint32 fracN;
+	AVL_uint32 BW;
+	AVL_uint32 BF;
+	AVL_DVBSx_ErrorCode r;
+	//AVL_uchar auto_scan = 0;// Add flag for "’ßÌ¨"
+	// Register initial flag;
+	auto_scan = 0;
+	//when sym is 0 or 45000, means auto-scan channel.
+	if (bb_sym == 0 || bb_sym == 45000) //auto-scan mode
+	{
+		auto_scan = 1;
+	}
+	Time_DELAY_MS(50);
+   	fracN = (channel_freq + tuner_crystal/2)/tuner_crystal;
+   	if(fracN > 0xff)
+   	fracN = 0xff;
+   	reg[0]=(char) (fracN & 0xff);
+   	fracN = (channel_freq<<17)/tuner_crystal;
+   	fracN = fracN & 0x1ffff;
+   	reg[1]=(char) ((fracN>>9)&0xff);
+   	reg[2]=(char) ((fracN>>1)&0xff);
+   	// reg[3]_D7 is frac<0>, D6~D0 is 0x50
+   	reg[3]=(char) (((fracN<<7)&0x80) | 0x50); // default is 0x50
+   	// Channel Filter Bandwidth Setting.
+   	//"sym" unit is Hz;
+   	if(auto_scan)//’ßÌ¨ requested by BB
+   	{
+   		reg[5] = 0xA3; //BW=27MHz
+   	}
+   	else
+   	{
+   		// rolloff is 35%
+   		BW = bb_sym*135/200;
+   		// monsen 20080726, BB request low IF when sym < 6.5MHz
+   		// add 6M when Rs<6.5M,
+   		if(bb_sym<6500)
+   		{
+   			BW = BW + 6000;
+   		}
+   			// add 2M for LNB frequency shifting
+   		BW = BW + 2000;
+   			// add 8% margin since fc is not very accurate
+   		BW = BW*108/100;
+   			// Bandwidth can be tuned from 4M to 40M
+   		if( BW< 4000)
+   		{
+   			BW = 4000;
+   		}
+   		if( BW> 40000)
+   		{
+   			BW = 40000;
+   		}
+   		BF = (BW*127 + 21100/2) / (21100); // BW(MHz) * 1.27 / 211KHz
+   		reg[5] = (AVL_uchar)BF;//145
+		printk("BF is %d,BW is %d\n",BF,BW);
+   	}
+   	// Sequence 4
+   	// Send Reg0 ->Reg4
+   	Time_DELAY_MS(5);
+   	r = AV2011_I2C_write(0,reg,4,pTuner);
+   	if(r!=AVL_DVBSx_EC_OK)
+      {
+           return(r);
+      }
+	Time_DELAY_MS(5);
+	// Sequence 5
+	// Send Reg5
+	r = AV2011_I2C_write(5, reg+5, 1,pTuner);
+	if(r!=AVL_DVBSx_EC_OK)
+      {
+            return(r);
+      }
+	Time_DELAY_MS(5);
+	// Fine-tune Function Control
+	//Tuner fine-tune gain function block. bit2.
+	//not auto-scan case. enable block function. FT_block=1, FT_EN=1
+	if (!auto_scan)
+	{
+		reg[37] = 0x06;
+		r = AV2011_I2C_write(37, reg+37, 1,pTuner);
+		if(r!=AVL_DVBSx_EC_OK){
+		return(r);
+		}
+		Time_DELAY_MS(5);
+		//Disable RFLP at Lock Channel sequence after reg[37]
+		//RFLP=OFF at Lock Channel sequence
+		// RFLP can be Turned OFF, only at Receving mode.
+		reg[12] = 0x96 + ((1)<<6);	//Loop through MTC_ADD_FIX	
+		//reg[12] = 0x96;
+		r = AV2011_I2C_write(12, reg+12, 1,pTuner);
+		if(r!=AVL_DVBSx_EC_OK){
+		return(r);
+		Time_DELAY_MS(5);
+		}
+	}
+	return r;
+}
+static void Time_DELAY_MS(AVL_uint32 ms)
+{
+	AVL_DVBSx_IBSP_Delay(ms);
+}
+
+AVL_uint16 AVL_DVBSx_AV2011_CalculateLPF(AVL_uint16 uiSymbolRate_10kHz) {
+	AVL_int32 lpf = uiSymbolRate_10kHz;
+	//lpf *= 81;
+	//lpf /= 100;
+	//lpf += 500;
+	return((AVL_uint16)lpf);
+}
+
+static AVL_DVBSx_ErrorCode AV2011_I2C_write(AVL_uchar reg_start,AVL_uchar* buff,AVL_uchar len,struct AVL_Tuner * pTuner)
+{
+	AVL_DVBSx_ErrorCode r=0;
+	AVL_uchar ucTemp[50];
+	int i,uiTimeOut=0;
+	AVL_DVBSx_IBSP_Delay(5);
+
+      //for(i = 0; i < len; i ++)
+      {
+             ucTemp[0] = reg_start;
+             r = AVL_DVBSx_II2CRepeater_GetOPStatus( pTuner->m_pAVLChip);
+             //	 printk("%s  r is %d\n",__FUNCTION__,r);
+             while( r != AVL_DVBSx_EC_OK)
+             {
+                if( uiTimeOut++>100)
+                {
+                     break;
+                }
+                AVL_DVBSx_IBSP_Delay(1);
+                r = AVL_DVBSx_II2CRepeater_GetOPStatus( pTuner->m_pAVLChip);
+             }
+
+
+             for(i = 1; i < len+1; i ++)
+             {
+                 ucTemp[i] = *(buff+i-1);
+             }
+
+             r = AVL_DVBSx_II2CRepeater_SendData(pTuner->m_uiSlaveAddress,ucTemp, len+1, pTuner->m_pAVLChip );
+             if(r != AVL_DVBSx_EC_OK)
+             {
+                 return(r);
+             }
+      }
+	AVL_DVBSx_IBSP_Delay(1);
+	return(r);
+}
+
+static AVL_DVBSx_ErrorCode AV2011_I2C_Read(AVL_uchar regAddr,AVL_uchar* buff,struct AVL_Tuner * pTuner)
+{
+      AVL_DVBSx_ErrorCode r=0;
+      int uiTimeOut=0;
+
+      r = AVL_DVBSx_II2CRepeater_GetOPStatus( pTuner->m_pAVLChip );
+      while( r != AVL_DVBSx_EC_OK)
+      {
+            if( uiTimeOut++>200) 
+            {
+                 break;
+            }
+            AVL_DVBSx_IBSP_Delay(1);
+            r = AVL_DVBSx_II2CRepeater_GetOPStatus( pTuner->m_pAVLChip );
+      }
+	r = AVL_DVBSx_II2CRepeater_ReadData_Multi(pTuner->m_uiSlaveAddress, buff, regAddr/*0x00*/, 1, pTuner->m_pAVLChip);
+	if(r != AVL_DVBSx_EC_OK)
+       {
+		return(r);
+	}
+	return(r);
+}
+
+static AVL_DVBSx_ErrorCode AV2011_I2C_Check(struct AVL_Tuner * pTuner)
+{
+      AVL_uchar regValue,AV2011_address;
+
+      AV2011_address = 0xC0;
+      do
+      {
+          pTuner->m_uiSlaveAddress = AV2011_address;
+          AVL_DVBSx_II2C_Write16(pTuner->m_pAVLChip, rc_tuner_slave_addr_addr, pTuner->m_uiSlaveAddress);
+          regValue=(char) (0x38);
+          if(AV2011_I2C_write(0,&regValue,1,pTuner) == AVL_DVBSx_EC_OK)
+          {
+               regValue = 0;
+               if(AV2011_I2C_Read(0,&regValue,pTuner) == AVL_DVBSx_EC_OK)
+               {
+               	printf("regValue is %x\n",regValue);
+                     if(regValue == 0x38)
+                     {
+                         break;
+                     }
+               }
+          }
+          AV2011_address += 0x02;
+      }while(AV2011_address <= 0xC6);
+      if(AV2011_address > 0xC6)
+      {
+           HB_printf("\n Not find tuner slave address");
+           AV2011_address = tuner_slave_address;
+      }
+      pTuner->m_uiSlaveAddress = AV2011_address;
+//	  pTuner->m_uiSlaveAddress = 0xC0;
+      HB_printf("\n Tuner slave address = 0x%X\n",pTuner->m_uiSlaveAddress);
+      return AVL_DVBSx_EC_OK;
+}
+AVL_DVBSx_ErrorCode AVL_DVBSx_ExtAV2011_Lock(struct AVL_Tuner * pTuner)
+{
+	AVL_DVBSx_ErrorCode r;
+	printf("pTuner->m_uiFrequency_100kHz is %d,pTuner->m_uiLPF_100kHz is %d\n",pTuner->m_uiFrequency_100kHz,pTuner->m_uiLPF_100kHz);
+	r = Tuner_control((AVL_uint32)((pTuner->m_uiFrequency_100kHz)/10), (AVL_uint32)((pTuner->m_uiLPF_100kHz)*100), pTuner);
+	return(r);
+}
+//#endif
+
diff -Naur a/drivers/amlogic/dvb_tv/avl6211/AV2011/ExtAV2011.h b/drivers/amlogic/dvb_tv/avl6211/AV2011/ExtAV2011.h
--- a/drivers/amlogic/dvb_tv/avl6211/AV2011/ExtAV2011.h	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/amlogic/dvb_tv/avl6211/AV2011/ExtAV2011.h	2014-12-11 16:13:49.953618665 +0100
@@ -0,0 +1,24 @@
+#ifndef AV2011_h_h
+#define AV2011_h_h
+//#include "Board.h"
+#include "avl_dvbsx.h"
+#include "II2CRepeater.h"
+#include "ITuner.h"
+
+#ifdef AVL_CPLUSPLUS
+extern "C" {
+#endif
+
+#define tuner_slave_address     0xC0
+#define tuner_I2Cbus_clock      200             //The clock speed of the tuner dedicated I2C bus, in a unit of kHz.
+#define tuner_LPF               340             //The LPF of the tuner,in a unit of 100kHz.
+
+// time delay function ( minisecond )
+AVL_DVBSx_ErrorCode AVL_DVBSx_ExtAV2011_Initialize(struct AVL_Tuner * pTuner);
+AVL_DVBSx_ErrorCode AVL_DVBSx_ExtAV2011_GetLockStatus(struct AVL_Tuner * pTuner);
+AVL_DVBSx_ErrorCode AVL_DVBSx_ExtAV2011_Lock( struct AVL_Tuner * pTuner);
+
+#ifdef AVL_CPLUSPLUS
+}
+#endif
+#endif
diff -Naur a/drivers/amlogic/dvb_tv/avl6211/avlfrontend.c b/drivers/amlogic/dvb_tv/avl6211/avlfrontend.c
--- a/drivers/amlogic/dvb_tv/avl6211/avlfrontend.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/amlogic/dvb_tv/avl6211/avlfrontend.c	2014-12-11 16:13:50.009618235 +0100
@@ -0,0 +1,931 @@
+/*****************************************************************
+**
+**  Copyright (C) 2009 Amlogic,Inc.
+**  All rights reserved
+**        Filename : avlfrontend.c
+**
+**  comment:
+**        Driver for AVL6211 demodulator
+**  author :
+**	    Shijie.Rong@amlogic
+**  version :
+**	    v1.0	 12/3/30
+*****************************************************************/
+
+/*
+    Driver for AVL6211 demodulator
+*/
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/string.h>
+#include <linux/delay.h>
+#include <linux/jiffies.h>
+#include <linux/slab.h>
+#include <linux/platform_device.h>
+#ifdef ARC_700
+#include <asm/arch/am_regs.h>
+#else
+#include <mach/am_regs.h>
+#endif
+#include <linux/i2c.h>
+#include <asm/gpio.h>
+#include "avlfrontend.h"
+#include "LockSignal_Api.h"
+#include <linux/kthread.h>
+#include <mach/gpio.h>
+#include <mach/gpio_data.h>
+
+#include <linux/amlogic/aml_gpio_consumer.h>
+
+#include "../aml_fe.h"
+
+#if 1
+#define pr_dbg	printk
+//#define pr_dbg(fmt, args...) printk( KERN_DEBUG"DVB: " fmt, ## args)
+#else
+#define pr_dbg(fmt, args...)
+#endif
+
+#define pr_error(fmt, args...) printk( KERN_ERR"DVB: " fmt, ## args)
+
+#define M_TUNERMAXLPF_100KHZ	440
+#define bs_start_freq			950				//The start RF frequency, 950MHz
+#define bs_stop_freq			2150			//The stop RF frequency, 2150MHz
+#define Blindscan_Mode   AVL_DVBSx_BS_Slow_Mode	//The Blind scan mode.	AVL_DVBSx_BS_Fast_Mode = 0,AVL_DVBSx_BS_Slow_Mode = 1
+
+extern struct AVL_Tuner *avl6211pTuner[FE_DEV_COUNT];
+extern struct AVL_DVBSx_Chip * pAVLChip_all[FE_DEV_COUNT];
+AVL_semaphore blindscanSem[FE_DEV_COUNT];
+static int blindstart[FE_DEV_COUNT] = { 0, 0};
+struct dvb_frontend *fe_use[FE_DEV_COUNT] = { NULL, NULL };
+struct aml_fe_dev *cur_dvbdev[FE_DEV_COUNT] = { NULL, NULL };
+static int reset_demods = 0; 
+
+
+static char *device_name = "avl6211";
+
+struct aml_fe_dev * avl6211_get_cur_dev(int id)
+{
+	return cur_dvbdev[id];
+}
+
+static int AVL6211_Reset(int reset_gpio)
+{
+	amlogic_gpio_request(reset_gpio,device_name);
+
+	amlogic_gpio_direction_output(reset_gpio, 0, device_name);
+	msleep(300);
+	amlogic_gpio_direction_output(reset_gpio, 1, device_name);
+	return 0;
+}
+
+static int AVL6211_Lnb_Power_Ctrl(int id, int lnb)
+{
+	AVL_DVBSx_ErrorCode r = AVL_DVBSx_EC_OK;
+
+	if(1 == lnb) {
+		r=AVL_DVBSx_IDiseqc_SetLNB1Out(1, pAVLChip_all[id]);	//set LNB1_PIN60 1: Hight 
+/*		if(id == 0) {
+			amlogic_gpio_request(PAD_GPIOAO_8 , device_name);
+			amlogic_gpio_direction_output(PAD_GPIOAO_8, 1, device_name);
+		}else if(id == 1) {
+			amlogic_gpio_request(PAD_GPIOAO_9, device_name);
+			amlogic_gpio_direction_output(PAD_GPIOAO_9, 1, device_name);
+	
+		}*/
+	}
+	else {
+		r=AVL_DVBSx_IDiseqc_SetLNB1Out(0, pAVLChip_all[id]);	//set LNB1_PIN60 1: Low 	
+	/*	if(id == 0) {
+			amlogic_gpio_request(PAD_GPIOAO_8 , device_name);
+			amlogic_gpio_direction_output(PAD_GPIOAO_8, 0, device_name);
+		}else if(id == 1) {
+			amlogic_gpio_request(PAD_GPIOAO_9, device_name);
+			amlogic_gpio_direction_output(PAD_GPIOAO_9, 0, device_name);
+	
+		}*/
+
+	}
+	
+	return r;
+}
+
+static int AVL6211_Tuner_Power_Ctrl(int id, int tunerpwr)
+{
+	if(1==tunerpwr)	AVL_DVBSx_IBase_SetGPIOVal(0, pAVLChip_all[id]);
+	else				AVL_DVBSx_IBase_SetGPIOVal(0, pAVLChip_all[id]);
+	return 0;
+}
+
+static int AVL6211_Ant_Overload_Ctrl(void)
+{
+	return 0;//gpio_get_value(frontend_ANT);
+}
+
+static int	AVL6211_Diseqc_Reset_Overload(struct dvb_frontend* fe)
+{
+		return 0;
+}
+
+static int	AVL6211_Diseqc_Send_Master_Cmd(struct dvb_frontend* fe, struct dvb_diseqc_master_cmd* cmd)
+{
+	struct aml_fe *afe = fe->demodulator_priv;
+	struct aml_fe_dev *dev = afe->dtv_demod;
+	int id = dev->i2c_adap_id - 1;
+	AVL_DVBSx_ErrorCode r = AVL_DVBSx_EC_OK;
+	AVL_uchar ucData[8];
+	int j=100;
+	struct AVL_DVBSx_Diseqc_TxStatus TxStatus;
+	int i;
+	pr_dbg("msg_len is %d,\n data is",cmd->msg_len);
+	for(i=0;i<cmd->msg_len;i++){
+		ucData[i]=cmd->msg[i];
+		printk("%x ",cmd->msg[i]);
+	}
+	
+	r=AVL_DVBSx_IDiseqc_SendModulationData(ucData, cmd->msg_len, pAVLChip_all[id]);
+	if(r != AVL_DVBSx_EC_OK)
+	{
+		pr_dbg("AVL_DVBSx_IDiseqc_SendModulationData failed !\n");
+	}
+	else
+	{
+		do
+		{
+			j--;
+			AVL_DVBSx_IBSP_Delay(1);
+			r= AVL_DVBSx_IDiseqc_GetTxStatus(&TxStatus, pAVLChip_all[id]);
+		}while((TxStatus.m_TxDone != 1)&&j);
+		if(r ==AVL_DVBSx_EC_OK )
+		{
+
+		}
+		else
+		{
+			pr_dbg("AVL_DVBSx_IDiseqc_SendModulationData Err. !\n");
+		}		
+	}
+	return r;
+}
+
+static int	AVL6211_Diseqc_Recv_Slave_Reply(struct dvb_frontend* fe, struct dvb_diseqc_slave_reply* reply)
+{
+		return 0;
+}
+
+static int	AVL6211_Diseqc_Send_Burst(struct dvb_frontend* fe, fe_sec_mini_cmd_t minicmd)
+{
+	struct aml_fe *afe = fe->demodulator_priv;
+	struct aml_fe_dev *dev = afe->dtv_demod;
+	int id = dev->i2c_adap_id - 1;
+	AVL_DVBSx_ErrorCode r = AVL_DVBSx_EC_OK;
+ 	struct AVL_DVBSx_Diseqc_TxStatus sTxStatus;
+	AVL_uchar ucTone = 0;
+	int i=100;
+	#define TONE_COUNT				8
+	if(minicmd == SEC_MINI_A)
+		ucTone = 1;
+	else if(minicmd == SEC_MINI_B)
+		ucTone = 0;
+	else ;
+
+  	r = AVL_DVBSx_IDiseqc_SendTone(ucTone, TONE_COUNT, pAVLChip_all[id]);
+	if(AVL_DVBSx_EC_OK != r)
+	{
+		pr_dbg("\rSend tone %d --- Fail!\n",ucTone);
+	}
+	else
+	{
+	    do
+	    {
+	    	i--;
+			AVL_DVBSx_IBSP_Delay(1);
+		    r =AVL_DVBSx_IDiseqc_GetTxStatus(&sTxStatus, pAVLChip_all[id]);   //Get current status of the Diseqc transmitter data FIFO.
+	    }
+	    while((1 != sTxStatus.m_TxDone)&&i);			//Wait until operation finished.
+	    if(AVL_DVBSx_EC_OK != r)
+	    {
+		    pr_dbg("\rOutput tone %d --- Fail!\n",ucTone);
+	    }
+	}
+	return (r);
+
+}
+
+static int	AVL6211_Set_Tone(struct dvb_frontend* fe, fe_sec_tone_mode_t tone)
+{
+	struct aml_fe *afe = fe->demodulator_priv;
+	struct aml_fe_dev *dev = afe->dtv_demod;
+	int id = dev->i2c_adap_id - 1;
+	AVL_DVBSx_ErrorCode r = AVL_DVBSx_EC_OK;
+	AVL_uchar  uc22kOn = 0;
+	if(SEC_TONE_ON == tone)
+		uc22kOn = 1;
+	else if(SEC_TONE_OFF == tone)
+		uc22kOn = 0;
+	else ;
+	if(uc22kOn)
+	{
+		r=AVL_DVBSx_IDiseqc_StartContinuous(pAVLChip_all[id]);
+	}else{
+		r=AVL_DVBSx_IDiseqc_StopContinuous(pAVLChip_all[id]);
+	}
+	if(r!=AVL_DVBSx_EC_OK)
+	{
+		pr_dbg("[AVL6211_22K_Control] Err:0x%x\n",r);
+	}	
+	
+	return r;
+	
+}
+
+static int	AVL6211_Set_Voltage(struct dvb_frontend* fe, fe_sec_voltage_t voltage)
+{
+	struct aml_fe *afe = fe->demodulator_priv;
+	struct aml_fe_dev *dev = afe->dtv_demod;
+	int id = dev->i2c_adap_id - 1;
+	AVL_DVBSx_ErrorCode r=AVL_DVBSx_EC_OK;	
+	AVL_uchar nValue = 1;
+	if(voltage == SEC_VOLTAGE_OFF){
+		AVL6211_Lnb_Power_Ctrl(id, 0);//lnb power off
+		return 0;
+	}
+
+	if(voltage ==  SEC_VOLTAGE_13)
+		nValue = 0;
+	else if(voltage ==SEC_VOLTAGE_18)
+		nValue = 1;
+	else;	
+	
+	AVL6211_Lnb_Power_Ctrl(id, 1);//lnb power on
+
+	if(1==nValue)
+		r=AVL_DVBSx_IDiseqc_SetLNBOut(1, pAVLChip_all[id]);	//set LNB0_PIN59 1: Hight 
+	else
+		r=AVL_DVBSx_IDiseqc_SetLNBOut(0, pAVLChip_all[id]);	//set LNB0_PIN59 1: Low 
+
+	return r;
+}
+
+static int	AVL6211_Enable_High_Lnb_Voltage(struct dvb_frontend* fe, long arg)
+{
+	return 0;
+}
+
+static void AVL6211_DumpSetting(struct AVL_DVBSx_BlindScanAPI_Setting *pBSsetting)
+{
+	printk(KERN_INFO "AVL6211_DumpSetting+++\n");
+
+	printk(KERN_INFO "m_uiScan_Min_Symbolrate_MHz %d\n", pBSsetting->m_uiScan_Min_Symbolrate_MHz);
+	printk(KERN_INFO "m_uiScan_Max_Symbolrate_MHz %d\n", pBSsetting->m_uiScan_Max_Symbolrate_MHz);
+	printk(KERN_INFO "m_uiScan_Start_Freq_MHz %d\n", pBSsetting->m_uiScan_Start_Freq_MHz);
+	printk(KERN_INFO "m_uiScan_Stop_Freq_MHz %d\n", pBSsetting->m_uiScan_Stop_Freq_MHz);
+	printk(KERN_INFO "m_uiScan_Next_Freq_100KHz %d\n", pBSsetting->m_uiScan_Next_Freq_100KHz);
+	printk(KERN_INFO "m_uiScan_Progress_Per %d\n", pBSsetting->m_uiScan_Progress_Per);
+	printk(KERN_INFO "m_uiScan_Bind_No %d\n", pBSsetting->m_uiScan_Bind_No);
+	printk(KERN_INFO "m_uiTuner_MaxLPF_100kHz %d\n", pBSsetting->m_uiTuner_MaxLPF_100kHz);
+	printk(KERN_INFO "m_uiScan_Center_Freq_Step_100KHz %d\n", pBSsetting->m_uiScan_Center_Freq_Step_100KHz);
+	printk(KERN_INFO "BS_Mode %d\n", pBSsetting->BS_Mode);
+	printk(KERN_INFO "m_uiScaning %d\n", pBSsetting->m_uiScaning);
+	printk(KERN_INFO "m_uiChannelCount %d\n", pBSsetting->m_uiChannelCount);
+	printk(KERN_INFO "m_eSpectrumMode %d\n", pBSsetting->m_eSpectrumMode);
+
+	printk(KERN_INFO "AVL6211_DumpSetting---\n");
+	
+	return;
+}
+
+#if 0
+static int dvbs2_blindscan_task(struct dvbsx_blindscanpara *pbspara)//(struct dvb_frontend* fe, struct dvbsx_blindscanpara *pbspara)
+
+{
+		struct dvbsx_blindscanevent bsevent;
+		AVL_DVBSx_ErrorCode r = AVL_DVBSx_EC_OK;
+		AVL_uint16	index = 0;
+		struct AVL_DVBSx_Channel * pChannel;
+	//	AVL_uchar HandIndex = 0;
+
+		//struct AVL_DVBSx_Chip * pAVLChip = &g_stAvlDVBSxChip[HandIndex];
+		//struct AVL_Tuner * pTuner = &g_stTuner[HandIndex];
+		struct AVL_DVBSx_BlindScanAPI_Setting BSsetting;
+		enum AVL_DVBSx_BlindScanAPI_Status BS_Status;
+		struct AVL_DVBSx_BlindScanAPI_Setting * pBSsetting = &BSsetting;
+		BS_Status = AVL_DVBSx_BS_Status_Init;
+	
+		//This function do all the initialization work.It should be called only once at the beginning.It needn't be recalled when we want to lock a new channel.
+	/*	r = Initialize(pAVLChip,pTuner);
+		if(AVL_DVBSx_EC_OK != r)
+		{
+			printf("Initialization failed !\n");
+			return (r);
+		}
+		printf("Initialization success !\n");*/
+
+		memset(pBSsetting, 0, sizeof(struct AVL_DVBSx_BlindScanAPI_Setting));
+	
+		pBSsetting->m_uiScan_Start_Freq_MHz=pbspara->minfrequency/1000;
+		pBSsetting->m_uiScan_Stop_Freq_MHz=pbspara->maxfrequency/1000;
+		pBSsetting->m_uiScan_Max_Symbolrate_MHz=pbspara->maxSymbolRate/(1000 * 1000);
+		pBSsetting->m_uiScan_Min_Symbolrate_MHz=pbspara->minSymbolRate/(1000 * 1000);
+		
+		while(BS_Status != AVL_DVBSx_BS_Status_Exit)
+			{
+				if(!blindstart){
+					BS_Status = AVL_DVBSx_BS_Status_Cancel;
+					printf("AVL_DVBSx_BS_Status_Cancel\n");
+				}
+				printk(KERN_INFO "BS_Status %d blindstart %d\n", BS_Status, blindstart);
+				switch(BS_Status)
+				{
+				case AVL_DVBSx_BS_Status_Init:			{
+															printk(KERN_INFO "AVL_DVBSx_BS_Status_Init\n");
+														AVL_DVBSx_IBlindScanAPI_Initialize(pBSsetting);//this function set the parameters blind scan process needed.	
+		
+														AVL_DVBSx_IBlindScanAPI_SetFreqRange(pBSsetting, bs_start_freq, bs_stop_freq); //Default scan rang is from 950 to 2150. User may call this function to change scan frequency rang.
+														AVL_DVBSx_IBlindScanAPI_SetScanMode(pBSsetting, Blindscan_Mode);
+		
+														AVL_DVBSx_IBlindScanAPI_SetSpectrumMode(pBSsetting, AVL_DVBSx_Spectrum_Invert); //Default set is AVL_DVBSx_Spectrum_Normal, it must be set correctly according Board HW configuration
+														AVL_DVBSx_IBlindScanAPI_SetMaxLPF(pBSsetting, M_TUNERMAXLPF_100KHZ); //Set Tuner max LPF value, this value will difference according tuner type
+		
+														BS_Status = AVL_DVBSx_BS_Status_Start;
+
+														AVL6211_DumpSetting(pBSsetting);
+														break;
+													}
+		
+				case AVL_DVBSx_BS_Status_Start: 	{	
+															
+														r = AVL_DVBSx_IBlindScanAPI_Start(pAVLChip_all, avl6211pTuner, pBSsetting);
+														printk(KERN_INFO "AVL_DVBSx_BS_Status_Start %d\n", r);
+														if(AVL_DVBSx_EC_OK != r)
+														{
+															BS_Status = AVL_DVBSx_BS_Status_Exit;
+														}
+														else
+														{	
+															
+															bsevent.status = BLINDSCAN_UPDATESTARTFREQ;
+															bsevent.u.m_uistartfreq_khz = avl6211pTuner->m_uiFrequency_100kHz * 100;
+															fe_use->ops.blindscan_ops.info.blindscan_callback(fe_use, &bsevent);
+															BS_Status = AVL_DVBSx_BS_Status_Wait;
+														}
+														break;
+													}
+		
+				case AVL_DVBSx_BS_Status_Wait:		{
+														r = AVL_DVBSx_IBlindScanAPI_GetCurrentScanStatus(pAVLChip_all, pBSsetting);
+														printk(KERN_INFO "AVL_DVBSx_BS_Status_Wait %d %d\n", r, pBSsetting->bsInfo.m_uiChannelCount);
+														if(AVL_DVBSx_EC_GeneralFail == r)
+														{
+															BS_Status = AVL_DVBSx_BS_Status_Exit;
+														}
+														if(AVL_DVBSx_EC_OK == r)
+														{
+															BS_Status = AVL_DVBSx_BS_Status_Adjust;
+														}
+														if(AVL_DVBSx_EC_Running == r)
+														{
+															AVL_DVBSx_IBSP_Delay(100);
+														}
+														break;
+													}
+		
+				case AVL_DVBSx_BS_Status_Adjust:		{
+														r = AVL_DVBSx_IBlindScanAPI_Adjust(pAVLChip_all, pBSsetting);
+														printk(KERN_INFO "AVL_DVBSx_BS_Status_Adjust %d\n", r);
+														if(AVL_DVBSx_EC_OK != r)
+														{
+															BS_Status = AVL_DVBSx_BS_Status_Exit;
+														}
+														BS_Status = AVL_DVBSx_BS_Status_User_Process;
+														break;
+													}
+		
+				case AVL_DVBSx_BS_Status_User_Process:	{
+														printk(KERN_INFO "AVL_DVBSx_BS_Status_User_Process\n");
+														//------------Custom code start-------------------
+														//customer can add the callback function here such as adding TP information to TP list or lock the TP for parsing PSI
+														//Add custom code here; Following code is an example
+		
+														/*----- example 1: print Blindscan progress ----*/
+														printf(" %2d%% \n", AVL_DVBSx_IBlindscanAPI_GetProgress(pBSsetting)); //display progress Percent of blindscan process
+		
+														/*----- example 2: print TP information if found valid TP ----*/
+														while(index < pBSsetting->m_uiChannelCount) //display new TP info found in current stage
+														{
+															pChannel = &pBSsetting->channels[index++];
+															printf("	  Ch%2d: RF: %4d SR: %5d ",index, (pChannel->m_uiFrequency_kHz/1000),(pChannel->m_uiSymbolRate_Hz/1000));
+
+															bsevent.status = BLINDSCAN_UPDATERESULTFREQ;
+															bsevent.u.parameters.frequency = pChannel->m_uiFrequency_kHz;
+															bsevent.u.parameters.u.qpsk.symbol_rate = pChannel->m_uiSymbolRate_Hz;
+															
+															fe_use->ops.blindscan_ops.info.blindscan_callback(fe_use, &bsevent);
+														}	
+														
+														bsevent.status = BLINDSCAN_UPDATEPROCESS;
+														bsevent.u.m_uiprogress = AVL_DVBSx_IBlindscanAPI_GetProgress(pBSsetting);
+														fe_use->ops.blindscan_ops.info.blindscan_callback(fe_use, &bsevent);
+														//------------Custom code end -------------------
+		
+														if ( (AVL_DVBSx_IBlindscanAPI_GetProgress(pBSsetting) < 100))
+															BS_Status = AVL_DVBSx_BS_Status_Start;
+														else											
+															BS_Status = AVL_DVBSx_BS_Status_WaitExit;
+														break;
+													}
+				case AVL_DVBSx_BS_Status_WaitExit:
+													{
+														msleep(50);
+														break;
+													}
+		
+				case AVL_DVBSx_BS_Status_Cancel:		{ 
+														r = AVL_DVBSx_IBlindScanAPI_Exit(pAVLChip_all,pBSsetting);
+														printk(KERN_INFO "AVL_DVBSx_BS_Status_Cancel %d\n", r);
+														BS_Status = AVL_DVBSx_BS_Status_Exit;
+														blindstart=2;
+														break;
+													}
+		
+				default:							{
+														BS_Status = AVL_DVBSx_BS_Status_Cancel;
+														break;
+													}
+					}
+				}
+			return 0;
+
+
+}
+
+
+static struct task_struct *dvbs2_task;
+static int AVL6211_Blindscan_Scan(struct dvb_frontend* fe, struct dvbsx_blindscanpara *pbspara)
+{
+	printk(KERN_INFO "AVL6211_Blindscan_Scan printk\n");
+
+	AVL_DVBSx_IBSP_WaitSemaphore(&blindscanSem);
+	fe_use = fe;
+	blindstart=1;
+	AVL_DVBSx_IBSP_ReleaseSemaphore(&blindscanSem);
+	  dvbs2_task = kthread_create(dvbs2_blindscan_task, pbspara, "dvbs2_task");
+      if(!dvbs2_task){
+      	printk("Unable to start dvbs2 thread.\n");
+     	dvbs2_task = NULL;
+      return -1;
+      }
+	  wake_up_process(dvbs2_task);
+	  return 0;
+}
+
+static int AVL6211_Blindscan_Cancel(struct dvb_frontend* fe)
+{
+		blindstart=0;
+		printk(KERN_INFO "AVL6211_Blindscan_Cancel\n");
+		while(2!=blindstart){
+				pr_dbg("wait for scan exit\n");
+				msleep(100);
+		}
+		/*call do_exit() directly*/
+		dvbs2_task = NULL;
+		fe_use = NULL;
+		return 0;
+}
+#endif
+
+static int initflag[2]= { -1, -1 };
+
+static int AVL6211_Read_Status(struct dvb_frontend *fe, fe_status_t * status)
+{
+	struct aml_fe *afe = fe->demodulator_priv;
+	struct aml_fe_dev *dev = afe->dtv_demod;
+	int id = dev->i2c_adap_id - 1;
+	unsigned char s=0;
+//printk("Get status blindstart:%d.\n",blindstart);
+	if(1==blindstart[id])
+	     s=1;
+         else
+	   s=AVL6211_GETLockStatus(id);
+
+	if(s==1)
+	{
+		*status = FE_HAS_LOCK|FE_HAS_SIGNAL|FE_HAS_CARRIER|FE_HAS_VITERBI|FE_HAS_SYNC;
+	}
+	else
+	{
+		*status = 0;
+	}
+	
+	return  0;
+}
+
+static int AVL6211_Read_Ber(struct dvb_frontend *fe, u32 * ber)
+{
+	struct aml_fe *afe = fe->demodulator_priv;
+	struct aml_fe_dev *dev = afe->dtv_demod;
+	int id = dev->i2c_adap_id - 1;
+	if(1==blindstart[id])
+		return 0;
+	*ber=AVL6211_GETBer(id);
+	return 0;
+}
+
+static int AVL6211_Read_Signal_Strength(struct dvb_frontend *fe, u16 *strength)
+{
+	struct aml_fe *afe = fe->demodulator_priv;
+	struct aml_fe_dev *dev = afe->dtv_demod;
+	int id = dev->i2c_adap_id - 1;
+	if(1==blindstart[id])
+		return 0;
+	*strength=AVL_Get_Level_Percent(pAVLChip_all[id]);
+//	*strength=AVL6211_GETSignalLevel();
+	return 0;
+}
+static int AVL6211_Read_Snr(struct dvb_frontend *fe, u16 * snr)
+{
+	struct aml_fe *afe = fe->demodulator_priv;
+	struct aml_fe_dev *dev = afe->dtv_demod;
+	int id = dev->i2c_adap_id - 1;
+	if(1==blindstart[id])
+		return 0;
+	*snr=AVL_Get_Quality_Percent(pAVLChip_all[id]);
+	//*snr=AVL6211_GETSnr();
+	return 0;
+}
+
+static int AVL6211_Read_Ucblocks(struct dvb_frontend *fe, u32 * ucblocks)
+{
+	ucblocks=NULL;
+	return 0;
+}
+
+static int AVL6211_Set_Frontend(struct dvb_frontend *fe)
+{
+	struct aml_fe *afe = fe->demodulator_priv;
+	struct aml_fe_dev *dev = afe->dtv_demod;
+	int id = dev->i2c_adap_id - 1;
+	
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+
+	int async_ret = 0;
+	pr_dbg("avl6211 set frontend=>frequency=%d,symbol_rate=%d\r\n",c->frequency,c->symbol_rate);
+
+	if(initflag[id]!=0)
+	{
+		pr_dbg("[%s] avl6211 init fail\n",__FUNCTION__);
+		return 0;	
+	}
+//	printk("[AVL6211_Set_Frontend],blindstart is %d\n",blindstart);
+
+	if(1==blindstart[id])
+		return 0;
+	AVL_DVBSx_IBSP_WaitSemaphore(&blindscanSem[id]);
+	if((850000>c->frequency)||(c->frequency>2300000))
+	{
+			c->frequency =945000;
+			pr_dbg("freq is out of range,force to set 945000khz\n");
+	}
+	struct avl6211_state *state = fe->demodulator_priv;
+	struct AVL_DVBSx_Channel Channel;
+	AVL_DVBSx_ErrorCode r = AVL_DVBSx_EC_OK;
+	avl6211pTuner[id]->m_uiFrequency_100kHz=c->frequency/100;
+//	avl6211pTuner->m_uiFrequency_100kHz=15000;
+//	printk("avl6211pTuner m_uiFrequency_100kHz is %d",avl6211pTuner->m_uiFrequency_100kHz);
+	
+	/* r = CPU_Halt(pAVLChip_all);
+	if(AVL_DVBSx_EC_OK != r)
+	{
+		printf("CPU halt failed !\n");
+		return (r);
+	}*/
+
+	//Change the value defined by macro and go back here when we want to lock a new channel.
+//	avl6211pTuner->m_uiFrequency_100kHz = tuner_freq*10;      
+	avl6211pTuner[id]->m_uiSymbolRate_Hz = c->symbol_rate;//c->symbol_rate;//30000000; //symbol rate of the channel to be locked.
+	//This function should be called before locking the tuner to adjust the tuner LPF based on channel symbol rate.
+	AVL_Set_LPF(id, avl6211pTuner[id], avl6211pTuner[id]->m_uiSymbolRate_Hz);
+
+	r=avl6211pTuner[id]->m_pLockFunc(avl6211pTuner[id]);
+	if (AVL_DVBSx_EC_OK != r)
+	{
+		state->freq=c->frequency;
+		state->mode=c->modulation ;
+		state->symbol_rate=c->symbol_rate;
+		AVL_DVBSx_IBSP_ReleaseSemaphore(&blindscanSem[id]);
+ 		pr_dbg("Tuner test failed !\n");
+		return (r);
+	}
+	pr_dbg("Tuner test ok !\n");
+	//msleep(50);
+	fe->ops.asyncinfo.set_frontend_asyncpreproc(fe);
+	async_ret = fe->ops.asyncinfo.set_frontend_asyncwait(fe, 50);
+	if(async_ret > 0){
+		fe->ops.asyncinfo.set_frontend_asyncpostproc(fe, async_ret);
+		AVL_DVBSx_IBSP_ReleaseSemaphore(&blindscanSem[id]);
+		return 0;
+	}	
+	fe->ops.asyncinfo.set_frontend_asyncpostproc(fe, async_ret);	
+	#if 0
+	Channel.m_uiSymbolRate_Hz = c->symbol_rate;      //Change the value defined by macro when we want to lock a new channel.
+	Channel.m_Flags = (CI_FLAG_MANUAL_LOCK_MODE) << CI_FLAG_MANUAL_LOCK_MODE_BIT;		//Manual lock Flag
+									
+	Channel.m_Flags |= (CI_FLAG_IQ_NO_SWAPPED) << CI_FLAG_IQ_BIT;   		//Auto IQ swap
+	Channel.m_Flags |= (CI_FLAG_IQ_AUTO_BIT_AUTO) << CI_FLAG_IQ_AUTO_BIT;			//Auto IQ swap Flag
+													//Support QPSK and 8PSK  dvbs2
+	{
+	#define Coderate				RX_DVBS2_2_3
+	#define Modulation				AVL_DVBSx_MM_QPSK
+	
+		if (Coderate > 16 || Coderate < 6 || Modulation > 3)
+		{			
+			printf("Configure error !\n");
+			return AVL_DVBSx_EC_GeneralFail;
+		}
+		Channel.m_Flags |= (CI_FLAG_DVBS2) << CI_FLAG_DVBS2_BIT;											//Disable automatic standard detection
+		Channel.m_Flags |= (enum AVL_DVBSx_FecRate)(Coderate) << CI_FLAG_CODERATE_BIT;						//Manual config FEC code rate
+		Channel.m_Flags |= ((enum AVL_DVBSx_ModulationMode)(Modulation)) << CI_FLAG_MODULATION_BIT;			//Manual config Modulation
+	}
+	//This function should be called after tuner locked to lock the channel.
+	#else
+	Channel.m_uiSymbolRate_Hz = c->symbol_rate;
+	Channel.m_Flags = (CI_FLAG_IQ_NO_SWAPPED) << CI_FLAG_IQ_BIT;	//Normal IQ
+	Channel.m_Flags |= (CI_FLAG_IQ_AUTO_BIT_AUTO) << CI_FLAG_IQ_AUTO_BIT;	//Enable automatic IQ swap detection
+	Channel.m_Flags |= (CI_FLAG_DVBS2_UNDEF) << CI_FLAG_DVBS2_BIT;			//Enable automatic standard detection
+	#endif
+	r = AVL_DVBSx_IRx_LockChannel(&Channel, pAVLChip_all[id]);  
+	if (AVL_DVBSx_EC_OK != r)
+	{
+		state->freq=c->frequency;
+		state->mode=c->modulation ;
+		state->symbol_rate=c->symbol_rate;	
+		AVL_DVBSx_IBSP_ReleaseSemaphore(&blindscanSem[id]);
+		pr_dbg("Lock channel failed !\n");
+		return (r);
+	}
+	AVL_DVBSx_IBSP_ReleaseSemaphore(&blindscanSem[id]);
+	if (AVL_DVBSx_EC_OK != r)
+	{
+		printf("Lock channel failed !\n");
+		return (r);
+	}
+	int waittime=150;//3s 
+	//Channel lock time increase while symbol rate decrease.Give the max waiting time for different symbolrates.
+	if(c->symbol_rate<5000000)
+	{
+		waittime = 150;//250;       //The max waiting time is 5000ms,considering the IQ swapped status the time should be doubled.
+	}
+	else if(c->symbol_rate<10000000)
+	{
+        waittime = 30;        //The max waiting time is 600ms,considering the IQ swapped status the time should be doubled.
+	}
+	else
+	{
+        waittime = 15;        //The max waiting time is 300ms,considering the IQ swapped status the time should be doubled.
+	} 
+	int lockstatus = 0;
+	fe->ops.asyncinfo.set_frontend_asyncpreproc(fe);
+	while(waittime)
+	{
+		//msleep(20);
+		async_ret = fe->ops.asyncinfo.set_frontend_asyncwait(fe, 20);
+		if(async_ret > 0){
+			break;
+		}
+		
+		lockstatus=AVL6211_GETLockStatus(id);
+		if(1==lockstatus){
+			pr_dbg("lock success !\n");
+			break;
+		}
+		
+		waittime--;
+	}
+	fe->ops.asyncinfo.set_frontend_asyncpostproc(fe, async_ret);
+	
+	if(!AVL6211_GETLockStatus(id))
+		pr_dbg("lock timeout !\n");
+	
+	r=AVL_DVBSx_IRx_ResetErrorStat(pAVLChip_all[id]);
+	if (AVL_DVBSx_EC_OK != r)
+	{
+		state->freq=c->frequency;
+		state->mode=c->modulation ;
+		state->symbol_rate=c->symbol_rate;
+		
+		printf("Reset error status failed !\n");
+		return (r);
+	}
+	
+//	demod_connect(state, p->frequency,p->u.qam.modulation,p->u.qam.symbol_rate);
+	state->freq=c->frequency;
+	state->mode=c->modulation ;
+	state->symbol_rate=c->symbol_rate; //these data will be writed to eeprom
+
+	pr_dbg("avl6211=>frequency=%d,symbol_rate=%d\r\n",c->frequency,c->symbol_rate);
+	return  0;
+}
+
+static int AVL6211_Get_Frontend(struct dvb_frontend *fe)
+{//these content will be writed into eeprom .
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	struct avl6211_state *state = fe->demodulator_priv;
+
+	printk("delivery sys: %d\n", c->delivery_system);
+	c->frequency=state->freq;
+	c->symbol_rate=state->symbol_rate;
+	
+	return 0;
+}
+
+static ssize_t avl_frontend_show_short_circuit(struct class* class, struct class_attribute* attr, char* buf)
+{
+	int ant_overload_status = AVL6211_Ant_Overload_Ctrl();
+	
+	return sprintf(buf, "%d\n", ant_overload_status);
+}
+
+static struct class_attribute avl_frontend_class_attrs[] = {
+	__ATTR(short_circuit,  S_IRUGO | S_IWUSR, avl_frontend_show_short_circuit, NULL),
+	__ATTR_NULL
+};
+
+static struct class avl_frontend_class = {
+	.name = "avl_frontend",
+	.class_attrs = avl_frontend_class_attrs,
+};
+
+static int avl6211_fe_get_ops(struct aml_fe_dev *dev, int mode, void *ops)
+{
+	struct dvb_frontend_ops *fe_ops = (struct dvb_frontend_ops*)ops;
+
+	char *fe_name = "AMLOGIC DVB-S2";
+	memcpy(fe_ops->info.name, fe_name, strlen(fe_name));
+	fe_ops->info.type = FE_QPSK;
+	fe_ops->delsys[0] =  SYS_DVBS;
+	fe_ops->delsys[1] =  SYS_DVBS2;
+	fe_ops->info.frequency_min = 850000;
+	fe_ops->info.frequency_max = 2300000;
+	fe_ops->info.frequency_stepsize = 0;
+	fe_ops->info.frequency_tolerance = 0;
+	fe_ops->info.symbol_rate_min = 1000000;
+	fe_ops->info.symbol_rate_max = 45000000;
+	fe_ops->info.caps = FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |
+			FE_CAN_FEC_5_6 | FE_CAN_FEC_7_8 | FE_CAN_FEC_AUTO |
+			FE_CAN_QPSK | FE_CAN_QAM_16 |
+			FE_CAN_QAM_64 | FE_CAN_QAM_AUTO |
+			FE_CAN_TRANSMISSION_MODE_AUTO |
+			FE_CAN_GUARD_INTERVAL_AUTO |
+			FE_CAN_HIERARCHY_AUTO |
+			FE_CAN_RECOVER |
+			FE_CAN_MUTE_TS;
+
+	fe_ops->set_frontend = AVL6211_Set_Frontend;
+	fe_ops->get_frontend = AVL6211_Get_Frontend;	
+	fe_ops->read_status = AVL6211_Read_Status;
+	fe_ops->read_ber = AVL6211_Read_Ber;
+	fe_ops->read_signal_strength = AVL6211_Read_Signal_Strength;
+	fe_ops->read_snr = AVL6211_Read_Snr;
+	fe_ops->read_ucblocks = AVL6211_Read_Ucblocks;
+
+	fe_ops->diseqc_reset_overload = AVL6211_Diseqc_Reset_Overload;
+	fe_ops->diseqc_send_master_cmd = AVL6211_Diseqc_Send_Master_Cmd;
+	fe_ops->diseqc_recv_slave_reply = AVL6211_Diseqc_Recv_Slave_Reply;
+	fe_ops->diseqc_send_burst = AVL6211_Diseqc_Send_Burst;
+	fe_ops->set_tone = AVL6211_Set_Tone;
+	fe_ops->set_voltage = AVL6211_Set_Voltage;
+	fe_ops->enable_high_lnb_voltage = AVL6211_Enable_High_Lnb_Voltage;
+
+#if 0
+	fe_ops->blindscan_ops.blindscan_scan = AVL6211_Blindscan_Scan;
+	fe_ops->blindscan_ops.blindscan_cancel = AVL6211_Blindscan_Cancel;
+#endif
+	fe_ops->asyncinfo.set_frontend_asyncenable = 1;
+
+	return 0;
+}
+
+static int avl6211_fe_enter_mode(struct aml_fe *fe, int mode)
+{
+	struct aml_fe_dev *dev = fe->dtv_demod;
+	int id = dev->i2c_adap_id - 1;
+	cur_dvbdev[id] = dev;
+	pr_dbg("=========================demod init\r\n");
+	AVL_DVBSx_ErrorCode r = AVL_DVBSx_EC_OK;
+	//init sema
+//	AVL_DVBSx_IBSP_InitSemaphore( &blindscanSem );
+	//reset
+	if(!reset_demods) {
+		AVL6211_Reset(dev->reset_gpio);
+		msleep(100);
+		reset_demods++;
+	}
+	//init
+	r=AVL6211_LockSignal_Init(id);
+	//LBNON
+//	AVL6211_Lnb_Power_Ctrl(1);
+	//tunerpower
+	AVL6211_Tuner_Power_Ctrl(id, 0);	
+//	r=AVL_DVBSx_IDiseqc_StopContinuous(pAVLChip_all);
+	if(AVL_DVBSx_EC_OK != r)
+	{
+		return r;
+	}
+	initflag[id] =0;
+	pr_dbg("0x%x(ptuner),0x%x(pavchip)=========================demod init\r\n",avl6211pTuner[id]->m_uiSlaveAddress,pAVLChip_all[id]->m_SlaveAddr);
+	msleep(200);
+	
+	return 0;
+}
+
+
+static int avl6211_fe_resume(struct aml_fe_dev *dev)
+{
+	
+	int id = dev->i2c_adap_id - 1;	
+	cur_dvbdev[id] = dev;
+	
+	pr_dbg("avl6211_fe_resume \n");
+	AVL_DVBSx_ErrorCode r = AVL_DVBSx_EC_OK;
+	//init sema
+//	AVL_DVBSx_IBSP_InitSemaphore( &blindscanSem );
+	//reset
+//	AVL6211_Reset(dev->reset_gpio);
+//	msleep(100);
+	//init
+	r=AVL6211_LockSignal_Init(id);
+	//LBNON
+//	AVL6211_Lnb_Power_Ctrl(1);
+	//tunerpower
+	AVL6211_Tuner_Power_Ctrl(id, 0);
+//	r=AVL_DVBSx_IDiseqc_StopContinuous(pAVLChip_all);
+
+	r=AVL_DVBSx_IBase_SetGPIODir(0, pAVLChip_all[id]);
+	if(AVL_DVBSx_EC_OK != r)
+	{
+		return r;
+	}
+	initflag[id] =0;
+	pr_dbg("0x%x(ptuner),0x%x(pavchip)=========================demod init\r\n",avl6211pTuner[id]->m_uiSlaveAddress,pAVLChip_all[id]->m_SlaveAddr);
+	msleep(200);
+	return 0;
+
+}
+
+static int avl6211_fe_suspend(struct aml_fe_dev *dev)
+{
+	return 0;
+}
+
+static struct aml_fe_drv avl6211_0_dtv_demod_drv = {
+.id         = AM_DTV_DEMOD_AVL6211,
+.name       = "Avl6211_0",
+.capability = AM_FE_QPSK,
+.get_ops    = avl6211_fe_get_ops,
+.enter_mode = avl6211_fe_enter_mode,
+.suspend    = avl6211_fe_suspend,
+.resume     = avl6211_fe_resume
+};
+
+static struct aml_fe_drv avl6211_1_dtv_demod_drv = {
+.id         = AM_DTV_DEMOD_AVL6211,
+.name       = "Avl6211_1",
+.capability = AM_FE_QPSK,
+.get_ops    = avl6211_fe_get_ops,
+.enter_mode = avl6211_fe_enter_mode,
+.suspend    = avl6211_fe_suspend,
+.resume     = avl6211_fe_resume
+};
+
+static int __init avlfrontend_init(void)
+{
+	AVL_DVBSx_IBSP_InitSemaphore( &blindscanSem[0] );
+	AVL_DVBSx_IBSP_InitSemaphore( &blindscanSem[1] );
+
+	pr_dbg("register avl6211_0 demod driver\n");
+	aml_register_fe_drv(AM_DEV_DTV_DEMOD, &avl6211_0_dtv_demod_drv);
+
+        pr_dbg("register avl6211_1 demod driver\n");
+	return aml_register_fe_drv(AM_DEV_DTV_DEMOD, &avl6211_1_dtv_demod_drv);
+}
+
+
+static void __exit avlfrontend_exit(void)
+{
+	pr_dbg("unregister avl6211_0 demod driver\n");
+	aml_unregister_fe_drv(AM_DEV_DTV_DEMOD, &avl6211_0_dtv_demod_drv);	
+	pr_dbg("unregister avl6211_1 demod driver\n");
+	aml_unregister_fe_drv(AM_DEV_DTV_DEMOD, &avl6211_1_dtv_demod_drv);	
+}
+
+fs_initcall(avlfrontend_init);
+module_exit(avlfrontend_exit);
+
+
+MODULE_DESCRIPTION("avl6211 DVB-S2 Demodulator driver");
+MODULE_AUTHOR("RSJ");
+MODULE_LICENSE("GPL");
+
+
diff -Naur a/drivers/amlogic/dvb_tv/avl6211/include/avl_dvbsx_globals.h b/drivers/amlogic/dvb_tv/avl6211/include/avl_dvbsx_globals.h
--- a/drivers/amlogic/dvb_tv/avl6211/include/avl_dvbsx_globals.h	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/amlogic/dvb_tv/avl6211/include/avl_dvbsx_globals.h	2014-12-11 16:13:50.153617135 +0100
@@ -0,0 +1,361 @@
+/*
+ *           Copyright 2012 Availink, Inc.
+ *
+ *  This software contains Availink proprietary information and
+ *  its use and disclosure are restricted solely to the terms in
+ *  the corresponding written license agreement. It shall not be 
+ *  disclosed to anyone other than valid licensees without
+ *  written permission of Availink, Inc.
+ *
+ */
+
+
+///$Date: 2012-2-9 17:36 $
+///
+#ifndef AVL_DVBSX_GLOBALS_H
+#define AVL_DVBSX_GLOBALS_H
+
+#define raptor_status_addr						  (0x00000860 + 0x0)
+#define rx_rsp_addr                                                             (0x00000200 + 0x0)
+#define rx_cmd_addr                                                             (0x00000400 + 0x0)
+#define i2cm_cmd_addr                                                           (0x00000404 + 0x0)
+#define i2cm_rsp_addr                                                           (0x00000418 + 0x0)
+#define error_msg_addr                                                          (0x0000042c + 0x0)
+#define core_ready_word_addr                                                    (0x00000434 + 0x0)
+#define i2cm_status_addr                                                        (0x00000438 + 0x0)
+#define rx_config_addr                                                          (0x0000043c + 0x0)
+#define rx_state_addr                                                           (0x00000690 + 0x0)
+#define sharemem_addr                                                           (0x000008d8 + 0x0)
+#define patchglobalvar_addr                                                     (0x00002614 + 0x0)
+#define patchtext_addr                                                          (0x00002654 + 0x0)
+#define rom_ver_addr                                                            (0x00100000 + 0x0)
+#define rx_config_rom_addr                                                      (0x00100004 + 0x0)
+#define rp_sleep_wake_status_addr												(0x00002632 + 0x0)
+
+#define	rc_rfagc_pol_addr                                                       (rx_config_addr + 0x0)
+#define	rc_alpha_addr                                                           (rx_config_addr + 0x4)
+#define	rc_equalizer_addr                                                       (rx_config_addr + 0x8)
+#define	rc_internal_decode_mode_addr                                            (rx_config_addr + 0xc)
+#define	rc_format_addr                                                          (rx_config_addr + 0x10)
+#define	rc_input_addr                                                           (rx_config_addr + 0x14)
+#define	rc_interleave_mode_addr                                                 (rx_config_addr + 0x18)
+#define	rc_pkt_err_pol_addr                                                     (rx_config_addr + 0x1c)
+#define	rc_mpeg_mode_addr                                                       (rx_config_addr + 0x20)
+#define	rc_outpin_sel_addr                                                      (rx_config_addr + 0x24)
+#define	rc_pkt_int_pattern_addr                                                 (rx_config_addr + 0x28)
+#define	rc_mpeg_seri_seq_addr                                                   (rx_config_addr + 0x2c)
+#define	rc_alpha_setting_addr                                                   (rx_config_addr + 0x30)
+#define	rc_specinv_addr                                                         (rx_config_addr + 0x34)
+#define	rc_stdout_port_addr                                                     (rx_config_addr + 0x38)
+#define	rc_dvbs_snr_mode_addr                                                   (rx_config_addr + 0x3c)
+#define	rc_blind_scan_avg_blk_num_addr                                          (rx_config_addr + 0x40)
+#define	rc_fec_coderate_addr                                                    (rx_config_addr + 0x44)
+#define	rc_fec_modulation_addr                                                  (rx_config_addr + 0x48)
+#define	rc_show_mod_pilot_addr                                                  (rx_config_addr + 0x4c)
+#define	rc_btr_cd_th_addr                                                       (rx_config_addr + 0x50)
+#define	rc_int_sym_rate_MHz_addr                                                (rx_config_addr + 0x54)
+#define	rc_blind_scan_sweep_range_hz_addr                                       (rx_config_addr + 0x58)
+#define	rc_blind_scan_acq_th_addr                                               (rx_config_addr + 0x5c)
+#define	rc_blind_scan_cd_th_addr                                                (rx_config_addr + 0x60)
+#define	rc_dvbs2_eq_adpt_sw_gain_acq_addr                                       (rx_config_addr + 0x64)
+#define	rc_dvbs_dss_eq_adpt_sw_gain_acq_addr                                    (rx_config_addr + 0x68)
+#define	rc_old_lwm_addr                                                         (rx_config_addr + 0x6c)
+#define	rc_residue_addr                                                         (rx_config_addr + 0x70)
+#define	rc_old_frame_cnt_addr                                                   (rx_config_addr + 0x74)
+#define	rc_error_addr                                                           (rx_config_addr + 0x78)
+#define	rc_patch_ver_addr                                                       (rx_config_addr + 0x7c)
+#define	rc_expected_ROM_CRC_addr                                                (rx_config_addr + 0x80)
+#define	rc_ROM_CRC_start_addr_addr                                              (rx_config_addr + 0x84)
+#define	rc_ROM_CRC_end_addr_addr                                                (rx_config_addr + 0x88)
+#define	rc_modcode_corr_addr                                                    (rx_config_addr + 0x8c)
+#define	rc_softcode_corr_addr                                                   (rx_config_addr + 0x90)
+#define	rc_softcode_uw_addr                                                     (rx_config_addr + 0x94)
+#define	rc_dvbs_ber_addr                                                        (rx_config_addr + 0x98)
+#define	rc_blind_scan_sym_rate_tol_hz_addr                                      (rx_config_addr + 0x9c)
+#define	rc_coarse_num_adjust_factor_addr                                        (rx_config_addr + 0xa0)
+#define	rc_num_freq_candidate_addr                                              (rx_config_addr + 0xa4)
+#define	rc_rfagc_dcm_addr                                                       (rx_config_addr + 0xa6)
+#define	rc_dagc_ref_addr                                                        (rx_config_addr + 0xa8)
+#define	rc_aagc_ref_addr                                                        (rx_config_addr + 0xaa)
+#define	rc_acq_coincidence_threshold_addr                                       (rx_config_addr + 0xac)
+#define	rc_acq_timeout_frames_addr                                              (rx_config_addr + 0xae)
+#define	rc_fec_wait_timeout_frames_addr                                         (rx_config_addr + 0xb0)
+#define	rc_freq_init_est_frames_addr                                            (rx_config_addr + 0xb2)
+#define	rc_freq_est_frames_addr                                                 (rx_config_addr + 0xb4)
+#define	rc_lfsr_fb_invert_addr                                                  (rx_config_addr + 0xb6)
+#define	rc_lfsr_mode_addr                                                       (rx_config_addr + 0xb8)
+#define	rc_pkt_lfsr_en_addr                                                     (rx_config_addr + 0xba)
+#define	rc_mpeg_posedge_addr                                                    (rx_config_addr + 0xbc)
+#define	rc_mpeg_serial_addr                                                     (rx_config_addr + 0xbe)
+#define	rc_seri_rate_frac_n_addr                                                (rx_config_addr + 0xc0)
+#define	rc_seri_rate_frac_d_addr                                                (rx_config_addr + 0xc2)
+#define	rc_para_rate_adj_n_addr                                                 (rx_config_addr + 0xc4)
+#define	rc_para_rate_adj_d_addr                                                 (rx_config_addr + 0xc6)
+#define	rc_show_demod_status_addr                                               (rx_config_addr + 0xc8)
+#define	rc_show_per_addr                                                        (rx_config_addr + 0xca)
+#define	rc_show_ber_addr                                                        (rx_config_addr + 0xcc)
+#define	rc_show_wer_addr                                                        (rx_config_addr + 0xce)
+#define	rc_show_detail_addr                                                     (rx_config_addr + 0xd0)
+#define	rc_show_scatter_addr                                                    (rx_config_addr + 0xd2)
+#define	rc_show_period_frames_addr                                              (rx_config_addr + 0xd4)
+#define	rc_show_coeffs_addr                                                     (rx_config_addr + 0xd6)
+#define	rc_pkt_err_mode_addr                                                    (rx_config_addr + 0xd8)
+#define	rc_uw_lock_det_frames_addr                                              (rx_config_addr + 0xda)
+#define	rc_uw_lock_det_thresh_addr                                              (rx_config_addr + 0xdc)
+#define	rc_ddc_buffer_offset_addr                                               (rx_config_addr + 0xde)
+#define	rc_eq_buffer_offset_addr                                                (rx_config_addr + 0xe0)
+#define	rc_disable_freq_adj_addr                                                (rx_config_addr + 0xe2)
+#define	rc_crc_enabled_addr                                                     (rx_config_addr + 0xe4)
+#define	rc_interleave_shift_addr                                                (rx_config_addr + 0xe6)
+#define	rc_skip_tune_addr                                                       (rx_config_addr + 0xe8)
+#define	rc_skip_freq_est_addr                                                   (rx_config_addr + 0xea)
+#define	rc_uw_corr_peak_num_addr                                                (rx_config_addr + 0xec)
+#define	rc_lock_detect_frm_num_addr                                             (rx_config_addr + 0xee)
+#define	rc_max_demod_reset_num_addr                                             (rx_config_addr + 0xf0)
+#define	rc_max_freq_tune_num_addr                                               (rx_config_addr + 0xf2)
+#define	rc_dagc_acq_gain_addr                                                   (rx_config_addr + 0xf4)
+#define	rc_dagc_trk_gain_addr                                                   (rx_config_addr + 0xf6)
+#define	rc_aagc_acq_gain_addr                                                   (rx_config_addr + 0xf8)
+#define	rc_aagc_trk_gain_addr                                                   (rx_config_addr + 0xfa)
+#define	rc_eq_loop_gain_addr                                                    (rx_config_addr + 0xfc)
+#define	rc_eq_center_tap_position_addr                                          (rx_config_addr + 0xfe)
+#define	rc_eq_cnvg_frames_addr                                                  (rx_config_addr + 0x100)
+#define	rc_dvbs2_eq_adpt_sw_gain_trk_addr                                       (rx_config_addr + 0x102)
+#define	rc_dvbs_dss_eq_adpt_sw_gain_trk_addr                                    (rx_config_addr + 0x104)
+#define	rc_dvbs2_eq_adpt_sw_symbol_acq_addr                                     (rx_config_addr + 0x106)
+#define	rc_dvbs2_eq_adpt_sw_symbol_trk_addr                                     (rx_config_addr + 0x108)
+#define	rc_dvbs_dss_eq_adpt_sw_symbol_acq_addr                                  (rx_config_addr + 0x10a)
+#define	rc_dvbs_dss_eq_adpt_sw_symbol_trk_addr                                  (rx_config_addr + 0x10c)
+#define	rc_pnref_addr                                                           (rx_config_addr + 0x10e)
+#define	rc_dc_comp_acq_gain_addr                                                (rx_config_addr + 0x110)
+#define	rc_dc_comp_trk_gain_addr                                                (rx_config_addr + 0x112)
+#define	rc_dc_comp_init_i_addr                                                  (rx_config_addr + 0x114)
+#define	rc_dc_comp_init_q_addr                                                  (rx_config_addr + 0x116)
+#define	rc_iq_comp_acq_gain_addr                                                (rx_config_addr + 0x118)
+#define	rc_iq_comp_trk_gain_addr                                                (rx_config_addr + 0x11a)
+#define	rc_iq_amp_imb_addr                                                      (rx_config_addr + 0x11c)
+#define	rc_iq_phs_imb_addr                                                      (rx_config_addr + 0x11e)
+#define	rc_dc_comp_enable_addr                                                  (rx_config_addr + 0x120)
+#define	rc_iq_comp_enable_addr                                                  (rx_config_addr + 0x122)
+#define	rc_snr_settle_frames_addr                                               (rx_config_addr + 0x124)
+#define	rc_btr_acq_lpbw_addr                                                    (rx_config_addr + 0x126)
+#define	rc_btr_uw_lpbw_addr                                                     (rx_config_addr + 0x128)
+#define	rc_cpr_lpbw_addr                                                        (rx_config_addr + 0x12a)
+#define	rc_cpr_acq_lpbw_addr                                                    (rx_config_addr + 0x12c)
+#define	rc_cpr_trk_lpbw_addr                                                    (rx_config_addr + 0x12e)
+#define	rc_cpr_freq_acq_rshft_addr                                              (rx_config_addr + 0x130)
+#define	rc_cpr_freq_trk_rshft_np_addr                                           (rx_config_addr + 0x132)
+#define	rc_cpr_freq_trk_ini_rshft_np_addr                                       (rx_config_addr + 0x134)
+#define	rc_cpr_freq_trk_rshft_p_addr                                            (rx_config_addr + 0x136)
+#define	rc_cpr_freq_trk_ini_rshft_p_addr                                        (rx_config_addr + 0x138)
+#define	rc_btr_dwell_time_ksym_addr                                             (rx_config_addr + 0x13a)
+#define	rc_cpr_output_en_addr                                                   (rx_config_addr + 0x13c)
+#define	rc_cpr_lck_window_len_addr                                              (rx_config_addr + 0x13e)
+#define	rc_cpr_lck_unlock_cnt_addr                                              (rx_config_addr + 0x140)
+#define	rc_cpr_lck_thr_cpr_addr                                                 (rx_config_addr + 0x142)
+#define	rc_cpr_dvbs_cnt_len_addr                                                (rx_config_addr + 0x144)
+#define	rc_cpr_freq_swp_upd_rate_addr                                           (rx_config_addr + 0x146)
+#define	rc_cpr_freq_swp_step_addr                                               (rx_config_addr + 0x148)
+#define	rc_cpr_freq_swp_times_addr                                              (rx_config_addr + 0x14a)
+#define	rc_cpr_freq_swp_rng_addr                                                (rx_config_addr + 0x14c)
+#define	rc_cpr_dvbs_dss_acq_lpbw_addr                                           (rx_config_addr + 0x14e)
+#define	rc_cpr_dvbs_dss_trk_lpbw_addr                                           (rx_config_addr + 0x150)
+#define	rc_cpr_freq_swp_init_val_addr                                           (rx_config_addr + 0x152)
+#define	rc_dvbs_dss_snr_est_blk_size_addr                                       (rx_config_addr + 0x154)
+#define	rc_dvbs_dss_snr_est_lpbw_addr                                           (rx_config_addr + 0x156)
+#define	rc_dvbs_dss_fec_init_sel_pkt_number_addr                                (rx_config_addr + 0x158)
+#define	rc_fec_min_indx_repetitions_cm_addr                                     (rx_config_addr + 0x15a)
+#define	rc_fec_max_frame_chk_cm_addr                                            (rx_config_addr + 0x15c)
+#define	rc_dvbs_bypass_bit_descrambler_addr                                     (rx_config_addr + 0x15e)
+#define	rc_int_nom_carrier_freq_MHz_addr                                        (rx_config_addr + 0x160)
+#define	rc_int_dmd_clk_MHz_addr                                                 (rx_config_addr + 0x162)
+#define	rc_int_fec_clk_MHz_addr                                                 (rx_config_addr + 0x164)
+#define	rc_int_mpeg_clk_MHz_addr                                                (rx_config_addr + 0x166)
+#define	rc_int_btr_loop_bandwidth_addr                                          (rx_config_addr + 0x168)
+#define	rc_int_cpr_loop_bandwidth_addr                                          (rx_config_addr + 0x16a)
+#define	rc_int_carrier_freq_half_range_MHz_addr                                 (rx_config_addr + 0x16c)
+#define	rc_int_normalized_freq_step_addr                                        (rx_config_addr + 0x16e)
+#define	rc_int_lock_detect_loop_bw_addr                                         (rx_config_addr + 0x170)
+#define	rc_int_snr_measurement_tolerance_dB_addr                                (rx_config_addr + 0x172)
+#define	rc_dvbs2_low_power_mode_addr                                            (rx_config_addr + 0x174)
+#define	rc_demap_scale_addr                                                     (rx_config_addr + 0x176)
+#define	rc_fec_lock_num_addr                                                    (rx_config_addr + 0x178)
+#define	rc_fec_lock_leak_addr                                                   (rx_config_addr + 0x17a)
+#define	rc_fec_lock_threshold_addr                                              (rx_config_addr + 0x17c)
+#define	rc_dvbs_fec_lock_leak_addr                                              (rx_config_addr + 0x17e)
+#define	rc_dvbs_fec_lock_threshold_addr                                         (rx_config_addr + 0x180)
+#define	rc_modcod_descramble_flag_addr                                          (rx_config_addr + 0x182)
+#define	rc_fec_min_indx_repetitions_addr                                        (rx_config_addr + 0x184)
+#define	rc_dvbs_fec_fcnt_step_addr                                              (rx_config_addr + 0x186)
+#define	rc_fec_only_addr                                                        (rx_config_addr + 0x188)
+#define	rc_toggle_fec_mode_addr                                                 (rx_config_addr + 0x18a)
+#define	rc_fec_bypass_depunc_addr                                               (rx_config_addr + 0x18c)
+#define	rc_fec_max_frame_chk_addr                                               (rx_config_addr + 0x18e)
+#define	rc_dvbs_fec_max_trial_for_same_phase_addr                               (rx_config_addr + 0x190)
+#define	rc_fec_deintrlvr_rs_rst_addr                                            (rx_config_addr + 0x192)
+#define	rc_fec_bypass_coderate_addr                                             (rx_config_addr + 0x194)
+#define	rc_vtrbi_performance_test_addr                                          (rx_config_addr + 0x196)
+#define	rc_fec_pk_thrshld_addr                                                  (rx_config_addr + 0x198)
+#define	rc_dss_fec_max_trial_for_same_phase_addr                                (rx_config_addr + 0x19a)
+#define	rc_dss_fec_fcnt_step_addr                                               (rx_config_addr + 0x19c)
+#define	rc_btr_cd_num_addr                                                      (rx_config_addr + 0x19e)
+#define	rc_accel_track_addr                                                     (rx_config_addr + 0x1a0)
+#define	rc_mpeg_sync_byte_addr                                                  (rx_config_addr + 0x1a2)
+#define	rc_dvbs_equalizer_cnvg_iter_no_addr                                     (rx_config_addr + 0x1a4)
+#define	rc_modcod_scrmb_mmsb_addr                                               (rx_config_addr + 0x1a6)
+#define	rc_modcod_scrmb_mlsb_addr                                               (rx_config_addr + 0x1a8)
+#define	rc_modcod_scrmb_lmsb_addr                                               (rx_config_addr + 0x1aa)
+#define	rc_modcod_scrmb_llsb_addr                                               (rx_config_addr + 0x1ac)
+#define	rc_i2cm_speed_kHz_addr                                                  (rx_config_addr + 0x1ae)
+#define	rc_i2cm_time_out_addr                                                   (rx_config_addr + 0x1b0)
+#define	rc_tuner_frequency_100kHz_addr                                          (rx_config_addr + 0x1b2)
+#define	rc_tuner_LPF_100kHz_addr                                                (rx_config_addr + 0x1b4)
+#define	rc_tuner_slave_addr_addr                                                (rx_config_addr + 0x1b6)
+#define	rc_tuner_max_LPF_100kHz_addr                                            (rx_config_addr + 0x1b8)
+#define	rc_tuner_LPF_margin_100kHz_addr                                         (rx_config_addr + 0x1ba)
+#define	rc_tuner_use_internal_control_addr                                      (rx_config_addr + 0x1bc)
+#define	rc_blind_scan_start_freq_100kHz_addr                                    (rx_config_addr + 0x1be)
+#define	rc_blind_scan_end_freq_100kHz_addr                                      (rx_config_addr + 0x1c0)
+#define	rc_blind_scan_min_sym_rate_kHz_addr                                     (rx_config_addr + 0x1c2)
+#define	rc_blind_scan_max_sym_rate_kHz_addr                                     (rx_config_addr + 0x1c4)
+#define	rc_blind_scan_channel_info_offset_addr                                  (rx_config_addr + 0x1c6)
+#define	rc_blind_scan_process_range_100kHz_addr                                 (rx_config_addr + 0x1c8)
+#define	rc_blind_scan_sweep_scalor_addr                                         (rx_config_addr + 0x1ca)
+#define	rc_blind_scan_sweep_max_addr                                            (rx_config_addr + 0x1cc)
+#define	rc_blind_scan_low_sym_swp_range_addr                                    (rx_config_addr + 0x1ce)
+#define	rc_blind_scan_acq_num_addr                                              (rx_config_addr + 0x1d0)
+#define	rc_blind_scan_cd_num_addr                                               (rx_config_addr + 0x1d2)
+#define	rc_blind_scan_acq_btr_lbw_addr                                          (rx_config_addr + 0x1d4)
+#define	rc_blind_scan_cd_btr_lbw_addr                                           (rx_config_addr + 0x1d6)
+#define	rc_blind_scan_uw_en_addr                                                (rx_config_addr + 0x1d8)
+#define	rc_blind_scan_ts_retry_addr                                             (rx_config_addr + 0x1da)
+#define	rc_blind_scan_freq_step_100kHz_addr                                     (rx_config_addr + 0x1dc)
+#define	rc_blind_scan_freq_decimation_addr                                      (rx_config_addr + 0x1de)
+#define	rc_blind_scan_mode_addr                                                 (rx_config_addr + 0x1e0)
+#define	rc_blind_scan_show_detail_addr                                          (rx_config_addr + 0x1e2)
+#define	rc_blind_scan_max_left1_100kHz_addr                                     (rx_config_addr + 0x1e4)
+#define	rc_blind_scan_max_left2_100kHz_addr                                     (rx_config_addr + 0x1e6)
+#define	rc_blind_scan_freq_back_100kHz_addr                                     (rx_config_addr + 0x1e8)
+#define	rc_descram_X_init_msb_addr                                              (rx_config_addr + 0x1ea)
+#define	rc_descram_X_init_lsb_addr                                              (rx_config_addr + 0x1ec)
+#define	rc_descram_Y_init_msb_addr                                              (rx_config_addr + 0x1ee)
+#define	rc_descram_Y_init_lsb_addr                                              (rx_config_addr + 0x1f0)
+#define	rc_pl_descram_en_addr                                                   (rx_config_addr + 0x1f2)
+#define	rc_iq_try_times_addr                                                    (rx_config_addr + 0x1f4)
+#define	rc_iq_retries_addr                                                      (rx_config_addr + 0x1f6)
+#define	rc_pll_fec_addr                                                         (rx_config_addr + 0x1f8)
+#define	rc_pll_mpeg_addr                                                        (rx_config_addr + 0x1fa)
+#define	rc_in_soft_sleep_mode_addr                                              (rx_config_addr + 0x1fc)
+#define	rc_in_hard_sleep_mode_addr                                              (rx_config_addr + 0x1fe)
+#define	rc_in_sleep_mode_addr                                                   (rx_config_addr + 0x200)
+#define	rc_decode_mode_addr                                                     (rx_config_addr + 0x202)
+#define	rc_iq_mode_addr                                                         (rx_config_addr + 0x204)
+#define	rc_blind_scan_carrier_db_addr                                           (rx_config_addr + 0x206)
+#define	rc_dishpoint_mode_addr                                                  (rx_config_addr + 0x208)
+#define	rc_lock_mode_addr                                                       (rx_config_addr + 0x20a)
+#define	rc_functional_mode_addr                                                 (rx_config_addr + 0x20c)
+#define	rc_blind_scan_reset_addr                                                (rx_config_addr + 0x20e)
+#define	rc_mpeg_continuous_mode_control_addr                                    (rx_config_addr + 0x210)
+#define	rc_hwm_threshold_addr                                                   (rx_config_addr + 0x212)
+#define	rc_lwm_threshold_addr                                                   (rx_config_addr + 0x214)
+#define	rc_pll_adust_period_addr                                                (rx_config_addr + 0x216)
+#define	rc_time_constant_addr                                                   (rx_config_addr + 0x218)
+#define	rc_pkt_fifo_hwm_addr                                                    (rx_config_addr + 0x21a)
+#define	rc_pkt_fifo_lwm_addr                                                    (rx_config_addr + 0x21c)
+#define	rc_bs_pk_to_avg_threshold_addr                                          (rx_config_addr + 0x21e)
+#define	rc_blind_scan_tuner_spectrum_inversion_addr                             (rx_config_addr + 0x220)
+
+
+#define	rs_main_state_addr                                                      (rx_state_addr + 0x0)
+#define	rs_last_main_state_addr                                                 (rx_state_addr + 0x4)
+#define	rs_code_rate_addr                                                       (rx_state_addr + 0x8)
+#define	rs_modulation_addr                                                      (rx_state_addr + 0xc)
+#define	rs_pilot_addr                                                           (rx_state_addr + 0x10)
+#define	rs_frame_length_addr                                                    (rx_state_addr + 0x14)
+#define	rs_frame_count_addr                                                     (rx_state_addr + 0x18)
+#define	rs_int_decim_samp_rate_MHz_addr                                         (rx_state_addr + 0x1c)
+#define	rs_int_freq_MHz_addr                                                    (rx_state_addr + 0x20)
+#define	rs_int_SNR_dB_addr                                                      (rx_state_addr + 0x40)
+#define	rs_int_ck_i_addr                                                        (rx_state_addr + 0x44)
+#define	rs_int_ck_q_addr                                                        (rx_state_addr + 0x48)
+#define	rs_int_ek_addr                                                          (rx_state_addr + 0x4c)
+#define	rs_int_snr_addr                                                         (rx_state_addr + 0x50)
+#define	rs_int_instant_snr_addr                                                 (rx_state_addr + 0x54)
+#define	rs_eq_loop_gain_scl_addr                                                (rx_state_addr + 0x58)
+#define	rs_eq_loop_gain_rshft_addr                                              (rx_state_addr + 0x5c)
+#define	rs_eq_i_coeffs_addr                                                     (rx_state_addr + 0x60)
+#define	rs_eq_q_coeffs_addr                                                     (rx_state_addr + 0x90)
+#define	rs_corr_val_addr                                                        (rx_state_addr + 0xc0)
+#define	rs_mode_code_addr                                                       (rx_state_addr + 0xe0)
+#define	rs_demod_reset_times_addr                                               (rx_state_addr + 0xe4)
+#define	rs_uw_clk32cnt_acc_addr                                                 (rx_state_addr + 0xe8)
+#define	rs_freq_tune_times_addr                                                 (rx_state_addr + 0xec)
+#define	rs_fec_err_accum_addr                                                   (rx_state_addr + 0xf0)
+#define	rs_equalizer_control_addr                                               (rx_state_addr + 0xf4)
+#define	rs_eq_adpt_sw_gain_addr                                                 (rx_state_addr + 0xf8)
+#define	rs_int_mer_addr                                                         (rx_state_addr + 0xfc)
+#define	rs_int_mer_s_addr                                                       (rx_state_addr + 0x100)
+#define	rs_int_mer_e_addr                                                       (rx_state_addr + 0x104)
+#define	rs_int_mer_e_i_addr                                                     (rx_state_addr + 0x108)
+#define	rs_int_mer_e_q_addr                                                     (rx_state_addr + 0x10c)
+#define	rs_blind_scan_bin_size_Hz_addr                                          (rx_state_addr + 0x110)
+#define	rs_calc_ROM_CRC_addr                                                    (rx_state_addr + 0x114)
+#define	rs_uw_i_ptr_addr                                                        (rx_state_addr + 0x118)
+#define	rs_uw_q_ptr_addr                                                        (rx_state_addr + 0x11c)
+#define	rs_uw_i_ref_ptr_addr                                                    (rx_state_addr + 0x120)
+#define	rs_uw_q_ref_ptr_addr                                                    (rx_state_addr + 0x124)
+#define	rs_mc_i_ref_ptr_addr                                                    (rx_state_addr + 0x128)
+#define	rs_mc_q_ref_ptr_addr                                                    (rx_state_addr + 0x12c)
+#define	rs_mc_ptr_addr                                                          (rx_state_addr + 0x130)
+#define	rs_xi_ptr_addr                                                          (rx_state_addr + 0x134)
+#define	rs_xq_ptr_addr                                                          (rx_state_addr + 0x138)
+#define	rs_int_buf_ptr_addr                                                     (rx_state_addr + 0x13c)
+#define	rs_eq_adpt_sw_symbol_addr                                               (rx_state_addr + 0x140)
+#define	rs_int_carrier_freq_100kHz_addr                                         (rx_state_addr + 0x142)
+#define	rs_num_uw_acquisition_addr                                              (rx_state_addr + 0x144)
+#define	rs_next_punc_cnt_addr                                                   (rx_state_addr + 0x146)
+#define	rs_next_punc_cnt_mod_32_addr                                            (rx_state_addr + 0x148)
+#define	rs_loop_max_addr                                                        (rx_state_addr + 0x14a)
+#define	rs_fcnt_step_temp_addr                                                  (rx_state_addr + 0x14c)
+#define	rs_acq_state_addr                                                       (rx_state_addr + 0x14e)
+#define	rs_indx_trial_addr                                                      (rx_state_addr + 0x150)
+#define	rs_min_occurance_addr                                                   (rx_state_addr + 0x152)
+#define	rs_fcnt_step_addr                                                       (rx_state_addr + 0x154)
+#define	rs_max_trial_addr                                                       (rx_state_addr + 0x156)
+#define	rs_loop_addr                                                            (rx_state_addr + 0x158)
+#define	rs_max_occ_addr                                                         (rx_state_addr + 0x15a)
+#define	rs_sync_indx_addr                                                       (rx_state_addr + 0x15c)
+#define	rs_dvbs_dss_fec_lock_addr                                               (rx_state_addr + 0x15e)
+#define	rs_sym_offset_addr                                                      (rx_state_addr + 0x160)
+#define	rs_uw_lock_addr                                                         (rx_state_addr + 0x162)
+#define	rs_fec_lock_addr                                                        (rx_state_addr + 0x164)
+#define	rs_snr_count_addr                                                       (rx_state_addr + 0x166)
+#define	rs_freq_est_frames_addr                                                 (rx_state_addr + 0x168)
+#define	rs_valid_modcod_addr                                                    (rx_state_addr + 0x16a)
+#define	rs_eq_cnvg_status_addr                                                  (rx_state_addr + 0x16c)
+#define	rs_freq_est_status_addr                                                 (rx_state_addr + 0x16e)
+#define	rs_rx_rsp_ptr_addr                                                      (rx_state_addr + 0x170)
+#define	rs_demap_table_state_addr                                               (rx_state_addr + 0x172)
+#define	rs_ldpc_table_state_addr                                                (rx_state_addr + 0x174)
+#define	rs_ROM_CRC_status_addr                                                  (rx_state_addr + 0x176)
+#define	rs_blind_scan_btr_lock_addr                                             (rx_state_addr + 0x178)
+#define	rs_blind_scan_channel_count_addr                                        (rx_state_addr + 0x17a)
+#define	rs_blind_scan_progress_addr                                             (rx_state_addr + 0x17c)
+#define	rs_blind_scan_error_code_addr                                           (rx_state_addr + 0x17e)
+#define	rs_blind_scan_bin_numbers_addr                                          (rx_state_addr + 0x180)
+#define	rs_blind_scan_max_left1_bins_addr                                       (rx_state_addr + 0x182)
+#define	rs_blind_scan_max_left2_bins_addr                                       (rx_state_addr + 0x184)
+#define	rs_tuner_status_addr                                                    (rx_state_addr + 0x186)
+#define	rs_ScatterData_rdy_addr                                                 (rx_state_addr + 0x188)
+
+
+#define	rp_uint_BER_addr                                                        (raptor_status_addr + 0x0)
+#define	rp_uint_PER_addr                                                        (raptor_status_addr + 0x4)
+#define	rp_uint_WER_addr                                                        (raptor_status_addr + 0x8)
+
+
+#define c68k_ready_word_addr													core_ready_word_addr
+
+#define rc_s2_modulation                                                        (patchglobalvar_addr + 0x1a)
+#define rc_s2_coderate                                                          (patchglobalvar_addr + 0x1c)
+#endif
diff -Naur a/drivers/amlogic/dvb_tv/avl6211/include/avl_dvbsx.h b/drivers/amlogic/dvb_tv/avl6211/include/avl_dvbsx.h
--- a/drivers/amlogic/dvb_tv/avl6211/include/avl_dvbsx.h	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/amlogic/dvb_tv/avl6211/include/avl_dvbsx.h	2014-12-11 16:13:50.033618053 +0100
@@ -0,0 +1,333 @@
+
+/*
+ *           Copyright 2012 Availink, Inc.
+ *
+ *  This software contains Availink proprietary information and
+ *  its use and disclosure are restricted solely to the terms in
+ *  the corresponding written license agreement. It shall not be 
+ *  disclosed to anyone other than valid licensees without
+ *  written permission of Availink, Inc.
+ *
+ */
+
+
+///$Date: 2012-2-9 17:36 $
+///
+///
+/// @file
+/// @brief Defines data structures, enumerations, and global macros for the AVL_DVBSx device.
+/// 
+#ifndef AVL_DVBSx_h_h
+	#define AVL_DVBSx_h_h
+
+	#include "avl.h"
+
+	#ifdef AVL_CPLUSPLUS
+extern "C" {
+	#endif
+
+	// The CI_FLAG_... macros below pertain to the m_Flags member of the AVL_DVBSx_Channel structure.
+	#define CI_FLAG_IQ_BIT							0x00000000  /// The index of the bit which controls the IQ swap setting
+	#define CI_FLAG_IQ_BIT_MASK						0x00000001  /// A bit mask for accessing the IQ swap bit
+	#define CI_FLAG_IQ_NO_SWAPPED					0x00000000	/// Setting the CI_FLAG_IQ_BIT to this value means that the I and Q signals are not swapped
+	#define CI_FLAG_IQ_SWAPPED						0x00000001	/// Setting the CI_FLAG_IQ_BIT to this value means that the I and Q signals are swapped
+
+	#define CI_FLAG_DVBS2_BIT						0x00000002	/// The start index of the bit which controls the standard setting
+	#define CI_FLAG_DVBS2_BIT_MASK					0x0000001c	/// A bit mask for accessing the standard setting 
+	#define CI_FLAG_DVBS 							0x00000000	/// The value which represents the DVB-S standard
+	#define CI_FLAG_DVBS2							0x00000001	/// The value which represents the DVB-S2 standard
+	#define CI_FLAG_DVBS2_UNDEF						0x00000004  /// The value which indicates that the standard is not known
+
+	#define CI_FLAG_MANUAL_LOCK_MODE_BIT			0x00000001  /// The index of the bit which controls the manual code rate setting
+	#define CI_FLAG_MANUAL_LOCK_MODE_BIT_MASK		0x00000002	/// A bit mask for accessing the manual code rate bit
+	#define CI_FLAG_MANUAL_LOCK_MODE				0x00000001	/// Setting the CI_FLAG_MANUAL_LOCK_MODE_BIT to this value means that the code rate can be manually configured
+	#define CI_FLAG_AUTO_LOCK_MODE					0x00000000	/// Setting the CI_FLAG_MANUAL_LOCK_MODE_BIT to this value means that the code rate will be detected automatically by the hardware
+
+	#define CI_FLAG_CODERATE_BIT					0x00000008	/// The index of the bit which controls the code rate setting	
+	#define CI_FLAG_CODERATE_BIT_MASK				0x00001f00	/// A bit mask for accessing the index value of code rate
+
+	#define CI_FLAG_MODULATION_BIT					0x0000000d	///	The index of the bit which controls the modulation mode setting
+	#define CI_FLAG_MODULATION_BIT_MASK				0x00006000	///	A bit mask for accessing the index value of modulation mode
+	
+	#define CI_FLAG_IQ_AUTO_BIT						0x00000005	/// The index of the bit which controls the automatic IQ swap setting
+	#define CI_FLAG_IQ_AUTO_BIT_MASK				0x00000020  /// A bit mask for accessing the automatic IQ swap bit
+	#define CI_FLAG_IQ_AUTO_BIT_OFF					0x00000000  /// Setting the CI_FLAG_AUTO_BIT to this value disables automatic IQ swap
+	#define CI_FLAG_IQ_AUTO_BIT_AUTO				0x00000001  /// Setting the CI_FLAG_AUTO_BIT to this value enables automatic IQ swap
+
+	#define CI_FLAG_LOCK_MODE_BIT					0x00000006	/// The index of the bit which controls the channel lock mode
+	#define CI_FLAG_LOCK_MODE_BIT_MASK				0x00000040	/// A bit mask for accessing the channel lock mode
+
+	#define CI_FLAG_ADAPTIVE_POWER_SAVE_BIT			0x00000007	/// The index of the bit which controls whether adaptive power save mode is enabled
+	#define CI_FLAG_ADAPTIVE_POWER_SAVE_BIT_MASK	0x00000080	/// A bit mask for accessing the adaptive power save mode bit
+
+	typedef AVL_uint16 AVL_DVBSx_ErrorCode;		///< Defines the return code for Availink device operations. \sa AVL_DVBSx_EC_OK, AVL_DVBSx_EC_GeneralFail, AVL_DVBSx_EC_I2CFail, AVL_DVBSx_EC_TimeOut, AVL_DVBSx_EC_Running, AVL_DVBSx_EC_MemoryRunout, AVL_DVBSx_EC_BSP_ERROR1, AVL_DVBSx_EC_BSP_ERROR2
+
+	#define AVL_DVBSx_EC_OK					0	///< There is no error.
+	#define AVL_DVBSx_EC_GeneralFail		1	///< Some general failure happened.
+	#define AVL_DVBSx_EC_I2CFail			2	///< I2C bus failed.
+	#define AVL_DVBSx_EC_TimeOut			4	///< Operation failed in a given time period
+	#define AVL_DVBSx_EC_Running			8	///< The Availink device is still processing a previous command.
+	#define AVL_DVBSx_EC_InSleepMode		16	///< The requested receiver command could not be sent because the Availink device is in sleep mode.
+	#define AVL_DVBSx_EC_MemoryRunout		32	///< The Availink device has insufficient memory to complete the current operation.
+	#define AVL_DVBSx_EC_BSP_ERROR1			64	///< User defined error code for reporting BSP operation failure.
+	#define AVL_DVBSx_EC_BSP_ERROR2			128	///< User defined error code for reporting BSP operation failure.
+
+	#define AVL_DVBSx_SA_0					0x0C ///< Availink device slave address 0.  Up to two Availink devices are supported on one I2C bus.  
+	#define AVL_DVBSx_SA_1					0x0D ///< Availink device slave address 1.  Up to two Availink devices are supported on one I2C bus.
+
+	///
+	/// Represents the code rate. The Availink device can automatically detect the code rate of the input signal.
+	enum AVL_DVBSx_FecRate
+	{
+		RX_DVBS_1_2 = 0,		///< = 0 Code rate 1/2
+		RX_DVBS_2_3 = 1,		///< = 1 Code rate 2/3
+		RX_DVBS_3_4 = 2,		///< = 2 Code rate 3/4
+		RX_DVBS_5_6 = 3,		///< = 3 Code rate 5/6
+		RX_DVBS_6_7 = 4,		///< = 4 Code rate 6/7
+		RX_DVBS_7_8 = 5,		///< = 5 Code rate 7/8
+		RX_DVBS2_1_4 = 6,		///< = 6 Code rate 1/4
+		RX_DVBS2_1_3 = 7,		///< = 7 Code rate 1/3
+		RX_DVBS2_2_5 = 8,		///< = 8 Code rate 2/5
+		RX_DVBS2_1_2 = 9,		///< = 9 Code rate 1/2
+		RX_DVBS2_3_5 = 10,		///< = 10 Code rate 3/5
+		RX_DVBS2_2_3 = 11,		///< = 11 Code rate 2/3
+		RX_DVBS2_3_4 = 12,		///< = 12 Code rate 3/4
+		RX_DVBS2_4_5 = 13,		///< = 13 Code rate 4/5
+		RX_DVBS2_5_6 = 14,		///< = 14 Code rate 5/6
+		RX_DVBS2_8_9 = 15,		///< = 15 Code rate 8/9
+		RX_DVBS2_9_10 = 16		///< = 16 Code rate 9/10
+	};
+
+	///
+	/// Represents the Pilot mode of the signal. The Availink device can automatically detect the Pilot mode of the received signal.
+	enum AVL_DVBSx_Pilot
+	{
+		RX_Pilot_off = 0,		///< = 0 Pilot off
+		RX_Pilot_on = 1			///< = 1 Pilot on
+	};
+
+	///
+	/// Represents the channel lock mode.
+	enum AVL_DVBSx_LockMode
+	{
+		AVL_DVBSx_LOCK_MODE_FIXED = 0,		///< = 0 Fixed lock mode
+		AVL_DVBSx_LOCK_MODE_ADAPTIVE = 1	///< = 1 Adaptive lock mode
+	};
+
+	///
+	/// Represents the modulation mode. The Availink device can automatically detect the modulation mode of the received signal.
+	enum AVL_DVBSx_ModulationMode
+	{
+		AVL_DVBSx_MM_QPSK = 0,		///< = 0 QPSK
+		AVL_DVBSx_MM_8PSK = 1,		///< = 1 8-PSK
+		AVL_DVBSx_MM_16APSK = 2,	///< = 2 16-APSK
+		AVL_DVBSx_MM_32APSK = 3		///< = 3 32-APSK
+	};
+
+	///
+	/// The roll off of the received signal. The Availink device can automatically detect this value from the received signal.
+	enum AVL_DVBSx_RollOff
+	{
+		AVL_DVBSx_RO_20 = 0,		///<  = 0 Rolloff is 0.20
+		AVL_DVBSx_RO_25 = 1,		///<  = 1 Rolloff is 0.25
+		AVL_DVBSx_RO_35 = 2			///<  = 2 Rolloff is 0.35
+	};
+
+	///
+	/// The MPEG output format. The default value in the Availink device is \a AVL_DVBSx_MPF_TS
+	enum AVL_DVBSx_MpegFormat
+	{
+		AVL_DVBSx_MPF_TS = 0,		///< = 0  Transport stream format.
+		AVL_DVBSx_MPF_TSP = 1		///< = 1  Transport stream plus parity format.
+	};
+
+	///
+	/// The MPEG output mode. The default value in the Availink device is \a AVL_DVBSx_MPM_Parallel
+	enum AVL_DVBSx_MpegMode
+	{
+		AVL_DVBSx_MPM_Parallel = 0,		///< = 0  Output MPEG data in parallel mode
+		AVL_DVBSx_MPM_Serial = 1		///< = 0  Output MPEG data in serial mode
+	};
+
+	///
+	/// The MPEG output clock polarity. The clock polarity should be configured to meet the back end device's requirement.
+	/// The default value in the Availink device is \a AVL_DVBSx_MPCP_Rising
+	enum AVL_DVBSx_MpegClockPolarity
+	{
+		AVL_DVBSx_MPCP_Falling = 0,		///<  = 0  The MPEG data is valid on the falling edge of the clock.
+		AVL_DVBSx_MPCP_Rising = 1		///<  = 1  The MPEG data is valid on the rising edge of the clock.
+	};
+
+	///
+	/// Internal MPEG pull-down resistor control. Used to enable or disable the internal MPEG interface pull-down resistors.
+	/// The default value in AVL_DVBSx is \a AVL_DVBSx_MPPD_Enable
+	enum AVL_DVBSx_MpegPulldown
+	{
+		AVL_DVBSx_MPPD_Disable = 0,		///< = 0 The internal MPEG interface pull-down resistors are disabled.
+		AVL_DVBSx_MPPD_Enable = 1		///< = 1 The internal MPEG interface pull-down resistors are enabled.
+	};
+
+	///
+	/// Defines the output bit order of the MPEG data bytes.  The meaning differs depending on whether the MPEG interface 
+	/// is configured to output data in serial mode or parallel mode as follows:
+	/// Serial Mode: Normal - The device outputs the MSB of each byte first and the LSB of each byte last.
+	//               Invert - The device outputs the LSB of each byte first and the MSB of each byte last.
+	/// Parallel Mode: Normal - The device outputs the MSB of each byte on pin MPEG_DATA_7 and the LSB of each byte on pin MPEG_DATA_0.
+	///                Invert - The device outputs the LSB of each byte on pin MPEG_DATA_7 and the MSB of each byte on pin MPEG_DATA_0.
+	enum AVL_DVBSx_MpegBitOrder
+	{
+		AVL_DVBSx_MPBO_Normal = 0,		///< = 0 Normal output bit order
+		AVL_DVBSx_MPBO_Invert = 1		///< = 1 Inverted output bit order
+	};
+
+	///
+	/// Defines the pin on which the Availink device outputs the MPEG data when the MPEG interface has been configured to operate 
+	/// in serial mode.
+	enum AVL_DVBSx_MpegSerialPin
+	{
+		AVL_DVBSx_MPSP_DATA0 = 0,		///< = 0 Serial data is output on pin MPEG_DATA_0
+		AVL_DVBSx_MPSP_DATA7 = 1		///< = 1 Serial data is output on pin MPEG_DATA_7
+	};
+
+	///
+	/// Defines the polarity of the MPEG data valid signal when the MPEG interface is configured to operate in TSP mode.
+	enum AVL_DVBSx_MpegValidPolarity
+	{
+		AVL_DVBSx_MPVP_Normal = 0,		///< = 0 The MPEG data valid signal is high during the payload data and low during the parity bytes.
+		AVL_DVBSx_MPVP_Invert = 1		///< = 1 The MPEG data valid signal is low during the payload data and high during the parity bytes.
+	};
+
+	///
+	/// Defines the polarity of the MPEG error signal.
+	enum AVL_DVBSx_MpegErrorPolarity
+	{
+		AVL_DVBSx_MPEP_Normal = 0,		///< = 0 The MPEG error signal is high during the payload of a packet which contains uncorrectable error(s).
+		AVL_DVBSx_MPEP_Invert = 1		///< = 1 The MPEG error signal is low during the payload of a packet which contains uncorrectable error(s).
+	};
+
+	///
+	/// Defines the polarity of the RF AGC control signal.   The polarity of the RF AGC control signal must be
+	/// configured to match that required by the tuner.
+	/// The default value in the Availink device is \a AVL_DVBSx_RA_Invert
+	enum AVL_DVBSx_RfagcPola
+	{
+		AVL_DVBSx_RA_Normal = 0,	///< = 0  Normal polarization. This setting is used for a tuner whose gain increases with increased AGC voltage.
+		AVL_DVBSx_RA_Invert = 1		///< = 1  Inverted polarization. The default value. Most tuners fall into this category.  This setting is used for a tuner whose gain decreases with increased AGC voltage.
+	};
+
+	///
+	/// Defines the device functional mode.
+	enum AVL_DVBSx_FunctionalMode
+	{
+		AVL_DVBSx_FunctMode_Demod = 0,	    ///< = 0 The device is in demod mode.
+		AVL_DVBSx_FunctMode_BlindScan = 1	///< = 1 The device is in blind scan mode
+	};
+
+	/// 
+	/// Defines the device spectrum polarity setting. 
+	enum AVL_DVBSx_SpectrumPolarity
+	{
+		AVL_DVBSx_Spectrum_Normal = 0,		///< = 0 The received signal spectrum is not inverted.
+		AVL_DVBSx_Spectrum_Invert = 1		///< = 1 The received signal spectrum is inverted.
+	};
+
+	///
+	/// Defines the sleep-wake status of the Availink device
+	enum AVL_DVBSx_Sleep_Wake_Status
+	{
+		AVL_DVBSx_Sleep_Mode = 0,
+		AVL_DVBSx_Wake_Mode = 1
+	};
+
+	///
+	/// Defines the DiSEqC status
+	enum AVL_DVBSx_Diseqc_OPStatus
+	{
+		AVL_DVBSx_DOS_Uninitialized = 0,	///< = 0  DiSEqC has not been initialized yet.
+		AVL_DVBSx_DOS_Initialized   = 1,	///< = 1  DiSEqC has been initialized.
+		AVL_DVBSx_DOS_InContinuous  = 2,	///< = 2  DiSEqC is in continuous mode.
+		AVL_DVBSx_DOS_InTone        = 3,	///< = 3  DiSEqC is in tone burst mode.
+		AVL_DVBSx_DOS_InModulation  = 4		///< = 4  DiSEqC is in modulation mode.
+	};
+
+	/// Stores the MPEG interface configuration parameters that typically need to be configured for the user application.
+	struct AVL_DVBSx_MpegInfo
+	{
+		enum AVL_DVBSx_MpegFormat m_MpegFormat;		///< The MPEG output format (TS or TSP)
+		enum AVL_DVBSx_MpegMode m_MpegMode;			///< The MPEG output mode (parallel or serial)
+		enum AVL_DVBSx_MpegClockPolarity m_MpegClockPolarity; ///< The polarity of the MPEG clock signal
+	} ;
+
+    /// Stores the properties which characterize the received signal
+	struct AVL_DVBSx_SignalInfo
+	{
+		enum AVL_DVBSx_Pilot m_pilot;				///< The pilot mode. \sa ::AVL_DVBSx_Pilot.
+		enum AVL_DVBSx_FecRate m_coderate;			///< The code rate. \sa ::AVL_DVBSx_FecRate.
+		enum AVL_DVBSx_ModulationMode m_modulation;	///< The modulation mode. \sa ::AVL_DVBSx_ModulationMode.
+		enum AVL_DVBSx_RollOff m_rolloff;			///< The roll-off (excess bandwidth). \sa ::AVL_DVBSx_RollOff.
+	};
+
+    /// Stores the carrier channel parameters.
+	struct AVL_DVBSx_Channel
+	{
+		AVL_uint32 m_uiFrequency_kHz;		///< The channel carrier frequency in units of kHz. 
+		AVL_uint32 m_uiSymbolRate_Hz;		///< The symbol rate in units of Hz. 
+		AVL_uint32 m_Flags;					///< Contains bit-mapped fields which store additional channel configuration information.
+	};
+
+    /// The structure stores the data and flags associated with the Availink device.
+	struct AVL_DVBSx_Chip
+	{
+		AVL_uint16 m_SlaveAddr;								///< Device I2C slave address.
+		AVL_uint16 m_uiBusId;								///< Bus identifier.
+		AVL_uint16 m_StdBuffIndex;							///< The internal stdout port buffer index.
+		AVL_uint16 m_DemodFrequency_10kHz;					///< The internal demod clock frequency corresponding to the current PLL configuration in units of 10kHz.
+		AVL_uint16 m_FecFrequency_10kHz;					///< The FEC clock frequency corresponding to the current PLL configuration in units of 10kHz.
+		AVL_uint16 m_MpegFrequency_10kHz;					///< The MPEG clock corresponding to the current PLL configuration in units of 10 kHZ.
+		AVL_semaphore m_semRx;								///< A semaphore used to protect the receiver command channel.
+		AVL_semaphore m_semI2CRepeater;						///< A semaphore used to protect the I2C repeater channel.
+		AVL_semaphore m_semI2CRepeater_r;					///< A semaphore used to protect the I2C repeater channel data reading.
+		AVL_semaphore m_semDiseqc;							///< A semaphore used to protect the DiSEqC operations.
+		enum AVL_DVBSx_Diseqc_OPStatus Diseqc_OP_Status;	///< The DiSEqC status.	\sa ::AVL_DVBSx_Diseqc_OPStatus.
+	};
+
+	/// Configures the Availink device's PLL. The SDK provides an array of PLL configurations in IBSP.h. The user may remove unused elements in that array to reduce the SDK footprint. Availink advises users to refrain from changing the PLL setup values themselves. Please contact Availink if there is a need to support a PLL configuration not already provided.
+	struct AVL_DVBSx_PllConf
+	{
+		AVL_uint16 m_uiClkf;					///< Feedback clock divider
+		AVL_uint16 m_uiClkr;					///< Reference clock divider
+		AVL_uint16 m_uiPllod;					///< PLL output divider
+		AVL_uint16 m_uiPllod2;					///< PLL output divider 2
+		AVL_uint16 m_uiPllod3;					///< PLL output divider 3
+		AVL_uint16 m_RefFrequency_kHz;			///< Reference clock frequency in units of kHz
+		AVL_uint16 m_DmodFrequency_10kHz;		///< Demod clock frequency in units of 10kHz
+		AVL_uint16 m_FecFrequency_10kHz;		///< FEC clock frequency in units of 10 kHz
+		AVL_uint16 m_MpegFrequency_10kHz;		///< MPEG clock frequency in units of 10 kHz
+	} ;
+
+	/// The structure for storing the version information associated with the Availink device and its associated software. \sa AVL_VerInfo
+	struct AVL_DVBSx_VerInfo
+	{
+		struct AVL_VerInfo m_Chip;		///< Hardware version. Should be 1.0.2.
+		struct AVL_VerInfo m_API;		///< SDK version.
+		struct AVL_VerInfo m_Patch;		///< The version of the firmware patch.
+	} ;
+
+	/// Initializes an ::AVL_DVBSx_Chip object. The user must first define an object of type ::AVL_DVBSx_Chip, and then pass the address of the object to this function. This function initializes semaphores for the object and sets the I2C slave address.
+	/// 
+	/// @param pAVL_DVBSx_ChipObject  A pointer to the ::AVL_DVBSx_Chip object.
+	/// @param uiSlaveAddress  The slave address for the Availink device.
+	/// 
+	/// @return ::AVL_DVBSx_ErrorCode, Return ::AVL_DVBSx_EC_OK if the initialization is successful.
+	/// @remarks This function initializes the semaphores without any checking. It is the user's responsibility to make sure that each object is initialized only once. 
+	AVL_DVBSx_ErrorCode Init_AVL_DVBSx_ChipObject(struct AVL_DVBSx_Chip * pAVL_DVBSx_ChipObject, AVL_uint16 uiSlaveAddress);
+
+	/// Declaration of the global PLL configuration array variable. The variable must be defined in IBSP.c
+	/// 
+	extern const struct AVL_DVBSx_PllConf pll_conf[];
+	extern const AVL_uint16 pll_array_size;
+
+	#ifdef AVL_CPLUSPLUS
+}
+	#endif
+#endif
diff -Naur a/drivers/amlogic/dvb_tv/avl6211/include/avlfrontend.h b/drivers/amlogic/dvb_tv/avl6211/include/avlfrontend.h
--- a/drivers/amlogic/dvb_tv/avl6211/include/avlfrontend.h	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/amlogic/dvb_tv/avl6211/include/avlfrontend.h	2014-12-11 16:13:50.149617166 +0100
@@ -0,0 +1,46 @@
+
+
+
+#ifndef _AVL6211SF_H_
+#define _AVL6211SF_H_
+
+
+
+#include <linux/dvb/frontend.h>
+#include "../aml_dvb.h"
+
+
+#include "IBSP.h"
+#include "avl_dvbsx.h"
+#include "IBase.h"
+#include "IRx.h"
+#include "II2C.h"
+#include "IDiseqc.h"
+#include "ITuner.h"
+#include "IBlindScan.h"
+#include "IBlindscanAPI.h"
+
+
+#define printf printk
+
+
+struct avl6211_fe_config {
+	int                   i2c_id;
+	int                 reset_pin;
+	int                 demod_addr;
+	int                 tuner_addr;
+	void 			  *i2c_adapter;
+};
+
+
+struct avl6211_state {
+	struct avl6211_fe_config config;
+	struct i2c_adapter *i2c;
+	u32                 freq;
+        fe_modulation_t     mode;
+        u32                 symbol_rate;
+        struct dvb_frontend fe;
+};
+
+
+#endif
diff -Naur a/drivers/amlogic/dvb_tv/avl6211/include/avl.h b/drivers/amlogic/dvb_tv/avl6211/include/avl.h
--- a/drivers/amlogic/dvb_tv/avl6211/include/avl.h	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/amlogic/dvb_tv/avl6211/include/avl.h	2014-12-11 16:13:50.069617776 +0100
@@ -0,0 +1,133 @@
+/*
+ *           Copyright 2012 Availink, Inc.
+ *
+ *  This software contains Availink proprietary information and
+ *  its use and disclosure are restricted solely to the terms in
+ *  the corresponding written license agreement. It shall not be 
+ *  disclosed to anyone other than valid licensees without
+ *  written permission of Availink, Inc.
+ *
+ */
+
+
+///$Date: 2012-2-9 17:36 $
+///
+///
+/// @file
+/// @brief Defines common macros, functions and data structures for all Availink products. This file also declare functions for ensuring the SDK can work in both little endian and big endian target platforms.
+/// 
+#ifndef avl_h_h
+	#define avl_h_h
+
+	#include "bspdatadef.h"
+
+	#ifdef AVL_CPLUSPLUS
+extern "C" {
+	#endif
+
+	#define AVL_min(x,y) (((x) < (y)) ? (x) : (y))
+	#define AVL_max(x,y) (((x) < (y)) ? (y) : (x))
+	#define AVL_floor(a) (((a) == (int)(a))? ((int)(a)) : (((a) < 0)? ((int)((a)-1)) : ((int)(a))))
+	#define AVL_ceil(a)  (((a) == (int)(a))? ((int)(a)) : (((a) < 0)? ((int)(a)) : ((int)((a)+1))))
+	#define AVL_abs(a)  (((a)>0) ? (a) : (-(a)))
+	#define AVL_abssub(a,b) ((a>=b)?(a-b):(b-a))
+	#define AVL_CONSTANT_10_TO_THE_9TH 1000000000
+
+	#ifdef AVL_CPLUSPLUS
+		#define AVL_NULL    0
+	#else
+		#define AVL_NULL    ((void *)0)
+	#endif
+
+	/// Availink's version structure.
+	struct AVL_VerInfo {
+		AVL_uchar m_Major;	///< The major version
+		AVL_uchar m_Minor;	///< The minor version
+		AVL_uint16 m_Build;	///< The build version
+	};
+
+	/// Stores an unsigned 64-bit integer
+	struct AVL_uint64
+	{
+		AVL_uint32 m_HighWord;	///< The most significant 32-bits of the unsigned 64-bit integer
+		AVL_uint32 m_LowWord;	///< The least significant 32-bits of the unsigned 64-bit integer
+	};
+
+	/// Chunk two bytes \a uidata in to \a pBuff.
+	/// 
+	/// @param uidata The input 2 bytes data.
+	/// @param pBuff The destination buffer, at least 2 bytes length.
+	/// 
+	/// @remarks This function is used to eliminates the big endian and little endian problem.
+	void Chunk16(AVL_uint16 uidata, AVL_puchar pBuff);
+
+	/// Composes a ::AVL_uint16 from two bytes in a AVL_uchar array.
+	/// 
+	/// @param pBuff  The buffer has at least 2 bytes data.
+	/// 
+	/// @return AVL_uint16
+	/// @remarks This function is used to eliminates the big endian and little endian problem.
+	AVL_uint16 DeChunk16(const AVL_puchar pBuff);
+
+	/// Chunk four bytes \a uidata in to \a pBuff.
+	/// 
+	/// @param uidata The input 3 bytes data.
+	/// @param pBuff The destination buffer, at least 3 bytes length.
+	/// 
+	/// @remarks This function is used to eliminates the big endian and little endian problem.
+	void Chunk32(AVL_uint32 uidata, AVL_puchar pBuff);
+
+	/// Composes a ::AVL_uint16 from four bytes in a AVL_uchar array.
+	/// 
+	/// @param pBuff  The buffer has at least 4 bytes data.
+	/// 
+	/// @return AVL_uint32
+	/// @remarks This function is used to eliminates the big endian and little endian problem.
+	AVL_uint32 DeChunk32(const AVL_puchar pBuff);
+
+	/// Chunk 3 byte of \a uiaddr into the \a pBuff
+	/// 
+	/// @param uiaddr The address. Only the three LSB bytes will be used.
+	/// @param pBuff The destination buffer, at lease three bytes length.
+	/// 
+	/// @remarks This function is used to eliminates the big endian and little endian problem.
+	void ChunkAddr(AVL_uint32 uiaddr, AVL_puchar pBuff);
+
+	/// Adds a 32-bit unsigned integer to a 64-bit unsigned integer.  Stores the result in a 64-bit unsigned integer.
+	///
+	/// @param pSum Contains the 64-bit addend.  Also carries back the resulting sum.
+	/// @param uiAddend Contains the 32-bit addend.
+	///
+	/// @remarks This function is an 'internal' function. Availink does not recommend that the user call it directly.
+	void Add32To64(struct AVL_uint64 *pSum, AVL_uint32 uiAddend);
+
+	/// Divides two 64-bit unsigned integers.  Stores the result in a 64-bit unsigned integer.
+	///
+	/// @param divisor Contains the 64-bit divisor. 
+	/// @param dividend Contains the 64-bit dividend.
+	///
+	/// @remarks This function is an 'internal' function. Availink does not recommend that the user call it directly.
+	AVL_uint32 Divide64(struct AVL_uint64 divisor, struct AVL_uint64 dividend);
+
+	/// Multiplies two 32-bit unsigned integers.  Stores the result in a 64-bit unsigned integer.
+	///
+	/// @param pDst Carries back the 64-bit product of the multiplication.
+	/// @param m1 Contains one of the 32-bit factors to be used in the multiplication.
+	/// @param m2 Contains the other 32-bit factor to be used in the multiplication.
+	///
+	/// @remarks This function is an 'internal' function. Availink does not recommend that the user call it directly.
+	void Multiply32(struct AVL_uint64 *pDst, AVL_uint32 m1, AVL_uint32 m2);
+
+	/// Shifts a 32-bit unsigned integer left by 16 bits and then adds the result to a 64-bit unsigned integer.  Stores the sum in a 64-bit unsigned integer.
+	///
+	/// @param pDst Contains the 64-bit addend.  Also carries back the resulting sum.
+	/// @param a Contains the 32-bit input which is shifted and added to the other addend.
+	///
+	/// @remarks This function is an 'internal' function. Availink does not recommend that the user call it directly.
+	void AddScaled32To64(struct AVL_uint64 *pDst, AVL_uint32 a);
+
+	#ifdef AVL_CPLUSPLUS
+}
+	#endif
+
+#endif
diff -Naur a/drivers/amlogic/dvb_tv/avl6211/include/BlindScan_source.h b/drivers/amlogic/dvb_tv/avl6211/include/BlindScan_source.h
--- a/drivers/amlogic/dvb_tv/avl6211/include/BlindScan_source.h	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/amlogic/dvb_tv/avl6211/include/BlindScan_source.h	2014-12-11 16:13:50.033618053 +0100
@@ -0,0 +1,33 @@
+/*
+ *           Copyright 2012 Availink, Inc.
+ *
+ *  This software contains Availink proprietary information and
+ *  its use and disclosure are restricted solely to the terms in
+ *  the corresponding written license agreement. It shall not be 
+ *  disclosed to anyone other than valid licensees without
+ *  written permission of Availink, Inc.
+ *
+ */
+
+
+///$Date: 2012-2-9 17:36 $
+///
+
+#ifndef BlindScan_source_h_h
+    #define BlindScan_source_h_h
+
+    #include "avl_dvbsx.h"
+
+    #ifdef AVL_CPLUSPLUS
+extern "C" {
+	#endif
+
+	void AVL_DVBSx_Error_Dispose(AVL_DVBSx_ErrorCode r);
+    AVL_DVBSx_ErrorCode Initialize(struct AVL_DVBSx_Chip * pAVLChip,struct AVL_Tuner * pTuner);
+	AVL_DVBSx_ErrorCode BlindScan(void);
+
+	#ifdef AVL_CPLUSPLUS
+}
+	#endif
+
+#endif
diff -Naur a/drivers/amlogic/dvb_tv/avl6211/include/bspdatadef.h b/drivers/amlogic/dvb_tv/avl6211/include/bspdatadef.h
--- a/drivers/amlogic/dvb_tv/avl6211/include/bspdatadef.h	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/amlogic/dvb_tv/avl6211/include/bspdatadef.h	2014-12-11 16:13:50.161617073 +0100
@@ -0,0 +1,52 @@
+/*
+ *           Copyright 2012 Availink, Inc.
+ *
+ *  This software contains Availink proprietary information and
+ *  its use and disclosure are restricted solely to the terms in
+ *  the corresponding written license agreement. It shall not be 
+ *  disclosed to anyone other than valid licensees without
+ *  written permission of Availink, Inc.
+ *
+ */
+
+
+///$Date: 2012-2-9 17:36 $
+///
+///
+/// @file
+/// @brief Defines the primary data type according the target platform. All data 
+/// types defined in this file should be overwritten by Users according to 
+/// their own target platform.
+/// 
+#ifndef bspdatadef_h_h
+#define bspdatadef_h_h
+
+#include <linux/semaphore.h>
+
+//#define AVL_CPLUSPLUS		///< Used to switch the C++ and C compiler. Comment the macro AVL_CPLUSPLUS if you use C compiler
+
+typedef  char AVL_char;		///< 8 bits signed char data type.
+typedef  unsigned char AVL_uchar;	///< 8 bits unsigned char data type.
+
+typedef  short AVL_int16;	///< 16 bits signed char data type.
+typedef  unsigned short AVL_uint16;	///< 16 bits unsigned char data type.
+
+typedef  int AVL_int32;		///< 32 bits signed char data type.
+typedef  unsigned int AVL_uint32;	///< 32 bits unsigned char data type.
+
+typedef  char * AVL_pchar;	///< pointer to a 8 bits signed char data type.
+typedef  unsigned char * AVL_puchar; ///< pointer to a 8 bits unsigned char data type.
+
+typedef  short * AVL_pint16;	///< pointer to a 16 bits signed char data type.
+typedef  unsigned short * AVL_puint16;	///< pointer to a 16 bits unsigned char data type.
+
+typedef  int * AVL_pint32;	///< pointer to a 32 bits signed char data type.
+typedef  unsigned int * AVL_puint32; ///< pointer to a 32 bits unsigned char data type.
+
+//typedef unsigned char AVL_semaphore; 	///< the semaphore data type.
+//typedef unsigned char * AVL_psemaphore;		///< the pointer to a semaphore data type.
+typedef struct semaphore AVL_semaphore; 
+typedef struct semaphore *AVL_psemaphore; 
+
+#endif
+
diff -Naur a/drivers/amlogic/dvb_tv/avl6211/include/DiSEqC_source.h b/drivers/amlogic/dvb_tv/avl6211/include/DiSEqC_source.h
--- a/drivers/amlogic/dvb_tv/avl6211/include/DiSEqC_source.h	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/amlogic/dvb_tv/avl6211/include/DiSEqC_source.h	2014-12-11 16:13:50.061617837 +0100
@@ -0,0 +1,41 @@
+/*
+ *           Copyright 2012 Availink, Inc.
+ *
+ *  This software contains Availink proprietary information and
+ *  its use and disclosure are restricted solely to the terms in
+ *  the corresponding written license agreement. It shall not be 
+ *  disclosed to anyone other than valid licensees without
+ *  written permission of Availink, Inc.
+ *
+ */
+
+
+///$Date: 2012-2-9 17:36 $
+///
+
+
+
+#ifndef Diseqc_source_h_h
+    #define Diseqc_source_h_h
+
+	#include "avl_dvbsx.h"
+
+    #ifdef AVL_CPLUSPLUS
+extern "C" {
+	#endif
+
+    void AVL_DVBSx_Error_Dispose(AVL_DVBSx_ErrorCode r);
+    AVL_DVBSx_ErrorCode Initialize(struct AVL_DVBSx_Chip * pAVLChip);
+   AVL_DVBSx_ErrorCode DiSEqC(void);
+	AVL_DVBSx_ErrorCode AVL6211_SetToneOut(AVL_uchar ucTone);
+	void AVL6211_DiseqcSendCmd(AVL_puchar pCmd,AVL_uchar CmdSize);
+	AVL_DVBSx_ErrorCode AVL6211_LNB_PIO_Control(AVL_char nPIN_Index,AVL_char nValue);
+	AVL_DVBSx_ErrorCode AVL6211_22K_Control(AVL_uchar OnOff);
+	
+	#define LNB1_PIN_60 60
+	#define LNB0_PIN_59 59
+	#ifdef AVL_CPLUSPLUS
+}
+	#endif
+
+#endif
diff -Naur a/drivers/amlogic/dvb_tv/avl6211/include/ExtSharpBS2S7HZ6306.h b/drivers/amlogic/dvb_tv/avl6211/include/ExtSharpBS2S7HZ6306.h
--- a/drivers/amlogic/dvb_tv/avl6211/include/ExtSharpBS2S7HZ6306.h	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/amlogic/dvb_tv/avl6211/include/ExtSharpBS2S7HZ6306.h	2014-12-11 16:13:50.053617900 +0100
@@ -0,0 +1,43 @@
+/*
+ *           Copyright 2012 Availink, Inc.
+ *
+ *  This software contains Availink proprietary information and
+ *  its use and disclosure are restricted solely to the terms in
+ *  the corresponding written license agreement. It shall not be 
+ *  disclosed to anyone other than valid licensees without
+ *  written permission of Availink, Inc.
+ *
+ */
+
+
+///$Date: 2012-2-9 17:36 $
+///
+///
+/// @file 
+/// @brief Declare functions for external Sharp BS2S7HZ6306 tuner control
+///
+#ifndef ExtSharpBS2S7HZ6306_h_h
+	#define ExtSharpBS2S7HZ6306_h_h
+
+	#include "avl_dvbsx.h"
+    #include "ITuner.h"
+
+	//Included to support the blind scan fix made to blindscanform.cpp file ae per raptor.
+	#define SHARP_TUNER_FACTOR_VALUE			9
+	#define SHARP_HSYM_ACQ_TH_VALUE				20480
+	#define SHARP_HSYM_CD_TH_VALUE				156
+	//////////////////////////////////////////////////////////////////////////////////////
+	
+	#ifdef AVL_CPLUSPLUS
+extern "C" {
+	#endif
+
+	AVL_DVBSx_ErrorCode ExtSharpBS2S7HZ6306_Initialize(struct AVL_Tuner * pTuner);
+	AVL_DVBSx_ErrorCode ExtSharpBS2S7HZ6306_GetLockStatus(struct AVL_Tuner * pTuner );
+	AVL_DVBSx_ErrorCode ExtSharpBS2S7HZ6306_Lock(struct AVL_Tuner * pTuner);
+	AVL_DVBSx_ErrorCode ExtSharpBS2S7HZ6306_Check(struct AVL_Tuner * pTuner);
+
+	#ifdef AVL_CPLUSPLUS
+}
+	#endif
+#endif
diff -Naur a/drivers/amlogic/dvb_tv/avl6211/include/IBase.h b/drivers/amlogic/dvb_tv/avl6211/include/IBase.h
--- a/drivers/amlogic/dvb_tv/avl6211/include/IBase.h	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/amlogic/dvb_tv/avl6211/include/IBase.h	2014-12-11 16:13:50.041617992 +0100
@@ -0,0 +1,257 @@
+/*
+ *           Copyright 2012 Availink, Inc.
+ *
+ *  This software contains Availink proprietary information and
+ *  its use and disclosure are restricted solely to the terms in
+ *  the corresponding written license agreement. It shall not be 
+ *  disclosed to anyone other than valid licensees without
+ *  written permission of Availink, Inc.
+ *
+ */
+
+
+///$Date: 2012-2-9 17:36 $
+///
+///
+/// @file
+/// @brief Declares functions for generic device level operations.
+/// 
+#ifndef IBase_h_h
+	#define IBase_h_h
+
+	#include "avl_dvbsx.h"
+	#include "ITuner.h"
+	#include "avl_dvbsx_globals.h"
+
+	#ifdef AVL_CPLUSPLUS
+extern "C" {
+	#endif
+
+	///@cond
+	#define core_reset_b_reg			0x600000
+	#define gpio_data_in_to_reg			0x6C0004
+	#define gpio_data_reg_out			0x6C0008
+	#define gpio_reg_enb				0x6C000C
+
+	#define pll_clkr_map_addr			0x6C40C0
+	#define pll_clkf_map_addr			0x6C4100
+	#define pll_od_map_addr				0x6C4080
+	#define pll_od2_map_addr			0x6C4140
+	#define pll_od3_map_addr			0x6C4180
+	#define pll_bwadj_map_addr			0x6C41C0
+	#define pll_softvalue_en_map_addr	0x6C4200
+	#define reset_register_addr			0x6C4000
+
+	#define OP_RX_NOOP		    		0x00
+	#define OP_RX_LD_DEFAULT    		0x01
+	#define OP_RX_INIT_GO				0x02
+	#define OP_RX_RESET_BERPER	 		0x03
+	#define OP_RX_HALT					0x04
+	#define OP_RX_SLEEP         		0x05
+	#define OP_RX_WAKE          		0x06
+	#define OP_RX_BLIND_SCAN    		0x08
+	#define OP_RX_STDOUT_MODE   		0x09
+	///@endcond
+
+	///@cond
+	#define AVL_DVBSx_API_VER_MAJOR	0x01
+	#define AVL_DVBSx_API_VER_MINOR	0x00
+	#define AVL_DVBSx_API_VER_BUILD	0x06
+
+	/// @cond
+	/// Configures the PLL.
+	/// 
+	/// @param pPLLConf  Pointer to the PLL configuration object
+	/// @param pAVLChip Pointer to the ::AVL_DVBSx_Chip object for which the PLL is being configured.
+	/// 
+	/// @return ::AVL_DVBSx_ErrorCode, 
+	/// Return ::AVL_DVBSx_EC_OK if the PLL configuration has been successfully sent to the Availink device. 
+	/// Return ::AVL_DVBSx_I2C_Fail if there is an I2C communication problem
+	/// @remarks This function is an internal SDK function. Availink recommends that users refrain from directly calling this function.
+	AVL_DVBSx_ErrorCode AVL_DVBSx_IBase_SetPLL(const struct AVL_DVBSx_PllConf * pPLLConf, struct AVL_DVBSx_Chip * pAVLChip );
+
+	/// Downloads the firmware to the Availink device.
+	/// 
+	/// @param pInitialData Pointer to the buffer which contains the firmware data.
+	/// @param pAVLChip Pointer to the ::AVL_DVBSx_Chip object for which the firmware is being downloaded.
+	/// 
+	/// @return ::AVL_DVBSx_ErrorCode, 
+	/// Return ::AVL_DVBSx_EC_OK if the firmware download is successful. 	
+	/// Return ::AVL_DVBSx_EC_I2CFail if there is an I2C communication problem.
+	/// @remarks This function is an internal SDK function. Availink recommends that users refrain from directly calling this function. 
+	AVL_DVBSx_ErrorCode AVL_DVBSx_IBase_DownloadFirmware(AVL_puchar pFirmwareData,  const struct AVL_DVBSx_Chip * pAVLChip);
+
+	///@endcond
+	
+	/// Checks the Availink device status to determine whether initialization is complete.
+	/// 
+	/// @param pAVLChip Pointer to the ::AVL_DVBSx_Chip object for which initialization status is being checked.
+	/// 
+	/// @return ::AVL_DVBSx_ErrorCode, 
+	/// Return ::AVL_DVBSx_EC_OK if device initialization is complete. 
+	/// Return ::AVL_DVBSx_EC_GeneralFail if device initialization has failed.
+	/// Return ::AVL_DVBSx_EC_I2CFail if there is an I2C communication problem.
+	AVL_DVBSx_ErrorCode AVL_DVBSx_IBase_GetStatus( struct AVL_DVBSx_Chip * pAVLChip );
+
+	/// Retrieves the Availink device version information.
+	/// 
+	/// @param pVerInfo Pointer to an object in which to store the retrieved version information.  Refer to ::AVL_DVBSx_Ver_Info for more details.
+	/// @param pAVLChip Pointer to the ::AVL_DVBSx_Chip object for which the version information is being retrieved.
+	/// 
+	/// @return ::AVL_DVBSx_ErrorCode, 
+	/// Return ::AVL_DVBSx_EC_OK if the version information has been retrieved.
+	/// Return ::AVL_DVBSx_EC_I2CFail if there is an I2C communication problem.
+	AVL_DVBSx_ErrorCode AVL_DVBSx_IBase_GetVersion( struct AVL_DVBSx_VerInfo * pVerInfo, const struct AVL_DVBSx_Chip * pAVLChip ) ;
+
+	/// Initializes the Availink device. This function boots the device. 
+	/// The user may call ::AVL_DVBSx_IBase_GetStatus to check the device initialization status.
+	/// 
+	/// @param pPLLConf  Pointer to the ::AVL_DVBSx_PLLConf object which contains the device PLL settings. 
+	/// @param pInitialData Pointer to the buffer which contains the firmware patch data.
+	/// @param pAVLChip Pointer to the ::AVL_DVBSx_Chip object which is being initialized.
+	/// 
+	/// @return ::AVL_DVBSx_ErrorCode, 
+	/// Return ::AVL_DVBSx_EC_OK if the firmware and configuration information has been successfully downloaded to the Availink device.
+	/// Return ::AVL_DVBSx_EC_I2CFail if there is an I2C communication problem.
+	AVL_DVBSx_ErrorCode AVL_DVBSx_IBase_Initialize( const struct AVL_DVBSx_PllConf * pPLLConf, AVL_puchar pInitialData,  struct AVL_DVBSx_Chip * pAVLChip ) ;
+
+	/// Sends an operational command to the Availink device.
+	/// 
+	/// @param ucOpCmd  The OP_RX_xxx command being sent to the device.
+	/// @param pAVLChip Pointer to the ::AVL_DVBSx_Chip to which the command is being sent.  
+	/// 
+	/// @return ::AVL_DVBSx_ErrorCode, 
+	/// Return ::AVL_DVBSx_EC_OK if the operational command is sent to the device.
+	/// Return ::AVL_DVBSx_EC_Running if the command could not be sent because the device is still processing a previous command.
+	/// Return ::AVL_DVBSx_EC_I2CFail if there is an I2C communication problem.
+	/// @remarks This function is an internal SDK function. Availink recommends that users refrain from directly calling this function. 
+	AVL_DVBSx_ErrorCode AVL_DVBSx_IBase_SendRxOP(AVL_uchar ucOpCmd, struct AVL_DVBSx_Chip * pAVLChip );
+
+	/// Checks if the Availink device has finished processing the last operational command sent to it.
+	/// 
+	/// @param pAVLChip Pointer to the ::AVL_DVBSx_Chip for which the operational command status is being checked.
+	/// 
+	/// @return ::AVL_DVBSx_ErrorCode, 
+	/// Return ::AVL_DVBSx_EC_OK if the device has finished processing the last command. 
+	/// Return ::AVL_DVBSx_EC_Running if the device is still processing a previous command.
+	/// Return ::AVL_DVBSx_EC_I2CFail if there is an I2C communication problem.
+	/// @remarks This function is an internal SDK function. Availink recommends that users refrain from directly calling this function.
+	AVL_DVBSx_ErrorCode AVL_DVBSx_IBase_GetRxOPStatus(const struct AVL_DVBSx_Chip * pAVLChip );
+
+	/// Halts the Availink device.  In halt mode the device does not perform any channel processing.
+	/// 
+	/// @param pAVLChip Pointer to the ::AVL_DVBSx_Chip which is being halted.
+	/// 
+	/// @return ::AVL_DVBSx_ErrorCode, 
+	/// Return ::AVL_DVBSx_EC_OK if the operational command has been sent to the device.
+	/// Return ::AVL_DVBSx_EC_Running if the command could not be sent because the device is still processing a previous command.
+	/// Return ::AVL_DVBSx_EC_I2CFail if there is an I2C communication problem.
+	AVL_DVBSx_ErrorCode AVL_DVBSx_IBase_Halt( struct AVL_DVBSx_Chip * pAVLChip );
+
+	/// Places the Availink device in sleep mode.  In sleep mode some device blocks are held in an idle state to reduce power consumption.
+	/// 
+	/// @param pAVLChip Pointer to the ::AVL_DVBSx_Chip which is being placed in sleep mode.
+	/// 
+	/// @return ::AVL_DVBSx_ErrorCode, 
+	/// Return ::AVL_DVBSx_EC_OK if the operational command has been sent to the device.
+	/// Return ::AVL_DVBSx_EC_Running if the command could not be sent because the device is still processing a previous command.
+	/// Return ::AVL_DVBSx_EC_I2CFail if there is an I2C communication problem.
+	AVL_DVBSx_ErrorCode AVL_DVBSx_IBase_Sleep( struct AVL_DVBSx_Chip * pAVLChip );
+
+	/// Wakes the Availink device from sleep mode.  Upon waking from sleep, the device enters the halt mode.
+	/// 
+	/// @param pAVLChip Pointer to the ::AVL_DVBSx_Chip which is being waken from sleep.
+	/// 
+	/// @return ::AVL_DVBSx_ErrorCode, 
+	/// Return ::AVL_DVBSx_EC_OK if the operational command has been sent to the device.
+	/// Return ::AVL_DVBSx_EC_Running if the command could not be sent because the device is still processing a previous command.
+	/// Return ::AVL_DVBSx_EC_I2CFail if there is an I2C communication problem.
+	AVL_DVBSx_ErrorCode AVL_DVBSx_IBase_Wake( struct AVL_DVBSx_Chip * pAVLChip );
+
+	/// Sets the device functional mode.  The device can be configured for either demod mode or blind scan mode.  
+	/// 
+	/// @param pAVLChip Pointer to the ::AVL_DVBSx_Chip for which the functional mode is being set.
+	/// @param enumFunctionalMode The functional mode into which the device is being placed.
+	/// 
+	/// @return ::AVL_DVBSx_ErrorCode, 
+	/// Return ::AVL_DVBSx_EC_OK if the functional mode has been set. 	
+	/// Return ::AVL_DVBSx_EC_I2CFail if there is an I2C communication problem.
+	AVL_DVBSx_ErrorCode AVL_DVBSx_IBase_SetFunctionalMode(const struct AVL_DVBSx_Chip * pAVLChip, enum AVL_DVBSx_FunctionalMode enumFunctionalMode);
+
+	/// Checks the current device functional mode. The Availink device can operate in either demodulation mode or blind scan mode.
+	/// 
+	/// @param pFunctionalMode Pointer to the ::AVL_DVBSx_FunctionalMode object in which to store the retrieved functional mode.
+	/// @param pAVLChip Pointer to the ::AVL_DVBSx_Chip for which the functional mode is being retrieved.
+	/// 
+	/// @return ::AVL_DVBSx_ErrorCode, 
+	/// Return ::AVL_DVBSx_EC_OK if the functional mode has been retrieved. 		
+	/// Return ::AVL_DVBSx_EC_I2CFail if there is an I2C communication problem.
+	AVL_DVBSx_ErrorCode AVL_DVBSx_IBase_GetFunctionalMode(enum AVL_DVBSx_FunctionalMode * pFunctionalMode,  const struct AVL_DVBSx_Chip * pAVLChip);
+
+	/// Configures the direction of the GPIO pins.
+	/// 
+	/// @param ucDir This is a bitmapped field in which each of the three LSBs controls the direction of a particular GPIO pin.  Setting a direction bit to a 
+	/// one configures the respective pin as an input, and setting the bit to a zero configures the pin as an output.  Bit 0 (the LSB) corresponds to pin CS_0, 
+	/// bit 1 corresponds to pin LNB_CNTRL_1, and bit 2 corresponds to pin GPIO_CLK.
+	/// @param pAVLChip A pointer point to the ::AVL_DVBSx_Chip object for which GPIO pin direction is being configured.
+	/// 
+	/// @return ::AVL_DVBSx_ErrorCode, 
+	/// Return ::AVL_DVBSx_EC_OK if the GPIO pin direction is configured.
+	/// Return ::AVL_DVBSx_EC_I2CFail if there is an I2C communication problem.
+	AVL_DVBSx_ErrorCode AVL_DVBSx_IBase_SetGPIODir( AVL_uchar ucDir, const struct AVL_DVBSx_Chip * pAVLChip );
+
+	/// Sets the voltage level of any GPIO pins that have been configured as outputs.
+	/// 
+	/// @param ucVal This is a bitmapped field in which each of the three LSBs controls the voltage level of a particular GPIO pin that has been configured as an 
+	/// output.  Setting a value bit to a zero drives the corresponding pin low, while setting a value bit to a one, drives the corresponding pin high.
+	/// Bit 0 (the LSB) corresponds to pin CS_0, bit 1 corresponds to pin LNB_CNTRL_1, and bit 2 corresponds to pin GPIO_CLK.
+	/// @param pAVLChip Pointer to the ::AVL_DVBSx_Chip object for which the GPIO pin output voltages are being configured.
+	/// 
+	/// @return ::AVL_DVBSx_ErrorCode, 
+	/// Return ::AVL_DVBSx_EC_OK if the GPIO output pin voltages have been configured.
+	/// Return ::AVL_DVBSx_EC_I2CFail if there is an I2C communication problem.
+	/// @remarks This function only controls the voltage of those GPIO pins that have been configured as outputs.  If a GPIO pin has been configured as an input,
+	/// the function has no effect for that pin.
+	AVL_DVBSx_ErrorCode AVL_DVBSx_IBase_SetGPIOVal( AVL_uchar ucVal, const struct AVL_DVBSx_Chip * pAVLChip );
+
+	/// Reads the voltage level of the GPIO pins.
+	/// 
+	/// @param pucVal Pointer to a variable in which to store the GPIO pin voltage levels.  This is a bitmapped field in which each of the three LSBs will 
+	/// contain the voltage level of a particular GPIO pin.  A value bit of zero means that the corresponding pin is low, while a value bit of one, means that
+	/// the corresponding pin is high.  Bit 0 (the LSB) corresponds to pin CS_0, bit 1 corresponds to pin LNB_CNTRL_1, and bit 2 corresponds to pin GPIO_CLK.
+	/// The GPIO pin voltage level can be read regardless of whether the pin has been configured as an input or output.
+	/// @param pAVLChip Pointer to the ::AVL_DVBSx_Chip object for which the GPIO pin voltage levels are being read.
+	/// 
+	/// @return ::AVL_DVBSx_ErrorCode, 
+	/// Return ::AVL_DVBSx_EC_OK if the GPIO pin voltages have been read.
+	/// Return ::AVL_DVBSx_EC_I2CFail if there is a I2C communication problem.
+	AVL_DVBSx_ErrorCode AVL_DVBSx_IBase_GetGPIOVal( AVL_puchar pucVal, const struct AVL_DVBSx_Chip * pAVLChip );
+
+	/// Checks the Availink device is in sleep status or wake status.
+	/// 
+	/// @param pChipStatus Pointer to the AVL_DVBSx_Sleep_Wake_Status object in which to store the retrieved chip status.
+	/// @param pAVLChip Pointer to the AVL_DVBSx_Chip for which the operational command status is being checked.
+	/// 
+	/// @return ::AVL_DVBSx_ErrorCode, 
+	/// Return ::AVL_DVBSx_EC_OK if the device has finished processing the last command. 
+	/// Return ::AVL_DVBSx_EC_Running if the device is still processing a previous command.
+	/// Return ::AVL_DVBSx_EC_I2CFail if there is an I2C communication problem.
+	AVL_DVBSx_ErrorCode AVL_DVBSx_IBase_GetChipStatus( enum AVL_DVBSx_Sleep_Wake_Status * pChipStatus, const struct AVL_DVBSx_Chip * pAVLChip );
+
+	/// Configures the device to indicate whether the tuner inverts the received signal spectrum.
+	/// 
+	/// @param enumSpectrumPolarity Indicates whether the tuner being used inverts the received signal spectrum.  
+	/// @param pAVLChip A pointer to the ::AVL_DVBSx_Chip object for which the spectrum polarity setting is being configured.
+	/// 
+	/// @return ::AVL_DVBSx_ErrorCode, 
+	/// Return ::AVL_DVBSx_EC_OK if the spectrum polarity configuration is successful.
+	/// Return ::AVL_DVBSx_EC_I2CFail if there is an I2C communication problem.
+	/// @remarks 
+	AVL_DVBSx_ErrorCode AVL_DVBSx_IBase_SetSpectrumPolarity( enum AVL_DVBSx_SpectrumPolarity enumSpectrumPolarity, const struct AVL_DVBSx_Chip * pAVLChip );
+
+
+	#ifdef AVL_CPLUSPLUS
+}
+	#endif
+
+#endif
diff -Naur a/drivers/amlogic/dvb_tv/avl6211/include/IBlindscanAPI.h b/drivers/amlogic/dvb_tv/avl6211/include/IBlindscanAPI.h
--- a/drivers/amlogic/dvb_tv/avl6211/include/IBlindscanAPI.h	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/amlogic/dvb_tv/avl6211/include/IBlindscanAPI.h	2014-12-11 16:13:50.161617073 +0100
@@ -0,0 +1,177 @@
+/*
+ *           Copyright 2012 Availink, Inc.
+ *
+ *  This software contains Availink proprietary information and
+ *  its use and disclosure are restricted solely to the terms in
+ *  the corresponding written license agreement. It shall not be 
+ *  disclosed to anyone other than valid licensees without
+ *  written permission of Availink, Inc.
+ *
+ */
+
+
+///$Date: 2012-2-9 17:36 $
+///
+#ifndef IBlindScanAPI_h_h
+	#define IBlindScanAPI_h_h
+
+	#include "avl_dvbsx.h"
+	#include "ITuner.h"
+	#include "IBlindScan.h"
+
+	#ifdef AVL_CPLUSPLUS
+extern "C" {
+	#endif
+
+	/// 
+	/// Defines the status of blind scan process.
+	enum AVL_DVBSx_BlindScanAPI_Status
+	{	
+		AVL_DVBSx_BS_Status_Init = 0,							///< = 0 Indicates that the blind scan process is initializing the parameters.
+		AVL_DVBSx_BS_Status_Start = 1,							///< = 1 Indicates that the blind scan process is starting to scan.
+		AVL_DVBSx_BS_Status_Wait = 2,							///< = 2 Indicates that the blind scan process is waiting for the completion of scanning.
+		AVL_DVBSx_BS_Status_Adjust = 3,							///< = 3 Indicates that the blind scan process is reading the channel info which have scanned out.
+		AVL_DVBSx_BS_Status_User_Process = 4,					///< = 4 Indicates that the blind scan process is in custom code. Customer can add the callback function in this stage such as adding TP information to TP list or lock the TP for parsing PSI.
+		AVL_DVBSx_BS_Status_Cancel = 5,							///< = 5 Indicates that the blind scan process is cancelled or the blind scan have completed.
+		AVL_DVBSx_BS_Status_Exit = 6,							///< = 6 Indicates that the blind scan process have ended.
+		AVL_DVBSx_BS_Status_WaitExit = 7
+	};
+
+	/// 
+	/// Defines the blind scan mode.
+	enum AVL_DVBSx_BlindScanAPI_Mode
+	{
+		AVL_DVBSx_BS_Fast_Mode = 0,								///< = 0 Indicates that the blind scan frequency step is automatic settings.
+		AVL_DVBSx_BS_Slow_Mode = 1								///< = 1 Indicates that the blind scan frequency step can be setting by user. The default value is 10MHz.
+	};
+
+	/// 
+	/// Stores the blind scan configuration parameters.
+	struct AVL_DVBSx_BlindScanAPI_Setting
+	{
+		AVL_uint16  m_uiScan_Min_Symbolrate_MHz;				///< The minimum symbol rate to be scanned in units of MHz. The minimum value is 1000 kHz.
+		AVL_uint16  m_uiScan_Max_Symbolrate_MHz;				///< The maximum symbol rate to be scanned in units of MHz. The maximum value is 45000 kHz.
+		AVL_uint16 	m_uiScan_Start_Freq_MHz;					///< The start scan frequency in units of MHz. The minimum value depends on the tuner specification.
+		AVL_uint16  m_uiScan_Stop_Freq_MHz;						///< The stop scan frequency in units of MHz. The maximum value depends on the tuner specification.
+		AVL_uint16  m_uiScan_Next_Freq_100KHz;					///< The start frequency of the next scan in units of 100kHz.
+		AVL_uint16  m_uiScan_Progress_Per;						///< The percentage completion of the blind scan process. A value of 100 indicates that the blind scan is finished.
+		AVL_uint16  m_uiScan_Bind_No;							///< The number of completion of the blind scan procedure.
+		AVL_uint16  m_uiTuner_MaxLPF_100kHz;					///< The max low pass filter bandwidth of the tuner.
+		AVL_uint16	m_uiScan_Center_Freq_Step_100KHz;			///< The blind scan frequency step. The value is only valid when BS_Mode set to AVL_DVBSx_BS_Slow_Mode and would be ignored when BS_Mode set to AVL_DVBSx_BS_Fast_Mode.
+		enum AVL_DVBSx_BlindScanAPI_Mode BS_Mode;				///< The blind scan mode. \sa ::AVL_DVBSx_IBlindScanAPI_Mode.
+		AVL_uint16  m_uiScaning;								///< whether in blindscan progress.
+		
+		AVL_uint16  m_uiChannelCount;							///< The number of channels detected thus far by the blind scan operation.  The Availink device can store up to 120 detected channels.
+		struct AVL_DVBSx_Channel channels[128];					///< Stores the channel information that all scan out results. 
+		struct AVL_DVBSx_Channel channels_Temp[16];				///< Stores the channel information temporarily that scan out results by the blind scan procedure.
+
+		struct AVL_DVBSx_BlindScanPara	bsPara;					///< Stores the blind scan parameters each blind scan procedure.
+		struct AVL_DVBSx_BlindScanInfo	bsInfo;					///< Stores the blind scan status information each blind scan procedure.
+		enum AVL_DVBSx_SpectrumPolarity m_eSpectrumMode;		///< Defines the device spectrum polarity setting.  \sa ::AVL_DVBSx_SpectrumPolarity.
+	};
+
+	/// Initializes the blind scan parameters.
+	/// 
+	/// @param pBSsetting  A pointer to the blind scan configuration parameters.
+	/// 
+	/// @return ::AVL_DVBSx_ErrorCode, 
+	/// Return ::AVL_DVBSx_EC_OK after all the member of the pBSsetting is configured with the default value.
+	AVL_DVBSx_ErrorCode AVL_DVBSx_IBlindScanAPI_Initialize(struct AVL_DVBSx_BlindScanAPI_Setting *pBSsetting );
+
+	/// Configures the device to indicate whether the tuner inverts the received signal spectrum.
+	/// 
+	/// @param pBSsetting A pointer to the ::AVL_DVBSx_IBlindScanAPI_Setting object for which the spectrum polarity is being configured.
+	/// @param SpectrumMode Indicates whether the tuner inverts the received signal spectrum. 
+	/// 
+	/// @return ::AVL_DVBSx_ErrorCode, 
+	/// Return ::AVL_DVBSx_EC_OK after the spectrum polarity is configured with the desired value.
+	AVL_DVBSx_ErrorCode AVL_DVBSx_IBlindScanAPI_SetSpectrumMode(struct AVL_DVBSx_BlindScanAPI_Setting *pBSsetting, enum AVL_DVBSx_SpectrumPolarity SpectrumMode);
+
+	/// Sets the blind scan mode.
+	/// 
+	/// @param pBSsetting A Pointer to the ::AVL_DVBSx_IBlindScanAPI_Setting for which the blind scan mode is being retrieved.
+	/// @param Scan_Mode The blind scan mode on which the device is being placed.
+	/// 
+	/// @return ::AVL_DVBSx_ErrorCode, 
+	/// Return ::AVL_DVBSx_EC_OK after the blind scan mode has been retrieved.
+	AVL_DVBSx_ErrorCode AVL_DVBSx_IBlindScanAPI_SetScanMode(struct AVL_DVBSx_BlindScanAPI_Setting *pBSsetting, enum AVL_DVBSx_BlindScanAPI_Mode Scan_Mode);
+
+	/// Sets the start frequency and stop frequency.
+	/// 
+	/// @param pBSsetting A Pointer to the ::AVL_DVBSx_IBlindScanAPI_Setting for which the frequency range is being retrieved.
+	/// @param StartFreq_MHz The start scan frequency in units of MHz.
+	/// @param EndFreq_MHz The stop scan frequency in units of MHz.
+	///
+	/// @return ::AVL_DVBSx_ErrorCode, 
+	/// Return ::AVL_DVBSx_EC_OK after the frequency range has been retrieved.
+	AVL_DVBSx_ErrorCode AVL_DVBSx_IBlindScanAPI_SetFreqRange(struct AVL_DVBSx_BlindScanAPI_Setting *pBSsetting, AVL_uint16 StartFreq_MHz, AVL_uint16 EndFreq_MHz );
+
+	/// Sets the max low pass filter bandwidth of the tuner.
+	/// 
+	/// @param pBSsetting A Pointer to the ::AVL_DVBSx_IBlindScanAPI_Setting for which the max LPF is being retrieved.
+	/// @param MaxLPF The tuner LPF bandwidth setting in units of 100 kHz.
+	/// 
+	/// @return ::AVL_DVBSx_ErrorCode, 
+	/// Return ::AVL_DVBSx_EC_OK after the max LPF has been retrieved.
+	AVL_DVBSx_ErrorCode AVL_DVBSx_IBlindScanAPI_SetMaxLPF(struct AVL_DVBSx_BlindScanAPI_Setting *pBSsetting, AVL_uint16 MaxLPF );
+
+	/// Performs a blind scan operation. Call the function ::AVL_DVBSx_IBlindScan_GetScanStatus to check the status of the blind scan operation.
+	/// 
+	/// @param pAVLChip A pointer to the ::AVL_DVBSx_Chip object on which blind scan is being performed.
+	/// @param pTuner A Pointer to the ::AVL_Tuner object on which to lock tuner at a proper frequency point.
+	/// @param pBSsetting A Pointer to blind scan configuration parameters.
+	///
+	/// @return ::AVL_DVBSx_ErrorCode, 
+	/// Return ::AVL_DVBSx_EC_OK if the scan command is successfully sent to the Availink device.
+	/// Return ::AVL_DVBSx_EC_I2CFail if there is an I2C communication problem.
+	/// Return ::AVL_DVBSx_EC_Running if the scan command could not be sent because the Availink device is still processing a previous command.
+	/// Return ::AVL_DVBSx_EC_GeneralFail if the device is not in the blind scan functional mode or the parameters are wrong.
+	AVL_DVBSx_ErrorCode AVL_DVBSx_IBlindScanAPI_Start(struct AVL_DVBSx_Chip *pAVLChip, struct AVL_Tuner *pTuner, struct AVL_DVBSx_BlindScanAPI_Setting *pBSsetting );
+
+	/// Queries the blind scan status.
+	/// 
+	/// @param pAVLChip A pointer to Pointer to the ::AVL_DVBSx_Chip object for which the blind scan status is being queried.
+	/// @param pBSsetting A Pointer to a variable in which to store the blind scan status.
+	/// 
+	/// @return ::AVL_DVBSx_ErrorCode, 
+	/// Return ::AVL_DVBSx_EC_OK if the blind scan status has been retrieved.
+	/// Return ::AVL_DVBSx_EC_I2CFail if there is an I2C communication problem.
+	/// Return ::AVL_DVBSx_EC_Running if the scan command could not be sent because the Availink device is still processing a previous command.
+	AVL_DVBSx_ErrorCode AVL_DVBSx_IBlindScanAPI_GetCurrentScanStatus(struct AVL_DVBSx_Chip *pAVLChip ,struct AVL_DVBSx_BlindScanAPI_Setting *pBSsetting );
+
+	/// Reads the channels found during a particular scan from the firmware and stores the new channels found in the scan and filters out the duplicate ones.
+	/// 
+	/// @param pAVLChip A pointer to the AVL_DVBSx_Chip object on which read channel operation is being performed.
+	/// @param pBSsetting A pointer to a structure that stores the new channels found in the scan.
+	/// 
+	/// @return ::AVL_DVBSx_ErrorCode, 
+	/// Return ::AVL_DVBSx_EC_OK if the blind scan status has been retrieved.
+	/// Return ::AVL_DVBSx_EC_I2CFail if there is an I2C communication problem.
+	AVL_DVBSx_ErrorCode AVL_DVBSx_IBlindScanAPI_Adjust(struct AVL_DVBSx_Chip *pAVLChip ,struct AVL_DVBSx_BlindScanAPI_Setting *pBSsetting );
+
+	/// Stops blind scan process.
+	/// 
+	/// @param pAVLChip A pointer to the ::AVL_DVBSx_Chip object on which blind scan is being stopped.
+	/// @param pBSsetting A Pointer to blind scan configuration parameters.
+	/// 
+	/// @return ::AVL_DVBSx_ErrorCode, 
+	/// Return ::AVL_DVBSx_EC_OK if the functional mode has been set. 	
+	/// Return ::AVL_DVBSx_EC_I2CFail if there is an I2C communication problem.
+	AVL_DVBSx_ErrorCode AVL_DVBSx_IBlindScanAPI_Exit(struct AVL_DVBSx_Chip * pAVLChip, struct AVL_DVBSx_BlindScanAPI_Setting * pBSsetting);
+
+	/// Gets the progress of blind scan process based on current scan step's start frequency.
+	/// 
+	/// @param pBSsetting A pointer to the ::AVL_DVBSx_IBlindScanAPI_Setting object for which store the blind scan process.
+	/// 
+	/// @return ::AVL_uint16, 
+	/// Return ::The progress of blind scan process based on current scan step's start frequency.
+	AVL_uint16 AVL_DVBSx_IBlindscanAPI_GetProgress(struct AVL_DVBSx_BlindScanAPI_Setting *pBSsetting );
+
+
+	#ifdef AVL_CPLUSPLUS
+}
+	#endif
+
+#endif
+
+
diff -Naur a/drivers/amlogic/dvb_tv/avl6211/include/IBlindScan.h b/drivers/amlogic/dvb_tv/avl6211/include/IBlindScan.h
--- a/drivers/amlogic/dvb_tv/avl6211/include/IBlindScan.h	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/amlogic/dvb_tv/avl6211/include/IBlindScan.h	2014-12-11 16:13:50.061617837 +0100
@@ -0,0 +1,118 @@
+/*
+ *           Copyright 2012 Availink, Inc.
+ *
+ *  This software contains Availink proprietary information and
+ *  its use and disclosure are restricted solely to the terms in
+ *  the corresponding written license agreement. It shall not be 
+ *  disclosed to anyone other than valid licensees without
+ *  written permission of Availink, Inc.
+ *
+ */
+
+
+///$Date: 2012-2-9 17:36 $
+///
+///
+/// @file
+/// @brief Declares functions for blind scan.
+/// 
+/// @details The Availink device can store up to 120 detected carrier channels. 
+/// If more than 120 channels are detected in the scan range, the function ::AVL_DVBSx_IBlindScan_GetScanStatus will 
+/// set ::AVL_DVBSx_BlindScanPara.m_uiResultCode to 1.
+/// The user can read blind scan results with the function ::AVL_DVBSx_IBlindScan_ReadChannelInfo. 
+/// 
+#ifndef IBlindScan_h_h
+	#define IBlindScan_h_h
+
+	#include "avl_dvbsx.h"
+	#include "ITuner.h"
+	#include "avl_dvbsx_globals.h"
+
+	#ifdef AVL_CPLUSPLUS
+extern "C" {
+	#endif
+
+	///@cond
+
+	/// @endcond
+
+	/// Stores the blind scan parameters which are passed to the ::AVL_DVBSx_IBlindScan_Scan function.
+	struct AVL_DVBSx_BlindScanPara
+	{
+		AVL_uint16 m_uiStartFreq_100kHz;	///< The start scan frequency in units of 100kHz. The minimum value depends on the tuner specification. 
+		AVL_uint16 m_uiStopFreq_100kHz;		///< The stop scan frequency in units of 100kHz. The maximum value depends on the tuner specification.
+		AVL_uint16 m_uiMinSymRate_kHz;		///< The minimum symbol rate to be scanned in units of kHz. The minimum value is 1000 kHz.
+		AVL_uint16 m_uiMaxSymRate_kHz;		///< The maximum symbol rate to be scanned in units of kHz. The maximum value is 45000 kHz.
+	};
+
+	/// Stores the blind scan status information.
+	struct AVL_DVBSx_BlindScanInfo
+	{
+		AVL_uint16 m_uiProgress;				///< The percentage completion of the blind scan procedure. A value of 100 indicates that the blind scan is finished.
+		AVL_uint16 m_uiChannelCount;			///< The number of channels detected thus far by the blind scan operation.  The Availink device can store up to 120 detected channels.
+		AVL_uint16 m_uiNextStartFreq_100kHz;	///< The start frequency of the next scan in units of 100kHz.
+		AVL_uint16 m_uiResultCode;				///< The result of the blind scan operation.  Possible values are:  0 - blind scan operation normal; 1 -- more than 120 channels have been detected.
+	};
+
+	/// Performs a blind scan operation. Call the function ::AVL_DVBSx_IBlindScan_GetScanStatus to check the status of the blind scan operation.
+	/// 
+	/// @param pBSPara  A pointer to the blind scan configuration parameters.
+	/// @param uiTumerLPF_100kHz The tuner LPF bandwidth setting in units of 100 kHz.
+	/// @param pAVLChip A pointer to the ::AVL_DVBSx_Chip object on which blind scan is being performed.
+	/// 
+	/// @return ::AVL_DVBSx_ErrorCode, 
+	/// Return ::AVL_DVBSx_EC_OK if the scan command is successfully sent to the Availink device.
+	/// Return ::AVL_DVBSx_EC_I2CFail if there is an I2C communication problem.
+	/// Return ::AVL_DVBSx_EC_Running if the scan command could not be sent because the Availink device is still processing a previous command.
+	/// Return ::AVL_DVBSx_EC_GeneralFail if the device is not in the blind scan functional mode or if the parameter \a pBSPara->m_uiStartFreq_100kHz is larger than the parameter \a pBSPara->m_uiStopFreq_100kHz
+	AVL_DVBSx_ErrorCode AVL_DVBSx_IBlindScan_Scan(struct AVL_DVBSx_BlindScanPara * pBSPara, AVL_uint16 uiTunerLPF_100kHz, const struct AVL_DVBSx_Chip * pAVLChip );
+
+	/// Queries the blind scan status.
+	/// 
+	/// @param pBSInfo  Pointer to the object in which the blind scan status is to be stored.
+	/// @param pAVLChip Pointer to the ::AVL_DVBSx_Chip object for which the blind scan status is being queried.
+	/// 
+	/// @return ::AVL_DVBSx_ErrorCode, 
+	/// Return ::AVL_DVBSx_EC_OK if the blind scan status has been retrieved.
+	/// Return ::AVL_DVBSx_EC_I2CFail if there is an I2C communication problem.
+	AVL_DVBSx_ErrorCode AVL_DVBSx_IBlindScan_GetScanStatus(struct AVL_DVBSx_BlindScanInfo * pBSInfo, const struct AVL_DVBSx_Chip * pAVLChip );
+
+	/// Cancels the current blind scan operation.
+	/// 
+	/// @param pAVLChip Pointer to the ::AVL_DVBSx_Chip object for which the blind scan operation is being canceled.
+	/// 
+	/// @return ::AVL_DVBSx_ErrorCode, 
+	/// Return ::AVL_DVBSx_EC_OK if the Availink device has been commanded to cancel the blind scan operation.
+	/// Return ::AVL_DVBSx_EC_I2CFail if there is an I2C communication problem.
+	/// Return ::AVL_DVBSx_EC_Running if the blind scan could not be canceled because the device is still processing a previous command.
+	/// @remarks This function sends a cancel command to the Availink device. The internal scan is not be canceled until the current scan section is finished. 
+	/// Call ::AVL_DVBSx_IBase_GetRxOPStatus to determine when the scan cancellation is complete.
+	AVL_DVBSx_ErrorCode AVL_DVBSx_IBlindScan_Cancel(struct AVL_DVBSx_Chip * pAVLChip );
+
+	/// Retrieves the blind scan results.
+	/// 
+	/// @param uiStartIndex  The blind scan results are stored in an array internal to the Availink device. This parameter tells the function the array index at which to retrieve the results.
+	/// @param pChannelCount The number of channel results to be retrieved.  The function updates this value with the actual number of channel results that are reported.
+	/// @param pChannel Pointer to an object in which the blind scan results are to be stored.
+	/// @param pAVLChip Pointer to the ::AVL_DVBSx_Chip object for which the blind scan results are being retrieved.
+	/// 
+	/// @return ::AVL_DVBSx_ErrorCode, 
+	/// Return ::AVL_DVBSx_EC_OK if the blind scan results have been retrieved.
+	/// Return ::AVL_DVBSx_EC_I2CFail if there is an I2C communication problem.
+	/// @remarks The scan results internal to the Availink device are overwritten after a subsequent call to the ::AVL_DVBSx_IBlindScan_Reset function. Be sure to read out all of the channel information before calling ::AVL_DVBSx_IBlindScan_Reset.
+	AVL_DVBSx_ErrorCode AVL_DVBSx_IBlindScan_ReadChannelInfo(AVL_uint16 uiStartIndex, AVL_puint16 pChannelCount, struct AVL_DVBSx_Channel * pChannel, const struct AVL_DVBSx_Chip * pAVLChip );
+
+	/// Resets the Availink device internal blind scan results.
+	/// 
+	/// @param pAVLChip Pointer to the ::AVL_DVBSx_Chip object for which the internal blind scan results are being reset.
+	/// 
+	/// @return ::AVL_DVBSx_ErrorCode, 
+	/// Return ::AVL_DVBSx_EC_OK if the reset operation is successful.
+	/// Return ::AVL_DVBSx_EC_I2CFail if there is an I2C communication problem.
+	AVL_DVBSx_ErrorCode AVL_DVBSx_IBlindScan_Reset( const struct AVL_DVBSx_Chip * pAVLChip );
+
+	#ifdef AVL_CPLUSPLUS
+}
+	#endif
+
+#endif
diff -Naur a/drivers/amlogic/dvb_tv/avl6211/include/IBSP.h b/drivers/amlogic/dvb_tv/avl6211/include/IBSP.h
--- a/drivers/amlogic/dvb_tv/avl6211/include/IBSP.h	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/amlogic/dvb_tv/avl6211/include/IBSP.h	2014-12-11 16:13:50.045617961 +0100
@@ -0,0 +1,115 @@
+/*
+ *           Copyright 2012 Availink, Inc.
+ *
+ *  This software contains Availink proprietary information and
+ *  its use and disclosure are restricted solely to the terms in
+ *  the corresponding written license agreement. It shall not be 
+ *  disclosed to anyone other than valid licensees without
+ *  written permission of Availink, Inc.
+ *
+ */
+
+
+///$Date: 2012-2-9 17:36 $
+///
+///
+/// @file
+/// @brief Defines the BSP functions which the user needs to implement. 
+/// @details These BSP functions are called by SDK API functions. This file also defines some hardware related macros which also need to be 
+/// customized by the user according to their hardware platform. Most of the functions declared here should 
+/// NOT be directly called by the user's applications explicitly.  There are two exceptions.  These are ::AVL_DVBSx_IBSP_Initialize and ::AVL_DVBSx_IBSP_Dispose.
+///
+#ifndef IBSP_h_h
+	#define IBSP_h_h
+
+	#include "avl_dvbsx.h"
+	#include <linux/i2c.h>
+	#include "avlfrontend.h"
+	#ifdef AVL_CPLUSPLUS
+extern "C" {
+	#endif
+
+	#define MAX_II2C_READ_SIZE	64		///< The maximum number of bytes the back end chip can handle in a single I2C read operation. This value must >= 2.
+	#define MAX_II2C_Write_SIZE	64		///< The maximum number of bytes the back end chip can handle in a single I2C write operation. This value must >= 8.
+
+
+	/// Performs initialization for BSP operations.
+	/// 
+	/// @remarks This function should never called inside the SDK. The user can redeclare this function to any prototype.
+	/// @return ::AVL_DVBSx_ErrorCode, 
+	/// Return ::AVL_DVBSx_EC_OK Returned by the function stub provided with the SDK. 
+	AVL_DVBSx_ErrorCode AVL_DVBSx_IBSP_Initialize(void);
+
+	/// Destroys all resources allocated in AVL_DVBSx_IBSP_Initialize and other BSP operations.
+	/// 
+	/// @remarks This function should never called inside the SDK. The user can redeclare this function to any prototype.
+	/// @return ::AVL_DVBSx_ErrorCode, 
+	/// Return ::AVL_DVBSx_EC_OK Returned by the function stub provided with the SDK. 
+	AVL_DVBSx_ErrorCode AVL_DVBSx_IBSP_Dispose(void);
+
+	/// Implements a delay in units of milliseconds.
+	/// 
+	/// @param uiMS: The delay period in units of milliseconds.
+	/// 
+	/// @return ::AVL_DVBSx_ErrorCode, 
+	/// Return ::AVL_DVBSx_EC_OK Returned by the function stub provided with the SDK. 
+	AVL_DVBSx_ErrorCode AVL_DVBSx_IBSP_Delay( AVL_uint32 uiMS );
+
+	/// Performs an I2C read operation.
+	/// 
+	/// @param pAVLChip Pointer to the Availink device for which the read operation is being performed. 
+	/// @param pucBuff Pointer to a buffer in which to place the read data.
+	/// @param puiSize The number of bytes to be read. The function updates this value with the number of bytes actually read. If there is an error, the function sets this value to 0.
+	/// 
+	/// @return ::AVL_DVBSx_ErrorCode, 
+	/// Return ::AVL_DVBSx_EC_OK if the read operation is successful. 
+	/// Return ::AVL_DVBSx_EC_I2CFail if there is an I2C communication problem.
+	/// @remarks This function should perform a direct I2C read operation without first writing the device internal address. The Availink SDK automatically handles writing the device internal address prior to performing the read operation.
+	AVL_DVBSx_ErrorCode AVL_DVBSx_IBSP_I2CRead( const struct AVL_DVBSx_Chip * pAVLChip,  AVL_puchar pucBuff, AVL_puint16 puiSize );
+
+	/// Performs an I2C write operation.
+	/// 
+	/// @param pAVLChip Pointer to the Availink device for which the write operation is being performed.
+	/// @param pucBuff Pointer to a buffer which contains the data to be written.
+	/// @param puiSize The number of bytes to be written. The function updates this value with the number of bytes actually written. If there is an error, the function sets this value to 0.
+	/// 
+	/// @return ::AVL_DVBSx_ErrorCode, 
+	/// Return ::AVL_DVBSx_EC_OK if the write operation is successful. 
+	/// Return ::AVL_DVBSx_EC_I2CFail if there is an I2C communication problem.
+	AVL_DVBSx_ErrorCode AVL_DVBSx_IBSP_I2CWrite( const struct AVL_DVBSx_Chip * pAVLChip,  AVL_puchar pucBuff, AVL_puint16 puiSize );
+
+	/// Initializes a semaphore object.
+	/// 
+	/// @param pSemaphore A pointer to the ::AVL_semaphore object to be initialized.
+	/// 
+	/// @return ::AVL_DVBSx_ErrorCode, 
+	/// Return ::AVL_DVBSx_EC_OK Returned by the function stub provided with the SDK. 
+	/// @remarks All of the semaphore objects should be initialized with 1 as maximum count and the initialized state should be signaled. In particular, after initialization, the first query should succeed.
+	AVL_DVBSx_ErrorCode AVL_DVBSx_IBSP_InitSemaphore( AVL_psemaphore pSemaphore ); 
+
+	/// Queries the semaphore. If the semaphore is held by another thread, the function should be blocked until the semaphore is available.
+	/// 
+	/// @param pSemaphore A pointer to the ::AVL_semaphore object being queried.
+	/// 
+	/// @return ::AVL_DVBSx_ErrorCode, 
+	/// Return ::AVL_DVBSx_EC_OK Returned by the function stub provided with the SDK. 
+	AVL_DVBSx_ErrorCode AVL_DVBSx_IBSP_WaitSemaphore( AVL_psemaphore pSemaphore );         
+
+	/// Releases the semaphore so that it is available.
+	/// 
+	/// @param pSemaphore A pointer to the ::AVL_semaphore object which is being released.
+	/// 
+	/// @return ::AVL_DVBSx_ErrorCode, 
+	/// Return ::AVL_DVBSx_EC_OK Returned by the function stub provided with the SDK. 
+	AVL_DVBSx_ErrorCode AVL_DVBSx_IBSP_ReleaseSemaphore( AVL_psemaphore pSemaphore );
+
+
+	extern AVL_int32 I2CWrite(AVL_uchar I2CSlaveAddr, AVL_uchar *data, AVL_int32 length,int iDeviceId);
+
+
+	extern AVL_int32  I2CRead(AVL_uchar I2CSlaveAddr, AVL_uchar *data, AVL_int32 length,int iDeviceId);
+
+	#ifdef AVL_CPLUSPLUS
+}
+	#endif
+#endif
diff -Naur a/drivers/amlogic/dvb_tv/avl6211/include/IDiseqc.h b/drivers/amlogic/dvb_tv/avl6211/include/IDiseqc.h
--- a/drivers/amlogic/dvb_tv/avl6211/include/IDiseqc.h	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/amlogic/dvb_tv/avl6211/include/IDiseqc.h	2014-12-11 16:13:50.097617561 +0100
@@ -0,0 +1,252 @@
+/*
+ *           Copyright 2012 Availink, Inc.
+ *
+ *  This software contains Availink proprietary information and
+ *  its use and disclosure are restricted solely to the terms in
+ *  the corresponding written license agreement. It shall not be 
+ *  disclosed to anyone other than valid licensees without
+ *  written permission of Availink, Inc.
+ *
+ */
+
+
+///$Date: 2012-2-9 17:36 $
+///
+///
+/// @file
+/// @brief Declares the functions for DiSEqC operations.
+/// @details There are some limitations of the DiSEqC operation. First, it is a half duplex bus. You cannot send and receive data simultaneously. Second, the maximum size of each transmission is 8 bytes.
+/// The DiSEqC interface can operate in different modes such as modulation mode, tone mode and continuous mode. There are functions corresponding to these modes.  If the user changes the operating mode by calling functions
+/// which belong to another mode, the previous operation will be cancelled if it has not finished yet.
+///
+#ifndef IDiseqc_h_h
+	#define IDiseqc_h_h
+
+	#include "avl_dvbsx.h"
+
+	#ifdef AVL_CPLUSPLUS
+extern "C" {
+	#endif
+
+	///@cond
+
+	#define diseqc_tx_cntrl_addr			0x00700000
+	#define diseqc_tone_frac_n_addr			0x00700004
+	#define diseqc_tone_frac_d_addr			0x00700008
+	#define diseqc_tx_st_addr				0x0070000c
+	#define diseqc_rx_parity_addr			0x00700010
+	#define diseqc_rx_msg_tim_addr			0x00700014
+	#define diseqc_rx_st_addr				0x00700018
+	#define diseqc_rx_cntrl_addr			0x0070001c
+	#define diseqc_srst_addr				0x00700020
+	#define diseqc_bit_time_addr			0x00700024
+	#define diseqc_samp_frac_n_addr			0x00700028
+	#define diseqc_samp_frac_d_addr			0x0070002c
+	#define diseqc_bit_decode_range_addr	0x00700030
+	#define diseqc_rx_fifo_map_addr			0x00700040
+	#define diseqc_tx_fifo_map_addr			0x00700080
+
+	///@endcond
+
+	///
+	/// When transmitting data in Tone0 or Tone1 mode, there is a gap between two tones. This enumeration defines the gap length.
+	enum AVL_DVBSx_Diseqc_TxGap
+	{
+		AVL_DVBSx_DTXG_15ms = 0,		///< = 0  The gap is 15 ms.
+		AVL_DVBSx_DTXG_20ms = 1,		///< = 1  The gap is 20 ms.
+		AVL_DVBSx_DTXG_25ms = 2,		///< = 2  The gap is 25 ms.
+		AVL_DVBSx_DTXG_30ms = 3			///< = 3  The gap is 30 ms.
+	};
+
+	///
+	/// Defines the transmit mode.
+	enum AVL_DVBSx_Diseqc_TxMode
+	{
+		AVL_DVBSx_DTM_Modulation = 0,			///< = 0  Use modulation mode.
+		AVL_DVBSx_DTM_Tone0 = 1,				///< = 1  Send out tone 0.
+		AVL_DVBSx_DTM_Tone1 = 2,				///< = 2  Send out tone 1.
+		AVL_DVBSx_DTM_Continuous = 3			///< = 3  Continuously send out pulses.
+	};
+
+	///
+	/// Configures the DiSEqC output waveform mode.
+	enum AVL_DVBSx_Diseqc_WaveFormMode
+	{
+		AVL_DVBSx_DWM_Normal = 0,			///< = 0  Normal waveform mode
+		AVL_DVBSx_DWM_Envelope = 1			///< = 1  Envelope waveform mode
+	};
+
+	///
+	/// After data is transmitted to the DiSEqC device, the DiSEqC device may return some data. 
+	/// This enumeration controls the amount of time for which the Availink device will open the DiSEqC input FIFO to receive the data. Data that 
+	/// is received outside of this time frame is abandoned.
+	enum AVL_DVBSx_Diseqc_RxTime
+	{
+		AVL_DVBSx_DRT_150ms = 0,		///< = 0  Wait 150 ms for receive data and then close the input FIFO.
+		AVL_DVBSx_DRT_170ms = 1,		///< = 1  Wait 170 ms for receive data and then close the input FIFO.
+		AVL_DVBSx_DRT_190ms = 2,		///< = 2  Wait 190 ms for receive data and then close the input FIFO.
+		AVL_DVBSx_DRT_210ms = 3			///< = 3  Wait 210 ms for receive data and then close the input FIFO.
+	};
+
+	/// Stores the DiSEqC configuration parameters.
+	/// 
+	struct AVL_DVBSx_Diseqc_Para
+	{
+		AVL_uint16 m_ToneFrequency_kHz;						///< The DiSEqC bus speed in units of kHz. Normally, it is 22kHz. 
+		enum AVL_DVBSx_Diseqc_TxGap m_TXGap;				///< Transmit gap
+		enum AVL_DVBSx_Diseqc_WaveFormMode m_TxWaveForm;	///< Transmit waveform format
+		enum AVL_DVBSx_Diseqc_RxTime m_RxTimeout;			///< Receive time frame window
+		enum AVL_DVBSx_Diseqc_WaveFormMode m_RxWaveForm;	///< Receive waveform format
+	};
+
+	/// Stores the DiSEqC transmitter status.
+	/// 
+	struct AVL_DVBSx_Diseqc_TxStatus
+	{
+		AVL_uchar m_TxDone;				///< Indicates whether the transmission is complete (1 - transmission is finished, 0 - transmission is still in progress).
+		AVL_uchar m_TxFifoCount;		///< The number of bytes remaining in the transmit FIFO
+	};
+
+	/// Stores the DiSEqC receiver status
+	/// 
+	struct AVL_DVBSx_Diseqc_RxStatus
+	{
+		AVL_uchar m_RxFifoCount;		///< The number of bytes in the DiSEqC receive FIFO.
+		AVL_uchar m_RxFifoParChk;		///< The parity check result of the received data. This is a bit-mapped field in which each bit represents the parity check result for each each byte in the receive FIFO.  The upper bits without corresponding data are undefined. If a bit is 1, the corresponding byte in the FIFO has good parity. For example, if three bytes are in the FIFO, and the parity check value is 0x03 (value of bit 2 is zero), then the first and the second bytes in the receive FIFO are good. The third byte had bad parity. 
+		AVL_uchar m_RxDone;				///< 1 if the receiver window is turned off, 0 if it is still in receiving state.
+	};
+
+	/// Initializes the DiSEqC component using the configuration parameters in \a pDiseqcPara.
+	/// 
+	/// @param pDiseqcPara  Pointer to the DiSEqC configuration parameters.
+	/// @param pAVLChip Pointer to the ::AVL_DVBSx_Chip object for which the DiSEqC interface is being initialized.
+	/// 
+	/// @return ::AVL_DVBSx_ErrorCode, 
+	/// Return ::AVL_DVBSx_EC_OK if the DiSEqC interface has been initialized.
+	/// Return ::AVL_DVBSx_EC_I2CFail if there is an I2C communication problem.
+	AVL_DVBSx_ErrorCode AVL_DVBSx_IDiseqc_Initialize( const struct AVL_DVBSx_Diseqc_Para * pDiseqcPara, struct AVL_DVBSx_Chip * pAVLChip );
+
+	/// Reads data from the DiSEqC input FIFO.
+	/// 
+	/// @param pucBuff Pointer to a buffer in which the read data should be stored.
+	/// @param pucSize The number of bytes to read from the FIFO. The maximum value is 8.  The function updates this parameter to indicate the number of bytes that have actually been read.
+	/// @param pAVLChip Pointer to the ::AVL_DVBSx_Chip object for which the DiSEqC input FIFO is being read.
+	/// 
+	/// @return ::AVL_DVBSx_ErrorCode, 
+	/// Return ::AVL_DVBSx_EC_OK if the DiSEqC input FIFO has been read. 
+	/// Return ::AVL_DVBSx_EC_I2CFail if there is an I2C communication problem.
+	/// Return ::AVL_DVBSx_EC_GeneralFail if the DiSEqC interface is not in modulation mode or if the DiSEqC interface is still receiving the data.
+	/// @remarks Availink recommends that the user call ::AVL_DVBSx_IDiseqc_GetRxStatus before calling this function. 
+	AVL_DVBSx_ErrorCode AVL_DVBSx_IDiseqc_ReadModulationData( AVL_puchar pucBuff, AVL_puchar pucSize, struct AVL_DVBSx_Chip * pAVLChip );
+
+	/// Sends data to the DiSEqC bus. 
+	/// 
+	/// @param pucBuff Pointer to an array which contains the data to be sent to the DiSEqC bus.
+	/// @param ucSize The number of bytes to be sent. The maximum is 8.
+	/// @param pAVLChip Pointer to the ::AVL_DVBSx_Chip object for which data is to be sent to the DiSEqC bus.
+	/// 
+	/// @return ::AVL_DVBSx_ErrorCode, 
+	/// Return ::AVL_DVBSx_EC_OK if the data has been sent
+	/// Return ::AVL_DVBSx_EC_I2CFail if there is an I2C communication problem.
+	/// Return ::AVL_DVBSx_EC_Running if it is not safe to switch the DiSEqC mode because the last transmission is not complete yet.
+	/// Return ::AVL_DVBSx_EC_MemoryRunout if \aucSize is larger than 8.
+	AVL_DVBSx_ErrorCode AVL_DVBSx_IDiseqc_SendModulationData( const AVL_puchar pucBuff, AVL_uchar ucSize, struct AVL_DVBSx_Chip * pAVLChip );
+
+	/// Checks the current status of the DiSEqC transmitter.
+	/// 
+	/// @param pTxStatus  Pointer to an object in which to store the DiSEqC transmitter status.
+	/// @param pAVLChip Pointer to the ::AVL_DVBSx_Chip object for which the transmit status is being checked.
+	/// 
+	/// @return ::AVL_DVBSx_ErrorCode, 
+	/// Return ::AVL_DVBSx_EC_OK if the transmit status has been retrieved.
+	/// Return ::AVL_DVBSx_EC_I2CFail if there is an I2C communication problem.
+	AVL_DVBSx_ErrorCode AVL_DVBSx_IDiseqc_GetTxStatus( struct AVL_DVBSx_Diseqc_TxStatus * pTxStatus, struct AVL_DVBSx_Chip * pAVLChip );
+
+	/// Checks the current status of the DiSEqC receiver.
+	/// 
+	/// @param pRxStatus  Pointer to an object in which to store the DiSEqC receiver status information.
+	/// @param pAVLChip Pointer to the ::AVL_DVBSx_Chip object for which the receiver status is being checked.
+	/// 
+	/// @return ::AVL_DVBSx_ErrorCode, 
+	/// Return ::AVL_DVBSx_EC_OK if the receiver status has been retrieved.
+	/// Return ::AVL_DVBSx_EC_I2CFail if there is an I2C communication problem.
+	/// Return ::AVL_DVBSx_EC_GeneralFail if the DiSEqC component is not in modulation mode.
+	AVL_DVBSx_ErrorCode AVL_DVBSx_IDiseqc_GetRxStatus( struct AVL_DVBSx_Diseqc_RxStatus * pRxStatus, struct AVL_DVBSx_Chip * pAVLChip );
+
+	/// Sets the output level of pin LNB_CNTRL_0.  This pin is typically used to control LNB polarization.
+	/// 
+	/// @param uiOut Controls the level of pin LNB_CNTRL_0 (0 - Set output level low, 1 - Set output level high).
+	/// @param pAVLChip Pointer to the ::AVL_DVBSx_Chip object for which the output level of pin LNB_CNTRL_0 is being set.
+	/// 
+	/// @return ::AVL_DVBSx_ErrorCode, 
+	/// Return ::AVL_DVBSx_EC_OK if the pin level has been configured.
+	/// Return ::AVL_DVBSx_EC_I2CFail if there is an I2C communication problem.
+	AVL_DVBSx_ErrorCode AVL_DVBSx_IDiseqc_SetLNBOut( AVL_uchar uiOut, struct AVL_DVBSx_Chip * pAVLChip );    
+
+	/// Gets the output level of pin LNB_CNTRL_0.
+	/// 
+	/// @param puiOut Pointer to a variable in which to store the pin output level (0 - Output level is low, 1 - Output level is high).
+	/// @param pAVLChip Pointer to the ::AVL_DVBSx_Chip object for which the pin output level is being read.
+	/// 
+	/// @return ::AVL_DVBSx_ErrorCode, 
+	/// Return ::AVL_DVBSx_EC_OK if the pin level has been read.
+	/// Return ::AVL_DVBSx_EC_I2CFail if there is an I2C communication problem.
+	AVL_DVBSx_ErrorCode AVL_DVBSx_IDiseqc_GetLNBOut( AVL_puchar puiOut, struct AVL_DVBSx_Chip * pAVLChip );
+
+	/// Configures the device to transmit the DiSEqC Tone.
+	/// 
+	/// @param ucTone  Configures the tone to be transmitted (0 - Tone_0, 1 - Tone_1).
+	/// @param ucCount  The number of tones to be transmitted.  The maximum value is 8.
+	/// @param pAVLChip Pointer to the ::AVL_DVBSx_Chip object which is being configured to transmit the tones.
+	/// 
+	/// @return ::AVL_DVBSx_ErrorCode, 
+	/// Return ::AVL_DVBSx_EC_OK if the device has been configured to transmit the DiSEqC tones.
+	/// Return ::AVL_DVBSx_EC_I2CFail if there is an I2C communication problem.
+	/// Return ::AVL_DVBSx_EC_MemoryRunout if \aucCount is larger than 8.
+	/// Return ::AVL_DVBSx_EC_Running if it is not safe to switch the DiSEqC mode because the last transmission is not complete.
+	AVL_DVBSx_ErrorCode AVL_DVBSx_IDiseqc_SendTone( AVL_uchar ucTone, AVL_uchar ucCount, struct AVL_DVBSx_Chip * pAVLChip );
+
+	/// Configures the device to output a continuous 22kHz DiSEqC waveform.
+	/// 
+	/// @param pAVLChip Pointer to the ::AVL_DVBSx_Chip object which is being configured to output the waveform.
+	/// 
+	/// @return ::AVL_DVBSx_ErrorCode, 
+	/// Return ::AVL_DVBSx_EC_OK if the device has been configured to transmit the waveform.
+	/// Return ::AVL_DVBSx_EC_I2CFail if there is an I2C communication problem.
+	/// Return ::AVL_DVBSx_EC_Running if it is not safe to switch the DiSEqC mode because the last transmission is not complete.
+	AVL_DVBSx_ErrorCode AVL_DVBSx_IDiseqc_StartContinuous (struct AVL_DVBSx_Chip * pAVLChip );
+
+	/// Configures the device to stop outputting a continuous  22kHz DiSEqC waveform.
+	/// 
+	/// @param pAVLChip Pointer to the ::AVL_DVBSx_Chip object which is being configured to stop outputting the waveform.
+	/// 
+	/// @return ::AVL_DVBSx_ErrorCode, 
+	/// Return ::AVL_DVBSx_EC_OK if the device has been configured to stop transmitting the waveform.
+	/// Return ::AVL_DVBSx_EC_I2CFail if there is an I2C communication problem.
+	AVL_DVBSx_ErrorCode AVL_DVBSx_IDiseqc_StopContinuous (struct AVL_DVBSx_Chip * pAVLChip );
+
+	/// Sets the output level of pin LNB_CNTRL_1.  This pin is also can used to control LNB polarization.
+	/// 
+	/// @param uiOut Controls the level of pin LNB_CNTRL_1 (0 - Set output level low, 1 - Set output level high).
+	/// @param pAVLChip Pointer to the ::AVL_DVBSx_Chip object for which the output level of pin LNB_CNTRL_1 is being set.
+	/// 
+	/// @return ::AVL_DVBSx_ErrorCode, 
+	/// Return ::AVL_DVBSx_EC_OK if the pin level has been configured.
+	/// Return ::AVL_DVBSx_EC_I2CFail if there is an I2C communication problem.
+	AVL_DVBSx_ErrorCode AVL_DVBSx_IDiseqc_SetLNB1Out( AVL_uchar uiOut, struct AVL_DVBSx_Chip * pAVLChip );    
+
+	/// Gets the output level of pin LNB_CNTRL_1.
+	/// 
+	/// @param puiOut Pointer to a variable in which to store the pin output level (0 - Output level is low, 1 - Output level is high).
+	/// @param pAVLChip Pointer to the ::AVL_DVBSx_Chip object for which the pin output level is being read.
+	/// 
+	/// @return ::AVL_DVBSx_ErrorCode, 
+	/// Return ::AVL_DVBSx_EC_OK if the pin level has been read.
+	/// Return ::AVL_DVBSx_EC_I2CFail if there is an I2C communication problem.
+	AVL_DVBSx_ErrorCode AVL_DVBSx_IDiseqc_GetLNB1Out( AVL_puchar puiOut, struct AVL_DVBSx_Chip * pAVLChip );
+
+	#ifdef AVL_CPLUSPLUS
+}
+	#endif
+
+#endif
diff -Naur a/drivers/amlogic/dvb_tv/avl6211/include/II2C.h b/drivers/amlogic/dvb_tv/avl6211/include/II2C.h
--- a/drivers/amlogic/dvb_tv/avl6211/include/II2C.h	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/amlogic/dvb_tv/avl6211/include/II2C.h	2014-12-11 16:13:50.125617349 +0100
@@ -0,0 +1,132 @@
+/*
+ *           Copyright 2012 Availink, Inc.
+ *
+ *  This software contains Availink proprietary information and
+ *  its use and disclosure are restricted solely to the terms in
+ *  the corresponding written license agreement. It shall not be 
+ *  disclosed to anyone other than valid licensees without
+ *  written permission of Availink, Inc.
+ *
+ */
+
+
+///$Date: 2012-2-9 17:36 $
+///
+///@file
+///@brief This interface provides functions for performing atomic I2C operations.
+///@details The user should always use the functions provided in this file to perform I2C operations. These functions provide 
+/// multi_thread protection and they automatically break potentially large I2C transactions into smaller I2C transactions to 
+/// meet the hardware limitations defined in the BSP. 
+/// These functions also eliminate the difference between the big endian and little endian systems. Please note that 
+/// these I2C functions can only be used to perform I2C operations with the Availink device. When reading and writing data from and to
+/// the Availink device, all data is treated as unsigned data. The user needs to cast data properly to get desired values.
+/// 
+#ifndef II2C_h_h
+	#define II2C_h_h
+
+	#include "avl_dvbsx.h"
+	#include "avl_dvbsx_globals.h"
+
+	#ifdef AVL_CPLUSPLUS
+extern "C" {
+	#endif
+
+	/// @cond
+	
+	/// Initializes I2C operation.
+	/// 
+	/// 
+	/// @return ::AVL_DVBSx_ErrorCode, 
+	/// Return ::AVL_DVBSx_EC_OK if I2C functionality has been initialized.
+	/// Return ::AVL_DVBSx_EC_MemoryRunout if the semaphores cannot be initialized.
+	/// @remarks This is an internal SDK function. This function must be called before any I2C operations. The user does not need to worry about calling this function directly because it is called by the SDK function ::InitAVL_DVBSx_ChipObject.
+	AVL_DVBSx_ErrorCode AVL_DVBSx_II2C_Initialize(void);
+
+	/// @endcond
+	
+	/// This function reads one or more bytes from the Availink device.  The bytes are read from the device internal address specified by the user.
+	/// 
+	/// @param pAVLChip  Pointer to the ::AVL_DVBSx_Chip object for which the read operation is being performed.
+	/// @param uiOffset  The Availink device internal address from where the function is to read data.
+	/// @param pucBuff  Pointer to a buffer in which to store the read data.
+	/// @param uiSize The number of bytes to read.
+	/// 
+	/// @return ::AVL_DVBSx_ErrorCode, 
+	/// Return ::AVL_DVBSx_EC_OK if the data has been read from the Availink device.
+	/// Return ::AVL_DVBSx_EC_I2CFail if there is an I2C communication problem.
+	/// @remarks The function first performs an I2C write operation to send the read address to the Availink device.
+	AVL_DVBSx_ErrorCode AVL_DVBSx_II2C_Read( const struct AVL_DVBSx_Chip * pAVLChip, AVL_uint32 uiOffset, AVL_puchar pucBuff, AVL_uint16 uiSize);
+
+	/// Reads one or more bytes from the Availink device at the current address.
+	/// 
+	/// @param pAVLChip  Pointer to the ::AVL_DVBSx_Chip object for which the read operation is being performed.
+	/// @param pucBuff  Pointer to a buffer in which to store the read data.
+	/// @param uiSize The number of bytes to read.
+	/// 
+	/// @return ::AVL_DVBSx_ErrorCode, 
+	/// Return ::AVL_DVBSx_EC_OK if the data has been read from the Availink device.
+	/// Return ::AVL_DVBSx_EC_I2CFail if there is an I2C communication problem.
+	/// @remarks The function will directly performs an I2C read operation.  
+	AVL_DVBSx_ErrorCode AVL_DVBSx_II2C_ReadDirect( const struct AVL_DVBSx_Chip * pAVLChip, AVL_puchar pucBuff, AVL_uint16 uiSize);
+
+	/// This function writes one or more bytes to the Availink device.
+	/// 
+	/// @param pAVLChip  Pointer to the ::AVL_DVBSx_Chip object to which data is to be written.
+	/// @param pucBuff  Pointer to a buffer which contains the data to be written.
+	/// @param uiSize The number of bytes to be written.  The minimum permissible value is 3.
+	/// 
+	/// @return ::AVL_DVBSx_ErrorCode, 
+	/// Return ::AVL_DVBSx_EC_OK if the data has been written to the Availink device.
+	/// Return ::AVL_DVBSx_EC_I2CFail if there is an I2C communication problem.
+	/// Return ::AVL_DVBSx_EC_GeneralFail if uiSize is less than 3.
+	AVL_DVBSx_ErrorCode AVL_DVBSx_II2C_Write( const struct AVL_DVBSx_Chip * pAVLChip, AVL_puchar pucBuff, AVL_uint16 uiSize);
+
+	/// Reads a 16-bit unsigned integer from the Availink device.
+	/// 
+	/// @param pAVLChip  Pointer to the ::AVL_DVBSx_Chip object from which data is being read.
+	/// @param uiAddr  The Availink device internal address from where the data is to be read.
+	/// @param puiData Pointer to a variable in which to store the read data.
+	/// 
+	/// @return ::AVL_DVBSx_ErrorCode, 
+	/// Return ::AVL_DVBSx_EC_OK if the data has been read from the Availink device.
+	/// Return ::AVL_DVBSx_EC_I2CFail if there is an I2C communication problem.
+	AVL_DVBSx_ErrorCode AVL_DVBSx_II2C_Read16( const struct AVL_DVBSx_Chip * pAVLChip, AVL_uint32 uiAddr, AVL_puint16 puiData );
+
+	/// Reads a 32-bit unsigned integer from the Availink device.
+	/// 
+	/// @param pAVLChip  Pointer to the ::AVL_DVBSx_Chip object from which data is being read.
+	/// @param uiAddr  The Availink device internal address from where the data is to be read.
+	/// @param puiData Pointer to a variable in which to store the read data.
+	/// 
+	/// @return ::AVL_DVBSx_ErrorCode, 
+	/// Return ::AVL_DVBSx_EC_OK if the data has been read from the Availink device.
+	/// Return ::AVL_DVBSx_EC_I2CFail if there is an I2C communication problem.
+	AVL_DVBSx_ErrorCode AVL_DVBSx_II2C_Read32( const struct AVL_DVBSx_Chip * pAVLChip, AVL_uint32 uiAddr, AVL_puint32 puiData );
+
+	/// Writes a 16-bit unsigned integer to the Availink device.
+	/// 
+	/// @param pAVLChip  Pointer to the ::AVL_DVBSx_Chip object to which data is being written.
+	/// @param uiAddr  The Availink device internal address to which the data is to be written.
+	/// @param uiData The data to be written to the Availink device.
+	/// 
+	/// @return ::AVL_DVBSx_ErrorCode, 
+	/// Return ::AVL_DVBSx_EC_OK if the data has been written to the Availink device.
+	/// Return ::AVL_DVBSx_EC_I2CFail if there is an I2C communication problem.
+	AVL_DVBSx_ErrorCode AVL_DVBSx_II2C_Write16( const struct AVL_DVBSx_Chip * pAVLChip, AVL_uint32 uiAddr, AVL_uint16 uiData );
+
+	/// Writes a 32-bit unsigned integer to the Availink device.
+	/// 
+	/// @param pAVLChip  Pointer to the ::AVL_DVBSx_Chip object to which the data is being written.
+	/// @param uiAddr  The Availink device internal address to which the data is to be written.
+	/// @param uiData The data to be written to the Availink device.
+	/// 
+	/// @return ::AVL_DVBSx_ErrorCode, 
+	/// Return ::AVL_DVBSx_EC_OK if the data has been written to the Availink device.
+	/// Return ::AVL_DVBSx_EC_I2CFail if there is an I2C communication problem.
+	AVL_DVBSx_ErrorCode AVL_DVBSx_II2C_Write32( const struct AVL_DVBSx_Chip * pAVLChip, AVL_uint32 uiAddr, AVL_uint32 uiData );
+
+	#ifdef AVL_CPLUSPLUS
+}
+	#endif
+
+#endif
diff -Naur a/drivers/amlogic/dvb_tv/avl6211/include/II2CRepeater.h b/drivers/amlogic/dvb_tv/avl6211/include/II2CRepeater.h
--- a/drivers/amlogic/dvb_tv/avl6211/include/II2CRepeater.h	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/amlogic/dvb_tv/avl6211/include/II2CRepeater.h	2014-12-11 16:13:50.077617717 +0100
@@ -0,0 +1,134 @@
+/*
+ *           Copyright 2012 Availink, Inc.
+ *
+ *  This software contains Availink proprietary information and
+ *  its use and disclosure are restricted solely to the terms in
+ *  the corresponding written license agreement. It shall not be 
+ *  disclosed to anyone other than valid licensees without
+ *  written permission of Availink, Inc.
+ *
+ */
+
+
+///$Date: 2012-2-9 17:36 $
+///
+///
+/// @file
+/// @brief Defines functions for initializing and controlling the I2C repeater.
+/// @details The I2C repeater provides a dedicated I2C bus for tuner control. It is 
+/// recommended that the functions in this interface be used to implement a tuner 
+/// driver for the tuner being used. For customer convenience, Availink provides tested 
+/// tuner drivers for a variety tuner devices.
+/// 
+#ifndef II2CRepeater_h_h
+	#define II2CRepeater_h_h
+
+	#include "avl_dvbsx.h"
+	#include "avl_dvbsx_globals.h"
+
+	#ifdef AVL_CPLUSPLUS
+extern "C" {
+	#endif
+
+	///@cond
+
+	#define I2CM_CMD_LENGTH   0x14
+	#define I2CM_RSP_LENGTH   0x14
+
+	#define OP_I2CM_NOOP      0x00
+	#define OP_I2CM_INIT	  0x01
+	#define OP_I2CM_WRITE     0x02
+	#define OP_I2CM_READ      0x03
+
+	///@endcond
+
+	///@cond
+
+	/// Sends an I2C repeater operational command to the Availink device. 
+	/// 
+	/// @param pBuff Pointer to the array which contains the operational command and its parameters.
+	/// @param ucSize The number of command related bytes in the array to which pBuff points.
+	/// @param pAVLChip A pointer to the ::AVL_DVBSx_Chip object to which an I2C repeater operational command is being sent.
+	/// 
+	/// Return ::AVL_DVBSx_EC_OK if the I2C repeater operational command has been sent to the Availink device.
+	/// Return ::AVL_DVBSx_EC_I2CFail if there is an I2C communication problem.
+	/// Return ::AVL_DVBSx_EC_Running if the command could not be sent to the Availink device because the device is still processing a previous command.
+	AVL_DVBSx_ErrorCode AVL_DVBSx_II2CRepeater_SendOP(AVL_puchar pBuff, AVL_uchar ucSize, struct AVL_DVBSx_Chip * pAVLChip );
+
+	///@endcond
+
+	/// Initializes the I2C repeater.
+	/// 
+	/// @param I2CBusClock_kHz The clock speed of the I2C bus between the tuner and the Availink device.
+	/// @param pAVLChip A pointer to a ::AVL_DVBSx_Chip object for which the I2C repeater is being initialized.
+	/// 
+	/// @return ::AVL_DVBSx_ErrorCode, 
+	/// Return ::AVL_DVBSx_EC_OK if the initialize command has been sent to the Availink device.
+	/// Return ::AVL_DVBSx_EC_I2CFail if there is an I2C communication problem.
+	/// Return ::AVL_DVBSx_EC_Running if the initialize command could not be sent to the Availink device because the device is still processing a previous command.
+	/// @remarks This function must be called before any other function in this interface. This is a nonblocking function.  Call ::AVL_DVBSx_II2CRepeater_GetOPStatus to determine if the I2C repeater is initialized.
+	AVL_DVBSx_ErrorCode AVL_DVBSx_II2CRepeater_Initialize( AVL_uint16 I2CBusClock_kHz, struct AVL_DVBSx_Chip * pAVLChip );
+
+	/// Reads data back from the tuner via the I2C repeater.  This function is used with tuners which insert a stop
+	/// bit between messages.
+	/// 
+	/// @param ucSlaveAddr The slave address of the tuner device. Please note that the Availink device only supports a 7 bit slave address.
+	/// @param pucBuff Pointer to a buffer in which to store the data read from the tuner.
+	/// @param uiSize The number of bytes to read from the tuner.  The maximum value is 20.
+	/// @param pAVLChip A pointer to the ::AVL_DVBSx_Chip object for which data is being read from the tuner.
+	/// 
+	/// @return ::AVL_DVBSx_ErrorCode, 
+	/// Return ::AVL_DVBSx_EC_OK if the data has been read from the tuner.
+	/// Return ::AVL_DVBSx_EC_I2CFail if there is an I2C communication problem.
+	/// Return ::AVL_DVBSx_EC_Running if the read command could not be sent to the Availink device because the device is still processing  a previous command.
+	/// Return ::AVL_DVBSx_EC_GeneralFail if \a uiSize is larger than 20.
+	/// @remarks This function will trigger a I2C read operation. It is used with tuners which insert a stop bit between messages.  The read position (or device internal address) can be determined by calling ::AVL_DVBSx_II2CRepeater_SendData.
+	AVL_DVBSx_ErrorCode AVL_DVBSx_II2CRepeater_ReadData(  AVL_uchar ucSlaveAddr, AVL_puchar pucBuff, AVL_uint16 uiSize, struct AVL_DVBSx_Chip * pAVLChip );
+
+	/// Reads data back from the tuner via the I2C repeater.  This function is used with tuners which do not insert a stop
+	/// bit between messages.
+	/// 
+	/// @param ucSlaveAddr The slave address of the tuner device. Please note that the Availink device only supports a 7 bit slave address.
+	/// @param pucBuff Pointer to the buffer in which to store the read data.
+	/// @param ucRegAddr The address of the register being read.
+	/// @param uiSize The number of bytes to read from the tuner.  The maximum value is 20.
+	/// @param pAVLChip A pointer to the ::AVL_DVBSx_Chip object for which data is being read from the tuner.
+	/// 
+	/// @return ::AVL_DVBSx_ErrorCode, 
+	/// Return ::AVL_DVBSx_EC_OK if the data has been read from the tuner.
+	/// Return ::AVL_DVBSx_EC_I2CFail if there is an I2C communication problem.
+	/// Return ::AVL_DVBSx_EC_Running if the read command could not be sent to the Availink device because the device is still processing a previous command.
+	/// Return ::AVL_DVBSx_EC_GeneralFail if \a uiSize is larger than 20.
+	/// @remarks This function will trigger a I2C read operation. It is used with tuners which do not insert a stop bit between messages.
+	AVL_DVBSx_ErrorCode AVL_DVBSx_II2CRepeater_ReadData_Multi(  AVL_uchar ucSlaveAddr, AVL_puchar pucBuff, AVL_uchar ucRegAddr, AVL_uint16 uiSize, struct AVL_DVBSx_Chip * pAVLChip );
+
+	/// Writes data to the tuner via the I2C repeater.
+	/// 
+	/// @param ucSlaveAddr The slave address of the tuner device. Please note that the Availink device only supports a 7 bit slave address.
+	/// @param ucBuff Pointer to the buffer which contains the data to be sent to the tuner.
+	/// @param uiSize The number of bytes to be sent to the tuner.  The maximum value is 17.
+	/// @param pAVLChip A pointer to the ::AVL_DVBSx_Chip object for which data is being sent to the tuner.
+	/// 
+	/// @return ::AVL_DVBSx_ErrorCode, 
+	/// Return ::AVL_DVBSx_EC_OK if the send command has been sent to the Availink device.
+	/// Return ::AVL_DVBSx_EC_I2CFail if there is an I2C communication problem.
+	/// Return ::AVL_DVBSx_EC_Running if the send command could not be sent to the Availink device because the device is still processing a previous command.
+	/// Return ::AVL_DVBSx_EC_GeneralFail if \a uiSize is larger than 17.
+	/// @remarks The internal register address is buried in the buffer to which \a ucBuff points. This function is a nonblocking function.  Call ::AVL_DVBSx_II2CRepeater_GetOPStatus to determine if the write operation is complete.
+	AVL_DVBSx_ErrorCode AVL_DVBSx_II2CRepeater_SendData(  AVL_uchar ucSlaveAddr, const AVL_puchar ucBuff, AVL_uint16 uiSize, struct AVL_DVBSx_Chip * pAVLChip );
+
+	/// Checks if the last I2C repeater operation is finished.
+	/// 
+	/// @param pAVLChip A pointer to the ::AVL_DVBSx_Chip object for which I2C repeater operation status is being queried.
+	/// 
+	/// @return ::AVL_DVBSx_ErrorCode, 
+	/// Return ::AVL_DVBSx_EC_OK if the last I2C repeater operation is complete.
+	/// Return ::AVL_DVBSx_EC_I2CFail if there is an I2C communication problem.
+	/// Return ::AVL_DVBSx_EC_Running if the Availink device is still processing the last I2C repeater operation.
+	AVL_DVBSx_ErrorCode AVL_DVBSx_II2CRepeater_GetOPStatus(const struct AVL_DVBSx_Chip * pAVLChip );
+
+	#ifdef AVL_CPLUSPLUS
+}
+	#endif
+
+#endif
diff -Naur a/drivers/amlogic/dvb_tv/avl6211/include/IRx.h b/drivers/amlogic/dvb_tv/avl6211/include/IRx.h
--- a/drivers/amlogic/dvb_tv/avl6211/include/IRx.h	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/amlogic/dvb_tv/avl6211/include/IRx.h	2014-12-11 16:13:50.041617992 +0100
@@ -0,0 +1,462 @@
+/*
+ *           Copyright 2012 Availink, Inc.
+ *
+ *  This software contains Availink proprietary information and
+ *  its use and disclosure are restricted solely to the terms in
+ *  the corresponding written license agreement. It shall not be 
+ *  disclosed to anyone other than valid licensees without
+ *  written permission of Availink, Inc.
+ *
+ */
+
+
+///$Date: 2012-2-9 17:36 $
+///
+///
+/// @file
+/// @brief Declares functions for the receiver component.
+/// @details Although the user may call these functions from multiple threads, Availink recommends that all
+/// "control" functions be called from a single thread to avoid confusion. 
+/// 
+#ifndef IRx_h_h
+	#define IRx_h_h
+
+	#include "avl_dvbsx.h"
+	#include "avl_dvbsx_globals.h"
+
+	#ifdef AVL_CPLUSPLUS
+extern "C" {
+	#endif
+
+	/// @cond
+	#define rx_aagc_gain								0x0040004C
+    #define rx_Rolloff_addr								0x00400030
+	#define scatter_data_addr							0x00001AD8
+	#define rc_mpeg_bus_tri_enb							0x006C0028
+	#define rc_mpeg_bus_pe								0x006C0038
+	#define rc_rfagc_tri_enb							0x006C002C
+	#define rc_spare_rw_reg_1							0x006C0044
+	#define rp_mpeg_config_addr							0x2652
+	#define rs_imb_status_addr							0x00400058
+	#define rp_phase_imb_addr							0x2650
+	#define rp_amp_imb_addr								0x264E
+	#define rs_cust_chip_id_addr						0x006C0034
+	#define rc_eq_out_iq_swap_addr						0x00402028
+
+	//raptor merge for blind scan fixes to be able to control the tuner step size
+	#define rp_tuner_factor_addr                        0x0000264C
+	#define rp_hsym_acq_th_addr							0x0000264A
+	#define rp_hsym_cd_th_addr							0x00002648	
+
+    #define rc_mpeg_bus_cntrl_addr				        0x400800
+    #define rc_cntns_pkt_para_rate_frac_n_addr	        0x400898
+    #define rc_cntns_pkt_para_rate_frac_d_addr	        0x40089C
+    #define rc_pkt_seri_rate_frac_n_addr		        0x400818
+    #define rc_pkt_seri_rate_frac_d_addr		        0x40081C
+
+
+	#define  rc_pkt_err_count_addr						0x400810
+	#define  rc_pkt_count_addr							0x400814
+	#define  rs_total_words_addr						0x400430
+	#define  rs_total_uncorrected_words_addr			0x400434
+
+
+	/// @endcond
+
+	/// Initializes the demodulator.
+	/// 
+    /// @param pAVLChip A pointer to the ::AVL_DVBSx_Chip object for which the demodulator is being initialized.
+	/// 
+	/// @return ::AVL_DVBSx_ErrorCode, 
+	/// Return ::AVL_DVBSx_EC_OK if the demodulator has been initialized.
+	/// Return ::AVL_DVBSx_EC_I2CFail if there is an I2C communication problem.
+	/// @remarks This function must be called first before all other functions declared in this interface.
+	AVL_DVBSx_ErrorCode AVL_DVBSx_IRx_Initialize(const struct AVL_DVBSx_Chip * pAVLChip );
+
+	/// Configures the Availink device with the polarity of the RF AGC. This value should be set according to the tuner's requirement as specified by the tuner datasheet.
+	/// 
+	/// @param enumAGCPola The polarity of the RF AGC. Refer to ::AVL_DVBSx_RfagcPola.
+    /// @param pAVLChip A pointer to the ::AVL_DVBSx_Chip object which is being configured with the tuner RF AGC polarity.
+	/// 
+	/// @return ::AVL_DVBSx_ErrorCode, 
+	/// Return ::AVL_DVBSx_EC_OK if the tuner RF AGC polarity has been configured.
+	/// Return ::AVL_DVBSx_EC_I2CFail if there is an I2C communication problem.
+	AVL_DVBSx_ErrorCode AVL_DVBSx_IRx_SetRFAGCPola( enum AVL_DVBSx_RfagcPola enumAGCPola, const struct AVL_DVBSx_Chip * pAVLChip );
+
+	/// Configures the MPEG output mode.
+	/// 
+	/// @param pMpegMode A pointer to an object which contains the MPEG output mode configuration. 
+    /// @param pAVLChip A pointer to the ::AVL_DVBSx_Chip object for which the MPEG output mode is being configured.
+	/// 
+	/// @return ::AVL_DVBSx_ErrorCode, 
+	/// Return ::AVL_DVBSx_EC_OK if the MPEG output mode has been configured.
+	/// Return ::AVL_DVBSx_EC_I2CFail if there is an I2C communication problem.
+	AVL_DVBSx_ErrorCode AVL_DVBSx_IRx_SetMpegMode( const struct AVL_DVBSx_MpegInfo * pMpegMode, const struct AVL_DVBSx_Chip * pAVLChip );
+
+	/// Gets the RF signal level.
+	/// 
+	/// @param puiRFSignalLevel Pointer to a variable in which to store signal level.  The signal level value ranges from 0 to 65535, with zero corresponding to the weakest signal level value and 65535 corresponding to the strongest signal level value.
+	/// @param pAVLChip A pointer to the ::AVL_DVBSx_Chip object for which the signal level is being retrieved.
+	/// 
+	/// @return ::AVL_DVBSx_ErrorCode, 
+	/// Return ::AVL_DVBSx_EC_OK if the signal level has been retrieved.
+	/// Return ::AVL_DVBSx_EC_I2CFail if there is an I2C communication problem.
+	/// @remarks This function actually reads the RF AGC value. The corresponding signal power in dBm varies depending on the tuner. The user can derive the relationship from the Tuner datasheet or through measurement.
+	AVL_DVBSx_ErrorCode AVL_DVBSx_IRx_GetSignalLevel(AVL_puint16 puiRFSignalLevel , const struct AVL_DVBSx_Chip * pAVLChip );
+
+	/// Sets the carrier frequency sweep range for subsequent LockChannel calls. Use of this function is optional.  The default value is 500 (+/-5MHz). This function is typically used to narrow the sweep range in cases where there are multiple narrow bandwidth signals within the default range and there is the possibility that the wrong signal will be locked.  If multiple signals are detected within the specified sweep range, the Availink device will lock to the strongest one.
+	/// 
+	/// @param uiFreqSweepRange_10kHz Half of the frequency sweep range in units of 10kHz. The maximum value is 500 (sweep from -5MHz to +5MHz).
+    /// @param pAVLChip A pointer to the ::AVL_DVBSx_Chip object for which the frequency sweep range is being set.
+	/// 
+	/// @return ::AVL_DVBSx_ErrorCode, 
+	/// Return ::AVL_DVBSx_EC_OK if the frequency sweep range is successfully configured.
+	/// Return ::AVL_DVBSx_EC_I2CFail if there is an I2C communication problem.
+	/// @remarks The input parameter uiFreqSweepRange_10kHz specifies half of the actual sweep range. The whole range will be [-uiFreqSweepRange_10kHz, +uiFreqSweepRange_10kHz]. Note that this sweep range must be large enough to accommodate the RF path frequency uncertainty.
+	AVL_DVBSx_ErrorCode AVL_DVBSx_IRx_SetFreqSweepRange(AVL_uint16 uiFreqSweepRange_10kHz, const struct AVL_DVBSx_Chip * pAVLChip );
+
+	/// Configures the m_Flags member of the AVL_DVBSx_Channel object with the desired lock mode.  On boot-up the default channel lock mode is AVL_DVBSx_LOCK_MODE_FIXED.
+	/// 
+	/// @param psChannel  Pointer to the channel object for which to configure the lock mode.
+	/// @param enumChannelLockMode The desired lock mode.  Refer to ::AVL_DVBSx_LockMode. 
+	/// 
+	/// @return ::AVL_DVBSx_ErrorCode, 
+	/// Return ::AVL_DVBSx_EC_OK after the m_Flags member of the psChannel input parameter is configured with the desired lock mode.
+	AVL_DVBSx_ErrorCode AVL_DVBSx_IRx_SetChannelLockMode( struct AVL_DVBSx_Channel * psChannel, enum AVL_DVBSx_LockMode enumChannelLockMode );
+
+	/// Locks to a channel using the parameters specified in \a psChannel.
+	/// 
+	/// @param psChannel  Holds the channel related parameters needed by the Availink device to lock to the input signal.
+	/// @param pAVLChip A pointer to the AVL_DVBSx_Chip object for which the lock operation is being performed. 
+	/// 
+	/// @return ::AVL_DVBSx_ErrorCode, 
+	/// Return ::AVL_DVBSx_EC_OK if the lock parameters and command are successfully sent to the device.
+	/// Return ::AVL_DVBSx_EC_I2CFail if there is an I2C communication problem.
+	/// Return ::AVL_DVBSx_EC_Running if the lock command could not be sent to the device because the device is still processing a previous command.
+	/// @remarks Calling this function commands the Availink device to lock to a particular channel. Use the function 
+	/// GetLockStatus to determine if the device has successfully locked to the channel. The channel lock operation is 
+	/// performed in either fixed mode or adaptive mode depending on how the psChannel input parameter has been configured.  
+	/// Please see the function SetChannelLockMode for more details regarding how to configure the channel object for either mode.  This function can perform automatic IQ swap if \a psChannel->m_Flags has the CI_FLAG_IQ_AUTO_BIT bit set.
+	AVL_DVBSx_ErrorCode AVL_DVBSx_IRx_LockChannel( struct AVL_DVBSx_Channel * psChannel, struct AVL_DVBSx_Chip * pAVLChip );
+
+	/// Checks if the Availink device has locked to the channel.
+	/// 
+	/// @param puiLockStatus Pointer to a variable in which to store the channel lock status (0 - Not locked 1 - Locked).
+	/// @param pAVLChip A pointer to the ::AVL_DVBSx_Chip object for which the lock status is being queried.
+	/// 
+	/// @return ::AVL_DVBSx_ErrorCode, 
+	/// Return ::AVL_DVBSx_EC_OK if the channel lock status has been retrieved.
+	/// Return ::AVL_DVBSx_EC_I2CFail if there is an I2C communication problem.
+	/// @remarks This function should be called after the function ::AVL_DVBSx_IRx_LockChannel is called.
+	AVL_DVBSx_ErrorCode AVL_DVBSx_IRx_GetLockStatus( AVL_puint16 puiLockStatus, const struct AVL_DVBSx_Chip * pAVLChip );
+
+	/// Resets the BER and PER accumulation statistics.
+	/// 
+	/// @param pAVLChip A pointer to the ::AVL_DVBSx_Chip object for which the BER and PER statistics are being reset.
+	/// 
+	/// @return ::AVL_DVBSx_ErrorCode, 
+	/// Return ::AVL_DVBSx_EC_OK if command to reset the BER and PER statistics has been sent to the Availink device.
+	/// Return ::AVL_DVBSx_EC_I2CFail if there is an I2C communication problem.
+	/// Return ::AVL_DVBSx_EC_Running if the command could not be sent to the Availink device because the device is still processing a previous command.
+	AVL_DVBSx_ErrorCode AVL_DVBSx_IRx_ResetErrorStat( struct AVL_DVBSx_Chip * pAVLChip );
+
+	/// Retrieves the scatter data from the Availink device. 
+	/// 
+	/// @param ucpData  Pointer to an array in which to store the scatter data. The buffer size MUST be >= 2*(*puiSize) because there are two bytes per set of IQ data. The first (*puiSize) bytes in the buffer are I values, and the following (*puiSize) bytes are Q values.
+	/// @param puiSize  The number of IQ pairs to be read.  The function updates this value with the number of IQ pairs actually retrieved.
+	/// @param pAVLChip A pointer to the ::AVL_DVBSx_Chip object for which the scatter data is being retrieved.
+	/// 
+	/// @return ::AVL_DVBSx_ErrorCode, 
+	/// Return ::AVL_DVBSx_EC_OK if the scatter data has been retrieved.
+	/// Return ::AVL_DVBSx_EC_I2CFail if there is an I2C communication problem.
+	/// Return ::AVL_DVBSx_EC_Running if the scatter data is not ready for retrieval.
+	/// @remarks Normally, the size of the scatter data will be 132 sets of IQ. i.e. 264 bytes.
+	AVL_DVBSx_ErrorCode AVL_DVBSx_IRx_GetScatterData( AVL_puchar ucpData, AVL_puint16 puiSize, const struct AVL_DVBSx_Chip * pAVLChip );
+
+	/// Reads the current SNR estimate.
+	/// 
+	/// @param puiSNR_db Pointer to a variable in which to store the estimated SNR value.  The SNR value is scaled by 100. For example, a reported SNR value of 2578 means the SNR value is 25.78 db.
+	/// @param pAVLChip A pointer to the ::AVL_DVBSx_Chip object for which estimated SNR is being read.
+	/// 
+	/// @return ::AVL_DVBSx_ErrorCode, 
+	/// Return ::AVL_DVBSx_EC_OK if the SNR has been retrieved.
+	/// Return ::AVL_DVBSx_EC_I2CFail if there is an I2C communication problem.
+	/// @remarks It takes a few seconds for the device to calculate a stable SNR value after FEC lock. The function returns an SNR value of 0 before a stable SNR value is calculated.
+	AVL_DVBSx_ErrorCode AVL_DVBSx_IRx_GetSNR( AVL_puint32 puiSNR_db, const struct AVL_DVBSx_Chip * pAVLChip );
+
+	/// Reads the current PER calculation result.
+	/// 
+	/// @param puiPER Pointer to a variable in which to store the PER value. The value is scaled by 1e+9. For example, if the reported value is 123456, the PER value is 0.000123456.
+	/// @param pAVLChip A pointer to the ::AVL_DVBSx_Chip object for which the PER is being retrieved.
+	/// 
+	/// @return ::AVL_DVBSx_ErrorCode, 
+	/// Return ::AVL_DVBSx_EC_OK if the PER has been retrieved.
+	/// Return ::AVL_DVBSx_EC_I2CFail if there is an I2C communication problem.
+	/// @remarks It takes a few seconds for the device to calculates a stable PER value after FEC lock. The function reports a PER of 0 until a stable PER is calculated.
+	AVL_DVBSx_ErrorCode AVL_DVBSx_IRx_GetPER( AVL_puint32 puiPER, const struct AVL_DVBSx_Chip * pAVLChip );
+
+	/// Reads the current BER calculation result.
+	/// 
+	/// @param puiBER Pointer to a variable in which to store the current BER value. The value is scaled by 1e+9. For example, a BER reading of 123456 means the that the BER is 0.000123456.
+	/// @param pAVLChip Pointer to the ::AVL_DVBSx_Chip object for which the BER is being read.
+	/// 
+	/// @return ::AVL_DVBSx_ErrorCode, 
+	/// Return ::AVL_DVBSx_EC_OK if the BER has been retrieved.
+	/// Return ::AVL_DVBSx_EC_I2CFail if there is an I2C communication problem.
+	/// @remarks This function is provided for laboratory BER testing.  The function requires the use of a transmitter which can generate either an LFSR15 or LFSR23 data stream.  
+	AVL_DVBSx_ErrorCode AVL_DVBSx_IRx_GetBER( AVL_puint32 puiBER, const struct AVL_DVBSx_Chip * pAVLChip );
+
+	/// Reads the current DVBS BER estimate.
+	/// 
+	/// @param puiBER A pointer to a variable in which to store the estimated DVBS BER value. The value is scaled by 1e+9. For example, a BER reading of 123456 means the estimated BER is 0.000123456.
+	/// @param pAVLChip A pointer to the ::AVL_DVBSx_Chip object for which estimated DVBS BER is being read.
+	/// 
+	/// @return ::AVL_DVBSx_ErrorCode, 
+	/// Return ::AVL_DVBSx_EC_OK if the BER has been retrieved.
+	/// Return ::AVL_DVBSx_EC_I2CFail if there is an I2C communication problem.
+	/// Return ::AVL_DVBSx_EC_GeneralFail if the Availink device is not locked to a DVBS signal.
+	/// @remarks This function reports and estimated BER when a DVB-S signal is received.  The function does not require the input of a known test pattern to the receiver.  It can estimate BER for on-air DVB-S signals. 
+	AVL_DVBSx_ErrorCode AVL_DVBSx_IRx_GetDVBSBER( AVL_puint32 puiBER, const struct AVL_DVBSx_Chip * pAVLChip );
+
+	/// Resets the DVB-S BER estimate.
+	/// 
+	/// @param pAVLChip A pointer to the ::AVL_DVBSx_Chip object for which the DVB-S BER estimate is being reset.
+	/// 
+	/// @return ::AVL_DVBSx_ErrorCode, 
+	/// Return ::AVL_DVBSx_EC_OK if the DVB-S BER estimate has been reset.
+	/// Return ::AVL_DVBSx_EC_I2CFail if there is an I2C communication problem.
+	AVL_DVBSx_ErrorCode AVL_DVBSx_IRx_ResetDVBSBER( const struct AVL_DVBSx_Chip * pAVLChip );
+
+	/// Gets the RF carrier frequency offset. Typically this is used to adjust the tuner frequency.
+	/// 
+	/// @param piRFOffset_100kHz Pointer to a variable in which to store the RF carrier frequency offset in units of 100 kHz. 
+	/// @param pAVLChip A pointer to the ::AVL_DVBSx_Chip object for which the RF carrier frequency offset is being read.
+	/// 
+	/// @return ::AVL_DVBSx_ErrorCode, 
+	/// Return ::AVL_DVBSx_EC_OK if the RF carrier frequency offset has been read.
+	/// Return ::AVL_DVBSx_EC_I2CFail if there is an I2C communication problem.
+	/// @remarks This function may be called after the Availink device has locked to the input signal. 
+	AVL_DVBSx_ErrorCode AVL_DVBSx_IRx_GetRFOffset( AVL_pint16 piRFOffset_100kHz, const struct AVL_DVBSx_Chip * pAVLChip );
+
+	/// Gets the current locked signal information.
+	/// 
+	/// @param pSignalInfo Pointer to an object in which to store the detected signal information. 
+	/// @param pAVLChip Pointer to the ::AVL_DVBSx_Chip object for which the signal information is being retrieved.
+	/// 
+	/// @return ::AVL_DVBSx_ErrorCode, 
+	/// Return ::AVL_DVBSx_EC_OK if the signal information has been retrieved.
+	/// Return ::AVL_DVBSx_EC_I2CFail if there is an I2C communication problem.
+	/// @remarks This function may be called after the Availink device has locked to the input signal.
+	AVL_DVBSx_ErrorCode AVL_DVBSx_IRx_GetSignalInfo( struct AVL_DVBSx_SignalInfo * pSignalInfo, const struct AVL_DVBSx_Chip * pAVLChip );
+
+	/// Allows the user to enable or disable dish pointing mode.
+	/// 
+	/// @param ucMode Indicates whether dish pointing mode is being enabled or disabled (0 - Disable dish pointing mode, 1 - Enable dish pointing mode).  
+	/// @param pAVLChip A pointer to the ::AVL_DVBSx_Chip object for which dish pointing mode is being configured.
+	/// 
+	/// @return ::AVL_DVBSx_ErrorCode, 
+	/// Return ::AVL_DVBSx_EC_OK if dish pointing mode has been configured.
+	/// Return ::AVL_DVBSx_EC_I2CFail if there is an I2C communication problem.
+	/// Return ::AVL_DVBSx_EC_GeneralFail if the Availink device is not in demodulator mode.
+	AVL_DVBSx_ErrorCode AVL_DVBSx_IRx_SetDishPointingMode( AVL_uchar ucMode, const struct AVL_DVBSx_Chip *pAVLChip );
+
+	/// Configures the Availink device to drive the MPEG output interface.
+	/// 
+	/// @param pAVLChip A pointer to the ::AVL_DVBSx_Chip object which is to drive the MPEG output interface.
+	/// 
+	/// @return ::AVL_DVBSx_ErrorCode, 
+	/// Return ::AVL_DVBSx_EC_OK if the device has been successfully configured to drive the MPEG output interface.
+	/// Return ::AVL_DVBSx_EC_I2CFail if there is an I2C communication problem.
+	AVL_DVBSx_ErrorCode AVL_DVBSx_IRx_DriveMpegOutput( const struct AVL_DVBSx_Chip * pAVLChip );
+
+	/// Configures the Availink device to release the MPEG output interface, placing it in a high impedance state.  This allows the MPEG bus to be driven by other devices which may be sharing it with the Availink device.
+	/// 
+	/// @param pAVLChip A pointer to the ::AVL_DVBSx_Chip object which is to release the MPEG output interface.
+	/// 
+	/// @return ::AVL_DVBSx_ErrorCode, 
+	/// Return ::AVL_DVBSx_EC_OK if the device has been successfully configured to release the MPEG output interface.
+	/// Return ::AVL_DVBSx_EC_I2CFail if there is an I2C communication problem.
+	AVL_DVBSx_ErrorCode AVL_DVBSx_IRx_ReleaseMpegOutput( const struct AVL_DVBSx_Chip * pAVLChip );
+
+	/// Enables MPEG persistent clock mode.  In this mode, once the Availink device is commanded to lock to a channel, it persistently outputs an MPEG clock signal,
+	/// regardless of whether the demod is locked or not.  When the demod is not locked, the MPEG valid and data signals are held low.  When the demod is locked, the received data
+	/// is output.
+	/// 
+	/// @param uiMpegDataClkFreq_10kHz The desired MPEG output byte clock frequency during periods in which the demod is not locked.  Units of 10 kHz.
+	/// @param pAVLChip A pointer to the ::AVL_DVBSx_Chip object for which MPEG persistent clock mode is being enabled.
+	/// 
+	/// @return ::AVL_DVBSx_ErrorCode, 
+	/// Return ::AVL_DVBSx_EC_OK if MPEG persistent clock mode is successfully enabled.
+	/// Return ::AVL_DVBSx_EC_I2CFail if there is an I2C communication problem.
+	AVL_DVBSx_ErrorCode AVL_DVBSx_IRx_EnableMpegPersistentClockMode( AVL_uint16 uiMpegDataClkFreq_10kHz, const struct AVL_DVBSx_Chip *pAVLChip );
+
+	/// Disables MPEG persistent clock mode.  If MPEG persistent clock mode is disabled, then the Availink device outputs an MPEG clock signal only when it is locked to a channel.
+	/// 
+	/// @param pAVLChip A pointer to the ::AVL_DVBSx_Chip object for which MPEG persistent clock mode is being disabled.
+	/// 
+	/// @return ::AVL_DVBSx_ErrorCode, 
+	/// Return ::AVL_DVBSx_EC_OK if MPEG persistent clock mode is successfully disabled.
+	/// Return ::AVL_DVBSx_EC_I2CFail if there is an I2C communication problem.
+	AVL_DVBSx_ErrorCode AVL_DVBSx_IRx_DisableMpegPersistentClockMode( const struct AVL_DVBSx_Chip *pAVLChip );
+
+	/// Enable MPEG manual clock mode.  In this mode, the Availink device always outputs an MPEG clock signal.
+	/// 
+	/// @param uiMpegDataClkFreq_10kHz The desired MPEG continuous output byte clock frequency.
+	/// @param enumMpegMode The mode in which the MPEG output interface is being operated (parallel or serial).
+	/// @param pAVLChip A pointer to the ::AVL_DVBSx_Chip object for which MPEG persistent clock mode is being disabled.
+	/// 
+	/// @return ::AVL_DVBSx_ErrorCode, 
+	/// Return ::AVL_DVBSx_EC_OK if MPEG persistent clock mode is successfully disabled.
+	/// Return ::AVL_DVBSx_EC_I2CFail if there is an I2C communication problem.
+    AVL_DVBSx_ErrorCode AVL_DVBSx_IRx_EnableMpegManualClockFrequency(AVL_uint16 uiMpegDataClkFreq_10kHz, enum AVL_DVBSx_MpegMode enumMpegMode, const struct AVL_DVBSx_Chip * pAVLChip);
+
+	/// Disables MPEG manual clock mode.  If MPEG manual clock is disabled, MPEG output clock in automatic mode. Then the Availink device outputs an MPEG clock signal only when it is locked to a channel.
+	/// 
+	/// @param pAVLChip A pointer to the ::AVL_DVBSx_Chip object for which MPEG persistent clock mode is being disabled.
+	/// 
+	/// @return ::AVL_DVBSx_ErrorCode, 
+	/// Return ::AVL_DVBSx_EC_OK if MPEG persistent clock mode is successfully disabled.
+	/// Return ::AVL_DVBSx_EC_I2CFail if there is an I2C communication problem.
+    AVL_DVBSx_ErrorCode AVL_DVBSx_IRx_DisableMpegManualClockFrequency(const struct AVL_DVBSx_Chip * pAVLChip);
+
+	/// Enables or disables the internal MPEG interface pull-down resistors.  
+	/// 
+	/// @param pAVLChip A pointer to the ::AVL_DVBSx_Chip object for which the internal MPEG interface resistors are being configured.
+	/// @param enumPulldownState Indicates whether the internal pull-down resistors should be enabled or disabled.
+	/// 
+	/// @return ::AVL_DVBSx_ErrorCode, 
+	/// Return ::AVL_DVBSx_EC_OK if the internal MPEG pull-down resistors have been configured.
+	/// Return ::AVL_DVBSx_EC_I2CFail if there is an I2C communication problem.
+	AVL_DVBSx_ErrorCode AVL_DVBSx_IRx_SetMpegPulldown( const struct AVL_DVBSx_Chip *pAVLChip, enum AVL_DVBSx_MpegPulldown enumPulldownState );
+
+	/// Configures the Availink device to output the RF AGC signal.
+	/// 
+	/// @param pAVLChip A pointer to the ::AVL_DVBSx_Chip object which is to output an RF AGC signal.
+	/// 
+	/// @return ::AVL_DVBSx_ErrorCode, 
+	/// Return ::AVL_DVBSx_EC_OK if the device has been successfully configured to output an RF AGC signal.
+	/// Return ::AVL_DVBSx_EC_I2CFail if there is an I2C communication problem.
+	AVL_DVBSx_ErrorCode AVL_DVBSx_IRx_DriveRFAGC( const struct AVL_DVBSx_Chip * pAVLChip );
+
+	/// Configures the Availink device to release the RF AGC signal output.
+	/// 
+	/// @param pAVLChip A pointer to the ::AVL_DVBSx_Chip object which is to release the RF AGC signal output.
+	/// 
+	/// @return ::AVL_DVBSx_ErrorCode, 
+	/// Return ::AVL_DVBSx_EC_OK if the device has been successfully configured to release the RF AGC signal.
+	/// Return ::AVL_DVBSx_EC_I2CFail if there is an I2C communication problem.
+	AVL_DVBSx_ErrorCode AVL_DVBSx_IRx_ReleaseRFAGC( const struct AVL_DVBSx_Chip * pAVLChip );
+
+	/// Reads the IQ imbalance of the received signal.
+	/// 
+	/// @param pAVLChip A pointer to the ::AVL_DVBSx_Chip object for which the IQ imbalance of the received signal is being read.
+	/// @param piAmplitude A pointer to a variable in which to store the amplitude imbalance in units of dB.  The value is scaled by 100.  For example, a value of 300 means an amplitude imbalance of 3 dB.
+	/// @param piPhase A pointer to a variable in which to store the phase imbalance in units of degrees.  The value is scaled by 100.  For example, a value of 200 means a phase imbalance of 2 degrees.
+	/// 
+	/// @return ::AVL_DVBSx_ErrorCode, 
+	/// Return ::AVL_DVBSx_EC_OK if the IQ imbalance has been retrieved from the Availink device.
+	/// Return ::AVL_DVBSx_EC_I2CFail if there is an I2C communication problem.
+	AVL_DVBSx_ErrorCode AVL_DVBSx_IRx_GetIQ_Imbalance( const struct AVL_DVBSx_Chip * pAVLChip, AVL_pint16 piAmplitude, AVL_pint16 piPhase );
+
+	/// Reads the Availink device ID.  Availink can customize the device ID to meet the needs of individual customers.  
+	/// 
+	/// @param pAVLChip A pointer to the ::AVL_DVBSx_Chip object for which the device ID is being read.
+	/// @param puiDeviceID A pointer to a variable in which to store the device ID.
+	/// 
+	/// @return ::AVL_DVBSx_ErrorCode, 
+	/// Return ::AVL_DVBSx_EC_OK if the device ID has been read.
+	/// Return ::AVL_DVBSx_EC_I2CFail if there is an I2C communication problem.
+	AVL_DVBSx_ErrorCode AVL_DVBSx_IRx_GetDeviceID( const struct AVL_DVBSx_Chip * pAVLChip, AVL_puint32 puiDeviceID);
+
+	/// Configures the output bit order of the MPEG data.  The user can set the bit order to either normal or invert.
+	/// The meaning differs depending on whether the MPEG interface is configured to output data in serial mode or
+	/// parallel mode as follows:
+	/// Serial mode (Normal - Output the most significant bit of each byte first, Invert - Output the least significant 
+	/// bit of each byte first.)
+	/// Parallel mode (Normal - The MSB of each byte is output on pin 7 and the LSB on pin 0, Invert - The MSB of each 
+	/// byte is output on pin 0 and the LSB on pin 7.)
+	/// 
+	/// @param pAVLChip A pointer to the ::AVL_DVBSx_Chip object for which the MPEG bit order is being configured.
+	/// @param enumMpegMode The mode in which the MPEG output interface is being operated (parallel or serial).
+	/// @param enumMpegBitOrder The desired MPEG output bit order.
+	/// 
+	/// @return ::AVL_DVBSx_ErrorCode, 
+	/// Return ::AVL_DVBSx_EC_OK if the MPEG output bit order has been configured.
+	/// Return ::AVL_DVBSx_EC_I2CFail if there is an I2C communication problem.
+	AVL_DVBSx_ErrorCode AVL_DVBSx_IRx_SetMpegBitOrder( const struct AVL_DVBSx_Chip * pAVLChip, enum AVL_DVBSx_MpegMode enumMpegMode, enum AVL_DVBSx_MpegBitOrder enumMpegBitOrder );
+
+	/// Selects the pin on which MPEG data is output in serial mode.  The serial data can be output on pin MPEG_DATA_7
+	/// or pin MPEG_DATA_0.
+	/// 
+	/// @param pAVLChip A pointer to the ::AVL_DVBSx_Chip object for which the output data pin is being selected.
+	/// @param enumSerialPin The pin on which to output the MPEG data in serial mode.
+	/// 
+	/// @return ::AVL_DVBSx_ErrorCode, 
+	/// Return ::AVL_DVBSx_EC_OK if the MPEG output pin has been configured for serial mode.
+	/// Return ::AVL_DVBSx_EC_I2CFail if there is an I2C communication problem.
+	AVL_DVBSx_ErrorCode AVL_DVBSx_IRx_SetMpegSerialPin( const struct AVL_DVBSx_Chip * pAVLChip, enum AVL_DVBSx_MpegSerialPin enumSerialPin );
+
+	/// Configures the polarity of the MPEG valid signal when the MPEG interface is configured for TSP mode.
+	/// If the MPEG Interface is configured for TS mode, calling this function has no effect.
+	/// 
+	/// @param pAVLChip A pointer to the ::AVL_DVBSx_Chip object for which the polarity of the MPEG valid signal is being configured.
+	/// @param enumValidPolarity The polarity of the MPEG valid signal in TSP mode (Normal - The valid signal is held low during the 
+	/// parity bytes, Invert - The valid signal is held high during the parity bytes).
+	/// 
+	/// @return ::AVL_DVBSx_ErrorCode, 
+	/// Return ::AVL_DVBSx_EC_OK if the polarity of the MPEG valid signal has been configured.
+	/// Return ::AVL_DVBSx_EC_I2CFail if there is an I2C communication problem.
+	AVL_DVBSx_ErrorCode AVL_DVBSx_IRx_SetMpegValidPolarity( const struct AVL_DVBSx_Chip * pAVLChip, enum AVL_DVBSx_MpegValidPolarity enumValidPolarity );
+
+	/// Configures the polarity of the MPEG error signal.  This function allows the user to configure the Availink device with the
+	/// the error signal polarity that should be used when the demod is not locked to the channel as well as the error signal polarity
+	/// that should be used when the demod is locked to the channel.
+	/// 
+	/// @param pAVLChip A pointer to the ::AVL_DVBSx_Chip object for which the polarity of the MPEG error signal is being configured.
+	/// @param enumErrorLockPolarity The MPEG error signal polarity to be used during periods in which the Availink device is locked to a 
+	/// signal (Normal - The MPEG error signal is high when there is an MPEG error, Invert - The MPEG signal is low when there is an MPEG error).
+	/// @param enumErrorUnlockPolarity The MPEG error signal polarity to be used during periods in which the Availink device is not locked to a 
+	/// signal (Normal - MPEG error signal is low when the demod is not locked, Invert - MPEG error signal is high when the demod is not locked.)
+	/// 
+	/// @return ::AVL_DVBSx_ErrorCode, 
+	/// Return ::AVL_DVBSx_EC_OK if the polarity of the MPEG error signal has been configured.
+	/// Return ::AVL_DVBSx_EC_I2CFail if there is an I2C communication problem.
+	AVL_DVBSx_ErrorCode AVL_DVBSx_IRx_SetMpegErrorPolarity(const struct AVL_DVBSx_Chip * pAVLChip, enum AVL_DVBSx_MpegErrorPolarity enumErrorLockPolarity, enum AVL_DVBSx_MpegErrorPolarity enumErrorUnlockPolarity);
+
+	/// Reads the IQ swap status of the received signal.  This function is useful if the user enabled automatic IQ swap
+	/// when locking to the channel.  After channel lock has been achieved, the user may call the GetIQ_Swap function
+	/// to determine whether the I and Q signals had to be swapped for the received signal.
+	/// 
+	/// @param pAVLChip A pointer to the ::AVL_DVBSx_Chip object for which the IQ swap status status is being retrieved.
+	/// @param puiIQ_Swap Pointer to a variable in which to store the IQ swap status (0 - Not swapped, 1 - Swapped).
+	/// 
+	/// @return ::AVL_DVBSx_ErrorCode, 
+	/// Return ::AVL_DVBSx_EC_OK if the IQ swap status has been retrieved.
+	/// Return ::AVL_DVBSx_EC_I2CFail if there is an I2C communication problem.
+	AVL_DVBSx_ErrorCode AVL_DVBSx_IRx_GetIQ_Swap( const struct AVL_DVBSx_Chip * pAVLChip, AVL_puint16 uiIQ_Swap );
+
+	/// Reads the current word error rate of Reed-Solomon decoder.
+	/// 
+	/// @param puiRSErr Pointer to a variable in which to store the word error rate value.The value is scaled by 1e+9. For example, if the reported value is 123456, the word error rate value is 0.000123456.
+	/// @param pAVLChip A pointer to the ::AVL_DVBSx_Chip object for which the word error rate is being retrieved.
+	/// 
+	/// @return ::AVL_DVBSx_ErrorCode, 
+	/// Return ::AVL_DVBSx_EC_OK if the word error rate has been retrieved.
+	/// Return ::AVL_DVBSx_EC_I2CFail if there is an I2C communication problem.
+	AVL_DVBSx_ErrorCode AVL_DVBSx_IRx_GetRSError( AVL_puint32  puiRSErr, const struct AVL_DVBSx_Chip * pAVLChip );
+
+	/// Reads back the value of total error packets at current time.
+	/// 
+	/// @param puiErrPacket Pointer to a variable in which to store the error packets value. 
+	/// @param pAVLChip A pointer to the ::AVL_DVBSx_Chip object for which the error packets is being retrieved.
+	/// 
+	/// @return ::AVL_DVBSx_ErrorCode, 
+	/// Return ::AVL_DVBSx_EC_OK if the error packets value has been retrieved.
+	/// Return ::AVL_DVBSx_EC_I2CFail if there is an I2C communication problem.
+	AVL_DVBSx_ErrorCode AVL_DVBSx_IRx_GetErrPacket( AVL_puint32 puiErrPacket, const struct AVL_DVBSx_Chip * pAVLChip );
+
+    #ifdef AVL_CPLUSPLUS
+}
+	#endif
+
+#endif
diff -Naur a/drivers/amlogic/dvb_tv/avl6211/include/ITuner.h b/drivers/amlogic/dvb_tv/avl6211/include/ITuner.h
--- a/drivers/amlogic/dvb_tv/avl6211/include/ITuner.h	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/amlogic/dvb_tv/avl6211/include/ITuner.h	2014-12-11 16:13:50.061617837 +0100
@@ -0,0 +1,64 @@
+/*
+ *           Copyright 2012 Availink, Inc.
+ *
+ *  This software contains Availink proprietary information and
+ *  its use and disclosure are restricted solely to the terms in
+ *  the corresponding written license agreement. It shall not be 
+ *  disclosed to anyone other than valid licensees without
+ *  written permission of Availink, Inc.
+ *
+ */
+
+
+///$Date: 2012-2-9 17:36 $
+///
+///
+/// @file 
+/// @brief The ITuner interface
+/// @details The ITuner interface supports dynamic tuner switch during run time. It is the user's responsibility to to ensure that the function pointers in the tuner data structure are not NULL.
+/// 
+#ifndef ITuner_h_h
+	#define ITuner_h_h
+
+	#include "avl_dvbsx.h"
+	#include "avl_dvbsx_globals.h"
+
+	#ifdef AVL_CPLUSPLUS
+extern "C" {
+	#endif
+
+	/// @cond
+
+	/// @endcond
+
+	/// The Tuner data structure
+	/// 
+	struct AVL_Tuner
+	{
+		AVL_uint16 m_uiSlaveAddress;			///< The Tuner slave address. It is the write address of the tuner device. In particular it is an 8-bit address, with the LSB set to zero. The Availink device does not support 10-bit I2C addresses. 
+		AVL_uint16 m_uiI2CBusClock_kHz;		///< The clock speed of the I2C bus that is dedicated to tuner control.  The units are kHz.
+		AVL_uint16 m_uiFrequency_100kHz;	///< The tuned frequency in units of 100kHz.
+		AVL_uint16 m_uiLPF_100kHz;				///< The lowpass filter bandwidth of the tuner.
+		AVL_uint32 m_uiSymbolRate_Hz;			///< The symbol rate of the incoming channel.
+		void * m_pParameters;							///< A pointer to the tuner's customized parameters baseband gain, etc.
+		struct AVL_DVBSx_Chip * m_pAVLChip;	///< A pointer to the Availink device connected to the Tuner.
+		AVL_DVBSx_ErrorCode (* m_pInitializeFunc)(struct AVL_Tuner *);	 	///< A pointer to the tuner initialization function.
+		AVL_DVBSx_ErrorCode (* m_pGetLockStatusFunc)(struct AVL_Tuner *); ///< A pointer to the tuner GetLockStatus function.
+		AVL_DVBSx_ErrorCode (* m_pDumpDataFunc)(AVL_puchar ucpData, AVL_puchar ucpSize, struct AVL_Tuner *); 	///< A pointer to the DumpData function. This function is optional; it is used to dump debug information.
+		AVL_DVBSx_ErrorCode (* m_pLockFunc)(struct AVL_Tuner *);					///< A pointer to the tuner Lock function.
+	};
+
+	/// This function calculates the tuner lowpass filter bandwidth based on the symbol rate of the received signal.
+	/// 	
+	/// @param uiSymbolRate_10kHz  The symbol rate of the received signal in units of 10kHz.
+	/// @param pTuner  A pointer to the tuner object for which the lowpass filter bandwidth is being computed. The function updates the member m_uiLPF_100kHz of this object.
+	/// 
+	/// @return ::AVL_DVBSx_ErrorCode, 
+	/// Return ::AVL_DVBSx_EC_OK if the tuner lowpass filter bandwidth member of the tuner object has been updated.
+	/// This function is provided as an example of how to set the lowpass filter bandwidth in a manner that is proportional to the symbol rate.  The user may use their own calculation instead.
+	AVL_DVBSx_ErrorCode AVL_DVBSx_ITuner_CalculateLPF(AVL_uint16 uiSymbolRate_10kHz,struct AVL_Tuner * pTuner);
+
+	#ifdef AVL_CPLUSPLUS
+}
+	#endif
+#endif
diff -Naur a/drivers/amlogic/dvb_tv/avl6211/include/LockSignal_Api.h b/drivers/amlogic/dvb_tv/avl6211/include/LockSignal_Api.h
--- a/drivers/amlogic/dvb_tv/avl6211/include/LockSignal_Api.h	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/amlogic/dvb_tv/avl6211/include/LockSignal_Api.h	2014-12-11 16:13:50.141617225 +0100
@@ -0,0 +1,61 @@
+/*
+ *           Copyright 2012 Availink, Inc.
+ *
+ *  This software contains Availink proprietary information and
+ *  its use and disclosure are restricted solely to the terms in
+ *  the corresponding written license agreement. It shall not be 
+ *  disclosed to anyone other than valid licensees without
+ *  written permission of Availink, Inc.
+ *
+ */
+
+
+///$Date: 2012-2-9 17:36 $
+///
+
+
+
+#ifndef LockSignal_source_h_h
+    #define LockSignal_source_h_h
+
+    #include "avl_dvbsx.h"
+   
+
+	#ifdef AVL_CPLUSPLUS
+extern "C" {
+	#endif
+/*#include"ITuner.h"
+#include "IRx.h"
+#include "DiSEqC_source.h"	
+#include "IBlindScan.h"
+#include "IBlindscanAPI.h"	
+#include "II2C.h"
+#include "IBase.h"*/
+
+
+
+    struct Signal_Level
+    {
+	    AVL_uint16 SignalLevel;
+        AVL_int16 SignalDBM;
+    };
+
+    void AVL_DVBSx_Error_Dispose(AVL_DVBSx_ErrorCode r);
+    AVL_DVBSx_ErrorCode AVL6211_Initialize(struct AVL_DVBSx_Chip * pAVLChip,struct AVL_Tuner * pTuner,int iDeviceIndex);
+    AVL_DVBSx_ErrorCode AVL6211_LockSignal_Init(int iDeviceId);
+   AVL_DVBSx_ErrorCode CPU_Halt(struct AVL_DVBSx_Chip * pAVLChip);
+   void AVL_Set_LPF(int iDeviceId,struct AVL_Tuner * pTuner, AVL_uint32 m_uiSymbolRate_Hz);
+	int AVL_Get_Quality_Percent(struct AVL_DVBSx_Chip * pAVLChip);	
+	AVL_int16 AVL_Get_Level_Percent(struct AVL_DVBSx_Chip * pAVLChip);
+   
+	AVL_uint32 AVL6211_GETBer(int iDeviceId);
+	AVL_uint32 AVL6211_GETPer(int iDeviceId);
+	AVL_uint32 AVL6211_GETSnr(int iDeviceId);
+	AVL_uint32 AVL6211_GETSignalLevel(int iDeviceId);
+	AVL_uint32 AVL6211_GETLockStatus(int iDeviceId);
+
+	
+	#ifdef AVL_CPLUSPLUS
+}
+	#endif
+#endif
diff -Naur a/drivers/amlogic/dvb_tv/avl6211/include/SharpBS2S7HZ6306.h b/drivers/amlogic/dvb_tv/avl6211/include/SharpBS2S7HZ6306.h
--- a/drivers/amlogic/dvb_tv/avl6211/include/SharpBS2S7HZ6306.h	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/amlogic/dvb_tv/avl6211/include/SharpBS2S7HZ6306.h	2014-12-11 16:13:50.161617073 +0100
@@ -0,0 +1,59 @@
+/*
+ *           Copyright 2012 Availink, Inc.
+ *
+ *  This software contains Availink proprietary information and
+ *  its use and disclosure are restricted solely to the terms in
+ *  the corresponding written license agreement. It shall not be 
+ *  disclosed to anyone other than valid licensees without
+ *  written permission of Availink, Inc.
+ *
+ */
+
+
+///$Date: 2012-2-9 17:36 $
+///
+///
+/// @file 
+/// @brief Declare customized data structure for Sharp BS2S7HZ6306 tuner
+/// 
+#ifndef SharpBS2S7HZ6306_h_h
+	#define SharpBS2S7HZ6306_h_h
+
+	#include "avl_dvbsx.h"
+
+	#ifdef AVL_CPLUSPLUS
+extern "C" {
+	#endif
+
+	enum SharpBS2S7HZ6306_BBGain
+	{
+		Bbg_0_Sharp,
+		Bbg_1_Sharp,
+		Bbg_2_Sharp,
+		Bbg_4_Sharp   
+	};
+
+	enum SharpBS2S7HZ6306_PumpCurrent
+	{
+		PC_78_150_Sharp = 0,	///< = 0 min +/- 78 uA; typical +/- 120 uA; Max +/- 150 uA
+		PC_169_325_Sharp = 1,	///< = 1 min +/- 169 uA; typical +/- 260 uA; Max +/- 325 uA
+		PC_360_694_Sharp = 2,	///< = 2 min +/- 360 uA; typical +/- 555 uA; Max +/- 694 uA
+		PC_780_1500_Sharp = 3	///< = 3 min +/- 780 uA; typical +/- 1200 uA; Max +/- 1500 uA
+	};
+
+	struct SharpBS2S7HZ6306_TunerPara
+	{
+		enum SharpBS2S7HZ6306_PumpCurrent     m_ChargPump;
+		enum SharpBS2S7HZ6306_BBGain          m_BBGain;
+	};
+
+	struct SharpBS2S7HZ6306_Registers
+	{
+		AVL_uchar m_ucLPF;
+		AVL_uchar m_ucRegData[4];
+	};
+
+	#ifdef AVL_CPLUSPLUS
+}
+	#endif
+#endif
diff -Naur a/drivers/amlogic/dvb_tv/avl6211/include/ucPatchData.h b/drivers/amlogic/dvb_tv/avl6211/include/ucPatchData.h
--- a/drivers/amlogic/dvb_tv/avl6211/include/ucPatchData.h	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/amlogic/dvb_tv/avl6211/include/ucPatchData.h	2014-12-11 16:13:50.141617225 +0100
@@ -0,0 +1,304 @@
+const unsigned char ucPatchData [] = 
+{
+	0x00, 0x00, 0x12, 0xA8, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0x1C, 0xD8, 0x00, 0x00, 0x08, 0xD8, 
+	0x5A, 0x6C, 0x78, 0x87, 0x90, 0x96, 0xA0, 0xA2, 0x3F, 0xFF, 0x5C, 0x29, 0x40, 0x3F, 0x3B, 0x64, 
+	0x3F, 0xF9, 0x37, 0x4C, 0x40, 0x3A, 0xE1, 0x48, 0x41, 0x43, 0x00, 0xD2, 0x41, 0x1F, 0xB3, 0x3E, 
+	0x41, 0x59, 0xF3, 0x4D, 0x41, 0x57, 0xE4, 0x26, 0x41, 0x50, 0x5E, 0x9E, 0x41, 0x52, 0xD3, 0xC3, 
+	0x41, 0x84, 0xB5, 0x74, 0x41, 0x85, 0x82, 0x41, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 
+	0x38, 0x39, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 
+	0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x22, 0x30, 0x4E, 0x71, 0x4E, 0xD0, 0x4E, 0x56, 0x00, 0x00, 
+	0x4A, 0x79, 0x00, 0x00, 0x05, 0xF8, 0x67, 0x3E, 0x41, 0xF9, 0x00, 0x00, 0x08, 0x16, 0x30, 0xBC, 
+	0x00, 0xFF, 0x70, 0x00, 0x30, 0x2E, 0x00, 0x0A, 0x0C, 0x80, 0x00, 0x00, 0x00, 0xC8, 0x67, 0x12, 
+	0x0C, 0x80, 0x00, 0x00, 0x00, 0xC9, 0x67, 0x0C, 0x0C, 0x80, 0x00, 0x00, 0x00, 0xCA, 0x67, 0x12, 
+	0x60, 0x14, 0x60, 0x12, 0x70, 0x0A, 0x2F, 0x00, 0x4E, 0xB9, 0x00, 0x10, 0x0C, 0x46, 0x58, 0x8F, 
+	0x60, 0x04, 0x70, 0x01, 0x30, 0x80, 0x42, 0x01, 0x70, 0x00, 0x10, 0x01, 0x4E, 0x5E, 0x4E, 0x75, 
+	0x00, 0x00, 0x11, 0x9C, 0x00, 0x00, 0x26, 0x54, 0x4E, 0x56, 0x00, 0x00, 0x48, 0xE7, 0x20, 0x30, 
+	0x45, 0xF9, 0x00, 0x00, 0x04, 0x3C, 0x70, 0x00, 0x30, 0x2A, 0x01, 0xC6, 0x41, 0xF9, 0x00, 0x00, 
+	0x08, 0xD8, 0x43, 0xF0, 0x08, 0x00, 0x23, 0xC9, 0x00, 0x00, 0x37, 0x60, 0x72, 0x00, 0x32, 0x2E, 
+	0x00, 0x0A, 0x0C, 0x81, 0x00, 0x00, 0x01, 0xF8, 0x64, 0x00, 0x00, 0xB8, 0x70, 0x10, 0xB0, 0x81, 
+	0x67, 0x00, 0x01, 0x72, 0x70, 0x66, 0xB0, 0x81, 0x67, 0x00, 0x02, 0x7C, 0x70, 0x67, 0xB0, 0x81, 
+	0x67, 0x00, 0x02, 0xE0, 0x70, 0x6D, 0xB0, 0x81, 0x67, 0x00, 0x07, 0x12, 0x70, 0x74, 0xB0, 0x81, 
+	0x67, 0x00, 0x01, 0xE8, 0x70, 0x75, 0xB0, 0x81, 0x67, 0x00, 0x07, 0x48, 0x0C, 0x81, 0x00, 0x00, 
+	0x00, 0xCE, 0x67, 0x00, 0x0B, 0xAE, 0x0C, 0x81, 0x00, 0x00, 0x00, 0xCF, 0x67, 0x00, 0x0B, 0xC2, 
+	0x0C, 0x81, 0x00, 0x00, 0x00, 0xDC, 0x67, 0x00, 0x0B, 0x32, 0x0C, 0x81, 0x00, 0x00, 0x00, 0xDD, 
+	0x67, 0x00, 0x0A, 0x78, 0x0C, 0x81, 0x00, 0x00, 0x00, 0xDE, 0x67, 0x00, 0x01, 0xC6, 0x0C, 0x81, 
+	0x00, 0x00, 0x00, 0xDF, 0x67, 0x00, 0x0B, 0x9A, 0x0C, 0x81, 0x00, 0x00, 0x01, 0x35, 0x67, 0x00, 
+	0x05, 0xBE, 0x0C, 0x81, 0x00, 0x00, 0x01, 0x44, 0x67, 0x00, 0x0B, 0xB0, 0x0C, 0x81, 0x00, 0x00, 
+	0x01, 0x47, 0x67, 0x00, 0x05, 0x8A, 0x0C, 0x81, 0x00, 0x00, 0x01, 0x93, 0x67, 0x00, 0x08, 0x34, 
+	0x0C, 0x81, 0x00, 0x00, 0x01, 0x98, 0x67, 0x00, 0x01, 0x42, 0x0C, 0x81, 0x00, 0x00, 0x01, 0xA2, 
+	0x67, 0x00, 0x04, 0xB8, 0x0C, 0x81, 0x00, 0x00, 0x01, 0xF5, 0x67, 0x00, 0x00, 0xCC, 0x60, 0x00, 
+	0x0F, 0xB6, 0x0C, 0x81, 0x00, 0x00, 0x01, 0xF8, 0x67, 0x00, 0x06, 0xE0, 0x0C, 0x81, 0x00, 0x00, 
+	0x02, 0x02, 0x67, 0x00, 0x0E, 0xDE, 0x0C, 0x81, 0x00, 0x00, 0x02, 0x04, 0x67, 0x00, 0x07, 0xF4, 
+	0x0C, 0x81, 0x00, 0x00, 0x02, 0x0D, 0x67, 0x00, 0x0A, 0x3A, 0x0C, 0x81, 0x00, 0x00, 0x02, 0x10, 
+	0x67, 0x00, 0x03, 0x80, 0x0C, 0x81, 0x00, 0x00, 0x02, 0x22, 0x67, 0x00, 0x0E, 0xE6, 0x0C, 0x81, 
+	0x00, 0x00, 0x02, 0x26, 0x67, 0x00, 0x0B, 0xCE, 0x0C, 0x81, 0x00, 0x00, 0x02, 0x2B, 0x67, 0x00, 
+	0x07, 0xC2, 0x0C, 0x81, 0x00, 0x00, 0x02, 0x2C, 0x67, 0x00, 0x08, 0xB8, 0x0C, 0x81, 0x00, 0x00, 
+	0x02, 0x31, 0x67, 0x00, 0x0F, 0x2A, 0x0C, 0x81, 0x00, 0x00, 0x02, 0x67, 0x67, 0x00, 0x02, 0x4A, 
+	0x0C, 0x81, 0x00, 0x00, 0x02, 0x6A, 0x67, 0x00, 0x05, 0x36, 0x0C, 0x81, 0x00, 0x00, 0x02, 0x78, 
+	0x67, 0x00, 0x0B, 0xD8, 0x0C, 0x81, 0x00, 0x00, 0x02, 0x79, 0x67, 0x00, 0x01, 0xE0, 0x0C, 0x81, 
+	0x00, 0x00, 0x02, 0x82, 0x67, 0x00, 0x0C, 0xE0, 0x0C, 0x81, 0x00, 0x00, 0x02, 0xC2, 0x67, 0x00, 
+	0x0E, 0x9C, 0x0C, 0x81, 0x00, 0x00, 0x03, 0x2E, 0x67, 0x00, 0x05, 0x38, 0x0C, 0x81, 0x00, 0x00, 
+	0x03, 0x2F, 0x67, 0x00, 0x05, 0x8A, 0x0C, 0x81, 0x00, 0x00, 0x03, 0x36, 0x67, 0x00, 0x04, 0xB4, 
+	0x60, 0x00, 0x0E, 0xF4, 0x60, 0x00, 0x01, 0x22, 0x25, 0x7A, 0x0E, 0xFC, 0x02, 0x50, 0x35, 0x7C, 
+	0x01, 0x90, 0x01, 0x26, 0x42, 0x78, 0x26, 0x52, 0x42, 0x78, 0x26, 0x50, 0x42, 0x78, 0x26, 0x4E, 
+	0x25, 0x7C, 0x01, 0x00, 0x00, 0x1D, 0x00, 0x7C, 0x70, 0x09, 0x31, 0xC0, 0x26, 0x4C, 0x31, 0xFC, 
+	0x50, 0x00, 0x26, 0x4A, 0x31, 0xFC, 0x00, 0x9C, 0x26, 0x48, 0x21, 0xFC, 0x00, 0x00, 0x00, 0xC8, 
+	0x26, 0x44, 0x31, 0xFC, 0x01, 0x90, 0x26, 0x42, 0x21, 0xFC, 0x00, 0x4C, 0x4B, 0x40, 0x26, 0x3E, 
+	0x70, 0x01, 0x11, 0xC0, 0x26, 0x3D, 0x31, 0xC0, 0x26, 0x32, 0x42, 0x78, 0x26, 0x30, 0x42, 0x78, 
+	0x26, 0x2E, 0x42, 0xB8, 0x26, 0x2A, 0x60, 0x00, 0x0E, 0x8E, 0x42, 0xA7, 0x42, 0xA7, 0x30, 0x2A, 
+	0x00, 0xA8, 0x48, 0xC0, 0x4E, 0xB9, 0x00, 0x10, 0x03, 0x1E, 0x2F, 0x00, 0x2F, 0x3A, 0x0E, 0x8C, 
+	0x4E, 0xB9, 0x00, 0x10, 0x81, 0x78, 0x70, 0x10, 0xDF, 0xC0, 0x48, 0x78, 0x75, 0x30, 0x4E, 0xB9, 
+	0x00, 0x10, 0x63, 0xA2, 0x58, 0x8F, 0x60, 0x00, 0x0E, 0x5E, 0x35, 0x7C, 0x4E, 0x20, 0x01, 0x9E, 
+	0x25, 0x7C, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x50, 0x70, 0x04, 0x35, 0x40, 0x01, 0x4A, 0x60, 0x00, 
+	0x05, 0x72, 0x4A, 0xB9, 0x00, 0x00, 0x37, 0x64, 0x66, 0x00, 0x0E, 0x3C, 0x41, 0xF9, 0x00, 0x00, 
+	0x06, 0x90, 0x70, 0x05, 0xB0, 0xA8, 0x00, 0x04, 0x66, 0x00, 0x0E, 0x2C, 0x70, 0x06, 0xB0, 0x90, 
+	0x66, 0x00, 0x0E, 0x24, 0x2F, 0x3A, 0x0E, 0x38, 0x20, 0x39, 0x00, 0x40, 0x00, 0x48, 0xE9, 0x80, 
+	0xE8, 0x80, 0x4E, 0xB9, 0x00, 0x10, 0x03, 0x1E, 0x2F, 0x00, 0x4E, 0xB9, 0x00, 0x10, 0xD7, 0xE4, 
+	0x50, 0x8F, 0x2F, 0x00, 0x2F, 0x3A, 0x0E, 0x1C, 0x4E, 0xB9, 0x00, 0x10, 0xDC, 0x40, 0x50, 0x8F, 
+	0x2F, 0x00, 0x2F, 0x39, 0x00, 0x00, 0x37, 0x68, 0x4E, 0xB9, 0x00, 0x10, 0xDA, 0x74, 0x25, 0x40, 
+	0x02, 0x24, 0x60, 0x00, 0x04, 0x08, 0x70, 0x7F, 0x35, 0x40, 0x01, 0x6E, 0x70, 0x10, 0x35, 0x40, 
+	0x00, 0xAE, 0x70, 0x05, 0x35, 0x40, 0x00, 0xAC, 0x23, 0xFC, 0x00, 0x00, 0x26, 0x7F, 0x00, 0x6C, 
+	0x80, 0x00, 0x42, 0xB9, 0x00, 0x6C, 0x80, 0x04, 0x70, 0x01, 0x23, 0xC0, 0x00, 0x6C, 0x80, 0x04, 
+	0x42, 0xB9, 0x00, 0x6C, 0x80, 0x04, 0x23, 0xFC, 0x00, 0x00, 0x26, 0x70, 0x00, 0x6C, 0x80, 0x00, 
+	0x42, 0xB9, 0x00, 0x6C, 0x80, 0x04, 0x23, 0xC0, 0x00, 0x6C, 0x80, 0x04, 0x42, 0xB9, 0x00, 0x6C, 
+	0x80, 0x04, 0x23, 0xFC, 0x00, 0x00, 0x26, 0x7F, 0x00, 0x6C, 0x80, 0x00, 0x42, 0xB9, 0x00, 0x6C, 
+	0x80, 0x04, 0x23, 0xC0, 0x00, 0x6C, 0x80, 0x04, 0x42, 0xB9, 0x00, 0x6C, 0x80, 0x04, 0x60, 0x00, 
+	0x0D, 0x76, 0x23, 0xEA, 0x02, 0x24, 0x00, 0x00, 0x37, 0x68, 0x70, 0x05, 0x35, 0x40, 0x00, 0xAC, 
+	0x30, 0x2A, 0x02, 0x02, 0x72, 0x0F, 0xC0, 0x81, 0x25, 0x40, 0x00, 0x0C, 0x42, 0x6A, 0x01, 0xF4, 
+	0x70, 0xFF, 0x25, 0x40, 0x00, 0x98, 0x72, 0x01, 0x60, 0x00, 0x0D, 0x4E, 0x72, 0x00, 0x32, 0x38, 
+	0x26, 0x52, 0x70, 0x01, 0xC2, 0x80, 0x24, 0x01, 0x22, 0x3C, 0xFF, 0xFF, 0xEF, 0xFF, 0xC2, 0xB9, 
+	0x00, 0x40, 0x08, 0x00, 0x70, 0x0C, 0xE1, 0xA2, 0x20, 0x3C, 0x00, 0x00, 0x10, 0x00, 0xC0, 0x82, 
+	0x82, 0x80, 0x23, 0xC1, 0x00, 0x40, 0x08, 0x00, 0x70, 0x00, 0x30, 0x38, 0x26, 0x52, 0x74, 0x01, 
+	0xE2, 0x88, 0x72, 0xFE, 0xC2, 0xB9, 0x00, 0x6C, 0x00, 0x44, 0xC4, 0x80, 0x82, 0x82, 0x23, 0xC1, 
+	0x00, 0x6C, 0x00, 0x44, 0x60, 0x00, 0x0D, 0x00, 0x4A, 0x6A, 0x02, 0x0C, 0x66, 0x00, 0x00, 0x92, 
+	0x23, 0xF8, 0x26, 0x3E, 0x00, 0x00, 0x37, 0x6C, 0x33, 0xF8, 0x26, 0x42, 0x00, 0x00, 0x37, 0x70, 
+	0x2F, 0x3A, 0x0D, 0x04, 0x2F, 0x39, 0x00, 0x00, 0x37, 0x6C, 0x4E, 0xB9, 0x00, 0x10, 0xCF, 0x40, 
+	0x58, 0x8F, 0x2F, 0x00, 0x4E, 0xB9, 0x00, 0x10, 0xD7, 0xE4, 0x50, 0x8F, 0x2F, 0x00, 0x2F, 0x2A, 
+	0x02, 0x24, 0x4E, 0xB9, 0x00, 0x10, 0xDE, 0x44, 0x50, 0x8F, 0x6E, 0x4A, 0x35, 0x79, 0x00, 0x00, 
+	0x37, 0x70, 0x01, 0x60, 0x2F, 0x3A, 0x0C, 0xD4, 0x74, 0x00, 0x34, 0x39, 0x00, 0x00, 0x37, 0x70, 
+	0x2F, 0x02, 0x4E, 0xB9, 0x00, 0x10, 0xCF, 0x40, 0x58, 0x8F, 0x2F, 0x00, 0x4E, 0xB9, 0x00, 0x10, 
+	0xD7, 0xE4, 0x25, 0x40, 0x02, 0x28, 0x20, 0x2A, 0x00, 0x34, 0x72, 0x00, 0x32, 0x2A, 0x02, 0x20, 
+	0xB3, 0x80, 0x53, 0x80, 0x50, 0x8F, 0x66, 0x18, 0x20, 0x2A, 0x02, 0x28, 0x08, 0x40, 0x00, 0x1F, 
+	0x25, 0x40, 0x02, 0x28, 0x60, 0x0A, 0x42, 0x6A, 0x01, 0x60, 0x25, 0x7A, 0x0C, 0x92, 0x02, 0x28, 
+	0x23, 0xF9, 0x00, 0x40, 0x08, 0x00, 0x00, 0x00, 0x37, 0x74, 0x30, 0x2A, 0x02, 0x10, 0x02, 0x40, 
+	0x80, 0x00, 0x0C, 0x40, 0x80, 0x00, 0x66, 0x2E, 0x20, 0x39, 0x00, 0x00, 0x37, 0x74, 0x72, 0x0B, 
+	0xE2, 0xA0, 0x08, 0x00, 0x00, 0x00, 0x66, 0x1E, 0x70, 0x00, 0x30, 0x2A, 0x02, 0x10, 0x02, 0x80, 
+	0x00, 0x00, 0x7F, 0xFF, 0xE9, 0x80, 0x23, 0xC0, 0x00, 0x40, 0x08, 0x18, 0x30, 0x6A, 0x01, 0x66, 
+	0x23, 0xC8, 0x00, 0x40, 0x08, 0x1C, 0x72, 0x00, 0x32, 0x38, 0x26, 0x52, 0x70, 0x01, 0xE6, 0x89, 
+	0xC0, 0x81, 0x25, 0x40, 0x00, 0x1C, 0x25, 0x79, 0x00, 0x00, 0x37, 0x68, 0x02, 0x24, 0x60, 0x00, 
+	0x0C, 0x06, 0x23, 0xF9, 0x00, 0x40, 0x00, 0x58, 0x00, 0x00, 0x37, 0x78, 0x20, 0x39, 0x00, 0x00, 
+	0x37, 0x78, 0x74, 0x10, 0xE5, 0xA0, 0x74, 0x18, 0xE4, 0xA0, 0x23, 0xC0, 0x00, 0x00, 0x37, 0x7C, 
+	0x20, 0x39, 0x00, 0x00, 0x37, 0x78, 0xE5, 0xA0, 0xE4, 0xA0, 0x23, 0xC0, 0x00, 0x00, 0x37, 0x80, 
+	0x2F, 0x3A, 0x0B, 0xF0, 0x2F, 0x3A, 0x0B, 0xFC, 0x20, 0x39, 0x00, 0x00, 0x37, 0x7C, 0x4E, 0xB9, 
+	0x00, 0x10, 0x03, 0x1E, 0x2F, 0x00, 0x4E, 0xB9, 0x00, 0x10, 0xD7, 0xE4, 0x50, 0x8F, 0x2F, 0x00, 
+	0x4E, 0xB9, 0x00, 0x10, 0xDC, 0x48, 0x23, 0xC0, 0x00, 0x00, 0x37, 0x84, 0x2F, 0x39, 0x00, 0x00, 
+	0x37, 0x84, 0x2F, 0x3A, 0x0B, 0xD2, 0x4E, 0xB9, 0x00, 0x10, 0xDA, 0x74, 0x50, 0x8F, 0x2F, 0x00, 
+	0x20, 0x39, 0x00, 0x00, 0x37, 0x80, 0x4E, 0xB9, 0x00, 0x10, 0x03, 0x1E, 0x2F, 0x00, 0x4E, 0xB9, 
+	0x00, 0x10, 0xD7, 0xE4, 0x23, 0xC0, 0x00, 0x00, 0x37, 0x88, 0x2F, 0x39, 0x00, 0x00, 0x37, 0x84, 
+	0x4E, 0xB9, 0x00, 0x10, 0x87, 0x74, 0x23, 0xC0, 0x00, 0x00, 0x37, 0x8C, 0x58, 0x8F, 0x2F, 0x3A, 
+	0x0B, 0x9A, 0x2F, 0x39, 0x00, 0x00, 0x37, 0x88, 0x4E, 0xB9, 0x00, 0x10, 0xDA, 0x74, 0x23, 0xC0, 
+	0x00, 0x00, 0x37, 0x88, 0x2F, 0x3A, 0x0B, 0x74, 0x2F, 0x39, 0x00, 0x00, 0x37, 0x88, 0x4E, 0xB9, 
+	0x00, 0x10, 0xDA, 0x74, 0x50, 0x8F, 0x2F, 0x00, 0x4E, 0xB9, 0x00, 0x10, 0xD0, 0xE0, 0x58, 0x8F, 
+	0x31, 0xC0, 0x26, 0x50, 0x2F, 0x3A, 0x0B, 0x68, 0x2F, 0x39, 0x00, 0x00, 0x37, 0x8C, 0x4E, 0xB9, 
+	0x00, 0x10, 0xDA, 0x74, 0x50, 0x8F, 0x2F, 0x00, 0x4E, 0xB9, 0x00, 0x10, 0xD0, 0xE0, 0x58, 0x8F, 
+	0x31, 0xC0, 0x26, 0x4E, 0x70, 0x18, 0x60, 0x00, 0x01, 0x00, 0x70, 0x02, 0x23, 0xC0, 0x00, 0x00, 
+	0x37, 0x90, 0x72, 0x00, 0x32, 0x38, 0x26, 0x52, 0x70, 0x01, 0xE4, 0x89, 0xC0, 0x81, 0x25, 0x40, 
+	0x00, 0x1C, 0x0C, 0x38, 0x00, 0x01, 0x26, 0x3D, 0x66, 0x18, 0x2F, 0x3A, 0x0B, 0x26, 0x2F, 0x2A, 
+	0x02, 0x24, 0x4E, 0xB9, 0x00, 0x10, 0xDE, 0x44, 0x50, 0x8F, 0x6E, 0x06, 0x42, 0xB9, 0x00, 0x00, 
+	0x37, 0x90, 0x25, 0x79, 0x00, 0x00, 0x37, 0x90, 0x00, 0x04, 0x2F, 0x2A, 0x00, 0x04, 0x4E, 0xB9, 
+	0x00, 0x10, 0x8B, 0x72, 0x58, 0x8F, 0x23, 0xF9, 0x00, 0x40, 0x08, 0x00, 0x00, 0x00, 0x37, 0x94, 
+	0x20, 0x39, 0x00, 0x00, 0x37, 0x94, 0x72, 0x0B, 0xE2, 0xA0, 0x08, 0x00, 0x00, 0x00, 0x66, 0x04, 
+	0x42, 0x6A, 0x00, 0xBA, 0x08, 0xB9, 0x00, 0x01, 0x00, 0x00, 0x37, 0x96, 0x23, 0xF9, 0x00, 0x00, 
+	0x37, 0x94, 0x00, 0x40, 0x08, 0x00, 0x45, 0xF9, 0x00, 0x00, 0x06, 0x90, 0x70, 0x01, 0x2F, 0x00, 
+	0x42, 0xA7, 0x42, 0xA7, 0x2F, 0x2A, 0x00, 0x08, 0x4E, 0xB9, 0x00, 0x10, 0x65, 0xE6, 0x70, 0x10, 
+	0xDF, 0xC0, 0x4E, 0xB9, 0x00, 0x10, 0x68, 0x98, 0x42, 0xAA, 0x00, 0x18, 0x70, 0x11, 0x24, 0x80, 
+	0x42, 0xAA, 0x00, 0xF0, 0x70, 0x01, 0x35, 0x40, 0x01, 0x64, 0x60, 0x00, 0xFD, 0x0A, 0x72, 0x00, 
+	0x32, 0x38, 0x26, 0x52, 0x70, 0x01, 0xE4, 0x89, 0xC0, 0x81, 0x25, 0x40, 0x00, 0x1C, 0x60, 0x00, 
+	0x0A, 0x46, 0x23, 0xEA, 0x02, 0x24, 0x00, 0x00, 0x37, 0x68, 0x60, 0x00, 0x0A, 0x3A, 0x70, 0x05, 
+	0xB0, 0xB9, 0x00, 0x00, 0x06, 0x90, 0x66, 0x00, 0x0A, 0x2E, 0x42, 0xA7, 0x42, 0xA7, 0x30, 0x2A, 
+	0x00, 0xA8, 0x48, 0xC0, 0x4E, 0xB9, 0x00, 0x10, 0x03, 0x1E, 0x2F, 0x00, 0x2F, 0x3A, 0x0A, 0x58, 
+	0x4E, 0xB9, 0x00, 0x10, 0x81, 0x78, 0x70, 0x10, 0xDF, 0xC0, 0x60, 0x00, 0x0A, 0x0A, 0x47, 0xF9, 
+	0x00, 0x00, 0x06, 0x90, 0x70, 0x01, 0xB0, 0xAB, 0x00, 0xE4, 0x64, 0x00, 0x09, 0xFA, 0x4E, 0xB9, 
+	0x00, 0x10, 0x8D, 0xB6, 0x42, 0xAB, 0x00, 0xEC, 0x2F, 0x2A, 0x00, 0x50, 0x30, 0x2A, 0x01, 0x9E, 
+	0x48, 0xC0, 0xD0, 0x80, 0x2F, 0x00, 0x4E, 0xB9, 0x00, 0x10, 0x8E, 0xF8, 0x50, 0x8F, 0x60, 0x00, 
+	0x09, 0xD6, 0x20, 0x79, 0x00, 0x00, 0x37, 0x60, 0x72, 0x00, 0x32, 0x39, 0x00, 0x00, 0x08, 0x0A, 
+	0x74, 0x0C, 0x20, 0x01, 0xC2, 0xC2, 0x48, 0x40, 0xC0, 0xC2, 0x48, 0x40, 0x42, 0x40, 0xD2, 0x80, 
+	0x0C, 0xB0, 0x00, 0x00, 0x93, 0xD0, 0x18, 0x04, 0x65, 0x00, 0x09, 0xAC, 0x23, 0xEA, 0x00, 0x5C, 
+	0x00, 0x00, 0x37, 0x98, 0x70, 0x00, 0x30, 0x38, 0x26, 0x4A, 0x25, 0x40, 0x00, 0x5C, 0x23, 0xEA, 
+	0x00, 0x60, 0x00, 0x00, 0x37, 0x9C, 0x30, 0x38, 0x26, 0x48, 0x25, 0x40, 0x00, 0x60, 0x20, 0x2A, 
+	0x00, 0x60, 0x72, 0x0A, 0xE3, 0xA0, 0x25, 0x40, 0x00, 0x60, 0x60, 0x00, 0x09, 0x7A, 0x20, 0x79, 
+	0x00, 0x00, 0x37, 0x60, 0x72, 0x00, 0x32, 0x39, 0x00, 0x00, 0x08, 0x0A, 0x74, 0x0C, 0x20, 0x01, 
+	0xC2, 0xC2, 0x48, 0x40, 0xC0, 0xC2, 0x48, 0x40, 0x42, 0x40, 0xD2, 0x80, 0x0C, 0xB0, 0x00, 0x00, 
+	0x93, 0xD0, 0x18, 0x04, 0x65, 0x00, 0x09, 0x50, 0x25, 0x79, 0x00, 0x00, 0x37, 0x98, 0x00, 0x5C, 
+	0x25, 0x79, 0x00, 0x00, 0x37, 0x9C, 0x00, 0x60, 0x60, 0x00, 0x09, 0x3C, 0x42, 0x6A, 0x01, 0x60, 
+	0x25, 0x7A, 0x09, 0x5C, 0x02, 0x28, 0x42, 0x79, 0x00, 0x00, 0x07, 0xD2, 0x70, 0x00, 0x30, 0x2A, 
+	0x01, 0xB4, 0x72, 0x0A, 0x4E, 0xB9, 0x00, 0x10, 0xE6, 0x86, 0x72, 0x7D, 0x34, 0x00, 0x70, 0x00, 
+	0x30, 0x2A, 0x01, 0xC4, 0xE3, 0x42, 0x04, 0x80, 0x00, 0x00, 0x00, 0xC8, 0xE7, 0x89, 0x4E, 0xB9, 
+	0x00, 0x10, 0xE6, 0x86, 0x94, 0x40, 0xC4, 0xF8, 0x26, 0x4C, 0x35, 0x42, 0x01, 0xDC, 0x60, 0x00, 
+	0x08, 0xF6, 0x0C, 0xAA, 0x00, 0x2D, 0xC6, 0xC0, 0x00, 0x54, 0x6C, 0x00, 0x08, 0xEA, 0x70, 0x02, 
+	0x35, 0x40, 0x01, 0x78, 0x70, 0x20, 0x35, 0x40, 0x01, 0x3A, 0x35, 0x7C, 0x00, 0xC2, 0x01, 0x6E, 
+	0x70, 0x03, 0x35, 0x40, 0x00, 0xAC, 0x60, 0x00, 0x08, 0xCE, 0x0C, 0x6A, 0x00, 0x01, 0x02, 0x0A, 
+	0x66, 0x00, 0x08, 0xC4, 0x70, 0x01, 0xB0, 0xAA, 0x00, 0x0C, 0x66, 0x00, 0x08, 0xBA, 0x4E, 0xB9, 
+	0x00, 0x10, 0x92, 0x8C, 0x20, 0x3C, 0xBF, 0xFF, 0xFF, 0xFF, 0xC0, 0xB9, 0x00, 0x40, 0x00, 0x1C, 
+	0x08, 0xC0, 0x00, 0x1E, 0x23, 0xC0, 0x00, 0x40, 0x00, 0x1C, 0x20, 0x3C, 0xBF, 0xFF, 0xFF, 0xFF, 
+	0xC0, 0xB9, 0x00, 0x40, 0x00, 0x1C, 0x23, 0xC0, 0x00, 0x40, 0x00, 0x1C, 0x47, 0xF9, 0x00, 0x00, 
+	0x06, 0x90, 0x2F, 0x2B, 0x01, 0xC0, 0x4E, 0xB9, 0x00, 0x10, 0x89, 0xE2, 0x58, 0x8F, 0x4E, 0xB9, 
+	0x00, 0x10, 0x92, 0xCA, 0x72, 0xFB, 0xC2, 0xB9, 0x00, 0x40, 0x00, 0x70, 0x70, 0x04, 0x82, 0x80, 
+	0x23, 0xC1, 0x00, 0x40, 0x00, 0x70, 0x70, 0xFB, 0xC0, 0xB9, 0x00, 0x40, 0x00, 0x70, 0x23, 0xC0, 
+	0x00, 0x40, 0x00, 0x70, 0x30, 0x2A, 0x01, 0x3A, 0x72, 0x0A, 0x48, 0xC0, 0xE3, 0xA0, 0x2F, 0x00, 
+	0x4E, 0xB9, 0x00, 0x10, 0x63, 0x32, 0x58, 0x8F, 0x4A, 0x80, 0x67, 0x00, 0xFA, 0xEA, 0x48, 0x78, 
+	0x03, 0xE8, 0x4E, 0xB9, 0x00, 0x10, 0x63, 0xA2, 0x58, 0x8F, 0x4E, 0xB9, 0x00, 0x10, 0x83, 0xE8, 
+	0x20, 0x7C, 0x00, 0x40, 0x30, 0x58, 0x22, 0x10, 0x70, 0x01, 0xC0, 0x41, 0x67, 0xF8, 0x23, 0xF9, 
+	0x00, 0x40, 0x30, 0x20, 0x00, 0x00, 0x37, 0xA0, 0x23, 0xF9, 0x00, 0x40, 0x00, 0x54, 0x00, 0x00, 
+	0x37, 0xA4, 0x20, 0x3C, 0x00, 0x00, 0x0F, 0xFF, 0xC0, 0xB9, 0x00, 0x00, 0x37, 0xA0, 0x72, 0x0E, 
+	0xE3, 0xA0, 0x22, 0x39, 0x00, 0x00, 0x37, 0xA4, 0x4E, 0xB9, 0x00, 0x10, 0xE6, 0x86, 0x23, 0xC0, 
+	0x00, 0x00, 0x37, 0xA0, 0x20, 0x3C, 0xFE, 0xFF, 0xFF, 0xFF, 0xC0, 0xB9, 0x00, 0x40, 0x30, 0x48, 
+	0x08, 0xC0, 0x00, 0x18, 0x23, 0xC0, 0x00, 0x40, 0x30, 0x48, 0x20, 0x3C, 0xFE, 0xFF, 0xFF, 0xFF, 
+	0xC0, 0xB9, 0x00, 0x40, 0x30, 0x48, 0x23, 0xC0, 0x00, 0x40, 0x30, 0x48, 0x2F, 0x39, 0x00, 0x00, 
+	0x37, 0xA0, 0x4E, 0xB9, 0x00, 0x10, 0x35, 0x02, 0x58, 0x8F, 0x42, 0x6B, 0x01, 0x44, 0x60, 0x00, 
+	0xFA, 0x56, 0x70, 0x09, 0x23, 0xC0, 0x00, 0x00, 0x37, 0xA8, 0x70, 0x0A, 0x23, 0xC0, 0x00, 0x00, 
+	0x37, 0xAC, 0x41, 0xF9, 0x00, 0x00, 0x06, 0x90, 0x47, 0xE8, 0x00, 0x0C, 0x70, 0x01, 0xB0, 0x93, 
+	0x66, 0x0E, 0x4A, 0xA8, 0x00, 0x10, 0x66, 0x08, 0x21, 0xFC, 0x00, 0x00, 0x01, 0x90, 0x26, 0x44, 
+	0x23, 0xF8, 0x26, 0x44, 0x00, 0x00, 0x37, 0xB0, 0x2F, 0x3A, 0x07, 0xB0, 0x2F, 0x39, 0x00, 0x00, 
+	0x37, 0xB0, 0x4E, 0xB9, 0x00, 0x10, 0xCF, 0x40, 0x58, 0x8F, 0x2F, 0x00, 0x4E, 0xB9, 0x00, 0x10, 
+	0xDA, 0x74, 0x23, 0xC0, 0x00, 0x00, 0x37, 0xB4, 0x4A, 0xAA, 0x00, 0x0C, 0x50, 0x8F, 0x67, 0x08, 
+	0x70, 0x02, 0xB0, 0xAA, 0x00, 0x0C, 0x66, 0x0A, 0x2F, 0x3A, 0x07, 0x84, 0x30, 0x2A, 0x01, 0x50, 
+	0x60, 0x0E, 0x4E, 0xB9, 0x00, 0x10, 0x96, 0xB4, 0x2F, 0x3A, 0x07, 0x74, 0x30, 0x2A, 0x01, 0x2E, 
+	0x48, 0xC0, 0x4E, 0xB9, 0x00, 0x10, 0x03, 0x1E, 0x2F, 0x00, 0x4E, 0xB9, 0x00, 0x10, 0xDA, 0x74, 
+	0x23, 0xC0, 0x00, 0x00, 0x37, 0xB8, 0x50, 0x8F, 0x48, 0x79, 0x00, 0x00, 0x37, 0xBC, 0x48, 0x79, 
+	0x00, 0x00, 0x37, 0xC0, 0x42, 0xA7, 0x2F, 0x13, 0x2F, 0x39, 0x00, 0x00, 0x37, 0xB4, 0x2F, 0x39, 
+	0x00, 0x00, 0x37, 0xB8, 0x4E, 0xB9, 0x00, 0x10, 0x97, 0x58, 0x70, 0x18, 0xDF, 0xC0, 0x23, 0xF9, 
+	0x00, 0x00, 0x37, 0xC0, 0x00, 0x00, 0x37, 0xC4, 0x23, 0xF9, 0x00, 0x00, 0x37, 0xBC, 0x00, 0x00, 
+	0x37, 0xC8, 0x24, 0x39, 0x00, 0x00, 0x37, 0xC4, 0x70, 0x19, 0xE1, 0xA2, 0x20, 0x39, 0x00, 0x00, 
+	0x37, 0xA8, 0x72, 0x14, 0xE3, 0xA0, 0x84, 0x80, 0x20, 0x39, 0x00, 0x00, 0x37, 0xC8, 0xEB, 0x80, 
+	0x84, 0x80, 0x84, 0xB9, 0x00, 0x00, 0x37, 0xAC, 0x23, 0xC2, 0x00, 0x40, 0x0C, 0x10, 0x60, 0x00, 
+	0x06, 0xA6, 0x0C, 0x6A, 0x00, 0x01, 0x01, 0xFC, 0x67, 0x08, 0x0C, 0x6A, 0x00, 0x01, 0x01, 0xFE, 
+	0x66, 0x62, 0x4A, 0x6A, 0x02, 0x00, 0x66, 0x5C, 0x70, 0x0F, 0x23, 0xC0, 0x00, 0x6C, 0x41, 0x40, 
+	0x23, 0xC0, 0x00, 0x6C, 0x41, 0x80, 0x23, 0xFC, 0x00, 0x00, 0x26, 0x70, 0x00, 0x6C, 0x80, 0x00, 
+	0x42, 0xB9, 0x00, 0x6C, 0x80, 0x04, 0x70, 0x01, 0x23, 0xC0, 0x00, 0x6C, 0x80, 0x04, 0x42, 0xB9, 
+	0x00, 0x6C, 0x80, 0x04, 0x41, 0xF9, 0x00, 0x00, 0x06, 0x90, 0x42, 0x68, 0x01, 0x64, 0x42, 0xB9, 
+	0x00, 0x60, 0x00, 0x28, 0x42, 0xB9, 0x00, 0x60, 0x00, 0x20, 0x42, 0xB9, 0x00, 0x60, 0x00, 0x5C, 
+	0x70, 0x16, 0x20, 0x80, 0x70, 0x01, 0x35, 0x40, 0x02, 0x00, 0x23, 0xC0, 0x00, 0x60, 0x00, 0x20, 
+	0x42, 0x78, 0x26, 0x32, 0x0C, 0x6A, 0x00, 0x01, 0x02, 0x00, 0x66, 0x00, 0x00, 0x8A, 0x4A, 0x6A, 
+	0x01, 0xFC, 0x66, 0x00, 0x00, 0x82, 0x4A, 0x6A, 0x01, 0xFE, 0x66, 0x7A, 0x23, 0xFC, 0x00, 0x00, 
+	0x26, 0x7F, 0x00, 0x6C, 0x80, 0x00, 0x42, 0xB9, 0x00, 0x6C, 0x80, 0x04, 0x70, 0x01, 0x23, 0xC0, 
+	0x00, 0x6C, 0x80, 0x04, 0x42, 0xB9, 0x00, 0x6C, 0x80, 0x04, 0x23, 0xFC, 0x00, 0x00, 0x26, 0x70, 
+	0x00, 0x6C, 0x80, 0x00, 0x42, 0xB9, 0x00, 0x6C, 0x80, 0x04, 0x23, 0xC0, 0x00, 0x6C, 0x80, 0x04, 
+	0x42, 0xB9, 0x00, 0x6C, 0x80, 0x04, 0x23, 0xFC, 0x00, 0x00, 0x26, 0x7F, 0x00, 0x6C, 0x80, 0x00, 
+	0x42, 0xB9, 0x00, 0x6C, 0x80, 0x04, 0x23, 0xC0, 0x00, 0x6C, 0x80, 0x04, 0x42, 0xB9, 0x00, 0x6C, 
+	0x80, 0x04, 0x42, 0x6A, 0x02, 0x00, 0x30, 0x2A, 0x01, 0xF8, 0x23, 0xC0, 0x00, 0x6C, 0x41, 0x40, 
+	0x30, 0x2A, 0x01, 0xFA, 0x23, 0xC0, 0x00, 0x6C, 0x41, 0x80, 0x70, 0x01, 0x23, 0xC0, 0x00, 0x60, 
+	0x00, 0x5C, 0x31, 0xC0, 0x26, 0x32, 0x60, 0x00, 0xF8, 0x4E, 0x42, 0xB9, 0x00, 0x00, 0x37, 0x64, 
+	0x4E, 0xB9, 0x00, 0x10, 0x0A, 0xA2, 0x4E, 0xB9, 0x00, 0x10, 0x2C, 0x0E, 0x41, 0xF9, 0x00, 0x00, 
+	0x06, 0x90, 0x70, 0x16, 0xB0, 0x90, 0x26, 0x48, 0x66, 0x0C, 0x70, 0x01, 0x23, 0xC0, 0x00, 0x00, 
+	0x37, 0x64, 0x60, 0x00, 0xF8, 0x22, 0x45, 0xE8, 0x00, 0x04, 0x20, 0x10, 0xB0, 0x92, 0x67, 0x06, 
+	0x4E, 0xB9, 0x00, 0x10, 0x2A, 0xCC, 0x24, 0x93, 0x4E, 0xB9, 0x00, 0x10, 0x35, 0xDA, 0x60, 0x00, 
+	0xF8, 0x06, 0x4A, 0x6A, 0x02, 0x0C, 0x66, 0x00, 0x05, 0x4E, 0x30, 0x2A, 0x01, 0x60, 0x72, 0x0A, 
+	0x48, 0xC0, 0x4E, 0xB9, 0x00, 0x10, 0xE6, 0x86, 0x33, 0xC0, 0x00, 0x00, 0x37, 0xCC, 0x20, 0x2A, 
+	0x00, 0x34, 0x72, 0x00, 0x32, 0x2A, 0x02, 0x20, 0xB3, 0x80, 0x53, 0x80, 0x66, 0x10, 0x30, 0x39, 
+	0x00, 0x00, 0x37, 0xCC, 0x48, 0xC0, 0x44, 0x80, 0x33, 0xC0, 0x00, 0x00, 0x37, 0xCC, 0x41, 0xF9, 
+	0x00, 0x00, 0x07, 0xD2, 0x30, 0x39, 0x00, 0x00, 0x37, 0xCC, 0x91, 0x50, 0x20, 0x2A, 0x00, 0x34, 
+	0x72, 0x00, 0x32, 0x2A, 0x02, 0x20, 0xB3, 0x80, 0x53, 0x80, 0x66, 0x00, 0x04, 0xFA, 0x30, 0x10, 
+	0x48, 0xC0, 0x44, 0x80, 0x30, 0x80, 0x60, 0x00, 0x04, 0xEE, 0x47, 0xF9, 0x00, 0x00, 0x06, 0x90, 
+	0x22, 0x13, 0x70, 0x01, 0xB2, 0x80, 0x67, 0x4C, 0x70, 0x03, 0xB2, 0x80, 0x67, 0x36, 0x70, 0x04, 
+	0xB2, 0x80, 0x67, 0x44, 0x70, 0x05, 0xB2, 0x80, 0x67, 0x3A, 0x70, 0x17, 0xB0, 0x81, 0x66, 0x3E, 
+	0x0C, 0xAA, 0x00, 0x1E, 0x84, 0x80, 0x00, 0x54, 0x6E, 0x18, 0x42, 0x78, 0x1E, 0x84, 0x2F, 0x2A, 
+	0x02, 0x24, 0x2F, 0x2A, 0x02, 0x50, 0x4E, 0xB9, 0x00, 0x10, 0xDA, 0x74, 0x27, 0x40, 0x01, 0xC4, 
+	0x50, 0x8F, 0x60, 0x0A, 0x0C, 0xAA, 0x00, 0x1E, 0x84, 0x80, 0x00, 0x54, 0x6F, 0x06, 0x42, 0xAA, 
+	0x00, 0x0C, 0x60, 0x0A, 0x70, 0x04, 0x60, 0x02, 0x70, 0x01, 0x25, 0x40, 0x00, 0x0C, 0x60, 0x00, 
+	0xF7, 0x36, 0x20, 0x39, 0x00, 0x6C, 0x00, 0x30, 0x33, 0xC0, 0x00, 0x00, 0x37, 0xCE, 0x42, 0x01, 
+	0x0C, 0x79, 0x00, 0x0F, 0x00, 0x00, 0x37, 0xCE, 0x67, 0x00, 0x04, 0x6E, 0x60, 0x00, 0xF7, 0x18, 
+	0x20, 0x39, 0x00, 0x6C, 0x00, 0x30, 0x33, 0xC0, 0x00, 0x00, 0x37, 0xCE, 0x0C, 0x79, 0x00, 0x0F, 
+	0x00, 0x00, 0x37, 0xCE, 0x66, 0x10, 0x72, 0x01, 0x4A, 0xB9, 0x00, 0x00, 0x37, 0x64, 0x66, 0x00, 
+	0x04, 0x48, 0x60, 0x00, 0x04, 0x42, 0x60, 0x00, 0xF6, 0xEE, 0x23, 0xF9, 0x00, 0x40, 0x08, 0x00, 
+	0x00, 0x00, 0x37, 0xD0, 0x08, 0x2A, 0x00, 0x00, 0x02, 0x05, 0x67, 0x00, 0x04, 0x2A, 0x20, 0x39, 
+	0x00, 0x00, 0x37, 0xD0, 0x72, 0x0B, 0xE2, 0xA0, 0x08, 0x00, 0x00, 0x00, 0x66, 0x00, 0x04, 0x18, 
+	0x30, 0x2A, 0x02, 0x10, 0x02, 0x40, 0x80, 0x00, 0x0C, 0x40, 0x80, 0x00, 0x66, 0x00, 0x04, 0x08, 
+	0x23, 0xF9, 0x00, 0x40, 0x08, 0x20, 0x00, 0x00, 0x37, 0xD4, 0x23, 0xF9, 0x00, 0x40, 0x08, 0x24, 
+	0x00, 0x00, 0x37, 0xD8, 0x23, 0xF9, 0x00, 0x40, 0x08, 0x18, 0x00, 0x00, 0x37, 0xDC, 0x23, 0xF9, 
+	0x00, 0x40, 0x08, 0x1C, 0x00, 0x00, 0x37, 0xE0, 0x42, 0x6A, 0x00, 0xBA, 0x42, 0xB9, 0x00, 0x60, 
+	0x00, 0x5C, 0x70, 0x01, 0x23, 0xC0, 0x00, 0x60, 0x00, 0x5C, 0x23, 0xF9, 0x00, 0x00, 0x37, 0xD4, 
+	0x00, 0x40, 0x08, 0x20, 0x23, 0xF9, 0x00, 0x00, 0x37, 0xD8, 0x00, 0x40, 0x08, 0x24, 0x23, 0xF9, 
+	0x00, 0x00, 0x37, 0xDC, 0x00, 0x40, 0x08, 0x18, 0x23, 0xF9, 0x00, 0x00, 0x37, 0xE0, 0x00, 0x40, 
+	0x08, 0x1C, 0x60, 0x3C, 0x23, 0xF9, 0x00, 0x40, 0x08, 0x00, 0x00, 0x00, 0x37, 0xE4, 0x30, 0x2A, 
+	0x02, 0x10, 0x02, 0x40, 0x80, 0x00, 0x0C, 0x40, 0x80, 0x00, 0x66, 0x00, 0x03, 0x8A, 0x08, 0x2A, 
+	0x00, 0x00, 0x02, 0x05, 0x67, 0x00, 0x03, 0x80, 0x20, 0x39, 0x00, 0x00, 0x37, 0xE4, 0x72, 0x0B, 
+	0xE2, 0xA0, 0x08, 0x00, 0x00, 0x00, 0x66, 0x00, 0x03, 0x6E, 0x70, 0x01, 0x35, 0x40, 0x00, 0xBA, 
+	0x4E, 0xB9, 0x00, 0x10, 0x68, 0x98, 0x60, 0x00, 0x03, 0x5E, 0x0C, 0x6A, 0x00, 0x01, 0x01, 0x94, 
+	0x66, 0x78, 0x47, 0xF9, 0x00, 0x00, 0x06, 0x90, 0x42, 0x6B, 0x01, 0x46, 0x42, 0x6B, 0x01, 0x48, 
+	0x22, 0x2A, 0x00, 0x44, 0x70, 0x05, 0xB2, 0x80, 0x62, 0x3A, 0x20, 0x01, 0xD0, 0x80, 0x32, 0x3B, 
+	0x08, 0x06, 0x4E, 0xFB, 0x10, 0x02, 0x00, 0x0C, 0x00, 0x14, 0x00, 0x1E, 0x00, 0x22, 0x00, 0x26, 
+	0x00, 0x2A, 0x42, 0x79, 0x00, 0x00, 0x37, 0xE8, 0x60, 0x38, 0x70, 0x01, 0x33, 0xC0, 0x00, 0x00, 
+	0x37, 0xE8, 0x60, 0x2E, 0x70, 0x05, 0x60, 0xF4, 0x70, 0x08, 0x60, 0xF0, 0x70, 0x0D, 0x60, 0xEC, 
+	0x70, 0x19, 0x60, 0xE8, 0x48, 0x7A, 0x03, 0x4C, 0x48, 0x78, 0x00, 0xA0, 0x48, 0x79, 0x00, 0x00, 
+	0x1D, 0x40, 0x4E, 0xB9, 0x00, 0x10, 0xC4, 0xF6, 0x70, 0x0C, 0xDF, 0xC0, 0x4E, 0xB9, 0x00, 0x10, 
+	0x0C, 0x78, 0x27, 0x6A, 0x00, 0x44, 0x00, 0x08, 0x60, 0x10, 0x70, 0x02, 0xB0, 0xAA, 0x00, 0x0C, 
+	0x66, 0x08, 0x70, 0x01, 0x33, 0xC0, 0x00, 0x00, 0x37, 0xE8, 0x0C, 0x6A, 0x00, 0x01, 0x01, 0x94, 
+	0x67, 0x5C, 0x70, 0x02, 0xB0, 0xAA, 0x00, 0x0C, 0x66, 0x6A, 0x60, 0x52, 0x22, 0x39, 0x00, 0x40, 
+	0x04, 0x00, 0x70, 0x01, 0xC0, 0x41, 0x67, 0x10, 0x70, 0xFE, 0xC0, 0xB9, 0x00, 0x40, 0x04, 0x00, 
+	0x23, 0xC0, 0x00, 0x40, 0x04, 0x00, 0x60, 0x36, 0x4A, 0x79, 0x00, 0x00, 0x37, 0xE8, 0x63, 0x2E, 
+	0x72, 0xFE, 0xC2, 0xB9, 0x00, 0x40, 0x04, 0x00, 0x70, 0x01, 0x82, 0x80, 0x23, 0xC1, 0x00, 0x40, 
+	0x04, 0x00, 0x43, 0xF9, 0x00, 0x00, 0x06, 0x90, 0x41, 0xE9, 0x01, 0x46, 0x52, 0x50, 0x30, 0x10, 
+	0x72, 0x1F, 0xC0, 0x41, 0x33, 0x40, 0x01, 0x48, 0x53, 0x79, 0x00, 0x00, 0x37, 0xE8, 0x4A, 0x79, 
+	0x00, 0x00, 0x37, 0xE8, 0x62, 0xA6, 0x70, 0xFE, 0xC0, 0xB9, 0x00, 0x40, 0x04, 0x00, 0x23, 0xC0, 
+	0x00, 0x40, 0x04, 0x00, 0x33, 0xF9, 0x00, 0x00, 0x37, 0xE8, 0x00, 0x00, 0x37, 0xEA, 0x48, 0x78, 
+	0x06, 0x40, 0x60, 0x00, 0x01, 0x72, 0x4A, 0x6A, 0x01, 0x94, 0x67, 0x00, 0x02, 0x3A, 0x20, 0x39, 
+	0x00, 0x40, 0x04, 0x14, 0xE6, 0x80, 0x08, 0x00, 0x00, 0x00, 0x67, 0x00, 0x01, 0x3E, 0x70, 0x02, 
+	0xB0, 0xAA, 0x00, 0x0C, 0x66, 0x3A, 0x0C, 0x79, 0x00, 0x03, 0x00, 0x00, 0x07, 0xD8, 0x66, 0x0E, 
+	0x47, 0xF9, 0x00, 0x10, 0x6A, 0xD4, 0x74, 0x09, 0x4E, 0x93, 0x53, 0x82, 0x66, 0xFA, 0x0C, 0x79, 
+	0x00, 0x13, 0x00, 0x00, 0x07, 0xD8, 0x66, 0x0E, 0x47, 0xF9, 0x00, 0x10, 0x6A, 0xD4, 0x74, 0x0E, 
+	0x4E, 0x93, 0x53, 0x82, 0x66, 0xFA, 0x4E, 0xB9, 0x00, 0x10, 0x6A, 0xD4, 0x60, 0x00, 0x00, 0xA4, 
+	0x4A, 0xAA, 0x00, 0x0C, 0x66, 0x00, 0x00, 0x9C, 0x22, 0x2A, 0x00, 0x44, 0x70, 0x05, 0xB2, 0x80, 
+	0x62, 0x5A, 0x20, 0x01, 0xD0, 0x80, 0x32, 0x3B, 0x08, 0x06, 0x4E, 0xFB, 0x10, 0x02, 0x00, 0x6C, 
+	0x00, 0x0C, 0x00, 0x1E, 0x00, 0x2A, 0x00, 0x36, 0x00, 0x42, 0x0C, 0x79, 0x00, 0x04, 0x00, 0x00, 
+	0x07, 0xD6, 0x6C, 0x56, 0x4E, 0xB9, 0x00, 0x10, 0x6A, 0xD4, 0x60, 0x4E, 0x0C, 0x79, 0x00, 0x07, 
+	0x00, 0x00, 0x07, 0xD6, 0x6C, 0x44, 0x60, 0xEC, 0x0C, 0x79, 0x00, 0x0C, 0x00, 0x00, 0x07, 0xD6, 
+	0x6C, 0x38, 0x60, 0xE0, 0x0C, 0x79, 0x00, 0x18, 0x00, 0x00, 0x07, 0xD6, 0x6C, 0x2C, 0x60, 0xD4, 
+	0x0C, 0x79, 0x00, 0x1F, 0x00, 0x00, 0x07, 0xD6, 0x6C, 0x20, 0x60, 0xC8, 0x48, 0x7A, 0x01, 0xC4, 
+	0x48, 0x78, 0x00, 0xA0, 0x48, 0x79, 0x00, 0x00, 0x1D, 0x40, 0x4E, 0xB9, 0x00, 0x10, 0xC4, 0xF6, 
+	0x70, 0x0C, 0xDF, 0xC0, 0x4E, 0xB9, 0x00, 0x10, 0x0C, 0x78, 0x0C, 0x79, 0x00, 0x1D, 0x00, 0x00, 
+	0x07, 0xD8, 0x66, 0x0E, 0x47, 0xF9, 0x00, 0x10, 0x6A, 0xD4, 0x74, 0x03, 0x4E, 0x93, 0x53, 0x82, 
+	0x66, 0xFA, 0x08, 0x2A, 0x00, 0x00, 0x02, 0x05, 0x67, 0x40, 0x43, 0xF9, 0x00, 0x00, 0x06, 0x90, 
+	0x41, 0xE9, 0x01, 0x48, 0x0C, 0x50, 0x00, 0x0A, 0x66, 0x08, 0x70, 0x0E, 0xD1, 0x79, 0x00, 0x00, 
+	0x37, 0xEA, 0x52, 0x79, 0x00, 0x00, 0x37, 0xEA, 0x0C, 0x50, 0x00, 0x04, 0x67, 0x06, 0x0C, 0x50, 
+	0x00, 0x07, 0x66, 0x06, 0x52, 0x79, 0x00, 0x00, 0x37, 0xEA, 0x0C, 0x79, 0x00, 0x1C, 0x00, 0x00, 
+	0x37, 0xEA, 0x63, 0x06, 0x70, 0x02, 0x33, 0x40, 0x01, 0x5E, 0x70, 0xF7, 0xC0, 0xB9, 0x00, 0x40, 
+	0x04, 0x14, 0x23, 0xC0, 0x00, 0x40, 0x04, 0x14, 0x60, 0x12, 0x72, 0xF7, 0xC2, 0xB9, 0x00, 0x40, 
+	0x04, 0x14, 0x70, 0x08, 0x82, 0x80, 0x23, 0xC1, 0x00, 0x40, 0x04, 0x14, 0x42, 0x79, 0x00, 0x00, 
+	0x07, 0xE0, 0x48, 0x78, 0x03, 0xE8, 0x4E, 0xB9, 0x00, 0x10, 0x63, 0xA2, 0x58, 0x8F, 0x60, 0x00, 
+	0xF3, 0x76, 0x4A, 0x6A, 0x01, 0x94, 0x67, 0x00, 0x00, 0xBE, 0x41, 0xF9, 0x00, 0x00, 0x06, 0x90, 
+	0x70, 0x00, 0x30, 0x38, 0x26, 0x2E, 0xB0, 0xA8, 0x00, 0x0C, 0x66, 0x0E, 0x70, 0x00, 0x30, 0x38, 
+	0x26, 0x30, 0xB0, 0xA8, 0x00, 0x08, 0x67, 0x00, 0x00, 0x9E, 0x42, 0x68, 0x01, 0x6A, 0x60, 0x00, 
+	0x00, 0x96, 0x4A, 0x6A, 0x01, 0x94, 0x67, 0x00, 0x00, 0x8E, 0x08, 0x2A, 0x00, 0x00, 0x02, 0x05, 
+	0x67, 0x06, 0x4E, 0xB9, 0x00, 0x10, 0x33, 0x9C, 0x60, 0x00, 0xF3, 0x2C, 0x41, 0xF9, 0x00, 0x00, 
+	0x06, 0x90, 0x70, 0x01, 0xB0, 0xA8, 0x00, 0x0C, 0x66, 0x6C, 0x4A, 0xA8, 0x00, 0x10, 0x66, 0x66, 
+	0x50, 0x88, 0x70, 0x0A, 0xB0, 0x90, 0x66, 0x08, 0x70, 0x2D, 0x35, 0x40, 0x01, 0x2E, 0x60, 0x56, 
+	0x70, 0x0B, 0xB0, 0x90, 0x66, 0x04, 0x70, 0x32, 0x60, 0xF0, 0x70, 0x0C, 0xB0, 0x90, 0x67, 0x06, 
+	0x70, 0x0E, 0xB0, 0x90, 0x66, 0x04, 0x70, 0x3C, 0x60, 0xE0, 0x70, 0x0F, 0xB0, 0x90, 0x66, 0x04, 
+	0x70, 0x46, 0x60, 0xD6, 0x70, 0x10, 0xB0, 0x90, 0x66, 0x2C, 0x70, 0x50, 0x60, 0xCC, 0x23, 0xF9, 
+	0x00, 0x40, 0x08, 0x00, 0x00, 0x00, 0x37, 0xEC, 0x20, 0x39, 0x00, 0x00, 0x37, 0xEC, 0x72, 0x0B, 
+	0xE2, 0xA0, 0x08, 0x00, 0x00, 0x00, 0x66, 0x0E, 0x4A, 0xB8, 0x26, 0x2A, 0x63, 0x08, 0x23, 0xF8, 
+	0x26, 0x2A, 0x00, 0x40, 0x08, 0x18, 0x42, 0x01, 0x70, 0x00, 0x10, 0x01, 0x4C, 0xEE, 0x0C, 0x04, 
+	0xFF, 0xF4, 0x4E, 0x5E, 0x4E, 0x75, 0x3E, 0xCC, 0xCC, 0xCD, 0x3B, 0x03, 0x12, 0x6F, 0x4D, 0x80, 
+	0x00, 0x00, 0x3F, 0x80, 0x00, 0x00, 0x49, 0x74, 0x24, 0x00, 0x42, 0xC8, 0x00, 0x00, 0x00, 0x00, 
+	0x00, 0x00, 0x43, 0x00, 0x00, 0x00, 0x43, 0x80, 0x00, 0x00, 0x42, 0x65, 0x2E, 0xED, 0x43, 0x48, 
+	0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x3A, 0xC4, 0x9B, 0xA6, 0x3C, 0x23, 0xD7, 0x0A, 0x37, 0x27, 
+	0xC5, 0xAC, 0x49, 0x6C, 0x6C, 0x65, 0x67, 0x61, 0x6C, 0x20, 0x63, 0x6F, 0x64, 0x65, 0x20, 0x72, 
+	0x61, 0x74, 0x65, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x44, 0x56, 0x42, 0x53, 0x20, 0x73, 0x74, 0x64, 
+	0x20, 0x0A, 0x00, 0x4E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x14, 0x00, 0x10, 0x03, 0xB2, 
+	0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x10, 0x00, 0x10, 0x04, 0x28, 0x00, 0x00, 0x00, 0x04, 
+	0x00, 0x00, 0x00, 0x0C, 0x00, 0x10, 0x04, 0x9E, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x08, 
+	0x00, 0x10, 0x05, 0x18, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x01, 0x00, 0x00, 0x10, 0x05, 0x64, 
+	0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x10, 0x02, 0x58
+
+};
+
diff -Naur a/drivers/amlogic/dvb_tv/avl6211/Kconfig b/drivers/amlogic/dvb_tv/avl6211/Kconfig
--- a/drivers/amlogic/dvb_tv/avl6211/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/amlogic/dvb_tv/avl6211/Kconfig	2014-12-11 16:13:50.473614685 +0100
@@ -0,0 +1,21 @@
+#
+# Avl6211 driver configuration
+#
+menuconfig AM_AVL6211
+	tristate "AVL6211 demod driver"
+	default n
+	depends on AM_DVB
+	help
+		Select to enable AVL6211 demod driver.
+
+if AM_AVL6211
+
+config AVL6211_OUTPUT_SERIAL
+	bool "Serial Output Mode"
+	depends on AM_AVL6211
+	default n
+	help
+	 data default on DATA0
+
+endif
+
diff -Naur a/drivers/amlogic/dvb_tv/avl6211/Makefile b/drivers/amlogic/dvb_tv/avl6211/Makefile
--- a/drivers/amlogic/dvb_tv/avl6211/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/amlogic/dvb_tv/avl6211/Makefile	2014-12-11 16:13:49.913618978 +0100
@@ -0,0 +1,17 @@
+obj-$(CONFIG_AM_AVL6211) += avl6211_fe.o
+
+avl6211_src = src
+avl6211_fe-objs +=  avlfrontend.o	
+avl6211_fe-objs +=  $(avl6211_src)/avl.o  $(avl6211_src)/avl_dvbsx.o	$(avl6211_src)/IBase.o	 $(avl6211_src)/avl_dvbsx.o	$(avl6211_src)/IDiseqc.o  $(avl6211_src)/II2C.o	\
+										$(avl6211_src)/II2CRepeater.o  $(avl6211_src)/IRx.o  $(avl6211_src)/IBSP.o	$(avl6211_src)/LockSignal_Api.o  ##$(avl6211_src)/ExtSharpBS2S7HZ6306.o	 $(avl6211_src)/DiSEqC_source.o  
+										
+avl6211_fe-objs +=	$(avl6211_src)/IBlindscanAPI.o   $(avl6211_src)/IBlindScan.o
+
+avl6211_fe-objs +=  AV2011/ExtAV2011.o	
+
+
+EXTRA_CFLAGS += -I.
+EXTRA_CFLAGS += -Idrivers/media/dvb-core
+EXTRA_CFLAGS += -Idrivers/amlogic/dvb_tv/avl6211/include
+EXTRA_CFLAGS += -Idrivers/amlogic/dvb_tv/avl6211
+EXTRA_CFLAGS += -Idrivers/amlogic/dvb_tv/avl6211/AV2011
diff -Naur a/drivers/amlogic/dvb_tv/avl6211/src/avl.c b/drivers/amlogic/dvb_tv/avl6211/src/avl.c
--- a/drivers/amlogic/dvb_tv/avl6211/src/avl.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/amlogic/dvb_tv/avl6211/src/avl.c	2014-12-11 16:13:50.325615817 +0100
@@ -0,0 +1,162 @@
+/*
+ *           Copyright 2012 Availink, Inc.
+ *
+ *  This software contains Availink proprietary information and
+ *  its use and disclosure are restricted solely to the terms in
+ *  the corresponding written license agreement. It shall not be 
+ *  disclosed to anyone other than valid licensees without
+ *  written permission of Availink, Inc.
+ *
+ */
+
+
+///$Date: 2012-2-9 17:36 $
+///
+#include "avl.h"
+
+#ifdef AVL_CPLUSPLUS
+extern "C" {
+#endif
+
+	void ChunkAddr(AVL_uint32 uiaddr, AVL_puchar pBuff)
+	{
+		pBuff[0] =(AVL_uchar)(uiaddr>>16);
+		pBuff[1] =(AVL_uchar)(uiaddr>>8);
+		pBuff[2] =(AVL_uchar)(uiaddr);
+		return ;
+	}
+
+	void Chunk16(AVL_uint16 uidata, AVL_puchar pBuff)
+	{
+		pBuff[0] = (AVL_uchar)(uidata>>8);
+		pBuff[1] = (AVL_uchar)(uidata & 0xff);
+		return ;
+	}
+
+	AVL_uint16 DeChunk16(const AVL_puchar pBuff)
+	{
+		AVL_uint16 uiData;
+		uiData = pBuff[0];
+		uiData = (AVL_uint16)(uiData << 8) + pBuff[1];
+		return uiData;
+	}
+
+	void Chunk32(AVL_uint32 uidata, AVL_puchar pBuff)
+	{
+		pBuff[0] = (AVL_uchar)(uidata>>24);
+		pBuff[1] = (AVL_uchar)(uidata>>16);
+		pBuff[2] = (AVL_uchar)(uidata>>8);
+		pBuff[3] = (AVL_uchar)(uidata);
+		return ;
+	}
+
+	AVL_uint32 DeChunk32(const AVL_puchar pBuff)
+	{
+		AVL_uint32 uiData;
+		uiData = pBuff[0];
+		uiData = (uiData << 8) + pBuff[1];
+		uiData = (uiData << 8) + pBuff[2];
+		uiData = (uiData << 8) + pBuff[3];
+		return uiData;
+	}
+
+	void Add32To64(struct AVL_uint64 *pSum, AVL_uint32 uiAddend)
+	{
+		AVL_uint32 uiTemp;
+
+		uiTemp = pSum->m_LowWord;
+		pSum->m_LowWord += uiAddend;
+		pSum->m_LowWord &= 0xFFFFFFFF;
+
+		if (pSum->m_LowWord < uiTemp)
+		{
+			pSum->m_HighWord++;
+		}
+	}
+
+	AVL_uint32 Divide64(struct AVL_uint64 divisor, struct AVL_uint64 dividend)
+	{
+		AVL_uint32 uFlag = 0x0;
+		AVL_uint32 uQuto = 0x0;
+		AVL_uint32 i = 0;
+		AVL_uint32 dividend_H = dividend.m_HighWord;
+		AVL_uint32 dividend_L = dividend.m_LowWord;
+		AVL_uint32 divisor_H = divisor.m_HighWord; 
+		AVL_uint32 divisor_L = divisor.m_LowWord; 
+
+		if(((divisor_H == 0x0) && (divisor_L == 0x0)) || (dividend_H/divisor_L))
+		{   
+			return 0;
+		}
+		else if((divisor_H == 0x0)&&(dividend_H == 0x0))
+		{
+			return  dividend_L / divisor_L;
+		} 
+		else 
+		{  
+			if(divisor_H != 0)
+			{
+				while(divisor_H)
+				{
+					dividend_L /= 2;
+					if(dividend_H % 2)
+					{    
+						dividend_L += 0x80000000;
+					}
+					dividend_H /= 2;
+
+					divisor_L /= 2;
+					if(divisor_H %2)
+					{    
+						divisor_L += 0x80000000;
+					}
+					divisor_H /= 2;
+				}
+			}   
+			for   (i = 0; i <= 31; i++) 
+			{ 
+
+				uFlag = (AVL_int32)dividend_H >> 31;
+
+				dividend_H = (dividend_H << 1)|(dividend_L >> 31);
+				dividend_L <<= 1; 
+
+				uQuto <<= 1;
+				if((dividend_H|uFlag) >= divisor_L)
+				{ 
+					dividend_H -= divisor_L;   
+					uQuto++;   
+				}   
+			} 
+			return uQuto;
+		} 
+
+	}
+
+	void Multiply32(struct AVL_uint64 *pDst, AVL_uint32 m1, AVL_uint32 m2)
+	{
+		pDst->m_LowWord = (m1 & 0xFFFF) * (m2 & 0xFFFF);
+		pDst->m_HighWord = 0;
+
+		AddScaled32To64(pDst, (m1 >> 16) * (m2 & 0xFFFF));
+		AddScaled32To64(pDst, (m2 >> 16) * (m1 & 0xFFFF));
+
+		pDst->m_HighWord += (m1 >> 16) * (m2 >> 16);
+	}
+
+	void AddScaled32To64(struct AVL_uint64 *pDst, AVL_uint32 a)
+	{
+		AVL_uint32 saved;
+
+		saved = pDst->m_LowWord;
+		pDst->m_LowWord += (a << 16);
+
+		pDst->m_LowWord &= 0xFFFFFFFF;
+		pDst->m_HighWord += ((pDst->m_LowWord < saved) ? 1 : 0) + (a >> 16);
+	}
+
+
+#ifdef AVL_CPLUSPLUS
+}
+#endif
+
diff -Naur a/drivers/amlogic/dvb_tv/avl6211/src/avl_dvbsx.c b/drivers/amlogic/dvb_tv/avl6211/src/avl_dvbsx.c
--- a/drivers/amlogic/dvb_tv/avl6211/src/avl_dvbsx.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/amlogic/dvb_tv/avl6211/src/avl_dvbsx.c	2014-12-11 16:13:50.473614685 +0100
@@ -0,0 +1,32 @@
+/*
+ *           Copyright 2012 Availink, Inc.
+ *
+ *  This software contains Availink proprietary information and
+ *  its use and disclosure are restricted solely to the terms in
+ *  the corresponding written license agreement. It shall not be 
+ *  disclosed to anyone other than valid licensees without
+ *  written permission of Availink, Inc.
+ *
+ */
+
+
+///$Date: 2012-2-9 17:36 $
+///
+#include "avl.h"
+#include "avl_dvbsx.h"
+#include "IBSP.h"
+#include "II2C.h"
+
+AVL_DVBSx_ErrorCode Init_AVL_DVBSx_ChipObject(struct AVL_DVBSx_Chip * pAVL_DVBSx_ChipObject, AVL_uint16 uiSlaveAddress)
+{
+	AVL_DVBSx_ErrorCode r;
+	pAVL_DVBSx_ChipObject->m_SlaveAddr = uiSlaveAddress;
+	pAVL_DVBSx_ChipObject->m_StdBuffIndex = 0;
+	pAVL_DVBSx_ChipObject->Diseqc_OP_Status = AVL_DVBSx_DOS_Uninitialized;
+	r = AVL_DVBSx_IBSP_InitSemaphore(&(pAVL_DVBSx_ChipObject->m_semRx));
+	r |= AVL_DVBSx_IBSP_InitSemaphore(&(pAVL_DVBSx_ChipObject->m_semI2CRepeater));
+	r |= AVL_DVBSx_IBSP_InitSemaphore(&(pAVL_DVBSx_ChipObject->m_semI2CRepeater_r));
+	r |= AVL_DVBSx_IBSP_InitSemaphore(&(pAVL_DVBSx_ChipObject->m_semDiseqc));
+	r |= AVL_DVBSx_II2C_Initialize(); // there is a internal protection to assure it will be initialized only once.
+	return (r);
+}
diff -Naur a/drivers/amlogic/dvb_tv/avl6211/src/BlindScan_source.cpp b/drivers/amlogic/dvb_tv/avl6211/src/BlindScan_source.cpp
--- a/drivers/amlogic/dvb_tv/avl6211/src/BlindScan_source.cpp	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/amlogic/dvb_tv/avl6211/src/BlindScan_source.cpp	2014-12-11 16:13:50.377615419 +0100
@@ -0,0 +1,610 @@
+/*
+ *           Copyright 2012 Availink, Inc.
+ *
+ *  This software contains Availink proprietary information and
+ *  its use and disclosure are restricted solely to the terms in
+ *  the corresponding written license agreement. It shall not be 
+ *  disclosed to anyone other than valid licensees without
+ *  written permission of Availink, Inc.
+ *
+ */
+
+
+///$Date: 2012-2-9 17:36 $
+///
+#include <conio.h>
+#include "stdio.h"
+#include "IBSP.h"
+#include "avl_dvbsx.h"
+#include "IBase.h"
+#include "IRx.h"
+#include "ITuner.h"
+#include "ExtSharpBS2S7HZ6306.h"
+#include "II2C.h"
+#include "IDiseqc.h"
+#include "IBlindScan.h"
+#include "IBlindscanAPI.h"
+#include "BlindScan_source.h"
+
+extern AVL_uchar ucPatchData [];				//Defined in AVL6211_patch.dat.cpp.
+
+#define Chip_ID					0x0F //0x01000002		//The Chip ID of AVL6211.
+#define bs_start_freq			950				//The start RF frequency, 950MHz
+#define bs_stop_freq			2150			//The stop RF frequency, 2150MHz
+#define Blindscan_Mode   AVL_DVBSx_BS_Slow_Mode	//The Blind scan mode.	AVL_DVBSx_BS_Fast_Mode = 0,AVL_DVBSx_BS_Slow_Mode = 1
+#define Diseqc_Tone_Frequency   22              //The DiSEqC bus speed in the unit of kHz. Normally, it should be 22kHz. 
+
+#define FontEnd_MaxCount 2
+struct AVL_DVBSx_Chip  g_stAvlDVBSxChip[FontEnd_MaxCount];
+struct AVL_Tuner g_stTuner[FontEnd_MaxCount];
+enum AVL_Demod_ReferenceClock_Select_t
+{
+	Ref_clock_4M=0,
+	Ref_clock_4M5=1,
+	Ref_clock_10M=2,
+	Ref_clock_16M=3,
+	Ref_clock_27M=4,
+	Ref_clock_Enhance_4M=5,
+	Ref_clock_Enhance_4M5=6,
+	Ref_clock_Enhance_10M=7,
+	Ref_clock_Enhance_16M=8,
+	Ref_clock_Enhance_27M=9,
+};
+
+enum AVL_TunerLPF_Calculation_Flag
+{
+	InputLPF = 0,
+	InputSymbolRate = 1,
+};
+
+struct AVL_Demod_Tuner_Configuration_t
+{
+	////////////////////////////Demod Configure///////////////////////////////
+
+	AVL_char m_ChannelId;												///< Bus identifier.
+	AVL_uint16 m_uiDemodAddress;										///< Device I2C slave address.
+	enum AVL_Demod_ReferenceClock_Select_t   m_DemodReferenceClk;		///< Configures the Availink device's PLL.Refer to enum AVL_Demod_ReferenceClock_Select_t
+
+	///< The MPEG output mode. The default value in the Availink device is \a AVL_DVBSx_MPM_Parallel
+	enum AVL_DVBSx_MpegMode m_TSOutPutMode;								///< AVL_DVBSx_MPM_Parallel = 0;	Output MPEG data in parallel mode
+																		///< AVL_DVBSx_MPM_Serial = 1;		Output MPEG data in serial mode
+
+	///< The MPEG output clock polarity. The clock polarity should be configured to meet the back end device's requirement.The default value in the Availink device is \a AVL_DVBSx_MPCP_Rising.
+	enum AVL_DVBSx_MpegClockPolarity m_TSClockPolarity;					///< AVL_DVBSx_MPCP_Falling = 0;	The MPEG data is valid on the falling edge of the clock.
+																		///< AVL_DVBSx_MPCP_Rising = 1;		The MPEG data is valid on the rising edge of the clock.
+
+	///< The MPEG output format. The default value in the Availink device is \a AVL_DVBSx_MPF_TS
+	enum AVL_DVBSx_MpegFormat m_TSFormat;								///< AVL_DVBSx_MPF_TS = 0;		Transport stream format.
+																		///< AVL_DVBSx_MPF_TSP = 1;		Transport stream plus parity format.
+
+	///< Defines the pin on which the Availink device outputs the MPEG data when the MPEG interface has been configured to operate in serial mode.
+	enum AVL_DVBSx_MpegSerialPin m_SerDataPin;							///< AVL_DVBSx_MPSP_DATA0 = 0;		Serial data is output on pin MPEG_DATA_0
+																		///< AVL_DVBSx_MPSP_DATA7 = 1;		Serial data is output on pin MPEG_DATA_7
+
+	////////////////////////////Tuner Configure///////////////////////////////
+
+	AVL_uint16 m_uiTunerAddress;										///< Tuner I2C slave address.
+	AVL_uint16 m_uiTuner_I2Cbus_clock;									///< The clock speed of the tuner dedicated I2C bus, in a unit of kHz.
+	AVL_uint16 m_uiTunerMaxLPF_100Khz;									///< The max low pass filter bandwidth of the tuner.
+
+	///< Defines the LPF's forms of computation.
+	enum AVL_TunerLPF_Calculation_Flag m_LPF_Config_flag;				///< InputLPF = 0;			The LPF will be calculated by formula which defined by user.
+																		///< InputSymbolRate = 1;	The LPF will be calculated in tuner driver according to the SymbolRate.
+
+	///< Defines the polarity of the RF AGC control signal.The polarity of the RF AGC control signal must be configured to match that required by the tuner.
+	enum AVL_DVBSx_RfagcPola m_TunerRFAGC;								///< AVL_DVBSx_RA_Normal = 0;	Normal polarization. This setting is used for a tuner whose gain increases with increased AGC voltage.
+																		///< AVL_DVBSx_RA_Invert = 1;	Inverted polarization. The default value. Most tuners fall into this category.  This setting is used for a tuner whose gain decreases with increased AGC voltage.
+
+	///< Defines the device spectrum polarity setting. 
+	enum AVL_DVBSx_SpectrumPolarity m_Tuner_IQ_SpectrumMode;			///< AVL_DVBSx_Spectrum_Normal = 0;	The received signal spectrum is not inverted.
+																		///< AVL_DVBSx_Spectrum_Invert = 1;	The received signal spectrum is inverted.
+
+	AVL_DVBSx_ErrorCode (* m_pInitializeFunc)(struct AVL_Tuner *);	 	///< A pointer to the tuner initialization function.
+	AVL_DVBSx_ErrorCode (* m_pGetLockStatusFunc)(struct AVL_Tuner *); 	///< A pointer to the tuner GetLockStatus function.
+	AVL_DVBSx_ErrorCode (* m_pLockFunc)(struct AVL_Tuner *);			///< A pointer to the tuner Lock function.      
+};
+
+
+/*Here please according to customer needs, defining the array index*/
+
+static AVL_char g_nDemodTunerArrayIndex = 0;
+
+struct AVL_Demod_Tuner_Configuration_t g_DemodTuner_Config[]=
+{
+	{
+			0,
+			AVL_DVBSx_SA_0,
+			Ref_clock_10M,
+			AVL_DVBSx_MPM_Parallel,
+			AVL_DVBSx_MPCP_Rising,
+			AVL_DVBSx_MPF_TSP,
+			AVL_DVBSx_MPSP_DATA0,
+
+			0xC0,
+			200,
+			340,
+			InputLPF,
+			AVL_DVBSx_RA_Invert,
+			AVL_DVBSx_Spectrum_Normal,
+			&ExtSharpBS2S7HZ6306_Initialize,
+			&ExtSharpBS2S7HZ6306_GetLockStatus,
+			&ExtSharpBS2S7HZ6306_Lock,
+	},
+	{
+			1,
+			AVL_DVBSx_SA_0,
+			Ref_clock_10M,
+			AVL_DVBSx_MPM_Parallel,
+			AVL_DVBSx_MPCP_Rising,
+			AVL_DVBSx_MPF_TSP,
+			AVL_DVBSx_MPSP_DATA0,
+
+			0xC0,
+			200,
+			340,
+			InputLPF,
+			AVL_DVBSx_RA_Invert,
+			AVL_DVBSx_Spectrum_Normal,
+			&ExtSharpBS2S7HZ6306_Initialize,
+			&ExtSharpBS2S7HZ6306_GetLockStatus,
+			&ExtSharpBS2S7HZ6306_Lock,
+	},
+};
+
+void AVL_DVBSx_Error_Dispose(AVL_DVBSx_ErrorCode r)
+{
+	switch(r)
+	{
+	case AVL_DVBSx_EC_OK:
+		printf("AVL_DVBSx_EC_OK !\n");
+		break;
+	case AVL_DVBSx_EC_GeneralFail:
+		printf("AVL_DVBSx_EC_GeneralFail !\n");
+		break;
+	case AVL_DVBSx_EC_I2CFail:
+		printf("AVL_DVBSx_EC_I2CFail !\n");
+		break;
+	case AVL_DVBSx_EC_TimeOut:
+		printf("AVL_DVBSx_EC_TimeOut !\n");
+		break;
+	case AVL_DVBSx_EC_Running:
+		printf("AVL_DVBSx_EC_Running !\n");
+		break;
+	case AVL_DVBSx_EC_InSleepMode:
+		printf("AVL_DVBSx_EC_InSleepMode !\n");
+		break; 			
+	case AVL_DVBSx_EC_MemoryRunout:
+		printf("AVL_DVBSx_EC_MemoryRunout !\n");
+		break;
+	case AVL_DVBSx_EC_BSP_ERROR1:
+		printf("AVL_DVBSx_EC_BSP_ERROR1 !\n");
+		break;
+	case AVL_DVBSx_EC_BSP_ERROR2:
+		printf("AVL_DVBSx_EC_BSP_ERROR2 !\n");
+		break;
+	}
+}
+
+AVL_DVBSx_ErrorCode CPU_Halt(struct AVL_DVBSx_Chip * pAVLChip)
+{
+	AVL_DVBSx_ErrorCode r;
+	AVL_uint16 i= 0;
+
+	r = AVL_DVBSx_IBase_SendRxOP(OP_RX_HALT, pAVLChip );
+
+	if(AVL_DVBSx_EC_OK == r)
+	{
+		while(i++<20)
+		{
+			r = AVL_DVBSx_IBase_GetRxOPStatus(pAVLChip);
+			if(AVL_DVBSx_EC_OK == r)
+			{
+				break;
+			}
+			else
+			{
+				AVL_DVBSx_IBSP_Delay(10);
+			}
+		}
+	}
+	return (r);
+}
+
+static void AVL_Set_LPF(struct AVL_Tuner * pTuner)
+{	
+	struct AVL_Demod_Tuner_Configuration_t *pDemodTunerConfig = &g_DemodTuner_Config[g_nDemodTunerArrayIndex];
+
+	if (pDemodTunerConfig->m_LPF_Config_flag == InputSymbolRate)
+	{
+		pTuner->m_uiLPF_100kHz = pTuner->m_uiSymbolRate_Hz;
+	}
+	else
+	{
+		pTuner->m_uiLPF_100kHz = pTuner->m_uiSymbolRate_Hz*75/10000000+40;
+	}
+
+	if(pTuner->m_uiLPF_100kHz > pDemodTunerConfig->m_uiTunerMaxLPF_100Khz)
+	{
+		pTuner->m_uiLPF_100kHz = pDemodTunerConfig->m_uiTunerMaxLPF_100Khz;
+	}
+
+}
+
+AVL_DVBSx_ErrorCode AVL_Lock(struct AVL_DVBSx_Chip * pAVLChip,struct AVL_Tuner * pTuner,struct AVL_DVBSx_Channel * pChannel,AVL_uint16 * uiLockStatus)
+{	
+	AVL_DVBSx_ErrorCode r = AVL_DVBSx_EC_OK;
+	struct AVL_DVBSx_Channel Channel;
+	AVL_uint16 uiCounter;
+
+	pTuner->m_uiFrequency_100kHz = pChannel->m_uiFrequency_kHz/100;  
+	pTuner->m_uiSymbolRate_Hz = pChannel->m_uiSymbolRate_Hz;
+	AVL_Set_LPF(pTuner);
+	r = pTuner->m_pLockFunc(pTuner);
+
+	AVL_DVBSx_IBSP_Delay(50);		//Wait a while for tuner to lock in certain frequency.
+
+	Channel.m_uiSymbolRate_Hz = pChannel->m_uiSymbolRate_Hz;
+	Channel.m_Flags = (CI_FLAG_IQ_NO_SWAPPED) << CI_FLAG_IQ_BIT;	//Normal IQ
+	Channel.m_Flags |= (CI_FLAG_IQ_AUTO_BIT_AUTO) << CI_FLAG_IQ_AUTO_BIT;	//Enable automatic IQ swap detection
+	Channel.m_Flags |= (CI_FLAG_DVBS2_UNDEF) << CI_FLAG_DVBS2_BIT;			//Enable automatic standard detection
+
+	//This function should be called after tuner locked to lock the channel.
+	r |= AVL_DVBSx_IRx_LockChannel(&Channel, pAVLChip);  
+
+	//------------------------Check if Channel was locked-----------------------------
+	if(Channel.m_uiSymbolRate_Hz < 5000000)
+		uiCounter = 25;
+	else if(Channel.m_uiSymbolRate_Hz < 10000000)
+		uiCounter = 12;
+	else
+		uiCounter = 5;
+
+	do
+	{
+		AVL_DVBSx_IBSP_Delay(100);    //Wait 100ms for demod to lock the channel.
+
+		r = AVL_DVBSx_IRx_GetLockStatus(uiLockStatus, pAVLChip);
+
+		if ((AVL_DVBSx_EC_OK == r)&&(1 == *uiLockStatus))
+			break;
+	}while(--uiCounter);
+	//--------------------------------------------------------------------------------
+
+	return r;
+}
+
+void AVL_Display_TP_Info(struct AVL_DVBSx_Channel * pChannel, AVL_uint16 Channel_Num)
+{
+	AVL_uint16 i;
+	printf("\n\n");
+	for(i=0; i < Channel_Num; i++)
+	{
+		printf("Ch%2d: RF: %4d SR: %5d ",i+1, (pChannel[i].m_uiFrequency_kHz/1000),(pChannel[i].m_uiSymbolRate_Hz/1000));
+		switch((pChannel[i].m_Flags & CI_FLAG_DVBS2_BIT_MASK) >> CI_FLAG_DVBS2_BIT)
+		{
+		case CI_FLAG_DVBS:
+			printf("   DVBS ");
+			break;
+		case CI_FLAG_DVBS2:
+			printf("  DVBS2 ");
+			break;
+		case CI_FLAG_DVBS2_UNDEF:
+			printf("Unknown ");
+			break;
+		} 
+		switch((pChannel[i].m_Flags & CI_FLAG_IQ_BIT_MASK)>>CI_FLAG_IQ_BIT)
+		{
+		case CI_FLAG_IQ_NO_SWAPPED:
+			printf("Normal ");
+			break;
+		case CI_FLAG_IQ_SWAPPED:
+			printf("Invert ");
+			break;
+		}
+		printf("\n");
+	}	
+}
+
+AVL_DVBSx_ErrorCode Initialize(struct AVL_DVBSx_Chip * pAVLChip,struct AVL_Tuner * pTuner)
+{
+	struct AVL_DVBSx_Diseqc_Para sDiseqcPara;
+	struct AVL_DVBSx_MpegInfo sMpegMode;
+	AVL_DVBSx_ErrorCode r = AVL_DVBSx_EC_OK;
+	struct AVL_Demod_Tuner_Configuration_t *pDemodTunerConfig = &g_DemodTuner_Config[g_nDemodTunerArrayIndex];
+	struct AVL_DVBSx_VerInfo VerInfo;
+	//AVL_uint32 uiTemp;
+	AVL_uint32 uiDeviceID=0;
+
+#if 0  
+	//This function should be implemented by customer.
+	//This function should be called before all other functions to prepare everything for a BSP operation.
+	r = AVL_DVBSx_IBSP_Initialize();
+
+	if( AVL_DVBSx_EC_OK !=r )
+	{
+		printf("BSP Initialization failed !\n");
+		return (r);
+	}
+#endif
+
+	pAVLChip->m_uiBusId=pDemodTunerConfig->m_ChannelId;
+
+	// This function should be called after bsp initialized to initialize the chip object.
+	r = Init_AVL_DVBSx_ChipObject(pAVLChip, pDemodTunerConfig->m_uiDemodAddress);	
+	if( AVL_DVBSx_EC_OK !=r ) 
+	{
+		printf("Chip Object Initialization failed !\n");
+		return (r);
+	}
+
+	//Judge the chip ID of current chip.
+	r= AVL_DVBSx_IRx_GetDeviceID(  pAVLChip, &uiDeviceID);
+	//r = AVL_DVBSx_II2C_Read32(pAVLChip, rom_ver_addr, &uiTemp);
+	if (AVL_DVBSx_EC_OK != r)
+	{
+		printf("Get Chip ID failed !\n");
+		return (r);
+	}
+	//if ( uiTemp != Chip_ID )
+	if(uiDeviceID != Chip_ID )
+	{
+		printf("Chip ID isn't correct !\n");
+		return AVL_DVBSx_EC_GeneralFail;
+	}
+
+	//This function should be called after chip object initialized to initialize the IBase,using reference clock as 10M. Make sure you pickup the right pll_conf since it may be modified in BSP.
+	r = AVL_DVBSx_IBase_Initialize(&(pll_conf[pDemodTunerConfig->m_DemodReferenceClk]), ucPatchData, pAVLChip); 
+	if( AVL_DVBSx_EC_OK !=r ) 
+	{
+		printf("IBase Initialization failed !\n");
+		return (r);
+	}
+	AVL_DVBSx_IBSP_Delay(100);	  //Wait 100 ms to assure that the AVL_DVBSx chip boots up.This function should be implemented by customer.
+
+	//This function should be called to verify the AVL_DVBSx chip has completed its initialization procedure.
+	r = AVL_DVBSx_IBase_GetStatus(pAVLChip);
+	if( AVL_DVBSx_EC_OK != r )       
+	{
+		printf("Booted failed !\n");
+		return (r);
+	}
+	printf("Booted !\n");
+
+	//Get Chip ID, Patch version and SDK version.
+	AVL_DVBSx_IBase_GetVersion( &VerInfo, pAVLChip);
+	printf("Chip Ver:{%d}.{%d}.{%d}  API Ver:{%d}.{%d}.{%d}  Patch Ver:{%d}.{%d}.{%d} \n", 
+		VerInfo.m_Chip.m_Major, VerInfo.m_Chip.m_Minor, VerInfo.m_Chip.m_Build, 
+		VerInfo.m_API.m_Major, VerInfo.m_API.m_Minor, VerInfo.m_API.m_Build, 
+		VerInfo.m_Patch.m_Major, VerInfo.m_Patch.m_Minor, VerInfo.m_Patch.m_Build);	
+
+	//This function should be called after IBase initialized to initialize the demod.
+	r = AVL_DVBSx_IRx_Initialize(pAVLChip);
+	if(AVL_DVBSx_EC_OK != r)
+	{
+		printf("Demod Initialization failed !\n");
+		return (r);
+	}
+
+	//This function should be called after demod initialized to set RF AGC polar.
+	//User does not need to setup this for Sharp tuner since it is the default value. But for other tuners, user may need to do it here.
+	r |= AVL_DVBSx_IRx_SetRFAGCPola(pDemodTunerConfig->m_TunerRFAGC, pAVLChip);
+	r |= AVL_DVBSx_IRx_DriveRFAGC(pAVLChip);
+
+	if(AVL_DVBSx_EC_OK != r)
+	{
+		printf("Set RF AGC Polar failed !\n");
+		return (r);
+	}
+
+	//This function should be called after demod initialized to set spectrum polar.
+	r = AVL_DVBSx_IBase_SetSpectrumPolarity(pDemodTunerConfig->m_Tuner_IQ_SpectrumMode, pAVLChip);
+	if(AVL_DVBSx_EC_OK != r)
+	{
+		printf("Set Spectrum Polar failed !\n");
+		return (r);
+	}
+
+	//Setup MPEG mode parameters.
+	sMpegMode.m_MpegFormat = pDemodTunerConfig->m_TSFormat;
+	sMpegMode.m_MpegMode = pDemodTunerConfig->m_TSOutPutMode;
+	sMpegMode.m_MpegClockPolarity = pDemodTunerConfig->m_TSClockPolarity;
+
+	//This function should be called after demod initialized to set MPEG mode.(These parameters will be valid after call lock channel function)
+	r = AVL_DVBSx_IRx_SetMpegMode(&sMpegMode,pAVLChip );
+
+	if(sMpegMode.m_MpegMode == AVL_DVBSx_MPM_Serial)
+	{
+		AVL_DVBSx_IRx_SetMpegSerialPin(pAVLChip,pDemodTunerConfig->m_SerDataPin);
+	}
+	if(AVL_DVBSx_EC_OK != r)
+	{
+		printf("Set MPEG output mode failed !\n");
+		return (r);
+	}
+
+	// Enable the MPEG output (this function call has no effect for the AVL_DVBSxLG and AVL_DVBSxLGa devices)
+	r = AVL_DVBSx_IRx_DriveMpegOutput(pAVLChip);
+
+	//Setup tuner parameters for tuner initialization.
+	pTuner->m_uiSlaveAddress = pDemodTunerConfig->m_uiTunerAddress;
+	pTuner->m_uiI2CBusClock_kHz = pDemodTunerConfig->m_uiTuner_I2Cbus_clock;
+	pTuner->m_pParameters = 0;
+	pTuner->m_pAVLChip = pAVLChip;
+	pTuner->m_pInitializeFunc = pDemodTunerConfig->m_pInitializeFunc;
+	pTuner->m_pLockFunc = pDemodTunerConfig->m_pLockFunc;
+	pTuner->m_pGetLockStatusFunc = pDemodTunerConfig->m_pGetLockStatusFunc;
+
+	//This function should be called after IBase initialized to initialize the tuner.
+	r = pTuner->m_pInitializeFunc(pTuner);
+	if(AVL_DVBSx_EC_OK != r)
+	{
+		printf("Tuner Initialization failed !\n");
+		return (r);
+	}
+
+	//Setup DiSEqC parameters for DiSEqC initialization.
+	sDiseqcPara.m_RxTimeout = AVL_DVBSx_DRT_150ms;
+	sDiseqcPara.m_RxWaveForm = AVL_DVBSx_DWM_Normal;
+	sDiseqcPara.m_ToneFrequency_kHz = Diseqc_Tone_Frequency;		
+	sDiseqcPara.m_TXGap = AVL_DVBSx_DTXG_15ms;
+	sDiseqcPara.m_TxWaveForm = AVL_DVBSx_DWM_Normal;
+
+	//The DiSEqC should be initialized if AVL_DVBSx need to supply power to LNB. This function should be called after IBase initialized to initialize the DiSEqC.
+	r = AVL_DVBSx_IDiseqc_Initialize(&sDiseqcPara, pAVLChip);
+	if(AVL_DVBSx_EC_OK != r)
+	{
+		printf("DiSEqC Initialization failed !\n");
+	}
+
+	return (r);
+}
+
+AVL_DVBSx_ErrorCode BlindScan(void)
+{
+	AVL_DVBSx_ErrorCode r = AVL_DVBSx_EC_OK;
+	AVL_uint16	index = 0;
+	struct AVL_DVBSx_Channel * pChannel;
+	AVL_uchar HandIndex = 0;
+	struct AVL_DVBSx_Chip * pAVLChip = &g_stAvlDVBSxChip[HandIndex];
+	struct AVL_Tuner * pTuner = &g_stTuner[HandIndex];
+	struct AVL_DVBSx_BlindScanAPI_Setting BSsetting;
+	enum AVL_DVBSx_BlindScanAPI_Status BS_Status;
+	struct AVL_DVBSx_BlindScanAPI_Setting * pBSsetting = &BSsetting;
+	struct AVL_Demod_Tuner_Configuration_t *pDemodTunerConfig = &g_DemodTuner_Config[g_nDemodTunerArrayIndex];
+	BS_Status = AVL_DVBSx_BS_Status_Init;
+
+	//This function do all the initialization work.It should be called only once at the beginning.It needn't be recalled when we want to lock a new channel.
+	r = Initialize(pAVLChip,pTuner);
+	if(AVL_DVBSx_EC_OK != r)
+	{
+		printf("Initialization failed !\n");
+		return (r);
+	}
+	printf("Initialization success !\n");
+
+	while(BS_Status != AVL_DVBSx_BS_Status_Exit)
+	{
+		switch(BS_Status)
+		{
+		case AVL_DVBSx_BS_Status_Init:			{
+												AVL_DVBSx_IBlindScanAPI_Initialize(pBSsetting);//this function set the parameters blind scan process needed.	
+
+												AVL_DVBSx_IBlindScanAPI_SetFreqRange(pBSsetting, bs_start_freq, bs_stop_freq); //Default scan rang is from 950 to 2150. User may call this function to change scan frequency rang.
+												AVL_DVBSx_IBlindScanAPI_SetScanMode(pBSsetting, Blindscan_Mode);
+
+												AVL_DVBSx_IBlindScanAPI_SetSpectrumMode(pBSsetting, pDemodTunerConfig->m_Tuner_IQ_SpectrumMode); //Default set is AVL_DVBSx_Spectrum_Normal, it must be set correctly according Board HW configuration
+												AVL_DVBSx_IBlindScanAPI_SetMaxLPF(pBSsetting, pDemodTunerConfig->m_uiTunerMaxLPF_100Khz); //Set Tuner max LPF value, this value will difference according tuner type
+
+												BS_Status = AVL_DVBSx_BS_Status_Start;
+												break;
+											}
+
+		case AVL_DVBSx_BS_Status_Start:		{													
+												r = AVL_DVBSx_IBlindScanAPI_Start(pAVLChip, pTuner, pBSsetting);
+												if(AVL_DVBSx_EC_OK != r)
+												{
+													BS_Status = AVL_DVBSx_BS_Status_Exit;
+												}
+												BS_Status = AVL_DVBSx_BS_Status_Wait;
+												break;
+											}
+
+		case AVL_DVBSx_BS_Status_Wait: 		{
+												r = AVL_DVBSx_IBlindScanAPI_GetCurrentScanStatus(pAVLChip, pBSsetting);
+												if(AVL_DVBSx_EC_GeneralFail == r)
+												{
+													BS_Status = AVL_DVBSx_BS_Status_Exit;
+												}
+												if(AVL_DVBSx_EC_OK == r)
+												{
+													BS_Status = AVL_DVBSx_BS_Status_Adjust;
+												}
+												if(AVL_DVBSx_EC_Running == r)
+												{
+													AVL_DVBSx_IBSP_Delay(100);
+												}
+												break;
+											}
+
+		case AVL_DVBSx_BS_Status_Adjust:		{
+												r = AVL_DVBSx_IBlindScanAPI_Adjust(pAVLChip, pBSsetting);
+												if(AVL_DVBSx_EC_OK != r)
+												{
+													BS_Status = AVL_DVBSx_BS_Status_Exit;
+												}
+												BS_Status = AVL_DVBSx_BS_Status_User_Process;
+												break;
+											}
+
+		case AVL_DVBSx_BS_Status_User_Process:	{
+												//------------Custom code start-------------------
+												//customer can add the callback function here such as adding TP information to TP list or lock the TP for parsing PSI
+												//Add custom code here; Following code is an example
+
+												/*----- example 1: print Blindscan progress ----*/
+												printf(" %2d%% \n", AVL_DVBSx_IBlindscanAPI_GetProgress(pBSsetting)); //display progress Percent of blindscan process
+
+												/*----- example 2: print TP information if found valid TP ----*/
+												while(index < pBSsetting->m_uiChannelCount) //display new TP info found in current stage
+												{
+													pChannel = &pBSsetting->channels[index++];
+													printf("      Ch%2d: RF: %4d SR: %5d ",index, (pChannel->m_uiFrequency_kHz/1000),(pChannel->m_uiSymbolRate_Hz/1000));
+
+												#if 0 //Lock signal for testing
+													AVL_uint16 uiLockStatus = 0;
+													struct AVL_DVBSx_Channel channel;
+
+													channel.m_uiFrequency_kHz = pChannel->m_uiFrequency_kHz;
+													channel.m_uiSymbolRate_Hz = pChannel->m_uiSymbolRate_Hz;
+
+													AVL_Lock(pAVLChip, pTuner, &channel, &uiLockStatus);
+													if(uiLockStatus)
+														printf("Locked!");
+													else		
+														printf("Unlock!");
+												#endif
+													printf("\n");
+												}													
+												index = pBSsetting->m_uiChannelCount;
+
+												/*----- example 3: Break blindscan process when check key pressed ----*/
+												#if 0
+												if ( _kbhit() ) // demonstrate blindscan exit while process status machine is running
+												{
+													if( _getch() == 'e' )
+													{
+														printf("Exit by user.\n");
+														BS_Status = Blindscan_Status_Cancel;
+														break;
+													}
+												}
+												#endif
+												//------------Custom code end -------------------
+
+												if ( (AVL_DVBSx_IBlindscanAPI_GetProgress(pBSsetting) < 100))
+													BS_Status = AVL_DVBSx_BS_Status_Start;
+												else											
+													BS_Status = AVL_DVBSx_BS_Status_Cancel;
+												break;
+											}
+
+		case AVL_DVBSx_BS_Status_Cancel:		{ 
+												r = AVL_DVBSx_IBlindScanAPI_Exit(pAVLChip,pBSsetting);
+												BS_Status = AVL_DVBSx_BS_Status_Exit;
+												break;
+											}
+
+		default:						    {
+												BS_Status = AVL_DVBSx_BS_Status_Cancel;
+												break;
+											}
+		}
+	}
+
+	//print all of the TP info found in blindscan process. this isn't necessary for the customer
+	AVL_Display_TP_Info(pBSsetting->channels,pBSsetting->m_uiChannelCount);
+
+	//-------------------------Blindscan Band Process End------------------------
+	return (r);
+
+}
diff -Naur a/drivers/amlogic/dvb_tv/avl6211/src/DiSEqC_source.c b/drivers/amlogic/dvb_tv/avl6211/src/DiSEqC_source.c
--- a/drivers/amlogic/dvb_tv/avl6211/src/DiSEqC_source.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/amlogic/dvb_tv/avl6211/src/DiSEqC_source.c	2014-12-11 16:13:50.437614960 +0100
@@ -0,0 +1,452 @@
+/*
+ *           Copyright 2012 Availink, Inc.
+ *
+ *  This software contains Availink proprietary information and
+ *  its use and disclosure are restricted solely to the terms in
+ *  the corresponding written license agreement. It shall not be 
+ *  disclosed to anyone other than valid licensees without
+ *  written permission of Availink, Inc.
+ *
+ */
+
+
+///$Date: 2012-2-9 17:36 $
+///
+//#include "stdio.h"
+#include "IBSP.h"
+#include "avl_dvbsx.h"
+#include "IBase.h"
+#include "IRx.h"
+#include "II2C.h"
+#include "IDiseqc.h"
+#include "DiSEqC_source.h"
+
+extern AVL_uchar ucPatchData[];			//defined in AVL6211_patch.dat.cpp
+static 	struct AVL_DVBSx_Chip AVL_DVBSxChip;
+#define Chip_ID					0x0F //0x01000002		//The Chip ID of AVL6211.
+#define DiSEqC_Tone_Frequency   22              // The DiSEqC bus speed in the unit of kHz. Normally, it should be 22kHz. 
+#define EAST 0
+#define WEST 1
+
+/*void AVL_DVBSx_Error_Dispose(AVL_DVBSx_ErrorCode r)
+{
+    switch(r)
+	{
+	    case AVL_DVBSx_EC_OK:
+		    printf("AVL_DVBSx_EC_OK !\n");
+			break;
+	    case AVL_DVBSx_EC_GeneralFail:
+			printf("AVL_DVBSx_EC_GeneralFail !\n");
+			break;
+		case AVL_DVBSx_EC_I2CFail:
+			printf("AVL_DVBSx_EC_I2CFail !\n");
+			break;
+		case AVL_DVBSx_EC_TimeOut:
+			printf("AVL_DVBSx_EC_TimeOut !\n");
+			break;
+		case AVL_DVBSx_EC_Running:
+			printf("AVL_DVBSx_EC_Running !\n");
+			break;
+		case AVL_DVBSx_EC_InSleepMode:
+			printf("AVL_DVBSx_EC_InSleepMode !\n");
+			break; 		
+		case AVL_DVBSx_EC_MemoryRunout:
+			printf("AVL_DVBSx_EC_MemoryRunout !\n");
+			break;
+		case AVL_DVBSx_EC_BSP_ERROR1:
+			printf("AVL_DVBSx_EC_BSP_ERROR1 !\n");
+			break;
+		case AVL_DVBSx_EC_BSP_ERROR2:
+			printf("AVL_DVBSx_EC_BSP_ERROR2 !\n");
+			break;
+	}
+}*/
+AVL_DVBSx_ErrorCode AVL6211_22K_Control(AVL_uchar OnOff)
+{
+	AVL_DVBSx_ErrorCode r=AVL_DVBSx_EC_OK;
+	struct  AVL_DVBSx_Chip * pAVLChip  = &AVL_DVBSxChip;  
+	if(OnOff)
+	{
+		r=AVL_DVBSx_IDiseqc_StartContinuous(pAVLChip);
+	}else{
+		r=AVL_DVBSx_IDiseqc_StopContinuous(pAVLChip);
+	}
+	if(r!=AVL_DVBSx_EC_OK)
+	{
+		printf("[AVL6211_22K_Control] Err:0x%x\n",r);
+	}	
+	return r;
+}
+AVL_DVBSx_ErrorCode AVL6211_SetToneOut(AVL_uchar ucTone)
+{
+	AVL_DVBSx_ErrorCode r=AVL_DVBSx_EC_OK;
+	struct AVL_DVBSx_Diseqc_TxStatus TxStatus;
+	struct AVL_DVBSx_Chip * pAVLChip = &AVL_DVBSxChip;
+	AVL_DVBSx_IDiseqc_SendTone( ucTone, 1, pAVLChip);
+	if(r != AVL_DVBSx_EC_OK)
+	{
+		printf("AVL_DVBSx_IDiseqc_SendTone failed !\n");
+	}
+	else
+	{
+		do
+		{
+			r= AVL_DVBSx_IDiseqc_GetTxStatus(&TxStatus, pAVLChip);
+		}while(TxStatus.m_TxDone != 1);
+		if(r ==AVL_DVBSx_EC_OK )
+		{
+
+		}
+		else
+		{
+			printf("AVL_DVBSx_IDiseqc_SendTone Err. !\n");
+		}
+	}
+	return r;
+	
+}
+void AVL6211_DiseqcSendCmd(AVL_puchar pCmd,AVL_uchar CmdSize)
+{
+	AVL_DVBSx_ErrorCode r=AVL_DVBSx_EC_OK;
+	struct AVL_DVBSx_Diseqc_TxStatus TxStatus;
+	struct AVL_DVBSx_Chip * pAVLChip = &AVL_DVBSxChip;
+	
+	r=AVL_DVBSx_IDiseqc_SendModulationData(pCmd, CmdSize, pAVLChip);
+	if(r != AVL_DVBSx_EC_OK)
+	{
+		printf("AVL_DVBSx_IDiseqc_SendModulationData failed !\n");
+	}
+	else
+	{
+		do
+		{
+			r= AVL_DVBSx_IDiseqc_GetTxStatus(&TxStatus, pAVLChip);
+		}while(TxStatus.m_TxDone != 1);
+		if(r ==AVL_DVBSx_EC_OK )
+		{
+
+		}
+		else
+		{
+			printf("AVL_DVBSx_IDiseqc_SendModulationData Err. !\n");
+		}		
+	}
+}
+
+
+AVL_DVBSx_ErrorCode AVL6211_LNB_PIO_Control(AVL_char nPIN_Index,AVL_char nValue)
+{
+	struct AVL_DVBSx_Chip * pAVLChip = &AVL_DVBSxChip;
+	AVL_DVBSx_ErrorCode r=AVL_DVBSx_EC_OK;
+	if(nPIN_Index == LNB1_PIN_60)
+	{
+		if(nValue)
+			r=AVL_DVBSx_IDiseqc_SetLNB1Out(1,pAVLChip);//set LNB1_PIN60 1: Hight 
+		else
+			r=AVL_DVBSx_IDiseqc_SetLNB1Out(0,pAVLChip);	//set LNB1_PIN60 1: Low 
+	}
+	else if(nPIN_Index == LNB0_PIN_59)
+	{
+		if(nValue)
+			r=AVL_DVBSx_IDiseqc_SetLNBOut(1,pAVLChip);//set LNB0_PIN59 1: Hight 
+		else
+			r=AVL_DVBSx_IDiseqc_SetLNBOut(0,pAVLChip);	//set LNB0_PIN59 1: Low 
+	}		
+
+	if(r!=AVL_DVBSx_EC_OK)
+	{
+		printf("[AVL6211_LNB_PIO_Control] set nPIN_Index:0x%x,Err\n",r);
+	}
+	return r;
+}
+#if 0
+AVL_DVBSx_ErrorCode Initialize(struct AVL_DVBSx_Chip * pAVLChip)
+{
+    struct AVL_DVBSx_Diseqc_Para sDiseqcPara;
+	AVL_DVBSx_ErrorCode r=AVL_DVBSx_EC_OK;
+	struct AVL_DVBSx_VerInfo VerInfo;
+	//AVL_uint32 uiTemp;
+	AVL_uint32 uiDeviceID=0;
+/* 
+	//This function should be implemented by customer.
+	//This function should be called before all other functions to prepare everything for a BSP operation.
+	r = AVL_DVBSx_IBSP_Initialize();
+	if( AVL_DVBSx_EC_OK !=r )
+	{
+		printf("BSP Initialization failed !\n");
+		return (r);
+	}
+*/
+
+    // This function should be called after bsp initialized to initialize the chip object.
+    r = Init_AVL_DVBSx_ChipObject(pAVLChip, AVL_DVBSx_SA_0);	
+	if( AVL_DVBSx_EC_OK !=r ) 
+	{
+		printf("Chip Object Initialization failed !\n");
+		return (r);
+	}
+
+	//Judge the chip ID of current chip.
+	r= AVL_DVBSx_IRx_GetDeviceID(  pAVLChip, &uiDeviceID);
+	//r = AVL_DVBSx_II2C_Read32(pAVLChip, rom_ver_addr, &uiTemp);
+	if (AVL_DVBSx_EC_OK != r)
+	{
+		printf("Get Chip ID failed !\n");
+		return (r);
+	}
+	//if ( uiTemp != Chip_ID )
+	if(uiDeviceID != Chip_ID )
+	{
+		printf("uiDeviceID:0x%x,Chip ID isn't correct!\n",uiDeviceID);
+		return AVL_DVBSx_EC_GeneralFail;
+	}
+
+
+    //This function should be called after chip object initialized to initialize the IBase,using reference clock as 10M. Make sure you pickup the right pll_conf since it may be modified in BSP.
+	r = AVL_DVBSx_IBase_Initialize(const_cast<AVL_DVBSx_PllConf *>(pll_conf+2), ucPatchData, pAVLChip); 
+	if( AVL_DVBSx_EC_OK !=r ) 
+	{
+		printf("IBase Initialization failed !\n");
+		return (r);
+	}
+	AVL_DVBSx_IBSP_Delay(100);	  //Wait 100 ms to assure that the AVLDVBSx chip boots up.This function should be implemented by customer.
+  
+	//This function should be called to verify the AVLDVBSx chip has completed its initialization procedure.
+    r = AVL_DVBSx_IBase_GetStatus(pAVLChip);
+	if( AVL_DVBSx_EC_OK != r )       
+	{
+		printf("Booted failed !\n");
+		return (r);
+	}
+    printf("Booted !\n");
+
+	//Get Chip ID, Patch version and SDK version.
+	AVL_DVBSx_IBase_GetVersion( &VerInfo, pAVLChip);
+	printf("Chip Ver:{%d}.{%d}.{%d}  API Ver:{%d}.{%d}.{%d}  Patch Ver:{%d}.{%d}.{%d} \n", 
+		VerInfo.m_Chip.m_Major, VerInfo.m_Chip.m_Minor, VerInfo.m_Chip.m_Build, 
+		VerInfo.m_API.m_Major, VerInfo.m_API.m_Minor, VerInfo.m_API.m_Build, 
+		VerInfo.m_Patch.m_Major, VerInfo.m_Patch.m_Minor, VerInfo.m_Patch.m_Build);	
+
+    //This function should be called after IBase initialized to initialize the demod.
+	r = AVL_DVBSx_IRx_Initialize(pAVLChip);
+	if(AVL_DVBSx_EC_OK != r)
+	{
+		printf("Demod Initialization failed !\n");
+		return (r);
+	}
+
+	//This function should be called after demod initialized to set RF AGC polar.
+	//User does not need to setup this for Sharp tuner since it is the default value. But for other tuners, user may need to do it here.
+	r |= AVL_DVBSx_IRx_SetRFAGCPola(AVL_DVBSx_RA_Invert, pAVLChip);
+	r |= AVL_DVBSx_IRx_DriveRFAGC(pAVLChip);
+
+	if(AVL_DVBSx_EC_OK != r)
+	{
+		printf("Set RF AGC Polar failed !\n");
+		return (r);
+	}
+
+	//This function should be called after demod initialized to set spectrum polar.
+	r = AVL_DVBSx_IBase_SetSpectrumPolarity(AVL_DVBSx_Spectrum_Normal, pAVLChip);
+	if(AVL_DVBSx_EC_OK != r)
+	{
+		printf("Set Spectrum Polar failed !\n");
+		return (r);
+	}
+
+    //Setup DiSEqC parameters for DiSEqC initialization.
+	sDiseqcPara.m_RxTimeout = AVL_DVBSx_DRT_150ms;
+	sDiseqcPara.m_RxWaveForm = AVL_DVBSx_DWM_Normal;
+	sDiseqcPara.m_ToneFrequency_kHz = DiSEqC_Tone_Frequency;		
+	sDiseqcPara.m_TXGap = AVL_DVBSx_DTXG_15ms;
+	sDiseqcPara.m_TxWaveForm = AVL_DVBSx_DWM_Normal;
+
+	//This function should be called after IBase initialized to initialize the DiSEqC.
+	r = AVL_DVBSx_IDiseqc_Initialize(&sDiseqcPara, pAVLChip);
+	if(AVL_DVBSx_EC_OK != r)
+	{
+		printf("DiSEqC Initialization failed !\n");
+	}
+
+
+	return (r);
+}
+
+AVL_DVBSx_ErrorCode DiSEqC(void)
+{
+	struct AVL_DVBSx_Diseqc_TxStatus sTxStatus;
+	struct AVL_DVBSx_Diseqc_RxStatus sRxStatus;
+	AVL_DVBSx_ErrorCode r = AVL_DVBSx_EC_OK;
+	AVL_uchar ucData[8];
+	AVL_uchar i,i1;
+
+	struct AVL_DVBSx_Chip * pAVLChip = &AVL_DVBSxChip;
+
+    //This function do all the initialization work. It should be called only once at the beginning.
+	r = Initialize(pAVLChip);
+	if(AVL_DVBSx_EC_OK != r)
+	{
+		printf("Initialization failed !\n");
+		return (r);
+	}
+	printf("Initialization success !\n");	
+
+/*PIN 59/60 I/O Control exmples*/
+	r=AVL6211_LNB_PIO_Control(LNB0_PIN_59,1);
+	if(r== AVL_DVBSx_EC_OK)
+	{
+		printf("Set PIO 59 to 1,OK\n");
+	}
+       AVL_DVBSx_IBSP_Delay(1000);	 
+	r=AVL6211_LNB_PIO_Control(LNB0_PIN_59,0);	
+	if(r== AVL_DVBSx_EC_OK)
+	{
+		printf("Set PIO 59 to 0,OK\n");
+	}
+	AVL_DVBSx_IBSP_Delay(1000);	 
+	r=AVL6211_LNB_PIO_Control(LNB1_PIN_60,1);
+	if(r== AVL_DVBSx_EC_OK)
+	{
+		printf("Set PIO 60 to 1,OK\n");
+	}
+	  AVL_DVBSx_IBSP_Delay(100);	 
+	r=AVL6211_LNB_PIO_Control(LNB1_PIN_60,0);
+	if(r== AVL_DVBSx_EC_OK)
+	{
+		printf("Set PIO 60 to 0,OK\n");
+	}
+	AVL_DVBSx_IBSP_Delay(1000);	
+
+//22K Control examples
+	r=AVL6211_22K_Control(1);
+	if(r== AVL_DVBSx_EC_OK)
+	{
+		printf("Set 22K On,OK\n");
+	}
+	AVL_DVBSx_IBSP_Delay(1000);
+	r=AVL6211_22K_Control(0);
+	if(r== AVL_DVBSx_EC_OK)
+	{
+		printf("Set 22K Off,OK\n");
+	}
+	AVL_DVBSx_IBSP_Delay(1000);	
+//Send the tone burst command	
+	r=AVL6211_SetToneOut(1);
+	if(r== AVL_DVBSx_EC_OK)
+	{
+		printf("Send ToneBurst 1,OK\n");
+	}
+	AVL_DVBSx_IBSP_Delay(1000);		
+	r=AVL6211_SetToneOut(0);
+	if(r== AVL_DVBSx_EC_OK)
+	{
+		printf("Send ToneBurst 0,OK\n");
+	}
+	AVL_DVBSx_IBSP_Delay(1000);	
+
+	//LNB switch control
+	ucData[0]=0xE0;
+	ucData[1]=0x10;
+	ucData[2]=0x38;
+	ucData[3]=0xF0;
+
+	AVL_uchar uPortBit=0; 
+	AVL_uchar uLNBPort = 1;
+
+	switch(uLNBPort) 
+	{ 
+		case 1: 
+			uPortBit=0;
+			break; 
+
+		case 2: 
+			uPortBit=0x04;
+			break; 
+
+		case 3:
+			uPortBit=0x08;
+			break; 
+
+		case 4:
+			uPortBit=0x0C;
+			break; 
+
+		default:
+			uPortBit=0; 
+			break; 
+
+	} 
+	ucData[3] += uPortBit; 
+
+    //This function can be called after initialization to send out 4 modulation bytes to select the LNB port if used the 1/4 LNB switch.
+	AVL6211_DiseqcSendCmd(ucData, 4);
+
+
+	//Positioner control one degree. 
+	ucData[0]=0xE0;
+	ucData[1]=0x31;
+	ucData[2]=0x68;
+	ucData[3]=0xFF;
+
+	AVL_uchar uDirection = EAST;
+	AVL_uchar uCommandByte;
+
+	switch(uDirection) 
+	{ 
+		case EAST: 
+			uCommandByte=0x68;       //Turn east
+			break; 
+
+		case WEST: 
+			uCommandByte=0x69;       //Turn west
+			break; 
+
+		default:
+			uCommandByte=0x68;
+			break; 
+
+	}
+
+	ucData[2] = uCommandByte; 
+	AVL6211_DiseqcSendCmd(ucData, 4);
+	
+	//Before receiving modulation data, we should send some request data first.
+	//Read input status. 
+	do
+	{
+		r = AVL_DVBSx_IDiseqc_GetRxStatus(&sRxStatus, pAVLChip);    //Get current status of the DiSEqC receiver.
+	}
+	while(1 != sRxStatus.m_RxDone);       //Wait until operation finished.
+	if(AVL_DVBSx_EC_OK != r)
+	{
+		printf("Read modulation bytes --- Fail!\n");
+	}
+	else
+	{
+	    if(0 != sRxStatus.m_RxFifoCount)      //Data received.
+	    {
+		    i = sRxStatus.m_RxFifoCount;
+			//This function can be called to read data back from the DiSEqC input FIFO when there are data received.
+		    r = AVL_DVBSx_IDiseqc_ReadModulationData(ucData, &i, pAVLChip);     
+            if(AVL_DVBSx_EC_OK == r)
+	        {
+		       printf("Received %u modulation bytes:",i);
+		       for(i1=0; i1<i; i1++)
+	           {
+		           printf("0x%x,", ucData[i1]);
+	           } 
+		       printf("\n");
+	        }
+	        else
+	        {
+		       printf("Read modulation data --- Fail!\n");
+	        }  
+	    }
+	    else
+	    {
+		    printf("There is no data in input FIFO.\n");
+	    }
+	}
+	return (r);
+}
+#endif
diff -Naur a/drivers/amlogic/dvb_tv/avl6211/src/ExtSharpBS2S7HZ6306.c b/drivers/amlogic/dvb_tv/avl6211/src/ExtSharpBS2S7HZ6306.c
--- a/drivers/amlogic/dvb_tv/avl6211/src/ExtSharpBS2S7HZ6306.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/amlogic/dvb_tv/avl6211/src/ExtSharpBS2S7HZ6306.c	2014-12-11 16:13:50.393615298 +0100
@@ -0,0 +1,319 @@
+/*
+ *           Copyright 2012 Availink, Inc.
+ *
+ *  This software contains Availink proprietary information and
+ *  its use and disclosure are restricted solely to the terms in
+ *  the corresponding written license agreement. It shall not be 
+ *  disclosed to anyone other than valid licensees without
+ *  written permission of Availink, Inc.
+ *
+ */
+
+
+///$Date: 2012-2-9 17:36 $
+///
+#include "SharpBS2S7HZ6306.h"
+#include "ExtSharpBS2S7HZ6306.h"
+#include "II2CRepeater.h"
+#include "IBSP.h"
+#include "II2C.h"
+#include "IBase.h"
+
+AVL_DVBSx_ErrorCode SharpBS2S7HZ6306Regs_SetLPF( AVL_uint16 uiLPF_10kHz, struct SharpBS2S7HZ6306_Registers * pTunerRegs )
+{
+	uiLPF_10kHz /=100;
+	if( uiLPF_10kHz <10 )
+	{
+		uiLPF_10kHz = 10;
+	}
+	if( uiLPF_10kHz>34 )
+	{
+		uiLPF_10kHz = 34;
+	}
+	pTunerRegs->m_ucLPF = (AVL_uchar)((uiLPF_10kHz-10)/2+3);
+	return(AVL_DVBSx_EC_OK);
+}
+
+AVL_DVBSx_ErrorCode SharpBS2S7HZ6306_SetBBGain( enum SharpBS2S7HZ6306_BBGain BBGain, struct SharpBS2S7HZ6306_Registers * pTunerRegs )
+{
+	pTunerRegs->m_ucRegData[0] &=  ~(0x3<<5);
+	pTunerRegs->m_ucRegData[0] |= ((AVL_uchar)(BBGain)<<5);
+	return(AVL_DVBSx_EC_OK);
+}
+
+AVL_DVBSx_ErrorCode SharpBS2S7HZ6306_SetChargePump( enum SharpBS2S7HZ6306_PumpCurrent Current, struct SharpBS2S7HZ6306_Registers * pTunerRegs )
+{
+	pTunerRegs->m_ucRegData[2] &= ~(0x3<<5);
+	pTunerRegs->m_ucRegData[2] |= ((AVL_uchar)(Current)<<5);
+	return(AVL_DVBSx_EC_OK);
+}
+
+AVL_DVBSx_ErrorCode SharpBS2S7HZ6306_SetFrequency(AVL_uint16 uiFrequency_100kHz, struct SharpBS2S7HZ6306_Registers * pTunerRegs)
+{
+	AVL_uint16 P, N, A, DIV;
+	if(  uiFrequency_100kHz<9500 )
+	{
+		return(AVL_DVBSx_EC_GeneralFail);
+	}
+	else if(  uiFrequency_100kHz<9860 )
+	{
+		pTunerRegs->m_ucRegData[3] &= ~(0x7<<5);
+		pTunerRegs->m_ucRegData[3] |= (0x5<<5);
+		P = 16;
+		DIV = 1;
+	}
+	else if( uiFrequency_100kHz<10730 )
+	{
+		pTunerRegs->m_ucRegData[3] &= ~(0x7<<5);
+		pTunerRegs->m_ucRegData[3] |= (0x6<<5);
+		P = 16;
+		DIV = 1;
+	}
+	else if( uiFrequency_100kHz<11540 )
+	{
+		pTunerRegs->m_ucRegData[3] &= ~(0x7<<5);
+		pTunerRegs->m_ucRegData[3] |= (0x7<<5);
+		P = 32;
+		DIV = 1;
+	}
+	else if( uiFrequency_100kHz<12910 )
+	{
+		pTunerRegs->m_ucRegData[3] &= ~(0x7<<5);
+		pTunerRegs->m_ucRegData[3] |= (0x1<<5);
+		P = 32;
+		DIV = 0;
+	}
+	else if( uiFrequency_100kHz<14470 )
+	{
+		pTunerRegs->m_ucRegData[3] &= ~(0x7<<5);
+		pTunerRegs->m_ucRegData[3] |= (0x2<<5);
+		P = 32;
+		DIV = 0;
+	}
+	else if( uiFrequency_100kHz<16150 )
+	{
+		pTunerRegs->m_ucRegData[3] &= ~(0x7<<5);
+		pTunerRegs->m_ucRegData[3] |= (0x3<<5);
+		P = 32;
+		DIV = 0;
+	}
+	else if( uiFrequency_100kHz<17910 )
+	{
+		pTunerRegs->m_ucRegData[3] &= ~(0x7<<5);
+		pTunerRegs->m_ucRegData[3] |= (0x4<<5);
+		P = 32;
+		DIV = 0;
+	}
+	else if( uiFrequency_100kHz<19720 )
+	{
+		pTunerRegs->m_ucRegData[3] &= ~(0x7<<5);
+		pTunerRegs->m_ucRegData[3] |= (0x5<<5);
+		P = 32;
+		DIV = 0;
+	}
+	else if( uiFrequency_100kHz<=21540 )
+	{
+		pTunerRegs->m_ucRegData[3] &= ~(0x7<<5);
+		pTunerRegs->m_ucRegData[3] |= (0x6<<5);
+		P = 32;
+		DIV = 0;
+	}
+	else
+	{
+		return(AVL_DVBSx_EC_GeneralFail);
+	}
+
+	A = (uiFrequency_100kHz/10)%P;
+	N = (uiFrequency_100kHz/10)/P;
+
+	pTunerRegs->m_ucRegData[3] &= ~(0x1<<4);
+	if( P==16 )
+	{
+		pTunerRegs->m_ucRegData[3] |= (0x1<<4);
+	}
+
+	pTunerRegs->m_ucRegData[3] &= ~(0x1<<1);
+	pTunerRegs->m_ucRegData[3] |= (AVL_uchar)(DIV<<1);
+
+	pTunerRegs->m_ucRegData[1] &= ~(0x1f<<0);
+	pTunerRegs->m_ucRegData[1] |= (AVL_uchar)(A<<0);
+
+	pTunerRegs->m_ucRegData[1] &= ~(0x7<<5);
+	pTunerRegs->m_ucRegData[1] |= (AVL_uchar)(N<<5);
+	pTunerRegs->m_ucRegData[0] &= ~(0x1f<<0);
+	pTunerRegs->m_ucRegData[0] |= (AVL_uchar)((N>>3)<<0);
+
+	return(AVL_DVBSx_EC_OK);
+}
+
+AVL_DVBSx_ErrorCode SharpBS2S7HZ6306_CommitSetting(const struct AVL_Tuner * pTuner , struct SharpBS2S7HZ6306_Registers * pTunerRegs )
+{
+	AVL_DVBSx_ErrorCode r;
+	pTunerRegs->m_ucRegData[0] &= 0x7f;
+	pTunerRegs->m_ucRegData[2] |= 0x80;
+
+	pTunerRegs->m_ucRegData[2] &= ~(0x7<<2);
+	pTunerRegs->m_ucRegData[3] &= ~(0x3<<2);
+
+	r = AVL_DVBSx_II2CRepeater_SendData((AVL_uchar)(pTuner->m_uiSlaveAddress), pTunerRegs->m_ucRegData, 4, pTuner->m_pAVLChip );
+	if( r != AVL_DVBSx_EC_OK )
+	{
+		return(r);
+	}
+	pTunerRegs->m_ucRegData[2] |= (0x1<<2);
+
+	r |= AVL_DVBSx_II2CRepeater_SendData((AVL_uchar)(pTuner->m_uiSlaveAddress), (pTunerRegs->m_ucRegData)+2, 1, pTuner->m_pAVLChip );
+	if( r != AVL_DVBSx_EC_OK )
+	{
+		return(r);
+	}
+	r |= AVL_DVBSx_IBSP_Delay(12);
+
+	r |= SharpBS2S7HZ6306Regs_SetLPF ((AVL_uint16)(pTuner->m_uiLPF_100kHz*10), pTunerRegs);
+	pTunerRegs->m_ucRegData[2] |= ((((pTunerRegs->m_ucLPF)>>1)&0x1)<<3); /* PD4 */
+	pTunerRegs->m_ucRegData[2] |= ((((pTunerRegs->m_ucLPF)>>0)&0x1)<<4); /* PD5 */
+	pTunerRegs->m_ucRegData[3] |= ((((pTunerRegs->m_ucLPF)>>3)&0x1)<<2); /* PD2 */
+	pTunerRegs->m_ucRegData[3] |= ((((pTunerRegs->m_ucLPF)>>2)&0x1)<<3); /* PD3 */
+
+	r |= AVL_DVBSx_II2CRepeater_SendData((AVL_uchar)(pTuner->m_uiSlaveAddress), (pTunerRegs->m_ucRegData)+2, 2, pTuner->m_pAVLChip );
+
+	return(r);
+}
+
+//*******************************************************************************************
+
+AVL_DVBSx_ErrorCode Initialize_Demod_RelatedTunerPart(struct AVL_Tuner * pTuner)
+{
+	AVL_DVBSx_ErrorCode r;
+	r = AVL_DVBSx_II2C_Write16(pTuner->m_pAVLChip, rc_tuner_slave_addr_addr, pTuner->m_uiSlaveAddress);
+	r |= AVL_DVBSx_II2C_Write16(pTuner->m_pAVLChip, rc_tuner_use_internal_control_addr, 0);
+	r |= AVL_DVBSx_II2C_Write16(pTuner->m_pAVLChip, rc_tuner_LPF_margin_100kHz_addr, 0);	//clean up the LPF margin for blind scan. for external driver, this must be zero.
+	r |= AVL_DVBSx_II2C_Write16(pTuner->m_pAVLChip, rc_tuner_max_LPF_100kHz_addr, 320);	//set up the right LPF for blind scan to regulate the freq_step. This field should corresponding the flat response part of the LPF.
+
+	r |= AVL_DVBSx_II2CRepeater_Initialize(pTuner->m_uiI2CBusClock_kHz, pTuner->m_pAVLChip);
+
+	return r;
+}
+
+AVL_DVBSx_ErrorCode ExtSharpBS2S7HZ6306_Initialize(struct AVL_Tuner * pTuner)
+{
+	AVL_DVBSx_ErrorCode r;
+
+	//Initialize the part of demodulator that related with the tuner. 
+	r = Initialize_Demod_RelatedTunerPart(pTuner);
+
+	//Initialize the Tuner.
+	//BS2S7HZ6306 not need initialize, if other tuners need initialize add the initialization code here.
+
+	return(r);
+}
+
+AVL_DVBSx_ErrorCode ExtSharpBS2S7HZ6306_GetLockStatus(struct AVL_Tuner * pTuner )
+{
+	AVL_DVBSx_ErrorCode r;
+	AVL_uint16 ucTemp;
+	r = AVL_DVBSx_II2CRepeater_ReadData((AVL_uchar)(pTuner->m_uiSlaveAddress), (AVL_puchar)(&ucTemp), 1, pTuner->m_pAVLChip );
+	if( AVL_DVBSx_EC_OK == r )
+	{
+
+		if( 0 == (ucTemp & 0x40) )
+		{
+			r = AVL_DVBSx_EC_GeneralFail ;
+		}
+	}
+	return(r);
+}
+
+static AVL_DVBSx_ErrorCode Frequency_LPF_Adjustment(struct AVL_Tuner * pTuner,AVL_uint16 *uiAdjustFreq)
+{
+	AVL_DVBSx_ErrorCode r;
+	AVL_uint32 uitemp1;
+	AVL_uint16 uitemp2;
+	AVL_uint16 minimum_LPF_100kHz;
+	AVL_uint16 carrierFrequency_100kHz;
+
+	r = AVL_DVBSx_II2C_Read32(pTuner->m_pAVLChip, 0x263E, &uitemp1);
+	r |= AVL_DVBSx_II2C_Read16(pTuner->m_pAVLChip, 0x2642, &uitemp2);
+	if(r != AVL_DVBSx_EC_OK)
+	{
+		 *uiAdjustFreq = pTuner->m_uiFrequency_100kHz;
+		 return r;
+	}
+
+	if(pTuner->m_uiSymbolRate_Hz <= uitemp1)
+	{
+		carrierFrequency_100kHz =(AVL_uint16 )((uitemp2/10)+ pTuner->m_uiFrequency_100kHz);
+
+		minimum_LPF_100kHz = (pTuner->m_uiSymbolRate_Hz/100000 )*135/200 +  (uitemp2/10) + 50;
+		if(pTuner->m_uiLPF_100kHz < minimum_LPF_100kHz)
+		{
+			pTuner->m_uiLPF_100kHz = (AVL_uint16 )(minimum_LPF_100kHz);
+		}
+	}
+	else
+	{
+		carrierFrequency_100kHz = pTuner->m_uiFrequency_100kHz;
+	}
+
+	*uiAdjustFreq = carrierFrequency_100kHz;
+
+	return AVL_DVBSx_EC_OK;
+
+}
+
+
+AVL_DVBSx_ErrorCode ExtSharpBS2S7HZ6306_Lock(struct AVL_Tuner * pTuner)
+{
+	AVL_DVBSx_ErrorCode r;
+	AVL_uint16 carrierFrequency_100kHz;
+
+	struct SharpBS2S7HZ6306_Registers TunerRegs;
+	struct SharpBS2S7HZ6306_TunerPara * pPara;
+
+	TunerRegs.m_ucRegData[0] = 0;
+	TunerRegs.m_ucRegData[1] = 0;
+	TunerRegs.m_ucRegData[2] = 0;
+	TunerRegs.m_ucRegData[3] = 0;
+
+
+	Frequency_LPF_Adjustment(pTuner, &carrierFrequency_100kHz);
+	
+	r = SharpBS2S7HZ6306_SetFrequency(carrierFrequency_100kHz, &TunerRegs );
+	if( 0 == pTuner->m_pParameters )	//use default values
+	{
+		r |= SharpBS2S7HZ6306_SetChargePump(PC_360_694_Sharp, &TunerRegs);
+		r |= SharpBS2S7HZ6306_SetBBGain(Bbg_4_Sharp, &TunerRegs);
+	}
+	else		//use custom value
+	{
+		pPara = (struct SharpBS2S7HZ6306_TunerPara *)(pTuner->m_pParameters);
+		r |= SharpBS2S7HZ6306_SetChargePump(pPara->m_ChargPump, &TunerRegs);
+		r |= SharpBS2S7HZ6306_SetBBGain(pPara->m_BBGain, &TunerRegs);
+	}
+	r |= SharpBS2S7HZ6306_CommitSetting(pTuner, &TunerRegs);
+	return(r);
+}
+
+AVL_DVBSx_ErrorCode ExtSharpBS2S7HZ6306_Check(struct AVL_Tuner * pTuner)
+{
+	AVL_DVBSx_ErrorCode r;
+
+	r = ExtSharpBS2S7HZ6306_Initialize(pTuner);
+	if (r != AVL_DVBSx_EC_OK)
+	{
+		return r;
+	}
+	AVL_DVBSx_IBSP_Delay(1);
+	r = ExtSharpBS2S7HZ6306_Lock(pTuner);
+	if (r != AVL_DVBSx_EC_OK)
+	{
+		return r;
+	}
+	AVL_DVBSx_IBSP_Delay(50);		//Wait a while for tuner to lock in certain frequency.
+	r = ExtSharpBS2S7HZ6306_GetLockStatus(pTuner);
+	if (r != AVL_DVBSx_EC_OK)
+	{
+		return r;
+	}
+	return AVL_DVBSx_EC_OK;
+}
diff -Naur a/drivers/amlogic/dvb_tv/avl6211/src/IBase.c b/drivers/amlogic/dvb_tv/avl6211/src/IBase.c
--- a/drivers/amlogic/dvb_tv/avl6211/src/IBase.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/amlogic/dvb_tv/avl6211/src/IBase.c	2014-12-11 16:13:50.457614809 +0100
@@ -0,0 +1,335 @@
+/*
+ *           Copyright 2012 Availink, Inc.
+ *
+ *  This software contains Availink proprietary information and
+ *  its use and disclosure are restricted solely to the terms in
+ *  the corresponding written license agreement. It shall not be 
+ *  disclosed to anyone other than valid licensees without
+ *  written permission of Availink, Inc.
+ *
+ */
+
+
+///$Date: 2012-2-9 17:36 $
+///
+#include "IBase.h"
+#include "II2C.h"
+#include "IBSP.h"
+#include "IRx.h"
+#include "ITuner.h"
+#include "II2CRepeater.h"
+#include "IBlindScan.h"
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_IBase_SetPLL(const struct AVL_DVBSx_PllConf * pPLLConf, struct AVL_DVBSx_Chip * pAVLChip )
+{
+	AVL_DVBSx_ErrorCode r = AVL_DVBSx_EC_OK;
+	printk("%s in \n",__FUNCTION__);
+	r = AVL_DVBSx_II2C_Write32(pAVLChip, pll_clkf_map_addr, pPLLConf->m_uiClkf);
+	r |= AVL_DVBSx_II2C_Write32(pAVLChip, pll_bwadj_map_addr, pPLLConf->m_uiClkf);
+	r |= AVL_DVBSx_II2C_Write32(pAVLChip, pll_clkr_map_addr, pPLLConf->m_uiClkr);
+	r |= AVL_DVBSx_II2C_Write32(pAVLChip, pll_od_map_addr, pPLLConf->m_uiPllod);
+	r |= AVL_DVBSx_II2C_Write32(pAVLChip, pll_od2_map_addr, pPLLConf->m_uiPllod2);
+	r |= AVL_DVBSx_II2C_Write32(pAVLChip, pll_od3_map_addr, pPLLConf->m_uiPllod3);
+	r |= AVL_DVBSx_II2C_Write32(pAVLChip, pll_softvalue_en_map_addr,   1);
+	r |= AVL_DVBSx_II2C_Write32(pAVLChip, reset_register_addr, 0);
+	AVL_DVBSx_II2C_Write32(pAVLChip, reset_register_addr, 1);  //this is a reset, do not expect an ACK from the chip.
+	pAVLChip->m_DemodFrequency_10kHz = pPLLConf->m_DmodFrequency_10kHz;
+	pAVLChip->m_FecFrequency_10kHz =  pPLLConf->m_FecFrequency_10kHz;
+	pAVLChip->m_MpegFrequency_10kHz = pPLLConf->m_MpegFrequency_10kHz;
+
+	return(r);
+}
+/// @endcond
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_IBase_DownloadFirmware(AVL_puchar pFirmwareData,  const struct AVL_DVBSx_Chip * pAVLChip)
+{
+	printk("%s in \n",__FUNCTION__);
+	AVL_uint32 uiSize, uiDataSize;
+	AVL_DVBSx_ErrorCode r = AVL_DVBSx_EC_OK;
+	AVL_uint32 i1;
+
+	r = AVL_DVBSx_II2C_Write32(pAVLChip, core_reset_b_reg, 0);
+
+	uiDataSize = DeChunk32(pFirmwareData);
+	i1 = 4;
+	while( i1 < uiDataSize )
+	{
+		uiSize = DeChunk32(pFirmwareData+i1);
+		i1 += 4;
+		r |= AVL_DVBSx_II2C_Write(pAVLChip, pFirmwareData+i1+1, (AVL_uint16)(uiSize+3));
+		i1 += 4 + uiSize;
+	}
+	r |= AVL_DVBSx_II2C_Write32(pAVLChip, 0x00000000, 0x00003ffc);
+	r |= AVL_DVBSx_II2C_Write16(pAVLChip, core_ready_word_addr, 0x0000);
+	r |= AVL_DVBSx_II2C_Write32(pAVLChip, error_msg_addr, 0x00000000);
+	r |= AVL_DVBSx_II2C_Write32(pAVLChip, error_msg_addr+4, 0x00000000);
+	 AVL_DVBSx_II2C_Write32(pAVLChip, core_reset_b_reg, 1);
+
+	return(r);
+}
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_IBase_GetStatus( struct AVL_DVBSx_Chip * pAVLChip )
+{
+	printk("%s in \n",__FUNCTION__);
+	AVL_DVBSx_ErrorCode r = AVL_DVBSx_EC_OK;
+	AVL_uint16 uiReadValue;
+	AVL_uint32 uiTemp;
+
+	r = AVL_DVBSx_II2C_Read32(pAVLChip, core_reset_b_reg, &uiTemp);
+	r |= AVL_DVBSx_II2C_Read16(pAVLChip, core_ready_word_addr, &uiReadValue);
+	if( (AVL_DVBSx_EC_OK == r) )
+	{
+		if( (0 == uiTemp) || (uiReadValue != 0xA55A) )
+		{
+			r = AVL_DVBSx_EC_GeneralFail;
+		}
+	}
+
+	return(r);
+}
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_IBase_GetVersion( struct AVL_DVBSx_VerInfo * pVerInfo, const struct AVL_DVBSx_Chip * pAVLChip )
+{
+	AVL_uint32 uiTemp;
+	AVL_uchar ucBuff[4];
+	AVL_DVBSx_ErrorCode r = AVL_DVBSx_EC_OK;
+
+	r =  AVL_DVBSx_II2C_Read32(pAVLChip, rom_ver_addr, &uiTemp);
+	if( AVL_DVBSx_EC_OK == r )
+	{
+		Chunk32(uiTemp, ucBuff);
+		pVerInfo->m_Chip.m_Major = ucBuff[0];
+		pVerInfo->m_Chip.m_Minor = ucBuff[1];
+		pVerInfo->m_Chip.m_Build = ucBuff[2];
+		pVerInfo->m_Chip.m_Build = ((AVL_uint16)((pVerInfo->m_Chip.m_Build)<<8)) + ucBuff[3];
+		r |=  AVL_DVBSx_II2C_Read32(pAVLChip, rc_patch_ver_addr, &uiTemp);
+		if( AVL_DVBSx_EC_OK == r )
+		{
+			Chunk32(uiTemp, ucBuff);
+			pVerInfo->m_Patch.m_Major = ucBuff[0];
+			pVerInfo->m_Patch.m_Minor = ucBuff[1];
+			pVerInfo->m_Patch.m_Build = ucBuff[2];
+			pVerInfo->m_Patch.m_Build = ((AVL_uint16)((pVerInfo->m_Patch.m_Build)<<8)) + ucBuff[3];
+
+			pVerInfo->m_API.m_Major = AVL_DVBSx_API_VER_MAJOR;
+			pVerInfo->m_API.m_Minor = AVL_DVBSx_API_VER_MINOR;
+			pVerInfo->m_API.m_Build = AVL_DVBSx_API_VER_BUILD;
+		}
+	}
+	return(r);
+}
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_IBase_Initialize( const struct AVL_DVBSx_PllConf * pPLLConf, AVL_puchar pInitialData,  struct AVL_DVBSx_Chip * pAVLChip )
+{	
+	AVL_DVBSx_ErrorCode r = AVL_DVBSx_EC_OK;
+
+	r |= AVL_DVBSx_IBase_SetPLL(pPLLConf, pAVLChip );
+	r |= AVL_DVBSx_IBSP_Delay(100);	  // this delay is critical 
+	r |= AVL_DVBSx_IBase_DownloadFirmware(pInitialData, pAVLChip);
+
+	return(r);
+}
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_IBase_Halt( struct AVL_DVBSx_Chip * pAVLChip )
+{
+	AVL_DVBSx_ErrorCode r = AVL_DVBSx_EC_OK;
+
+	r |= AVL_DVBSx_IBase_SendRxOP(OP_RX_HALT, pAVLChip);	
+
+	return(r);
+}
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_IBase_Sleep( struct AVL_DVBSx_Chip * pAVLChip )
+{
+	AVL_DVBSx_ErrorCode r = AVL_DVBSx_EC_OK;
+
+	r |= AVL_DVBSx_IBase_SendRxOP(OP_RX_SLEEP, pAVLChip);
+
+	return(r);
+}
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_IBase_Wake( struct AVL_DVBSx_Chip * pAVLChip )
+{
+	AVL_DVBSx_ErrorCode r = AVL_DVBSx_EC_OK;
+
+	r |= AVL_DVBSx_IBase_SendRxOP(OP_RX_WAKE, pAVLChip);
+
+	return(r);
+}
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_IBase_SetFunctionalMode(const struct AVL_DVBSx_Chip * pAVLChip, enum AVL_DVBSx_FunctionalMode enumFunctionalMode)
+{
+	AVL_DVBSx_ErrorCode r = AVL_DVBSx_EC_OK;
+
+	r = AVL_DVBSx_II2C_Write16(pAVLChip, rc_functional_mode_addr, (AVL_uint16)enumFunctionalMode);
+	if(enumFunctionalMode == AVL_DVBSx_FunctMode_Demod)
+	{
+		r |= AVL_DVBSx_II2C_Write16(pAVLChip, 0x2642, 400);
+
+	}
+	else if(enumFunctionalMode == AVL_DVBSx_FunctMode_BlindScan)
+	{
+		r |= AVL_DVBSx_II2C_Write16(pAVLChip, 0x2642, 0);
+	}
+	r |=AVL_DVBSx_II2C_Write16(pAVLChip, rc_iq_mode_addr,0);
+
+	return(r);
+}
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_IBase_GetFunctionalMode(enum AVL_DVBSx_FunctionalMode * pFunctionalMode,  const struct AVL_DVBSx_Chip * pAVLChip)
+{
+	AVL_DVBSx_ErrorCode r = AVL_DVBSx_EC_OK;	
+	AVL_uint16 uiTemp;
+
+	r = AVL_DVBSx_II2C_Read16(pAVLChip, rc_functional_mode_addr, &uiTemp);
+	*pFunctionalMode = (enum AVL_DVBSx_FunctionalMode)(uiTemp & 0x0001);	
+
+	return(r);
+}
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_IBase_SendRxOP(AVL_uchar ucOpCmd, struct AVL_DVBSx_Chip * pAVLChip )
+{
+/*	AVL_DVBSx_ErrorCode r = AVL_DVBSx_EC_OK;
+	AVL_uchar pucBuff[2];
+	AVL_uint16 uiTemp;
+	enum AVL_DVBSx_Sleep_Wake_Status sleep_wake_status;
+	const AVL_uint16 uiTimeDelay = 10;
+	AVL_uint16 uiMaxRetries = 20;
+
+	r = AVL_DVBSx_IBSP_WaitSemaphore(&(pAVLChip->m_semRx));
+	r |= AVL_DVBSx_IBase_GetChipStatus(&sleep_wake_status, pAVLChip);
+	if(r == AVL_DVBSx_EC_OK)
+	{
+		if(sleep_wake_status == AVL_DVBSx_Sleep_Mode)
+		{
+			if((ucOpCmd != OP_RX_WAKE) && (ucOpCmd != OP_RX_HALT) && (ucOpCmd != OP_RX_SLEEP))
+			{
+				AVL_DVBSx_IBSP_ReleaseSemaphore(&(pAVLChip->m_semRx));
+				r = AVL_DVBSx_EC_InSleepMode;
+				return(r);
+			}
+		}
+
+		do
+		{
+			r = AVL_DVBSx_IBase_GetRxOPStatus(pAVLChip);
+			if( AVL_DVBSx_EC_OK == r )
+			{
+				break;
+			}
+			AVL_DVBSx_IBSP_Delay(uiTimeDelay);
+			uiMaxRetries--;
+
+		}while(uiMaxRetries != 0);
+
+		if( AVL_DVBSx_EC_OK == r )
+		{
+			pucBuff[0] = 0;
+			pucBuff[1] = ucOpCmd;
+			uiTemp = DeChunk16(pucBuff);
+			r |= AVL_DVBSx_II2C_Write16(pAVLChip, rx_cmd_addr, uiTemp);   
+		}
+	}
+	r |= AVL_DVBSx_IBSP_ReleaseSemaphore(&(pAVLChip->m_semRx));
+
+	return(r);*/
+	AVL_DVBSx_ErrorCode r = AVL_DVBSx_EC_OK;
+	unsigned char pucBuff[2];
+	unsigned short uiTemp;
+
+	r |= AVL_DVBSx_IBase_GetRxOPStatus(pAVLChip);
+	if( AVL_DVBSx_EC_OK == r )
+	{
+		pucBuff[0] = 0;
+		pucBuff[1] = ucOpCmd;
+		uiTemp = DeChunk16(pucBuff);
+		r |= AVL_DVBSx_II2C_Write16(pAVLChip, rx_cmd_addr, uiTemp);   
+	}
+
+	return(r);
+
+}
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_IBase_GetRxOPStatus(const struct AVL_DVBSx_Chip * pAVLChip )
+{
+	AVL_DVBSx_ErrorCode r = AVL_DVBSx_EC_OK;
+	AVL_uchar pBuff[2] = {0,0};
+
+	r = AVL_DVBSx_II2C_Read(pAVLChip, rx_cmd_addr, pBuff, 2);
+	if( AVL_DVBSx_EC_OK == r )
+	{
+		if( 0 != pBuff[1] )
+		{
+			r = AVL_DVBSx_EC_Running;
+		}
+	}
+
+	return(r);
+}
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_IBase_SetGPIODir( AVL_uchar ucDir, const struct AVL_DVBSx_Chip * pAVLChip )
+{
+	AVL_DVBSx_ErrorCode r = AVL_DVBSx_EC_OK;
+	AVL_uint32 uiTemp = (AVL_uint32)(ucDir & 0x7);
+
+	r = AVL_DVBSx_II2C_Write32(pAVLChip, gpio_reg_enb, uiTemp);
+
+	return(r);
+}
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_IBase_SetGPIOVal( AVL_uchar ucVal, const struct AVL_DVBSx_Chip * pAVLChip )
+{
+	AVL_DVBSx_ErrorCode r = AVL_DVBSx_EC_OK;
+	AVL_uint32 uiTemp;
+	
+	uiTemp = (AVL_uint32)(ucVal & 0x7);
+	r = AVL_DVBSx_II2C_Write32(pAVLChip, gpio_data_reg_out, uiTemp);
+
+	return(r);
+}
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_IBase_GetGPIOVal( AVL_puchar pucVal, const struct AVL_DVBSx_Chip * pAVLChip )
+{
+	AVL_DVBSx_ErrorCode r = AVL_DVBSx_EC_OK;
+	AVL_uint32 uiTemp;
+
+	r = AVL_DVBSx_II2C_Read32(pAVLChip, gpio_data_in_to_reg, &uiTemp);
+	*pucVal = (AVL_uchar)uiTemp;
+	
+	return(r);
+}
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_IBase_GetChipStatus( enum AVL_DVBSx_Sleep_Wake_Status * pChipStatus, const struct AVL_DVBSx_Chip * pAVLChip )
+{
+	AVL_DVBSx_ErrorCode r = AVL_DVBSx_EC_OK;
+	AVL_uint16 uiStatus;
+
+	r = AVL_DVBSx_II2C_Read16(pAVLChip, rp_sleep_wake_status_addr, &uiStatus);
+	if( AVL_DVBSx_EC_OK == r )
+	{
+		if((enum AVL_DVBSx_Sleep_Wake_Status)(uiStatus) == AVL_DVBSx_Sleep_Mode)
+		{
+			*pChipStatus = AVL_DVBSx_Sleep_Mode;
+
+		}
+		else if((enum AVL_DVBSx_Sleep_Wake_Status)(uiStatus) == AVL_DVBSx_Wake_Mode)
+		{
+			*pChipStatus = AVL_DVBSx_Wake_Mode;
+		}
+		else
+		{
+			r = AVL_DVBSx_EC_GeneralFail;
+		}
+	}
+
+	return(r);
+}
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_IBase_SetSpectrumPolarity( enum AVL_DVBSx_SpectrumPolarity enumSpectrumPolarity, const struct AVL_DVBSx_Chip * pAVLChip )
+{
+	AVL_DVBSx_ErrorCode r;
+
+	r = AVL_DVBSx_II2C_Write16(pAVLChip, rc_blind_scan_tuner_spectrum_inversion_addr, (AVL_uint16)enumSpectrumPolarity);
+
+	return(r);
+}
diff -Naur a/drivers/amlogic/dvb_tv/avl6211/src/IBlindscanAPI.c b/drivers/amlogic/dvb_tv/avl6211/src/IBlindscanAPI.c
--- a/drivers/amlogic/dvb_tv/avl6211/src/IBlindscanAPI.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/amlogic/dvb_tv/avl6211/src/IBlindscanAPI.c	2014-12-11 16:13:50.289616089 +0100
@@ -0,0 +1,237 @@
+/*
+ *           Copyright 2012 Availink, Inc.
+ *
+ *  This software contains Availink proprietary information and
+ *  its use and disclosure are restricted solely to the terms in
+ *  the corresponding written license agreement. It shall not be 
+ *  disclosed to anyone other than valid licensees without
+ *  written permission of Availink, Inc.
+ *
+ */
+
+
+///$Date: 2012-2-9 17:36 $
+///
+#include "avl_dvbsx.h"
+#include "ITuner.h"
+#include "avl_dvbsx_globals.h"
+#include "IBSP.h"
+#include "IBase.h"
+#include "IRx.h"
+#include "II2C.h"
+#include "IBlindScan.h"
+#include "IBlindscanAPI.h"
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_IBlindScanAPI_Initialize(struct AVL_DVBSx_BlindScanAPI_Setting * pBSsetting)
+{		
+	pBSsetting->m_uiScan_Start_Freq_MHz = 950;     //Default Set Blind scan start frequency
+	pBSsetting->m_uiScan_Stop_Freq_MHz = 2150;     //Default Set Blind scan stop frequency
+	pBSsetting->m_uiScan_Next_Freq_100KHz = 10*pBSsetting->m_uiScan_Start_Freq_MHz;
+
+	pBSsetting->m_uiScan_Max_Symbolrate_MHz = 45;  //Set MAX symbol rate
+	pBSsetting->m_uiScan_Min_Symbolrate_MHz = 2;   //Set MIN symbol rate
+	
+	pBSsetting->m_uiTuner_MaxLPF_100kHz = 340;
+
+	pBSsetting->m_uiScan_Bind_No = 0;
+	pBSsetting->m_uiScan_Progress_Per = 0;
+	pBSsetting->m_uiChannelCount = 0;
+	
+	pBSsetting->m_eSpectrumMode = AVL_DVBSx_Spectrum_Normal;  //Set spectrum mode
+
+	pBSsetting->BS_Mode = AVL_DVBSx_BS_Fast_Mode; //1: Freq Step forward is 10MHz        0: Freq Step firmware is 20.7MHz
+	pBSsetting->m_uiScaning = 0;
+	pBSsetting->m_uiScan_Center_Freq_Step_100KHz = 100;  //only valid when scan_algorithmic set to 1 and would be ignored when scan_algorithmic set to 0.
+	printk("BS_Mode is %d(0-fast,1-slow)\n",pBSsetting->BS_Mode);
+	return AVL_DVBSx_EC_OK;
+}
+AVL_DVBSx_ErrorCode AVL_DVBSx_IBlindScanAPI_SetSpectrumMode(struct AVL_DVBSx_BlindScanAPI_Setting * pBSsetting, enum AVL_DVBSx_SpectrumPolarity SpectrumMode)
+{
+	pBSsetting->m_eSpectrumMode = SpectrumMode;
+	return AVL_DVBSx_EC_OK;
+}
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_IBlindScanAPI_SetScanMode(struct AVL_DVBSx_BlindScanAPI_Setting * pBSsetting, enum AVL_DVBSx_BlindScanAPI_Mode Scan_Mode)
+{
+	pBSsetting->BS_Mode = Scan_Mode;
+	return AVL_DVBSx_EC_OK;
+}
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_IBlindScanAPI_SetFreqRange(struct AVL_DVBSx_BlindScanAPI_Setting * pBSsetting,AVL_uint16 StartFreq_MHz,AVL_uint16 EndFreq_MHz)
+{
+//	pBSsetting->m_uiScan_Start_Freq_MHz = StartFreq_MHz;     //Change default start frequency
+//	pBSsetting->m_uiScan_Stop_Freq_MHz = EndFreq_MHz;        //Change default end frequency
+	pBSsetting->m_uiScan_Next_Freq_100KHz = 10*pBSsetting->m_uiScan_Start_Freq_MHz;
+	
+	return AVL_DVBSx_EC_OK;
+}
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_IBlindScanAPI_SetMaxLPF(struct AVL_DVBSx_BlindScanAPI_Setting * pBSsetting ,AVL_uint16 MaxLPF)
+{
+	pBSsetting->m_uiTuner_MaxLPF_100kHz = MaxLPF;
+	
+	return AVL_DVBSx_EC_OK;
+}
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_IBlindScanAPI_Start(struct AVL_DVBSx_Chip * pAVLChip, struct AVL_Tuner * pTuner, struct AVL_DVBSx_BlindScanAPI_Setting * pBSsetting)
+{
+	AVL_DVBSx_ErrorCode r = AVL_DVBSx_EC_OK;
+	struct AVL_DVBSx_BlindScanPara * pbsPara = &pBSsetting->bsPara;
+
+	r |= AVL_DVBSx_IBase_SetFunctionalMode(pAVLChip, AVL_DVBSx_FunctMode_BlindScan);
+	r |= AVL_DVBSx_IBase_SetSpectrumPolarity(pBSsetting->m_eSpectrumMode,pAVLChip); 
+
+	if(pBSsetting->BS_Mode)
+	{
+		pTuner->m_uiFrequency_100kHz = 10*pBSsetting->m_uiScan_Start_Freq_MHz + 320 + (pBSsetting->m_uiScan_Bind_No) * pBSsetting->m_uiScan_Center_Freq_Step_100KHz;
+		pbsPara->m_uiStartFreq_100kHz = pTuner->m_uiFrequency_100kHz - 320;
+		pbsPara->m_uiStopFreq_100kHz =  pTuner->m_uiFrequency_100kHz + 320;
+	}
+	else
+	{
+		pbsPara->m_uiStartFreq_100kHz = pBSsetting->m_uiScan_Next_Freq_100KHz;
+		pbsPara->m_uiStopFreq_100kHz = pBSsetting->m_uiScan_Next_Freq_100KHz + 320*2;
+		pTuner->m_uiFrequency_100kHz = (pbsPara->m_uiStartFreq_100kHz + pbsPara->m_uiStopFreq_100kHz)/2;
+	}
+
+	pTuner->m_uiLPF_100kHz =  pBSsetting->m_uiTuner_MaxLPF_100kHz;
+	
+	r |= pTuner->m_pLockFunc(pTuner);	//Lock the tuner. 
+	
+	AVL_DVBSx_IBSP_Delay(50);		//wait a while for tuner to lock in certain frequency.
+	
+	r |= pTuner->m_pGetLockStatusFunc(pTuner);	 //Check the lock status of the tuner.
+	if (AVL_DVBSx_EC_OK != r)		 
+	{
+		return r;
+	}
+			
+	pbsPara->m_uiMaxSymRate_kHz = 1000*pBSsetting->m_uiScan_Max_Symbolrate_MHz;
+	pbsPara->m_uiMinSymRate_kHz = 1000*pBSsetting->m_uiScan_Min_Symbolrate_MHz;
+	
+	r |= AVL_DVBSx_IBlindScan_Reset(pAVLChip);
+	r |= AVL_DVBSx_IBlindScan_Scan(pbsPara,340, pAVLChip);
+	pBSsetting->m_uiScaning = 1;
+	
+	return r;
+}
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_IBlindScanAPI_GetCurrentScanStatus(struct AVL_DVBSx_Chip * pAVLChip,struct AVL_DVBSx_BlindScanAPI_Setting * pBSsetting)
+{
+	AVL_DVBSx_ErrorCode r = AVL_DVBSx_EC_OK;
+	struct AVL_DVBSx_BlindScanInfo * pbsInfo = &(pBSsetting->bsInfo);
+	struct AVL_DVBSx_BlindScanPara * pbsPara = &(pBSsetting->bsPara);	
+    
+	r |= AVL_DVBSx_IBlindScan_GetScanStatus(pbsInfo, pAVLChip);  //Query the internal blind scan procedure information.
+	
+
+	if(100 == pbsInfo->m_uiProgress)
+	{
+		pBSsetting->m_uiScan_Next_Freq_100KHz = pbsInfo->m_uiNextStartFreq_100kHz;
+		pBSsetting->m_uiScan_Progress_Per = AVL_min(100,((10*(pbsPara->m_uiStopFreq_100kHz - 10*pBSsetting->m_uiScan_Start_Freq_MHz))/(pBSsetting->m_uiScan_Stop_Freq_MHz - pBSsetting->m_uiScan_Start_Freq_MHz)));
+		pBSsetting->m_uiScan_Bind_No++;	
+		pBSsetting->m_uiScaning = 0;
+
+		r |= AVL_DVBSx_IBase_SetFunctionalMode(pAVLChip,AVL_DVBSx_FunctMode_Demod);
+	}
+	if( r != AVL_DVBSx_EC_OK
+#if defined(CONFIG_MACH_MESON6_G18_TH7)
+	 || pbsInfo->m_uiResultCode > 0
+#endif
+	 )
+		return AVL_DVBSx_EC_GeneralFail;
+
+	if(100 == pbsInfo->m_uiProgress)
+		return AVL_DVBSx_EC_OK;
+	else
+		return AVL_DVBSx_EC_Running;
+}
+
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_IBlindScanAPI_Adjust(struct AVL_DVBSx_Chip * pAVLChip,struct AVL_DVBSx_BlindScanAPI_Setting * pBSsetting)
+{
+	
+	AVL_DVBSx_ErrorCode r = AVL_DVBSx_EC_OK;	
+	struct AVL_DVBSx_BlindScanInfo * pbsInfo = &pBSsetting->bsInfo;
+	AVL_uint16 Indext = pBSsetting->m_uiChannelCount;
+	AVL_uint16 i,j,flag;
+	struct AVL_DVBSx_Channel *pTemp;
+	struct AVL_DVBSx_Channel *pValid;
+	AVL_uint32 uiSymbolRate_Hz;
+	AVL_uint32 ui_SR_offset;
+	
+	if(pbsInfo->m_uiChannelCount>0)
+	{
+		r |= AVL_DVBSx_IBlindScan_ReadChannelInfo(0, &(pbsInfo->m_uiChannelCount), pBSsetting->channels_Temp, pAVLChip);
+	}
+
+	for(i=0; i<pbsInfo->m_uiChannelCount; i++)
+	{
+		pTemp = &(pBSsetting->channels_Temp[i]);
+		flag =0;
+		for(j=0; j<pBSsetting->m_uiChannelCount; j++)
+		{
+			pValid = &(pBSsetting->channels[j]);
+			if( (AVL_abssub(pValid->m_uiFrequency_kHz,pTemp->m_uiFrequency_kHz)*833) < AVL_min(pValid->m_uiSymbolRate_Hz,pTemp->m_uiSymbolRate_Hz) )
+			{
+				flag = 1;
+				break;
+			}				
+		}
+
+		if(0 == flag)
+		{
+			pBSsetting->channels[Indext].m_Flags = pTemp->m_Flags;
+			pBSsetting->channels[Indext].m_uiSymbolRate_Hz = pTemp->m_uiSymbolRate_Hz;
+			pBSsetting->channels[Indext].m_uiFrequency_kHz = 1000*((pTemp->m_uiFrequency_kHz+500)/1000);
+
+			uiSymbolRate_Hz = pBSsetting->channels[Indext].m_uiSymbolRate_Hz;
+			//----------------------------adjust symbol rate offset------------------------------------------------------------
+			ui_SR_offset = ((uiSymbolRate_Hz%10000)>5000)?(10000-(uiSymbolRate_Hz%10000)):(uiSymbolRate_Hz%10000);
+			if( ((uiSymbolRate_Hz>10000000) && (ui_SR_offset<3500)) || ((uiSymbolRate_Hz>5000000) && (ui_SR_offset<2000)) )
+				uiSymbolRate_Hz = (uiSymbolRate_Hz%10000<5000)?(uiSymbolRate_Hz - ui_SR_offset):(uiSymbolRate_Hz + ui_SR_offset);
+
+			ui_SR_offset = ((uiSymbolRate_Hz%1000)>500)?(1000-(uiSymbolRate_Hz%1000)):(uiSymbolRate_Hz%1000);
+			if( (uiSymbolRate_Hz<5000000) && (ui_SR_offset< 500) )
+				uiSymbolRate_Hz = (uiSymbolRate_Hz%1000<500)?(uiSymbolRate_Hz - ui_SR_offset):(uiSymbolRate_Hz + ui_SR_offset);
+	
+			pBSsetting->channels[Indext].m_uiSymbolRate_Hz = 1000*(uiSymbolRate_Hz/1000);
+			//----------------------------------------------------------------------------------------------------------------
+			Indext++;
+		}
+	}
+	
+	pBSsetting->m_uiChannelCount = Indext;
+	
+	return r;
+}
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_IBlindScanAPI_Exit(struct AVL_DVBSx_Chip * pAVLChip, struct AVL_DVBSx_BlindScanAPI_Setting * pBSsetting)
+{
+	AVL_DVBSx_ErrorCode r = AVL_DVBSx_EC_OK;
+	struct AVL_DVBSx_BlindScanInfo * pbsInfo = &pBSsetting->bsInfo;
+	
+	if(pBSsetting->m_uiScaning == 1)
+	{
+		do
+		{
+			AVL_DVBSx_IBSP_Delay(50);			
+			r |= AVL_DVBSx_IBlindScan_GetScanStatus(pbsInfo, pAVLChip);  //Query the internal blind scan procedure information.
+			if(AVL_DVBSx_EC_OK !=r)
+			{
+				return r;			
+			}
+		}while(100 != pbsInfo->m_uiProgress);
+	}
+	
+	r |= AVL_DVBSx_IBase_SetFunctionalMode(pAVLChip,AVL_DVBSx_FunctMode_Demod);
+	AVL_DVBSx_IBSP_Delay(10);
+	
+	return r;
+}
+
+AVL_uint16 AVL_DVBSx_IBlindscanAPI_GetProgress(struct AVL_DVBSx_BlindScanAPI_Setting * pBSsetting)
+{
+	return pBSsetting->m_uiScan_Progress_Per;
+}
+
diff -Naur a/drivers/amlogic/dvb_tv/avl6211/src/IBlindScan.c b/drivers/amlogic/dvb_tv/avl6211/src/IBlindScan.c
--- a/drivers/amlogic/dvb_tv/avl6211/src/IBlindScan.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/amlogic/dvb_tv/avl6211/src/IBlindScan.c	2014-12-11 16:13:50.457614809 +0100
@@ -0,0 +1,163 @@
+/*
+ *           Copyright 2012 Availink, Inc.
+ *
+ *  This software contains Availink proprietary information and
+ *  its use and disclosure are restricted solely to the terms in
+ *  the corresponding written license agreement. It shall not be 
+ *  disclosed to anyone other than valid licensees without
+ *  written permission of Availink, Inc.
+ *
+ */
+
+
+///$Date: 2012-2-9 17:36 $
+///
+#include "IBlindScan.h"
+#include "IBase.h"
+#include "IRx.h"
+#include "II2C.h"
+#include "ITuner.h"
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_IBlindScan_Scan(struct AVL_DVBSx_BlindScanPara * pBSPara, AVL_uint16 uiTunerLPF_100kHz, const struct AVL_DVBSx_Chip * pAVLChip )
+{
+	AVL_DVBSx_ErrorCode r;
+	AVL_uint16 uiCarrierFreq_100kHz;
+	AVL_uint16 uiMinSymRate;
+	enum AVL_DVBSx_FunctionalMode enumFunctionalMode;
+
+	r = AVL_DVBSx_IBase_GetFunctionalMode(&enumFunctionalMode, pAVLChip);
+
+	if(enumFunctionalMode == AVL_DVBSx_FunctMode_BlindScan)
+	{
+		r |= AVL_DVBSx_II2C_Write16(pAVLChip, rc_tuner_LPF_100kHz_addr, uiTunerLPF_100kHz);
+
+		uiMinSymRate = pBSPara->m_uiMinSymRate_kHz - 200;		// give some tolerance
+
+		if( uiMinSymRate < 800 )	   //Blind scan doesn't support symbol rate less then 1M, give 200K margin
+		{
+			uiMinSymRate = 800;
+		}
+
+		if( pBSPara->m_uiStartFreq_100kHz < pBSPara->m_uiStopFreq_100kHz )
+		{
+			if( AVL_DVBSx_EC_OK == r )
+			{
+				uiCarrierFreq_100kHz = ((pBSPara->m_uiStopFreq_100kHz)+(pBSPara->m_uiStartFreq_100kHz))>>1;
+				r |= AVL_DVBSx_II2C_Write16(pAVLChip, rc_tuner_frequency_100kHz_addr, uiCarrierFreq_100kHz);
+				r |= AVL_DVBSx_II2C_Write16(pAVLChip, rc_blind_scan_min_sym_rate_kHz_addr, uiMinSymRate);
+				r |= AVL_DVBSx_II2C_Write16(pAVLChip, rc_blind_scan_max_sym_rate_kHz_addr, (pBSPara->m_uiMaxSymRate_kHz)+200);
+				r |= AVL_DVBSx_II2C_Write16(pAVLChip, rc_blind_scan_start_freq_100kHz_addr, (pBSPara->m_uiStartFreq_100kHz));
+				r |= AVL_DVBSx_II2C_Write16(pAVLChip, rc_blind_scan_end_freq_100kHz_addr, (pBSPara->m_uiStopFreq_100kHz));
+
+				if( AVL_DVBSx_EC_OK == r )
+				{
+					r = AVL_DVBSx_IBase_SendRxOP(OP_RX_BLIND_SCAN, (struct AVL_DVBSx_Chip *)pAVLChip );
+				}
+			}
+		}
+		else
+		{
+			r = AVL_DVBSx_EC_GeneralFail;
+		}
+	}
+	else
+	{
+		r = AVL_DVBSx_EC_GeneralFail;
+	}
+
+	return(r);
+}
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_IBlindScan_GetScanStatus(struct AVL_DVBSx_BlindScanInfo * pBSInfo, const struct AVL_DVBSx_Chip * pAVLChip )
+{
+	AVL_DVBSx_ErrorCode r = AVL_DVBSx_EC_OK;
+
+	r |= AVL_DVBSx_II2C_Read16(pAVLChip, rs_blind_scan_progress_addr, &(pBSInfo->m_uiProgress));
+	r |= AVL_DVBSx_II2C_Read16(pAVLChip, rs_blind_scan_channel_count_addr, &(pBSInfo->m_uiChannelCount));
+	r |= AVL_DVBSx_II2C_Read16(pAVLChip, rc_blind_scan_start_freq_100kHz_addr, &(pBSInfo->m_uiNextStartFreq_100kHz));
+	r |= AVL_DVBSx_II2C_Read16(pAVLChip, rs_blind_scan_error_code_addr, &(pBSInfo->m_uiResultCode));
+	if( pBSInfo->m_uiProgress > 100 )
+	{
+		pBSInfo->m_uiProgress = 0;
+	}
+	return(r);
+}
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_IBlindScan_Cancel(struct AVL_DVBSx_Chip * pAVLChip )
+{
+	AVL_DVBSx_ErrorCode r;
+	enum AVL_DVBSx_FunctionalMode enumFunctionalMode;
+
+	r = AVL_DVBSx_IBase_GetFunctionalMode(&enumFunctionalMode, pAVLChip);
+
+	if(enumFunctionalMode == AVL_DVBSx_FunctMode_BlindScan)
+	{
+		r |= AVL_DVBSx_IBase_SendRxOP(OP_RX_HALT, pAVLChip );
+	}
+	else
+	{
+		r = AVL_DVBSx_EC_GeneralFail;
+	}
+
+	return(r);
+}
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_IBlindScan_ReadChannelInfo(AVL_uint16 uiStartIndex, AVL_puint16 pChannelCount, struct AVL_DVBSx_Channel * pChannel, const struct AVL_DVBSx_Chip * pAVLChip )
+{
+	AVL_DVBSx_ErrorCode r;
+	AVL_uint32 channel_addr;
+	AVL_uint16 i1, i2;
+	AVL_uint32 uiMinFreq;
+	int iMinIdx;
+	struct AVL_DVBSx_Channel sTempChannel;
+
+	r = AVL_DVBSx_II2C_Read16(pAVLChip, rs_blind_scan_channel_count_addr, &i1);
+	if( (uiStartIndex + (*pChannelCount)) > (i1) )
+	{
+		*pChannelCount = i1-uiStartIndex;
+	}
+	r |= AVL_DVBSx_II2C_Read16(pAVLChip, rc_blind_scan_channel_info_offset_addr, &i1);
+	channel_addr = (sharemem_addr + i1) + uiStartIndex*sizeof(struct AVL_DVBSx_Channel);
+	for( i1=0; i1<(*pChannelCount); i1++ )
+	{
+#if 1  //for some processors which can not read 12 bytes		
+		//dump the channel information
+		r |= AVL_DVBSx_II2C_Read32(pAVLChip, channel_addr, &(pChannel[i1].m_uiFrequency_kHz));
+		channel_addr += 4;
+		r |= AVL_DVBSx_II2C_Read32(pAVLChip, channel_addr, &(pChannel[i1].m_uiSymbolRate_Hz));
+		channel_addr += 4;
+		r |= AVL_DVBSx_II2C_Read32(pAVLChip, channel_addr, &(pChannel[i1].m_Flags));
+		channel_addr += 4;
+#endif		
+	}
+
+	// Sort the results
+	for(i1=0; i1<(*pChannelCount); i1++)
+	{
+		iMinIdx = i1;
+		uiMinFreq = pChannel[i1].m_uiFrequency_kHz;
+		for(i2=(i1+1); i2<(*pChannelCount); i2++)
+		{
+			if(pChannel[i2].m_uiFrequency_kHz < uiMinFreq)
+			{
+				uiMinFreq = pChannel[i2].m_uiFrequency_kHz;
+				iMinIdx = i2;
+			}
+		}
+		sTempChannel = pChannel[iMinIdx];
+		pChannel[iMinIdx] = pChannel[i1];
+		pChannel[i1] = sTempChannel;
+	}
+
+	return(r);
+}
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_IBlindScan_Reset( const struct AVL_DVBSx_Chip * pAVLChip )
+{
+	AVL_DVBSx_ErrorCode r;
+
+	r = AVL_DVBSx_II2C_Write16(pAVLChip, rc_blind_scan_reset_addr, 1);
+
+	return(r);
+}
+
diff -Naur a/drivers/amlogic/dvb_tv/avl6211/src/IBSP.c b/drivers/amlogic/dvb_tv/avl6211/src/IBSP.c
--- a/drivers/amlogic/dvb_tv/avl6211/src/IBSP.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/amlogic/dvb_tv/avl6211/src/IBSP.c	2014-12-11 16:13:50.473614685 +0100
@@ -0,0 +1,234 @@
+/*
+ *           Copyright 2012 Availink, Inc.
+ *
+ *  This software contains Availink proprietary information and
+ *  its use and disclosure are restricted solely to the terms in
+ *  the corresponding written license agreement. It shall not be 
+ *  disclosed to anyone other than valid licensees without
+ *  written permission of Availink, Inc.
+ *
+ */
+
+
+///$Date: 2012-2-9 17:36 $
+///
+///
+/// @file
+/// @brief Implements the functions declared in IBSP.h. 
+/// 
+#include "IBSP.h"
+#include <linux/semaphore.h>
+#include <linux/delay.h>
+
+#include "../../aml_fe.h"
+
+#define init_MUTEX(sem)		sema_init(sem, 1)
+#define init_MUTEX_LOCKED(sem)	sema_init(sem, 0)
+
+/// The following table illustrates a set of PLL configuration values to operate AVL6211 in two modes:
+// Standard performance mode.
+// High performance mode
+
+/// Please refer to the AVL6211 channel receiver datasheet for detailed information on highest symbol rate 
+/// supported by the demod in both these modes.
+
+///For more information on other supported clock frequencies and PLL settings for higher symbol rates, please 
+///contact Availink.
+
+/// Users can remove unused elements from the following array to reduce the SDK footprint size.
+const struct AVL_DVBSx_PllConf pll_conf[] =
+{
+	// The following set of PLL configuration at different reference clock frequencies refer to demod operation
+	// in standard performance mode.
+	 {503,  1, 7, 4, 2,  4000, 11200, 16800, 25200} ///< Reference clock 4 MHz,   Demod clock 112 MHz, FEC clock 168 MHz, MPEG clock 252 MHz
+	,{447,  1, 7, 4, 2,  4500, 11200, 16800, 25200} ///< Reference clock 4.5 MHz, Demod clock 112 MHz, FEC clock 168 MHz, MPEG clock 252 MHz
+	,{503,  4, 7, 4, 2, 10000, 11200, 16800, 25200} ///< Reference clock 10 MHz,  Demod clock 112 MHz, FEC clock 168 MHz, MPEG clock 252 MHz
+	,{503,  7, 7, 4, 2, 16000, 11200, 16800, 25200} ///< Reference clock 16 MHz,  Demod clock 112 MHz, FEC clock 168 MHz, MPEG clock 252 MHz
+	,{111,  2, 7, 4, 2, 27000, 11200, 16800, 25200} ///< Reference clock 27 MHz,  Demod clock 112 MHz, FEC clock 168 MHz, MPEG clock 252 MHz
+	
+	// The following set of PLL configuration at different reference clock frequencies refer to demod operation
+	// in high performance mode. 
+	,{566,  1, 7, 4, 2,  4000, 12600, 18900, 28350} /// < Reference clock 4 MHz,   Demod clock 126 MHz, FEC clock 189 MHz, MPEG clock 283.5 MHz
+	,{503,  1, 7, 4, 2,  4500, 12600, 18900, 28350} ///< Reference clock 4.5 MHz, Demod clock 126 MHz, FEC clock 189 MHz, MPEG clock 283.5 MHz
+	,{566,  4, 7, 4, 2, 10000, 12600, 18900, 28350} ///< Reference clock 10 MHz,  Demod clock 126 MHz, FEC clock 189 MHz, MPEG clock 283.5 MHz
+	,{566,  7, 7, 4, 2, 16000, 12600, 18900, 28350} ///< Reference clock 16 MHz,  Demod clock 126 MHz, FEC clock 189 MHz, MPEG clock 283.5 MHz
+	,{377,  8, 7, 4, 2, 27000, 12600, 18900, 28350} ///< Reference clock 27 MHz,  Demod clock 126 MHz, FEC clock 189 MHz, MPEG clock 283.5 MHz
+
+};
+
+const AVL_uint16 pll_array_size = sizeof(pll_conf)/sizeof(struct AVL_DVBSx_PllConf);
+
+AVL_int32 I2CWrite(AVL_uchar I2CSlaveAddr, AVL_uchar *data, AVL_int32 length, int iDeviceID);
+AVL_int32  I2CRead(AVL_uchar I2CSlaveAddr, AVL_uchar *data, AVL_int32 length, int iDeviceID);
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_IBSP_Initialize(void)
+{
+	return(AVL_DVBSx_EC_OK);
+}
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_IBSP_Dispose(void)
+{
+	return(AVL_DVBSx_EC_OK);
+}
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_IBSP_Delay( AVL_uint32 uiMS )
+{
+	msleep(uiMS);
+	return(AVL_DVBSx_EC_OK);
+}
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_IBSP_I2CRead(  const struct AVL_DVBSx_Chip * pAVLChip,  AVL_puchar pucBuff, AVL_puint16 puiSize )
+{
+	AVL_uint16 I2CSlaveAddr;
+	AVL_puchar data;
+	AVL_puint16 length;
+	I2CSlaveAddr=pAVLChip->m_SlaveAddr;
+	data = pucBuff;
+	length = *puiSize;
+	if(I2CRead(I2CSlaveAddr,data, length,pAVLChip->m_uiBusId)==0)
+		return AVL_DVBSx_EC_I2CFail;
+	//printk("data is %x,%x\n",data[0],data[1]);
+	return(AVL_DVBSx_EC_OK);
+}
+AVL_DVBSx_ErrorCode AVL_DVBSx_IBSP_I2CWrite(  const struct AVL_DVBSx_Chip * pAVLChip,  AVL_puchar pucBuff,  AVL_puint16  puiSize )
+{
+	AVL_uint16 I2CSlaveAddr;
+	AVL_puchar data;
+	AVL_puint16 length;
+	I2CSlaveAddr=pAVLChip->m_SlaveAddr;
+	data = pucBuff;
+	length = *puiSize;
+	if(I2CWrite(I2CSlaveAddr,data, length,pAVLChip->m_uiBusId)==0)
+		return AVL_DVBSx_EC_I2CFail;
+	return(AVL_DVBSx_EC_OK);
+}
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_IBSP_InitSemaphore( AVL_psemaphore pSemaphore )
+{
+	init_MUTEX(pSemaphore);
+	return(AVL_DVBSx_EC_OK);
+}
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_IBSP_WaitSemaphore( AVL_psemaphore pSemaphore )
+{
+	if(down_interruptible(pSemaphore))
+		return -AVL_DVBSx_EC_GeneralFail;
+	return(AVL_DVBSx_EC_OK);
+}
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_IBSP_ReleaseSemaphore( AVL_psemaphore pSemaphore )
+{
+	up(pSemaphore);
+	return(AVL_DVBSx_EC_OK);
+}
+
+
+extern struct aml_fe_dev * avl6211_get_cur_dev(int iDeviceId);
+
+
+ AVL_int32 I2CWrite(AVL_uchar I2CSlaveAddr, AVL_uchar *data, AVL_int32 length,int iDeviceId)
+ {
+//	printk("\n[I2CWrite] enter I2CSlaveAddr is %x,length is %d,data is %x, %x,%x\n",I2CSlaveAddr,length,data[0],data[1],data[2]);
+//	printk("I2CSlaveAddr is %d\n",I2CSlaveAddr);
+   /* I2C write, please port this function*/
+   AVL_int32 ret = 0;
+//	unsigned char regbuf[1];			/*8 bytes reg addr, regbuf 1 byte*/
+	struct i2c_msg msg;			/*construct 2 msgs, 1 for reg addr, 1 for reg value, send together*/
+
+//	regbuf[0] = I2CSlaveAddr & 0xff;
+
+	memset(&msg, 0, sizeof(msg));
+
+	/*write reg address*/
+/*	msg[0].addr = (state->config.demod_addr);					
+	msg[0].flags = 0;
+	msg[0].buf = regbuf;
+	msg[0].len = 1;*/
+
+
+	/*write value*/
+	msg.addr = I2CSlaveAddr;
+	msg.flags = 0;  //I2C_M_NOSTART;	/*i2c_transfer will emit a stop flag, so we should send 2 msg together,
+																// * and the second msg's flag=I2C_M_NOSTART, to get the right timing*/
+	msg.buf = data;
+	msg.len = length;
+#if 0
+
+	/*write reg address*/
+	msg[0].addr = 0x80;					
+	msg[0].flags = 0;
+	msg[0].buf = 0x7;
+	msg[0].len = 1;
+
+	/*write value*/
+	msg[1].addr = 0x80;
+	msg[1].flags = I2C_M_NOSTART;	/*i2c_transfer will emit a stop flag, so we should send 2 msg together,
+																 * and the second msg's flag=I2C_M_NOSTART, to get the right timing*/
+	msg[1].buf = 0x8;
+	msg[1].len = 1;
+
+#endif
+
+//	int i2c_id = -1;
+	/*cfg->demod_addr=0;
+	cfg->tuner_addr=0;
+	cfg->i2c_id=0;
+	cfg->reset_pin=0;*/
+	struct aml_fe_dev *dev = avl6211_get_cur_dev(iDeviceId);
+	/*i2c_handle = i2c_get_adapter(i2c_id,i2c_handle);
+	if (!i2c_handle) {
+		printk("cannot get i2c adaptor\n");
+		return 0;
+	}*/
+	ret = i2c_transfer((struct i2c_adapter *)dev->i2c_adap, &msg, 1);
+	if(ret<0){
+		printk(" %s: writereg error, errno is %d \n", __FUNCTION__, ret);
+		return 0;
+	}
+	else{
+		//printk(" %s:write success, errno is %d \n", __FUNCTION__, ret);
+		return 1;
+	}
+      return 1;
+ }
+ 
+ AVL_int32  I2CRead(AVL_uchar I2CSlaveAddr, AVL_uchar *data, AVL_int32 length,int iDeviceId)
+ {
+     /* I2C read, please port this function*/
+	//	printk("I2CSlaveAddr is %d,length is %d\n",I2CSlaveAddr,length);
+//		printk("I2CSlaveAddr is %d\n",I2CSlaveAddr);
+		 AVL_uint32 nRetCode = 0;
+		 struct i2c_msg msg[1];
+		 
+		 if(data == 0 || length == 0)
+		 {
+			 printk("avl6211 read register parameter error !!\n");
+			 return 0;
+		 }
+	 
+		 //read real data 
+		 memset(msg, 0, sizeof(msg));
+		 msg[0].addr = I2CSlaveAddr;
+		 msg[0].flags |=  I2C_M_RD;  //write  I2C_M_RD=0x01
+		 msg[0].len = length;
+		 msg[0].buf = data;
+
+
+		struct aml_fe_dev *dev = avl6211_get_cur_dev(iDeviceId);
+	//	printk("\n[I2CRead] get i2c_adapter");
+	/*	i2c_handle = i2c_get_adapter(i2c_id);
+		if (!i2c_handle) {
+			printk("cannot get i2c adaptor\n");
+		}*/
+	
+		 
+		 nRetCode = i2c_transfer((struct i2c_adapter *)dev->i2c_adap, msg, 1);
+	 
+		 if(nRetCode != 1)
+		 {
+			 printk("avl6211_readregister reg failure!\n");
+			 return 0;
+		 }
+        return 1;
+ }
+
diff -Naur a/drivers/amlogic/dvb_tv/avl6211/src/IDiseqc.c b/drivers/amlogic/dvb_tv/avl6211/src/IDiseqc.c
--- a/drivers/amlogic/dvb_tv/avl6211/src/IDiseqc.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/amlogic/dvb_tv/avl6211/src/IDiseqc.c	2014-12-11 16:13:50.393615298 +0100
@@ -0,0 +1,478 @@
+/*
+ *           Copyright 2012 Availink, Inc.
+ *
+ *  This software contains Availink proprietary information and
+ *  its use and disclosure are restricted solely to the terms in
+ *  the corresponding written license agreement. It shall not be 
+ *  disclosed to anyone other than valid licensees without
+ *  written permission of Availink, Inc.
+ *
+ */
+
+
+///$Date: 2012-2-9 17:36 $
+///
+#include "IDiseqc.h"
+#include "II2C.h"
+#include "IBSP.h"
+#include "IBase.h"
+
+///@cond
+#define Diseqc_delay 20
+
+/// Check if it is safe to switch DiSEqC operation mode.
+/// 
+/// @param pAVLChip A pointer point to a ::AVL_DVBSx_Chip object which is used to tell function which chip it is working on.
+/// 
+/// @return ::AVL_DVBSx_ErrorCode, 
+/// Return ::AVL_DVBSx_EC_OK if it is OK to switch.
+/// Return ::AVL_DVBSx_EC_Running if it is not safe to switch since the last transmit is not done yet.
+/// Return ::AVL_DVBSx_EC_I2CFail if there is a I2C problem.
+AVL_DVBSx_ErrorCode AVL_DVBSx_IDiseqc_IsSafeToSwitchMode( struct AVL_DVBSx_Chip * pAVLChip )
+{
+	AVL_DVBSx_ErrorCode r = AVL_DVBSx_EC_OK;
+	AVL_uint32 i1;
+	switch( pAVLChip->Diseqc_OP_Status )
+	{
+	case AVL_DVBSx_DOS_InModulation:
+	case AVL_DVBSx_DOS_InTone:
+		r |= AVL_DVBSx_II2C_Read32(pAVLChip, diseqc_tx_st_addr, &i1);
+		if( 1 != ((i1 & 0x00000040) >> 6) )	//check if the last transmit is done
+		{
+			r |= AVL_DVBSx_EC_Running;
+		}
+		break;
+	case AVL_DVBSx_DOS_InContinuous:
+	case AVL_DVBSx_DOS_Initialized:
+		break;
+	default:
+		r |= AVL_DVBSx_EC_GeneralFail;
+		break;
+	}
+	return(r);
+}
+
+///@endcond
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_IDiseqc_Initialize( const struct AVL_DVBSx_Diseqc_Para * pDiseqcPara, struct AVL_DVBSx_Chip * pAVLChip )
+{
+	AVL_DVBSx_ErrorCode r;
+	AVL_uint32 i1;
+	r = AVL_DVBSx_IBSP_WaitSemaphore(&(pAVLChip->m_semDiseqc));
+	if( AVL_DVBSx_EC_OK == r )
+	{
+		r |= AVL_DVBSx_II2C_Write32(pAVLChip, diseqc_srst_addr, 1);
+
+		r |= AVL_DVBSx_II2C_Write32(pAVLChip, diseqc_samp_frac_n_addr, 200);		//2M=200*10kHz
+		r |= AVL_DVBSx_II2C_Write32(pAVLChip, diseqc_samp_frac_d_addr, pAVLChip->m_DemodFrequency_10kHz);
+
+		r |= AVL_DVBSx_II2C_Write32(pAVLChip, diseqc_tone_frac_n_addr, ((pDiseqcPara->m_ToneFrequency_kHz)<<1));
+		r |= AVL_DVBSx_II2C_Write32(pAVLChip, diseqc_tone_frac_d_addr, pAVLChip->m_DemodFrequency_10kHz*10);
+
+		// Initialize the tx_control
+		r |= AVL_DVBSx_II2C_Read32(pAVLChip, diseqc_tx_cntrl_addr, &i1);
+		i1 &= 0x00000300;
+		i1 |= 0x20;		//reset tx_fifo
+		i1 |= ((AVL_uint32)(pDiseqcPara->m_TXGap) << 6);
+		i1 |= ((AVL_uint32)(pDiseqcPara->m_TxWaveForm) << 4);
+		i1 |= (1<<3);			//enable tx gap.
+		r |= AVL_DVBSx_II2C_Write32(pAVLChip, diseqc_tx_cntrl_addr, i1);
+		i1 &= ~(0x20);	//release tx_fifo reset
+		r |= AVL_DVBSx_II2C_Write32(pAVLChip, diseqc_tx_cntrl_addr, i1);
+
+		// Initialize the rx_control
+		i1 = ((AVL_uint32)(pDiseqcPara->m_RxWaveForm) << 2);
+		i1 |= (1<<1);	//active the receiver
+		i1 |= (1<<3);	//envelop high when tone present
+		r |= AVL_DVBSx_II2C_Write32(pAVLChip, diseqc_rx_cntrl_addr, i1);
+		i1 = (AVL_uint32)(pDiseqcPara->m_RxTimeout);
+		r |= AVL_DVBSx_II2C_Write32(pAVLChip, diseqc_rx_msg_tim_addr, i1);
+
+		r |= AVL_DVBSx_II2C_Write32(pAVLChip, diseqc_srst_addr, 0);
+
+		if( AVL_DVBSx_EC_OK == r )
+		{
+			pAVLChip->Diseqc_OP_Status = AVL_DVBSx_DOS_Initialized;
+		}
+	}
+	r |= AVL_DVBSx_IBSP_ReleaseSemaphore(&(pAVLChip->m_semDiseqc));
+	return(r);
+}
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_IDiseqc_ReadModulationData( AVL_puchar pucBuff, AVL_puchar pucSize, struct AVL_DVBSx_Chip * pAVLChip )
+{
+	AVL_DVBSx_ErrorCode r;
+	AVL_uint32 i1,i2;
+	AVL_uchar pucBuffTemp[4];
+	r = AVL_DVBSx_IBSP_WaitSemaphore(&(pAVLChip->m_semDiseqc));
+	r |= AVL_DVBSx_II2C_Read32(pAVLChip, diseqc_rx_st_addr, &i1);
+	r |= AVL_DVBSx_II2C_Read32(pAVLChip, diseqc_tx_cntrl_addr, &i2);
+	if((i2>>8) & 0x01)
+	{
+		pAVLChip->Diseqc_OP_Status = AVL_DVBSx_DOS_InModulation; 
+	}
+	if( AVL_DVBSx_DOS_InModulation == pAVLChip->Diseqc_OP_Status )
+	{
+		// In modulation mode
+		if( (!((i2>>8) & 0x01 ) && (0x00000004 == (i1 & 0x00000004))) || (((i2>>8) & 0x01 ) &&(0x00000004 != (i1 & 0x00000004))))
+		{
+			*pucSize = (AVL_uchar)((i1 & 0x00000078)>>3);
+			//Receive data
+			for( i1=0; i1<*pucSize; i1++ )
+			{
+				r |= AVL_DVBSx_II2C_Read(pAVLChip, diseqc_rx_fifo_map_addr, pucBuffTemp, 4);
+				pucBuff[i1] = pucBuffTemp[3];
+			}
+		}
+		else
+		{
+			r = AVL_DVBSx_EC_GeneralFail;
+		}
+	}
+	else
+	{
+		r = AVL_DVBSx_EC_GeneralFail;
+	}
+
+	r |= AVL_DVBSx_IBSP_ReleaseSemaphore(&(pAVLChip->m_semDiseqc));
+	return(r);
+}
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_IDiseqc_SendModulationData( const AVL_puchar pucBuff, AVL_uchar ucSize, struct AVL_DVBSx_Chip * pAVLChip )
+{
+	AVL_DVBSx_ErrorCode r;
+	AVL_uint32 i1, i2;
+	AVL_uchar pucBuffTemp[8];
+	AVL_uchar Continuousflag = 0;
+	AVL_uchar uiTempOutTh = 0;
+
+	if( ucSize>8 )
+	{
+		r = AVL_DVBSx_EC_MemoryRunout;
+	}
+	else
+	{
+		r = AVL_DVBSx_IBSP_WaitSemaphore(&(pAVLChip->m_semDiseqc));   
+		r |= AVL_DVBSx_IDiseqc_IsSafeToSwitchMode(pAVLChip);
+		if( AVL_DVBSx_EC_OK ==  r)
+		{
+			if (pAVLChip->Diseqc_OP_Status == AVL_DVBSx_DOS_InContinuous)
+			{
+				r |= AVL_DVBSx_II2C_Read32(pAVLChip, diseqc_tx_cntrl_addr, &i1);
+				if ((i1>>10) & 0x01)
+				{
+					Continuousflag = 1;
+					i1 &= 0xfffff3ff;
+					r |= AVL_DVBSx_II2C_Write32(pAVLChip, diseqc_tx_cntrl_addr, i1);
+					r |= AVL_DVBSx_IBSP_Delay(Diseqc_delay);
+				}
+			}
+			//reset rx_fifo
+			r |= AVL_DVBSx_II2C_Read32(pAVLChip, diseqc_rx_cntrl_addr, &i2);
+			r |= AVL_DVBSx_II2C_Write32(pAVLChip, diseqc_rx_cntrl_addr, (i2|0x01));
+			r |= AVL_DVBSx_II2C_Write32(pAVLChip, diseqc_rx_cntrl_addr, (i2&0xfffffffe));
+
+			r |= AVL_DVBSx_II2C_Read32(pAVLChip, diseqc_tx_cntrl_addr, &i1);
+			i1 &= 0xfffffff8;	//set to modulation mode and put it to FIFO load mode
+			r |= AVL_DVBSx_II2C_Write32(pAVLChip, diseqc_tx_cntrl_addr, i1);
+
+			//trunk address
+			ChunkAddr(diseqc_tx_fifo_map_addr, pucBuffTemp);
+			pucBuffTemp[3] = 0;
+			pucBuffTemp[4] = 0;
+			pucBuffTemp[5] = 0;
+			for( i2=0; i2<ucSize; i2++ )
+			{
+				pucBuffTemp[6] = pucBuff[i2];
+
+				r |= AVL_DVBSx_II2C_Write(pAVLChip, pucBuffTemp, 7);
+			}                           
+			i1 |= (1<<2);  //start fifo transmit.
+			r |= AVL_DVBSx_II2C_Write32(pAVLChip, diseqc_tx_cntrl_addr, i1);
+
+			if( AVL_DVBSx_EC_OK == r )
+			{
+				pAVLChip->Diseqc_OP_Status = AVL_DVBSx_DOS_InModulation;
+			}
+			do 
+			{
+				r |= AVL_DVBSx_IBSP_Delay(1);
+				if (++uiTempOutTh > 500)
+				{
+					r |= AVL_DVBSx_EC_TimeOut;
+					r |= AVL_DVBSx_IBSP_ReleaseSemaphore(&(pAVLChip->m_semDiseqc));
+					return(r);
+				}
+				r = AVL_DVBSx_II2C_Read32(pAVLChip, diseqc_tx_st_addr, &i1);
+			} while ( 1 != ((i1 & 0x00000040) >> 6) );
+
+			r = AVL_DVBSx_IBSP_Delay(Diseqc_delay);		//delay 15ms
+			if (Continuousflag == 1)			//resume to send out wave
+			{
+				//No data in FIFO
+				r |= AVL_DVBSx_II2C_Read32(pAVLChip, diseqc_tx_cntrl_addr, &i1);
+				i1 &= 0xfffffff8; 
+				i1 |= 0x03;		//switch to continuous mode
+				r |= AVL_DVBSx_II2C_Write32(pAVLChip, diseqc_tx_cntrl_addr, i1);
+
+				//start to send out wave
+				i1 |= (1<<10);  
+				r |= AVL_DVBSx_II2C_Write32(pAVLChip, diseqc_tx_cntrl_addr, i1);
+				if( AVL_DVBSx_EC_OK == r )
+				{
+					pAVLChip->Diseqc_OP_Status = AVL_DVBSx_DOS_InContinuous;
+				}
+			}
+		}
+		r |= AVL_DVBSx_IBSP_ReleaseSemaphore(&(pAVLChip->m_semDiseqc));
+	}
+
+	return(r);
+}
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_IDiseqc_GetTxStatus( struct AVL_DVBSx_Diseqc_TxStatus * pTxStatus, struct AVL_DVBSx_Chip * pAVLChip )
+{
+	AVL_DVBSx_ErrorCode r;
+	AVL_uint32 i1;
+	r = AVL_DVBSx_IBSP_WaitSemaphore(&(pAVLChip->m_semDiseqc));
+	if( (AVL_DVBSx_DOS_InModulation == pAVLChip->Diseqc_OP_Status) || (AVL_DVBSx_DOS_InTone == pAVLChip->Diseqc_OP_Status) )
+	{
+		r |= AVL_DVBSx_II2C_Read32(pAVLChip, diseqc_tx_st_addr, &i1);
+		pTxStatus->m_TxDone = (AVL_uchar)((i1 & 0x00000040)>>6);
+		pTxStatus->m_TxFifoCount = (AVL_uchar)((i1 & 0x0000003c)>>2);
+	}
+	else
+	{
+		r |= AVL_DVBSx_EC_GeneralFail;
+	}
+	r |= AVL_DVBSx_IBSP_ReleaseSemaphore(&(pAVLChip->m_semDiseqc));
+	return(r);
+}
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_IDiseqc_GetRxStatus( struct AVL_DVBSx_Diseqc_RxStatus * pRxStatus, struct AVL_DVBSx_Chip * pAVLChip )
+{
+	AVL_DVBSx_ErrorCode r;
+	AVL_uint32 i1;
+	r = AVL_DVBSx_IBSP_WaitSemaphore(&(pAVLChip->m_semDiseqc));
+	if( AVL_DVBSx_DOS_InModulation == pAVLChip->Diseqc_OP_Status )
+	{
+		r |= AVL_DVBSx_II2C_Read32(pAVLChip, diseqc_rx_st_addr, &i1);
+		pRxStatus->m_RxDone = (AVL_uchar)((i1 & 0x00000004)>>2);
+		pRxStatus->m_RxFifoCount = (AVL_uchar)((i1 & 0x000000078)>>3);
+		r |= AVL_DVBSx_II2C_Read32(pAVLChip, diseqc_rx_parity_addr, &i1);
+		pRxStatus->m_RxFifoParChk = (AVL_uchar)(i1 & 0x000000ff);
+	}
+	else
+	{
+		r |= AVL_DVBSx_EC_GeneralFail;
+	}
+	r |= AVL_DVBSx_IBSP_ReleaseSemaphore(&(pAVLChip->m_semDiseqc));
+	return(r);
+}
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_IDiseqc_SetLNBOut( AVL_uchar uiOut, struct AVL_DVBSx_Chip * pAVLChip )
+{
+	AVL_DVBSx_ErrorCode r;
+	AVL_uint32 i1;
+	r = AVL_DVBSx_IBSP_WaitSemaphore(&(pAVLChip->m_semDiseqc));
+	r |= AVL_DVBSx_II2C_Read32(pAVLChip, diseqc_tx_cntrl_addr, &i1);
+	i1 &= 0xfffffdff;
+	i1 |= ((uiOut & 0x1)<<9);
+	r |= AVL_DVBSx_II2C_Write32(pAVLChip, diseqc_tx_cntrl_addr, i1);
+	r |= AVL_DVBSx_IBSP_Delay(Diseqc_delay);
+	r |= AVL_DVBSx_IBSP_ReleaseSemaphore(&(pAVLChip->m_semDiseqc));
+	return(r);
+}
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_IDiseqc_GetLNBOut( AVL_puchar puiOut, struct AVL_DVBSx_Chip * pAVLChip )
+{
+	AVL_DVBSx_ErrorCode r;
+	AVL_uint32 i1;
+	r = AVL_DVBSx_IBSP_WaitSemaphore(&(pAVLChip->m_semDiseqc));
+	r |= AVL_DVBSx_II2C_Read32(pAVLChip, diseqc_tx_cntrl_addr, &i1);
+	i1 &= 0x00000200;
+	*puiOut = (AVL_uchar)(i1>>9);
+	r |= AVL_DVBSx_IBSP_ReleaseSemaphore(&(pAVLChip->m_semDiseqc));
+	return(r);
+}
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_IDiseqc_SendTone( AVL_uchar ucTone, AVL_uchar ucCount, struct AVL_DVBSx_Chip * pAVLChip )
+{
+	AVL_DVBSx_ErrorCode r;
+	AVL_uint32 i1, i2;
+	AVL_uchar pucBuffTemp[8];
+	AVL_uchar Continuousflag = 0;
+	AVL_uchar uiTempOutTh = 0;
+
+	if( ucCount>8 )
+	{
+		r = AVL_DVBSx_EC_MemoryRunout;
+	}
+	else
+	{
+		r = AVL_DVBSx_IBSP_WaitSemaphore(&(pAVLChip->m_semDiseqc));
+		r |= AVL_DVBSx_IDiseqc_IsSafeToSwitchMode(pAVLChip);
+
+		if( AVL_DVBSx_EC_OK == r )
+		{
+			if (pAVLChip->Diseqc_OP_Status == AVL_DVBSx_DOS_InContinuous)
+			{
+				r |= AVL_DVBSx_II2C_Read32(pAVLChip, diseqc_tx_cntrl_addr, &i1);
+				if ((i1>>10) & 0x01)
+				{
+					Continuousflag = 1;
+					i1 &= 0xfffff3ff;
+					r |= AVL_DVBSx_II2C_Write32(pAVLChip, diseqc_tx_cntrl_addr, i1);
+					r |= AVL_DVBSx_IBSP_Delay(Diseqc_delay);
+				}
+			}
+			//No data in the FIFO.
+			r |= AVL_DVBSx_II2C_Read32(pAVLChip, diseqc_tx_cntrl_addr, &i1);
+			i1 &= 0xfffffff8;  //put it into the FIFO load mode.
+			if( 0 == ucTone )
+			{
+				i1 |= 0x01;
+			}
+			else
+			{
+				i1 |= 0x02;
+			}
+			r |= AVL_DVBSx_II2C_Write32(pAVLChip, diseqc_tx_cntrl_addr, i1);
+
+			//trunk address
+			ChunkAddr(diseqc_tx_fifo_map_addr, pucBuffTemp);
+			pucBuffTemp[3] = 0;
+			pucBuffTemp[4] = 0;
+			pucBuffTemp[5] = 0;
+			pucBuffTemp[6] = 1;
+
+			for( i2=0; i2<ucCount; i2++ )
+			{
+				r |= AVL_DVBSx_II2C_Write(pAVLChip, pucBuffTemp, 7);
+			}
+
+			i1 |= (1<<2);  //start fifo transmit.
+			r |= AVL_DVBSx_II2C_Write32(pAVLChip, diseqc_tx_cntrl_addr, i1);
+			if( AVL_DVBSx_EC_OK == r )
+			{
+				pAVLChip->Diseqc_OP_Status = AVL_DVBSx_DOS_InTone;
+			}
+			do 
+			{
+				r |= AVL_DVBSx_IBSP_Delay(1);
+				if (++uiTempOutTh > 500)
+				{
+					r |= AVL_DVBSx_EC_TimeOut;
+					r |= AVL_DVBSx_IBSP_ReleaseSemaphore(&(pAVLChip->m_semDiseqc));
+					return(r);
+				}
+				r = AVL_DVBSx_II2C_Read32(pAVLChip, diseqc_tx_st_addr, &i1);
+			} while ( 1 != ((i1 & 0x00000040) >> 6) );
+
+			r = AVL_DVBSx_IBSP_Delay(Diseqc_delay);		//delay 15ms
+			if (Continuousflag == 1)			//resume to send out wave
+			{
+				//No data in FIFO
+				r |= AVL_DVBSx_II2C_Read32(pAVLChip, diseqc_tx_cntrl_addr, &i1);
+				i1 &= 0xfffffff8; 
+				i1 |= 0x03;		//switch to continuous mode
+				r |= AVL_DVBSx_II2C_Write32(pAVLChip, diseqc_tx_cntrl_addr, i1);
+
+				//start to send out wave
+				i1 |= (1<<10);  
+				r |= AVL_DVBSx_II2C_Write32(pAVLChip, diseqc_tx_cntrl_addr, i1);
+				if( AVL_DVBSx_EC_OK == r )
+				{
+					pAVLChip->Diseqc_OP_Status = AVL_DVBSx_DOS_InContinuous;
+				}
+			}
+		}
+		r |= AVL_DVBSx_IBSP_ReleaseSemaphore(&(pAVLChip->m_semDiseqc));
+	}
+	return(r);
+}
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_IDiseqc_StartContinuous (struct AVL_DVBSx_Chip * pAVLChip )
+{
+	AVL_DVBSx_ErrorCode r;
+	AVL_uint32 i1;
+	r = AVL_DVBSx_IBSP_WaitSemaphore(&(pAVLChip->m_semDiseqc));
+	r |= AVL_DVBSx_IDiseqc_IsSafeToSwitchMode(pAVLChip);
+
+	if( AVL_DVBSx_EC_OK == r )
+	{
+		//No data in FIFO
+		r |= AVL_DVBSx_II2C_Read32(pAVLChip, diseqc_tx_cntrl_addr, &i1);
+		i1 &= 0xfffffff8; 
+		i1 |= 0x03;		//switch to continuous mode
+		r |= AVL_DVBSx_II2C_Write32(pAVLChip, diseqc_tx_cntrl_addr, i1);
+
+		//start to send out wave
+		i1 |= (1<<10);  
+		r |= AVL_DVBSx_II2C_Write32(pAVLChip, diseqc_tx_cntrl_addr, i1);
+		if( AVL_DVBSx_EC_OK == r )
+		{
+			pAVLChip->Diseqc_OP_Status = AVL_DVBSx_DOS_InContinuous;
+		}
+	}
+	r |= AVL_DVBSx_IBSP_ReleaseSemaphore(&(pAVLChip->m_semDiseqc));
+	return(r);
+}
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_IDiseqc_StopContinuous (struct AVL_DVBSx_Chip * pAVLChip )
+{
+	AVL_DVBSx_ErrorCode r;
+	AVL_uint32 i1;
+	r = AVL_DVBSx_IBSP_WaitSemaphore(&(pAVLChip->m_semDiseqc));
+	if( AVL_DVBSx_DOS_InContinuous == pAVLChip->Diseqc_OP_Status )
+	{
+		r |= AVL_DVBSx_II2C_Read32(pAVLChip, diseqc_tx_cntrl_addr, &i1);
+		i1 &= 0xfffff3ff;
+		r |= AVL_DVBSx_II2C_Write32(pAVLChip, diseqc_tx_cntrl_addr, i1);
+	}
+
+	r |= AVL_DVBSx_IBSP_ReleaseSemaphore(&(pAVLChip->m_semDiseqc));
+	return(r);
+}
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_IDiseqc_SetLNB1Out( AVL_uchar uiOut, struct AVL_DVBSx_Chip * pAVLChip ) 
+{
+	AVL_DVBSx_ErrorCode r;
+	AVL_uint32 uiTemp;
+	r = AVL_DVBSx_IBSP_WaitSemaphore(&(pAVLChip->m_semDiseqc));
+	r |= AVL_DVBSx_II2C_Read32(pAVLChip, gpio_reg_enb, &uiTemp);
+	uiTemp &= ~(1<<1);
+	r |= AVL_DVBSx_II2C_Write32(pAVLChip, gpio_reg_enb, uiTemp);  
+
+	r |= AVL_DVBSx_II2C_Read32(pAVLChip, gpio_data_reg_out, &uiTemp);
+	if(uiOut)
+	{
+		uiTemp |= 1<<1 ;
+	}
+	else
+	{
+		uiTemp &= ~(1<<1) ;
+	}
+	r |= AVL_DVBSx_II2C_Write32(pAVLChip, gpio_data_reg_out, uiTemp);
+	r |= AVL_DVBSx_IBSP_Delay(Diseqc_delay);
+	r |= AVL_DVBSx_IBSP_ReleaseSemaphore(&(pAVLChip->m_semDiseqc));
+	return(r);
+}
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_IDiseqc_GetLNB1Out( AVL_puchar puiOut, struct AVL_DVBSx_Chip * pAVLChip )
+{
+	AVL_DVBSx_ErrorCode r;
+	AVL_uint32 uiTemp;
+	r = AVL_DVBSx_IBSP_WaitSemaphore(&(pAVLChip->m_semDiseqc));
+	r |= AVL_DVBSx_II2C_Read32(pAVLChip, gpio_data_reg_out, &uiTemp);
+	if(uiTemp & (1<<1))
+	{
+		*puiOut = 1;
+	}
+	else
+	{
+		*puiOut = 0;
+	}
+	r |= AVL_DVBSx_IBSP_ReleaseSemaphore(&(pAVLChip->m_semDiseqc));
+	return(r);
+}
diff -Naur a/drivers/amlogic/dvb_tv/avl6211/src/II2C.c b/drivers/amlogic/dvb_tv/avl6211/src/II2C.c
--- a/drivers/amlogic/dvb_tv/avl6211/src/II2C.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/amlogic/dvb_tv/avl6211/src/II2C.c	2014-12-11 16:13:50.289616089 +0100
@@ -0,0 +1,258 @@
+/*
+ *           Copyright 2012 Availink, Inc.
+ *
+ *  This software contains Availink proprietary information and
+ *  its use and disclosure are restricted solely to the terms in
+ *  the corresponding written license agreement. It shall not be 
+ *  disclosed to anyone other than valid licensees without
+ *  written permission of Availink, Inc.
+ *
+ */
+
+
+///$Date: 2012-2-9 17:36 $
+///
+#include "II2C.h"
+#include "IBSP.h"
+
+/// @cond
+AVL_semaphore gI2CSem[2];
+/// @endcond
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_II2C_Initialize(void)
+{
+	AVL_DVBSx_ErrorCode r = AVL_DVBSx_EC_OK;
+	static AVL_uchar gI2CSem_inited = 0;
+	if( 0 == gI2CSem_inited )
+	{
+		gI2CSem_inited = 1;
+		r = AVL_DVBSx_IBSP_InitSemaphore(&(gI2CSem[0]));
+		r = AVL_DVBSx_IBSP_InitSemaphore(&(gI2CSem[1]));
+	}
+	return r;
+}
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_II2C_Read( const struct AVL_DVBSx_Chip * pAVLChip, AVL_uint32 uiOffset, AVL_puchar pucBuff, AVL_uint16 uiSize)
+{
+	AVL_DVBSx_ErrorCode r;
+	AVL_uchar pucBuffTemp[3];
+	AVL_uint16 ui1, ui2;
+	AVL_uint16 iSize;
+
+	r = AVL_DVBSx_IBSP_WaitSemaphore(&(gI2CSem[pAVLChip->m_uiBusId]));
+	if( AVL_DVBSx_EC_OK == r )
+	{
+		ChunkAddr(uiOffset, pucBuffTemp);
+		ui1 = 3;
+		r = AVL_DVBSx_IBSP_I2CWrite(pAVLChip, pucBuffTemp, &ui1);  
+		if( AVL_DVBSx_EC_OK == r )
+		{
+			if( uiSize & 1 )
+			{
+				iSize = uiSize - 1;
+			}
+			else
+			{
+				iSize = uiSize;
+			}
+			ui2 = 0;
+			while( iSize > MAX_II2C_READ_SIZE )
+			{
+				ui1 = MAX_II2C_READ_SIZE;
+				r |= AVL_DVBSx_IBSP_I2CRead(pAVLChip, pucBuff+ui2, &ui1);
+				ui2 += MAX_II2C_READ_SIZE;
+				iSize -= MAX_II2C_READ_SIZE;
+			}
+
+			if( 0 != iSize )
+			{
+				r |= AVL_DVBSx_IBSP_I2CRead(pAVLChip, pucBuff+ui2, &iSize);
+			}
+
+			if( uiSize & 1 )
+			{
+				ui1 = 2;
+				r |= AVL_DVBSx_IBSP_I2CRead(pAVLChip, pucBuffTemp, &ui1);
+				pucBuff[uiSize-1] = pucBuffTemp[0];
+			}
+		}
+	}
+	r |= AVL_DVBSx_IBSP_ReleaseSemaphore(&(gI2CSem[pAVLChip->m_uiBusId]));
+	return(r);
+}
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_II2C_ReadDirect( const struct AVL_DVBSx_Chip * pAVLChip, AVL_puchar pucBuff, AVL_uint16 uiSize)
+{
+	AVL_DVBSx_ErrorCode r;
+	AVL_uchar pucBuffTemp[3];
+	AVL_uint16 ui1, ui2;
+	AVL_uint16 iSize;
+	r = AVL_DVBSx_IBSP_WaitSemaphore(&(gI2CSem[pAVLChip->m_uiBusId]));
+	if( AVL_DVBSx_EC_OK == r )
+	{
+		if( uiSize & 1 )
+		{
+			iSize = uiSize - 1;
+		}
+		else
+		{
+			iSize = uiSize;
+		}
+		ui2 = 0;
+		while( iSize > MAX_II2C_READ_SIZE )
+		{
+			ui1 = MAX_II2C_READ_SIZE;
+			r |= AVL_DVBSx_IBSP_I2CRead(pAVLChip, pucBuff+ui2, &ui1);
+			ui2 += MAX_II2C_READ_SIZE;
+			iSize -= MAX_II2C_READ_SIZE;
+		}
+
+		if( 0 != iSize )
+		{
+			r |= AVL_DVBSx_IBSP_I2CRead(pAVLChip, pucBuff+ui2, &iSize);
+		}
+
+		if( uiSize & 1 )
+		{
+			ui1 = 2;
+			r |= AVL_DVBSx_IBSP_I2CRead(pAVLChip, pucBuffTemp, &ui1);
+			pucBuff[uiSize-1] = pucBuffTemp[0];
+		}
+	}
+	r |= AVL_DVBSx_IBSP_ReleaseSemaphore(&(gI2CSem[pAVLChip->m_uiBusId]));
+	return(r);
+}
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_II2C_Write( const struct AVL_DVBSx_Chip * pAVLChip, AVL_puchar pucBuff, AVL_uint16 uiSize)
+{
+	AVL_DVBSx_ErrorCode r;
+	AVL_uchar pucBuffTemp[5];
+	AVL_uint16 ui1, ui2, uTemp;
+	AVL_uint16 iSize;
+	AVL_uint32 uAddr;
+	if( uiSize<3 )
+	{
+		return(AVL_DVBSx_EC_GeneralFail);	 //at least 3 bytes
+	}
+
+	uiSize -= 3;			//actual data size
+	r = AVL_DVBSx_IBSP_WaitSemaphore(&(gI2CSem[pAVLChip->m_uiBusId]));
+	if( AVL_DVBSx_EC_OK == r )
+	{
+		//dump address
+		uAddr = pucBuff[0];
+		uAddr = uAddr<<8;
+		uAddr += pucBuff[1];
+		uAddr = uAddr<<8;
+		uAddr += pucBuff[2];
+
+		if( uiSize & 1 )
+		{
+			iSize = uiSize -1;
+		}
+		else
+		{
+			iSize = uiSize;
+		}
+
+		uTemp = (MAX_II2C_Write_SIZE-3) & 0xfffe; //how many bytes data we can transfer every time
+
+		ui2 = 0;
+		while( iSize > uTemp )
+		{
+			ui1 = uTemp+3;
+			//save the data
+			pucBuffTemp[0] = pucBuff[ui2];
+			pucBuffTemp[1] = pucBuff[ui2+1];
+			pucBuffTemp[2] = pucBuff[ui2+2];
+			ChunkAddr(uAddr, pucBuff+ui2);
+			r |= AVL_DVBSx_IBSP_I2CWrite(pAVLChip, pucBuff+ui2, &ui1);
+			//restore data
+			pucBuff[ui2] = pucBuffTemp[0];
+			pucBuff[ui2+1] = pucBuffTemp[1];
+			pucBuff[ui2+2] = pucBuffTemp[2];
+			uAddr += uTemp;
+			ui2 += uTemp;
+			iSize -= uTemp;
+		}
+		ui1 = iSize+3;
+		//save the data
+		pucBuffTemp[0] = pucBuff[ui2];
+		pucBuffTemp[1] = pucBuff[ui2+1];
+		pucBuffTemp[2] = pucBuff[ui2+2];
+		ChunkAddr(uAddr, pucBuff+ui2);
+		r |= AVL_DVBSx_IBSP_I2CWrite(pAVLChip, pucBuff+ui2, &ui1);
+		//restore data
+		pucBuff[ui2] = pucBuffTemp[0];
+		pucBuff[ui2+1] = pucBuffTemp[1];
+		pucBuff[ui2+2] = pucBuffTemp[2];
+		uAddr += iSize;
+		ui2 += iSize;
+
+		if( uiSize & 1 )
+		{
+			ChunkAddr(uAddr, pucBuffTemp);
+			ui1 = 3;
+			r |= AVL_DVBSx_IBSP_I2CWrite(pAVLChip, pucBuffTemp, &ui1);
+			ui1 = 2;
+			r |= AVL_DVBSx_IBSP_I2CRead(pAVLChip, pucBuffTemp+3, &ui1);
+			pucBuffTemp[3] = pucBuff[ui2+3];
+			ui1 = 5;
+			r |= AVL_DVBSx_IBSP_I2CWrite(pAVLChip, pucBuffTemp, &ui1);
+		}
+	}
+	r |= AVL_DVBSx_IBSP_ReleaseSemaphore(&(gI2CSem[pAVLChip->m_uiBusId]));
+
+	return(r);
+}
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_II2C_Read16( const struct AVL_DVBSx_Chip * pAVLChip, AVL_uint32 uiAddr, AVL_puint16 puiData )
+{
+	AVL_DVBSx_ErrorCode r;
+	AVL_uchar pBuff[2];
+
+	r = AVL_DVBSx_II2C_Read(pAVLChip, uiAddr, pBuff, 2);
+	if( AVL_DVBSx_EC_OK == r )
+	{
+		*puiData = DeChunk16(pBuff);
+		//printf("puiData is %x\n",*puiData);
+	}
+	return(r);
+}
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_II2C_Read32( const struct AVL_DVBSx_Chip * pAVLChip, AVL_uint32 uiAddr, AVL_puint32 puiData )
+{
+	AVL_DVBSx_ErrorCode r;
+	AVL_uchar pBuff[4];
+
+	r = AVL_DVBSx_II2C_Read(pAVLChip, uiAddr, pBuff, 4);
+	if( AVL_DVBSx_EC_OK == r )
+	{
+		*puiData = DeChunk32(pBuff);
+		//printf("puiData is %x\n",*puiData);
+	}
+	return(r);
+}
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_II2C_Write16( const struct AVL_DVBSx_Chip * pAVLChip, AVL_uint32 uiAddr, AVL_uint16 uiData )
+{
+	AVL_DVBSx_ErrorCode r;
+	AVL_uchar pBuff[5];
+
+	ChunkAddr(uiAddr, pBuff);
+	Chunk16(uiData, pBuff+3);
+
+	r = AVL_DVBSx_II2C_Write(pAVLChip, pBuff, 5);
+	return(r);
+}
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_II2C_Write32( const struct AVL_DVBSx_Chip * pAVLChip, AVL_uint32 uiAddr, AVL_uint32 uiData )
+{
+	AVL_DVBSx_ErrorCode r;
+	AVL_uchar pBuff[7];
+
+	ChunkAddr(uiAddr, pBuff);
+	Chunk32(uiData, pBuff+3);
+	r = AVL_DVBSx_II2C_Write(pAVLChip, pBuff, 7);
+	return(r);
+}
diff -Naur a/drivers/amlogic/dvb_tv/avl6211/src/II2CRepeater.c b/drivers/amlogic/dvb_tv/avl6211/src/II2CRepeater.c
--- a/drivers/amlogic/dvb_tv/avl6211/src/II2CRepeater.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/amlogic/dvb_tv/avl6211/src/II2CRepeater.c	2014-12-11 16:13:50.213616675 +0100
@@ -0,0 +1,187 @@
+/*
+ *           Copyright 2012 Availink, Inc.
+ *
+ *  This software contains Availink proprietary information and
+ *  its use and disclosure are restricted solely to the terms in
+ *  the corresponding written license agreement. It shall not be 
+ *  disclosed to anyone other than valid licensees without
+ *  written permission of Availink, Inc.
+ *
+ */
+
+
+///$Date: 2012-2-9 17:36 $
+///
+#include "II2CRepeater.h"
+#include "IBSP.h"
+#include "II2C.h"
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_II2CRepeater_SendOP(AVL_puchar pBuff, AVL_uchar ucSize, struct AVL_DVBSx_Chip * pAVLChip )
+{
+	AVL_DVBSx_ErrorCode r;
+	const AVL_uint16 uiTimeDelay = 5;
+	const AVL_uint16 uiMaxRetries = 60;
+	AVL_uint32 i;
+
+	r = AVL_DVBSx_IBSP_WaitSemaphore(&(pAVLChip->m_semI2CRepeater));
+
+	i = 0;
+	while (AVL_DVBSx_EC_OK != AVL_DVBSx_II2CRepeater_GetOPStatus(pAVLChip))   //Maximum waiting time is 300mS.
+	{
+		if (uiMaxRetries < i++)
+		{
+			r |= AVL_DVBSx_EC_Running;
+			break;
+		}
+		AVL_DVBSx_IBSP_Delay(uiTimeDelay);
+	}
+
+	if ( AVL_DVBSx_EC_OK == r )
+	{
+		r = AVL_DVBSx_II2C_Write(pAVLChip, pBuff, ucSize);   
+	}
+	r |= AVL_DVBSx_IBSP_ReleaseSemaphore(&(pAVLChip->m_semI2CRepeater));
+	return(r);
+}
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_II2CRepeater_Initialize( AVL_uint16 I2CBusClock_kHz, struct AVL_DVBSx_Chip * pAVLChip )
+{
+	AVL_uchar pBuff[5];
+	AVL_DVBSx_ErrorCode r;
+	r = AVL_DVBSx_II2C_Write16(pAVLChip, rc_i2cm_speed_kHz_addr, I2CBusClock_kHz);
+	ChunkAddr(i2cm_cmd_addr+I2CM_CMD_LENGTH-2, pBuff);
+	pBuff[3] = 0x01;
+	pBuff[4] = OP_I2CM_INIT;
+	r |= AVL_DVBSx_II2CRepeater_SendOP(pBuff, 5, pAVLChip);
+	return r;
+}
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_II2CRepeater_GetOPStatus( const struct AVL_DVBSx_Chip * pAVLChip )
+{
+	AVL_DVBSx_ErrorCode r;
+	AVL_uchar pBuff[2];
+	r = AVL_DVBSx_II2C_Read(pAVLChip, i2cm_cmd_addr+I2CM_CMD_LENGTH-2, pBuff, 2);
+	if ( AVL_DVBSx_EC_OK == r )
+	{
+		if ( pBuff[1] != 0 )
+		{
+			r = AVL_DVBSx_EC_Running;
+		}
+	}
+	return(r);
+}
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_II2CRepeater_ReadData( AVL_uchar ucSlaveAddr, AVL_puchar pucBuff, AVL_uint16 uiSize, struct AVL_DVBSx_Chip * pAVLChip )
+{
+	AVL_DVBSx_ErrorCode r;
+	AVL_uchar pBuff[I2CM_RSP_LENGTH];
+	AVL_uint16 uiTimeOut;
+	const AVL_uint16 uiTimeOutTh = 500;
+	const AVL_uint32 uiTimeDelay = 1;  
+
+	if ( uiSize > I2CM_RSP_LENGTH )
+	{
+		return(AVL_DVBSx_EC_GeneralFail);
+	}
+	r = AVL_DVBSx_IBSP_WaitSemaphore(&(pAVLChip->m_semI2CRepeater_r));
+
+	ChunkAddr(i2cm_cmd_addr+I2CM_CMD_LENGTH-4, pBuff);
+	pBuff[3] = 0x0;
+	pBuff[4] = (AVL_uchar)uiSize;
+	pBuff[5] = ucSlaveAddr;
+	pBuff[6] = OP_I2CM_READ;
+	r |= AVL_DVBSx_II2CRepeater_SendOP(pBuff, 7, pAVLChip);
+	if ( AVL_DVBSx_EC_OK == r )
+	{
+		uiTimeOut = 0;
+		do 
+		{
+			r |= AVL_DVBSx_IBSP_Delay(uiTimeDelay);
+			if ((++uiTimeOut) >= uiTimeOutTh)
+			{
+				r |= AVL_DVBSx_EC_TimeOut;
+				r |= AVL_DVBSx_IBSP_ReleaseSemaphore(&(pAVLChip->m_semI2CRepeater_r));
+				return(r);
+			}
+		} while ( AVL_DVBSx_EC_OK != AVL_DVBSx_II2CRepeater_GetOPStatus(pAVLChip) );
+
+		r |= AVL_DVBSx_II2C_Read(pAVLChip, i2cm_rsp_addr, pucBuff, uiSize);
+	}
+	r |= AVL_DVBSx_IBSP_ReleaseSemaphore(&(pAVLChip->m_semI2CRepeater_r));
+	return(r);
+}
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_II2CRepeater_ReadData_Multi(  AVL_uchar ucSlaveAddr, AVL_puchar pucBuff, AVL_uchar ucRegAddr, AVL_uint16 uiSize, struct AVL_DVBSx_Chip * pAVLChip )
+{
+   	AVL_DVBSx_ErrorCode r;
+	AVL_uchar pBuff[I2CM_RSP_LENGTH];
+	AVL_uint16 uiTimeOut;
+	const AVL_uint16 uiTimeOutTh = 500;
+	const AVL_uint32 uiTimeDelay = 1;
+
+	if ( uiSize > I2CM_RSP_LENGTH )
+	{
+		return(AVL_DVBSx_EC_GeneralFail);
+	}
+
+	r = AVL_DVBSx_IBSP_WaitSemaphore(&(pAVLChip->m_semI2CRepeater_r));
+
+	ChunkAddr(i2cm_cmd_addr+I2CM_CMD_LENGTH-6, pBuff);
+	pBuff[3] = 0;
+	pBuff[4] = ucRegAddr;
+	pBuff[5] = 0x1;
+	pBuff[6] = (AVL_uchar)uiSize;
+	pBuff[7] = ucSlaveAddr;
+	pBuff[8] = OP_I2CM_READ;
+	r |= AVL_DVBSx_II2CRepeater_SendOP(pBuff, 9, pAVLChip);
+	memset(pBuff,0,I2CM_RSP_LENGTH);
+	if ( AVL_DVBSx_EC_OK == r )
+	{
+		uiTimeOut = 0;
+		do 
+		{
+			r |= AVL_DVBSx_IBSP_Delay(uiTimeDelay);
+			if ((++uiTimeOut) >= uiTimeOutTh)
+			{
+				r |= AVL_DVBSx_EC_TimeOut;
+				r |= AVL_DVBSx_IBSP_ReleaseSemaphore(&(pAVLChip->m_semI2CRepeater_r));
+				return(r);
+			}
+		} while ( AVL_DVBSx_EC_OK != AVL_DVBSx_II2CRepeater_GetOPStatus(pAVLChip) );
+
+		r |= AVL_DVBSx_II2C_Read(pAVLChip, i2cm_rsp_addr, pucBuff, uiSize);
+	//	printf("pucBuff is %x,%x,%x,%x\n",pucBuff[0],pucBuff[1],pucBuff[2],pucBuff[3]);
+	}
+	r |= AVL_DVBSx_IBSP_ReleaseSemaphore(&(pAVLChip->m_semI2CRepeater_r));
+
+	return(r);
+}
+
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_II2CRepeater_SendData(  AVL_uchar ucSlaveAddr, const AVL_puchar pucBuff, AVL_uint16 uiSize, struct AVL_DVBSx_Chip * pAVLChip )
+{
+	AVL_uchar pBuff[I2CM_CMD_LENGTH+3];
+	AVL_uint16 i1, i2;
+	AVL_uint16 cmdSize;
+
+	if ( uiSize>I2CM_CMD_LENGTH-3 )
+	{
+		return(AVL_DVBSx_EC_GeneralFail);
+	}
+
+	cmdSize = ((3+uiSize)%2)+3+uiSize;	  /* How many bytes need send to Availink device through i2c interface */
+	ChunkAddr(i2cm_cmd_addr+I2CM_CMD_LENGTH-cmdSize, pBuff);
+
+	i1 = 3+((3+uiSize)%2);	  /* skip one byte if the uisize+3 is odd*/
+
+	for ( i2=0; i2<uiSize; i2++ )
+	{
+		pBuff[i1++] = pucBuff[i2];
+	}
+	pBuff[i1++] = (AVL_uchar)uiSize;
+	pBuff[i1++] = ucSlaveAddr;
+	pBuff[i1++] = OP_I2CM_WRITE;
+
+	return(AVL_DVBSx_II2CRepeater_SendOP(pBuff, (AVL_uchar)(cmdSize+3), pAVLChip));
+}
+
diff -Naur a/drivers/amlogic/dvb_tv/avl6211/src/IRx.c b/drivers/amlogic/dvb_tv/avl6211/src/IRx.c
--- a/drivers/amlogic/dvb_tv/avl6211/src/IRx.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/amlogic/dvb_tv/avl6211/src/IRx.c	2014-12-11 16:13:50.429615023 +0100
@@ -0,0 +1,584 @@
+/*
+ *           Copyright 2012 Availink, Inc.
+ *
+ *  This software contains Availink proprietary information and
+ *  its use and disclosure are restricted solely to the terms in
+ *  the corresponding written license agreement. It shall not be 
+ *  disclosed to anyone other than valid licensees without
+ *  written permission of Availink, Inc.
+ *
+ */
+
+
+///$Date: 2012-2-9 17:36 $
+///
+#include "IRx.h"
+#include "IBase.h"
+#include "II2C.h"
+#include "IBSP.h"
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_IRx_Initialize( const struct AVL_DVBSx_Chip * pAVLChip )
+{
+	AVL_DVBSx_ErrorCode r;
+
+	r = AVL_DVBSx_II2C_Write32(pAVLChip, 0x263E, 50000);
+
+	// Set clk to match the PLL 
+	r |= AVL_DVBSx_II2C_Write16(pAVLChip, rc_int_dmd_clk_MHz_addr,  pAVLChip->m_DemodFrequency_10kHz);
+	r |= AVL_DVBSx_II2C_Write16(pAVLChip, rc_int_fec_clk_MHz_addr, pAVLChip->m_FecFrequency_10kHz);
+	r |= AVL_DVBSx_II2C_Write16(pAVLChip, rc_int_mpeg_clk_MHz_addr, pAVLChip->m_MpegFrequency_10kHz);
+	r |= AVL_DVBSx_II2C_Write32(pAVLChip, rc_format_addr, 1);
+
+	return(r);
+}
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_IRx_SetFreqSweepRange( AVL_uint16 uiFreqSweepRange_10kHz, const struct AVL_DVBSx_Chip * pAVLChip )
+{
+	if(uiFreqSweepRange_10kHz > 500)
+	{
+		uiFreqSweepRange_10kHz = 500;
+	}
+	return AVL_DVBSx_II2C_Write16(pAVLChip, rc_int_carrier_freq_half_range_MHz_addr, uiFreqSweepRange_10kHz);
+}
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_IRx_SetChannelLockMode( struct AVL_DVBSx_Channel * psChannel, enum AVL_DVBSx_LockMode enumChannelLockMode )
+{
+	if(enumChannelLockMode == AVL_DVBSx_LOCK_MODE_FIXED)
+	{
+		psChannel->m_Flags &= ~CI_FLAG_LOCK_MODE_BIT_MASK;
+	}
+	else
+	{
+		psChannel->m_Flags |= CI_FLAG_LOCK_MODE_BIT_MASK;
+	}
+
+	return(AVL_DVBSx_EC_OK);
+}
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_IRx_LockChannel( struct AVL_DVBSx_Channel * psChannel, struct AVL_DVBSx_Chip * pAVLChip )
+{
+	AVL_DVBSx_ErrorCode r;
+	AVL_uint32 IQ;
+	AVL_uint32 autoIQ_Detect;
+	AVL_uint16 Standard;
+	AVL_uint16 auto_manual_lock;
+	AVL_uint16 Coderate;
+	AVL_uint16 Modulation;
+	enum AVL_DVBSx_LockMode LockMode;
+	enum AVL_DVBSx_FunctionalMode enumFunctionalMode;
+	r = AVL_DVBSx_EC_OK;
+
+	r |= AVL_DVBSx_IBase_GetFunctionalMode(&enumFunctionalMode, pAVLChip);
+	if(enumFunctionalMode == AVL_DVBSx_FunctMode_Demod)
+	{		
+		LockMode = (enum AVL_DVBSx_LockMode)((psChannel->m_Flags & CI_FLAG_LOCK_MODE_BIT_MASK) >> CI_FLAG_LOCK_MODE_BIT);
+		if(LockMode == AVL_DVBSx_LOCK_MODE_ADAPTIVE)
+		{
+			r |= AVL_DVBSx_II2C_Write16(pAVLChip, rc_lock_mode_addr, 1);
+			if(psChannel->m_uiSymbolRate_Hz < 3000000)
+			{
+				r |= AVL_DVBSx_IRx_SetFreqSweepRange(300, pAVLChip);
+			}
+			else
+			{
+				r |= AVL_DVBSx_IRx_SetFreqSweepRange(500, pAVLChip);
+			}
+		}
+		else
+		{
+			r |= AVL_DVBSx_II2C_Write16(pAVLChip, rc_lock_mode_addr, 0);
+		}
+		IQ = ((psChannel->m_Flags) & CI_FLAG_IQ_BIT_MASK)>>CI_FLAG_IQ_BIT;
+		r |= AVL_DVBSx_II2C_Write32(pAVLChip, rc_specinv_addr, IQ);
+		Standard = (AVL_uint16)(((psChannel->m_Flags) & CI_FLAG_DVBS2_BIT_MASK)>>CI_FLAG_DVBS2_BIT);
+		autoIQ_Detect = (((psChannel->m_Flags) & CI_FLAG_IQ_AUTO_BIT_MASK)>>CI_FLAG_IQ_AUTO_BIT);
+		auto_manual_lock = (((psChannel->m_Flags) & CI_FLAG_MANUAL_LOCK_MODE_BIT_MASK)>>CI_FLAG_MANUAL_LOCK_MODE_BIT);
+		if(auto_manual_lock == CI_FLAG_MANUAL_LOCK_MODE)
+		{
+			Coderate = ((psChannel->m_Flags) & CI_FLAG_CODERATE_BIT_MASK)>>CI_FLAG_CODERATE_BIT;
+			if(Standard == CI_FLAG_DVBS)
+			{
+				if (Coderate > 5)
+				{
+					return AVL_DVBSx_EC_GeneralFail;
+				}
+				r |= AVL_DVBSx_II2C_Write32(pAVLChip, rc_fec_coderate_addr, Coderate);
+			}
+			else if(Standard == CI_FLAG_DVBS2)
+			{
+				Modulation = ((psChannel->m_Flags) & CI_FLAG_MODULATION_BIT_MASK)>>CI_FLAG_MODULATION_BIT;
+				if (Coderate > 16 || Coderate <= 5 || Modulation > 3)
+				{
+					return AVL_DVBSx_EC_GeneralFail;
+				}
+				r |= AVL_DVBSx_II2C_Write16(pAVLChip, rc_s2_coderate, Coderate);
+				r |= AVL_DVBSx_II2C_Write16(pAVLChip, rc_s2_modulation, Modulation);
+			}
+			else
+				return AVL_DVBSx_EC_GeneralFail;
+		}
+		else
+		{
+			if(Standard == CI_FLAG_DVBS2_UNDEF || autoIQ_Detect == 1)
+			{
+				Standard = 0x14;
+			}
+		}
+		r |= AVL_DVBSx_II2C_Write16(pAVLChip, rc_fec_bypass_coderate_addr, auto_manual_lock);
+		r |= AVL_DVBSx_II2C_Write16(pAVLChip, rc_decode_mode_addr, Standard);
+		r |= AVL_DVBSx_II2C_Write16(pAVLChip, rc_iq_mode_addr, (AVL_uint16)autoIQ_Detect);
+		r |= AVL_DVBSx_II2C_Write32(pAVLChip, rc_int_sym_rate_MHz_addr, psChannel->m_uiSymbolRate_Hz);
+		r |= AVL_DVBSx_IBase_SendRxOP(OP_RX_INIT_GO, pAVLChip );
+	}
+	else
+	{
+		r = AVL_DVBSx_EC_GeneralFail;
+	}
+
+	return(r);
+}
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_IRx_GetLockStatus( AVL_puint16 puiLockStatus, const struct AVL_DVBSx_Chip * pAVLChip )
+{
+	AVL_DVBSx_ErrorCode r;
+	r = AVL_DVBSx_II2C_Read16(pAVLChip, rs_fec_lock_addr, puiLockStatus);
+	return(r);
+}
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_IRx_ResetErrorStat( struct AVL_DVBSx_Chip * pAVLChip )
+{
+	enum AVL_DVBSx_FunctionalMode enumFunctionalMode;
+	AVL_DVBSx_ErrorCode r;
+
+	r = AVL_DVBSx_IBase_GetFunctionalMode(&enumFunctionalMode, pAVLChip);
+
+	if(enumFunctionalMode == AVL_DVBSx_FunctMode_Demod)
+	{
+		r |= AVL_DVBSx_IBase_SendRxOP( OP_RX_RESET_BERPER, pAVLChip );
+	}
+	else
+	{
+		r = AVL_DVBSx_EC_GeneralFail;
+	}
+
+	return(r);   
+}
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_IRx_SetRFAGCPola( enum AVL_DVBSx_RfagcPola enumAGCPola, const struct AVL_DVBSx_Chip * pAVLChip )
+{
+	AVL_DVBSx_ErrorCode r;
+	AVL_uint32 uiTemp;
+	uiTemp = (AVL_uint32)enumAGCPola;
+	r = AVL_DVBSx_II2C_Write32(pAVLChip, rc_rfagc_pol_addr, uiTemp);
+	return(r);
+}
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_IRx_SetMpegMode( const struct AVL_DVBSx_MpegInfo * pMpegMode, const struct AVL_DVBSx_Chip * pAVLChip )
+{
+	AVL_DVBSx_ErrorCode r;
+
+	r = AVL_DVBSx_II2C_Write32(pAVLChip, rc_mpeg_mode_addr, (AVL_uint32)(pMpegMode->m_MpegFormat));
+	r |= AVL_DVBSx_II2C_Write16(pAVLChip, rc_mpeg_serial_addr, (AVL_uint16)(pMpegMode->m_MpegMode));
+	r |= AVL_DVBSx_II2C_Write16(pAVLChip, rc_mpeg_posedge_addr, (AVL_uint16)(pMpegMode->m_MpegClockPolarity));
+
+	return(r);
+}
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_IRx_SetMpegValidPolarity( const struct AVL_DVBSx_Chip * pAVLChip, enum AVL_DVBSx_MpegValidPolarity enumValidPolarity )
+{
+	AVL_DVBSx_ErrorCode r = AVL_DVBSx_EC_OK;
+	AVL_uint16 uiTemp;
+
+	r |= AVL_DVBSx_II2C_Read16(pAVLChip, rp_mpeg_config_addr, &uiTemp);
+	uiTemp &= 0xFFFE;
+	uiTemp |= (AVL_uint16)enumValidPolarity;
+	r |= AVL_DVBSx_II2C_Write16(pAVLChip, rp_mpeg_config_addr, uiTemp);
+
+	return(r);
+}
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_IRx_SetMpegErrorPolarity(const struct AVL_DVBSx_Chip * pAVLChip, enum AVL_DVBSx_MpegErrorPolarity enumErrorLockPolarity, enum AVL_DVBSx_MpegErrorPolarity enumErrorUnlockPolarity)
+{
+	AVL_DVBSx_ErrorCode r = AVL_DVBSx_EC_OK;
+	AVL_uint16 uiTemp;
+
+	r |= AVL_DVBSx_II2C_Read16(pAVLChip, rp_mpeg_config_addr, &uiTemp);
+	uiTemp &= 0xFFF3;
+	uiTemp |= (enumErrorLockPolarity << 2);
+	uiTemp |= (enumErrorUnlockPolarity << 3);
+	r |= AVL_DVBSx_II2C_Write16(pAVLChip, rp_mpeg_config_addr, uiTemp);
+
+	return(r);
+}
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_IRx_SetMpegBitOrder( const struct AVL_DVBSx_Chip * pAVLChip, enum AVL_DVBSx_MpegMode enumMpegMode, enum AVL_DVBSx_MpegBitOrder enumMpegBitOrder )
+{
+	AVL_uint16 uiTemp;
+	AVL_DVBSx_ErrorCode r = AVL_DVBSx_EC_OK;
+
+	r |= AVL_DVBSx_II2C_Read16(pAVLChip, rp_mpeg_config_addr, &uiTemp);
+	uiTemp &= 0xFFFD;
+	if(enumMpegMode == AVL_DVBSx_MPM_Serial)
+	{
+		AVL_DVBSx_II2C_Write32(pAVLChip, rc_mpeg_seri_seq_addr, (AVL_uint32)enumMpegBitOrder);	
+	}
+	else
+	{
+		uiTemp |= ((AVL_uint16)enumMpegBitOrder << 1);
+	}
+	r |= AVL_DVBSx_II2C_Write16(pAVLChip, rp_mpeg_config_addr, uiTemp);
+
+	return(r);
+}
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_IRx_SetMpegSerialPin( const struct AVL_DVBSx_Chip * pAVLChip, enum AVL_DVBSx_MpegSerialPin enumSerialPin )
+{
+	AVL_DVBSx_ErrorCode r = AVL_DVBSx_EC_OK;
+
+	r |= AVL_DVBSx_II2C_Write32(pAVLChip, rc_outpin_sel_addr, enumSerialPin);
+
+	return(r);
+}
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_IRx_GetSignalLevel( AVL_puint16 puiRFSignalLevel , const struct AVL_DVBSx_Chip * pAVLChip )
+{
+	AVL_uint32 uiData;
+	AVL_uint16 uiSignalLevel;
+	AVL_DVBSx_ErrorCode r;
+
+	r = AVL_DVBSx_II2C_Read32(pAVLChip, (rx_aagc_gain), &uiData);
+
+	if( AVL_DVBSx_EC_OK == r )
+	{
+		uiData += 0x800000;
+		uiData &= 0xffffff;	
+		uiSignalLevel = (AVL_uint16)(uiData>>8);
+		*puiRFSignalLevel = uiSignalLevel;
+	}
+	return(r);
+}
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_IRx_GetScatterData( AVL_puchar ucpData, AVL_puint16 puiSize, const struct AVL_DVBSx_Chip * pAVLChip )
+{
+	AVL_uint16 ucTemp1, ucTemp2;
+	AVL_DVBSx_ErrorCode r;
+	r = AVL_DVBSx_II2C_Read16(pAVLChip, rs_ScatterData_rdy_addr, &ucTemp1);
+	r |= AVL_DVBSx_II2C_Read16(pAVLChip, scatter_data_addr, &ucTemp2);
+	if( (AVL_DVBSx_EC_OK != r) || (0 == ucTemp1) )
+	{
+		return(AVL_DVBSx_EC_Running);
+	}
+	if( ucTemp2>(*puiSize) )
+	{
+		ucTemp2 = (*puiSize);
+	}
+	else
+	{
+		(*puiSize) = ucTemp2;
+	}
+
+	r = AVL_DVBSx_II2C_Read(pAVLChip, scatter_data_addr+2, ucpData, (AVL_uint16)(ucTemp2<<1)); //both i and q
+	ucTemp1 = 0;
+	r |= AVL_DVBSx_II2C_Write16(pAVLChip, rs_ScatterData_rdy_addr, ucTemp1);
+	return(r);
+}
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_IRx_GetSNR( AVL_puint32 puiSNR_db, const struct AVL_DVBSx_Chip * pAVLChip )
+{
+	AVL_DVBSx_ErrorCode r;
+	r = AVL_DVBSx_II2C_Read32(pAVLChip, rs_int_SNR_dB_addr, puiSNR_db);
+	if( (*puiSNR_db) > 10000 )
+	{
+		// Not get stable SNR value yet.
+		*puiSNR_db = 0;
+	}
+	return(r);
+}
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_IRx_GetPER( AVL_puint32 puiPER, const struct AVL_DVBSx_Chip * pAVLChip )
+{
+	AVL_DVBSx_ErrorCode r;
+	AVL_uint32 hw_packets;
+	AVL_uint32 hw_errors;
+	struct AVL_uint64 ui64ErrTemp;
+	struct AVL_uint64 ui64Packets;
+
+	r = AVL_DVBSx_II2C_Read32(pAVLChip, rc_pkt_err_count_addr, &hw_errors);
+	r |= AVL_DVBSx_II2C_Read32(pAVLChip, rc_pkt_count_addr, &hw_packets);
+
+	if((hw_packets != 0) && (hw_errors != 0))
+	{
+		Multiply32(&ui64ErrTemp, hw_errors, AVL_CONSTANT_10_TO_THE_9TH);
+		ui64Packets.m_HighWord = 0;
+		ui64Packets.m_LowWord = 0;
+		Add32To64(&ui64Packets, hw_packets);
+		*puiPER = Divide64( ui64Packets, ui64ErrTemp); 
+	}
+	else
+	{
+		*puiPER = 0;
+	}
+
+	return(r);
+}
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_IRx_GetBER( AVL_puint32 puiBER, const struct AVL_DVBSx_Chip * pAVLChip )
+{
+	AVL_DVBSx_ErrorCode r;
+	r = AVL_DVBSx_II2C_Read32(pAVLChip, rp_uint_BER_addr, puiBER);
+	return(r);
+}
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_IRx_GetDVBSBER( AVL_puint32 puiBER, const struct AVL_DVBSx_Chip * pAVLChip )
+{
+	AVL_DVBSx_ErrorCode r;
+
+	r = AVL_DVBSx_II2C_Read32(pAVLChip, rc_dvbs_ber_addr, puiBER);
+	if( 0xffffffff == (*puiBER) )
+	{
+		r |= AVL_DVBSx_EC_GeneralFail;
+	}
+	return(r);
+}
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_IRx_ResetDVBSBER( const struct AVL_DVBSx_Chip * pAVLChip )
+{
+	AVL_DVBSx_ErrorCode r;
+	r = AVL_DVBSx_II2C_Write32(pAVLChip, rc_dvbs_ber_addr, 0xffffffff);
+	return(r);
+}
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_IRx_GetRFOffset( AVL_pint16 piRFOffset_100kHz, const struct AVL_DVBSx_Chip * pAVLChip )
+{
+	AVL_DVBSx_ErrorCode r;
+	r = AVL_DVBSx_II2C_Read16(pAVLChip, rs_int_carrier_freq_100kHz_addr, (AVL_puint16)piRFOffset_100kHz);
+	return(r);
+}
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_IRx_GetSignalInfo( struct AVL_DVBSx_SignalInfo * pSignalInfo, const struct AVL_DVBSx_Chip * pAVLChip )
+{
+	AVL_DVBSx_ErrorCode r = AVL_DVBSx_EC_OK;
+	AVL_uint32 uiTemp;
+	r |= AVL_DVBSx_II2C_Read32(pAVLChip, rs_pilot_addr, &uiTemp);
+	pSignalInfo->m_pilot = (enum AVL_DVBSx_Pilot)(uiTemp);
+	r |= AVL_DVBSx_II2C_Read32(pAVLChip, rs_code_rate_addr, &uiTemp);
+	pSignalInfo->m_coderate = (enum AVL_DVBSx_FecRate)(uiTemp);
+	r |= AVL_DVBSx_II2C_Read32(pAVLChip, rs_modulation_addr, &uiTemp);
+	pSignalInfo->m_modulation = (enum AVL_DVBSx_ModulationMode)(uiTemp);
+	r |= AVL_DVBSx_II2C_Read32(pAVLChip, rx_Rolloff_addr, &uiTemp);
+	pSignalInfo->m_rolloff = (enum AVL_DVBSx_RollOff)((uiTemp>>22) & 0x03);
+	return(r);
+}
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_IRx_SetDishPointingMode( AVL_uchar ucMode, const struct AVL_DVBSx_Chip *pAVLChip )
+{
+	AVL_DVBSx_ErrorCode r = AVL_DVBSx_EC_OK;
+	enum AVL_DVBSx_FunctionalMode enumFunctionalMode;
+
+	r |= AVL_DVBSx_IBase_GetFunctionalMode(&enumFunctionalMode, pAVLChip);
+	if(enumFunctionalMode == AVL_DVBSx_FunctMode_Demod)
+	{
+		if(ucMode == 1)
+		{
+			r |= AVL_DVBSx_II2C_Write16(pAVLChip, rc_aagc_acq_gain_addr, 12);
+			r |= AVL_DVBSx_II2C_Write16(pAVLChip, rc_dishpoint_mode_addr, 1);
+		}
+		else
+		{
+			r |= AVL_DVBSx_II2C_Write16(pAVLChip, rc_aagc_acq_gain_addr, 10);
+			r |= AVL_DVBSx_II2C_Write16(pAVLChip, rc_dishpoint_mode_addr, 0);
+		}
+	}
+	else
+	{
+		r = AVL_DVBSx_EC_GeneralFail;
+	}
+
+	return(r);
+}
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_IRx_DriveMpegOutput( const struct AVL_DVBSx_Chip * pAVLChip )
+{
+	AVL_DVBSx_ErrorCode r;
+
+	r = AVL_DVBSx_II2C_Write32(pAVLChip, rc_mpeg_bus_tri_enb, 1);
+
+	return(r);
+}
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_IRx_ReleaseMpegOutput( const struct AVL_DVBSx_Chip * pAVLChip )
+{
+	AVL_DVBSx_ErrorCode r;
+
+	r = AVL_DVBSx_II2C_Write32(pAVLChip, rc_mpeg_bus_tri_enb, 0);
+
+	return(r);
+}
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_IRx_EnableMpegPersistentClockMode( AVL_uint16 uiMpegDataClkFreq_10kHz, const struct AVL_DVBSx_Chip *pAVLChip )
+{
+	AVL_DVBSx_ErrorCode r = AVL_DVBSx_EC_OK;
+
+	uiMpegDataClkFreq_10kHz |= 0x8000;
+	r |= AVL_DVBSx_II2C_Write16(pAVLChip, rc_mpeg_continuous_mode_control_addr, uiMpegDataClkFreq_10kHz);
+
+	return(r);
+}
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_IRx_DisableMpegPersistentClockMode( const struct AVL_DVBSx_Chip *pAVLChip )
+{
+	AVL_DVBSx_ErrorCode r = AVL_DVBSx_EC_OK;
+
+	r |= AVL_DVBSx_II2C_Write16(pAVLChip, rc_mpeg_continuous_mode_control_addr, 0);
+
+	return(r);
+}
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_IRx_EnableMpegManualClockFrequency( AVL_uint16 uiMpegDataClkFreq_10kHz, enum AVL_DVBSx_MpegMode enumMpegMode, const struct AVL_DVBSx_Chip * pAVLChip ) 
+{
+	AVL_DVBSx_ErrorCode r = AVL_DVBSx_EC_OK;
+	AVL_uint16 uiMpegRefClkFreq;
+	AVL_uint32 uiTemp;
+	r = AVL_DVBSx_II2C_Read32(pAVLChip, rc_mpeg_bus_cntrl_addr, &uiTemp );
+	uiTemp |= 0x00000800;
+	r |=AVL_DVBSx_II2C_Write32(pAVLChip, rc_mpeg_bus_cntrl_addr, uiTemp );
+
+	r |= AVL_DVBSx_II2C_Read16(pAVLChip, rc_int_mpeg_clk_MHz_addr, &uiMpegRefClkFreq);
+	r |= AVL_DVBSx_II2C_Write32(pAVLChip, rc_cntns_pkt_para_rate_frac_n_addr,(AVL_uint32)(uiMpegDataClkFreq_10kHz << 1));		
+	r |= AVL_DVBSx_II2C_Write32(pAVLChip, rc_cntns_pkt_para_rate_frac_d_addr, (AVL_uint32)uiMpegRefClkFreq);		
+	if(enumMpegMode == AVL_DVBSx_MPM_Serial)
+	{
+		r |= AVL_DVBSx_II2C_Write32(pAVLChip, rc_pkt_seri_rate_frac_n_addr, (AVL_uint32)((uiMpegDataClkFreq_10kHz/8)<< 4));		
+		r |= AVL_DVBSx_II2C_Write32(pAVLChip, rc_pkt_seri_rate_frac_d_addr, (AVL_uint32)uiMpegRefClkFreq);		
+	}
+
+	return(r);
+}
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_IRx_DisableMpegManualClockFrequency( const struct AVL_DVBSx_Chip * pAVLChip )
+{
+	AVL_uint32 uiTemp;
+	AVL_DVBSx_ErrorCode r = AVL_DVBSx_EC_OK;
+
+	r = AVL_DVBSx_II2C_Read32(pAVLChip, rc_mpeg_bus_cntrl_addr, &uiTemp );
+	uiTemp &= 0xFFFFF7FF;
+	r |= AVL_DVBSx_II2C_Write32(pAVLChip, rc_mpeg_bus_cntrl_addr, uiTemp );
+
+	return(r);
+}
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_IRx_SetMpegPulldown( const struct AVL_DVBSx_Chip *pAVLChip, enum AVL_DVBSx_MpegPulldown enumPulldownState )
+{
+	AVL_DVBSx_ErrorCode r;
+
+	r = AVL_DVBSx_EC_OK;
+	if(enumPulldownState == AVL_DVBSx_MPPD_Disable)
+	{
+		r |= AVL_DVBSx_II2C_Write32(pAVLChip, rc_mpeg_bus_pe, 0);
+	}
+	else
+	{
+		r |= AVL_DVBSx_II2C_Write32(pAVLChip, rc_mpeg_bus_pe, 0xFFF);
+	}
+
+	return(r);
+}
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_IRx_DriveRFAGC( const struct AVL_DVBSx_Chip * pAVLChip )
+{
+	AVL_DVBSx_ErrorCode r = AVL_DVBSx_EC_OK;
+
+	r = AVL_DVBSx_II2C_Write16(pAVLChip, rc_aagc_ref_addr, 0x30);
+	r |= AVL_DVBSx_II2C_Write32(pAVLChip, rc_rfagc_tri_enb, 1);
+	
+	return(r);
+}
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_IRx_ReleaseRFAGC( const struct AVL_DVBSx_Chip * pAVLChip )
+{
+	AVL_DVBSx_ErrorCode r = AVL_DVBSx_EC_OK;
+
+	r = AVL_DVBSx_II2C_Write32(pAVLChip, rc_rfagc_tri_enb, 0);
+	
+	return(r);
+}
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_IRx_GetIQ_Imbalance( const struct AVL_DVBSx_Chip * pAVLChip, AVL_pint16 piAmplitude, AVL_pint16 piPhase )
+{
+	AVL_DVBSx_ErrorCode r = AVL_DVBSx_EC_OK;
+
+	r |= AVL_DVBSx_II2C_Read16(pAVLChip, rp_amp_imb_addr, (AVL_puint16)piAmplitude);
+	r |= AVL_DVBSx_II2C_Read16(pAVLChip, rp_phase_imb_addr, (AVL_puint16)piPhase);
+
+	return(r);
+}
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_IRx_GetDeviceID( const struct AVL_DVBSx_Chip * pAVLChip, AVL_puint32 puiDeviceID)
+{
+	AVL_DVBSx_ErrorCode r = AVL_DVBSx_EC_OK;
+
+	r = AVL_DVBSx_II2C_Read32(pAVLChip, rs_cust_chip_id_addr, puiDeviceID);
+
+	return(r);
+}
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_IRx_SetAdaptivePowerSaveMode( struct AVL_DVBSx_Channel * psChannel, AVL_uint16 uiEnable )
+{
+	if(uiEnable == 0)
+	{
+		psChannel->m_Flags &= ~CI_FLAG_ADAPTIVE_POWER_SAVE_BIT_MASK;
+	}
+	else
+	{
+		psChannel->m_Flags |= CI_FLAG_ADAPTIVE_POWER_SAVE_BIT_MASK;
+	}
+
+	return(AVL_DVBSx_EC_OK);
+}
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_IRx_GetIQ_Swap( const struct AVL_DVBSx_Chip * pAVLChip, AVL_puint16 puiIQ_Swap )
+{
+	AVL_DVBSx_ErrorCode r = AVL_DVBSx_EC_OK;
+	AVL_uint32 uiTemp1, uiTemp2;
+
+	r |= AVL_DVBSx_II2C_Read32(pAVLChip, rc_specinv_addr, &uiTemp1);
+	r |= AVL_DVBSx_II2C_Read32(pAVLChip, rc_eq_out_iq_swap_addr, &uiTemp2);
+	*puiIQ_Swap = (AVL_uint16)(uiTemp1 ^ uiTemp2);
+
+	return(r);
+}
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_IRx_GetRSError( AVL_puint32  puiRSErr, const struct AVL_DVBSx_Chip * pAVLChip )
+{
+	AVL_DVBSx_ErrorCode r;
+	AVL_uint32 rs_total_words, rs_total_errors;
+	struct AVL_uint64 ui64ErrTemp;
+	struct AVL_uint64 ui64Words;
+
+	r = AVL_DVBSx_II2C_Read32(pAVLChip, rs_total_words_addr, &rs_total_words);
+	r |= AVL_DVBSx_II2C_Read32(pAVLChip, rs_total_uncorrected_words_addr, &rs_total_errors);
+
+	if((rs_total_words != 0) && (rs_total_errors != 0))
+	{
+		Multiply32(&ui64ErrTemp, rs_total_errors, AVL_CONSTANT_10_TO_THE_9TH);
+		ui64Words.m_HighWord = 0;
+		ui64Words.m_LowWord = 0;
+		Add32To64(&ui64Words, rs_total_words);
+		*puiRSErr = Divide64( ui64Words, ui64ErrTemp); 
+	}
+	else
+	{
+		*puiRSErr = 0;
+	}
+
+	return (r);
+}
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_IRx_GetErrPacket( AVL_puint32 puiErrPacket, const struct AVL_DVBSx_Chip * pAVLChip )
+{
+	AVL_DVBSx_ErrorCode r;
+
+	r = AVL_DVBSx_II2C_Read32(pAVLChip, rc_pkt_err_count_addr, puiErrPacket);
+
+	return(r);
+}
diff -Naur a/drivers/amlogic/dvb_tv/avl6211/src/ITuner.c b/drivers/amlogic/dvb_tv/avl6211/src/ITuner.c
--- a/drivers/amlogic/dvb_tv/avl6211/src/ITuner.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/amlogic/dvb_tv/avl6211/src/ITuner.c	2014-12-11 16:13:50.245616432 +0100
@@ -0,0 +1,27 @@
+/*
+ *           Copyright 2012 Availink, Inc.
+ *
+ *  This software contains Availink proprietary information and
+ *  its use and disclosure are restricted solely to the terms in
+ *  the corresponding written license agreement. It shall not be 
+ *  disclosed to anyone other than valid licensees without
+ *  written permission of Availink, Inc.
+ *
+ */
+
+
+///$Date: 2012-2-9 17:36 $
+///
+#include "avl_dvbsx.h"
+#include "ITuner.h"
+#include "II2C.h"
+
+AVL_DVBSx_ErrorCode AVL_DVBSx_ITuner_CalculateLPF(AVL_uint16 uiSymbolRate_10kHz, struct AVL_Tuner * pTuner)
+{
+	AVL_uint32 lpf = uiSymbolRate_10kHz;
+	lpf *= 675;			//roll off = 0.35
+	lpf /= 10000;
+	lpf += 30;
+	pTuner->m_uiLPF_100kHz = (AVL_uint16)lpf;
+	return(AVL_DVBSx_EC_OK);
+}
diff -Naur a/drivers/amlogic/dvb_tv/avl6211/src/LockSignal_Api.c b/drivers/amlogic/dvb_tv/avl6211/src/LockSignal_Api.c
--- a/drivers/amlogic/dvb_tv/avl6211/src/LockSignal_Api.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/amlogic/dvb_tv/avl6211/src/LockSignal_Api.c	2014-12-11 16:13:50.289616089 +0100
@@ -0,0 +1,704 @@
+/*
+ *           Copyright 2012 Availink, Inc.
+ *
+ *  This software contains Availink proprietary information and
+ *  its use and disclosure are restricted solely to the terms in
+ *  the corresponding written license agreement. It shall not be 
+ *  disclosed to anyone other than valid licensees without
+ *  written permission of Availink, Inc.
+ *
+ */
+
+
+///$Date: 2012-2-9 17:36 $
+///
+//#include "stdio.h"
+#include "IBSP.h"
+#include "avl_dvbsx.h"
+#include "IBase.h"
+#include "IRx.h"
+#include "ITuner.h"
+#include "ExtSharpBS2S7HZ6306.h"
+#include "II2C.h"
+#include "IDiseqc.h"
+#include "IBlindScan.h"
+#include "LockSignal_Api.h"
+#include "ExtAV2011.h"
+#include "ucPatchData.h"
+
+
+struct Signal_Level  SignalLevel [47]=
+{
+	{8285,	-922},{10224,	-902},{12538,	-882},{14890,	-862},{17343,	-842},{19767,	-822},{22178,	-802},{24618,	-782},{27006,	-762},{29106,	-742},
+	{30853,	-722},{32289,	-702},{33577,	-682},{34625,	-662},{35632,	-642},{36552,	-622},{37467,	-602},{38520,	-582},{39643,	-562},{40972,	-542},
+	{42351,	-522},{43659,	-502},{44812,	-482},{45811,	-462},{46703,	-442},{47501,	-422},{48331,	-402},{49116,	-382},{49894,	-362},{50684,	-342},
+	{51543,	-322},{52442,	-302},{53407,	-282},{54314,	-262},{55208,	-242},{56000,	-222},{56789,	-202},{57544,	-182},{58253,	-162},{58959,	-142},
+	{59657,	-122},{60404,	-102},{61181,	-82},{62008,	-62},{63032,	-42},{65483,	-22},{65535,	-12}
+
+};
+
+extern const unsigned char ucPatchData [];
+
+
+//extern AVL_uchar ucPatchData [];				//Defined in AVL6211_patch.dat.cpp.
+//extern struct Signal_Level  SignalLevel [47];   //Defined in SignalLevel.cpp
+
+#define Chip_ID					0x0F //0x01000002			//The Chip ID of AVL6211.
+#define Diseqc_Tone_Frequency   22					//The DiSEqC bus speed in the unit of kHz. Normally, it should be 22kHz. 
+#define IQ_Swap					Auto				//Controls the IQ swap setting			enum AVL_DVBS_IQ_Swap
+#define standard				DVBS2				//Controls the standard setting			enum AVL_DVBS_standard
+
+#define FontEnd_MaxCount 2
+struct AVL_DVBSx_Chip  g_stAvlDVBSxChip[FontEnd_MaxCount];
+struct AVL_Tuner g_stTuner[FontEnd_MaxCount];
+
+enum AVL_DVBS_IQ_Swap
+{
+	Normal,						//< = 0 The received signal spectrum is not inverted.
+	Invert,						//< = 1 The received signal spectrum is inverted.
+	Auto						//< = 2 The demodulator will automatically detect the received signal spectrum.
+};
+
+enum AVL_DVBS_standard
+{
+	DVBS,
+	DVBS2,
+};
+
+enum AVL_Demod_ReferenceClock_Select_t
+{
+	Ref_clock_4M=0,
+	Ref_clock_4M5=1,
+	Ref_clock_10M=2,
+	Ref_clock_16M=3,
+	Ref_clock_27M=4,
+	Ref_clock_Enhance_4M=5,
+	Ref_clock_Enhance_4M5=6,
+	Ref_clock_Enhance_10M=7,
+	Ref_clock_Enhance_16M=8,
+	Ref_clock_Enhance_27M=9,
+};
+
+enum AVL_TunerLPF_Calculation_Flag
+{
+	InputLPF = 0,
+	InputSymbolRate = 1,
+};
+
+struct AVL_Demod_Tuner_Configuration_t
+{
+	////////////////////////////Demod Configure///////////////////////////////
+
+	AVL_char m_ChannelId;												///< Bus identifier.
+	AVL_uint16 m_uiDemodAddress;										///< Device I2C slave address.
+	enum AVL_Demod_ReferenceClock_Select_t   m_DemodReferenceClk;		///< Configures the Availink device's PLL.Refer to enum AVL_Demod_ReferenceClock_Select_t
+
+	///< The MPEG output mode. The default value in the Availink device is \a AVL_DVBSx_MPM_Parallel
+	enum AVL_DVBSx_MpegMode m_TSOutPutMode;								///< AVL_DVBSx_MPM_Parallel = 0;	Output MPEG data in parallel mode
+																		///< AVL_DVBSx_MPM_Serial = 1;		Output MPEG data in serial mode
+
+	///< The MPEG output clock polarity. The clock polarity should be configured to meet the back end device's requirement.The default value in the Availink device is \a AVL_DVBSx_MPCP_Rising.
+	enum AVL_DVBSx_MpegClockPolarity m_TSClockPolarity;					///< AVL_DVBSx_MPCP_Falling = 0;	The MPEG data is valid on the falling edge of the clock.
+																		///< AVL_DVBSx_MPCP_Rising = 1;		The MPEG data is valid on the rising edge of the clock.
+
+	///< The MPEG output format. The default value in the Availink device is \a AVL_DVBSx_MPF_TS
+	enum AVL_DVBSx_MpegFormat m_TSFormat;								///< AVL_DVBSx_MPF_TS = 0;		Transport stream format.
+																		///< AVL_DVBSx_MPF_TSP = 1;		Transport stream plus parity format.
+
+	///< Defines the pin on which the Availink device outputs the MPEG data when the MPEG interface has been configured to operate in serial mode.
+	enum AVL_DVBSx_MpegSerialPin m_SerDataPin;							///< AVL_DVBSx_MPSP_DATA0 = 0;		Serial data is output on pin MPEG_DATA_0
+																		///< AVL_DVBSx_MPSP_DATA7 = 1;		Serial data is output on pin MPEG_DATA_7
+	
+	////////////////////////////Tuner Configure///////////////////////////////
+
+	AVL_uint16 m_uiTunerAddress;										///< Tuner I2C slave address.
+	AVL_uint16 m_uiTuner_I2Cbus_clock;									///< The clock speed of the tuner dedicated I2C bus, in a unit of kHz.
+	AVL_uint16 m_uiTunerMaxLPF_100Khz;									///< The max low pass filter bandwidth of the tuner.
+
+	///< Defines the LPF's forms of computation.
+	enum AVL_TunerLPF_Calculation_Flag m_LPF_Config_flag;				///< InputLPF = 0;			The LPF will be calculated by formula which defined by user.
+																		///< InputSymbolRate = 1;	The LPF will be calculated in tuner driver according to the SymbolRate.
+
+	///< Defines the polarity of the RF AGC control signal.The polarity of the RF AGC control signal must be configured to match that required by the tuner.
+	enum AVL_DVBSx_RfagcPola m_TunerRFAGC;								///< AVL_DVBSx_RA_Normal = 0;	Normal polarization. This setting is used for a tuner whose gain increases with increased AGC voltage.
+																		///< AVL_DVBSx_RA_Invert = 1;	Inverted polarization. The default value. Most tuners fall into this category.  This setting is used for a tuner whose gain decreases with increased AGC voltage.
+
+	///< Defines the device spectrum polarity setting. 
+	enum AVL_DVBSx_SpectrumPolarity m_Tuner_IQ_SpectrumMode;			///< AVL_DVBSx_Spectrum_Normal = 0;	The received signal spectrum is not inverted.
+																		///< AVL_DVBSx_Spectrum_Invert = 1;	The received signal spectrum is inverted.
+
+	AVL_DVBSx_ErrorCode (* m_pInitializeFunc)(struct AVL_Tuner *);	 	///< A pointer to the tuner initialization function.
+	AVL_DVBSx_ErrorCode (* m_pGetLockStatusFunc)(struct AVL_Tuner *); 	///< A pointer to the tuner GetLockStatus function.
+	AVL_DVBSx_ErrorCode (* m_pLockFunc)(struct AVL_Tuner *);			///< A pointer to the tuner Lock function.      
+};
+
+
+/*Here please according to customer needs, defining the array index*/
+
+static AVL_char g_nDemodTunerArrayIndex = 0;
+
+struct AVL_Demod_Tuner_Configuration_t g_DemodTuner_Config[]=
+{
+	{
+			0,
+			AVL_DVBSx_SA_0,
+			Ref_clock_27M,
+#ifdef AVL6211_OUTPUT_SERIAL	
+			AVL_DVBSx_MPM_Serial,
+#else
+			AVL_DVBSx_MPM_Parallel,
+#endif
+			AVL_DVBSx_MPCP_Rising,//AVL_DVBSx_MPCP_Rising,
+			AVL_DVBSx_MPF_TS,
+			AVL_DVBSx_MPSP_DATA0,										
+
+			0xC0,
+			200,
+			440,
+			InputSymbolRate,
+			AVL_DVBSx_RA_Invert,
+			#if defined(CONFIG_AVLINK_SPECTRUM_INVERT)
+			AVL_DVBSx_Spectrum_Invert,
+			#else
+			AVL_DVBSx_Spectrum_Normal,
+			#endif
+			&AVL_DVBSx_ExtAV2011_Initialize,
+			&AVL_DVBSx_ExtAV2011_GetLockStatus,
+			&AVL_DVBSx_ExtAV2011_Lock,
+	},
+	{
+			1,
+			AVL_DVBSx_SA_0,
+			Ref_clock_27M,
+			AVL_DVBSx_MPM_Parallel,
+			AVL_DVBSx_MPCP_Rising,
+			AVL_DVBSx_MPF_TS,
+			AVL_DVBSx_MPSP_DATA0,
+
+			0xC0,
+			200,
+			440,
+			InputSymbolRate,
+			AVL_DVBSx_RA_Invert,
+			#if defined(CONFIG_AVLINK_SPECTRUM_INVERT)
+			AVL_DVBSx_Spectrum_Invert,
+			#else
+			AVL_DVBSx_Spectrum_Normal,
+			#endif
+			&AVL_DVBSx_ExtAV2011_Initialize,
+			&AVL_DVBSx_ExtAV2011_GetLockStatus,
+			&AVL_DVBSx_ExtAV2011_Lock,
+	},
+};
+
+
+AVL_uchar DVBS_SNR[6] ={12,32,41,52,58,62};
+AVL_uchar DVBS2Qpsk_SNR[8] ={10,24,32,41,47,52,63,65};
+AVL_uchar DVBS28psk_SNR[6] ={57,67,80,95,100,110};
+
+int AVL_Get_Quality_Percent(struct AVL_DVBSx_Chip * pAVLChip)
+{
+    AVL_DVBSx_ErrorCode r=AVL_DVBSx_EC_OK;
+    AVL_uint32 uiSNR;
+    AVL_uint16 uiLockStatus=0;
+    AVL_uchar SNRrefer = 0;;
+    AVL_uchar Quality=5;
+	AVL_uchar i;
+    struct AVL_DVBSx_SignalInfo SignalInfo;      
+
+	for(i=0;i<5;i++)
+	{
+		AVL_DVBSx_IBSP_Delay(10);
+    	r |= AVL_DVBSx_IRx_GetLockStatus(&uiLockStatus, pAVLChip);
+		if(uiLockStatus!=1)		break;
+	}
+    if(i==5)
+    {
+        r |= AVL_DVBSx_IRx_GetSNR(&uiSNR, pAVLChip);
+        r |= AVL_DVBSx_IRx_GetSignalInfo(&SignalInfo, pAVLChip);
+    }
+	else
+		return Quality;
+	
+    if (SignalInfo.m_coderate < RX_DVBS2_1_4)
+    {
+        SNRrefer = DVBS_SNR[SignalInfo.m_coderate];
+    }
+    else
+    {
+        if (SignalInfo.m_modulation == AVL_DVBSx_MM_8PSK)
+            SNRrefer = DVBS28psk_SNR[SignalInfo.m_coderate -RX_DVBS2_3_5];
+        else
+            SNRrefer = DVBS2Qpsk_SNR[SignalInfo.m_coderate -RX_DVBS2_1_2];
+    }
+	
+    if ((uiSNR/10) > SNRrefer)
+    {
+    	uiSNR = uiSNR/10 - SNRrefer;
+        if(uiSNR>=100)
+            Quality = 99;
+        else if(uiSNR>=50)  //  >5.0dB
+            Quality = 80+ (uiSNR-50)*20/50;
+        else if(uiSNR>=25)  //  > 2.5dB
+            Quality = 50+ (uiSNR-25)*30/25;
+        else if(uiSNR>=10)  //  > 1dB
+            Quality = 25+ (uiSNR-10)*25/15;			
+        else 
+            Quality = 5+ (uiSNR)*20/10;
+    }
+    else
+    {
+        Quality = 5;
+    }
+	
+	return Quality;
+}    
+
+
+struct Signal_Level  AGC_LUT [91]=
+{
+    {63688,  0},{62626, -1},{61840, -2},{61175, -3},{60626, -4},{60120, -5},{59647, -6},{59187, -7},{58741, -8},{58293, -9},
+    {57822,-10},{57387,-11},{56913,-12},{56491,-13},{55755,-14},{55266,-15},{54765,-16},{54221,-17},{53710,-18},{53244,-19},
+    {52625,-20},{52043,-21},{51468,-22},{50904,-23},{50331,-24},{49772,-25},{49260,-26},{48730,-27},{48285,-28},{47804,-29},
+    {47333,-30},{46880,-31},{46460,-32},{46000,-33},{45539,-34},{45066,-35},{44621,-36},{44107,-37},{43611,-38},{43082,-39},
+    {42512,-40},{41947,-41},{41284,-42},{40531,-43},{39813,-44},{38978,-45},{38153,-46},{37294,-47},{36498,-48},{35714,-49},
+    {35010,-50},{34432,-51},{33814,-52},{33315,-53},{32989,-54},{32504,-55},{32039,-56},{31608,-57},{31141,-58},{30675,-59},
+    {30215,-60},{29711,-61},{29218,-62},{28688,-63},{28183,-64},{27593,-65},{26978,-66},{26344,-67},{25680,-68},{24988,-69},
+    {24121,-70},{23285,-71},{22460,-72},{21496,-73},{20495,-74},{19320,-75},{18132,-76},{16926,-77},{15564,-78},{14398,-79},
+    {12875,-80},{11913,-81},{10514,-82},{ 9070,-83},{ 7588,-84},{ 6044,-85},{ 4613,-86},{ 3177,-87},{ 1614,-88},{  123,-89},
+    {    0,-90}
+};
+	
+AVL_int16 AVL_Get_Level_Percent(struct AVL_DVBSx_Chip * pAVLChip)
+{
+
+	AVL_DVBSx_ErrorCode r = AVL_DVBSx_EC_OK;
+	AVL_uint16 Level;
+	AVL_int16 i;
+	AVL_int16 Percent;
+/*
+	#define Level_High_Stage	36
+	#define Level_Low_Stage 	70
+
+	#define Percent_Space_High	6
+	#define Percent_Space_Mid	44
+	#define Percent_Space_Low	50		//Percent_Space_High+Percent_Space_Mid+Percent_Space_Low = 100
+
+*/	
+	#define Level_High_Stage	36
+	#define Level_Low_Stage		76
+
+	#define Percent_Space_High	10
+	#define Percent_Space_Mid	30
+	#define Percent_Space_Low	60
+
+
+	i = 0;
+	Percent = 0;
+
+	r = AVL_DVBSx_IRx_GetSignalLevel(&Level,pAVLChip);
+
+	while(Level < AGC_LUT[i++].SignalLevel);
+	
+	if(i<= Level_High_Stage)
+		Percent = Percent_Space_Low+Percent_Space_Mid+ (Level_High_Stage-i)*Percent_Space_High/Level_High_Stage;
+	else if(i<=Level_Low_Stage)
+		Percent = Percent_Space_Low+ (Level_Low_Stage-i)*Percent_Space_Mid/(Level_Low_Stage-Level_High_Stage);
+	else
+		Percent =(90-i)*Percent_Space_Low/(90-Level_Low_Stage);
+
+	return Percent;	
+}
+
+
+
+
+void AVL_DVBSx_Error_Dispose(AVL_DVBSx_ErrorCode r)
+{
+    switch(r)
+	{
+	    case AVL_DVBSx_EC_OK:
+		    printf("AVL_DVBSx_EC_OK !\n");
+			break;
+	    case AVL_DVBSx_EC_GeneralFail:
+			printf("AVL_DVBSx_EC_GeneralFail !\n");
+			break;
+		case AVL_DVBSx_EC_I2CFail:
+			printf("AVL_DVBSx_EC_I2CFail !\n");
+			break;
+		case AVL_DVBSx_EC_TimeOut:
+			printf("AVL_DVBSx_EC_TimeOut !\n");
+			break;
+		case AVL_DVBSx_EC_Running:
+			printf("AVL_DVBSx_EC_Running !\n");
+			break;
+		case AVL_DVBSx_EC_InSleepMode:
+			printf("AVL_DVBSx_EC_InSleepMode !\n");
+			break; 			
+		case AVL_DVBSx_EC_MemoryRunout:
+			printf("AVL_DVBSx_EC_MemoryRunout !\n");
+			break;
+		case AVL_DVBSx_EC_BSP_ERROR1:
+			printf("AVL_DVBSx_EC_BSP_ERROR1 !\n");
+			break;
+		case AVL_DVBSx_EC_BSP_ERROR2:
+			printf("AVL_DVBSx_EC_BSP_ERROR2 !\n");
+			break;
+	}
+}
+
+AVL_DVBSx_ErrorCode CPU_Halt(struct AVL_DVBSx_Chip * pAVLChip)
+{
+	AVL_DVBSx_ErrorCode r;
+	AVL_uint16 i= 0;
+
+	r = AVL_DVBSx_IBase_SendRxOP(OP_RX_HALT, pAVLChip );
+	printf("%s  r is %d",__FUNCTION__,r);
+     if(AVL_DVBSx_EC_OK == r)
+     {
+		while(i++<20)
+		{
+			r = AVL_DVBSx_IBase_GetRxOPStatus(pAVLChip);
+			if(AVL_DVBSx_EC_OK == r)
+			{
+				break;
+			}
+			else
+			{
+				AVL_DVBSx_IBSP_Delay(10);
+			}
+		}
+     }
+	 printf("%s  r is %d",__FUNCTION__,r);
+	return (r);
+}
+
+void AVL_Set_LPF(int iDeviceId ,struct AVL_Tuner * pTuner, AVL_uint32 m_uiSymbolRate_Hz)
+{	
+	struct AVL_Demod_Tuner_Configuration_t *pDemodTunerConfig = &g_DemodTuner_Config[iDeviceId];
+
+	if (pDemodTunerConfig->m_LPF_Config_flag == InputSymbolRate)
+	{
+		pTuner->m_uiLPF_100kHz = m_uiSymbolRate_Hz/(1000*100);
+	}
+	else
+	{
+		pTuner->m_uiLPF_100kHz = (m_uiSymbolRate_Hz*75)/(1000*100*100)+40;
+	}
+
+	if (pTuner->m_uiLPF_100kHz > pDemodTunerConfig->m_uiTunerMaxLPF_100Khz)
+	{
+		pTuner->m_uiLPF_100kHz = pDemodTunerConfig->m_uiTunerMaxLPF_100Khz;
+	}
+}
+
+
+AVL_DVBSx_ErrorCode AVL6211_Initialize(struct AVL_DVBSx_Chip * pAVLChip,struct AVL_Tuner * pTuner,int iDeviceIndex)
+{
+    struct AVL_DVBSx_Diseqc_Para sDiseqcPara;
+	struct AVL_DVBSx_MpegInfo sMpegMode;
+	AVL_DVBSx_ErrorCode r = AVL_DVBSx_EC_OK;
+	struct AVL_Demod_Tuner_Configuration_t *pDemodTunerConfig = &g_DemodTuner_Config[iDeviceIndex];
+	struct AVL_DVBSx_VerInfo VerInfo;
+	//AVL_uint32 uiTemp;
+	AVL_uint32 uiDeviceID=0;
+#if 0  
+	//This function should be implemented by customer.
+	//This function should be called before all other functions to prepare everything for a BSP operation.
+	r = AVL_DVBSx_IBSP_Initialize();
+
+	if( AVL_DVBSx_EC_OK != r )
+	{
+		printf("BSP Initialization failed !\n");
+		return (r);
+	}
+#endif
+
+	pAVLChip->m_uiBusId=pDemodTunerConfig->m_ChannelId;
+	//pAVLChip->m_uiDeviceId = iDeviceIndex;
+	printk(" (AVL6211_Initialize), iDeviceIndex = %d ,pAVLChip->m_uiBusId = %d \n",iDeviceIndex,pAVLChip->m_uiBusId);
+	
+    // This function should be called after bsp initialized to initialize the chip object.
+    r = Init_AVL_DVBSx_ChipObject(pAVLChip, pDemodTunerConfig->m_uiDemodAddress);	
+	if( AVL_DVBSx_EC_OK != r ) 
+	{
+		printf("Chip Object Initialization failed !\n");
+		return (r);
+	}
+
+	//Judge the chip ID of current chip.
+	//r = AVL_DVBSx_II2C_Read32(pAVLChip, rom_ver_addr, &uiTemp);
+	
+	r= AVL_DVBSx_IRx_GetDeviceID(  pAVLChip, &uiDeviceID);
+	printk("r is %x,uiDeviceID is %x\n",r,uiDeviceID);
+	if (AVL_DVBSx_EC_OK != r)
+	{
+		printf("Get Chip ID failed !\n");
+		return (r);
+	}
+	
+	//if ( uiTemp != Chip_ID )
+	if(uiDeviceID != Chip_ID )
+	{
+		printf("Chip ID isn't correct !\n");
+		return AVL_DVBSx_EC_GeneralFail;
+	}
+
+    //This function should be called after chip object initialized to initialize the IBase,using reference clock as 10M. Make sure you pickup the right pll_conf since it may be modified in BSP.
+	r = AVL_DVBSx_IBase_Initialize(&(pll_conf[pDemodTunerConfig->m_DemodReferenceClk]), ucPatchData, pAVLChip); 
+	if( AVL_DVBSx_EC_OK != r ) 
+	{
+		printf("IBase Initialization failed !\n");
+		return (r);
+	}
+	AVL_DVBSx_IBSP_Delay(100);	  //Wait 100 ms to assure that the AVL_DVBSx chip boots up.This function should be implemented by customer.
+
+  
+	//This function should be called to verify the AVL_DVBSx chip has completed its initialization procedure.
+    r = AVL_DVBSx_IBase_GetStatus(pAVLChip);
+	if( AVL_DVBSx_EC_OK != r )       
+	{
+		printf("Booted failed !\n");
+		return (r);
+	}
+    printf("Booted !\n");
+
+	//Get Chip ID, Patch version and SDK version.
+	AVL_DVBSx_IBase_GetVersion( &VerInfo, pAVLChip);
+	printf("Chip Ver:{%d}.{%d}.{%d}  API Ver:{%d}.{%d}.{%d}  Patch Ver:{%d}.{%d}.{%d} \n", 
+		VerInfo.m_Chip.m_Major, VerInfo.m_Chip.m_Minor, VerInfo.m_Chip.m_Build, 
+		VerInfo.m_API.m_Major, VerInfo.m_API.m_Minor, VerInfo.m_API.m_Build, 
+		VerInfo.m_Patch.m_Major, VerInfo.m_Patch.m_Minor, VerInfo.m_Patch.m_Build);	
+
+    //This function should be called after IBase initialized to initialize the demod.
+	r = AVL_DVBSx_IRx_Initialize(pAVLChip);
+	if(AVL_DVBSx_EC_OK != r)
+	{
+		printf("Demod Initialization failed !\n");
+		return (r);
+	}
+	//This function should be called after demod initialized to set RF AGC polar.
+	//User does not need to setup this for Sharp tuner since it is the default value. But for other tuners, user may need to do it here.
+    r |= AVL_DVBSx_IRx_SetRFAGCPola(pDemodTunerConfig->m_TunerRFAGC, pAVLChip);
+	r |= AVL_DVBSx_IRx_DriveRFAGC(pAVLChip);
+
+	if(AVL_DVBSx_EC_OK != r)
+	{
+		printf("Set RF AGC Polar failed !\n");
+		return (r);
+	}
+
+	//This function should be called after demod initialized to set spectrum polar.
+	r = AVL_DVBSx_IBase_SetSpectrumPolarity(pDemodTunerConfig->m_Tuner_IQ_SpectrumMode, pAVLChip);
+	if(AVL_DVBSx_EC_OK != r)
+	{
+		printf("Set Spectrum Polar failed !\n");
+		return (r);
+	}
+
+	//Setup MPEG mode parameters.
+    sMpegMode.m_MpegFormat = pDemodTunerConfig->m_TSFormat;
+	sMpegMode.m_MpegMode = pDemodTunerConfig->m_TSOutPutMode;
+	sMpegMode.m_MpegClockPolarity = pDemodTunerConfig->m_TSClockPolarity;
+	
+	//This function should be called after demod initialized to set MPEG mode.(These parameters will be valid after call lock channel function)
+	r = AVL_DVBSx_IRx_SetMpegMode(&sMpegMode,pAVLChip );
+
+	if(sMpegMode.m_MpegMode == AVL_DVBSx_MPM_Serial)
+	{
+		AVL_DVBSx_IRx_SetMpegSerialPin(pAVLChip,pDemodTunerConfig->m_SerDataPin);
+	}
+	if(AVL_DVBSx_EC_OK != r)
+	{
+		printf("Set MPEG output mode failed !\n");
+		return (r);
+	}
+    
+	// Enable the MPEG output (this function call has no effect for the AVL_DVBSxLG and AVL_DVBSxLGa devices)
+	r = AVL_DVBSx_IRx_DriveMpegOutput(pAVLChip);
+
+	//Setup tuner parameters for tuner initialization.
+	pTuner->m_uiSlaveAddress = pDemodTunerConfig->m_uiTunerAddress;
+	pTuner->m_uiI2CBusClock_kHz = pDemodTunerConfig->m_uiTuner_I2Cbus_clock;
+    pTuner->m_pParameters = 0;
+    pTuner->m_pAVLChip = pAVLChip;
+	pTuner->m_pInitializeFunc = pDemodTunerConfig->m_pInitializeFunc;
+	pTuner->m_pLockFunc = pDemodTunerConfig->m_pLockFunc;
+	pTuner->m_pGetLockStatusFunc = pDemodTunerConfig->m_pGetLockStatusFunc;
+
+	//This function should be called after IBase initialized to initialize the tuner.
+	r = pTuner->m_pInitializeFunc(pTuner);
+	if(AVL_DVBSx_EC_OK != r)
+	{
+		printf("Tuner Initialization failed !\n");
+		return (r);
+	}
+
+	//Setup DiSEqC parameters for DiSEqC initialization.
+	sDiseqcPara.m_RxTimeout = AVL_DVBSx_DRT_150ms;
+	sDiseqcPara.m_RxWaveForm = AVL_DVBSx_DWM_Normal;
+	sDiseqcPara.m_ToneFrequency_kHz = Diseqc_Tone_Frequency;		
+	sDiseqcPara.m_TXGap = AVL_DVBSx_DTXG_15ms;
+	sDiseqcPara.m_TxWaveForm = AVL_DVBSx_DWM_Normal;
+
+	//The DiSEqC should be initialized if AVL_DVBSx need to supply power to LNB. This function should be called after IBase initialized to initialize the DiSEqC.
+	r = AVL_DVBSx_IDiseqc_Initialize(&sDiseqcPara, pAVLChip);
+	if(AVL_DVBSx_EC_OK != r)
+	{
+		printf("DiSEqC Initialization failed !\n");
+	}
+
+	return (r);
+}
+
+
+struct AVL_Tuner *avl6211pTuner[FE_DEV_COUNT];
+struct AVL_DVBSx_Chip * pAVLChip_all[FE_DEV_COUNT];
+
+
+
+AVL_DVBSx_ErrorCode AVL6211_LockSignal_Init(int iFeId)
+{
+	AVL_DVBSx_ErrorCode r = AVL_DVBSx_EC_OK;
+	AVL_uchar HandIndex = iFeId;
+	struct AVL_DVBSx_Chip * pAVLChip = &g_stAvlDVBSxChip[HandIndex];
+	struct AVL_Tuner * pTuner = &g_stTuner[HandIndex];
+	avl6211pTuner[iFeId]=pTuner;
+//	printk(" johnnyDebug,(AVL6211_LockSignal_Init,start), iFeId = %d pAVLChip_all[iFeId]->m_uiDeviceId = %d,\n",iFeId);
+    //This function do all the initialization work.It should be called only once at the beginning.It needn't be recalled when we want to lock a new channel.
+	r = AVL6211_Initialize(pAVLChip,pTuner,iFeId);
+	pAVLChip_all[iFeId]=pAVLChip;
+	printk(" (AVL6211_LockSignal_Init,end), iFeId = %d ,pAVLChip_all[iFeId]->m_uiDeviceId = %d\n",iFeId,pAVLChip_all[iFeId]->m_uiBusId);
+	if(AVL_DVBSx_EC_OK != r)
+	{
+		printf("Initialization failed !\n");
+		return (r);
+	}
+	printf("Initialization success !\n");
+	return (r);
+}
+
+
+
+AVL_uint32 AVL6211_GETLockStatus(int iDeviceId)
+{
+	AVL_uchar HandIndex = iDeviceId;
+	struct AVL_DVBSx_Chip * pAVLChip = &g_stAvlDVBSxChip[HandIndex];
+	AVL_DVBSx_ErrorCode r = AVL_DVBSx_EC_OK;
+	AVL_uint16 uiLockStatus;
+	r = AVL_DVBSx_IRx_GetLockStatus(&uiLockStatus, pAVLChip);
+	//printf("lock status is %d",uiLockStatus);
+	if ((AVL_DVBSx_EC_OK == r)&&(1 == uiLockStatus));
+		return	uiLockStatus;
+
+	return	uiLockStatus;
+
+}
+
+
+AVL_uint32 AVL6211_GETBer(int iDeviceId)
+{
+	AVL_uchar HandIndex = iDeviceId;
+	struct AVL_DVBSx_Chip * pAVLChip = &g_stAvlDVBSxChip[HandIndex];
+	AVL_DVBSx_ErrorCode r = AVL_DVBSx_EC_OK;
+	AVL_uint32 uiBER;
+	//This function can be called to read back the current BER calculation result after function AVL_DVBSx_IDVBSxRx_ResetErrorStat called.
+	r = AVL_DVBSx_IRx_GetDVBSBER(&uiBER, pAVLChip);
+	if (AVL_DVBSx_EC_OK != r)
+	{
+		printf("Get DVBS BER failed.  This function should only be called if the input signal is a DVBS signal.\n");
+	}	
+    else
+	{
+	//	printf("BER=%.9f\n",(float)(uiBER*1.0e-9));
+		printf("BER=%d*10-9\n",uiBER);
+	}
+	return uiBER;
+}
+
+
+AVL_uint32 AVL6211_GETPer(int iDeviceId)
+{
+	AVL_uchar HandIndex = iDeviceId;
+	struct AVL_DVBSx_Chip * pAVLChip = &g_stAvlDVBSxChip[HandIndex];
+	AVL_DVBSx_ErrorCode r = AVL_DVBSx_EC_OK;
+	AVL_uint32 uiPER;
+	//This function can be called to read back the current PER calculation result after function AVL_DVBSx_IDVBSxRx_ResetErrorStat called.
+	r = AVL_DVBSx_IRx_GetPER(&uiPER, pAVLChip);
+	if (AVL_DVBSx_EC_OK != r)
+	{
+		printf("Get PER --- Fail !\n");
+	}	
+    else
+	{
+	//	printf("PER=%.9f\n",(float)(uiPER*1.0e-9));
+		printf("PER=%d*10-9\n",uiPER);
+	}
+
+	return uiPER;
+}
+
+
+AVL_uint32 AVL6211_GETSnr(int iDeviceId)
+{
+	AVL_uchar HandIndex = iDeviceId;
+	struct AVL_DVBSx_Chip * pAVLChip = &g_stAvlDVBSxChip[HandIndex];
+	AVL_DVBSx_ErrorCode r = AVL_DVBSx_EC_OK;
+	AVL_uint32 uiSNR;
+	//This function can be called to read back the current SNR estimate after the channel locked and some waiting time.
+	r = AVL_DVBSx_IRx_GetSNR(&uiSNR, pAVLChip);
+	if (AVL_DVBSx_EC_OK != r)
+	{
+		printf("Get SNR --- Fail !\n"); 
+	}
+    else
+	{
+	//	printf("SNR=%.2fdb\n",(float)(uiSNR/100.0));
+		printf("SNR=%ddb\n",uiSNR/100);
+	}
+	return uiSNR;
+}
+
+
+AVL_uint32 AVL6211_GETSignalLevel(int iDeviceId)
+{
+	AVL_uchar HandIndex = iDeviceId;
+	AVL_uint16 i;
+	struct AVL_DVBSx_Chip * pAVLChip = &g_stAvlDVBSxChip[HandIndex];
+	AVL_DVBSx_ErrorCode r = AVL_DVBSx_EC_OK;
+	AVL_uint16 uiRFSignalLevel;
+	AVL_int16  uiRFSignalDBM;
+	//This function can be called to get the RF signal level after the channel locked.
+	   r = AVL_DVBSx_IRx_GetSignalLevel(&uiRFSignalLevel, pAVLChip);
+	   if (AVL_DVBSx_EC_OK != r)
+	   {
+		   printf("Get SignalLevel --- Fail !\n");
+	   }
+	   else
+	   {
+		   for(i=0; i<47; i++)
+		   {
+			   if(uiRFSignalLevel <= SignalLevel[i].SignalLevel)   
+			   {
+				   //Calculate the corresponding DBM value.
+				   if((0==i)&&(uiRFSignalLevel < SignalLevel[i].SignalLevel))
+				   {
+					   printf("RFSignalLevel is too weak !");
+				   }
+				   else
+				   {
+					   uiRFSignalDBM = SignalLevel[i].SignalDBM;
+				   }
+				   break;
+			   } 
+		   }	   
+	   //  printf("RFSignalLevel::%.1fdbm\n",(float)(uiRFSignalDBM/10.0));
+		   printf("RFSignalLevel::%ddbm\n",uiRFSignalDBM/10);
+	   }  
+
+	return uiRFSignalDBM;
+}
+
+
+
+
diff -Naur a/drivers/amlogic/dvb_tv/avl6211/src/SignalLevel.cpp b/drivers/amlogic/dvb_tv/avl6211/src/SignalLevel.cpp
--- a/drivers/amlogic/dvb_tv/avl6211/src/SignalLevel.cpp	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/amlogic/dvb_tv/avl6211/src/SignalLevel.cpp	2014-12-11 16:13:50.429615023 +0100
@@ -0,0 +1,31 @@
+/*
+ *           Copyright 2012 Availink, Inc.
+ *
+ *  This software contains Availink proprietary information and
+ *  its use and disclosure are restricted solely to the terms in
+ *  the corresponding written license agreement. It shall not be 
+ *  disclosed to anyone other than valid licensees without
+ *  written permission of Availink, Inc.
+ *
+ */
+
+
+///$Date: 2012-2-9 17:36 $
+///
+
+
+
+#include "LockSignal_Manual_source.h"
+
+struct Signal_Level  SignalLevel [47]=
+{
+	{8285,	-922},{10224,	-902},{12538,	-882},{14890,	-862},{17343,	-842},{19767,	-822},{22178,	-802},{24618,	-782},{27006,	-762},{29106,	-742},
+	{30853,	-722},{32289,	-702},{33577,	-682},{34625,	-662},{35632,	-642},{36552,	-622},{37467,	-602},{38520,	-582},{39643,	-562},{40972,	-542},
+	{42351,	-522},{43659,	-502},{44812,	-482},{45811,	-462},{46703,	-442},{47501,	-422},{48331,	-402},{49116,	-382},{49894,	-362},{50684,	-342},
+	{51543,	-322},{52442,	-302},{53407,	-282},{54314,	-262},{55208,	-242},{56000,	-222},{56789,	-202},{57544,	-182},{58253,	-162},{58959,	-142},
+	{59657,	-122},{60404,	-102},{61181,	-82},{62008,	-62},{63032,	-42},{65483,	-22},{65535,	-12}
+
+};
+
+
+
diff -Naur a/drivers/amlogic/dvb_tv/Makefile b/drivers/amlogic/dvb_tv/Makefile
--- a/drivers/amlogic/dvb_tv/Makefile	2014-12-11 15:40:00.089007476 +0100
+++ b/drivers/amlogic/dvb_tv/Makefile	2014-12-11 15:56:35.209504705 +0100
@@ -12,10 +12,7 @@
 
 obj-$(CONFIG_AM_M6_DEMOD) += amldemod/
 
-ifneq ($(wildcard $(srctree)/../hardware/dvb),)
-	obj-$(CONFIG_AM_ATBM8869) += ../../../../hardware/dvb/altobeam/drivers/atbm887x/
-	obj-$(CONFIG_AM_SI2177)   += ../../../../hardware/dvb/silabs/drivers/si2177/
-	obj-$(CONFIG_AM_AVL6211)  += ../../../../hardware/dvb/availink/drivers/avl6211/
-endif
+obj-$(CONFIG_AM_AVL6211) += avl6211/
 
+EXTRA_CFLAGS += -Idrivers/media/dvb-core
 EXTRA_CFLAGS += -I.
