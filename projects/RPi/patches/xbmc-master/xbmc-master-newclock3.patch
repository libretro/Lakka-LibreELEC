From edcac7d62db15484a0fbd441bf26fe31b9c0f8ff Mon Sep 17 00:00:00 2001
From: Ben Avison <bavison@riscosopen.org>
Date: Wed, 11 Dec 2013 17:21:54 +0000
Subject: [PATCH 001/102] Move the reference-counting of Begin and End calls
 from DX and GL source files into GUIFontTTF.cpp.

---
 xbmc/guilib/GUIFontTTF.cpp   |  21 ++++++++
 xbmc/guilib/GUIFontTTF.h     |   6 ++-
 xbmc/guilib/GUIFontTTFDX.cpp |  79 +++++++++++++----------------
 xbmc/guilib/GUIFontTTFDX.h   |   4 +-
 xbmc/guilib/GUIFontTTFGL.cpp | 118 +++++++++++++++++++------------------------
 xbmc/guilib/GUIFontTTFGL.h   |   4 +-
 6 files changed, 117 insertions(+), 115 deletions(-)

diff --git a/xbmc/guilib/GUIFontTTF.cpp b/xbmc/guilib/GUIFontTTF.cpp
index 7014d35..a6b73e5 100644
--- a/xbmc/guilib/GUIFontTTF.cpp
+++ b/xbmc/guilib/GUIFontTTF.cpp
@@ -309,6 +309,27 @@ bool CGUIFontTTFBase::Load(const CStdString& strFilename, float height, float as
   return true;
 }
 
+void CGUIFontTTFBase::Begin()
+{
+  if (m_nestedBeginCount == 0 && m_texture != NULL && FirstBegin())
+  {
+    m_vertex_count = 0;
+  }
+  // Keep track of the nested begin/end calls.
+  m_nestedBeginCount++;
+}
+
+void CGUIFontTTFBase::End()
+{
+  if (m_nestedBeginCount == 0)
+    return;
+
+  if (--m_nestedBeginCount > 0)
+    return;
+
+  LastEnd();
+}
+
 void CGUIFontTTFBase::DrawTextInternal(float x, float y, const vecColors &colors, const vecText &text, uint32_t alignment, float maxPixelWidth, bool scrolling)
 {
   Begin();
diff --git a/xbmc/guilib/GUIFontTTF.h b/xbmc/guilib/GUIFontTTF.h
index 9723a43..c1c4507 100644
--- a/xbmc/guilib/GUIFontTTF.h
+++ b/xbmc/guilib/GUIFontTTF.h
@@ -77,8 +77,8 @@ class CGUIFontTTFBase
 
   bool Load(const CStdString& strFilename, float height = 20.0f, float aspect = 1.0f, float lineSpacing = 1.0f, bool border = false);
 
-  virtual void Begin() = 0;
-  virtual void End() = 0;
+  void Begin();
+  void End();
 
   const CStdString& GetFileName() const { return m_strFileName; };
 
@@ -169,6 +169,8 @@ class CGUIFontTTFBase
   CStdString m_strFileName;
 
 private:
+  virtual bool FirstBegin() = 0;
+  virtual void LastEnd() = 0;
   CGUIFontTTFBase(const CGUIFontTTFBase&);
   CGUIFontTTFBase& operator=(const CGUIFontTTFBase&);
   int m_referenceCount;
diff --git a/xbmc/guilib/GUIFontTTFDX.cpp b/xbmc/guilib/GUIFontTTFDX.cpp
index e3eba24..2f90668 100644
--- a/xbmc/guilib/GUIFontTTFDX.cpp
+++ b/xbmc/guilib/GUIFontTTFDX.cpp
@@ -51,65 +51,56 @@ CGUIFontTTFDX::~CGUIFontTTFDX(void)
   free(m_index);
 }
 
-void CGUIFontTTFDX::Begin()
+bool CGUIFontTTFDX::FirstBegin()
 {
   LPDIRECT3DDEVICE9 pD3DDevice = g_Windowing.Get3DDevice();
 
   if (pD3DDevice == NULL)
+  {
     CLog::Log(LOGERROR, __FUNCTION__" - failed to get Direct3D device");
+    return false;
+  }
 
-  if (m_nestedBeginCount == 0 && pD3DDevice != NULL && m_texture != NULL)
+  int unit = 0;
+  // just have to blit from our texture.
+  m_texture->BindToUnit(unit);
+  pD3DDevice->SetTextureStageState( unit, D3DTSS_COLOROP, D3DTOP_SELECTARG1 ); // only use diffuse
+  pD3DDevice->SetTextureStageState( unit, D3DTSS_COLORARG1, D3DTA_DIFFUSE);
+  pD3DDevice->SetTextureStageState( unit, D3DTSS_ALPHAOP, D3DTOP_MODULATE );
+  pD3DDevice->SetTextureStageState( unit, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
+  pD3DDevice->SetTextureStageState( unit, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE);
+  unit++;
+
+  if(g_Windowing.UseLimitedColor())
   {
-    int unit = 0;
-    // just have to blit from our texture.
-    m_texture->BindToUnit(unit);
-    pD3DDevice->SetTextureStageState( unit, D3DTSS_COLOROP, D3DTOP_SELECTARG1 ); // only use diffuse
-    pD3DDevice->SetTextureStageState( unit, D3DTSS_COLORARG1, D3DTA_DIFFUSE);
-    pD3DDevice->SetTextureStageState( unit, D3DTSS_ALPHAOP, D3DTOP_MODULATE );
-    pD3DDevice->SetTextureStageState( unit, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
-    pD3DDevice->SetTextureStageState( unit, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE);
+    pD3DDevice->SetTextureStageState( unit, D3DTSS_COLOROP  , D3DTOP_ADD );
+    pD3DDevice->SetTextureStageState( unit, D3DTSS_COLORARG1, D3DTA_CURRENT) ;
+    pD3DDevice->SetRenderState( D3DRS_TEXTUREFACTOR, D3DCOLOR_RGBA(16,16,16,0) );
+    pD3DDevice->SetTextureStageState( unit, D3DTSS_COLORARG2, D3DTA_TFACTOR );
     unit++;
-
-    if(g_Windowing.UseLimitedColor())
-    {
-      pD3DDevice->SetTextureStageState( unit, D3DTSS_COLOROP  , D3DTOP_ADD );
-      pD3DDevice->SetTextureStageState( unit, D3DTSS_COLORARG1, D3DTA_CURRENT) ;
-      pD3DDevice->SetRenderState( D3DRS_TEXTUREFACTOR, D3DCOLOR_RGBA(16,16,16,0) );
-      pD3DDevice->SetTextureStageState( unit, D3DTSS_COLORARG2, D3DTA_TFACTOR );
-      unit++;
-    }
-
-    // no other texture stages needed
-    pD3DDevice->SetTextureStageState( unit, D3DTSS_COLOROP, D3DTOP_DISABLE);
-    pD3DDevice->SetTextureStageState( unit, D3DTSS_ALPHAOP, D3DTOP_DISABLE);
-
-    pD3DDevice->SetRenderState( D3DRS_ZENABLE, FALSE );
-    pD3DDevice->SetRenderState( D3DRS_FOGENABLE, FALSE );
-    pD3DDevice->SetRenderState( D3DRS_FILLMODE, D3DFILL_SOLID );
-    pD3DDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE );
-    pD3DDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
-    pD3DDevice->SetRenderState( D3DRS_SRCBLEND, D3DBLEND_SRCALPHA );
-    pD3DDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA );
-    pD3DDevice->SetRenderState( D3DRS_LIGHTING, FALSE);
-
-    pD3DDevice->SetFVF(D3DFVF_XYZ | D3DFVF_DIFFUSE | D3DFVF_TEX1);
-    m_vertex_count = 0;
   }
 
-  // Keep track of the nested begin/end calls.
-  m_nestedBeginCount++;
+  // no other texture stages needed
+  pD3DDevice->SetTextureStageState( unit, D3DTSS_COLOROP, D3DTOP_DISABLE);
+  pD3DDevice->SetTextureStageState( unit, D3DTSS_ALPHAOP, D3DTOP_DISABLE);
+
+  pD3DDevice->SetRenderState( D3DRS_ZENABLE, FALSE );
+  pD3DDevice->SetRenderState( D3DRS_FOGENABLE, FALSE );
+  pD3DDevice->SetRenderState( D3DRS_FILLMODE, D3DFILL_SOLID );
+  pD3DDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE );
+  pD3DDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
+  pD3DDevice->SetRenderState( D3DRS_SRCBLEND, D3DBLEND_SRCALPHA );
+  pD3DDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA );
+  pD3DDevice->SetRenderState( D3DRS_LIGHTING, FALSE);
+
+  pD3DDevice->SetFVF(D3DFVF_XYZ | D3DFVF_DIFFUSE | D3DFVF_TEX1);
+  return true;
 }
 
-void CGUIFontTTFDX::End()
+void CGUIFontTTFDX::LastEnd()
 {
   LPDIRECT3DDEVICE9 pD3DDevice = g_Windowing.Get3DDevice();
 
-  if (m_nestedBeginCount == 0)
-    return;
-
-  if (--m_nestedBeginCount > 0)
-    return;
-
   if (m_vertex_count == 0)
     return;
 
diff --git a/xbmc/guilib/GUIFontTTFDX.h b/xbmc/guilib/GUIFontTTFDX.h
index 0431085..17dfefe 100644
--- a/xbmc/guilib/GUIFontTTFDX.h
+++ b/xbmc/guilib/GUIFontTTFDX.h
@@ -41,8 +41,8 @@ class CGUIFontTTFDX : public CGUIFontTTFBase
   CGUIFontTTFDX(const CStdString& strFileName);
   virtual ~CGUIFontTTFDX(void);
 
-  virtual void Begin();
-  virtual void End();
+  virtual bool FirstBegin();
+  virtual void LastEnd();
 
 protected:
   virtual CBaseTexture* ReallocTexture(unsigned int& newHeight);
diff --git a/xbmc/guilib/GUIFontTTFGL.cpp b/xbmc/guilib/GUIFontTTFGL.cpp
index 3358a5a..93b7ea6 100644
--- a/xbmc/guilib/GUIFontTTFGL.cpp
+++ b/xbmc/guilib/GUIFontTTFGL.cpp
@@ -50,90 +50,78 @@ CGUIFontTTFGL::~CGUIFontTTFGL(void)
 {
 }
 
-void CGUIFontTTFGL::Begin()
+bool CGUIFontTTFGL::FirstBegin()
 {
-  if (m_nestedBeginCount == 0 && m_texture != NULL)
+  if (!m_bTextureLoaded)
   {
-    if (!m_bTextureLoaded)
-    {
-      // Have OpenGL generate a texture object handle for us
-      glGenTextures(1, (GLuint*) &m_nTexture);
+    // Have OpenGL generate a texture object handle for us
+    glGenTextures(1, (GLuint*) &m_nTexture);
 
-      // Bind the texture object
-      glBindTexture(GL_TEXTURE_2D, m_nTexture);
+    // Bind the texture object
+    glBindTexture(GL_TEXTURE_2D, m_nTexture);
 #ifdef HAS_GL
-      glEnable(GL_TEXTURE_2D);
+    glEnable(GL_TEXTURE_2D);
 #endif
-      // Set the texture's stretching properties
-      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
-      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+    // Set the texture's stretching properties
+    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
 
-      // Set the texture image -- THIS WORKS, so the pixels must be wrong.
-      glTexImage2D(GL_TEXTURE_2D, 0, GL_ALPHA, m_texture->GetWidth(), m_texture->GetHeight(), 0,
-                   GL_ALPHA, GL_UNSIGNED_BYTE, m_texture->GetPixels());
+    // Set the texture image -- THIS WORKS, so the pixels must be wrong.
+    glTexImage2D(GL_TEXTURE_2D, 0, GL_ALPHA, m_texture->GetWidth(), m_texture->GetHeight(), 0,
+                 GL_ALPHA, GL_UNSIGNED_BYTE, m_texture->GetPixels());
 
-      VerifyGLState();
-      m_bTextureLoaded = true;
-    }
+    VerifyGLState();
+    m_bTextureLoaded = true;
+  }
 
-    // Turn Blending On
-    glBlendFuncSeparate(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_ONE_MINUS_DST_ALPHA, GL_ONE);
-    glEnable(GL_BLEND);
+  // Turn Blending On
+  glBlendFuncSeparate(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_ONE_MINUS_DST_ALPHA, GL_ONE);
+  glEnable(GL_BLEND);
 #ifdef HAS_GL
-    glEnable(GL_TEXTURE_2D);
+  glEnable(GL_TEXTURE_2D);
 #endif
-    glBindTexture(GL_TEXTURE_2D, m_nTexture);
+  glBindTexture(GL_TEXTURE_2D, m_nTexture);
 
 #ifdef HAS_GL
-    glTexEnvi(GL_TEXTURE_ENV,GL_TEXTURE_ENV_MODE,GL_COMBINE);
-    glTexEnvi(GL_TEXTURE_ENV,GL_COMBINE_RGB,GL_REPLACE);
-    glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE0_RGB, GL_PRIMARY_COLOR);
-    glTexEnvi(GL_TEXTURE_ENV, GL_OPERAND0_RGB, GL_SRC_COLOR);
-    glTexEnvi(GL_TEXTURE_ENV, GL_COMBINE_ALPHA, GL_MODULATE);
-    glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE0_ALPHA, GL_TEXTURE0);
-    glTexEnvi(GL_TEXTURE_ENV, GL_OPERAND0_ALPHA, GL_SRC_ALPHA);
-    glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE1_ALPHA, GL_PRIMARY_COLOR);
-    glTexEnvi(GL_TEXTURE_ENV, GL_OPERAND1_ALPHA, GL_SRC_ALPHA);
-    glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
-    VerifyGLState();
+  glTexEnvi(GL_TEXTURE_ENV,GL_TEXTURE_ENV_MODE,GL_COMBINE);
+  glTexEnvi(GL_TEXTURE_ENV,GL_COMBINE_RGB,GL_REPLACE);
+  glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE0_RGB, GL_PRIMARY_COLOR);
+  glTexEnvi(GL_TEXTURE_ENV, GL_OPERAND0_RGB, GL_SRC_COLOR);
+  glTexEnvi(GL_TEXTURE_ENV, GL_COMBINE_ALPHA, GL_MODULATE);
+  glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE0_ALPHA, GL_TEXTURE0);
+  glTexEnvi(GL_TEXTURE_ENV, GL_OPERAND0_ALPHA, GL_SRC_ALPHA);
+  glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE1_ALPHA, GL_PRIMARY_COLOR);
+  glTexEnvi(GL_TEXTURE_ENV, GL_OPERAND1_ALPHA, GL_SRC_ALPHA);
+  glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
+  VerifyGLState();
+
+  if(g_Windowing.UseLimitedColor())
+  {
+    glActiveTexture(GL_TEXTURE1);
+    glBindTexture(GL_TEXTURE_2D, m_nTexture); // dummy bind
+    glEnable(GL_TEXTURE_2D);
 
-    if(g_Windowing.UseLimitedColor())
-    {
-      glActiveTexture(GL_TEXTURE1);
-      glBindTexture(GL_TEXTURE_2D, m_nTexture); // dummy bind
-      glEnable(GL_TEXTURE_2D);
-
-      const GLfloat rgba[4] = {16.0f / 255.0f, 16.0f / 255.0f, 16.0f / 255.0f, 0.0f};
-      glTexEnvi (GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE , GL_COMBINE);
-      glTexEnvfv(GL_TEXTURE_ENV, GL_TEXTURE_ENV_COLOR, rgba);
-      glTexEnvi (GL_TEXTURE_ENV, GL_COMBINE_RGB      , GL_ADD);
-      glTexEnvi (GL_TEXTURE_ENV, GL_SOURCE0_RGB      , GL_PREVIOUS);
-      glTexEnvi (GL_TEXTURE_ENV, GL_SOURCE1_RGB      , GL_CONSTANT);
-      glTexEnvi (GL_TEXTURE_ENV, GL_OPERAND0_RGB     , GL_SRC_COLOR);
-      glTexEnvi (GL_TEXTURE_ENV, GL_OPERAND1_RGB     , GL_SRC_COLOR);
-      glTexEnvi (GL_TEXTURE_ENV, GL_COMBINE_ALPHA    , GL_REPLACE);
-      glTexEnvi (GL_TEXTURE_ENV, GL_SOURCE0_ALPHA    , GL_PREVIOUS);
-      VerifyGLState();
-    }
+    const GLfloat rgba[4] = {16.0f / 255.0f, 16.0f / 255.0f, 16.0f / 255.0f, 0.0f};
+    glTexEnvi (GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE , GL_COMBINE);
+    glTexEnvfv(GL_TEXTURE_ENV, GL_TEXTURE_ENV_COLOR, rgba);
+    glTexEnvi (GL_TEXTURE_ENV, GL_COMBINE_RGB      , GL_ADD);
+    glTexEnvi (GL_TEXTURE_ENV, GL_SOURCE0_RGB      , GL_PREVIOUS);
+    glTexEnvi (GL_TEXTURE_ENV, GL_SOURCE1_RGB      , GL_CONSTANT);
+    glTexEnvi (GL_TEXTURE_ENV, GL_OPERAND0_RGB     , GL_SRC_COLOR);
+    glTexEnvi (GL_TEXTURE_ENV, GL_OPERAND1_RGB     , GL_SRC_COLOR);
+    glTexEnvi (GL_TEXTURE_ENV, GL_COMBINE_ALPHA    , GL_REPLACE);
+    glTexEnvi (GL_TEXTURE_ENV, GL_SOURCE0_ALPHA    , GL_PREVIOUS);
+    VerifyGLState();
+  }
 
 #else
-    g_Windowing.EnableGUIShader(SM_FONTS);
+  g_Windowing.EnableGUIShader(SM_FONTS);
 #endif
-
-    m_vertex_count = 0;
-  }
-  // Keep track of the nested begin/end calls.
-  m_nestedBeginCount++;
+  return true;
 }
 
-void CGUIFontTTFGL::End()
+void CGUIFontTTFGL::LastEnd()
 {
-  if (m_nestedBeginCount == 0)
-    return;
-
-  if (--m_nestedBeginCount > 0)
-    return;
-
 #ifdef HAS_GL
   glPushClientAttrib(GL_CLIENT_VERTEX_ARRAY_BIT);
 
diff --git a/xbmc/guilib/GUIFontTTFGL.h b/xbmc/guilib/GUIFontTTFGL.h
index a0dacba..6736cf7 100644
--- a/xbmc/guilib/GUIFontTTFGL.h
+++ b/xbmc/guilib/GUIFontTTFGL.h
@@ -41,8 +41,8 @@ class CGUIFontTTFGL : public CGUIFontTTFBase
   CGUIFontTTFGL(const CStdString& strFileName);
   virtual ~CGUIFontTTFGL(void);
 
-  virtual void Begin();
-  virtual void End();
+  virtual bool FirstBegin();
+  virtual void LastEnd();
 
 protected:
   virtual CBaseTexture* ReallocTexture(unsigned int& newHeight);
-- 
1.9.3


From 9c2224de3667c4fb7de55f3c08a4b43de9b1c64e Mon Sep 17 00:00:00 2001
From: Ben Avison <bavison@riscosopen.org>
Date: Wed, 11 Dec 2013 18:47:54 +0000
Subject: [PATCH 002/102] Convert CGUIFontTTFBase::m_vertex to be managed as a
 std::vector. Also retired CGUIFontTTFBase::m_vertex_count and
 CGUIFontTTFBase::m_vertex_size because these can be derived from vector
 member functions.

---
 xbmc/guilib/GUIFontTTF.cpp   | 29 +++++------------------------
 xbmc/guilib/GUIFontTTF.h     |  4 +---
 xbmc/guilib/GUIFontTTFDX.cpp | 12 ++++++------
 xbmc/guilib/GUIFontTTFGL.cpp | 12 ++++++------
 4 files changed, 18 insertions(+), 39 deletions(-)

diff --git a/xbmc/guilib/GUIFontTTF.cpp b/xbmc/guilib/GUIFontTTF.cpp
index a6b73e5..3f219d9 100644
--- a/xbmc/guilib/GUIFontTTF.cpp
+++ b/xbmc/guilib/GUIFontTTF.cpp
@@ -139,8 +139,7 @@ CGUIFontTTFBase::CGUIFontTTFBase(const CStdString& strFileName)
   m_nestedBeginCount = 0;
 
   m_bTextureLoaded = false;
-  m_vertex_size   = 4*1024;
-  m_vertex        = (SVertex*)malloc(m_vertex_size * sizeof(SVertex));
+  m_vertex.reserve(4*1024);
 
   m_face = NULL;
   m_stroker = NULL;
@@ -155,7 +154,6 @@ CGUIFontTTFBase::CGUIFontTTFBase(const CStdString& strFileName)
   m_textureScaleX = m_textureScaleY = 0.0;
   m_ellipsesWidth = m_height = 0.0f;
   m_color = 0;
-  m_vertex_count = 0;
   m_nTexture = 0;
 }
 
@@ -216,9 +214,7 @@ void CGUIFontTTFBase::Clear()
     g_freeTypeLibrary.ReleaseStroker(m_stroker);
   m_stroker = NULL;
 
-  free(m_vertex);
-  m_vertex = NULL;
-  m_vertex_count = 0;
+  m_vertex.clear();
 }
 
 bool CGUIFontTTFBase::Load(const CStdString& strFilename, float height, float aspect, float lineSpacing, bool border)
@@ -313,7 +309,7 @@ void CGUIFontTTFBase::Begin()
 {
   if (m_nestedBeginCount == 0 && m_texture != NULL && FirstBegin())
   {
-    m_vertex_count = 0;
+    m_vertex.clear();
   }
   // Keep track of the nested begin/end calls.
   m_nestedBeginCount++;
@@ -746,22 +742,9 @@ void CGUIFontTTFBase::RenderCharacter(float posX, float posY, const Character *c
   float tt = texture.y1 * m_textureScaleY;
   float tb = texture.y2 * m_textureScaleY;
 
-  // grow the vertex buffer if required
-  if(m_vertex_count >= m_vertex_size)
-  {
-    m_vertex_size *= 2;
-    void* old      = m_vertex;
-    m_vertex       = (SVertex*)realloc(m_vertex, m_vertex_size * sizeof(SVertex));
-    if (!m_vertex)
-    {
-      free(old);
-      CLog::Log(LOGSEVERE, "%s: can't allocate %" PRIdS" bytes for texture", __FUNCTION__ , m_vertex_size * sizeof(SVertex));
-      return;
-    }
-  }
-
+  m_vertex.resize(m_vertex.size() + 4);
+  SVertex* v = &m_vertex[m_vertex.size() - 4];
   m_color = color;
-  SVertex* v = m_vertex + m_vertex_count;
 
   unsigned char r = GET_R(color)
               , g = GET_G(color)
@@ -828,8 +811,6 @@ void CGUIFontTTFBase::RenderCharacter(float posX, float posY, const Character *c
   v[3].y = y[2];
   v[3].z = z[2];
 #endif
-
-  m_vertex_count+=4;
 }
 
 // Oblique code - original taken from freetype2 (ftsynth.c)
diff --git a/xbmc/guilib/GUIFontTTF.h b/xbmc/guilib/GUIFontTTF.h
index c1c4507..35e3cf9 100644
--- a/xbmc/guilib/GUIFontTTF.h
+++ b/xbmc/guilib/GUIFontTTF.h
@@ -157,9 +157,7 @@ class CGUIFontTTFBase
   bool m_bTextureLoaded;
   unsigned int m_nTexture;
 
-  SVertex* m_vertex;
-  int      m_vertex_count;
-  int      m_vertex_size;
+  std::vector<SVertex> m_vertex;
 
   float    m_textureScaleX;
   float    m_textureScaleY;
diff --git a/xbmc/guilib/GUIFontTTFDX.cpp b/xbmc/guilib/GUIFontTTFDX.cpp
index 2f90668..6ef8984 100644
--- a/xbmc/guilib/GUIFontTTFDX.cpp
+++ b/xbmc/guilib/GUIFontTTFDX.cpp
@@ -101,17 +101,17 @@ void CGUIFontTTFDX::LastEnd()
 {
   LPDIRECT3DDEVICE9 pD3DDevice = g_Windowing.Get3DDevice();
 
-  if (m_vertex_count == 0)
+  if (m_vertex.size() == 0)
     return;
 
-  unsigned index_size = m_vertex_size * 6 / 4;
+  unsigned index_size = m_vertex.capacity() * 6 / 4;
   if(m_index_size < index_size)
   {
     uint16_t* id  = (uint16_t*)calloc(index_size, sizeof(uint16_t));
     if(id == NULL)
       return;
 
-    for(int i = 0, b = 0; i < m_vertex_size; i += 4, b += 6)
+    for(int i = 0, b = 0; i < m_vertex.capacity(); i += 4, b += 6)
     {
       id[b+0] = i + 0;
       id[b+1] = i + 1;
@@ -140,11 +140,11 @@ void CGUIFontTTFDX::LastEnd()
 
   pD3DDevice->DrawIndexedPrimitiveUP(D3DPT_TRIANGLELIST
                                     , 0
-                                    , m_vertex_count
-                                    , m_vertex_count / 2
+                                    , m_vertex.size()
+                                    , m_vertex.size() / 2
                                     , m_index
                                     , D3DFMT_INDEX16
-                                    , m_vertex
+                                    , &m_vertex[0]
                                     , sizeof(SVertex));
   pD3DDevice->SetTransform(D3DTS_WORLD, &orig);
 
diff --git a/xbmc/guilib/GUIFontTTFGL.cpp b/xbmc/guilib/GUIFontTTFGL.cpp
index 93b7ea6..a4e8571 100644
--- a/xbmc/guilib/GUIFontTTFGL.cpp
+++ b/xbmc/guilib/GUIFontTTFGL.cpp
@@ -125,13 +125,13 @@ void CGUIFontTTFGL::LastEnd()
 #ifdef HAS_GL
   glPushClientAttrib(GL_CLIENT_VERTEX_ARRAY_BIT);
 
-  glColorPointer   (4, GL_UNSIGNED_BYTE, sizeof(SVertex), (char*)m_vertex + offsetof(SVertex, r));
-  glVertexPointer  (3, GL_FLOAT        , sizeof(SVertex), (char*)m_vertex + offsetof(SVertex, x));
-  glTexCoordPointer(2, GL_FLOAT        , sizeof(SVertex), (char*)m_vertex + offsetof(SVertex, u));
+  glColorPointer   (4, GL_UNSIGNED_BYTE, sizeof(SVertex), (char*)&m_vertex[0] + offsetof(SVertex, r));
+  glVertexPointer  (3, GL_FLOAT        , sizeof(SVertex), (char*)&m_vertex[0] + offsetof(SVertex, x));
+  glTexCoordPointer(2, GL_FLOAT        , sizeof(SVertex), (char*)&m_vertex[0] + offsetof(SVertex, u));
   glEnableClientState(GL_COLOR_ARRAY);
   glEnableClientState(GL_VERTEX_ARRAY);
   glEnableClientState(GL_TEXTURE_COORD_ARRAY);
-  glDrawArrays(GL_QUADS, 0, m_vertex_count);
+  glDrawArrays(GL_QUADS, 0, m_vertex.size());
   glPopClientAttrib();
 
   glActiveTexture(GL_TEXTURE1);
@@ -147,10 +147,10 @@ void CGUIFontTTFGL::LastEnd()
   GLint tex0Loc = g_Windowing.GUIShaderGetCoord0();
 
   // stack object until VBOs will be used
-  std::vector<SVertex> vecVertices( 6 * (m_vertex_count / 4) );
+  std::vector<SVertex> vecVertices( 6 * (m_vertex.size() / 4) );
   SVertex *vertices = &vecVertices[0];
 
-  for (int i=0; i<m_vertex_count; i+=4)
+  for (size_t i=0; i<m_vertex.size(); i+=4)
   {
     *vertices++ = m_vertex[i];
     *vertices++ = m_vertex[i+1];
-- 
1.9.3


From f23877edf693b70df11026c47f6e2d7343063447 Mon Sep 17 00:00:00 2001
From: Ben Avison <bavison@riscosopen.org>
Date: Mon, 16 Dec 2013 18:58:12 +0000
Subject: [PATCH 003/102] CGUIFontTTFBase::RenderCharacter can now append to
 arbitrary vectors of vertices rather than only CGUIFontTTFBase::m_vertex

---
 xbmc/guilib/GUIFontTTF.cpp | 12 +++++++-----
 xbmc/guilib/GUIFontTTF.h   |  2 +-
 2 files changed, 8 insertions(+), 6 deletions(-)

diff --git a/xbmc/guilib/GUIFontTTF.cpp b/xbmc/guilib/GUIFontTTF.cpp
index 3f219d9..1aaf68b 100644
--- a/xbmc/guilib/GUIFontTTF.cpp
+++ b/xbmc/guilib/GUIFontTTF.cpp
@@ -330,6 +330,8 @@ void CGUIFontTTFBase::DrawTextInternal(float x, float y, const vecColors &colors
 {
   Begin();
 
+  std::vector<SVertex> &vertices = m_vertex;
+
   // save the origin, which is scaled separately
   m_originX = x;
   m_originY = y;
@@ -410,7 +412,7 @@ void CGUIFontTTFBase::DrawTextInternal(float x, float y, const vecColors &colors
 
         for (int i = 0; i < 3; i++)
         {
-          RenderCharacter(startX + cursorX, startY, period, color, !scrolling);
+          RenderCharacter(startX + cursorX, startY, period, color, !scrolling, vertices);
           cursorX += period->advance;
         }
         break;
@@ -419,7 +421,7 @@ void CGUIFontTTFBase::DrawTextInternal(float x, float y, const vecColors &colors
     else if (maxPixelWidth > 0 && cursorX > maxPixelWidth)
       break;  // exceeded max allowed width - stop rendering
 
-    RenderCharacter(startX + cursorX, startY, ch, color, !scrolling);
+    RenderCharacter(startX + cursorX, startY, ch, color, !scrolling, vertices);
     if ( alignment & XBFONT_JUSTIFIED )
     {
       if ((*pos & 0xffff) == L' ')
@@ -676,7 +678,7 @@ bool CGUIFontTTFBase::CacheCharacter(wchar_t letter, uint32_t style, Character *
   return true;
 }
 
-void CGUIFontTTFBase::RenderCharacter(float posX, float posY, const Character *ch, color_t color, bool roundX)
+void CGUIFontTTFBase::RenderCharacter(float posX, float posY, const Character *ch, color_t color, bool roundX, std::vector<SVertex> &vertices)
 {
   // actual image width isn't same as the character width as that is
   // just baseline width and height should include the descent
@@ -742,8 +744,8 @@ void CGUIFontTTFBase::RenderCharacter(float posX, float posY, const Character *c
   float tt = texture.y1 * m_textureScaleY;
   float tb = texture.y2 * m_textureScaleY;
 
-  m_vertex.resize(m_vertex.size() + 4);
-  SVertex* v = &m_vertex[m_vertex.size() - 4];
+  vertices.resize(vertices.size() + 4);
+  SVertex* v = &vertices[vertices.size() - 4];
   m_color = color;
 
   unsigned char r = GET_R(color)
diff --git a/xbmc/guilib/GUIFontTTF.h b/xbmc/guilib/GUIFontTTF.h
index 35e3cf9..4a6a696 100644
--- a/xbmc/guilib/GUIFontTTF.h
+++ b/xbmc/guilib/GUIFontTTF.h
@@ -109,7 +109,7 @@ class CGUIFontTTFBase
   // Stuff for pre-rendering for speed
   inline Character *GetCharacter(character_t letter);
   bool CacheCharacter(wchar_t letter, uint32_t style, Character *ch);
-  void RenderCharacter(float posX, float posY, const Character *ch, color_t color, bool roundX);
+  void RenderCharacter(float posX, float posY, const Character *ch, color_t color, bool roundX, std::vector<SVertex> &vertices);
   void ClearCharacterCache();
 
   virtual CBaseTexture* ReallocTexture(unsigned int& newHeight) = 0;
-- 
1.9.3


From 2ff7c7b3e9e883df75cbf2370a666c402a9ac94a Mon Sep 17 00:00:00 2001
From: Ben Avison <bavison@riscosopen.org>
Date: Wed, 15 Jan 2014 17:18:38 +0000
Subject: [PATCH 004/102] Add a cache of font glyph bounding box vertices. This
 is implemented as a template because ultimately we will key on different
 parameters and store values of different types, depending upon whether we
 have a GLES or non-GLES backend, and for GLES, whether or not the currently
 applicable transformation matrices permit the use of hardware clipping.

---
 xbmc/guilib/GUIFontCache.cpp  | 105 ++++++++++++++++++++
 xbmc/guilib/GUIFontCache.h    | 217 ++++++++++++++++++++++++++++++++++++++++++
 xbmc/guilib/GUIFontTTF.cpp    | 181 +++++++++++++++++++----------------
 xbmc/guilib/GUIFontTTF.h      |   5 +
 xbmc/guilib/GUIFontTTFGL.cpp  |   1 +
 xbmc/guilib/GraphicContext.h  |   1 +
 xbmc/guilib/Makefile.in       |   1 +
 xbmc/guilib/TransformMatrix.h |  11 +++
 8 files changed, 438 insertions(+), 84 deletions(-)
 create mode 100644 xbmc/guilib/GUIFontCache.cpp
 create mode 100644 xbmc/guilib/GUIFontCache.h

diff --git a/xbmc/guilib/GUIFontCache.cpp b/xbmc/guilib/GUIFontCache.cpp
new file mode 100644
index 0000000..c029713
--- /dev/null
+++ b/xbmc/guilib/GUIFontCache.cpp
@@ -0,0 +1,105 @@
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include <stdint.h>
+#include <vector>
+#include "utils/StdString.h" // required by GUIFontTTF.h
+#include "GUIFontTTF.h"
+#include "GraphicContext.h"
+
+template<class Position, class Value>
+void CGUIFontCacheEntry<Position, Value>::Reassign::operator()(CGUIFontCacheEntry<Position, Value> &entry)
+{
+  entry.m_key.m_pos = m_key.m_pos;
+  entry.m_key.m_colors.assign(m_key.m_colors.begin(), m_key.m_colors.end());
+  entry.m_key.m_text.assign(m_key.m_text.begin(), m_key.m_text.end());
+  entry.m_key.m_alignment = m_key.m_alignment;
+  entry.m_key.m_maxPixelWidth = m_key.m_maxPixelWidth;
+  entry.m_key.m_scrolling = m_key.m_scrolling;
+  entry.m_matrix = m_key.m_matrix;
+  entry.m_key.m_scaleX = m_key.m_scaleX;
+  entry.m_key.m_scaleY = m_key.m_scaleY;
+
+  entry.m_lastUsedMillis = m_nowMillis;
+  entry.m_value.clear();
+}
+
+template<class Position, class Value>
+CGUIFontCacheEntry<Position, Value>::~CGUIFontCacheEntry()
+{
+  delete &m_key.m_colors;
+  delete &m_key.m_text;
+  m_value.clear();
+}
+
+template<class Position, class Value>
+Value &CGUIFontCache<Position, Value>::Lookup(Position &pos,
+                                              const vecColors &colors, const vecText &text,
+                                              uint32_t alignment, float maxPixelWidth,
+                                              bool scrolling,
+                                              unsigned int nowMillis, bool &dirtyCache)
+{
+  const CGUIFontCacheKey<Position> key(pos,
+                                       const_cast<vecColors &>(colors), const_cast<vecText &>(text),
+                                       alignment, maxPixelWidth,
+                                       scrolling, g_graphicsContext.GetGUIMatrix(),
+                                       g_graphicsContext.GetGUIScaleX(), g_graphicsContext.GetGUIScaleY());
+  EntryHashIterator i = m_list.get<Hash>().find(key);
+  if (i == m_list.get<Hash>().end())
+  {
+    /* Cache miss */
+    EntryAgeIterator oldest = m_list.get<Age>().begin();
+    if (!m_list.get<Age>().empty() && nowMillis - oldest->m_lastUsedMillis > FONT_CACHE_TIME_LIMIT)
+    {
+      /* The oldest existing entry is old enough to expire and reuse */
+      m_list.get<Hash>().modify(m_list.project<Hash>(oldest), typename CGUIFontCacheEntry<Position, Value>::Reassign(key, nowMillis));
+      m_list.get<Age>().relocate(m_list.get<Age>().end(), oldest);
+    }
+    else
+    {
+      /* We need a new entry instead */
+      /* Yes, this causes the creation an destruction of a temporary entry, but
+       * this code ought to only be used infrequently, when the cache needs to grow */
+      m_list.get<Age>().push_back(CGUIFontCacheEntry<Position, Value>(*this, key, nowMillis));
+    }
+    dirtyCache = true;
+    return (--m_list.get<Age>().end())->m_value;
+  }
+  else
+  {
+    /* Cache hit */
+    /* Update time in entry and move to the back of the list */
+    i->m_lastUsedMillis = nowMillis;
+    m_list.get<Age>().relocate(m_list.get<Age>().end(), m_list.project<Age>(i));
+    dirtyCache = false;
+    return i->m_value;
+  }
+}
+
+template<class Position, class Value>
+void CGUIFontCache<Position, Value>::Flush()
+{
+  m_list.get<Age>().clear();
+}
+
+template void CGUIFontCacheEntry<CGUIFontCacheStaticPosition, CGUIFontCacheStaticValue>::Reassign::operator()(CGUIFontCacheEntry<CGUIFontCacheStaticPosition, CGUIFontCacheStaticValue> &entry);
+template CGUIFontCacheEntry<CGUIFontCacheStaticPosition, CGUIFontCacheStaticValue>::~CGUIFontCacheEntry();
+template CGUIFontCacheStaticValue &CGUIFontCache<CGUIFontCacheStaticPosition, CGUIFontCacheStaticValue>::Lookup(CGUIFontCacheStaticPosition &, const vecColors &, const vecText &, uint32_t, float, bool, unsigned int, bool &);
+template void CGUIFontCache<CGUIFontCacheStaticPosition, CGUIFontCacheStaticValue>::Flush();
diff --git a/xbmc/guilib/GUIFontCache.h b/xbmc/guilib/GUIFontCache.h
new file mode 100644
index 0000000..ef65845
--- /dev/null
+++ b/xbmc/guilib/GUIFontCache.h
@@ -0,0 +1,217 @@
+/*!
+\file GUIFontCache.h
+\brief
+*/
+
+#ifndef CGUILIB_GUIFONTCACHE_H
+#define CGUILIB_GUIFONTCACHE_H
+#pragma once
+
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include <cstddef>
+#include <cstring>
+#include <stdint.h>
+
+#include <algorithm>
+#include <vector>
+
+#include "boost/multi_index_container.hpp"
+#include "boost/multi_index/sequenced_index.hpp"
+#include "boost/multi_index/hashed_index.hpp"
+#include "boost/multi_index/member.hpp"
+
+#include "TransformMatrix.h"
+
+using namespace boost::multi_index;
+
+#define FONT_CACHE_TIME_LIMIT (1000)
+
+template<class Position, class Value> class CGUIFontCache;
+class CGUIFontTTFBase;
+
+template<class Position>
+struct CGUIFontCacheKey
+{
+  Position m_pos;
+  vecColors &m_colors;
+  vecText &m_text;
+  uint32_t m_alignment;
+  float m_maxPixelWidth;
+  bool m_scrolling;
+  const TransformMatrix &m_matrix;
+  float m_scaleX;
+  float m_scaleY;
+
+  CGUIFontCacheKey(Position pos,
+                   vecColors &colors, vecText &text,
+                   uint32_t alignment, float maxPixelWidth,
+                   bool scrolling, const TransformMatrix &matrix,
+                   float scaleX, float scaleY) :
+    m_pos(pos),
+    m_colors(colors), m_text(text),
+    m_alignment(alignment), m_maxPixelWidth(maxPixelWidth),
+    m_scrolling(scrolling), m_matrix(matrix),
+    m_scaleX(scaleX), m_scaleY(scaleY)
+  {}
+};
+
+template<class Position, class Value>
+struct CGUIFontCacheEntry
+{
+  const CGUIFontCache<Position, Value> &m_cache;
+  CGUIFontCacheKey<Position> m_key;
+  TransformMatrix m_matrix;
+
+  /* These need to be declared as mutable to get round the fact that only
+   * const iterators are available. These fields do not affect comparison or
+   * hash functors, so from the container's point of view, they are mutable. */
+  mutable unsigned int m_lastUsedMillis;
+  mutable Value m_value;
+
+  CGUIFontCacheEntry(const CGUIFontCache<Position, Value> &cache, const CGUIFontCacheKey<Position> &key, unsigned int nowMillis) :
+    m_cache(cache),
+    m_key(key.m_pos,
+          *new vecColors, *new vecText,
+          key.m_alignment, key.m_maxPixelWidth,
+          key.m_scrolling, m_matrix,
+          key.m_scaleX, key.m_scaleY),
+    m_lastUsedMillis(nowMillis)
+  {
+    m_key.m_colors.assign(key.m_colors.begin(), key.m_colors.end());
+    m_key.m_text.assign(key.m_text.begin(), key.m_text.end());
+    m_matrix = key.m_matrix;
+  }
+
+  CGUIFontCacheEntry(const CGUIFontCacheEntry &other) :
+    m_cache(other.m_cache),
+    m_key(other.m_key.m_pos,
+          *new vecColors, *new vecText,
+          other.m_key.m_alignment, other.m_key.m_maxPixelWidth,
+          other.m_key.m_scrolling, m_matrix,
+          other.m_key.m_scaleX, other.m_key.m_scaleY),
+    m_lastUsedMillis(other.m_lastUsedMillis),
+    m_value(other.m_value)
+  {
+    m_key.m_colors.assign(other.m_key.m_colors.begin(), other.m_key.m_colors.end());
+    m_key.m_text.assign(other.m_key.m_text.begin(), other.m_key.m_text.end());
+    m_matrix = other.m_key.m_matrix;
+  }
+
+  struct Reassign
+  {
+    Reassign(const CGUIFontCacheKey<Position> &key, unsigned int nowMillis) : m_key(key), m_nowMillis(nowMillis) {}
+    void operator()(CGUIFontCacheEntry &entry);
+  private:
+    const CGUIFontCacheKey<Position> &m_key;
+    unsigned int m_nowMillis;
+  };
+
+  ~CGUIFontCacheEntry();
+};
+
+template<class Position>
+struct CGUIFontCacheHash
+{
+  size_t operator()(const CGUIFontCacheKey<Position> &key) const
+  {
+    /* Not much effort has gone into choosing this hash function */
+    size_t hash = 0, i;
+    for (i = 0; i < 3 && i < key.m_text.size(); ++i)
+      hash += key.m_text[i];
+    if (key.m_colors.size())
+      hash += key.m_colors[0];
+    hash += MatrixHashContribution(key);
+    return hash;
+  }
+};
+
+template<class Position>
+struct CGUIFontCacheKeysMatch
+{
+  bool operator()(const CGUIFontCacheKey<Position> &a, const CGUIFontCacheKey<Position> &b) const
+  {
+    return a.m_text == b.m_text &&
+           a.m_colors == b.m_colors &&
+           a.m_alignment == b.m_alignment &&
+           a.m_scrolling == b.m_scrolling &&
+           a.m_maxPixelWidth == b.m_maxPixelWidth &&
+           Match(a.m_pos, a.m_matrix, b.m_pos, b.m_matrix, a.m_scrolling) &&
+           a.m_scaleX == b.m_scaleX &&
+           a.m_scaleY == b.m_scaleY;
+  }
+};
+
+template<class Position, class Value>
+class CGUIFontCache
+{
+  /* Empty structs used as tags to identify indexes */
+  struct Age {};
+  struct Hash {};
+
+  typedef multi_index_container<
+      CGUIFontCacheEntry<Position, Value>,
+      indexed_by<
+          sequenced<tag<Age> >,
+          hashed_unique<tag<Hash>, member<CGUIFontCacheEntry<Position, Value>, CGUIFontCacheKey<Position>, &CGUIFontCacheEntry<Position, Value>::m_key>, CGUIFontCacheHash<Position>, CGUIFontCacheKeysMatch<Position> >
+      >
+  > EntryList;
+
+  typedef typename EntryList::template index<Age>::type::iterator EntryAgeIterator;
+  typedef typename EntryList::template index<Hash>::type::iterator EntryHashIterator;
+
+  EntryList m_list;
+
+public:
+  const CGUIFontTTFBase &m_font;
+
+  CGUIFontCache(CGUIFontTTFBase &font) : m_font(font) {}
+  Value &Lookup(Position &pos,
+                const vecColors &colors, const vecText &text,
+                uint32_t alignment, float maxPixelWidth,
+                bool scrolling,
+                unsigned int nowMillis, bool &dirtyCache);
+  void Flush();
+};
+
+struct CGUIFontCacheStaticPosition
+{
+  float m_x;
+  float m_y;
+  CGUIFontCacheStaticPosition(float x, float y) : m_x(x), m_y(y) {}
+};
+
+typedef std::vector<SVertex> CGUIFontCacheStaticValue;
+
+inline bool Match(const CGUIFontCacheStaticPosition &a, const TransformMatrix &a_m,
+                  const CGUIFontCacheStaticPosition &b, const TransformMatrix &b_m,
+                  bool scrolling)
+{
+  return a.m_x == b.m_x && a.m_y == b.m_y && a_m == b_m;
+}
+
+inline float MatrixHashContribution(const CGUIFontCacheKey<CGUIFontCacheStaticPosition> &a)
+{
+  /* Ensure horizontally translated versions end up in different buckets */
+  return a.m_matrix.m[0][3];
+}
+
+#endif
diff --git a/xbmc/guilib/GUIFontTTF.cpp b/xbmc/guilib/GUIFontTTF.cpp
index 1aaf68b..288e61a 100644
--- a/xbmc/guilib/GUIFontTTF.cpp
+++ b/xbmc/guilib/GUIFontTTF.cpp
@@ -27,6 +27,7 @@
 #include "utils/MathUtils.h"
 #include "utils/log.h"
 #include "windowing/WindowingFactory.h"
+#include "threads/SystemClock.h"
 
 #include <math.h>
 
@@ -131,7 +132,7 @@ class CFreeTypeLibrary
 XBMC_GLOBAL_REF(CFreeTypeLibrary, g_freeTypeLibrary); // our freetype library
 #define g_freeTypeLibrary XBMC_GLOBAL_USE(CFreeTypeLibrary)
 
-CGUIFontTTFBase::CGUIFontTTFBase(const CStdString& strFileName)
+CGUIFontTTFBase::CGUIFontTTFBase(const CStdString& strFileName) : m_staticCache(*this)
 {
   m_texture = NULL;
   m_char = NULL;
@@ -330,108 +331,120 @@ void CGUIFontTTFBase::DrawTextInternal(float x, float y, const vecColors &colors
 {
   Begin();
 
-  std::vector<SVertex> &vertices = m_vertex;
-
-  // save the origin, which is scaled separately
-  m_originX = x;
-  m_originY = y;
-
-  // Check if we will really need to truncate or justify the text
-  if ( alignment & XBFONT_TRUNCATED )
+  bool dirtyCache;
+  CGUIFontCacheStaticPosition staticPos(x, y);
+  std::vector<SVertex> &vertices = m_staticCache.Lookup(staticPos,
+                                                        colors, text,
+                                                        alignment, maxPixelWidth,
+                                                        scrolling,
+                                                        XbmcThreads::SystemClockMillis(),
+                                                        dirtyCache);
+  if (dirtyCache)
   {
-    if ( maxPixelWidth <= 0.0f || GetTextWidthInternal(text.begin(), text.end()) <= maxPixelWidth)
-      alignment &= ~XBFONT_TRUNCATED;
-  }
-  else if ( alignment & XBFONT_JUSTIFIED )
-  {
-    if ( maxPixelWidth <= 0.0f )
-      alignment &= ~XBFONT_JUSTIFIED;
-  }
+    // save the origin, which is scaled separately
+    m_originX = x;
+    m_originY = y;
 
-  // calculate sizing information
-  float startX = 0;
-  float startY = (alignment & XBFONT_CENTER_Y) ? -0.5f*m_cellHeight : 0;  // vertical centering
+    // Check if we will really need to truncate or justify the text
+    if ( alignment & XBFONT_TRUNCATED )
+    {
+      if ( maxPixelWidth <= 0.0f || GetTextWidthInternal(text.begin(), text.end()) <= maxPixelWidth)
+        alignment &= ~XBFONT_TRUNCATED;
+    }
+    else if ( alignment & XBFONT_JUSTIFIED )
+    {
+      if ( maxPixelWidth <= 0.0f )
+        alignment &= ~XBFONT_JUSTIFIED;
+    }
 
-  if ( alignment & (XBFONT_RIGHT | XBFONT_CENTER_X) )
-  {
-    // Get the extent of this line
-    float w = GetTextWidthInternal( text.begin(), text.end() );
+    // calculate sizing information
+    float startX = 0;
+    float startY = (alignment & XBFONT_CENTER_Y) ? -0.5f*m_cellHeight : 0;  // vertical centering
 
-    if ( alignment & XBFONT_TRUNCATED && w > maxPixelWidth + 0.5f ) // + 0.5f due to rounding issues
-      w = maxPixelWidth;
+    if ( alignment & (XBFONT_RIGHT | XBFONT_CENTER_X) )
+    {
+      // Get the extent of this line
+      float w = GetTextWidthInternal( text.begin(), text.end() );
 
-    if ( alignment & XBFONT_CENTER_X)
-      w *= 0.5f;
-    // Offset this line's starting position
-    startX -= w;
-  }
+      if ( alignment & XBFONT_TRUNCATED && w > maxPixelWidth + 0.5f ) // + 0.5f due to rounding issues
+        w = maxPixelWidth;
 
-  float spacePerLetter = 0; // for justification effects
-  if ( alignment & XBFONT_JUSTIFIED )
-  {
-    // first compute the size of the text to render in both characters and pixels
-    unsigned int lineChars = 0;
-    float linePixels = 0;
-    for (vecText::const_iterator pos = text.begin(); pos != text.end(); ++pos)
+      if ( alignment & XBFONT_CENTER_X)
+        w *= 0.5f;
+      // Offset this line's starting position
+      startX -= w;
+    }
+
+    float spacePerLetter = 0; // for justification effects
+    if ( alignment & XBFONT_JUSTIFIED )
     {
-      Character *ch = GetCharacter(*pos);
-      if (ch)
-      { // spaces have multiple times the justification spacing of normal letters
-        lineChars += ((*pos & 0xffff) == L' ') ? justification_word_weight : 1;
-        linePixels += ch->advance;
+      // first compute the size of the text to render in both characters and pixels
+      unsigned int lineChars = 0;
+      float linePixels = 0;
+      for (vecText::const_iterator pos = text.begin(); pos != text.end(); ++pos)
+      {
+        Character *ch = GetCharacter(*pos);
+        if (ch)
+        { // spaces have multiple times the justification spacing of normal letters
+          lineChars += ((*pos & 0xffff) == L' ') ? justification_word_weight : 1;
+          linePixels += ch->advance;
+        }
       }
+      if (lineChars > 1)
+        spacePerLetter = (maxPixelWidth - linePixels) / (lineChars - 1);
     }
-    if (lineChars > 1)
-      spacePerLetter = (maxPixelWidth - linePixels) / (lineChars - 1);
-  }
-  float cursorX = 0; // current position along the line
-
-  for (vecText::const_iterator pos = text.begin(); pos != text.end(); ++pos)
-  {
-    // If starting text on a new line, determine justification effects
-    // Get the current letter in the CStdString
-    color_t color = (*pos & 0xff0000) >> 16;
-    if (color >= colors.size())
-      color = 0;
-    color = colors[color];
+    float cursorX = 0; // current position along the line
 
-    // grab the next character
-    Character *ch = GetCharacter(*pos);
-    if (!ch) continue;
-
-    if ( alignment & XBFONT_TRUNCATED )
+    for (vecText::const_iterator pos = text.begin(); pos != text.end(); ++pos)
     {
-      // Check if we will be exceeded the max allowed width
-      if ( cursorX + ch->advance + 3 * m_ellipsesWidth > maxPixelWidth )
-      {
-        // Yup. Let's draw the ellipses, then bail
-        // Perhaps we should really bail to the next line in this case??
-        Character *period = GetCharacter(L'.');
-        if (!period)
-          break;
+      // If starting text on a new line, determine justification effects
+      // Get the current letter in the CStdString
+      color_t color = (*pos & 0xff0000) >> 16;
+      if (color >= colors.size())
+        color = 0;
+      color = colors[color];
+
+      // grab the next character
+      Character *ch = GetCharacter(*pos);
+      if (!ch) continue;
 
-        for (int i = 0; i < 3; i++)
+      if ( alignment & XBFONT_TRUNCATED )
+      {
+        // Check if we will be exceeded the max allowed width
+        if ( cursorX + ch->advance + 3 * m_ellipsesWidth > maxPixelWidth )
         {
-          RenderCharacter(startX + cursorX, startY, period, color, !scrolling, vertices);
-          cursorX += period->advance;
+          // Yup. Let's draw the ellipses, then bail
+          // Perhaps we should really bail to the next line in this case??
+          Character *period = GetCharacter(L'.');
+          if (!period)
+            break;
+
+          for (int i = 0; i < 3; i++)
+          {
+            RenderCharacter(startX + cursorX, startY, period, color, !scrolling, vertices);
+            cursorX += period->advance;
+          }
+          break;
         }
-        break;
       }
-    }
-    else if (maxPixelWidth > 0 && cursorX > maxPixelWidth)
-      break;  // exceeded max allowed width - stop rendering
+      else if (maxPixelWidth > 0 && cursorX > maxPixelWidth)
+        break;  // exceeded max allowed width - stop rendering
 
-    RenderCharacter(startX + cursorX, startY, ch, color, !scrolling, vertices);
-    if ( alignment & XBFONT_JUSTIFIED )
-    {
-      if ((*pos & 0xffff) == L' ')
-        cursorX += ch->advance + spacePerLetter * justification_word_weight;
+      RenderCharacter(startX + cursorX, startY, ch, color, !scrolling, vertices);
+      if ( alignment & XBFONT_JUSTIFIED )
+      {
+        if ((*pos & 0xffff) == L' ')
+          cursorX += ch->advance + spacePerLetter * justification_word_weight;
+        else
+          cursorX += ch->advance + spacePerLetter;
+      }
       else
-        cursorX += ch->advance + spacePerLetter;
+        cursorX += ch->advance;
     }
-    else
-      cursorX += ch->advance;
   }
+  /* Append the new vertices (from the cache or otherwise) to the set collected
+   * since the first Begin() call */
+  m_vertex.insert(m_vertex.end(), vertices.begin(), vertices.end());
 
   End();
 }
diff --git a/xbmc/guilib/GUIFontTTF.h b/xbmc/guilib/GUIFontTTF.h
index 4a6a696..7cb4669 100644
--- a/xbmc/guilib/GUIFontTTF.h
+++ b/xbmc/guilib/GUIFontTTF.h
@@ -64,6 +64,9 @@ struct SVertex
 };
 
 
+#include "GUIFontCache.h"
+
+
 class CGUIFontTTFBase
 {
   friend class CGUIFont;
@@ -166,6 +169,8 @@ class CGUIFontTTFBase
 
   CStdString m_strFileName;
 
+  CGUIFontCache<CGUIFontCacheStaticPosition, CGUIFontCacheStaticValue> m_staticCache;
+
 private:
   virtual bool FirstBegin() = 0;
   virtual void LastEnd() = 0;
diff --git a/xbmc/guilib/GUIFontTTFGL.cpp b/xbmc/guilib/GUIFontTTFGL.cpp
index a4e8571..cb56987 100644
--- a/xbmc/guilib/GUIFontTTFGL.cpp
+++ b/xbmc/guilib/GUIFontTTFGL.cpp
@@ -200,6 +200,7 @@ CBaseTexture* CGUIFontTTFGL::ReallocTexture(unsigned int& newHeight)
   m_textureScaleX = 1.0f / m_textureWidth;
   if (m_textureHeight < newHeight)
     CLog::Log(LOGWARNING, "%s: allocated new texture with height of %d, requested %d", __FUNCTION__, m_textureHeight, newHeight);
+  m_staticCache.Flush();
 
   memset(newTexture->GetPixels(), 0, m_textureHeight * newTexture->GetPitch());
   if (m_texture)
diff --git a/xbmc/guilib/GraphicContext.h b/xbmc/guilib/GraphicContext.h
index 6c2dcd4..bab2457 100644
--- a/xbmc/guilib/GraphicContext.h
+++ b/xbmc/guilib/GraphicContext.h
@@ -146,6 +146,7 @@ class CGraphicContext : public CCriticalSection,
   inline void ScaleFinalCoords(float &x, float &y, float &z) const XBMC_FORCE_INLINE { m_finalTransform.matrix.TransformPosition(x, y, z); }
   bool RectIsAngled(float x1, float y1, float x2, float y2) const;
 
+  inline const TransformMatrix &GetGUIMatrix() const XBMC_FORCE_INLINE { return m_finalTransform.matrix; }
   inline float GetGUIScaleX() const XBMC_FORCE_INLINE { return m_finalTransform.scaleX; }
   inline float GetGUIScaleY() const XBMC_FORCE_INLINE { return m_finalTransform.scaleY; }
   inline color_t MergeAlpha(color_t color) const XBMC_FORCE_INLINE
diff --git a/xbmc/guilib/Makefile.in b/xbmc/guilib/Makefile.in
index 086fb0d..af82979 100644
--- a/xbmc/guilib/Makefile.in
+++ b/xbmc/guilib/Makefile.in
@@ -23,6 +23,7 @@ SRCS += GUIEditControl.cpp
 SRCS += GUIFadeLabelControl.cpp
 SRCS += GUIFixedListContainer.cpp
 SRCS += GUIFont.cpp
+SRCS += GUIFontCache.cpp
 SRCS += GUIFontManager.cpp
 SRCS += GUIFontTTF.cpp
 SRCS += GUIImage.cpp
diff --git a/xbmc/guilib/TransformMatrix.h b/xbmc/guilib/TransformMatrix.h
index f351c99..9036ba9 100644
--- a/xbmc/guilib/TransformMatrix.h
+++ b/xbmc/guilib/TransformMatrix.h
@@ -245,3 +245,14 @@ class TransformMatrix
   float alpha;
   bool identity;
 };
+
+inline bool operator==(const TransformMatrix &a, const TransformMatrix &b)
+{
+  return a.alpha == b.alpha && ((a.identity && b.identity) ||
+      (!a.identity && !b.identity && std::equal(&a.m[0][0], &a.m[0][0] + sizeof a.m / sizeof a.m[0][0], &b.m[0][0])));
+}
+
+inline bool operator!=(const TransformMatrix &a, const TransformMatrix &b)
+{
+  return !operator==(a, b);
+}
-- 
1.9.3


From 87d36e7f4d045a70075c0e084e9869a89b0ab51f Mon Sep 17 00:00:00 2001
From: Ben Avison <bavison@riscosopen.org>
Date: Thu, 23 Jan 2014 22:24:17 +0000
Subject: [PATCH 005/102] Lay the groundwork for hardware clipping.

For glScissor() to replace CGraphicContext::ClipRect, a necessary condition
is that no shear or rotation is introduced between the coordinate systems
they use; this depends upon the settings of the GUI matrix m_finalTransform
as well as the OpenGL model-view and projection matrices. These all remain
unchanged between paired calls of CGUIShader::OnEnabled and
CGUIShader::OnDisabled, so we scan the matrices in CGUIShader::OnEnabled to
see whether hardware clipping is possible.

Then, in CGUIFontTTFBase::RenderCharacter, we don't apply software clipping
in such cases. However, because vertices arising from multiple
CGUIFontTTFBase::DrawTextInternal calls (each of which often uses a different
clip rectangle) get lumped into the same vector, which only at the end is
passed to OpenGL for rendering, we need to wait a few commits before we can
actually apply hardware clipping. In the meantime, expect to see rendering
errors.
---
 xbmc/guilib/GUIFontTTF.cpp               |  3 +-
 xbmc/guilib/GUIShader.cpp                | 80 +++++++++++++++++++++++++++++++-
 xbmc/guilib/GUIShader.h                  | 11 +++++
 xbmc/guilib/GraphicContext.cpp           | 10 ++++
 xbmc/guilib/GraphicContext.h             |  1 +
 xbmc/rendering/RenderSystem.h            |  2 +
 xbmc/rendering/gles/RenderSystemGLES.cpp | 22 +++++++++
 xbmc/rendering/gles/RenderSystemGLES.h   |  2 +
 8 files changed, 128 insertions(+), 3 deletions(-)

diff --git a/xbmc/guilib/GUIFontTTF.cpp b/xbmc/guilib/GUIFontTTF.cpp
index 288e61a..19c7ff4 100644
--- a/xbmc/guilib/GUIFontTTF.cpp
+++ b/xbmc/guilib/GUIFontTTF.cpp
@@ -710,7 +710,8 @@ void CGUIFontTTFBase::RenderCharacter(float posX, float posY, const Character *c
                (posY + ch->offsetY + height) * g_graphicsContext.GetGUIScaleY());
   vertex += CPoint(m_originX, m_originY);
   CRect texture(ch->left, ch->top, ch->right, ch->bottom);
-  g_graphicsContext.ClipRect(vertex, texture);
+  if (!g_Windowing.ScissorsCanEffectClipping())
+    g_graphicsContext.ClipRect(vertex, texture);
 
   // transform our positions - note, no scaling due to GUI calibration/resolution occurs
   float x[4], y[4], z[4];
diff --git a/xbmc/guilib/GUIShader.cpp b/xbmc/guilib/GUIShader.cpp
index 11089b8..53bce09 100644
--- a/xbmc/guilib/GUIShader.cpp
+++ b/xbmc/guilib/GUIShader.cpp
@@ -26,6 +26,8 @@
 #include "GUIShader.h"
 #include "MatrixGLES.h"
 #include "utils/log.h"
+#include "windowing/egl/WinSystemEGL.h"
+#include "guilib/GraphicContext.h"
 
 CGUIShader::CGUIShader( const char *shader ) : CGLSLShaderProgram("guishader_vert.glsl", shader)
 {
@@ -86,8 +88,82 @@ bool CGUIShader::OnEnabled()
 {
   // This is called after glUseProgram()
 
-  glUniformMatrix4fv(m_hProj,  1, GL_FALSE, g_matrices.GetMatrix(MM_PROJECTION));
-  glUniformMatrix4fv(m_hModel, 1, GL_FALSE, g_matrices.GetMatrix(MM_MODELVIEW));
+  GLfloat *projMatrix = g_matrices.GetMatrix(MM_PROJECTION);
+  GLfloat *modelMatrix = g_matrices.GetMatrix(MM_MODELVIEW);
+  glUniformMatrix4fv(m_hProj,  1, GL_FALSE, projMatrix);
+  glUniformMatrix4fv(m_hModel, 1, GL_FALSE, modelMatrix);
+
+  const TransformMatrix &guiMatrix = g_graphicsContext.GetGUIMatrix();
+  CRect viewPort; // absolute positions of corners
+  g_Windowing.GetViewPort(viewPort);
+
+  /* glScissor operates in window coordinates. In order that we can use it to
+   * perform clipping, we must ensure that there is an independent linear
+   * transformation from the coordinate system used by CGraphicContext::ClipRect
+   * to window coordinates, separately for X and Y (in other words, no
+   * rotation or shear is introduced at any stage). To do, this, we need to
+   * check that zeros are present in the following locations:
+   *
+   * GUI matrix:
+   * / * 0 * * \
+   * | 0 * * * |
+   * \ 0 0 * * /
+   *       ^ TransformMatrix::TransformX/Y/ZCoord are only ever called with
+   *         input z = 0, so this column doesn't matter
+   * Model-view matrix:
+   * / * 0 0 * \
+   * | 0 * 0 * |
+   * | 0 0 * * |
+   * \ * * * * /  <- eye w has no influence on window x/y (last column below
+   *                                                       is either 0 or ignored)
+   * Projection matrix:
+   * / * 0 0 0 \
+   * | 0 * 0 0 |
+   * | * * * * |  <- normalised device coordinate z has no influence on window x/y
+   * \ 0 0 * 0 /
+   *
+   * Some of these zeros are not strictly required to ensure this, but they tend
+   * to be zeroed in the common case, so by checking for zeros here, we simplify
+   * the calculation of the window x/y coordinates further down the line.
+   *
+   * (Minor detail: we don't quite deal in window coordinates as defined by
+   * OpenGL, because CRenderSystemGLES::SetScissors flips the Y axis. But all
+   * that's needed to handle that is an effective negation at the stage where
+   * Y is in normalised device coordinates.)
+   */
+  m_clipPossible = guiMatrix.m[0][1] == 0 &&
+      guiMatrix.m[1][0] == 0 &&
+      guiMatrix.m[2][0] == 0 &&
+      guiMatrix.m[2][1] == 0 &&
+      modelMatrix[0+1*4] == 0 &&
+      modelMatrix[0+2*4] == 0 &&
+      modelMatrix[1+0*4] == 0 &&
+      modelMatrix[1+2*4] == 0 &&
+      modelMatrix[2+0*4] == 0 &&
+      modelMatrix[2+1*4] == 0 &&
+      projMatrix[0+1*4] == 0 &&
+      projMatrix[0+2*4] == 0 &&
+      projMatrix[0+3*4] == 0 &&
+      projMatrix[1+0*4] == 0 &&
+      projMatrix[1+2*4] == 0 &&
+      projMatrix[1+3*4] == 0 &&
+      projMatrix[3+0*4] == 0 &&
+      projMatrix[3+1*4] == 0 &&
+      projMatrix[3+3*4] == 0;
+  if (m_clipPossible)
+  {
+    m_clipXFactor = guiMatrix.m[0][0] * modelMatrix[0+0*4] * projMatrix[0+0*4];
+    m_clipXOffset = (guiMatrix.m[0][3] * modelMatrix[0+0*4] + modelMatrix[0+3*4]) * projMatrix[0+0*4];
+    m_clipYFactor = guiMatrix.m[1][1] * modelMatrix[1+1*4] * projMatrix[1+1*4];
+    m_clipYOffset = (guiMatrix.m[1][3] * modelMatrix[1+1*4] + modelMatrix[1+3*4]) * projMatrix[1+1*4];
+    float clipW = (guiMatrix.m[2][3] * modelMatrix[2+2*4] + modelMatrix[2+3*4]) * projMatrix[3+2*4];
+    float xMult = (viewPort.x2 - viewPort.x1) / (2 * clipW);
+    float yMult = (viewPort.y1 - viewPort.y2) / (2 * clipW); // correct for inverted window coordinate scheme
+    m_clipXFactor = m_clipXFactor * xMult;
+    m_clipXOffset = m_clipXOffset * xMult + (viewPort.x2 + viewPort.x1) / 2;
+    m_clipYFactor = m_clipYFactor * yMult;
+    m_clipYOffset = m_clipYOffset * yMult + (viewPort.y2 + viewPort.y1) / 2;
+  }
 
   return true;
 }
diff --git a/xbmc/guilib/GUIShader.h b/xbmc/guilib/GUIShader.h
index c7e95aa..86ce4cc 100644
--- a/xbmc/guilib/GUIShader.h
+++ b/xbmc/guilib/GUIShader.h
@@ -41,6 +41,11 @@ class CGUIShader : public CGLSLShaderProgram
   GLint GetCord1Loc() { return m_hCord1; }
   GLint GetUniColLoc() { return m_hUniCol; }
   GLint GetCoord0MatrixLoc() { return m_hCoord0Matrix; }
+  bool HardwareClipIsPossible() { return m_clipPossible; }
+  GLfloat GetClipXFactor() { return m_clipXFactor; }
+  GLfloat GetClipXOffset() { return m_clipXOffset; }
+  GLfloat GetClipYFactor() { return m_clipYFactor; }
+  GLfloat GetClipYOffset() { return m_clipYOffset; }
 
 protected:
   GLint m_hTex0;
@@ -56,6 +61,12 @@ class CGUIShader : public CGLSLShaderProgram
 
   GLfloat *m_proj;
   GLfloat *m_model;
+
+  bool m_clipPossible;
+  GLfloat m_clipXFactor;
+  GLfloat m_clipXOffset;
+  GLfloat m_clipYFactor;
+  GLfloat m_clipYOffset;
 };
 
 #endif // GUI_SHADER_H
diff --git a/xbmc/guilib/GraphicContext.cpp b/xbmc/guilib/GraphicContext.cpp
index 38f17a7..5bffdf5 100644
--- a/xbmc/guilib/GraphicContext.cpp
+++ b/xbmc/guilib/GraphicContext.cpp
@@ -167,6 +167,16 @@ void CGraphicContext::ClipRect(CRect &vertex, CRect &texture, CRect *texture2)
   }
 }
 
+CRect CGraphicContext::GetClipRegion()
+{
+  if (m_clipRegions.empty())
+    return CRect(0, 0, m_iScreenWidth, m_iScreenHeight);
+  CRect clipRegion(m_clipRegions.top());
+  if (!m_origins.empty())
+    clipRegion -= m_origins.top();
+  return clipRegion;
+}
+
 bool CGraphicContext::SetViewPort(float fx, float fy, float fwidth, float fheight, bool intersectPrevious /* = false */)
 {
   // transform coordinates - we may have a rotation which changes the positioning of the
diff --git a/xbmc/guilib/GraphicContext.h b/xbmc/guilib/GraphicContext.h
index bab2457..0a27643 100644
--- a/xbmc/guilib/GraphicContext.h
+++ b/xbmc/guilib/GraphicContext.h
@@ -199,6 +199,7 @@ class CGraphicContext : public CCriticalSection,
   void ApplyHardwareTransform();
   void RestoreHardwareTransform();
   void ClipRect(CRect &vertex, CRect &texture, CRect *diffuse = NULL);
+  CRect GetClipRegion();
   inline void AddGUITransform()
   {
     m_transforms.push(m_finalTransform);
diff --git a/xbmc/rendering/RenderSystem.h b/xbmc/rendering/RenderSystem.h
index fa64eba..c1dfb93 100644
--- a/xbmc/rendering/RenderSystem.h
+++ b/xbmc/rendering/RenderSystem.h
@@ -110,6 +110,8 @@ class CRenderSystemBase
   virtual void GetViewPort(CRect& viewPort) = 0;
   virtual void RestoreViewPort() {};
 
+  virtual bool ScissorsCanEffectClipping() { return false; }
+  virtual CRect ClipRectToScissorRect(const CRect &rect) { return CRect(); }
   virtual void SetScissors(const CRect &rect) = 0;
   virtual void ResetScissors() = 0;
 
diff --git a/xbmc/rendering/gles/RenderSystemGLES.cpp b/xbmc/rendering/gles/RenderSystemGLES.cpp
index 653c9ec..deb3afc 100644
--- a/xbmc/rendering/gles/RenderSystemGLES.cpp
+++ b/xbmc/rendering/gles/RenderSystemGLES.cpp
@@ -533,6 +533,28 @@ void CRenderSystemGLES::SetViewPort(CRect& viewPort)
   m_viewPort[3] = viewPort.Height();
 }
 
+bool CRenderSystemGLES::ScissorsCanEffectClipping()
+{
+  if (m_pGUIshader[m_method])
+    return m_pGUIshader[m_method]->HardwareClipIsPossible();
+
+  return false;
+}
+
+CRect CRenderSystemGLES::ClipRectToScissorRect(const CRect &rect)
+{
+  if (!m_pGUIshader[m_method])
+    return CRect();
+  float xFactor = m_pGUIshader[m_method]->GetClipXFactor();
+  float xOffset = m_pGUIshader[m_method]->GetClipXOffset();
+  float yFactor = m_pGUIshader[m_method]->GetClipYFactor();
+  float yOffset = m_pGUIshader[m_method]->GetClipYOffset();
+  return CRect(rect.x1 * xFactor + xOffset,
+               rect.y1 * yFactor + yOffset,
+               rect.x2 * xFactor + xOffset,
+               rect.y2 * yFactor + yOffset);
+}
+
 void CRenderSystemGLES::SetScissors(const CRect &rect)
 {
   if (!m_bRenderCreated)
diff --git a/xbmc/rendering/gles/RenderSystemGLES.h b/xbmc/rendering/gles/RenderSystemGLES.h
index 98e398a..81ee49e 100644
--- a/xbmc/rendering/gles/RenderSystemGLES.h
+++ b/xbmc/rendering/gles/RenderSystemGLES.h
@@ -63,6 +63,8 @@ class CRenderSystemGLES : public CRenderSystemBase
   virtual void SetViewPort(CRect& viewPort);
   virtual void GetViewPort(CRect& viewPort);
 
+  virtual bool ScissorsCanEffectClipping();
+  virtual CRect ClipRectToScissorRect(const CRect &rect);
   virtual void SetScissors(const CRect& rect);
   virtual void ResetScissors();
 
-- 
1.9.3


From f6889534ebe503adc35ebb3b37d19ec48ae1b1f7 Mon Sep 17 00:00:00 2001
From: Ben Avison <bavison@riscosopen.org>
Date: Thu, 23 Jan 2014 16:42:22 +0000
Subject: [PATCH 006/102] Increase font cache hit rate by keying on the
 fractional part of m_originX and m_originY *after* they have been through the
 graphics context's transformation matrix, plus the scale/rotation elements of
 the matrix, rather than the origin in the original frame of reference plus
 the complete transformation matrix. All vertices of individual glyph bounding
 boxes are a constant offset from this position, and when the fractional part
 of the translation is a match, the rounding of each vertex will be in the
 same direction; this permits us to calculate the desired vertices from the
 cached ones simply by adding the integer parts of the translations with no
 additional rounding steps.

Note that this requires that software clipping is *not* performed.
---
 xbmc/guilib/GUIFontCache.cpp |  8 +++++++
 xbmc/guilib/GUIFontCache.h   | 43 +++++++++++++++++++++++++++++++++++
 xbmc/guilib/GUIFontTTF.cpp   | 53 +++++++++++++++++++++++++++++++++++---------
 xbmc/guilib/GUIFontTTF.h     |  1 +
 4 files changed, 95 insertions(+), 10 deletions(-)

diff --git a/xbmc/guilib/GUIFontCache.cpp b/xbmc/guilib/GUIFontCache.cpp
index c029713..b66c00b 100644
--- a/xbmc/guilib/GUIFontCache.cpp
+++ b/xbmc/guilib/GUIFontCache.cpp
@@ -85,6 +85,9 @@ Value &CGUIFontCache<Position, Value>::Lookup(Position &pos,
   else
   {
     /* Cache hit */
+    /* Update the translation arguments so that they hold the offset to apply
+     * to the cached values (but only in the dynamic case) */
+    pos.UpdateWithOffsets(i->m_key.m_pos, scrolling);
     /* Update time in entry and move to the back of the list */
     i->m_lastUsedMillis = nowMillis;
     m_list.get<Age>().relocate(m_list.get<Age>().end(), m_list.project<Age>(i));
@@ -103,3 +106,8 @@ template void CGUIFontCacheEntry<CGUIFontCacheStaticPosition, CGUIFontCacheStati
 template CGUIFontCacheEntry<CGUIFontCacheStaticPosition, CGUIFontCacheStaticValue>::~CGUIFontCacheEntry();
 template CGUIFontCacheStaticValue &CGUIFontCache<CGUIFontCacheStaticPosition, CGUIFontCacheStaticValue>::Lookup(CGUIFontCacheStaticPosition &, const vecColors &, const vecText &, uint32_t, float, bool, unsigned int, bool &);
 template void CGUIFontCache<CGUIFontCacheStaticPosition, CGUIFontCacheStaticValue>::Flush();
+
+template void CGUIFontCacheEntry<CGUIFontCacheDynamicPosition, CGUIFontCacheDynamicValue>::Reassign::operator()(CGUIFontCacheEntry<CGUIFontCacheDynamicPosition, CGUIFontCacheDynamicValue> &entry);
+template CGUIFontCacheEntry<CGUIFontCacheDynamicPosition, CGUIFontCacheDynamicValue>::~CGUIFontCacheEntry();
+template CGUIFontCacheDynamicValue &CGUIFontCache<CGUIFontCacheDynamicPosition, CGUIFontCacheDynamicValue>::Lookup(CGUIFontCacheDynamicPosition &, const vecColors &, const vecText &, uint32_t, float, bool, unsigned int, bool &);
+template void CGUIFontCache<CGUIFontCacheDynamicPosition, CGUIFontCacheDynamicValue>::Flush();
diff --git a/xbmc/guilib/GUIFontCache.h b/xbmc/guilib/GUIFontCache.h
index ef65845..d913dee 100644
--- a/xbmc/guilib/GUIFontCache.h
+++ b/xbmc/guilib/GUIFontCache.h
@@ -44,6 +44,7 @@
 using namespace boost::multi_index;
 
 #define FONT_CACHE_TIME_LIMIT (1000)
+#define FONT_CACHE_DIST_LIMIT (0.01)
 
 template<class Position, class Value> class CGUIFontCache;
 class CGUIFontTTFBase;
@@ -197,6 +198,7 @@ struct CGUIFontCacheStaticPosition
   float m_x;
   float m_y;
   CGUIFontCacheStaticPosition(float x, float y) : m_x(x), m_y(y) {}
+  void UpdateWithOffsets(const CGUIFontCacheStaticPosition &cached, bool scrolling) {}
 };
 
 typedef std::vector<SVertex> CGUIFontCacheStaticValue;
@@ -214,4 +216,45 @@ inline float MatrixHashContribution(const CGUIFontCacheKey<CGUIFontCacheStaticPo
   return a.m_matrix.m[0][3];
 }
 
+struct CGUIFontCacheDynamicPosition
+{
+  float m_x;
+  float m_y;
+  float m_z;
+  CGUIFontCacheDynamicPosition() {}
+  CGUIFontCacheDynamicPosition(float x, float y, float z) : m_x(x), m_y(y), m_z(z) {}
+  void UpdateWithOffsets(const CGUIFontCacheDynamicPosition &cached, bool scrolling)
+  {
+    if (scrolling)
+      m_x = m_x - cached.m_x;
+    else
+      m_x = floorf(m_x - cached.m_x + FONT_CACHE_DIST_LIMIT);
+    m_y = floorf(m_y - cached.m_y + FONT_CACHE_DIST_LIMIT);
+    m_z = floorf(m_z - cached.m_z + FONT_CACHE_DIST_LIMIT);
+  }
+};
+
+typedef std::vector<SVertex> CGUIFontCacheDynamicValue;
+
+inline bool Match(const CGUIFontCacheDynamicPosition &a, const TransformMatrix &a_m,
+                  const CGUIFontCacheDynamicPosition &b, const TransformMatrix &b_m,
+                  bool scrolling)
+{
+  float diffX = a.m_x - b.m_x + FONT_CACHE_DIST_LIMIT;
+  float diffY = a.m_y - b.m_y + FONT_CACHE_DIST_LIMIT;
+  float diffZ = a.m_z - b.m_z + FONT_CACHE_DIST_LIMIT;
+  return (scrolling || diffX - floorf(diffX) < 2 * FONT_CACHE_DIST_LIMIT) &&
+          diffY - floorf(diffY) < 2 * FONT_CACHE_DIST_LIMIT &&
+          diffZ - floorf(diffZ) < 2 * FONT_CACHE_DIST_LIMIT &&
+          a_m.m[0][0] == b_m.m[0][0] &&
+          a_m.m[1][1] == b_m.m[1][1] &&
+          a_m.m[2][2] == b_m.m[2][2];
+          // We already know the first 3 columns of both matrices are diagonal, so no need to check the other elements
+}
+
+inline float MatrixHashContribution(const CGUIFontCacheKey<CGUIFontCacheDynamicPosition> &a)
+{
+  return 0;
+}
+
 #endif
diff --git a/xbmc/guilib/GUIFontTTF.cpp b/xbmc/guilib/GUIFontTTF.cpp
index 19c7ff4..73f0e50 100644
--- a/xbmc/guilib/GUIFontTTF.cpp
+++ b/xbmc/guilib/GUIFontTTF.cpp
@@ -132,7 +132,7 @@ class CFreeTypeLibrary
 XBMC_GLOBAL_REF(CFreeTypeLibrary, g_freeTypeLibrary); // our freetype library
 #define g_freeTypeLibrary XBMC_GLOBAL_USE(CFreeTypeLibrary)
 
-CGUIFontTTFBase::CGUIFontTTFBase(const CStdString& strFileName) : m_staticCache(*this)
+CGUIFontTTFBase::CGUIFontTTFBase(const CStdString& strFileName) : m_staticCache(*this), m_dynamicCache(*this)
 {
   m_texture = NULL;
   m_char = NULL;
@@ -332,13 +332,28 @@ void CGUIFontTTFBase::DrawTextInternal(float x, float y, const vecColors &colors
   Begin();
 
   bool dirtyCache;
+  bool hardwareClipping = g_Windowing.ScissorsCanEffectClipping();
   CGUIFontCacheStaticPosition staticPos(x, y);
-  std::vector<SVertex> &vertices = m_staticCache.Lookup(staticPos,
-                                                        colors, text,
-                                                        alignment, maxPixelWidth,
-                                                        scrolling,
-                                                        XbmcThreads::SystemClockMillis(),
-                                                        dirtyCache);
+  CGUIFontCacheDynamicPosition dynamicPos;
+  if (hardwareClipping)
+  {
+    dynamicPos = CGUIFontCacheDynamicPosition(g_graphicsContext.ScaleFinalXCoord(x, y),
+                                              g_graphicsContext.ScaleFinalYCoord(x, y),
+                                              g_graphicsContext.ScaleFinalZCoord(x, y));
+  }
+  std::vector<SVertex> &vertices = hardwareClipping ?
+      m_dynamicCache.Lookup(dynamicPos,
+                            colors, text,
+                            alignment, maxPixelWidth,
+                            scrolling,
+                            XbmcThreads::SystemClockMillis(),
+                            dirtyCache) :
+      m_staticCache.Lookup(staticPos,
+                           colors, text,
+                           alignment, maxPixelWidth,
+                           scrolling,
+                           XbmcThreads::SystemClockMillis(),
+                           dirtyCache);
   if (dirtyCache)
   {
     // save the origin, which is scaled separately
@@ -441,10 +456,28 @@ void CGUIFontTTFBase::DrawTextInternal(float x, float y, const vecColors &colors
       else
         cursorX += ch->advance;
     }
+    if (hardwareClipping)
+      /* Append the new vertices (which we have just constructed in the cache)
+       * to the set collected since the first Begin() call */
+      m_vertex.insert(m_vertex.end(), vertices.begin(), vertices.end());
+  }
+  else if (hardwareClipping)
+  {
+    /* Apply the translation offset to the vertices from the cache after
+     * appending them to the set collected since the first Begin() call */
+    m_vertex.insert(m_vertex.end(), vertices.begin(), vertices.end());
+    SVertex *v;
+    for (v = &*m_vertex.end() - vertices.size(); v != &*m_vertex.end(); v++)
+    {
+      v->x += dynamicPos.m_x;
+      v->y += dynamicPos.m_y;
+      v->z += dynamicPos.m_z;
+    }
   }
-  /* Append the new vertices (from the cache or otherwise) to the set collected
-   * since the first Begin() call */
-  m_vertex.insert(m_vertex.end(), vertices.begin(), vertices.end());
+  if (!hardwareClipping)
+    /* Append the new vertices (from the cache or otherwise) to the set collected
+     * since the first Begin() call */
+    m_vertex.insert(m_vertex.end(), vertices.begin(), vertices.end());
 
   End();
 }
diff --git a/xbmc/guilib/GUIFontTTF.h b/xbmc/guilib/GUIFontTTF.h
index 7cb4669..78445ab 100644
--- a/xbmc/guilib/GUIFontTTF.h
+++ b/xbmc/guilib/GUIFontTTF.h
@@ -170,6 +170,7 @@ class CGUIFontTTFBase
   CStdString m_strFileName;
 
   CGUIFontCache<CGUIFontCacheStaticPosition, CGUIFontCacheStaticValue> m_staticCache;
+  CGUIFontCache<CGUIFontCacheDynamicPosition, CGUIFontCacheDynamicValue> m_dynamicCache;
 
 private:
   virtual bool FirstBegin() = 0;
-- 
1.9.3


From cb2bda9a1951835142835f34fa99d001766dd637 Mon Sep 17 00:00:00 2001
From: Ben Avison <bavison@riscosopen.org>
Date: Wed, 8 Jan 2014 12:16:33 +0000
Subject: [PATCH 007/102] Rewrite of scrolling text code.

No longer shuffles the string round to minimise the number of characters
before the clipping rectangle; this doesn't save much on rendering time but
does harm the effectiveness of the cache. Now uses a pixel offset into the
string rather than a character + pixel offset, and plots the entire string
every time (execpt when the wrap point is visible, in which case the entire
string is plotted twice).

It also makes motion smoother, because (possibly unintentionally) the
previous code preferred to align the scroll offset with character boundaries.
This would lead to uneven changes of position, especially when the width of
the character currently being scrolled off the edge was only slightly more
than an integral multiple of the scroll increment.
---
 xbmc/guilib/GUIFadeLabelControl.cpp |   8 +--
 xbmc/guilib/GUIFont.cpp             | 123 +++++++++++++-----------------------
 xbmc/guilib/GUIFont.h               |  17 ++---
 xbmc/guilib/GUIRSSControl.cpp       |   6 +-
 xbmc/utils/RssReader.cpp            |   2 +-
 xbmc/utils/RssReader.h              |   2 +-
 6 files changed, 58 insertions(+), 100 deletions(-)

diff --git a/xbmc/guilib/GUIFadeLabelControl.cpp b/xbmc/guilib/GUIFadeLabelControl.cpp
index 844f960..5859d9f 100644
--- a/xbmc/guilib/GUIFadeLabelControl.cpp
+++ b/xbmc/guilib/GUIFadeLabelControl.cpp
@@ -109,18 +109,14 @@ void CGUIFadeLabelControl::Process(unsigned int currentTime, CDirtyRegionList &d
     bool moveToNextLabel = false;
     if (!m_scrollOut)
     {
-      vecText text;
-      m_textLayout.GetFirstText(text);
-      if (m_scrollInfo.characterPos && m_scrollInfo.characterPos < text.size())
-        text.erase(text.begin(), text.begin() + min((int)m_scrollInfo.characterPos - 1, (int)text.size()));
-      if (m_label.font->GetTextWidth(text) < m_width)
+      if (m_scrollInfo.pixelPos + m_width > m_scrollInfo.m_textWidth)
       {
         if (m_fadeAnim.GetProcess() != ANIM_PROCESS_NORMAL)
           m_fadeAnim.QueueAnimation(ANIM_PROCESS_NORMAL);
         moveToNextLabel = true;
       }
     }
-    else if (m_scrollInfo.characterPos > m_textLayout.GetTextLength())
+    else if (m_scrollInfo.pixelPos > m_scrollInfo.m_textWidth)
       moveToNextLabel = true;
     
     // apply the fading animation
diff --git a/xbmc/guilib/GUIFont.cpp b/xbmc/guilib/GUIFont.cpp
index a7ee668..eb8efdb 100644
--- a/xbmc/guilib/GUIFont.cpp
+++ b/xbmc/guilib/GUIFont.cpp
@@ -36,7 +36,12 @@ CScrollInfo::CScrollInfo(unsigned int wait /* = 50 */, float pos /* = 0 */,
     initialWait = wait;
     initialPos = pos;
     SetSpeed(speed ? speed : defaultSpeed);
-    g_charsetConverter.utf8ToW(scrollSuffix, suffix);
+    CStdStringW wsuffix;
+    g_charsetConverter.utf8ToW(scrollSuffix, wsuffix);
+    suffix.clear();
+    suffix.reserve(wsuffix.size());
+    for (vecText::size_type i = 0; i < wsuffix.size(); i++)
+      suffix.push_back(wsuffix[i]);
     Reset();
 }
 
@@ -115,11 +120,12 @@ bool CGUIFont::UpdateScrollInfo(const vecText &text, CScrollInfo &scrollInfo)
 {
   // draw at our scroll position
   // we handle the scrolling as follows:
-  //   We scroll on a per-pixel basis up until we have scrolled the first character outside
-  //   of our viewport, whereby we cycle the string around, and reset the scroll position.
-  //
-  //   pixelPos is the amount in pixels to move the string by.
-  //   characterPos is the amount in characters to rotate the string by.
+  //   We scroll on a per-pixel basis (eschewing the use of character indices
+  //   which were also in use previously). The complete string, including suffix,
+  //   is plotted to achieve the desired effect - normally just the one time, but
+  //   if there is a wrap point within the viewport then it will be plotted twice.
+  //   If the string is smaller than the viewport, then it may be plotted even
+  //   more times than that.
   //
   if (scrollInfo.waitTime)
   {
@@ -135,54 +141,19 @@ bool CGUIFont::UpdateScrollInfo(const vecText &text, CScrollInfo &scrollInfo)
   // move along by the appropriate scroll amount
   float scrollAmount = fabs(scrollInfo.GetPixelsPerFrame() * g_graphicsContext.GetGUIScaleX());
 
-  if (scrollInfo.pixelSpeed > 0)
+  if (!scrollInfo.m_widthValid)
   {
-    // we want to move scrollAmount, grab the next character
-    float charWidth = GetCharWidth(scrollInfo.GetCurrentChar(text));
-    if (scrollInfo.pixelPos + scrollAmount < charWidth)
-      scrollInfo.pixelPos += scrollAmount;  // within the current character
-    else
-    { // past the current character, decrement scrollAmount by the charWidth and move to the next character
-      while (scrollInfo.pixelPos + scrollAmount >= charWidth)
-      {
-        scrollAmount -= (charWidth - scrollInfo.pixelPos);
-        scrollInfo.pixelPos = 0;
-        scrollInfo.characterPos++;
-        if (scrollInfo.characterPos >= text.size() + scrollInfo.suffix.size())
-        {
-          scrollInfo.Reset();
-          break;
-        }
-        charWidth = GetCharWidth(scrollInfo.GetCurrentChar(text));
-      }
-    }
-  }
-  else if (scrollInfo.pixelSpeed < 0)
-  { // scrolling backwards
-    // we want to move scrollAmount, grab the next character
-    float charWidth = GetCharWidth(scrollInfo.GetCurrentChar(text));
-    if (scrollInfo.pixelPos + scrollAmount < charWidth)
-      scrollInfo.pixelPos += scrollAmount;  // within the current character
-    else
-    { // past the current character, decrement scrollAmount by the charWidth and move to the next character
-      while (scrollInfo.pixelPos + scrollAmount >= charWidth)
-      {
-        scrollAmount -= (charWidth - scrollInfo.pixelPos);
-        scrollInfo.pixelPos = 0;
-        if (scrollInfo.characterPos == 0)
-        {
-          scrollInfo.Reset();
-          scrollInfo.characterPos = text.size() + scrollInfo.suffix.size() - 1;
-          break;
-        }
-        scrollInfo.characterPos--;
-        charWidth = GetCharWidth(scrollInfo.GetCurrentChar(text));
-      }
-    }
+    /* Calculate the pixel width of the complete string */
+    scrollInfo.m_textWidth = GetTextWidth(text);
+    scrollInfo.m_totalWidth = scrollInfo.m_textWidth + GetTextWidth(scrollInfo.suffix);
+    scrollInfo.m_widthValid = true;
   }
+  scrollInfo.pixelPos += scrollAmount;
+  assert(scrollInfo.m_totalWidth != 0);
+  while (scrollInfo.pixelPos >= scrollInfo.m_totalWidth)
+    scrollInfo.pixelPos -= scrollInfo.m_totalWidth;
 
-  if(scrollInfo.characterPos != old.characterPos
-  || scrollInfo.pixelPos     != old.pixelPos)
+  if (scrollInfo.pixelPos != old.pixelPos)
     return true;
   else
     return false;
@@ -194,39 +165,27 @@ void CGUIFont::DrawScrollingText(float x, float y, const vecColors &colors, colo
   if (!m_font) return;
   if (!shadowColor) shadowColor = m_shadowColor;
 
-  float spaceWidth = GetCharWidth(L' ');
-  // max chars on screen + extra margin chars
-  vecText::size_type maxChars =
-    std::min<vecText::size_type>(
-      (text.size() + (vecText::size_type)scrollInfo.suffix.size()),
-      (vecText::size_type)((maxWidth * 1.05f) / spaceWidth));
-
   if (!text.size() || ClippedRegionIsEmpty(x, y, maxWidth, alignment))
     return; // nothing to render
 
-  maxWidth = ROUND((maxWidth + scrollInfo.pixelPos) / g_graphicsContext.GetGUIScaleX());
+  if (!scrollInfo.m_widthValid)
+  {
+    /* Calculate the pixel width of the complete string */
+    scrollInfo.m_textWidth = GetTextWidth(text);
+    scrollInfo.m_totalWidth = scrollInfo.m_textWidth + GetTextWidth(scrollInfo.suffix);
+    scrollInfo.m_widthValid = true;
+  }
+
+  assert(scrollInfo.m_totalWidth != 0);
+
+  float textPixelWidth = ROUND(scrollInfo.m_textWidth / g_graphicsContext.GetGUIScaleX());
+  float suffixPixelWidth = ROUND((scrollInfo.m_totalWidth - scrollInfo.m_textWidth) / g_graphicsContext.GetGUIScaleX());
 
-  float charWidth = GetCharWidth(scrollInfo.GetCurrentChar(text));
   float offset;
   if(scrollInfo.pixelSpeed >= 0)
     offset = scrollInfo.pixelPos;
   else
-    offset = charWidth - scrollInfo.pixelPos;
-
-  // Now rotate our string as needed, only take a slightly larger then visible part of the text.
-  unsigned int pos = scrollInfo.characterPos;
-  vecText renderText;
-  renderText.reserve(maxChars);
-  for (vecText::size_type i = 0; i < maxChars; i++)
-  {
-    if (pos >= text.size() + scrollInfo.suffix.size())
-      pos = 0;
-    if (pos < text.size())
-      renderText.push_back(text[pos]);
-    else
-      renderText.push_back(scrollInfo.suffix[pos - text.size()]);
-    pos++;
-  }
+    offset = scrollInfo.m_totalWidth - scrollInfo.pixelPos;
 
   vecColors renderColors;
   for (unsigned int i = 0; i < colors.size(); i++)
@@ -239,9 +198,17 @@ void CGUIFont::DrawScrollingText(float x, float y, const vecColors &colors, colo
     vecColors shadowColors;
     for (unsigned int i = 0; i < renderColors.size(); i++)
       shadowColors.push_back((renderColors[i] & 0xff000000) != 0 ? shadowColor : 0);
-    m_font->DrawTextInternal(x - offset + 1, y + 1, shadowColors, renderText, alignment, maxWidth + m_font->GetLineHeight(2.0f), scroll);
+    for (float dx = -offset; dx < maxWidth; dx += scrollInfo.m_totalWidth)
+    {
+      m_font->DrawTextInternal(x + dx + 1, y + 1, shadowColors, text, alignment, textPixelWidth, scroll);
+      m_font->DrawTextInternal(x + dx + scrollInfo.m_textWidth + 1, y + 1, shadowColors, scrollInfo.suffix, alignment, suffixPixelWidth, scroll);
+    }
+  }
+  for (float dx = -offset; dx < maxWidth; dx += scrollInfo.m_totalWidth)
+  {
+    m_font->DrawTextInternal(x + dx, y, renderColors, text, alignment, textPixelWidth, scroll);
+    m_font->DrawTextInternal(x + dx + scrollInfo.m_textWidth, y, renderColors, scrollInfo.suffix, alignment, suffixPixelWidth, scroll);
   }
-  m_font->DrawTextInternal(x - offset, y, renderColors, renderText, alignment, maxWidth + m_font->GetLineHeight(2.0f), scroll);
 
   g_graphicsContext.RestoreClipRegion();
 }
diff --git a/xbmc/guilib/GUIFont.h b/xbmc/guilib/GUIFont.h
index c55db48..09cf9b3 100644
--- a/xbmc/guilib/GUIFont.h
+++ b/xbmc/guilib/GUIFont.h
@@ -64,7 +64,6 @@ class CScrollInfo
   void Reset()
   {
     waitTime = initialWait;
-    characterPos = 0;
     // pixelPos is where we start the current letter, so is measured
     // to the left of the text rendering's left edge.  Thus, a negative
     // value will mean the text starts to the right
@@ -72,25 +71,19 @@ class CScrollInfo
     // privates:
     m_averageFrameTime = 1000.f / abs(defaultSpeed);
     m_lastFrameTime = 0;
-  }
-  uint32_t GetCurrentChar(const vecText &text) const
-  {
-    assert(text.size());
-    if (characterPos < text.size())
-      return text[characterPos];
-    else if (characterPos < text.size() + suffix.size())
-      return suffix[characterPos - text.size()];
-    return text[0];
+    m_widthValid = false;
   }
   float GetPixelsPerFrame();
 
   float pixelPos;
   float pixelSpeed;
   unsigned int waitTime;
-  unsigned int characterPos;
   unsigned int initialWait;
   float initialPos;
-  CStdStringW suffix;
+  vecText suffix;
+  mutable float m_textWidth;
+  mutable float m_totalWidth;
+  mutable bool m_widthValid;
 
   static const int defaultSpeed = 60;
 private:
diff --git a/xbmc/guilib/GUIRSSControl.cpp b/xbmc/guilib/GUIRSSControl.cpp
index 8d985cf..a8e20fc 100644
--- a/xbmc/guilib/GUIRSSControl.cpp
+++ b/xbmc/guilib/GUIRSSControl.cpp
@@ -119,7 +119,9 @@ void CGUIRSSControl::Process(unsigned int currentTime, CDirtyRegionList &dirtyre
       dirty = true;
 
       if (CRssManager::Get().GetReader(GetID(), GetParentID(), this, m_pReader))
-        m_scrollInfo.characterPos = m_pReader->m_SavedScrollPos;
+      {
+        m_scrollInfo.pixelPos = m_pReader->m_savedScrollPixelPos;
+      }
       else
       {
         if (m_strRSSTags != "")
@@ -174,7 +176,7 @@ void CGUIRSSControl::Render()
     if (m_pReader)
     {
       m_pReader->CheckForUpdates();
-      m_pReader->m_SavedScrollPos = m_scrollInfo.characterPos;
+      m_pReader->m_savedScrollPixelPos = m_scrollInfo.pixelPos;
     }
   }
   CGUIControl::Render();
diff --git a/xbmc/utils/RssReader.cpp b/xbmc/utils/RssReader.cpp
index a22d364..013ddb8 100644
--- a/xbmc/utils/RssReader.cpp
+++ b/xbmc/utils/RssReader.cpp
@@ -54,7 +54,7 @@ CRssReader::CRssReader() : CThread("RSSReader")
   m_pObserver = NULL;
   m_spacesBetweenFeeds = 0;
   m_bIsRunning = false;
-  m_SavedScrollPos = 0;
+  m_savedScrollPixelPos = 0;
   m_rtlText = false;
   m_requestRefresh = false;
 }
diff --git a/xbmc/utils/RssReader.h b/xbmc/utils/RssReader.h
index 2c6f366..b74faf2 100644
--- a/xbmc/utils/RssReader.h
+++ b/xbmc/utils/RssReader.h
@@ -43,7 +43,7 @@ class CRssReader : public CThread
   void SetObserver(IRssObserver* observer);
   void CheckForUpdates();
   void requestRefresh();
-  unsigned int m_SavedScrollPos;
+  float m_savedScrollPixelPos;
 
 private:
   void Process();
-- 
1.9.3


From 49a538250c27fc99507e0a49a688e13827633c9d Mon Sep 17 00:00:00 2001
From: Ben Avison <bavison@riscosopen.org>
Date: Mon, 27 Jan 2014 23:21:10 +0000
Subject: [PATCH 008/102] Move the application of the translation offsets into
 the GLES code. Still all pure software at this stage. Main change is in the
 data types at the interface between CGUIFontTTFBase and CGUIFontTTFGL. The
 old way (array of vertices in m_vertex) are retained in addition, for the
 sake`of cases that need to use software clipping on GLES, as well as for DX
 and GL support where the new scheme is not (yet?) used.

---
 xbmc/guilib/GUIFontTTF.cpp   | 19 +++---------
 xbmc/guilib/GUIFontTTF.h     | 17 +++++++++++
 xbmc/guilib/GUIFontTTFGL.cpp | 72 ++++++++++++++++++++++++++++++++------------
 3 files changed, 73 insertions(+), 35 deletions(-)

diff --git a/xbmc/guilib/GUIFontTTF.cpp b/xbmc/guilib/GUIFontTTF.cpp
index 73f0e50..ad0a53b 100644
--- a/xbmc/guilib/GUIFontTTF.cpp
+++ b/xbmc/guilib/GUIFontTTF.cpp
@@ -215,6 +215,7 @@ void CGUIFontTTFBase::Clear()
     g_freeTypeLibrary.ReleaseStroker(m_stroker);
   m_stroker = NULL;
 
+  m_vertexTrans.clear();
   m_vertex.clear();
 }
 
@@ -310,6 +311,7 @@ void CGUIFontTTFBase::Begin()
 {
   if (m_nestedBeginCount == 0 && m_texture != NULL && FirstBegin())
   {
+    m_vertexTrans.clear();
     m_vertex.clear();
   }
   // Keep track of the nested begin/end calls.
@@ -457,23 +459,10 @@ void CGUIFontTTFBase::DrawTextInternal(float x, float y, const vecColors &colors
         cursorX += ch->advance;
     }
     if (hardwareClipping)
-      /* Append the new vertices (which we have just constructed in the cache)
-       * to the set collected since the first Begin() call */
-      m_vertex.insert(m_vertex.end(), vertices.begin(), vertices.end());
+      m_vertexTrans.push_back(CTranslatedVertices(0, 0, 0, &vertices));
   }
   else if (hardwareClipping)
-  {
-    /* Apply the translation offset to the vertices from the cache after
-     * appending them to the set collected since the first Begin() call */
-    m_vertex.insert(m_vertex.end(), vertices.begin(), vertices.end());
-    SVertex *v;
-    for (v = &*m_vertex.end() - vertices.size(); v != &*m_vertex.end(); v++)
-    {
-      v->x += dynamicPos.m_x;
-      v->y += dynamicPos.m_y;
-      v->z += dynamicPos.m_z;
-    }
-  }
+    m_vertexTrans.push_back(CTranslatedVertices(dynamicPos.m_x, dynamicPos.m_y, dynamicPos.m_z, &vertices));
   if (!hardwareClipping)
     /* Append the new vertices (from the cache or otherwise) to the set collected
      * since the first Begin() call */
diff --git a/xbmc/guilib/GUIFontTTF.h b/xbmc/guilib/GUIFontTTF.h
index 78445ab..c71f90d 100644
--- a/xbmc/guilib/GUIFontTTF.h
+++ b/xbmc/guilib/GUIFontTTF.h
@@ -61,6 +61,14 @@ struct SVertex
   unsigned char r, g, b, a;
 #endif
   float u, v;
+  struct SVertex Offset(float translate[3]) const
+  {
+    SVertex out = *this;
+    out.x += translate[0];
+    out.y += translate[1];
+    out.z += translate[2];
+    return out;
+  }
 };
 
 
@@ -160,6 +168,15 @@ class CGUIFontTTFBase
   bool m_bTextureLoaded;
   unsigned int m_nTexture;
 
+  struct CTranslatedVertices
+  {
+    float translateX;
+    float translateY;
+    float translateZ;
+    const std::vector<SVertex> *vertexBuffer;
+    CTranslatedVertices(float translateX, float translateY, float translateZ, const std::vector<SVertex> *vertexBuffer) : translateX(translateX), translateY(translateY), translateZ(translateZ), vertexBuffer(vertexBuffer) {}
+  };
+  std::vector<CTranslatedVertices> m_vertexTrans;
   std::vector<SVertex> m_vertex;
 
   float    m_textureScaleX;
diff --git a/xbmc/guilib/GUIFontTTFGL.cpp b/xbmc/guilib/GUIFontTTFGL.cpp
index cb56987..f6aa081 100644
--- a/xbmc/guilib/GUIFontTTFGL.cpp
+++ b/xbmc/guilib/GUIFontTTFGL.cpp
@@ -146,34 +146,65 @@ void CGUIFontTTFGL::LastEnd()
   GLint colLoc  = g_Windowing.GUIShaderGetCol();
   GLint tex0Loc = g_Windowing.GUIShaderGetCoord0();
 
-  // stack object until VBOs will be used
-  std::vector<SVertex> vecVertices( 6 * (m_vertex.size() / 4) );
-  SVertex *vertices = &vecVertices[0];
+  // Enable the attributes used by this shader
+  glEnableVertexAttribArray(posLoc);
+  glEnableVertexAttribArray(colLoc);
+  glEnableVertexAttribArray(tex0Loc);
 
-  for (size_t i=0; i<m_vertex.size(); i+=4)
+  if (m_vertex.size() > 0)
   {
-    *vertices++ = m_vertex[i];
-    *vertices++ = m_vertex[i+1];
-    *vertices++ = m_vertex[i+2];
+    // Deal with vertices that had to use software clipping
+    std::vector<SVertex> vecVertices( 6 * (m_vertex.size() / 4) );
+    SVertex *vertices = &vecVertices[0];
 
-    *vertices++ = m_vertex[i+1];
-    *vertices++ = m_vertex[i+3];
-    *vertices++ = m_vertex[i+2];
-  }
+    for (size_t i=0; i<m_vertex.size(); i+=4)
+    {
+      *vertices++ = m_vertex[i];
+      *vertices++ = m_vertex[i+1];
+      *vertices++ = m_vertex[i+2];
 
-  vertices = &vecVertices[0];
+      *vertices++ = m_vertex[i+1];
+      *vertices++ = m_vertex[i+3];
+      *vertices++ = m_vertex[i+2];
+    }
 
-  glVertexAttribPointer(posLoc,  3, GL_FLOAT,         GL_FALSE, sizeof(SVertex), (char*)vertices + offsetof(SVertex, x));
-  // Normalize color values. Does not affect Performance at all.
-  glVertexAttribPointer(colLoc,  4, GL_UNSIGNED_BYTE, GL_TRUE, sizeof(SVertex), (char*)vertices + offsetof(SVertex, r));
-  glVertexAttribPointer(tex0Loc, 2, GL_FLOAT,         GL_FALSE, sizeof(SVertex), (char*)vertices + offsetof(SVertex, u));
+    vertices = &vecVertices[0];
 
-  glEnableVertexAttribArray(posLoc);
-  glEnableVertexAttribArray(colLoc);
-  glEnableVertexAttribArray(tex0Loc);
+    glVertexAttribPointer(posLoc,  3, GL_FLOAT,         GL_FALSE, sizeof(SVertex), (char*)vertices + offsetof(SVertex, x));
+    // Normalize color values. Does not affect Performance at all.
+    glVertexAttribPointer(colLoc,  4, GL_UNSIGNED_BYTE, GL_TRUE, sizeof(SVertex), (char*)vertices + offsetof(SVertex, r));
+    glVertexAttribPointer(tex0Loc, 2, GL_FLOAT,         GL_FALSE, sizeof(SVertex), (char*)vertices + offsetof(SVertex, u));
+
+    glDrawArrays(GL_TRIANGLES, 0, vecVertices.size());
+  }
+  if (m_vertexTrans.size() > 0)
+  {
+    // Deal with the vertices that can be hardware clipped and therefore translated
+    std::vector<SVertex> vecVertices;
+    for (size_t i = 0; i < m_vertexTrans.size(); i++)
+    {
+      float translate[3] = { m_vertexTrans[i].translateX, m_vertexTrans[i].translateY, m_vertexTrans[i].translateZ };
+      for (size_t j = 0; j < m_vertexTrans[i].vertexBuffer->size(); j += 4)
+      {
+        vecVertices.push_back((*m_vertexTrans[i].vertexBuffer)[j].Offset(translate));
+        vecVertices.push_back((*m_vertexTrans[i].vertexBuffer)[j+1].Offset(translate));
+        vecVertices.push_back((*m_vertexTrans[i].vertexBuffer)[j+2].Offset(translate));
+        vecVertices.push_back((*m_vertexTrans[i].vertexBuffer)[j+1].Offset(translate));
+        vecVertices.push_back((*m_vertexTrans[i].vertexBuffer)[j+3].Offset(translate));
+        vecVertices.push_back((*m_vertexTrans[i].vertexBuffer)[j+2].Offset(translate));
+      }
+    }
+    SVertex *vertices = &vecVertices[0];
 
-  glDrawArrays(GL_TRIANGLES, 0, vecVertices.size());
+    glVertexAttribPointer(posLoc,  3, GL_FLOAT,         GL_FALSE, sizeof(SVertex), (char*)vertices + offsetof(SVertex, x));
+    // Normalize color values. Does not affect Performance at all.
+    glVertexAttribPointer(colLoc,  4, GL_UNSIGNED_BYTE, GL_TRUE, sizeof(SVertex), (char*)vertices + offsetof(SVertex, r));
+    glVertexAttribPointer(tex0Loc, 2, GL_FLOAT,         GL_FALSE, sizeof(SVertex), (char*)vertices + offsetof(SVertex, u));
+
+    glDrawArrays(GL_TRIANGLES, 0, vecVertices.size());
+  }
 
+  // Disable the attributes used by this shader
   glDisableVertexAttribArray(posLoc);
   glDisableVertexAttribArray(colLoc);
   glDisableVertexAttribArray(tex0Loc);
@@ -201,6 +232,7 @@ CBaseTexture* CGUIFontTTFGL::ReallocTexture(unsigned int& newHeight)
   if (m_textureHeight < newHeight)
     CLog::Log(LOGWARNING, "%s: allocated new texture with height of %d, requested %d", __FUNCTION__, m_textureHeight, newHeight);
   m_staticCache.Flush();
+  m_dynamicCache.Flush();
 
   memset(newTexture->GetPixels(), 0, m_textureHeight * newTexture->GetPitch());
   if (m_texture)
-- 
1.9.3


From a68d88009e7ae9b5484285332bc23aa22c73d17d Mon Sep 17 00:00:00 2001
From: Ben Avison <bavison@riscosopen.org>
Date: Wed, 15 Jan 2014 15:28:06 +0000
Subject: [PATCH 009/102] Rather than applying the translation offsets to the
 vertices, now applies them to the model view matrix from the top of the
 matrix stack and pushes it over to OpenGL. The vertices themselves are still
 all held client-side.

---
 xbmc/guilib/GUIFontTTF.h                 |  8 -------
 xbmc/guilib/GUIFontTTFGL.cpp             | 40 +++++++++++++++++++++-----------
 xbmc/guilib/GUIShader.h                  |  1 +
 xbmc/rendering/gles/RenderSystemGLES.cpp |  8 +++++++
 xbmc/rendering/gles/RenderSystemGLES.h   |  1 +
 5 files changed, 36 insertions(+), 22 deletions(-)

diff --git a/xbmc/guilib/GUIFontTTF.h b/xbmc/guilib/GUIFontTTF.h
index c71f90d..fde2085 100644
--- a/xbmc/guilib/GUIFontTTF.h
+++ b/xbmc/guilib/GUIFontTTF.h
@@ -61,14 +61,6 @@ struct SVertex
   unsigned char r, g, b, a;
 #endif
   float u, v;
-  struct SVertex Offset(float translate[3]) const
-  {
-    SVertex out = *this;
-    out.x += translate[0];
-    out.y += translate[1];
-    out.z += translate[2];
-    return out;
-  }
 };
 
 
diff --git a/xbmc/guilib/GUIFontTTFGL.cpp b/xbmc/guilib/GUIFontTTFGL.cpp
index f6aa081..fbffaa0 100644
--- a/xbmc/guilib/GUIFontTTFGL.cpp
+++ b/xbmc/guilib/GUIFontTTFGL.cpp
@@ -29,6 +29,7 @@
 #include "utils/log.h"
 #include "utils/GLUtils.h"
 #include "windowing/WindowingFactory.h"
+#include "guilib/MatrixGLES.h"
 
 // stuff for freetype
 #include <ft2build.h>
@@ -145,6 +146,7 @@ void CGUIFontTTFGL::LastEnd()
   GLint posLoc  = g_Windowing.GUIShaderGetPos();
   GLint colLoc  = g_Windowing.GUIShaderGetCol();
   GLint tex0Loc = g_Windowing.GUIShaderGetCoord0();
+  GLint modelLoc = g_Windowing.GUIShaderGetModel();
 
   // Enable the attributes used by this shader
   glEnableVertexAttribArray(posLoc);
@@ -183,25 +185,35 @@ void CGUIFontTTFGL::LastEnd()
     std::vector<SVertex> vecVertices;
     for (size_t i = 0; i < m_vertexTrans.size(); i++)
     {
-      float translate[3] = { m_vertexTrans[i].translateX, m_vertexTrans[i].translateY, m_vertexTrans[i].translateZ };
+      // Apply the translation to the currently active (top-of-stack) model view matrix
+      g_matrices.MatrixMode(MM_MODELVIEW);
+      g_matrices.PushMatrix();
+      g_matrices.Translatef(m_vertexTrans[i].translateX, m_vertexTrans[i].translateY, m_vertexTrans[i].translateZ);
+      glUniformMatrix4fv(modelLoc, 1, GL_FALSE, g_matrices.GetMatrix(MM_MODELVIEW));
+
+      vecVertices.clear();
       for (size_t j = 0; j < m_vertexTrans[i].vertexBuffer->size(); j += 4)
       {
-        vecVertices.push_back((*m_vertexTrans[i].vertexBuffer)[j].Offset(translate));
-        vecVertices.push_back((*m_vertexTrans[i].vertexBuffer)[j+1].Offset(translate));
-        vecVertices.push_back((*m_vertexTrans[i].vertexBuffer)[j+2].Offset(translate));
-        vecVertices.push_back((*m_vertexTrans[i].vertexBuffer)[j+1].Offset(translate));
-        vecVertices.push_back((*m_vertexTrans[i].vertexBuffer)[j+3].Offset(translate));
-        vecVertices.push_back((*m_vertexTrans[i].vertexBuffer)[j+2].Offset(translate));
+        vecVertices.push_back((*m_vertexTrans[i].vertexBuffer)[j]);
+        vecVertices.push_back((*m_vertexTrans[i].vertexBuffer)[j+1]);
+        vecVertices.push_back((*m_vertexTrans[i].vertexBuffer)[j+2]);
+        vecVertices.push_back((*m_vertexTrans[i].vertexBuffer)[j+1]);
+        vecVertices.push_back((*m_vertexTrans[i].vertexBuffer)[j+3]);
+        vecVertices.push_back((*m_vertexTrans[i].vertexBuffer)[j+2]);
       }
-    }
-    SVertex *vertices = &vecVertices[0];
+      SVertex *vertices = &vecVertices[0];
 
-    glVertexAttribPointer(posLoc,  3, GL_FLOAT,         GL_FALSE, sizeof(SVertex), (char*)vertices + offsetof(SVertex, x));
-    // Normalize color values. Does not affect Performance at all.
-    glVertexAttribPointer(colLoc,  4, GL_UNSIGNED_BYTE, GL_TRUE, sizeof(SVertex), (char*)vertices + offsetof(SVertex, r));
-    glVertexAttribPointer(tex0Loc, 2, GL_FLOAT,         GL_FALSE, sizeof(SVertex), (char*)vertices + offsetof(SVertex, u));
+      glVertexAttribPointer(posLoc,  3, GL_FLOAT,         GL_FALSE, sizeof(SVertex), (char*)vertices + offsetof(SVertex, x));
+      // Normalize color values. Does not affect Performance at all.
+      glVertexAttribPointer(colLoc,  4, GL_UNSIGNED_BYTE, GL_TRUE, sizeof(SVertex), (char*)vertices + offsetof(SVertex, r));
+      glVertexAttribPointer(tex0Loc, 2, GL_FLOAT,         GL_FALSE, sizeof(SVertex), (char*)vertices + offsetof(SVertex, u));
 
-    glDrawArrays(GL_TRIANGLES, 0, vecVertices.size());
+      glDrawArrays(GL_TRIANGLES, 0, vecVertices.size());
+
+      g_matrices.PopMatrix();
+    }
+    // Restore the original model view matrix
+    glUniformMatrix4fv(modelLoc, 1, GL_FALSE, g_matrices.GetMatrix(MM_MODELVIEW));
   }
 
   // Disable the attributes used by this shader
diff --git a/xbmc/guilib/GUIShader.h b/xbmc/guilib/GUIShader.h
index 86ce4cc..ba01956 100644
--- a/xbmc/guilib/GUIShader.h
+++ b/xbmc/guilib/GUIShader.h
@@ -41,6 +41,7 @@ class CGUIShader : public CGLSLShaderProgram
   GLint GetCord1Loc() { return m_hCord1; }
   GLint GetUniColLoc() { return m_hUniCol; }
   GLint GetCoord0MatrixLoc() { return m_hCoord0Matrix; }
+  GLint GetModelLoc() { return m_hModel; }
   bool HardwareClipIsPossible() { return m_clipPossible; }
   GLfloat GetClipXFactor() { return m_clipXFactor; }
   GLfloat GetClipXOffset() { return m_clipXOffset; }
diff --git a/xbmc/rendering/gles/RenderSystemGLES.cpp b/xbmc/rendering/gles/RenderSystemGLES.cpp
index deb3afc..0904d1f 100644
--- a/xbmc/rendering/gles/RenderSystemGLES.cpp
+++ b/xbmc/rendering/gles/RenderSystemGLES.cpp
@@ -691,4 +691,12 @@ bool CRenderSystemGLES::SupportsStereo(RENDER_STEREO_MODE mode)
   }
 }
 
+GLint CRenderSystemGLES::GUIShaderGetModel()
+{
+  if (m_pGUIshader[m_method])
+    return m_pGUIshader[m_method]->GetModelLoc();
+
+  return -1;
+}
+
 #endif
diff --git a/xbmc/rendering/gles/RenderSystemGLES.h b/xbmc/rendering/gles/RenderSystemGLES.h
index 81ee49e..d2f9cd1 100644
--- a/xbmc/rendering/gles/RenderSystemGLES.h
+++ b/xbmc/rendering/gles/RenderSystemGLES.h
@@ -91,6 +91,7 @@ class CRenderSystemGLES : public CRenderSystemBase
   GLint GUIShaderGetCoord1();
   GLint GUIShaderGetUniCol();
   GLint GUIShaderGetCoord0Matrix();
+  GLint GUIShaderGetModel();
 
 protected:
   virtual void SetVSyncImpl(bool enable) = 0;
-- 
1.9.3


From 6b25456e32488065307ee21d19e53fa9f74bdf20 Mon Sep 17 00:00:00 2001
From: Ben Avison <bavison@riscosopen.org>
Date: Wed, 29 Jan 2014 13:21:19 +0000
Subject: [PATCH 010/102] Enable hardware clipping.

---
 xbmc/guilib/GUIFontTTF.cpp   | 4 ++--
 xbmc/guilib/GUIFontTTF.h     | 5 ++++-
 xbmc/guilib/GUIFontTTFGL.cpp | 6 ++++++
 3 files changed, 12 insertions(+), 3 deletions(-)

diff --git a/xbmc/guilib/GUIFontTTF.cpp b/xbmc/guilib/GUIFontTTF.cpp
index ad0a53b..4dc4c8e 100644
--- a/xbmc/guilib/GUIFontTTF.cpp
+++ b/xbmc/guilib/GUIFontTTF.cpp
@@ -459,10 +459,10 @@ void CGUIFontTTFBase::DrawTextInternal(float x, float y, const vecColors &colors
         cursorX += ch->advance;
     }
     if (hardwareClipping)
-      m_vertexTrans.push_back(CTranslatedVertices(0, 0, 0, &vertices));
+      m_vertexTrans.push_back(CTranslatedVertices(0, 0, 0, &vertices, g_graphicsContext.GetClipRegion()));
   }
   else if (hardwareClipping)
-    m_vertexTrans.push_back(CTranslatedVertices(dynamicPos.m_x, dynamicPos.m_y, dynamicPos.m_z, &vertices));
+    m_vertexTrans.push_back(CTranslatedVertices(dynamicPos.m_x, dynamicPos.m_y, dynamicPos.m_z, &vertices, g_graphicsContext.GetClipRegion()));
   if (!hardwareClipping)
     /* Append the new vertices (from the cache or otherwise) to the set collected
      * since the first Begin() call */
diff --git a/xbmc/guilib/GUIFontTTF.h b/xbmc/guilib/GUIFontTTF.h
index fde2085..5e7c31f 100644
--- a/xbmc/guilib/GUIFontTTF.h
+++ b/xbmc/guilib/GUIFontTTF.h
@@ -27,6 +27,8 @@
  *
  */
 
+#include "Geometry.h"
+
 // forward definition
 class CBaseTexture;
 
@@ -166,7 +168,8 @@ class CGUIFontTTFBase
     float translateY;
     float translateZ;
     const std::vector<SVertex> *vertexBuffer;
-    CTranslatedVertices(float translateX, float translateY, float translateZ, const std::vector<SVertex> *vertexBuffer) : translateX(translateX), translateY(translateY), translateZ(translateZ), vertexBuffer(vertexBuffer) {}
+    CRect clip;
+    CTranslatedVertices(float translateX, float translateY, float translateZ, const std::vector<SVertex> *vertexBuffer, const CRect &clip) : translateX(translateX), translateY(translateY), translateZ(translateZ), vertexBuffer(vertexBuffer), clip(clip) {}
   };
   std::vector<CTranslatedVertices> m_vertexTrans;
   std::vector<SVertex> m_vertex;
diff --git a/xbmc/guilib/GUIFontTTFGL.cpp b/xbmc/guilib/GUIFontTTFGL.cpp
index fbffaa0..b7618e1 100644
--- a/xbmc/guilib/GUIFontTTFGL.cpp
+++ b/xbmc/guilib/GUIFontTTFGL.cpp
@@ -185,6 +185,10 @@ void CGUIFontTTFGL::LastEnd()
     std::vector<SVertex> vecVertices;
     for (size_t i = 0; i < m_vertexTrans.size(); i++)
     {
+      // Apply the clip rectangle
+      CRect clip = g_Windowing.ClipRectToScissorRect(m_vertexTrans[i].clip);
+      g_graphicsContext.SetScissors(clip);
+
       // Apply the translation to the currently active (top-of-stack) model view matrix
       g_matrices.MatrixMode(MM_MODELVIEW);
       g_matrices.PushMatrix();
@@ -212,6 +216,8 @@ void CGUIFontTTFGL::LastEnd()
 
       g_matrices.PopMatrix();
     }
+    // Restore the original scissor rectangle
+    g_graphicsContext.ResetScissors();
     // Restore the original model view matrix
     glUniformMatrix4fv(modelLoc, 1, GL_FALSE, g_matrices.GetMatrix(MM_MODELVIEW));
   }
-- 
1.9.3


From 490473747496cc5919c6118e0e57906bbf7da652 Mon Sep 17 00:00:00 2001
From: Ben Avison <bavison@riscosopen.org>
Date: Wed, 15 Jan 2014 15:32:51 +0000
Subject: [PATCH 011/102] Move the vertex data across to a vertex buffer object
 just prior to drawing.

---
 xbmc/guilib/GUIFontTTFGL.cpp | 24 +++++++++++++++++++-----
 1 file changed, 19 insertions(+), 5 deletions(-)

diff --git a/xbmc/guilib/GUIFontTTFGL.cpp b/xbmc/guilib/GUIFontTTFGL.cpp
index b7618e1..0df3749 100644
--- a/xbmc/guilib/GUIFontTTFGL.cpp
+++ b/xbmc/guilib/GUIFontTTFGL.cpp
@@ -207,12 +207,24 @@ void CGUIFontTTFGL::LastEnd()
       }
       SVertex *vertices = &vecVertices[0];
 
-      glVertexAttribPointer(posLoc,  3, GL_FLOAT,         GL_FALSE, sizeof(SVertex), (char*)vertices + offsetof(SVertex, x));
-      // Normalize color values. Does not affect Performance at all.
-      glVertexAttribPointer(colLoc,  4, GL_UNSIGNED_BYTE, GL_TRUE, sizeof(SVertex), (char*)vertices + offsetof(SVertex, r));
-      glVertexAttribPointer(tex0Loc, 2, GL_FLOAT,         GL_FALSE, sizeof(SVertex), (char*)vertices + offsetof(SVertex, u));
-
+      // Generate a unique buffer object name and put it in vertexBuffer
+      GLuint vertexBuffer;
+      glGenBuffers(1, &vertexBuffer);
+      // Bind the buffer to the OpenGL context's GL_ARRAY_BUFFER binding point
+      glBindBuffer(GL_ARRAY_BUFFER, vertexBuffer);
+      // Create a data store for the buffer object bound to the GL_ARRAY_BUFFER
+      // binding point (i.e. our buffer object) and initialise it from the
+      // specified client-side pointer
+      glBufferData(GL_ARRAY_BUFFER, vecVertices.size() * sizeof *vertices, vertices, GL_STATIC_DRAW);
+      // Set up the offsets of the various vertex attributes within the buffer
+      // object bound to GL_ARRAY_BUFFER
+      glVertexAttribPointer(posLoc,  3, GL_FLOAT,         GL_FALSE, sizeof(SVertex), (GLvoid *) offsetof(SVertex, x));
+      glVertexAttribPointer(colLoc,  4, GL_UNSIGNED_BYTE, GL_TRUE,  sizeof(SVertex), (GLvoid *) offsetof(SVertex, r));
+      glVertexAttribPointer(tex0Loc, 2, GL_FLOAT,         GL_FALSE, sizeof(SVertex), (GLvoid *) offsetof(SVertex, u));
+      // Do the actual drawing operation, using the full set of vertices in the buffer
       glDrawArrays(GL_TRIANGLES, 0, vecVertices.size());
+      // Release the buffer name for reuse
+      glDeleteBuffers(1, &vertexBuffer);
 
       g_matrices.PopMatrix();
     }
@@ -220,6 +232,8 @@ void CGUIFontTTFGL::LastEnd()
     g_graphicsContext.ResetScissors();
     // Restore the original model view matrix
     glUniformMatrix4fv(modelLoc, 1, GL_FALSE, g_matrices.GetMatrix(MM_MODELVIEW));
+    // Unbind GL_ARRAY_BUFFER
+    glBindBuffer(GL_ARRAY_BUFFER, 0);
   }
 
   // Disable the attributes used by this shader
-- 
1.9.3


From b65cab61e361360be10816d2f872204e38cc46f2 Mon Sep 17 00:00:00 2001
From: Ben Avison <bavison@riscosopen.org>
Date: Wed, 15 Jan 2014 16:04:04 +0000
Subject: [PATCH 012/102] Move vertex data into an OpenGL VBO when the font
 cache entry is populated. The font cache now stores the "name" (handle) of
 the VBO, rather than a vector of vertices.

---
 xbmc/guilib/GUIFontCache.cpp |  6 ++++
 xbmc/guilib/GUIFontCache.h   | 30 +++++++++++++++++-
 xbmc/guilib/GUIFontTTF.cpp   | 15 +++++++--
 xbmc/guilib/GUIFontTTF.h     |  7 +++--
 xbmc/guilib/GUIFontTTFGL.cpp | 74 ++++++++++++++++++++++++++++++--------------
 xbmc/guilib/GUIFontTTFGL.h   |  5 +++
 6 files changed, 107 insertions(+), 30 deletions(-)

diff --git a/xbmc/guilib/GUIFontCache.cpp b/xbmc/guilib/GUIFontCache.cpp
index b66c00b..895fa72 100644
--- a/xbmc/guilib/GUIFontCache.cpp
+++ b/xbmc/guilib/GUIFontCache.cpp
@@ -111,3 +111,9 @@ template void CGUIFontCacheEntry<CGUIFontCacheDynamicPosition, CGUIFontCacheDyna
 template CGUIFontCacheEntry<CGUIFontCacheDynamicPosition, CGUIFontCacheDynamicValue>::~CGUIFontCacheEntry();
 template CGUIFontCacheDynamicValue &CGUIFontCache<CGUIFontCacheDynamicPosition, CGUIFontCacheDynamicValue>::Lookup(CGUIFontCacheDynamicPosition &, const vecColors &, const vecText &, uint32_t, float, bool, unsigned int, bool &);
 template void CGUIFontCache<CGUIFontCacheDynamicPosition, CGUIFontCacheDynamicValue>::Flush();
+
+void CVertexBuffer::clear()
+{
+  if (m_font != NULL)
+    m_font->DestroyVertexBuffer(*this);
+}
diff --git a/xbmc/guilib/GUIFontCache.h b/xbmc/guilib/GUIFontCache.h
index d913dee..ff766bf 100644
--- a/xbmc/guilib/GUIFontCache.h
+++ b/xbmc/guilib/GUIFontCache.h
@@ -234,7 +234,35 @@ struct CGUIFontCacheDynamicPosition
   }
 };
 
-typedef std::vector<SVertex> CGUIFontCacheDynamicValue;
+struct CVertexBuffer
+{
+  void *bufferHandle;
+  size_t size;
+  CVertexBuffer() : bufferHandle(NULL), size(0), m_font(NULL) {}
+  CVertexBuffer(void *bufferHandle, size_t size, const CGUIFontTTFBase *font) : bufferHandle(bufferHandle), size(size), m_font(font) {}
+  CVertexBuffer(const CVertexBuffer &other) : bufferHandle(other.bufferHandle), size(other.size), m_font(other.m_font)
+  {
+    /* In practice, the copy constructor is only called before a vertex buffer
+     * has been attached. If this should ever change, we'll need another support
+     * function in GUIFontTTFGL/DX to duplicate a buffer, given its handle. */
+    assert(other.bufferHandle == 0);
+  }
+  CVertexBuffer &operator=(CVertexBuffer &other)
+  {
+    /* This is used with move-assignment semantics for initialising the object in the font cache */
+    assert(bufferHandle == 0);
+    bufferHandle = other.bufferHandle;
+    other.bufferHandle = 0;
+    size = other.size;
+    m_font = other.m_font;
+    return *this;
+  }
+  void clear();
+private:
+  const CGUIFontTTFBase *m_font;
+};
+
+typedef CVertexBuffer CGUIFontCacheDynamicValue;
 
 inline bool Match(const CGUIFontCacheDynamicPosition &a, const TransformMatrix &a_m,
                   const CGUIFontCacheDynamicPosition &b, const TransformMatrix &b_m,
diff --git a/xbmc/guilib/GUIFontTTF.cpp b/xbmc/guilib/GUIFontTTF.cpp
index 4dc4c8e..8b25306 100644
--- a/xbmc/guilib/GUIFontTTF.cpp
+++ b/xbmc/guilib/GUIFontTTF.cpp
@@ -343,13 +343,18 @@ void CGUIFontTTFBase::DrawTextInternal(float x, float y, const vecColors &colors
                                               g_graphicsContext.ScaleFinalYCoord(x, y),
                                               g_graphicsContext.ScaleFinalZCoord(x, y));
   }
-  std::vector<SVertex> &vertices = hardwareClipping ?
+  CVertexBuffer unusedVertexBuffer;
+  CVertexBuffer &vertexBuffer = hardwareClipping ?
       m_dynamicCache.Lookup(dynamicPos,
                             colors, text,
                             alignment, maxPixelWidth,
                             scrolling,
                             XbmcThreads::SystemClockMillis(),
                             dirtyCache) :
+      unusedVertexBuffer;
+  std::vector<SVertex> tempVertices;
+  std::vector<SVertex> &vertices = hardwareClipping ?
+      tempVertices :
       m_staticCache.Lookup(staticPos,
                            colors, text,
                            alignment, maxPixelWidth,
@@ -459,10 +464,14 @@ void CGUIFontTTFBase::DrawTextInternal(float x, float y, const vecColors &colors
         cursorX += ch->advance;
     }
     if (hardwareClipping)
-      m_vertexTrans.push_back(CTranslatedVertices(0, 0, 0, &vertices, g_graphicsContext.GetClipRegion()));
+    {
+      CVertexBuffer newVertexBuffer = CreateVertexBuffer(tempVertices);
+      vertexBuffer = newVertexBuffer;
+      m_vertexTrans.push_back(CTranslatedVertices(0, 0, 0, &vertexBuffer, g_graphicsContext.GetClipRegion()));
+    }
   }
   else if (hardwareClipping)
-    m_vertexTrans.push_back(CTranslatedVertices(dynamicPos.m_x, dynamicPos.m_y, dynamicPos.m_z, &vertices, g_graphicsContext.GetClipRegion()));
+    m_vertexTrans.push_back(CTranslatedVertices(dynamicPos.m_x, dynamicPos.m_y, dynamicPos.m_z, &vertexBuffer, g_graphicsContext.GetClipRegion()));
   if (!hardwareClipping)
     /* Append the new vertices (from the cache or otherwise) to the set collected
      * since the first Begin() call */
diff --git a/xbmc/guilib/GUIFontTTF.h b/xbmc/guilib/GUIFontTTF.h
index 5e7c31f..b1cd525 100644
--- a/xbmc/guilib/GUIFontTTF.h
+++ b/xbmc/guilib/GUIFontTTF.h
@@ -84,6 +84,9 @@ class CGUIFontTTFBase
 
   void Begin();
   void End();
+  /* The next two should only be called if we've declared we can do hardware clipping */
+  virtual CVertexBuffer CreateVertexBuffer(const std::vector<SVertex> &vertices) const { assert(false); return CVertexBuffer(); }
+  virtual void DestroyVertexBuffer(CVertexBuffer &bufferHandle) const {}
 
   const CStdString& GetFileName() const { return m_strFileName; };
 
@@ -167,9 +170,9 @@ class CGUIFontTTFBase
     float translateX;
     float translateY;
     float translateZ;
-    const std::vector<SVertex> *vertexBuffer;
+    const CVertexBuffer *vertexBuffer;
     CRect clip;
-    CTranslatedVertices(float translateX, float translateY, float translateZ, const std::vector<SVertex> *vertexBuffer, const CRect &clip) : translateX(translateX), translateY(translateY), translateZ(translateZ), vertexBuffer(vertexBuffer), clip(clip) {}
+    CTranslatedVertices(float translateX, float translateY, float translateZ, const CVertexBuffer *vertexBuffer, const CRect &clip) : translateX(translateX), translateY(translateY), translateZ(translateZ), vertexBuffer(vertexBuffer), clip(clip) {}
   };
   std::vector<CTranslatedVertices> m_vertexTrans;
   std::vector<SVertex> m_vertex;
diff --git a/xbmc/guilib/GUIFontTTFGL.cpp b/xbmc/guilib/GUIFontTTFGL.cpp
index 0df3749..1cd684b7 100644
--- a/xbmc/guilib/GUIFontTTFGL.cpp
+++ b/xbmc/guilib/GUIFontTTFGL.cpp
@@ -49,6 +49,10 @@ CGUIFontTTFGL::CGUIFontTTFGL(const CStdString& strFileName)
 
 CGUIFontTTFGL::~CGUIFontTTFGL(void)
 {
+  // It's important that all the CGUIFontCacheEntry objects are
+  // destructed before the CGUIFontTTFGL goes out of scope, because
+  // our virtual methods won't be accessible after this point
+  m_dynamicCache.Flush();
 }
 
 bool CGUIFontTTFGL::FirstBegin()
@@ -182,7 +186,6 @@ void CGUIFontTTFGL::LastEnd()
   if (m_vertexTrans.size() > 0)
   {
     // Deal with the vertices that can be hardware clipped and therefore translated
-    std::vector<SVertex> vecVertices;
     for (size_t i = 0; i < m_vertexTrans.size(); i++)
     {
       // Apply the clip rectangle
@@ -195,36 +198,17 @@ void CGUIFontTTFGL::LastEnd()
       g_matrices.Translatef(m_vertexTrans[i].translateX, m_vertexTrans[i].translateY, m_vertexTrans[i].translateZ);
       glUniformMatrix4fv(modelLoc, 1, GL_FALSE, g_matrices.GetMatrix(MM_MODELVIEW));
 
-      vecVertices.clear();
-      for (size_t j = 0; j < m_vertexTrans[i].vertexBuffer->size(); j += 4)
-      {
-        vecVertices.push_back((*m_vertexTrans[i].vertexBuffer)[j]);
-        vecVertices.push_back((*m_vertexTrans[i].vertexBuffer)[j+1]);
-        vecVertices.push_back((*m_vertexTrans[i].vertexBuffer)[j+2]);
-        vecVertices.push_back((*m_vertexTrans[i].vertexBuffer)[j+1]);
-        vecVertices.push_back((*m_vertexTrans[i].vertexBuffer)[j+3]);
-        vecVertices.push_back((*m_vertexTrans[i].vertexBuffer)[j+2]);
-      }
-      SVertex *vertices = &vecVertices[0];
-
-      // Generate a unique buffer object name and put it in vertexBuffer
-      GLuint vertexBuffer;
-      glGenBuffers(1, &vertexBuffer);
       // Bind the buffer to the OpenGL context's GL_ARRAY_BUFFER binding point
-      glBindBuffer(GL_ARRAY_BUFFER, vertexBuffer);
-      // Create a data store for the buffer object bound to the GL_ARRAY_BUFFER
-      // binding point (i.e. our buffer object) and initialise it from the
-      // specified client-side pointer
-      glBufferData(GL_ARRAY_BUFFER, vecVertices.size() * sizeof *vertices, vertices, GL_STATIC_DRAW);
+      glBindBuffer(GL_ARRAY_BUFFER, (GLuint) m_vertexTrans[i].vertexBuffer->bufferHandle);
+
       // Set up the offsets of the various vertex attributes within the buffer
       // object bound to GL_ARRAY_BUFFER
       glVertexAttribPointer(posLoc,  3, GL_FLOAT,         GL_FALSE, sizeof(SVertex), (GLvoid *) offsetof(SVertex, x));
       glVertexAttribPointer(colLoc,  4, GL_UNSIGNED_BYTE, GL_TRUE,  sizeof(SVertex), (GLvoid *) offsetof(SVertex, r));
       glVertexAttribPointer(tex0Loc, 2, GL_FLOAT,         GL_FALSE, sizeof(SVertex), (GLvoid *) offsetof(SVertex, u));
+
       // Do the actual drawing operation, using the full set of vertices in the buffer
-      glDrawArrays(GL_TRIANGLES, 0, vecVertices.size());
-      // Release the buffer name for reuse
-      glDeleteBuffers(1, &vertexBuffer);
+      glDrawArrays(GL_TRIANGLES, 0, 6 * m_vertexTrans[i].vertexBuffer->size);
 
       g_matrices.PopMatrix();
     }
@@ -245,6 +229,48 @@ void CGUIFontTTFGL::LastEnd()
 #endif
 }
 
+#if HAS_GLES
+CVertexBuffer CGUIFontTTFGL::CreateVertexBuffer(const std::vector<SVertex> &vertices) const
+{
+  // Rearrange the vertices to describe triangles
+  std::vector<SVertex> triangleVertices;
+  triangleVertices.reserve(vertices.size() * 6 / 4);
+  for (size_t i = 0; i < vertices.size(); i += 4)
+  {
+    triangleVertices.push_back(vertices[i]);
+    triangleVertices.push_back(vertices[i+1]);
+    triangleVertices.push_back(vertices[i+2]);
+    triangleVertices.push_back(vertices[i+1]);
+    triangleVertices.push_back(vertices[i+3]);
+    triangleVertices.push_back(vertices[i+2]);
+  }
+
+  // Generate a unique buffer object name and put it in bufferHandle
+  GLuint bufferHandle;
+  glGenBuffers(1, &bufferHandle);
+  // Bind the buffer to the OpenGL context's GL_ARRAY_BUFFER binding point
+  glBindBuffer(GL_ARRAY_BUFFER, bufferHandle);
+  // Create a data store for the buffer object bound to the GL_ARRAY_BUFFER
+  // binding point (i.e. our buffer object) and initialise it from the
+  // specified client-side pointer
+  glBufferData(GL_ARRAY_BUFFER, triangleVertices.size() * sizeof (SVertex), &triangleVertices[0], GL_STATIC_DRAW);
+  // Unbind GL_ARRAY_BUFFER
+  glBindBuffer(GL_ARRAY_BUFFER, 0);
+
+  return CVertexBuffer((void *) bufferHandle, vertices.size() / 4, this);
+}
+
+void CGUIFontTTFGL::DestroyVertexBuffer(CVertexBuffer &buffer) const
+{
+  if (buffer.bufferHandle != 0)
+  {
+    // Release the buffer name for reuse
+    glDeleteBuffers(1, (GLuint *) &buffer.bufferHandle);
+    buffer.bufferHandle = 0;
+  }
+}
+#endif
+
 CBaseTexture* CGUIFontTTFGL::ReallocTexture(unsigned int& newHeight)
 {
   newHeight = CBaseTexture::PadPow2(newHeight);
diff --git a/xbmc/guilib/GUIFontTTFGL.h b/xbmc/guilib/GUIFontTTFGL.h
index 6736cf7..168fb21 100644
--- a/xbmc/guilib/GUIFontTTFGL.h
+++ b/xbmc/guilib/GUIFontTTFGL.h
@@ -29,6 +29,7 @@
 
 
 #include "GUIFontTTF.h"
+#include "system.h"
 
 
 /*!
@@ -43,6 +44,10 @@ class CGUIFontTTFGL : public CGUIFontTTFBase
 
   virtual bool FirstBegin();
   virtual void LastEnd();
+#if HAS_GLES
+  virtual CVertexBuffer CreateVertexBuffer(const std::vector<SVertex> &vertices) const;
+  virtual void DestroyVertexBuffer(CVertexBuffer &bufferHandle) const;
+#endif
 
 protected:
   virtual CBaseTexture* ReallocTexture(unsigned int& newHeight);
-- 
1.9.3


From bafbd11e1fbcb62c9eec8d567897c356ddca2893 Mon Sep 17 00:00:00 2001
From: Ben Avison <bavison@riscosopen.org>
Date: Thu, 16 Jan 2014 16:29:42 +0000
Subject: [PATCH 013/102] Switch from glDrawArrays() to glDrawElements(). This
 involves setting up a static VBO containing the indexes necessary to convert
 from quads to triangles on the fly in the GPU.

---
 xbmc/guilib/GUIFontTTFGL.cpp        | 72 +++++++++++++++++++++++++------------
 xbmc/guilib/GUIFontTTFGL.h          |  9 +++++
 xbmc/windowing/egl/WinSystemEGL.cpp | 17 +++++++++
 3 files changed, 76 insertions(+), 22 deletions(-)

diff --git a/xbmc/guilib/GUIFontTTFGL.cpp b/xbmc/guilib/GUIFontTTFGL.cpp
index 1cd684b7..d476409 100644
--- a/xbmc/guilib/GUIFontTTFGL.cpp
+++ b/xbmc/guilib/GUIFontTTFGL.cpp
@@ -186,6 +186,10 @@ void CGUIFontTTFGL::LastEnd()
   if (m_vertexTrans.size() > 0)
   {
     // Deal with the vertices that can be hardware clipped and therefore translated
+
+    // Bind our pre-calculated array to GL_ELEMENT_ARRAY_BUFFER
+    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, m_elementArrayHandle);
+
     for (size_t i = 0; i < m_vertexTrans.size(); i++)
     {
       // Apply the clip rectangle
@@ -201,14 +205,21 @@ void CGUIFontTTFGL::LastEnd()
       // Bind the buffer to the OpenGL context's GL_ARRAY_BUFFER binding point
       glBindBuffer(GL_ARRAY_BUFFER, (GLuint) m_vertexTrans[i].vertexBuffer->bufferHandle);
 
-      // Set up the offsets of the various vertex attributes within the buffer
-      // object bound to GL_ARRAY_BUFFER
-      glVertexAttribPointer(posLoc,  3, GL_FLOAT,         GL_FALSE, sizeof(SVertex), (GLvoid *) offsetof(SVertex, x));
-      glVertexAttribPointer(colLoc,  4, GL_UNSIGNED_BYTE, GL_TRUE,  sizeof(SVertex), (GLvoid *) offsetof(SVertex, r));
-      glVertexAttribPointer(tex0Loc, 2, GL_FLOAT,         GL_FALSE, sizeof(SVertex), (GLvoid *) offsetof(SVertex, u));
+      // Do the actual drawing operation, split into groups of characters no
+      // larger than the pre-determined size of the element array
+      for (size_t character = 0; m_vertexTrans[i].vertexBuffer->size > character; character += ELEMENT_ARRAY_MAX_CHAR_INDEX)
+      {
+        size_t count = m_vertexTrans[i].vertexBuffer->size - character;
+        count = std::min<size_t>(count, ELEMENT_ARRAY_MAX_CHAR_INDEX);
+
+        // Set up the offsets of the various vertex attributes within the buffer
+        // object bound to GL_ARRAY_BUFFER
+        glVertexAttribPointer(posLoc,  3, GL_FLOAT,         GL_FALSE, sizeof(SVertex), (GLvoid *) (character*sizeof(SVertex)*4 + offsetof(SVertex, x)));
+        glVertexAttribPointer(colLoc,  4, GL_UNSIGNED_BYTE, GL_TRUE,  sizeof(SVertex), (GLvoid *) (character*sizeof(SVertex)*4 + offsetof(SVertex, r)));
+        glVertexAttribPointer(tex0Loc, 2, GL_FLOAT,         GL_FALSE, sizeof(SVertex), (GLvoid *) (character*sizeof(SVertex)*4 + offsetof(SVertex, u)));
 
-      // Do the actual drawing operation, using the full set of vertices in the buffer
-      glDrawArrays(GL_TRIANGLES, 0, 6 * m_vertexTrans[i].vertexBuffer->size);
+        glDrawElements(GL_TRIANGLES, 6 * count, GL_UNSIGNED_SHORT, 0);
+      }
 
       g_matrices.PopMatrix();
     }
@@ -216,8 +227,9 @@ void CGUIFontTTFGL::LastEnd()
     g_graphicsContext.ResetScissors();
     // Restore the original model view matrix
     glUniformMatrix4fv(modelLoc, 1, GL_FALSE, g_matrices.GetMatrix(MM_MODELVIEW));
-    // Unbind GL_ARRAY_BUFFER
+    // Unbind GL_ARRAY_BUFFER and GL_ELEMENT_ARRAY_BUFFER
     glBindBuffer(GL_ARRAY_BUFFER, 0);
+    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
   }
 
   // Disable the attributes used by this shader
@@ -232,19 +244,6 @@ void CGUIFontTTFGL::LastEnd()
 #if HAS_GLES
 CVertexBuffer CGUIFontTTFGL::CreateVertexBuffer(const std::vector<SVertex> &vertices) const
 {
-  // Rearrange the vertices to describe triangles
-  std::vector<SVertex> triangleVertices;
-  triangleVertices.reserve(vertices.size() * 6 / 4);
-  for (size_t i = 0; i < vertices.size(); i += 4)
-  {
-    triangleVertices.push_back(vertices[i]);
-    triangleVertices.push_back(vertices[i+1]);
-    triangleVertices.push_back(vertices[i+2]);
-    triangleVertices.push_back(vertices[i+1]);
-    triangleVertices.push_back(vertices[i+3]);
-    triangleVertices.push_back(vertices[i+2]);
-  }
-
   // Generate a unique buffer object name and put it in bufferHandle
   GLuint bufferHandle;
   glGenBuffers(1, &bufferHandle);
@@ -253,7 +252,7 @@ CVertexBuffer CGUIFontTTFGL::CreateVertexBuffer(const std::vector<SVertex> &vert
   // Create a data store for the buffer object bound to the GL_ARRAY_BUFFER
   // binding point (i.e. our buffer object) and initialise it from the
   // specified client-side pointer
-  glBufferData(GL_ARRAY_BUFFER, triangleVertices.size() * sizeof (SVertex), &triangleVertices[0], GL_STATIC_DRAW);
+  glBufferData(GL_ARRAY_BUFFER, vertices.size() * sizeof (SVertex), &vertices[0], GL_STATIC_DRAW);
   // Unbind GL_ARRAY_BUFFER
   glBindBuffer(GL_ARRAY_BUFFER, 0);
 
@@ -348,4 +347,33 @@ void CGUIFontTTFGL::DeleteHardwareTexture()
   }
 }
 
+#if HAS_GLES
+void CGUIFontTTFGL::CreateStaticVertexBuffers(void)
+{
+  // Bind a new buffer to the OpenGL context's GL_ELEMENT_ARRAY_BUFFER binding point
+  glGenBuffers(1, &m_elementArrayHandle);
+  glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, m_elementArrayHandle);
+  // Create an array holding the mesh indices to convert quads to triangles
+  GLushort index[ELEMENT_ARRAY_MAX_CHAR_INDEX][6];
+  for (size_t i = 0; i < ELEMENT_ARRAY_MAX_CHAR_INDEX; i++)
+  {
+    index[i][0] = 4*i;
+    index[i][1] = 4*i+1;
+    index[i][2] = 4*i+2;
+    index[i][3] = 4*i+1;
+    index[i][4] = 4*i+3;
+    index[i][5] = 4*i+2;
+  }
+  glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof index, index, GL_STATIC_DRAW);
+  glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
+}
+
+void CGUIFontTTFGL::DestroyStaticVertexBuffers(void)
+{
+  glDeleteBuffers(1, &m_elementArrayHandle);
+}
+
+GLuint CGUIFontTTFGL::m_elementArrayHandle;
+#endif
+
 #endif
diff --git a/xbmc/guilib/GUIFontTTFGL.h b/xbmc/guilib/GUIFontTTFGL.h
index 168fb21..a14ab7a 100644
--- a/xbmc/guilib/GUIFontTTFGL.h
+++ b/xbmc/guilib/GUIFontTTFGL.h
@@ -30,6 +30,7 @@
 
 #include "GUIFontTTF.h"
 #include "system.h"
+#include "system_gl.h"
 
 
 /*!
@@ -47,6 +48,8 @@ class CGUIFontTTFGL : public CGUIFontTTFBase
 #if HAS_GLES
   virtual CVertexBuffer CreateVertexBuffer(const std::vector<SVertex> &vertices) const;
   virtual void DestroyVertexBuffer(CVertexBuffer &bufferHandle) const;
+  static void CreateStaticVertexBuffers(void);
+  static void DestroyStaticVertexBuffers(void);
 #endif
 
 protected:
@@ -54,6 +57,12 @@ class CGUIFontTTFGL : public CGUIFontTTFBase
   virtual bool CopyCharToTexture(FT_BitmapGlyph bitGlyph, unsigned int x1, unsigned int y1, unsigned int x2, unsigned int y2);
   virtual void DeleteHardwareTexture();
 
+#if HAS_GLES
+#define ELEMENT_ARRAY_MAX_CHAR_INDEX (1000)
+
+  static GLuint m_elementArrayHandle;
+#endif
+
 };
 
 #endif
diff --git a/xbmc/windowing/egl/WinSystemEGL.cpp b/xbmc/windowing/egl/WinSystemEGL.cpp
index 6de3532..258a293 100644
--- a/xbmc/windowing/egl/WinSystemEGL.cpp
+++ b/xbmc/windowing/egl/WinSystemEGL.cpp
@@ -29,6 +29,7 @@
 #include "settings/AdvancedSettings.h"
 #include "settings/Settings.h"
 #include "settings/DisplaySettings.h"
+#include "guilib/GUIFontTTFGL.h"
 #include "utils/log.h"
 #include "EGLWrapper.h"
 #include "EGLQuirks.h"
@@ -193,6 +194,9 @@ bool CWinSystemEGL::CreateWindow(RESOLUTION_INFO &res)
     return false;
   }
 
+#if HAS_GLES
+  bool newContext = false;
+#endif
   if (m_context == EGL_NO_CONTEXT)
   {
     if (!m_egl->CreateContext(m_display, m_config, contextAttrs, &m_context))
@@ -200,6 +204,9 @@ bool CWinSystemEGL::CreateWindow(RESOLUTION_INFO &res)
       CLog::Log(LOGERROR, "%s: Could not create context",__FUNCTION__);
       return false;
     }
+#if HAS_GLES
+    newContext = true;
+#endif
   }
 
   if (!m_egl->BindContext(m_display, m_surface, m_context))
@@ -208,6 +215,11 @@ bool CWinSystemEGL::CreateWindow(RESOLUTION_INFO &res)
     return false;
   }
 
+#if HAS_GLES
+  if (newContext)
+    CGUIFontTTFGL::CreateStaticVertexBuffers();
+#endif
+
   // for the non-trivial dirty region modes, we need the EGL buffer to be preserved across updates
   if (g_advancedSettings.m_guiAlgorithmDirtyRegions == DIRTYREGION_SOLVER_COST_REDUCTION ||
       g_advancedSettings.m_guiAlgorithmDirtyRegions == DIRTYREGION_SOLVER_UNION)
@@ -229,7 +241,12 @@ bool CWinSystemEGL::DestroyWindowSystem()
   DestroyWindow();
 
   if (m_context != EGL_NO_CONTEXT)
+  {
+#if HAS_GLES
+    CGUIFontTTFGL::DestroyStaticVertexBuffers();
+#endif
     m_egl->DestroyContext(m_display, m_context);
+  }
   m_context = EGL_NO_CONTEXT;
 
   if (m_display != EGL_NO_DISPLAY)
-- 
1.9.3


From a2ba9f0ea636a5b9644d69874c4141b4595500a3 Mon Sep 17 00:00:00 2001
From: Ben Avison <bavison@riscosopen.org>
Date: Tue, 4 Feb 2014 16:17:57 +0000
Subject: [PATCH 014/102] Update Windows project files

---
 project/VS2010Express/XBMC.vcxproj         | 2 ++
 project/VS2010Express/XBMC.vcxproj.filters | 6 ++++++
 2 files changed, 8 insertions(+)

diff --git a/project/VS2010Express/XBMC.vcxproj b/project/VS2010Express/XBMC.vcxproj
index 3d2b67b..2498cb2 100644
--- a/project/VS2010Express/XBMC.vcxproj
+++ b/project/VS2010Express/XBMC.vcxproj
@@ -426,6 +426,7 @@
     <ClCompile Include="..\..\xbmc\guilib\GUIFadeLabelControl.cpp" />
     <ClCompile Include="..\..\xbmc\guilib\GUIFixedListContainer.cpp" />
     <ClCompile Include="..\..\xbmc\guilib\GUIFont.cpp" />
+    <ClCompile Include="..\..\xbmc\guilib\GUIFontCache.cpp" />
     <ClCompile Include="..\..\xbmc\guilib\GUIFontManager.cpp" />
     <ClCompile Include="..\..\xbmc\guilib\GUIFontTTF.cpp" />
     <ClCompile Include="..\..\xbmc\guilib\GUIFontTTFDX.cpp" />
@@ -1745,6 +1746,7 @@
     <ClInclude Include="..\..\xbmc\guilib\GUIFadeLabelControl.h" />
     <ClInclude Include="..\..\xbmc\guilib\GUIFixedListContainer.h" />
     <ClInclude Include="..\..\xbmc\guilib\GUIFont.h" />
+    <ClInclude Include="..\..\xbmc\guilib\GUIFontCache.h" />
     <ClInclude Include="..\..\xbmc\guilib\GUIFontManager.h" />
     <ClInclude Include="..\..\xbmc\guilib\GUIFontTTF.h" />
     <ClInclude Include="..\..\xbmc\guilib\GUIFontTTFDX.h" />
diff --git a/project/VS2010Express/XBMC.vcxproj.filters b/project/VS2010Express/XBMC.vcxproj.filters
index c630d26..aa7d063 100644
--- a/project/VS2010Express/XBMC.vcxproj.filters
+++ b/project/VS2010Express/XBMC.vcxproj.filters
@@ -1003,6 +1003,9 @@
     <ClCompile Include="..\..\xbmc\guilib\GUIFont.cpp">
       <Filter>guilib</Filter>
     </ClCompile>
+    <ClCompile Include="..\..\xbmc\guilib\GUIFontCache.cpp">
+      <Filter>guilib</Filter>
+    </ClCompile>
     <ClCompile Include="..\..\xbmc\guilib\GUIFontManager.cpp">
       <Filter>guilib</Filter>
     </ClCompile>
@@ -3918,6 +3921,9 @@
     <ClInclude Include="..\..\xbmc\guilib\GUIFont.h">
       <Filter>guilib</Filter>
     </ClInclude>
+    <ClInclude Include="..\..\xbmc\guilib\GUIFontCache.h">
+      <Filter>guilib</Filter>
+    </ClInclude>
     <ClInclude Include="..\..\xbmc\guilib\GUIFontManager.h">
       <Filter>guilib</Filter>
     </ClInclude>
-- 
1.9.3


From f3abd7d186d1561aeedc9f561f4f473cfc924f05 Mon Sep 17 00:00:00 2001
From: Ben Avison <bavison@riscosopen.org>
Date: Tue, 4 Feb 2014 16:49:45 +0000
Subject: [PATCH 015/102] Update XCode project file

---
 XBMC.xcodeproj/project.pbxproj | 10 ++++++++++
 1 file changed, 10 insertions(+)

diff --git a/XBMC.xcodeproj/project.pbxproj b/XBMC.xcodeproj/project.pbxproj
index 94f85ee..990dfdb 100644
--- a/XBMC.xcodeproj/project.pbxproj
+++ b/XBMC.xcodeproj/project.pbxproj
@@ -168,6 +168,9 @@
 		1D638128161E211E003603ED /* PeripheralImon.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 1D638126161E211E003603ED /* PeripheralImon.cpp */; };
 		1DAFDB7C16DFDCA7007F8C68 /* PeripheralBusCEC.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 1DAFDB7A16DFDCA7007F8C68 /* PeripheralBusCEC.cpp */; };
 		1DE0443515828F4B005DDB4D /* Exception.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 1DE0443315828F4B005DDB4D /* Exception.cpp */; };
+		2FD7EC5F18A14FE50047F86C /* GUIFontCache.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 2FD7EC5D18A14FE50047F86C /* GUIFontCache.cpp */; };
+		2FD7EC6018A14FE50047F86C /* GUIFontCache.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 2FD7EC5D18A14FE50047F86C /* GUIFontCache.cpp */; };
+		2FD7EC6118A14FE50047F86C /* GUIFontCache.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 2FD7EC5D18A14FE50047F86C /* GUIFontCache.cpp */; };
 		32C631281423A90F00F18420 /* JpegIO.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 32C631261423A90F00F18420 /* JpegIO.cpp */; };
 		36A9443D15821E2800727135 /* DatabaseUtils.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 36A9443B15821E2800727135 /* DatabaseUtils.cpp */; };
 		36A9444115821E7C00727135 /* SortUtils.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 36A9443F15821E7C00727135 /* SortUtils.cpp */; };
@@ -4020,6 +4023,8 @@
 		1DAFDB7B16DFDCA7007F8C68 /* PeripheralBusCEC.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = PeripheralBusCEC.h; sourceTree = "<group>"; };
 		1DE0443315828F4B005DDB4D /* Exception.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = Exception.cpp; path = commons/Exception.cpp; sourceTree = "<group>"; };
 		1DE0443415828F4B005DDB4D /* Exception.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = Exception.h; path = commons/Exception.h; sourceTree = "<group>"; };
+		2FD7EC5D18A14FE50047F86C /* GUIFontCache.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = GUIFontCache.cpp; sourceTree = "<group>"; };
+		2FD7EC5E18A14FE50047F86C /* GUIFontCache.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = GUIFontCache.h; sourceTree = "<group>"; };
 		32C631261423A90F00F18420 /* JpegIO.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = JpegIO.cpp; sourceTree = "<group>"; };
 		32C631271423A90F00F18420 /* JpegIO.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = JpegIO.h; sourceTree = "<group>"; };
 		36A9443B15821E2800727135 /* DatabaseUtils.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = DatabaseUtils.cpp; sourceTree = "<group>"; };
@@ -6533,6 +6538,8 @@
 				18B7C76A1294222E009E7A26 /* GUIFixedListContainer.cpp */,
 				18B7C7101294222D009E7A26 /* GUIFixedListContainer.h */,
 				18B7C76B1294222E009E7A26 /* GUIFont.cpp */,
+				2FD7EC5D18A14FE50047F86C /* GUIFontCache.cpp */,
+				2FD7EC5E18A14FE50047F86C /* GUIFontCache.h */,
 				18B7C7111294222D009E7A26 /* GUIFont.h */,
 				18B7C76C1294222E009E7A26 /* GUIFontManager.cpp */,
 				18B7C7121294222D009E7A26 /* GUIFontManager.h */,
@@ -11858,6 +11865,7 @@
 				DF033D381946612400BFC82E /* AEDeviceEnumerationOSX.cpp in Sources */,
 				7C525DF5195E2D8100BE3482 /* SaveFileStateJob.cpp in Sources */,
 				7C908894196358A8003D0619 /* auto_buffer.cpp in Sources */,
+				2FD7EC5F18A14FE50047F86C /* GUIFontCache.cpp in Sources */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
@@ -13052,6 +13060,7 @@
 				7CAA469219427AED00008885 /* PosixDirectory.cpp in Sources */,
 				7C525DF7195E2D8100BE3482 /* SaveFileStateJob.cpp in Sources */,
 				7C908896196358A8003D0619 /* auto_buffer.cpp in Sources */,
+				2FD7EC6118A14FE50047F86C /* GUIFontCache.cpp in Sources */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
@@ -14248,6 +14257,7 @@
 				7CAA469119427AED00008885 /* PosixDirectory.cpp in Sources */,
 				7C525DF6195E2D8100BE3482 /* SaveFileStateJob.cpp in Sources */,
 				7C908895196358A8003D0619 /* auto_buffer.cpp in Sources */,
+				2FD7EC6018A14FE50047F86C /* GUIFontCache.cpp in Sources */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
-- 
1.9.3


From 366e8c48c165265b4f9d22b8e2b26fdddfa6467a Mon Sep 17 00:00:00 2001
From: Ben Avison <bavison@riscosopen.org>
Date: Tue, 4 Feb 2014 17:44:34 +0000
Subject: [PATCH 016/102] Clang seems to be more picky than gcc about some C++
 template syntax

---
 xbmc/guilib/GUIFontCache.cpp | 20 ++++++++++----------
 1 file changed, 10 insertions(+), 10 deletions(-)

diff --git a/xbmc/guilib/GUIFontCache.cpp b/xbmc/guilib/GUIFontCache.cpp
index 895fa72..bd84b9a 100644
--- a/xbmc/guilib/GUIFontCache.cpp
+++ b/xbmc/guilib/GUIFontCache.cpp
@@ -61,26 +61,26 @@ Value &CGUIFontCache<Position, Value>::Lookup(Position &pos,
                                        alignment, maxPixelWidth,
                                        scrolling, g_graphicsContext.GetGUIMatrix(),
                                        g_graphicsContext.GetGUIScaleX(), g_graphicsContext.GetGUIScaleY());
-  EntryHashIterator i = m_list.get<Hash>().find(key);
-  if (i == m_list.get<Hash>().end())
+  EntryHashIterator i = m_list.template get<Hash>().find(key);
+  if (i == m_list.template get<Hash>().end())
   {
     /* Cache miss */
-    EntryAgeIterator oldest = m_list.get<Age>().begin();
-    if (!m_list.get<Age>().empty() && nowMillis - oldest->m_lastUsedMillis > FONT_CACHE_TIME_LIMIT)
+    EntryAgeIterator oldest = m_list.template get<Age>().begin();
+    if (!m_list.template get<Age>().empty() && nowMillis - oldest->m_lastUsedMillis > FONT_CACHE_TIME_LIMIT)
     {
       /* The oldest existing entry is old enough to expire and reuse */
-      m_list.get<Hash>().modify(m_list.project<Hash>(oldest), typename CGUIFontCacheEntry<Position, Value>::Reassign(key, nowMillis));
-      m_list.get<Age>().relocate(m_list.get<Age>().end(), oldest);
+      m_list.template get<Hash>().modify(m_list.template project<Hash>(oldest), typename CGUIFontCacheEntry<Position, Value>::Reassign(key, nowMillis));
+      m_list.template get<Age>().relocate(m_list.template get<Age>().end(), oldest);
     }
     else
     {
       /* We need a new entry instead */
       /* Yes, this causes the creation an destruction of a temporary entry, but
        * this code ought to only be used infrequently, when the cache needs to grow */
-      m_list.get<Age>().push_back(CGUIFontCacheEntry<Position, Value>(*this, key, nowMillis));
+      m_list.template get<Age>().push_back(CGUIFontCacheEntry<Position, Value>(*this, key, nowMillis));
     }
     dirtyCache = true;
-    return (--m_list.get<Age>().end())->m_value;
+    return (--m_list.template get<Age>().end())->m_value;
   }
   else
   {
@@ -90,7 +90,7 @@ Value &CGUIFontCache<Position, Value>::Lookup(Position &pos,
     pos.UpdateWithOffsets(i->m_key.m_pos, scrolling);
     /* Update time in entry and move to the back of the list */
     i->m_lastUsedMillis = nowMillis;
-    m_list.get<Age>().relocate(m_list.get<Age>().end(), m_list.project<Age>(i));
+    m_list.template get<Age>().relocate(m_list.template get<Age>().end(), m_list.template project<Age>(i));
     dirtyCache = false;
     return i->m_value;
   }
@@ -99,7 +99,7 @@ Value &CGUIFontCache<Position, Value>::Lookup(Position &pos,
 template<class Position, class Value>
 void CGUIFontCache<Position, Value>::Flush()
 {
-  m_list.get<Age>().clear();
+  m_list.template get<Age>().clear();
 }
 
 template void CGUIFontCacheEntry<CGUIFontCacheStaticPosition, CGUIFontCacheStaticValue>::Reassign::operator()(CGUIFontCacheEntry<CGUIFontCacheStaticPosition, CGUIFontCacheStaticValue> &entry);
-- 
1.9.3


From 88806afd0c118a2ca1e8f0dbf8ee425137aacfc3 Mon Sep 17 00:00:00 2001
From: Ben Avison <bavison@riscosopen.org>
Date: Tue, 4 Feb 2014 18:52:14 +0000
Subject: [PATCH 017/102] Fix header to hopefully permit iOS builds to work
 again. GUIShader.cpp added #include windowing/egl/WinSystemEGL.h inside a but
 also need the header windowing/osx/WinSystemIOS.h instead. The only thing
 GUIShader.cpp needed was g_windowing.GetViewPort, which is provided by the
 common base class CRenderSystemGLES of g_windowing in both cases, so I think
 it should be sufficient to use windowing/WindowingFactory.h instead, which is
 abstracted away from the other header files.

---
 xbmc/guilib/GUIShader.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/xbmc/guilib/GUIShader.cpp b/xbmc/guilib/GUIShader.cpp
index 53bce09..86330cc 100644
--- a/xbmc/guilib/GUIShader.cpp
+++ b/xbmc/guilib/GUIShader.cpp
@@ -26,7 +26,7 @@
 #include "GUIShader.h"
 #include "MatrixGLES.h"
 #include "utils/log.h"
-#include "windowing/egl/WinSystemEGL.h"
+#include "windowing/WindowingFactory.h"
 #include "guilib/GraphicContext.h"
 
 CGUIShader::CGUIShader( const char *shader ) : CGLSLShaderProgram("guishader_vert.glsl", shader)
-- 
1.9.3


From b981367182fb888f1cf0d8e5d335e3526af896c4 Mon Sep 17 00:00:00 2001
From: Ben Avison <bavison@riscosopen.org>
Date: Tue, 8 Apr 2014 18:14:55 +0100
Subject: [PATCH 018/102] Fix font display in stereoscopic modes
 CGUIFontTTFGL::LastEnd was previously using the relatively high-level
 CGraphicContext::SetScissors function to enforce hardware clipping. However,
 the coordinates it passed in already contained the stereoscopic offset, so
 the CGraphicContext::SetScissors effectively ended up double-applying the
 offset, with the effect that clip rectangles were always off-screen. Changed
 to call the low-level SetScissors call instead (using g_Windowing to select
 the correct implementation, e.g. CRenderSystemGLES::SetScissors). This also
 skips the intersection of the scissors with the screen limits, but that does
 not appear to matter in practice.

---
 xbmc/guilib/GUIFontTTFGL.cpp | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/xbmc/guilib/GUIFontTTFGL.cpp b/xbmc/guilib/GUIFontTTFGL.cpp
index d476409..8466a81 100644
--- a/xbmc/guilib/GUIFontTTFGL.cpp
+++ b/xbmc/guilib/GUIFontTTFGL.cpp
@@ -194,7 +194,7 @@ void CGUIFontTTFGL::LastEnd()
     {
       // Apply the clip rectangle
       CRect clip = g_Windowing.ClipRectToScissorRect(m_vertexTrans[i].clip);
-      g_graphicsContext.SetScissors(clip);
+      g_Windowing.SetScissors(clip);
 
       // Apply the translation to the currently active (top-of-stack) model view matrix
       g_matrices.MatrixMode(MM_MODELVIEW);
@@ -224,7 +224,7 @@ void CGUIFontTTFGL::LastEnd()
       g_matrices.PopMatrix();
     }
     // Restore the original scissor rectangle
-    g_graphicsContext.ResetScissors();
+    g_Windowing.ResetScissors();
     // Restore the original model view matrix
     glUniformMatrix4fv(modelLoc, 1, GL_FALSE, g_matrices.GetMatrix(MM_MODELVIEW));
     // Unbind GL_ARRAY_BUFFER and GL_ELEMENT_ARRAY_BUFFER
-- 
1.9.3


From cffae5d7f38dfbbaa427e61c0e5a56fe00852380 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Fri, 10 Jan 2014 12:10:43 +0000
Subject: [PATCH 019/102] [rbp] Don't override dvdplayer with omxplayer.

Using dvdplayer can be useful on the Pi. We can actually play sd (up to 640x480 MPEG-4 video) video in real time.
This is useful for codec variants like DivX3 which we don't currently play.

This may expose bugs where dvdplayer is incorrectly used as the default player which will need to be fixed
---
 xbmc/cores/playercorefactory/PlayerCoreConfig.h | 7 -------
 1 file changed, 7 deletions(-)

diff --git a/xbmc/cores/playercorefactory/PlayerCoreConfig.h b/xbmc/cores/playercorefactory/PlayerCoreConfig.h
index 27f0bec..fc12bb7 100644
--- a/xbmc/cores/playercorefactory/PlayerCoreConfig.h
+++ b/xbmc/cores/playercorefactory/PlayerCoreConfig.h
@@ -88,14 +88,7 @@ friend class CPlayerCoreFactory;
     {
       case EPC_MPLAYER:
       // TODO: this hack needs removal until we have a better player selection
-#if defined(HAS_OMXPLAYER)
-      case EPC_DVDPLAYER: 
-        pPlayer = new COMXPlayer(callback); 
-        CLog::Log(LOGINFO, "Created player %s for core %d / OMXPlayer forced as DVDPlayer", "OMXPlayer", m_eCore);
-        break;
-#else
       case EPC_DVDPLAYER: pPlayer = new CDVDPlayer(callback); break;
-#endif
       case EPC_PAPLAYER: pPlayer = new PAPlayer(callback); break;
       case EPC_EXTPLAYER: pPlayer = new CExternalPlayer(callback); break;
 #if defined(HAS_OMXPLAYER)
-- 
1.9.3


From f3e06268a61b2fd42401fd810f9d6144adc7f6ab Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Fri, 10 Jan 2014 15:37:41 +0000
Subject: [PATCH 020/102] [players] Use default players rather than hard coded
 DVDPlayer/PAPlayer

---
 system/playercorefactory.xml | 23 ++++++++++++-----------
 1 file changed, 12 insertions(+), 11 deletions(-)

diff --git a/system/playercorefactory.xml b/system/playercorefactory.xml
index 57dfcdd..7be9799 100644
--- a/system/playercorefactory.xml
+++ b/system/playercorefactory.xml
@@ -11,31 +11,32 @@
   </players>
 
   <rules name="system rules">
-    <rule name="rtv" protocols="rtv" player="DVDPlayer" />
-    <rule name="hdhomerun/myth/mms/udp" protocols="hdhomerun|myth|cmyth|mms|mmsh|udp" player="DVDPlayer" />
-    <rule name="lastfm/shout" protocols="lastfm|shout" player="PAPlayer" />
+    <rule name="rtv" protocols="rtv" player="videodefaultplayer" />
+    <rule name="hdhomerun/myth/mms/udp" protocols="hdhomerun|myth|cmyth|mms|mmsh|udp" player="videodefaultplayer" />
+    <rule name="lastfm/shout" protocols="lastfm|shout" player="audiodefaultplayer" />
     <rule name="rtmp" protocols="rtmp" player="videodefaultplayer" />
 
     <!-- dvdplayer can play standard rtsp streams -->
-    <rule name="rtsp" protocols="rtsp" filetypes="!(rm|ra)"  player="PAPlayer" />
+    <rule name="rtsp" protocols="rtsp" filetypes="!(rm|ra)"  player="audiodefaultplayer" />
 
     <!-- Internet streams -->
     <rule name="streams" internetstream="true">
-      <rule name="aacp/sdp" mimetypes="audio/aacp|application/sdp" player="DVDPlayer" />
-      <rule name="mp2" mimetypes="application/octet-stream" filetypes="mp2" player="PAPlayer" />
+      <rule name="aacp/sdp" mimetypes="audio/aacp|application/sdp" player="videodefaultplayer" />
+      <rule name="mp2" mimetypes="application/octet-stream" filetypes="mp2" player="audiodefaultplayer" />
     </rule>
 
     <!-- DVDs -->
-    <rule name="dvd" dvd="true" player="DVDPlayer" />
-    <rule name="dvdimage" dvdimage="true" player="DVDPlayer" />
+    <rule name="dvd" dvd="true" player="videodefaultdvdplayer" />
+    <rule name="dvdfile" dvdfile="true" player="videodefaultdvdplayer" />
+    <rule name="dvdimage" dvdimage="true" player="videodefaultdvdplayer" />
 
     <!-- Only dvdplayer can handle these normally -->
-    <rule name="sdp/asf" filetypes="sdp|asf" player="DVDPlayer" />
+    <rule name="sdp/asf" filetypes="sdp|asf" player="videodefaultplayer" />
 
     <!-- Pass these to dvdplayer as we do not know if they are audio or video -->
-    <rule name="nsv" filetypes="nsv" player="DVDPlayer" />
+    <rule name="nsv" filetypes="nsv" player="videodefaultplayer" />
 
     <!-- pvr radio channels should be played by dvdplayer because they need buffering -->
-    <rule name="radio" filetypes="pvr" filename=".*/radio/.*" player="DVDPlayer" />
+    <rule name="radio" filetypes="pvr" filename=".*/radio/.*" player="videodefaultplayer" />
   </rules>
 </playercorefactory>
-- 
1.9.3


From afe6ac464be227de30cc4177c50091231d607af9 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Sat, 11 Jan 2014 18:23:42 +0000
Subject: [PATCH 021/102] [rbp] Don't force dvdplayer for airplay

---
 xbmc/network/AirPlayServer.cpp | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/xbmc/network/AirPlayServer.cpp b/xbmc/network/AirPlayServer.cpp
index a2b930e..74a3b30 100644
--- a/xbmc/network/AirPlayServer.cpp
+++ b/xbmc/network/AirPlayServer.cpp
@@ -903,9 +903,11 @@ int CAirPlayServer::CTCPClient::ProcessRequest( CStdString& responseHeader,
       CFileItem fileToPlay(location, false);
       fileToPlay.SetProperty("StartPercent", position*100.0f);
       ServerInstance->AnnounceToClients(EVENT_LOADING);
+#ifndef TARGET_RASPBERRY_PI
       // froce to internal dvdplayer cause it is the only
       // one who will work well with airplay
       g_application.m_eForcedNextPlayer = EPC_DVDPLAYER;
+#endif
       CApplicationMessenger::Get().MediaPlay(fileToPlay);
     }
   }
-- 
1.9.3


From 5d75c8ba10041c285e9628e8d014530971d284f0 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Mon, 13 Jan 2014 13:11:06 +0000
Subject: [PATCH 022/102] [rbp] Give plugins omxplayer when they request
 dvdplayer on pi

---
 xbmc/interfaces/legacy/ModuleXbmc.cpp | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/xbmc/interfaces/legacy/ModuleXbmc.cpp b/xbmc/interfaces/legacy/ModuleXbmc.cpp
index db54d79..96031b2 100644
--- a/xbmc/interfaces/legacy/ModuleXbmc.cpp
+++ b/xbmc/interfaces/legacy/ModuleXbmc.cpp
@@ -527,7 +527,11 @@ namespace XBMCAddon
     int getPLAYLIST_MUSIC() { return PLAYLIST_MUSIC; }
     int getPLAYLIST_VIDEO() { return PLAYLIST_VIDEO; }
     int getPLAYER_CORE_AUTO() { return EPC_NONE; }
+#ifdef TARGET_RASPBERRY_PI
+    int getPLAYER_CORE_DVDPLAYER() { return EPC_OMXPLAYER; }
+#else
     int getPLAYER_CORE_DVDPLAYER() { return EPC_DVDPLAYER; }
+#endif
     int getPLAYER_CORE_MPLAYER() { return EPC_MPLAYER; }
     int getPLAYER_CORE_PAPLAYER() { return EPC_PAPLAYER; }
     int getTRAY_OPEN() { return TRAY_OPEN; }
-- 
1.9.3


From f1001b59dba7124ecaf64588d953dbbb232e38e1 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Tue, 14 Jan 2014 18:04:07 +0000
Subject: [PATCH 023/102] [rbp] Allow ALSA to be chosen in addition to Pi sink

Needs --enable-alsa in ./configure step and alsa support on platform
---
 configure.in                             |  1 -
 tools/depends/target/Makefile            |  5 +++--
 xbmc/cores/AudioEngine/AESinkFactory.cpp | 15 ++++++++++++++-
 3 files changed, 17 insertions(+), 4 deletions(-)

diff --git a/configure.in b/configure.in
index efd0574..a537a1c 100644
--- a/configure.in
+++ b/configure.in
@@ -705,7 +705,6 @@ case $use_platform in
      use_arch="arm"
      use_cpu=arm1176jzf-s
      use_hardcoded_tables="yes"
-     use_alsa="no"
      ARCH="arm"
      AC_DEFINE(HAS_EGLGLES, [1], [Define if supporting EGL based GLES Framebuffer])
      USE_OMXLIB=1; AC_DEFINE([HAVE_OMXLIB],[1],["Define to 1 if OMX libs is enabled"])
diff --git a/tools/depends/target/Makefile b/tools/depends/target/Makefile
index 3e02fc0..eea2a06 100644
--- a/tools/depends/target/Makefile
+++ b/tools/depends/target/Makefile
@@ -57,10 +57,11 @@ LINUX_SYSTEM_LIBS=
 ifeq ($(OS),linux)
   #not for raspberry pi
   ifneq ($(TARGET_PLATFORM),raspberry-pi)
-    DEPENDS += alsa-lib libsdl linux-system-libs
-    ALSA_LIB = alsa-lib
+    DEPENDS += libsdl linux-system-libs
     LINUX_SYSTEM_LIBS = linux-system-libs
   endif
+  DEPENDS += alsa-lib
+  ALSA_LIB = alsa-lib
   FFMPEG_DEPENDS = gnutls
 endif
 
diff --git a/xbmc/cores/AudioEngine/AESinkFactory.cpp b/xbmc/cores/AudioEngine/AESinkFactory.cpp
index e42d973..715b4f1 100644
--- a/xbmc/cores/AudioEngine/AESinkFactory.cpp
+++ b/xbmc/cores/AudioEngine/AESinkFactory.cpp
@@ -27,6 +27,7 @@
   #include "Sinks/AESinkAUDIOTRACK.h"
 #elif defined(TARGET_RASPBERRY_PI)
   #include "Sinks/AESinkPi.h"
+  #include "Sinks/AESinkALSA.h"
 #elif defined(TARGET_DARWIN_IOS)
   #include "Sinks/AESinkDARWINIOS.h"
 #elif defined(TARGET_DARWIN_OSX)
@@ -66,6 +67,7 @@ void CAESinkFactory::ParseDevice(std::string &device, std::string &driver)
         driver == "AUDIOTRACK"  ||
 #elif defined(TARGET_RASPBERRY_PI)
         driver == "PI"          ||
+        driver == "ALSA"        ||
 #elif defined(TARGET_DARWIN_IOS)
         driver == "DARWINIOS"  ||
 #elif defined(TARGET_DARWIN_OSX)
@@ -105,7 +107,12 @@ IAESink *CAESinkFactory::TrySink(std::string &driver, std::string &device, AEAud
 #elif defined(TARGET_ANDROID)
     sink = new CAESinkAUDIOTRACK();
 #elif defined(TARGET_RASPBERRY_PI)
+  if (driver == "PI")
     sink = new CAESinkPi();
+  #if defined(HAS_ALSA)
+  if (driver == "ALSA")
+    sink = new CAESinkALSA();
+  #endif
 #elif defined(TARGET_DARWIN_IOS)
     sink = new CAESinkDARWINIOS();
 #elif defined(TARGET_DARWIN_OSX)
@@ -196,7 +203,13 @@ void CAESinkFactory::EnumerateEx(AESinkInfoList &list, bool force)
   CAESinkPi::EnumerateDevicesEx(info.m_deviceInfoList, force);
   if(!info.m_deviceInfoList.empty())
     list.push_back(info);
-
+  #if defined(HAS_ALSA)
+  info.m_deviceInfoList.clear();
+  info.m_sinkName = "ALSA";
+  CAESinkALSA::EnumerateDevicesEx(info.m_deviceInfoList, force);
+  if(!info.m_deviceInfoList.empty())
+    list.push_back(info);
+  #endif
 #elif defined(TARGET_DARWIN_IOS)
 
   info.m_deviceInfoList.clear();
-- 
1.9.3


From 9e7fee9ceb9a58256985b22d5dec8e9b217a81c3 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Thu, 16 Jan 2014 01:39:29 +0000
Subject: [PATCH 024/102] [omxcodec] Add hardware decode to dvdplayer for Pi

Hijack the abandoned OpenMaxVideo codec
---
 configure.in                                       |   21 +-
 xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp    |   12 +-
 xbmc/cores/VideoRenderers/LinuxRendererGLES.h      |    6 +-
 xbmc/cores/VideoRenderers/RenderManager.cpp        |    2 +-
 xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp |    7 +-
 .../dvdplayer/DVDCodecs/Video/DVDVideoCodec.h      |    7 +-
 .../DVDCodecs/Video/DVDVideoCodecOpenMax.cpp       |  295 +---
 .../DVDCodecs/Video/DVDVideoCodecOpenMax.h         |   34 +-
 xbmc/cores/dvdplayer/DVDCodecs/Video/Makefile.in   |    1 -
 xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMax.cpp   |  269 ----
 xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMax.h     |  116 --
 .../dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp     | 1418 ++++++++++----------
 .../cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.h |  120 +-
 xbmc/cores/dvdplayer/DVDPlayer.cpp                 |    2 +
 xbmc/cores/dvdplayer/DVDPlayerVideo.cpp            |   21 +-
 xbmc/linux/OMXCore.cpp                             |   45 +-
 xbmc/linux/OMXCore.h                               |    2 +-
 17 files changed, 894 insertions(+), 1484 deletions(-)
 delete mode 100644 xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMax.cpp
 delete mode 100644 xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMax.h

diff --git a/configure.in b/configure.in
index a537a1c..62516d6 100644
--- a/configure.in
+++ b/configure.in
@@ -1968,9 +1968,24 @@ if test "$host_vendor" = "apple" ; then
   USE_OPENMAX=0
   AC_MSG_NOTICE($openmax_disabled)
 elif test "$target_platform" = "target_raspberry_pi"; then
-  use_openmax="no"
-  USE_OPENMAX=0
-  AC_MSG_NOTICE($openmax_disabled)
+  if test "$use_gles" = "yes" && test "$use_openmax" = "auto"; then
+    use_openmax="yes"
+    USE_OPENMAX=1
+    HAVE_LIBOPENMAX=1
+    AC_DEFINE([HAVE_LIBOPENMAX], [1], [Define to 1 if you have the 'LIBOPENMAX' library.])
+    AC_DEFINE([OMX_SKIP64BIT], [1], [Define to 1 if you have the 'LIBOPENMAX' library.])
+    AC_MSG_NOTICE($openmax_enabled)
+  elif test "$use_gles" = "yes" && test "$use_openmax" = "yes"; then
+    use_openmax="yes"
+    USE_OPENMAX=1
+    HAVE_LIBOPENMAX=1
+    AC_DEFINE([HAVE_LIBOPENMAX], [1], [Define to 1 if you have the 'LIBOPENMAX' library.])
+    AC_MSG_NOTICE($openmax_enabled)
+  else
+    AC_MSG_NOTICE($openmax_disabled)
+    use_openmax=no
+    USE_OPENMAX=0
+  fi
 else
   if test "$use_gles" = "yes" && test "$use_openmax" = "auto"; then
     PKG_CHECK_MODULES([OPENMAX], [libomxil-bellagio],
diff --git a/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp b/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp
index 72eb725..2e0d0ca 100644
--- a/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp
+++ b/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp
@@ -44,7 +44,7 @@
 #include "VideoShaders/VideoFilterShader.h"
 #include "windowing/WindowingFactory.h"
 #include "guilib/Texture.h"
-#include "../dvdplayer/DVDCodecs/Video/OpenMaxVideo.h"
+#include "DVDCodecs/Video/OpenMaxVideo.h"
 #include "threads/SingleLock.h"
 #include "RenderCapture.h"
 #include "RenderFormats.h"
@@ -1328,6 +1328,10 @@ void CLinuxRendererGLES::RenderOpenMax(int index, int field)
   glActiveTexture(GL_TEXTURE0);
   glBindTexture(m_textureTarget, textureId);
 
+  GLint filter = m_scalingMethod == VS_SCALINGMETHOD_NEAREST ? GL_NEAREST : GL_LINEAR;
+  glTexParameteri(m_textureTarget, GL_TEXTURE_MAG_FILTER, filter);
+  glTexParameteri(m_textureTarget, GL_TEXTURE_MIN_FILTER, filter);
+
   g_Windowing.EnableGUIShader(SM_TEXTURE_RGBA);
 
   GLubyte idx[4] = {0, 1, 3, 2};        //determines order of triangle strip
@@ -2674,10 +2678,12 @@ unsigned int CLinuxRendererGLES::GetProcessorSize()
 }
 
 #ifdef HAVE_LIBOPENMAX
-void CLinuxRendererGLES::AddProcessor(COpenMax* openMax, DVDVideoPicture *picture, int index)
+void CLinuxRendererGLES::AddProcessor(COpenMaxVideoBuffer *openMaxBuffer, int index)
 {
   YUVBUFFER &buf = m_buffers[index];
-  buf.openMaxBuffer = picture->openMaxBuffer;
+  COpenMaxVideoBuffer *pic = openMaxBuffer->Acquire();
+  SAFE_RELEASE(buf.openMaxBuffer);
+  buf.openMaxBuffer = pic;
 }
 #endif
 #ifdef HAVE_VIDEOTOOLBOXDECODER
diff --git a/xbmc/cores/VideoRenderers/LinuxRendererGLES.h b/xbmc/cores/VideoRenderers/LinuxRendererGLES.h
index 642cded..5a6a2be 100644
--- a/xbmc/cores/VideoRenderers/LinuxRendererGLES.h
+++ b/xbmc/cores/VideoRenderers/LinuxRendererGLES.h
@@ -39,7 +39,7 @@ class CRenderCapture;
 class CBaseTexture;
 namespace Shaders { class BaseYUV2RGBShader; }
 namespace Shaders { class BaseVideoFilterShader; }
-class COpenMaxVideo;
+class COpenMaxVideoBuffer;
 class CDVDVideoCodecStageFright;
 class CDVDMediaCodecInfo;
 typedef std::vector<int>     Features;
@@ -158,7 +158,7 @@ class CLinuxRendererGLES : public CBaseRenderer
   virtual std::vector<ERenderFormat> SupportedFormats() { return m_formats; }
 
 #ifdef HAVE_LIBOPENMAX
-  virtual void         AddProcessor(COpenMax* openMax, DVDVideoPicture *picture, int index);
+  virtual void         AddProcessor(COpenMaxVideoBuffer *openMaxVideoBuffer, int index);
 #endif
 #ifdef HAVE_VIDEOTOOLBOXDECODER
   virtual void         AddProcessor(struct __CVBuffer *cvBufferRef, int index);
@@ -272,7 +272,7 @@ class CLinuxRendererGLES : public CBaseRenderer
     unsigned  flipindex; /* used to decide if this has been uploaded */
 
 #ifdef HAVE_LIBOPENMAX
-    OpenMaxVideoBuffer *openMaxBuffer;
+    COpenMaxVideoBuffer *openMaxBuffer;
 #endif
 #ifdef HAVE_VIDEOTOOLBOXDECODER
     struct __CVBuffer *cvBufferRef;
diff --git a/xbmc/cores/VideoRenderers/RenderManager.cpp b/xbmc/cores/VideoRenderers/RenderManager.cpp
index ca9aa84..1816407 100644
--- a/xbmc/cores/VideoRenderers/RenderManager.cpp
+++ b/xbmc/cores/VideoRenderers/RenderManager.cpp
@@ -914,7 +914,7 @@ int CXBMCRenderManager::AddVideoPicture(DVDVideoPicture& pic)
 #endif
 #ifdef HAVE_LIBOPENMAX
   else if(pic.format == RENDER_FMT_OMXEGL)
-    m_pRenderer->AddProcessor(pic.openMax, &pic, index);
+    m_pRenderer->AddProcessor(pic.openMaxBuffer, index);
 #endif
 #ifdef TARGET_DARWIN
   else if(pic.format == RENDER_FMT_CVBREF)
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp b/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp
index f77ac40..5d37395 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp
@@ -268,9 +268,12 @@ CDVDVideoCodec* CDVDFactoryCodec::CreateVideoCodec(CDVDStreamInfo &hint, unsigne
 #endif
 
 #if defined(HAVE_LIBOPENMAX)
-  if (CSettings::Get().GetBool("videoplayer.useomx") && !hint.software )
+  if (!hint.software && CSettings::Get().GetBool("videoplayer.useomx"))
   {
-      if (hint.codec == AV_CODEC_ID_H264 || hint.codec == AV_CODEC_ID_MPEG2VIDEO || hint.codec == AV_CODEC_ID_VC1)
+    if (hint.codec == AV_CODEC_ID_H264 || hint.codec == AV_CODEC_ID_H263 || hint.codec == AV_CODEC_ID_MPEG4 ||
+        hint.codec == AV_CODEC_ID_MPEG1VIDEO || hint.codec == AV_CODEC_ID_MPEG2VIDEO ||
+        hint.codec == AV_CODEC_ID_VP6 || hint.codec == AV_CODEC_ID_VP6F || hint.codec == AV_CODEC_ID_VP6A || hint.codec == AV_CODEC_ID_VP8 ||
+        hint.codec == AV_CODEC_ID_THEORA || hint.codec == AV_CODEC_ID_MJPEG || hint.codec == AV_CODEC_ID_MJPEGB || hint.codec == AV_CODEC_ID_VC1 || hint.codec == AV_CODEC_ID_WMV3)
     {
       if ( (pCodec = OpenCodec(new CDVDVideoCodecOpenMax(), hint, options)) ) return pCodec;
     }
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h
index 741017d..7daed00 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h
@@ -48,9 +48,7 @@ struct DVDCodecAvailableType
 namespace DXVA { class CSurfaceContext; }
 namespace VAAPI { struct CHolder; }
 namespace VDPAU { class CVdpauRenderPicture; }
-class COpenMax;
-class COpenMaxVideo;
-struct OpenMaxVideoBuffer;
+class COpenMaxVideoBuffer;
 class CDVDVideoCodecStageFright;
 class CDVDMediaCodecInfo;
 typedef void* EGLImageKHR;
@@ -79,8 +77,7 @@ struct DVDVideoPicture
     };
 
     struct {
-      COpenMax *openMax;
-      OpenMaxVideoBuffer *openMaxBuffer;
+      COpenMaxVideoBuffer *openMaxBuffer;
     };
 
     struct {
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecOpenMax.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecOpenMax.cpp
index b2e7816..7d33192 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecOpenMax.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecOpenMax.cpp
@@ -29,113 +29,43 @@
 #include "DVDStreamInfo.h"
 #include "DVDVideoCodecOpenMax.h"
 #include "OpenMaxVideo.h"
+#include "settings/Settings.h"
 #include "utils/log.h"
 
-#define CLASSNAME "COpenMax"
+#define CLASSNAME "CDVDVideoCodecOpenMax"
 ////////////////////////////////////////////////////////////////////////////////////////////
 ////////////////////////////////////////////////////////////////////////////////////////////
-CDVDVideoCodecOpenMax::CDVDVideoCodecOpenMax() : CDVDVideoCodec()
+CDVDVideoCodecOpenMax::CDVDVideoCodecOpenMax()
 {
   m_omx_decoder = NULL;
-  m_pFormatName = "omx-xxxx";
-
-  m_convert_bitstream = false;
-  memset(&m_videobuffer, 0, sizeof(DVDVideoPicture));
+  CLog::Log(LOGDEBUG, "%s::%s %p\n", CLASSNAME, __func__, this);
 }
 
 CDVDVideoCodecOpenMax::~CDVDVideoCodecOpenMax()
 {
+  CLog::Log(LOGDEBUG, "%s::%s %p\n", CLASSNAME, __func__, this);
   Dispose();
 }
 
 bool CDVDVideoCodecOpenMax::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options)
 {
-  // we always qualify even if DVDFactoryCodec does this too.
-  if (CSettings::Get().GetBool("videoplayer.useomx") && !hints.software)
-  {
-    m_convert_bitstream = false;
-
-    switch (hints.codec)
-    {
-      case AV_CODEC_ID_H264:
-      {
-        m_pFormatName = "omx-h264";
-        if (hints.extrasize < 7 || hints.extradata == NULL)
-        {
-          CLog::Log(LOGNOTICE,
-            "%s::%s - avcC data too small or missing", CLASSNAME, __func__);
-          return false;
-        }
-        // valid avcC data (bitstream) always starts with the value 1 (version)
-        if ( *(char*)hints.extradata == 1 )
-          m_convert_bitstream = bitstream_convert_init(hints.extradata, hints.extrasize);
-      }
-      break;
-      case AV_CODEC_ID_MPEG4:
-        m_pFormatName = "omx-mpeg4";
-      break;
-      case AV_CODEC_ID_MPEG2VIDEO:
-        m_pFormatName = "omx-mpeg2";
-      break;
-      case AV_CODEC_ID_VC1:
-        m_pFormatName = "omx-vc1";
-      break;
-      default:
-        return false;
-      break;
-    }
-
-    m_omx_decoder = new COpenMaxVideo;
-    if (!m_omx_decoder->Open(hints))
-    {
-      CLog::Log(LOGERROR,
-        "%s::%s - failed to open, codec(%d), profile(%d), level(%d)", 
-        CLASSNAME, __func__, hints.codec, hints.profile, hints.level);
-      return false;
-    }
-
-    // allocate a YV12 DVDVideoPicture buffer.
-    // first make sure all properties are reset.
-    memset(&m_videobuffer, 0, sizeof(DVDVideoPicture));
-
-    m_videobuffer.dts = DVD_NOPTS_VALUE;
-    m_videobuffer.pts = DVD_NOPTS_VALUE;
-    //m_videobuffer.format = RENDER_FMT_YUV420P;
-    m_videobuffer.format = RENDER_FMT_OMXEGL;
-    m_videobuffer.color_range  = 0;
-    m_videobuffer.color_matrix = 4;
-    m_videobuffer.iFlags  = DVP_FLAG_ALLOCATED;
-    m_videobuffer.iWidth  = hints.width;
-    m_videobuffer.iHeight = hints.height;
-    m_videobuffer.iDisplayWidth  = hints.width;
-    m_videobuffer.iDisplayHeight = hints.height;
-
-    return true;
-  }
+  m_omx_decoder = new COpenMaxVideo;
+  return m_omx_decoder->Open(hints, options);
+}
 
-  return false;
+const char* CDVDVideoCodecOpenMax::GetName(void)
+{
+  return m_omx_decoder ? m_omx_decoder->GetName() : "omx-xxx";
 }
 
 void CDVDVideoCodecOpenMax::Dispose()
 {
   if (m_omx_decoder)
   {
-    m_omx_decoder->Close();
+    m_omx_decoder->Dispose();
     delete m_omx_decoder;
     m_omx_decoder = NULL;
   }
-  if (m_videobuffer.iFlags & DVP_FLAG_ALLOCATED)
-  {
-    m_videobuffer.iFlags = 0;
-  }
-  if (m_convert_bitstream)
-  {
-    if (m_sps_pps_context.sps_pps_data)
-    {
-      free(m_sps_pps_context.sps_pps_data);
-      m_sps_pps_context.sps_pps_data = NULL;
-    }
-  }
 }
 
 void CDVDVideoCodecOpenMax::SetDropState(bool bDrop)
@@ -145,37 +75,12 @@ void CDVDVideoCodecOpenMax::SetDropState(bool bDrop)
 
 int CDVDVideoCodecOpenMax::Decode(uint8_t* pData, int iSize, double dts, double pts)
 {
-  if (pData)
-  {
-    int rtn;
-    int demuxer_bytes = iSize;
-    uint8_t *demuxer_content = pData;
-    bool bitstream_convered  = false;
-
-    if (m_convert_bitstream)
-    {
-      // convert demuxer packet from bitstream to bytestream (AnnexB)
-      int bytestream_size = 0;
-      uint8_t *bytestream_buff = NULL;
-
-      bitstream_convert(demuxer_content, demuxer_bytes, &bytestream_buff, &bytestream_size);
-      if (bytestream_buff && (bytestream_size > 0))
-      {
-        bitstream_convered = true;
-        demuxer_bytes = bytestream_size;
-        demuxer_content = bytestream_buff;
-      }
-    }
-
-    rtn = m_omx_decoder->Decode(demuxer_content, demuxer_bytes, dts, pts);
-
-    if (bitstream_convered)
-      free(demuxer_content);
+  return m_omx_decoder->Decode(pData, iSize, dts, pts);
+}
 
-    return rtn;
-  }
-  
-  return VC_BUFFER;
+unsigned CDVDVideoCodecOpenMax::GetAllowedReferences()
+{
+  return m_omx_decoder->GetAllowedReferences();
 }
 
 void CDVDVideoCodecOpenMax::Reset(void)
@@ -185,172 +90,12 @@ void CDVDVideoCodecOpenMax::Reset(void)
 
 bool CDVDVideoCodecOpenMax::GetPicture(DVDVideoPicture* pDvdVideoPicture)
 {
-  m_omx_decoder->GetPicture(&m_videobuffer);
-  *pDvdVideoPicture = m_videobuffer;
-
-  return VC_PICTURE | VC_BUFFER;
-}
-
-////////////////////////////////////////////////////////////////////////////////////////////
-bool CDVDVideoCodecOpenMax::bitstream_convert_init(void *in_extradata, int in_extrasize)
-{
-  // based on h264_mp4toannexb_bsf.c (ffmpeg)
-  // which is Copyright (c) 2007 Benoit Fouet <benoit.fouet@free.fr>
-  // and Licensed GPL 2.1 or greater
-
-  m_sps_pps_size = 0;
-  m_sps_pps_context.sps_pps_data = NULL;
-  
-  // nothing to filter
-  if (!in_extradata || in_extrasize < 6)
-    return false;
-
-  uint16_t unit_size;
-  uint32_t total_size = 0;
-  uint8_t *out = NULL, unit_nb, sps_done = 0;
-  const uint8_t *extradata = (uint8_t*)in_extradata + 4;
-  static const uint8_t nalu_header[4] = {0, 0, 0, 1};
-
-  // retrieve length coded size
-  m_sps_pps_context.length_size = (*extradata++ & 0x3) + 1;
-  if (m_sps_pps_context.length_size == 3)
-    return false;
-
-  // retrieve sps and pps unit(s)
-  unit_nb = *extradata++ & 0x1f;  // number of sps unit(s)
-  if (!unit_nb)
-  {
-    unit_nb = *extradata++;       // number of pps unit(s)
-    sps_done++;
-  }
-  while (unit_nb--)
-  {
-    unit_size = extradata[0] << 8 | extradata[1];
-    total_size += unit_size + 4;
-    if ( (extradata + 2 + unit_size) > ((uint8_t*)in_extradata + in_extrasize) )
-    {
-      free(out);
-      return false;
-    }
-    uint8_t* new_out = (uint8_t*)realloc(out, total_size);
-    if (new_out)
-    {
-      out = new_out;
-    }
-    else
-    {
-      CLog::Log(LOGERROR, "bitstream_convert_init failed - %s : could not realloc the buffer out",  __FUNCTION__);
-      free(out);
-      return false;
-    }
-
-    memcpy(out + total_size - unit_size - 4, nalu_header, 4);
-    memcpy(out + total_size - unit_size, extradata + 2, unit_size);
-    extradata += 2 + unit_size;
-
-    if (!unit_nb && !sps_done++)
-      unit_nb = *extradata++;     // number of pps unit(s)
-  }
-
-  m_sps_pps_context.sps_pps_data = out;
-  m_sps_pps_context.size = total_size;
-  m_sps_pps_context.first_idr = 1;
-
-  return true;
-}
-
-bool CDVDVideoCodecOpenMax::bitstream_convert(uint8_t* pData, int iSize, uint8_t **poutbuf, int *poutbuf_size)
-{
-  // based on h264_mp4toannexb_bsf.c (ffmpeg)
-  // which is Copyright (c) 2007 Benoit Fouet <benoit.fouet@free.fr>
-  // and Licensed GPL 2.1 or greater
-
-  uint8_t *buf = pData;
-  uint32_t buf_size = iSize;
-  uint8_t  unit_type;
-  int32_t  nal_size;
-  uint32_t cumul_size = 0;
-  const uint8_t *buf_end = buf + buf_size;
-
-  do
-  {
-    if (buf + m_sps_pps_context.length_size > buf_end)
-      goto fail;
-
-    if (m_sps_pps_context.length_size == 1)
-      nal_size = buf[0];
-    else if (m_sps_pps_context.length_size == 2)
-      nal_size = buf[0] << 8 | buf[1];
-    else
-      nal_size = buf[0] << 24 | buf[1] << 16 | buf[2] << 8 | buf[3];
-
-    buf += m_sps_pps_context.length_size;
-    unit_type = *buf & 0x1f;
-
-    if (buf + nal_size > buf_end || nal_size < 0)
-      goto fail;
-
-    // prepend only to the first type 5 NAL unit of an IDR picture
-    if (m_sps_pps_context.first_idr && unit_type == 5)
-    {
-      bitstream_alloc_and_copy(poutbuf, poutbuf_size,
-        m_sps_pps_context.sps_pps_data, m_sps_pps_context.size, buf, nal_size);
-      m_sps_pps_context.first_idr = 0;
-    }
-    else
-    {
-      bitstream_alloc_and_copy(poutbuf, poutbuf_size, NULL, 0, buf, nal_size);
-      if (!m_sps_pps_context.first_idr && unit_type == 1)
-          m_sps_pps_context.first_idr = 1;
-    }
-
-    buf += nal_size;
-    cumul_size += nal_size + m_sps_pps_context.length_size;
-  } while (cumul_size < buf_size);
-
-  return true;
-
-fail:
-  free(*poutbuf);
-  *poutbuf = NULL;
-  *poutbuf_size = 0;
-  return false;
+  return m_omx_decoder->GetPicture(pDvdVideoPicture);
 }
 
-void CDVDVideoCodecOpenMax::bitstream_alloc_and_copy(
-  uint8_t **poutbuf,      int *poutbuf_size,
-  const uint8_t *sps_pps, uint32_t sps_pps_size,
-  const uint8_t *in,      uint32_t in_size)
+bool CDVDVideoCodecOpenMax::ClearPicture(DVDVideoPicture* pDvdVideoPicture)
 {
-  // based on h264_mp4toannexb_bsf.c (ffmpeg)
-  // which is Copyright (c) 2007 Benoit Fouet <benoit.fouet@free.fr>
-  // and Licensed GPL 2.1 or greater
-
-  #define CHD_WB32(p, d) { \
-    ((uint8_t*)(p))[3] = (d); \
-    ((uint8_t*)(p))[2] = (d) >> 8; \
-    ((uint8_t*)(p))[1] = (d) >> 16; \
-    ((uint8_t*)(p))[0] = (d) >> 24; }
-
-  uint32_t offset = *poutbuf_size;
-  uint8_t nal_header_size = offset ? 3 : 4;
-
-  *poutbuf_size += sps_pps_size + in_size + nal_header_size;
-  *poutbuf = (uint8_t*)realloc(*poutbuf, *poutbuf_size);
-  if (sps_pps)
-    memcpy(*poutbuf + offset, sps_pps, sps_pps_size);
-
-  memcpy(*poutbuf + sps_pps_size + nal_header_size + offset, in, in_size);
-  if (!offset)
-  {
-    CHD_WB32(*poutbuf + sps_pps_size, 1);
-  }
-  else
-  {
-    (*poutbuf + offset + sps_pps_size)[0] = 0;
-    (*poutbuf + offset + sps_pps_size)[1] = 0;
-    (*poutbuf + offset + sps_pps_size)[2] = 1;
-  }
+  return m_omx_decoder->ClearPicture(pDvdVideoPicture);
 }
 
 #endif
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecOpenMax.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecOpenMax.h
index fb80d02..67cc235 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecOpenMax.h
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecOpenMax.h
@@ -23,7 +23,7 @@
 
 #include "DVDVideoCodec.h"
 
-class COpenVideoMax;
+class COpenMaxVideo;
 class CDVDVideoCodecOpenMax : public CDVDVideoCodec
 {
 public:
@@ -36,39 +36,13 @@ class CDVDVideoCodecOpenMax : public CDVDVideoCodec
   virtual int  Decode(uint8_t *pData, int iSize, double dts, double pts);
   virtual void Reset(void);
   virtual bool GetPicture(DVDVideoPicture *pDvdVideoPicture);
+  virtual bool ClearPicture(DVDVideoPicture* pDvdVideoPicture);
+  virtual unsigned GetAllowedReferences();
   virtual void SetDropState(bool bDrop);
-  virtual const char* GetName(void) { return (const char*)m_pFormatName; }
+  virtual const char* GetName(void);
   
 protected:
-  const char        *m_pFormatName;
   COpenMaxVideo     *m_omx_decoder;
-  DVDVideoPicture   m_videobuffer;
-
-  // bitstream to bytestream (Annex B) conversion support.
-  bool bitstream_convert_init(void *in_extradata, int in_extrasize);
-  bool bitstream_convert(uint8_t* pData, int iSize, uint8_t **poutbuf, int *poutbuf_size);
-  static void bitstream_alloc_and_copy( uint8_t **poutbuf, int *poutbuf_size,
-    const uint8_t *sps_pps, uint32_t sps_pps_size, const uint8_t *in, uint32_t in_size);
-
-  typedef struct omx_bitstream_ctx {
-      uint8_t  length_size;
-      uint8_t  first_idr;
-      uint8_t *sps_pps_data;
-      uint32_t size;
-
-      omx_bitstream_ctx()
-      {
-        length_size = 0;
-        first_idr = 0;
-        sps_pps_data = NULL;
-        size = 0;
-      }
-
-  } omx_bitstream_ctx;
-
-  uint32_t          m_sps_pps_size;
-  omx_bitstream_ctx m_sps_pps_context;
-  bool              m_convert_bitstream;
 };
 
 #endif
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/Makefile.in b/xbmc/cores/dvdplayer/DVDCodecs/Video/Makefile.in
index 8a97889..ebf7123 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/Makefile.in
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/Makefile.in
@@ -20,7 +20,6 @@ SRCS += DVDVideoCodecVDA.cpp
 SRCS += VDA.cpp
 endif
 ifeq (@USE_OPENMAX@,1)
-SRCS += OpenMax.cpp
 SRCS += OpenMaxVideo.cpp
 SRCS += DVDVideoCodecOpenMax.cpp
 endif
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMax.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMax.cpp
deleted file mode 100644
index 7b0a0c2ef..0000000
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMax.cpp
+++ /dev/null
@@ -1,269 +0,0 @@
-/*
- *      Copyright (C) 2010-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-
-#if (defined HAVE_CONFIG_H) && (!defined TARGET_WINDOWS)
-  #include "config.h"
-#elif defined(TARGET_WINDOWS)
-#include "system.h"
-#endif
-
-#if defined(HAVE_LIBOPENMAX)
-#include "OpenMax.h"
-#include "DynamicDll.h"
-#include "DVDClock.h"
-#include "DVDStreamInfo.h"
-#include "windowing/WindowingFactory.h"
-#include "DVDVideoCodec.h"
-#include "utils/log.h"
-#include "utils/TimeUtils.h"
-#include "ApplicationMessenger.h"
-#include "Application.h"
-
-#include <OMX_Core.h>
-#include <OMX_Component.h>
-#include <OMX_Index.h>
-#include <OMX_Image.h>
-
-#define CLASSNAME "COpenMax"
-
-
-////////////////////////////////////////////////////////////////////////////////////////////
-class DllLibOpenMaxInterface
-{
-public:
-  virtual ~DllLibOpenMaxInterface() {}
-
-  virtual OMX_ERRORTYPE OMX_Init(void) = 0;
-  virtual OMX_ERRORTYPE OMX_Deinit(void) = 0;
-  virtual OMX_ERRORTYPE OMX_GetHandle(
-    OMX_HANDLETYPE *pHandle, OMX_STRING cComponentName, OMX_PTR pAppData, OMX_CALLBACKTYPE *pCallBacks) = 0;
-  virtual OMX_ERRORTYPE OMX_FreeHandle(OMX_HANDLETYPE hComponent) = 0;
-  virtual OMX_ERRORTYPE OMX_GetComponentsOfRole(OMX_STRING role, OMX_U32 *pNumComps, OMX_U8 **compNames) = 0;
-  virtual OMX_ERRORTYPE OMX_GetRolesOfComponent(OMX_STRING compName, OMX_U32 *pNumRoles, OMX_U8 **roles) = 0;
-  virtual OMX_ERRORTYPE OMX_ComponentNameEnum(OMX_STRING cComponentName, OMX_U32 nNameLength, OMX_U32 nIndex) = 0;
-};
-
-class DllLibOpenMax : public DllDynamic, DllLibOpenMaxInterface
-{
-  DECLARE_DLL_WRAPPER(DllLibOpenMax, "/usr/lib/libnvomx.so")
-
-  DEFINE_METHOD0(OMX_ERRORTYPE, OMX_Init)
-  DEFINE_METHOD0(OMX_ERRORTYPE, OMX_Deinit)
-  DEFINE_METHOD4(OMX_ERRORTYPE, OMX_GetHandle, (OMX_HANDLETYPE *p1, OMX_STRING p2, OMX_PTR p3, OMX_CALLBACKTYPE *p4))
-  DEFINE_METHOD1(OMX_ERRORTYPE, OMX_FreeHandle, (OMX_HANDLETYPE p1))
-  DEFINE_METHOD3(OMX_ERRORTYPE, OMX_GetComponentsOfRole, (OMX_STRING p1, OMX_U32 *p2, OMX_U8 **p3))
-  DEFINE_METHOD3(OMX_ERRORTYPE, OMX_GetRolesOfComponent, (OMX_STRING p1, OMX_U32 *p2, OMX_U8 **p3))
-  DEFINE_METHOD3(OMX_ERRORTYPE, OMX_ComponentNameEnum, (OMX_STRING p1, OMX_U32 p2, OMX_U32 p3))
-  BEGIN_METHOD_RESOLVE()
-    RESOLVE_METHOD(OMX_Init)
-    RESOLVE_METHOD(OMX_Deinit)
-    RESOLVE_METHOD(OMX_GetHandle)
-    RESOLVE_METHOD(OMX_FreeHandle)
-    RESOLVE_METHOD(OMX_GetComponentsOfRole)
-    RESOLVE_METHOD(OMX_GetRolesOfComponent)
-    RESOLVE_METHOD(OMX_ComponentNameEnum)
-  END_METHOD_RESOLVE()
-};
-
-////////////////////////////////////////////////////////////////////////////////////////////
-#define OMX_INIT_STRUCTURE(a) \
-  memset(&(a), 0, sizeof(a)); \
-  (a).nSize = sizeof(a); \
-  (a).nVersion.s.nVersionMajor = OMX_VERSION_MAJOR; \
-  (a).nVersion.s.nVersionMinor = OMX_VERSION_MINOR; \
-  (a).nVersion.s.nRevision = OMX_VERSION_REVISION; \
-  (a).nVersion.s.nStep = OMX_VERSION_STEP
-
-////////////////////////////////////////////////////////////////////////////////////////////
-////////////////////////////////////////////////////////////////////////////////////////////
-COpenMax::COpenMax()
-{
-  #if defined(OMX_DEBUG_VERBOSE)
-  CLog::Log(LOGDEBUG, "%s::%s\n", CLASSNAME, __func__);
-  #endif
-  m_dll = new DllLibOpenMax;
-  m_dll->Load();
-  m_is_open = false;
-
-  m_omx_decoder = NULL;
-  m_omx_client_state = DEAD;
-  m_omx_decoder_state = 0;
-  sem_init(m_omx_decoder_state_change, 0, 0);
-  /*
-  m_omx_flush_input  = (sem_t*)malloc(sizeof(sem_t));
-  sem_init(m_omx_flush_input, 0, 0);
-  m_omx_flush_output = (sem_t*)malloc(sizeof(sem_t));
-  sem_init(m_omx_flush_output, 0, 0);
-  */
-}
-
-COpenMax::~COpenMax()
-{
-  #if defined(OMX_DEBUG_VERBOSE)
-  CLog::Log(LOGDEBUG, "%s::%s\n", CLASSNAME, __func__);
-  #endif
-  /*
-  sem_destroy(m_omx_flush_input);
-  free(m_omx_flush_input);
-  sem_destroy(m_omx_flush_output);
-  free(m_omx_flush_output);
-  */
-  delete m_dll;
-}
-
-
-
-
-////////////////////////////////////////////////////////////////////////////////////////////
-// DecoderEventHandler -- OMX event callback
-OMX_ERRORTYPE COpenMax::DecoderEventHandlerCallback(
-  OMX_HANDLETYPE hComponent,
-  OMX_PTR pAppData,
-  OMX_EVENTTYPE eEvent,
-  OMX_U32 nData1,
-  OMX_U32 nData2,
-  OMX_PTR pEventData)
-{
-  COpenMax *ctx = (COpenMax*)pAppData;
-  return ctx->DecoderEventHandler(hComponent, pAppData, eEvent, nData1, nData2, pEventData);
-}
-
-// DecoderEmptyBufferDone -- OpenMax input buffer has been emptied
-OMX_ERRORTYPE COpenMax::DecoderEmptyBufferDoneCallback(
-  OMX_HANDLETYPE hComponent,
-  OMX_PTR pAppData,
-  OMX_BUFFERHEADERTYPE* pBuffer)
-{
-  COpenMax *ctx = (COpenMax*)pAppData;
-  return ctx->DecoderEmptyBufferDone( hComponent, pAppData, pBuffer);
-}
-
-// DecoderFillBufferDone -- OpenMax output buffer has been filled
-OMX_ERRORTYPE COpenMax::DecoderFillBufferDoneCallback(
-  OMX_HANDLETYPE hComponent,
-  OMX_PTR pAppData,
-  OMX_BUFFERHEADERTYPE* pBuffer)
-{
-  COpenMax *ctx = (COpenMax*)pAppData;
-  return ctx->DecoderFillBufferDone(hComponent, pAppData, pBuffer);
-}
-
-
-
-// Wait for a component to transition to the specified state
-OMX_ERRORTYPE COpenMax::WaitForState(OMX_STATETYPE state)
-{
-  OMX_STATETYPE test_state;
-  int tries = 0;
-  struct timespec timeout;
-  OMX_ERRORTYPE omx_error = OMX_GetState(m_omx_decoder, &test_state);
-
-  #if defined(OMX_DEBUG_VERBOSE)
-  CLog::Log(LOGDEBUG, "%s::%s - waiting for state(%d)\n", CLASSNAME, __func__, state);
-  #endif
-  while ((omx_error == OMX_ErrorNone) && (test_state != state)) 
-  {
-    clock_gettime(CLOCK_REALTIME, &timeout);
-    timeout.tv_sec += 1;
-    sem_timedwait(m_omx_decoder_state_change, &timeout);
-    if (errno == ETIMEDOUT)
-      tries++;
-    if (tries > 5)
-      return OMX_ErrorUndefined;
-
-    omx_error = OMX_GetState(m_omx_decoder, &test_state);
-  }
-
-  return omx_error;
-}
-
-// SetStateForAllComponents
-// Blocks until all state changes have completed
-OMX_ERRORTYPE COpenMax::SetStateForComponent(OMX_STATETYPE state)
-{
-  OMX_ERRORTYPE omx_err;
-
-  #if defined(OMX_DEBUG_VERBOSE)
-  CLog::Log(LOGDEBUG, "%s::%s - state(%d)\n", CLASSNAME, __func__, state);
-  #endif
-  omx_err = OMX_SendCommand(m_omx_decoder, OMX_CommandStateSet, state, 0);
-  if (omx_err)
-    CLog::Log(LOGERROR, "%s::%s - OMX_CommandStateSet failed with omx_err(0x%x)\n",
-      CLASSNAME, __func__, omx_err);
-  else
-    omx_err = WaitForState(state);
-
-  return omx_err;
-}
-
-bool COpenMax::Initialize( const CStdString &decoder_name)
-{
-  OMX_ERRORTYPE omx_err = m_dll->OMX_Init();
-  if (omx_err)
-  {
-    CLog::Log(LOGERROR,
-      "%s::%s - OpenMax failed to init, status(%d), ", // codec(%d), profile(%d), level(%d)
-      CLASSNAME, __func__, omx_err );//, hints.codec, hints.profile, hints.level);
-    return false;
-  }
-
-  // Get video decoder handle setting up callbacks, component is in loaded state on return.
-  static OMX_CALLBACKTYPE decoder_callbacks = {
-    &DecoderEventHandlerCallback, &DecoderEmptyBufferDoneCallback, &DecoderFillBufferDoneCallback };
-  omx_err = m_dll->OMX_GetHandle(&m_omx_decoder, (char*)decoder_name.c_str(), this, &decoder_callbacks);
-  if (omx_err)
-  {
-    CLog::Log(LOGERROR,
-      "%s::%s - could not get decoder handle\n", CLASSNAME, __func__);
-    m_dll->OMX_Deinit();
-    return false;
-  }
-
-  return true;
-}
-
-void COpenMax::Deinitialize()
-{
-  CLog::Log(LOGERROR,
-    "%s::%s - failed to get component port parameter\n", CLASSNAME, __func__);
-  m_dll->OMX_FreeHandle(m_omx_decoder);
-  m_omx_decoder = NULL;
-  m_dll->OMX_Deinit();
-}
-
-// OpenMax decoder callback routines.
-OMX_ERRORTYPE COpenMax::DecoderEventHandler(OMX_HANDLETYPE hComponent, OMX_PTR pAppData,
-  OMX_EVENTTYPE eEvent, OMX_U32 nData1, OMX_U32 nData2, OMX_PTR pEventData)
-{
-  return OMX_ErrorNone;
-}
-
-OMX_ERRORTYPE COpenMax::DecoderEmptyBufferDone(OMX_HANDLETYPE hComponent, OMX_PTR pAppData, OMX_BUFFERHEADERTYPE* pBuffer)
-{
-  return OMX_ErrorNone;
-}
-
-OMX_ERRORTYPE COpenMax::DecoderFillBufferDone(OMX_HANDLETYPE hComponent, OMX_PTR pAppData, OMX_BUFFERHEADERTYPE* pBufferHeader)
-{
-  return OMX_ErrorNone;
-}
-
-#endif
-
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMax.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMax.h
deleted file mode 100644
index 0d9ff18..0000000
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMax.h
+++ /dev/null
@@ -1,116 +0,0 @@
-#pragma once
-/*
- *      Copyright (C) 2010-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-
-#if defined(HAVE_LIBOPENMAX)
-
-#include "cores/dvdplayer/DVDStreamInfo.h"
-#include "DVDVideoCodec.h"
-#include "threads/Event.h"
-
-#include <queue>
-#include <semaphore.h>
-#include <OMX_Core.h>
-
-////////////////////////////////////////////////////////////////////////////////////////////
-// debug spew defines
-#if 0
-#define OMX_DEBUG_VERBOSE
-#define OMX_DEBUG_EVENTHANDLER
-#define OMX_DEBUG_FILLBUFFERDONE
-#define OMX_DEBUG_EMPTYBUFFERDONE
-#endif
-
-typedef struct omx_codec_capability {
-    // level is OMX_VIDEO_AVCPROFILETYPE, OMX_VIDEO_H263PROFILETYPE, 
-    // or OMX_VIDEO_MPEG4PROFILETYPE depending on context.
-    OMX_U32 level;
-    // level is OMX_VIDEO_AVCLEVELTYPE, OMX_VIDEO_H263LEVELTYPE, 
-    // or OMX_VIDEO_MPEG4PROFILETYPE depending on context.
-    OMX_U32 profile;
-} omx_codec_capability;
-
-typedef struct omx_demux_packet {
-  OMX_U8 *buff;
-  int size;
-  double dts;
-  double pts;
-} omx_demux_packet;
-
-class DllLibOpenMax;
-class COpenMax
-{
-public:
-  COpenMax();
-  virtual ~COpenMax();
-
-protected:
-  enum OMX_CLIENT_STATE {
-      DEAD,
-      LOADED,
-      LOADED_TO_IDLE,
-      IDLE_TO_EXECUTING,
-      EXECUTING,
-      EXECUTING_TO_IDLE,
-      IDLE_TO_LOADED,
-      RECONFIGURING,
-      ERROR
-  };
-
-  // initialize OpenMax and get decoder component
-  bool Initialize( const CStdString &decoder_name);
-  void Deinitialize();
-
-  // OpenMax Decoder delegate callback routines.
-  static OMX_ERRORTYPE DecoderEventHandlerCallback(OMX_HANDLETYPE hComponent, OMX_PTR pAppData,
-    OMX_EVENTTYPE eEvent, OMX_U32 nData1, OMX_U32 nData2, OMX_PTR pEventData);
-  static OMX_ERRORTYPE DecoderEmptyBufferDoneCallback(
-    OMX_HANDLETYPE hComponent, OMX_PTR pAppData, OMX_BUFFERHEADERTYPE* pBuffer);
-  static OMX_ERRORTYPE DecoderFillBufferDoneCallback(
-    OMX_HANDLETYPE hComponent, OMX_PTR pAppData, OMX_BUFFERHEADERTYPE* pBufferHeader);
-
-  // OpenMax decoder callback routines.
-  virtual OMX_ERRORTYPE DecoderEventHandler(OMX_HANDLETYPE hComponent, OMX_PTR pAppData,
-    OMX_EVENTTYPE eEvent, OMX_U32 nData1, OMX_U32 nData2, OMX_PTR pEventData);
-  virtual OMX_ERRORTYPE DecoderEmptyBufferDone(
-    OMX_HANDLETYPE hComponent, OMX_PTR pAppData, OMX_BUFFERHEADERTYPE* pBuffer);
-  virtual OMX_ERRORTYPE DecoderFillBufferDone(
-    OMX_HANDLETYPE hComponent, OMX_PTR pAppData, OMX_BUFFERHEADERTYPE* pBufferHeader);
-
-  // OpenMax helper routines
-  OMX_ERRORTYPE WaitForState(OMX_STATETYPE state);
-  OMX_ERRORTYPE SetStateForComponent(OMX_STATETYPE state);
-
-  DllLibOpenMax     *m_dll;
-  bool              m_is_open;
-  OMX_HANDLETYPE    m_omx_decoder;   // openmax decoder component reference
-
-  // OpenMax state tracking
-  OMX_CLIENT_STATE  m_omx_client_state;
-  volatile int      m_omx_decoder_state;
-  sem_t             *m_omx_decoder_state_change;
-  std::vector<omx_codec_capability> m_omx_decoder_capabilities;
-
-private:
-  COpenMax(const COpenMax& other);
-  COpenMax& operator=(const COpenMax&);
-};
-
-#endif
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp
index dcbdb1e..aca2e0d 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp
@@ -32,673 +32,891 @@
 #include "DVDVideoCodec.h"
 #include "utils/log.h"
 #include "utils/TimeUtils.h"
+#include "settings/Settings.h"
 #include "ApplicationMessenger.h"
 #include "Application.h"
+#include "threads/Atomics.h"
 
-#include <OMX_Core.h>
-#include <OMX_Component.h>
-#include <OMX_Index.h>
-#include <OMX_Image.h>
+#include <IL/OMX_Core.h>
+#include <IL/OMX_Component.h>
+#include <IL/OMX_Index.h>
+#include <IL/OMX_Image.h>
 
+#include "cores/omxplayer/OMXImage.h"
+
+#define DTS_QUEUE
+
+#define DEFAULT_TIMEOUT 1000
+#ifdef _DEBUG
+#define OMX_DEBUG_VERBOSE
+#endif
 
 #define CLASSNAME "COpenMaxVideo"
 
-// TODO: These are Nvidia Tegra2 dependent, need to dynamiclly find the
-// right codec matched to video format.
-#define OMX_H264BASE_DECODER    "OMX.Nvidia.h264.decode"
-// OMX.Nvidia.h264ext.decode segfaults, not sure why.
-//#define OMX_H264MAIN_DECODER  "OMX.Nvidia.h264ext.decode"
-#define OMX_H264MAIN_DECODER    "OMX.Nvidia.h264.decode"
-#define OMX_H264HIGH_DECODER    "OMX.Nvidia.h264ext.decode"
-#define OMX_MPEG4_DECODER       "OMX.Nvidia.mp4.decode"
-#define OMX_MPEG4EXT_DECODER    "OMX.Nvidia.mp4ext.decode"
-#define OMX_MPEG2V_DECODER      "OMX.Nvidia.mpeg2v.decode"
-#define OMX_VC1_DECODER         "OMX.Nvidia.vc1.decode"
-
-// EGL extension functions
-static PFNEGLCREATEIMAGEKHRPROC eglCreateImageKHR;
-static PFNEGLDESTROYIMAGEKHRPROC eglDestroyImageKHR;
-#define GETEXTENSION(type, ext) \
-do \
-{ \
-    ext = (type) eglGetProcAddress(#ext); \
-    if (!ext) \
-    { \
-        CLog::Log(LOGERROR, "%s::%s - ERROR getting proc addr of " #ext "\n", CLASSNAME, __func__); \
-    } \
-} while (0);
-
-#define OMX_INIT_STRUCTURE(a) \
-  memset(&(a), 0, sizeof(a)); \
-  (a).nSize = sizeof(a); \
-  (a).nVersion.s.nVersionMajor = OMX_VERSION_MAJOR; \
-  (a).nVersion.s.nVersionMinor = OMX_VERSION_MINOR; \
-  (a).nVersion.s.nRevision = OMX_VERSION_REVISION; \
-  (a).nVersion.s.nStep = OMX_VERSION_STEP
+COpenMaxVideoBuffer::COpenMaxVideoBuffer(COpenMaxVideo *omv)
+    : m_omv(omv), m_refs(0)
+{
+  CLog::Log(LOGDEBUG, "%s::%s %p", CLASSNAME, __func__, this);
+  omx_buffer = NULL;
+  width = 0;
+  height = 0;
+  index = 0;
+  egl_image = 0;
+  texture_id = 0;
+}
+
+COpenMaxVideoBuffer::~COpenMaxVideoBuffer()
+{
+  CLog::Log(LOGDEBUG, "%s::%s %p", CLASSNAME, __func__, this);
+}
 
 
-COpenMaxVideo::COpenMaxVideo()
+// DecoderFillBufferDone -- OpenMax output buffer has been filled
+static OMX_ERRORTYPE DecoderFillBufferDoneCallback(
+  OMX_HANDLETYPE hComponent,
+  OMX_PTR pAppData,
+  OMX_BUFFERHEADERTYPE* pBuffer)
+{
+  COpenMaxVideoBuffer *pic = static_cast<COpenMaxVideoBuffer*>(pBuffer->pAppPrivate);
+  COpenMaxVideo *ctx = pic->m_omv;
+  return ctx->DecoderFillBufferDone(hComponent, pBuffer);
+}
+
+
+COpenMaxVideoBuffer* COpenMaxVideoBuffer::Acquire()
+{
+  long count = AtomicIncrement(&m_refs);
+  #if defined(OMX_DEBUG_VERBOSE)
+  CLog::Log(LOGDEBUG, "%s::%s %p ref:%ld", CLASSNAME, __func__, this, count);
+  #endif
+  (void)count;
+  return this;
+}
+
+long COpenMaxVideoBuffer::Release()
 {
-  m_portChanging = false;
+  long count = AtomicDecrement(&m_refs);
+  if (count == 0)
+  {
+    m_omv->ReleaseOpenMaxBuffer(this);
+  }
+
+  #if defined(OMX_DEBUG_VERBOSE)
+  CLog::Log(LOGDEBUG, "%s::%s %p ref:%ld", CLASSNAME, __func__, this, count);
+  #endif
+  return count;
+}
 
-  pthread_mutex_init(&m_omx_input_mutex, NULL);
+void COpenMaxVideoBuffer::Sync()
+{
+  #if defined(OMX_DEBUG_VERBOSE)
+  CLog::Log(LOGDEBUG, "%s::%s %p ref:%ld", CLASSNAME, __func__, this, m_refs);
+  #endif
+  Release();
+}
+
+COpenMaxVideo::COpenMaxVideo()
+{
+  CLog::Log(LOGDEBUG, "%s::%s %p", CLASSNAME, __func__, this);
   pthread_mutex_init(&m_omx_output_mutex, NULL);
 
-  m_omx_decoder_state_change = (sem_t*)malloc(sizeof(sem_t));
-  sem_init(m_omx_decoder_state_change, 0, 0);
-  memset(&m_videobuffer, 0, sizeof(DVDVideoPicture));
   m_drop_state = false;
   m_decoded_width = 0;
   m_decoded_height = 0;
-  m_omx_input_eos = false;
-  m_omx_input_port = 0;
-  m_omx_output_eos = false;
-  m_omx_output_port = 0;
-  m_videoplayback_done = false;
+  m_egl_buffer_count = 0;
+
+  m_port_settings_changed = false;
+  m_pFormatName = "omx-xxxx";
 }
 
 COpenMaxVideo::~COpenMaxVideo()
 {
   #if defined(OMX_DEBUG_VERBOSE)
-  CLog::Log(LOGDEBUG, "%s::%s\n", CLASSNAME, __func__);
+  CLog::Log(LOGDEBUG, "%s::%s %p", CLASSNAME, __func__, this);
   #endif
-  if (m_is_open)
-    Close();
-  pthread_mutex_destroy(&m_omx_input_mutex);
+  if (m_omx_decoder.IsInitialized())
+  {
+    if (m_omx_tunnel.IsInitialized())
+      m_omx_tunnel.Deestablish();
+
+    StopDecoder();
+
+    if (m_omx_egl_render.IsInitialized())
+      m_omx_egl_render.Deinitialize();
+    if (m_omx_decoder.IsInitialized())
+      m_omx_decoder.Deinitialize();
+  }
   pthread_mutex_destroy(&m_omx_output_mutex);
-  sem_destroy(m_omx_decoder_state_change);
-  free(m_omx_decoder_state_change);
 }
 
-bool COpenMaxVideo::Open(CDVDStreamInfo &hints)
+bool COpenMaxVideo::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options)
 {
   #if defined(OMX_DEBUG_VERBOSE)
-  CLog::Log(LOGDEBUG, "%s::%s\n", CLASSNAME, __func__);
+  CLog::Log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
   #endif
 
+  // we always qualify even if DVDFactoryCodec does this too.
+  if (!CSettings::Get().GetBool("videoplayer.useomx") || hints.software)
+    return false;
+
   OMX_ERRORTYPE omx_err = OMX_ErrorNone;
-  std::string decoder_name;
 
   m_decoded_width  = hints.width;
   m_decoded_height = hints.height;
 
+  m_egl_display = g_Windowing.GetEGLDisplay();
+  m_egl_context = g_Windowing.GetEGLContext();
+  m_egl_buffer_count = 4;
+
+  m_codingType = OMX_VIDEO_CodingUnused;
+
   switch (hints.codec)
   {
     case AV_CODEC_ID_H264:
-    {
-      switch(hints.profile)
-      {
-        case FF_PROFILE_H264_BASELINE:
-          // (role name) video_decoder.avc
-          // H.264 Baseline profile
-          decoder_name = OMX_H264BASE_DECODER;
-        break;
-        case FF_PROFILE_H264_MAIN:
-          // (role name) video_decoder.avc
-          // H.264 Main profile
-          decoder_name = OMX_H264MAIN_DECODER;
-        break;
-        case FF_PROFILE_H264_HIGH:
-          // (role name) video_decoder.avc
-          // H.264 Main profile
-          decoder_name = OMX_H264HIGH_DECODER;
-        break;
-        default:
-          return false;
-        break;
-      }
-    }
+      // H.264
+      m_codingType = OMX_VIDEO_CodingAVC;
+      m_pFormatName = "omx-h264";
     break;
+    case AV_CODEC_ID_H263:
     case AV_CODEC_ID_MPEG4:
-      // (role name) video_decoder.mpeg4
-      // MPEG-4, DivX 4/5 and Xvid compatible
-      decoder_name = OMX_MPEG4_DECODER;
-    break;
-    /*
-    TODO: what mpeg4 formats are "ext" ????
-    case NvxStreamType_MPEG4Ext:
-      // (role name) video_decoder.mpeg4
       // MPEG-4, DivX 4/5 and Xvid compatible
-      decoder_name = OMX_MPEG4EXT_DECODER;
+      m_codingType = OMX_VIDEO_CodingMPEG4;
       m_pFormatName = "omx-mpeg4";
     break;
-    */
+    case AV_CODEC_ID_MPEG1VIDEO:
     case AV_CODEC_ID_MPEG2VIDEO:
-      // (role name) video_decoder.mpeg2
       // MPEG-2
-      decoder_name = OMX_MPEG2V_DECODER;
+      m_codingType = OMX_VIDEO_CodingMPEG2;
+      m_pFormatName = "omx-mpeg2";
+    break;
+    case AV_CODEC_ID_VP6:
+      // this form is encoded upside down
+      // fall through
+    case AV_CODEC_ID_VP6F:
+    case AV_CODEC_ID_VP6A:
+      // VP6
+      m_codingType = OMX_VIDEO_CodingVP6;
+      m_pFormatName = "omx-vp6";
+    break;
+    case AV_CODEC_ID_VP8:
+      // VP8
+      m_codingType = OMX_VIDEO_CodingVP8;
+      m_pFormatName = "omx-vp8";
+    break;
+    case AV_CODEC_ID_THEORA:
+      // theora
+      m_codingType = OMX_VIDEO_CodingTheora;
+      m_pFormatName = "omx-theora";
+    break;
+    case AV_CODEC_ID_MJPEG:
+    case AV_CODEC_ID_MJPEGB:
+      // mjpg
+      m_codingType = OMX_VIDEO_CodingMJPEG;
+      m_pFormatName = "omx-mjpg";
     break;
     case AV_CODEC_ID_VC1:
-      // (role name) video_decoder.vc1
+    case AV_CODEC_ID_WMV3:
       // VC-1, WMV9
-      decoder_name = OMX_VC1_DECODER;
-    break;
+      m_codingType = OMX_VIDEO_CodingWMV;
+      m_pFormatName = "omx-vc1";
+      break;
     default:
+      CLog::Log(LOGERROR, "%s::%s : Video codec unknown: %x", CLASSNAME, __func__, hints.codec);
       return false;
     break;
   }
 
   // initialize OpenMAX.
-  if (!Initialize(decoder_name))
+  if (!m_omx_decoder.Initialize("OMX.broadcom.video_decode", OMX_IndexParamVideoInit))
   {
+    CLog::Log(LOGERROR, "%s::%s error m_omx_decoder.Initialize", CLASSNAME, __func__);
     return false;
   }
 
-  // TODO: Find component from role name.
-  // Get the port information. This will obtain information about the
-  // number of ports and index of the first port.
-  OMX_PORT_PARAM_TYPE port_param;
-  OMX_INIT_STRUCTURE(port_param);
-  omx_err = OMX_GetParameter(m_omx_decoder, OMX_IndexParamVideoInit, &port_param);
-  if (omx_err)
+  omx_err = m_omx_decoder.SetStateForComponent(OMX_StateIdle);
+  if (omx_err != OMX_ErrorNone)
   {
-    Deinitialize();
+    CLog::Log(LOGERROR, "%s::%s m_omx_decoder.SetStateForComponent omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
     return false;
   }
-  m_omx_input_port = port_param.nStartPortNumber;
-  m_omx_output_port = m_omx_input_port + 1;
-  #if defined(OMX_DEBUG_VERBOSE)
-  CLog::Log(LOGDEBUG,
-    "%s::%s - decoder_component(0x%p), input_port(0x%x), output_port(0x%x)\n",
-    CLASSNAME, __func__, m_omx_decoder, m_omx_input_port, m_omx_output_port);
-  #endif
 
-  // TODO: Set role for the component because components could have multiple roles.
-  //QueryCodec();
+  OMX_VIDEO_PARAM_PORTFORMATTYPE formatType;
+  OMX_INIT_STRUCTURE(formatType);
+  formatType.nPortIndex = m_omx_decoder.GetInputPort();
+  formatType.eCompressionFormat = m_codingType;
+
+  omx_err = m_omx_decoder.SetParameter(OMX_IndexParamVideoPortFormat, &formatType);
+  if (omx_err != OMX_ErrorNone)
+  {
+    CLog::Log(LOGERROR, "%s::%s m_omx_decoder.SetParameter omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+    return false;
+  }
+  OMX_PARAM_PORTDEFINITIONTYPE portParam;
+  OMX_INIT_STRUCTURE(portParam);
+  portParam.nPortIndex = m_omx_decoder.GetInputPort();
+
+  omx_err = m_omx_decoder.GetParameter(OMX_IndexParamPortDefinition, &portParam);
+  if (omx_err != OMX_ErrorNone)
+  {
+    CLog::Log(LOGERROR, "%s::%s error OMX_IndexParamPortDefinition omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+    return false;
+  }
+
+  portParam.nPortIndex = m_omx_decoder.GetInputPort();
+  portParam.nBufferCountActual = 20;
+  portParam.format.video.nFrameWidth  = m_decoded_width;
+  portParam.format.video.nFrameHeight = m_decoded_height;
+
+  omx_err = m_omx_decoder.SetParameter(OMX_IndexParamPortDefinition, &portParam);
+  if (omx_err != OMX_ErrorNone)
+  {
+    CLog::Log(LOGERROR, "%s::%s error OMX_IndexParamPortDefinition omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+    return false;
+  }
+
+  // request portsettingschanged on aspect ratio change
+  OMX_CONFIG_REQUESTCALLBACKTYPE notifications;
+  OMX_INIT_STRUCTURE(notifications);
+  notifications.nPortIndex = m_omx_decoder.GetOutputPort();
+  notifications.nIndex = OMX_IndexParamBrcmPixelAspectRatio;
+  notifications.bEnable = OMX_TRUE;
+
+  omx_err = m_omx_decoder.SetParameter((OMX_INDEXTYPE)OMX_IndexConfigRequestCallback, &notifications);
+  if (omx_err != OMX_ErrorNone)
+  {
+    CLog::Log(LOGERROR, "%s::%s OMX_IndexConfigRequestCallback error (0%08x)", CLASSNAME, __func__, omx_err);
+    return false;
+  }
+
+  if (NaluFormatStartCodes(hints.codec, (uint8_t *)hints.extradata, hints.extrasize))
+  {
+    OMX_NALSTREAMFORMATTYPE nalStreamFormat;
+    OMX_INIT_STRUCTURE(nalStreamFormat);
+    nalStreamFormat.nPortIndex = m_omx_decoder.GetInputPort();
+    nalStreamFormat.eNaluFormat = OMX_NaluFormatStartCodes;
+
+    omx_err = m_omx_decoder.SetParameter((OMX_INDEXTYPE)OMX_IndexParamNalStreamFormatSelect, &nalStreamFormat);
+    if (omx_err != OMX_ErrorNone)
+    {
+      CLog::Log(LOGERROR, "%s::%s OMX_IndexParamNalStreamFormatSelect error (0%08x)", CLASSNAME, __func__, omx_err);
+      return false;
+    }
+  }
 
-  // Component will be in OMX_StateLoaded now so we can alloc omx input/output buffers.
-  // we can only alloc them in OMX_StateLoaded state or if the component port is disabled
   // Alloc buffers for the omx input port.
-  omx_err = AllocOMXInputBuffers();
-  if (omx_err)
+  omx_err = m_omx_decoder.AllocInputBuffers();
+  if (omx_err != OMX_ErrorNone)
   {
-    Deinitialize();
+    CLog::Log(LOGERROR, "%s::%s AllocInputBuffers error (0%08x)", CLASSNAME, __func__, omx_err);
     return false;
   }
-  // Alloc buffers for the omx output port.
-  m_egl_display = g_Windowing.GetEGLDisplay();
-  m_egl_context = g_Windowing.GetEGLContext();
-  omx_err = AllocOMXOutputBuffers();
-  if (omx_err)
+
+  omx_err = m_omx_decoder.SetStateForComponent(OMX_StateExecuting);
+  if (omx_err != OMX_ErrorNone)
   {
-    FreeOMXInputBuffers(false);
-    Deinitialize();
+    CLog::Log(LOGERROR, "%s::%s error m_omx_decoder.SetStateForComponent error (0%08x)", CLASSNAME, __func__, omx_err);
     return false;
   }
 
-  m_is_open = true;
-  m_drop_state = false;
-  m_videoplayback_done = false;
+  if (!SendDecoderConfig((uint8_t *)hints.extradata, hints.extrasize))
+    return false;
 
-  // crank it up.
-  StartDecoder();
+  m_drop_state = false;
 
   return true;
 }
 
-void COpenMaxVideo::Close()
+void COpenMaxVideo::Dispose()
 {
   #if defined(OMX_DEBUG_VERBOSE)
-  CLog::Log(LOGDEBUG, "%s::%s\n", CLASSNAME, __func__);
+  CLog::Log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
   #endif
-  if (m_omx_decoder)
-  {
-    if (m_omx_decoder_state != OMX_StateLoaded)
-      StopDecoder();
-    Deinitialize();
-  }
-  m_is_open = false;
 }
 
 void COpenMaxVideo::SetDropState(bool bDrop)
 {
+#if defined(OMX_DEBUG_VERBOSE)
+  if (m_drop_state != bDrop)
+    CLog::Log(LOGDEBUG, "%s::%s - m_drop_state(%d)",
+      CLASSNAME, __func__, bDrop);
+#endif
   m_drop_state = bDrop;
+}
 
-  if (m_drop_state)
+bool COpenMaxVideo::SendDecoderConfig(uint8_t *extradata, int extrasize)
+{
+  OMX_ERRORTYPE omx_err   = OMX_ErrorNone;
+
+  /* send decoder config */
+  if (extrasize > 0 && extradata != NULL)
   {
-    OMX_ERRORTYPE omx_err;
+    OMX_BUFFERHEADERTYPE *omx_buffer = m_omx_decoder.GetInputBuffer();
 
-    // blow all but the last ready video frame
-    pthread_mutex_lock(&m_omx_output_mutex);
-    while (m_omx_output_ready.size() > 1)
+    if (omx_buffer == NULL)
     {
-      m_dts_queue.pop();
-      OMX_BUFFERHEADERTYPE *omx_buffer = m_omx_output_ready.front()->omx_buffer;
-      m_omx_output_ready.pop();
-      // return the omx buffer back to OpenMax to fill.
-      omx_err = OMX_FillThisBuffer(m_omx_decoder, omx_buffer);
-      if (omx_err)
-        CLog::Log(LOGERROR, "%s::%s - OMX_FillThisBuffer, omx_err(0x%x)\n",
-          CLASSNAME, __func__, omx_err);
+      CLog::Log(LOGERROR, "%s::%s - buffer error 0x%08x", CLASSNAME, __func__, omx_err);
+      return false;
     }
-    pthread_mutex_unlock(&m_omx_output_mutex);
 
-    #if defined(OMX_DEBUG_VERBOSE)
-    CLog::Log(LOGDEBUG, "%s::%s - m_drop_state(%d)\n",
-      CLASSNAME, __func__, m_drop_state);
-    #endif
+    omx_buffer->nOffset = 0;
+    omx_buffer->nFilledLen = extrasize;
+    if (omx_buffer->nFilledLen > omx_buffer->nAllocLen)
+    {
+      CLog::Log(LOGERROR, "%s::%s - omx_buffer->nFilledLen > omx_buffer->nAllocLen", CLASSNAME, __func__);
+      return false;
+    }
+
+    memcpy((unsigned char *)omx_buffer->pBuffer, extradata, omx_buffer->nFilledLen);
+    omx_buffer->nFlags = OMX_BUFFERFLAG_CODECCONFIG | OMX_BUFFERFLAG_ENDOFFRAME;
+
+//CLog::Log(LOGINFO, "%s::%s - Empty(%d,%x)", CLASSNAME, __func__, omx_buffer->nFilledLen, omx_buffer->nFlags); CLog::MemDump((char *)omx_buffer->pBuffer, std::min(64U, omx_buffer->nFilledLen));
+    omx_err = m_omx_decoder.EmptyThisBuffer(omx_buffer);
+    if (omx_err != OMX_ErrorNone)
+    {
+      CLog::Log(LOGERROR, "%s::%s - OMX_EmptyThisBuffer() failed with result(0x%x)", CLASSNAME, __func__, omx_err);
+      return false;
+    }
   }
+  return true;
 }
 
-int COpenMaxVideo::Decode(uint8_t* pData, int iSize, double dts, double pts)
+bool COpenMaxVideo::NaluFormatStartCodes(enum AVCodecID codec, uint8_t *extradata, int extrasize)
+{
+  switch(codec)
+  {
+    case AV_CODEC_ID_H264:
+      if (extrasize < 7 || extradata == NULL)
+        return true;
+      // valid avcC atom data always starts with the value 1 (version), otherwise annexb
+      else if ( *extradata != 1 )
+        return true;
+    default: break;
+  }
+  return false;
+}
+
+bool COpenMaxVideo::PortSettingsChanged()
 {
-  if (pData)
+  OMX_ERRORTYPE omx_err   = OMX_ErrorNone;
+
+  if (m_port_settings_changed)
+  {
+    m_omx_decoder.DisablePort(m_omx_decoder.GetOutputPort(), true);
+  }
+
+  OMX_PARAM_PORTDEFINITIONTYPE port_def;
+  OMX_INIT_STRUCTURE(port_def);
+  port_def.nPortIndex = m_omx_decoder.GetOutputPort();
+  omx_err = m_omx_decoder.GetParameter(OMX_IndexParamPortDefinition, &port_def);
+  if (omx_err != OMX_ErrorNone)
+  {
+    CLog::Log(LOGERROR, "%s::%s - error m_omx_decoder.GetParameter(OMX_IndexParamPortDefinition) omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+    return false;
+  }
+
+  OMX_CONFIG_POINTTYPE pixel_aspect;
+  OMX_INIT_STRUCTURE(pixel_aspect);
+  pixel_aspect.nPortIndex = m_omx_decoder.GetOutputPort();
+  omx_err = m_omx_decoder.GetParameter(OMX_IndexParamBrcmPixelAspectRatio, &pixel_aspect);
+  if (omx_err != OMX_ErrorNone)
+  {
+    CLog::Log(LOGERROR, "%s::%s - error m_omx_decoder.GetParameter(OMX_IndexParamBrcmPixelAspectRatio) omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+    return false;
+  }
+
+  if (m_port_settings_changed)
   {
-    int demuxer_bytes = iSize;
-    uint8_t *demuxer_content = pData;
+    m_omx_decoder.EnablePort(m_omx_decoder.GetOutputPort(), true);
+    return true;
+  }
+
+  // convert in stripes
+  port_def.format.video.nSliceHeight = 16;
+  port_def.format.video.nStride = 0;
+
+  omx_err = m_omx_decoder.SetParameter(OMX_IndexParamPortDefinition, &port_def);
+  if (omx_err != OMX_ErrorNone)
+  {
+    CLog::Log(LOGERROR, "%s::%s m_omx_decoder.SetParameter result(0x%x)", CLASSNAME, __func__, omx_err);
+    return false;
+  }
+
+  OMX_CALLBACKTYPE callbacks = { NULL, NULL, DecoderFillBufferDoneCallback };
+  if (!m_omx_egl_render.Initialize("OMX.broadcom.egl_render", OMX_IndexParamVideoInit, &callbacks))
+  {
+    CLog::Log(LOGERROR, "%s::%s error m_omx_egl_render.Initialize", CLASSNAME, __func__);
+    return false;
+  }
+
+  OMX_CONFIG_PORTBOOLEANTYPE discardMode;
+  OMX_INIT_STRUCTURE(discardMode);
+  discardMode.nPortIndex = m_omx_egl_render.GetInputPort();
+  discardMode.bEnabled = OMX_FALSE;
+  omx_err = m_omx_egl_render.SetParameter(OMX_IndexParamBrcmVideoEGLRenderDiscardMode, &discardMode);
+  if (omx_err != OMX_ErrorNone)
+  {
+    CLog::Log(LOGERROR, "%s::%s - error m_omx_egl_render.SetParameter(OMX_IndexParamBrcmVideoEGLRenderDiscardMode) omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+    return false;
+  }
+
+  m_omx_egl_render.ResetEos();
+
+  CLog::Log(LOGDEBUG, "%s::%s - %dx%d@%.2f interlace:%d deinterlace:%d", CLASSNAME, __func__,
+      port_def.format.video.nFrameWidth, port_def.format.video.nFrameHeight,
+      port_def.format.video.xFramerate / (float)(1<<16), 0,0);
+
+  m_omx_tunnel.Initialize(&m_omx_decoder, m_omx_decoder.GetOutputPort(), &m_omx_egl_render, m_omx_egl_render.GetInputPort());
+
+  omx_err = m_omx_tunnel.Establish();
+  if (omx_err != OMX_ErrorNone)
+  {
+    CLog::Log(LOGERROR, "%s::%s - m_omx_tunnel.Establish omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+    return false;
+  }
+
+  // Obtain the information about the output port.
+  OMX_PARAM_PORTDEFINITIONTYPE port_format;
+  OMX_INIT_STRUCTURE(port_format);
+  port_format.nPortIndex = m_omx_egl_render.GetOutputPort();
+  omx_err = m_omx_egl_render.GetParameter(OMX_IndexParamPortDefinition, &port_format);
+  if (omx_err != OMX_ErrorNone)
+    CLog::Log(LOGERROR, "%s::%s - m_omx_egl_render.GetParameter OMX_IndexParamPortDefinition omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+
+  port_format.nBufferCountActual = m_egl_buffer_count;
+  omx_err = m_omx_egl_render.SetParameter(OMX_IndexParamPortDefinition, &port_format);
+  if (omx_err != OMX_ErrorNone)
+    CLog::Log(LOGERROR, "%s::%s - m_omx_egl_render.SetParameter OMX_IndexParamPortDefinition omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+
+  #if defined(OMX_DEBUG_VERBOSE)
+  CLog::Log(LOGDEBUG,
+    "%s::%s (1) - oport(%d), nFrameWidth(%u), nFrameHeight(%u), nStride(%x), nBufferCountMin(%u), nBufferCountActual(%u), nBufferSize(%u)",
+    CLASSNAME, __func__, m_omx_egl_render.GetOutputPort(),
+    port_format.format.video.nFrameWidth, port_format.format.video.nFrameHeight,port_format.format.video.nStride,
+    port_format.nBufferCountMin, port_format.nBufferCountActual, port_format.nBufferSize);
+  #endif
+
 
-    // we need to queue then de-queue the demux packet, seems silly but
-    // omx might not have a omx input buffer avaliable when we are called
-    // and we must store the demuxer packet and try again later.
+  omx_err =  m_omx_egl_render.EnablePort(m_omx_egl_render.GetOutputPort(), false);
+  if (omx_err != OMX_ErrorNone)
+  {
+    CLog::Log(LOGERROR, "%s::%s - m_omx_egl_render.EnablePort omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+    return false;
+  }
+
+  if (!AllocOMXOutputBuffers())
+  {
+    CLog::Log(LOGERROR, "%s::%s - AllocOMXOutputBuffers failed", CLASSNAME, __func__);
+    return false;
+  }
+
+  omx_err = m_omx_egl_render.WaitForCommand(OMX_CommandPortEnable, m_omx_egl_render.GetOutputPort());
+  if (omx_err != OMX_ErrorNone)
+  {
+    CLog::Log(LOGERROR, "%s::%s m_omx_egl_render.WaitForCommand(OMX_CommandPortEnable) omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+    return false;
+  }
+
+  assert(m_omx_output_busy.empty());
+  assert(m_omx_output_ready.empty());
+
+  omx_err = m_omx_egl_render.SetStateForComponent(OMX_StateExecuting);
+  if (omx_err != OMX_ErrorNone)
+  {
+    CLog::Log(LOGERROR, "%s::%s - m_omx_egl_render.SetStateForComponent omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+    return false;
+  }
+
+  omx_err = PrimeFillBuffers();
+  if (omx_err != OMX_ErrorNone)
+  {
+    CLog::Log(LOGERROR, "%s::%s - m_omx_egl_render.PrimeFillBuffers omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+    return false;
+  }
+
+  m_port_settings_changed = true;
+  return true;
+}
+
+
+int COpenMaxVideo::Decode(uint8_t* pData, int iSize, double dts, double pts)
+{
+  #if defined(OMX_DEBUG_VERBOSE)
+  CLog::Log(LOGDEBUG, "%s::%s - %-8p %-6d dts:%.3f pts:%.3f demux_queue(%d) dts_queue(%d) ready_queue(%d) busy_queue(%d)",
+     CLASSNAME, __func__, pData, iSize, dts == DVD_NOPTS_VALUE ? 0.0 : dts*1e-6, pts == DVD_NOPTS_VALUE ? 0.0 : pts*1e-6, m_demux_queue.size(), m_dts_queue.size(), m_omx_output_ready.size(), m_omx_output_busy.size());
+  #endif
+
+  OMX_ERRORTYPE omx_err;
+  unsigned int demuxer_bytes = 0;
+  uint8_t *demuxer_content = NULL;
+
+  // we need to queue then de-queue the demux packet, seems silly but
+  // omx might not have a omx input buffer available when we are called
+  // and we must store the demuxer packet and try again later.
+  if (pData && m_demux_queue.empty() && m_omx_decoder.GetInputBufferSpace() >= (unsigned int)iSize)
+  {
+    demuxer_bytes = iSize;
+    demuxer_content = pData;
+  }
+  else if (pData && iSize)
+  {
     omx_demux_packet demux_packet;
     demux_packet.dts = dts;
     demux_packet.pts = pts;
-
-    demux_packet.size = demuxer_bytes;
-    demux_packet.buff = new OMX_U8[demuxer_bytes];
-    memcpy(demux_packet.buff, demuxer_content, demuxer_bytes);
+    demux_packet.size = iSize;
+    demux_packet.buff = new OMX_U8[iSize];
+    memcpy(demux_packet.buff, pData, iSize);
     m_demux_queue.push(demux_packet);
+  }
 
-    // we can look at m_omx_input_avaliable.empty without needing to lock/unlock
+  OMX_U8 *buffer_to_free = NULL;
+  while (1)
+  {
     // try to send any/all demux packets to omx decoder.
-    while (!m_omx_input_avaliable.empty() && !m_demux_queue.empty() )
+    if (!demuxer_bytes && !m_demux_queue.empty())
     {
-      OMX_ERRORTYPE omx_err;
-      OMX_BUFFERHEADERTYPE* omx_buffer;
-
-      demux_packet = m_demux_queue.front();
-      m_demux_queue.pop();
-      // need to lock here to retreve an input buffer and pop the queue
-      pthread_mutex_lock(&m_omx_input_mutex);
-      omx_buffer = m_omx_input_avaliable.front();
-      m_omx_input_avaliable.pop();
-      pthread_mutex_unlock(&m_omx_input_mutex);
-
-      // delete the previous demuxer buffer
-      delete [] omx_buffer->pBuffer;
-      // setup a new omx_buffer.
-      omx_buffer->nFlags  = m_omx_input_eos ? OMX_BUFFERFLAG_EOS : 0;
+      omx_demux_packet &demux_packet = m_demux_queue.front();
+      if (m_omx_decoder.GetInputBufferSpace() >= (unsigned int)demux_packet.size)
+      {
+        // need to lock here to retrieve an input buffer and pop the queue
+        m_demux_queue.pop();
+        demuxer_bytes = (unsigned int)demux_packet.size;
+        demuxer_content = demux_packet.buff;
+        buffer_to_free = demux_packet.buff;
+        dts = demux_packet.dts;
+        pts = demux_packet.pts;
+      }
+    }
+
+    if (demuxer_content)
+    {
+      // 500ms timeout
+      OMX_BUFFERHEADERTYPE *omx_buffer = m_omx_decoder.GetInputBuffer(500);
+      if (omx_buffer == NULL)
+      {
+        CLog::Log(LOGERROR, "%s::%s - m_omx_decoder.GetInputBuffer timeout", CLASSNAME, __func__);
+        return VC_ERROR;
+      }
+      #if defined(OMX_DEBUG_VERBOSE)
+      //CLog::Log(LOGDEBUG, "%s::%s - omx_buffer=%p", CLASSNAME, __func__, omx_buffer);
+      #endif
+      omx_buffer->nFlags  = 0;
       omx_buffer->nOffset = 0;
-      omx_buffer->pBuffer = demux_packet.buff;
-      omx_buffer->nAllocLen  = demux_packet.size;
-      omx_buffer->nFilledLen = demux_packet.size;
-      omx_buffer->nTimeStamp = (demux_packet.pts == DVD_NOPTS_VALUE) ? 0 : demux_packet.pts * 1000.0; // in microseconds;
+
+      omx_buffer->nFilledLen = (demuxer_bytes > omx_buffer->nAllocLen) ? omx_buffer->nAllocLen : demuxer_bytes;
+      omx_buffer->nTimeStamp = ToOMXTime((uint64_t)(pts == DVD_NOPTS_VALUE) ? 0 : pts);
       omx_buffer->pAppPrivate = omx_buffer;
-      omx_buffer->nInputPortIndex = m_omx_input_port;
+      memcpy(omx_buffer->pBuffer, demuxer_content, omx_buffer->nFilledLen);
 
-      #if defined(OMX_DEBUG_EMPTYBUFFERDONE)
-      CLog::Log(LOGDEBUG,
-        "%s::%s - feeding decoder, omx_buffer->pBuffer(0x%p), demuxer_bytes(%d)\n",
-        CLASSNAME, __func__, omx_buffer->pBuffer, demuxer_bytes);
-      #endif
-      // Give this omx_buffer to OpenMax to be decoded.
-      omx_err = OMX_EmptyThisBuffer(m_omx_decoder, omx_buffer);
-      if (omx_err)
+      demuxer_bytes -= omx_buffer->nFilledLen;
+      demuxer_content += omx_buffer->nFilledLen;
+
+      if (demuxer_bytes == 0)
+        omx_buffer->nFlags |= OMX_BUFFERFLAG_ENDOFFRAME;
+      if (pts == DVD_NOPTS_VALUE)
+        omx_buffer->nFlags |= OMX_BUFFERFLAG_TIME_UNKNOWN;
+      if (m_drop_state) // hijack an omx flag to signal this frame to be dropped - it will be returned with the picture (but otherwise ignored)
+        omx_buffer->nFlags |= OMX_BUFFERFLAG_DATACORRUPT;
+
+#if defined(OMX_DEBUG_VERBOSE)
+      CLog::Log(LOGDEBUG, "%s::%s - %-6d dts:%.3f pts:%.3f flags:%x",
+        CLASSNAME, __func__, omx_buffer->nFilledLen, dts == DVD_NOPTS_VALUE ? 0.0 : dts*1e-6, pts == DVD_NOPTS_VALUE ? 0.0 : pts*1e-6, omx_buffer->nFlags);
+#endif
+
+      omx_err = m_omx_decoder.EmptyThisBuffer(omx_buffer);
+      if (omx_err != OMX_ErrorNone)
       {
-        CLog::Log(LOGDEBUG,
-          "%s::%s - OMX_EmptyThisBuffer() failed with result(0x%x)\n",
-          CLASSNAME, __func__, omx_err);
+        CLog::Log(LOGERROR, "%s::%s - OMX_EmptyThisBuffer() failed with result(0x%x)", CLASSNAME, __func__, omx_err);
         return VC_ERROR;
       }
-      // only push if we are successful with feeding OMX_EmptyThisBuffer
-      m_dts_queue.push(demux_packet.dts);
-
-      // if m_omx_input_avaliable and/or demux_queue are now empty,
-      // wait up to 20ms for OpenMax to consume a demux packet
-      if (m_omx_input_avaliable.empty() || m_demux_queue.empty())
-        m_input_consumed_event.WaitMSec(1);
+      if (demuxer_bytes == 0)
+      {
+#ifdef DTS_QUEUE
+        // only push if we are successful with feeding OMX_EmptyThisBuffer
+        m_dts_queue.push(dts);
+        assert(m_dts_queue.size() < 32);
+#endif
+        if (buffer_to_free)
+        {
+          delete [] buffer_to_free;
+          buffer_to_free = NULL;
+          demuxer_content = NULL;
+          continue;
+        }
+      }
+    }
+    omx_err = m_omx_decoder.WaitForEvent(OMX_EventPortSettingsChanged, 0);
+    if (omx_err == OMX_ErrorNone)
+    {
+      if (!PortSettingsChanged())
+      {
+        CLog::Log(LOGERROR, "%s::%s - error PortSettingsChanged omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+        return VC_ERROR;
+      }
+    }
+    else if (omx_err != OMX_ErrorTimeout)
+    {
+      CLog::Log(LOGERROR, "%s::%s - video not supported omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+      return VC_ERROR;
     }
-    if (m_omx_input_avaliable.empty() && !m_demux_queue.empty())
-      m_input_consumed_event.WaitMSec(1);
-
-    #if defined(OMX_DEBUG_VERBOSE)
-    if (m_omx_input_avaliable.empty())
-      CLog::Log(LOGDEBUG,
-        "%s::%s - buffering demux, m_demux_queue_size(%d), demuxer_bytes(%d)\n",
-        CLASSNAME, __func__, m_demux_queue.size(), demuxer_bytes);
-    #endif
+    omx_err = m_omx_decoder.WaitForEvent(OMX_EventParamOrConfigChanged, 0);
+    if (omx_err == OMX_ErrorNone)
+    {
+      if (!PortSettingsChanged())
+      {
+        CLog::Log(LOGERROR, "%s::%s - error PortSettingsChanged (EventParamOrConfigChanged) omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+        return VC_ERROR;
+      }
+    }
+    else if (omx_err == OMX_ErrorStreamCorrupt)
+    {
+      CLog::Log(LOGERROR, "%s::%s - video not supported 2 omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+      return VC_ERROR;
+    }
+    if (!demuxer_bytes)
+      break;
   }
 
+#if defined(OMX_DEBUG_VERBOSE)
+  if (!m_omx_decoder.GetInputBufferSpace())
+    CLog::Log(LOGDEBUG,
+      "%s::%s - buffering demux, m_demux_queue_size(%d), demuxer_bytes(%d) m_dts_queue.size(%d)",
+      CLASSNAME, __func__, m_demux_queue.size(), demuxer_bytes, m_dts_queue.size());
+  #endif
+
   if (m_omx_output_ready.empty())
+  {
+    //CLog::Log(LOGDEBUG, "%s::%s - empty: buffers:%d", CLASSNAME, __func__, m_omx_output_ready.size());
     return VC_BUFFER;
+  }
 
-  return VC_PICTURE | VC_BUFFER;
+  //CLog::Log(LOGDEBUG, "%s::%s -  full: buffers:%d", CLASSNAME, __func__, m_omx_output_ready.size());
+  return VC_PICTURE;
 }
 
 void COpenMaxVideo::Reset(void)
 {
   #if defined(OMX_DEBUG_VERBOSE)
-  CLog::Log(LOGDEBUG, "%s::%s\n", CLASSNAME, __func__);
+  CLog::Log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
   #endif
-/*
-  // only reset OpenMax decoder if it's running
-  if (m_omx_decoder_state == OMX_StateExecuting)
+  m_omx_egl_render.FlushAll();
+  m_omx_decoder.FlushAll();
+  // blow all ready video frames
+  while (!m_omx_output_ready.empty())
   {
-    OMX_ERRORTYPE omx_err;
-
-    omx_err = StopDecoder();
-    // Alloc OpenMax input buffers.
-    omx_err = AllocOMXInputBuffers();
-    // Alloc OpenMax output buffers.
-    omx_err = AllocOMXOutputBuffers();
-
-    omx_err = StartDecoder();
+    pthread_mutex_lock(&m_omx_output_mutex);
+    COpenMaxVideoBuffer *pic = m_omx_output_ready.front();
+    m_omx_output_ready.pop();
+    pthread_mutex_unlock(&m_omx_output_mutex);
+    // return the omx buffer back to OpenMax to fill.
+    ReturnOpenMaxBuffer(pic);
   }
-*/
-  ::Sleep(100);
+#ifdef DTS_QUEUE
+  while (!m_dts_queue.empty())
+    m_dts_queue.pop();
+#endif
+
+  while (!m_demux_queue.empty())
+    m_demux_queue.pop();
 }
 
-bool COpenMaxVideo::GetPicture(DVDVideoPicture* pDvdVideoPicture)
+
+OMX_ERRORTYPE COpenMaxVideo::ReturnOpenMaxBuffer(COpenMaxVideoBuffer *buffer)
 {
-  while (m_omx_output_busy.size() > 1)
+  OMX_ERRORTYPE omx_err = OMX_ErrorNone;
+#if defined(OMX_DEBUG_VERBOSE)
+  CLog::Log(LOGDEBUG, "%s::%s %p (%d)", CLASSNAME, __func__, buffer, m_omx_output_busy.size());
+#endif
+  bool done = buffer->omx_buffer->nFlags & OMX_BUFFERFLAG_EOS;
+  if (!done)
   {
-    // fetch a output buffer and pop it off the busy list
-    pthread_mutex_lock(&m_omx_output_mutex);
-    OpenMaxVideoBuffer *buffer = m_omx_output_busy.front();
-    m_omx_output_busy.pop();
-    pthread_mutex_unlock(&m_omx_output_mutex);
+    // return the omx buffer back to OpenMax to fill.
+    buffer->omx_buffer->nFlags = 0;
+    buffer->omx_buffer->nFilledLen = 0;
 
-    bool done = buffer->omx_buffer->nFlags & OMX_BUFFERFLAG_EOS;
-    if (!done)
-    {
-      // return the omx buffer back to OpenMax to fill.
-      OMX_ERRORTYPE omx_err = OMX_FillThisBuffer(m_omx_decoder, buffer->omx_buffer);
-      if (omx_err)
-        CLog::Log(LOGERROR, "%s::%s - OMX_FillThisBuffer, omx_err(0x%x)\n",
-          CLASSNAME, __func__, omx_err);
-    }
+    assert(buffer->omx_buffer->nOutputPortIndex == m_omx_egl_render.GetOutputPort());
+#if defined(OMX_DEBUG_VERBOSE)
+    CLog::Log(LOGDEBUG, "%s::%s FillThisBuffer(%p) %p->%ld", CLASSNAME, __func__, buffer, buffer->omx_buffer, buffer->m_refs);
+#endif
+    OMX_ERRORTYPE omx_err = m_omx_egl_render.FillThisBuffer(buffer->omx_buffer);
+
+    if (omx_err)
+      CLog::Log(LOGERROR, "%s::%s - OMX_FillThisBuffer, omx_err(0x%x)", CLASSNAME, __func__, omx_err);
   }
+  return omx_err;
+}
+
+void COpenMaxVideo::ReleaseOpenMaxBuffer(COpenMaxVideoBuffer *buffer)
+{
+  // remove from busy list
+  pthread_mutex_lock(&m_omx_output_mutex);
+  m_omx_output_busy.erase(std::remove(m_omx_output_busy.begin(), m_omx_output_busy.end(), buffer), m_omx_output_busy.end());
+  pthread_mutex_unlock(&m_omx_output_mutex);
+  ReturnOpenMaxBuffer(buffer);
+}
+
+bool COpenMaxVideo::GetPicture(DVDVideoPicture* pDvdVideoPicture)
+{
+  //CLog::Log(LOGDEBUG, "%s::%s - m_omx_output_busy.size()=%d m_omx_output_ready.size()=%d", CLASSNAME, __func__, m_omx_output_busy.size(), m_omx_output_ready.size());
+  //CLog::Log(LOGDEBUG, "%s::%s -  full: buffers:%d", CLASSNAME, __func__, m_omx_output_ready.size());
 
   if (!m_omx_output_ready.empty())
   {
-    OpenMaxVideoBuffer *buffer;
+    COpenMaxVideoBuffer *buffer;
     // fetch a output buffer and pop it off the ready list
     pthread_mutex_lock(&m_omx_output_mutex);
     buffer = m_omx_output_ready.front();
     m_omx_output_ready.pop();
-    m_omx_output_busy.push(buffer);
+    m_omx_output_busy.push_back(buffer);
     pthread_mutex_unlock(&m_omx_output_mutex);
 
+    memset(pDvdVideoPicture, 0, sizeof *pDvdVideoPicture);
     pDvdVideoPicture->dts = DVD_NOPTS_VALUE;
     pDvdVideoPicture->pts = DVD_NOPTS_VALUE;
     pDvdVideoPicture->format = RENDER_FMT_OMXEGL;
-    pDvdVideoPicture->openMax = this;
     pDvdVideoPicture->openMaxBuffer = buffer;
-
+    pDvdVideoPicture->color_range  = 0;
+    pDvdVideoPicture->color_matrix = 4;
+    pDvdVideoPicture->iWidth  = m_decoded_width;
+    pDvdVideoPicture->iHeight = m_decoded_height;
+    pDvdVideoPicture->iDisplayWidth  = m_decoded_width;
+    pDvdVideoPicture->iDisplayHeight = m_decoded_height;
+
+#ifdef DTS_QUEUE
     if (!m_dts_queue.empty())
     {
       pDvdVideoPicture->dts = m_dts_queue.front();
       m_dts_queue.pop();
     }
+#endif
     // nTimeStamp is in microseconds
-    pDvdVideoPicture->pts = (buffer->omx_buffer->nTimeStamp == 0) ? DVD_NOPTS_VALUE : (double)buffer->omx_buffer->nTimeStamp / 1000.0;
+    double ts = FromOMXTime(buffer->omx_buffer->nTimeStamp);
+    pDvdVideoPicture->pts = (ts == 0) ? DVD_NOPTS_VALUE : ts;
+    pDvdVideoPicture->openMaxBuffer->Acquire();
+    pDvdVideoPicture->iFlags  = DVP_FLAG_ALLOCATED;
+    if (buffer->omx_buffer->nFlags & OMX_BUFFERFLAG_DATACORRUPT)
+      pDvdVideoPicture->iFlags |= DVP_FLAG_DROPPED;
+#if defined(OMX_DEBUG_VERBOSE)
+    CLog::Log(LOGINFO, "%s::%s dts:%.3f pts:%.3f flags:%x:%x openMaxBuffer:%p omx_buffer:%p egl_image:%p texture_id:%x", CLASSNAME, __func__,
+        pDvdVideoPicture->dts == DVD_NOPTS_VALUE ? 0.0 : pDvdVideoPicture->dts*1e-6, pDvdVideoPicture->pts == DVD_NOPTS_VALUE ? 0.0 : pDvdVideoPicture->pts*1e-6,
+        pDvdVideoPicture->iFlags, buffer->omx_buffer->nFlags, pDvdVideoPicture->openMaxBuffer, pDvdVideoPicture->openMaxBuffer->omx_buffer, pDvdVideoPicture->openMaxBuffer->egl_image, pDvdVideoPicture->openMaxBuffer->texture_id);
+#endif
   }
-  #if defined(OMX_DEBUG_VERBOSE)
   else
   {
-    CLog::Log(LOGDEBUG, "%s::%s - called but m_omx_output_ready is empty\n",
-      CLASSNAME, __func__);
+    CLog::Log(LOGERROR, "%s::%s - called but m_omx_output_ready is empty", CLASSNAME, __func__);
+    return false;
   }
-  #endif
-
-  pDvdVideoPicture->iFlags  = DVP_FLAG_ALLOCATED;
-  pDvdVideoPicture->iFlags |= m_drop_state ? DVP_FLAG_DROPPED : 0;
-
   return true;
 }
 
-
-// DecoderEmptyBufferDone -- OpenMax input buffer has been emptied
-OMX_ERRORTYPE COpenMaxVideo::DecoderEmptyBufferDone(
-  OMX_HANDLETYPE hComponent,
-  OMX_PTR pAppData,
-  OMX_BUFFERHEADERTYPE* pBuffer)
+bool COpenMaxVideo::ClearPicture(DVDVideoPicture* pDvdVideoPicture)
 {
-  COpenMaxVideo *ctx = static_cast<COpenMaxVideo*>(pAppData);
-/*
-  #if defined(OMX_DEBUG_EMPTYBUFFERDONE)
-  CLog::Log(LOGDEBUG, "%s::%s - buffer_size(%lu), timestamp(%f)\n",
-    CLASSNAME, __func__, pBuffer->nFilledLen, (double)pBuffer->nTimeStamp / 1000.0);
-  #endif
-*/
-  // queue free input buffer to avaliable list.
-  pthread_mutex_lock(&ctx->m_omx_input_mutex);
-  ctx->m_omx_input_avaliable.push(pBuffer);
-  ctx->m_input_consumed_event.Set();
-  pthread_mutex_unlock(&ctx->m_omx_input_mutex);
-
-  return OMX_ErrorNone;
+#if defined(OMX_DEBUG_VERBOSE)
+  CLog::Log(LOGDEBUG, "%s::%s - %p", CLASSNAME, __func__, pDvdVideoPicture->openMaxBuffer);
+#endif
+  if (pDvdVideoPicture->format == RENDER_FMT_OMXEGL)
+    pDvdVideoPicture->openMaxBuffer->Release();
+  memset(pDvdVideoPicture, 0, sizeof *pDvdVideoPicture);
+  return true;
 }
 
-// DecoderFillBufferDone -- OpenMax output buffer has been filled
+  // DecoderFillBufferDone -- OpenMax output buffer has been filled
 OMX_ERRORTYPE COpenMaxVideo::DecoderFillBufferDone(
   OMX_HANDLETYPE hComponent,
-  OMX_PTR pAppData,
   OMX_BUFFERHEADERTYPE* pBuffer)
 {
-  COpenMaxVideo *ctx = static_cast<COpenMaxVideo*>(pAppData);
-  OpenMaxVideoBuffer *buffer = (OpenMaxVideoBuffer*)pBuffer->pAppPrivate;
+  COpenMaxVideoBuffer *buffer = (COpenMaxVideoBuffer*)pBuffer->pAppPrivate;
 
-  #if defined(OMX_DEBUG_FILLBUFFERDONE)
-  CLog::Log(LOGDEBUG, "%s::%s - buffer_size(%lu), timestamp(%f)\n",
-    CLASSNAME, __func__, pBuffer->nFilledLen, (double)pBuffer->nTimeStamp / 1000.0);
+  #if defined(OMX_DEBUG_VERBOSE)
+  CLog::Log(LOGDEBUG, "%s::%s - %p (%p,%p) buffer_size(%u), pts:%.3f",
+    CLASSNAME, __func__, buffer, pBuffer, buffer->omx_buffer, pBuffer->nFilledLen, (double)FromOMXTime(buffer->omx_buffer->nTimeStamp)*1e-6);
   #endif
 
-  if (!ctx->m_portChanging)
-  {
-    // queue output omx buffer to ready list.
-    pthread_mutex_lock(&ctx->m_omx_output_mutex);
-    ctx->m_omx_output_ready.push(buffer);
-    pthread_mutex_unlock(&ctx->m_omx_output_mutex);
-  }
+  // queue output omx buffer to ready list.
+  pthread_mutex_lock(&m_omx_output_mutex);
+  m_omx_output_ready.push(buffer);
+  pthread_mutex_unlock(&m_omx_output_mutex);
 
   return OMX_ErrorNone;
 }
 
-void COpenMaxVideo::QueryCodec(void)
-{
-  OMX_ERRORTYPE omx_err = OMX_ErrorNone;
-  OMX_VIDEO_PARAM_PROFILELEVELTYPE port_param;
-  OMX_INIT_STRUCTURE(port_param);
-
-  port_param.nPortIndex = m_omx_input_port;
-
-  for (port_param.nProfileIndex = 0;; port_param.nProfileIndex++)
-  {
-    omx_err = OMX_GetParameter(m_omx_decoder,
-      OMX_IndexParamVideoProfileLevelQuerySupported, &port_param);
-    if (omx_err)
-      break;
-
-    omx_codec_capability omx_capability;
-    omx_capability.level = port_param.eLevel;
-    omx_capability.profile = port_param.eProfile;
-    m_omx_decoder_capabilities.push_back(omx_capability);
-  }
-}
-
 OMX_ERRORTYPE COpenMaxVideo::PrimeFillBuffers(void)
 {
   OMX_ERRORTYPE omx_err = OMX_ErrorNone;
-  OpenMaxVideoBuffer *buffer;
+  COpenMaxVideoBuffer *buffer;
 
   #if defined(OMX_DEBUG_VERBOSE)
-  CLog::Log(LOGDEBUG, "%s::%s\n", CLASSNAME, __func__);
+  CLog::Log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
   #endif
   // tell OpenMax to start filling output buffers
   for (size_t i = 0; i < m_omx_output_buffers.size(); i++)
   {
     buffer = m_omx_output_buffers[i];
     // always set the port index.
-    buffer->omx_buffer->nOutputPortIndex = m_omx_output_port;
-    // Need to clear the EOS flag.
-    buffer->omx_buffer->nFlags &= ~OMX_BUFFERFLAG_EOS;
+    buffer->omx_buffer->nOutputPortIndex = m_omx_egl_render.GetOutputPort();
     buffer->omx_buffer->pAppPrivate = buffer;
-
-    omx_err = OMX_FillThisBuffer(m_omx_decoder, buffer->omx_buffer);
-    if (omx_err)
-      CLog::Log(LOGERROR, "%s::%s - OMX_FillThisBuffer failed with omx_err(0x%x)\n",
-        CLASSNAME, __func__, omx_err);
+    omx_err = ReturnOpenMaxBuffer(buffer);
   }
-
   return omx_err;
 }
 
-OMX_ERRORTYPE COpenMaxVideo::AllocOMXInputBuffers(void)
-{
-  OMX_ERRORTYPE omx_err = OMX_ErrorNone;
-
-  // Obtain the information about the decoder input port.
-  OMX_PARAM_PORTDEFINITIONTYPE port_format;
-  OMX_INIT_STRUCTURE(port_format);
-  port_format.nPortIndex = m_omx_input_port;
-  OMX_GetParameter(m_omx_decoder, OMX_IndexParamPortDefinition, &port_format);
-
-  #if defined(OMX_DEBUG_VERBOSE)
-  CLog::Log(LOGDEBUG,
-    "%s::%s - iport(%d), nBufferCountMin(%lu), nBufferSize(%lu)\n",
-    CLASSNAME, __func__, m_omx_input_port, port_format.nBufferCountMin, port_format.nBufferSize);
-  #endif
-  for (size_t i = 0; i < port_format.nBufferCountMin; i++)
-  {
-    OMX_BUFFERHEADERTYPE *buffer = NULL;
-    // use an external buffer that's sized according to actual demux
-    // packet size, start at internal's buffer size, will get deleted when
-    // we start pulling demuxer packets and using demux packet sized buffers.
-    OMX_U8* data = new OMX_U8[port_format.nBufferSize];
-    omx_err = OMX_UseBuffer(m_omx_decoder, &buffer, m_omx_input_port, NULL, port_format.nBufferSize, data);
-    if (omx_err)
-    {
-      CLog::Log(LOGERROR, "%s::%s - OMX_UseBuffer failed with omx_err(0x%x)\n",
-        CLASSNAME, __func__, omx_err);
-      return(omx_err);
-    }
-    m_omx_input_buffers.push_back(buffer);
-    // don't have to lock/unlock here, we are not decoding
-    m_omx_input_avaliable.push(buffer);
-  }
-  m_omx_input_eos = false;
-
-  return(omx_err);
-}
-OMX_ERRORTYPE COpenMaxVideo::FreeOMXInputBuffers(bool wait)
+OMX_ERRORTYPE COpenMaxVideo::FreeOMXInputBuffers(void)
 {
   OMX_ERRORTYPE omx_err = OMX_ErrorNone;
 
-  /*
-  omx_err = OMX_SendCommand(m_omx_decoder, OMX_CommandFlush, m_omx_input_port, 0);
-  if (omx_err)
-    CLog::Log(LOGERROR, "%s::%s - OMX_CommandFlush failed with omx_err(0x%x)\n",
-      CLASSNAME, __func__, omx_err);
-  else if (wait)
-    sem_wait(m_omx_flush_input);
-  */
-
-  // free omx input port buffers.
-  for (size_t i = 0; i < m_omx_input_buffers.size(); i++)
-  {
-    // using external buffers (OMX_UseBuffer), free our external buffers
-    //  before calling OMX_FreeBuffer which frees the omx buffer.
-    delete [] m_omx_input_buffers[i]->pBuffer;
-    m_omx_input_buffers[i]->pBuffer = NULL;
-    omx_err = OMX_FreeBuffer(m_omx_decoder, m_omx_input_port, m_omx_input_buffers[i]);
-  }
-  m_omx_input_buffers.clear();
-
   // empty input buffer queue. not decoding so don't need lock/unlock.
-  while (!m_omx_input_avaliable.empty())
-    m_omx_input_avaliable.pop();
   while (!m_demux_queue.empty())
     m_demux_queue.pop();
+#ifdef DTS_QUEUE
   while (!m_dts_queue.empty())
     m_dts_queue.pop();
-
+#endif
   return(omx_err);
 }
 
-void COpenMaxVideo::CallbackAllocOMXEGLTextures(void *userdata)
+bool COpenMaxVideo::CallbackAllocOMXEGLTextures(void *userdata)
 {
   COpenMaxVideo *omx = static_cast<COpenMaxVideo*>(userdata);
-  omx->AllocOMXOutputEGLTextures();
+  return omx->AllocOMXOutputEGLTextures() == OMX_ErrorNone;
 }
 
-void COpenMaxVideo::CallbackFreeOMXEGLTextures(void *userdata)
+bool COpenMaxVideo::CallbackFreeOMXEGLTextures(void *userdata)
 {
   COpenMaxVideo *omx = static_cast<COpenMaxVideo*>(userdata);
-  omx->FreeOMXOutputEGLTextures(true);
+  return omx->FreeOMXOutputEGLTextures() == OMX_ErrorNone;
 }
 
-OMX_ERRORTYPE COpenMaxVideo::AllocOMXOutputBuffers(void)
+bool COpenMaxVideo::AllocOMXOutputBuffers(void)
 {
-  OMX_ERRORTYPE omx_err;
-
-  if ( g_application.IsCurrentThread() )
-  {
-    omx_err = AllocOMXOutputEGLTextures();
-  }
-  else
-  {
-    ThreadMessageCallback callbackData;
-    callbackData.callback = &CallbackAllocOMXEGLTextures;
-    callbackData.userptr = (void *)this;
-
-    ThreadMessage tMsg;
-    tMsg.dwMessage = TMSG_CALLBACK;
-    tMsg.lpVoid = (void*)&callbackData;
-
-    g_application.getApplicationMessenger().SendMessage(tMsg, true);
-
-    omx_err = OMX_ErrorNone;
-  }
-
-  return omx_err;
+  return g_OMXImage.SendMessage(CallbackAllocOMXEGLTextures, (void *)this);
 }
 
-OMX_ERRORTYPE COpenMaxVideo::FreeOMXOutputBuffers(bool wait)
+bool COpenMaxVideo::FreeOMXOutputBuffers(void)
 {
-  OMX_ERRORTYPE omx_err = FreeOMXOutputEGLTextures(wait);
-
-  return omx_err;
+  return g_OMXImage.SendMessage(CallbackFreeOMXEGLTextures, (void *)this);
 }
 
 OMX_ERRORTYPE COpenMaxVideo::AllocOMXOutputEGLTextures(void)
 {
-  OMX_ERRORTYPE omx_err;
-
-  if (!eglCreateImageKHR)
-  {
-    GETEXTENSION(PFNEGLCREATEIMAGEKHRPROC,  eglCreateImageKHR);
-  }
-
+  OMX_ERRORTYPE omx_err = OMX_ErrorNone;
   EGLint attrib = EGL_NONE;
-  OpenMaxVideoBuffer *egl_buffer;
-
-  // Obtain the information about the output port.
-  OMX_PARAM_PORTDEFINITIONTYPE port_format;
-  OMX_INIT_STRUCTURE(port_format);
-  port_format.nPortIndex = m_omx_output_port;
-  omx_err = OMX_GetParameter(m_omx_decoder, OMX_IndexParamPortDefinition, &port_format);
-
-  #if defined(OMX_DEBUG_VERBOSE)
-  CLog::Log(LOGDEBUG,
-    "%s::%s (1) - oport(%d), nFrameWidth(%lu), nFrameHeight(%lu), nStride(%lx), nBufferCountMin(%lu), nBufferSize(%lu)\n",
-    CLASSNAME, __func__, m_omx_output_port,
-    port_format.format.video.nFrameWidth, port_format.format.video.nFrameHeight,port_format.format.video.nStride,
-    port_format.nBufferCountMin, port_format.nBufferSize);
-  #endif
+  COpenMaxVideoBuffer *egl_buffer;
 
   glActiveTexture(GL_TEXTURE0);
 
-  for (size_t i = 0; i < port_format.nBufferCountMin; i++)
+  for (size_t i = 0; i < m_egl_buffer_count; i++)
   {
-    egl_buffer = new OpenMaxVideoBuffer;
-    memset(egl_buffer, 0, sizeof(*egl_buffer));
+    egl_buffer = new COpenMaxVideoBuffer(this);
     egl_buffer->width  = m_decoded_width;
     egl_buffer->height = m_decoded_height;
 
     glGenTextures(1, &egl_buffer->texture_id);
     glBindTexture(GL_TEXTURE_2D, egl_buffer->texture_id);
 
+    // no mipmaps
+    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+
     // create space for buffer with a texture
     glTexImage2D(
       GL_TEXTURE_2D,      // target
@@ -710,8 +928,6 @@ OMX_ERRORTYPE COpenMaxVideo::AllocOMXOutputEGLTextures(void)
       GL_RGBA,            // format
       GL_UNSIGNED_BYTE,   // type
       NULL);              // pixels -- will be provided later
-      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
-      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
 
     // create EGLImage from texture
     egl_buffer->egl_image = eglCreateImageKHR(
@@ -722,49 +938,40 @@ OMX_ERRORTYPE COpenMaxVideo::AllocOMXOutputEGLTextures(void)
       &attrib);
     if (!egl_buffer->egl_image)
     {
-      CLog::Log(LOGERROR, "%s::%s - ERROR creating EglImage\n", CLASSNAME, __func__);
+      CLog::Log(LOGERROR, "%s::%s - ERROR creating EglImage", CLASSNAME, __func__);
       return(OMX_ErrorUndefined);
     }
     egl_buffer->index = i;
 
     // tell decoder output port that it will be using EGLImage
-    omx_err = OMX_UseEGLImage(
-      m_omx_decoder, &egl_buffer->omx_buffer, m_omx_output_port, egl_buffer, egl_buffer->egl_image);
+    omx_err = m_omx_egl_render.UseEGLImage(
+      &egl_buffer->omx_buffer, m_omx_egl_render.GetOutputPort(), egl_buffer, egl_buffer->egl_image);
     if (omx_err)
     {
-      CLog::Log(LOGERROR, "%s::%s - OMX_UseEGLImage failed with omx_err(0x%x)\n",
+      CLog::Log(LOGERROR, "%s::%s - OMX_UseEGLImage failed with omx_err(0x%x)",
         CLASSNAME, __func__, omx_err);
       return(omx_err);
     }
     m_omx_output_buffers.push_back(egl_buffer);
 
-    CLog::Log(LOGDEBUG, "%s::%s - Texture %p Width %d Height %d\n",
+    CLog::Log(LOGDEBUG, "%s::%s - Texture %p Width %d Height %d",
       CLASSNAME, __func__, egl_buffer->egl_image, egl_buffer->width, egl_buffer->height);
   }
-  m_omx_output_eos = false;
-  while (!m_omx_output_busy.empty())
-    m_omx_output_busy.pop();
-  while (!m_omx_output_ready.empty())
-    m_omx_output_ready.pop();
-
   return omx_err;
 }
 
-OMX_ERRORTYPE COpenMaxVideo::FreeOMXOutputEGLTextures(bool wait)
+OMX_ERRORTYPE COpenMaxVideo::FreeOMXOutputEGLTextures(void)
 {
   OMX_ERRORTYPE omx_err = OMX_ErrorNone;
-  OpenMaxVideoBuffer *egl_buffer;
-
-  if (!eglDestroyImageKHR)
-  {
-    GETEXTENSION(PFNEGLDESTROYIMAGEKHRPROC, eglDestroyImageKHR);
-  }
+  COpenMaxVideoBuffer *egl_buffer;
 
   for (size_t i = 0; i < m_omx_output_buffers.size(); i++)
   {
     egl_buffer = m_omx_output_buffers[i];
     // tell decoder output port to stop using the EGLImage
-    omx_err = OMX_FreeBuffer(m_omx_decoder, m_omx_output_port, egl_buffer->omx_buffer);
+    omx_err = m_omx_egl_render.FreeOutputBuffer(egl_buffer->omx_buffer);
+    if (omx_err != OMX_ErrorNone)
+      CLog::Log(LOGERROR, "%s::%s m_omx_egl_render.FreeOutputBuffer(%p) omx_err(0x%08x)", CLASSNAME, __func__, egl_buffer->omx_buffer, omx_err);
     // destroy egl_image
     eglDestroyImageKHR(m_egl_display, egl_buffer->egl_image);
     // free texture
@@ -777,274 +984,45 @@ OMX_ERRORTYPE COpenMaxVideo::FreeOMXOutputEGLTextures(bool wait)
 }
 
 
-////////////////////////////////////////////////////////////////////////////////////////////
-// DecoderEventHandler -- OMX event callback
-OMX_ERRORTYPE COpenMaxVideo::DecoderEventHandler(
-  OMX_HANDLETYPE hComponent,
-  OMX_PTR pAppData,
-  OMX_EVENTTYPE eEvent,
-  OMX_U32 nData1,
-  OMX_U32 nData2,
-  OMX_PTR pEventData)
-{
-  OMX_ERRORTYPE omx_err;
-  COpenMaxVideo *ctx = static_cast<COpenMaxVideo*>(pAppData);
-
-/*
-  #if defined(OMX_DEBUG_VERBOSE)
-  CLog::Log(LOGDEBUG,
-    "COpenMax::%s - hComponent(0x%p), eEvent(0x%x), nData1(0x%lx), nData2(0x%lx), pEventData(0x%p)\n",
-    __func__, hComponent, eEvent, nData1, nData2, pEventData);
-  #endif
-*/
-
-  switch (eEvent)
-  {
-    case OMX_EventCmdComplete:
-      switch(nData1)
-      {
-        case OMX_CommandStateSet:
-          ctx->m_omx_decoder_state = (int)nData2;
-          switch (ctx->m_omx_decoder_state)
-          {
-            case OMX_StateInvalid:
-              CLog::Log(LOGDEBUG, "%s::%s - OMX_StateInvalid\n", CLASSNAME, __func__);
-            break;
-            case OMX_StateLoaded:
-              CLog::Log(LOGDEBUG, "%s::%s - OMX_StateLoaded\n", CLASSNAME, __func__);
-            break;
-            case OMX_StateIdle:
-              CLog::Log(LOGDEBUG, "%s::%s - OMX_StateIdle\n", CLASSNAME, __func__);
-            break;
-            case OMX_StateExecuting:
-              CLog::Log(LOGDEBUG, "%s::%s - OMX_StateExecuting\n", CLASSNAME, __func__);
-            break;
-            case OMX_StatePause:
-              CLog::Log(LOGDEBUG, "%s::%s - OMX_StatePause\n", CLASSNAME, __func__);
-            break;
-            case OMX_StateWaitForResources:
-              CLog::Log(LOGDEBUG, "%s::%s - OMX_StateWaitForResources\n", CLASSNAME, __func__);
-            break;
-            default:
-              CLog::Log(LOGDEBUG,
-                "%s::%s - Unknown OMX_Statexxxxx, state(%d)\n",
-                CLASSNAME, __func__, ctx->m_omx_decoder_state);
-            break;
-          }
-          sem_post(ctx->m_omx_decoder_state_change);
-        break;
-        case OMX_CommandFlush:
-          /*
-          if (OMX_ALL == (int)nData2)
-          {
-            sem_post(ctx->m_omx_flush_input);
-            sem_post(ctx->m_omx_flush_output);
-            CLog::Log(LOGDEBUG, "COpenMax::%s - OMX_CommandFlush input/output\n",__func__);
-          }
-          else if (ctx->m_omx_input_port == (int)nData2)
-          {
-            sem_post(ctx->m_omx_flush_input);
-            CLog::Log(LOGDEBUG, "COpenMax::%s - OMX_CommandFlush input\n",__func__);
-          }
-          else if (ctx->m_omx_output_port == (int)nData2)
-          {
-            sem_post(ctx->m_omx_flush_output);
-            CLog::Log(LOGDEBUG, "COpenMax::%s - OMX_CommandFlush ouput\n",__func__);
-          }
-          else
-          */
-          {
-            #if defined(OMX_DEBUG_EVENTHANDLER)
-            CLog::Log(LOGDEBUG,
-              "%s::%s - OMX_CommandFlush, nData2(0x%lx)\n",
-              CLASSNAME, __func__, nData2);
-            #endif
-          }
-        break;
-        case OMX_CommandPortDisable:
-          #if defined(OMX_DEBUG_EVENTHANDLER)
-          CLog::Log(LOGDEBUG,
-            "%s::%s - OMX_CommandPortDisable, nData1(0x%lx), nData2(0x%lx)\n",
-            CLASSNAME, __func__, nData1, nData2);
-          #endif
-          if (ctx->m_omx_output_port == (int)nData2)
-          {
-            // Got OMX_CommandPortDisable event, alloc new buffers for the output port.
-            ctx->AllocOMXOutputBuffers();
-            omx_err = OMX_SendCommand(ctx->m_omx_decoder, OMX_CommandPortEnable, ctx->m_omx_output_port, NULL);
-          }
-        break;
-        case OMX_CommandPortEnable:
-          #if defined(OMX_DEBUG_EVENTHANDLER)
-          CLog::Log(LOGDEBUG,
-            "%s::%s - OMX_CommandPortEnable, nData1(0x%lx), nData2(0x%lx)\n",
-            CLASSNAME, __func__, nData1, nData2);
-          #endif
-          if (ctx->m_omx_output_port == (int)nData2)
-          {
-            // Got OMX_CommandPortEnable event.
-            // OMX_CommandPortDisable will have re-alloced new ones so re-prime
-            ctx->PrimeFillBuffers();
-          }
-          ctx->m_portChanging = false;
-        break;
-        #if defined(OMX_DEBUG_EVENTHANDLER)
-        case OMX_CommandMarkBuffer:
-          CLog::Log(LOGDEBUG,
-            "%s::%s - OMX_CommandMarkBuffer, nData1(0x%lx), nData2(0x%lx)\n",
-            CLASSNAME, __func__, nData1, nData2);
-        break;
-        #endif
-      }
-    break;
-    case OMX_EventBufferFlag:
-      if (ctx->m_omx_decoder == hComponent && (nData2 & OMX_BUFFERFLAG_EOS)) {
-        #if defined(OMX_DEBUG_EVENTHANDLER)
-        if(ctx->m_omx_input_port  == (int)nData1)
-            CLog::Log(LOGDEBUG, "%s::%s - OMX_EventBufferFlag(input)\n",
-            CLASSNAME, __func__);
-        #endif
-        if(ctx->m_omx_output_port == (int)nData1)
-        {
-            ctx->m_videoplayback_done = true;
-            #if defined(OMX_DEBUG_EVENTHANDLER)
-            CLog::Log(LOGDEBUG, "%s::%s - OMX_EventBufferFlag(output)\n",
-            CLASSNAME, __func__);
-            #endif
-        }
-      }
-    break;
-    case OMX_EventPortSettingsChanged:
-      #if defined(OMX_DEBUG_EVENTHANDLER)
-      CLog::Log(LOGDEBUG,
-        "%s::%s - OMX_EventPortSettingsChanged(output)\n", CLASSNAME, __func__);
-      #endif
-      // not sure nData2 is the input/output ports in this call, docs don't say
-      if (ctx->m_omx_output_port == (int)nData2)
-      {
-        // free the current OpenMax output buffers, you must do this before sending
-        // OMX_CommandPortDisable to component as it expects output buffers
-        // to be freed before it will issue a OMX_CommandPortDisable event.
-        ctx->m_portChanging = true;
-        OMX_SendCommand(ctx->m_omx_decoder, OMX_CommandPortDisable, ctx->m_omx_output_port, NULL);
-        omx_err = ctx->FreeOMXOutputBuffers(false);
-      }
-    break;
-    #if defined(OMX_DEBUG_EVENTHANDLER)
-    case OMX_EventMark:
-      CLog::Log(LOGDEBUG, "%s::%s - OMX_EventMark\n", CLASSNAME, __func__);
-    break;
-    case OMX_EventResourcesAcquired:
-      CLog::Log(LOGDEBUG, "%s::%s - OMX_EventResourcesAcquired\n", CLASSNAME, __func__);
-    break;
-    #endif
-    case OMX_EventError:
-      switch((OMX_S32)nData1)
-      {
-        case OMX_ErrorInsufficientResources:
-          CLog::Log(LOGERROR, "%s::%s - OMX_EventError, insufficient resources\n",
-            CLASSNAME, __func__);
-          // we are so frack'ed
-          //exit(0);
-        break;
-        case OMX_ErrorFormatNotDetected:
-          CLog::Log(LOGERROR, "%s::%s - OMX_EventError, cannot parse input stream\n",
-            CLASSNAME, __func__);
-        break;
-        case OMX_ErrorPortUnpopulated:
-          // silently ignore these. We can get them when setting OMX_CommandPortDisable
-          // on the output port and the component flushes the output buffers.
-        break;
-        case OMX_ErrorStreamCorrupt:
-          CLog::Log(LOGERROR, "%s::%s - OMX_EventError, Bitstream corrupt\n",
-            CLASSNAME, __func__);
-          ctx->m_videoplayback_done = true;
-        break;
-        default:
-          CLog::Log(LOGERROR, "%s::%s - OMX_EventError detected, nData1(0x%lx), nData2(0x%lx)\n",
-            CLASSNAME, __func__, nData1, nData2);
-        break;
-      }
-      // do this so we don't hang on errors
-      /*
-      sem_post(ctx->m_omx_flush_input);
-      sem_post(ctx->m_omx_flush_output);
-      */
-      sem_post(ctx->m_omx_decoder_state_change);
-    break;
-    default:
-      CLog::Log(LOGWARNING,
-        "%s::%s - Unknown eEvent(0x%x), nData1(0x%lx), nData2(0x%lx)\n",
-        CLASSNAME, __func__, eEvent, nData1, nData2);
-    break;
-  }
-
-  return OMX_ErrorNone;
-}
-
-// StartPlayback -- Kick off video playback.
-OMX_ERRORTYPE COpenMaxVideo::StartDecoder(void)
-{
-  OMX_ERRORTYPE omx_err;
-
-  #if defined(OMX_DEBUG_VERBOSE)
-  CLog::Log(LOGDEBUG, "%s::%s\n", CLASSNAME, __func__);
-  #endif
-
-  // transition decoder component to IDLE state
-  omx_err = SetStateForComponent(OMX_StateIdle);
-  if (omx_err)
-  {
-    CLog::Log(LOGERROR, "%s::%s - setting OMX_StateIdle failed with omx_err(0x%x)\n",
-      CLASSNAME, __func__, omx_err);
-    return omx_err;
-  }
-
-  // transition decoder component to executing state
-  omx_err = SetStateForComponent(OMX_StateExecuting);
-  if (omx_err)
-  {
-    CLog::Log(LOGERROR, "%s::%s - setting OMX_StateExecuting failed with omx_err(0x%x)\n",
-      CLASSNAME, __func__, omx_err);
-    return omx_err;
-  }
-
-  //prime the omx output buffers.
-  PrimeFillBuffers();
-
-  return omx_err;
-}
-
 // StopPlayback -- Stop video playback
 OMX_ERRORTYPE COpenMaxVideo::StopDecoder(void)
 {
-  OMX_ERRORTYPE omx_err;
+  OMX_ERRORTYPE omx_err = OMX_ErrorNone;
 
   #if defined(OMX_DEBUG_VERBOSE)
-  CLog::Log(LOGDEBUG, "%s::%s\n", CLASSNAME, __func__);
+  CLog::Log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
   #endif
+
   // transition decoder component from executing to idle
-  omx_err = SetStateForComponent(OMX_StateIdle);
-  if (omx_err)
+  if (m_omx_decoder.IsInitialized())
   {
-    CLog::Log(LOGERROR, "%s::%s - setting OMX_StateIdle failed with omx_err(0x%x)\n",
-      CLASSNAME, __func__, omx_err);
-    return omx_err;
+    omx_err = m_omx_decoder.SetStateForComponent(OMX_StateIdle);
+    if (omx_err)
+      CLog::Log(LOGERROR, "%s::%s - setting OMX_StateIdle failed with omx_err(0x%x)",
+        CLASSNAME, __func__, omx_err);
   }
 
   // we can free our allocated port buffers in OMX_StateIdle state.
   // free OpenMax input buffers.
-  FreeOMXInputBuffers(true);
-  // free OpenMax output buffers.
-  FreeOMXOutputBuffers(true);
+  FreeOMXInputBuffers();
+
+  if (m_omx_egl_render.IsInitialized())
+  {
+      omx_err = m_omx_egl_render.SetStateForComponent(OMX_StateIdle);
+      if (omx_err)
+        CLog::Log(LOGERROR, "%s::%s - setting egl OMX_StateIdle failed with omx_err(0x%x)",
+          CLASSNAME, __func__, omx_err);
+      // free OpenMax output buffers.
+      omx_err = m_omx_egl_render.DisablePort(m_omx_egl_render.GetOutputPort(), false);
+      if (omx_err != OMX_ErrorNone)
+        CLog::Log(LOGERROR, "%s::%s m_omx_egl_render.DisablePort(%d) omx_err(0x%08x)", CLASSNAME, __func__, m_omx_egl_render.GetOutputPort(), omx_err);
 
-  // transition decoder component from idle to loaded
-  omx_err = SetStateForComponent(OMX_StateLoaded);
-  if (omx_err)
-    CLog::Log(LOGERROR,
-      "%s::%s - setting OMX_StateLoaded failed with omx_err(0x%x)\n",
-      CLASSNAME, __func__, omx_err);
+      FreeOMXOutputBuffers();
 
+      omx_err = m_omx_egl_render.WaitForCommand(OMX_CommandPortDisable, m_omx_egl_render.GetOutputPort());
+      if (omx_err != OMX_ErrorNone)
+        CLog::Log(LOGERROR, "%s::%s WaitForCommand:OMX_CommandPortDisable omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+  }
   return omx_err;
 }
 
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.h
index e06c41d..9079c13 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.h
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.h
@@ -21,12 +21,35 @@
 
 #if defined(HAVE_LIBOPENMAX)
 
-#include "OpenMax.h"
+#include "system_gl.h"
 #include <EGL/egl.h>
 #include <EGL/eglext.h>
 
+#include "linux/OMXCore.h"
+#include "linux/OMXClock.h"
+
+#include "cores/dvdplayer/DVDStreamInfo.h"
+#include "DVDVideoCodec.h"
+#include "threads/Event.h"
+
+#include <queue>
+#include <semaphore.h>
+
+typedef struct omx_demux_packet {
+  OMX_U8 *buff;
+  int size;
+  double dts;
+  double pts;
+} omx_demux_packet;
+
+class COpenMaxVideo;
 // an omx egl video frame
-typedef struct OpenMaxVideoBuffer {
+class COpenMaxVideoBuffer
+{
+public:
+  COpenMaxVideoBuffer(COpenMaxVideo *omv);
+  virtual ~COpenMaxVideoBuffer();
+
   OMX_BUFFERHEADERTYPE *omx_buffer;
   int width;
   int height;
@@ -35,79 +58,86 @@ typedef struct OpenMaxVideoBuffer {
   // used for egl based rendering if active
   EGLImageKHR egl_image;
   GLuint texture_id;
-} OpenMaxVideoBuffer;
+  // reference counting
+  COpenMaxVideoBuffer* Acquire();
+  long                 Release();
+  void                 Sync();
+
+  COpenMaxVideo *m_omv;
+  long m_refs;
+private:
+};
 
-class COpenMaxVideo : public COpenMax
+class COpenMaxVideo
 {
 public:
   COpenMaxVideo();
   virtual ~COpenMaxVideo();
 
   // Required overrides
-  bool Open(CDVDStreamInfo &hints);
-  void Close(void);
-  int  Decode(uint8_t *pData, int iSize, double dts, double pts);
-  void Reset(void);
-  bool GetPicture(DVDVideoPicture *pDvdVideoPicture);
-  void SetDropState(bool bDrop);
+  virtual bool Open(CDVDStreamInfo &hints, CDVDCodecOptions &options);
+  virtual void Dispose(void);
+  virtual int  Decode(uint8_t *pData, int iSize, double dts, double pts);
+  virtual void Reset(void);
+  virtual bool GetPicture(DVDVideoPicture *pDvdVideoPicture);
+  virtual bool ClearPicture(DVDVideoPicture* pDvdVideoPicture);
+  virtual unsigned GetAllowedReferences() { return 2; }
+  virtual void SetDropState(bool bDrop);
+  virtual const char* GetName(void) { return (const char*)m_pFormatName; }
+
+  // OpenMax decoder callback routines.
+  OMX_ERRORTYPE DecoderFillBufferDone(OMX_HANDLETYPE hComponent, OMX_BUFFERHEADERTYPE* pBuffer);
+  void ReleaseOpenMaxBuffer(COpenMaxVideoBuffer *buffer);
+
 protected:
   void QueryCodec(void);
   OMX_ERRORTYPE PrimeFillBuffers(void);
   OMX_ERRORTYPE AllocOMXInputBuffers(void);
-  OMX_ERRORTYPE FreeOMXInputBuffers(bool wait);
-  OMX_ERRORTYPE AllocOMXOutputBuffers(void);
-  OMX_ERRORTYPE FreeOMXOutputBuffers(bool wait);
-  static void CallbackAllocOMXEGLTextures(void*);
+  OMX_ERRORTYPE FreeOMXInputBuffers(void);
+  bool AllocOMXOutputBuffers(void);
+  bool FreeOMXOutputBuffers(void);
+  static bool CallbackAllocOMXEGLTextures(void*);
   OMX_ERRORTYPE AllocOMXOutputEGLTextures(void);
-  static void CallbackFreeOMXEGLTextures(void*);
-  OMX_ERRORTYPE FreeOMXOutputEGLTextures(bool wait);
-
-  // TODO Those should move into the base class. After start actions can be executed by callbacks.
-  OMX_ERRORTYPE StartDecoder(void);
+  static bool CallbackFreeOMXEGLTextures(void*);
+  OMX_ERRORTYPE FreeOMXOutputEGLTextures(void);
   OMX_ERRORTYPE StopDecoder(void);
-
-  // OpenMax decoder callback routines.
-  virtual OMX_ERRORTYPE DecoderEventHandler(OMX_HANDLETYPE hComponent, OMX_PTR pAppData,
-    OMX_EVENTTYPE eEvent, OMX_U32 nData1, OMX_U32 nData2, OMX_PTR pEventData);
-  virtual OMX_ERRORTYPE DecoderEmptyBufferDone(
-    OMX_HANDLETYPE hComponent, OMX_PTR pAppData, OMX_BUFFERHEADERTYPE* pBuffer);
-  virtual OMX_ERRORTYPE DecoderFillBufferDone(
-    OMX_HANDLETYPE hComponent, OMX_PTR pAppData, OMX_BUFFERHEADERTYPE* pBufferHeader);
+  OMX_ERRORTYPE ReturnOpenMaxBuffer(COpenMaxVideoBuffer *buffer);
 
   // EGL Resources
   EGLDisplay        m_egl_display;
   EGLContext        m_egl_context;
 
   // Video format
-  DVDVideoPicture   m_videobuffer;
   bool              m_drop_state;
   int               m_decoded_width;
   int               m_decoded_height;
+  unsigned int      m_egl_buffer_count;
+
+  bool m_port_settings_changed;
+  const char        *m_pFormatName;
 
   std::queue<double> m_dts_queue;
   std::queue<omx_demux_packet> m_demux_queue;
 
-  // OpenMax input buffers (demuxer packets)
-  pthread_mutex_t   m_omx_input_mutex;
-  std::queue<OMX_BUFFERHEADERTYPE*> m_omx_input_avaliable;
-  std::vector<OMX_BUFFERHEADERTYPE*> m_omx_input_buffers;
-  bool              m_omx_input_eos;
-  int               m_omx_input_port;
-  //sem_t             *m_omx_flush_input;
-  CEvent            m_input_consumed_event;
-
   // OpenMax output buffers (video frames)
   pthread_mutex_t   m_omx_output_mutex;
-  std::queue<OpenMaxVideoBuffer*> m_omx_output_busy;
-  std::queue<OpenMaxVideoBuffer*> m_omx_output_ready;
-  std::vector<OpenMaxVideoBuffer*> m_omx_output_buffers;
-  bool              m_omx_output_eos;
-  int               m_omx_output_port;
-  //sem_t             *m_omx_flush_output;
+  std::vector<COpenMaxVideoBuffer*> m_omx_output_busy;
+  std::queue<COpenMaxVideoBuffer*> m_omx_output_ready;
+  std::vector<COpenMaxVideoBuffer*> m_omx_output_buffers;
+
+  // initialize OpenMax and get decoder component
+  bool Initialize( const CStdString &decoder_name);
+
+  // Components
+  COMXCoreComponent m_omx_decoder;
+  COMXCoreComponent m_omx_egl_render;
 
-  bool              m_portChanging;
+  COMXCoreTunel     m_omx_tunnel;
+  OMX_VIDEO_CODINGTYPE m_codingType;
 
-  volatile bool     m_videoplayback_done;
+  bool PortSettingsChanged();
+  bool SendDecoderConfig(uint8_t *extradata, int extrasize);
+  bool NaluFormatStartCodes(enum AVCodecID codec, uint8_t *extradata, int extrasize);
 };
 
 // defined(HAVE_LIBOPENMAX)
diff --git a/xbmc/cores/dvdplayer/DVDPlayer.cpp b/xbmc/cores/dvdplayer/DVDPlayer.cpp
index af0e493..d01089e 100644
--- a/xbmc/cores/dvdplayer/DVDPlayer.cpp
+++ b/xbmc/cores/dvdplayer/DVDPlayer.cpp
@@ -2974,7 +2974,9 @@ bool CDVDPlayer::OpenVideoStream(CDVDStreamInfo& hint, bool reset)
       hint.aspect = aspect;
       hint.forced_aspect = true;
     }
+#ifndef TARGET_RASPBERRY_PI
     hint.software = true;
+#endif
   }
 
   CDVDInputStream::IMenus* pMenus = dynamic_cast<CDVDInputStream::IMenus*>(m_pInputStream);
diff --git a/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp b/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
index 633e333..c6350cd 100644
--- a/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
+++ b/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
@@ -324,6 +324,9 @@ void CDVDPlayerVideo::Process()
 
   while (!m_bStop)
   {
+    DemuxPacket staticPacket = {};
+    DemuxPacket* pPacket = NULL;
+    bool bPacketDrop = false;
     int iQueueTimeOut = (int)(m_stalled ? frametime / 4 : frametime * 10) / 1000;
     int iPriority = (m_speed == DVD_PLAYSPEED_PAUSE && m_started) ? 1 : 0;
 
@@ -360,8 +363,10 @@ void CDVDPlayerVideo::Process()
         OutputPicture(&picture, pts);
         pts+= frametime;
       }
-
-      continue;
+      pPacket = &staticPacket;
+      bPacketDrop = false;
+      goto submit_empty_packet;
+      //continue;
     }
 
     if (pMsg->IsType(CDVDMsg::GENERAL_SYNCHRONIZE))
@@ -490,9 +495,12 @@ void CDVDPlayerVideo::Process()
 
     if (pMsg->IsType(CDVDMsg::DEMUXER_PACKET))
     {
-      DemuxPacket* pPacket = ((CDVDMsgDemuxerPacket*)pMsg)->GetPacket();
-      bool bPacketDrop     = ((CDVDMsgDemuxerPacket*)pMsg)->GetPacketDrop();
-
+      pPacket = ((CDVDMsgDemuxerPacket*)pMsg)->GetPacket();
+      bPacketDrop     = ((CDVDMsgDemuxerPacket*)pMsg)->GetPacketDrop();
+    }
+submit_empty_packet:
+    if (ret == MSGQ_TIMEOUT || pMsg->IsType(CDVDMsg::DEMUXER_PACKET))
+    {
       if (m_stalled)
       {
         CLog::Log(LOGINFO, "CDVDPlayerVideo - Stillframe left, switching to normal playback");
@@ -750,7 +758,8 @@ void CDVDPlayerVideo::Process()
     }
 
     // all data is used by the decoder, we can safely free it now
-    pMsg->Release();
+    if (ret != MSGQ_TIMEOUT)
+        pMsg->Release();
   }
 
   // we need to let decoder release any picture retained resources.
diff --git a/xbmc/linux/OMXCore.cpp b/xbmc/linux/OMXCore.cpp
index 6e7d9a9..99e407a 100644
--- a/xbmc/linux/OMXCore.cpp
+++ b/xbmc/linux/OMXCore.cpp
@@ -460,7 +460,12 @@ void COMXCoreComponent::FlushInput()
     CLog::Log(LOGERROR, "COMXCoreComponent::FlushInput - Error on component %s omx_err(0x%08x)", 
               m_componentName.c_str(), (int)omx_err);
   }
-  WaitForCommand(OMX_CommandFlush, m_input_port);
+  omx_err = WaitForCommand(OMX_CommandFlush, m_input_port);
+  if(omx_err != OMX_ErrorNone)
+  {
+    CLog::Log(LOGERROR, "COMXCoreComponent::FlushInput - %s WaitForCommand omx_err(0x%08x)",
+              m_componentName.c_str(), (int)omx_err);
+  }
 }
 
 void COMXCoreComponent::FlushOutput()
@@ -477,7 +482,12 @@ void COMXCoreComponent::FlushOutput()
     CLog::Log(LOGERROR, "COMXCoreComponent::FlushOutput - Error on component %s omx_err(0x%08x)", 
               m_componentName.c_str(), (int)omx_err);
   }
-  WaitForCommand(OMX_CommandFlush, m_output_port);
+  omx_err = WaitForCommand(OMX_CommandFlush, m_output_port);
+  if(omx_err != OMX_ErrorNone)
+  {
+    CLog::Log(LOGERROR, "COMXCoreComponent::FlushOutput - %s WaitForCommand omx_err(0x%08x)",
+              m_componentName.c_str(), (int)omx_err);
+  }
 }
 
 // timeout in milliseconds
@@ -1149,7 +1159,12 @@ OMX_STATETYPE COMXCoreComponent::GetState()
 
   OMX_STATETYPE state;
 
-  OMX_GetState(m_handle, &state);
+  OMX_ERRORTYPE omx_err = OMX_GetState(m_handle, &state);
+  if (omx_err != OMX_ErrorNone)
+  {
+    CLog::Log(LOGERROR, "COMXCoreComponent::GetState - %s failed with omx_err(0x%x)\n",
+      m_componentName.c_str(), omx_err);
+  }
   return state;
 }
 
@@ -1307,6 +1322,8 @@ OMX_ERRORTYPE COMXCoreComponent::DisablePort(unsigned int port, bool wait)
 
 OMX_ERRORTYPE COMXCoreComponent::UseEGLImage(OMX_BUFFERHEADERTYPE** ppBufferHdr, OMX_U32 nPortIndex, OMX_PTR pAppPrivate, void* eglImage)
 {
+if (m_callbacks.FillBufferDone == &COMXCoreComponent::DecoderFillBufferDoneCallback)
+{
   OMX_ERRORTYPE omx_err = OMX_ErrorNone;
 
   if(!m_handle)
@@ -1383,8 +1400,21 @@ OMX_ERRORTYPE COMXCoreComponent::UseEGLImage(OMX_BUFFERHEADERTYPE** ppBufferHdr,
 
   return omx_err;
 }
+else
+{
+  OMX_ERRORTYPE omx_err;
+    omx_err = OMX_UseEGLImage(m_handle, ppBufferHdr, nPortIndex, pAppPrivate, eglImage);
+    if(omx_err != OMX_ErrorNone)
+    {
+      CLog::Log(LOGERROR, "%s::%s - %s failed with omx_err(0x%x)\n",
+                CLASSNAME, __func__, m_componentName.c_str(), omx_err);
+      return omx_err;
+    }
+  return omx_err;
+}
+}
 
-bool COMXCoreComponent::Initialize( const std::string &component_name, OMX_INDEXTYPE index)
+bool COMXCoreComponent::Initialize( const std::string &component_name, OMX_INDEXTYPE index, OMX_CALLBACKTYPE *callbacks)
 {
   OMX_ERRORTYPE omx_err;
 
@@ -1419,6 +1449,13 @@ bool COMXCoreComponent::Initialize( const std::string &component_name, OMX_INDEX
   m_callbacks.EmptyBufferDone = &COMXCoreComponent::DecoderEmptyBufferDoneCallback;
   m_callbacks.FillBufferDone  = &COMXCoreComponent::DecoderFillBufferDoneCallback;
 
+  if (callbacks && callbacks->EventHandler)
+    m_callbacks.EventHandler    = callbacks->EventHandler;
+  if (callbacks && callbacks->EmptyBufferDone)
+    m_callbacks.EmptyBufferDone = callbacks->EmptyBufferDone;
+  if (callbacks && callbacks->FillBufferDone)
+    m_callbacks.FillBufferDone  = callbacks->FillBufferDone;
+
   // Get video component handle setting up callbacks, component is in loaded state on return.
   if(!m_handle)
   {
diff --git a/xbmc/linux/OMXCore.h b/xbmc/linux/OMXCore.h
index 1efb313..b4c8626 100644
--- a/xbmc/linux/OMXCore.h
+++ b/xbmc/linux/OMXCore.h
@@ -107,7 +107,7 @@ class COMXCoreComponent
   OMX_ERRORTYPE DisablePort(unsigned int port, bool wait = true);
   OMX_ERRORTYPE UseEGLImage(OMX_BUFFERHEADERTYPE** ppBufferHdr, OMX_U32 nPortIndex, OMX_PTR pAppPrivate, void* eglImage);
 
-  bool          Initialize( const std::string &component_name, OMX_INDEXTYPE index);
+  bool          Initialize( const std::string &component_name, OMX_INDEXTYPE index, OMX_CALLBACKTYPE *callbacks = NULL);
   bool          IsInitialized();
   bool          Deinitialize();
 
-- 
1.9.3


From a594ae2a26c942405520ebda5d9cbe2db40bad59 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Mon, 20 Jan 2014 16:03:40 +0000
Subject: [PATCH 025/102] [omxcodec] Enable for dvd menus

---
 xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp b/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp
index 5d37395..6d1810f 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp
@@ -192,6 +192,10 @@ CDVDVideoCodec* CDVDFactoryCodec::CreateVideoCodec(CDVDStreamInfo &hint, unsigne
 
   CLog::Log(LOGDEBUG, "CDVDFactoryCodec: compiled in hardware support: %s", hwSupport.c_str());
 
+#if defined(HAVE_LIBOPENMAX)
+  // libopenmax can handle dvd playback including stills
+  if (!CSettings::Get().GetBool("videoplayer.useomx"))
+#endif
   if (hint.stills && (hint.codec == AV_CODEC_ID_MPEG2VIDEO || hint.codec == AV_CODEC_ID_MPEG1VIDEO))
   {
      // If dvd is an mpeg2 and hint.stills
-- 
1.9.3


From 87b8052d31c20b3173c2a676b0f7d3068687f6bf Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Mon, 3 Feb 2014 22:27:44 +0000
Subject: [PATCH 026/102] [omxcodec] Add omx specific texture
 create/upload/delete functions

---
 xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp | 33 +++++++++++++++++++++++++
 xbmc/cores/VideoRenderers/LinuxRendererGLES.h   |  4 +++
 2 files changed, 37 insertions(+)

diff --git a/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp b/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp
index 2e0d0ca..b8af8d0 100644
--- a/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp
+++ b/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp
@@ -803,6 +803,12 @@ void CLinuxRendererGLES::LoadShaders(int field)
     m_textureCreate = &CLinuxRendererGLES::CreateNV12Texture;
     m_textureDelete = &CLinuxRendererGLES::DeleteNV12Texture;
   }
+  else if (m_format == RENDER_FMT_OMXEGL)
+  {
+    m_textureUpload = &CLinuxRendererGLES::UploadOMXEGLTexture;
+    m_textureCreate = &CLinuxRendererGLES::CreateOMXEGLTexture;
+    m_textureDelete = &CLinuxRendererGLES::DeleteOMXEGLTexture;
+  }
   else
   {
     // default to YV12 texture handlers
@@ -2485,6 +2491,33 @@ bool CLinuxRendererGLES::CreateSurfaceTexture(int index)
   return true;
 }
 
+//********************************************************************************************************
+// SurfaceTexture creation, deletion, copying + clearing
+//********************************************************************************************************
+void CLinuxRendererGLES::UploadOMXEGLTexture(int index)
+{
+#ifdef HAVE_LIBOPENMAX
+  YUVBUFFER &buf = m_buffers[index];
+  if (buf.openMaxBuffer)
+  {
+    //buf.openMaxBuffer->Sync();
+  }
+#endif
+}
+void CLinuxRendererGLES::DeleteOMXEGLTexture(int index)
+{
+#ifdef HAVE_LIBOPENMAX
+  YUVBUFFER &buf = m_buffers[index];
+  if (buf.openMaxBuffer)
+    SAFE_RELEASE(buf.openMaxBuffer);
+#endif
+}
+bool CLinuxRendererGLES::CreateOMXEGLTexture(int index)
+{
+  DeleteOMXEGLTexture(index);
+  return true;
+}
+
 void CLinuxRendererGLES::SetTextureFilter(GLenum method)
 {
   for (int i = 0 ; i<m_NumYV12Buffers ; i++)
diff --git a/xbmc/cores/VideoRenderers/LinuxRendererGLES.h b/xbmc/cores/VideoRenderers/LinuxRendererGLES.h
index 5a6a2be..52df291 100644
--- a/xbmc/cores/VideoRenderers/LinuxRendererGLES.h
+++ b/xbmc/cores/VideoRenderers/LinuxRendererGLES.h
@@ -209,6 +209,10 @@ class CLinuxRendererGLES : public CBaseRenderer
   void DeleteSurfaceTexture(int index);
   bool CreateSurfaceTexture(int index);
 
+  void UploadOMXEGLTexture(int index);
+  void DeleteOMXEGLTexture(int index);
+  bool CreateOMXEGLTexture(int index);
+
   void CalculateTextureSourceRects(int source, int num_planes);
 
   // renderers
-- 
1.9.3


From f2c59b5ce9460a04c52e014cf15c9e835f9c9933 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Mon, 3 Feb 2014 22:50:43 +0000
Subject: [PATCH 027/102] [omxcodec] Add shared pointer to delay shutdown of
 codec until buffers are returned

---
 .../DVDCodecs/Video/DVDVideoCodecOpenMax.cpp        | 13 +++----------
 .../DVDCodecs/Video/DVDVideoCodecOpenMax.h          |  3 ++-
 .../dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp      | 21 ++++++++++++++++++++-
 xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.h |  5 ++++-
 4 files changed, 29 insertions(+), 13 deletions(-)

diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecOpenMax.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecOpenMax.cpp
index 7d33192..ef10555 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecOpenMax.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecOpenMax.cpp
@@ -28,7 +28,6 @@
 #include "DVDClock.h"
 #include "DVDStreamInfo.h"
 #include "DVDVideoCodecOpenMax.h"
-#include "OpenMaxVideo.h"
 #include "settings/Settings.h"
 #include "utils/log.h"
 
@@ -36,8 +35,8 @@
 ////////////////////////////////////////////////////////////////////////////////////////////
 ////////////////////////////////////////////////////////////////////////////////////////////
 CDVDVideoCodecOpenMax::CDVDVideoCodecOpenMax()
+ : m_omx_decoder( new COpenMaxVideo )
 {
-  m_omx_decoder = NULL;
   CLog::Log(LOGDEBUG, "%s::%s %p\n", CLASSNAME, __func__, this);
 }
 
@@ -49,8 +48,7 @@ CDVDVideoCodecOpenMax::~CDVDVideoCodecOpenMax()
 
 bool CDVDVideoCodecOpenMax::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options)
 {
-  m_omx_decoder = new COpenMaxVideo;
-  return m_omx_decoder->Open(hints, options);
+  return m_omx_decoder->Open(hints, options, m_omx_decoder);
 }
 
 const char* CDVDVideoCodecOpenMax::GetName(void)
@@ -60,12 +58,7 @@ const char* CDVDVideoCodecOpenMax::GetName(void)
 
 void CDVDVideoCodecOpenMax::Dispose()
 {
-  if (m_omx_decoder)
-  {
-    m_omx_decoder->Dispose();
-    delete m_omx_decoder;
-    m_omx_decoder = NULL;
-  }
+  m_omx_decoder->Dispose();
 }
 
 void CDVDVideoCodecOpenMax::SetDropState(bool bDrop)
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecOpenMax.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecOpenMax.h
index 67cc235..b7c0c1b 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecOpenMax.h
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecOpenMax.h
@@ -22,6 +22,7 @@
 #if defined(HAVE_LIBOPENMAX)
 
 #include "DVDVideoCodec.h"
+#include "OpenMaxVideo.h"
 
 class COpenMaxVideo;
 class CDVDVideoCodecOpenMax : public CDVDVideoCodec
@@ -42,7 +43,7 @@ class CDVDVideoCodecOpenMax : public CDVDVideoCodec
   virtual const char* GetName(void);
   
 protected:
-  COpenMaxVideo     *m_omx_decoder;
+  OpenMaxVideoPtr m_omx_decoder;
 };
 
 #endif
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp
index aca2e0d..29b5bb9 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp
@@ -126,6 +126,7 @@ COpenMaxVideo::COpenMaxVideo()
   m_egl_buffer_count = 0;
 
   m_port_settings_changed = false;
+  m_finished = false;
   m_pFormatName = "omx-xxxx";
 }
 
@@ -134,6 +135,7 @@ COpenMaxVideo::~COpenMaxVideo()
   #if defined(OMX_DEBUG_VERBOSE)
   CLog::Log(LOGDEBUG, "%s::%s %p", CLASSNAME, __func__, this);
   #endif
+  assert(m_finished);
   if (m_omx_decoder.IsInitialized())
   {
     if (m_omx_tunnel.IsInitialized())
@@ -149,7 +151,7 @@ COpenMaxVideo::~COpenMaxVideo()
   pthread_mutex_destroy(&m_omx_output_mutex);
 }
 
-bool COpenMaxVideo::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options)
+bool COpenMaxVideo::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options, OpenMaxVideoPtr myself)
 {
   #if defined(OMX_DEBUG_VERBOSE)
   CLog::Log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
@@ -161,6 +163,7 @@ bool COpenMaxVideo::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options)
 
   OMX_ERRORTYPE omx_err = OMX_ErrorNone;
 
+  m_myself = myself;
   m_decoded_width  = hints.width;
   m_decoded_height = hints.height;
 
@@ -331,6 +334,15 @@ void COpenMaxVideo::Dispose()
   #if defined(OMX_DEBUG_VERBOSE)
   CLog::Log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
   #endif
+  // we are happy to exit, but let last shared pointer being deleted trigger the destructor
+  bool done = false;
+  pthread_mutex_lock(&m_omx_output_mutex);
+  if (m_omx_output_busy.empty())
+    done = true;
+  m_finished = true;
+  pthread_mutex_unlock(&m_omx_output_mutex);
+  if (done)
+    m_myself.reset();
 }
 
 void COpenMaxVideo::SetDropState(bool bDrop)
@@ -752,6 +764,13 @@ void COpenMaxVideo::ReleaseOpenMaxBuffer(COpenMaxVideoBuffer *buffer)
   m_omx_output_busy.erase(std::remove(m_omx_output_busy.begin(), m_omx_output_busy.end(), buffer), m_omx_output_busy.end());
   pthread_mutex_unlock(&m_omx_output_mutex);
   ReturnOpenMaxBuffer(buffer);
+  bool done = false;
+  pthread_mutex_lock(&m_omx_output_mutex);
+  if (m_finished && m_omx_output_busy.empty())
+    done = true;
+  pthread_mutex_unlock(&m_omx_output_mutex);
+  if (done)
+    m_myself.reset();
 }
 
 bool COpenMaxVideo::GetPicture(DVDVideoPicture* pDvdVideoPicture)
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.h
index 9079c13..0975e8a 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.h
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.h
@@ -43,6 +43,7 @@ typedef struct omx_demux_packet {
 } omx_demux_packet;
 
 class COpenMaxVideo;
+typedef boost::shared_ptr<COpenMaxVideo> OpenMaxVideoPtr;
 // an omx egl video frame
 class COpenMaxVideoBuffer
 {
@@ -75,7 +76,7 @@ class COpenMaxVideo
   virtual ~COpenMaxVideo();
 
   // Required overrides
-  virtual bool Open(CDVDStreamInfo &hints, CDVDCodecOptions &options);
+  virtual bool Open(CDVDStreamInfo &hints, CDVDCodecOptions &options, OpenMaxVideoPtr myself);
   virtual void Dispose(void);
   virtual int  Decode(uint8_t *pData, int iSize, double dts, double pts);
   virtual void Reset(void);
@@ -112,9 +113,11 @@ class COpenMaxVideo
   int               m_decoded_width;
   int               m_decoded_height;
   unsigned int      m_egl_buffer_count;
+  bool              m_finished;
 
   bool m_port_settings_changed;
   const char        *m_pFormatName;
+  OpenMaxVideoPtr   m_myself;
 
   std::queue<double> m_dts_queue;
   std::queue<omx_demux_packet> m_demux_queue;
-- 
1.9.3


From 43aaae9490318a6cc33d5546df73cf4138b0779a Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Mon, 3 Feb 2014 23:11:31 +0000
Subject: [PATCH 028/102] [omxcodec] Fix for aspect ratio in non-square pixel
 modes

---
 xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp | 17 +++++++++++++++++
 xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.h   |  3 +++
 2 files changed, 20 insertions(+)

diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp
index 29b5bb9..7e23c87 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp
@@ -63,6 +63,7 @@ COpenMaxVideoBuffer::COpenMaxVideoBuffer(COpenMaxVideo *omv)
   index = 0;
   egl_image = 0;
   texture_id = 0;
+  m_aspect_ratio = 0.0f;
 }
 
 COpenMaxVideoBuffer::~COpenMaxVideoBuffer()
@@ -166,6 +167,8 @@ bool COpenMaxVideo::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options, OpenM
   m_myself = myself;
   m_decoded_width  = hints.width;
   m_decoded_height = hints.height;
+  m_forced_aspect_ratio = hints.forced_aspect;
+  m_aspect_ratio = hints.aspect;
 
   m_egl_display = g_Windowing.GetEGLDisplay();
   m_egl_context = g_Windowing.GetEGLContext();
@@ -435,6 +438,9 @@ bool COpenMaxVideo::PortSettingsChanged()
     CLog::Log(LOGERROR, "%s::%s - error m_omx_decoder.GetParameter(OMX_IndexParamBrcmPixelAspectRatio) omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
     return false;
   }
+  if (!m_forced_aspect_ratio && pixel_aspect.nX && pixel_aspect.nY)
+    m_aspect_ratio = (float)pixel_aspect.nX * port_def.format.video.nFrameWidth /
+      ((float)pixel_aspect.nY * port_def.format.video.nFrameHeight);
 
   if (m_port_settings_changed)
   {
@@ -800,6 +806,16 @@ bool COpenMaxVideo::GetPicture(DVDVideoPicture* pDvdVideoPicture)
     pDvdVideoPicture->iDisplayWidth  = m_decoded_width;
     pDvdVideoPicture->iDisplayHeight = m_decoded_height;
 
+    if (buffer->m_aspect_ratio > 0.0 && !m_forced_aspect_ratio)
+    {
+      pDvdVideoPicture->iDisplayWidth  = ((int)lrint(pDvdVideoPicture->iHeight * buffer->m_aspect_ratio)) & -3;
+      if (pDvdVideoPicture->iDisplayWidth > pDvdVideoPicture->iWidth)
+      {
+        pDvdVideoPicture->iDisplayWidth  = pDvdVideoPicture->iWidth;
+        pDvdVideoPicture->iDisplayHeight = ((int)lrint(pDvdVideoPicture->iWidth / buffer->m_aspect_ratio)) & -3;
+      }
+    }
+
 #ifdef DTS_QUEUE
     if (!m_dts_queue.empty())
     {
@@ -853,6 +869,7 @@ OMX_ERRORTYPE COpenMaxVideo::DecoderFillBufferDone(
 
   // queue output omx buffer to ready list.
   pthread_mutex_lock(&m_omx_output_mutex);
+  buffer->m_aspect_ratio = m_aspect_ratio;
   m_omx_output_ready.push(buffer);
   pthread_mutex_unlock(&m_omx_output_mutex);
 
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.h
index 0975e8a..9138a20 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.h
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.h
@@ -54,6 +54,7 @@ class COpenMaxVideoBuffer
   OMX_BUFFERHEADERTYPE *omx_buffer;
   int width;
   int height;
+  float m_aspect_ratio;
   int index;
 
   // used for egl based rendering if active
@@ -114,6 +115,8 @@ class COpenMaxVideo
   int               m_decoded_height;
   unsigned int      m_egl_buffer_count;
   bool              m_finished;
+  float             m_aspect_ratio;
+  bool              m_forced_aspect_ratio;
 
   bool m_port_settings_changed;
   const char        *m_pFormatName;
-- 
1.9.3


From c67d107b1e9fdb03ed4c9fa812b7dc41d56e0473 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Mon, 3 Feb 2014 23:19:22 +0000
Subject: [PATCH 029/102] [omxcodec] Report error when codec not enabled

---
 xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp | 10 +++++++++-
 1 file changed, 9 insertions(+), 1 deletion(-)

diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp
index 7e23c87..2ae722b 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp
@@ -43,6 +43,7 @@
 #include <IL/OMX_Image.h>
 
 #include "cores/omxplayer/OMXImage.h"
+#include "linux/RBP.h"
 
 #define DTS_QUEUE
 
@@ -155,7 +156,7 @@ COpenMaxVideo::~COpenMaxVideo()
 bool COpenMaxVideo::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options, OpenMaxVideoPtr myself)
 {
   #if defined(OMX_DEBUG_VERBOSE)
-  CLog::Log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
+  CLog::Log(LOGDEBUG, "%s::%s useomx:%d software:%d", CLASSNAME, __func__, CSettings::Get().GetBool("videoplayer.useomx"), hints.software);
   #endif
 
   // we always qualify even if DVDFactoryCodec does this too.
@@ -232,6 +233,13 @@ bool COpenMaxVideo::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options, OpenM
     break;
   }
 
+  if ( (m_codingType == OMX_VIDEO_CodingMPEG2 && !g_RBP.GetCodecMpg2() ) ||
+       (m_codingType == OMX_VIDEO_CodingWMV   && !g_RBP.GetCodecWvc1() ) )
+  {
+    CLog::Log(LOGWARNING, "%s::%s Codec %s is not supported\n", CLASSNAME, __func__, m_pFormatName);
+    return false;
+  }
+
   // initialize OpenMAX.
   if (!m_omx_decoder.Initialize("OMX.broadcom.video_decode", OMX_IndexParamVideoInit))
   {
-- 
1.9.3


From 84fd054b518469989f566fb5a007b1a3fbcb8f8e Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Tue, 4 Feb 2014 17:29:37 +0000
Subject: [PATCH 030/102] [omxcodec] Add deinterlace support

---
 xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp    |   2 +-
 .../dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp     | 106 ++++++++++++++++++---
 .../cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.h |   9 +-
 3 files changed, 103 insertions(+), 14 deletions(-)

diff --git a/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp b/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp
index b8af8d0..51f56aa 100644
--- a/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp
+++ b/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp
@@ -2605,7 +2605,7 @@ bool CLinuxRendererGLES::Supports(EDEINTERLACEMODE mode)
     return true;
 
   if(m_renderMethod & RENDER_OMXEGL)
-    return false;
+    return true;
 
   if(m_renderMethod & RENDER_EGLIMG)
     return false;
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp
index 2ae722b..fbf1458 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp
@@ -33,6 +33,7 @@
 #include "utils/log.h"
 #include "utils/TimeUtils.h"
 #include "settings/Settings.h"
+#include "settings/MediaSettings.h"
 #include "ApplicationMessenger.h"
 #include "Application.h"
 #include "threads/Atomics.h"
@@ -130,6 +131,10 @@ COpenMaxVideo::COpenMaxVideo()
   m_port_settings_changed = false;
   m_finished = false;
   m_pFormatName = "omx-xxxx";
+
+  m_deinterlace = false;
+  m_deinterlace_request = VS_DEINTERLACEMODE_OFF;
+  m_deinterlace_second_field = false;
 }
 
 COpenMaxVideo::~COpenMaxVideo()
@@ -140,13 +145,17 @@ COpenMaxVideo::~COpenMaxVideo()
   assert(m_finished);
   if (m_omx_decoder.IsInitialized())
   {
-    if (m_omx_tunnel.IsInitialized())
-      m_omx_tunnel.Deestablish();
+    if (m_omx_tunnel_decoder.IsInitialized())
+      m_omx_tunnel_decoder.Deestablish();
+    if (m_omx_tunnel_image_fx.IsInitialized())
+      m_omx_tunnel_image_fx.Deestablish();
 
     StopDecoder();
 
     if (m_omx_egl_render.IsInitialized())
       m_omx_egl_render.Deinitialize();
+    if (m_omx_image_fx.IsInitialized())
+      m_omx_image_fx.Deinitialize();
     if (m_omx_decoder.IsInitialized())
       m_omx_decoder.Deinitialize();
   }
@@ -165,6 +174,8 @@ bool COpenMaxVideo::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options, OpenM
 
   OMX_ERRORTYPE omx_err = OMX_ErrorNone;
 
+  m_deinterlace_request = CMediaSettings::Get().GetCurrentVideoSettings().m_DeinterlaceMode;
+
   m_myself = myself;
   m_decoded_width  = hints.width;
   m_decoded_height = hints.height;
@@ -467,6 +478,49 @@ bool COpenMaxVideo::PortSettingsChanged()
     return false;
   }
 
+  OMX_CONFIG_INTERLACETYPE interlace;
+  OMX_INIT_STRUCTURE(interlace);
+  interlace.nPortIndex = m_omx_decoder.GetOutputPort();
+  omx_err = m_omx_decoder.GetConfig(OMX_IndexConfigCommonInterlace, &interlace);
+
+  if (m_deinterlace_request == VS_DEINTERLACEMODE_FORCE)
+    m_deinterlace = true;
+  else if (m_deinterlace_request == VS_DEINTERLACEMODE_OFF)
+    m_deinterlace = false;
+  else
+    m_deinterlace = interlace.eMode != OMX_InterlaceProgressive;
+
+  CLog::Log(LOGDEBUG, "%s::%s - %dx%d@%.2f interlace:%d deinterlace:%d",
+  CLASSNAME, __func__, port_def.format.video.nFrameWidth, port_def.format.video.nFrameHeight, port_def.format.video.xFramerate / (float) (1 << 16),
+      interlace.eMode, m_deinterlace);
+
+  if (m_deinterlace)
+  {
+    if (!m_omx_image_fx.Initialize("OMX.broadcom.image_fx", OMX_IndexParamImageInit))
+    {
+      CLog::Log(LOGERROR, "%s::%s error m_omx_image_fx.Initialize", CLASSNAME, __func__);
+      return false;
+    }
+  }
+
+  if (m_deinterlace)
+  {
+    OMX_CONFIG_IMAGEFILTERPARAMSTYPE image_filter;
+    OMX_INIT_STRUCTURE(image_filter);
+
+    image_filter.nPortIndex = m_omx_image_fx.GetOutputPort();
+    image_filter.nNumParams = 1;
+    image_filter.nParams[0] = 3;
+    image_filter.eImageFilter = OMX_ImageFilterDeInterlaceAdvanced;
+
+    omx_err = m_omx_image_fx.SetConfig(OMX_IndexConfigCommonImageFilterParameters, &image_filter);
+    if (omx_err != OMX_ErrorNone)
+    {
+      CLog::Log(LOGERROR, "%s::%s - OMX_IndexConfigCommonImageFilterParameters omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+      return false;
+    }
+  }
+
   OMX_CALLBACKTYPE callbacks = { NULL, NULL, DecoderFillBufferDoneCallback };
   if (!m_omx_egl_render.Initialize("OMX.broadcom.egl_render", OMX_IndexParamVideoInit, &callbacks))
   {
@@ -487,19 +541,40 @@ bool COpenMaxVideo::PortSettingsChanged()
 
   m_omx_egl_render.ResetEos();
 
-  CLog::Log(LOGDEBUG, "%s::%s - %dx%d@%.2f interlace:%d deinterlace:%d", CLASSNAME, __func__,
-      port_def.format.video.nFrameWidth, port_def.format.video.nFrameHeight,
-      port_def.format.video.xFramerate / (float)(1<<16), 0,0);
-
-  m_omx_tunnel.Initialize(&m_omx_decoder, m_omx_decoder.GetOutputPort(), &m_omx_egl_render, m_omx_egl_render.GetInputPort());
+  if (m_deinterlace)
+  {
+    m_omx_tunnel_decoder.Initialize(&m_omx_decoder, m_omx_decoder.GetOutputPort(), &m_omx_image_fx, m_omx_image_fx.GetInputPort());
+    m_omx_tunnel_image_fx.Initialize(&m_omx_image_fx, m_omx_image_fx.GetOutputPort(), &m_omx_egl_render, m_omx_egl_render.GetInputPort());
+  }
+  else
+  {
+    m_omx_tunnel_decoder.Initialize(&m_omx_decoder, m_omx_decoder.GetOutputPort(), &m_omx_egl_render, m_omx_egl_render.GetInputPort());
+  }
 
-  omx_err = m_omx_tunnel.Establish();
+  omx_err = m_omx_tunnel_decoder.Establish();
   if (omx_err != OMX_ErrorNone)
   {
-    CLog::Log(LOGERROR, "%s::%s - m_omx_tunnel.Establish omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+    CLog::Log(LOGERROR, "%s::%s - m_omx_tunnel_decoder.Establish omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
     return false;
   }
 
+  if (m_deinterlace)
+  {
+    omx_err = m_omx_tunnel_image_fx.Establish();
+    if (omx_err != OMX_ErrorNone)
+    {
+      CLog::Log(LOGERROR, "%s::%s - m_omx_tunnel_image_fx.Establish omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+      return false;
+    }
+    omx_err = m_omx_image_fx.SetStateForComponent(OMX_StateExecuting);
+    if (omx_err != OMX_ErrorNone)
+    {
+      CLog::Log(LOGERROR, "%s::%s - m_omx_image_fx.SetStateForComponent omx_err(0x%08x)",
+      CLASSNAME, __func__, omx_err);
+      return false;
+    }
+  }
+
   // Obtain the information about the output port.
   OMX_PARAM_PORTDEFINITIONTYPE port_format;
   OMX_INIT_STRUCTURE(port_format);
@@ -724,8 +799,12 @@ void COpenMaxVideo::Reset(void)
   #if defined(OMX_DEBUG_VERBOSE)
   CLog::Log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
   #endif
-  m_omx_egl_render.FlushAll();
-  m_omx_decoder.FlushAll();
+  if (m_omx_egl_render.IsInitialized())
+    m_omx_egl_render.FlushAll();
+  if (m_omx_image_fx.IsInitialized())
+    m_omx_image_fx.FlushAll();
+  if (m_omx_decoder.IsInitialized())
+    m_omx_decoder.FlushAll();
   // blow all ready video frames
   while (!m_omx_output_ready.empty())
   {
@@ -825,11 +904,14 @@ bool COpenMaxVideo::GetPicture(DVDVideoPicture* pDvdVideoPicture)
     }
 
 #ifdef DTS_QUEUE
-    if (!m_dts_queue.empty())
+    if (!m_deinterlace_second_field)
     {
+      assert(!m_dts_queue.empty());
       pDvdVideoPicture->dts = m_dts_queue.front();
       m_dts_queue.pop();
     }
+    if (m_deinterlace)
+      m_deinterlace_second_field = !m_deinterlace_second_field;
 #endif
     // nTimeStamp is in microseconds
     double ts = FromOMXTime(buffer->omx_buffer->nTimeStamp);
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.h
index 9138a20..c8ad4d8 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.h
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.h
@@ -31,6 +31,7 @@
 #include "cores/dvdplayer/DVDStreamInfo.h"
 #include "DVDVideoCodec.h"
 #include "threads/Event.h"
+#include "xbmc/settings/VideoSettings.h"
 
 #include <queue>
 #include <semaphore.h>
@@ -136,11 +137,17 @@ class COpenMaxVideo
 
   // Components
   COMXCoreComponent m_omx_decoder;
+  COMXCoreComponent m_omx_image_fx;
   COMXCoreComponent m_omx_egl_render;
 
-  COMXCoreTunel     m_omx_tunnel;
+  COMXCoreTunel     m_omx_tunnel_decoder;
+  COMXCoreTunel     m_omx_tunnel_image_fx;
   OMX_VIDEO_CODINGTYPE m_codingType;
 
+  bool              m_deinterlace;
+  EDEINTERLACEMODE  m_deinterlace_request;
+  bool              m_deinterlace_second_field;
+
   bool PortSettingsChanged();
   bool SendDecoderConfig(uint8_t *extradata, int extrasize);
   bool NaluFormatStartCodes(enum AVCodecID codec, uint8_t *extradata, int extrasize);
-- 
1.9.3


From f64991ff2b74d5600cc7dd1e2959fc4b2a4f60bc Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Wed, 5 Feb 2014 11:46:33 +0000
Subject: [PATCH 031/102] [rbp/settings] Allow av sync type to be enabled

It works for dvdplayer
---
 system/settings/rbp.xml | 7 -------
 1 file changed, 7 deletions(-)

diff --git a/system/settings/rbp.xml b/system/settings/rbp.xml
index 2b7d0a6..1429256 100644
--- a/system/settings/rbp.xml
+++ b/system/settings/rbp.xml
@@ -1,13 +1,6 @@
 <?xml version="1.0" encoding="utf-8" ?>
 <settings>
   <section id="videos">
-    <category id="videoplayer">
-      <group id="2">
-        <setting id="videoplayer.synctype">
-          <visible>false</visible>
-        </setting>
-      </group>
-    </category>
     <category id="videoacceleration">
       <group id="1">
         <visible>false</visible>
-- 
1.9.3


From 4dfa451d32f3302babeaefdbe7b6d29bb65353d4 Mon Sep 17 00:00:00 2001
From: Ben Avison <bavison@riscosopen.org>
Date: Thu, 1 May 2014 16:28:39 +0100
Subject: [PATCH 032/102] Improved file buffering in CArchive

Even though memcpy is typically inlined by the compiler into byte/word loads
and stores (at least for release builds), the frequency with which 1, 2 and 4
byte loads/stores are encountered in cases where the size is *not*
determinable at compile time is still high enough that it's worth handling
these specially. On the ARM1176JZF-S in the Raspberry Pi, this improves the
total time to open a library (in the case where it's fetched from a CArchive)
by around 4%.

It should be noted that this code uses 16-bit and 32-bit word loads and
stores that are not necessarily aligned to their respective widths. It is
possible that there are some architectures out there which do not support
this, although all ARMs since ARMv6 have supported it (and ARMs earlier than
that are probably not powerful enough to be good targets for XBMC).
---
 xbmc/utils/Archive.h | 16 ++++++++++++++++
 1 file changed, 16 insertions(+)

diff --git a/xbmc/utils/Archive.h b/xbmc/utils/Archive.h
index 6ed0f8f..8506d95 100644
--- a/xbmc/utils/Archive.h
+++ b/xbmc/utils/Archive.h
@@ -154,9 +154,17 @@ class CArchive
      * than waiting until we attempt to put more data into an already full buffer */
     if (m_BufferRemain > size)
     {
+      switch (size)
+      {
+      case 1: *m_BufferPos++ = *ptr; m_BufferRemain--; break;
+      case 2: *(uint16_t *) m_BufferPos = *(const uint16_t *) ptr; m_BufferPos += 2; m_BufferRemain -= 2; break;
+      case 4: *(uint32_t *) m_BufferPos = *(const uint32_t *) ptr; m_BufferPos += 4; m_BufferRemain -= 4; break;
+      default:
       memcpy(m_BufferPos, ptr, size);
       m_BufferPos += size;
       m_BufferRemain -= size;
+      break;
+      }
       return *this;
     }
     else
@@ -171,9 +179,17 @@ class CArchive
     /* Note, refilling the buffer is deferred until we know we need to read more from it */
     if (m_BufferRemain >= size)
     {
+      switch (size)
+      {
+      case 1: *ptr = *m_BufferPos++; m_BufferRemain--; break;
+      case 2: *(uint16_t *) ptr = *(const uint16_t *) m_BufferPos; m_BufferPos += 2; m_BufferRemain -= 2; break;
+      case 4: *(uint32_t *) ptr = *(const uint32_t *) m_BufferPos; m_BufferPos += 4; m_BufferRemain -= 4; break;
+      default:
       memcpy(ptr, m_BufferPos, size);
       m_BufferPos += size;
       m_BufferRemain -= size;
+      break;
+      }
       return *this;
     }
     else
-- 
1.9.3


From e1da30ac65ceedef2eb5bf3e795507f8f3c593b6 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Sun, 16 Feb 2014 17:38:05 +0000
Subject: [PATCH 033/102] [omxcodec] Only do essential calls in texture thread
 [omxcodec] Fix for files with no valid pts values. [omxcodec] Fix stall on
 seek/trickplay - need to reset start flag [omxcodec] Make sure we have a
 valid context when video decode starts before first fanart is decoded
 [omxcodec] More care with dropping frames quickly

---
 .../dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp     | 127 ++++++++++++++-------
 .../cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.h |  14 +--
 2 files changed, 89 insertions(+), 52 deletions(-)

diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp
index fbf1458..71d19af 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp
@@ -55,6 +55,9 @@
 
 #define CLASSNAME "COpenMaxVideo"
 
+#define OMX_BUFFERFLAG_PTS_INVALID (1<<28)
+#define OMX_BUFFERFLAG_DROPPED     (1<<29)
+
 COpenMaxVideoBuffer::COpenMaxVideoBuffer(COpenMaxVideo *omv)
     : m_omv(omv), m_refs(0)
 {
@@ -120,7 +123,9 @@ void COpenMaxVideoBuffer::Sync()
 
 COpenMaxVideo::COpenMaxVideo()
 {
+  #if defined(OMX_DEBUG_VERBOSE)
   CLog::Log(LOGDEBUG, "%s::%s %p", CLASSNAME, __func__, this);
+  #endif
   pthread_mutex_init(&m_omx_output_mutex, NULL);
 
   m_drop_state = false;
@@ -135,6 +140,7 @@ COpenMaxVideo::COpenMaxVideo()
   m_deinterlace = false;
   m_deinterlace_request = VS_DEINTERLACEMODE_OFF;
   m_deinterlace_second_field = false;
+  m_startframe = false;
 }
 
 COpenMaxVideo::~COpenMaxVideo()
@@ -182,8 +188,6 @@ bool COpenMaxVideo::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options, OpenM
   m_forced_aspect_ratio = hints.forced_aspect;
   m_aspect_ratio = hints.aspect;
 
-  m_egl_display = g_Windowing.GetEGLDisplay();
-  m_egl_context = g_Windowing.GetEGLContext();
   m_egl_buffer_count = 4;
 
   m_codingType = OMX_VIDEO_CodingUnused;
@@ -347,6 +351,7 @@ bool COpenMaxVideo::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options, OpenM
     return false;
 
   m_drop_state = false;
+  m_startframe = false;
 
   return true;
 }
@@ -375,6 +380,25 @@ void COpenMaxVideo::SetDropState(bool bDrop)
       CLASSNAME, __func__, bDrop);
 #endif
   m_drop_state = bDrop;
+  if (m_drop_state)
+  {
+    while (1)
+    {
+      COpenMaxVideoBuffer *buffer = NULL;
+      pthread_mutex_lock(&m_omx_output_mutex);
+      // fetch a output buffer and pop it off the ready list
+      if (!m_omx_output_ready.empty())
+      {
+        buffer = m_omx_output_ready.front();
+        m_omx_output_ready.pop();
+      }
+      pthread_mutex_unlock(&m_omx_output_mutex);
+      if (buffer)
+        ReturnOpenMaxBuffer(buffer);
+      else
+        break;
+    }
+  }
 }
 
 bool COpenMaxVideo::SendDecoderConfig(uint8_t *extradata, int extrasize)
@@ -713,10 +737,13 @@ int COpenMaxVideo::Decode(uint8_t* pData, int iSize, double dts, double pts)
 
       if (demuxer_bytes == 0)
         omx_buffer->nFlags |= OMX_BUFFERFLAG_ENDOFFRAME;
-      if (pts == DVD_NOPTS_VALUE)
+      // openmax doesn't like an unknown timestamp as first frame
+      if (pts == DVD_NOPTS_VALUE && m_startframe)
         omx_buffer->nFlags |= OMX_BUFFERFLAG_TIME_UNKNOWN;
+      if (pts == DVD_NOPTS_VALUE) // hijack an omx flag to indicate there wasn't a real timestamp - it will be returned with the picture (but otherwise ignored)
+        omx_buffer->nFlags |= OMX_BUFFERFLAG_PTS_INVALID;
       if (m_drop_state) // hijack an omx flag to signal this frame to be dropped - it will be returned with the picture (but otherwise ignored)
-        omx_buffer->nFlags |= OMX_BUFFERFLAG_DATACORRUPT;
+        omx_buffer->nFlags |= OMX_BUFFERFLAG_DECODEONLY | OMX_BUFFERFLAG_DROPPED;
 
 #if defined(OMX_DEBUG_VERBOSE)
       CLog::Log(LOGDEBUG, "%s::%s - %-6d dts:%.3f pts:%.3f flags:%x",
@@ -731,10 +758,14 @@ int COpenMaxVideo::Decode(uint8_t* pData, int iSize, double dts, double pts)
       }
       if (demuxer_bytes == 0)
       {
+        m_startframe = true;
 #ifdef DTS_QUEUE
-        // only push if we are successful with feeding OMX_EmptyThisBuffer
-        m_dts_queue.push(dts);
-        assert(m_dts_queue.size() < 32);
+        if (!m_drop_state)
+        {
+          // only push if we are successful with feeding OMX_EmptyThisBuffer
+          m_dts_queue.push(dts);
+          assert(m_dts_queue.size() < 32);
+        }
 #endif
         if (buffer_to_free)
         {
@@ -806,15 +837,8 @@ void COpenMaxVideo::Reset(void)
   if (m_omx_decoder.IsInitialized())
     m_omx_decoder.FlushAll();
   // blow all ready video frames
-  while (!m_omx_output_ready.empty())
-  {
-    pthread_mutex_lock(&m_omx_output_mutex);
-    COpenMaxVideoBuffer *pic = m_omx_output_ready.front();
-    m_omx_output_ready.pop();
-    pthread_mutex_unlock(&m_omx_output_mutex);
-    // return the omx buffer back to OpenMax to fill.
-    ReturnOpenMaxBuffer(pic);
-  }
+  SetDropState(true);
+  SetDropState(false);
 #ifdef DTS_QUEUE
   while (!m_dts_queue.empty())
     m_dts_queue.pop();
@@ -822,6 +846,7 @@ void COpenMaxVideo::Reset(void)
 
   while (!m_demux_queue.empty())
     m_demux_queue.pop();
+  m_startframe = false;
 }
 
 
@@ -914,17 +939,17 @@ bool COpenMaxVideo::GetPicture(DVDVideoPicture* pDvdVideoPicture)
       m_deinterlace_second_field = !m_deinterlace_second_field;
 #endif
     // nTimeStamp is in microseconds
-    double ts = FromOMXTime(buffer->omx_buffer->nTimeStamp);
-    pDvdVideoPicture->pts = (ts == 0) ? DVD_NOPTS_VALUE : ts;
+    pDvdVideoPicture->pts = FromOMXTime(buffer->omx_buffer->nTimeStamp);
     pDvdVideoPicture->openMaxBuffer->Acquire();
     pDvdVideoPicture->iFlags  = DVP_FLAG_ALLOCATED;
-    if (buffer->omx_buffer->nFlags & OMX_BUFFERFLAG_DATACORRUPT)
-      pDvdVideoPicture->iFlags |= DVP_FLAG_DROPPED;
+    if (buffer->omx_buffer->nFlags & OMX_BUFFERFLAG_PTS_INVALID)
+      pDvdVideoPicture->pts = DVD_NOPTS_VALUE;
 #if defined(OMX_DEBUG_VERBOSE)
     CLog::Log(LOGINFO, "%s::%s dts:%.3f pts:%.3f flags:%x:%x openMaxBuffer:%p omx_buffer:%p egl_image:%p texture_id:%x", CLASSNAME, __func__,
         pDvdVideoPicture->dts == DVD_NOPTS_VALUE ? 0.0 : pDvdVideoPicture->dts*1e-6, pDvdVideoPicture->pts == DVD_NOPTS_VALUE ? 0.0 : pDvdVideoPicture->pts*1e-6,
         pDvdVideoPicture->iFlags, buffer->omx_buffer->nFlags, pDvdVideoPicture->openMaxBuffer, pDvdVideoPicture->openMaxBuffer->omx_buffer, pDvdVideoPicture->openMaxBuffer->egl_image, pDvdVideoPicture->openMaxBuffer->texture_id);
 #endif
+    assert(!(buffer->omx_buffer->nFlags & (OMX_BUFFERFLAG_DECODEONLY | OMX_BUFFERFLAG_DROPPED)));
   }
   else
   {
@@ -953,10 +978,11 @@ OMX_ERRORTYPE COpenMaxVideo::DecoderFillBufferDone(
   COpenMaxVideoBuffer *buffer = (COpenMaxVideoBuffer*)pBuffer->pAppPrivate;
 
   #if defined(OMX_DEBUG_VERBOSE)
-  CLog::Log(LOGDEBUG, "%s::%s - %p (%p,%p) buffer_size(%u), pts:%.3f",
-    CLASSNAME, __func__, buffer, pBuffer, buffer->omx_buffer, pBuffer->nFilledLen, (double)FromOMXTime(buffer->omx_buffer->nTimeStamp)*1e-6);
+  CLog::Log(LOGDEBUG, "%s::%s - %p (%p,%p) buffer_size(%u), pts:%.3f flags:%x",
+    CLASSNAME, __func__, buffer, pBuffer, buffer->omx_buffer, pBuffer->nFilledLen, (double)FromOMXTime(buffer->omx_buffer->nTimeStamp)*1e-6, buffer->omx_buffer->nFlags);
   #endif
 
+  assert(!(buffer->omx_buffer->nFlags & (OMX_BUFFERFLAG_DECODEONLY | OMX_BUFFERFLAG_DROPPED)));
   // queue output omx buffer to ready list.
   pthread_mutex_lock(&m_omx_output_mutex);
   buffer->m_aspect_ratio = m_aspect_ratio;
@@ -1000,41 +1026,60 @@ OMX_ERRORTYPE COpenMaxVideo::FreeOMXInputBuffers(void)
   return(omx_err);
 }
 
-bool COpenMaxVideo::CallbackAllocOMXEGLTextures(void *userdata)
+bool COpenMaxVideo::CallbackAllocOMXEGLTextures(EGLDisplay egl_display, EGLContext egl_context, void *userdata)
 {
   COpenMaxVideo *omx = static_cast<COpenMaxVideo*>(userdata);
-  return omx->AllocOMXOutputEGLTextures() == OMX_ErrorNone;
+  return omx->AllocOMXOutputEGLTextures(egl_display, egl_context) == OMX_ErrorNone;
 }
 
-bool COpenMaxVideo::CallbackFreeOMXEGLTextures(void *userdata)
+bool COpenMaxVideo::CallbackFreeOMXEGLTextures(EGLDisplay egl_display, EGLContext egl_context, void *userdata)
 {
   COpenMaxVideo *omx = static_cast<COpenMaxVideo*>(userdata);
-  return omx->FreeOMXOutputEGLTextures() == OMX_ErrorNone;
+  return omx->FreeOMXOutputEGLTextures(egl_display, egl_context) == OMX_ErrorNone;
 }
 
 bool COpenMaxVideo::AllocOMXOutputBuffers(void)
 {
-  return g_OMXImage.SendMessage(CallbackAllocOMXEGLTextures, (void *)this);
+  pthread_mutex_lock(&m_omx_output_mutex);
+  for (size_t i = 0; i < m_egl_buffer_count; i++)
+  {
+    COpenMaxVideoBuffer *egl_buffer = new COpenMaxVideoBuffer(this);
+    egl_buffer->width  = m_decoded_width;
+    egl_buffer->height = m_decoded_height;
+    egl_buffer->index = i;
+    m_omx_output_buffers.push_back(egl_buffer);
+  }
+  bool ret = g_OMXImage.SendMessage(CallbackAllocOMXEGLTextures, (void *)this);
+  pthread_mutex_unlock(&m_omx_output_mutex);
+  return ret;
 }
 
 bool COpenMaxVideo::FreeOMXOutputBuffers(void)
 {
-  return g_OMXImage.SendMessage(CallbackFreeOMXEGLTextures, (void *)this);
+  pthread_mutex_lock(&m_omx_output_mutex);
+  bool ret = g_OMXImage.SendMessage(CallbackFreeOMXEGLTextures, (void *)this);
+
+  for (size_t i = 0; i < m_omx_output_buffers.size(); i++)
+  {
+    COpenMaxVideoBuffer *egl_buffer = m_omx_output_buffers[i];
+    delete egl_buffer;
+  }
+
+  m_omx_output_buffers.clear();
+  pthread_mutex_unlock(&m_omx_output_mutex);
+  return ret;
 }
 
-OMX_ERRORTYPE COpenMaxVideo::AllocOMXOutputEGLTextures(void)
+OMX_ERRORTYPE COpenMaxVideo::AllocOMXOutputEGLTextures(EGLDisplay egl_display, EGLContext egl_context)
 {
   OMX_ERRORTYPE omx_err = OMX_ErrorNone;
   EGLint attrib = EGL_NONE;
-  COpenMaxVideoBuffer *egl_buffer;
 
   glActiveTexture(GL_TEXTURE0);
 
   for (size_t i = 0; i < m_egl_buffer_count; i++)
   {
-    egl_buffer = new COpenMaxVideoBuffer(this);
-    egl_buffer->width  = m_decoded_width;
-    egl_buffer->height = m_decoded_height;
+    COpenMaxVideoBuffer *egl_buffer = m_omx_output_buffers[i];
 
     glGenTextures(1, &egl_buffer->texture_id);
     glBindTexture(GL_TEXTURE_2D, egl_buffer->texture_id);
@@ -1057,8 +1102,8 @@ OMX_ERRORTYPE COpenMaxVideo::AllocOMXOutputEGLTextures(void)
 
     // create EGLImage from texture
     egl_buffer->egl_image = eglCreateImageKHR(
-      m_egl_display,
-      m_egl_context,
+      egl_display,
+      egl_context,
       EGL_GL_TEXTURE_2D_KHR,
       (EGLClientBuffer)(egl_buffer->texture_id),
       &attrib);
@@ -1067,7 +1112,6 @@ OMX_ERRORTYPE COpenMaxVideo::AllocOMXOutputEGLTextures(void)
       CLog::Log(LOGERROR, "%s::%s - ERROR creating EglImage", CLASSNAME, __func__);
       return(OMX_ErrorUndefined);
     }
-    egl_buffer->index = i;
 
     // tell decoder output port that it will be using EGLImage
     omx_err = m_omx_egl_render.UseEGLImage(
@@ -1078,7 +1122,6 @@ OMX_ERRORTYPE COpenMaxVideo::AllocOMXOutputEGLTextures(void)
         CLASSNAME, __func__, omx_err);
       return(omx_err);
     }
-    m_omx_output_buffers.push_back(egl_buffer);
 
     CLog::Log(LOGDEBUG, "%s::%s - Texture %p Width %d Height %d",
       CLASSNAME, __func__, egl_buffer->egl_image, egl_buffer->width, egl_buffer->height);
@@ -1086,26 +1129,22 @@ OMX_ERRORTYPE COpenMaxVideo::AllocOMXOutputEGLTextures(void)
   return omx_err;
 }
 
-OMX_ERRORTYPE COpenMaxVideo::FreeOMXOutputEGLTextures(void)
+OMX_ERRORTYPE COpenMaxVideo::FreeOMXOutputEGLTextures(EGLDisplay egl_display, EGLContext egl_context)
 {
   OMX_ERRORTYPE omx_err = OMX_ErrorNone;
-  COpenMaxVideoBuffer *egl_buffer;
 
   for (size_t i = 0; i < m_omx_output_buffers.size(); i++)
   {
-    egl_buffer = m_omx_output_buffers[i];
+    COpenMaxVideoBuffer *egl_buffer = m_omx_output_buffers[i];
     // tell decoder output port to stop using the EGLImage
     omx_err = m_omx_egl_render.FreeOutputBuffer(egl_buffer->omx_buffer);
     if (omx_err != OMX_ErrorNone)
       CLog::Log(LOGERROR, "%s::%s m_omx_egl_render.FreeOutputBuffer(%p) omx_err(0x%08x)", CLASSNAME, __func__, egl_buffer->omx_buffer, omx_err);
     // destroy egl_image
-    eglDestroyImageKHR(m_egl_display, egl_buffer->egl_image);
+    eglDestroyImageKHR(egl_display, egl_buffer->egl_image);
     // free texture
     glDeleteTextures(1, &egl_buffer->texture_id);
-    delete egl_buffer;
   }
-  m_omx_output_buffers.clear();
-
   return omx_err;
 }
 
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.h
index c8ad4d8..f234f6d 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.h
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.h
@@ -99,17 +99,13 @@ class COpenMaxVideo
   OMX_ERRORTYPE FreeOMXInputBuffers(void);
   bool AllocOMXOutputBuffers(void);
   bool FreeOMXOutputBuffers(void);
-  static bool CallbackAllocOMXEGLTextures(void*);
-  OMX_ERRORTYPE AllocOMXOutputEGLTextures(void);
-  static bool CallbackFreeOMXEGLTextures(void*);
-  OMX_ERRORTYPE FreeOMXOutputEGLTextures(void);
+  static bool CallbackAllocOMXEGLTextures(EGLDisplay egl_display, EGLContext egl_context, void*);
+  OMX_ERRORTYPE AllocOMXOutputEGLTextures(EGLDisplay egl_display, EGLContext egl_context);
+  static bool CallbackFreeOMXEGLTextures(EGLDisplay egl_display, EGLContext egl_context, void*);
+  OMX_ERRORTYPE FreeOMXOutputEGLTextures(EGLDisplay egl_display, EGLContext egl_context);
   OMX_ERRORTYPE StopDecoder(void);
   OMX_ERRORTYPE ReturnOpenMaxBuffer(COpenMaxVideoBuffer *buffer);
 
-  // EGL Resources
-  EGLDisplay        m_egl_display;
-  EGLContext        m_egl_context;
-
   // Video format
   bool              m_drop_state;
   int               m_decoded_width;
@@ -148,6 +144,8 @@ class COpenMaxVideo
   EDEINTERLACEMODE  m_deinterlace_request;
   bool              m_deinterlace_second_field;
 
+  bool              m_startframe;
+
   bool PortSettingsChanged();
   bool SendDecoderConfig(uint8_t *extradata, int extrasize);
   bool NaluFormatStartCodes(enum AVCodecID codec, uint8_t *extradata, int extrasize);
-- 
1.9.3


From dc58ddd6e648ba0be7a0b0c97fcff9fa10b799e5 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Sat, 8 Mar 2014 15:36:06 +0000
Subject: [PATCH 034/102] [hifiberry] Hack: force it to be recognised as IEC958
 capable to enable passthrough options

---
 xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp b/xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp
index 7cb049c..649bcb1 100644
--- a/xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp
+++ b/xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp
@@ -1296,6 +1296,10 @@ void CAESinkALSA::EnumerateDevice(AEDeviceInfoList &list, const std::string &dev
     if (snd_card_get_name(cardNr, &cardName) == 0)
       info.m_displayName = cardName;
 
+    // hack: hifiberry digi doesn't correctly report as iec958 device. Needs fixing in kernel driver
+    if (info.m_displayName == "snd_rpi_hifiberry_digi")
+      info.m_deviceType = AE_DEVTYPE_IEC958;
+
     if (info.m_deviceType == AE_DEVTYPE_HDMI && info.m_displayName.size() > 5 &&
         info.m_displayName.substr(info.m_displayName.size()-5) == " HDMI")
     {
-- 
1.9.3


From 05a408c7f18de9f3b47806223538b05c4ad23358 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Tue, 11 Mar 2014 18:50:23 +0000
Subject: [PATCH 035/102] [dvdplayer] Use inexact seeking like omxplayer

---
 xbmc/cores/dvdplayer/DVDPlayer.cpp | 11 +++++++++++
 1 file changed, 11 insertions(+)

diff --git a/xbmc/cores/dvdplayer/DVDPlayer.cpp b/xbmc/cores/dvdplayer/DVDPlayer.cpp
index d01089e..8122d2a 100644
--- a/xbmc/cores/dvdplayer/DVDPlayer.cpp
+++ b/xbmc/cores/dvdplayer/DVDPlayer.cpp
@@ -1892,7 +1892,11 @@ void CDVDPlayer::CheckAutoSceneSkip()
     /*
      * Seeking is NOT flushed so any content up to the demux point is retained when playing forwards.
      */
+#ifdef TARGET_RASPBERRY_PI
+    m_messenger.Put(new CDVDMsgPlayerSeek((int)seek, true, true, true, false, true));
+#else
     m_messenger.Put(new CDVDMsgPlayerSeek((int)seek, true, false, true, false, true));
+#endif
     /*
      * Seek doesn't always work reliably. Last physical seek time is recorded to prevent looping
      * if there was an error with seeking and it landed somewhere unexpected, perhaps back in the
@@ -1910,7 +1914,11 @@ void CDVDPlayer::CheckAutoSceneSkip()
     /*
      * Seeking is NOT flushed so any content up to the demux point is retained when playing forwards.
      */
+#ifdef TARGET_RASPBERRY_PI
+    m_messenger.Put(new CDVDMsgPlayerSeek(cut.end + 1, true, false, true, false, true));
+#else
     m_messenger.Put(new CDVDMsgPlayerSeek(cut.end + 1, true, false, true, false, true));
+#endif
     /*
      * Each commercial break is only skipped once so poorly detected commercial breaks can be
      * manually re-entered. Start and end are recorded to prevent looping and to allow seeking back
@@ -3111,9 +3119,12 @@ void CDVDPlayer::UpdateClockMaster()
 void CDVDPlayer::FlushBuffers(bool queued, double pts, bool accurate)
 {
   double startpts;
+#ifndef TARGET_RASPBERRY_PI
+  /* for now, ignore accurate flag as it discards keyframes and causes corrupt frames */
   if(accurate)
     startpts = pts;
   else
+#endif
     startpts = DVD_NOPTS_VALUE;
 
   /* call with demuxer pts */
-- 
1.9.3


From b27b04e4b4a043271832668f92b5119067d10c18 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Mon, 7 Apr 2014 18:19:32 +0100
Subject: [PATCH 036/102] [rbp/omxplayer] When opening a stream don't try to
 update gui so often

---
 xbmc/dialogs/GUIDialogBusy.cpp | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/xbmc/dialogs/GUIDialogBusy.cpp b/xbmc/dialogs/GUIDialogBusy.cpp
index e9ba7d3..0fdc3c2 100644
--- a/xbmc/dialogs/GUIDialogBusy.cpp
+++ b/xbmc/dialogs/GUIDialogBusy.cpp
@@ -64,7 +64,11 @@ bool CGUIDialogBusy::WaitOnEvent(CEvent &event, unsigned int displaytime /* = 10
     if (dialog)
     {
       dialog->Show();
+#ifdef TARGET_RASPBERRY_PI
+      while(!event.WaitMSec(100))
+#else
       while(!event.WaitMSec(1))
+#endif
       {
         g_windowManager.ProcessRenderLoop(false);
         if (allowCancel && dialog->IsCanceled())
-- 
1.9.3


From 1e240825884ba363c4f340e3bcefde0e18436098 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Mon, 7 Apr 2014 15:28:57 +0100
Subject: [PATCH 037/102] [omxcodec] Clamp video texture at edges to avoid
 image wrapping

---
 xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp b/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp
index 51f56aa..2929a37 100644
--- a/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp
+++ b/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp
@@ -1337,6 +1337,8 @@ void CLinuxRendererGLES::RenderOpenMax(int index, int field)
   GLint filter = m_scalingMethod == VS_SCALINGMETHOD_NEAREST ? GL_NEAREST : GL_LINEAR;
   glTexParameteri(m_textureTarget, GL_TEXTURE_MAG_FILTER, filter);
   glTexParameteri(m_textureTarget, GL_TEXTURE_MIN_FILTER, filter);
+  glTexParameteri(m_textureTarget, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+  glTexParameteri(m_textureTarget, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
 
   g_Windowing.EnableGUIShader(SM_TEXTURE_RGBA);
 
-- 
1.9.3


From a107ddc2b9b85151e7bf77ff7401531e55866eff Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Sun, 30 Mar 2014 15:54:34 +0100
Subject: [PATCH 038/102] [omxplayer] Make the sharpness control act as a
 sharpness control.

This fixes scaling kernel as Mitchell Netravali, and varies sharpness over range B=[5/3,0] C=[-1/3,1/2]
---
 xbmc/cores/omxplayer/OMXPlayer.cpp | 338 +++++++++++++++++++++++++++++++++++++
 1 file changed, 338 insertions(+)

diff --git a/xbmc/cores/omxplayer/OMXPlayer.cpp b/xbmc/cores/omxplayer/OMXPlayer.cpp
index a4cfa1f..668a72a 100644
--- a/xbmc/cores/omxplayer/OMXPlayer.cpp
+++ b/xbmc/cores/omxplayer/OMXPlayer.cpp
@@ -1043,6 +1043,334 @@ bool COMXPlayer::IsBetterStream(COMXCurrentStream& current, CDemuxStream* stream
   return false;
 }
 
+static void SetSharpness(float sharpness)
+{
+  const int16_t mitchells[][32] =
+  {
+      { // B=1.66667 C=-0.33333
+         0,  3,  8, 15, 24, 35, 49, 55, 70, 92,100,107,109,113,113,114,114,113,113,109,107,100, 92, 70, 55, 49, 35, 24, 15,  8,  3,  0,
+      },
+      { // B=1.64000 C=-0.32000
+         0,  3,  7, 14, 24, 34, 48, 54, 69, 91,100,107,111,114,116,116,116,116,114,111,107,100, 91, 69, 54, 48, 34, 24, 14,  7,  3,  0,
+      },
+      { // B=1.61333 C=-0.30667
+         0,  3,  7, 14, 23, 34, 47, 53, 68, 90, 99,107,112,115,118,118,118,118,115,112,107, 99, 90, 68, 53, 47, 34, 23, 14,  7,  3,  0,
+      },
+      { // B=1.58667 C=-0.29333
+         0,  2,  7, 14, 22, 33, 46, 52, 67, 89, 99,107,113,117,119,121,121,119,117,113,107, 99, 89, 67, 52, 46, 33, 22, 14,  7,  2,  0,
+      },
+      { // B=1.56000 C=-0.28000
+         0,  2,  7, 13, 22, 32, 45, 51, 66, 88, 98,107,114,119,121,123,123,121,119,114,107, 98, 88, 66, 51, 45, 32, 22, 13,  7,  2,  0,
+      },
+      { // B=1.53333 C=-0.26667
+         0,  2,  7, 12, 21, 31, 44, 50, 65, 87, 98,108,114,120,123,125,125,123,120,114,108, 98, 87, 65, 50, 44, 31, 21, 12,  7,  2,  0,
+      },
+      { // B=1.50667 C=-0.25333
+         0,  2,  6, 12, 20, 30, 43, 49, 64, 86, 98,108,116,122,125,127,127,125,122,116,108, 98, 86, 64, 49, 43, 30, 20, 12,  6,  2,  0,
+      },
+      { // B=1.48000 C=-0.24000
+         0,  2,  6, 12, 19, 29, 42, 47, 63, 85, 98,108,117,123,127,130,130,127,123,117,108, 98, 85, 63, 47, 42, 29, 19, 12,  6,  2,  0,
+      },
+      { // B=1.45333 C=-0.22667
+         0,  2,  6, 11, 19, 28, 41, 46, 62, 85, 97,108,118,125,129,132,132,129,125,118,108, 97, 85, 62, 46, 41, 28, 19, 11,  6,  2,  0,
+      },
+      { // B=1.42667 C=-0.21333
+         0,  2,  5, 11, 18, 28, 40, 45, 61, 84, 97,108,119,126,131,134,134,131,126,119,108, 97, 84, 61, 45, 40, 28, 18, 11,  5,  2,  0,
+      },
+      { // B=1.40000 C=-0.20000
+         0,  2,  5, 10, 18, 27, 39, 44, 60, 84, 96,109,119,127,134,136,136,134,127,119,109, 96, 84, 60, 44, 39, 27, 18, 10,  5,  2,  0,
+      },
+      { // B=1.37333 C=-0.18667
+         0,  1,  5, 10, 17, 26, 38, 43, 58, 82, 96,109,120,129,135,139,139,135,129,120,109, 96, 82, 58, 43, 38, 26, 17, 10,  5,  1,  0,
+      },
+      { // B=1.34667 C=-0.17333
+         0,  2,  4, 10, 16, 25, 37, 42, 57, 81, 96,109,121,131,137,141,141,137,131,121,109, 96, 81, 57, 42, 37, 25, 16, 10,  4,  2,  0,
+      },
+      { // B=1.32000 C=-0.16000
+         0,  1,  4,  9, 15, 24, 36, 41, 56, 81, 95,110,122,132,139,143,143,139,132,122,110, 95, 81, 56, 41, 36, 24, 15,  9,  4,  1,  0,
+      },
+      { // B=1.29333 C=-0.14667
+         0,  1,  4,  8, 15, 23, 35, 40, 55, 80, 95,110,123,133,141,146,146,141,133,123,110, 95, 80, 55, 40, 35, 23, 15,  8,  4,  1,  0,
+      },
+      { // B=1.26667 C=-0.13333
+         0,  1,  4,  8, 14, 22, 33, 38, 54, 79, 95,110,124,135,143,148,148,143,135,124,110, 95, 79, 54, 38, 33, 22, 14,  8,  4,  1,  0,
+      },
+      { // B=1.24000 C=-0.12000
+         0,  1,  4,  7, 14, 21, 33, 37, 53, 78, 94,110,125,136,145,150,150,145,136,125,110, 94, 78, 53, 37, 33, 21, 14,  7,  4,  1,  0,
+      },
+      { // B=1.21333 C=-0.10667
+         0,  1,  3,  7, 13, 20, 32, 36, 52, 77, 94,110,127,138,147,152,152,147,138,127,110, 94, 77, 52, 36, 32, 20, 13,  7,  3,  1,  0,
+      },
+      { // B=1.18667 C=-0.09333
+         0,  1,  3,  7, 12, 20, 30, 35, 51, 77, 93,111,125,140,149,155,155,149,140,125,111, 93, 77, 51, 35, 30, 20, 12,  7,  3,  1,  0,
+      },
+      { // B=1.16000 C=-0.08000
+         0,  1,  3,  6, 11, 19, 29, 34, 50, 76, 93,111,128,141,151,157,157,151,141,128,111, 93, 76, 50, 34, 29, 19, 11,  6,  3,  1,  0,
+      },
+      { // B=1.13333 C=-0.06667
+         0,  1,  3,  5, 11, 18, 28, 33, 49, 75, 93,111,129,143,153,159,159,153,143,129,111, 93, 75, 49, 33, 28, 18, 11,  5,  3,  1,  0,
+      },
+      { // B=1.10667 C=-0.05333
+         0,  1,  2,  5, 10, 17, 27, 32, 48, 74, 93,111,130,144,155,161,161,155,144,130,111, 93, 74, 48, 32, 27, 17, 10,  5,  2,  1,  0,
+      },
+      { // B=1.08000 C=-0.04000
+         0,  1,  2,  5,  9, 16, 26, 31, 46, 73, 92,112,130,145,157,164,164,157,145,130,112, 92, 73, 46, 31, 26, 16,  9,  5,  2,  1,  0,
+      },
+      { // B=1.05333 C=-0.02667
+         0,  0,  2,  4,  9, 15, 25, 29, 45, 72, 92,112,131,147,159,166,166,159,147,131,112, 92, 72, 45, 29, 25, 15,  9,  4,  2,  0,  0,
+      },
+      { // B=1.02667 C=-0.01333
+         0,  0,  1,  4,  8, 14, 24, 28, 44, 72, 92,112,132,148,161,168,168,161,148,132,112, 92, 72, 44, 28, 24, 14,  8,  4,  1,  0,  0,
+      },
+      { // B=1.00000 C=0.00000
+         0,  0,  1,  4,  7, 14, 23, 27, 43, 71, 91,112,133,150,163,170,170,163,150,133,112, 91, 71, 43, 27, 23, 14,  7,  4,  1,  0,  0,
+      },
+      { // B=0.97333 C=0.01333
+         0,  0,  1,  3,  7, 12, 22, 26, 42, 70, 91,113,133,152,165,173,173,165,152,133,113, 91, 70, 42, 26, 22, 12,  7,  3,  1,  0,  0,
+      },
+      { // B=0.94667 C=0.02667
+         0,  0,  1,  2,  6, 12, 21, 25, 41, 69, 90,113,135,153,167,175,175,167,153,135,113, 90, 69, 41, 25, 21, 12,  6,  2,  1,  0,  0,
+      },
+      { // B=0.92000 C=0.04000
+         0,  0,  0,  2,  5, 11, 20, 24, 40, 68, 90,113,136,154,169,177,177,169,154,136,113, 90, 68, 40, 24, 20, 11,  5,  2,  0,  0,  0,
+      },
+      { // B=0.89333 C=0.05333
+         0,  0,  0,  1,  5, 10, 19, 23, 39, 67, 90,114,136,156,171,179,179,171,156,136,114, 90, 67, 39, 23, 19, 10,  5,  1,  0,  0,  0,
+      },
+      { // B=0.86667 C=0.06667
+         0,  0,  0,  1,  4,  9, 18, 22, 38, 66, 89,114,137,157,173,182,182,173,157,137,114, 89, 66, 38, 22, 18,  9,  4,  1,  0,  0,  0,
+      },
+      { // B=0.84000 C=0.08000
+         0,  0, -1,  1,  3,  9, 17, 21, 37, 65, 89,114,138,159,175,184,184,175,159,138,114, 89, 65, 37, 21, 17,  9,  3,  1, -1,  0,  0,
+      },
+      { // B=0.81333 C=0.09333
+         0,  0, -1,  0,  3,  7, 16, 19, 36, 65, 89,114,139,160,177,186,186,177,160,139,114, 89, 65, 36, 19, 16,  7,  3,  0, -1,  0,  0,
+      },
+      { // B=0.78667 C=0.10667
+         0, -1, -1,  0,  2,  6, 15, 18, 35, 64, 88,115,139,162,179,188,188,179,162,139,115, 88, 64, 35, 18, 15,  6,  2,  0, -1, -1,  0,
+      },
+      { // B=0.76000 C=0.12000
+         0, -1, -1, -1,  1,  6, 14, 17, 33, 63, 88,115,141,163,181,191,191,181,163,141,115, 88, 63, 33, 17, 14,  6,  1, -1, -1, -1,  0,
+      },
+      { // B=0.73333 C=0.13333
+         0, -1, -1, -1,  0,  5, 13, 16, 32, 62, 87,115,142,165,183,193,193,183,165,142,115, 87, 62, 32, 16, 13,  5,  0, -1, -1, -1,  0,
+      },
+      { // B=0.70667 C=0.14667
+         0, -1, -1, -2,  0,  4, 12, 15, 31, 61, 87,115,143,166,185,195,195,185,166,143,115, 87, 61, 31, 15, 12,  4,  0, -2, -1, -1,  0,
+      },
+      { // B=0.68000 C=0.16000
+         0, -1, -2, -2, -1,  3, 11, 14, 30, 61, 87,116,142,168,187,197,197,187,168,142,116, 87, 61, 30, 14, 11,  3, -1, -2, -2, -1,  0,
+      },
+      { // B=0.65333 C=0.17333
+         0, -1, -2, -3, -1,  2, 10, 13, 29, 60, 86,116,144,169,189,200,200,189,169,144,116, 86, 60, 29, 13, 10,  2, -1, -3, -2, -1,  0,
+      },
+      { // B=0.62667 C=0.18667
+         0, -1, -3, -3, -2,  1,  9, 12, 28, 59, 86,116,145,171,191,202,202,191,171,145,116, 86, 59, 28, 12,  9,  1, -2, -3, -3, -1,  0,
+      },
+      { // B=0.60000 C=0.20000
+         0, -1, -3, -3, -3,  0,  8, 10, 27, 58, 86,116,146,172,193,204,204,193,172,146,116, 86, 58, 27, 10,  8,  0, -3, -3, -3, -1,  0,
+      },
+      { // B=0.57333 C=0.21333
+         0, -1, -3, -4, -3, -1,  7,  9, 26, 57, 86,116,147,174,194,207,207,194,174,147,116, 86, 57, 26,  9,  7, -1, -3, -4, -3, -1,  0,
+      },
+      { // B=0.54667 C=0.22667
+         0, -2, -3, -5, -4, -1,  5,  8, 25, 57, 85,117,148,176,196,209,209,196,176,148,117, 85, 57, 25,  8,  5, -1, -4, -5, -3, -2,  0,
+      },
+      { // B=0.52000 C=0.24000
+         0, -1, -4, -5, -5, -2,  4,  7, 24, 55, 85,117,149,177,199,211,211,199,177,149,117, 85, 55, 24,  7,  4, -2, -5, -5, -4, -1,  0,
+      },
+      { // B=0.49333 C=0.25333
+         0, -2, -4, -5, -6, -3,  3,  6, 23, 55, 84,117,150,178,200,214,214,200,178,150,117, 84, 55, 23,  6,  3, -3, -6, -5, -4, -2,  0,
+      },
+      { // B=0.46667 C=0.26667
+         0, -2, -4, -6, -6, -4,  2,  6, 22, 54, 84,118,150,180,202,216,216,202,180,150,118, 84, 54, 22,  6,  2, -4, -6, -6, -4, -2,  0,
+      },
+      { // B=0.44000 C=0.28000
+         0, -2, -4, -6, -7, -5,  2,  5, 21, 53, 83,118,150,181,205,218,218,205,181,150,118, 83, 53, 21,  5,  2, -5, -7, -6, -4, -2,  0,
+      },
+      { // B=0.41333 C=0.29333
+         0, -2, -4, -7, -7, -6,  0,  5, 20, 53, 83,118,152,183,207,220,220,207,183,152,118, 83, 53, 20,  5,  0, -6, -7, -7, -4, -2,  0,
+      },
+      { // B=0.38667 C=0.30667
+         0, -2, -5, -7, -8, -7, -1,  4, 19, 52, 83,118,153,185,208,223,223,208,185,153,118, 83, 52, 19,  4, -1, -7, -8, -7, -5, -2,  0,
+      },
+      { // B=0.36000 C=0.32000
+         0, -2, -5, -8, -8, -8, -2,  3, 19, 51, 83,118,155,186,210,225,225,210,186,155,118, 83, 51, 19,  3, -2, -8, -8, -8, -5, -2,  0,
+      },
+      { // B=0.33333 C=0.33333
+         0, -2, -6, -8,-10, -8, -3,  2, 18, 50, 82,119,155,187,213,227,227,213,187,155,119, 82, 50, 18,  2, -3, -8,-10, -8, -6, -2,  0,
+      },
+      { // B=0.32667 C=0.33667
+         0, -2, -6, -8,-10, -8, -3,  2, 18, 49, 82,119,155,188,213,228,228,213,188,155,119, 82, 49, 18,  2, -3, -8,-10, -8, -6, -2,  0,
+      },
+      { // B=0.32000 C=0.34000
+         0, -2, -6, -8,-10, -9, -3,  2, 18, 49, 82,119,155,188,214,228,228,214,188,155,119, 82, 49, 18,  2, -3, -9,-10, -8, -6, -2,  0,
+      },
+      { // B=0.31333 C=0.34333
+         0, -2, -6, -8,-10, -9, -4,  1, 18, 49, 82,119,155,188,214,229,229,214,188,155,119, 82, 49, 18,  1, -4, -9,-10, -8, -6, -2,  0,
+      },
+      { // B=0.30667 C=0.34667
+         0, -2, -6, -9,-10, -9, -4,  1, 18, 49, 82,119,156,189,214,229,229,214,189,156,119, 82, 49, 18,  1, -4, -9,-10, -9, -6, -2,  0,
+      },
+      { // B=0.30000 C=0.35000
+         0, -3, -5, -9,-10,-10, -4,  1, 18, 49, 82,119,156,189,215,230,230,215,189,156,119, 82, 49, 18,  1, -4,-10,-10, -9, -5, -3,  0,
+      },
+      { // B=0.29333 C=0.35333
+         0, -2, -6, -9,-10,-10, -4,  1, 17, 48, 82,119,156,190,215,231,231,215,190,156,119, 82, 48, 17,  1, -4,-10,-10, -9, -6, -2,  0,
+      },
+      { // B=0.28667 C=0.35667
+         0, -2, -6, -9,-11,-10, -5,  1, 17, 48, 82,119,157,190,216,231,231,216,190,157,119, 82, 48, 17,  1, -5,-10,-11, -9, -6, -2,  0,
+      },
+      { // B=0.28000 C=0.36000
+         0, -3, -6, -9,-11,-10, -5,  0, 17, 48, 82,119,157,190,217,231,231,217,190,157,119, 82, 48, 17,  0, -5,-10,-11, -9, -6, -3,  0,
+      },
+      { // B=0.27333 C=0.36333
+         0, -3, -6, -9,-11,-11, -5,  0, 17, 48, 82,119,157,191,217,232,232,217,191,157,119, 82, 48, 17,  0, -5,-11,-11, -9, -6, -3,  0,
+      },
+      { // B=0.26667 C=0.36667
+         0, -3, -6, -9,-11,-11, -5,  0, 17, 48, 81,119,157,191,217,233,233,217,191,157,119, 81, 48, 17,  0, -5,-11,-11, -9, -6, -3,  0,
+      },
+      { // B=0.26000 C=0.37000
+         0, -3, -6,-10,-11,-11, -5,  0, 16, 47, 81,120,156,191,218,233,233,218,191,156,120, 81, 47, 16,  0, -5,-11,-11,-10, -6, -3,  0,
+      },
+      { // B=0.25333 C=0.37333
+         0, -3, -6, -9,-12,-11, -6,  0, 16, 47, 81,119,158,192,218,234,234,218,192,158,119, 81, 47, 16,  0, -6,-11,-12, -9, -6, -3,  0,
+      },
+      { // B=0.24667 C=0.37667
+         0, -3, -6,-10,-12,-11, -6,  0, 16, 47, 81,120,157,192,219,234,234,219,192,157,120, 81, 47, 16,  0, -6,-11,-12,-10, -6, -3,  0,
+      },
+      { // B=0.24000 C=0.38000
+         0, -3, -6,-10,-12,-12, -6, -1, 16, 47, 81,120,158,193,219,235,235,219,193,158,120, 81, 47, 16, -1, -6,-12,-12,-10, -6, -3,  0,
+      },
+      { // B=0.23333 C=0.38333
+         0, -3, -6,-10,-12,-12, -6, -1, 16, 46, 81,120,158,193,220,236,236,220,193,158,120, 81, 46, 16, -1, -6,-12,-12,-10, -6, -3,  0,
+      },
+      { // B=0.22667 C=0.38667
+         0, -3, -6,-10,-12,-12, -7, -1, 15, 47, 80,120,158,194,220,236,236,220,194,158,120, 80, 47, 15, -1, -7,-12,-12,-10, -6, -3,  0,
+      },
+      { // B=0.22000 C=0.39000
+         0, -3, -6,-10,-13,-12, -7, -1, 15, 46, 80,120,159,194,221,237,237,221,194,159,120, 80, 46, 15, -1, -7,-12,-13,-10, -6, -3,  0,
+      },
+      { // B=0.21333 C=0.39333
+         0, -3, -6,-10,-13,-12, -8, -1, 15, 46, 80,120,159,194,221,237,237,221,194,159,120, 80, 46, 15, -1, -8,-12,-13,-10, -6, -3,  0,
+      },
+      { // B=0.20667 C=0.39667
+         0, -3, -7,-10,-13,-12, -8, -2, 15, 46, 80,120,159,194,222,238,238,222,194,159,120, 80, 46, 15, -2, -8,-12,-13,-10, -7, -3,  0,
+      },
+      { // B=0.20000 C=0.40000
+         0, -3, -7,-10,-13,-13, -8, -2, 15, 45, 81,120,159,195,222,238,238,222,195,159,120, 81, 45, 15, -2, -8,-13,-13,-10, -7, -3,  0,
+      },
+      { // B=0.19333 C=0.40333
+         0, -3, -7,-11,-13,-13, -8, -2, 15, 45, 81,120,160,195,223,239,239,223,195,160,120, 81, 45, 15, -2, -8,-13,-13,-11, -7, -3,  0,
+      },
+      { // B=0.18667 C=0.40667
+         0, -3, -7,-10,-14,-13, -9, -2, 14, 45, 80,120,160,196,223,240,240,223,196,160,120, 80, 45, 14, -2, -9,-13,-14,-10, -7, -3,  0,
+      },
+      { // B=0.18000 C=0.41000
+         0, -3, -7,-11,-13,-13, -9, -2, 14, 45, 80,120,160,196,224,240,240,224,196,160,120, 80, 45, 14, -2, -9,-13,-13,-11, -7, -3,  0,
+      },
+      { // B=0.17333 C=0.41333
+         0, -3, -7,-11,-13,-14, -9, -3, 14, 45, 80,120,160,196,225,240,240,225,196,160,120, 80, 45, 14, -3, -9,-14,-13,-11, -7, -3,  0,
+      },
+      { // B=0.16667 C=0.41667
+         0, -3, -7,-11,-14,-14, -9, -3, 14, 44, 80,120,161,197,225,241,241,225,197,161,120, 80, 44, 14, -3, -9,-14,-14,-11, -7, -3,  0,
+      },
+      { // B=0.16000 C=0.42000
+         0, -3, -7,-11,-14,-14,-10, -3, 14, 44, 80,120,161,197,225,242,242,225,197,161,120, 80, 44, 14, -3,-10,-14,-14,-11, -7, -3,  0,
+      },
+      { // B=0.15333 C=0.42333
+         0, -3, -7,-11,-14,-14,-10, -3, 13, 44, 80,120,161,197,226,242,242,226,197,161,120, 80, 44, 13, -3,-10,-14,-14,-11, -7, -3,  0,
+      },
+      { // B=0.14667 C=0.42667
+         0, -3, -7,-11,-15,-14,-10, -4, 14, 43, 80,120,163,198,226,243,243,226,198,163,120, 80, 43, 14, -4,-10,-14,-15,-11, -7, -3,  0,
+      },
+      { // B=0.14000 C=0.43000
+         0, -3, -7,-12,-14,-15,-10, -4, 14, 43, 80,120,163,198,227,243,243,227,198,163,120, 80, 43, 14, -4,-10,-15,-14,-12, -7, -3,  0,
+      },
+      { // B=0.13333 C=0.43333
+         0, -3, -7,-12,-14,-15,-11, -4, 13, 43, 79,121,161,199,227,244,244,227,199,161,121, 79, 43, 13, -4,-11,-15,-14,-12, -7, -3,  0,
+      },
+      { // B=0.12667 C=0.43667
+         0, -3, -7,-12,-14,-15,-11, -4, 13, 43, 79,120,163,199,228,245,245,228,199,163,120, 79, 43, 13, -4,-11,-15,-14,-12, -7, -3,  0,
+      },
+      { // B=0.12000 C=0.44000
+         0, -3, -7,-12,-15,-15,-12, -5, 13, 43, 79,121,162,199,228,245,245,228,199,162,121, 79, 43, 13, -5,-12,-15,-15,-12, -7, -3,  0,
+      },
+      { // B=0.11333 C=0.44333
+         0, -3, -7,-12,-15,-16,-11, -5, 13, 42, 79,121,162,200,229,246,246,229,200,162,121, 79, 42, 13, -5,-11,-16,-15,-12, -7, -3,  0,
+      },
+      { // B=0.10667 C=0.44667
+         0, -3, -8,-12,-15,-16,-12, -5, 13, 42, 79,121,162,200,229,246,246,229,200,162,121, 79, 42, 13, -5,-12,-16,-15,-12, -8, -3,  0,
+      },
+      { // B=0.10000 C=0.45000
+         0, -3, -8,-12,-16,-16,-12, -6, 13, 42, 79,121,163,200,230,247,247,230,200,163,121, 79, 42, 13, -6,-12,-16,-16,-12, -8, -3,  0,
+      },
+      { // B=0.09333 C=0.45333
+         0, -3, -8,-12,-16,-16,-13, -5, 12, 42, 79,121,163,201,230,248,248,230,201,163,121, 79, 42, 12, -5,-13,-16,-16,-12, -8, -3,  0,
+      },
+      { // B=0.08667 C=0.45667
+         0, -3, -8,-12,-16,-16,-13, -5, 12, 41, 79,121,163,201,231,248,248,231,201,163,121, 79, 41, 12, -5,-13,-16,-16,-12, -8, -3,  0,
+      },
+      { // B=0.08000 C=0.46000
+         0, -3, -8,-12,-16,-17,-13, -6, 12, 41, 79,121,163,201,232,248,248,232,201,163,121, 79, 41, 12, -6,-13,-17,-16,-12, -8, -3,  0,
+      },
+      { // B=0.07333 C=0.46333
+         0, -3, -8,-13,-16,-17,-13, -6, 12, 41, 79,121,164,202,232,249,249,232,202,164,121, 79, 41, 12, -6,-13,-17,-16,-13, -8, -3,  0,
+      },
+      { // B=0.06667 C=0.46667
+         0, -3, -8,-13,-16,-17,-14, -6, 11, 41, 79,121,164,202,233,249,249,233,202,164,121, 79, 41, 11, -6,-14,-17,-16,-13, -8, -3,  0,
+      },
+      { // B=0.06000 C=0.47000
+         0, -3, -8,-13,-16,-18,-14, -6, 11, 40, 79,121,164,203,233,250,250,233,203,164,121, 79, 40, 11, -6,-14,-18,-16,-13, -8, -3,  0,
+      },
+      { // B=0.05333 C=0.47333
+         0, -3, -8,-13,-17,-18,-14, -6, 11, 40, 79,121,165,203,233,251,251,233,203,165,121, 79, 40, 11, -6,-14,-18,-17,-13, -8, -3,  0,
+      },
+      { // B=0.04667 C=0.47667
+         0, -4, -8,-13,-17,-18,-14, -7, 11, 40, 79,121,166,203,234,251,251,234,203,166,121, 79, 40, 11, -7,-14,-18,-17,-13, -8, -4,  0,
+      },
+      { // B=0.04000 C=0.48000
+         0, -4, -8,-13,-17,-18,-14, -7, 11, 40, 78,121,166,204,234,251,251,234,204,166,121, 78, 40, 11, -7,-14,-18,-17,-13, -8, -4,  0,
+      },
+      { // B=0.03333 C=0.48333
+         0, -4, -8,-14,-17,-18,-15, -7, 11, 40, 78,122,164,204,235,252,252,235,204,164,122, 78, 40, 11, -7,-15,-18,-17,-14, -8, -4,  0,
+      },
+      { // B=0.02667 C=0.48667
+         0, -4, -8,-14,-17,-19,-15, -7, 10, 40, 78,122,164,205,235,253,253,235,205,164,122, 78, 40, 10, -7,-15,-19,-17,-14, -8, -4,  0,
+      },
+      { // B=0.02000 C=0.49000
+         0, -4, -8,-14,-17,-19,-15, -7, 10, 39, 78,122,164,205,236,253,253,236,205,164,122, 78, 39, 10, -7,-15,-19,-17,-14, -8, -4,  0,
+      },
+      { // B=0.01333 C=0.49333
+         0, -4, -8,-14,-18,-19,-16, -7,  9, 40, 78,122,165,205,236,254,254,236,205,165,122, 78, 40,  9, -7,-16,-19,-18,-14, -8, -4,  0,
+      },
+      { // B=0.00667 C=0.49667
+         0, -4, -9,-14,-18,-19,-15, -8, 10, 39, 78,122,166,206,236,254,254,236,206,166,122, 78, 39, 10, -8,-15,-19,-18,-14, -9, -4,  0,
+      },
+      { // B=0.00000 C=0.50000
+         0, -4, -8,-14,-18,-19,-16, -8,  9, 39, 77,122,166,206,237,255,255,237,206,166,122, 77, 39,  9, -8,-16,-19,-18,-14, -8, -4,  0,
+      },
+  };
+  int index = (sharpness + 1.0f) * 50.0f + 0.5f;
+  if (index >=0 && index <= 100)
+  {
+    const int16_t *coef = mitchells[index];
+
+    char command[33*12];
+    char response[33*12];
+    unsigned int len = sprintf(command, "scaling_kernel ");
+    for (int i=0; i < 32; i++) {
+       if (len + 12 < sizeof command)
+         len += sprintf(command+len, "%d ", coef[i]);
+    }
+    // no interpolate flag
+    if (len + 12 < sizeof command)
+      len += sprintf(command+len, " %d", 0);
+    //printf("%i: %s\n", index, command);
+    vc_gencmd(response, sizeof response, command);
+  }
+}
+
 void COMXPlayer::Process()
 {
   bool bOmxWaitVideo = false;
@@ -1175,6 +1503,8 @@ void COMXPlayer::Process()
     SetCaching(CACHESTATE_FLUSH);
 
   EDEINTERLACEMODE current_deinterlace = CMediaSettings::Get().GetCurrentVideoSettings().m_DeinterlaceMode;
+  float current_sharpness = CMediaSettings::Get().GetCurrentVideoSettings().m_Sharpness;
+  SetSharpness(current_sharpness);
 
   while (!m_bAbortRequest)
   {
@@ -1206,6 +1536,13 @@ void COMXPlayer::Process()
         current_deinterlace = CMediaSettings::Get().GetCurrentVideoSettings().m_DeinterlaceMode;
       }
 
+      // if sharpness setting has changed, we should update it
+      if (current_sharpness != CMediaSettings::Get().GetCurrentVideoSettings().m_Sharpness)
+      {
+        current_sharpness = CMediaSettings::Get().GetCurrentVideoSettings().m_Sharpness;
+        SetSharpness(current_sharpness);
+      }
+
       m_video_fifo = (int)(100.0*(m_omxPlayerVideo.GetDecoderBufferSize()-m_omxPlayerVideo.GetDecoderFreeSpace())/m_omxPlayerVideo.GetDecoderBufferSize());
       m_audio_fifo = (int)(100.0*audio_fifo/m_omxPlayerAudio.GetCacheTotal());
 
@@ -4574,6 +4911,7 @@ void COMXPlayer::GetRenderFeatures(std::vector<int> &renderFeatures)
   renderFeatures.push_back(RENDERFEATURE_CROP);
   renderFeatures.push_back(RENDERFEATURE_PIXEL_RATIO);
   renderFeatures.push_back(RENDERFEATURE_ZOOM);
+  renderFeatures.push_back(RENDERFEATURE_SHARPNESS);
 }
 
 void COMXPlayer::GetDeinterlaceMethods(std::vector<int> &deinterlaceMethods)
-- 
1.9.3


From b0f1716de6047490c4c502bc5023219489c34ba7 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Wed, 16 Apr 2014 21:18:06 +0100
Subject: [PATCH 039/102] [omxplayer] Don't propagate 3d flags based on
 supported 3d modes

---
 xbmc/cores/omxplayer/OMXPlayerVideo.cpp | 29 ++++-------------------------
 1 file changed, 4 insertions(+), 25 deletions(-)

diff --git a/xbmc/cores/omxplayer/OMXPlayerVideo.cpp b/xbmc/cores/omxplayer/OMXPlayerVideo.cpp
index 2fdbe18..e6bf2d0 100644
--- a/xbmc/cores/omxplayer/OMXPlayerVideo.cpp
+++ b/xbmc/cores/omxplayer/OMXPlayerVideo.cpp
@@ -746,36 +746,15 @@ void OMXPlayerVideo::ResolutionUpdateCallBack(uint32_t width, uint32_t height, f
   unsigned flags = 0;
   ERenderFormat format = RENDER_FMT_BYPASS;
 
+  /* figure out steremode expected based on user settings and hints */
+  unsigned int stereo_flags = GetStereoModeFlags(GetStereoMode());
+
   if(m_bAllowFullscreen)
   {
     flags |= CONF_FLAGS_FULLSCREEN;
     m_bAllowFullscreen = false; // only allow on first configure
   }
-
-  flags |= GetStereoModeFlags(GetStereoMode());
-
-  if(flags & CONF_FLAGS_STEREO_MODE_SBS)
-  {
-    if(g_Windowing.Support3D(video_width, video_height, D3DPRESENTFLAG_MODE3DSBS))
-      CLog::Log(LOGNOTICE, "3DSBS movie found");
-    else
-    {
-      flags &= ~CONF_FLAGS_STEREO_MODE_MASK(~0);
-      CLog::Log(LOGNOTICE, "3DSBS movie found but not supported");
-    }
-  }
-  else if(flags & CONF_FLAGS_STEREO_MODE_TAB)
-  {
-    if(g_Windowing.Support3D(video_width, video_height, D3DPRESENTFLAG_MODE3DTB))
-      CLog::Log(LOGNOTICE, "3DTB movie found");
-    else
-    {
-      flags &= ~CONF_FLAGS_STEREO_MODE_MASK(~0);
-      CLog::Log(LOGNOTICE, "3DTB movie found but not supported");
-    }
-  }
-  else
-    CLog::Log(LOGNOTICE, "not a 3D movie");
+  flags |= stereo_flags;
 
   unsigned int iDisplayWidth  = width;
   unsigned int iDisplayHeight = height;
-- 
1.9.3


From 605211b04a4bcbd6a7e5b98fdd748c01d2455fbc Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Thu, 17 Apr 2014 13:00:52 +0100
Subject: [PATCH 040/102] [graphics] Don't set stereo mode based on resolution

The resolution change should follow stereo mode
---
 xbmc/guilib/GraphicContext.cpp | 22 ----------------------
 1 file changed, 22 deletions(-)

diff --git a/xbmc/guilib/GraphicContext.cpp b/xbmc/guilib/GraphicContext.cpp
index 5bffdf5..7e4fdd4 100644
--- a/xbmc/guilib/GraphicContext.cpp
+++ b/xbmc/guilib/GraphicContext.cpp
@@ -418,28 +418,6 @@ void CGraphicContext::SetVideoResolution(RESOLUTION res, bool forceUpdate)
   Lock();
 
   RESOLUTION_INFO info_org  = CDisplaySettings::Get().GetResolutionInfo(res);
-  RESOLUTION_INFO info_last = CDisplaySettings::Get().GetResolutionInfo(lastRes);
-
-  RENDER_STEREO_MODE stereo_mode = m_stereoMode;
-
-  // if the new mode is an actual stereo mode, switch to that
-  // if the old mode was an actual stereo mode, switch to no 3d mode
-  if (info_org.dwFlags & D3DPRESENTFLAG_MODE3DTB)
-    stereo_mode = RENDER_STEREO_MODE_SPLIT_HORIZONTAL;
-  else if (info_org.dwFlags & D3DPRESENTFLAG_MODE3DSBS)
-    stereo_mode = RENDER_STEREO_MODE_SPLIT_VERTICAL;
-  else if ((info_last.dwFlags & D3DPRESENTFLAG_MODE3DSBS) != 0
-        || (info_last.dwFlags & D3DPRESENTFLAG_MODE3DTB)  != 0)
-    stereo_mode = RENDER_STEREO_MODE_OFF;
-
-  if(stereo_mode != m_stereoMode)
-  {
-    m_stereoView     = RENDER_STEREO_VIEW_OFF;
-    m_stereoMode     = stereo_mode;
-    m_nextStereoMode = stereo_mode;
-    CSettings::Get().SetInt("videoscreen.stereoscopicmode", (int)m_stereoMode);
-  }
-
   RESOLUTION_INFO info_mod = GetResInfo(res);
 
   m_iScreenWidth  = info_mod.iWidth;
-- 
1.9.3


From b02ed2e1e04e2d082ff8421b7e2fcb80e15e6e62 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Thu, 17 Apr 2014 13:01:51 +0100
Subject: [PATCH 041/102] [graphics] Allow switching to a more suitable 3D
 resolution

---
 xbmc/guilib/GraphicContext.cpp | 41 ++++++++++++++++++++++++++++++++++++++++-
 xbmc/guilib/GraphicContext.h   |  1 +
 2 files changed, 41 insertions(+), 1 deletion(-)

diff --git a/xbmc/guilib/GraphicContext.cpp b/xbmc/guilib/GraphicContext.cpp
index 7e4fdd4..886b612 100644
--- a/xbmc/guilib/GraphicContext.cpp
+++ b/xbmc/guilib/GraphicContext.cpp
@@ -35,6 +35,7 @@
 #include "utils/JobManager.h"
 #include "video/VideoReferenceClock.h"
 #include "cores/IPlayer.h"
+#include <float.h>
 
 using namespace std;
 
@@ -459,6 +460,44 @@ RESOLUTION CGraphicContext::GetVideoResolution() const
   return m_Resolution;
 }
 
+RESOLUTION CGraphicContext::Get3DVideoResolution(RENDER_STEREO_MODE mode) const
+{
+  RESOLUTION best = m_Resolution;
+  RESOLUTION_INFO curr = CDisplaySettings::Get().GetResolutionInfo(best);
+
+  // Find closest refresh rate
+  for (size_t i = (int)RES_DESKTOP; i < CDisplaySettings::Get().ResolutionInfoSize(); i++)
+  {
+    const RESOLUTION_INFO info = CDisplaySettings::Get().GetResolutionInfo((RESOLUTION)i);
+
+    //discard resolutions that are not the same width and height (and interlaced/3D flags)
+    //or have a too low refreshrate
+    if (info.iScreenWidth  != curr.iScreenWidth
+    ||  info.iScreenHeight != curr.iScreenHeight
+    ||  info.iScreen       != curr.iScreen
+    ||  (info.dwFlags & D3DPRESENTFLAG_INTERLACED) != (curr.dwFlags & D3DPRESENTFLAG_INTERLACED)
+    ||  fabs(info.fRefreshRate - curr.fRefreshRate) >= FLT_EPSILON)
+      continue;
+
+    if (mode == RENDER_STEREO_MODE_SPLIT_VERTICAL && info.dwFlags & D3DPRESENTFLAG_MODE3DSBS)
+    {
+      best = (RESOLUTION)i;
+      break;
+    }
+    else if (mode == RENDER_STEREO_MODE_SPLIT_HORIZONTAL && info.dwFlags & D3DPRESENTFLAG_MODE3DTB)
+    {
+      best = (RESOLUTION)i;
+      break;
+    }
+    else if ((mode == RENDER_STEREO_MODE_OFF || mode == RENDER_STEREO_MODE_MONO) && !(info.dwFlags & (D3DPRESENTFLAG_MODE3DSBS|D3DPRESENTFLAG_MODE3DTB)))
+    {
+      best = (RESOLUTION)i;
+      break;
+    }
+  }
+  return best;
+}
+
 void CGraphicContext::ResetOverscan(RESOLUTION_INFO &res)
 {
   res.Overscan.left = 0;
@@ -996,7 +1035,7 @@ void CGraphicContext::Flip(const CDirtyRegionList& dirty)
   if(m_stereoMode != m_nextStereoMode)
   {
     m_stereoMode = m_nextStereoMode;
-    SetVideoResolution(GetVideoResolution(), true);
+    SetVideoResolution(Get3DVideoResolution(m_stereoMode), true);
     g_windowManager.SendMessage(GUI_MSG_NOTIFY_ALL, 0, 0, GUI_MSG_RENDERER_RESET);
   }
 }
diff --git a/xbmc/guilib/GraphicContext.h b/xbmc/guilib/GraphicContext.h
index 0a27643..df55e92 100644
--- a/xbmc/guilib/GraphicContext.h
+++ b/xbmc/guilib/GraphicContext.h
@@ -108,6 +108,7 @@ class CGraphicContext : public CCriticalSection,
   bool IsValidResolution(RESOLUTION res);
   void SetVideoResolution(RESOLUTION res, bool forceUpdate = false);
   RESOLUTION GetVideoResolution() const;
+  RESOLUTION Get3DVideoResolution(RENDER_STEREO_MODE mode) const;
   void ResetOverscan(RESOLUTION res, OVERSCAN &overscan);
   void ResetOverscan(RESOLUTION_INFO &resinfo);
   void ResetScreenParameters(RESOLUTION res);
-- 
1.9.3


From fb3ce65df80a323c9809ddb795aba36a3fbb9a1e Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Thu, 17 Apr 2014 13:38:55 +0100
Subject: [PATCH 042/102] [3D] Support switching to 3D resolutions

Include matching 3D flags (SBS/TAB) in the score of a resolution to switch to, to enable switching to 3d modes.
Also remove the old code that treated 3D modes differently when assigning a score.
---
 xbmc/cores/VideoRenderers/BaseRenderer.cpp | 47 +++++++++++-------------------
 1 file changed, 17 insertions(+), 30 deletions(-)

diff --git a/xbmc/cores/VideoRenderers/BaseRenderer.cpp b/xbmc/cores/VideoRenderers/BaseRenderer.cpp
index 83c3adb..8076e76 100644
--- a/xbmc/cores/VideoRenderers/BaseRenderer.cpp
+++ b/xbmc/cores/VideoRenderers/BaseRenderer.cpp
@@ -222,10 +222,14 @@ void CBaseRenderer::FindResolutionFromFpsMatch(float fps, float& weight)
 RESOLUTION CBaseRenderer::FindClosestResolution(float fps, float multiplier, RESOLUTION current, float& weight)
 {
   RESOLUTION_INFO curr = g_graphicsContext.GetResInfo(current);
+  RENDER_STEREO_MODE stereo_mode = g_graphicsContext.GetStereoMode();
 
   float fRefreshRate = fps;
 
-  float last_diff = fRefreshRate;
+  int c_weight = MathUtils::round_int(RefreshWeight(curr.fRefreshRate, fRefreshRate * multiplier) * 1000.0);
+  if (!(stereo_mode == RENDER_STEREO_MODE_SPLIT_VERTICAL) != !(curr.dwFlags & D3DPRESENTFLAG_MODE3DSBS) ||
+      !(stereo_mode == RENDER_STEREO_MODE_SPLIT_HORIZONTAL) != !(curr.dwFlags & D3DPRESENTFLAG_MODE3DTB))
+    c_weight += 1000;
 
   // Find closest refresh rate
   for (size_t i = (int)RES_DESKTOP; i < CDisplaySettings::Get().ResolutionInfoSize(); i++)
@@ -241,40 +245,23 @@ RESOLUTION CBaseRenderer::FindClosestResolution(float fps, float multiplier, RES
     ||  info.fRefreshRate < (fRefreshRate * multiplier / 1.001) - 0.001)
       continue;
 
-    // For 3D choose the closest refresh rate 
-    if(CONF_FLAGS_STEREO_MODE_MASK(m_iFlags))
-    {
-      float diff = (info.fRefreshRate - fRefreshRate);
-      if(diff < 0)
-        diff *= -1.0f;
+    int i_weight = MathUtils::round_int(RefreshWeight(info.fRefreshRate, fRefreshRate * multiplier) * 1000.0);
 
-      if(diff < last_diff)
-      {
-        last_diff = diff;
-        current = (RESOLUTION)i;
-        curr = info;
-      }
-    }
-    else
-    {
-      int c_weight = MathUtils::round_int(RefreshWeight(curr.fRefreshRate, fRefreshRate * multiplier) * 1000.0);
-      int i_weight = MathUtils::round_int(RefreshWeight(info.fRefreshRate, fRefreshRate * multiplier) * 1000.0);
+    if (!(stereo_mode == RENDER_STEREO_MODE_SPLIT_VERTICAL) != !(info.dwFlags & D3DPRESENTFLAG_MODE3DSBS) ||
+        !(stereo_mode == RENDER_STEREO_MODE_SPLIT_HORIZONTAL) != !(info.dwFlags & D3DPRESENTFLAG_MODE3DTB))
+      i_weight += 1000;
 
-      // Closer the better, prefer higher refresh rate if the same
-      if ((i_weight <  c_weight)
-      ||  (i_weight == c_weight && info.fRefreshRate > curr.fRefreshRate))
-      {
-        current = (RESOLUTION)i;
-        curr    = info;
-      }
+    // Closer the better, prefer higher refresh rate if the same
+    if ((i_weight <  c_weight)
+    ||  (i_weight == c_weight && info.fRefreshRate > curr.fRefreshRate))
+    {
+      current  = (RESOLUTION)i;
+      curr     = info;
+      c_weight = i_weight;
     }
   }
 
-  // For 3D overwrite weight
-  if(CONF_FLAGS_STEREO_MODE_MASK(m_iFlags))
-    weight = 0;
-  else
-    weight = RefreshWeight(curr.fRefreshRate, fRefreshRate * multiplier);
+  weight = RefreshWeight(curr.fRefreshRate, fRefreshRate * multiplier);
 
   return current;
 }
-- 
1.9.3


From cee7c61f26e7ef4eee06450a549bcc6d1595a252 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Wed, 23 Apr 2014 00:05:07 +0100
Subject: [PATCH 043/102] [graphics] Make pixel ratio for 3d modes consistent

Note: Use the stored stereo flags from lists of resolutions.
Use current stereo mode for current resolution.
---
 xbmc/cores/VideoRenderers/BaseRenderer.cpp      | 10 ++++----
 xbmc/guilib/GraphicContext.cpp                  | 32 ++++++++++---------------
 xbmc/guilib/GraphicContext.h                    |  4 ++--
 xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp |  8 -------
 4 files changed, 19 insertions(+), 35 deletions(-)

diff --git a/xbmc/cores/VideoRenderers/BaseRenderer.cpp b/xbmc/cores/VideoRenderers/BaseRenderer.cpp
index 8076e76..beda4e9 100644
--- a/xbmc/cores/VideoRenderers/BaseRenderer.cpp
+++ b/xbmc/cores/VideoRenderers/BaseRenderer.cpp
@@ -119,7 +119,7 @@ bool CBaseRenderer::FindResolutionFromOverride(float fps, float& weight, bool fa
 
     for (size_t j = (int)RES_DESKTOP; j < CDisplaySettings::Get().ResolutionInfoSize(); j++)
     {
-      RESOLUTION_INFO info = g_graphicsContext.GetResInfo((RESOLUTION)j);
+      RESOLUTION_INFO info = g_graphicsContext.GetResInfo((RESOLUTION)j, false);
 
       if (info.iScreenWidth  == curr.iScreenWidth
        && info.iScreenHeight == curr.iScreenHeight
@@ -179,7 +179,7 @@ void CBaseRenderer::FindResolutionFromFpsMatch(float fps, float& weight)
       //get the resolution with the refreshrate closest to 60 hertz
       for (size_t i = (int)RES_DESKTOP; i < CDisplaySettings::Get().ResolutionInfoSize(); i++)
       {
-        RESOLUTION_INFO info = g_graphicsContext.GetResInfo((RESOLUTION)i);
+        RESOLUTION_INFO info = g_graphicsContext.GetResInfo((RESOLUTION)i, false);
 
         if (MathUtils::round_int(info.fRefreshRate) == 60
          && info.iScreenWidth  == curr.iScreenWidth
@@ -200,7 +200,7 @@ void CBaseRenderer::FindResolutionFromFpsMatch(float fps, float& weight)
         CLog::Log(LOGDEBUG, "60 hertz refreshrate not available, choosing highest");
         for (size_t i = (int)RES_DESKTOP; i < CDisplaySettings::Get().ResolutionInfoSize(); i++)
         {
-          RESOLUTION_INFO info = g_graphicsContext.GetResInfo((RESOLUTION)i);
+          RESOLUTION_INFO info = g_graphicsContext.GetResInfo((RESOLUTION)i, false);
 
           if (info.fRefreshRate  >  curr.fRefreshRate
            && info.iScreenWidth  == curr.iScreenWidth
@@ -234,14 +234,14 @@ RESOLUTION CBaseRenderer::FindClosestResolution(float fps, float multiplier, RES
   // Find closest refresh rate
   for (size_t i = (int)RES_DESKTOP; i < CDisplaySettings::Get().ResolutionInfoSize(); i++)
   {
-    const RESOLUTION_INFO info = g_graphicsContext.GetResInfo((RESOLUTION)i);
+    const RESOLUTION_INFO info = g_graphicsContext.GetResInfo((RESOLUTION)i, false);
 
     //discard resolutions that are not the same width and height (and interlaced/3D flags)
     //or have a too low refreshrate
     if (info.iScreenWidth  != curr.iScreenWidth
     ||  info.iScreenHeight != curr.iScreenHeight
     ||  info.iScreen       != curr.iScreen
-    ||  (info.dwFlags & D3DPRESENTFLAG_MODEMASK) != (curr.dwFlags & D3DPRESENTFLAG_MODEMASK)
+    ||  (info.dwFlags & D3DPRESENTFLAG_INTERLACED) != (curr.dwFlags & D3DPRESENTFLAG_INTERLACED)
     ||  info.fRefreshRate < (fRefreshRate * multiplier / 1.001) - 0.001)
       continue;
 
diff --git a/xbmc/guilib/GraphicContext.cpp b/xbmc/guilib/GraphicContext.cpp
index 886b612..40a6362 100644
--- a/xbmc/guilib/GraphicContext.cpp
+++ b/xbmc/guilib/GraphicContext.cpp
@@ -707,32 +707,26 @@ void CGraphicContext::ApplyStateBlock()
   g_Windowing.ApplyStateBlock();
 }
 
-const RESOLUTION_INFO CGraphicContext::GetResInfo(RESOLUTION res) const
+const RESOLUTION_INFO CGraphicContext::GetResInfo(RESOLUTION res, bool use_current_3d /*= true*/) const
 {
   RESOLUTION_INFO info = CDisplaySettings::Get().GetResolutionInfo(res);
 
-  if(m_stereoMode == RENDER_STEREO_MODE_SPLIT_HORIZONTAL)
+  if(use_current_3d ? m_stereoMode == RENDER_STEREO_MODE_SPLIT_HORIZONTAL : (info.dwFlags & D3DPRESENTFLAG_MODE3DTB))
   {
-    if((info.dwFlags & D3DPRESENTFLAG_MODE3DTB) == 0)
-    {
-      info.fPixelRatio     /= 2;
-      info.iBlanking        = 0;
-      info.dwFlags         |= D3DPRESENTFLAG_MODE3DTB;
-    }
+    info.fPixelRatio     /= 2;
+    info.iBlanking        = 0;
+    info.dwFlags         |= D3DPRESENTFLAG_MODE3DTB;
     info.iHeight          = (info.iHeight         - info.iBlanking) / 2;
     info.Overscan.top    /= 2;
     info.Overscan.bottom  = (info.Overscan.bottom - info.iBlanking) / 2;
     info.iSubtitles       = (info.iSubtitles      - info.iBlanking) / 2;
   }
 
-  if(m_stereoMode == RENDER_STEREO_MODE_SPLIT_VERTICAL)
+  if(use_current_3d ? m_stereoMode == RENDER_STEREO_MODE_SPLIT_VERTICAL : (info.dwFlags & D3DPRESENTFLAG_MODE3DSBS))
   {
-    if((info.dwFlags & D3DPRESENTFLAG_MODE3DSBS) == 0)
-    {
-      info.fPixelRatio     *= 2;
-      info.iBlanking        = 0;
-      info.dwFlags         |= D3DPRESENTFLAG_MODE3DSBS;
-    }
+    info.fPixelRatio     *= 2;
+    info.iBlanking        = 0;
+    info.dwFlags         |= D3DPRESENTFLAG_MODE3DSBS;
     info.iWidth           = (info.iWidth         - info.iBlanking) / 2;
     info.Overscan.left   /= 2;
     info.Overscan.right   = (info.Overscan.right - info.iBlanking) / 2;
@@ -740,7 +734,7 @@ const RESOLUTION_INFO CGraphicContext::GetResInfo(RESOLUTION res) const
   return info;
 }
 
-void CGraphicContext::SetResInfo(RESOLUTION res, const RESOLUTION_INFO& info)
+void CGraphicContext::SetResInfo(RESOLUTION res, const RESOLUTION_INFO& info, bool use_current_3d /*= true*/)
 {
   RESOLUTION_INFO& curr = CDisplaySettings::Get().GetResolutionInfo(res);
   curr.Overscan   = info.Overscan;
@@ -750,16 +744,14 @@ void CGraphicContext::SetResInfo(RESOLUTION res, const RESOLUTION_INFO& info)
   if(info.dwFlags & D3DPRESENTFLAG_MODE3DSBS)
   {
     curr.Overscan.right  = info.Overscan.right  * 2 + info.iBlanking;
-    if((curr.dwFlags & D3DPRESENTFLAG_MODE3DSBS) == 0)
-      curr.fPixelRatio  /= 2.0;
+    curr.fPixelRatio  /= 2.0;
   }
 
   if(info.dwFlags & D3DPRESENTFLAG_MODE3DTB)
   {
     curr.Overscan.bottom = info.Overscan.bottom * 2 + info.iBlanking;
     curr.iSubtitles      = info.iSubtitles      * 2 + info.iBlanking;
-    if((curr.dwFlags & D3DPRESENTFLAG_MODE3DTB) == 0)
-      curr.fPixelRatio  *= 2.0;
+    curr.fPixelRatio  *= 2.0;
   }
 }
 
diff --git a/xbmc/guilib/GraphicContext.h b/xbmc/guilib/GraphicContext.h
index df55e92..c77f2ff 100644
--- a/xbmc/guilib/GraphicContext.h
+++ b/xbmc/guilib/GraphicContext.h
@@ -124,8 +124,8 @@ class CGraphicContext : public CCriticalSection,
   {
     return GetResInfo(m_Resolution);
   }
-  const RESOLUTION_INFO GetResInfo(RESOLUTION res) const;
-  void SetResInfo(RESOLUTION res, const RESOLUTION_INFO& info);
+  const RESOLUTION_INFO GetResInfo(RESOLUTION res, bool use_current_3d = true) const;
+  void SetResInfo(RESOLUTION res, const RESOLUTION_INFO& info, bool use_current_3d = true);
 
   /* \brief Get UI scaling information from a given resolution to the screen resolution.
    Takes account of overscan and UI zooming.
diff --git a/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp b/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp
index 90b57e1..5b26b20 100644
--- a/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp
+++ b/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp
@@ -448,15 +448,9 @@ bool CEGLNativeTypeRaspberryPI::ProbeResolutions(std::vector<RESOLUTION_INFO> &r
       m_desktopRes.fPixelRatio  = get_display_aspect_ratio((HDMI_ASPECT_T)tv_state.display.hdmi.display_options.aspect) / ((float)m_desktopRes.iScreenWidth / (float)m_desktopRes.iScreenHeight);
       // Also add 3D flags
       if (tv_state.display.hdmi.format_3d == HDMI_3D_FORMAT_SBS_HALF)
-      {
         m_desktopRes.dwFlags |= D3DPRESENTFLAG_MODE3DSBS;
-        m_desktopRes.fPixelRatio *= 2.0;
-      }
       else if (tv_state.display.hdmi.format_3d == HDMI_3D_FORMAT_TB_HALF)
-      {
         m_desktopRes.dwFlags |= D3DPRESENTFLAG_MODE3DTB;
-        m_desktopRes.fPixelRatio *= 0.5;
-      }
       HDMI_PROPERTY_PARAM_T property;
       property.property = HDMI_PROPERTY_PIXEL_CLOCK_TYPE;
       vc_tv_hdmi_get_property(&property);
@@ -602,7 +596,6 @@ void CEGLNativeTypeRaspberryPI::GetSupportedModes(HDMI_RES_GROUP_T group, std::v
         RESOLUTION_INFO res2 = res;
         res2.dwFlags |= D3DPRESENTFLAG_MODE3DSBS;
         res2.fPixelRatio    = get_display_aspect_ratio((HDMI_ASPECT_T)tv->aspect_ratio) / ((float)res2.iScreenWidth / (float)res2.iScreenHeight);
-        res2.fPixelRatio   *= 2.0f;
         CLog::Log(LOGDEBUG, "EGL mode %d: %s (%.2f)\n", i, res2.strMode.c_str(), res2.fPixelRatio);
 
         res2.iSubtitles    = (int)(0.965 * res2.iHeight);
@@ -619,7 +612,6 @@ void CEGLNativeTypeRaspberryPI::GetSupportedModes(HDMI_RES_GROUP_T group, std::v
         RESOLUTION_INFO res2 = res;
         res2.dwFlags |= D3DPRESENTFLAG_MODE3DTB;
         res2.fPixelRatio    = get_display_aspect_ratio((HDMI_ASPECT_T)tv->aspect_ratio) / ((float)res2.iScreenWidth / (float)res2.iScreenHeight);
-        res2.fPixelRatio   *= 0.5f;
         CLog::Log(LOGDEBUG, "EGL mode %d: %s (%.2f)\n", i, res2.strMode.c_str(), res2.fPixelRatio);
 
         res2.iSubtitles    = (int)(0.965 * res2.iHeight);
-- 
1.9.3


From 50b494ec8d7c50d1b62e4c98a2e442ad72d70700 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Wed, 23 Apr 2014 21:07:51 +0100
Subject: [PATCH 044/102] [PiSink] More attempts to reduce underrun audio
 glitches with multichannl and high samplerate

---
 xbmc/cores/AudioEngine/Sinks/AESinkPi.cpp | 78 ++++++++++++-------------------
 1 file changed, 30 insertions(+), 48 deletions(-)

diff --git a/xbmc/cores/AudioEngine/Sinks/AESinkPi.cpp b/xbmc/cores/AudioEngine/Sinks/AESinkPi.cpp
index 19a9411..0a09275 100644
--- a/xbmc/cores/AudioEngine/Sinks/AESinkPi.cpp
+++ b/xbmc/cores/AudioEngine/Sinks/AESinkPi.cpp
@@ -186,7 +186,7 @@ bool CAESinkPi::Initialize(AEAudioFormat &format, std::string &device)
   unsigned int sample_size = CAEUtil::DataFormatToBits(format.m_dataFormat) >> 3;
   format.m_frameSize     = sample_size * channels;
   format.m_sampleRate    = std::max(8000U, std::min(192000U, format.m_sampleRate));
-  format.m_frames        = format.m_sampleRate * AUDIO_PLAYBUFFER;
+  format.m_frames        = format.m_sampleRate * AUDIO_PLAYBUFFER / NUM_OMX_BUFFERS;
   format.m_frameSamples  = format.m_frames * channels;
 
   SetAudioProps(m_passthrough, GetChannelMap(format, m_passthrough));
@@ -232,7 +232,7 @@ bool CAESinkPi::Initialize(AEAudioFormat &format, std::string &device)
     CLog::Log(LOGERROR, "%s:%s - error get OMX_IndexParamPortDefinition (input) omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
 
   port_param.nBufferCountActual = std::max((unsigned int)port_param.nBufferCountMin, (unsigned int)NUM_OMX_BUFFERS);
-  port_param.nBufferSize = m_format.m_frameSize * m_format.m_frames / port_param.nBufferCountActual;
+  port_param.nBufferSize = m_format.m_frameSize * m_format.m_frames;
 
   omx_err = m_omx_render.SetParameter(OMX_IndexParamPortDefinition, &port_param);
   if (omx_err != OMX_ErrorNone)
@@ -306,61 +306,43 @@ double CAESinkPi::GetCacheTotal()
 
 unsigned int CAESinkPi::AddPackets(uint8_t **data, unsigned int frames, unsigned int offset)
 {
-  unsigned int sent = 0;
   uint8_t *buffer = data[0]+offset*m_format.m_frameSize;
 
-  if (!m_Initialized)
+  if (!m_Initialized || !frames)
     return frames;
 
   OMX_ERRORTYPE omx_err   = OMX_ErrorNone;
   OMX_BUFFERHEADERTYPE *omx_buffer = NULL;
-  while (sent < frames)
+
+  AEDelayStatus status;
+  GetDelay(status);
+  double delay = status.GetDelay();
+  if (delay <= 0.0 && m_submitted)
+    CLog::Log(LOGNOTICE, "%s:%s Underrun (delay:%.2f frames:%d)", CLASSNAME, __func__, delay, frames);
+
+  omx_buffer = m_omx_render.GetInputBuffer(1000);
+  if (omx_buffer == NULL)
   {
-    AEDelayStatus status;
-    GetDelay(status);
-    double delay = status.GetDelay();
-    double ideal_submission_time = AUDIO_PLAYBUFFER - delay;
-    // ideal amount of audio we'd like submit (to make delay match AUDIO_PLAYBUFFER)
-    int timeout = 1000;
-    int ideal_submission_samples = ideal_submission_time / (m_sinkbuffer_sec_per_byte * m_format.m_frameSize);
-    // if we are almost full then sleep (to avoid repeatedly sending a few samples)
-    bool too_laggy = ideal_submission_time < 0.25 * AUDIO_PLAYBUFFER;
-    int sleeptime = (int)(AUDIO_PLAYBUFFER * 0.25 * 1000.0);
-    if (too_laggy)
-    {
-      Sleep(sleeptime);
-      continue;
-    }
-    omx_buffer = m_omx_render.GetInputBuffer(timeout);
-    if (omx_buffer == NULL)
-    {
-      CLog::Log(LOGERROR, "COMXAudio::Decode timeout");
-      break;
-    }
-
-    unsigned int space = omx_buffer->nAllocLen / m_format.m_frameSize;
-    unsigned int samples = std::min(std::min(space, (unsigned int)ideal_submission_samples), frames - sent);
-
-    omx_buffer->nFilledLen = samples * m_format.m_frameSize;
-    omx_buffer->nTimeStamp = ToOMXTime(0);
-    omx_buffer->nFlags = 0;
-    memcpy(omx_buffer->pBuffer, (uint8_t *)buffer + sent * m_format.m_frameSize, omx_buffer->nFilledLen);
-
-    sent += samples;
-
-    if (sent == frames)
-      omx_buffer->nFlags |= OMX_BUFFERFLAG_ENDOFFRAME;
-
-    if (delay <= 0.0 && m_submitted)
-      CLog::Log(LOGNOTICE, "%s:%s Underrun (delay:%.2f frames:%d)", CLASSNAME, __func__, delay, frames);
-
-    omx_err = m_omx_render.EmptyThisBuffer(omx_buffer);
-    if (omx_err != OMX_ErrorNone)
-      CLog::Log(LOGERROR, "%s:%s frames=%d err=%x", CLASSNAME, __func__, frames, omx_err);
-    m_submitted++;
+    CLog::Log(LOGERROR, "CAESinkPi::AddPackets timeout");
+    return 0;
   }
 
-  return sent;
+  omx_buffer->nFilledLen = frames * m_format.m_frameSize;
+  // must be true
+  assert(omx_buffer->nFilledLen <= omx_buffer->nAllocLen);
+  omx_buffer->nTimeStamp = ToOMXTime(0);
+  omx_buffer->nFlags = OMX_BUFFERFLAG_ENDOFFRAME;
+  memcpy(omx_buffer->pBuffer, buffer, omx_buffer->nFilledLen);
+
+  omx_err = m_omx_render.EmptyThisBuffer(omx_buffer);
+  if (omx_err != OMX_ErrorNone)
+    CLog::Log(LOGERROR, "%s:%s frames=%d err=%x", CLASSNAME, __func__, frames, omx_err);
+  m_submitted++;
+  GetDelay(status);
+  delay = status.GetDelay();
+  if (delay > AUDIO_PLAYBUFFER)
+    Sleep((int)(1000.0f * (delay - AUDIO_PLAYBUFFER)));
+  return frames;
 }
 
 void CAESinkPi::Drain()
-- 
1.9.3


From ba6de3c9448a90c35df2b4bccf12f354c8422a55 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Tue, 22 Apr 2014 12:23:23 +0100
Subject: [PATCH 045/102] [omxplayer] Make dvdplayer the default for dvd images

---
 xbmc/cores/omxplayer/omxplayer_advancedsettings.xml | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/xbmc/cores/omxplayer/omxplayer_advancedsettings.xml b/xbmc/cores/omxplayer/omxplayer_advancedsettings.xml
index 77c6a15..51c0daf 100644
--- a/xbmc/cores/omxplayer/omxplayer_advancedsettings.xml
+++ b/xbmc/cores/omxplayer/omxplayer_advancedsettings.xml
@@ -2,6 +2,6 @@
 <advancedsettings>
   <video>
     <defaultplayer>omxplayer</defaultplayer>
-    <defaultdvdplayer>omxplayer</defaultdvdplayer>
+    <defaultdvdplayer>dvdplayer</defaultdvdplayer>
   </video>
 </advancedsettings>
-- 
1.9.3


From 4f6bde16d4768b34732df62ca04418b123d027b5 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Sat, 26 Apr 2014 17:27:52 +0100
Subject: [PATCH 046/102] [cec] Don't suspend pi on tv switch off - it can't
 wake up

---
 system/peripherals.xml | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/system/peripherals.xml b/system/peripherals.xml
index a906628..9b5271a 100644
--- a/system/peripherals.xml
+++ b/system/peripherals.xml
@@ -16,7 +16,7 @@
     <setting key="send_inactive_source" type="bool" value="1" label="36025" order="5" />
     <setting key="cec_standby_screensaver" type="bool" value="0" label="36009" order="6" />
     <setting key="cec_wake_screensaver" type="bool" value="1" label="36010" order="7" />
-    <setting key="standby_pc_on_tv_standby" type="enum" value="13011" label="36029" order="8" lvalues="36028|13005|13011" />
+    <setting key="standby_pc_on_tv_standby" type="enum" value="36028" label="36029" order="8" lvalues="36028|13005|13011" />
     <setting key="standby_tv_on_pc_standby" type="bool" value="1" label="36026" order="9" />
     <setting key="use_tv_menu_language" type="bool" value="1" label="36018" order="10" />
     <setting key="pause_playback_on_deactivate" type="bool" value="1" label="36033" order="11" />
-- 
1.9.3


From b7433fb3abf84933605135201fa4499aed15b1b7 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Thu, 27 Jun 2013 01:25:57 +0100
Subject: [PATCH 048/102] [rbp/omxplayer] Do we need discontinuity handling?

So far I've not seen what this is needed for and it does cause problems for some files.
---
 xbmc/cores/omxplayer/OMXPlayer.cpp | 1 +
 1 file changed, 1 insertion(+)

diff --git a/xbmc/cores/omxplayer/OMXPlayer.cpp b/xbmc/cores/omxplayer/OMXPlayer.cpp
index 668a72a..ebb59d5 100644
--- a/xbmc/cores/omxplayer/OMXPlayer.cpp
+++ b/xbmc/cores/omxplayer/OMXPlayer.cpp
@@ -2387,6 +2387,7 @@ static void UpdateLimits(double& minimum, double& maximum, double dts)
 
 void COMXPlayer::CheckContinuity(COMXCurrentStream& current, DemuxPacket* pPacket)
 {
+return;
   if (m_playSpeed < DVD_PLAYSPEED_PAUSE)
     return;
 
-- 
1.9.3


From 66a9d175627a9a298aa7f41c81428ccc48c7dd8d Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Thu, 24 Oct 2013 00:53:26 +0100
Subject: [PATCH 049/102] [rbp/omxplayer] Avoid marking non-monotonic
 timestamps as unknown

Following a single spurious timestamp that is in the future,
all subsequent timestamps will be marked unknown causing out of sync.
---
 xbmc/cores/omxplayer/OMXAudio.cpp | 16 ++--------------
 1 file changed, 2 insertions(+), 14 deletions(-)

diff --git a/xbmc/cores/omxplayer/OMXAudio.cpp b/xbmc/cores/omxplayer/OMXAudio.cpp
index 77731a9..5f9d028 100644
--- a/xbmc/cores/omxplayer/OMXAudio.cpp
+++ b/xbmc/cores/omxplayer/OMXAudio.cpp
@@ -1210,22 +1210,10 @@ unsigned int COMXAudio::AddPackets(const void* data, unsigned int len, double dt
     }
     else
     {
-      if(pts == DVD_NOPTS_VALUE)
-      {
+      if(pts == DVD_NOPTS_VALUE || pts == m_last_pts)
         omx_buffer->nFlags = OMX_BUFFERFLAG_TIME_UNKNOWN;
+      else
         m_last_pts = pts;
-      }
-      else if (m_last_pts != pts)
-      {
-        if(pts > m_last_pts)
-          m_last_pts = pts;
-        else
-          omx_buffer->nFlags = OMX_BUFFERFLAG_TIME_UNKNOWN;;
-      }
-      else if (m_last_pts == pts)
-      {
-        omx_buffer->nFlags = OMX_BUFFERFLAG_TIME_UNKNOWN;
-      }
     }
 
     omx_buffer->nTimeStamp = ToOMXTime(val);
-- 
1.9.3


From 953b12e91da05a8202f7fbc69ab0b818f25964da Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Fri, 13 Dec 2013 16:25:23 +0000
Subject: [PATCH 051/102] Add time taken to resample to log

---
 xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp    | 7 +++++++
 xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAESound.h | 2 +-
 2 files changed, 8 insertions(+), 1 deletion(-)

diff --git a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp
index 4ee53ec..a4337f1 100644
--- a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp
+++ b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp
@@ -2610,7 +2610,14 @@ void CActiveAE::ResampleSounds()
   {
     if (!(*it)->IsConverted())
     {
+  struct timespec now;
+  clock_gettime(CLOCK_MONOTONIC, &now);
+  uint64_t  Start = ((int64_t)now.tv_sec * 1000000000L) + now.tv_nsec;
+
       ResampleSound(*it);
+  clock_gettime(CLOCK_MONOTONIC, &now);
+  uint64_t  End = ((int64_t)now.tv_sec * 1000000000L) + now.tv_nsec;
+  CLog::Log(LOGNOTICE, "ActiveAE::%s - resample %s took %.0fms", __FUNCTION__, (*it)->m_filename.c_str(), (End-Start)*1e-6);
       // only do one sound, then yield to main loop
       break;
     }
diff --git a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAESound.h b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAESound.h
index 9324e1e..4405f66 100644
--- a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAESound.h
+++ b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAESound.h
@@ -58,8 +58,8 @@ class CActiveAESound : public IAESound
   static int Read(void *h, uint8_t* buf, int size);
   static int64_t Seek(void *h, int64_t pos, int whence);
 
-protected:
   std::string m_filename;
+protected:
   XFILE::CFile *m_pFile;
   bool m_isSeekPosible;
   int m_fileSize;
-- 
1.9.3


From 6145eb43d0dfda3fcbb739dbed4af84d2c272a00 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Sat, 14 Dec 2013 16:55:05 +0000
Subject: [PATCH 052/102] logging: Add microsecond timer to log messages

---
 xbmc/utils/log.cpp | 12 +++++++++---
 1 file changed, 9 insertions(+), 3 deletions(-)

diff --git a/xbmc/utils/log.cpp b/xbmc/utils/log.cpp
index dd6ef26..8edf2fd 100644
--- a/xbmc/utils/log.cpp
+++ b/xbmc/utils/log.cpp
@@ -32,6 +32,7 @@
 #elif defined(TARGET_WINDOWS)
 #include "win32/WIN32Util.h"
 #endif
+#include "utils/TimeUtils.cpp"
 
 #define critSec XBMC_GLOBAL_USE(CLog::CLogGlobals).critSec
 #define m_file XBMC_GLOBAL_USE(CLog::CLogGlobals).m_file
@@ -64,7 +65,7 @@ void CLog::Close()
 
 void CLog::Log(int loglevel, const char *format, ... )
 {
-  static const char* prefixFormat = "%02.2d:%02.2d:%02.2d T:%" PRIu64" %7s: ";
+  static const char* prefixFormat = "%02.2d:%02.2d:%02.2d %10.6f T:%" PRIu64" %7s: ";
   CSingleLock waitLock(critSec);
   int extras = (loglevel >> LOGMASKBIT) << LOGMASKBIT;
   loglevel = loglevel & LOGMASK;
@@ -90,6 +91,11 @@ void CLog::Log(int loglevel, const char *format, ... )
     strData = StringUtils::FormatV(format,va);
     va_end(va);
 
+
+  struct timespec now;
+  clock_gettime(CLOCK_MONOTONIC, &now);
+  float Now = now.tv_sec + now.tv_nsec * 1e-9;
+
     if (m_repeatLogLevel == loglevel && m_repeatLine == strData)
     {
       m_repeatCount++;
@@ -100,7 +106,7 @@ void CLog::Log(int loglevel, const char *format, ... )
       strPrefix = StringUtils::Format(prefixFormat,
                                       time.wHour,
                                       time.wMinute,
-                                      time.wSecond,
+                                      time.wSecond, Now,
                                       (uint64_t)CThread::GetCurrentThreadId(),
                                       levelNames[m_repeatLogLevel]);
 
@@ -129,7 +135,7 @@ void CLog::Log(int loglevel, const char *format, ... )
     strPrefix = StringUtils::Format(prefixFormat,
                                     time.wHour,
                                     time.wMinute,
-                                    time.wSecond,
+                                    time.wSecond, Now,
                                     (uint64_t)CThread::GetCurrentThreadId(),
                                     levelNames[loglevel]);
 
-- 
1.9.3


From d7817a5e964c2e85ab49b74ac73b0d28491702d0 Mon Sep 17 00:00:00 2001
From: Jonathan Marshall <jmarshall@xbmc.org>
Date: Sat, 2 Nov 2013 23:49:17 +1300
Subject: [PATCH 053/102] adds GetTvShowSeasons

---
 xbmc/video/VideoDatabase.cpp | 30 ++++++++++++++++++++++++------
 xbmc/video/VideoDatabase.h   |  1 +
 2 files changed, 25 insertions(+), 6 deletions(-)

diff --git a/xbmc/video/VideoDatabase.cpp b/xbmc/video/VideoDatabase.cpp
index 8ac7e41..6d28a42 100644
--- a/xbmc/video/VideoDatabase.cpp
+++ b/xbmc/video/VideoDatabase.cpp
@@ -4060,7 +4060,7 @@ bool CVideoDatabase::RemoveArtForItem(int mediaId, const MediaType &mediaType, c
   return result;
 }
 
-bool CVideoDatabase::GetTvShowSeasonArt(int showId, map<int, map<string, string> > &seasonArt)
+bool CVideoDatabase::GetTvShowSeasons(int showId, map<int, int> &seasons)
 {
   try
   {
@@ -4071,19 +4071,37 @@ bool CVideoDatabase::GetTvShowSeasonArt(int showId, map<int, map<string, string>
     CStdString sql = PrepareSQL("select idSeason,season from seasons where idShow=%i", showId);
     m_pDS2->query(sql.c_str());
 
-    vector< pair<int, int> > seasons;
+    seasons.clear();
     while (!m_pDS2->eof())
     {
-      seasons.push_back(make_pair(m_pDS2->fv(0).get_asInt(), m_pDS2->fv(1).get_asInt()));
+      seasons.insert(make_pair(m_pDS2->fv(1).get_asInt(), m_pDS2->fv(0).get_asInt()));
       m_pDS2->next();
     }
     m_pDS2->close();
+    return true;
+  }
+  catch (...)
+  {
+    CLog::Log(LOGERROR, "%s(%d) failed", __FUNCTION__, showId);
+  }
+  return false;
+}
+
+bool CVideoDatabase::GetTvShowSeasonArt(int showId, map<int, map<string, string> > &seasonArt)
+{
+  try
+  {
+    if (NULL == m_pDB.get()) return false;
+    if (NULL == m_pDS2.get()) return false; // using dataset 2 as we're likely called in loops on dataset 1
+
+    map<int, int> seasons;
+    GetTvShowSeasons(showId, seasons);
 
-    for (vector< pair<int,int> >::const_iterator i = seasons.begin(); i != seasons.end(); ++i)
+    for (map<int, int>::const_iterator i = seasons.begin(); i != seasons.end(); ++i)
     {
       map<string, string> art;
-      GetArtForItem(i->first, MediaTypeSeason, art);
-      seasonArt.insert(make_pair(i->second,art));
+      GetArtForItem(i->second, MediaTypeSeason, art);
+      seasonArt.insert(make_pair(i->first,art));
     }
     return true;
   }
diff --git a/xbmc/video/VideoDatabase.h b/xbmc/video/VideoDatabase.h
index 093a48e..9db34f4 100644
--- a/xbmc/video/VideoDatabase.h
+++ b/xbmc/video/VideoDatabase.h
@@ -738,6 +738,7 @@ class CVideoDatabase : public CDatabase
   std::string GetArtForItem(int mediaId, const MediaType &mediaType, const std::string &artType);
   bool RemoveArtForItem(int mediaId, const MediaType &mediaType, const std::string &artType);
   bool RemoveArtForItem(int mediaId, const MediaType &mediaType, const std::set<std::string> &artTypes);
+  bool GetTvShowSeasons(int showId, std::map<int, int> &seasons);
   bool GetTvShowSeasonArt(int mediaId, std::map<int, std::map<std::string, std::string> > &seasonArt);
   bool GetArtTypes(const MediaType &mediaType, std::vector<std::string> &artTypes);
 
-- 
1.9.3


From e66f4c004028a0abdb10f630f7e5c3aec2c1d9c1 Mon Sep 17 00:00:00 2001
From: Jonathan Marshall <jmarshall@xbmc.org>
Date: Sat, 2 Nov 2013 23:50:10 +1300
Subject: [PATCH 054/102] move AddSeason() public.

---
 xbmc/video/VideoDatabase.h | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/xbmc/video/VideoDatabase.h b/xbmc/video/VideoDatabase.h
index 9db34f4..eaf2e36 100644
--- a/xbmc/video/VideoDatabase.h
+++ b/xbmc/video/VideoDatabase.h
@@ -749,6 +749,7 @@ class CVideoDatabase : public CDatabase
 
   virtual bool GetFilter(CDbUrl &videoUrl, Filter &filter, SortDescription &sorting);
 
+  int AddSeason(int showID, int season);
   int AddSet(const CStdString& strSet);
   void ClearMovieSet(int idMovie);
   void SetMovieSet(int idMovie, int idSet);
@@ -779,7 +780,6 @@ class CVideoDatabase : public CDatabase
 
   int AddTvShow();
   int AddMusicVideo(const CStdString& strFilenameAndPath);
-  int AddSeason(int showID, int season);
 
   /*! \brief Adds a path to the tvshow link table.
    \param idShow the id of the show.
-- 
1.9.3


From a621b135be3841fa8a3b20f8c63c2d3f81a8d8c2 Mon Sep 17 00:00:00 2001
From: Jonathan Marshall <jmarshall@xbmc.org>
Date: Sat, 2 Nov 2013 23:48:24 +1300
Subject: [PATCH 055/102] adds GetArt function to (video) scraper, allowing art
 to be fetched given the video identifier.

---
 xbmc/addons/Scraper.cpp            | 38 ++++++++++++++++++++++++++++++++++++++
 xbmc/addons/Scraper.h              |  3 +++
 xbmc/video/VideoInfoDownloader.cpp |  5 +++++
 xbmc/video/VideoInfoDownloader.h   |  7 +++++++
 4 files changed, 53 insertions(+)

diff --git a/xbmc/addons/Scraper.cpp b/xbmc/addons/Scraper.cpp
index 8ab526c..9c32bb5 100644
--- a/xbmc/addons/Scraper.cpp
+++ b/xbmc/addons/Scraper.cpp
@@ -925,6 +925,44 @@ EPISODELIST CScraper::GetEpisodeList(XFILE::CCurlFile &fcurl, const CScraperUrl
   return vcep;
 }
 
+// takes URL; returns true and populates art XML details on success, false otherwise
+bool CScraper::GetArt(XFILE::CCurlFile &fcurl, const std::string &id, CVideoInfoTag &video)
+{
+  CLog::Log(LOGDEBUG, "%s: Reading art for '%s' using %s scraper "
+            "(file: '%s', content: '%s', version: '%s')", __FUNCTION__, id.c_str(), Name().c_str(), Path().c_str(),
+            ADDON::TranslateContent(Content()).c_str(), Version().asString().c_str());
+
+  video.Reset();
+  vector<string> vcsIn;
+  CScraperUrl scurl;
+  vcsIn.push_back(id);
+  vector<string> vcsOut = RunNoThrow("GetArt", scurl, fcurl, &vcsIn);
+
+  // parse XML output
+  bool fRet(false);
+  for (vector<string>::const_iterator i = vcsOut.begin(); i != vcsOut.end(); ++i)
+  {
+    CXBMCTinyXML doc;
+    doc.Parse(*i, TIXML_ENCODING_UTF8);
+    if (!doc.RootElement())
+    {
+      CLog::Log(LOGERROR, "%s: Unable to parse XML", __FUNCTION__);
+      continue;
+    }
+
+    TiXmlHandle xhDoc(&doc);
+    TiXmlElement *pxeDetails = xhDoc.FirstChild("details").Element();
+    if (!pxeDetails)
+    {
+      CLog::Log(LOGERROR, "%s: Invalid XML file (want <details>)", __FUNCTION__);
+      continue;
+    }
+    video.Load(pxeDetails, true/*fChain*/);
+    fRet = true;  // but don't exit in case of chaining
+  }
+  return fRet;
+}
+
 // takes URL; returns true and populates video details on success, false otherwise
 bool CScraper::GetVideoDetails(XFILE::CCurlFile &fcurl, const CScraperUrl &scurl,
   bool fMovie/*else episode*/, CVideoInfoTag &video)
diff --git a/xbmc/addons/Scraper.h b/xbmc/addons/Scraper.h
index 717a480..d27747a 100644
--- a/xbmc/addons/Scraper.h
+++ b/xbmc/addons/Scraper.h
@@ -18,6 +18,8 @@
  *  <http://www.gnu.org/licenses/>.
  *
  */
+
+#include <string>
 #include "addons/Addon.h"
 #include "XBDateTime.h"
 #include "utils/ScraperUrl.h"
@@ -146,6 +148,7 @@ class CScraper : public CAddon
     CAlbum &album);
   bool GetArtistDetails(XFILE::CCurlFile &fcurl, const CScraperUrl &scurl,
     const CStdString &sSearch, CArtist &artist);
+  bool GetArt(XFILE::CCurlFile &fcurl, const std::string &id, CVideoInfoTag &video);
 
 private:
   CScraper(const CScraper &rhs);
diff --git a/xbmc/video/VideoInfoDownloader.cpp b/xbmc/video/VideoInfoDownloader.cpp
index f33ac8a..5d84734 100644
--- a/xbmc/video/VideoInfoDownloader.cpp
+++ b/xbmc/video/VideoInfoDownloader.cpp
@@ -191,6 +191,11 @@ bool CVideoInfoDownloader::GetDetails(const CScraperUrl &url,
     return m_info->GetVideoDetails(*m_http, url, true/*fMovie*/, movieDetails);
 }
 
+bool CVideoInfoDownloader::GetArt(const std::string &id, CVideoInfoTag &details)
+{
+  return m_info->GetArt(*m_http, id, details);
+}
+
 bool CVideoInfoDownloader::GetEpisodeDetails(const CScraperUrl &url,
                                              CVideoInfoTag &movieDetails,
                                              CGUIDialogProgress *pProgress /* = NULL */)
diff --git a/xbmc/video/VideoInfoDownloader.h b/xbmc/video/VideoInfoDownloader.h
index 22ac229..75bc341 100644
--- a/xbmc/video/VideoInfoDownloader.h
+++ b/xbmc/video/VideoInfoDownloader.h
@@ -59,6 +59,13 @@ class CVideoInfoDownloader : public CThread
 
   static void ShowErrorDialog(const ADDON::CScraperError &sce);
 
+  /*! \brief Grab art URLs for an item with the scraper
+   \param id the unique identifier used by the scraper to describe the item.
+   \param details [out] the video info tag structure to fill with art.
+   \return true on success, false on failure.
+   */
+  bool GetArt(const std::string &id, CVideoInfoTag &details);
+
 protected:
   enum LOOKUP_STATE { DO_NOTHING = 0,
                       FIND_MOVIE = 1,
-- 
1.9.3


From a42f7ed37045b85d7ae79a79230438d6834e8d13 Mon Sep 17 00:00:00 2001
From: Jonathan Marshall <jmarshall@xbmc.org>
Date: Sat, 2 Nov 2013 23:53:14 +1300
Subject: [PATCH 056/102] refresh season art if a new season is found that
 isn't recorded in the database yet. Fixes #14339

---
 xbmc/video/VideoInfoScanner.cpp | 33 ++++++++++++++++++++++++++++++++-
 xbmc/video/VideoInfoScanner.h   |  2 ++
 2 files changed, 34 insertions(+), 1 deletion(-)

diff --git a/xbmc/video/VideoInfoScanner.cpp b/xbmc/video/VideoInfoScanner.cpp
index b5a5864..e0056bd 100644
--- a/xbmc/video/VideoInfoScanner.cpp
+++ b/xbmc/video/VideoInfoScanner.cpp
@@ -1361,6 +1361,10 @@ namespace VIDEO
       pDlgProgress->Progress();
     }
 
+    bool updateSeasons = false;
+    map<int, int> seasons;
+    m_database.GetTvShowSeasons(showInfo.m_iDbId, seasons);
+
     EPISODELIST episodes;
     bool hasEpisodeGuide = false;
 
@@ -1409,6 +1413,8 @@ namespace VIDEO
         }
         if (AddVideo(&item, CONTENT_TVSHOWS, file->isFolder, true, &showInfo) < 0)
           return INFO_ERROR;
+        if (seasons.find(item.GetVideoInfoTag()->m_iSeason) == seasons.end())
+          updateSeasons = true;
         continue;
       }
 
@@ -1538,6 +1544,8 @@ namespace VIDEO
           
         if (AddVideo(&item, CONTENT_TVSHOWS, file->isFolder, useLocal, &showInfo) < 0)
           return INFO_ERROR;
+        if (seasons.find(item.GetVideoInfoTag()->m_iSeason) == seasons.end())
+          updateSeasons = true;
       }
       else
       {
@@ -1546,9 +1554,27 @@ namespace VIDEO
                   file->cDate.GetAsLocalizedDate().c_str(), file->strTitle.c_str());
       }
     }
+    if (updateSeasons)
+      UpdateSeasons(showInfo, scraper, useLocal);
     return INFO_ADDED;
   }
 
+  void CVideoInfoScanner::UpdateSeasons(const CVideoInfoTag &showInfo, const ADDON::ScraperPtr &scraper, bool useLocal)
+  {
+    map<int, map<string, string> > seasonArt;
+    m_database.GetTvShowSeasonArt(showInfo.m_iDbId, seasonArt);
+    CVideoInfoTag details;
+    CVideoInfoDownloader loader(scraper);
+    loader.GetArt(showInfo.m_strIMDBNumber, details);
+    details.m_strPath = showInfo.m_strPath;
+    GetSeasonThumbs(details, seasonArt, CVideoThumbLoader::GetArtTypes("season"), useLocal);
+    for (map<int, map<string, string> >::iterator i = seasonArt.begin(); i != seasonArt.end(); ++i)
+    {
+      int seasonID = m_database.AddSeason(showInfo.m_iDbId, i->first);
+      m_database.SetArtForItem(seasonID, "season", i->second);
+    }
+  }
+
   CStdString CVideoInfoScanner::GetnfoFile(CFileItem *item, bool bGrabAny) const
   {
     CStdString nfoFile;
@@ -1817,6 +1843,11 @@ namespace VIDEO
     }
     for (int season = -1; season <= maxSeasons; season++)
     {
+      // skip if we already have some art
+      map<int, map<string, string> >::const_iterator i = seasonArt.find(season);
+      if (i != seasonArt.end() && !i->second.empty())
+        continue;
+
       map<string, string> art;
       if (useLocal)
       {
@@ -1870,7 +1901,7 @@ namespace VIDEO
           art.insert(make_pair(artTypes.front(), image));
       }
 
-      seasonArt.insert(make_pair(season, art));
+      seasonArt[season] = art;
     }
   }
 
diff --git a/xbmc/video/VideoInfoScanner.h b/xbmc/video/VideoInfoScanner.h
index 2f0d60f..94fca85 100644
--- a/xbmc/video/VideoInfoScanner.h
+++ b/xbmc/video/VideoInfoScanner.h
@@ -228,6 +228,8 @@ namespace VIDEO
      */
     INFO_RET OnProcessSeriesFolder(EPISODELIST& files, const ADDON::ScraperPtr &scraper, bool useLocal, const CVideoInfoTag& showInfo, CGUIDialogProgress* pDlgProgress = NULL);
 
+    void UpdateSeasons(const CVideoInfoTag &showInfo, const ADDON::ScraperPtr &scraper, bool useLocal);
+
     bool EnumerateSeriesFolder(CFileItem* item, EPISODELIST& episodeList);
     bool EnumerateEpisodeItem(const CFileItem *item, EPISODELIST& episodeList);
     bool ProcessItemByVideoInfoTag(const CFileItem *item, EPISODELIST &episodeList);
-- 
1.9.3


From fbb40d3e32c9f0181c39e025d8ef05fbfdb0b31f Mon Sep 17 00:00:00 2001
From: Jonathan Marshall <jmarshall@xbmc.org>
Date: Sat, 2 Nov 2013 23:53:34 +1300
Subject: [PATCH 057/102] REMOVEME: updated thetvdb.com scraper to support art
 updates

---
 addons/metadata.tvdb.com/tvdb.xml | 59 +++++++++++++++++++++++++--------------
 1 file changed, 38 insertions(+), 21 deletions(-)

diff --git a/addons/metadata.tvdb.com/tvdb.xml b/addons/metadata.tvdb.com/tvdb.xml
index 39e604d..60a0e96 100644
--- a/addons/metadata.tvdb.com/tvdb.xml
+++ b/addons/metadata.tvdb.com/tvdb.xml
@@ -99,57 +99,74 @@
 			<RegExp input="$$5" output="&lt;actor&gt;&lt;name&gt;\2&lt;/name&gt;&lt;role&gt;\3&lt;/role&gt;&lt;/actor&gt;" dest="4+">
 				<expression repeat="yes" noclean="1,2,3">&lt;Actor&gt;.*?&lt;Image&gt;([^&lt;]*)&lt;/Image&gt;.*?&lt;Name&gt;([^&lt;]*)&lt;/Name&gt;.*?&lt;Role&gt;([^&lt;]*)</expression>
 			</RegExp>
-			<RegExp input="$$5" output="&lt;thumb aspect=&quot;banner&quot;&gt;http://thetvdb.com/banners/\1&lt;/thumb&gt;" dest="4+">
+			<RegExp input="$$2" output="&lt;chain function=&quot;GetArt&quot;&gt;\1&lt;/chain&gt;" dest="4+">
+				<expression/>
+			</RegExp>
+			<RegExp input="$$3" output="\1" dest="6">
+				<expression>.*/(.*).zip</expression>
+			</RegExp>
+			<RegExp input="$$3" output="&lt;episodeguide&gt;&lt;url cache=&quot;$$2-$$6.xml&quot;&gt;\1&lt;/url&gt;&lt;/episodeguide&gt;" dest="4+">
+				<expression/>
+			</RegExp>
+			<expression noclean="1"/>
+		</RegExp>
+	</GetDetails>
+
+	<GetArt dest="3">
+		<RegExp input="$$4" output="&lt;details&gt;\1&lt;/details&gt;" dest="3">
+			<RegExp input="$$1" output="&lt;url function=&quot;ParseArt&quot; cache=&quot;\1-banners.xml&quot;&gt;http://thetvdb.com/api/1D62F2F90030C444/series/\1/banners.xml&lt;/url&gt;" dest="4">
+				<expression/>
+			</RegExp>
+			<expression noclean="1"/>
+		</RegExp>
+	</GetArt>
+	<ParseArt dest="3">
+		<RegExp input="$$4" output="&lt;details&gt;\1&lt;/details&gt;" dest="3">
+			<RegExp input="$$1" output="&lt;thumb aspect=&quot;banner&quot;&gt;http://thetvdb.com/banners/\1&lt;/thumb&gt;" dest="4">
 				<expression repeat="yes">&lt;BannerPath&gt;([^&lt;]*)&lt;/BannerPath&gt;[^&lt;]*&lt;BannerType&gt;series&lt;/BannerType&gt;[^&lt;]*&lt;BannerType2&gt;graphical&lt;/BannerType2&gt;[^&lt;]*&lt;Language&gt;$INFO[language]&lt;/Language&gt;</expression>
 			</RegExp>
-			<RegExp input="$$5" output="&lt;thumb aspect=&quot;banner&quot;&gt;http://thetvdb.com/banners/\1&lt;/thumb&gt;" dest="4+">
+			<RegExp input="$$1" output="&lt;thumb aspect=&quot;banner&quot;&gt;http://thetvdb.com/banners/\1&lt;/thumb&gt;" dest="4+">
 				<expression repeat="yes">&lt;BannerPath&gt;([^&lt;]*)&lt;/BannerPath&gt;[^&lt;]*&lt;BannerType&gt;series&lt;/BannerType&gt;[^&lt;]*&lt;BannerType2&gt;graphical&lt;/BannerType2&gt;[^&lt;]*&lt;Language&gt;((?!$INFO[language])[a-z])*&lt;/Language&gt;</expression>
 			</RegExp>
-			<RegExp input="$$5" output="&lt;thumb aspect=&quot;banner&quot;&gt;http://thetvdb.com/banners/\1&lt;/thumb&gt;" dest="4+">
+			<RegExp input="$$1" output="&lt;thumb aspect=&quot;banner&quot;&gt;http://thetvdb.com/banners/\1&lt;/thumb&gt;" dest="4+">
 				<expression repeat="yes">&lt;BannerPath&gt;([^&lt;]*)&lt;/BannerPath&gt;[^&lt;]*&lt;BannerType&gt;series&lt;/BannerType&gt;[^&lt;]*&lt;BannerType2&gt;text&lt;/BannerType2&gt;[^&lt;]*&lt;Language&gt;$INFO[language]&lt;/Language&gt;</expression>
 			</RegExp>
-			<RegExp input="$$5" output="&lt;thumb aspect=&quot;banner&quot;&gt;http://thetvdb.com/banners/\1&lt;/thumb&gt;" dest="4+">
+			<RegExp input="$$1" output="&lt;thumb aspect=&quot;banner&quot;&gt;http://thetvdb.com/banners/\1&lt;/thumb&gt;" dest="4+">
 				<expression repeat="yes">&lt;BannerPath&gt;([^&lt;]*)&lt;/BannerPath&gt;[^&lt;]*&lt;BannerType&gt;series&lt;/BannerType&gt;[^&lt;]*&lt;BannerType2&gt;text&lt;/BannerType2&gt;[^&lt;]*&lt;Language&gt;((?!$INFO[language])[a-z])*&lt;/Language&gt;</expression>
 			</RegExp>
-			<RegExp input="$$5" output="&lt;thumb aspect=&quot;banner&quot;&gt;http://thetvdb.com/banners/\1&lt;/thumb&gt;" dest="4+">
+			<RegExp input="$$1" output="&lt;thumb aspect=&quot;banner&quot;&gt;http://thetvdb.com/banners/\1&lt;/thumb&gt;" dest="4+">
 				<expression repeat="yes">&lt;BannerPath&gt;([^&lt;]*)&lt;/BannerPath&gt;[^&lt;]*&lt;BannerType&gt;series&lt;/BannerType&gt;[^&lt;]*&lt;BannerType2&gt;blank&lt;/BannerType2&gt;[^&lt;]*&lt;Language&gt;&lt;/Language&gt;</expression>
 			</RegExp>
-			<RegExp input="$$5" output="&lt;thumb aspect=&quot;poster&quot; type=&quot;season&quot; season=&quot;\2&quot;&gt;http://thetvdb.com/banners/\1&lt;/thumb&gt;" dest="4+">
+			<RegExp input="$$1" output="&lt;thumb aspect=&quot;poster&quot; type=&quot;season&quot; season=&quot;\2&quot;&gt;http://thetvdb.com/banners/\1&lt;/thumb&gt;" dest="4+">
 				<expression repeat="yes">&lt;BannerPath&gt;([^&lt;]*)&lt;/BannerPath&gt;[^&lt;]*&lt;BannerType&gt;season&lt;/BannerType&gt;[^&lt;]*&lt;BannerType2&gt;season&lt;/BannerType2&gt;[^&lt;]*&lt;Language&gt;$INFO[language]&lt;/Language&gt;[^&lt;]*[^S]*Season&gt;([0-9]+)&lt;/Season&gt;</expression>
 			</RegExp>
-			<RegExp input="$$5" output="&lt;thumb aspect=&quot;poster&quot; type=&quot;season&quot; season=&quot;\3&quot;&gt;http://thetvdb.com/banners/\1&lt;/thumb&gt;" dest="4+">
+			<RegExp input="$$1" output="&lt;thumb aspect=&quot;poster&quot; type=&quot;season&quot; season=&quot;\3&quot;&gt;http://thetvdb.com/banners/\1&lt;/thumb&gt;" dest="4+">
 				<expression repeat="yes">&lt;BannerPath&gt;([^&lt;]*)&lt;/BannerPath&gt;[^&lt;]*&lt;BannerType&gt;season&lt;/BannerType&gt;[^&lt;]*&lt;BannerType2&gt;season&lt;/BannerType2&gt;[^&lt;]*&lt;Language&gt;((?!$INFO[language])[a-z])*&lt;/Language&gt;[^&lt;]*[^S]*Season&gt;([0-9]+)&lt;/Season&gt;</expression>
 			</RegExp>
-			<RegExp input="$$5" output="&lt;thumb aspect=&quot;banner&quot; type=&quot;season&quot; season=&quot;\2&quot;&gt;http://thetvdb.com/banners/\1&lt;/thumb&gt;" dest="4+">
+			<RegExp input="$$1" output="&lt;thumb aspect=&quot;banner&quot; type=&quot;season&quot; season=&quot;\2&quot;&gt;http://thetvdb.com/banners/\1&lt;/thumb&gt;" dest="4+">
 				<expression repeat="yes">&lt;BannerPath&gt;([^&lt;]*)&lt;/BannerPath&gt;[^&lt;]*&lt;BannerType&gt;season&lt;/BannerType&gt;[^&lt;]*&lt;BannerType2&gt;seasonwide&lt;/BannerType2&gt;[^&lt;]*&lt;Language&gt;$INFO[language]&lt;/Language&gt;[^&lt;]*[^S]*Season&gt;([0-9]+)&lt;/Season&gt;</expression>
 			</RegExp>
-			<RegExp input="$$5" output="&lt;thumb aspect=&quot;banner&quot; type=&quot;season&quot; season=&quot;\3&quot;&gt;http://thetvdb.com/banners/\1&lt;/thumb&gt;" dest="4+">
+			<RegExp input="$$1" output="&lt;thumb aspect=&quot;banner&quot; type=&quot;season&quot; season=&quot;\3&quot;&gt;http://thetvdb.com/banners/\1&lt;/thumb&gt;" dest="4+">
 				<expression repeat="yes">&lt;BannerPath&gt;([^&lt;]*)&lt;/BannerPath&gt;[^&lt;]*&lt;BannerType&gt;season&lt;/BannerType&gt;[^&lt;]*&lt;BannerType2&gt;seasonwide&lt;/BannerType2&gt;[^&lt;]*&lt;Language&gt;((?!$INFO[language])[a-z])*&lt;/Language&gt;[^&lt;]*[^S]*Season&gt;([0-9]+)&lt;/Season&gt;</expression>
 			</RegExp>
-			<RegExp input="$$5" output="&lt;thumb aspect=&quot;poster&quot;&gt;http://thetvdb.com/banners/\1&lt;/thumb&gt;" dest="4+">
+			<RegExp input="$$1" output="&lt;thumb aspect=&quot;poster&quot;&gt;http://thetvdb.com/banners/\1&lt;/thumb&gt;" dest="4+">
 				<expression repeat="yes">&lt;BannerPath&gt;([^&lt;]*)&lt;/BannerPath&gt;[^&lt;]*&lt;BannerType&gt;poster&lt;/BannerType&gt;</expression>
 			</RegExp>
-			<RegExp input="$$5" output="&lt;thumb aspect=&quot;poster&quot; type=&quot;season&quot; season=&quot;-1&quot;&gt;http://thetvdb.com/banners/\1&lt;/thumb&gt;" dest="4+">
+			<RegExp input="$$1" output="&lt;thumb aspect=&quot;poster&quot; type=&quot;season&quot; season=&quot;-1&quot;&gt;http://thetvdb.com/banners/\1&lt;/thumb&gt;" dest="4+">
 				<expression repeat="yes">&lt;BannerPath&gt;([^&lt;]*)&lt;/BannerPath&gt;[^&lt;]*&lt;BannerType&gt;poster&lt;/BannerType&gt;</expression>
 			</RegExp>
-			<RegExp conditional="fanart" input="$$7" output="&lt;fanart url=&quot;http://thetvdb.com/banners/&quot;&gt;\1&lt;/fanart&gt;" dest="4+">
-				<RegExp input="$$5" output="&lt;thumb dim=&quot;\2&quot; colors=&quot;\3&quot; preview=&quot;_cache/\1&quot;&gt;\1&lt;/thumb&gt;" dest="7+">
+			<RegExp conditional="fanart" input="$$5" output="&lt;fanart url=&quot;http://thetvdb.com/banners/&quot;&gt;\1&lt;/fanart&gt;" dest="4+">
+				<RegExp input="$$1" output="&lt;thumb dim=&quot;\2&quot; colors=&quot;\3&quot; preview=&quot;_cache/\1&quot;&gt;\1&lt;/thumb&gt;" dest="5">
 					<expression repeat="yes">&lt;BannerPath&gt;([^&lt;]*)&lt;/BannerPath&gt;[^&lt;]*&lt;BannerType&gt;fanart&lt;/BannerType&gt;[^&lt;]*&lt;BannerType2&gt;([^&lt;]*)&lt;/BannerType2&gt;[^&lt;]*&lt;Colors&gt;([^&lt;]*)&lt;/Colors&gt;[^&lt;]*&lt;Language&gt;$INFO[language]&lt;/Language&gt;</expression>
 				</RegExp>
-				<RegExp input="$$5" output="&lt;thumb dim=&quot;\2&quot; colors=&quot;\3&quot; preview=&quot;_cache/\1&quot;&gt;\1&lt;/thumb&gt;" dest="7+">
+				<RegExp input="$$1" output="&lt;thumb dim=&quot;\2&quot; colors=&quot;\3&quot; preview=&quot;_cache/\1&quot;&gt;\1&lt;/thumb&gt;" dest="5+">
 					<expression repeat="yes">&lt;BannerPath&gt;([^&lt;]*)&lt;/BannerPath&gt;[^&lt;]*&lt;BannerType&gt;fanart&lt;/BannerType&gt;[^&lt;]*&lt;BannerType2&gt;([^&lt;]*)&lt;/BannerType2&gt;[^&lt;]*&lt;Colors&gt;([^&lt;]*)&lt;/Colors&gt;[^&lt;]*&lt;Language&gt;((?!$INFO[language])[a-z])*&lt;/Language&gt;</expression>
 				</RegExp>
 				<expression noclean="1"/>
 			</RegExp>
-			<RegExp input="$$3" output="\1" dest="6">
-				<expression>.*/(.*).zip</expression>
-			</RegExp>
-			<RegExp input="$$3" output="&lt;episodeguide&gt;&lt;url cache=&quot;$$2-$$6.xml&quot;&gt;\1&lt;/url&gt;&lt;/episodeguide&gt;" dest="4+">
-				<expression/>
-			</RegExp>
 			<expression noclean="1"/>
 		</RegExp>
-	</GetDetails>
+	</ParseArt>
 
 	<!-- input:	$1=html !-->
 	<!-- input:	$2=series url !-->
-- 
1.9.3


From 8d71a5c0f9f90c5450c1a644c3f8d510494bef4f Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Sat, 22 Mar 2014 16:40:01 +0000
Subject: [PATCH 058/102] Enable PYTHONOPTIMIZE for Pi

---
 xbmc/interfaces/python/XBPython.cpp | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/xbmc/interfaces/python/XBPython.cpp b/xbmc/interfaces/python/XBPython.cpp
index 0d6dabc..c3fd0f1 100644
--- a/xbmc/interfaces/python/XBPython.cpp
+++ b/xbmc/interfaces/python/XBPython.cpp
@@ -462,6 +462,10 @@ bool XBPython::InitializeEngine()
       }
 #endif
 
+// Lets enable for Pi
+#if defined(TARGET_RASPBERRY_PI)
+   setenv("PYTHONOPTIMIZE", "1", 1);
+#endif
 
 // Darwin packs .pyo files, we need PYTHONOPTIMIZE on in order to load them.
 #if defined(TARGET_DARWIN)
-- 
1.9.3


From 4d75c729f34c7a3240c7ba2f4ba4f685b98772f5 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Mon, 28 Apr 2014 18:07:45 +0100
Subject: [PATCH 059/102] [rpi] Make ActiveAE thread higher priority to make
 audio underrun less likely

---
 xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp
index a4337f1..3ac182a 100644
--- a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp
+++ b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp
@@ -2168,6 +2168,12 @@ void CActiveAE::LoadSettings()
 bool CActiveAE::Initialize()
 {
   Create();
+
+#ifdef TARGET_RASPBERRY_PI
+  /* audio normally won't consume full cpu, so let it have prio */
+  SetPriority(GetPriority()+1);
+#endif
+
   Message *reply;
   if (m_controlPort.SendOutMessageSync(CActiveAEControlProtocol::INIT,
                                                  &reply,
-- 
1.9.3


From 8ac8fd1742b9ee3cf118806f13798760f19cab63 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Tue, 29 Apr 2014 15:23:22 +0100
Subject: [PATCH 060/102] [ffmpeg] Speed up wtv index creation

The index creation is O(N^2) with number of entries (typically thousands).
On a Pi this can take more than 60 seconds to execute for a recording of a few hours.

By replacing with an O(N) loop, this takes virtually zero time
---
 tools/depends/target/ffmpeg/Makefile               |  3 +-
 .../ffmpeg_Speed_up_wtv_index_creation.patch       | 47 ++++++++++++++++++++++
 2 files changed, 49 insertions(+), 1 deletion(-)
 create mode 100644 tools/depends/target/ffmpeg/ffmpeg_Speed_up_wtv_index_creation.patch

diff --git a/tools/depends/target/ffmpeg/Makefile b/tools/depends/target/ffmpeg/Makefile
index 51e1918..f514ae6 100644
--- a/tools/depends/target/ffmpeg/Makefile
+++ b/tools/depends/target/ffmpeg/Makefile
@@ -1,6 +1,6 @@
 include ../../Makefile.include
 include FFMPEG-VERSION
-DEPS= ../../Makefile.include FFMPEG-VERSION Makefile
+DEPS= ../../Makefile.include FFMPEG-VERSION Makefile ffmpeg_Speed_up_wtv_index_creation.patch
 
 # set to "yes" to enable patching
 # we don't apply patches until we move to a vanilla ffmpeg tarball
@@ -63,6 +63,7 @@ $(PLATFORM): $(TARBALLS_LOCATION)/$(ARCHIVE) $(DEPS)
 	rm -rf $(PLATFORM); mkdir -p $(PLATFORM)
 	cd $(PLATFORM); $(ARCHIVE_TOOL) $(ARCHIVE_TOOL_FLAGS) $(TARBALLS_LOCATION)/$(ARCHIVE)
 	cd $(PLATFORM); sed -i".bak" -e "s%pkg_config_default=pkg-config%export PKG_CONFIG_LIBDIR=$(PREFIX)/lib/pkgconfig\npkg_config_default=$(NATIVEPREFIX)/bin/pkg-config%" configure
+	cd $(PLATFORM); patch -p3 < ../ffmpeg_Speed_up_wtv_index_creation.patch
 	cd $(PLATFORM);\
 	CFLAGS="$(CFLAGS)" CXXFLAGS="$(CXXFLAGS)" CPPFLAGS="$(CPPFLAGS)" LDFLAGS="$(LDFLAGS)" \
 	./configure $(ffmpg_config)
diff --git a/tools/depends/target/ffmpeg/ffmpeg_Speed_up_wtv_index_creation.patch b/tools/depends/target/ffmpeg/ffmpeg_Speed_up_wtv_index_creation.patch
new file mode 100644
index 0000000..8f5f989
--- /dev/null
+++ b/tools/depends/target/ffmpeg/ffmpeg_Speed_up_wtv_index_creation.patch
@@ -0,0 +1,47 @@
+commit 0e7427498cb1131671f6fe9d054245ae7e5a36f5
+Author: popcornmix <popcornmix@gmail.com>
+Date:   Tue Mar 25 19:43:07 2014 +0000
+
+    [ffmpeg] Speed up wtv index creation
+
+    The index creation is O(N^2) with number of entries (typically thousands).
+    On a Pi this can take more than 60 seconds to execute for a recording of a few hours.
+
+    By replacing with an O(N) loop, this takes virtually zero time
+
+diff --git a/lib/ffmpeg/libavformat/wtvdec.c b/lib/ffmpeg/libavformat/wtvdec.c
+index e423370..70898bd 100644
+--- a/lib/ffmpeg/libavformat/wtvdec.c
++++ b/lib/ffmpeg/libavformat/wtvdec.c
+@@ -980,21 +980,23 @@ static int read_header(AVFormatContext *s)
+                 pb = wtvfile_open(s, root, root_size, ff_timeline_table_0_entries_Events_le16);
+                 if (pb) {
+                     int i;
++                    AVIndexEntry *e = wtv->index_entries;
++                    AVIndexEntry *e_end = wtv->index_entries + wtv->nb_index_entries - 1;
++                    uint64_t last_position = 0;
+                     while (1) {
+                         uint64_t frame_nb = avio_rl64(pb);
+                         uint64_t position = avio_rl64(pb);
++                        while (frame_nb > e->size && e <= e_end) {
++                           e->pos = last_position;
++                           e++;
++                        }
+                         if (url_feof(pb))
+                             break;
+-                        for (i = wtv->nb_index_entries - 1; i >= 0; i--) {
+-                            AVIndexEntry *e = wtv->index_entries + i;
+-                            if (frame_nb > e->size)
+-                                break;
+-                            if (position > e->pos)
+-                                e->pos = position;
+-                        }
++                        last_position = position;
+                     }
++                    e_end->pos = last_position;
+                     wtvfile_close(pb);
+-                    st->duration = wtv->index_entries[wtv->nb_index_entries - 1].timestamp;
++                    st->duration = e_end->timestamp;
+                 }
+             }
+         }
-- 
1.9.3


From 5a4f696fb8f2406f3caafbe88447db0ed3368283 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Tue, 29 Apr 2014 15:55:28 +0100
Subject: [PATCH 061/102] [ffmpeg] vc-1: Optimise parser (with special
 attention to ARM)

Backport from upstream ffmpeg
---
 ...earch-code-search-functions-into-separate.patch | 752 +++++++++++++++++++++
 ...atform-specific-start-code-search-routine.patch | 143 ++++
 ...mise-parser-with-special-attention-to-ARM.patch | 401 +++++++++++
 tools/depends/target/ffmpeg/Makefile               |   8 +-
 4 files changed, 1303 insertions(+), 1 deletion(-)
 create mode 100644 tools/depends/target/ffmpeg/0001-h264-Move-search-code-search-functions-into-separate.patch
 create mode 100644 tools/depends/target/ffmpeg/0002-vc-1-Add-platform-specific-start-code-search-routine.patch
 create mode 100644 tools/depends/target/ffmpeg/0003-vc-1-Optimise-parser-with-special-attention-to-ARM.patch

diff --git a/tools/depends/target/ffmpeg/0001-h264-Move-search-code-search-functions-into-separate.patch b/tools/depends/target/ffmpeg/0001-h264-Move-search-code-search-functions-into-separate.patch
new file mode 100644
index 0000000..62e473d
--- /dev/null
+++ b/tools/depends/target/ffmpeg/0001-h264-Move-search-code-search-functions-into-separate.patch
@@ -0,0 +1,752 @@
+From 8cdb3bf2837a3fb4fff3c6586316f81ae5f7b6cd Mon Sep 17 00:00:00 2001
+From: Ben Avison <bavison@riscosopen.org>
+Date: Wed, 16 Apr 2014 01:51:31 +0100
+Subject: [PATCH 1/3] h264: Move search code search functions into separate
+ source files.
+
+This permits re-use with parsers for codecs which use similar start codes.
+
+Signed-off-by: Michael Niedermayer <michaelni@gmx.at>
+---
+ libavcodec/Makefile               |   2 +-
+ libavcodec/arm/Makefile           |   2 +-
+ libavcodec/arm/h264dsp_armv6.S    | 253 --------------------------------------
+ libavcodec/arm/h264dsp_init_arm.c |   4 +-
+ libavcodec/arm/startcode_armv6.S  | 253 ++++++++++++++++++++++++++++++++++++++
+ libavcodec/h264dsp.c              |  31 +----
+ libavcodec/startcode.c            |  57 +++++++++
+ libavcodec/startcode.h            |  35 ++++++
+ 8 files changed, 351 insertions(+), 286 deletions(-)
+ delete mode 100644 libavcodec/arm/h264dsp_armv6.S
+ create mode 100644 libavcodec/arm/startcode_armv6.S
+ create mode 100644 libavcodec/startcode.c
+ create mode 100644 libavcodec/startcode.h
+
+diff --git a/libavcodec/Makefile b/libavcodec/Makefile
+index b56ecd1..19caf11 100644
+--- a/libavcodec/Makefile
++++ b/libavcodec/Makefile
+@@ -49,7 +49,7 @@ OBJS-$(CONFIG_FFT)                     += avfft.o fft_fixed.o fft_float.o \
+ OBJS-$(CONFIG_GOLOMB)                  += golomb.o
+ OBJS-$(CONFIG_H263DSP)                 += h263dsp.o
+ OBJS-$(CONFIG_H264CHROMA)              += h264chroma.o
+-OBJS-$(CONFIG_H264DSP)                 += h264dsp.o h264idct.o
++OBJS-$(CONFIG_H264DSP)                 += h264dsp.o h264idct.o startcode.o
+ OBJS-$(CONFIG_H264PRED)                += h264pred.o
+ OBJS-$(CONFIG_H264QPEL)                += h264qpel.o
+ OBJS-$(CONFIG_HPELDSP)                 += hpeldsp.o
+diff --git a/libavcodec/arm/Makefile b/libavcodec/arm/Makefile
+index a8446b2..b6410b2 100644
+--- a/libavcodec/arm/Makefile
++++ b/libavcodec/arm/Makefile
+@@ -47,7 +47,7 @@ ARMV6-OBJS-$(CONFIG_DSPUTIL)           += arm/dsputil_init_armv6.o      \
+                                           arm/simple_idct_armv6.o       \
+
+ ARMV6-OBJS-$(CONFIG_AC3DSP)            += arm/ac3dsp_armv6.o
+-ARMV6-OBJS-$(CONFIG_H264DSP)           += arm/h264dsp_armv6.o
++ARMV6-OBJS-$(CONFIG_H264DSP)           += arm/startcode_armv6.o
+ ARMV6-OBJS-$(CONFIG_HPELDSP)           += arm/hpeldsp_init_armv6.o      \
+                                           arm/hpeldsp_armv6.o
+ ARMV6-OBJS-$(CONFIG_MPEGAUDIODSP)      += arm/mpegaudiodsp_fixed_armv6.o
+diff --git a/libavcodec/arm/h264dsp_armv6.S b/libavcodec/arm/h264dsp_armv6.S
+deleted file mode 100644
+index 2758262..0000000
+--- a/libavcodec/arm/h264dsp_armv6.S
++++ /dev/null
+@@ -1,253 +0,0 @@
+-/*
+- * Copyright (c) 2013 RISC OS Open Ltd
+- * Author: Ben Avison <bavison@riscosopen.org>
+- *
+- * This file is part of FFmpeg.
+- *
+- * FFmpeg is free software; you can redistribute it and/or
+- * modify it under the terms of the GNU Lesser General Public
+- * License as published by the Free Software Foundation; either
+- * version 2.1 of the License, or (at your option) any later version.
+- *
+- * FFmpeg is distributed in the hope that it will be useful,
+- * but WITHOUT ANY WARRANTY; without even the implied warranty of
+- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+- * Lesser General Public License for more details.
+- *
+- * You should have received a copy of the GNU Lesser General Public
+- * License along with FFmpeg; if not, write to the Free Software
+- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+- */
+-
+-#include "libavutil/arm/asm.S"
+-
+-RESULT  .req    a1
+-BUF     .req    a1
+-SIZE    .req    a2
+-PATTERN .req    a3
+-PTR     .req    a4
+-DAT0    .req    v1
+-DAT1    .req    v2
+-DAT2    .req    v3
+-DAT3    .req    v4
+-TMP0    .req    v5
+-TMP1    .req    v6
+-TMP2    .req    ip
+-TMP3    .req    lr
+-
+-#define PRELOAD_DISTANCE 4
+-
+-.macro innerloop4
+-        ldr     DAT0, [PTR], #4
+-        subs    SIZE, SIZE, #4 @ C flag survives rest of macro
+-        sub     TMP0, DAT0, PATTERN, lsr #14
+-        bic     TMP0, TMP0, DAT0
+-        ands    TMP0, TMP0, PATTERN
+-.endm
+-
+-.macro innerloop16  decrement, do_preload
+-        ldmia   PTR!, {DAT0,DAT1,DAT2,DAT3}
+- .ifnc "\do_preload",""
+-        pld     [PTR, #PRELOAD_DISTANCE*32]
+- .endif
+- .ifnc "\decrement",""
+-        subs    SIZE, SIZE, #\decrement @ C flag survives rest of macro
+- .endif
+-        sub     TMP0, DAT0, PATTERN, lsr #14
+-        sub     TMP1, DAT1, PATTERN, lsr #14
+-        bic     TMP0, TMP0, DAT0
+-        bic     TMP1, TMP1, DAT1
+-        sub     TMP2, DAT2, PATTERN, lsr #14
+-        sub     TMP3, DAT3, PATTERN, lsr #14
+-        ands    TMP0, TMP0, PATTERN
+-        bic     TMP2, TMP2, DAT2
+-        it      eq
+-        andseq  TMP1, TMP1, PATTERN
+-        bic     TMP3, TMP3, DAT3
+-        itt     eq
+-        andseq  TMP2, TMP2, PATTERN
+-        andseq  TMP3, TMP3, PATTERN
+-.endm
+-
+-/* int ff_h264_find_start_code_candidate_armv6(const uint8_t *buf, int size) */
+-function ff_h264_find_start_code_candidate_armv6, export=1
+-        push    {v1-v6,lr}
+-        mov     PTR, BUF
+-        @ Ensure there are at least (PRELOAD_DISTANCE+2) complete cachelines to go
+-        @ before using code that does preloads
+-        cmp     SIZE, #(PRELOAD_DISTANCE+3)*32 - 1
+-        blo     60f
+-
+-        @ Get to word-alignment, 1 byte at a time
+-        tst     PTR, #3
+-        beq     2f
+-1:      ldrb    DAT0, [PTR], #1
+-        sub     SIZE, SIZE, #1
+-        teq     DAT0, #0
+-        beq     90f
+-        tst     PTR, #3
+-        bne     1b
+-2:      @ Get to 4-word alignment, 1 word at a time
+-        ldr     PATTERN, =0x80008000
+-        setend  be
+-        tst     PTR, #12
+-        beq     4f
+-3:      innerloop4
+-        bne     91f
+-        tst     PTR, #12
+-        bne     3b
+-4:      @ Get to cacheline (8-word) alignment
+-        tst     PTR, #16
+-        beq     5f
+-        innerloop16  16
+-        bne     93f
+-5:      @ Check complete cachelines, with preloading
+-        @ We need to stop when there are still (PRELOAD_DISTANCE+1)
+-        @ complete cachelines to go
+-        sub     SIZE, SIZE, #(PRELOAD_DISTANCE+2)*32
+-6:      innerloop16  , do_preload
+-        bne     93f
+-        innerloop16  32
+-        bne     93f
+-        bcs     6b
+-        @ Preload trailing part-cacheline, if any
+-        tst     SIZE, #31
+-        beq     7f
+-        pld     [PTR, #(PRELOAD_DISTANCE+1)*32]
+-        @ Check remaining data without doing any more preloads. First
+-        @ do in chunks of 4 words:
+-7:      adds    SIZE, SIZE, #(PRELOAD_DISTANCE+2)*32 - 16
+-        bmi     9f
+-8:      innerloop16  16
+-        bne     93f
+-        bcs     8b
+-        @ Then in words:
+-9:      adds    SIZE, SIZE, #16 - 4
+-        bmi     11f
+-10:     innerloop4
+-        bne     91f
+-        bcs     10b
+-11:     setend  le
+-        @ Check second byte of final halfword
+-        ldrb    DAT0, [PTR, #-1]
+-        teq     DAT0, #0
+-        beq     90f
+-        @ Check any remaining bytes
+-        tst     SIZE, #3
+-        beq     13f
+-12:     ldrb    DAT0, [PTR], #1
+-        sub     SIZE, SIZE, #1
+-        teq     DAT0, #0
+-        beq     90f
+-        tst     SIZE, #3
+-        bne     12b
+-        @ No candidate found
+-13:     sub     RESULT, PTR, BUF
+-        b       99f
+-
+-60:     @ Small buffer - simply check by looping over bytes
+-        subs    SIZE, SIZE, #1
+-        bcc     99f
+-61:     ldrb    DAT0, [PTR], #1
+-        subs    SIZE, SIZE, #1
+-        teq     DAT0, #0
+-        beq     90f
+-        bcs     61b
+-        @ No candidate found
+-        sub     RESULT, PTR, BUF
+-        b       99f
+-
+-90:     @ Found a candidate at the preceding byte
+-        sub     RESULT, PTR, BUF
+-        sub     RESULT, RESULT, #1
+-        b       99f
+-
+-91:     @ Found a candidate somewhere in the preceding 4 bytes
+-        sub     RESULT, PTR, BUF
+-        sub     RESULT, RESULT, #4
+-        sub     TMP0, DAT0, #0x20000
+-        bics    TMP0, TMP0, DAT0
+-        itt     pl
+-        ldrbpl  DAT0, [PTR, #-3]
+-        addpl   RESULT, RESULT, #2
+-        bpl     92f
+-        teq     RESULT, #0
+-        beq     98f @ don't look back a byte if found at first byte in buffer
+-        ldrb    DAT0, [PTR, #-5]
+-92:     teq     DAT0, #0
+-        it      eq
+-        subeq   RESULT, RESULT, #1
+-        b       98f
+-
+-93:     @ Found a candidate somewhere in the preceding 16 bytes
+-        sub     RESULT, PTR, BUF
+-        sub     RESULT, RESULT, #16
+-        teq     TMP0, #0
+-        beq     95f @ not in first 4 bytes
+-        sub     TMP0, DAT0, #0x20000
+-        bics    TMP0, TMP0, DAT0
+-        itt     pl
+-        ldrbpl  DAT0, [PTR, #-15]
+-        addpl   RESULT, RESULT, #2
+-        bpl     94f
+-        teq     RESULT, #0
+-        beq     98f @ don't look back a byte if found at first byte in buffer
+-        ldrb    DAT0, [PTR, #-17]
+-94:     teq     DAT0, #0
+-        it      eq
+-        subeq   RESULT, RESULT, #1
+-        b       98f
+-95:     add     RESULT, RESULT, #4
+-        teq     TMP1, #0
+-        beq     96f @ not in next 4 bytes
+-        sub     TMP1, DAT1, #0x20000
+-        bics    TMP1, TMP1, DAT1
+-        itee    mi
+-        ldrbmi  DAT0, [PTR, #-13]
+-        ldrbpl  DAT0, [PTR, #-11]
+-        addpl   RESULT, RESULT, #2
+-        teq     DAT0, #0
+-        it      eq
+-        subeq   RESULT, RESULT, #1
+-        b       98f
+-96:     add     RESULT, RESULT, #4
+-        teq     TMP2, #0
+-        beq     97f @ not in next 4 bytes
+-        sub     TMP2, DAT2, #0x20000
+-        bics    TMP2, TMP2, DAT2
+-        itee    mi
+-        ldrbmi  DAT0, [PTR, #-9]
+-        ldrbpl  DAT0, [PTR, #-7]
+-        addpl   RESULT, RESULT, #2
+-        teq     DAT0, #0
+-        it      eq
+-        subeq   RESULT, RESULT, #1
+-        b       98f
+-97:     add     RESULT, RESULT, #4
+-        sub     TMP3, DAT3, #0x20000
+-        bics    TMP3, TMP3, DAT3
+-        itee    mi
+-        ldrbmi  DAT0, [PTR, #-5]
+-        ldrbpl  DAT0, [PTR, #-3]
+-        addpl   RESULT, RESULT, #2
+-        teq     DAT0, #0
+-        it      eq
+-        subeq   RESULT, RESULT, #1
+-        @ drop through to 98f
+-98:     setend  le
+-99:     pop     {v1-v6,pc}
+-endfunc
+-
+-        .unreq  RESULT
+-        .unreq  BUF
+-        .unreq  SIZE
+-        .unreq  PATTERN
+-        .unreq  PTR
+-        .unreq  DAT0
+-        .unreq  DAT1
+-        .unreq  DAT2
+-        .unreq  DAT3
+-        .unreq  TMP0
+-        .unreq  TMP1
+-        .unreq  TMP2
+-        .unreq  TMP3
+diff --git a/libavcodec/arm/h264dsp_init_arm.c b/libavcodec/arm/h264dsp_init_arm.c
+index a0418fd..eb6c514 100644
+--- a/libavcodec/arm/h264dsp_init_arm.c
++++ b/libavcodec/arm/h264dsp_init_arm.c
+@@ -24,7 +24,7 @@
+ #include "libavutil/arm/cpu.h"
+ #include "libavcodec/h264dsp.h"
+
+-int ff_h264_find_start_code_candidate_armv6(const uint8_t *buf, int size);
++int ff_startcode_find_candidate_armv6(const uint8_t *buf, int size);
+
+ void ff_h264_v_loop_filter_luma_neon(uint8_t *pix, int stride, int alpha,
+                                      int beta, int8_t *tc0);
+@@ -109,7 +109,7 @@ av_cold void ff_h264dsp_init_arm(H264DSPContext *c, const int bit_depth,
+     int cpu_flags = av_get_cpu_flags();
+
+     if (have_armv6(cpu_flags))
+-        c->h264_find_start_code_candidate = ff_h264_find_start_code_candidate_armv6;
++        c->h264_find_start_code_candidate = ff_startcode_find_candidate_armv6;
+     if (have_neon(cpu_flags))
+         h264dsp_init_neon(c, bit_depth, chroma_format_idc);
+ }
+diff --git a/libavcodec/arm/startcode_armv6.S b/libavcodec/arm/startcode_armv6.S
+new file mode 100644
+index 0000000..a46f009
+--- /dev/null
++++ b/libavcodec/arm/startcode_armv6.S
+@@ -0,0 +1,253 @@
++/*
++ * Copyright (c) 2013 RISC OS Open Ltd
++ * Author: Ben Avison <bavison@riscosopen.org>
++ *
++ * This file is part of FFmpeg.
++ *
++ * FFmpeg is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU Lesser General Public
++ * License as published by the Free Software Foundation; either
++ * version 2.1 of the License, or (at your option) any later version.
++ *
++ * FFmpeg is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++ * Lesser General Public License for more details.
++ *
++ * You should have received a copy of the GNU Lesser General Public
++ * License along with FFmpeg; if not, write to the Free Software
++ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
++ */
++
++#include "libavutil/arm/asm.S"
++
++RESULT  .req    a1
++BUF     .req    a1
++SIZE    .req    a2
++PATTERN .req    a3
++PTR     .req    a4
++DAT0    .req    v1
++DAT1    .req    v2
++DAT2    .req    v3
++DAT3    .req    v4
++TMP0    .req    v5
++TMP1    .req    v6
++TMP2    .req    ip
++TMP3    .req    lr
++
++#define PRELOAD_DISTANCE 4
++
++.macro innerloop4
++        ldr     DAT0, [PTR], #4
++        subs    SIZE, SIZE, #4 @ C flag survives rest of macro
++        sub     TMP0, DAT0, PATTERN, lsr #14
++        bic     TMP0, TMP0, DAT0
++        ands    TMP0, TMP0, PATTERN
++.endm
++
++.macro innerloop16  decrement, do_preload
++        ldmia   PTR!, {DAT0,DAT1,DAT2,DAT3}
++ .ifnc "\do_preload",""
++        pld     [PTR, #PRELOAD_DISTANCE*32]
++ .endif
++ .ifnc "\decrement",""
++        subs    SIZE, SIZE, #\decrement @ C flag survives rest of macro
++ .endif
++        sub     TMP0, DAT0, PATTERN, lsr #14
++        sub     TMP1, DAT1, PATTERN, lsr #14
++        bic     TMP0, TMP0, DAT0
++        bic     TMP1, TMP1, DAT1
++        sub     TMP2, DAT2, PATTERN, lsr #14
++        sub     TMP3, DAT3, PATTERN, lsr #14
++        ands    TMP0, TMP0, PATTERN
++        bic     TMP2, TMP2, DAT2
++        it      eq
++        andseq  TMP1, TMP1, PATTERN
++        bic     TMP3, TMP3, DAT3
++        itt     eq
++        andseq  TMP2, TMP2, PATTERN
++        andseq  TMP3, TMP3, PATTERN
++.endm
++
++/* int ff_startcode_find_candidate_armv6(const uint8_t *buf, int size) */
++function ff_startcode_find_candidate_armv6, export=1
++        push    {v1-v6,lr}
++        mov     PTR, BUF
++        @ Ensure there are at least (PRELOAD_DISTANCE+2) complete cachelines to go
++        @ before using code that does preloads
++        cmp     SIZE, #(PRELOAD_DISTANCE+3)*32 - 1
++        blo     60f
++
++        @ Get to word-alignment, 1 byte at a time
++        tst     PTR, #3
++        beq     2f
++1:      ldrb    DAT0, [PTR], #1
++        sub     SIZE, SIZE, #1
++        teq     DAT0, #0
++        beq     90f
++        tst     PTR, #3
++        bne     1b
++2:      @ Get to 4-word alignment, 1 word at a time
++        ldr     PATTERN, =0x80008000
++        setend  be
++        tst     PTR, #12
++        beq     4f
++3:      innerloop4
++        bne     91f
++        tst     PTR, #12
++        bne     3b
++4:      @ Get to cacheline (8-word) alignment
++        tst     PTR, #16
++        beq     5f
++        innerloop16  16
++        bne     93f
++5:      @ Check complete cachelines, with preloading
++        @ We need to stop when there are still (PRELOAD_DISTANCE+1)
++        @ complete cachelines to go
++        sub     SIZE, SIZE, #(PRELOAD_DISTANCE+2)*32
++6:      innerloop16  , do_preload
++        bne     93f
++        innerloop16  32
++        bne     93f
++        bcs     6b
++        @ Preload trailing part-cacheline, if any
++        tst     SIZE, #31
++        beq     7f
++        pld     [PTR, #(PRELOAD_DISTANCE+1)*32]
++        @ Check remaining data without doing any more preloads. First
++        @ do in chunks of 4 words:
++7:      adds    SIZE, SIZE, #(PRELOAD_DISTANCE+2)*32 - 16
++        bmi     9f
++8:      innerloop16  16
++        bne     93f
++        bcs     8b
++        @ Then in words:
++9:      adds    SIZE, SIZE, #16 - 4
++        bmi     11f
++10:     innerloop4
++        bne     91f
++        bcs     10b
++11:     setend  le
++        @ Check second byte of final halfword
++        ldrb    DAT0, [PTR, #-1]
++        teq     DAT0, #0
++        beq     90f
++        @ Check any remaining bytes
++        tst     SIZE, #3
++        beq     13f
++12:     ldrb    DAT0, [PTR], #1
++        sub     SIZE, SIZE, #1
++        teq     DAT0, #0
++        beq     90f
++        tst     SIZE, #3
++        bne     12b
++        @ No candidate found
++13:     sub     RESULT, PTR, BUF
++        b       99f
++
++60:     @ Small buffer - simply check by looping over bytes
++        subs    SIZE, SIZE, #1
++        bcc     99f
++61:     ldrb    DAT0, [PTR], #1
++        subs    SIZE, SIZE, #1
++        teq     DAT0, #0
++        beq     90f
++        bcs     61b
++        @ No candidate found
++        sub     RESULT, PTR, BUF
++        b       99f
++
++90:     @ Found a candidate at the preceding byte
++        sub     RESULT, PTR, BUF
++        sub     RESULT, RESULT, #1
++        b       99f
++
++91:     @ Found a candidate somewhere in the preceding 4 bytes
++        sub     RESULT, PTR, BUF
++        sub     RESULT, RESULT, #4
++        sub     TMP0, DAT0, #0x20000
++        bics    TMP0, TMP0, DAT0
++        itt     pl
++        ldrbpl  DAT0, [PTR, #-3]
++        addpl   RESULT, RESULT, #2
++        bpl     92f
++        teq     RESULT, #0
++        beq     98f @ don't look back a byte if found at first byte in buffer
++        ldrb    DAT0, [PTR, #-5]
++92:     teq     DAT0, #0
++        it      eq
++        subeq   RESULT, RESULT, #1
++        b       98f
++
++93:     @ Found a candidate somewhere in the preceding 16 bytes
++        sub     RESULT, PTR, BUF
++        sub     RESULT, RESULT, #16
++        teq     TMP0, #0
++        beq     95f @ not in first 4 bytes
++        sub     TMP0, DAT0, #0x20000
++        bics    TMP0, TMP0, DAT0
++        itt     pl
++        ldrbpl  DAT0, [PTR, #-15]
++        addpl   RESULT, RESULT, #2
++        bpl     94f
++        teq     RESULT, #0
++        beq     98f @ don't look back a byte if found at first byte in buffer
++        ldrb    DAT0, [PTR, #-17]
++94:     teq     DAT0, #0
++        it      eq
++        subeq   RESULT, RESULT, #1
++        b       98f
++95:     add     RESULT, RESULT, #4
++        teq     TMP1, #0
++        beq     96f @ not in next 4 bytes
++        sub     TMP1, DAT1, #0x20000
++        bics    TMP1, TMP1, DAT1
++        itee    mi
++        ldrbmi  DAT0, [PTR, #-13]
++        ldrbpl  DAT0, [PTR, #-11]
++        addpl   RESULT, RESULT, #2
++        teq     DAT0, #0
++        it      eq
++        subeq   RESULT, RESULT, #1
++        b       98f
++96:     add     RESULT, RESULT, #4
++        teq     TMP2, #0
++        beq     97f @ not in next 4 bytes
++        sub     TMP2, DAT2, #0x20000
++        bics    TMP2, TMP2, DAT2
++        itee    mi
++        ldrbmi  DAT0, [PTR, #-9]
++        ldrbpl  DAT0, [PTR, #-7]
++        addpl   RESULT, RESULT, #2
++        teq     DAT0, #0
++        it      eq
++        subeq   RESULT, RESULT, #1
++        b       98f
++97:     add     RESULT, RESULT, #4
++        sub     TMP3, DAT3, #0x20000
++        bics    TMP3, TMP3, DAT3
++        itee    mi
++        ldrbmi  DAT0, [PTR, #-5]
++        ldrbpl  DAT0, [PTR, #-3]
++        addpl   RESULT, RESULT, #2
++        teq     DAT0, #0
++        it      eq
++        subeq   RESULT, RESULT, #1
++        @ drop through to 98f
++98:     setend  le
++99:     pop     {v1-v6,pc}
++endfunc
++
++        .unreq  RESULT
++        .unreq  BUF
++        .unreq  SIZE
++        .unreq  PATTERN
++        .unreq  PTR
++        .unreq  DAT0
++        .unreq  DAT1
++        .unreq  DAT2
++        .unreq  DAT3
++        .unreq  TMP0
++        .unreq  TMP1
++        .unreq  TMP2
++        .unreq  TMP3
+diff --git a/libavcodec/h264dsp.c b/libavcodec/h264dsp.c
+index a2a4aba..a4da776 100644
+--- a/libavcodec/h264dsp.c
++++ b/libavcodec/h264dsp.c
+@@ -33,6 +33,7 @@
+ #include "avcodec.h"
+ #include "h264dsp.h"
+ #include "h264idct.h"
++#include "startcode.h"
+ #include "libavutil/common.h"
+
+ #define BIT_DEPTH 8
+@@ -63,34 +64,6 @@
+ #include "h264addpx_template.c"
+ #undef BIT_DEPTH
+
+-static int h264_find_start_code_candidate_c(const uint8_t *buf, int size)
+-{
+-    int i = 0;
+-#if HAVE_FAST_UNALIGNED
+-    /* we check i < size instead of i + 3 / 7 because it is
+-     * simpler and there must be FF_INPUT_BUFFER_PADDING_SIZE
+-     * bytes at the end.
+-     */
+-#       if HAVE_FAST_64BIT
+-    while (i < size &&
+-            !((~*(const uint64_t *)(buf + i) &
+-                    (*(const uint64_t *)(buf + i) - 0x0101010101010101ULL)) &
+-                    0x8080808080808080ULL))
+-        i += 8;
+-#       else
+-    while (i < size &&
+-            !((~*(const uint32_t *)(buf + i) &
+-                    (*(const uint32_t *)(buf + i) - 0x01010101U)) &
+-                    0x80808080U))
+-        i += 4;
+-#       endif
+-#endif
+-    for (; i < size; i++)
+-        if (!buf[i])
+-            break;
+-    return i;
+-}
+-
+ av_cold void ff_h264dsp_init(H264DSPContext *c, const int bit_depth,
+                              const int chroma_format_idc)
+ {
+@@ -178,7 +151,7 @@ av_cold void ff_h264dsp_init(H264DSPContext *c, const int bit_depth,
+         H264_DSP(8);
+         break;
+     }
+-    c->h264_find_start_code_candidate = h264_find_start_code_candidate_c;
++    c->h264_find_start_code_candidate = ff_startcode_find_candidate_c;
+
+     if (ARCH_AARCH64) ff_h264dsp_init_aarch64(c, bit_depth, chroma_format_idc);
+     if (ARCH_ARM) ff_h264dsp_init_arm(c, bit_depth, chroma_format_idc);
+diff --git a/libavcodec/startcode.c b/libavcodec/startcode.c
+new file mode 100644
+index 0000000..5df7695
+--- /dev/null
++++ b/libavcodec/startcode.c
+@@ -0,0 +1,57 @@
++/*
++ * Copyright (c) 2003-2010 Michael Niedermayer <michaelni@gmx.at>
++ *
++ * This file is part of FFmpeg.
++ *
++ * FFmpeg is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU Lesser General Public
++ * License as published by the Free Software Foundation; either
++ * version 2.1 of the License, or (at your option) any later version.
++ *
++ * FFmpeg is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++ * Lesser General Public License for more details.
++ *
++ * You should have received a copy of the GNU Lesser General Public
++ * License along with FFmpeg; if not, write to the Free Software
++ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
++ */
++
++/**
++ * @file
++ * Accelerated start code search function for start codes common to
++ * MPEG-1/2/4 video, VC-1, H.264/5
++ * @author Michael Niedermayer <michaelni@gmx.at>
++ */
++
++#include "startcode.h"
++#include "config.h"
++
++int ff_startcode_find_candidate_c(const uint8_t *buf, int size)
++{
++    int i = 0;
++#if HAVE_FAST_UNALIGNED
++    /* we check i < size instead of i + 3 / 7 because it is
++     * simpler and there must be FF_INPUT_BUFFER_PADDING_SIZE
++     * bytes at the end.
++     */
++#       if HAVE_FAST_64BIT
++    while (i < size &&
++            !((~*(const uint64_t *)(buf + i) &
++                    (*(const uint64_t *)(buf + i) - 0x0101010101010101ULL)) &
++                    0x8080808080808080ULL))
++        i += 8;
++#       else
++    while (i < size &&
++            !((~*(const uint32_t *)(buf + i) &
++                    (*(const uint32_t *)(buf + i) - 0x01010101U)) &
++                    0x80808080U))
++        i += 4;
++#       endif
++#endif
++    for (; i < size; i++)
++        if (!buf[i])
++            break;
++    return i;
++}
+diff --git a/libavcodec/startcode.h b/libavcodec/startcode.h
+new file mode 100644
+index 0000000..cc55d5f
+--- /dev/null
++++ b/libavcodec/startcode.h
+@@ -0,0 +1,35 @@
++/*
++ * Copyright (c) 2003-2010 Michael Niedermayer <michaelni@gmx.at>
++ *
++ * This file is part of FFmpeg.
++ *
++ * FFmpeg is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU Lesser General Public
++ * License as published by the Free Software Foundation; either
++ * version 2.1 of the License, or (at your option) any later version.
++ *
++ * FFmpeg is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++ * Lesser General Public License for more details.
++ *
++ * You should have received a copy of the GNU Lesser General Public
++ * License along with FFmpeg; if not, write to the Free Software
++ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
++ */
++
++/**
++ * @file
++ * Accelerated start code search function for start codes common to
++ * MPEG-1/2/4 video, VC-1, H.264/5
++ * @author Michael Niedermayer <michaelni@gmx.at>
++ */
++
++#ifndef AVCODEC_STARTCODE_H
++#define AVCODEC_STARTCODE_H
++
++#include <stdint.h>
++
++int ff_startcode_find_candidate_c(const uint8_t *buf, int size);
++
++#endif /* AVCODEC_STARTCODE_H */
+--
+1.9.1
diff --git a/tools/depends/target/ffmpeg/0002-vc-1-Add-platform-specific-start-code-search-routine.patch b/tools/depends/target/ffmpeg/0002-vc-1-Add-platform-specific-start-code-search-routine.patch
new file mode 100644
index 0000000..e84ace6
--- /dev/null
+++ b/tools/depends/target/ffmpeg/0002-vc-1-Add-platform-specific-start-code-search-routine.patch
@@ -0,0 +1,143 @@
+From a60747132a1a6652ac0d18f3f110a20ea637ac30 Mon Sep 17 00:00:00 2001
+From: Ben Avison <bavison@riscosopen.org>
+Date: Wed, 16 Apr 2014 01:51:32 +0100
+Subject: [PATCH 2/3] vc-1: Add platform-specific start code search routine to
+ VC1DSPContext.
+
+Initialise VC1DSPContext for parser as well as for decoder.
+Note, the VC-1 code doesn't actually use the function pointer yet.
+
+Signed-off-by: Michael Niedermayer <michaelni@gmx.at>
+---
+ libavcodec/Makefile              | 6 +++---
+ libavcodec/arm/Makefile          | 2 ++
+ libavcodec/arm/vc1dsp_init_arm.c | 4 ++++
+ libavcodec/vc1.c                 | 2 ++
+ libavcodec/vc1dec.c              | 1 -
+ libavcodec/vc1dsp.c              | 3 +++
+ libavcodec/vc1dsp.h              | 8 ++++++++
+ 7 files changed, 22 insertions(+), 4 deletions(-)
+
+diff --git a/libavcodec/Makefile b/libavcodec/Makefile
+index 19caf11..120f85a 100644
+--- a/libavcodec/Makefile
++++ b/libavcodec/Makefile
+@@ -458,7 +458,7 @@ OBJS-$(CONFIG_VB_DECODER)              += vb.o
+ OBJS-$(CONFIG_VBLE_DECODER)            += vble.o
+ OBJS-$(CONFIG_VC1_DECODER)             += vc1dec.o vc1.o vc1data.o vc1dsp.o \
+                                           msmpeg4dec.o msmpeg4.o msmpeg4data.o \
+-                                          wmv2dsp.o
++                                          wmv2dsp.o startcode.o
+ OBJS-$(CONFIG_VCR1_DECODER)            += vcr1.o
+ OBJS-$(CONFIG_VMDAUDIO_DECODER)        += vmdav.o
+ OBJS-$(CONFIG_VMDVIDEO_DECODER)        += vmdav.o
+@@ -783,9 +783,9 @@ OBJS-$(CONFIG_PNM_PARSER)              += pnm_parser.o pnm.o
+ OBJS-$(CONFIG_RV30_PARSER)             += rv34_parser.o
+ OBJS-$(CONFIG_RV40_PARSER)             += rv34_parser.o
+ OBJS-$(CONFIG_TAK_PARSER)              += tak_parser.o tak.o
+-OBJS-$(CONFIG_VC1_PARSER)              += vc1_parser.o vc1.o vc1data.o \
++OBJS-$(CONFIG_VC1_PARSER)              += vc1_parser.o vc1.o vc1data.o vc1dsp.o \
+                                           msmpeg4.o msmpeg4data.o mpeg4video.o \
+-                                          h263.o
++                                          h263.o startcode.o
+ OBJS-$(CONFIG_VORBIS_PARSER)           += vorbis_parser.o xiph.o
+ OBJS-$(CONFIG_VP3_PARSER)              += vp3_parser.o
+ OBJS-$(CONFIG_VP8_PARSER)              += vp8_parser.o
+diff --git a/libavcodec/arm/Makefile b/libavcodec/arm/Makefile
+index b6410b2..fa2b18e 100644
+--- a/libavcodec/arm/Makefile
++++ b/libavcodec/arm/Makefile
+@@ -51,6 +51,8 @@ ARMV6-OBJS-$(CONFIG_H264DSP)           += arm/startcode_armv6.o
+ ARMV6-OBJS-$(CONFIG_HPELDSP)           += arm/hpeldsp_init_armv6.o      \
+                                           arm/hpeldsp_armv6.o
+ ARMV6-OBJS-$(CONFIG_MPEGAUDIODSP)      += arm/mpegaudiodsp_fixed_armv6.o
++ARMV6-OBJS-$(CONFIG_VC1_DECODER)       += arm/startcode_armv6.o
++ARMV6-OBJS-$(CONFIG_VC1_PARSER)        += arm/startcode_armv6.o
+ ARMV6-OBJS-$(CONFIG_VP8_DECODER)       += arm/vp8_armv6.o               \
+                                           arm/vp8dsp_init_armv6.o       \
+                                           arm/vp8dsp_armv6.o
+diff --git a/libavcodec/arm/vc1dsp_init_arm.c b/libavcodec/arm/vc1dsp_init_arm.c
+index 47d4126..4a84848 100644
+--- a/libavcodec/arm/vc1dsp_init_arm.c
++++ b/libavcodec/arm/vc1dsp_init_arm.c
+@@ -23,10 +23,14 @@
+ #include "libavcodec/vc1dsp.h"
+ #include "vc1dsp.h"
+
++int ff_startcode_find_candidate_armv6(const uint8_t *buf, int size);
++
+ av_cold void ff_vc1dsp_init_arm(VC1DSPContext *dsp)
+ {
+     int cpu_flags = av_get_cpu_flags();
+
++    if (have_armv6(cpu_flags))
++        dsp->vc1_find_start_code_candidate = ff_startcode_find_candidate_armv6;
+     if (have_neon(cpu_flags))
+         ff_vc1dsp_init_neon(dsp);
+ }
+diff --git a/libavcodec/vc1.c b/libavcodec/vc1.c
+index 49d4885..cb941dd 100644
+--- a/libavcodec/vc1.c
++++ b/libavcodec/vc1.c
+@@ -1706,5 +1706,7 @@ av_cold int ff_vc1_init_common(VC1Context *v)
+     v->pq      = -1;
+     v->mvrange = 0; /* 7.1.1.18, p80 */
+
++    ff_vc1dsp_init(&v->vc1dsp);
++
+     return 0;
+ }
+diff --git a/libavcodec/vc1dec.c b/libavcodec/vc1dec.c
+index 30fee47..67cda42 100644
+--- a/libavcodec/vc1dec.c
++++ b/libavcodec/vc1dec.c
+@@ -5631,7 +5631,6 @@ static av_cold int vc1_decode_init(AVCodecContext *avctx)
+     ff_vc1_decode_end(avctx);
+
+     ff_h264chroma_init(&v->h264chroma, 8);
+-    ff_vc1dsp_init(&v->vc1dsp);
+
+     if (avctx->codec_id == AV_CODEC_ID_WMV3 || avctx->codec_id == AV_CODEC_ID_WMV3IMAGE) {
+         int count = 0;
+diff --git a/libavcodec/vc1dsp.c b/libavcodec/vc1dsp.c
+index ec9c17b..09a9006 100644
+--- a/libavcodec/vc1dsp.c
++++ b/libavcodec/vc1dsp.c
+@@ -30,6 +30,7 @@
+ #include "h264chroma.h"
+ #include "rnd_avg.h"
+ #include "vc1dsp.h"
++#include "startcode.h"
+
+ /* Apply overlap transform to horizontal edge */
+ static void vc1_v_overlap_c(uint8_t *src, int stride)
+@@ -947,6 +948,8 @@ av_cold void ff_vc1dsp_init(VC1DSPContext *dsp)
+     dsp->sprite_v_double_twoscale = sprite_v_double_twoscale_c;
+ #endif /* CONFIG_WMV3IMAGE_DECODER || CONFIG_VC1IMAGE_DECODER */
+
++    dsp->vc1_find_start_code_candidate = ff_startcode_find_candidate_c;
++
+     if (ARCH_AARCH64)
+         ff_vc1dsp_init_aarch64(dsp);
+     if (ARCH_ARM)
+diff --git a/libavcodec/vc1dsp.h b/libavcodec/vc1dsp.h
+index 990fbc3..6a90eed 100644
+--- a/libavcodec/vc1dsp.h
++++ b/libavcodec/vc1dsp.h
+@@ -74,6 +74,14 @@ typedef struct VC1DSPContext {
+     void (*sprite_v_double_twoscale)(uint8_t *dst, const uint8_t *src1a, const uint8_t *src1b, int offset1,
+                                                    const uint8_t *src2a, const uint8_t *src2b, int offset2,
+                                      int alpha, int width);
++
++    /**
++     * Search buf from the start for up to size bytes. Return the index
++     * of a zero byte, or >= size if not found. Ideally, use lookahead
++     * to filter out any zero bytes that are known to not be followed by
++     * one or more further zero bytes and a one byte.
++     */
++    int (*vc1_find_start_code_candidate)(const uint8_t *buf, int size);
+ } VC1DSPContext;
+
+ void ff_vc1dsp_init(VC1DSPContext* c);
+--
+1.9.1
diff --git a/tools/depends/target/ffmpeg/0003-vc-1-Optimise-parser-with-special-attention-to-ARM.patch b/tools/depends/target/ffmpeg/0003-vc-1-Optimise-parser-with-special-attention-to-ARM.patch
new file mode 100644
index 0000000..1f0cf40
--- /dev/null
+++ b/tools/depends/target/ffmpeg/0003-vc-1-Optimise-parser-with-special-attention-to-ARM.patch
@@ -0,0 +1,401 @@
+From c39df43eae03768427243668c040de8437c4f79c Mon Sep 17 00:00:00 2001
+From: Ben Avison <bavison@riscosopen.org>
+Date: Wed, 23 Apr 2014 01:41:04 +0100
+Subject: [PATCH 3/3] vc-1: Optimise parser (with special attention to ARM)
+
+The previous implementation of the parser made four passes over each input
+buffer (reduced to two if the container format already guaranteed the input
+buffer corresponded to frames, such as with MKV). But these buffers are
+often 200K in size, certainly enough to flush the data out of L1 cache, and
+for many CPUs, all the way out to main memory. The passes were:
+
+1) locate frame boundaries (not needed for MKV etc)
+2) copy the data into a contiguous block (not needed for MKV etc)
+3) locate the start codes within each frame
+4) unescape the data between start codes
+
+After this, the unescaped data was parsed to extract certain header fields,
+but because the unescape operation was so large, this was usually also
+effectively operating on uncached memory. Most of the unescaped data was
+simply thrown away and never processed further. Only step 2 - because it
+used memcpy - was using prefetch, making things even worse.
+
+This patch reorganises these steps so that, aside from the copying, the
+operations are performed in parallel, maximising cache utilisation. No more
+than the worst-case number of bytes needed for header parsing is unescaped.
+Most of the data is, in practice, only read in order to search for a start
+code, for which optimised implementations already existed in the H264 codec
+(notably the ARM version uses prefetch, so we end up doing both remaining
+passes at maximum speed). For MKV files, we know when we've found the last
+start code of interest in a given frame, so we are able to avoid doing even
+that one remaining pass for most of the buffer.
+
+In some use-cases (such as the Raspberry Pi) video decode is handled by the
+GPU, but the entire elementary stream is still fed through the parser to
+pick out certain elements of the header which are necessary to manage the
+decode process. As you might expect, in these cases, the performance of the
+parser is significant.
+
+To measure parser performance, I used the same VC-1 elementary stream in
+either an MPEG-2 transport stream or a MKV file, and fed it through ffmpeg
+with -c:v copy -c:a copy -f null. These are the gperftools counts for
+those streams, both filtered to only include vc1_parse() and its callees,
+and unfiltered (to include the whole binary). Lower numbers are better:
+
+                Before          After
+File  Filtered  Mean   StdDev   Mean   StdDev  Confidence  Change
+M2TS  No        861.7  8.2      650.5  8.1     100.0%      +32.5%
+MKV   No        868.9  7.4      731.7  9.0     100.0%      +18.8%
+M2TS  Yes       250.0  11.2     27.2   3.4     100.0%      +817.9%
+MKV   Yes       149.0  12.8     1.7    0.8     100.0%      +8526.3%
+
+Yes, that last case shows vc1_parse() running 86 times faster! The M2TS
+case does show a larger absolute improvement though, since it was worse
+to begin with.
+
+This patch has been tested with the FATE suite (albeit on x86 for speed).
+
+Signed-off-by: Michael Niedermayer <michaelni@gmx.at>
+---
+ libavcodec/vc1_parser.c | 284 ++++++++++++++++++++++++++++++------------------
+ 1 file changed, 180 insertions(+), 104 deletions(-)
+
+diff --git a/libavcodec/vc1_parser.c b/libavcodec/vc1_parser.c
+index cc29ce1..4ed14bc 100644
+--- a/libavcodec/vc1_parser.c
++++ b/libavcodec/vc1_parser.c
+@@ -30,122 +30,88 @@
+ #include "vc1.h"
+ #include "get_bits.h"
+
++/** The maximum number of bytes of a sequence, entry point or
++ *  frame header whose values we pay any attention to */
++#define UNESCAPED_THRESHOLD 37
++
++/** The maximum number of bytes of a sequence, entry point or
++ *  frame header which must be valid memory (because they are
++ *  used to update the bitstream cache in skip_bits() calls)
++ */
++#define UNESCAPED_LIMIT 144
++
++typedef enum {
++    NO_MATCH,
++    ONE_ZERO,
++    TWO_ZEROS,
++    ONE
++} VC1ParseSearchState;
++
+ typedef struct {
+     ParseContext pc;
+     VC1Context v;
++    uint8_t prev_start_code;
++    size_t bytes_to_skip;
++    uint8_t unesc_buffer[UNESCAPED_LIMIT];
++    size_t unesc_index;
++    VC1ParseSearchState search_state;
+ } VC1ParseContext;
+
+-static void vc1_extract_headers(AVCodecParserContext *s, AVCodecContext *avctx,
+-                                const uint8_t *buf, int buf_size)
++static void vc1_extract_header(AVCodecParserContext *s, AVCodecContext *avctx,
++                               const uint8_t *buf, int buf_size)
+ {
++    /* Parse the header we just finished unescaping */
+     VC1ParseContext *vpc = s->priv_data;
+     GetBitContext gb;
+-    const uint8_t *start, *end, *next;
+-    uint8_t *buf2 = av_mallocz(buf_size + FF_INPUT_BUFFER_PADDING_SIZE);
+-
++    int ret;
+     vpc->v.s.avctx = avctx;
+     vpc->v.parse_only = 1;
+-    vpc->v.first_pic_header_flag = 1;
+-    next = buf;
+-    s->repeat_pict = 0;
+-
+-    for(start = buf, end = buf + buf_size; next < end; start = next){
+-        int buf2_size, size;
+-        int ret;
+-
+-        next = find_next_marker(start + 4, end);
+-        size = next - start - 4;
+-        buf2_size = vc1_unescape_buffer(start + 4, size, buf2);
+-        init_get_bits(&gb, buf2, buf2_size * 8);
+-        if(size <= 0) continue;
+-        switch(AV_RB32(start)){
+-        case VC1_CODE_SEQHDR:
+-            ff_vc1_decode_sequence_header(avctx, &vpc->v, &gb);
+-            break;
+-        case VC1_CODE_ENTRYPOINT:
+-            ff_vc1_decode_entry_point(avctx, &vpc->v, &gb);
+-            break;
+-        case VC1_CODE_FRAME:
+-            if(vpc->v.profile < PROFILE_ADVANCED)
+-                ret = ff_vc1_parse_frame_header    (&vpc->v, &gb);
+-            else
+-                ret = ff_vc1_parse_frame_header_adv(&vpc->v, &gb);
+-
+-            if (ret < 0)
+-                break;
+-
+-            /* keep AV_PICTURE_TYPE_BI internal to VC1 */
+-            if (vpc->v.s.pict_type == AV_PICTURE_TYPE_BI)
+-                s->pict_type = AV_PICTURE_TYPE_B;
+-            else
+-                s->pict_type = vpc->v.s.pict_type;
+-
+-            if (avctx->ticks_per_frame > 1){
+-                // process pulldown flags
+-                s->repeat_pict = 1;
+-                // Pulldown flags are only valid when 'broadcast' has been set.
+-                // So ticks_per_frame will be 2
+-                if (vpc->v.rff){
+-                    // repeat field
+-                    s->repeat_pict = 2;
+-                }else if (vpc->v.rptfrm){
+-                    // repeat frames
+-                    s->repeat_pict = vpc->v.rptfrm * 2 + 1;
+-                }
+-            }
+-
+-            if (vpc->v.broadcast && vpc->v.interlace && !vpc->v.psf)
+-                s->field_order = vpc->v.tff ? AV_FIELD_TT : AV_FIELD_BB;
+-            else
+-                s->field_order = AV_FIELD_PROGRESSIVE;
++    init_get_bits(&gb, buf, buf_size * 8);
++    switch (vpc->prev_start_code) {
++    case VC1_CODE_SEQHDR & 0xFF:
++        ff_vc1_decode_sequence_header(avctx, &vpc->v, &gb);
++        break;
++    case VC1_CODE_ENTRYPOINT & 0xFF:
++        ff_vc1_decode_entry_point(avctx, &vpc->v, &gb);
++        break;
++    case VC1_CODE_FRAME & 0xFF:
++        if(vpc->v.profile < PROFILE_ADVANCED)
++            ret = ff_vc1_parse_frame_header    (&vpc->v, &gb);
++        else
++            ret = ff_vc1_parse_frame_header_adv(&vpc->v, &gb);
+
++        if (ret < 0)
+             break;
+-        }
+-    }
+
+-    av_free(buf2);
+-}
++        /* keep AV_PICTURE_TYPE_BI internal to VC1 */
++        if (vpc->v.s.pict_type == AV_PICTURE_TYPE_BI)
++            s->pict_type = AV_PICTURE_TYPE_B;
++        else
++            s->pict_type = vpc->v.s.pict_type;
+
+-/**
+- * Find the end of the current frame in the bitstream.
+- * @return the position of the first byte of the next frame, or -1
+- */
+-static int vc1_find_frame_end(ParseContext *pc, const uint8_t *buf,
+-                               int buf_size) {
+-    int pic_found, i;
+-    uint32_t state;
+-
+-    pic_found= pc->frame_start_found;
+-    state= pc->state;
+-
+-    i=0;
+-    if(!pic_found){
+-        for(i=0; i<buf_size; i++){
+-            state= (state<<8) | buf[i];
+-            if(state == VC1_CODE_FRAME || state == VC1_CODE_FIELD){
+-                i++;
+-                pic_found=1;
+-                break;
++        if (avctx->ticks_per_frame > 1){
++            // process pulldown flags
++            s->repeat_pict = 1;
++            // Pulldown flags are only valid when 'broadcast' has been set.
++            // So ticks_per_frame will be 2
++            if (vpc->v.rff){
++                // repeat field
++                s->repeat_pict = 2;
++            }else if (vpc->v.rptfrm){
++                // repeat frames
++                s->repeat_pict = vpc->v.rptfrm * 2 + 1;
+             }
++        }else{
++            s->repeat_pict = 0;
+         }
+-    }
+
+-    if(pic_found){
+-        /* EOF considered as end of frame */
+-        if (buf_size == 0)
+-            return 0;
+-        for(; i<buf_size; i++){
+-            state= (state<<8) | buf[i];
+-            if(IS_MARKER(state) && state != VC1_CODE_FIELD && state != VC1_CODE_SLICE){
+-                pc->frame_start_found=0;
+-                pc->state=-1;
+-                return i-3;
+-            }
+-        }
++        if (vpc->v.broadcast && vpc->v.interlace && !vpc->v.psf)
++            s->field_order = vpc->v.tff ? AV_FIELD_TT : AV_FIELD_BB;
++        else
++            s->field_order = AV_FIELD_PROGRESSIVE;
++
++        break;
+     }
+-    pc->frame_start_found= pic_found;
+-    pc->state= state;
+-    return END_NOT_FOUND;
+ }
+
+ static int vc1_parse(AVCodecParserContext *s,
+@@ -153,22 +119,127 @@ static int vc1_parse(AVCodecParserContext *s,
+                            const uint8_t **poutbuf, int *poutbuf_size,
+                            const uint8_t *buf, int buf_size)
+ {
++    /* Here we do the searching for frame boundaries and headers at
++     * the same time. Only a minimal amount at the start of each
++     * header is unescaped. */
+     VC1ParseContext *vpc = s->priv_data;
+-    int next;
++    int pic_found = vpc->pc.frame_start_found;
++    uint8_t *unesc_buffer = vpc->unesc_buffer;
++    size_t unesc_index = vpc->unesc_index;
++    VC1ParseSearchState search_state = vpc->search_state;
++    int next = END_NOT_FOUND;
++    int i = vpc->bytes_to_skip;
++
++    if (pic_found && buf_size == 0) {
++        /* EOF considered as end of frame */
++        memset(unesc_buffer + unesc_index, 0, UNESCAPED_THRESHOLD - unesc_index);
++        vc1_extract_header(s, avctx, unesc_buffer, unesc_index);
++        next = 0;
++    }
++    while (i < buf_size) {
++        int start_code_found = 0;
++        uint8_t b;
++        while (i < buf_size && unesc_index < UNESCAPED_THRESHOLD) {
++            b = buf[i++];
++            unesc_buffer[unesc_index++] = b;
++            if (search_state <= ONE_ZERO)
++                search_state = b ? NO_MATCH : search_state + 1;
++            else if (search_state == TWO_ZEROS) {
++                if (b == 1)
++                    search_state = ONE;
++                else if (b > 1) {
++                    if (b == 3)
++                        unesc_index--; // swallow emulation prevention byte
++                    search_state = NO_MATCH;
++                }
++            }
++            else { // search_state == ONE
++                // Header unescaping terminates early due to detection of next start code
++                search_state = NO_MATCH;
++                start_code_found = 1;
++                break;
++            }
++        }
++        if ((s->flags & PARSER_FLAG_COMPLETE_FRAMES) &&
++                unesc_index >= UNESCAPED_THRESHOLD &&
++                vpc->prev_start_code == (VC1_CODE_FRAME & 0xFF))
++        {
++            // No need to keep scanning the rest of the buffer for
++            // start codes if we know it contains a complete frame and
++            // we've already unescaped all we need of the frame header
++            vc1_extract_header(s, avctx, unesc_buffer, unesc_index);
++            break;
++        }
++        if (unesc_index >= UNESCAPED_THRESHOLD && !start_code_found) {
++            while (i < buf_size) {
++                if (search_state == NO_MATCH) {
++                    i += vpc->v.vc1dsp.vc1_find_start_code_candidate(buf + i, buf_size - i);
++                    if (i < buf_size) {
++                        search_state = ONE_ZERO;
++                    }
++                    i++;
++                } else {
++                    b = buf[i++];
++                    if (search_state == ONE_ZERO)
++                        search_state = b ? NO_MATCH : TWO_ZEROS;
++                    else if (search_state == TWO_ZEROS) {
++                        if (b >= 1)
++                            search_state = b == 1 ? ONE : NO_MATCH;
++                    }
++                    else { // search_state == ONE
++                        search_state = NO_MATCH;
++                        start_code_found = 1;
++                        break;
++                    }
++                }
++            }
++        }
++        if (start_code_found) {
++            vc1_extract_header(s, avctx, unesc_buffer, unesc_index);
++
++            vpc->prev_start_code = b;
++            unesc_index = 0;
++
++            if (!(s->flags & PARSER_FLAG_COMPLETE_FRAMES)) {
++                if (!pic_found && (b == (VC1_CODE_FRAME & 0xFF) || b == (VC1_CODE_FIELD & 0xFF))) {
++                    pic_found = 1;
++                }
++                else if (pic_found && b != (VC1_CODE_FIELD & 0xFF) && b != (VC1_CODE_SLICE & 0xFF)) {
++                    next = i - 4;
++                    pic_found = b == (VC1_CODE_FRAME & 0xFF);
++                    break;
++                }
++            }
++        }
++    }
+
+-    if(s->flags & PARSER_FLAG_COMPLETE_FRAMES){
+-        next= buf_size;
+-    }else{
+-        next= vc1_find_frame_end(&vpc->pc, buf, buf_size);
++    vpc->pc.frame_start_found = pic_found;
++    vpc->unesc_index = unesc_index;
++    vpc->search_state = search_state;
+
++    if (s->flags & PARSER_FLAG_COMPLETE_FRAMES) {
++        next = buf_size;
++    } else {
+         if (ff_combine_frame(&vpc->pc, next, &buf, &buf_size) < 0) {
++            vpc->bytes_to_skip = 0;
+             *poutbuf = NULL;
+             *poutbuf_size = 0;
+             return buf_size;
+         }
+     }
+
+-    vc1_extract_headers(s, avctx, buf, buf_size);
++    vpc->v.first_pic_header_flag = 1;
++
++    /* If we return with a valid pointer to a combined frame buffer
++     * then on the next call then we'll have been unhelpfully rewound
++     * by up to 4 bytes (depending upon whether the start code
++     * overlapped the input buffer, and if so by how much). We don't
++     * want this: it will either cause spurious second detections of
++     * the start code we've already seen, or cause extra bytes to be
++     * inserted at the start of the unescaped buffer. */
++    vpc->bytes_to_skip = 4;
++    if (next < 0)
++        vpc->bytes_to_skip += next;
+
+     *poutbuf = buf;
+     *poutbuf_size = buf_size;
+@@ -199,6 +270,11 @@ static av_cold int vc1_parse_init(AVCodecParserContext *s)
+ {
+     VC1ParseContext *vpc = s->priv_data;
+     vpc->v.s.slice_context_count = 1;
++    vpc->v.first_pic_header_flag = 1;
++    vpc->prev_start_code = 0;
++    vpc->bytes_to_skip = 0;
++    vpc->unesc_index = 0;
++    vpc->search_state = NO_MATCH;
+     return ff_vc1_init_common(&vpc->v);
+ }
+
+--
+1.9.1
diff --git a/tools/depends/target/ffmpeg/Makefile b/tools/depends/target/ffmpeg/Makefile
index f514ae6..863ee41 100644
--- a/tools/depends/target/ffmpeg/Makefile
+++ b/tools/depends/target/ffmpeg/Makefile
@@ -1,6 +1,9 @@
 include ../../Makefile.include
 include FFMPEG-VERSION
-DEPS= ../../Makefile.include FFMPEG-VERSION Makefile ffmpeg_Speed_up_wtv_index_creation.patch
+DEPS= ../../Makefile.include FFMPEG-VERSION Makefile \
+      ffmpeg_Speed_up_wtv_index_creation.patch 0001-h264-Move-search-code-search-functions-into-separate.patch \
+      0002-vc-1-Add-platform-specific-start-code-search-routine.patch 0003-vc-1-Optimise-parser-with-special-attention-to-ARM.patch
+
 
 # set to "yes" to enable patching
 # we don't apply patches until we move to a vanilla ffmpeg tarball
@@ -64,6 +67,9 @@ $(PLATFORM): $(TARBALLS_LOCATION)/$(ARCHIVE) $(DEPS)
 	cd $(PLATFORM); $(ARCHIVE_TOOL) $(ARCHIVE_TOOL_FLAGS) $(TARBALLS_LOCATION)/$(ARCHIVE)
 	cd $(PLATFORM); sed -i".bak" -e "s%pkg_config_default=pkg-config%export PKG_CONFIG_LIBDIR=$(PREFIX)/lib/pkgconfig\npkg_config_default=$(NATIVEPREFIX)/bin/pkg-config%" configure
 	cd $(PLATFORM); patch -p3 < ../ffmpeg_Speed_up_wtv_index_creation.patch
+	cd $(PLATFORM); patch -p1 < ../0001-h264-Move-search-code-search-functions-into-separate.patch
+	cd $(PLATFORM); patch -p1 < ../0002-vc-1-Add-platform-specific-start-code-search-routine.patch
+	cd $(PLATFORM); patch -p1 < ../0003-vc-1-Optimise-parser-with-special-attention-to-ARM.patch
 	cd $(PLATFORM);\
 	CFLAGS="$(CFLAGS)" CXXFLAGS="$(CXXFLAGS)" CPPFLAGS="$(CPPFLAGS)" LDFLAGS="$(LDFLAGS)" \
 	./configure $(ffmpg_config)
-- 
1.9.3


From 7ed755d1a64b291f94f367e457755bd9f0640b2d Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Tue, 29 Apr 2014 16:53:32 +0100
Subject: [PATCH 062/102] [ffmpeg] truehd: Optimise with special attention to
 ARM

Backport from upstream ffmpeg
---
 .../0001-truehd-tune-VLC-decoding-for-ARM.patch    |  65 ++
 ...hand-scheduled-ARM-asm-version-of-mlp_fil.patch | 557 +++++++++++++++++
 ...k-out-part-of-rematrix_channels-into-plat.patch | 158 +++++
 ...hand-scheduled-ARM-asm-version-of-ff_mlp_.patch | 285 +++++++++
 ...k-out-part-of-output_data-into-platform-s.patch | 197 ++++++
 ...hand-scheduled-ARM-asm-version-of-ff_mlp_.patch | 689 +++++++++++++++++++++
 tools/depends/target/ffmpeg/Makefile               |  13 +-
 7 files changed, 1962 insertions(+), 2 deletions(-)
 create mode 100644 tools/depends/target/ffmpeg/0001-truehd-tune-VLC-decoding-for-ARM.patch
 create mode 100644 tools/depends/target/ffmpeg/0002-truehd-add-hand-scheduled-ARM-asm-version-of-mlp_fil.patch
 create mode 100644 tools/depends/target/ffmpeg/0003-truehd-break-out-part-of-rematrix_channels-into-plat.patch
 create mode 100644 tools/depends/target/ffmpeg/0004-truehd-add-hand-scheduled-ARM-asm-version-of-ff_mlp_.patch
 create mode 100644 tools/depends/target/ffmpeg/0005-truehd-break-out-part-of-output_data-into-platform-s.patch
 create mode 100644 tools/depends/target/ffmpeg/0006-truehd-add-hand-scheduled-ARM-asm-version-of-ff_mlp_.patch

diff --git a/tools/depends/target/ffmpeg/0001-truehd-tune-VLC-decoding-for-ARM.patch b/tools/depends/target/ffmpeg/0001-truehd-tune-VLC-decoding-for-ARM.patch
new file mode 100644
index 0000000..2950843
--- /dev/null
+++ b/tools/depends/target/ffmpeg/0001-truehd-tune-VLC-decoding-for-ARM.patch
@@ -0,0 +1,65 @@
+From 425d69b993d25489e4830766507d9d8f6c819802 Mon Sep 17 00:00:00 2001
+From: Ben Avison <bavison@riscosopen.org>
+Date: Wed, 19 Mar 2014 17:26:19 +0000
+Subject: [PATCH 1/6] truehd: tune VLC decoding for ARM.
+
+Profiling on a Raspberry Pi revealed the best performance to correspond
+with VLC_BITS = 5. Results for overall audio decode and the get_vlc2 function
+in particular are as follows:
+
+              Before          After
+              Mean   StdDev   Mean   StdDev  Confidence  Change
+6:2 total     348.8  20.1     339.6  15.1    88.8%       +2.7%  (insignificant)
+6:2 function  38.1   8.1      26.4   4.1     100.0%      +44.5%
+8:2 total     339.1  15.4     324.5  15.5    99.4%       +4.5%
+8:2 function  33.8   7.0      27.3   5.6     99.7%       +23.6%
+6:6 total     604.6  20.8     572.8  20.6    100.0%      +5.6%
+6:6 function  95.8   8.4      68.9   8.2     100.0%      +39.1%
+8:8 total     766.4  17.6     741.5  21.2    100.0%      +3.4%
+8:8 function  106.0  11.4     86.1   9.9     100.0%      +23.1%
+
+Signed-off-by: Michael Niedermayer <michaelni@gmx.at>
+---
+ libavcodec/mlpdec.c | 13 ++++++++++---
+ 1 file changed, 10 insertions(+), 3 deletions(-)
+
+diff --git a/libavcodec/mlpdec.c b/libavcodec/mlpdec.c
+index 93ed552..cbd9000 100644
+--- a/libavcodec/mlpdec.c
++++ b/libavcodec/mlpdec.c
+@@ -37,9 +37,16 @@
+ #include "mlp_parser.h"
+ #include "mlpdsp.h"
+ #include "mlp.h"
++#include "config.h"
+
+ /** number of bits used for VLC lookup - longest Huffman code is 9 */
++#if ARCH_ARM == 1
++#define VLC_BITS            5
++#define VLC_STATIC_SIZE     64
++#else
+ #define VLC_BITS            9
++#define VLC_STATIC_SIZE     512
++#endif
+
+ typedef struct SubStream {
+     /// Set if a valid restart header has been read. Otherwise the substream cannot be decoded.
+@@ -193,13 +200,13 @@ static av_cold void init_static(void)
+     if (!huff_vlc[0].bits) {
+         INIT_VLC_STATIC(&huff_vlc[0], VLC_BITS, 18,
+                     &ff_mlp_huffman_tables[0][0][1], 2, 1,
+-                    &ff_mlp_huffman_tables[0][0][0], 2, 1, 512);
++                    &ff_mlp_huffman_tables[0][0][0], 2, 1, VLC_STATIC_SIZE);
+         INIT_VLC_STATIC(&huff_vlc[1], VLC_BITS, 16,
+                     &ff_mlp_huffman_tables[1][0][1], 2, 1,
+-                    &ff_mlp_huffman_tables[1][0][0], 2, 1, 512);
++                    &ff_mlp_huffman_tables[1][0][0], 2, 1, VLC_STATIC_SIZE);
+         INIT_VLC_STATIC(&huff_vlc[2], VLC_BITS, 15,
+                     &ff_mlp_huffman_tables[2][0][1], 2, 1,
+-                    &ff_mlp_huffman_tables[2][0][0], 2, 1, 512);
++                    &ff_mlp_huffman_tables[2][0][0], 2, 1, VLC_STATIC_SIZE);
+     }
+
+     ff_mlp_init_crc();
+--
+1.9.1
diff --git a/tools/depends/target/ffmpeg/0002-truehd-add-hand-scheduled-ARM-asm-version-of-mlp_fil.patch b/tools/depends/target/ffmpeg/0002-truehd-add-hand-scheduled-ARM-asm-version-of-mlp_fil.patch
new file mode 100644
index 0000000..4aea35f
--- /dev/null
+++ b/tools/depends/target/ffmpeg/0002-truehd-add-hand-scheduled-ARM-asm-version-of-mlp_fil.patch
@@ -0,0 +1,557 @@
+From bfe3d8c8e4e046163dc314aa16207413e377283f Mon Sep 17 00:00:00 2001
+From: Ben Avison <bavison@riscosopen.org>
+Date: Mon, 3 Mar 2014 19:44:23 +0000
+Subject: [PATCH 2/6] truehd: add hand-scheduled ARM asm version of
+ mlp_filter_channel.
+
+Profiling results for overall audio decode and the mlp_filter_channel(_arm)
+function in particular are as follows:
+
+              Before          After
+              Mean   StdDev   Mean   StdDev  Confidence  Change
+6:2 total     380.4  22.0     370.8  17.0    87.4%       +2.6%  (insignificant)
+6:2 function  60.7   7.2      36.6   8.1     100.0%      +65.8%
+8:2 total     357.0  17.5     343.2  19.0    97.8%       +4.0%  (insignificant)
+8:2 function  60.3   8.8      37.3   3.8     100.0%      +61.8%
+6:6 total     717.2  23.2     658.4  15.7    100.0%      +8.9%
+6:6 function  140.4  12.9     81.5   9.2     100.0%      +72.4%
+8:8 total     981.9  16.2     896.2  24.5    100.0%      +9.6%
+8:8 function  193.4  15.0     103.3  11.5    100.0%      +87.2%
+
+Experiments with adding preload instructions to this function yielded no
+useful benefit, so these have not been included.
+
+The assembly version has also been tested with a fuzz tester to ensure that
+any combinations of inputs not exercised by my available test streams still
+generate mathematically identical results to the C version.
+---
+ libavcodec/arm/Makefile          |   2 +
+ libavcodec/arm/mlpdsp_arm.S      | 433 +++++++++++++++++++++++++++++++++++++++
+ libavcodec/arm/mlpdsp_init_arm.c |  36 ++++
+ libavcodec/mlpdsp.c              |   2 +
+ libavcodec/mlpdsp.h              |   1 +
+ 5 files changed, 474 insertions(+)
+ create mode 100644 libavcodec/arm/mlpdsp_arm.S
+ create mode 100644 libavcodec/arm/mlpdsp_init_arm.c
+
+diff --git a/libavcodec/arm/Makefile b/libavcodec/arm/Makefile
+index a8446b2..ba673b1 100644
+--- a/libavcodec/arm/Makefile
++++ b/libavcodec/arm/Makefile
+@@ -22,6 +22,8 @@ OBJS-$(CONFIG_H264PRED)                += arm/h264pred_init_arm.o
+ OBJS-$(CONFIG_H264QPEL)                += arm/h264qpel_init_arm.o
+ OBJS-$(CONFIG_HPELDSP)                 += arm/hpeldsp_init_arm.o        \
+                                           arm/hpeldsp_arm.o
++OBJS-$(CONFIG_MLP_DECODER)             += arm/mlpdsp_init_arm.o         \
++                                          arm/mlpdsp_arm.o
+ OBJS-$(CONFIG_MPEGAUDIODSP)            += arm/mpegaudiodsp_init_arm.o
+ OBJS-$(CONFIG_MPEGVIDEO)               += arm/mpegvideo_arm.o
+ OBJS-$(CONFIG_NEON_CLOBBER_TEST)       += arm/neontest.o
+diff --git a/libavcodec/arm/mlpdsp_arm.S b/libavcodec/arm/mlpdsp_arm.S
+new file mode 100644
+index 0000000..615819d
+--- /dev/null
++++ b/libavcodec/arm/mlpdsp_arm.S
+@@ -0,0 +1,433 @@
++/*
++ * Copyright (c) 2014 RISC OS Open Ltd
++ * Author: Ben Avison <bavison@riscosopen.org>
++ *
++ * This file is part of FFmpeg.
++ *
++ * FFmpeg is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU Lesser General Public
++ * License as published by the Free Software Foundation; either
++ * version 2.1 of the License, or (at your option) any later version.
++ *
++ * FFmpeg is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++ * Lesser General Public License for more details.
++ *
++ * You should have received a copy of the GNU Lesser General Public
++ * License along with FFmpeg; if not, write to the Free Software
++ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
++ */
++
++#include "libavutil/arm/asm.S"
++
++#define MAX_CHANNELS        8
++#define MAX_FIR_ORDER       8
++#define MAX_IIR_ORDER       4
++#define MAX_RATEFACTOR      4
++#define MAX_BLOCKSIZE       (40 * MAX_RATEFACTOR)
++
++PST     .req    a1
++PCO     .req    a2
++AC0     .req    a3
++AC1     .req    a4
++CO0     .req    v1
++CO1     .req    v2
++CO2     .req    v3
++CO3     .req    v4
++ST0     .req    v5
++ST1     .req    v6
++ST2     .req    sl
++ST3     .req    fp
++I       .req    ip
++PSAMP   .req    lr
++
++
++// Some macros that do loads/multiplies where the register number is determined
++// from an assembly-time expression. Boy is GNU assembler's syntax ugly...
++
++.macro load  group, index, base, offset
++       .altmacro
++       load_ \group, %(\index), \base, \offset
++       .noaltmacro
++.endm
++
++.macro load_ group, index, base, offset
++        ldr     \group\index, [\base, #\offset]
++.endm
++
++.macro loadd  group, index, base, offset
++       .altmacro
++       loadd_ \group, %(\index), %(\index+1), \base, \offset
++       .noaltmacro
++.endm
++
++.macro loadd_ group, index0, index1, base, offset
++A .if offset >= 256
++A       ldr     \group\index0, [\base, #\offset]
++A       ldr     \group\index1, [\base, #(\offset) + 4]
++A .else
++        ldrd    \group\index0, \group\index1, [\base, #\offset]
++A .endif
++.endm
++
++.macro multiply  index, accumulate, long
++        .altmacro
++        multiply_ %(\index), \accumulate, \long
++        .noaltmacro
++.endm
++
++.macro multiply_  index, accumulate, long
++ .if \long
++  .if \accumulate
++        smlal   AC0, AC1, CO\index, ST\index
++  .else
++        smull   AC0, AC1, CO\index, ST\index
++  .endif
++ .else
++  .if \accumulate
++        mla     AC0, CO\index, ST\index, AC0
++  .else
++        mul     AC0, CO\index, ST\index
++  .endif
++ .endif
++.endm
++
++// A macro to update the load register number and load offsets
++
++.macro inc  howmany
++  .set LOAD_REG, (LOAD_REG + \howmany) & 3
++  .set OFFSET_CO, OFFSET_CO + 4 * \howmany
++  .set OFFSET_ST, OFFSET_ST + 4 * \howmany
++  .if FIR_REMAIN > 0
++    .set FIR_REMAIN, FIR_REMAIN - \howmany
++    .if FIR_REMAIN == 0
++      .set OFFSET_CO, 4 * MAX_FIR_ORDER
++      .set OFFSET_ST, 4 * (MAX_BLOCKSIZE + MAX_FIR_ORDER)
++    .endif
++  .elseif IIR_REMAIN > 0
++    .set IIR_REMAIN, IIR_REMAIN - \howmany
++  .endif
++.endm
++
++// Macro to implement the inner loop for one specific combination of parameters
++
++.macro implement_filter  mask_minus1, shift_0, shift_8, iir_taps, fir_taps
++  .set TOTAL_TAPS, \iir_taps + \fir_taps
++
++  // Deal with register allocation...
++  .set DEFINED_SHIFT, 0
++  .set DEFINED_MASK, 0
++  .set SHUFFLE_SHIFT, 0
++  .set SHUFFLE_MASK, 0
++  .set SPILL_SHIFT, 0
++  .set SPILL_MASK, 0
++  .if TOTAL_TAPS == 0
++    // Little register pressure in this case - just keep MASK where it was
++    .if !\mask_minus1
++      MASK .req ST1
++      .set DEFINED_MASK, 1
++    .endif
++  .else
++    .if \shift_0
++      .if !\mask_minus1
++        // AC1 is unused with shift 0
++        MASK .req AC1
++        .set DEFINED_MASK, 1
++        .set SHUFFLE_MASK, 1
++      .endif
++    .elseif \shift_8
++      .if !\mask_minus1
++        .if TOTAL_TAPS <= 4
++        // All coefficients are preloaded (so pointer not needed)
++          MASK .req PCO
++          .set DEFINED_MASK, 1
++          .set SHUFFLE_MASK, 1
++        .else
++          .set SPILL_MASK, 1
++        .endif
++      .endif
++    .else // shift not 0 or 8
++      .if TOTAL_TAPS <= 3
++        // All coefficients are preloaded, and at least one CO register is unused
++        .if \fir_taps & 1
++          SHIFT .req CO0
++          .set DEFINED_SHIFT, 1
++          .set SHUFFLE_SHIFT, 1
++        .else
++          SHIFT .req CO3
++          .set DEFINED_SHIFT, 1
++          .set SHUFFLE_SHIFT, 1
++        .endif
++        .if !\mask_minus1
++          MASK .req PCO
++          .set DEFINED_MASK, 1
++          .set SHUFFLE_MASK, 1
++        .endif
++      .elseif TOTAL_TAPS == 4
++        // All coefficients are preloaded
++        SHIFT .req PCO
++        .set DEFINED_SHIFT, 1
++        .set SHUFFLE_SHIFT, 1
++        .if !\mask_minus1
++          .set SPILL_MASK, 1
++        .endif
++      .else
++        .set SPILL_SHIFT, 1
++        .if !\mask_minus1
++          .set SPILL_MASK, 1
++        .endif
++      .endif
++    .endif
++  .endif
++  .if SPILL_SHIFT
++    SHIFT .req ST0
++    .set DEFINED_SHIFT, 1
++  .endif
++  .if SPILL_MASK
++    MASK .req ST1
++    .set DEFINED_MASK, 1
++  .endif
++
++        // Preload coefficients if possible
++  .if TOTAL_TAPS <= 4
++    .set OFFSET_CO, 0
++    .if \fir_taps & 1
++      .set LOAD_REG, 1
++    .else
++      .set LOAD_REG, 0
++    .endif
++    .rept \fir_taps
++        load    CO, LOAD_REG, PCO, OFFSET_CO
++      .set LOAD_REG, (LOAD_REG + 1) & 3
++      .set OFFSET_CO, OFFSET_CO + 4
++    .endr
++    .set OFFSET_CO, 4 * MAX_FIR_ORDER
++    .rept \iir_taps
++        load    CO, LOAD_REG, PCO, OFFSET_CO
++      .set LOAD_REG, (LOAD_REG + 1) & 3
++      .set OFFSET_CO, OFFSET_CO + 4
++    .endr
++  .endif
++
++        // Move mask/shift to final positions if necessary
++        // Need to do this after preloading, because in some cases we
++        // reuse the coefficient pointer register
++  .if SHUFFLE_SHIFT
++        mov     SHIFT, ST0
++  .endif
++  .if SHUFFLE_MASK
++        mov     MASK, ST1
++  .endif
++
++        // Begin loop
++01:
++  .if TOTAL_TAPS == 0
++        // Things simplify a lot in this case
++        // In fact this could be pipelined further if it's worth it...
++        ldr     ST0, [PSAMP]
++        subs    I, I, #1
++    .if !\mask_minus1
++        and     ST0, ST0, MASK
++    .endif
++        str     ST0, [PST, #-4]!
++        str     ST0, [PST, #4 * (MAX_BLOCKSIZE + MAX_FIR_ORDER)]
++        str     ST0, [PSAMP], #4 * MAX_CHANNELS
++        bne     01b
++  .else
++    .if \fir_taps & 1
++      .set LOAD_REG, 1
++    .else
++      .set LOAD_REG, 0
++    .endif
++    .set LOAD_BANK, 0
++    .set FIR_REMAIN, \fir_taps
++    .set IIR_REMAIN, \iir_taps
++    .if FIR_REMAIN == 0 // only IIR terms
++      .set OFFSET_CO, 4 * MAX_FIR_ORDER
++      .set OFFSET_ST, 4 * (MAX_BLOCKSIZE + MAX_FIR_ORDER)
++    .else
++      .set OFFSET_CO, 0
++      .set OFFSET_ST, 0
++    .endif
++    .set MUL_REG, LOAD_REG
++    .set COUNTER, 0
++    .rept TOTAL_TAPS + 2
++        // Do load(s)
++     .if FIR_REMAIN != 0 || IIR_REMAIN != 0
++      .if COUNTER == 0
++       .if TOTAL_TAPS > 4
++        load    CO, LOAD_REG, PCO, OFFSET_CO
++       .endif
++        load    ST, LOAD_REG, PST, OFFSET_ST
++        inc     1
++      .elseif COUNTER == 1 && (\fir_taps & 1) == 0
++       .if TOTAL_TAPS > 4
++        load    CO, LOAD_REG, PCO, OFFSET_CO
++       .endif
++        load    ST, LOAD_REG, PST, OFFSET_ST
++        inc     1
++      .elseif LOAD_BANK == 0
++       .if TOTAL_TAPS > 4
++        .if FIR_REMAIN == 0 && IIR_REMAIN == 1
++        load    CO, LOAD_REG, PCO, OFFSET_CO
++        .else
++        loadd   CO, LOAD_REG, PCO, OFFSET_CO
++        .endif
++       .endif
++       .set LOAD_BANK, 1
++      .else
++       .if FIR_REMAIN == 0 && IIR_REMAIN == 1
++        load    ST, LOAD_REG, PST, OFFSET_ST
++        inc     1
++       .else
++        loadd   ST, LOAD_REG, PST, OFFSET_ST
++        inc     2
++       .endif
++       .set LOAD_BANK, 0
++      .endif
++     .endif
++
++        // Do interleaved multiplies, slightly delayed
++     .if COUNTER >= 2
++        multiply MUL_REG, COUNTER > 2, !\shift_0
++      .set MUL_REG, (MUL_REG + 1) & 3
++     .endif
++     .set COUNTER, COUNTER + 1
++    .endr
++
++        // Post-process the result of the multiplies
++    .if SPILL_SHIFT
++        ldr     SHIFT, [sp, #9*4 + 0*4]
++    .endif
++    .if SPILL_MASK
++        ldr     MASK, [sp, #9*4 + 1*4]
++    .endif
++        ldr     ST2, [PSAMP]
++        subs    I, I, #1
++    .if \shift_8
++        mov     AC0, AC0, lsr #8
++        orr     AC0, AC0, AC1, lsl #24
++    .elseif !\shift_0
++        rsb     ST3, SHIFT, #32
++        mov     AC0, AC0, lsr SHIFT
++A       orr     AC0, AC0, AC1, lsl ST3
++T       mov     AC1, AC1, lsl ST3
++T       orr     AC0, AC0, AC1
++    .endif
++    .if \mask_minus1
++        add     ST3, ST2, AC0
++    .else
++        add     ST2, ST2, AC0
++        and     ST3, ST2, MASK
++        sub     ST2, ST3, AC0
++    .endif
++        str     ST3, [PST, #-4]!
++        str     ST2, [PST, #4 * (MAX_BLOCKSIZE + MAX_FIR_ORDER)]
++        str     ST3, [PSAMP], #4 * MAX_CHANNELS
++        bne     01b
++  .endif
++        b       99f
++
++  .if DEFINED_SHIFT
++    .unreq SHIFT
++  .endif
++  .if DEFINED_MASK
++    .unreq MASK
++  .endif
++.endm
++
++.macro switch_on_fir_taps  mask_minus1, shift_0, shift_8, iir_taps
++A       ldr     pc, [pc, a3, LSL #2] // firorder is in range 0-(8-iir_taps)
++T       tbh     [pc, a3, lsl #1]
++0:
++A       .word   0, 70f, 71f, 72f, 73f, 74f
++T       .hword  (70f - 0b) / 2, (71f - 0b) / 2, (72f - 0b) / 2, (73f - 0b) / 2, (74f - 0b) / 2
++ .if \iir_taps <= 3
++A       .word   75f
++T       .hword  (75f - 0b) / 2
++  .if \iir_taps <= 2
++A       .word   76f
++T       .hword  (76f - 0b) / 2
++   .if \iir_taps <= 1
++A       .word   77f
++T       .hword  (77f - 0b) / 2
++    .if \iir_taps == 0
++A       .word   78f
++T       .hword  (78f - 0b) / 2
++    .endif
++   .endif
++  .endif
++ .endif
++70:     implement_filter  \mask_minus1, \shift_0, \shift_8, \iir_taps, 0
++71:     implement_filter  \mask_minus1, \shift_0, \shift_8, \iir_taps, 1
++72:     implement_filter  \mask_minus1, \shift_0, \shift_8, \iir_taps, 2
++73:     implement_filter  \mask_minus1, \shift_0, \shift_8, \iir_taps, 3
++74:     implement_filter  \mask_minus1, \shift_0, \shift_8, \iir_taps, 4
++ .if \iir_taps <= 3
++75:     implement_filter  \mask_minus1, \shift_0, \shift_8, \iir_taps, 5
++  .if \iir_taps <= 2
++76:     implement_filter  \mask_minus1, \shift_0, \shift_8, \iir_taps, 6
++   .if \iir_taps <= 1
++77:     implement_filter  \mask_minus1, \shift_0, \shift_8, \iir_taps, 7
++    .if \iir_taps == 0
++78:     implement_filter  \mask_minus1, \shift_0, \shift_8, \iir_taps, 8
++    .endif
++   .endif
++  .endif
++ .endif
++.endm
++
++.macro switch_on_iir_taps  mask_minus1, shift_0, shift_8
++A       ldr     pc, [pc, a4, LSL #2] // irorder is in range 0-4
++T       tbh    [pc, a4, lsl #1]
++0:
++A       .word   0, 60f, 61f, 62f, 63f, 64f
++T       .hword  (60f - 0b) / 2, (61f - 0b) / 2, (62f - 0b) / 2, (63f - 0b) / 2, (64f - 0b) / 2
++60:     switch_on_fir_taps  \mask_minus1, \shift_0, \shift_8, 0
++61:     switch_on_fir_taps  \mask_minus1, \shift_0, \shift_8, 1
++62:     switch_on_fir_taps  \mask_minus1, \shift_0, \shift_8, 2
++63:     switch_on_fir_taps  \mask_minus1, \shift_0, \shift_8, 3
++64:     switch_on_fir_taps  \mask_minus1, \shift_0, \shift_8, 4
++.endm
++
++/* void ff_mlp_filter_channel_arm(int32_t *state, const int32_t *coeff,
++ *                                int firorder, int iirorder,
++ *                                unsigned int filter_shift, int32_t mask,
++ *                                int blocksize, int32_t *sample_buffer);
++ */
++function ff_mlp_filter_channel_arm, export=1
++        push    {v1-fp,lr}
++        add     v1, sp, #9*4 // point at arguments on stack
++        ldm     v1, {ST0,ST1,I,PSAMP}
++        cmp     ST1, #-1
++        bne     30f
++        movs    ST2, ST0, lsl #29 // shift is in range 0-15; we want to special-case 0 and 8
++        bne     20f
++        bcs     10f
++        switch_on_iir_taps 1, 1, 0
++10:     switch_on_iir_taps 1, 0, 1
++20:     switch_on_iir_taps 1, 0, 0
++30:     movs    ST2, ST0, lsl #29 // shift is in range 0-15; we want to special-case 0 and 8
++        bne     50f
++        bcs     40f
++        switch_on_iir_taps 0, 1, 0
++40:     switch_on_iir_taps 0, 0, 1
++50:     switch_on_iir_taps 0, 0, 0
++99:     pop     {v1-fp,pc}
++endfunc
++
++        .unreq  PST
++        .unreq  PCO
++        .unreq  AC0
++        .unreq  AC1
++        .unreq  CO0
++        .unreq  CO1
++        .unreq  CO2
++        .unreq  CO3
++        .unreq  ST0
++        .unreq  ST1
++        .unreq  ST2
++        .unreq  ST3
++        .unreq  I
++        .unreq  PSAMP
+diff --git a/libavcodec/arm/mlpdsp_init_arm.c b/libavcodec/arm/mlpdsp_init_arm.c
+new file mode 100644
+index 0000000..9a14815
+--- /dev/null
++++ b/libavcodec/arm/mlpdsp_init_arm.c
+@@ -0,0 +1,36 @@
++/*
++ * Copyright (c) 2014 RISC OS Open Ltd
++ * Author: Ben Avison <bavison@riscosopen.org>
++ *
++ * This file is part of FFmpeg.
++ *
++ * FFmpeg is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU Lesser General Public
++ * License as published by the Free Software Foundation; either
++ * version 2.1 of the License, or (at your option) any later version.
++ *
++ * FFmpeg is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++ * Lesser General Public License for more details.
++ *
++ * You should have received a copy of the GNU Lesser General Public
++ * License along with FFmpeg; if not, write to the Free Software
++ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
++ */
++
++#include <stdint.h>
++
++#include "libavutil/arm/cpu.h"
++#include "libavutil/attributes.h"
++#include "libavcodec/mlpdsp.h"
++
++void ff_mlp_filter_channel_arm(int32_t *state, const int32_t *coeff,
++                               int firorder, int iirorder,
++                               unsigned int filter_shift, int32_t mask,
++                               int blocksize, int32_t *sample_buffer);
++
++av_cold void ff_mlpdsp_init_arm(MLPDSPContext *c)
++{
++    c->mlp_filter_channel = ff_mlp_filter_channel_arm;
++}
+diff --git a/libavcodec/mlpdsp.c b/libavcodec/mlpdsp.c
+index b413e86..4b403b8 100644
+--- a/libavcodec/mlpdsp.c
++++ b/libavcodec/mlpdsp.c
+@@ -60,6 +60,8 @@ static void mlp_filter_channel(int32_t *state, const int32_t *coeff,
+ av_cold void ff_mlpdsp_init(MLPDSPContext *c)
+ {
+     c->mlp_filter_channel = mlp_filter_channel;
++    if (ARCH_ARM)
++        ff_mlpdsp_init_arm(c);
+     if (ARCH_X86)
+         ff_mlpdsp_init_x86(c);
+ }
+diff --git a/libavcodec/mlpdsp.h b/libavcodec/mlpdsp.h
+index 84a8aa3..129bcfe 100644
+--- a/libavcodec/mlpdsp.h
++++ b/libavcodec/mlpdsp.h
+@@ -32,6 +32,7 @@ typedef struct MLPDSPContext {
+ } MLPDSPContext;
+
+ void ff_mlpdsp_init(MLPDSPContext *c);
++void ff_mlpdsp_init_arm(MLPDSPContext *c);
+ void ff_mlpdsp_init_x86(MLPDSPContext *c);
+
+ #endif /* AVCODEC_MLPDSP_H */
+--
+1.9.1
diff --git a/tools/depends/target/ffmpeg/0003-truehd-break-out-part-of-rematrix_channels-into-plat.patch b/tools/depends/target/ffmpeg/0003-truehd-break-out-part-of-rematrix_channels-into-plat.patch
new file mode 100644
index 0000000..9c06f8f
--- /dev/null
+++ b/tools/depends/target/ffmpeg/0003-truehd-break-out-part-of-rematrix_channels-into-plat.patch
@@ -0,0 +1,158 @@
+From bb74fc44081fb6d7923ce1b7ed3e3e6514695f3e Mon Sep 17 00:00:00 2001
+From: Ben Avison <bavison@riscosopen.org>
+Date: Wed, 5 Mar 2014 21:01:28 +0000
+Subject: [PATCH 3/6] truehd: break out part of rematrix_channels into
+ platform-specific callback.
+
+Verified with profiling that this doesn't have a measurable effect upon
+overall performance.
+---
+ libavcodec/mlpdec.c | 37 ++++++++++++-------------------------
+ libavcodec/mlpdsp.c | 33 +++++++++++++++++++++++++++++++++
+ libavcodec/mlpdsp.h | 23 +++++++++++++++++++++++
+ 3 files changed, 68 insertions(+), 25 deletions(-)
+
+diff --git a/libavcodec/mlpdec.c b/libavcodec/mlpdec.c
+index cbd9000..01ded5c 100644
+--- a/libavcodec/mlpdec.c
++++ b/libavcodec/mlpdec.c
+@@ -1024,7 +1024,7 @@ static void fill_noise_buffer(MLPDecodeContext *m, unsigned int substr)
+ static void rematrix_channels(MLPDecodeContext *m, unsigned int substr)
+ {
+     SubStream *s = &m->substream[substr];
+-    unsigned int mat, src_ch, i;
++    unsigned int mat;
+     unsigned int maxchan;
+
+     maxchan = s->max_matrix_channel;
+@@ -1036,31 +1036,18 @@ static void rematrix_channels(MLPDecodeContext *m, unsigned int substr)
+     }
+
+     for (mat = 0; mat < s->num_primitive_matrices; mat++) {
+-        int matrix_noise_shift = s->matrix_noise_shift[mat];
+         unsigned int dest_ch = s->matrix_out_ch[mat];
+-        int32_t mask = MSB_MASK(s->quant_step_size[dest_ch]);
+-        int32_t *coeffs = s->matrix_coeff[mat];
+-        int index  = s->num_primitive_matrices - mat;
+-        int index2 = 2 * index + 1;
+-
+-        /* TODO: DSPContext? */
+-
+-        for (i = 0; i < s->blockpos; i++) {
+-            int32_t bypassed_lsb = m->bypassed_lsbs[i][mat];
+-            int32_t *samples = m->sample_buffer[i];
+-            int64_t accum = 0;
+-
+-            for (src_ch = 0; src_ch <= maxchan; src_ch++)
+-                accum += (int64_t) samples[src_ch] * coeffs[src_ch];
+-
+-            if (matrix_noise_shift) {
+-                index &= m->access_unit_size_pow2 - 1;
+-                accum += m->noise_buffer[index] << (matrix_noise_shift + 7);
+-                index += index2;
+-            }
+-
+-            samples[dest_ch] = ((accum >> 14) & mask) + bypassed_lsb;
+-        }
++        m->dsp.mlp_rematrix_channel(&m->sample_buffer[0][0],
++                                    s->matrix_coeff[mat],
++                                    &m->bypassed_lsbs[0][mat],
++                                    m->noise_buffer,
++                                    s->num_primitive_matrices - mat,
++                                    dest_ch,
++                                    s->blockpos,
++                                    maxchan,
++                                    s->matrix_noise_shift[mat],
++                                    m->access_unit_size_pow2,
++                                    MSB_MASK(s->quant_step_size[dest_ch]));
+     }
+ }
+
+diff --git a/libavcodec/mlpdsp.c b/libavcodec/mlpdsp.c
+index 4b403b8..7a359b0 100644
+--- a/libavcodec/mlpdsp.c
++++ b/libavcodec/mlpdsp.c
+@@ -57,9 +57,42 @@ static void mlp_filter_channel(int32_t *state, const int32_t *coeff,
+     }
+ }
+
++void ff_mlp_rematrix_channel(int32_t *samples,
++                             const int32_t *coeffs,
++                             const uint8_t *bypassed_lsbs,
++                             const int8_t *noise_buffer,
++                             int index,
++                             unsigned int dest_ch,
++                             uint16_t blockpos,
++                             unsigned int maxchan,
++                             int matrix_noise_shift,
++                             int access_unit_size_pow2,
++                             int32_t mask)
++{
++    unsigned int src_ch, i;
++    int index2 = 2 * index + 1;
++    for (i = 0; i < blockpos; i++) {
++        int64_t accum = 0;
++
++        for (src_ch = 0; src_ch <= maxchan; src_ch++)
++            accum += (int64_t) samples[src_ch] * coeffs[src_ch];
++
++        if (matrix_noise_shift) {
++            index &= access_unit_size_pow2 - 1;
++            accum += noise_buffer[index] << (matrix_noise_shift + 7);
++            index += index2;
++        }
++
++        samples[dest_ch] = ((accum >> 14) & mask) + *bypassed_lsbs;
++        bypassed_lsbs += MAX_CHANNELS;
++        samples += MAX_CHANNELS;
++    }
++}
++
+ av_cold void ff_mlpdsp_init(MLPDSPContext *c)
+ {
+     c->mlp_filter_channel = mlp_filter_channel;
++    c->mlp_rematrix_channel = ff_mlp_rematrix_channel;
+     if (ARCH_ARM)
+         ff_mlpdsp_init_arm(c);
+     if (ARCH_X86)
+diff --git a/libavcodec/mlpdsp.h b/libavcodec/mlpdsp.h
+index 129bcfe..f98e9be 100644
+--- a/libavcodec/mlpdsp.h
++++ b/libavcodec/mlpdsp.h
+@@ -24,11 +24,34 @@
+
+ #include <stdint.h>
+
++void ff_mlp_rematrix_channel(int32_t *samples,
++                             const int32_t *coeffs,
++                             const uint8_t *bypassed_lsbs,
++                             const int8_t *noise_buffer,
++                             int index,
++                             unsigned int dest_ch,
++                             uint16_t blockpos,
++                             unsigned int maxchan,
++                             int matrix_noise_shift,
++                             int access_unit_size_pow2,
++                             int32_t mask);
++
+ typedef struct MLPDSPContext {
+     void (*mlp_filter_channel)(int32_t *state, const int32_t *coeff,
+                                int firorder, int iirorder,
+                                unsigned int filter_shift, int32_t mask,
+                                int blocksize, int32_t *sample_buffer);
++    void (*mlp_rematrix_channel)(int32_t *samples,
++                                 const int32_t *coeffs,
++                                 const uint8_t *bypassed_lsbs,
++                                 const int8_t *noise_buffer,
++                                 int index,
++                                 unsigned int dest_ch,
++                                 uint16_t blockpos,
++                                 unsigned int maxchan,
++                                 int matrix_noise_shift,
++                                 int access_unit_size_pow2,
++                                 int32_t mask);
+ } MLPDSPContext;
+
+ void ff_mlpdsp_init(MLPDSPContext *c);
+--
+1.9.1
diff --git a/tools/depends/target/ffmpeg/0004-truehd-add-hand-scheduled-ARM-asm-version-of-ff_mlp_.patch b/tools/depends/target/ffmpeg/0004-truehd-add-hand-scheduled-ARM-asm-version-of-ff_mlp_.patch
new file mode 100644
index 0000000..575622e
--- /dev/null
+++ b/tools/depends/target/ffmpeg/0004-truehd-add-hand-scheduled-ARM-asm-version-of-ff_mlp_.patch
@@ -0,0 +1,285 @@
+From 98428a8cf593587b403076bb54b46cc70ed17ff2 Mon Sep 17 00:00:00 2001
+From: Ben Avison <bavison@riscosopen.org>
+Date: Mon, 10 Mar 2014 14:42:05 +0000
+Subject: [PATCH 4/6] truehd: add hand-scheduled ARM asm version of
+ ff_mlp_rematrix_channel.
+
+Profiling results for overall audio decode and the rematrix_channels function
+in particular are as follows:
+
+              Before          After
+              Mean   StdDev   Mean   StdDev  Confidence  Change
+6:2 total     370.8  17.0     348.8  20.1    99.9%       +6.3%
+6:2 function  46.4   8.4      45.8   6.6     18.0%       +1.2%  (insignificant)
+8:2 total     343.2  19.0     339.1  15.4    54.7%       +1.2%  (insignificant)
+8:2 function  38.9   3.9      40.2   6.9     52.4%       -3.2%  (insignificant)
+6:6 total     658.4  15.7     604.6  20.8    100.0%      +8.9%
+6:6 function  109.0  8.7      59.5   5.4     100.0%      +83.3%
+8:8 total     896.2  24.5     766.4  17.6    100.0%      +16.9%
+8:8 function  223.4  12.8     93.8   5.0     100.0%      +138.3%
+
+The assembly version has also been tested with a fuzz tester to ensure that
+any combinations of inputs not exercised by my available test streams still
+generate mathematically identical results to the C version.
+---
+ libavcodec/arm/mlpdsp_arm.S      | 222 +++++++++++++++++++++++++++++++++++++++
+ libavcodec/arm/mlpdsp_init_arm.c |  12 +++
+ 2 files changed, 234 insertions(+)
+
+diff --git a/libavcodec/arm/mlpdsp_arm.S b/libavcodec/arm/mlpdsp_arm.S
+index 615819d..9b51d0c 100644
+--- a/libavcodec/arm/mlpdsp_arm.S
++++ b/libavcodec/arm/mlpdsp_arm.S
+@@ -431,3 +431,225 @@ endfunc
+         .unreq  ST3
+         .unreq  I
+         .unreq  PSAMP
++
++/********************************************************************/
++
++PSA     .req    a1 // samples
++PCO     .req    a2 // coeffs
++PBL     .req    a3 // bypassed_lsbs
++INDEX   .req    a4
++CO0     .req    v1
++CO1     .req    v2
++CO2     .req    v3
++CO3     .req    v4
++SA0     .req    v5
++SA1     .req    v6
++SA2     .req    sl
++SA3     .req    fp
++AC0     .req    ip
++AC1     .req    lr
++NOISE   .req    SA0
++LSB     .req    SA1
++DCH     .req    SA2 // dest_ch
++MASK    .req    SA3
++
++    // INDEX is used as follows:
++    // bits 0..6   index2 (values up to 17, but wider so that we can
++    //               add to index field without needing to mask)
++    // bits 7..14  i (values up to 160)
++    // bit 15      underflow detect for i
++    // bits 25..31 (if access_unit_size_pow2 == 128)  \ index
++    // bits 26..31 (if access_unit_size_pow2 == 64)   /
++
++.macro implement_rematrix  shift, index_mask, mask_minus1, maxchan
++    .if \maxchan == 1
++        // We can just leave the coefficients in registers in this case
++        ldrd    CO0, CO1, [PCO]
++    .endif
++1:
++    .if \maxchan == 1
++        ldrd    SA0, SA1, [PSA]
++        smull   AC0, AC1, CO0, SA0
++    .elseif \maxchan == 5
++        ldr     CO0, [PCO, #0]
++        ldr     SA0, [PSA, #0]
++        ldr     CO1, [PCO, #4]
++        ldr     SA1, [PSA, #4]
++        ldrd    CO2, CO3, [PCO, #8]
++        smull   AC0, AC1, CO0, SA0
++        ldrd    SA2, SA3, [PSA, #8]
++        smlal   AC0, AC1, CO1, SA1
++        ldrd    CO0, CO1, [PCO, #16]
++        smlal   AC0, AC1, CO2, SA2
++        ldrd    SA0, SA1, [PSA, #16]
++        smlal   AC0, AC1, CO3, SA3
++        smlal   AC0, AC1, CO0, SA0
++    .else // \maxchan == 7
++        ldr     CO2, [PCO, #0]
++        ldr     SA2, [PSA, #0]
++        ldr     CO3, [PCO, #4]
++        ldr     SA3, [PSA, #4]
++        ldrd    CO0, CO1, [PCO, #8]
++        smull   AC0, AC1, CO2, SA2
++        ldrd    SA0, SA1, [PSA, #8]
++        smlal   AC0, AC1, CO3, SA3
++        ldrd    CO2, CO3, [PCO, #16]
++        smlal   AC0, AC1, CO0, SA0
++        ldrd    SA2, SA3, [PSA, #16]
++        smlal   AC0, AC1, CO1, SA1
++        ldrd    CO0, CO1, [PCO, #24]
++        smlal   AC0, AC1, CO2, SA2
++        ldrd    SA0, SA1, [PSA, #24]
++        smlal   AC0, AC1, CO3, SA3
++        smlal   AC0, AC1, CO0, SA0
++    .endif
++        ldm     sp, {NOISE, DCH, MASK}
++        smlal   AC0, AC1, CO1, SA1
++    .if \shift != 0
++      .if \index_mask == 63
++        add     NOISE, NOISE, INDEX, lsr #32-6
++        ldrb    LSB, [PBL], #MAX_CHANNELS
++        ldrsb   NOISE, [NOISE]
++        add     INDEX, INDEX, INDEX, lsl #32-6
++      .else // \index_mask == 127
++        add     NOISE, NOISE, INDEX, lsr #32-7
++        ldrb    LSB, [PBL], #MAX_CHANNELS
++        ldrsb   NOISE, [NOISE]
++        add     INDEX, INDEX, INDEX, lsl #32-7
++      .endif
++        sub     INDEX, INDEX, #1<<7
++        adds    AC0, AC0, NOISE, lsl #\shift + 7
++        adc     AC1, AC1, NOISE, asr #31
++    .else
++        ldrb    LSB, [PBL], #MAX_CHANNELS
++        sub     INDEX, INDEX, #1<<7
++    .endif
++        add     PSA, PSA, #MAX_CHANNELS*4
++        mov     AC0, AC0, lsr #14
++        orr     AC0, AC0, AC1, lsl #18
++    .if !\mask_minus1
++        and     AC0, AC0, MASK
++    .endif
++        add     AC0, AC0, LSB
++        tst     INDEX, #1<<15
++        str     AC0, [PSA, DCH, lsl #2]  // DCH is precompensated for the early increment of PSA
++        beq     1b
++        b       98f
++.endm
++
++.macro switch_on_maxchan  shift, index_mask, mask_minus1
++        cmp     v4, #5
++        blo     51f
++        beq     50f
++        implement_rematrix  \shift, \index_mask, \mask_minus1, 7
++50:     implement_rematrix  \shift, \index_mask, \mask_minus1, 5
++51:     implement_rematrix  \shift, \index_mask, \mask_minus1, 1
++.endm
++
++.macro switch_on_mask  shift, index_mask
++        cmp     sl, #-1
++        bne     40f
++        switch_on_maxchan  \shift, \index_mask, 1
++40:     switch_on_maxchan  \shift, \index_mask, 0
++.endm
++
++.macro switch_on_au_size  shift
++  .if \shift == 0
++        switch_on_mask  \shift, undefined
++  .else
++        teq     v6, #64
++        bne     30f
++        orr     INDEX, INDEX, v1, lsl #32-6
++        switch_on_mask  \shift, 63
++30:     orr     INDEX, INDEX, v1, lsl #32-7
++        switch_on_mask  \shift, 127
++  .endif
++.endm
++
++/* void ff_mlp_rematrix_channel_arm(int32_t *samples,
++ *                                  const int32_t *coeffs,
++ *                                  const uint8_t *bypassed_lsbs,
++ *                                  const int8_t *noise_buffer,
++ *                                  int index,
++ *                                  unsigned int dest_ch,
++ *                                  uint16_t blockpos,
++ *                                  unsigned int maxchan,
++ *                                  int matrix_noise_shift,
++ *                                  int access_unit_size_pow2,
++ *                                  int32_t mask);
++ */
++function ff_mlp_rematrix_channel_arm, export=1
++        push    {v1-fp,lr}
++        add     v1, sp, #9*4 // point at arguments on stack
++        ldm     v1, {v1-sl}
++        teq     v4, #1
++        itt     ne
++        teqne   v4, #5
++        teqne   v4, #7
++        bne     99f
++        teq     v6, #64
++        it      ne
++        teqne   v6, #128
++        bne     99f
++        sub     v2, v2, #MAX_CHANNELS
++        push    {a4,v2,sl}          // initialise NOISE,DCH,MASK; make sp dword-aligned
++        movs    INDEX, v3, lsl #7
++        beq     98f                 // just in case, do nothing if blockpos = 0
++        subs    INDEX, INDEX, #1<<7 // offset by 1 so we borrow at the right time
++        adc     lr, v1, v1          // calculate index2 (C was set by preceding subs)
++        orr     INDEX, INDEX, lr
++        // Switch on matrix_noise_shift: values 0 and 1 are
++        // disproportionately common so do those in a form the branch
++        // predictor can accelerate. Values can only go up to 15.
++        cmp     v5, #1
++        beq     11f
++        blo     10f
++A       ldr     pc, [pc, v5, lsl #2]
++T       tbh     [pc, v5, lsl #1]
++0:
++A       .word   0, 0, 0, 12f, 13f, 14f, 15f, 16f, 17f, 18f, 19f, 20f, 21f, 22f, 23f, 24f, 25f
++T       .hword  0, 0, (12f - 0b) / 2, (13f - 0b) / 2, (14f - 0b) / 2, (15f - 0b) / 2
++T       .hword  (16f - 0b) / 2, (17f - 0b) / 2, (18f - 0b) / 2, (19f - 0b) / 2
++T       .hword  (20f - 0b) / 2, (21f - 0b) / 2, (22f - 0b) / 2, (23f - 0b) / 2, (24f - 0b) / 2, (25f - 0b) / 2
++10:     switch_on_au_size  0
++11:     switch_on_au_size  1
++12:     switch_on_au_size  2
++13:     switch_on_au_size  3
++14:     switch_on_au_size  4
++15:     switch_on_au_size  5
++16:     switch_on_au_size  6
++17:     switch_on_au_size  7
++18:     switch_on_au_size  8
++19:     switch_on_au_size  9
++20:     switch_on_au_size  10
++21:     switch_on_au_size  11
++22:     switch_on_au_size  12
++23:     switch_on_au_size  13
++24:     switch_on_au_size  14
++25:     switch_on_au_size  15
++
++98:     add     sp, sp, #3*4
++        pop     {v1-fp,pc}
++99:     // Can't handle these parameters, drop back to C
++        pop     {v1-fp,lr}
++        b       X(ff_mlp_rematrix_channel)
++endfunc
++
++        .unreq  PSA
++        .unreq  PCO
++        .unreq  PBL
++        .unreq  INDEX
++        .unreq  CO0
++        .unreq  CO1
++        .unreq  CO2
++        .unreq  CO3
++        .unreq  SA0
++        .unreq  SA1
++        .unreq  SA2
++        .unreq  SA3
++        .unreq  AC0
++        .unreq  AC1
++        .unreq  NOISE
++        .unreq  LSB
++        .unreq  DCH
++        .unreq  MASK
+diff --git a/libavcodec/arm/mlpdsp_init_arm.c b/libavcodec/arm/mlpdsp_init_arm.c
+index 9a14815..1bb2276 100644
+--- a/libavcodec/arm/mlpdsp_init_arm.c
++++ b/libavcodec/arm/mlpdsp_init_arm.c
+@@ -29,8 +29,20 @@ void ff_mlp_filter_channel_arm(int32_t *state, const int32_t *coeff,
+                                int firorder, int iirorder,
+                                unsigned int filter_shift, int32_t mask,
+                                int blocksize, int32_t *sample_buffer);
++void ff_mlp_rematrix_channel_arm(int32_t *samples,
++                                 const int32_t *coeffs,
++                                 const uint8_t *bypassed_lsbs,
++                                 const int8_t *noise_buffer,
++                                 int index,
++                                 unsigned int dest_ch,
++                                 uint16_t blockpos,
++                                 unsigned int maxchan,
++                                 int matrix_noise_shift,
++                                 int access_unit_size_pow2,
++                                 int32_t mask);
+
+ av_cold void ff_mlpdsp_init_arm(MLPDSPContext *c)
+ {
+     c->mlp_filter_channel = ff_mlp_filter_channel_arm;
++    c->mlp_rematrix_channel = ff_mlp_rematrix_channel_arm;
+ }
+--
+1.9.1
diff --git a/tools/depends/target/ffmpeg/0005-truehd-break-out-part-of-output_data-into-platform-s.patch b/tools/depends/target/ffmpeg/0005-truehd-break-out-part-of-output_data-into-platform-s.patch
new file mode 100644
index 0000000..c5880e9
--- /dev/null
+++ b/tools/depends/target/ffmpeg/0005-truehd-break-out-part-of-output_data-into-platform-s.patch
@@ -0,0 +1,197 @@
+From 5bfcb7a691eb63c56f1485b60f399d79ff943799 Mon Sep 17 00:00:00 2001
+From: Ben Avison <bavison@riscosopen.org>
+Date: Wed, 12 Mar 2014 18:18:39 +0000
+Subject: [PATCH 5/6] truehd: break out part of output_data into
+ platform-specific callback.
+
+Verified with profiling that this doesn't have a measurable effect upon
+overall performance.
+---
+ libavcodec/mlpdec.c | 40 +++++++++++++++++++++++-----------------
+ libavcodec/mlpdsp.c | 38 ++++++++++++++++++++++++++++++++++++++
+ libavcodec/mlpdsp.h | 22 ++++++++++++++++++++++
+ 3 files changed, 83 insertions(+), 17 deletions(-)
+
+diff --git a/libavcodec/mlpdec.c b/libavcodec/mlpdec.c
+index 01ded5c..061dabc 100644
+--- a/libavcodec/mlpdec.c
++++ b/libavcodec/mlpdec.c
+@@ -363,6 +363,10 @@ static int read_major_sync(MLPDecodeContext *m, GetBitContext *gb)
+         m->avctx->sample_fmt = AV_SAMPLE_FMT_S32;
+     else
+         m->avctx->sample_fmt = AV_SAMPLE_FMT_S16;
++    m->dsp.mlp_pack_output = m->dsp.mlp_select_pack_output(m->substream[m->max_decoded_substream].ch_assign,
++                                                           m->substream[m->max_decoded_substream].output_shift,
++                                                           m->substream[m->max_decoded_substream].max_matrix_channel,
++                                                           m->avctx->sample_fmt == AV_SAMPLE_FMT_S32);
+
+     m->params_valid = 1;
+     for (substr = 0; substr < MAX_SUBSTREAMS; substr++)
+@@ -612,6 +616,10 @@ FF_ENABLE_DEPRECATION_WARNINGS
+     if (substr == m->max_decoded_substream) {
+         m->avctx->channels       = s->max_matrix_channel + 1;
+         m->avctx->channel_layout = s->ch_layout;
++        m->dsp.mlp_pack_output = m->dsp.mlp_select_pack_output(s->ch_assign,
++                                                               s->output_shift,
++                                                               s->max_matrix_channel,
++                                                               m->avctx->sample_fmt == AV_SAMPLE_FMT_S32);
+
+         if (m->avctx->codec_id == AV_CODEC_ID_MLP && m->needs_reordering) {
+             if (m->avctx->channel_layout == (AV_CH_LAYOUT_QUAD|AV_CH_LOW_FREQUENCY) ||
+@@ -857,9 +865,15 @@ static int read_decoding_params(MLPDecodeContext *m, GetBitContext *gbp,
+                 return ret;
+
+     if (s->param_presence_flags & PARAM_OUTSHIFT)
+-        if (get_bits1(gbp))
++        if (get_bits1(gbp)) {
+             for (ch = 0; ch <= s->max_matrix_channel; ch++)
+                 s->output_shift[ch] = get_sbits(gbp, 4);
++            if (substr == m->max_decoded_substream)
++                m->dsp.mlp_pack_output = m->dsp.mlp_select_pack_output(s->ch_assign,
++                                                                       s->output_shift,
++                                                                       s->max_matrix_channel,
++                                                                       m->avctx->sample_fmt == AV_SAMPLE_FMT_S32);
++        }
+
+     if (s->param_presence_flags & PARAM_QUANTSTEP)
+         if (get_bits1(gbp))
+@@ -1058,9 +1072,6 @@ static int output_data(MLPDecodeContext *m, unsigned int substr,
+ {
+     AVCodecContext *avctx = m->avctx;
+     SubStream *s = &m->substream[substr];
+-    unsigned int i, out_ch = 0;
+-    int32_t *data_32;
+-    int16_t *data_16;
+     int ret;
+     int is32 = (m->avctx->sample_fmt == AV_SAMPLE_FMT_S32);
+
+@@ -1078,19 +1089,14 @@ static int output_data(MLPDecodeContext *m, unsigned int substr,
+     frame->nb_samples = s->blockpos;
+     if ((ret = ff_get_buffer(avctx, frame, 0)) < 0)
+         return ret;
+-    data_32 = (int32_t *)frame->data[0];
+-    data_16 = (int16_t *)frame->data[0];
+-
+-    for (i = 0; i < s->blockpos; i++) {
+-        for (out_ch = 0; out_ch <= s->max_matrix_channel; out_ch++) {
+-            int mat_ch = s->ch_assign[out_ch];
+-            int32_t sample = m->sample_buffer[i][mat_ch]
+-                          << s->output_shift[mat_ch];
+-            s->lossless_check_data ^= (sample & 0xffffff) << mat_ch;
+-            if (is32) *data_32++ = sample << 8;
+-            else      *data_16++ = sample >> 8;
+-        }
+-    }
++    s->lossless_check_data = m->dsp.mlp_pack_output(s->lossless_check_data,
++                                                    s->blockpos,
++                                                    m->sample_buffer,
++                                                    frame->data[0],
++                                                    s->ch_assign,
++                                                    s->output_shift,
++                                                    s->max_matrix_channel,
++                                                    is32);
+
+     /* Update matrix encoding side data */
+     if ((ret = ff_side_data_update_matrix_encoding(frame, s->matrix_encoding)) < 0)
+diff --git a/libavcodec/mlpdsp.c b/libavcodec/mlpdsp.c
+index 7a359b0..3ae8c37 100644
+--- a/libavcodec/mlpdsp.c
++++ b/libavcodec/mlpdsp.c
+@@ -89,10 +89,48 @@ void ff_mlp_rematrix_channel(int32_t *samples,
+     }
+ }
+
++static int32_t (*mlp_select_pack_output(uint8_t *ch_assign,
++                                        int8_t *output_shift,
++                                        uint8_t max_matrix_channel,
++                                        int is32))(int32_t, uint16_t, int32_t (*)[], void *, uint8_t*, int8_t *, uint8_t, int)
++{
++    return ff_mlp_pack_output;
++}
++
++int32_t ff_mlp_pack_output(int32_t lossless_check_data,
++                           uint16_t blockpos,
++                           int32_t (*sample_buffer)[MAX_CHANNELS],
++                           void *data,
++                           uint8_t *ch_assign,
++                           int8_t *output_shift,
++                           uint8_t max_matrix_channel,
++                           int is32)
++{
++    unsigned int i, out_ch = 0;
++    int32_t *data_32 = data;
++    int16_t *data_16 = data;
++
++    for (i = 0; i < blockpos; i++) {
++        for (out_ch = 0; out_ch <= max_matrix_channel; out_ch++) {
++            int mat_ch = ch_assign[out_ch];
++            int32_t sample = sample_buffer[i][mat_ch]
++                          << output_shift[mat_ch];
++            lossless_check_data ^= (sample & 0xffffff) << mat_ch;
++            if (is32)
++                *data_32++ = sample << 8;
++            else
++                *data_16++ = sample >> 8;
++        }
++    }
++    return lossless_check_data;
++}
++
+ av_cold void ff_mlpdsp_init(MLPDSPContext *c)
+ {
+     c->mlp_filter_channel = mlp_filter_channel;
+     c->mlp_rematrix_channel = ff_mlp_rematrix_channel;
++    c->mlp_select_pack_output = mlp_select_pack_output;
++    c->mlp_pack_output = ff_mlp_pack_output;
+     if (ARCH_ARM)
+         ff_mlpdsp_init_arm(c);
+     if (ARCH_X86)
+diff --git a/libavcodec/mlpdsp.h b/libavcodec/mlpdsp.h
+index f98e9be..a0edeb7 100644
+--- a/libavcodec/mlpdsp.h
++++ b/libavcodec/mlpdsp.h
+@@ -23,6 +23,7 @@
+ #define AVCODEC_MLPDSP_H
+
+ #include <stdint.h>
++#include "mlp.h"
+
+ void ff_mlp_rematrix_channel(int32_t *samples,
+                              const int32_t *coeffs,
+@@ -36,6 +37,15 @@ void ff_mlp_rematrix_channel(int32_t *samples,
+                              int access_unit_size_pow2,
+                              int32_t mask);
+
++int32_t ff_mlp_pack_output(int32_t lossless_check_data,
++                           uint16_t blockpos,
++                           int32_t (*sample_buffer)[MAX_CHANNELS],
++                           void *data,
++                           uint8_t *ch_assign,
++                           int8_t *output_shift,
++                           uint8_t max_matrix_channel,
++                           int is32);
++
+ typedef struct MLPDSPContext {
+     void (*mlp_filter_channel)(int32_t *state, const int32_t *coeff,
+                                int firorder, int iirorder,
+@@ -52,6 +62,18 @@ typedef struct MLPDSPContext {
+                                  int matrix_noise_shift,
+                                  int access_unit_size_pow2,
+                                  int32_t mask);
++    int32_t (*(*mlp_select_pack_output)(uint8_t *ch_assign,
++                                        int8_t *output_shift,
++                                        uint8_t max_matrix_channel,
++                                        int is32))(int32_t, uint16_t, int32_t (*)[], void *, uint8_t*, int8_t *, uint8_t, int);
++    int32_t (*mlp_pack_output)(int32_t lossless_check_data,
++                               uint16_t blockpos,
++                               int32_t (*sample_buffer)[MAX_CHANNELS],
++                               void *data,
++                               uint8_t *ch_assign,
++                               int8_t *output_shift,
++                               uint8_t max_matrix_channel,
++                               int is32);
+ } MLPDSPContext;
+
+ void ff_mlpdsp_init(MLPDSPContext *c);
+--
+1.9.1
diff --git a/tools/depends/target/ffmpeg/0006-truehd-add-hand-scheduled-ARM-asm-version-of-ff_mlp_.patch b/tools/depends/target/ffmpeg/0006-truehd-add-hand-scheduled-ARM-asm-version-of-ff_mlp_.patch
new file mode 100644
index 0000000..93add62
--- /dev/null
+++ b/tools/depends/target/ffmpeg/0006-truehd-add-hand-scheduled-ARM-asm-version-of-ff_mlp_.patch
@@ -0,0 +1,689 @@
+From c647209386bd811cc1c33b4fc8ec17a00f8c8ded Mon Sep 17 00:00:00 2001
+From: Ben Avison <bavison@riscosopen.org>
+Date: Thu, 13 Mar 2014 00:21:55 +0000
+Subject: [PATCH 6/6] truehd: add hand-scheduled ARM asm version of
+ ff_mlp_pack_output.
+
+Profiling results for overall decode and the output_data function in
+particular are as follows:
+
+              Before          After
+              Mean   StdDev   Mean   StdDev  Confidence  Change
+6:2 total     339.6  15.1     329.3  16.0    95.8%       +3.1%  (insignificant)
+6:2 function  24.6   6.0      9.9    3.1     100.0%      +148.5%
+8:2 total     324.5  15.5     323.6  14.3    15.2%       +0.3%  (insignificant)
+8:2 function  20.4   3.9      9.9    3.4     100.0%      +104.7%
+6:6 total     572.8  20.6     539.9  24.2    100.0%      +6.1%
+6:6 function  54.5   5.6      16.0   3.8     100.0%      +240.9%
+8:8 total     741.5  21.2     702.5  18.5    100.0%      +5.6%
+8:8 function  63.9   7.6      18.4   4.8     100.0%      +247.3%
+
+The assembly version has also been tested with a fuzz tester to ensure that
+any combinations of inputs not exercised by my available test streams still
+generate mathematically identical results to the C version.
+---
+ libavcodec/arm/Makefile          |   1 +
+ libavcodec/arm/mlpdsp_armv6.S    | 530 +++++++++++++++++++++++++++++++++++++++
+ libavcodec/arm/mlpdsp_init_arm.c |  96 +++++++
+ 3 files changed, 627 insertions(+)
+ create mode 100644 libavcodec/arm/mlpdsp_armv6.S
+
+diff --git a/libavcodec/arm/Makefile b/libavcodec/arm/Makefile
+index ba673b1..7b2f923 100644
+--- a/libavcodec/arm/Makefile
++++ b/libavcodec/arm/Makefile
+@@ -52,6 +52,7 @@ ARMV6-OBJS-$(CONFIG_AC3DSP)            += arm/ac3dsp_armv6.o
+ ARMV6-OBJS-$(CONFIG_H264DSP)           += arm/h264dsp_armv6.o
+ ARMV6-OBJS-$(CONFIG_HPELDSP)           += arm/hpeldsp_init_armv6.o      \
+                                           arm/hpeldsp_armv6.o
++ARMV6-OBJS-$(CONFIG_MLP_DECODER)       += arm/mlpdsp_armv6.o
+ ARMV6-OBJS-$(CONFIG_MPEGAUDIODSP)      += arm/mpegaudiodsp_fixed_armv6.o
+ ARMV6-OBJS-$(CONFIG_VP8_DECODER)       += arm/vp8_armv6.o               \
+                                           arm/vp8dsp_init_armv6.o       \
+diff --git a/libavcodec/arm/mlpdsp_armv6.S b/libavcodec/arm/mlpdsp_armv6.S
+new file mode 100644
+index 0000000..05a2c85
+--- /dev/null
++++ b/libavcodec/arm/mlpdsp_armv6.S
+@@ -0,0 +1,530 @@
++/*
++ * Copyright (c) 2014 RISC OS Open Ltd
++ * Author: Ben Avison <bavison@riscosopen.org>
++ *
++ * This file is part of FFmpeg.
++ *
++ * FFmpeg is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU Lesser General Public
++ * License as published by the Free Software Foundation; either
++ * version 2.1 of the License, or (at your option) any later version.
++ *
++ * FFmpeg is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++ * Lesser General Public License for more details.
++ *
++ * You should have received a copy of the GNU Lesser General Public
++ * License along with FFmpeg; if not, write to the Free Software
++ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
++ */
++
++#include "libavutil/arm/asm.S"
++
++.macro loadregoffsh2  group, index, base, offgroup, offindex
++       .altmacro
++       loadregoffsh2_ \group, %(\index), \base, \offgroup, %(\offindex)
++       .noaltmacro
++.endm
++
++.macro loadregoffsh2_ group, index, base, offgroup, offindex
++        ldr     \group\index, [\base, \offgroup\offindex, lsl #2]
++.endm
++
++.macro eorlslreg  check, data, group, index
++        .altmacro
++        eorlslreg_ \check, \data, \group, %(\index)
++        .noaltmacro
++.endm
++
++.macro eorlslreg_ check, data, group, index
++        eor     \check, \check, \data, lsl \group\index
++.endm
++
++.macro decr_modulo var, by, modulus
++ .set \var, \var - \by
++ .if \var == 0
++  .set \var, \modulus
++ .endif
++.endm
++
++ .macro load_group1  size, channels, r0, r1, r2, r3, pointer_dead=0
++  .if \size == 2
++        ldrd    \r0, \r1, [IN], #(\size + 8 - \channels) * 4
++  .else // size == 4
++   .if IDX1 > 4 || \channels==8
++        ldm     IN!, {\r0, \r1, \r2, \r3}
++   .else
++        ldm     IN, {\r0, \r1, \r2, \r3}
++    .if !\pointer_dead
++        add     IN, IN, #(4 + 8 - \channels) * 4
++     .endif
++   .endif
++  .endif
++        decr_modulo IDX1, \size, \channels
++ .endm
++
++ .macro load_group2  size, channels, r0, r1, r2, r3, pointer_dead=0
++  .if \size == 2
++   .if IDX1 > 2
++        ldm     IN!, {\r2, \r3}
++   .else
++//A   .ifc \r2, ip
++//A    .if \pointer_dead
++//A       ldm     IN, {\r2, \r3}
++//A    .else
++//A       ldr     \r2, [IN], #4
++//A       ldr     \r3, [IN], #(\size - 1 + 8 - \channels) * 4
++//A    .endif
++//A   .else
++        ldrd    \r2, \r3, [IN], #(\size + 8 - \channels) * 4
++//A   .endif
++   .endif
++  .endif
++        decr_modulo IDX1, \size, \channels
++ .endm
++
++.macro implement_pack  inorder, channels, shift
++.if \inorder
++.ifc \shift, mixed
++
++CHECK   .req    a1
++COUNT   .req    a2
++IN      .req    a3
++OUT     .req    a4
++DAT0    .req    v1
++DAT1    .req    v2
++DAT2    .req    v3
++DAT3    .req    v4
++SHIFT0  .req    v5
++SHIFT1  .req    v6
++SHIFT2  .req    sl
++SHIFT3  .req    fp
++SHIFT4  .req    ip
++SHIFT5  .req    lr
++
++ .macro output4words
++  .set SIZE_GROUP1, IDX1
++  .if SIZE_GROUP1 > 4
++   .set SIZE_GROUP1, 4
++  .endif
++  .set SIZE_GROUP2, 4 - SIZE_GROUP1
++        load_group1  SIZE_GROUP1, \channels, DAT0, DAT1, DAT2, DAT3
++        load_group2  SIZE_GROUP2, \channels, DAT0, DAT1, DAT2, DAT3
++   .if \channels == 2
++        lsl     DAT0, SHIFT0
++        lsl     DAT1, SHIFT1
++        lsl     DAT2, SHIFT0
++        lsl     DAT3, SHIFT1
++   .elseif \channels == 6
++    .if IDX2 == 6
++        lsl     DAT0, SHIFT0
++        lsl     DAT1, SHIFT1
++        lsl     DAT2, SHIFT2
++        lsl     DAT3, SHIFT3
++    .elseif IDX2 == 2
++        lsl     DAT0, SHIFT4
++        lsl     DAT1, SHIFT5
++        lsl     DAT2, SHIFT0
++        lsl     DAT3, SHIFT1
++    .else // IDX2 == 4
++        lsl     DAT0, SHIFT2
++        lsl     DAT1, SHIFT3
++        lsl     DAT2, SHIFT4
++        lsl     DAT3, SHIFT5
++    .endif
++   .elseif \channels == 8
++    .if IDX2 == 8
++        uxtb    SHIFT0, SHIFT4, ror #0
++        uxtb    SHIFT1, SHIFT4, ror #8
++        uxtb    SHIFT2, SHIFT4, ror #16
++        uxtb    SHIFT3, SHIFT4, ror #24
++    .else
++        uxtb    SHIFT0, SHIFT5, ror #0
++        uxtb    SHIFT1, SHIFT5, ror #8
++        uxtb    SHIFT2, SHIFT5, ror #16
++        uxtb    SHIFT3, SHIFT5, ror #24
++    .endif
++        lsl     DAT0, SHIFT0
++        lsl     DAT1, SHIFT1
++        lsl     DAT2, SHIFT2
++        lsl     DAT3, SHIFT3
++   .endif
++        eor     CHECK, CHECK, DAT0, lsr #8 - (\channels - IDX2)
++        eor     CHECK, CHECK, DAT1, lsr #7 - (\channels - IDX2)
++   decr_modulo IDX2, 2, \channels
++        eor     CHECK, CHECK, DAT2, lsr #8 - (\channels - IDX2)
++        eor     CHECK, CHECK, DAT3, lsr #7 - (\channels - IDX2)
++   decr_modulo IDX2, 2, \channels
++        stm     OUT!, {DAT0 - DAT3}
++ .endm
++
++ .set WORDS_PER_LOOP, \channels  // calculate LCM (channels, 4)
++ .if (WORDS_PER_LOOP % 2) == 0
++  .set WORDS_PER_LOOP, WORDS_PER_LOOP / 2
++ .endif
++ .if (WORDS_PER_LOOP % 2) == 0
++  .set WORDS_PER_LOOP, WORDS_PER_LOOP / 2
++ .endif
++ .set WORDS_PER_LOOP, WORDS_PER_LOOP * 4
++ .set SAMPLES_PER_LOOP, WORDS_PER_LOOP / \channels
++
++function ff_mlp_pack_output_inorder_\channels\()ch_mixedshift_armv6, export=1
++ .if SAMPLES_PER_LOOP > 1
++        tst     COUNT, #SAMPLES_PER_LOOP - 1  // always seems to be in practice
++        bne     X(ff_mlp_pack_output)         // but just in case, branch to C implementation if not
++ .endif
++        teq     COUNT, #0
++        it      eq
++        bxeq    lr
++        push    {v1-v6,sl,fp,lr}
++        ldr     SHIFT0, [sp, #(9+1)*4]  // get output_shift from stack
++        ldr     SHIFT1, =0x08080808
++        ldr     SHIFT4, [SHIFT0]
++ .if \channels == 2
++        uadd8   SHIFT4, SHIFT4, SHIFT1 // increase all shifts by 8
++        uxtb    SHIFT0, SHIFT4, ror #0
++        uxtb    SHIFT1, SHIFT4, ror #8
++ .else
++        ldr     SHIFT5, [SHIFT0, #4]
++        uadd8   SHIFT4, SHIFT4, SHIFT1 // increase all shifts by 8
++        uadd8   SHIFT5, SHIFT5, SHIFT1
++  .if \channels == 6
++        uxtb    SHIFT0, SHIFT4, ror #0
++        uxtb    SHIFT1, SHIFT4, ror #8
++        uxtb    SHIFT2, SHIFT4, ror #16
++        uxtb    SHIFT3, SHIFT4, ror #24
++        uxtb    SHIFT4, SHIFT5, ror #0
++        uxtb    SHIFT5, SHIFT5, ror #8
++  .endif
++ .endif
++ .set IDX1, \channels
++ .set IDX2, \channels
++0:
++ .rept WORDS_PER_LOOP / 4
++        output4words
++ .endr
++        subs    COUNT, COUNT, #SAMPLES_PER_LOOP
++        bne     0b
++        pop     {v1-v6,sl,fp,pc}
++        .ltorg
++endfunc
++ .purgem output4words
++
++        .unreq  CHECK
++        .unreq  COUNT
++        .unreq  IN
++        .unreq  OUT
++        .unreq  DAT0
++        .unreq  DAT1
++        .unreq  DAT2
++        .unreq  DAT3
++        .unreq  SHIFT0
++        .unreq  SHIFT1
++        .unreq  SHIFT2
++        .unreq  SHIFT3
++        .unreq  SHIFT4
++        .unreq  SHIFT5
++
++.else // not mixed
++
++CHECK   .req    a1
++COUNT   .req    a2
++IN      .req    a3
++OUT     .req    a4
++DAT0    .req    v1
++DAT1    .req    v2
++DAT2    .req    v3
++DAT3    .req    v4
++DAT4    .req    v5
++DAT5    .req    v6
++DAT6    .req    sl // use these rather than the otherwise unused
++DAT7    .req    fp // ip and lr so that we can load them usinf LDRD
++
++ .macro output4words  tail, head, r0, r1, r2, r3, r4, r5, r6, r7, pointer_dead=0
++  .if \head
++   .set SIZE_GROUP1, IDX1
++   .if SIZE_GROUP1 > 4
++    .set SIZE_GROUP1, 4
++   .endif
++   .set SIZE_GROUP2, 4 - SIZE_GROUP1
++        load_group1  SIZE_GROUP1, \channels, \r0, \r1, \r2, \r3, \pointer_dead
++  .endif
++  .if \tail
++        eor     CHECK, CHECK, \r4, lsr #8 - (\channels - IDX2)
++        eor     CHECK, CHECK, \r5, lsr #7 - (\channels - IDX2)
++   decr_modulo IDX2, 2, \channels
++  .endif
++  .if \head
++        load_group2  SIZE_GROUP2, \channels, \r0, \r1, \r2, \r3, \pointer_dead
++  .endif
++  .if \tail
++        eor     CHECK, CHECK, \r6, lsr #8 - (\channels - IDX2)
++        eor     CHECK, CHECK, \r7, lsr #7 - (\channels - IDX2)
++   decr_modulo IDX2, 2, \channels
++        stm     OUT!, {\r4, \r5, \r6, \r7}
++  .endif
++  .if \head
++        lsl     \r0, #8 + \shift
++        lsl     \r1, #8 + \shift
++        lsl     \r2, #8 + \shift
++        lsl     \r3, #8 + \shift
++  .endif
++ .endm
++
++ .set WORDS_PER_LOOP, \channels  // calculate LCM (channels, 8)
++ .if (WORDS_PER_LOOP % 2) == 0
++  .set WORDS_PER_LOOP, WORDS_PER_LOOP / 2
++ .endif
++ .if (WORDS_PER_LOOP % 2) == 0
++  .set WORDS_PER_LOOP, WORDS_PER_LOOP / 2
++ .endif
++ .if (WORDS_PER_LOOP % 2) == 0
++  .set WORDS_PER_LOOP, WORDS_PER_LOOP / 2
++ .endif
++ .set WORDS_PER_LOOP, WORDS_PER_LOOP * 8
++ .set SAMPLES_PER_LOOP, WORDS_PER_LOOP / \channels
++
++function ff_mlp_pack_output_inorder_\channels\()ch_\shift\()shift_armv6, export=1
++ .if SAMPLES_PER_LOOP > 1
++        tst     COUNT, #SAMPLES_PER_LOOP - 1  // always seems to be in practice
++        bne     X(ff_mlp_pack_output)         // but just in case, branch to C implementation if not
++ .endif
++        subs    COUNT, COUNT, #SAMPLES_PER_LOOP
++        it      lo
++        bxlo    lr
++        push    {v1-v6,sl,fp,lr}
++ .set IDX1, \channels
++ .set IDX2, \channels
++        output4words  0, 1, DAT0, DAT1, DAT2, DAT3, DAT4, DAT5, DAT6, DAT7
++0:      beq     1f
++ .rept WORDS_PER_LOOP / 8
++        output4words  1, 1, DAT4, DAT5, DAT6, DAT7, DAT0, DAT1, DAT2, DAT3
++        output4words  1, 1, DAT0, DAT1, DAT2, DAT3, DAT4, DAT5, DAT6, DAT7
++ .endr
++        subs    COUNT, COUNT, #SAMPLES_PER_LOOP
++        bne     0b
++1:
++ .rept WORDS_PER_LOOP / 8 - 1
++        output4words  1, 1, DAT4, DAT5, DAT6, DAT7, DAT0, DAT1, DAT2, DAT3
++        output4words  1, 1, DAT0, DAT1, DAT2, DAT3, DAT4, DAT5, DAT6, DAT7
++ .endr
++        output4words  1, 1, DAT4, DAT5, DAT6, DAT7, DAT0, DAT1, DAT2, DAT3, pointer_dead=1
++        output4words  1, 0, DAT0, DAT1, DAT2, DAT3, DAT4, DAT5, DAT6, DAT7
++        pop     {v1-v6,sl,fp,pc}
++endfunc
++ .purgem output4words
++
++        .unreq  CHECK
++        .unreq  COUNT
++        .unreq  IN
++        .unreq  OUT
++        .unreq  DAT0
++        .unreq  DAT1
++        .unreq  DAT2
++        .unreq  DAT3
++        .unreq  DAT4
++        .unreq  DAT5
++        .unreq  DAT6
++        .unreq  DAT7
++
++.endif // mixed
++.else // not inorder
++.ifc \shift, mixed
++
++// This case not currently handled
++
++.else // not mixed
++
++#if !CONFIG_THUMB
++
++CHECK   .req    a1
++COUNT   .req    a2
++IN      .req    a3
++OUT     .req    a4
++DAT0    .req    v1
++DAT1    .req    v2
++DAT2    .req    v3
++DAT3    .req    v4
++CHAN0   .req    v5
++CHAN1   .req    v6
++CHAN2   .req    sl
++CHAN3   .req    fp
++CHAN4   .req    ip
++CHAN5   .req    lr
++
++ .macro output4words
++  .if \channels == 8
++   .if IDX1 == 8
++        uxtb    CHAN0, CHAN4, ror #0
++        uxtb    CHAN1, CHAN4, ror #8
++        uxtb    CHAN2, CHAN4, ror #16
++        uxtb    CHAN3, CHAN4, ror #24
++   .else
++        uxtb    CHAN0, CHAN5, ror #0
++        uxtb    CHAN1, CHAN5, ror #8
++        uxtb    CHAN2, CHAN5, ror #16
++        uxtb    CHAN3, CHAN5, ror #24
++   .endif
++        ldr     DAT0, [IN, CHAN0, lsl #2]
++        ldr     DAT1, [IN, CHAN1, lsl #2]
++        ldr     DAT2, [IN, CHAN2, lsl #2]
++        ldr     DAT3, [IN, CHAN3, lsl #2]
++   .if IDX1 == 4
++        add     IN, IN, #8*4
++   .endif
++        decr_modulo IDX1, 4, \channels
++  .else
++   .set SIZE_GROUP1, IDX1
++   .if SIZE_GROUP1 > 4
++    .set SIZE_GROUP1, 4
++   .endif
++   .set SIZE_GROUP2, 4 - SIZE_GROUP1
++   .if SIZE_GROUP1 == 2
++        loadregoffsh2  DAT, 0, IN, CHAN, 0 + (\channels - IDX1)
++        loadregoffsh2  DAT, 1, IN, CHAN, 1 + (\channels - IDX1)
++        add     IN, IN, #8*4
++   .else // SIZE_GROUP1 == 4
++        loadregoffsh2  DAT, 0, IN, CHAN, 0 + (\channels - IDX1)
++        loadregoffsh2  DAT, 1, IN, CHAN, 1 + (\channels - IDX1)
++        loadregoffsh2  DAT, 2, IN, CHAN, 2 + (\channels - IDX1)
++        loadregoffsh2  DAT, 3, IN, CHAN, 3 + (\channels - IDX1)
++    .if IDX1 == 4
++        add     IN, IN, #8*4
++    .endif
++   .endif
++        decr_modulo IDX1, SIZE_GROUP1, \channels
++   .if SIZE_GROUP2 == 2
++        loadregoffsh2  DAT, 2, IN, CHAN, 0 + (\channels - IDX1)
++        loadregoffsh2  DAT, 3, IN, CHAN, 1 + (\channels - IDX1)
++    .if IDX1 == 2
++        add     IN, IN, #8*4
++    .endif
++   .endif
++        decr_modulo IDX1, SIZE_GROUP2, \channels
++  .endif
++  .if \channels == 8 // in this case we can corrupt CHAN0-3
++        rsb     CHAN0, CHAN0, #8
++        rsb     CHAN1, CHAN1, #8
++        rsb     CHAN2, CHAN2, #8
++        rsb     CHAN3, CHAN3, #8
++        lsl     DAT0, #8 + \shift
++        lsl     DAT1, #8 + \shift
++        lsl     DAT2, #8 + \shift
++        lsl     DAT3, #8 + \shift
++        eor     CHECK, CHECK, DAT0, lsr CHAN0
++        eor     CHECK, CHECK, DAT1, lsr CHAN1
++        eor     CHECK, CHECK, DAT2, lsr CHAN2
++        eor     CHECK, CHECK, DAT3, lsr CHAN3
++  .else
++   .if \shift != 0
++        lsl     DAT0, #\shift
++        lsl     DAT1, #\shift
++        lsl     DAT2, #\shift
++        lsl     DAT3, #\shift
++   .endif
++        bic     DAT0, DAT0, #0xff000000
++        bic     DAT1, DAT1, #0xff000000
++        bic     DAT2, DAT2, #0xff000000
++        bic     DAT3, DAT3, #0xff000000
++        eorlslreg CHECK, DAT0, CHAN, 0 + (\channels - IDX2)
++        eorlslreg CHECK, DAT1, CHAN, 1 + (\channels - IDX2)
++   decr_modulo IDX2, 2, \channels
++        eorlslreg CHECK, DAT2, CHAN, 0 + (\channels - IDX2)
++        eorlslreg CHECK, DAT3, CHAN, 1 + (\channels - IDX2)
++   decr_modulo IDX2, 2, \channels
++        lsl     DAT0, #8
++        lsl     DAT1, #8
++        lsl     DAT2, #8
++        lsl     DAT3, #8
++  .endif
++        stm     OUT!, {DAT0 - DAT3}
++ .endm
++
++ .set WORDS_PER_LOOP, \channels  // calculate LCM (channels, 4)
++ .if (WORDS_PER_LOOP % 2) == 0
++  .set WORDS_PER_LOOP, WORDS_PER_LOOP / 2
++ .endif
++ .if (WORDS_PER_LOOP % 2) == 0
++  .set WORDS_PER_LOOP, WORDS_PER_LOOP / 2
++ .endif
++ .set WORDS_PER_LOOP, WORDS_PER_LOOP * 4
++ .set SAMPLES_PER_LOOP, WORDS_PER_LOOP / \channels
++
++function ff_mlp_pack_output_outoforder_\channels\()ch_\shift\()shift_armv6, export=1
++ .if SAMPLES_PER_LOOP > 1
++        tst     COUNT, #SAMPLES_PER_LOOP - 1  // always seems to be in practice
++        bne     X(ff_mlp_pack_output)         // but just in case, branch to C implementation if not
++ .endif
++        teq     COUNT, #0
++        it      eq
++        bxeq    lr
++        push    {v1-v6,sl,fp,lr}
++        ldr     CHAN0, [sp, #(9+0)*4]  // get ch_assign from stack
++        ldr     CHAN4, [CHAN0]
++ .if \channels == 2
++        uxtb    CHAN0, CHAN4, ror #0
++        uxtb    CHAN1, CHAN4, ror #8
++ .else
++        ldr     CHAN5, [CHAN0, #4]
++  .if \channels == 6
++        uxtb    CHAN0, CHAN4, ror #0
++        uxtb    CHAN1, CHAN4, ror #8
++        uxtb    CHAN2, CHAN4, ror #16
++        uxtb    CHAN3, CHAN4, ror #24
++        uxtb    CHAN4, CHAN5, ror #0
++        uxtb    CHAN5, CHAN5, ror #8
++  .endif
++ .endif
++ .set IDX1, \channels
++ .set IDX2, \channels
++0:
++ .rept WORDS_PER_LOOP / 4
++        output4words
++ .endr
++        subs    COUNT, COUNT, #SAMPLES_PER_LOOP
++        bne     0b
++        pop     {v1-v6,sl,fp,pc}
++        .ltorg
++endfunc
++ .purgem output4words
++
++        .unreq  CHECK
++        .unreq  COUNT
++        .unreq  IN
++        .unreq  OUT
++        .unreq  DAT0
++        .unreq  DAT1
++        .unreq  DAT2
++        .unreq  DAT3
++        .unreq  CHAN0
++        .unreq  CHAN1
++        .unreq  CHAN2
++        .unreq  CHAN3
++        .unreq  CHAN4
++        .unreq  CHAN5
++
++#endif // !CONFIG_THUMB
++
++.endif // mixed
++.endif // inorder
++.endm // implement_pack
++
++.macro pack_channels  inorder, channels
++        implement_pack  \inorder, \channels, 0
++        implement_pack  \inorder, \channels, 1
++        implement_pack  \inorder, \channels, 2
++        implement_pack  \inorder, \channels, 3
++        implement_pack  \inorder, \channels, 4
++        implement_pack  \inorder, \channels, 5
++        implement_pack  \inorder, \channels, mixed
++.endm
++
++.macro pack_order  inorder
++        pack_channels  \inorder, 2
++        pack_channels  \inorder, 6
++        pack_channels  \inorder, 8
++.endm
++
++        pack_order  0
++        pack_order  1
+diff --git a/libavcodec/arm/mlpdsp_init_arm.c b/libavcodec/arm/mlpdsp_init_arm.c
+index 1bb2276..10ec316 100644
+--- a/libavcodec/arm/mlpdsp_init_arm.c
++++ b/libavcodec/arm/mlpdsp_init_arm.c
+@@ -41,8 +41,104 @@ void ff_mlp_rematrix_channel_arm(int32_t *samples,
+                                  int access_unit_size_pow2,
+                                  int32_t mask);
+
++#define DECLARE_PACK(order,channels,shift) \
++    int32_t ff_mlp_pack_output_##order##order_##channels##ch_##shift##shift_armv6(int32_t, uint16_t, int32_t (*)[], void *, uint8_t*, int8_t *, uint8_t, int);
++#define ENUMERATE_PACK(order,channels,shift) \
++    ff_mlp_pack_output_##order##order_##channels##ch_##shift##shift_armv6,
++#define PACK_CHANNELS(macro,order,channels) \
++        macro(order,channels,0) \
++        macro(order,channels,1) \
++        macro(order,channels,2) \
++        macro(order,channels,3) \
++        macro(order,channels,4) \
++        macro(order,channels,5) \
++        macro(order,channels,mixed)
++#define PACK_ORDER(macro,order) \
++        PACK_CHANNELS(macro,order,2) \
++        PACK_CHANNELS(macro,order,6) \
++        PACK_CHANNELS(macro,order,8)
++#define PACK_ALL(macro) \
++        PACK_ORDER(macro,outof) \
++        PACK_ORDER(macro,in)
++PACK_ALL(DECLARE_PACK)
++
++#define ff_mlp_pack_output_outoforder_2ch_mixedshift_armv6 0
++#define ff_mlp_pack_output_outoforder_6ch_mixedshift_armv6 0
++#define ff_mlp_pack_output_outoforder_8ch_mixedshift_armv6 0
++#if CONFIG_THUMB
++#define ff_mlp_pack_output_outoforder_2ch_0shift_armv6 0
++#define ff_mlp_pack_output_outoforder_2ch_1shift_armv6 0
++#define ff_mlp_pack_output_outoforder_2ch_2shift_armv6 0
++#define ff_mlp_pack_output_outoforder_2ch_3shift_armv6 0
++#define ff_mlp_pack_output_outoforder_2ch_4shift_armv6 0
++#define ff_mlp_pack_output_outoforder_2ch_5shift_armv6 0
++#define ff_mlp_pack_output_outoforder_6ch_0shift_armv6 0
++#define ff_mlp_pack_output_outoforder_6ch_1shift_armv6 0
++#define ff_mlp_pack_output_outoforder_6ch_2shift_armv6 0
++#define ff_mlp_pack_output_outoforder_6ch_3shift_armv6 0
++#define ff_mlp_pack_output_outoforder_6ch_4shift_armv6 0
++#define ff_mlp_pack_output_outoforder_6ch_5shift_armv6 0
++#define ff_mlp_pack_output_outoforder_8ch_0shift_armv6 0
++#define ff_mlp_pack_output_outoforder_8ch_1shift_armv6 0
++#define ff_mlp_pack_output_outoforder_8ch_2shift_armv6 0
++#define ff_mlp_pack_output_outoforder_8ch_3shift_armv6 0
++#define ff_mlp_pack_output_outoforder_8ch_4shift_armv6 0
++#define ff_mlp_pack_output_outoforder_8ch_5shift_armv6 0
++#endif
++
++static int32_t (*mlp_select_pack_output_armv6(uint8_t *ch_assign,
++                                              int8_t *output_shift,
++                                              uint8_t max_matrix_channel,
++                                              int is32))(int32_t, uint16_t, int32_t (*)[], void *, uint8_t*, int8_t *, uint8_t, int)
++{
++    int ch_index;
++    int shift = output_shift[0] < 0 || output_shift[0] > 5 ? 6 : output_shift[0];
++    int inorder = 1;
++    static int32_t (*const routine[2*3*7])(int32_t, uint16_t, int32_t (*)[], void *, uint8_t*, int8_t *, uint8_t, int) = {
++            PACK_ALL(ENUMERATE_PACK)
++    };
++    int i;
++
++    if (!is32) // don't support 16-bit output (it's not used by TrueHD)
++        return ff_mlp_pack_output;
++
++    switch (max_matrix_channel) {
++    case 1:
++        ch_index = 0;
++        break;
++    case 5:
++        ch_index = 1;
++        break;
++    case 7:
++        ch_index = 2;
++        break;
++    default:
++        return ff_mlp_pack_output;
++    }
++
++    for (i = 0; i <= max_matrix_channel; i++) {
++        if (shift != 6 && output_shift[i] != shift)
++            shift = 6; // indicate mixed shifts
++        if (ch_assign[i] != i)
++            inorder = 0;
++    }
++#if CONFIG_THUMB
++    if (!inorder)
++        return ff_mlp_pack_output; // can't currently handle an order array except in ARM mode
++#else
++    if (shift == 6 && !inorder)
++        return ff_mlp_pack_output; // can't currently handle both an order array and a shift array
++#endif
++
++    return routine[(inorder*3+ch_index)*7+shift];
++}
++
+ av_cold void ff_mlpdsp_init_arm(MLPDSPContext *c)
+ {
++    int cpu_flags = av_get_cpu_flags();
++
+     c->mlp_filter_channel = ff_mlp_filter_channel_arm;
+     c->mlp_rematrix_channel = ff_mlp_rematrix_channel_arm;
++    if (cpu_flags & AV_CPU_FLAG_ARMV6)
++        c->mlp_select_pack_output = mlp_select_pack_output_armv6;
+ }
+--
+1.9.1
diff --git a/tools/depends/target/ffmpeg/Makefile b/tools/depends/target/ffmpeg/Makefile
index 863ee41..b56fbdd 100644
--- a/tools/depends/target/ffmpeg/Makefile
+++ b/tools/depends/target/ffmpeg/Makefile
@@ -2,8 +2,10 @@ include ../../Makefile.include
 include FFMPEG-VERSION
 DEPS= ../../Makefile.include FFMPEG-VERSION Makefile \
       ffmpeg_Speed_up_wtv_index_creation.patch 0001-h264-Move-search-code-search-functions-into-separate.patch \
-      0002-vc-1-Add-platform-specific-start-code-search-routine.patch 0003-vc-1-Optimise-parser-with-special-attention-to-ARM.patch
-
+      0002-vc-1-Add-platform-specific-start-code-search-routine.patch 0003-vc-1-Optimise-parser-with-special-attention-to-ARM.patch    \
+      0001-truehd-tune-VLC-decoding-for-ARM.patch                     0002-truehd-add-hand-scheduled-ARM-asm-version-of-mlp_fil.patch  \
+      0003-truehd-break-out-part-of-rematrix_channels-into-plat.patch 0004-truehd-add-hand-scheduled-ARM-asm-version-of-ff_mlp_.patch  \
+      0005-truehd-break-out-part-of-output_data-into-platform-s.patch 0006-truehd-add-hand-scheduled-ARM-asm-version-of-ff_mlp_.patch
 
 # set to "yes" to enable patching
 # we don't apply patches until we move to a vanilla ffmpeg tarball
@@ -70,6 +72,13 @@ $(PLATFORM): $(TARBALLS_LOCATION)/$(ARCHIVE) $(DEPS)
 	cd $(PLATFORM); patch -p1 < ../0001-h264-Move-search-code-search-functions-into-separate.patch
 	cd $(PLATFORM); patch -p1 < ../0002-vc-1-Add-platform-specific-start-code-search-routine.patch
 	cd $(PLATFORM); patch -p1 < ../0003-vc-1-Optimise-parser-with-special-attention-to-ARM.patch
+	cd $(PLATFORM); patch -p1 < ../0001-truehd-tune-VLC-decoding-for-ARM.patch
+	cd $(PLATFORM); patch -p1 < ../0002-truehd-add-hand-scheduled-ARM-asm-version-of-mlp_fil.patch
+	cd $(PLATFORM); patch -p1 < ../0003-truehd-break-out-part-of-rematrix_channels-into-plat.patch
+	cd $(PLATFORM); patch -p1 < ../0004-truehd-add-hand-scheduled-ARM-asm-version-of-ff_mlp_.patch
+	cd $(PLATFORM); patch -p1 < ../0005-truehd-break-out-part-of-output_data-into-platform-s.patch
+	cd $(PLATFORM); patch -p1 < ../0006-truehd-add-hand-scheduled-ARM-asm-version-of-ff_mlp_.patch
+
 	cd $(PLATFORM);\
 	CFLAGS="$(CFLAGS)" CXXFLAGS="$(CXXFLAGS)" CPPFLAGS="$(CPPFLAGS)" LDFLAGS="$(LDFLAGS)" \
 	./configure $(ffmpg_config)
-- 
1.9.3


From cdb3f7900819d86cff4baa2dcd3867cb7f4d823e Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Sun, 11 May 2014 16:13:45 +0100
Subject: [PATCH 063/102] [rbp] Add config.txt settings to log file

---
 xbmc/linux/RBP.cpp | 8 +++++++-
 1 file changed, 7 insertions(+), 1 deletion(-)

diff --git a/xbmc/linux/RBP.cpp b/xbmc/linux/RBP.cpp
index 49dcbb8..9a5e9cb 100644
--- a/xbmc/linux/RBP.cpp
+++ b/xbmc/linux/RBP.cpp
@@ -79,11 +79,17 @@ bool CRBP::Initialize()
 
 void CRBP::LogFirmwareVerison()
 {
-  char  response[160];
+  char  response[1024];
   m_DllBcmHost->vc_gencmd(response, sizeof response, "version");
   response[sizeof(response) - 1] = '\0';
   CLog::Log(LOGNOTICE, "Raspberry PI firmware version: %s", response);
   CLog::Log(LOGNOTICE, "ARM mem: %dMB GPU mem: %dMB MPG2:%d WVC1:%d", m_arm_mem, m_gpu_mem, m_codec_mpg2_enabled, m_codec_wvc1_enabled);
+  m_DllBcmHost->vc_gencmd(response, sizeof response, "get_config int");
+  response[sizeof(response) - 1] = '\0';
+  CLog::Log(LOGNOTICE, "Config:\n%s", response);
+  m_DllBcmHost->vc_gencmd(response, sizeof response, "get_config str");
+  response[sizeof(response) - 1] = '\0';
+  CLog::Log(LOGNOTICE, "Config:\n%s", response);
 }
 
 void CRBP::GetDisplaySize(int &width, int &height)
-- 
1.9.3


From 21731d0cbe70622a6510bc6feda029d1615db981 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Mon, 12 May 2014 23:06:43 +0100
Subject: [PATCH 064/102] [omxcodec] Updates to work better with dropping and
 lateness detection

---
 .../DVDCodecs/Video/DVDVideoCodecOpenMax.cpp       |  5 ++
 .../DVDCodecs/Video/DVDVideoCodecOpenMax.h         |  1 +
 .../dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp     | 97 +++++++++++++++++-----
 .../cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.h |  9 +-
 4 files changed, 86 insertions(+), 26 deletions(-)

diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecOpenMax.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecOpenMax.cpp
index ef10555..8323497 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecOpenMax.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecOpenMax.cpp
@@ -91,4 +91,9 @@ bool CDVDVideoCodecOpenMax::ClearPicture(DVDVideoPicture* pDvdVideoPicture)
   return m_omx_decoder->ClearPicture(pDvdVideoPicture);
 }
 
+bool CDVDVideoCodecOpenMax::GetCodecStats(double &pts, int &droppedPics)
+{
+  return m_omx_decoder->GetCodecStats(pts, droppedPics);
+}
+
 #endif
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecOpenMax.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecOpenMax.h
index b7c0c1b..4f243df 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecOpenMax.h
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecOpenMax.h
@@ -41,6 +41,7 @@ class CDVDVideoCodecOpenMax : public CDVDVideoCodec
   virtual unsigned GetAllowedReferences();
   virtual void SetDropState(bool bDrop);
   virtual const char* GetName(void);
+  virtual bool GetCodecStats(double &pts, int &droppedPics);
   
 protected:
   OpenMaxVideoPtr m_omx_decoder;
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp
index 71d19af..612ae21 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp
@@ -37,6 +37,7 @@
 #include "ApplicationMessenger.h"
 #include "Application.h"
 #include "threads/Atomics.h"
+#include "guilib/GUIWindowManager.h"
 
 #include <IL/OMX_Core.h>
 #include <IL/OMX_Component.h>
@@ -57,6 +58,7 @@
 
 #define OMX_BUFFERFLAG_PTS_INVALID (1<<28)
 #define OMX_BUFFERFLAG_DROPPED     (1<<29)
+#define OMX_BUFFERFLAG_FIRST_FIELD (1<<30)
 
 COpenMaxVideoBuffer::COpenMaxVideoBuffer(COpenMaxVideo *omv)
     : m_omv(omv), m_refs(0)
@@ -139,8 +141,11 @@ COpenMaxVideo::COpenMaxVideo()
 
   m_deinterlace = false;
   m_deinterlace_request = VS_DEINTERLACEMODE_OFF;
-  m_deinterlace_second_field = false;
   m_startframe = false;
+  m_decoderPts = DVD_NOPTS_VALUE;
+  m_droppedPics = 0;
+  m_decode_frame_number = 1;
+  m_skipDeinterlaceFields = false;
 }
 
 COpenMaxVideo::~COpenMaxVideo()
@@ -369,7 +374,10 @@ void COpenMaxVideo::Dispose()
   m_finished = true;
   pthread_mutex_unlock(&m_omx_output_mutex);
   if (done)
+  {
+    assert(m_dts_queue.empty());
     m_myself.reset();
+  }
 }
 
 void COpenMaxVideo::SetDropState(bool bDrop)
@@ -730,6 +738,7 @@ int COpenMaxVideo::Decode(uint8_t* pData, int iSize, double dts, double pts)
       omx_buffer->nFilledLen = (demuxer_bytes > omx_buffer->nAllocLen) ? omx_buffer->nAllocLen : demuxer_bytes;
       omx_buffer->nTimeStamp = ToOMXTime((uint64_t)(pts == DVD_NOPTS_VALUE) ? 0 : pts);
       omx_buffer->pAppPrivate = omx_buffer;
+      omx_buffer->pMarkData = (OMX_PTR)m_decode_frame_number;
       memcpy(omx_buffer->pBuffer, demuxer_content, omx_buffer->nFilledLen);
 
       demuxer_bytes -= omx_buffer->nFilledLen;
@@ -742,12 +751,18 @@ int COpenMaxVideo::Decode(uint8_t* pData, int iSize, double dts, double pts)
         omx_buffer->nFlags |= OMX_BUFFERFLAG_TIME_UNKNOWN;
       if (pts == DVD_NOPTS_VALUE) // hijack an omx flag to indicate there wasn't a real timestamp - it will be returned with the picture (but otherwise ignored)
         omx_buffer->nFlags |= OMX_BUFFERFLAG_PTS_INVALID;
-      if (m_drop_state) // hijack an omx flag to signal this frame to be dropped - it will be returned with the picture (but otherwise ignored)
+      if (m_drop_state)
+      {
+        // hijack an omx flag to signal this frame to be dropped - it will be returned with the picture (but otherwise ignored)
         omx_buffer->nFlags |= OMX_BUFFERFLAG_DECODEONLY | OMX_BUFFERFLAG_DROPPED;
+        m_droppedPics += m_deinterlace ? 2:1;
+      }
+      // always set this flag on input. It won't be set on second field of interlaced video.
+      omx_buffer->nFlags |= OMX_BUFFERFLAG_FIRST_FIELD;
 
 #if defined(OMX_DEBUG_VERBOSE)
-      CLog::Log(LOGDEBUG, "%s::%s - %-6d dts:%.3f pts:%.3f flags:%x",
-        CLASSNAME, __func__, omx_buffer->nFilledLen, dts == DVD_NOPTS_VALUE ? 0.0 : dts*1e-6, pts == DVD_NOPTS_VALUE ? 0.0 : pts*1e-6, omx_buffer->nFlags);
+      CLog::Log(LOGDEBUG, "%s::%s - %-6d dts:%.3f pts:%.3f flags:%x frame:%d",
+        CLASSNAME, __func__, omx_buffer->nFilledLen, dts == DVD_NOPTS_VALUE ? 0.0 : dts*1e-6, pts == DVD_NOPTS_VALUE ? 0.0 : pts*1e-6, omx_buffer->nFlags, (int)omx_buffer->pMarkData);
 #endif
 
       omx_err = m_omx_decoder.EmptyThisBuffer(omx_buffer);
@@ -758,13 +773,16 @@ int COpenMaxVideo::Decode(uint8_t* pData, int iSize, double dts, double pts)
       }
       if (demuxer_bytes == 0)
       {
+        m_decode_frame_number++;
         m_startframe = true;
 #ifdef DTS_QUEUE
         if (!m_drop_state)
         {
           // only push if we are successful with feeding OMX_EmptyThisBuffer
+          pthread_mutex_lock(&m_omx_output_mutex);
           m_dts_queue.push(dts);
           assert(m_dts_queue.size() < 32);
+          pthread_mutex_unlock(&m_omx_output_mutex);
         }
 #endif
         if (buffer_to_free)
@@ -840,13 +858,18 @@ void COpenMaxVideo::Reset(void)
   SetDropState(true);
   SetDropState(false);
 #ifdef DTS_QUEUE
+  pthread_mutex_lock(&m_omx_output_mutex);
   while (!m_dts_queue.empty())
     m_dts_queue.pop();
+  pthread_mutex_unlock(&m_omx_output_mutex);
 #endif
 
   while (!m_demux_queue.empty())
     m_demux_queue.pop();
   m_startframe = false;
+  m_decoderPts = DVD_NOPTS_VALUE;
+  m_droppedPics = 0;
+  m_decode_frame_number = 1;
 }
 
 
@@ -928,26 +951,17 @@ bool COpenMaxVideo::GetPicture(DVDVideoPicture* pDvdVideoPicture)
       }
     }
 
-#ifdef DTS_QUEUE
-    if (!m_deinterlace_second_field)
-    {
-      assert(!m_dts_queue.empty());
-      pDvdVideoPicture->dts = m_dts_queue.front();
-      m_dts_queue.pop();
-    }
-    if (m_deinterlace)
-      m_deinterlace_second_field = !m_deinterlace_second_field;
-#endif
     // nTimeStamp is in microseconds
+    pDvdVideoPicture->dts = buffer->dts;
     pDvdVideoPicture->pts = FromOMXTime(buffer->omx_buffer->nTimeStamp);
     pDvdVideoPicture->openMaxBuffer->Acquire();
     pDvdVideoPicture->iFlags  = DVP_FLAG_ALLOCATED;
     if (buffer->omx_buffer->nFlags & OMX_BUFFERFLAG_PTS_INVALID)
       pDvdVideoPicture->pts = DVD_NOPTS_VALUE;
 #if defined(OMX_DEBUG_VERBOSE)
-    CLog::Log(LOGINFO, "%s::%s dts:%.3f pts:%.3f flags:%x:%x openMaxBuffer:%p omx_buffer:%p egl_image:%p texture_id:%x", CLASSNAME, __func__,
+    CLog::Log(LOGINFO, "%s::%s dts:%.3f pts:%.3f flags:%x:%x frame:%d openMaxBuffer:%p omx_buffer:%p egl_image:%p texture_id:%x", CLASSNAME, __func__,
         pDvdVideoPicture->dts == DVD_NOPTS_VALUE ? 0.0 : pDvdVideoPicture->dts*1e-6, pDvdVideoPicture->pts == DVD_NOPTS_VALUE ? 0.0 : pDvdVideoPicture->pts*1e-6,
-        pDvdVideoPicture->iFlags, buffer->omx_buffer->nFlags, pDvdVideoPicture->openMaxBuffer, pDvdVideoPicture->openMaxBuffer->omx_buffer, pDvdVideoPicture->openMaxBuffer->egl_image, pDvdVideoPicture->openMaxBuffer->texture_id);
+        pDvdVideoPicture->iFlags, buffer->omx_buffer->nFlags, (int)buffer->omx_buffer->pMarkData, pDvdVideoPicture->openMaxBuffer, pDvdVideoPicture->openMaxBuffer->omx_buffer, pDvdVideoPicture->openMaxBuffer->egl_image, pDvdVideoPicture->openMaxBuffer->texture_id);
 #endif
     assert(!(buffer->omx_buffer->nFlags & (OMX_BUFFERFLAG_DECODEONLY | OMX_BUFFERFLAG_DROPPED)));
   }
@@ -956,6 +970,12 @@ bool COpenMaxVideo::GetPicture(DVDVideoPicture* pDvdVideoPicture)
     CLog::Log(LOGERROR, "%s::%s - called but m_omx_output_ready is empty", CLASSNAME, __func__);
     return false;
   }
+
+  if (pDvdVideoPicture->pts != DVD_NOPTS_VALUE)
+    m_decoderPts = pDvdVideoPicture->pts;
+  else
+    m_decoderPts = pDvdVideoPicture->dts; // xxx is DVD_NOPTS_VALUE better?
+
   return true;
 }
 
@@ -970,25 +990,56 @@ bool COpenMaxVideo::ClearPicture(DVDVideoPicture* pDvdVideoPicture)
   return true;
 }
 
+bool COpenMaxVideo::GetCodecStats(double &pts, int &droppedPics)
+{
+  pts = m_decoderPts;
+  droppedPics = m_droppedPics;
+  m_droppedPics = 0;
+#if defined(OMX_DEBUG_VERBOSE)
+  CLog::Log(LOGDEBUG, "%s::%s - pts:%.0f droppedPics:%d", CLASSNAME, __func__, pts, droppedPics);
+#endif
+  return true;
+}
+
   // DecoderFillBufferDone -- OpenMax output buffer has been filled
 OMX_ERRORTYPE COpenMaxVideo::DecoderFillBufferDone(
   OMX_HANDLETYPE hComponent,
   OMX_BUFFERHEADERTYPE* pBuffer)
 {
   COpenMaxVideoBuffer *buffer = (COpenMaxVideoBuffer*)pBuffer->pAppPrivate;
+  bool skipDeinterlaceFields = m_skipDeinterlaceFields || g_windowManager.HasDialogOnScreen();
 
   #if defined(OMX_DEBUG_VERBOSE)
-  CLog::Log(LOGDEBUG, "%s::%s - %p (%p,%p) buffer_size(%u), pts:%.3f flags:%x",
-    CLASSNAME, __func__, buffer, pBuffer, buffer->omx_buffer, pBuffer->nFilledLen, (double)FromOMXTime(buffer->omx_buffer->nTimeStamp)*1e-6, buffer->omx_buffer->nFlags);
+  CLog::Log(LOGDEBUG, "%s::%s - %p (%p,%p) buffer_size(%u), pts:%.3f flags:%x frame:%d win:%x",
+    CLASSNAME, __func__, buffer, pBuffer, buffer->omx_buffer, pBuffer->nFilledLen, (double)FromOMXTime(buffer->omx_buffer->nTimeStamp)*1e-6, buffer->omx_buffer->nFlags, (int)buffer->omx_buffer->pMarkData, skipDeinterlaceFields);
   #endif
 
   assert(!(buffer->omx_buffer->nFlags & (OMX_BUFFERFLAG_DECODEONLY | OMX_BUFFERFLAG_DROPPED)));
-  // queue output omx buffer to ready list.
-  pthread_mutex_lock(&m_omx_output_mutex);
-  buffer->m_aspect_ratio = m_aspect_ratio;
-  m_omx_output_ready.push(buffer);
-  pthread_mutex_unlock(&m_omx_output_mutex);
 
+
+  // flags have OMX_BUFFERFLAG_FIRST_FIELD set if this is a direct result of a submitted frame,
+  // clear for second field of deinterlaced frame. They are zero when frame is returned due to a flush.
+#ifdef DTS_QUEUE
+  if ((!m_deinterlace || (buffer->omx_buffer->nFlags & OMX_BUFFERFLAG_FIRST_FIELD)) && buffer->omx_buffer->nFlags)
+  {
+    pthread_mutex_lock(&m_omx_output_mutex);
+    assert(!m_dts_queue.empty());
+    buffer->dts = m_dts_queue.front();
+    m_dts_queue.pop();
+    pthread_mutex_unlock(&m_omx_output_mutex);
+  }
+#endif
+  if (m_drop_state || (m_deinterlace && skipDeinterlaceFields && !(buffer->omx_buffer->nFlags & OMX_BUFFERFLAG_FIRST_FIELD)))
+  {
+    ReturnOpenMaxBuffer(buffer);
+  }
+  else
+  {
+    buffer->m_aspect_ratio = m_aspect_ratio;
+    pthread_mutex_lock(&m_omx_output_mutex);
+    m_omx_output_ready.push(buffer);
+    pthread_mutex_unlock(&m_omx_output_mutex);
+  }
   return OMX_ErrorNone;
 }
 
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.h
index f234f6d..adf53b5 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.h
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.h
@@ -57,6 +57,7 @@ class COpenMaxVideoBuffer
   int height;
   float m_aspect_ratio;
   int index;
+  double dts;
 
   // used for egl based rendering if active
   EGLImageKHR egl_image;
@@ -87,6 +88,7 @@ class COpenMaxVideo
   virtual unsigned GetAllowedReferences() { return 2; }
   virtual void SetDropState(bool bDrop);
   virtual const char* GetName(void) { return (const char*)m_pFormatName; }
+  virtual bool GetCodecStats(double &pts, int &droppedPics);
 
   // OpenMax decoder callback routines.
   OMX_ERRORTYPE DecoderFillBufferDone(OMX_HANDLETYPE hComponent, OMX_BUFFERHEADERTYPE* pBuffer);
@@ -142,10 +144,11 @@ class COpenMaxVideo
 
   bool              m_deinterlace;
   EDEINTERLACEMODE  m_deinterlace_request;
-  bool              m_deinterlace_second_field;
-
   bool              m_startframe;
-
+  unsigned int      m_decode_frame_number;
+  double            m_decoderPts;
+  unsigned int      m_droppedPics;
+  bool              m_skipDeinterlaceFields;
   bool PortSettingsChanged();
   bool SendDecoderConfig(uint8_t *extradata, int extrasize);
   bool NaluFormatStartCodes(enum AVCodecID codec, uint8_t *extradata, int extrasize);
-- 
1.9.3


From 089ed035143c22d05c5360d05a18b250b92192a7 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Fri, 11 Apr 2014 16:12:27 +0100
Subject: [PATCH 065/102] [omxplayer] Add ability to log more timestamp info in
 extra debug settings

---
 language/English/strings.po             |  5 ++++
 xbmc/commons/ilog.h                     |  1 +
 xbmc/cores/omxplayer/OMXPlayer.cpp      | 52 ++++++++++++++++-----------------
 xbmc/cores/omxplayer/OMXPlayerAudio.cpp |  8 ++---
 xbmc/cores/omxplayer/OMXPlayerVideo.cpp |  9 +++---
 xbmc/settings/AdvancedSettings.cpp      |  3 ++
 6 files changed, 44 insertions(+), 34 deletions(-)

diff --git a/language/English/strings.po b/language/English/strings.po
index d386f68..a2c7215 100755
--- a/language/English/strings.po
+++ b/language/English/strings.po
@@ -2871,6 +2871,11 @@ msgctxt "#679"
 msgid "Verbose logging for CEC library"
 msgstr ""
 
+#: xbmc/settings/AdvancedSettings.cpp
+msgctxt "#697"
+msgid "Verbose logging for OMXPLAYER"
+msgstr ""
+
 #empty strings from id 680 to 699
 
 msgctxt "#700"
diff --git a/xbmc/commons/ilog.h b/xbmc/commons/ilog.h
index 4bf5d83..3fb7cc3 100644
--- a/xbmc/commons/ilog.h
+++ b/xbmc/commons/ilog.h
@@ -53,6 +53,7 @@
 #define LOGAIRTUNES (1 << (LOGMASKBIT + 8))
 #define LOGUPNP     (1 << (LOGMASKBIT + 9))
 #define LOGCEC      (1 << (LOGMASKBIT + 10))
+#define LOGOMXPLAYER  (1 << (LOGMASKBIT+11))
 
 #ifdef __GNUC__
 #define ATTRIB_LOG_FORMAT __attribute__((format(printf,3,4)))
diff --git a/xbmc/cores/omxplayer/OMXPlayer.cpp b/xbmc/cores/omxplayer/OMXPlayer.cpp
index ebb59d5..4e0662f 100644
--- a/xbmc/cores/omxplayer/OMXPlayer.cpp
+++ b/xbmc/cores/omxplayer/OMXPlayer.cpp
@@ -1546,27 +1546,28 @@ void COMXPlayer::Process()
       m_video_fifo = (int)(100.0*(m_omxPlayerVideo.GetDecoderBufferSize()-m_omxPlayerVideo.GetDecoderFreeSpace())/m_omxPlayerVideo.GetDecoderBufferSize());
       m_audio_fifo = (int)(100.0*audio_fifo/m_omxPlayerAudio.GetCacheTotal());
 
-      #ifdef _DEBUG
-      static unsigned count;
-      if ((count++ & 7) == 0)
+      if (g_advancedSettings.CanLogComponent(LOGOMXPLAYER))
       {
-        char response[80];
-        if (m_omxPlayerVideo.GetDecoderBufferSize() && m_omxPlayerAudio.GetCacheTotal())
-          vc_gencmd(response, sizeof response, "render_bar 4 video_fifo %d %d %d %d",
-              m_video_fifo,
-              (int)(100.0*video_fifo/m_omxPlayerAudio.GetCacheTotal()),
-              0, 100);
-        if (m_omxPlayerAudio.GetCacheTotal())
-          vc_gencmd(response, sizeof response, "render_bar 5 audio_fifo %d %d %d %d",
-              m_audio_fifo,
-              (int)(100.0*m_omxPlayerAudio.GetDelay()/m_omxPlayerAudio.GetCacheTotal()),
-              0, 100);
-        vc_gencmd(response, sizeof response, "render_bar 6 video_queue %d %d %d %d",
-              m_omxPlayerVideo.GetLevel(), 0, 0, 100);
-        vc_gencmd(response, sizeof response, "render_bar 7 audio_queue %d %d %d %d",
-              m_omxPlayerAudio.GetLevel(), 0, 0, 100);
+        static unsigned count;
+        if ((count++ & 7) == 0)
+        {
+          char response[80];
+          if (m_omxPlayerVideo.GetDecoderBufferSize() && m_omxPlayerAudio.GetCacheTotal())
+            vc_gencmd(response, sizeof response, "render_bar 4 video_fifo %d %d %d %d",
+                m_video_fifo,
+                (int)(100.0*video_fifo/m_omxPlayerAudio.GetCacheTotal()),
+                0, 100);
+          if (m_omxPlayerAudio.GetCacheTotal())
+            vc_gencmd(response, sizeof response, "render_bar 5 audio_fifo %d %d %d %d",
+                m_audio_fifo,
+                (int)(100.0*m_omxPlayerAudio.GetDelay()/m_omxPlayerAudio.GetCacheTotal()),
+                0, 100);
+          vc_gencmd(response, sizeof response, "render_bar 6 video_queue %d %d %d %d",
+                m_omxPlayerVideo.GetLevel(), 0, 0, 100);
+          vc_gencmd(response, sizeof response, "render_bar 7 audio_queue %d %d %d %d",
+                m_omxPlayerAudio.GetLevel(), 0, 0, 100);
+        }
       }
-      #endif
       if (audio_pts != DVD_NOPTS_VALUE)
       {
         audio_fifo_low = m_HasAudio && audio_fifo < threshold;
@@ -1582,13 +1583,12 @@ void COMXPlayer::Process()
       if (!m_HasVideo && m_HasAudio)
         video_fifo_high = true;
 
-      #ifdef _DEBUG
-      CLog::Log(LOGDEBUG, "%s - M:%.6f-%.6f (A:%.6f V:%.6f) PEF:%d%d%d S:%.2f A:%.2f V:%.2f/T:%.2f (A:%d%d V:%d%d) A:%d%% V:%d%% (%.2f,%.2f)", __FUNCTION__,
-        m_stamp*1e-6, m_av_clock.OMXClockAdjustment()*1e-6, audio_pts*1e-6, video_pts*1e-6, m_av_clock.OMXIsPaused(), bOmxSentEOFs, not_accepts_data, m_playSpeed * (1.0f/DVD_PLAYSPEED_NORMAL),
-        audio_pts == DVD_NOPTS_VALUE ? 0.0:audio_fifo, video_pts == DVD_NOPTS_VALUE ? 0.0:video_fifo, m_threshold,
-        audio_fifo_low, audio_fifo_high, video_fifo_low, video_fifo_high,
-        m_omxPlayerAudio.GetLevel(), m_omxPlayerVideo.GetLevel(), m_omxPlayerAudio.GetDelay(), (float)m_omxPlayerAudio.GetCacheTotal());
-      #endif
+      if (g_advancedSettings.CanLogComponent(LOGOMXPLAYER))
+        CLog::Log(LOGDEBUG, "%s - M:%.6f-%.6f (A:%.6f V:%.6f) PEF:%d%d%d S:%.2f A:%.2f V:%.2f/T:%.2f (A:%d%d V:%d%d) A:%d%% V:%d%% (%.2f,%.2f)", __FUNCTION__,
+          m_stamp*1e-6, m_av_clock.OMXClockAdjustment()*1e-6, audio_pts*1e-6, video_pts*1e-6, m_av_clock.OMXIsPaused(), bOmxSentEOFs, not_accepts_data, m_playSpeed * (1.0f/DVD_PLAYSPEED_NORMAL),
+          audio_pts == DVD_NOPTS_VALUE ? 0.0:audio_fifo, video_pts == DVD_NOPTS_VALUE ? 0.0:video_fifo, m_threshold,
+          audio_fifo_low, audio_fifo_high, video_fifo_low, video_fifo_high,
+          m_omxPlayerAudio.GetLevel(), m_omxPlayerVideo.GetLevel(), m_omxPlayerAudio.GetDelay(), (float)m_omxPlayerAudio.GetCacheTotal());
 
       if (TP(m_playSpeed))
       {
diff --git a/xbmc/cores/omxplayer/OMXPlayerAudio.cpp b/xbmc/cores/omxplayer/OMXPlayerAudio.cpp
index d3348ec..02dd9be 100644
--- a/xbmc/cores/omxplayer/OMXPlayerAudio.cpp
+++ b/xbmc/cores/omxplayer/OMXPlayerAudio.cpp
@@ -364,10 +364,10 @@ void OMXPlayerAudio::Process()
       DemuxPacket* pPacket = ((CDVDMsgDemuxerPacket*)pMsg)->GetPacket();
       bool bPacketDrop     = ((CDVDMsgDemuxerPacket*)pMsg)->GetPacketDrop();
 
-      #ifdef _DEBUG
-      CLog::Log(LOGINFO, "Audio: dts:%.0f pts:%.0f size:%d (s:%d f:%d d:%d l:%d) s:%d %d/%d late:%d,%d", pPacket->dts, pPacket->pts,
-           (int)pPacket->iSize, m_started, m_flush, bPacketDrop, m_stalled, m_speed, 0, 0, (int)m_omxAudio.GetAudioRenderingLatency(), (int)m_hints_current.samplerate);
-      #endif
+      if (g_advancedSettings.CanLogComponent(LOGOMXPLAYER))
+        CLog::Log(LOGINFO, "Audio: dts:%.0f pts:%.0f size:%d (s:%d f:%d d:%d l:%d) s:%d %d/%d late:%d,%d", pPacket->dts, pPacket->pts,
+             (int)pPacket->iSize, m_started, m_flush, bPacketDrop, m_stalled, m_speed, 0, 0, (int)m_omxAudio.GetAudioRenderingLatency(), (int)m_hints_current.samplerate);
+
       if(Decode(pPacket, m_speed > DVD_PLAYSPEED_NORMAL || m_speed < 0 || bPacketDrop))
       {
         // we are not running until something is cached in output device
diff --git a/xbmc/cores/omxplayer/OMXPlayerVideo.cpp b/xbmc/cores/omxplayer/OMXPlayerVideo.cpp
index e6bf2d0..aa5ea43 100644
--- a/xbmc/cores/omxplayer/OMXPlayerVideo.cpp
+++ b/xbmc/cores/omxplayer/OMXPlayerVideo.cpp
@@ -42,6 +42,7 @@
 #include "DVDOverlayRenderer.h"
 #include "settings/DisplaySettings.h"
 #include "settings/Settings.h"
+#include "settings/AdvancedSettings.h"
 #include "settings/MediaSettings.h"
 #include "cores/VideoRenderers/RenderFormats.h"
 #include "cores/VideoRenderers/RenderFlags.h"
@@ -451,10 +452,10 @@ void OMXPlayerVideo::Process()
       DemuxPacket* pPacket = ((CDVDMsgDemuxerPacket*)pMsg)->GetPacket();
       bool bPacketDrop     = ((CDVDMsgDemuxerPacket*)pMsg)->GetPacketDrop();
 
-      #ifdef _DEBUG
-      CLog::Log(LOGINFO, "Video: dts:%.0f pts:%.0f size:%d (s:%d f:%d d:%d l:%d) s:%d %d/%d late:%d\n", pPacket->dts, pPacket->pts, 
-          (int)pPacket->iSize, m_started, m_flush, bPacketDrop, m_stalled, m_speed, 0, 0, 0);
-      #endif
+      if (g_advancedSettings.CanLogComponent(LOGOMXPLAYER))
+        CLog::Log(LOGINFO, "Video: dts:%.0f pts:%.0f size:%d (s:%d f:%d d:%d l:%d) s:%d %d/%d late:%d\n", pPacket->dts, pPacket->pts,
+            (int)pPacket->iSize, m_started, m_flush, bPacketDrop, m_stalled, m_speed, 0, 0, 0);
+
       if (m_messageQueue.GetDataSize() == 0
       ||  m_speed < 0)
       {
diff --git a/xbmc/settings/AdvancedSettings.cpp b/xbmc/settings/AdvancedSettings.cpp
index 59b4d9e..e597a4e 100644
--- a/xbmc/settings/AdvancedSettings.cpp
+++ b/xbmc/settings/AdvancedSettings.cpp
@@ -1386,6 +1386,9 @@ void CAdvancedSettings::SettingOptionsLoggingComponentsFiller(const CSetting *se
 #ifdef HAVE_LIBCEC
   list.push_back(std::make_pair(g_localizeStrings.Get(679), LOGCEC));
 #endif
+#ifdef TARGET_RASPBERRY_PI
+  list.push_back(std::make_pair(g_localizeStrings.Get(697), LOGOMXPLAYER));
+#endif
 }
 
 void CAdvancedSettings::setExtraLogLevel(const std::vector<CVariant> &components)
-- 
1.9.3


From 55725e4e4177382834f003c144aebf50000bf389 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Mon, 7 Apr 2014 23:13:55 +0100
Subject: [PATCH 066/102] [omxplayer] Add ability to dump out audio/video data
 for later debugging

---
 language/English/strings.po        | 10 ++++++++
 xbmc/commons/ilog.h                |  2 ++
 xbmc/cores/omxplayer/OMXAudio.cpp  | 49 ++++++++++++++++++++++++++++++++++++++
 xbmc/cores/omxplayer/OMXVideo.cpp  | 47 ++++++++++++++++++++++++++++++++++++
 xbmc/settings/AdvancedSettings.cpp |  4 ++++
 5 files changed, 112 insertions(+)

diff --git a/language/English/strings.po b/language/English/strings.po
index a2c7215..9ba9565 100755
--- a/language/English/strings.po
+++ b/language/English/strings.po
@@ -2876,6 +2876,16 @@ msgctxt "#697"
 msgid "Verbose logging for OMXPLAYER"
 msgstr ""
 
+#: xbmc/settings/AdvancedSettings.cpp
+msgctxt "#698"
+msgid "Dump video frames to debug file"
+msgstr ""
+
+#: xbmc/settings/AdvancedSettings.cpp
+msgctxt "#699"
+msgid "Dump audio frames to debug file"
+msgstr ""
+
 #empty strings from id 680 to 699
 
 msgctxt "#700"
diff --git a/xbmc/commons/ilog.h b/xbmc/commons/ilog.h
index 3fb7cc3..4d722a0 100644
--- a/xbmc/commons/ilog.h
+++ b/xbmc/commons/ilog.h
@@ -54,6 +54,8 @@
 #define LOGUPNP     (1 << (LOGMASKBIT + 9))
 #define LOGCEC      (1 << (LOGMASKBIT + 10))
 #define LOGOMXPLAYER  (1 << (LOGMASKBIT+11))
+#define LOGDUMPVIDEO  (1 << (LOGMASKBIT+12))
+#define LOGDUMPAUDIO  (1 << (LOGMASKBIT+13))
 
 #ifdef __GNUC__
 #define ATTRIB_LOG_FORMAT __attribute__((format(printf,3,4)))
diff --git a/xbmc/cores/omxplayer/OMXAudio.cpp b/xbmc/cores/omxplayer/OMXAudio.cpp
index 5f9d028..1bcc53e0 100644
--- a/xbmc/cores/omxplayer/OMXAudio.cpp
+++ b/xbmc/cores/omxplayer/OMXAudio.cpp
@@ -59,6 +59,49 @@ static const uint16_t AC3FSCod   [] = {48000, 44100, 32000, 0};
 
 static const uint16_t DTSFSCod   [] = {0, 8000, 16000, 32000, 0, 0, 11025, 22050, 44100, 0, 0, 12000, 24000, 48000, 0, 0};
 
+//#define DEBUG_PLAYBACK
+static void dump_omx_buffer(OMX_BUFFERHEADERTYPE *omx_buffer)
+{
+  if (!(g_advancedSettings.CanLogComponent(LOGDUMPAUDIO)))
+    return;
+  static FILE *fp;
+  if (!omx_buffer)
+  {
+    if (fp)
+    {
+      fclose(fp);
+      fp = NULL;
+    }
+    return;
+  }
+  if (!fp)
+  {
+    char filename[1024];
+    strcpy(filename, g_advancedSettings.m_logFolder.c_str());
+    strcat(filename, "audio.dat");
+#ifdef DEBUG_PLAYBACK
+    fp = fopen(filename, "rb");
+#else
+    fp = fopen(filename, "wb");
+#endif
+    }
+  if (fp)
+  {
+#ifdef DEBUG_PLAYBACK
+    OMX_BUFFERHEADERTYPE omx = {0};
+    int s = fread(&omx, sizeof omx, 1, fp);
+    omx_buffer->nFilledLen = omx.nFilledLen;
+    omx_buffer->nFlags = omx.nFlags;
+    omx_buffer->nTimeStamp = omx.nTimeStamp;
+    if (s==1)
+      fread(omx_buffer->pBuffer, omx_buffer->nFilledLen, 1, fp);
+#else
+    if (fwrite(omx_buffer, sizeof *omx_buffer, 1, fp) == 1)
+      fwrite(omx_buffer->pBuffer, omx_buffer->nFilledLen, 1, fp);
+#endif
+  }
+}
+
 //////////////////////////////////////////////////////////////////////
 // Construction/Destruction
 //////////////////////////////////////////////////////////////////////
@@ -866,6 +909,7 @@ bool COMXAudio::Initialize(AEAudioFormat format, OMXClock *clock, CDVDStreamInfo
     memcpy((unsigned char *)omx_buffer->pBuffer, &m_wave_header, omx_buffer->nFilledLen);
     omx_buffer->nFlags = OMX_BUFFERFLAG_CODECCONFIG | OMX_BUFFERFLAG_ENDOFFRAME;
 
+    dump_omx_buffer(omx_buffer);
     omx_err = m_omx_decoder.EmptyThisBuffer(omx_buffer);
     if (omx_err != OMX_ErrorNone)
     {
@@ -898,6 +942,7 @@ bool COMXAudio::Initialize(AEAudioFormat format, OMXClock *clock, CDVDStreamInfo
       memcpy((unsigned char *)omx_buffer->pBuffer, m_extradata, omx_buffer->nFilledLen);
       omx_buffer->nFlags = OMX_BUFFERFLAG_CODECCONFIG | OMX_BUFFERFLAG_ENDOFFRAME;
   
+      dump_omx_buffer(omx_buffer);
       omx_err = m_omx_decoder.EmptyThisBuffer(omx_buffer);
       if (omx_err != OMX_ErrorNone)
       {
@@ -934,6 +979,8 @@ bool COMXAudio::Deinitialize()
 {
   CSingleLock lock (m_critSection);
 
+  dump_omx_buffer(NULL);
+
   if ( m_omx_tunnel_clock_analog.IsInitialized() )
     m_omx_tunnel_clock_analog.Deestablish();
   if ( m_omx_tunnel_clock_hdmi.IsInitialized() )
@@ -1226,6 +1273,7 @@ unsigned int COMXAudio::AddPackets(const void* data, unsigned int len, double dt
     int nRetry = 0;
     while(true)
     {
+      dump_omx_buffer(omx_buffer);
       omx_err = m_omx_decoder.EmptyThisBuffer(omx_buffer);
       if (omx_err == OMX_ErrorNone)
       {
@@ -1492,6 +1540,7 @@ void COMXAudio::SubmitEOS()
 
   omx_buffer->nFlags = OMX_BUFFERFLAG_ENDOFFRAME | OMX_BUFFERFLAG_EOS | OMX_BUFFERFLAG_TIME_UNKNOWN;
 
+  dump_omx_buffer(omx_buffer);
   omx_err = m_omx_decoder.EmptyThisBuffer(omx_buffer);
   if (omx_err != OMX_ErrorNone)
   {
diff --git a/xbmc/cores/omxplayer/OMXVideo.cpp b/xbmc/cores/omxplayer/OMXVideo.cpp
index 820ea44..6639804 100644
--- a/xbmc/cores/omxplayer/OMXVideo.cpp
+++ b/xbmc/cores/omxplayer/OMXVideo.cpp
@@ -63,6 +63,49 @@
 
 #define MAX_TEXT_LENGTH 1024
 
+//#define DEBUG_PLAYBACK
+static void dump_omx_buffer(OMX_BUFFERHEADERTYPE *omx_buffer)
+{
+  if (!(g_advancedSettings.CanLogComponent(LOGDUMPVIDEO)))
+    return;
+  static FILE *fp;
+  if (!omx_buffer)
+  {
+    if (fp)
+    {
+      fclose(fp);
+      fp = NULL;
+    }
+    return;
+  }
+  if (!fp)
+  {
+    char filename[1024];
+    strcpy(filename, g_advancedSettings.m_logFolder.c_str());
+    strcat(filename, "video.dat");
+#ifdef DEBUG_PLAYBACK
+    fp = fopen(filename, "rb");
+#else
+    fp = fopen(filename, "wb");
+#endif
+    }
+  if (fp)
+  {
+#ifdef DEBUG_PLAYBACK
+    OMX_BUFFERHEADERTYPE omx = {0};
+    int s = fread(&omx, sizeof omx, 1, fp);
+    omx_buffer->nFilledLen = omx.nFilledLen;
+    omx_buffer->nFlags = omx.nFlags;
+    omx_buffer->nTimeStamp = omx.nTimeStamp;
+    if (s==1)
+      fread(omx_buffer->pBuffer, omx_buffer->nFilledLen, 1, fp);
+#else
+    if (fwrite(omx_buffer, sizeof *omx_buffer, 1, fp) == 1)
+      fwrite(omx_buffer->pBuffer, omx_buffer->nFilledLen, 1, fp);
+#endif
+  }
+}
+
 COMXVideo::COMXVideo() : m_video_codec_name("")
 {
   m_is_open           = false;
@@ -118,6 +161,7 @@ bool COMXVideo::SendDecoderConfig()
     memcpy((unsigned char *)omx_buffer->pBuffer, m_extradata, omx_buffer->nFilledLen);
     omx_buffer->nFlags = OMX_BUFFERFLAG_CODECCONFIG | OMX_BUFFERFLAG_ENDOFFRAME;
   
+    dump_omx_buffer(omx_buffer);
     omx_err = m_omx_decoder.EmptyThisBuffer(omx_buffer);
     if (omx_err != OMX_ErrorNone)
     {
@@ -687,6 +731,7 @@ bool COMXVideo::Open(CDVDStreamInfo &hints, OMXClock *clock, EDEINTERLACEMODE de
 void COMXVideo::Close()
 {
   CSingleLock lock (m_critSection);
+  dump_omx_buffer(NULL);
   m_omx_tunnel_clock.Deestablish();
   m_omx_tunnel_decoder.Deestablish();
   if(m_deinterlace)
@@ -781,6 +826,7 @@ int COMXVideo::Decode(uint8_t *pData, int iSize, double pts)
       int nRetry = 0;
       while(true)
       {
+        dump_omx_buffer(omx_buffer);
         omx_err = m_omx_decoder.EmptyThisBuffer(omx_buffer);
         if (omx_err == OMX_ErrorNone)
         {
@@ -910,6 +956,7 @@ void COMXVideo::SubmitEOS()
 
   omx_buffer->nFlags = OMX_BUFFERFLAG_ENDOFFRAME | OMX_BUFFERFLAG_EOS | OMX_BUFFERFLAG_TIME_UNKNOWN;
   
+  dump_omx_buffer(omx_buffer);
   omx_err = m_omx_decoder.EmptyThisBuffer(omx_buffer);
   if (omx_err != OMX_ErrorNone)
   {
diff --git a/xbmc/settings/AdvancedSettings.cpp b/xbmc/settings/AdvancedSettings.cpp
index e597a4e..0530467 100644
--- a/xbmc/settings/AdvancedSettings.cpp
+++ b/xbmc/settings/AdvancedSettings.cpp
@@ -1389,6 +1389,10 @@ void CAdvancedSettings::SettingOptionsLoggingComponentsFiller(const CSetting *se
 #ifdef TARGET_RASPBERRY_PI
   list.push_back(std::make_pair(g_localizeStrings.Get(697), LOGOMXPLAYER));
 #endif
+#ifdef TARGET_RASPBERRY_PI
+  list.push_back(std::make_pair(g_localizeStrings.Get(698), LOGDUMPVIDEO));
+  list.push_back(std::make_pair(g_localizeStrings.Get(699), LOGDUMPAUDIO));
+#endif
 }
 
 void CAdvancedSettings::setExtraLogLevel(const std::vector<CVariant> &components)
-- 
1.9.3


From 0cdbd90db8f90e1f6dd9703b1c7646e7813d7d1f Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Wed, 28 May 2014 18:30:51 +0100
Subject: [PATCH 067/102] [omxcodec] Reduce GPU memory use by 2 video frames

---
 xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp | 14 ++++++++++++++
 1 file changed, 14 insertions(+)

diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp
index 612ae21..494fdf5 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp
@@ -308,6 +308,20 @@ bool COpenMaxVideo::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options, OpenM
     return false;
   }
 
+  {
+    // as we aren't tunnelled to display, we can save memory by setting extrabuffers to 0
+    OMX_PARAM_U32TYPE extra_buffers;
+    OMX_INIT_STRUCTURE(extra_buffers);
+    extra_buffers.nU32 = 0;
+
+    omx_err = m_omx_decoder.SetParameter(OMX_IndexParamBrcmExtraBuffers, &extra_buffers);
+    if(omx_err != OMX_ErrorNone)
+    {
+      CLog::Log(LOGERROR, "COMXVideo::Open error OMX_IndexParamBrcmExtraBuffers omx_err(0x%08x)\n", omx_err);
+      return false;
+    }
+  }
+
   // request portsettingschanged on aspect ratio change
   OMX_CONFIG_REQUESTCALLBACKTYPE notifications;
   OMX_INIT_STRUCTURE(notifications);
-- 
1.9.3


From 5f1289e7a8f03c67a50e626f87517daf15e35f25 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Fri, 30 May 2014 14:15:10 +0100
Subject: [PATCH 068/102] [pi] Fix for logged resolutions

---
 xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp | 15 +++++----------
 1 file changed, 5 insertions(+), 10 deletions(-)

diff --git a/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp b/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp
index 5b26b20..a3edf0e 100644
--- a/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp
+++ b/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp
@@ -483,10 +483,8 @@ bool CEGLNativeTypeRaspberryPI::ProbeResolutions(std::vector<RESOLUTION_INFO> &r
 
   if(resolutions.size() == 0)
   {
-    RESOLUTION_INFO res;
-    CLog::Log(LOGDEBUG, "EGL probe resolution %s:%x\n", m_desktopRes.strMode.c_str(), m_desktopRes.dwFlags);
-
     AddUniqueResolution(m_desktopRes, resolutions);
+    CLog::Log(LOGDEBUG, "EGL probe resolution %s:%x\n", m_desktopRes.strMode.c_str(), m_desktopRes.dwFlags);
   }
 
   if(resolutions.size() < 2)
@@ -576,13 +574,12 @@ void CEGLNativeTypeRaspberryPI::GetSupportedModes(HDMI_RES_GROUP_T group, std::v
       res.iScreenWidth  = tv->width;
       res.iScreenHeight = tv->height;
       res.fPixelRatio   = get_display_aspect_ratio((HDMI_ASPECT_T)tv->aspect_ratio) / ((float)res.iScreenWidth / (float)res.iScreenHeight);
+      res.iSubtitles    = (int)(0.965 * res.iHeight);
 
+      AddUniqueResolution(res, resolutions);
       CLog::Log(LOGDEBUG, "EGL mode %d: %s (%.2f) %s%s:%x\n", i, res.strMode.c_str(), res.fPixelRatio,
           tv->native ? "N" : "", tv->scan_mode ? "I" : "", tv->code);
 
-      res.iSubtitles    = (int)(0.965 * res.iHeight);
-
-      AddUniqueResolution(res, resolutions);
       if (tv->frame_rate == 24 || tv->frame_rate == 30 || tv->frame_rate == 60)
       {
         RESOLUTION_INFO res2 = res;
@@ -596,11 +593,10 @@ void CEGLNativeTypeRaspberryPI::GetSupportedModes(HDMI_RES_GROUP_T group, std::v
         RESOLUTION_INFO res2 = res;
         res2.dwFlags |= D3DPRESENTFLAG_MODE3DSBS;
         res2.fPixelRatio    = get_display_aspect_ratio((HDMI_ASPECT_T)tv->aspect_ratio) / ((float)res2.iScreenWidth / (float)res2.iScreenHeight);
-        CLog::Log(LOGDEBUG, "EGL mode %d: %s (%.2f)\n", i, res2.strMode.c_str(), res2.fPixelRatio);
-
         res2.iSubtitles    = (int)(0.965 * res2.iHeight);
 
         AddUniqueResolution(res2, resolutions);
+        CLog::Log(LOGDEBUG, "EGL mode %d: %s (%.2f)\n", i, res2.strMode.c_str(), res2.fPixelRatio);
         if (tv->frame_rate == 24 || tv->frame_rate == 30 || tv->frame_rate == 60)
         {
           res2.fRefreshRate  = (float)tv->frame_rate * (1000.0f/1001.0f);
@@ -612,11 +608,10 @@ void CEGLNativeTypeRaspberryPI::GetSupportedModes(HDMI_RES_GROUP_T group, std::v
         RESOLUTION_INFO res2 = res;
         res2.dwFlags |= D3DPRESENTFLAG_MODE3DTB;
         res2.fPixelRatio    = get_display_aspect_ratio((HDMI_ASPECT_T)tv->aspect_ratio) / ((float)res2.iScreenWidth / (float)res2.iScreenHeight);
-        CLog::Log(LOGDEBUG, "EGL mode %d: %s (%.2f)\n", i, res2.strMode.c_str(), res2.fPixelRatio);
-
         res2.iSubtitles    = (int)(0.965 * res2.iHeight);
 
         AddUniqueResolution(res2, resolutions);
+        CLog::Log(LOGDEBUG, "EGL mode %d: %s (%.2f)\n", i, res2.strMode.c_str(), res2.fPixelRatio);
         if (tv->frame_rate == 24 || tv->frame_rate == 30 || tv->frame_rate == 60)
         {
           res2.fRefreshRate  = (float)tv->frame_rate * (1000.0f/1001.0f);
-- 
1.9.3


From 22f4be7399f9b9fc57cd735b498699a736cce6a7 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Fri, 30 May 2014 14:58:43 +0100
Subject: [PATCH 069/102] [settings] Experiment: Report DESKTOP resolution in
 video settings

---
 xbmc/settings/DisplaySettings.cpp | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/xbmc/settings/DisplaySettings.cpp b/xbmc/settings/DisplaySettings.cpp
index bb31f15..eae549b 100644
--- a/xbmc/settings/DisplaySettings.cpp
+++ b/xbmc/settings/DisplaySettings.cpp
@@ -650,6 +650,9 @@ void CDisplaySettings::SettingOptionsResolutionsFiller(const CSetting *setting,
     vector<RESOLUTION_WHR> resolutions = g_Windowing.ScreenResolutions(info.iScreen, info.fRefreshRate);
     for (vector<RESOLUTION_WHR>::const_iterator resolution = resolutions.begin(); resolution != resolutions.end(); ++resolution)
     {
+if (resolution->ResInfo_Index == RES_DESKTOP)
+      list.push_back(make_pair(StringUtils::Format("DESKTOP"), resolution->ResInfo_Index));
+else
       list.push_back(make_pair(
         StringUtils::Format("%dx%d%s", resolution->width, resolution->height,
                             ModeFlagsToString(resolution->flags, false).c_str()),
-- 
1.9.3


From b8f5d4e406cf9934aa4e8a37880122d78c01f9b9 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Sat, 7 Jun 2014 16:55:41 +0100
Subject: [PATCH 070/102] [omx] Remove logging for texture jobs

This causes a lot of log spam which hasn't proved useful so far.
---
 xbmc/cores/omxplayer/OMXImage.cpp | 5 -----
 1 file changed, 5 deletions(-)

diff --git a/xbmc/cores/omxplayer/OMXImage.cpp b/xbmc/cores/omxplayer/OMXImage.cpp
index 262a004..d529b20 100644
--- a/xbmc/cores/omxplayer/OMXImage.cpp
+++ b/xbmc/cores/omxplayer/OMXImage.cpp
@@ -210,13 +210,11 @@ bool COMXImage::SendMessage(bool (*callback)(EGLDisplay egl_display, EGLContext
   mess.sync.Reset();
   {
     CSingleLock lock(m_texqueue_lock);
-    CLog::Log(LOGDEBUG, "%s: texture job: %p:%p", __func__, &mess, mess.callback);
     m_texqueue.push(&mess);
     m_texqueue_cond.notifyAll();
   }
   // wait for function to have finished (in texture thread)
   mess.sync.Wait();
-  CLog::Log(LOGDEBUG, "%s: texture job done: %p:%p = %d", __func__, &mess, mess.callback, mess.result);
   // need to ensure texture thread has returned from mess.sync.Set() before we exit and free tex
   CSingleLock lock(m_texqueue_lock);
   return mess.result;
@@ -429,15 +427,12 @@ void COMXImage::Process()
       struct callbackinfo *mess = m_texqueue.front();
       m_texqueue.pop();
       lock.Leave();
-      CLog::Log(LOGDEBUG, "%s: texture job: %p:%p:%p", __func__, mess, mess->callback, mess->cookie);
 
       mess->result = mess->callback(g_Windowing.GetEGLDisplay(), GetEGLContext(), mess->cookie);
-      CLog::Log(LOGDEBUG, "%s: texture job about to Set: %p:%p:%p", __func__, mess, mess->callback, mess->cookie);
       {
         CSingleLock lock(m_texqueue_lock);
         mess->sync.Set();
       }
-      CLog::Log(LOGDEBUG, "%s: texture job: %p done", __func__, mess);
     }
   }
 }
-- 
1.9.3


From a0a6be81a50eabf6e4f02df6ce11298c73287b74 Mon Sep 17 00:00:00 2001
From: Matthias Kortstiege <vdrfan@xbmc.org>
Date: Sun, 1 Jun 2014 18:47:20 +0200
Subject: [PATCH 071/102] changed: avoid useless filesytem io while searching
 for subtitles

---
 xbmc/Util.cpp | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/xbmc/Util.cpp b/xbmc/Util.cpp
index b33f142..4eabca6 100644
--- a/xbmc/Util.cpp
+++ b/xbmc/Util.cpp
@@ -1988,7 +1988,7 @@ void CUtil::ScanForExternalSubtitles(const std::string& strMovie, std::vector<st
     {
       CFileItemList items;
       
-      CDirectory::GetDirectory(strLookInPaths[step], items, g_advancedSettings.m_subtitlesExtensions, DIR_FLAG_NO_FILE_DIRS);
+      CDirectory::GetDirectory(strLookInPaths[step], items, g_advancedSettings.m_subtitlesExtensions, DIR_FLAG_NO_FILE_DIRS | DIR_FLAG_NO_FILE_INFO);
       
       for (int j = 0; j < items.Size(); j++)
       {
@@ -2068,7 +2068,7 @@ int CUtil::ScanArchiveForSubtitles( const std::string& strArchivePath, const std
   {
    CURL pathToUrl(strArchivePath);
    CURL zipURL = URIUtils::CreateArchivePath("zip", pathToUrl, "");
-   if (!CDirectory::GetDirectory(zipURL, ItemList, "", DIR_FLAG_NO_FILE_DIRS))
+   if (!CDirectory::GetDirectory(zipURL, ItemList, "", DIR_FLAG_NO_FILE_DIRS | DIR_FLAG_NO_FILE_INFO))
     return false;
   }
   else
-- 
1.9.3


From 4d20984ed783f9fc227ecdb3be43ad864af1fc55 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Wed, 4 Jun 2014 19:10:27 +0100
Subject: [PATCH 072/102] [pisink] Support planar formats

---
 xbmc/cores/AudioEngine/Sinks/AESinkPi.cpp | 35 ++++++++++++++++++++++++++-----
 1 file changed, 30 insertions(+), 5 deletions(-)

diff --git a/xbmc/cores/AudioEngine/Sinks/AESinkPi.cpp b/xbmc/cores/AudioEngine/Sinks/AESinkPi.cpp
index 0a09275..5a45653 100644
--- a/xbmc/cores/AudioEngine/Sinks/AESinkPi.cpp
+++ b/xbmc/cores/AudioEngine/Sinks/AESinkPi.cpp
@@ -180,7 +180,9 @@ bool CAESinkPi::Initialize(AEAudioFormat &format, std::string &device)
     format.m_channelLayout = AE_CH_LAYOUT_2_0;
 
   // setup for a 50ms sink feed from SoftAE
-  if (format.m_dataFormat != AE_FMT_FLOAT && format.m_dataFormat != AE_FMT_S32LE)
+  if (format.m_dataFormat != AE_FMT_FLOATP && format.m_dataFormat != AE_FMT_FLOAT &&
+      format.m_dataFormat != AE_FMT_S32NE && format.m_dataFormat != AE_FMT_S32NEP && format.m_dataFormat != AE_FMT_S32LE &&
+      format.m_dataFormat != AE_FMT_S16NE && format.m_dataFormat != AE_FMT_S16NEP && format.m_dataFormat != AE_FMT_S16LE)
     format.m_dataFormat = AE_FMT_S16LE;
   unsigned int channels    = format.m_channelLayout.Count();
   unsigned int sample_size = CAEUtil::DataFormatToBits(format.m_dataFormat) >> 3;
@@ -210,7 +212,13 @@ bool CAESinkPi::Initialize(AEAudioFormat &format, std::string &device)
   m_pcm_input.eEndian               = OMX_EndianLittle;
   m_pcm_input.bInterleaved          = OMX_TRUE;
   m_pcm_input.nBitPerSample         = sample_size * 8;
-  m_pcm_input.ePCMMode              = m_format.m_dataFormat == AE_FMT_FLOAT ? (OMX_AUDIO_PCMMODETYPE)0x8000 : OMX_AUDIO_PCMModeLinear;
+  // 0x8000 = float, 0x10000 = planar
+  uint32_t flags = 0;
+  if (m_format.m_dataFormat == AE_FMT_FLOAT || m_format.m_dataFormat == AE_FMT_FLOATP)
+   flags |= 0x8000;
+  if (AE_IS_PLANAR(m_format.m_dataFormat))
+   flags |= 0x10000;
+  m_pcm_input.ePCMMode              = flags == 0 ? OMX_AUDIO_PCMModeLinear : (OMX_AUDIO_PCMMODETYPE)flags;
   m_pcm_input.nChannels             = channels;
   m_pcm_input.nSamplingRate         = m_format.m_sampleRate;
 
@@ -306,14 +314,18 @@ double CAESinkPi::GetCacheTotal()
 
 unsigned int CAESinkPi::AddPackets(uint8_t **data, unsigned int frames, unsigned int offset)
 {
-  uint8_t *buffer = data[0]+offset*m_format.m_frameSize;
-
   if (!m_Initialized || !frames)
     return frames;
 
   OMX_ERRORTYPE omx_err   = OMX_ErrorNone;
   OMX_BUFFERHEADERTYPE *omx_buffer = NULL;
 
+  unsigned int channels    = m_format.m_channelLayout.Count();
+  unsigned int sample_size = CAEUtil::DataFormatToBits(m_format.m_dataFormat) >> 3;
+  const int planes = AE_IS_PLANAR(m_format.m_dataFormat) ? channels : 1;
+  const int chans  = AE_IS_PLANAR(m_format.m_dataFormat) ? 1 : channels;
+  const int pitch  = chans * sample_size;
+
   AEDelayStatus status;
   GetDelay(status);
   double delay = status.GetDelay();
@@ -332,8 +344,13 @@ unsigned int CAESinkPi::AddPackets(uint8_t **data, unsigned int frames, unsigned
   assert(omx_buffer->nFilledLen <= omx_buffer->nAllocLen);
   omx_buffer->nTimeStamp = ToOMXTime(0);
   omx_buffer->nFlags = OMX_BUFFERFLAG_ENDOFFRAME;
-  memcpy(omx_buffer->pBuffer, buffer, omx_buffer->nFilledLen);
 
+  if (omx_buffer->nFilledLen)
+  {
+    int planesize = omx_buffer->nFilledLen / planes;
+    for (int i=0; i < planes; i++)
+      memcpy((uint8_t *)omx_buffer->pBuffer + i * planesize, data[i] + offset * pitch, planesize);
+  }
   omx_err = m_omx_render.EmptyThisBuffer(omx_buffer);
   if (omx_err != OMX_ErrorNone)
     CLog::Log(LOGERROR, "%s:%s frames=%d err=%x", CLASSNAME, __func__, frames, omx_err);
@@ -370,8 +387,13 @@ void CAESinkPi::EnumerateDevicesEx(AEDeviceInfoList &list, bool force)
   for (unsigned int i=0; i<sizeof PassthroughSampleRates/sizeof *PassthroughSampleRates; i++)
     m_info.m_sampleRates.push_back(PassthroughSampleRates[i]);
   m_info.m_dataFormats.push_back(AE_FMT_FLOAT);
+  m_info.m_dataFormats.push_back(AE_FMT_S32NE);
+  m_info.m_dataFormats.push_back(AE_FMT_S16NE);
   m_info.m_dataFormats.push_back(AE_FMT_S32LE);
   m_info.m_dataFormats.push_back(AE_FMT_S16LE);
+  m_info.m_dataFormats.push_back(AE_FMT_FLOATP);
+  m_info.m_dataFormats.push_back(AE_FMT_S32NEP);
+  m_info.m_dataFormats.push_back(AE_FMT_S16NEP);
   m_info.m_dataFormats.push_back(AE_FMT_AC3);
   m_info.m_dataFormats.push_back(AE_FMT_DTS);
   m_info.m_dataFormats.push_back(AE_FMT_EAC3);
@@ -392,6 +414,9 @@ void CAESinkPi::EnumerateDevicesEx(AEDeviceInfoList &list, bool force)
   m_info.m_dataFormats.push_back(AE_FMT_FLOAT);
   m_info.m_dataFormats.push_back(AE_FMT_S32LE);
   m_info.m_dataFormats.push_back(AE_FMT_S16LE);
+  m_info.m_dataFormats.push_back(AE_FMT_FLOATP);
+  m_info.m_dataFormats.push_back(AE_FMT_S32NEP);
+  m_info.m_dataFormats.push_back(AE_FMT_S16NEP);
 
   list.push_back(m_info);
 }
-- 
1.9.3


From 67509ae7eddc9143964d7ba5da9ab9632c6ac382 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Mon, 30 Dec 2013 12:02:14 +0000
Subject: [PATCH 073/102] [rbp] Hardware accelerated resampling

This replaces the format conversion, up/down mixing and resampling code from ActiveAE with a GPU accelerated version.
Should significantly reduce CPU when using paplayer or dvdplayer.

Requires updated firmware
---
 .../Engines/ActiveAE/ActiveAEResample.cpp          |   5 +
 .../Engines/ActiveAE/ActiveAEResample.h            |   8 +
 .../Engines/ActiveAE/ActiveAEResamplePi.cpp        | 601 +++++++++++++++++++++
 .../Engines/ActiveAE/ActiveAEResamplePi.h          |  62 +++
 xbmc/cores/AudioEngine/Makefile.in                 |   1 +
 xbmc/cores/AudioEngine/Sinks/AESinkPi.cpp          |  14 +-
 xbmc/linux/OMXCore.cpp                             |   4 +-
 7 files changed, 686 insertions(+), 9 deletions(-)
 create mode 100644 xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResamplePi.cpp
 create mode 100644 xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResamplePi.h

diff --git a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResample.cpp b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResample.cpp
index 03946c3..5feeefb 100644
--- a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResample.cpp
+++ b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResample.cpp
@@ -18,6 +18,10 @@
  *
  */
 
+#include "system.h"
+
+#if !defined(TARGET_RASPBERRY_PI)
+
 #include "ActiveAEResample.h"
 #include "utils/log.h"
 
@@ -360,3 +364,4 @@ int CActiveAEResample::GetAVChannelIndex(enum AEChannel aechannel, uint64_t layo
 {
   return av_get_channel_layout_channel_index(layout, GetAVChannel(aechannel));
 }
+#endif
diff --git a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResample.h b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResample.h
index a471e02..5d37cc7 100644
--- a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResample.h
+++ b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResample.h
@@ -19,6 +19,8 @@
  *
  */
 
+#include "system.h"
+
 #include "cores/AudioEngine/Utils/AEChannelInfo.h"
 #include "cores/AudioEngine/Utils/AEAudioFormat.h"
 #include "cores/AudioEngine/Engines/ActiveAE/ActiveAEBuffer.h"
@@ -29,6 +31,10 @@ extern "C" {
 #include "libswresample/swresample.h"
 }
 
+#if defined(TARGET_RASPBERRY_PI)
+#include "ActiveAEResamplePi.h"
+#else
+
 namespace ActiveAE
 {
 
@@ -63,3 +69,5 @@ class CActiveAEResample
 };
 
 }
+
+#endif
diff --git a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResamplePi.cpp b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResamplePi.cpp
new file mode 100644
index 0000000..9a1e549
--- /dev/null
+++ b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResamplePi.cpp
@@ -0,0 +1,601 @@
+/*
+ *      Copyright (C) 2010-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "system.h"
+
+#if defined(TARGET_RASPBERRY_PI)
+
+#include "ActiveAEResample.h"
+#include "linux/RBP.h"
+#include "settings/Settings.h"
+#include "utils/log.h"
+
+extern "C" {
+#include "libavutil/channel_layout.h"
+#include "libavutil/opt.h"
+#include "libswresample/swresample.h"
+}
+
+//#define DEBUG_VERBOSE
+
+#define CLASSNAME "CActiveAEResamplePi"
+
+#define BUFFERSIZE (32*1024*2*8)
+
+//#define BENCHMARKING
+#ifdef BENCHMARKING
+#define LOGTIMEINIT(f) \
+  struct timespec now; \
+  uint64_t  Start, End; \
+  clock_gettime(CLOCK_MONOTONIC, &now); \
+  Start = ((int64_t)now.tv_sec * 1000000000L) + now.tv_nsec; \
+  const char *_filename = f;
+
+#define LOGTIME(n) \
+  clock_gettime(CLOCK_MONOTONIC, &now); \
+  End = ((int64_t)now.tv_sec * 1000000000L) + now.tv_nsec; \
+  CLog::Log(LOGNOTICE, "ActiveAE::%s %d - resample %s took %.0fms", __FUNCTION__, n, _filename, (End-Start)*1e-6); \
+  Start=End;
+#else
+#define LOGTIMEINIT(f)
+#define LOGTIME(n)
+#endif
+
+using namespace ActiveAE;
+
+CActiveAEResample::CActiveAEResample()
+{
+  CLog::Log(LOGINFO, "%s::%s", CLASSNAME, __func__);
+
+  m_Initialized = false;
+  m_last_src_fmt = AV_SAMPLE_FMT_NONE;
+  m_last_dst_fmt = AV_SAMPLE_FMT_NONE;
+  m_last_src_channels = 0;
+  m_last_dst_channels = 0;
+}
+
+CActiveAEResample::~CActiveAEResample()
+{
+  CLog::Log(LOGINFO, "%s::%s", CLASSNAME, __func__);
+  DeInit();
+}
+
+void CActiveAEResample::DeInit()
+{
+  CLog::Log(LOGDEBUG, "%s:%s", CLASSNAME, __func__);
+  if (m_Initialized)
+  {
+    m_omx_mixer.FlushAll();
+    m_omx_mixer.Deinitialize();
+    m_Initialized = false;
+  }
+}
+
+bool CActiveAEResample::Init(uint64_t dst_chan_layout, int dst_channels, int dst_rate, AVSampleFormat dst_fmt, int dst_bits, int dst_dither, uint64_t src_chan_layout, int src_channels, int src_rate, AVSampleFormat src_fmt, int src_bits, int src_dither, bool upmix, bool normalize, CAEChannelInfo *remapLayout, AEQuality quality)
+{
+  LOGTIMEINIT("x");
+
+  CLog::Log(LOGINFO, "%s::%s remap:%p chan:%d->%d rate:%d->%d format:%d->%d bits:%d->%d norm:%d upmix:%d", CLASSNAME, __func__, remapLayout, src_channels, dst_channels, src_rate, dst_rate, src_fmt, dst_fmt, src_bits, dst_bits, normalize, upmix);
+
+  if (src_bits == 0)
+  {
+    if (src_fmt == AV_SAMPLE_FMT_U8) src_bits = 8;
+    else if (src_fmt == AV_SAMPLE_FMT_S16) src_bits = 16;
+    else if (src_fmt == AV_SAMPLE_FMT_S32) src_bits = 32;
+    else if (src_fmt == AV_SAMPLE_FMT_FLT) src_bits = 32;
+  }
+  assert(src_bits && dst_bits);
+
+  m_dst_chan_layout = dst_chan_layout;
+  m_dst_channels = dst_channels;
+  m_dst_rate = dst_rate;
+  m_dst_fmt = dst_fmt;
+  m_dst_bits = dst_bits;
+  m_src_chan_layout = src_chan_layout;
+  m_src_channels = src_channels;
+  m_src_rate = src_rate;
+  m_src_fmt = src_fmt;
+  m_src_bits = src_bits;
+
+  if (m_dst_chan_layout == 0)
+    m_dst_chan_layout = av_get_default_channel_layout(m_dst_channels);
+  if (m_src_chan_layout == 0)
+    m_src_chan_layout = av_get_default_channel_layout(m_src_channels);
+
+  OMX_CONFIG_BRCMAUDIODOWNMIXCOEFFICIENTS8x8 mix;
+  OMX_INIT_STRUCTURE(mix);
+
+  assert(sizeof(mix.coeff)/sizeof(mix.coeff[0]) == 64);
+
+  LOGTIME(1);
+// this code is just uses ffmpeg to produce the 8x8 mixing matrix
+{
+  // dummy sample rate and format, as we only care about channel mapping
+  SwrContext *m_pContext = swr_alloc_set_opts(NULL, m_dst_chan_layout, AV_SAMPLE_FMT_FLT, 48000,
+                                                        m_src_chan_layout, AV_SAMPLE_FMT_FLT, 48000, 0, NULL);
+  if (!m_pContext)
+  {
+    CLog::Log(LOGERROR, "CActiveAEResample::Init - create context failed");
+    return false;
+  }
+  // tell resampler to clamp float values
+  // not required for sink stage (remapLayout == true)
+  if (!remapLayout && normalize)
+  {
+     av_opt_set_double(m_pContext, "rematrix_maxval", 1.0, 0);
+  }
+
+  if (remapLayout)
+  {
+    // one-to-one mapping of channels
+    // remapLayout is the layout of the sink, if the channel is in our src layout
+    // the channel is mapped by setting coef 1.0
+    double m_rematrix[AE_CH_MAX][AE_CH_MAX];
+    memset(m_rematrix, 0, sizeof(m_rematrix));
+    m_dst_chan_layout = 0;
+    for (unsigned int out=0; out<remapLayout->Count(); out++)
+    {
+      m_dst_chan_layout += (uint64_t) (1 << out);
+      int idx = GetAVChannelIndex((*remapLayout)[out], m_src_chan_layout);
+      if (idx >= 0)
+      {
+        m_rematrix[out][idx] = 1.0;
+      }
+    }
+
+    av_opt_set_int(m_pContext, "out_channel_count", m_dst_channels, 0);
+    av_opt_set_int(m_pContext, "out_channel_layout", m_dst_chan_layout, 0);
+
+    if (swr_set_matrix(m_pContext, (const double*)m_rematrix, AE_CH_MAX) < 0)
+    {
+      CLog::Log(LOGERROR, "CActiveAEResample::Init - setting channel matrix failed");
+      return false;
+    }
+  }
+  // stereo upmix
+  else if (upmix && m_src_channels == 2 && m_dst_channels > 2)
+  {
+    double m_rematrix[AE_CH_MAX][AE_CH_MAX];
+    memset(m_rematrix, 0, sizeof(m_rematrix));
+    for (int out=0; out<m_dst_channels; out++)
+    {
+      uint64_t out_chan = av_channel_layout_extract_channel(m_dst_chan_layout, out);
+      switch(out_chan)
+      {
+        case AV_CH_FRONT_LEFT:
+        case AV_CH_BACK_LEFT:
+        case AV_CH_SIDE_LEFT:
+          m_rematrix[out][0] = 1.0;
+          break;
+        case AV_CH_FRONT_RIGHT:
+        case AV_CH_BACK_RIGHT:
+        case AV_CH_SIDE_RIGHT:
+          m_rematrix[out][1] = 1.0;
+          break;
+        case AV_CH_FRONT_CENTER:
+          m_rematrix[out][0] = 0.5;
+          m_rematrix[out][1] = 0.5;
+          break;
+        case AV_CH_LOW_FREQUENCY:
+          m_rematrix[out][0] = 0.5;
+          m_rematrix[out][1] = 0.5;
+          break;
+        default:
+          break;
+      }
+    }
+
+    if (swr_set_matrix(m_pContext, (const double*)m_rematrix, AE_CH_MAX) < 0)
+    {
+      CLog::Log(LOGERROR, "CActiveAEResample::Init - setting channel matrix failed");
+      return false;
+    }
+  }
+
+  if (swr_init(m_pContext) < 0)
+  {
+    CLog::Log(LOGERROR, "CActiveAEResample::Init - init resampler failed");
+    return false;
+  }
+
+  const int samples = 8;
+  uint8_t *output, *input;
+  av_samples_alloc(&output, NULL, m_dst_channels, samples, AV_SAMPLE_FMT_FLT, 1);
+  av_samples_alloc(&input , NULL, m_src_channels, samples, AV_SAMPLE_FMT_FLT, 1);
+
+  // Produce "identity" samples
+  float *f = (float *)input;
+  for (int j=0; j < samples; j++)
+    for (int i=0; i < m_src_channels; i++)
+      *f++ = i == j ? 1.0f : 0.0f;
+
+  int ret = swr_convert(m_pContext, &output, samples, (const uint8_t **)&input, samples);
+  if (ret < 0)
+    CLog::Log(LOGERROR, "CActiveAEResample::Resample - resample failed");
+
+  f = (float *)output;
+  for (int j=0; j < samples; j++)
+    for (int i=0; i < m_dst_channels; i++)
+      mix.coeff[8*i+j] = *f++ * (1<<16);
+
+  for (int j=0; j < 8; j++)
+  {
+    char s[128] = {}, *t=s;
+    for (int i=0; i < 8; i++)
+      t += sprintf(t, "% 6.2f ", mix.coeff[j*8+i] * (1.0/0x10000));
+    CLog::Log(LOGINFO, "%s::%s  %s", CLASSNAME, __func__, s);
+  }
+  av_freep(&input);
+  av_freep(&output);
+  swr_free(&m_pContext);
+}
+  LOGTIME(2);
+
+  // This may be called before Application calls g_RBP.Initialise, so call it here too
+  g_RBP.Initialize();
+
+  OMX_ERRORTYPE omx_err   = OMX_ErrorNone;
+
+  if (!m_omx_mixer.Initialize("OMX.broadcom.audio_mixer", OMX_IndexParamAudioInit))
+    CLog::Log(LOGERROR, "%s::%s - m_omx_mixer.Initialize omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+
+  LOGTIME(3);
+
+  OMX_INIT_STRUCTURE(m_pcm_input);
+  m_pcm_input.nPortIndex            = m_omx_mixer.GetInputPort();
+  m_pcm_input.eNumData              = OMX_NumericalDataSigned;
+  m_pcm_input.eEndian               = OMX_EndianLittle;
+  m_pcm_input.bInterleaved          = OMX_TRUE;
+  m_pcm_input.nBitPerSample         = m_src_bits;
+  m_pcm_input.ePCMMode              = m_src_fmt == AV_SAMPLE_FMT_FLT ? (OMX_AUDIO_PCMMODETYPE)0x8000 : OMX_AUDIO_PCMModeLinear;
+  m_pcm_input.nChannels             = src_channels;
+  m_pcm_input.nSamplingRate         = src_rate;
+
+  omx_err = m_omx_mixer.SetParameter(OMX_IndexParamAudioPcm, &m_pcm_input);
+  if (omx_err != OMX_ErrorNone)
+    CLog::Log(LOGERROR, "%s::%s - error m_omx_mixer in SetParameter omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+
+  OMX_INIT_STRUCTURE(m_pcm_output);
+  m_pcm_output.nPortIndex            = m_omx_mixer.GetOutputPort();
+  m_pcm_output.eNumData              = OMX_NumericalDataSigned;
+  m_pcm_output.eEndian               = OMX_EndianLittle;
+  m_pcm_output.bInterleaved          = OMX_TRUE;
+  m_pcm_output.nBitPerSample         = m_dst_bits;
+  m_pcm_output.ePCMMode              = m_dst_fmt == AV_SAMPLE_FMT_FLT ? (OMX_AUDIO_PCMMODETYPE)0x8000 : OMX_AUDIO_PCMModeLinear;
+  m_pcm_output.nChannels             = dst_channels;
+  m_pcm_output.nSamplingRate         = dst_rate;
+
+  omx_err = m_omx_mixer.SetParameter(OMX_IndexParamAudioPcm, &m_pcm_output);
+  if (omx_err != OMX_ErrorNone)
+    CLog::Log(LOGERROR, "%s::%s - error m_omx_mixer out SetParameter omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+
+  LOGTIME(4);
+
+  mix.nPortIndex = m_omx_mixer.GetInputPort();
+  omx_err = m_omx_mixer.SetConfig(OMX_IndexConfigBrcmAudioDownmixCoefficients8x8, &mix);
+  if (omx_err != OMX_ErrorNone)
+  {
+    CLog::Log(LOGERROR, "%s::%s - error setting mixer OMX_IndexConfigBrcmAudioDownmixCoefficients, error 0x%08x\n",
+              CLASSNAME, __func__, omx_err);
+    return false;
+  }
+
+  // set up the number/size of buffers for decoder input
+  OMX_PARAM_PORTDEFINITIONTYPE port_param;
+  OMX_INIT_STRUCTURE(port_param);
+  port_param.nPortIndex = m_omx_mixer.GetInputPort();
+
+  omx_err = m_omx_mixer.GetParameter(OMX_IndexParamPortDefinition, &port_param);
+  if (omx_err != OMX_ErrorNone)
+    CLog::Log(LOGERROR, "%s:%s - error get OMX_IndexParamPortDefinition (input) omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+
+  port_param.nBufferCountActual = std::max((unsigned int)port_param.nBufferCountMin, (unsigned int)1);
+  port_param.nBufferSize = BUFFERSIZE;
+
+  omx_err = m_omx_mixer.SetParameter(OMX_IndexParamPortDefinition, &port_param);
+  if (omx_err != OMX_ErrorNone)
+    CLog::Log(LOGERROR, "%s:%s - error set OMX_IndexParamPortDefinition (input) omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+
+  LOGTIME(5);
+
+  omx_err = m_omx_mixer.AllocInputBuffers();
+  if (omx_err != OMX_ErrorNone)
+    CLog::Log(LOGERROR, "%s:%s - Error alloc buffers 0x%08x", CLASSNAME, __func__, omx_err);
+
+  LOGTIME(6);
+
+  // set up the number/size of buffers for decoder output
+  OMX_INIT_STRUCTURE(port_param);
+  port_param.nPortIndex = m_omx_mixer.GetOutputPort();
+
+  omx_err = m_omx_mixer.GetParameter(OMX_IndexParamPortDefinition, &port_param);
+  if (omx_err != OMX_ErrorNone)
+    CLog::Log(LOGERROR, "%s:%s - error get OMX_IndexParamPortDefinition (input) omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+
+  port_param.nBufferCountActual = std::max((unsigned int)port_param.nBufferCountMin, (unsigned int)1);
+  port_param.nBufferSize = BUFFERSIZE;
+
+  omx_err = m_omx_mixer.SetParameter(OMX_IndexParamPortDefinition, &port_param);
+  if (omx_err != OMX_ErrorNone)
+    CLog::Log(LOGERROR, "%s:%s - error set OMX_IndexParamPortDefinition (input) omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+
+  LOGTIME(7);
+
+  omx_err = m_omx_mixer.AllocOutputBuffers();
+  if (omx_err != OMX_ErrorNone)
+    CLog::Log(LOGERROR, "%s:%s - Error alloc buffers 0x%08x", CLASSNAME, __func__, omx_err);
+
+  LOGTIME(8);
+
+  omx_err = m_omx_mixer.SetStateForComponent(OMX_StateExecuting);
+  if (omx_err != OMX_ErrorNone)
+    CLog::Log(LOGERROR, "%s:%s - m_omx_mixer OMX_StateExecuting omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+
+  LOGTIME(9);
+
+  m_Initialized = true;
+
+  return true;
+}
+
+int CActiveAEResample::Resample(uint8_t **dst_buffer, int dst_samples, uint8_t **src_buffer, int src_samples, double ratio)
+{
+  #ifdef DEBUG_VERBOSE
+  CLog::Log(LOGINFO, "%s::%s samples:%d->%d (%.2f)", CLASSNAME, __func__, src_samples, dst_samples, ratio);
+  #endif
+  if (!m_Initialized)
+    return 0;
+  OMX_ERRORTYPE omx_err   = OMX_ErrorNone;
+
+  const int s_pitch = m_pcm_input.nChannels * m_src_bits >> 3;
+  const int d_pitch = m_pcm_output.nChannels * m_dst_bits >> 3;
+  int sent = 0;
+  int received = 0;
+  while (sent < src_samples)
+  {
+    OMX_BUFFERHEADERTYPE *omx_buffer = NULL;
+    OMX_BUFFERHEADERTYPE *m_encoded_buffer = NULL;
+
+    omx_buffer = m_omx_mixer.GetInputBuffer(1000);
+    if (omx_buffer == NULL)
+      return false;
+
+    const int max_src_samples = BUFFERSIZE / s_pitch;
+    const int max_dst_samples = (long long)(BUFFERSIZE/d_pitch) * m_src_rate / (m_dst_rate + m_src_rate-1);
+    int send = std::min(std::min(max_dst_samples, max_src_samples), src_samples - sent);
+
+    omx_buffer->nOffset = 0;
+    omx_buffer->nFlags = OMX_BUFFERFLAG_EOS;
+    omx_buffer->nFilledLen = send * s_pitch;
+
+    assert(omx_buffer->nFilledLen > 0 && omx_buffer->nFilledLen <= omx_buffer->nAllocLen);
+
+    if (omx_buffer->nFilledLen)
+    {
+      memcpy(omx_buffer->pBuffer, src_buffer[0] + sent * s_pitch, omx_buffer->nFilledLen);
+      sent += send;
+    }
+
+    omx_err = m_omx_mixer.EmptyThisBuffer(omx_buffer);
+    if (omx_err != OMX_ErrorNone)
+    {
+      CLog::Log(LOGERROR, "%s::%s OMX_EmptyThisBuffer() failed with result(0x%x)", CLASSNAME, __func__, omx_err);
+      return false;
+    }
+
+    m_encoded_buffer = m_omx_mixer.GetOutputBuffer();
+
+    if (!m_encoded_buffer)
+    {
+      CLog::Log(LOGERROR, "%s::%s no output buffer", CLASSNAME, __func__);
+      return false;
+    }
+
+    omx_err = m_omx_mixer.FillThisBuffer(m_encoded_buffer);
+    if (omx_err != OMX_ErrorNone)
+      return false;
+
+    omx_err = m_omx_mixer.WaitForOutputDone(1000);
+    if (omx_err != OMX_ErrorNone)
+    {
+      CLog::Log(LOGERROR, "%s::%s m_omx_mixer.WaitForOutputDone result(0x%x)", CLASSNAME, __func__, omx_err);
+      return false;
+    }
+    assert(m_encoded_buffer->nFilledLen > 0 && m_encoded_buffer->nFilledLen <= m_encoded_buffer->nAllocLen);
+
+    if (m_omx_mixer.BadState())
+    {
+      CLog::Log(LOGERROR, "%s::%s m_omx_mixer.BadState", CLASSNAME, __func__);
+      return false;
+    }
+
+    if (m_encoded_buffer->nFilledLen)
+    {
+      memcpy(dst_buffer[0] + received * d_pitch, m_encoded_buffer->pBuffer, m_encoded_buffer->nFilledLen);
+      received += m_encoded_buffer->nFilledLen / d_pitch;
+    }
+  }
+  #ifdef DEBUG_VERBOSE
+  CLog::Log(LOGINFO, "%s::%s format:%d->%d rate:%d->%d chan:%d->%d samples %d->%d (%f) %d =%d", CLASSNAME, __func__,
+    (int)m_src_fmt, (int)m_dst_fmt, m_src_rate, m_dst_rate, m_src_channels, m_dst_channels, src_samples, dst_samples, ratio, m_Initialized, received);
+  #endif
+  return received;
+}
+
+int64_t CActiveAEResample::GetDelay(int64_t base)
+{
+  int ret = 0;
+  #ifdef DEBUG_VERBOSE
+  CLog::Log(LOGINFO, "%s::%s = %d", CLASSNAME, __func__, ret);
+  #endif
+  return ret;
+}
+
+int CActiveAEResample::GetBufferedSamples()
+{
+  int ret = 0;
+  #ifdef DEBUG_VERBOSE
+  CLog::Log(LOGINFO, "%s::%s = %d", CLASSNAME, __func__, ret);
+  #endif
+  return ret;
+}
+
+int CActiveAEResample::CalcDstSampleCount(int src_samples, int dst_rate, int src_rate)
+{
+  int ret = ((long long)src_samples * dst_rate + src_rate-1) / src_rate;
+  #ifdef DEBUG_VERBOSE
+  CLog::Log(LOGINFO, "%s::%s = %d", CLASSNAME, __func__, ret);
+  #endif
+  return ret;
+}
+
+int CActiveAEResample::GetSrcBufferSize(int samples)
+{
+  int ret = 0;
+  #ifdef DEBUG_VERBOSE
+  CLog::Log(LOGINFO, "%s::%s = %d", CLASSNAME, __func__, ret);
+  #endif
+  return ret;
+}
+
+int CActiveAEResample::GetDstBufferSize(int samples)
+{
+  int ret = CalcDstSampleCount(samples, m_dst_rate, m_src_rate);
+  #ifdef DEBUG_VERBOSE
+  CLog::Log(LOGINFO, "%s::%s = %d", CLASSNAME, __func__, ret);
+  #endif
+  return ret;
+}
+
+uint64_t CActiveAEResample::GetAVChannelLayout(CAEChannelInfo &info)
+{
+  #ifdef DEBUG_VERBOSE
+  CLog::Log(LOGINFO, "%s::%s", CLASSNAME, __func__);
+  #endif
+  uint64_t channelLayout = 0;
+  if (info.HasChannel(AE_CH_FL))   channelLayout |= AV_CH_FRONT_LEFT;
+  if (info.HasChannel(AE_CH_FR))   channelLayout |= AV_CH_FRONT_RIGHT;
+  if (info.HasChannel(AE_CH_FC))   channelLayout |= AV_CH_FRONT_CENTER;
+  if (info.HasChannel(AE_CH_LFE))  channelLayout |= AV_CH_LOW_FREQUENCY;
+  if (info.HasChannel(AE_CH_BL))   channelLayout |= AV_CH_BACK_LEFT;
+  if (info.HasChannel(AE_CH_BR))   channelLayout |= AV_CH_BACK_RIGHT;
+  if (info.HasChannel(AE_CH_FLOC)) channelLayout |= AV_CH_FRONT_LEFT_OF_CENTER;
+  if (info.HasChannel(AE_CH_FROC)) channelLayout |= AV_CH_FRONT_RIGHT_OF_CENTER;
+  if (info.HasChannel(AE_CH_BC))   channelLayout |= AV_CH_BACK_CENTER;
+  if (info.HasChannel(AE_CH_SL))   channelLayout |= AV_CH_SIDE_LEFT;
+  if (info.HasChannel(AE_CH_SR))   channelLayout |= AV_CH_SIDE_RIGHT;
+  if (info.HasChannel(AE_CH_TC))   channelLayout |= AV_CH_TOP_CENTER;
+  if (info.HasChannel(AE_CH_TFL))  channelLayout |= AV_CH_TOP_FRONT_LEFT;
+  if (info.HasChannel(AE_CH_TFC))  channelLayout |= AV_CH_TOP_FRONT_CENTER;
+  if (info.HasChannel(AE_CH_TFR))  channelLayout |= AV_CH_TOP_FRONT_RIGHT;
+  if (info.HasChannel(AE_CH_TBL))   channelLayout |= AV_CH_TOP_BACK_LEFT;
+  if (info.HasChannel(AE_CH_TBC))   channelLayout |= AV_CH_TOP_BACK_CENTER;
+  if (info.HasChannel(AE_CH_TBR))   channelLayout |= AV_CH_TOP_BACK_RIGHT;
+
+  return channelLayout;
+}
+
+AVSampleFormat CActiveAEResample::GetAVSampleFormat(AEDataFormat format)
+{
+  #ifdef DEBUG_VERBOSE
+  CLog::Log(LOGINFO, "%s::%s", CLASSNAME, __func__);
+  #endif
+  if      (format == AE_FMT_U8)     return AV_SAMPLE_FMT_U8;
+  else if (format == AE_FMT_S16NE)  return AV_SAMPLE_FMT_S16;
+  else if (format == AE_FMT_S32NE)  return AV_SAMPLE_FMT_S32;
+  else if (format == AE_FMT_S24NE4) return AV_SAMPLE_FMT_S32;
+  else if (format == AE_FMT_FLOAT)  return AV_SAMPLE_FMT_FLT;
+  else if (format == AE_FMT_DOUBLE) return AV_SAMPLE_FMT_DBL;
+
+  else if (format == AE_FMT_U8P)     return AV_SAMPLE_FMT_U8P;
+  else if (format == AE_FMT_S16NEP)  return AV_SAMPLE_FMT_S16P;
+  else if (format == AE_FMT_S32NEP)  return AV_SAMPLE_FMT_S32P;
+  else if (format == AE_FMT_S24NE4P) return AV_SAMPLE_FMT_S32P;
+  else if (format == AE_FMT_FLOATP)  return AV_SAMPLE_FMT_FLTP;
+  else if (format == AE_FMT_DOUBLEP) return AV_SAMPLE_FMT_DBLP;
+
+  if (AE_IS_PLANAR(format))
+    return AV_SAMPLE_FMT_FLTP;
+  else
+    return AV_SAMPLE_FMT_FLT;
+}
+
+AEDataFormat CActiveAEResample::GetAESampleFormat(AVSampleFormat format, int bits)
+{
+  #ifdef DEBUG_VERBOSE
+  CLog::Log(LOGINFO, "%s::%s", CLASSNAME, __func__);
+  #endif
+  if      (format == AV_SAMPLE_FMT_U8)   return AE_FMT_U8;
+  else if (format == AV_SAMPLE_FMT_S16)  return AE_FMT_S16NE;
+  else if (format == AV_SAMPLE_FMT_S32 && bits == 32)  return AE_FMT_S32NE;
+  else if (format == AV_SAMPLE_FMT_S32 && bits == 24)  return AE_FMT_S24NE4;
+  else if (format == AV_SAMPLE_FMT_FLT)  return AE_FMT_FLOAT;
+  else if (format == AV_SAMPLE_FMT_DBL)  return AE_FMT_DOUBLE;
+
+  else if (format == AV_SAMPLE_FMT_U8P)   return AE_FMT_U8P;
+  else if (format == AV_SAMPLE_FMT_S16P)  return AE_FMT_S16NEP;
+  else if (format == AV_SAMPLE_FMT_S32P && bits == 32)  return AE_FMT_S32NEP;
+  else if (format == AV_SAMPLE_FMT_S32P && bits == 24)  return AE_FMT_S24NE4P;
+  else if (format == AV_SAMPLE_FMT_FLTP)  return AE_FMT_FLOATP;
+  else if (format == AV_SAMPLE_FMT_DBLP)  return AE_FMT_DOUBLEP;
+
+  CLog::Log(LOGERROR, "CActiveAEResample::GetAESampleFormat - format not supported");
+  return AE_FMT_INVALID;
+}
+
+uint64_t CActiveAEResample::GetAVChannel(enum AEChannel aechannel)
+{
+  #ifdef DEBUG_VERBOSE
+  CLog::Log(LOGINFO, "%s::%s", CLASSNAME, __func__);
+  #endif
+  switch (aechannel)
+  {
+  case AE_CH_FL:   return AV_CH_FRONT_LEFT;
+  case AE_CH_FR:   return AV_CH_FRONT_RIGHT;
+  case AE_CH_FC:   return AV_CH_FRONT_CENTER;
+  case AE_CH_LFE:  return AV_CH_LOW_FREQUENCY;
+  case AE_CH_BL:   return AV_CH_BACK_LEFT;
+  case AE_CH_BR:   return AV_CH_BACK_RIGHT;
+  case AE_CH_FLOC: return AV_CH_FRONT_LEFT_OF_CENTER;
+  case AE_CH_FROC: return AV_CH_FRONT_RIGHT_OF_CENTER;
+  case AE_CH_BC:   return AV_CH_BACK_CENTER;
+  case AE_CH_SL:   return AV_CH_SIDE_LEFT;
+  case AE_CH_SR:   return AV_CH_SIDE_RIGHT;
+  case AE_CH_TC:   return AV_CH_TOP_CENTER;
+  case AE_CH_TFL:  return AV_CH_TOP_FRONT_LEFT;
+  case AE_CH_TFC:  return AV_CH_TOP_FRONT_CENTER;
+  case AE_CH_TFR:  return AV_CH_TOP_FRONT_RIGHT;
+  case AE_CH_TBL:  return AV_CH_TOP_BACK_LEFT;
+  case AE_CH_TBC:  return AV_CH_TOP_BACK_CENTER;
+  case AE_CH_TBR:  return AV_CH_TOP_BACK_RIGHT;
+  default:
+    return 0;
+  }
+}
+
+int CActiveAEResample::GetAVChannelIndex(enum AEChannel aechannel, uint64_t layout)
+{
+  #ifdef DEBUG_VERBOSE
+  CLog::Log(LOGINFO, "%s::%s", CLASSNAME, __func__);
+  #endif
+  return av_get_channel_layout_channel_index(layout, GetAVChannel(aechannel));
+}
+
+#endif
diff --git a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResamplePi.h b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResamplePi.h
new file mode 100644
index 0000000..47a9e08
--- /dev/null
+++ b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResamplePi.h
@@ -0,0 +1,62 @@
+#pragma once
+/*
+ *      Copyright (C) 2010-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "linux/OMXCore.h"
+
+namespace ActiveAE
+{
+
+class CActiveAEResample
+{
+public:
+  CActiveAEResample();
+  virtual ~CActiveAEResample();
+  bool Init(uint64_t dst_chan_layout, int dst_channels, int dst_rate, AVSampleFormat dst_fmt, int dst_bits, int dst_dither, uint64_t src_chan_layout, int src_channels, int src_rate, AVSampleFormat src_fmt, int src_bits, int src_dither, bool upmix, bool normalize, CAEChannelInfo *remapLayout, AEQuality quality);
+  int Resample(uint8_t **dst_buffer, int dst_samples, uint8_t **src_buffer, int src_samples, double ratio);
+  int64_t GetDelay(int64_t base);
+  int GetBufferedSamples();
+  int CalcDstSampleCount(int src_samples, int dst_rate, int src_rate);
+  int GetSrcBufferSize(int samples);
+  int GetDstBufferSize(int samples);
+  static uint64_t GetAVChannelLayout(CAEChannelInfo &info);
+//  static CAEChannelInfo GetAEChannelLayout(uint64_t layout);
+  static AVSampleFormat GetAVSampleFormat(AEDataFormat format);
+  static AEDataFormat GetAESampleFormat(AVSampleFormat format, int bits);
+  static uint64_t GetAVChannel(enum AEChannel aechannel);
+  int GetAVChannelIndex(enum AEChannel aechannel, uint64_t layout);
+
+protected:
+  void DeInit();
+  uint64_t m_src_chan_layout, m_dst_chan_layout;
+  int m_src_rate, m_dst_rate;
+  int m_src_channels, m_dst_channels;
+  AVSampleFormat m_src_fmt, m_dst_fmt;
+  int m_src_bits, m_dst_bits;
+
+  OMX_AUDIO_PARAM_PCMMODETYPE m_pcm_input;
+  OMX_AUDIO_PARAM_PCMMODETYPE m_pcm_output;
+  COMXCoreComponent    m_omx_mixer;
+  bool                 m_Initialized;
+  AVSampleFormat m_last_src_fmt, m_last_dst_fmt;
+  int m_last_src_channels, m_last_dst_channels;
+};
+
+}
diff --git a/xbmc/cores/AudioEngine/Makefile.in b/xbmc/cores/AudioEngine/Makefile.in
index 581249e..20c05bb 100644
--- a/xbmc/cores/AudioEngine/Makefile.in
+++ b/xbmc/cores/AudioEngine/Makefile.in
@@ -31,6 +31,7 @@ SRCS += Engines/ActiveAE/ActiveAESink.cpp
 SRCS += Engines/ActiveAE/ActiveAEStream.cpp
 SRCS += Engines/ActiveAE/ActiveAESound.cpp
 SRCS += Engines/ActiveAE/ActiveAEResample.cpp
+SRCS += Engines/ActiveAE/ActiveAEResamplePi.cpp
 SRCS += Engines/ActiveAE/ActiveAEBuffer.cpp
 
 ifeq (@USE_ANDROID@,1)
diff --git a/xbmc/cores/AudioEngine/Sinks/AESinkPi.cpp b/xbmc/cores/AudioEngine/Sinks/AESinkPi.cpp
index 5a45653..2733054 100644
--- a/xbmc/cores/AudioEngine/Sinks/AESinkPi.cpp
+++ b/xbmc/cores/AudioEngine/Sinks/AESinkPi.cpp
@@ -78,9 +78,9 @@ static void SetAudioProps(bool stream_channels, uint32_t channel_map)
   CLog::Log(LOGDEBUG, "%s:%s hdmi_stream_channels %d hdmi_channel_map %08x", CLASSNAME, __func__, stream_channels, channel_map);
 }
 
-static uint32_t GetChannelMap(AEAudioFormat &format, bool passthrough)
+static uint32_t GetChannelMap(const CAEChannelInfo &channelLayout, bool passthrough)
 {
-  unsigned int channels = format.m_channelLayout.Count();
+  unsigned int channels = channelLayout.Count();
   uint32_t channel_map = 0;
   if (passthrough)
     return 0;
@@ -119,12 +119,12 @@ static uint32_t GetChannelMap(AEAudioFormat &format, bool passthrough)
   // According to CEA-861-D only RL and RR are known. In case of a format having SL and SR channels
   // but no BR BL channels, we use the wide map in order to open only the num of channels really
   // needed.
-  if (format.m_channelLayout.HasChannel(AE_CH_BL) && !format.m_channelLayout.HasChannel(AE_CH_SL))
+  if (channelLayout.HasChannel(AE_CH_BL) && !channelLayout.HasChannel(AE_CH_SL))
     map = map_back;
 
   for (unsigned int i = 0; i < channels; ++i)
   {
-    AEChannel c = format.m_channelLayout[i];
+    AEChannel c = channelLayout[i];
     unsigned int chan = 0;
     if ((unsigned int)c < sizeof map_normal / sizeof *map_normal)
       chan = map[(unsigned int)c];
@@ -155,9 +155,9 @@ static uint32_t GetChannelMap(AEAudioFormat &format, bool passthrough)
     0xff, // 7
     0x13, // 7.1
   };
-  uint8_t cea = format.m_channelLayout.HasChannel(AE_CH_LFE) ? cea_map_lfe[channels] : cea_map[channels];
+  uint8_t cea = channelLayout.HasChannel(AE_CH_LFE) ? cea_map_lfe[channels] : cea_map[channels];
   if (cea == 0xff)
-    CLog::Log(LOGERROR, "%s::%s - Unexpected CEA mapping %d,%d", CLASSNAME, __func__, format.m_channelLayout.HasChannel(AE_CH_LFE), channels);
+    CLog::Log(LOGERROR, "%s::%s - Unexpected CEA mapping %d,%d", CLASSNAME, __func__, channelLayout.HasChannel(AE_CH_LFE), channels);
 
   channel_map |= cea << 24;
 
@@ -191,7 +191,7 @@ bool CAESinkPi::Initialize(AEAudioFormat &format, std::string &device)
   format.m_frames        = format.m_sampleRate * AUDIO_PLAYBUFFER / NUM_OMX_BUFFERS;
   format.m_frameSamples  = format.m_frames * channels;
 
-  SetAudioProps(m_passthrough, GetChannelMap(format, m_passthrough));
+  SetAudioProps(m_passthrough, GetChannelMap(format.m_channelLayout, m_passthrough));
 
   m_format = format;
   m_sinkbuffer_sec_per_byte = 1.0 / (double)(m_format.m_frameSize * m_format.m_sampleRate);
diff --git a/xbmc/linux/OMXCore.cpp b/xbmc/linux/OMXCore.cpp
index 99e407a..8d3c86a 100644
--- a/xbmc/linux/OMXCore.cpp
+++ b/xbmc/linux/OMXCore.cpp
@@ -448,7 +448,7 @@ void COMXCoreComponent::FlushAll()
 
 void COMXCoreComponent::FlushInput()
 {
-  if(!m_handle)
+  if(!m_handle || m_resource_error)
     return;
 
   OMX_ERRORTYPE omx_err = OMX_ErrorNone;
@@ -470,7 +470,7 @@ void COMXCoreComponent::FlushInput()
 
 void COMXCoreComponent::FlushOutput()
 {
-  if(!m_handle)
+  if(!m_handle || m_resource_error)
     return;
 
   OMX_ERRORTYPE omx_err = OMX_ErrorNone;
-- 
1.9.3


From e32cc71fee0020cee3013e5ecf2f9b02cb25d45b Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Sun, 1 Jun 2014 12:15:17 +0100
Subject: [PATCH 074/102] [resamplepi] Support planar formats

---
 .../Engines/ActiveAE/ActiveAEResamplePi.cpp        | 101 ++++++++++++---------
 1 file changed, 59 insertions(+), 42 deletions(-)

diff --git a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResamplePi.cpp b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResamplePi.cpp
index 9a1e549..1604030 100644
--- a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResamplePi.cpp
+++ b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResamplePi.cpp
@@ -88,20 +88,36 @@ void CActiveAEResample::DeInit()
   }
 }
 
+static int format_to_bits(AVSampleFormat fmt)
+{
+  switch (fmt)
+  {
+  case AV_SAMPLE_FMT_U8:
+  case AV_SAMPLE_FMT_U8P:
+    return 8;
+  case AV_SAMPLE_FMT_S16:
+  case AV_SAMPLE_FMT_S16P:
+    return 16;
+  case AV_SAMPLE_FMT_S32:
+  case AV_SAMPLE_FMT_S32P:
+  case AV_SAMPLE_FMT_FLT:
+  case AV_SAMPLE_FMT_FLTP:
+    return 32;
+  default:
+    assert(0);
+  }
+  return 0;
+}
+
 bool CActiveAEResample::Init(uint64_t dst_chan_layout, int dst_channels, int dst_rate, AVSampleFormat dst_fmt, int dst_bits, int dst_dither, uint64_t src_chan_layout, int src_channels, int src_rate, AVSampleFormat src_fmt, int src_bits, int src_dither, bool upmix, bool normalize, CAEChannelInfo *remapLayout, AEQuality quality)
 {
   LOGTIMEINIT("x");
 
   CLog::Log(LOGINFO, "%s::%s remap:%p chan:%d->%d rate:%d->%d format:%d->%d bits:%d->%d norm:%d upmix:%d", CLASSNAME, __func__, remapLayout, src_channels, dst_channels, src_rate, dst_rate, src_fmt, dst_fmt, src_bits, dst_bits, normalize, upmix);
 
-  if (src_bits == 0)
-  {
-    if (src_fmt == AV_SAMPLE_FMT_U8) src_bits = 8;
-    else if (src_fmt == AV_SAMPLE_FMT_S16) src_bits = 16;
-    else if (src_fmt == AV_SAMPLE_FMT_S32) src_bits = 32;
-    else if (src_fmt == AV_SAMPLE_FMT_FLT) src_bits = 32;
-  }
-  assert(src_bits && dst_bits);
+  // replace passed in number of bits with correct ones
+  src_bits = format_to_bits(src_fmt);
+  dst_bits = format_to_bits(dst_fmt);
 
   m_dst_chan_layout = dst_chan_layout;
   m_dst_channels = dst_channels;
@@ -139,7 +155,7 @@ bool CActiveAEResample::Init(uint64_t dst_chan_layout, int dst_channels, int dst
   // not required for sink stage (remapLayout == true)
   if (!remapLayout && normalize)
   {
-     av_opt_set_double(m_pContext, "rematrix_maxval", 1.0, 0);
+    av_opt_set_double(m_pContext, "rematrix_maxval", 1.0, 0);
   }
 
   if (remapLayout)
@@ -264,7 +280,13 @@ bool CActiveAEResample::Init(uint64_t dst_chan_layout, int dst_channels, int dst
   m_pcm_input.eEndian               = OMX_EndianLittle;
   m_pcm_input.bInterleaved          = OMX_TRUE;
   m_pcm_input.nBitPerSample         = m_src_bits;
-  m_pcm_input.ePCMMode              = m_src_fmt == AV_SAMPLE_FMT_FLT ? (OMX_AUDIO_PCMMODETYPE)0x8000 : OMX_AUDIO_PCMModeLinear;
+  // 0x8000 = float, 0x10000 = planar
+  uint32_t flags = 0;
+  if (m_src_fmt == AV_SAMPLE_FMT_FLT || m_src_fmt == AV_SAMPLE_FMT_FLTP)
+   flags |= 0x8000;
+  if (m_src_fmt >= AV_SAMPLE_FMT_U8P)
+   flags |= 0x10000;
+  m_pcm_input.ePCMMode              = flags == 0 ? OMX_AUDIO_PCMModeLinear : (OMX_AUDIO_PCMMODETYPE)flags;
   m_pcm_input.nChannels             = src_channels;
   m_pcm_input.nSamplingRate         = src_rate;
 
@@ -278,7 +300,12 @@ bool CActiveAEResample::Init(uint64_t dst_chan_layout, int dst_channels, int dst
   m_pcm_output.eEndian               = OMX_EndianLittle;
   m_pcm_output.bInterleaved          = OMX_TRUE;
   m_pcm_output.nBitPerSample         = m_dst_bits;
-  m_pcm_output.ePCMMode              = m_dst_fmt == AV_SAMPLE_FMT_FLT ? (OMX_AUDIO_PCMMODETYPE)0x8000 : OMX_AUDIO_PCMModeLinear;
+  flags = 0;
+  if (m_dst_fmt == AV_SAMPLE_FMT_FLT || m_dst_fmt == AV_SAMPLE_FMT_FLTP)
+   flags |= 0x8000;
+  if (m_dst_fmt >= AV_SAMPLE_FMT_U8P)
+   flags |= 0x10000;
+  m_pcm_output.ePCMMode              = flags == 0 ? OMX_AUDIO_PCMModeLinear : (OMX_AUDIO_PCMMODETYPE)flags;
   m_pcm_output.nChannels             = dst_channels;
   m_pcm_output.nSamplingRate         = dst_rate;
 
@@ -364,8 +391,13 @@ int CActiveAEResample::Resample(uint8_t **dst_buffer, int dst_samples, uint8_t *
     return 0;
   OMX_ERRORTYPE omx_err   = OMX_ErrorNone;
 
-  const int s_pitch = m_pcm_input.nChannels * m_src_bits >> 3;
-  const int d_pitch = m_pcm_output.nChannels * m_dst_bits >> 3;
+  const int s_planes = m_src_fmt >= AV_SAMPLE_FMT_U8P ? m_src_channels : 1;
+  const int d_planes = m_dst_fmt >= AV_SAMPLE_FMT_U8P ? m_dst_channels : 1;
+  const int s_chans  = m_src_fmt >= AV_SAMPLE_FMT_U8P ? 1 : m_src_channels;
+  const int d_chans  = m_dst_fmt >= AV_SAMPLE_FMT_U8P ? 1 : m_dst_channels;
+  const int s_pitch = s_chans * m_src_bits >> 3;
+  const int d_pitch = d_chans * m_dst_bits >> 3;
+
   int sent = 0;
   int received = 0;
   while (sent < src_samples)
@@ -377,19 +409,23 @@ int CActiveAEResample::Resample(uint8_t **dst_buffer, int dst_samples, uint8_t *
     if (omx_buffer == NULL)
       return false;
 
-    const int max_src_samples = BUFFERSIZE / s_pitch;
-    const int max_dst_samples = (long long)(BUFFERSIZE/d_pitch) * m_src_rate / (m_dst_rate + m_src_rate-1);
+    const int s_samplesize = m_src_channels * m_src_bits >> 3;
+    const int d_samplesize = m_dst_channels * m_dst_bits >> 3;
+    const int max_src_samples = BUFFERSIZE / s_samplesize;
+    const int max_dst_samples = (long long)(BUFFERSIZE / d_samplesize) * m_src_rate / (m_dst_rate + m_src_rate-1);
     int send = std::min(std::min(max_dst_samples, max_src_samples), src_samples - sent);
 
     omx_buffer->nOffset = 0;
     omx_buffer->nFlags = OMX_BUFFERFLAG_EOS;
-    omx_buffer->nFilledLen = send * s_pitch;
+    omx_buffer->nFilledLen = send * s_samplesize;
 
     assert(omx_buffer->nFilledLen > 0 && omx_buffer->nFilledLen <= omx_buffer->nAllocLen);
 
     if (omx_buffer->nFilledLen)
     {
-      memcpy(omx_buffer->pBuffer, src_buffer[0] + sent * s_pitch, omx_buffer->nFilledLen);
+      int planesize = omx_buffer->nFilledLen / s_planes;
+      for (int i=0; i < s_planes; i++)
+        memcpy((uint8_t *)omx_buffer->pBuffer + i * planesize, src_buffer[i] + sent * s_pitch, planesize);
       sent += send;
     }
 
@@ -428,8 +464,10 @@ int CActiveAEResample::Resample(uint8_t **dst_buffer, int dst_samples, uint8_t *
 
     if (m_encoded_buffer->nFilledLen)
     {
-      memcpy(dst_buffer[0] + received * d_pitch, m_encoded_buffer->pBuffer, m_encoded_buffer->nFilledLen);
-      received += m_encoded_buffer->nFilledLen / d_pitch;
+      int planesize = m_encoded_buffer->nFilledLen / d_planes;
+      for (int i=0; i < d_planes; i++)
+        memcpy(dst_buffer[i] + received * d_pitch, (uint8_t *)m_encoded_buffer->pBuffer + i * planesize, planesize);
+      received += m_encoded_buffer->nFilledLen / d_samplesize;
     }
   }
   #ifdef DEBUG_VERBOSE
@@ -521,6 +559,7 @@ AVSampleFormat CActiveAEResample::GetAVSampleFormat(AEDataFormat format)
   else if (format == AE_FMT_S16NE)  return AV_SAMPLE_FMT_S16;
   else if (format == AE_FMT_S32NE)  return AV_SAMPLE_FMT_S32;
   else if (format == AE_FMT_S24NE4) return AV_SAMPLE_FMT_S32;
+  else if (format == AE_FMT_S24NE4MSB)return AV_SAMPLE_FMT_S32;
   else if (format == AE_FMT_FLOAT)  return AV_SAMPLE_FMT_FLT;
   else if (format == AE_FMT_DOUBLE) return AV_SAMPLE_FMT_DBL;
 
@@ -528,6 +567,7 @@ AVSampleFormat CActiveAEResample::GetAVSampleFormat(AEDataFormat format)
   else if (format == AE_FMT_S16NEP)  return AV_SAMPLE_FMT_S16P;
   else if (format == AE_FMT_S32NEP)  return AV_SAMPLE_FMT_S32P;
   else if (format == AE_FMT_S24NE4P) return AV_SAMPLE_FMT_S32P;
+  else if (format == AE_FMT_S24NE4MSB)return AV_SAMPLE_FMT_S32;
   else if (format == AE_FMT_FLOATP)  return AV_SAMPLE_FMT_FLTP;
   else if (format == AE_FMT_DOUBLEP) return AV_SAMPLE_FMT_DBLP;
 
@@ -537,29 +577,6 @@ AVSampleFormat CActiveAEResample::GetAVSampleFormat(AEDataFormat format)
     return AV_SAMPLE_FMT_FLT;
 }
 
-AEDataFormat CActiveAEResample::GetAESampleFormat(AVSampleFormat format, int bits)
-{
-  #ifdef DEBUG_VERBOSE
-  CLog::Log(LOGINFO, "%s::%s", CLASSNAME, __func__);
-  #endif
-  if      (format == AV_SAMPLE_FMT_U8)   return AE_FMT_U8;
-  else if (format == AV_SAMPLE_FMT_S16)  return AE_FMT_S16NE;
-  else if (format == AV_SAMPLE_FMT_S32 && bits == 32)  return AE_FMT_S32NE;
-  else if (format == AV_SAMPLE_FMT_S32 && bits == 24)  return AE_FMT_S24NE4;
-  else if (format == AV_SAMPLE_FMT_FLT)  return AE_FMT_FLOAT;
-  else if (format == AV_SAMPLE_FMT_DBL)  return AE_FMT_DOUBLE;
-
-  else if (format == AV_SAMPLE_FMT_U8P)   return AE_FMT_U8P;
-  else if (format == AV_SAMPLE_FMT_S16P)  return AE_FMT_S16NEP;
-  else if (format == AV_SAMPLE_FMT_S32P && bits == 32)  return AE_FMT_S32NEP;
-  else if (format == AV_SAMPLE_FMT_S32P && bits == 24)  return AE_FMT_S24NE4P;
-  else if (format == AV_SAMPLE_FMT_FLTP)  return AE_FMT_FLOATP;
-  else if (format == AV_SAMPLE_FMT_DBLP)  return AE_FMT_DOUBLEP;
-
-  CLog::Log(LOGERROR, "CActiveAEResample::GetAESampleFormat - format not supported");
-  return AE_FMT_INVALID;
-}
-
 uint64_t CActiveAEResample::GetAVChannel(enum AEChannel aechannel)
 {
   #ifdef DEBUG_VERBOSE
-- 
1.9.3


From 0c7fcb56fea44e24064788e2c6910ad961ed17c6 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Sun, 15 Jun 2014 13:20:53 +0100
Subject: [PATCH 075/102] gles: Avoid crash when capturing snapshot when using
 dvdplayer

Note: snapshot will be blank, but that's better than crashing
---
 xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp b/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp
index 2929a37..53873f6 100644
--- a/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp
+++ b/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp
@@ -1598,7 +1598,9 @@ bool CLinuxRendererGLES::RenderCapture(CRenderCapture* capture)
     return false;
 
   // If rendered directly by the hardware
+#ifndef TARGET_RASPBERRY_PI
   if (m_renderMethod & RENDER_BYPASS)
+#endif
   {
     capture->BeginRender();
     capture->EndRender();
-- 
1.9.3


From d7bcc5ae49d12b97a9da7c5572d5f555c98859ec Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Mon, 16 Jun 2014 19:05:14 +0100
Subject: [PATCH 076/102] sqlite: Bump to 3080500

---
 tools/depends/target/sqlite3/Makefile | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/tools/depends/target/sqlite3/Makefile b/tools/depends/target/sqlite3/Makefile
index 87f7eaa..8fe61e8 100644
--- a/tools/depends/target/sqlite3/Makefile
+++ b/tools/depends/target/sqlite3/Makefile
@@ -3,7 +3,9 @@ DEPS= ../../Makefile.include Makefile
 
 # lib name, version
 LIBNAME=sqlite
-VERSION=3071000
+VERSION=3080500
+BASE_URL=https://www.sqlite.org/2014
+
 SOURCE=$(LIBNAME)-autoconf-$(VERSION)
 ARCHIVE=$(SOURCE).tar.gz
 
-- 
1.9.3


From 2b4f3f978406571d6dfb690ca4e282e3ee0c4b14 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Mon, 16 Jun 2014 19:06:00 +0100
Subject: [PATCH 077/102] [experimental] Disable quiet-noise generation

---
 xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAESink.cpp | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAESink.cpp b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAESink.cpp
index 488a0df..d9f4a43 100644
--- a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAESink.cpp
+++ b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAESink.cpp
@@ -870,6 +870,7 @@ void CActiveAESink::SwapInit(CSampleBuffer* samples)
 
 void CActiveAESink::GenerateNoise()
 {
+#ifndef TARGET_RASPBERRY_PI
   int nb_floats = m_sampleOfSilence.pkt->max_nb_samples;
   nb_floats *= m_sampleOfSilence.pkt->config.channels;
 
@@ -907,6 +908,7 @@ void CActiveAESink::GenerateNoise()
                      (uint8_t**)&noise, m_sampleOfSilence.pkt->max_nb_samples, 1.0);
 
   _aligned_free(noise);
+#endif
 }
 
 void CActiveAESink::SetSilenceTimer()
-- 
1.9.3


From 05d761fea469710297870c52ac2e154cbcda5d9a Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Mon, 16 Jun 2014 19:07:21 +0100
Subject: [PATCH 078/102] [omxcodec] Adjust asserts

---
 xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp | 11 +++++++----
 1 file changed, 7 insertions(+), 4 deletions(-)

diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp
index 494fdf5..23aaa9f 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp
@@ -795,7 +795,7 @@ int COpenMaxVideo::Decode(uint8_t* pData, int iSize, double dts, double pts)
           // only push if we are successful with feeding OMX_EmptyThisBuffer
           pthread_mutex_lock(&m_omx_output_mutex);
           m_dts_queue.push(dts);
-          assert(m_dts_queue.size() < 32);
+          assert(m_dts_queue.size() < 64);
           pthread_mutex_unlock(&m_omx_output_mutex);
         }
 #endif
@@ -1037,9 +1037,12 @@ OMX_ERRORTYPE COpenMaxVideo::DecoderFillBufferDone(
   if ((!m_deinterlace || (buffer->omx_buffer->nFlags & OMX_BUFFERFLAG_FIRST_FIELD)) && buffer->omx_buffer->nFlags)
   {
     pthread_mutex_lock(&m_omx_output_mutex);
-    assert(!m_dts_queue.empty());
-    buffer->dts = m_dts_queue.front();
-    m_dts_queue.pop();
+    if (!m_dts_queue.empty())
+    {
+      buffer->dts = m_dts_queue.front();
+      m_dts_queue.pop();
+    }
+    else assert(0);
     pthread_mutex_unlock(&m_omx_output_mutex);
   }
 #endif
-- 
1.9.3


From 41df02172c24c4426e2dd755207710de63987623 Mon Sep 17 00:00:00 2001
From: macrule <macrule2001@yahoo.de>
Date: Thu, 11 Apr 2013 18:24:42 +0200
Subject: [PATCH 079/102] Added some vc_tv_* functions that were missing in
 DllBCM.

---
 xbmc/linux/DllBCM.h | 9 +++++++++
 1 file changed, 9 insertions(+)

diff --git a/xbmc/linux/DllBCM.h b/xbmc/linux/DllBCM.h
index b92fdb8..9c7e293 100644
--- a/xbmc/linux/DllBCM.h
+++ b/xbmc/linux/DllBCM.h
@@ -48,6 +48,9 @@ class DllBcmHostInterface
   virtual void bcm_host_init() = 0;
   virtual void bcm_host_deinit() = 0;
   virtual int32_t graphics_get_display_size( const uint16_t display_number, uint32_t *width, uint32_t *height) = 0;
+  virtual int vc_tv_power_off() = 0;
+  virtual int vc_tv_sdtv_power_on(SDTV_MODE_T mode, SDTV_OPTIONS_T *options) = 0;
+  virtual int vc_tv_hdmi_power_on_preferred() = 0;
   virtual int vc_tv_hdmi_power_on_best(uint32_t width, uint32_t height, uint32_t frame_rate,
                                        HDMI_INTERLACED_T scan_mode, EDID_MODE_MATCH_FLAG_T match_flags) = 0;
   virtual int vc_tv_hdmi_power_on_best_3d(uint32_t width, uint32_t height, uint32_t frame_rate,
@@ -92,6 +95,12 @@ class DllBcmHost : public DllDynamic, DllBcmHostInterface
     { return ::bcm_host_deinit(); };
   virtual int32_t graphics_get_display_size( const uint16_t display_number, uint32_t *width, uint32_t *height)
     { return ::graphics_get_display_size(display_number, width, height); };
+  virtual int vc_tv_power_off()
+    { return ::vc_tv_power_off(); }
+  virtual int vc_tv_sdtv_power_on(SDTV_MODE_T mode, SDTV_OPTIONS_T *options)
+    { return ::vc_tv_sdtv_power_on(mode, options); }
+  virtual int vc_tv_hdmi_power_on_preferred()
+    { return ::vc_tv_hdmi_power_on_preferred(); }
   virtual int vc_tv_hdmi_power_on_best(uint32_t width, uint32_t height, uint32_t frame_rate,
                                        HDMI_INTERLACED_T scan_mode, EDID_MODE_MATCH_FLAG_T match_flags)
     { return ::vc_tv_hdmi_power_on_best(width, height, frame_rate, scan_mode, match_flags); };
-- 
1.9.3


From 8e14d993da8f0614b70dabdbb59fcb4cc79b6bc5 Mon Sep 17 00:00:00 2001
From: macrule <macrule2001@yahoo.de>
Date: Thu, 11 Apr 2013 18:29:03 +0200
Subject: [PATCH 080/102] Added private utility function to map a float display
 aspect, to the respective SDTV_ASPECT_* enum value.

---
 xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp | 19 +++++++++++++++++++
 1 file changed, 19 insertions(+)

diff --git a/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp b/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp
index a3edf0e..5ae2b59 100644
--- a/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp
+++ b/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp
@@ -410,6 +410,25 @@ static void SetResolutionString(RESOLUTION_INFO &res)
     res.dwFlags & D3DPRESENTFLAG_MODE3DTB   ? " 3DTB" : "",
     res.dwFlags & D3DPRESENTFLAG_MODE3DSBS  ? " 3DSBS" : "");
 }
+
+static SDTV_ASPECT_T get_sdtv_aspect_from_display_aspect(float display_aspect)
+{
+  SDTV_ASPECT_T aspect;
+  const float delta = 1e-3;
+  if(fabs(get_display_aspect_ratio(SDTV_ASPECT_16_9) - display_aspect) < delta)
+  {
+    aspect = SDTV_ASPECT_16_9;
+  }
+  else if(fabs(get_display_aspect_ratio(SDTV_ASPECT_14_9) - display_aspect) < delta)
+  {
+    aspect = SDTV_ASPECT_14_9;
+  }
+  else
+  {
+    aspect = SDTV_ASPECT_4_3;
+  }
+  return aspect;
+}
 #endif
 
 bool CEGLNativeTypeRaspberryPI::ProbeResolutions(std::vector<RESOLUTION_INFO> &resolutions)
-- 
1.9.3


From 73eebd2deb7924d492f9ba2b817dc52edf849a60 Mon Sep 17 00:00:00 2001
From: macrule <macrule2001@yahoo.de>
Date: Thu, 11 Apr 2013 19:50:58 +0200
Subject: [PATCH 081/102] Changed SDTV resolutions to be treated similarly to
 HDMI resolutions in SetNativeResolution. This means that the SDTV interface
 is powered up and set to the right mode.

---
 xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp | 36 ++++++++++++++++++++-----
 xbmc/windowing/egl/EGLNativeTypeRaspberryPI.h   |  1 -
 2 files changed, 29 insertions(+), 8 deletions(-)

diff --git a/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp b/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp
index 5ae2b59..712fe9c 100644
--- a/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp
+++ b/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp
@@ -220,7 +220,7 @@ bool CEGLNativeTypeRaspberryPI::SetNativeResolution(const RESOLUTION_INFO &res)
 
   DestroyDispmaxWindow();
 
-  if(!m_fixedMode && GETFLAGS_GROUP(res.dwFlags) && GETFLAGS_MODE(res.dwFlags))
+  if(GETFLAGS_GROUP(res.dwFlags) && GETFLAGS_MODE(res.dwFlags))
   {
     sem_init(&m_tv_synced, 0, 0);
     m_DllBcmHost->vc_tv_register_callback(CallbackTvServiceCallback, this);
@@ -274,6 +274,33 @@ bool CEGLNativeTypeRaspberryPI::SetNativeResolution(const RESOLUTION_INFO &res)
 
     m_desktopRes = res;
   }
+  else if(!GETFLAGS_GROUP(res.dwFlags) && GETFLAGS_MODE(res.dwFlags))
+  {
+    sem_init(&m_tv_synced, 0, 0);
+    m_DllBcmHost->vc_tv_register_callback(CallbackTvServiceCallback, this);
+
+    SDTV_OPTIONS_T options;
+    options.aspect = get_sdtv_aspect_from_display_aspect((float)res.iScreenWidth / (float)res.iScreenHeight);
+
+    int success = m_DllBcmHost->vc_tv_sdtv_power_on((SDTV_MODE_T)GETFLAGS_MODE(res.dwFlags), &options);
+
+    if (success == 0)
+    {
+      CLog::Log(LOGDEBUG, "EGL set SDTV mode (%d,%d)=%d\n",
+                          GETFLAGS_GROUP(res.dwFlags), GETFLAGS_MODE(res.dwFlags), success);
+
+      sem_wait(&m_tv_synced);
+    }
+    else
+    {
+      CLog::Log(LOGERROR, "EGL failed to set SDTV mode (%d,%d)=%d\n",
+                          GETFLAGS_GROUP(res.dwFlags), GETFLAGS_MODE(res.dwFlags), success);
+    }
+    m_DllBcmHost->vc_tv_unregister_callback(CallbackTvServiceCallback);
+    sem_destroy(&m_tv_synced);
+
+    m_desktopRes = res;
+  }
 
   m_dispman_display = m_DllBcmHost->vc_dispmanx_display_open(0);
 
@@ -439,8 +466,6 @@ bool CEGLNativeTypeRaspberryPI::ProbeResolutions(std::vector<RESOLUTION_INFO> &r
   if(!m_DllBcmHost)
     return false;
 
-  m_fixedMode               = false;
-
   /* read initial desktop resolution before probe resolutions.
    * probing will replace the desktop resolution when it finds the same one.
    * we raplace it because probing will generate more detailed 
@@ -483,7 +508,7 @@ bool CEGLNativeTypeRaspberryPI::ProbeResolutions(std::vector<RESOLUTION_INFO> &r
       m_desktopRes.iHeight      = tv_state.display.sdtv.height;
       m_desktopRes.iScreenWidth = tv_state.display.sdtv.width;
       m_desktopRes.iScreenHeight= tv_state.display.sdtv.height;
-      m_desktopRes.dwFlags      = D3DPRESENTFLAG_INTERLACED;
+      m_desktopRes.dwFlags      = MAKEFLAGS(HDMI_RES_GROUP_INVALID, tv_state.display.sdtv.mode, 1);
       m_desktopRes.fRefreshRate = (float)tv_state.display.sdtv.frame_rate;
       m_desktopRes.fPixelRatio  = get_display_aspect_ratio((SDTV_ASPECT_T)tv_state.display.sdtv.display_options.aspect) / ((float)m_desktopRes.iScreenWidth / (float)m_desktopRes.iScreenHeight);
     }
@@ -506,9 +531,6 @@ bool CEGLNativeTypeRaspberryPI::ProbeResolutions(std::vector<RESOLUTION_INFO> &r
     CLog::Log(LOGDEBUG, "EGL probe resolution %s:%x\n", m_desktopRes.strMode.c_str(), m_desktopRes.dwFlags);
   }
 
-  if(resolutions.size() < 2)
-    m_fixedMode = true;
-
   DLOG("CEGLNativeTypeRaspberryPI::ProbeResolutions\n");
   return true;
 #else
diff --git a/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.h b/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.h
index 59401f5..a0acb1a 100644
--- a/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.h
+++ b/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.h
@@ -59,7 +59,6 @@ class CEGLNativeTypeRaspberryPI : public CEGLNativeType
   DISPMANX_ELEMENT_HANDLE_T     m_dispman_element;
   TV_GET_STATE_RESP_T           m_tv_state;
   sem_t                         m_tv_synced;
-  bool                          m_fixedMode;
   RESOLUTION_INFO               m_desktopRes;
   int                           m_width;
   int                           m_height;
-- 
1.9.3


From 6edef341b2d0207ef9d817c844731c46a25b54f1 Mon Sep 17 00:00:00 2001
From: macrule <macrule2001@yahoo.de>
Date: Thu, 11 Apr 2013 19:54:59 +0200
Subject: [PATCH 082/102] Added methods SuspendVideoOutput() and
 ResumeVideoOutput() to CRBP class, which can be used to power down the
 Raspberry PI's video interface, and restore it at a later point.

---
 xbmc/linux/RBP.cpp                              | 15 +++++++++++++++
 xbmc/linux/RBP.h                                |  3 +++
 xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp |  3 +++
 3 files changed, 21 insertions(+)

diff --git a/xbmc/linux/RBP.cpp b/xbmc/linux/RBP.cpp
index 9a5e9cb..87619e9 100644
--- a/xbmc/linux/RBP.cpp
+++ b/xbmc/linux/RBP.cpp
@@ -165,4 +165,19 @@ void CRBP::Deinitialize()
   m_initialized     = false;
   m_omx_initialized = false;
 }
+
+void CRBP::SuspendVideoOutput()
+{
+  CLog::Log(LOGDEBUG, "Raspberry PI suspending video output\n");
+  char response[80];
+  m_DllBcmHost->vc_gencmd(response, sizeof response, "display_power 0");
+}
+
+void CRBP::ResumeVideoOutput()
+{
+  char response[80];
+  m_DllBcmHost->vc_gencmd(response, sizeof response, "display_power 1");
+  CLog::Log(LOGDEBUG, "Raspberry PI resuming video output\n");
+}
+
 #endif
diff --git a/xbmc/linux/RBP.h b/xbmc/linux/RBP.h
index 2aae579..f06687c 100644
--- a/xbmc/linux/RBP.h
+++ b/xbmc/linux/RBP.h
@@ -57,6 +57,9 @@ class CRBP
   unsigned char *CaptureDisplay(int width, int height, int *stride, bool swap_red_blue, bool video_only = true);
   DllOMX *GetDllOMX() { return m_OMX ? m_OMX->GetDll() : NULL; }
 
+  void SuspendVideoOutput();
+  void ResumeVideoOutput();
+
 private:
   DllBcmHost *m_DllBcmHost;
   bool       m_initialized;
diff --git a/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp b/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp
index 712fe9c..40d303e 100644
--- a/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp
+++ b/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp
@@ -58,7 +58,10 @@
 # define DLOG(fmt, args...)
 #endif
 
+#if defined(TARGET_RASPBERRY_PI)
 static void SetResolutionString(RESOLUTION_INFO &res);
+static SDTV_ASPECT_T get_sdtv_aspect_from_display_aspect(float display_aspect);
+#endif
 
 CEGLNativeTypeRaspberryPI::CEGLNativeTypeRaspberryPI()
 {
-- 
1.9.3


From 42be8acb22868ef82db0b30d15dc2c0114656ea3 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Sun, 11 Aug 2013 15:03:36 +0100
Subject: [PATCH 083/102] PowerManager (and its IPowerSyscall instance) now
 gets called from CApplication::OnKey() and can process and suppress key
 presses. This is a requirement to implement a virtual sleep state.

---
 xbmc/Application.cpp                  | 7 +++++++
 xbmc/powermanagement/IPowerSyscall.h  | 7 +++++++
 xbmc/powermanagement/PowerManager.cpp | 6 ++++++
 xbmc/powermanagement/PowerManager.h   | 3 +++
 4 files changed, 23 insertions(+)

diff --git a/xbmc/Application.cpp b/xbmc/Application.cpp
index c9690fc..ce52040 100644
--- a/xbmc/Application.cpp
+++ b/xbmc/Application.cpp
@@ -2347,6 +2347,13 @@ bool CApplication::OnKey(const CKey& key)
   // special handling if the screensaver is active
   CAction action = CButtonTranslator::GetInstance().GetAction(iWin, key);
 
+  // give the PowerManager a chance to process a keypress, and
+  // suppress further processing. we need this for virtual sleep.
+  if (g_powerManager.ProcessAction(action))
+  {
+    return true;
+  }
+
   // a key has been pressed.
   // reset Idle Timer
   m_idleTimer.StartZero();
diff --git a/xbmc/powermanagement/IPowerSyscall.h b/xbmc/powermanagement/IPowerSyscall.h
index 7f9e7ed..711abea 100644
--- a/xbmc/powermanagement/IPowerSyscall.h
+++ b/xbmc/powermanagement/IPowerSyscall.h
@@ -20,6 +20,9 @@
  *
  */
 
+// forward declaration
+class CAction;
+
 class IPowerEventsCallback
 {
 public:
@@ -60,6 +63,10 @@ class IPowerSyscall
    \param callback the callback to signal to
    */
   virtual bool PumpPowerEvents(IPowerEventsCallback *callback) = 0;
+
+  // this is an optional part of the interface, so we provide a no-op implementation here.
+  // return true to suppress further processing of the CAction.
+  virtual bool ProcessAction(const CAction& action) { return false; }
 };
 
 class CPowerSyscallWithoutEvents : public IPowerSyscall
diff --git a/xbmc/powermanagement/PowerManager.cpp b/xbmc/powermanagement/PowerManager.cpp
index fe72016..b392f76 100644
--- a/xbmc/powermanagement/PowerManager.cpp
+++ b/xbmc/powermanagement/PowerManager.cpp
@@ -232,6 +232,12 @@ void CPowerManager::ProcessEvents()
   nesting--;
 }
 
+bool CPowerManager::ProcessAction(const CAction& action)
+{
+  return m_instance->ProcessAction(action);
+}
+
+
 void CPowerManager::OnSleep()
 {
   CAnnouncementManager::Get().Announce(System, "xbmc", "OnSleep");
diff --git a/xbmc/powermanagement/PowerManager.h b/xbmc/powermanagement/PowerManager.h
index 0b1f10a..e42b143 100644
--- a/xbmc/powermanagement/PowerManager.h
+++ b/xbmc/powermanagement/PowerManager.h
@@ -58,6 +58,8 @@ class CNullPowerSyscall : public IPowerSyscall
 
 
   virtual bool PumpPowerEvents(IPowerEventsCallback *callback) { return false; }
+
+  virtual bool ProcessAction(const CAction& action) { return false; }
 };
 
 // This class will wrap and handle PowerSyscalls.
@@ -87,6 +89,7 @@ class CPowerManager : public IPowerEventsCallback
 
   static void SettingOptionsShutdownStatesFiller(const CSetting *setting, std::vector< std::pair<std::string, int> > &list, int &current, void *data);
 
+  bool ProcessAction(const CAction& action);
 private:
   void OnSleep();
   void OnWake();
-- 
1.9.3


From 5e7c6707827476ddf7875f551eb1895de0046986 Mon Sep 17 00:00:00 2001
From: macrule <macrule2001@yahoo.de>
Date: Wed, 17 Apr 2013 13:23:01 +0200
Subject: [PATCH 084/102] Added CPowerSyscallVirtualSleep class, which acts as
 a base class for devices that have no native standby mode, and need to fake
 it in some way.

---
 xbmc/powermanagement/Makefile                     |  1 +
 xbmc/powermanagement/PowerSyscallVirtualSleep.cpp | 84 +++++++++++++++++++++++
 xbmc/powermanagement/PowerSyscallVirtualSleep.h   | 56 +++++++++++++++
 3 files changed, 141 insertions(+)
 create mode 100644 xbmc/powermanagement/PowerSyscallVirtualSleep.cpp
 create mode 100644 xbmc/powermanagement/PowerSyscallVirtualSleep.h

diff --git a/xbmc/powermanagement/Makefile b/xbmc/powermanagement/Makefile
index 0b4c029..16056af 100644
--- a/xbmc/powermanagement/Makefile
+++ b/xbmc/powermanagement/Makefile
@@ -1,5 +1,6 @@
 SRCS=DPMSSupport.cpp \
      PowerManager.cpp \
+     PowerSyscallVirtualSleep.cpp \
 
 LIB=powermanagement.a
 
diff --git a/xbmc/powermanagement/PowerSyscallVirtualSleep.cpp b/xbmc/powermanagement/PowerSyscallVirtualSleep.cpp
new file mode 100644
index 0000000..6a1e47b
--- /dev/null
+++ b/xbmc/powermanagement/PowerSyscallVirtualSleep.cpp
@@ -0,0 +1,84 @@
+/*
+ *      Copyright (C) 2013 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "PowerSyscallVirtualSleep.h"
+#include "guilib/Key.h"
+#include "utils/log.h"
+#include "utils/StringUtils.h"
+
+bool CPowerSyscallVirtualSleep::Suspend()
+{
+  if (m_virtualSleepState == VIRTUAL_SLEEP_STATE_AWAKE)
+  {
+    if (VirtualSleep())
+    {
+      m_virtualSleepState = VIRTUAL_SLEEP_STATE_WILL_SLEEP;
+      return true;
+    }
+  }
+
+  return false;
+}
+
+bool CPowerSyscallVirtualSleep::PumpPowerEvents(IPowerEventsCallback *callback)
+{
+  if (m_virtualSleepState == VIRTUAL_SLEEP_STATE_WILL_WAKE)
+  {
+    callback->OnWake();
+    m_virtualSleepState = VIRTUAL_SLEEP_STATE_AWAKE;
+    return true;
+  }
+  else if (m_virtualSleepState == VIRTUAL_SLEEP_STATE_WILL_SLEEP)
+  {
+    callback->OnSleep();
+    m_virtualSleepState = VIRTUAL_SLEEP_STATE_ASLEEP;
+    return true;
+  }
+
+  return false;
+}
+
+bool CPowerSyscallVirtualSleep::ProcessAction(const CAction& action)
+{
+  if (m_virtualSleepState != VIRTUAL_SLEEP_STATE_ASLEEP)
+    return false;
+
+  // device is in virtual sleep, only one of the power keys will
+  // wake it up again.
+  if (action.GetID() == ACTION_BUILT_IN_FUNCTION)
+  {
+    CStdString name = action.GetName();
+    StringUtils::ToLower(name);
+    if(name.Equals("xbmc.suspend()") ||
+       name.Equals("shutdown") ||
+       name.Equals("suspend")  ||
+       name.Equals("hibernate"))
+    {
+      if(VirtualWake())
+      {
+        m_virtualSleepState = VIRTUAL_SLEEP_STATE_WILL_WAKE;
+        return false;
+      }
+    }
+  }
+
+  // wasn't a power key, suppress this and stay asleep
+  return true;
+}
diff --git a/xbmc/powermanagement/PowerSyscallVirtualSleep.h b/xbmc/powermanagement/PowerSyscallVirtualSleep.h
new file mode 100644
index 0000000..ef6e682
--- /dev/null
+++ b/xbmc/powermanagement/PowerSyscallVirtualSleep.h
@@ -0,0 +1,56 @@
+/*
+ *      Copyright (C) 2013 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#ifndef _POWER_SYSCALL_VIRTUAL_SLEEP_H_
+#define _POWER_SYSCALL_VIRTUAL_SLEEP_H_
+#include "IPowerSyscall.h"
+
+// Systems that have no native standby mode, can base their
+// IPowerSyscall implementation on this class, and need only
+// implement VirtualSleep()/VirtualWake().
+class CPowerSyscallVirtualSleep : public IPowerSyscall
+{
+public:
+  CPowerSyscallVirtualSleep() : m_virtualSleepState(VIRTUAL_SLEEP_STATE_AWAKE) {}
+  virtual ~CPowerSyscallVirtualSleep() {}
+
+  virtual bool CanSuspend() { return true; }
+  virtual bool Suspend();
+
+  virtual bool PumpPowerEvents(IPowerEventsCallback *callback);
+
+  virtual bool ProcessAction(const CAction& action);
+
+  virtual bool VirtualSleep() = 0;
+  virtual bool VirtualWake()  = 0;
+
+protected:
+  // keep track of virtual sleep state for devices that support it
+  typedef enum {
+    VIRTUAL_SLEEP_STATE_AWAKE = 0,
+    VIRTUAL_SLEEP_STATE_ASLEEP,
+    VIRTUAL_SLEEP_STATE_WILL_WAKE,
+    VIRTUAL_SLEEP_STATE_WILL_SLEEP,
+  } VirtualSleepState;
+
+  VirtualSleepState m_virtualSleepState;
+};
+
+#endif // _POWER_SYSCALL_VIRTUAL_SLEEP_H_
-- 
1.9.3


From bd85dcc014d0cfdbebeb1c118af5e33b7ac377a9 Mon Sep 17 00:00:00 2001
From: macrule <macrule2001@yahoo.de>
Date: Wed, 17 Apr 2013 13:24:22 +0200
Subject: [PATCH 085/102] Added power management support for the Raspberry Pi.
 Since it doesn't support true standby, we fake it by turning video on or off,
 and ignoring remote inputs during the standby phase.

---
 xbmc/powermanagement/PowerManager.cpp              |  4 ++
 xbmc/powermanagement/linux/Makefile                |  1 +
 .../linux/RaspberryPIPowerSyscall.cpp              | 38 +++++++++++++++++
 .../linux/RaspberryPIPowerSyscall.h                | 49 ++++++++++++++++++++++
 4 files changed, 92 insertions(+)
 create mode 100644 xbmc/powermanagement/linux/RaspberryPIPowerSyscall.cpp
 create mode 100644 xbmc/powermanagement/linux/RaspberryPIPowerSyscall.h

diff --git a/xbmc/powermanagement/PowerManager.cpp b/xbmc/powermanagement/PowerManager.cpp
index b392f76..7dd691c 100644
--- a/xbmc/powermanagement/PowerManager.cpp
+++ b/xbmc/powermanagement/PowerManager.cpp
@@ -38,6 +38,8 @@
 
 #if defined(TARGET_DARWIN)
 #include "osx/CocoaPowerSyscall.h"
+#elif defined(TARGET_RASPBERRY_PI)
+#include "linux/RaspberryPIPowerSyscall.h"
 #elif defined(TARGET_ANDROID)
 #include "android/AndroidPowerSyscall.h"
 #elif defined(TARGET_POSIX)
@@ -74,6 +76,8 @@ void CPowerManager::Initialize()
 {
 #if defined(TARGET_DARWIN)
   m_instance = new CCocoaPowerSyscall();
+#elif defined(TARGET_RASPBERRY_PI)
+  m_instance = new CRaspberryPIPowerSyscall();
 #elif defined(TARGET_ANDROID)
   m_instance = new CAndroidPowerSyscall();
 #elif defined(TARGET_POSIX)
diff --git a/xbmc/powermanagement/linux/Makefile b/xbmc/powermanagement/linux/Makefile
index fc6f8b5..10809da 100644
--- a/xbmc/powermanagement/linux/Makefile
+++ b/xbmc/powermanagement/linux/Makefile
@@ -1,6 +1,7 @@
 SRCS=ConsoleDeviceKitPowerSyscall.cpp \
      ConsoleUPowerSyscall.cpp \
      HALPowerSyscall.cpp \
+     RaspberryPIPowerSyscall.cpp \
      UPowerSyscall.cpp \
      LogindUPowerSyscall.cpp
 
diff --git a/xbmc/powermanagement/linux/RaspberryPIPowerSyscall.cpp b/xbmc/powermanagement/linux/RaspberryPIPowerSyscall.cpp
new file mode 100644
index 0000000..10deeb8
--- /dev/null
+++ b/xbmc/powermanagement/linux/RaspberryPIPowerSyscall.cpp
@@ -0,0 +1,38 @@
+/*
+ *      Copyright (C) 2013 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#if defined(TARGET_RASPBERRY_PI)
+
+#include "RaspberryPIPowerSyscall.h"
+#include "RBP.h"
+
+bool CRaspberryPIPowerSyscall::VirtualSleep()
+{
+  g_RBP.SuspendVideoOutput();
+  return true;
+}
+
+bool CRaspberryPIPowerSyscall::VirtualWake()
+{
+  g_RBP.ResumeVideoOutput();
+  return true;
+}
+
+#endif
diff --git a/xbmc/powermanagement/linux/RaspberryPIPowerSyscall.h b/xbmc/powermanagement/linux/RaspberryPIPowerSyscall.h
new file mode 100644
index 0000000..fd1d67c
--- /dev/null
+++ b/xbmc/powermanagement/linux/RaspberryPIPowerSyscall.h
@@ -0,0 +1,49 @@
+#pragma once
+/*
+ *      Copyright (C) 2013 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#ifndef _RASPBERRY_PI_POWER_SYSCALL_H_
+#define _RASPBERRY_PI_POWER_SYSCALL_H_
+
+#if defined(TARGET_RASPBERRY_PI)
+#include "powermanagement/PowerSyscallVirtualSleep.h"
+
+class CRaspberryPIPowerSyscall : public CPowerSyscallVirtualSleep
+{
+public:
+  CRaspberryPIPowerSyscall() : CPowerSyscallVirtualSleep() {}
+  virtual ~CRaspberryPIPowerSyscall() {}
+
+  virtual bool Powerdown()    { return false; }
+  virtual bool Hibernate()    { return false; }
+  virtual bool Reboot()       { return false; }
+
+  virtual bool CanPowerdown() { return false; }
+  virtual bool CanHibernate() { return false; }
+  virtual bool CanReboot()    { return true; }
+
+  virtual int  BatteryLevel() { return 0; }
+
+  virtual bool VirtualSleep();
+  virtual bool VirtualWake();
+};
+#endif // TARGET_RASPBERRY_PI
+
+#endif // _RASPBERRY_PI_POWER_SYSCALL_H_
-- 
1.9.3


From ab50d8fcfe9c0e0fdb749ce7456a2ddbf58a8b45 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Mon, 3 Mar 2014 16:16:29 +0000
Subject: [PATCH 086/102] [power] hack - don't kill lirc or cec

---
 xbmc/peripherals/devices/PeripheralCecAdapter.cpp | 37 +++++++++++++++++++++++
 xbmc/powermanagement/PowerManager.cpp             |  4 +--
 2 files changed, 39 insertions(+), 2 deletions(-)

diff --git a/xbmc/peripherals/devices/PeripheralCecAdapter.cpp b/xbmc/peripherals/devices/PeripheralCecAdapter.cpp
index 6950f0c..4c8416f 100644
--- a/xbmc/peripherals/devices/PeripheralCecAdapter.cpp
+++ b/xbmc/peripherals/devices/PeripheralCecAdapter.cpp
@@ -183,12 +183,49 @@ void CPeripheralCecAdapter::Announce(AnnouncementFlag flag, const char *sender,
   }
   else if (flag == System && !strcmp(sender, "xbmc") && !strcmp(message, "OnSleep"))
   {
+#if 1
+  bool bSendStandbyCommands(false);
+  {
+    CSingleLock lock(m_critSection);
+    bSendStandbyCommands = m_iExitCode != EXITCODE_REBOOT &&
+                           m_iExitCode != EXITCODE_RESTARTAPP &&
+                           !m_bDeviceRemoved &&
+                           (!m_bGoingToStandby || GetSettingBool("standby_tv_on_pc_standby")) &&
+                           GetSettingBool("enabled");
+
+    if (m_bGoingToStandby)
+      m_bActiveSourceBeforeStandby = m_cecAdapter->IsLibCECActiveSource();
+  }
+
+  if (bSendStandbyCommands)
+  {
+    if (m_cecAdapter->IsLibCECActiveSource())
+    {
+      if (!m_configuration.powerOffDevices.IsEmpty())
+      {
+        CLog::Log(LOGDEBUG, "%s - sending standby commands", __FUNCTION__);
+        m_standbySent = CDateTime::GetCurrentDateTime();
+        m_cecAdapter->StandbyDevices();
+      }
+      else if (m_configuration.bSendInactiveSource == 1)
+      {
+        CLog::Log(LOGDEBUG, "%s - sending inactive source commands", __FUNCTION__);
+        m_cecAdapter->SetInactiveView();
+      }
+    }
+    else
+    {
+      CLog::Log(LOGDEBUG, "%s - XBMC is not the active source, not sending any standby commands", __FUNCTION__);
+    }
+  }
+#else
     // this will also power off devices when we're the active source
     {
       CSingleLock lock(m_critSection);
       m_bGoingToStandby = true;
     }
     StopThread();
+#endif
   }
   else if (flag == System && !strcmp(sender, "xbmc") && !strcmp(message, "OnWake"))
   {
diff --git a/xbmc/powermanagement/PowerManager.cpp b/xbmc/powermanagement/PowerManager.cpp
index 7dd691c..17f118a 100644
--- a/xbmc/powermanagement/PowerManager.cpp
+++ b/xbmc/powermanagement/PowerManager.cpp
@@ -248,7 +248,7 @@ void CPowerManager::OnSleep()
   CLog::Log(LOGNOTICE, "%s: Running sleep jobs", __FUNCTION__);
 
   // stop lirc
-#if defined(HAS_LIRC) || defined(HAS_IRSERVERSUITE)
+#if 0 //defined(HAS_LIRC) || defined(HAS_IRSERVERSUITE)
   CLog::Log(LOGNOTICE, "%s: Stopping lirc", __FUNCTION__);
   CBuiltins::Execute("LIRC.Stop");
 #endif
@@ -284,7 +284,7 @@ void CPowerManager::OnWake()
 #endif
 
   // restart lirc
-#if defined(HAS_LIRC) || defined(HAS_IRSERVERSUITE)
+#if 0 // defined(HAS_LIRC) || defined(HAS_IRSERVERSUITE)
   CLog::Log(LOGNOTICE, "%s: Restarting lirc", __FUNCTION__);
   CBuiltins::Execute("LIRC.Start");
 #endif
-- 
1.9.3


From 18db33d3f1fe0f10f1dec1979f27d08c72a1a5b2 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Mon, 3 Mar 2014 16:47:54 +0000
Subject: [PATCH 087/102] [power] hack - wake on any action

---
 xbmc/powermanagement/PowerSyscallVirtualSleep.cpp | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/xbmc/powermanagement/PowerSyscallVirtualSleep.cpp b/xbmc/powermanagement/PowerSyscallVirtualSleep.cpp
index 6a1e47b..a717a09 100644
--- a/xbmc/powermanagement/PowerSyscallVirtualSleep.cpp
+++ b/xbmc/powermanagement/PowerSyscallVirtualSleep.cpp
@@ -62,14 +62,14 @@ bool CPowerSyscallVirtualSleep::ProcessAction(const CAction& action)
 
   // device is in virtual sleep, only one of the power keys will
   // wake it up again.
-  if (action.GetID() == ACTION_BUILT_IN_FUNCTION)
+  //if (action.GetID() == ACTION_BUILT_IN_FUNCTION)
   {
     CStdString name = action.GetName();
     StringUtils::ToLower(name);
-    if(name.Equals("xbmc.suspend()") ||
+    /*if(name.Equals("system.suspend") ||
        name.Equals("shutdown") ||
        name.Equals("suspend")  ||
-       name.Equals("hibernate"))
+       name.Equals("hibernate"))*/
     {
       if(VirtualWake())
       {
-- 
1.9.3


From 61a6f6564b85012f9c6666b3d9f5ccb2299ae138 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Mon, 3 Mar 2014 17:30:07 +0000
Subject: [PATCH 088/102] [power] hack - Make suspend toggle suspend state

---
 xbmc/powermanagement/PowerSyscallVirtualSleep.cpp | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/xbmc/powermanagement/PowerSyscallVirtualSleep.cpp b/xbmc/powermanagement/PowerSyscallVirtualSleep.cpp
index a717a09..d39c3ed 100644
--- a/xbmc/powermanagement/PowerSyscallVirtualSleep.cpp
+++ b/xbmc/powermanagement/PowerSyscallVirtualSleep.cpp
@@ -33,6 +33,11 @@ bool CPowerSyscallVirtualSleep::Suspend()
       return true;
     }
   }
+  else if (VirtualWake())
+  {
+    m_virtualSleepState = VIRTUAL_SLEEP_STATE_WILL_WAKE;
+    return false;
+  }
 
   return false;
 }
-- 
1.9.3


From 9d8ab89dc5dec5b3d2c7a42f0875eda5761b3320 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Tue, 4 Mar 2014 19:33:44 +0000
Subject: [PATCH 089/102] [power] Add back in powerdown and reboot

---
 .../linux/RaspberryPIPowerSyscall.cpp              | 34 ++++++++++++++++++++++
 .../linux/RaspberryPIPowerSyscall.h                |  6 ++--
 2 files changed, 37 insertions(+), 3 deletions(-)

diff --git a/xbmc/powermanagement/linux/RaspberryPIPowerSyscall.cpp b/xbmc/powermanagement/linux/RaspberryPIPowerSyscall.cpp
index 10deeb8..220bca9 100644
--- a/xbmc/powermanagement/linux/RaspberryPIPowerSyscall.cpp
+++ b/xbmc/powermanagement/linux/RaspberryPIPowerSyscall.cpp
@@ -20,7 +20,11 @@
 
 #if defined(TARGET_RASPBERRY_PI)
 
+#include "system.h"
 #include "RaspberryPIPowerSyscall.h"
+#if defined(HAS_DBUS)
+#include "LogindUPowerSyscall.h"
+#endif
 #include "RBP.h"
 
 bool CRaspberryPIPowerSyscall::VirtualSleep()
@@ -35,4 +39,34 @@ bool CRaspberryPIPowerSyscall::VirtualWake()
   return true;
 }
 
+bool CRaspberryPIPowerSyscall::Powerdown()
+{
+  int s = false;
+#if defined(HAS_DBUS)
+  if (CLogindUPowerSyscall::HasLogind())
+  {
+    IPowerSyscall *m_instance = new CLogindUPowerSyscall;
+    if (m_instance->CanPowerdown())
+      s = m_instance->Powerdown();
+    delete m_instance;
+  }
+#endif
+  return s;
+}
+
+bool CRaspberryPIPowerSyscall::Reboot()
+{
+  int s = false;
+#if defined(HAS_DBUS)
+  if (CLogindUPowerSyscall::HasLogind())
+  {
+    IPowerSyscall *m_instance = new CLogindUPowerSyscall;
+    if (m_instance->CanReboot())
+      s = m_instance->Reboot();
+    delete m_instance;
+  }
+#endif
+  return s;
+}
+
 #endif
diff --git a/xbmc/powermanagement/linux/RaspberryPIPowerSyscall.h b/xbmc/powermanagement/linux/RaspberryPIPowerSyscall.h
index fd1d67c..062132e 100644
--- a/xbmc/powermanagement/linux/RaspberryPIPowerSyscall.h
+++ b/xbmc/powermanagement/linux/RaspberryPIPowerSyscall.h
@@ -31,11 +31,11 @@ class CRaspberryPIPowerSyscall : public CPowerSyscallVirtualSleep
   CRaspberryPIPowerSyscall() : CPowerSyscallVirtualSleep() {}
   virtual ~CRaspberryPIPowerSyscall() {}
 
-  virtual bool Powerdown()    { return false; }
+  virtual bool Powerdown();
   virtual bool Hibernate()    { return false; }
-  virtual bool Reboot()       { return false; }
+  virtual bool Reboot();
 
-  virtual bool CanPowerdown() { return false; }
+  virtual bool CanPowerdown() { return true; }
   virtual bool CanHibernate() { return false; }
   virtual bool CanReboot()    { return true; }
 
-- 
1.9.3


From 251012ede3883268a585bc4d3fe11c4d9e782d67 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Wed, 18 Jun 2014 23:11:28 +0100
Subject: [PATCH 090/102] [rbp] Reduce GPU memory use when limited

Switching from default triple buffered output to double buffered saves 8M with 1080p GUI.
This may slightly reduce framerate, but is likely to be minimal.

Assume if gpu_mem is set below the default 128M that this memory reduction is wanted
---
 xbmc/linux/RBP.cpp | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/xbmc/linux/RBP.cpp b/xbmc/linux/RBP.cpp
index 87619e9..9f72a36 100644
--- a/xbmc/linux/RBP.cpp
+++ b/xbmc/linux/RBP.cpp
@@ -72,6 +72,9 @@ bool CRBP::Initialize()
   if (vc_gencmd(response, sizeof response, "codec_enabled WVC1") == 0)
     m_codec_wvc1_enabled = strcmp("WVC1=enabled", response) == 0;
 
+  if (m_gpu_mem < 128)
+    setenv("V3D_DOUBLE_BUFFER", "1", 1);
+
   g_OMXImage.Initialize();
   m_omx_image_init = true;
   return true;
-- 
1.9.3


From a8bb89d0dba9cac1bd738043355e3364a098f089 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Thu, 19 Jun 2014 18:44:10 +0100
Subject: [PATCH 091/102] ActiveAE: Add queries to determine number of channels
 output

---
 xbmc/cores/AudioEngine/AEFactory.cpp                 | 14 ++++++++++++++
 xbmc/cores/AudioEngine/AEFactory.h                   |  2 ++
 xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp | 17 +++++++++++++++++
 xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.h   |  2 ++
 xbmc/cores/AudioEngine/Interfaces/AE.h               | 12 ++++++++++++
 5 files changed, 47 insertions(+)

diff --git a/xbmc/cores/AudioEngine/AEFactory.cpp b/xbmc/cores/AudioEngine/AEFactory.cpp
index fe8d51c..cccf7f1 100644
--- a/xbmc/cores/AudioEngine/AEFactory.cpp
+++ b/xbmc/cores/AudioEngine/AEFactory.cpp
@@ -216,6 +216,20 @@ bool CAEFactory::SupportsSilenceTimeout()
   return false;
 }
 
+bool CAEFactory::IsStereoConfig()
+{
+  if(AE)
+    return AE->IsStereoConfig();
+  return false;
+}
+
+bool CAEFactory::IsNotHDAudioConfig()
+{
+  if(AE)
+    return AE->IsNotHDAudioConfig();
+  return false;
+}
+
 /**
   * Returns true if current AudioEngine supports at lest two basic quality levels
   * @return true if quality setting is supported, otherwise false
diff --git a/xbmc/cores/AudioEngine/AEFactory.h b/xbmc/cores/AudioEngine/AEFactory.h
index 1d8bf36..658997b 100644
--- a/xbmc/cores/AudioEngine/AEFactory.h
+++ b/xbmc/cores/AudioEngine/AEFactory.h
@@ -54,6 +54,8 @@ class CAEFactory
   static std::string GetDefaultDevice(bool passthrough);
   static bool SupportsRaw(AEDataFormat format, int samplerate);
   static bool SupportsSilenceTimeout();
+  static bool IsStereoConfig();
+  static bool IsNotHDAudioConfig();
 
   /**
    * Returns true if current AudioEngine supports at lest two basic quality levels
diff --git a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp
index 3ac182a..5820a5d 100644
--- a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp
+++ b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp
@@ -2251,6 +2251,23 @@ bool CActiveAE::SupportsSilenceTimeout()
   return true;
 }
 
+bool CActiveAE::IsStereoConfig()
+{
+  std:string device = CSettings::Get().GetString("audiooutput.audiodevice");
+  int numChannels = (m_sink.GetDeviceType(device) == AE_DEVTYPE_IEC958) ? AE_CH_LAYOUT_2_0 : CSettings::Get().GetInt("audiooutput.channels");
+  bool passthrough = CSettings::Get().GetInt("audiooutput.config") == AE_CONFIG_FIXED ? false : CSettings::Get().GetBool("audiooutput.passthrough");
+  return numChannels == AE_CH_LAYOUT_2_0 && ! (passthrough &&
+    CSettings::Get().GetBool("audiooutput.ac3passthrough") &&
+    CSettings::Get().GetBool("audiooutput.ac3transcode"));
+}
+
+bool CActiveAE::IsNotHDAudioConfig()
+{
+  std:string device = CSettings::Get().GetString("audiooutput.audiodevice");
+  int numChannels = (m_sink.GetDeviceType(device) == AE_DEVTYPE_IEC958) ? AE_CH_LAYOUT_2_0 : CSettings::Get().GetInt("audiooutput.channels");
+  return numChannels <= AE_CH_LAYOUT_5_1;
+}
+
 bool CActiveAE::SupportsQualityLevel(enum AEQuality level)
 {
   if (level == AE_QUALITY_LOW || level == AE_QUALITY_MID || level == AE_QUALITY_HIGH)
diff --git a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.h b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.h
index bfb65d6..5467aa4 100644
--- a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.h
+++ b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.h
@@ -229,6 +229,8 @@ class CActiveAE : public IAE, private CThread
   virtual std::string GetDefaultDevice(bool passthrough);
   virtual bool SupportsRaw(AEDataFormat format, int samplerate);
   virtual bool SupportsSilenceTimeout();
+  virtual bool IsStereoConfig();
+  virtual bool IsNotHDAudioConfig();
   virtual bool SupportsQualityLevel(enum AEQuality level);
   virtual bool IsSettingVisible(const std::string &settingId);
   virtual void KeepConfiguration(unsigned int millis);
diff --git a/xbmc/cores/AudioEngine/Interfaces/AE.h b/xbmc/cores/AudioEngine/Interfaces/AE.h
index 3379bf6..eaa3a19 100644
--- a/xbmc/cores/AudioEngine/Interfaces/AE.h
+++ b/xbmc/cores/AudioEngine/Interfaces/AE.h
@@ -211,6 +211,18 @@ class IAE
    */
   virtual bool SupportsSilenceTimeout() { return false; }
 
+  /**
+   * Returns true if the AudioEngine is currently configured for stereo audio
+   * @returns true if the AudioEngine is currently configured for stereo audio
+   */
+  virtual bool IsStereoConfig() { return false; }
+
+  /**
+   * Returns true if the AudioEngine is currently configured for 5.1 or less
+   * @returns true if the AudioEngine is currently configured for 5.1 or less
+   */
+  virtual bool IsNotHDAudioConfig() { return false; }
+
   virtual void RegisterAudioCallback(IAudioCallback* pCallback) {}
 
   virtual void UnregisterAudioCallback() {}
-- 
1.9.3


From 9b8f061b96f56dafb0bf4a198ad99556e740a84a Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Thu, 13 Mar 2014 16:08:46 +0000
Subject: [PATCH 092/102] [omxplayer] Make use of audio decode fast paths when
 downmixing

The TrueHD codec actually works in 3 stages.
It decodes the downmixed stereo.
It then decodes the differences required to produce 5.1.
It then decodes the differences required to produce 7.1.

Many users end up downmixing this 7.1 stream back to 2.0.
Much better to tell the codec we only need the 2.0 stream.

When playing a 94s duration video file on an overclocked Pi, the audio decode took:
7.1 channels: 39.6s
5.1 channels: 36.5s
2.0 channels: 23.0s

So, it's almost twice as fast to decode TrueHD when only stereo is required.
---
 xbmc/cores/omxplayer/OMXAudioCodecOMX.cpp | 10 ++++++++++
 1 file changed, 10 insertions(+)

diff --git a/xbmc/cores/omxplayer/OMXAudioCodecOMX.cpp b/xbmc/cores/omxplayer/OMXAudioCodecOMX.cpp
index bb3bea4..814fe1d 100644
--- a/xbmc/cores/omxplayer/OMXAudioCodecOMX.cpp
+++ b/xbmc/cores/omxplayer/OMXAudioCodecOMX.cpp
@@ -25,6 +25,7 @@
 #include "utils/log.h"
 
 #include "cores/AudioEngine/Utils/AEUtil.h"
+#include "cores/AudioEngine/AEFactory.h"
 
 // the size of the audio_render output port buffers
 #define AUDIO_DECODE_OUTPUT_BUFFER (32*1024)
@@ -86,6 +87,15 @@ bool COMXAudioCodecOMX::Open(CDVDStreamInfo &hints)
   m_pCodecContext->block_align = hints.blockalign;
   m_pCodecContext->bit_rate = hints.bitrate;
   m_pCodecContext->bits_per_coded_sample = hints.bitspersample;
+  if (hints.codec == AV_CODEC_ID_TRUEHD)
+  {
+    if (CAEFactory::IsStereoConfig())
+      m_pCodecContext->request_channel_layout = AV_CH_LAYOUT_STEREO;
+    else if (CAEFactory::IsNotHDAudioConfig())
+      m_pCodecContext->request_channel_layout = AV_CH_LAYOUT_5POINT1;
+  }
+  if (m_pCodecContext->request_channel_layout)
+    CLog::Log(LOGNOTICE,"COMXAudioCodecOMX::Open() Requesting channel layout of %x", (unsigned)m_pCodecContext->request_channel_layout);
 
   // vorbis has variable sized planar output, so skip concatenation
   if (hints.codec == AV_CODEC_ID_VORBIS)
-- 
1.9.3


From b4e5c374bfcab5cb3dce973ef84cb5e1d3f3c8d5 Mon Sep 17 00:00:00 2001
From: Matthias Kortstiege <vdrfan@xbmc.org>
Date: Sun, 29 Jun 2014 11:10:07 +0200
Subject: [PATCH 095/102] no need to compute slow hash on changes in case the
 fast one already succeeded

---
 xbmc/video/VideoInfoScanner.cpp | 51 +++++++++++++++++++++--------------------
 1 file changed, 26 insertions(+), 25 deletions(-)

diff --git a/xbmc/video/VideoInfoScanner.cpp b/xbmc/video/VideoInfoScanner.cpp
index e0056bd..a0b1a00 100644
--- a/xbmc/video/VideoInfoScanner.cpp
+++ b/xbmc/video/VideoInfoScanner.cpp
@@ -267,40 +267,41 @@ namespace VIDEO
       CStdString fastHash = GetFastHash(strDirectory, regexps);
       if (m_database.GetPathHash(strDirectory, dbHash) && !fastHash.empty() && fastHash == dbHash)
       { // fast hashes match - no need to process anything
-        CLog::Log(LOGDEBUG, "VideoInfoScanner: Skipping dir '%s' due to no change (fasthash)", CURL::GetRedacted(strDirectory).c_str());
         hash = fastHash;
-        bSkip = true;
       }
-      if (!bSkip)
+      else
       { // need to fetch the folder
         CDirectory::GetDirectory(strDirectory, items, g_advancedSettings.m_videoExtensions);
         items.Stack();
-        // compute hash
-        GetPathHash(items, hash);
-        if (hash != dbHash && !hash.empty())
+
+        // check whether to re-use previously computed fast hash
+        if (!CanFastHash(items, regexps) || fastHash.empty())
+          GetPathHash(items, hash);
+        else
+          hash = fastHash;
+      }
+
+      if (hash == dbHash || (hash.empty() && !dbHash.empty()))
+      {
+        if (hash.empty() && !dbHash.empty())
         {
-          if (dbHash.empty())
-            CLog::Log(LOGDEBUG, "VideoInfoScanner: Scanning dir '%s' as not in the database", CURL::GetRedacted(strDirectory).c_str());
-          else
-            CLog::Log(LOGDEBUG, "VideoInfoScanner: Rescanning dir '%s' due to change (%s != %s)", CURL::GetRedacted(strDirectory).c_str(), dbHash.c_str(), hash.c_str());
+          CLog::Log(LOGDEBUG, "VideoInfoScanner: Skipping dir '%s' as it's empty or doesn't exist - adding to clean list", CURL::GetRedacted(strDirectory).c_str());
+          if (m_bClean)
+            m_pathsToClean.insert(m_database.GetPathId(strDirectory));
         }
         else
-        { // they're the same or the hash is empty (dir empty/dir not retrievable)
-          if (hash.empty() && !dbHash.empty())
-          {
-            CLog::Log(LOGDEBUG, "VideoInfoScanner: Skipping dir '%s' as it's empty or doesn't exist - adding to clean list", CURL::GetRedacted(strDirectory).c_str());
-            if (m_bClean)
-              m_pathsToClean.insert(m_database.GetPathId(strDirectory));
-          }
-          else
-            CLog::Log(LOGDEBUG, "VideoInfoScanner: Skipping dir '%s' due to no change", CURL::GetRedacted(strDirectory).c_str());
-          bSkip = true;
-          if (m_handle)
-            OnDirectoryScanned(strDirectory);
+        {
+          CLog::Log(LOGDEBUG, "VideoInfoScanner: Skipping dir '%s' due to no change%s", CURL::GetRedacted(strDirectory).c_str(), !fastHash.empty() ? " (fasthash)" : "");
         }
-        // update the hash to a fast hash if needed
-        if (CanFastHash(items, regexps) && !fastHash.empty())
-          hash = fastHash;
+
+        bSkip = true;
+      }
+      else
+      {
+        if (dbHash.empty())
+          CLog::Log(LOGDEBUG, "VideoInfoScanner: Scanning dir '%s' as not in the database", CURL::GetRedacted(strDirectory).c_str());
+        else
+          CLog::Log(LOGDEBUG, "VideoInfoScanner: Rescanning dir '%s' due to change (%s != %s)", CURL::GetRedacted(strDirectory).c_str(), dbHash.c_str(), hash.c_str());
       }
     }
     else if (content == CONTENT_TVSHOWS)
-- 
1.9.3


From cd7b60465faeea8c911e8b779bb4eb861ab97e4f Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Fri, 27 Jun 2014 00:01:05 +0100
Subject: [PATCH 096/102] [rbp] Resume video output on startup

---
 xbmc/linux/RBP.cpp | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/xbmc/linux/RBP.cpp b/xbmc/linux/RBP.cpp
index 9f72a36..f789bf1 100644
--- a/xbmc/linux/RBP.cpp
+++ b/xbmc/linux/RBP.cpp
@@ -75,6 +75,9 @@ bool CRBP::Initialize()
   if (m_gpu_mem < 128)
     setenv("V3D_DOUBLE_BUFFER", "1", 1);
 
+  // in case xbcm was restarted when suspended
+  ResumeVideoOutput();
+
   g_OMXImage.Initialize();
   m_omx_image_init = true;
   return true;
-- 
1.9.3


From cf66a3902ad562b29323f901f05821ccf0dc2209 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Fri, 27 Jun 2014 00:36:29 +0100
Subject: [PATCH 097/102] [omxplayer] Experimental support for anaglyph
 rendering of 3d videos

Requires updated firmware
---
 xbmc/cores/omxplayer/OMXPlayer.cpp      | 12 ++++++++--
 xbmc/cores/omxplayer/OMXPlayerVideo.cpp | 32 ++++++++++++++++++++++++++-
 xbmc/cores/omxplayer/OMXVideo.cpp       | 39 +++++++++++++++++++++------------
 xbmc/cores/omxplayer/OMXVideo.h         |  3 ++-
 xbmc/rendering/RenderSystem.cpp         |  4 ++++
 5 files changed, 72 insertions(+), 18 deletions(-)

diff --git a/xbmc/cores/omxplayer/OMXPlayer.cpp b/xbmc/cores/omxplayer/OMXPlayer.cpp
index 4e0662f..6cebdc4 100644
--- a/xbmc/cores/omxplayer/OMXPlayer.cpp
+++ b/xbmc/cores/omxplayer/OMXPlayer.cpp
@@ -1503,6 +1503,8 @@ void COMXPlayer::Process()
     SetCaching(CACHESTATE_FLUSH);
 
   EDEINTERLACEMODE current_deinterlace = CMediaSettings::Get().GetCurrentVideoSettings().m_DeinterlaceMode;
+  RENDER_STEREO_MODE current_stereomode = g_graphicsContext.GetStereoMode();
+
   float current_sharpness = CMediaSettings::Get().GetCurrentVideoSettings().m_Sharpness;
   SetSharpness(current_sharpness);
 
@@ -1525,8 +1527,13 @@ void COMXPlayer::Process()
       float threshold = 0.1f;
       bool audio_fifo_low = false, video_fifo_low = false, audio_fifo_high = false, video_fifo_high = false;
 
-      // if deinterlace setting has changed, we should close and open video
-      if (current_deinterlace != CMediaSettings::Get().GetCurrentVideoSettings().m_DeinterlaceMode)
+      // if deinterlace or stereomode setting has changed, we should close and open video
+      RENDER_STEREO_MODE stereomode = g_graphicsContext.GetStereoMode();
+
+      if ((current_deinterlace != CMediaSettings::Get().GetCurrentVideoSettings().m_DeinterlaceMode) ||
+          (current_stereomode != stereomode &&
+          (current_stereomode == RENDER_STEREO_MODE_ANAGLYPH_RED_CYAN || current_stereomode == RENDER_STEREO_MODE_ANAGLYPH_GREEN_MAGENTA) !=
+          (stereomode == RENDER_STEREO_MODE_ANAGLYPH_RED_CYAN || stereomode == RENDER_STEREO_MODE_ANAGLYPH_GREEN_MAGENTA)))
       {
         int iStream = m_CurrentVideo.id, source = m_CurrentVideo.source;
         CloseVideoStream(false);
@@ -1534,6 +1541,7 @@ void COMXPlayer::Process()
         if (m_State.canseek)
           m_messenger.Put(new CDVDMsgPlayerSeek(GetTime(), true, true, true, true, true));
         current_deinterlace = CMediaSettings::Get().GetCurrentVideoSettings().m_DeinterlaceMode;
+        current_stereomode = stereomode;
       }
 
       // if sharpness setting has changed, we should update it
diff --git a/xbmc/cores/omxplayer/OMXPlayerVideo.cpp b/xbmc/cores/omxplayer/OMXPlayerVideo.cpp
index aa5ea43..4d06f1d 100644
--- a/xbmc/cores/omxplayer/OMXPlayerVideo.cpp
+++ b/xbmc/cores/omxplayer/OMXPlayerVideo.cpp
@@ -549,7 +549,29 @@ bool OMXPlayerVideo::OpenDecoder()
   else
     m_fForcedAspectRatio = 0.0;
 
-  bool bVideoDecoderOpen = m_omxVideo.Open(m_hints, m_av_clock, CMediaSettings::Get().GetCurrentVideoSettings().m_DeinterlaceMode, m_hdmi_clock_sync);
+
+  unsigned flags = GetStereoModeFlags(GetStereoMode());
+  RENDER_STEREO_MODE video_stereo_mode = (flags & CONF_FLAGS_STEREO_MODE_SBS) ? RENDER_STEREO_MODE_SPLIT_VERTICAL :
+                                         (flags & CONF_FLAGS_STEREO_MODE_TAB) ? RENDER_STEREO_MODE_SPLIT_HORIZONTAL : RENDER_STEREO_MODE_OFF;
+  bool stereo_invert                   = (flags & CONF_FLAGS_STEREO_CADANCE_RIGHT_LEFT) ? true : false;
+  OMX_IMAGEFILTERANAGLYPHTYPE anaglyph = OMX_ImageFilterAnaglyphNone;
+
+  if (g_graphicsContext.GetStereoMode() == RENDER_STEREO_MODE_ANAGLYPH_RED_CYAN)
+  {
+    if (video_stereo_mode == RENDER_STEREO_MODE_SPLIT_VERTICAL)
+      anaglyph = OMX_ImageFilterAnaglyphSBStoRedCyan;
+    else if (video_stereo_mode == RENDER_STEREO_MODE_SPLIT_HORIZONTAL)
+      anaglyph = OMX_ImageFilterAnaglyphTABtoRedCyan;
+  }
+  else if (g_graphicsContext.GetStereoMode() == RENDER_STEREO_MODE_ANAGLYPH_GREEN_MAGENTA)
+  {
+    if (video_stereo_mode == RENDER_STEREO_MODE_SPLIT_VERTICAL)
+      anaglyph = OMX_ImageFilterAnaglyphSBStoGreenMagenta;
+    else if (video_stereo_mode == RENDER_STEREO_MODE_SPLIT_HORIZONTAL)
+      anaglyph = OMX_ImageFilterAnaglyphTABtoGreenMagenta;
+  }
+
+  bool bVideoDecoderOpen = m_omxVideo.Open(m_hints, m_av_clock, CMediaSettings::Get().GetCurrentVideoSettings().m_DeinterlaceMode, anaglyph, m_hdmi_clock_sync);
   m_omxVideo.RegisterResolutionUpdateCallBack((void *)this, ResolutionUpdateCallBack);
 
   if(!bVideoDecoderOpen)
@@ -694,6 +716,10 @@ void OMXPlayerVideo::SetVideoRect(const CRect &InSrcRect, const CRect &InDestRec
       video_stereo_mode = RENDER_STEREO_MODE_OFF;
       display_stereo_mode = RENDER_STEREO_MODE_OFF;
     }
+    else if (display_stereo_mode == RENDER_STEREO_MODE_ANAGLYPH_RED_CYAN || display_stereo_mode == RENDER_STEREO_MODE_ANAGLYPH_GREEN_MAGENTA)
+    {
+      SrcRect.x2 *= 2.0f;
+    }
     else if (stereo_invert)
     {
       SrcRect.x1 += m_hints.width / 2;
@@ -710,6 +736,10 @@ void OMXPlayerVideo::SetVideoRect(const CRect &InSrcRect, const CRect &InDestRec
       video_stereo_mode = RENDER_STEREO_MODE_OFF;
       display_stereo_mode = RENDER_STEREO_MODE_OFF;
     }
+    else if (display_stereo_mode == RENDER_STEREO_MODE_ANAGLYPH_RED_CYAN || display_stereo_mode == RENDER_STEREO_MODE_ANAGLYPH_GREEN_MAGENTA)
+    {
+      SrcRect.y2 *= 2.0f;
+    }
     else if (stereo_invert)
     {
       SrcRect.y1 += m_hints.height / 2;
diff --git a/xbmc/cores/omxplayer/OMXVideo.cpp b/xbmc/cores/omxplayer/OMXVideo.cpp
index 6639804..07c4643 100644
--- a/xbmc/cores/omxplayer/OMXVideo.cpp
+++ b/xbmc/cores/omxplayer/OMXVideo.cpp
@@ -113,6 +113,7 @@ COMXVideo::COMXVideo() : m_video_codec_name("")
   m_extrasize         = 0;
   m_deinterlace       = false;
   m_deinterlace_request = VS_DEINTERLACEMODE_OFF;
+  m_anaglyph          = OMX_ImageFilterAnaglyphNone;
   m_hdmi_clock_sync   = false;
   m_drop_state        = false;
   m_decoded_width     = 0;
@@ -227,9 +228,9 @@ bool COMXVideo::PortSettingsChanged()
   else
     m_deinterlace = interlace.eMode != OMX_InterlaceProgressive;
 
-    CLog::Log(LOGDEBUG, "%s::%s - %dx%d@%.2f interlace:%d deinterlace:%d", CLASSNAME, __func__,
+    CLog::Log(LOGDEBUG, "%s::%s - %dx%d@%.2f interlace:%d deinterlace:%d anaglyph:%d", CLASSNAME, __func__,
       port_image.format.video.nFrameWidth, port_image.format.video.nFrameHeight,
-      port_image.format.video.xFramerate / (float)(1<<16), interlace.eMode, m_deinterlace);
+      port_image.format.video.xFramerate / (float)(1<<16), interlace.eMode, m_deinterlace, m_anaglyph);
 
   // let OMXPlayerVideo know about resolution so it can inform RenderManager
   if (m_res_callback)
@@ -256,7 +257,7 @@ bool COMXVideo::PortSettingsChanged()
   if(!m_omx_sched.Initialize("OMX.broadcom.video_scheduler", OMX_IndexParamVideoInit))
     return false;
 
-  if(m_deinterlace)
+  if(m_deinterlace || m_anaglyph)
   {
     if(!m_omx_image_fx.Initialize("OMX.broadcom.image_fx", OMX_IndexParamImageInit))
       return false;
@@ -296,16 +297,24 @@ bool COMXVideo::PortSettingsChanged()
     }
   }
 
-  if(m_deinterlace)
+  if(m_deinterlace || m_anaglyph)
   {
     OMX_CONFIG_IMAGEFILTERPARAMSTYPE image_filter;
     OMX_INIT_STRUCTURE(image_filter);
 
     image_filter.nPortIndex = m_omx_image_fx.GetOutputPort();
-    image_filter.nNumParams = 1;
-    image_filter.nParams[0] = 3;
-    image_filter.eImageFilter = OMX_ImageFilterDeInterlaceAdvanced;
-
+    if (m_anaglyph != OMX_ImageFilterAnaglyphNone)
+    {
+      image_filter.nNumParams = 1;
+      image_filter.nParams[0] = m_anaglyph;
+      image_filter.eImageFilter = OMX_ImageFilterAnaglyph;
+    }
+    else
+    {
+      image_filter.nNumParams = 1;
+      image_filter.nParams[0] = 3;
+      image_filter.eImageFilter = OMX_ImageFilterDeInterlaceAdvanced;
+    }
     omx_err = m_omx_image_fx.SetConfig(OMX_IndexConfigCommonImageFilterParameters, &image_filter);
     if(omx_err != OMX_ErrorNone)
     {
@@ -314,7 +323,7 @@ bool COMXVideo::PortSettingsChanged()
     }
   }
 
-  if(m_deinterlace)
+  if(m_deinterlace || m_anaglyph)
   {
     m_omx_tunnel_decoder.Initialize(&m_omx_decoder, m_omx_decoder.GetOutputPort(), &m_omx_image_fx, m_omx_image_fx.GetInputPort());
     m_omx_tunnel_image_fx.Initialize(&m_omx_image_fx, m_omx_image_fx.GetOutputPort(), &m_omx_sched, m_omx_sched.GetInputPort());
@@ -341,7 +350,7 @@ bool COMXVideo::PortSettingsChanged()
     return false;
   }
 
-  if(m_deinterlace)
+  if(m_deinterlace || m_anaglyph)
   {
     omx_err = m_omx_tunnel_image_fx.Establish();
     if(omx_err != OMX_ErrorNone)
@@ -383,7 +392,7 @@ bool COMXVideo::PortSettingsChanged()
   return true;
 }
 
-bool COMXVideo::Open(CDVDStreamInfo &hints, OMXClock *clock, EDEINTERLACEMODE deinterlace, bool hdmi_clock_sync)
+bool COMXVideo::Open(CDVDStreamInfo &hints, OMXClock *clock, EDEINTERLACEMODE deinterlace, OMX_IMAGEFILTERANAGLYPHTYPE anaglyph, bool hdmi_clock_sync)
 {
   CSingleLock lock (m_critSection);
   bool vflip = false;
@@ -523,6 +532,7 @@ bool COMXVideo::Open(CDVDStreamInfo &hints, OMXClock *clock, EDEINTERLACEMODE de
     break;
   }
   m_deinterlace_request = deinterlace;
+  m_anaglyph = anaglyph;
 
   if(!m_omx_decoder.Initialize(decoder_name, OMX_IndexParamVideoInit))
     return false;
@@ -734,7 +744,7 @@ void COMXVideo::Close()
   dump_omx_buffer(NULL);
   m_omx_tunnel_clock.Deestablish();
   m_omx_tunnel_decoder.Deestablish();
-  if(m_deinterlace)
+  if(m_deinterlace || m_anaglyph)
     m_omx_tunnel_image_fx.Deestablish();
   m_omx_tunnel_sched.Deestablish();
 
@@ -742,7 +752,7 @@ void COMXVideo::Close()
 
   m_omx_sched.Deinitialize();
   m_omx_decoder.Deinitialize();
-  if(m_deinterlace)
+  if(m_deinterlace || m_anaglyph)
     m_omx_image_fx.Deinitialize();
   m_omx_render.Deinitialize();
 
@@ -755,6 +765,7 @@ void COMXVideo::Close()
 
   m_video_codec_name  = "";
   m_deinterlace       = false;
+  m_anaglyph          = OMX_ImageFilterAnaglyphNone;
   m_av_clock          = NULL;
 
   m_res_ctx           = NULL;
@@ -878,7 +889,7 @@ void COMXVideo::Reset(void)
 
   m_setStartTime = true;
   m_omx_decoder.FlushInput();
-  if(m_deinterlace)
+  if(m_deinterlace || m_anaglyph)
     m_omx_image_fx.FlushInput();
 }
 
diff --git a/xbmc/cores/omxplayer/OMXVideo.h b/xbmc/cores/omxplayer/OMXVideo.h
index 226000e..e2e79c2 100644
--- a/xbmc/cores/omxplayer/OMXVideo.h
+++ b/xbmc/cores/omxplayer/OMXVideo.h
@@ -49,7 +49,7 @@ class COMXVideo
 
   // Required overrides
   bool SendDecoderConfig();
-  bool Open(CDVDStreamInfo &hints, OMXClock *clock, EDEINTERLACEMODE deinterlace = VS_DEINTERLACEMODE_OFF, bool hdmi_clock_sync = false);
+  bool Open(CDVDStreamInfo &hints, OMXClock *clock, EDEINTERLACEMODE deinterlace = VS_DEINTERLACEMODE_OFF, OMX_IMAGEFILTERANAGLYPHTYPE anaglyph = OMX_ImageFilterAnaglyphNone, bool hdmi_clock_sync = false);
   bool PortSettingsChanged();
   void RegisterResolutionUpdateCallBack(void *ctx, ResolutionUpdateCallBackFn callback) { m_res_ctx = ctx; m_res_callback = callback; }
   void Close(void);
@@ -94,6 +94,7 @@ class COMXVideo
 
   bool              m_deinterlace;
   EDEINTERLACEMODE  m_deinterlace_request;
+  OMX_IMAGEFILTERANAGLYPHTYPE m_anaglyph;
   bool              m_hdmi_clock_sync;
   ResolutionUpdateCallBackFn m_res_callback;
   void              *m_res_ctx;
diff --git a/xbmc/rendering/RenderSystem.cpp b/xbmc/rendering/RenderSystem.cpp
index e5a98f6..3ee28e0 100644
--- a/xbmc/rendering/RenderSystem.cpp
+++ b/xbmc/rendering/RenderSystem.cpp
@@ -73,6 +73,10 @@ bool CRenderSystemBase::SupportsStereo(RENDER_STEREO_MODE mode) const
     case RENDER_STEREO_MODE_SPLIT_HORIZONTAL:
     case RENDER_STEREO_MODE_SPLIT_VERTICAL:
     case RENDER_STEREO_MODE_MONO:
+#ifdef TARGET_RASPBERRY_PI
+    case RENDER_STEREO_MODE_ANAGLYPH_RED_CYAN:
+    case RENDER_STEREO_MODE_ANAGLYPH_GREEN_MAGENTA:
+#endif
       return true;
     default:
       return false;
-- 
1.9.3


From 2ec74d1273d13709bde43877856dfba84cb3e808 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Wed, 2 Jul 2014 12:24:01 +0100
Subject: [PATCH 098/102] [settings] Add update flag to omx acceleration

---
 system/settings/settings.xml | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/system/settings/settings.xml b/system/settings/settings.xml
index 7d1d51f..5b67ee6 100644
--- a/system/settings/settings.xml
+++ b/system/settings/settings.xml
@@ -740,6 +740,9 @@
           </dependencies>
           <level>2</level>
           <default>true</default>
+          <updates>
+            <update type="change" />
+          </updates>
           <control type="toggle" />
         </setting>
         <setting id="videoplayer.usevideotoolbox" type="boolean" label="13432" help="36162">
-- 
1.9.3


From 300cf12bc8ebd2e5114581820fe55474b3c39ffc Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Tue, 1 Jul 2014 00:38:54 +0100
Subject: [PATCH 099/102] [omx] Avoid hang following jpegs that failed to
 decode

There's a few instanced of xbmc hanging following a jpeg that failed to decode on GPU:
http://forum.stmlabs.com/showthread.php?tid=14839
https://github.com/raspberrypi/firmware/issues/288
http://openelec.tv/forum/120-news-announcements/70709-openelec-4-0-released?start=15#105219

It should fail and continue with software decode. It hangs on the OMX_FreeBuffer call.
Looks like image_decode component should be returned to idle state before freeing buffers
when operation did not complete successfully
---
 xbmc/cores/omxplayer/OMXImage.cpp | 78 ++++++++++++++++++++++++++-------------
 xbmc/cores/omxplayer/OMXImage.h   |  4 ++
 2 files changed, 56 insertions(+), 26 deletions(-)

diff --git a/xbmc/cores/omxplayer/OMXImage.cpp b/xbmc/cores/omxplayer/OMXImage.cpp
index d529b20..f5fe546 100644
--- a/xbmc/cores/omxplayer/OMXImage.cpp
+++ b/xbmc/cores/omxplayer/OMXImage.cpp
@@ -902,6 +902,7 @@ COMXImageDec::COMXImageDec()
 {
   m_decoded_buffer = NULL;
   OMX_INIT_STRUCTURE(m_decoded_format);
+  m_success = false;
 }
 
 COMXImageDec::~COMXImageDec()
@@ -916,15 +917,20 @@ void COMXImageDec::Close()
 {
   CSingleLock lock(m_OMXSection);
 
-  if(m_omx_decoder.IsInitialized())
-  {
-    m_omx_decoder.FlushInput();
-    m_omx_decoder.FreeInputBuffers();
-  }
-  if(m_omx_resize.IsInitialized())
+  if (!m_success)
   {
-    m_omx_resize.FlushOutput();
-    m_omx_resize.FreeOutputBuffers();
+    if(m_omx_decoder.IsInitialized())
+    {
+      m_omx_decoder.SetStateForComponent(OMX_StateIdle);
+      m_omx_decoder.FlushInput();
+      m_omx_decoder.FreeInputBuffers();
+    }
+    if(m_omx_resize.IsInitialized())
+    {
+      m_omx_resize.SetStateForComponent(OMX_StateIdle);
+      m_omx_resize.FlushOutput();
+      m_omx_resize.FreeOutputBuffers();
+    }
   }
   if(m_omx_tunnel_decode.IsInitialized())
     m_omx_tunnel_decode.Deestablish();
@@ -1177,6 +1183,7 @@ bool COMXImageDec::Decode(const uint8_t *demuxer_content, unsigned demuxer_bytes
 
   memcpy( (char*)pixels, m_decoded_buffer->pBuffer, stride * height);
 
+  m_success = true;
   Close();
   return true;
 }
@@ -1191,6 +1198,7 @@ COMXImageEnc::COMXImageEnc()
   CSingleLock lock(m_OMXSection);
   OMX_INIT_STRUCTURE(m_encoded_format);
   m_encoded_buffer = NULL;
+  m_success = false;
 }
 
 COMXImageEnc::~COMXImageEnc()
@@ -1416,6 +1424,7 @@ COMXImageReEnc::COMXImageReEnc()
   m_encoded_buffer = NULL;
   m_pDestBuffer = NULL;
   m_nDestAllocSize = 0;
+  m_success = false;
 }
 
 COMXImageReEnc::~COMXImageReEnc()
@@ -1431,15 +1440,24 @@ void COMXImageReEnc::Close()
 {
   CSingleLock lock(m_OMXSection);
 
-  if(m_omx_decoder.IsInitialized())
-  {
-    m_omx_decoder.FlushInput();
-    m_omx_decoder.FreeInputBuffers();
-  }
-  if(m_omx_encoder.IsInitialized())
+  if (!m_success)
   {
-    m_omx_encoder.FlushOutput();
-    m_omx_encoder.FreeOutputBuffers();
+    if(m_omx_decoder.IsInitialized())
+    {
+      m_omx_decoder.SetStateForComponent(OMX_StateIdle);
+      m_omx_decoder.FlushInput();
+      m_omx_decoder.FreeInputBuffers();
+    }
+    if(m_omx_resize.IsInitialized())
+    {
+      m_omx_resize.SetStateForComponent(OMX_StateIdle);
+    }
+    if(m_omx_encoder.IsInitialized())
+    {
+      m_omx_encoder.SetStateForComponent(OMX_StateIdle);
+      m_omx_encoder.FlushOutput();
+      m_omx_encoder.FreeOutputBuffers();
+    }
   }
   if(m_omx_tunnel_decode.IsInitialized())
     m_omx_tunnel_decode.Deestablish();
@@ -1856,14 +1874,15 @@ bool COMXImageReEnc::ReEncode(COMXImageFile &srcFile, unsigned int maxWidth, uns
     }
   }
 
-  Close();
-
   if(m_omx_decoder.BadState())
     return false;
 
   pDestBuffer = m_pDestBuffer;
   CLog::Log(LOGDEBUG, "%s::%s : %s %dx%d -> %dx%d\n", CLASSNAME, __func__, srcFile.GetFilename(), srcFile.GetWidth(), srcFile.GetHeight(), maxWidth, maxHeight);
 
+  m_success = true;
+  Close();
+
   return true;
 }
 
@@ -1875,6 +1894,7 @@ bool COMXImageReEnc::ReEncode(COMXImageFile &srcFile, unsigned int maxWidth, uns
 
 COMXTexture::COMXTexture()
 {
+  m_success = false;
 }
 
 COMXTexture::~COMXTexture()
@@ -1886,15 +1906,20 @@ void COMXTexture::Close()
 {
   CSingleLock lock(m_OMXSection);
 
-  if(m_omx_decoder.IsInitialized())
-  {
-    m_omx_decoder.FlushInput();
-    m_omx_decoder.FreeInputBuffers();
-  }
-  if(m_omx_egl_render.IsInitialized())
+  if (!m_success)
   {
-    m_omx_egl_render.FlushOutput();
-    m_omx_egl_render.FreeOutputBuffers();
+    if(m_omx_decoder.IsInitialized())
+    {
+      m_omx_decoder.SetStateForComponent(OMX_StateIdle);
+      m_omx_decoder.FlushInput();
+      m_omx_decoder.FreeInputBuffers();
+    }
+    if(m_omx_egl_render.IsInitialized())
+    {
+      m_omx_egl_render.SetStateForComponent(OMX_StateIdle);
+      m_omx_egl_render.FlushOutput();
+      m_omx_egl_render.FreeOutputBuffers();
+    }
   }
   if (m_omx_tunnel_decode.IsInitialized())
     m_omx_tunnel_decode.Deestablish();
@@ -2196,6 +2221,7 @@ bool COMXTexture::Decode(const uint8_t *demuxer_content, unsigned demuxer_bytes,
       eos = true;
     }
   }
+  m_success = true;
   Close();
   return true;
 }
diff --git a/xbmc/cores/omxplayer/OMXImage.h b/xbmc/cores/omxplayer/OMXImage.h
index ec7a229..62e931a 100644
--- a/xbmc/cores/omxplayer/OMXImage.h
+++ b/xbmc/cores/omxplayer/OMXImage.h
@@ -135,6 +135,7 @@ class COMXImageDec
   OMX_BUFFERHEADERTYPE          *m_decoded_buffer;
   OMX_PARAM_PORTDEFINITIONTYPE  m_decoded_format;
   CCriticalSection              m_OMXSection;
+  bool                          m_success;
 };
 
 class COMXImageEnc
@@ -153,6 +154,7 @@ class COMXImageEnc
   OMX_BUFFERHEADERTYPE          *m_encoded_buffer;
   OMX_PARAM_PORTDEFINITIONTYPE  m_encoded_format;
   CCriticalSection              m_OMXSection;
+  bool                          m_success;
 };
 
 class COMXImageReEnc
@@ -176,6 +178,7 @@ class COMXImageReEnc
   CCriticalSection              m_OMXSection;
   void                          *m_pDestBuffer;
   unsigned int                  m_nDestAllocSize;
+  bool                          m_success;
 };
 
 class COMXTexture
@@ -200,6 +203,7 @@ class COMXTexture
 
   OMX_BUFFERHEADERTYPE *m_egl_buffer;
   CCriticalSection              m_OMXSection;
+  bool              m_success;
 };
 
 extern COMXImage g_OMXImage;
-- 
1.9.3


From 1fe4b152bde3a10c2e1499fb038088105f23eb0a Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Wed, 2 Jul 2014 20:41:29 +0100
Subject: [PATCH 100/102] [pi] Reduce time textures are held for when memory is
 low

---
 xbmc/Application.cpp |  9 +++++++++
 xbmc/linux/RBP.cpp   | 10 ++++++++++
 xbmc/linux/RBP.h     |  1 +
 3 files changed, 20 insertions(+)

diff --git a/xbmc/Application.cpp b/xbmc/Application.cpp
index ce52040..c6c20e4 100644
--- a/xbmc/Application.cpp
+++ b/xbmc/Application.cpp
@@ -348,6 +348,10 @@
 #include "utils/AMLUtils.h"
 #endif
 
+#if defined(TARGET_RASPBERRY_PI)
+#include "linux/RBP.h"
+#endif
+
 #include "cores/FFmpeg.h"
 
 using namespace std;
@@ -5154,6 +5158,11 @@ void CApplication::ProcessSlow()
   if (!m_pPlayer->IsPlayingVideo())
     g_largeTextureManager.CleanupUnusedImages();
 
+#ifdef TARGET_RASPBERRY_PI
+  if (g_RBP.GetGpuMemFree() < 64)
+    g_TextureManager.FreeUnusedTextures();
+  else
+#endif
   g_TextureManager.FreeUnusedTextures(5000);
 
 #ifdef HAS_DVD_DRIVE
diff --git a/xbmc/linux/RBP.cpp b/xbmc/linux/RBP.cpp
index f789bf1..65c95a3 100644
--- a/xbmc/linux/RBP.cpp
+++ b/xbmc/linux/RBP.cpp
@@ -83,6 +83,16 @@ bool CRBP::Initialize()
   return true;
 }
 
+int CRBP::GetGpuMemFree()
+{
+  int reloc_mem = 0;
+  char response[80] = "";
+
+  if (vc_gencmd(response, sizeof response, "get_mem reloc") == 0)
+    vc_gencmd_number_property(response, "reloc", &reloc_mem);
+  return reloc_mem;
+}
+
 void CRBP::LogFirmwareVerison()
 {
   char  response[1024];
diff --git a/xbmc/linux/RBP.h b/xbmc/linux/RBP.h
index f06687c..bf6dfdb 100644
--- a/xbmc/linux/RBP.h
+++ b/xbmc/linux/RBP.h
@@ -50,6 +50,7 @@ class CRBP
   void Deinitialize();
   int GetArmMem() { return m_arm_mem; }
   int GetGpuMem() { return m_gpu_mem; }
+  int GetGpuMemFree();
   bool GetCodecMpg2() { return m_codec_mpg2_enabled; }
   bool GetCodecWvc1() { return m_codec_wvc1_enabled; }
   void GetDisplaySize(int &width, int &height);
-- 
1.9.3


From 845be398a669796dab1867168595e2b14e5f2916 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Wed, 2 Jul 2014 21:03:59 +0100
Subject: [PATCH 101/102] [omx] Restrict the number of outstanding jpeg calls
 to gpu

Allowing more than one outstanding call to gpu for texture encode/decode can be beneficial as processing
can be overlapped with vchiq message transfer.

Experimentally, 3 outstanding operations is optimal.

Allowing more that this ties up memory on GPU without any performance benefit, so avoid submitting more jobs
---
 xbmc/cores/omxplayer/OMXImage.cpp | 35 +++++++++++++++++++++++++++++++++++
 1 file changed, 35 insertions(+)

diff --git a/xbmc/cores/omxplayer/OMXImage.cpp b/xbmc/cores/omxplayer/OMXImage.cpp
index f5fe546..a3704da 100644
--- a/xbmc/cores/omxplayer/OMXImage.cpp
+++ b/xbmc/cores/omxplayer/OMXImage.cpp
@@ -49,6 +49,33 @@
 #define EXIF_TAG_ORIENTATION    0x0112
 
 
+// A helper for restricting threads calling GPU functions to limit memory use
+static XbmcThreads::ConditionVariable g_count_cond;
+static CCriticalSection               g_count_lock;
+static int g_count_val;
+
+static void limit_calls_enter(int &count, int allowed)
+{
+  //printf("%s  in=%d\n", __func__, m_count_val);
+  CSingleLock lock(g_count_lock);
+  while (count >= allowed)
+  {
+    g_count_cond.wait(lock);
+  }
+  count++;
+  //printf("%s out=%d\n", __func__, m_count_val);
+}
+
+static void limit_calls_leave(int &count)
+{
+  //printf("%s  in=%d\n", __func__, m_count_val);
+  CSingleLock lock(g_count_lock);
+  count--;
+  g_count_cond.notifyAll();
+  //printf("%s out=%d\n", __func__, m_count_val);
+}
+
+
 #ifdef CLASSNAME
 #undef CLASSNAME
 #endif
@@ -900,6 +927,7 @@ bool COMXImageFile::ReadFile(const CStdString& inputFile)
 
 COMXImageDec::COMXImageDec()
 {
+  limit_calls_enter(g_count_val, 3);
   m_decoded_buffer = NULL;
   OMX_INIT_STRUCTURE(m_decoded_format);
   m_success = false;
@@ -911,6 +939,7 @@ COMXImageDec::~COMXImageDec()
 
   OMX_INIT_STRUCTURE(m_decoded_format);
   m_decoded_buffer = NULL;
+  limit_calls_leave(g_count_val);
 }
 
 void COMXImageDec::Close()
@@ -1195,6 +1224,7 @@ bool COMXImageDec::Decode(const uint8_t *demuxer_content, unsigned demuxer_bytes
 
 COMXImageEnc::COMXImageEnc()
 {
+  limit_calls_enter(g_count_val, 3);
   CSingleLock lock(m_OMXSection);
   OMX_INIT_STRUCTURE(m_encoded_format);
   m_encoded_buffer = NULL;
@@ -1209,6 +1239,7 @@ COMXImageEnc::~COMXImageEnc()
   m_encoded_buffer = NULL;
   if(m_omx_encoder.IsInitialized())
     m_omx_encoder.Deinitialize();
+  limit_calls_leave(g_count_val);
 }
 
 bool COMXImageEnc::Encode(unsigned char *buffer, int size, unsigned width, unsigned height, unsigned int pitch)
@@ -1421,6 +1452,7 @@ bool COMXImageEnc::CreateThumbnailFromSurface(unsigned char* buffer, unsigned in
 
 COMXImageReEnc::COMXImageReEnc()
 {
+  limit_calls_enter(g_count_val, 3);
   m_encoded_buffer = NULL;
   m_pDestBuffer = NULL;
   m_nDestAllocSize = 0;
@@ -1434,6 +1466,7 @@ COMXImageReEnc::~COMXImageReEnc()
     free (m_pDestBuffer);
   m_pDestBuffer = NULL;
   m_nDestAllocSize = 0;
+  limit_calls_leave(g_count_val);
 }
 
 void COMXImageReEnc::Close()
@@ -1894,12 +1927,14 @@ bool COMXImageReEnc::ReEncode(COMXImageFile &srcFile, unsigned int maxWidth, uns
 
 COMXTexture::COMXTexture()
 {
+  limit_calls_enter(g_count_val, 3);
   m_success = false;
 }
 
 COMXTexture::~COMXTexture()
 {
   Close();
+  limit_calls_leave(g_count_val);
 }
 
 void COMXTexture::Close()
-- 
1.9.3


From edd99869f9079a7f6fb783485eee0a77f461d253 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Sat, 5 Jul 2014 19:26:46 +0100
Subject: [PATCH 102/102] [omxplayer] Explictly choose deinterlace method for
 1080i

As the 1080i deinterlace doesn't require the 3 frames of context we can save ~6MB by requesting it explicitly
---
 xbmc/cores/omxplayer/OMXVideo.cpp | 5 ++++-
 1 file changed, 4 insertions(+), 1 deletion(-)

diff --git a/xbmc/cores/omxplayer/OMXVideo.cpp b/xbmc/cores/omxplayer/OMXVideo.cpp
index 07c4643..e2a3d27 100644
--- a/xbmc/cores/omxplayer/OMXVideo.cpp
+++ b/xbmc/cores/omxplayer/OMXVideo.cpp
@@ -313,7 +313,10 @@ bool COMXVideo::PortSettingsChanged()
     {
       image_filter.nNumParams = 1;
       image_filter.nParams[0] = 3;
-      image_filter.eImageFilter = OMX_ImageFilterDeInterlaceAdvanced;
+      if (port_image.format.video.nFrameWidth * port_image.format.video.nFrameHeight > 576 * 720)
+        image_filter.eImageFilter = OMX_ImageFilterDeInterlaceFast;
+      else
+        image_filter.eImageFilter = OMX_ImageFilterDeInterlaceAdvanced;
     }
     omx_err = m_omx_image_fx.SetConfig(OMX_IndexConfigCommonImageFilterParameters, &image_filter);
     if(omx_err != OMX_ErrorNone)
-- 
1.9.3

