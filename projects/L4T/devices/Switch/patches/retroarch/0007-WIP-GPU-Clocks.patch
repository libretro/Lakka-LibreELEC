From 88a883e97e7114bc63b264f9be07f016b7a73c4e Mon Sep 17 00:00:00 2001
From: Ronald Brown <rbrown4014@yahoo.com>
Date: Sun, 5 Feb 2023 12:53:57 -0800
Subject: [PATCH 7/7] WIP: GPU Clocks

---
 Makefile.common                   |   3 +
 configuration.h                   |  10 +
 intl/msg_hash_lbl.h               |  16 ++
 intl/msg_hash_us.h                |  90 +++++++
 lakka-switch.h                    |   7 +-
 menu/cbs/menu_cbs_deferred_push.c |   9 +
 menu/cbs/menu_cbs_get_value.c     | 192 +++++++++++++
 menu/cbs/menu_cbs_left.c          | 135 +++++++++-
 menu/cbs/menu_cbs_ok.c            |  18 ++
 menu/cbs/menu_cbs_right.c         | 140 +++++++++-
 menu/cbs/menu_cbs_sublabel.c      |  41 ++-
 menu/cbs/menu_cbs_title.c         |   8 +
 menu/menu_cbs.h                   |   4 +
 menu/menu_displaylist.c           | 110 +++++++-
 menu/menu_displaylist.h           |   4 +
 menu/menu_driver.h                |   8 +-
 menu/menu_setting.c               |   9 +
 misc/gpufreq/gpufreq.c            | 431 ++++++++++++++++++++++++++++++
 misc/gpufreq/gpufreq.h            | 108 ++++++++
 msg_hash.h                        |  32 ++-
 20 files changed, 1363 insertions(+), 12 deletions(-)
 create mode 100644 misc/gpufreq/gpufreq.c
 create mode 100644 misc/gpufreq/gpufreq.h

diff --git a/Makefile.common b/Makefile.common
index 3597675751..52961fd835 100644
--- a/Makefile.common
+++ b/Makefile.common
@@ -801,6 +801,9 @@ ifeq ($(HAVE_LAKKA), 1)
    OBJ += network/drivers_wifi/connmanctl.o
    OBJ += misc/cpufreq/cpufreq.o
 endif
+ifeq ($(HAVE_LAKKA_SWITCH), 1)
+      OBJ += misc/gpufreq/gpufreq.o
+endif
 
 ifeq ($(HAVE_WIFI), 1)
    OBJ += network/wifi_driver.o
diff --git a/configuration.h b/configuration.h
index 882af40a04..f5465a4320 100644
--- a/configuration.h
+++ b/configuration.h
@@ -337,6 +337,12 @@ typedef struct settings
       unsigned cpu_max_freq;
 #endif
 
+#ifdef HAVE_LAKKA_SWITCH
+      unsigned gpu_scaling_mode;
+      unsigned gpu_min_freq;
+      unsigned gpu_max_freq;
+#endif
+
 #ifdef HAVE_MIST
       unsigned steam_rich_presence_format;
 #endif
@@ -456,6 +462,10 @@ typedef struct settings
       char timezone[TIMEZONE_LENGTH];
       char cpu_main_gov[32];
       char cpu_menu_gov[32];
+#endif
+#ifdef HAVE_LAKKA_SWITCH
+      char gpu_main_gov[32];
+      char gpu_menu_gov[32];
 #endif
    } arrays;
 
diff --git a/intl/msg_hash_lbl.h b/intl/msg_hash_lbl.h
index 1a026f1d51..b48b8f7b9c 100644
--- a/intl/msg_hash_lbl.h
+++ b/intl/msg_hash_lbl.h
@@ -1173,6 +1173,16 @@ MSG_HASH(
    MENU_ENUM_LABEL_DEFERRED_CPU_POLICY_ENTRY,
    "deferred_cpu_policy_list"
    )
+#ifdef HAVE_LAKKA_SWITCH
+MSG_HASH(
+   MENU_ENUM_LABEL_DEFERRED_GPU_PERFPOWER_LIST,
+   "deferred_gpu_perfpower_list"
+   )
+MSG_HASH(
+   MENU_ENUM_LABEL_DEFERRED_GPU_POLICY_ENTRY,
+   "deferred_gpu_policy_list"
+   )
+#endif
 MSG_HASH(
    MENU_ENUM_LABEL_DEFERRED_LAKKA_LIST,
    "deferred_lakka_list"
@@ -5793,6 +5803,12 @@ MSG_HASH(
    MENU_ENUM_LABEL_CPU_PERFPOWER,
    "cpu_perfpower_list"
    )
+#ifdef HAVE_LAKKA_SWITCH
+MSG_HASH(
+   MENU_ENUM_LABEL_GPU_PERFPOWER,
+   "gpu_perfpower_list"
+   )
+#endif
 MSG_HASH(
    MENU_ENUM_LABEL_AI_SERVICE_SETTINGS,
    "ai_service_settings"
diff --git a/intl/msg_hash_us.h b/intl/msg_hash_us.h
index a655217a80..f34eca8530 100644
--- a/intl/msg_hash_us.h
+++ b/intl/msg_hash_us.h
@@ -14972,6 +14972,96 @@ MSG_HASH(
    "Displays a list of available timezones. After selecting a time zone, time and date is adjusted to the selected time zone. It assumes, that system/hardware clock is set to UTC."
    )
 #ifdef HAVE_LAKKA_SWITCH
+
+MSG_HASH(
+   MENU_ENUM_LABEL_VALUE_GPU_PERFPOWER,
+   "GPU Performance and Power"
+   )
+MSG_HASH(
+   MENU_ENUM_LABEL_VALUE_GPU_POLICY_ENTRY,
+   "Policy"
+   )
+MSG_HASH(
+   MENU_ENUM_LABEL_VALUE_GPU_PERF_MODE,
+   "Governing Mode"
+   )
+MSG_HASH(
+   MENU_ENUM_LABEL_VALUE_GPU_PERF_MODE_MANUAL,
+   "Manual"
+   )
+MSG_HASH(
+   MENU_ENUM_SUBLABEL_VALUE_GPU_PERF_MODE_MANUAL,
+   "Allows to manually tweak every detail in every GPU: governor, frequencies, etc. Only recommended for advanced users."
+   )
+MSG_HASH(
+   MENU_ENUM_LABEL_VALUE_GPU_PERF_MODE_MANAGED_PERF,
+   "Performance (Managed)"
+   )
+MSG_HASH(
+   MENU_ENUM_SUBLABEL_VALUE_GPU_PERF_MODE_MANAGED_PERF,
+   "Default and recommended mode. Maximum performance while playing, while saving power when paused or browsing menus."
+   )
+MSG_HASH(
+   MENU_ENUM_LABEL_VALUE_GPU_PERF_MODE_MANAGED_PER_CONTEXT,
+   "Custom Managed"
+   )
+MSG_HASH(
+   MENU_ENUM_SUBLABEL_VALUE_GPU_PERF_MODE_MANAGED_PER_CONTEXT,
+   "Allows to choose what governors to use in menus and during gameplay. Performance, Ondemand or Schedutil are recommended during gameplay."
+   )
+MSG_HASH(
+   MENU_ENUM_LABEL_VALUE_GPU_PERF_MODE_MAX_PERF,
+   "Maximum Performance"
+   )
+MSG_HASH(
+   MENU_ENUM_SUBLABEL_VALUE_GPU_PERF_MODE_MAX_PERF,
+   "Always maximum performance: highest frequencies for best experience."
+   )
+MSG_HASH(
+   MENU_ENUM_LABEL_VALUE_GPU_PERF_MODE_MIN_POWER,
+   "Minimum Power"
+   )
+MSG_HASH(
+   MENU_ENUM_SUBLABEL_VALUE_GPU_PERF_MODE_MIN_POWER,
+   "Use the lowest frequency available to save power. Useful on battery powered devices but performance will be significantly reduced."
+   )
+MSG_HASH(
+   MENU_ENUM_LABEL_VALUE_GPU_PERF_MODE_BALANCED,
+   "Balanced"
+   )
+MSG_HASH(
+   MENU_ENUM_SUBLABEL_VALUE_GPU_PERF_MODE_BALANCED,
+   "Adapts to the current workload. Works well with most devices and emulators and helps to save power. Demanding games and cores might suffer a performance drop on some devices."
+   )
+MSG_HASH(
+   MENU_ENUM_LABEL_VALUE_GPU_POLICY_MIN_FREQ,
+   "Minimum Frequency"
+   )
+MSG_HASH(
+   MENU_ENUM_LABEL_VALUE_GPU_POLICY_MAX_FREQ,
+   "Maximum Frequency"
+   )
+MSG_HASH(
+   MENU_ENUM_LABEL_VALUE_GPU_MANAGED_MIN_FREQ,
+   "Minimum Core Frequency"
+   )
+MSG_HASH(
+   MENU_ENUM_LABEL_VALUE_GPU_MANAGED_MAX_FREQ,
+   "Maximum Core Frequency"
+   )
+MSG_HASH(
+   MENU_ENUM_LABEL_VALUE_GPU_POLICY_GOVERNOR,
+   "CPU Governor"
+   )
+MSG_HASH(
+   MENU_ENUM_LABEL_VALUE_GPU_POLICY_CORE_GOVERNOR,
+   "Core Governor"
+   )
+MSG_HASH(
+   MENU_ENUM_LABEL_VALUE_GPU_POLICY_MENU_GOVERNOR,
+   "Menu Governor"
+   )
+
 MSG_HASH(
    MENU_ENUM_LABEL_VALUE_LAKKA_SWITCH_OPTIONS,
    "Nintendo Switch Options"
diff --git a/lakka-switch.h b/lakka-switch.h
index fe037a0da1..2db038b9e2 100644
--- a/lakka-switch.h
+++ b/lakka-switch.h
@@ -17,16 +17,13 @@
 #define __RARCH_LAKKA_SWITCH_H
 
 #define SWITCH_OC_TOGGLE_PATH "/sys/kernel/tegra_cpufreq/overclock"
+
 #define SWITCH_CEC_TOGGLE_PATH "/tmp/.CEC"
-#define SWITCH_GPU_PROFILE_FILE_MAX_PATH  "/sys/devices/57000000.gpu/devfreq/57000000.gpu/max_freq"
-#define SWITCH_GPU_PROFILE_FILE_MIN_PATH  "/sys/devices/57000000.gpu/devfreq/57000000.gpu/min_freq"
-#define SWITCH_GPU_PROFILE_FILE_GOVERNOR_PATH "/sys/devices/57000000.gpu/devfreq/57000000.gpu/governor"
-#define SWITCH_GPU_PROFILE_FILE_AVAILABLE_GOVERNORS_PATH "/sys/devices/57000000.gpu/devfreq/57000000.gpu/available_governors"
-#define SWITCH_GPU_PROFILE_FILE_AVAILABLE_FREQ_PATH "/sys/devices/57000000.gpu/devfreq/57000000.gpu/available_governors"
 
 #define SWITCH_R2P_ENABLED_PATH "/sys/module/pmc_r2p/parameters/enabled" 
 #define SWITCH_R2P_ACTION_PATH /sys/module/pmc_r2p/parameters/action 
 #define SWITCH_R2P_ENTRY_ID_PATH /sys/module/pmc_r2p/parameters/entry_id 
 #define SWITCH_R2P_PARAM1_PATH /sys/module/pmc_r2p/parameters/param1
 #define SWITCH_R2P_PARAM2_PATH /sys/module/pmc_r2p/parameters/param2
+
 #endif
diff --git a/menu/cbs/menu_cbs_deferred_push.c b/menu/cbs/menu_cbs_deferred_push.c
index ae9fca0fd7..a3f019985c 100644
--- a/menu/cbs/menu_cbs_deferred_push.c
+++ b/menu/cbs/menu_cbs_deferred_push.c
@@ -274,6 +274,11 @@ GENERIC_DEFERRED_PUSH(deferred_push_cpu_perfpower,                  DISPLAYLIST_
 GENERIC_DEFERRED_PUSH(deferred_push_cpu_policy,                     DISPLAYLIST_CPU_POLICY_LIST)
 #endif
 
+#ifdef HAVE_LAKKA_SWITCH
+GENERIC_DEFERRED_PUSH(deferred_push_gpu_perfpower,                  DISPLAYLIST_GPU_PERFPOWER_LIST)
+GENERIC_DEFERRED_PUSH(deferred_push_gpu_policy,                     DISPLAYLIST_GPU_POLICY_LIST)
+#endif
+
 GENERIC_DEFERRED_PUSH(deferred_push_manual_content_scan_list,       DISPLAYLIST_MANUAL_CONTENT_SCAN_LIST)
 GENERIC_DEFERRED_PUSH(deferred_push_manual_content_scan_dat_file,   DISPLAYLIST_MANUAL_CONTENT_SCAN_DAT_FILES)
 
@@ -794,6 +799,10 @@ static int menu_cbs_init_bind_deferred_push_compare_label(
 #if defined(HAVE_LAKKA)
       {MENU_ENUM_LABEL_DEFERRED_CPU_PERFPOWER_LIST, deferred_push_cpu_perfpower},
       {MENU_ENUM_LABEL_DEFERRED_CPU_POLICY_ENTRY, deferred_push_cpu_policy},
+#endif
+#ifdef HAVE_LAKKA_SWITCH
+      {MENU_ENUM_LABEL_DEFERRED_GPU_PERFPOWER_LIST, deferred_push_gpu_perfpower},
+      {MENU_ENUM_LABEL_DEFERRED_GPU_POLICY_ENTRY, deferred_push_gpu_policy},
 #endif
       {MENU_ENUM_LABEL_DEFERRED_REMAPPINGS_PORT_LIST, deferred_push_remappings_port },
       {MENU_ENUM_LABEL_DEFERRED_ACCOUNTS_LIST, deferred_push_accounts_list},
diff --git a/menu/cbs/menu_cbs_get_value.c b/menu/cbs/menu_cbs_get_value.c
index c56c106598..7a943d563f 100644
--- a/menu/cbs/menu_cbs_get_value.c
+++ b/menu/cbs/menu_cbs_get_value.c
@@ -48,6 +48,9 @@
 #include "../../playlist.h"
 #include "../../manual_content_scan.h"
 #include "../misc/cpufreq/cpufreq.h"
+#ifdef HAVE_LAKKA_SWITCH
+#include "../misc/gpufreq/gpufreq.h"
+#endif
 #include "../../audio/audio_driver.h"
 
 #ifdef HAVE_NETWORKING
@@ -763,7 +766,170 @@ static void menu_action_cpu_governor_label(
    strlcpy(s, d->scaling_governor, len);
 }
 #endif
+#ifdef HAVE_LAKKA_SWITCH
+static void menu_action_setting_disp_gpu_gov_mode(
+      file_list_t* list,
+      unsigned *w, unsigned type, unsigned i,
+      const char *label,
+      char *s, size_t len,
+      const char *path,
+      char *s2, size_t len2)
+{
+   const char *alt        = list->list[i].alt
+         ? list->list[i].alt
+         : list->list[i].path;
+   enum gpu_scaling_mode mode = get_gpu_scaling_mode(NULL);
+
+   if (alt)
+      strlcpy(s2, alt, len2);
+
+   strlcpy(s, msg_hash_to_str(
+      MENU_ENUM_LABEL_VALUE_GPU_PERF_MODE_MANAGED_PERF + (int)mode), len);
+}
+
+static void menu_action_setting_disp_gpu_gov_choose(
+      file_list_t* list,
+      unsigned *w, unsigned type, unsigned i,
+      const char *label,
+      char *s, size_t len,
+      const char *path,
+      char *s2, size_t len2)
+{
+   gpu_scaling_opts_t opts;
+   const char *alt            = list->list[i].alt
+         ? list->list[i].alt
+         : list->list[i].path;
+   int fnum                   = atoi(list->list[i].label);
+   enum gpu_scaling_mode mode = get_gpu_scaling_mode(&opts);
+
+   if (alt)
+      strlcpy(s2, alt, len2);
+
+   if (!fnum)
+      strlcpy(s, opts.main_policy, len);
+   else
+      strlcpy(s, opts.menu_policy, len);
+}
+
+static void menu_action_setting_disp_set_label_gpu_policy(
+      file_list_t* list,
+      unsigned *w, unsigned type, unsigned i,
+      const char *label,
+      char *s, size_t len,
+      const char *path,
+      char *s2, size_t len2)
+{
+   unsigned policyid = atoi(path);
+   gpu_scaling_driver_t **drivers = get_gpu_scaling_drivers(false);
+   gpu_scaling_driver_t *d = drivers[policyid];
+
+   *s = '\0';
+   *w = 0;
+
+   if (d->affected_gpus)
+      snprintf(s2, len2, "%s %d [CPU(s) %s]", msg_hash_to_str(
+         MENU_ENUM_LABEL_VALUE_GPU_POLICY_ENTRY), policyid,
+         d->affected_gpus);
+   else
+      snprintf(s2, len2, "%s %d", msg_hash_to_str(
+         MENU_ENUM_LABEL_VALUE_GPU_POLICY_ENTRY), policyid);
+}
+
+static void menu_action_gpu_managed_freq_label(
+      file_list_t* list,
+      unsigned *w, unsigned type, unsigned i,
+      const char *label,
+      char *s, size_t len,
+      const char *path,
+      char *s2, size_t len2)
+{
+   gpu_scaling_opts_t opts;
+   uint32_t freq              = 0;
+   enum gpu_scaling_mode mode = get_gpu_scaling_mode(&opts);
+
+   switch (type)
+   {
+      case MENU_SETTINGS_GPU_MANAGED_SET_MINFREQ:
+         strlcpy(s2, msg_hash_to_str(
+                  MENU_ENUM_LABEL_VALUE_GPU_MANAGED_MIN_FREQ), len2);
+         freq = opts.min_freq;
+         break;
+      case MENU_SETTINGS_GPU_MANAGED_SET_MAXFREQ:
+         strlcpy(s2, msg_hash_to_str(
+                  MENU_ENUM_LABEL_VALUE_GPU_MANAGED_MAX_FREQ), len2);
+         freq = opts.max_freq;
+         break;
+   };
+
+   if (freq == 1)
+   {
+      s[0] = 'M';
+      s[1] = 'i';
+      s[2] = 'n';
+      s[3] = '.';
+      s[4] = '\0';
+   }
+   else if (freq == ~0U)
+   {
+      s[0] = 'M';
+      s[1] = 'a';
+      s[2] = 'x';
+      s[3] = '.';
+      s[4] = '\0';
+   }
+   else
+      snprintf(s, len, "%u MHz", freq / 1000);
+}
+
+static void menu_action_gpu_freq_label(
+      file_list_t* list,
+      unsigned *w, unsigned type, unsigned i,
+      const char *label,
+      char *s, size_t len,
+      const char *path,
+      char *s2, size_t len2)
+{
+   unsigned              policyid = atoi(path);
+   gpu_scaling_driver_t **drivers = get_gpu_scaling_drivers(false);
+   gpu_scaling_driver_t        *d = drivers[policyid];
+
+   switch (type)
+   {
+      case MENU_SETTINGS_GPU_POLICY_SET_MINFREQ:
+         strlcpy(s2, msg_hash_to_str(
+                  MENU_ENUM_LABEL_VALUE_GPU_POLICY_MIN_FREQ), len2);
+         snprintf(s, len, "%u MHz", d->min_policy_freq / 1000);
+         break;
+      case MENU_SETTINGS_GPU_POLICY_SET_MAXFREQ:
+         strlcpy(s2, msg_hash_to_str(
+                  MENU_ENUM_LABEL_VALUE_GPU_POLICY_MAX_FREQ), len2);
+         snprintf(s, len, "%u MHz", d->max_policy_freq / 1000);
+         break;
+      case MENU_SETTINGS_GPU_POLICY_SET_GOVERNOR:
+         strlcpy(s2, msg_hash_to_str(
+                  MENU_ENUM_LABEL_VALUE_GPU_POLICY_GOVERNOR), len2);
+         strlcpy(s, d->scaling_governor, len);
+         break;
+   };
+}
 
+static void menu_action_gpu_governor_label(
+      file_list_t* list,
+      unsigned *w, unsigned type, unsigned i,
+      const char *label,
+      char *s, size_t len,
+      const char *path,
+      char *s2, size_t len2)
+{
+   unsigned policyid = atoi(path);
+   gpu_scaling_driver_t **drivers = get_gpu_scaling_drivers(false);
+   gpu_scaling_driver_t *d = drivers[policyid];
+
+   strlcpy(s2, msg_hash_to_str(
+      MENU_ENUM_LABEL_VALUE_GPU_POLICY_GOVERNOR), len2);
+   strlcpy(s, d->scaling_governor, len);
+}
+#endif
 static void menu_action_setting_disp_set_label_core_lock(
       file_list_t* list,
       unsigned *w, unsigned type, unsigned i,
@@ -2064,6 +2230,32 @@ static int menu_cbs_init_bind_get_string_representation_compare_label(
             BIND_ACTION_GET_VALUE(cbs, menu_action_cpu_governor_label);
             break;
          #endif
+         #ifdef HAVE_LAKKA_SWITCH
+         case MENU_ENUM_LABEL_GPU_PERF_MODE:
+            BIND_ACTION_GET_VALUE(cbs,
+                  menu_action_setting_disp_gpu_gov_mode);
+            break;
+         case MENU_ENUM_LABEL_GPU_POLICY_CORE_GOVERNOR:
+         case MENU_ENUM_LABEL_GPU_POLICY_MENU_GOVERNOR:
+            BIND_ACTION_GET_VALUE(cbs,
+                  menu_action_setting_disp_gpu_gov_choose);
+            break;
+         case MENU_ENUM_LABEL_GPU_POLICY_ENTRY:
+            BIND_ACTION_GET_VALUE(cbs,
+                  menu_action_setting_disp_set_label_gpu_policy);
+            break;
+         case MENU_ENUM_LABEL_GPU_POLICY_MIN_FREQ:
+         case MENU_ENUM_LABEL_GPU_POLICY_MAX_FREQ:
+            BIND_ACTION_GET_VALUE(cbs, menu_action_gpu_freq_label);
+            break;
+         case MENU_ENUM_LABEL_GPU_MANAGED_MIN_FREQ:
+         case MENU_ENUM_LABEL_GPU_MANAGED_MAX_FREQ:
+            BIND_ACTION_GET_VALUE(cbs, menu_action_gpu_managed_freq_label);
+            break;
+         case MENU_ENUM_LABEL_GPU_POLICY_GOVERNOR:
+            BIND_ACTION_GET_VALUE(cbs, menu_action_gpu_governor_label);
+            break;
+         #endif
          default:
             return -1;
       }
diff --git a/menu/cbs/menu_cbs_left.c b/menu/cbs/menu_cbs_left.c
index d8b8eb1b01..164122004c 100644
--- a/menu/cbs/menu_cbs_left.c
+++ b/menu/cbs/menu_cbs_left.c
@@ -47,7 +47,9 @@
 #include "../../playlist.h"
 #include "../../manual_content_scan.h"
 #include "../misc/cpufreq/cpufreq.h"
-
+#ifdef HAVE_LAKKA_SWITCH
+#include "../misc/gpufreq/gpufreq.h"
+#endif
 #ifndef BIND_ACTION_LEFT
 #define BIND_ACTION_LEFT(cbs, name) (cbs)->action_left = (name)
 #endif
@@ -800,7 +802,120 @@ static int cpu_policy_freq_tweak(unsigned type, const char *label,
    return 0;
 }
 #endif
+#ifdef HAVE_LAKKA_SWITCH
+static int gpu_policy_mode_change(unsigned type, const char *label,
+      bool wraparound)
+{
+   bool refresh = false;
+   enum gpu_scaling_mode mode = get_gpu_scaling_mode(NULL);
+   if (mode != GPUSCALING_MANAGED_PERFORMANCE)
+      mode--;
+   set_gpu_scaling_mode(mode, NULL);
+   menu_entries_ctl(MENU_ENTRIES_CTL_SET_REFRESH, &refresh);
+   return 0;
+}
+
+static int gpu_policy_freq_managed_tweak(unsigned type, const char *label,
+      bool wraparound)
+{
+   bool refresh = false;
+   gpu_scaling_opts_t opts;
+   enum gpu_scaling_mode mode = get_gpu_scaling_mode(&opts);
+
+   switch (type) {
+   case MENU_SETTINGS_GPU_MANAGED_SET_MINFREQ:
+      opts.min_freq = get_gpu_scaling_next_frequency_limit(
+         opts.min_freq, -1);
+      set_gpu_scaling_mode(mode, &opts);
+      break;
+   case MENU_SETTINGS_GPU_MANAGED_SET_MAXFREQ:
+      opts.max_freq = get_gpu_scaling_next_frequency_limit(
+         opts.max_freq, -1);
+      set_gpu_scaling_mode(mode, &opts);
+      break;
+   };
+
+   return 0;
+}
 
+static int gpu_policy_freq_managed_gov(unsigned type, const char *label,
+      bool wraparound)
+{
+   int pidx;
+   bool refresh = false;
+   gpu_scaling_opts_t opts;
+   enum gpu_scaling_mode mode = get_gpu_scaling_mode(&opts);
+   gpu_scaling_driver_t **drivers = get_gpu_scaling_drivers(false);
+
+   /* Using drivers[0] governors, should be improved */
+   if (!drivers || !drivers[0])
+      return -1;
+
+   switch (atoi(label)) {
+   case 0:
+      pidx = string_list_find_elem(drivers[0]->available_governors,
+         opts.main_policy);
+      if (pidx > 1)
+      {
+         strlcpy(opts.main_policy,
+            drivers[0]->available_governors->elems[pidx-2].data,
+            sizeof(opts.main_policy));
+         set_gpu_scaling_mode(mode, &opts);
+      }
+      break;
+   case 1:
+      pidx = string_list_find_elem(drivers[0]->available_governors,
+         opts.menu_policy);
+      if (pidx > 1)
+      {
+         strlcpy(opts.menu_policy,
+            drivers[0]->available_governors->elems[pidx-2].data,
+            sizeof(opts.menu_policy));
+         set_gpu_scaling_mode(mode, &opts);
+      }
+      break;
+   };
+
+   return 0;
+}
+
+static int gpu_policy_freq_tweak(unsigned type, const char *label,
+      bool wraparound)
+{
+   bool refresh = false;
+   gpu_scaling_driver_t **drivers = get_gpu_scaling_drivers(false);
+   unsigned policyid = atoi(label);
+   uint32_t next_freq;
+   if (!drivers)
+     return 0;
+
+   switch (type) {
+   case MENU_SETTINGS_GPU_POLICY_SET_MINFREQ:
+      next_freq = get_gpu_scaling_next_frequency(drivers[policyid],
+         drivers[policyid]->min_policy_freq, -1);
+      set_gpu_scaling_min_frequency(drivers[policyid], next_freq);
+      break;
+   case MENU_SETTINGS_GPU_POLICY_SET_MAXFREQ:
+      next_freq = get_gpu_scaling_next_frequency(drivers[policyid],
+         drivers[policyid]->max_policy_freq, -1);
+      set_gpu_scaling_max_frequency(drivers[policyid], next_freq);
+      break;
+   case MENU_SETTINGS_CPU_POLICY_SET_GOVERNOR:
+   {
+      int pidx = string_list_find_elem(drivers[policyid]->available_governors,
+         drivers[policyid]->scaling_governor);
+      if (pidx > 1)
+      {
+         set_gpu_scaling_governor(drivers[policyid],
+            drivers[policyid]->available_governors->elems[pidx-2].data);
+      }
+      break;
+   }
+   };
+
+   return 0;
+}
+#endif
 static int core_setting_left(unsigned type, const char *label,
       bool wraparound)
 {
@@ -1131,6 +1246,24 @@ static int menu_cbs_init_bind_left_compare_label(menu_file_list_cbs_t *cbs,
                BIND_ACTION_LEFT(cbs, cpu_policy_freq_managed_gov);
                break;
             #endif
+            #ifdef HAVE_LAKKA_SWITCH
+            case MENU_ENUM_LABEL_GPU_PERF_MODE:
+               BIND_ACTION_LEFT(cbs, gpu_policy_mode_change);
+               break;
+            case MENU_ENUM_LABEL_GPU_POLICY_MAX_FREQ:
+            case MENU_ENUM_LABEL_GPU_POLICY_MIN_FREQ:
+            case MENU_ENUM_LABEL_GPU_POLICY_GOVERNOR:
+               BIND_ACTION_LEFT(cbs, gpu_policy_freq_tweak);
+               break;
+            case MENU_ENUM_LABEL_GPU_MANAGED_MIN_FREQ:
+            case MENU_ENUM_LABEL_GPU_MANAGED_MAX_FREQ:
+               BIND_ACTION_LEFT(cbs, gpu_policy_freq_managed_tweak);
+               break;
+            case MENU_ENUM_LABEL_GPU_POLICY_CORE_GOVERNOR:
+            case MENU_ENUM_LABEL_GPU_POLICY_MENU_GOVERNOR:
+               BIND_ACTION_LEFT(cbs, gpu_policy_freq_managed_gov);
+               break;
+            #endif
             default:
                return -1;
          }
diff --git a/menu/cbs/menu_cbs_ok.c b/menu/cbs/menu_cbs_ok.c
index 668d49b8ff..6c951c96e4 100644
--- a/menu/cbs/menu_cbs_ok.c
+++ b/menu/cbs/menu_cbs_ok.c
@@ -411,6 +411,12 @@ static enum msg_hash_enums action_ok_dl_to_enum(unsigned lbl)
          return MENU_ENUM_LABEL_DEFERRED_CPU_PERFPOWER_LIST;
       case ACTION_OK_DL_CPU_POLICY_SETTINGS_LIST:
          return MENU_ENUM_LABEL_DEFERRED_CPU_POLICY_ENTRY;
+#ifdef HAVE_LAKKA_SWITCH
+      case ACTION_OK_DL_GPU_PERFPOWER_SETTINGS_LIST:
+         return MENU_ENUM_LABEL_DEFERRED_GPU_PERFPOWER_LIST;
+      case ACTION_OK_DL_GPU_POLICY_SETTINGS_LIST:
+         return MENU_ENUM_LABEL_DEFERRED_GPU_POLICY_ENTRY;
+#endif
       case ACTION_OK_DL_MENU_SOUNDS_LIST:
          return MENU_ENUM_LABEL_DEFERRED_MENU_SOUNDS_LIST;
       case ACTION_OK_DL_MENU_FILE_BROWSER_SETTINGS_LIST:
@@ -1648,6 +1654,10 @@ int generic_action_ok_displaylist_push(const char *path,
       case ACTION_OK_DL_POWER_MANAGEMENT_SETTINGS_LIST:
       case ACTION_OK_DL_CPU_PERFPOWER_SETTINGS_LIST:
       case ACTION_OK_DL_CPU_POLICY_SETTINGS_LIST:
+#ifdef HAVE_LAKKA_SWITCH
+      case ACTION_OK_DL_GPU_PERFPOWER_SETTINGS_LIST:
+      case ACTION_OK_DL_GPU_POLICY_SETTINGS_LIST:
+#endif
       case ACTION_OK_DL_MENU_SOUNDS_LIST:
       case ACTION_OK_DL_MENU_FILE_BROWSER_SETTINGS_LIST:
       case ACTION_OK_DL_RETRO_ACHIEVEMENTS_SETTINGS_LIST:
@@ -5887,6 +5897,10 @@ DEFAULT_ACTION_OK_FUNC(action_ok_quick_menu_views_list, ACTION_OK_DL_QUICK_MENU_
 DEFAULT_ACTION_OK_FUNC(action_ok_power_management_list, ACTION_OK_DL_POWER_MANAGEMENT_SETTINGS_LIST)
 DEFAULT_ACTION_OK_FUNC(action_ok_cpu_perfpower_list, ACTION_OK_DL_CPU_PERFPOWER_SETTINGS_LIST)
 DEFAULT_ACTION_OK_FUNC(action_ok_cpu_policy_entry, ACTION_OK_DL_CPU_POLICY_SETTINGS_LIST)
+#ifdef HAVE_LAKKA_SWITCH
+DEFAULT_ACTION_OK_FUNC(action_ok_gpu_perfpower_list, ACTION_OK_DL_GPU_PERFPOWER_SETTINGS_LIST)
+DEFAULT_ACTION_OK_FUNC(action_ok_gpu_policy_entry, ACTION_OK_DL_GPU_POLICY_SETTINGS_LIST)
+#endif
 DEFAULT_ACTION_OK_FUNC(action_ok_menu_sounds_list, ACTION_OK_DL_MENU_SOUNDS_LIST)
 DEFAULT_ACTION_OK_FUNC(action_ok_user_interface_list, ACTION_OK_DL_USER_INTERFACE_SETTINGS_LIST)
 DEFAULT_ACTION_OK_FUNC(action_ok_menu_file_browser_list, ACTION_OK_DL_MENU_FILE_BROWSER_SETTINGS_LIST)
@@ -8469,6 +8483,10 @@ static int menu_cbs_init_bind_ok_compare_label(menu_file_list_cbs_t *cbs,
          {MENU_ENUM_LABEL_POWER_MANAGEMENT_SETTINGS,           action_ok_power_management_list},
          {MENU_ENUM_LABEL_CPU_PERFPOWER,                       action_ok_cpu_perfpower_list},
          {MENU_ENUM_LABEL_CPU_POLICY_ENTRY,                    action_ok_cpu_policy_entry},
+#ifdef HAVE_LAKKA_SWITCH
+         {MENU_ENUM_LABEL_GPU_PERFPOWER,                       action_ok_gpu_perfpower_list},
+         {MENU_ENUM_LABEL_GPU_POLICY_ENTRY,                    action_ok_gpu_policy_entry},
+#endif
          {MENU_ENUM_LABEL_MENU_SOUNDS,                         action_ok_menu_sounds_list},
          {MENU_ENUM_LABEL_MENU_FILE_BROWSER_SETTINGS,          action_ok_menu_file_browser_list},
          {MENU_ENUM_LABEL_FILE_BROWSER_OPEN_UWP_PERMISSIONS,   action_ok_open_uwp_permission_settings},
diff --git a/menu/cbs/menu_cbs_right.c b/menu/cbs/menu_cbs_right.c
index 396b89064a..00aeee607d 100644
--- a/menu/cbs/menu_cbs_right.c
+++ b/menu/cbs/menu_cbs_right.c
@@ -48,7 +48,9 @@
 #include "../../playlist.h"
 #include "../../manual_content_scan.h"
 #include "../misc/cpufreq/cpufreq.h"
-
+#ifdef HAVE_LAKKA_SWITCH
+#include "../misc/gpufreq/gpufreq.h"
+#endif
 #ifndef BIND_ACTION_RIGHT
 #define BIND_ACTION_RIGHT(cbs, name) (cbs)->action_right = (name)
 #endif
@@ -913,6 +915,124 @@ static int cpu_policy_freq_tweak(unsigned type, const char *label,
 }
 #endif
 
+#ifdef HAVE_LAKKA_SWITCH
+static int gpu_policy_mode_change(unsigned type, const char *label,
+      bool wraparound)
+{
+   bool refresh = false;
+   enum gpu_scaling_mode mode = get_gpu_scaling_mode(NULL);
+   if (mode != GPUSCALING_MANUAL)
+      mode++;
+   set_gpu_scaling_mode(mode, NULL);
+   menu_entries_ctl(MENU_ENTRIES_CTL_SET_REFRESH, &refresh);
+   return 0;
+}
+
+static int gpu_policy_freq_managed_tweak(unsigned type, const char *label,
+      bool wraparound)
+{
+   bool refresh = false;
+   gpu_scaling_opts_t opts;
+   enum gpu_scaling_mode mode = get_gpu_scaling_mode(&opts);
+
+   switch (type)
+   {
+      case MENU_SETTINGS_GPU_MANAGED_SET_MINFREQ:
+         opts.min_freq = get_gpu_scaling_next_frequency_limit(
+               opts.min_freq, 1);
+         set_gpu_scaling_mode(mode, &opts);
+         break;
+      case MENU_SETTINGS_GPU_MANAGED_SET_MAXFREQ:
+         opts.max_freq = get_gpu_scaling_next_frequency_limit(
+               opts.max_freq, 1);
+         set_gpu_scaling_mode(mode, &opts);
+         break;
+   }
+
+   return 0;
+}
+
+static int gpu_policy_freq_managed_gov(unsigned type, const char *label,
+      bool wraparound)
+{
+   int pidx;
+   bool refresh = false;
+   gpu_scaling_opts_t opts;
+   enum gpu_scaling_mode mode     = get_gpu_scaling_mode(&opts);
+   gpu_scaling_driver_t **drivers = get_gpu_scaling_drivers(false);
+
+   /* Using drivers[0] governors, should be improved */
+   if (!drivers || !drivers[0])
+      return -1;
+
+   switch (atoi(label))
+   {
+      case 0:
+         pidx = string_list_find_elem(drivers[0]->available_governors,
+               opts.main_policy);
+         if (pidx && pidx + 1 < drivers[0]->available_governors->size)
+         {
+            strlcpy(opts.main_policy,
+                  drivers[0]->available_governors->elems[pidx].data,
+                  sizeof(opts.main_policy));
+            set_cpu_scaling_mode(mode, &opts);
+         }
+         break;
+      case 1:
+         pidx = string_list_find_elem(drivers[0]->available_governors,
+               opts.menu_policy);
+         if (pidx && pidx + 1 < drivers[0]->available_governors->size)
+         {
+            strlcpy(opts.menu_policy,
+                  drivers[0]->available_governors->elems[pidx].data,
+                  sizeof(opts.menu_policy));
+            set_gpu_scaling_mode(mode, &opts);
+         }
+         break;
+   }
+
+   return 0;
+}
+
+static int gpu_policy_freq_tweak(unsigned type, const char *label,
+      bool wraparound)
+{
+   gpu_scaling_driver_t **drivers = get_gpu_scaling_drivers(false);
+
+   if (drivers)
+   {
+      uint32_t next_freq;
+      unsigned policyid           = atoi(label);
+      switch (type)
+      {
+         case MENU_SETTINGS_GPU_POLICY_SET_MINFREQ:
+            next_freq = get_gpu_scaling_next_frequency(drivers[policyid],
+                  drivers[policyid]->min_policy_freq, 1);
+            set_gpu_scaling_min_frequency(drivers[policyid], next_freq);
+            break;
+         case MENU_SETTINGS_GPU_POLICY_SET_MAXFREQ:
+            next_freq = get_gpu_scaling_next_frequency(drivers[policyid],
+                  drivers[policyid]->max_policy_freq, 1);
+            set_gpu_scaling_max_frequency(drivers[policyid], next_freq);
+            break;
+         case MENU_SETTINGS_GPU_POLICY_SET_GOVERNOR:
+            {
+               int pidx = string_list_find_elem(drivers[policyid]->available_governors,
+                     drivers[policyid]->scaling_governor);
+               if (pidx && pidx + 1 < drivers[policyid]->available_governors->size)
+               {
+                  set_gpu_scaling_governor(drivers[policyid],
+                        drivers[policyid]->available_governors->elems[pidx].data);
+               }
+               break;
+            }
+      }
+   }
+
+   return 0;
+}
+#endif
+
 int core_setting_right(unsigned type, const char *label,
       bool wraparound)
 {
@@ -1257,6 +1377,24 @@ static int menu_cbs_init_bind_right_compare_label(menu_file_list_cbs_t *cbs,
                BIND_ACTION_RIGHT(cbs, cpu_policy_freq_managed_gov);
                break;
             #endif
+            #ifdef HAVE_LAKKA_SWITCH
+            case MENU_ENUM_LABEL_GPU_PERF_MODE:
+               BIND_ACTION_RIGHT(cbs, gpu_policy_mode_change);
+               break;
+            case MENU_ENUM_LABEL_GPU_POLICY_MAX_FREQ:
+            case MENU_ENUM_LABEL_GPU_POLICY_MIN_FREQ:
+            case MENU_ENUM_LABEL_GPU_POLICY_GOVERNOR:
+               BIND_ACTION_RIGHT(cbs, gpu_policy_freq_tweak);
+               break;
+            case MENU_ENUM_LABEL_GPU_MANAGED_MIN_FREQ:
+            case MENU_ENUM_LABEL_GPU_MANAGED_MAX_FREQ:
+               BIND_ACTION_RIGHT(cbs, gpu_policy_freq_managed_tweak);
+               break;
+            case MENU_ENUM_LABEL_GPU_POLICY_CORE_GOVERNOR:
+            case MENU_ENUM_LABEL_GPU_POLICY_MENU_GOVERNOR:
+               BIND_ACTION_RIGHT(cbs, gpu_policy_freq_managed_gov);
+               break;
+            #endif
             default:
                return -1;
          }
diff --git a/menu/cbs/menu_cbs_sublabel.c b/menu/cbs/menu_cbs_sublabel.c
index f3a39dd519..507a522415 100644
--- a/menu/cbs/menu_cbs_sublabel.c
+++ b/menu/cbs/menu_cbs_sublabel.c
@@ -36,7 +36,9 @@
 #include "../../bluetooth/bluetooth_driver.h"
 #endif
 #include "../../misc/cpufreq/cpufreq.h"
-
+#ifdef HAVE_LAKKA_SWITCH
+#include "../../misc/gpufreq/gpufreq.h"
+#endif
 #ifdef HAVE_NETWORKING
 #include "../../network/netplay/netplay.h"
 #endif
@@ -1341,7 +1343,38 @@ static int action_bind_sublabel_cpu_perf_mode(
    return 0;
 }
 #endif
+#ifdef HAVE_LAKKA_SWITCH
+static int action_bind_sublabel_gpu_policy_entry_list(
+      file_list_t *list,
+      unsigned type, unsigned i,
+      const char *label, const char *path,
+      char *s, size_t len)
+{
+   /* Displays info about the Policy entry */
+   gpu_scaling_driver_t **drivers = get_gpu_scaling_drivers(false);
+   int idx = atoi(path);
+   if (drivers)
+   {
+      snprintf(s, len, "%s | Freq: %u MHz\n", drivers[idx]->scaling_governor,
+         drivers[idx]->current_frequency / 1000);
+      return 0;
+   }
 
+   return -1;
+}
+static int action_bind_sublabel_gpu_perf_mode(
+      file_list_t *list,
+      unsigned type, unsigned i,
+      const char *label, const char *path,
+      char *s, size_t len)
+{
+   /* Displays info about the mode selected */
+   enum gpu_scaling_mode mode = get_gpu_scaling_mode(NULL);
+   strlcpy(s, msg_hash_to_str(
+      MENU_ENUM_SUBLABEL_VALUE_GPU_PERF_MODE_MANAGED_PERF + (int)mode), len);
+   return 0;
+}
+#endif
 #ifdef HAVE_CHEEVOS
 static int action_bind_sublabel_cheevos_entry(
       file_list_t *list,
@@ -4872,6 +4905,12 @@ int menu_cbs_init_bind_sublabel(menu_file_list_cbs_t *cbs,
          case MENU_ENUM_LABEL_SWITCH_CEC_ENABLE:
             BIND_ACTION_SUBLABEL(cbs, action_bind_sublabel_switch_cec_enable);
             break;
+         case MENU_ENUM_LABEL_GPU_POLICY_ENTRY:
+            BIND_ACTION_SUBLABEL(cbs, action_bind_sublabel_gpu_policy_entry_list);
+            break;
+         case MENU_ENUM_LABEL_GPU_PERF_MODE:
+            BIND_ACTION_SUBLABEL(cbs, action_bind_sublabel_gpu_perf_mode);
+            break;
 #endif
          case MENU_ENUM_LABEL_USER_LANGUAGE:
             BIND_ACTION_SUBLABEL(cbs, action_bind_sublabel_user_language);
diff --git a/menu/cbs/menu_cbs_title.c b/menu/cbs/menu_cbs_title.c
index 905722736c..a893ca2a8c 100644
--- a/menu/cbs/menu_cbs_title.c
+++ b/menu/cbs/menu_cbs_title.c
@@ -654,6 +654,10 @@ DEFAULT_TITLE_MACRO(action_get_accessibility_settings_list,     MENU_ENUM_LABEL_
 DEFAULT_TITLE_MACRO(action_get_power_management_settings_list,  MENU_ENUM_LABEL_VALUE_POWER_MANAGEMENT_SETTINGS)
 DEFAULT_TITLE_MACRO(action_get_cpu_perfpower_settings_list,     MENU_ENUM_LABEL_VALUE_CPU_PERFPOWER)
 DEFAULT_TITLE_MACRO(action_get_cpu_policy_entry_list,           MENU_ENUM_LABEL_VALUE_CPU_POLICY_ENTRY)
+#ifdef HAVE_LAKKA_SWITCH
+DEFAULT_TITLE_MACRO(action_get_gpu_perfpower_settings_list,     MENU_ENUM_LABEL_VALUE_GPU_PERFPOWER)
+DEFAULT_TITLE_MACRO(action_get_gpu_policy_entry_list,           MENU_ENUM_LABEL_VALUE_GPU_POLICY_ENTRY)
+#endif
 DEFAULT_TITLE_MACRO(action_get_menu_sounds_list,                MENU_ENUM_LABEL_VALUE_MENU_SOUNDS)
 DEFAULT_TITLE_MACRO(action_get_menu_file_browser_settings_list, MENU_ENUM_LABEL_VALUE_MENU_FILE_BROWSER_SETTINGS)
 DEFAULT_TITLE_MACRO(action_get_retro_achievements_settings_list,MENU_ENUM_LABEL_VALUE_RETRO_ACHIEVEMENTS_SETTINGS)
@@ -1016,6 +1020,10 @@ static int menu_cbs_init_bind_title_compare_label(menu_file_list_cbs_t *cbs,
       {MENU_ENUM_LABEL_DEFERRED_POWER_MANAGEMENT_SETTINGS_LIST,       action_get_power_management_settings_list},
       {MENU_ENUM_LABEL_DEFERRED_CPU_PERFPOWER_LIST,                   action_get_cpu_perfpower_settings_list},
       {MENU_ENUM_LABEL_DEFERRED_CPU_POLICY_ENTRY,                     action_get_cpu_policy_entry_list},
+#ifdef HAVE_LAKKA_SWITCH
+      {MENU_ENUM_LABEL_DEFERRED_GPU_PERFPOWER_LIST,                   action_get_gpu_perfpower_settings_list},
+      {MENU_ENUM_LABEL_DEFERRED_GPU_POLICY_ENTRY,                     action_get_gpu_policy_entry_list},
+#endif
       {MENU_ENUM_LABEL_DEFERRED_MENU_SOUNDS_LIST,                     action_get_menu_sounds_list},
       {MENU_ENUM_LABEL_DEFERRED_MENU_FILE_BROWSER_SETTINGS_LIST,      action_get_menu_file_browser_settings_list},
       {MENU_ENUM_LABEL_DEFERRED_RETRO_ACHIEVEMENTS_SETTINGS_LIST,     action_get_retro_achievements_settings_list},
diff --git a/menu/menu_cbs.h b/menu/menu_cbs.h
index 57f11cf23b..411b34fc50 100644
--- a/menu/menu_cbs.h
+++ b/menu/menu_cbs.h
@@ -199,6 +199,10 @@ enum
    ACTION_OK_DL_POWER_MANAGEMENT_SETTINGS_LIST,
    ACTION_OK_DL_CPU_PERFPOWER_SETTINGS_LIST,
    ACTION_OK_DL_CPU_POLICY_SETTINGS_LIST,
+#ifdef HAVE_LAKKA_SWITCH
+   ACTION_OK_DL_GPU_PERFPOWER_SETTINGS_LIST,
+   ACTION_OK_DL_GPU_POLICY_SETTINGS_LIST,
+#endif   
    ACTION_OK_DL_MENU_SOUNDS_LIST,
    ACTION_OK_DL_MENU_FILE_BROWSER_SETTINGS_LIST,
    ACTION_OK_DL_RETRO_ACHIEVEMENTS_SETTINGS_LIST,
diff --git a/menu/menu_displaylist.c b/menu/menu_displaylist.c
index c23808d904..4b1a91e3a7 100644
--- a/menu/menu_displaylist.c
+++ b/menu/menu_displaylist.c
@@ -122,8 +122,10 @@
 #include "../manual_content_scan.h"
 #include "../core_backup.h"
 #include "../misc/cpufreq/cpufreq.h"
+#ifdef HAVE_LAKKA_SWITCH
+#include "../misc/gpufreq/gpufreq.h"
+#endif
 #include "../input/input_remapping.h"
-
 #ifdef HAVE_MIST
 #include "../steam/steam.h"
 #endif
@@ -9989,7 +9991,10 @@ unsigned menu_displaylist_build_list(
             menu_displaylist_build_info_t build_list[] = {
                {MENU_ENUM_LABEL_SUSTAINED_PERFORMANCE_MODE, PARSE_ONLY_BOOL},
                {MENU_ENUM_LABEL_CPU_PERFPOWER,              PARSE_ACTION},
-#ifdef HAVE_LAKKA
+#ifdef HAVE_LAKKA_SWITCH
+               {MENU_ENUM_LABEL_GPU_PERFPOWER,              PARSE_ACTION},
+#endif
+#ifndef HAVE_LAKKA
                {MENU_ENUM_LABEL_GAMEMODE_ENABLE,            PARSE_ONLY_BOOL},
 #endif /*HAVE_LAKKA*/
             };
@@ -11820,6 +11825,107 @@ bool menu_displaylist_ctl(enum menu_displaylist_ctl_state type,
          break;
       }
 #endif
+#ifdef HAVE_LAKKA_SWITCH
+      case DISPLAYLIST_GPU_POLICY_LIST:
+         menu_entries_ctl(MENU_ENTRIES_CTL_CLEAR, info->list);
+
+         menu_entries_append(info->list,
+            info->path,
+            info->path,
+            MENU_ENUM_LABEL_GPU_POLICY_MIN_FREQ,
+            MENU_SETTINGS_GPU_POLICY_SET_MINFREQ, 0, 0, NULL);
+
+         menu_entries_append(info->list,
+            info->path,
+            info->path,
+            MENU_ENUM_LABEL_GPU_POLICY_MAX_FREQ,
+            MENU_SETTINGS_GPU_POLICY_SET_MAXFREQ, 0, 0, NULL);
+
+         menu_entries_append(info->list,
+            info->path,
+            info->path,
+            MENU_ENUM_LABEL_GPU_POLICY_GOVERNOR,
+            MENU_SETTINGS_GPU_POLICY_SET_GOVERNOR, 0, 0, NULL);
+
+         info->flags       |= MD_FLAG_NEED_REFRESH
+                            | MD_FLAG_NEED_PUSH
+                            | MD_FLAG_NEED_CLEAR;
+         break;
+      case DISPLAYLIST_GPU_PERFPOWER_LIST:
+      {
+         cpu_scaling_driver_t **drivers = get_gpu_scaling_drivers(true);
+         menu_entries_ctl(MENU_ENTRIES_CTL_CLEAR, info->list);
+         if (drivers)
+         {
+            int count = 0;
+
+            menu_entries_append(info->list,
+               msg_hash_to_str(MENU_ENUM_LABEL_VALUE_GPU_PERF_MODE),
+               msg_hash_to_str(MENU_ENUM_LABEL_GPU_PERF_MODE),
+               MENU_ENUM_LABEL_GPU_PERF_MODE,
+               0, 0, 0, NULL);
+
+            switch (get_gpu_scaling_mode(NULL))
+            {
+               case GPUSCALING_MANUAL:
+                  while (*drivers)
+                  {
+                     char policyid[16];
+                     snprintf(policyid, sizeof(policyid), "%u", count++);
+                     menu_entries_append(info->list,
+                           policyid,
+                           policyid,
+                           MENU_ENUM_LABEL_GPU_POLICY_ENTRY,
+                           0, 0, 0, NULL);
+                     drivers++;
+                  }
+                  break;
+               case GPUSCALING_MANAGED_PER_CONTEXT:
+                  /* Allows user to pick two governors */
+                  menu_entries_append(info->list,
+                        msg_hash_to_str(MENU_ENUM_LABEL_VALUE_GPU_POLICY_CORE_GOVERNOR),
+                        "0",
+                        MENU_ENUM_LABEL_GPU_POLICY_CORE_GOVERNOR,
+                        0, 0, 0, NULL);
+
+                  menu_entries_append(info->list,
+                        msg_hash_to_str(MENU_ENUM_LABEL_VALUE_GPU_POLICY_MENU_GOVERNOR),
+                        "1",
+                        MENU_ENUM_LABEL_GPU_POLICY_MENU_GOVERNOR,
+                        0, 0, 0, NULL);
+
+                  /* fallthrough */
+               case CPUSCALING_MANAGED_PERFORMANCE:
+                  /* Allow users to choose max/min frequencies */
+                  menu_entries_append(info->list,
+                        "0",
+                        "0",
+                        MENU_ENUM_LABEL_GPU_MANAGED_MIN_FREQ,
+                        MENU_SETTINGS_GPU_MANAGED_SET_MINFREQ,
+                        0, 0, NULL);
+
+                  menu_entries_append(info->list,
+                        "1",
+                        "1",
+                        MENU_ENUM_LABEL_GPU_MANAGED_MAX_FREQ,
+                        MENU_SETTINGS_GPU_MANAGED_SET_MAXFREQ,
+                        0, 0, NULL);
+
+                  break;
+               case GPUSCALING_MAX_PERFORMANCE:
+               case GPUSCALING_MIN_POWER:
+               case GPUSCALING_BALANCED:
+                  /* No settings for these modes */
+                  break;
+            };
+         }
+
+         info->flags       |= MD_FLAG_NEED_REFRESH
+                            | MD_FLAG_NEED_PUSH
+                            | MD_FLAG_NEED_CLEAR;
+         break;
+      }
+#endif
 #if defined(HAVE_LIBNX)
       case DISPLAYLIST_SWITCH_CPU_PROFILE:
       {
diff --git a/menu/menu_displaylist.h b/menu/menu_displaylist.h
index 44b2f068af..a75d530ee0 100644
--- a/menu/menu_displaylist.h
+++ b/menu/menu_displaylist.h
@@ -282,6 +282,10 @@ enum menu_displaylist_ctl_state
 #if defined(HAVE_LAKKA)
    DISPLAYLIST_CPU_PERFPOWER_LIST,
    DISPLAYLIST_CPU_POLICY_LIST,
+#endif
+#ifdef HAVE_LAKKA_SWITCH
+   DISPLAYLIST_GPU_PERFPOWER_LIST,
+   DISPLAYLIST_GPU_POLICY_LIST,
 #endif
    DISPLAYLIST_PENDING_CLEAR,
    DISPLAYLIST_SHADER_PRESET_PREPEND,
diff --git a/menu/menu_driver.h b/menu/menu_driver.h
index ba5a80e3ee..e1f85a7a8b 100644
--- a/menu/menu_driver.h
+++ b/menu/menu_driver.h
@@ -251,7 +251,13 @@ enum menu_settings_type
    MENU_SETTINGS_CPU_POLICY_SET_GOVERNOR,
    MENU_SETTINGS_CPU_MANAGED_SET_MINFREQ,
    MENU_SETTINGS_CPU_MANAGED_SET_MAXFREQ,
-
+#ifdef HAVE_LAKKA_SWITCH
+   MENU_SETTINGS_GPU_POLICY_SET_MINFREQ,
+   MENU_SETTINGS_GPU_POLICY_SET_MAXFREQ,
+   MENU_SETTINGS_GPU_POLICY_SET_GOVERNOR,
+   MENU_SETTINGS_GPU_MANAGED_SET_MINFREQ,
+   MENU_SETTINGS_GPU_MANAGED_SET_MAXFREQ,
+#endif
    MENU_SET_CDROM_LIST,
    MENU_SET_LOAD_CDROM_LIST,
    MENU_SET_EJECT_DISC,
diff --git a/menu/menu_setting.c b/menu/menu_setting.c
index 5a444aef90..85858a3d43 100644
--- a/menu/menu_setting.c
+++ b/menu/menu_setting.c
@@ -18616,6 +18616,15 @@ static bool setting_append_list(
                &subgroup_info,
                parent_group);
 #endif
+#ifdef HAVE_LAKKA_SWITCH
+         CONFIG_ACTION(
+               list, list_info,
+               MENU_ENUM_LABEL_GPU_PERFPOWER,
+               MENU_ENUM_LABEL_VALUE_GPU_PERFPOWER,
+               &group_info,
+               &subgroup_info,
+               parent_group);
+#endif
 #ifndef HAVE_LAKKA
          if (frontend_driver_has_gamemode())
             CONFIG_BOOL(
diff --git a/misc/gpufreq/gpufreq.c b/misc/gpufreq/gpufreq.c
new file mode 100644
index 0000000000..df73ab30a5
--- /dev/null
+++ b/misc/gpufreq/gpufreq.c
@@ -0,0 +1,431 @@
+/*  RetroArch - A frontend for libretro.
+ *  Copyright (C) 2021 - David Guillen Fandos
+ *
+ *  RetroArch is free software: you can redistribute it and/or modify it under the terms
+ *  of the GNU General Public License as published by the Free Software Found-
+ *  ation, either version 3 of the License, or (at your option) any later version.
+ *
+ *  RetroArch is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+ *  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+ *  PURPOSE.  See the GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along with RetroArch.
+ *  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <stdio.h>
+#include <time.h>
+#include <string.h>
+#include <file/file_path.h>
+#include <lists/string_list.h>
+#include <lists/dir_list.h>
+#include <streams/file_stream.h>
+#include <string/stdstring.h>
+#include <retro_miscellaneous.h>
+
+#include "gpufreq.h"
+#include "../../configuration.h"
+
+#define REFRESH_TIMEOUT  2
+#ifdef HAVE_LAKKA_SWITCH
+#define GPU_POLICIES_DIR "/sys/devices/gpu.0/devfreq/57000000.gpu/"
+/*
+else
+ * #define GPU_POLICIES_DIR "Proper/path/for/board/" // WIP  
+*/
+#endif
+/*
+ * Available Switch gpu governors.
+ * wmark_active nvhost_podgov(Default) userspace simple_ondemand
+ */
+
+static time_t last_update = 0;
+static gpu_scaling_driver_t **scaling_drivers = NULL;
+/* Mode state and its options */
+static enum gpu_scaling_mode cur_smode = GPUSCALING_MANAGED_PERFORMANCE;
+#ifdef HAVE_LAKKA_SWITCH
+static gpu_scaling_opts_t cur_smode_opts = { 1, ~0U, "nvgpu_podgov", "simple_ondemand" };
+/*
+
+#else
+ * static gpu_scaling_opts_t cur_smode_opts = { 1, ~0U, "nvgpu_podgov", "simple_ondemand" };
+ * //needs to be set properly for each GPU that we decide to add support for. */
+#endif
+
+/* Precalculate and store the absolute max and min frequencies */
+static uint32_t abs_min_freq = 1, abs_max_freq = ~0U;
+
+static bool readparse_uint32(const char *path, uint32_t *value)
+{
+   char *tmpbuf;
+   if (!filestream_read_file(path, (void**)&tmpbuf, NULL))
+      return false;
+   string_remove_all_chars(tmpbuf, '\n');
+   if (sscanf(tmpbuf, "%" PRIu32, value) != 1)
+   {
+      free(tmpbuf);
+      return false;
+   }
+   free(tmpbuf);
+   return true;
+}
+
+static struct string_list* readparse_list(const char *path)
+{
+   char *tmpbuf;
+   struct string_list* ret;
+   if (!filestream_read_file(path, (void**)&tmpbuf, NULL))
+      return NULL;
+   string_remove_all_chars(tmpbuf, '\n');
+   ret = string_split(tmpbuf, " ");
+   free(tmpbuf);
+   return ret;
+}
+
+static void free_drivers(gpu_scaling_driver_t **d)
+{
+   if (d)
+   {
+      gpu_scaling_driver_t **it = d;
+      while (*it)
+      {
+         gpu_scaling_driver_t *drv = *it++;
+         if (drv->scaling_governor)
+            free(drv->scaling_governor);
+         if (drv->available_freqs)
+            free(drv->available_freqs);
+         string_list_free(drv->available_governors);
+
+         free(drv);
+      }
+      free(d);
+   }
+}
+
+gpu_scaling_driver_t **get_gpu_scaling_drivers(bool can_update)
+{
+   if (can_update && (time(NULL) > last_update + REFRESH_TIMEOUT ||
+       !scaling_drivers))
+   {
+      /* Parse /sys/devices/system/cpu/cpufreq/ policies */
+      int i, j, pc;
+      struct string_list *policy_dir = dir_list_new(GPU_POLICIES_DIR, NULL,
+        true, false, false, false);
+      if (!policy_dir)
+         return NULL;
+      dir_list_sort(policy_dir, false);
+
+      /* Delete the previous list of drivers */
+      free_drivers(scaling_drivers);
+
+      scaling_drivers = (gpu_scaling_driver_t**)calloc(
+         (policy_dir->size + 1), sizeof(gpu_scaling_driver_t*));
+      for (i = 0, pc = 0; i < policy_dir->size; i++)
+      {
+         uint32_t polid;
+         gpu_scaling_driver_t *drv;
+         struct string_list *tmplst;
+         char fpath[PATH_MAX_LENGTH];
+         const char *fname = strrchr(policy_dir->elems[i].data, '/');
+
+         if (!fname)
+            continue;
+
+         drv = calloc(1, sizeof(gpu_scaling_driver_t));
+         drv->policy_id = polid;
+
+         /* Read all nodes with freq info */
+         fill_pathname_join(fpath, policy_dir->elems[i].data,
+            "cur_freq", sizeof(fpath));
+         readparse_uint32(fpath, &drv->current_frequency);
+
+         fill_pathname_join(fpath, policy_dir->elems[i].data,
+            "scaling_max_freq", sizeof(fpath));
+         readparse_uint32(fpath, &drv->max_policy_freq);
+
+         fill_pathname_join(fpath, policy_dir->elems[i].data,
+            "scaling_available_governors", sizeof(fpath));
+         drv->available_governors = readparse_list(fpath);
+
+         fill_pathname_join(fpath, policy_dir->elems[i].data,
+            "scaling_governor", sizeof(fpath));
+         filestream_read_file(fpath, (void**)&drv->scaling_governor, NULL);
+         string_remove_all_chars(drv->scaling_governor, '\n');
+
+         /* This is not available in many platforms! */
+         fill_pathname_join(fpath, policy_dir->elems[i].data,
+            "scaling_available_frequencies", sizeof(fpath));
+         tmplst = readparse_list(fpath);
+         if (tmplst)
+         {
+            drv->available_freqs = calloc(tmplst->size, sizeof(uint32_t));
+            for (j = 0; j < tmplst->size; j++)
+            {
+               uint32_t freq = (uint32_t)atol(tmplst->elems[j].data);
+               drv->available_freqs[j] = freq;
+               if (abs_min_freq > freq || abs_min_freq == 1)
+                  abs_min_freq = freq;
+               if (abs_max_freq < freq || abs_max_freq == ~0U)
+                  abs_max_freq = freq;
+            }
+            string_list_free(tmplst);
+         }
+
+         /* Move to the list */
+         scaling_drivers[pc++] = drv;
+      }
+      dir_list_free(policy_dir);
+      last_update = time(NULL);
+   }
+   return scaling_drivers;
+}
+
+bool set_gpu_scaling_min_frequency(
+   gpu_scaling_driver_t *driver,
+   uint32_t min_freq)
+{
+   char fpath[PATH_MAX_LENGTH];
+   char value[16];
+   snprintf(fpath, sizeof(fpath), GPU_POLICIES_DIR "min_freq",
+      driver->policy_id);
+   snprintf(value, sizeof(value), "%" PRIu32 "\n", min_freq);
+   if (filestream_write_file(fpath, value, strlen(value)))
+   {
+      driver->min_policy_freq = min_freq;
+      last_update = 0;   /* Force reload */
+      return true;
+   }
+   return false;
+}
+
+bool set_gpu_scaling_max_frequency(
+   gpu_scaling_driver_t *driver,
+   uint32_t max_freq)
+{
+   char fpath[PATH_MAX_LENGTH];
+   char value[16];
+   snprintf(fpath, sizeof(fpath), GPU_POLICIES_DIR "max_freq",
+      driver->policy_id);
+   snprintf(value, sizeof(value), "%" PRIu32 "\n", max_freq);
+   if (filestream_write_file(fpath, value, strlen(value)))
+   {
+      driver->max_policy_freq = max_freq;
+      last_update = 0;   /* Force reload */
+      return true;
+   }
+   return false;
+}
+
+uint32_t get_gpu_scaling_next_frequency(
+   gpu_scaling_driver_t *driver,
+   uint32_t freq,
+   int step)
+{
+   /* If the driver does not have a list of available frequencies */
+   if (driver->available_freqs)
+   {
+      uint32_t *fr = driver->available_freqs;
+      while (*fr)
+      {
+         if (fr[0] <= freq && fr[1] > freq && step > 0)
+         {
+            freq = fr[1];
+            break;
+         }
+         else if (fr[0] < freq && fr[1] >= freq && step < 0)
+         {
+            freq = fr[0];
+            break;
+         }
+         fr++;
+      }
+      if (!(*fr))
+      {
+         if (step > 0)
+            freq = driver->max_gpu_freq;
+         else
+            freq = driver->min_gpu_freq;
+      }
+   }
+   else {
+      /* Just do small steps towards the max/min, arbitrary 100MHz */
+      freq = freq + step * 100000;
+   }
+
+   freq = MIN(freq, driver->max_gpu_freq);
+   freq = MAX(freq, driver->min_gpu_freq);
+
+   return freq;
+}
+
+uint32_t get_gpu_scaling_next_frequency_limit(uint32_t freq, int step)
+{
+   /* Tune step, if it's smaller than 100MHz */
+   unsigned fstep = 100000;
+   if ((abs_max_freq - abs_min_freq) / 20 < fstep)
+      fstep = 50000;
+
+   if (freq <= abs_min_freq && step < 0)
+      return 1;   /* Means "minimum frequency" */
+
+   if (freq >= abs_max_freq && step > 0)
+      return ~0U;   /* Means "maximum frequency" */
+
+   /* Just do small steps towards the max/min */
+   freq = freq + step * fstep;
+
+   freq = MIN(freq, abs_max_freq);
+   freq = MAX(freq, abs_min_freq);
+
+   return freq;
+}
+
+bool set_gpu_scaling_governor(gpu_scaling_driver_t *driver, const char* governor)
+{
+   char fpath[PATH_MAX_LENGTH];
+   snprintf(fpath, sizeof(fpath), GPU_POLICIES_DIR "scaling_governor",
+      driver->policy_id);
+   if (filestream_write_file(fpath, governor, strlen(governor)))
+   {
+      if (driver->scaling_governor)
+         free(driver->scaling_governor);
+      driver->scaling_governor = strdup(governor);
+      last_update = 0;   /* Force reload */
+      return true;
+   }
+   return false;
+}
+
+static void steer_all_drivers(
+   const char *governor,
+   uint32_t minfreq,
+   uint32_t maxfreq)
+{
+   gpu_scaling_driver_t **drivers = get_gpu_scaling_drivers(false);
+   if (!drivers)
+      return;
+   while (*drivers)
+   {
+      gpu_scaling_driver_t *d = *drivers++;
+      if (minfreq)
+         set_gpu_scaling_min_frequency(d, MAX(minfreq, d->min_gpu_freq));
+      if (maxfreq)
+         set_gpu_scaling_max_frequency(d, MIN(maxfreq, d->max_gpu_freq));
+      set_gpu_scaling_governor(d, governor);
+   }
+}
+
+void set_gpu_scaling_signal(enum gpu_scaling_event event)
+{
+   switch (cur_smode) {
+   case GPUSCALING_MANAGED_PERFORMANCE:
+      /* Bump to perf or fall back to ondemand depending on the RA state */
+      if (event == GPUSCALING_EVENT_FOCUS_CORE)
+         steer_all_drivers("nvhost_podgov", cur_smode_opts.min_freq,
+            cur_smode_opts.max_freq);
+      else
+         steer_all_drivers("nvhost_podgov", 1, ~0U);
+      break;
+   case GPUSCALING_MANAGED_PER_CONTEXT:
+      /* Apply the right settings the user specified */
+      if (event == GPUSCALING_EVENT_FOCUS_CORE)
+         steer_all_drivers(cur_smode_opts.main_policy, cur_smode_opts.min_freq,
+            cur_smode_opts.max_freq);
+      else
+         steer_all_drivers(cur_smode_opts.menu_policy, 1, ~0U);
+      break;
+   default:
+      break;
+   };
+}
+
+enum gpu_scaling_mode get_gpu_scaling_mode(gpu_scaling_opts_t *opts)
+{
+   if (opts)
+      *opts = cur_smode_opts;
+   return cur_smode;
+}
+
+void set_gpu_scaling_mode(
+   enum gpu_scaling_mode mode,
+   const gpu_scaling_opts_t *opts)
+{
+   settings_t *settings = config_get_ptr();
+
+   /* Store current state */
+   cur_smode = mode;
+   if (opts)
+      cur_smode_opts = *opts;
+
+   switch (mode)
+   {
+   case GPUSCALING_MANUAL:
+      /* Do nothing, the UI allows for tweaking directly */
+      break;
+   case GPUSCALING_MANAGED_PERFORMANCE:
+   case GPUSCALING_MANAGED_PER_CONTEXT:
+      /* Simulate a state change to enforce the policy */
+      set_gpu_scaling_signal(GPUSCALING_EVENT_FOCUS_MENU);
+      break;
+   case GPUSCALING_MAX_PERFORMANCE:
+      // Set performance and bump frequencies to min/max
+      steer_all_drivers("performance", 1, ~0U);
+      break;
+   case GPUSCALING_MIN_POWER:
+      // Set powersave and bump frequencies to min/max
+      //steer_all_drivers("powersave", 1, ~0U);
+      break;
+   case GPUSCALING_BALANCED:
+      // Set ondemand and bump frequencies to min/max
+      //steer_all_drivers("ondemand", 1, ~0U);
+      break;
+   };
+
+   if (settings)
+   {
+      /* Store current settings */
+      settings->uints.gpu_scaling_mode = (int)cur_smode;
+      settings->uints.gpu_min_freq = cur_smode_opts.min_freq;
+      settings->uints.gpu_max_freq = cur_smode_opts.max_freq;
+
+      strlcpy(settings->arrays.gpu_main_gov, cur_smode_opts.main_policy,
+         sizeof(settings->arrays.gpu_main_gov));
+      strlcpy(settings->arrays.gpu_menu_gov, cur_smode_opts.menu_policy,
+         sizeof(settings->arrays.gpu_menu_gov));
+   }
+};
+
+void gpu_scaling_driver_free()
+{
+   if (scaling_drivers)
+      free_drivers(scaling_drivers);
+
+   scaling_drivers = NULL;
+   last_update = 0;
+}
+
+void gpu_scaling_driver_init(void)
+{
+   /* Read the default settings */
+   settings_t *settings = config_get_ptr();
+   unsigned mode = settings->uints.gpu_scaling_mode;
+   cur_smode_opts.min_freq = settings->uints.gpu_min_freq;
+   cur_smode_opts.max_freq = settings->uints.gpu_max_freq;
+
+   if (mode <= (int)GPUSCALING_MANUAL)
+      cur_smode = (enum gpu_scaling_mode)mode;
+
+   if (settings->arrays.gpu_main_gov[0])
+      strlcpy(cur_smode_opts.main_policy, settings->arrays.gpu_main_gov,
+         sizeof(cur_smode_opts.main_policy));
+   if (settings->arrays.gpu_menu_gov[0])
+      strlcpy(cur_smode_opts.menu_policy, settings->arrays.gpu_menu_gov,
+         sizeof(cur_smode_opts.menu_policy));
+
+   /* Force update the policy tree */
+   get_gpu_scaling_drivers(true);
+
+   /* Force enforce these settings */
+   set_gpu_scaling_mode(cur_smode, NULL);
+}
+
diff --git a/misc/gpufreq/gpufreq.h b/misc/gpufreq/gpufreq.h
new file mode 100644
index 0000000000..201beed6f5
--- /dev/null
+++ b/misc/gpufreq/gpufreq.h
@@ -0,0 +1,108 @@
+/*  RetroArch - A frontend for libretro.
+ *  Copyright (C) 2021 - David Guillen Fandos
+ *
+ *  RetroArch is free software: you can redistribute it and/or modify it under the terms
+ *  of the GNU General Public License as published by the Free Software Found-
+ *  ation, either version 3 of the License, or (at your option) any later version.
+ *
+ *  RetroArch is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+ *  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+ *  PURPOSE.  See the GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along with RetroArch.
+ *  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef _MISC_GPUFREQ_H
+#define _MISC_GPUFREQ_H
+
+#include <stdint.h>
+
+RETRO_BEGIN_DECLS
+
+#define MAX_GOV_STRLEN   32
+
+/* Events from Frontend to the driver to drive policies */
+enum gpu_scaling_event
+{
+   GPUSCALING_EVENT_FOCUS_CORE,
+   GPUSCALING_EVENT_FOCUS_MENU,
+   GPUSCALING_EVENT_FOCUS_SCREENSAVER
+};
+
+/* Scaling mode selected by the user */
+enum gpu_scaling_mode
+{
+   GPUSCALING_MANAGED_PERFORMANCE = 0, /* Performance while running core     */
+   GPUSCALING_MANAGED_PER_CONTEXT,     /* Policies for core, menu, etc.      */
+   GPUSCALING_MAX_PERFORMANCE,         /* Performance (Max Freq)             */
+   GPUSCALING_MIN_POWER,               /* Use Powersave governor             */
+   GPUSCALING_BALANCED,                /* Uses schedutil/ondemand            */
+   GPUSCALING_MANUAL                   /* Can manually tweak stuff           */
+};
+
+typedef struct gpu_scaling_opts
+{
+   /* Max/Min frequencies */
+   uint32_t min_freq, max_freq;
+   /* Options for GPUSCALING_POLICY_PER_CONTEXT */
+   char main_policy[MAX_GOV_STRLEN];
+   char menu_policy[MAX_GOV_STRLEN];
+} gpu_scaling_opts_t;
+
+typedef struct gpu_scaling_driver
+{
+   /* Policy number in the sysfs tree */
+   unsigned int policy_id;
+   /* Which GPUs this scaling driver will affect */
+   char *affected_gpus;
+   /* Governor and available governors */
+   char *scaling_governor;
+   struct string_list *available_governors;
+   /* Current frequency (value might be slightly old) */
+   uint32_t current_frequency;
+   /* Max and min frequencies, for the hardware and policy */
+   uint32_t min_gpu_freq, max_gpu_freq;
+   uint32_t min_policy_freq, max_policy_freq;
+   /* Available frequencies table (can be NULL), ends with zero */
+   uint32_t *available_freqs;
+} gpu_scaling_driver_t;
+
+/* Safely free all memory used by the driver */
+void gpu_scaling_driver_free(void);
+
+/* Signal the initialization */
+void gpu_scaling_driver_init(void);
+
+/* Get a list of the available cpu scaling drivers */
+gpu_scaling_driver_t **get_gpu_scaling_drivers(bool can_update);
+
+/* Set max and min policy cpu frequency */
+bool set_gpu_scaling_min_frequency(
+   gpu_scaling_driver_t *driver, uint32_t min_freq);
+bool set_gpu_scaling_max_frequency(
+   gpu_scaling_driver_t *driver, uint32_t max_freq);
+
+/* Calculate next/previous frequencies */
+uint32_t get_gpu_scaling_next_frequency(gpu_scaling_driver_t *driver,
+   uint32_t freq, int step);
+uint32_t get_gpu_scaling_next_frequency_limit(uint32_t freq, int step);
+
+/* Set the scaling governor for this scaling driver */
+bool set_gpu_scaling_governor(gpu_scaling_driver_t *driver,
+      const char* governor);
+
+/* Signal certain events that are of interest of this driver */
+void set_gpu_scaling_signal(enum gpu_scaling_event);
+
+/* Set the base cpufreq policy mode */
+void set_gpu_scaling_mode(enum gpu_scaling_mode mode,
+                          const gpu_scaling_opts_t *opts);
+
+/* Get the base cpufreq policy mode */
+enum gpu_scaling_mode get_gpu_scaling_mode(gpu_scaling_opts_t *opts);
+
+RETRO_END_DECLS
+
+#endif
+
diff --git a/msg_hash.h b/msg_hash.h
index 990a0564fa..e351c893b1 100644
--- a/msg_hash.h
+++ b/msg_hash.h
@@ -1899,6 +1899,10 @@ enum msg_hash_enums
    MENU_ENUM_LABEL_DEFERRED_POWER_MANAGEMENT_SETTINGS_LIST,
    MENU_ENUM_LABEL_DEFERRED_CPU_PERFPOWER_LIST,
    MENU_ENUM_LABEL_DEFERRED_CPU_POLICY_ENTRY,
+#ifdef HAVE_LAKKA_SWITCH
+   MENU_ENUM_LABEL_DEFERRED_GPU_PERFPOWER_LIST,
+   MENU_ENUM_LABEL_DEFERRED_GPU_POLICY_ENTRY,
+#endif
    MENU_ENUM_LABEL_DEFERRED_MENU_SOUNDS_LIST,
    MENU_ENUM_LABEL_DEFERRED_MENU_FILE_BROWSER_SETTINGS_LIST,
    MENU_ENUM_LABEL_DEFERRED_RETRO_ACHIEVEMENTS_SETTINGS_LIST,
@@ -3697,6 +3701,18 @@ enum msg_hash_enums
    MENU_LABEL(CPU_POLICY_MENU_GOVERNOR),
    MENU_LABEL(CPU_MANAGED_MIN_FREQ),
    MENU_LABEL(CPU_MANAGED_MAX_FREQ),
+#ifdef HAVE_LAKKA_SWITCH
+   MENU_LABEL(GPU_PERF_MODE),
+   MENU_LABEL(GPU_PERFPOWER),
+   MENU_LABEL(GPU_POLICY_ENTRY),
+   MENU_LABEL(GPU_POLICY_MIN_FREQ),
+   MENU_LABEL(GPU_POLICY_MAX_FREQ),
+   MENU_LABEL(GPU_POLICY_GOVERNOR),
+   MENU_LABEL(GPU_POLICY_CORE_GOVERNOR),
+   MENU_LABEL(GPU_POLICY_MENU_GOVERNOR),
+   MENU_LABEL(GPU_MANAGED_MIN_FREQ),
+   MENU_LABEL(GPU_MANAGED_MAX_FREQ),
+#endif   
    MENU_LBL_H(GAMEMODE_ENABLE),
    MENU_ENUM_SUBLABEL_GAMEMODE_ENABLE_LINUX,
 
@@ -3713,7 +3729,21 @@ enum msg_hash_enums
    MENU_ENUM_SUBLABEL_VALUE_CPU_PERF_MODE_MIN_POWER,
    MENU_ENUM_SUBLABEL_VALUE_CPU_PERF_MODE_BALANCED,
    MENU_ENUM_SUBLABEL_VALUE_CPU_PERF_MODE_MANUAL,
-
+#ifdef HAVE_LAKKA_SWITCH
+   MENU_ENUM_LABEL_VALUE_GPU_PERF_MODE_MANAGED_PERF,
+   MENU_ENUM_LABEL_VALUE_GPU_PERF_MODE_MANAGED_PER_CONTEXT,
+   MENU_ENUM_LABEL_VALUE_GPU_PERF_MODE_MAX_PERF,
+   MENU_ENUM_LABEL_VALUE_GPU_PERF_MODE_MIN_POWER,
+   MENU_ENUM_LABEL_VALUE_GPU_PERF_MODE_BALANCED,
+   MENU_ENUM_LABEL_VALUE_GPU_PERF_MODE_MANUAL,
+
+   MENU_ENUM_SUBLABEL_VALUE_GPU_PERF_MODE_MANAGED_PERF,
+   MENU_ENUM_SUBLABEL_VALUE_GPU_PERF_MODE_MANAGED_PER_CONTEXT,
+   MENU_ENUM_SUBLABEL_VALUE_GPU_PERF_MODE_MAX_PERF,
+   MENU_ENUM_SUBLABEL_VALUE_GPU_PERF_MODE_MIN_POWER,
+   MENU_ENUM_SUBLABEL_VALUE_GPU_PERF_MODE_BALANCED,
+   MENU_ENUM_SUBLABEL_VALUE_GPU_PERF_MODE_MANUAL,
+#endif
    MENU_ENUM_LABEL_CHEAT_HANDLER_TYPE_EMU,
    MENU_ENUM_LABEL_CHEAT_HANDLER_TYPE_RETRO,
    MENU_ENUM_LABEL_CHEAT_TYPE_DISABLED,
-- 
2.25.1

