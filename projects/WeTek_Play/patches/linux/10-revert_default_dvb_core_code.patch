diff -Naur a/drivers/media/dvb-core/demux.h b/drivers/media/dvb-core/demux.h
--- a/drivers/media/dvb-core/demux.h	2015-01-04 18:07:59.000000000 +0100
+++ b/drivers/media/dvb-core/demux.h	2014-12-20 18:25:15.000000000 +0100
@@ -83,46 +83,6 @@
 #define TS_DEMUX        8   /* in case TS_PACKET is set, send the TS to
 			       the demux device, not to the dvr device */
 
-/* PES type for filters which write to built-in decoder */
-/* these should be kept identical to the types in dmx.h */
-
-typedef enum
-{  /* also send packets to decoder (if it exists) */
-	DMX_TS_PES_AUDIO0,
-	DMX_TS_PES_VIDEO0,
-	DMX_TS_PES_TELETEXT0,
-	DMX_TS_PES_SUBTITLE0,
-	DMX_TS_PES_PCR0,
-
-	DMX_TS_PES_AUDIO1,
-	DMX_TS_PES_VIDEO1,
-	DMX_TS_PES_TELETEXT1,
-	DMX_TS_PES_SUBTITLE1,
-	DMX_TS_PES_PCR1,
-
-	DMX_TS_PES_AUDIO2,
-	DMX_TS_PES_VIDEO2,
-	DMX_TS_PES_TELETEXT2,
-	DMX_TS_PES_SUBTITLE2,
-	DMX_TS_PES_PCR2,
-
-	DMX_TS_PES_AUDIO3,
-	DMX_TS_PES_VIDEO3,
-	DMX_TS_PES_TELETEXT3,
-	DMX_TS_PES_SUBTITLE3,
-	DMX_TS_PES_PCR3,
-
-	DMX_TS_PES_OTHER
-}dmx_ts_pes_t;
-
-
-#define DMX_TS_PES_AUDIO    DMX_TS_PES_AUDIO0
-#define DMX_TS_PES_VIDEO    DMX_TS_PES_VIDEO0
-#define DMX_TS_PES_TELETEXT DMX_TS_PES_TELETEXT0
-#define DMX_TS_PES_SUBTITLE DMX_TS_PES_SUBTITLE0
-#define DMX_TS_PES_PCR      DMX_TS_PES_PCR0
-
-
 struct dmx_ts_feed {
 	int is_filtering; /* Set to non-zero when filtering in progress */
 	struct dmx_demux *parent; /* Back-pointer */
diff -Naur a/drivers/media/dvb-core/dmxdev.c b/drivers/media/dvb-core/dmxdev.c
--- a/drivers/media/dvb-core/dmxdev.c	2015-01-04 18:07:59.000000000 +0100
+++ b/drivers/media/dvb-core/dmxdev.c	2015-02-12 18:25:19.000000000 +0100
@@ -1160,7 +1160,7 @@
 
 	switch (cmd) {
 	case DMX_SET_BUFFER_SIZE:
-		ret = dvb_dvr_set_buffer_size(dmxdev, arg);
+		ret = dvb_dvr_set_buffer_size(dmxdev, arg);	
 		break;
 
 	default:
diff -Naur a/drivers/media/dvb-core/dvbdev.c b/drivers/media/dvb-core/dvbdev.c
--- a/drivers/media/dvb-core/dvbdev.c	2015-01-04 18:07:59.000000000 +0100
+++ b/drivers/media/dvb-core/dvbdev.c	2014-12-20 18:25:15.000000000 +0100
@@ -47,7 +47,7 @@
 
 static const char * const dnames[] = {
 	"video", "audio", "sec", "frontend", "demux", "dvr", "ca",
-	"net", "osd", "dsc"
+	"net", "osd"
 };
 
 #ifdef CONFIG_DVB_DYNAMIC_MINORS
diff -Naur a/drivers/media/dvb-core/dvbdev.h b/drivers/media/dvb-core/dvbdev.h
--- a/drivers/media/dvb-core/dvbdev.h	2015-01-04 18:07:59.000000000 +0100
+++ b/drivers/media/dvb-core/dvbdev.h	2014-12-20 18:25:15.000000000 +0100
@@ -47,7 +47,6 @@
 #define DVB_DEVICE_CA         6
 #define DVB_DEVICE_NET        7
 #define DVB_DEVICE_OSD        8
-#define DVB_DEVICE_DSC        9
 
 #define DVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr) \
 	static short adapter_nr[] = \
diff -Naur a/drivers/media/dvb-core/dvb_frontend.c b/drivers/media/dvb-core/dvb_frontend.c
--- a/drivers/media/dvb-core/dvb_frontend.c	2015-01-04 18:07:59.000000000 +0100
+++ b/drivers/media/dvb-core/dvb_frontend.c	2014-12-20 18:25:15.000000000 +0100
@@ -52,10 +52,6 @@
 static int dvb_override_tune_delay;
 static int dvb_powerdown_on_sleep = 1;
 static int dvb_mfe_wait_time = 5;
-static int dvb_afc_debug=0;
-static int disable_set_frotend_param=0;
-static int dvb_dtv_debug=0;
-
 
 module_param_named(frontend_debug, dvb_frontend_debug, int, 0644);
 MODULE_PARM_DESC(frontend_debug, "Turn on/off frontend core debugging (default:off).");
@@ -69,18 +65,6 @@
 MODULE_PARM_DESC(dvb_powerdown_on_sleep, "0: do not power down, 1: turn LNB voltage off on sleep (default)");
 module_param(dvb_mfe_wait_time, int, 0644);
 MODULE_PARM_DESC(dvb_mfe_wait_time, "Wait up to <mfe_wait_time> seconds on open() for multi-frontend to become available (default:5 seconds)");
-module_param(dvb_afc_debug, int, 0644);
-MODULE_PARM_DESC( dvb_afc_debug,"vb_afc_debug \n");
-module_param(disable_set_frotend_param, int, 0644);
-MODULE_PARM_DESC( disable_set_frotend_param,"disable_set_frotend_param \n");
-module_param(dvb_dtv_debug, int, 0644);
-MODULE_PARM_DESC( dvb_dtv_debug,"vb_afc_debug \n");
-
-
-#define dprintk if (dvb_frontend_debug) printk
-#define pr_afc  if(dvb_afc_debug)printk
-#define dtvprintk  if(dvb_dtv_debug)printk
-
 
 #define FESTATE_IDLE 1
 #define FESTATE_RETUNE 2
@@ -117,22 +101,14 @@
 #define DVB_FE_DEVICE_REMOVED	2
 
 static DEFINE_MUTEX(frontend_mutex);
-extern unsigned int jiffies_to_msecs(const unsigned long j);
-int jiffiestime;
-//#define LOCK_TIMEOUT 2000
-static int LOCK_TIMEOUT = 2000;
 
 struct dvb_frontend_private {
 
 	/* thread/frontend values */
 	struct dvb_device *dvbdev;
-	struct dvb_frontend_parameters parameters_in;
 	struct dvb_frontend_parameters parameters_out;
 	struct dvb_fe_events events;
 	struct semaphore sem;
-	struct dvbsx_blindscan_events blindscan_events;
-	struct semaphore blindscan_sem;
-	bool in_blindscan;
 	struct list_head list_head;
 	wait_queue_head_t wait_queue;
 	struct task_struct *thread;
@@ -146,12 +122,6 @@
 	int tone;
 	int voltage;
 
-	/*set_frontend ops async support*/
-	wait_queue_head_t setfrontendasync_wait_queue;
-	unsigned int setfrontendasync_wakeup;
-	unsigned int setfrontendasync_needwakeup;
-	unsigned int setfrontendasync_interruptwakeup;
-
 	/* swzigzag values */
 	unsigned int state;
 	unsigned int bending;
@@ -166,7 +136,6 @@
 	int quality;
 	unsigned int check_wrapped;
 	enum dvbfe_search algo_status;
-	int user_delay;
 };
 
 static void dvb_frontend_wakeup(struct dvb_frontend *fe);
@@ -191,7 +160,6 @@
 	DVBV3_QAM,
 	DVBV3_OFDM,
 	DVBV3_ATSC,
-	DVBV3_ANALOG
 };
 
 static enum dvbv3_emulation_type dvbv3_type(u32 delivery_system)
@@ -215,8 +183,6 @@
 	case SYS_ATSCMH:
 	case SYS_DVBC_ANNEX_B:
 		return DVBV3_ATSC;
-	case SYS_ANALOG:
-		return DVBV3_ANALOG;
 	case SYS_UNDEFINED:
 	case SYS_ISDBC:
 	case SYS_DVBH:
@@ -241,13 +207,8 @@
 
 	dev_dbg(fe->dvb->device, "%s:\n", __func__);
 
-	if(fe->dtv_property_cache.delivery_system == SYS_ANALOG){
-		if ((status & FE_HAS_LOCK) && has_get_frontend(fe))
-			dtv_get_frontend(fe, &fepriv->parameters_out);
-	}else{
-		if (/*(status & FE_HAS_LOCK) && */has_get_frontend(fe))
-			dtv_get_frontend(fe, &fepriv->parameters_out);
-	}
+	if ((status & FE_HAS_LOCK) && has_get_frontend(fe))
+		dtv_get_frontend(fe, &fepriv->parameters_out);
 
 	mutex_lock(&events->mtx);
 
@@ -260,6 +221,7 @@
 	e = &events->events[events->eventw];
 	e->status = status;
 	e->parameters = fepriv->parameters_out;
+
 	events->eventw = wp;
 
 	mutex_unlock(&events->mtx);
@@ -306,92 +268,6 @@
 	return 0;
 }
 
-static void dvbsx_blindscan_add_event(struct dvb_frontend *fe, struct dvbsx_blindscanevent *pbsevent)
-{
-	struct dvb_frontend_private *fepriv = fe->frontend_priv;
-	struct dvbsx_blindscan_events *events = &fepriv->blindscan_events;
-	struct dvbsx_blindscanevent *e;
-	int wp;
-
-	dprintk ("%s\n", __func__);
-
-	if (mutex_lock_interruptible (&events->mtx))
-		return;
-
-	wp = (events->eventw + 1) % MAX_BLINDSCAN_EVENT;
-
-	if (wp == events->eventr) {
-		events->overflow = 1;
-		events->eventr = (events->eventr + 1) % MAX_BLINDSCAN_EVENT;
-	}
-
-	e = &events->events[events->eventw];
-
-	memcpy (e, pbsevent, sizeof (struct dvbsx_blindscanevent));
-
-	events->eventw = wp;
-
-	mutex_unlock(&events->mtx);
-
-	wake_up_interruptible (&events->wait_queue);
-}
-
-static int dvbsx_blindscan_get_event(struct dvb_frontend *fe,
-				struct dvbsx_blindscanevent *event , int flags)
-{
-	struct dvb_frontend_private *fepriv = fe->frontend_priv;
-	struct dvbsx_blindscan_events *events = &fepriv->blindscan_events;
-
-	dprintk ("%s\n", __func__);
-
-	if (events->overflow) {
-		events->overflow = 0;
-		return -EOVERFLOW;
-	}
-
-	if (events->eventw == events->eventr) {
-		int ret;
-
-		if (flags & O_NONBLOCK)
-			return -EWOULDBLOCK;
-
-		up(&fepriv->blindscan_sem);
-
-		ret = wait_event_interruptible_timeout (events->wait_queue,
-												events->eventw != events->eventr, fe->ops.blindscan_ops.info.bspara.timeout * HZ);
-
-		if (down_interruptible (&fepriv->blindscan_sem))
-			return -ERESTARTSYS;
-
-		if (ret < 0)
-			return ret;
-	}
-
-	if (mutex_lock_interruptible (&events->mtx))
-		return -ERESTARTSYS;
-
-	memcpy (event, &events->events[events->eventr],
-		sizeof(struct dvbsx_blindscanevent));
-
-	events->eventr = (events->eventr + 1) % MAX_BLINDSCAN_EVENT;
-
-	mutex_unlock(&events->mtx);
-
-	return 0;
-}
-
-static int dvbsx_blindscan_event_callback(struct dvb_frontend *fe, struct dvbsx_blindscanevent *pbsevent)
-{
-	dprintk ("%s\n", __func__);
-
-	if((!fe) || (!pbsevent ))
-		return -1;
-
-	dvbsx_blindscan_add_event(fe, pbsevent);
-
-	return 0;
-}
-
 static void dvb_frontend_clear_events(struct dvb_frontend *fe)
 {
 	struct dvb_frontend_private *fepriv = fe->frontend_priv;
@@ -458,7 +334,6 @@
 	int autoinversion;
 	int ready = 0;
 	int fe_set_err = 0;
-	int time=0;
 	struct dvb_frontend_private *fepriv = fe->frontend_priv;
 	struct dtv_frontend_properties *c = &fe->dtv_property_cache, tmp;
 	int original_inversion = c->inversion;
@@ -537,13 +412,8 @@
 	if (autoinversion)
 		c->inversion = fepriv->inversion;
 	tmp = *c;
-	time=jiffies_to_msecs(jiffies)-jiffiestime;
-	dprintk("2---auto tune,time is %d\n",time);
-	if (fe->ops.set_frontend&&(time>=LOCK_TIMEOUT)){
+	if (fe->ops.set_frontend)
 		fe_set_err = fe->ops.set_frontend(fe);
-		jiffiestime=jiffies_to_msecs(jiffies);
-		}
-	fepriv->parameters_out = fepriv->parameters_in;
 	*c = tmp;
 	if (fe_set_err < 0) {
 		fepriv->state = FESTATE_ERROR;
@@ -557,35 +427,12 @@
 	return 0;
 }
 
-#if (defined CONFIG_AM_M6_DEMOD)
-extern u32 dvbc_get_status(void);
-extern unsigned long atsc_read_iqr_reg(void);
-
-#endif
-#if (defined CONFIG_AM_SI2176)
-int si2176_get_strength(void);
-#endif
-#if (defined CONFIG_AM_SI2177)
-int si2177_get_strength(void);
-#endif
-
-
 static void dvb_frontend_swzigzag(struct dvb_frontend *fe)
 {
-	fe_status_t s;
-	int retval;
-	int time;
+	fe_status_t s = 0;
+	int retval = 0;
 	struct dvb_frontend_private *fepriv = fe->frontend_priv;
 	struct dtv_frontend_properties *c = &fe->dtv_property_cache, tmp;
-#if ((defined CONFIG_AM_SI2176) || (defined CONFIG_AM_SI2177))&&(defined CONFIG_AM_M6_DEMOD)
-	int strength;
-#endif
-#if (defined CONFIG_AM_M6_DEMOD)
-	int newcount;
-    int count;
-	count=0;
-#endif
-	s=retval=time=0;
 
 	/* if we've got no parameters, just keep idling */
 	if (fepriv->state & FESTATE_IDLE) {
@@ -617,10 +464,7 @@
 	} else {
 		if (fe->ops.read_status)
 			fe->ops.read_status(fe, &s);
-			time=jiffies_to_msecs(jiffies)-jiffiestime;
-		dprintk("1---read status,time is %d, s is %d,fepriv->status is %d\n",time,s,fepriv->status);
-		if (((s != fepriv->status)&&(time>=LOCK_TIMEOUT))||((s != fepriv->status)&&(s == (FE_HAS_LOCK|FE_HAS_SIGNAL|FE_HAS_CARRIER|FE_HAS_VITERBI|FE_HAS_SYNC)))) {
-			printk("1----!!!!!!!!!!!!!!!!!!!event s=%d,fepriv->status is %d!!!!!!!!!!!!!!!!!\n",s,fepriv->status);
+		if (s != fepriv->status) {
 			dvb_frontend_add_event(fe, s);
 			fepriv->status = s;
 		}
@@ -638,142 +482,6 @@
 		}
 		return;
 	}
-//auto_mode qam   201306-rsj
-#if (defined CONFIG_AM_M6_DEMOD)
-//dvbc auto qam
-	if(c->modulation== QAM_AUTO){
-		while((dvbc_get_status()<=3)&&(count<=20)){
-			msleep(30);
-			if(count==20){
-				fe->ops.read_status(fe, &s);
-				printk("!!!!!!!!!!!!!!!!!!!event s=%d,fepriv->status is %d!!!!!!!!!!!!!!!!!\n",s,fepriv->status);
-				dvb_frontend_add_event(fe, s);
-				fepriv->status = s;
-			}
-			count++;
-		}
-		count=0;
-		while((dvbc_get_status()>3)&&(dvbc_get_status()!=5)&&(count<5)){
-			if(count==0)
-				c->modulation=QAM_64;
-			else if(count==1)
-				c->modulation=QAM_256;
-			else if(count==2)
-				c->modulation=QAM_128;
-			else if(count==3)
-				c->modulation=QAM_16;
-			else
-				c->modulation=QAM_32;
-
-			if (fe->ops.set_qam_mode){
-				fe->ops.set_qam_mode(fe);
-			}
-			for(newcount=0;newcount<6;newcount++){
-				if(dvbc_get_status()==5)
-					break;
-				msleep(50);
-			}
-			newcount=0;
-			count++;
-			if(dvbc_get_status()==5){
-				if (fe->ops.read_status){
-					fe->ops.read_status(fe, &s);
-				}
-				if(((s != fepriv->status)&&(s == (FE_HAS_LOCK|FE_HAS_SIGNAL|FE_HAS_CARRIER|FE_HAS_VITERBI|FE_HAS_SYNC)))){
-					printk("!!!!!!!!!!!!!!!!!!!event s=%d,fepriv->status is %d!!!!!!!!!!!!!!!!!\n",s,fepriv->status);
-					dvb_frontend_add_event(fe, s);
-					fepriv->status = s;
-					break;
-				}
-			}
-
-		}
-	}else if(c->modulation == QAM_AUTO){
-	//	fepriv->parameters_out = fepriv->parameters_in;
-		msleep(100);
-		#if (defined CONFIG_AM_SI2176)
-		strength=si2176_get_strength()-256;
-		if(strength<=(-85)){
-			s=32;
-			printk("5-strength is %d\n",strength);
-			if(s != fepriv->status){
-					printk("5----!!!!!!!!!!!!!!!!!!!event s=%d,fepriv->status is %d!!!!!!!!!!!!!!!!!\n",s,fepriv->status);
-					dvb_frontend_add_event(fe, s);
-					fepriv->status = s;
-					jiffiestime=jiffies_to_msecs(jiffies);
-				}
-			return;
-
-		}
-		#elif (defined CONFIG_AM_SI2177)
-		strength=si2177_get_strength()-256;
-		if(strength<=(-85)){
-			s=32;
-			printk("5-strength is %d\n",strength);
-			if(s != fepriv->status){
-					printk("5----!!!!!!!!!!!!!!!!!!!event s=%d,fepriv->status is %d!!!!!!!!!!!!!!!!!\n",s,fepriv->status);
-					dvb_frontend_add_event(fe, s);
-					fepriv->status = s;
-					jiffiestime=jiffies_to_msecs(jiffies);
-				}
-			return;
-
-		}
-		#endif
-		while(((atsc_read_iqr_reg()>>16)!=0x1f)&&(count<2)){
-			if(count==0){
-				if (fe->ops.set_frontend){
-			//	fe->ops.set_frontend(fe, &fepriv->parameters_in);
-				}
-			}
-	//			fepriv->parameters_in.u.vsb.modulation=QAM_256;
-			else if(count==1){
-				c->modulation=QAM_64;
-				if (fe->ops.set_qam_mode){
-					fe->ops.set_qam_mode(fe);
-				}
-			//	dprintk("fepriv->parameters_in.frequency is %d\n",fepriv->parameters_in.frequency);
-			}
-			for(newcount=0;newcount<10;newcount++){
-				if((atsc_read_iqr_reg()>>16)==0x1f)
-					break;
-				msleep(50);
-			}
-			newcount=0;
-			count++;
-		if((atsc_read_iqr_reg()>>16)==0x1f){
-				if (fe->ops.read_status){
-					fe->ops.read_status(fe, &s);
-				}
-				if(((s != fepriv->status)&&(s == (FE_HAS_LOCK|FE_HAS_SIGNAL|FE_HAS_CARRIER|FE_HAS_VITERBI|FE_HAS_SYNC)))){
-					printk("3----!!!!!!!!!!!!!!!!!!!event s=%d,fepriv->status is %d!!!!!!!!!!!!!!!!!\n",s,fepriv->status);
-					printk("fepriv->parameters_in.frequency is %d\n",fepriv->parameters_in.frequency);
-					dvb_frontend_add_event(fe, s);
-					fepriv->status = s;
-					jiffiestime=jiffies_to_msecs(jiffies);
-					return;
-				}
-			}
-			if(count==2&&((atsc_read_iqr_reg()>>16)!=0x1f)){
-				if (fe->ops.read_status){
-					fe->ops.read_status(fe, &s);
-				}
-				if(s != fepriv->status){
-					printk("2----!!!!!!!!!!!!!!!!!!!event s=%d,fepriv->status is %d!!!!!!!!!!!!!!!!!\n",s,fepriv->status);
-					printk("fepriv->parameters_in.frequency is %d\n",fepriv->parameters_in.frequency);
-					dvb_frontend_add_event(fe, s);
-					fepriv->status = s;
-					jiffiestime=jiffies_to_msecs(jiffies);
-					return;
-				}
-			}
-		}
-
-	}
-
-
-//
-#endif
 
 	/* if we are tuned already, check we're still locked */
 	if (fepriv->state & FESTATE_TUNED) {
@@ -818,10 +526,6 @@
 
 	/* fast zigzag. */
 	if ((fepriv->state & FESTATE_SEARCHING_FAST) || (fepriv->state & FESTATE_RETUNE)) {
-
-	  if(fepriv->state & FESTATE_SEARCHING_FAST)
-		fepriv->delay = fepriv->min_delay + HZ/5;/*if not lock signal ,then wait 25 jiffies*/
-	  else
 		fepriv->delay = fepriv->min_delay;
 
 		/* perform a tune */
@@ -895,11 +599,11 @@
 {
 	struct dvb_frontend *fe = data;
 	struct dvb_frontend_private *fepriv = fe->frontend_priv;
-	unsigned long timeout;
 	fe_status_t s;
 	enum dvbfe_algo algo;
 
-	struct dvb_frontend_parameters *params=NULL;
+	bool re_tune = false;
+	bool semheld = false;
 
 	dev_dbg(fe->dvb->device, "%s:\n", __func__);
 
@@ -916,13 +620,15 @@
 	while (1) {
 		up(&fepriv->sem);	    /* is locked when we enter the thread... */
 restart:
-		timeout = wait_event_interruptible_timeout(fepriv->wait_queue,
+		wait_event_interruptible_timeout(fepriv->wait_queue,
 			dvb_frontend_should_wakeup(fe) || kthread_should_stop()
 				|| freezing(current),
 			fepriv->delay);
 
 		if (kthread_should_stop() || dvb_frontend_is_exiting(fe)) {
 			/* got signal or quitting */
+			if (!down_interruptible(&fepriv->sem))
+				semheld = true;
 			fepriv->exit = DVB_FE_NORMAL_EXIT;
 			break;
 		}
@@ -950,15 +656,15 @@
 				dev_dbg(fe->dvb->device, "%s: Frontend ALGO = DVBFE_ALGO_HW\n", __func__);
 
 				if (fepriv->state & FESTATE_RETUNE) {
-					dprintk("%s: Retune requested, FESTATE_RETUNE\n", __func__);
-					params = &fepriv->parameters_in;
+					dev_dbg(fe->dvb->device, "%s: Retune requested, FESTATE_RETUNE\n", __func__);
+					re_tune = true;
 					fepriv->state = FESTATE_TUNED;
+				} else {
+					re_tune = false;
 				}
 
 				if (fe->ops.tune)
-					fe->ops.tune(fe, params, fepriv->tune_mode_flags, &fepriv->delay, &s);
-				if (params)
-					fepriv->parameters_out = *params;
+					fe->ops.tune(fe, re_tune, fepriv->tune_mode_flags, &fepriv->delay, &s);
 
 				if (s != fepriv->status && !(fepriv->tune_mode_flags & FE_TUNE_MODE_ONESHOT)) {
 					dev_dbg(fe->dvb->device, "%s: state changed, adding current state\n", __func__);
@@ -991,17 +697,12 @@
 					}
 				}
 				/* Track the carrier if the search was successful */
-				if (fepriv->algo_status == DVBFE_ALGO_SEARCH_SUCCESS) {
-					if (fe->ops.track)
-						fe->ops.track(fe, &fepriv->parameters_in);
-					s = FE_HAS_LOCK;
-				} else {
+				if (fepriv->algo_status != DVBFE_ALGO_SEARCH_SUCCESS) {
 					fepriv->algo_status |= DVBFE_ALGO_SEARCH_AGAIN;
 					fepriv->delay = HZ / 2;
-					s = FE_TIMEDOUT;
 				}
 				dtv_property_legacy_params_sync(fe, &fepriv->parameters_out);
-				//fe->ops.read_status(fe, &s);
+				fe->ops.read_status(fe, &s);
 				if (s != fepriv->status) {
 					dvb_frontend_add_event(fe, s); /* update event list */
 					fepriv->status = s;
@@ -1043,6 +744,8 @@
 		fepriv->exit = DVB_FE_NO_EXIT;
 	mb();
 
+	if (semheld)
+		up(&fepriv->sem);
 	dvb_frontend_wakeup(fe);
 	return 0;
 }
@@ -1273,125 +976,6 @@
 	return 0;
 }
 
-static int dvb_frontend_asyncshouldwakeup(struct dvb_frontend *fe)
-{
-	struct dvb_frontend_private *fepriv = fe->frontend_priv;
-
-	dprintk ("%s:%d\n", __func__, fepriv->setfrontendasync_wakeup);
-
-	if (fepriv->setfrontendasync_wakeup) {
-		fepriv->setfrontendasync_wakeup = 0;
-		return 1;
-	}
-
-	return 0;
-}
-
-static void dvb_frontend_asyncwakeup(struct dvb_frontend *fe)
-{
-	struct dvb_frontend_private *fepriv = fe->frontend_priv;
-
-	if(!fe){
-		return;
-	}
-
-	if(!fe->ops.asyncinfo.set_frontend_asyncenable){
-		return;
-	}
-
-
-	dprintk ("%s:%d\n", __func__, fepriv->setfrontendasync_needwakeup);
-
-	if(fepriv->setfrontendasync_needwakeup){
-		fepriv->setfrontendasync_wakeup = 1;
-		wake_up_interruptible(&fepriv->setfrontendasync_wait_queue);
-	}
-}
-
-static int dvb_frontend_asyncpreproc(struct dvb_frontend *fe)
-{
-	struct dvb_frontend_private *fepriv = fe->frontend_priv;
-
-	if(!fe){
-		return -1;
-	}
-
-	if(!fe->ops.asyncinfo.set_frontend_asyncenable){
-		return -1;
-	}
-
-	fepriv->setfrontendasync_needwakeup = 1;
-
-	dprintk ("%s:%d\n", __func__, fepriv->setfrontendasync_needwakeup);
-
-	/*enable other frontend ops run*/
-	up(&fepriv->sem);
-
-	return 0;
-}
-
-static int dvb_frontend_asyncwait(struct dvb_frontend *fe, u32 ms_timeout)
-{
-	int ret = 0;
-	unsigned long wait_ret = 0;
-	struct dvb_frontend_private *fepriv = fe->frontend_priv;
-
-	if(!fe){
-		return -1;
-	}
-
-	if(!fe->ops.asyncinfo.set_frontend_asyncenable){
-		return -1;
-	}
-
-	wait_ret= wait_event_interruptible_timeout(fepriv->setfrontendasync_wait_queue,
-											dvb_frontend_asyncshouldwakeup(fe),
-											ms_timeout * HZ /1000);
-
-	dprintk ("%s:%d/%ld\n", __func__, ms_timeout, wait_ret);
-
-	if(wait_ret > 0){
-		ret = 1;
-	}
-	else if(wait_ret == 0){
-		ret = 0;
-	}
-
-	return ret;
-}
-
-static int dvb_frontend_asyncpostproc(struct dvb_frontend *fe, int asyncwait_ret)
-{
-	struct dvb_frontend_private *fepriv = fe->frontend_priv;
-
-	if(!fe){
-		return -1;
-	}
-
-	if(!fe->ops.asyncinfo.set_frontend_asyncenable){
-		return -1;
-	}
-
-	if (down_interruptible (&fepriv->sem))
-		return -1;
-
-	fepriv->setfrontendasync_needwakeup = 0;
-
-	if(asyncwait_ret > 0){
-		fepriv->setfrontendasync_interruptwakeup = 1;
-	}
-	else if(asyncwait_ret == 0){
-		fepriv->setfrontendasync_interruptwakeup = 0;
-	}
-	else{
-		fepriv->setfrontendasync_interruptwakeup = 0;
-	}
-
-	dprintk ("%s:%d/%d\n", __func__, asyncwait_ret, fepriv->setfrontendasync_needwakeup);
-
-	return 0;
-}
-
 #define _DTV_CMD(n, s, b) \
 [n] = { \
 	.name = #n, \
@@ -1563,7 +1147,6 @@
 		c->transmission_mode = p->u.ofdm.transmission_mode;
 		c->guard_interval = p->u.ofdm.guard_interval;
 		c->hierarchy = p->u.ofdm.hierarchy_information;
-		c->ofdm_mode = p->u.ofdm.ofdm_mode;
 		break;
 	case DVBV3_ATSC:
 		dev_dbg(fe->dvb->device, "%s: Preparing ATSC req\n", __func__);
@@ -1575,14 +1158,6 @@
 		else
 			c->delivery_system = SYS_DVBC_ANNEX_B;
 		break;
-	case DVBV3_ANALOG:
-		c->analog.soundsys  = p->u.analog.soundsys;
-		c->analog.audmode   = p->u.analog.audmode;
-		c->analog.std       = p->u.analog.std;
-		c->analog.flag      = p->u.analog.flag;
-		c->analog.afc_range = p->u.analog.afc_range;
-		c->analog.reserved  = p->u.analog.reserved;
-		break;
 	case DVBV3_UNKNOWN:
 		dev_err(fe->dvb->device,
 				"%s: doesn't know how to handle a DVBv3 call to delivery system %i\n",
@@ -1603,7 +1178,7 @@
 
 	p->frequency = c->frequency;
 	p->inversion = c->inversion;
-	dtvprintk("[get frontend]p is %d\n",p->frequency);
+
 	switch (dvbv3_type(c->delivery_system)) {
 	case DVBV3_UNKNOWN:
 		dev_err(fe->dvb->device,
@@ -1652,21 +1227,11 @@
 		p->u.ofdm.transmission_mode = c->transmission_mode;
 		p->u.ofdm.guard_interval = c->guard_interval;
 		p->u.ofdm.hierarchy_information = c->hierarchy;
-		p->u.ofdm.ofdm_mode = c->ofdm_mode;
 		break;
 	case DVBV3_ATSC:
 		dev_dbg(fe->dvb->device, "%s: Preparing VSB req\n", __func__);
 		p->u.vsb.modulation = c->modulation;
 		break;
-	case DVBV3_ANALOG:
-		p->u.analog.soundsys = c->analog.soundsys;
-		p->u.analog.audmode  = c->analog.audmode;
-		p->u.analog.std      = c->analog.std;
-		p->u.analog.flag     = c->analog.flag;
-		p->u.analog.afc_range= c->analog.afc_range;
-		p->u.analog.reserved = c->analog.reserved;
-		break;
-
 	}
 	return 0;
 }
@@ -1939,8 +1504,7 @@
 	bool status;
 
 	status = (delsys == SYS_DVBT) || (delsys == SYS_DVBC_ANNEX_A) ||
-		 (delsys == SYS_DVBS) || (delsys == SYS_ATSC) || (delsys == SYS_DTMB) ||
-		 (delsys == SYS_ISDBT)|| (delsys == SYS_ANALOG) || (delsys == SYS_DVBS2);
+		 (delsys == SYS_DVBS) || (delsys == SYS_ATSC);
 
 	return status;
 }
@@ -2335,38 +1899,10 @@
 	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
 	struct dvb_frontend_private *fepriv = fe->frontend_priv;
 	int err = -EOPNOTSUPP;
-	int need_lock = 1;
-	int need_blindscan = 0;
 
 	dev_dbg(fe->dvb->device, "%s: (%d)\n", __func__, _IOC_NR(cmd));
-	if (fepriv->exit != DVB_FE_NO_EXIT)
-		return -ENODEV;
-
-	if ((file->f_flags & O_ACCMODE) == O_RDONLY &&
-	    (_IOC_DIR(cmd) != _IOC_READ || cmd == FE_GET_EVENT ||
-	     cmd == FE_DISEQC_RECV_SLAVE_REPLY))
-		return -EPERM;
-
-	if (cmd==FE_READ_STATUS ||
-			cmd==FE_READ_BER ||
-			cmd==FE_READ_SIGNAL_STRENGTH ||
-			cmd==FE_READ_SNR ||
-			cmd==FE_READ_UNCORRECTED_BLOCKS ||
-			cmd==FE_GET_FRONTEND ||
-			cmd==FE_READ_AFC ||
-			cmd==FE_SET_BLINDSCAN ||
-			cmd==FE_GET_BLINDSCANEVENT ||
-			cmd==FE_SET_BLINDSCANCANCEl)
-		need_lock = 0;
-
-	if (cmd==FE_SET_BLINDSCAN ||
-			cmd==FE_GET_BLINDSCANEVENT ||
-			cmd==FE_SET_BLINDSCANCANCEl)
-		need_blindscan = 1;
-
-	if (need_lock)
-		if (down_interruptible(&fepriv->sem))
-			return -ERESTARTSYS;
+	if (down_interruptible(&fepriv->sem))
+		return -ERESTARTSYS;
 
 	if (fepriv->exit != DVB_FE_NO_EXIT) {
 		up(&fepriv->sem);
@@ -2380,14 +1916,6 @@
 		return -EPERM;
 	}
 
-	if (need_blindscan)
-		if (down_interruptible (&fepriv->blindscan_sem))
-			return -ERESTARTSYS;
-
-	if(cmd==FE_SET_FRONTEND ||
-			cmd==FE_SET_MODE)
-		dvb_frontend_asyncwakeup(fe);
-
 	if ((cmd == FE_SET_PROPERTY) || (cmd == FE_GET_PROPERTY))
 		err = dvb_frontend_ioctl_properties(file, cmd, parg);
 	else {
@@ -2395,12 +1923,7 @@
 		err = dvb_frontend_ioctl_legacy(file, cmd, parg);
 	}
 
-	if (need_blindscan)
-		up(&fepriv->blindscan_sem);
-
-	if (need_lock)
-		up(&fepriv->sem);
-
+	up(&fepriv->sem);
 	return err;
 }
 
@@ -2510,7 +2033,6 @@
 	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
 	struct dvb_frontend_tune_settings fetunesettings;
 	u32 rolloff = 0;
-	printk("dtv_set_frontend\n");
 
 	if (dvb_frontend_check_parameters(fe) < 0)
 		return -EINVAL;
@@ -2585,16 +2107,16 @@
 		case SYS_DVBC_ANNEX_A:
 		case SYS_DVBC_ANNEX_C:
 			fepriv->min_delay = HZ / 20;
-			fepriv->step_size = 0;
-			fepriv->max_drift = 0;
+			fepriv->step_size = c->symbol_rate / 16000;
+			fepriv->max_drift = c->symbol_rate / 2000;
 			break;
 		case SYS_DVBT:
 		case SYS_DVBT2:
 		case SYS_ISDBT:
 		case SYS_DTMB:
 			fepriv->min_delay = HZ / 20;
-			fepriv->step_size = 0;//fe->ops.info.frequency_stepsize * 2;
-			fepriv->max_drift = 0;//(fe->ops.info.frequency_stepsize * 2) + 1;
+			fepriv->step_size = fe->ops.info.frequency_stepsize * 2;
+			fepriv->max_drift = (fe->ops.info.frequency_stepsize * 2) + 1;
 			break;
 		default:
 			/*
@@ -2614,16 +2136,10 @@
 
 	/* Request the search algorithm to search */
 	fepriv->algo_status |= DVBFE_ALGO_SEARCH_AGAIN;
-	if(c->delivery_system==SYS_ANALOG && (c->analog.flag & ANALOG_FLAG_ENABLE_AFC)){
-		dvb_frontend_add_event(fe, 0);
-		dvb_frontend_wakeup(fe);
-	}else if (fe->ops.set_frontend){
-		fe->ops.set_frontend(fe);
-		if(c->delivery_system!=SYS_ANALOG)
-			dvb_frontend_clear_events(fe);
-			dvb_frontend_add_event(fe, 0);
-			dvb_frontend_wakeup(fe);
-	}
+
+	dvb_frontend_clear_events(fe);
+	dvb_frontend_add_event(fe, 0);
+	dvb_frontend_wakeup(fe);
 	fepriv->status = 0;
 
 	return 0;
@@ -2853,21 +2369,16 @@
 			err = fe->ops.enable_high_lnb_voltage(fe, (long) parg);
 		break;
 
-	case FE_SET_FRONTEND: {
-		if(disable_set_frotend_param)
-		    break;
-		printk("FE_SET_FRONTEND\n");
+	case FE_SET_FRONTEND:
 		err = dvbv3_set_delivery_system(fe);
 		if (err)
 			break;
+
 		err = dtv_property_cache_sync(fe, c, parg);
 		if (err)
 			break;
-		jiffiestime=jiffies_to_msecs(jiffies);
 		err = dtv_set_frontend(fe);
 		break;
-	}
-
 	case FE_GET_EVENT:
 		err = dvb_frontend_get_event (fe, parg, file->f_flags);
 		break;
@@ -2880,146 +2391,6 @@
 		fepriv->tune_mode_flags = (unsigned long) parg;
 		err = 0;
 		break;
-
-	case FE_SET_DELAY:
-		fepriv->user_delay = (int)parg;
-		err = 0;
-		break;
-
-	case FE_SET_MODE:
-		if(fe->ops.set_mode){
-			err = fe->ops.set_mode(fe, (int)parg);
-		if(err == 0){
-			switch((int)parg){
-			case FE_QPSK:
-				c->delivery_system = SYS_DVBS2;//DVBV3_QPSK;
-				break;
-			case FE_QAM:
-				c->delivery_system = SYS_DVBC_ANNEX_A;//DVBV3_QAM;
-				break;
-			case FE_OFDM:
-				c->delivery_system = SYS_DVBT;//DVBV3_OFDM;
-				break;
-			case FE_ATSC:
-				c->delivery_system = SYS_ATSC;//DVBV3_ATSC;
-				break;
-			case FE_ANALOG:
-				c->delivery_system = SYS_ANALOG;//DVBV3_ANALOG;
-				break;
-			case FE_DTMB:
-				c->delivery_system = SYS_DTMB;//DVBV3_OFDM;
-				break;
-			case FE_ISDBT:
-				c->delivery_system = SYS_ISDBT;//DVBV3_OFDM;
-			break;
-				}
-			}
-		}
-		break;
-
-	case FE_READ_TS:
-		if(fe->ops.read_ts){
-			err = fe->ops.read_ts(fe, (int*)parg);
-		}
-		break;
-
-    case FE_FINE_TUNE:
-       if(fe->ops.tuner_ops.fine_tune){
-            err = fe->ops.tuner_ops.fine_tune(fe, *((int*)parg));
-       }
-       break;
-    case FE_READ_TUNER_STATUS:
-       if(fe->ops.tuner_ops.get_tuner_status){
-            tuner_status_t parm_status = {0};
-            tuner_status_t *tmsp = parg;
-            err = fe->ops.tuner_ops.get_tuner_status(fe, &parm_status);
-            memcpy(tmsp,&parm_status,sizeof(tuner_status_t));
-       }
-       break;
-    case FE_READ_ANALOG_STATUS:
-       if(fe->ops.analog_ops.get_atv_status){
-            atv_status_t atv_stats = {0};
-            atv_status_t *tmap = parg;
-            err = fe->ops.analog_ops.get_atv_status(fe, &atv_stats);
-            memcpy(tmap,&atv_stats,sizeof(atv_status_t));
-       }
-       break;
-    case FE_READ_SD_STATUS:
-       if(fe->ops.analog_ops.get_sd_status){
-        sound_status_t sound_sts = {0};
-            err = fe->ops.analog_ops.get_sd_status(fe, &sound_sts);
-            memcpy(parg,&sound_sts,sizeof(sound_status_t));
-       }
-       break;
-    case FE_SET_PARAM_BOX:
-        if(fe->ops.tuner_ops.set_config){
-            tuner_param_t tuner_parm = {0};
-            memcpy(&tuner_parm, parg, sizeof(tuner_param_t));
-            err = fe->ops.tuner_ops.set_config(fe, &tuner_parm);
-            memcpy(parg,&tuner_parm, sizeof(tuner_param_t));
-        }
-        break;
-
-	case  FE_SET_BLINDSCAN:
-		memcpy (&(fe->ops.blindscan_ops.info.bspara), parg, sizeof (struct dvbsx_blindscanpara));
-
-		dprintk("FE_SET_BLINDSCAN %d %d %d %d %d %d %d\n",
-				fe->ops.blindscan_ops.info.bspara.minfrequency,
-				fe->ops.blindscan_ops.info.bspara.maxfrequency,
-				fe->ops.blindscan_ops.info.bspara.minSymbolRate,
-				fe->ops.blindscan_ops.info.bspara.maxSymbolRate,
-				fe->ops.blindscan_ops.info.bspara.frequencyRange,
-				fe->ops.blindscan_ops.info.bspara.frequencyStep,
-				fe->ops.blindscan_ops.info.bspara.timeout);
-
-		/*register*/
-		fe->ops.blindscan_ops.info.blindscan_callback = dvbsx_blindscan_event_callback;
-
-		fepriv->in_blindscan = true;
-
-		if (fe->ops.blindscan_ops.blindscan_scan)
-			err = fe->ops.blindscan_ops.blindscan_scan(fe, &(fe->ops.blindscan_ops.info.bspara));
-		break;
-
-	case  FE_GET_BLINDSCANEVENT:
-		{
-			struct dvbsx_blindscanevent *p_tmp_bsevent = NULL;
-
-			err = dvbsx_blindscan_get_event (fe, (struct dvbsx_blindscanevent*) parg, file->f_flags);
-
-			p_tmp_bsevent = (struct dvbsx_blindscanevent*) parg;
-
-			dprintk("FE_GET_BLINDSCANEVENT status:%d\n", p_tmp_bsevent->status);
-
-			if(p_tmp_bsevent->status == BLINDSCAN_UPDATESTARTFREQ)
-			{
-				dprintk("start freq %d\n", p_tmp_bsevent->u.m_uistartfreq_khz);
-			}
-			else if(p_tmp_bsevent->status == BLINDSCAN_UPDATEPROCESS)
-			{
-				dprintk("process %d\n", p_tmp_bsevent->u.m_uiprogress);
-			}
-			else if(p_tmp_bsevent->status == BLINDSCAN_UPDATERESULTFREQ)
-			{
-				dprintk("result freq %d symb %d\n", p_tmp_bsevent->u.parameters.frequency, p_tmp_bsevent->u.parameters.u.qpsk.symbol_rate);
-			}
-			break;
-		}
-
-	case  FE_SET_BLINDSCANCANCEl:
-		dprintk("FE_SET_BLINDSCANCANCEl\n");
-
-
-		if (fe->ops.blindscan_ops.blindscan_cancel)
-			err = fe->ops.blindscan_ops.blindscan_cancel(fe);
-
-		fepriv->in_blindscan = false;
-
-		/*unregister*/
-		fe->ops.blindscan_ops.info.blindscan_callback = NULL;
-
-		break;
-
 	}
 
 	return err;
@@ -3121,7 +2492,6 @@
 
 		/*  empty event queue */
 		fepriv->events.eventr = fepriv->events.eventw = 0;
-		fepriv->blindscan_events.eventr = fepriv->blindscan_events.eventw = 0;
 	}
 
 	if (adapter->mfe_shared)
@@ -3213,25 +2583,6 @@
 }
 EXPORT_SYMBOL(dvb_frontend_resume);
 
-
-static ssize_t dvbc_lock_show(struct class *cls,struct class_attribute *attr,char *buf)
-{
-	return sprintf(buf, "dvbc_autoflags: %s\n", LOCK_TIMEOUT?"on":"off");
-}
-static ssize_t dvbc_lock_store(struct class *cls, struct class_attribute *attr, const char *buf, size_t count)
-{
-	int mode = simple_strtol(buf,0,16);
-	printk("autoflags is %d\n",mode);
-	LOCK_TIMEOUT= mode;
-	return count;
-
-}
-
-static CLASS_ATTR(lock_time,0644,dvbc_lock_show,dvbc_lock_store);
-
-struct class *tongfang_clsp = NULL;
-#define LOCK_DEVICE_NAME  "tongfang"
-
 int dvb_register_frontend(struct dvb_adapter* dvb,
 			  struct dvb_frontend* fe)
 {
@@ -3244,7 +2595,6 @@
 		.kernel_ioctl = dvb_frontend_ioctl
 	};
 
-	int ret;
 	dev_dbg(dvb->device, "%s:\n", __func__);
 
 	if (mutex_lock_interruptible(&frontend_mutex))
@@ -3258,24 +2608,12 @@
 	fepriv = fe->frontend_priv;
 
 	sema_init(&fepriv->sem, 1);
-	sema_init(&fepriv->blindscan_sem, 1);
 	init_waitqueue_head (&fepriv->wait_queue);
 	init_waitqueue_head (&fepriv->events.wait_queue);
-	init_waitqueue_head (&fepriv->blindscan_events.wait_queue);
 	mutex_init(&fepriv->events.mtx);
-	mutex_init(&fepriv->blindscan_events.mtx);
 	fe->dvb = dvb;
 	fepriv->inversion = INVERSION_OFF;
 
-	init_waitqueue_head (&fepriv->setfrontendasync_wait_queue);
-	fepriv->setfrontendasync_wakeup = 0;
-	fepriv->setfrontendasync_needwakeup = 0;
-	fepriv->setfrontendasync_interruptwakeup = 0;
-
-	fe->ops.asyncinfo.set_frontend_asyncpreproc = dvb_frontend_asyncpreproc;
-	fe->ops.asyncinfo.set_frontend_asyncwait = dvb_frontend_asyncwait;
-	fe->ops.asyncinfo.set_frontend_asyncpostproc = dvb_frontend_asyncpostproc;
-
 	dev_info(fe->dvb->device,
 			"DVB: registering adapter %i frontend %i (%s)...\n",
 			fe->dvb->num, fe->id, fe->ops.info.name);
@@ -3283,21 +2621,6 @@
 	dvb_register_device (fe->dvb, &fepriv->dvbdev, &dvbdev_template,
 			     fe, DVB_DEVICE_FRONTEND);
 
-	if(!tongfang_clsp)
-	{
-		int ret = 0;
-		printk("For tongfang\n");
-		tongfang_clsp = class_create(THIS_MODULE,LOCK_DEVICE_NAME);
-		if(!tongfang_clsp)
-		{
-			 printk("[tongfang]%s:create class error.\n",__func__);
-			 return PTR_ERR(tongfang_clsp);
-		}
-		ret = class_create_file(tongfang_clsp, &class_attr_lock_time);
-		if(ret)
-			printk("[tongfang]%s create  class file error.\n",__func__);
-	}
-
 	/*
 	 * Initialize the cache to the proper values according with the
 	 * first supported delivery system (ops->delsys[0])
@@ -3326,8 +2649,6 @@
 
 	mutex_lock(&frontend_mutex);
 	dvb_unregister_device (fepriv->dvbdev);
-	class_remove_file(tongfang_clsp, &class_attr_lock_time);
-	class_destroy(tongfang_clsp);
 
 	/* fe is invalid now */
 	kfree(fepriv);
@@ -3373,17 +2694,3 @@
 }
 #endif
 EXPORT_SYMBOL(dvb_frontend_detach);
-
-void dvb_frontend_retune(struct dvb_frontend *fe)
-{
-	struct dvb_frontend_private *fepriv = fe->frontend_priv;
-
-	fepriv->state = FESTATE_RETUNE;
-
-	fepriv->algo_status |= DVBFE_ALGO_SEARCH_AGAIN;
-
-	dvb_frontend_wakeup(fe);
-	fepriv->status = 0;
-}
-EXPORT_SYMBOL(dvb_frontend_retune);
-
diff -Naur a/drivers/media/dvb-core/dvb_frontend.h b/drivers/media/dvb-core/dvb_frontend.h
--- a/drivers/media/dvb-core/dvb_frontend.h	2015-01-04 18:07:59.000000000 +0100
+++ b/drivers/media/dvb-core/dvb_frontend.h	2014-12-20 18:25:15.000000000 +0100
@@ -71,12 +71,8 @@
 struct analog_parameters {
 	unsigned int frequency;
 	unsigned int mode;
-	unsigned int soundsys;//A2,BTSC/EIAJ/NICAM
 	unsigned int audmode;
-	unsigned int lock_range;
-	unsigned int leap_step;
-	v4l2_std_id std;
-	unsigned int reserved;
+	u64 std;
 };
 
 enum dvbfe_modcod {
@@ -222,8 +218,7 @@
 
 #define TUNER_STATUS_LOCKED 1
 #define TUNER_STATUS_STEREO 2
-	int (*get_status)(struct dvb_frontend *fe, void *status);
-	void (*get_pll_status)(struct dvb_frontend *fe, void *status);
+	int (*get_status)(struct dvb_frontend *fe, u32 *status);
 	int (*get_rf_strength)(struct dvb_frontend *fe, u16 *strength);
 	int (*get_afc)(struct dvb_frontend *fe, s32 *afc);
 
@@ -238,10 +233,6 @@
 	 */
 	int (*set_state)(struct dvb_frontend *fe, enum tuner_param param, struct tuner_state *state);
 	int (*get_state)(struct dvb_frontend *fe, enum tuner_param param, struct tuner_state *state);
-    /*add function to get tuner status*/
-    int (*get_tuner_status)(struct dvb_frontend *fe, tuner_status_t *tuner_status);
-    /*add special fine tune function */
-    int (*fine_tune)(struct dvb_frontend *fe, int offset_khz);
 };
 
 struct analog_demod_info {
@@ -256,10 +247,6 @@
 			   struct analog_parameters *params);
 	int  (*has_signal)(struct dvb_frontend *fe, u16 *signal);
 	int  (*get_afc)(struct dvb_frontend *fe, s32 *afc);
-	int  (*is_stereo)(struct dvb_frontend *fe);
-	int  (*get_snr)(struct dvb_frontend *fe);
-	int (*get_status)(struct dvb_frontend *fe, void *status);
-	void (*get_pll_status)(struct dvb_frontend *fe, void *status);
 	void (*tuner_status)(struct dvb_frontend *fe);
 	void (*standby)(struct dvb_frontend *fe);
 	void (*release)(struct dvb_frontend *fe);
@@ -267,37 +254,10 @@
 
 	/** This is to allow setting tuner-specific configuration */
 	int (*set_config)(struct dvb_frontend *fe, void *priv_cfg);
-    /*add function to get atv_demod & stereo_demod status*/
-    int (*get_atv_status)(struct dvb_frontend *fe, atv_status_t *atv_status);
-    int (*get_sd_status)(struct dvb_frontend *fe, sound_status_t *sd_status);
 };
 
 struct dtv_frontend_properties;
 
-struct dvbsx_blindscan_info {
-	/* timeout of get blindscan event */
-	struct dvbsx_blindscanpara bspara;
-	int (*blindscan_callback)(struct dvb_frontend *fe, struct dvbsx_blindscanevent *pbsevent);
-};
-
-struct dvbsx_blindscan_ops {
-	struct dvbsx_blindscan_info info;
-
-	/*
-	 *  These are provided start and stop blindscan
-	 */
-	int (*blindscan_scan)(struct dvb_frontend* fe, struct dvbsx_blindscanpara *pbspara);
-	int (*blindscan_cancel)(struct dvb_frontend* fe);
-};
-
-struct dvb_frontend_asyncinfo {
-	int set_frontend_asyncenable;
-	int (*set_frontend_asyncpreproc)(struct dvb_frontend *fe);
-	/*return value = 1 interrupt, = 0 timeout,  = -1 error*/
-	int (*set_frontend_asyncwait)(struct dvb_frontend *fe, u32 timeout);
-	int (*set_frontend_asyncpostproc)(struct dvb_frontend *fe, int asyncwait_ret);
-};
-
 struct dvb_frontend_ops {
 
 	struct dvb_frontend_info info;
@@ -322,17 +282,16 @@
 	enum dvbfe_algo (*get_frontend_algo)(struct dvb_frontend *fe);
 
 	/* these two are only used for the swzigzag code */
-	int (*set_frontend)(struct dvb_frontend* fe);
+	int (*set_frontend)(struct dvb_frontend *fe);
 	int (*get_tune_settings)(struct dvb_frontend* fe, struct dvb_frontend_tune_settings* settings);
 
-	int (*get_frontend)(struct dvb_frontend* fe);
+	int (*get_frontend)(struct dvb_frontend *fe);
 
 	int (*read_status)(struct dvb_frontend* fe, fe_status_t* status);
 	int (*read_ber)(struct dvb_frontend* fe, u32* ber);
 	int (*read_signal_strength)(struct dvb_frontend* fe, u16* strength);
 	int (*read_snr)(struct dvb_frontend* fe, u16* snr);
 	int (*read_ucblocks)(struct dvb_frontend* fe, u32* ucblocks);
-	int (*set_qam_mode)(struct dvb_frontend* fe);
 
 	int (*diseqc_reset_overload)(struct dvb_frontend* fe);
 	int (*diseqc_send_master_cmd)(struct dvb_frontend* fe, struct dvb_diseqc_master_cmd* cmd);
@@ -350,22 +309,15 @@
 	 * tuning algorithms, rather than a simple swzigzag
 	 */
 	enum dvbfe_search (*search)(struct dvb_frontend *fe);
-	int (*track)(struct dvb_frontend *fe, struct dvb_frontend_parameters *p);
 
 	struct dvb_tuner_ops tuner_ops;
 	struct analog_demod_ops analog_ops;
 
 	int (*set_property)(struct dvb_frontend* fe, struct dtv_property* tvp);
 	int (*get_property)(struct dvb_frontend* fe, struct dtv_property* tvp);
-
-	struct dvbsx_blindscan_ops blindscan_ops;
-
-	int (*set_mode)(struct dvb_frontend* fe, fe_type_t type);
-	int (*read_ts)(struct dvb_frontend* fe, int *ts);
-
-	struct dvb_frontend_asyncinfo asyncinfo;
 };
 
+#ifdef __DVB_CORE__
 #define MAX_EVENT 8
 
 struct dvb_fe_events {
@@ -376,17 +328,7 @@
 	wait_queue_head_t	  wait_queue;
 	struct mutex		  mtx;
 };
-
-#define MAX_BLINDSCAN_EVENT 32
-
-struct dvbsx_blindscan_events {
-	struct dvbsx_blindscanevent events[MAX_BLINDSCAN_EVENT];
-	int			  eventw;
-	int			  eventr;
-	int			  overflow;
-	wait_queue_head_t	  wait_queue;
-	struct mutex		  mtx;
-};
+#endif
 
 struct dtv_frontend_properties {
 
@@ -411,8 +353,6 @@
 	fe_pilot_t		pilot;
 	fe_rolloff_t		rolloff;
 
-	fe_ofdm_mode_t      ofdm_mode;
-
 	fe_delivery_system_t	delivery_system;
 
 	enum fe_interleaving	interleaving;
@@ -434,11 +374,6 @@
 	/* Multistream specifics */
 	u32			stream_id;
 
-	u32         dvbt2_plp_id;
-
-	/* Analog specifics */
-	struct dvb_analog_parameters analog;
-	struct dvb_analog_parameters param;
 	/* ATSC-MH specifics */
 	u8			atscmh_fic_ver;
 	u8			atscmh_parade_id;
diff -Naur a/include/uapi/linux/dvb/dmx.h b/include/uapi/linux/dvb/dmx.h
--- a/include/uapi/linux/dvb/dmx.h	2015-01-04 18:08:01.000000000 +0100
+++ b/include/uapi/linux/dvb/dmx.h	2014-12-07 20:11:05.000000000 +0100
@@ -130,10 +130,7 @@
 	DMX_SOURCE_DVR0   = 16,
 	DMX_SOURCE_DVR1,
 	DMX_SOURCE_DVR2,
-	DMX_SOURCE_DVR3,
-	DMX_SOURCE_FRONT0_OFFSET = 100,
-	DMX_SOURCE_FRONT1_OFFSET,
-	DMX_SOURCE_FRONT2_OFFSET
+	DMX_SOURCE_DVR3
 } dmx_source_t;
 
 struct dmx_stc {
diff -Naur a/include/uapi/linux/dvb/frontend.h b/include/uapi/linux/dvb/frontend.h
--- a/include/uapi/linux/dvb/frontend.h	2015-01-04 18:08:01.000000000 +0100
+++ b/include/uapi/linux/dvb/frontend.h	2014-12-20 18:25:15.000000000 +0100
@@ -27,26 +27,14 @@
 #define _DVBFRONTEND_H_
 
 #include <linux/types.h>
-#include <linux/videodev2.h>
 
 typedef enum fe_type {
 	FE_QPSK,
 	FE_QAM,
 	FE_OFDM,
-	FE_ATSC,
-	FE_ANALOG,
-	FE_DTMB,
-	FE_ISDBT
+	FE_ATSC
 } fe_type_t;
 
-typedef enum fe_layer {
-	Layer_A_B_C,
-	Layer_A,
-	Layer_B,
-	Layer_C,
-} fe_layer_t;
-
-
 
 typedef enum fe_caps {
 	FE_IS_STUPID			= 0,
@@ -82,7 +70,6 @@
 	FE_CAN_MUTE_TS			= 0x80000000  /* frontend can stop spurious TS data output */
 } fe_caps_t;
 
-#define FE_CAN_3_LAYER FE_CAN_MULTISTREAM
 
 struct dvb_frontend_info {
 	char       name[128];
@@ -119,8 +106,7 @@
 typedef enum fe_sec_voltage {
 	SEC_VOLTAGE_13,
 	SEC_VOLTAGE_18,
-	SEC_VOLTAGE_OFF,
-	SEC_VOLTAGE_ON     // for ISDBT antenna control
+	SEC_VOLTAGE_OFF
 } fe_sec_voltage_t;
 
 
@@ -149,15 +135,14 @@
  */
 
 typedef enum fe_status {
-	FE_HAS_SIGNAL	= 0x01,   /* found something above the noise level */
-	FE_HAS_CARRIER	= 0x02,   /* found a DVB signal  */
-	FE_HAS_VITERBI	= 0x04,   /* FEC is stable  */
-	FE_HAS_SYNC	= 0x08,   /* found sync bytes  */
-	FE_HAS_LOCK	= 0x10,   /* everything's working... */
-	FE_TIMEDOUT	= 0x20,   /* no lock within the last ~2 seconds */
-	FE_REINIT	= 0x40    /* frontend was reinitialized,  */
-} fe_status_t;			  /* application is recommended to reset */
-				  /* DiSEqC, tone and parameters */
+	FE_HAS_SIGNAL		= 0x01,
+	FE_HAS_CARRIER		= 0x02,
+	FE_HAS_VITERBI		= 0x04,
+	FE_HAS_SYNC		= 0x08,
+	FE_HAS_LOCK		= 0x10,
+	FE_TIMEDOUT		= 0x20,
+	FE_REINIT		= 0x40,
+} fe_status_t;
 
 typedef enum fe_spectral_inversion {
 	INVERSION_OFF,
@@ -212,7 +197,7 @@
 	TRANSMISSION_MODE_C3780,
 } fe_transmit_mode_t;
 
-//#if defined(__DVB_CORE__) || !defined (__KERNEL__)
+#if defined(__DVB_CORE__) || !defined (__KERNEL__)
 typedef enum fe_bandwidth {
 	BANDWIDTH_8_MHZ,
 	BANDWIDTH_7_MHZ,
@@ -222,7 +207,7 @@
 	BANDWIDTH_10_MHZ,
 	BANDWIDTH_1_712_MHZ,
 } fe_bandwidth_t;
-//#endif
+#endif
 
 typedef enum fe_guard_interval {
 	GUARD_INTERVAL_1_32,
@@ -254,13 +239,7 @@
 	INTERLEAVING_720,
 };
 
-typedef enum fe_ofdm_mode
-{
-	OFDM_DVBT,
-	OFDM_DVBT2,
-}fe_ofdm_mode_t;
-
-//#if defined(__DVB_CORE__) || !defined (__KERNEL__)
+#if defined(__DVB_CORE__) || !defined (__KERNEL__)
 struct dvb_qpsk_parameters {
 	__u32		symbol_rate;  /* symbol rate in Symbols per second */
 	fe_code_rate_t	fec_inner;    /* forward error correction (see above) */
@@ -284,19 +263,8 @@
 	fe_transmit_mode_t  transmission_mode;
 	fe_guard_interval_t guard_interval;
 	fe_hierarchy_t      hierarchy_information;
-	fe_ofdm_mode_t ofdm_mode;
 };
 
-#define ANALOG_FLAG_ENABLE_AFC                 0X00000001
-#define  ANALOG_FLAG_MANUL_SCAN                0x00000011
-struct dvb_analog_parameters {
-	unsigned int         audmode; /*V4L2_TUNER_MODE_MONO,V4L2_TUNER_MODE_STEREO,V4L2_TUNER_MODE_LANG2,V4L2_TUNER_MODE_SAP,V4L2_TUNER_MODE_LANG1,V4L2_TUNER_MODE_LANG1_LANG2*/
-	unsigned int         soundsys;/*A2,BTSC,EIAJ,NICAM*/
-	v4l2_std_id           std;
-	unsigned int         flag;
-                unsigned int         afc_range;
-        unsigned int         reserved;
-};
 
 struct dvb_frontend_parameters {
 	__u32 frequency;     /* (absolute) frequency in Hz for QAM/OFDM/ATSC */
@@ -307,7 +275,6 @@
 		struct dvb_qam_parameters  qam;
 		struct dvb_ofdm_parameters ofdm;
 		struct dvb_vsb_parameters vsb;
-		struct dvb_analog_parameters analog;
 	} u;
 };
 
@@ -315,7 +282,7 @@
 	fe_status_t status;
 	struct dvb_frontend_parameters parameters;
 };
-//#endif
+#endif
 
 /* S2API Commands */
 #define DTV_UNDEFINED		0
@@ -378,8 +345,6 @@
 
 #define DTV_ENUM_DELSYS		44
 
-#define DTV_DVBT2_PLP_ID    DTV_DVBT2_PLP_ID_LEGACY
-
 /* ATSC-MH */
 #define DTV_ATSCMH_FIC_VER		45
 #define DTV_ATSCMH_PARADE_ID		46
@@ -410,9 +375,7 @@
 #define DTV_STAT_ERROR_BLOCK_COUNT	68
 #define DTV_STAT_TOTAL_BLOCK_COUNT	69
 
-#define DTV_DVBT2_DATA_PLPS	70
-
-#define DTV_MAX_COMMAND			DTV_DVBT2_DATA_PLPS	
+#define DTV_MAX_COMMAND		DTV_STAT_TOTAL_BLOCK_COUNT
 
 typedef enum fe_pilot {
 	PILOT_ON,
@@ -445,9 +408,8 @@
 	SYS_CMMB,
 	SYS_DAB,
 	SYS_DVBT2,
-	SYS_ANALOG,
 	SYS_TURBO,
-	SYS_DVBC_ANNEX_C
+	SYS_DVBC_ANNEX_C,
 } fe_delivery_system_t;
 
 /* backward compatibility */
@@ -589,85 +551,10 @@
 	__u32 num;
 	struct dtv_property *props;
 };
-//for atv
-typedef struct tuner_status_s {
-	unsigned int frequency;
-	unsigned int rssi;
-	unsigned char mode;//dtv:0 or atv:1
-	unsigned char tuner_locked;//notlocked:0,locked:1
-	void 		 *ressrved;
-}tuner_status_t;
-
-typedef struct atv_status_s {
-	unsigned char atv_lock;//notlocked:0,locked 1
-	v4l2_std_id	  std;
-	unsigned int  audmode;
-			 int  snr;
-                         int  afc;
-	void     	  *resrvred;
-}atv_status_t;
-
-typedef struct sound_status_s {
-	unsigned short sound_sys;//A2DK/A2BG/NICAM BG/NICAM DK/BTSC/EIAJ
-	unsigned short sound_mode;//SETERO/DUAL/MONO/SAP
-	void     	       *resrvred;
-}sound_status_t;
-typedef enum tuner_param_cmd_e{
-	TUNER_CMD_AUDIO_MUTE = 0x0000,
-	TUNER_CMD_AUDIO_ON,// 0x0001,
-	TUNER_CMD_TUNER_POWER_ON,
-	TUNER_CMD_TUNER_POWER_DOWN,
-	TUNER_CMD_SET_VOLUME,
-	TUNER_CMD_SET_LEAP_SETP_SIZE,
-	TUNER_CMD_GET_MONO_MODE,
-	TUNER_CMD_SET_BEST_LOCK_RANGE,
-	TUNER_CMD_GET_BEST_LOCK_RANGE,
-	TUNER_CMD_SET_CVBS_AMP_OUT,
-	TUNER_CMD_GET_CVBS_AMP_OUT,
-	TUNER_CMD_NULL,
-}tuner_param_cmd_t;
-/*parameter for set param box*/
-typedef struct tuner_param_s {
-	tuner_param_cmd_t cmd;
-	unsigned int      parm;
-	unsigned int 	  resvred;
-}tuner_param_t;
 
 #define FE_SET_PROPERTY		   _IOW('o', 82, struct dtv_properties)
 #define FE_GET_PROPERTY		   _IOR('o', 83, struct dtv_properties)
 
-/* Satellite blind scan settings */
-struct dvbsx_blindscanpara {
-	__u32 minfrequency;			/* minimum tuner frequency in kHz */
-	__u32 maxfrequency;			/* maximum tuner frequency in kHz */
-	__u32 minSymbolRate;		/* minimum symbol rate in sym/sec */
-	__u32 maxSymbolRate;		/* maximum symbol rate in sym/sec */
-	__u32 frequencyRange;		/* search range in kHz. freq -/+freqRange will be searched */
-	__u32 frequencyStep;			/* tuner step frequency in kHz */
-	__s32 timeout;				/* blindscan event timeout*/
-};
-
-/* Satellite blind scan status */
-typedef enum dvbsx_blindscanstatus {
-	BLINDSCAN_NONEDO,
-	BLINDSCAN_UPDATESTARTFREQ,
-	BLINDSCAN_UPDATEPROCESS,
-	BLINDSCAN_UPDATERESULTFREQ
-} dvbsx_blindscanstatus_t;
-
-/* Satellite blind scan event */
-struct dvbsx_blindscanevent {
-	dvbsx_blindscanstatus_t status;
-	union {
-		__u16 m_uiprogress;							/* The percentage completion of the blind scan procedure. A value of 100 indicates that the blind scan is finished. */
-		__u32 m_uistartfreq_khz;					/* The start scan frequency in units of kHz. The minimum value depends on the tuner specification. */
-		struct dvb_frontend_parameters parameters;	/* Blind scan channel info. */
-	} u;
-};
-
-#define FE_SET_BLINDSCAN					_IOW('o', 84, struct dvbsx_blindscanpara)
-#define FE_GET_BLINDSCANEVENT		   		_IOR('o', 85, struct dvbsx_blindscanevent)
-#define FE_SET_BLINDSCANCANCEl				_IO('o', 86)
 
 /**
  * When set, this flag will disable any zigzagging or other "normal" tuning
@@ -703,16 +590,4 @@
 
 #define FE_DISHNETWORK_SEND_LEGACY_CMD _IO('o', 80) /* unsigned int */
 
-#define FE_SET_DELAY               _IO('o', 100)
-
-
-#define FE_SET_MODE                _IO('o', 90)
-#define FE_READ_AFC                _IOR('o', 91, __u32)
-#define FE_FINE_TUNE               _IOW('o', 92, __u32)
-#define FE_READ_TUNER_STATUS       _IOR('o', 93, tuner_status_t)
-#define FE_READ_ANALOG_STATUS      _IOR('o', 94, atv_status_t)
-#define FE_READ_SD_STATUS          _IOR('o', 95, sound_status_t)
-#define FE_READ_TS                 _IOR('o', 96, int)
-//set & get the tuner parameters only atv
-#define FE_SET_PARAM_BOX           _IOWR('o', 97, tuner_param_t)
 #endif /*_DVBFRONTEND_H_*/
